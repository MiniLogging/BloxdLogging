"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[26],{13012:(L,U,x)=>{x.r(U),x.d(U,{EXT_materials_diffuse_roughness:()=>gU,EXT_mesh_gpu_instancing:()=>wL,GLTF2Export:()=>WL,GLTFData:()=>A,KHR_draco_mesh_compression:()=>xU,KHR_lights_punctual:()=>oU,KHR_materials_anisotropy:()=>hU,KHR_materials_clearcoat:()=>EU,KHR_materials_diffuse_transmission:()=>VU,KHR_materials_dispersion:()=>QU,KHR_materials_emissive_strength:()=>fU,KHR_materials_ior:()=>DU,KHR_materials_iridescence:()=>dU,KHR_materials_sheen:()=>lU,KHR_materials_specular:()=>XU,KHR_materials_transmission:()=>yU,KHR_materials_unlit:()=>NU,KHR_materials_volume:()=>uU,KHR_texture_transform:()=>MU,OBJExport:()=>F,STLExport:()=>JU,USDZExportAsync:()=>Ux,_ConvertToGLTFPBRMetallicRoughness:()=>n,_SolveMetallic:()=>y,__IGLTFExporterExtension:()=>a});var mL=x(12589),p=x(12382),G=x(12915);class F{static OBJ(L,U,x,F){const a=[];let o=1,A=1;U&&(x||(x="mat"),a.push("mtllib "+x+".mtl"));for(let r=0;r<L.length;r++){const x=L[r],h=x.name||`mesh${r}}`;a.push(`o ${h}`);let b=null;if(F){const L=x.fa(!0);b=new mL.Matrix,L.invertToRef(b),x.bakeTransformIntoVertices(L)}if(U){const L=x.material;L&&a.push("usemtl "+L.id)}const E=x.va;if(!E){p.Tools.Warn("No geometry is present on the mesh");continue}const Y=E.getVerticesData("position"),S=E.getVerticesData("normal"),V=E.getVerticesData("uv"),H=E.Da();let Q=0,q=0;if(!Y||!H){p.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const f=L[0].PL().useRightHandedSystem?1:-1;for(let L=0;L<Y.length;L+=3)a.push("v "+Y[L]*f+" "+Y[L+1]+" "+Y[L+2]),Q++;if(null!=S)for(let L=0;L<S.length;L+=3)a.push("vn "+S[L]*f+" "+S[L+1]+" "+S[L+2]);if(null!=V)for(let L=0;L<V.length;L+=2)a.push("vt "+V[L]+" "+V[L+1]),q++;const v=["","",""],D=(x.material||x.PL().defaultMaterial)._getEffectiveOrientation(x),[P,d]=D===G.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let L=0;L<H.length;L+=3){const U=[String(H[L]+o),String(H[L+P]+o),String(H[L+d]+o)],x=[String(H[L]+A),String(H[L+P]+A),String(H[L+d]+A)],mL=U,p=null!=V?x:v,G=null!=S?U:v;a.push("f "+mL[0]+"/"+p[0]+"/"+G[0]+" "+mL[1]+"/"+p[1]+"/"+G[1]+" "+mL[2]+"/"+p[2]+"/"+G[2])}F&&b&&x.bakeTransformIntoVertices(b),o+=Q,A+=q}return a.join("\n")}static MTL(L){const U=[],x=L.material;U.push("newmtl mat1"),U.push("  Ns "+x.specularPower.toFixed(4)),U.push("  Ni 1.5000"),U.push("  d "+x.alpha.toFixed(4)),U.push("  Tr 0.0000"),U.push("  Tf 1.0000 1.0000 1.0000"),U.push("  illum 2"),U.push("  Ka "+x.ambientColor.r.toFixed(4)+" "+x.ambientColor.g.toFixed(4)+" "+x.ambientColor.b.toFixed(4)),U.push("  Kd "+x.diffuseColor.r.toFixed(4)+" "+x.diffuseColor.g.toFixed(4)+" "+x.diffuseColor.b.toFixed(4)),U.push("  Ks "+x.specularColor.r.toFixed(4)+" "+x.specularColor.g.toFixed(4)+" "+x.specularColor.b.toFixed(4)),U.push("  Ke "+x.emissiveColor.r.toFixed(4)+" "+x.emissiveColor.g.toFixed(4)+" "+x.emissiveColor.b.toFixed(4));x.ambientTexture&&U.push("  map_Ka "+x.ambientTexture.name),x.diffuseTexture&&U.push("  map_Kd "+x.diffuseTexture.name),x.specularTexture&&U.push("  map_Ks "+x.specularTexture.name),x.bumpTexture&&U.push("  map_bump -imfchan z "+x.bumpTexture.name),x.opacityTexture&&U.push("  map_d "+x.opacityTexture.name);return U.join("\n")}}var a=0,o=x(12448);class A{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const L in this.files){const U=this.files[L],x=new Blob([U],{type:(0,o.f)(L)});p.Tools.Download(x,L)}}}var r=x(12666),h=x(13015),b=x(13026),E=x(13042),Y=x(12719),S=x(12440),V=x(12637),H=x(12610);const Q=H.HighestCommonFactor,q={...H,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:Q};var f=x(12810),v=x(12565),D=x(13078),P=x(13086),d=x(12803);const K=1e-6,l=new V.QU(.04,.04,.04),i=1024,X=V.QU.White(),t=V.QU.Black();function y(L,U,x){if(U<l.r)return 0;const mL=l.r,p=L*x/(1-l.r)+U-2*l.r,G=p*p-4*mL*(l.r-U);return q.Clamp((-p+Math.sqrt(G))/(2*mL),0,1)}function n(L){const U=L.diffuseColor.toLinearSpace(L.PL().getEngine().useExactSrgbConversions).scale(.5),x=L.alpha,p=function(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new mL.Vector2(0,1),x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new mL.Vector2(0,.1),p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new mL.Vector2(0,.1),G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new mL.Vector2(1300,.1);return function(L,U,x,mL,p){return(1-L)*(1-L)*(1-L)*U+3*(1-L)*(1-L)*L*x+3*(1-L)*L*L*mL+L*L*L*p}(Math.pow(L/G.x,.333333),U.y,x.y,p.y,G.y)}(q.Clamp(L.specularPower,0,i));return{baseColorFactor:[U.r,U.g,U.b,x],metallicFactor:0,roughnessFactor:p}}function N(L,U){U.needAlphaBlending()?L.alphaMode="BLEND":U.needAlphaTesting()&&(L.alphaMode="MASK",L.alphaCutoff=U.alphaCutOff)}function e(L,U,x){const mL=new Uint8Array(L*U*4);for(let p=0;p<mL.length;p+=4)mL[p]=mL[p+1]=mL[p+2]=mL[p+3]=255;return D.b.CreateRGBATexture(mL,L,U,x)}function u(L){if(L instanceof Uint8Array){const U=L.length,x=new Float32Array(L.length);for(let mL=0;mL<U;++mL)x[mL]=L[mL]/255;return x}if(L instanceof Float32Array)return L;throw new Error("Unsupported pixel format!")}class Z{constructor(L){this._exporter=L,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(L){return L?this._textureMap.get(L)??null:null}async exportStandardMaterialAsync(L,U,x){const mL=n(L),G={name:L.name};if(null==L.Pa||L.Pa||(L.twoSidedLighting||p.Tools.Warn(L.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),G.doubleSided=!0),x){const x=[],p=L.diffuseTexture;p&&x.push(this.exportTextureAsync(p,U).then((L=>{L&&(mL.baseColorTexture=L)})));const F=L.bumpTexture;F&&x.push(this.exportTextureAsync(F,U).then((L=>{L&&(G.normalTexture=L,1!==F.level&&(G.normalTexture.scale=F.level))})));const a=L.emissiveTexture;a&&(G.emissiveFactor=[1,1,1],x.push(this.exportTextureAsync(a,U).then((L=>{L&&(G.emissiveTexture=L)}))));const o=L.ambientTexture;o&&x.push(this.exportTextureAsync(o,U).then((L=>{if(L){const U={index:L.index};G.occlusionTexture=U}}))),x.length>0&&(this._exporter._materialNeedsUVsSet.add(L),await Promise.all(x))}(L.alpha<1||L.opacityTexture)&&(L.alphaMode===P.d.ALPHA_COMBINE?G.alphaMode="BLEND":p.Tools.Warn(L.name+": glTF 2.0 does not support alpha mode: "+L.alphaMode.toString())),L.emissiveColor&&!L.emissiveColor.equalsWithEpsilon(t,K)&&(G.emissiveFactor=L.emissiveColor.Va()),G.pbrMetallicRoughness=mL,N(G,L),await this._finishMaterialAsync(G,L,U);const F=this._exporter._materials;return F.push(G),F.length-1}async _finishMaterialAsync(L,U,x){const mL=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",L,U),p=[];for(const G of mL)p.push(this.exportTextureAsync(G,x));await Promise.all(p),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",L,U)}async _getImageDataAsync(L,U,mL,p){const G=P.d.TEXTURETYPE_UNSIGNED_BYTE,F=this._exporter._babylonScene,a=F.getEngine(),o=a.createRawTexture(L,U,mL,P.d.TEXTUREFORMAT_RGBA,!1,!0,v.e.NEAREST_SAMPLINGMODE,null,G);a.isWebGPU?await x.e(51).then(x.bind(x,15102)):await x.e(52).then(x.bind(x,15108)),await f.n.ApplyPostProcess("pass",o,F,G,P.d.TEXTURE_NEAREST_SAMPLINGMODE,P.d.TEXTUREFORMAT_RGBA);const A=await a._readTexturePixels(o,U,mL);return await d.DumpTools.DumpDataAsync(U,mL,A,p,void 0,!0,!0)}_resizeTexturesToSameDimensions(L,U,x){const mL=L?L.getSize():{width:0,height:0},p=U?U.getSize():{width:0,height:0};let G,F;return mL.width<p.width?(G=L&&L instanceof v.e?f.n.CreateResizedCopy(L,p.width,p.height,!0):e(p.width,p.height,x),F=U):mL.width>p.width?(F=U&&U instanceof v.e?f.n.CreateResizedCopy(U,mL.width,mL.height,!0):e(mL.width,mL.height,x),G=L):(G=L,F=U),{texture1:G,texture2:F}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(L,U,x,mL){const p=new Array;if(!L&&!U)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const G=L?L.PL():U?U.PL():null;if(G){var F;const a=this._resizeTexturesToSameDimensions(L,U,G),o=null===(F=a.texture1)||void 0===F?void 0:F.getSize();let A,r;const h=o.width,b=o.height,E=await a.texture1.readPixels(),Y=await a.texture2.readPixels();if(!E)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(A=u(E),!Y)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");r=u(Y);const S=r.byteLength,H=new Uint8Array(S),Q=new Uint8Array(S),q=4,f=t;let v=0,D=0;for(let L=0;L<b;++L)for(let U=0;U<h;++U){const mL=(h*L+U)*q,p={diffuseColor:new V.QU(A[mL],A[mL+1],A[mL+2]).toLinearSpace(G.getEngine().useExactSrgbConversions).multiply(x.diffuseColor),specularColor:new V.QU(r[mL],r[mL+1],r[mL+2]).toLinearSpace(G.getEngine().useExactSrgbConversions).multiply(x.specularColor),glossiness:r[mL+3]*x.glossiness},F=this._convertSpecularGlossinessToMetallicRoughness(p);f.r=Math.max(f.r,F.baseColor.r),f.g=Math.max(f.g,F.baseColor.g),f.b=Math.max(f.b,F.baseColor.b),v=Math.max(v,F.metallic),D=Math.max(D,F.roughness),Q[mL]=255*F.baseColor.r,Q[mL+1]=255*F.baseColor.g,Q[mL+2]=255*F.baseColor.b,Q[mL+3]=a.texture1.Ha?255*A[mL+3]:255,H[mL]=0,H[mL+1]=255*F.roughness,H[mL+2]=255*F.metallic,H[mL+3]=255}const P={baseColor:f,metallic:v,roughness:D};let d=!1,l=!1;for(let L=0;L<b;++L)for(let U=0;U<h;++U){const x=(h*L+U)*q;Q[x]/=P.baseColor.r>K?P.baseColor.r:1,Q[x+1]/=P.baseColor.g>K?P.baseColor.g:1,Q[x+2]/=P.baseColor.b>K?P.baseColor.b:1;const mL=V.QU.FromInts(Q[x],Q[x+1],Q[x+2]).toGammaSpace(G.getEngine().useExactSrgbConversions);Q[x]=255*mL.r,Q[x+1]=255*mL.g,Q[x+2]=255*mL.b,mL.equalsWithEpsilon(X,K)||(l=!0),H[x+1]/=P.roughness>K?P.roughness:1,H[x+2]/=P.metallic>K?P.metallic:1;V.QU.FromInts(255,H[x+1],H[x+2]).equalsWithEpsilon(X,K)||(d=!0)}return d&&p.push(this._getImageDataAsync(H,h,b,mL).then((L=>{P.metallicRoughnessTextureData=L}))),l&&p.push(this._getImageDataAsync(Q,h,b,mL).then((L=>{P.baseColorTextureData=L}))),await Promise.all(p).then((()=>P))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(L){const U=this._getPerceivedBrightness(L.diffuseColor),x=this._getPerceivedBrightness(L.specularColor),mL=1-this._getMaxComponent(L.specularColor),p=y(U,x,mL),G=L.diffuseColor.scale(mL/(1-l.r)/Math.max(1-p)),F=L.specularColor.SU(l.scale(1-p)).scale(1/Math.max(p));let a=V.QU.Lerp(G,F,p*p);a=a.clampToRef(0,1,a);return{baseColor:a,metallic:p,roughness:1-L.glossiness}}_getPerceivedBrightness(L){return L?Math.sqrt(.299*L.r*L.r+.587*L.g*L.g+.114*L.b*L.b):0}_getMaxComponent(L){return L?Math.max(L.r,Math.max(L.g,L.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(L,U,x,mL){const p=[],G={baseColor:L._albedoColor,metallic:L._metallic,roughness:L._roughness};if(mL){L._albedoTexture&&p.push(this.exportTextureAsync(L._albedoTexture,U).then((L=>{L&&(x.baseColorTexture=L)})));const mL=L._metallicTexture;mL&&p.push(this.exportTextureAsync(mL,U).then((L=>{L&&(x.metallicRoughnessTexture=L)})))}return p.length>0&&(this._exporter._materialNeedsUVsSet.add(L),await Promise.all(p)),G}_getTextureSampler(L){const U={};if(!L||!(L instanceof v.e))return U;const x=this._getGLTFTextureWrapMode(L.wrapU);10497!==x&&(U.wrapS=x);const mL=this._getGLTFTextureWrapMode(L.wrapV);switch(10497!==mL&&(U.wrapT=mL),L.samplingMode){case v.e.LINEAR_LINEAR:U.magFilter=9729,U.minFilter=9729;break;case v.e.LINEAR_NEAREST:U.magFilter=9729,U.minFilter=9728;break;case v.e.NEAREST_LINEAR:U.magFilter=9728,U.minFilter=9729;break;case v.e.NEAREST_LINEAR_MIPLINEAR:U.magFilter=9728,U.minFilter=9987;break;case v.e.NEAREST_NEAREST:U.magFilter=9728,U.minFilter=9728;break;case v.e.NEAREST_LINEAR_MIPNEAREST:U.magFilter=9728,U.minFilter=9985;break;case v.e.LINEAR_NEAREST_MIPNEAREST:U.magFilter=9729,U.minFilter=9984;break;case v.e.LINEAR_NEAREST_MIPLINEAR:U.magFilter=9729,U.minFilter=9986;break;case v.e.NEAREST_NEAREST_MIPLINEAR:U.magFilter=9728,U.minFilter=9986;break;case v.e.LINEAR_LINEAR_MIPLINEAR:U.magFilter=9729,U.minFilter=9987;break;case v.e.LINEAR_LINEAR_MIPNEAREST:U.magFilter=9729,U.minFilter=9985;break;case v.e.NEAREST_NEAREST_MIPNEAREST:U.magFilter=9728,U.minFilter=9984}return U}_getGLTFTextureWrapMode(L){switch(L){case v.e.WRAP_ADDRESSMODE:return 10497;case v.e.CLAMP_ADDRESSMODE:return 33071;case v.e.MIRROR_ADDRESSMODE:return 33648;default:return p.Tools.Error(`Unsupported Texture Wrap Mode ${L}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(L,U,x,mL){const p={diffuseColor:L._albedoColor,specularColor:L._reflectivityColor,glossiness:L._microSurface},G=L._albedoTexture,F=L._reflectivityTexture,a=L._useMicroSurfaceFromReflectivityMapAlpha;if(F&&!a)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((G||F)&&mL){this._exporter._materialNeedsUVsSet.add(L);const mL=this._exportTextureSampler(G||F),a=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(G,F,p,U),o=this._exporter._textures;if(a.baseColorTextureData){const L=this._exportImage(`baseColor${o.length}`,U,a.baseColorTextureData);x.baseColorTexture=this._exportTextureInfo(L,mL,null===G||void 0===G?void 0:G.coordinatesIndex)}if(a.metallicRoughnessTextureData){const L=this._exportImage(`metallicRoughness${o.length}`,U,a.metallicRoughnessTextureData);x.metallicRoughnessTexture=this._exportTextureInfo(L,mL,null===F||void 0===F?void 0:F.coordinatesIndex)}return a}return this._convertSpecularGlossinessToMetallicRoughness(p)}async exportPBRMaterialAsync(L,U,x){const mL={},p={name:L.name},G=L.isMetallicWorkflow();if(G){const U=L._albedoColor,x=L.alpha;U&&(mL.baseColorFactor=[U.r,U.g,U.b,x])}const F=G?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(L,U,mL,x):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(L,U,mL,x);await this._setMetallicRoughnessPbrMaterialAsync(F,L,p,mL,U,x),await this._finishMaterialAsync(p,L,U);const a=this._exporter._materials;return a.push(p),a.length-1}async _setMetallicRoughnessPbrMaterialAsync(L,U,x,mL,G,F){if(N(x,U),L.baseColor.equalsWithEpsilon(X,K)&&q.WithinEpsilon(U.alpha,1,K)||(mL.baseColorFactor=[L.baseColor.r,L.baseColor.g,L.baseColor.b,U.alpha]),null!=L.metallic&&1!==L.metallic&&(mL.metallicFactor=L.metallic),null!=L.roughness&&1!==L.roughness&&(mL.roughnessFactor=L.roughness),null==U.Pa||U.Pa||(U._twoSidedLighting||p.Tools.Warn(U.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),x.doubleSided=!0),F){const L=[],mL=U._bumpTexture;mL&&L.push(this.exportTextureAsync(mL,G).then((L=>{L&&(x.normalTexture=L,1!==mL.level&&(x.normalTexture.scale=mL.level))})));const p=U._ambientTexture;p&&L.push(this.exportTextureAsync(p,G).then((L=>{if(L){const mL={index:L.index,texCoord:L.texCoord,extensions:L.extensions};x.occlusionTexture=mL;const p=U._ambientTextureStrength;p&&(mL.strength=p)}})));const F=U._emissiveTexture;F&&L.push(this.exportTextureAsync(F,G).then((L=>{L&&(x.emissiveTexture=L)}))),L.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(L))}const a=U._emissiveColor;a.equalsWithEpsilon(t,K)||(x.emissiveFactor=a.Va()),x.pbrMetallicRoughness=mL}_getPixelsFromTextureAsync(L){return function(L){switch(L){case P.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case P.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case P.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case P.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case P.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case P.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case P.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case P.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case P.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case P.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case P.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case P.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case P.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case P.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case P.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case P.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case P.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case P.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case P.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case P.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case P.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(L.textureFormat)?(0,f.j)(L,L._texture.width,L._texture.height):(L.textureType,P.d.TEXTURETYPE_UNSIGNED_BYTE,L.readPixels())}async exportTextureAsync(L,U){const x=this._exporter._extensionsPreExportTextureAsync("exporter",L,U);return x?await x.then((async x=>x?await this._exportTextureInfoAsync(x,U):await this._exportTextureInfoAsync(L,U))):await this._exportTextureInfoAsync(L,U)}async _exportTextureInfoAsync(L,U){let x=this._textureMap.get(L);if(!x){const mL=await this._getPixelsFromTextureAsync(L);if(!mL)return null;const G=this._exportTextureSampler(L),F=L.mimeType;if(F)switch(F){case"image/jpeg":case"image/png":case"image/webp":U=F;break;default:p.Tools.Warn(`Unsupported media type: ${F}. Exporting texture as PNG.`)}const a=this._internalTextureToImage,o=L.getInternalTexture().uniqueId;a[o]||(a[o]={});let A=a[o][U];if(void 0===A){const x=L.getSize();A=(async()=>{const p=await this._getImageDataAsync(mL,x.width,x.height,U);return this._exportImage(L.name,U,p)})(),a[o][U]=A}x=this._exportTextureInfo(await A,G,L.coordinatesIndex),this._textureMap.set(L,x),this._exporter._extensionsPostExportTextures("exporter",x,L)}return x}_exportImage(L,U,x){const mL=this._exporter._images;let G;if(this._exporter._shouldUseGlb){G={name:L,mimeType:U,bufferView:void 0};const mL=this._exporter._bufferManager.createBufferView(new Uint8Array(x));this._exporter._bufferManager.setBufferView(G,mL)}else{const F=L.replace(/\.\/|\/|\.\\|\\/g,"_"),a=function(L){switch(L){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(U);let o=F+a;mL.some((L=>L.uri===o))&&(o=`${F}_${p.Tools.RandomId()}${a}`),G={name:L,uri:o},this._exporter._imageData[o]={data:x,mimeType:U}}return mL.push(G),mL.length-1}_exportTextureInfo(L,U,x){const mL=this._exporter._textures;let p=mL.findIndex((x=>x.sampler==U&&x.source===L));-1===p&&(p=mL.length,mL.push({source:L,sampler:U}));const G={index:p};return x&&(G.texCoord=x),G}_exportTextureSampler(L){const U=this._getTextureSampler(L),x=this._exporter._samplers,mL=x.findIndex((L=>L.minFilter===U.minFilter&&L.magFilter===U.magFilter&&L.wrapS===U.wrapS&&L.wrapT===U.wrapT));return-1!==mL?mL:(x.push(U),x.length-1)}}var g=x(12675),z=x(12406),M=x(13093),J=x(12598);const j=mL.YU.Zero(),R=mL.Quaternion.Identity(),c=mL.YU.One(),W=new mL.YU(-1,1,1);function I(L,U){const{byteOffset:x,byteStride:mL,type:p,normalized:G}=L,F=L.getSize(),a=U.reduce(((L,U)=>U.getTotalVertices()>L?U.getTotalVertices():L),-Number.MAX_VALUE);return{byteOffset:x,byteStride:mL,componentCount:F,type:p,count:a*F,normalized:G,totalVertices:a,kind:L.getKind()}}function w(L){switch(L){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function B(L){switch(L){case r.h.PositionKind:case r.h.NormalKind:case r.h.TangentKind:case r.h.ColorKind:case r.h.MatricesIndicesKind:case r.h.MatricesIndicesExtraKind:case r.h.MatricesWeightsKind:case r.h.MatricesWeightsExtraKind:case r.h.UVKind:case r.h.UV2Kind:case r.h.UV3Kind:case r.h.UV4Kind:case r.h.UV5Kind:case r.h.UV6Kind:return!0}return!1}function s(L){switch(L){case G.c.TriangleFillMode:return 4;case G.c.TriangleStripDrawMode:return 5;case G.c.TriangleFanDrawMode:return 6;case G.c.PointListDrawMode:case G.c.PointFillMode:return 0;case G.c.LineLoopDrawMode:return 2;case G.c.LineListDrawMode:return 1;case G.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${L}`)}function C(L){const U=Math.sqrt(L.x*L.x+L.y*L.y+L.z*L.z);U>0&&(L.x/=U,L.y/=U,L.z/=U)}function k(L){return L.x*=-1,L}function T(L){if(L.x*L.x+L.y*L.y>.5){const U=Math.abs(L.x),x=Math.abs(L.y);if(U>x){const x=Math.sign(L.x);L.x=U,L.y*=-x,L.z*=-x,L.w*=x}else{const U=Math.sign(L.y);L.x*=-U,L.y=x,L.z*=U,L.w*=-U}}else{const U=Math.abs(L.z),x=Math.abs(L.w);if(U>x){const x=Math.sign(L.z);L.x*=-x,L.y*=x,L.z=U,L.w*=-x}else{const U=Math.sign(L.w);L.x*=U,L.y*=-U,L.z*=-U,L.w=x}}return L}function O(L){L.da(-L.z,L.w,L.x,-L.y)}function LL(L,U){const x=mL.YU.FromArrayToRef(U.translation||[0,0,0],0,mL.TmpVectors.YU[0]),p=mL.Quaternion.FromArrayToRef(U.rotation||[0,0,0,1],0,mL.TmpVectors.Quaternion[0]),G=mL.Matrix.ComposeToRef(c,p,x,mL.TmpVectors.Matrix[0]),F=mL.YU.FromArrayToRef(L.translation||[0,0,0],0,mL.TmpVectors.YU[2]),a=mL.Quaternion.FromArrayToRef(L.rotation||[0,0,0,1],0,mL.TmpVectors.Quaternion[1]),o=mL.Matrix.ComposeToRef(c,a,F,mL.TmpVectors.Matrix[1]);G.multiplyToRef(o,o),o.decompose(void 0,p,x),x.equalsWithEpsilon(j,J.c)?delete U.translation:U.translation=x.Va(),p.equalsWithEpsilon(R,J.c)?delete U.rotation:U.rotation=p.Va(),U.scale&&delete U.scale}function UL(L,U){if(!(U instanceof h.e))return!1;if(!(1===U.getChildren().length&&0===L.getChildren().length&&L.parent===U))return!1;const x=L.PL(),mL=L instanceof M.b&&!x.useRightHandedSystem?W:c;return!!U.Ka.equalsWithEpsilon(mL,J.c)||(z.c.Warn(`Cannot collapse node ${L.name} into parent node ${U.name} with modified scaling.`),!1)}function xL(L){if(L instanceof Array){const U=new Float32Array(L);return new Uint8Array(U.buffer,U.byteOffset,U.byteLength)}return ArrayBuffer.isView(L)?new Uint8Array(L.buffer,L.byteOffset,L.byteLength):new Uint8Array(L)}function mU(L,U){for(const[x,mL]of Object.entries(L)){const p=U[x];(Array.isArray(mL)&&Array.isArray(p)&&pL(mL,p)||mL===p)&&delete L[x]}return L}function pL(L,U){return L.length===U.length&&L.every(((L,x)=>L===U[x]))}const GL=mL.Matrix.Compose(new mL.YU(-1,1,1),mL.Quaternion.Identity(),mL.YU.Zero());function FL(L,U){if(!(L instanceof h.e))return!1;if(U){if(!L.getWorldMatrix().equalsWithEpsilon(mL.Matrix.IdentityReadOnly,J.c))return!1}else{if(!L.getWorldMatrix().multiplyToRef(GL,mL.TmpVectors.Matrix[0]).equalsWithEpsilon(mL.Matrix.IdentityReadOnly,J.c))return!1}return!(L instanceof b.c&&L.va)}const aL=new Map([[Int8Array,(L,U,x)=>L.setInt8(U,x)],[Uint8Array,(L,U,x)=>L.setUint8(U,x)],[Uint8ClampedArray,(L,U,x)=>L.setUint8(U,x)],[Int16Array,(L,U,x)=>L.setInt16(U,x,!0)],[Uint16Array,(L,U,x)=>L.setUint16(U,x,!0)],[Int32Array,(L,U,x)=>L.setInt32(U,x,!0)],[Uint32Array,(L,U,x)=>L.setUint32(U,x,!0)],[Float32Array,(L,U,x)=>L.setFloat32(U,x,!0)],[Float64Array,(L,U,x)=>L.setFloat64(U,x,!0)]]);class oL{writeTypedArray(L){this._checkGrowBuffer(L.byteLength);const U=aL.get(L.constructor);for(let x=0;x<L.length;x++)U(this._dataView,this._byteOffset,L[x]),this._byteOffset+=L.BYTES_PER_ELEMENT}constructor(L){this._data=new Uint8Array(L),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(L){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,L),this._byteOffset++}writeInt8(L){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,L),this._byteOffset++}writeInt16(L){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,L,!0),this._byteOffset+=2}writeUInt16(L){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,L,!0),this._byteOffset+=2}writeInt32(L){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,L,!0),this._byteOffset+=4}writeUInt32(L){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,L,!0),this._byteOffset+=4}writeFloat32(L){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,L,!0),this._byteOffset+=4}writeFloat64(L){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,L,!0),this._byteOffset+=8}_checkGrowBuffer(L){const U=this.byteOffset+L;if(U>this._data.byteLength){const L=new Uint8Array(2*U);L.set(this._data),this._data=L,this._dataView=new DataView(this._data.buffer)}}}function AL(L){return L%4===0?4:L%2===0?2:1}class rL{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(L){let U=0;this._bufferViewToData.forEach((L=>{U+=L.byteLength}));const x=new oL(U),mL=Array.from(this._bufferViewToData.keys()).sort(((L,U)=>AL(U.byteLength)-AL(L.byteLength)));for(const p of mL){p.byteOffset=x.byteOffset,L.push(p);const U=L.length-1,mL=this.getPropertiesWithBufferView(p);for(const L of mL)L.bufferView=U;x.writeTypedArray(this._bufferViewToData.get(p)),this._bufferViewToData.delete(p)}return x.getOutputData()}createBufferView(L,U){const x={buffer:0,byteOffset:void 0,byteLength:L.byteLength,byteStride:U};return this._bufferViewToData.set(x,L),x}createAccessor(L,U,x,mL,p,G,F){this._verifyBufferView(L);const a={bufferView:void 0,componentType:x,count:mL,type:U,min:null===G||void 0===G?void 0:G.min,max:null===G||void 0===G?void 0:G.max,normalized:F,byteOffset:p};return this.setBufferView(a,L),this._accessorToBufferView.set(a,L),a}setBufferView(L,U){this._verifyBufferView(U);this.getPropertiesWithBufferView(U).push(L)}removeBufferView(L){const U=this.getPropertiesWithBufferView(L);for(const x of U)void 0!==x.bufferView&&delete x.bufferView;this._bufferViewToData.delete(L),this._bufferViewToProperties.delete(L),this._accessorToBufferView.forEach(((U,x)=>{U===L&&(void 0!==x.byteOffset&&delete x.byteOffset,this._accessorToBufferView.delete(x))}))}getBufferView(L){const U=this._accessorToBufferView.get(L);return this._verifyBufferView(U),U}getPropertiesWithBufferView(L){return this._verifyBufferView(L),this._bufferViewToProperties.set(L,this._bufferViewToProperties.get(L)??[]),this._bufferViewToProperties.get(L)}getData(L){return this._verifyBufferView(L),this._bufferViewToData.get(L)}_verifyBufferView(L){if(void 0===L||!this._bufferViewToData.has(L))throw new Error(`BufferView ${L} not found in BufferManager.`)}}var hL,bL=x(13052),EL=x(13075),YL=x(13102),SL=x(12968),VL=x(13133),HL=x(13143),QL=x(13046),qL=x(13150);!function(L){L[L.INTANGENT=0]="INTANGENT",L[L.OUTTANGENT=1]="OUTTANGENT"}(hL||(hL={}));class fL{static _IsTransformable(L){return L&&(L instanceof h.e||L instanceof bL.c||L instanceof qL.d)}static _CreateNodeAnimation(L,U,x,mL,G){if(this._IsTransformable(L)){const F=[],a=[],o=U.getKeys(),A=fL._CalculateMinMaxKeyFrames(o),r=fL._DeduceInterpolation(o,x,mL),h=r.interpolationType,b=r.shouldBakeAnimation;if(b?fL._CreateBakedAnimation(L,U,x,A.min,A.max,U.framePerSecond,G,F,a,A,mL):"LINEAR"===h||"STEP"===h?fL._CreateLinearOrStepAnimation(L,U,x,F,a,mL):"CUBICSPLINE"===h?fL._CreateCubicSplineAnimation(L,U,x,F,a,mL):fL._CreateBakedAnimation(L,U,x,A.min,A.max,U.framePerSecond,G,F,a,A,mL),F.length&&a.length){return{inputs:F,outputs:a,samplerInterpolation:h,inputsMin:b?A.min:p.Tools.FloatRound(A.min/U.framePerSecond),inputsMax:b?A.max:p.Tools.FloatRound(A.max/U.framePerSecond)}}}return null}static _DeduceAnimationInfo(L){let U=null,x="VEC3",mL=!1;const G=L.targetProperty.split(".");switch(G[0]){case"Ka":U="scale";break;case"position":U="translation";break;case"rotation":x="VEC4",U="rotation";break;case"rotationQuaternion":x="VEC4",mL=!0,U="rotation";break;case"influence":x="SCALAR",U="weights";break;default:p.Tools.Error(`Unsupported animatable property ${G[0]}`)}return U?{animationChannelTargetPath:U,dataAccessorType:x,useQuaternion:mL}:(p.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(L,U,x,mL,p,G,F,a,o,A,r){let h;if(fL._IsTransformable(L)&&L.animations)for(const b of L.animations){if(r&&!r(b))continue;const p=fL._DeduceAnimationInfo(b);p&&(h={name:b.name,samplers:[],channels:[]},fL._AddAnimation(`${b.name}`,b.hasRunningRuntimeAnimations?U:h,L,b,p.dataAccessorType,p.animationChannelTargetPath,mL,G,F,a,p.useQuaternion,o,A),h.samplers.length&&h.channels.length&&x.push(h))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(L,U,x,mL,p,G,F,a,o,A,r){let h;if(L instanceof QL.e){const p=L.morphTargetManager;if(p)for(let b=0;b<p.numTargets;++b){const E=p.getTarget(b);for(const Y of E.animations){if(r&&!r(Y))continue;const E=new VL.c(`${Y.name}`,"influence",Y.framePerSecond,Y.dataType,Y.loopMode,Y.enableBlending),S=[],V=Y.getKeys();for(let L=0;L<V.length;++L){const U=V[L];for(let L=0;L<p.numTargets;++L)L==b?S.push(U):S.push({frame:U.frame,value:0})}E.setKeys(S);const H=fL._DeduceAnimationInfo(E);H&&(h={name:E.name,samplers:[],channels:[]},fL._AddAnimation(Y.name,Y.hasRunningRuntimeAnimations?U:h,L,E,H.dataAccessorType,H.animationChannelTargetPath,mL,G,F,a,H.useQuaternion,o,A,p.numTargets),h.samplers.length&&h.channels.length&&x.push(h))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(L,U,x,mL,p,G,F,a,o){let A;if(L.animationGroups){const h=L.animationGroups;for(const b of h){const h=new Map,E=new Map,Y=new Set,S=b.to-b.from;A={name:b.name,channels:[],samplers:[]};for(let U=0;U<b.targetedAnimations.length;++U){const S=b.targetedAnimations[U],V=S.target,H=S.animation;if(o&&!o(H))continue;const Q=a.has(V);if(this._IsTransformable(V)||1===V.length&&this._IsTransformable(V[0])){const L=fL._DeduceAnimationInfo(S.animation);if(L){const U=this._IsTransformable(V)?V:this._IsTransformable(V[0])?V[0]:null;U&&fL._AddAnimation(`${H.name}`,A,U,H,L.dataAccessorType,L.animationChannelTargetPath,x,mL,p,G,L.useQuaternion,F,Q)}}else if(V instanceof HL.b||1===V.length&&V[0]instanceof HL.b){if(fL._DeduceAnimationInfo(S.animation)){const U=V instanceof HL.b?V:V[0];if(U){const x=L.morphTargetManagers.find((L=>{for(let x=0;x<L.numTargets;++x)if(L.getTarget(x)===U)return!0;return!1}));if(x){const mL=L.meshes.find((L=>L.morphTargetManager===x));var r;if(mL)h.has(mL)||h.set(mL,new Map),null===(r=h.get(mL))||void 0===r||r.set(U,H),Y.add(mL),E.set(mL,H)}}}}}Y.forEach((L=>{const U=L.morphTargetManager;let a=null;const o=[],r=E.get(L).getKeys(),Y=r.length;for(let x=0;x<Y;++x)for(let mL=0;mL<U.numTargets;++mL){const p=U.getTarget(mL),G=h.get(L);if(G){const U=G.get(p);U?(a||(a=new VL.c(`${b.name}_${L.name}_MorphWeightAnimation`,"influence",U.framePerSecond,VL.c.ANIMATIONTYPE_FLOAT,U.loopMode,U.enableBlending)),o.push(U.getKeys()[x])):o.push({frame:b.from+S/Y*x,value:p.influence,inTangent:r[0].inTangent?0:void 0,outTangent:r[0].outTangent?0:void 0})}}a.setKeys(o);const V=fL._DeduceAnimationInfo(a);V&&fL._AddAnimation(`${b.name}_${L.name}_MorphWeightAnimation`,A,L,a,V.dataAccessorType,V.animationChannelTargetPath,x,mL,p,G,V.useQuaternion,F,!1,null===U||void 0===U?void 0:U.numTargets)})),A.channels.length&&A.samplers.length&&U.push(A)}}}static _AddAnimation(L,U,x,p,G,F,a,o,A,r,h,b,E,Y){const S=fL._CreateNodeAnimation(x,p,F,h,b);let V,H,Q,q,f,v;if(S){if(Y){let L=0,U=0;const x=[];for(;S.inputs.length>0;)U=S.inputs.shift(),L%Y==0&&x.push(U),L++;S.inputs=x}const L=a.get(x),p=new Float32Array(S.inputs);V=o.createBufferView(p),H=o.createAccessor(V,"SCALAR",5126,S.inputs.length,void 0,{min:[S.inputsMin],max:[S.inputsMax]}),r.push(H),Q=r.length-1;const A=new mL.Quaternion,h=new mL.YU,b=new mL.YU,D=x instanceof bL.c,P=w(G),d=new Float32Array(S.outputs.length*P);S.outputs.forEach((function(L,U){let x=L;switch(F){case"translation":E&&(mL.YU.FromArrayToRef(L,0,b),k(b),b.toArray(x));break;case"rotation":4===L.length?mL.Quaternion.FromArrayToRef(L,0,A):(x=new Array(4),mL.YU.FromArrayToRef(L,0,h),mL.Quaternion.FromEulerVectorToRef(h,A)),E&&(T(A),D&&O(A)),A.toArray(x)}d.set(x,U*P)})),V=o.createBufferView(d),H=o.createAccessor(V,G,5126,S.outputs.length),r.push(H),q=r.length-1,f={interpolation:S.samplerInterpolation,input:Q,output:q},U.samplers.push(f),v={sampler:U.samplers.length-1,target:{node:L,path:F}},U.channels.push(v)}}static _CreateBakedAnimation(L,U,x,G,F,a,o,A,r,h,b){let E;const Y=mL.Quaternion.Identity();let S,V=null,H=null,Q=null,q=null,f=null,v=null;h.min=p.Tools.FloatRound(G/a);const D=U.getKeys();for(let mL=0,P=D.length;mL<P;++mL){if(v=null,Q=D[mL],mL+1<P)if(q=D[mL+1],Q.value.equals&&Q.value.equals(q.value)||Q.value===q.value){if(0!==mL)continue;v=Q.frame}else v=q.frame;else{if(f=D[mL-1],Q.value.equals&&Q.value.equals(f.value)||Q.value===f.value)continue;v=F}if(v)for(let mL=Q.frame;mL<=v;mL+=o){if(S=p.Tools.FloatRound(mL/a),S===V)continue;V=S,H=S;const G={key:0,repeatCount:0,loopMode:U.loopMode};E=U._interpolate(mL,G),fL._SetInterpolatedValue(L,E,S,U,x,Y,A,r,b)}}H&&(h.max=H)}static _ConvertFactorToVector3OrQuaternion(L,U,x,G,F){const a=fL._GetBasePositionRotationOrScale(U,G,F),o=x.targetProperty.split("."),A=o?o[1]:"",r=F?mL.Quaternion.qU(a).normalize():mL.YU.qU(a);switch(A){case"x":case"y":case"z":r[A]=L;break;case"w":r.w=L;break;default:p.Tools.Error(`glTFAnimation: Unsupported component name "${A}"!`)}return r}static _SetInterpolatedValue(L,U,x,p,G,F,a,o,A){let r;a.push(x),"weights"!==G?(p.dataType===VL.c.ANIMATIONTYPE_FLOAT&&(U=this._ConvertFactorToVector3OrQuaternion(U,L,p,G,A)),"rotation"===G?(A?F=U:(r=U,mL.Quaternion.RotationYawPitchRollToRef(r.y,r.x,r.z,F)),o.push(F.Va())):(r=U,o.push(r.Va()))):o.push([U])}static _CreateLinearOrStepAnimation(L,U,x,mL,p,G){for(const F of U.getKeys())mL.push(F.frame/U.framePerSecond),fL._AddKeyframeValue(F,U,p,x,L,G)}static _CreateCubicSplineAnimation(L,U,x,mL,p,G){U.getKeys().forEach((function(F){mL.push(F.frame/U.framePerSecond),fL._AddSplineTangent(hL.INTANGENT,p,x,"CUBICSPLINE",F,G),fL._AddKeyframeValue(F,U,p,x,L,G),fL._AddSplineTangent(hL.OUTTANGENT,p,x,"CUBICSPLINE",F,G)}))}static _GetBasePositionRotationOrScale(L,U,x){let p;if("rotation"===U)if(x){p=(L.rotationQuaternion??mL.Quaternion.Identity()).Va()}else{p=(L.rotation??mL.YU.Zero()).Va()}else if("translation"===U){p=(L.position??mL.YU.Zero()).Va()}else{p=(L.Ka??mL.YU.One()).Va()}return p}static _AddKeyframeValue(L,U,x,G,F,a){let o;const A=U.dataType;if(A===VL.c.ANIMATIONTYPE_VECTOR3){let U=L.value.Va();if("rotation"===G){const L=mL.YU.qU(U);U=mL.Quaternion.RotationYawPitchRoll(L.y,L.x,L.z).Va()}x.push(U)}else if(A===VL.c.ANIMATIONTYPE_FLOAT){if("weights"===G)x.push([L.value]);else if(o=this._ConvertFactorToVector3OrQuaternion(L.value,F,U,G,a),o){if("rotation"===G){const L=a?o:mL.Quaternion.RotationYawPitchRoll(o.y,o.x,o.z).normalize();x.push(L.Va())}x.push(o.Va())}}else A===VL.c.ANIMATIONTYPE_QUATERNION?x.push(L.value.normalize().Va()):p.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(L,U,x){let mL,p,G=!1;if("rotation"===U&&!x)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let F=0,a=L.length;F<a;++F)if(p=L[F],p.inTangent||p.outTangent)if(mL){if("CUBICSPLINE"!==mL){mL="LINEAR",G=!0;break}}else mL="CUBICSPLINE";else if(mL){if("CUBICSPLINE"===mL||p.interpolation&&1===p.interpolation&&"STEP"!==mL){mL="LINEAR",G=!0;break}}else mL=p.interpolation&&1===p.interpolation?"STEP":"LINEAR";return mL||(mL="LINEAR"),{interpolationType:mL,shouldBakeAnimation:G}}static _AddSplineTangent(L,U,x,p,G,F){let a;const o=L===hL.INTANGENT?G.inTangent:G.outTangent;if("CUBICSPLINE"===p){if("rotation"===x)if(o)if(F)a=o.Va();else{const L=o;a=mL.Quaternion.RotationYawPitchRoll(L.y,L.x,L.z).Va()}else a=[0,0,0,0];else a="weights"===x?o?[o]:[0]:o?o.Va():[0,0,0];U.push(a)}}static _CalculateMinMaxKeyFrames(L){let U=1/0,x=-1/0;return L.forEach((function(L){U=Math.min(U,L.frame),x=Math.max(x,L.frame)})),{min:U,max:x}}}function vL(L,U,x,G,F,a){const o={attributes:{},influence:L.influence,name:L.name},A=U.va;if(!A)return p.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),o;const h=a?-1:1,b=mL.YU.Zero();let E=0,Y=0;if(L.hasPositions){const G=L.getPositions(),a=A.getVerticesData(r.h.PositionKind);if(a){const L=new Float32Array(a.length),U=[1/0,1/0,1/0],p=[-1/0,-1/0,-1/0];Y=a.length/3,E=0;for(let x=E;x<Y;++x){const F=mL.YU.qU(a,3*x);mL.YU.qU(G,3*x).subtractToRef(F,b),b.x*=h,U[0]=Math.min(U[0],b.x),p[0]=Math.max(p[0],b.x),U[1]=Math.min(U[1],b.y),p[1]=Math.max(p[1],b.y),U[2]=Math.min(U[2],b.z),p[2]=Math.max(p[2],b.z),L[3*x]=b.x,L[3*x+1]=b.y,L[3*x+2]=b.z}const A=x.createBufferView(L,12),r=x.createAccessor(A,"VEC3",5126,G.length/3,0,{min:U,max:p});F.push(r),o.attributes.POSITION=F.length-1}else p.Tools.Warn(`Morph target positions for mesh ${U.name} were not exported. Mesh does not have position vertex data`)}if(L.hasNormals){const G=L.getNormals(),a=A.getVerticesData(r.h.NormalKind);if(a){const L=new Float32Array(a.length);Y=a.length/3,E=0;for(let x=E;x<Y;++x){const U=mL.YU.qU(a,3*x).normalize();mL.YU.qU(G,3*x).normalize().subtractToRef(U,b),L[3*x]=b.x*h,L[3*x+1]=b.y,L[3*x+2]=b.z}const U=x.createBufferView(L,12),p=x.createAccessor(U,"VEC3",5126,G.length/3,0);F.push(p),o.attributes.NORMAL=F.length-1}else p.Tools.Warn(`Morph target normals for mesh ${U.name} were not exported. Mesh does not have normals vertex data`)}if(L.hasTangents){const G=L.getTangents(),a=A.getVerticesData(r.h.TangentKind);if(a){Y=a.length/4;const L=new Float32Array(3*Y);E=0;for(let x=E;x<Y;++x){const U=mL.YU.qU(a,4*x);C(U);const p=mL.YU.qU(G,3*x);C(p),p.subtractToRef(U,b),L[3*x]=b.x*h,L[3*x+1]=b.y,L[3*x+2]=b.z}const U=x.createBufferView(L,12),p=x.createAccessor(U,"VEC3",5126,Y,0);F.push(p),o.attributes.TANGENT=F.length-1}else p.Tools.Warn(`Morph target tangents for mesh ${U.name} were not exported. Mesh does not have tangents vertex data`)}if(L.hasColors){const G=L.getColors(),a=A.getVerticesData(r.h.ColorKind),h=A.getVertexBuffer(r.h.ColorKind);if(a&&h){const L=h.getSize();Y=a.length/L;const U=new Float32Array(Y*L);E=0;for(let x=E;x<Y;++x)if(3===L){const p=mL.YU.qU(a,x*L);mL.YU.qU(G,x*L).subtractToRef(p,b),U[3*x]=b.x,U[3*x+1]=b.y,U[3*x+2]=b.z}else if(4===L){const p=new mL.Vector4,F=mL.Vector4.qU(a,x*L);mL.Vector4.qU(G,x*L).subtractToRef(F,p),U[4*x]=p.x,U[4*x+1]=p.y,U[4*x+2]=p.z,U[4*x+3]=p.w}else p.Tools.Warn(`Unsupported number of components for color attribute: ${L}`);const A=x.createBufferView(U,4*L),r=x.createAccessor(A,3===L?"VEC3":"VEC4",5126,Y,0);F.push(r),o.attributes.COLOR_0=F.length-1}else p.Tools.Warn(`Morph target colors for mesh ${U.name} were not exported. Mesh does not have colors vertex data`)}return o}var DL=x(13154),PL=x(13001),dL=x(12979),KL=x(12547);class lL{}lL.DEFAULT_COLOR=V.QU.White(),lL.DEFAULT_WIDTH_ATTENUATED=1,lL.DEFAULT_WIDTH=.1;var iL=x(12791),XL=x(13158);class tL{static ConvertPoints(L,U){if(L.length&&Array.isArray(L)&&"number"===typeof L[0])return[L];if(L.length&&Array.isArray(L[0])&&"number"===typeof L[0][0])return L;if(L.length&&!Array.isArray(L[0])&&L[0]instanceof mL.YU){const U=[];for(let x=0;x<L.length;x++){const mL=L[x];U.push(mL.x,mL.y,mL.z)}return[U]}if(L.length>0&&Array.isArray(L[0])&&L[0].length>0&&L[0][0]instanceof mL.YU){const U=[],x=L;for(const L of x)U.push(L.flatMap((L=>[L.x,L.y,L.z])));return U}if(L instanceof Float32Array){if(null!==U&&void 0!==U&&U.floatArrayStride){const x=[],mL=3*U.floatArrayStride;for(let U=0;U<L.length;U+=mL){const p=new Array(mL);for(let x=0;x<mL;x++)p[x]=L[U+x];x.push(p)}return x}return[Array.from(L)]}if(L.length&&L[0]instanceof Float32Array){const U=[];for(const x of L)U.push(Array.from(x));return U}return[]}static OmitZeroLengthPredicate(L,U,x){const mL=[];return U.SU(L).lengthSquared()>0&&mL.push([L,U]),x.SU(U).lengthSquared()>0&&mL.push([U,x]),L.SU(x).lengthSquared()>0&&mL.push([x,L]),0===mL.length?null:mL}static OmitDuplicatesPredicate(L,U,x,mL){const p=[];return tL._SearchInPoints(L,U,mL)||p.push([L,U]),tL._SearchInPoints(U,x,mL)||p.push([U,x]),tL._SearchInPoints(x,L,mL)||p.push([x,L]),0===p.length?null:p}static _SearchInPoints(L,U,x){for(const F of x)for(let x=0;x<F.length;x++){var mL,p,G;if(null!==(mL=F[x])&&void 0!==mL&&mL.equals(L))if(null!==(p=F[x+1])&&void 0!==p&&p.equals(U)||null!==(G=F[x-1])&&void 0!==G&&G.equals(U))return!0}return!1}static MeshesToLines(L,U){const x=[];for(let p=0;p<L.length;p++){const G=L[p],F=G.getVerticesData(r.h.PositionKind),a=G.Da();if(F&&a)for(let L=0,o=0;L<a.length;L++){const A=3*a[o++],r=3*a[o++],h=3*a[o++],b=new mL.YU(F[A],F[A+1],F[A+2]),E=new mL.YU(F[r],F[r+1],F[r+2]),Y=new mL.YU(F[h],F[h+1],F[h+2]);if(U){const mL=U(b,E,Y,x,L,A,G,p,F,a);if(mL)for(const L of mL)x.push(L)}else x.push([b,E],[E,Y],[Y,b])}}return x}static ToVector3Array(L){if(Array.isArray(L[0])){const U=[],x=L;for(const L of x){const x=[];for(let U=0;U<L.length;U+=3)x.push(new mL.YU(L[U],L[U+1],L[U+2]));U.push(x)}return U}const U=L,x=[];for(let p=0;p<U.length;p+=3)x.push(new mL.YU(U[p],U[p+1],U[p+2]));return x}static ToNumberArray(L){return L.flatMap((L=>[L.x,L.y,L.z]))}static GetPointsCountInfo(L){const U=new Array(L.length);let x=0;for(let mL=L.length;mL--;)U[mL]=L[mL].length/3,x+=U[mL];return{total:x,counts:U}}static GetLineLength(L){if(0===L.length)return 0;let U;U="number"===typeof L[0]?tL.ToVector3Array(L):L;const x=mL.TmpVectors.YU[0];let p=0;for(let mL=0;mL<U.length-1;mL++){const L=U[mL];p+=U[mL+1].subtractToRef(L,x).length()}return p}static GetLineLengthArray(L){const U=new Float32Array(L.length/3);let x=0;for(let mL=0,p=L.length/3-1;mL<p;mL++){let p=L[3*mL+0],G=L[3*mL+1],F=L[3*mL+2];p-=L[3*mL+3],G-=L[3*mL+4],F-=L[3*mL+5];x+=Math.sqrt(p*p+G*G+F*F),U[mL+1]=x}return U}static SegmentizeSegmentByCount(L,U,x){const p=[],G=U.SU(L),F=mL.TmpVectors.YU[0];F.la(x);const a=mL.TmpVectors.YU[1];G.divideToRef(F,a);let o=L.clone();p.push(o);for(let mL=0;mL<x;mL++)o=o.clone(),p.push(o.addInPlace(a));return p}static SegmentizeLineBySegmentLength(L,U){const x=L[0]instanceof mL.YU?tL.GetLineSegments(L):"number"===typeof L[0]?tL.GetLineSegments(tL.ToVector3Array(L)):L,p=[];for(const mL of x)if(mL.length>U){const L=tL.SegmentizeSegmentByCount(mL.point1,mL.point2,Math.ceil(mL.length/U));for(const U of L)p.push(U)}else p.push(mL.point1),p.push(mL.point2);return p}static SegmentizeLineBySegmentCount(L,U){const x="number"===typeof L[0]?tL.ToVector3Array(L):L,mL=tL.GetLineLength(x)/U;return tL.SegmentizeLineBySegmentLength(x,mL)}static GetLineSegments(L){const U=[];for(let x=0;x<L.length-1;x++){const mL=L[x],p=L[x+1],G=p.SU(mL).length();U.push({point1:mL,point2:p,length:G})}return U}static GetMinMaxSegmentLength(L){const U=tL.GetLineSegments(L).sort((L=>L.length));return{min:U[0].length,max:U[U.length-1].length}}static GetPositionOnLineByVisibility(L,U,x){let p=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const G=U*x;let F=0,a=0;const o=L.length;for(let mL=0;mL<o;mL++){if(G<=F+L[mL].length){a=mL;break}F+=L[mL].length}const A=(G-F)/L[a].length;return L[a].point2.subtractToRef(L[a].point1,mL.TmpVectors.YU[0]),mL.TmpVectors.YU[1]=mL.TmpVectors.YU[0].multiplyByFloats(A,A,A),p||mL.TmpVectors.YU[1].addInPlace(L[a].point1),mL.TmpVectors.YU[1].clone()}static GetCircleLinePoints(L,U){let x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L,G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/U;const F=[];for(let a=0;a<=U;a++)F.push(new mL.YU(Math.cos(a*G)*L,Math.sin(a*G)*p,x));return F}static GetBezierLinePoints(L,U,x,mL){return iL.h.CreateQuadraticBezier(L,U,x,mL).getPoints().flatMap((L=>[L.x,L.y,L.z]))}static GetArrowCap(L,U,x,mL,p){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,F=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[L.clone(),L.add(U.multiplyByFloats(x,x,x))],widths:[mL,p,G,F]}}static GetPointsFromText(L,U,x,mL){let p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const F=[],a=(0,XL.b)(L,U,x,mL);for(const o of a){for(const L of o.paths){const U=[],x=L.getPoints();for(const L of x)U.push(L.x,L.y,p);F.push(U)}if(G)for(const L of o.holes){const U=[],x=L.getPoints();for(const L of x)U.push(L.x,L.y,p);F.push(U)}}return F}static Color3toRGBAUint8(L){const U=new Uint8Array(4*L.length);for(let x=0,mL=0;x<L.length;x++)U[mL++]=255*L[x].r,U[mL++]=255*L[x].g,U[mL++]=255*L[x].b,U[mL++]=255;return U}static CreateColorsTexture(L,U,x,mL){const p=mL.getEngine().getCaps().maxTextureSize??1,G=U.length>p?p:U.length,F=Math.ceil(U.length/p);F>1&&(U=[...U,...Array(G*F-U.length).fill(U[0])]);const a=tL.Color3toRGBAUint8(U),o=new D.b(a,G,F,Y.b.TEXTUREFORMAT_RGBA,mL,!1,!0,x);return o.name=L,o}static PrepareEmptyColorsTexture(L){if(!lL.EmptyColorsTexture){const U=new Uint8Array(4);lL.EmptyColorsTexture=new D.b(U,1,1,Y.b.TEXTUREFORMAT_RGBA,L,!1,!1,D.b.NEAREST_NEAREST),lL.EmptyColorsTexture.name="grlEmptyColorsTexture"}return lL.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var L;null===(L=lL.EmptyColorsTexture)||void 0===L||L.dispose(),lL.EmptyColorsTexture=null}static BooleanToNumber(L){return L?1:0}}class yL extends dL.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class nL extends PL.d{isCompatible(L){return!0}constructor(L,U,x){var p;x=x||{color:lL.DEFAULT_COLOR};const G=new yL;G.GREASED_LINE_HAS_COLOR=!!x.color&&!x.useColors,G.GREASED_LINE_SIZE_ATTENUATION=x.sizeAttenuation??!1,G.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===x.colorDistributionType,G.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(U??L.PL()).useRightHandedSystem,G.GREASED_LINE_CAMERA_FACING=x.cameraFacing??!0,super(L,nL.GREASED_LINE_MATERIAL_NAME,200,G,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(p=x)||void 0===p?void 0:p.forceGLSL)||nL.ForceGLSL,this._scene=U??L.PL(),this._engine=this._scene.getEngine(),this._cameraFacing=x.cameraFacing??!0,this.visibility=x.visibility??1,this.useDash=x.useDash??!1,this.dashRatio=x.dashRatio??.5,this.dashOffset=x.dashOffset??0,this.width=x.width?x.width:x.sizeAttenuation?lL.DEFAULT_WIDTH_ATTENUATED:lL.DEFAULT_WIDTH,this._sizeAttenuation=x.sizeAttenuation??!1,this.colorMode=x.colorMode??0,this._color=x.color??null,this.useColors=x.useColors??!1,this._colorsDistributionType=x.colorDistributionType??0,this.colorsSampling=x.colorsSampling??D.b.NEAREST_NEAREST,this._colors=x.iL??null,this.dashCount=x.dashCount??1,this.resolution=x.resolution??new mL.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),x.colorsTexture?this.colorsTexture=x.colorsTexture:this._colors?this.colorsTexture=tL.CreateColorsTexture(`${L.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??lL.DEFAULT_COLOR,tL.PrepareEmptyColorsTexture(this._scene)),this._engine.oa.add((()=>{tL.DisposeEmptyColorsTexture()}))}getAttributes(L){L.push("grl_offsets"),L.push("grl_widths"),L.push("grl_colorPointers"),L.push("grl_counters"),this._cameraFacing?(L.push("grl_previousAndSide"),L.push("grl_nextAndCounters")):L.push("grl_slopes")}getSamplers(L){L.push("grl_colors")}getActiveTextures(L){this.colorsTexture&&L.push(this.colorsTexture)}getUniforms(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const U=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&U.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===L&&U.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:U,vertex:this._cameraFacing&&this._isGLSL(L)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(L)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(L){if(this._cameraFacing){L.qa("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||L.qa("viewProjection",this._scene.getTransformMatrix());const U=mL.TmpVectors.Vector4[0];U.x=this._aspect,U.y=this._resolution.x,U.z=this._resolution.y,U.w=this.width,L.updateVector4("grl_aspect_resolution_lineWidth",U)}const U=mL.TmpVectors.Vector4[0];U.x=tL.BooleanToNumber(this.useDash),U.y=this._dashArray,U.z=this.dashOffset,U.w=this.dashRatio,L.updateVector4("grl_dashOptions",U);const x=mL.TmpVectors.Vector4[1];x.x=this.colorMode,x.y=this.visibility,x.z=this.colorsTexture?this.colorsTexture.getSize().width:0,x.w=tL.BooleanToNumber(this.useColors),L.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",x),this._color&&L.updateColor3("grl_singleColor",this._color);const p=this.colorsTexture??lL.EmptyColorsTexture;L.setTexture("grl_colors",p),L.updateFloat2("grl_textureSize",(null===p||void 0===p?void 0:p.getSize().width)??1,(null===p||void 0===p?void 0:p.getSize().height)??1)}prepareDefines(L,U,x){L.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,L.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,L.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,L.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=U.useRightHandedSystem,L.GREASED_LINE_CAMERA_FACING=this._cameraFacing,L.GREASED_LINE_USE_OFFSETS=!!x.offsets}getClassName(){return nL.GREASED_LINE_MATERIAL_NAME}getCustomCode(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(U)?function(L,U){if("vertex"===L){const L={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return U&&(L["!gl_Position\\=viewProjection\\*worldPos;"]="//"),L}return"fragment"===L?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(L,this._cameraFacing):function(L,U){if("vertex"===L){const L={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return U&&(L["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),L}return"fragment"===L?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(L,this._cameraFacing)}dispose(){var L;null===(L=this.colorsTexture)||void 0===L||L.dispose(),super.dispose()}get iL(){return this._colors}set iL(L){this.setColors(L)}setColors(L){var U;let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1],mL=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const p=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var G;if(this._colors=L,null!==L&&0!==L.length){if(!x||mL)if(this.colorsTexture&&p===L.length&&!mL){const U=tL.Color3toRGBAUint8(L);this.colorsTexture.update(U)}else{var F;null===(F=this.colorsTexture)||void 0===F||F.dispose(),this.colorsTexture=tL.CreateColorsTexture(`${this._material.name}-colors-texture`,L,this.colorsSampling,this._scene)}}else null===(G=this.colorsTexture)||void 0===G||G.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(L){this._dashCount=L,this._dashArray=1/L}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(L){this._sizeAttenuation=L,this.markAllDefinesAsDirty()}get color(){return this._color}set color(L){this.setColor(L)}setColor(L){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==L||null!==this._color&&null===L?(this._color=L,U||this.markAllDefinesAsDirty()):this._color=L}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(L){this._colorsDistributionType=L,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(L){this._aspect=L.x/L.y,this._resolution=L}serialize(){const L=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(U.iL=this._colors),this._color&&(U.color=this._color),L.greasedLineMaterialOptions=U,L}parse(L,U,x){var mL;super.parse(L,U,x);const p=L.greasedLineMaterialOptions;null===(mL=this.colorsTexture)||void 0===mL||mL.dispose(),p.color&&this.setColor(p.color,!0),p.colorDistributionType&&(this.colorsDistributionType=p.colorDistributionType),p.iL&&(this.iL=p.iL),p.colorsSampling&&(this.colorsSampling=p.colorsSampling),p.colorMode&&(this.colorMode=p.colorMode),p.useColors&&(this.useColors=p.useColors),p.visibility&&(this.visibility=p.visibility),p.useDash&&(this.useDash=p.useDash),p.dashCount&&(this.dashCount=p.dashCount),p.dashRatio&&(this.dashRatio=p.dashRatio),p.dashOffset&&(this.dashOffset=p.dashOffset),p.width&&(this.width=p.width),p.sizeAttenuation&&(this.sizeAttenuation=p.sizeAttenuation),p.resolution&&(this.resolution=p.resolution),this.iL?this.colorsTexture=tL.CreateColorsTexture(`${this._material.name}-colors-texture`,this.iL,this.colorsSampling,U):tL.PrepareEmptyColorsTexture(U),this.markAllDefinesAsDirty()}copyTo(L){var U;const x=L;null===(U=x.colorsTexture)||void 0===U||U.dispose(),this._colors&&(x.colorsTexture=tL.CreateColorsTexture(`${x._material.name}-colors-texture`,this._colors,x.colorsSampling,this._scene)),x.setColor(this.color,!0),x.colorsDistributionType=this.colorsDistributionType,x.colorsSampling=this.colorsSampling,x.colorMode=this.colorMode,x.useColors=this.useColors,x.visibility=this.visibility,x.useDash=this.useDash,x.dashCount=this.dashCount,x.dashRatio=this.dashRatio,x.dashOffset=this.dashOffset,x.width=this.width,x.sizeAttenuation=this.sizeAttenuation,x.resolution=this.resolution,x.markAllDefinesAsDirty()}_isGLSL(L){return 0===L||this._forceGLSL}}nL.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",nL.ForceGLSL=!1,(0,KL.d)(`BABYLON.${nL.GREASED_LINE_MATERIAL_NAME}`,nL);var NL=x(13031),eL=x(12414),uL=x(12813),ZL=x(12529);class gL extends uL.ShaderMaterial{constructor(L,U,p){const G=U.getEngine(),F=G.isWebGPU&&!(p.forceGLSL||gL.ForceGLSL),a=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];U.useRightHandedSystem&&a.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const o=["position","grl_widths","grl_offsets","grl_colorPointers"];p.cameraFacing?(a.push("GREASED_LINE_CAMERA_FACING"),o.push("grl_previousAndSide","grl_nextAndCounters")):(o.push("grl_slopes"),o.push("grl_counters"));const A=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(F||A.push("world","viewProjection","view","projection"),super(L,U,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:F?["Scene","Mesh"]:void 0,attributes:o,uniforms:A,samplers:F?[]:["grlColors"],defines:a,extraInitializationsAsync:async()=>{F?await Promise.all([x.e(66).then(x.bind(x,15776)),x.e(75).then(x.bind(x,15785))]):await Promise.all([x.e(69).then(x.bind(x,15792)),x.e(76).then(x.bind(x,15795))])},shaderLanguage:F?1:0}),this._color=V.QU.White(),this._colorsDistributionType=0,this._colorsTexture=null,p=p||{color:lL.DEFAULT_COLOR},this.visibility=p.visibility??1,this.useDash=p.useDash??!1,this.dashRatio=p.dashRatio??.5,this.dashOffset=p.dashOffset??0,this.dashCount=p.dashCount??1,this.width=p.width?p.width:p.sizeAttenuation&&p.cameraFacing?lL.DEFAULT_WIDTH_ATTENUATED:lL.DEFAULT_WIDTH,this.sizeAttenuation=p.sizeAttenuation??!1,this.color=p.color??V.QU.White(),this.useColors=p.useColors??!1,this.colorsDistributionType=p.colorDistributionType??0,this.colorsSampling=p.colorsSampling??D.b.NEAREST_NEAREST,this.colorMode=p.colorMode??0,this._colors=p.iL??null,this._cameraFacing=p.cameraFacing??!0,this.resolution=p.resolution??new mL.Vector2(G.getRenderWidth(),G.getRenderHeight()),p.colorsTexture?this.colorsTexture=p.colorsTexture:this._colors?this.colorsTexture=tL.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,U):(this._color=this._color??lL.DEFAULT_COLOR,this.colorsTexture=tL.PrepareEmptyColorsTexture(U)),F){const L=new ZL.c;L.setParameters(),L.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",L)}G.oa.add((()=>{tL.DisposeEmptyColorsTexture()}))}dispose(){var L;null===(L=this._colorsTexture)||void 0===L||L.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new mL.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get iL(){return this._colors}set iL(L){this.setColors(L)}setColors(L){var U;let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1],mL=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const p=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var G;if(this._colors=L,null!==L&&0!==L.length){if(!x||mL)if(this._colorsTexture&&p===L.length&&!mL){const U=tL.Color3toRGBAUint8(L);this._colorsTexture.update(U)}else{var F;null===(F=this._colorsTexture)||void 0===F||F.dispose(),this.colorsTexture=tL.CreateColorsTexture(`${this.name}-colors-texture`,L,this.colorsSampling,this.PL())}}else null===(G=this._colorsTexture)||void 0===G||G.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(L){this._colorsTexture=L,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(L){this._width=L,this.setFloat("grlWidth",L)}get useColors(){return this._useColors}set useColors(L){this._useColors=L,this.setFloat("grlUseColors",tL.BooleanToNumber(L))}get colorsSampling(){return this._colorsSampling}set colorsSampling(L){this._colorsSampling=L}get visibility(){return this._visibility}set visibility(L){this._visibility=L,this.setFloat("grlVisibility",L)}get useDash(){return this._useDash}set useDash(L){this._useDash=L,this.setFloat("grlUseDash",tL.BooleanToNumber(L))}get dashOffset(){return this._dashOffset}set dashOffset(L){this._dashOffset=L,this.setFloat("grlDashOffset",L)}get dashRatio(){return this._dashRatio}set dashRatio(L){this._dashRatio=L,this.setFloat("grlDashRatio",L)}get dashCount(){return this._dashCount}set dashCount(L){this._dashCount=L,this._dashArray=1/L,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(L){this._sizeAttenuation=L,this.setFloat("grlSizeAttenuation",tL.BooleanToNumber(L))}get color(){return this._color}set color(L){this.setColor(L)}setColor(L){L=L??lL.DEFAULT_COLOR,this._color=L,this.setColor3("grlColor",L)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(L){this._colorsDistributionType=L,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(L){this._colorMode=L,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(L){this._resolution=L,this.setVector2("grlResolution",L),this.setFloat("grlAspect",L.x/L.y)}serialize(){const L=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(U.iL=this._colors),L.greasedLineMaterialOptions=U,L}parse(L,U,x){var mL;const p=L.greasedLineMaterialOptions;null===(mL=this._colorsTexture)||void 0===mL||mL.dispose(),p.color&&(this.color=p.color),p.colorDistributionType&&(this.colorsDistributionType=p.colorDistributionType),p.colorsSampling&&(this.colorsSampling=p.colorsSampling),p.colorMode&&(this.colorMode=p.colorMode),p.useColors&&(this.useColors=p.useColors),p.visibility&&(this.visibility=p.visibility),p.useDash&&(this.useDash=p.useDash),p.dashCount&&(this.dashCount=p.dashCount),p.dashRatio&&(this.dashRatio=p.dashRatio),p.dashOffset&&(this.dashOffset=p.dashOffset),p.width&&(this.width=p.width),p.sizeAttenuation&&(this.sizeAttenuation=p.sizeAttenuation),p.resolution&&(this.resolution=p.resolution),p.iL?this.colorsTexture=tL.CreateColorsTexture(`${this.name}-colors-texture`,p.iL,this.colorsSampling,this.PL()):this.colorsTexture=tL.PrepareEmptyColorsTexture(U),this._cameraFacing=p.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var zL,ML,JL;gL.ForceGLSL=!1,function(L){L[L.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",L[L.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(zL||(zL={})),function(L){L[L.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",L[L.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",L[L.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(ML||(ML={})),function(L){L[L.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",L[L.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",L[L.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",L[L.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",L[L.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(JL||(JL={}));class jL extends QL.e{constructor(L,U,x){super(L,U,null,null,!1,!1),this.name=L,this._options=x,this._lazy=!1,this._updatable=!1,this._engine=U.getEngine(),this._lazy=x.lazy??!1,this._updatable=x.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=x.colorPointers??[],this._widths=x.widths??new Array(x.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(L){let U=0;for(const mL of this._points)U+=mL.length;const x=U/3*2-this._widths.length;for(let mL=0;mL<x;mL++)this._widths.push(L)}updateLazy(){var L,U;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(L=this._options.ribbonOptions)||void 0===L?void 0:L.smoothShading),!this.nL&&this.refreshBoundingInfo(),null===(U=this.greasedLineMaterial)||void 0===U||U.updateLazy()}addPoints(L,U){for(const x of L)this._points.push(x);this._lazy||this.setPoints(this._points,U)}dispose(L){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(L,U)}isLazy(){return this._lazy}get XL(){return this._uvs}set XL(L){this._uvs=L instanceof Float32Array?L:new Float32Array(L),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(L){this.material instanceof gL&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===L||void 0===L?void 0:L.length)>0),this._offsets=L,this._offsetsBuffer?this._offsetsBuffer.update(L):this._createOffsetsBuffer(L)}get widths(){return this._widths}set widths(L){this._widths=L,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(L)}get colorPointers(){return this._colorPointers}set colorPointers(L){this._colorPointers=L,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(L)}get greasedLineMaterial(){var L,U;if(this.material&&this.material instanceof gL)return this.material;const x=null===(L=this.material)||void 0===L||null===(U=L.pluginManager)||void 0===U?void 0:U.getPlugin(nL.GREASED_LINE_MATERIAL_NAME);return x||void 0}get points(){const L=[];return eL.b.DeepCopy(this._points,L),L}setPoints(L,U){this._points=tL.ConvertPoints(L,(null===U||void 0===U?void 0:U.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==U&&void 0!==U&&U.colorPointers||this._updateColorPointers(),this._setPoints(this._points,U)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,XL:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(L){super.serialize(L),L.type=this.getClassName(),L.lineOptions=this._createLineOptions()}_createVertexBuffers(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new NL.b;return U.KL=this._vertexPositions,U.indices=this._indices,U.XL=this._uvs,L&&(U.lL=[],NL.b.ComputeNormals(this._vertexPositions,this._indices,U.lL)),U.yL(this,this._options.updatable),U}_createOffsetsBuffer(L){const U=this._scene.getEngine(),x=new r.d(U,L,this._updatable,3);this.setVerticesBuffer(x.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=x}}class RL{constructor(L,U){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=L,this.wasAddedByNoopNode=U}getIndicesAccessor(L,U,x,mL,p){var G,F,a,o;return null===(G=this._indicesAccessorMap.get(L))||void 0===G||null===(F=G.get(U))||void 0===F||null===(a=F.get(x))||void 0===a||null===(o=a.get(mL))||void 0===o?void 0:o.get(p)}setIndicesAccessor(L,U,x,mL,p,G){let F=this._indicesAccessorMap.get(L);F||(F=new Map,this._indicesAccessorMap.set(L,F));let a=F.get(U);a||(a=new Map,F.set(U,a));let o=a.get(x);o||(o=new Map,a.set(x,o));let A=o.get(mL);A||(A=new Map,o.set(mL,A)),A.set(p,G)}pushExportedNode(L){this._exportedNodes.has(L)||this._exportedNodes.add(L)}getNodesSet(){return this._exportedNodes}getVertexBufferView(L){return this._vertexBufferViewMap.get(L)}setVertexBufferView(L,U){this._vertexBufferViewMap.set(L,U)}setRemappedBufferView(L,U,x){this._remappedBufferView.set(L,new Map),this._remappedBufferView.get(L).set(U,x)}getRemappedBufferView(L,U){var x;return null===(x=this._remappedBufferView.get(L))||void 0===x?void 0:x.get(U)}getVertexAccessor(L,U,x){var mL,p;return null===(mL=this._vertexAccessorMap.get(L))||void 0===mL||null===(p=mL.get(U))||void 0===p?void 0:p.get(x)}setVertexAccessor(L,U,x,mL){let p=this._vertexAccessorMap.get(L);p||(p=new Map,this._vertexAccessorMap.set(L,p));let G=p.get(U);G||(G=new Map,p.set(U,G)),G.set(x,mL)}hasVertexColorAlpha(L){return this._vertexMapColorAlpha.get(L)||!1}setHasVertexColorAlpha(L,U){return this._vertexMapColorAlpha.set(L,U)}getMesh(L){return this._meshMap.get(L)}setMesh(L,U){this._meshMap.set(L,U)}bindMorphDataToMesh(L,U){const x=this._meshMorphTargetMap.get(L)||[];this._meshMorphTargetMap.set(L,x),-1===x.indexOf(U)&&x.push(U)}getMorphTargetsFromMesh(L){return this._meshMorphTargetMap.get(L)}}class cL{_ApplyExtension(L,U,x,mL){if(x>=U.length)return Promise.resolve(L);const p=mL(U[x],L);return p?p.then((async L=>L?await this._ApplyExtension(L,U,x+1,mL):null)):this._ApplyExtension(L,U,x+1,mL)}_ApplyExtensions(L,U){const x=[];for(const mL of cL._ExtensionNames)x.push(this._extensions[mL]);return this._ApplyExtension(L,x,0,U)}_extensionsPreExportTextureAsync(L,U,x){return this._ApplyExtensions(U,((U,mL)=>U.preExportTextureAsync&&U.preExportTextureAsync(L,mL,x)))}_extensionsPostExportNodeAsync(L,U,x,mL,p){return this._ApplyExtensions(U,((U,G)=>U.postExportNodeAsync&&U.postExportNodeAsync(L,G,x,mL,p,this._bufferManager)))}_extensionsPostExportMaterialAsync(L,U,x){return this._ApplyExtensions(U,((U,mL)=>U.postExportMaterialAsync&&U.postExportMaterialAsync(L,mL,x)))}_extensionsPostExportMaterialAdditionalTextures(L,U,x){const mL=[];for(const p of cL._ExtensionNames){const G=this._extensions[p];G.postExportMaterialAdditionalTextures&&mL.push(...G.postExportMaterialAdditionalTextures(L,U,x))}return mL}_extensionsPostExportTextures(L,U,x){for(const mL of cL._ExtensionNames){const p=this._extensions[mL];p.postExportTexture&&p.postExportTexture(L,U,x)}}_extensionsPostExportMeshPrimitive(L){for(const U of cL._ExtensionNames){const x=this._extensions[U];x.postExportMeshPrimitive&&x.postExportMeshPrimitive(L,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const L of cL._ExtensionNames){const U=this._extensions[L];U.preGenerateBinaryAsync&&await U.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(L){for(const U of cL._ExtensionNames){const x=this._extensions[U];x.enabled&&L(x)}}_extensionsOnExporting(){this._forEachExtensions((L=>{var U,x,mL;L.wasUsed&&((U=this._glTF).extensionsUsed||(U.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(L.name)&&this._glTF.extensionsUsed.push(L.name),L.required&&((x=this._glTF).extensionsRequired||(x.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(L.name)&&this._glTF.extensionsRequired.push(L.name)),(mL=this._glTF).extensions||(mL.extensions={}),L.onExporting&&L.onExporting())}))}_loadExtensions(){for(const L of cL._ExtensionNames){const U=cL._ExtensionFactories[L](this);this._extensions[L]=U}}constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:S.c.LastCreatedScene,U=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${Y.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new Z(this),this._extensions={},this._bufferManager=new rL,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!L)throw new Error("No scene available to export");this._babylonScene=L,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:L=>{var U;return null===L||void 0===L||null===(U=L.ba)||void 0===U?void 0:U.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...U},this._loadExtensions()}dispose(){for(const L in this._extensions){this._extensions[L].dispose()}}get options(){return this._options}static RegisterExtension(L,U){cL.UnregisterExtension(L)&&p.Tools.Warn(`Extension with the name ${L} already exists`),cL._ExtensionFactories[L]=U,cL._ExtensionNames.push(L)}static UnregisterExtension(L){if(!cL._ExtensionFactories[L])return!1;delete cL._ExtensionFactories[L];const U=cL._ExtensionNames.indexOf(L);return-1!==U&&cL._ExtensionNames.splice(U,1),!0}_generateJSON(L,U,x){const mL={byteLength:L};return mL.byteLength&&(this._glTF.buffers=[mL]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.VU=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(mL.uri=U+".bin"),x?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(L){const U=await this._generateBinaryAsync();this._extensionsOnExporting();const x=this._generateJSON(U.byteLength,L,!0),mL=new Blob([U],{type:"application/octet-stream"}),p=L+".gltf",G=L+".bin",F=new A;if(F.files[p]=x,F.files[G]=mL,this._imageData)for(const a in this._imageData)F.files[a]=new Blob([this._imageData[a].data],{type:this._imageData[a].mimeType});return F}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(L){const U=L%4;return 0===U?U:4-U}async generateGLBAsync(L){this._shouldUseGlb=!0;const U=await this._generateBinaryAsync();this._extensionsOnExporting();const x=this._generateJSON(U.byteLength),mL=L+".glb";let p,G=x.length;if("undefined"!==typeof TextEncoder){p=(new TextEncoder).encode(x),G=p.length}const F=this._getPadding(G),a=this._getPadding(U.byteLength),o=28+G+F+U.byteLength+a,r=new oL(o);if(r.writeUInt32(1179937895),r.writeUInt32(2),r.writeUInt32(o),r.writeUInt32(G+F),r.writeUInt32(1313821514),p)r.writeTypedArray(p);else{const L="_".charCodeAt(0);for(let U=0;U<G;++U){const mL=x.charCodeAt(U);mL!=x.codePointAt(U)?r.writeUInt8(L):r.writeUInt8(mL)}}for(let A=0;A<F;++A)r.writeUInt8(32);r.writeUInt32(U.byteLength+a),r.writeUInt32(5130562),r.writeTypedArray(U);for(let A=0;A<a;++A)r.writeUInt8(0);const h=new A;return h.files[mL]=new Blob([r.getOutputData()],{type:"application/octet-stream"}),h}_setNodeTransformation(L,U,x){if(U.getPivotPoint().equalsWithEpsilon(j,J.c)||p.Tools.Warn("Pivot points are not supported in the glTF serializer"),!U.position.equalsWithEpsilon(j,J.c)){const p=mL.TmpVectors.YU[0].p(U.position);x&&k(p),L.translation=p.Va()}U.Ka.equalsWithEpsilon(c,J.c)||(L.scale=U.Ka.Va());const G=U.rotationQuaternion||mL.Quaternion.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);G.equalsWithEpsilon(R,J.c)||(x&&T(G),L.rotation=G.normalize().Va())}_setCameraTransformation(L,U,x){if(!U.position.equalsWithEpsilon(j,J.c)){const p=mL.TmpVectors.YU[0].p(U.position);x&&k(p),L.translation=p.Va()}const p=U.rotationQuaternion||mL.Quaternion.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);x&&T(p),this._babylonScene.useRightHandedSystem||O(p),p.equalsWithEpsilon(R,J.c)||(L.rotation=p.Va())}_listAvailableCameras(){for(const L of this._babylonScene.cameras){const U={type:L.mode===bL.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(L.name&&(U.name=L.name),"perspective"===U.type)U.perspective={aspectRatio:L.getEngine().getAspectRatio(L),yfov:L.fovMode===bL.c.FOVMODE_VERTICAL_FIXED?L.fov:L.fov*L.getEngine().getAspectRatio(L),znear:L.Qa,zfar:L.maxZ};else if("orthographic"===U.type){const x=L.orthoLeft&&L.orthoRight?.5*(L.orthoRight-L.orthoLeft):.5*L.getEngine().getRenderWidth(),mL=L.orthoBottom&&L.orthoTop?.5*(L.orthoTop-L.orthoBottom):.5*L.getEngine().getRenderHeight();U.orthographic={xmag:x,ymag:mL,znear:L.Qa,zfar:L.maxZ}}this._camerasMap.set(L,U)}}_exportAndAssignCameras(){const L=Array.from(this._camerasMap.values());for(const U of L){const L=this._nodesCameraMap.get(U);if(void 0!==L){this._cameras.push(U);for(const U of L)U.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const L of this._babylonScene.skeletons){if(L.bones.length<=0)continue;const U={joints:[]};this._skinMap.set(L,U)}}_exportAndAssignSkeletons(){for(const L of this._babylonScene.skeletons){if(L.bones.length<=0)continue;const U=this._skinMap.get(L);if(void 0==U)continue;const x={},mL=[];let G=-1;for(let p=0;p<L.bones.length;++p){const U=L.bones[p],mL=U.getIndex()??p;-1!==mL&&(x[mL]=U,mL>G&&(G=mL))}for(let L=0;L<=G;++L){const G=x[L];mL.push(G.getAbsoluteInverseBindMatrix());const F=G.getTransformNode();if(null!==F){const L=this._nodeMap.get(F);F&&null!==L&&void 0!==L?U.joints.push(L):p.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else p.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const F=this._nodesSkinMap.get(U);if(U.joints.length>0&&void 0!==F){const L=64*mL.length,x=new Float32Array(L/4);mL.forEach(((L,U)=>{x.set(L.m,16*U)}));const p=this._bufferManager.createBufferView(x);this._accessors.push(this._bufferManager.createAccessor(p,"MAT4",5126,mL.length)),U.inverseBindMatrices=this._accessors.length-1,this._skins.push(U);for(const U of F)U.skin=this._skins.length-1}}}async _exportSceneAsync(){const L={nodes:[]};if(this._babylonScene.metadata){const U=this._options.metadataSelector(this._babylonScene.metadata);U&&(L.extras=U)}const U=new Array,x=new Array,mL=new Array;for(const a of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&FL(a,this._babylonScene.useRightHandedSystem)?mL.push(...a.getChildren()):this._babylonScene.useRightHandedSystem?U.push(a):x.push(a);this._listAvailableCameras(),this._listAvailableSkeletons();const p=new RL(!0,!1);L.nodes.push(...await this._exportNodesAsync(x,p));const G=new RL(!1,!1);L.nodes.push(...await this._exportNodesAsync(U,G));const F=new RL(!1,!0);L.nodes.push(...await this._exportNodesAsync(mL,F)),L.nodes.length&&this._scenes.push(L),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&fL._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,p.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(L){let U=this._shouldExportNodeMap.get(L);return void 0===U&&(U=this._options.shouldExportNode(L),this._shouldExportNodeMap.set(L,U)),U}async _exportNodesAsync(L,U){const x=new Array;this._exportBuffers(L,U);for(const mL of L)await this._exportNodeAsync(mL,x,U);return x}_collectBuffers(L,U,x,mL,p){if(this._shouldExportNode(L)&&L instanceof b.c&&L.va){const G=L.va.getVertexBuffers();if(G)for(const mL in G){if(!B(mL))continue;const F=G[mL];p.setHasVertexColorAlpha(F,L.hasVertexAlpha);const a=F._buffer,o=U.get(a)||[];U.set(a,o),-1===o.indexOf(F)&&o.push(F);const A=x.get(F)||[];x.set(F,A),-1===A.indexOf(L)&&A.push(L)}const F=L.morphTargetManager;if(F)for(let U=0;U<F.numTargets;U++){const x=F.getTarget(U),p=mL.get(x)||[];mL.set(x,p),-1===p.indexOf(L)&&p.push(L)}}for(const G of L.getChildren())this._collectBuffers(G,U,x,mL,p)}_exportBuffers(L,U){const x=new Map,mL=new Map,p=new Map;for(const a of L)this._collectBuffers(a,x,mL,p,U);const G=Array.from(x.keys());for(const a of G){const L=a.getData();if(!L)throw new Error("Buffer data is not available");const p=x.get(a);if(!p)continue;const G=p[0].byteStride;if(p.some((L=>L.byteStride!==G)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const F=xL(L).slice();for(const U of p){const L=mL.get(U),{byteOffset:x,byteStride:p,componentCount:G,type:a,count:o,normalized:A,kind:h}=I(U,L);switch(h){case r.h.NormalKind:case r.h.TangentKind:(0,g.h)(F,x,p,G,a,o,A,(L=>{const U=Math.sqrt(L[0]*L[0]+L[1]*L[1]+L[2]*L[2]);if(U>0){const x=1/U;L[0]*=x,L[1]*=x,L[2]*=x}}));break;case r.h.ColorKind:{const U=L.filter((L=>L.material instanceof SL.HU||null==L.material)).length;if(0==U)break;if(U!=L.length){z.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}a==r.h.UNSIGNED_BYTE&&z.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const mL=new V.QU,h=new V.ia,b=this._babylonScene.getEngine().useExactSrgbConversions;(0,g.h)(F,x,p,G,a,o,A,(L=>{3===L.length?(mL.Vx(L,0),mL.toLinearSpaceToRef(mL,b),mL.toArray(L,0)):(h.Vx(L,0),h.toLinearSpaceToRef(h,b),h.toArray(L,0))}))}}}if(U.convertToRightHanded){for(const L of p){const U=mL.get(L),{byteOffset:x,byteStride:p,componentCount:G,type:a,count:o,normalized:A,kind:h}=I(L,U);switch(h){case r.h.PositionKind:case r.h.NormalKind:case r.h.TangentKind:(0,g.h)(F,x,p,G,a,o,A,(L=>{L[0]=-L[0]}))}}U.convertedToRightHandedBuffers.set(a,F)}const o=this._bufferManager.createBufferView(F,G);U.setVertexBufferView(a,o);const A=new Map;for(const U of p){const L=mL.get(U),{kind:x,totalVertices:p}=I(U,L);switch(x){case r.h.MatricesIndicesKind:case r.h.MatricesIndicesExtraKind:if(U.type==r.h.FLOAT){const L=U.getFloatData(p);null!==L&&A.set(U,L)}}}0!==A.size&&z.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const h=Array.from(A.keys());for(const x of h){const L=A.get(x);if(!L)continue;const mL=L.some((L=>L>=256)),p=new(mL?Uint16Array:Uint8Array)(L.length);for(let U=0;U<L.length;U++)p[U]=L[U];const G=this._bufferManager.createBufferView(p,4*(mL?2:1));U.setRemappedBufferView(a,x,G)}}const F=Array.from(p.keys());for(const a of F){const L=p.get(a);if(!L)continue;const x=vL(a,L[0],this._bufferManager,this._bufferViews,this._accessors,U.convertToRightHanded);for(const mL of L)U.bindMorphDataToMesh(mL,x)}}async _exportNodeAsync(L,U,x){let mL=this._nodeMap.get(L);if(void 0!==mL)return void(U.includes(mL)||U.push(mL));const p=await this._createNodeAsync(L,x);if(p){mL=this._nodes.length,this._nodes.push(p),this._nodeMap.set(L,mL),x.pushExportedNode(L),U.push(mL);const G={name:"runtime animations",channels:[],samplers:[]},F=[];this._babylonScene.animationGroups.length||(fL._CreateMorphTargetAnimationFromMorphTargetAnimations(L,G,F,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,x.convertToRightHanded,this._options.shouldExportAnimation),L.animations.length&&fL._CreateNodeAnimationFromNodeAnimations(L,G,F,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,x.convertToRightHanded,this._options.shouldExportAnimation)),G.channels.length&&G.samplers.length&&this._animations.push(G),F.forEach((L=>{L.channels.length&&L.samplers.length&&this._animations.push(L)}))}const G=p?[]:U;for(const F of L.getChildren())await this._exportNodeAsync(F,G,x);p&&G.length&&(p.children=G)}async _createNodeAsync(L,U){if(!this._shouldExportNode(L))return null;const x={};if(L.name&&(x.name=L.name),L.metadata){const U=this._options.metadataSelector(L.metadata);U&&(x.extras=U)}if(L instanceof h.e&&(this._setNodeTransformation(x,L,U.convertToRightHanded),L instanceof b.c)){const p=L instanceof E.e?L.sourceMesh:L;if(p.Sa&&p.Sa.length>0&&(x.mesh=await this._exportMeshAsync(p,U)),L.skeleton){const U=this._skinMap.get(L.skeleton);var mL;if(void 0!==U)void 0===this._nodesSkinMap.get(U)&&this._nodesSkinMap.set(U,[]),null===(mL=this._nodesSkinMap.get(U))||void 0===mL||mL.push(x)}}if(L instanceof M.b){const mL=this._camerasMap.get(L);if(mL){var p;void 0===this._nodesCameraMap.get(mL)&&this._nodesCameraMap.set(mL,[]),this._setCameraTransformation(x,L,U.convertToRightHanded);const F=L.parent;if(null!==F&&UL(L,F)){const L=this._nodeMap.get(F);if(void 0!==L){var G;const U=this._nodes[L];return LL(x,U),null===(G=this._nodesCameraMap.get(mL))||void 0===G||G.push(U),null}}null===(p=this._nodesCameraMap.get(mL))||void 0===p||p.push(x)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",x,L,this._nodeMap,U.convertToRightHanded)?x:(z.c.Warn(`Not exporting node ${L.name}`),null)}_exportIndices(L,U,x,mL,p,F,a,o,A){let r=L;A.mode=s(F);const h=a!==G.c.CounterClockWiseSideOrientation,b=!o.wasAddedByNoopNode&&h,E=function(L){switch(L){case G.c.TriangleFillMode:case G.c.TriangleStripDrawMode:case G.c.TriangleFanDrawMode:return!0}return!1}(F)&&b;if(E){if(F===G.c.TriangleStripDrawMode||F===G.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");A.mode=s(F);const a=U?new Uint32Array(mL):new Uint16Array(mL);if(L)for(let U=0;U+2<mL;U+=3)a[U]=L[x+U]+p,a[U+1]=L[x+U+2]+p,a[U+2]=L[x+U+1]+p;else for(let L=0;L+2<mL;L+=3)a[L]=L,a[L+1]=L+2,a[L+2]=L+1;r=a}else if(L&&0!==p){const G=U?new Uint32Array(mL):new Uint16Array(mL);for(let U=0;U<mL;U++)G[U]=L[x+U]+p;r=G}if(r){let G=o.getIndicesAccessor(L,x,mL,p,E);if(void 0===G){const F=function(L,U,x,mL){if(L instanceof Uint16Array||L instanceof Uint32Array)return L;if(L instanceof Int32Array)return new Uint32Array(L.buffer,L.byteOffset,L.length);const p=L.slice(U,U+x);return mL?new Uint32Array(p):new Uint16Array(p)}(r,0,mL,U),a=this._bufferManager.createBufferView(F),A=U?5125:5123;this._accessors.push(this._bufferManager.createAccessor(a,"SCALAR",A,mL,0)),G=this._accessors.length-1,o.setIndicesAccessor(L,x,mL,p,E,G)}A.indices=G}}_exportVertexBuffer(L,U,x,mL,p,G){const F=L.getKind();if(!B(F))return;if(F.startsWith("uv")&&!this._options.exportUnusedUVs&&(!U||!this._materialNeedsUVsSet.has(U)))return;let a=p.getVertexAccessor(L,x,mL);if(void 0===a){const U=p.convertedToRightHandedBuffers.get(L._buffer)||L._buffer.getData(),G=F===r.h.PositionKind?function(L,U,x,mL){const{byteOffset:p,byteStride:G,type:F,normalized:a}=U,o=U.getSize(),A=new Array(o).fill(1/0),r=new Array(o).fill(-1/0);return(0,g.h)(L,p+x*G,G,o,F,mL*o,a,(L=>{for(let U=0;U<o;U++)A[U]=Math.min(A[U],L[U]),r[U]=Math.max(r[U],L[U])})),{min:A,max:r}}(U,L,x,mL):void 0,o=(F===r.h.MatricesIndicesKind||F===r.h.MatricesIndicesExtraKind)&&L.type===r.h.FLOAT,A=o?r.h.UNSIGNED_BYTE:L.type,h=o?void 0:L.normalized,b=o?p.getRemappedBufferView(L._buffer,L):p.getVertexBufferView(L._buffer),E=L.byteOffset+x*L.byteStride;this._accessors.push(this._bufferManager.createAccessor(b,function(L,U){if(L==r.h.ColorKind)return U?"VEC4":"VEC3";switch(L){case r.h.PositionKind:case r.h.NormalKind:return"VEC3";case r.h.TangentKind:case r.h.MatricesIndicesKind:case r.h.MatricesIndicesExtraKind:case r.h.MatricesWeightsKind:case r.h.MatricesWeightsExtraKind:return"VEC4";case r.h.UVKind:case r.h.UV2Kind:case r.h.UV3Kind:case r.h.UV4Kind:case r.h.UV5Kind:case r.h.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${L}`)}(F,p.hasVertexColorAlpha(L)),A,mL,E,G,h)),a=this._accessors.length-1,p.setVertexAccessor(L,x,mL,a)}G.attributes[function(L){switch(L){case r.h.PositionKind:return"POSITION";case r.h.NormalKind:return"NORMAL";case r.h.TangentKind:return"TANGENT";case r.h.ColorKind:return"COLOR_0";case r.h.UVKind:return"TEXCOORD_0";case r.h.UV2Kind:return"TEXCOORD_1";case r.h.UV3Kind:return"TEXCOORD_2";case r.h.UV4Kind:return"TEXCOORD_3";case r.h.UV5Kind:return"TEXCOORD_4";case r.h.UV6Kind:return"TEXCOORD_5";case r.h.MatricesIndicesKind:return"JOINTS_0";case r.h.MatricesIndicesExtraKind:return"JOINTS_1";case r.h.MatricesWeightsKind:return"WEIGHTS_0";case r.h.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${L}`)}(F)]=a}async _exportMaterialAsync(L,U,x,mL){let p=this._materialMap.get(L);if(void 0===p){const mL=U&&Object.keys(U).some((L=>L.startsWith("uv")));if((L=L instanceof EL.b?L.Xa[x.materialIndex]:L)instanceof YL.d)p=await this._materialExporter.exportPBRMaterialAsync(L,"image/png",mL);else{if(!(L instanceof SL.HU))return void z.c.Warn(`Unsupported material '${L.name}' with type ${L.getClassName()}`);p=await this._materialExporter.exportStandardMaterialAsync(L,"image/png",mL)}this._materialMap.set(L,p)}mL.material=p}async _exportMeshAsync(L,U){var x;let mL=U.getMesh(L);if(void 0!==mL)return mL;const p={primitives:[]};mL=this._meshes.length,this._meshes.push(p),U.setMesh(L,mL);const F=L.isUnIndexed?null:L.Da(),a=null===(x=L.va)||void 0===x?void 0:x.getVertexBuffers(),o=U.getMorphTargetsFromMesh(L),A=L instanceof DL.c,r=L instanceof jL,h=L.Sa;if(a&&h&&h.length>0)for(const Y of h){const x={attributes:{}},mL=Y.ZL()||this._babylonScene.defaultMaterial;if(r){var b,E;const U={name:mL.name},p=L,G=V.QU.White(),F=(null===(b=p.material)||void 0===b?void 0:b.alpha)??1,a=(null===(E=p.greasedLineMaterial)||void 0===E?void 0:E.color)??G;(!a.equalsWithEpsilon(G,J.c)||F<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...a.Va(),F]}),this._materials.push(U),x.material=this._materials.length-1}else if(A){const U={name:mL.name},p=L;(!p.color.equalsWithEpsilon(V.QU.White(),J.c)||p.alpha<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...p.color.Va(),p.alpha]}),this._materials.push(U),x.material=this._materials.length-1}else await this._exportMaterialAsync(mL,a,Y,x);const h=A||r?G.c.LineListDrawMode:L.overrideRenderingFillMode??mL.fillMode,S=mL._getEffectiveOrientation(L);this._exportIndices(F,F?(0,g.c)(F,Y.indexCount,Y.indexStart,Y.verticesStart):Y.verticesCount>65535,F?Y.indexStart:Y.verticesStart,F?Y.indexCount:Y.verticesCount,-Y.verticesStart,h,S,U,x);for(const L of Object.values(a))this._exportVertexBuffer(L,mL,Y.verticesStart,Y.verticesCount,U,x);if(o){x.targets=[];for(const L of o)x.targets.push(L.attributes)}p.primitives.push(x),this._extensionsPostExportMeshPrimitive(x)}if(o){p.weights=[],p.extras||(p.extras={}),p.extras.targetNames=[];for(const L of o)p.weights.push(L.influence),p.extras.targetNames.push(L.name)}return mL}}cL._ExtensionNames=new Array,cL._ExtensionFactories={};class WL{static async GLTFAsync(L,U,x){x&&x.exportWithoutWaitingForScene||await L.whenReadyAsync();const mL=new cL(L,x),p=await mL.generateGLTFAsync(U.replace(/\.[^/.]+$/,""));return mL.dispose(),p}static async GLBAsync(L,U,x){x&&x.exportWithoutWaitingForScene||await L.whenReadyAsync();const mL=new cL(L,x),p=await mL.generateGLBAsync(U.replace(/\.[^/.]+$/,""));return mL.dispose(),p}}x(13175);const IL="EXT_mesh_gpu_instancing";class wL{constructor(L){this.name=IL,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(L,U,x,p,G,F){return await new Promise((L=>{if(U&&x instanceof QL.e&&x.hasThinInstances&&this._exporter){this._wasUsed=!0;const L=mL.YU.Zero(),p=mL.Quaternion.Identity(),a=mL.YU.One(),o=x.thinInstanceGetWorldMatrices(),A=mL.TmpVectors.YU[2],r=mL.TmpVectors.Quaternion[1],h=mL.TmpVectors.YU[3];let b=!1,E=!1,Y=!1;const S=new Float32Array(3*x.ta),V=new Float32Array(4*x.ta),H=new Float32Array(3*x.ta);let Q=0;for(const U of o)U.decompose(h,r,A),G&&(k(A),T(r)),S.set(A.Va(),3*Q),V.set(r.normalize().Va(),4*Q),H.set(h.Va(),3*Q),b=b||!A.equalsWithEpsilon(L),E=E||!r.equalsWithEpsilon(p),Y=Y||!h.equalsWithEpsilon(a),Q++;const q={attributes:{}};b&&(q.attributes.TRANSLATION=this._buildAccessor(S,"VEC3",x.ta,F)),E&&(q.attributes.ROTATION=this._buildAccessor(V,"VEC4",x.ta,F)),Y&&(q.attributes.SCALE=this._buildAccessor(H,"VEC3",x.ta,F)),U.extensions=U.extensions||{},U.extensions[IL]=q}L(U)}))}_buildAccessor(L,U,x,mL){const p=mL.createBufferView(L),G=mL.createAccessor(p,U,5126,x);return this._exporter._accessors.push(G),this._exporter._accessors.length-1}}cL.RegisterExtension(IL,(L=>new wL(L)));var BL=x(13179),sL=x(13191),CL=x(13195),kL=x(13202);function TL(L){return L===CL.e.PositionKind?"POSITION":L===CL.e.NormalKind?"NORMAL":L===CL.e.ColorKind?"COLOR":L.startsWith(CL.e.UVKind)?"TEX_COORD":"GENERIC"}const OL={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class LU extends BL.b{static get DefaultAvailable(){return(0,BL.i)(LU.DefaultConfiguration)}static get Default(){return LU._Default??(LU._Default=new LU),LU._Default}static ResetDefault(L){LU._Default&&(L||LU._Default.dispose(),LU._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(L,U){return{module:await(U||DracoEncoderModule)({wasmBinary:L})}}_getWorkerContent(){return`${sL.h}(${sL.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:LU.DefaultConfiguration)}async _encodeAsync(L,U,x){const mL=x?(0,kL.e)(OL,x):OL;if(this._workerPoolPromise){const x=await this._workerPoolPromise;return await new Promise(((p,G)=>{x.push(((x,F)=>{const a=L=>{x.removeEventListener("error",a),x.removeEventListener("message",o),G(L),F()},o=L=>{"encodeMeshDone"===L.data.id&&(x.removeEventListener("error",a),x.removeEventListener("message",o),p(L.data.encodedMeshData),F())};x.addEventListener("error",a),x.addEventListener("message",o);const A=[];for(const U of L)A.push(U.data.buffer);U&&A.push(U.buffer),x.postMessage({id:"encodeMesh",attributes:L,indices:U,options:mL},A)}))}))}if(this._modulePromise){const x=await this._modulePromise;return(0,sL.h)(x.module,L,U,mL)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(L,U){if(0==L.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");L instanceof QL.e&&L.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===U||void 0===U?void 0:U.method)&&(z.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),U.method="MESH_SEQUENTIAL_ENCODING");const x=function(L){let U=L.Da(void 0,!0);return!U||U instanceof Uint32Array||U instanceof Uint16Array||(U=((0,g.c)(U,U.length)?Uint32Array:Uint16Array).from(U)),U}(L),mL=function(L,U){const x=[];for(const mL of L.getVerticesDataKinds()){if(null!==U&&void 0!==U&&U.includes(mL)){if(mL===CL.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const p=L.getVertexBuffer(mL),G=p.getSize(),F=(0,g.t)(p.getData(),G,p.type,p.byteOffset,p.byteStride,p.normalized,L.getTotalVertices(),!0);x.push({kind:mL,dracoName:TL(mL),size:G,data:F})}return x}(L,null===U||void 0===U?void 0:U.excludedAttributes);return await this._encodeAsync(mL,x,U)}}LU.DefaultConfiguration={wasmUrl:`${p.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${p.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${p.Tools._DefaultCdnUrl}/draco_encoder.js`},LU._Default=null;const UU="KHR_draco_mesh_compression";class xU{get wasUsed(){return this._wasUsed}constructor(L){this.name=UU,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===L.options.meshCompressionMethod&&LU.DefaultAvailable}dispose(){}postExportMeshPrimitive(L,U,x){if(!this.enabled)return;if(4!==L.mode&&5!==L.mode)return void z.c.Warn("Cannot compress primitive with mode "+L.mode+".");const mL=[],p=[];let G=null;if(void 0!==L.indices){const F=x[L.indices],a=U.getBufferView(F);G=U.getData(a).slice(),mL.push(a),p.push(F)}const F=[];for(const[r,h]of Object.entries(L.attributes)){const L=x[h],G=U.getBufferView(L),o=w(L.type),A=(0,g.t)(U.getData(G),o,L.componentType,L.byteOffset||0,G.byteStride||(0,g.l)(L.componentType)*o,L.normalized||!1,L.count,!0);F.push({kind:r,dracoName:(a=r,"POSITION"===a?"POSITION":"NORMAL"===a?"NORMAL":a.startsWith("COLOR")?"COLOR":a.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:w(L.type),data:A}),mL.push(G),p.push(L)}var a;const o={method:L.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},A=LU.Default._encodeAsync(F,G,o).then((x=>{if(!x)return void z.c.Error("Draco encoding failed for primitive.");const G={bufferView:-1,attributes:x.attributeIds},F=U.createBufferView(x.data);U.setBufferView(G,F);for(const L of mL)this._bufferViewsUsed.add(L);for(const L of p)this._accessorsUsed.add(L);L.extensions||(L.extensions={}),L.extensions[UU]=G})).catch((L=>{z.c.Error("Draco encoding failed for primitive: "+L)}));this._encodePromises.push(A),this._wasUsed=!0}async preGenerateBinaryAsync(L){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((U=>{L.getPropertiesWithBufferView(U).every((L=>this._accessorsUsed.has(L)))&&L.removeBufferView(U)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}cL.RegisterExtension(UU,(L=>new xU(L)));var mx=x(13208);const pU="KHR_lights_punctual",GU={name:"",color:[1,1,1],ya:1,range:Number.MAX_VALUE},FU={innerConeAngle:0,outerConeAngle:Math.PI/4},aU=mL.YU.Backward();class oU{constructor(L){this.name=pU,this.enabled=!0,this.required=!1,this._exporter=L}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[pU]=this._lights}async postExportNodeAsync(L,U,x,p,G){return await new Promise((F=>{if(!(x instanceof qL.d))return void F(U);const a=x.getTypeID()==qL.d.LIGHTTYPEID_POINTLIGHT?"point":x.getTypeID()==qL.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":x.getTypeID()==qL.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!a||!(x instanceof mx.d))return z.c.Warn(`${L}: Light ${x.name} is not supported in ${pU}`),void F(U);if(x.falloffType!==qL.d.FALLOFF_GLTF&&z.c.Warn(`${L}: Light falloff for ${x.name} does not match the ${pU} specification!`),!x.position.equalsToFloats(0,0,0)){const L=mL.TmpVectors.YU[0].p(x.position);G&&k(L),U.translation=L.Va()}if("point"!==a){const L=x.direction.normalizeToRef(mL.TmpVectors.YU[0]);G&&k(L);const p=mL.Quaternion.FromUnitVectorsToRef(aU,L,mL.TmpVectors.Quaternion[0]);mL.Quaternion.IsIdentity(p)||(U.rotation=p.Va())}const o={type:a,name:x.name,color:x.na.Va(),ya:x.ya,range:x.range};if(mU(o,GU),"spot"===a){const L=x;o.spot={innerConeAngle:L.innerAngle/2,outerConeAngle:L.angle/2},mU(o.spot,FU)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(o);const A={ip:this._lights.lights.length-1},r=x.parent;if(r&&UL(x,r)){const L=p.get(r);if(L){const x=this._exporter._nodes[L];return LL(U,x),x.extensions||(x.extensions={}),x.extensions[pU]=A,void F(null)}}U.extensions||(U.extensions={}),U.extensions[pU]=A,F(U)}))}}cL.RegisterExtension(pU,(L=>new oU(L)));var AU=x(13115);const rU="KHR_materials_anisotropy";class hU{constructor(L){this.name=rU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,U,x){const mL=[];return x instanceof AU.e&&x.anisotropy.isEnabled&&!x.anisotropy.legacy?(x.anisotropy.texture&&mL.push(x.anisotropy.texture),mL):[]}postExportMaterialAsync(L,U,x){return new Promise((L=>{if(x instanceof AU.e){if(!x.anisotropy.isEnabled||x.anisotropy.legacy)return void L(U);this._wasUsed=!0,U.extensions=U.extensions||{};const mL=this._exporter._materialExporter.getTextureInfo(x.anisotropy.texture),p={anisotropyStrength:x.anisotropy.ya,anisotropyRotation:x.anisotropy.angle,anisotropyTexture:mL??void 0};null!==p.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(x),U.extensions[rU]=p}L(U)}))}}cL.RegisterExtension(rU,(L=>new hU(L)));const bU="KHR_materials_clearcoat";class EU{constructor(L){this.name=bU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,U,x){const mL=[];return x instanceof AU.e&&x.clearCoat.isEnabled?(x.clearCoat.texture&&mL.push(x.clearCoat.texture),!x.clearCoat.useRoughnessFromMainTexture&&x.clearCoat.textureRoughness&&mL.push(x.clearCoat.textureRoughness),x.clearCoat.bumpTexture&&mL.push(x.clearCoat.bumpTexture),mL):[]}postExportMaterialAsync(L,U,x){return new Promise((L=>{if(x instanceof AU.e){if(!x.clearCoat.isEnabled)return void L(U);this._wasUsed=!0,U.extensions=U.extensions||{};const mL=this._exporter._materialExporter.getTextureInfo(x.clearCoat.texture);let G;G=x.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(x.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(x.clearCoat.textureRoughness),x.clearCoat.isTintEnabled&&p.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${x.name}`),x.clearCoat.remapF0OnInterfaceChange&&p.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${x.name}`);const F=this._exporter._materialExporter.getTextureInfo(x.clearCoat.bumpTexture),a={clearcoatFactor:x.clearCoat.ya,clearcoatTexture:mL??void 0,clearcoatRoughnessFactor:x.clearCoat.roughness,clearcoatRoughnessTexture:G??void 0,clearcoatNormalTexture:F??void 0};null===a.clearcoatTexture&&null===a.clearcoatRoughnessTexture&&null===a.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(x),U.extensions[bU]=a}L(U)}))}}cL.RegisterExtension(bU,(L=>new EU(L)));const YU="KHR_materials_diffuse_transmission";function SU(L,U){const x=U.subSurface;let mL=null;return x.translucencyIntensityTexture?mL=x.translucencyIntensityTexture:x.thicknessTexture&&x.useMaskFromThicknessTexture&&(mL=x.thicknessTexture),mL&&!x.useGltfStyleTextures?(z.c.Warn(`${L}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${U.name}`,1),null):mL}class VU{constructor(L){this.name=YU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,U,x){const mL=[];if(x instanceof YL.d&&this._isExtensionEnabled(x)){const U=SU(L,x);return U&&mL.push(U),x.subSurface.translucencyColorTexture&&mL.push(x.subSurface.translucencyColorTexture),mL}return mL}_isExtensionEnabled(L){if(L.unlit)return!1;const U=L.subSurface;return!!U.isTranslucencyEnabled&&(!L.unlit&&!U.useAlbedoToTintTranslucency&&U.useGltfStyleTextures&&1===U.volumeIndexOfRefraction&&0===U.minimumThickness&&0===U.maximumThickness)}postExportMaterialAsync(L,U,x){return new Promise((mL=>{if(x instanceof YL.d&&this._isExtensionEnabled(x)){this._wasUsed=!0;const mL=x.subSurface,p=SU(L,x),G=0==mL.translucencyIntensity?void 0:mL.translucencyIntensity,F=this._exporter._materialExporter.getTextureInfo(p)??void 0,a=!mL.translucencyColor||mL.translucencyColor.equalsFloats(1,1,1)?void 0:mL.translucencyColor.Va(),o=this._exporter._materialExporter.getTextureInfo(mL.translucencyColorTexture)??void 0,A={diffuseTransmissionFactor:G,diffuseTransmissionTexture:F,diffuseTransmissionColorFactor:a,diffuseTransmissionColorTexture:o};(F||o)&&this._exporter._materialNeedsUVsSet.add(x),U.extensions=U.extensions||{},U.extensions[YU]=A}mL(U)}))}}cL.RegisterExtension(YU,(L=>new VU(L)));const HU="KHR_materials_dispersion";class QU{constructor(){this.name=HU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(L){if(L.unlit)return!1;const U=L.subSurface;return!(!U.isRefractionEnabled&&!U.isDispersionEnabled)}postExportMaterialAsync(L,U,x){return new Promise((L=>{if(x instanceof YL.d&&this._isExtensionEnabled(x)){this._wasUsed=!0;const L={dispersion:x.subSurface.dispersion};U.extensions=U.extensions||{},U.extensions[HU]=L}L(U)}))}}cL.RegisterExtension(HU,(()=>new QU));const qU="KHR_materials_emissive_strength";class fU{constructor(){this.name=qU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(L,U,x){return await new Promise((L=>{if(!(x instanceof YL.d))return L(U);const mL=x.emissiveColor.Va(),p=Math.max(...mL);if(p>1){this._wasUsed=!0,U.extensions||(U.extensions={});const L={emissiveStrength:p},mL=x.emissiveColor.scale(1/L.emissiveStrength);U.emissiveFactor=mL.Va(),U.extensions[qU]=L}return L(U)}))}}cL.RegisterExtension(qU,(L=>new fU));const vU="KHR_materials_ior";class DU{constructor(){this.name=vU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(L){return!L.unlit&&(void 0!=L.indexOfRefraction&&1.5!=L.indexOfRefraction)}postExportMaterialAsync(L,U,x){return new Promise((L=>{if(x instanceof YL.d&&this._isExtensionEnabled(x)){this._wasUsed=!0;const L={ior:x.indexOfRefraction};U.extensions=U.extensions||{},U.extensions[vU]=L}L(U)}))}}cL.RegisterExtension(vU,(L=>new DU));const PU="KHR_materials_iridescence";class dU{constructor(L){this.name=PU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,U,x){const mL=[];return x instanceof AU.e&&x.iridescence.isEnabled?(x.iridescence.texture&&mL.push(x.iridescence.texture),x.iridescence.thicknessTexture&&x.iridescence.thicknessTexture!==x.iridescence.texture&&mL.push(x.iridescence.thicknessTexture),mL):[]}postExportMaterialAsync(L,U,x){return new Promise((L=>{if(x instanceof AU.e){if(!x.iridescence.isEnabled)return void L(U);this._wasUsed=!0,U.extensions=U.extensions||{};const mL=this._exporter._materialExporter.getTextureInfo(x.iridescence.texture),p=this._exporter._materialExporter.getTextureInfo(x.iridescence.thicknessTexture),G={iridescenceFactor:x.iridescence.ya,iridescenceIor:x.iridescence.indexOfRefraction,iridescenceThicknessMinimum:x.iridescence.minimumThickness,iridescenceThicknessMaximum:x.iridescence.maximumThickness,iridescenceTexture:mL??void 0,iridescenceThicknessTexture:p??void 0};null===G.iridescenceTexture&&null===G.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(x),U.extensions[PU]=G}L(U)}))}}cL.RegisterExtension(PU,(L=>new dU(L)));const KU="KHR_materials_sheen";class lU{constructor(L){this.name=KU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,U,x){return x instanceof YL.d&&x.sheen.isEnabled&&x.sheen.texture?[x.sheen.texture]:[]}async postExportMaterialAsync(L,U,x){return await new Promise((L=>{if(x instanceof YL.d){if(!x.sheen.isEnabled)return void L(U);this._wasUsed=!0,null==U.extensions&&(U.extensions={});const mL={sheenColorFactor:x.sheen.color.Va(),sheenRoughnessFactor:x.sheen.roughness??0};null===mL.sheenColorTexture&&null===mL.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(x),x.sheen.texture&&(mL.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(x.sheen.texture)??void 0),x.sheen.textureRoughness&&!x.sheen.useRoughnessFromMainTexture?mL.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(x.sheen.textureRoughness)??void 0:x.sheen.texture&&x.sheen.useRoughnessFromMainTexture&&(mL.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(x.sheen.texture)??void 0),U.extensions[KU]=mL}L(U)}))}}cL.RegisterExtension(KU,(L=>new lU(L)));const iU="KHR_materials_specular";class XU{constructor(L){this.name=iU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,U,x){const mL=[];return x instanceof YL.d&&this._isExtensionEnabled(x)?(x.metallicReflectanceTexture&&mL.push(x.metallicReflectanceTexture),x.reflectanceTexture&&mL.push(x.reflectanceTexture),mL):mL}_isExtensionEnabled(L){return!L.unlit&&(void 0!=L.metallicF0Factor&&1!=L.metallicF0Factor||void 0!=L.metallicReflectanceColor&&!L.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(L))}_hasTexturesExtension(L){return null!=L.metallicReflectanceTexture||null!=L.reflectanceTexture}postExportMaterialAsync(L,U,x){return new Promise((L=>{if(x instanceof YL.d&&this._isExtensionEnabled(x)){this._wasUsed=!0,U.extensions=U.extensions||{};const L=this._exporter._materialExporter.getTextureInfo(x.metallicReflectanceTexture)??void 0,mL=this._exporter._materialExporter.getTextureInfo(x.reflectanceTexture)??void 0,p={specularFactor:1==x.metallicF0Factor?void 0:x.metallicF0Factor,specularTexture:L,specularColorFactor:x.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:x.metallicReflectanceColor.Va(),specularColorTexture:mL};this._hasTexturesExtension(x)&&this._exporter._materialNeedsUVsSet.add(x),U.extensions[iU]=p}L(U)}))}}cL.RegisterExtension(iU,(L=>new XU(L)));const tU="KHR_materials_transmission";class yU{constructor(L){this.name=tU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,U,x){const mL=[];return x instanceof YL.d&&this._isExtensionEnabled(x)?(x.subSurface.thicknessTexture&&mL.push(x.subSurface.thicknessTexture),mL):mL}_isExtensionEnabled(L){if(L.unlit)return!1;const U=L.subSurface;return U.isRefractionEnabled&&void 0!=U.refractionIntensity&&0!=U.refractionIntensity||this._hasTexturesExtension(L)}_hasTexturesExtension(L){return null!=L.subSurface.refractionIntensityTexture}async postExportMaterialAsync(L,U,x){if(x instanceof YL.d&&this._isExtensionEnabled(x)){this._wasUsed=!0;const mL=x.subSurface,p={transmissionFactor:0===mL.refractionIntensity?void 0:mL.refractionIntensity};if(this._hasTexturesExtension(x)&&this._exporter._materialNeedsUVsSet.add(x),mL.refractionIntensityTexture)if(mL.useGltfStyleTextures){const L=await this._exporter._materialExporter.exportTextureAsync(mL.refractionIntensityTexture,"image/png");L&&(p.transmissionTexture=L)}else z.c.Warn(`${L}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);U.extensions||(U.extensions={}),U.extensions[tU]=p}return U}}cL.RegisterExtension(tU,(L=>new yU(L)));const nU="KHR_materials_unlit";class NU{constructor(){this.name=nU,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(L,U,x){return new Promise((L=>{let mL=!1;x instanceof YL.d?mL=x.unlit:x instanceof SL.HU&&(mL=x.disableLighting),mL&&(this._wasUsed=!0,null==U.extensions&&(U.extensions={}),U.extensions[nU]={}),L(U)}))}}cL.RegisterExtension(nU,(()=>new NU));const eU="KHR_materials_volume";class uU{constructor(L){this.name=eU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,U,x){const mL=[];return x instanceof YL.d&&this._isExtensionEnabled(x)?(x.subSurface.thicknessTexture&&mL.push(x.subSurface.thicknessTexture),mL):mL}_isExtensionEnabled(L){if(L.unlit)return!1;const U=L.subSurface;return!(!U.isRefractionEnabled&&!U.isTranslucencyEnabled)&&(void 0!=U.maximumThickness&&0!=U.maximumThickness||void 0!=U.tintColorAtDistance&&U.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=U.tintColor&&U.tintColor!=V.QU.White()||this._hasTexturesExtension(L))}_hasTexturesExtension(L){return null!=L.subSurface.thicknessTexture}postExportMaterialAsync(L,U,x){return new Promise((L=>{if(x instanceof YL.d&&this._isExtensionEnabled(x)){this._wasUsed=!0;const L=x.subSurface,mL={thicknessFactor:0==L.maximumThickness?void 0:L.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(L.thicknessTexture)??void 0,attenuationDistance:L.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:L.tintColorAtDistance,attenuationColor:L.tintColor.equalsFloats(1,1,1)?void 0:L.tintColor.Va()};this._hasTexturesExtension(x)&&this._exporter._materialNeedsUVsSet.add(x),U.extensions=U.extensions||{},U.extensions[eU]=mL}L(U)}))}}cL.RegisterExtension(eU,(L=>new uU(L)));const ZU="EXT_materials_diffuse_roughness";class gU{constructor(L){this.name=ZU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,U,x){const mL=[];return x instanceof AU.e&&x._baseDiffuseRoughness?(x._baseDiffuseRoughnessTexture&&mL.push(x._baseDiffuseRoughnessTexture),mL):[]}postExportMaterialAsync(L,U,x){return new Promise((L=>{if(x instanceof AU.e){if(!x._baseDiffuseRoughness)return void L(U);this._wasUsed=!0,U.extensions=U.extensions||{};const mL=this._exporter._materialExporter.getTextureInfo(x._baseDiffuseRoughnessTexture),p={diffuseRoughnessFactor:x._baseDiffuseRoughness,diffuseRoughnessTexture:mL??void 0};null!==p.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(x),U.extensions[ZU]=p}L(U)}))}}cL.RegisterExtension(ZU,(L=>new gU(L)));const zU="KHR_texture_transform";class MU{constructor(){this.name=zU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(L,U,x){if(x.PL()||p.Tools.Warn(`${L}: /*@__KEY__*/"scene" is not defined for Babylon texture ${x.name}!`),(0!==x.uAng||0!==x.vAng)&&(p.Tools.Warn(`${L}: Texture ${x.name} with rotation in the u or v axis is not supported in glTF.`),0!==x.uRotationCenter||0!==x.vRotationCenter))return;const mL={};let G=!1;if(0===x.uOffset&&0===x.vOffset||(mL.offset=[x.uOffset,x.vOffset],G=!0),1===x.uScale&&1===x.vScale||(mL.scale=[x.uScale,x.vScale],G=!0),0!==x.wAng){if(0!==x.uRotationCenter||0!==x.vRotationCenter){if(x.homogeneousRotationInUVTransform&&x.uScale!==x.vScale)return void p.Tools.Warn(`${L}: Texture ${x.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${zU}.`);p.Tools.Warn(`${L}: Texture ${x.name} with non-origin rotation center will be exported using an adjusted offset with ${zU}.`),mL.offset=function(L){const{uOffset:U,vOffset:x,uRotationCenter:mL,vRotationCenter:p,uScale:G,vScale:F,wAng:a}=L,o=Math.cos(a),A=Math.sin(a),r=mL*G,h=p*F;return[U+(r*(1-o)+h*A),x+(h*(1-o)-r*A)]}(x)}mL.rotation=-x.wAng,G=!0}0!==x.coordinatesIndex&&(mL.texCoord=x.coordinatesIndex,G=!0),G&&(this._wasUsed=!0,U.extensions||(U.extensions={}),U.extensions[zU]=mL)}}cL.RegisterExtension(zU,(()=>new MU));class JU{static CreateSTL(L){let U=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",p=arguments.length>3&&void 0!==arguments[3]&&arguments[3],G=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],F=arguments.length>5&&void 0!==arguments[5]&&arguments[5],a=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const A=function(L,U,x){const p=[3*L[x],3*L[x+1],3*L[x+2]],G=[new mL.YU(U[p[0]],U[p[0]+2],U[p[0]+1]),new mL.YU(U[p[1]],U[p[1]+2],U[p[1]+1]),new mL.YU(U[p[2]],U[p[2]+2],U[p[2]+1])],F=G[0].SU(G[1]),a=G[2].SU(G[1]);return{v:G,n:mL.YU.Cross(a,F).normalize()}},h=function(L,U,x,mL){return U=b(L,U,x.x,mL),U=b(L,U,x.y,mL),b(L,U,x.z,mL)},b=function(L,U,x,mL){return L.setFloat32(U,x,mL),U+4},Y=function(L){if(a){let U=L;L instanceof E.e&&(U=L.sourceMesh);const x=U.getVerticesData(r.h.PositionKind,!0,!0);if(!x)return[];const p=mL.YU.Zero();let G;for(G=0;G<x.length;G+=3)mL.YU.TransformCoordinatesFromFloatsToRef(x[G],x[G+1],x[G+2],L.fa(!0),p).toArray(x,G);return x}return L.getVerticesData(r.h.PositionKind)||[]};a&&(F=!0);let S="",V=0,H=0;if(p){for(let x=0;x<L.length;x++){const U=L[x].Da();V+=U?U.length/3:0}const U=new ArrayBuffer(84+50*V);S=new DataView(U),H+=80,S.setUint32(H,V,G),H+=4}else o||(S="solid stlmesh\r\n");for(let mL=0;mL<L.length;mL++){const U=L[mL];!p&&o&&(S+="solid "+U.name+"\r\n"),!F&&U instanceof QL.e&&U.bakeCurrentTransformIntoVertices();const x=Y(U),a=U.Da()||[];for(let L=0;L<a.length;L+=3){const U=A(a,x,L);p?(H=h(S,H,U.n,G),H=h(S,H,U.v[0],G),H=h(S,H,U.v[1],G),H=h(S,H,U.v[2],G),H+=2):(S+="\tfacet normal "+U.n.x+" "+U.n.y+" "+U.n.z+"\r\n",S+="\t\touter loop\r\n",S+="\t\t\tvertex "+U.v[0].x+" "+U.v[0].y+" "+U.v[0].z+"\r\n",S+="\t\t\tvertex "+U.v[1].x+" "+U.v[1].y+" "+U.v[1].z+"\r\n",S+="\t\t\tvertex "+U.v[2].x+" "+U.v[2].y+" "+U.v[2].z+"\r\n",S+="\t\tendloop\r\n",S+="\tendfacet\r\n")}!p&&o&&(S+="endsolid "+name+"\r\n")}if(p||o||(S+="endsolid stlmesh"),U){const L=document.createElement("a"),U=new Blob([S],{type:"application/octet-stream"});L.href=window.URL.createObjectURL(U),L.download=x+".stl",L.click()}return S}}function jU(L,U){let x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const mL=[];for(let p=0;p<L.length/x;p++){const G=L[p*x],F=L[p*x+1],a=L[p*x+2];mL.push(`(${G.toPrecision(U.precision)}, ${F.toPrecision(U.precision)}, ${a.toPrecision(U.precision)})`)}return mL.join(", ")}function RU(L,U){const x=[];for(let mL=0;mL<L.length/2;mL++){const p=L[2*mL],G=L[2*mL+1];x.push(`(${p.toPrecision(U.precision)}, ${(1-G).toPrecision(U.precision)})`)}return x.join(", ")}function cU(L,U){const x=L.getVerticesData(r.h.PositionKind),mL=L.getVerticesData(r.h.NormalKind);if(x&&mL)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(L){var U;const x=null!==(U=L.Da())&&void 0!==U&&U.length?L.getTotalIndices():L.getTotalVertices();return Array(x/3).fill(3).join(", ")}(L)}]\n\t\tint[] faceVertexIndices = [${function(L){const U=L.Da(),x=[];if(null!==U)for(let mL=0;mL<U.length;mL++)x.push(U[mL]);else{const U=L.getTotalVertices();for(let L=0;L<U;L++)x.push(L)}return x.join(", ")}(L)}]\n\t\tnormal3f[] normals = [${jU(mL,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${jU(x,U)}]\n        ${function(L,U){let x="";for(let p=0;p<4;p++){const mL=p>0?p:"",G=L.getVerticesData(r.h.UVKind+(mL?mL+1:""));G&&(x+=`\n\t\ttexCoord2f[] primvars:st${mL} = [${RU(G,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const mL=L.getVerticesData(r.h.ColorKind);return mL&&(x+=`\n\tcolor3f[] primvars:displayColor = [${jU(mL,U,mL.length/L.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),x}(L,U)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function WU(L,U){return`\n        def "Geometry"\n        {\n        ${cU(L,U)}\n        }\n        `}function IU(L){let U='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return U+=L,fflate.strToU8(U)}function wU(L){const U=L.m;return`( ${BU(U,0)}, ${BU(U,4)}, ${BU(U,8)}, ${BU(U,12)} )`}function BU(L,U){return`(${L[U+0]}, ${L[U+1]}, ${L[U+2]}, ${L[U+3]})`}function sU(L){const U="Object_"+L.uniqueId,x=function(L){const U=L.getWorldMatrix().clone(),x=L.PL().useRightHandedSystem;if(!x){let mL=L.parent;for(;mL;){if(FL(mL,x)){U.multiplyToRef(mL.getWorldMatrix().invert(),U);break}mL=mL.parent}}return U.determinant()<0&&p.Tools.Warn(`Exporting mesh ${L.name} with negative scale. Result may look incorrect in destination engine.`),U}(L),mL=wU(x);return`def Xform "${U}" (\n\tprepend references = @./geometries/Geometry_${L.va.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${mL}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${L.material.uniqueId}>\n}\n\n`}function CU(L){switch(L){case P.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case P.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case P.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function kU(L){return`(${L.x}, ${L.y})`}function TU(L){return`(${L.r}, ${L.g}, ${L.b})`}function OU(L,U,x,p,G,F){const a=L.getInternalTexture().uniqueId+"_"+L.invertY;G[a]=L;const o=L.coordinatesIndex>0?"st"+L.coordinatesIndex:"st",A=new mL.Vector2(L.uScale,L.vScale),r=new mL.Vector2(L.uOffset,L.vOffset),h=L.wAng,b=Math.sin(h),E=Math.cos(h);return r.y=1-r.y-A.y,r.x+=b*A.x,r.y+=(1-E)*A.y,`\n    def Shader "PrimvarReader_${x}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${o}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${x}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${U.uniqueId}/PrimvarReader_${x}.outputs:result>\n        float inputs:rotation = ${(h*(180/Math.PI)).toFixed(F.precision)}\n        float2 inputs:scale = ${kU(A)}\n        float2 inputs:translation = ${kU(r)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${L.uniqueId}_${x}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${a}.png@\n        float2 inputs:st.connect = </Materials/Material_${U.uniqueId}/Transform2d_${x}.outputs:result>\n        ${p?"float4 inputs:scale = "+function(L){return`(${L.r}, ${L.g}, ${L.b}, 1.0)`}(p):""}\n        token inputs:sourceColorSpace = "${L.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${CU(L.wrapU)}"\n        token inputs:wrapT = "${CU(L.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${U.needAlphaBlending()?"float outputs:a":""}\n    }`}function Lx(L,U,x){const mL="\t\t\t",p=[],G=[],{diffuseMap:F,na:a,alphaCutOff:o,emissiveMap:A,emissive:r,normalMap:h,roughnessMap:b,roughnessChannel:E,roughness:Y,metalnessMap:S,metalnessChannel:H,metalness:Q,aoMap:q,aoMapChannel:f,aoMapIntensity:v,alphaMap:D,ior:P,clearCoatEnabled:d,clearCoat:K,clearCoatMap:l,clearCoatRoughness:i,clearCoatRoughnessMap:X}=function(L){const U={diffuseMap:null,na:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return L instanceof SL.HU?{...U,diffuseMap:L.diffuseTexture,na:L.diffuseColor,alphaCutOff:L.alphaCutOff,emissiveMap:L.emissiveTexture,emissive:L.emissiveColor,roughness:1,alphaMap:L.opacityTexture}:L instanceof AU.e?{...U,diffuseMap:L._albedoTexture,na:L._albedoColor,alphaCutOff:L._alphaCutOff,emissiveMap:L._emissiveTexture,emissive:L._emissiveColor,normalMap:L._bumpTexture,roughnessMap:L._metallicTexture,roughnessChannel:L._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:L._roughness??1,metalnessMap:L._metallicTexture,metalnessChannel:L._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:L._metallic??0,aoMap:L._ambientTexture,aoMapChannel:L._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:L._ambientTextureStrength,alphaMap:L._opacityTexture,ior:L.subSurface.indexOfRefraction,clearCoatEnabled:L.clearCoat.isEnabled,clearCoat:L.clearCoat.ya,clearCoatMap:L.clearCoat.texture,clearCoatRoughness:L.clearCoat.roughness,clearCoatRoughnessMap:L.clearCoat.useRoughnessFromMainTexture?L.clearCoat.texture:L.clearCoat.textureRoughness}:U}(L);return null!==F?(p.push(`${mL}color3f inputs:diffuseColor.connect = </Materials/Material_${L.uniqueId}/Texture_${F.uniqueId}_diffuse.outputs:rgb>`),L.needAlphaBlending()?p.push(`${mL}float inputs:opacity.connect = </Materials/Material_${L.uniqueId}/Texture_${F.uniqueId}_diffuse.outputs:a>`):L.needAlphaTesting()&&(p.push(`${mL}float inputs:opacity.connect = </Materials/Material_${L.uniqueId}/Texture_${F.uniqueId}_diffuse.outputs:a>`),p.push(`${mL}float inputs:opacityThreshold = ${o}`)),G.push(OU(F,L,"diffuse",a,U,x))):p.push(`${mL}color3f inputs:diffuseColor = ${TU(a||V.QU.White())}`),null!==A?(p.push(`${mL}color3f inputs:emissiveColor.connect = </Materials/Material_${L.uniqueId}/Texture_${A.uniqueId}_emissive.outputs:rgb>`),G.push(OU(A,L,"emissive",r,U,x))):r&&r.toLuminance()>0&&p.push(`${mL}color3f inputs:emissiveColor = ${TU(r)}`),null!==h&&(p.push(`${mL}normal3f inputs:normal.connect = </Materials/Material_${L.uniqueId}/Texture_${h.uniqueId}_normal.outputs:rgb>`),G.push(OU(h,L,"normal",null,U,x))),null!==q&&(p.push(`${mL}float inputs:occlusion.connect = </Materials/Material_${L.uniqueId}/Texture_${q.uniqueId}_occlusion.outputs:${f}>`),G.push(OU(q,L,"occlusion",new V.QU(v,v,v),U,x))),null!==b?(p.push(`${mL}float inputs:roughness.connect = </Materials/Material_${L.uniqueId}/Texture_${b.uniqueId}_roughness.outputs:${E}>`),G.push(OU(b,L,"roughness",new V.QU(Y,Y,Y),U,x))):p.push(`${mL}float inputs:roughness = ${Y}`),null!==S?(p.push(`${mL}float inputs:metallic.connect = </Materials/Material_${L.uniqueId}/Texture_${S.uniqueId}_metallic.outputs:${H}>`),G.push(OU(S,L,"metallic",new V.QU(Q,Q,Q),U,x))):p.push(`${mL}float inputs:metallic = ${Q}`),null!==D?(p.push(`${mL}float inputs:opacity.connect = </Materials/Material_${L.uniqueId}/Texture_${D.uniqueId}_opacity.outputs:r>`),p.push(`${mL}float inputs:opacityThreshold = 0.0001`),G.push(OU(D,L,"opacity",null,U,x))):p.push(`${mL}float inputs:opacity = ${L.alpha}`),d&&(null!==l?(p.push(`${mL}float inputs:clearcoat.connect = </Materials/Material_${L.uniqueId}/Texture_${l.uniqueId}_clearcoat.outputs:r>`),G.push(OU(l,L,"clearcoat",new V.QU(K,K,K),U,x))):p.push(`${mL}float inputs:clearcoat = ${K}`),null!==X?(p.push(`${mL}float inputs:clearcoatRoughness.connect = </Materials/Material_${L.uniqueId}/Texture_${X.uniqueId}_clearcoatRoughness.outputs:g>`),G.push(OU(X,L,"clearcoatRoughness",new V.QU(i,i,i),U,x))):p.push(`${mL}float inputs:clearcoatRoughness = ${i}`)),p.push(`${mL}float inputs:ior = ${P}`),`\n\tdef Material "Material_${L.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${p.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${L.uniqueId}/PreviewSurface.outputs:surface>\n\n${G.join("\n")}\n\n\t}\n`}async function Ux(L,U,x){const G={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...U};"undefined"===typeof fflate&&await p.Tools.LoadScriptAsync(G.fflateUrl);const F={};F[G.modelFileName]=null;let a='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';a+=function(L){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===L.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${L.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${L.planeAnchoringAlignment}"`:""}\n            `}(G);const o={};for(const mL of L.meshes){if(0===mL.getTotalVertices())continue;const L=mL,U=L.va,A=L.material;if(!A||!U||x&&!x(L))continue;if(-1!==["HU","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(A.getClassName())){const x="geometries/Geometry_"+U.uniqueId+".usda";if(!(x in F)){const L=WU(U,G);F[x]=IU(L)}A.uniqueId in o||(o[A.uniqueId]=A),a+=sU(L)}else p.Tools.Warn("USDZExportAsync does not support this material type: "+A.getClassName())}L.activeCamera&&G.exportCamera&&(a+=function(L,U){const x="Camera_"+L.uniqueId,p=wU(mL.Matrix.RotationY(Math.PI).multiply(L.getWorldMatrix()));if(L.mode===P.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${x}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${p}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${L.Qa.toPrecision(U.precision)}, ${L.maxZ.toPrecision(U.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(L.orthoLeft||1)+Math.abs(L.orthoRight||1))).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(L.orthoTop||1)+Math.abs(L.orthoBottom||1))).toPrecision(U.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const mL=L.getEngine().getAspectRatio(L),G=U.cameraSensorWidth||35;return`def Camera "${x}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${p}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${L.Qa.toPrecision(U.precision)}, ${L.maxZ.toPrecision(U.precision)})\n\t\t\tfloat focalLength = ${(G/(2*Math.tan(.5*L.fov))).toPrecision(U.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(G*mL).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(G/mL).toPrecision(U.precision)}            \n\t\t}\n\t\n\t`}}(L.activeCamera,G)),a+="\n            }\n        }\n    }";const A={};a+=function(L,U,x){const mL=[];for(const p in L){const G=L[p];mL.push(Lx(G,U,x))}return`\n    def "Materials"\n{\n${mL.join("")}\n}\n\n`}(o,A,G),F[G.modelFileName]=fflate.strToU8(a);for(const mL in A){const L=A[mL],U=L.getSize(),x=await L.readPixels();if(!x)throw new Error("Texture data is not available");const p=await d.DumpTools.DumpDataAsync(U.width,U.height,x,"image/png",void 0,!1,!0);F[`textures/Texture_${mL}.png`]=new Uint8Array(p).slice()}let r=0;for(const mL in F){const L=F[mL];if(!L)continue;r+=34+mL.length;const U=63&r;if(4!==U){const x=new Uint8Array(64-U);F[mL]=[L,{extra:{12345:x}}]}r=L.length}return fflate.zipSync(F,{level:0})}}}]);