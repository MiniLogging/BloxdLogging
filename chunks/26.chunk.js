"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[26],{12799:(V,h,mV)=>{mV.r(h),mV.d(h,{EXT_materials_diffuse_roughness:()=>fh,EXT_mesh_gpu_instancing:()=>UV,GLTF2Export:()=>bV,GLTFData:()=>K,KHR_draco_mesh_compression:()=>mm,KHR_lights_punctual:()=>Ch,KHR_materials_anisotropy:()=>nh,KHR_materials_clearcoat:()=>xh,KHR_materials_diffuse_transmission:()=>sh,KHR_materials_dispersion:()=>ch,KHR_materials_emissive_strength:()=>Qh,KHR_materials_ior:()=>vh,KHR_materials_iridescence:()=>Hh,KHR_materials_sheen:()=>lh,KHR_materials_specular:()=>yh,KHR_materials_transmission:()=>Ih,KHR_materials_unlit:()=>Th,KHR_materials_volume:()=>ph,KHR_texture_transform:()=>Yh,OBJExport:()=>A,STLExport:()=>wh,USDZExportAsync:()=>hm,_ConvertToGLTFPBRMetallicRoughness:()=>r,_SolveMetallic:()=>I,__IGLTFExporterExtension:()=>k});var t=mV(12422),L=mV(12253),N=mV(12718);class A{static OBJ(V,h,mV,A){const k=[];let C=1,K=1;h&&(mV||(mV="mat"),k.push("mtllib "+mV+".mtl"));for(let o=0;o<V.length;o++){const mV=V[o],n=mV.name||`mesh${o}}`;k.push(`o ${n}`);let q=null;if(A){const V=mV.Qk(!0);q=new t.Matrix,V.invertToRef(q),mV.bakeTransformIntoVertices(V)}if(h){const V=mV.material;V&&k.push("usemtl "+V.id)}const x=mV.Jk;if(!x){L.Tools.Warn("No geometry is present on the mesh");continue}const R=x.getVerticesData("position"),d=x.getVerticesData("normal"),s=x.getVerticesData("uv"),M=x.vk();let c=0,z=0;if(!R||!M){L.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const Q=V[0].DV().useRightHandedSystem?1:-1;for(let V=0;V<R.length;V+=3)k.push("v "+R[V]*Q+" "+R[V+1]+" "+R[V+2]),c++;if(null!=d)for(let V=0;V<d.length;V+=3)k.push("vn "+d[V]*Q+" "+d[V+1]+" "+d[V+2]);if(null!=s)for(let V=0;V<s.length;V+=2)k.push("vt "+s[V]+" "+s[V+1]),z++;const J=["","",""],v=(mV.material||mV.DV().defaultMaterial)._getEffectiveOrientation(mV),[D,H]=v===N.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let V=0;V<M.length;V+=3){const h=[String(M[V]+C),String(M[V+D]+C),String(M[V+H]+C)],mV=[String(M[V]+K),String(M[V+D]+K),String(M[V+H]+K)],t=h,L=null!=s?mV:J,N=null!=d?h:J;k.push("f "+t[0]+"/"+L[0]+"/"+N[0]+" "+t[1]+"/"+L[1]+"/"+N[1]+" "+t[2]+"/"+L[2]+"/"+N[2])}A&&q&&mV.bakeTransformIntoVertices(q),C+=c,K+=z}return k.join("\n")}static MTL(V){const h=[],mV=V.material;h.push("newmtl mat1"),h.push("  Ns "+mV.specularPower.toFixed(4)),h.push("  Ni 1.5000"),h.push("  d "+mV.alpha.toFixed(4)),h.push("  Tr 0.0000"),h.push("  Tf 1.0000 1.0000 1.0000"),h.push("  illum 2"),h.push("  Ka "+mV.ambientColor.r.toFixed(4)+" "+mV.ambientColor.g.toFixed(4)+" "+mV.ambientColor.b.toFixed(4)),h.push("  Kd "+mV.diffuseColor.r.toFixed(4)+" "+mV.diffuseColor.g.toFixed(4)+" "+mV.diffuseColor.b.toFixed(4)),h.push("  Ks "+mV.specularColor.r.toFixed(4)+" "+mV.specularColor.g.toFixed(4)+" "+mV.specularColor.b.toFixed(4)),h.push("  Ke "+mV.emissiveColor.r.toFixed(4)+" "+mV.emissiveColor.g.toFixed(4)+" "+mV.emissiveColor.b.toFixed(4));mV.ambientTexture&&h.push("  map_Ka "+mV.ambientTexture.name),mV.diffuseTexture&&h.push("  map_Kd "+mV.diffuseTexture.name),mV.specularTexture&&h.push("  map_Ks "+mV.specularTexture.name),mV.bumpTexture&&h.push("  map_bump -imfchan z "+mV.bumpTexture.name),mV.opacityTexture&&h.push("  map_d "+mV.opacityTexture.name);return h.join("\n")}}var k=0,C=mV(12303);class K{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const V in this.files){const h=this.files[V],mV=new Blob([h],{type:(0,C.j)(V)});L.Tools.Download(mV,V)}}}var o=mV(12481),n=mV(12806),q=mV(12811),x=mV(12829),R=mV(12544),d=mV(12300),s=mV(12453),M=mV(12435);const c=M.HighestCommonFactor,z={...M,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:c};var Q=mV(12632),J=mV(12406),v=mV(12860),D=mV(12867),H=mV(12625);const j=1e-6,l=new s.Jh(.04,.04,.04),G=1024,y=s.Jh.White(),O=s.Jh.Black();function I(V,h,mV){if(h<l.r)return 0;const t=l.r,L=V*mV/(1-l.r)+h-2*l.r,N=L*L-4*t*(l.r-h);return z.Clamp((-L+Math.sqrt(N))/(2*t),0,1)}function r(V){const h=V.diffuseColor.toLinearSpace(V.DV().getEngine().useExactSrgbConversions).scale(.5),mV=V.alpha,L=function(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new t.Vector2(0,1),mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new t.Vector2(0,.1),L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new t.Vector2(0,.1),N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new t.Vector2(1300,.1);return function(V,h,mV,t,L){return(1-V)*(1-V)*(1-V)*h+3*(1-V)*(1-V)*V*mV+3*(1-V)*V*V*t+V*V*V*L}(Math.pow(V/N.x,.333333),h.y,mV.y,L.y,N.y)}(z.Clamp(V.specularPower,0,G));return{baseColorFactor:[h.r,h.g,h.b,mV],metallicFactor:0,roughnessFactor:L}}function T(V,h){h.needAlphaBlending()?V.alphaMode="BLEND":h.needAlphaTesting()&&(V.alphaMode="MASK",V.alphaCutoff=h.alphaCutOff)}function F(V,h,mV){const t=new Uint8Array(V*h*4);for(let L=0;L<t.length;L+=4)t[L]=t[L+1]=t[L+2]=t[L+3]=255;return v.e.CreateRGBATexture(t,V,h,mV)}function p(V){if(V instanceof Uint8Array){const h=V.length,mV=new Float32Array(V.length);for(let t=0;t<h;++t)mV[t]=V[t]/255;return mV}if(V instanceof Float32Array)return V;throw new Error("Unsupported pixel format!")}class Z{constructor(V){this._exporter=V,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(V){return V?this._textureMap.get(V)??null:null}async exportStandardMaterialAsync(V,h,mV){const t=r(V),N={name:V.name};if(null==V.Dk||V.Dk||(V.twoSidedLighting||L.Tools.Warn(V.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),N.doubleSided=!0),mV){const mV=[],L=V.diffuseTexture;L&&mV.push(this.exportTextureAsync(L,h).then((V=>{V&&(t.baseColorTexture=V)})));const A=V.bumpTexture;A&&mV.push(this.exportTextureAsync(A,h).then((V=>{V&&(N.normalTexture=V,1!==A.level&&(N.normalTexture.scale=A.level))})));const k=V.emissiveTexture;k&&(N.emissiveFactor=[1,1,1],mV.push(this.exportTextureAsync(k,h).then((V=>{V&&(N.emissiveTexture=V)}))));const C=V.ambientTexture;C&&mV.push(this.exportTextureAsync(C,h).then((V=>{if(V){const h={index:V.index};N.occlusionTexture=h}}))),mV.length>0&&(this._exporter._materialNeedsUVsSet.add(V),await Promise.all(mV))}(V.alpha<1||V.opacityTexture)&&(V.alphaMode===D.e.ALPHA_COMBINE?N.alphaMode="BLEND":L.Tools.Warn(V.name+": glTF 2.0 does not support alpha mode: "+V.alphaMode.toString())),V.emissiveColor&&!V.emissiveColor.equalsWithEpsilon(O,j)&&(N.emissiveFactor=V.emissiveColor.sk()),N.pbrMetallicRoughness=t,T(N,V),await this._finishMaterialAsync(N,V,h);const A=this._exporter._materials;return A.push(N),A.length-1}async _finishMaterialAsync(V,h,mV){const t=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",V,h),L=[];for(const N of t)L.push(this.exportTextureAsync(N,mV));await Promise.all(L),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",V,h)}async _getImageDataAsync(V,h,t,L){const N=D.e.TEXTURETYPE_UNSIGNED_BYTE,A=this._exporter._babylonScene,k=A.getEngine(),C=k.createRawTexture(V,h,t,D.e.TEXTUREFORMAT_RGBA,!1,!0,J.d.NEAREST_SAMPLINGMODE,null,N);k.isWebGPU?await mV.e(51).then(mV.bind(mV,14854)):await mV.e(52).then(mV.bind(mV,14862)),await Q.p.ApplyPostProcess("pass",C,A,N,D.e.TEXTURE_NEAREST_SAMPLINGMODE,D.e.TEXTUREFORMAT_RGBA);const K=await k._readTexturePixels(C,h,t);return await H.DumpTools.DumpDataAsync(h,t,K,L,void 0,!0,!0)}_resizeTexturesToSameDimensions(V,h,mV){const t=V?V.getSize():{width:0,height:0},L=h?h.getSize():{width:0,height:0};let N,A;return t.width<L.width?(N=V&&V instanceof J.d?Q.p.CreateResizedCopy(V,L.width,L.height,!0):F(L.width,L.height,mV),A=h):t.width>L.width?(A=h&&h instanceof J.d?Q.p.CreateResizedCopy(h,t.width,t.height,!0):F(t.width,t.height,mV),N=V):(N=V,A=h),{texture1:N,texture2:A}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(V,h,mV,t){const L=new Array;if(!V&&!h)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const N=V?V.DV():h?h.DV():null;if(N){var A;const k=this._resizeTexturesToSameDimensions(V,h,N),C=null===(A=k.texture1)||void 0===A?void 0:A.getSize();let K,o;const n=C.width,q=C.height,x=await k.texture1.readPixels(),R=await k.texture2.readPixels();if(!x)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(K=p(x),!R)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");o=p(R);const d=o.byteLength,M=new Uint8Array(d),c=new Uint8Array(d),z=4,Q=O;let J=0,v=0;for(let V=0;V<q;++V)for(let h=0;h<n;++h){const t=(n*V+h)*z,L={diffuseColor:new s.Jh(K[t],K[t+1],K[t+2]).toLinearSpace(N.getEngine().useExactSrgbConversions).multiply(mV.diffuseColor),specularColor:new s.Jh(o[t],o[t+1],o[t+2]).toLinearSpace(N.getEngine().useExactSrgbConversions).multiply(mV.specularColor),glossiness:o[t+3]*mV.glossiness},A=this._convertSpecularGlossinessToMetallicRoughness(L);Q.r=Math.max(Q.r,A.baseColor.r),Q.g=Math.max(Q.g,A.baseColor.g),Q.b=Math.max(Q.b,A.baseColor.b),J=Math.max(J,A.metallic),v=Math.max(v,A.roughness),c[t]=255*A.baseColor.r,c[t+1]=255*A.baseColor.g,c[t+2]=255*A.baseColor.b,c[t+3]=k.texture1.Mk?255*K[t+3]:255,M[t]=0,M[t+1]=255*A.roughness,M[t+2]=255*A.metallic,M[t+3]=255}const D={baseColor:Q,metallic:J,roughness:v};let H=!1,l=!1;for(let V=0;V<q;++V)for(let h=0;h<n;++h){const mV=(n*V+h)*z;c[mV]/=D.baseColor.r>j?D.baseColor.r:1,c[mV+1]/=D.baseColor.g>j?D.baseColor.g:1,c[mV+2]/=D.baseColor.b>j?D.baseColor.b:1;const t=s.Jh.FromInts(c[mV],c[mV+1],c[mV+2]).toGammaSpace(N.getEngine().useExactSrgbConversions);c[mV]=255*t.r,c[mV+1]=255*t.g,c[mV+2]=255*t.b,t.equalsWithEpsilon(y,j)||(l=!0),M[mV+1]/=D.roughness>j?D.roughness:1,M[mV+2]/=D.metallic>j?D.metallic:1;s.Jh.FromInts(255,M[mV+1],M[mV+2]).equalsWithEpsilon(y,j)||(H=!0)}return H&&L.push(this._getImageDataAsync(M,n,q,t).then((V=>{D.metallicRoughnessTextureData=V}))),l&&L.push(this._getImageDataAsync(c,n,q,t).then((V=>{D.baseColorTextureData=V}))),await Promise.all(L).then((()=>D))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(V){const h=this._getPerceivedBrightness(V.diffuseColor),mV=this._getPerceivedBrightness(V.specularColor),t=1-this._getMaxComponent(V.specularColor),L=I(h,mV,t),N=V.diffuseColor.scale(t/(1-l.r)/Math.max(1-L)),A=V.specularColor.Mh(l.scale(1-L)).scale(1/Math.max(L));let k=s.Jh.Lerp(N,A,L*L);k=k.clampToRef(0,1,k);return{baseColor:k,metallic:L,roughness:1-V.glossiness}}_getPerceivedBrightness(V){return V?Math.sqrt(.299*V.r*V.r+.587*V.g*V.g+.114*V.b*V.b):0}_getMaxComponent(V){return V?Math.max(V.r,Math.max(V.g,V.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(V,h,mV,t){const L=[],N={baseColor:V._albedoColor,metallic:V._metallic,roughness:V._roughness};if(t){V._albedoTexture&&L.push(this.exportTextureAsync(V._albedoTexture,h).then((V=>{V&&(mV.baseColorTexture=V)})));const t=V._metallicTexture;t&&L.push(this.exportTextureAsync(t,h).then((V=>{V&&(mV.metallicRoughnessTexture=V)})))}return L.length>0&&(this._exporter._materialNeedsUVsSet.add(V),await Promise.all(L)),N}_getTextureSampler(V){const h={};if(!V||!(V instanceof J.d))return h;const mV=this._getGLTFTextureWrapMode(V.wrapU);10497!==mV&&(h.wrapS=mV);const t=this._getGLTFTextureWrapMode(V.wrapV);switch(10497!==t&&(h.wrapT=t),V.samplingMode){case J.d.LINEAR_LINEAR:h.magFilter=9729,h.minFilter=9729;break;case J.d.LINEAR_NEAREST:h.magFilter=9729,h.minFilter=9728;break;case J.d.NEAREST_LINEAR:h.magFilter=9728,h.minFilter=9729;break;case J.d.NEAREST_LINEAR_MIPLINEAR:h.magFilter=9728,h.minFilter=9987;break;case J.d.NEAREST_NEAREST:h.magFilter=9728,h.minFilter=9728;break;case J.d.NEAREST_LINEAR_MIPNEAREST:h.magFilter=9728,h.minFilter=9985;break;case J.d.LINEAR_NEAREST_MIPNEAREST:h.magFilter=9729,h.minFilter=9984;break;case J.d.LINEAR_NEAREST_MIPLINEAR:h.magFilter=9729,h.minFilter=9986;break;case J.d.NEAREST_NEAREST_MIPLINEAR:h.magFilter=9728,h.minFilter=9986;break;case J.d.LINEAR_LINEAR_MIPLINEAR:h.magFilter=9729,h.minFilter=9987;break;case J.d.LINEAR_LINEAR_MIPNEAREST:h.magFilter=9729,h.minFilter=9985;break;case J.d.NEAREST_NEAREST_MIPNEAREST:h.magFilter=9728,h.minFilter=9984}return h}_getGLTFTextureWrapMode(V){switch(V){case J.d.WRAP_ADDRESSMODE:return 10497;case J.d.CLAMP_ADDRESSMODE:return 33071;case J.d.MIRROR_ADDRESSMODE:return 33648;default:return L.Tools.Error(`Unsupported Texture Wrap Mode ${V}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(V,h,mV,t){const L={diffuseColor:V._albedoColor,specularColor:V._reflectivityColor,glossiness:V._microSurface},N=V._albedoTexture,A=V._reflectivityTexture,k=V._useMicroSurfaceFromReflectivityMapAlpha;if(A&&!k)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((N||A)&&t){this._exporter._materialNeedsUVsSet.add(V);const t=this._exportTextureSampler(N||A),k=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(N,A,L,h),C=this._exporter._textures;if(k.baseColorTextureData){const V=this._exportImage(`baseColor${C.length}`,h,k.baseColorTextureData);mV.baseColorTexture=this._exportTextureInfo(V,t,null===N||void 0===N?void 0:N.coordinatesIndex)}if(k.metallicRoughnessTextureData){const V=this._exportImage(`metallicRoughness${C.length}`,h,k.metallicRoughnessTextureData);mV.metallicRoughnessTexture=this._exportTextureInfo(V,t,null===A||void 0===A?void 0:A.coordinatesIndex)}return k}return this._convertSpecularGlossinessToMetallicRoughness(L)}async exportPBRMaterialAsync(V,h,mV){const t={},L={name:V.name},N=V.isMetallicWorkflow();if(N){const h=V._albedoColor,mV=V.alpha;h&&(t.baseColorFactor=[h.r,h.g,h.b,mV])}const A=N?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(V,h,t,mV):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(V,h,t,mV);await this._setMetallicRoughnessPbrMaterialAsync(A,V,L,t,h,mV),await this._finishMaterialAsync(L,V,h);const k=this._exporter._materials;return k.push(L),k.length-1}async _setMetallicRoughnessPbrMaterialAsync(V,h,mV,t,N,A){if(T(mV,h),V.baseColor.equalsWithEpsilon(y,j)&&z.WithinEpsilon(h.alpha,1,j)||(t.baseColorFactor=[V.baseColor.r,V.baseColor.g,V.baseColor.b,h.alpha]),null!=V.metallic&&1!==V.metallic&&(t.metallicFactor=V.metallic),null!=V.roughness&&1!==V.roughness&&(t.roughnessFactor=V.roughness),null==h.Dk||h.Dk||(h._twoSidedLighting||L.Tools.Warn(h.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),mV.doubleSided=!0),A){const V=[],t=h._bumpTexture;t&&V.push(this.exportTextureAsync(t,N).then((V=>{V&&(mV.normalTexture=V,1!==t.level&&(mV.normalTexture.scale=t.level))})));const L=h._ambientTexture;L&&V.push(this.exportTextureAsync(L,N).then((V=>{if(V){const t={index:V.index,texCoord:V.texCoord,extensions:V.extensions};mV.occlusionTexture=t;const L=h._ambientTextureStrength;L&&(t.strength=L)}})));const A=h._emissiveTexture;A&&V.push(this.exportTextureAsync(A,N).then((V=>{V&&(mV.emissiveTexture=V)}))),V.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(V))}const k=h._emissiveColor;k.equalsWithEpsilon(O,j)||(mV.emissiveFactor=k.sk()),mV.pbrMetallicRoughness=t}_getPixelsFromTextureAsync(V){return function(V){switch(V){case D.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case D.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case D.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case D.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case D.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case D.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case D.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case D.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case D.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case D.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case D.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(V.textureFormat)?(0,Q.l)(V,V._texture.width,V._texture.height):(V.textureType,D.e.TEXTURETYPE_UNSIGNED_BYTE,V.readPixels())}async exportTextureAsync(V,h){const mV=this._exporter._extensionsPreExportTextureAsync("exporter",V,h);return mV?await mV.then((async mV=>mV?await this._exportTextureInfoAsync(mV,h):await this._exportTextureInfoAsync(V,h))):await this._exportTextureInfoAsync(V,h)}async _exportTextureInfoAsync(V,h){let mV=this._textureMap.get(V);if(!mV){const t=await this._getPixelsFromTextureAsync(V);if(!t)return null;const N=this._exportTextureSampler(V),A=V.mimeType;if(A)switch(A){case"image/jpeg":case"image/png":case"image/webp":h=A;break;default:L.Tools.Warn(`Unsupported media type: ${A}. Exporting texture as PNG.`)}const k=this._internalTextureToImage,C=V.getInternalTexture().uniqueId;k[C]||(k[C]={});let K=k[C][h];if(void 0===K){const mV=V.getSize();K=(async()=>{const L=await this._getImageDataAsync(t,mV.width,mV.height,h);return this._exportImage(V.name,h,L)})(),k[C][h]=K}mV=this._exportTextureInfo(await K,N,V.coordinatesIndex),this._textureMap.set(V,mV),this._exporter._extensionsPostExportTextures("exporter",mV,V)}return mV}_exportImage(V,h,mV){const t=this._exporter._images;let N;if(this._exporter._shouldUseGlb){N={name:V,mimeType:h,bufferView:void 0};const t=this._exporter._bufferManager.createBufferView(new Uint8Array(mV));this._exporter._bufferManager.setBufferView(N,t)}else{const A=V.replace(/\.\/|\/|\.\\|\\/g,"_"),k=function(V){switch(V){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(h);let C=A+k;t.some((V=>V.uri===C))&&(C=`${A}_${L.Tools.RandomId()}${k}`),N={name:V,uri:C},this._exporter._imageData[C]={data:mV,mimeType:h}}return t.push(N),t.length-1}_exportTextureInfo(V,h,mV){const t=this._exporter._textures;let L=t.findIndex((mV=>mV.sampler==h&&mV.source===V));-1===L&&(L=t.length,t.push({source:V,sampler:h}));const N={index:L};return mV&&(N.texCoord=mV),N}_exportTextureSampler(V){const h=this._getTextureSampler(V),mV=this._exporter._samplers,t=mV.findIndex((V=>V.minFilter===h.minFilter&&V.magFilter===h.magFilter&&V.wrapS===h.wrapS&&V.wrapT===h.wrapT));return-1!==t?t:(mV.push(h),mV.length-1)}}var f=mV(12495),S=mV(12264),Y=mV(12876),w=mV(12425);const E=t.sh.Zero(),g=t.Quaternion.Identity(),i=t.sh.One(),b=new t.sh(-1,1,1);function P(V,h){const{byteOffset:mV,byteStride:t,type:L,normalized:N}=V,A=V.getSize(),k=h.reduce(((V,h)=>h.getTotalVertices()>V?h.getTotalVertices():V),-Number.MAX_VALUE);return{byteOffset:mV,byteStride:t,componentCount:A,type:L,count:k*A,normalized:N,totalVertices:k,kind:V.getKind()}}function U(V){switch(V){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function u(V){switch(V){case o.i.PositionKind:case o.i.NormalKind:case o.i.TangentKind:case o.i.ColorKind:case o.i.MatricesIndicesKind:case o.i.MatricesIndicesExtraKind:case o.i.MatricesWeightsKind:case o.i.MatricesWeightsExtraKind:case o.i.UVKind:case o.i.UV2Kind:case o.i.UV3Kind:case o.i.UV4Kind:case o.i.UV5Kind:case o.i.UV6Kind:return!0}return!1}function e(V){switch(V){case N.c.TriangleFillMode:return 4;case N.c.TriangleStripDrawMode:return 5;case N.c.TriangleFanDrawMode:return 6;case N.c.PointListDrawMode:case N.c.PointFillMode:return 0;case N.c.LineLoopDrawMode:return 2;case N.c.LineListDrawMode:return 1;case N.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${V}`)}function W(V){const h=Math.sqrt(V.x*V.x+V.y*V.y+V.z*V.z);h>0&&(V.x/=h,V.y/=h,V.z/=h)}function X(V){return V.x*=-1,V}function a(V){if(V.x*V.x+V.y*V.y>.5){const h=Math.abs(V.x),mV=Math.abs(V.y);if(h>mV){const mV=Math.sign(V.x);V.x=h,V.y*=-mV,V.z*=-mV,V.w*=mV}else{const h=Math.sign(V.y);V.x*=-h,V.y=mV,V.z*=h,V.w*=-h}}else{const h=Math.abs(V.z),mV=Math.abs(V.w);if(h>mV){const mV=Math.sign(V.z);V.x*=-mV,V.y*=mV,V.z=h,V.w*=-mV}else{const h=Math.sign(V.w);V.x*=h,V.y*=-h,V.z*=-h,V.w=mV}}return V}function B(V){V.Hk(-V.z,V.w,V.x,-V.y)}function VV(V,h){const mV=t.sh.FromArrayToRef(h.translation||[0,0,0],0,t.TmpVectors.sh[0]),L=t.Quaternion.FromArrayToRef(h.rotation||[0,0,0,1],0,t.TmpVectors.Quaternion[0]),N=t.Matrix.ComposeToRef(i,L,mV,t.TmpVectors.Matrix[0]),A=t.sh.FromArrayToRef(V.translation||[0,0,0],0,t.TmpVectors.sh[2]),k=t.Quaternion.FromArrayToRef(V.rotation||[0,0,0,1],0,t.TmpVectors.Quaternion[1]),C=t.Matrix.ComposeToRef(i,k,A,t.TmpVectors.Matrix[1]);N.multiplyToRef(C,C),C.decompose(void 0,L,mV),mV.equalsWithEpsilon(E,w.c)?delete h.translation:h.translation=mV.sk(),L.equalsWithEpsilon(g,w.c)?delete h.rotation:h.rotation=L.sk(),h.scale&&delete h.scale}function hV(V,h){if(!(h instanceof n.c))return!1;if(!(1===h.getChildren().length&&0===V.getChildren().length&&V.parent===h))return!1;const mV=V.DV(),t=V instanceof Y.d&&!mV.useRightHandedSystem?b:i;return!!h.jk.equalsWithEpsilon(t,w.c)||(S.e.Warn(`Cannot collapse node ${V.name} into parent node ${h.name} with modified scaling.`),!1)}function mh(V){if(V instanceof Array){const h=new Float32Array(V);return new Uint8Array(h.buffer,h.byteOffset,h.byteLength)}return ArrayBuffer.isView(V)?new Uint8Array(V.buffer,V.byteOffset,V.byteLength):new Uint8Array(V)}function tV(V,h){for(const[mV,t]of Object.entries(V)){const L=h[mV];(Array.isArray(t)&&Array.isArray(L)&&LV(t,L)||t===L)&&delete V[mV]}return V}function LV(V,h){return V.length===h.length&&V.every(((V,mV)=>V===h[mV]))}const NV=t.Matrix.Compose(new t.sh(-1,1,1),t.Quaternion.Identity(),t.sh.Zero());function AV(V,h){if(!(V instanceof n.c))return!1;if(h){if(!V.getWorldMatrix().equalsWithEpsilon(t.Matrix.IdentityReadOnly,w.c))return!1}else{if(!V.getWorldMatrix().multiplyToRef(NV,t.TmpVectors.Matrix[0]).equalsWithEpsilon(t.Matrix.IdentityReadOnly,w.c))return!1}return!(V instanceof q.e&&V.Jk)}const kV=new Map([[Int8Array,(V,h,mV)=>V.setInt8(h,mV)],[Uint8Array,(V,h,mV)=>V.setUint8(h,mV)],[Uint8ClampedArray,(V,h,mV)=>V.setUint8(h,mV)],[Int16Array,(V,h,mV)=>V.setInt16(h,mV,!0)],[Uint16Array,(V,h,mV)=>V.setUint16(h,mV,!0)],[Int32Array,(V,h,mV)=>V.setInt32(h,mV,!0)],[Uint32Array,(V,h,mV)=>V.setUint32(h,mV,!0)],[Float32Array,(V,h,mV)=>V.setFloat32(h,mV,!0)],[Float64Array,(V,h,mV)=>V.setFloat64(h,mV,!0)]]);class CV{writeTypedArray(V){this._checkGrowBuffer(V.byteLength);const h=kV.get(V.constructor);for(let mV=0;mV<V.length;mV++)h(this._dataView,this._byteOffset,V[mV]),this._byteOffset+=V.BYTES_PER_ELEMENT}constructor(V){this._data=new Uint8Array(V),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(V){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,V),this._byteOffset++}writeInt8(V){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,V),this._byteOffset++}writeInt16(V){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,V,!0),this._byteOffset+=2}writeUInt16(V){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,V,!0),this._byteOffset+=2}writeInt32(V){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,V,!0),this._byteOffset+=4}writeUInt32(V){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,V,!0),this._byteOffset+=4}writeFloat32(V){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,V,!0),this._byteOffset+=4}writeFloat64(V){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,V,!0),this._byteOffset+=8}_checkGrowBuffer(V){const h=this.byteOffset+V;if(h>this._data.byteLength){const V=new Uint8Array(2*h);V.set(this._data),this._data=V,this._dataView=new DataView(this._data.buffer)}}}function KV(V){return V%4===0?4:V%2===0?2:1}class oV{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(V){let h=0;this._bufferViewToData.forEach((V=>{h+=V.byteLength}));const mV=new CV(h),t=Array.from(this._bufferViewToData.keys()).sort(((V,h)=>KV(h.byteLength)-KV(V.byteLength)));for(const L of t){L.byteOffset=mV.byteOffset,V.push(L);const h=V.length-1,t=this.getPropertiesWithBufferView(L);for(const V of t)V.bufferView=h;mV.writeTypedArray(this._bufferViewToData.get(L)),this._bufferViewToData.delete(L)}return mV.getOutputData()}createBufferView(V,h){const mV={buffer:0,byteOffset:void 0,byteLength:V.byteLength,byteStride:h};return this._bufferViewToData.set(mV,V),mV}createAccessor(V,h,mV,t,L,N,A){this._verifyBufferView(V);const k={bufferView:void 0,componentType:mV,count:t,type:h,min:null===N||void 0===N?void 0:N.min,max:null===N||void 0===N?void 0:N.max,normalized:A,byteOffset:L};return this.setBufferView(k,V),this._accessorToBufferView.set(k,V),k}setBufferView(V,h){this._verifyBufferView(h);this.getPropertiesWithBufferView(h).push(V)}removeBufferView(V){const h=this.getPropertiesWithBufferView(V);for(const mV of h)void 0!==mV.bufferView&&delete mV.bufferView;this._bufferViewToData.delete(V),this._bufferViewToProperties.delete(V),this._accessorToBufferView.forEach(((h,mV)=>{h===V&&(void 0!==mV.byteOffset&&delete mV.byteOffset,this._accessorToBufferView.delete(mV))}))}getBufferView(V){const h=this._accessorToBufferView.get(V);return this._verifyBufferView(h),h}getPropertiesWithBufferView(V){return this._verifyBufferView(V),this._bufferViewToProperties.set(V,this._bufferViewToProperties.get(V)??[]),this._bufferViewToProperties.get(V)}getData(V){return this._verifyBufferView(V),this._bufferViewToData.get(V)}_verifyBufferView(V){if(void 0===V||!this._bufferViewToData.has(V))throw new Error(`BufferView ${V} not found in BufferManager.`)}}var nV,qV=mV(12838),xV=mV(12855),RV=mV(12885),dV=mV(12754),sV=mV(12918),MV=mV(12931),cV=mV(12836),zV=mV(12937);!function(V){V[V.INTANGENT=0]="INTANGENT",V[V.OUTTANGENT=1]="OUTTANGENT"}(nV||(nV={}));class QV{static _IsTransformable(V){return V&&(V instanceof n.c||V instanceof qV.b||V instanceof zV.d)}static _CreateNodeAnimation(V,h,mV,t,N){if(this._IsTransformable(V)){const A=[],k=[],C=h.getKeys(),K=QV._CalculateMinMaxKeyFrames(C),o=QV._DeduceInterpolation(C,mV,t),n=o.interpolationType,q=o.shouldBakeAnimation;if(q?QV._CreateBakedAnimation(V,h,mV,K.min,K.max,h.framePerSecond,N,A,k,K,t):"LINEAR"===n||"STEP"===n?QV._CreateLinearOrStepAnimation(V,h,mV,A,k,t):"CUBICSPLINE"===n?QV._CreateCubicSplineAnimation(V,h,mV,A,k,t):QV._CreateBakedAnimation(V,h,mV,K.min,K.max,h.framePerSecond,N,A,k,K,t),A.length&&k.length){return{inputs:A,outputs:k,samplerInterpolation:n,inputsMin:q?K.min:L.Tools.FloatRound(K.min/h.framePerSecond),inputsMax:q?K.max:L.Tools.FloatRound(K.max/h.framePerSecond)}}}return null}static _DeduceAnimationInfo(V){let h=null,mV="VEC3",t=!1;const N=V.targetProperty.split(".");switch(N[0]){case"jk":h="scale";break;case"position":h="translation";break;case"rotation":mV="VEC4",h="rotation";break;case"rotationQuaternion":mV="VEC4",t=!0,h="rotation";break;case"influence":mV="SCALAR",h="weights";break;default:L.Tools.Error(`Unsupported animatable property ${N[0]}`)}return h?{animationChannelTargetPath:h,dataAccessorType:mV,useQuaternion:t}:(L.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(V,h,mV,t,L,N,A,k,C,K,o){let n;if(QV._IsTransformable(V)&&V.animations)for(const q of V.animations){if(o&&!o(q))continue;const L=QV._DeduceAnimationInfo(q);L&&(n={name:q.name,samplers:[],channels:[]},QV._AddAnimation(`${q.name}`,q.hasRunningRuntimeAnimations?h:n,V,q,L.dataAccessorType,L.animationChannelTargetPath,t,N,A,k,L.useQuaternion,C,K),n.samplers.length&&n.channels.length&&mV.push(n))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(V,h,mV,t,L,N,A,k,C,K,o){let n;if(V instanceof cV.c){const L=V.morphTargetManager;if(L)for(let q=0;q<L.numTargets;++q){const x=L.getTarget(q);for(const R of x.animations){if(o&&!o(R))continue;const x=new sV.d(`${R.name}`,"influence",R.framePerSecond,R.dataType,R.loopMode,R.enableBlending),d=[],s=R.getKeys();for(let V=0;V<s.length;++V){const h=s[V];for(let V=0;V<L.numTargets;++V)V==q?d.push(h):d.push({frame:h.frame,value:0})}x.setKeys(d);const M=QV._DeduceAnimationInfo(x);M&&(n={name:x.name,samplers:[],channels:[]},QV._AddAnimation(R.name,R.hasRunningRuntimeAnimations?h:n,V,x,M.dataAccessorType,M.animationChannelTargetPath,t,N,A,k,M.useQuaternion,C,K,L.numTargets),n.samplers.length&&n.channels.length&&mV.push(n))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(V,h,mV,t,L,N,A,k,C){let K;if(V.animationGroups){const n=V.animationGroups;for(const q of n){const n=new Map,x=new Map,R=new Set,d=q.to-q.from;K={name:q.name,channels:[],samplers:[]};for(let h=0;h<q.targetedAnimations.length;++h){const d=q.targetedAnimations[h],s=d.target,M=d.animation;if(C&&!C(M))continue;const c=k.has(s);if(this._IsTransformable(s)||1===s.length&&this._IsTransformable(s[0])){const V=QV._DeduceAnimationInfo(d.animation);if(V){const h=this._IsTransformable(s)?s:this._IsTransformable(s[0])?s[0]:null;h&&QV._AddAnimation(`${M.name}`,K,h,M,V.dataAccessorType,V.animationChannelTargetPath,mV,t,L,N,V.useQuaternion,A,c)}}else if(s instanceof MV.c||1===s.length&&s[0]instanceof MV.c){if(QV._DeduceAnimationInfo(d.animation)){const h=s instanceof MV.c?s:s[0];if(h){const mV=V.morphTargetManagers.find((V=>{for(let mV=0;mV<V.numTargets;++mV)if(V.getTarget(mV)===h)return!0;return!1}));if(mV){const t=V.meshes.find((V=>V.morphTargetManager===mV));var o;if(t)n.has(t)||n.set(t,new Map),null===(o=n.get(t))||void 0===o||o.set(h,M),R.add(t),x.set(t,M)}}}}}R.forEach((V=>{const h=V.morphTargetManager;let k=null;const C=[],o=x.get(V).getKeys(),R=o.length;for(let mV=0;mV<R;++mV)for(let t=0;t<h.numTargets;++t){const L=h.getTarget(t),N=n.get(V);if(N){const h=N.get(L);h?(k||(k=new sV.d(`${q.name}_${V.name}_MorphWeightAnimation`,"influence",h.framePerSecond,sV.d.ANIMATIONTYPE_FLOAT,h.loopMode,h.enableBlending)),C.push(h.getKeys()[mV])):C.push({frame:q.from+d/R*mV,value:L.influence,inTangent:o[0].inTangent?0:void 0,outTangent:o[0].outTangent?0:void 0})}}k.setKeys(C);const s=QV._DeduceAnimationInfo(k);s&&QV._AddAnimation(`${q.name}_${V.name}_MorphWeightAnimation`,K,V,k,s.dataAccessorType,s.animationChannelTargetPath,mV,t,L,N,s.useQuaternion,A,!1,null===h||void 0===h?void 0:h.numTargets)})),K.channels.length&&K.samplers.length&&h.push(K)}}}static _AddAnimation(V,h,mV,L,N,A,k,C,K,o,n,q,x,R){const d=QV._CreateNodeAnimation(mV,L,A,n,q);let s,M,c,z,Q,J;if(d){if(R){let V=0,h=0;const mV=[];for(;d.inputs.length>0;)h=d.inputs.shift(),V%R==0&&mV.push(h),V++;d.inputs=mV}const V=k.get(mV),L=new Float32Array(d.inputs);s=C.createBufferView(L),M=C.createAccessor(s,"SCALAR",5126,d.inputs.length,void 0,{min:[d.inputsMin],max:[d.inputsMax]}),o.push(M),c=o.length-1;const K=new t.Quaternion,n=new t.sh,q=new t.sh,v=mV instanceof qV.b,D=U(N),H=new Float32Array(d.outputs.length*D);d.outputs.forEach((function(V,h){let mV=V;switch(A){case"translation":x&&(t.sh.FromArrayToRef(V,0,q),X(q),q.toArray(mV));break;case"rotation":4===V.length?t.Quaternion.FromArrayToRef(V,0,K):(mV=new Array(4),t.sh.FromArrayToRef(V,0,n),t.Quaternion.FromEulerVectorToRef(n,K)),x&&(a(K),v&&B(K)),K.toArray(mV)}H.set(mV,h*D)})),s=C.createBufferView(H),M=C.createAccessor(s,N,5126,d.outputs.length),o.push(M),z=o.length-1,Q={interpolation:d.samplerInterpolation,input:c,output:z},h.samplers.push(Q),J={sampler:h.samplers.length-1,target:{node:V,path:A}},h.channels.push(J)}}static _CreateBakedAnimation(V,h,mV,N,A,k,C,K,o,n,q){let x;const R=t.Quaternion.Identity();let d,s=null,M=null,c=null,z=null,Q=null,J=null;n.min=L.Tools.FloatRound(N/k);const v=h.getKeys();for(let t=0,D=v.length;t<D;++t){if(J=null,c=v[t],t+1<D)if(z=v[t+1],c.value.equals&&c.value.equals(z.value)||c.value===z.value){if(0!==t)continue;J=c.frame}else J=z.frame;else{if(Q=v[t-1],c.value.equals&&c.value.equals(Q.value)||c.value===Q.value)continue;J=A}if(J)for(let t=c.frame;t<=J;t+=C){if(d=L.Tools.FloatRound(t/k),d===s)continue;s=d,M=d;const N={key:0,repeatCount:0,loopMode:h.loopMode};x=h._interpolate(t,N),QV._SetInterpolatedValue(V,x,d,h,mV,R,K,o,q)}}M&&(n.max=M)}static _ConvertFactorToVector3OrQuaternion(V,h,mV,N,A){const k=QV._GetBasePositionRotationOrScale(h,N,A),C=mV.targetProperty.split("."),K=C?C[1]:"",o=A?t.Quaternion.Dh(k).normalize():t.sh.Dh(k);switch(K){case"x":case"y":case"z":o[K]=V;break;case"w":o.w=V;break;default:L.Tools.Error(`glTFAnimation: Unsupported component name "${K}"!`)}return o}static _SetInterpolatedValue(V,h,mV,L,N,A,k,C,K){let o;k.push(mV),"weights"!==N?(L.dataType===sV.d.ANIMATIONTYPE_FLOAT&&(h=this._ConvertFactorToVector3OrQuaternion(h,V,L,N,K)),"rotation"===N?(K?A=h:(o=h,t.Quaternion.RotationYawPitchRollToRef(o.y,o.x,o.z,A)),C.push(A.sk())):(o=h,C.push(o.sk()))):C.push([h])}static _CreateLinearOrStepAnimation(V,h,mV,t,L,N){for(const A of h.getKeys())t.push(A.frame/h.framePerSecond),QV._AddKeyframeValue(A,h,L,mV,V,N)}static _CreateCubicSplineAnimation(V,h,mV,t,L,N){h.getKeys().forEach((function(A){t.push(A.frame/h.framePerSecond),QV._AddSplineTangent(nV.INTANGENT,L,mV,"CUBICSPLINE",A,N),QV._AddKeyframeValue(A,h,L,mV,V,N),QV._AddSplineTangent(nV.OUTTANGENT,L,mV,"CUBICSPLINE",A,N)}))}static _GetBasePositionRotationOrScale(V,h,mV){let L;if("rotation"===h)if(mV){L=(V.rotationQuaternion??t.Quaternion.Identity()).sk()}else{L=(V.rotation??t.sh.Zero()).sk()}else if("translation"===h){L=(V.position??t.sh.Zero()).sk()}else{L=(V.jk??t.sh.One()).sk()}return L}static _AddKeyframeValue(V,h,mV,N,A,k){let C;const K=h.dataType;if(K===sV.d.ANIMATIONTYPE_VECTOR3){let h=V.value.sk();if("rotation"===N){const V=t.sh.Dh(h);h=t.Quaternion.RotationYawPitchRoll(V.y,V.x,V.z).sk()}mV.push(h)}else if(K===sV.d.ANIMATIONTYPE_FLOAT){if("weights"===N)mV.push([V.value]);else if(C=this._ConvertFactorToVector3OrQuaternion(V.value,A,h,N,k),C){if("rotation"===N){const V=k?C:t.Quaternion.RotationYawPitchRoll(C.y,C.x,C.z).normalize();mV.push(V.sk())}mV.push(C.sk())}}else K===sV.d.ANIMATIONTYPE_QUATERNION?mV.push(V.value.normalize().sk()):L.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(V,h,mV){let t,L,N=!1;if("rotation"===h&&!mV)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let A=0,k=V.length;A<k;++A)if(L=V[A],L.inTangent||L.outTangent)if(t){if("CUBICSPLINE"!==t){t="LINEAR",N=!0;break}}else t="CUBICSPLINE";else if(t){if("CUBICSPLINE"===t||L.interpolation&&1===L.interpolation&&"STEP"!==t){t="LINEAR",N=!0;break}}else t=L.interpolation&&1===L.interpolation?"STEP":"LINEAR";return t||(t="LINEAR"),{interpolationType:t,shouldBakeAnimation:N}}static _AddSplineTangent(V,h,mV,L,N,A){let k;const C=V===nV.INTANGENT?N.inTangent:N.outTangent;if("CUBICSPLINE"===L){if("rotation"===mV)if(C)if(A)k=C.sk();else{const V=C;k=t.Quaternion.RotationYawPitchRoll(V.y,V.x,V.z).sk()}else k=[0,0,0,0];else k="weights"===mV?C?[C]:[0]:C?C.sk():[0,0,0];h.push(k)}}static _CalculateMinMaxKeyFrames(V){let h=1/0,mV=-1/0;return V.forEach((function(V){h=Math.min(h,V.frame),mV=Math.max(mV,V.frame)})),{min:h,max:mV}}}function JV(V,h,mV,N,A,k){const C={attributes:{},influence:V.influence,name:V.name},K=h.Jk;if(!K)return L.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),C;const n=k?-1:1,q=t.sh.Zero();let x=0,R=0;if(V.hasPositions){const N=V.getPositions(),k=K.getVerticesData(o.i.PositionKind);if(k){const V=new Float32Array(k.length),h=[1/0,1/0,1/0],L=[-1/0,-1/0,-1/0];R=k.length/3,x=0;for(let mV=x;mV<R;++mV){const A=t.sh.Dh(k,3*mV);t.sh.Dh(N,3*mV).subtractToRef(A,q),q.x*=n,h[0]=Math.min(h[0],q.x),L[0]=Math.max(L[0],q.x),h[1]=Math.min(h[1],q.y),L[1]=Math.max(L[1],q.y),h[2]=Math.min(h[2],q.z),L[2]=Math.max(L[2],q.z),V[3*mV]=q.x,V[3*mV+1]=q.y,V[3*mV+2]=q.z}const K=mV.createBufferView(V,12),o=mV.createAccessor(K,"VEC3",5126,N.length/3,0,{min:h,max:L});A.push(o),C.attributes.POSITION=A.length-1}else L.Tools.Warn(`Morph target positions for mesh ${h.name} were not exported. Mesh does not have position vertex data`)}if(V.hasNormals){const N=V.getNormals(),k=K.getVerticesData(o.i.NormalKind);if(k){const V=new Float32Array(k.length);R=k.length/3,x=0;for(let mV=x;mV<R;++mV){const h=t.sh.Dh(k,3*mV).normalize();t.sh.Dh(N,3*mV).normalize().subtractToRef(h,q),V[3*mV]=q.x*n,V[3*mV+1]=q.y,V[3*mV+2]=q.z}const h=mV.createBufferView(V,12),L=mV.createAccessor(h,"VEC3",5126,N.length/3,0);A.push(L),C.attributes.NORMAL=A.length-1}else L.Tools.Warn(`Morph target normals for mesh ${h.name} were not exported. Mesh does not have normals vertex data`)}if(V.hasTangents){const N=V.getTangents(),k=K.getVerticesData(o.i.TangentKind);if(k){R=k.length/4;const V=new Float32Array(3*R);x=0;for(let mV=x;mV<R;++mV){const h=t.sh.Dh(k,4*mV);W(h);const L=t.sh.Dh(N,3*mV);W(L),L.subtractToRef(h,q),V[3*mV]=q.x*n,V[3*mV+1]=q.y,V[3*mV+2]=q.z}const h=mV.createBufferView(V,12),L=mV.createAccessor(h,"VEC3",5126,R,0);A.push(L),C.attributes.TANGENT=A.length-1}else L.Tools.Warn(`Morph target tangents for mesh ${h.name} were not exported. Mesh does not have tangents vertex data`)}if(V.hasColors){const N=V.getColors(),k=K.getVerticesData(o.i.ColorKind),n=K.getVertexBuffer(o.i.ColorKind);if(k&&n){const V=n.getSize();R=k.length/V;const h=new Float32Array(R*V);x=0;for(let mV=x;mV<R;++mV)if(3===V){const L=t.sh.Dh(k,mV*V);t.sh.Dh(N,mV*V).subtractToRef(L,q),h[3*mV]=q.x,h[3*mV+1]=q.y,h[3*mV+2]=q.z}else if(4===V){const L=new t.Vector4,A=t.Vector4.Dh(k,mV*V);t.Vector4.Dh(N,mV*V).subtractToRef(A,L),h[4*mV]=L.x,h[4*mV+1]=L.y,h[4*mV+2]=L.z,h[4*mV+3]=L.w}else L.Tools.Warn(`Unsupported number of components for color attribute: ${V}`);const K=mV.createBufferView(h,4*V),o=mV.createAccessor(K,3===V?"VEC3":"VEC4",5126,R,0);A.push(o),C.attributes.COLOR_0=A.length-1}else L.Tools.Warn(`Morph target colors for mesh ${h.name} were not exported. Mesh does not have colors vertex data`)}return C}var vV=mV(12946),DV=mV(12790),HV=mV(12770),jV=mV(12388);class lV{}lV.DEFAULT_COLOR=s.Jh.White(),lV.DEFAULT_WIDTH_ATTENUATED=1,lV.DEFAULT_WIDTH=.1;var GV=mV(12615),yV=mV(12955);class OV{static ConvertPoints(V,h){if(V.length&&Array.isArray(V)&&"number"===typeof V[0])return[V];if(V.length&&Array.isArray(V[0])&&"number"===typeof V[0][0])return V;if(V.length&&!Array.isArray(V[0])&&V[0]instanceof t.sh){const h=[];for(let mV=0;mV<V.length;mV++){const t=V[mV];h.push(t.x,t.y,t.z)}return[h]}if(V.length>0&&Array.isArray(V[0])&&V[0].length>0&&V[0][0]instanceof t.sh){const h=[],mV=V;for(const V of mV)h.push(V.flatMap((V=>[V.x,V.y,V.z])));return h}if(V instanceof Float32Array){if(null!==h&&void 0!==h&&h.floatArrayStride){const mV=[],t=3*h.floatArrayStride;for(let h=0;h<V.length;h+=t){const L=new Array(t);for(let mV=0;mV<t;mV++)L[mV]=V[h+mV];mV.push(L)}return mV}return[Array.from(V)]}if(V.length&&V[0]instanceof Float32Array){const h=[];for(const mV of V)h.push(Array.from(mV));return h}return[]}static OmitZeroLengthPredicate(V,h,mV){const t=[];return h.Mh(V).lengthSquared()>0&&t.push([V,h]),mV.Mh(h).lengthSquared()>0&&t.push([h,mV]),V.Mh(mV).lengthSquared()>0&&t.push([mV,V]),0===t.length?null:t}static OmitDuplicatesPredicate(V,h,mV,t){const L=[];return OV._SearchInPoints(V,h,t)||L.push([V,h]),OV._SearchInPoints(h,mV,t)||L.push([h,mV]),OV._SearchInPoints(mV,V,t)||L.push([mV,V]),0===L.length?null:L}static _SearchInPoints(V,h,mV){for(const A of mV)for(let mV=0;mV<A.length;mV++){var t,L,N;if(null!==(t=A[mV])&&void 0!==t&&t.equals(V))if(null!==(L=A[mV+1])&&void 0!==L&&L.equals(h)||null!==(N=A[mV-1])&&void 0!==N&&N.equals(h))return!0}return!1}static MeshesToLines(V,h){const mV=[];for(let L=0;L<V.length;L++){const N=V[L],A=N.getVerticesData(o.i.PositionKind),k=N.vk();if(A&&k)for(let V=0,C=0;V<k.length;V++){const K=3*k[C++],o=3*k[C++],n=3*k[C++],q=new t.sh(A[K],A[K+1],A[K+2]),x=new t.sh(A[o],A[o+1],A[o+2]),R=new t.sh(A[n],A[n+1],A[n+2]);if(h){const t=h(q,x,R,mV,V,K,N,L,A,k);if(t)for(const V of t)mV.push(V)}else mV.push([q,x],[x,R],[R,q])}}return mV}static ToVector3Array(V){if(Array.isArray(V[0])){const h=[],mV=V;for(const V of mV){const mV=[];for(let h=0;h<V.length;h+=3)mV.push(new t.sh(V[h],V[h+1],V[h+2]));h.push(mV)}return h}const h=V,mV=[];for(let L=0;L<h.length;L+=3)mV.push(new t.sh(h[L],h[L+1],h[L+2]));return mV}static ToNumberArray(V){return V.flatMap((V=>[V.x,V.y,V.z]))}static GetPointsCountInfo(V){const h=new Array(V.length);let mV=0;for(let t=V.length;t--;)h[t]=V[t].length/3,mV+=h[t];return{total:mV,counts:h}}static GetLineLength(V){if(0===V.length)return 0;let h;h="number"===typeof V[0]?OV.ToVector3Array(V):V;const mV=t.TmpVectors.sh[0];let L=0;for(let t=0;t<h.length-1;t++){const V=h[t];L+=h[t+1].subtractToRef(V,mV).length()}return L}static GetLineLengthArray(V){const h=new Float32Array(V.length/3);let mV=0;for(let t=0,L=V.length/3-1;t<L;t++){let L=V[3*t+0],N=V[3*t+1],A=V[3*t+2];L-=V[3*t+3],N-=V[3*t+4],A-=V[3*t+5];mV+=Math.sqrt(L*L+N*N+A*A),h[t+1]=mV}return h}static SegmentizeSegmentByCount(V,h,mV){const L=[],N=h.Mh(V),A=t.TmpVectors.sh[0];A.lk(mV);const k=t.TmpVectors.sh[1];N.divideToRef(A,k);let C=V.clone();L.push(C);for(let t=0;t<mV;t++)C=C.clone(),L.push(C.addInPlace(k));return L}static SegmentizeLineBySegmentLength(V,h){const mV=V[0]instanceof t.sh?OV.GetLineSegments(V):"number"===typeof V[0]?OV.GetLineSegments(OV.ToVector3Array(V)):V,L=[];for(const t of mV)if(t.length>h){const V=OV.SegmentizeSegmentByCount(t.point1,t.point2,Math.ceil(t.length/h));for(const h of V)L.push(h)}else L.push(t.point1),L.push(t.point2);return L}static SegmentizeLineBySegmentCount(V,h){const mV="number"===typeof V[0]?OV.ToVector3Array(V):V,t=OV.GetLineLength(mV)/h;return OV.SegmentizeLineBySegmentLength(mV,t)}static GetLineSegments(V){const h=[];for(let mV=0;mV<V.length-1;mV++){const t=V[mV],L=V[mV+1],N=L.Mh(t).length();h.push({point1:t,point2:L,length:N})}return h}static GetMinMaxSegmentLength(V){const h=OV.GetLineSegments(V).sort((V=>V.length));return{min:h[0].length,max:h[h.length-1].length}}static GetPositionOnLineByVisibility(V,h,mV){let L=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const N=h*mV;let A=0,k=0;const C=V.length;for(let t=0;t<C;t++){if(N<=A+V[t].length){k=t;break}A+=V[t].length}const K=(N-A)/V[k].length;return V[k].point2.subtractToRef(V[k].point1,t.TmpVectors.sh[0]),t.TmpVectors.sh[1]=t.TmpVectors.sh[0].multiplyByFloats(K,K,K),L||t.TmpVectors.sh[1].addInPlace(V[k].point1),t.TmpVectors.sh[1].clone()}static GetCircleLinePoints(V,h){let mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V,N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/h;const A=[];for(let k=0;k<=h;k++)A.push(new t.sh(Math.cos(k*N)*V,Math.sin(k*N)*L,mV));return A}static GetBezierLinePoints(V,h,mV,t){return GV.g.CreateQuadraticBezier(V,h,mV,t).getPoints().flatMap((V=>[V.x,V.y,V.z]))}static GetArrowCap(V,h,mV,t,L){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,A=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[V.clone(),V.add(h.multiplyByFloats(mV,mV,mV))],widths:[t,L,N,A]}}static GetPointsFromText(V,h,mV,t){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const A=[],k=(0,yV.c)(V,h,mV,t);for(const C of k){for(const V of C.paths){const h=[],mV=V.getPoints();for(const V of mV)h.push(V.x,V.y,L);A.push(h)}if(N)for(const V of C.holes){const h=[],mV=V.getPoints();for(const V of mV)h.push(V.x,V.y,L);A.push(h)}}return A}static Color3toRGBAUint8(V){const h=new Uint8Array(4*V.length);for(let mV=0,t=0;mV<V.length;mV++)h[t++]=255*V[mV].r,h[t++]=255*V[mV].g,h[t++]=255*V[mV].b,h[t++]=255;return h}static CreateColorsTexture(V,h,mV,t){const L=t.getEngine().getCaps().maxTextureSize??1,N=h.length>L?L:h.length,A=Math.ceil(h.length/L);A>1&&(h=[...h,...Array(N*A-h.length).fill(h[0])]);const k=OV.Color3toRGBAUint8(h),C=new v.e(k,N,A,R.c.TEXTUREFORMAT_RGBA,t,!1,!0,mV);return C.name=V,C}static PrepareEmptyColorsTexture(V){if(!lV.EmptyColorsTexture){const h=new Uint8Array(4);lV.EmptyColorsTexture=new v.e(h,1,1,R.c.TEXTUREFORMAT_RGBA,V,!1,!1,v.e.NEAREST_NEAREST),lV.EmptyColorsTexture.name="grlEmptyColorsTexture"}return lV.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var V;null===(V=lV.EmptyColorsTexture)||void 0===V||V.dispose(),lV.EmptyColorsTexture=null}static BooleanToNumber(V){return V?1:0}}class IV extends HV.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class rV extends DV.d{isCompatible(V){return!0}constructor(V,h,mV){var L;mV=mV||{color:lV.DEFAULT_COLOR};const N=new IV;N.GREASED_LINE_HAS_COLOR=!!mV.color&&!mV.useColors,N.GREASED_LINE_SIZE_ATTENUATION=mV.sizeAttenuation??!1,N.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===mV.colorDistributionType,N.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(h??V.DV()).useRightHandedSystem,N.GREASED_LINE_CAMERA_FACING=mV.cameraFacing??!0,super(V,rV.GREASED_LINE_MATERIAL_NAME,200,N,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(L=mV)||void 0===L?void 0:L.forceGLSL)||rV.ForceGLSL,this._scene=h??V.DV(),this._engine=this._scene.getEngine(),this._cameraFacing=mV.cameraFacing??!0,this.visibility=mV.visibility??1,this.useDash=mV.useDash??!1,this.dashRatio=mV.dashRatio??.5,this.dashOffset=mV.dashOffset??0,this.width=mV.width?mV.width:mV.sizeAttenuation?lV.DEFAULT_WIDTH_ATTENUATED:lV.DEFAULT_WIDTH,this._sizeAttenuation=mV.sizeAttenuation??!1,this.colorMode=mV.colorMode??0,this._color=mV.color??null,this.useColors=mV.useColors??!1,this._colorsDistributionType=mV.colorDistributionType??0,this.colorsSampling=mV.colorsSampling??v.e.NEAREST_NEAREST,this._colors=mV.GV??null,this.dashCount=mV.dashCount??1,this.resolution=mV.resolution??new t.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),mV.colorsTexture?this.colorsTexture=mV.colorsTexture:this._colors?this.colorsTexture=OV.CreateColorsTexture(`${V.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??lV.DEFAULT_COLOR,OV.PrepareEmptyColorsTexture(this._scene)),this._engine.XL.add((()=>{OV.DisposeEmptyColorsTexture()}))}getAttributes(V){V.push("grl_offsets"),V.push("grl_widths"),V.push("grl_colorPointers"),V.push("grl_counters"),this._cameraFacing?(V.push("grl_previousAndSide"),V.push("grl_nextAndCounters")):V.push("grl_slopes")}getSamplers(V){V.push("grl_colors")}getActiveTextures(V){this.colorsTexture&&V.push(this.colorsTexture)}getUniforms(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const h=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&h.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===V&&h.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:h,vertex:this._cameraFacing&&this._isGLSL(V)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(V)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(V){if(this._cameraFacing){V.zk("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||V.zk("viewProjection",this._scene.getTransformMatrix());const h=t.TmpVectors.Vector4[0];h.x=this._aspect,h.y=this._resolution.x,h.z=this._resolution.y,h.w=this.width,V.updateVector4("grl_aspect_resolution_lineWidth",h)}const h=t.TmpVectors.Vector4[0];h.x=OV.BooleanToNumber(this.useDash),h.y=this._dashArray,h.z=this.dashOffset,h.w=this.dashRatio,V.updateVector4("grl_dashOptions",h);const mV=t.TmpVectors.Vector4[1];mV.x=this.colorMode,mV.y=this.visibility,mV.z=this.colorsTexture?this.colorsTexture.getSize().width:0,mV.w=OV.BooleanToNumber(this.useColors),V.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",mV),this._color&&V.updateColor3("grl_singleColor",this._color);const L=this.colorsTexture??lV.EmptyColorsTexture;V.setTexture("grl_colors",L),V.updateFloat2("grl_textureSize",(null===L||void 0===L?void 0:L.getSize().width)??1,(null===L||void 0===L?void 0:L.getSize().height)??1)}prepareDefines(V,h,mV){V.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,V.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,V.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,V.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=h.useRightHandedSystem,V.GREASED_LINE_CAMERA_FACING=this._cameraFacing,V.GREASED_LINE_USE_OFFSETS=!!mV.offsets}getClassName(){return rV.GREASED_LINE_MATERIAL_NAME}getCustomCode(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(h)?function(V,h){if("vertex"===V){const V={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return h&&(V["!gl_Position\\=viewProjection\\*worldPos;"]="//"),V}return"fragment"===V?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(V,this._cameraFacing):function(V,h){if("vertex"===V){const V={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return h&&(V["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),V}return"fragment"===V?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(V,this._cameraFacing)}dispose(){var V;null===(V=this.colorsTexture)||void 0===V||V.dispose(),super.dispose()}get GV(){return this._colors}set GV(V){this.setColors(V)}setColors(V){var h;let mV=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const L=(null===(h=this._colors)||void 0===h?void 0:h.length)??0;var N;if(this._colors=V,null!==V&&0!==V.length){if(!mV||t)if(this.colorsTexture&&L===V.length&&!t){const h=OV.Color3toRGBAUint8(V);this.colorsTexture.update(h)}else{var A;null===(A=this.colorsTexture)||void 0===A||A.dispose(),this.colorsTexture=OV.CreateColorsTexture(`${this._material.name}-colors-texture`,V,this.colorsSampling,this._scene)}}else null===(N=this.colorsTexture)||void 0===N||N.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(V){this._dashCount=V,this._dashArray=1/V}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(V){this._sizeAttenuation=V,this.markAllDefinesAsDirty()}get color(){return this._color}set color(V){this.setColor(V)}setColor(V){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==V||null!==this._color&&null===V?(this._color=V,h||this.markAllDefinesAsDirty()):this._color=V}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(V){this._colorsDistributionType=V,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(V){this._aspect=V.x/V.y,this._resolution=V}serialize(){const V=super.serialize(),h={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(h.GV=this._colors),this._color&&(h.color=this._color),V.greasedLineMaterialOptions=h,V}parse(V,h,mV){var t;super.parse(V,h,mV);const L=V.greasedLineMaterialOptions;null===(t=this.colorsTexture)||void 0===t||t.dispose(),L.color&&this.setColor(L.color,!0),L.colorDistributionType&&(this.colorsDistributionType=L.colorDistributionType),L.GV&&(this.GV=L.GV),L.colorsSampling&&(this.colorsSampling=L.colorsSampling),L.colorMode&&(this.colorMode=L.colorMode),L.useColors&&(this.useColors=L.useColors),L.visibility&&(this.visibility=L.visibility),L.useDash&&(this.useDash=L.useDash),L.dashCount&&(this.dashCount=L.dashCount),L.dashRatio&&(this.dashRatio=L.dashRatio),L.dashOffset&&(this.dashOffset=L.dashOffset),L.width&&(this.width=L.width),L.sizeAttenuation&&(this.sizeAttenuation=L.sizeAttenuation),L.resolution&&(this.resolution=L.resolution),this.GV?this.colorsTexture=OV.CreateColorsTexture(`${this._material.name}-colors-texture`,this.GV,this.colorsSampling,h):OV.PrepareEmptyColorsTexture(h),this.markAllDefinesAsDirty()}copyTo(V){var h;const mV=V;null===(h=mV.colorsTexture)||void 0===h||h.dispose(),this._colors&&(mV.colorsTexture=OV.CreateColorsTexture(`${mV._material.name}-colors-texture`,this._colors,mV.colorsSampling,this._scene)),mV.setColor(this.color,!0),mV.colorsDistributionType=this.colorsDistributionType,mV.colorsSampling=this.colorsSampling,mV.colorMode=this.colorMode,mV.useColors=this.useColors,mV.visibility=this.visibility,mV.useDash=this.useDash,mV.dashCount=this.dashCount,mV.dashRatio=this.dashRatio,mV.dashOffset=this.dashOffset,mV.width=this.width,mV.sizeAttenuation=this.sizeAttenuation,mV.resolution=this.resolution,mV.markAllDefinesAsDirty()}_isGLSL(V){return 0===V||this._forceGLSL}}rV.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",rV.ForceGLSL=!1,(0,jV.i)(`BABYLON.${rV.GREASED_LINE_MATERIAL_NAME}`,rV);var TV=mV(12817),FV=mV(12272),pV=mV(12640),ZV=mV(12366);class fV extends pV.ShaderMaterial{constructor(V,h,L){const N=h.getEngine(),A=N.isWebGPU&&!(L.forceGLSL||fV.ForceGLSL),k=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];h.useRightHandedSystem&&k.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const C=["position","grl_widths","grl_offsets","grl_colorPointers"];L.cameraFacing?(k.push("GREASED_LINE_CAMERA_FACING"),C.push("grl_previousAndSide","grl_nextAndCounters")):(C.push("grl_slopes"),C.push("grl_counters"));const K=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(A||K.push("world","viewProjection","view","projection"),super(V,h,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:A?["Scene","Mesh"]:void 0,attributes:C,uniforms:K,samplers:A?[]:["grlColors"],defines:k,extraInitializationsAsync:async()=>{A?await Promise.all([mV.e(66).then(mV.bind(mV,15518)),mV.e(75).then(mV.bind(mV,15520))]):await Promise.all([mV.e(69).then(mV.bind(mV,15523)),mV.e(76).then(mV.bind(mV,15528))])},shaderLanguage:A?1:0}),this._color=s.Jh.White(),this._colorsDistributionType=0,this._colorsTexture=null,L=L||{color:lV.DEFAULT_COLOR},this.visibility=L.visibility??1,this.useDash=L.useDash??!1,this.dashRatio=L.dashRatio??.5,this.dashOffset=L.dashOffset??0,this.dashCount=L.dashCount??1,this.width=L.width?L.width:L.sizeAttenuation&&L.cameraFacing?lV.DEFAULT_WIDTH_ATTENUATED:lV.DEFAULT_WIDTH,this.sizeAttenuation=L.sizeAttenuation??!1,this.color=L.color??s.Jh.White(),this.useColors=L.useColors??!1,this.colorsDistributionType=L.colorDistributionType??0,this.colorsSampling=L.colorsSampling??v.e.NEAREST_NEAREST,this.colorMode=L.colorMode??0,this._colors=L.GV??null,this._cameraFacing=L.cameraFacing??!0,this.resolution=L.resolution??new t.Vector2(N.getRenderWidth(),N.getRenderHeight()),L.colorsTexture?this.colorsTexture=L.colorsTexture:this._colors?this.colorsTexture=OV.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,h):(this._color=this._color??lV.DEFAULT_COLOR,this.colorsTexture=OV.PrepareEmptyColorsTexture(h)),A){const V=new ZV.d;V.setParameters(),V.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",V)}N.XL.add((()=>{OV.DisposeEmptyColorsTexture()}))}dispose(){var V;null===(V=this._colorsTexture)||void 0===V||V.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new t.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get GV(){return this._colors}set GV(V){this.setColors(V)}setColors(V){var h;let mV=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const L=(null===(h=this._colors)||void 0===h?void 0:h.length)??0;var N;if(this._colors=V,null!==V&&0!==V.length){if(!mV||t)if(this._colorsTexture&&L===V.length&&!t){const h=OV.Color3toRGBAUint8(V);this._colorsTexture.update(h)}else{var A;null===(A=this._colorsTexture)||void 0===A||A.dispose(),this.colorsTexture=OV.CreateColorsTexture(`${this.name}-colors-texture`,V,this.colorsSampling,this.DV())}}else null===(N=this._colorsTexture)||void 0===N||N.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(V){this._colorsTexture=V,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(V){this._width=V,this.setFloat("grlWidth",V)}get useColors(){return this._useColors}set useColors(V){this._useColors=V,this.setFloat("grlUseColors",OV.BooleanToNumber(V))}get colorsSampling(){return this._colorsSampling}set colorsSampling(V){this._colorsSampling=V}get visibility(){return this._visibility}set visibility(V){this._visibility=V,this.setFloat("grlVisibility",V)}get useDash(){return this._useDash}set useDash(V){this._useDash=V,this.setFloat("grlUseDash",OV.BooleanToNumber(V))}get dashOffset(){return this._dashOffset}set dashOffset(V){this._dashOffset=V,this.setFloat("grlDashOffset",V)}get dashRatio(){return this._dashRatio}set dashRatio(V){this._dashRatio=V,this.setFloat("grlDashRatio",V)}get dashCount(){return this._dashCount}set dashCount(V){this._dashCount=V,this._dashArray=1/V,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(V){this._sizeAttenuation=V,this.setFloat("grlSizeAttenuation",OV.BooleanToNumber(V))}get color(){return this._color}set color(V){this.setColor(V)}setColor(V){V=V??lV.DEFAULT_COLOR,this._color=V,this.setColor3("grlColor",V)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(V){this._colorsDistributionType=V,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(V){this._colorMode=V,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(V){this._resolution=V,this.setVector2("grlResolution",V),this.setFloat("grlAspect",V.x/V.y)}serialize(){const V=super.serialize(),h={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(h.GV=this._colors),V.greasedLineMaterialOptions=h,V}parse(V,h,mV){var t;const L=V.greasedLineMaterialOptions;null===(t=this._colorsTexture)||void 0===t||t.dispose(),L.color&&(this.color=L.color),L.colorDistributionType&&(this.colorsDistributionType=L.colorDistributionType),L.colorsSampling&&(this.colorsSampling=L.colorsSampling),L.colorMode&&(this.colorMode=L.colorMode),L.useColors&&(this.useColors=L.useColors),L.visibility&&(this.visibility=L.visibility),L.useDash&&(this.useDash=L.useDash),L.dashCount&&(this.dashCount=L.dashCount),L.dashRatio&&(this.dashRatio=L.dashRatio),L.dashOffset&&(this.dashOffset=L.dashOffset),L.width&&(this.width=L.width),L.sizeAttenuation&&(this.sizeAttenuation=L.sizeAttenuation),L.resolution&&(this.resolution=L.resolution),L.GV?this.colorsTexture=OV.CreateColorsTexture(`${this.name}-colors-texture`,L.GV,this.colorsSampling,this.DV()):this.colorsTexture=OV.PrepareEmptyColorsTexture(h),this._cameraFacing=L.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var SV,YV,wV;fV.ForceGLSL=!1,function(V){V[V.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",V[V.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(SV||(SV={})),function(V){V[V.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",V[V.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",V[V.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(YV||(YV={})),function(V){V[V.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",V[V.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",V[V.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",V[V.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",V[V.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(wV||(wV={}));class EV extends cV.c{constructor(V,h,mV){super(V,h,null,null,!1,!1),this.name=V,this._options=mV,this._lazy=!1,this._updatable=!1,this._engine=h.getEngine(),this._lazy=mV.lazy??!1,this._updatable=mV.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=mV.colorPointers??[],this._widths=mV.widths??new Array(mV.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(V){let h=0;for(const t of this._points)h+=t.length;const mV=h/3*2-this._widths.length;for(let t=0;t<mV;t++)this._widths.push(V)}updateLazy(){var V,h;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(V=this._options.ribbonOptions)||void 0===V?void 0:V.smoothShading),!this.rV&&this.refreshBoundingInfo(),null===(h=this.greasedLineMaterial)||void 0===h||h.updateLazy()}addPoints(V,h){for(const mV of V)this._points.push(mV);this._lazy||this.setPoints(this._points,h)}dispose(V){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(V,h)}isLazy(){return this._lazy}get yV(){return this._uvs}set yV(V){this._uvs=V instanceof Float32Array?V:new Float32Array(V),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(V){this.material instanceof fV&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===V||void 0===V?void 0:V.length)>0),this._offsets=V,this._offsetsBuffer?this._offsetsBuffer.update(V):this._createOffsetsBuffer(V)}get widths(){return this._widths}set widths(V){this._widths=V,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(V)}get colorPointers(){return this._colorPointers}set colorPointers(V){this._colorPointers=V,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(V)}get greasedLineMaterial(){var V,h;if(this.material&&this.material instanceof fV)return this.material;const mV=null===(V=this.material)||void 0===V||null===(h=V.pluginManager)||void 0===h?void 0:h.getPlugin(rV.GREASED_LINE_MATERIAL_NAME);return mV||void 0}get points(){const V=[];return FV.b.DeepCopy(this._points,V),V}setPoints(V,h){this._points=OV.ConvertPoints(V,(null===h||void 0===h?void 0:h.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==h&&void 0!==h&&h.colorPointers||this._updateColorPointers(),this._setPoints(this._points,h)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,yV:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(V){super.serialize(V),V.type=this.getClassName(),V.lineOptions=this._createLineOptions()}_createVertexBuffers(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new TV.e;return h.jV=this._vertexPositions,h.indices=this._indices,h.yV=this._uvs,V&&(h.lV=[],TV.e.ComputeNormals(this._vertexPositions,this._indices,h.lV)),h.IV(this,this._options.updatable),h}_createOffsetsBuffer(V){const h=this._scene.getEngine(),mV=new o.e(h,V,this._updatable,3);this.setVerticesBuffer(mV.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=mV}}class gV{constructor(V,h){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=V,this.wasAddedByNoopNode=h}getIndicesAccessor(V,h,mV,t,L){var N,A,k,C;return null===(N=this._indicesAccessorMap.get(V))||void 0===N||null===(A=N.get(h))||void 0===A||null===(k=A.get(mV))||void 0===k||null===(C=k.get(t))||void 0===C?void 0:C.get(L)}setIndicesAccessor(V,h,mV,t,L,N){let A=this._indicesAccessorMap.get(V);A||(A=new Map,this._indicesAccessorMap.set(V,A));let k=A.get(h);k||(k=new Map,A.set(h,k));let C=k.get(mV);C||(C=new Map,k.set(mV,C));let K=C.get(t);K||(K=new Map,C.set(t,K)),K.set(L,N)}pushExportedNode(V){this._exportedNodes.has(V)||this._exportedNodes.add(V)}getNodesSet(){return this._exportedNodes}getVertexBufferView(V){return this._vertexBufferViewMap.get(V)}setVertexBufferView(V,h){this._vertexBufferViewMap.set(V,h)}setRemappedBufferView(V,h,mV){this._remappedBufferView.set(V,new Map),this._remappedBufferView.get(V).set(h,mV)}getRemappedBufferView(V,h){var mV;return null===(mV=this._remappedBufferView.get(V))||void 0===mV?void 0:mV.get(h)}getVertexAccessor(V,h,mV){var t,L;return null===(t=this._vertexAccessorMap.get(V))||void 0===t||null===(L=t.get(h))||void 0===L?void 0:L.get(mV)}setVertexAccessor(V,h,mV,t){let L=this._vertexAccessorMap.get(V);L||(L=new Map,this._vertexAccessorMap.set(V,L));let N=L.get(h);N||(N=new Map,L.set(h,N)),N.set(mV,t)}hasVertexColorAlpha(V){return this._vertexMapColorAlpha.get(V)||!1}setHasVertexColorAlpha(V,h){return this._vertexMapColorAlpha.set(V,h)}getMesh(V){return this._meshMap.get(V)}setMesh(V,h){this._meshMap.set(V,h)}bindMorphDataToMesh(V,h){const mV=this._meshMorphTargetMap.get(V)||[];this._meshMorphTargetMap.set(V,mV),-1===mV.indexOf(h)&&mV.push(h)}getMorphTargetsFromMesh(V){return this._meshMorphTargetMap.get(V)}}class iV{_ApplyExtension(V,h,mV,t){if(mV>=h.length)return Promise.resolve(V);const L=t(h[mV],V);return L?L.then((async V=>V?await this._ApplyExtension(V,h,mV+1,t):null)):this._ApplyExtension(V,h,mV+1,t)}_ApplyExtensions(V,h){const mV=[];for(const t of iV._ExtensionNames)mV.push(this._extensions[t]);return this._ApplyExtension(V,mV,0,h)}_extensionsPreExportTextureAsync(V,h,mV){return this._ApplyExtensions(h,((h,t)=>h.preExportTextureAsync&&h.preExportTextureAsync(V,t,mV)))}_extensionsPostExportNodeAsync(V,h,mV,t,L){return this._ApplyExtensions(h,((h,N)=>h.postExportNodeAsync&&h.postExportNodeAsync(V,N,mV,t,L,this._bufferManager)))}_extensionsPostExportMaterialAsync(V,h,mV){return this._ApplyExtensions(h,((h,t)=>h.postExportMaterialAsync&&h.postExportMaterialAsync(V,t,mV)))}_extensionsPostExportMaterialAdditionalTextures(V,h,mV){const t=[];for(const L of iV._ExtensionNames){const N=this._extensions[L];N.postExportMaterialAdditionalTextures&&t.push(...N.postExportMaterialAdditionalTextures(V,h,mV))}return t}_extensionsPostExportTextures(V,h,mV){for(const t of iV._ExtensionNames){const L=this._extensions[t];L.postExportTexture&&L.postExportTexture(V,h,mV)}}_extensionsPostExportMeshPrimitive(V){for(const h of iV._ExtensionNames){const mV=this._extensions[h];mV.postExportMeshPrimitive&&mV.postExportMeshPrimitive(V,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const V of iV._ExtensionNames){const h=this._extensions[V];h.preGenerateBinaryAsync&&await h.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(V){for(const h of iV._ExtensionNames){const mV=this._extensions[h];mV.enabled&&V(mV)}}_extensionsOnExporting(){this._forEachExtensions((V=>{var h,mV,t;V.wasUsed&&((h=this._glTF).extensionsUsed||(h.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(V.name)&&this._glTF.extensionsUsed.push(V.name),V.required&&((mV=this._glTF).extensionsRequired||(mV.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(V.name)&&this._glTF.extensionsRequired.push(V.name)),(t=this._glTF).extensions||(t.extensions={}),V.onExporting&&V.onExporting())}))}_loadExtensions(){for(const V of iV._ExtensionNames){const h=iV._ExtensionFactories[V](this);this._extensions[V]=h}}constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:d.b.LastCreatedScene,h=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${R.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new Z(this),this._extensions={},this._bufferManager=new oV,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!V)throw new Error("No scene available to export");this._babylonScene=V,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:V=>{var h;return null===V||void 0===V||null===(h=V.qk)||void 0===h?void 0:h.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...h},this._loadExtensions()}dispose(){for(const V in this._extensions){this._extensions[V].dispose()}}get options(){return this._options}static RegisterExtension(V,h){iV.UnregisterExtension(V)&&L.Tools.Warn(`Extension with the name ${V} already exists`),iV._ExtensionFactories[V]=h,iV._ExtensionNames.push(V)}static UnregisterExtension(V){if(!iV._ExtensionFactories[V])return!1;delete iV._ExtensionFactories[V];const h=iV._ExtensionNames.indexOf(V);return-1!==h&&iV._ExtensionNames.splice(h,1),!0}_generateJSON(V,h,mV){const t={byteLength:V};return t.byteLength&&(this._glTF.buffers=[t]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.zh=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(t.uri=h+".bin"),mV?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(V){const h=await this._generateBinaryAsync();this._extensionsOnExporting();const mV=this._generateJSON(h.byteLength,V,!0),t=new Blob([h],{type:"application/octet-stream"}),L=V+".gltf",N=V+".bin",A=new K;if(A.files[L]=mV,A.files[N]=t,this._imageData)for(const k in this._imageData)A.files[k]=new Blob([this._imageData[k].data],{type:this._imageData[k].mimeType});return A}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(V){const h=V%4;return 0===h?h:4-h}async generateGLBAsync(V){this._shouldUseGlb=!0;const h=await this._generateBinaryAsync();this._extensionsOnExporting();const mV=this._generateJSON(h.byteLength),t=V+".glb";let L,N=mV.length;if("undefined"!==typeof TextEncoder){L=(new TextEncoder).encode(mV),N=L.length}const A=this._getPadding(N),k=this._getPadding(h.byteLength),C=28+N+A+h.byteLength+k,o=new CV(C);if(o.writeUInt32(1179937895),o.writeUInt32(2),o.writeUInt32(C),o.writeUInt32(N+A),o.writeUInt32(1313821514),L)o.writeTypedArray(L);else{const V="_".charCodeAt(0);for(let h=0;h<N;++h){const t=mV.charCodeAt(h);t!=mV.codePointAt(h)?o.writeUInt8(V):o.writeUInt8(t)}}for(let K=0;K<A;++K)o.writeUInt8(32);o.writeUInt32(h.byteLength+k),o.writeUInt32(5130562),o.writeTypedArray(h);for(let K=0;K<k;++K)o.writeUInt8(0);const n=new K;return n.files[t]=new Blob([o.getOutputData()],{type:"application/octet-stream"}),n}_setNodeTransformation(V,h,mV){if(h.getPivotPoint().equalsWithEpsilon(E,w.c)||L.Tools.Warn("Pivot points are not supported in the glTF serializer"),!h.position.equalsWithEpsilon(E,w.c)){const L=t.TmpVectors.sh[0].t(h.position);mV&&X(L),V.translation=L.sk()}h.jk.equalsWithEpsilon(i,w.c)||(V.scale=h.jk.sk());const N=h.rotationQuaternion||t.Quaternion.FromEulerAngles(h.rotation.x,h.rotation.y,h.rotation.z);N.equalsWithEpsilon(g,w.c)||(mV&&a(N),V.rotation=N.normalize().sk())}_setCameraTransformation(V,h,mV){if(!h.position.equalsWithEpsilon(E,w.c)){const L=t.TmpVectors.sh[0].t(h.position);mV&&X(L),V.translation=L.sk()}const L=h.rotationQuaternion||t.Quaternion.FromEulerAngles(h.rotation.x,h.rotation.y,h.rotation.z);mV&&a(L),this._babylonScene.useRightHandedSystem||B(L),L.equalsWithEpsilon(g,w.c)||(V.rotation=L.sk())}_listAvailableCameras(){for(const V of this._babylonScene.cameras){const h={type:V.mode===qV.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(V.name&&(h.name=V.name),"perspective"===h.type)h.perspective={aspectRatio:V.getEngine().getAspectRatio(V),yfov:V.fovMode===qV.b.FOVMODE_VERTICAL_FIXED?V.fov:V.fov*V.getEngine().getAspectRatio(V),znear:V.ck,zfar:V.maxZ};else if("orthographic"===h.type){const mV=V.orthoLeft&&V.orthoRight?.5*(V.orthoRight-V.orthoLeft):.5*V.getEngine().getRenderWidth(),t=V.orthoBottom&&V.orthoTop?.5*(V.orthoTop-V.orthoBottom):.5*V.getEngine().getRenderHeight();h.orthographic={xmag:mV,ymag:t,znear:V.ck,zfar:V.maxZ}}this._camerasMap.set(V,h)}}_exportAndAssignCameras(){const V=Array.from(this._camerasMap.values());for(const h of V){const V=this._nodesCameraMap.get(h);if(void 0!==V){this._cameras.push(h);for(const h of V)h.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const V of this._babylonScene.skeletons){if(V.bones.length<=0)continue;const h={joints:[]};this._skinMap.set(V,h)}}_exportAndAssignSkeletons(){for(const V of this._babylonScene.skeletons){if(V.bones.length<=0)continue;const h=this._skinMap.get(V);if(void 0==h)continue;const mV={},t=[];let N=-1;for(let L=0;L<V.bones.length;++L){const h=V.bones[L],t=h.getIndex()??L;-1!==t&&(mV[t]=h,t>N&&(N=t))}for(let V=0;V<=N;++V){const N=mV[V];t.push(N.getAbsoluteInverseBindMatrix());const A=N.getTransformNode();if(null!==A){const V=this._nodeMap.get(A);A&&null!==V&&void 0!==V?h.joints.push(V):L.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else L.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const A=this._nodesSkinMap.get(h);if(h.joints.length>0&&void 0!==A){const V=64*t.length,mV=new Float32Array(V/4);t.forEach(((V,h)=>{mV.set(V.m,16*h)}));const L=this._bufferManager.createBufferView(mV);this._accessors.push(this._bufferManager.createAccessor(L,"MAT4",5126,t.length)),h.inverseBindMatrices=this._accessors.length-1,this._skins.push(h);for(const h of A)h.skin=this._skins.length-1}}}async _exportSceneAsync(){const V={nodes:[]};if(this._babylonScene.metadata){const h=this._options.metadataSelector(this._babylonScene.metadata);h&&(V.extras=h)}const h=new Array,mV=new Array,t=new Array;for(const k of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&AV(k,this._babylonScene.useRightHandedSystem)?t.push(...k.getChildren()):this._babylonScene.useRightHandedSystem?h.push(k):mV.push(k);this._listAvailableCameras(),this._listAvailableSkeletons();const L=new gV(!0,!1);V.nodes.push(...await this._exportNodesAsync(mV,L));const N=new gV(!1,!1);V.nodes.push(...await this._exportNodesAsync(h,N));const A=new gV(!1,!0);V.nodes.push(...await this._exportNodesAsync(t,A)),V.nodes.length&&this._scenes.push(V),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&QV._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,L.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(V){let h=this._shouldExportNodeMap.get(V);return void 0===h&&(h=this._options.shouldExportNode(V),this._shouldExportNodeMap.set(V,h)),h}async _exportNodesAsync(V,h){const mV=new Array;this._exportBuffers(V,h);for(const t of V)await this._exportNodeAsync(t,mV,h);return mV}_collectBuffers(V,h,mV,t,L){if(this._shouldExportNode(V)&&V instanceof q.e&&V.Jk){const N=V.Jk.getVertexBuffers();if(N)for(const t in N){if(!u(t))continue;const A=N[t];L.setHasVertexColorAlpha(A,V.hasVertexAlpha);const k=A._buffer,C=h.get(k)||[];h.set(k,C),-1===C.indexOf(A)&&C.push(A);const K=mV.get(A)||[];mV.set(A,K),-1===K.indexOf(V)&&K.push(V)}const A=V.morphTargetManager;if(A)for(let h=0;h<A.numTargets;h++){const mV=A.getTarget(h),L=t.get(mV)||[];t.set(mV,L),-1===L.indexOf(V)&&L.push(V)}}for(const N of V.getChildren())this._collectBuffers(N,h,mV,t,L)}_exportBuffers(V,h){const mV=new Map,t=new Map,L=new Map;for(const k of V)this._collectBuffers(k,mV,t,L,h);const N=Array.from(mV.keys());for(const k of N){const V=k.getData();if(!V)throw new Error("Buffer data is not available");const L=mV.get(k);if(!L)continue;const N=L[0].byteStride;if(L.some((V=>V.byteStride!==N)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const A=mh(V).slice();for(const h of L){const V=t.get(h),{byteOffset:mV,byteStride:L,componentCount:N,type:k,count:C,normalized:K,kind:n}=P(h,V);switch(n){case o.i.NormalKind:case o.i.TangentKind:(0,f.e)(A,mV,L,N,k,C,K,(V=>{const h=Math.sqrt(V[0]*V[0]+V[1]*V[1]+V[2]*V[2]);if(h>0){const mV=1/h;V[0]*=mV,V[1]*=mV,V[2]*=mV}}));break;case o.i.ColorKind:{const h=V.filter((V=>V.material instanceof dV.Qh||null==V.material)).length;if(0==h)break;if(h!=V.length){S.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}k==o.i.UNSIGNED_BYTE&&S.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const t=new s.Jh,n=new s.Gk,q=this._babylonScene.getEngine().useExactSrgbConversions;(0,f.e)(A,mV,L,N,k,C,K,(V=>{3===V.length?(t.Dm(V,0),t.toLinearSpaceToRef(t,q),t.toArray(V,0)):(n.Dm(V,0),n.toLinearSpaceToRef(n,q),n.toArray(V,0))}))}}}if(h.convertToRightHanded){for(const V of L){const h=t.get(V),{byteOffset:mV,byteStride:L,componentCount:N,type:k,count:C,normalized:K,kind:n}=P(V,h);switch(n){case o.i.PositionKind:case o.i.NormalKind:case o.i.TangentKind:(0,f.e)(A,mV,L,N,k,C,K,(V=>{V[0]=-V[0]}))}}h.convertedToRightHandedBuffers.set(k,A)}const C=this._bufferManager.createBufferView(A,N);h.setVertexBufferView(k,C);const K=new Map;for(const h of L){const V=t.get(h),{kind:mV,totalVertices:L}=P(h,V);switch(mV){case o.i.MatricesIndicesKind:case o.i.MatricesIndicesExtraKind:if(h.type==o.i.FLOAT){const V=h.getFloatData(L);null!==V&&K.set(h,V)}}}0!==K.size&&S.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const n=Array.from(K.keys());for(const mV of n){const V=K.get(mV);if(!V)continue;const t=V.some((V=>V>=256)),L=new(t?Uint16Array:Uint8Array)(V.length);for(let h=0;h<V.length;h++)L[h]=V[h];const N=this._bufferManager.createBufferView(L,4*(t?2:1));h.setRemappedBufferView(k,mV,N)}}const A=Array.from(L.keys());for(const k of A){const V=L.get(k);if(!V)continue;const mV=JV(k,V[0],this._bufferManager,this._bufferViews,this._accessors,h.convertToRightHanded);for(const t of V)h.bindMorphDataToMesh(t,mV)}}async _exportNodeAsync(V,h,mV){let t=this._nodeMap.get(V);if(void 0!==t)return void(h.includes(t)||h.push(t));const L=await this._createNodeAsync(V,mV);if(L){t=this._nodes.length,this._nodes.push(L),this._nodeMap.set(V,t),mV.pushExportedNode(V),h.push(t);const N={name:"runtime animations",channels:[],samplers:[]},A=[];this._babylonScene.animationGroups.length||(QV._CreateMorphTargetAnimationFromMorphTargetAnimations(V,N,A,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,mV.convertToRightHanded,this._options.shouldExportAnimation),V.animations.length&&QV._CreateNodeAnimationFromNodeAnimations(V,N,A,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,mV.convertToRightHanded,this._options.shouldExportAnimation)),N.channels.length&&N.samplers.length&&this._animations.push(N),A.forEach((V=>{V.channels.length&&V.samplers.length&&this._animations.push(V)}))}const N=L?[]:h;for(const A of V.getChildren())await this._exportNodeAsync(A,N,mV);L&&N.length&&(L.children=N)}async _createNodeAsync(V,h){if(!this._shouldExportNode(V))return null;const mV={};if(V.name&&(mV.name=V.name),V.metadata){const h=this._options.metadataSelector(V.metadata);h&&(mV.extras=h)}if(V instanceof n.c&&(this._setNodeTransformation(mV,V,h.convertToRightHanded),V instanceof q.e)){const L=V instanceof x.e?V.sourceMesh:V;if(L.dk&&L.dk.length>0&&(mV.mesh=await this._exportMeshAsync(L,h)),V.skeleton){const h=this._skinMap.get(V.skeleton);var t;if(void 0!==h)void 0===this._nodesSkinMap.get(h)&&this._nodesSkinMap.set(h,[]),null===(t=this._nodesSkinMap.get(h))||void 0===t||t.push(mV)}}if(V instanceof Y.d){const t=this._camerasMap.get(V);if(t){var L;void 0===this._nodesCameraMap.get(t)&&this._nodesCameraMap.set(t,[]),this._setCameraTransformation(mV,V,h.convertToRightHanded);const A=V.parent;if(null!==A&&hV(V,A)){const V=this._nodeMap.get(A);if(void 0!==V){var N;const h=this._nodes[V];return VV(mV,h),null===(N=this._nodesCameraMap.get(t))||void 0===N||N.push(h),null}}null===(L=this._nodesCameraMap.get(t))||void 0===L||L.push(mV)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",mV,V,this._nodeMap,h.convertToRightHanded)?mV:(S.e.Warn(`Not exporting node ${V.name}`),null)}_exportIndices(V,h,mV,t,L,A,k,C,K){let o=V;K.mode=e(A);const n=k!==N.c.CounterClockWiseSideOrientation,q=!C.wasAddedByNoopNode&&n,x=function(V){switch(V){case N.c.TriangleFillMode:case N.c.TriangleStripDrawMode:case N.c.TriangleFanDrawMode:return!0}return!1}(A)&&q;if(x){if(A===N.c.TriangleStripDrawMode||A===N.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");K.mode=e(A);const k=h?new Uint32Array(t):new Uint16Array(t);if(V)for(let h=0;h+2<t;h+=3)k[h]=V[mV+h]+L,k[h+1]=V[mV+h+2]+L,k[h+2]=V[mV+h+1]+L;else for(let V=0;V+2<t;V+=3)k[V]=V,k[V+1]=V+2,k[V+2]=V+1;o=k}else if(V&&0!==L){const N=h?new Uint32Array(t):new Uint16Array(t);for(let h=0;h<t;h++)N[h]=V[mV+h]+L;o=N}if(o){let N=C.getIndicesAccessor(V,mV,t,L,x);if(void 0===N){const A=function(V,h,mV,t){if(V instanceof Uint16Array||V instanceof Uint32Array)return V;if(V instanceof Int32Array)return new Uint32Array(V.buffer,V.byteOffset,V.length);const L=V.slice(h,h+mV);return t?new Uint32Array(L):new Uint16Array(L)}(o,0,t,h),k=this._bufferManager.createBufferView(A),K=h?5125:5123;this._accessors.push(this._bufferManager.createAccessor(k,"SCALAR",K,t,0)),N=this._accessors.length-1,C.setIndicesAccessor(V,mV,t,L,x,N)}K.indices=N}}_exportVertexBuffer(V,h,mV,t,L,N){const A=V.getKind();if(!u(A))return;if(A.startsWith("uv")&&!this._options.exportUnusedUVs&&(!h||!this._materialNeedsUVsSet.has(h)))return;let k=L.getVertexAccessor(V,mV,t);if(void 0===k){const h=L.convertedToRightHandedBuffers.get(V._buffer)||V._buffer.getData(),N=A===o.i.PositionKind?function(V,h,mV,t){const{byteOffset:L,byteStride:N,type:A,normalized:k}=h,C=h.getSize(),K=new Array(C).fill(1/0),o=new Array(C).fill(-1/0);return(0,f.e)(V,L+mV*N,N,C,A,t*C,k,(V=>{for(let h=0;h<C;h++)K[h]=Math.min(K[h],V[h]),o[h]=Math.max(o[h],V[h])})),{min:K,max:o}}(h,V,mV,t):void 0,C=(A===o.i.MatricesIndicesKind||A===o.i.MatricesIndicesExtraKind)&&V.type===o.i.FLOAT,K=C?o.i.UNSIGNED_BYTE:V.type,n=C?void 0:V.normalized,q=C?L.getRemappedBufferView(V._buffer,V):L.getVertexBufferView(V._buffer),x=V.byteOffset+mV*V.byteStride;this._accessors.push(this._bufferManager.createAccessor(q,function(V,h){if(V==o.i.ColorKind)return h?"VEC4":"VEC3";switch(V){case o.i.PositionKind:case o.i.NormalKind:return"VEC3";case o.i.TangentKind:case o.i.MatricesIndicesKind:case o.i.MatricesIndicesExtraKind:case o.i.MatricesWeightsKind:case o.i.MatricesWeightsExtraKind:return"VEC4";case o.i.UVKind:case o.i.UV2Kind:case o.i.UV3Kind:case o.i.UV4Kind:case o.i.UV5Kind:case o.i.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${V}`)}(A,L.hasVertexColorAlpha(V)),K,t,x,N,n)),k=this._accessors.length-1,L.setVertexAccessor(V,mV,t,k)}N.attributes[function(V){switch(V){case o.i.PositionKind:return"POSITION";case o.i.NormalKind:return"NORMAL";case o.i.TangentKind:return"TANGENT";case o.i.ColorKind:return"COLOR_0";case o.i.UVKind:return"TEXCOORD_0";case o.i.UV2Kind:return"TEXCOORD_1";case o.i.UV3Kind:return"TEXCOORD_2";case o.i.UV4Kind:return"TEXCOORD_3";case o.i.UV5Kind:return"TEXCOORD_4";case o.i.UV6Kind:return"TEXCOORD_5";case o.i.MatricesIndicesKind:return"JOINTS_0";case o.i.MatricesIndicesExtraKind:return"JOINTS_1";case o.i.MatricesWeightsKind:return"WEIGHTS_0";case o.i.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${V}`)}(A)]=k}async _exportMaterialAsync(V,h,mV,t){let L=this._materialMap.get(V);if(void 0===L){const t=h&&Object.keys(h).some((V=>V.startsWith("uv")));if((V=V instanceof xV.e?V.yk[mV.materialIndex]:V)instanceof RV.c)L=await this._materialExporter.exportPBRMaterialAsync(V,"image/png",t);else{if(!(V instanceof dV.Qh))return void S.e.Warn(`Unsupported material '${V.name}' with type ${V.getClassName()}`);L=await this._materialExporter.exportStandardMaterialAsync(V,"image/png",t)}this._materialMap.set(V,L)}t.material=L}async _exportMeshAsync(V,h){var mV;let t=h.getMesh(V);if(void 0!==t)return t;const L={primitives:[]};t=this._meshes.length,this._meshes.push(L),h.setMesh(V,t);const A=V.isUnIndexed?null:V.vk(),k=null===(mV=V.Jk)||void 0===mV?void 0:mV.getVertexBuffers(),C=h.getMorphTargetsFromMesh(V),K=V instanceof vV.c,o=V instanceof EV,n=V.dk;if(k&&n&&n.length>0)for(const R of n){const mV={attributes:{}},t=R.ZV()||this._babylonScene.defaultMaterial;if(o){var q,x;const h={name:t.name},L=V,N=s.Jh.White(),A=(null===(q=L.material)||void 0===q?void 0:q.alpha)??1,k=(null===(x=L.greasedLineMaterial)||void 0===x?void 0:x.color)??N;(!k.equalsWithEpsilon(N,w.c)||A<1)&&(h.pbrMetallicRoughness={baseColorFactor:[...k.sk(),A]}),this._materials.push(h),mV.material=this._materials.length-1}else if(K){const h={name:t.name},L=V;(!L.color.equalsWithEpsilon(s.Jh.White(),w.c)||L.alpha<1)&&(h.pbrMetallicRoughness={baseColorFactor:[...L.color.sk(),L.alpha]}),this._materials.push(h),mV.material=this._materials.length-1}else await this._exportMaterialAsync(t,k,R,mV);const n=K||o?N.c.LineListDrawMode:V.overrideRenderingFillMode??t.fillMode,d=t._getEffectiveOrientation(V);this._exportIndices(A,A?(0,f.b)(A,R.indexCount,R.indexStart,R.verticesStart):R.verticesCount>65535,A?R.indexStart:R.verticesStart,A?R.indexCount:R.verticesCount,-R.verticesStart,n,d,h,mV);for(const V of Object.values(k))this._exportVertexBuffer(V,t,R.verticesStart,R.verticesCount,h,mV);if(C){mV.targets=[];for(const V of C)mV.targets.push(V.attributes)}L.primitives.push(mV),this._extensionsPostExportMeshPrimitive(mV)}if(C){L.weights=[],L.extras||(L.extras={}),L.extras.targetNames=[];for(const V of C)L.weights.push(V.influence),L.extras.targetNames.push(V.name)}return t}}iV._ExtensionNames=new Array,iV._ExtensionFactories={};class bV{static async GLTFAsync(V,h,mV){mV&&mV.exportWithoutWaitingForScene||await V.whenReadyAsync();const t=new iV(V,mV),L=await t.generateGLTFAsync(h.replace(/\.[^/.]+$/,""));return t.dispose(),L}static async GLBAsync(V,h,mV){mV&&mV.exportWithoutWaitingForScene||await V.whenReadyAsync();const t=new iV(V,mV),L=await t.generateGLBAsync(h.replace(/\.[^/.]+$/,""));return t.dispose(),L}}mV(12965);const PV="EXT_mesh_gpu_instancing";class UV{constructor(V){this.name=PV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(V,h,mV,L,N,A){return await new Promise((V=>{if(h&&mV instanceof cV.c&&mV.hasThinInstances&&this._exporter){this._wasUsed=!0;const V=t.sh.Zero(),L=t.Quaternion.Identity(),k=t.sh.One(),C=mV.thinInstanceGetWorldMatrices(),K=t.TmpVectors.sh[2],o=t.TmpVectors.Quaternion[1],n=t.TmpVectors.sh[3];let q=!1,x=!1,R=!1;const d=new Float32Array(3*mV.Ok),s=new Float32Array(4*mV.Ok),M=new Float32Array(3*mV.Ok);let c=0;for(const h of C)h.decompose(n,o,K),N&&(X(K),a(o)),d.set(K.sk(),3*c),s.set(o.normalize().sk(),4*c),M.set(n.sk(),3*c),q=q||!K.equalsWithEpsilon(V),x=x||!o.equalsWithEpsilon(L),R=R||!n.equalsWithEpsilon(k),c++;const z={attributes:{}};q&&(z.attributes.TRANSLATION=this._buildAccessor(d,"VEC3",mV.Ok,A)),x&&(z.attributes.ROTATION=this._buildAccessor(s,"VEC4",mV.Ok,A)),R&&(z.attributes.SCALE=this._buildAccessor(M,"VEC3",mV.Ok,A)),h.extensions=h.extensions||{},h.extensions[PV]=z}V(h)}))}_buildAccessor(V,h,mV,t){const L=t.createBufferView(V),N=t.createAccessor(L,h,5126,mV);return this._exporter._accessors.push(N),this._exporter._accessors.length-1}}iV.RegisterExtension(PV,(V=>new UV(V)));var uV=mV(12969),eV=mV(12979),WV=mV(12986),XV=mV(12988);function aV(V){return V===WV.e.PositionKind?"POSITION":V===WV.e.NormalKind?"NORMAL":V===WV.e.ColorKind?"COLOR":V.startsWith(WV.e.UVKind)?"TEX_COORD":"GENERIC"}const BV={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Vh extends uV.b{static get DefaultAvailable(){return(0,uV.h)(Vh.DefaultConfiguration)}static get Default(){return Vh._Default??(Vh._Default=new Vh),Vh._Default}static ResetDefault(V){Vh._Default&&(V||Vh._Default.dispose(),Vh._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(V,h){return{module:await(h||DracoEncoderModule)({wasmBinary:V})}}_getWorkerContent(){return`${eV.j}(${eV.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Vh.DefaultConfiguration)}async _encodeAsync(V,h,mV){const t=mV?(0,XV.b)(BV,mV):BV;if(this._workerPoolPromise){const mV=await this._workerPoolPromise;return await new Promise(((L,N)=>{mV.push(((mV,A)=>{const k=V=>{mV.removeEventListener("error",k),mV.removeEventListener("message",C),N(V),A()},C=V=>{"encodeMeshDone"===V.data.id&&(mV.removeEventListener("error",k),mV.removeEventListener("message",C),L(V.data.encodedMeshData),A())};mV.addEventListener("error",k),mV.addEventListener("message",C);const K=[];for(const h of V)K.push(h.data.buffer);h&&K.push(h.buffer),mV.postMessage({id:"encodeMesh",attributes:V,indices:h,options:t},K)}))}))}if(this._modulePromise){const mV=await this._modulePromise;return(0,eV.j)(mV.module,V,h,t)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(V,h){if(0==V.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");V instanceof cV.c&&V.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===h||void 0===h?void 0:h.method)&&(S.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),h.method="MESH_SEQUENTIAL_ENCODING");const mV=function(V){let h=V.vk(void 0,!0);return!h||h instanceof Uint32Array||h instanceof Uint16Array||(h=((0,f.b)(h,h.length)?Uint32Array:Uint16Array).from(h)),h}(V),t=function(V,h){const mV=[];for(const t of V.getVerticesDataKinds()){if(null!==h&&void 0!==h&&h.includes(t)){if(t===WV.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const L=V.getVertexBuffer(t),N=L.getSize(),A=(0,f.n)(L.getData(),N,L.type,L.byteOffset,L.byteStride,L.normalized,V.getTotalVertices(),!0);mV.push({kind:t,dracoName:aV(t),size:N,data:A})}return mV}(V,null===h||void 0===h?void 0:h.excludedAttributes);return await this._encodeAsync(t,mV,h)}}Vh.DefaultConfiguration={wasmUrl:`${L.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${L.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${L.Tools._DefaultCdnUrl}/draco_encoder.js`},Vh._Default=null;const hh="KHR_draco_mesh_compression";class mm{get wasUsed(){return this._wasUsed}constructor(V){this.name=hh,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===V.options.meshCompressionMethod&&Vh.DefaultAvailable}dispose(){}postExportMeshPrimitive(V,h,mV){if(!this.enabled)return;if(4!==V.mode&&5!==V.mode)return void S.e.Warn("Cannot compress primitive with mode "+V.mode+".");const t=[],L=[];let N=null;if(void 0!==V.indices){const A=mV[V.indices],k=h.getBufferView(A);N=h.getData(k).slice(),t.push(k),L.push(A)}const A=[];for(const[o,n]of Object.entries(V.attributes)){const V=mV[n],N=h.getBufferView(V),C=U(V.type),K=(0,f.n)(h.getData(N),C,V.componentType,V.byteOffset||0,N.byteStride||(0,f.h)(V.componentType)*C,V.normalized||!1,V.count,!0);A.push({kind:o,dracoName:(k=o,"POSITION"===k?"POSITION":"NORMAL"===k?"NORMAL":k.startsWith("COLOR")?"COLOR":k.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:U(V.type),data:K}),t.push(N),L.push(V)}var k;const C={method:V.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},K=Vh.Default._encodeAsync(A,N,C).then((mV=>{if(!mV)return void S.e.Error("Draco encoding failed for primitive.");const N={bufferView:-1,attributes:mV.attributeIds},A=h.createBufferView(mV.data);h.setBufferView(N,A);for(const V of t)this._bufferViewsUsed.add(V);for(const V of L)this._accessorsUsed.add(V);V.extensions||(V.extensions={}),V.extensions[hh]=N})).catch((V=>{S.e.Error("Draco encoding failed for primitive: "+V)}));this._encodePromises.push(K),this._wasUsed=!0}async preGenerateBinaryAsync(V){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((h=>{V.getPropertiesWithBufferView(h).every((V=>this._accessorsUsed.has(V)))&&V.removeBufferView(h)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}iV.RegisterExtension(hh,(V=>new mm(V)));var th=mV(12995);const Lh="KHR_lights_punctual",Nh={name:"",color:[1,1,1],Ik:1,range:Number.MAX_VALUE},Ah={innerConeAngle:0,outerConeAngle:Math.PI/4},kh=t.sh.Backward();class Ch{constructor(V){this.name=Lh,this.enabled=!0,this.required=!1,this._exporter=V}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Lh]=this._lights}async postExportNodeAsync(V,h,mV,L,N){return await new Promise((A=>{if(!(mV instanceof zV.d))return void A(h);const k=mV.getTypeID()==zV.d.LIGHTTYPEID_POINTLIGHT?"point":mV.getTypeID()==zV.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":mV.getTypeID()==zV.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!k||!(mV instanceof th.d))return S.e.Warn(`${V}: Light ${mV.name} is not supported in ${Lh}`),void A(h);if(mV.falloffType!==zV.d.FALLOFF_GLTF&&S.e.Warn(`${V}: Light falloff for ${mV.name} does not match the ${Lh} specification!`),!mV.position.equalsToFloats(0,0,0)){const V=t.TmpVectors.sh[0].t(mV.position);N&&X(V),h.translation=V.sk()}if("point"!==k){const V=mV.direction.normalizeToRef(t.TmpVectors.sh[0]);N&&X(V);const L=t.Quaternion.FromUnitVectorsToRef(kh,V,t.TmpVectors.Quaternion[0]);t.Quaternion.IsIdentity(L)||(h.rotation=L.sk())}const C={type:k,name:mV.name,color:mV.rk.sk(),Ik:mV.Ik,range:mV.range};if(tV(C,Nh),"spot"===k){const V=mV;C.spot={innerConeAngle:V.innerAngle/2,outerConeAngle:V.angle/2},tV(C.spot,Ah)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(C);const K={fh:this._lights.lights.length-1},o=mV.parent;if(o&&hV(mV,o)){const V=L.get(o);if(V){const mV=this._exporter._nodes[V];return VV(h,mV),mV.extensions||(mV.extensions={}),mV.extensions[Lh]=K,void A(null)}}h.extensions||(h.extensions={}),h.extensions[Lh]=K,A(h)}))}}iV.RegisterExtension(Lh,(V=>new Ch(V)));var Kh=mV(12899);const oh="KHR_materials_anisotropy";class nh{constructor(V){this.name=oh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,h,mV){const t=[];return mV instanceof Kh.e&&mV.anisotropy.isEnabled&&!mV.anisotropy.legacy?(mV.anisotropy.texture&&t.push(mV.anisotropy.texture),t):[]}postExportMaterialAsync(V,h,mV){return new Promise((V=>{if(mV instanceof Kh.e){if(!mV.anisotropy.isEnabled||mV.anisotropy.legacy)return void V(h);this._wasUsed=!0,h.extensions=h.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(mV.anisotropy.texture),L={anisotropyStrength:mV.anisotropy.Ik,anisotropyRotation:mV.anisotropy.angle,anisotropyTexture:t??void 0};null!==L.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(mV),h.extensions[oh]=L}V(h)}))}}iV.RegisterExtension(oh,(V=>new nh(V)));const qh="KHR_materials_clearcoat";class xh{constructor(V){this.name=qh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,h,mV){const t=[];return mV instanceof Kh.e&&mV.clearCoat.isEnabled?(mV.clearCoat.texture&&t.push(mV.clearCoat.texture),!mV.clearCoat.useRoughnessFromMainTexture&&mV.clearCoat.textureRoughness&&t.push(mV.clearCoat.textureRoughness),mV.clearCoat.bumpTexture&&t.push(mV.clearCoat.bumpTexture),t):[]}postExportMaterialAsync(V,h,mV){return new Promise((V=>{if(mV instanceof Kh.e){if(!mV.clearCoat.isEnabled)return void V(h);this._wasUsed=!0,h.extensions=h.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(mV.clearCoat.texture);let N;N=mV.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(mV.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(mV.clearCoat.textureRoughness),mV.clearCoat.isTintEnabled&&L.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${mV.name}`),mV.clearCoat.remapF0OnInterfaceChange&&L.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${mV.name}`);const A=this._exporter._materialExporter.getTextureInfo(mV.clearCoat.bumpTexture),k={clearcoatFactor:mV.clearCoat.Ik,clearcoatTexture:t??void 0,clearcoatRoughnessFactor:mV.clearCoat.roughness,clearcoatRoughnessTexture:N??void 0,clearcoatNormalTexture:A??void 0};null===k.clearcoatTexture&&null===k.clearcoatRoughnessTexture&&null===k.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(mV),h.extensions[qh]=k}V(h)}))}}iV.RegisterExtension(qh,(V=>new xh(V)));const Rh="KHR_materials_diffuse_transmission";function dh(V,h){const mV=h.subSurface;let t=null;return mV.translucencyIntensityTexture?t=mV.translucencyIntensityTexture:mV.thicknessTexture&&mV.useMaskFromThicknessTexture&&(t=mV.thicknessTexture),t&&!mV.useGltfStyleTextures?(S.e.Warn(`${V}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${h.name}`,1),null):t}class sh{constructor(V){this.name=Rh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,h,mV){const t=[];if(mV instanceof RV.c&&this._isExtensionEnabled(mV)){const h=dh(V,mV);return h&&t.push(h),mV.subSurface.translucencyColorTexture&&t.push(mV.subSurface.translucencyColorTexture),t}return t}_isExtensionEnabled(V){if(V.unlit)return!1;const h=V.subSurface;return!!h.isTranslucencyEnabled&&(!V.unlit&&!h.useAlbedoToTintTranslucency&&h.useGltfStyleTextures&&1===h.volumeIndexOfRefraction&&0===h.minimumThickness&&0===h.maximumThickness)}postExportMaterialAsync(V,h,mV){return new Promise((t=>{if(mV instanceof RV.c&&this._isExtensionEnabled(mV)){this._wasUsed=!0;const t=mV.subSurface,L=dh(V,mV),N=0==t.translucencyIntensity?void 0:t.translucencyIntensity,A=this._exporter._materialExporter.getTextureInfo(L)??void 0,k=!t.translucencyColor||t.translucencyColor.equalsFloats(1,1,1)?void 0:t.translucencyColor.sk(),C=this._exporter._materialExporter.getTextureInfo(t.translucencyColorTexture)??void 0,K={diffuseTransmissionFactor:N,diffuseTransmissionTexture:A,diffuseTransmissionColorFactor:k,diffuseTransmissionColorTexture:C};(A||C)&&this._exporter._materialNeedsUVsSet.add(mV),h.extensions=h.extensions||{},h.extensions[Rh]=K}t(h)}))}}iV.RegisterExtension(Rh,(V=>new sh(V)));const Mh="KHR_materials_dispersion";class ch{constructor(){this.name=Mh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(V){if(V.unlit)return!1;const h=V.subSurface;return!(!h.isRefractionEnabled&&!h.isDispersionEnabled)}postExportMaterialAsync(V,h,mV){return new Promise((V=>{if(mV instanceof RV.c&&this._isExtensionEnabled(mV)){this._wasUsed=!0;const V={dispersion:mV.subSurface.dispersion};h.extensions=h.extensions||{},h.extensions[Mh]=V}V(h)}))}}iV.RegisterExtension(Mh,(()=>new ch));const zh="KHR_materials_emissive_strength";class Qh{constructor(){this.name=zh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(V,h,mV){return await new Promise((V=>{if(!(mV instanceof RV.c))return V(h);const t=mV.emissiveColor.sk(),L=Math.max(...t);if(L>1){this._wasUsed=!0,h.extensions||(h.extensions={});const V={emissiveStrength:L},t=mV.emissiveColor.scale(1/V.emissiveStrength);h.emissiveFactor=t.sk(),h.extensions[zh]=V}return V(h)}))}}iV.RegisterExtension(zh,(V=>new Qh));const Jh="KHR_materials_ior";class vh{constructor(){this.name=Jh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(V){return!V.unlit&&(void 0!=V.indexOfRefraction&&1.5!=V.indexOfRefraction)}postExportMaterialAsync(V,h,mV){return new Promise((V=>{if(mV instanceof RV.c&&this._isExtensionEnabled(mV)){this._wasUsed=!0;const V={ior:mV.indexOfRefraction};h.extensions=h.extensions||{},h.extensions[Jh]=V}V(h)}))}}iV.RegisterExtension(Jh,(V=>new vh));const Dh="KHR_materials_iridescence";class Hh{constructor(V){this.name=Dh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,h,mV){const t=[];return mV instanceof Kh.e&&mV.iridescence.isEnabled?(mV.iridescence.texture&&t.push(mV.iridescence.texture),mV.iridescence.thicknessTexture&&mV.iridescence.thicknessTexture!==mV.iridescence.texture&&t.push(mV.iridescence.thicknessTexture),t):[]}postExportMaterialAsync(V,h,mV){return new Promise((V=>{if(mV instanceof Kh.e){if(!mV.iridescence.isEnabled)return void V(h);this._wasUsed=!0,h.extensions=h.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(mV.iridescence.texture),L=this._exporter._materialExporter.getTextureInfo(mV.iridescence.thicknessTexture),N={iridescenceFactor:mV.iridescence.Ik,iridescenceIor:mV.iridescence.indexOfRefraction,iridescenceThicknessMinimum:mV.iridescence.minimumThickness,iridescenceThicknessMaximum:mV.iridescence.maximumThickness,iridescenceTexture:t??void 0,iridescenceThicknessTexture:L??void 0};null===N.iridescenceTexture&&null===N.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(mV),h.extensions[Dh]=N}V(h)}))}}iV.RegisterExtension(Dh,(V=>new Hh(V)));const jh="KHR_materials_sheen";class lh{constructor(V){this.name=jh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,h,mV){return mV instanceof RV.c&&mV.sheen.isEnabled&&mV.sheen.texture?[mV.sheen.texture]:[]}async postExportMaterialAsync(V,h,mV){return await new Promise((V=>{if(mV instanceof RV.c){if(!mV.sheen.isEnabled)return void V(h);this._wasUsed=!0,null==h.extensions&&(h.extensions={});const t={sheenColorFactor:mV.sheen.color.sk(),sheenRoughnessFactor:mV.sheen.roughness??0};null===t.sheenColorTexture&&null===t.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(mV),mV.sheen.texture&&(t.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(mV.sheen.texture)??void 0),mV.sheen.textureRoughness&&!mV.sheen.useRoughnessFromMainTexture?t.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(mV.sheen.textureRoughness)??void 0:mV.sheen.texture&&mV.sheen.useRoughnessFromMainTexture&&(t.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(mV.sheen.texture)??void 0),h.extensions[jh]=t}V(h)}))}}iV.RegisterExtension(jh,(V=>new lh(V)));const Gh="KHR_materials_specular";class yh{constructor(V){this.name=Gh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,h,mV){const t=[];return mV instanceof RV.c&&this._isExtensionEnabled(mV)?(mV.metallicReflectanceTexture&&t.push(mV.metallicReflectanceTexture),mV.reflectanceTexture&&t.push(mV.reflectanceTexture),t):t}_isExtensionEnabled(V){return!V.unlit&&(void 0!=V.metallicF0Factor&&1!=V.metallicF0Factor||void 0!=V.metallicReflectanceColor&&!V.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(V))}_hasTexturesExtension(V){return null!=V.metallicReflectanceTexture||null!=V.reflectanceTexture}postExportMaterialAsync(V,h,mV){return new Promise((V=>{if(mV instanceof RV.c&&this._isExtensionEnabled(mV)){this._wasUsed=!0,h.extensions=h.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(mV.metallicReflectanceTexture)??void 0,t=this._exporter._materialExporter.getTextureInfo(mV.reflectanceTexture)??void 0,L={specularFactor:1==mV.metallicF0Factor?void 0:mV.metallicF0Factor,specularTexture:V,specularColorFactor:mV.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:mV.metallicReflectanceColor.sk(),specularColorTexture:t};this._hasTexturesExtension(mV)&&this._exporter._materialNeedsUVsSet.add(mV),h.extensions[Gh]=L}V(h)}))}}iV.RegisterExtension(Gh,(V=>new yh(V)));const Oh="KHR_materials_transmission";class Ih{constructor(V){this.name=Oh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,h,mV){const t=[];return mV instanceof RV.c&&this._isExtensionEnabled(mV)?(mV.subSurface.thicknessTexture&&t.push(mV.subSurface.thicknessTexture),t):t}_isExtensionEnabled(V){if(V.unlit)return!1;const h=V.subSurface;return h.isRefractionEnabled&&void 0!=h.refractionIntensity&&0!=h.refractionIntensity||this._hasTexturesExtension(V)}_hasTexturesExtension(V){return null!=V.subSurface.refractionIntensityTexture}async postExportMaterialAsync(V,h,mV){if(mV instanceof RV.c&&this._isExtensionEnabled(mV)){this._wasUsed=!0;const t=mV.subSurface,L={transmissionFactor:0===t.refractionIntensity?void 0:t.refractionIntensity};if(this._hasTexturesExtension(mV)&&this._exporter._materialNeedsUVsSet.add(mV),t.refractionIntensityTexture)if(t.useGltfStyleTextures){const V=await this._exporter._materialExporter.exportTextureAsync(t.refractionIntensityTexture,"image/png");V&&(L.transmissionTexture=V)}else S.e.Warn(`${V}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);h.extensions||(h.extensions={}),h.extensions[Oh]=L}return h}}iV.RegisterExtension(Oh,(V=>new Ih(V)));const rh="KHR_materials_unlit";class Th{constructor(){this.name=rh,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(V,h,mV){return new Promise((V=>{let t=!1;mV instanceof RV.c?t=mV.unlit:mV instanceof dV.Qh&&(t=mV.disableLighting),t&&(this._wasUsed=!0,null==h.extensions&&(h.extensions={}),h.extensions[rh]={}),V(h)}))}}iV.RegisterExtension(rh,(()=>new Th));const Fh="KHR_materials_volume";class ph{constructor(V){this.name=Fh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,h,mV){const t=[];return mV instanceof RV.c&&this._isExtensionEnabled(mV)?(mV.subSurface.thicknessTexture&&t.push(mV.subSurface.thicknessTexture),t):t}_isExtensionEnabled(V){if(V.unlit)return!1;const h=V.subSurface;return!(!h.isRefractionEnabled&&!h.isTranslucencyEnabled)&&(void 0!=h.maximumThickness&&0!=h.maximumThickness||void 0!=h.tintColorAtDistance&&h.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=h.tintColor&&h.tintColor!=s.Jh.White()||this._hasTexturesExtension(V))}_hasTexturesExtension(V){return null!=V.subSurface.thicknessTexture}postExportMaterialAsync(V,h,mV){return new Promise((V=>{if(mV instanceof RV.c&&this._isExtensionEnabled(mV)){this._wasUsed=!0;const V=mV.subSurface,t={thicknessFactor:0==V.maximumThickness?void 0:V.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(V.thicknessTexture)??void 0,attenuationDistance:V.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:V.tintColorAtDistance,attenuationColor:V.tintColor.equalsFloats(1,1,1)?void 0:V.tintColor.sk()};this._hasTexturesExtension(mV)&&this._exporter._materialNeedsUVsSet.add(mV),h.extensions=h.extensions||{},h.extensions[Fh]=t}V(h)}))}}iV.RegisterExtension(Fh,(V=>new ph(V)));const Zh="EXT_materials_diffuse_roughness";class fh{constructor(V){this.name=Zh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,h,mV){const t=[];return mV instanceof Kh.e&&mV._baseDiffuseRoughness?(mV._baseDiffuseRoughnessTexture&&t.push(mV._baseDiffuseRoughnessTexture),t):[]}postExportMaterialAsync(V,h,mV){return new Promise((V=>{if(mV instanceof Kh.e){if(!mV._baseDiffuseRoughness)return void V(h);this._wasUsed=!0,h.extensions=h.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(mV._baseDiffuseRoughnessTexture),L={diffuseRoughnessFactor:mV._baseDiffuseRoughness,diffuseRoughnessTexture:t??void 0};null!==L.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(mV),h.extensions[Zh]=L}V(h)}))}}iV.RegisterExtension(Zh,(V=>new fh(V)));const Sh="KHR_texture_transform";class Yh{constructor(){this.name=Sh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(V,h,mV){if(mV.DV()||L.Tools.Warn(`${V}: /*@__KEY__*/"scene" is not defined for Babylon texture ${mV.name}!`),(0!==mV.uAng||0!==mV.vAng)&&(L.Tools.Warn(`${V}: Texture ${mV.name} with rotation in the u or v axis is not supported in glTF.`),0!==mV.uRotationCenter||0!==mV.vRotationCenter))return;const t={};let N=!1;if(0===mV.uOffset&&0===mV.vOffset||(t.offset=[mV.uOffset,mV.vOffset],N=!0),1===mV.uScale&&1===mV.vScale||(t.scale=[mV.uScale,mV.vScale],N=!0),0!==mV.wAng){if(0!==mV.uRotationCenter||0!==mV.vRotationCenter){if(mV.homogeneousRotationInUVTransform&&mV.uScale!==mV.vScale)return void L.Tools.Warn(`${V}: Texture ${mV.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Sh}.`);L.Tools.Warn(`${V}: Texture ${mV.name} with non-origin rotation center will be exported using an adjusted offset with ${Sh}.`),t.offset=function(V){const{uOffset:h,vOffset:mV,uRotationCenter:t,vRotationCenter:L,uScale:N,vScale:A,wAng:k}=V,C=Math.cos(k),K=Math.sin(k),o=t*N,n=L*A;return[h+(o*(1-C)+n*K),mV+(n*(1-C)-o*K)]}(mV)}t.rotation=-mV.wAng,N=!0}0!==mV.coordinatesIndex&&(t.texCoord=mV.coordinatesIndex,N=!0),N&&(this._wasUsed=!0,h.extensions||(h.extensions={}),h.extensions[Sh]=t)}}iV.RegisterExtension(Sh,(()=>new Yh));class wh{static CreateSTL(V){let h=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",L=arguments.length>3&&void 0!==arguments[3]&&arguments[3],N=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],A=arguments.length>5&&void 0!==arguments[5]&&arguments[5],k=arguments.length>6&&void 0!==arguments[6]&&arguments[6],C=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const K=function(V,h,mV){const L=[3*V[mV],3*V[mV+1],3*V[mV+2]],N=[new t.sh(h[L[0]],h[L[0]+2],h[L[0]+1]),new t.sh(h[L[1]],h[L[1]+2],h[L[1]+1]),new t.sh(h[L[2]],h[L[2]+2],h[L[2]+1])],A=N[0].Mh(N[1]),k=N[2].Mh(N[1]);return{v:N,n:t.sh.Cross(k,A).normalize()}},n=function(V,h,mV,t){return h=q(V,h,mV.x,t),h=q(V,h,mV.y,t),q(V,h,mV.z,t)},q=function(V,h,mV,t){return V.setFloat32(h,mV,t),h+4},R=function(V){if(k){let h=V;V instanceof x.e&&(h=V.sourceMesh);const mV=h.getVerticesData(o.i.PositionKind,!0,!0);if(!mV)return[];const L=t.sh.Zero();let N;for(N=0;N<mV.length;N+=3)t.sh.TransformCoordinatesFromFloatsToRef(mV[N],mV[N+1],mV[N+2],V.Qk(!0),L).toArray(mV,N);return mV}return V.getVerticesData(o.i.PositionKind)||[]};k&&(A=!0);let d="",s=0,M=0;if(L){for(let mV=0;mV<V.length;mV++){const h=V[mV].vk();s+=h?h.length/3:0}const h=new ArrayBuffer(84+50*s);d=new DataView(h),M+=80,d.setUint32(M,s,N),M+=4}else C||(d="solid stlmesh\r\n");for(let t=0;t<V.length;t++){const h=V[t];!L&&C&&(d+="solid "+h.name+"\r\n"),!A&&h instanceof cV.c&&h.bakeCurrentTransformIntoVertices();const mV=R(h),k=h.vk()||[];for(let V=0;V<k.length;V+=3){const h=K(k,mV,V);L?(M=n(d,M,h.n,N),M=n(d,M,h.v[0],N),M=n(d,M,h.v[1],N),M=n(d,M,h.v[2],N),M+=2):(d+="\tfacet normal "+h.n.x+" "+h.n.y+" "+h.n.z+"\r\n",d+="\t\touter loop\r\n",d+="\t\t\tvertex "+h.v[0].x+" "+h.v[0].y+" "+h.v[0].z+"\r\n",d+="\t\t\tvertex "+h.v[1].x+" "+h.v[1].y+" "+h.v[1].z+"\r\n",d+="\t\t\tvertex "+h.v[2].x+" "+h.v[2].y+" "+h.v[2].z+"\r\n",d+="\t\tendloop\r\n",d+="\tendfacet\r\n")}!L&&C&&(d+="endsolid "+name+"\r\n")}if(L||C||(d+="endsolid stlmesh"),h){const V=document.createElement("a"),h=new Blob([d],{type:"application/octet-stream"});V.href=window.URL.createObjectURL(h),V.download=mV+".stl",V.click()}return d}}function Eh(V,h){let mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const t=[];for(let L=0;L<V.length/mV;L++){const N=V[L*mV],A=V[L*mV+1],k=V[L*mV+2];t.push(`(${N.toPrecision(h.precision)}, ${A.toPrecision(h.precision)}, ${k.toPrecision(h.precision)})`)}return t.join(", ")}function gh(V,h){const mV=[];for(let t=0;t<V.length/2;t++){const L=V[2*t],N=V[2*t+1];mV.push(`(${L.toPrecision(h.precision)}, ${(1-N).toPrecision(h.precision)})`)}return mV.join(", ")}function ih(V,h){const mV=V.getVerticesData(o.i.PositionKind),t=V.getVerticesData(o.i.NormalKind);if(mV&&t)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(V){var h;const mV=null!==(h=V.vk())&&void 0!==h&&h.length?V.getTotalIndices():V.getTotalVertices();return Array(mV/3).fill(3).join(", ")}(V)}]\n\t\tint[] faceVertexIndices = [${function(V){const h=V.vk(),mV=[];if(null!==h)for(let t=0;t<h.length;t++)mV.push(h[t]);else{const h=V.getTotalVertices();for(let V=0;V<h;V++)mV.push(V)}return mV.join(", ")}(V)}]\n\t\tnormal3f[] normals = [${Eh(t,h)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Eh(mV,h)}]\n        ${function(V,h){let mV="";for(let L=0;L<4;L++){const t=L>0?L:"",N=V.getVerticesData(o.i.UVKind+(t?t+1:""));N&&(mV+=`\n\t\ttexCoord2f[] primvars:st${t} = [${gh(N,h)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const t=V.getVerticesData(o.i.ColorKind);return t&&(mV+=`\n\tcolor3f[] primvars:displayColor = [${Eh(t,h,t.length/V.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),mV}(V,h)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function bh(V,h){return`\n        def "Geometry"\n        {\n        ${ih(V,h)}\n        }\n        `}function Ph(V){let h='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return h+=V,fflate.strToU8(h)}function Uh(V){const h=V.m;return`( ${uh(h,0)}, ${uh(h,4)}, ${uh(h,8)}, ${uh(h,12)} )`}function uh(V,h){return`(${V[h+0]}, ${V[h+1]}, ${V[h+2]}, ${V[h+3]})`}function eh(V){const h="Object_"+V.uniqueId,mV=function(V){const h=V.getWorldMatrix().clone(),mV=V.DV().useRightHandedSystem;if(!mV){let t=V.parent;for(;t;){if(AV(t,mV)){h.multiplyToRef(t.getWorldMatrix().invert(),h);break}t=t.parent}}return h.determinant()<0&&L.Tools.Warn(`Exporting mesh ${V.name} with negative scale. Result may look incorrect in destination engine.`),h}(V),t=Uh(mV);return`def Xform "${h}" (\n\tprepend references = @./geometries/Geometry_${V.Jk.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${t}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${V.material.uniqueId}>\n}\n\n`}function Wh(V){switch(V){case D.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case D.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case D.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Xh(V){return`(${V.x}, ${V.y})`}function ah(V){return`(${V.r}, ${V.g}, ${V.b})`}function Bh(V,h,mV,L,N,A){const k=V.getInternalTexture().uniqueId+"_"+V.invertY;N[k]=V;const C=V.coordinatesIndex>0?"st"+V.coordinatesIndex:"st",K=new t.Vector2(V.uScale,V.vScale),o=new t.Vector2(V.uOffset,V.vOffset),n=V.wAng,q=Math.sin(n),x=Math.cos(n);return o.y=1-o.y-K.y,o.x+=q*K.x,o.y+=(1-x)*K.y,`\n    def Shader "PrimvarReader_${mV}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${C}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${mV}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${h.uniqueId}/PrimvarReader_${mV}.outputs:result>\n        float inputs:rotation = ${(n*(180/Math.PI)).toFixed(A.precision)}\n        float2 inputs:scale = ${Xh(K)}\n        float2 inputs:translation = ${Xh(o)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${V.uniqueId}_${mV}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${k}.png@\n        float2 inputs:st.connect = </Materials/Material_${h.uniqueId}/Transform2d_${mV}.outputs:result>\n        ${L?"float4 inputs:scale = "+function(V){return`(${V.r}, ${V.g}, ${V.b}, 1.0)`}(L):""}\n        token inputs:sourceColorSpace = "${V.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Wh(V.wrapU)}"\n        token inputs:wrapT = "${Wh(V.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${h.needAlphaBlending()?"float outputs:a":""}\n    }`}function Vm(V,h,mV){const t="\t\t\t",L=[],N=[],{diffuseMap:A,rk:k,alphaCutOff:C,emissiveMap:K,emissive:o,normalMap:n,roughnessMap:q,roughnessChannel:x,roughness:R,metalnessMap:d,metalnessChannel:M,metalness:c,aoMap:z,aoMapChannel:Q,aoMapIntensity:J,alphaMap:v,ior:D,clearCoatEnabled:H,clearCoat:j,clearCoatMap:l,clearCoatRoughness:G,clearCoatRoughnessMap:y}=function(V){const h={diffuseMap:null,rk:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return V instanceof dV.Qh?{...h,diffuseMap:V.diffuseTexture,rk:V.diffuseColor,alphaCutOff:V.alphaCutOff,emissiveMap:V.emissiveTexture,emissive:V.emissiveColor,roughness:1,alphaMap:V.opacityTexture}:V instanceof Kh.e?{...h,diffuseMap:V._albedoTexture,rk:V._albedoColor,alphaCutOff:V._alphaCutOff,emissiveMap:V._emissiveTexture,emissive:V._emissiveColor,normalMap:V._bumpTexture,roughnessMap:V._metallicTexture,roughnessChannel:V._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:V._roughness??1,metalnessMap:V._metallicTexture,metalnessChannel:V._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:V._metallic??0,aoMap:V._ambientTexture,aoMapChannel:V._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:V._ambientTextureStrength,alphaMap:V._opacityTexture,ior:V.subSurface.indexOfRefraction,clearCoatEnabled:V.clearCoat.isEnabled,clearCoat:V.clearCoat.Ik,clearCoatMap:V.clearCoat.texture,clearCoatRoughness:V.clearCoat.roughness,clearCoatRoughnessMap:V.clearCoat.useRoughnessFromMainTexture?V.clearCoat.texture:V.clearCoat.textureRoughness}:h}(V);return null!==A?(L.push(`${t}color3f inputs:diffuseColor.connect = </Materials/Material_${V.uniqueId}/Texture_${A.uniqueId}_diffuse.outputs:rgb>`),V.needAlphaBlending()?L.push(`${t}float inputs:opacity.connect = </Materials/Material_${V.uniqueId}/Texture_${A.uniqueId}_diffuse.outputs:a>`):V.needAlphaTesting()&&(L.push(`${t}float inputs:opacity.connect = </Materials/Material_${V.uniqueId}/Texture_${A.uniqueId}_diffuse.outputs:a>`),L.push(`${t}float inputs:opacityThreshold = ${C}`)),N.push(Bh(A,V,"diffuse",k,h,mV))):L.push(`${t}color3f inputs:diffuseColor = ${ah(k||s.Jh.White())}`),null!==K?(L.push(`${t}color3f inputs:emissiveColor.connect = </Materials/Material_${V.uniqueId}/Texture_${K.uniqueId}_emissive.outputs:rgb>`),N.push(Bh(K,V,"emissive",o,h,mV))):o&&o.toLuminance()>0&&L.push(`${t}color3f inputs:emissiveColor = ${ah(o)}`),null!==n&&(L.push(`${t}normal3f inputs:normal.connect = </Materials/Material_${V.uniqueId}/Texture_${n.uniqueId}_normal.outputs:rgb>`),N.push(Bh(n,V,"normal",null,h,mV))),null!==z&&(L.push(`${t}float inputs:occlusion.connect = </Materials/Material_${V.uniqueId}/Texture_${z.uniqueId}_occlusion.outputs:${Q}>`),N.push(Bh(z,V,"occlusion",new s.Jh(J,J,J),h,mV))),null!==q?(L.push(`${t}float inputs:roughness.connect = </Materials/Material_${V.uniqueId}/Texture_${q.uniqueId}_roughness.outputs:${x}>`),N.push(Bh(q,V,"roughness",new s.Jh(R,R,R),h,mV))):L.push(`${t}float inputs:roughness = ${R}`),null!==d?(L.push(`${t}float inputs:metallic.connect = </Materials/Material_${V.uniqueId}/Texture_${d.uniqueId}_metallic.outputs:${M}>`),N.push(Bh(d,V,"metallic",new s.Jh(c,c,c),h,mV))):L.push(`${t}float inputs:metallic = ${c}`),null!==v?(L.push(`${t}float inputs:opacity.connect = </Materials/Material_${V.uniqueId}/Texture_${v.uniqueId}_opacity.outputs:r>`),L.push(`${t}float inputs:opacityThreshold = 0.0001`),N.push(Bh(v,V,"opacity",null,h,mV))):L.push(`${t}float inputs:opacity = ${V.alpha}`),H&&(null!==l?(L.push(`${t}float inputs:clearcoat.connect = </Materials/Material_${V.uniqueId}/Texture_${l.uniqueId}_clearcoat.outputs:r>`),N.push(Bh(l,V,"clearcoat",new s.Jh(j,j,j),h,mV))):L.push(`${t}float inputs:clearcoat = ${j}`),null!==y?(L.push(`${t}float inputs:clearcoatRoughness.connect = </Materials/Material_${V.uniqueId}/Texture_${y.uniqueId}_clearcoatRoughness.outputs:g>`),N.push(Bh(y,V,"clearcoatRoughness",new s.Jh(G,G,G),h,mV))):L.push(`${t}float inputs:clearcoatRoughness = ${G}`)),L.push(`${t}float inputs:ior = ${D}`),`\n\tdef Material "Material_${V.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${L.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${V.uniqueId}/PreviewSurface.outputs:surface>\n\n${N.join("\n")}\n\n\t}\n`}async function hm(V,h,mV){const N={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...h};"undefined"===typeof fflate&&await L.Tools.LoadScriptAsync(N.fflateUrl);const A={};A[N.modelFileName]=null;let k='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';k+=function(V){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===V.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${V.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${V.planeAnchoringAlignment}"`:""}\n            `}(N);const C={};for(const t of V.meshes){if(0===t.getTotalVertices())continue;const V=t,h=V.Jk,K=V.material;if(!K||!h||mV&&!mV(V))continue;if(-1!==["Qh","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(K.getClassName())){const mV="geometries/Geometry_"+h.uniqueId+".usda";if(!(mV in A)){const V=bh(h,N);A[mV]=Ph(V)}K.uniqueId in C||(C[K.uniqueId]=K),k+=eh(V)}else L.Tools.Warn("USDZExportAsync does not support this material type: "+K.getClassName())}V.activeCamera&&N.exportCamera&&(k+=function(V,h){const mV="Camera_"+V.uniqueId,L=Uh(t.Matrix.RotationY(Math.PI).multiply(V.getWorldMatrix()));if(V.mode===D.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${mV}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${L}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${V.ck.toPrecision(h.precision)}, ${V.maxZ.toPrecision(h.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(V.orthoLeft||1)+Math.abs(V.orthoRight||1))).toPrecision(h.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(V.orthoTop||1)+Math.abs(V.orthoBottom||1))).toPrecision(h.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const t=V.getEngine().getAspectRatio(V),N=h.cameraSensorWidth||35;return`def Camera "${mV}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${L}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${V.ck.toPrecision(h.precision)}, ${V.maxZ.toPrecision(h.precision)})\n\t\t\tfloat focalLength = ${(N/(2*Math.tan(.5*V.fov))).toPrecision(h.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(N*t).toPrecision(h.precision)}\n\t\t\tfloat verticalAperture = ${(N/t).toPrecision(h.precision)}            \n\t\t}\n\t\n\t`}}(V.activeCamera,N)),k+="\n            }\n        }\n    }";const K={};k+=function(V,h,mV){const t=[];for(const L in V){const N=V[L];t.push(Vm(N,h,mV))}return`\n    def "Materials"\n{\n${t.join("")}\n}\n\n`}(C,K,N),A[N.modelFileName]=fflate.strToU8(k);for(const t in K){const V=K[t],h=V.getSize(),mV=await V.readPixels();if(!mV)throw new Error("Texture data is not available");const L=await H.DumpTools.DumpDataAsync(h.width,h.height,mV,"image/png",void 0,!1,!0);A[`textures/Texture_${t}.png`]=new Uint8Array(L).slice()}let o=0;for(const t in A){const V=A[t];if(!V)continue;o+=34+t.length;const h=63&o;if(4!==h){const mV=new Uint8Array(64-h);A[t]=[V,{extra:{12345:mV}}]}o=V.length}return fflate.zipSync(A,{level:0})}}}]);