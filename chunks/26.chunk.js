"use strict";(self.c2c3ycupenc=self.c2c3ycupenc||[]).push([[26],{12088:(c,r,D)=>{D.r(r),D.d(r,{EXT_materials_diffuse_roughness:()=>dr,EXT_mesh_gpu_instancing:()=>Qc,GLTF2Export:()=>sc,GLTFData:()=>x,KHR_draco_mesh_compression:()=>Dr,KHR_lights_punctual:()=>Hr,KHR_materials_anisotropy:()=>Er,KHR_materials_clearcoat:()=>Yr,KHR_materials_diffuse_transmission:()=>wr,KHR_materials_dispersion:()=>Jr,KHR_materials_emissive_strength:()=>jr,KHR_materials_ior:()=>er,KHR_materials_iridescence:()=>Ur,KHR_materials_sheen:()=>gr,KHR_materials_specular:()=>Sr,KHR_materials_transmission:()=>fr,KHR_materials_unlit:()=>hr,KHR_materials_volume:()=>Pr,KHR_texture_transform:()=>br,OBJExport:()=>u,STLExport:()=>Or,USDZExportAsync:()=>rD,_ConvertToGLTFPBRMetallicRoughness:()=>A,_SolveMetallic:()=>f,__IGLTFExporterExtension:()=>a});var W=D(11683),B=D(11487),t=D(12010);class u{static OBJ(c,r,D,u){const a=[];let H=1,x=1;r&&(D||(D="mat"),a.push("mtllib "+D+".mtl"));for(let M=0;M<c.length;M++){const D=c[M],E=D.name||`mesh${M}}`;a.push(`o ${E}`);let m=null;if(u){const c=D.va(!0);m=new W.Matrix,c.invertToRef(m),D.bakeTransformIntoVertices(c)}if(r){const c=D.material;c&&a.push("usemtl "+c.id)}const Y=D.ka;if(!Y){B.Tools.Warn("No geometry is present on the mesh");continue}const v=Y.getVerticesData("position"),k=Y.getVerticesData("normal"),w=Y.getVerticesData("uv"),Z=Y.wa();let J=0,q=0;if(!v||!Z){B.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const j=c[0].yc().useRightHandedSystem?1:-1;for(let c=0;c<v.length;c+=3)a.push("v "+v[c]*j+" "+v[c+1]+" "+v[c+2]),J++;if(null!=k)for(let c=0;c<k.length;c+=3)a.push("vn "+k[c]*j+" "+k[c+1]+" "+k[c+2]);if(null!=w)for(let c=0;c<w.length;c+=2)a.push("vt "+w[c]+" "+w[c+1]),q++;const X=["","",""],e=(D.material||D.yc().defaultMaterial)._getEffectiveOrientation(D),[y,U]=e===t.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let c=0;c<Z.length;c+=3){const r=[String(Z[c]+H),String(Z[c+y]+H),String(Z[c+U]+H)],D=[String(Z[c]+x),String(Z[c+y]+x),String(Z[c+U]+x)],W=r,B=null!=w?D:X,t=null!=k?r:X;a.push("f "+W[0]+"/"+B[0]+"/"+t[0]+" "+W[1]+"/"+B[1]+"/"+t[1]+" "+W[2]+"/"+B[2]+"/"+t[2])}u&&m&&D.bakeTransformIntoVertices(m),H+=J,x+=q}return a.join("\n")}static MTL(c){const r=[],D=c.material;r.push("newmtl mat1"),r.push("  Ns "+D.specularPower.toFixed(4)),r.push("  Ni 1.5000"),r.push("  d "+D.alpha.toFixed(4)),r.push("  Tr 0.0000"),r.push("  Tf 1.0000 1.0000 1.0000"),r.push("  illum 2"),r.push("  Ka "+D.ambientColor.r.toFixed(4)+" "+D.ambientColor.g.toFixed(4)+" "+D.ambientColor.b.toFixed(4)),r.push("  Kd "+D.diffuseColor.r.toFixed(4)+" "+D.diffuseColor.g.toFixed(4)+" "+D.diffuseColor.b.toFixed(4)),r.push("  Ks "+D.specularColor.r.toFixed(4)+" "+D.specularColor.g.toFixed(4)+" "+D.specularColor.b.toFixed(4)),r.push("  Ke "+D.emissiveColor.r.toFixed(4)+" "+D.emissiveColor.g.toFixed(4)+" "+D.emissiveColor.b.toFixed(4));D.ambientTexture&&r.push("  map_Ka "+D.ambientTexture.name),D.diffuseTexture&&r.push("  map_Kd "+D.diffuseTexture.name),D.specularTexture&&r.push("  map_Ks "+D.specularTexture.name),D.bumpTexture&&r.push("  map_bump -imfchan z "+D.bumpTexture.name),D.opacityTexture&&r.push("  map_d "+D.opacityTexture.name);return r.join("\n")}}var a=0,H=D(11545);class x{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const c in this.files){const r=this.files[c],D=new Blob([r],{type:(0,H.i)(c)});B.Tools.Download(D,c)}}}var M=D(11750),E=D(12096),m=D(12109),Y=D(12129),v=D(11792),k=D(11538),w=D(11722),Z=D(11696);const J=Z.HighestCommonFactor,q={...Z,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:J};var j=D(11907),X=D(11656),e=D(12159),y=D(12166),U=D(11905);const N=1e-6,g=new w.Xr(.04,.04,.04),z=1024,S=w.Xr.White(),K=w.Xr.Black();function f(c,r,D){if(r<g.r)return 0;const W=g.r,B=c*D/(1-g.r)+r-2*g.r,t=B*B-4*W*(g.r-r);return q.Clamp((-B+Math.sqrt(t))/(2*W),0,1)}function A(c){const r=c.diffuseColor.toLinearSpace(c.yc().getEngine().useExactSrgbConversions).scale(.5),D=c.alpha,B=function(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new W.Vector2(0,1),D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new W.Vector2(0,.1),B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new W.Vector2(0,.1),t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new W.Vector2(1300,.1);return function(c,r,D,W,B){return(1-c)*(1-c)*(1-c)*r+3*(1-c)*(1-c)*c*D+3*(1-c)*c*c*W+c*c*c*B}(Math.pow(c/t.x,.333333),r.y,D.y,B.y,t.y)}(q.Clamp(c.specularPower,0,z));return{baseColorFactor:[r.r,r.g,r.b,D],metallicFactor:0,roughnessFactor:B}}function h(c,r){r.needAlphaBlending()?c.alphaMode="BLEND":r.needAlphaTesting()&&(c.alphaMode="MASK",c.alphaCutoff=r.alphaCutOff)}function L(c,r,D){const W=new Uint8Array(c*r*4);for(let B=0;B<W.length;B+=4)W[B]=W[B+1]=W[B+2]=W[B+3]=255;return e.e.CreateRGBATexture(W,c,r,D)}function P(c){if(c instanceof Uint8Array){const r=c.length,D=new Float32Array(c.length);for(let W=0;W<r;++W)D[W]=c[W]/255;return D}if(c instanceof Float32Array)return c;throw new Error("Unsupported pixel format!")}class G{constructor(c){this._exporter=c,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(c){return c?this._textureMap.get(c)??null:null}async exportStandardMaterialAsync(c,r,D){const W=A(c),t={name:c.name};if(null==c.Za||c.Za||(c.twoSidedLighting||B.Tools.Warn(c.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),t.doubleSided=!0),D){const D=[],B=c.diffuseTexture;B&&D.push(this.exportTextureAsync(B,r).then((c=>{c&&(W.baseColorTexture=c)})));const u=c.bumpTexture;u&&D.push(this.exportTextureAsync(u,r).then((c=>{c&&(t.normalTexture=c,1!==u.level&&(t.normalTexture.scale=u.level))})));const a=c.emissiveTexture;a&&(t.emissiveFactor=[1,1,1],D.push(this.exportTextureAsync(a,r).then((c=>{c&&(t.emissiveTexture=c)}))));const H=c.ambientTexture;H&&D.push(this.exportTextureAsync(H,r).then((c=>{if(c){const r={index:c.index};t.occlusionTexture=r}}))),D.length>0&&(this._exporter._materialNeedsUVsSet.add(c),await Promise.all(D))}(c.alpha<1||c.opacityTexture)&&(c.alphaMode===y.e.ALPHA_COMBINE?t.alphaMode="BLEND":B.Tools.Warn(c.name+": glTF 2.0 does not support alpha mode: "+c.alphaMode.toString())),c.emissiveColor&&!c.emissiveColor.equalsWithEpsilon(K,N)&&(t.emissiveFactor=c.emissiveColor.Ma()),t.pbrMetallicRoughness=W,h(t,c),await this._finishMaterialAsync(t,c,r);const u=this._exporter._materials;return u.push(t),u.length-1}async _finishMaterialAsync(c,r,D){const W=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",c,r),B=[];for(const t of W)B.push(this.exportTextureAsync(t,D));await Promise.all(B),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",c,r)}async _getImageDataAsync(c,r,W,B){const t=y.e.TEXTURETYPE_UNSIGNED_BYTE,u=this._exporter._babylonScene,a=u.getEngine(),H=a.createRawTexture(c,r,W,y.e.TEXTUREFORMAT_RGBA,!1,!0,X.b.NEAREST_SAMPLINGMODE,null,t);a.isWebGPU?await D.e(51).then(D.bind(D,14151)):await D.e(52).then(D.bind(D,14155)),await j.m.ApplyPostProcess("pass",H,u,t,y.e.TEXTURE_NEAREST_SAMPLINGMODE,y.e.TEXTUREFORMAT_RGBA);const x=await a._readTexturePixels(H,r,W);return await U.DumpTools.DumpDataAsync(r,W,x,B,void 0,!0,!0)}_resizeTexturesToSameDimensions(c,r,D){const W=c?c.getSize():{width:0,height:0},B=r?r.getSize():{width:0,height:0};let t,u;return W.width<B.width?(t=c&&c instanceof X.b?j.m.CreateResizedCopy(c,B.width,B.height,!0):L(B.width,B.height,D),u=r):W.width>B.width?(u=r&&r instanceof X.b?j.m.CreateResizedCopy(r,W.width,W.height,!0):L(W.width,W.height,D),t=c):(t=c,u=r),{texture1:t,texture2:u}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(c,r,D,W){const B=new Array;if(!c&&!r)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const t=c?c.yc():r?r.yc():null;if(t){var u;const a=this._resizeTexturesToSameDimensions(c,r,t),H=null===(u=a.texture1)||void 0===u?void 0:u.getSize();let x,M;const E=H.width,m=H.height,Y=await a.texture1.readPixels(),v=await a.texture2.readPixels();if(!Y)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(x=P(Y),!v)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");M=P(v);const k=M.byteLength,Z=new Uint8Array(k),J=new Uint8Array(k),q=4,j=K;let X=0,e=0;for(let c=0;c<m;++c)for(let r=0;r<E;++r){const W=(E*c+r)*q,B={diffuseColor:new w.Xr(x[W],x[W+1],x[W+2]).toLinearSpace(t.getEngine().useExactSrgbConversions).multiply(D.diffuseColor),specularColor:new w.Xr(M[W],M[W+1],M[W+2]).toLinearSpace(t.getEngine().useExactSrgbConversions).multiply(D.specularColor),glossiness:M[W+3]*D.glossiness},u=this._convertSpecularGlossinessToMetallicRoughness(B);j.r=Math.max(j.r,u.baseColor.r),j.g=Math.max(j.g,u.baseColor.g),j.b=Math.max(j.b,u.baseColor.b),X=Math.max(X,u.metallic),e=Math.max(e,u.roughness),J[W]=255*u.baseColor.r,J[W+1]=255*u.baseColor.g,J[W+2]=255*u.baseColor.b,J[W+3]=a.texture1.Ea?255*x[W+3]:255,Z[W]=0,Z[W+1]=255*u.roughness,Z[W+2]=255*u.metallic,Z[W+3]=255}const y={baseColor:j,metallic:X,roughness:e};let U=!1,g=!1;for(let c=0;c<m;++c)for(let r=0;r<E;++r){const D=(E*c+r)*q;J[D]/=y.baseColor.r>N?y.baseColor.r:1,J[D+1]/=y.baseColor.g>N?y.baseColor.g:1,J[D+2]/=y.baseColor.b>N?y.baseColor.b:1;const W=w.Xr.FromInts(J[D],J[D+1],J[D+2]).toGammaSpace(t.getEngine().useExactSrgbConversions);J[D]=255*W.r,J[D+1]=255*W.g,J[D+2]=255*W.b,W.equalsWithEpsilon(S,N)||(g=!0),Z[D+1]/=y.roughness>N?y.roughness:1,Z[D+2]/=y.metallic>N?y.metallic:1;w.Xr.FromInts(255,Z[D+1],Z[D+2]).equalsWithEpsilon(S,N)||(U=!0)}return U&&B.push(this._getImageDataAsync(Z,E,m,W).then((c=>{y.metallicRoughnessTextureData=c}))),g&&B.push(this._getImageDataAsync(J,E,m,W).then((c=>{y.baseColorTextureData=c}))),await Promise.all(B).then((()=>y))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(c){const r=this._getPerceivedBrightness(c.diffuseColor),D=this._getPerceivedBrightness(c.specularColor),W=1-this._getMaxComponent(c.specularColor),B=f(r,D,W),t=c.diffuseColor.scale(W/(1-g.r)/Math.max(1-B)),u=c.specularColor.Jr(g.scale(1-B)).scale(1/Math.max(B));let a=w.Xr.Lerp(t,u,B*B);a=a.clampToRef(0,1,a);return{baseColor:a,metallic:B,roughness:1-c.glossiness}}_getPerceivedBrightness(c){return c?Math.sqrt(.299*c.r*c.r+.587*c.g*c.g+.114*c.b*c.b):0}_getMaxComponent(c){return c?Math.max(c.r,Math.max(c.g,c.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(c,r,D,W){const B=[],t={baseColor:c._albedoColor,metallic:c._metallic,roughness:c._roughness};if(W){c._albedoTexture&&B.push(this.exportTextureAsync(c._albedoTexture,r).then((c=>{c&&(D.baseColorTexture=c)})));const W=c._metallicTexture;W&&B.push(this.exportTextureAsync(W,r).then((c=>{c&&(D.metallicRoughnessTexture=c)})))}return B.length>0&&(this._exporter._materialNeedsUVsSet.add(c),await Promise.all(B)),t}_getTextureSampler(c){const r={};if(!c||!(c instanceof X.b))return r;const D=this._getGLTFTextureWrapMode(c.wrapU);10497!==D&&(r.wrapS=D);const W=this._getGLTFTextureWrapMode(c.wrapV);switch(10497!==W&&(r.wrapT=W),c.samplingMode){case X.b.LINEAR_LINEAR:r.magFilter=9729,r.minFilter=9729;break;case X.b.LINEAR_NEAREST:r.magFilter=9729,r.minFilter=9728;break;case X.b.NEAREST_LINEAR:r.magFilter=9728,r.minFilter=9729;break;case X.b.NEAREST_LINEAR_MIPLINEAR:r.magFilter=9728,r.minFilter=9987;break;case X.b.NEAREST_NEAREST:r.magFilter=9728,r.minFilter=9728;break;case X.b.NEAREST_LINEAR_MIPNEAREST:r.magFilter=9728,r.minFilter=9985;break;case X.b.LINEAR_NEAREST_MIPNEAREST:r.magFilter=9729,r.minFilter=9984;break;case X.b.LINEAR_NEAREST_MIPLINEAR:r.magFilter=9729,r.minFilter=9986;break;case X.b.NEAREST_NEAREST_MIPLINEAR:r.magFilter=9728,r.minFilter=9986;break;case X.b.LINEAR_LINEAR_MIPLINEAR:r.magFilter=9729,r.minFilter=9987;break;case X.b.LINEAR_LINEAR_MIPNEAREST:r.magFilter=9729,r.minFilter=9985;break;case X.b.NEAREST_NEAREST_MIPNEAREST:r.magFilter=9728,r.minFilter=9984}return r}_getGLTFTextureWrapMode(c){switch(c){case X.b.WRAP_ADDRESSMODE:return 10497;case X.b.CLAMP_ADDRESSMODE:return 33071;case X.b.MIRROR_ADDRESSMODE:return 33648;default:return B.Tools.Error(`Unsupported Texture Wrap Mode ${c}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(c,r,D,W){const B={diffuseColor:c._albedoColor,specularColor:c._reflectivityColor,glossiness:c._microSurface},t=c._albedoTexture,u=c._reflectivityTexture,a=c._useMicroSurfaceFromReflectivityMapAlpha;if(u&&!a)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((t||u)&&W){this._exporter._materialNeedsUVsSet.add(c);const W=this._exportTextureSampler(t||u),a=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(t,u,B,r),H=this._exporter._textures;if(a.baseColorTextureData){const c=this._exportImage(`baseColor${H.length}`,r,a.baseColorTextureData);D.baseColorTexture=this._exportTextureInfo(c,W,null===t||void 0===t?void 0:t.coordinatesIndex)}if(a.metallicRoughnessTextureData){const c=this._exportImage(`metallicRoughness${H.length}`,r,a.metallicRoughnessTextureData);D.metallicRoughnessTexture=this._exportTextureInfo(c,W,null===u||void 0===u?void 0:u.coordinatesIndex)}return a}return this._convertSpecularGlossinessToMetallicRoughness(B)}async exportPBRMaterialAsync(c,r,D){const W={},B={name:c.name},t=c.isMetallicWorkflow();if(t){const r=c._albedoColor,D=c.alpha;r&&(W.baseColorFactor=[r.r,r.g,r.b,D])}const u=t?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(c,r,W,D):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(c,r,W,D);await this._setMetallicRoughnessPbrMaterialAsync(u,c,B,W,r,D),await this._finishMaterialAsync(B,c,r);const a=this._exporter._materials;return a.push(B),a.length-1}async _setMetallicRoughnessPbrMaterialAsync(c,r,D,W,t,u){if(h(D,r),c.baseColor.equalsWithEpsilon(S,N)&&q.WithinEpsilon(r.alpha,1,N)||(W.baseColorFactor=[c.baseColor.r,c.baseColor.g,c.baseColor.b,r.alpha]),null!=c.metallic&&1!==c.metallic&&(W.metallicFactor=c.metallic),null!=c.roughness&&1!==c.roughness&&(W.roughnessFactor=c.roughness),null==r.Za||r.Za||(r._twoSidedLighting||B.Tools.Warn(r.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),D.doubleSided=!0),u){const c=[],W=r._bumpTexture;W&&c.push(this.exportTextureAsync(W,t).then((c=>{c&&(D.normalTexture=c,1!==W.level&&(D.normalTexture.scale=W.level))})));const B=r._ambientTexture;B&&c.push(this.exportTextureAsync(B,t).then((c=>{if(c){const W={index:c.index,texCoord:c.texCoord,extensions:c.extensions};D.occlusionTexture=W;const B=r._ambientTextureStrength;B&&(W.strength=B)}})));const u=r._emissiveTexture;u&&c.push(this.exportTextureAsync(u,t).then((c=>{c&&(D.emissiveTexture=c)}))),c.length>0&&(this._exporter._materialNeedsUVsSet.add(r),await Promise.all(c))}const a=r._emissiveColor;a.equalsWithEpsilon(K,N)||(D.emissiveFactor=a.Ma()),D.pbrMetallicRoughness=W}_getPixelsFromTextureAsync(c){return function(c){switch(c){case y.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case y.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case y.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case y.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case y.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case y.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case y.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case y.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case y.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case y.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case y.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case y.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case y.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case y.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case y.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case y.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case y.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case y.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case y.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case y.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case y.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(c.textureFormat)?(0,j.j)(c,c._texture.width,c._texture.height):(c.textureType,y.e.TEXTURETYPE_UNSIGNED_BYTE,c.readPixels())}async exportTextureAsync(c,r){const D=this._exporter._extensionsPreExportTextureAsync("exporter",c,r);return D?await D.then((async D=>D?await this._exportTextureInfoAsync(D,r):await this._exportTextureInfoAsync(c,r))):await this._exportTextureInfoAsync(c,r)}async _exportTextureInfoAsync(c,r){let D=this._textureMap.get(c);if(!D){const W=await this._getPixelsFromTextureAsync(c);if(!W)return null;const t=this._exportTextureSampler(c),u=c.mimeType;if(u)switch(u){case"image/jpeg":case"image/png":case"image/webp":r=u;break;default:B.Tools.Warn(`Unsupported media type: ${u}. Exporting texture as PNG.`)}const a=this._internalTextureToImage,H=c.getInternalTexture().uniqueId;a[H]||(a[H]={});let x=a[H][r];if(void 0===x){const D=c.getSize();x=(async()=>{const B=await this._getImageDataAsync(W,D.width,D.height,r);return this._exportImage(c.name,r,B)})(),a[H][r]=x}D=this._exportTextureInfo(await x,t,c.coordinatesIndex),this._textureMap.set(c,D),this._exporter._extensionsPostExportTextures("exporter",D,c)}return D}_exportImage(c,r,D){const W=this._exporter._images;let t;if(this._exporter._shouldUseGlb){t={name:c,mimeType:r,bufferView:void 0};const W=this._exporter._bufferManager.createBufferView(new Uint8Array(D));this._exporter._bufferManager.setBufferView(t,W)}else{const u=c.replace(/\.\/|\/|\.\\|\\/g,"_"),a=function(c){switch(c){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(r);let H=u+a;W.some((c=>c.uri===H))&&(H=`${u}_${B.Tools.RandomId()}${a}`),t={name:c,uri:H},this._exporter._imageData[H]={data:D,mimeType:r}}return W.push(t),W.length-1}_exportTextureInfo(c,r,D){const W=this._exporter._textures;let B=W.findIndex((D=>D.sampler==r&&D.source===c));-1===B&&(B=W.length,W.push({source:c,sampler:r}));const t={index:B};return D&&(t.texCoord=D),t}_exportTextureSampler(c){const r=this._getTextureSampler(c),D=this._exporter._samplers,W=D.findIndex((c=>c.minFilter===r.minFilter&&c.magFilter===r.magFilter&&c.wrapS===r.wrapS&&c.wrapT===r.wrapT));return-1!==W?W:(D.push(r),D.length-1)}}var d=D(11759),T=D(11509),b=D(12169),O=D(11687);const C=W.Zr.Zero(),p=W.Quaternion.Identity(),R=W.Zr.One(),s=new W.Zr(-1,1,1);function o(c,r){const{byteOffset:D,byteStride:W,type:B,normalized:t}=c,u=c.getSize(),a=r.reduce(((c,r)=>r.getTotalVertices()>c?r.getTotalVertices():c),-Number.MAX_VALUE);return{byteOffset:D,byteStride:W,componentCount:u,type:B,count:a*u,normalized:t,totalVertices:a,kind:c.getKind()}}function Q(c){switch(c){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function l(c){switch(c){case M.d.PositionKind:case M.d.NormalKind:case M.d.TangentKind:case M.d.ColorKind:case M.d.MatricesIndicesKind:case M.d.MatricesIndicesExtraKind:case M.d.MatricesWeightsKind:case M.d.MatricesWeightsExtraKind:case M.d.UVKind:case M.d.UV2Kind:case M.d.UV3Kind:case M.d.UV4Kind:case M.d.UV5Kind:case M.d.UV6Kind:return!0}return!1}function F(c){switch(c){case t.c.TriangleFillMode:return 4;case t.c.TriangleStripDrawMode:return 5;case t.c.TriangleFanDrawMode:return 6;case t.c.PointListDrawMode:case t.c.PointFillMode:return 0;case t.c.LineLoopDrawMode:return 2;case t.c.LineListDrawMode:return 1;case t.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${c}`)}function I(c){const r=Math.sqrt(c.x*c.x+c.y*c.y+c.z*c.z);r>0&&(c.x/=r,c.y/=r,c.z/=r)}function i(c){return c.x*=-1,c}function n(c){if(c.x*c.x+c.y*c.y>.5){const r=Math.abs(c.x),D=Math.abs(c.y);if(r>D){const D=Math.sign(c.x);c.x=r,c.y*=-D,c.z*=-D,c.w*=D}else{const r=Math.sign(c.y);c.x*=-r,c.y=D,c.z*=r,c.w*=-r}}else{const r=Math.abs(c.z),D=Math.abs(c.w);if(r>D){const D=Math.sign(c.z);c.x*=-D,c.y*=D,c.z=r,c.w*=-D}else{const r=Math.sign(c.w);c.x*=r,c.y*=-r,c.z*=-r,c.w=D}}return c}function V(c){c.Ja(-c.z,c.w,c.x,-c.y)}function cc(c,r){const D=W.Zr.FromArrayToRef(r.translation||[0,0,0],0,W.TmpVectors.Zr[0]),B=W.Quaternion.FromArrayToRef(r.rotation||[0,0,0,1],0,W.TmpVectors.Quaternion[0]),t=W.Matrix.ComposeToRef(R,B,D,W.TmpVectors.Matrix[0]),u=W.Zr.FromArrayToRef(c.translation||[0,0,0],0,W.TmpVectors.Zr[2]),a=W.Quaternion.FromArrayToRef(c.rotation||[0,0,0,1],0,W.TmpVectors.Quaternion[1]),H=W.Matrix.ComposeToRef(R,a,u,W.TmpVectors.Matrix[1]);t.multiplyToRef(H,H),H.decompose(void 0,B,D),D.equalsWithEpsilon(C,O.c)?delete r.translation:r.translation=D.Ma(),B.equalsWithEpsilon(p,O.c)?delete r.rotation:r.rotation=B.Ma(),r.scale&&delete r.scale}function rc(c,r){if(!(r instanceof E.e))return!1;if(!(1===r.getChildren().length&&0===c.getChildren().length&&c.parent===r))return!1;const D=c.yc(),W=c instanceof b.e&&!D.useRightHandedSystem?s:R;return!!r.qa.equalsWithEpsilon(W,O.c)||(T.e.Warn(`Cannot collapse node ${c.name} into parent node ${r.name} with modified scaling.`),!1)}function Dc(c){if(c instanceof Array){const r=new Float32Array(c);return new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}return ArrayBuffer.isView(c)?new Uint8Array(c.buffer,c.byteOffset,c.byteLength):new Uint8Array(c)}function Wc(c,r){for(const[D,W]of Object.entries(c)){const B=r[D];(Array.isArray(W)&&Array.isArray(B)&&Bc(W,B)||W===B)&&delete c[D]}return c}function Bc(c,r){return c.length===r.length&&c.every(((c,D)=>c===r[D]))}const tc=W.Matrix.Compose(new W.Zr(-1,1,1),W.Quaternion.Identity(),W.Zr.Zero());function uc(c,r){if(!(c instanceof E.e))return!1;if(r){if(!c.getWorldMatrix().equalsWithEpsilon(W.Matrix.IdentityReadOnly,O.c))return!1}else{if(!c.getWorldMatrix().multiplyToRef(tc,W.TmpVectors.Matrix[0]).equalsWithEpsilon(W.Matrix.IdentityReadOnly,O.c))return!1}return!(c instanceof m.d&&c.ka)}const ac=new Map([[Int8Array,(c,r,D)=>c.setInt8(r,D)],[Uint8Array,(c,r,D)=>c.setUint8(r,D)],[Uint8ClampedArray,(c,r,D)=>c.setUint8(r,D)],[Int16Array,(c,r,D)=>c.setInt16(r,D,!0)],[Uint16Array,(c,r,D)=>c.setUint16(r,D,!0)],[Int32Array,(c,r,D)=>c.setInt32(r,D,!0)],[Uint32Array,(c,r,D)=>c.setUint32(r,D,!0)],[Float32Array,(c,r,D)=>c.setFloat32(r,D,!0)],[Float64Array,(c,r,D)=>c.setFloat64(r,D,!0)]]);class Hc{writeTypedArray(c){this._checkGrowBuffer(c.byteLength);const r=ac.get(c.constructor);for(let D=0;D<c.length;D++)r(this._dataView,this._byteOffset,c[D]),this._byteOffset+=c.BYTES_PER_ELEMENT}constructor(c){this._data=new Uint8Array(c),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(c){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,c),this._byteOffset++}writeInt8(c){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,c),this._byteOffset++}writeInt16(c){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,c,!0),this._byteOffset+=2}writeUInt16(c){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,c,!0),this._byteOffset+=2}writeInt32(c){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,c,!0),this._byteOffset+=4}writeUInt32(c){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,c,!0),this._byteOffset+=4}writeFloat32(c){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,c,!0),this._byteOffset+=4}writeFloat64(c){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,c,!0),this._byteOffset+=8}_checkGrowBuffer(c){const r=this.byteOffset+c;if(r>this._data.byteLength){const c=new Uint8Array(2*r);c.set(this._data),this._data=c,this._dataView=new DataView(this._data.buffer)}}}function xc(c){return c%4===0?4:c%2===0?2:1}class Mc{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(c){let r=0;this._bufferViewToData.forEach((c=>{r+=c.byteLength}));const D=new Hc(r),W=Array.from(this._bufferViewToData.keys()).sort(((c,r)=>xc(r.byteLength)-xc(c.byteLength)));for(const B of W){B.byteOffset=D.byteOffset,c.push(B);const r=c.length-1,W=this.getPropertiesWithBufferView(B);for(const c of W)c.bufferView=r;D.writeTypedArray(this._bufferViewToData.get(B)),this._bufferViewToData.delete(B)}return D.getOutputData()}createBufferView(c,r){const D={buffer:0,byteOffset:void 0,byteLength:c.byteLength,byteStride:r};return this._bufferViewToData.set(D,c),D}createAccessor(c,r,D,W,B,t,u){this._verifyBufferView(c);const a={bufferView:void 0,componentType:D,count:W,type:r,min:null===t||void 0===t?void 0:t.min,max:null===t||void 0===t?void 0:t.max,normalized:u,byteOffset:B};return this.setBufferView(a,c),this._accessorToBufferView.set(a,c),a}setBufferView(c,r){this._verifyBufferView(r);this.getPropertiesWithBufferView(r).push(c)}removeBufferView(c){const r=this.getPropertiesWithBufferView(c);for(const D of r)void 0!==D.bufferView&&delete D.bufferView;this._bufferViewToData.delete(c),this._bufferViewToProperties.delete(c),this._accessorToBufferView.forEach(((r,D)=>{r===c&&(void 0!==D.byteOffset&&delete D.byteOffset,this._accessorToBufferView.delete(D))}))}getBufferView(c){const r=this._accessorToBufferView.get(c);return this._verifyBufferView(r),r}getPropertiesWithBufferView(c){return this._verifyBufferView(c),this._bufferViewToProperties.set(c,this._bufferViewToProperties.get(c)??[]),this._bufferViewToProperties.get(c)}getData(c){return this._verifyBufferView(c),this._bufferViewToData.get(c)}_verifyBufferView(c){if(void 0===c||!this._bufferViewToData.has(c))throw new Error(`BufferView ${c} not found in BufferManager.`)}}var Ec,mc=D(12143),Yc=D(12157),vc=D(12172),kc=D(12055),wc=D(12202),Zc=D(12215),Jc=D(12135),qc=D(12218);!function(c){c[c.INTANGENT=0]="INTANGENT",c[c.OUTTANGENT=1]="OUTTANGENT"}(Ec||(Ec={}));class jc{static _IsTransformable(c){return c&&(c instanceof E.e||c instanceof mc.d||c instanceof qc.b)}static _CreateNodeAnimation(c,r,D,W,t){if(this._IsTransformable(c)){const u=[],a=[],H=r.getKeys(),x=jc._CalculateMinMaxKeyFrames(H),M=jc._DeduceInterpolation(H,D,W),E=M.interpolationType,m=M.shouldBakeAnimation;if(m?jc._CreateBakedAnimation(c,r,D,x.min,x.max,r.framePerSecond,t,u,a,x,W):"LINEAR"===E||"STEP"===E?jc._CreateLinearOrStepAnimation(c,r,D,u,a,W):"CUBICSPLINE"===E?jc._CreateCubicSplineAnimation(c,r,D,u,a,W):jc._CreateBakedAnimation(c,r,D,x.min,x.max,r.framePerSecond,t,u,a,x,W),u.length&&a.length){return{inputs:u,outputs:a,samplerInterpolation:E,inputsMin:m?x.min:B.Tools.FloatRound(x.min/r.framePerSecond),inputsMax:m?x.max:B.Tools.FloatRound(x.max/r.framePerSecond)}}}return null}static _DeduceAnimationInfo(c){let r=null,D="VEC3",W=!1;const t=c.targetProperty.split(".");switch(t[0]){case"qa":r="scale";break;case"position":r="translation";break;case"rotation":D="VEC4",r="rotation";break;case"rotationQuaternion":D="VEC4",W=!0,r="rotation";break;case"influence":D="SCALAR",r="weights";break;default:B.Tools.Error(`Unsupported animatable property ${t[0]}`)}return r?{animationChannelTargetPath:r,dataAccessorType:D,useQuaternion:W}:(B.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(c,r,D,W,B,t,u,a,H,x,M){let E;if(jc._IsTransformable(c)&&c.animations)for(const m of c.animations){if(M&&!M(m))continue;const B=jc._DeduceAnimationInfo(m);B&&(E={name:m.name,samplers:[],channels:[]},jc._AddAnimation(`${m.name}`,m.hasRunningRuntimeAnimations?r:E,c,m,B.dataAccessorType,B.animationChannelTargetPath,W,t,u,a,B.useQuaternion,H,x),E.samplers.length&&E.channels.length&&D.push(E))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(c,r,D,W,B,t,u,a,H,x,M){let E;if(c instanceof Jc.e){const B=c.morphTargetManager;if(B)for(let m=0;m<B.numTargets;++m){const Y=B.getTarget(m);for(const v of Y.animations){if(M&&!M(v))continue;const Y=new wc.b(`${v.name}`,"influence",v.framePerSecond,v.dataType,v.loopMode,v.enableBlending),k=[],w=v.getKeys();for(let c=0;c<w.length;++c){const r=w[c];for(let c=0;c<B.numTargets;++c)c==m?k.push(r):k.push({frame:r.frame,value:0})}Y.setKeys(k);const Z=jc._DeduceAnimationInfo(Y);Z&&(E={name:Y.name,samplers:[],channels:[]},jc._AddAnimation(v.name,v.hasRunningRuntimeAnimations?r:E,c,Y,Z.dataAccessorType,Z.animationChannelTargetPath,W,t,u,a,Z.useQuaternion,H,x,B.numTargets),E.samplers.length&&E.channels.length&&D.push(E))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(c,r,D,W,B,t,u,a,H){let x;if(c.animationGroups){const E=c.animationGroups;for(const m of E){const E=new Map,Y=new Map,v=new Set,k=m.to-m.from;x={name:m.name,channels:[],samplers:[]};for(let r=0;r<m.targetedAnimations.length;++r){const k=m.targetedAnimations[r],w=k.target,Z=k.animation;if(H&&!H(Z))continue;const J=a.has(w);if(this._IsTransformable(w)||1===w.length&&this._IsTransformable(w[0])){const c=jc._DeduceAnimationInfo(k.animation);if(c){const r=this._IsTransformable(w)?w:this._IsTransformable(w[0])?w[0]:null;r&&jc._AddAnimation(`${Z.name}`,x,r,Z,c.dataAccessorType,c.animationChannelTargetPath,D,W,B,t,c.useQuaternion,u,J)}}else if(w instanceof Zc.e||1===w.length&&w[0]instanceof Zc.e){if(jc._DeduceAnimationInfo(k.animation)){const r=w instanceof Zc.e?w:w[0];if(r){const D=c.morphTargetManagers.find((c=>{for(let D=0;D<c.numTargets;++D)if(c.getTarget(D)===r)return!0;return!1}));if(D){const W=c.meshes.find((c=>c.morphTargetManager===D));var M;if(W)E.has(W)||E.set(W,new Map),null===(M=E.get(W))||void 0===M||M.set(r,Z),v.add(W),Y.set(W,Z)}}}}}v.forEach((c=>{const r=c.morphTargetManager;let a=null;const H=[],M=Y.get(c).getKeys(),v=M.length;for(let D=0;D<v;++D)for(let W=0;W<r.numTargets;++W){const B=r.getTarget(W),t=E.get(c);if(t){const r=t.get(B);r?(a||(a=new wc.b(`${m.name}_${c.name}_MorphWeightAnimation`,"influence",r.framePerSecond,wc.b.ANIMATIONTYPE_FLOAT,r.loopMode,r.enableBlending)),H.push(r.getKeys()[D])):H.push({frame:m.from+k/v*D,value:B.influence,inTangent:M[0].inTangent?0:void 0,outTangent:M[0].outTangent?0:void 0})}}a.setKeys(H);const w=jc._DeduceAnimationInfo(a);w&&jc._AddAnimation(`${m.name}_${c.name}_MorphWeightAnimation`,x,c,a,w.dataAccessorType,w.animationChannelTargetPath,D,W,B,t,w.useQuaternion,u,!1,null===r||void 0===r?void 0:r.numTargets)})),x.channels.length&&x.samplers.length&&r.push(x)}}}static _AddAnimation(c,r,D,B,t,u,a,H,x,M,E,m,Y,v){const k=jc._CreateNodeAnimation(D,B,u,E,m);let w,Z,J,q,j,X;if(k){if(v){let c=0,r=0;const D=[];for(;k.inputs.length>0;)r=k.inputs.shift(),c%v==0&&D.push(r),c++;k.inputs=D}const c=a.get(D),B=new Float32Array(k.inputs);w=H.createBufferView(B),Z=H.createAccessor(w,"SCALAR",5126,k.inputs.length,void 0,{min:[k.inputsMin],max:[k.inputsMax]}),M.push(Z),J=M.length-1;const x=new W.Quaternion,E=new W.Zr,m=new W.Zr,e=D instanceof mc.d,y=Q(t),U=new Float32Array(k.outputs.length*y);k.outputs.forEach((function(c,r){let D=c;switch(u){case"translation":Y&&(W.Zr.FromArrayToRef(c,0,m),i(m),m.toArray(D));break;case"rotation":4===c.length?W.Quaternion.FromArrayToRef(c,0,x):(D=new Array(4),W.Zr.FromArrayToRef(c,0,E),W.Quaternion.FromEulerVectorToRef(E,x)),Y&&(n(x),e&&V(x)),x.toArray(D)}U.set(D,r*y)})),w=H.createBufferView(U),Z=H.createAccessor(w,t,5126,k.outputs.length),M.push(Z),q=M.length-1,j={interpolation:k.samplerInterpolation,input:J,output:q},r.samplers.push(j),X={sampler:r.samplers.length-1,target:{node:c,path:u}},r.channels.push(X)}}static _CreateBakedAnimation(c,r,D,t,u,a,H,x,M,E,m){let Y;const v=W.Quaternion.Identity();let k,w=null,Z=null,J=null,q=null,j=null,X=null;E.min=B.Tools.FloatRound(t/a);const e=r.getKeys();for(let W=0,y=e.length;W<y;++W){if(X=null,J=e[W],W+1<y)if(q=e[W+1],J.value.equals&&J.value.equals(q.value)||J.value===q.value){if(0!==W)continue;X=J.frame}else X=q.frame;else{if(j=e[W-1],J.value.equals&&J.value.equals(j.value)||J.value===j.value)continue;X=u}if(X)for(let W=J.frame;W<=X;W+=H){if(k=B.Tools.FloatRound(W/a),k===w)continue;w=k,Z=k;const t={key:0,repeatCount:0,loopMode:r.loopMode};Y=r._interpolate(W,t),jc._SetInterpolatedValue(c,Y,k,r,D,v,x,M,m)}}Z&&(E.max=Z)}static _ConvertFactorToVector3OrQuaternion(c,r,D,t,u){const a=jc._GetBasePositionRotationOrScale(r,t,u),H=D.targetProperty.split("."),x=H?H[1]:"",M=u?W.Quaternion.er(a).normalize():W.Zr.er(a);switch(x){case"x":case"y":case"z":M[x]=c;break;case"w":M.w=c;break;default:B.Tools.Error(`glTFAnimation: Unsupported component name "${x}"!`)}return M}static _SetInterpolatedValue(c,r,D,B,t,u,a,H,x){let M;a.push(D),"weights"!==t?(B.dataType===wc.b.ANIMATIONTYPE_FLOAT&&(r=this._ConvertFactorToVector3OrQuaternion(r,c,B,t,x)),"rotation"===t?(x?u=r:(M=r,W.Quaternion.RotationYawPitchRollToRef(M.y,M.x,M.z,u)),H.push(u.Ma())):(M=r,H.push(M.Ma()))):H.push([r])}static _CreateLinearOrStepAnimation(c,r,D,W,B,t){for(const u of r.getKeys())W.push(u.frame/r.framePerSecond),jc._AddKeyframeValue(u,r,B,D,c,t)}static _CreateCubicSplineAnimation(c,r,D,W,B,t){r.getKeys().forEach((function(u){W.push(u.frame/r.framePerSecond),jc._AddSplineTangent(Ec.INTANGENT,B,D,"CUBICSPLINE",u,t),jc._AddKeyframeValue(u,r,B,D,c,t),jc._AddSplineTangent(Ec.OUTTANGENT,B,D,"CUBICSPLINE",u,t)}))}static _GetBasePositionRotationOrScale(c,r,D){let B;if("rotation"===r)if(D){B=(c.rotationQuaternion??W.Quaternion.Identity()).Ma()}else{B=(c.rotation??W.Zr.Zero()).Ma()}else if("translation"===r){B=(c.position??W.Zr.Zero()).Ma()}else{B=(c.qa??W.Zr.One()).Ma()}return B}static _AddKeyframeValue(c,r,D,t,u,a){let H;const x=r.dataType;if(x===wc.b.ANIMATIONTYPE_VECTOR3){let r=c.value.Ma();if("rotation"===t){const c=W.Zr.er(r);r=W.Quaternion.RotationYawPitchRoll(c.y,c.x,c.z).Ma()}D.push(r)}else if(x===wc.b.ANIMATIONTYPE_FLOAT){if("weights"===t)D.push([c.value]);else if(H=this._ConvertFactorToVector3OrQuaternion(c.value,u,r,t,a),H){if("rotation"===t){const c=a?H:W.Quaternion.RotationYawPitchRoll(H.y,H.x,H.z).normalize();D.push(c.Ma())}D.push(H.Ma())}}else x===wc.b.ANIMATIONTYPE_QUATERNION?D.push(c.value.normalize().Ma()):B.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(c,r,D){let W,B,t=!1;if("rotation"===r&&!D)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let u=0,a=c.length;u<a;++u)if(B=c[u],B.inTangent||B.outTangent)if(W){if("CUBICSPLINE"!==W){W="LINEAR",t=!0;break}}else W="CUBICSPLINE";else if(W){if("CUBICSPLINE"===W||B.interpolation&&1===B.interpolation&&"STEP"!==W){W="LINEAR",t=!0;break}}else W=B.interpolation&&1===B.interpolation?"STEP":"LINEAR";return W||(W="LINEAR"),{interpolationType:W,shouldBakeAnimation:t}}static _AddSplineTangent(c,r,D,B,t,u){let a;const H=c===Ec.INTANGENT?t.inTangent:t.outTangent;if("CUBICSPLINE"===B){if("rotation"===D)if(H)if(u)a=H.Ma();else{const c=H;a=W.Quaternion.RotationYawPitchRoll(c.y,c.x,c.z).Ma()}else a=[0,0,0,0];else a="weights"===D?H?[H]:[0]:H?H.Ma():[0,0,0];r.push(a)}}static _CalculateMinMaxKeyFrames(c){let r=1/0,D=-1/0;return c.forEach((function(c){r=Math.min(r,c.frame),D=Math.max(D,c.frame)})),{min:r,max:D}}}function Xc(c,r,D,t,u,a){const H={attributes:{},influence:c.influence,name:c.name},x=r.ka;if(!x)return B.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),H;const E=a?-1:1,m=W.Zr.Zero();let Y=0,v=0;if(c.hasPositions){const t=c.getPositions(),a=x.getVerticesData(M.d.PositionKind);if(a){const c=new Float32Array(a.length),r=[1/0,1/0,1/0],B=[-1/0,-1/0,-1/0];v=a.length/3,Y=0;for(let D=Y;D<v;++D){const u=W.Zr.er(a,3*D);W.Zr.er(t,3*D).subtractToRef(u,m),m.x*=E,r[0]=Math.min(r[0],m.x),B[0]=Math.max(B[0],m.x),r[1]=Math.min(r[1],m.y),B[1]=Math.max(B[1],m.y),r[2]=Math.min(r[2],m.z),B[2]=Math.max(B[2],m.z),c[3*D]=m.x,c[3*D+1]=m.y,c[3*D+2]=m.z}const x=D.createBufferView(c,12),M=D.createAccessor(x,"VEC3",5126,t.length/3,0,{min:r,max:B});u.push(M),H.attributes.POSITION=u.length-1}else B.Tools.Warn(`Morph target positions for mesh ${r.name} were not exported. Mesh does not have position vertex data`)}if(c.hasNormals){const t=c.getNormals(),a=x.getVerticesData(M.d.NormalKind);if(a){const c=new Float32Array(a.length);v=a.length/3,Y=0;for(let D=Y;D<v;++D){const r=W.Zr.er(a,3*D).normalize();W.Zr.er(t,3*D).normalize().subtractToRef(r,m),c[3*D]=m.x*E,c[3*D+1]=m.y,c[3*D+2]=m.z}const r=D.createBufferView(c,12),B=D.createAccessor(r,"VEC3",5126,t.length/3,0);u.push(B),H.attributes.NORMAL=u.length-1}else B.Tools.Warn(`Morph target normals for mesh ${r.name} were not exported. Mesh does not have normals vertex data`)}if(c.hasTangents){const t=c.getTangents(),a=x.getVerticesData(M.d.TangentKind);if(a){v=a.length/4;const c=new Float32Array(3*v);Y=0;for(let D=Y;D<v;++D){const r=W.Zr.er(a,4*D);I(r);const B=W.Zr.er(t,3*D);I(B),B.subtractToRef(r,m),c[3*D]=m.x*E,c[3*D+1]=m.y,c[3*D+2]=m.z}const r=D.createBufferView(c,12),B=D.createAccessor(r,"VEC3",5126,v,0);u.push(B),H.attributes.TANGENT=u.length-1}else B.Tools.Warn(`Morph target tangents for mesh ${r.name} were not exported. Mesh does not have tangents vertex data`)}if(c.hasColors){const t=c.getColors(),a=x.getVerticesData(M.d.ColorKind),E=x.getVertexBuffer(M.d.ColorKind);if(a&&E){const c=E.getSize();v=a.length/c;const r=new Float32Array(v*c);Y=0;for(let D=Y;D<v;++D)if(3===c){const B=W.Zr.er(a,D*c);W.Zr.er(t,D*c).subtractToRef(B,m),r[3*D]=m.x,r[3*D+1]=m.y,r[3*D+2]=m.z}else if(4===c){const B=new W.Vector4,u=W.Vector4.er(a,D*c);W.Vector4.er(t,D*c).subtractToRef(u,B),r[4*D]=B.x,r[4*D+1]=B.y,r[4*D+2]=B.z,r[4*D+3]=B.w}else B.Tools.Warn(`Unsupported number of components for color attribute: ${c}`);const x=D.createBufferView(r,4*c),M=D.createAccessor(x,3===c?"VEC3":"VEC4",5126,v,0);u.push(M),H.attributes.COLOR_0=u.length-1}else B.Tools.Warn(`Morph target colors for mesh ${r.name} were not exported. Mesh does not have colors vertex data`)}return H}var ec=D(12222),yc=D(12076),Uc=D(12061),Nc=D(11637);class gc{}gc.DEFAULT_COLOR=w.Xr.White(),gc.DEFAULT_WIDTH_ATTENUATED=1,gc.DEFAULT_WIDTH=.1;var zc=D(11899),Sc=D(12224);class Kc{static ConvertPoints(c,r){if(c.length&&Array.isArray(c)&&"number"===typeof c[0])return[c];if(c.length&&Array.isArray(c[0])&&"number"===typeof c[0][0])return c;if(c.length&&!Array.isArray(c[0])&&c[0]instanceof W.Zr){const r=[];for(let D=0;D<c.length;D++){const W=c[D];r.push(W.x,W.y,W.z)}return[r]}if(c.length>0&&Array.isArray(c[0])&&c[0].length>0&&c[0][0]instanceof W.Zr){const r=[],D=c;for(const c of D)r.push(c.flatMap((c=>[c.x,c.y,c.z])));return r}if(c instanceof Float32Array){if(null!==r&&void 0!==r&&r.floatArrayStride){const D=[],W=3*r.floatArrayStride;for(let r=0;r<c.length;r+=W){const B=new Array(W);for(let D=0;D<W;D++)B[D]=c[r+D];D.push(B)}return D}return[Array.from(c)]}if(c.length&&c[0]instanceof Float32Array){const r=[];for(const D of c)r.push(Array.from(D));return r}return[]}static OmitZeroLengthPredicate(c,r,D){const W=[];return r.Jr(c).lengthSquared()>0&&W.push([c,r]),D.Jr(r).lengthSquared()>0&&W.push([r,D]),c.Jr(D).lengthSquared()>0&&W.push([D,c]),0===W.length?null:W}static OmitDuplicatesPredicate(c,r,D,W){const B=[];return Kc._SearchInPoints(c,r,W)||B.push([c,r]),Kc._SearchInPoints(r,D,W)||B.push([r,D]),Kc._SearchInPoints(D,c,W)||B.push([D,c]),0===B.length?null:B}static _SearchInPoints(c,r,D){for(const u of D)for(let D=0;D<u.length;D++){var W,B,t;if(null!==(W=u[D])&&void 0!==W&&W.equals(c))if(null!==(B=u[D+1])&&void 0!==B&&B.equals(r)||null!==(t=u[D-1])&&void 0!==t&&t.equals(r))return!0}return!1}static MeshesToLines(c,r){const D=[];for(let B=0;B<c.length;B++){const t=c[B],u=t.getVerticesData(M.d.PositionKind),a=t.wa();if(u&&a)for(let c=0,H=0;c<a.length;c++){const x=3*a[H++],M=3*a[H++],E=3*a[H++],m=new W.Zr(u[x],u[x+1],u[x+2]),Y=new W.Zr(u[M],u[M+1],u[M+2]),v=new W.Zr(u[E],u[E+1],u[E+2]);if(r){const W=r(m,Y,v,D,c,x,t,B,u,a);if(W)for(const c of W)D.push(c)}else D.push([m,Y],[Y,v],[v,m])}}return D}static ToVector3Array(c){if(Array.isArray(c[0])){const r=[],D=c;for(const c of D){const D=[];for(let r=0;r<c.length;r+=3)D.push(new W.Zr(c[r],c[r+1],c[r+2]));r.push(D)}return r}const r=c,D=[];for(let B=0;B<r.length;B+=3)D.push(new W.Zr(r[B],r[B+1],r[B+2]));return D}static ToNumberArray(c){return c.flatMap((c=>[c.x,c.y,c.z]))}static GetPointsCountInfo(c){const r=new Array(c.length);let D=0;for(let W=c.length;W--;)r[W]=c[W].length/3,D+=r[W];return{total:D,counts:r}}static GetLineLength(c){if(0===c.length)return 0;let r;r="number"===typeof c[0]?Kc.ToVector3Array(c):c;const D=W.TmpVectors.Zr[0];let B=0;for(let W=0;W<r.length-1;W++){const c=r[W];B+=r[W+1].subtractToRef(c,D).length()}return B}static GetLineLengthArray(c){const r=new Float32Array(c.length/3);let D=0;for(let W=0,B=c.length/3-1;W<B;W++){let B=c[3*W+0],t=c[3*W+1],u=c[3*W+2];B-=c[3*W+3],t-=c[3*W+4],u-=c[3*W+5];D+=Math.sqrt(B*B+t*t+u*u),r[W+1]=D}return r}static SegmentizeSegmentByCount(c,r,D){const B=[],t=r.Jr(c),u=W.TmpVectors.Zr[0];u.ja(D);const a=W.TmpVectors.Zr[1];t.divideToRef(u,a);let H=c.clone();B.push(H);for(let W=0;W<D;W++)H=H.clone(),B.push(H.addInPlace(a));return B}static SegmentizeLineBySegmentLength(c,r){const D=c[0]instanceof W.Zr?Kc.GetLineSegments(c):"number"===typeof c[0]?Kc.GetLineSegments(Kc.ToVector3Array(c)):c,B=[];for(const W of D)if(W.length>r){const c=Kc.SegmentizeSegmentByCount(W.point1,W.point2,Math.ceil(W.length/r));for(const r of c)B.push(r)}else B.push(W.point1),B.push(W.point2);return B}static SegmentizeLineBySegmentCount(c,r){const D="number"===typeof c[0]?Kc.ToVector3Array(c):c,W=Kc.GetLineLength(D)/r;return Kc.SegmentizeLineBySegmentLength(D,W)}static GetLineSegments(c){const r=[];for(let D=0;D<c.length-1;D++){const W=c[D],B=c[D+1],t=B.Jr(W).length();r.push({point1:W,point2:B,length:t})}return r}static GetMinMaxSegmentLength(c){const r=Kc.GetLineSegments(c).sort((c=>c.length));return{min:r[0].length,max:r[r.length-1].length}}static GetPositionOnLineByVisibility(c,r,D){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const t=r*D;let u=0,a=0;const H=c.length;for(let W=0;W<H;W++){if(t<=u+c[W].length){a=W;break}u+=c[W].length}const x=(t-u)/c[a].length;return c[a].point2.subtractToRef(c[a].point1,W.TmpVectors.Zr[0]),W.TmpVectors.Zr[1]=W.TmpVectors.Zr[0].multiplyByFloats(x,x,x),B||W.TmpVectors.Zr[1].addInPlace(c[a].point1),W.TmpVectors.Zr[1].clone()}static GetCircleLinePoints(c,r){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c,t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/r;const u=[];for(let a=0;a<=r;a++)u.push(new W.Zr(Math.cos(a*t)*c,Math.sin(a*t)*B,D));return u}static GetBezierLinePoints(c,r,D,W){return zc.d.CreateQuadraticBezier(c,r,D,W).getPoints().flatMap((c=>[c.x,c.y,c.z]))}static GetArrowCap(c,r,D,W,B){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,u=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[c.clone(),c.add(r.multiplyByFloats(D,D,D))],widths:[W,B,t,u]}}static GetPointsFromText(c,r,D,W){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const u=[],a=(0,Sc.d)(c,r,D,W);for(const H of a){for(const c of H.paths){const r=[],D=c.getPoints();for(const c of D)r.push(c.x,c.y,B);u.push(r)}if(t)for(const c of H.holes){const r=[],D=c.getPoints();for(const c of D)r.push(c.x,c.y,B);u.push(r)}}return u}static Color3toRGBAUint8(c){const r=new Uint8Array(4*c.length);for(let D=0,W=0;D<c.length;D++)r[W++]=255*c[D].r,r[W++]=255*c[D].g,r[W++]=255*c[D].b,r[W++]=255;return r}static CreateColorsTexture(c,r,D,W){const B=W.getEngine().getCaps().maxTextureSize??1,t=r.length>B?B:r.length,u=Math.ceil(r.length/B);u>1&&(r=[...r,...Array(t*u-r.length).fill(r[0])]);const a=Kc.Color3toRGBAUint8(r),H=new e.e(a,t,u,v.b.TEXTUREFORMAT_RGBA,W,!1,!0,D);return H.name=c,H}static PrepareEmptyColorsTexture(c){if(!gc.EmptyColorsTexture){const r=new Uint8Array(4);gc.EmptyColorsTexture=new e.e(r,1,1,v.b.TEXTUREFORMAT_RGBA,c,!1,!1,e.e.NEAREST_NEAREST),gc.EmptyColorsTexture.name="grlEmptyColorsTexture"}return gc.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var c;null===(c=gc.EmptyColorsTexture)||void 0===c||c.dispose(),gc.EmptyColorsTexture=null}static BooleanToNumber(c){return c?1:0}}class fc extends Uc.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Ac extends yc.c{isCompatible(c){return!0}constructor(c,r,D){var B;D=D||{color:gc.DEFAULT_COLOR};const t=new fc;t.GREASED_LINE_HAS_COLOR=!!D.color&&!D.useColors,t.GREASED_LINE_SIZE_ATTENUATION=D.sizeAttenuation??!1,t.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===D.colorDistributionType,t.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(r??c.yc()).useRightHandedSystem,t.GREASED_LINE_CAMERA_FACING=D.cameraFacing??!0,super(c,Ac.GREASED_LINE_MATERIAL_NAME,200,t,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(B=D)||void 0===B?void 0:B.forceGLSL)||Ac.ForceGLSL,this._scene=r??c.yc(),this._engine=this._scene.getEngine(),this._cameraFacing=D.cameraFacing??!0,this.visibility=D.visibility??1,this.useDash=D.useDash??!1,this.dashRatio=D.dashRatio??.5,this.dashOffset=D.dashOffset??0,this.width=D.width?D.width:D.sizeAttenuation?gc.DEFAULT_WIDTH_ATTENUATED:gc.DEFAULT_WIDTH,this._sizeAttenuation=D.sizeAttenuation??!1,this.colorMode=D.colorMode??0,this._color=D.color??null,this.useColors=D.useColors??!1,this._colorsDistributionType=D.colorDistributionType??0,this.colorsSampling=D.colorsSampling??e.e.NEAREST_NEAREST,this._colors=D.zc??null,this.dashCount=D.dashCount??1,this.resolution=D.resolution??new W.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),D.colorsTexture?this.colorsTexture=D.colorsTexture:this._colors?this.colorsTexture=Kc.CreateColorsTexture(`${c.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??gc.DEFAULT_COLOR,Kc.PrepareEmptyColorsTexture(this._scene)),this._engine.Wa.add((()=>{Kc.DisposeEmptyColorsTexture()}))}getAttributes(c){c.push("grl_offsets"),c.push("grl_widths"),c.push("grl_colorPointers"),c.push("grl_counters"),this._cameraFacing?(c.push("grl_previousAndSide"),c.push("grl_nextAndCounters")):c.push("grl_slopes")}getSamplers(c){c.push("grl_colors")}getActiveTextures(c){this.colorsTexture&&c.push(this.colorsTexture)}getUniforms(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const r=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&r.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===c&&r.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:r,vertex:this._cameraFacing&&this._isGLSL(c)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(c)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(c){if(this._cameraFacing){c.Ya("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||c.Ya("viewProjection",this._scene.getTransformMatrix());const r=W.TmpVectors.Vector4[0];r.x=this._aspect,r.y=this._resolution.x,r.z=this._resolution.y,r.w=this.width,c.updateVector4("grl_aspect_resolution_lineWidth",r)}const r=W.TmpVectors.Vector4[0];r.x=Kc.BooleanToNumber(this.useDash),r.y=this._dashArray,r.z=this.dashOffset,r.w=this.dashRatio,c.updateVector4("grl_dashOptions",r);const D=W.TmpVectors.Vector4[1];D.x=this.colorMode,D.y=this.visibility,D.z=this.colorsTexture?this.colorsTexture.getSize().width:0,D.w=Kc.BooleanToNumber(this.useColors),c.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",D),this._color&&c.updateColor3("grl_singleColor",this._color);const B=this.colorsTexture??gc.EmptyColorsTexture;c.setTexture("grl_colors",B),c.updateFloat2("grl_textureSize",(null===B||void 0===B?void 0:B.getSize().width)??1,(null===B||void 0===B?void 0:B.getSize().height)??1)}prepareDefines(c,r,D){c.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,c.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,c.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,c.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=r.useRightHandedSystem,c.GREASED_LINE_CAMERA_FACING=this._cameraFacing,c.GREASED_LINE_USE_OFFSETS=!!D.offsets}getClassName(){return Ac.GREASED_LINE_MATERIAL_NAME}getCustomCode(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(r)?function(c,r){if("vertex"===c){const c={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return r&&(c["!gl_Position\\=viewProjection\\*worldPos;"]="//"),c}return"fragment"===c?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(c,this._cameraFacing):function(c,r){if("vertex"===c){const c={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return r&&(c["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),c}return"fragment"===c?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(c,this._cameraFacing)}dispose(){var c;null===(c=this.colorsTexture)||void 0===c||c.dispose(),super.dispose()}get zc(){return this._colors}set zc(c){this.setColors(c)}setColors(c){var r;let D=arguments.length>1&&void 0!==arguments[1]&&arguments[1],W=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=(null===(r=this._colors)||void 0===r?void 0:r.length)??0;var t;if(this._colors=c,null!==c&&0!==c.length){if(!D||W)if(this.colorsTexture&&B===c.length&&!W){const r=Kc.Color3toRGBAUint8(c);this.colorsTexture.update(r)}else{var u;null===(u=this.colorsTexture)||void 0===u||u.dispose(),this.colorsTexture=Kc.CreateColorsTexture(`${this._material.name}-colors-texture`,c,this.colorsSampling,this._scene)}}else null===(t=this.colorsTexture)||void 0===t||t.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(c){this._dashCount=c,this._dashArray=1/c}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(c){this._sizeAttenuation=c,this.markAllDefinesAsDirty()}get color(){return this._color}set color(c){this.setColor(c)}setColor(c){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==c||null!==this._color&&null===c?(this._color=c,r||this.markAllDefinesAsDirty()):this._color=c}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(c){this._colorsDistributionType=c,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(c){this._aspect=c.x/c.y,this._resolution=c}serialize(){const c=super.serialize(),r={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(r.zc=this._colors),this._color&&(r.color=this._color),c.greasedLineMaterialOptions=r,c}parse(c,r,D){var W;super.parse(c,r,D);const B=c.greasedLineMaterialOptions;null===(W=this.colorsTexture)||void 0===W||W.dispose(),B.color&&this.setColor(B.color,!0),B.colorDistributionType&&(this.colorsDistributionType=B.colorDistributionType),B.zc&&(this.zc=B.zc),B.colorsSampling&&(this.colorsSampling=B.colorsSampling),B.colorMode&&(this.colorMode=B.colorMode),B.useColors&&(this.useColors=B.useColors),B.visibility&&(this.visibility=B.visibility),B.useDash&&(this.useDash=B.useDash),B.dashCount&&(this.dashCount=B.dashCount),B.dashRatio&&(this.dashRatio=B.dashRatio),B.dashOffset&&(this.dashOffset=B.dashOffset),B.width&&(this.width=B.width),B.sizeAttenuation&&(this.sizeAttenuation=B.sizeAttenuation),B.resolution&&(this.resolution=B.resolution),this.zc?this.colorsTexture=Kc.CreateColorsTexture(`${this._material.name}-colors-texture`,this.zc,this.colorsSampling,r):Kc.PrepareEmptyColorsTexture(r),this.markAllDefinesAsDirty()}copyTo(c){var r;const D=c;null===(r=D.colorsTexture)||void 0===r||r.dispose(),this._colors&&(D.colorsTexture=Kc.CreateColorsTexture(`${D._material.name}-colors-texture`,this._colors,D.colorsSampling,this._scene)),D.setColor(this.color,!0),D.colorsDistributionType=this.colorsDistributionType,D.colorsSampling=this.colorsSampling,D.colorMode=this.colorMode,D.useColors=this.useColors,D.visibility=this.visibility,D.useDash=this.useDash,D.dashCount=this.dashCount,D.dashRatio=this.dashRatio,D.dashOffset=this.dashOffset,D.width=this.width,D.sizeAttenuation=this.sizeAttenuation,D.resolution=this.resolution,D.markAllDefinesAsDirty()}_isGLSL(c){return 0===c||this._forceGLSL}}Ac.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Ac.ForceGLSL=!1,(0,Nc.e)(`BABYLON.${Ac.GREASED_LINE_MATERIAL_NAME}`,Ac);var hc=D(12118),Lc=D(11515),Pc=D(11915),Gc=D(11617);class dc extends Pc.ShaderMaterial{constructor(c,r,B){const t=r.getEngine(),u=t.isWebGPU&&!(B.forceGLSL||dc.ForceGLSL),a=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];r.useRightHandedSystem&&a.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const H=["position","grl_widths","grl_offsets","grl_colorPointers"];B.cameraFacing?(a.push("GREASED_LINE_CAMERA_FACING"),H.push("grl_previousAndSide","grl_nextAndCounters")):(H.push("grl_slopes"),H.push("grl_counters"));const x=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(u||x.push("world","viewProjection","view","projection"),super(c,r,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:u?["Scene","Mesh"]:void 0,attributes:H,uniforms:x,samplers:u?[]:["grlColors"],defines:a,extraInitializationsAsync:async()=>{u?await Promise.all([D.e(66).then(D.bind(D,14846)),D.e(75).then(D.bind(D,14853))]):await Promise.all([D.e(69).then(D.bind(D,14857)),D.e(76).then(D.bind(D,14865))])},shaderLanguage:u?1:0}),this._color=w.Xr.White(),this._colorsDistributionType=0,this._colorsTexture=null,B=B||{color:gc.DEFAULT_COLOR},this.visibility=B.visibility??1,this.useDash=B.useDash??!1,this.dashRatio=B.dashRatio??.5,this.dashOffset=B.dashOffset??0,this.dashCount=B.dashCount??1,this.width=B.width?B.width:B.sizeAttenuation&&B.cameraFacing?gc.DEFAULT_WIDTH_ATTENUATED:gc.DEFAULT_WIDTH,this.sizeAttenuation=B.sizeAttenuation??!1,this.color=B.color??w.Xr.White(),this.useColors=B.useColors??!1,this.colorsDistributionType=B.colorDistributionType??0,this.colorsSampling=B.colorsSampling??e.e.NEAREST_NEAREST,this.colorMode=B.colorMode??0,this._colors=B.zc??null,this._cameraFacing=B.cameraFacing??!0,this.resolution=B.resolution??new W.Vector2(t.getRenderWidth(),t.getRenderHeight()),B.colorsTexture?this.colorsTexture=B.colorsTexture:this._colors?this.colorsTexture=Kc.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,r):(this._color=this._color??gc.DEFAULT_COLOR,this.colorsTexture=Kc.PrepareEmptyColorsTexture(r)),u){const c=new Gc.e;c.setParameters(),c.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",c)}t.Wa.add((()=>{Kc.DisposeEmptyColorsTexture()}))}dispose(){var c;null===(c=this._colorsTexture)||void 0===c||c.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new W.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get zc(){return this._colors}set zc(c){this.setColors(c)}setColors(c){var r;let D=arguments.length>1&&void 0!==arguments[1]&&arguments[1],W=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=(null===(r=this._colors)||void 0===r?void 0:r.length)??0;var t;if(this._colors=c,null!==c&&0!==c.length){if(!D||W)if(this._colorsTexture&&B===c.length&&!W){const r=Kc.Color3toRGBAUint8(c);this._colorsTexture.update(r)}else{var u;null===(u=this._colorsTexture)||void 0===u||u.dispose(),this.colorsTexture=Kc.CreateColorsTexture(`${this.name}-colors-texture`,c,this.colorsSampling,this.yc())}}else null===(t=this._colorsTexture)||void 0===t||t.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(c){this._colorsTexture=c,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(c){this._width=c,this.setFloat("grlWidth",c)}get useColors(){return this._useColors}set useColors(c){this._useColors=c,this.setFloat("grlUseColors",Kc.BooleanToNumber(c))}get colorsSampling(){return this._colorsSampling}set colorsSampling(c){this._colorsSampling=c}get visibility(){return this._visibility}set visibility(c){this._visibility=c,this.setFloat("grlVisibility",c)}get useDash(){return this._useDash}set useDash(c){this._useDash=c,this.setFloat("grlUseDash",Kc.BooleanToNumber(c))}get dashOffset(){return this._dashOffset}set dashOffset(c){this._dashOffset=c,this.setFloat("grlDashOffset",c)}get dashRatio(){return this._dashRatio}set dashRatio(c){this._dashRatio=c,this.setFloat("grlDashRatio",c)}get dashCount(){return this._dashCount}set dashCount(c){this._dashCount=c,this._dashArray=1/c,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(c){this._sizeAttenuation=c,this.setFloat("grlSizeAttenuation",Kc.BooleanToNumber(c))}get color(){return this._color}set color(c){this.setColor(c)}setColor(c){c=c??gc.DEFAULT_COLOR,this._color=c,this.setColor3("grlColor",c)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(c){this._colorsDistributionType=c,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(c){this._colorMode=c,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(c){this._resolution=c,this.setVector2("grlResolution",c),this.setFloat("grlAspect",c.x/c.y)}serialize(){const c=super.serialize(),r={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(r.zc=this._colors),c.greasedLineMaterialOptions=r,c}parse(c,r,D){var W;const B=c.greasedLineMaterialOptions;null===(W=this._colorsTexture)||void 0===W||W.dispose(),B.color&&(this.color=B.color),B.colorDistributionType&&(this.colorsDistributionType=B.colorDistributionType),B.colorsSampling&&(this.colorsSampling=B.colorsSampling),B.colorMode&&(this.colorMode=B.colorMode),B.useColors&&(this.useColors=B.useColors),B.visibility&&(this.visibility=B.visibility),B.useDash&&(this.useDash=B.useDash),B.dashCount&&(this.dashCount=B.dashCount),B.dashRatio&&(this.dashRatio=B.dashRatio),B.dashOffset&&(this.dashOffset=B.dashOffset),B.width&&(this.width=B.width),B.sizeAttenuation&&(this.sizeAttenuation=B.sizeAttenuation),B.resolution&&(this.resolution=B.resolution),B.zc?this.colorsTexture=Kc.CreateColorsTexture(`${this.name}-colors-texture`,B.zc,this.colorsSampling,this.yc()):this.colorsTexture=Kc.PrepareEmptyColorsTexture(r),this._cameraFacing=B.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Tc,bc,Oc;dc.ForceGLSL=!1,function(c){c[c.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",c[c.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Tc||(Tc={})),function(c){c[c.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",c[c.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",c[c.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(bc||(bc={})),function(c){c[c.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",c[c.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",c[c.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",c[c.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",c[c.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Oc||(Oc={}));class Cc extends Jc.e{constructor(c,r,D){super(c,r,null,null,!1,!1),this.name=c,this._options=D,this._lazy=!1,this._updatable=!1,this._engine=r.getEngine(),this._lazy=D.lazy??!1,this._updatable=D.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=D.colorPointers??[],this._widths=D.widths??new Array(D.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(c){let r=0;for(const W of this._points)r+=W.length;const D=r/3*2-this._widths.length;for(let W=0;W<D;W++)this._widths.push(c)}updateLazy(){var c,r;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(c=this._options.ribbonOptions)||void 0===c?void 0:c.smoothShading),!this.Ac&&this.refreshBoundingInfo(),null===(r=this.greasedLineMaterial)||void 0===r||r.updateLazy()}addPoints(c,r){for(const D of c)this._points.push(D);this._lazy||this.setPoints(this._points,r)}dispose(c){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(c,r)}isLazy(){return this._lazy}get Sc(){return this._uvs}set Sc(c){this._uvs=c instanceof Float32Array?c:new Float32Array(c),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(c){this.material instanceof dc&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===c||void 0===c?void 0:c.length)>0),this._offsets=c,this._offsetsBuffer?this._offsetsBuffer.update(c):this._createOffsetsBuffer(c)}get widths(){return this._widths}set widths(c){this._widths=c,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(c)}get colorPointers(){return this._colorPointers}set colorPointers(c){this._colorPointers=c,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(c)}get greasedLineMaterial(){var c,r;if(this.material&&this.material instanceof dc)return this.material;const D=null===(c=this.material)||void 0===c||null===(r=c.pluginManager)||void 0===r?void 0:r.getPlugin(Ac.GREASED_LINE_MATERIAL_NAME);return D||void 0}get points(){const c=[];return Lc.e.DeepCopy(this._points,c),c}setPoints(c,r){this._points=Kc.ConvertPoints(c,(null===r||void 0===r?void 0:r.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==r&&void 0!==r&&r.colorPointers||this._updateColorPointers(),this._setPoints(this._points,r)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Sc:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(c){super.serialize(c),c.type=this.getClassName(),c.lineOptions=this._createLineOptions()}_createVertexBuffers(){let c=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=new hc.b;return r.Nc=this._vertexPositions,r.indices=this._indices,r.Sc=this._uvs,c&&(r.gc=[],hc.b.ComputeNormals(this._vertexPositions,this._indices,r.gc)),r.fc(this,this._options.updatable),r}_createOffsetsBuffer(c){const r=this._scene.getEngine(),D=new M.b(r,c,this._updatable,3);this.setVerticesBuffer(D.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=D}}class pc{constructor(c,r){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=c,this.wasAddedByNoopNode=r}getIndicesAccessor(c,r,D,W,B){var t,u,a,H;return null===(t=this._indicesAccessorMap.get(c))||void 0===t||null===(u=t.get(r))||void 0===u||null===(a=u.get(D))||void 0===a||null===(H=a.get(W))||void 0===H?void 0:H.get(B)}setIndicesAccessor(c,r,D,W,B,t){let u=this._indicesAccessorMap.get(c);u||(u=new Map,this._indicesAccessorMap.set(c,u));let a=u.get(r);a||(a=new Map,u.set(r,a));let H=a.get(D);H||(H=new Map,a.set(D,H));let x=H.get(W);x||(x=new Map,H.set(W,x)),x.set(B,t)}pushExportedNode(c){this._exportedNodes.has(c)||this._exportedNodes.add(c)}getNodesSet(){return this._exportedNodes}getVertexBufferView(c){return this._vertexBufferViewMap.get(c)}setVertexBufferView(c,r){this._vertexBufferViewMap.set(c,r)}setRemappedBufferView(c,r,D){this._remappedBufferView.set(c,new Map),this._remappedBufferView.get(c).set(r,D)}getRemappedBufferView(c,r){var D;return null===(D=this._remappedBufferView.get(c))||void 0===D?void 0:D.get(r)}getVertexAccessor(c,r,D){var W,B;return null===(W=this._vertexAccessorMap.get(c))||void 0===W||null===(B=W.get(r))||void 0===B?void 0:B.get(D)}setVertexAccessor(c,r,D,W){let B=this._vertexAccessorMap.get(c);B||(B=new Map,this._vertexAccessorMap.set(c,B));let t=B.get(r);t||(t=new Map,B.set(r,t)),t.set(D,W)}hasVertexColorAlpha(c){return this._vertexMapColorAlpha.get(c)||!1}setHasVertexColorAlpha(c,r){return this._vertexMapColorAlpha.set(c,r)}getMesh(c){return this._meshMap.get(c)}setMesh(c,r){this._meshMap.set(c,r)}bindMorphDataToMesh(c,r){const D=this._meshMorphTargetMap.get(c)||[];this._meshMorphTargetMap.set(c,D),-1===D.indexOf(r)&&D.push(r)}getMorphTargetsFromMesh(c){return this._meshMorphTargetMap.get(c)}}class Rc{_ApplyExtension(c,r,D,W){if(D>=r.length)return Promise.resolve(c);const B=W(r[D],c);return B?B.then((async c=>c?await this._ApplyExtension(c,r,D+1,W):null)):this._ApplyExtension(c,r,D+1,W)}_ApplyExtensions(c,r){const D=[];for(const W of Rc._ExtensionNames)D.push(this._extensions[W]);return this._ApplyExtension(c,D,0,r)}_extensionsPreExportTextureAsync(c,r,D){return this._ApplyExtensions(r,((r,W)=>r.preExportTextureAsync&&r.preExportTextureAsync(c,W,D)))}_extensionsPostExportNodeAsync(c,r,D,W,B){return this._ApplyExtensions(r,((r,t)=>r.postExportNodeAsync&&r.postExportNodeAsync(c,t,D,W,B,this._bufferManager)))}_extensionsPostExportMaterialAsync(c,r,D){return this._ApplyExtensions(r,((r,W)=>r.postExportMaterialAsync&&r.postExportMaterialAsync(c,W,D)))}_extensionsPostExportMaterialAdditionalTextures(c,r,D){const W=[];for(const B of Rc._ExtensionNames){const t=this._extensions[B];t.postExportMaterialAdditionalTextures&&W.push(...t.postExportMaterialAdditionalTextures(c,r,D))}return W}_extensionsPostExportTextures(c,r,D){for(const W of Rc._ExtensionNames){const B=this._extensions[W];B.postExportTexture&&B.postExportTexture(c,r,D)}}_extensionsPostExportMeshPrimitive(c){for(const r of Rc._ExtensionNames){const D=this._extensions[r];D.postExportMeshPrimitive&&D.postExportMeshPrimitive(c,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const c of Rc._ExtensionNames){const r=this._extensions[c];r.preGenerateBinaryAsync&&await r.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(c){for(const r of Rc._ExtensionNames){const D=this._extensions[r];D.enabled&&c(D)}}_extensionsOnExporting(){this._forEachExtensions((c=>{var r,D,W;c.wasUsed&&((r=this._glTF).extensionsUsed||(r.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(c.name)&&this._glTF.extensionsUsed.push(c.name),c.required&&((D=this._glTF).extensionsRequired||(D.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(c.name)&&this._glTF.extensionsRequired.push(c.name)),(W=this._glTF).extensions||(W.extensions={}),c.onExporting&&c.onExporting())}))}_loadExtensions(){for(const c of Rc._ExtensionNames){const r=Rc._ExtensionFactories[c](this);this._extensions[c]=r}}constructor(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:k.c.LastCreatedScene,r=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${v.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new G(this),this._extensions={},this._bufferManager=new Mc,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!c)throw new Error("No scene available to export");this._babylonScene=c,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:c=>{var r;return null===c||void 0===c||null===(r=c.ua)||void 0===r?void 0:r.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...r},this._loadExtensions()}dispose(){for(const c in this._extensions){this._extensions[c].dispose()}}get options(){return this._options}static RegisterExtension(c,r){Rc.UnregisterExtension(c)&&B.Tools.Warn(`Extension with the name ${c} already exists`),Rc._ExtensionFactories[c]=r,Rc._ExtensionNames.push(c)}static UnregisterExtension(c){if(!Rc._ExtensionFactories[c])return!1;delete Rc._ExtensionFactories[c];const r=Rc._ExtensionNames.indexOf(c);return-1!==r&&Rc._ExtensionNames.splice(r,1),!0}_generateJSON(c,r,D){const W={byteLength:c};return W.byteLength&&(this._glTF.buffers=[W]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.qr=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(W.uri=r+".bin"),D?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(c){const r=await this._generateBinaryAsync();this._extensionsOnExporting();const D=this._generateJSON(r.byteLength,c,!0),W=new Blob([r],{type:"application/octet-stream"}),B=c+".gltf",t=c+".bin",u=new x;if(u.files[B]=D,u.files[t]=W,this._imageData)for(const a in this._imageData)u.files[a]=new Blob([this._imageData[a].data],{type:this._imageData[a].mimeType});return u}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(c){const r=c%4;return 0===r?r:4-r}async generateGLBAsync(c){this._shouldUseGlb=!0;const r=await this._generateBinaryAsync();this._extensionsOnExporting();const D=this._generateJSON(r.byteLength),W=c+".glb";let B,t=D.length;if("undefined"!==typeof TextEncoder){B=(new TextEncoder).encode(D),t=B.length}const u=this._getPadding(t),a=this._getPadding(r.byteLength),H=28+t+u+r.byteLength+a,M=new Hc(H);if(M.writeUInt32(1179937895),M.writeUInt32(2),M.writeUInt32(H),M.writeUInt32(t+u),M.writeUInt32(1313821514),B)M.writeTypedArray(B);else{const c="_".charCodeAt(0);for(let r=0;r<t;++r){const W=D.charCodeAt(r);W!=D.codePointAt(r)?M.writeUInt8(c):M.writeUInt8(W)}}for(let x=0;x<u;++x)M.writeUInt8(32);M.writeUInt32(r.byteLength+a),M.writeUInt32(5130562),M.writeTypedArray(r);for(let x=0;x<a;++x)M.writeUInt8(0);const E=new x;return E.files[W]=new Blob([M.getOutputData()],{type:"application/octet-stream"}),E}_setNodeTransformation(c,r,D){if(r.getPivotPoint().equalsWithEpsilon(C,O.c)||B.Tools.Warn("Pivot points are not supported in the glTF serializer"),!r.position.equalsWithEpsilon(C,O.c)){const B=W.TmpVectors.Zr[0].t(r.position);D&&i(B),c.translation=B.Ma()}r.qa.equalsWithEpsilon(R,O.c)||(c.scale=r.qa.Ma());const t=r.rotationQuaternion||W.Quaternion.FromEulerAngles(r.rotation.x,r.rotation.y,r.rotation.z);t.equalsWithEpsilon(p,O.c)||(D&&n(t),c.rotation=t.normalize().Ma())}_setCameraTransformation(c,r,D){if(!r.position.equalsWithEpsilon(C,O.c)){const B=W.TmpVectors.Zr[0].t(r.position);D&&i(B),c.translation=B.Ma()}const B=r.rotationQuaternion||W.Quaternion.FromEulerAngles(r.rotation.x,r.rotation.y,r.rotation.z);D&&n(B),this._babylonScene.useRightHandedSystem||V(B),B.equalsWithEpsilon(p,O.c)||(c.rotation=B.Ma())}_listAvailableCameras(){for(const c of this._babylonScene.cameras){const r={type:c.mode===mc.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(c.name&&(r.name=c.name),"perspective"===r.type)r.perspective={aspectRatio:c.getEngine().getAspectRatio(c),yfov:c.fovMode===mc.d.FOVMODE_VERTICAL_FIXED?c.fov:c.fov*c.getEngine().getAspectRatio(c),znear:c.ma,zfar:c.maxZ};else if("orthographic"===r.type){const D=c.orthoLeft&&c.orthoRight?.5*(c.orthoRight-c.orthoLeft):.5*c.getEngine().getRenderWidth(),W=c.orthoBottom&&c.orthoTop?.5*(c.orthoTop-c.orthoBottom):.5*c.getEngine().getRenderHeight();r.orthographic={xmag:D,ymag:W,znear:c.ma,zfar:c.maxZ}}this._camerasMap.set(c,r)}}_exportAndAssignCameras(){const c=Array.from(this._camerasMap.values());for(const r of c){const c=this._nodesCameraMap.get(r);if(void 0!==c){this._cameras.push(r);for(const r of c)r.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const c of this._babylonScene.skeletons){if(c.bones.length<=0)continue;const r={joints:[]};this._skinMap.set(c,r)}}_exportAndAssignSkeletons(){for(const c of this._babylonScene.skeletons){if(c.bones.length<=0)continue;const r=this._skinMap.get(c);if(void 0==r)continue;const D={},W=[];let t=-1;for(let B=0;B<c.bones.length;++B){const r=c.bones[B],W=r.getIndex()??B;-1!==W&&(D[W]=r,W>t&&(t=W))}for(let c=0;c<=t;++c){const t=D[c];W.push(t.getAbsoluteInverseBindMatrix());const u=t.getTransformNode();if(null!==u){const c=this._nodeMap.get(u);u&&null!==c&&void 0!==c?r.joints.push(c):B.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else B.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const u=this._nodesSkinMap.get(r);if(r.joints.length>0&&void 0!==u){const c=64*W.length,D=new Float32Array(c/4);W.forEach(((c,r)=>{D.set(c.m,16*r)}));const B=this._bufferManager.createBufferView(D);this._accessors.push(this._bufferManager.createAccessor(B,"MAT4",5126,W.length)),r.inverseBindMatrices=this._accessors.length-1,this._skins.push(r);for(const r of u)r.skin=this._skins.length-1}}}async _exportSceneAsync(){const c={nodes:[]};if(this._babylonScene.metadata){const r=this._options.metadataSelector(this._babylonScene.metadata);r&&(c.extras=r)}const r=new Array,D=new Array,W=new Array;for(const a of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&uc(a,this._babylonScene.useRightHandedSystem)?W.push(...a.getChildren()):this._babylonScene.useRightHandedSystem?r.push(a):D.push(a);this._listAvailableCameras(),this._listAvailableSkeletons();const B=new pc(!0,!1);c.nodes.push(...await this._exportNodesAsync(D,B));const t=new pc(!1,!1);c.nodes.push(...await this._exportNodesAsync(r,t));const u=new pc(!1,!0);c.nodes.push(...await this._exportNodesAsync(W,u)),c.nodes.length&&this._scenes.push(c),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&jc._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,B.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(c){let r=this._shouldExportNodeMap.get(c);return void 0===r&&(r=this._options.shouldExportNode(c),this._shouldExportNodeMap.set(c,r)),r}async _exportNodesAsync(c,r){const D=new Array;this._exportBuffers(c,r);for(const W of c)await this._exportNodeAsync(W,D,r);return D}_collectBuffers(c,r,D,W,B){if(this._shouldExportNode(c)&&c instanceof m.d&&c.ka){const t=c.ka.getVertexBuffers();if(t)for(const W in t){if(!l(W))continue;const u=t[W];B.setHasVertexColorAlpha(u,c.hasVertexAlpha);const a=u._buffer,H=r.get(a)||[];r.set(a,H),-1===H.indexOf(u)&&H.push(u);const x=D.get(u)||[];D.set(u,x),-1===x.indexOf(c)&&x.push(c)}const u=c.morphTargetManager;if(u)for(let r=0;r<u.numTargets;r++){const D=u.getTarget(r),B=W.get(D)||[];W.set(D,B),-1===B.indexOf(c)&&B.push(c)}}for(const t of c.getChildren())this._collectBuffers(t,r,D,W,B)}_exportBuffers(c,r){const D=new Map,W=new Map,B=new Map;for(const a of c)this._collectBuffers(a,D,W,B,r);const t=Array.from(D.keys());for(const a of t){const c=a.getData();if(!c)throw new Error("Buffer data is not available");const B=D.get(a);if(!B)continue;const t=B[0].byteStride;if(B.some((c=>c.byteStride!==t)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const u=Dc(c).slice();for(const r of B){const c=W.get(r),{byteOffset:D,byteStride:B,componentCount:t,type:a,count:H,normalized:x,kind:E}=o(r,c);switch(E){case M.d.NormalKind:case M.d.TangentKind:(0,d.j)(u,D,B,t,a,H,x,(c=>{const r=Math.sqrt(c[0]*c[0]+c[1]*c[1]+c[2]*c[2]);if(r>0){const D=1/r;c[0]*=D,c[1]*=D,c[2]*=D}}));break;case M.d.ColorKind:{const r=c.filter((c=>c.material instanceof kc.jr||null==c.material)).length;if(0==r)break;if(r!=c.length){T.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}a==M.d.UNSIGNED_BYTE&&T.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const W=new w.Xr,E=new w.Xa,m=this._babylonScene.getEngine().useExactSrgbConversions;(0,d.j)(u,D,B,t,a,H,x,(c=>{3===c.length?(W.jD(c,0),W.toLinearSpaceToRef(W,m),W.toArray(c,0)):(E.jD(c,0),E.toLinearSpaceToRef(E,m),E.toArray(c,0))}))}}}if(r.convertToRightHanded){for(const c of B){const r=W.get(c),{byteOffset:D,byteStride:B,componentCount:t,type:a,count:H,normalized:x,kind:E}=o(c,r);switch(E){case M.d.PositionKind:case M.d.NormalKind:case M.d.TangentKind:(0,d.j)(u,D,B,t,a,H,x,(c=>{c[0]=-c[0]}))}}r.convertedToRightHandedBuffers.set(a,u)}const H=this._bufferManager.createBufferView(u,t);r.setVertexBufferView(a,H);const x=new Map;for(const r of B){const c=W.get(r),{kind:D,totalVertices:B}=o(r,c);switch(D){case M.d.MatricesIndicesKind:case M.d.MatricesIndicesExtraKind:if(r.type==M.d.FLOAT){const c=r.getFloatData(B);null!==c&&x.set(r,c)}}}0!==x.size&&T.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const E=Array.from(x.keys());for(const D of E){const c=x.get(D);if(!c)continue;const W=c.some((c=>c>=256)),B=new(W?Uint16Array:Uint8Array)(c.length);for(let r=0;r<c.length;r++)B[r]=c[r];const t=this._bufferManager.createBufferView(B,4*(W?2:1));r.setRemappedBufferView(a,D,t)}}const u=Array.from(B.keys());for(const a of u){const c=B.get(a);if(!c)continue;const D=Xc(a,c[0],this._bufferManager,this._bufferViews,this._accessors,r.convertToRightHanded);for(const W of c)r.bindMorphDataToMesh(W,D)}}async _exportNodeAsync(c,r,D){let W=this._nodeMap.get(c);if(void 0!==W)return void(r.includes(W)||r.push(W));const B=await this._createNodeAsync(c,D);if(B){W=this._nodes.length,this._nodes.push(B),this._nodeMap.set(c,W),D.pushExportedNode(c),r.push(W);const t={name:"runtime animations",channels:[],samplers:[]},u=[];this._babylonScene.animationGroups.length||(jc._CreateMorphTargetAnimationFromMorphTargetAnimations(c,t,u,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,D.convertToRightHanded,this._options.shouldExportAnimation),c.animations.length&&jc._CreateNodeAnimationFromNodeAnimations(c,t,u,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,D.convertToRightHanded,this._options.shouldExportAnimation)),t.channels.length&&t.samplers.length&&this._animations.push(t),u.forEach((c=>{c.channels.length&&c.samplers.length&&this._animations.push(c)}))}const t=B?[]:r;for(const u of c.getChildren())await this._exportNodeAsync(u,t,D);B&&t.length&&(B.children=t)}async _createNodeAsync(c,r){if(!this._shouldExportNode(c))return null;const D={};if(c.name&&(D.name=c.name),c.metadata){const r=this._options.metadataSelector(c.metadata);r&&(D.extras=r)}if(c instanceof E.e&&(this._setNodeTransformation(D,c,r.convertToRightHanded),c instanceof m.d)){const B=c instanceof Y.b?c.sourceMesh:c;if(B.xa&&B.xa.length>0&&(D.mesh=await this._exportMeshAsync(B,r)),c.skeleton){const r=this._skinMap.get(c.skeleton);var W;if(void 0!==r)void 0===this._nodesSkinMap.get(r)&&this._nodesSkinMap.set(r,[]),null===(W=this._nodesSkinMap.get(r))||void 0===W||W.push(D)}}if(c instanceof b.e){const W=this._camerasMap.get(c);if(W){var B;void 0===this._nodesCameraMap.get(W)&&this._nodesCameraMap.set(W,[]),this._setCameraTransformation(D,c,r.convertToRightHanded);const u=c.parent;if(null!==u&&rc(c,u)){const c=this._nodeMap.get(u);if(void 0!==c){var t;const r=this._nodes[c];return cc(D,r),null===(t=this._nodesCameraMap.get(W))||void 0===t||t.push(r),null}}null===(B=this._nodesCameraMap.get(W))||void 0===B||B.push(D)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",D,c,this._nodeMap,r.convertToRightHanded)?D:(T.e.Warn(`Not exporting node ${c.name}`),null)}_exportIndices(c,r,D,W,B,u,a,H,x){let M=c;x.mode=F(u);const E=a!==t.c.CounterClockWiseSideOrientation,m=!H.wasAddedByNoopNode&&E,Y=function(c){switch(c){case t.c.TriangleFillMode:case t.c.TriangleStripDrawMode:case t.c.TriangleFanDrawMode:return!0}return!1}(u)&&m;if(Y){if(u===t.c.TriangleStripDrawMode||u===t.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");x.mode=F(u);const a=r?new Uint32Array(W):new Uint16Array(W);if(c)for(let r=0;r+2<W;r+=3)a[r]=c[D+r]+B,a[r+1]=c[D+r+2]+B,a[r+2]=c[D+r+1]+B;else for(let c=0;c+2<W;c+=3)a[c]=c,a[c+1]=c+2,a[c+2]=c+1;M=a}else if(c&&0!==B){const t=r?new Uint32Array(W):new Uint16Array(W);for(let r=0;r<W;r++)t[r]=c[D+r]+B;M=t}if(M){let t=H.getIndicesAccessor(c,D,W,B,Y);if(void 0===t){const u=function(c,r,D,W){if(c instanceof Uint16Array||c instanceof Uint32Array)return c;if(c instanceof Int32Array)return new Uint32Array(c.buffer,c.byteOffset,c.length);const B=c.slice(r,r+D);return W?new Uint32Array(B):new Uint16Array(B)}(M,0,W,r),a=this._bufferManager.createBufferView(u),x=r?5125:5123;this._accessors.push(this._bufferManager.createAccessor(a,"SCALAR",x,W,0)),t=this._accessors.length-1,H.setIndicesAccessor(c,D,W,B,Y,t)}x.indices=t}}_exportVertexBuffer(c,r,D,W,B,t){const u=c.getKind();if(!l(u))return;if(u.startsWith("uv")&&!this._options.exportUnusedUVs&&(!r||!this._materialNeedsUVsSet.has(r)))return;let a=B.getVertexAccessor(c,D,W);if(void 0===a){const r=B.convertedToRightHandedBuffers.get(c._buffer)||c._buffer.getData(),t=u===M.d.PositionKind?function(c,r,D,W){const{byteOffset:B,byteStride:t,type:u,normalized:a}=r,H=r.getSize(),x=new Array(H).fill(1/0),M=new Array(H).fill(-1/0);return(0,d.j)(c,B+D*t,t,H,u,W*H,a,(c=>{for(let r=0;r<H;r++)x[r]=Math.min(x[r],c[r]),M[r]=Math.max(M[r],c[r])})),{min:x,max:M}}(r,c,D,W):void 0,H=(u===M.d.MatricesIndicesKind||u===M.d.MatricesIndicesExtraKind)&&c.type===M.d.FLOAT,x=H?M.d.UNSIGNED_BYTE:c.type,E=H?void 0:c.normalized,m=H?B.getRemappedBufferView(c._buffer,c):B.getVertexBufferView(c._buffer),Y=c.byteOffset+D*c.byteStride;this._accessors.push(this._bufferManager.createAccessor(m,function(c,r){if(c==M.d.ColorKind)return r?"VEC4":"VEC3";switch(c){case M.d.PositionKind:case M.d.NormalKind:return"VEC3";case M.d.TangentKind:case M.d.MatricesIndicesKind:case M.d.MatricesIndicesExtraKind:case M.d.MatricesWeightsKind:case M.d.MatricesWeightsExtraKind:return"VEC4";case M.d.UVKind:case M.d.UV2Kind:case M.d.UV3Kind:case M.d.UV4Kind:case M.d.UV5Kind:case M.d.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${c}`)}(u,B.hasVertexColorAlpha(c)),x,W,Y,t,E)),a=this._accessors.length-1,B.setVertexAccessor(c,D,W,a)}t.attributes[function(c){switch(c){case M.d.PositionKind:return"POSITION";case M.d.NormalKind:return"NORMAL";case M.d.TangentKind:return"TANGENT";case M.d.ColorKind:return"COLOR_0";case M.d.UVKind:return"TEXCOORD_0";case M.d.UV2Kind:return"TEXCOORD_1";case M.d.UV3Kind:return"TEXCOORD_2";case M.d.UV4Kind:return"TEXCOORD_3";case M.d.UV5Kind:return"TEXCOORD_4";case M.d.UV6Kind:return"TEXCOORD_5";case M.d.MatricesIndicesKind:return"JOINTS_0";case M.d.MatricesIndicesExtraKind:return"JOINTS_1";case M.d.MatricesWeightsKind:return"WEIGHTS_0";case M.d.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${c}`)}(u)]=a}async _exportMaterialAsync(c,r,D,W){let B=this._materialMap.get(c);if(void 0===B){const W=r&&Object.keys(r).some((c=>c.startsWith("uv")));if((c=c instanceof Yc.d?c.ea[D.materialIndex]:c)instanceof vc.d)B=await this._materialExporter.exportPBRMaterialAsync(c,"image/png",W);else{if(!(c instanceof kc.jr))return void T.e.Warn(`Unsupported material '${c.name}' with type ${c.getClassName()}`);B=await this._materialExporter.exportStandardMaterialAsync(c,"image/png",W)}this._materialMap.set(c,B)}W.material=B}async _exportMeshAsync(c,r){var D;let W=r.getMesh(c);if(void 0!==W)return W;const B={primitives:[]};W=this._meshes.length,this._meshes.push(B),r.setMesh(c,W);const u=c.isUnIndexed?null:c.wa(),a=null===(D=c.ka)||void 0===D?void 0:D.getVertexBuffers(),H=r.getMorphTargetsFromMesh(c),x=c instanceof ec.b,M=c instanceof Cc,E=c.xa;if(a&&E&&E.length>0)for(const v of E){const D={attributes:{}},W=v.Gc()||this._babylonScene.defaultMaterial;if(M){var m,Y;const r={name:W.name},B=c,t=w.Xr.White(),u=(null===(m=B.material)||void 0===m?void 0:m.alpha)??1,a=(null===(Y=B.greasedLineMaterial)||void 0===Y?void 0:Y.color)??t;(!a.equalsWithEpsilon(t,O.c)||u<1)&&(r.pbrMetallicRoughness={baseColorFactor:[...a.Ma(),u]}),this._materials.push(r),D.material=this._materials.length-1}else if(x){const r={name:W.name},B=c;(!B.color.equalsWithEpsilon(w.Xr.White(),O.c)||B.alpha<1)&&(r.pbrMetallicRoughness={baseColorFactor:[...B.color.Ma(),B.alpha]}),this._materials.push(r),D.material=this._materials.length-1}else await this._exportMaterialAsync(W,a,v,D);const E=x||M?t.c.LineListDrawMode:c.overrideRenderingFillMode??W.fillMode,k=W._getEffectiveOrientation(c);this._exportIndices(u,u?(0,d.e)(u,v.indexCount,v.indexStart,v.verticesStart):v.verticesCount>65535,u?v.indexStart:v.verticesStart,u?v.indexCount:v.verticesCount,-v.verticesStart,E,k,r,D);for(const c of Object.values(a))this._exportVertexBuffer(c,W,v.verticesStart,v.verticesCount,r,D);if(H){D.targets=[];for(const c of H)D.targets.push(c.attributes)}B.primitives.push(D),this._extensionsPostExportMeshPrimitive(D)}if(H){B.weights=[],B.extras||(B.extras={}),B.extras.targetNames=[];for(const c of H)B.weights.push(c.influence),B.extras.targetNames.push(c.name)}return W}}Rc._ExtensionNames=new Array,Rc._ExtensionFactories={};class sc{static async GLTFAsync(c,r,D){D&&D.exportWithoutWaitingForScene||await c.whenReadyAsync();const W=new Rc(c,D),B=await W.generateGLTFAsync(r.replace(/\.[^/.]+$/,""));return W.dispose(),B}static async GLBAsync(c,r,D){D&&D.exportWithoutWaitingForScene||await c.whenReadyAsync();const W=new Rc(c,D),B=await W.generateGLBAsync(r.replace(/\.[^/.]+$/,""));return W.dispose(),B}}D(12236);const oc="EXT_mesh_gpu_instancing";class Qc{constructor(c){this.name=oc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(c,r,D,B,t,u){return await new Promise((c=>{if(r&&D instanceof Jc.e&&D.hasThinInstances&&this._exporter){this._wasUsed=!0;const c=W.Zr.Zero(),B=W.Quaternion.Identity(),a=W.Zr.One(),H=D.thinInstanceGetWorldMatrices(),x=W.TmpVectors.Zr[2],M=W.TmpVectors.Quaternion[1],E=W.TmpVectors.Zr[3];let m=!1,Y=!1,v=!1;const k=new Float32Array(3*D.ya),w=new Float32Array(4*D.ya),Z=new Float32Array(3*D.ya);let J=0;for(const r of H)r.decompose(E,M,x),t&&(i(x),n(M)),k.set(x.Ma(),3*J),w.set(M.normalize().Ma(),4*J),Z.set(E.Ma(),3*J),m=m||!x.equalsWithEpsilon(c),Y=Y||!M.equalsWithEpsilon(B),v=v||!E.equalsWithEpsilon(a),J++;const q={attributes:{}};m&&(q.attributes.TRANSLATION=this._buildAccessor(k,"VEC3",D.ya,u)),Y&&(q.attributes.ROTATION=this._buildAccessor(w,"VEC4",D.ya,u)),v&&(q.attributes.SCALE=this._buildAccessor(Z,"VEC3",D.ya,u)),r.extensions=r.extensions||{},r.extensions[oc]=q}c(r)}))}_buildAccessor(c,r,D,W){const B=W.createBufferView(c),t=W.createAccessor(B,r,5126,D);return this._exporter._accessors.push(t),this._exporter._accessors.length-1}}Rc.RegisterExtension(oc,(c=>new Qc(c)));var lc=D(12244),Fc=D(12256),Ic=D(12263),ic=D(12272);function nc(c){return c===Ic.c.PositionKind?"POSITION":c===Ic.c.NormalKind?"NORMAL":c===Ic.c.ColorKind?"COLOR":c.startsWith(Ic.c.UVKind)?"TEX_COORD":"GENERIC"}const Vc={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class cr extends lc.c{static get DefaultAvailable(){return(0,lc.g)(cr.DefaultConfiguration)}static get Default(){return cr._Default??(cr._Default=new cr),cr._Default}static ResetDefault(c){cr._Default&&(c||cr._Default.dispose(),cr._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(c,r){return{module:await(r||DracoEncoderModule)({wasmBinary:c})}}_getWorkerContent(){return`${Fc.j}(${Fc.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:cr.DefaultConfiguration)}async _encodeAsync(c,r,D){const W=D?(0,ic.b)(Vc,D):Vc;if(this._workerPoolPromise){const D=await this._workerPoolPromise;return await new Promise(((B,t)=>{D.push(((D,u)=>{const a=c=>{D.removeEventListener("error",a),D.removeEventListener("message",H),t(c),u()},H=c=>{"encodeMeshDone"===c.data.id&&(D.removeEventListener("error",a),D.removeEventListener("message",H),B(c.data.encodedMeshData),u())};D.addEventListener("error",a),D.addEventListener("message",H);const x=[];for(const r of c)x.push(r.data.buffer);r&&x.push(r.buffer),D.postMessage({id:"encodeMesh",attributes:c,indices:r,options:W},x)}))}))}if(this._modulePromise){const D=await this._modulePromise;return(0,Fc.j)(D.module,c,r,W)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(c,r){if(0==c.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");c instanceof Jc.e&&c.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===r||void 0===r?void 0:r.method)&&(T.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),r.method="MESH_SEQUENTIAL_ENCODING");const D=function(c){let r=c.wa(void 0,!0);return!r||r instanceof Uint32Array||r instanceof Uint16Array||(r=((0,d.e)(r,r.length)?Uint32Array:Uint16Array).from(r)),r}(c),W=function(c,r){const D=[];for(const W of c.getVerticesDataKinds()){if(null!==r&&void 0!==r&&r.includes(W)){if(W===Ic.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const B=c.getVertexBuffer(W),t=B.getSize(),u=(0,d.u)(B.getData(),t,B.type,B.byteOffset,B.byteStride,B.normalized,c.getTotalVertices(),!0);D.push({kind:W,dracoName:nc(W),size:t,data:u})}return D}(c,null===r||void 0===r?void 0:r.excludedAttributes);return await this._encodeAsync(W,D,r)}}cr.DefaultConfiguration={wasmUrl:`${B.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${B.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${B.Tools._DefaultCdnUrl}/draco_encoder.js`},cr._Default=null;const rr="KHR_draco_mesh_compression";class Dr{get wasUsed(){return this._wasUsed}constructor(c){this.name=rr,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===c.options.meshCompressionMethod&&cr.DefaultAvailable}dispose(){}postExportMeshPrimitive(c,r,D){if(!this.enabled)return;if(4!==c.mode&&5!==c.mode)return void T.e.Warn("Cannot compress primitive with mode "+c.mode+".");const W=[],B=[];let t=null;if(void 0!==c.indices){const u=D[c.indices],a=r.getBufferView(u);t=r.getData(a).slice(),W.push(a),B.push(u)}const u=[];for(const[M,E]of Object.entries(c.attributes)){const c=D[E],t=r.getBufferView(c),H=Q(c.type),x=(0,d.u)(r.getData(t),H,c.componentType,c.byteOffset||0,t.byteStride||(0,d.o)(c.componentType)*H,c.normalized||!1,c.count,!0);u.push({kind:M,dracoName:(a=M,"POSITION"===a?"POSITION":"NORMAL"===a?"NORMAL":a.startsWith("COLOR")?"COLOR":a.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:Q(c.type),data:x}),W.push(t),B.push(c)}var a;const H={method:c.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},x=cr.Default._encodeAsync(u,t,H).then((D=>{if(!D)return void T.e.Error("Draco encoding failed for primitive.");const t={bufferView:-1,attributes:D.attributeIds},u=r.createBufferView(D.data);r.setBufferView(t,u);for(const c of W)this._bufferViewsUsed.add(c);for(const c of B)this._accessorsUsed.add(c);c.extensions||(c.extensions={}),c.extensions[rr]=t})).catch((c=>{T.e.Error("Draco encoding failed for primitive: "+c)}));this._encodePromises.push(x),this._wasUsed=!0}async preGenerateBinaryAsync(c){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((r=>{c.getPropertiesWithBufferView(r).every((c=>this._accessorsUsed.has(c)))&&c.removeBufferView(r)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Rc.RegisterExtension(rr,(c=>new Dr(c)));var Wr=D(12275);const Br="KHR_lights_punctual",tr={name:"",color:[1,1,1],Ua:1,range:Number.MAX_VALUE},ur={innerConeAngle:0,outerConeAngle:Math.PI/4},ar=W.Zr.Backward();class Hr{constructor(c){this.name=Br,this.enabled=!0,this.required=!1,this._exporter=c}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Br]=this._lights}async postExportNodeAsync(c,r,D,B,t){return await new Promise((u=>{if(!(D instanceof qc.b))return void u(r);const a=D.getTypeID()==qc.b.LIGHTTYPEID_POINTLIGHT?"point":D.getTypeID()==qc.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":D.getTypeID()==qc.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!a||!(D instanceof Wr.b))return T.e.Warn(`${c}: Light ${D.name} is not supported in ${Br}`),void u(r);if(D.falloffType!==qc.b.FALLOFF_GLTF&&T.e.Warn(`${c}: Light falloff for ${D.name} does not match the ${Br} specification!`),!D.position.equalsToFloats(0,0,0)){const c=W.TmpVectors.Zr[0].t(D.position);t&&i(c),r.translation=c.Ma()}if("point"!==a){const c=D.direction.normalizeToRef(W.TmpVectors.Zr[0]);t&&i(c);const B=W.Quaternion.FromUnitVectorsToRef(ar,c,W.TmpVectors.Quaternion[0]);W.Quaternion.IsIdentity(B)||(r.rotation=B.Ma())}const H={type:a,name:D.name,color:D.Na.Ma(),Ua:D.Ua,range:D.range};if(Wc(H,tr),"spot"===a){const c=D;H.spot={innerConeAngle:c.innerAngle/2,outerConeAngle:c.angle/2},Wc(H.spot,ur)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(H);const x={gt:this._lights.lights.length-1},M=D.parent;if(M&&rc(D,M)){const c=B.get(M);if(c){const D=this._exporter._nodes[c];return cc(r,D),D.extensions||(D.extensions={}),D.extensions[Br]=x,void u(null)}}r.extensions||(r.extensions={}),r.extensions[Br]=x,u(r)}))}}Rc.RegisterExtension(Br,(c=>new Hr(c)));var xr=D(12189);const Mr="KHR_materials_anisotropy";class Er{constructor(c){this.name=Mr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,r,D){const W=[];return D instanceof xr.d&&D.anisotropy.isEnabled&&!D.anisotropy.legacy?(D.anisotropy.texture&&W.push(D.anisotropy.texture),W):[]}postExportMaterialAsync(c,r,D){return new Promise((c=>{if(D instanceof xr.d){if(!D.anisotropy.isEnabled||D.anisotropy.legacy)return void c(r);this._wasUsed=!0,r.extensions=r.extensions||{};const W=this._exporter._materialExporter.getTextureInfo(D.anisotropy.texture),B={anisotropyStrength:D.anisotropy.Ua,anisotropyRotation:D.anisotropy.angle,anisotropyTexture:W??void 0};null!==B.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(D),r.extensions[Mr]=B}c(r)}))}}Rc.RegisterExtension(Mr,(c=>new Er(c)));const mr="KHR_materials_clearcoat";class Yr{constructor(c){this.name=mr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,r,D){const W=[];return D instanceof xr.d&&D.clearCoat.isEnabled?(D.clearCoat.texture&&W.push(D.clearCoat.texture),!D.clearCoat.useRoughnessFromMainTexture&&D.clearCoat.textureRoughness&&W.push(D.clearCoat.textureRoughness),D.clearCoat.bumpTexture&&W.push(D.clearCoat.bumpTexture),W):[]}postExportMaterialAsync(c,r,D){return new Promise((c=>{if(D instanceof xr.d){if(!D.clearCoat.isEnabled)return void c(r);this._wasUsed=!0,r.extensions=r.extensions||{};const W=this._exporter._materialExporter.getTextureInfo(D.clearCoat.texture);let t;t=D.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(D.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(D.clearCoat.textureRoughness),D.clearCoat.isTintEnabled&&B.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${D.name}`),D.clearCoat.remapF0OnInterfaceChange&&B.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${D.name}`);const u=this._exporter._materialExporter.getTextureInfo(D.clearCoat.bumpTexture),a={clearcoatFactor:D.clearCoat.Ua,clearcoatTexture:W??void 0,clearcoatRoughnessFactor:D.clearCoat.roughness,clearcoatRoughnessTexture:t??void 0,clearcoatNormalTexture:u??void 0};null===a.clearcoatTexture&&null===a.clearcoatRoughnessTexture&&null===a.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(D),r.extensions[mr]=a}c(r)}))}}Rc.RegisterExtension(mr,(c=>new Yr(c)));const vr="KHR_materials_diffuse_transmission";function kr(c,r){const D=r.subSurface;let W=null;return D.translucencyIntensityTexture?W=D.translucencyIntensityTexture:D.thicknessTexture&&D.useMaskFromThicknessTexture&&(W=D.thicknessTexture),W&&!D.useGltfStyleTextures?(T.e.Warn(`${c}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${r.name}`,1),null):W}class wr{constructor(c){this.name=vr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,r,D){const W=[];if(D instanceof vc.d&&this._isExtensionEnabled(D)){const r=kr(c,D);return r&&W.push(r),D.subSurface.translucencyColorTexture&&W.push(D.subSurface.translucencyColorTexture),W}return W}_isExtensionEnabled(c){if(c.unlit)return!1;const r=c.subSurface;return!!r.isTranslucencyEnabled&&(!c.unlit&&!r.useAlbedoToTintTranslucency&&r.useGltfStyleTextures&&1===r.volumeIndexOfRefraction&&0===r.minimumThickness&&0===r.maximumThickness)}postExportMaterialAsync(c,r,D){return new Promise((W=>{if(D instanceof vc.d&&this._isExtensionEnabled(D)){this._wasUsed=!0;const W=D.subSurface,B=kr(c,D),t=0==W.translucencyIntensity?void 0:W.translucencyIntensity,u=this._exporter._materialExporter.getTextureInfo(B)??void 0,a=!W.translucencyColor||W.translucencyColor.equalsFloats(1,1,1)?void 0:W.translucencyColor.Ma(),H=this._exporter._materialExporter.getTextureInfo(W.translucencyColorTexture)??void 0,x={diffuseTransmissionFactor:t,diffuseTransmissionTexture:u,diffuseTransmissionColorFactor:a,diffuseTransmissionColorTexture:H};(u||H)&&this._exporter._materialNeedsUVsSet.add(D),r.extensions=r.extensions||{},r.extensions[vr]=x}W(r)}))}}Rc.RegisterExtension(vr,(c=>new wr(c)));const Zr="KHR_materials_dispersion";class Jr{constructor(){this.name=Zr,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(c){if(c.unlit)return!1;const r=c.subSurface;return!(!r.isRefractionEnabled&&!r.isDispersionEnabled)}postExportMaterialAsync(c,r,D){return new Promise((c=>{if(D instanceof vc.d&&this._isExtensionEnabled(D)){this._wasUsed=!0;const c={dispersion:D.subSurface.dispersion};r.extensions=r.extensions||{},r.extensions[Zr]=c}c(r)}))}}Rc.RegisterExtension(Zr,(()=>new Jr));const qr="KHR_materials_emissive_strength";class jr{constructor(){this.name=qr,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(c,r,D){return await new Promise((c=>{if(!(D instanceof vc.d))return c(r);const W=D.emissiveColor.Ma(),B=Math.max(...W);if(B>1){this._wasUsed=!0,r.extensions||(r.extensions={});const c={emissiveStrength:B},W=D.emissiveColor.scale(1/c.emissiveStrength);r.emissiveFactor=W.Ma(),r.extensions[qr]=c}return c(r)}))}}Rc.RegisterExtension(qr,(c=>new jr));const Xr="KHR_materials_ior";class er{constructor(){this.name=Xr,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(c){return!c.unlit&&(void 0!=c.indexOfRefraction&&1.5!=c.indexOfRefraction)}postExportMaterialAsync(c,r,D){return new Promise((c=>{if(D instanceof vc.d&&this._isExtensionEnabled(D)){this._wasUsed=!0;const c={ior:D.indexOfRefraction};r.extensions=r.extensions||{},r.extensions[Xr]=c}c(r)}))}}Rc.RegisterExtension(Xr,(c=>new er));const yr="KHR_materials_iridescence";class Ur{constructor(c){this.name=yr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,r,D){const W=[];return D instanceof xr.d&&D.iridescence.isEnabled?(D.iridescence.texture&&W.push(D.iridescence.texture),D.iridescence.thicknessTexture&&D.iridescence.thicknessTexture!==D.iridescence.texture&&W.push(D.iridescence.thicknessTexture),W):[]}postExportMaterialAsync(c,r,D){return new Promise((c=>{if(D instanceof xr.d){if(!D.iridescence.isEnabled)return void c(r);this._wasUsed=!0,r.extensions=r.extensions||{};const W=this._exporter._materialExporter.getTextureInfo(D.iridescence.texture),B=this._exporter._materialExporter.getTextureInfo(D.iridescence.thicknessTexture),t={iridescenceFactor:D.iridescence.Ua,iridescenceIor:D.iridescence.indexOfRefraction,iridescenceThicknessMinimum:D.iridescence.minimumThickness,iridescenceThicknessMaximum:D.iridescence.maximumThickness,iridescenceTexture:W??void 0,iridescenceThicknessTexture:B??void 0};null===t.iridescenceTexture&&null===t.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(D),r.extensions[yr]=t}c(r)}))}}Rc.RegisterExtension(yr,(c=>new Ur(c)));const Nr="KHR_materials_sheen";class gr{constructor(c){this.name=Nr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,r,D){return D instanceof vc.d&&D.sheen.isEnabled&&D.sheen.texture?[D.sheen.texture]:[]}async postExportMaterialAsync(c,r,D){return await new Promise((c=>{if(D instanceof vc.d){if(!D.sheen.isEnabled)return void c(r);this._wasUsed=!0,null==r.extensions&&(r.extensions={});const W={sheenColorFactor:D.sheen.color.Ma(),sheenRoughnessFactor:D.sheen.roughness??0};null===W.sheenColorTexture&&null===W.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(D),D.sheen.texture&&(W.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(D.sheen.texture)??void 0),D.sheen.textureRoughness&&!D.sheen.useRoughnessFromMainTexture?W.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(D.sheen.textureRoughness)??void 0:D.sheen.texture&&D.sheen.useRoughnessFromMainTexture&&(W.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(D.sheen.texture)??void 0),r.extensions[Nr]=W}c(r)}))}}Rc.RegisterExtension(Nr,(c=>new gr(c)));const zr="KHR_materials_specular";class Sr{constructor(c){this.name=zr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,r,D){const W=[];return D instanceof vc.d&&this._isExtensionEnabled(D)?(D.metallicReflectanceTexture&&W.push(D.metallicReflectanceTexture),D.reflectanceTexture&&W.push(D.reflectanceTexture),W):W}_isExtensionEnabled(c){return!c.unlit&&(void 0!=c.metallicF0Factor&&1!=c.metallicF0Factor||void 0!=c.metallicReflectanceColor&&!c.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(c))}_hasTexturesExtension(c){return null!=c.metallicReflectanceTexture||null!=c.reflectanceTexture}postExportMaterialAsync(c,r,D){return new Promise((c=>{if(D instanceof vc.d&&this._isExtensionEnabled(D)){this._wasUsed=!0,r.extensions=r.extensions||{};const c=this._exporter._materialExporter.getTextureInfo(D.metallicReflectanceTexture)??void 0,W=this._exporter._materialExporter.getTextureInfo(D.reflectanceTexture)??void 0,B={specularFactor:1==D.metallicF0Factor?void 0:D.metallicF0Factor,specularTexture:c,specularColorFactor:D.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:D.metallicReflectanceColor.Ma(),specularColorTexture:W};this._hasTexturesExtension(D)&&this._exporter._materialNeedsUVsSet.add(D),r.extensions[zr]=B}c(r)}))}}Rc.RegisterExtension(zr,(c=>new Sr(c)));const Kr="KHR_materials_transmission";class fr{constructor(c){this.name=Kr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,r,D){const W=[];return D instanceof vc.d&&this._isExtensionEnabled(D)?(D.subSurface.thicknessTexture&&W.push(D.subSurface.thicknessTexture),W):W}_isExtensionEnabled(c){if(c.unlit)return!1;const r=c.subSurface;return r.isRefractionEnabled&&void 0!=r.refractionIntensity&&0!=r.refractionIntensity||this._hasTexturesExtension(c)}_hasTexturesExtension(c){return null!=c.subSurface.refractionIntensityTexture}async postExportMaterialAsync(c,r,D){if(D instanceof vc.d&&this._isExtensionEnabled(D)){this._wasUsed=!0;const W=D.subSurface,B={transmissionFactor:0===W.refractionIntensity?void 0:W.refractionIntensity};if(this._hasTexturesExtension(D)&&this._exporter._materialNeedsUVsSet.add(D),W.refractionIntensityTexture)if(W.useGltfStyleTextures){const c=await this._exporter._materialExporter.exportTextureAsync(W.refractionIntensityTexture,"image/png");c&&(B.transmissionTexture=c)}else T.e.Warn(`${c}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);r.extensions||(r.extensions={}),r.extensions[Kr]=B}return r}}Rc.RegisterExtension(Kr,(c=>new fr(c)));const Ar="KHR_materials_unlit";class hr{constructor(){this.name=Ar,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(c,r,D){return new Promise((c=>{let W=!1;D instanceof vc.d?W=D.unlit:D instanceof kc.jr&&(W=D.disableLighting),W&&(this._wasUsed=!0,null==r.extensions&&(r.extensions={}),r.extensions[Ar]={}),c(r)}))}}Rc.RegisterExtension(Ar,(()=>new hr));const Lr="KHR_materials_volume";class Pr{constructor(c){this.name=Lr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,r,D){const W=[];return D instanceof vc.d&&this._isExtensionEnabled(D)?(D.subSurface.thicknessTexture&&W.push(D.subSurface.thicknessTexture),W):W}_isExtensionEnabled(c){if(c.unlit)return!1;const r=c.subSurface;return!(!r.isRefractionEnabled&&!r.isTranslucencyEnabled)&&(void 0!=r.maximumThickness&&0!=r.maximumThickness||void 0!=r.tintColorAtDistance&&r.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=r.tintColor&&r.tintColor!=w.Xr.White()||this._hasTexturesExtension(c))}_hasTexturesExtension(c){return null!=c.subSurface.thicknessTexture}postExportMaterialAsync(c,r,D){return new Promise((c=>{if(D instanceof vc.d&&this._isExtensionEnabled(D)){this._wasUsed=!0;const c=D.subSurface,W={thicknessFactor:0==c.maximumThickness?void 0:c.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(c.thicknessTexture)??void 0,attenuationDistance:c.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:c.tintColorAtDistance,attenuationColor:c.tintColor.equalsFloats(1,1,1)?void 0:c.tintColor.Ma()};this._hasTexturesExtension(D)&&this._exporter._materialNeedsUVsSet.add(D),r.extensions=r.extensions||{},r.extensions[Lr]=W}c(r)}))}}Rc.RegisterExtension(Lr,(c=>new Pr(c)));const Gr="EXT_materials_diffuse_roughness";class dr{constructor(c){this.name=Gr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,r,D){const W=[];return D instanceof xr.d&&D._baseDiffuseRoughness?(D._baseDiffuseRoughnessTexture&&W.push(D._baseDiffuseRoughnessTexture),W):[]}postExportMaterialAsync(c,r,D){return new Promise((c=>{if(D instanceof xr.d){if(!D._baseDiffuseRoughness)return void c(r);this._wasUsed=!0,r.extensions=r.extensions||{};const W=this._exporter._materialExporter.getTextureInfo(D._baseDiffuseRoughnessTexture),B={diffuseRoughnessFactor:D._baseDiffuseRoughness,diffuseRoughnessTexture:W??void 0};null!==B.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(D),r.extensions[Gr]=B}c(r)}))}}Rc.RegisterExtension(Gr,(c=>new dr(c)));const Tr="KHR_texture_transform";class br{constructor(){this.name=Tr,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(c,r,D){if(D.yc()||B.Tools.Warn(`${c}: /*@__KEY__*/"scene" is not defined for Babylon texture ${D.name}!`),(0!==D.uAng||0!==D.vAng)&&(B.Tools.Warn(`${c}: Texture ${D.name} with rotation in the u or v axis is not supported in glTF.`),0!==D.uRotationCenter||0!==D.vRotationCenter))return;const W={};let t=!1;if(0===D.uOffset&&0===D.vOffset||(W.offset=[D.uOffset,D.vOffset],t=!0),1===D.uScale&&1===D.vScale||(W.scale=[D.uScale,D.vScale],t=!0),0!==D.wAng){if(0!==D.uRotationCenter||0!==D.vRotationCenter){if(D.homogeneousRotationInUVTransform&&D.uScale!==D.vScale)return void B.Tools.Warn(`${c}: Texture ${D.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Tr}.`);B.Tools.Warn(`${c}: Texture ${D.name} with non-origin rotation center will be exported using an adjusted offset with ${Tr}.`),W.offset=function(c){const{uOffset:r,vOffset:D,uRotationCenter:W,vRotationCenter:B,uScale:t,vScale:u,wAng:a}=c,H=Math.cos(a),x=Math.sin(a),M=W*t,E=B*u;return[r+(M*(1-H)+E*x),D+(E*(1-H)-M*x)]}(D)}W.rotation=-D.wAng,t=!0}0!==D.coordinatesIndex&&(W.texCoord=D.coordinatesIndex,t=!0),t&&(this._wasUsed=!0,r.extensions||(r.extensions={}),r.extensions[Tr]=W)}}Rc.RegisterExtension(Tr,(()=>new br));class Or{static CreateSTL(c){let r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",B=arguments.length>3&&void 0!==arguments[3]&&arguments[3],t=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],u=arguments.length>5&&void 0!==arguments[5]&&arguments[5],a=arguments.length>6&&void 0!==arguments[6]&&arguments[6],H=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const x=function(c,r,D){const B=[3*c[D],3*c[D+1],3*c[D+2]],t=[new W.Zr(r[B[0]],r[B[0]+2],r[B[0]+1]),new W.Zr(r[B[1]],r[B[1]+2],r[B[1]+1]),new W.Zr(r[B[2]],r[B[2]+2],r[B[2]+1])],u=t[0].Jr(t[1]),a=t[2].Jr(t[1]);return{v:t,n:W.Zr.Cross(a,u).normalize()}},E=function(c,r,D,W){return r=m(c,r,D.x,W),r=m(c,r,D.y,W),m(c,r,D.z,W)},m=function(c,r,D,W){return c.setFloat32(r,D,W),r+4},v=function(c){if(a){let r=c;c instanceof Y.b&&(r=c.sourceMesh);const D=r.getVerticesData(M.d.PositionKind,!0,!0);if(!D)return[];const B=W.Zr.Zero();let t;for(t=0;t<D.length;t+=3)W.Zr.TransformCoordinatesFromFloatsToRef(D[t],D[t+1],D[t+2],c.va(!0),B).toArray(D,t);return D}return c.getVerticesData(M.d.PositionKind)||[]};a&&(u=!0);let k="",w=0,Z=0;if(B){for(let D=0;D<c.length;D++){const r=c[D].wa();w+=r?r.length/3:0}const r=new ArrayBuffer(84+50*w);k=new DataView(r),Z+=80,k.setUint32(Z,w,t),Z+=4}else H||(k="solid stlmesh\r\n");for(let W=0;W<c.length;W++){const r=c[W];!B&&H&&(k+="solid "+r.name+"\r\n"),!u&&r instanceof Jc.e&&r.bakeCurrentTransformIntoVertices();const D=v(r),a=r.wa()||[];for(let c=0;c<a.length;c+=3){const r=x(a,D,c);B?(Z=E(k,Z,r.n,t),Z=E(k,Z,r.v[0],t),Z=E(k,Z,r.v[1],t),Z=E(k,Z,r.v[2],t),Z+=2):(k+="\tfacet normal "+r.n.x+" "+r.n.y+" "+r.n.z+"\r\n",k+="\t\touter loop\r\n",k+="\t\t\tvertex "+r.v[0].x+" "+r.v[0].y+" "+r.v[0].z+"\r\n",k+="\t\t\tvertex "+r.v[1].x+" "+r.v[1].y+" "+r.v[1].z+"\r\n",k+="\t\t\tvertex "+r.v[2].x+" "+r.v[2].y+" "+r.v[2].z+"\r\n",k+="\t\tendloop\r\n",k+="\tendfacet\r\n")}!B&&H&&(k+="endsolid "+name+"\r\n")}if(B||H||(k+="endsolid stlmesh"),r){const c=document.createElement("a"),r=new Blob([k],{type:"application/octet-stream"});c.href=window.URL.createObjectURL(r),c.download=D+".stl",c.click()}return k}}function Cr(c,r){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const W=[];for(let B=0;B<c.length/D;B++){const t=c[B*D],u=c[B*D+1],a=c[B*D+2];W.push(`(${t.toPrecision(r.precision)}, ${u.toPrecision(r.precision)}, ${a.toPrecision(r.precision)})`)}return W.join(", ")}function pr(c,r){const D=[];for(let W=0;W<c.length/2;W++){const B=c[2*W],t=c[2*W+1];D.push(`(${B.toPrecision(r.precision)}, ${(1-t).toPrecision(r.precision)})`)}return D.join(", ")}function Rr(c,r){const D=c.getVerticesData(M.d.PositionKind),W=c.getVerticesData(M.d.NormalKind);if(D&&W)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(c){var r;const D=null!==(r=c.wa())&&void 0!==r&&r.length?c.getTotalIndices():c.getTotalVertices();return Array(D/3).fill(3).join(", ")}(c)}]\n\t\tint[] faceVertexIndices = [${function(c){const r=c.wa(),D=[];if(null!==r)for(let W=0;W<r.length;W++)D.push(r[W]);else{const r=c.getTotalVertices();for(let c=0;c<r;c++)D.push(c)}return D.join(", ")}(c)}]\n\t\tnormal3f[] normals = [${Cr(W,r)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Cr(D,r)}]\n        ${function(c,r){let D="";for(let B=0;B<4;B++){const W=B>0?B:"",t=c.getVerticesData(M.d.UVKind+(W?W+1:""));t&&(D+=`\n\t\ttexCoord2f[] primvars:st${W} = [${pr(t,r)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const W=c.getVerticesData(M.d.ColorKind);return W&&(D+=`\n\tcolor3f[] primvars:displayColor = [${Cr(W,r,W.length/c.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),D}(c,r)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function sr(c,r){return`\n        def "Geometry"\n        {\n        ${Rr(c,r)}\n        }\n        `}function or(c){let r='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return r+=c,fflate.strToU8(r)}function Qr(c){const r=c.m;return`( ${lr(r,0)}, ${lr(r,4)}, ${lr(r,8)}, ${lr(r,12)} )`}function lr(c,r){return`(${c[r+0]}, ${c[r+1]}, ${c[r+2]}, ${c[r+3]})`}function Fr(c){const r="Object_"+c.uniqueId,D=function(c){const r=c.getWorldMatrix().clone(),D=c.yc().useRightHandedSystem;if(!D){let W=c.parent;for(;W;){if(uc(W,D)){r.multiplyToRef(W.getWorldMatrix().invert(),r);break}W=W.parent}}return r.determinant()<0&&B.Tools.Warn(`Exporting mesh ${c.name} with negative scale. Result may look incorrect in destination engine.`),r}(c),W=Qr(D);return`def Xform "${r}" (\n\tprepend references = @./geometries/Geometry_${c.ka.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${W}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${c.material.uniqueId}>\n}\n\n`}function Ir(c){switch(c){case y.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case y.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case y.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function ir(c){return`(${c.x}, ${c.y})`}function nr(c){return`(${c.r}, ${c.g}, ${c.b})`}function Vr(c,r,D,B,t,u){const a=c.getInternalTexture().uniqueId+"_"+c.invertY;t[a]=c;const H=c.coordinatesIndex>0?"st"+c.coordinatesIndex:"st",x=new W.Vector2(c.uScale,c.vScale),M=new W.Vector2(c.uOffset,c.vOffset),E=c.wAng,m=Math.sin(E),Y=Math.cos(E);return M.y=1-M.y-x.y,M.x+=m*x.x,M.y+=(1-Y)*x.y,`\n    def Shader "PrimvarReader_${D}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${H}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${D}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${r.uniqueId}/PrimvarReader_${D}.outputs:result>\n        float inputs:rotation = ${(E*(180/Math.PI)).toFixed(u.precision)}\n        float2 inputs:scale = ${ir(x)}\n        float2 inputs:translation = ${ir(M)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${c.uniqueId}_${D}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${a}.png@\n        float2 inputs:st.connect = </Materials/Material_${r.uniqueId}/Transform2d_${D}.outputs:result>\n        ${B?"float4 inputs:scale = "+function(c){return`(${c.r}, ${c.g}, ${c.b}, 1.0)`}(B):""}\n        token inputs:sourceColorSpace = "${c.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Ir(c.wrapU)}"\n        token inputs:wrapT = "${Ir(c.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${r.needAlphaBlending()?"float outputs:a":""}\n    }`}function cD(c,r,D){const W="\t\t\t",B=[],t=[],{diffuseMap:u,Na:a,alphaCutOff:H,emissiveMap:x,emissive:M,normalMap:E,roughnessMap:m,roughnessChannel:Y,roughness:v,metalnessMap:k,metalnessChannel:Z,metalness:J,aoMap:q,aoMapChannel:j,aoMapIntensity:X,alphaMap:e,ior:y,clearCoatEnabled:U,clearCoat:N,clearCoatMap:g,clearCoatRoughness:z,clearCoatRoughnessMap:S}=function(c){const r={diffuseMap:null,Na:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return c instanceof kc.jr?{...r,diffuseMap:c.diffuseTexture,Na:c.diffuseColor,alphaCutOff:c.alphaCutOff,emissiveMap:c.emissiveTexture,emissive:c.emissiveColor,roughness:1,alphaMap:c.opacityTexture}:c instanceof xr.d?{...r,diffuseMap:c._albedoTexture,Na:c._albedoColor,alphaCutOff:c._alphaCutOff,emissiveMap:c._emissiveTexture,emissive:c._emissiveColor,normalMap:c._bumpTexture,roughnessMap:c._metallicTexture,roughnessChannel:c._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:c._roughness??1,metalnessMap:c._metallicTexture,metalnessChannel:c._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:c._metallic??0,aoMap:c._ambientTexture,aoMapChannel:c._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:c._ambientTextureStrength,alphaMap:c._opacityTexture,ior:c.subSurface.indexOfRefraction,clearCoatEnabled:c.clearCoat.isEnabled,clearCoat:c.clearCoat.Ua,clearCoatMap:c.clearCoat.texture,clearCoatRoughness:c.clearCoat.roughness,clearCoatRoughnessMap:c.clearCoat.useRoughnessFromMainTexture?c.clearCoat.texture:c.clearCoat.textureRoughness}:r}(c);return null!==u?(B.push(`${W}color3f inputs:diffuseColor.connect = </Materials/Material_${c.uniqueId}/Texture_${u.uniqueId}_diffuse.outputs:rgb>`),c.needAlphaBlending()?B.push(`${W}float inputs:opacity.connect = </Materials/Material_${c.uniqueId}/Texture_${u.uniqueId}_diffuse.outputs:a>`):c.needAlphaTesting()&&(B.push(`${W}float inputs:opacity.connect = </Materials/Material_${c.uniqueId}/Texture_${u.uniqueId}_diffuse.outputs:a>`),B.push(`${W}float inputs:opacityThreshold = ${H}`)),t.push(Vr(u,c,"diffuse",a,r,D))):B.push(`${W}color3f inputs:diffuseColor = ${nr(a||w.Xr.White())}`),null!==x?(B.push(`${W}color3f inputs:emissiveColor.connect = </Materials/Material_${c.uniqueId}/Texture_${x.uniqueId}_emissive.outputs:rgb>`),t.push(Vr(x,c,"emissive",M,r,D))):M&&M.toLuminance()>0&&B.push(`${W}color3f inputs:emissiveColor = ${nr(M)}`),null!==E&&(B.push(`${W}normal3f inputs:normal.connect = </Materials/Material_${c.uniqueId}/Texture_${E.uniqueId}_normal.outputs:rgb>`),t.push(Vr(E,c,"normal",null,r,D))),null!==q&&(B.push(`${W}float inputs:occlusion.connect = </Materials/Material_${c.uniqueId}/Texture_${q.uniqueId}_occlusion.outputs:${j}>`),t.push(Vr(q,c,"occlusion",new w.Xr(X,X,X),r,D))),null!==m?(B.push(`${W}float inputs:roughness.connect = </Materials/Material_${c.uniqueId}/Texture_${m.uniqueId}_roughness.outputs:${Y}>`),t.push(Vr(m,c,"roughness",new w.Xr(v,v,v),r,D))):B.push(`${W}float inputs:roughness = ${v}`),null!==k?(B.push(`${W}float inputs:metallic.connect = </Materials/Material_${c.uniqueId}/Texture_${k.uniqueId}_metallic.outputs:${Z}>`),t.push(Vr(k,c,"metallic",new w.Xr(J,J,J),r,D))):B.push(`${W}float inputs:metallic = ${J}`),null!==e?(B.push(`${W}float inputs:opacity.connect = </Materials/Material_${c.uniqueId}/Texture_${e.uniqueId}_opacity.outputs:r>`),B.push(`${W}float inputs:opacityThreshold = 0.0001`),t.push(Vr(e,c,"opacity",null,r,D))):B.push(`${W}float inputs:opacity = ${c.alpha}`),U&&(null!==g?(B.push(`${W}float inputs:clearcoat.connect = </Materials/Material_${c.uniqueId}/Texture_${g.uniqueId}_clearcoat.outputs:r>`),t.push(Vr(g,c,"clearcoat",new w.Xr(N,N,N),r,D))):B.push(`${W}float inputs:clearcoat = ${N}`),null!==S?(B.push(`${W}float inputs:clearcoatRoughness.connect = </Materials/Material_${c.uniqueId}/Texture_${S.uniqueId}_clearcoatRoughness.outputs:g>`),t.push(Vr(S,c,"clearcoatRoughness",new w.Xr(z,z,z),r,D))):B.push(`${W}float inputs:clearcoatRoughness = ${z}`)),B.push(`${W}float inputs:ior = ${y}`),`\n\tdef Material "Material_${c.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${B.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${c.uniqueId}/PreviewSurface.outputs:surface>\n\n${t.join("\n")}\n\n\t}\n`}async function rD(c,r,D){const t={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...r};"undefined"===typeof fflate&&await B.Tools.LoadScriptAsync(t.fflateUrl);const u={};u[t.modelFileName]=null;let a='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';a+=function(c){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===c.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${c.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${c.planeAnchoringAlignment}"`:""}\n            `}(t);const H={};for(const W of c.meshes){if(0===W.getTotalVertices())continue;const c=W,r=c.ka,x=c.material;if(!x||!r||D&&!D(c))continue;if(-1!==["jr","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(x.getClassName())){const D="geometries/Geometry_"+r.uniqueId+".usda";if(!(D in u)){const c=sr(r,t);u[D]=or(c)}x.uniqueId in H||(H[x.uniqueId]=x),a+=Fr(c)}else B.Tools.Warn("USDZExportAsync does not support this material type: "+x.getClassName())}c.activeCamera&&t.exportCamera&&(a+=function(c,r){const D="Camera_"+c.uniqueId,B=Qr(W.Matrix.RotationY(Math.PI).multiply(c.getWorldMatrix()));if(c.mode===y.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${D}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${B}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${c.ma.toPrecision(r.precision)}, ${c.maxZ.toPrecision(r.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(c.orthoLeft||1)+Math.abs(c.orthoRight||1))).toPrecision(r.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(c.orthoTop||1)+Math.abs(c.orthoBottom||1))).toPrecision(r.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const W=c.getEngine().getAspectRatio(c),t=r.cameraSensorWidth||35;return`def Camera "${D}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${B}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${c.ma.toPrecision(r.precision)}, ${c.maxZ.toPrecision(r.precision)})\n\t\t\tfloat focalLength = ${(t/(2*Math.tan(.5*c.fov))).toPrecision(r.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(t*W).toPrecision(r.precision)}\n\t\t\tfloat verticalAperture = ${(t/W).toPrecision(r.precision)}            \n\t\t}\n\t\n\t`}}(c.activeCamera,t)),a+="\n            }\n        }\n    }";const x={};a+=function(c,r,D){const W=[];for(const B in c){const t=c[B];W.push(cD(t,r,D))}return`\n    def "Materials"\n{\n${W.join("")}\n}\n\n`}(H,x,t),u[t.modelFileName]=fflate.strToU8(a);for(const W in x){const c=x[W],r=c.getSize(),D=await c.readPixels();if(!D)throw new Error("Texture data is not available");const B=await U.DumpTools.DumpDataAsync(r.width,r.height,D,"image/png",void 0,!1,!0);u[`textures/Texture_${W}.png`]=new Uint8Array(B).slice()}let M=0;for(const W in u){const c=u[W];if(!c)continue;M+=34+W.length;const r=63&M;if(4!==r){const D=new Uint8Array(64-r);u[W]=[c,{extra:{12345:D}}]}M=c.length}return fflate.zipSync(u,{level:0})}}}]);