"use strict";(self["3nlrbof8msu"]=self["3nlrbof8msu"]||[]).push([[26],{13146:(t,b,Z)=>{Z.r(b),Z.d(b,{EXT_materials_diffuse_roughness:()=>Nb,EXT_mesh_gpu_instancing:()=>zt,GLTF2Export:()=>xt,GLTFData:()=>Y,KHR_draco_mesh_compression:()=>Zb,KHR_lights_punctual:()=>Cb,KHR_materials_anisotropy:()=>Ib,KHR_materials_clearcoat:()=>Mb,KHR_materials_diffuse_transmission:()=>kb,KHR_materials_dispersion:()=>lb,KHR_materials_emissive_strength:()=>Eb,KHR_materials_ior:()=>Hb,KHR_materials_iridescence:()=>Ob,KHR_materials_sheen:()=>eb,KHR_materials_specular:()=>jb,KHR_materials_transmission:()=>nb,KHR_materials_unlit:()=>db,KHR_materials_volume:()=>qb,KHR_texture_transform:()=>Kb,OBJExport:()=>v,STLExport:()=>Lb,USDZExportAsync:()=>bZ,_ConvertToGLTFPBRMetallicRoughness:()=>y,_SolveMetallic:()=>n,__IGLTFExporterExtension:()=>h});var J=Z(12735),S=Z(12549),P=Z(13052);class v{static OBJ(t,b,Z,v){const h=[];let C=1,Y=1;b&&(Z||(Z="mat"),h.push("mtllib "+Z+".mtl"));for(let g=0;g<t.length;g++){const Z=t[g],I=Z.name||`mesh${g}}`;h.push(`o ${I}`);let r=null;if(v){const t=Z.sb(!0);r=new J.Matrix,t.invertToRef(r),Z.bakeTransformIntoVertices(t)}if(b){const t=Z.material;t&&h.push("usemtl "+t.id)}const M=Z.qb;if(!M){S.Tools.Warn("No geometry is present on the mesh");continue}const T=M.getVerticesData("position"),a=M.getVerticesData("normal"),k=M.getVerticesData("uv"),u=M.Qb();let l=0,U=0;if(!T||!u){S.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const E=t[0].et().useRightHandedSystem?1:-1;for(let t=0;t<T.length;t+=3)h.push("v "+T[t]*E+" "+T[t+1]+" "+T[t+2]),l++;if(null!=a)for(let t=0;t<a.length;t+=3)h.push("vn "+a[t]*E+" "+a[t+1]+" "+a[t+2]);if(null!=k)for(let t=0;t<k.length;t+=2)h.push("vt "+k[t]+" "+k[t+1]),U++;const c=["","",""],H=(Z.material||Z.et().defaultMaterial)._getEffectiveOrientation(Z),[o,O]=H===P.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let t=0;t<u.length;t+=3){const b=[String(u[t]+C),String(u[t+o]+C),String(u[t+O]+C)],Z=[String(u[t]+Y),String(u[t+o]+Y),String(u[t+O]+Y)],J=b,S=null!=k?Z:c,P=null!=a?b:c;h.push("f "+J[0]+"/"+S[0]+"/"+P[0]+" "+J[1]+"/"+S[1]+"/"+P[1]+" "+J[2]+"/"+S[2]+"/"+P[2])}v&&r&&Z.bakeTransformIntoVertices(r),C+=l,Y+=U}return h.join("\n")}static MTL(t){const b=[],Z=t.material;b.push("newmtl mat1"),b.push("  Ns "+Z.specularPower.toFixed(4)),b.push("  Ni 1.5000"),b.push("  d "+Z.alpha.toFixed(4)),b.push("  Tr 0.0000"),b.push("  Tf 1.0000 1.0000 1.0000"),b.push("  illum 2"),b.push("  Ka "+Z.ambientColor.r.toFixed(4)+" "+Z.ambientColor.g.toFixed(4)+" "+Z.ambientColor.b.toFixed(4)),b.push("  Kd "+Z.diffuseColor.r.toFixed(4)+" "+Z.diffuseColor.g.toFixed(4)+" "+Z.diffuseColor.b.toFixed(4)),b.push("  Ks "+Z.specularColor.r.toFixed(4)+" "+Z.specularColor.g.toFixed(4)+" "+Z.specularColor.b.toFixed(4)),b.push("  Ke "+Z.emissiveColor.r.toFixed(4)+" "+Z.emissiveColor.g.toFixed(4)+" "+Z.emissiveColor.b.toFixed(4));Z.ambientTexture&&b.push("  map_Ka "+Z.ambientTexture.name),Z.diffuseTexture&&b.push("  map_Kd "+Z.diffuseTexture.name),Z.specularTexture&&b.push("  map_Ks "+Z.specularTexture.name),Z.bumpTexture&&b.push("  map_bump -imfchan z "+Z.bumpTexture.name),Z.opacityTexture&&b.push("  map_d "+Z.opacityTexture.name);return b.join("\n")}}var h=0,C=Z(12593);class Y{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const t in this.files){const b=this.files[t],Z=new Blob([b],{type:(0,C.i)(t)});S.Tools.Download(Z,t)}}}var g=Z(12800),I=Z(13152),r=Z(13159),M=Z(13178),T=Z(12860),a=Z(12585),k=Z(12775),u=Z(12745);const l=u.HighestCommonFactor,U={...u,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:l};var E=Z(12964),c=Z(12716),H=Z(13208),o=Z(13214),O=Z(12955);const p=1e-6,e=new k.hZ(.04,.04,.04),W=1024,j=k.hZ.White(),V=k.hZ.Black();function n(t,b,Z){if(b<e.r)return 0;const J=e.r,S=t*Z/(1-e.r)+b-2*e.r,P=S*S-4*J*(e.r-b);return U.Clamp((-S+Math.sqrt(P))/(2*J),0,1)}function y(t){const b=t.diffuseColor.toLinearSpace(t.et().getEngine().useExactSrgbConversions).scale(.5),Z=t.alpha,S=function(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new J.Vector2(0,1),Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new J.Vector2(0,.1),S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new J.Vector2(0,.1),P=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new J.Vector2(1300,.1);return function(t,b,Z,J,S){return(1-t)*(1-t)*(1-t)*b+3*(1-t)*(1-t)*t*Z+3*(1-t)*t*t*J+t*t*t*S}(Math.pow(t/P.x,.333333),b.y,Z.y,S.y,P.y)}(U.Clamp(t.specularPower,0,W));return{baseColorFactor:[b.r,b.g,b.b,Z],metallicFactor:0,roughnessFactor:S}}function d(t,b){b.needAlphaBlending()?t.alphaMode="BLEND":b.needAlphaTesting()&&(t.alphaMode="MASK",t.alphaCutoff=b.alphaCutOff)}function s(t,b,Z){const J=new Uint8Array(t*b*4);for(let S=0;S<J.length;S+=4)J[S]=J[S+1]=J[S+2]=J[S+3]=255;return H.c.CreateRGBATexture(J,t,b,Z)}function q(t){if(t instanceof Uint8Array){const b=t.length,Z=new Float32Array(t.length);for(let J=0;J<b;++J)Z[J]=t[J]/255;return Z}if(t instanceof Float32Array)return t;throw new Error("Unsupported pixel format!")}class Q{constructor(t){this._exporter=t,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(t){return t?this._textureMap.get(t)??null:null}async exportStandardMaterialAsync(t,b,Z){const J=y(t),P={name:t.name};if(null==t.Nb||t.Nb||(t.twoSidedLighting||S.Tools.Warn(t.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),P.doubleSided=!0),Z){const Z=[],S=t.diffuseTexture;S&&Z.push(this.exportTextureAsync(S,b).then((t=>{t&&(J.baseColorTexture=t)})));const v=t.bumpTexture;v&&Z.push(this.exportTextureAsync(v,b).then((t=>{t&&(P.normalTexture=t,1!==v.level&&(P.normalTexture.scale=v.level))})));const h=t.emissiveTexture;h&&(P.emissiveFactor=[1,1,1],Z.push(this.exportTextureAsync(h,b).then((t=>{t&&(P.emissiveTexture=t)}))));const C=t.ambientTexture;C&&Z.push(this.exportTextureAsync(C,b).then((t=>{if(t){const b={index:t.index};P.occlusionTexture=b}}))),Z.length>0&&(this._exporter._materialNeedsUVsSet.add(t),await Promise.all(Z))}(t.alpha<1||t.opacityTexture)&&(t.alphaMode===o.c.ALPHA_COMBINE?P.alphaMode="BLEND":S.Tools.Warn(t.name+": glTF 2.0 does not support alpha mode: "+t.alphaMode.toString())),t.emissiveColor&&!t.emissiveColor.equalsWithEpsilon(V,p)&&(P.emissiveFactor=t.emissiveColor.jb()),P.pbrMetallicRoughness=J,d(P,t),await this._finishMaterialAsync(P,t,b);const v=this._exporter._materials;return v.push(P),v.length-1}async _finishMaterialAsync(t,b,Z){const J=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",t,b),S=[];for(const P of J)S.push(this.exportTextureAsync(P,Z));await Promise.all(S),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",t,b)}async _getImageDataAsync(t,b,J,S){const P=o.c.TEXTURETYPE_UNSIGNED_BYTE,v=this._exporter._babylonScene,h=v.getEngine(),C=h.createRawTexture(t,b,J,o.c.TEXTUREFORMAT_RGBA,!1,!0,c.c.NEAREST_SAMPLINGMODE,null,P);h.isWebGPU?await Z.e(51).then(Z.bind(Z,15203)):await Z.e(52).then(Z.bind(Z,15205)),await E.j.ApplyPostProcess("pass",C,v,P,o.c.TEXTURE_NEAREST_SAMPLINGMODE,o.c.TEXTUREFORMAT_RGBA);const Y=await h._readTexturePixels(C,b,J);return await O.DumpTools.DumpDataAsync(b,J,Y,S,void 0,!0,!0)}_resizeTexturesToSameDimensions(t,b,Z){const J=t?t.getSize():{width:0,height:0},S=b?b.getSize():{width:0,height:0};let P,v;return J.width<S.width?(P=t&&t instanceof c.c?E.j.CreateResizedCopy(t,S.width,S.height,!0):s(S.width,S.height,Z),v=b):J.width>S.width?(v=b&&b instanceof c.c?E.j.CreateResizedCopy(b,J.width,J.height,!0):s(J.width,J.height,Z),P=t):(P=t,v=b),{texture1:P,texture2:v}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(t,b,Z,J){const S=new Array;if(!t&&!b)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const P=t?t.et():b?b.et():null;if(P){var v;const h=this._resizeTexturesToSameDimensions(t,b,P),C=null===(v=h.texture1)||void 0===v?void 0:v.getSize();let Y,g;const I=C.width,r=C.height,M=await h.texture1.readPixels(),T=await h.texture2.readPixels();if(!M)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(Y=q(M),!T)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");g=q(T);const a=g.byteLength,u=new Uint8Array(a),l=new Uint8Array(a),U=4,E=V;let c=0,H=0;for(let t=0;t<r;++t)for(let b=0;b<I;++b){const J=(I*t+b)*U,S={diffuseColor:new k.hZ(Y[J],Y[J+1],Y[J+2]).toLinearSpace(P.getEngine().useExactSrgbConversions).multiply(Z.diffuseColor),specularColor:new k.hZ(g[J],g[J+1],g[J+2]).toLinearSpace(P.getEngine().useExactSrgbConversions).multiply(Z.specularColor),glossiness:g[J+3]*Z.glossiness},v=this._convertSpecularGlossinessToMetallicRoughness(S);E.r=Math.max(E.r,v.baseColor.r),E.g=Math.max(E.g,v.baseColor.g),E.b=Math.max(E.b,v.baseColor.b),c=Math.max(c,v.metallic),H=Math.max(H,v.roughness),l[J]=255*v.baseColor.r,l[J+1]=255*v.baseColor.g,l[J+2]=255*v.baseColor.b,l[J+3]=h.texture1.Vb?255*Y[J+3]:255,u[J]=0,u[J+1]=255*v.roughness,u[J+2]=255*v.metallic,u[J+3]=255}const o={baseColor:E,metallic:c,roughness:H};let O=!1,e=!1;for(let t=0;t<r;++t)for(let b=0;b<I;++b){const Z=(I*t+b)*U;l[Z]/=o.baseColor.r>p?o.baseColor.r:1,l[Z+1]/=o.baseColor.g>p?o.baseColor.g:1,l[Z+2]/=o.baseColor.b>p?o.baseColor.b:1;const J=k.hZ.FromInts(l[Z],l[Z+1],l[Z+2]).toGammaSpace(P.getEngine().useExactSrgbConversions);l[Z]=255*J.r,l[Z+1]=255*J.g,l[Z+2]=255*J.b,J.equalsWithEpsilon(j,p)||(e=!0),u[Z+1]/=o.roughness>p?o.roughness:1,u[Z+2]/=o.metallic>p?o.metallic:1;k.hZ.FromInts(255,u[Z+1],u[Z+2]).equalsWithEpsilon(j,p)||(O=!0)}return O&&S.push(this._getImageDataAsync(u,I,r,J).then((t=>{o.metallicRoughnessTextureData=t}))),e&&S.push(this._getImageDataAsync(l,I,r,J).then((t=>{o.baseColorTextureData=t}))),await Promise.all(S).then((()=>o))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(t){const b=this._getPerceivedBrightness(t.diffuseColor),Z=this._getPerceivedBrightness(t.specularColor),J=1-this._getMaxComponent(t.specularColor),S=n(b,Z,J),P=t.diffuseColor.scale(J/(1-e.r)/Math.max(1-S)),v=t.specularColor.SZ(e.scale(1-S)).scale(1/Math.max(S));let h=k.hZ.Lerp(P,v,S*S);h=h.clampToRef(0,1,h);return{baseColor:h,metallic:S,roughness:1-t.glossiness}}_getPerceivedBrightness(t){return t?Math.sqrt(.299*t.r*t.r+.587*t.g*t.g+.114*t.b*t.b):0}_getMaxComponent(t){return t?Math.max(t.r,Math.max(t.g,t.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(t,b,Z,J){const S=[],P={baseColor:t._albedoColor,metallic:t._metallic,roughness:t._roughness};if(J){t._albedoTexture&&S.push(this.exportTextureAsync(t._albedoTexture,b).then((t=>{t&&(Z.baseColorTexture=t)})));const J=t._metallicTexture;J&&S.push(this.exportTextureAsync(J,b).then((t=>{t&&(Z.metallicRoughnessTexture=t)})))}return S.length>0&&(this._exporter._materialNeedsUVsSet.add(t),await Promise.all(S)),P}_getTextureSampler(t){const b={};if(!t||!(t instanceof c.c))return b;const Z=this._getGLTFTextureWrapMode(t.wrapU);10497!==Z&&(b.wrapS=Z);const J=this._getGLTFTextureWrapMode(t.wrapV);switch(10497!==J&&(b.wrapT=J),t.samplingMode){case c.c.LINEAR_LINEAR:b.magFilter=9729,b.minFilter=9729;break;case c.c.LINEAR_NEAREST:b.magFilter=9729,b.minFilter=9728;break;case c.c.NEAREST_LINEAR:b.magFilter=9728,b.minFilter=9729;break;case c.c.NEAREST_LINEAR_MIPLINEAR:b.magFilter=9728,b.minFilter=9987;break;case c.c.NEAREST_NEAREST:b.magFilter=9728,b.minFilter=9728;break;case c.c.NEAREST_LINEAR_MIPNEAREST:b.magFilter=9728,b.minFilter=9985;break;case c.c.LINEAR_NEAREST_MIPNEAREST:b.magFilter=9729,b.minFilter=9984;break;case c.c.LINEAR_NEAREST_MIPLINEAR:b.magFilter=9729,b.minFilter=9986;break;case c.c.NEAREST_NEAREST_MIPLINEAR:b.magFilter=9728,b.minFilter=9986;break;case c.c.LINEAR_LINEAR_MIPLINEAR:b.magFilter=9729,b.minFilter=9987;break;case c.c.LINEAR_LINEAR_MIPNEAREST:b.magFilter=9729,b.minFilter=9985;break;case c.c.NEAREST_NEAREST_MIPNEAREST:b.magFilter=9728,b.minFilter=9984}return b}_getGLTFTextureWrapMode(t){switch(t){case c.c.WRAP_ADDRESSMODE:return 10497;case c.c.CLAMP_ADDRESSMODE:return 33071;case c.c.MIRROR_ADDRESSMODE:return 33648;default:return S.Tools.Error(`Unsupported Texture Wrap Mode ${t}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(t,b,Z,J){const S={diffuseColor:t._albedoColor,specularColor:t._reflectivityColor,glossiness:t._microSurface},P=t._albedoTexture,v=t._reflectivityTexture,h=t._useMicroSurfaceFromReflectivityMapAlpha;if(v&&!h)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((P||v)&&J){this._exporter._materialNeedsUVsSet.add(t);const J=this._exportTextureSampler(P||v),h=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(P,v,S,b),C=this._exporter._textures;if(h.baseColorTextureData){const t=this._exportImage(`baseColor${C.length}`,b,h.baseColorTextureData);Z.baseColorTexture=this._exportTextureInfo(t,J,null===P||void 0===P?void 0:P.coordinatesIndex)}if(h.metallicRoughnessTextureData){const t=this._exportImage(`metallicRoughness${C.length}`,b,h.metallicRoughnessTextureData);Z.metallicRoughnessTexture=this._exportTextureInfo(t,J,null===v||void 0===v?void 0:v.coordinatesIndex)}return h}return this._convertSpecularGlossinessToMetallicRoughness(S)}async exportPBRMaterialAsync(t,b,Z){const J={},S={name:t.name},P=t.isMetallicWorkflow();if(P){const b=t._albedoColor,Z=t.alpha;b&&(J.baseColorFactor=[b.r,b.g,b.b,Z])}const v=P?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(t,b,J,Z):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(t,b,J,Z);await this._setMetallicRoughnessPbrMaterialAsync(v,t,S,J,b,Z),await this._finishMaterialAsync(S,t,b);const h=this._exporter._materials;return h.push(S),h.length-1}async _setMetallicRoughnessPbrMaterialAsync(t,b,Z,J,P,v){if(d(Z,b),t.baseColor.equalsWithEpsilon(j,p)&&U.WithinEpsilon(b.alpha,1,p)||(J.baseColorFactor=[t.baseColor.r,t.baseColor.g,t.baseColor.b,b.alpha]),null!=t.metallic&&1!==t.metallic&&(J.metallicFactor=t.metallic),null!=t.roughness&&1!==t.roughness&&(J.roughnessFactor=t.roughness),null==b.Nb||b.Nb||(b._twoSidedLighting||S.Tools.Warn(b.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Z.doubleSided=!0),v){const t=[],J=b._bumpTexture;J&&t.push(this.exportTextureAsync(J,P).then((t=>{t&&(Z.normalTexture=t,1!==J.level&&(Z.normalTexture.scale=J.level))})));const S=b._ambientTexture;S&&t.push(this.exportTextureAsync(S,P).then((t=>{if(t){const J={index:t.index,texCoord:t.texCoord,extensions:t.extensions};Z.occlusionTexture=J;const S=b._ambientTextureStrength;S&&(J.strength=S)}})));const v=b._emissiveTexture;v&&t.push(this.exportTextureAsync(v,P).then((t=>{t&&(Z.emissiveTexture=t)}))),t.length>0&&(this._exporter._materialNeedsUVsSet.add(b),await Promise.all(t))}const h=b._emissiveColor;h.equalsWithEpsilon(V,p)||(Z.emissiveFactor=h.jb()),Z.pbrMetallicRoughness=J}_getPixelsFromTextureAsync(t){return function(t){switch(t){case o.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case o.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case o.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case o.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case o.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case o.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case o.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case o.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case o.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case o.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case o.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case o.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(t.textureFormat)?(0,E.i)(t,t._texture.width,t._texture.height):(t.textureType,o.c.TEXTURETYPE_UNSIGNED_BYTE,t.readPixels())}async exportTextureAsync(t,b){const Z=this._exporter._extensionsPreExportTextureAsync("exporter",t,b);return Z?await Z.then((async Z=>Z?await this._exportTextureInfoAsync(Z,b):await this._exportTextureInfoAsync(t,b))):await this._exportTextureInfoAsync(t,b)}async _exportTextureInfoAsync(t,b){let Z=this._textureMap.get(t);if(!Z){const J=await this._getPixelsFromTextureAsync(t);if(!J)return null;const P=this._exportTextureSampler(t),v=t.mimeType;if(v)switch(v){case"image/jpeg":case"image/png":case"image/webp":b=v;break;default:S.Tools.Warn(`Unsupported media type: ${v}. Exporting texture as PNG.`)}const h=this._internalTextureToImage,C=t.getInternalTexture().uniqueId;h[C]||(h[C]={});let Y=h[C][b];if(void 0===Y){const Z=t.getSize();Y=(async()=>{const S=await this._getImageDataAsync(J,Z.width,Z.height,b);return this._exportImage(t.name,b,S)})(),h[C][b]=Y}Z=this._exportTextureInfo(await Y,P,t.coordinatesIndex),this._textureMap.set(t,Z),this._exporter._extensionsPostExportTextures("exporter",Z,t)}return Z}_exportImage(t,b,Z){const J=this._exporter._images;let P;if(this._exporter._shouldUseGlb){P={name:t,mimeType:b,bufferView:void 0};const J=this._exporter._bufferManager.createBufferView(new Uint8Array(Z));this._exporter._bufferManager.setBufferView(P,J)}else{const v=t.replace(/\.\/|\/|\.\\|\\/g,"_"),h=function(t){switch(t){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(b);let C=v+h;J.some((t=>t.uri===C))&&(C=`${v}_${S.Tools.RandomId()}${h}`),P={name:t,uri:C},this._exporter._imageData[C]={data:Z,mimeType:b}}return J.push(P),J.length-1}_exportTextureInfo(t,b,Z){const J=this._exporter._textures;let S=J.findIndex((Z=>Z.sampler==b&&Z.source===t));-1===S&&(S=J.length,J.push({source:t,sampler:b}));const P={index:S};return Z&&(P.texCoord=Z),P}_exportTextureSampler(t){const b=this._getTextureSampler(t),Z=this._exporter._samplers,J=Z.findIndex((t=>t.minFilter===b.minFilter&&t.magFilter===b.magFilter&&t.wrapS===b.wrapS&&t.wrapT===b.wrapT));return-1!==J?J:(Z.push(b),Z.length-1)}}var N=Z(12810),A=Z(12557),K=Z(13222),L=Z(12737);const F=J.JZ.Zero(),B=J.Quaternion.Identity(),X=J.JZ.One(),x=new J.JZ(-1,1,1);function i(t,b){const{byteOffset:Z,byteStride:J,type:S,normalized:P}=t,v=t.getSize(),h=b.reduce(((t,b)=>b.getTotalVertices()>t?b.getTotalVertices():t),-Number.MAX_VALUE);return{byteOffset:Z,byteStride:J,componentCount:v,type:S,count:h*v,normalized:P,totalVertices:h,kind:t.getKind()}}function z(t){switch(t){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function D(t){switch(t){case g.g.PositionKind:case g.g.NormalKind:case g.g.TangentKind:case g.g.ColorKind:case g.g.MatricesIndicesKind:case g.g.MatricesIndicesExtraKind:case g.g.MatricesWeightsKind:case g.g.MatricesWeightsExtraKind:case g.g.UVKind:case g.g.UV2Kind:case g.g.UV3Kind:case g.g.UV4Kind:case g.g.UV5Kind:case g.g.UV6Kind:return!0}return!1}function f(t){switch(t){case P.c.TriangleFillMode:return 4;case P.c.TriangleStripDrawMode:return 5;case P.c.TriangleFanDrawMode:return 6;case P.c.PointListDrawMode:case P.c.PointFillMode:return 0;case P.c.LineLoopDrawMode:return 2;case P.c.LineListDrawMode:return 1;case P.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${t}`)}function mt(t){const b=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z);b>0&&(t.x/=b,t.y/=b,t.z/=b)}function R(t){return t.x*=-1,t}function w(t){if(t.x*t.x+t.y*t.y>.5){const b=Math.abs(t.x),Z=Math.abs(t.y);if(b>Z){const Z=Math.sign(t.x);t.x=b,t.y*=-Z,t.z*=-Z,t.w*=Z}else{const b=Math.sign(t.y);t.x*=-b,t.y=Z,t.z*=b,t.w*=-b}}else{const b=Math.abs(t.z),Z=Math.abs(t.w);if(b>Z){const Z=Math.sign(t.z);t.x*=-Z,t.y*=Z,t.z=b,t.w*=-Z}else{const b=Math.sign(t.w);t.x*=b,t.y*=-b,t.z*=-b,t.w=Z}}return t}function G(t){t.Ab(-t.z,t.w,t.x,-t.y)}function tt(t,b){const Z=J.JZ.FromArrayToRef(b.translation||[0,0,0],0,J.TmpVectors.JZ[0]),S=J.Quaternion.FromArrayToRef(b.rotation||[0,0,0,1],0,J.TmpVectors.Quaternion[0]),P=J.Matrix.ComposeToRef(X,S,Z,J.TmpVectors.Matrix[0]),v=J.JZ.FromArrayToRef(t.translation||[0,0,0],0,J.TmpVectors.JZ[2]),h=J.Quaternion.FromArrayToRef(t.rotation||[0,0,0,1],0,J.TmpVectors.Quaternion[1]),C=J.Matrix.ComposeToRef(X,h,v,J.TmpVectors.Matrix[1]);P.multiplyToRef(C,C),C.decompose(void 0,S,Z),Z.equalsWithEpsilon(F,L.e)?delete b.translation:b.translation=Z.jb(),S.equalsWithEpsilon(B,L.e)?delete b.rotation:b.rotation=S.jb(),b.scale&&delete b.scale}function bt(t,b){if(!(b instanceof I.e))return!1;if(!(1===b.getChildren().length&&0===t.getChildren().length&&t.parent===b))return!1;const Z=t.et(),J=t instanceof K.b&&!Z.useRightHandedSystem?x:X;return!!b.Kb.equalsWithEpsilon(J,L.e)||(A.c.Warn(`Cannot collapse node ${t.name} into parent node ${b.name} with modified scaling.`),!1)}function Zt(t){if(t instanceof Array){const b=new Float32Array(t);return new Uint8Array(b.buffer,b.byteOffset,b.byteLength)}return ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t)}function Jt(t,b){for(const[Z,J]of Object.entries(t)){const S=b[Z];(Array.isArray(J)&&Array.isArray(S)&&St(J,S)||J===S)&&delete t[Z]}return t}function St(t,b){return t.length===b.length&&t.every(((t,Z)=>t===b[Z]))}const Pt=J.Matrix.Compose(new J.JZ(-1,1,1),J.Quaternion.Identity(),J.JZ.Zero());function vt(t,b){if(!(t instanceof I.e))return!1;if(b){if(!t.getWorldMatrix().equalsWithEpsilon(J.Matrix.IdentityReadOnly,L.e))return!1}else{if(!t.getWorldMatrix().multiplyToRef(Pt,J.TmpVectors.Matrix[0]).equalsWithEpsilon(J.Matrix.IdentityReadOnly,L.e))return!1}return!(t instanceof r.b&&t.qb)}const ht=new Map([[Int8Array,(t,b,Z)=>t.setInt8(b,Z)],[Uint8Array,(t,b,Z)=>t.setUint8(b,Z)],[Uint8ClampedArray,(t,b,Z)=>t.setUint8(b,Z)],[Int16Array,(t,b,Z)=>t.setInt16(b,Z,!0)],[Uint16Array,(t,b,Z)=>t.setUint16(b,Z,!0)],[Int32Array,(t,b,Z)=>t.setInt32(b,Z,!0)],[Uint32Array,(t,b,Z)=>t.setUint32(b,Z,!0)],[Float32Array,(t,b,Z)=>t.setFloat32(b,Z,!0)],[Float64Array,(t,b,Z)=>t.setFloat64(b,Z,!0)]]);class Ct{writeTypedArray(t){this._checkGrowBuffer(t.byteLength);const b=ht.get(t.constructor);for(let Z=0;Z<t.length;Z++)b(this._dataView,this._byteOffset,t[Z]),this._byteOffset+=t.BYTES_PER_ELEMENT}constructor(t){this._data=new Uint8Array(t),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(t){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,t),this._byteOffset++}writeInt8(t){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,t),this._byteOffset++}writeInt16(t){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,t,!0),this._byteOffset+=2}writeUInt16(t){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,t,!0),this._byteOffset+=2}writeInt32(t){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,t,!0),this._byteOffset+=4}writeUInt32(t){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,t,!0),this._byteOffset+=4}writeFloat32(t){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,t,!0),this._byteOffset+=4}writeFloat64(t){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,t,!0),this._byteOffset+=8}_checkGrowBuffer(t){const b=this.byteOffset+t;if(b>this._data.byteLength){const t=new Uint8Array(2*b);t.set(this._data),this._data=t,this._dataView=new DataView(this._data.buffer)}}}function Yt(t){return t%4===0?4:t%2===0?2:1}class gt{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(t){let b=0;this._bufferViewToData.forEach((t=>{b+=t.byteLength}));const Z=new Ct(b),J=Array.from(this._bufferViewToData.keys()).sort(((t,b)=>Yt(b.byteLength)-Yt(t.byteLength)));for(const S of J){S.byteOffset=Z.byteOffset,t.push(S);const b=t.length-1,J=this.getPropertiesWithBufferView(S);for(const t of J)t.bufferView=b;Z.writeTypedArray(this._bufferViewToData.get(S)),this._bufferViewToData.delete(S)}return Z.getOutputData()}createBufferView(t,b){const Z={buffer:0,byteOffset:void 0,byteLength:t.byteLength,byteStride:b};return this._bufferViewToData.set(Z,t),Z}createAccessor(t,b,Z,J,S,P,v){this._verifyBufferView(t);const h={bufferView:void 0,componentType:Z,count:J,type:b,min:null===P||void 0===P?void 0:P.min,max:null===P||void 0===P?void 0:P.max,normalized:v,byteOffset:S};return this.setBufferView(h,t),this._accessorToBufferView.set(h,t),h}setBufferView(t,b){this._verifyBufferView(b);this.getPropertiesWithBufferView(b).push(t)}removeBufferView(t){const b=this.getPropertiesWithBufferView(t);for(const Z of b)void 0!==Z.bufferView&&delete Z.bufferView;this._bufferViewToData.delete(t),this._bufferViewToProperties.delete(t),this._accessorToBufferView.forEach(((b,Z)=>{b===t&&(void 0!==Z.byteOffset&&delete Z.byteOffset,this._accessorToBufferView.delete(Z))}))}getBufferView(t){const b=this._accessorToBufferView.get(t);return this._verifyBufferView(b),b}getPropertiesWithBufferView(t){return this._verifyBufferView(t),this._bufferViewToProperties.set(t,this._bufferViewToProperties.get(t)??[]),this._bufferViewToProperties.get(t)}getData(t){return this._verifyBufferView(t),this._bufferViewToData.get(t)}_verifyBufferView(t){if(void 0===t||!this._bufferViewToData.has(t))throw new Error(`BufferView ${t} not found in BufferManager.`)}}var It,rt=Z(13193),Mt=Z(13200),Tt=Z(13225),at=Z(13113),kt=Z(13261),ut=Z(13270),lt=Z(13184),Ut=Z(13272);!function(t){t[t.INTANGENT=0]="INTANGENT",t[t.OUTTANGENT=1]="OUTTANGENT"}(It||(It={}));class Et{static _IsTransformable(t){return t&&(t instanceof I.e||t instanceof rt.e||t instanceof Ut.d)}static _CreateNodeAnimation(t,b,Z,J,P){if(this._IsTransformable(t)){const v=[],h=[],C=b.getKeys(),Y=Et._CalculateMinMaxKeyFrames(C),g=Et._DeduceInterpolation(C,Z,J),I=g.interpolationType,r=g.shouldBakeAnimation;if(r?Et._CreateBakedAnimation(t,b,Z,Y.min,Y.max,b.framePerSecond,P,v,h,Y,J):"LINEAR"===I||"STEP"===I?Et._CreateLinearOrStepAnimation(t,b,Z,v,h,J):"CUBICSPLINE"===I?Et._CreateCubicSplineAnimation(t,b,Z,v,h,J):Et._CreateBakedAnimation(t,b,Z,Y.min,Y.max,b.framePerSecond,P,v,h,Y,J),v.length&&h.length){return{inputs:v,outputs:h,samplerInterpolation:I,inputsMin:r?Y.min:S.Tools.FloatRound(Y.min/b.framePerSecond),inputsMax:r?Y.max:S.Tools.FloatRound(Y.max/b.framePerSecond)}}}return null}static _DeduceAnimationInfo(t){let b=null,Z="VEC3",J=!1;const P=t.targetProperty.split(".");switch(P[0]){case"Kb":b="scale";break;case"position":b="translation";break;case"rotation":Z="VEC4",b="rotation";break;case"rotationQuaternion":Z="VEC4",J=!0,b="rotation";break;case"influence":Z="SCALAR",b="weights";break;default:S.Tools.Error(`Unsupported animatable property ${P[0]}`)}return b?{animationChannelTargetPath:b,dataAccessorType:Z,useQuaternion:J}:(S.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(t,b,Z,J,S,P,v,h,C,Y,g){let I;if(Et._IsTransformable(t)&&t.animations)for(const r of t.animations){if(g&&!g(r))continue;const S=Et._DeduceAnimationInfo(r);S&&(I={name:r.name,samplers:[],channels:[]},Et._AddAnimation(`${r.name}`,r.hasRunningRuntimeAnimations?b:I,t,r,S.dataAccessorType,S.animationChannelTargetPath,J,P,v,h,S.useQuaternion,C,Y),I.samplers.length&&I.channels.length&&Z.push(I))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(t,b,Z,J,S,P,v,h,C,Y,g){let I;if(t instanceof lt.b){const S=t.morphTargetManager;if(S)for(let r=0;r<S.numTargets;++r){const M=S.getTarget(r);for(const T of M.animations){if(g&&!g(T))continue;const M=new kt.d(`${T.name}`,"influence",T.framePerSecond,T.dataType,T.loopMode,T.enableBlending),a=[],k=T.getKeys();for(let t=0;t<k.length;++t){const b=k[t];for(let t=0;t<S.numTargets;++t)t==r?a.push(b):a.push({frame:b.frame,value:0})}M.setKeys(a);const u=Et._DeduceAnimationInfo(M);u&&(I={name:M.name,samplers:[],channels:[]},Et._AddAnimation(T.name,T.hasRunningRuntimeAnimations?b:I,t,M,u.dataAccessorType,u.animationChannelTargetPath,J,P,v,h,u.useQuaternion,C,Y,S.numTargets),I.samplers.length&&I.channels.length&&Z.push(I))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(t,b,Z,J,S,P,v,h,C){let Y;if(t.animationGroups){const I=t.animationGroups;for(const r of I){const I=new Map,M=new Map,T=new Set,a=r.to-r.from;Y={name:r.name,channels:[],samplers:[]};for(let b=0;b<r.targetedAnimations.length;++b){const a=r.targetedAnimations[b],k=a.target,u=a.animation;if(C&&!C(u))continue;const l=h.has(k);if(this._IsTransformable(k)||1===k.length&&this._IsTransformable(k[0])){const t=Et._DeduceAnimationInfo(a.animation);if(t){const b=this._IsTransformable(k)?k:this._IsTransformable(k[0])?k[0]:null;b&&Et._AddAnimation(`${u.name}`,Y,b,u,t.dataAccessorType,t.animationChannelTargetPath,Z,J,S,P,t.useQuaternion,v,l)}}else if(k instanceof ut.d||1===k.length&&k[0]instanceof ut.d){if(Et._DeduceAnimationInfo(a.animation)){const b=k instanceof ut.d?k:k[0];if(b){const Z=t.morphTargetManagers.find((t=>{for(let Z=0;Z<t.numTargets;++Z)if(t.getTarget(Z)===b)return!0;return!1}));if(Z){const J=t.meshes.find((t=>t.morphTargetManager===Z));var g;if(J)I.has(J)||I.set(J,new Map),null===(g=I.get(J))||void 0===g||g.set(b,u),T.add(J),M.set(J,u)}}}}}T.forEach((t=>{const b=t.morphTargetManager;let h=null;const C=[],g=M.get(t).getKeys(),T=g.length;for(let Z=0;Z<T;++Z)for(let J=0;J<b.numTargets;++J){const S=b.getTarget(J),P=I.get(t);if(P){const b=P.get(S);b?(h||(h=new kt.d(`${r.name}_${t.name}_MorphWeightAnimation`,"influence",b.framePerSecond,kt.d.ANIMATIONTYPE_FLOAT,b.loopMode,b.enableBlending)),C.push(b.getKeys()[Z])):C.push({frame:r.from+a/T*Z,value:S.influence,inTangent:g[0].inTangent?0:void 0,outTangent:g[0].outTangent?0:void 0})}}h.setKeys(C);const k=Et._DeduceAnimationInfo(h);k&&Et._AddAnimation(`${r.name}_${t.name}_MorphWeightAnimation`,Y,t,h,k.dataAccessorType,k.animationChannelTargetPath,Z,J,S,P,k.useQuaternion,v,!1,null===b||void 0===b?void 0:b.numTargets)})),Y.channels.length&&Y.samplers.length&&b.push(Y)}}}static _AddAnimation(t,b,Z,S,P,v,h,C,Y,g,I,r,M,T){const a=Et._CreateNodeAnimation(Z,S,v,I,r);let k,u,l,U,E,c;if(a){if(T){let t=0,b=0;const Z=[];for(;a.inputs.length>0;)b=a.inputs.shift(),t%T==0&&Z.push(b),t++;a.inputs=Z}const t=h.get(Z),S=new Float32Array(a.inputs);k=C.createBufferView(S),u=C.createAccessor(k,"SCALAR",5126,a.inputs.length,void 0,{min:[a.inputsMin],max:[a.inputsMax]}),g.push(u),l=g.length-1;const Y=new J.Quaternion,I=new J.JZ,r=new J.JZ,H=Z instanceof rt.e,o=z(P),O=new Float32Array(a.outputs.length*o);a.outputs.forEach((function(t,b){let Z=t;switch(v){case"translation":M&&(J.JZ.FromArrayToRef(t,0,r),R(r),r.toArray(Z));break;case"rotation":4===t.length?J.Quaternion.FromArrayToRef(t,0,Y):(Z=new Array(4),J.JZ.FromArrayToRef(t,0,I),J.Quaternion.FromEulerVectorToRef(I,Y)),M&&(w(Y),H&&G(Y)),Y.toArray(Z)}O.set(Z,b*o)})),k=C.createBufferView(O),u=C.createAccessor(k,P,5126,a.outputs.length),g.push(u),U=g.length-1,E={interpolation:a.samplerInterpolation,input:l,output:U},b.samplers.push(E),c={sampler:b.samplers.length-1,target:{node:t,path:v}},b.channels.push(c)}}static _CreateBakedAnimation(t,b,Z,P,v,h,C,Y,g,I,r){let M;const T=J.Quaternion.Identity();let a,k=null,u=null,l=null,U=null,E=null,c=null;I.min=S.Tools.FloatRound(P/h);const H=b.getKeys();for(let J=0,o=H.length;J<o;++J){if(c=null,l=H[J],J+1<o)if(U=H[J+1],l.value.equals&&l.value.equals(U.value)||l.value===U.value){if(0!==J)continue;c=l.frame}else c=U.frame;else{if(E=H[J-1],l.value.equals&&l.value.equals(E.value)||l.value===E.value)continue;c=v}if(c)for(let J=l.frame;J<=c;J+=C){if(a=S.Tools.FloatRound(J/h),a===k)continue;k=a,u=a;const P={key:0,repeatCount:0,loopMode:b.loopMode};M=b._interpolate(J,P),Et._SetInterpolatedValue(t,M,a,b,Z,T,Y,g,r)}}u&&(I.max=u)}static _ConvertFactorToVector3OrQuaternion(t,b,Z,P,v){const h=Et._GetBasePositionRotationOrScale(b,P,v),C=Z.targetProperty.split("."),Y=C?C[1]:"",g=v?J.Quaternion.CZ(h).normalize():J.JZ.CZ(h);switch(Y){case"x":case"y":case"z":g[Y]=t;break;case"w":g.w=t;break;default:S.Tools.Error(`glTFAnimation: Unsupported component name "${Y}"!`)}return g}static _SetInterpolatedValue(t,b,Z,S,P,v,h,C,Y){let g;h.push(Z),"weights"!==P?(S.dataType===kt.d.ANIMATIONTYPE_FLOAT&&(b=this._ConvertFactorToVector3OrQuaternion(b,t,S,P,Y)),"rotation"===P?(Y?v=b:(g=b,J.Quaternion.RotationYawPitchRollToRef(g.y,g.x,g.z,v)),C.push(v.jb())):(g=b,C.push(g.jb()))):C.push([b])}static _CreateLinearOrStepAnimation(t,b,Z,J,S,P){for(const v of b.getKeys())J.push(v.frame/b.framePerSecond),Et._AddKeyframeValue(v,b,S,Z,t,P)}static _CreateCubicSplineAnimation(t,b,Z,J,S,P){b.getKeys().forEach((function(v){J.push(v.frame/b.framePerSecond),Et._AddSplineTangent(It.INTANGENT,S,Z,"CUBICSPLINE",v,P),Et._AddKeyframeValue(v,b,S,Z,t,P),Et._AddSplineTangent(It.OUTTANGENT,S,Z,"CUBICSPLINE",v,P)}))}static _GetBasePositionRotationOrScale(t,b,Z){let S;if("rotation"===b)if(Z){S=(t.rotationQuaternion??J.Quaternion.Identity()).jb()}else{S=(t.rotation??J.JZ.Zero()).jb()}else if("translation"===b){S=(t.position??J.JZ.Zero()).jb()}else{S=(t.Kb??J.JZ.One()).jb()}return S}static _AddKeyframeValue(t,b,Z,P,v,h){let C;const Y=b.dataType;if(Y===kt.d.ANIMATIONTYPE_VECTOR3){let b=t.value.jb();if("rotation"===P){const t=J.JZ.CZ(b);b=J.Quaternion.RotationYawPitchRoll(t.y,t.x,t.z).jb()}Z.push(b)}else if(Y===kt.d.ANIMATIONTYPE_FLOAT){if("weights"===P)Z.push([t.value]);else if(C=this._ConvertFactorToVector3OrQuaternion(t.value,v,b,P,h),C){if("rotation"===P){const t=h?C:J.Quaternion.RotationYawPitchRoll(C.y,C.x,C.z).normalize();Z.push(t.jb())}Z.push(C.jb())}}else Y===kt.d.ANIMATIONTYPE_QUATERNION?Z.push(t.value.normalize().jb()):S.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(t,b,Z){let J,S,P=!1;if("rotation"===b&&!Z)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let v=0,h=t.length;v<h;++v)if(S=t[v],S.inTangent||S.outTangent)if(J){if("CUBICSPLINE"!==J){J="LINEAR",P=!0;break}}else J="CUBICSPLINE";else if(J){if("CUBICSPLINE"===J||S.interpolation&&1===S.interpolation&&"STEP"!==J){J="LINEAR",P=!0;break}}else J=S.interpolation&&1===S.interpolation?"STEP":"LINEAR";return J||(J="LINEAR"),{interpolationType:J,shouldBakeAnimation:P}}static _AddSplineTangent(t,b,Z,S,P,v){let h;const C=t===It.INTANGENT?P.inTangent:P.outTangent;if("CUBICSPLINE"===S){if("rotation"===Z)if(C)if(v)h=C.jb();else{const t=C;h=J.Quaternion.RotationYawPitchRoll(t.y,t.x,t.z).jb()}else h=[0,0,0,0];else h="weights"===Z?C?[C]:[0]:C?C.jb():[0,0,0];b.push(h)}}static _CalculateMinMaxKeyFrames(t){let b=1/0,Z=-1/0;return t.forEach((function(t){b=Math.min(b,t.frame),Z=Math.max(Z,t.frame)})),{min:b,max:Z}}}function ct(t,b,Z,P,v,h){const C={attributes:{},influence:t.influence,name:t.name},Y=b.qb;if(!Y)return S.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),C;const I=h?-1:1,r=J.JZ.Zero();let M=0,T=0;if(t.hasPositions){const P=t.getPositions(),h=Y.getVerticesData(g.g.PositionKind);if(h){const t=new Float32Array(h.length),b=[1/0,1/0,1/0],S=[-1/0,-1/0,-1/0];T=h.length/3,M=0;for(let Z=M;Z<T;++Z){const v=J.JZ.CZ(h,3*Z);J.JZ.CZ(P,3*Z).subtractToRef(v,r),r.x*=I,b[0]=Math.min(b[0],r.x),S[0]=Math.max(S[0],r.x),b[1]=Math.min(b[1],r.y),S[1]=Math.max(S[1],r.y),b[2]=Math.min(b[2],r.z),S[2]=Math.max(S[2],r.z),t[3*Z]=r.x,t[3*Z+1]=r.y,t[3*Z+2]=r.z}const Y=Z.createBufferView(t,12),g=Z.createAccessor(Y,"VEC3",5126,P.length/3,0,{min:b,max:S});v.push(g),C.attributes.POSITION=v.length-1}else S.Tools.Warn(`Morph target positions for mesh ${b.name} were not exported. Mesh does not have position vertex data`)}if(t.hasNormals){const P=t.getNormals(),h=Y.getVerticesData(g.g.NormalKind);if(h){const t=new Float32Array(h.length);T=h.length/3,M=0;for(let Z=M;Z<T;++Z){const b=J.JZ.CZ(h,3*Z).normalize();J.JZ.CZ(P,3*Z).normalize().subtractToRef(b,r),t[3*Z]=r.x*I,t[3*Z+1]=r.y,t[3*Z+2]=r.z}const b=Z.createBufferView(t,12),S=Z.createAccessor(b,"VEC3",5126,P.length/3,0);v.push(S),C.attributes.NORMAL=v.length-1}else S.Tools.Warn(`Morph target normals for mesh ${b.name} were not exported. Mesh does not have normals vertex data`)}if(t.hasTangents){const P=t.getTangents(),h=Y.getVerticesData(g.g.TangentKind);if(h){T=h.length/4;const t=new Float32Array(3*T);M=0;for(let Z=M;Z<T;++Z){const b=J.JZ.CZ(h,4*Z);mt(b);const S=J.JZ.CZ(P,3*Z);mt(S),S.subtractToRef(b,r),t[3*Z]=r.x*I,t[3*Z+1]=r.y,t[3*Z+2]=r.z}const b=Z.createBufferView(t,12),S=Z.createAccessor(b,"VEC3",5126,T,0);v.push(S),C.attributes.TANGENT=v.length-1}else S.Tools.Warn(`Morph target tangents for mesh ${b.name} were not exported. Mesh does not have tangents vertex data`)}if(t.hasColors){const P=t.getColors(),h=Y.getVerticesData(g.g.ColorKind),I=Y.getVertexBuffer(g.g.ColorKind);if(h&&I){const t=I.getSize();T=h.length/t;const b=new Float32Array(T*t);M=0;for(let Z=M;Z<T;++Z)if(3===t){const S=J.JZ.CZ(h,Z*t);J.JZ.CZ(P,Z*t).subtractToRef(S,r),b[3*Z]=r.x,b[3*Z+1]=r.y,b[3*Z+2]=r.z}else if(4===t){const S=new J.Vector4,v=J.Vector4.CZ(h,Z*t);J.Vector4.CZ(P,Z*t).subtractToRef(v,S),b[4*Z]=S.x,b[4*Z+1]=S.y,b[4*Z+2]=S.z,b[4*Z+3]=S.w}else S.Tools.Warn(`Unsupported number of components for color attribute: ${t}`);const Y=Z.createBufferView(b,4*t),g=Z.createAccessor(Y,3===t?"VEC3":"VEC4",5126,T,0);v.push(g),C.attributes.COLOR_0=v.length-1}else S.Tools.Warn(`Morph target colors for mesh ${b.name} were not exported. Mesh does not have colors vertex data`)}return C}var Ht=Z(13279),ot=Z(13132),Ot=Z(13121),pt=Z(12688);class et{}et.DEFAULT_COLOR=k.hZ.White(),et.DEFAULT_WIDTH_ATTENUATED=1,et.DEFAULT_WIDTH=.1;var Wt=Z(12944),jt=Z(13287);class Vt{static ConvertPoints(t,b){if(t.length&&Array.isArray(t)&&"number"===typeof t[0])return[t];if(t.length&&Array.isArray(t[0])&&"number"===typeof t[0][0])return t;if(t.length&&!Array.isArray(t[0])&&t[0]instanceof J.JZ){const b=[];for(let Z=0;Z<t.length;Z++){const J=t[Z];b.push(J.x,J.y,J.z)}return[b]}if(t.length>0&&Array.isArray(t[0])&&t[0].length>0&&t[0][0]instanceof J.JZ){const b=[],Z=t;for(const t of Z)b.push(t.flatMap((t=>[t.x,t.y,t.z])));return b}if(t instanceof Float32Array){if(null!==b&&void 0!==b&&b.floatArrayStride){const Z=[],J=3*b.floatArrayStride;for(let b=0;b<t.length;b+=J){const S=new Array(J);for(let Z=0;Z<J;Z++)S[Z]=t[b+Z];Z.push(S)}return Z}return[Array.from(t)]}if(t.length&&t[0]instanceof Float32Array){const b=[];for(const Z of t)b.push(Array.from(Z));return b}return[]}static OmitZeroLengthPredicate(t,b,Z){const J=[];return b.SZ(t).lengthSquared()>0&&J.push([t,b]),Z.SZ(b).lengthSquared()>0&&J.push([b,Z]),t.SZ(Z).lengthSquared()>0&&J.push([Z,t]),0===J.length?null:J}static OmitDuplicatesPredicate(t,b,Z,J){const S=[];return Vt._SearchInPoints(t,b,J)||S.push([t,b]),Vt._SearchInPoints(b,Z,J)||S.push([b,Z]),Vt._SearchInPoints(Z,t,J)||S.push([Z,t]),0===S.length?null:S}static _SearchInPoints(t,b,Z){for(const v of Z)for(let Z=0;Z<v.length;Z++){var J,S,P;if(null!==(J=v[Z])&&void 0!==J&&J.equals(t))if(null!==(S=v[Z+1])&&void 0!==S&&S.equals(b)||null!==(P=v[Z-1])&&void 0!==P&&P.equals(b))return!0}return!1}static MeshesToLines(t,b){const Z=[];for(let S=0;S<t.length;S++){const P=t[S],v=P.getVerticesData(g.g.PositionKind),h=P.Qb();if(v&&h)for(let t=0,C=0;t<h.length;t++){const Y=3*h[C++],g=3*h[C++],I=3*h[C++],r=new J.JZ(v[Y],v[Y+1],v[Y+2]),M=new J.JZ(v[g],v[g+1],v[g+2]),T=new J.JZ(v[I],v[I+1],v[I+2]);if(b){const J=b(r,M,T,Z,t,Y,P,S,v,h);if(J)for(const t of J)Z.push(t)}else Z.push([r,M],[M,T],[T,r])}}return Z}static ToVector3Array(t){if(Array.isArray(t[0])){const b=[],Z=t;for(const t of Z){const Z=[];for(let b=0;b<t.length;b+=3)Z.push(new J.JZ(t[b],t[b+1],t[b+2]));b.push(Z)}return b}const b=t,Z=[];for(let S=0;S<b.length;S+=3)Z.push(new J.JZ(b[S],b[S+1],b[S+2]));return Z}static ToNumberArray(t){return t.flatMap((t=>[t.x,t.y,t.z]))}static GetPointsCountInfo(t){const b=new Array(t.length);let Z=0;for(let J=t.length;J--;)b[J]=t[J].length/3,Z+=b[J];return{total:Z,counts:b}}static GetLineLength(t){if(0===t.length)return 0;let b;b="number"===typeof t[0]?Vt.ToVector3Array(t):t;const Z=J.TmpVectors.JZ[0];let S=0;for(let J=0;J<b.length-1;J++){const t=b[J];S+=b[J+1].subtractToRef(t,Z).length()}return S}static GetLineLengthArray(t){const b=new Float32Array(t.length/3);let Z=0;for(let J=0,S=t.length/3-1;J<S;J++){let S=t[3*J+0],P=t[3*J+1],v=t[3*J+2];S-=t[3*J+3],P-=t[3*J+4],v-=t[3*J+5];Z+=Math.sqrt(S*S+P*P+v*v),b[J+1]=Z}return b}static SegmentizeSegmentByCount(t,b,Z){const S=[],P=b.SZ(t),v=J.TmpVectors.JZ[0];v.Lb(Z);const h=J.TmpVectors.JZ[1];P.divideToRef(v,h);let C=t.clone();S.push(C);for(let J=0;J<Z;J++)C=C.clone(),S.push(C.addInPlace(h));return S}static SegmentizeLineBySegmentLength(t,b){const Z=t[0]instanceof J.JZ?Vt.GetLineSegments(t):"number"===typeof t[0]?Vt.GetLineSegments(Vt.ToVector3Array(t)):t,S=[];for(const J of Z)if(J.length>b){const t=Vt.SegmentizeSegmentByCount(J.point1,J.point2,Math.ceil(J.length/b));for(const b of t)S.push(b)}else S.push(J.point1),S.push(J.point2);return S}static SegmentizeLineBySegmentCount(t,b){const Z="number"===typeof t[0]?Vt.ToVector3Array(t):t,J=Vt.GetLineLength(Z)/b;return Vt.SegmentizeLineBySegmentLength(Z,J)}static GetLineSegments(t){const b=[];for(let Z=0;Z<t.length-1;Z++){const J=t[Z],S=t[Z+1],P=S.SZ(J).length();b.push({point1:J,point2:S,length:P})}return b}static GetMinMaxSegmentLength(t){const b=Vt.GetLineSegments(t).sort((t=>t.length));return{min:b[0].length,max:b[b.length-1].length}}static GetPositionOnLineByVisibility(t,b,Z){let S=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const P=b*Z;let v=0,h=0;const C=t.length;for(let J=0;J<C;J++){if(P<=v+t[J].length){h=J;break}v+=t[J].length}const Y=(P-v)/t[h].length;return t[h].point2.subtractToRef(t[h].point1,J.TmpVectors.JZ[0]),J.TmpVectors.JZ[1]=J.TmpVectors.JZ[0].multiplyByFloats(Y,Y,Y),S||J.TmpVectors.JZ[1].addInPlace(t[h].point1),J.TmpVectors.JZ[1].clone()}static GetCircleLinePoints(t,b){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t,P=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/b;const v=[];for(let h=0;h<=b;h++)v.push(new J.JZ(Math.cos(h*P)*t,Math.sin(h*P)*S,Z));return v}static GetBezierLinePoints(t,b,Z,J){return Wt.c.CreateQuadraticBezier(t,b,Z,J).getPoints().flatMap((t=>[t.x,t.y,t.z]))}static GetArrowCap(t,b,Z,J,S){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,v=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[t.clone(),t.add(b.multiplyByFloats(Z,Z,Z))],widths:[J,S,P,v]}}static GetPointsFromText(t,b,Z,J){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,P=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const v=[],h=(0,jt.c)(t,b,Z,J);for(const C of h){for(const t of C.paths){const b=[],Z=t.getPoints();for(const t of Z)b.push(t.x,t.y,S);v.push(b)}if(P)for(const t of C.holes){const b=[],Z=t.getPoints();for(const t of Z)b.push(t.x,t.y,S);v.push(b)}}return v}static Color3toRGBAUint8(t){const b=new Uint8Array(4*t.length);for(let Z=0,J=0;Z<t.length;Z++)b[J++]=255*t[Z].r,b[J++]=255*t[Z].g,b[J++]=255*t[Z].b,b[J++]=255;return b}static CreateColorsTexture(t,b,Z,J){const S=J.getEngine().getCaps().maxTextureSize??1,P=b.length>S?S:b.length,v=Math.ceil(b.length/S);v>1&&(b=[...b,...Array(P*v-b.length).fill(b[0])]);const h=Vt.Color3toRGBAUint8(b),C=new H.c(h,P,v,T.b.TEXTUREFORMAT_RGBA,J,!1,!0,Z);return C.name=t,C}static PrepareEmptyColorsTexture(t){if(!et.EmptyColorsTexture){const b=new Uint8Array(4);et.EmptyColorsTexture=new H.c(b,1,1,T.b.TEXTUREFORMAT_RGBA,t,!1,!1,H.c.NEAREST_NEAREST),et.EmptyColorsTexture.name="grlEmptyColorsTexture"}return et.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var t;null===(t=et.EmptyColorsTexture)||void 0===t||t.dispose(),et.EmptyColorsTexture=null}static BooleanToNumber(t){return t?1:0}}class nt extends Ot.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class yt extends ot.d{isCompatible(t){return!0}constructor(t,b,Z){var S;Z=Z||{color:et.DEFAULT_COLOR};const P=new nt;P.GREASED_LINE_HAS_COLOR=!!Z.color&&!Z.useColors,P.GREASED_LINE_SIZE_ATTENUATION=Z.sizeAttenuation??!1,P.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===Z.colorDistributionType,P.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(b??t.et()).useRightHandedSystem,P.GREASED_LINE_CAMERA_FACING=Z.cameraFacing??!0,super(t,yt.GREASED_LINE_MATERIAL_NAME,200,P,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(S=Z)||void 0===S?void 0:S.forceGLSL)||yt.ForceGLSL,this._scene=b??t.et(),this._engine=this._scene.getEngine(),this._cameraFacing=Z.cameraFacing??!0,this.visibility=Z.visibility??1,this.useDash=Z.useDash??!1,this.dashRatio=Z.dashRatio??.5,this.dashOffset=Z.dashOffset??0,this.width=Z.width?Z.width:Z.sizeAttenuation?et.DEFAULT_WIDTH_ATTENUATED:et.DEFAULT_WIDTH,this._sizeAttenuation=Z.sizeAttenuation??!1,this.colorMode=Z.colorMode??0,this._color=Z.color??null,this.useColors=Z.useColors??!1,this._colorsDistributionType=Z.colorDistributionType??0,this.colorsSampling=Z.colorsSampling??H.c.NEAREST_NEAREST,this._colors=Z.nt??null,this.dashCount=Z.dashCount??1,this.resolution=Z.resolution??new J.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),Z.colorsTexture?this.colorsTexture=Z.colorsTexture:this._colors?this.colorsTexture=Vt.CreateColorsTexture(`${t.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??et.DEFAULT_COLOR,Vt.PrepareEmptyColorsTexture(this._scene)),this._engine.lb.add((()=>{Vt.DisposeEmptyColorsTexture()}))}getAttributes(t){t.push("grl_offsets"),t.push("grl_widths"),t.push("grl_colorPointers"),t.push("grl_counters"),this._cameraFacing?(t.push("grl_previousAndSide"),t.push("grl_nextAndCounters")):t.push("grl_slopes")}getSamplers(t){t.push("grl_colors")}getActiveTextures(t){this.colorsTexture&&t.push(this.colorsTexture)}getUniforms(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const b=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&b.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===t&&b.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:b,vertex:this._cameraFacing&&this._isGLSL(t)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(t)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(t){if(this._cameraFacing){t.yb("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||t.yb("viewProjection",this._scene.getTransformMatrix());const b=J.TmpVectors.Vector4[0];b.x=this._aspect,b.y=this._resolution.x,b.z=this._resolution.y,b.w=this.width,t.updateVector4("grl_aspect_resolution_lineWidth",b)}const b=J.TmpVectors.Vector4[0];b.x=Vt.BooleanToNumber(this.useDash),b.y=this._dashArray,b.z=this.dashOffset,b.w=this.dashRatio,t.updateVector4("grl_dashOptions",b);const Z=J.TmpVectors.Vector4[1];Z.x=this.colorMode,Z.y=this.visibility,Z.z=this.colorsTexture?this.colorsTexture.getSize().width:0,Z.w=Vt.BooleanToNumber(this.useColors),t.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",Z),this._color&&t.updateColor3("grl_singleColor",this._color);const S=this.colorsTexture??et.EmptyColorsTexture;t.setTexture("grl_colors",S),t.updateFloat2("grl_textureSize",(null===S||void 0===S?void 0:S.getSize().width)??1,(null===S||void 0===S?void 0:S.getSize().height)??1)}prepareDefines(t,b,Z){t.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,t.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,t.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,t.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=b.useRightHandedSystem,t.GREASED_LINE_CAMERA_FACING=this._cameraFacing,t.GREASED_LINE_USE_OFFSETS=!!Z.offsets}getClassName(){return yt.GREASED_LINE_MATERIAL_NAME}getCustomCode(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(b)?function(t,b){if("vertex"===t){const t={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return b&&(t["!gl_Position\\=viewProjection\\*worldPos;"]="//"),t}return"fragment"===t?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(t,this._cameraFacing):function(t,b){if("vertex"===t){const t={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return b&&(t["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),t}return"fragment"===t?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(t,this._cameraFacing)}dispose(){var t;null===(t=this.colorsTexture)||void 0===t||t.dispose(),super.dispose()}get nt(){return this._colors}set nt(t){this.setColors(t)}setColors(t){var b;let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1],J=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const S=(null===(b=this._colors)||void 0===b?void 0:b.length)??0;var P;if(this._colors=t,null!==t&&0!==t.length){if(!Z||J)if(this.colorsTexture&&S===t.length&&!J){const b=Vt.Color3toRGBAUint8(t);this.colorsTexture.update(b)}else{var v;null===(v=this.colorsTexture)||void 0===v||v.dispose(),this.colorsTexture=Vt.CreateColorsTexture(`${this._material.name}-colors-texture`,t,this.colorsSampling,this._scene)}}else null===(P=this.colorsTexture)||void 0===P||P.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(t){this._dashCount=t,this._dashArray=1/t}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(t){this._sizeAttenuation=t,this.markAllDefinesAsDirty()}get color(){return this._color}set color(t){this.setColor(t)}setColor(t){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==t||null!==this._color&&null===t?(this._color=t,b||this.markAllDefinesAsDirty()):this._color=t}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(t){this._colorsDistributionType=t,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(t){this._aspect=t.x/t.y,this._resolution=t}serialize(){const t=super.serialize(),b={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(b.nt=this._colors),this._color&&(b.color=this._color),t.greasedLineMaterialOptions=b,t}parse(t,b,Z){var J;super.parse(t,b,Z);const S=t.greasedLineMaterialOptions;null===(J=this.colorsTexture)||void 0===J||J.dispose(),S.color&&this.setColor(S.color,!0),S.colorDistributionType&&(this.colorsDistributionType=S.colorDistributionType),S.nt&&(this.nt=S.nt),S.colorsSampling&&(this.colorsSampling=S.colorsSampling),S.colorMode&&(this.colorMode=S.colorMode),S.useColors&&(this.useColors=S.useColors),S.visibility&&(this.visibility=S.visibility),S.useDash&&(this.useDash=S.useDash),S.dashCount&&(this.dashCount=S.dashCount),S.dashRatio&&(this.dashRatio=S.dashRatio),S.dashOffset&&(this.dashOffset=S.dashOffset),S.width&&(this.width=S.width),S.sizeAttenuation&&(this.sizeAttenuation=S.sizeAttenuation),S.resolution&&(this.resolution=S.resolution),this.nt?this.colorsTexture=Vt.CreateColorsTexture(`${this._material.name}-colors-texture`,this.nt,this.colorsSampling,b):Vt.PrepareEmptyColorsTexture(b),this.markAllDefinesAsDirty()}copyTo(t){var b;const Z=t;null===(b=Z.colorsTexture)||void 0===b||b.dispose(),this._colors&&(Z.colorsTexture=Vt.CreateColorsTexture(`${Z._material.name}-colors-texture`,this._colors,Z.colorsSampling,this._scene)),Z.setColor(this.color,!0),Z.colorsDistributionType=this.colorsDistributionType,Z.colorsSampling=this.colorsSampling,Z.colorMode=this.colorMode,Z.useColors=this.useColors,Z.visibility=this.visibility,Z.useDash=this.useDash,Z.dashCount=this.dashCount,Z.dashRatio=this.dashRatio,Z.dashOffset=this.dashOffset,Z.width=this.width,Z.sizeAttenuation=this.sizeAttenuation,Z.resolution=this.resolution,Z.markAllDefinesAsDirty()}_isGLSL(t){return 0===t||this._forceGLSL}}yt.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",yt.ForceGLSL=!1,(0,pt.f)(`BABYLON.${yt.GREASED_LINE_MATERIAL_NAME}`,yt);var dt=Z(13162),st=Z(12565),qt=Z(12973),Qt=Z(12665);class Nt extends qt.ShaderMaterial{constructor(t,b,S){const P=b.getEngine(),v=P.isWebGPU&&!(S.forceGLSL||Nt.ForceGLSL),h=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];b.useRightHandedSystem&&h.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const C=["position","grl_widths","grl_offsets","grl_colorPointers"];S.cameraFacing?(h.push("GREASED_LINE_CAMERA_FACING"),C.push("grl_previousAndSide","grl_nextAndCounters")):(C.push("grl_slopes"),C.push("grl_counters"));const Y=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(v||Y.push("world","viewProjection","view","projection"),super(t,b,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:v?["Scene","Mesh"]:void 0,attributes:C,uniforms:Y,samplers:v?[]:["grlColors"],defines:h,extraInitializationsAsync:async()=>{v?await Promise.all([Z.e(66).then(Z.bind(Z,15874)),Z.e(75).then(Z.bind(Z,15879))]):await Promise.all([Z.e(69).then(Z.bind(Z,15885)),Z.e(76).then(Z.bind(Z,15890))])},shaderLanguage:v?1:0}),this._color=k.hZ.White(),this._colorsDistributionType=0,this._colorsTexture=null,S=S||{color:et.DEFAULT_COLOR},this.visibility=S.visibility??1,this.useDash=S.useDash??!1,this.dashRatio=S.dashRatio??.5,this.dashOffset=S.dashOffset??0,this.dashCount=S.dashCount??1,this.width=S.width?S.width:S.sizeAttenuation&&S.cameraFacing?et.DEFAULT_WIDTH_ATTENUATED:et.DEFAULT_WIDTH,this.sizeAttenuation=S.sizeAttenuation??!1,this.color=S.color??k.hZ.White(),this.useColors=S.useColors??!1,this.colorsDistributionType=S.colorDistributionType??0,this.colorsSampling=S.colorsSampling??H.c.NEAREST_NEAREST,this.colorMode=S.colorMode??0,this._colors=S.nt??null,this._cameraFacing=S.cameraFacing??!0,this.resolution=S.resolution??new J.Vector2(P.getRenderWidth(),P.getRenderHeight()),S.colorsTexture?this.colorsTexture=S.colorsTexture:this._colors?this.colorsTexture=Vt.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,b):(this._color=this._color??et.DEFAULT_COLOR,this.colorsTexture=Vt.PrepareEmptyColorsTexture(b)),v){const t=new Qt.b;t.setParameters(),t.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",t)}P.lb.add((()=>{Vt.DisposeEmptyColorsTexture()}))}dispose(){var t;null===(t=this._colorsTexture)||void 0===t||t.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new J.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get nt(){return this._colors}set nt(t){this.setColors(t)}setColors(t){var b;let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1],J=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const S=(null===(b=this._colors)||void 0===b?void 0:b.length)??0;var P;if(this._colors=t,null!==t&&0!==t.length){if(!Z||J)if(this._colorsTexture&&S===t.length&&!J){const b=Vt.Color3toRGBAUint8(t);this._colorsTexture.update(b)}else{var v;null===(v=this._colorsTexture)||void 0===v||v.dispose(),this.colorsTexture=Vt.CreateColorsTexture(`${this.name}-colors-texture`,t,this.colorsSampling,this.et())}}else null===(P=this._colorsTexture)||void 0===P||P.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(t){this._colorsTexture=t,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(t){this._width=t,this.setFloat("grlWidth",t)}get useColors(){return this._useColors}set useColors(t){this._useColors=t,this.setFloat("grlUseColors",Vt.BooleanToNumber(t))}get colorsSampling(){return this._colorsSampling}set colorsSampling(t){this._colorsSampling=t}get visibility(){return this._visibility}set visibility(t){this._visibility=t,this.setFloat("grlVisibility",t)}get useDash(){return this._useDash}set useDash(t){this._useDash=t,this.setFloat("grlUseDash",Vt.BooleanToNumber(t))}get dashOffset(){return this._dashOffset}set dashOffset(t){this._dashOffset=t,this.setFloat("grlDashOffset",t)}get dashRatio(){return this._dashRatio}set dashRatio(t){this._dashRatio=t,this.setFloat("grlDashRatio",t)}get dashCount(){return this._dashCount}set dashCount(t){this._dashCount=t,this._dashArray=1/t,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(t){this._sizeAttenuation=t,this.setFloat("grlSizeAttenuation",Vt.BooleanToNumber(t))}get color(){return this._color}set color(t){this.setColor(t)}setColor(t){t=t??et.DEFAULT_COLOR,this._color=t,this.setColor3("grlColor",t)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(t){this._colorsDistributionType=t,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(t){this._colorMode=t,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(t){this._resolution=t,this.setVector2("grlResolution",t),this.setFloat("grlAspect",t.x/t.y)}serialize(){const t=super.serialize(),b={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(b.nt=this._colors),t.greasedLineMaterialOptions=b,t}parse(t,b,Z){var J;const S=t.greasedLineMaterialOptions;null===(J=this._colorsTexture)||void 0===J||J.dispose(),S.color&&(this.color=S.color),S.colorDistributionType&&(this.colorsDistributionType=S.colorDistributionType),S.colorsSampling&&(this.colorsSampling=S.colorsSampling),S.colorMode&&(this.colorMode=S.colorMode),S.useColors&&(this.useColors=S.useColors),S.visibility&&(this.visibility=S.visibility),S.useDash&&(this.useDash=S.useDash),S.dashCount&&(this.dashCount=S.dashCount),S.dashRatio&&(this.dashRatio=S.dashRatio),S.dashOffset&&(this.dashOffset=S.dashOffset),S.width&&(this.width=S.width),S.sizeAttenuation&&(this.sizeAttenuation=S.sizeAttenuation),S.resolution&&(this.resolution=S.resolution),S.nt?this.colorsTexture=Vt.CreateColorsTexture(`${this.name}-colors-texture`,S.nt,this.colorsSampling,this.et()):this.colorsTexture=Vt.PrepareEmptyColorsTexture(b),this._cameraFacing=S.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var At,Kt,Lt;Nt.ForceGLSL=!1,function(t){t[t.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",t[t.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(At||(At={})),function(t){t[t.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",t[t.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",t[t.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Kt||(Kt={})),function(t){t[t.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",t[t.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",t[t.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",t[t.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",t[t.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Lt||(Lt={}));class Ft extends lt.b{constructor(t,b,Z){super(t,b,null,null,!1,!1),this.name=t,this._options=Z,this._lazy=!1,this._updatable=!1,this._engine=b.getEngine(),this._lazy=Z.lazy??!1,this._updatable=Z.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=Z.colorPointers??[],this._widths=Z.widths??new Array(Z.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(t){let b=0;for(const J of this._points)b+=J.length;const Z=b/3*2-this._widths.length;for(let J=0;J<Z;J++)this._widths.push(t)}updateLazy(){var t,b;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(t=this._options.ribbonOptions)||void 0===t?void 0:t.smoothShading),!this.qt&&this.refreshBoundingInfo(),null===(b=this.greasedLineMaterial)||void 0===b||b.updateLazy()}addPoints(t,b){for(const Z of t)this._points.push(Z);this._lazy||this.setPoints(this._points,b)}dispose(t){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(t,b)}isLazy(){return this._lazy}get yt(){return this._uvs}set yt(t){this._uvs=t instanceof Float32Array?t:new Float32Array(t),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(t){this.material instanceof Nt&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===t||void 0===t?void 0:t.length)>0),this._offsets=t,this._offsetsBuffer?this._offsetsBuffer.update(t):this._createOffsetsBuffer(t)}get widths(){return this._widths}set widths(t){this._widths=t,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(t)}get colorPointers(){return this._colorPointers}set colorPointers(t){this._colorPointers=t,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(t)}get greasedLineMaterial(){var t,b;if(this.material&&this.material instanceof Nt)return this.material;const Z=null===(t=this.material)||void 0===t||null===(b=t.pluginManager)||void 0===b?void 0:b.getPlugin(yt.GREASED_LINE_MATERIAL_NAME);return Z||void 0}get points(){const t=[];return st.e.DeepCopy(this._points,t),t}setPoints(t,b){this._points=Vt.ConvertPoints(t,(null===b||void 0===b?void 0:b.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==b&&void 0!==b&&b.colorPointers||this._updateColorPointers(),this._setPoints(this._points,b)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,yt:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(t){super.serialize(t),t.type=this.getClassName(),t.lineOptions=this._createLineOptions()}_createVertexBuffers(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new dt.c;return b.jt=this._vertexPositions,b.indices=this._indices,b.yt=this._uvs,t&&(b.Vt=[],dt.c.ComputeNormals(this._vertexPositions,this._indices,b.Vt)),b.st(this,this._options.updatable),b}_createOffsetsBuffer(t){const b=this._scene.getEngine(),Z=new g.d(b,t,this._updatable,3);this.setVerticesBuffer(Z.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=Z}}class Bt{constructor(t,b){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=t,this.wasAddedByNoopNode=b}getIndicesAccessor(t,b,Z,J,S){var P,v,h,C;return null===(P=this._indicesAccessorMap.get(t))||void 0===P||null===(v=P.get(b))||void 0===v||null===(h=v.get(Z))||void 0===h||null===(C=h.get(J))||void 0===C?void 0:C.get(S)}setIndicesAccessor(t,b,Z,J,S,P){let v=this._indicesAccessorMap.get(t);v||(v=new Map,this._indicesAccessorMap.set(t,v));let h=v.get(b);h||(h=new Map,v.set(b,h));let C=h.get(Z);C||(C=new Map,h.set(Z,C));let Y=C.get(J);Y||(Y=new Map,C.set(J,Y)),Y.set(S,P)}pushExportedNode(t){this._exportedNodes.has(t)||this._exportedNodes.add(t)}getNodesSet(){return this._exportedNodes}getVertexBufferView(t){return this._vertexBufferViewMap.get(t)}setVertexBufferView(t,b){this._vertexBufferViewMap.set(t,b)}setRemappedBufferView(t,b,Z){this._remappedBufferView.set(t,new Map),this._remappedBufferView.get(t).set(b,Z)}getRemappedBufferView(t,b){var Z;return null===(Z=this._remappedBufferView.get(t))||void 0===Z?void 0:Z.get(b)}getVertexAccessor(t,b,Z){var J,S;return null===(J=this._vertexAccessorMap.get(t))||void 0===J||null===(S=J.get(b))||void 0===S?void 0:S.get(Z)}setVertexAccessor(t,b,Z,J){let S=this._vertexAccessorMap.get(t);S||(S=new Map,this._vertexAccessorMap.set(t,S));let P=S.get(b);P||(P=new Map,S.set(b,P)),P.set(Z,J)}hasVertexColorAlpha(t){return this._vertexMapColorAlpha.get(t)||!1}setHasVertexColorAlpha(t,b){return this._vertexMapColorAlpha.set(t,b)}getMesh(t){return this._meshMap.get(t)}setMesh(t,b){this._meshMap.set(t,b)}bindMorphDataToMesh(t,b){const Z=this._meshMorphTargetMap.get(t)||[];this._meshMorphTargetMap.set(t,Z),-1===Z.indexOf(b)&&Z.push(b)}getMorphTargetsFromMesh(t){return this._meshMorphTargetMap.get(t)}}class Xt{_ApplyExtension(t,b,Z,J){if(Z>=b.length)return Promise.resolve(t);const S=J(b[Z],t);return S?S.then((async t=>t?await this._ApplyExtension(t,b,Z+1,J):null)):this._ApplyExtension(t,b,Z+1,J)}_ApplyExtensions(t,b){const Z=[];for(const J of Xt._ExtensionNames)Z.push(this._extensions[J]);return this._ApplyExtension(t,Z,0,b)}_extensionsPreExportTextureAsync(t,b,Z){return this._ApplyExtensions(b,((b,J)=>b.preExportTextureAsync&&b.preExportTextureAsync(t,J,Z)))}_extensionsPostExportNodeAsync(t,b,Z,J,S){return this._ApplyExtensions(b,((b,P)=>b.postExportNodeAsync&&b.postExportNodeAsync(t,P,Z,J,S,this._bufferManager)))}_extensionsPostExportMaterialAsync(t,b,Z){return this._ApplyExtensions(b,((b,J)=>b.postExportMaterialAsync&&b.postExportMaterialAsync(t,J,Z)))}_extensionsPostExportMaterialAdditionalTextures(t,b,Z){const J=[];for(const S of Xt._ExtensionNames){const P=this._extensions[S];P.postExportMaterialAdditionalTextures&&J.push(...P.postExportMaterialAdditionalTextures(t,b,Z))}return J}_extensionsPostExportTextures(t,b,Z){for(const J of Xt._ExtensionNames){const S=this._extensions[J];S.postExportTexture&&S.postExportTexture(t,b,Z)}}_extensionsPostExportMeshPrimitive(t){for(const b of Xt._ExtensionNames){const Z=this._extensions[b];Z.postExportMeshPrimitive&&Z.postExportMeshPrimitive(t,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const t of Xt._ExtensionNames){const b=this._extensions[t];b.preGenerateBinaryAsync&&await b.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(t){for(const b of Xt._ExtensionNames){const Z=this._extensions[b];Z.enabled&&t(Z)}}_extensionsOnExporting(){this._forEachExtensions((t=>{var b,Z,J;t.wasUsed&&((b=this._glTF).extensionsUsed||(b.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(t.name)&&this._glTF.extensionsUsed.push(t.name),t.required&&((Z=this._glTF).extensionsRequired||(Z.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(t.name)&&this._glTF.extensionsRequired.push(t.name)),(J=this._glTF).extensions||(J.extensions={}),t.onExporting&&t.onExporting())}))}_loadExtensions(){for(const t of Xt._ExtensionNames){const b=Xt._ExtensionFactories[t](this);this._extensions[t]=b}}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:a.e.LastCreatedScene,b=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${T.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new Q(this),this._extensions={},this._bufferManager=new gt,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!t)throw new Error("No scene available to export");this._babylonScene=t,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:t=>{var b;return null===t||void 0===t||null===(b=t.pb)||void 0===b?void 0:b.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...b},this._loadExtensions()}dispose(){for(const t in this._extensions){this._extensions[t].dispose()}}get options(){return this._options}static RegisterExtension(t,b){Xt.UnregisterExtension(t)&&S.Tools.Warn(`Extension with the name ${t} already exists`),Xt._ExtensionFactories[t]=b,Xt._ExtensionNames.push(t)}static UnregisterExtension(t){if(!Xt._ExtensionFactories[t])return!1;delete Xt._ExtensionFactories[t];const b=Xt._ExtensionNames.indexOf(t);return-1!==b&&Xt._ExtensionNames.splice(b,1),!0}_generateJSON(t,b,Z){const J={byteLength:t};return J.byteLength&&(this._glTF.buffers=[J]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.PZ=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(J.uri=b+".bin"),Z?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(t){const b=await this._generateBinaryAsync();this._extensionsOnExporting();const Z=this._generateJSON(b.byteLength,t,!0),J=new Blob([b],{type:"application/octet-stream"}),S=t+".gltf",P=t+".bin",v=new Y;if(v.files[S]=Z,v.files[P]=J,this._imageData)for(const h in this._imageData)v.files[h]=new Blob([this._imageData[h].data],{type:this._imageData[h].mimeType});return v}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(t){const b=t%4;return 0===b?b:4-b}async generateGLBAsync(t){this._shouldUseGlb=!0;const b=await this._generateBinaryAsync();this._extensionsOnExporting();const Z=this._generateJSON(b.byteLength),J=t+".glb";let S,P=Z.length;if("undefined"!==typeof TextEncoder){S=(new TextEncoder).encode(Z),P=S.length}const v=this._getPadding(P),h=this._getPadding(b.byteLength),C=28+P+v+b.byteLength+h,g=new Ct(C);if(g.writeUInt32(1179937895),g.writeUInt32(2),g.writeUInt32(C),g.writeUInt32(P+v),g.writeUInt32(1313821514),S)g.writeTypedArray(S);else{const t="_".charCodeAt(0);for(let b=0;b<P;++b){const J=Z.charCodeAt(b);J!=Z.codePointAt(b)?g.writeUInt8(t):g.writeUInt8(J)}}for(let Y=0;Y<v;++Y)g.writeUInt8(32);g.writeUInt32(b.byteLength+h),g.writeUInt32(5130562),g.writeTypedArray(b);for(let Y=0;Y<h;++Y)g.writeUInt8(0);const I=new Y;return I.files[J]=new Blob([g.getOutputData()],{type:"application/octet-stream"}),I}_setNodeTransformation(t,b,Z){if(b.getPivotPoint().equalsWithEpsilon(F,L.e)||S.Tools.Warn("Pivot points are not supported in the glTF serializer"),!b.position.equalsWithEpsilon(F,L.e)){const S=J.TmpVectors.JZ[0].S(b.position);Z&&R(S),t.translation=S.jb()}b.Kb.equalsWithEpsilon(X,L.e)||(t.scale=b.Kb.jb());const P=b.rotationQuaternion||J.Quaternion.FromEulerAngles(b.rotation.x,b.rotation.y,b.rotation.z);P.equalsWithEpsilon(B,L.e)||(Z&&w(P),t.rotation=P.normalize().jb())}_setCameraTransformation(t,b,Z){if(!b.position.equalsWithEpsilon(F,L.e)){const S=J.TmpVectors.JZ[0].S(b.position);Z&&R(S),t.translation=S.jb()}const S=b.rotationQuaternion||J.Quaternion.FromEulerAngles(b.rotation.x,b.rotation.y,b.rotation.z);Z&&w(S),this._babylonScene.useRightHandedSystem||G(S),S.equalsWithEpsilon(B,L.e)||(t.rotation=S.jb())}_listAvailableCameras(){for(const t of this._babylonScene.cameras){const b={type:t.mode===rt.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(t.name&&(b.name=t.name),"perspective"===b.type)b.perspective={aspectRatio:t.getEngine().getAspectRatio(t),yfov:t.fovMode===rt.e.FOVMODE_VERTICAL_FIXED?t.fov:t.fov*t.getEngine().getAspectRatio(t),znear:t.nb,zfar:t.maxZ};else if("orthographic"===b.type){const Z=t.orthoLeft&&t.orthoRight?.5*(t.orthoRight-t.orthoLeft):.5*t.getEngine().getRenderWidth(),J=t.orthoBottom&&t.orthoTop?.5*(t.orthoTop-t.orthoBottom):.5*t.getEngine().getRenderHeight();b.orthographic={xmag:Z,ymag:J,znear:t.nb,zfar:t.maxZ}}this._camerasMap.set(t,b)}}_exportAndAssignCameras(){const t=Array.from(this._camerasMap.values());for(const b of t){const t=this._nodesCameraMap.get(b);if(void 0!==t){this._cameras.push(b);for(const b of t)b.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const t of this._babylonScene.skeletons){if(t.bones.length<=0)continue;const b={joints:[]};this._skinMap.set(t,b)}}_exportAndAssignSkeletons(){for(const t of this._babylonScene.skeletons){if(t.bones.length<=0)continue;const b=this._skinMap.get(t);if(void 0==b)continue;const Z={},J=[];let P=-1;for(let S=0;S<t.bones.length;++S){const b=t.bones[S],J=b.getIndex()??S;-1!==J&&(Z[J]=b,J>P&&(P=J))}for(let t=0;t<=P;++t){const P=Z[t];J.push(P.getAbsoluteInverseBindMatrix());const v=P.getTransformNode();if(null!==v){const t=this._nodeMap.get(v);v&&null!==t&&void 0!==t?b.joints.push(t):S.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else S.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const v=this._nodesSkinMap.get(b);if(b.joints.length>0&&void 0!==v){const t=64*J.length,Z=new Float32Array(t/4);J.forEach(((t,b)=>{Z.set(t.m,16*b)}));const S=this._bufferManager.createBufferView(Z);this._accessors.push(this._bufferManager.createAccessor(S,"MAT4",5126,J.length)),b.inverseBindMatrices=this._accessors.length-1,this._skins.push(b);for(const b of v)b.skin=this._skins.length-1}}}async _exportSceneAsync(){const t={nodes:[]};if(this._babylonScene.metadata){const b=this._options.metadataSelector(this._babylonScene.metadata);b&&(t.extras=b)}const b=new Array,Z=new Array,J=new Array;for(const h of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&vt(h,this._babylonScene.useRightHandedSystem)?J.push(...h.getChildren()):this._babylonScene.useRightHandedSystem?b.push(h):Z.push(h);this._listAvailableCameras(),this._listAvailableSkeletons();const S=new Bt(!0,!1);t.nodes.push(...await this._exportNodesAsync(Z,S));const P=new Bt(!1,!1);t.nodes.push(...await this._exportNodesAsync(b,P));const v=new Bt(!1,!0);t.nodes.push(...await this._exportNodesAsync(J,v)),t.nodes.length&&this._scenes.push(t),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Et._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,S.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(t){let b=this._shouldExportNodeMap.get(t);return void 0===b&&(b=this._options.shouldExportNode(t),this._shouldExportNodeMap.set(t,b)),b}async _exportNodesAsync(t,b){const Z=new Array;this._exportBuffers(t,b);for(const J of t)await this._exportNodeAsync(J,Z,b);return Z}_collectBuffers(t,b,Z,J,S){if(this._shouldExportNode(t)&&t instanceof r.b&&t.qb){const P=t.qb.getVertexBuffers();if(P)for(const J in P){if(!D(J))continue;const v=P[J];S.setHasVertexColorAlpha(v,t.hasVertexAlpha);const h=v._buffer,C=b.get(h)||[];b.set(h,C),-1===C.indexOf(v)&&C.push(v);const Y=Z.get(v)||[];Z.set(v,Y),-1===Y.indexOf(t)&&Y.push(t)}const v=t.morphTargetManager;if(v)for(let b=0;b<v.numTargets;b++){const Z=v.getTarget(b),S=J.get(Z)||[];J.set(Z,S),-1===S.indexOf(t)&&S.push(t)}}for(const P of t.getChildren())this._collectBuffers(P,b,Z,J,S)}_exportBuffers(t,b){const Z=new Map,J=new Map,S=new Map;for(const h of t)this._collectBuffers(h,Z,J,S,b);const P=Array.from(Z.keys());for(const h of P){const t=h.getData();if(!t)throw new Error("Buffer data is not available");const S=Z.get(h);if(!S)continue;const P=S[0].byteStride;if(S.some((t=>t.byteStride!==P)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const v=Zt(t).slice();for(const b of S){const t=J.get(b),{byteOffset:Z,byteStride:S,componentCount:P,type:h,count:C,normalized:Y,kind:I}=i(b,t);switch(I){case g.g.NormalKind:case g.g.TangentKind:(0,N.h)(v,Z,S,P,h,C,Y,(t=>{const b=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);if(b>0){const Z=1/b;t[0]*=Z,t[1]*=Z,t[2]*=Z}}));break;case g.g.ColorKind:{const b=t.filter((t=>t.material instanceof at.vZ||null==t.material)).length;if(0==b)break;if(b!=t.length){A.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}h==g.g.UNSIGNED_BYTE&&A.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const J=new k.hZ,I=new k.Fb,r=this._babylonScene.getEngine().useExactSrgbConversions;(0,N.h)(v,Z,S,P,h,C,Y,(t=>{3===t.length?(J.ZJ(t,0),J.toLinearSpaceToRef(J,r),J.toArray(t,0)):(I.ZJ(t,0),I.toLinearSpaceToRef(I,r),I.toArray(t,0))}))}}}if(b.convertToRightHanded){for(const t of S){const b=J.get(t),{byteOffset:Z,byteStride:S,componentCount:P,type:h,count:C,normalized:Y,kind:I}=i(t,b);switch(I){case g.g.PositionKind:case g.g.NormalKind:case g.g.TangentKind:(0,N.h)(v,Z,S,P,h,C,Y,(t=>{t[0]=-t[0]}))}}b.convertedToRightHandedBuffers.set(h,v)}const C=this._bufferManager.createBufferView(v,P);b.setVertexBufferView(h,C);const Y=new Map;for(const b of S){const t=J.get(b),{kind:Z,totalVertices:S}=i(b,t);switch(Z){case g.g.MatricesIndicesKind:case g.g.MatricesIndicesExtraKind:if(b.type==g.g.FLOAT){const t=b.getFloatData(S);null!==t&&Y.set(b,t)}}}0!==Y.size&&A.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const I=Array.from(Y.keys());for(const Z of I){const t=Y.get(Z);if(!t)continue;const J=t.some((t=>t>=256)),S=new(J?Uint16Array:Uint8Array)(t.length);for(let b=0;b<t.length;b++)S[b]=t[b];const P=this._bufferManager.createBufferView(S,4*(J?2:1));b.setRemappedBufferView(h,Z,P)}}const v=Array.from(S.keys());for(const h of v){const t=S.get(h);if(!t)continue;const Z=ct(h,t[0],this._bufferManager,this._bufferViews,this._accessors,b.convertToRightHanded);for(const J of t)b.bindMorphDataToMesh(J,Z)}}async _exportNodeAsync(t,b,Z){let J=this._nodeMap.get(t);if(void 0!==J)return void(b.includes(J)||b.push(J));const S=await this._createNodeAsync(t,Z);if(S){J=this._nodes.length,this._nodes.push(S),this._nodeMap.set(t,J),Z.pushExportedNode(t),b.push(J);const P={name:"runtime animations",channels:[],samplers:[]},v=[];this._babylonScene.animationGroups.length||(Et._CreateMorphTargetAnimationFromMorphTargetAnimations(t,P,v,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Z.convertToRightHanded,this._options.shouldExportAnimation),t.animations.length&&Et._CreateNodeAnimationFromNodeAnimations(t,P,v,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Z.convertToRightHanded,this._options.shouldExportAnimation)),P.channels.length&&P.samplers.length&&this._animations.push(P),v.forEach((t=>{t.channels.length&&t.samplers.length&&this._animations.push(t)}))}const P=S?[]:b;for(const v of t.getChildren())await this._exportNodeAsync(v,P,Z);S&&P.length&&(S.children=P)}async _createNodeAsync(t,b){if(!this._shouldExportNode(t))return null;const Z={};if(t.name&&(Z.name=t.name),t.metadata){const b=this._options.metadataSelector(t.metadata);b&&(Z.extras=b)}if(t instanceof I.e&&(this._setNodeTransformation(Z,t,b.convertToRightHanded),t instanceof r.b)){const S=t instanceof M.c?t.sourceMesh:t;if(S.Wb&&S.Wb.length>0&&(Z.mesh=await this._exportMeshAsync(S,b)),t.skeleton){const b=this._skinMap.get(t.skeleton);var J;if(void 0!==b)void 0===this._nodesSkinMap.get(b)&&this._nodesSkinMap.set(b,[]),null===(J=this._nodesSkinMap.get(b))||void 0===J||J.push(Z)}}if(t instanceof K.b){const J=this._camerasMap.get(t);if(J){var S;void 0===this._nodesCameraMap.get(J)&&this._nodesCameraMap.set(J,[]),this._setCameraTransformation(Z,t,b.convertToRightHanded);const v=t.parent;if(null!==v&&bt(t,v)){const t=this._nodeMap.get(v);if(void 0!==t){var P;const b=this._nodes[t];return tt(Z,b),null===(P=this._nodesCameraMap.get(J))||void 0===P||P.push(b),null}}null===(S=this._nodesCameraMap.get(J))||void 0===S||S.push(Z)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",Z,t,this._nodeMap,b.convertToRightHanded)?Z:(A.c.Warn(`Not exporting node ${t.name}`),null)}_exportIndices(t,b,Z,J,S,v,h,C,Y){let g=t;Y.mode=f(v);const I=h!==P.c.CounterClockWiseSideOrientation,r=!C.wasAddedByNoopNode&&I,M=function(t){switch(t){case P.c.TriangleFillMode:case P.c.TriangleStripDrawMode:case P.c.TriangleFanDrawMode:return!0}return!1}(v)&&r;if(M){if(v===P.c.TriangleStripDrawMode||v===P.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");Y.mode=f(v);const h=b?new Uint32Array(J):new Uint16Array(J);if(t)for(let b=0;b+2<J;b+=3)h[b]=t[Z+b]+S,h[b+1]=t[Z+b+2]+S,h[b+2]=t[Z+b+1]+S;else for(let t=0;t+2<J;t+=3)h[t]=t,h[t+1]=t+2,h[t+2]=t+1;g=h}else if(t&&0!==S){const P=b?new Uint32Array(J):new Uint16Array(J);for(let b=0;b<J;b++)P[b]=t[Z+b]+S;g=P}if(g){let P=C.getIndicesAccessor(t,Z,J,S,M);if(void 0===P){const v=function(t,b,Z,J){if(t instanceof Uint16Array||t instanceof Uint32Array)return t;if(t instanceof Int32Array)return new Uint32Array(t.buffer,t.byteOffset,t.length);const S=t.slice(b,b+Z);return J?new Uint32Array(S):new Uint16Array(S)}(g,0,J,b),h=this._bufferManager.createBufferView(v),Y=b?5125:5123;this._accessors.push(this._bufferManager.createAccessor(h,"SCALAR",Y,J,0)),P=this._accessors.length-1,C.setIndicesAccessor(t,Z,J,S,M,P)}Y.indices=P}}_exportVertexBuffer(t,b,Z,J,S,P){const v=t.getKind();if(!D(v))return;if(v.startsWith("uv")&&!this._options.exportUnusedUVs&&(!b||!this._materialNeedsUVsSet.has(b)))return;let h=S.getVertexAccessor(t,Z,J);if(void 0===h){const b=S.convertedToRightHandedBuffers.get(t._buffer)||t._buffer.getData(),P=v===g.g.PositionKind?function(t,b,Z,J){const{byteOffset:S,byteStride:P,type:v,normalized:h}=b,C=b.getSize(),Y=new Array(C).fill(1/0),g=new Array(C).fill(-1/0);return(0,N.h)(t,S+Z*P,P,C,v,J*C,h,(t=>{for(let b=0;b<C;b++)Y[b]=Math.min(Y[b],t[b]),g[b]=Math.max(g[b],t[b])})),{min:Y,max:g}}(b,t,Z,J):void 0,C=(v===g.g.MatricesIndicesKind||v===g.g.MatricesIndicesExtraKind)&&t.type===g.g.FLOAT,Y=C?g.g.UNSIGNED_BYTE:t.type,I=C?void 0:t.normalized,r=C?S.getRemappedBufferView(t._buffer,t):S.getVertexBufferView(t._buffer),M=t.byteOffset+Z*t.byteStride;this._accessors.push(this._bufferManager.createAccessor(r,function(t,b){if(t==g.g.ColorKind)return b?"VEC4":"VEC3";switch(t){case g.g.PositionKind:case g.g.NormalKind:return"VEC3";case g.g.TangentKind:case g.g.MatricesIndicesKind:case g.g.MatricesIndicesExtraKind:case g.g.MatricesWeightsKind:case g.g.MatricesWeightsExtraKind:return"VEC4";case g.g.UVKind:case g.g.UV2Kind:case g.g.UV3Kind:case g.g.UV4Kind:case g.g.UV5Kind:case g.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${t}`)}(v,S.hasVertexColorAlpha(t)),Y,J,M,P,I)),h=this._accessors.length-1,S.setVertexAccessor(t,Z,J,h)}P.attributes[function(t){switch(t){case g.g.PositionKind:return"POSITION";case g.g.NormalKind:return"NORMAL";case g.g.TangentKind:return"TANGENT";case g.g.ColorKind:return"COLOR_0";case g.g.UVKind:return"TEXCOORD_0";case g.g.UV2Kind:return"TEXCOORD_1";case g.g.UV3Kind:return"TEXCOORD_2";case g.g.UV4Kind:return"TEXCOORD_3";case g.g.UV5Kind:return"TEXCOORD_4";case g.g.UV6Kind:return"TEXCOORD_5";case g.g.MatricesIndicesKind:return"JOINTS_0";case g.g.MatricesIndicesExtraKind:return"JOINTS_1";case g.g.MatricesWeightsKind:return"WEIGHTS_0";case g.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${t}`)}(v)]=h}async _exportMaterialAsync(t,b,Z,J){let S=this._materialMap.get(t);if(void 0===S){const J=b&&Object.keys(b).some((t=>t.startsWith("uv")));if((t=t instanceof Mt.b?t.Bb[Z.materialIndex]:t)instanceof Tt.b)S=await this._materialExporter.exportPBRMaterialAsync(t,"image/png",J);else{if(!(t instanceof at.vZ))return void A.c.Warn(`Unsupported material '${t.name}' with type ${t.getClassName()}`);S=await this._materialExporter.exportStandardMaterialAsync(t,"image/png",J)}this._materialMap.set(t,S)}J.material=S}async _exportMeshAsync(t,b){var Z;let J=b.getMesh(t);if(void 0!==J)return J;const S={primitives:[]};J=this._meshes.length,this._meshes.push(S),b.setMesh(t,J);const v=t.isUnIndexed?null:t.Qb(),h=null===(Z=t.qb)||void 0===Z?void 0:Z.getVertexBuffers(),C=b.getMorphTargetsFromMesh(t),Y=t instanceof Ht.b,g=t instanceof Ft,I=t.Wb;if(h&&I&&I.length>0)for(const T of I){const Z={attributes:{}},J=T.Kt()||this._babylonScene.defaultMaterial;if(g){var r,M;const b={name:J.name},S=t,P=k.hZ.White(),v=(null===(r=S.material)||void 0===r?void 0:r.alpha)??1,h=(null===(M=S.greasedLineMaterial)||void 0===M?void 0:M.color)??P;(!h.equalsWithEpsilon(P,L.e)||v<1)&&(b.pbrMetallicRoughness={baseColorFactor:[...h.jb(),v]}),this._materials.push(b),Z.material=this._materials.length-1}else if(Y){const b={name:J.name},S=t;(!S.color.equalsWithEpsilon(k.hZ.White(),L.e)||S.alpha<1)&&(b.pbrMetallicRoughness={baseColorFactor:[...S.color.jb(),S.alpha]}),this._materials.push(b),Z.material=this._materials.length-1}else await this._exportMaterialAsync(J,h,T,Z);const I=Y||g?P.c.LineListDrawMode:t.overrideRenderingFillMode??J.fillMode,a=J._getEffectiveOrientation(t);this._exportIndices(v,v?(0,N.c)(v,T.indexCount,T.indexStart,T.verticesStart):T.verticesCount>65535,v?T.indexStart:T.verticesStart,v?T.indexCount:T.verticesCount,-T.verticesStart,I,a,b,Z);for(const t of Object.values(h))this._exportVertexBuffer(t,J,T.verticesStart,T.verticesCount,b,Z);if(C){Z.targets=[];for(const t of C)Z.targets.push(t.attributes)}S.primitives.push(Z),this._extensionsPostExportMeshPrimitive(Z)}if(C){S.weights=[],S.extras||(S.extras={}),S.extras.targetNames=[];for(const t of C)S.weights.push(t.influence),S.extras.targetNames.push(t.name)}return J}}Xt._ExtensionNames=new Array,Xt._ExtensionFactories={};class xt{static async GLTFAsync(t,b,Z){Z&&Z.exportWithoutWaitingForScene||await t.whenReadyAsync();const J=new Xt(t,Z),S=await J.generateGLTFAsync(b.replace(/\.[^/.]+$/,""));return J.dispose(),S}static async GLBAsync(t,b,Z){Z&&Z.exportWithoutWaitingForScene||await t.whenReadyAsync();const J=new Xt(t,Z),S=await J.generateGLBAsync(b.replace(/\.[^/.]+$/,""));return J.dispose(),S}}Z(13301);const it="EXT_mesh_gpu_instancing";class zt{constructor(t){this.name=it,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(t,b,Z,S,P,v){return await new Promise((t=>{if(b&&Z instanceof lt.b&&Z.hasThinInstances&&this._exporter){this._wasUsed=!0;const t=J.JZ.Zero(),S=J.Quaternion.Identity(),h=J.JZ.One(),C=Z.thinInstanceGetWorldMatrices(),Y=J.TmpVectors.JZ[2],g=J.TmpVectors.Quaternion[1],I=J.TmpVectors.JZ[3];let r=!1,M=!1,T=!1;const a=new Float32Array(3*Z.Xb),k=new Float32Array(4*Z.Xb),u=new Float32Array(3*Z.Xb);let l=0;for(const b of C)b.decompose(I,g,Y),P&&(R(Y),w(g)),a.set(Y.jb(),3*l),k.set(g.normalize().jb(),4*l),u.set(I.jb(),3*l),r=r||!Y.equalsWithEpsilon(t),M=M||!g.equalsWithEpsilon(S),T=T||!I.equalsWithEpsilon(h),l++;const U={attributes:{}};r&&(U.attributes.TRANSLATION=this._buildAccessor(a,"VEC3",Z.Xb,v)),M&&(U.attributes.ROTATION=this._buildAccessor(k,"VEC4",Z.Xb,v)),T&&(U.attributes.SCALE=this._buildAccessor(u,"VEC3",Z.Xb,v)),b.extensions=b.extensions||{},b.extensions[it]=U}t(b)}))}_buildAccessor(t,b,Z,J){const S=J.createBufferView(t),P=J.createAccessor(S,b,5126,Z);return this._exporter._accessors.push(P),this._exporter._accessors.length-1}}Xt.RegisterExtension(it,(t=>new zt(t)));var Dt=Z(13304),ft=Z(13315),mb=Z(13324),Rt=Z(13330);function wt(t){return t===mb.b.PositionKind?"POSITION":t===mb.b.NormalKind?"NORMAL":t===mb.b.ColorKind?"COLOR":t.startsWith(mb.b.UVKind)?"TEX_COORD":"GENERIC"}const Gt={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class tb extends Dt.d{static get DefaultAvailable(){return(0,Dt.j)(tb.DefaultConfiguration)}static get Default(){return tb._Default??(tb._Default=new tb),tb._Default}static ResetDefault(t){tb._Default&&(t||tb._Default.dispose(),tb._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(t,b){return{module:await(b||DracoEncoderModule)({wasmBinary:t})}}_getWorkerContent(){return`${ft.h}(${ft.i})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:tb.DefaultConfiguration)}async _encodeAsync(t,b,Z){const J=Z?(0,Rt.d)(Gt,Z):Gt;if(this._workerPoolPromise){const Z=await this._workerPoolPromise;return await new Promise(((S,P)=>{Z.push(((Z,v)=>{const h=t=>{Z.removeEventListener("error",h),Z.removeEventListener("message",C),P(t),v()},C=t=>{"encodeMeshDone"===t.data.id&&(Z.removeEventListener("error",h),Z.removeEventListener("message",C),S(t.data.encodedMeshData),v())};Z.addEventListener("error",h),Z.addEventListener("message",C);const Y=[];for(const b of t)Y.push(b.data.buffer);b&&Y.push(b.buffer),Z.postMessage({id:"encodeMesh",attributes:t,indices:b,options:J},Y)}))}))}if(this._modulePromise){const Z=await this._modulePromise;return(0,ft.h)(Z.module,t,b,J)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(t,b){if(0==t.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");t instanceof lt.b&&t.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===b||void 0===b?void 0:b.method)&&(A.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),b.method="MESH_SEQUENTIAL_ENCODING");const Z=function(t){let b=t.Qb(void 0,!0);return!b||b instanceof Uint32Array||b instanceof Uint16Array||(b=((0,N.c)(b,b.length)?Uint32Array:Uint16Array).from(b)),b}(t),J=function(t,b){const Z=[];for(const J of t.getVerticesDataKinds()){if(null!==b&&void 0!==b&&b.includes(J)){if(J===mb.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const S=t.getVertexBuffer(J),P=S.getSize(),v=(0,N.t)(S.getData(),P,S.type,S.byteOffset,S.byteStride,S.normalized,t.getTotalVertices(),!0);Z.push({kind:J,dracoName:wt(J),size:P,data:v})}return Z}(t,null===b||void 0===b?void 0:b.excludedAttributes);return await this._encodeAsync(J,Z,b)}}tb.DefaultConfiguration={wasmUrl:`${S.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${S.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${S.Tools._DefaultCdnUrl}/draco_encoder.js`},tb._Default=null;const bb="KHR_draco_mesh_compression";class Zb{get wasUsed(){return this._wasUsed}constructor(t){this.name=bb,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===t.options.meshCompressionMethod&&tb.DefaultAvailable}dispose(){}postExportMeshPrimitive(t,b,Z){if(!this.enabled)return;if(4!==t.mode&&5!==t.mode)return void A.c.Warn("Cannot compress primitive with mode "+t.mode+".");const J=[],S=[];let P=null;if(void 0!==t.indices){const v=Z[t.indices],h=b.getBufferView(v);P=b.getData(h).slice(),J.push(h),S.push(v)}const v=[];for(const[g,I]of Object.entries(t.attributes)){const t=Z[I],P=b.getBufferView(t),C=z(t.type),Y=(0,N.t)(b.getData(P),C,t.componentType,t.byteOffset||0,P.byteStride||(0,N.n)(t.componentType)*C,t.normalized||!1,t.count,!0);v.push({kind:g,dracoName:(h=g,"POSITION"===h?"POSITION":"NORMAL"===h?"NORMAL":h.startsWith("COLOR")?"COLOR":h.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:z(t.type),data:Y}),J.push(P),S.push(t)}var h;const C={method:t.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},Y=tb.Default._encodeAsync(v,P,C).then((Z=>{if(!Z)return void A.c.Error("Draco encoding failed for primitive.");const P={bufferView:-1,attributes:Z.attributeIds},v=b.createBufferView(Z.data);b.setBufferView(P,v);for(const t of J)this._bufferViewsUsed.add(t);for(const t of S)this._accessorsUsed.add(t);t.extensions||(t.extensions={}),t.extensions[bb]=P})).catch((t=>{A.c.Error("Draco encoding failed for primitive: "+t)}));this._encodePromises.push(Y),this._wasUsed=!0}async preGenerateBinaryAsync(t){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((b=>{t.getPropertiesWithBufferView(b).every((t=>this._accessorsUsed.has(t)))&&t.removeBufferView(b)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Xt.RegisterExtension(bb,(t=>new Zb(t)));var Jb=Z(13338);const Sb="KHR_lights_punctual",Pb={name:"",color:[1,1,1],xb:1,range:Number.MAX_VALUE},vb={innerConeAngle:0,outerConeAngle:Math.PI/4},hb=J.JZ.Backward();class Cb{constructor(t){this.name=Sb,this.enabled=!0,this.required=!1,this._exporter=t}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Sb]=this._lights}async postExportNodeAsync(t,b,Z,S,P){return await new Promise((v=>{if(!(Z instanceof Ut.d))return void v(b);const h=Z.getTypeID()==Ut.d.LIGHTTYPEID_POINTLIGHT?"point":Z.getTypeID()==Ut.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":Z.getTypeID()==Ut.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!h||!(Z instanceof Jb.b))return A.c.Warn(`${t}: Light ${Z.name} is not supported in ${Sb}`),void v(b);if(Z.falloffType!==Ut.d.FALLOFF_GLTF&&A.c.Warn(`${t}: Light falloff for ${Z.name} does not match the ${Sb} specification!`),!Z.position.equalsToFloats(0,0,0)){const t=J.TmpVectors.JZ[0].S(Z.position);P&&R(t),b.translation=t.jb()}if("point"!==h){const t=Z.direction.normalizeToRef(J.TmpVectors.JZ[0]);P&&R(t);const S=J.Quaternion.FromUnitVectorsToRef(hb,t,J.TmpVectors.Quaternion[0]);J.Quaternion.IsIdentity(S)||(b.rotation=S.jb())}const C={type:h,name:Z.name,color:Z.ib.jb(),xb:Z.xb,range:Z.range};if(Jt(C,Pb),"spot"===h){const t=Z;C.spot={innerConeAngle:t.innerAngle/2,outerConeAngle:t.angle/2},Jt(C.spot,vb)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(C);const Y={rb:this._lights.lights.length-1},g=Z.parent;if(g&&bt(Z,g)){const t=S.get(g);if(t){const Z=this._exporter._nodes[t];return tt(b,Z),Z.extensions||(Z.extensions={}),Z.extensions[Sb]=Y,void v(null)}}b.extensions||(b.extensions={}),b.extensions[Sb]=Y,v(b)}))}}Xt.RegisterExtension(Sb,(t=>new Cb(t)));var Yb=Z(13240);const gb="KHR_materials_anisotropy";class Ib{constructor(t){this.name=gb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,b,Z){const J=[];return Z instanceof Yb.d&&Z.anisotropy.isEnabled&&!Z.anisotropy.legacy?(Z.anisotropy.texture&&J.push(Z.anisotropy.texture),J):[]}postExportMaterialAsync(t,b,Z){return new Promise((t=>{if(Z instanceof Yb.d){if(!Z.anisotropy.isEnabled||Z.anisotropy.legacy)return void t(b);this._wasUsed=!0,b.extensions=b.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(Z.anisotropy.texture),S={anisotropyStrength:Z.anisotropy.xb,anisotropyRotation:Z.anisotropy.angle,anisotropyTexture:J??void 0};null!==S.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(Z),b.extensions[gb]=S}t(b)}))}}Xt.RegisterExtension(gb,(t=>new Ib(t)));const rb="KHR_materials_clearcoat";class Mb{constructor(t){this.name=rb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,b,Z){const J=[];return Z instanceof Yb.d&&Z.clearCoat.isEnabled?(Z.clearCoat.texture&&J.push(Z.clearCoat.texture),!Z.clearCoat.useRoughnessFromMainTexture&&Z.clearCoat.textureRoughness&&J.push(Z.clearCoat.textureRoughness),Z.clearCoat.bumpTexture&&J.push(Z.clearCoat.bumpTexture),J):[]}postExportMaterialAsync(t,b,Z){return new Promise((t=>{if(Z instanceof Yb.d){if(!Z.clearCoat.isEnabled)return void t(b);this._wasUsed=!0,b.extensions=b.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(Z.clearCoat.texture);let P;P=Z.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(Z.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(Z.clearCoat.textureRoughness),Z.clearCoat.isTintEnabled&&S.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${Z.name}`),Z.clearCoat.remapF0OnInterfaceChange&&S.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${Z.name}`);const v=this._exporter._materialExporter.getTextureInfo(Z.clearCoat.bumpTexture),h={clearcoatFactor:Z.clearCoat.xb,clearcoatTexture:J??void 0,clearcoatRoughnessFactor:Z.clearCoat.roughness,clearcoatRoughnessTexture:P??void 0,clearcoatNormalTexture:v??void 0};null===h.clearcoatTexture&&null===h.clearcoatRoughnessTexture&&null===h.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Z),b.extensions[rb]=h}t(b)}))}}Xt.RegisterExtension(rb,(t=>new Mb(t)));const Tb="KHR_materials_diffuse_transmission";function ab(t,b){const Z=b.subSurface;let J=null;return Z.translucencyIntensityTexture?J=Z.translucencyIntensityTexture:Z.thicknessTexture&&Z.useMaskFromThicknessTexture&&(J=Z.thicknessTexture),J&&!Z.useGltfStyleTextures?(A.c.Warn(`${t}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${b.name}`,1),null):J}class kb{constructor(t){this.name=Tb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,b,Z){const J=[];if(Z instanceof Tt.b&&this._isExtensionEnabled(Z)){const b=ab(t,Z);return b&&J.push(b),Z.subSurface.translucencyColorTexture&&J.push(Z.subSurface.translucencyColorTexture),J}return J}_isExtensionEnabled(t){if(t.unlit)return!1;const b=t.subSurface;return!!b.isTranslucencyEnabled&&(!t.unlit&&!b.useAlbedoToTintTranslucency&&b.useGltfStyleTextures&&1===b.volumeIndexOfRefraction&&0===b.minimumThickness&&0===b.maximumThickness)}postExportMaterialAsync(t,b,Z){return new Promise((J=>{if(Z instanceof Tt.b&&this._isExtensionEnabled(Z)){this._wasUsed=!0;const J=Z.subSurface,S=ab(t,Z),P=0==J.translucencyIntensity?void 0:J.translucencyIntensity,v=this._exporter._materialExporter.getTextureInfo(S)??void 0,h=!J.translucencyColor||J.translucencyColor.equalsFloats(1,1,1)?void 0:J.translucencyColor.jb(),C=this._exporter._materialExporter.getTextureInfo(J.translucencyColorTexture)??void 0,Y={diffuseTransmissionFactor:P,diffuseTransmissionTexture:v,diffuseTransmissionColorFactor:h,diffuseTransmissionColorTexture:C};(v||C)&&this._exporter._materialNeedsUVsSet.add(Z),b.extensions=b.extensions||{},b.extensions[Tb]=Y}J(b)}))}}Xt.RegisterExtension(Tb,(t=>new kb(t)));const ub="KHR_materials_dispersion";class lb{constructor(){this.name=ub,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(t){if(t.unlit)return!1;const b=t.subSurface;return!(!b.isRefractionEnabled&&!b.isDispersionEnabled)}postExportMaterialAsync(t,b,Z){return new Promise((t=>{if(Z instanceof Tt.b&&this._isExtensionEnabled(Z)){this._wasUsed=!0;const t={dispersion:Z.subSurface.dispersion};b.extensions=b.extensions||{},b.extensions[ub]=t}t(b)}))}}Xt.RegisterExtension(ub,(()=>new lb));const Ub="KHR_materials_emissive_strength";class Eb{constructor(){this.name=Ub,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(t,b,Z){return await new Promise((t=>{if(!(Z instanceof Tt.b))return t(b);const J=Z.emissiveColor.jb(),S=Math.max(...J);if(S>1){this._wasUsed=!0,b.extensions||(b.extensions={});const t={emissiveStrength:S},J=Z.emissiveColor.scale(1/t.emissiveStrength);b.emissiveFactor=J.jb(),b.extensions[Ub]=t}return t(b)}))}}Xt.RegisterExtension(Ub,(t=>new Eb));const cb="KHR_materials_ior";class Hb{constructor(){this.name=cb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(t){return!t.unlit&&(void 0!=t.indexOfRefraction&&1.5!=t.indexOfRefraction)}postExportMaterialAsync(t,b,Z){return new Promise((t=>{if(Z instanceof Tt.b&&this._isExtensionEnabled(Z)){this._wasUsed=!0;const t={ior:Z.indexOfRefraction};b.extensions=b.extensions||{},b.extensions[cb]=t}t(b)}))}}Xt.RegisterExtension(cb,(t=>new Hb));const ob="KHR_materials_iridescence";class Ob{constructor(t){this.name=ob,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,b,Z){const J=[];return Z instanceof Yb.d&&Z.iridescence.isEnabled?(Z.iridescence.texture&&J.push(Z.iridescence.texture),Z.iridescence.thicknessTexture&&Z.iridescence.thicknessTexture!==Z.iridescence.texture&&J.push(Z.iridescence.thicknessTexture),J):[]}postExportMaterialAsync(t,b,Z){return new Promise((t=>{if(Z instanceof Yb.d){if(!Z.iridescence.isEnabled)return void t(b);this._wasUsed=!0,b.extensions=b.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(Z.iridescence.texture),S=this._exporter._materialExporter.getTextureInfo(Z.iridescence.thicknessTexture),P={iridescenceFactor:Z.iridescence.xb,iridescenceIor:Z.iridescence.indexOfRefraction,iridescenceThicknessMinimum:Z.iridescence.minimumThickness,iridescenceThicknessMaximum:Z.iridescence.maximumThickness,iridescenceTexture:J??void 0,iridescenceThicknessTexture:S??void 0};null===P.iridescenceTexture&&null===P.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(Z),b.extensions[ob]=P}t(b)}))}}Xt.RegisterExtension(ob,(t=>new Ob(t)));const pb="KHR_materials_sheen";class eb{constructor(t){this.name=pb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,b,Z){return Z instanceof Tt.b&&Z.sheen.isEnabled&&Z.sheen.texture?[Z.sheen.texture]:[]}async postExportMaterialAsync(t,b,Z){return await new Promise((t=>{if(Z instanceof Tt.b){if(!Z.sheen.isEnabled)return void t(b);this._wasUsed=!0,null==b.extensions&&(b.extensions={});const J={sheenColorFactor:Z.sheen.color.jb(),sheenRoughnessFactor:Z.sheen.roughness??0};null===J.sheenColorTexture&&null===J.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Z),Z.sheen.texture&&(J.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(Z.sheen.texture)??void 0),Z.sheen.textureRoughness&&!Z.sheen.useRoughnessFromMainTexture?J.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Z.sheen.textureRoughness)??void 0:Z.sheen.texture&&Z.sheen.useRoughnessFromMainTexture&&(J.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Z.sheen.texture)??void 0),b.extensions[pb]=J}t(b)}))}}Xt.RegisterExtension(pb,(t=>new eb(t)));const Wb="KHR_materials_specular";class jb{constructor(t){this.name=Wb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,b,Z){const J=[];return Z instanceof Tt.b&&this._isExtensionEnabled(Z)?(Z.metallicReflectanceTexture&&J.push(Z.metallicReflectanceTexture),Z.reflectanceTexture&&J.push(Z.reflectanceTexture),J):J}_isExtensionEnabled(t){return!t.unlit&&(void 0!=t.metallicF0Factor&&1!=t.metallicF0Factor||void 0!=t.metallicReflectanceColor&&!t.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(t))}_hasTexturesExtension(t){return null!=t.metallicReflectanceTexture||null!=t.reflectanceTexture}postExportMaterialAsync(t,b,Z){return new Promise((t=>{if(Z instanceof Tt.b&&this._isExtensionEnabled(Z)){this._wasUsed=!0,b.extensions=b.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(Z.metallicReflectanceTexture)??void 0,J=this._exporter._materialExporter.getTextureInfo(Z.reflectanceTexture)??void 0,S={specularFactor:1==Z.metallicF0Factor?void 0:Z.metallicF0Factor,specularTexture:t,specularColorFactor:Z.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:Z.metallicReflectanceColor.jb(),specularColorTexture:J};this._hasTexturesExtension(Z)&&this._exporter._materialNeedsUVsSet.add(Z),b.extensions[Wb]=S}t(b)}))}}Xt.RegisterExtension(Wb,(t=>new jb(t)));const Vb="KHR_materials_transmission";class nb{constructor(t){this.name=Vb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,b,Z){const J=[];return Z instanceof Tt.b&&this._isExtensionEnabled(Z)?(Z.subSurface.thicknessTexture&&J.push(Z.subSurface.thicknessTexture),J):J}_isExtensionEnabled(t){if(t.unlit)return!1;const b=t.subSurface;return b.isRefractionEnabled&&void 0!=b.refractionIntensity&&0!=b.refractionIntensity||this._hasTexturesExtension(t)}_hasTexturesExtension(t){return null!=t.subSurface.refractionIntensityTexture}async postExportMaterialAsync(t,b,Z){if(Z instanceof Tt.b&&this._isExtensionEnabled(Z)){this._wasUsed=!0;const J=Z.subSurface,S={transmissionFactor:0===J.refractionIntensity?void 0:J.refractionIntensity};if(this._hasTexturesExtension(Z)&&this._exporter._materialNeedsUVsSet.add(Z),J.refractionIntensityTexture)if(J.useGltfStyleTextures){const t=await this._exporter._materialExporter.exportTextureAsync(J.refractionIntensityTexture,"image/png");t&&(S.transmissionTexture=t)}else A.c.Warn(`${t}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);b.extensions||(b.extensions={}),b.extensions[Vb]=S}return b}}Xt.RegisterExtension(Vb,(t=>new nb(t)));const yb="KHR_materials_unlit";class db{constructor(){this.name=yb,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(t,b,Z){return new Promise((t=>{let J=!1;Z instanceof Tt.b?J=Z.unlit:Z instanceof at.vZ&&(J=Z.disableLighting),J&&(this._wasUsed=!0,null==b.extensions&&(b.extensions={}),b.extensions[yb]={}),t(b)}))}}Xt.RegisterExtension(yb,(()=>new db));const sb="KHR_materials_volume";class qb{constructor(t){this.name=sb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,b,Z){const J=[];return Z instanceof Tt.b&&this._isExtensionEnabled(Z)?(Z.subSurface.thicknessTexture&&J.push(Z.subSurface.thicknessTexture),J):J}_isExtensionEnabled(t){if(t.unlit)return!1;const b=t.subSurface;return!(!b.isRefractionEnabled&&!b.isTranslucencyEnabled)&&(void 0!=b.maximumThickness&&0!=b.maximumThickness||void 0!=b.tintColorAtDistance&&b.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=b.tintColor&&b.tintColor!=k.hZ.White()||this._hasTexturesExtension(t))}_hasTexturesExtension(t){return null!=t.subSurface.thicknessTexture}postExportMaterialAsync(t,b,Z){return new Promise((t=>{if(Z instanceof Tt.b&&this._isExtensionEnabled(Z)){this._wasUsed=!0;const t=Z.subSurface,J={thicknessFactor:0==t.maximumThickness?void 0:t.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(t.thicknessTexture)??void 0,attenuationDistance:t.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:t.tintColorAtDistance,attenuationColor:t.tintColor.equalsFloats(1,1,1)?void 0:t.tintColor.jb()};this._hasTexturesExtension(Z)&&this._exporter._materialNeedsUVsSet.add(Z),b.extensions=b.extensions||{},b.extensions[sb]=J}t(b)}))}}Xt.RegisterExtension(sb,(t=>new qb(t)));const Qb="EXT_materials_diffuse_roughness";class Nb{constructor(t){this.name=Qb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,b,Z){const J=[];return Z instanceof Yb.d&&Z._baseDiffuseRoughness?(Z._baseDiffuseRoughnessTexture&&J.push(Z._baseDiffuseRoughnessTexture),J):[]}postExportMaterialAsync(t,b,Z){return new Promise((t=>{if(Z instanceof Yb.d){if(!Z._baseDiffuseRoughness)return void t(b);this._wasUsed=!0,b.extensions=b.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(Z._baseDiffuseRoughnessTexture),S={diffuseRoughnessFactor:Z._baseDiffuseRoughness,diffuseRoughnessTexture:J??void 0};null!==S.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(Z),b.extensions[Qb]=S}t(b)}))}}Xt.RegisterExtension(Qb,(t=>new Nb(t)));const Ab="KHR_texture_transform";class Kb{constructor(){this.name=Ab,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(t,b,Z){if(Z.et()||S.Tools.Warn(`${t}: /*@__KEY__*/"scene" is not defined for Babylon texture ${Z.name}!`),(0!==Z.uAng||0!==Z.vAng)&&(S.Tools.Warn(`${t}: Texture ${Z.name} with rotation in the u or v axis is not supported in glTF.`),0!==Z.uRotationCenter||0!==Z.vRotationCenter))return;const J={};let P=!1;if(0===Z.uOffset&&0===Z.vOffset||(J.offset=[Z.uOffset,Z.vOffset],P=!0),1===Z.uScale&&1===Z.vScale||(J.scale=[Z.uScale,Z.vScale],P=!0),0!==Z.wAng){if(0!==Z.uRotationCenter||0!==Z.vRotationCenter){if(Z.homogeneousRotationInUVTransform&&Z.uScale!==Z.vScale)return void S.Tools.Warn(`${t}: Texture ${Z.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Ab}.`);S.Tools.Warn(`${t}: Texture ${Z.name} with non-origin rotation center will be exported using an adjusted offset with ${Ab}.`),J.offset=function(t){const{uOffset:b,vOffset:Z,uRotationCenter:J,vRotationCenter:S,uScale:P,vScale:v,wAng:h}=t,C=Math.cos(h),Y=Math.sin(h),g=J*P,I=S*v;return[b+(g*(1-C)+I*Y),Z+(I*(1-C)-g*Y)]}(Z)}J.rotation=-Z.wAng,P=!0}0!==Z.coordinatesIndex&&(J.texCoord=Z.coordinatesIndex,P=!0),P&&(this._wasUsed=!0,b.extensions||(b.extensions={}),b.extensions[Ab]=J)}}Xt.RegisterExtension(Ab,(()=>new Kb));class Lb{static CreateSTL(t){let b=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",S=arguments.length>3&&void 0!==arguments[3]&&arguments[3],P=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],v=arguments.length>5&&void 0!==arguments[5]&&arguments[5],h=arguments.length>6&&void 0!==arguments[6]&&arguments[6],C=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const Y=function(t,b,Z){const S=[3*t[Z],3*t[Z+1],3*t[Z+2]],P=[new J.JZ(b[S[0]],b[S[0]+2],b[S[0]+1]),new J.JZ(b[S[1]],b[S[1]+2],b[S[1]+1]),new J.JZ(b[S[2]],b[S[2]+2],b[S[2]+1])],v=P[0].SZ(P[1]),h=P[2].SZ(P[1]);return{v:P,n:J.JZ.Cross(h,v).normalize()}},I=function(t,b,Z,J){return b=r(t,b,Z.x,J),b=r(t,b,Z.y,J),r(t,b,Z.z,J)},r=function(t,b,Z,J){return t.setFloat32(b,Z,J),b+4},T=function(t){if(h){let b=t;t instanceof M.c&&(b=t.sourceMesh);const Z=b.getVerticesData(g.g.PositionKind,!0,!0);if(!Z)return[];const S=J.JZ.Zero();let P;for(P=0;P<Z.length;P+=3)J.JZ.TransformCoordinatesFromFloatsToRef(Z[P],Z[P+1],Z[P+2],t.sb(!0),S).toArray(Z,P);return Z}return t.getVerticesData(g.g.PositionKind)||[]};h&&(v=!0);let a="",k=0,u=0;if(S){for(let Z=0;Z<t.length;Z++){const b=t[Z].Qb();k+=b?b.length/3:0}const b=new ArrayBuffer(84+50*k);a=new DataView(b),u+=80,a.setUint32(u,k,P),u+=4}else C||(a="solid stlmesh\r\n");for(let J=0;J<t.length;J++){const b=t[J];!S&&C&&(a+="solid "+b.name+"\r\n"),!v&&b instanceof lt.b&&b.bakeCurrentTransformIntoVertices();const Z=T(b),h=b.Qb()||[];for(let t=0;t<h.length;t+=3){const b=Y(h,Z,t);S?(u=I(a,u,b.n,P),u=I(a,u,b.v[0],P),u=I(a,u,b.v[1],P),u=I(a,u,b.v[2],P),u+=2):(a+="\tfacet normal "+b.n.x+" "+b.n.y+" "+b.n.z+"\r\n",a+="\t\touter loop\r\n",a+="\t\t\tvertex "+b.v[0].x+" "+b.v[0].y+" "+b.v[0].z+"\r\n",a+="\t\t\tvertex "+b.v[1].x+" "+b.v[1].y+" "+b.v[1].z+"\r\n",a+="\t\t\tvertex "+b.v[2].x+" "+b.v[2].y+" "+b.v[2].z+"\r\n",a+="\t\tendloop\r\n",a+="\tendfacet\r\n")}!S&&C&&(a+="endsolid "+name+"\r\n")}if(S||C||(a+="endsolid stlmesh"),b){const t=document.createElement("a"),b=new Blob([a],{type:"application/octet-stream"});t.href=window.URL.createObjectURL(b),t.download=Z+".stl",t.click()}return a}}function Fb(t,b){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const J=[];for(let S=0;S<t.length/Z;S++){const P=t[S*Z],v=t[S*Z+1],h=t[S*Z+2];J.push(`(${P.toPrecision(b.precision)}, ${v.toPrecision(b.precision)}, ${h.toPrecision(b.precision)})`)}return J.join(", ")}function Bb(t,b){const Z=[];for(let J=0;J<t.length/2;J++){const S=t[2*J],P=t[2*J+1];Z.push(`(${S.toPrecision(b.precision)}, ${(1-P).toPrecision(b.precision)})`)}return Z.join(", ")}function Xb(t,b){const Z=t.getVerticesData(g.g.PositionKind),J=t.getVerticesData(g.g.NormalKind);if(Z&&J)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(t){var b;const Z=null!==(b=t.Qb())&&void 0!==b&&b.length?t.getTotalIndices():t.getTotalVertices();return Array(Z/3).fill(3).join(", ")}(t)}]\n\t\tint[] faceVertexIndices = [${function(t){const b=t.Qb(),Z=[];if(null!==b)for(let J=0;J<b.length;J++)Z.push(b[J]);else{const b=t.getTotalVertices();for(let t=0;t<b;t++)Z.push(t)}return Z.join(", ")}(t)}]\n\t\tnormal3f[] normals = [${Fb(J,b)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Fb(Z,b)}]\n        ${function(t,b){let Z="";for(let S=0;S<4;S++){const J=S>0?S:"",P=t.getVerticesData(g.g.UVKind+(J?J+1:""));P&&(Z+=`\n\t\ttexCoord2f[] primvars:st${J} = [${Bb(P,b)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const J=t.getVerticesData(g.g.ColorKind);return J&&(Z+=`\n\tcolor3f[] primvars:displayColor = [${Fb(J,b,J.length/t.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),Z}(t,b)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function xb(t,b){return`\n        def "Geometry"\n        {\n        ${Xb(t,b)}\n        }\n        `}function ib(t){let b='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return b+=t,fflate.strToU8(b)}function zb(t){const b=t.m;return`( ${Db(b,0)}, ${Db(b,4)}, ${Db(b,8)}, ${Db(b,12)} )`}function Db(t,b){return`(${t[b+0]}, ${t[b+1]}, ${t[b+2]}, ${t[b+3]})`}function fb(t){const b="Object_"+t.uniqueId,Z=function(t){const b=t.getWorldMatrix().clone(),Z=t.et().useRightHandedSystem;if(!Z){let J=t.parent;for(;J;){if(vt(J,Z)){b.multiplyToRef(J.getWorldMatrix().invert(),b);break}J=J.parent}}return b.determinant()<0&&S.Tools.Warn(`Exporting mesh ${t.name} with negative scale. Result may look incorrect in destination engine.`),b}(t),J=zb(Z);return`def Xform "${b}" (\n\tprepend references = @./geometries/Geometry_${t.qb.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${J}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${t.material.uniqueId}>\n}\n\n`}function mZ(t){switch(t){case o.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case o.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case o.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Rb(t){return`(${t.x}, ${t.y})`}function wb(t){return`(${t.r}, ${t.g}, ${t.b})`}function Gb(t,b,Z,S,P,v){const h=t.getInternalTexture().uniqueId+"_"+t.invertY;P[h]=t;const C=t.coordinatesIndex>0?"st"+t.coordinatesIndex:"st",Y=new J.Vector2(t.uScale,t.vScale),g=new J.Vector2(t.uOffset,t.vOffset),I=t.wAng,r=Math.sin(I),M=Math.cos(I);return g.y=1-g.y-Y.y,g.x+=r*Y.x,g.y+=(1-M)*Y.y,`\n    def Shader "PrimvarReader_${Z}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${C}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${Z}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${b.uniqueId}/PrimvarReader_${Z}.outputs:result>\n        float inputs:rotation = ${(I*(180/Math.PI)).toFixed(v.precision)}\n        float2 inputs:scale = ${Rb(Y)}\n        float2 inputs:translation = ${Rb(g)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${t.uniqueId}_${Z}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${h}.png@\n        float2 inputs:st.connect = </Materials/Material_${b.uniqueId}/Transform2d_${Z}.outputs:result>\n        ${S?"float4 inputs:scale = "+function(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}(S):""}\n        token inputs:sourceColorSpace = "${t.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${mZ(t.wrapU)}"\n        token inputs:wrapT = "${mZ(t.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${b.needAlphaBlending()?"float outputs:a":""}\n    }`}function tZ(t,b,Z){const J="\t\t\t",S=[],P=[],{diffuseMap:v,ib:h,alphaCutOff:C,emissiveMap:Y,emissive:g,normalMap:I,roughnessMap:r,roughnessChannel:M,roughness:T,metalnessMap:a,metalnessChannel:u,metalness:l,aoMap:U,aoMapChannel:E,aoMapIntensity:c,alphaMap:H,ior:o,clearCoatEnabled:O,clearCoat:p,clearCoatMap:e,clearCoatRoughness:W,clearCoatRoughnessMap:j}=function(t){const b={diffuseMap:null,ib:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return t instanceof at.vZ?{...b,diffuseMap:t.diffuseTexture,ib:t.diffuseColor,alphaCutOff:t.alphaCutOff,emissiveMap:t.emissiveTexture,emissive:t.emissiveColor,roughness:1,alphaMap:t.opacityTexture}:t instanceof Yb.d?{...b,diffuseMap:t._albedoTexture,ib:t._albedoColor,alphaCutOff:t._alphaCutOff,emissiveMap:t._emissiveTexture,emissive:t._emissiveColor,normalMap:t._bumpTexture,roughnessMap:t._metallicTexture,roughnessChannel:t._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:t._roughness??1,metalnessMap:t._metallicTexture,metalnessChannel:t._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:t._metallic??0,aoMap:t._ambientTexture,aoMapChannel:t._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:t._ambientTextureStrength,alphaMap:t._opacityTexture,ior:t.subSurface.indexOfRefraction,clearCoatEnabled:t.clearCoat.isEnabled,clearCoat:t.clearCoat.xb,clearCoatMap:t.clearCoat.texture,clearCoatRoughness:t.clearCoat.roughness,clearCoatRoughnessMap:t.clearCoat.useRoughnessFromMainTexture?t.clearCoat.texture:t.clearCoat.textureRoughness}:b}(t);return null!==v?(S.push(`${J}color3f inputs:diffuseColor.connect = </Materials/Material_${t.uniqueId}/Texture_${v.uniqueId}_diffuse.outputs:rgb>`),t.needAlphaBlending()?S.push(`${J}float inputs:opacity.connect = </Materials/Material_${t.uniqueId}/Texture_${v.uniqueId}_diffuse.outputs:a>`):t.needAlphaTesting()&&(S.push(`${J}float inputs:opacity.connect = </Materials/Material_${t.uniqueId}/Texture_${v.uniqueId}_diffuse.outputs:a>`),S.push(`${J}float inputs:opacityThreshold = ${C}`)),P.push(Gb(v,t,"diffuse",h,b,Z))):S.push(`${J}color3f inputs:diffuseColor = ${wb(h||k.hZ.White())}`),null!==Y?(S.push(`${J}color3f inputs:emissiveColor.connect = </Materials/Material_${t.uniqueId}/Texture_${Y.uniqueId}_emissive.outputs:rgb>`),P.push(Gb(Y,t,"emissive",g,b,Z))):g&&g.toLuminance()>0&&S.push(`${J}color3f inputs:emissiveColor = ${wb(g)}`),null!==I&&(S.push(`${J}normal3f inputs:normal.connect = </Materials/Material_${t.uniqueId}/Texture_${I.uniqueId}_normal.outputs:rgb>`),P.push(Gb(I,t,"normal",null,b,Z))),null!==U&&(S.push(`${J}float inputs:occlusion.connect = </Materials/Material_${t.uniqueId}/Texture_${U.uniqueId}_occlusion.outputs:${E}>`),P.push(Gb(U,t,"occlusion",new k.hZ(c,c,c),b,Z))),null!==r?(S.push(`${J}float inputs:roughness.connect = </Materials/Material_${t.uniqueId}/Texture_${r.uniqueId}_roughness.outputs:${M}>`),P.push(Gb(r,t,"roughness",new k.hZ(T,T,T),b,Z))):S.push(`${J}float inputs:roughness = ${T}`),null!==a?(S.push(`${J}float inputs:metallic.connect = </Materials/Material_${t.uniqueId}/Texture_${a.uniqueId}_metallic.outputs:${u}>`),P.push(Gb(a,t,"metallic",new k.hZ(l,l,l),b,Z))):S.push(`${J}float inputs:metallic = ${l}`),null!==H?(S.push(`${J}float inputs:opacity.connect = </Materials/Material_${t.uniqueId}/Texture_${H.uniqueId}_opacity.outputs:r>`),S.push(`${J}float inputs:opacityThreshold = 0.0001`),P.push(Gb(H,t,"opacity",null,b,Z))):S.push(`${J}float inputs:opacity = ${t.alpha}`),O&&(null!==e?(S.push(`${J}float inputs:clearcoat.connect = </Materials/Material_${t.uniqueId}/Texture_${e.uniqueId}_clearcoat.outputs:r>`),P.push(Gb(e,t,"clearcoat",new k.hZ(p,p,p),b,Z))):S.push(`${J}float inputs:clearcoat = ${p}`),null!==j?(S.push(`${J}float inputs:clearcoatRoughness.connect = </Materials/Material_${t.uniqueId}/Texture_${j.uniqueId}_clearcoatRoughness.outputs:g>`),P.push(Gb(j,t,"clearcoatRoughness",new k.hZ(W,W,W),b,Z))):S.push(`${J}float inputs:clearcoatRoughness = ${W}`)),S.push(`${J}float inputs:ior = ${o}`),`\n\tdef Material "Material_${t.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${S.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${t.uniqueId}/PreviewSurface.outputs:surface>\n\n${P.join("\n")}\n\n\t}\n`}async function bZ(t,b,Z){const P={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...b};"undefined"===typeof fflate&&await S.Tools.LoadScriptAsync(P.fflateUrl);const v={};v[P.modelFileName]=null;let h='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';h+=function(t){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===t.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${t.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${t.planeAnchoringAlignment}"`:""}\n            `}(P);const C={};for(const J of t.meshes){if(0===J.getTotalVertices())continue;const t=J,b=t.qb,Y=t.material;if(!Y||!b||Z&&!Z(t))continue;if(-1!==["vZ","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(Y.getClassName())){const Z="geometries/Geometry_"+b.uniqueId+".usda";if(!(Z in v)){const t=xb(b,P);v[Z]=ib(t)}Y.uniqueId in C||(C[Y.uniqueId]=Y),h+=fb(t)}else S.Tools.Warn("USDZExportAsync does not support this material type: "+Y.getClassName())}t.activeCamera&&P.exportCamera&&(h+=function(t,b){const Z="Camera_"+t.uniqueId,S=zb(J.Matrix.RotationY(Math.PI).multiply(t.getWorldMatrix()));if(t.mode===o.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${Z}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${S}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.nb.toPrecision(b.precision)}, ${t.maxZ.toPrecision(b.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(t.orthoLeft||1)+Math.abs(t.orthoRight||1))).toPrecision(b.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(t.orthoTop||1)+Math.abs(t.orthoBottom||1))).toPrecision(b.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const J=t.getEngine().getAspectRatio(t),P=b.cameraSensorWidth||35;return`def Camera "${Z}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${S}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.nb.toPrecision(b.precision)}, ${t.maxZ.toPrecision(b.precision)})\n\t\t\tfloat focalLength = ${(P/(2*Math.tan(.5*t.fov))).toPrecision(b.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(P*J).toPrecision(b.precision)}\n\t\t\tfloat verticalAperture = ${(P/J).toPrecision(b.precision)}            \n\t\t}\n\t\n\t`}}(t.activeCamera,P)),h+="\n            }\n        }\n    }";const Y={};h+=function(t,b,Z){const J=[];for(const S in t){const P=t[S];J.push(tZ(P,b,Z))}return`\n    def "Materials"\n{\n${J.join("")}\n}\n\n`}(C,Y,P),v[P.modelFileName]=fflate.strToU8(h);for(const J in Y){const t=Y[J],b=t.getSize(),Z=await t.readPixels();if(!Z)throw new Error("Texture data is not available");const S=await O.DumpTools.DumpDataAsync(b.width,b.height,Z,"image/png",void 0,!1,!0);v[`textures/Texture_${J}.png`]=new Uint8Array(S).slice()}let g=0;for(const J in v){const t=v[J];if(!t)continue;g+=34+J.length;const b=63&g;if(4!==b){const Z=new Uint8Array(64-b);v[J]=[t,{extra:{12345:Z}}]}g=t.length}return fflate.zipSync(v,{level:0})}}}]);