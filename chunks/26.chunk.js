"use strict";(self.h6ljd275xwr=self.h6ljd275xwr||[]).push([[26],{11763:(n,y,H)=>{H.r(y),H.d(y,{EXT_materials_diffuse_roughness:()=>Sy,EXT_mesh_gpu_instancing:()=>xn,GLTF2Export:()=>sn,GLTFData:()=>V,KHR_draco_mesh_compression:()=>oy,KHR_lights_punctual:()=>Vy,KHR_materials_anisotropy:()=>Ay,KHR_materials_clearcoat:()=>Ty,KHR_materials_diffuse_transmission:()=>Qy,KHR_materials_dispersion:()=>vy,KHR_materials_emissive_strength:()=>gy,KHR_materials_ior:()=>fy,KHR_materials_iridescence:()=>py,KHR_materials_sheen:()=>Xy,KHR_materials_specular:()=>ay,KHR_materials_transmission:()=>ey,KHR_materials_unlit:()=>jy,KHR_materials_volume:()=>Ry,KHR_texture_transform:()=>ry,OBJExport:()=>k,STLExport:()=>Ky,USDZExportAsync:()=>HH,_ConvertToGLTFPBRMetallicRoughness:()=>e,_SolveMetallic:()=>O,__IGLTFExporterExtension:()=>i});var o=H(11288),G=H(11094),h=H(11658);class k{static OBJ(n,y,H,k){const i=[];let B=1,V=1;y&&(H||(H="mat"),i.push("mtllib "+H+".mtl"));for(let q=0;q<n.length;q++){const H=n[q],b=H.name||`mesh${q}}`;i.push(`o ${b}`);let A=null;if(k){const n=H.Qi(!0);A=new o.Matrix,n.invertToRef(A),H.bakeTransformIntoVertices(n)}if(y){const n=H.material;n&&i.push("usemtl "+n.id)}const U=H.li;if(!U){G.Tools.Warn("No geometry is present on the mesh");continue}const T=U.getVerticesData("position"),W=U.getVerticesData("normal"),z=U.getVerticesData("uv"),Q=U.Fi();let l=0,v=0;if(!T||!Q){G.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const F=n[0].pn().useRightHandedSystem?1:-1;for(let n=0;n<T.length;n+=3)i.push("v "+T[n]*F+" "+T[n+1]+" "+T[n+2]),l++;if(null!=W)for(let n=0;n<W.length;n+=3)i.push("vn "+W[n]*F+" "+W[n+1]+" "+W[n+2]);if(null!=z)for(let n=0;n<z.length;n+=2)i.push("vt "+z[n]+" "+z[n+1]),v++;const g=["","",""],M=(H.material||H.pn().defaultMaterial)._getEffectiveOrientation(H),[f,c]=M===h.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let n=0;n<Q.length;n+=3){const y=[String(Q[n]+B),String(Q[n+f]+B),String(Q[n+c]+B)],H=[String(Q[n]+V),String(Q[n+f]+V),String(Q[n+c]+V)],o=y,G=null!=z?H:g,h=null!=W?y:g;i.push("f "+o[0]+"/"+G[0]+"/"+h[0]+" "+o[1]+"/"+G[1]+"/"+h[1]+" "+o[2]+"/"+G[2]+"/"+h[2])}k&&A&&H.bakeTransformIntoVertices(A),B+=l,V+=v}return i.join("\n")}static MTL(n){const y=[],H=n.material;y.push("newmtl mat1"),y.push("  Ns "+H.specularPower.toFixed(4)),y.push("  Ni 1.5000"),y.push("  d "+H.alpha.toFixed(4)),y.push("  Tr 0.0000"),y.push("  Tf 1.0000 1.0000 1.0000"),y.push("  illum 2"),y.push("  Ka "+H.ambientColor.r.toFixed(4)+" "+H.ambientColor.g.toFixed(4)+" "+H.ambientColor.b.toFixed(4)),y.push("  Kd "+H.diffuseColor.r.toFixed(4)+" "+H.diffuseColor.g.toFixed(4)+" "+H.diffuseColor.b.toFixed(4)),y.push("  Ks "+H.specularColor.r.toFixed(4)+" "+H.specularColor.g.toFixed(4)+" "+H.specularColor.b.toFixed(4)),y.push("  Ke "+H.emissiveColor.r.toFixed(4)+" "+H.emissiveColor.g.toFixed(4)+" "+H.emissiveColor.b.toFixed(4));H.ambientTexture&&y.push("  map_Ka "+H.ambientTexture.name),H.diffuseTexture&&y.push("  map_Kd "+H.diffuseTexture.name),H.specularTexture&&y.push("  map_Ks "+H.specularTexture.name),H.bumpTexture&&y.push("  map_bump -imfchan z "+H.bumpTexture.name),H.opacityTexture&&y.push("  map_d "+H.opacityTexture.name);return y.join("\n")}}var i=0,B=H(11154);class V{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const n in this.files){const y=this.files[n],H=new Blob([y],{type:(0,B.i)(n)});G.Tools.Download(H,n)}}}var q=H(11360),b=H(11766),A=H(11779),U=H(11798),T=H(11440),W=H(11149),z=H(11335),Q=H(11303);const l=Q.HighestCommonFactor,v={...Q,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:l};var F=H(11547),g=H(11269),M=H(11831),f=H(11839),c=H(11542);const p=1e-6,E=new z.Fy(.04,.04,.04),X=1024,d=z.Fy.White(),a=z.Fy.Black();function O(n,y,H){if(y<E.r)return 0;const o=E.r,G=n*H/(1-E.r)+y-2*E.r,h=G*G-4*o*(E.r-y);return v.Clamp((-G+Math.sqrt(h))/(2*o),0,1)}function e(n){const y=n.diffuseColor.toLinearSpace(n.pn().getEngine().useExactSrgbConversions).scale(.5),H=n.alpha,G=function(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new o.Vector2(0,1),H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new o.Vector2(0,.1),G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new o.Vector2(0,.1),h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new o.Vector2(1300,.1);return function(n,y,H,o,G){return(1-n)*(1-n)*(1-n)*y+3*(1-n)*(1-n)*n*H+3*(1-n)*n*n*o+n*n*n*G}(Math.pow(n/h.x,.333333),y.y,H.y,G.y,h.y)}(v.Clamp(n.specularPower,0,X));return{baseColorFactor:[y.r,y.g,y.b,H],metallicFactor:0,roughnessFactor:G}}function w(n,y){y.needAlphaBlending()?n.alphaMode="BLEND":y.needAlphaTesting()&&(n.alphaMode="MASK",n.alphaCutoff=y.alphaCutOff)}function j(n,y,H){const o=new Uint8Array(n*y*4);for(let G=0;G<o.length;G+=4)o[G]=o[G+1]=o[G+2]=o[G+3]=255;return M.b.CreateRGBATexture(o,n,y,H)}function I(n){if(n instanceof Uint8Array){const y=n.length,H=new Float32Array(n.length);for(let o=0;o<y;++o)H[o]=n[o]/255;return H}if(n instanceof Float32Array)return n;throw new Error("Unsupported pixel format!")}class R{constructor(n){this._exporter=n,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(n){return n?this._textureMap.get(n)??null:null}async exportStandardMaterialAsync(n,y,H){const o=e(n),h={name:n.name};if(null==n.gi||n.gi||(n.twoSidedLighting||G.Tools.Warn(n.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),h.doubleSided=!0),H){const H=[],G=n.diffuseTexture;G&&H.push(this.exportTextureAsync(G,y).then((n=>{n&&(o.baseColorTexture=n)})));const k=n.bumpTexture;k&&H.push(this.exportTextureAsync(k,y).then((n=>{n&&(h.normalTexture=n,1!==k.level&&(h.normalTexture.scale=k.level))})));const i=n.emissiveTexture;i&&(h.emissiveFactor=[1,1,1],H.push(this.exportTextureAsync(i,y).then((n=>{n&&(h.emissiveTexture=n)}))));const B=n.ambientTexture;B&&H.push(this.exportTextureAsync(B,y).then((n=>{if(n){const y={index:n.index};h.occlusionTexture=y}}))),H.length>0&&(this._exporter._materialNeedsUVsSet.add(n),await Promise.all(H))}(n.alpha<1||n.opacityTexture)&&(n.alphaMode===f.b.ALPHA_COMBINE?h.alphaMode="BLEND":G.Tools.Warn(n.name+": glTF 2.0 does not support alpha mode: "+n.alphaMode.toString())),n.emissiveColor&&!n.emissiveColor.equalsWithEpsilon(a,p)&&(h.emissiveFactor=n.emissiveColor.Ui()),h.pbrMetallicRoughness=o,w(h,n),await this._finishMaterialAsync(h,n,y);const k=this._exporter._materials;return k.push(h),k.length-1}async _finishMaterialAsync(n,y,H){const o=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",n,y),G=[];for(const h of o)G.push(this.exportTextureAsync(h,H));await Promise.all(G),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",n,y)}async _getImageDataAsync(n,y,o,G){const h=f.b.TEXTURETYPE_UNSIGNED_BYTE,k=this._exporter._babylonScene,i=k.getEngine(),B=i.createRawTexture(n,y,o,f.b.TEXTUREFORMAT_RGBA,!1,!0,g.b.NEAREST_SAMPLINGMODE,null,h);i.isWebGPU?await H.e(51).then(H.bind(H,13876)):await H.e(52).then(H.bind(H,13884)),await F.h.ApplyPostProcess("pass",B,k,h,f.b.TEXTURE_NEAREST_SAMPLINGMODE,f.b.TEXTUREFORMAT_RGBA);const V=await i._readTexturePixels(B,y,o);return await c.DumpTools.DumpDataAsync(y,o,V,G,void 0,!0,!0)}_resizeTexturesToSameDimensions(n,y,H){const o=n?n.getSize():{width:0,height:0},G=y?y.getSize():{width:0,height:0};let h,k;return o.width<G.width?(h=n&&n instanceof g.b?F.h.CreateResizedCopy(n,G.width,G.height,!0):j(G.width,G.height,H),k=y):o.width>G.width?(k=y&&y instanceof g.b?F.h.CreateResizedCopy(y,o.width,o.height,!0):j(o.width,o.height,H),h=n):(h=n,k=y),{texture1:h,texture2:k}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(n,y,H,o){const G=new Array;if(!n&&!y)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const h=n?n.pn():y?y.pn():null;if(h){var k;const i=this._resizeTexturesToSameDimensions(n,y,h),B=null===(k=i.texture1)||void 0===k?void 0:k.getSize();let V,q;const b=B.width,A=B.height,U=await i.texture1.readPixels(),T=await i.texture2.readPixels();if(!U)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(V=I(U),!T)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");q=I(T);const W=q.byteLength,Q=new Uint8Array(W),l=new Uint8Array(W),v=4,F=a;let g=0,M=0;for(let n=0;n<A;++n)for(let y=0;y<b;++y){const o=(b*n+y)*v,G={diffuseColor:new z.Fy(V[o],V[o+1],V[o+2]).toLinearSpace(h.getEngine().useExactSrgbConversions).multiply(H.diffuseColor),specularColor:new z.Fy(q[o],q[o+1],q[o+2]).toLinearSpace(h.getEngine().useExactSrgbConversions).multiply(H.specularColor),glossiness:q[o+3]*H.glossiness},k=this._convertSpecularGlossinessToMetallicRoughness(G);F.r=Math.max(F.r,k.baseColor.r),F.g=Math.max(F.g,k.baseColor.g),F.b=Math.max(F.b,k.baseColor.b),g=Math.max(g,k.metallic),M=Math.max(M,k.roughness),l[o]=255*k.baseColor.r,l[o+1]=255*k.baseColor.g,l[o+2]=255*k.baseColor.b,l[o+3]=i.texture1.Ti?255*V[o+3]:255,Q[o]=0,Q[o+1]=255*k.roughness,Q[o+2]=255*k.metallic,Q[o+3]=255}const f={baseColor:F,metallic:g,roughness:M};let c=!1,E=!1;for(let n=0;n<A;++n)for(let y=0;y<b;++y){const H=(b*n+y)*v;l[H]/=f.baseColor.r>p?f.baseColor.r:1,l[H+1]/=f.baseColor.g>p?f.baseColor.g:1,l[H+2]/=f.baseColor.b>p?f.baseColor.b:1;const o=z.Fy.FromInts(l[H],l[H+1],l[H+2]).toGammaSpace(h.getEngine().useExactSrgbConversions);l[H]=255*o.r,l[H+1]=255*o.g,l[H+2]=255*o.b,o.equalsWithEpsilon(d,p)||(E=!0),Q[H+1]/=f.roughness>p?f.roughness:1,Q[H+2]/=f.metallic>p?f.metallic:1;z.Fy.FromInts(255,Q[H+1],Q[H+2]).equalsWithEpsilon(d,p)||(c=!0)}return c&&G.push(this._getImageDataAsync(Q,b,A,o).then((n=>{f.metallicRoughnessTextureData=n}))),E&&G.push(this._getImageDataAsync(l,b,A,o).then((n=>{f.baseColorTextureData=n}))),await Promise.all(G).then((()=>f))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(n){const y=this._getPerceivedBrightness(n.diffuseColor),H=this._getPerceivedBrightness(n.specularColor),o=1-this._getMaxComponent(n.specularColor),G=O(y,H,o),h=n.diffuseColor.scale(o/(1-E.r)/Math.max(1-G)),k=n.specularColor.Qy(E.scale(1-G)).scale(1/Math.max(G));let i=z.Fy.Lerp(h,k,G*G);i=i.clampToRef(0,1,i);return{baseColor:i,metallic:G,roughness:1-n.glossiness}}_getPerceivedBrightness(n){return n?Math.sqrt(.299*n.r*n.r+.587*n.g*n.g+.114*n.b*n.b):0}_getMaxComponent(n){return n?Math.max(n.r,Math.max(n.g,n.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(n,y,H,o){const G=[],h={baseColor:n._albedoColor,metallic:n._metallic,roughness:n._roughness};if(o){n._albedoTexture&&G.push(this.exportTextureAsync(n._albedoTexture,y).then((n=>{n&&(H.baseColorTexture=n)})));const o=n._metallicTexture;o&&G.push(this.exportTextureAsync(o,y).then((n=>{n&&(H.metallicRoughnessTexture=n)})))}return G.length>0&&(this._exporter._materialNeedsUVsSet.add(n),await Promise.all(G)),h}_getTextureSampler(n){const y={};if(!n||!(n instanceof g.b))return y;const H=this._getGLTFTextureWrapMode(n.wrapU);10497!==H&&(y.wrapS=H);const o=this._getGLTFTextureWrapMode(n.wrapV);switch(10497!==o&&(y.wrapT=o),n.samplingMode){case g.b.LINEAR_LINEAR:y.magFilter=9729,y.minFilter=9729;break;case g.b.LINEAR_NEAREST:y.magFilter=9729,y.minFilter=9728;break;case g.b.NEAREST_LINEAR:y.magFilter=9728,y.minFilter=9729;break;case g.b.NEAREST_LINEAR_MIPLINEAR:y.magFilter=9728,y.minFilter=9987;break;case g.b.NEAREST_NEAREST:y.magFilter=9728,y.minFilter=9728;break;case g.b.NEAREST_LINEAR_MIPNEAREST:y.magFilter=9728,y.minFilter=9985;break;case g.b.LINEAR_NEAREST_MIPNEAREST:y.magFilter=9729,y.minFilter=9984;break;case g.b.LINEAR_NEAREST_MIPLINEAR:y.magFilter=9729,y.minFilter=9986;break;case g.b.NEAREST_NEAREST_MIPLINEAR:y.magFilter=9728,y.minFilter=9986;break;case g.b.LINEAR_LINEAR_MIPLINEAR:y.magFilter=9729,y.minFilter=9987;break;case g.b.LINEAR_LINEAR_MIPNEAREST:y.magFilter=9729,y.minFilter=9985;break;case g.b.NEAREST_NEAREST_MIPNEAREST:y.magFilter=9728,y.minFilter=9984}return y}_getGLTFTextureWrapMode(n){switch(n){case g.b.WRAP_ADDRESSMODE:return 10497;case g.b.CLAMP_ADDRESSMODE:return 33071;case g.b.MIRROR_ADDRESSMODE:return 33648;default:return G.Tools.Error(`Unsupported Texture Wrap Mode ${n}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(n,y,H,o){const G={diffuseColor:n._albedoColor,specularColor:n._reflectivityColor,glossiness:n._microSurface},h=n._albedoTexture,k=n._reflectivityTexture,i=n._useMicroSurfaceFromReflectivityMapAlpha;if(k&&!i)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((h||k)&&o){this._exporter._materialNeedsUVsSet.add(n);const o=this._exportTextureSampler(h||k),i=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(h,k,G,y),B=this._exporter._textures;if(i.baseColorTextureData){const n=this._exportImage(`baseColor${B.length}`,y,i.baseColorTextureData);H.baseColorTexture=this._exportTextureInfo(n,o,null===h||void 0===h?void 0:h.coordinatesIndex)}if(i.metallicRoughnessTextureData){const n=this._exportImage(`metallicRoughness${B.length}`,y,i.metallicRoughnessTextureData);H.metallicRoughnessTexture=this._exportTextureInfo(n,o,null===k||void 0===k?void 0:k.coordinatesIndex)}return i}return this._convertSpecularGlossinessToMetallicRoughness(G)}async exportPBRMaterialAsync(n,y,H){const o={},G={name:n.name},h=n.isMetallicWorkflow();if(h){const y=n._albedoColor,H=n.alpha;y&&(o.baseColorFactor=[y.r,y.g,y.b,H])}const k=h?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(n,y,o,H):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(n,y,o,H);await this._setMetallicRoughnessPbrMaterialAsync(k,n,G,o,y,H),await this._finishMaterialAsync(G,n,y);const i=this._exporter._materials;return i.push(G),i.length-1}async _setMetallicRoughnessPbrMaterialAsync(n,y,H,o,h,k){if(w(H,y),n.baseColor.equalsWithEpsilon(d,p)&&v.WithinEpsilon(y.alpha,1,p)||(o.baseColorFactor=[n.baseColor.r,n.baseColor.g,n.baseColor.b,y.alpha]),null!=n.metallic&&1!==n.metallic&&(o.metallicFactor=n.metallic),null!=n.roughness&&1!==n.roughness&&(o.roughnessFactor=n.roughness),null==y.gi||y.gi||(y._twoSidedLighting||G.Tools.Warn(y.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),H.doubleSided=!0),k){const n=[],o=y._bumpTexture;o&&n.push(this.exportTextureAsync(o,h).then((n=>{n&&(H.normalTexture=n,1!==o.level&&(H.normalTexture.scale=o.level))})));const G=y._ambientTexture;G&&n.push(this.exportTextureAsync(G,h).then((n=>{if(n){const o={index:n.index,texCoord:n.texCoord,extensions:n.extensions};H.occlusionTexture=o;const G=y._ambientTextureStrength;G&&(o.strength=G)}})));const k=y._emissiveTexture;k&&n.push(this.exportTextureAsync(k,h).then((n=>{n&&(H.emissiveTexture=n)}))),n.length>0&&(this._exporter._materialNeedsUVsSet.add(y),await Promise.all(n))}const i=y._emissiveColor;i.equalsWithEpsilon(a,p)||(H.emissiveFactor=i.Ui()),H.pbrMetallicRoughness=o}_getPixelsFromTextureAsync(n){return function(n){switch(n){case f.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case f.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case f.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case f.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case f.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case f.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case f.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case f.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case f.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case f.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case f.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case f.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case f.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case f.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case f.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case f.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case f.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case f.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case f.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case f.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case f.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(n.textureFormat)?(0,F.f)(n,n._texture.width,n._texture.height):(n.textureType,f.b.TEXTURETYPE_UNSIGNED_BYTE,n.readPixels())}async exportTextureAsync(n,y){const H=this._exporter._extensionsPreExportTextureAsync("exporter",n,y);return H?await H.then((async H=>H?await this._exportTextureInfoAsync(H,y):await this._exportTextureInfoAsync(n,y))):await this._exportTextureInfoAsync(n,y)}async _exportTextureInfoAsync(n,y){let H=this._textureMap.get(n);if(!H){const o=await this._getPixelsFromTextureAsync(n);if(!o)return null;const h=this._exportTextureSampler(n),k=n.mimeType;if(k)switch(k){case"image/jpeg":case"image/png":case"image/webp":y=k;break;default:G.Tools.Warn(`Unsupported media type: ${k}. Exporting texture as PNG.`)}const i=this._internalTextureToImage,B=n.getInternalTexture().uniqueId;i[B]||(i[B]={});let V=i[B][y];if(void 0===V){const H=n.getSize();V=(async()=>{const G=await this._getImageDataAsync(o,H.width,H.height,y);return this._exportImage(n.name,y,G)})(),i[B][y]=V}H=this._exportTextureInfo(await V,h,n.coordinatesIndex),this._textureMap.set(n,H),this._exporter._extensionsPostExportTextures("exporter",H,n)}return H}_exportImage(n,y,H){const o=this._exporter._images;let h;if(this._exporter._shouldUseGlb){h={name:n,mimeType:y,bufferView:void 0};const o=this._exporter._bufferManager.createBufferView(new Uint8Array(H));this._exporter._bufferManager.setBufferView(h,o)}else{const k=n.replace(/\.\/|\/|\.\\|\\/g,"_"),i=function(n){switch(n){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(y);let B=k+i;o.some((n=>n.uri===B))&&(B=`${k}_${G.Tools.RandomId()}${i}`),h={name:n,uri:B},this._exporter._imageData[B]={data:H,mimeType:y}}return o.push(h),o.length-1}_exportTextureInfo(n,y,H){const o=this._exporter._textures;let G=o.findIndex((H=>H.sampler==y&&H.source===n));-1===G&&(G=o.length,o.push({source:n,sampler:y}));const h={index:G};return H&&(h.texCoord=H),h}_exportTextureSampler(n){const y=this._getTextureSampler(n),H=this._exporter._samplers,o=H.findIndex((n=>n.minFilter===y.minFilter&&n.magFilter===y.magFilter&&n.wrapS===y.wrapS&&n.wrapT===y.wrapT));return-1!==o?o:(H.push(y),H.length-1)}}var C=H(11375),S=H(11114),N=H(11844),r=H(11297);const K=o.zy.Zero(),Y=o.Quaternion.Identity(),D=o.zy.One(),Z=new o.zy(-1,1,1);function s(n,y){const{byteOffset:H,byteStride:o,type:G,normalized:h}=n,k=n.getSize(),i=y.reduce(((n,y)=>y.getTotalVertices()>n?y.getTotalVertices():n),-Number.MAX_VALUE);return{byteOffset:H,byteStride:o,componentCount:k,type:G,count:i*k,normalized:h,totalVertices:i,kind:n.getKind()}}function P(n){switch(n){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function x(n){switch(n){case q.g.PositionKind:case q.g.NormalKind:case q.g.TangentKind:case q.g.ColorKind:case q.g.MatricesIndicesKind:case q.g.MatricesIndicesExtraKind:case q.g.MatricesWeightsKind:case q.g.MatricesWeightsExtraKind:case q.g.UVKind:case q.g.UV2Kind:case q.g.UV3Kind:case q.g.UV4Kind:case q.g.UV5Kind:case q.g.UV6Kind:return!0}return!1}function t(n){switch(n){case h.e.TriangleFillMode:return 4;case h.e.TriangleStripDrawMode:return 5;case h.e.TriangleFanDrawMode:return 6;case h.e.PointListDrawMode:case h.e.PointFillMode:return 0;case h.e.LineLoopDrawMode:return 2;case h.e.LineListDrawMode:return 1;case h.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${n}`)}function u(n){const y=Math.sqrt(n.x*n.x+n.y*n.y+n.z*n.z);y>0&&(n.x/=y,n.y/=y,n.z/=y)}function L(n){return n.x*=-1,n}function J(n){if(n.x*n.x+n.y*n.y>.5){const y=Math.abs(n.x),H=Math.abs(n.y);if(y>H){const H=Math.sign(n.x);n.x=y,n.y*=-H,n.z*=-H,n.w*=H}else{const y=Math.sign(n.y);n.x*=-y,n.y=H,n.z*=y,n.w*=-y}}else{const y=Math.abs(n.z),H=Math.abs(n.w);if(y>H){const H=Math.sign(n.z);n.x*=-H,n.y*=H,n.z=y,n.w*=-H}else{const y=Math.sign(n.w);n.x*=y,n.y*=-y,n.z*=-y,n.w=H}}return n}function m(n){n.Mi(-n.z,n.w,n.x,-n.y)}function nn(n,y){const H=o.zy.FromArrayToRef(y.translation||[0,0,0],0,o.TmpVectors.zy[0]),G=o.Quaternion.FromArrayToRef(y.rotation||[0,0,0,1],0,o.TmpVectors.Quaternion[0]),h=o.Matrix.ComposeToRef(D,G,H,o.TmpVectors.Matrix[0]),k=o.zy.FromArrayToRef(n.translation||[0,0,0],0,o.TmpVectors.zy[2]),i=o.Quaternion.FromArrayToRef(n.rotation||[0,0,0,1],0,o.TmpVectors.Quaternion[1]),B=o.Matrix.ComposeToRef(D,i,k,o.TmpVectors.Matrix[1]);h.multiplyToRef(B,B),B.decompose(void 0,G,H),H.equalsWithEpsilon(K,r.e)?delete y.translation:y.translation=H.Ui(),G.equalsWithEpsilon(Y,r.e)?delete y.rotation:y.rotation=G.Ui(),y.scale&&delete y.scale}function yn(n,y){if(!(y instanceof b.c))return!1;if(!(1===y.getChildren().length&&0===n.getChildren().length&&n.parent===y))return!1;const H=n.pn(),o=n instanceof N.d&&!H.useRightHandedSystem?Z:D;return!!y.fi.equalsWithEpsilon(o,r.e)||(S.d.Warn(`Cannot collapse node ${n.name} into parent node ${y.name} with modified scaling.`),!1)}function Hn(n){if(n instanceof Array){const y=new Float32Array(n);return new Uint8Array(y.buffer,y.byteOffset,y.byteLength)}return ArrayBuffer.isView(n)?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):new Uint8Array(n)}function on(n,y){for(const[H,o]of Object.entries(n)){const G=y[H];(Array.isArray(o)&&Array.isArray(G)&&Gn(o,G)||o===G)&&delete n[H]}return n}function Gn(n,y){return n.length===y.length&&n.every(((n,H)=>n===y[H]))}const hn=o.Matrix.Compose(new o.zy(-1,1,1),o.Quaternion.Identity(),o.zy.Zero());function kn(n,y){if(!(n instanceof b.c))return!1;if(y){if(!n.getWorldMatrix().equalsWithEpsilon(o.Matrix.IdentityReadOnly,r.e))return!1}else{if(!n.getWorldMatrix().multiplyToRef(hn,o.TmpVectors.Matrix[0]).equalsWithEpsilon(o.Matrix.IdentityReadOnly,r.e))return!1}return!(n instanceof A.d&&n.li)}const Bn=new Map([[Int8Array,(n,y,H)=>n.setInt8(y,H)],[Uint8Array,(n,y,H)=>n.setUint8(y,H)],[Uint8ClampedArray,(n,y,H)=>n.setUint8(y,H)],[Int16Array,(n,y,H)=>n.setInt16(y,H,!0)],[Uint16Array,(n,y,H)=>n.setUint16(y,H,!0)],[Int32Array,(n,y,H)=>n.setInt32(y,H,!0)],[Uint32Array,(n,y,H)=>n.setUint32(y,H,!0)],[Float32Array,(n,y,H)=>n.setFloat32(y,H,!0)],[Float64Array,(n,y,H)=>n.setFloat64(y,H,!0)]]);class Vn{writeTypedArray(n){this._checkGrowBuffer(n.byteLength);const y=Bn.get(n.constructor);for(let H=0;H<n.length;H++)y(this._dataView,this._byteOffset,n[H]),this._byteOffset+=n.BYTES_PER_ELEMENT}constructor(n){this._data=new Uint8Array(n),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(n){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,n),this._byteOffset++}writeInt8(n){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,n),this._byteOffset++}writeInt16(n){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,n,!0),this._byteOffset+=2}writeUInt16(n){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,n,!0),this._byteOffset+=2}writeInt32(n){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,n,!0),this._byteOffset+=4}writeUInt32(n){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,n,!0),this._byteOffset+=4}writeFloat32(n){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,n,!0),this._byteOffset+=4}writeFloat64(n){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,n,!0),this._byteOffset+=8}_checkGrowBuffer(n){const y=this.byteOffset+n;if(y>this._data.byteLength){const n=new Uint8Array(2*y);n.set(this._data),this._data=n,this._dataView=new DataView(this._data.buffer)}}}function qn(n){return n%4===0?4:n%2===0?2:1}class bn{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(n){let y=0;this._bufferViewToData.forEach((n=>{y+=n.byteLength}));const H=new Vn(y),o=Array.from(this._bufferViewToData.keys()).sort(((n,y)=>qn(y.byteLength)-qn(n.byteLength)));for(const G of o){G.byteOffset=H.byteOffset,n.push(G);const y=n.length-1,o=this.getPropertiesWithBufferView(G);for(const n of o)n.bufferView=y;H.writeTypedArray(this._bufferViewToData.get(G)),this._bufferViewToData.delete(G)}return H.getOutputData()}createBufferView(n,y){const H={buffer:0,byteOffset:void 0,byteLength:n.byteLength,byteStride:y};return this._bufferViewToData.set(H,n),H}createAccessor(n,y,H,o,G,h,k){this._verifyBufferView(n);const i={bufferView:void 0,componentType:H,count:o,type:y,min:null===h||void 0===h?void 0:h.min,max:null===h||void 0===h?void 0:h.max,normalized:k,byteOffset:G};return this.setBufferView(i,n),this._accessorToBufferView.set(i,n),i}setBufferView(n,y){this._verifyBufferView(y);this.getPropertiesWithBufferView(y).push(n)}removeBufferView(n){const y=this.getPropertiesWithBufferView(n);for(const H of y)void 0!==H.bufferView&&delete H.bufferView;this._bufferViewToData.delete(n),this._bufferViewToProperties.delete(n),this._accessorToBufferView.forEach(((y,H)=>{y===n&&(void 0!==H.byteOffset&&delete H.byteOffset,this._accessorToBufferView.delete(H))}))}getBufferView(n){const y=this._accessorToBufferView.get(n);return this._verifyBufferView(y),y}getPropertiesWithBufferView(n){return this._verifyBufferView(n),this._bufferViewToProperties.set(n,this._bufferViewToProperties.get(n)??[]),this._bufferViewToProperties.get(n)}getData(n){return this._verifyBufferView(n),this._bufferViewToData.get(n)}_verifyBufferView(n){if(void 0===n||!this._bufferViewToData.has(n))throw new Error(`BufferView ${n} not found in BufferManager.`)}}var An,Un=H(11806),Tn=H(11827),Wn=H(11846),zn=H(11714),Qn=H(11885),ln=H(11901),vn=H(11800),Fn=H(11907);!function(n){n[n.INTANGENT=0]="INTANGENT",n[n.OUTTANGENT=1]="OUTTANGENT"}(An||(An={}));class gn{static _IsTransformable(n){return n&&(n instanceof b.c||n instanceof Un.d||n instanceof Fn.e)}static _CreateNodeAnimation(n,y,H,o,h){if(this._IsTransformable(n)){const k=[],i=[],B=y.getKeys(),V=gn._CalculateMinMaxKeyFrames(B),q=gn._DeduceInterpolation(B,H,o),b=q.interpolationType,A=q.shouldBakeAnimation;if(A?gn._CreateBakedAnimation(n,y,H,V.min,V.max,y.framePerSecond,h,k,i,V,o):"LINEAR"===b||"STEP"===b?gn._CreateLinearOrStepAnimation(n,y,H,k,i,o):"CUBICSPLINE"===b?gn._CreateCubicSplineAnimation(n,y,H,k,i,o):gn._CreateBakedAnimation(n,y,H,V.min,V.max,y.framePerSecond,h,k,i,V,o),k.length&&i.length){return{inputs:k,outputs:i,samplerInterpolation:b,inputsMin:A?V.min:G.Tools.FloatRound(V.min/y.framePerSecond),inputsMax:A?V.max:G.Tools.FloatRound(V.max/y.framePerSecond)}}}return null}static _DeduceAnimationInfo(n){let y=null,H="VEC3",o=!1;const h=n.targetProperty.split(".");switch(h[0]){case"fi":y="scale";break;case"position":y="translation";break;case"rotation":H="VEC4",y="rotation";break;case"rotationQuaternion":H="VEC4",o=!0,y="rotation";break;case"influence":H="SCALAR",y="weights";break;default:G.Tools.Error(`Unsupported animatable property ${h[0]}`)}return y?{animationChannelTargetPath:y,dataAccessorType:H,useQuaternion:o}:(G.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(n,y,H,o,G,h,k,i,B,V,q){let b;if(gn._IsTransformable(n)&&n.animations)for(const A of n.animations){if(q&&!q(A))continue;const G=gn._DeduceAnimationInfo(A);G&&(b={name:A.name,samplers:[],channels:[]},gn._AddAnimation(`${A.name}`,A.hasRunningRuntimeAnimations?y:b,n,A,G.dataAccessorType,G.animationChannelTargetPath,o,h,k,i,G.useQuaternion,B,V),b.samplers.length&&b.channels.length&&H.push(b))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(n,y,H,o,G,h,k,i,B,V,q){let b;if(n instanceof vn.b){const G=n.morphTargetManager;if(G)for(let A=0;A<G.numTargets;++A){const U=G.getTarget(A);for(const T of U.animations){if(q&&!q(T))continue;const U=new Qn.e(`${T.name}`,"influence",T.framePerSecond,T.dataType,T.loopMode,T.enableBlending),W=[],z=T.getKeys();for(let n=0;n<z.length;++n){const y=z[n];for(let n=0;n<G.numTargets;++n)n==A?W.push(y):W.push({frame:y.frame,value:0})}U.setKeys(W);const Q=gn._DeduceAnimationInfo(U);Q&&(b={name:U.name,samplers:[],channels:[]},gn._AddAnimation(T.name,T.hasRunningRuntimeAnimations?y:b,n,U,Q.dataAccessorType,Q.animationChannelTargetPath,o,h,k,i,Q.useQuaternion,B,V,G.numTargets),b.samplers.length&&b.channels.length&&H.push(b))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(n,y,H,o,G,h,k,i,B){let V;if(n.animationGroups){const b=n.animationGroups;for(const A of b){const b=new Map,U=new Map,T=new Set,W=A.to-A.from;V={name:A.name,channels:[],samplers:[]};for(let y=0;y<A.targetedAnimations.length;++y){const W=A.targetedAnimations[y],z=W.target,Q=W.animation;if(B&&!B(Q))continue;const l=i.has(z);if(this._IsTransformable(z)||1===z.length&&this._IsTransformable(z[0])){const n=gn._DeduceAnimationInfo(W.animation);if(n){const y=this._IsTransformable(z)?z:this._IsTransformable(z[0])?z[0]:null;y&&gn._AddAnimation(`${Q.name}`,V,y,Q,n.dataAccessorType,n.animationChannelTargetPath,H,o,G,h,n.useQuaternion,k,l)}}else if(z instanceof ln.c||1===z.length&&z[0]instanceof ln.c){if(gn._DeduceAnimationInfo(W.animation)){const y=z instanceof ln.c?z:z[0];if(y){const H=n.morphTargetManagers.find((n=>{for(let H=0;H<n.numTargets;++H)if(n.getTarget(H)===y)return!0;return!1}));if(H){const o=n.meshes.find((n=>n.morphTargetManager===H));var q;if(o)b.has(o)||b.set(o,new Map),null===(q=b.get(o))||void 0===q||q.set(y,Q),T.add(o),U.set(o,Q)}}}}}T.forEach((n=>{const y=n.morphTargetManager;let i=null;const B=[],q=U.get(n).getKeys(),T=q.length;for(let H=0;H<T;++H)for(let o=0;o<y.numTargets;++o){const G=y.getTarget(o),h=b.get(n);if(h){const y=h.get(G);y?(i||(i=new Qn.e(`${A.name}_${n.name}_MorphWeightAnimation`,"influence",y.framePerSecond,Qn.e.ANIMATIONTYPE_FLOAT,y.loopMode,y.enableBlending)),B.push(y.getKeys()[H])):B.push({frame:A.from+W/T*H,value:G.influence,inTangent:q[0].inTangent?0:void 0,outTangent:q[0].outTangent?0:void 0})}}i.setKeys(B);const z=gn._DeduceAnimationInfo(i);z&&gn._AddAnimation(`${A.name}_${n.name}_MorphWeightAnimation`,V,n,i,z.dataAccessorType,z.animationChannelTargetPath,H,o,G,h,z.useQuaternion,k,!1,null===y||void 0===y?void 0:y.numTargets)})),V.channels.length&&V.samplers.length&&y.push(V)}}}static _AddAnimation(n,y,H,G,h,k,i,B,V,q,b,A,U,T){const W=gn._CreateNodeAnimation(H,G,k,b,A);let z,Q,l,v,F,g;if(W){if(T){let n=0,y=0;const H=[];for(;W.inputs.length>0;)y=W.inputs.shift(),n%T==0&&H.push(y),n++;W.inputs=H}const n=i.get(H),G=new Float32Array(W.inputs);z=B.createBufferView(G),Q=B.createAccessor(z,"SCALAR",5126,W.inputs.length,void 0,{min:[W.inputsMin],max:[W.inputsMax]}),q.push(Q),l=q.length-1;const V=new o.Quaternion,b=new o.zy,A=new o.zy,M=H instanceof Un.d,f=P(h),c=new Float32Array(W.outputs.length*f);W.outputs.forEach((function(n,y){let H=n;switch(k){case"translation":U&&(o.zy.FromArrayToRef(n,0,A),L(A),A.toArray(H));break;case"rotation":4===n.length?o.Quaternion.FromArrayToRef(n,0,V):(H=new Array(4),o.zy.FromArrayToRef(n,0,b),o.Quaternion.FromEulerVectorToRef(b,V)),U&&(J(V),M&&m(V)),V.toArray(H)}c.set(H,y*f)})),z=B.createBufferView(c),Q=B.createAccessor(z,h,5126,W.outputs.length),q.push(Q),v=q.length-1,F={interpolation:W.samplerInterpolation,input:l,output:v},y.samplers.push(F),g={sampler:y.samplers.length-1,target:{node:n,path:k}},y.channels.push(g)}}static _CreateBakedAnimation(n,y,H,h,k,i,B,V,q,b,A){let U;const T=o.Quaternion.Identity();let W,z=null,Q=null,l=null,v=null,F=null,g=null;b.min=G.Tools.FloatRound(h/i);const M=y.getKeys();for(let o=0,f=M.length;o<f;++o){if(g=null,l=M[o],o+1<f)if(v=M[o+1],l.value.equals&&l.value.equals(v.value)||l.value===v.value){if(0!==o)continue;g=l.frame}else g=v.frame;else{if(F=M[o-1],l.value.equals&&l.value.equals(F.value)||l.value===F.value)continue;g=k}if(g)for(let o=l.frame;o<=g;o+=B){if(W=G.Tools.FloatRound(o/i),W===z)continue;z=W,Q=W;const h={key:0,repeatCount:0,loopMode:y.loopMode};U=y._interpolate(o,h),gn._SetInterpolatedValue(n,U,W,y,H,T,V,q,A)}}Q&&(b.max=Q)}static _ConvertFactorToVector3OrQuaternion(n,y,H,h,k){const i=gn._GetBasePositionRotationOrScale(y,h,k),B=H.targetProperty.split("."),V=B?B[1]:"",q=k?o.Quaternion.gy(i).normalize():o.zy.gy(i);switch(V){case"x":case"y":case"z":q[V]=n;break;case"w":q.w=n;break;default:G.Tools.Error(`glTFAnimation: Unsupported component name "${V}"!`)}return q}static _SetInterpolatedValue(n,y,H,G,h,k,i,B,V){let q;i.push(H),"weights"!==h?(G.dataType===Qn.e.ANIMATIONTYPE_FLOAT&&(y=this._ConvertFactorToVector3OrQuaternion(y,n,G,h,V)),"rotation"===h?(V?k=y:(q=y,o.Quaternion.RotationYawPitchRollToRef(q.y,q.x,q.z,k)),B.push(k.Ui())):(q=y,B.push(q.Ui()))):B.push([y])}static _CreateLinearOrStepAnimation(n,y,H,o,G,h){for(const k of y.getKeys())o.push(k.frame/y.framePerSecond),gn._AddKeyframeValue(k,y,G,H,n,h)}static _CreateCubicSplineAnimation(n,y,H,o,G,h){y.getKeys().forEach((function(k){o.push(k.frame/y.framePerSecond),gn._AddSplineTangent(An.INTANGENT,G,H,"CUBICSPLINE",k,h),gn._AddKeyframeValue(k,y,G,H,n,h),gn._AddSplineTangent(An.OUTTANGENT,G,H,"CUBICSPLINE",k,h)}))}static _GetBasePositionRotationOrScale(n,y,H){let G;if("rotation"===y)if(H){G=(n.rotationQuaternion??o.Quaternion.Identity()).Ui()}else{G=(n.rotation??o.zy.Zero()).Ui()}else if("translation"===y){G=(n.position??o.zy.Zero()).Ui()}else{G=(n.fi??o.zy.One()).Ui()}return G}static _AddKeyframeValue(n,y,H,h,k,i){let B;const V=y.dataType;if(V===Qn.e.ANIMATIONTYPE_VECTOR3){let y=n.value.Ui();if("rotation"===h){const n=o.zy.gy(y);y=o.Quaternion.RotationYawPitchRoll(n.y,n.x,n.z).Ui()}H.push(y)}else if(V===Qn.e.ANIMATIONTYPE_FLOAT){if("weights"===h)H.push([n.value]);else if(B=this._ConvertFactorToVector3OrQuaternion(n.value,k,y,h,i),B){if("rotation"===h){const n=i?B:o.Quaternion.RotationYawPitchRoll(B.y,B.x,B.z).normalize();H.push(n.Ui())}H.push(B.Ui())}}else V===Qn.e.ANIMATIONTYPE_QUATERNION?H.push(n.value.normalize().Ui()):G.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(n,y,H){let o,G,h=!1;if("rotation"===y&&!H)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let k=0,i=n.length;k<i;++k)if(G=n[k],G.inTangent||G.outTangent)if(o){if("CUBICSPLINE"!==o){o="LINEAR",h=!0;break}}else o="CUBICSPLINE";else if(o){if("CUBICSPLINE"===o||G.interpolation&&1===G.interpolation&&"STEP"!==o){o="LINEAR",h=!0;break}}else o=G.interpolation&&1===G.interpolation?"STEP":"LINEAR";return o||(o="LINEAR"),{interpolationType:o,shouldBakeAnimation:h}}static _AddSplineTangent(n,y,H,G,h,k){let i;const B=n===An.INTANGENT?h.inTangent:h.outTangent;if("CUBICSPLINE"===G){if("rotation"===H)if(B)if(k)i=B.Ui();else{const n=B;i=o.Quaternion.RotationYawPitchRoll(n.y,n.x,n.z).Ui()}else i=[0,0,0,0];else i="weights"===H?B?[B]:[0]:B?B.Ui():[0,0,0];y.push(i)}}static _CalculateMinMaxKeyFrames(n){let y=1/0,H=-1/0;return n.forEach((function(n){y=Math.min(y,n.frame),H=Math.max(H,n.frame)})),{min:y,max:H}}}function Mn(n,y,H,h,k,i){const B={attributes:{},influence:n.influence,name:n.name},V=y.li;if(!V)return G.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),B;const b=i?-1:1,A=o.zy.Zero();let U=0,T=0;if(n.hasPositions){const h=n.getPositions(),i=V.getVerticesData(q.g.PositionKind);if(i){const n=new Float32Array(i.length),y=[1/0,1/0,1/0],G=[-1/0,-1/0,-1/0];T=i.length/3,U=0;for(let H=U;H<T;++H){const k=o.zy.gy(i,3*H);o.zy.gy(h,3*H).subtractToRef(k,A),A.x*=b,y[0]=Math.min(y[0],A.x),G[0]=Math.max(G[0],A.x),y[1]=Math.min(y[1],A.y),G[1]=Math.max(G[1],A.y),y[2]=Math.min(y[2],A.z),G[2]=Math.max(G[2],A.z),n[3*H]=A.x,n[3*H+1]=A.y,n[3*H+2]=A.z}const V=H.createBufferView(n,12),q=H.createAccessor(V,"VEC3",5126,h.length/3,0,{min:y,max:G});k.push(q),B.attributes.POSITION=k.length-1}else G.Tools.Warn(`Morph target positions for mesh ${y.name} were not exported. Mesh does not have position vertex data`)}if(n.hasNormals){const h=n.getNormals(),i=V.getVerticesData(q.g.NormalKind);if(i){const n=new Float32Array(i.length);T=i.length/3,U=0;for(let H=U;H<T;++H){const y=o.zy.gy(i,3*H).normalize();o.zy.gy(h,3*H).normalize().subtractToRef(y,A),n[3*H]=A.x*b,n[3*H+1]=A.y,n[3*H+2]=A.z}const y=H.createBufferView(n,12),G=H.createAccessor(y,"VEC3",5126,h.length/3,0);k.push(G),B.attributes.NORMAL=k.length-1}else G.Tools.Warn(`Morph target normals for mesh ${y.name} were not exported. Mesh does not have normals vertex data`)}if(n.hasTangents){const h=n.getTangents(),i=V.getVerticesData(q.g.TangentKind);if(i){T=i.length/4;const n=new Float32Array(3*T);U=0;for(let H=U;H<T;++H){const y=o.zy.gy(i,4*H);u(y);const G=o.zy.gy(h,3*H);u(G),G.subtractToRef(y,A),n[3*H]=A.x*b,n[3*H+1]=A.y,n[3*H+2]=A.z}const y=H.createBufferView(n,12),G=H.createAccessor(y,"VEC3",5126,T,0);k.push(G),B.attributes.TANGENT=k.length-1}else G.Tools.Warn(`Morph target tangents for mesh ${y.name} were not exported. Mesh does not have tangents vertex data`)}if(n.hasColors){const h=n.getColors(),i=V.getVerticesData(q.g.ColorKind),b=V.getVertexBuffer(q.g.ColorKind);if(i&&b){const n=b.getSize();T=i.length/n;const y=new Float32Array(T*n);U=0;for(let H=U;H<T;++H)if(3===n){const G=o.zy.gy(i,H*n);o.zy.gy(h,H*n).subtractToRef(G,A),y[3*H]=A.x,y[3*H+1]=A.y,y[3*H+2]=A.z}else if(4===n){const G=new o.Vector4,k=o.Vector4.gy(i,H*n);o.Vector4.gy(h,H*n).subtractToRef(k,G),y[4*H]=G.x,y[4*H+1]=G.y,y[4*H+2]=G.z,y[4*H+3]=G.w}else G.Tools.Warn(`Unsupported number of components for color attribute: ${n}`);const V=H.createBufferView(y,4*n),q=H.createAccessor(V,3===n?"VEC3":"VEC4",5126,T,0);k.push(q),B.attributes.COLOR_0=k.length-1}else G.Tools.Warn(`Morph target colors for mesh ${y.name} were not exported. Mesh does not have colors vertex data`)}return B}var fn=H(11915),cn=H(11754),pn=H(11732),En=H(11248);class Xn{}Xn.DEFAULT_COLOR=z.Fy.White(),Xn.DEFAULT_WIDTH_ATTENUATED=1,Xn.DEFAULT_WIDTH=.1;var dn=H(11527),an=H(11923);class On{static ConvertPoints(n,y){if(n.length&&Array.isArray(n)&&"number"===typeof n[0])return[n];if(n.length&&Array.isArray(n[0])&&"number"===typeof n[0][0])return n;if(n.length&&!Array.isArray(n[0])&&n[0]instanceof o.zy){const y=[];for(let H=0;H<n.length;H++){const o=n[H];y.push(o.x,o.y,o.z)}return[y]}if(n.length>0&&Array.isArray(n[0])&&n[0].length>0&&n[0][0]instanceof o.zy){const y=[],H=n;for(const n of H)y.push(n.flatMap((n=>[n.x,n.y,n.z])));return y}if(n instanceof Float32Array){if(null!==y&&void 0!==y&&y.floatArrayStride){const H=[],o=3*y.floatArrayStride;for(let y=0;y<n.length;y+=o){const G=new Array(o);for(let H=0;H<o;H++)G[H]=n[y+H];H.push(G)}return H}return[Array.from(n)]}if(n.length&&n[0]instanceof Float32Array){const y=[];for(const H of n)y.push(Array.from(H));return y}return[]}static OmitZeroLengthPredicate(n,y,H){const o=[];return y.Qy(n).lengthSquared()>0&&o.push([n,y]),H.Qy(y).lengthSquared()>0&&o.push([y,H]),n.Qy(H).lengthSquared()>0&&o.push([H,n]),0===o.length?null:o}static OmitDuplicatesPredicate(n,y,H,o){const G=[];return On._SearchInPoints(n,y,o)||G.push([n,y]),On._SearchInPoints(y,H,o)||G.push([y,H]),On._SearchInPoints(H,n,o)||G.push([H,n]),0===G.length?null:G}static _SearchInPoints(n,y,H){for(const k of H)for(let H=0;H<k.length;H++){var o,G,h;if(null!==(o=k[H])&&void 0!==o&&o.equals(n))if(null!==(G=k[H+1])&&void 0!==G&&G.equals(y)||null!==(h=k[H-1])&&void 0!==h&&h.equals(y))return!0}return!1}static MeshesToLines(n,y){const H=[];for(let G=0;G<n.length;G++){const h=n[G],k=h.getVerticesData(q.g.PositionKind),i=h.Fi();if(k&&i)for(let n=0,B=0;n<i.length;n++){const V=3*i[B++],q=3*i[B++],b=3*i[B++],A=new o.zy(k[V],k[V+1],k[V+2]),U=new o.zy(k[q],k[q+1],k[q+2]),T=new o.zy(k[b],k[b+1],k[b+2]);if(y){const o=y(A,U,T,H,n,V,h,G,k,i);if(o)for(const n of o)H.push(n)}else H.push([A,U],[U,T],[T,A])}}return H}static ToVector3Array(n){if(Array.isArray(n[0])){const y=[],H=n;for(const n of H){const H=[];for(let y=0;y<n.length;y+=3)H.push(new o.zy(n[y],n[y+1],n[y+2]));y.push(H)}return y}const y=n,H=[];for(let G=0;G<y.length;G+=3)H.push(new o.zy(y[G],y[G+1],y[G+2]));return H}static ToNumberArray(n){return n.flatMap((n=>[n.x,n.y,n.z]))}static GetPointsCountInfo(n){const y=new Array(n.length);let H=0;for(let o=n.length;o--;)y[o]=n[o].length/3,H+=y[o];return{total:H,counts:y}}static GetLineLength(n){if(0===n.length)return 0;let y;y="number"===typeof n[0]?On.ToVector3Array(n):n;const H=o.TmpVectors.zy[0];let G=0;for(let o=0;o<y.length-1;o++){const n=y[o];G+=y[o+1].subtractToRef(n,H).length()}return G}static GetLineLengthArray(n){const y=new Float32Array(n.length/3);let H=0;for(let o=0,G=n.length/3-1;o<G;o++){let G=n[3*o+0],h=n[3*o+1],k=n[3*o+2];G-=n[3*o+3],h-=n[3*o+4],k-=n[3*o+5];H+=Math.sqrt(G*G+h*h+k*k),y[o+1]=H}return y}static SegmentizeSegmentByCount(n,y,H){const G=[],h=y.Qy(n),k=o.TmpVectors.zy[0];k.ci(H);const i=o.TmpVectors.zy[1];h.divideToRef(k,i);let B=n.clone();G.push(B);for(let o=0;o<H;o++)B=B.clone(),G.push(B.addInPlace(i));return G}static SegmentizeLineBySegmentLength(n,y){const H=n[0]instanceof o.zy?On.GetLineSegments(n):"number"===typeof n[0]?On.GetLineSegments(On.ToVector3Array(n)):n,G=[];for(const o of H)if(o.length>y){const n=On.SegmentizeSegmentByCount(o.point1,o.point2,Math.ceil(o.length/y));for(const y of n)G.push(y)}else G.push(o.point1),G.push(o.point2);return G}static SegmentizeLineBySegmentCount(n,y){const H="number"===typeof n[0]?On.ToVector3Array(n):n,o=On.GetLineLength(H)/y;return On.SegmentizeLineBySegmentLength(H,o)}static GetLineSegments(n){const y=[];for(let H=0;H<n.length-1;H++){const o=n[H],G=n[H+1],h=G.Qy(o).length();y.push({point1:o,point2:G,length:h})}return y}static GetMinMaxSegmentLength(n){const y=On.GetLineSegments(n).sort((n=>n.length));return{min:y[0].length,max:y[y.length-1].length}}static GetPositionOnLineByVisibility(n,y,H){let G=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const h=y*H;let k=0,i=0;const B=n.length;for(let o=0;o<B;o++){if(h<=k+n[o].length){i=o;break}k+=n[o].length}const V=(h-k)/n[i].length;return n[i].point2.subtractToRef(n[i].point1,o.TmpVectors.zy[0]),o.TmpVectors.zy[1]=o.TmpVectors.zy[0].multiplyByFloats(V,V,V),G||o.TmpVectors.zy[1].addInPlace(n[i].point1),o.TmpVectors.zy[1].clone()}static GetCircleLinePoints(n,y){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n,h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/y;const k=[];for(let i=0;i<=y;i++)k.push(new o.zy(Math.cos(i*h)*n,Math.sin(i*h)*G,H));return k}static GetBezierLinePoints(n,y,H,o){return dn.e.CreateQuadraticBezier(n,y,H,o).getPoints().flatMap((n=>[n.x,n.y,n.z]))}static GetArrowCap(n,y,H,o,G){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,k=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[n.clone(),n.add(y.multiplyByFloats(H,H,H))],widths:[o,G,h,k]}}static GetPointsFromText(n,y,H,o){let G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const k=[],i=(0,an.b)(n,y,H,o);for(const B of i){for(const n of B.paths){const y=[],H=n.getPoints();for(const n of H)y.push(n.x,n.y,G);k.push(y)}if(h)for(const n of B.holes){const y=[],H=n.getPoints();for(const n of H)y.push(n.x,n.y,G);k.push(y)}}return k}static Color3toRGBAUint8(n){const y=new Uint8Array(4*n.length);for(let H=0,o=0;H<n.length;H++)y[o++]=255*n[H].r,y[o++]=255*n[H].g,y[o++]=255*n[H].b,y[o++]=255;return y}static CreateColorsTexture(n,y,H,o){const G=o.getEngine().getCaps().maxTextureSize??1,h=y.length>G?G:y.length,k=Math.ceil(y.length/G);k>1&&(y=[...y,...Array(h*k-y.length).fill(y[0])]);const i=On.Color3toRGBAUint8(y),B=new M.b(i,h,k,T.d.TEXTUREFORMAT_RGBA,o,!1,!0,H);return B.name=n,B}static PrepareEmptyColorsTexture(n){if(!Xn.EmptyColorsTexture){const y=new Uint8Array(4);Xn.EmptyColorsTexture=new M.b(y,1,1,T.d.TEXTUREFORMAT_RGBA,n,!1,!1,M.b.NEAREST_NEAREST),Xn.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Xn.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var n;null===(n=Xn.EmptyColorsTexture)||void 0===n||n.dispose(),Xn.EmptyColorsTexture=null}static BooleanToNumber(n){return n?1:0}}class en extends pn.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class wn extends cn.c{isCompatible(n){return!0}constructor(n,y,H){var G;H=H||{color:Xn.DEFAULT_COLOR};const h=new en;h.GREASED_LINE_HAS_COLOR=!!H.color&&!H.useColors,h.GREASED_LINE_SIZE_ATTENUATION=H.sizeAttenuation??!1,h.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===H.colorDistributionType,h.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(y??n.pn()).useRightHandedSystem,h.GREASED_LINE_CAMERA_FACING=H.cameraFacing??!0,super(n,wn.GREASED_LINE_MATERIAL_NAME,200,h,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(G=H)||void 0===G?void 0:G.forceGLSL)||wn.ForceGLSL,this._scene=y??n.pn(),this._engine=this._scene.getEngine(),this._cameraFacing=H.cameraFacing??!0,this.visibility=H.visibility??1,this.useDash=H.useDash??!1,this.dashRatio=H.dashRatio??.5,this.dashOffset=H.dashOffset??0,this.width=H.width?H.width:H.sizeAttenuation?Xn.DEFAULT_WIDTH_ATTENUATED:Xn.DEFAULT_WIDTH,this._sizeAttenuation=H.sizeAttenuation??!1,this.colorMode=H.colorMode??0,this._color=H.color??null,this.useColors=H.useColors??!1,this._colorsDistributionType=H.colorDistributionType??0,this.colorsSampling=H.colorsSampling??M.b.NEAREST_NEAREST,this._colors=H.an??null,this.dashCount=H.dashCount??1,this.resolution=H.resolution??new o.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),H.colorsTexture?this.colorsTexture=H.colorsTexture:this._colors?this.colorsTexture=On.CreateColorsTexture(`${n.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Xn.DEFAULT_COLOR,On.PrepareEmptyColorsTexture(this._scene)),this._engine.ah.add((()=>{On.DisposeEmptyColorsTexture()}))}getAttributes(n){n.push("grl_offsets"),n.push("grl_widths"),n.push("grl_colorPointers"),n.push("grl_counters"),this._cameraFacing?(n.push("grl_previousAndSide"),n.push("grl_nextAndCounters")):n.push("grl_slopes")}getSamplers(n){n.push("grl_colors")}getActiveTextures(n){this.colorsTexture&&n.push(this.colorsTexture)}getUniforms(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const y=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&y.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===n&&y.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:y,vertex:this._cameraFacing&&this._isGLSL(n)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(n)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(n){if(this._cameraFacing){n.zi("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||n.zi("viewProjection",this._scene.getTransformMatrix());const y=o.TmpVectors.Vector4[0];y.x=this._aspect,y.y=this._resolution.x,y.z=this._resolution.y,y.w=this.width,n.updateVector4("grl_aspect_resolution_lineWidth",y)}const y=o.TmpVectors.Vector4[0];y.x=On.BooleanToNumber(this.useDash),y.y=this._dashArray,y.z=this.dashOffset,y.w=this.dashRatio,n.updateVector4("grl_dashOptions",y);const H=o.TmpVectors.Vector4[1];H.x=this.colorMode,H.y=this.visibility,H.z=this.colorsTexture?this.colorsTexture.getSize().width:0,H.w=On.BooleanToNumber(this.useColors),n.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",H),this._color&&n.updateColor3("grl_singleColor",this._color);const G=this.colorsTexture??Xn.EmptyColorsTexture;n.setTexture("grl_colors",G),n.updateFloat2("grl_textureSize",(null===G||void 0===G?void 0:G.getSize().width)??1,(null===G||void 0===G?void 0:G.getSize().height)??1)}prepareDefines(n,y,H){n.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,n.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,n.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,n.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=y.useRightHandedSystem,n.GREASED_LINE_CAMERA_FACING=this._cameraFacing,n.GREASED_LINE_USE_OFFSETS=!!H.offsets}getClassName(){return wn.GREASED_LINE_MATERIAL_NAME}getCustomCode(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(y)?function(n,y){if("vertex"===n){const n={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return y&&(n["!gl_Position\\=viewProjection\\*worldPos;"]="//"),n}return"fragment"===n?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(n,this._cameraFacing):function(n,y){if("vertex"===n){const n={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return y&&(n["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),n}return"fragment"===n?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(n,this._cameraFacing)}dispose(){var n;null===(n=this.colorsTexture)||void 0===n||n.dispose(),super.dispose()}get an(){return this._colors}set an(n){this.setColors(n)}setColors(n){var y;let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const G=(null===(y=this._colors)||void 0===y?void 0:y.length)??0;var h;if(this._colors=n,null!==n&&0!==n.length){if(!H||o)if(this.colorsTexture&&G===n.length&&!o){const y=On.Color3toRGBAUint8(n);this.colorsTexture.update(y)}else{var k;null===(k=this.colorsTexture)||void 0===k||k.dispose(),this.colorsTexture=On.CreateColorsTexture(`${this._material.name}-colors-texture`,n,this.colorsSampling,this._scene)}}else null===(h=this.colorsTexture)||void 0===h||h.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(n){this._dashCount=n,this._dashArray=1/n}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(n){this._sizeAttenuation=n,this.markAllDefinesAsDirty()}get color(){return this._color}set color(n){this.setColor(n)}setColor(n){let y=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==n||null!==this._color&&null===n?(this._color=n,y||this.markAllDefinesAsDirty()):this._color=n}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(n){this._colorsDistributionType=n,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(n){this._aspect=n.x/n.y,this._resolution=n}serialize(){const n=super.serialize(),y={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(y.an=this._colors),this._color&&(y.color=this._color),n.greasedLineMaterialOptions=y,n}parse(n,y,H){var o;super.parse(n,y,H);const G=n.greasedLineMaterialOptions;null===(o=this.colorsTexture)||void 0===o||o.dispose(),G.color&&this.setColor(G.color,!0),G.colorDistributionType&&(this.colorsDistributionType=G.colorDistributionType),G.an&&(this.an=G.an),G.colorsSampling&&(this.colorsSampling=G.colorsSampling),G.colorMode&&(this.colorMode=G.colorMode),G.useColors&&(this.useColors=G.useColors),G.visibility&&(this.visibility=G.visibility),G.useDash&&(this.useDash=G.useDash),G.dashCount&&(this.dashCount=G.dashCount),G.dashRatio&&(this.dashRatio=G.dashRatio),G.dashOffset&&(this.dashOffset=G.dashOffset),G.width&&(this.width=G.width),G.sizeAttenuation&&(this.sizeAttenuation=G.sizeAttenuation),G.resolution&&(this.resolution=G.resolution),this.an?this.colorsTexture=On.CreateColorsTexture(`${this._material.name}-colors-texture`,this.an,this.colorsSampling,y):On.PrepareEmptyColorsTexture(y),this.markAllDefinesAsDirty()}copyTo(n){var y;const H=n;null===(y=H.colorsTexture)||void 0===y||y.dispose(),this._colors&&(H.colorsTexture=On.CreateColorsTexture(`${H._material.name}-colors-texture`,this._colors,H.colorsSampling,this._scene)),H.setColor(this.color,!0),H.colorsDistributionType=this.colorsDistributionType,H.colorsSampling=this.colorsSampling,H.colorMode=this.colorMode,H.useColors=this.useColors,H.visibility=this.visibility,H.useDash=this.useDash,H.dashCount=this.dashCount,H.dashRatio=this.dashRatio,H.dashOffset=this.dashOffset,H.width=this.width,H.sizeAttenuation=this.sizeAttenuation,H.resolution=this.resolution,H.markAllDefinesAsDirty()}_isGLSL(n){return 0===n||this._forceGLSL}}wn.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",wn.ForceGLSL=!1,(0,En.h)(`BABYLON.${wn.GREASED_LINE_MATERIAL_NAME}`,wn);var jn=H(11786),In=H(11118),Rn=H(11549),Cn=H(11232);class Sn extends Rn.ShaderMaterial{constructor(n,y,G){const h=y.getEngine(),k=h.isWebGPU&&!(G.forceGLSL||Sn.ForceGLSL),i=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];y.useRightHandedSystem&&i.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const B=["position","grl_widths","grl_offsets","grl_colorPointers"];G.cameraFacing?(i.push("GREASED_LINE_CAMERA_FACING"),B.push("grl_previousAndSide","grl_nextAndCounters")):(B.push("grl_slopes"),B.push("grl_counters"));const V=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(k||V.push("world","viewProjection","view","projection"),super(n,y,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:k?["Scene","Mesh"]:void 0,attributes:B,uniforms:V,samplers:k?[]:["grlColors"],defines:i,extraInitializationsAsync:async()=>{k?await Promise.all([H.e(66).then(H.bind(H,14526)),H.e(75).then(H.bind(H,14528))]):await Promise.all([H.e(69).then(H.bind(H,14530)),H.e(76).then(H.bind(H,14538))])},shaderLanguage:k?1:0}),this._color=z.Fy.White(),this._colorsDistributionType=0,this._colorsTexture=null,G=G||{color:Xn.DEFAULT_COLOR},this.visibility=G.visibility??1,this.useDash=G.useDash??!1,this.dashRatio=G.dashRatio??.5,this.dashOffset=G.dashOffset??0,this.dashCount=G.dashCount??1,this.width=G.width?G.width:G.sizeAttenuation&&G.cameraFacing?Xn.DEFAULT_WIDTH_ATTENUATED:Xn.DEFAULT_WIDTH,this.sizeAttenuation=G.sizeAttenuation??!1,this.color=G.color??z.Fy.White(),this.useColors=G.useColors??!1,this.colorsDistributionType=G.colorDistributionType??0,this.colorsSampling=G.colorsSampling??M.b.NEAREST_NEAREST,this.colorMode=G.colorMode??0,this._colors=G.an??null,this._cameraFacing=G.cameraFacing??!0,this.resolution=G.resolution??new o.Vector2(h.getRenderWidth(),h.getRenderHeight()),G.colorsTexture?this.colorsTexture=G.colorsTexture:this._colors?this.colorsTexture=On.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,y):(this._color=this._color??Xn.DEFAULT_COLOR,this.colorsTexture=On.PrepareEmptyColorsTexture(y)),k){const n=new Cn.b;n.setParameters(),n.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",n)}h.ah.add((()=>{On.DisposeEmptyColorsTexture()}))}dispose(){var n;null===(n=this._colorsTexture)||void 0===n||n.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new o.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get an(){return this._colors}set an(n){this.setColors(n)}setColors(n){var y;let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const G=(null===(y=this._colors)||void 0===y?void 0:y.length)??0;var h;if(this._colors=n,null!==n&&0!==n.length){if(!H||o)if(this._colorsTexture&&G===n.length&&!o){const y=On.Color3toRGBAUint8(n);this._colorsTexture.update(y)}else{var k;null===(k=this._colorsTexture)||void 0===k||k.dispose(),this.colorsTexture=On.CreateColorsTexture(`${this.name}-colors-texture`,n,this.colorsSampling,this.pn())}}else null===(h=this._colorsTexture)||void 0===h||h.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(n){this._colorsTexture=n,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(n){this._width=n,this.setFloat("grlWidth",n)}get useColors(){return this._useColors}set useColors(n){this._useColors=n,this.setFloat("grlUseColors",On.BooleanToNumber(n))}get colorsSampling(){return this._colorsSampling}set colorsSampling(n){this._colorsSampling=n}get visibility(){return this._visibility}set visibility(n){this._visibility=n,this.setFloat("grlVisibility",n)}get useDash(){return this._useDash}set useDash(n){this._useDash=n,this.setFloat("grlUseDash",On.BooleanToNumber(n))}get dashOffset(){return this._dashOffset}set dashOffset(n){this._dashOffset=n,this.setFloat("grlDashOffset",n)}get dashRatio(){return this._dashRatio}set dashRatio(n){this._dashRatio=n,this.setFloat("grlDashRatio",n)}get dashCount(){return this._dashCount}set dashCount(n){this._dashCount=n,this._dashArray=1/n,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(n){this._sizeAttenuation=n,this.setFloat("grlSizeAttenuation",On.BooleanToNumber(n))}get color(){return this._color}set color(n){this.setColor(n)}setColor(n){n=n??Xn.DEFAULT_COLOR,this._color=n,this.setColor3("grlColor",n)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(n){this._colorsDistributionType=n,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(n){this._colorMode=n,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(n){this._resolution=n,this.setVector2("grlResolution",n),this.setFloat("grlAspect",n.x/n.y)}serialize(){const n=super.serialize(),y={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(y.an=this._colors),n.greasedLineMaterialOptions=y,n}parse(n,y,H){var o;const G=n.greasedLineMaterialOptions;null===(o=this._colorsTexture)||void 0===o||o.dispose(),G.color&&(this.color=G.color),G.colorDistributionType&&(this.colorsDistributionType=G.colorDistributionType),G.colorsSampling&&(this.colorsSampling=G.colorsSampling),G.colorMode&&(this.colorMode=G.colorMode),G.useColors&&(this.useColors=G.useColors),G.visibility&&(this.visibility=G.visibility),G.useDash&&(this.useDash=G.useDash),G.dashCount&&(this.dashCount=G.dashCount),G.dashRatio&&(this.dashRatio=G.dashRatio),G.dashOffset&&(this.dashOffset=G.dashOffset),G.width&&(this.width=G.width),G.sizeAttenuation&&(this.sizeAttenuation=G.sizeAttenuation),G.resolution&&(this.resolution=G.resolution),G.an?this.colorsTexture=On.CreateColorsTexture(`${this.name}-colors-texture`,G.an,this.colorsSampling,this.pn()):this.colorsTexture=On.PrepareEmptyColorsTexture(y),this._cameraFacing=G.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Nn,rn,Kn;Sn.ForceGLSL=!1,function(n){n[n.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",n[n.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Nn||(Nn={})),function(n){n[n.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",n[n.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",n[n.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(rn||(rn={})),function(n){n[n.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",n[n.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",n[n.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",n[n.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",n[n.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Kn||(Kn={}));class Yn extends vn.b{constructor(n,y,H){super(n,y,null,null,!1,!1),this.name=n,this._options=H,this._lazy=!1,this._updatable=!1,this._engine=y.getEngine(),this._lazy=H.lazy??!1,this._updatable=H.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=H.colorPointers??[],this._widths=H.widths??new Array(H.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(n){let y=0;for(const o of this._points)y+=o.length;const H=y/3*2-this._widths.length;for(let o=0;o<H;o++)this._widths.push(n)}updateLazy(){var n,y;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(n=this._options.ribbonOptions)||void 0===n?void 0:n.smoothShading),!this.jn&&this.refreshBoundingInfo(),null===(y=this.greasedLineMaterial)||void 0===y||y.updateLazy()}addPoints(n,y){for(const H of n)this._points.push(H);this._lazy||this.setPoints(this._points,y)}dispose(n){let y=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(n,y)}isLazy(){return this._lazy}get On(){return this._uvs}set On(n){this._uvs=n instanceof Float32Array?n:new Float32Array(n),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(n){this.material instanceof Sn&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===n||void 0===n?void 0:n.length)>0),this._offsets=n,this._offsetsBuffer?this._offsetsBuffer.update(n):this._createOffsetsBuffer(n)}get widths(){return this._widths}set widths(n){this._widths=n,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(n)}get colorPointers(){return this._colorPointers}set colorPointers(n){this._colorPointers=n,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(n)}get greasedLineMaterial(){var n,y;if(this.material&&this.material instanceof Sn)return this.material;const H=null===(n=this.material)||void 0===n||null===(y=n.pluginManager)||void 0===y?void 0:y.getPlugin(wn.GREASED_LINE_MATERIAL_NAME);return H||void 0}get points(){const n=[];return In.c.DeepCopy(this._points,n),n}setPoints(n,y){this._points=On.ConvertPoints(n,(null===y||void 0===y?void 0:y.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==y&&void 0!==y&&y.colorPointers||this._updateColorPointers(),this._setPoints(this._points,y)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,On:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(n){super.serialize(n),n.type=this.getClassName(),n.lineOptions=this._createLineOptions()}_createVertexBuffers(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const y=new jn.c;return y.Xn=this._vertexPositions,y.indices=this._indices,y.On=this._uvs,n&&(y.dn=[],jn.c.ComputeNormals(this._vertexPositions,this._indices,y.dn)),y.wn(this,this._options.updatable),y}_createOffsetsBuffer(n){const y=this._scene.getEngine(),H=new q.d(y,n,this._updatable,3);this.setVerticesBuffer(H.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=H}}class Dn{constructor(n,y){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=n,this.wasAddedByNoopNode=y}getIndicesAccessor(n,y,H,o,G){var h,k,i,B;return null===(h=this._indicesAccessorMap.get(n))||void 0===h||null===(k=h.get(y))||void 0===k||null===(i=k.get(H))||void 0===i||null===(B=i.get(o))||void 0===B?void 0:B.get(G)}setIndicesAccessor(n,y,H,o,G,h){let k=this._indicesAccessorMap.get(n);k||(k=new Map,this._indicesAccessorMap.set(n,k));let i=k.get(y);i||(i=new Map,k.set(y,i));let B=i.get(H);B||(B=new Map,i.set(H,B));let V=B.get(o);V||(V=new Map,B.set(o,V)),V.set(G,h)}pushExportedNode(n){this._exportedNodes.has(n)||this._exportedNodes.add(n)}getNodesSet(){return this._exportedNodes}getVertexBufferView(n){return this._vertexBufferViewMap.get(n)}setVertexBufferView(n,y){this._vertexBufferViewMap.set(n,y)}setRemappedBufferView(n,y,H){this._remappedBufferView.set(n,new Map),this._remappedBufferView.get(n).set(y,H)}getRemappedBufferView(n,y){var H;return null===(H=this._remappedBufferView.get(n))||void 0===H?void 0:H.get(y)}getVertexAccessor(n,y,H){var o,G;return null===(o=this._vertexAccessorMap.get(n))||void 0===o||null===(G=o.get(y))||void 0===G?void 0:G.get(H)}setVertexAccessor(n,y,H,o){let G=this._vertexAccessorMap.get(n);G||(G=new Map,this._vertexAccessorMap.set(n,G));let h=G.get(y);h||(h=new Map,G.set(y,h)),h.set(H,o)}hasVertexColorAlpha(n){return this._vertexMapColorAlpha.get(n)||!1}setHasVertexColorAlpha(n,y){return this._vertexMapColorAlpha.set(n,y)}getMesh(n){return this._meshMap.get(n)}setMesh(n,y){this._meshMap.set(n,y)}bindMorphDataToMesh(n,y){const H=this._meshMorphTargetMap.get(n)||[];this._meshMorphTargetMap.set(n,H),-1===H.indexOf(y)&&H.push(y)}getMorphTargetsFromMesh(n){return this._meshMorphTargetMap.get(n)}}class Zn{_ApplyExtension(n,y,H,o){if(H>=y.length)return Promise.resolve(n);const G=o(y[H],n);return G?G.then((async n=>n?await this._ApplyExtension(n,y,H+1,o):null)):this._ApplyExtension(n,y,H+1,o)}_ApplyExtensions(n,y){const H=[];for(const o of Zn._ExtensionNames)H.push(this._extensions[o]);return this._ApplyExtension(n,H,0,y)}_extensionsPreExportTextureAsync(n,y,H){return this._ApplyExtensions(y,((y,o)=>y.preExportTextureAsync&&y.preExportTextureAsync(n,o,H)))}_extensionsPostExportNodeAsync(n,y,H,o,G){return this._ApplyExtensions(y,((y,h)=>y.postExportNodeAsync&&y.postExportNodeAsync(n,h,H,o,G,this._bufferManager)))}_extensionsPostExportMaterialAsync(n,y,H){return this._ApplyExtensions(y,((y,o)=>y.postExportMaterialAsync&&y.postExportMaterialAsync(n,o,H)))}_extensionsPostExportMaterialAdditionalTextures(n,y,H){const o=[];for(const G of Zn._ExtensionNames){const h=this._extensions[G];h.postExportMaterialAdditionalTextures&&o.push(...h.postExportMaterialAdditionalTextures(n,y,H))}return o}_extensionsPostExportTextures(n,y,H){for(const o of Zn._ExtensionNames){const G=this._extensions[o];G.postExportTexture&&G.postExportTexture(n,y,H)}}_extensionsPostExportMeshPrimitive(n){for(const y of Zn._ExtensionNames){const H=this._extensions[y];H.postExportMeshPrimitive&&H.postExportMeshPrimitive(n,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const n of Zn._ExtensionNames){const y=this._extensions[n];y.preGenerateBinaryAsync&&await y.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(n){for(const y of Zn._ExtensionNames){const H=this._extensions[y];H.enabled&&n(H)}}_extensionsOnExporting(){this._forEachExtensions((n=>{var y,H,o;n.wasUsed&&((y=this._glTF).extensionsUsed||(y.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(n.name)&&this._glTF.extensionsUsed.push(n.name),n.required&&((H=this._glTF).extensionsRequired||(H.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(n.name)&&this._glTF.extensionsRequired.push(n.name)),(o=this._glTF).extensions||(o.extensions={}),n.onExporting&&n.onExporting())}))}_loadExtensions(){for(const n of Zn._ExtensionNames){const y=Zn._ExtensionFactories[n](this);this._extensions[n]=y}}constructor(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:W.c.LastCreatedScene,y=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${T.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new R(this),this._extensions={},this._bufferManager=new bn,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!n)throw new Error("No scene available to export");this._babylonScene=n,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:n=>{var y;return null===n||void 0===n||null===(y=n.rh)||void 0===y?void 0:y.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...y},this._loadExtensions()}dispose(){for(const n in this._extensions){this._extensions[n].dispose()}}get options(){return this._options}static RegisterExtension(n,y){Zn.UnregisterExtension(n)&&G.Tools.Warn(`Extension with the name ${n} already exists`),Zn._ExtensionFactories[n]=y,Zn._ExtensionNames.push(n)}static UnregisterExtension(n){if(!Zn._ExtensionFactories[n])return!1;delete Zn._ExtensionFactories[n];const y=Zn._ExtensionNames.indexOf(n);return-1!==y&&Zn._ExtensionNames.splice(y,1),!0}_generateJSON(n,y,H){const o={byteLength:n};return o.byteLength&&(this._glTF.buffers=[o]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.ly=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(o.uri=y+".bin"),H?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(n){const y=await this._generateBinaryAsync();this._extensionsOnExporting();const H=this._generateJSON(y.byteLength,n,!0),o=new Blob([y],{type:"application/octet-stream"}),G=n+".gltf",h=n+".bin",k=new V;if(k.files[G]=H,k.files[h]=o,this._imageData)for(const i in this._imageData)k.files[i]=new Blob([this._imageData[i].data],{type:this._imageData[i].mimeType});return k}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(n){const y=n%4;return 0===y?y:4-y}async generateGLBAsync(n){this._shouldUseGlb=!0;const y=await this._generateBinaryAsync();this._extensionsOnExporting();const H=this._generateJSON(y.byteLength),o=n+".glb";let G,h=H.length;if("undefined"!==typeof TextEncoder){G=(new TextEncoder).encode(H),h=G.length}const k=this._getPadding(h),i=this._getPadding(y.byteLength),B=28+h+k+y.byteLength+i,q=new Vn(B);if(q.writeUInt32(1179937895),q.writeUInt32(2),q.writeUInt32(B),q.writeUInt32(h+k),q.writeUInt32(1313821514),G)q.writeTypedArray(G);else{const n="_".charCodeAt(0);for(let y=0;y<h;++y){const o=H.charCodeAt(y);o!=H.codePointAt(y)?q.writeUInt8(n):q.writeUInt8(o)}}for(let V=0;V<k;++V)q.writeUInt8(32);q.writeUInt32(y.byteLength+i),q.writeUInt32(5130562),q.writeTypedArray(y);for(let V=0;V<i;++V)q.writeUInt8(0);const b=new V;return b.files[o]=new Blob([q.getOutputData()],{type:"application/octet-stream"}),b}_setNodeTransformation(n,y,H){if(y.getPivotPoint().equalsWithEpsilon(K,r.e)||G.Tools.Warn("Pivot points are not supported in the glTF serializer"),!y.position.equalsWithEpsilon(K,r.e)){const G=o.TmpVectors.zy[0].B(y.position);H&&L(G),n.translation=G.Ui()}y.fi.equalsWithEpsilon(D,r.e)||(n.scale=y.fi.Ui());const h=y.rotationQuaternion||o.Quaternion.FromEulerAngles(y.rotation.x,y.rotation.y,y.rotation.z);h.equalsWithEpsilon(Y,r.e)||(H&&J(h),n.rotation=h.normalize().Ui())}_setCameraTransformation(n,y,H){if(!y.position.equalsWithEpsilon(K,r.e)){const G=o.TmpVectors.zy[0].B(y.position);H&&L(G),n.translation=G.Ui()}const G=y.rotationQuaternion||o.Quaternion.FromEulerAngles(y.rotation.x,y.rotation.y,y.rotation.z);H&&J(G),this._babylonScene.useRightHandedSystem||m(G),G.equalsWithEpsilon(Y,r.e)||(n.rotation=G.Ui())}_listAvailableCameras(){for(const n of this._babylonScene.cameras){const y={type:n.mode===Un.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(n.name&&(y.name=n.name),"perspective"===y.type)y.perspective={aspectRatio:n.getEngine().getAspectRatio(n),yfov:n.fovMode===Un.d.FOVMODE_VERTICAL_FIXED?n.fov:n.fov*n.getEngine().getAspectRatio(n),znear:n.Wi,zfar:n.maxZ};else if("orthographic"===y.type){const H=n.orthoLeft&&n.orthoRight?.5*(n.orthoRight-n.orthoLeft):.5*n.getEngine().getRenderWidth(),o=n.orthoBottom&&n.orthoTop?.5*(n.orthoTop-n.orthoBottom):.5*n.getEngine().getRenderHeight();y.orthographic={xmag:H,ymag:o,znear:n.Wi,zfar:n.maxZ}}this._camerasMap.set(n,y)}}_exportAndAssignCameras(){const n=Array.from(this._camerasMap.values());for(const y of n){const n=this._nodesCameraMap.get(y);if(void 0!==n){this._cameras.push(y);for(const y of n)y.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const n of this._babylonScene.skeletons){if(n.bones.length<=0)continue;const y={joints:[]};this._skinMap.set(n,y)}}_exportAndAssignSkeletons(){for(const n of this._babylonScene.skeletons){if(n.bones.length<=0)continue;const y=this._skinMap.get(n);if(void 0==y)continue;const H={},o=[];let h=-1;for(let G=0;G<n.bones.length;++G){const y=n.bones[G],o=y.getIndex()??G;-1!==o&&(H[o]=y,o>h&&(h=o))}for(let n=0;n<=h;++n){const h=H[n];o.push(h.getAbsoluteInverseBindMatrix());const k=h.getTransformNode();if(null!==k){const n=this._nodeMap.get(k);k&&null!==n&&void 0!==n?y.joints.push(n):G.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else G.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const k=this._nodesSkinMap.get(y);if(y.joints.length>0&&void 0!==k){const n=64*o.length,H=new Float32Array(n/4);o.forEach(((n,y)=>{H.set(n.m,16*y)}));const G=this._bufferManager.createBufferView(H);this._accessors.push(this._bufferManager.createAccessor(G,"MAT4",5126,o.length)),y.inverseBindMatrices=this._accessors.length-1,this._skins.push(y);for(const y of k)y.skin=this._skins.length-1}}}async _exportSceneAsync(){const n={nodes:[]};if(this._babylonScene.metadata){const y=this._options.metadataSelector(this._babylonScene.metadata);y&&(n.extras=y)}const y=new Array,H=new Array,o=new Array;for(const i of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&kn(i,this._babylonScene.useRightHandedSystem)?o.push(...i.getChildren()):this._babylonScene.useRightHandedSystem?y.push(i):H.push(i);this._listAvailableCameras(),this._listAvailableSkeletons();const G=new Dn(!0,!1);n.nodes.push(...await this._exportNodesAsync(H,G));const h=new Dn(!1,!1);n.nodes.push(...await this._exportNodesAsync(y,h));const k=new Dn(!1,!0);n.nodes.push(...await this._exportNodesAsync(o,k)),n.nodes.length&&this._scenes.push(n),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&gn._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,G.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(n){let y=this._shouldExportNodeMap.get(n);return void 0===y&&(y=this._options.shouldExportNode(n),this._shouldExportNodeMap.set(n,y)),y}async _exportNodesAsync(n,y){const H=new Array;this._exportBuffers(n,y);for(const o of n)await this._exportNodeAsync(o,H,y);return H}_collectBuffers(n,y,H,o,G){if(this._shouldExportNode(n)&&n instanceof A.d&&n.li){const h=n.li.getVertexBuffers();if(h)for(const o in h){if(!x(o))continue;const k=h[o];G.setHasVertexColorAlpha(k,n.hasVertexAlpha);const i=k._buffer,B=y.get(i)||[];y.set(i,B),-1===B.indexOf(k)&&B.push(k);const V=H.get(k)||[];H.set(k,V),-1===V.indexOf(n)&&V.push(n)}const k=n.morphTargetManager;if(k)for(let y=0;y<k.numTargets;y++){const H=k.getTarget(y),G=o.get(H)||[];o.set(H,G),-1===G.indexOf(n)&&G.push(n)}}for(const h of n.getChildren())this._collectBuffers(h,y,H,o,G)}_exportBuffers(n,y){const H=new Map,o=new Map,G=new Map;for(const i of n)this._collectBuffers(i,H,o,G,y);const h=Array.from(H.keys());for(const i of h){const n=i.getData();if(!n)throw new Error("Buffer data is not available");const G=H.get(i);if(!G)continue;const h=G[0].byteStride;if(G.some((n=>n.byteStride!==h)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const k=Hn(n).slice();for(const y of G){const n=o.get(y),{byteOffset:H,byteStride:G,componentCount:h,type:i,count:B,normalized:V,kind:b}=s(y,n);switch(b){case q.g.NormalKind:case q.g.TangentKind:(0,C.g)(k,H,G,h,i,B,V,(n=>{const y=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);if(y>0){const H=1/y;n[0]*=H,n[1]*=H,n[2]*=H}}));break;case q.g.ColorKind:{const y=n.filter((n=>n.material instanceof zn.vy||null==n.material)).length;if(0==y)break;if(y!=n.length){S.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}i==q.g.UNSIGNED_BYTE&&S.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const o=new z.Fy,b=new z.pi,A=this._babylonScene.getEngine().useExactSrgbConversions;(0,C.g)(k,H,G,h,i,B,V,(n=>{3===n.length?(o.vH(n,0),o.toLinearSpaceToRef(o,A),o.toArray(n,0)):(b.vH(n,0),b.toLinearSpaceToRef(b,A),b.toArray(n,0))}))}}}if(y.convertToRightHanded){for(const n of G){const y=o.get(n),{byteOffset:H,byteStride:G,componentCount:h,type:i,count:B,normalized:V,kind:b}=s(n,y);switch(b){case q.g.PositionKind:case q.g.NormalKind:case q.g.TangentKind:(0,C.g)(k,H,G,h,i,B,V,(n=>{n[0]=-n[0]}))}}y.convertedToRightHandedBuffers.set(i,k)}const B=this._bufferManager.createBufferView(k,h);y.setVertexBufferView(i,B);const V=new Map;for(const y of G){const n=o.get(y),{kind:H,totalVertices:G}=s(y,n);switch(H){case q.g.MatricesIndicesKind:case q.g.MatricesIndicesExtraKind:if(y.type==q.g.FLOAT){const n=y.getFloatData(G);null!==n&&V.set(y,n)}}}0!==V.size&&S.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const b=Array.from(V.keys());for(const H of b){const n=V.get(H);if(!n)continue;const o=n.some((n=>n>=256)),G=new(o?Uint16Array:Uint8Array)(n.length);for(let y=0;y<n.length;y++)G[y]=n[y];const h=this._bufferManager.createBufferView(G,4*(o?2:1));y.setRemappedBufferView(i,H,h)}}const k=Array.from(G.keys());for(const i of k){const n=G.get(i);if(!n)continue;const H=Mn(i,n[0],this._bufferManager,this._bufferViews,this._accessors,y.convertToRightHanded);for(const o of n)y.bindMorphDataToMesh(o,H)}}async _exportNodeAsync(n,y,H){let o=this._nodeMap.get(n);if(void 0!==o)return void(y.includes(o)||y.push(o));const G=await this._createNodeAsync(n,H);if(G){o=this._nodes.length,this._nodes.push(G),this._nodeMap.set(n,o),H.pushExportedNode(n),y.push(o);const h={name:"runtime animations",channels:[],samplers:[]},k=[];this._babylonScene.animationGroups.length||(gn._CreateMorphTargetAnimationFromMorphTargetAnimations(n,h,k,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,H.convertToRightHanded,this._options.shouldExportAnimation),n.animations.length&&gn._CreateNodeAnimationFromNodeAnimations(n,h,k,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,H.convertToRightHanded,this._options.shouldExportAnimation)),h.channels.length&&h.samplers.length&&this._animations.push(h),k.forEach((n=>{n.channels.length&&n.samplers.length&&this._animations.push(n)}))}const h=G?[]:y;for(const k of n.getChildren())await this._exportNodeAsync(k,h,H);G&&h.length&&(G.children=h)}async _createNodeAsync(n,y){if(!this._shouldExportNode(n))return null;const H={};if(n.name&&(H.name=n.name),n.metadata){const y=this._options.metadataSelector(n.metadata);y&&(H.extras=y)}if(n instanceof b.c&&(this._setNodeTransformation(H,n,y.convertToRightHanded),n instanceof A.d)){const G=n instanceof U.d?n.sourceMesh:n;if(G.Lh&&G.Lh.length>0&&(H.mesh=await this._exportMeshAsync(G,y)),n.skeleton){const y=this._skinMap.get(n.skeleton);var o;if(void 0!==y)void 0===this._nodesSkinMap.get(y)&&this._nodesSkinMap.set(y,[]),null===(o=this._nodesSkinMap.get(y))||void 0===o||o.push(H)}}if(n instanceof N.d){const o=this._camerasMap.get(n);if(o){var G;void 0===this._nodesCameraMap.get(o)&&this._nodesCameraMap.set(o,[]),this._setCameraTransformation(H,n,y.convertToRightHanded);const k=n.parent;if(null!==k&&yn(n,k)){const n=this._nodeMap.get(k);if(void 0!==n){var h;const y=this._nodes[n];return nn(H,y),null===(h=this._nodesCameraMap.get(o))||void 0===h||h.push(y),null}}null===(G=this._nodesCameraMap.get(o))||void 0===G||G.push(H)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",H,n,this._nodeMap,y.convertToRightHanded)?H:(S.d.Warn(`Not exporting node ${n.name}`),null)}_exportIndices(n,y,H,o,G,k,i,B,V){let q=n;V.mode=t(k);const b=i!==h.e.CounterClockWiseSideOrientation,A=!B.wasAddedByNoopNode&&b,U=function(n){switch(n){case h.e.TriangleFillMode:case h.e.TriangleStripDrawMode:case h.e.TriangleFanDrawMode:return!0}return!1}(k)&&A;if(U){if(k===h.e.TriangleStripDrawMode||k===h.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");V.mode=t(k);const i=y?new Uint32Array(o):new Uint16Array(o);if(n)for(let y=0;y+2<o;y+=3)i[y]=n[H+y]+G,i[y+1]=n[H+y+2]+G,i[y+2]=n[H+y+1]+G;else for(let n=0;n+2<o;n+=3)i[n]=n,i[n+1]=n+2,i[n+2]=n+1;q=i}else if(n&&0!==G){const h=y?new Uint32Array(o):new Uint16Array(o);for(let y=0;y<o;y++)h[y]=n[H+y]+G;q=h}if(q){let h=B.getIndicesAccessor(n,H,o,G,U);if(void 0===h){const k=function(n,y,H,o){if(n instanceof Uint16Array||n instanceof Uint32Array)return n;if(n instanceof Int32Array)return new Uint32Array(n.buffer,n.byteOffset,n.length);const G=n.slice(y,y+H);return o?new Uint32Array(G):new Uint16Array(G)}(q,0,o,y),i=this._bufferManager.createBufferView(k),V=y?5125:5123;this._accessors.push(this._bufferManager.createAccessor(i,"SCALAR",V,o,0)),h=this._accessors.length-1,B.setIndicesAccessor(n,H,o,G,U,h)}V.indices=h}}_exportVertexBuffer(n,y,H,o,G,h){const k=n.getKind();if(!x(k))return;if(k.startsWith("uv")&&!this._options.exportUnusedUVs&&(!y||!this._materialNeedsUVsSet.has(y)))return;let i=G.getVertexAccessor(n,H,o);if(void 0===i){const y=G.convertedToRightHandedBuffers.get(n._buffer)||n._buffer.getData(),h=k===q.g.PositionKind?function(n,y,H,o){const{byteOffset:G,byteStride:h,type:k,normalized:i}=y,B=y.getSize(),V=new Array(B).fill(1/0),q=new Array(B).fill(-1/0);return(0,C.g)(n,G+H*h,h,B,k,o*B,i,(n=>{for(let y=0;y<B;y++)V[y]=Math.min(V[y],n[y]),q[y]=Math.max(q[y],n[y])})),{min:V,max:q}}(y,n,H,o):void 0,B=(k===q.g.MatricesIndicesKind||k===q.g.MatricesIndicesExtraKind)&&n.type===q.g.FLOAT,V=B?q.g.UNSIGNED_BYTE:n.type,b=B?void 0:n.normalized,A=B?G.getRemappedBufferView(n._buffer,n):G.getVertexBufferView(n._buffer),U=n.byteOffset+H*n.byteStride;this._accessors.push(this._bufferManager.createAccessor(A,function(n,y){if(n==q.g.ColorKind)return y?"VEC4":"VEC3";switch(n){case q.g.PositionKind:case q.g.NormalKind:return"VEC3";case q.g.TangentKind:case q.g.MatricesIndicesKind:case q.g.MatricesIndicesExtraKind:case q.g.MatricesWeightsKind:case q.g.MatricesWeightsExtraKind:return"VEC4";case q.g.UVKind:case q.g.UV2Kind:case q.g.UV3Kind:case q.g.UV4Kind:case q.g.UV5Kind:case q.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${n}`)}(k,G.hasVertexColorAlpha(n)),V,o,U,h,b)),i=this._accessors.length-1,G.setVertexAccessor(n,H,o,i)}h.attributes[function(n){switch(n){case q.g.PositionKind:return"POSITION";case q.g.NormalKind:return"NORMAL";case q.g.TangentKind:return"TANGENT";case q.g.ColorKind:return"COLOR_0";case q.g.UVKind:return"TEXCOORD_0";case q.g.UV2Kind:return"TEXCOORD_1";case q.g.UV3Kind:return"TEXCOORD_2";case q.g.UV4Kind:return"TEXCOORD_3";case q.g.UV5Kind:return"TEXCOORD_4";case q.g.UV6Kind:return"TEXCOORD_5";case q.g.MatricesIndicesKind:return"JOINTS_0";case q.g.MatricesIndicesExtraKind:return"JOINTS_1";case q.g.MatricesWeightsKind:return"WEIGHTS_0";case q.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${n}`)}(k)]=i}async _exportMaterialAsync(n,y,H,o){let G=this._materialMap.get(n);if(void 0===G){const o=y&&Object.keys(y).some((n=>n.startsWith("uv")));if((n=n instanceof Tn.e?n.Ei[H.materialIndex]:n)instanceof Wn.e)G=await this._materialExporter.exportPBRMaterialAsync(n,"image/png",o);else{if(!(n instanceof zn.vy))return void S.d.Warn(`Unsupported material '${n.name}' with type ${n.getClassName()}`);G=await this._materialExporter.exportStandardMaterialAsync(n,"image/png",o)}this._materialMap.set(n,G)}o.material=G}async _exportMeshAsync(n,y){var H;let o=y.getMesh(n);if(void 0!==o)return o;const G={primitives:[]};o=this._meshes.length,this._meshes.push(G),y.setMesh(n,o);const k=n.isUnIndexed?null:n.Fi(),i=null===(H=n.li)||void 0===H?void 0:H.getVertexBuffers(),B=y.getMorphTargetsFromMesh(n),V=n instanceof fn.e,q=n instanceof Yn,b=n.Lh;if(i&&b&&b.length>0)for(const T of b){const H={attributes:{}},o=T.Sn()||this._babylonScene.defaultMaterial;if(q){var A,U;const y={name:o.name},G=n,h=z.Fy.White(),k=(null===(A=G.material)||void 0===A?void 0:A.alpha)??1,i=(null===(U=G.greasedLineMaterial)||void 0===U?void 0:U.color)??h;(!i.equalsWithEpsilon(h,r.e)||k<1)&&(y.pbrMetallicRoughness={baseColorFactor:[...i.Ui(),k]}),this._materials.push(y),H.material=this._materials.length-1}else if(V){const y={name:o.name},G=n;(!G.color.equalsWithEpsilon(z.Fy.White(),r.e)||G.alpha<1)&&(y.pbrMetallicRoughness={baseColorFactor:[...G.color.Ui(),G.alpha]}),this._materials.push(y),H.material=this._materials.length-1}else await this._exportMaterialAsync(o,i,T,H);const b=V||q?h.e.LineListDrawMode:n.overrideRenderingFillMode??o.fillMode,W=o._getEffectiveOrientation(n);this._exportIndices(k,k?(0,C.c)(k,T.indexCount,T.indexStart,T.verticesStart):T.verticesCount>65535,k?T.indexStart:T.verticesStart,k?T.indexCount:T.verticesCount,-T.verticesStart,b,W,y,H);for(const n of Object.values(i))this._exportVertexBuffer(n,o,T.verticesStart,T.verticesCount,y,H);if(B){H.targets=[];for(const n of B)H.targets.push(n.attributes)}G.primitives.push(H),this._extensionsPostExportMeshPrimitive(H)}if(B){G.weights=[],G.extras||(G.extras={}),G.extras.targetNames=[];for(const n of B)G.weights.push(n.influence),G.extras.targetNames.push(n.name)}return o}}Zn._ExtensionNames=new Array,Zn._ExtensionFactories={};class sn{static async GLTFAsync(n,y,H){H&&H.exportWithoutWaitingForScene||await n.whenReadyAsync();const o=new Zn(n,H),G=await o.generateGLTFAsync(y.replace(/\.[^/.]+$/,""));return o.dispose(),G}static async GLBAsync(n,y,H){H&&H.exportWithoutWaitingForScene||await n.whenReadyAsync();const o=new Zn(n,H),G=await o.generateGLBAsync(y.replace(/\.[^/.]+$/,""));return o.dispose(),G}}H(11938);const Pn="EXT_mesh_gpu_instancing";class xn{constructor(n){this.name=Pn,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=n}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(n,y,H,G,h,k){return await new Promise((n=>{if(y&&H instanceof vn.b&&H.hasThinInstances&&this._exporter){this._wasUsed=!0;const n=o.zy.Zero(),G=o.Quaternion.Identity(),i=o.zy.One(),B=H.thinInstanceGetWorldMatrices(),V=o.TmpVectors.zy[2],q=o.TmpVectors.Quaternion[1],b=o.TmpVectors.zy[3];let A=!1,U=!1,T=!1;const W=new Float32Array(3*H.Xi),z=new Float32Array(4*H.Xi),Q=new Float32Array(3*H.Xi);let l=0;for(const y of B)y.decompose(b,q,V),h&&(L(V),J(q)),W.set(V.Ui(),3*l),z.set(q.normalize().Ui(),4*l),Q.set(b.Ui(),3*l),A=A||!V.equalsWithEpsilon(n),U=U||!q.equalsWithEpsilon(G),T=T||!b.equalsWithEpsilon(i),l++;const v={attributes:{}};A&&(v.attributes.TRANSLATION=this._buildAccessor(W,"VEC3",H.Xi,k)),U&&(v.attributes.ROTATION=this._buildAccessor(z,"VEC4",H.Xi,k)),T&&(v.attributes.SCALE=this._buildAccessor(Q,"VEC3",H.Xi,k)),y.extensions=y.extensions||{},y.extensions[Pn]=v}n(y)}))}_buildAccessor(n,y,H,o){const G=o.createBufferView(n),h=o.createAccessor(G,y,5126,H);return this._exporter._accessors.push(h),this._exporter._accessors.length-1}}Zn.RegisterExtension(Pn,(n=>new xn(n)));var tn=H(11941),un=H(11953),Ln=H(11959),Jn=H(11967);function mn(n){return n===Ln.b.PositionKind?"POSITION":n===Ln.b.NormalKind?"NORMAL":n===Ln.b.ColorKind?"COLOR":n.startsWith(Ln.b.UVKind)?"TEX_COORD":"GENERIC"}const ny={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class yy extends tn.e{static get DefaultAvailable(){return(0,tn.i)(yy.DefaultConfiguration)}static get Default(){return yy._Default??(yy._Default=new yy),yy._Default}static ResetDefault(n){yy._Default&&(n||yy._Default.dispose(),yy._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(n,y){return{module:await(y||DracoEncoderModule)({wasmBinary:n})}}_getWorkerContent(){return`${un.j}(${un.n})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:yy.DefaultConfiguration)}async _encodeAsync(n,y,H){const o=H?(0,Jn.c)(ny,H):ny;if(this._workerPoolPromise){const H=await this._workerPoolPromise;return await new Promise(((G,h)=>{H.push(((H,k)=>{const i=n=>{H.removeEventListener("error",i),H.removeEventListener("message",B),h(n),k()},B=n=>{"encodeMeshDone"===n.data.id&&(H.removeEventListener("error",i),H.removeEventListener("message",B),G(n.data.encodedMeshData),k())};H.addEventListener("error",i),H.addEventListener("message",B);const V=[];for(const y of n)V.push(y.data.buffer);y&&V.push(y.buffer),H.postMessage({id:"encodeMesh",attributes:n,indices:y,options:o},V)}))}))}if(this._modulePromise){const H=await this._modulePromise;return(0,un.j)(H.module,n,y,o)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(n,y){if(0==n.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");n instanceof vn.b&&n.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===y||void 0===y?void 0:y.method)&&(S.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),y.method="MESH_SEQUENTIAL_ENCODING");const H=function(n){let y=n.Fi(void 0,!0);return!y||y instanceof Uint32Array||y instanceof Uint16Array||(y=((0,C.c)(y,y.length)?Uint32Array:Uint16Array).from(y)),y}(n),o=function(n,y){const H=[];for(const o of n.getVerticesDataKinds()){if(null!==y&&void 0!==y&&y.includes(o)){if(o===Ln.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const G=n.getVertexBuffer(o),h=G.getSize(),k=(0,C.u)(G.getData(),h,G.type,G.byteOffset,G.byteStride,G.normalized,n.getTotalVertices(),!0);H.push({kind:o,dracoName:mn(o),size:h,data:k})}return H}(n,null===y||void 0===y?void 0:y.excludedAttributes);return await this._encodeAsync(o,H,y)}}yy.DefaultConfiguration={wasmUrl:`${G.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${G.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${G.Tools._DefaultCdnUrl}/draco_encoder.js`},yy._Default=null;const Hy="KHR_draco_mesh_compression";class oy{get wasUsed(){return this._wasUsed}constructor(n){this.name=Hy,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===n.options.meshCompressionMethod&&yy.DefaultAvailable}dispose(){}postExportMeshPrimitive(n,y,H){if(!this.enabled)return;if(4!==n.mode&&5!==n.mode)return void S.d.Warn("Cannot compress primitive with mode "+n.mode+".");const o=[],G=[];let h=null;if(void 0!==n.indices){const k=H[n.indices],i=y.getBufferView(k);h=y.getData(i).slice(),o.push(i),G.push(k)}const k=[];for(const[q,b]of Object.entries(n.attributes)){const n=H[b],h=y.getBufferView(n),B=P(n.type),V=(0,C.u)(y.getData(h),B,n.componentType,n.byteOffset||0,h.byteStride||(0,C.o)(n.componentType)*B,n.normalized||!1,n.count,!0);k.push({kind:q,dracoName:(i=q,"POSITION"===i?"POSITION":"NORMAL"===i?"NORMAL":i.startsWith("COLOR")?"COLOR":i.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:P(n.type),data:V}),o.push(h),G.push(n)}var i;const B={method:n.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},V=yy.Default._encodeAsync(k,h,B).then((H=>{if(!H)return void S.d.Error("Draco encoding failed for primitive.");const h={bufferView:-1,attributes:H.attributeIds},k=y.createBufferView(H.data);y.setBufferView(h,k);for(const n of o)this._bufferViewsUsed.add(n);for(const n of G)this._accessorsUsed.add(n);n.extensions||(n.extensions={}),n.extensions[Hy]=h})).catch((n=>{S.d.Error("Draco encoding failed for primitive: "+n)}));this._encodePromises.push(V),this._wasUsed=!0}async preGenerateBinaryAsync(n){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((y=>{n.getPropertiesWithBufferView(y).every((n=>this._accessorsUsed.has(n)))&&n.removeBufferView(y)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Zn.RegisterExtension(Hy,(n=>new oy(n)));var Gy=H(11972);const hy="KHR_lights_punctual",ky={name:"",color:[1,1,1],di:1,range:Number.MAX_VALUE},iy={innerConeAngle:0,outerConeAngle:Math.PI/4},By=o.zy.Backward();class Vy{constructor(n){this.name=hy,this.enabled=!0,this.required=!1,this._exporter=n}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[hy]=this._lights}async postExportNodeAsync(n,y,H,G,h){return await new Promise((k=>{if(!(H instanceof Fn.e))return void k(y);const i=H.getTypeID()==Fn.e.LIGHTTYPEID_POINTLIGHT?"point":H.getTypeID()==Fn.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":H.getTypeID()==Fn.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!i||!(H instanceof Gy.c))return S.d.Warn(`${n}: Light ${H.name} is not supported in ${hy}`),void k(y);if(H.falloffType!==Fn.e.FALLOFF_GLTF&&S.d.Warn(`${n}: Light falloff for ${H.name} does not match the ${hy} specification!`),!H.position.equalsToFloats(0,0,0)){const n=o.TmpVectors.zy[0].B(H.position);h&&L(n),y.translation=n.Ui()}if("point"!==i){const n=H.direction.normalizeToRef(o.TmpVectors.zy[0]);h&&L(n);const G=o.Quaternion.FromUnitVectorsToRef(By,n,o.TmpVectors.Quaternion[0]);o.Quaternion.IsIdentity(G)||(y.rotation=G.Ui())}const B={type:i,name:H.name,color:H.ai.Ui(),di:H.di,range:H.range};if(on(B,ky),"spot"===i){const n=H;B.spot={innerConeAngle:n.innerAngle/2,outerConeAngle:n.angle/2},on(B.spot,iy)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(B);const V={zh:this._lights.lights.length-1},q=H.parent;if(q&&yn(H,q)){const n=G.get(q);if(n){const H=this._exporter._nodes[n];return nn(y,H),H.extensions||(H.extensions={}),H.extensions[hy]=V,void k(null)}}y.extensions||(y.extensions={}),y.extensions[hy]=V,k(y)}))}}Zn.RegisterExtension(hy,(n=>new Vy(n)));var qy=H(11869);const by="KHR_materials_anisotropy";class Ay{constructor(n){this.name=by,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=n}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(n,y,H){const o=[];return H instanceof qy.e&&H.anisotropy.isEnabled&&!H.anisotropy.legacy?(H.anisotropy.texture&&o.push(H.anisotropy.texture),o):[]}postExportMaterialAsync(n,y,H){return new Promise((n=>{if(H instanceof qy.e){if(!H.anisotropy.isEnabled||H.anisotropy.legacy)return void n(y);this._wasUsed=!0,y.extensions=y.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(H.anisotropy.texture),G={anisotropyStrength:H.anisotropy.di,anisotropyRotation:H.anisotropy.angle,anisotropyTexture:o??void 0};null!==G.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(H),y.extensions[by]=G}n(y)}))}}Zn.RegisterExtension(by,(n=>new Ay(n)));const Uy="KHR_materials_clearcoat";class Ty{constructor(n){this.name=Uy,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=n}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(n,y,H){const o=[];return H instanceof qy.e&&H.clearCoat.isEnabled?(H.clearCoat.texture&&o.push(H.clearCoat.texture),!H.clearCoat.useRoughnessFromMainTexture&&H.clearCoat.textureRoughness&&o.push(H.clearCoat.textureRoughness),H.clearCoat.bumpTexture&&o.push(H.clearCoat.bumpTexture),o):[]}postExportMaterialAsync(n,y,H){return new Promise((n=>{if(H instanceof qy.e){if(!H.clearCoat.isEnabled)return void n(y);this._wasUsed=!0,y.extensions=y.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(H.clearCoat.texture);let h;h=H.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(H.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(H.clearCoat.textureRoughness),H.clearCoat.isTintEnabled&&G.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${H.name}`),H.clearCoat.remapF0OnInterfaceChange&&G.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${H.name}`);const k=this._exporter._materialExporter.getTextureInfo(H.clearCoat.bumpTexture),i={clearcoatFactor:H.clearCoat.di,clearcoatTexture:o??void 0,clearcoatRoughnessFactor:H.clearCoat.roughness,clearcoatRoughnessTexture:h??void 0,clearcoatNormalTexture:k??void 0};null===i.clearcoatTexture&&null===i.clearcoatRoughnessTexture&&null===i.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(H),y.extensions[Uy]=i}n(y)}))}}Zn.RegisterExtension(Uy,(n=>new Ty(n)));const Wy="KHR_materials_diffuse_transmission";function zy(n,y){const H=y.subSurface;let o=null;return H.translucencyIntensityTexture?o=H.translucencyIntensityTexture:H.thicknessTexture&&H.useMaskFromThicknessTexture&&(o=H.thicknessTexture),o&&!H.useGltfStyleTextures?(S.d.Warn(`${n}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${y.name}`,1),null):o}class Qy{constructor(n){this.name=Wy,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=n}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(n,y,H){const o=[];if(H instanceof Wn.e&&this._isExtensionEnabled(H)){const y=zy(n,H);return y&&o.push(y),H.subSurface.translucencyColorTexture&&o.push(H.subSurface.translucencyColorTexture),o}return o}_isExtensionEnabled(n){if(n.unlit)return!1;const y=n.subSurface;return!!y.isTranslucencyEnabled&&(!n.unlit&&!y.useAlbedoToTintTranslucency&&y.useGltfStyleTextures&&1===y.volumeIndexOfRefraction&&0===y.minimumThickness&&0===y.maximumThickness)}postExportMaterialAsync(n,y,H){return new Promise((o=>{if(H instanceof Wn.e&&this._isExtensionEnabled(H)){this._wasUsed=!0;const o=H.subSurface,G=zy(n,H),h=0==o.translucencyIntensity?void 0:o.translucencyIntensity,k=this._exporter._materialExporter.getTextureInfo(G)??void 0,i=!o.translucencyColor||o.translucencyColor.equalsFloats(1,1,1)?void 0:o.translucencyColor.Ui(),B=this._exporter._materialExporter.getTextureInfo(o.translucencyColorTexture)??void 0,V={diffuseTransmissionFactor:h,diffuseTransmissionTexture:k,diffuseTransmissionColorFactor:i,diffuseTransmissionColorTexture:B};(k||B)&&this._exporter._materialNeedsUVsSet.add(H),y.extensions=y.extensions||{},y.extensions[Wy]=V}o(y)}))}}Zn.RegisterExtension(Wy,(n=>new Qy(n)));const ly="KHR_materials_dispersion";class vy{constructor(){this.name=ly,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(n){if(n.unlit)return!1;const y=n.subSurface;return!(!y.isRefractionEnabled&&!y.isDispersionEnabled)}postExportMaterialAsync(n,y,H){return new Promise((n=>{if(H instanceof Wn.e&&this._isExtensionEnabled(H)){this._wasUsed=!0;const n={dispersion:H.subSurface.dispersion};y.extensions=y.extensions||{},y.extensions[ly]=n}n(y)}))}}Zn.RegisterExtension(ly,(()=>new vy));const Fy="KHR_materials_emissive_strength";class gy{constructor(){this.name=Fy,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(n,y,H){return await new Promise((n=>{if(!(H instanceof Wn.e))return n(y);const o=H.emissiveColor.Ui(),G=Math.max(...o);if(G>1){this._wasUsed=!0,y.extensions||(y.extensions={});const n={emissiveStrength:G},o=H.emissiveColor.scale(1/n.emissiveStrength);y.emissiveFactor=o.Ui(),y.extensions[Fy]=n}return n(y)}))}}Zn.RegisterExtension(Fy,(n=>new gy));const My="KHR_materials_ior";class fy{constructor(){this.name=My,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(n){return!n.unlit&&(void 0!=n.indexOfRefraction&&1.5!=n.indexOfRefraction)}postExportMaterialAsync(n,y,H){return new Promise((n=>{if(H instanceof Wn.e&&this._isExtensionEnabled(H)){this._wasUsed=!0;const n={ior:H.indexOfRefraction};y.extensions=y.extensions||{},y.extensions[My]=n}n(y)}))}}Zn.RegisterExtension(My,(n=>new fy));const cy="KHR_materials_iridescence";class py{constructor(n){this.name=cy,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=n}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(n,y,H){const o=[];return H instanceof qy.e&&H.iridescence.isEnabled?(H.iridescence.texture&&o.push(H.iridescence.texture),H.iridescence.thicknessTexture&&H.iridescence.thicknessTexture!==H.iridescence.texture&&o.push(H.iridescence.thicknessTexture),o):[]}postExportMaterialAsync(n,y,H){return new Promise((n=>{if(H instanceof qy.e){if(!H.iridescence.isEnabled)return void n(y);this._wasUsed=!0,y.extensions=y.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(H.iridescence.texture),G=this._exporter._materialExporter.getTextureInfo(H.iridescence.thicknessTexture),h={iridescenceFactor:H.iridescence.di,iridescenceIor:H.iridescence.indexOfRefraction,iridescenceThicknessMinimum:H.iridescence.minimumThickness,iridescenceThicknessMaximum:H.iridescence.maximumThickness,iridescenceTexture:o??void 0,iridescenceThicknessTexture:G??void 0};null===h.iridescenceTexture&&null===h.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(H),y.extensions[cy]=h}n(y)}))}}Zn.RegisterExtension(cy,(n=>new py(n)));const Ey="KHR_materials_sheen";class Xy{constructor(n){this.name=Ey,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=n}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(n,y,H){return H instanceof Wn.e&&H.sheen.isEnabled&&H.sheen.texture?[H.sheen.texture]:[]}async postExportMaterialAsync(n,y,H){return await new Promise((n=>{if(H instanceof Wn.e){if(!H.sheen.isEnabled)return void n(y);this._wasUsed=!0,null==y.extensions&&(y.extensions={});const o={sheenColorFactor:H.sheen.color.Ui(),sheenRoughnessFactor:H.sheen.roughness??0};null===o.sheenColorTexture&&null===o.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(H),H.sheen.texture&&(o.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.texture)??void 0),H.sheen.textureRoughness&&!H.sheen.useRoughnessFromMainTexture?o.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.textureRoughness)??void 0:H.sheen.texture&&H.sheen.useRoughnessFromMainTexture&&(o.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.texture)??void 0),y.extensions[Ey]=o}n(y)}))}}Zn.RegisterExtension(Ey,(n=>new Xy(n)));const dy="KHR_materials_specular";class ay{constructor(n){this.name=dy,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=n}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(n,y,H){const o=[];return H instanceof Wn.e&&this._isExtensionEnabled(H)?(H.metallicReflectanceTexture&&o.push(H.metallicReflectanceTexture),H.reflectanceTexture&&o.push(H.reflectanceTexture),o):o}_isExtensionEnabled(n){return!n.unlit&&(void 0!=n.metallicF0Factor&&1!=n.metallicF0Factor||void 0!=n.metallicReflectanceColor&&!n.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(n))}_hasTexturesExtension(n){return null!=n.metallicReflectanceTexture||null!=n.reflectanceTexture}postExportMaterialAsync(n,y,H){return new Promise((n=>{if(H instanceof Wn.e&&this._isExtensionEnabled(H)){this._wasUsed=!0,y.extensions=y.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(H.metallicReflectanceTexture)??void 0,o=this._exporter._materialExporter.getTextureInfo(H.reflectanceTexture)??void 0,G={specularFactor:1==H.metallicF0Factor?void 0:H.metallicF0Factor,specularTexture:n,specularColorFactor:H.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:H.metallicReflectanceColor.Ui(),specularColorTexture:o};this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),y.extensions[dy]=G}n(y)}))}}Zn.RegisterExtension(dy,(n=>new ay(n)));const Oy="KHR_materials_transmission";class ey{constructor(n){this.name=Oy,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=n}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(n,y,H){const o=[];return H instanceof Wn.e&&this._isExtensionEnabled(H)?(H.subSurface.thicknessTexture&&o.push(H.subSurface.thicknessTexture),o):o}_isExtensionEnabled(n){if(n.unlit)return!1;const y=n.subSurface;return y.isRefractionEnabled&&void 0!=y.refractionIntensity&&0!=y.refractionIntensity||this._hasTexturesExtension(n)}_hasTexturesExtension(n){return null!=n.subSurface.refractionIntensityTexture}async postExportMaterialAsync(n,y,H){if(H instanceof Wn.e&&this._isExtensionEnabled(H)){this._wasUsed=!0;const o=H.subSurface,G={transmissionFactor:0===o.refractionIntensity?void 0:o.refractionIntensity};if(this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),o.refractionIntensityTexture)if(o.useGltfStyleTextures){const n=await this._exporter._materialExporter.exportTextureAsync(o.refractionIntensityTexture,"image/png");n&&(G.transmissionTexture=n)}else S.d.Warn(`${n}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);y.extensions||(y.extensions={}),y.extensions[Oy]=G}return y}}Zn.RegisterExtension(Oy,(n=>new ey(n)));const wy="KHR_materials_unlit";class jy{constructor(){this.name=wy,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(n,y,H){return new Promise((n=>{let o=!1;H instanceof Wn.e?o=H.unlit:H instanceof zn.vy&&(o=H.disableLighting),o&&(this._wasUsed=!0,null==y.extensions&&(y.extensions={}),y.extensions[wy]={}),n(y)}))}}Zn.RegisterExtension(wy,(()=>new jy));const Iy="KHR_materials_volume";class Ry{constructor(n){this.name=Iy,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=n}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(n,y,H){const o=[];return H instanceof Wn.e&&this._isExtensionEnabled(H)?(H.subSurface.thicknessTexture&&o.push(H.subSurface.thicknessTexture),o):o}_isExtensionEnabled(n){if(n.unlit)return!1;const y=n.subSurface;return!(!y.isRefractionEnabled&&!y.isTranslucencyEnabled)&&(void 0!=y.maximumThickness&&0!=y.maximumThickness||void 0!=y.tintColorAtDistance&&y.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=y.tintColor&&y.tintColor!=z.Fy.White()||this._hasTexturesExtension(n))}_hasTexturesExtension(n){return null!=n.subSurface.thicknessTexture}postExportMaterialAsync(n,y,H){return new Promise((n=>{if(H instanceof Wn.e&&this._isExtensionEnabled(H)){this._wasUsed=!0;const n=H.subSurface,o={thicknessFactor:0==n.maximumThickness?void 0:n.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(n.thicknessTexture)??void 0,attenuationDistance:n.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:n.tintColorAtDistance,attenuationColor:n.tintColor.equalsFloats(1,1,1)?void 0:n.tintColor.Ui()};this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),y.extensions=y.extensions||{},y.extensions[Iy]=o}n(y)}))}}Zn.RegisterExtension(Iy,(n=>new Ry(n)));const Cy="EXT_materials_diffuse_roughness";class Sy{constructor(n){this.name=Cy,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=n}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(n,y,H){const o=[];return H instanceof qy.e&&H._baseDiffuseRoughness?(H._baseDiffuseRoughnessTexture&&o.push(H._baseDiffuseRoughnessTexture),o):[]}postExportMaterialAsync(n,y,H){return new Promise((n=>{if(H instanceof qy.e){if(!H._baseDiffuseRoughness)return void n(y);this._wasUsed=!0,y.extensions=y.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(H._baseDiffuseRoughnessTexture),G={diffuseRoughnessFactor:H._baseDiffuseRoughness,diffuseRoughnessTexture:o??void 0};null!==G.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(H),y.extensions[Cy]=G}n(y)}))}}Zn.RegisterExtension(Cy,(n=>new Sy(n)));const Ny="KHR_texture_transform";class ry{constructor(){this.name=Ny,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(n,y,H){if(H.pn()||G.Tools.Warn(`${n}: /*@__KEY__*/"scene" is not defined for Babylon texture ${H.name}!`),(0!==H.uAng||0!==H.vAng)&&(G.Tools.Warn(`${n}: Texture ${H.name} with rotation in the u or v axis is not supported in glTF.`),0!==H.uRotationCenter||0!==H.vRotationCenter))return;const o={};let h=!1;if(0===H.uOffset&&0===H.vOffset||(o.offset=[H.uOffset,H.vOffset],h=!0),1===H.uScale&&1===H.vScale||(o.scale=[H.uScale,H.vScale],h=!0),0!==H.wAng){if(0!==H.uRotationCenter||0!==H.vRotationCenter){if(H.homogeneousRotationInUVTransform&&H.uScale!==H.vScale)return void G.Tools.Warn(`${n}: Texture ${H.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Ny}.`);G.Tools.Warn(`${n}: Texture ${H.name} with non-origin rotation center will be exported using an adjusted offset with ${Ny}.`),o.offset=function(n){const{uOffset:y,vOffset:H,uRotationCenter:o,vRotationCenter:G,uScale:h,vScale:k,wAng:i}=n,B=Math.cos(i),V=Math.sin(i),q=o*h,b=G*k;return[y+(q*(1-B)+b*V),H+(b*(1-B)-q*V)]}(H)}o.rotation=-H.wAng,h=!0}0!==H.coordinatesIndex&&(o.texCoord=H.coordinatesIndex,h=!0),h&&(this._wasUsed=!0,y.extensions||(y.extensions={}),y.extensions[Ny]=o)}}Zn.RegisterExtension(Ny,(()=>new ry));class Ky{static CreateSTL(n){let y=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",G=arguments.length>3&&void 0!==arguments[3]&&arguments[3],h=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],k=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],B=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const V=function(n,y,H){const G=[3*n[H],3*n[H+1],3*n[H+2]],h=[new o.zy(y[G[0]],y[G[0]+2],y[G[0]+1]),new o.zy(y[G[1]],y[G[1]+2],y[G[1]+1]),new o.zy(y[G[2]],y[G[2]+2],y[G[2]+1])],k=h[0].Qy(h[1]),i=h[2].Qy(h[1]);return{v:h,n:o.zy.Cross(i,k).normalize()}},b=function(n,y,H,o){return y=A(n,y,H.x,o),y=A(n,y,H.y,o),A(n,y,H.z,o)},A=function(n,y,H,o){return n.setFloat32(y,H,o),y+4},T=function(n){if(i){let y=n;n instanceof U.d&&(y=n.sourceMesh);const H=y.getVerticesData(q.g.PositionKind,!0,!0);if(!H)return[];const G=o.zy.Zero();let h;for(h=0;h<H.length;h+=3)o.zy.TransformCoordinatesFromFloatsToRef(H[h],H[h+1],H[h+2],n.Qi(!0),G).toArray(H,h);return H}return n.getVerticesData(q.g.PositionKind)||[]};i&&(k=!0);let W="",z=0,Q=0;if(G){for(let H=0;H<n.length;H++){const y=n[H].Fi();z+=y?y.length/3:0}const y=new ArrayBuffer(84+50*z);W=new DataView(y),Q+=80,W.setUint32(Q,z,h),Q+=4}else B||(W="solid stlmesh\r\n");for(let o=0;o<n.length;o++){const y=n[o];!G&&B&&(W+="solid "+y.name+"\r\n"),!k&&y instanceof vn.b&&y.bakeCurrentTransformIntoVertices();const H=T(y),i=y.Fi()||[];for(let n=0;n<i.length;n+=3){const y=V(i,H,n);G?(Q=b(W,Q,y.n,h),Q=b(W,Q,y.v[0],h),Q=b(W,Q,y.v[1],h),Q=b(W,Q,y.v[2],h),Q+=2):(W+="\tfacet normal "+y.n.x+" "+y.n.y+" "+y.n.z+"\r\n",W+="\t\touter loop\r\n",W+="\t\t\tvertex "+y.v[0].x+" "+y.v[0].y+" "+y.v[0].z+"\r\n",W+="\t\t\tvertex "+y.v[1].x+" "+y.v[1].y+" "+y.v[1].z+"\r\n",W+="\t\t\tvertex "+y.v[2].x+" "+y.v[2].y+" "+y.v[2].z+"\r\n",W+="\t\tendloop\r\n",W+="\tendfacet\r\n")}!G&&B&&(W+="endsolid "+name+"\r\n")}if(G||B||(W+="endsolid stlmesh"),y){const n=document.createElement("a"),y=new Blob([W],{type:"application/octet-stream"});n.href=window.URL.createObjectURL(y),n.download=H+".stl",n.click()}return W}}function Yy(n,y){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const o=[];for(let G=0;G<n.length/H;G++){const h=n[G*H],k=n[G*H+1],i=n[G*H+2];o.push(`(${h.toPrecision(y.precision)}, ${k.toPrecision(y.precision)}, ${i.toPrecision(y.precision)})`)}return o.join(", ")}function Dy(n,y){const H=[];for(let o=0;o<n.length/2;o++){const G=n[2*o],h=n[2*o+1];H.push(`(${G.toPrecision(y.precision)}, ${(1-h).toPrecision(y.precision)})`)}return H.join(", ")}function Zy(n,y){const H=n.getVerticesData(q.g.PositionKind),o=n.getVerticesData(q.g.NormalKind);if(H&&o)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(n){var y;const H=null!==(y=n.Fi())&&void 0!==y&&y.length?n.getTotalIndices():n.getTotalVertices();return Array(H/3).fill(3).join(", ")}(n)}]\n\t\tint[] faceVertexIndices = [${function(n){const y=n.Fi(),H=[];if(null!==y)for(let o=0;o<y.length;o++)H.push(y[o]);else{const y=n.getTotalVertices();for(let n=0;n<y;n++)H.push(n)}return H.join(", ")}(n)}]\n\t\tnormal3f[] normals = [${Yy(o,y)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Yy(H,y)}]\n        ${function(n,y){let H="";for(let G=0;G<4;G++){const o=G>0?G:"",h=n.getVerticesData(q.g.UVKind+(o?o+1:""));h&&(H+=`\n\t\ttexCoord2f[] primvars:st${o} = [${Dy(h,y)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const o=n.getVerticesData(q.g.ColorKind);return o&&(H+=`\n\tcolor3f[] primvars:displayColor = [${Yy(o,y,o.length/n.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),H}(n,y)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function sy(n,y){return`\n        def "Geometry"\n        {\n        ${Zy(n,y)}\n        }\n        `}function Py(n){let y='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return y+=n,fflate.strToU8(y)}function xy(n){const y=n.m;return`( ${ty(y,0)}, ${ty(y,4)}, ${ty(y,8)}, ${ty(y,12)} )`}function ty(n,y){return`(${n[y+0]}, ${n[y+1]}, ${n[y+2]}, ${n[y+3]})`}function uy(n){const y="Object_"+n.uniqueId,H=function(n){const y=n.getWorldMatrix().clone(),H=n.pn().useRightHandedSystem;if(!H){let o=n.parent;for(;o;){if(kn(o,H)){y.multiplyToRef(o.getWorldMatrix().invert(),y);break}o=o.parent}}return y.determinant()<0&&G.Tools.Warn(`Exporting mesh ${n.name} with negative scale. Result may look incorrect in destination engine.`),y}(n),o=xy(H);return`def Xform "${y}" (\n\tprepend references = @./geometries/Geometry_${n.li.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${o}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${n.material.uniqueId}>\n}\n\n`}function Ly(n){switch(n){case f.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case f.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case f.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Jy(n){return`(${n.x}, ${n.y})`}function my(n){return`(${n.r}, ${n.g}, ${n.b})`}function nH(n,y,H,G,h,k){const i=n.getInternalTexture().uniqueId+"_"+n.invertY;h[i]=n;const B=n.coordinatesIndex>0?"st"+n.coordinatesIndex:"st",V=new o.Vector2(n.uScale,n.vScale),q=new o.Vector2(n.uOffset,n.vOffset),b=n.wAng,A=Math.sin(b),U=Math.cos(b);return q.y=1-q.y-V.y,q.x+=A*V.x,q.y+=(1-U)*V.y,`\n    def Shader "PrimvarReader_${H}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${B}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${H}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${y.uniqueId}/PrimvarReader_${H}.outputs:result>\n        float inputs:rotation = ${(b*(180/Math.PI)).toFixed(k.precision)}\n        float2 inputs:scale = ${Jy(V)}\n        float2 inputs:translation = ${Jy(q)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${n.uniqueId}_${H}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${i}.png@\n        float2 inputs:st.connect = </Materials/Material_${y.uniqueId}/Transform2d_${H}.outputs:result>\n        ${G?"float4 inputs:scale = "+function(n){return`(${n.r}, ${n.g}, ${n.b}, 1.0)`}(G):""}\n        token inputs:sourceColorSpace = "${n.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Ly(n.wrapU)}"\n        token inputs:wrapT = "${Ly(n.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${y.needAlphaBlending()?"float outputs:a":""}\n    }`}function yH(n,y,H){const o="\t\t\t",G=[],h=[],{diffuseMap:k,ai:i,alphaCutOff:B,emissiveMap:V,emissive:q,normalMap:b,roughnessMap:A,roughnessChannel:U,roughness:T,metalnessMap:W,metalnessChannel:Q,metalness:l,aoMap:v,aoMapChannel:F,aoMapIntensity:g,alphaMap:M,ior:f,clearCoatEnabled:c,clearCoat:p,clearCoatMap:E,clearCoatRoughness:X,clearCoatRoughnessMap:d}=function(n){const y={diffuseMap:null,ai:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return n instanceof zn.vy?{...y,diffuseMap:n.diffuseTexture,ai:n.diffuseColor,alphaCutOff:n.alphaCutOff,emissiveMap:n.emissiveTexture,emissive:n.emissiveColor,roughness:1,alphaMap:n.opacityTexture}:n instanceof qy.e?{...y,diffuseMap:n._albedoTexture,ai:n._albedoColor,alphaCutOff:n._alphaCutOff,emissiveMap:n._emissiveTexture,emissive:n._emissiveColor,normalMap:n._bumpTexture,roughnessMap:n._metallicTexture,roughnessChannel:n._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:n._roughness??1,metalnessMap:n._metallicTexture,metalnessChannel:n._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:n._metallic??0,aoMap:n._ambientTexture,aoMapChannel:n._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:n._ambientTextureStrength,alphaMap:n._opacityTexture,ior:n.subSurface.indexOfRefraction,clearCoatEnabled:n.clearCoat.isEnabled,clearCoat:n.clearCoat.di,clearCoatMap:n.clearCoat.texture,clearCoatRoughness:n.clearCoat.roughness,clearCoatRoughnessMap:n.clearCoat.useRoughnessFromMainTexture?n.clearCoat.texture:n.clearCoat.textureRoughness}:y}(n);return null!==k?(G.push(`${o}color3f inputs:diffuseColor.connect = </Materials/Material_${n.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:rgb>`),n.needAlphaBlending()?G.push(`${o}float inputs:opacity.connect = </Materials/Material_${n.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:a>`):n.needAlphaTesting()&&(G.push(`${o}float inputs:opacity.connect = </Materials/Material_${n.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:a>`),G.push(`${o}float inputs:opacityThreshold = ${B}`)),h.push(nH(k,n,"diffuse",i,y,H))):G.push(`${o}color3f inputs:diffuseColor = ${my(i||z.Fy.White())}`),null!==V?(G.push(`${o}color3f inputs:emissiveColor.connect = </Materials/Material_${n.uniqueId}/Texture_${V.uniqueId}_emissive.outputs:rgb>`),h.push(nH(V,n,"emissive",q,y,H))):q&&q.toLuminance()>0&&G.push(`${o}color3f inputs:emissiveColor = ${my(q)}`),null!==b&&(G.push(`${o}normal3f inputs:normal.connect = </Materials/Material_${n.uniqueId}/Texture_${b.uniqueId}_normal.outputs:rgb>`),h.push(nH(b,n,"normal",null,y,H))),null!==v&&(G.push(`${o}float inputs:occlusion.connect = </Materials/Material_${n.uniqueId}/Texture_${v.uniqueId}_occlusion.outputs:${F}>`),h.push(nH(v,n,"occlusion",new z.Fy(g,g,g),y,H))),null!==A?(G.push(`${o}float inputs:roughness.connect = </Materials/Material_${n.uniqueId}/Texture_${A.uniqueId}_roughness.outputs:${U}>`),h.push(nH(A,n,"roughness",new z.Fy(T,T,T),y,H))):G.push(`${o}float inputs:roughness = ${T}`),null!==W?(G.push(`${o}float inputs:metallic.connect = </Materials/Material_${n.uniqueId}/Texture_${W.uniqueId}_metallic.outputs:${Q}>`),h.push(nH(W,n,"metallic",new z.Fy(l,l,l),y,H))):G.push(`${o}float inputs:metallic = ${l}`),null!==M?(G.push(`${o}float inputs:opacity.connect = </Materials/Material_${n.uniqueId}/Texture_${M.uniqueId}_opacity.outputs:r>`),G.push(`${o}float inputs:opacityThreshold = 0.0001`),h.push(nH(M,n,"opacity",null,y,H))):G.push(`${o}float inputs:opacity = ${n.alpha}`),c&&(null!==E?(G.push(`${o}float inputs:clearcoat.connect = </Materials/Material_${n.uniqueId}/Texture_${E.uniqueId}_clearcoat.outputs:r>`),h.push(nH(E,n,"clearcoat",new z.Fy(p,p,p),y,H))):G.push(`${o}float inputs:clearcoat = ${p}`),null!==d?(G.push(`${o}float inputs:clearcoatRoughness.connect = </Materials/Material_${n.uniqueId}/Texture_${d.uniqueId}_clearcoatRoughness.outputs:g>`),h.push(nH(d,n,"clearcoatRoughness",new z.Fy(X,X,X),y,H))):G.push(`${o}float inputs:clearcoatRoughness = ${X}`)),G.push(`${o}float inputs:ior = ${f}`),`\n\tdef Material "Material_${n.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${G.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${n.uniqueId}/PreviewSurface.outputs:surface>\n\n${h.join("\n")}\n\n\t}\n`}async function HH(n,y,H){const h={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...y};"undefined"===typeof fflate&&await G.Tools.LoadScriptAsync(h.fflateUrl);const k={};k[h.modelFileName]=null;let i='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';i+=function(n){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===n.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${n.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${n.planeAnchoringAlignment}"`:""}\n            `}(h);const B={};for(const o of n.meshes){if(0===o.getTotalVertices())continue;const n=o,y=n.li,V=n.material;if(!V||!y||H&&!H(n))continue;if(-1!==["vy","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(V.getClassName())){const H="geometries/Geometry_"+y.uniqueId+".usda";if(!(H in k)){const n=sy(y,h);k[H]=Py(n)}V.uniqueId in B||(B[V.uniqueId]=V),i+=uy(n)}else G.Tools.Warn("USDZExportAsync does not support this material type: "+V.getClassName())}n.activeCamera&&h.exportCamera&&(i+=function(n,y){const H="Camera_"+n.uniqueId,G=xy(o.Matrix.RotationY(Math.PI).multiply(n.getWorldMatrix()));if(n.mode===f.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${H}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${G}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${n.Wi.toPrecision(y.precision)}, ${n.maxZ.toPrecision(y.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(n.orthoLeft||1)+Math.abs(n.orthoRight||1))).toPrecision(y.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(n.orthoTop||1)+Math.abs(n.orthoBottom||1))).toPrecision(y.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const o=n.getEngine().getAspectRatio(n),h=y.cameraSensorWidth||35;return`def Camera "${H}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${G}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${n.Wi.toPrecision(y.precision)}, ${n.maxZ.toPrecision(y.precision)})\n\t\t\tfloat focalLength = ${(h/(2*Math.tan(.5*n.fov))).toPrecision(y.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(h*o).toPrecision(y.precision)}\n\t\t\tfloat verticalAperture = ${(h/o).toPrecision(y.precision)}            \n\t\t}\n\t\n\t`}}(n.activeCamera,h)),i+="\n            }\n        }\n    }";const V={};i+=function(n,y,H){const o=[];for(const G in n){const h=n[G];o.push(yH(h,y,H))}return`\n    def "Materials"\n{\n${o.join("")}\n}\n\n`}(B,V,h),k[h.modelFileName]=fflate.strToU8(i);for(const o in V){const n=V[o],y=n.getSize(),H=await n.readPixels();if(!H)throw new Error("Texture data is not available");const G=await c.DumpTools.DumpDataAsync(y.width,y.height,H,"image/png",void 0,!1,!0);k[`textures/Texture_${o}.png`]=new Uint8Array(G).slice()}let q=0;for(const o in k){const n=k[o];if(!n)continue;q+=34+o.length;const y=63&q;if(4!==y){const H=new Uint8Array(64-y);k[o]=[n,{extra:{12345:H}}]}q=n.length}return fflate.zipSync(k,{level:0})}}}]);