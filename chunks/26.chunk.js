"use strict";(self.bbj0x35f849=self.bbj0x35f849||[]).push([[26],{11536:(N,q,C)=>{C.r(q),C.d(q,{EXT_materials_diffuse_roughness:()=>oq,EXT_mesh_gpu_instancing:()=>RN,GLTF2Export:()=>BN,GLTFData:()=>A,KHR_draco_mesh_compression:()=>Cq,KHR_lights_punctual:()=>wq,KHR_materials_anisotropy:()=>tq,KHR_materials_clearcoat:()=>Zq,KHR_materials_diffuse_transmission:()=>vq,KHR_materials_dispersion:()=>Oq,KHR_materials_emissive_strength:()=>iq,KHR_materials_ior:()=>jq,KHR_materials_iridescence:()=>Tq,KHR_materials_sheen:()=>pq,KHR_materials_specular:()=>Xq,KHR_materials_transmission:()=>Mq,KHR_materials_unlit:()=>Eq,KHR_materials_volume:()=>eq,KHR_texture_transform:()=>Dq,OBJExport:()=>a,STLExport:()=>cq,USDZExportAsync:()=>qC,_ConvertToGLTFPBRMetallicRoughness:()=>Y,_SolveMetallic:()=>M,__IGLTFExporterExtension:()=>F});var d=C(11122),U=C(10945),W=C(11447);class a{static OBJ(N,q,C,a){const F=[];let w=1,A=1;q&&(C||(C="mat"),F.push("mtllib "+C+".mtl"));for(let n=0;n<N.length;n++){const C=N[n],t=C.name||`mesh${n}}`;F.push(`o ${t}`);let V=null;if(a){const N=C.Ed(!0);V=new d.Matrix,N.invertToRef(V),C.bakeTransformIntoVertices(N)}if(q){const N=C.material;N&&F.push("usemtl "+N.id)}const Z=C.ed;if(!Z){U.Tools.Warn("No geometry is present on the mesh");continue}const J=Z.getVerticesData("position"),Q=Z.getVerticesData("normal"),v=Z.getVerticesData("uv"),r=Z.od();let O=0,K=0;if(!J||!r){U.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const i=N[0].lN().useRightHandedSystem?1:-1;for(let N=0;N<J.length;N+=3)F.push("v "+J[N]*i+" "+J[N+1]+" "+J[N+2]),O++;if(null!=Q)for(let N=0;N<Q.length;N+=3)F.push("vn "+Q[N]*i+" "+Q[N+1]+" "+Q[N+2]);if(null!=v)for(let N=0;N<v.length;N+=2)F.push("vt "+v[N]+" "+v[N+1]),K++;const I=["","",""],j=(C.material||C.lN().defaultMaterial)._getEffectiveOrientation(C),[l,T]=j===W.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let N=0;N<r.length;N+=3){const q=[String(r[N]+w),String(r[N+l]+w),String(r[N+T]+w)],C=[String(r[N]+A),String(r[N+l]+A),String(r[N+T]+A)],d=q,U=null!=v?C:I,W=null!=Q?q:I;F.push("f "+d[0]+"/"+U[0]+"/"+W[0]+" "+d[1]+"/"+U[1]+"/"+W[1]+" "+d[2]+"/"+U[2]+"/"+W[2])}a&&V&&C.bakeTransformIntoVertices(V),w+=O,A+=K}return F.join("\n")}static MTL(N){const q=[],C=N.material;q.push("newmtl mat1"),q.push("  Ns "+C.specularPower.toFixed(4)),q.push("  Ni 1.5000"),q.push("  d "+C.alpha.toFixed(4)),q.push("  Tr 0.0000"),q.push("  Tf 1.0000 1.0000 1.0000"),q.push("  illum 2"),q.push("  Ka "+C.ambientColor.r.toFixed(4)+" "+C.ambientColor.g.toFixed(4)+" "+C.ambientColor.b.toFixed(4)),q.push("  Kd "+C.diffuseColor.r.toFixed(4)+" "+C.diffuseColor.g.toFixed(4)+" "+C.diffuseColor.b.toFixed(4)),q.push("  Ks "+C.specularColor.r.toFixed(4)+" "+C.specularColor.g.toFixed(4)+" "+C.specularColor.b.toFixed(4)),q.push("  Ke "+C.emissiveColor.r.toFixed(4)+" "+C.emissiveColor.g.toFixed(4)+" "+C.emissiveColor.b.toFixed(4));C.ambientTexture&&q.push("  map_Ka "+C.ambientTexture.name),C.diffuseTexture&&q.push("  map_Kd "+C.diffuseTexture.name),C.specularTexture&&q.push("  map_Ks "+C.specularTexture.name),C.bumpTexture&&q.push("  map_bump -imfchan z "+C.bumpTexture.name),C.opacityTexture&&q.push("  map_d "+C.opacityTexture.name);return q.join("\n")}}var F=0,w=C(11e3);class A{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const N in this.files){const q=this.files[N],C=new Blob([q],{type:(0,w.f)(N)});U.Tools.Download(C,N)}}}var n=C(11199),t=C(11541),V=C(11557),Z=C(11568),J=C(11259),Q=C(10995),v=C(11167),r=C(11142);const O=r.HighestCommonFactor,K={...r,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:O};var i=C(11356),I=C(11101),j=C(11596),l=C(11603),T=C(11354);const z=1e-6,p=new v.Oq(.04,.04,.04),s=1024,X=v.Oq.White(),P=v.Oq.Black();function M(N,q,C){if(q<p.r)return 0;const d=p.r,U=N*C/(1-p.r)+q-2*p.r,W=U*U-4*d*(p.r-q);return K.Clamp((-U+Math.sqrt(W))/(2*d),0,1)}function Y(N){const q=N.diffuseColor.toLinearSpace(N.lN().getEngine().useExactSrgbConversions).scale(.5),C=N.alpha,U=function(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new d.Vector2(0,1),C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new d.Vector2(0,.1),U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new d.Vector2(0,.1),W=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new d.Vector2(1300,.1);return function(N,q,C,d,U){return(1-N)*(1-N)*(1-N)*q+3*(1-N)*(1-N)*N*C+3*(1-N)*N*N*d+N*N*N*U}(Math.pow(N/W.x,.333333),q.y,C.y,U.y,W.y)}(K.Clamp(N.specularPower,0,s));return{baseColorFactor:[q.r,q.g,q.b,C],metallicFactor:0,roughnessFactor:U}}function E(N,q){q.needAlphaBlending()?N.alphaMode="BLEND":q.needAlphaTesting()&&(N.alphaMode="MASK",N.alphaCutoff=q.alphaCutOff)}function H(N,q,C){const d=new Uint8Array(N*q*4);for(let U=0;U<d.length;U+=4)d[U]=d[U+1]=d[U+2]=d[U+3]=255;return j.d.CreateRGBATexture(d,N,q,C)}function e(N){if(N instanceof Uint8Array){const q=N.length,C=new Float32Array(N.length);for(let d=0;d<q;++d)C[d]=N[d]/255;return C}if(N instanceof Float32Array)return N;throw new Error("Unsupported pixel format!")}class b{constructor(N){this._exporter=N,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(N){return N?this._textureMap.get(N)??null:null}async exportStandardMaterialAsync(N,q,C){const d=Y(N),W={name:N.name};if(null==N.Ld||N.Ld||(N.twoSidedLighting||U.Tools.Warn(N.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),W.doubleSided=!0),C){const C=[],U=N.diffuseTexture;U&&C.push(this.exportTextureAsync(U,q).then((N=>{N&&(d.baseColorTexture=N)})));const a=N.bumpTexture;a&&C.push(this.exportTextureAsync(a,q).then((N=>{N&&(W.normalTexture=N,1!==a.level&&(W.normalTexture.scale=a.level))})));const F=N.emissiveTexture;F&&(W.emissiveFactor=[1,1,1],C.push(this.exportTextureAsync(F,q).then((N=>{N&&(W.emissiveTexture=N)}))));const w=N.ambientTexture;w&&C.push(this.exportTextureAsync(w,q).then((N=>{if(N){const q={index:N.index};W.occlusionTexture=q}}))),C.length>0&&(this._exporter._materialNeedsUVsSet.add(N),await Promise.all(C))}(N.alpha<1||N.opacityTexture)&&(N.alphaMode===l.b.ALPHA_COMBINE?W.alphaMode="BLEND":U.Tools.Warn(N.name+": glTF 2.0 does not support alpha mode: "+N.alphaMode.toString())),N.emissiveColor&&!N.emissiveColor.equalsWithEpsilon(P,z)&&(W.emissiveFactor=N.emissiveColor.zd()),W.pbrMetallicRoughness=d,E(W,N),await this._finishMaterialAsync(W,N,q);const a=this._exporter._materials;return a.push(W),a.length-1}async _finishMaterialAsync(N,q,C){const d=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",N,q),U=[];for(const W of d)U.push(this.exportTextureAsync(W,C));await Promise.all(U),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",N,q)}async _getImageDataAsync(N,q,d,U){const W=l.b.TEXTURETYPE_UNSIGNED_BYTE,a=this._exporter._babylonScene,F=a.getEngine(),w=F.createRawTexture(N,q,d,l.b.TEXTUREFORMAT_RGBA,!1,!0,I.c.NEAREST_SAMPLINGMODE,null,W);F.isWebGPU?await C.e(51).then(C.bind(C,13576)):await C.e(52).then(C.bind(C,13585)),await i.m.ApplyPostProcess("pass",w,a,W,l.b.TEXTURE_NEAREST_SAMPLINGMODE,l.b.TEXTUREFORMAT_RGBA);const A=await F._readTexturePixels(w,q,d);return await T.DumpTools.DumpDataAsync(q,d,A,U,void 0,!0,!0)}_resizeTexturesToSameDimensions(N,q,C){const d=N?N.getSize():{width:0,height:0},U=q?q.getSize():{width:0,height:0};let W,a;return d.width<U.width?(W=N&&N instanceof I.c?i.m.CreateResizedCopy(N,U.width,U.height,!0):H(U.width,U.height,C),a=q):d.width>U.width?(a=q&&q instanceof I.c?i.m.CreateResizedCopy(q,d.width,d.height,!0):H(d.width,d.height,C),W=N):(W=N,a=q),{texture1:W,texture2:a}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(N,q,C,d){const U=new Array;if(!N&&!q)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const W=N?N.lN():q?q.lN():null;if(W){var a;const F=this._resizeTexturesToSameDimensions(N,q,W),w=null===(a=F.texture1)||void 0===a?void 0:a.getSize();let A,n;const t=w.width,V=w.height,Z=await F.texture1.readPixels(),J=await F.texture2.readPixels();if(!Z)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(A=e(Z),!J)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");n=e(J);const Q=n.byteLength,r=new Uint8Array(Q),O=new Uint8Array(Q),K=4,i=P;let I=0,j=0;for(let N=0;N<V;++N)for(let q=0;q<t;++q){const d=(t*N+q)*K,U={diffuseColor:new v.Oq(A[d],A[d+1],A[d+2]).toLinearSpace(W.getEngine().useExactSrgbConversions).multiply(C.diffuseColor),specularColor:new v.Oq(n[d],n[d+1],n[d+2]).toLinearSpace(W.getEngine().useExactSrgbConversions).multiply(C.specularColor),glossiness:n[d+3]*C.glossiness},a=this._convertSpecularGlossinessToMetallicRoughness(U);i.r=Math.max(i.r,a.baseColor.r),i.g=Math.max(i.g,a.baseColor.g),i.b=Math.max(i.b,a.baseColor.b),I=Math.max(I,a.metallic),j=Math.max(j,a.roughness),O[d]=255*a.baseColor.r,O[d+1]=255*a.baseColor.g,O[d+2]=255*a.baseColor.b,O[d+3]=F.texture1.pd?255*A[d+3]:255,r[d]=0,r[d+1]=255*a.roughness,r[d+2]=255*a.metallic,r[d+3]=255}const l={baseColor:i,metallic:I,roughness:j};let T=!1,p=!1;for(let N=0;N<V;++N)for(let q=0;q<t;++q){const C=(t*N+q)*K;O[C]/=l.baseColor.r>z?l.baseColor.r:1,O[C+1]/=l.baseColor.g>z?l.baseColor.g:1,O[C+2]/=l.baseColor.b>z?l.baseColor.b:1;const d=v.Oq.FromInts(O[C],O[C+1],O[C+2]).toGammaSpace(W.getEngine().useExactSrgbConversions);O[C]=255*d.r,O[C+1]=255*d.g,O[C+2]=255*d.b,d.equalsWithEpsilon(X,z)||(p=!0),r[C+1]/=l.roughness>z?l.roughness:1,r[C+2]/=l.metallic>z?l.metallic:1;v.Oq.FromInts(255,r[C+1],r[C+2]).equalsWithEpsilon(X,z)||(T=!0)}return T&&U.push(this._getImageDataAsync(r,t,V,d).then((N=>{l.metallicRoughnessTextureData=N}))),p&&U.push(this._getImageDataAsync(O,t,V,d).then((N=>{l.baseColorTextureData=N}))),await Promise.all(U).then((()=>l))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(N){const q=this._getPerceivedBrightness(N.diffuseColor),C=this._getPerceivedBrightness(N.specularColor),d=1-this._getMaxComponent(N.specularColor),U=M(q,C,d),W=N.diffuseColor.scale(d/(1-p.r)/Math.max(1-U)),a=N.specularColor.Qq(p.scale(1-U)).scale(1/Math.max(U));let F=v.Oq.Lerp(W,a,U*U);F=F.clampToRef(0,1,F);return{baseColor:F,metallic:U,roughness:1-N.glossiness}}_getPerceivedBrightness(N){return N?Math.sqrt(.299*N.r*N.r+.587*N.g*N.g+.114*N.b*N.b):0}_getMaxComponent(N){return N?Math.max(N.r,Math.max(N.g,N.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(N,q,C,d){const U=[],W={baseColor:N._albedoColor,metallic:N._metallic,roughness:N._roughness};if(d){N._albedoTexture&&U.push(this.exportTextureAsync(N._albedoTexture,q).then((N=>{N&&(C.baseColorTexture=N)})));const d=N._metallicTexture;d&&U.push(this.exportTextureAsync(d,q).then((N=>{N&&(C.metallicRoughnessTexture=N)})))}return U.length>0&&(this._exporter._materialNeedsUVsSet.add(N),await Promise.all(U)),W}_getTextureSampler(N){const q={};if(!N||!(N instanceof I.c))return q;const C=this._getGLTFTextureWrapMode(N.wrapU);10497!==C&&(q.wrapS=C);const d=this._getGLTFTextureWrapMode(N.wrapV);switch(10497!==d&&(q.wrapT=d),N.samplingMode){case I.c.LINEAR_LINEAR:q.magFilter=9729,q.minFilter=9729;break;case I.c.LINEAR_NEAREST:q.magFilter=9729,q.minFilter=9728;break;case I.c.NEAREST_LINEAR:q.magFilter=9728,q.minFilter=9729;break;case I.c.NEAREST_LINEAR_MIPLINEAR:q.magFilter=9728,q.minFilter=9987;break;case I.c.NEAREST_NEAREST:q.magFilter=9728,q.minFilter=9728;break;case I.c.NEAREST_LINEAR_MIPNEAREST:q.magFilter=9728,q.minFilter=9985;break;case I.c.LINEAR_NEAREST_MIPNEAREST:q.magFilter=9729,q.minFilter=9984;break;case I.c.LINEAR_NEAREST_MIPLINEAR:q.magFilter=9729,q.minFilter=9986;break;case I.c.NEAREST_NEAREST_MIPLINEAR:q.magFilter=9728,q.minFilter=9986;break;case I.c.LINEAR_LINEAR_MIPLINEAR:q.magFilter=9729,q.minFilter=9987;break;case I.c.LINEAR_LINEAR_MIPNEAREST:q.magFilter=9729,q.minFilter=9985;break;case I.c.NEAREST_NEAREST_MIPNEAREST:q.magFilter=9728,q.minFilter=9984}return q}_getGLTFTextureWrapMode(N){switch(N){case I.c.WRAP_ADDRESSMODE:return 10497;case I.c.CLAMP_ADDRESSMODE:return 33071;case I.c.MIRROR_ADDRESSMODE:return 33648;default:return U.Tools.Error(`Unsupported Texture Wrap Mode ${N}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(N,q,C,d){const U={diffuseColor:N._albedoColor,specularColor:N._reflectivityColor,glossiness:N._microSurface},W=N._albedoTexture,a=N._reflectivityTexture,F=N._useMicroSurfaceFromReflectivityMapAlpha;if(a&&!F)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((W||a)&&d){this._exporter._materialNeedsUVsSet.add(N);const d=this._exportTextureSampler(W||a),F=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(W,a,U,q),w=this._exporter._textures;if(F.baseColorTextureData){const N=this._exportImage(`baseColor${w.length}`,q,F.baseColorTextureData);C.baseColorTexture=this._exportTextureInfo(N,d,null===W||void 0===W?void 0:W.coordinatesIndex)}if(F.metallicRoughnessTextureData){const N=this._exportImage(`metallicRoughness${w.length}`,q,F.metallicRoughnessTextureData);C.metallicRoughnessTexture=this._exportTextureInfo(N,d,null===a||void 0===a?void 0:a.coordinatesIndex)}return F}return this._convertSpecularGlossinessToMetallicRoughness(U)}async exportPBRMaterialAsync(N,q,C){const d={},U={name:N.name},W=N.isMetallicWorkflow();if(W){const q=N._albedoColor,C=N.alpha;q&&(d.baseColorFactor=[q.r,q.g,q.b,C])}const a=W?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(N,q,d,C):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(N,q,d,C);await this._setMetallicRoughnessPbrMaterialAsync(a,N,U,d,q,C),await this._finishMaterialAsync(U,N,q);const F=this._exporter._materials;return F.push(U),F.length-1}async _setMetallicRoughnessPbrMaterialAsync(N,q,C,d,W,a){if(E(C,q),N.baseColor.equalsWithEpsilon(X,z)&&K.WithinEpsilon(q.alpha,1,z)||(d.baseColorFactor=[N.baseColor.r,N.baseColor.g,N.baseColor.b,q.alpha]),null!=N.metallic&&1!==N.metallic&&(d.metallicFactor=N.metallic),null!=N.roughness&&1!==N.roughness&&(d.roughnessFactor=N.roughness),null==q.Ld||q.Ld||(q._twoSidedLighting||U.Tools.Warn(q.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),C.doubleSided=!0),a){const N=[],d=q._bumpTexture;d&&N.push(this.exportTextureAsync(d,W).then((N=>{N&&(C.normalTexture=N,1!==d.level&&(C.normalTexture.scale=d.level))})));const U=q._ambientTexture;U&&N.push(this.exportTextureAsync(U,W).then((N=>{if(N){const d={index:N.index,texCoord:N.texCoord,extensions:N.extensions};C.occlusionTexture=d;const U=q._ambientTextureStrength;U&&(d.strength=U)}})));const a=q._emissiveTexture;a&&N.push(this.exportTextureAsync(a,W).then((N=>{N&&(C.emissiveTexture=N)}))),N.length>0&&(this._exporter._materialNeedsUVsSet.add(q),await Promise.all(N))}const F=q._emissiveColor;F.equalsWithEpsilon(P,z)||(C.emissiveFactor=F.zd()),C.pbrMetallicRoughness=d}_getPixelsFromTextureAsync(N){return function(N){switch(N){case l.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case l.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case l.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case l.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case l.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case l.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case l.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case l.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case l.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case l.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case l.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case l.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case l.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case l.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case l.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case l.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case l.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case l.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case l.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case l.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case l.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(N.textureFormat)?(0,i.i)(N,N._texture.width,N._texture.height):(N.textureType,l.b.TEXTURETYPE_UNSIGNED_BYTE,N.readPixels())}async exportTextureAsync(N,q){const C=this._exporter._extensionsPreExportTextureAsync("exporter",N,q);return C?await C.then((async C=>C?await this._exportTextureInfoAsync(C,q):await this._exportTextureInfoAsync(N,q))):await this._exportTextureInfoAsync(N,q)}async _exportTextureInfoAsync(N,q){let C=this._textureMap.get(N);if(!C){const d=await this._getPixelsFromTextureAsync(N);if(!d)return null;const W=this._exportTextureSampler(N),a=N.mimeType;if(a)switch(a){case"image/jpeg":case"image/png":case"image/webp":q=a;break;default:U.Tools.Warn(`Unsupported media type: ${a}. Exporting texture as PNG.`)}const F=this._internalTextureToImage,w=N.getInternalTexture().uniqueId;F[w]||(F[w]={});let A=F[w][q];if(void 0===A){const C=N.getSize();A=(async()=>{const U=await this._getImageDataAsync(d,C.width,C.height,q);return this._exportImage(N.name,q,U)})(),F[w][q]=A}C=this._exportTextureInfo(await A,W,N.coordinatesIndex),this._textureMap.set(N,C),this._exporter._extensionsPostExportTextures("exporter",C,N)}return C}_exportImage(N,q,C){const d=this._exporter._images;let W;if(this._exporter._shouldUseGlb){W={name:N,mimeType:q,bufferView:void 0};const d=this._exporter._bufferManager.createBufferView(new Uint8Array(C));this._exporter._bufferManager.setBufferView(W,d)}else{const a=N.replace(/\.\/|\/|\.\\|\\/g,"_"),F=function(N){switch(N){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(q);let w=a+F;d.some((N=>N.uri===w))&&(w=`${a}_${U.Tools.RandomId()}${F}`),W={name:N,uri:w},this._exporter._imageData[w]={data:C,mimeType:q}}return d.push(W),d.length-1}_exportTextureInfo(N,q,C){const d=this._exporter._textures;let U=d.findIndex((C=>C.sampler==q&&C.source===N));-1===U&&(U=d.length,d.push({source:N,sampler:q}));const W={index:U};return C&&(W.texCoord=C),W}_exportTextureSampler(N){const q=this._getTextureSampler(N),C=this._exporter._samplers,d=C.findIndex((N=>N.minFilter===q.minFilter&&N.magFilter===q.magFilter&&N.wrapS===q.wrapS&&N.wrapT===q.wrapT));return-1!==d?d:(C.push(q),C.length-1)}}var o=C(11210),S=C(10962),D=C(11610),c=C(11129);const L=d.Jq.Zero(),G=d.Quaternion.Identity(),h=d.Jq.One(),B=new d.Jq(-1,1,1);function y(N,q){const{byteOffset:C,byteStride:d,type:U,normalized:W}=N,a=N.getSize(),F=q.reduce(((N,q)=>q.getTotalVertices()>N?q.getTotalVertices():N),-Number.MAX_VALUE);return{byteOffset:C,byteStride:d,componentCount:a,type:U,count:F*a,normalized:W,totalVertices:F,kind:N.getKind()}}function R(N){switch(N){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function u(N){switch(N){case n.g.PositionKind:case n.g.NormalKind:case n.g.TangentKind:case n.g.ColorKind:case n.g.MatricesIndicesKind:case n.g.MatricesIndicesExtraKind:case n.g.MatricesWeightsKind:case n.g.MatricesWeightsExtraKind:case n.g.UVKind:case n.g.UV2Kind:case n.g.UV3Kind:case n.g.UV4Kind:case n.g.UV5Kind:case n.g.UV6Kind:return!0}return!1}function m(N){switch(N){case W.d.TriangleFillMode:return 4;case W.d.TriangleStripDrawMode:return 5;case W.d.TriangleFanDrawMode:return 6;case W.d.PointListDrawMode:case W.d.PointFillMode:return 0;case W.d.LineLoopDrawMode:return 2;case W.d.LineListDrawMode:return 1;case W.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${N}`)}function f(N){const q=Math.sqrt(N.x*N.x+N.y*N.y+N.z*N.z);q>0&&(N.x/=q,N.y/=q,N.z/=q)}function k(N){return N.x*=-1,N}function g(N){if(N.x*N.x+N.y*N.y>.5){const q=Math.abs(N.x),C=Math.abs(N.y);if(q>C){const C=Math.sign(N.x);N.x=q,N.y*=-C,N.z*=-C,N.w*=C}else{const q=Math.sign(N.y);N.x*=-q,N.y=C,N.z*=q,N.w*=-q}}else{const q=Math.abs(N.z),C=Math.abs(N.w);if(q>C){const C=Math.sign(N.z);N.x*=-C,N.y*=C,N.z=q,N.w*=-C}else{const q=Math.sign(N.w);N.x*=q,N.y*=-q,N.z*=-q,N.w=C}}return N}function x(N){N.hd(-N.z,N.w,N.x,-N.y)}function NN(N,q){const C=d.Jq.FromArrayToRef(q.translation||[0,0,0],0,d.TmpVectors.Jq[0]),U=d.Quaternion.FromArrayToRef(q.rotation||[0,0,0,1],0,d.TmpVectors.Quaternion[0]),W=d.Matrix.ComposeToRef(h,U,C,d.TmpVectors.Matrix[0]),a=d.Jq.FromArrayToRef(N.translation||[0,0,0],0,d.TmpVectors.Jq[2]),F=d.Quaternion.FromArrayToRef(N.rotation||[0,0,0,1],0,d.TmpVectors.Quaternion[1]),w=d.Matrix.ComposeToRef(h,F,a,d.TmpVectors.Matrix[1]);W.multiplyToRef(w,w),w.decompose(void 0,U,C),C.equalsWithEpsilon(L,c.e)?delete q.translation:q.translation=C.zd(),U.equalsWithEpsilon(G,c.e)?delete q.rotation:q.rotation=U.zd(),q.scale&&delete q.scale}function qN(N,q){if(!(q instanceof t.b))return!1;if(!(1===q.getChildren().length&&0===N.getChildren().length&&N.parent===q))return!1;const C=N.lN(),d=N instanceof D.d&&!C.useRightHandedSystem?B:h;return!!q.yd.equalsWithEpsilon(d,c.e)||(S.c.Warn(`Cannot collapse node ${N.name} into parent node ${q.name} with modified scaling.`),!1)}function CN(N){if(N instanceof Array){const q=new Float32Array(N);return new Uint8Array(q.buffer,q.byteOffset,q.byteLength)}return ArrayBuffer.isView(N)?new Uint8Array(N.buffer,N.byteOffset,N.byteLength):new Uint8Array(N)}function dN(N,q){for(const[C,d]of Object.entries(N)){const U=q[C];(Array.isArray(d)&&Array.isArray(U)&&UN(d,U)||d===U)&&delete N[C]}return N}function UN(N,q){return N.length===q.length&&N.every(((N,C)=>N===q[C]))}const WN=d.Matrix.Compose(new d.Jq(-1,1,1),d.Quaternion.Identity(),d.Jq.Zero());function aN(N,q){if(!(N instanceof t.b))return!1;if(q){if(!N.getWorldMatrix().equalsWithEpsilon(d.Matrix.IdentityReadOnly,c.e))return!1}else{if(!N.getWorldMatrix().multiplyToRef(WN,d.TmpVectors.Matrix[0]).equalsWithEpsilon(d.Matrix.IdentityReadOnly,c.e))return!1}return!(N instanceof V.d&&N.ed)}const FN=new Map([[Int8Array,(N,q,C)=>N.setInt8(q,C)],[Uint8Array,(N,q,C)=>N.setUint8(q,C)],[Uint8ClampedArray,(N,q,C)=>N.setUint8(q,C)],[Int16Array,(N,q,C)=>N.setInt16(q,C,!0)],[Uint16Array,(N,q,C)=>N.setUint16(q,C,!0)],[Int32Array,(N,q,C)=>N.setInt32(q,C,!0)],[Uint32Array,(N,q,C)=>N.setUint32(q,C,!0)],[Float32Array,(N,q,C)=>N.setFloat32(q,C,!0)],[Float64Array,(N,q,C)=>N.setFloat64(q,C,!0)]]);class wN{writeTypedArray(N){this._checkGrowBuffer(N.byteLength);const q=FN.get(N.constructor);for(let C=0;C<N.length;C++)q(this._dataView,this._byteOffset,N[C]),this._byteOffset+=N.BYTES_PER_ELEMENT}constructor(N){this._data=new Uint8Array(N),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(N){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,N),this._byteOffset++}writeInt8(N){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,N),this._byteOffset++}writeInt16(N){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,N,!0),this._byteOffset+=2}writeUInt16(N){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,N,!0),this._byteOffset+=2}writeInt32(N){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,N,!0),this._byteOffset+=4}writeUInt32(N){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,N,!0),this._byteOffset+=4}writeFloat32(N){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,N,!0),this._byteOffset+=4}writeFloat64(N){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,N,!0),this._byteOffset+=8}_checkGrowBuffer(N){const q=this.byteOffset+N;if(q>this._data.byteLength){const N=new Uint8Array(2*q);N.set(this._data),this._data=N,this._dataView=new DataView(this._data.buffer)}}}function AN(N){return N%4===0?4:N%2===0?2:1}class nN{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(N){let q=0;this._bufferViewToData.forEach((N=>{q+=N.byteLength}));const C=new wN(q),d=Array.from(this._bufferViewToData.keys()).sort(((N,q)=>AN(q.byteLength)-AN(N.byteLength)));for(const U of d){U.byteOffset=C.byteOffset,N.push(U);const q=N.length-1,d=this.getPropertiesWithBufferView(U);for(const N of d)N.bufferView=q;C.writeTypedArray(this._bufferViewToData.get(U)),this._bufferViewToData.delete(U)}return C.getOutputData()}createBufferView(N,q){const C={buffer:0,byteOffset:void 0,byteLength:N.byteLength,byteStride:q};return this._bufferViewToData.set(C,N),C}createAccessor(N,q,C,d,U,W,a){this._verifyBufferView(N);const F={bufferView:void 0,componentType:C,count:d,type:q,min:null===W||void 0===W?void 0:W.min,max:null===W||void 0===W?void 0:W.max,normalized:a,byteOffset:U};return this.setBufferView(F,N),this._accessorToBufferView.set(F,N),F}setBufferView(N,q){this._verifyBufferView(q);this.getPropertiesWithBufferView(q).push(N)}removeBufferView(N){const q=this.getPropertiesWithBufferView(N);for(const C of q)void 0!==C.bufferView&&delete C.bufferView;this._bufferViewToData.delete(N),this._bufferViewToProperties.delete(N),this._accessorToBufferView.forEach(((q,C)=>{q===N&&(void 0!==C.byteOffset&&delete C.byteOffset,this._accessorToBufferView.delete(C))}))}getBufferView(N){const q=this._accessorToBufferView.get(N);return this._verifyBufferView(q),q}getPropertiesWithBufferView(N){return this._verifyBufferView(N),this._bufferViewToProperties.set(N,this._bufferViewToProperties.get(N)??[]),this._bufferViewToProperties.get(N)}getData(N){return this._verifyBufferView(N),this._bufferViewToData.get(N)}_verifyBufferView(N){if(void 0===N||!this._bufferViewToData.has(N))throw new Error(`BufferView ${N} not found in BufferManager.`)}}var tN,VN=C(11578),ZN=C(11590),JN=C(11618),QN=C(11503),vN=C(11645),rN=C(11659),ON=C(11571),KN=C(11666);!function(N){N[N.INTANGENT=0]="INTANGENT",N[N.OUTTANGENT=1]="OUTTANGENT"}(tN||(tN={}));class iN{static _IsTransformable(N){return N&&(N instanceof t.b||N instanceof VN.b||N instanceof KN.c)}static _CreateNodeAnimation(N,q,C,d,W){if(this._IsTransformable(N)){const a=[],F=[],w=q.getKeys(),A=iN._CalculateMinMaxKeyFrames(w),n=iN._DeduceInterpolation(w,C,d),t=n.interpolationType,V=n.shouldBakeAnimation;if(V?iN._CreateBakedAnimation(N,q,C,A.min,A.max,q.framePerSecond,W,a,F,A,d):"LINEAR"===t||"STEP"===t?iN._CreateLinearOrStepAnimation(N,q,C,a,F,d):"CUBICSPLINE"===t?iN._CreateCubicSplineAnimation(N,q,C,a,F,d):iN._CreateBakedAnimation(N,q,C,A.min,A.max,q.framePerSecond,W,a,F,A,d),a.length&&F.length){return{inputs:a,outputs:F,samplerInterpolation:t,inputsMin:V?A.min:U.Tools.FloatRound(A.min/q.framePerSecond),inputsMax:V?A.max:U.Tools.FloatRound(A.max/q.framePerSecond)}}}return null}static _DeduceAnimationInfo(N){let q=null,C="VEC3",d=!1;const W=N.targetProperty.split(".");switch(W[0]){case"yd":q="scale";break;case"position":q="translation";break;case"rotation":C="VEC4",q="rotation";break;case"rotationQuaternion":C="VEC4",d=!0,q="rotation";break;case"influence":C="SCALAR",q="weights";break;default:U.Tools.Error(`Unsupported animatable property ${W[0]}`)}return q?{animationChannelTargetPath:q,dataAccessorType:C,useQuaternion:d}:(U.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(N,q,C,d,U,W,a,F,w,A,n){let t;if(iN._IsTransformable(N)&&N.animations)for(const V of N.animations){if(n&&!n(V))continue;const U=iN._DeduceAnimationInfo(V);U&&(t={name:V.name,samplers:[],channels:[]},iN._AddAnimation(`${V.name}`,V.hasRunningRuntimeAnimations?q:t,N,V,U.dataAccessorType,U.animationChannelTargetPath,d,W,a,F,U.useQuaternion,w,A),t.samplers.length&&t.channels.length&&C.push(t))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(N,q,C,d,U,W,a,F,w,A,n){let t;if(N instanceof ON.b){const U=N.morphTargetManager;if(U)for(let V=0;V<U.numTargets;++V){const Z=U.getTarget(V);for(const J of Z.animations){if(n&&!n(J))continue;const Z=new vN.d(`${J.name}`,"influence",J.framePerSecond,J.dataType,J.loopMode,J.enableBlending),Q=[],v=J.getKeys();for(let N=0;N<v.length;++N){const q=v[N];for(let N=0;N<U.numTargets;++N)N==V?Q.push(q):Q.push({frame:q.frame,value:0})}Z.setKeys(Q);const r=iN._DeduceAnimationInfo(Z);r&&(t={name:Z.name,samplers:[],channels:[]},iN._AddAnimation(J.name,J.hasRunningRuntimeAnimations?q:t,N,Z,r.dataAccessorType,r.animationChannelTargetPath,d,W,a,F,r.useQuaternion,w,A,U.numTargets),t.samplers.length&&t.channels.length&&C.push(t))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(N,q,C,d,U,W,a,F,w){let A;if(N.animationGroups){const t=N.animationGroups;for(const V of t){const t=new Map,Z=new Map,J=new Set,Q=V.to-V.from;A={name:V.name,channels:[],samplers:[]};for(let q=0;q<V.targetedAnimations.length;++q){const Q=V.targetedAnimations[q],v=Q.target,r=Q.animation;if(w&&!w(r))continue;const O=F.has(v);if(this._IsTransformable(v)||1===v.length&&this._IsTransformable(v[0])){const N=iN._DeduceAnimationInfo(Q.animation);if(N){const q=this._IsTransformable(v)?v:this._IsTransformable(v[0])?v[0]:null;q&&iN._AddAnimation(`${r.name}`,A,q,r,N.dataAccessorType,N.animationChannelTargetPath,C,d,U,W,N.useQuaternion,a,O)}}else if(v instanceof rN.d||1===v.length&&v[0]instanceof rN.d){if(iN._DeduceAnimationInfo(Q.animation)){const q=v instanceof rN.d?v:v[0];if(q){const C=N.morphTargetManagers.find((N=>{for(let C=0;C<N.numTargets;++C)if(N.getTarget(C)===q)return!0;return!1}));if(C){const d=N.meshes.find((N=>N.morphTargetManager===C));var n;if(d)t.has(d)||t.set(d,new Map),null===(n=t.get(d))||void 0===n||n.set(q,r),J.add(d),Z.set(d,r)}}}}}J.forEach((N=>{const q=N.morphTargetManager;let F=null;const w=[],n=Z.get(N).getKeys(),J=n.length;for(let C=0;C<J;++C)for(let d=0;d<q.numTargets;++d){const U=q.getTarget(d),W=t.get(N);if(W){const q=W.get(U);q?(F||(F=new vN.d(`${V.name}_${N.name}_MorphWeightAnimation`,"influence",q.framePerSecond,vN.d.ANIMATIONTYPE_FLOAT,q.loopMode,q.enableBlending)),w.push(q.getKeys()[C])):w.push({frame:V.from+Q/J*C,value:U.influence,inTangent:n[0].inTangent?0:void 0,outTangent:n[0].outTangent?0:void 0})}}F.setKeys(w);const v=iN._DeduceAnimationInfo(F);v&&iN._AddAnimation(`${V.name}_${N.name}_MorphWeightAnimation`,A,N,F,v.dataAccessorType,v.animationChannelTargetPath,C,d,U,W,v.useQuaternion,a,!1,null===q||void 0===q?void 0:q.numTargets)})),A.channels.length&&A.samplers.length&&q.push(A)}}}static _AddAnimation(N,q,C,U,W,a,F,w,A,n,t,V,Z,J){const Q=iN._CreateNodeAnimation(C,U,a,t,V);let v,r,O,K,i,I;if(Q){if(J){let N=0,q=0;const C=[];for(;Q.inputs.length>0;)q=Q.inputs.shift(),N%J==0&&C.push(q),N++;Q.inputs=C}const N=F.get(C),U=new Float32Array(Q.inputs);v=w.createBufferView(U),r=w.createAccessor(v,"SCALAR",5126,Q.inputs.length,void 0,{min:[Q.inputsMin],max:[Q.inputsMax]}),n.push(r),O=n.length-1;const A=new d.Quaternion,t=new d.Jq,V=new d.Jq,j=C instanceof VN.b,l=R(W),T=new Float32Array(Q.outputs.length*l);Q.outputs.forEach((function(N,q){let C=N;switch(a){case"translation":Z&&(d.Jq.FromArrayToRef(N,0,V),k(V),V.toArray(C));break;case"rotation":4===N.length?d.Quaternion.FromArrayToRef(N,0,A):(C=new Array(4),d.Jq.FromArrayToRef(N,0,t),d.Quaternion.FromEulerVectorToRef(t,A)),Z&&(g(A),j&&x(A)),A.toArray(C)}T.set(C,q*l)})),v=w.createBufferView(T),r=w.createAccessor(v,W,5126,Q.outputs.length),n.push(r),K=n.length-1,i={interpolation:Q.samplerInterpolation,input:O,output:K},q.samplers.push(i),I={sampler:q.samplers.length-1,target:{node:N,path:a}},q.channels.push(I)}}static _CreateBakedAnimation(N,q,C,W,a,F,w,A,n,t,V){let Z;const J=d.Quaternion.Identity();let Q,v=null,r=null,O=null,K=null,i=null,I=null;t.min=U.Tools.FloatRound(W/F);const j=q.getKeys();for(let d=0,l=j.length;d<l;++d){if(I=null,O=j[d],d+1<l)if(K=j[d+1],O.value.equals&&O.value.equals(K.value)||O.value===K.value){if(0!==d)continue;I=O.frame}else I=K.frame;else{if(i=j[d-1],O.value.equals&&O.value.equals(i.value)||O.value===i.value)continue;I=a}if(I)for(let d=O.frame;d<=I;d+=w){if(Q=U.Tools.FloatRound(d/F),Q===v)continue;v=Q,r=Q;const W={key:0,repeatCount:0,loopMode:q.loopMode};Z=q._interpolate(d,W),iN._SetInterpolatedValue(N,Z,Q,q,C,J,A,n,V)}}r&&(t.max=r)}static _ConvertFactorToVector3OrQuaternion(N,q,C,W,a){const F=iN._GetBasePositionRotationOrScale(q,W,a),w=C.targetProperty.split("."),A=w?w[1]:"",n=a?d.Quaternion.Kq(F).normalize():d.Jq.Kq(F);switch(A){case"x":case"y":case"z":n[A]=N;break;case"w":n.w=N;break;default:U.Tools.Error(`glTFAnimation: Unsupported component name "${A}"!`)}return n}static _SetInterpolatedValue(N,q,C,U,W,a,F,w,A){let n;F.push(C),"weights"!==W?(U.dataType===vN.d.ANIMATIONTYPE_FLOAT&&(q=this._ConvertFactorToVector3OrQuaternion(q,N,U,W,A)),"rotation"===W?(A?a=q:(n=q,d.Quaternion.RotationYawPitchRollToRef(n.y,n.x,n.z,a)),w.push(a.zd())):(n=q,w.push(n.zd()))):w.push([q])}static _CreateLinearOrStepAnimation(N,q,C,d,U,W){for(const a of q.getKeys())d.push(a.frame/q.framePerSecond),iN._AddKeyframeValue(a,q,U,C,N,W)}static _CreateCubicSplineAnimation(N,q,C,d,U,W){q.getKeys().forEach((function(a){d.push(a.frame/q.framePerSecond),iN._AddSplineTangent(tN.INTANGENT,U,C,"CUBICSPLINE",a,W),iN._AddKeyframeValue(a,q,U,C,N,W),iN._AddSplineTangent(tN.OUTTANGENT,U,C,"CUBICSPLINE",a,W)}))}static _GetBasePositionRotationOrScale(N,q,C){let U;if("rotation"===q)if(C){U=(N.rotationQuaternion??d.Quaternion.Identity()).zd()}else{U=(N.rotation??d.Jq.Zero()).zd()}else if("translation"===q){U=(N.position??d.Jq.Zero()).zd()}else{U=(N.yd??d.Jq.One()).zd()}return U}static _AddKeyframeValue(N,q,C,W,a,F){let w;const A=q.dataType;if(A===vN.d.ANIMATIONTYPE_VECTOR3){let q=N.value.zd();if("rotation"===W){const N=d.Jq.Kq(q);q=d.Quaternion.RotationYawPitchRoll(N.y,N.x,N.z).zd()}C.push(q)}else if(A===vN.d.ANIMATIONTYPE_FLOAT){if("weights"===W)C.push([N.value]);else if(w=this._ConvertFactorToVector3OrQuaternion(N.value,a,q,W,F),w){if("rotation"===W){const N=F?w:d.Quaternion.RotationYawPitchRoll(w.y,w.x,w.z).normalize();C.push(N.zd())}C.push(w.zd())}}else A===vN.d.ANIMATIONTYPE_QUATERNION?C.push(N.value.normalize().zd()):U.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(N,q,C){let d,U,W=!1;if("rotation"===q&&!C)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let a=0,F=N.length;a<F;++a)if(U=N[a],U.inTangent||U.outTangent)if(d){if("CUBICSPLINE"!==d){d="LINEAR",W=!0;break}}else d="CUBICSPLINE";else if(d){if("CUBICSPLINE"===d||U.interpolation&&1===U.interpolation&&"STEP"!==d){d="LINEAR",W=!0;break}}else d=U.interpolation&&1===U.interpolation?"STEP":"LINEAR";return d||(d="LINEAR"),{interpolationType:d,shouldBakeAnimation:W}}static _AddSplineTangent(N,q,C,U,W,a){let F;const w=N===tN.INTANGENT?W.inTangent:W.outTangent;if("CUBICSPLINE"===U){if("rotation"===C)if(w)if(a)F=w.zd();else{const N=w;F=d.Quaternion.RotationYawPitchRoll(N.y,N.x,N.z).zd()}else F=[0,0,0,0];else F="weights"===C?w?[w]:[0]:w?w.zd():[0,0,0];q.push(F)}}static _CalculateMinMaxKeyFrames(N){let q=1/0,C=-1/0;return N.forEach((function(N){q=Math.min(q,N.frame),C=Math.max(C,N.frame)})),{min:q,max:C}}}function IN(N,q,C,W,a,F){const w={attributes:{},influence:N.influence,name:N.name},A=q.ed;if(!A)return U.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),w;const t=F?-1:1,V=d.Jq.Zero();let Z=0,J=0;if(N.hasPositions){const W=N.getPositions(),F=A.getVerticesData(n.g.PositionKind);if(F){const N=new Float32Array(F.length),q=[1/0,1/0,1/0],U=[-1/0,-1/0,-1/0];J=F.length/3,Z=0;for(let C=Z;C<J;++C){const a=d.Jq.Kq(F,3*C);d.Jq.Kq(W,3*C).subtractToRef(a,V),V.x*=t,q[0]=Math.min(q[0],V.x),U[0]=Math.max(U[0],V.x),q[1]=Math.min(q[1],V.y),U[1]=Math.max(U[1],V.y),q[2]=Math.min(q[2],V.z),U[2]=Math.max(U[2],V.z),N[3*C]=V.x,N[3*C+1]=V.y,N[3*C+2]=V.z}const A=C.createBufferView(N,12),n=C.createAccessor(A,"VEC3",5126,W.length/3,0,{min:q,max:U});a.push(n),w.attributes.POSITION=a.length-1}else U.Tools.Warn(`Morph target positions for mesh ${q.name} were not exported. Mesh does not have position vertex data`)}if(N.hasNormals){const W=N.getNormals(),F=A.getVerticesData(n.g.NormalKind);if(F){const N=new Float32Array(F.length);J=F.length/3,Z=0;for(let C=Z;C<J;++C){const q=d.Jq.Kq(F,3*C).normalize();d.Jq.Kq(W,3*C).normalize().subtractToRef(q,V),N[3*C]=V.x*t,N[3*C+1]=V.y,N[3*C+2]=V.z}const q=C.createBufferView(N,12),U=C.createAccessor(q,"VEC3",5126,W.length/3,0);a.push(U),w.attributes.NORMAL=a.length-1}else U.Tools.Warn(`Morph target normals for mesh ${q.name} were not exported. Mesh does not have normals vertex data`)}if(N.hasTangents){const W=N.getTangents(),F=A.getVerticesData(n.g.TangentKind);if(F){J=F.length/4;const N=new Float32Array(3*J);Z=0;for(let C=Z;C<J;++C){const q=d.Jq.Kq(F,4*C);f(q);const U=d.Jq.Kq(W,3*C);f(U),U.subtractToRef(q,V),N[3*C]=V.x*t,N[3*C+1]=V.y,N[3*C+2]=V.z}const q=C.createBufferView(N,12),U=C.createAccessor(q,"VEC3",5126,J,0);a.push(U),w.attributes.TANGENT=a.length-1}else U.Tools.Warn(`Morph target tangents for mesh ${q.name} were not exported. Mesh does not have tangents vertex data`)}if(N.hasColors){const W=N.getColors(),F=A.getVerticesData(n.g.ColorKind),t=A.getVertexBuffer(n.g.ColorKind);if(F&&t){const N=t.getSize();J=F.length/N;const q=new Float32Array(J*N);Z=0;for(let C=Z;C<J;++C)if(3===N){const U=d.Jq.Kq(F,C*N);d.Jq.Kq(W,C*N).subtractToRef(U,V),q[3*C]=V.x,q[3*C+1]=V.y,q[3*C+2]=V.z}else if(4===N){const U=new d.Vector4,a=d.Vector4.Kq(F,C*N);d.Vector4.Kq(W,C*N).subtractToRef(a,U),q[4*C]=U.x,q[4*C+1]=U.y,q[4*C+2]=U.z,q[4*C+3]=U.w}else U.Tools.Warn(`Unsupported number of components for color attribute: ${N}`);const A=C.createBufferView(q,4*N),n=C.createAccessor(A,3===N?"VEC3":"VEC4",5126,J,0);a.push(n),w.attributes.COLOR_0=a.length-1}else U.Tools.Warn(`Morph target colors for mesh ${q.name} were not exported. Mesh does not have colors vertex data`)}return w}var jN=C(11674),lN=C(11529),TN=C(11515),zN=C(11076);class pN{}pN.DEFAULT_COLOR=v.Oq.White(),pN.DEFAULT_WIDTH_ATTENUATED=1,pN.DEFAULT_WIDTH=.1;var sN=C(11343),XN=C(11683);class PN{static ConvertPoints(N,q){if(N.length&&Array.isArray(N)&&"number"===typeof N[0])return[N];if(N.length&&Array.isArray(N[0])&&"number"===typeof N[0][0])return N;if(N.length&&!Array.isArray(N[0])&&N[0]instanceof d.Jq){const q=[];for(let C=0;C<N.length;C++){const d=N[C];q.push(d.x,d.y,d.z)}return[q]}if(N.length>0&&Array.isArray(N[0])&&N[0].length>0&&N[0][0]instanceof d.Jq){const q=[],C=N;for(const N of C)q.push(N.flatMap((N=>[N.x,N.y,N.z])));return q}if(N instanceof Float32Array){if(null!==q&&void 0!==q&&q.floatArrayStride){const C=[],d=3*q.floatArrayStride;for(let q=0;q<N.length;q+=d){const U=new Array(d);for(let C=0;C<d;C++)U[C]=N[q+C];C.push(U)}return C}return[Array.from(N)]}if(N.length&&N[0]instanceof Float32Array){const q=[];for(const C of N)q.push(Array.from(C));return q}return[]}static OmitZeroLengthPredicate(N,q,C){const d=[];return q.Qq(N).lengthSquared()>0&&d.push([N,q]),C.Qq(q).lengthSquared()>0&&d.push([q,C]),N.Qq(C).lengthSquared()>0&&d.push([C,N]),0===d.length?null:d}static OmitDuplicatesPredicate(N,q,C,d){const U=[];return PN._SearchInPoints(N,q,d)||U.push([N,q]),PN._SearchInPoints(q,C,d)||U.push([q,C]),PN._SearchInPoints(C,N,d)||U.push([C,N]),0===U.length?null:U}static _SearchInPoints(N,q,C){for(const a of C)for(let C=0;C<a.length;C++){var d,U,W;if(null!==(d=a[C])&&void 0!==d&&d.equals(N))if(null!==(U=a[C+1])&&void 0!==U&&U.equals(q)||null!==(W=a[C-1])&&void 0!==W&&W.equals(q))return!0}return!1}static MeshesToLines(N,q){const C=[];for(let U=0;U<N.length;U++){const W=N[U],a=W.getVerticesData(n.g.PositionKind),F=W.od();if(a&&F)for(let N=0,w=0;N<F.length;N++){const A=3*F[w++],n=3*F[w++],t=3*F[w++],V=new d.Jq(a[A],a[A+1],a[A+2]),Z=new d.Jq(a[n],a[n+1],a[n+2]),J=new d.Jq(a[t],a[t+1],a[t+2]);if(q){const d=q(V,Z,J,C,N,A,W,U,a,F);if(d)for(const N of d)C.push(N)}else C.push([V,Z],[Z,J],[J,V])}}return C}static ToVector3Array(N){if(Array.isArray(N[0])){const q=[],C=N;for(const N of C){const C=[];for(let q=0;q<N.length;q+=3)C.push(new d.Jq(N[q],N[q+1],N[q+2]));q.push(C)}return q}const q=N,C=[];for(let U=0;U<q.length;U+=3)C.push(new d.Jq(q[U],q[U+1],q[U+2]));return C}static ToNumberArray(N){return N.flatMap((N=>[N.x,N.y,N.z]))}static GetPointsCountInfo(N){const q=new Array(N.length);let C=0;for(let d=N.length;d--;)q[d]=N[d].length/3,C+=q[d];return{total:C,counts:q}}static GetLineLength(N){if(0===N.length)return 0;let q;q="number"===typeof N[0]?PN.ToVector3Array(N):N;const C=d.TmpVectors.Jq[0];let U=0;for(let d=0;d<q.length-1;d++){const N=q[d];U+=q[d+1].subtractToRef(N,C).length()}return U}static GetLineLengthArray(N){const q=new Float32Array(N.length/3);let C=0;for(let d=0,U=N.length/3-1;d<U;d++){let U=N[3*d+0],W=N[3*d+1],a=N[3*d+2];U-=N[3*d+3],W-=N[3*d+4],a-=N[3*d+5];C+=Math.sqrt(U*U+W*W+a*a),q[d+1]=C}return q}static SegmentizeSegmentByCount(N,q,C){const U=[],W=q.Qq(N),a=d.TmpVectors.Jq[0];a.Rd(C);const F=d.TmpVectors.Jq[1];W.divideToRef(a,F);let w=N.clone();U.push(w);for(let d=0;d<C;d++)w=w.clone(),U.push(w.addInPlace(F));return U}static SegmentizeLineBySegmentLength(N,q){const C=N[0]instanceof d.Jq?PN.GetLineSegments(N):"number"===typeof N[0]?PN.GetLineSegments(PN.ToVector3Array(N)):N,U=[];for(const d of C)if(d.length>q){const N=PN.SegmentizeSegmentByCount(d.point1,d.point2,Math.ceil(d.length/q));for(const q of N)U.push(q)}else U.push(d.point1),U.push(d.point2);return U}static SegmentizeLineBySegmentCount(N,q){const C="number"===typeof N[0]?PN.ToVector3Array(N):N,d=PN.GetLineLength(C)/q;return PN.SegmentizeLineBySegmentLength(C,d)}static GetLineSegments(N){const q=[];for(let C=0;C<N.length-1;C++){const d=N[C],U=N[C+1],W=U.Qq(d).length();q.push({point1:d,point2:U,length:W})}return q}static GetMinMaxSegmentLength(N){const q=PN.GetLineSegments(N).sort((N=>N.length));return{min:q[0].length,max:q[q.length-1].length}}static GetPositionOnLineByVisibility(N,q,C){let U=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const W=q*C;let a=0,F=0;const w=N.length;for(let d=0;d<w;d++){if(W<=a+N[d].length){F=d;break}a+=N[d].length}const A=(W-a)/N[F].length;return N[F].point2.subtractToRef(N[F].point1,d.TmpVectors.Jq[0]),d.TmpVectors.Jq[1]=d.TmpVectors.Jq[0].multiplyByFloats(A,A,A),U||d.TmpVectors.Jq[1].addInPlace(N[F].point1),d.TmpVectors.Jq[1].clone()}static GetCircleLinePoints(N,q){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N,W=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/q;const a=[];for(let F=0;F<=q;F++)a.push(new d.Jq(Math.cos(F*W)*N,Math.sin(F*W)*U,C));return a}static GetBezierLinePoints(N,q,C,d){return sN.d.CreateQuadraticBezier(N,q,C,d).getPoints().flatMap((N=>[N.x,N.y,N.z]))}static GetArrowCap(N,q,C,d,U){let W=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[N.clone(),N.add(q.multiplyByFloats(C,C,C))],widths:[d,U,W,a]}}static GetPointsFromText(N,q,C,d){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,W=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const a=[],F=(0,XN.e)(N,q,C,d);for(const w of F){for(const N of w.paths){const q=[],C=N.getPoints();for(const N of C)q.push(N.x,N.y,U);a.push(q)}if(W)for(const N of w.holes){const q=[],C=N.getPoints();for(const N of C)q.push(N.x,N.y,U);a.push(q)}}return a}static Color3toRGBAUint8(N){const q=new Uint8Array(4*N.length);for(let C=0,d=0;C<N.length;C++)q[d++]=255*N[C].r,q[d++]=255*N[C].g,q[d++]=255*N[C].b,q[d++]=255;return q}static CreateColorsTexture(N,q,C,d){const U=d.getEngine().getCaps().maxTextureSize??1,W=q.length>U?U:q.length,a=Math.ceil(q.length/U);a>1&&(q=[...q,...Array(W*a-q.length).fill(q[0])]);const F=PN.Color3toRGBAUint8(q),w=new j.d(F,W,a,J.e.TEXTUREFORMAT_RGBA,d,!1,!0,C);return w.name=N,w}static PrepareEmptyColorsTexture(N){if(!pN.EmptyColorsTexture){const q=new Uint8Array(4);pN.EmptyColorsTexture=new j.d(q,1,1,J.e.TEXTUREFORMAT_RGBA,N,!1,!1,j.d.NEAREST_NEAREST),pN.EmptyColorsTexture.name="grlEmptyColorsTexture"}return pN.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var N;null===(N=pN.EmptyColorsTexture)||void 0===N||N.dispose(),pN.EmptyColorsTexture=null}static BooleanToNumber(N){return N?1:0}}class MN extends TN.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class YN extends lN.c{isCompatible(N){return!0}constructor(N,q,C){var U;C=C||{color:pN.DEFAULT_COLOR};const W=new MN;W.GREASED_LINE_HAS_COLOR=!!C.color&&!C.useColors,W.GREASED_LINE_SIZE_ATTENUATION=C.sizeAttenuation??!1,W.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===C.colorDistributionType,W.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(q??N.lN()).useRightHandedSystem,W.GREASED_LINE_CAMERA_FACING=C.cameraFacing??!0,super(N,YN.GREASED_LINE_MATERIAL_NAME,200,W,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(U=C)||void 0===U?void 0:U.forceGLSL)||YN.ForceGLSL,this._scene=q??N.lN(),this._engine=this._scene.getEngine(),this._cameraFacing=C.cameraFacing??!0,this.visibility=C.visibility??1,this.useDash=C.useDash??!1,this.dashRatio=C.dashRatio??.5,this.dashOffset=C.dashOffset??0,this.width=C.width?C.width:C.sizeAttenuation?pN.DEFAULT_WIDTH_ATTENUATED:pN.DEFAULT_WIDTH,this._sizeAttenuation=C.sizeAttenuation??!1,this.colorMode=C.colorMode??0,this._color=C.color??null,this.useColors=C.useColors??!1,this._colorsDistributionType=C.colorDistributionType??0,this.colorsSampling=C.colorsSampling??j.d.NEAREST_NEAREST,this._colors=C.sN??null,this.dashCount=C.dashCount??1,this.resolution=C.resolution??new d.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),C.colorsTexture?this.colorsTexture=C.colorsTexture:this._colors?this.colorsTexture=PN.CreateColorsTexture(`${N.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??pN.DEFAULT_COLOR,PN.PrepareEmptyColorsTexture(this._scene)),this._engine.td.add((()=>{PN.DisposeEmptyColorsTexture()}))}getAttributes(N){N.push("grl_offsets"),N.push("grl_widths"),N.push("grl_colorPointers"),N.push("grl_counters"),this._cameraFacing?(N.push("grl_previousAndSide"),N.push("grl_nextAndCounters")):N.push("grl_slopes")}getSamplers(N){N.push("grl_colors")}getActiveTextures(N){this.colorsTexture&&N.push(this.colorsTexture)}getUniforms(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const q=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&q.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===N&&q.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:q,vertex:this._cameraFacing&&this._isGLSL(N)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(N)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(N){if(this._cameraFacing){N.Yd("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||N.Yd("viewProjection",this._scene.getTransformMatrix());const q=d.TmpVectors.Vector4[0];q.x=this._aspect,q.y=this._resolution.x,q.z=this._resolution.y,q.w=this.width,N.updateVector4("grl_aspect_resolution_lineWidth",q)}const q=d.TmpVectors.Vector4[0];q.x=PN.BooleanToNumber(this.useDash),q.y=this._dashArray,q.z=this.dashOffset,q.w=this.dashRatio,N.updateVector4("grl_dashOptions",q);const C=d.TmpVectors.Vector4[1];C.x=this.colorMode,C.y=this.visibility,C.z=this.colorsTexture?this.colorsTexture.getSize().width:0,C.w=PN.BooleanToNumber(this.useColors),N.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",C),this._color&&N.updateColor3("grl_singleColor",this._color);const U=this.colorsTexture??pN.EmptyColorsTexture;N.setTexture("grl_colors",U),N.updateFloat2("grl_textureSize",(null===U||void 0===U?void 0:U.getSize().width)??1,(null===U||void 0===U?void 0:U.getSize().height)??1)}prepareDefines(N,q,C){N.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,N.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,N.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,N.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=q.useRightHandedSystem,N.GREASED_LINE_CAMERA_FACING=this._cameraFacing,N.GREASED_LINE_USE_OFFSETS=!!C.offsets}getClassName(){return YN.GREASED_LINE_MATERIAL_NAME}getCustomCode(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(q)?function(N,q){if("vertex"===N){const N={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return q&&(N["!gl_Position\\=viewProjection\\*worldPos;"]="//"),N}return"fragment"===N?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(N,this._cameraFacing):function(N,q){if("vertex"===N){const N={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return q&&(N["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),N}return"fragment"===N?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(N,this._cameraFacing)}dispose(){var N;null===(N=this.colorsTexture)||void 0===N||N.dispose(),super.dispose()}get sN(){return this._colors}set sN(N){this.setColors(N)}setColors(N){var q;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],d=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const U=(null===(q=this._colors)||void 0===q?void 0:q.length)??0;var W;if(this._colors=N,null!==N&&0!==N.length){if(!C||d)if(this.colorsTexture&&U===N.length&&!d){const q=PN.Color3toRGBAUint8(N);this.colorsTexture.update(q)}else{var a;null===(a=this.colorsTexture)||void 0===a||a.dispose(),this.colorsTexture=PN.CreateColorsTexture(`${this._material.name}-colors-texture`,N,this.colorsSampling,this._scene)}}else null===(W=this.colorsTexture)||void 0===W||W.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(N){this._dashCount=N,this._dashArray=1/N}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(N){this._sizeAttenuation=N,this.markAllDefinesAsDirty()}get color(){return this._color}set color(N){this.setColor(N)}setColor(N){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==N||null!==this._color&&null===N?(this._color=N,q||this.markAllDefinesAsDirty()):this._color=N}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(N){this._colorsDistributionType=N,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(N){this._aspect=N.x/N.y,this._resolution=N}serialize(){const N=super.serialize(),q={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(q.sN=this._colors),this._color&&(q.color=this._color),N.greasedLineMaterialOptions=q,N}parse(N,q,C){var d;super.parse(N,q,C);const U=N.greasedLineMaterialOptions;null===(d=this.colorsTexture)||void 0===d||d.dispose(),U.color&&this.setColor(U.color,!0),U.colorDistributionType&&(this.colorsDistributionType=U.colorDistributionType),U.sN&&(this.sN=U.sN),U.colorsSampling&&(this.colorsSampling=U.colorsSampling),U.colorMode&&(this.colorMode=U.colorMode),U.useColors&&(this.useColors=U.useColors),U.visibility&&(this.visibility=U.visibility),U.useDash&&(this.useDash=U.useDash),U.dashCount&&(this.dashCount=U.dashCount),U.dashRatio&&(this.dashRatio=U.dashRatio),U.dashOffset&&(this.dashOffset=U.dashOffset),U.width&&(this.width=U.width),U.sizeAttenuation&&(this.sizeAttenuation=U.sizeAttenuation),U.resolution&&(this.resolution=U.resolution),this.sN?this.colorsTexture=PN.CreateColorsTexture(`${this._material.name}-colors-texture`,this.sN,this.colorsSampling,q):PN.PrepareEmptyColorsTexture(q),this.markAllDefinesAsDirty()}copyTo(N){var q;const C=N;null===(q=C.colorsTexture)||void 0===q||q.dispose(),this._colors&&(C.colorsTexture=PN.CreateColorsTexture(`${C._material.name}-colors-texture`,this._colors,C.colorsSampling,this._scene)),C.setColor(this.color,!0),C.colorsDistributionType=this.colorsDistributionType,C.colorsSampling=this.colorsSampling,C.colorMode=this.colorMode,C.useColors=this.useColors,C.visibility=this.visibility,C.useDash=this.useDash,C.dashCount=this.dashCount,C.dashRatio=this.dashRatio,C.dashOffset=this.dashOffset,C.width=this.width,C.sizeAttenuation=this.sizeAttenuation,C.resolution=this.resolution,C.markAllDefinesAsDirty()}_isGLSL(N){return 0===N||this._forceGLSL}}YN.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",YN.ForceGLSL=!1,(0,zN.h)(`BABYLON.${YN.GREASED_LINE_MATERIAL_NAME}`,YN);var EN=C(11561),HN=C(10971),eN=C(11361),bN=C(11063);class oN extends eN.ShaderMaterial{constructor(N,q,U){const W=q.getEngine(),a=W.isWebGPU&&!(U.forceGLSL||oN.ForceGLSL),F=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];q.useRightHandedSystem&&F.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const w=["position","grl_widths","grl_offsets","grl_colorPointers"];U.cameraFacing?(F.push("GREASED_LINE_CAMERA_FACING"),w.push("grl_previousAndSide","grl_nextAndCounters")):(w.push("grl_slopes"),w.push("grl_counters"));const A=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(a||A.push("world","viewProjection","view","projection"),super(N,q,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:a?["Scene","Mesh"]:void 0,attributes:w,uniforms:A,samplers:a?[]:["grlColors"],defines:F,extraInitializationsAsync:async()=>{a?await Promise.all([C.e(66).then(C.bind(C,14235)),C.e(75).then(C.bind(C,14243))]):await Promise.all([C.e(69).then(C.bind(C,14249)),C.e(76).then(C.bind(C,14257))])},shaderLanguage:a?1:0}),this._color=v.Oq.White(),this._colorsDistributionType=0,this._colorsTexture=null,U=U||{color:pN.DEFAULT_COLOR},this.visibility=U.visibility??1,this.useDash=U.useDash??!1,this.dashRatio=U.dashRatio??.5,this.dashOffset=U.dashOffset??0,this.dashCount=U.dashCount??1,this.width=U.width?U.width:U.sizeAttenuation&&U.cameraFacing?pN.DEFAULT_WIDTH_ATTENUATED:pN.DEFAULT_WIDTH,this.sizeAttenuation=U.sizeAttenuation??!1,this.color=U.color??v.Oq.White(),this.useColors=U.useColors??!1,this.colorsDistributionType=U.colorDistributionType??0,this.colorsSampling=U.colorsSampling??j.d.NEAREST_NEAREST,this.colorMode=U.colorMode??0,this._colors=U.sN??null,this._cameraFacing=U.cameraFacing??!0,this.resolution=U.resolution??new d.Vector2(W.getRenderWidth(),W.getRenderHeight()),U.colorsTexture?this.colorsTexture=U.colorsTexture:this._colors?this.colorsTexture=PN.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,q):(this._color=this._color??pN.DEFAULT_COLOR,this.colorsTexture=PN.PrepareEmptyColorsTexture(q)),a){const N=new bN.d;N.setParameters(),N.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",N)}W.td.add((()=>{PN.DisposeEmptyColorsTexture()}))}dispose(){var N;null===(N=this._colorsTexture)||void 0===N||N.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new d.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get sN(){return this._colors}set sN(N){this.setColors(N)}setColors(N){var q;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],d=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const U=(null===(q=this._colors)||void 0===q?void 0:q.length)??0;var W;if(this._colors=N,null!==N&&0!==N.length){if(!C||d)if(this._colorsTexture&&U===N.length&&!d){const q=PN.Color3toRGBAUint8(N);this._colorsTexture.update(q)}else{var a;null===(a=this._colorsTexture)||void 0===a||a.dispose(),this.colorsTexture=PN.CreateColorsTexture(`${this.name}-colors-texture`,N,this.colorsSampling,this.lN())}}else null===(W=this._colorsTexture)||void 0===W||W.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(N){this._colorsTexture=N,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(N){this._width=N,this.setFloat("grlWidth",N)}get useColors(){return this._useColors}set useColors(N){this._useColors=N,this.setFloat("grlUseColors",PN.BooleanToNumber(N))}get colorsSampling(){return this._colorsSampling}set colorsSampling(N){this._colorsSampling=N}get visibility(){return this._visibility}set visibility(N){this._visibility=N,this.setFloat("grlVisibility",N)}get useDash(){return this._useDash}set useDash(N){this._useDash=N,this.setFloat("grlUseDash",PN.BooleanToNumber(N))}get dashOffset(){return this._dashOffset}set dashOffset(N){this._dashOffset=N,this.setFloat("grlDashOffset",N)}get dashRatio(){return this._dashRatio}set dashRatio(N){this._dashRatio=N,this.setFloat("grlDashRatio",N)}get dashCount(){return this._dashCount}set dashCount(N){this._dashCount=N,this._dashArray=1/N,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(N){this._sizeAttenuation=N,this.setFloat("grlSizeAttenuation",PN.BooleanToNumber(N))}get color(){return this._color}set color(N){this.setColor(N)}setColor(N){N=N??pN.DEFAULT_COLOR,this._color=N,this.setColor3("grlColor",N)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(N){this._colorsDistributionType=N,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(N){this._colorMode=N,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(N){this._resolution=N,this.setVector2("grlResolution",N),this.setFloat("grlAspect",N.x/N.y)}serialize(){const N=super.serialize(),q={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(q.sN=this._colors),N.greasedLineMaterialOptions=q,N}parse(N,q,C){var d;const U=N.greasedLineMaterialOptions;null===(d=this._colorsTexture)||void 0===d||d.dispose(),U.color&&(this.color=U.color),U.colorDistributionType&&(this.colorsDistributionType=U.colorDistributionType),U.colorsSampling&&(this.colorsSampling=U.colorsSampling),U.colorMode&&(this.colorMode=U.colorMode),U.useColors&&(this.useColors=U.useColors),U.visibility&&(this.visibility=U.visibility),U.useDash&&(this.useDash=U.useDash),U.dashCount&&(this.dashCount=U.dashCount),U.dashRatio&&(this.dashRatio=U.dashRatio),U.dashOffset&&(this.dashOffset=U.dashOffset),U.width&&(this.width=U.width),U.sizeAttenuation&&(this.sizeAttenuation=U.sizeAttenuation),U.resolution&&(this.resolution=U.resolution),U.sN?this.colorsTexture=PN.CreateColorsTexture(`${this.name}-colors-texture`,U.sN,this.colorsSampling,this.lN()):this.colorsTexture=PN.PrepareEmptyColorsTexture(q),this._cameraFacing=U.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var SN,DN,cN;oN.ForceGLSL=!1,function(N){N[N.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",N[N.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(SN||(SN={})),function(N){N[N.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",N[N.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",N[N.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(DN||(DN={})),function(N){N[N.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",N[N.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",N[N.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",N[N.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",N[N.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(cN||(cN={}));class LN extends ON.b{constructor(N,q,C){super(N,q,null,null,!1,!1),this.name=N,this._options=C,this._lazy=!1,this._updatable=!1,this._engine=q.getEngine(),this._lazy=C.lazy??!1,this._updatable=C.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=C.colorPointers??[],this._widths=C.widths??new Array(C.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(N){let q=0;for(const d of this._points)q+=d.length;const C=q/3*2-this._widths.length;for(let d=0;d<C;d++)this._widths.push(N)}updateLazy(){var N,q;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(N=this._options.ribbonOptions)||void 0===N?void 0:N.smoothShading),!this.YN&&this.refreshBoundingInfo(),null===(q=this.greasedLineMaterial)||void 0===q||q.updateLazy()}addPoints(N,q){for(const C of N)this._points.push(C);this._lazy||this.setPoints(this._points,q)}dispose(N){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(N,q)}isLazy(){return this._lazy}get XN(){return this._uvs}set XN(N){this._uvs=N instanceof Float32Array?N:new Float32Array(N),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(N){this.material instanceof oN&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===N||void 0===N?void 0:N.length)>0),this._offsets=N,this._offsetsBuffer?this._offsetsBuffer.update(N):this._createOffsetsBuffer(N)}get widths(){return this._widths}set widths(N){this._widths=N,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(N)}get colorPointers(){return this._colorPointers}set colorPointers(N){this._colorPointers=N,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(N)}get greasedLineMaterial(){var N,q;if(this.material&&this.material instanceof oN)return this.material;const C=null===(N=this.material)||void 0===N||null===(q=N.pluginManager)||void 0===q?void 0:q.getPlugin(YN.GREASED_LINE_MATERIAL_NAME);return C||void 0}get points(){const N=[];return HN.b.DeepCopy(this._points,N),N}setPoints(N,q){this._points=PN.ConvertPoints(N,(null===q||void 0===q?void 0:q.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==q&&void 0!==q&&q.colorPointers||this._updateColorPointers(),this._setPoints(this._points,q)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,XN:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(N){super.serialize(N),N.type=this.getClassName(),N.lineOptions=this._createLineOptions()}_createVertexBuffers(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const q=new EN.c;return q.zN=this._vertexPositions,q.indices=this._indices,q.XN=this._uvs,N&&(q.pN=[],EN.c.ComputeNormals(this._vertexPositions,this._indices,q.pN)),q.MN(this,this._options.updatable),q}_createOffsetsBuffer(N){const q=this._scene.getEngine(),C=new n.c(q,N,this._updatable,3);this.setVerticesBuffer(C.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=C}}class GN{constructor(N,q){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=N,this.wasAddedByNoopNode=q}getIndicesAccessor(N,q,C,d,U){var W,a,F,w;return null===(W=this._indicesAccessorMap.get(N))||void 0===W||null===(a=W.get(q))||void 0===a||null===(F=a.get(C))||void 0===F||null===(w=F.get(d))||void 0===w?void 0:w.get(U)}setIndicesAccessor(N,q,C,d,U,W){let a=this._indicesAccessorMap.get(N);a||(a=new Map,this._indicesAccessorMap.set(N,a));let F=a.get(q);F||(F=new Map,a.set(q,F));let w=F.get(C);w||(w=new Map,F.set(C,w));let A=w.get(d);A||(A=new Map,w.set(d,A)),A.set(U,W)}pushExportedNode(N){this._exportedNodes.has(N)||this._exportedNodes.add(N)}getNodesSet(){return this._exportedNodes}getVertexBufferView(N){return this._vertexBufferViewMap.get(N)}setVertexBufferView(N,q){this._vertexBufferViewMap.set(N,q)}setRemappedBufferView(N,q,C){this._remappedBufferView.set(N,new Map),this._remappedBufferView.get(N).set(q,C)}getRemappedBufferView(N,q){var C;return null===(C=this._remappedBufferView.get(N))||void 0===C?void 0:C.get(q)}getVertexAccessor(N,q,C){var d,U;return null===(d=this._vertexAccessorMap.get(N))||void 0===d||null===(U=d.get(q))||void 0===U?void 0:U.get(C)}setVertexAccessor(N,q,C,d){let U=this._vertexAccessorMap.get(N);U||(U=new Map,this._vertexAccessorMap.set(N,U));let W=U.get(q);W||(W=new Map,U.set(q,W)),W.set(C,d)}hasVertexColorAlpha(N){return this._vertexMapColorAlpha.get(N)||!1}setHasVertexColorAlpha(N,q){return this._vertexMapColorAlpha.set(N,q)}getMesh(N){return this._meshMap.get(N)}setMesh(N,q){this._meshMap.set(N,q)}bindMorphDataToMesh(N,q){const C=this._meshMorphTargetMap.get(N)||[];this._meshMorphTargetMap.set(N,C),-1===C.indexOf(q)&&C.push(q)}getMorphTargetsFromMesh(N){return this._meshMorphTargetMap.get(N)}}class hN{_ApplyExtension(N,q,C,d){if(C>=q.length)return Promise.resolve(N);const U=d(q[C],N);return U?U.then((async N=>N?await this._ApplyExtension(N,q,C+1,d):null)):this._ApplyExtension(N,q,C+1,d)}_ApplyExtensions(N,q){const C=[];for(const d of hN._ExtensionNames)C.push(this._extensions[d]);return this._ApplyExtension(N,C,0,q)}_extensionsPreExportTextureAsync(N,q,C){return this._ApplyExtensions(q,((q,d)=>q.preExportTextureAsync&&q.preExportTextureAsync(N,d,C)))}_extensionsPostExportNodeAsync(N,q,C,d,U){return this._ApplyExtensions(q,((q,W)=>q.postExportNodeAsync&&q.postExportNodeAsync(N,W,C,d,U,this._bufferManager)))}_extensionsPostExportMaterialAsync(N,q,C){return this._ApplyExtensions(q,((q,d)=>q.postExportMaterialAsync&&q.postExportMaterialAsync(N,d,C)))}_extensionsPostExportMaterialAdditionalTextures(N,q,C){const d=[];for(const U of hN._ExtensionNames){const W=this._extensions[U];W.postExportMaterialAdditionalTextures&&d.push(...W.postExportMaterialAdditionalTextures(N,q,C))}return d}_extensionsPostExportTextures(N,q,C){for(const d of hN._ExtensionNames){const U=this._extensions[d];U.postExportTexture&&U.postExportTexture(N,q,C)}}_extensionsPostExportMeshPrimitive(N){for(const q of hN._ExtensionNames){const C=this._extensions[q];C.postExportMeshPrimitive&&C.postExportMeshPrimitive(N,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const N of hN._ExtensionNames){const q=this._extensions[N];q.preGenerateBinaryAsync&&await q.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(N){for(const q of hN._ExtensionNames){const C=this._extensions[q];C.enabled&&N(C)}}_extensionsOnExporting(){this._forEachExtensions((N=>{var q,C,d;N.wasUsed&&((q=this._glTF).extensionsUsed||(q.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(N.name)&&this._glTF.extensionsUsed.push(N.name),N.required&&((C=this._glTF).extensionsRequired||(C.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(N.name)&&this._glTF.extensionsRequired.push(N.name)),(d=this._glTF).extensions||(d.extensions={}),N.onExporting&&N.onExporting())}))}_loadExtensions(){for(const N of hN._ExtensionNames){const q=hN._ExtensionFactories[N](this);this._extensions[N]=q}}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Q.e.LastCreatedScene,q=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${J.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new b(this),this._extensions={},this._bufferManager=new nN,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!N)throw new Error("No scene available to export");this._babylonScene=N,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:N=>{var q;return null===N||void 0===N||null===(q=N.vd)||void 0===q?void 0:q.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...q},this._loadExtensions()}dispose(){for(const N in this._extensions){this._extensions[N].dispose()}}get options(){return this._options}static RegisterExtension(N,q){hN.UnregisterExtension(N)&&U.Tools.Warn(`Extension with the name ${N} already exists`),hN._ExtensionFactories[N]=q,hN._ExtensionNames.push(N)}static UnregisterExtension(N){if(!hN._ExtensionFactories[N])return!1;delete hN._ExtensionFactories[N];const q=hN._ExtensionNames.indexOf(N);return-1!==q&&hN._ExtensionNames.splice(q,1),!0}_generateJSON(N,q,C){const d={byteLength:N};return d.byteLength&&(this._glTF.buffers=[d]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.vq=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(d.uri=q+".bin"),C?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(N){const q=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(q.byteLength,N,!0),d=new Blob([q],{type:"application/octet-stream"}),U=N+".gltf",W=N+".bin",a=new A;if(a.files[U]=C,a.files[W]=d,this._imageData)for(const F in this._imageData)a.files[F]=new Blob([this._imageData[F].data],{type:this._imageData[F].mimeType});return a}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(N){const q=N%4;return 0===q?q:4-q}async generateGLBAsync(N){this._shouldUseGlb=!0;const q=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(q.byteLength),d=N+".glb";let U,W=C.length;if("undefined"!==typeof TextEncoder){U=(new TextEncoder).encode(C),W=U.length}const a=this._getPadding(W),F=this._getPadding(q.byteLength),w=28+W+a+q.byteLength+F,n=new wN(w);if(n.writeUInt32(1179937895),n.writeUInt32(2),n.writeUInt32(w),n.writeUInt32(W+a),n.writeUInt32(1313821514),U)n.writeTypedArray(U);else{const N="_".charCodeAt(0);for(let q=0;q<W;++q){const d=C.charCodeAt(q);d!=C.codePointAt(q)?n.writeUInt8(N):n.writeUInt8(d)}}for(let A=0;A<a;++A)n.writeUInt8(32);n.writeUInt32(q.byteLength+F),n.writeUInt32(5130562),n.writeTypedArray(q);for(let A=0;A<F;++A)n.writeUInt8(0);const t=new A;return t.files[d]=new Blob([n.getOutputData()],{type:"application/octet-stream"}),t}_setNodeTransformation(N,q,C){if(q.getPivotPoint().equalsWithEpsilon(L,c.e)||U.Tools.Warn("Pivot points are not supported in the glTF serializer"),!q.position.equalsWithEpsilon(L,c.e)){const U=d.TmpVectors.Jq[0].U(q.position);C&&k(U),N.translation=U.zd()}q.yd.equalsWithEpsilon(h,c.e)||(N.scale=q.yd.zd());const W=q.rotationQuaternion||d.Quaternion.FromEulerAngles(q.rotation.x,q.rotation.y,q.rotation.z);W.equalsWithEpsilon(G,c.e)||(C&&g(W),N.rotation=W.normalize().zd())}_setCameraTransformation(N,q,C){if(!q.position.equalsWithEpsilon(L,c.e)){const U=d.TmpVectors.Jq[0].U(q.position);C&&k(U),N.translation=U.zd()}const U=q.rotationQuaternion||d.Quaternion.FromEulerAngles(q.rotation.x,q.rotation.y,q.rotation.z);C&&g(U),this._babylonScene.useRightHandedSystem||x(U),U.equalsWithEpsilon(G,c.e)||(N.rotation=U.zd())}_listAvailableCameras(){for(const N of this._babylonScene.cameras){const q={type:N.mode===VN.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(N.name&&(q.name=N.name),"perspective"===q.type)q.perspective={aspectRatio:N.getEngine().getAspectRatio(N),yfov:N.fovMode===VN.b.FOVMODE_VERTICAL_FIXED?N.fov:N.fov*N.getEngine().getAspectRatio(N),znear:N.sd,zfar:N.maxZ};else if("orthographic"===q.type){const C=N.orthoLeft&&N.orthoRight?.5*(N.orthoRight-N.orthoLeft):.5*N.getEngine().getRenderWidth(),d=N.orthoBottom&&N.orthoTop?.5*(N.orthoTop-N.orthoBottom):.5*N.getEngine().getRenderHeight();q.orthographic={xmag:C,ymag:d,znear:N.sd,zfar:N.maxZ}}this._camerasMap.set(N,q)}}_exportAndAssignCameras(){const N=Array.from(this._camerasMap.values());for(const q of N){const N=this._nodesCameraMap.get(q);if(void 0!==N){this._cameras.push(q);for(const q of N)q.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const N of this._babylonScene.skeletons){if(N.bones.length<=0)continue;const q={joints:[]};this._skinMap.set(N,q)}}_exportAndAssignSkeletons(){for(const N of this._babylonScene.skeletons){if(N.bones.length<=0)continue;const q=this._skinMap.get(N);if(void 0==q)continue;const C={},d=[];let W=-1;for(let U=0;U<N.bones.length;++U){const q=N.bones[U],d=q.getIndex()??U;-1!==d&&(C[d]=q,d>W&&(W=d))}for(let N=0;N<=W;++N){const W=C[N];d.push(W.getAbsoluteInverseBindMatrix());const a=W.getTransformNode();if(null!==a){const N=this._nodeMap.get(a);a&&null!==N&&void 0!==N?q.joints.push(N):U.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else U.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const a=this._nodesSkinMap.get(q);if(q.joints.length>0&&void 0!==a){const N=64*d.length,C=new Float32Array(N/4);d.forEach(((N,q)=>{C.set(N.m,16*q)}));const U=this._bufferManager.createBufferView(C);this._accessors.push(this._bufferManager.createAccessor(U,"MAT4",5126,d.length)),q.inverseBindMatrices=this._accessors.length-1,this._skins.push(q);for(const q of a)q.skin=this._skins.length-1}}}async _exportSceneAsync(){const N={nodes:[]};if(this._babylonScene.metadata){const q=this._options.metadataSelector(this._babylonScene.metadata);q&&(N.extras=q)}const q=new Array,C=new Array,d=new Array;for(const F of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&aN(F,this._babylonScene.useRightHandedSystem)?d.push(...F.getChildren()):this._babylonScene.useRightHandedSystem?q.push(F):C.push(F);this._listAvailableCameras(),this._listAvailableSkeletons();const U=new GN(!0,!1);N.nodes.push(...await this._exportNodesAsync(C,U));const W=new GN(!1,!1);N.nodes.push(...await this._exportNodesAsync(q,W));const a=new GN(!1,!0);N.nodes.push(...await this._exportNodesAsync(d,a)),N.nodes.length&&this._scenes.push(N),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&iN._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,U.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(N){let q=this._shouldExportNodeMap.get(N);return void 0===q&&(q=this._options.shouldExportNode(N),this._shouldExportNodeMap.set(N,q)),q}async _exportNodesAsync(N,q){const C=new Array;this._exportBuffers(N,q);for(const d of N)await this._exportNodeAsync(d,C,q);return C}_collectBuffers(N,q,C,d,U){if(this._shouldExportNode(N)&&N instanceof V.d&&N.ed){const W=N.ed.getVertexBuffers();if(W)for(const d in W){if(!u(d))continue;const a=W[d];U.setHasVertexColorAlpha(a,N.hasVertexAlpha);const F=a._buffer,w=q.get(F)||[];q.set(F,w),-1===w.indexOf(a)&&w.push(a);const A=C.get(a)||[];C.set(a,A),-1===A.indexOf(N)&&A.push(N)}const a=N.morphTargetManager;if(a)for(let q=0;q<a.numTargets;q++){const C=a.getTarget(q),U=d.get(C)||[];d.set(C,U),-1===U.indexOf(N)&&U.push(N)}}for(const W of N.getChildren())this._collectBuffers(W,q,C,d,U)}_exportBuffers(N,q){const C=new Map,d=new Map,U=new Map;for(const F of N)this._collectBuffers(F,C,d,U,q);const W=Array.from(C.keys());for(const F of W){const N=F.getData();if(!N)throw new Error("Buffer data is not available");const U=C.get(F);if(!U)continue;const W=U[0].byteStride;if(U.some((N=>N.byteStride!==W)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const a=CN(N).slice();for(const q of U){const N=d.get(q),{byteOffset:C,byteStride:U,componentCount:W,type:F,count:w,normalized:A,kind:t}=y(q,N);switch(t){case n.g.NormalKind:case n.g.TangentKind:(0,o.i)(a,C,U,W,F,w,A,(N=>{const q=Math.sqrt(N[0]*N[0]+N[1]*N[1]+N[2]*N[2]);if(q>0){const C=1/q;N[0]*=C,N[1]*=C,N[2]*=C}}));break;case n.g.ColorKind:{const q=N.filter((N=>N.material instanceof QN.rq||null==N.material)).length;if(0==q)break;if(q!=N.length){S.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}F==n.g.UNSIGNED_BYTE&&S.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const d=new v.Oq,t=new v.md,V=this._babylonScene.getEngine().useExactSrgbConversions;(0,o.i)(a,C,U,W,F,w,A,(N=>{3===N.length?(d.JC(N,0),d.toLinearSpaceToRef(d,V),d.toArray(N,0)):(t.JC(N,0),t.toLinearSpaceToRef(t,V),t.toArray(N,0))}))}}}if(q.convertToRightHanded){for(const N of U){const q=d.get(N),{byteOffset:C,byteStride:U,componentCount:W,type:F,count:w,normalized:A,kind:t}=y(N,q);switch(t){case n.g.PositionKind:case n.g.NormalKind:case n.g.TangentKind:(0,o.i)(a,C,U,W,F,w,A,(N=>{N[0]=-N[0]}))}}q.convertedToRightHandedBuffers.set(F,a)}const w=this._bufferManager.createBufferView(a,W);q.setVertexBufferView(F,w);const A=new Map;for(const q of U){const N=d.get(q),{kind:C,totalVertices:U}=y(q,N);switch(C){case n.g.MatricesIndicesKind:case n.g.MatricesIndicesExtraKind:if(q.type==n.g.FLOAT){const N=q.getFloatData(U);null!==N&&A.set(q,N)}}}0!==A.size&&S.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const t=Array.from(A.keys());for(const C of t){const N=A.get(C);if(!N)continue;const d=N.some((N=>N>=256)),U=new(d?Uint16Array:Uint8Array)(N.length);for(let q=0;q<N.length;q++)U[q]=N[q];const W=this._bufferManager.createBufferView(U,4*(d?2:1));q.setRemappedBufferView(F,C,W)}}const a=Array.from(U.keys());for(const F of a){const N=U.get(F);if(!N)continue;const C=IN(F,N[0],this._bufferManager,this._bufferViews,this._accessors,q.convertToRightHanded);for(const d of N)q.bindMorphDataToMesh(d,C)}}async _exportNodeAsync(N,q,C){let d=this._nodeMap.get(N);if(void 0!==d)return void(q.includes(d)||q.push(d));const U=await this._createNodeAsync(N,C);if(U){d=this._nodes.length,this._nodes.push(U),this._nodeMap.set(N,d),C.pushExportedNode(N),q.push(d);const W={name:"runtime animations",channels:[],samplers:[]},a=[];this._babylonScene.animationGroups.length||(iN._CreateMorphTargetAnimationFromMorphTargetAnimations(N,W,a,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation),N.animations.length&&iN._CreateNodeAnimationFromNodeAnimations(N,W,a,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation)),W.channels.length&&W.samplers.length&&this._animations.push(W),a.forEach((N=>{N.channels.length&&N.samplers.length&&this._animations.push(N)}))}const W=U?[]:q;for(const a of N.getChildren())await this._exportNodeAsync(a,W,C);U&&W.length&&(U.children=W)}async _createNodeAsync(N,q){if(!this._shouldExportNode(N))return null;const C={};if(N.name&&(C.name=N.name),N.metadata){const q=this._options.metadataSelector(N.metadata);q&&(C.extras=q)}if(N instanceof t.b&&(this._setNodeTransformation(C,N,q.convertToRightHanded),N instanceof V.d)){const U=N instanceof Z.c?N.sourceMesh:N;if(U.jd&&U.jd.length>0&&(C.mesh=await this._exportMeshAsync(U,q)),N.skeleton){const q=this._skinMap.get(N.skeleton);var d;if(void 0!==q)void 0===this._nodesSkinMap.get(q)&&this._nodesSkinMap.set(q,[]),null===(d=this._nodesSkinMap.get(q))||void 0===d||d.push(C)}}if(N instanceof D.d){const d=this._camerasMap.get(N);if(d){var U;void 0===this._nodesCameraMap.get(d)&&this._nodesCameraMap.set(d,[]),this._setCameraTransformation(C,N,q.convertToRightHanded);const a=N.parent;if(null!==a&&qN(N,a)){const N=this._nodeMap.get(a);if(void 0!==N){var W;const q=this._nodes[N];return NN(C,q),null===(W=this._nodesCameraMap.get(d))||void 0===W||W.push(q),null}}null===(U=this._nodesCameraMap.get(d))||void 0===U||U.push(C)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",C,N,this._nodeMap,q.convertToRightHanded)?C:(S.c.Warn(`Not exporting node ${N.name}`),null)}_exportIndices(N,q,C,d,U,a,F,w,A){let n=N;A.mode=m(a);const t=F!==W.d.CounterClockWiseSideOrientation,V=!w.wasAddedByNoopNode&&t,Z=function(N){switch(N){case W.d.TriangleFillMode:case W.d.TriangleStripDrawMode:case W.d.TriangleFanDrawMode:return!0}return!1}(a)&&V;if(Z){if(a===W.d.TriangleStripDrawMode||a===W.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");A.mode=m(a);const F=q?new Uint32Array(d):new Uint16Array(d);if(N)for(let q=0;q+2<d;q+=3)F[q]=N[C+q]+U,F[q+1]=N[C+q+2]+U,F[q+2]=N[C+q+1]+U;else for(let N=0;N+2<d;N+=3)F[N]=N,F[N+1]=N+2,F[N+2]=N+1;n=F}else if(N&&0!==U){const W=q?new Uint32Array(d):new Uint16Array(d);for(let q=0;q<d;q++)W[q]=N[C+q]+U;n=W}if(n){let W=w.getIndicesAccessor(N,C,d,U,Z);if(void 0===W){const a=function(N,q,C,d){if(N instanceof Uint16Array||N instanceof Uint32Array)return N;if(N instanceof Int32Array)return new Uint32Array(N.buffer,N.byteOffset,N.length);const U=N.slice(q,q+C);return d?new Uint32Array(U):new Uint16Array(U)}(n,0,d,q),F=this._bufferManager.createBufferView(a),A=q?5125:5123;this._accessors.push(this._bufferManager.createAccessor(F,"SCALAR",A,d,0)),W=this._accessors.length-1,w.setIndicesAccessor(N,C,d,U,Z,W)}A.indices=W}}_exportVertexBuffer(N,q,C,d,U,W){const a=N.getKind();if(!u(a))return;if(a.startsWith("uv")&&!this._options.exportUnusedUVs&&(!q||!this._materialNeedsUVsSet.has(q)))return;let F=U.getVertexAccessor(N,C,d);if(void 0===F){const q=U.convertedToRightHandedBuffers.get(N._buffer)||N._buffer.getData(),W=a===n.g.PositionKind?function(N,q,C,d){const{byteOffset:U,byteStride:W,type:a,normalized:F}=q,w=q.getSize(),A=new Array(w).fill(1/0),n=new Array(w).fill(-1/0);return(0,o.i)(N,U+C*W,W,w,a,d*w,F,(N=>{for(let q=0;q<w;q++)A[q]=Math.min(A[q],N[q]),n[q]=Math.max(n[q],N[q])})),{min:A,max:n}}(q,N,C,d):void 0,w=(a===n.g.MatricesIndicesKind||a===n.g.MatricesIndicesExtraKind)&&N.type===n.g.FLOAT,A=w?n.g.UNSIGNED_BYTE:N.type,t=w?void 0:N.normalized,V=w?U.getRemappedBufferView(N._buffer,N):U.getVertexBufferView(N._buffer),Z=N.byteOffset+C*N.byteStride;this._accessors.push(this._bufferManager.createAccessor(V,function(N,q){if(N==n.g.ColorKind)return q?"VEC4":"VEC3";switch(N){case n.g.PositionKind:case n.g.NormalKind:return"VEC3";case n.g.TangentKind:case n.g.MatricesIndicesKind:case n.g.MatricesIndicesExtraKind:case n.g.MatricesWeightsKind:case n.g.MatricesWeightsExtraKind:return"VEC4";case n.g.UVKind:case n.g.UV2Kind:case n.g.UV3Kind:case n.g.UV4Kind:case n.g.UV5Kind:case n.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${N}`)}(a,U.hasVertexColorAlpha(N)),A,d,Z,W,t)),F=this._accessors.length-1,U.setVertexAccessor(N,C,d,F)}W.attributes[function(N){switch(N){case n.g.PositionKind:return"POSITION";case n.g.NormalKind:return"NORMAL";case n.g.TangentKind:return"TANGENT";case n.g.ColorKind:return"COLOR_0";case n.g.UVKind:return"TEXCOORD_0";case n.g.UV2Kind:return"TEXCOORD_1";case n.g.UV3Kind:return"TEXCOORD_2";case n.g.UV4Kind:return"TEXCOORD_3";case n.g.UV5Kind:return"TEXCOORD_4";case n.g.UV6Kind:return"TEXCOORD_5";case n.g.MatricesIndicesKind:return"JOINTS_0";case n.g.MatricesIndicesExtraKind:return"JOINTS_1";case n.g.MatricesWeightsKind:return"WEIGHTS_0";case n.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${N}`)}(a)]=F}async _exportMaterialAsync(N,q,C,d){let U=this._materialMap.get(N);if(void 0===U){const d=q&&Object.keys(q).some((N=>N.startsWith("uv")));if((N=N instanceof ZN.d?N.gd[C.materialIndex]:N)instanceof JN.c)U=await this._materialExporter.exportPBRMaterialAsync(N,"image/png",d);else{if(!(N instanceof QN.rq))return void S.c.Warn(`Unsupported material '${N.name}' with type ${N.getClassName()}`);U=await this._materialExporter.exportStandardMaterialAsync(N,"image/png",d)}this._materialMap.set(N,U)}d.material=U}async _exportMeshAsync(N,q){var C;let d=q.getMesh(N);if(void 0!==d)return d;const U={primitives:[]};d=this._meshes.length,this._meshes.push(U),q.setMesh(N,d);const a=N.isUnIndexed?null:N.od(),F=null===(C=N.ed)||void 0===C?void 0:C.getVertexBuffers(),w=q.getMorphTargetsFromMesh(N),A=N instanceof jN.e,n=N instanceof LN,t=N.jd;if(F&&t&&t.length>0)for(const J of t){const C={attributes:{}},d=J.bN()||this._babylonScene.defaultMaterial;if(n){var V,Z;const q={name:d.name},U=N,W=v.Oq.White(),a=(null===(V=U.material)||void 0===V?void 0:V.alpha)??1,F=(null===(Z=U.greasedLineMaterial)||void 0===Z?void 0:Z.color)??W;(!F.equalsWithEpsilon(W,c.e)||a<1)&&(q.pbrMetallicRoughness={baseColorFactor:[...F.zd(),a]}),this._materials.push(q),C.material=this._materials.length-1}else if(A){const q={name:d.name},U=N;(!U.color.equalsWithEpsilon(v.Oq.White(),c.e)||U.alpha<1)&&(q.pbrMetallicRoughness={baseColorFactor:[...U.color.zd(),U.alpha]}),this._materials.push(q),C.material=this._materials.length-1}else await this._exportMaterialAsync(d,F,J,C);const t=A||n?W.d.LineListDrawMode:N.overrideRenderingFillMode??d.fillMode,Q=d._getEffectiveOrientation(N);this._exportIndices(a,a?(0,o.c)(a,J.indexCount,J.indexStart,J.verticesStart):J.verticesCount>65535,a?J.indexStart:J.verticesStart,a?J.indexCount:J.verticesCount,-J.verticesStart,t,Q,q,C);for(const N of Object.values(F))this._exportVertexBuffer(N,d,J.verticesStart,J.verticesCount,q,C);if(w){C.targets=[];for(const N of w)C.targets.push(N.attributes)}U.primitives.push(C),this._extensionsPostExportMeshPrimitive(C)}if(w){U.weights=[],U.extras||(U.extras={}),U.extras.targetNames=[];for(const N of w)U.weights.push(N.influence),U.extras.targetNames.push(N.name)}return d}}hN._ExtensionNames=new Array,hN._ExtensionFactories={};class BN{static async GLTFAsync(N,q,C){C&&C.exportWithoutWaitingForScene||await N.whenReadyAsync();const d=new hN(N,C),U=await d.generateGLTFAsync(q.replace(/\.[^/.]+$/,""));return d.dispose(),U}static async GLBAsync(N,q,C){C&&C.exportWithoutWaitingForScene||await N.whenReadyAsync();const d=new hN(N,C),U=await d.generateGLBAsync(q.replace(/\.[^/.]+$/,""));return d.dispose(),U}}C(11691);const yN="EXT_mesh_gpu_instancing";class RN{constructor(N){this.name=yN,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(N,q,C,U,W,a){return await new Promise((N=>{if(q&&C instanceof ON.b&&C.hasThinInstances&&this._exporter){this._wasUsed=!0;const N=d.Jq.Zero(),U=d.Quaternion.Identity(),F=d.Jq.One(),w=C.thinInstanceGetWorldMatrices(),A=d.TmpVectors.Jq[2],n=d.TmpVectors.Quaternion[1],t=d.TmpVectors.Jq[3];let V=!1,Z=!1,J=!1;const Q=new Float32Array(3*C.xd),v=new Float32Array(4*C.xd),r=new Float32Array(3*C.xd);let O=0;for(const q of w)q.decompose(t,n,A),W&&(k(A),g(n)),Q.set(A.zd(),3*O),v.set(n.normalize().zd(),4*O),r.set(t.zd(),3*O),V=V||!A.equalsWithEpsilon(N),Z=Z||!n.equalsWithEpsilon(U),J=J||!t.equalsWithEpsilon(F),O++;const K={attributes:{}};V&&(K.attributes.TRANSLATION=this._buildAccessor(Q,"VEC3",C.xd,a)),Z&&(K.attributes.ROTATION=this._buildAccessor(v,"VEC4",C.xd,a)),J&&(K.attributes.SCALE=this._buildAccessor(r,"VEC3",C.xd,a)),q.extensions=q.extensions||{},q.extensions[yN]=K}N(q)}))}_buildAccessor(N,q,C,d){const U=d.createBufferView(N),W=d.createAccessor(U,q,5126,C);return this._exporter._accessors.push(W),this._exporter._accessors.length-1}}hN.RegisterExtension(yN,(N=>new RN(N)));var uN=C(11696),mN=C(11702),fN=C(11708),kN=C(11715);function gN(N){return N===fN.b.PositionKind?"POSITION":N===fN.b.NormalKind?"NORMAL":N===fN.b.ColorKind?"COLOR":N.startsWith(fN.b.UVKind)?"TEX_COORD":"GENERIC"}const xN={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Nq extends uN.b{static get DefaultAvailable(){return(0,uN.f)(Nq.DefaultConfiguration)}static get Default(){return Nq._Default??(Nq._Default=new Nq),Nq._Default}static ResetDefault(N){Nq._Default&&(N||Nq._Default.dispose(),Nq._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(N,q){return{module:await(q||DracoEncoderModule)({wasmBinary:N})}}_getWorkerContent(){return`${mN.f}(${mN.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Nq.DefaultConfiguration)}async _encodeAsync(N,q,C){const d=C?(0,kN.d)(xN,C):xN;if(this._workerPoolPromise){const C=await this._workerPoolPromise;return await new Promise(((U,W)=>{C.push(((C,a)=>{const F=N=>{C.removeEventListener("error",F),C.removeEventListener("message",w),W(N),a()},w=N=>{"encodeMeshDone"===N.data.id&&(C.removeEventListener("error",F),C.removeEventListener("message",w),U(N.data.encodedMeshData),a())};C.addEventListener("error",F),C.addEventListener("message",w);const A=[];for(const q of N)A.push(q.data.buffer);q&&A.push(q.buffer),C.postMessage({id:"encodeMesh",attributes:N,indices:q,options:d},A)}))}))}if(this._modulePromise){const C=await this._modulePromise;return(0,mN.f)(C.module,N,q,d)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(N,q){if(0==N.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");N instanceof ON.b&&N.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===q||void 0===q?void 0:q.method)&&(S.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),q.method="MESH_SEQUENTIAL_ENCODING");const C=function(N){let q=N.od(void 0,!0);return!q||q instanceof Uint32Array||q instanceof Uint16Array||(q=((0,o.c)(q,q.length)?Uint32Array:Uint16Array).from(q)),q}(N),d=function(N,q){const C=[];for(const d of N.getVerticesDataKinds()){if(null!==q&&void 0!==q&&q.includes(d)){if(d===fN.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const U=N.getVertexBuffer(d),W=U.getSize(),a=(0,o.s)(U.getData(),W,U.type,U.byteOffset,U.byteStride,U.normalized,N.getTotalVertices(),!0);C.push({kind:d,dracoName:gN(d),size:W,data:a})}return C}(N,null===q||void 0===q?void 0:q.excludedAttributes);return await this._encodeAsync(d,C,q)}}Nq.DefaultConfiguration={wasmUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder.js`},Nq._Default=null;const qq="KHR_draco_mesh_compression";class Cq{get wasUsed(){return this._wasUsed}constructor(N){this.name=qq,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===N.options.meshCompressionMethod&&Nq.DefaultAvailable}dispose(){}postExportMeshPrimitive(N,q,C){if(!this.enabled)return;if(4!==N.mode&&5!==N.mode)return void S.c.Warn("Cannot compress primitive with mode "+N.mode+".");const d=[],U=[];let W=null;if(void 0!==N.indices){const a=C[N.indices],F=q.getBufferView(a);W=q.getData(F).slice(),d.push(F),U.push(a)}const a=[];for(const[n,t]of Object.entries(N.attributes)){const N=C[t],W=q.getBufferView(N),w=R(N.type),A=(0,o.s)(q.getData(W),w,N.componentType,N.byteOffset||0,W.byteStride||(0,o.o)(N.componentType)*w,N.normalized||!1,N.count,!0);a.push({kind:n,dracoName:(F=n,"POSITION"===F?"POSITION":"NORMAL"===F?"NORMAL":F.startsWith("COLOR")?"COLOR":F.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:R(N.type),data:A}),d.push(W),U.push(N)}var F;const w={method:N.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},A=Nq.Default._encodeAsync(a,W,w).then((C=>{if(!C)return void S.c.Error("Draco encoding failed for primitive.");const W={bufferView:-1,attributes:C.attributeIds},a=q.createBufferView(C.data);q.setBufferView(W,a);for(const N of d)this._bufferViewsUsed.add(N);for(const N of U)this._accessorsUsed.add(N);N.extensions||(N.extensions={}),N.extensions[qq]=W})).catch((N=>{S.c.Error("Draco encoding failed for primitive: "+N)}));this._encodePromises.push(A),this._wasUsed=!0}async preGenerateBinaryAsync(N){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((q=>{N.getPropertiesWithBufferView(q).every((N=>this._accessorsUsed.has(N)))&&N.removeBufferView(q)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}hN.RegisterExtension(qq,(N=>new Cq(N)));var dq=C(11721);const Uq="KHR_lights_punctual",Wq={name:"",color:[1,1,1],OF:1,range:Number.MAX_VALUE},aq={innerConeAngle:0,outerConeAngle:Math.PI/4},Fq=d.Jq.Backward();class wq{constructor(N){this.name=Uq,this.enabled=!0,this.required=!1,this._exporter=N}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Uq]=this._lights}async postExportNodeAsync(N,q,C,U,W){return await new Promise((a=>{if(!(C instanceof KN.c))return void a(q);const F=C.getTypeID()==KN.c.LIGHTTYPEID_POINTLIGHT?"point":C.getTypeID()==KN.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":C.getTypeID()==KN.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!F||!(C instanceof dq.d))return S.c.Warn(`${N}: Light ${C.name} is not supported in ${Uq}`),void a(q);if(C.falloffType!==KN.c.FALLOFF_GLTF&&S.c.Warn(`${N}: Light falloff for ${C.name} does not match the ${Uq} specification!`),!C.position.equalsToFloats(0,0,0)){const N=d.TmpVectors.Jq[0].U(C.position);W&&k(N),q.translation=N.zd()}if("point"!==F){const N=C.direction.normalizeToRef(d.TmpVectors.Jq[0]);W&&k(N);const U=d.Quaternion.FromUnitVectorsToRef(Fq,N,d.TmpVectors.Quaternion[0]);d.Quaternion.IsIdentity(U)||(q.rotation=U.zd())}const w={type:F,name:C.name,color:C.KF.zd(),OF:C.OF,range:C.range};if(dN(w,Wq),"spot"===F){const N=C;w.spot={innerConeAngle:N.innerAngle/2,outerConeAngle:N.angle/2},dN(w.spot,aq)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(w);const A={Cd:this._lights.lights.length-1},n=C.parent;if(n&&qN(C,n)){const N=U.get(n);if(N){const C=this._exporter._nodes[N];return NN(q,C),C.extensions||(C.extensions={}),C.extensions[Uq]=A,void a(null)}}q.extensions||(q.extensions={}),q.extensions[Uq]=A,a(q)}))}}hN.RegisterExtension(Uq,(N=>new wq(N)));var Aq=C(11631);const nq="KHR_materials_anisotropy";class tq{constructor(N){this.name=nq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,q,C){const d=[];return C instanceof Aq.d&&C.anisotropy.isEnabled&&!C.anisotropy.legacy?(C.anisotropy.texture&&d.push(C.anisotropy.texture),d):[]}postExportMaterialAsync(N,q,C){return new Promise((N=>{if(C instanceof Aq.d){if(!C.anisotropy.isEnabled||C.anisotropy.legacy)return void N(q);this._wasUsed=!0,q.extensions=q.extensions||{};const d=this._exporter._materialExporter.getTextureInfo(C.anisotropy.texture),U={anisotropyStrength:C.anisotropy.OF,anisotropyRotation:C.anisotropy.angle,anisotropyTexture:d??void 0};null!==U.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(C),q.extensions[nq]=U}N(q)}))}}hN.RegisterExtension(nq,(N=>new tq(N)));const Vq="KHR_materials_clearcoat";class Zq{constructor(N){this.name=Vq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,q,C){const d=[];return C instanceof Aq.d&&C.clearCoat.isEnabled?(C.clearCoat.texture&&d.push(C.clearCoat.texture),!C.clearCoat.useRoughnessFromMainTexture&&C.clearCoat.textureRoughness&&d.push(C.clearCoat.textureRoughness),C.clearCoat.bumpTexture&&d.push(C.clearCoat.bumpTexture),d):[]}postExportMaterialAsync(N,q,C){return new Promise((N=>{if(C instanceof Aq.d){if(!C.clearCoat.isEnabled)return void N(q);this._wasUsed=!0,q.extensions=q.extensions||{};const d=this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture);let W;W=C.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(C.clearCoat.textureRoughness),C.clearCoat.isTintEnabled&&U.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${C.name}`),C.clearCoat.remapF0OnInterfaceChange&&U.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${C.name}`);const a=this._exporter._materialExporter.getTextureInfo(C.clearCoat.bumpTexture),F={clearcoatFactor:C.clearCoat.OF,clearcoatTexture:d??void 0,clearcoatRoughnessFactor:C.clearCoat.roughness,clearcoatRoughnessTexture:W??void 0,clearcoatNormalTexture:a??void 0};null===F.clearcoatTexture&&null===F.clearcoatRoughnessTexture&&null===F.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),q.extensions[Vq]=F}N(q)}))}}hN.RegisterExtension(Vq,(N=>new Zq(N)));const Jq="KHR_materials_diffuse_transmission";function Qq(N,q){const C=q.subSurface;let d=null;return C.translucencyIntensityTexture?d=C.translucencyIntensityTexture:C.thicknessTexture&&C.useMaskFromThicknessTexture&&(d=C.thicknessTexture),d&&!C.useGltfStyleTextures?(S.c.Warn(`${N}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${q.name}`,1),null):d}class vq{constructor(N){this.name=Jq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,q,C){const d=[];if(C instanceof JN.c&&this._isExtensionEnabled(C)){const q=Qq(N,C);return q&&d.push(q),C.subSurface.translucencyColorTexture&&d.push(C.subSurface.translucencyColorTexture),d}return d}_isExtensionEnabled(N){if(N.unlit)return!1;const q=N.subSurface;return!!q.isTranslucencyEnabled&&(!N.unlit&&!q.useAlbedoToTintTranslucency&&q.useGltfStyleTextures&&1===q.volumeIndexOfRefraction&&0===q.minimumThickness&&0===q.maximumThickness)}postExportMaterialAsync(N,q,C){return new Promise((d=>{if(C instanceof JN.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const d=C.subSurface,U=Qq(N,C),W=0==d.translucencyIntensity?void 0:d.translucencyIntensity,a=this._exporter._materialExporter.getTextureInfo(U)??void 0,F=!d.translucencyColor||d.translucencyColor.equalsFloats(1,1,1)?void 0:d.translucencyColor.zd(),w=this._exporter._materialExporter.getTextureInfo(d.translucencyColorTexture)??void 0,A={diffuseTransmissionFactor:W,diffuseTransmissionTexture:a,diffuseTransmissionColorFactor:F,diffuseTransmissionColorTexture:w};(a||w)&&this._exporter._materialNeedsUVsSet.add(C),q.extensions=q.extensions||{},q.extensions[Jq]=A}d(q)}))}}hN.RegisterExtension(Jq,(N=>new vq(N)));const rq="KHR_materials_dispersion";class Oq{constructor(){this.name=rq,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(N){if(N.unlit)return!1;const q=N.subSurface;return!(!q.isRefractionEnabled&&!q.isDispersionEnabled)}postExportMaterialAsync(N,q,C){return new Promise((N=>{if(C instanceof JN.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const N={dispersion:C.subSurface.dispersion};q.extensions=q.extensions||{},q.extensions[rq]=N}N(q)}))}}hN.RegisterExtension(rq,(()=>new Oq));const Kq="KHR_materials_emissive_strength";class iq{constructor(){this.name=Kq,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(N,q,C){return await new Promise((N=>{if(!(C instanceof JN.c))return N(q);const d=C.emissiveColor.zd(),U=Math.max(...d);if(U>1){this._wasUsed=!0,q.extensions||(q.extensions={});const N={emissiveStrength:U},d=C.emissiveColor.scale(1/N.emissiveStrength);q.emissiveFactor=d.zd(),q.extensions[Kq]=N}return N(q)}))}}hN.RegisterExtension(Kq,(N=>new iq));const Iq="KHR_materials_ior";class jq{constructor(){this.name=Iq,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(N){return!N.unlit&&(void 0!=N.indexOfRefraction&&1.5!=N.indexOfRefraction)}postExportMaterialAsync(N,q,C){return new Promise((N=>{if(C instanceof JN.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const N={ior:C.indexOfRefraction};q.extensions=q.extensions||{},q.extensions[Iq]=N}N(q)}))}}hN.RegisterExtension(Iq,(N=>new jq));const lq="KHR_materials_iridescence";class Tq{constructor(N){this.name=lq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,q,C){const d=[];return C instanceof Aq.d&&C.iridescence.isEnabled?(C.iridescence.texture&&d.push(C.iridescence.texture),C.iridescence.thicknessTexture&&C.iridescence.thicknessTexture!==C.iridescence.texture&&d.push(C.iridescence.thicknessTexture),d):[]}postExportMaterialAsync(N,q,C){return new Promise((N=>{if(C instanceof Aq.d){if(!C.iridescence.isEnabled)return void N(q);this._wasUsed=!0,q.extensions=q.extensions||{};const d=this._exporter._materialExporter.getTextureInfo(C.iridescence.texture),U=this._exporter._materialExporter.getTextureInfo(C.iridescence.thicknessTexture),W={iridescenceFactor:C.iridescence.OF,iridescenceIor:C.iridescence.indexOfRefraction,iridescenceThicknessMinimum:C.iridescence.minimumThickness,iridescenceThicknessMaximum:C.iridescence.maximumThickness,iridescenceTexture:d??void 0,iridescenceThicknessTexture:U??void 0};null===W.iridescenceTexture&&null===W.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(C),q.extensions[lq]=W}N(q)}))}}hN.RegisterExtension(lq,(N=>new Tq(N)));const zq="KHR_materials_sheen";class pq{constructor(N){this.name=zq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,q,C){return C instanceof JN.c&&C.sheen.isEnabled&&C.sheen.texture?[C.sheen.texture]:[]}async postExportMaterialAsync(N,q,C){return await new Promise((N=>{if(C instanceof JN.c){if(!C.sheen.isEnabled)return void N(q);this._wasUsed=!0,null==q.extensions&&(q.extensions={});const d={sheenColorFactor:C.sheen.color.zd(),sheenRoughnessFactor:C.sheen.roughness??0};null===d.sheenColorTexture&&null===d.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),C.sheen.texture&&(d.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),C.sheen.textureRoughness&&!C.sheen.useRoughnessFromMainTexture?d.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.textureRoughness)??void 0:C.sheen.texture&&C.sheen.useRoughnessFromMainTexture&&(d.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),q.extensions[zq]=d}N(q)}))}}hN.RegisterExtension(zq,(N=>new pq(N)));const sq="KHR_materials_specular";class Xq{constructor(N){this.name=sq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,q,C){const d=[];return C instanceof JN.c&&this._isExtensionEnabled(C)?(C.metallicReflectanceTexture&&d.push(C.metallicReflectanceTexture),C.reflectanceTexture&&d.push(C.reflectanceTexture),d):d}_isExtensionEnabled(N){return!N.unlit&&(void 0!=N.metallicF0Factor&&1!=N.metallicF0Factor||void 0!=N.metallicReflectanceColor&&!N.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(N))}_hasTexturesExtension(N){return null!=N.metallicReflectanceTexture||null!=N.reflectanceTexture}postExportMaterialAsync(N,q,C){return new Promise((N=>{if(C instanceof JN.c&&this._isExtensionEnabled(C)){this._wasUsed=!0,q.extensions=q.extensions||{};const N=this._exporter._materialExporter.getTextureInfo(C.metallicReflectanceTexture)??void 0,d=this._exporter._materialExporter.getTextureInfo(C.reflectanceTexture)??void 0,U={specularFactor:1==C.metallicF0Factor?void 0:C.metallicF0Factor,specularTexture:N,specularColorFactor:C.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:C.metallicReflectanceColor.zd(),specularColorTexture:d};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),q.extensions[sq]=U}N(q)}))}}hN.RegisterExtension(sq,(N=>new Xq(N)));const Pq="KHR_materials_transmission";class Mq{constructor(N){this.name=Pq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,q,C){const d=[];return C instanceof JN.c&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&d.push(C.subSurface.thicknessTexture),d):d}_isExtensionEnabled(N){if(N.unlit)return!1;const q=N.subSurface;return q.isRefractionEnabled&&void 0!=q.refractionIntensity&&0!=q.refractionIntensity||this._hasTexturesExtension(N)}_hasTexturesExtension(N){return null!=N.subSurface.refractionIntensityTexture}async postExportMaterialAsync(N,q,C){if(C instanceof JN.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const d=C.subSurface,U={transmissionFactor:0===d.refractionIntensity?void 0:d.refractionIntensity};if(this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),d.refractionIntensityTexture)if(d.useGltfStyleTextures){const N=await this._exporter._materialExporter.exportTextureAsync(d.refractionIntensityTexture,"image/png");N&&(U.transmissionTexture=N)}else S.c.Warn(`${N}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);q.extensions||(q.extensions={}),q.extensions[Pq]=U}return q}}hN.RegisterExtension(Pq,(N=>new Mq(N)));const Yq="KHR_materials_unlit";class Eq{constructor(){this.name=Yq,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(N,q,C){return new Promise((N=>{let d=!1;C instanceof JN.c?d=C.unlit:C instanceof QN.rq&&(d=C.disableLighting),d&&(this._wasUsed=!0,null==q.extensions&&(q.extensions={}),q.extensions[Yq]={}),N(q)}))}}hN.RegisterExtension(Yq,(()=>new Eq));const Hq="KHR_materials_volume";class eq{constructor(N){this.name=Hq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,q,C){const d=[];return C instanceof JN.c&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&d.push(C.subSurface.thicknessTexture),d):d}_isExtensionEnabled(N){if(N.unlit)return!1;const q=N.subSurface;return!(!q.isRefractionEnabled&&!q.isTranslucencyEnabled)&&(void 0!=q.maximumThickness&&0!=q.maximumThickness||void 0!=q.tintColorAtDistance&&q.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=q.tintColor&&q.tintColor!=v.Oq.White()||this._hasTexturesExtension(N))}_hasTexturesExtension(N){return null!=N.subSurface.thicknessTexture}postExportMaterialAsync(N,q,C){return new Promise((N=>{if(C instanceof JN.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const N=C.subSurface,d={thicknessFactor:0==N.maximumThickness?void 0:N.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(N.thicknessTexture)??void 0,attenuationDistance:N.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:N.tintColorAtDistance,attenuationColor:N.tintColor.equalsFloats(1,1,1)?void 0:N.tintColor.zd()};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),q.extensions=q.extensions||{},q.extensions[Hq]=d}N(q)}))}}hN.RegisterExtension(Hq,(N=>new eq(N)));const bq="EXT_materials_diffuse_roughness";class oq{constructor(N){this.name=bq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,q,C){const d=[];return C instanceof Aq.d&&C._baseDiffuseRoughness?(C._baseDiffuseRoughnessTexture&&d.push(C._baseDiffuseRoughnessTexture),d):[]}postExportMaterialAsync(N,q,C){return new Promise((N=>{if(C instanceof Aq.d){if(!C._baseDiffuseRoughness)return void N(q);this._wasUsed=!0,q.extensions=q.extensions||{};const d=this._exporter._materialExporter.getTextureInfo(C._baseDiffuseRoughnessTexture),U={diffuseRoughnessFactor:C._baseDiffuseRoughness,diffuseRoughnessTexture:d??void 0};null!==U.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(C),q.extensions[bq]=U}N(q)}))}}hN.RegisterExtension(bq,(N=>new oq(N)));const Sq="KHR_texture_transform";class Dq{constructor(){this.name=Sq,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(N,q,C){if(C.lN()||U.Tools.Warn(`${N}: /*@__KEY__*/"scene" is not defined for Babylon texture ${C.name}!`),(0!==C.uAng||0!==C.vAng)&&(U.Tools.Warn(`${N}: Texture ${C.name} with rotation in the u or v axis is not supported in glTF.`),0!==C.uRotationCenter||0!==C.vRotationCenter))return;const d={};let W=!1;if(0===C.uOffset&&0===C.vOffset||(d.offset=[C.uOffset,C.vOffset],W=!0),1===C.uScale&&1===C.vScale||(d.scale=[C.uScale,C.vScale],W=!0),0!==C.wAng){if(0!==C.uRotationCenter||0!==C.vRotationCenter){if(C.homogeneousRotationInUVTransform&&C.uScale!==C.vScale)return void U.Tools.Warn(`${N}: Texture ${C.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Sq}.`);U.Tools.Warn(`${N}: Texture ${C.name} with non-origin rotation center will be exported using an adjusted offset with ${Sq}.`),d.offset=function(N){const{uOffset:q,vOffset:C,uRotationCenter:d,vRotationCenter:U,uScale:W,vScale:a,wAng:F}=N,w=Math.cos(F),A=Math.sin(F),n=d*W,t=U*a;return[q+(n*(1-w)+t*A),C+(t*(1-w)-n*A)]}(C)}d.rotation=-C.wAng,W=!0}0!==C.coordinatesIndex&&(d.texCoord=C.coordinatesIndex,W=!0),W&&(this._wasUsed=!0,q.extensions||(q.extensions={}),q.extensions[Sq]=d)}}hN.RegisterExtension(Sq,(()=>new Dq));class cq{static CreateSTL(N){let q=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",U=arguments.length>3&&void 0!==arguments[3]&&arguments[3],W=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],F=arguments.length>6&&void 0!==arguments[6]&&arguments[6],w=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const A=function(N,q,C){const U=[3*N[C],3*N[C+1],3*N[C+2]],W=[new d.Jq(q[U[0]],q[U[0]+2],q[U[0]+1]),new d.Jq(q[U[1]],q[U[1]+2],q[U[1]+1]),new d.Jq(q[U[2]],q[U[2]+2],q[U[2]+1])],a=W[0].Qq(W[1]),F=W[2].Qq(W[1]);return{v:W,n:d.Jq.Cross(F,a).normalize()}},t=function(N,q,C,d){return q=V(N,q,C.x,d),q=V(N,q,C.y,d),V(N,q,C.z,d)},V=function(N,q,C,d){return N.setFloat32(q,C,d),q+4},J=function(N){if(F){let q=N;N instanceof Z.c&&(q=N.sourceMesh);const C=q.getVerticesData(n.g.PositionKind,!0,!0);if(!C)return[];const U=d.Jq.Zero();let W;for(W=0;W<C.length;W+=3)d.Jq.TransformCoordinatesFromFloatsToRef(C[W],C[W+1],C[W+2],N.Ed(!0),U).toArray(C,W);return C}return N.getVerticesData(n.g.PositionKind)||[]};F&&(a=!0);let Q="",v=0,r=0;if(U){for(let C=0;C<N.length;C++){const q=N[C].od();v+=q?q.length/3:0}const q=new ArrayBuffer(84+50*v);Q=new DataView(q),r+=80,Q.setUint32(r,v,W),r+=4}else w||(Q="solid stlmesh\r\n");for(let d=0;d<N.length;d++){const q=N[d];!U&&w&&(Q+="solid "+q.name+"\r\n"),!a&&q instanceof ON.b&&q.bakeCurrentTransformIntoVertices();const C=J(q),F=q.od()||[];for(let N=0;N<F.length;N+=3){const q=A(F,C,N);U?(r=t(Q,r,q.n,W),r=t(Q,r,q.v[0],W),r=t(Q,r,q.v[1],W),r=t(Q,r,q.v[2],W),r+=2):(Q+="\tfacet normal "+q.n.x+" "+q.n.y+" "+q.n.z+"\r\n",Q+="\t\touter loop\r\n",Q+="\t\t\tvertex "+q.v[0].x+" "+q.v[0].y+" "+q.v[0].z+"\r\n",Q+="\t\t\tvertex "+q.v[1].x+" "+q.v[1].y+" "+q.v[1].z+"\r\n",Q+="\t\t\tvertex "+q.v[2].x+" "+q.v[2].y+" "+q.v[2].z+"\r\n",Q+="\t\tendloop\r\n",Q+="\tendfacet\r\n")}!U&&w&&(Q+="endsolid "+name+"\r\n")}if(U||w||(Q+="endsolid stlmesh"),q){const N=document.createElement("a"),q=new Blob([Q],{type:"application/octet-stream"});N.href=window.URL.createObjectURL(q),N.download=C+".stl",N.click()}return Q}}function Lq(N,q){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const d=[];for(let U=0;U<N.length/C;U++){const W=N[U*C],a=N[U*C+1],F=N[U*C+2];d.push(`(${W.toPrecision(q.precision)}, ${a.toPrecision(q.precision)}, ${F.toPrecision(q.precision)})`)}return d.join(", ")}function Gq(N,q){const C=[];for(let d=0;d<N.length/2;d++){const U=N[2*d],W=N[2*d+1];C.push(`(${U.toPrecision(q.precision)}, ${(1-W).toPrecision(q.precision)})`)}return C.join(", ")}function hq(N,q){const C=N.getVerticesData(n.g.PositionKind),d=N.getVerticesData(n.g.NormalKind);if(C&&d)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(N){var q;const C=null!==(q=N.od())&&void 0!==q&&q.length?N.getTotalIndices():N.getTotalVertices();return Array(C/3).fill(3).join(", ")}(N)}]\n\t\tint[] faceVertexIndices = [${function(N){const q=N.od(),C=[];if(null!==q)for(let d=0;d<q.length;d++)C.push(q[d]);else{const q=N.getTotalVertices();for(let N=0;N<q;N++)C.push(N)}return C.join(", ")}(N)}]\n\t\tnormal3f[] normals = [${Lq(d,q)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Lq(C,q)}]\n        ${function(N,q){let C="";for(let U=0;U<4;U++){const d=U>0?U:"",W=N.getVerticesData(n.g.UVKind+(d?d+1:""));W&&(C+=`\n\t\ttexCoord2f[] primvars:st${d} = [${Gq(W,q)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const d=N.getVerticesData(n.g.ColorKind);return d&&(C+=`\n\tcolor3f[] primvars:displayColor = [${Lq(d,q,d.length/N.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),C}(N,q)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Bq(N,q){return`\n        def "Geometry"\n        {\n        ${hq(N,q)}\n        }\n        `}function yq(N){let q='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return q+=N,fflate.strToU8(q)}function Rq(N){const q=N.m;return`( ${uq(q,0)}, ${uq(q,4)}, ${uq(q,8)}, ${uq(q,12)} )`}function uq(N,q){return`(${N[q+0]}, ${N[q+1]}, ${N[q+2]}, ${N[q+3]})`}function mq(N){const q="Object_"+N.uniqueId,C=function(N){const q=N.getWorldMatrix().clone(),C=N.lN().useRightHandedSystem;if(!C){let d=N.parent;for(;d;){if(aN(d,C)){q.multiplyToRef(d.getWorldMatrix().invert(),q);break}d=d.parent}}return q.determinant()<0&&U.Tools.Warn(`Exporting mesh ${N.name} with negative scale. Result may look incorrect in destination engine.`),q}(N),d=Rq(C);return`def Xform "${q}" (\n\tprepend references = @./geometries/Geometry_${N.ed.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${d}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${N.material.uniqueId}>\n}\n\n`}function fq(N){switch(N){case l.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case l.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case l.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function kq(N){return`(${N.x}, ${N.y})`}function gq(N){return`(${N.r}, ${N.g}, ${N.b})`}function xq(N,q,C,U,W,a){const F=N.getInternalTexture().uniqueId+"_"+N.invertY;W[F]=N;const w=N.coordinatesIndex>0?"st"+N.coordinatesIndex:"st",A=new d.Vector2(N.uScale,N.vScale),n=new d.Vector2(N.uOffset,N.vOffset),t=N.wAng,V=Math.sin(t),Z=Math.cos(t);return n.y=1-n.y-A.y,n.x+=V*A.x,n.y+=(1-Z)*A.y,`\n    def Shader "PrimvarReader_${C}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${w}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${C}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${q.uniqueId}/PrimvarReader_${C}.outputs:result>\n        float inputs:rotation = ${(t*(180/Math.PI)).toFixed(a.precision)}\n        float2 inputs:scale = ${kq(A)}\n        float2 inputs:translation = ${kq(n)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${N.uniqueId}_${C}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${F}.png@\n        float2 inputs:st.connect = </Materials/Material_${q.uniqueId}/Transform2d_${C}.outputs:result>\n        ${U?"float4 inputs:scale = "+function(N){return`(${N.r}, ${N.g}, ${N.b}, 1.0)`}(U):""}\n        token inputs:sourceColorSpace = "${N.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${fq(N.wrapU)}"\n        token inputs:wrapT = "${fq(N.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${q.needAlphaBlending()?"float outputs:a":""}\n    }`}function NC(N,q,C){const d="\t\t\t",U=[],W=[],{diffuseMap:a,KF:F,alphaCutOff:w,emissiveMap:A,emissive:n,normalMap:t,roughnessMap:V,roughnessChannel:Z,roughness:J,metalnessMap:Q,metalnessChannel:r,metalness:O,aoMap:K,aoMapChannel:i,aoMapIntensity:I,alphaMap:j,ior:l,clearCoatEnabled:T,clearCoat:z,clearCoatMap:p,clearCoatRoughness:s,clearCoatRoughnessMap:X}=function(N){const q={diffuseMap:null,KF:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return N instanceof QN.rq?{...q,diffuseMap:N.diffuseTexture,KF:N.diffuseColor,alphaCutOff:N.alphaCutOff,emissiveMap:N.emissiveTexture,emissive:N.emissiveColor,roughness:1,alphaMap:N.opacityTexture}:N instanceof Aq.d?{...q,diffuseMap:N._albedoTexture,KF:N._albedoColor,alphaCutOff:N._alphaCutOff,emissiveMap:N._emissiveTexture,emissive:N._emissiveColor,normalMap:N._bumpTexture,roughnessMap:N._metallicTexture,roughnessChannel:N._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:N._roughness??1,metalnessMap:N._metallicTexture,metalnessChannel:N._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:N._metallic??0,aoMap:N._ambientTexture,aoMapChannel:N._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:N._ambientTextureStrength,alphaMap:N._opacityTexture,ior:N.subSurface.indexOfRefraction,clearCoatEnabled:N.clearCoat.isEnabled,clearCoat:N.clearCoat.OF,clearCoatMap:N.clearCoat.texture,clearCoatRoughness:N.clearCoat.roughness,clearCoatRoughnessMap:N.clearCoat.useRoughnessFromMainTexture?N.clearCoat.texture:N.clearCoat.textureRoughness}:q}(N);return null!==a?(U.push(`${d}color3f inputs:diffuseColor.connect = </Materials/Material_${N.uniqueId}/Texture_${a.uniqueId}_diffuse.outputs:rgb>`),N.needAlphaBlending()?U.push(`${d}float inputs:opacity.connect = </Materials/Material_${N.uniqueId}/Texture_${a.uniqueId}_diffuse.outputs:a>`):N.needAlphaTesting()&&(U.push(`${d}float inputs:opacity.connect = </Materials/Material_${N.uniqueId}/Texture_${a.uniqueId}_diffuse.outputs:a>`),U.push(`${d}float inputs:opacityThreshold = ${w}`)),W.push(xq(a,N,"diffuse",F,q,C))):U.push(`${d}color3f inputs:diffuseColor = ${gq(F||v.Oq.White())}`),null!==A?(U.push(`${d}color3f inputs:emissiveColor.connect = </Materials/Material_${N.uniqueId}/Texture_${A.uniqueId}_emissive.outputs:rgb>`),W.push(xq(A,N,"emissive",n,q,C))):n&&n.toLuminance()>0&&U.push(`${d}color3f inputs:emissiveColor = ${gq(n)}`),null!==t&&(U.push(`${d}normal3f inputs:normal.connect = </Materials/Material_${N.uniqueId}/Texture_${t.uniqueId}_normal.outputs:rgb>`),W.push(xq(t,N,"normal",null,q,C))),null!==K&&(U.push(`${d}float inputs:occlusion.connect = </Materials/Material_${N.uniqueId}/Texture_${K.uniqueId}_occlusion.outputs:${i}>`),W.push(xq(K,N,"occlusion",new v.Oq(I,I,I),q,C))),null!==V?(U.push(`${d}float inputs:roughness.connect = </Materials/Material_${N.uniqueId}/Texture_${V.uniqueId}_roughness.outputs:${Z}>`),W.push(xq(V,N,"roughness",new v.Oq(J,J,J),q,C))):U.push(`${d}float inputs:roughness = ${J}`),null!==Q?(U.push(`${d}float inputs:metallic.connect = </Materials/Material_${N.uniqueId}/Texture_${Q.uniqueId}_metallic.outputs:${r}>`),W.push(xq(Q,N,"metallic",new v.Oq(O,O,O),q,C))):U.push(`${d}float inputs:metallic = ${O}`),null!==j?(U.push(`${d}float inputs:opacity.connect = </Materials/Material_${N.uniqueId}/Texture_${j.uniqueId}_opacity.outputs:r>`),U.push(`${d}float inputs:opacityThreshold = 0.0001`),W.push(xq(j,N,"opacity",null,q,C))):U.push(`${d}float inputs:opacity = ${N.alpha}`),T&&(null!==p?(U.push(`${d}float inputs:clearcoat.connect = </Materials/Material_${N.uniqueId}/Texture_${p.uniqueId}_clearcoat.outputs:r>`),W.push(xq(p,N,"clearcoat",new v.Oq(z,z,z),q,C))):U.push(`${d}float inputs:clearcoat = ${z}`),null!==X?(U.push(`${d}float inputs:clearcoatRoughness.connect = </Materials/Material_${N.uniqueId}/Texture_${X.uniqueId}_clearcoatRoughness.outputs:g>`),W.push(xq(X,N,"clearcoatRoughness",new v.Oq(s,s,s),q,C))):U.push(`${d}float inputs:clearcoatRoughness = ${s}`)),U.push(`${d}float inputs:ior = ${l}`),`\n\tdef Material "Material_${N.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${U.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${N.uniqueId}/PreviewSurface.outputs:surface>\n\n${W.join("\n")}\n\n\t}\n`}async function qC(N,q,C){const W={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...q};"undefined"===typeof fflate&&await U.Tools.LoadScriptAsync(W.fflateUrl);const a={};a[W.modelFileName]=null;let F='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';F+=function(N){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===N.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${N.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${N.planeAnchoringAlignment}"`:""}\n            `}(W);const w={};for(const d of N.meshes){if(0===d.getTotalVertices())continue;const N=d,q=N.ed,A=N.material;if(!A||!q||C&&!C(N))continue;if(-1!==["rq","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(A.getClassName())){const C="geometries/Geometry_"+q.uniqueId+".usda";if(!(C in a)){const N=Bq(q,W);a[C]=yq(N)}A.uniqueId in w||(w[A.uniqueId]=A),F+=mq(N)}else U.Tools.Warn("USDZExportAsync does not support this material type: "+A.getClassName())}N.activeCamera&&W.exportCamera&&(F+=function(N,q){const C="Camera_"+N.uniqueId,U=Rq(d.Matrix.RotationY(Math.PI).multiply(N.getWorldMatrix()));if(N.mode===l.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${U}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${N.sd.toPrecision(q.precision)}, ${N.maxZ.toPrecision(q.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(N.orthoLeft||1)+Math.abs(N.orthoRight||1))).toPrecision(q.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(N.orthoTop||1)+Math.abs(N.orthoBottom||1))).toPrecision(q.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const d=N.getEngine().getAspectRatio(N),W=q.cameraSensorWidth||35;return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${U}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${N.sd.toPrecision(q.precision)}, ${N.maxZ.toPrecision(q.precision)})\n\t\t\tfloat focalLength = ${(W/(2*Math.tan(.5*N.fov))).toPrecision(q.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(W*d).toPrecision(q.precision)}\n\t\t\tfloat verticalAperture = ${(W/d).toPrecision(q.precision)}            \n\t\t}\n\t\n\t`}}(N.activeCamera,W)),F+="\n            }\n        }\n    }";const A={};F+=function(N,q,C){const d=[];for(const U in N){const W=N[U];d.push(NC(W,q,C))}return`\n    def "Materials"\n{\n${d.join("")}\n}\n\n`}(w,A,W),a[W.modelFileName]=fflate.strToU8(F);for(const d in A){const N=A[d],q=N.getSize(),C=await N.readPixels();if(!C)throw new Error("Texture data is not available");const U=await T.DumpTools.DumpDataAsync(q.width,q.height,C,"image/png",void 0,!1,!0);a[`textures/Texture_${d}.png`]=new Uint8Array(U).slice()}let n=0;for(const d in a){const N=a[d];if(!N)continue;n+=34+d.length;const q=63&n;if(4!==q){const C=new Uint8Array(64-q);a[d]=[N,{extra:{12345:C}}]}n=N.length}return fflate.zipSync(a,{level:0})}}}]);