"use strict";(self.h66iwo8dvgq=self.h66iwo8dvgq||[]).push([[26],{12271:(b,X,P)=>{P.r(X),P.d(X,{EXT_materials_diffuse_roughness:()=>kX,EXT_mesh_gpu_instancing:()=>Fb,GLTF2Export:()=>cb,GLTFData:()=>w,KHR_draco_mesh_compression:()=>PX,KHR_lights_punctual:()=>uX,KHR_materials_anisotropy:()=>OX,KHR_materials_clearcoat:()=>YX,KHR_materials_diffuse_transmission:()=>tX,KHR_materials_dispersion:()=>WX,KHR_materials_emissive_strength:()=>yX,KHR_materials_ior:()=>LX,KHR_materials_iridescence:()=>vX,KHR_materials_sheen:()=>oX,KHR_materials_specular:()=>TX,KHR_materials_transmission:()=>VX,KHR_materials_unlit:()=>xX,KHR_materials_volume:()=>CX,KHR_texture_transform:()=>UX,OBJExport:()=>N,STLExport:()=>gX,USDZExportAsync:()=>XP,_ConvertToGLTFPBRMetallicRoughness:()=>i,_SolveMetallic:()=>V,__IGLTFExporterExtension:()=>a});var Q=P(11834),S=P(11689),d=P(12177);class N{static OBJ(b,X,P,N){const a=[];let u=1,w=1;X&&(P||(P="mat"),a.push("mtllib "+P+".mtl"));for(let f=0;f<b.length;f++){const P=b[f],O=P.name||`mesh${f}}`;a.push(`o ${O}`);let e=null;if(N){const b=P.pd(!0);e=new Q.Matrix,b.invertToRef(e),P.bakeTransformIntoVertices(b)}if(X){const b=P.material;b&&a.push("usemtl "+b.id)}const Y=P.Ud;if(!Y){S.Tools.Warn("No geometry is present on the mesh");continue}const D=Y.getVerticesData("position"),E=Y.getVerticesData("normal"),t=Y.getVerticesData("uv"),B=Y.ld();let W=0,n=0;if(!D||!B){S.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const y=b[0].Ab().useRightHandedSystem?1:-1;for(let b=0;b<D.length;b+=3)a.push("v "+D[b]*y+" "+D[b+1]+" "+D[b+2]),W++;if(null!=E)for(let b=0;b<E.length;b+=3)a.push("vn "+E[b]*y+" "+E[b+1]+" "+E[b+2]);if(null!=t)for(let b=0;b<t.length;b+=2)a.push("vt "+t[b]+" "+t[b+1]),n++;const h=["","",""],L=(P.material||P.Ab().defaultMaterial)._getEffectiveOrientation(P),[Z,v]=L===d.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let b=0;b<B.length;b+=3){const X=[String(B[b]+u),String(B[b+Z]+u),String(B[b+v]+u)],P=[String(B[b]+w),String(B[b+Z]+w),String(B[b+v]+w)],Q=X,S=null!=t?P:h,d=null!=E?X:h;a.push("f "+Q[0]+"/"+S[0]+"/"+d[0]+" "+Q[1]+"/"+S[1]+"/"+d[1]+" "+Q[2]+"/"+S[2]+"/"+d[2])}N&&e&&P.bakeTransformIntoVertices(e),u+=W,w+=n}return a.join("\n")}static MTL(b){const X=[],P=b.material;X.push("newmtl mat1"),X.push("  Ns "+P.specularPower.toFixed(4)),X.push("  Ni 1.5000"),X.push("  d "+P.alpha.toFixed(4)),X.push("  Tr 0.0000"),X.push("  Tf 1.0000 1.0000 1.0000"),X.push("  illum 2"),X.push("  Ka "+P.ambientColor.r.toFixed(4)+" "+P.ambientColor.g.toFixed(4)+" "+P.ambientColor.b.toFixed(4)),X.push("  Kd "+P.diffuseColor.r.toFixed(4)+" "+P.diffuseColor.g.toFixed(4)+" "+P.diffuseColor.b.toFixed(4)),X.push("  Ks "+P.specularColor.r.toFixed(4)+" "+P.specularColor.g.toFixed(4)+" "+P.specularColor.b.toFixed(4)),X.push("  Ke "+P.emissiveColor.r.toFixed(4)+" "+P.emissiveColor.g.toFixed(4)+" "+P.emissiveColor.b.toFixed(4));P.ambientTexture&&X.push("  map_Ka "+P.ambientTexture.name),P.diffuseTexture&&X.push("  map_Kd "+P.diffuseTexture.name),P.specularTexture&&X.push("  map_Ks "+P.specularTexture.name),P.bumpTexture&&X.push("  map_bump -imfchan z "+P.bumpTexture.name),P.opacityTexture&&X.push("  map_d "+P.opacityTexture.name);return X.join("\n")}}var a=0,u=P(11738);class w{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const b in this.files){const X=this.files[b],P=new Blob([X],{type:(0,u.f)(b)});S.Tools.Download(P,b)}}}var f=P(11912),O=P(12277),e=P(12290),Y=P(12311),D=P(11973),E=P(11732),t=P(11878),B=P(11844);const W=B.HighestCommonFactor,n={...B,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:W};var y=P(12081),h=P(11814),L=P(12346),Z=P(12348),v=P(12072);const A=1e-6,o=new t.yX(.04,.04,.04),K=1024,T=t.yX.White(),q=t.yX.Black();function V(b,X,P){if(X<o.r)return 0;const Q=o.r,S=b*P/(1-o.r)+X-2*o.r,d=S*S-4*Q*(o.r-X);return n.Clamp((-S+Math.sqrt(d))/(2*Q),0,1)}function i(b){const X=b.diffuseColor.toLinearSpace(b.Ab().getEngine().useExactSrgbConversions).scale(.5),P=b.alpha,S=function(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Q.Vector2(0,1),P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Q.Vector2(0,.1),S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Q.Vector2(0,.1),d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new Q.Vector2(1300,.1);return function(b,X,P,Q,S){return(1-b)*(1-b)*(1-b)*X+3*(1-b)*(1-b)*b*P+3*(1-b)*b*b*Q+b*b*b*S}(Math.pow(b/d.x,.333333),X.y,P.y,S.y,d.y)}(n.Clamp(b.specularPower,0,K));return{baseColorFactor:[X.r,X.g,X.b,P],metallicFactor:0,roughnessFactor:S}}function x(b,X){X.needAlphaBlending()?b.alphaMode="BLEND":X.needAlphaTesting()&&(b.alphaMode="MASK",b.alphaCutoff=X.alphaCutOff)}function H(b,X,P){const Q=new Uint8Array(b*X*4);for(let S=0;S<Q.length;S+=4)Q[S]=Q[S+1]=Q[S+2]=Q[S+3]=255;return L.d.CreateRGBATexture(Q,b,X,P)}function C(b){if(b instanceof Uint8Array){const X=b.length,P=new Float32Array(b.length);for(let Q=0;Q<X;++Q)P[Q]=b[Q]/255;return P}if(b instanceof Float32Array)return b;throw new Error("Unsupported pixel format!")}class p{constructor(b){this._exporter=b,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(b){return b?this._textureMap.get(b)??null:null}async exportStandardMaterialAsync(b,X,P){const Q=i(b),d={name:b.name};if(null==b.Jd||b.Jd||(b.twoSidedLighting||S.Tools.Warn(b.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),d.doubleSided=!0),P){const P=[],S=b.diffuseTexture;S&&P.push(this.exportTextureAsync(S,X).then((b=>{b&&(Q.baseColorTexture=b)})));const N=b.bumpTexture;N&&P.push(this.exportTextureAsync(N,X).then((b=>{b&&(d.normalTexture=b,1!==N.level&&(d.normalTexture.scale=N.level))})));const a=b.emissiveTexture;a&&(d.emissiveFactor=[1,1,1],P.push(this.exportTextureAsync(a,X).then((b=>{b&&(d.emissiveTexture=b)}))));const u=b.ambientTexture;u&&P.push(this.exportTextureAsync(u,X).then((b=>{if(b){const X={index:b.index};d.occlusionTexture=X}}))),P.length>0&&(this._exporter._materialNeedsUVsSet.add(b),await Promise.all(P))}(b.alpha<1||b.opacityTexture)&&(b.alphaMode===Z.b.ALPHA_COMBINE?d.alphaMode="BLEND":S.Tools.Warn(b.name+": glTF 2.0 does not support alpha mode: "+b.alphaMode.toString())),b.emissiveColor&&!b.emissiveColor.equalsWithEpsilon(q,A)&&(d.emissiveFactor=b.emissiveColor.Zd()),d.pbrMetallicRoughness=Q,x(d,b),await this._finishMaterialAsync(d,b,X);const N=this._exporter._materials;return N.push(d),N.length-1}async _finishMaterialAsync(b,X,P){const Q=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",b,X),S=[];for(const d of Q)S.push(this.exportTextureAsync(d,P));await Promise.all(S),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",b,X)}async _getImageDataAsync(b,X,Q,S){const d=Z.b.TEXTURETYPE_UNSIGNED_BYTE,N=this._exporter._babylonScene,a=N.getEngine(),u=a.createRawTexture(b,X,Q,Z.b.TEXTUREFORMAT_RGBA,!1,!0,h.d.NEAREST_SAMPLINGMODE,null,d);a.isWebGPU?await P.e(51).then(P.bind(P,14400)):await P.e(52).then(P.bind(P,14404)),await y.m.ApplyPostProcess("pass",u,N,d,Z.b.TEXTURE_NEAREST_SAMPLINGMODE,Z.b.TEXTUREFORMAT_RGBA);const w=await a._readTexturePixels(u,X,Q);return await v.DumpTools.DumpDataAsync(X,Q,w,S,void 0,!0,!0)}_resizeTexturesToSameDimensions(b,X,P){const Q=b?b.getSize():{width:0,height:0},S=X?X.getSize():{width:0,height:0};let d,N;return Q.width<S.width?(d=b&&b instanceof h.d?y.m.CreateResizedCopy(b,S.width,S.height,!0):H(S.width,S.height,P),N=X):Q.width>S.width?(N=X&&X instanceof h.d?y.m.CreateResizedCopy(X,Q.width,Q.height,!0):H(Q.width,Q.height,P),d=b):(d=b,N=X),{texture1:d,texture2:N}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(b,X,P,Q){const S=new Array;if(!b&&!X)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const d=b?b.Ab():X?X.Ab():null;if(d){var N;const a=this._resizeTexturesToSameDimensions(b,X,d),u=null===(N=a.texture1)||void 0===N?void 0:N.getSize();let w,f;const O=u.width,e=u.height,Y=await a.texture1.readPixels(),D=await a.texture2.readPixels();if(!Y)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(w=C(Y),!D)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");f=C(D);const E=f.byteLength,B=new Uint8Array(E),W=new Uint8Array(E),n=4,y=q;let h=0,L=0;for(let b=0;b<e;++b)for(let X=0;X<O;++X){const Q=(O*b+X)*n,S={diffuseColor:new t.yX(w[Q],w[Q+1],w[Q+2]).toLinearSpace(d.getEngine().useExactSrgbConversions).multiply(P.diffuseColor),specularColor:new t.yX(f[Q],f[Q+1],f[Q+2]).toLinearSpace(d.getEngine().useExactSrgbConversions).multiply(P.specularColor),glossiness:f[Q+3]*P.glossiness},N=this._convertSpecularGlossinessToMetallicRoughness(S);y.r=Math.max(y.r,N.baseColor.r),y.g=Math.max(y.g,N.baseColor.g),y.b=Math.max(y.b,N.baseColor.b),h=Math.max(h,N.metallic),L=Math.max(L,N.roughness),W[Q]=255*N.baseColor.r,W[Q+1]=255*N.baseColor.g,W[Q+2]=255*N.baseColor.b,W[Q+3]=a.texture1.Ad?255*w[Q+3]:255,B[Q]=0,B[Q+1]=255*N.roughness,B[Q+2]=255*N.metallic,B[Q+3]=255}const Z={baseColor:y,metallic:h,roughness:L};let v=!1,o=!1;for(let b=0;b<e;++b)for(let X=0;X<O;++X){const P=(O*b+X)*n;W[P]/=Z.baseColor.r>A?Z.baseColor.r:1,W[P+1]/=Z.baseColor.g>A?Z.baseColor.g:1,W[P+2]/=Z.baseColor.b>A?Z.baseColor.b:1;const Q=t.yX.FromInts(W[P],W[P+1],W[P+2]).toGammaSpace(d.getEngine().useExactSrgbConversions);W[P]=255*Q.r,W[P+1]=255*Q.g,W[P+2]=255*Q.b,Q.equalsWithEpsilon(T,A)||(o=!0),B[P+1]/=Z.roughness>A?Z.roughness:1,B[P+2]/=Z.metallic>A?Z.metallic:1;t.yX.FromInts(255,B[P+1],B[P+2]).equalsWithEpsilon(T,A)||(v=!0)}return v&&S.push(this._getImageDataAsync(B,O,e,Q).then((b=>{Z.metallicRoughnessTextureData=b}))),o&&S.push(this._getImageDataAsync(W,O,e,Q).then((b=>{Z.baseColorTextureData=b}))),await Promise.all(S).then((()=>Z))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(b){const X=this._getPerceivedBrightness(b.diffuseColor),P=this._getPerceivedBrightness(b.specularColor),Q=1-this._getMaxComponent(b.specularColor),S=V(X,P,Q),d=b.diffuseColor.scale(Q/(1-o.r)/Math.max(1-S)),N=b.specularColor.BX(o.scale(1-S)).scale(1/Math.max(S));let a=t.yX.Lerp(d,N,S*S);a=a.clampToRef(0,1,a);return{baseColor:a,metallic:S,roughness:1-b.glossiness}}_getPerceivedBrightness(b){return b?Math.sqrt(.299*b.r*b.r+.587*b.g*b.g+.114*b.b*b.b):0}_getMaxComponent(b){return b?Math.max(b.r,Math.max(b.g,b.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(b,X,P,Q){const S=[],d={baseColor:b._albedoColor,metallic:b._metallic,roughness:b._roughness};if(Q){b._albedoTexture&&S.push(this.exportTextureAsync(b._albedoTexture,X).then((b=>{b&&(P.baseColorTexture=b)})));const Q=b._metallicTexture;Q&&S.push(this.exportTextureAsync(Q,X).then((b=>{b&&(P.metallicRoughnessTexture=b)})))}return S.length>0&&(this._exporter._materialNeedsUVsSet.add(b),await Promise.all(S)),d}_getTextureSampler(b){const X={};if(!b||!(b instanceof h.d))return X;const P=this._getGLTFTextureWrapMode(b.wrapU);10497!==P&&(X.wrapS=P);const Q=this._getGLTFTextureWrapMode(b.wrapV);switch(10497!==Q&&(X.wrapT=Q),b.samplingMode){case h.d.LINEAR_LINEAR:X.magFilter=9729,X.minFilter=9729;break;case h.d.LINEAR_NEAREST:X.magFilter=9729,X.minFilter=9728;break;case h.d.NEAREST_LINEAR:X.magFilter=9728,X.minFilter=9729;break;case h.d.NEAREST_LINEAR_MIPLINEAR:X.magFilter=9728,X.minFilter=9987;break;case h.d.NEAREST_NEAREST:X.magFilter=9728,X.minFilter=9728;break;case h.d.NEAREST_LINEAR_MIPNEAREST:X.magFilter=9728,X.minFilter=9985;break;case h.d.LINEAR_NEAREST_MIPNEAREST:X.magFilter=9729,X.minFilter=9984;break;case h.d.LINEAR_NEAREST_MIPLINEAR:X.magFilter=9729,X.minFilter=9986;break;case h.d.NEAREST_NEAREST_MIPLINEAR:X.magFilter=9728,X.minFilter=9986;break;case h.d.LINEAR_LINEAR_MIPLINEAR:X.magFilter=9729,X.minFilter=9987;break;case h.d.LINEAR_LINEAR_MIPNEAREST:X.magFilter=9729,X.minFilter=9985;break;case h.d.NEAREST_NEAREST_MIPNEAREST:X.magFilter=9728,X.minFilter=9984}return X}_getGLTFTextureWrapMode(b){switch(b){case h.d.WRAP_ADDRESSMODE:return 10497;case h.d.CLAMP_ADDRESSMODE:return 33071;case h.d.MIRROR_ADDRESSMODE:return 33648;default:return S.Tools.Error(`Unsupported Texture Wrap Mode ${b}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(b,X,P,Q){const S={diffuseColor:b._albedoColor,specularColor:b._reflectivityColor,glossiness:b._microSurface},d=b._albedoTexture,N=b._reflectivityTexture,a=b._useMicroSurfaceFromReflectivityMapAlpha;if(N&&!a)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((d||N)&&Q){this._exporter._materialNeedsUVsSet.add(b);const Q=this._exportTextureSampler(d||N),a=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(d,N,S,X),u=this._exporter._textures;if(a.baseColorTextureData){const b=this._exportImage(`baseColor${u.length}`,X,a.baseColorTextureData);P.baseColorTexture=this._exportTextureInfo(b,Q,null===d||void 0===d?void 0:d.coordinatesIndex)}if(a.metallicRoughnessTextureData){const b=this._exportImage(`metallicRoughness${u.length}`,X,a.metallicRoughnessTextureData);P.metallicRoughnessTexture=this._exportTextureInfo(b,Q,null===N||void 0===N?void 0:N.coordinatesIndex)}return a}return this._convertSpecularGlossinessToMetallicRoughness(S)}async exportPBRMaterialAsync(b,X,P){const Q={},S={name:b.name},d=b.isMetallicWorkflow();if(d){const X=b._albedoColor,P=b.alpha;X&&(Q.baseColorFactor=[X.r,X.g,X.b,P])}const N=d?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(b,X,Q,P):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(b,X,Q,P);await this._setMetallicRoughnessPbrMaterialAsync(N,b,S,Q,X,P),await this._finishMaterialAsync(S,b,X);const a=this._exporter._materials;return a.push(S),a.length-1}async _setMetallicRoughnessPbrMaterialAsync(b,X,P,Q,d,N){if(x(P,X),b.baseColor.equalsWithEpsilon(T,A)&&n.WithinEpsilon(X.alpha,1,A)||(Q.baseColorFactor=[b.baseColor.r,b.baseColor.g,b.baseColor.b,X.alpha]),null!=b.metallic&&1!==b.metallic&&(Q.metallicFactor=b.metallic),null!=b.roughness&&1!==b.roughness&&(Q.roughnessFactor=b.roughness),null==X.Jd||X.Jd||(X._twoSidedLighting||S.Tools.Warn(X.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),P.doubleSided=!0),N){const b=[],Q=X._bumpTexture;Q&&b.push(this.exportTextureAsync(Q,d).then((b=>{b&&(P.normalTexture=b,1!==Q.level&&(P.normalTexture.scale=Q.level))})));const S=X._ambientTexture;S&&b.push(this.exportTextureAsync(S,d).then((b=>{if(b){const Q={index:b.index,texCoord:b.texCoord,extensions:b.extensions};P.occlusionTexture=Q;const S=X._ambientTextureStrength;S&&(Q.strength=S)}})));const N=X._emissiveTexture;N&&b.push(this.exportTextureAsync(N,d).then((b=>{b&&(P.emissiveTexture=b)}))),b.length>0&&(this._exporter._materialNeedsUVsSet.add(X),await Promise.all(b))}const a=X._emissiveColor;a.equalsWithEpsilon(q,A)||(P.emissiveFactor=a.Zd()),P.pbrMetallicRoughness=Q}_getPixelsFromTextureAsync(b){return function(b){switch(b){case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(b.textureFormat)?(0,y.l)(b,b._texture.width,b._texture.height):(b.textureType,Z.b.TEXTURETYPE_UNSIGNED_BYTE,b.readPixels())}async exportTextureAsync(b,X){const P=this._exporter._extensionsPreExportTextureAsync("exporter",b,X);return P?await P.then((async P=>P?await this._exportTextureInfoAsync(P,X):await this._exportTextureInfoAsync(b,X))):await this._exportTextureInfoAsync(b,X)}async _exportTextureInfoAsync(b,X){let P=this._textureMap.get(b);if(!P){const Q=await this._getPixelsFromTextureAsync(b);if(!Q)return null;const d=this._exportTextureSampler(b),N=b.mimeType;if(N)switch(N){case"image/jpeg":case"image/png":case"image/webp":X=N;break;default:S.Tools.Warn(`Unsupported media type: ${N}. Exporting texture as PNG.`)}const a=this._internalTextureToImage,u=b.getInternalTexture().uniqueId;a[u]||(a[u]={});let w=a[u][X];if(void 0===w){const P=b.getSize();w=(async()=>{const S=await this._getImageDataAsync(Q,P.width,P.height,X);return this._exportImage(b.name,X,S)})(),a[u][X]=w}P=this._exportTextureInfo(await w,d,b.coordinatesIndex),this._textureMap.set(b,P),this._exporter._extensionsPostExportTextures("exporter",P,b)}return P}_exportImage(b,X,P){const Q=this._exporter._images;let d;if(this._exporter._shouldUseGlb){d={name:b,mimeType:X,bufferView:void 0};const Q=this._exporter._bufferManager.createBufferView(new Uint8Array(P));this._exporter._bufferManager.setBufferView(d,Q)}else{const N=b.replace(/\.\/|\/|\.\\|\\/g,"_"),a=function(b){switch(b){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(X);let u=N+a;Q.some((b=>b.uri===u))&&(u=`${N}_${S.Tools.RandomId()}${a}`),d={name:b,uri:u},this._exporter._imageData[u]={data:P,mimeType:X}}return Q.push(d),Q.length-1}_exportTextureInfo(b,X,P){const Q=this._exporter._textures;let S=Q.findIndex((P=>P.sampler==X&&P.source===b));-1===S&&(S=Q.length,Q.push({source:b,sampler:X}));const d={index:S};return P&&(d.texCoord=P),d}_exportTextureSampler(b){const X=this._getTextureSampler(b),P=this._exporter._samplers,Q=P.findIndex((b=>b.minFilter===X.minFilter&&b.magFilter===X.magFilter&&b.wrapS===X.wrapS&&b.wrapT===X.wrapT));return-1!==Q?Q:(P.push(X),P.length-1)}}var k=P(11918),z=P(11700),U=P(12352),g=P(11836);const j=Q.tX.Zero(),l=Q.Quaternion.Identity(),J=Q.tX.One(),c=new Q.tX(-1,1,1);function s(b,X){const{byteOffset:P,byteStride:Q,type:S,normalized:d}=b,N=b.getSize(),a=X.reduce(((b,X)=>X.getTotalVertices()>b?X.getTotalVertices():b),-Number.MAX_VALUE);return{byteOffset:P,byteStride:Q,componentCount:N,type:S,count:a*N,normalized:d,totalVertices:a,kind:b.getKind()}}function F(b){switch(b){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function M(b){switch(b){case f.g.PositionKind:case f.g.NormalKind:case f.g.TangentKind:case f.g.ColorKind:case f.g.MatricesIndicesKind:case f.g.MatricesIndicesExtraKind:case f.g.MatricesWeightsKind:case f.g.MatricesWeightsExtraKind:case f.g.UVKind:case f.g.UV2Kind:case f.g.UV3Kind:case f.g.UV4Kind:case f.g.UV5Kind:case f.g.UV6Kind:return!0}return!1}function R(b){switch(b){case d.b.TriangleFillMode:return 4;case d.b.TriangleStripDrawMode:return 5;case d.b.TriangleFanDrawMode:return 6;case d.b.PointListDrawMode:case d.b.PointFillMode:return 0;case d.b.LineLoopDrawMode:return 2;case d.b.LineListDrawMode:return 1;case d.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${b}`)}function r(b){const X=Math.sqrt(b.x*b.x+b.y*b.y+b.z*b.z);X>0&&(b.x/=X,b.y/=X,b.z/=X)}function I(b){return b.x*=-1,b}function G(b){if(b.x*b.x+b.y*b.y>.5){const X=Math.abs(b.x),P=Math.abs(b.y);if(X>P){const P=Math.sign(b.x);b.x=X,b.y*=-P,b.z*=-P,b.w*=P}else{const X=Math.sign(b.y);b.x*=-X,b.y=P,b.z*=X,b.w*=-X}}else{const X=Math.abs(b.z),P=Math.abs(b.w);if(X>P){const P=Math.sign(b.z);b.x*=-P,b.y*=P,b.z=X,b.w*=-P}else{const X=Math.sign(b.w);b.x*=X,b.y*=-X,b.z*=-X,b.w=P}}return b}function mb(b){b.sd(-b.z,b.w,b.x,-b.y)}function bb(b,X){const P=Q.tX.FromArrayToRef(X.translation||[0,0,0],0,Q.TmpVectors.tX[0]),S=Q.Quaternion.FromArrayToRef(X.rotation||[0,0,0,1],0,Q.TmpVectors.Quaternion[0]),d=Q.Matrix.ComposeToRef(J,S,P,Q.TmpVectors.Matrix[0]),N=Q.tX.FromArrayToRef(b.translation||[0,0,0],0,Q.TmpVectors.tX[2]),a=Q.Quaternion.FromArrayToRef(b.rotation||[0,0,0,1],0,Q.TmpVectors.Quaternion[1]),u=Q.Matrix.ComposeToRef(J,a,N,Q.TmpVectors.Matrix[1]);d.multiplyToRef(u,u),u.decompose(void 0,S,P),P.equalsWithEpsilon(j,g.c)?delete X.translation:X.translation=P.Zd(),S.equalsWithEpsilon(l,g.c)?delete X.rotation:X.rotation=S.Zd(),X.scale&&delete X.scale}function Xb(b,X){if(!(X instanceof O.b))return!1;if(!(1===X.getChildren().length&&0===b.getChildren().length&&b.parent===X))return!1;const P=b.Ab(),Q=b instanceof U.e&&!P.useRightHandedSystem?c:J;return!!X.Fd.equalsWithEpsilon(Q,g.c)||(z.b.Warn(`Cannot collapse node ${b.name} into parent node ${X.name} with modified scaling.`),!1)}function Pb(b){if(b instanceof Array){const X=new Float32Array(b);return new Uint8Array(X.buffer,X.byteOffset,X.byteLength)}return ArrayBuffer.isView(b)?new Uint8Array(b.buffer,b.byteOffset,b.byteLength):new Uint8Array(b)}function Qb(b,X){for(const[P,Q]of Object.entries(b)){const S=X[P];(Array.isArray(Q)&&Array.isArray(S)&&Sb(Q,S)||Q===S)&&delete b[P]}return b}function Sb(b,X){return b.length===X.length&&b.every(((b,P)=>b===X[P]))}const db=Q.Matrix.Compose(new Q.tX(-1,1,1),Q.Quaternion.Identity(),Q.tX.Zero());function Nb(b,X){if(!(b instanceof O.b))return!1;if(X){if(!b.getWorldMatrix().equalsWithEpsilon(Q.Matrix.IdentityReadOnly,g.c))return!1}else{if(!b.getWorldMatrix().multiplyToRef(db,Q.TmpVectors.Matrix[0]).equalsWithEpsilon(Q.Matrix.IdentityReadOnly,g.c))return!1}return!(b instanceof e.e&&b.Ud)}const ab=new Map([[Int8Array,(b,X,P)=>b.setInt8(X,P)],[Uint8Array,(b,X,P)=>b.setUint8(X,P)],[Uint8ClampedArray,(b,X,P)=>b.setUint8(X,P)],[Int16Array,(b,X,P)=>b.setInt16(X,P,!0)],[Uint16Array,(b,X,P)=>b.setUint16(X,P,!0)],[Int32Array,(b,X,P)=>b.setInt32(X,P,!0)],[Uint32Array,(b,X,P)=>b.setUint32(X,P,!0)],[Float32Array,(b,X,P)=>b.setFloat32(X,P,!0)],[Float64Array,(b,X,P)=>b.setFloat64(X,P,!0)]]);class ub{writeTypedArray(b){this._checkGrowBuffer(b.byteLength);const X=ab.get(b.constructor);for(let P=0;P<b.length;P++)X(this._dataView,this._byteOffset,b[P]),this._byteOffset+=b.BYTES_PER_ELEMENT}constructor(b){this._data=new Uint8Array(b),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(b){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,b),this._byteOffset++}writeInt8(b){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,b),this._byteOffset++}writeInt16(b){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,b,!0),this._byteOffset+=2}writeUInt16(b){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,b,!0),this._byteOffset+=2}writeInt32(b){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,b,!0),this._byteOffset+=4}writeUInt32(b){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,b,!0),this._byteOffset+=4}writeFloat32(b){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,b,!0),this._byteOffset+=4}writeFloat64(b){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,b,!0),this._byteOffset+=8}_checkGrowBuffer(b){const X=this.byteOffset+b;if(X>this._data.byteLength){const b=new Uint8Array(2*X);b.set(this._data),this._data=b,this._dataView=new DataView(this._data.buffer)}}}function wb(b){return b%4===0?4:b%2===0?2:1}class fb{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(b){let X=0;this._bufferViewToData.forEach((b=>{X+=b.byteLength}));const P=new ub(X),Q=Array.from(this._bufferViewToData.keys()).sort(((b,X)=>wb(X.byteLength)-wb(b.byteLength)));for(const S of Q){S.byteOffset=P.byteOffset,b.push(S);const X=b.length-1,Q=this.getPropertiesWithBufferView(S);for(const b of Q)b.bufferView=X;P.writeTypedArray(this._bufferViewToData.get(S)),this._bufferViewToData.delete(S)}return P.getOutputData()}createBufferView(b,X){const P={buffer:0,byteOffset:void 0,byteLength:b.byteLength,byteStride:X};return this._bufferViewToData.set(P,b),P}createAccessor(b,X,P,Q,S,d,N){this._verifyBufferView(b);const a={bufferView:void 0,componentType:P,count:Q,type:X,min:null===d||void 0===d?void 0:d.min,max:null===d||void 0===d?void 0:d.max,normalized:N,byteOffset:S};return this.setBufferView(a,b),this._accessorToBufferView.set(a,b),a}setBufferView(b,X){this._verifyBufferView(X);this.getPropertiesWithBufferView(X).push(b)}removeBufferView(b){const X=this.getPropertiesWithBufferView(b);for(const P of X)void 0!==P.bufferView&&delete P.bufferView;this._bufferViewToData.delete(b),this._bufferViewToProperties.delete(b),this._accessorToBufferView.forEach(((X,P)=>{X===b&&(void 0!==P.byteOffset&&delete P.byteOffset,this._accessorToBufferView.delete(P))}))}getBufferView(b){const X=this._accessorToBufferView.get(b);return this._verifyBufferView(X),X}getPropertiesWithBufferView(b){return this._verifyBufferView(b),this._bufferViewToProperties.set(b,this._bufferViewToProperties.get(b)??[]),this._bufferViewToProperties.get(b)}getData(b){return this._verifyBufferView(b),this._bufferViewToData.get(b)}_verifyBufferView(b){if(void 0===b||!this._bufferViewToData.has(b))throw new Error(`BufferView ${b} not found in BufferManager.`)}}var Ob,eb=P(12328),Yb=P(12342),Db=P(12358),Eb=P(12232),tb=P(12386),Bb=P(12390),Wb=P(12319),nb=P(12396);!function(b){b[b.INTANGENT=0]="INTANGENT",b[b.OUTTANGENT=1]="OUTTANGENT"}(Ob||(Ob={}));class yb{static _IsTransformable(b){return b&&(b instanceof O.b||b instanceof eb.c||b instanceof nb.e)}static _CreateNodeAnimation(b,X,P,Q,d){if(this._IsTransformable(b)){const N=[],a=[],u=X.getKeys(),w=yb._CalculateMinMaxKeyFrames(u),f=yb._DeduceInterpolation(u,P,Q),O=f.interpolationType,e=f.shouldBakeAnimation;if(e?yb._CreateBakedAnimation(b,X,P,w.min,w.max,X.framePerSecond,d,N,a,w,Q):"LINEAR"===O||"STEP"===O?yb._CreateLinearOrStepAnimation(b,X,P,N,a,Q):"CUBICSPLINE"===O?yb._CreateCubicSplineAnimation(b,X,P,N,a,Q):yb._CreateBakedAnimation(b,X,P,w.min,w.max,X.framePerSecond,d,N,a,w,Q),N.length&&a.length){return{inputs:N,outputs:a,samplerInterpolation:O,inputsMin:e?w.min:S.Tools.FloatRound(w.min/X.framePerSecond),inputsMax:e?w.max:S.Tools.FloatRound(w.max/X.framePerSecond)}}}return null}static _DeduceAnimationInfo(b){let X=null,P="VEC3",Q=!1;const d=b.targetProperty.split(".");switch(d[0]){case"Fd":X="scale";break;case"position":X="translation";break;case"rotation":P="VEC4",X="rotation";break;case"rotationQuaternion":P="VEC4",Q=!0,X="rotation";break;case"influence":P="SCALAR",X="weights";break;default:S.Tools.Error(`Unsupported animatable property ${d[0]}`)}return X?{animationChannelTargetPath:X,dataAccessorType:P,useQuaternion:Q}:(S.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(b,X,P,Q,S,d,N,a,u,w,f){let O;if(yb._IsTransformable(b)&&b.animations)for(const e of b.animations){if(f&&!f(e))continue;const S=yb._DeduceAnimationInfo(e);S&&(O={name:e.name,samplers:[],channels:[]},yb._AddAnimation(`${e.name}`,e.hasRunningRuntimeAnimations?X:O,b,e,S.dataAccessorType,S.animationChannelTargetPath,Q,d,N,a,S.useQuaternion,u,w),O.samplers.length&&O.channels.length&&P.push(O))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(b,X,P,Q,S,d,N,a,u,w,f){let O;if(b instanceof Wb.b){const S=b.morphTargetManager;if(S)for(let e=0;e<S.numTargets;++e){const Y=S.getTarget(e);for(const D of Y.animations){if(f&&!f(D))continue;const Y=new tb.c(`${D.name}`,"influence",D.framePerSecond,D.dataType,D.loopMode,D.enableBlending),E=[],t=D.getKeys();for(let b=0;b<t.length;++b){const X=t[b];for(let b=0;b<S.numTargets;++b)b==e?E.push(X):E.push({frame:X.frame,value:0})}Y.setKeys(E);const B=yb._DeduceAnimationInfo(Y);B&&(O={name:Y.name,samplers:[],channels:[]},yb._AddAnimation(D.name,D.hasRunningRuntimeAnimations?X:O,b,Y,B.dataAccessorType,B.animationChannelTargetPath,Q,d,N,a,B.useQuaternion,u,w,S.numTargets),O.samplers.length&&O.channels.length&&P.push(O))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(b,X,P,Q,S,d,N,a,u){let w;if(b.animationGroups){const O=b.animationGroups;for(const e of O){const O=new Map,Y=new Map,D=new Set,E=e.to-e.from;w={name:e.name,channels:[],samplers:[]};for(let X=0;X<e.targetedAnimations.length;++X){const E=e.targetedAnimations[X],t=E.target,B=E.animation;if(u&&!u(B))continue;const W=a.has(t);if(this._IsTransformable(t)||1===t.length&&this._IsTransformable(t[0])){const b=yb._DeduceAnimationInfo(E.animation);if(b){const X=this._IsTransformable(t)?t:this._IsTransformable(t[0])?t[0]:null;X&&yb._AddAnimation(`${B.name}`,w,X,B,b.dataAccessorType,b.animationChannelTargetPath,P,Q,S,d,b.useQuaternion,N,W)}}else if(t instanceof Bb.c||1===t.length&&t[0]instanceof Bb.c){if(yb._DeduceAnimationInfo(E.animation)){const X=t instanceof Bb.c?t:t[0];if(X){const P=b.morphTargetManagers.find((b=>{for(let P=0;P<b.numTargets;++P)if(b.getTarget(P)===X)return!0;return!1}));if(P){const Q=b.meshes.find((b=>b.morphTargetManager===P));var f;if(Q)O.has(Q)||O.set(Q,new Map),null===(f=O.get(Q))||void 0===f||f.set(X,B),D.add(Q),Y.set(Q,B)}}}}}D.forEach((b=>{const X=b.morphTargetManager;let a=null;const u=[],f=Y.get(b).getKeys(),D=f.length;for(let P=0;P<D;++P)for(let Q=0;Q<X.numTargets;++Q){const S=X.getTarget(Q),d=O.get(b);if(d){const X=d.get(S);X?(a||(a=new tb.c(`${e.name}_${b.name}_MorphWeightAnimation`,"influence",X.framePerSecond,tb.c.ANIMATIONTYPE_FLOAT,X.loopMode,X.enableBlending)),u.push(X.getKeys()[P])):u.push({frame:e.from+E/D*P,value:S.influence,inTangent:f[0].inTangent?0:void 0,outTangent:f[0].outTangent?0:void 0})}}a.setKeys(u);const t=yb._DeduceAnimationInfo(a);t&&yb._AddAnimation(`${e.name}_${b.name}_MorphWeightAnimation`,w,b,a,t.dataAccessorType,t.animationChannelTargetPath,P,Q,S,d,t.useQuaternion,N,!1,null===X||void 0===X?void 0:X.numTargets)})),w.channels.length&&w.samplers.length&&X.push(w)}}}static _AddAnimation(b,X,P,S,d,N,a,u,w,f,O,e,Y,D){const E=yb._CreateNodeAnimation(P,S,N,O,e);let t,B,W,n,y,h;if(E){if(D){let b=0,X=0;const P=[];for(;E.inputs.length>0;)X=E.inputs.shift(),b%D==0&&P.push(X),b++;E.inputs=P}const b=a.get(P),S=new Float32Array(E.inputs);t=u.createBufferView(S),B=u.createAccessor(t,"SCALAR",5126,E.inputs.length,void 0,{min:[E.inputsMin],max:[E.inputsMax]}),f.push(B),W=f.length-1;const w=new Q.Quaternion,O=new Q.tX,e=new Q.tX,L=P instanceof eb.c,Z=F(d),v=new Float32Array(E.outputs.length*Z);E.outputs.forEach((function(b,X){let P=b;switch(N){case"translation":Y&&(Q.tX.FromArrayToRef(b,0,e),I(e),e.toArray(P));break;case"rotation":4===b.length?Q.Quaternion.FromArrayToRef(b,0,w):(P=new Array(4),Q.tX.FromArrayToRef(b,0,O),Q.Quaternion.FromEulerVectorToRef(O,w)),Y&&(G(w),L&&mb(w)),w.toArray(P)}v.set(P,X*Z)})),t=u.createBufferView(v),B=u.createAccessor(t,d,5126,E.outputs.length),f.push(B),n=f.length-1,y={interpolation:E.samplerInterpolation,input:W,output:n},X.samplers.push(y),h={sampler:X.samplers.length-1,target:{node:b,path:N}},X.channels.push(h)}}static _CreateBakedAnimation(b,X,P,d,N,a,u,w,f,O,e){let Y;const D=Q.Quaternion.Identity();let E,t=null,B=null,W=null,n=null,y=null,h=null;O.min=S.Tools.FloatRound(d/a);const L=X.getKeys();for(let Q=0,Z=L.length;Q<Z;++Q){if(h=null,W=L[Q],Q+1<Z)if(n=L[Q+1],W.value.equals&&W.value.equals(n.value)||W.value===n.value){if(0!==Q)continue;h=W.frame}else h=n.frame;else{if(y=L[Q-1],W.value.equals&&W.value.equals(y.value)||W.value===y.value)continue;h=N}if(h)for(let Q=W.frame;Q<=h;Q+=u){if(E=S.Tools.FloatRound(Q/a),E===t)continue;t=E,B=E;const d={key:0,repeatCount:0,loopMode:X.loopMode};Y=X._interpolate(Q,d),yb._SetInterpolatedValue(b,Y,E,X,P,D,w,f,e)}}B&&(O.max=B)}static _ConvertFactorToVector3OrQuaternion(b,X,P,d,N){const a=yb._GetBasePositionRotationOrScale(X,d,N),u=P.targetProperty.split("."),w=u?u[1]:"",f=N?Q.Quaternion.hX(a).normalize():Q.tX.hX(a);switch(w){case"x":case"y":case"z":f[w]=b;break;case"w":f.w=b;break;default:S.Tools.Error(`glTFAnimation: Unsupported component name "${w}"!`)}return f}static _SetInterpolatedValue(b,X,P,S,d,N,a,u,w){let f;a.push(P),"weights"!==d?(S.dataType===tb.c.ANIMATIONTYPE_FLOAT&&(X=this._ConvertFactorToVector3OrQuaternion(X,b,S,d,w)),"rotation"===d?(w?N=X:(f=X,Q.Quaternion.RotationYawPitchRollToRef(f.y,f.x,f.z,N)),u.push(N.Zd())):(f=X,u.push(f.Zd()))):u.push([X])}static _CreateLinearOrStepAnimation(b,X,P,Q,S,d){for(const N of X.getKeys())Q.push(N.frame/X.framePerSecond),yb._AddKeyframeValue(N,X,S,P,b,d)}static _CreateCubicSplineAnimation(b,X,P,Q,S,d){X.getKeys().forEach((function(N){Q.push(N.frame/X.framePerSecond),yb._AddSplineTangent(Ob.INTANGENT,S,P,"CUBICSPLINE",N,d),yb._AddKeyframeValue(N,X,S,P,b,d),yb._AddSplineTangent(Ob.OUTTANGENT,S,P,"CUBICSPLINE",N,d)}))}static _GetBasePositionRotationOrScale(b,X,P){let S;if("rotation"===X)if(P){S=(b.rotationQuaternion??Q.Quaternion.Identity()).Zd()}else{S=(b.rotation??Q.tX.Zero()).Zd()}else if("translation"===X){S=(b.position??Q.tX.Zero()).Zd()}else{S=(b.Fd??Q.tX.One()).Zd()}return S}static _AddKeyframeValue(b,X,P,d,N,a){let u;const w=X.dataType;if(w===tb.c.ANIMATIONTYPE_VECTOR3){let X=b.value.Zd();if("rotation"===d){const b=Q.tX.hX(X);X=Q.Quaternion.RotationYawPitchRoll(b.y,b.x,b.z).Zd()}P.push(X)}else if(w===tb.c.ANIMATIONTYPE_FLOAT){if("weights"===d)P.push([b.value]);else if(u=this._ConvertFactorToVector3OrQuaternion(b.value,N,X,d,a),u){if("rotation"===d){const b=a?u:Q.Quaternion.RotationYawPitchRoll(u.y,u.x,u.z).normalize();P.push(b.Zd())}P.push(u.Zd())}}else w===tb.c.ANIMATIONTYPE_QUATERNION?P.push(b.value.normalize().Zd()):S.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(b,X,P){let Q,S,d=!1;if("rotation"===X&&!P)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let N=0,a=b.length;N<a;++N)if(S=b[N],S.inTangent||S.outTangent)if(Q){if("CUBICSPLINE"!==Q){Q="LINEAR",d=!0;break}}else Q="CUBICSPLINE";else if(Q){if("CUBICSPLINE"===Q||S.interpolation&&1===S.interpolation&&"STEP"!==Q){Q="LINEAR",d=!0;break}}else Q=S.interpolation&&1===S.interpolation?"STEP":"LINEAR";return Q||(Q="LINEAR"),{interpolationType:Q,shouldBakeAnimation:d}}static _AddSplineTangent(b,X,P,S,d,N){let a;const u=b===Ob.INTANGENT?d.inTangent:d.outTangent;if("CUBICSPLINE"===S){if("rotation"===P)if(u)if(N)a=u.Zd();else{const b=u;a=Q.Quaternion.RotationYawPitchRoll(b.y,b.x,b.z).Zd()}else a=[0,0,0,0];else a="weights"===P?u?[u]:[0]:u?u.Zd():[0,0,0];X.push(a)}}static _CalculateMinMaxKeyFrames(b){let X=1/0,P=-1/0;return b.forEach((function(b){X=Math.min(X,b.frame),P=Math.max(P,b.frame)})),{min:X,max:P}}}function hb(b,X,P,d,N,a){const u={attributes:{},influence:b.influence,name:b.name},w=X.Ud;if(!w)return S.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),u;const O=a?-1:1,e=Q.tX.Zero();let Y=0,D=0;if(b.hasPositions){const d=b.getPositions(),a=w.getVerticesData(f.g.PositionKind);if(a){const b=new Float32Array(a.length),X=[1/0,1/0,1/0],S=[-1/0,-1/0,-1/0];D=a.length/3,Y=0;for(let P=Y;P<D;++P){const N=Q.tX.hX(a,3*P);Q.tX.hX(d,3*P).subtractToRef(N,e),e.x*=O,X[0]=Math.min(X[0],e.x),S[0]=Math.max(S[0],e.x),X[1]=Math.min(X[1],e.y),S[1]=Math.max(S[1],e.y),X[2]=Math.min(X[2],e.z),S[2]=Math.max(S[2],e.z),b[3*P]=e.x,b[3*P+1]=e.y,b[3*P+2]=e.z}const w=P.createBufferView(b,12),f=P.createAccessor(w,"VEC3",5126,d.length/3,0,{min:X,max:S});N.push(f),u.attributes.POSITION=N.length-1}else S.Tools.Warn(`Morph target positions for mesh ${X.name} were not exported. Mesh does not have position vertex data`)}if(b.hasNormals){const d=b.getNormals(),a=w.getVerticesData(f.g.NormalKind);if(a){const b=new Float32Array(a.length);D=a.length/3,Y=0;for(let P=Y;P<D;++P){const X=Q.tX.hX(a,3*P).normalize();Q.tX.hX(d,3*P).normalize().subtractToRef(X,e),b[3*P]=e.x*O,b[3*P+1]=e.y,b[3*P+2]=e.z}const X=P.createBufferView(b,12),S=P.createAccessor(X,"VEC3",5126,d.length/3,0);N.push(S),u.attributes.NORMAL=N.length-1}else S.Tools.Warn(`Morph target normals for mesh ${X.name} were not exported. Mesh does not have normals vertex data`)}if(b.hasTangents){const d=b.getTangents(),a=w.getVerticesData(f.g.TangentKind);if(a){D=a.length/4;const b=new Float32Array(3*D);Y=0;for(let P=Y;P<D;++P){const X=Q.tX.hX(a,4*P);r(X);const S=Q.tX.hX(d,3*P);r(S),S.subtractToRef(X,e),b[3*P]=e.x*O,b[3*P+1]=e.y,b[3*P+2]=e.z}const X=P.createBufferView(b,12),S=P.createAccessor(X,"VEC3",5126,D,0);N.push(S),u.attributes.TANGENT=N.length-1}else S.Tools.Warn(`Morph target tangents for mesh ${X.name} were not exported. Mesh does not have tangents vertex data`)}if(b.hasColors){const d=b.getColors(),a=w.getVerticesData(f.g.ColorKind),O=w.getVertexBuffer(f.g.ColorKind);if(a&&O){const b=O.getSize();D=a.length/b;const X=new Float32Array(D*b);Y=0;for(let P=Y;P<D;++P)if(3===b){const S=Q.tX.hX(a,P*b);Q.tX.hX(d,P*b).subtractToRef(S,e),X[3*P]=e.x,X[3*P+1]=e.y,X[3*P+2]=e.z}else if(4===b){const S=new Q.Vector4,N=Q.Vector4.hX(a,P*b);Q.Vector4.hX(d,P*b).subtractToRef(N,S),X[4*P]=S.x,X[4*P+1]=S.y,X[4*P+2]=S.z,X[4*P+3]=S.w}else S.Tools.Warn(`Unsupported number of components for color attribute: ${b}`);const w=P.createBufferView(X,4*b),f=P.createAccessor(w,3===b?"VEC3":"VEC4",5126,D,0);N.push(f),u.attributes.COLOR_0=N.length-1}else S.Tools.Warn(`Morph target colors for mesh ${X.name} were not exported. Mesh does not have colors vertex data`)}return u}var Lb=P(12402),Zb=P(12260),vb=P(12240),Ab=P(11802);class ob{}ob.DEFAULT_COLOR=t.yX.White(),ob.DEFAULT_WIDTH_ATTENUATED=1,ob.DEFAULT_WIDTH=.1;var Kb=P(12057),Tb=P(12410);class qb{static ConvertPoints(b,X){if(b.length&&Array.isArray(b)&&"number"===typeof b[0])return[b];if(b.length&&Array.isArray(b[0])&&"number"===typeof b[0][0])return b;if(b.length&&!Array.isArray(b[0])&&b[0]instanceof Q.tX){const X=[];for(let P=0;P<b.length;P++){const Q=b[P];X.push(Q.x,Q.y,Q.z)}return[X]}if(b.length>0&&Array.isArray(b[0])&&b[0].length>0&&b[0][0]instanceof Q.tX){const X=[],P=b;for(const b of P)X.push(b.flatMap((b=>[b.x,b.y,b.z])));return X}if(b instanceof Float32Array){if(null!==X&&void 0!==X&&X.floatArrayStride){const P=[],Q=3*X.floatArrayStride;for(let X=0;X<b.length;X+=Q){const S=new Array(Q);for(let P=0;P<Q;P++)S[P]=b[X+P];P.push(S)}return P}return[Array.from(b)]}if(b.length&&b[0]instanceof Float32Array){const X=[];for(const P of b)X.push(Array.from(P));return X}return[]}static OmitZeroLengthPredicate(b,X,P){const Q=[];return X.BX(b).lengthSquared()>0&&Q.push([b,X]),P.BX(X).lengthSquared()>0&&Q.push([X,P]),b.BX(P).lengthSquared()>0&&Q.push([P,b]),0===Q.length?null:Q}static OmitDuplicatesPredicate(b,X,P,Q){const S=[];return qb._SearchInPoints(b,X,Q)||S.push([b,X]),qb._SearchInPoints(X,P,Q)||S.push([X,P]),qb._SearchInPoints(P,b,Q)||S.push([P,b]),0===S.length?null:S}static _SearchInPoints(b,X,P){for(const N of P)for(let P=0;P<N.length;P++){var Q,S,d;if(null!==(Q=N[P])&&void 0!==Q&&Q.equals(b))if(null!==(S=N[P+1])&&void 0!==S&&S.equals(X)||null!==(d=N[P-1])&&void 0!==d&&d.equals(X))return!0}return!1}static MeshesToLines(b,X){const P=[];for(let S=0;S<b.length;S++){const d=b[S],N=d.getVerticesData(f.g.PositionKind),a=d.ld();if(N&&a)for(let b=0,u=0;b<a.length;b++){const w=3*a[u++],f=3*a[u++],O=3*a[u++],e=new Q.tX(N[w],N[w+1],N[w+2]),Y=new Q.tX(N[f],N[f+1],N[f+2]),D=new Q.tX(N[O],N[O+1],N[O+2]);if(X){const Q=X(e,Y,D,P,b,w,d,S,N,a);if(Q)for(const b of Q)P.push(b)}else P.push([e,Y],[Y,D],[D,e])}}return P}static ToVector3Array(b){if(Array.isArray(b[0])){const X=[],P=b;for(const b of P){const P=[];for(let X=0;X<b.length;X+=3)P.push(new Q.tX(b[X],b[X+1],b[X+2]));X.push(P)}return X}const X=b,P=[];for(let S=0;S<X.length;S+=3)P.push(new Q.tX(X[S],X[S+1],X[S+2]));return P}static ToNumberArray(b){return b.flatMap((b=>[b.x,b.y,b.z]))}static GetPointsCountInfo(b){const X=new Array(b.length);let P=0;for(let Q=b.length;Q--;)X[Q]=b[Q].length/3,P+=X[Q];return{total:P,counts:X}}static GetLineLength(b){if(0===b.length)return 0;let X;X="number"===typeof b[0]?qb.ToVector3Array(b):b;const P=Q.TmpVectors.tX[0];let S=0;for(let Q=0;Q<X.length-1;Q++){const b=X[Q];S+=X[Q+1].subtractToRef(b,P).length()}return S}static GetLineLengthArray(b){const X=new Float32Array(b.length/3);let P=0;for(let Q=0,S=b.length/3-1;Q<S;Q++){let S=b[3*Q+0],d=b[3*Q+1],N=b[3*Q+2];S-=b[3*Q+3],d-=b[3*Q+4],N-=b[3*Q+5];P+=Math.sqrt(S*S+d*d+N*N),X[Q+1]=P}return X}static SegmentizeSegmentByCount(b,X,P){const S=[],d=X.BX(b),N=Q.TmpVectors.tX[0];N.Gd(P);const a=Q.TmpVectors.tX[1];d.divideToRef(N,a);let u=b.clone();S.push(u);for(let Q=0;Q<P;Q++)u=u.clone(),S.push(u.addInPlace(a));return S}static SegmentizeLineBySegmentLength(b,X){const P=b[0]instanceof Q.tX?qb.GetLineSegments(b):"number"===typeof b[0]?qb.GetLineSegments(qb.ToVector3Array(b)):b,S=[];for(const Q of P)if(Q.length>X){const b=qb.SegmentizeSegmentByCount(Q.point1,Q.point2,Math.ceil(Q.length/X));for(const X of b)S.push(X)}else S.push(Q.point1),S.push(Q.point2);return S}static SegmentizeLineBySegmentCount(b,X){const P="number"===typeof b[0]?qb.ToVector3Array(b):b,Q=qb.GetLineLength(P)/X;return qb.SegmentizeLineBySegmentLength(P,Q)}static GetLineSegments(b){const X=[];for(let P=0;P<b.length-1;P++){const Q=b[P],S=b[P+1],d=S.BX(Q).length();X.push({point1:Q,point2:S,length:d})}return X}static GetMinMaxSegmentLength(b){const X=qb.GetLineSegments(b).sort((b=>b.length));return{min:X[0].length,max:X[X.length-1].length}}static GetPositionOnLineByVisibility(b,X,P){let S=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const d=X*P;let N=0,a=0;const u=b.length;for(let Q=0;Q<u;Q++){if(d<=N+b[Q].length){a=Q;break}N+=b[Q].length}const w=(d-N)/b[a].length;return b[a].point2.subtractToRef(b[a].point1,Q.TmpVectors.tX[0]),Q.TmpVectors.tX[1]=Q.TmpVectors.tX[0].multiplyByFloats(w,w,w),S||Q.TmpVectors.tX[1].addInPlace(b[a].point1),Q.TmpVectors.tX[1].clone()}static GetCircleLinePoints(b,X){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:b,d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/X;const N=[];for(let a=0;a<=X;a++)N.push(new Q.tX(Math.cos(a*d)*b,Math.sin(a*d)*S,P));return N}static GetBezierLinePoints(b,X,P,Q){return Kb.e.CreateQuadraticBezier(b,X,P,Q).getPoints().flatMap((b=>[b.x,b.y,b.z]))}static GetArrowCap(b,X,P,Q,S){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,N=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[b.clone(),b.add(X.multiplyByFloats(P,P,P))],widths:[Q,S,d,N]}}static GetPointsFromText(b,X,P,Q){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,d=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const N=[],a=(0,Tb.e)(b,X,P,Q);for(const u of a){for(const b of u.paths){const X=[],P=b.getPoints();for(const b of P)X.push(b.x,b.y,S);N.push(X)}if(d)for(const b of u.holes){const X=[],P=b.getPoints();for(const b of P)X.push(b.x,b.y,S);N.push(X)}}return N}static Color3toRGBAUint8(b){const X=new Uint8Array(4*b.length);for(let P=0,Q=0;P<b.length;P++)X[Q++]=255*b[P].r,X[Q++]=255*b[P].g,X[Q++]=255*b[P].b,X[Q++]=255;return X}static CreateColorsTexture(b,X,P,Q){const S=Q.getEngine().getCaps().maxTextureSize??1,d=X.length>S?S:X.length,N=Math.ceil(X.length/S);N>1&&(X=[...X,...Array(d*N-X.length).fill(X[0])]);const a=qb.Color3toRGBAUint8(X),u=new L.d(a,d,N,D.b.TEXTUREFORMAT_RGBA,Q,!1,!0,P);return u.name=b,u}static PrepareEmptyColorsTexture(b){if(!ob.EmptyColorsTexture){const X=new Uint8Array(4);ob.EmptyColorsTexture=new L.d(X,1,1,D.b.TEXTUREFORMAT_RGBA,b,!1,!1,L.d.NEAREST_NEAREST),ob.EmptyColorsTexture.name="grlEmptyColorsTexture"}return ob.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var b;null===(b=ob.EmptyColorsTexture)||void 0===b||b.dispose(),ob.EmptyColorsTexture=null}static BooleanToNumber(b){return b?1:0}}class Vb extends vb.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class ib extends Zb.b{isCompatible(b){return!0}constructor(b,X,P){var S;P=P||{color:ob.DEFAULT_COLOR};const d=new Vb;d.GREASED_LINE_HAS_COLOR=!!P.color&&!P.useColors,d.GREASED_LINE_SIZE_ATTENUATION=P.sizeAttenuation??!1,d.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===P.colorDistributionType,d.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(X??b.Ab()).useRightHandedSystem,d.GREASED_LINE_CAMERA_FACING=P.cameraFacing??!0,super(b,ib.GREASED_LINE_MATERIAL_NAME,200,d,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(S=P)||void 0===S?void 0:S.forceGLSL)||ib.ForceGLSL,this._scene=X??b.Ab(),this._engine=this._scene.getEngine(),this._cameraFacing=P.cameraFacing??!0,this.visibility=P.visibility??1,this.useDash=P.useDash??!1,this.dashRatio=P.dashRatio??.5,this.dashOffset=P.dashOffset??0,this.width=P.width?P.width:P.sizeAttenuation?ob.DEFAULT_WIDTH_ATTENUATED:ob.DEFAULT_WIDTH,this._sizeAttenuation=P.sizeAttenuation??!1,this.colorMode=P.colorMode??0,this._color=P.color??null,this.useColors=P.useColors??!1,this._colorsDistributionType=P.colorDistributionType??0,this.colorsSampling=P.colorsSampling??L.d.NEAREST_NEAREST,this._colors=P.qb??null,this.dashCount=P.dashCount??1,this.resolution=P.resolution??new Q.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),P.colorsTexture?this.colorsTexture=P.colorsTexture:this._colors?this.colorsTexture=qb.CreateColorsTexture(`${b.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??ob.DEFAULT_COLOR,qb.PrepareEmptyColorsTexture(this._scene)),this._engine.Nd.add((()=>{qb.DisposeEmptyColorsTexture()}))}getAttributes(b){b.push("grl_offsets"),b.push("grl_widths"),b.push("grl_colorPointers"),b.push("grl_counters"),this._cameraFacing?(b.push("grl_previousAndSide"),b.push("grl_nextAndCounters")):b.push("grl_slopes")}getSamplers(b){b.push("grl_colors")}getActiveTextures(b){this.colorsTexture&&b.push(this.colorsTexture)}getUniforms(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const X=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&X.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===b&&X.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:X,vertex:this._cameraFacing&&this._isGLSL(b)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(b)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(b){if(this._cameraFacing){b.Cd("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||b.Cd("viewProjection",this._scene.getTransformMatrix());const X=Q.TmpVectors.Vector4[0];X.x=this._aspect,X.y=this._resolution.x,X.z=this._resolution.y,X.w=this.width,b.updateVector4("grl_aspect_resolution_lineWidth",X)}const X=Q.TmpVectors.Vector4[0];X.x=qb.BooleanToNumber(this.useDash),X.y=this._dashArray,X.z=this.dashOffset,X.w=this.dashRatio,b.updateVector4("grl_dashOptions",X);const P=Q.TmpVectors.Vector4[1];P.x=this.colorMode,P.y=this.visibility,P.z=this.colorsTexture?this.colorsTexture.getSize().width:0,P.w=qb.BooleanToNumber(this.useColors),b.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",P),this._color&&b.updateColor3("grl_singleColor",this._color);const S=this.colorsTexture??ob.EmptyColorsTexture;b.setTexture("grl_colors",S),b.updateFloat2("grl_textureSize",(null===S||void 0===S?void 0:S.getSize().width)??1,(null===S||void 0===S?void 0:S.getSize().height)??1)}prepareDefines(b,X,P){b.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,b.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,b.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,b.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=X.useRightHandedSystem,b.GREASED_LINE_CAMERA_FACING=this._cameraFacing,b.GREASED_LINE_USE_OFFSETS=!!P.offsets}getClassName(){return ib.GREASED_LINE_MATERIAL_NAME}getCustomCode(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(X)?function(b,X){if("vertex"===b){const b={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return X&&(b["!gl_Position\\=viewProjection\\*worldPos;"]="//"),b}return"fragment"===b?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(b,this._cameraFacing):function(b,X){if("vertex"===b){const b={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return X&&(b["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),b}return"fragment"===b?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(b,this._cameraFacing)}dispose(){var b;null===(b=this.colorsTexture)||void 0===b||b.dispose(),super.dispose()}get qb(){return this._colors}set qb(b){this.setColors(b)}setColors(b){var X;let P=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const S=(null===(X=this._colors)||void 0===X?void 0:X.length)??0;var d;if(this._colors=b,null!==b&&0!==b.length){if(!P||Q)if(this.colorsTexture&&S===b.length&&!Q){const X=qb.Color3toRGBAUint8(b);this.colorsTexture.update(X)}else{var N;null===(N=this.colorsTexture)||void 0===N||N.dispose(),this.colorsTexture=qb.CreateColorsTexture(`${this._material.name}-colors-texture`,b,this.colorsSampling,this._scene)}}else null===(d=this.colorsTexture)||void 0===d||d.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(b){this._dashCount=b,this._dashArray=1/b}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(b){this._sizeAttenuation=b,this.markAllDefinesAsDirty()}get color(){return this._color}set color(b){this.setColor(b)}setColor(b){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==b||null!==this._color&&null===b?(this._color=b,X||this.markAllDefinesAsDirty()):this._color=b}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(b){this._colorsDistributionType=b,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(b){this._aspect=b.x/b.y,this._resolution=b}serialize(){const b=super.serialize(),X={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(X.qb=this._colors),this._color&&(X.color=this._color),b.greasedLineMaterialOptions=X,b}parse(b,X,P){var Q;super.parse(b,X,P);const S=b.greasedLineMaterialOptions;null===(Q=this.colorsTexture)||void 0===Q||Q.dispose(),S.color&&this.setColor(S.color,!0),S.colorDistributionType&&(this.colorsDistributionType=S.colorDistributionType),S.qb&&(this.qb=S.qb),S.colorsSampling&&(this.colorsSampling=S.colorsSampling),S.colorMode&&(this.colorMode=S.colorMode),S.useColors&&(this.useColors=S.useColors),S.visibility&&(this.visibility=S.visibility),S.useDash&&(this.useDash=S.useDash),S.dashCount&&(this.dashCount=S.dashCount),S.dashRatio&&(this.dashRatio=S.dashRatio),S.dashOffset&&(this.dashOffset=S.dashOffset),S.width&&(this.width=S.width),S.sizeAttenuation&&(this.sizeAttenuation=S.sizeAttenuation),S.resolution&&(this.resolution=S.resolution),this.qb?this.colorsTexture=qb.CreateColorsTexture(`${this._material.name}-colors-texture`,this.qb,this.colorsSampling,X):qb.PrepareEmptyColorsTexture(X),this.markAllDefinesAsDirty()}copyTo(b){var X;const P=b;null===(X=P.colorsTexture)||void 0===X||X.dispose(),this._colors&&(P.colorsTexture=qb.CreateColorsTexture(`${P._material.name}-colors-texture`,this._colors,P.colorsSampling,this._scene)),P.setColor(this.color,!0),P.colorsDistributionType=this.colorsDistributionType,P.colorsSampling=this.colorsSampling,P.colorMode=this.colorMode,P.useColors=this.useColors,P.visibility=this.visibility,P.useDash=this.useDash,P.dashCount=this.dashCount,P.dashRatio=this.dashRatio,P.dashOffset=this.dashOffset,P.width=this.width,P.sizeAttenuation=this.sizeAttenuation,P.resolution=this.resolution,P.markAllDefinesAsDirty()}_isGLSL(b){return 0===b||this._forceGLSL}}ib.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",ib.ForceGLSL=!1,(0,Ab.h)(`BABYLON.${ib.GREASED_LINE_MATERIAL_NAME}`,ib);var xb=P(12299),Hb=P(11709),Cb=P(12084),pb=P(11789);class kb extends Cb.ShaderMaterial{constructor(b,X,S){const d=X.getEngine(),N=d.isWebGPU&&!(S.forceGLSL||kb.ForceGLSL),a=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];X.useRightHandedSystem&&a.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const u=["position","grl_widths","grl_offsets","grl_colorPointers"];S.cameraFacing?(a.push("GREASED_LINE_CAMERA_FACING"),u.push("grl_previousAndSide","grl_nextAndCounters")):(u.push("grl_slopes"),u.push("grl_counters"));const w=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(N||w.push("world","viewProjection","view","projection"),super(b,X,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:N?["Scene","Mesh"]:void 0,attributes:u,uniforms:w,samplers:N?[]:["grlColors"],defines:a,extraInitializationsAsync:async()=>{N?await Promise.all([P.e(66).then(P.bind(P,15091)),P.e(75).then(P.bind(P,15096))]):await Promise.all([P.e(69).then(P.bind(P,15104)),P.e(76).then(P.bind(P,15109))])},shaderLanguage:N?1:0}),this._color=t.yX.White(),this._colorsDistributionType=0,this._colorsTexture=null,S=S||{color:ob.DEFAULT_COLOR},this.visibility=S.visibility??1,this.useDash=S.useDash??!1,this.dashRatio=S.dashRatio??.5,this.dashOffset=S.dashOffset??0,this.dashCount=S.dashCount??1,this.width=S.width?S.width:S.sizeAttenuation&&S.cameraFacing?ob.DEFAULT_WIDTH_ATTENUATED:ob.DEFAULT_WIDTH,this.sizeAttenuation=S.sizeAttenuation??!1,this.color=S.color??t.yX.White(),this.useColors=S.useColors??!1,this.colorsDistributionType=S.colorDistributionType??0,this.colorsSampling=S.colorsSampling??L.d.NEAREST_NEAREST,this.colorMode=S.colorMode??0,this._colors=S.qb??null,this._cameraFacing=S.cameraFacing??!0,this.resolution=S.resolution??new Q.Vector2(d.getRenderWidth(),d.getRenderHeight()),S.colorsTexture?this.colorsTexture=S.colorsTexture:this._colors?this.colorsTexture=qb.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,X):(this._color=this._color??ob.DEFAULT_COLOR,this.colorsTexture=qb.PrepareEmptyColorsTexture(X)),N){const b=new pb.e;b.setParameters(),b.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",b)}d.Nd.add((()=>{qb.DisposeEmptyColorsTexture()}))}dispose(){var b;null===(b=this._colorsTexture)||void 0===b||b.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new Q.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get qb(){return this._colors}set qb(b){this.setColors(b)}setColors(b){var X;let P=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const S=(null===(X=this._colors)||void 0===X?void 0:X.length)??0;var d;if(this._colors=b,null!==b&&0!==b.length){if(!P||Q)if(this._colorsTexture&&S===b.length&&!Q){const X=qb.Color3toRGBAUint8(b);this._colorsTexture.update(X)}else{var N;null===(N=this._colorsTexture)||void 0===N||N.dispose(),this.colorsTexture=qb.CreateColorsTexture(`${this.name}-colors-texture`,b,this.colorsSampling,this.Ab())}}else null===(d=this._colorsTexture)||void 0===d||d.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(b){this._colorsTexture=b,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(b){this._width=b,this.setFloat("grlWidth",b)}get useColors(){return this._useColors}set useColors(b){this._useColors=b,this.setFloat("grlUseColors",qb.BooleanToNumber(b))}get colorsSampling(){return this._colorsSampling}set colorsSampling(b){this._colorsSampling=b}get visibility(){return this._visibility}set visibility(b){this._visibility=b,this.setFloat("grlVisibility",b)}get useDash(){return this._useDash}set useDash(b){this._useDash=b,this.setFloat("grlUseDash",qb.BooleanToNumber(b))}get dashOffset(){return this._dashOffset}set dashOffset(b){this._dashOffset=b,this.setFloat("grlDashOffset",b)}get dashRatio(){return this._dashRatio}set dashRatio(b){this._dashRatio=b,this.setFloat("grlDashRatio",b)}get dashCount(){return this._dashCount}set dashCount(b){this._dashCount=b,this._dashArray=1/b,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(b){this._sizeAttenuation=b,this.setFloat("grlSizeAttenuation",qb.BooleanToNumber(b))}get color(){return this._color}set color(b){this.setColor(b)}setColor(b){b=b??ob.DEFAULT_COLOR,this._color=b,this.setColor3("grlColor",b)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(b){this._colorsDistributionType=b,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(b){this._colorMode=b,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(b){this._resolution=b,this.setVector2("grlResolution",b),this.setFloat("grlAspect",b.x/b.y)}serialize(){const b=super.serialize(),X={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(X.qb=this._colors),b.greasedLineMaterialOptions=X,b}parse(b,X,P){var Q;const S=b.greasedLineMaterialOptions;null===(Q=this._colorsTexture)||void 0===Q||Q.dispose(),S.color&&(this.color=S.color),S.colorDistributionType&&(this.colorsDistributionType=S.colorDistributionType),S.colorsSampling&&(this.colorsSampling=S.colorsSampling),S.colorMode&&(this.colorMode=S.colorMode),S.useColors&&(this.useColors=S.useColors),S.visibility&&(this.visibility=S.visibility),S.useDash&&(this.useDash=S.useDash),S.dashCount&&(this.dashCount=S.dashCount),S.dashRatio&&(this.dashRatio=S.dashRatio),S.dashOffset&&(this.dashOffset=S.dashOffset),S.width&&(this.width=S.width),S.sizeAttenuation&&(this.sizeAttenuation=S.sizeAttenuation),S.resolution&&(this.resolution=S.resolution),S.qb?this.colorsTexture=qb.CreateColorsTexture(`${this.name}-colors-texture`,S.qb,this.colorsSampling,this.Ab()):this.colorsTexture=qb.PrepareEmptyColorsTexture(X),this._cameraFacing=S.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var zb,Ub,gb;kb.ForceGLSL=!1,function(b){b[b.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",b[b.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(zb||(zb={})),function(b){b[b.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",b[b.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",b[b.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Ub||(Ub={})),function(b){b[b.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",b[b.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",b[b.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",b[b.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",b[b.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(gb||(gb={}));class jb extends Wb.b{constructor(b,X,P){super(b,X,null,null,!1,!1),this.name=b,this._options=P,this._lazy=!1,this._updatable=!1,this._engine=X.getEngine(),this._lazy=P.lazy??!1,this._updatable=P.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=P.colorPointers??[],this._widths=P.widths??new Array(P.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(b){let X=0;for(const Q of this._points)X+=Q.length;const P=X/3*2-this._widths.length;for(let Q=0;Q<P;Q++)this._widths.push(b)}updateLazy(){var b,X;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(b=this._options.ribbonOptions)||void 0===b?void 0:b.smoothShading),!this.Hb&&this.refreshBoundingInfo(),null===(X=this.greasedLineMaterial)||void 0===X||X.updateLazy()}addPoints(b,X){for(const P of b)this._points.push(P);this._lazy||this.setPoints(this._points,X)}dispose(b){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(b,X)}isLazy(){return this._lazy}get Vb(){return this._uvs}set Vb(b){this._uvs=b instanceof Float32Array?b:new Float32Array(b),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(b){this.material instanceof kb&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===b||void 0===b?void 0:b.length)>0),this._offsets=b,this._offsetsBuffer?this._offsetsBuffer.update(b):this._createOffsetsBuffer(b)}get widths(){return this._widths}set widths(b){this._widths=b,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(b)}get colorPointers(){return this._colorPointers}set colorPointers(b){this._colorPointers=b,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(b)}get greasedLineMaterial(){var b,X;if(this.material&&this.material instanceof kb)return this.material;const P=null===(b=this.material)||void 0===b||null===(X=b.pluginManager)||void 0===X?void 0:X.getPlugin(ib.GREASED_LINE_MATERIAL_NAME);return P||void 0}get points(){const b=[];return Hb.b.DeepCopy(this._points,b),b}setPoints(b,X){this._points=qb.ConvertPoints(b,(null===X||void 0===X?void 0:X.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==X&&void 0!==X&&X.colorPointers||this._updateColorPointers(),this._setPoints(this._points,X)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Vb:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(b){super.serialize(b),b.type=this.getClassName(),b.lineOptions=this._createLineOptions()}_createVertexBuffers(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=new xb.e;return X.Kb=this._vertexPositions,X.indices=this._indices,X.Vb=this._uvs,b&&(X.Tb=[],xb.e.ComputeNormals(this._vertexPositions,this._indices,X.Tb)),X.xb(this,this._options.updatable),X}_createOffsetsBuffer(b){const X=this._scene.getEngine(),P=new f.c(X,b,this._updatable,3);this.setVerticesBuffer(P.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=P}}class lb{constructor(b,X){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=b,this.wasAddedByNoopNode=X}getIndicesAccessor(b,X,P,Q,S){var d,N,a,u;return null===(d=this._indicesAccessorMap.get(b))||void 0===d||null===(N=d.get(X))||void 0===N||null===(a=N.get(P))||void 0===a||null===(u=a.get(Q))||void 0===u?void 0:u.get(S)}setIndicesAccessor(b,X,P,Q,S,d){let N=this._indicesAccessorMap.get(b);N||(N=new Map,this._indicesAccessorMap.set(b,N));let a=N.get(X);a||(a=new Map,N.set(X,a));let u=a.get(P);u||(u=new Map,a.set(P,u));let w=u.get(Q);w||(w=new Map,u.set(Q,w)),w.set(S,d)}pushExportedNode(b){this._exportedNodes.has(b)||this._exportedNodes.add(b)}getNodesSet(){return this._exportedNodes}getVertexBufferView(b){return this._vertexBufferViewMap.get(b)}setVertexBufferView(b,X){this._vertexBufferViewMap.set(b,X)}setRemappedBufferView(b,X,P){this._remappedBufferView.set(b,new Map),this._remappedBufferView.get(b).set(X,P)}getRemappedBufferView(b,X){var P;return null===(P=this._remappedBufferView.get(b))||void 0===P?void 0:P.get(X)}getVertexAccessor(b,X,P){var Q,S;return null===(Q=this._vertexAccessorMap.get(b))||void 0===Q||null===(S=Q.get(X))||void 0===S?void 0:S.get(P)}setVertexAccessor(b,X,P,Q){let S=this._vertexAccessorMap.get(b);S||(S=new Map,this._vertexAccessorMap.set(b,S));let d=S.get(X);d||(d=new Map,S.set(X,d)),d.set(P,Q)}hasVertexColorAlpha(b){return this._vertexMapColorAlpha.get(b)||!1}setHasVertexColorAlpha(b,X){return this._vertexMapColorAlpha.set(b,X)}getMesh(b){return this._meshMap.get(b)}setMesh(b,X){this._meshMap.set(b,X)}bindMorphDataToMesh(b,X){const P=this._meshMorphTargetMap.get(b)||[];this._meshMorphTargetMap.set(b,P),-1===P.indexOf(X)&&P.push(X)}getMorphTargetsFromMesh(b){return this._meshMorphTargetMap.get(b)}}class Jb{_ApplyExtension(b,X,P,Q){if(P>=X.length)return Promise.resolve(b);const S=Q(X[P],b);return S?S.then((async b=>b?await this._ApplyExtension(b,X,P+1,Q):null)):this._ApplyExtension(b,X,P+1,Q)}_ApplyExtensions(b,X){const P=[];for(const Q of Jb._ExtensionNames)P.push(this._extensions[Q]);return this._ApplyExtension(b,P,0,X)}_extensionsPreExportTextureAsync(b,X,P){return this._ApplyExtensions(X,((X,Q)=>X.preExportTextureAsync&&X.preExportTextureAsync(b,Q,P)))}_extensionsPostExportNodeAsync(b,X,P,Q,S){return this._ApplyExtensions(X,((X,d)=>X.postExportNodeAsync&&X.postExportNodeAsync(b,d,P,Q,S,this._bufferManager)))}_extensionsPostExportMaterialAsync(b,X,P){return this._ApplyExtensions(X,((X,Q)=>X.postExportMaterialAsync&&X.postExportMaterialAsync(b,Q,P)))}_extensionsPostExportMaterialAdditionalTextures(b,X,P){const Q=[];for(const S of Jb._ExtensionNames){const d=this._extensions[S];d.postExportMaterialAdditionalTextures&&Q.push(...d.postExportMaterialAdditionalTextures(b,X,P))}return Q}_extensionsPostExportTextures(b,X,P){for(const Q of Jb._ExtensionNames){const S=this._extensions[Q];S.postExportTexture&&S.postExportTexture(b,X,P)}}_extensionsPostExportMeshPrimitive(b){for(const X of Jb._ExtensionNames){const P=this._extensions[X];P.postExportMeshPrimitive&&P.postExportMeshPrimitive(b,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const b of Jb._ExtensionNames){const X=this._extensions[b];X.preGenerateBinaryAsync&&await X.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(b){for(const X of Jb._ExtensionNames){const P=this._extensions[X];P.enabled&&b(P)}}_extensionsOnExporting(){this._forEachExtensions((b=>{var X,P,Q;b.wasUsed&&((X=this._glTF).extensionsUsed||(X.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(b.name)&&this._glTF.extensionsUsed.push(b.name),b.required&&((P=this._glTF).extensionsRequired||(P.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(b.name)&&this._glTF.extensionsRequired.push(b.name)),(Q=this._glTF).extensions||(Q.extensions={}),b.onExporting&&b.onExporting())}))}_loadExtensions(){for(const b of Jb._ExtensionNames){const X=Jb._ExtensionFactories[b](this);this._extensions[b]=X}}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:E.e.LastCreatedScene,X=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${D.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new p(this),this._extensions={},this._bufferManager=new fb,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!b)throw new Error("No scene available to export");this._babylonScene=b,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:b=>{var X;return null===b||void 0===b||null===(X=b.ed)||void 0===X?void 0:X.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...X},this._loadExtensions()}dispose(){for(const b in this._extensions){this._extensions[b].dispose()}}get options(){return this._options}static RegisterExtension(b,X){Jb.UnregisterExtension(b)&&S.Tools.Warn(`Extension with the name ${b} already exists`),Jb._ExtensionFactories[b]=X,Jb._ExtensionNames.push(b)}static UnregisterExtension(b){if(!Jb._ExtensionFactories[b])return!1;delete Jb._ExtensionFactories[b];const X=Jb._ExtensionNames.indexOf(b);return-1!==X&&Jb._ExtensionNames.splice(X,1),!0}_generateJSON(b,X,P){const Q={byteLength:b};return Q.byteLength&&(this._glTF.buffers=[Q]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.WX=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(Q.uri=X+".bin"),P?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(b){const X=await this._generateBinaryAsync();this._extensionsOnExporting();const P=this._generateJSON(X.byteLength,b,!0),Q=new Blob([X],{type:"application/octet-stream"}),S=b+".gltf",d=b+".bin",N=new w;if(N.files[S]=P,N.files[d]=Q,this._imageData)for(const a in this._imageData)N.files[a]=new Blob([this._imageData[a].data],{type:this._imageData[a].mimeType});return N}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(b){const X=b%4;return 0===X?X:4-X}async generateGLBAsync(b){this._shouldUseGlb=!0;const X=await this._generateBinaryAsync();this._extensionsOnExporting();const P=this._generateJSON(X.byteLength),Q=b+".glb";let S,d=P.length;if("undefined"!==typeof TextEncoder){S=(new TextEncoder).encode(P),d=S.length}const N=this._getPadding(d),a=this._getPadding(X.byteLength),u=28+d+N+X.byteLength+a,f=new ub(u);if(f.writeUInt32(1179937895),f.writeUInt32(2),f.writeUInt32(u),f.writeUInt32(d+N),f.writeUInt32(1313821514),S)f.writeTypedArray(S);else{const b="_".charCodeAt(0);for(let X=0;X<d;++X){const Q=P.charCodeAt(X);Q!=P.codePointAt(X)?f.writeUInt8(b):f.writeUInt8(Q)}}for(let w=0;w<N;++w)f.writeUInt8(32);f.writeUInt32(X.byteLength+a),f.writeUInt32(5130562),f.writeTypedArray(X);for(let w=0;w<a;++w)f.writeUInt8(0);const O=new w;return O.files[Q]=new Blob([f.getOutputData()],{type:"application/octet-stream"}),O}_setNodeTransformation(b,X,P){if(X.getPivotPoint().equalsWithEpsilon(j,g.c)||S.Tools.Warn("Pivot points are not supported in the glTF serializer"),!X.position.equalsWithEpsilon(j,g.c)){const S=Q.TmpVectors.tX[0].N(X.position);P&&I(S),b.translation=S.Zd()}X.Fd.equalsWithEpsilon(J,g.c)||(b.scale=X.Fd.Zd());const d=X.rotationQuaternion||Q.Quaternion.FromEulerAngles(X.rotation.x,X.rotation.y,X.rotation.z);d.equalsWithEpsilon(l,g.c)||(P&&G(d),b.rotation=d.normalize().Zd())}_setCameraTransformation(b,X,P){if(!X.position.equalsWithEpsilon(j,g.c)){const S=Q.TmpVectors.tX[0].N(X.position);P&&I(S),b.translation=S.Zd()}const S=X.rotationQuaternion||Q.Quaternion.FromEulerAngles(X.rotation.x,X.rotation.y,X.rotation.z);P&&G(S),this._babylonScene.useRightHandedSystem||mb(S),S.equalsWithEpsilon(l,g.c)||(b.rotation=S.Zd())}_listAvailableCameras(){for(const b of this._babylonScene.cameras){const X={type:b.mode===eb.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(b.name&&(X.name=b.name),"perspective"===X.type)X.perspective={aspectRatio:b.getEngine().getAspectRatio(b),yfov:b.fovMode===eb.c.FOVMODE_VERTICAL_FIXED?b.fov:b.fov*b.getEngine().getAspectRatio(b),znear:b.Vd,zfar:b.maxZ};else if("orthographic"===X.type){const P=b.orthoLeft&&b.orthoRight?.5*(b.orthoRight-b.orthoLeft):.5*b.getEngine().getRenderWidth(),Q=b.orthoBottom&&b.orthoTop?.5*(b.orthoTop-b.orthoBottom):.5*b.getEngine().getRenderHeight();X.orthographic={xmag:P,ymag:Q,znear:b.Vd,zfar:b.maxZ}}this._camerasMap.set(b,X)}}_exportAndAssignCameras(){const b=Array.from(this._camerasMap.values());for(const X of b){const b=this._nodesCameraMap.get(X);if(void 0!==b){this._cameras.push(X);for(const X of b)X.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const b of this._babylonScene.skeletons){if(b.bones.length<=0)continue;const X={joints:[]};this._skinMap.set(b,X)}}_exportAndAssignSkeletons(){for(const b of this._babylonScene.skeletons){if(b.bones.length<=0)continue;const X=this._skinMap.get(b);if(void 0==X)continue;const P={},Q=[];let d=-1;for(let S=0;S<b.bones.length;++S){const X=b.bones[S],Q=X.getIndex()??S;-1!==Q&&(P[Q]=X,Q>d&&(d=Q))}for(let b=0;b<=d;++b){const d=P[b];Q.push(d.getAbsoluteInverseBindMatrix());const N=d.getTransformNode();if(null!==N){const b=this._nodeMap.get(N);N&&null!==b&&void 0!==b?X.joints.push(b):S.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else S.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const N=this._nodesSkinMap.get(X);if(X.joints.length>0&&void 0!==N){const b=64*Q.length,P=new Float32Array(b/4);Q.forEach(((b,X)=>{P.set(b.m,16*X)}));const S=this._bufferManager.createBufferView(P);this._accessors.push(this._bufferManager.createAccessor(S,"MAT4",5126,Q.length)),X.inverseBindMatrices=this._accessors.length-1,this._skins.push(X);for(const X of N)X.skin=this._skins.length-1}}}async _exportSceneAsync(){const b={nodes:[]};if(this._babylonScene.metadata){const X=this._options.metadataSelector(this._babylonScene.metadata);X&&(b.extras=X)}const X=new Array,P=new Array,Q=new Array;for(const a of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Nb(a,this._babylonScene.useRightHandedSystem)?Q.push(...a.getChildren()):this._babylonScene.useRightHandedSystem?X.push(a):P.push(a);this._listAvailableCameras(),this._listAvailableSkeletons();const S=new lb(!0,!1);b.nodes.push(...await this._exportNodesAsync(P,S));const d=new lb(!1,!1);b.nodes.push(...await this._exportNodesAsync(X,d));const N=new lb(!1,!0);b.nodes.push(...await this._exportNodesAsync(Q,N)),b.nodes.length&&this._scenes.push(b),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&yb._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,S.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(b){let X=this._shouldExportNodeMap.get(b);return void 0===X&&(X=this._options.shouldExportNode(b),this._shouldExportNodeMap.set(b,X)),X}async _exportNodesAsync(b,X){const P=new Array;this._exportBuffers(b,X);for(const Q of b)await this._exportNodeAsync(Q,P,X);return P}_collectBuffers(b,X,P,Q,S){if(this._shouldExportNode(b)&&b instanceof e.e&&b.Ud){const d=b.Ud.getVertexBuffers();if(d)for(const Q in d){if(!M(Q))continue;const N=d[Q];S.setHasVertexColorAlpha(N,b.hasVertexAlpha);const a=N._buffer,u=X.get(a)||[];X.set(a,u),-1===u.indexOf(N)&&u.push(N);const w=P.get(N)||[];P.set(N,w),-1===w.indexOf(b)&&w.push(b)}const N=b.morphTargetManager;if(N)for(let X=0;X<N.numTargets;X++){const P=N.getTarget(X),S=Q.get(P)||[];Q.set(P,S),-1===S.indexOf(b)&&S.push(b)}}for(const d of b.getChildren())this._collectBuffers(d,X,P,Q,S)}_exportBuffers(b,X){const P=new Map,Q=new Map,S=new Map;for(const a of b)this._collectBuffers(a,P,Q,S,X);const d=Array.from(P.keys());for(const a of d){const b=a.getData();if(!b)throw new Error("Buffer data is not available");const S=P.get(a);if(!S)continue;const d=S[0].byteStride;if(S.some((b=>b.byteStride!==d)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const N=Pb(b).slice();for(const X of S){const b=Q.get(X),{byteOffset:P,byteStride:S,componentCount:d,type:a,count:u,normalized:w,kind:O}=s(X,b);switch(O){case f.g.NormalKind:case f.g.TangentKind:(0,k.j)(N,P,S,d,a,u,w,(b=>{const X=Math.sqrt(b[0]*b[0]+b[1]*b[1]+b[2]*b[2]);if(X>0){const P=1/X;b[0]*=P,b[1]*=P,b[2]*=P}}));break;case f.g.ColorKind:{const X=b.filter((b=>b.material instanceof Eb.nX||null==b.material)).length;if(0==X)break;if(X!=b.length){z.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}a==f.g.UNSIGNED_BYTE&&z.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const Q=new t.yX,O=new t.Ba,e=this._babylonScene.getEngine().useExactSrgbConversions;(0,k.j)(N,P,S,d,a,u,w,(b=>{3===b.length?(Q.tP(b,0),Q.toLinearSpaceToRef(Q,e),Q.toArray(b,0)):(O.tP(b,0),O.toLinearSpaceToRef(O,e),O.toArray(b,0))}))}}}if(X.convertToRightHanded){for(const b of S){const X=Q.get(b),{byteOffset:P,byteStride:S,componentCount:d,type:a,count:u,normalized:w,kind:O}=s(b,X);switch(O){case f.g.PositionKind:case f.g.NormalKind:case f.g.TangentKind:(0,k.j)(N,P,S,d,a,u,w,(b=>{b[0]=-b[0]}))}}X.convertedToRightHandedBuffers.set(a,N)}const u=this._bufferManager.createBufferView(N,d);X.setVertexBufferView(a,u);const w=new Map;for(const X of S){const b=Q.get(X),{kind:P,totalVertices:S}=s(X,b);switch(P){case f.g.MatricesIndicesKind:case f.g.MatricesIndicesExtraKind:if(X.type==f.g.FLOAT){const b=X.getFloatData(S);null!==b&&w.set(X,b)}}}0!==w.size&&z.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const O=Array.from(w.keys());for(const P of O){const b=w.get(P);if(!b)continue;const Q=b.some((b=>b>=256)),S=new(Q?Uint16Array:Uint8Array)(b.length);for(let X=0;X<b.length;X++)S[X]=b[X];const d=this._bufferManager.createBufferView(S,4*(Q?2:1));X.setRemappedBufferView(a,P,d)}}const N=Array.from(S.keys());for(const a of N){const b=S.get(a);if(!b)continue;const P=hb(a,b[0],this._bufferManager,this._bufferViews,this._accessors,X.convertToRightHanded);for(const Q of b)X.bindMorphDataToMesh(Q,P)}}async _exportNodeAsync(b,X,P){let Q=this._nodeMap.get(b);if(void 0!==Q)return void(X.includes(Q)||X.push(Q));const S=await this._createNodeAsync(b,P);if(S){Q=this._nodes.length,this._nodes.push(S),this._nodeMap.set(b,Q),P.pushExportedNode(b),X.push(Q);const d={name:"runtime animations",channels:[],samplers:[]},N=[];this._babylonScene.animationGroups.length||(yb._CreateMorphTargetAnimationFromMorphTargetAnimations(b,d,N,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,P.convertToRightHanded,this._options.shouldExportAnimation),b.animations.length&&yb._CreateNodeAnimationFromNodeAnimations(b,d,N,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,P.convertToRightHanded,this._options.shouldExportAnimation)),d.channels.length&&d.samplers.length&&this._animations.push(d),N.forEach((b=>{b.channels.length&&b.samplers.length&&this._animations.push(b)}))}const d=S?[]:X;for(const N of b.getChildren())await this._exportNodeAsync(N,d,P);S&&d.length&&(S.children=d)}async _createNodeAsync(b,X){if(!this._shouldExportNode(b))return null;const P={};if(b.name&&(P.name=b.name),b.metadata){const X=this._options.metadataSelector(b.metadata);X&&(P.extras=X)}if(b instanceof O.b&&(this._setNodeTransformation(P,b,X.convertToRightHanded),b instanceof e.e)){const S=b instanceof Y.d?b.sourceMesh:b;if(S.hd&&S.hd.length>0&&(P.mesh=await this._exportMeshAsync(S,X)),b.skeleton){const X=this._skinMap.get(b.skeleton);var Q;if(void 0!==X)void 0===this._nodesSkinMap.get(X)&&this._nodesSkinMap.set(X,[]),null===(Q=this._nodesSkinMap.get(X))||void 0===Q||Q.push(P)}}if(b instanceof U.e){const Q=this._camerasMap.get(b);if(Q){var S;void 0===this._nodesCameraMap.get(Q)&&this._nodesCameraMap.set(Q,[]),this._setCameraTransformation(P,b,X.convertToRightHanded);const N=b.parent;if(null!==N&&Xb(b,N)){const b=this._nodeMap.get(N);if(void 0!==b){var d;const X=this._nodes[b];return bb(P,X),null===(d=this._nodesCameraMap.get(Q))||void 0===d||d.push(X),null}}null===(S=this._nodesCameraMap.get(Q))||void 0===S||S.push(P)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",P,b,this._nodeMap,X.convertToRightHanded)?P:(z.b.Warn(`Not exporting node ${b.name}`),null)}_exportIndices(b,X,P,Q,S,N,a,u,w){let f=b;w.mode=R(N);const O=a!==d.b.CounterClockWiseSideOrientation,e=!u.wasAddedByNoopNode&&O,Y=function(b){switch(b){case d.b.TriangleFillMode:case d.b.TriangleStripDrawMode:case d.b.TriangleFanDrawMode:return!0}return!1}(N)&&e;if(Y){if(N===d.b.TriangleStripDrawMode||N===d.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");w.mode=R(N);const a=X?new Uint32Array(Q):new Uint16Array(Q);if(b)for(let X=0;X+2<Q;X+=3)a[X]=b[P+X]+S,a[X+1]=b[P+X+2]+S,a[X+2]=b[P+X+1]+S;else for(let b=0;b+2<Q;b+=3)a[b]=b,a[b+1]=b+2,a[b+2]=b+1;f=a}else if(b&&0!==S){const d=X?new Uint32Array(Q):new Uint16Array(Q);for(let X=0;X<Q;X++)d[X]=b[P+X]+S;f=d}if(f){let d=u.getIndicesAccessor(b,P,Q,S,Y);if(void 0===d){const N=function(b,X,P,Q){if(b instanceof Uint16Array||b instanceof Uint32Array)return b;if(b instanceof Int32Array)return new Uint32Array(b.buffer,b.byteOffset,b.length);const S=b.slice(X,X+P);return Q?new Uint32Array(S):new Uint16Array(S)}(f,0,Q,X),a=this._bufferManager.createBufferView(N),w=X?5125:5123;this._accessors.push(this._bufferManager.createAccessor(a,"SCALAR",w,Q,0)),d=this._accessors.length-1,u.setIndicesAccessor(b,P,Q,S,Y,d)}w.indices=d}}_exportVertexBuffer(b,X,P,Q,S,d){const N=b.getKind();if(!M(N))return;if(N.startsWith("uv")&&!this._options.exportUnusedUVs&&(!X||!this._materialNeedsUVsSet.has(X)))return;let a=S.getVertexAccessor(b,P,Q);if(void 0===a){const X=S.convertedToRightHandedBuffers.get(b._buffer)||b._buffer.getData(),d=N===f.g.PositionKind?function(b,X,P,Q){const{byteOffset:S,byteStride:d,type:N,normalized:a}=X,u=X.getSize(),w=new Array(u).fill(1/0),f=new Array(u).fill(-1/0);return(0,k.j)(b,S+P*d,d,u,N,Q*u,a,(b=>{for(let X=0;X<u;X++)w[X]=Math.min(w[X],b[X]),f[X]=Math.max(f[X],b[X])})),{min:w,max:f}}(X,b,P,Q):void 0,u=(N===f.g.MatricesIndicesKind||N===f.g.MatricesIndicesExtraKind)&&b.type===f.g.FLOAT,w=u?f.g.UNSIGNED_BYTE:b.type,O=u?void 0:b.normalized,e=u?S.getRemappedBufferView(b._buffer,b):S.getVertexBufferView(b._buffer),Y=b.byteOffset+P*b.byteStride;this._accessors.push(this._bufferManager.createAccessor(e,function(b,X){if(b==f.g.ColorKind)return X?"VEC4":"VEC3";switch(b){case f.g.PositionKind:case f.g.NormalKind:return"VEC3";case f.g.TangentKind:case f.g.MatricesIndicesKind:case f.g.MatricesIndicesExtraKind:case f.g.MatricesWeightsKind:case f.g.MatricesWeightsExtraKind:return"VEC4";case f.g.UVKind:case f.g.UV2Kind:case f.g.UV3Kind:case f.g.UV4Kind:case f.g.UV5Kind:case f.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${b}`)}(N,S.hasVertexColorAlpha(b)),w,Q,Y,d,O)),a=this._accessors.length-1,S.setVertexAccessor(b,P,Q,a)}d.attributes[function(b){switch(b){case f.g.PositionKind:return"POSITION";case f.g.NormalKind:return"NORMAL";case f.g.TangentKind:return"TANGENT";case f.g.ColorKind:return"COLOR_0";case f.g.UVKind:return"TEXCOORD_0";case f.g.UV2Kind:return"TEXCOORD_1";case f.g.UV3Kind:return"TEXCOORD_2";case f.g.UV4Kind:return"TEXCOORD_3";case f.g.UV5Kind:return"TEXCOORD_4";case f.g.UV6Kind:return"TEXCOORD_5";case f.g.MatricesIndicesKind:return"JOINTS_0";case f.g.MatricesIndicesExtraKind:return"JOINTS_1";case f.g.MatricesWeightsKind:return"WEIGHTS_0";case f.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${b}`)}(N)]=a}async _exportMaterialAsync(b,X,P,Q){let S=this._materialMap.get(b);if(void 0===S){const Q=X&&Object.keys(X).some((b=>b.startsWith("uv")));if((b=b instanceof Yb.c?b.Wa[P.materialIndex]:b)instanceof Db.e)S=await this._materialExporter.exportPBRMaterialAsync(b,"image/png",Q);else{if(!(b instanceof Eb.nX))return void z.b.Warn(`Unsupported material '${b.name}' with type ${b.getClassName()}`);S=await this._materialExporter.exportStandardMaterialAsync(b,"image/png",Q)}this._materialMap.set(b,S)}Q.material=S}async _exportMeshAsync(b,X){var P;let Q=X.getMesh(b);if(void 0!==Q)return Q;const S={primitives:[]};Q=this._meshes.length,this._meshes.push(S),X.setMesh(b,Q);const N=b.isUnIndexed?null:b.ld(),a=null===(P=b.Ud)||void 0===P?void 0:P.getVertexBuffers(),u=X.getMorphTargetsFromMesh(b),w=b instanceof Lb.e,f=b instanceof jb,O=b.hd;if(a&&O&&O.length>0)for(const D of O){const P={attributes:{}},Q=D.zb()||this._babylonScene.defaultMaterial;if(f){var e,Y;const X={name:Q.name},S=b,d=t.yX.White(),N=(null===(e=S.material)||void 0===e?void 0:e.alpha)??1,a=(null===(Y=S.greasedLineMaterial)||void 0===Y?void 0:Y.color)??d;(!a.equalsWithEpsilon(d,g.c)||N<1)&&(X.pbrMetallicRoughness={baseColorFactor:[...a.Zd(),N]}),this._materials.push(X),P.material=this._materials.length-1}else if(w){const X={name:Q.name},S=b;(!S.color.equalsWithEpsilon(t.yX.White(),g.c)||S.alpha<1)&&(X.pbrMetallicRoughness={baseColorFactor:[...S.color.Zd(),S.alpha]}),this._materials.push(X),P.material=this._materials.length-1}else await this._exportMaterialAsync(Q,a,D,P);const O=w||f?d.b.LineListDrawMode:b.overrideRenderingFillMode??Q.fillMode,E=Q._getEffectiveOrientation(b);this._exportIndices(N,N?(0,k.c)(N,D.indexCount,D.indexStart,D.verticesStart):D.verticesCount>65535,N?D.indexStart:D.verticesStart,N?D.indexCount:D.verticesCount,-D.verticesStart,O,E,X,P);for(const b of Object.values(a))this._exportVertexBuffer(b,Q,D.verticesStart,D.verticesCount,X,P);if(u){P.targets=[];for(const b of u)P.targets.push(b.attributes)}S.primitives.push(P),this._extensionsPostExportMeshPrimitive(P)}if(u){S.weights=[],S.extras||(S.extras={}),S.extras.targetNames=[];for(const b of u)S.weights.push(b.influence),S.extras.targetNames.push(b.name)}return Q}}Jb._ExtensionNames=new Array,Jb._ExtensionFactories={};class cb{static async GLTFAsync(b,X,P){P&&P.exportWithoutWaitingForScene||await b.whenReadyAsync();const Q=new Jb(b,P),S=await Q.generateGLTFAsync(X.replace(/\.[^/.]+$/,""));return Q.dispose(),S}static async GLBAsync(b,X,P){P&&P.exportWithoutWaitingForScene||await b.whenReadyAsync();const Q=new Jb(b,P),S=await Q.generateGLBAsync(X.replace(/\.[^/.]+$/,""));return Q.dispose(),S}}P(12420);const sb="EXT_mesh_gpu_instancing";class Fb{constructor(b){this.name=sb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(b,X,P,S,d,N){return await new Promise((b=>{if(X&&P instanceof Wb.b&&P.hasThinInstances&&this._exporter){this._wasUsed=!0;const b=Q.tX.Zero(),S=Q.Quaternion.Identity(),a=Q.tX.One(),u=P.thinInstanceGetWorldMatrices(),w=Q.TmpVectors.tX[2],f=Q.TmpVectors.Quaternion[1],O=Q.TmpVectors.tX[3];let e=!1,Y=!1,D=!1;const E=new Float32Array(3*P.na),t=new Float32Array(4*P.na),B=new Float32Array(3*P.na);let W=0;for(const X of u)X.decompose(O,f,w),d&&(I(w),G(f)),E.set(w.Zd(),3*W),t.set(f.normalize().Zd(),4*W),B.set(O.Zd(),3*W),e=e||!w.equalsWithEpsilon(b),Y=Y||!f.equalsWithEpsilon(S),D=D||!O.equalsWithEpsilon(a),W++;const n={attributes:{}};e&&(n.attributes.TRANSLATION=this._buildAccessor(E,"VEC3",P.na,N)),Y&&(n.attributes.ROTATION=this._buildAccessor(t,"VEC4",P.na,N)),D&&(n.attributes.SCALE=this._buildAccessor(B,"VEC3",P.na,N)),X.extensions=X.extensions||{},X.extensions[sb]=n}b(X)}))}_buildAccessor(b,X,P,Q){const S=Q.createBufferView(b),d=Q.createAccessor(S,X,5126,P);return this._exporter._accessors.push(d),this._exporter._accessors.length-1}}Jb.RegisterExtension(sb,(b=>new Fb(b)));var Mb=P(12423),Rb=P(12435),rb=P(12438),Ib=P(12441);function Gb(b){return b===rb.b.PositionKind?"POSITION":b===rb.b.NormalKind?"NORMAL":b===rb.b.ColorKind?"COLOR":b.startsWith(rb.b.UVKind)?"TEX_COORD":"GENERIC"}const mX={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class bX extends Mb.d{static get DefaultAvailable(){return(0,Mb.i)(bX.DefaultConfiguration)}static get Default(){return bX._Default??(bX._Default=new bX),bX._Default}static ResetDefault(b){bX._Default&&(b||bX._Default.dispose(),bX._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(b,X){return{module:await(X||DracoEncoderModule)({wasmBinary:b})}}_getWorkerContent(){return`${Rb.k}(${Rb.n})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:bX.DefaultConfiguration)}async _encodeAsync(b,X,P){const Q=P?(0,Ib.d)(mX,P):mX;if(this._workerPoolPromise){const P=await this._workerPoolPromise;return await new Promise(((S,d)=>{P.push(((P,N)=>{const a=b=>{P.removeEventListener("error",a),P.removeEventListener("message",u),d(b),N()},u=b=>{"encodeMeshDone"===b.data.id&&(P.removeEventListener("error",a),P.removeEventListener("message",u),S(b.data.encodedMeshData),N())};P.addEventListener("error",a),P.addEventListener("message",u);const w=[];for(const X of b)w.push(X.data.buffer);X&&w.push(X.buffer),P.postMessage({id:"encodeMesh",attributes:b,indices:X,options:Q},w)}))}))}if(this._modulePromise){const P=await this._modulePromise;return(0,Rb.k)(P.module,b,X,Q)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(b,X){if(0==b.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");b instanceof Wb.b&&b.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===X||void 0===X?void 0:X.method)&&(z.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),X.method="MESH_SEQUENTIAL_ENCODING");const P=function(b){let X=b.ld(void 0,!0);return!X||X instanceof Uint32Array||X instanceof Uint16Array||(X=((0,k.c)(X,X.length)?Uint32Array:Uint16Array).from(X)),X}(b),Q=function(b,X){const P=[];for(const Q of b.getVerticesDataKinds()){if(null!==X&&void 0!==X&&X.includes(Q)){if(Q===rb.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const S=b.getVertexBuffer(Q),d=S.getSize(),N=(0,k.v)(S.getData(),d,S.type,S.byteOffset,S.byteStride,S.normalized,b.getTotalVertices(),!0);P.push({kind:Q,dracoName:Gb(Q),size:d,data:N})}return P}(b,null===X||void 0===X?void 0:X.excludedAttributes);return await this._encodeAsync(Q,P,X)}}bX.DefaultConfiguration={wasmUrl:`${S.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${S.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${S.Tools._DefaultCdnUrl}/draco_encoder.js`},bX._Default=null;const XX="KHR_draco_mesh_compression";class PX{get wasUsed(){return this._wasUsed}constructor(b){this.name=XX,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===b.options.meshCompressionMethod&&bX.DefaultAvailable}dispose(){}postExportMeshPrimitive(b,X,P){if(!this.enabled)return;if(4!==b.mode&&5!==b.mode)return void z.b.Warn("Cannot compress primitive with mode "+b.mode+".");const Q=[],S=[];let d=null;if(void 0!==b.indices){const N=P[b.indices],a=X.getBufferView(N);d=X.getData(a).slice(),Q.push(a),S.push(N)}const N=[];for(const[f,O]of Object.entries(b.attributes)){const b=P[O],d=X.getBufferView(b),u=F(b.type),w=(0,k.v)(X.getData(d),u,b.componentType,b.byteOffset||0,d.byteStride||(0,k.o)(b.componentType)*u,b.normalized||!1,b.count,!0);N.push({kind:f,dracoName:(a=f,"POSITION"===a?"POSITION":"NORMAL"===a?"NORMAL":a.startsWith("COLOR")?"COLOR":a.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:F(b.type),data:w}),Q.push(d),S.push(b)}var a;const u={method:b.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},w=bX.Default._encodeAsync(N,d,u).then((P=>{if(!P)return void z.b.Error("Draco encoding failed for primitive.");const d={bufferView:-1,attributes:P.attributeIds},N=X.createBufferView(P.data);X.setBufferView(d,N);for(const b of Q)this._bufferViewsUsed.add(b);for(const b of S)this._accessorsUsed.add(b);b.extensions||(b.extensions={}),b.extensions[XX]=d})).catch((b=>{z.b.Error("Draco encoding failed for primitive: "+b)}));this._encodePromises.push(w),this._wasUsed=!0}async preGenerateBinaryAsync(b){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((X=>{b.getPropertiesWithBufferView(X).every((b=>this._accessorsUsed.has(b)))&&b.removeBufferView(X)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Jb.RegisterExtension(XX,(b=>new PX(b)));var QX=P(12447);const SX="KHR_lights_punctual",dX={name:"",color:[1,1,1],ya:1,range:Number.MAX_VALUE},NX={innerConeAngle:0,outerConeAngle:Math.PI/4},aX=Q.tX.Backward();class uX{constructor(b){this.name=SX,this.enabled=!0,this.required=!1,this._exporter=b}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[SX]=this._lights}async postExportNodeAsync(b,X,P,S,d){return await new Promise((N=>{if(!(P instanceof nb.e))return void N(X);const a=P.getTypeID()==nb.e.LIGHTTYPEID_POINTLIGHT?"point":P.getTypeID()==nb.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":P.getTypeID()==nb.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!a||!(P instanceof QX.c))return z.b.Warn(`${b}: Light ${P.name} is not supported in ${SX}`),void N(X);if(P.falloffType!==nb.e.FALLOFF_GLTF&&z.b.Warn(`${b}: Light falloff for ${P.name} does not match the ${SX} specification!`),!P.position.equalsToFloats(0,0,0)){const b=Q.TmpVectors.tX[0].N(P.position);d&&I(b),X.translation=b.Zd()}if("point"!==a){const b=P.direction.normalizeToRef(Q.TmpVectors.tX[0]);d&&I(b);const S=Q.Quaternion.FromUnitVectorsToRef(aX,b,Q.TmpVectors.Quaternion[0]);Q.Quaternion.IsIdentity(S)||(X.rotation=S.Zd())}const u={type:a,name:P.name,color:P.ha.Zd(),ya:P.ya,range:P.range};if(Qb(u,dX),"spot"===a){const b=P;u.spot={innerConeAngle:b.innerAngle/2,outerConeAngle:b.angle/2},Qb(u.spot,NX)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(u);const w={Pd:this._lights.lights.length-1},f=P.parent;if(f&&Xb(P,f)){const b=S.get(f);if(b){const P=this._exporter._nodes[b];return bb(X,P),P.extensions||(P.extensions={}),P.extensions[SX]=w,void N(null)}}X.extensions||(X.extensions={}),X.extensions[SX]=w,N(X)}))}}Jb.RegisterExtension(SX,(b=>new uX(b)));var wX=P(12371);const fX="KHR_materials_anisotropy";class OX{constructor(b){this.name=fX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,X,P){const Q=[];return P instanceof wX.b&&P.anisotropy.isEnabled&&!P.anisotropy.legacy?(P.anisotropy.texture&&Q.push(P.anisotropy.texture),Q):[]}postExportMaterialAsync(b,X,P){return new Promise((b=>{if(P instanceof wX.b){if(!P.anisotropy.isEnabled||P.anisotropy.legacy)return void b(X);this._wasUsed=!0,X.extensions=X.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(P.anisotropy.texture),S={anisotropyStrength:P.anisotropy.ya,anisotropyRotation:P.anisotropy.angle,anisotropyTexture:Q??void 0};null!==S.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(P),X.extensions[fX]=S}b(X)}))}}Jb.RegisterExtension(fX,(b=>new OX(b)));const eX="KHR_materials_clearcoat";class YX{constructor(b){this.name=eX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,X,P){const Q=[];return P instanceof wX.b&&P.clearCoat.isEnabled?(P.clearCoat.texture&&Q.push(P.clearCoat.texture),!P.clearCoat.useRoughnessFromMainTexture&&P.clearCoat.textureRoughness&&Q.push(P.clearCoat.textureRoughness),P.clearCoat.bumpTexture&&Q.push(P.clearCoat.bumpTexture),Q):[]}postExportMaterialAsync(b,X,P){return new Promise((b=>{if(P instanceof wX.b){if(!P.clearCoat.isEnabled)return void b(X);this._wasUsed=!0,X.extensions=X.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(P.clearCoat.texture);let d;d=P.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(P.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(P.clearCoat.textureRoughness),P.clearCoat.isTintEnabled&&S.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${P.name}`),P.clearCoat.remapF0OnInterfaceChange&&S.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${P.name}`);const N=this._exporter._materialExporter.getTextureInfo(P.clearCoat.bumpTexture),a={clearcoatFactor:P.clearCoat.ya,clearcoatTexture:Q??void 0,clearcoatRoughnessFactor:P.clearCoat.roughness,clearcoatRoughnessTexture:d??void 0,clearcoatNormalTexture:N??void 0};null===a.clearcoatTexture&&null===a.clearcoatRoughnessTexture&&null===a.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(P),X.extensions[eX]=a}b(X)}))}}Jb.RegisterExtension(eX,(b=>new YX(b)));const DX="KHR_materials_diffuse_transmission";function EX(b,X){const P=X.subSurface;let Q=null;return P.translucencyIntensityTexture?Q=P.translucencyIntensityTexture:P.thicknessTexture&&P.useMaskFromThicknessTexture&&(Q=P.thicknessTexture),Q&&!P.useGltfStyleTextures?(z.b.Warn(`${b}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${X.name}`,1),null):Q}class tX{constructor(b){this.name=DX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,X,P){const Q=[];if(P instanceof Db.e&&this._isExtensionEnabled(P)){const X=EX(b,P);return X&&Q.push(X),P.subSurface.translucencyColorTexture&&Q.push(P.subSurface.translucencyColorTexture),Q}return Q}_isExtensionEnabled(b){if(b.unlit)return!1;const X=b.subSurface;return!!X.isTranslucencyEnabled&&(!b.unlit&&!X.useAlbedoToTintTranslucency&&X.useGltfStyleTextures&&1===X.volumeIndexOfRefraction&&0===X.minimumThickness&&0===X.maximumThickness)}postExportMaterialAsync(b,X,P){return new Promise((Q=>{if(P instanceof Db.e&&this._isExtensionEnabled(P)){this._wasUsed=!0;const Q=P.subSurface,S=EX(b,P),d=0==Q.translucencyIntensity?void 0:Q.translucencyIntensity,N=this._exporter._materialExporter.getTextureInfo(S)??void 0,a=!Q.translucencyColor||Q.translucencyColor.equalsFloats(1,1,1)?void 0:Q.translucencyColor.Zd(),u=this._exporter._materialExporter.getTextureInfo(Q.translucencyColorTexture)??void 0,w={diffuseTransmissionFactor:d,diffuseTransmissionTexture:N,diffuseTransmissionColorFactor:a,diffuseTransmissionColorTexture:u};(N||u)&&this._exporter._materialNeedsUVsSet.add(P),X.extensions=X.extensions||{},X.extensions[DX]=w}Q(X)}))}}Jb.RegisterExtension(DX,(b=>new tX(b)));const BX="KHR_materials_dispersion";class WX{constructor(){this.name=BX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(b){if(b.unlit)return!1;const X=b.subSurface;return!(!X.isRefractionEnabled&&!X.isDispersionEnabled)}postExportMaterialAsync(b,X,P){return new Promise((b=>{if(P instanceof Db.e&&this._isExtensionEnabled(P)){this._wasUsed=!0;const b={dispersion:P.subSurface.dispersion};X.extensions=X.extensions||{},X.extensions[BX]=b}b(X)}))}}Jb.RegisterExtension(BX,(()=>new WX));const nX="KHR_materials_emissive_strength";class yX{constructor(){this.name=nX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(b,X,P){return await new Promise((b=>{if(!(P instanceof Db.e))return b(X);const Q=P.emissiveColor.Zd(),S=Math.max(...Q);if(S>1){this._wasUsed=!0,X.extensions||(X.extensions={});const b={emissiveStrength:S},Q=P.emissiveColor.scale(1/b.emissiveStrength);X.emissiveFactor=Q.Zd(),X.extensions[nX]=b}return b(X)}))}}Jb.RegisterExtension(nX,(b=>new yX));const hX="KHR_materials_ior";class LX{constructor(){this.name=hX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(b){return!b.unlit&&(void 0!=b.indexOfRefraction&&1.5!=b.indexOfRefraction)}postExportMaterialAsync(b,X,P){return new Promise((b=>{if(P instanceof Db.e&&this._isExtensionEnabled(P)){this._wasUsed=!0;const b={ior:P.indexOfRefraction};X.extensions=X.extensions||{},X.extensions[hX]=b}b(X)}))}}Jb.RegisterExtension(hX,(b=>new LX));const ZX="KHR_materials_iridescence";class vX{constructor(b){this.name=ZX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,X,P){const Q=[];return P instanceof wX.b&&P.iridescence.isEnabled?(P.iridescence.texture&&Q.push(P.iridescence.texture),P.iridescence.thicknessTexture&&P.iridescence.thicknessTexture!==P.iridescence.texture&&Q.push(P.iridescence.thicknessTexture),Q):[]}postExportMaterialAsync(b,X,P){return new Promise((b=>{if(P instanceof wX.b){if(!P.iridescence.isEnabled)return void b(X);this._wasUsed=!0,X.extensions=X.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(P.iridescence.texture),S=this._exporter._materialExporter.getTextureInfo(P.iridescence.thicknessTexture),d={iridescenceFactor:P.iridescence.ya,iridescenceIor:P.iridescence.indexOfRefraction,iridescenceThicknessMinimum:P.iridescence.minimumThickness,iridescenceThicknessMaximum:P.iridescence.maximumThickness,iridescenceTexture:Q??void 0,iridescenceThicknessTexture:S??void 0};null===d.iridescenceTexture&&null===d.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(P),X.extensions[ZX]=d}b(X)}))}}Jb.RegisterExtension(ZX,(b=>new vX(b)));const AX="KHR_materials_sheen";class oX{constructor(b){this.name=AX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,X,P){return P instanceof Db.e&&P.sheen.isEnabled&&P.sheen.texture?[P.sheen.texture]:[]}async postExportMaterialAsync(b,X,P){return await new Promise((b=>{if(P instanceof Db.e){if(!P.sheen.isEnabled)return void b(X);this._wasUsed=!0,null==X.extensions&&(X.extensions={});const Q={sheenColorFactor:P.sheen.color.Zd(),sheenRoughnessFactor:P.sheen.roughness??0};null===Q.sheenColorTexture&&null===Q.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(P),P.sheen.texture&&(Q.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.texture)??void 0),P.sheen.textureRoughness&&!P.sheen.useRoughnessFromMainTexture?Q.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.textureRoughness)??void 0:P.sheen.texture&&P.sheen.useRoughnessFromMainTexture&&(Q.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.texture)??void 0),X.extensions[AX]=Q}b(X)}))}}Jb.RegisterExtension(AX,(b=>new oX(b)));const KX="KHR_materials_specular";class TX{constructor(b){this.name=KX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,X,P){const Q=[];return P instanceof Db.e&&this._isExtensionEnabled(P)?(P.metallicReflectanceTexture&&Q.push(P.metallicReflectanceTexture),P.reflectanceTexture&&Q.push(P.reflectanceTexture),Q):Q}_isExtensionEnabled(b){return!b.unlit&&(void 0!=b.metallicF0Factor&&1!=b.metallicF0Factor||void 0!=b.metallicReflectanceColor&&!b.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(b))}_hasTexturesExtension(b){return null!=b.metallicReflectanceTexture||null!=b.reflectanceTexture}postExportMaterialAsync(b,X,P){return new Promise((b=>{if(P instanceof Db.e&&this._isExtensionEnabled(P)){this._wasUsed=!0,X.extensions=X.extensions||{};const b=this._exporter._materialExporter.getTextureInfo(P.metallicReflectanceTexture)??void 0,Q=this._exporter._materialExporter.getTextureInfo(P.reflectanceTexture)??void 0,S={specularFactor:1==P.metallicF0Factor?void 0:P.metallicF0Factor,specularTexture:b,specularColorFactor:P.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:P.metallicReflectanceColor.Zd(),specularColorTexture:Q};this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),X.extensions[KX]=S}b(X)}))}}Jb.RegisterExtension(KX,(b=>new TX(b)));const qX="KHR_materials_transmission";class VX{constructor(b){this.name=qX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,X,P){const Q=[];return P instanceof Db.e&&this._isExtensionEnabled(P)?(P.subSurface.thicknessTexture&&Q.push(P.subSurface.thicknessTexture),Q):Q}_isExtensionEnabled(b){if(b.unlit)return!1;const X=b.subSurface;return X.isRefractionEnabled&&void 0!=X.refractionIntensity&&0!=X.refractionIntensity||this._hasTexturesExtension(b)}_hasTexturesExtension(b){return null!=b.subSurface.refractionIntensityTexture}async postExportMaterialAsync(b,X,P){if(P instanceof Db.e&&this._isExtensionEnabled(P)){this._wasUsed=!0;const Q=P.subSurface,S={transmissionFactor:0===Q.refractionIntensity?void 0:Q.refractionIntensity};if(this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),Q.refractionIntensityTexture)if(Q.useGltfStyleTextures){const b=await this._exporter._materialExporter.exportTextureAsync(Q.refractionIntensityTexture,"image/png");b&&(S.transmissionTexture=b)}else z.b.Warn(`${b}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);X.extensions||(X.extensions={}),X.extensions[qX]=S}return X}}Jb.RegisterExtension(qX,(b=>new VX(b)));const iX="KHR_materials_unlit";class xX{constructor(){this.name=iX,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(b,X,P){return new Promise((b=>{let Q=!1;P instanceof Db.e?Q=P.unlit:P instanceof Eb.nX&&(Q=P.disableLighting),Q&&(this._wasUsed=!0,null==X.extensions&&(X.extensions={}),X.extensions[iX]={}),b(X)}))}}Jb.RegisterExtension(iX,(()=>new xX));const HX="KHR_materials_volume";class CX{constructor(b){this.name=HX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,X,P){const Q=[];return P instanceof Db.e&&this._isExtensionEnabled(P)?(P.subSurface.thicknessTexture&&Q.push(P.subSurface.thicknessTexture),Q):Q}_isExtensionEnabled(b){if(b.unlit)return!1;const X=b.subSurface;return!(!X.isRefractionEnabled&&!X.isTranslucencyEnabled)&&(void 0!=X.maximumThickness&&0!=X.maximumThickness||void 0!=X.tintColorAtDistance&&X.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=X.tintColor&&X.tintColor!=t.yX.White()||this._hasTexturesExtension(b))}_hasTexturesExtension(b){return null!=b.subSurface.thicknessTexture}postExportMaterialAsync(b,X,P){return new Promise((b=>{if(P instanceof Db.e&&this._isExtensionEnabled(P)){this._wasUsed=!0;const b=P.subSurface,Q={thicknessFactor:0==b.maximumThickness?void 0:b.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(b.thicknessTexture)??void 0,attenuationDistance:b.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:b.tintColorAtDistance,attenuationColor:b.tintColor.equalsFloats(1,1,1)?void 0:b.tintColor.Zd()};this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),X.extensions=X.extensions||{},X.extensions[HX]=Q}b(X)}))}}Jb.RegisterExtension(HX,(b=>new CX(b)));const pX="EXT_materials_diffuse_roughness";class kX{constructor(b){this.name=pX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,X,P){const Q=[];return P instanceof wX.b&&P._baseDiffuseRoughness?(P._baseDiffuseRoughnessTexture&&Q.push(P._baseDiffuseRoughnessTexture),Q):[]}postExportMaterialAsync(b,X,P){return new Promise((b=>{if(P instanceof wX.b){if(!P._baseDiffuseRoughness)return void b(X);this._wasUsed=!0,X.extensions=X.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(P._baseDiffuseRoughnessTexture),S={diffuseRoughnessFactor:P._baseDiffuseRoughness,diffuseRoughnessTexture:Q??void 0};null!==S.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(P),X.extensions[pX]=S}b(X)}))}}Jb.RegisterExtension(pX,(b=>new kX(b)));const zX="KHR_texture_transform";class UX{constructor(){this.name=zX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(b,X,P){if(P.Ab()||S.Tools.Warn(`${b}: /*@__KEY__*/"scene" is not defined for Babylon texture ${P.name}!`),(0!==P.uAng||0!==P.vAng)&&(S.Tools.Warn(`${b}: Texture ${P.name} with rotation in the u or v axis is not supported in glTF.`),0!==P.uRotationCenter||0!==P.vRotationCenter))return;const Q={};let d=!1;if(0===P.uOffset&&0===P.vOffset||(Q.offset=[P.uOffset,P.vOffset],d=!0),1===P.uScale&&1===P.vScale||(Q.scale=[P.uScale,P.vScale],d=!0),0!==P.wAng){if(0!==P.uRotationCenter||0!==P.vRotationCenter){if(P.homogeneousRotationInUVTransform&&P.uScale!==P.vScale)return void S.Tools.Warn(`${b}: Texture ${P.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${zX}.`);S.Tools.Warn(`${b}: Texture ${P.name} with non-origin rotation center will be exported using an adjusted offset with ${zX}.`),Q.offset=function(b){const{uOffset:X,vOffset:P,uRotationCenter:Q,vRotationCenter:S,uScale:d,vScale:N,wAng:a}=b,u=Math.cos(a),w=Math.sin(a),f=Q*d,O=S*N;return[X+(f*(1-u)+O*w),P+(O*(1-u)-f*w)]}(P)}Q.rotation=-P.wAng,d=!0}0!==P.coordinatesIndex&&(Q.texCoord=P.coordinatesIndex,d=!0),d&&(this._wasUsed=!0,X.extensions||(X.extensions={}),X.extensions[zX]=Q)}}Jb.RegisterExtension(zX,(()=>new UX));class gX{static CreateSTL(b){let X=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",S=arguments.length>3&&void 0!==arguments[3]&&arguments[3],d=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],N=arguments.length>5&&void 0!==arguments[5]&&arguments[5],a=arguments.length>6&&void 0!==arguments[6]&&arguments[6],u=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const w=function(b,X,P){const S=[3*b[P],3*b[P+1],3*b[P+2]],d=[new Q.tX(X[S[0]],X[S[0]+2],X[S[0]+1]),new Q.tX(X[S[1]],X[S[1]+2],X[S[1]+1]),new Q.tX(X[S[2]],X[S[2]+2],X[S[2]+1])],N=d[0].BX(d[1]),a=d[2].BX(d[1]);return{v:d,n:Q.tX.Cross(a,N).normalize()}},O=function(b,X,P,Q){return X=e(b,X,P.x,Q),X=e(b,X,P.y,Q),e(b,X,P.z,Q)},e=function(b,X,P,Q){return b.setFloat32(X,P,Q),X+4},D=function(b){if(a){let X=b;b instanceof Y.d&&(X=b.sourceMesh);const P=X.getVerticesData(f.g.PositionKind,!0,!0);if(!P)return[];const S=Q.tX.Zero();let d;for(d=0;d<P.length;d+=3)Q.tX.TransformCoordinatesFromFloatsToRef(P[d],P[d+1],P[d+2],b.pd(!0),S).toArray(P,d);return P}return b.getVerticesData(f.g.PositionKind)||[]};a&&(N=!0);let E="",t=0,B=0;if(S){for(let P=0;P<b.length;P++){const X=b[P].ld();t+=X?X.length/3:0}const X=new ArrayBuffer(84+50*t);E=new DataView(X),B+=80,E.setUint32(B,t,d),B+=4}else u||(E="solid stlmesh\r\n");for(let Q=0;Q<b.length;Q++){const X=b[Q];!S&&u&&(E+="solid "+X.name+"\r\n"),!N&&X instanceof Wb.b&&X.bakeCurrentTransformIntoVertices();const P=D(X),a=X.ld()||[];for(let b=0;b<a.length;b+=3){const X=w(a,P,b);S?(B=O(E,B,X.n,d),B=O(E,B,X.v[0],d),B=O(E,B,X.v[1],d),B=O(E,B,X.v[2],d),B+=2):(E+="\tfacet normal "+X.n.x+" "+X.n.y+" "+X.n.z+"\r\n",E+="\t\touter loop\r\n",E+="\t\t\tvertex "+X.v[0].x+" "+X.v[0].y+" "+X.v[0].z+"\r\n",E+="\t\t\tvertex "+X.v[1].x+" "+X.v[1].y+" "+X.v[1].z+"\r\n",E+="\t\t\tvertex "+X.v[2].x+" "+X.v[2].y+" "+X.v[2].z+"\r\n",E+="\t\tendloop\r\n",E+="\tendfacet\r\n")}!S&&u&&(E+="endsolid "+name+"\r\n")}if(S||u||(E+="endsolid stlmesh"),X){const b=document.createElement("a"),X=new Blob([E],{type:"application/octet-stream"});b.href=window.URL.createObjectURL(X),b.download=P+".stl",b.click()}return E}}function jX(b,X){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const Q=[];for(let S=0;S<b.length/P;S++){const d=b[S*P],N=b[S*P+1],a=b[S*P+2];Q.push(`(${d.toPrecision(X.precision)}, ${N.toPrecision(X.precision)}, ${a.toPrecision(X.precision)})`)}return Q.join(", ")}function lX(b,X){const P=[];for(let Q=0;Q<b.length/2;Q++){const S=b[2*Q],d=b[2*Q+1];P.push(`(${S.toPrecision(X.precision)}, ${(1-d).toPrecision(X.precision)})`)}return P.join(", ")}function JX(b,X){const P=b.getVerticesData(f.g.PositionKind),Q=b.getVerticesData(f.g.NormalKind);if(P&&Q)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(b){var X;const P=null!==(X=b.ld())&&void 0!==X&&X.length?b.getTotalIndices():b.getTotalVertices();return Array(P/3).fill(3).join(", ")}(b)}]\n\t\tint[] faceVertexIndices = [${function(b){const X=b.ld(),P=[];if(null!==X)for(let Q=0;Q<X.length;Q++)P.push(X[Q]);else{const X=b.getTotalVertices();for(let b=0;b<X;b++)P.push(b)}return P.join(", ")}(b)}]\n\t\tnormal3f[] normals = [${jX(Q,X)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${jX(P,X)}]\n        ${function(b,X){let P="";for(let S=0;S<4;S++){const Q=S>0?S:"",d=b.getVerticesData(f.g.UVKind+(Q?Q+1:""));d&&(P+=`\n\t\ttexCoord2f[] primvars:st${Q} = [${lX(d,X)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const Q=b.getVerticesData(f.g.ColorKind);return Q&&(P+=`\n\tcolor3f[] primvars:displayColor = [${jX(Q,X,Q.length/b.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),P}(b,X)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function cX(b,X){return`\n        def "Geometry"\n        {\n        ${JX(b,X)}\n        }\n        `}function sX(b){let X='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return X+=b,fflate.strToU8(X)}function FX(b){const X=b.m;return`( ${MX(X,0)}, ${MX(X,4)}, ${MX(X,8)}, ${MX(X,12)} )`}function MX(b,X){return`(${b[X+0]}, ${b[X+1]}, ${b[X+2]}, ${b[X+3]})`}function RX(b){const X="Object_"+b.uniqueId,P=function(b){const X=b.getWorldMatrix().clone(),P=b.Ab().useRightHandedSystem;if(!P){let Q=b.parent;for(;Q;){if(Nb(Q,P)){X.multiplyToRef(Q.getWorldMatrix().invert(),X);break}Q=Q.parent}}return X.determinant()<0&&S.Tools.Warn(`Exporting mesh ${b.name} with negative scale. Result may look incorrect in destination engine.`),X}(b),Q=FX(P);return`def Xform "${X}" (\n\tprepend references = @./geometries/Geometry_${b.Ud.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${Q}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${b.material.uniqueId}>\n}\n\n`}function rX(b){switch(b){case Z.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case Z.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case Z.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function IX(b){return`(${b.x}, ${b.y})`}function GX(b){return`(${b.r}, ${b.g}, ${b.b})`}function mP(b,X,P,S,d,N){const a=b.getInternalTexture().uniqueId+"_"+b.invertY;d[a]=b;const u=b.coordinatesIndex>0?"st"+b.coordinatesIndex:"st",w=new Q.Vector2(b.uScale,b.vScale),f=new Q.Vector2(b.uOffset,b.vOffset),O=b.wAng,e=Math.sin(O),Y=Math.cos(O);return f.y=1-f.y-w.y,f.x+=e*w.x,f.y+=(1-Y)*w.y,`\n    def Shader "PrimvarReader_${P}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${u}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${P}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${X.uniqueId}/PrimvarReader_${P}.outputs:result>\n        float inputs:rotation = ${(O*(180/Math.PI)).toFixed(N.precision)}\n        float2 inputs:scale = ${IX(w)}\n        float2 inputs:translation = ${IX(f)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${b.uniqueId}_${P}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${a}.png@\n        float2 inputs:st.connect = </Materials/Material_${X.uniqueId}/Transform2d_${P}.outputs:result>\n        ${S?"float4 inputs:scale = "+function(b){return`(${b.r}, ${b.g}, ${b.b}, 1.0)`}(S):""}\n        token inputs:sourceColorSpace = "${b.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${rX(b.wrapU)}"\n        token inputs:wrapT = "${rX(b.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${X.needAlphaBlending()?"float outputs:a":""}\n    }`}function bP(b,X,P){const Q="\t\t\t",S=[],d=[],{diffuseMap:N,ha:a,alphaCutOff:u,emissiveMap:w,emissive:f,normalMap:O,roughnessMap:e,roughnessChannel:Y,roughness:D,metalnessMap:E,metalnessChannel:B,metalness:W,aoMap:n,aoMapChannel:y,aoMapIntensity:h,alphaMap:L,ior:Z,clearCoatEnabled:v,clearCoat:A,clearCoatMap:o,clearCoatRoughness:K,clearCoatRoughnessMap:T}=function(b){const X={diffuseMap:null,ha:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return b instanceof Eb.nX?{...X,diffuseMap:b.diffuseTexture,ha:b.diffuseColor,alphaCutOff:b.alphaCutOff,emissiveMap:b.emissiveTexture,emissive:b.emissiveColor,roughness:1,alphaMap:b.opacityTexture}:b instanceof wX.b?{...X,diffuseMap:b._albedoTexture,ha:b._albedoColor,alphaCutOff:b._alphaCutOff,emissiveMap:b._emissiveTexture,emissive:b._emissiveColor,normalMap:b._bumpTexture,roughnessMap:b._metallicTexture,roughnessChannel:b._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:b._roughness??1,metalnessMap:b._metallicTexture,metalnessChannel:b._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:b._metallic??0,aoMap:b._ambientTexture,aoMapChannel:b._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:b._ambientTextureStrength,alphaMap:b._opacityTexture,ior:b.subSurface.indexOfRefraction,clearCoatEnabled:b.clearCoat.isEnabled,clearCoat:b.clearCoat.ya,clearCoatMap:b.clearCoat.texture,clearCoatRoughness:b.clearCoat.roughness,clearCoatRoughnessMap:b.clearCoat.useRoughnessFromMainTexture?b.clearCoat.texture:b.clearCoat.textureRoughness}:X}(b);return null!==N?(S.push(`${Q}color3f inputs:diffuseColor.connect = </Materials/Material_${b.uniqueId}/Texture_${N.uniqueId}_diffuse.outputs:rgb>`),b.needAlphaBlending()?S.push(`${Q}float inputs:opacity.connect = </Materials/Material_${b.uniqueId}/Texture_${N.uniqueId}_diffuse.outputs:a>`):b.needAlphaTesting()&&(S.push(`${Q}float inputs:opacity.connect = </Materials/Material_${b.uniqueId}/Texture_${N.uniqueId}_diffuse.outputs:a>`),S.push(`${Q}float inputs:opacityThreshold = ${u}`)),d.push(mP(N,b,"diffuse",a,X,P))):S.push(`${Q}color3f inputs:diffuseColor = ${GX(a||t.yX.White())}`),null!==w?(S.push(`${Q}color3f inputs:emissiveColor.connect = </Materials/Material_${b.uniqueId}/Texture_${w.uniqueId}_emissive.outputs:rgb>`),d.push(mP(w,b,"emissive",f,X,P))):f&&f.toLuminance()>0&&S.push(`${Q}color3f inputs:emissiveColor = ${GX(f)}`),null!==O&&(S.push(`${Q}normal3f inputs:normal.connect = </Materials/Material_${b.uniqueId}/Texture_${O.uniqueId}_normal.outputs:rgb>`),d.push(mP(O,b,"normal",null,X,P))),null!==n&&(S.push(`${Q}float inputs:occlusion.connect = </Materials/Material_${b.uniqueId}/Texture_${n.uniqueId}_occlusion.outputs:${y}>`),d.push(mP(n,b,"occlusion",new t.yX(h,h,h),X,P))),null!==e?(S.push(`${Q}float inputs:roughness.connect = </Materials/Material_${b.uniqueId}/Texture_${e.uniqueId}_roughness.outputs:${Y}>`),d.push(mP(e,b,"roughness",new t.yX(D,D,D),X,P))):S.push(`${Q}float inputs:roughness = ${D}`),null!==E?(S.push(`${Q}float inputs:metallic.connect = </Materials/Material_${b.uniqueId}/Texture_${E.uniqueId}_metallic.outputs:${B}>`),d.push(mP(E,b,"metallic",new t.yX(W,W,W),X,P))):S.push(`${Q}float inputs:metallic = ${W}`),null!==L?(S.push(`${Q}float inputs:opacity.connect = </Materials/Material_${b.uniqueId}/Texture_${L.uniqueId}_opacity.outputs:r>`),S.push(`${Q}float inputs:opacityThreshold = 0.0001`),d.push(mP(L,b,"opacity",null,X,P))):S.push(`${Q}float inputs:opacity = ${b.alpha}`),v&&(null!==o?(S.push(`${Q}float inputs:clearcoat.connect = </Materials/Material_${b.uniqueId}/Texture_${o.uniqueId}_clearcoat.outputs:r>`),d.push(mP(o,b,"clearcoat",new t.yX(A,A,A),X,P))):S.push(`${Q}float inputs:clearcoat = ${A}`),null!==T?(S.push(`${Q}float inputs:clearcoatRoughness.connect = </Materials/Material_${b.uniqueId}/Texture_${T.uniqueId}_clearcoatRoughness.outputs:g>`),d.push(mP(T,b,"clearcoatRoughness",new t.yX(K,K,K),X,P))):S.push(`${Q}float inputs:clearcoatRoughness = ${K}`)),S.push(`${Q}float inputs:ior = ${Z}`),`\n\tdef Material "Material_${b.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${S.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${b.uniqueId}/PreviewSurface.outputs:surface>\n\n${d.join("\n")}\n\n\t}\n`}async function XP(b,X,P){const d={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...X};"undefined"===typeof fflate&&await S.Tools.LoadScriptAsync(d.fflateUrl);const N={};N[d.modelFileName]=null;let a='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';a+=function(b){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===b.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${b.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${b.planeAnchoringAlignment}"`:""}\n            `}(d);const u={};for(const Q of b.meshes){if(0===Q.getTotalVertices())continue;const b=Q,X=b.Ud,w=b.material;if(!w||!X||P&&!P(b))continue;if(-1!==["nX","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(w.getClassName())){const P="geometries/Geometry_"+X.uniqueId+".usda";if(!(P in N)){const b=cX(X,d);N[P]=sX(b)}w.uniqueId in u||(u[w.uniqueId]=w),a+=RX(b)}else S.Tools.Warn("USDZExportAsync does not support this material type: "+w.getClassName())}b.activeCamera&&d.exportCamera&&(a+=function(b,X){const P="Camera_"+b.uniqueId,S=FX(Q.Matrix.RotationY(Math.PI).multiply(b.getWorldMatrix()));if(b.mode===Z.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${P}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${S}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${b.Vd.toPrecision(X.precision)}, ${b.maxZ.toPrecision(X.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(b.orthoLeft||1)+Math.abs(b.orthoRight||1))).toPrecision(X.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(b.orthoTop||1)+Math.abs(b.orthoBottom||1))).toPrecision(X.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const Q=b.getEngine().getAspectRatio(b),d=X.cameraSensorWidth||35;return`def Camera "${P}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${S}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${b.Vd.toPrecision(X.precision)}, ${b.maxZ.toPrecision(X.precision)})\n\t\t\tfloat focalLength = ${(d/(2*Math.tan(.5*b.fov))).toPrecision(X.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(d*Q).toPrecision(X.precision)}\n\t\t\tfloat verticalAperture = ${(d/Q).toPrecision(X.precision)}            \n\t\t}\n\t\n\t`}}(b.activeCamera,d)),a+="\n            }\n        }\n    }";const w={};a+=function(b,X,P){const Q=[];for(const S in b){const d=b[S];Q.push(bP(d,X,P))}return`\n    def "Materials"\n{\n${Q.join("")}\n}\n\n`}(u,w,d),N[d.modelFileName]=fflate.strToU8(a);for(const Q in w){const b=w[Q],X=b.getSize(),P=await b.readPixels();if(!P)throw new Error("Texture data is not available");const S=await v.DumpTools.DumpDataAsync(X.width,X.height,P,"image/png",void 0,!1,!0);N[`textures/Texture_${Q}.png`]=new Uint8Array(S).slice()}let f=0;for(const Q in N){const b=N[Q];if(!b)continue;f+=34+Q.length;const X=63&f;if(4!==X){const P=new Uint8Array(64-X);N[Q]=[b,{extra:{12345:P}}]}f=b.length}return fflate.zipSync(N,{level:0})}}}]);