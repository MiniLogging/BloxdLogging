"use strict";(self.fyqbdzs5tyo=self.fyqbdzs5tyo||[]).push([[26],{11658:(V,I,A)=>{A.r(I),A.d(I,{EXT_materials_diffuse_roughness:()=>iI,EXT_mesh_gpu_instancing:()=>DV,GLTF2Export:()=>TV,GLTFData:()=>b,KHR_draco_mesh_compression:()=>AI,KHR_lights_punctual:()=>cI,KHR_materials_anisotropy:()=>PI,KHR_materials_clearcoat:()=>GI,KHR_materials_diffuse_transmission:()=>uI,KHR_materials_dispersion:()=>gI,KHR_materials_emissive_strength:()=>LI,KHR_materials_ior:()=>mI,KHR_materials_iridescence:()=>eI,KHR_materials_sheen:()=>QI,KHR_materials_specular:()=>rI,KHR_materials_transmission:()=>xI,KHR_materials_unlit:()=>RI,KHR_materials_volume:()=>NI,KHR_texture_transform:()=>vI,OBJExport:()=>Y,STLExport:()=>CI,USDZExportAsync:()=>IA,_ConvertToGLTFPBRMetallicRoughness:()=>f,_SolveMetallic:()=>x,__IGLTFExporterExtension:()=>H});var B=A(11231),F=A(11052),E=A(11561);class Y{static OBJ(V,I,A,Y){const H=[];let c=1,b=1;I&&(A||(A="mat"),H.push("mtllib "+A+".mtl"));for(let X=0;X<V.length;X++){const A=V[X],P=A.name||`mesh${X}}`;H.push(`o ${P}`);let J=null;if(Y){const V=A.YH(!0);J=new B.Matrix,V.invertToRef(J),A.bakeTransformIntoVertices(V)}if(I){const V=A.material;V&&H.push("usemtl "+V.id)}const G=A.HH;if(!G){F.Tools.Warn("No geometry is present on the mesh");continue}const w=G.getVerticesData("position"),t=G.getVerticesData("normal"),u=G.getVerticesData("uv"),W=G.cH();let g=0,o=0;if(!w||!W){F.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const L=V[0].sV().useRightHandedSystem?1:-1;for(let V=0;V<w.length;V+=3)H.push("v "+w[V]*L+" "+w[V+1]+" "+w[V+2]),g++;if(null!=t)for(let V=0;V<t.length;V+=3)H.push("vn "+t[V]*L+" "+t[V+1]+" "+t[V+2]);if(null!=u)for(let V=0;V<u.length;V+=2)H.push("vt "+u[V]+" "+u[V+1]),o++;const z=["","",""],m=(A.material||A.sV().defaultMaterial)._getEffectiveOrientation(A),[s,e]=m===E.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let V=0;V<W.length;V+=3){const I=[String(W[V]+c),String(W[V+s]+c),String(W[V+e]+c)],A=[String(W[V]+b),String(W[V+s]+b),String(W[V+e]+b)],B=I,F=null!=u?A:z,E=null!=t?I:z;H.push("f "+B[0]+"/"+F[0]+"/"+E[0]+" "+B[1]+"/"+F[1]+"/"+E[1]+" "+B[2]+"/"+F[2]+"/"+E[2])}Y&&J&&A.bakeTransformIntoVertices(J),c+=g,b+=o}return H.join("\n")}static MTL(V){const I=[],A=V.material;I.push("newmtl mat1"),I.push("  Ns "+A.specularPower.toFixed(4)),I.push("  Ni 1.5000"),I.push("  d "+A.alpha.toFixed(4)),I.push("  Tr 0.0000"),I.push("  Tf 1.0000 1.0000 1.0000"),I.push("  illum 2"),I.push("  Ka "+A.ambientColor.r.toFixed(4)+" "+A.ambientColor.g.toFixed(4)+" "+A.ambientColor.b.toFixed(4)),I.push("  Kd "+A.diffuseColor.r.toFixed(4)+" "+A.diffuseColor.g.toFixed(4)+" "+A.diffuseColor.b.toFixed(4)),I.push("  Ks "+A.specularColor.r.toFixed(4)+" "+A.specularColor.g.toFixed(4)+" "+A.specularColor.b.toFixed(4)),I.push("  Ke "+A.emissiveColor.r.toFixed(4)+" "+A.emissiveColor.g.toFixed(4)+" "+A.emissiveColor.b.toFixed(4));A.ambientTexture&&I.push("  map_Ka "+A.ambientTexture.name),A.diffuseTexture&&I.push("  map_Kd "+A.diffuseTexture.name),A.specularTexture&&I.push("  map_Ks "+A.specularTexture.name),A.bumpTexture&&I.push("  map_bump -imfchan z "+A.bumpTexture.name),A.opacityTexture&&I.push("  map_d "+A.opacityTexture.name);return I.join("\n")}}var H=0,c=A(11105);class b{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const V in this.files){const I=this.files[V],A=new Blob([I],{type:(0,c.j)(V)});F.Tools.Download(A,V)}}}var X=A(11300),P=A(11661),J=A(11669),G=A(11693),w=A(11359),t=A(11097),u=A(11276),W=A(11249);const g=W.HighestCommonFactor,o={...W,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:g};var L=A(11461),z=A(11207),m=A(11730),s=A(11738),e=A(11454);const S=1e-6,Q=new u.oI(.04,.04,.04),h=1024,r=u.oI.White(),M=u.oI.Black();function x(V,I,A){if(I<Q.r)return 0;const B=Q.r,F=V*A/(1-Q.r)+I-2*Q.r,E=F*F-4*B*(Q.r-I);return o.Clamp((-F+Math.sqrt(E))/(2*B),0,1)}function f(V){const I=V.diffuseColor.toLinearSpace(V.sV().getEngine().useExactSrgbConversions).scale(.5),A=V.alpha,F=function(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new B.Vector2(0,1),A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new B.Vector2(0,.1),F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new B.Vector2(0,.1),E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new B.Vector2(1300,.1);return function(V,I,A,B,F){return(1-V)*(1-V)*(1-V)*I+3*(1-V)*(1-V)*V*A+3*(1-V)*V*V*B+V*V*V*F}(Math.pow(V/E.x,.333333),I.y,A.y,F.y,E.y)}(o.Clamp(V.specularPower,0,h));return{baseColorFactor:[I.r,I.g,I.b,A],metallicFactor:0,roughnessFactor:F}}function R(V,I){I.needAlphaBlending()?V.alphaMode="BLEND":I.needAlphaTesting()&&(V.alphaMode="MASK",V.alphaCutoff=I.alphaCutOff)}function q(V,I,A){const B=new Uint8Array(V*I*4);for(let F=0;F<B.length;F+=4)B[F]=B[F+1]=B[F+2]=B[F+3]=255;return m.b.CreateRGBATexture(B,V,I,A)}function N(V){if(V instanceof Uint8Array){const I=V.length,A=new Float32Array(V.length);for(let B=0;B<I;++B)A[B]=V[B]/255;return A}if(V instanceof Float32Array)return V;throw new Error("Unsupported pixel format!")}class l{constructor(V){this._exporter=V,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(V){return V?this._textureMap.get(V)??null:null}async exportStandardMaterialAsync(V,I,A){const B=f(V),E={name:V.name};if(null==V.bH||V.bH||(V.twoSidedLighting||F.Tools.Warn(V.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),E.doubleSided=!0),A){const A=[],F=V.diffuseTexture;F&&A.push(this.exportTextureAsync(F,I).then((V=>{V&&(B.baseColorTexture=V)})));const Y=V.bumpTexture;Y&&A.push(this.exportTextureAsync(Y,I).then((V=>{V&&(E.normalTexture=V,1!==Y.level&&(E.normalTexture.scale=Y.level))})));const H=V.emissiveTexture;H&&(E.emissiveFactor=[1,1,1],A.push(this.exportTextureAsync(H,I).then((V=>{V&&(E.emissiveTexture=V)}))));const c=V.ambientTexture;c&&A.push(this.exportTextureAsync(c,I).then((V=>{if(V){const I={index:V.index};E.occlusionTexture=I}}))),A.length>0&&(this._exporter._materialNeedsUVsSet.add(V),await Promise.all(A))}(V.alpha<1||V.opacityTexture)&&(V.alphaMode===s.d.ALPHA_COMBINE?E.alphaMode="BLEND":F.Tools.Warn(V.name+": glTF 2.0 does not support alpha mode: "+V.alphaMode.toString())),V.emissiveColor&&!V.emissiveColor.equalsWithEpsilon(M,S)&&(E.emissiveFactor=V.emissiveColor.AH()),E.pbrMetallicRoughness=B,R(E,V),await this._finishMaterialAsync(E,V,I);const Y=this._exporter._materials;return Y.push(E),Y.length-1}async _finishMaterialAsync(V,I,A){const B=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",V,I),F=[];for(const E of B)F.push(this.exportTextureAsync(E,A));await Promise.all(F),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",V,I)}async _getImageDataAsync(V,I,B,F){const E=s.d.TEXTURETYPE_UNSIGNED_BYTE,Y=this._exporter._babylonScene,H=Y.getEngine(),c=H.createRawTexture(V,I,B,s.d.TEXTUREFORMAT_RGBA,!1,!0,z.e.NEAREST_SAMPLINGMODE,null,E);H.isWebGPU?await A.e(51).then(A.bind(A,13678)):await A.e(52).then(A.bind(A,13683)),await L.j.ApplyPostProcess("pass",c,Y,E,s.d.TEXTURE_NEAREST_SAMPLINGMODE,s.d.TEXTUREFORMAT_RGBA);const b=await H._readTexturePixels(c,I,B);return await e.DumpTools.DumpDataAsync(I,B,b,F,void 0,!0,!0)}_resizeTexturesToSameDimensions(V,I,A){const B=V?V.getSize():{width:0,height:0},F=I?I.getSize():{width:0,height:0};let E,Y;return B.width<F.width?(E=V&&V instanceof z.e?L.j.CreateResizedCopy(V,F.width,F.height,!0):q(F.width,F.height,A),Y=I):B.width>F.width?(Y=I&&I instanceof z.e?L.j.CreateResizedCopy(I,B.width,B.height,!0):q(B.width,B.height,A),E=V):(E=V,Y=I),{texture1:E,texture2:Y}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(V,I,A,B){const F=new Array;if(!V&&!I)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const E=V?V.sV():I?I.sV():null;if(E){var Y;const H=this._resizeTexturesToSameDimensions(V,I,E),c=null===(Y=H.texture1)||void 0===Y?void 0:Y.getSize();let b,X;const P=c.width,J=c.height,G=await H.texture1.readPixels(),w=await H.texture2.readPixels();if(!G)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(b=N(G),!w)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");X=N(w);const t=X.byteLength,W=new Uint8Array(t),g=new Uint8Array(t),o=4,L=M;let z=0,m=0;for(let V=0;V<J;++V)for(let I=0;I<P;++I){const B=(P*V+I)*o,F={diffuseColor:new u.oI(b[B],b[B+1],b[B+2]).toLinearSpace(E.getEngine().useExactSrgbConversions).multiply(A.diffuseColor),specularColor:new u.oI(X[B],X[B+1],X[B+2]).toLinearSpace(E.getEngine().useExactSrgbConversions).multiply(A.specularColor),glossiness:X[B+3]*A.glossiness},Y=this._convertSpecularGlossinessToMetallicRoughness(F);L.r=Math.max(L.r,Y.baseColor.r),L.g=Math.max(L.g,Y.baseColor.g),L.b=Math.max(L.b,Y.baseColor.b),z=Math.max(z,Y.metallic),m=Math.max(m,Y.roughness),g[B]=255*Y.baseColor.r,g[B+1]=255*Y.baseColor.g,g[B+2]=255*Y.baseColor.b,g[B+3]=H.texture1.BH?255*b[B+3]:255,W[B]=0,W[B+1]=255*Y.roughness,W[B+2]=255*Y.metallic,W[B+3]=255}const s={baseColor:L,metallic:z,roughness:m};let e=!1,Q=!1;for(let V=0;V<J;++V)for(let I=0;I<P;++I){const A=(P*V+I)*o;g[A]/=s.baseColor.r>S?s.baseColor.r:1,g[A+1]/=s.baseColor.g>S?s.baseColor.g:1,g[A+2]/=s.baseColor.b>S?s.baseColor.b:1;const B=u.oI.FromInts(g[A],g[A+1],g[A+2]).toGammaSpace(E.getEngine().useExactSrgbConversions);g[A]=255*B.r,g[A+1]=255*B.g,g[A+2]=255*B.b,B.equalsWithEpsilon(r,S)||(Q=!0),W[A+1]/=s.roughness>S?s.roughness:1,W[A+2]/=s.metallic>S?s.metallic:1;u.oI.FromInts(255,W[A+1],W[A+2]).equalsWithEpsilon(r,S)||(e=!0)}return e&&F.push(this._getImageDataAsync(W,P,J,B).then((V=>{s.metallicRoughnessTextureData=V}))),Q&&F.push(this._getImageDataAsync(g,P,J,B).then((V=>{s.baseColorTextureData=V}))),await Promise.all(F).then((()=>s))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(V){const I=this._getPerceivedBrightness(V.diffuseColor),A=this._getPerceivedBrightness(V.specularColor),B=1-this._getMaxComponent(V.specularColor),F=x(I,A,B),E=V.diffuseColor.scale(B/(1-Q.r)/Math.max(1-F)),Y=V.specularColor.uI(Q.scale(1-F)).scale(1/Math.max(F));let H=u.oI.Lerp(E,Y,F*F);H=H.clampToRef(0,1,H);return{baseColor:H,metallic:F,roughness:1-V.glossiness}}_getPerceivedBrightness(V){return V?Math.sqrt(.299*V.r*V.r+.587*V.g*V.g+.114*V.b*V.b):0}_getMaxComponent(V){return V?Math.max(V.r,Math.max(V.g,V.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(V,I,A,B){const F=[],E={baseColor:V._albedoColor,metallic:V._metallic,roughness:V._roughness};if(B){V._albedoTexture&&F.push(this.exportTextureAsync(V._albedoTexture,I).then((V=>{V&&(A.baseColorTexture=V)})));const B=V._metallicTexture;B&&F.push(this.exportTextureAsync(B,I).then((V=>{V&&(A.metallicRoughnessTexture=V)})))}return F.length>0&&(this._exporter._materialNeedsUVsSet.add(V),await Promise.all(F)),E}_getTextureSampler(V){const I={};if(!V||!(V instanceof z.e))return I;const A=this._getGLTFTextureWrapMode(V.wrapU);10497!==A&&(I.wrapS=A);const B=this._getGLTFTextureWrapMode(V.wrapV);switch(10497!==B&&(I.wrapT=B),V.samplingMode){case z.e.LINEAR_LINEAR:I.magFilter=9729,I.minFilter=9729;break;case z.e.LINEAR_NEAREST:I.magFilter=9729,I.minFilter=9728;break;case z.e.NEAREST_LINEAR:I.magFilter=9728,I.minFilter=9729;break;case z.e.NEAREST_LINEAR_MIPLINEAR:I.magFilter=9728,I.minFilter=9987;break;case z.e.NEAREST_NEAREST:I.magFilter=9728,I.minFilter=9728;break;case z.e.NEAREST_LINEAR_MIPNEAREST:I.magFilter=9728,I.minFilter=9985;break;case z.e.LINEAR_NEAREST_MIPNEAREST:I.magFilter=9729,I.minFilter=9984;break;case z.e.LINEAR_NEAREST_MIPLINEAR:I.magFilter=9729,I.minFilter=9986;break;case z.e.NEAREST_NEAREST_MIPLINEAR:I.magFilter=9728,I.minFilter=9986;break;case z.e.LINEAR_LINEAR_MIPLINEAR:I.magFilter=9729,I.minFilter=9987;break;case z.e.LINEAR_LINEAR_MIPNEAREST:I.magFilter=9729,I.minFilter=9985;break;case z.e.NEAREST_NEAREST_MIPNEAREST:I.magFilter=9728,I.minFilter=9984}return I}_getGLTFTextureWrapMode(V){switch(V){case z.e.WRAP_ADDRESSMODE:return 10497;case z.e.CLAMP_ADDRESSMODE:return 33071;case z.e.MIRROR_ADDRESSMODE:return 33648;default:return F.Tools.Error(`Unsupported Texture Wrap Mode ${V}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(V,I,A,B){const F={diffuseColor:V._albedoColor,specularColor:V._reflectivityColor,glossiness:V._microSurface},E=V._albedoTexture,Y=V._reflectivityTexture,H=V._useMicroSurfaceFromReflectivityMapAlpha;if(Y&&!H)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((E||Y)&&B){this._exporter._materialNeedsUVsSet.add(V);const B=this._exportTextureSampler(E||Y),H=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(E,Y,F,I),c=this._exporter._textures;if(H.baseColorTextureData){const V=this._exportImage(`baseColor${c.length}`,I,H.baseColorTextureData);A.baseColorTexture=this._exportTextureInfo(V,B,null===E||void 0===E?void 0:E.coordinatesIndex)}if(H.metallicRoughnessTextureData){const V=this._exportImage(`metallicRoughness${c.length}`,I,H.metallicRoughnessTextureData);A.metallicRoughnessTexture=this._exportTextureInfo(V,B,null===Y||void 0===Y?void 0:Y.coordinatesIndex)}return H}return this._convertSpecularGlossinessToMetallicRoughness(F)}async exportPBRMaterialAsync(V,I,A){const B={},F={name:V.name},E=V.isMetallicWorkflow();if(E){const I=V._albedoColor,A=V.alpha;I&&(B.baseColorFactor=[I.r,I.g,I.b,A])}const Y=E?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(V,I,B,A):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(V,I,B,A);await this._setMetallicRoughnessPbrMaterialAsync(Y,V,F,B,I,A),await this._finishMaterialAsync(F,V,I);const H=this._exporter._materials;return H.push(F),H.length-1}async _setMetallicRoughnessPbrMaterialAsync(V,I,A,B,E,Y){if(R(A,I),V.baseColor.equalsWithEpsilon(r,S)&&o.WithinEpsilon(I.alpha,1,S)||(B.baseColorFactor=[V.baseColor.r,V.baseColor.g,V.baseColor.b,I.alpha]),null!=V.metallic&&1!==V.metallic&&(B.metallicFactor=V.metallic),null!=V.roughness&&1!==V.roughness&&(B.roughnessFactor=V.roughness),null==I.bH||I.bH||(I._twoSidedLighting||F.Tools.Warn(I.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),A.doubleSided=!0),Y){const V=[],B=I._bumpTexture;B&&V.push(this.exportTextureAsync(B,E).then((V=>{V&&(A.normalTexture=V,1!==B.level&&(A.normalTexture.scale=B.level))})));const F=I._ambientTexture;F&&V.push(this.exportTextureAsync(F,E).then((V=>{if(V){const B={index:V.index,texCoord:V.texCoord,extensions:V.extensions};A.occlusionTexture=B;const F=I._ambientTextureStrength;F&&(B.strength=F)}})));const Y=I._emissiveTexture;Y&&V.push(this.exportTextureAsync(Y,E).then((V=>{V&&(A.emissiveTexture=V)}))),V.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(V))}const H=I._emissiveColor;H.equalsWithEpsilon(M,S)||(A.emissiveFactor=H.AH()),A.pbrMetallicRoughness=B}_getPixelsFromTextureAsync(V){return function(V){switch(V){case s.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case s.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case s.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case s.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case s.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case s.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case s.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case s.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case s.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case s.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case s.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case s.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case s.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case s.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case s.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case s.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case s.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case s.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case s.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case s.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case s.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(V.textureFormat)?(0,L.f)(V,V._texture.width,V._texture.height):(V.textureType,s.d.TEXTURETYPE_UNSIGNED_BYTE,V.readPixels())}async exportTextureAsync(V,I){const A=this._exporter._extensionsPreExportTextureAsync("exporter",V,I);return A?await A.then((async A=>A?await this._exportTextureInfoAsync(A,I):await this._exportTextureInfoAsync(V,I))):await this._exportTextureInfoAsync(V,I)}async _exportTextureInfoAsync(V,I){let A=this._textureMap.get(V);if(!A){const B=await this._getPixelsFromTextureAsync(V);if(!B)return null;const E=this._exportTextureSampler(V),Y=V.mimeType;if(Y)switch(Y){case"image/jpeg":case"image/png":case"image/webp":I=Y;break;default:F.Tools.Warn(`Unsupported media type: ${Y}. Exporting texture as PNG.`)}const H=this._internalTextureToImage,c=V.getInternalTexture().uniqueId;H[c]||(H[c]={});let b=H[c][I];if(void 0===b){const A=V.getSize();b=(async()=>{const F=await this._getImageDataAsync(B,A.width,A.height,I);return this._exportImage(V.name,I,F)})(),H[c][I]=b}A=this._exportTextureInfo(await b,E,V.coordinatesIndex),this._textureMap.set(V,A),this._exporter._extensionsPostExportTextures("exporter",A,V)}return A}_exportImage(V,I,A){const B=this._exporter._images;let E;if(this._exporter._shouldUseGlb){E={name:V,mimeType:I,bufferView:void 0};const B=this._exporter._bufferManager.createBufferView(new Uint8Array(A));this._exporter._bufferManager.setBufferView(E,B)}else{const Y=V.replace(/\.\/|\/|\.\\|\\/g,"_"),H=function(V){switch(V){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(I);let c=Y+H;B.some((V=>V.uri===c))&&(c=`${Y}_${F.Tools.RandomId()}${H}`),E={name:V,uri:c},this._exporter._imageData[c]={data:A,mimeType:I}}return B.push(E),B.length-1}_exportTextureInfo(V,I,A){const B=this._exporter._textures;let F=B.findIndex((A=>A.sampler==I&&A.source===V));-1===F&&(F=B.length,B.push({source:V,sampler:I}));const E={index:F};return A&&(E.texCoord=A),E}_exportTextureSampler(V){const I=this._getTextureSampler(V),A=this._exporter._samplers,B=A.findIndex((V=>V.minFilter===I.minFilter&&V.magFilter===I.magFilter&&V.wrapS===I.wrapS&&V.wrapT===I.wrapT));return-1!==B?B:(A.push(I),A.length-1)}}var i=A(11311),y=A(11064),v=A(11746),C=A(11237);const K=B.tI.Zero(),p=B.Quaternion.Identity(),j=B.tI.One(),T=new B.tI(-1,1,1);function d(V,I){const{byteOffset:A,byteStride:B,type:F,normalized:E}=V,Y=V.getSize(),H=I.reduce(((V,I)=>I.getTotalVertices()>V?I.getTotalVertices():V),-Number.MAX_VALUE);return{byteOffset:A,byteStride:B,componentCount:Y,type:F,count:H*Y,normalized:E,totalVertices:H,kind:V.getKind()}}function D(V){switch(V){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function O(V){switch(V){case X.g.PositionKind:case X.g.NormalKind:case X.g.TangentKind:case X.g.ColorKind:case X.g.MatricesIndicesKind:case X.g.MatricesIndicesExtraKind:case X.g.MatricesWeightsKind:case X.g.MatricesWeightsExtraKind:case X.g.UVKind:case X.g.UV2Kind:case X.g.UV3Kind:case X.g.UV4Kind:case X.g.UV5Kind:case X.g.UV6Kind:return!0}return!1}function Z(V){switch(V){case E.c.TriangleFillMode:return 4;case E.c.TriangleStripDrawMode:return 5;case E.c.TriangleFanDrawMode:return 6;case E.c.PointListDrawMode:case E.c.PointFillMode:return 0;case E.c.LineLoopDrawMode:return 2;case E.c.LineListDrawMode:return 1;case E.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${V}`)}function a(V){const I=Math.sqrt(V.x*V.x+V.y*V.y+V.z*V.z);I>0&&(V.x/=I,V.y/=I,V.z/=I)}function k(V){return V.x*=-1,V}function U(V){if(V.x*V.x+V.y*V.y>.5){const I=Math.abs(V.x),A=Math.abs(V.y);if(I>A){const A=Math.sign(V.x);V.x=I,V.y*=-A,V.z*=-A,V.w*=A}else{const I=Math.sign(V.y);V.x*=-I,V.y=A,V.z*=I,V.w*=-I}}else{const I=Math.abs(V.z),A=Math.abs(V.w);if(I>A){const A=Math.sign(V.z);V.x*=-A,V.y*=A,V.z=I,V.w*=-A}else{const I=Math.sign(V.w);V.x*=I,V.y*=-I,V.z*=-I,V.w=A}}return V}function n(V){V.XH(-V.z,V.w,V.x,-V.y)}function VV(V,I){const A=B.tI.FromArrayToRef(I.translation||[0,0,0],0,B.TmpVectors.tI[0]),F=B.Quaternion.FromArrayToRef(I.rotation||[0,0,0,1],0,B.TmpVectors.Quaternion[0]),E=B.Matrix.ComposeToRef(j,F,A,B.TmpVectors.Matrix[0]),Y=B.tI.FromArrayToRef(V.translation||[0,0,0],0,B.TmpVectors.tI[2]),H=B.Quaternion.FromArrayToRef(V.rotation||[0,0,0,1],0,B.TmpVectors.Quaternion[1]),c=B.Matrix.ComposeToRef(j,H,Y,B.TmpVectors.Matrix[1]);E.multiplyToRef(c,c),c.decompose(void 0,F,A),A.equalsWithEpsilon(K,C.d)?delete I.translation:I.translation=A.AH(),F.equalsWithEpsilon(p,C.d)?delete I.rotation:I.rotation=F.AH(),I.scale&&delete I.scale}function IV(V,I){if(!(I instanceof P.e))return!1;if(!(1===I.getChildren().length&&0===V.getChildren().length&&V.parent===I))return!1;const A=V.sV(),B=V instanceof v.d&&!A.useRightHandedSystem?T:j;return!!I.PH.equalsWithEpsilon(B,C.d)||(y.b.Warn(`Cannot collapse node ${V.name} into parent node ${I.name} with modified scaling.`),!1)}function AV(V){if(V instanceof Array){const I=new Float32Array(V);return new Uint8Array(I.buffer,I.byteOffset,I.byteLength)}return ArrayBuffer.isView(V)?new Uint8Array(V.buffer,V.byteOffset,V.byteLength):new Uint8Array(V)}function BV(V,I){for(const[A,B]of Object.entries(V)){const F=I[A];(Array.isArray(B)&&Array.isArray(F)&&FV(B,F)||B===F)&&delete V[A]}return V}function FV(V,I){return V.length===I.length&&V.every(((V,A)=>V===I[A]))}const EV=B.Matrix.Compose(new B.tI(-1,1,1),B.Quaternion.Identity(),B.tI.Zero());function YV(V,I){if(!(V instanceof P.e))return!1;if(I){if(!V.getWorldMatrix().equalsWithEpsilon(B.Matrix.IdentityReadOnly,C.d))return!1}else{if(!V.getWorldMatrix().multiplyToRef(EV,B.TmpVectors.Matrix[0]).equalsWithEpsilon(B.Matrix.IdentityReadOnly,C.d))return!1}return!(V instanceof J.c&&V.HH)}const HV=new Map([[Int8Array,(V,I,A)=>V.setInt8(I,A)],[Uint8Array,(V,I,A)=>V.setUint8(I,A)],[Uint8ClampedArray,(V,I,A)=>V.setUint8(I,A)],[Int16Array,(V,I,A)=>V.setInt16(I,A,!0)],[Uint16Array,(V,I,A)=>V.setUint16(I,A,!0)],[Int32Array,(V,I,A)=>V.setInt32(I,A,!0)],[Uint32Array,(V,I,A)=>V.setUint32(I,A,!0)],[Float32Array,(V,I,A)=>V.setFloat32(I,A,!0)],[Float64Array,(V,I,A)=>V.setFloat64(I,A,!0)]]);class cV{writeTypedArray(V){this._checkGrowBuffer(V.byteLength);const I=HV.get(V.constructor);for(let A=0;A<V.length;A++)I(this._dataView,this._byteOffset,V[A]),this._byteOffset+=V.BYTES_PER_ELEMENT}constructor(V){this._data=new Uint8Array(V),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(V){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,V),this._byteOffset++}writeInt8(V){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,V),this._byteOffset++}writeInt16(V){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,V,!0),this._byteOffset+=2}writeUInt16(V){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,V,!0),this._byteOffset+=2}writeInt32(V){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,V,!0),this._byteOffset+=4}writeUInt32(V){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,V,!0),this._byteOffset+=4}writeFloat32(V){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,V,!0),this._byteOffset+=4}writeFloat64(V){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,V,!0),this._byteOffset+=8}_checkGrowBuffer(V){const I=this.byteOffset+V;if(I>this._data.byteLength){const V=new Uint8Array(2*I);V.set(this._data),this._data=V,this._dataView=new DataView(this._data.buffer)}}}function bV(V){return V%4===0?4:V%2===0?2:1}class XV{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(V){let I=0;this._bufferViewToData.forEach((V=>{I+=V.byteLength}));const A=new cV(I),B=Array.from(this._bufferViewToData.keys()).sort(((V,I)=>bV(I.byteLength)-bV(V.byteLength)));for(const F of B){F.byteOffset=A.byteOffset,V.push(F);const I=V.length-1,B=this.getPropertiesWithBufferView(F);for(const V of B)V.bufferView=I;A.writeTypedArray(this._bufferViewToData.get(F)),this._bufferViewToData.delete(F)}return A.getOutputData()}createBufferView(V,I){const A={buffer:0,byteOffset:void 0,byteLength:V.byteLength,byteStride:I};return this._bufferViewToData.set(A,V),A}createAccessor(V,I,A,B,F,E,Y){this._verifyBufferView(V);const H={bufferView:void 0,componentType:A,count:B,type:I,min:null===E||void 0===E?void 0:E.min,max:null===E||void 0===E?void 0:E.max,normalized:Y,byteOffset:F};return this.setBufferView(H,V),this._accessorToBufferView.set(H,V),H}setBufferView(V,I){this._verifyBufferView(I);this.getPropertiesWithBufferView(I).push(V)}removeBufferView(V){const I=this.getPropertiesWithBufferView(V);for(const A of I)void 0!==A.bufferView&&delete A.bufferView;this._bufferViewToData.delete(V),this._bufferViewToProperties.delete(V),this._accessorToBufferView.forEach(((I,A)=>{I===V&&(void 0!==A.byteOffset&&delete A.byteOffset,this._accessorToBufferView.delete(A))}))}getBufferView(V){const I=this._accessorToBufferView.get(V);return this._verifyBufferView(I),I}getPropertiesWithBufferView(V){return this._verifyBufferView(V),this._bufferViewToProperties.set(V,this._bufferViewToProperties.get(V)??[]),this._bufferViewToProperties.get(V)}getData(V){return this._verifyBufferView(V),this._bufferViewToData.get(V)}_verifyBufferView(V){if(void 0===V||!this._bufferViewToData.has(V))throw new Error(`BufferView ${V} not found in BufferManager.`)}}var PV,JV=A(11707),GV=A(11722),wV=A(11752),tV=A(11614),uV=A(11790),WV=A(11799),gV=A(11701),oV=A(11803);!function(V){V[V.INTANGENT=0]="INTANGENT",V[V.OUTTANGENT=1]="OUTTANGENT"}(PV||(PV={}));class LV{static _IsTransformable(V){return V&&(V instanceof P.e||V instanceof JV.c||V instanceof oV.c)}static _CreateNodeAnimation(V,I,A,B,E){if(this._IsTransformable(V)){const Y=[],H=[],c=I.getKeys(),b=LV._CalculateMinMaxKeyFrames(c),X=LV._DeduceInterpolation(c,A,B),P=X.interpolationType,J=X.shouldBakeAnimation;if(J?LV._CreateBakedAnimation(V,I,A,b.min,b.max,I.framePerSecond,E,Y,H,b,B):"LINEAR"===P||"STEP"===P?LV._CreateLinearOrStepAnimation(V,I,A,Y,H,B):"CUBICSPLINE"===P?LV._CreateCubicSplineAnimation(V,I,A,Y,H,B):LV._CreateBakedAnimation(V,I,A,b.min,b.max,I.framePerSecond,E,Y,H,b,B),Y.length&&H.length){return{inputs:Y,outputs:H,samplerInterpolation:P,inputsMin:J?b.min:F.Tools.FloatRound(b.min/I.framePerSecond),inputsMax:J?b.max:F.Tools.FloatRound(b.max/I.framePerSecond)}}}return null}static _DeduceAnimationInfo(V){let I=null,A="VEC3",B=!1;const E=V.targetProperty.split(".");switch(E[0]){case"PH":I="scale";break;case"position":I="translation";break;case"rotation":A="VEC4",I="rotation";break;case"rotationQuaternion":A="VEC4",B=!0,I="rotation";break;case"influence":A="SCALAR",I="weights";break;default:F.Tools.Error(`Unsupported animatable property ${E[0]}`)}return I?{animationChannelTargetPath:I,dataAccessorType:A,useQuaternion:B}:(F.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(V,I,A,B,F,E,Y,H,c,b,X){let P;if(LV._IsTransformable(V)&&V.animations)for(const J of V.animations){if(X&&!X(J))continue;const F=LV._DeduceAnimationInfo(J);F&&(P={name:J.name,samplers:[],channels:[]},LV._AddAnimation(`${J.name}`,J.hasRunningRuntimeAnimations?I:P,V,J,F.dataAccessorType,F.animationChannelTargetPath,B,E,Y,H,F.useQuaternion,c,b),P.samplers.length&&P.channels.length&&A.push(P))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(V,I,A,B,F,E,Y,H,c,b,X){let P;if(V instanceof gV.c){const F=V.morphTargetManager;if(F)for(let J=0;J<F.numTargets;++J){const G=F.getTarget(J);for(const w of G.animations){if(X&&!X(w))continue;const G=new uV.d(`${w.name}`,"influence",w.framePerSecond,w.dataType,w.loopMode,w.enableBlending),t=[],u=w.getKeys();for(let V=0;V<u.length;++V){const I=u[V];for(let V=0;V<F.numTargets;++V)V==J?t.push(I):t.push({frame:I.frame,value:0})}G.setKeys(t);const W=LV._DeduceAnimationInfo(G);W&&(P={name:G.name,samplers:[],channels:[]},LV._AddAnimation(w.name,w.hasRunningRuntimeAnimations?I:P,V,G,W.dataAccessorType,W.animationChannelTargetPath,B,E,Y,H,W.useQuaternion,c,b,F.numTargets),P.samplers.length&&P.channels.length&&A.push(P))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(V,I,A,B,F,E,Y,H,c){let b;if(V.animationGroups){const P=V.animationGroups;for(const J of P){const P=new Map,G=new Map,w=new Set,t=J.to-J.from;b={name:J.name,channels:[],samplers:[]};for(let I=0;I<J.targetedAnimations.length;++I){const t=J.targetedAnimations[I],u=t.target,W=t.animation;if(c&&!c(W))continue;const g=H.has(u);if(this._IsTransformable(u)||1===u.length&&this._IsTransformable(u[0])){const V=LV._DeduceAnimationInfo(t.animation);if(V){const I=this._IsTransformable(u)?u:this._IsTransformable(u[0])?u[0]:null;I&&LV._AddAnimation(`${W.name}`,b,I,W,V.dataAccessorType,V.animationChannelTargetPath,A,B,F,E,V.useQuaternion,Y,g)}}else if(u instanceof WV.b||1===u.length&&u[0]instanceof WV.b){if(LV._DeduceAnimationInfo(t.animation)){const I=u instanceof WV.b?u:u[0];if(I){const A=V.morphTargetManagers.find((V=>{for(let A=0;A<V.numTargets;++A)if(V.getTarget(A)===I)return!0;return!1}));if(A){const B=V.meshes.find((V=>V.morphTargetManager===A));var X;if(B)P.has(B)||P.set(B,new Map),null===(X=P.get(B))||void 0===X||X.set(I,W),w.add(B),G.set(B,W)}}}}}w.forEach((V=>{const I=V.morphTargetManager;let H=null;const c=[],X=G.get(V).getKeys(),w=X.length;for(let A=0;A<w;++A)for(let B=0;B<I.numTargets;++B){const F=I.getTarget(B),E=P.get(V);if(E){const I=E.get(F);I?(H||(H=new uV.d(`${J.name}_${V.name}_MorphWeightAnimation`,"influence",I.framePerSecond,uV.d.ANIMATIONTYPE_FLOAT,I.loopMode,I.enableBlending)),c.push(I.getKeys()[A])):c.push({frame:J.from+t/w*A,value:F.influence,inTangent:X[0].inTangent?0:void 0,outTangent:X[0].outTangent?0:void 0})}}H.setKeys(c);const u=LV._DeduceAnimationInfo(H);u&&LV._AddAnimation(`${J.name}_${V.name}_MorphWeightAnimation`,b,V,H,u.dataAccessorType,u.animationChannelTargetPath,A,B,F,E,u.useQuaternion,Y,!1,null===I||void 0===I?void 0:I.numTargets)})),b.channels.length&&b.samplers.length&&I.push(b)}}}static _AddAnimation(V,I,A,F,E,Y,H,c,b,X,P,J,G,w){const t=LV._CreateNodeAnimation(A,F,Y,P,J);let u,W,g,o,L,z;if(t){if(w){let V=0,I=0;const A=[];for(;t.inputs.length>0;)I=t.inputs.shift(),V%w==0&&A.push(I),V++;t.inputs=A}const V=H.get(A),F=new Float32Array(t.inputs);u=c.createBufferView(F),W=c.createAccessor(u,"SCALAR",5126,t.inputs.length,void 0,{min:[t.inputsMin],max:[t.inputsMax]}),X.push(W),g=X.length-1;const b=new B.Quaternion,P=new B.tI,J=new B.tI,m=A instanceof JV.c,s=D(E),e=new Float32Array(t.outputs.length*s);t.outputs.forEach((function(V,I){let A=V;switch(Y){case"translation":G&&(B.tI.FromArrayToRef(V,0,J),k(J),J.toArray(A));break;case"rotation":4===V.length?B.Quaternion.FromArrayToRef(V,0,b):(A=new Array(4),B.tI.FromArrayToRef(V,0,P),B.Quaternion.FromEulerVectorToRef(P,b)),G&&(U(b),m&&n(b)),b.toArray(A)}e.set(A,I*s)})),u=c.createBufferView(e),W=c.createAccessor(u,E,5126,t.outputs.length),X.push(W),o=X.length-1,L={interpolation:t.samplerInterpolation,input:g,output:o},I.samplers.push(L),z={sampler:I.samplers.length-1,target:{node:V,path:Y}},I.channels.push(z)}}static _CreateBakedAnimation(V,I,A,E,Y,H,c,b,X,P,J){let G;const w=B.Quaternion.Identity();let t,u=null,W=null,g=null,o=null,L=null,z=null;P.min=F.Tools.FloatRound(E/H);const m=I.getKeys();for(let B=0,s=m.length;B<s;++B){if(z=null,g=m[B],B+1<s)if(o=m[B+1],g.value.equals&&g.value.equals(o.value)||g.value===o.value){if(0!==B)continue;z=g.frame}else z=o.frame;else{if(L=m[B-1],g.value.equals&&g.value.equals(L.value)||g.value===L.value)continue;z=Y}if(z)for(let B=g.frame;B<=z;B+=c){if(t=F.Tools.FloatRound(B/H),t===u)continue;u=t,W=t;const E={key:0,repeatCount:0,loopMode:I.loopMode};G=I._interpolate(B,E),LV._SetInterpolatedValue(V,G,t,I,A,w,b,X,J)}}W&&(P.max=W)}static _ConvertFactorToVector3OrQuaternion(V,I,A,E,Y){const H=LV._GetBasePositionRotationOrScale(I,E,Y),c=A.targetProperty.split("."),b=c?c[1]:"",X=Y?B.Quaternion.LI(H).normalize():B.tI.LI(H);switch(b){case"x":case"y":case"z":X[b]=V;break;case"w":X.w=V;break;default:F.Tools.Error(`glTFAnimation: Unsupported component name "${b}"!`)}return X}static _SetInterpolatedValue(V,I,A,F,E,Y,H,c,b){let X;H.push(A),"weights"!==E?(F.dataType===uV.d.ANIMATIONTYPE_FLOAT&&(I=this._ConvertFactorToVector3OrQuaternion(I,V,F,E,b)),"rotation"===E?(b?Y=I:(X=I,B.Quaternion.RotationYawPitchRollToRef(X.y,X.x,X.z,Y)),c.push(Y.AH())):(X=I,c.push(X.AH()))):c.push([I])}static _CreateLinearOrStepAnimation(V,I,A,B,F,E){for(const Y of I.getKeys())B.push(Y.frame/I.framePerSecond),LV._AddKeyframeValue(Y,I,F,A,V,E)}static _CreateCubicSplineAnimation(V,I,A,B,F,E){I.getKeys().forEach((function(Y){B.push(Y.frame/I.framePerSecond),LV._AddSplineTangent(PV.INTANGENT,F,A,"CUBICSPLINE",Y,E),LV._AddKeyframeValue(Y,I,F,A,V,E),LV._AddSplineTangent(PV.OUTTANGENT,F,A,"CUBICSPLINE",Y,E)}))}static _GetBasePositionRotationOrScale(V,I,A){let F;if("rotation"===I)if(A){F=(V.rotationQuaternion??B.Quaternion.Identity()).AH()}else{F=(V.rotation??B.tI.Zero()).AH()}else if("translation"===I){F=(V.position??B.tI.Zero()).AH()}else{F=(V.PH??B.tI.One()).AH()}return F}static _AddKeyframeValue(V,I,A,E,Y,H){let c;const b=I.dataType;if(b===uV.d.ANIMATIONTYPE_VECTOR3){let I=V.value.AH();if("rotation"===E){const V=B.tI.LI(I);I=B.Quaternion.RotationYawPitchRoll(V.y,V.x,V.z).AH()}A.push(I)}else if(b===uV.d.ANIMATIONTYPE_FLOAT){if("weights"===E)A.push([V.value]);else if(c=this._ConvertFactorToVector3OrQuaternion(V.value,Y,I,E,H),c){if("rotation"===E){const V=H?c:B.Quaternion.RotationYawPitchRoll(c.y,c.x,c.z).normalize();A.push(V.AH())}A.push(c.AH())}}else b===uV.d.ANIMATIONTYPE_QUATERNION?A.push(V.value.normalize().AH()):F.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(V,I,A){let B,F,E=!1;if("rotation"===I&&!A)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let Y=0,H=V.length;Y<H;++Y)if(F=V[Y],F.inTangent||F.outTangent)if(B){if("CUBICSPLINE"!==B){B="LINEAR",E=!0;break}}else B="CUBICSPLINE";else if(B){if("CUBICSPLINE"===B||F.interpolation&&1===F.interpolation&&"STEP"!==B){B="LINEAR",E=!0;break}}else B=F.interpolation&&1===F.interpolation?"STEP":"LINEAR";return B||(B="LINEAR"),{interpolationType:B,shouldBakeAnimation:E}}static _AddSplineTangent(V,I,A,F,E,Y){let H;const c=V===PV.INTANGENT?E.inTangent:E.outTangent;if("CUBICSPLINE"===F){if("rotation"===A)if(c)if(Y)H=c.AH();else{const V=c;H=B.Quaternion.RotationYawPitchRoll(V.y,V.x,V.z).AH()}else H=[0,0,0,0];else H="weights"===A?c?[c]:[0]:c?c.AH():[0,0,0];I.push(H)}}static _CalculateMinMaxKeyFrames(V){let I=1/0,A=-1/0;return V.forEach((function(V){I=Math.min(I,V.frame),A=Math.max(A,V.frame)})),{min:I,max:A}}}function zV(V,I,A,E,Y,H){const c={attributes:{},influence:V.influence,name:V.name},b=I.HH;if(!b)return F.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),c;const P=H?-1:1,J=B.tI.Zero();let G=0,w=0;if(V.hasPositions){const E=V.getPositions(),H=b.getVerticesData(X.g.PositionKind);if(H){const V=new Float32Array(H.length),I=[1/0,1/0,1/0],F=[-1/0,-1/0,-1/0];w=H.length/3,G=0;for(let A=G;A<w;++A){const Y=B.tI.LI(H,3*A);B.tI.LI(E,3*A).subtractToRef(Y,J),J.x*=P,I[0]=Math.min(I[0],J.x),F[0]=Math.max(F[0],J.x),I[1]=Math.min(I[1],J.y),F[1]=Math.max(F[1],J.y),I[2]=Math.min(I[2],J.z),F[2]=Math.max(F[2],J.z),V[3*A]=J.x,V[3*A+1]=J.y,V[3*A+2]=J.z}const b=A.createBufferView(V,12),X=A.createAccessor(b,"VEC3",5126,E.length/3,0,{min:I,max:F});Y.push(X),c.attributes.POSITION=Y.length-1}else F.Tools.Warn(`Morph target positions for mesh ${I.name} were not exported. Mesh does not have position vertex data`)}if(V.hasNormals){const E=V.getNormals(),H=b.getVerticesData(X.g.NormalKind);if(H){const V=new Float32Array(H.length);w=H.length/3,G=0;for(let A=G;A<w;++A){const I=B.tI.LI(H,3*A).normalize();B.tI.LI(E,3*A).normalize().subtractToRef(I,J),V[3*A]=J.x*P,V[3*A+1]=J.y,V[3*A+2]=J.z}const I=A.createBufferView(V,12),F=A.createAccessor(I,"VEC3",5126,E.length/3,0);Y.push(F),c.attributes.NORMAL=Y.length-1}else F.Tools.Warn(`Morph target normals for mesh ${I.name} were not exported. Mesh does not have normals vertex data`)}if(V.hasTangents){const E=V.getTangents(),H=b.getVerticesData(X.g.TangentKind);if(H){w=H.length/4;const V=new Float32Array(3*w);G=0;for(let A=G;A<w;++A){const I=B.tI.LI(H,4*A);a(I);const F=B.tI.LI(E,3*A);a(F),F.subtractToRef(I,J),V[3*A]=J.x*P,V[3*A+1]=J.y,V[3*A+2]=J.z}const I=A.createBufferView(V,12),F=A.createAccessor(I,"VEC3",5126,w,0);Y.push(F),c.attributes.TANGENT=Y.length-1}else F.Tools.Warn(`Morph target tangents for mesh ${I.name} were not exported. Mesh does not have tangents vertex data`)}if(V.hasColors){const E=V.getColors(),H=b.getVerticesData(X.g.ColorKind),P=b.getVertexBuffer(X.g.ColorKind);if(H&&P){const V=P.getSize();w=H.length/V;const I=new Float32Array(w*V);G=0;for(let A=G;A<w;++A)if(3===V){const F=B.tI.LI(H,A*V);B.tI.LI(E,A*V).subtractToRef(F,J),I[3*A]=J.x,I[3*A+1]=J.y,I[3*A+2]=J.z}else if(4===V){const F=new B.Vector4,Y=B.Vector4.LI(H,A*V);B.Vector4.LI(E,A*V).subtractToRef(Y,F),I[4*A]=F.x,I[4*A+1]=F.y,I[4*A+2]=F.z,I[4*A+3]=F.w}else F.Tools.Warn(`Unsupported number of components for color attribute: ${V}`);const b=A.createBufferView(I,4*V),X=A.createAccessor(b,3===V?"VEC3":"VEC4",5126,w,0);Y.push(X),c.attributes.COLOR_0=Y.length-1}else F.Tools.Warn(`Morph target colors for mesh ${I.name} were not exported. Mesh does not have colors vertex data`)}return c}var mV=A(11810),sV=A(11646),eV=A(11628),SV=A(11189);class QV{}QV.DEFAULT_COLOR=u.oI.White(),QV.DEFAULT_WIDTH_ATTENUATED=1,QV.DEFAULT_WIDTH=.1;var hV=A(11440),rV=A(11816);class MV{static ConvertPoints(V,I){if(V.length&&Array.isArray(V)&&"number"===typeof V[0])return[V];if(V.length&&Array.isArray(V[0])&&"number"===typeof V[0][0])return V;if(V.length&&!Array.isArray(V[0])&&V[0]instanceof B.tI){const I=[];for(let A=0;A<V.length;A++){const B=V[A];I.push(B.x,B.y,B.z)}return[I]}if(V.length>0&&Array.isArray(V[0])&&V[0].length>0&&V[0][0]instanceof B.tI){const I=[],A=V;for(const V of A)I.push(V.flatMap((V=>[V.x,V.y,V.z])));return I}if(V instanceof Float32Array){if(null!==I&&void 0!==I&&I.floatArrayStride){const A=[],B=3*I.floatArrayStride;for(let I=0;I<V.length;I+=B){const F=new Array(B);for(let A=0;A<B;A++)F[A]=V[I+A];A.push(F)}return A}return[Array.from(V)]}if(V.length&&V[0]instanceof Float32Array){const I=[];for(const A of V)I.push(Array.from(A));return I}return[]}static OmitZeroLengthPredicate(V,I,A){const B=[];return I.uI(V).lengthSquared()>0&&B.push([V,I]),A.uI(I).lengthSquared()>0&&B.push([I,A]),V.uI(A).lengthSquared()>0&&B.push([A,V]),0===B.length?null:B}static OmitDuplicatesPredicate(V,I,A,B){const F=[];return MV._SearchInPoints(V,I,B)||F.push([V,I]),MV._SearchInPoints(I,A,B)||F.push([I,A]),MV._SearchInPoints(A,V,B)||F.push([A,V]),0===F.length?null:F}static _SearchInPoints(V,I,A){for(const Y of A)for(let A=0;A<Y.length;A++){var B,F,E;if(null!==(B=Y[A])&&void 0!==B&&B.equals(V))if(null!==(F=Y[A+1])&&void 0!==F&&F.equals(I)||null!==(E=Y[A-1])&&void 0!==E&&E.equals(I))return!0}return!1}static MeshesToLines(V,I){const A=[];for(let F=0;F<V.length;F++){const E=V[F],Y=E.getVerticesData(X.g.PositionKind),H=E.cH();if(Y&&H)for(let V=0,c=0;V<H.length;V++){const b=3*H[c++],X=3*H[c++],P=3*H[c++],J=new B.tI(Y[b],Y[b+1],Y[b+2]),G=new B.tI(Y[X],Y[X+1],Y[X+2]),w=new B.tI(Y[P],Y[P+1],Y[P+2]);if(I){const B=I(J,G,w,A,V,b,E,F,Y,H);if(B)for(const V of B)A.push(V)}else A.push([J,G],[G,w],[w,J])}}return A}static ToVector3Array(V){if(Array.isArray(V[0])){const I=[],A=V;for(const V of A){const A=[];for(let I=0;I<V.length;I+=3)A.push(new B.tI(V[I],V[I+1],V[I+2]));I.push(A)}return I}const I=V,A=[];for(let F=0;F<I.length;F+=3)A.push(new B.tI(I[F],I[F+1],I[F+2]));return A}static ToNumberArray(V){return V.flatMap((V=>[V.x,V.y,V.z]))}static GetPointsCountInfo(V){const I=new Array(V.length);let A=0;for(let B=V.length;B--;)I[B]=V[B].length/3,A+=I[B];return{total:A,counts:I}}static GetLineLength(V){if(0===V.length)return 0;let I;I="number"===typeof V[0]?MV.ToVector3Array(V):V;const A=B.TmpVectors.tI[0];let F=0;for(let B=0;B<I.length-1;B++){const V=I[B];F+=I[B+1].subtractToRef(V,A).length()}return F}static GetLineLengthArray(V){const I=new Float32Array(V.length/3);let A=0;for(let B=0,F=V.length/3-1;B<F;B++){let F=V[3*B+0],E=V[3*B+1],Y=V[3*B+2];F-=V[3*B+3],E-=V[3*B+4],Y-=V[3*B+5];A+=Math.sqrt(F*F+E*E+Y*Y),I[B+1]=A}return I}static SegmentizeSegmentByCount(V,I,A){const F=[],E=I.uI(V),Y=B.TmpVectors.tI[0];Y.JH(A);const H=B.TmpVectors.tI[1];E.divideToRef(Y,H);let c=V.clone();F.push(c);for(let B=0;B<A;B++)c=c.clone(),F.push(c.addInPlace(H));return F}static SegmentizeLineBySegmentLength(V,I){const A=V[0]instanceof B.tI?MV.GetLineSegments(V):"number"===typeof V[0]?MV.GetLineSegments(MV.ToVector3Array(V)):V,F=[];for(const B of A)if(B.length>I){const V=MV.SegmentizeSegmentByCount(B.point1,B.point2,Math.ceil(B.length/I));for(const I of V)F.push(I)}else F.push(B.point1),F.push(B.point2);return F}static SegmentizeLineBySegmentCount(V,I){const A="number"===typeof V[0]?MV.ToVector3Array(V):V,B=MV.GetLineLength(A)/I;return MV.SegmentizeLineBySegmentLength(A,B)}static GetLineSegments(V){const I=[];for(let A=0;A<V.length-1;A++){const B=V[A],F=V[A+1],E=F.uI(B).length();I.push({point1:B,point2:F,length:E})}return I}static GetMinMaxSegmentLength(V){const I=MV.GetLineSegments(V).sort((V=>V.length));return{min:I[0].length,max:I[I.length-1].length}}static GetPositionOnLineByVisibility(V,I,A){let F=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const E=I*A;let Y=0,H=0;const c=V.length;for(let B=0;B<c;B++){if(E<=Y+V[B].length){H=B;break}Y+=V[B].length}const b=(E-Y)/V[H].length;return V[H].point2.subtractToRef(V[H].point1,B.TmpVectors.tI[0]),B.TmpVectors.tI[1]=B.TmpVectors.tI[0].multiplyByFloats(b,b,b),F||B.TmpVectors.tI[1].addInPlace(V[H].point1),B.TmpVectors.tI[1].clone()}static GetCircleLinePoints(V,I){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V,E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/I;const Y=[];for(let H=0;H<=I;H++)Y.push(new B.tI(Math.cos(H*E)*V,Math.sin(H*E)*F,A));return Y}static GetBezierLinePoints(V,I,A,B){return hV.f.CreateQuadraticBezier(V,I,A,B).getPoints().flatMap((V=>[V.x,V.y,V.z]))}static GetArrowCap(V,I,A,B,F){let E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[V.clone(),V.add(I.multiplyByFloats(A,A,A))],widths:[B,F,E,Y]}}static GetPointsFromText(V,I,A,B){let F=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,E=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const Y=[],H=(0,rV.c)(V,I,A,B);for(const c of H){for(const V of c.paths){const I=[],A=V.getPoints();for(const V of A)I.push(V.x,V.y,F);Y.push(I)}if(E)for(const V of c.holes){const I=[],A=V.getPoints();for(const V of A)I.push(V.x,V.y,F);Y.push(I)}}return Y}static Color3toRGBAUint8(V){const I=new Uint8Array(4*V.length);for(let A=0,B=0;A<V.length;A++)I[B++]=255*V[A].r,I[B++]=255*V[A].g,I[B++]=255*V[A].b,I[B++]=255;return I}static CreateColorsTexture(V,I,A,B){const F=B.getEngine().getCaps().maxTextureSize??1,E=I.length>F?F:I.length,Y=Math.ceil(I.length/F);Y>1&&(I=[...I,...Array(E*Y-I.length).fill(I[0])]);const H=MV.Color3toRGBAUint8(I),c=new m.b(H,E,Y,w.c.TEXTUREFORMAT_RGBA,B,!1,!0,A);return c.name=V,c}static PrepareEmptyColorsTexture(V){if(!QV.EmptyColorsTexture){const I=new Uint8Array(4);QV.EmptyColorsTexture=new m.b(I,1,1,w.c.TEXTUREFORMAT_RGBA,V,!1,!1,m.b.NEAREST_NEAREST),QV.EmptyColorsTexture.name="grlEmptyColorsTexture"}return QV.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var V;null===(V=QV.EmptyColorsTexture)||void 0===V||V.dispose(),QV.EmptyColorsTexture=null}static BooleanToNumber(V){return V?1:0}}class xV extends eV.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class fV extends sV.d{isCompatible(V){return!0}constructor(V,I,A){var F;A=A||{color:QV.DEFAULT_COLOR};const E=new xV;E.GREASED_LINE_HAS_COLOR=!!A.color&&!A.useColors,E.GREASED_LINE_SIZE_ATTENUATION=A.sizeAttenuation??!1,E.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===A.colorDistributionType,E.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(I??V.sV()).useRightHandedSystem,E.GREASED_LINE_CAMERA_FACING=A.cameraFacing??!0,super(V,fV.GREASED_LINE_MATERIAL_NAME,200,E,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(F=A)||void 0===F?void 0:F.forceGLSL)||fV.ForceGLSL,this._scene=I??V.sV(),this._engine=this._scene.getEngine(),this._cameraFacing=A.cameraFacing??!0,this.visibility=A.visibility??1,this.useDash=A.useDash??!1,this.dashRatio=A.dashRatio??.5,this.dashOffset=A.dashOffset??0,this.width=A.width?A.width:A.sizeAttenuation?QV.DEFAULT_WIDTH_ATTENUATED:QV.DEFAULT_WIDTH,this._sizeAttenuation=A.sizeAttenuation??!1,this.colorMode=A.colorMode??0,this._color=A.color??null,this.useColors=A.useColors??!1,this._colorsDistributionType=A.colorDistributionType??0,this.colorsSampling=A.colorsSampling??m.b.NEAREST_NEAREST,this._colors=A.hV??null,this.dashCount=A.dashCount??1,this.resolution=A.resolution??new B.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),A.colorsTexture?this.colorsTexture=A.colorsTexture:this._colors?this.colorsTexture=MV.CreateColorsTexture(`${V.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??QV.DEFAULT_COLOR,MV.PrepareEmptyColorsTexture(this._scene)),this._engine.aY.add((()=>{MV.DisposeEmptyColorsTexture()}))}getAttributes(V){V.push("grl_offsets"),V.push("grl_widths"),V.push("grl_colorPointers"),V.push("grl_counters"),this._cameraFacing?(V.push("grl_previousAndSide"),V.push("grl_nextAndCounters")):V.push("grl_slopes")}getSamplers(V){V.push("grl_colors")}getActiveTextures(V){this.colorsTexture&&V.push(this.colorsTexture)}getUniforms(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const I=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&I.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===V&&I.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:I,vertex:this._cameraFacing&&this._isGLSL(V)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(V)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(V){if(this._cameraFacing){V.EH("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||V.EH("viewProjection",this._scene.getTransformMatrix());const I=B.TmpVectors.Vector4[0];I.x=this._aspect,I.y=this._resolution.x,I.z=this._resolution.y,I.w=this.width,V.updateVector4("grl_aspect_resolution_lineWidth",I)}const I=B.TmpVectors.Vector4[0];I.x=MV.BooleanToNumber(this.useDash),I.y=this._dashArray,I.z=this.dashOffset,I.w=this.dashRatio,V.updateVector4("grl_dashOptions",I);const A=B.TmpVectors.Vector4[1];A.x=this.colorMode,A.y=this.visibility,A.z=this.colorsTexture?this.colorsTexture.getSize().width:0,A.w=MV.BooleanToNumber(this.useColors),V.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",A),this._color&&V.updateColor3("grl_singleColor",this._color);const F=this.colorsTexture??QV.EmptyColorsTexture;V.setTexture("grl_colors",F),V.updateFloat2("grl_textureSize",(null===F||void 0===F?void 0:F.getSize().width)??1,(null===F||void 0===F?void 0:F.getSize().height)??1)}prepareDefines(V,I,A){V.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,V.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,V.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,V.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=I.useRightHandedSystem,V.GREASED_LINE_CAMERA_FACING=this._cameraFacing,V.GREASED_LINE_USE_OFFSETS=!!A.offsets}getClassName(){return fV.GREASED_LINE_MATERIAL_NAME}getCustomCode(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(I)?function(V,I){if("vertex"===V){const V={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return I&&(V["!gl_Position\\=viewProjection\\*worldPos;"]="//"),V}return"fragment"===V?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(V,this._cameraFacing):function(V,I){if("vertex"===V){const V={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return I&&(V["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),V}return"fragment"===V?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(V,this._cameraFacing)}dispose(){var V;null===(V=this.colorsTexture)||void 0===V||V.dispose(),super.dispose()}get hV(){return this._colors}set hV(V){this.setColors(V)}setColors(V){var I;let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1],B=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const F=(null===(I=this._colors)||void 0===I?void 0:I.length)??0;var E;if(this._colors=V,null!==V&&0!==V.length){if(!A||B)if(this.colorsTexture&&F===V.length&&!B){const I=MV.Color3toRGBAUint8(V);this.colorsTexture.update(I)}else{var Y;null===(Y=this.colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=MV.CreateColorsTexture(`${this._material.name}-colors-texture`,V,this.colorsSampling,this._scene)}}else null===(E=this.colorsTexture)||void 0===E||E.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(V){this._dashCount=V,this._dashArray=1/V}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(V){this._sizeAttenuation=V,this.markAllDefinesAsDirty()}get color(){return this._color}set color(V){this.setColor(V)}setColor(V){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==V||null!==this._color&&null===V?(this._color=V,I||this.markAllDefinesAsDirty()):this._color=V}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(V){this._colorsDistributionType=V,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(V){this._aspect=V.x/V.y,this._resolution=V}serialize(){const V=super.serialize(),I={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(I.hV=this._colors),this._color&&(I.color=this._color),V.greasedLineMaterialOptions=I,V}parse(V,I,A){var B;super.parse(V,I,A);const F=V.greasedLineMaterialOptions;null===(B=this.colorsTexture)||void 0===B||B.dispose(),F.color&&this.setColor(F.color,!0),F.colorDistributionType&&(this.colorsDistributionType=F.colorDistributionType),F.hV&&(this.hV=F.hV),F.colorsSampling&&(this.colorsSampling=F.colorsSampling),F.colorMode&&(this.colorMode=F.colorMode),F.useColors&&(this.useColors=F.useColors),F.visibility&&(this.visibility=F.visibility),F.useDash&&(this.useDash=F.useDash),F.dashCount&&(this.dashCount=F.dashCount),F.dashRatio&&(this.dashRatio=F.dashRatio),F.dashOffset&&(this.dashOffset=F.dashOffset),F.width&&(this.width=F.width),F.sizeAttenuation&&(this.sizeAttenuation=F.sizeAttenuation),F.resolution&&(this.resolution=F.resolution),this.hV?this.colorsTexture=MV.CreateColorsTexture(`${this._material.name}-colors-texture`,this.hV,this.colorsSampling,I):MV.PrepareEmptyColorsTexture(I),this.markAllDefinesAsDirty()}copyTo(V){var I;const A=V;null===(I=A.colorsTexture)||void 0===I||I.dispose(),this._colors&&(A.colorsTexture=MV.CreateColorsTexture(`${A._material.name}-colors-texture`,this._colors,A.colorsSampling,this._scene)),A.setColor(this.color,!0),A.colorsDistributionType=this.colorsDistributionType,A.colorsSampling=this.colorsSampling,A.colorMode=this.colorMode,A.useColors=this.useColors,A.visibility=this.visibility,A.useDash=this.useDash,A.dashCount=this.dashCount,A.dashRatio=this.dashRatio,A.dashOffset=this.dashOffset,A.width=this.width,A.sizeAttenuation=this.sizeAttenuation,A.resolution=this.resolution,A.markAllDefinesAsDirty()}_isGLSL(V){return 0===V||this._forceGLSL}}fV.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",fV.ForceGLSL=!1,(0,SV.e)(`BABYLON.${fV.GREASED_LINE_MATERIAL_NAME}`,fV);var RV=A(11676),qV=A(11070),NV=A(11469),lV=A(11169);class iV extends NV.ShaderMaterial{constructor(V,I,F){const E=I.getEngine(),Y=E.isWebGPU&&!(F.forceGLSL||iV.ForceGLSL),H=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];I.useRightHandedSystem&&H.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const c=["position","grl_widths","grl_offsets","grl_colorPointers"];F.cameraFacing?(H.push("GREASED_LINE_CAMERA_FACING"),c.push("grl_previousAndSide","grl_nextAndCounters")):(c.push("grl_slopes"),c.push("grl_counters"));const b=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(Y||b.push("world","viewProjection","view","projection"),super(V,I,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:Y?["Scene","Mesh"]:void 0,attributes:c,uniforms:b,samplers:Y?[]:["grlColors"],defines:H,extraInitializationsAsync:async()=>{Y?await Promise.all([A.e(66).then(A.bind(A,14267)),A.e(75).then(A.bind(A,14272))]):await Promise.all([A.e(69).then(A.bind(A,14279)),A.e(76).then(A.bind(A,14286))])},shaderLanguage:Y?1:0}),this._color=u.oI.White(),this._colorsDistributionType=0,this._colorsTexture=null,F=F||{color:QV.DEFAULT_COLOR},this.visibility=F.visibility??1,this.useDash=F.useDash??!1,this.dashRatio=F.dashRatio??.5,this.dashOffset=F.dashOffset??0,this.dashCount=F.dashCount??1,this.width=F.width?F.width:F.sizeAttenuation&&F.cameraFacing?QV.DEFAULT_WIDTH_ATTENUATED:QV.DEFAULT_WIDTH,this.sizeAttenuation=F.sizeAttenuation??!1,this.color=F.color??u.oI.White(),this.useColors=F.useColors??!1,this.colorsDistributionType=F.colorDistributionType??0,this.colorsSampling=F.colorsSampling??m.b.NEAREST_NEAREST,this.colorMode=F.colorMode??0,this._colors=F.hV??null,this._cameraFacing=F.cameraFacing??!0,this.resolution=F.resolution??new B.Vector2(E.getRenderWidth(),E.getRenderHeight()),F.colorsTexture?this.colorsTexture=F.colorsTexture:this._colors?this.colorsTexture=MV.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,I):(this._color=this._color??QV.DEFAULT_COLOR,this.colorsTexture=MV.PrepareEmptyColorsTexture(I)),Y){const V=new lV.b;V.setParameters(),V.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",V)}E.aY.add((()=>{MV.DisposeEmptyColorsTexture()}))}dispose(){var V;null===(V=this._colorsTexture)||void 0===V||V.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new B.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get hV(){return this._colors}set hV(V){this.setColors(V)}setColors(V){var I;let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1],B=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const F=(null===(I=this._colors)||void 0===I?void 0:I.length)??0;var E;if(this._colors=V,null!==V&&0!==V.length){if(!A||B)if(this._colorsTexture&&F===V.length&&!B){const I=MV.Color3toRGBAUint8(V);this._colorsTexture.update(I)}else{var Y;null===(Y=this._colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=MV.CreateColorsTexture(`${this.name}-colors-texture`,V,this.colorsSampling,this.sV())}}else null===(E=this._colorsTexture)||void 0===E||E.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(V){this._colorsTexture=V,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(V){this._width=V,this.setFloat("grlWidth",V)}get useColors(){return this._useColors}set useColors(V){this._useColors=V,this.setFloat("grlUseColors",MV.BooleanToNumber(V))}get colorsSampling(){return this._colorsSampling}set colorsSampling(V){this._colorsSampling=V}get visibility(){return this._visibility}set visibility(V){this._visibility=V,this.setFloat("grlVisibility",V)}get useDash(){return this._useDash}set useDash(V){this._useDash=V,this.setFloat("grlUseDash",MV.BooleanToNumber(V))}get dashOffset(){return this._dashOffset}set dashOffset(V){this._dashOffset=V,this.setFloat("grlDashOffset",V)}get dashRatio(){return this._dashRatio}set dashRatio(V){this._dashRatio=V,this.setFloat("grlDashRatio",V)}get dashCount(){return this._dashCount}set dashCount(V){this._dashCount=V,this._dashArray=1/V,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(V){this._sizeAttenuation=V,this.setFloat("grlSizeAttenuation",MV.BooleanToNumber(V))}get color(){return this._color}set color(V){this.setColor(V)}setColor(V){V=V??QV.DEFAULT_COLOR,this._color=V,this.setColor3("grlColor",V)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(V){this._colorsDistributionType=V,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(V){this._colorMode=V,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(V){this._resolution=V,this.setVector2("grlResolution",V),this.setFloat("grlAspect",V.x/V.y)}serialize(){const V=super.serialize(),I={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(I.hV=this._colors),V.greasedLineMaterialOptions=I,V}parse(V,I,A){var B;const F=V.greasedLineMaterialOptions;null===(B=this._colorsTexture)||void 0===B||B.dispose(),F.color&&(this.color=F.color),F.colorDistributionType&&(this.colorsDistributionType=F.colorDistributionType),F.colorsSampling&&(this.colorsSampling=F.colorsSampling),F.colorMode&&(this.colorMode=F.colorMode),F.useColors&&(this.useColors=F.useColors),F.visibility&&(this.visibility=F.visibility),F.useDash&&(this.useDash=F.useDash),F.dashCount&&(this.dashCount=F.dashCount),F.dashRatio&&(this.dashRatio=F.dashRatio),F.dashOffset&&(this.dashOffset=F.dashOffset),F.width&&(this.width=F.width),F.sizeAttenuation&&(this.sizeAttenuation=F.sizeAttenuation),F.resolution&&(this.resolution=F.resolution),F.hV?this.colorsTexture=MV.CreateColorsTexture(`${this.name}-colors-texture`,F.hV,this.colorsSampling,this.sV()):this.colorsTexture=MV.PrepareEmptyColorsTexture(I),this._cameraFacing=F.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var yV,vV,CV;iV.ForceGLSL=!1,function(V){V[V.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",V[V.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(yV||(yV={})),function(V){V[V.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",V[V.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",V[V.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(vV||(vV={})),function(V){V[V.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",V[V.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",V[V.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",V[V.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",V[V.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(CV||(CV={}));class KV extends gV.c{constructor(V,I,A){super(V,I,null,null,!1,!1),this.name=V,this._options=A,this._lazy=!1,this._updatable=!1,this._engine=I.getEngine(),this._lazy=A.lazy??!1,this._updatable=A.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=A.colorPointers??[],this._widths=A.widths??new Array(A.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(V){let I=0;for(const B of this._points)I+=B.length;const A=I/3*2-this._widths.length;for(let B=0;B<A;B++)this._widths.push(V)}updateLazy(){var V,I;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(V=this._options.ribbonOptions)||void 0===V?void 0:V.smoothShading),!this.fV&&this.refreshBoundingInfo(),null===(I=this.greasedLineMaterial)||void 0===I||I.updateLazy()}addPoints(V,I){for(const A of V)this._points.push(A);this._lazy||this.setPoints(this._points,I)}dispose(V){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(V,I)}isLazy(){return this._lazy}get rV(){return this._uvs}set rV(V){this._uvs=V instanceof Float32Array?V:new Float32Array(V),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(V){this.material instanceof iV&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===V||void 0===V?void 0:V.length)>0),this._offsets=V,this._offsetsBuffer?this._offsetsBuffer.update(V):this._createOffsetsBuffer(V)}get widths(){return this._widths}set widths(V){this._widths=V,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(V)}get colorPointers(){return this._colorPointers}set colorPointers(V){this._colorPointers=V,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(V)}get greasedLineMaterial(){var V,I;if(this.material&&this.material instanceof iV)return this.material;const A=null===(V=this.material)||void 0===V||null===(I=V.pluginManager)||void 0===I?void 0:I.getPlugin(fV.GREASED_LINE_MATERIAL_NAME);return A||void 0}get points(){const V=[];return qV.b.DeepCopy(this._points,V),V}setPoints(V,I){this._points=MV.ConvertPoints(V,(null===I||void 0===I?void 0:I.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==I&&void 0!==I&&I.colorPointers||this._updateColorPointers(),this._setPoints(this._points,I)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,rV:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(V){super.serialize(V),V.type=this.getClassName(),V.lineOptions=this._createLineOptions()}_createVertexBuffers(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new RV.e;return I.SV=this._vertexPositions,I.indices=this._indices,I.rV=this._uvs,V&&(I.QV=[],RV.e.ComputeNormals(this._vertexPositions,this._indices,I.QV)),I.xV(this,this._options.updatable),I}_createOffsetsBuffer(V){const I=this._scene.getEngine(),A=new X.d(I,V,this._updatable,3);this.setVerticesBuffer(A.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=A}}class pV{constructor(V,I){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=V,this.wasAddedByNoopNode=I}getIndicesAccessor(V,I,A,B,F){var E,Y,H,c;return null===(E=this._indicesAccessorMap.get(V))||void 0===E||null===(Y=E.get(I))||void 0===Y||null===(H=Y.get(A))||void 0===H||null===(c=H.get(B))||void 0===c?void 0:c.get(F)}setIndicesAccessor(V,I,A,B,F,E){let Y=this._indicesAccessorMap.get(V);Y||(Y=new Map,this._indicesAccessorMap.set(V,Y));let H=Y.get(I);H||(H=new Map,Y.set(I,H));let c=H.get(A);c||(c=new Map,H.set(A,c));let b=c.get(B);b||(b=new Map,c.set(B,b)),b.set(F,E)}pushExportedNode(V){this._exportedNodes.has(V)||this._exportedNodes.add(V)}getNodesSet(){return this._exportedNodes}getVertexBufferView(V){return this._vertexBufferViewMap.get(V)}setVertexBufferView(V,I){this._vertexBufferViewMap.set(V,I)}setRemappedBufferView(V,I,A){this._remappedBufferView.set(V,new Map),this._remappedBufferView.get(V).set(I,A)}getRemappedBufferView(V,I){var A;return null===(A=this._remappedBufferView.get(V))||void 0===A?void 0:A.get(I)}getVertexAccessor(V,I,A){var B,F;return null===(B=this._vertexAccessorMap.get(V))||void 0===B||null===(F=B.get(I))||void 0===F?void 0:F.get(A)}setVertexAccessor(V,I,A,B){let F=this._vertexAccessorMap.get(V);F||(F=new Map,this._vertexAccessorMap.set(V,F));let E=F.get(I);E||(E=new Map,F.set(I,E)),E.set(A,B)}hasVertexColorAlpha(V){return this._vertexMapColorAlpha.get(V)||!1}setHasVertexColorAlpha(V,I){return this._vertexMapColorAlpha.set(V,I)}getMesh(V){return this._meshMap.get(V)}setMesh(V,I){this._meshMap.set(V,I)}bindMorphDataToMesh(V,I){const A=this._meshMorphTargetMap.get(V)||[];this._meshMorphTargetMap.set(V,A),-1===A.indexOf(I)&&A.push(I)}getMorphTargetsFromMesh(V){return this._meshMorphTargetMap.get(V)}}class jV{_ApplyExtension(V,I,A,B){if(A>=I.length)return Promise.resolve(V);const F=B(I[A],V);return F?F.then((async V=>V?await this._ApplyExtension(V,I,A+1,B):null)):this._ApplyExtension(V,I,A+1,B)}_ApplyExtensions(V,I){const A=[];for(const B of jV._ExtensionNames)A.push(this._extensions[B]);return this._ApplyExtension(V,A,0,I)}_extensionsPreExportTextureAsync(V,I,A){return this._ApplyExtensions(I,((I,B)=>I.preExportTextureAsync&&I.preExportTextureAsync(V,B,A)))}_extensionsPostExportNodeAsync(V,I,A,B,F){return this._ApplyExtensions(I,((I,E)=>I.postExportNodeAsync&&I.postExportNodeAsync(V,E,A,B,F,this._bufferManager)))}_extensionsPostExportMaterialAsync(V,I,A){return this._ApplyExtensions(I,((I,B)=>I.postExportMaterialAsync&&I.postExportMaterialAsync(V,B,A)))}_extensionsPostExportMaterialAdditionalTextures(V,I,A){const B=[];for(const F of jV._ExtensionNames){const E=this._extensions[F];E.postExportMaterialAdditionalTextures&&B.push(...E.postExportMaterialAdditionalTextures(V,I,A))}return B}_extensionsPostExportTextures(V,I,A){for(const B of jV._ExtensionNames){const F=this._extensions[B];F.postExportTexture&&F.postExportTexture(V,I,A)}}_extensionsPostExportMeshPrimitive(V){for(const I of jV._ExtensionNames){const A=this._extensions[I];A.postExportMeshPrimitive&&A.postExportMeshPrimitive(V,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const V of jV._ExtensionNames){const I=this._extensions[V];I.preGenerateBinaryAsync&&await I.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(V){for(const I of jV._ExtensionNames){const A=this._extensions[I];A.enabled&&V(A)}}_extensionsOnExporting(){this._forEachExtensions((V=>{var I,A,B;V.wasUsed&&((I=this._glTF).extensionsUsed||(I.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(V.name)&&this._glTF.extensionsUsed.push(V.name),V.required&&((A=this._glTF).extensionsRequired||(A.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(V.name)&&this._glTF.extensionsRequired.push(V.name)),(B=this._glTF).extensions||(B.extensions={}),V.onExporting&&V.onExporting())}))}_loadExtensions(){for(const V of jV._ExtensionNames){const I=jV._ExtensionFactories[V](this);this._extensions[V]=I}}constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.e.LastCreatedScene,I=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${w.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new l(this),this._extensions={},this._bufferManager=new XV,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!V)throw new Error("No scene available to export");this._babylonScene=V,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:V=>{var I;return null===V||void 0===V||null===(I=V.nY)||void 0===I?void 0:I.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...I},this._loadExtensions()}dispose(){for(const V in this._extensions){this._extensions[V].dispose()}}get options(){return this._options}static RegisterExtension(V,I){jV.UnregisterExtension(V)&&F.Tools.Warn(`Extension with the name ${V} already exists`),jV._ExtensionFactories[V]=I,jV._ExtensionNames.push(V)}static UnregisterExtension(V){if(!jV._ExtensionFactories[V])return!1;delete jV._ExtensionFactories[V];const I=jV._ExtensionNames.indexOf(V);return-1!==I&&jV._ExtensionNames.splice(I,1),!0}_generateJSON(V,I,A){const B={byteLength:V};return B.byteLength&&(this._glTF.buffers=[B]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.WI=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(B.uri=I+".bin"),A?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(V){const I=await this._generateBinaryAsync();this._extensionsOnExporting();const A=this._generateJSON(I.byteLength,V,!0),B=new Blob([I],{type:"application/octet-stream"}),F=V+".gltf",E=V+".bin",Y=new b;if(Y.files[F]=A,Y.files[E]=B,this._imageData)for(const H in this._imageData)Y.files[H]=new Blob([this._imageData[H].data],{type:this._imageData[H].mimeType});return Y}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(V){const I=V%4;return 0===I?I:4-I}async generateGLBAsync(V){this._shouldUseGlb=!0;const I=await this._generateBinaryAsync();this._extensionsOnExporting();const A=this._generateJSON(I.byteLength),B=V+".glb";let F,E=A.length;if("undefined"!==typeof TextEncoder){F=(new TextEncoder).encode(A),E=F.length}const Y=this._getPadding(E),H=this._getPadding(I.byteLength),c=28+E+Y+I.byteLength+H,X=new cV(c);if(X.writeUInt32(1179937895),X.writeUInt32(2),X.writeUInt32(c),X.writeUInt32(E+Y),X.writeUInt32(1313821514),F)X.writeTypedArray(F);else{const V="_".charCodeAt(0);for(let I=0;I<E;++I){const B=A.charCodeAt(I);B!=A.codePointAt(I)?X.writeUInt8(V):X.writeUInt8(B)}}for(let b=0;b<Y;++b)X.writeUInt8(32);X.writeUInt32(I.byteLength+H),X.writeUInt32(5130562),X.writeTypedArray(I);for(let b=0;b<H;++b)X.writeUInt8(0);const P=new b;return P.files[B]=new Blob([X.getOutputData()],{type:"application/octet-stream"}),P}_setNodeTransformation(V,I,A){if(I.getPivotPoint().equalsWithEpsilon(K,C.d)||F.Tools.Warn("Pivot points are not supported in the glTF serializer"),!I.position.equalsWithEpsilon(K,C.d)){const F=B.TmpVectors.tI[0].B(I.position);A&&k(F),V.translation=F.AH()}I.PH.equalsWithEpsilon(j,C.d)||(V.scale=I.PH.AH());const E=I.rotationQuaternion||B.Quaternion.FromEulerAngles(I.rotation.x,I.rotation.y,I.rotation.z);E.equalsWithEpsilon(p,C.d)||(A&&U(E),V.rotation=E.normalize().AH())}_setCameraTransformation(V,I,A){if(!I.position.equalsWithEpsilon(K,C.d)){const F=B.TmpVectors.tI[0].B(I.position);A&&k(F),V.translation=F.AH()}const F=I.rotationQuaternion||B.Quaternion.FromEulerAngles(I.rotation.x,I.rotation.y,I.rotation.z);A&&U(F),this._babylonScene.useRightHandedSystem||n(F),F.equalsWithEpsilon(p,C.d)||(V.rotation=F.AH())}_listAvailableCameras(){for(const V of this._babylonScene.cameras){const I={type:V.mode===JV.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(V.name&&(I.name=V.name),"perspective"===I.type)I.perspective={aspectRatio:V.getEngine().getAspectRatio(V),yfov:V.fovMode===JV.c.FOVMODE_VERTICAL_FIXED?V.fov:V.fov*V.getEngine().getAspectRatio(V),znear:V.FH,zfar:V.maxZ};else if("orthographic"===I.type){const A=V.orthoLeft&&V.orthoRight?.5*(V.orthoRight-V.orthoLeft):.5*V.getEngine().getRenderWidth(),B=V.orthoBottom&&V.orthoTop?.5*(V.orthoTop-V.orthoBottom):.5*V.getEngine().getRenderHeight();I.orthographic={xmag:A,ymag:B,znear:V.FH,zfar:V.maxZ}}this._camerasMap.set(V,I)}}_exportAndAssignCameras(){const V=Array.from(this._camerasMap.values());for(const I of V){const V=this._nodesCameraMap.get(I);if(void 0!==V){this._cameras.push(I);for(const I of V)I.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const V of this._babylonScene.skeletons){if(V.bones.length<=0)continue;const I={joints:[]};this._skinMap.set(V,I)}}_exportAndAssignSkeletons(){for(const V of this._babylonScene.skeletons){if(V.bones.length<=0)continue;const I=this._skinMap.get(V);if(void 0==I)continue;const A={},B=[];let E=-1;for(let F=0;F<V.bones.length;++F){const I=V.bones[F],B=I.getIndex()??F;-1!==B&&(A[B]=I,B>E&&(E=B))}for(let V=0;V<=E;++V){const E=A[V];B.push(E.getAbsoluteInverseBindMatrix());const Y=E.getTransformNode();if(null!==Y){const V=this._nodeMap.get(Y);Y&&null!==V&&void 0!==V?I.joints.push(V):F.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else F.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const Y=this._nodesSkinMap.get(I);if(I.joints.length>0&&void 0!==Y){const V=64*B.length,A=new Float32Array(V/4);B.forEach(((V,I)=>{A.set(V.m,16*I)}));const F=this._bufferManager.createBufferView(A);this._accessors.push(this._bufferManager.createAccessor(F,"MAT4",5126,B.length)),I.inverseBindMatrices=this._accessors.length-1,this._skins.push(I);for(const I of Y)I.skin=this._skins.length-1}}}async _exportSceneAsync(){const V={nodes:[]};if(this._babylonScene.metadata){const I=this._options.metadataSelector(this._babylonScene.metadata);I&&(V.extras=I)}const I=new Array,A=new Array,B=new Array;for(const H of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&YV(H,this._babylonScene.useRightHandedSystem)?B.push(...H.getChildren()):this._babylonScene.useRightHandedSystem?I.push(H):A.push(H);this._listAvailableCameras(),this._listAvailableSkeletons();const F=new pV(!0,!1);V.nodes.push(...await this._exportNodesAsync(A,F));const E=new pV(!1,!1);V.nodes.push(...await this._exportNodesAsync(I,E));const Y=new pV(!1,!0);V.nodes.push(...await this._exportNodesAsync(B,Y)),V.nodes.length&&this._scenes.push(V),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&LV._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,F.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(V){let I=this._shouldExportNodeMap.get(V);return void 0===I&&(I=this._options.shouldExportNode(V),this._shouldExportNodeMap.set(V,I)),I}async _exportNodesAsync(V,I){const A=new Array;this._exportBuffers(V,I);for(const B of V)await this._exportNodeAsync(B,A,I);return A}_collectBuffers(V,I,A,B,F){if(this._shouldExportNode(V)&&V instanceof J.c&&V.HH){const E=V.HH.getVertexBuffers();if(E)for(const B in E){if(!O(B))continue;const Y=E[B];F.setHasVertexColorAlpha(Y,V.hasVertexAlpha);const H=Y._buffer,c=I.get(H)||[];I.set(H,c),-1===c.indexOf(Y)&&c.push(Y);const b=A.get(Y)||[];A.set(Y,b),-1===b.indexOf(V)&&b.push(V)}const Y=V.morphTargetManager;if(Y)for(let I=0;I<Y.numTargets;I++){const A=Y.getTarget(I),F=B.get(A)||[];B.set(A,F),-1===F.indexOf(V)&&F.push(V)}}for(const E of V.getChildren())this._collectBuffers(E,I,A,B,F)}_exportBuffers(V,I){const A=new Map,B=new Map,F=new Map;for(const H of V)this._collectBuffers(H,A,B,F,I);const E=Array.from(A.keys());for(const H of E){const V=H.getData();if(!V)throw new Error("Buffer data is not available");const F=A.get(H);if(!F)continue;const E=F[0].byteStride;if(F.some((V=>V.byteStride!==E)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const Y=AV(V).slice();for(const I of F){const V=B.get(I),{byteOffset:A,byteStride:F,componentCount:E,type:H,count:c,normalized:b,kind:P}=d(I,V);switch(P){case X.g.NormalKind:case X.g.TangentKind:(0,i.h)(Y,A,F,E,H,c,b,(V=>{const I=Math.sqrt(V[0]*V[0]+V[1]*V[1]+V[2]*V[2]);if(I>0){const A=1/I;V[0]*=A,V[1]*=A,V[2]*=A}}));break;case X.g.ColorKind:{const I=V.filter((V=>V.material instanceof tV.gI||null==V.material)).length;if(0==I)break;if(I!=V.length){y.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}H==X.g.UNSIGNED_BYTE&&y.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const B=new u.oI,P=new u.GH,J=this._babylonScene.getEngine().useExactSrgbConversions;(0,i.h)(Y,A,F,E,H,c,b,(V=>{3===V.length?(B.GA(V,0),B.toLinearSpaceToRef(B,J),B.toArray(V,0)):(P.GA(V,0),P.toLinearSpaceToRef(P,J),P.toArray(V,0))}))}}}if(I.convertToRightHanded){for(const V of F){const I=B.get(V),{byteOffset:A,byteStride:F,componentCount:E,type:H,count:c,normalized:b,kind:P}=d(V,I);switch(P){case X.g.PositionKind:case X.g.NormalKind:case X.g.TangentKind:(0,i.h)(Y,A,F,E,H,c,b,(V=>{V[0]=-V[0]}))}}I.convertedToRightHandedBuffers.set(H,Y)}const c=this._bufferManager.createBufferView(Y,E);I.setVertexBufferView(H,c);const b=new Map;for(const I of F){const V=B.get(I),{kind:A,totalVertices:F}=d(I,V);switch(A){case X.g.MatricesIndicesKind:case X.g.MatricesIndicesExtraKind:if(I.type==X.g.FLOAT){const V=I.getFloatData(F);null!==V&&b.set(I,V)}}}0!==b.size&&y.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const P=Array.from(b.keys());for(const A of P){const V=b.get(A);if(!V)continue;const B=V.some((V=>V>=256)),F=new(B?Uint16Array:Uint8Array)(V.length);for(let I=0;I<V.length;I++)F[I]=V[I];const E=this._bufferManager.createBufferView(F,4*(B?2:1));I.setRemappedBufferView(H,A,E)}}const Y=Array.from(F.keys());for(const H of Y){const V=F.get(H);if(!V)continue;const A=zV(H,V[0],this._bufferManager,this._bufferViews,this._accessors,I.convertToRightHanded);for(const B of V)I.bindMorphDataToMesh(B,A)}}async _exportNodeAsync(V,I,A){let B=this._nodeMap.get(V);if(void 0!==B)return void(I.includes(B)||I.push(B));const F=await this._createNodeAsync(V,A);if(F){B=this._nodes.length,this._nodes.push(F),this._nodeMap.set(V,B),A.pushExportedNode(V),I.push(B);const E={name:"runtime animations",channels:[],samplers:[]},Y=[];this._babylonScene.animationGroups.length||(LV._CreateMorphTargetAnimationFromMorphTargetAnimations(V,E,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,A.convertToRightHanded,this._options.shouldExportAnimation),V.animations.length&&LV._CreateNodeAnimationFromNodeAnimations(V,E,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,A.convertToRightHanded,this._options.shouldExportAnimation)),E.channels.length&&E.samplers.length&&this._animations.push(E),Y.forEach((V=>{V.channels.length&&V.samplers.length&&this._animations.push(V)}))}const E=F?[]:I;for(const Y of V.getChildren())await this._exportNodeAsync(Y,E,A);F&&E.length&&(F.children=E)}async _createNodeAsync(V,I){if(!this._shouldExportNode(V))return null;const A={};if(V.name&&(A.name=V.name),V.metadata){const I=this._options.metadataSelector(V.metadata);I&&(A.extras=I)}if(V instanceof P.e&&(this._setNodeTransformation(A,V,I.convertToRightHanded),V instanceof J.c)){const F=V instanceof G.b?V.sourceMesh:V;if(F.IH&&F.IH.length>0&&(A.mesh=await this._exportMeshAsync(F,I)),V.skeleton){const I=this._skinMap.get(V.skeleton);var B;if(void 0!==I)void 0===this._nodesSkinMap.get(I)&&this._nodesSkinMap.set(I,[]),null===(B=this._nodesSkinMap.get(I))||void 0===B||B.push(A)}}if(V instanceof v.d){const B=this._camerasMap.get(V);if(B){var F;void 0===this._nodesCameraMap.get(B)&&this._nodesCameraMap.set(B,[]),this._setCameraTransformation(A,V,I.convertToRightHanded);const Y=V.parent;if(null!==Y&&IV(V,Y)){const V=this._nodeMap.get(Y);if(void 0!==V){var E;const I=this._nodes[V];return VV(A,I),null===(E=this._nodesCameraMap.get(B))||void 0===E||E.push(I),null}}null===(F=this._nodesCameraMap.get(B))||void 0===F||F.push(A)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",A,V,this._nodeMap,I.convertToRightHanded)?A:(y.b.Warn(`Not exporting node ${V.name}`),null)}_exportIndices(V,I,A,B,F,Y,H,c,b){let X=V;b.mode=Z(Y);const P=H!==E.c.CounterClockWiseSideOrientation,J=!c.wasAddedByNoopNode&&P,G=function(V){switch(V){case E.c.TriangleFillMode:case E.c.TriangleStripDrawMode:case E.c.TriangleFanDrawMode:return!0}return!1}(Y)&&J;if(G){if(Y===E.c.TriangleStripDrawMode||Y===E.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");b.mode=Z(Y);const H=I?new Uint32Array(B):new Uint16Array(B);if(V)for(let I=0;I+2<B;I+=3)H[I]=V[A+I]+F,H[I+1]=V[A+I+2]+F,H[I+2]=V[A+I+1]+F;else for(let V=0;V+2<B;V+=3)H[V]=V,H[V+1]=V+2,H[V+2]=V+1;X=H}else if(V&&0!==F){const E=I?new Uint32Array(B):new Uint16Array(B);for(let I=0;I<B;I++)E[I]=V[A+I]+F;X=E}if(X){let E=c.getIndicesAccessor(V,A,B,F,G);if(void 0===E){const Y=function(V,I,A,B){if(V instanceof Uint16Array||V instanceof Uint32Array)return V;if(V instanceof Int32Array)return new Uint32Array(V.buffer,V.byteOffset,V.length);const F=V.slice(I,I+A);return B?new Uint32Array(F):new Uint16Array(F)}(X,0,B,I),H=this._bufferManager.createBufferView(Y),b=I?5125:5123;this._accessors.push(this._bufferManager.createAccessor(H,"SCALAR",b,B,0)),E=this._accessors.length-1,c.setIndicesAccessor(V,A,B,F,G,E)}b.indices=E}}_exportVertexBuffer(V,I,A,B,F,E){const Y=V.getKind();if(!O(Y))return;if(Y.startsWith("uv")&&!this._options.exportUnusedUVs&&(!I||!this._materialNeedsUVsSet.has(I)))return;let H=F.getVertexAccessor(V,A,B);if(void 0===H){const I=F.convertedToRightHandedBuffers.get(V._buffer)||V._buffer.getData(),E=Y===X.g.PositionKind?function(V,I,A,B){const{byteOffset:F,byteStride:E,type:Y,normalized:H}=I,c=I.getSize(),b=new Array(c).fill(1/0),X=new Array(c).fill(-1/0);return(0,i.h)(V,F+A*E,E,c,Y,B*c,H,(V=>{for(let I=0;I<c;I++)b[I]=Math.min(b[I],V[I]),X[I]=Math.max(X[I],V[I])})),{min:b,max:X}}(I,V,A,B):void 0,c=(Y===X.g.MatricesIndicesKind||Y===X.g.MatricesIndicesExtraKind)&&V.type===X.g.FLOAT,b=c?X.g.UNSIGNED_BYTE:V.type,P=c?void 0:V.normalized,J=c?F.getRemappedBufferView(V._buffer,V):F.getVertexBufferView(V._buffer),G=V.byteOffset+A*V.byteStride;this._accessors.push(this._bufferManager.createAccessor(J,function(V,I){if(V==X.g.ColorKind)return I?"VEC4":"VEC3";switch(V){case X.g.PositionKind:case X.g.NormalKind:return"VEC3";case X.g.TangentKind:case X.g.MatricesIndicesKind:case X.g.MatricesIndicesExtraKind:case X.g.MatricesWeightsKind:case X.g.MatricesWeightsExtraKind:return"VEC4";case X.g.UVKind:case X.g.UV2Kind:case X.g.UV3Kind:case X.g.UV4Kind:case X.g.UV5Kind:case X.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${V}`)}(Y,F.hasVertexColorAlpha(V)),b,B,G,E,P)),H=this._accessors.length-1,F.setVertexAccessor(V,A,B,H)}E.attributes[function(V){switch(V){case X.g.PositionKind:return"POSITION";case X.g.NormalKind:return"NORMAL";case X.g.TangentKind:return"TANGENT";case X.g.ColorKind:return"COLOR_0";case X.g.UVKind:return"TEXCOORD_0";case X.g.UV2Kind:return"TEXCOORD_1";case X.g.UV3Kind:return"TEXCOORD_2";case X.g.UV4Kind:return"TEXCOORD_3";case X.g.UV5Kind:return"TEXCOORD_4";case X.g.UV6Kind:return"TEXCOORD_5";case X.g.MatricesIndicesKind:return"JOINTS_0";case X.g.MatricesIndicesExtraKind:return"JOINTS_1";case X.g.MatricesWeightsKind:return"WEIGHTS_0";case X.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${V}`)}(Y)]=H}async _exportMaterialAsync(V,I,A,B){let F=this._materialMap.get(V);if(void 0===F){const B=I&&Object.keys(I).some((V=>V.startsWith("uv")));if((V=V instanceof GV.c?V.wH[A.materialIndex]:V)instanceof wV.b)F=await this._materialExporter.exportPBRMaterialAsync(V,"image/png",B);else{if(!(V instanceof tV.gI))return void y.b.Warn(`Unsupported material '${V.name}' with type ${V.getClassName()}`);F=await this._materialExporter.exportStandardMaterialAsync(V,"image/png",B)}this._materialMap.set(V,F)}B.material=F}async _exportMeshAsync(V,I){var A;let B=I.getMesh(V);if(void 0!==B)return B;const F={primitives:[]};B=this._meshes.length,this._meshes.push(F),I.setMesh(V,B);const Y=V.isUnIndexed?null:V.cH(),H=null===(A=V.HH)||void 0===A?void 0:A.getVertexBuffers(),c=I.getMorphTargetsFromMesh(V),b=V instanceof mV.d,X=V instanceof KV,P=V.IH;if(H&&P&&P.length>0)for(const w of P){const A={attributes:{}},B=w.lV()||this._babylonScene.defaultMaterial;if(X){var J,G;const I={name:B.name},F=V,E=u.oI.White(),Y=(null===(J=F.material)||void 0===J?void 0:J.alpha)??1,H=(null===(G=F.greasedLineMaterial)||void 0===G?void 0:G.color)??E;(!H.equalsWithEpsilon(E,C.d)||Y<1)&&(I.pbrMetallicRoughness={baseColorFactor:[...H.AH(),Y]}),this._materials.push(I),A.material=this._materials.length-1}else if(b){const I={name:B.name},F=V;(!F.color.equalsWithEpsilon(u.oI.White(),C.d)||F.alpha<1)&&(I.pbrMetallicRoughness={baseColorFactor:[...F.color.AH(),F.alpha]}),this._materials.push(I),A.material=this._materials.length-1}else await this._exportMaterialAsync(B,H,w,A);const P=b||X?E.c.LineListDrawMode:V.overrideRenderingFillMode??B.fillMode,t=B._getEffectiveOrientation(V);this._exportIndices(Y,Y?(0,i.d)(Y,w.indexCount,w.indexStart,w.verticesStart):w.verticesCount>65535,Y?w.indexStart:w.verticesStart,Y?w.indexCount:w.verticesCount,-w.verticesStart,P,t,I,A);for(const V of Object.values(H))this._exportVertexBuffer(V,B,w.verticesStart,w.verticesCount,I,A);if(c){A.targets=[];for(const V of c)A.targets.push(V.attributes)}F.primitives.push(A),this._extensionsPostExportMeshPrimitive(A)}if(c){F.weights=[],F.extras||(F.extras={}),F.extras.targetNames=[];for(const V of c)F.weights.push(V.influence),F.extras.targetNames.push(V.name)}return B}}jV._ExtensionNames=new Array,jV._ExtensionFactories={};class TV{static async GLTFAsync(V,I,A){A&&A.exportWithoutWaitingForScene||await V.whenReadyAsync();const B=new jV(V,A),F=await B.generateGLTFAsync(I.replace(/\.[^/.]+$/,""));return B.dispose(),F}static async GLBAsync(V,I,A){A&&A.exportWithoutWaitingForScene||await V.whenReadyAsync();const B=new jV(V,A),F=await B.generateGLBAsync(I.replace(/\.[^/.]+$/,""));return B.dispose(),F}}A(11823);const dV="EXT_mesh_gpu_instancing";class DV{constructor(V){this.name=dV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(V,I,A,F,E,Y){return await new Promise((V=>{if(I&&A instanceof gV.c&&A.hasThinInstances&&this._exporter){this._wasUsed=!0;const V=B.tI.Zero(),F=B.Quaternion.Identity(),H=B.tI.One(),c=A.thinInstanceGetWorldMatrices(),b=B.TmpVectors.tI[2],X=B.TmpVectors.Quaternion[1],P=B.TmpVectors.tI[3];let J=!1,G=!1,w=!1;const t=new Float32Array(3*A.tH),u=new Float32Array(4*A.tH),W=new Float32Array(3*A.tH);let g=0;for(const I of c)I.decompose(P,X,b),E&&(k(b),U(X)),t.set(b.AH(),3*g),u.set(X.normalize().AH(),4*g),W.set(P.AH(),3*g),J=J||!b.equalsWithEpsilon(V),G=G||!X.equalsWithEpsilon(F),w=w||!P.equalsWithEpsilon(H),g++;const o={attributes:{}};J&&(o.attributes.TRANSLATION=this._buildAccessor(t,"VEC3",A.tH,Y)),G&&(o.attributes.ROTATION=this._buildAccessor(u,"VEC4",A.tH,Y)),w&&(o.attributes.SCALE=this._buildAccessor(W,"VEC3",A.tH,Y)),I.extensions=I.extensions||{},I.extensions[dV]=o}V(I)}))}_buildAccessor(V,I,A,B){const F=B.createBufferView(V),E=B.createAccessor(F,I,5126,A);return this._exporter._accessors.push(E),this._exporter._accessors.length-1}}jV.RegisterExtension(dV,(V=>new DV(V)));var OV=A(11830),ZV=A(11839),aV=A(11848),kV=A(11853);function UV(V){return V===aV.c.PositionKind?"POSITION":V===aV.c.NormalKind?"NORMAL":V===aV.c.ColorKind?"COLOR":V.startsWith(aV.c.UVKind)?"TEX_COORD":"GENERIC"}const nV={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class VI extends OV.d{static get DefaultAvailable(){return(0,OV.j)(VI.DefaultConfiguration)}static get Default(){return VI._Default??(VI._Default=new VI),VI._Default}static ResetDefault(V){VI._Default&&(V||VI._Default.dispose(),VI._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(V,I){return{module:await(I||DracoEncoderModule)({wasmBinary:V})}}_getWorkerContent(){return`${ZV.g}(${ZV.i})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:VI.DefaultConfiguration)}async _encodeAsync(V,I,A){const B=A?(0,kV.d)(nV,A):nV;if(this._workerPoolPromise){const A=await this._workerPoolPromise;return await new Promise(((F,E)=>{A.push(((A,Y)=>{const H=V=>{A.removeEventListener("error",H),A.removeEventListener("message",c),E(V),Y()},c=V=>{"encodeMeshDone"===V.data.id&&(A.removeEventListener("error",H),A.removeEventListener("message",c),F(V.data.encodedMeshData),Y())};A.addEventListener("error",H),A.addEventListener("message",c);const b=[];for(const I of V)b.push(I.data.buffer);I&&b.push(I.buffer),A.postMessage({id:"encodeMesh",attributes:V,indices:I,options:B},b)}))}))}if(this._modulePromise){const A=await this._modulePromise;return(0,ZV.g)(A.module,V,I,B)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(V,I){if(0==V.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");V instanceof gV.c&&V.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===I||void 0===I?void 0:I.method)&&(y.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),I.method="MESH_SEQUENTIAL_ENCODING");const A=function(V){let I=V.cH(void 0,!0);return!I||I instanceof Uint32Array||I instanceof Uint16Array||(I=((0,i.d)(I,I.length)?Uint32Array:Uint16Array).from(I)),I}(V),B=function(V,I){const A=[];for(const B of V.getVerticesDataKinds()){if(null!==I&&void 0!==I&&I.includes(B)){if(B===aV.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const F=V.getVertexBuffer(B),E=F.getSize(),Y=(0,i.s)(F.getData(),E,F.type,F.byteOffset,F.byteStride,F.normalized,V.getTotalVertices(),!0);A.push({kind:B,dracoName:UV(B),size:E,data:Y})}return A}(V,null===I||void 0===I?void 0:I.excludedAttributes);return await this._encodeAsync(B,A,I)}}VI.DefaultConfiguration={wasmUrl:`${F.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${F.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${F.Tools._DefaultCdnUrl}/draco_encoder.js`},VI._Default=null;const II="KHR_draco_mesh_compression";class AI{get wasUsed(){return this._wasUsed}constructor(V){this.name=II,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===V.options.meshCompressionMethod&&VI.DefaultAvailable}dispose(){}postExportMeshPrimitive(V,I,A){if(!this.enabled)return;if(4!==V.mode&&5!==V.mode)return void y.b.Warn("Cannot compress primitive with mode "+V.mode+".");const B=[],F=[];let E=null;if(void 0!==V.indices){const Y=A[V.indices],H=I.getBufferView(Y);E=I.getData(H).slice(),B.push(H),F.push(Y)}const Y=[];for(const[X,P]of Object.entries(V.attributes)){const V=A[P],E=I.getBufferView(V),c=D(V.type),b=(0,i.s)(I.getData(E),c,V.componentType,V.byteOffset||0,E.byteStride||(0,i.l)(V.componentType)*c,V.normalized||!1,V.count,!0);Y.push({kind:X,dracoName:(H=X,"POSITION"===H?"POSITION":"NORMAL"===H?"NORMAL":H.startsWith("COLOR")?"COLOR":H.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:D(V.type),data:b}),B.push(E),F.push(V)}var H;const c={method:V.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},b=VI.Default._encodeAsync(Y,E,c).then((A=>{if(!A)return void y.b.Error("Draco encoding failed for primitive.");const E={bufferView:-1,attributes:A.attributeIds},Y=I.createBufferView(A.data);I.setBufferView(E,Y);for(const V of B)this._bufferViewsUsed.add(V);for(const V of F)this._accessorsUsed.add(V);V.extensions||(V.extensions={}),V.extensions[II]=E})).catch((V=>{y.b.Error("Draco encoding failed for primitive: "+V)}));this._encodePromises.push(b),this._wasUsed=!0}async preGenerateBinaryAsync(V){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((I=>{V.getPropertiesWithBufferView(I).every((V=>this._accessorsUsed.has(V)))&&V.removeBufferView(I)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}jV.RegisterExtension(II,(V=>new AI(V)));var BI=A(11856);const FI="KHR_lights_punctual",EI={name:"",color:[1,1,1],uH:1,range:Number.MAX_VALUE},YI={innerConeAngle:0,outerConeAngle:Math.PI/4},HI=B.tI.Backward();class cI{constructor(V){this.name=FI,this.enabled=!0,this.required=!1,this._exporter=V}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[FI]=this._lights}async postExportNodeAsync(V,I,A,F,E){return await new Promise((Y=>{if(!(A instanceof oV.c))return void Y(I);const H=A.getTypeID()==oV.c.LIGHTTYPEID_POINTLIGHT?"point":A.getTypeID()==oV.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":A.getTypeID()==oV.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!H||!(A instanceof BI.e))return y.b.Warn(`${V}: Light ${A.name} is not supported in ${FI}`),void Y(I);if(A.falloffType!==oV.c.FALLOFF_GLTF&&y.b.Warn(`${V}: Light falloff for ${A.name} does not match the ${FI} specification!`),!A.position.equalsToFloats(0,0,0)){const V=B.TmpVectors.tI[0].B(A.position);E&&k(V),I.translation=V.AH()}if("point"!==H){const V=A.direction.normalizeToRef(B.TmpVectors.tI[0]);E&&k(V);const F=B.Quaternion.FromUnitVectorsToRef(HI,V,B.TmpVectors.Quaternion[0]);B.Quaternion.IsIdentity(F)||(I.rotation=F.AH())}const c={type:H,name:A.name,color:A.WH.AH(),uH:A.uH,range:A.range};if(BV(c,EI),"spot"===H){const V=A;c.spot={innerConeAngle:V.innerAngle/2,outerConeAngle:V.angle/2},BV(c.spot,YI)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(c);const b={dY:this._lights.lights.length-1},X=A.parent;if(X&&IV(A,X)){const V=F.get(X);if(V){const A=this._exporter._nodes[V];return VV(I,A),A.extensions||(A.extensions={}),A.extensions[FI]=b,void Y(null)}}I.extensions||(I.extensions={}),I.extensions[FI]=b,Y(I)}))}}jV.RegisterExtension(FI,(V=>new cI(V)));var bI=A(11775);const XI="KHR_materials_anisotropy";class PI{constructor(V){this.name=XI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,A){const B=[];return A instanceof bI.c&&A.anisotropy.isEnabled&&!A.anisotropy.legacy?(A.anisotropy.texture&&B.push(A.anisotropy.texture),B):[]}postExportMaterialAsync(V,I,A){return new Promise((V=>{if(A instanceof bI.c){if(!A.anisotropy.isEnabled||A.anisotropy.legacy)return void V(I);this._wasUsed=!0,I.extensions=I.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(A.anisotropy.texture),F={anisotropyStrength:A.anisotropy.uH,anisotropyRotation:A.anisotropy.angle,anisotropyTexture:B??void 0};null!==F.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(A),I.extensions[XI]=F}V(I)}))}}jV.RegisterExtension(XI,(V=>new PI(V)));const JI="KHR_materials_clearcoat";class GI{constructor(V){this.name=JI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,A){const B=[];return A instanceof bI.c&&A.clearCoat.isEnabled?(A.clearCoat.texture&&B.push(A.clearCoat.texture),!A.clearCoat.useRoughnessFromMainTexture&&A.clearCoat.textureRoughness&&B.push(A.clearCoat.textureRoughness),A.clearCoat.bumpTexture&&B.push(A.clearCoat.bumpTexture),B):[]}postExportMaterialAsync(V,I,A){return new Promise((V=>{if(A instanceof bI.c){if(!A.clearCoat.isEnabled)return void V(I);this._wasUsed=!0,I.extensions=I.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(A.clearCoat.texture);let E;E=A.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(A.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(A.clearCoat.textureRoughness),A.clearCoat.isTintEnabled&&F.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${A.name}`),A.clearCoat.remapF0OnInterfaceChange&&F.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${A.name}`);const Y=this._exporter._materialExporter.getTextureInfo(A.clearCoat.bumpTexture),H={clearcoatFactor:A.clearCoat.uH,clearcoatTexture:B??void 0,clearcoatRoughnessFactor:A.clearCoat.roughness,clearcoatRoughnessTexture:E??void 0,clearcoatNormalTexture:Y??void 0};null===H.clearcoatTexture&&null===H.clearcoatRoughnessTexture&&null===H.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(A),I.extensions[JI]=H}V(I)}))}}jV.RegisterExtension(JI,(V=>new GI(V)));const wI="KHR_materials_diffuse_transmission";function tI(V,I){const A=I.subSurface;let B=null;return A.translucencyIntensityTexture?B=A.translucencyIntensityTexture:A.thicknessTexture&&A.useMaskFromThicknessTexture&&(B=A.thicknessTexture),B&&!A.useGltfStyleTextures?(y.b.Warn(`${V}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${I.name}`,1),null):B}class uI{constructor(V){this.name=wI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,A){const B=[];if(A instanceof wV.b&&this._isExtensionEnabled(A)){const I=tI(V,A);return I&&B.push(I),A.subSurface.translucencyColorTexture&&B.push(A.subSurface.translucencyColorTexture),B}return B}_isExtensionEnabled(V){if(V.unlit)return!1;const I=V.subSurface;return!!I.isTranslucencyEnabled&&(!V.unlit&&!I.useAlbedoToTintTranslucency&&I.useGltfStyleTextures&&1===I.volumeIndexOfRefraction&&0===I.minimumThickness&&0===I.maximumThickness)}postExportMaterialAsync(V,I,A){return new Promise((B=>{if(A instanceof wV.b&&this._isExtensionEnabled(A)){this._wasUsed=!0;const B=A.subSurface,F=tI(V,A),E=0==B.translucencyIntensity?void 0:B.translucencyIntensity,Y=this._exporter._materialExporter.getTextureInfo(F)??void 0,H=!B.translucencyColor||B.translucencyColor.equalsFloats(1,1,1)?void 0:B.translucencyColor.AH(),c=this._exporter._materialExporter.getTextureInfo(B.translucencyColorTexture)??void 0,b={diffuseTransmissionFactor:E,diffuseTransmissionTexture:Y,diffuseTransmissionColorFactor:H,diffuseTransmissionColorTexture:c};(Y||c)&&this._exporter._materialNeedsUVsSet.add(A),I.extensions=I.extensions||{},I.extensions[wI]=b}B(I)}))}}jV.RegisterExtension(wI,(V=>new uI(V)));const WI="KHR_materials_dispersion";class gI{constructor(){this.name=WI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(V){if(V.unlit)return!1;const I=V.subSurface;return!(!I.isRefractionEnabled&&!I.isDispersionEnabled)}postExportMaterialAsync(V,I,A){return new Promise((V=>{if(A instanceof wV.b&&this._isExtensionEnabled(A)){this._wasUsed=!0;const V={dispersion:A.subSurface.dispersion};I.extensions=I.extensions||{},I.extensions[WI]=V}V(I)}))}}jV.RegisterExtension(WI,(()=>new gI));const oI="KHR_materials_emissive_strength";class LI{constructor(){this.name=oI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(V,I,A){return await new Promise((V=>{if(!(A instanceof wV.b))return V(I);const B=A.emissiveColor.AH(),F=Math.max(...B);if(F>1){this._wasUsed=!0,I.extensions||(I.extensions={});const V={emissiveStrength:F},B=A.emissiveColor.scale(1/V.emissiveStrength);I.emissiveFactor=B.AH(),I.extensions[oI]=V}return V(I)}))}}jV.RegisterExtension(oI,(V=>new LI));const zI="KHR_materials_ior";class mI{constructor(){this.name=zI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(V){return!V.unlit&&(void 0!=V.indexOfRefraction&&1.5!=V.indexOfRefraction)}postExportMaterialAsync(V,I,A){return new Promise((V=>{if(A instanceof wV.b&&this._isExtensionEnabled(A)){this._wasUsed=!0;const V={ior:A.indexOfRefraction};I.extensions=I.extensions||{},I.extensions[zI]=V}V(I)}))}}jV.RegisterExtension(zI,(V=>new mI));const sI="KHR_materials_iridescence";class eI{constructor(V){this.name=sI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,A){const B=[];return A instanceof bI.c&&A.iridescence.isEnabled?(A.iridescence.texture&&B.push(A.iridescence.texture),A.iridescence.thicknessTexture&&A.iridescence.thicknessTexture!==A.iridescence.texture&&B.push(A.iridescence.thicknessTexture),B):[]}postExportMaterialAsync(V,I,A){return new Promise((V=>{if(A instanceof bI.c){if(!A.iridescence.isEnabled)return void V(I);this._wasUsed=!0,I.extensions=I.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(A.iridescence.texture),F=this._exporter._materialExporter.getTextureInfo(A.iridescence.thicknessTexture),E={iridescenceFactor:A.iridescence.uH,iridescenceIor:A.iridescence.indexOfRefraction,iridescenceThicknessMinimum:A.iridescence.minimumThickness,iridescenceThicknessMaximum:A.iridescence.maximumThickness,iridescenceTexture:B??void 0,iridescenceThicknessTexture:F??void 0};null===E.iridescenceTexture&&null===E.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(A),I.extensions[sI]=E}V(I)}))}}jV.RegisterExtension(sI,(V=>new eI(V)));const SI="KHR_materials_sheen";class QI{constructor(V){this.name=SI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,A){return A instanceof wV.b&&A.sheen.isEnabled&&A.sheen.texture?[A.sheen.texture]:[]}async postExportMaterialAsync(V,I,A){return await new Promise((V=>{if(A instanceof wV.b){if(!A.sheen.isEnabled)return void V(I);this._wasUsed=!0,null==I.extensions&&(I.extensions={});const B={sheenColorFactor:A.sheen.color.AH(),sheenRoughnessFactor:A.sheen.roughness??0};null===B.sheenColorTexture&&null===B.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(A),A.sheen.texture&&(B.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(A.sheen.texture)??void 0),A.sheen.textureRoughness&&!A.sheen.useRoughnessFromMainTexture?B.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(A.sheen.textureRoughness)??void 0:A.sheen.texture&&A.sheen.useRoughnessFromMainTexture&&(B.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(A.sheen.texture)??void 0),I.extensions[SI]=B}V(I)}))}}jV.RegisterExtension(SI,(V=>new QI(V)));const hI="KHR_materials_specular";class rI{constructor(V){this.name=hI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,A){const B=[];return A instanceof wV.b&&this._isExtensionEnabled(A)?(A.metallicReflectanceTexture&&B.push(A.metallicReflectanceTexture),A.reflectanceTexture&&B.push(A.reflectanceTexture),B):B}_isExtensionEnabled(V){return!V.unlit&&(void 0!=V.metallicF0Factor&&1!=V.metallicF0Factor||void 0!=V.metallicReflectanceColor&&!V.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(V))}_hasTexturesExtension(V){return null!=V.metallicReflectanceTexture||null!=V.reflectanceTexture}postExportMaterialAsync(V,I,A){return new Promise((V=>{if(A instanceof wV.b&&this._isExtensionEnabled(A)){this._wasUsed=!0,I.extensions=I.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(A.metallicReflectanceTexture)??void 0,B=this._exporter._materialExporter.getTextureInfo(A.reflectanceTexture)??void 0,F={specularFactor:1==A.metallicF0Factor?void 0:A.metallicF0Factor,specularTexture:V,specularColorFactor:A.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:A.metallicReflectanceColor.AH(),specularColorTexture:B};this._hasTexturesExtension(A)&&this._exporter._materialNeedsUVsSet.add(A),I.extensions[hI]=F}V(I)}))}}jV.RegisterExtension(hI,(V=>new rI(V)));const MI="KHR_materials_transmission";class xI{constructor(V){this.name=MI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,A){const B=[];return A instanceof wV.b&&this._isExtensionEnabled(A)?(A.subSurface.thicknessTexture&&B.push(A.subSurface.thicknessTexture),B):B}_isExtensionEnabled(V){if(V.unlit)return!1;const I=V.subSurface;return I.isRefractionEnabled&&void 0!=I.refractionIntensity&&0!=I.refractionIntensity||this._hasTexturesExtension(V)}_hasTexturesExtension(V){return null!=V.subSurface.refractionIntensityTexture}async postExportMaterialAsync(V,I,A){if(A instanceof wV.b&&this._isExtensionEnabled(A)){this._wasUsed=!0;const B=A.subSurface,F={transmissionFactor:0===B.refractionIntensity?void 0:B.refractionIntensity};if(this._hasTexturesExtension(A)&&this._exporter._materialNeedsUVsSet.add(A),B.refractionIntensityTexture)if(B.useGltfStyleTextures){const V=await this._exporter._materialExporter.exportTextureAsync(B.refractionIntensityTexture,"image/png");V&&(F.transmissionTexture=V)}else y.b.Warn(`${V}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);I.extensions||(I.extensions={}),I.extensions[MI]=F}return I}}jV.RegisterExtension(MI,(V=>new xI(V)));const fI="KHR_materials_unlit";class RI{constructor(){this.name=fI,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(V,I,A){return new Promise((V=>{let B=!1;A instanceof wV.b?B=A.unlit:A instanceof tV.gI&&(B=A.disableLighting),B&&(this._wasUsed=!0,null==I.extensions&&(I.extensions={}),I.extensions[fI]={}),V(I)}))}}jV.RegisterExtension(fI,(()=>new RI));const qI="KHR_materials_volume";class NI{constructor(V){this.name=qI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,A){const B=[];return A instanceof wV.b&&this._isExtensionEnabled(A)?(A.subSurface.thicknessTexture&&B.push(A.subSurface.thicknessTexture),B):B}_isExtensionEnabled(V){if(V.unlit)return!1;const I=V.subSurface;return!(!I.isRefractionEnabled&&!I.isTranslucencyEnabled)&&(void 0!=I.maximumThickness&&0!=I.maximumThickness||void 0!=I.tintColorAtDistance&&I.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=I.tintColor&&I.tintColor!=u.oI.White()||this._hasTexturesExtension(V))}_hasTexturesExtension(V){return null!=V.subSurface.thicknessTexture}postExportMaterialAsync(V,I,A){return new Promise((V=>{if(A instanceof wV.b&&this._isExtensionEnabled(A)){this._wasUsed=!0;const V=A.subSurface,B={thicknessFactor:0==V.maximumThickness?void 0:V.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(V.thicknessTexture)??void 0,attenuationDistance:V.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:V.tintColorAtDistance,attenuationColor:V.tintColor.equalsFloats(1,1,1)?void 0:V.tintColor.AH()};this._hasTexturesExtension(A)&&this._exporter._materialNeedsUVsSet.add(A),I.extensions=I.extensions||{},I.extensions[qI]=B}V(I)}))}}jV.RegisterExtension(qI,(V=>new NI(V)));const lI="EXT_materials_diffuse_roughness";class iI{constructor(V){this.name=lI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,A){const B=[];return A instanceof bI.c&&A._baseDiffuseRoughness?(A._baseDiffuseRoughnessTexture&&B.push(A._baseDiffuseRoughnessTexture),B):[]}postExportMaterialAsync(V,I,A){return new Promise((V=>{if(A instanceof bI.c){if(!A._baseDiffuseRoughness)return void V(I);this._wasUsed=!0,I.extensions=I.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(A._baseDiffuseRoughnessTexture),F={diffuseRoughnessFactor:A._baseDiffuseRoughness,diffuseRoughnessTexture:B??void 0};null!==F.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(A),I.extensions[lI]=F}V(I)}))}}jV.RegisterExtension(lI,(V=>new iI(V)));const yI="KHR_texture_transform";class vI{constructor(){this.name=yI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(V,I,A){if(A.sV()||F.Tools.Warn(`${V}: /*@__KEY__*/"scene" is not defined for Babylon texture ${A.name}!`),(0!==A.uAng||0!==A.vAng)&&(F.Tools.Warn(`${V}: Texture ${A.name} with rotation in the u or v axis is not supported in glTF.`),0!==A.uRotationCenter||0!==A.vRotationCenter))return;const B={};let E=!1;if(0===A.uOffset&&0===A.vOffset||(B.offset=[A.uOffset,A.vOffset],E=!0),1===A.uScale&&1===A.vScale||(B.scale=[A.uScale,A.vScale],E=!0),0!==A.wAng){if(0!==A.uRotationCenter||0!==A.vRotationCenter){if(A.homogeneousRotationInUVTransform&&A.uScale!==A.vScale)return void F.Tools.Warn(`${V}: Texture ${A.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${yI}.`);F.Tools.Warn(`${V}: Texture ${A.name} with non-origin rotation center will be exported using an adjusted offset with ${yI}.`),B.offset=function(V){const{uOffset:I,vOffset:A,uRotationCenter:B,vRotationCenter:F,uScale:E,vScale:Y,wAng:H}=V,c=Math.cos(H),b=Math.sin(H),X=B*E,P=F*Y;return[I+(X*(1-c)+P*b),A+(P*(1-c)-X*b)]}(A)}B.rotation=-A.wAng,E=!0}0!==A.coordinatesIndex&&(B.texCoord=A.coordinatesIndex,E=!0),E&&(this._wasUsed=!0,I.extensions||(I.extensions={}),I.extensions[yI]=B)}}jV.RegisterExtension(yI,(()=>new vI));class CI{static CreateSTL(V){let I=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",F=arguments.length>3&&void 0!==arguments[3]&&arguments[3],E=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],Y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],H=arguments.length>6&&void 0!==arguments[6]&&arguments[6],c=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const b=function(V,I,A){const F=[3*V[A],3*V[A+1],3*V[A+2]],E=[new B.tI(I[F[0]],I[F[0]+2],I[F[0]+1]),new B.tI(I[F[1]],I[F[1]+2],I[F[1]+1]),new B.tI(I[F[2]],I[F[2]+2],I[F[2]+1])],Y=E[0].uI(E[1]),H=E[2].uI(E[1]);return{v:E,n:B.tI.Cross(H,Y).normalize()}},P=function(V,I,A,B){return I=J(V,I,A.x,B),I=J(V,I,A.y,B),J(V,I,A.z,B)},J=function(V,I,A,B){return V.setFloat32(I,A,B),I+4},w=function(V){if(H){let I=V;V instanceof G.b&&(I=V.sourceMesh);const A=I.getVerticesData(X.g.PositionKind,!0,!0);if(!A)return[];const F=B.tI.Zero();let E;for(E=0;E<A.length;E+=3)B.tI.TransformCoordinatesFromFloatsToRef(A[E],A[E+1],A[E+2],V.YH(!0),F).toArray(A,E);return A}return V.getVerticesData(X.g.PositionKind)||[]};H&&(Y=!0);let t="",u=0,W=0;if(F){for(let A=0;A<V.length;A++){const I=V[A].cH();u+=I?I.length/3:0}const I=new ArrayBuffer(84+50*u);t=new DataView(I),W+=80,t.setUint32(W,u,E),W+=4}else c||(t="solid stlmesh\r\n");for(let B=0;B<V.length;B++){const I=V[B];!F&&c&&(t+="solid "+I.name+"\r\n"),!Y&&I instanceof gV.c&&I.bakeCurrentTransformIntoVertices();const A=w(I),H=I.cH()||[];for(let V=0;V<H.length;V+=3){const I=b(H,A,V);F?(W=P(t,W,I.n,E),W=P(t,W,I.v[0],E),W=P(t,W,I.v[1],E),W=P(t,W,I.v[2],E),W+=2):(t+="\tfacet normal "+I.n.x+" "+I.n.y+" "+I.n.z+"\r\n",t+="\t\touter loop\r\n",t+="\t\t\tvertex "+I.v[0].x+" "+I.v[0].y+" "+I.v[0].z+"\r\n",t+="\t\t\tvertex "+I.v[1].x+" "+I.v[1].y+" "+I.v[1].z+"\r\n",t+="\t\t\tvertex "+I.v[2].x+" "+I.v[2].y+" "+I.v[2].z+"\r\n",t+="\t\tendloop\r\n",t+="\tendfacet\r\n")}!F&&c&&(t+="endsolid "+name+"\r\n")}if(F||c||(t+="endsolid stlmesh"),I){const V=document.createElement("a"),I=new Blob([t],{type:"application/octet-stream"});V.href=window.URL.createObjectURL(I),V.download=A+".stl",V.click()}return t}}function KI(V,I){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const B=[];for(let F=0;F<V.length/A;F++){const E=V[F*A],Y=V[F*A+1],H=V[F*A+2];B.push(`(${E.toPrecision(I.precision)}, ${Y.toPrecision(I.precision)}, ${H.toPrecision(I.precision)})`)}return B.join(", ")}function pI(V,I){const A=[];for(let B=0;B<V.length/2;B++){const F=V[2*B],E=V[2*B+1];A.push(`(${F.toPrecision(I.precision)}, ${(1-E).toPrecision(I.precision)})`)}return A.join(", ")}function jI(V,I){const A=V.getVerticesData(X.g.PositionKind),B=V.getVerticesData(X.g.NormalKind);if(A&&B)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(V){var I;const A=null!==(I=V.cH())&&void 0!==I&&I.length?V.getTotalIndices():V.getTotalVertices();return Array(A/3).fill(3).join(", ")}(V)}]\n\t\tint[] faceVertexIndices = [${function(V){const I=V.cH(),A=[];if(null!==I)for(let B=0;B<I.length;B++)A.push(I[B]);else{const I=V.getTotalVertices();for(let V=0;V<I;V++)A.push(V)}return A.join(", ")}(V)}]\n\t\tnormal3f[] normals = [${KI(B,I)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${KI(A,I)}]\n        ${function(V,I){let A="";for(let F=0;F<4;F++){const B=F>0?F:"",E=V.getVerticesData(X.g.UVKind+(B?B+1:""));E&&(A+=`\n\t\ttexCoord2f[] primvars:st${B} = [${pI(E,I)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const B=V.getVerticesData(X.g.ColorKind);return B&&(A+=`\n\tcolor3f[] primvars:displayColor = [${KI(B,I,B.length/V.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),A}(V,I)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function TI(V,I){return`\n        def "Geometry"\n        {\n        ${jI(V,I)}\n        }\n        `}function dI(V){let I='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return I+=V,fflate.strToU8(I)}function DI(V){const I=V.m;return`( ${OI(I,0)}, ${OI(I,4)}, ${OI(I,8)}, ${OI(I,12)} )`}function OI(V,I){return`(${V[I+0]}, ${V[I+1]}, ${V[I+2]}, ${V[I+3]})`}function ZI(V){const I="Object_"+V.uniqueId,A=function(V){const I=V.getWorldMatrix().clone(),A=V.sV().useRightHandedSystem;if(!A){let B=V.parent;for(;B;){if(YV(B,A)){I.multiplyToRef(B.getWorldMatrix().invert(),I);break}B=B.parent}}return I.determinant()<0&&F.Tools.Warn(`Exporting mesh ${V.name} with negative scale. Result may look incorrect in destination engine.`),I}(V),B=DI(A);return`def Xform "${I}" (\n\tprepend references = @./geometries/Geometry_${V.HH.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${B}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${V.material.uniqueId}>\n}\n\n`}function aI(V){switch(V){case s.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case s.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case s.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function kI(V){return`(${V.x}, ${V.y})`}function UI(V){return`(${V.r}, ${V.g}, ${V.b})`}function nI(V,I,A,F,E,Y){const H=V.getInternalTexture().uniqueId+"_"+V.invertY;E[H]=V;const c=V.coordinatesIndex>0?"st"+V.coordinatesIndex:"st",b=new B.Vector2(V.uScale,V.vScale),X=new B.Vector2(V.uOffset,V.vOffset),P=V.wAng,J=Math.sin(P),G=Math.cos(P);return X.y=1-X.y-b.y,X.x+=J*b.x,X.y+=(1-G)*b.y,`\n    def Shader "PrimvarReader_${A}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${c}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${A}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${I.uniqueId}/PrimvarReader_${A}.outputs:result>\n        float inputs:rotation = ${(P*(180/Math.PI)).toFixed(Y.precision)}\n        float2 inputs:scale = ${kI(b)}\n        float2 inputs:translation = ${kI(X)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${V.uniqueId}_${A}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${H}.png@\n        float2 inputs:st.connect = </Materials/Material_${I.uniqueId}/Transform2d_${A}.outputs:result>\n        ${F?"float4 inputs:scale = "+function(V){return`(${V.r}, ${V.g}, ${V.b}, 1.0)`}(F):""}\n        token inputs:sourceColorSpace = "${V.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${aI(V.wrapU)}"\n        token inputs:wrapT = "${aI(V.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${I.needAlphaBlending()?"float outputs:a":""}\n    }`}function VA(V,I,A){const B="\t\t\t",F=[],E=[],{diffuseMap:Y,WH:H,alphaCutOff:c,emissiveMap:b,emissive:X,normalMap:P,roughnessMap:J,roughnessChannel:G,roughness:w,metalnessMap:t,metalnessChannel:W,metalness:g,aoMap:o,aoMapChannel:L,aoMapIntensity:z,alphaMap:m,ior:s,clearCoatEnabled:e,clearCoat:S,clearCoatMap:Q,clearCoatRoughness:h,clearCoatRoughnessMap:r}=function(V){const I={diffuseMap:null,WH:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return V instanceof tV.gI?{...I,diffuseMap:V.diffuseTexture,WH:V.diffuseColor,alphaCutOff:V.alphaCutOff,emissiveMap:V.emissiveTexture,emissive:V.emissiveColor,roughness:1,alphaMap:V.opacityTexture}:V instanceof bI.c?{...I,diffuseMap:V._albedoTexture,WH:V._albedoColor,alphaCutOff:V._alphaCutOff,emissiveMap:V._emissiveTexture,emissive:V._emissiveColor,normalMap:V._bumpTexture,roughnessMap:V._metallicTexture,roughnessChannel:V._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:V._roughness??1,metalnessMap:V._metallicTexture,metalnessChannel:V._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:V._metallic??0,aoMap:V._ambientTexture,aoMapChannel:V._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:V._ambientTextureStrength,alphaMap:V._opacityTexture,ior:V.subSurface.indexOfRefraction,clearCoatEnabled:V.clearCoat.isEnabled,clearCoat:V.clearCoat.uH,clearCoatMap:V.clearCoat.texture,clearCoatRoughness:V.clearCoat.roughness,clearCoatRoughnessMap:V.clearCoat.useRoughnessFromMainTexture?V.clearCoat.texture:V.clearCoat.textureRoughness}:I}(V);return null!==Y?(F.push(`${B}color3f inputs:diffuseColor.connect = </Materials/Material_${V.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:rgb>`),V.needAlphaBlending()?F.push(`${B}float inputs:opacity.connect = </Materials/Material_${V.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`):V.needAlphaTesting()&&(F.push(`${B}float inputs:opacity.connect = </Materials/Material_${V.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`),F.push(`${B}float inputs:opacityThreshold = ${c}`)),E.push(nI(Y,V,"diffuse",H,I,A))):F.push(`${B}color3f inputs:diffuseColor = ${UI(H||u.oI.White())}`),null!==b?(F.push(`${B}color3f inputs:emissiveColor.connect = </Materials/Material_${V.uniqueId}/Texture_${b.uniqueId}_emissive.outputs:rgb>`),E.push(nI(b,V,"emissive",X,I,A))):X&&X.toLuminance()>0&&F.push(`${B}color3f inputs:emissiveColor = ${UI(X)}`),null!==P&&(F.push(`${B}normal3f inputs:normal.connect = </Materials/Material_${V.uniqueId}/Texture_${P.uniqueId}_normal.outputs:rgb>`),E.push(nI(P,V,"normal",null,I,A))),null!==o&&(F.push(`${B}float inputs:occlusion.connect = </Materials/Material_${V.uniqueId}/Texture_${o.uniqueId}_occlusion.outputs:${L}>`),E.push(nI(o,V,"occlusion",new u.oI(z,z,z),I,A))),null!==J?(F.push(`${B}float inputs:roughness.connect = </Materials/Material_${V.uniqueId}/Texture_${J.uniqueId}_roughness.outputs:${G}>`),E.push(nI(J,V,"roughness",new u.oI(w,w,w),I,A))):F.push(`${B}float inputs:roughness = ${w}`),null!==t?(F.push(`${B}float inputs:metallic.connect = </Materials/Material_${V.uniqueId}/Texture_${t.uniqueId}_metallic.outputs:${W}>`),E.push(nI(t,V,"metallic",new u.oI(g,g,g),I,A))):F.push(`${B}float inputs:metallic = ${g}`),null!==m?(F.push(`${B}float inputs:opacity.connect = </Materials/Material_${V.uniqueId}/Texture_${m.uniqueId}_opacity.outputs:r>`),F.push(`${B}float inputs:opacityThreshold = 0.0001`),E.push(nI(m,V,"opacity",null,I,A))):F.push(`${B}float inputs:opacity = ${V.alpha}`),e&&(null!==Q?(F.push(`${B}float inputs:clearcoat.connect = </Materials/Material_${V.uniqueId}/Texture_${Q.uniqueId}_clearcoat.outputs:r>`),E.push(nI(Q,V,"clearcoat",new u.oI(S,S,S),I,A))):F.push(`${B}float inputs:clearcoat = ${S}`),null!==r?(F.push(`${B}float inputs:clearcoatRoughness.connect = </Materials/Material_${V.uniqueId}/Texture_${r.uniqueId}_clearcoatRoughness.outputs:g>`),E.push(nI(r,V,"clearcoatRoughness",new u.oI(h,h,h),I,A))):F.push(`${B}float inputs:clearcoatRoughness = ${h}`)),F.push(`${B}float inputs:ior = ${s}`),`\n\tdef Material "Material_${V.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${F.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${V.uniqueId}/PreviewSurface.outputs:surface>\n\n${E.join("\n")}\n\n\t}\n`}async function IA(V,I,A){const E={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...I};"undefined"===typeof fflate&&await F.Tools.LoadScriptAsync(E.fflateUrl);const Y={};Y[E.modelFileName]=null;let H='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';H+=function(V){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===V.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${V.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${V.planeAnchoringAlignment}"`:""}\n            `}(E);const c={};for(const B of V.meshes){if(0===B.getTotalVertices())continue;const V=B,I=V.HH,b=V.material;if(!b||!I||A&&!A(V))continue;if(-1!==["gI","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(b.getClassName())){const A="geometries/Geometry_"+I.uniqueId+".usda";if(!(A in Y)){const V=TI(I,E);Y[A]=dI(V)}b.uniqueId in c||(c[b.uniqueId]=b),H+=ZI(V)}else F.Tools.Warn("USDZExportAsync does not support this material type: "+b.getClassName())}V.activeCamera&&E.exportCamera&&(H+=function(V,I){const A="Camera_"+V.uniqueId,F=DI(B.Matrix.RotationY(Math.PI).multiply(V.getWorldMatrix()));if(V.mode===s.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${A}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${F}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${V.FH.toPrecision(I.precision)}, ${V.maxZ.toPrecision(I.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(V.orthoLeft||1)+Math.abs(V.orthoRight||1))).toPrecision(I.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(V.orthoTop||1)+Math.abs(V.orthoBottom||1))).toPrecision(I.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const B=V.getEngine().getAspectRatio(V),E=I.cameraSensorWidth||35;return`def Camera "${A}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${F}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${V.FH.toPrecision(I.precision)}, ${V.maxZ.toPrecision(I.precision)})\n\t\t\tfloat focalLength = ${(E/(2*Math.tan(.5*V.fov))).toPrecision(I.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(E*B).toPrecision(I.precision)}\n\t\t\tfloat verticalAperture = ${(E/B).toPrecision(I.precision)}            \n\t\t}\n\t\n\t`}}(V.activeCamera,E)),H+="\n            }\n        }\n    }";const b={};H+=function(V,I,A){const B=[];for(const F in V){const E=V[F];B.push(VA(E,I,A))}return`\n    def "Materials"\n{\n${B.join("")}\n}\n\n`}(c,b,E),Y[E.modelFileName]=fflate.strToU8(H);for(const B in b){const V=b[B],I=V.getSize(),A=await V.readPixels();if(!A)throw new Error("Texture data is not available");const F=await e.DumpTools.DumpDataAsync(I.width,I.height,A,"image/png",void 0,!1,!0);Y[`textures/Texture_${B}.png`]=new Uint8Array(F).slice()}let X=0;for(const B in Y){const V=Y[B];if(!V)continue;X+=34+B.length;const I=63&X;if(4!==I){const A=new Uint8Array(64-I);Y[B]=[V,{extra:{12345:A}}]}X=V.length}return fflate.zipSync(Y,{level:0})}}}]);