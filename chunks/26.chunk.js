"use strict";(self.hmihoa2fs98=self.hmihoa2fs98||[]).push([[26],{12094:(b,d,P)=>{P.r(d),P.d(d,{EXT_materials_diffuse_roughness:()=>ad,EXT_mesh_gpu_instancing:()=>mb,GLTF2Export:()=>Qb,GLTFData:()=>L,KHR_draco_mesh_compression:()=>Pd,KHR_lights_punctual:()=>Jd,KHR_materials_anisotropy:()=>Yd,KHR_materials_clearcoat:()=>Ed,KHR_materials_diffuse_transmission:()=>rd,KHR_materials_dispersion:()=>nd,KHR_materials_emissive_strength:()=>od,KHR_materials_ior:()=>fd,KHR_materials_iridescence:()=>Xd,KHR_materials_sheen:()=>Md,KHR_materials_specular:()=>Rd,KHR_materials_transmission:()=>Hd,KHR_materials_unlit:()=>Sd,KHR_materials_volume:()=>Nd,KHR_texture_transform:()=>Vd,OBJExport:()=>q,STLExport:()=>yd,USDZExportAsync:()=>dP,_ConvertToGLTFPBRMetallicRoughness:()=>p,_SolveMetallic:()=>H,__IGLTFExporterExtension:()=>C});var G=P(11681),W=P(11484),i=P(11999);class q{static OBJ(b,d,P,q){const C=[];let J=1,L=1;d&&(P||(P="mat"),C.push("mtllib "+P+".mtl"));for(let x=0;x<b.length;x++){const P=b[x],Y=P.name||`mesh${x}}`;C.push(`o ${Y}`);let s=null;if(q){const b=P.zd(!0);s=new G.Matrix,b.invertToRef(s),P.bakeTransformIntoVertices(b)}if(d){const b=P.material;b&&C.push("usemtl "+b.id)}const E=P.Qd;if(!E){W.Tools.Warn("No geometry is present on the mesh");continue}const w=E.getVerticesData("position"),t=E.getVerticesData("normal"),r=E.getVerticesData("uv"),B=E.Id();let n=0,Z=0;if(!w||!B){W.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const o=b[0].Xb().useRightHandedSystem?1:-1;for(let b=0;b<w.length;b+=3)C.push("v "+w[b]*o+" "+w[b+1]+" "+w[b+2]),n++;if(null!=t)for(let b=0;b<t.length;b+=3)C.push("vn "+t[b]*o+" "+t[b+1]+" "+t[b+2]);if(null!=r)for(let b=0;b<r.length;b+=2)C.push("vt "+r[b]+" "+r[b+1]),Z++;const A=["","",""],f=(P.material||P.Xb().defaultMaterial)._getEffectiveOrientation(P),[g,X]=f===i.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let b=0;b<B.length;b+=3){const d=[String(B[b]+J),String(B[b+g]+J),String(B[b+X]+J)],P=[String(B[b]+L),String(B[b+g]+L),String(B[b+X]+L)],G=d,W=null!=r?P:A,i=null!=t?d:A;C.push("f "+G[0]+"/"+W[0]+"/"+i[0]+" "+G[1]+"/"+W[1]+"/"+i[1]+" "+G[2]+"/"+W[2]+"/"+i[2])}q&&s&&P.bakeTransformIntoVertices(s),J+=n,L+=Z}return C.join("\n")}static MTL(b){const d=[],P=b.material;d.push("newmtl mat1"),d.push("  Ns "+P.specularPower.toFixed(4)),d.push("  Ni 1.5000"),d.push("  d "+P.alpha.toFixed(4)),d.push("  Tr 0.0000"),d.push("  Tf 1.0000 1.0000 1.0000"),d.push("  illum 2"),d.push("  Ka "+P.ambientColor.r.toFixed(4)+" "+P.ambientColor.g.toFixed(4)+" "+P.ambientColor.b.toFixed(4)),d.push("  Kd "+P.diffuseColor.r.toFixed(4)+" "+P.diffuseColor.g.toFixed(4)+" "+P.diffuseColor.b.toFixed(4)),d.push("  Ks "+P.specularColor.r.toFixed(4)+" "+P.specularColor.g.toFixed(4)+" "+P.specularColor.b.toFixed(4)),d.push("  Ke "+P.emissiveColor.r.toFixed(4)+" "+P.emissiveColor.g.toFixed(4)+" "+P.emissiveColor.b.toFixed(4));P.ambientTexture&&d.push("  map_Ka "+P.ambientTexture.name),P.diffuseTexture&&d.push("  map_Kd "+P.diffuseTexture.name),P.specularTexture&&d.push("  map_Ks "+P.specularTexture.name),P.bumpTexture&&d.push("  map_bump -imfchan z "+P.bumpTexture.name),P.opacityTexture&&d.push("  map_d "+P.opacityTexture.name);return d.join("\n")}}var C=0,J=P(11539);class L{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const b in this.files){const d=this.files[b],P=new Blob([d],{type:(0,J.h)(b)});W.Tools.Download(P,b)}}}var x=P(11752),Y=P(12103),s=P(12115),E=P(12126),w=P(11806),t=P(11535),r=P(11725),B=P(11700);const n=B.HighestCommonFactor,Z={...B,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:n};var o=P(11898),A=P(11658),f=P(12160),g=P(12163),X=P(11890);const u=1e-6,M=new r.Nd(.04,.04,.04),e=1024,R=r.Nd.White(),U=r.Nd.Black();function H(b,d,P){if(d<M.r)return 0;const G=M.r,W=b*P/(1-M.r)+d-2*M.r,i=W*W-4*G*(M.r-d);return Z.Clamp((-W+Math.sqrt(i))/(2*G),0,1)}function p(b){const d=b.diffuseColor.toLinearSpace(b.Xb().getEngine().useExactSrgbConversions).scale(.5),P=b.alpha,W=function(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new G.Vector2(0,1),P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new G.Vector2(0,.1),W=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new G.Vector2(0,.1),i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new G.Vector2(1300,.1);return function(b,d,P,G,W){return(1-b)*(1-b)*(1-b)*d+3*(1-b)*(1-b)*b*P+3*(1-b)*b*b*G+b*b*b*W}(Math.pow(b/i.x,.333333),d.y,P.y,W.y,i.y)}(Z.Clamp(b.specularPower,0,e));return{baseColorFactor:[d.r,d.g,d.b,P],metallicFactor:0,roughnessFactor:W}}function S(b,d){d.needAlphaBlending()?b.alphaMode="BLEND":d.needAlphaTesting()&&(b.alphaMode="MASK",b.alphaCutoff=d.alphaCutOff)}function l(b,d,P){const G=new Uint8Array(b*d*4);for(let W=0;W<G.length;W+=4)G[W]=G[W+1]=G[W+2]=G[W+3]=255;return f.b.CreateRGBATexture(G,b,d,P)}function N(b){if(b instanceof Uint8Array){const d=b.length,P=new Float32Array(b.length);for(let G=0;G<d;++G)P[G]=b[G]/255;return P}if(b instanceof Float32Array)return b;throw new Error("Unsupported pixel format!")}class j{constructor(b){this._exporter=b,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(b){return b?this._textureMap.get(b)??null:null}async exportStandardMaterialAsync(b,d,P){const G=p(b),i={name:b.name};if(null==b.md||b.md||(b.twoSidedLighting||W.Tools.Warn(b.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),i.doubleSided=!0),P){const P=[],W=b.diffuseTexture;W&&P.push(this.exportTextureAsync(W,d).then((b=>{b&&(G.baseColorTexture=b)})));const q=b.bumpTexture;q&&P.push(this.exportTextureAsync(q,d).then((b=>{b&&(i.normalTexture=b,1!==q.level&&(i.normalTexture.scale=q.level))})));const C=b.emissiveTexture;C&&(i.emissiveFactor=[1,1,1],P.push(this.exportTextureAsync(C,d).then((b=>{b&&(i.emissiveTexture=b)}))));const J=b.ambientTexture;J&&P.push(this.exportTextureAsync(J,d).then((b=>{if(b){const d={index:b.index};i.occlusionTexture=d}}))),P.length>0&&(this._exporter._materialNeedsUVsSet.add(b),await Promise.all(P))}(b.alpha<1||b.opacityTexture)&&(b.alphaMode===g.d.ALPHA_COMBINE?i.alphaMode="BLEND":W.Tools.Warn(b.name+": glTF 2.0 does not support alpha mode: "+b.alphaMode.toString())),b.emissiveColor&&!b.emissiveColor.equalsWithEpsilon(U,u)&&(i.emissiveFactor=b.emissiveColor.jd()),i.pbrMetallicRoughness=G,S(i,b),await this._finishMaterialAsync(i,b,d);const q=this._exporter._materials;return q.push(i),q.length-1}async _finishMaterialAsync(b,d,P){const G=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",b,d),W=[];for(const i of G)W.push(this.exportTextureAsync(i,P));await Promise.all(W),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",b,d)}async _getImageDataAsync(b,d,G,W){const i=g.d.TEXTURETYPE_UNSIGNED_BYTE,q=this._exporter._babylonScene,C=q.getEngine(),J=C.createRawTexture(b,d,G,g.d.TEXTUREFORMAT_RGBA,!1,!0,A.d.NEAREST_SAMPLINGMODE,null,i);C.isWebGPU?await P.e(51).then(P.bind(P,14129)):await P.e(52).then(P.bind(P,14136)),await o.g.ApplyPostProcess("pass",J,q,i,g.d.TEXTURE_NEAREST_SAMPLINGMODE,g.d.TEXTUREFORMAT_RGBA);const L=await C._readTexturePixels(J,d,G);return await X.DumpTools.DumpDataAsync(d,G,L,W,void 0,!0,!0)}_resizeTexturesToSameDimensions(b,d,P){const G=b?b.getSize():{width:0,height:0},W=d?d.getSize():{width:0,height:0};let i,q;return G.width<W.width?(i=b&&b instanceof A.d?o.g.CreateResizedCopy(b,W.width,W.height,!0):l(W.width,W.height,P),q=d):G.width>W.width?(q=d&&d instanceof A.d?o.g.CreateResizedCopy(d,G.width,G.height,!0):l(G.width,G.height,P),i=b):(i=b,q=d),{texture1:i,texture2:q}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(b,d,P,G){const W=new Array;if(!b&&!d)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const i=b?b.Xb():d?d.Xb():null;if(i){var q;const C=this._resizeTexturesToSameDimensions(b,d,i),J=null===(q=C.texture1)||void 0===q?void 0:q.getSize();let L,x;const Y=J.width,s=J.height,E=await C.texture1.readPixels(),w=await C.texture2.readPixels();if(!E)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(L=N(E),!w)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");x=N(w);const t=x.byteLength,B=new Uint8Array(t),n=new Uint8Array(t),Z=4,o=U;let A=0,f=0;for(let b=0;b<s;++b)for(let d=0;d<Y;++d){const G=(Y*b+d)*Z,W={diffuseColor:new r.Nd(L[G],L[G+1],L[G+2]).toLinearSpace(i.getEngine().useExactSrgbConversions).multiply(P.diffuseColor),specularColor:new r.Nd(x[G],x[G+1],x[G+2]).toLinearSpace(i.getEngine().useExactSrgbConversions).multiply(P.specularColor),glossiness:x[G+3]*P.glossiness},q=this._convertSpecularGlossinessToMetallicRoughness(W);o.r=Math.max(o.r,q.baseColor.r),o.g=Math.max(o.g,q.baseColor.g),o.b=Math.max(o.b,q.baseColor.b),A=Math.max(A,q.metallic),f=Math.max(f,q.roughness),n[G]=255*q.baseColor.r,n[G+1]=255*q.baseColor.g,n[G+2]=255*q.baseColor.b,n[G+3]=C.texture1.ad?255*L[G+3]:255,B[G]=0,B[G+1]=255*q.roughness,B[G+2]=255*q.metallic,B[G+3]=255}const g={baseColor:o,metallic:A,roughness:f};let X=!1,M=!1;for(let b=0;b<s;++b)for(let d=0;d<Y;++d){const P=(Y*b+d)*Z;n[P]/=g.baseColor.r>u?g.baseColor.r:1,n[P+1]/=g.baseColor.g>u?g.baseColor.g:1,n[P+2]/=g.baseColor.b>u?g.baseColor.b:1;const G=r.Nd.FromInts(n[P],n[P+1],n[P+2]).toGammaSpace(i.getEngine().useExactSrgbConversions);n[P]=255*G.r,n[P+1]=255*G.g,n[P+2]=255*G.b,G.equalsWithEpsilon(R,u)||(M=!0),B[P+1]/=g.roughness>u?g.roughness:1,B[P+2]/=g.metallic>u?g.metallic:1;r.Nd.FromInts(255,B[P+1],B[P+2]).equalsWithEpsilon(R,u)||(X=!0)}return X&&W.push(this._getImageDataAsync(B,Y,s,G).then((b=>{g.metallicRoughnessTextureData=b}))),M&&W.push(this._getImageDataAsync(n,Y,s,G).then((b=>{g.baseColorTextureData=b}))),await Promise.all(W).then((()=>g))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(b){const d=this._getPerceivedBrightness(b.diffuseColor),P=this._getPerceivedBrightness(b.specularColor),G=1-this._getMaxComponent(b.specularColor),W=H(d,P,G),i=b.diffuseColor.scale(G/(1-M.r)/Math.max(1-W)),q=b.specularColor.Rd(M.scale(1-W)).scale(1/Math.max(W));let C=r.Nd.Lerp(i,q,W*W);C=C.clampToRef(0,1,C);return{baseColor:C,metallic:W,roughness:1-b.glossiness}}_getPerceivedBrightness(b){return b?Math.sqrt(.299*b.r*b.r+.587*b.g*b.g+.114*b.b*b.b):0}_getMaxComponent(b){return b?Math.max(b.r,Math.max(b.g,b.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(b,d,P,G){const W=[],i={baseColor:b._albedoColor,metallic:b._metallic,roughness:b._roughness};if(G){b._albedoTexture&&W.push(this.exportTextureAsync(b._albedoTexture,d).then((b=>{b&&(P.baseColorTexture=b)})));const G=b._metallicTexture;G&&W.push(this.exportTextureAsync(G,d).then((b=>{b&&(P.metallicRoughnessTexture=b)})))}return W.length>0&&(this._exporter._materialNeedsUVsSet.add(b),await Promise.all(W)),i}_getTextureSampler(b){const d={};if(!b||!(b instanceof A.d))return d;const P=this._getGLTFTextureWrapMode(b.wrapU);10497!==P&&(d.wrapS=P);const G=this._getGLTFTextureWrapMode(b.wrapV);switch(10497!==G&&(d.wrapT=G),b.samplingMode){case A.d.LINEAR_LINEAR:d.magFilter=9729,d.minFilter=9729;break;case A.d.LINEAR_NEAREST:d.magFilter=9729,d.minFilter=9728;break;case A.d.NEAREST_LINEAR:d.magFilter=9728,d.minFilter=9729;break;case A.d.NEAREST_LINEAR_MIPLINEAR:d.magFilter=9728,d.minFilter=9987;break;case A.d.NEAREST_NEAREST:d.magFilter=9728,d.minFilter=9728;break;case A.d.NEAREST_LINEAR_MIPNEAREST:d.magFilter=9728,d.minFilter=9985;break;case A.d.LINEAR_NEAREST_MIPNEAREST:d.magFilter=9729,d.minFilter=9984;break;case A.d.LINEAR_NEAREST_MIPLINEAR:d.magFilter=9729,d.minFilter=9986;break;case A.d.NEAREST_NEAREST_MIPLINEAR:d.magFilter=9728,d.minFilter=9986;break;case A.d.LINEAR_LINEAR_MIPLINEAR:d.magFilter=9729,d.minFilter=9987;break;case A.d.LINEAR_LINEAR_MIPNEAREST:d.magFilter=9729,d.minFilter=9985;break;case A.d.NEAREST_NEAREST_MIPNEAREST:d.magFilter=9728,d.minFilter=9984}return d}_getGLTFTextureWrapMode(b){switch(b){case A.d.WRAP_ADDRESSMODE:return 10497;case A.d.CLAMP_ADDRESSMODE:return 33071;case A.d.MIRROR_ADDRESSMODE:return 33648;default:return W.Tools.Error(`Unsupported Texture Wrap Mode ${b}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(b,d,P,G){const W={diffuseColor:b._albedoColor,specularColor:b._reflectivityColor,glossiness:b._microSurface},i=b._albedoTexture,q=b._reflectivityTexture,C=b._useMicroSurfaceFromReflectivityMapAlpha;if(q&&!C)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((i||q)&&G){this._exporter._materialNeedsUVsSet.add(b);const G=this._exportTextureSampler(i||q),C=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(i,q,W,d),J=this._exporter._textures;if(C.baseColorTextureData){const b=this._exportImage(`baseColor${J.length}`,d,C.baseColorTextureData);P.baseColorTexture=this._exportTextureInfo(b,G,null===i||void 0===i?void 0:i.coordinatesIndex)}if(C.metallicRoughnessTextureData){const b=this._exportImage(`metallicRoughness${J.length}`,d,C.metallicRoughnessTextureData);P.metallicRoughnessTexture=this._exportTextureInfo(b,G,null===q||void 0===q?void 0:q.coordinatesIndex)}return C}return this._convertSpecularGlossinessToMetallicRoughness(W)}async exportPBRMaterialAsync(b,d,P){const G={},W={name:b.name},i=b.isMetallicWorkflow();if(i){const d=b._albedoColor,P=b.alpha;d&&(G.baseColorFactor=[d.r,d.g,d.b,P])}const q=i?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(b,d,G,P):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(b,d,G,P);await this._setMetallicRoughnessPbrMaterialAsync(q,b,W,G,d,P),await this._finishMaterialAsync(W,b,d);const C=this._exporter._materials;return C.push(W),C.length-1}async _setMetallicRoughnessPbrMaterialAsync(b,d,P,G,i,q){if(S(P,d),b.baseColor.equalsWithEpsilon(R,u)&&Z.WithinEpsilon(d.alpha,1,u)||(G.baseColorFactor=[b.baseColor.r,b.baseColor.g,b.baseColor.b,d.alpha]),null!=b.metallic&&1!==b.metallic&&(G.metallicFactor=b.metallic),null!=b.roughness&&1!==b.roughness&&(G.roughnessFactor=b.roughness),null==d.md||d.md||(d._twoSidedLighting||W.Tools.Warn(d.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),P.doubleSided=!0),q){const b=[],G=d._bumpTexture;G&&b.push(this.exportTextureAsync(G,i).then((b=>{b&&(P.normalTexture=b,1!==G.level&&(P.normalTexture.scale=G.level))})));const W=d._ambientTexture;W&&b.push(this.exportTextureAsync(W,i).then((b=>{if(b){const G={index:b.index,texCoord:b.texCoord,extensions:b.extensions};P.occlusionTexture=G;const W=d._ambientTextureStrength;W&&(G.strength=W)}})));const q=d._emissiveTexture;q&&b.push(this.exportTextureAsync(q,i).then((b=>{b&&(P.emissiveTexture=b)}))),b.length>0&&(this._exporter._materialNeedsUVsSet.add(d),await Promise.all(b))}const C=d._emissiveColor;C.equalsWithEpsilon(U,u)||(P.emissiveFactor=C.jd()),P.pbrMetallicRoughness=G}_getPixelsFromTextureAsync(b){return function(b){switch(b){case g.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case g.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case g.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case g.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case g.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case g.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case g.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case g.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case g.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case g.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case g.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case g.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(b.textureFormat)?(0,o.f)(b,b._texture.width,b._texture.height):(b.textureType,g.d.TEXTURETYPE_UNSIGNED_BYTE,b.readPixels())}async exportTextureAsync(b,d){const P=this._exporter._extensionsPreExportTextureAsync("exporter",b,d);return P?await P.then((async P=>P?await this._exportTextureInfoAsync(P,d):await this._exportTextureInfoAsync(b,d))):await this._exportTextureInfoAsync(b,d)}async _exportTextureInfoAsync(b,d){let P=this._textureMap.get(b);if(!P){const G=await this._getPixelsFromTextureAsync(b);if(!G)return null;const i=this._exportTextureSampler(b),q=b.mimeType;if(q)switch(q){case"image/jpeg":case"image/png":case"image/webp":d=q;break;default:W.Tools.Warn(`Unsupported media type: ${q}. Exporting texture as PNG.`)}const C=this._internalTextureToImage,J=b.getInternalTexture().uniqueId;C[J]||(C[J]={});let L=C[J][d];if(void 0===L){const P=b.getSize();L=(async()=>{const W=await this._getImageDataAsync(G,P.width,P.height,d);return this._exportImage(b.name,d,W)})(),C[J][d]=L}P=this._exportTextureInfo(await L,i,b.coordinatesIndex),this._textureMap.set(b,P),this._exporter._extensionsPostExportTextures("exporter",P,b)}return P}_exportImage(b,d,P){const G=this._exporter._images;let i;if(this._exporter._shouldUseGlb){i={name:b,mimeType:d,bufferView:void 0};const G=this._exporter._bufferManager.createBufferView(new Uint8Array(P));this._exporter._bufferManager.setBufferView(i,G)}else{const q=b.replace(/\.\/|\/|\.\\|\\/g,"_"),C=function(b){switch(b){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(d);let J=q+C;G.some((b=>b.uri===J))&&(J=`${q}_${W.Tools.RandomId()}${C}`),i={name:b,uri:J},this._exporter._imageData[J]={data:P,mimeType:d}}return G.push(i),G.length-1}_exportTextureInfo(b,d,P){const G=this._exporter._textures;let W=G.findIndex((P=>P.sampler==d&&P.source===b));-1===W&&(W=G.length,G.push({source:b,sampler:d}));const i={index:W};return P&&(i.texCoord=P),i}_exportTextureSampler(b){const d=this._getTextureSampler(b),P=this._exporter._samplers,G=P.findIndex((b=>b.minFilter===d.minFilter&&b.magFilter===d.magFilter&&b.wrapS===d.wrapS&&b.wrapT===d.wrapT));return-1!==G?G:(P.push(d),P.length-1)}}var a=P(11765),O=P(11504),V=P(12168),y=P(11688);const c=G.ed.Zero(),D=G.Quaternion.Identity(),z=G.ed.One(),Q=new G.ed(-1,1,1);function I(b,d){const{byteOffset:P,byteStride:G,type:W,normalized:i}=b,q=b.getSize(),C=d.reduce(((b,d)=>d.getTotalVertices()>b?d.getTotalVertices():b),-Number.MAX_VALUE);return{byteOffset:P,byteStride:G,componentCount:q,type:W,count:C*q,normalized:i,totalVertices:C,kind:b.getKind()}}function m(b){switch(b){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function v(b){switch(b){case x.c.PositionKind:case x.c.NormalKind:case x.c.TangentKind:case x.c.ColorKind:case x.c.MatricesIndicesKind:case x.c.MatricesIndicesExtraKind:case x.c.MatricesWeightsKind:case x.c.MatricesWeightsExtraKind:case x.c.UVKind:case x.c.UV2Kind:case x.c.UV3Kind:case x.c.UV4Kind:case x.c.UV5Kind:case x.c.UV6Kind:return!0}return!1}function F(b){switch(b){case i.e.TriangleFillMode:return 4;case i.e.TriangleStripDrawMode:return 5;case i.e.TriangleFanDrawMode:return 6;case i.e.PointListDrawMode:case i.e.PointFillMode:return 0;case i.e.LineLoopDrawMode:return 2;case i.e.LineListDrawMode:return 1;case i.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${b}`)}function h(b){const d=Math.sqrt(b.x*b.x+b.y*b.y+b.z*b.z);d>0&&(b.x/=d,b.y/=d,b.z/=d)}function T(b){return b.x*=-1,b}function K(b){if(b.x*b.x+b.y*b.y>.5){const d=Math.abs(b.x),P=Math.abs(b.y);if(d>P){const P=Math.sign(b.x);b.x=d,b.y*=-P,b.z*=-P,b.w*=P}else{const d=Math.sign(b.y);b.x*=-d,b.y=P,b.z*=d,b.w*=-d}}else{const d=Math.abs(b.z),P=Math.abs(b.w);if(d>P){const P=Math.sign(b.z);b.x*=-P,b.y*=P,b.z=d,b.w*=-P}else{const d=Math.sign(b.w);b.x*=d,b.y*=-d,b.z*=-d,b.w=P}}return b}function k(b){b.Fd(-b.z,b.w,b.x,-b.y)}function bb(b,d){const P=G.ed.FromArrayToRef(d.translation||[0,0,0],0,G.TmpVectors.ed[0]),W=G.Quaternion.FromArrayToRef(d.rotation||[0,0,0,1],0,G.TmpVectors.Quaternion[0]),i=G.Matrix.ComposeToRef(z,W,P,G.TmpVectors.Matrix[0]),q=G.ed.FromArrayToRef(b.translation||[0,0,0],0,G.TmpVectors.ed[2]),C=G.Quaternion.FromArrayToRef(b.rotation||[0,0,0,1],0,G.TmpVectors.Quaternion[1]),J=G.Matrix.ComposeToRef(z,C,q,G.TmpVectors.Matrix[1]);i.multiplyToRef(J,J),J.decompose(void 0,W,P),P.equalsWithEpsilon(c,y.c)?delete d.translation:d.translation=P.jd(),W.equalsWithEpsilon(D,y.c)?delete d.rotation:d.rotation=W.jd(),d.scale&&delete d.scale}function db(b,d){if(!(d instanceof Y.b))return!1;if(!(1===d.getChildren().length&&0===b.getChildren().length&&b.parent===d))return!1;const P=b.Xb(),G=b instanceof V.d&&!P.useRightHandedSystem?Q:z;return!!d.hd.equalsWithEpsilon(G,y.c)||(O.e.Warn(`Cannot collapse node ${b.name} into parent node ${d.name} with modified scaling.`),!1)}function Pb(b){if(b instanceof Array){const d=new Float32Array(b);return new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}return ArrayBuffer.isView(b)?new Uint8Array(b.buffer,b.byteOffset,b.byteLength):new Uint8Array(b)}function Gb(b,d){for(const[P,G]of Object.entries(b)){const W=d[P];(Array.isArray(G)&&Array.isArray(W)&&Wb(G,W)||G===W)&&delete b[P]}return b}function Wb(b,d){return b.length===d.length&&b.every(((b,P)=>b===d[P]))}const ib=G.Matrix.Compose(new G.ed(-1,1,1),G.Quaternion.Identity(),G.ed.Zero());function qb(b,d){if(!(b instanceof Y.b))return!1;if(d){if(!b.getWorldMatrix().equalsWithEpsilon(G.Matrix.IdentityReadOnly,y.c))return!1}else{if(!b.getWorldMatrix().multiplyToRef(ib,G.TmpVectors.Matrix[0]).equalsWithEpsilon(G.Matrix.IdentityReadOnly,y.c))return!1}return!(b instanceof s.d&&b.Qd)}const Cb=new Map([[Int8Array,(b,d,P)=>b.setInt8(d,P)],[Uint8Array,(b,d,P)=>b.setUint8(d,P)],[Uint8ClampedArray,(b,d,P)=>b.setUint8(d,P)],[Int16Array,(b,d,P)=>b.setInt16(d,P,!0)],[Uint16Array,(b,d,P)=>b.setUint16(d,P,!0)],[Int32Array,(b,d,P)=>b.setInt32(d,P,!0)],[Uint32Array,(b,d,P)=>b.setUint32(d,P,!0)],[Float32Array,(b,d,P)=>b.setFloat32(d,P,!0)],[Float64Array,(b,d,P)=>b.setFloat64(d,P,!0)]]);class Jb{writeTypedArray(b){this._checkGrowBuffer(b.byteLength);const d=Cb.get(b.constructor);for(let P=0;P<b.length;P++)d(this._dataView,this._byteOffset,b[P]),this._byteOffset+=b.BYTES_PER_ELEMENT}constructor(b){this._data=new Uint8Array(b),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(b){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,b),this._byteOffset++}writeInt8(b){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,b),this._byteOffset++}writeInt16(b){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,b,!0),this._byteOffset+=2}writeUInt16(b){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,b,!0),this._byteOffset+=2}writeInt32(b){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,b,!0),this._byteOffset+=4}writeUInt32(b){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,b,!0),this._byteOffset+=4}writeFloat32(b){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,b,!0),this._byteOffset+=4}writeFloat64(b){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,b,!0),this._byteOffset+=8}_checkGrowBuffer(b){const d=this.byteOffset+b;if(d>this._data.byteLength){const b=new Uint8Array(2*d);b.set(this._data),this._data=b,this._dataView=new DataView(this._data.buffer)}}}function Lb(b){return b%4===0?4:b%2===0?2:1}class xb{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(b){let d=0;this._bufferViewToData.forEach((b=>{d+=b.byteLength}));const P=new Jb(d),G=Array.from(this._bufferViewToData.keys()).sort(((b,d)=>Lb(d.byteLength)-Lb(b.byteLength)));for(const W of G){W.byteOffset=P.byteOffset,b.push(W);const d=b.length-1,G=this.getPropertiesWithBufferView(W);for(const b of G)b.bufferView=d;P.writeTypedArray(this._bufferViewToData.get(W)),this._bufferViewToData.delete(W)}return P.getOutputData()}createBufferView(b,d){const P={buffer:0,byteOffset:void 0,byteLength:b.byteLength,byteStride:d};return this._bufferViewToData.set(P,b),P}createAccessor(b,d,P,G,W,i,q){this._verifyBufferView(b);const C={bufferView:void 0,componentType:P,count:G,type:d,min:null===i||void 0===i?void 0:i.min,max:null===i||void 0===i?void 0:i.max,normalized:q,byteOffset:W};return this.setBufferView(C,b),this._accessorToBufferView.set(C,b),C}setBufferView(b,d){this._verifyBufferView(d);this.getPropertiesWithBufferView(d).push(b)}removeBufferView(b){const d=this.getPropertiesWithBufferView(b);for(const P of d)void 0!==P.bufferView&&delete P.bufferView;this._bufferViewToData.delete(b),this._bufferViewToProperties.delete(b),this._accessorToBufferView.forEach(((d,P)=>{d===b&&(void 0!==P.byteOffset&&delete P.byteOffset,this._accessorToBufferView.delete(P))}))}getBufferView(b){const d=this._accessorToBufferView.get(b);return this._verifyBufferView(d),d}getPropertiesWithBufferView(b){return this._verifyBufferView(b),this._bufferViewToProperties.set(b,this._bufferViewToProperties.get(b)??[]),this._bufferViewToProperties.get(b)}getData(b){return this._verifyBufferView(b),this._bufferViewToData.get(b)}_verifyBufferView(b){if(void 0===b||!this._bufferViewToData.has(b))throw new Error(`BufferView ${b} not found in BufferManager.`)}}var Yb,sb=P(12139),Eb=P(12152),wb=P(12174),tb=P(12056),rb=P(12201),Bb=P(12217),nb=P(12134),Zb=P(12220);!function(b){b[b.INTANGENT=0]="INTANGENT",b[b.OUTTANGENT=1]="OUTTANGENT"}(Yb||(Yb={}));class ob{static _IsTransformable(b){return b&&(b instanceof Y.b||b instanceof sb.c||b instanceof Zb.d)}static _CreateNodeAnimation(b,d,P,G,i){if(this._IsTransformable(b)){const q=[],C=[],J=d.getKeys(),L=ob._CalculateMinMaxKeyFrames(J),x=ob._DeduceInterpolation(J,P,G),Y=x.interpolationType,s=x.shouldBakeAnimation;if(s?ob._CreateBakedAnimation(b,d,P,L.min,L.max,d.framePerSecond,i,q,C,L,G):"LINEAR"===Y||"STEP"===Y?ob._CreateLinearOrStepAnimation(b,d,P,q,C,G):"CUBICSPLINE"===Y?ob._CreateCubicSplineAnimation(b,d,P,q,C,G):ob._CreateBakedAnimation(b,d,P,L.min,L.max,d.framePerSecond,i,q,C,L,G),q.length&&C.length){return{inputs:q,outputs:C,samplerInterpolation:Y,inputsMin:s?L.min:W.Tools.FloatRound(L.min/d.framePerSecond),inputsMax:s?L.max:W.Tools.FloatRound(L.max/d.framePerSecond)}}}return null}static _DeduceAnimationInfo(b){let d=null,P="VEC3",G=!1;const i=b.targetProperty.split(".");switch(i[0]){case"hd":d="scale";break;case"position":d="translation";break;case"rotation":P="VEC4",d="rotation";break;case"rotationQuaternion":P="VEC4",G=!0,d="rotation";break;case"influence":P="SCALAR",d="weights";break;default:W.Tools.Error(`Unsupported animatable property ${i[0]}`)}return d?{animationChannelTargetPath:d,dataAccessorType:P,useQuaternion:G}:(W.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(b,d,P,G,W,i,q,C,J,L,x){let Y;if(ob._IsTransformable(b)&&b.animations)for(const s of b.animations){if(x&&!x(s))continue;const W=ob._DeduceAnimationInfo(s);W&&(Y={name:s.name,samplers:[],channels:[]},ob._AddAnimation(`${s.name}`,s.hasRunningRuntimeAnimations?d:Y,b,s,W.dataAccessorType,W.animationChannelTargetPath,G,i,q,C,W.useQuaternion,J,L),Y.samplers.length&&Y.channels.length&&P.push(Y))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(b,d,P,G,W,i,q,C,J,L,x){let Y;if(b instanceof nb.d){const W=b.morphTargetManager;if(W)for(let s=0;s<W.numTargets;++s){const E=W.getTarget(s);for(const w of E.animations){if(x&&!x(w))continue;const E=new rb.b(`${w.name}`,"influence",w.framePerSecond,w.dataType,w.loopMode,w.enableBlending),t=[],r=w.getKeys();for(let b=0;b<r.length;++b){const d=r[b];for(let b=0;b<W.numTargets;++b)b==s?t.push(d):t.push({frame:d.frame,value:0})}E.setKeys(t);const B=ob._DeduceAnimationInfo(E);B&&(Y={name:E.name,samplers:[],channels:[]},ob._AddAnimation(w.name,w.hasRunningRuntimeAnimations?d:Y,b,E,B.dataAccessorType,B.animationChannelTargetPath,G,i,q,C,B.useQuaternion,J,L,W.numTargets),Y.samplers.length&&Y.channels.length&&P.push(Y))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(b,d,P,G,W,i,q,C,J){let L;if(b.animationGroups){const Y=b.animationGroups;for(const s of Y){const Y=new Map,E=new Map,w=new Set,t=s.to-s.from;L={name:s.name,channels:[],samplers:[]};for(let d=0;d<s.targetedAnimations.length;++d){const t=s.targetedAnimations[d],r=t.target,B=t.animation;if(J&&!J(B))continue;const n=C.has(r);if(this._IsTransformable(r)||1===r.length&&this._IsTransformable(r[0])){const b=ob._DeduceAnimationInfo(t.animation);if(b){const d=this._IsTransformable(r)?r:this._IsTransformable(r[0])?r[0]:null;d&&ob._AddAnimation(`${B.name}`,L,d,B,b.dataAccessorType,b.animationChannelTargetPath,P,G,W,i,b.useQuaternion,q,n)}}else if(r instanceof Bb.c||1===r.length&&r[0]instanceof Bb.c){if(ob._DeduceAnimationInfo(t.animation)){const d=r instanceof Bb.c?r:r[0];if(d){const P=b.morphTargetManagers.find((b=>{for(let P=0;P<b.numTargets;++P)if(b.getTarget(P)===d)return!0;return!1}));if(P){const G=b.meshes.find((b=>b.morphTargetManager===P));var x;if(G)Y.has(G)||Y.set(G,new Map),null===(x=Y.get(G))||void 0===x||x.set(d,B),w.add(G),E.set(G,B)}}}}}w.forEach((b=>{const d=b.morphTargetManager;let C=null;const J=[],x=E.get(b).getKeys(),w=x.length;for(let P=0;P<w;++P)for(let G=0;G<d.numTargets;++G){const W=d.getTarget(G),i=Y.get(b);if(i){const d=i.get(W);d?(C||(C=new rb.b(`${s.name}_${b.name}_MorphWeightAnimation`,"influence",d.framePerSecond,rb.b.ANIMATIONTYPE_FLOAT,d.loopMode,d.enableBlending)),J.push(d.getKeys()[P])):J.push({frame:s.from+t/w*P,value:W.influence,inTangent:x[0].inTangent?0:void 0,outTangent:x[0].outTangent?0:void 0})}}C.setKeys(J);const r=ob._DeduceAnimationInfo(C);r&&ob._AddAnimation(`${s.name}_${b.name}_MorphWeightAnimation`,L,b,C,r.dataAccessorType,r.animationChannelTargetPath,P,G,W,i,r.useQuaternion,q,!1,null===d||void 0===d?void 0:d.numTargets)})),L.channels.length&&L.samplers.length&&d.push(L)}}}static _AddAnimation(b,d,P,W,i,q,C,J,L,x,Y,s,E,w){const t=ob._CreateNodeAnimation(P,W,q,Y,s);let r,B,n,Z,o,A;if(t){if(w){let b=0,d=0;const P=[];for(;t.inputs.length>0;)d=t.inputs.shift(),b%w==0&&P.push(d),b++;t.inputs=P}const b=C.get(P),W=new Float32Array(t.inputs);r=J.createBufferView(W),B=J.createAccessor(r,"SCALAR",5126,t.inputs.length,void 0,{min:[t.inputsMin],max:[t.inputsMax]}),x.push(B),n=x.length-1;const L=new G.Quaternion,Y=new G.ed,s=new G.ed,f=P instanceof sb.c,g=m(i),X=new Float32Array(t.outputs.length*g);t.outputs.forEach((function(b,d){let P=b;switch(q){case"translation":E&&(G.ed.FromArrayToRef(b,0,s),T(s),s.toArray(P));break;case"rotation":4===b.length?G.Quaternion.FromArrayToRef(b,0,L):(P=new Array(4),G.ed.FromArrayToRef(b,0,Y),G.Quaternion.FromEulerVectorToRef(Y,L)),E&&(K(L),f&&k(L)),L.toArray(P)}X.set(P,d*g)})),r=J.createBufferView(X),B=J.createAccessor(r,i,5126,t.outputs.length),x.push(B),Z=x.length-1,o={interpolation:t.samplerInterpolation,input:n,output:Z},d.samplers.push(o),A={sampler:d.samplers.length-1,target:{node:b,path:q}},d.channels.push(A)}}static _CreateBakedAnimation(b,d,P,i,q,C,J,L,x,Y,s){let E;const w=G.Quaternion.Identity();let t,r=null,B=null,n=null,Z=null,o=null,A=null;Y.min=W.Tools.FloatRound(i/C);const f=d.getKeys();for(let G=0,g=f.length;G<g;++G){if(A=null,n=f[G],G+1<g)if(Z=f[G+1],n.value.equals&&n.value.equals(Z.value)||n.value===Z.value){if(0!==G)continue;A=n.frame}else A=Z.frame;else{if(o=f[G-1],n.value.equals&&n.value.equals(o.value)||n.value===o.value)continue;A=q}if(A)for(let G=n.frame;G<=A;G+=J){if(t=W.Tools.FloatRound(G/C),t===r)continue;r=t,B=t;const i={key:0,repeatCount:0,loopMode:d.loopMode};E=d._interpolate(G,i),ob._SetInterpolatedValue(b,E,t,d,P,w,L,x,s)}}B&&(Y.max=B)}static _ConvertFactorToVector3OrQuaternion(b,d,P,i,q){const C=ob._GetBasePositionRotationOrScale(d,i,q),J=P.targetProperty.split("."),L=J?J[1]:"",x=q?G.Quaternion.Od(C).normalize():G.ed.Od(C);switch(L){case"x":case"y":case"z":x[L]=b;break;case"w":x.w=b;break;default:W.Tools.Error(`glTFAnimation: Unsupported component name "${L}"!`)}return x}static _SetInterpolatedValue(b,d,P,W,i,q,C,J,L){let x;C.push(P),"weights"!==i?(W.dataType===rb.b.ANIMATIONTYPE_FLOAT&&(d=this._ConvertFactorToVector3OrQuaternion(d,b,W,i,L)),"rotation"===i?(L?q=d:(x=d,G.Quaternion.RotationYawPitchRollToRef(x.y,x.x,x.z,q)),J.push(q.jd())):(x=d,J.push(x.jd()))):J.push([d])}static _CreateLinearOrStepAnimation(b,d,P,G,W,i){for(const q of d.getKeys())G.push(q.frame/d.framePerSecond),ob._AddKeyframeValue(q,d,W,P,b,i)}static _CreateCubicSplineAnimation(b,d,P,G,W,i){d.getKeys().forEach((function(q){G.push(q.frame/d.framePerSecond),ob._AddSplineTangent(Yb.INTANGENT,W,P,"CUBICSPLINE",q,i),ob._AddKeyframeValue(q,d,W,P,b,i),ob._AddSplineTangent(Yb.OUTTANGENT,W,P,"CUBICSPLINE",q,i)}))}static _GetBasePositionRotationOrScale(b,d,P){let W;if("rotation"===d)if(P){W=(b.rotationQuaternion??G.Quaternion.Identity()).jd()}else{W=(b.rotation??G.ed.Zero()).jd()}else if("translation"===d){W=(b.position??G.ed.Zero()).jd()}else{W=(b.hd??G.ed.One()).jd()}return W}static _AddKeyframeValue(b,d,P,i,q,C){let J;const L=d.dataType;if(L===rb.b.ANIMATIONTYPE_VECTOR3){let d=b.value.jd();if("rotation"===i){const b=G.ed.Od(d);d=G.Quaternion.RotationYawPitchRoll(b.y,b.x,b.z).jd()}P.push(d)}else if(L===rb.b.ANIMATIONTYPE_FLOAT){if("weights"===i)P.push([b.value]);else if(J=this._ConvertFactorToVector3OrQuaternion(b.value,q,d,i,C),J){if("rotation"===i){const b=C?J:G.Quaternion.RotationYawPitchRoll(J.y,J.x,J.z).normalize();P.push(b.jd())}P.push(J.jd())}}else L===rb.b.ANIMATIONTYPE_QUATERNION?P.push(b.value.normalize().jd()):W.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(b,d,P){let G,W,i=!1;if("rotation"===d&&!P)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let q=0,C=b.length;q<C;++q)if(W=b[q],W.inTangent||W.outTangent)if(G){if("CUBICSPLINE"!==G){G="LINEAR",i=!0;break}}else G="CUBICSPLINE";else if(G){if("CUBICSPLINE"===G||W.interpolation&&1===W.interpolation&&"STEP"!==G){G="LINEAR",i=!0;break}}else G=W.interpolation&&1===W.interpolation?"STEP":"LINEAR";return G||(G="LINEAR"),{interpolationType:G,shouldBakeAnimation:i}}static _AddSplineTangent(b,d,P,W,i,q){let C;const J=b===Yb.INTANGENT?i.inTangent:i.outTangent;if("CUBICSPLINE"===W){if("rotation"===P)if(J)if(q)C=J.jd();else{const b=J;C=G.Quaternion.RotationYawPitchRoll(b.y,b.x,b.z).jd()}else C=[0,0,0,0];else C="weights"===P?J?[J]:[0]:J?J.jd():[0,0,0];d.push(C)}}static _CalculateMinMaxKeyFrames(b){let d=1/0,P=-1/0;return b.forEach((function(b){d=Math.min(d,b.frame),P=Math.max(P,b.frame)})),{min:d,max:P}}}function Ab(b,d,P,i,q,C){const J={attributes:{},influence:b.influence,name:b.name},L=d.Qd;if(!L)return W.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),J;const Y=C?-1:1,s=G.ed.Zero();let E=0,w=0;if(b.hasPositions){const i=b.getPositions(),C=L.getVerticesData(x.c.PositionKind);if(C){const b=new Float32Array(C.length),d=[1/0,1/0,1/0],W=[-1/0,-1/0,-1/0];w=C.length/3,E=0;for(let P=E;P<w;++P){const q=G.ed.Od(C,3*P);G.ed.Od(i,3*P).subtractToRef(q,s),s.x*=Y,d[0]=Math.min(d[0],s.x),W[0]=Math.max(W[0],s.x),d[1]=Math.min(d[1],s.y),W[1]=Math.max(W[1],s.y),d[2]=Math.min(d[2],s.z),W[2]=Math.max(W[2],s.z),b[3*P]=s.x,b[3*P+1]=s.y,b[3*P+2]=s.z}const L=P.createBufferView(b,12),x=P.createAccessor(L,"VEC3",5126,i.length/3,0,{min:d,max:W});q.push(x),J.attributes.POSITION=q.length-1}else W.Tools.Warn(`Morph target positions for mesh ${d.name} were not exported. Mesh does not have position vertex data`)}if(b.hasNormals){const i=b.getNormals(),C=L.getVerticesData(x.c.NormalKind);if(C){const b=new Float32Array(C.length);w=C.length/3,E=0;for(let P=E;P<w;++P){const d=G.ed.Od(C,3*P).normalize();G.ed.Od(i,3*P).normalize().subtractToRef(d,s),b[3*P]=s.x*Y,b[3*P+1]=s.y,b[3*P+2]=s.z}const d=P.createBufferView(b,12),W=P.createAccessor(d,"VEC3",5126,i.length/3,0);q.push(W),J.attributes.NORMAL=q.length-1}else W.Tools.Warn(`Morph target normals for mesh ${d.name} were not exported. Mesh does not have normals vertex data`)}if(b.hasTangents){const i=b.getTangents(),C=L.getVerticesData(x.c.TangentKind);if(C){w=C.length/4;const b=new Float32Array(3*w);E=0;for(let P=E;P<w;++P){const d=G.ed.Od(C,4*P);h(d);const W=G.ed.Od(i,3*P);h(W),W.subtractToRef(d,s),b[3*P]=s.x*Y,b[3*P+1]=s.y,b[3*P+2]=s.z}const d=P.createBufferView(b,12),W=P.createAccessor(d,"VEC3",5126,w,0);q.push(W),J.attributes.TANGENT=q.length-1}else W.Tools.Warn(`Morph target tangents for mesh ${d.name} were not exported. Mesh does not have tangents vertex data`)}if(b.hasColors){const i=b.getColors(),C=L.getVerticesData(x.c.ColorKind),Y=L.getVertexBuffer(x.c.ColorKind);if(C&&Y){const b=Y.getSize();w=C.length/b;const d=new Float32Array(w*b);E=0;for(let P=E;P<w;++P)if(3===b){const W=G.ed.Od(C,P*b);G.ed.Od(i,P*b).subtractToRef(W,s),d[3*P]=s.x,d[3*P+1]=s.y,d[3*P+2]=s.z}else if(4===b){const W=new G.Vector4,q=G.Vector4.Od(C,P*b);G.Vector4.Od(i,P*b).subtractToRef(q,W),d[4*P]=W.x,d[4*P+1]=W.y,d[4*P+2]=W.z,d[4*P+3]=W.w}else W.Tools.Warn(`Unsupported number of components for color attribute: ${b}`);const L=P.createBufferView(d,4*b),x=P.createAccessor(L,3===b?"VEC3":"VEC4",5126,w,0);q.push(x),J.attributes.COLOR_0=q.length-1}else W.Tools.Warn(`Morph target colors for mesh ${d.name} were not exported. Mesh does not have colors vertex data`)}return J}var fb=P(12227),gb=P(12080),Xb=P(12063),ub=P(11639);class Mb{}Mb.DEFAULT_COLOR=r.Nd.White(),Mb.DEFAULT_WIDTH_ATTENUATED=1,Mb.DEFAULT_WIDTH=.1;var eb=P(11882),Rb=P(12236);class Ub{static ConvertPoints(b,d){if(b.length&&Array.isArray(b)&&"number"===typeof b[0])return[b];if(b.length&&Array.isArray(b[0])&&"number"===typeof b[0][0])return b;if(b.length&&!Array.isArray(b[0])&&b[0]instanceof G.ed){const d=[];for(let P=0;P<b.length;P++){const G=b[P];d.push(G.x,G.y,G.z)}return[d]}if(b.length>0&&Array.isArray(b[0])&&b[0].length>0&&b[0][0]instanceof G.ed){const d=[],P=b;for(const b of P)d.push(b.flatMap((b=>[b.x,b.y,b.z])));return d}if(b instanceof Float32Array){if(null!==d&&void 0!==d&&d.floatArrayStride){const P=[],G=3*d.floatArrayStride;for(let d=0;d<b.length;d+=G){const W=new Array(G);for(let P=0;P<G;P++)W[P]=b[d+P];P.push(W)}return P}return[Array.from(b)]}if(b.length&&b[0]instanceof Float32Array){const d=[];for(const P of b)d.push(Array.from(P));return d}return[]}static OmitZeroLengthPredicate(b,d,P){const G=[];return d.Rd(b).lengthSquared()>0&&G.push([b,d]),P.Rd(d).lengthSquared()>0&&G.push([d,P]),b.Rd(P).lengthSquared()>0&&G.push([P,b]),0===G.length?null:G}static OmitDuplicatesPredicate(b,d,P,G){const W=[];return Ub._SearchInPoints(b,d,G)||W.push([b,d]),Ub._SearchInPoints(d,P,G)||W.push([d,P]),Ub._SearchInPoints(P,b,G)||W.push([P,b]),0===W.length?null:W}static _SearchInPoints(b,d,P){for(const q of P)for(let P=0;P<q.length;P++){var G,W,i;if(null!==(G=q[P])&&void 0!==G&&G.equals(b))if(null!==(W=q[P+1])&&void 0!==W&&W.equals(d)||null!==(i=q[P-1])&&void 0!==i&&i.equals(d))return!0}return!1}static MeshesToLines(b,d){const P=[];for(let W=0;W<b.length;W++){const i=b[W],q=i.getVerticesData(x.c.PositionKind),C=i.Id();if(q&&C)for(let b=0,J=0;b<C.length;b++){const L=3*C[J++],x=3*C[J++],Y=3*C[J++],s=new G.ed(q[L],q[L+1],q[L+2]),E=new G.ed(q[x],q[x+1],q[x+2]),w=new G.ed(q[Y],q[Y+1],q[Y+2]);if(d){const G=d(s,E,w,P,b,L,i,W,q,C);if(G)for(const b of G)P.push(b)}else P.push([s,E],[E,w],[w,s])}}return P}static ToVector3Array(b){if(Array.isArray(b[0])){const d=[],P=b;for(const b of P){const P=[];for(let d=0;d<b.length;d+=3)P.push(new G.ed(b[d],b[d+1],b[d+2]));d.push(P)}return d}const d=b,P=[];for(let W=0;W<d.length;W+=3)P.push(new G.ed(d[W],d[W+1],d[W+2]));return P}static ToNumberArray(b){return b.flatMap((b=>[b.x,b.y,b.z]))}static GetPointsCountInfo(b){const d=new Array(b.length);let P=0;for(let G=b.length;G--;)d[G]=b[G].length/3,P+=d[G];return{total:P,counts:d}}static GetLineLength(b){if(0===b.length)return 0;let d;d="number"===typeof b[0]?Ub.ToVector3Array(b):b;const P=G.TmpVectors.ed[0];let W=0;for(let G=0;G<d.length-1;G++){const b=d[G];W+=d[G+1].subtractToRef(b,P).length()}return W}static GetLineLengthArray(b){const d=new Float32Array(b.length/3);let P=0;for(let G=0,W=b.length/3-1;G<W;G++){let W=b[3*G+0],i=b[3*G+1],q=b[3*G+2];W-=b[3*G+3],i-=b[3*G+4],q-=b[3*G+5];P+=Math.sqrt(W*W+i*i+q*q),d[G+1]=P}return d}static SegmentizeSegmentByCount(b,d,P){const W=[],i=d.Rd(b),q=G.TmpVectors.ed[0];q.kd(P);const C=G.TmpVectors.ed[1];i.divideToRef(q,C);let J=b.clone();W.push(J);for(let G=0;G<P;G++)J=J.clone(),W.push(J.addInPlace(C));return W}static SegmentizeLineBySegmentLength(b,d){const P=b[0]instanceof G.ed?Ub.GetLineSegments(b):"number"===typeof b[0]?Ub.GetLineSegments(Ub.ToVector3Array(b)):b,W=[];for(const G of P)if(G.length>d){const b=Ub.SegmentizeSegmentByCount(G.point1,G.point2,Math.ceil(G.length/d));for(const d of b)W.push(d)}else W.push(G.point1),W.push(G.point2);return W}static SegmentizeLineBySegmentCount(b,d){const P="number"===typeof b[0]?Ub.ToVector3Array(b):b,G=Ub.GetLineLength(P)/d;return Ub.SegmentizeLineBySegmentLength(P,G)}static GetLineSegments(b){const d=[];for(let P=0;P<b.length-1;P++){const G=b[P],W=b[P+1],i=W.Rd(G).length();d.push({point1:G,point2:W,length:i})}return d}static GetMinMaxSegmentLength(b){const d=Ub.GetLineSegments(b).sort((b=>b.length));return{min:d[0].length,max:d[d.length-1].length}}static GetPositionOnLineByVisibility(b,d,P){let W=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const i=d*P;let q=0,C=0;const J=b.length;for(let G=0;G<J;G++){if(i<=q+b[G].length){C=G;break}q+=b[G].length}const L=(i-q)/b[C].length;return b[C].point2.subtractToRef(b[C].point1,G.TmpVectors.ed[0]),G.TmpVectors.ed[1]=G.TmpVectors.ed[0].multiplyByFloats(L,L,L),W||G.TmpVectors.ed[1].addInPlace(b[C].point1),G.TmpVectors.ed[1].clone()}static GetCircleLinePoints(b,d){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,W=arguments.length>3&&void 0!==arguments[3]?arguments[3]:b,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/d;const q=[];for(let C=0;C<=d;C++)q.push(new G.ed(Math.cos(C*i)*b,Math.sin(C*i)*W,P));return q}static GetBezierLinePoints(b,d,P,G){return eb.g.CreateQuadraticBezier(b,d,P,G).getPoints().flatMap((b=>[b.x,b.y,b.z]))}static GetArrowCap(b,d,P,G,W){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[b.clone(),b.add(d.multiplyByFloats(P,P,P))],widths:[G,W,i,q]}}static GetPointsFromText(b,d,P,G){let W=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const q=[],C=(0,Rb.b)(b,d,P,G);for(const J of C){for(const b of J.paths){const d=[],P=b.getPoints();for(const b of P)d.push(b.x,b.y,W);q.push(d)}if(i)for(const b of J.holes){const d=[],P=b.getPoints();for(const b of P)d.push(b.x,b.y,W);q.push(d)}}return q}static Color3toRGBAUint8(b){const d=new Uint8Array(4*b.length);for(let P=0,G=0;P<b.length;P++)d[G++]=255*b[P].r,d[G++]=255*b[P].g,d[G++]=255*b[P].b,d[G++]=255;return d}static CreateColorsTexture(b,d,P,G){const W=G.getEngine().getCaps().maxTextureSize??1,i=d.length>W?W:d.length,q=Math.ceil(d.length/W);q>1&&(d=[...d,...Array(i*q-d.length).fill(d[0])]);const C=Ub.Color3toRGBAUint8(d),J=new f.b(C,i,q,w.e.TEXTUREFORMAT_RGBA,G,!1,!0,P);return J.name=b,J}static PrepareEmptyColorsTexture(b){if(!Mb.EmptyColorsTexture){const d=new Uint8Array(4);Mb.EmptyColorsTexture=new f.b(d,1,1,w.e.TEXTUREFORMAT_RGBA,b,!1,!1,f.b.NEAREST_NEAREST),Mb.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Mb.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var b;null===(b=Mb.EmptyColorsTexture)||void 0===b||b.dispose(),Mb.EmptyColorsTexture=null}static BooleanToNumber(b){return b?1:0}}class Hb extends Xb.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class pb extends gb.b{isCompatible(b){return!0}constructor(b,d,P){var W;P=P||{color:Mb.DEFAULT_COLOR};const i=new Hb;i.GREASED_LINE_HAS_COLOR=!!P.color&&!P.useColors,i.GREASED_LINE_SIZE_ATTENUATION=P.sizeAttenuation??!1,i.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===P.colorDistributionType,i.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(d??b.Xb()).useRightHandedSystem,i.GREASED_LINE_CAMERA_FACING=P.cameraFacing??!0,super(b,pb.GREASED_LINE_MATERIAL_NAME,200,i,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(W=P)||void 0===W?void 0:W.forceGLSL)||pb.ForceGLSL,this._scene=d??b.Xb(),this._engine=this._scene.getEngine(),this._cameraFacing=P.cameraFacing??!0,this.visibility=P.visibility??1,this.useDash=P.useDash??!1,this.dashRatio=P.dashRatio??.5,this.dashOffset=P.dashOffset??0,this.width=P.width?P.width:P.sizeAttenuation?Mb.DEFAULT_WIDTH_ATTENUATED:Mb.DEFAULT_WIDTH,this._sizeAttenuation=P.sizeAttenuation??!1,this.colorMode=P.colorMode??0,this._color=P.color??null,this.useColors=P.useColors??!1,this._colorsDistributionType=P.colorDistributionType??0,this.colorsSampling=P.colorsSampling??f.b.NEAREST_NEAREST,this._colors=P.Rb??null,this.dashCount=P.dashCount??1,this.resolution=P.resolution??new G.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),P.colorsTexture?this.colorsTexture=P.colorsTexture:this._colors?this.colorsTexture=Ub.CreateColorsTexture(`${b.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Mb.DEFAULT_COLOR,Ub.PrepareEmptyColorsTexture(this._scene)),this._engine.Zd.add((()=>{Ub.DisposeEmptyColorsTexture()}))}getAttributes(b){b.push("grl_offsets"),b.push("grl_widths"),b.push("grl_colorPointers"),b.push("grl_counters"),this._cameraFacing?(b.push("grl_previousAndSide"),b.push("grl_nextAndCounters")):b.push("grl_slopes")}getSamplers(b){b.push("grl_colors")}getActiveTextures(b){this.colorsTexture&&b.push(this.colorsTexture)}getUniforms(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const d=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&d.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===b&&d.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:d,vertex:this._cameraFacing&&this._isGLSL(b)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(b)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(b){if(this._cameraFacing){b.yd("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||b.yd("viewProjection",this._scene.getTransformMatrix());const d=G.TmpVectors.Vector4[0];d.x=this._aspect,d.y=this._resolution.x,d.z=this._resolution.y,d.w=this.width,b.updateVector4("grl_aspect_resolution_lineWidth",d)}const d=G.TmpVectors.Vector4[0];d.x=Ub.BooleanToNumber(this.useDash),d.y=this._dashArray,d.z=this.dashOffset,d.w=this.dashRatio,b.updateVector4("grl_dashOptions",d);const P=G.TmpVectors.Vector4[1];P.x=this.colorMode,P.y=this.visibility,P.z=this.colorsTexture?this.colorsTexture.getSize().width:0,P.w=Ub.BooleanToNumber(this.useColors),b.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",P),this._color&&b.updateColor3("grl_singleColor",this._color);const W=this.colorsTexture??Mb.EmptyColorsTexture;b.setTexture("grl_colors",W),b.updateFloat2("grl_textureSize",(null===W||void 0===W?void 0:W.getSize().width)??1,(null===W||void 0===W?void 0:W.getSize().height)??1)}prepareDefines(b,d,P){b.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,b.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,b.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,b.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=d.useRightHandedSystem,b.GREASED_LINE_CAMERA_FACING=this._cameraFacing,b.GREASED_LINE_USE_OFFSETS=!!P.offsets}getClassName(){return pb.GREASED_LINE_MATERIAL_NAME}getCustomCode(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(d)?function(b,d){if("vertex"===b){const b={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return d&&(b["!gl_Position\\=viewProjection\\*worldPos;"]="//"),b}return"fragment"===b?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(b,this._cameraFacing):function(b,d){if("vertex"===b){const b={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return d&&(b["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),b}return"fragment"===b?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(b,this._cameraFacing)}dispose(){var b;null===(b=this.colorsTexture)||void 0===b||b.dispose(),super.dispose()}get Rb(){return this._colors}set Rb(b){this.setColors(b)}setColors(b){var d;let P=arguments.length>1&&void 0!==arguments[1]&&arguments[1],G=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const W=(null===(d=this._colors)||void 0===d?void 0:d.length)??0;var i;if(this._colors=b,null!==b&&0!==b.length){if(!P||G)if(this.colorsTexture&&W===b.length&&!G){const d=Ub.Color3toRGBAUint8(b);this.colorsTexture.update(d)}else{var q;null===(q=this.colorsTexture)||void 0===q||q.dispose(),this.colorsTexture=Ub.CreateColorsTexture(`${this._material.name}-colors-texture`,b,this.colorsSampling,this._scene)}}else null===(i=this.colorsTexture)||void 0===i||i.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(b){this._dashCount=b,this._dashArray=1/b}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(b){this._sizeAttenuation=b,this.markAllDefinesAsDirty()}get color(){return this._color}set color(b){this.setColor(b)}setColor(b){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==b||null!==this._color&&null===b?(this._color=b,d||this.markAllDefinesAsDirty()):this._color=b}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(b){this._colorsDistributionType=b,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(b){this._aspect=b.x/b.y,this._resolution=b}serialize(){const b=super.serialize(),d={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(d.Rb=this._colors),this._color&&(d.color=this._color),b.greasedLineMaterialOptions=d,b}parse(b,d,P){var G;super.parse(b,d,P);const W=b.greasedLineMaterialOptions;null===(G=this.colorsTexture)||void 0===G||G.dispose(),W.color&&this.setColor(W.color,!0),W.colorDistributionType&&(this.colorsDistributionType=W.colorDistributionType),W.Rb&&(this.Rb=W.Rb),W.colorsSampling&&(this.colorsSampling=W.colorsSampling),W.colorMode&&(this.colorMode=W.colorMode),W.useColors&&(this.useColors=W.useColors),W.visibility&&(this.visibility=W.visibility),W.useDash&&(this.useDash=W.useDash),W.dashCount&&(this.dashCount=W.dashCount),W.dashRatio&&(this.dashRatio=W.dashRatio),W.dashOffset&&(this.dashOffset=W.dashOffset),W.width&&(this.width=W.width),W.sizeAttenuation&&(this.sizeAttenuation=W.sizeAttenuation),W.resolution&&(this.resolution=W.resolution),this.Rb?this.colorsTexture=Ub.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Rb,this.colorsSampling,d):Ub.PrepareEmptyColorsTexture(d),this.markAllDefinesAsDirty()}copyTo(b){var d;const P=b;null===(d=P.colorsTexture)||void 0===d||d.dispose(),this._colors&&(P.colorsTexture=Ub.CreateColorsTexture(`${P._material.name}-colors-texture`,this._colors,P.colorsSampling,this._scene)),P.setColor(this.color,!0),P.colorsDistributionType=this.colorsDistributionType,P.colorsSampling=this.colorsSampling,P.colorMode=this.colorMode,P.useColors=this.useColors,P.visibility=this.visibility,P.useDash=this.useDash,P.dashCount=this.dashCount,P.dashRatio=this.dashRatio,P.dashOffset=this.dashOffset,P.width=this.width,P.sizeAttenuation=this.sizeAttenuation,P.resolution=this.resolution,P.markAllDefinesAsDirty()}_isGLSL(b){return 0===b||this._forceGLSL}}pb.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",pb.ForceGLSL=!1,(0,ub.f)(`BABYLON.${pb.GREASED_LINE_MATERIAL_NAME}`,pb);var Sb=P(12119),lb=P(11510),Nb=P(11906),jb=P(11623);class ab extends Nb.ShaderMaterial{constructor(b,d,W){const i=d.getEngine(),q=i.isWebGPU&&!(W.forceGLSL||ab.ForceGLSL),C=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];d.useRightHandedSystem&&C.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const J=["position","grl_widths","grl_offsets","grl_colorPointers"];W.cameraFacing?(C.push("GREASED_LINE_CAMERA_FACING"),J.push("grl_previousAndSide","grl_nextAndCounters")):(J.push("grl_slopes"),J.push("grl_counters"));const L=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(q||L.push("world","viewProjection","view","projection"),super(b,d,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:q?["Scene","Mesh"]:void 0,attributes:J,uniforms:L,samplers:q?[]:["grlColors"],defines:C,extraInitializationsAsync:async()=>{q?await Promise.all([P.e(66).then(P.bind(P,14794)),P.e(75).then(P.bind(P,14802))]):await Promise.all([P.e(69).then(P.bind(P,14808)),P.e(76).then(P.bind(P,14817))])},shaderLanguage:q?1:0}),this._color=r.Nd.White(),this._colorsDistributionType=0,this._colorsTexture=null,W=W||{color:Mb.DEFAULT_COLOR},this.visibility=W.visibility??1,this.useDash=W.useDash??!1,this.dashRatio=W.dashRatio??.5,this.dashOffset=W.dashOffset??0,this.dashCount=W.dashCount??1,this.width=W.width?W.width:W.sizeAttenuation&&W.cameraFacing?Mb.DEFAULT_WIDTH_ATTENUATED:Mb.DEFAULT_WIDTH,this.sizeAttenuation=W.sizeAttenuation??!1,this.color=W.color??r.Nd.White(),this.useColors=W.useColors??!1,this.colorsDistributionType=W.colorDistributionType??0,this.colorsSampling=W.colorsSampling??f.b.NEAREST_NEAREST,this.colorMode=W.colorMode??0,this._colors=W.Rb??null,this._cameraFacing=W.cameraFacing??!0,this.resolution=W.resolution??new G.Vector2(i.getRenderWidth(),i.getRenderHeight()),W.colorsTexture?this.colorsTexture=W.colorsTexture:this._colors?this.colorsTexture=Ub.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,d):(this._color=this._color??Mb.DEFAULT_COLOR,this.colorsTexture=Ub.PrepareEmptyColorsTexture(d)),q){const b=new jb.b;b.setParameters(),b.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",b)}i.Zd.add((()=>{Ub.DisposeEmptyColorsTexture()}))}dispose(){var b;null===(b=this._colorsTexture)||void 0===b||b.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new G.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Rb(){return this._colors}set Rb(b){this.setColors(b)}setColors(b){var d;let P=arguments.length>1&&void 0!==arguments[1]&&arguments[1],G=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const W=(null===(d=this._colors)||void 0===d?void 0:d.length)??0;var i;if(this._colors=b,null!==b&&0!==b.length){if(!P||G)if(this._colorsTexture&&W===b.length&&!G){const d=Ub.Color3toRGBAUint8(b);this._colorsTexture.update(d)}else{var q;null===(q=this._colorsTexture)||void 0===q||q.dispose(),this.colorsTexture=Ub.CreateColorsTexture(`${this.name}-colors-texture`,b,this.colorsSampling,this.Xb())}}else null===(i=this._colorsTexture)||void 0===i||i.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(b){this._colorsTexture=b,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(b){this._width=b,this.setFloat("grlWidth",b)}get useColors(){return this._useColors}set useColors(b){this._useColors=b,this.setFloat("grlUseColors",Ub.BooleanToNumber(b))}get colorsSampling(){return this._colorsSampling}set colorsSampling(b){this._colorsSampling=b}get visibility(){return this._visibility}set visibility(b){this._visibility=b,this.setFloat("grlVisibility",b)}get useDash(){return this._useDash}set useDash(b){this._useDash=b,this.setFloat("grlUseDash",Ub.BooleanToNumber(b))}get dashOffset(){return this._dashOffset}set dashOffset(b){this._dashOffset=b,this.setFloat("grlDashOffset",b)}get dashRatio(){return this._dashRatio}set dashRatio(b){this._dashRatio=b,this.setFloat("grlDashRatio",b)}get dashCount(){return this._dashCount}set dashCount(b){this._dashCount=b,this._dashArray=1/b,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(b){this._sizeAttenuation=b,this.setFloat("grlSizeAttenuation",Ub.BooleanToNumber(b))}get color(){return this._color}set color(b){this.setColor(b)}setColor(b){b=b??Mb.DEFAULT_COLOR,this._color=b,this.setColor3("grlColor",b)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(b){this._colorsDistributionType=b,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(b){this._colorMode=b,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(b){this._resolution=b,this.setVector2("grlResolution",b),this.setFloat("grlAspect",b.x/b.y)}serialize(){const b=super.serialize(),d={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(d.Rb=this._colors),b.greasedLineMaterialOptions=d,b}parse(b,d,P){var G;const W=b.greasedLineMaterialOptions;null===(G=this._colorsTexture)||void 0===G||G.dispose(),W.color&&(this.color=W.color),W.colorDistributionType&&(this.colorsDistributionType=W.colorDistributionType),W.colorsSampling&&(this.colorsSampling=W.colorsSampling),W.colorMode&&(this.colorMode=W.colorMode),W.useColors&&(this.useColors=W.useColors),W.visibility&&(this.visibility=W.visibility),W.useDash&&(this.useDash=W.useDash),W.dashCount&&(this.dashCount=W.dashCount),W.dashRatio&&(this.dashRatio=W.dashRatio),W.dashOffset&&(this.dashOffset=W.dashOffset),W.width&&(this.width=W.width),W.sizeAttenuation&&(this.sizeAttenuation=W.sizeAttenuation),W.resolution&&(this.resolution=W.resolution),W.Rb?this.colorsTexture=Ub.CreateColorsTexture(`${this.name}-colors-texture`,W.Rb,this.colorsSampling,this.Xb()):this.colorsTexture=Ub.PrepareEmptyColorsTexture(d),this._cameraFacing=W.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Ob,Vb,yb;ab.ForceGLSL=!1,function(b){b[b.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",b[b.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Ob||(Ob={})),function(b){b[b.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",b[b.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",b[b.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Vb||(Vb={})),function(b){b[b.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",b[b.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",b[b.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",b[b.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",b[b.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(yb||(yb={}));class cb extends nb.d{constructor(b,d,P){super(b,d,null,null,!1,!1),this.name=b,this._options=P,this._lazy=!1,this._updatable=!1,this._engine=d.getEngine(),this._lazy=P.lazy??!1,this._updatable=P.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=P.colorPointers??[],this._widths=P.widths??new Array(P.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(b){let d=0;for(const G of this._points)d+=G.length;const P=d/3*2-this._widths.length;for(let G=0;G<P;G++)this._widths.push(b)}updateLazy(){var b,d;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(b=this._options.ribbonOptions)||void 0===b?void 0:b.smoothShading),!this.Sb&&this.refreshBoundingInfo(),null===(d=this.greasedLineMaterial)||void 0===d||d.updateLazy()}addPoints(b,d){for(const P of b)this._points.push(P);this._lazy||this.setPoints(this._points,d)}dispose(b){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(b,d)}isLazy(){return this._lazy}get Ub(){return this._uvs}set Ub(b){this._uvs=b instanceof Float32Array?b:new Float32Array(b),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(b){this.material instanceof ab&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===b||void 0===b?void 0:b.length)>0),this._offsets=b,this._offsetsBuffer?this._offsetsBuffer.update(b):this._createOffsetsBuffer(b)}get widths(){return this._widths}set widths(b){this._widths=b,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(b)}get colorPointers(){return this._colorPointers}set colorPointers(b){this._colorPointers=b,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(b)}get greasedLineMaterial(){var b,d;if(this.material&&this.material instanceof ab)return this.material;const P=null===(b=this.material)||void 0===b||null===(d=b.pluginManager)||void 0===d?void 0:d.getPlugin(pb.GREASED_LINE_MATERIAL_NAME);return P||void 0}get points(){const b=[];return lb.b.DeepCopy(this._points,b),b}setPoints(b,d){this._points=Ub.ConvertPoints(b,(null===d||void 0===d?void 0:d.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==d&&void 0!==d&&d.colorPointers||this._updateColorPointers(),this._setPoints(this._points,d)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Ub:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(b){super.serialize(b),b.type=this.getClassName(),b.lineOptions=this._createLineOptions()}_createVertexBuffers(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new Sb.e;return d.Mb=this._vertexPositions,d.indices=this._indices,d.Ub=this._uvs,b&&(d.eb=[],Sb.e.ComputeNormals(this._vertexPositions,this._indices,d.eb)),d.pb(this,this._options.updatable),d}_createOffsetsBuffer(b){const d=this._scene.getEngine(),P=new x.b(d,b,this._updatable,3);this.setVerticesBuffer(P.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=P}}class Db{constructor(b,d){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=b,this.wasAddedByNoopNode=d}getIndicesAccessor(b,d,P,G,W){var i,q,C,J;return null===(i=this._indicesAccessorMap.get(b))||void 0===i||null===(q=i.get(d))||void 0===q||null===(C=q.get(P))||void 0===C||null===(J=C.get(G))||void 0===J?void 0:J.get(W)}setIndicesAccessor(b,d,P,G,W,i){let q=this._indicesAccessorMap.get(b);q||(q=new Map,this._indicesAccessorMap.set(b,q));let C=q.get(d);C||(C=new Map,q.set(d,C));let J=C.get(P);J||(J=new Map,C.set(P,J));let L=J.get(G);L||(L=new Map,J.set(G,L)),L.set(W,i)}pushExportedNode(b){this._exportedNodes.has(b)||this._exportedNodes.add(b)}getNodesSet(){return this._exportedNodes}getVertexBufferView(b){return this._vertexBufferViewMap.get(b)}setVertexBufferView(b,d){this._vertexBufferViewMap.set(b,d)}setRemappedBufferView(b,d,P){this._remappedBufferView.set(b,new Map),this._remappedBufferView.get(b).set(d,P)}getRemappedBufferView(b,d){var P;return null===(P=this._remappedBufferView.get(b))||void 0===P?void 0:P.get(d)}getVertexAccessor(b,d,P){var G,W;return null===(G=this._vertexAccessorMap.get(b))||void 0===G||null===(W=G.get(d))||void 0===W?void 0:W.get(P)}setVertexAccessor(b,d,P,G){let W=this._vertexAccessorMap.get(b);W||(W=new Map,this._vertexAccessorMap.set(b,W));let i=W.get(d);i||(i=new Map,W.set(d,i)),i.set(P,G)}hasVertexColorAlpha(b){return this._vertexMapColorAlpha.get(b)||!1}setHasVertexColorAlpha(b,d){return this._vertexMapColorAlpha.set(b,d)}getMesh(b){return this._meshMap.get(b)}setMesh(b,d){this._meshMap.set(b,d)}bindMorphDataToMesh(b,d){const P=this._meshMorphTargetMap.get(b)||[];this._meshMorphTargetMap.set(b,P),-1===P.indexOf(d)&&P.push(d)}getMorphTargetsFromMesh(b){return this._meshMorphTargetMap.get(b)}}class zb{_ApplyExtension(b,d,P,G){if(P>=d.length)return Promise.resolve(b);const W=G(d[P],b);return W?W.then((async b=>b?await this._ApplyExtension(b,d,P+1,G):null)):this._ApplyExtension(b,d,P+1,G)}_ApplyExtensions(b,d){const P=[];for(const G of zb._ExtensionNames)P.push(this._extensions[G]);return this._ApplyExtension(b,P,0,d)}_extensionsPreExportTextureAsync(b,d,P){return this._ApplyExtensions(d,((d,G)=>d.preExportTextureAsync&&d.preExportTextureAsync(b,G,P)))}_extensionsPostExportNodeAsync(b,d,P,G,W){return this._ApplyExtensions(d,((d,i)=>d.postExportNodeAsync&&d.postExportNodeAsync(b,i,P,G,W,this._bufferManager)))}_extensionsPostExportMaterialAsync(b,d,P){return this._ApplyExtensions(d,((d,G)=>d.postExportMaterialAsync&&d.postExportMaterialAsync(b,G,P)))}_extensionsPostExportMaterialAdditionalTextures(b,d,P){const G=[];for(const W of zb._ExtensionNames){const i=this._extensions[W];i.postExportMaterialAdditionalTextures&&G.push(...i.postExportMaterialAdditionalTextures(b,d,P))}return G}_extensionsPostExportTextures(b,d,P){for(const G of zb._ExtensionNames){const W=this._extensions[G];W.postExportTexture&&W.postExportTexture(b,d,P)}}_extensionsPostExportMeshPrimitive(b){for(const d of zb._ExtensionNames){const P=this._extensions[d];P.postExportMeshPrimitive&&P.postExportMeshPrimitive(b,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const b of zb._ExtensionNames){const d=this._extensions[b];d.preGenerateBinaryAsync&&await d.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(b){for(const d of zb._ExtensionNames){const P=this._extensions[d];P.enabled&&b(P)}}_extensionsOnExporting(){this._forEachExtensions((b=>{var d,P,G;b.wasUsed&&((d=this._glTF).extensionsUsed||(d.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(b.name)&&this._glTF.extensionsUsed.push(b.name),b.required&&((P=this._glTF).extensionsRequired||(P.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(b.name)&&this._glTF.extensionsRequired.push(b.name)),(G=this._glTF).extensions||(G.extensions={}),b.onExporting&&b.onExporting())}))}_loadExtensions(){for(const b of zb._ExtensionNames){const d=zb._ExtensionFactories[b](this);this._extensions[b]=d}}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.e.LastCreatedScene,d=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${w.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new j(this),this._extensions={},this._bufferManager=new xb,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!b)throw new Error("No scene available to export");this._babylonScene=b,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:b=>{var d;return null===b||void 0===b||null===(d=b.fd)||void 0===d?void 0:d.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...d},this._loadExtensions()}dispose(){for(const b in this._extensions){this._extensions[b].dispose()}}get options(){return this._options}static RegisterExtension(b,d){zb.UnregisterExtension(b)&&W.Tools.Warn(`Extension with the name ${b} already exists`),zb._ExtensionFactories[b]=d,zb._ExtensionNames.push(b)}static UnregisterExtension(b){if(!zb._ExtensionFactories[b])return!1;delete zb._ExtensionFactories[b];const d=zb._ExtensionNames.indexOf(b);return-1!==d&&zb._ExtensionNames.splice(d,1),!0}_generateJSON(b,d,P){const G={byteLength:b};return G.byteLength&&(this._glTF.buffers=[G]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Hd=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(G.uri=d+".bin"),P?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(b){const d=await this._generateBinaryAsync();this._extensionsOnExporting();const P=this._generateJSON(d.byteLength,b,!0),G=new Blob([d],{type:"application/octet-stream"}),W=b+".gltf",i=b+".bin",q=new L;if(q.files[W]=P,q.files[i]=G,this._imageData)for(const C in this._imageData)q.files[C]=new Blob([this._imageData[C].data],{type:this._imageData[C].mimeType});return q}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(b){const d=b%4;return 0===d?d:4-d}async generateGLBAsync(b){this._shouldUseGlb=!0;const d=await this._generateBinaryAsync();this._extensionsOnExporting();const P=this._generateJSON(d.byteLength),G=b+".glb";let W,i=P.length;if("undefined"!==typeof TextEncoder){W=(new TextEncoder).encode(P),i=W.length}const q=this._getPadding(i),C=this._getPadding(d.byteLength),J=28+i+q+d.byteLength+C,x=new Jb(J);if(x.writeUInt32(1179937895),x.writeUInt32(2),x.writeUInt32(J),x.writeUInt32(i+q),x.writeUInt32(1313821514),W)x.writeTypedArray(W);else{const b="_".charCodeAt(0);for(let d=0;d<i;++d){const G=P.charCodeAt(d);G!=P.codePointAt(d)?x.writeUInt8(b):x.writeUInt8(G)}}for(let L=0;L<q;++L)x.writeUInt8(32);x.writeUInt32(d.byteLength+C),x.writeUInt32(5130562),x.writeTypedArray(d);for(let L=0;L<C;++L)x.writeUInt8(0);const Y=new L;return Y.files[G]=new Blob([x.getOutputData()],{type:"application/octet-stream"}),Y}_setNodeTransformation(b,d,P){if(d.getPivotPoint().equalsWithEpsilon(c,y.c)||W.Tools.Warn("Pivot points are not supported in the glTF serializer"),!d.position.equalsWithEpsilon(c,y.c)){const W=G.TmpVectors.ed[0].q(d.position);P&&T(W),b.translation=W.jd()}d.hd.equalsWithEpsilon(z,y.c)||(b.scale=d.hd.jd());const i=d.rotationQuaternion||G.Quaternion.FromEulerAngles(d.rotation.x,d.rotation.y,d.rotation.z);i.equalsWithEpsilon(D,y.c)||(P&&K(i),b.rotation=i.normalize().jd())}_setCameraTransformation(b,d,P){if(!d.position.equalsWithEpsilon(c,y.c)){const W=G.TmpVectors.ed[0].q(d.position);P&&T(W),b.translation=W.jd()}const W=d.rotationQuaternion||G.Quaternion.FromEulerAngles(d.rotation.x,d.rotation.y,d.rotation.z);P&&K(W),this._babylonScene.useRightHandedSystem||k(W),W.equalsWithEpsilon(D,y.c)||(b.rotation=W.jd())}_listAvailableCameras(){for(const b of this._babylonScene.cameras){const d={type:b.mode===sb.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(b.name&&(d.name=b.name),"perspective"===d.type)d.perspective={aspectRatio:b.getEngine().getAspectRatio(b),yfov:b.fovMode===sb.c.FOVMODE_VERTICAL_FIXED?b.fov:b.fov*b.getEngine().getAspectRatio(b),znear:b.Vd,zfar:b.maxZ};else if("orthographic"===d.type){const P=b.orthoLeft&&b.orthoRight?.5*(b.orthoRight-b.orthoLeft):.5*b.getEngine().getRenderWidth(),G=b.orthoBottom&&b.orthoTop?.5*(b.orthoTop-b.orthoBottom):.5*b.getEngine().getRenderHeight();d.orthographic={xmag:P,ymag:G,znear:b.Vd,zfar:b.maxZ}}this._camerasMap.set(b,d)}}_exportAndAssignCameras(){const b=Array.from(this._camerasMap.values());for(const d of b){const b=this._nodesCameraMap.get(d);if(void 0!==b){this._cameras.push(d);for(const d of b)d.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const b of this._babylonScene.skeletons){if(b.bones.length<=0)continue;const d={joints:[]};this._skinMap.set(b,d)}}_exportAndAssignSkeletons(){for(const b of this._babylonScene.skeletons){if(b.bones.length<=0)continue;const d=this._skinMap.get(b);if(void 0==d)continue;const P={},G=[];let i=-1;for(let W=0;W<b.bones.length;++W){const d=b.bones[W],G=d.getIndex()??W;-1!==G&&(P[G]=d,G>i&&(i=G))}for(let b=0;b<=i;++b){const i=P[b];G.push(i.getAbsoluteInverseBindMatrix());const q=i.getTransformNode();if(null!==q){const b=this._nodeMap.get(q);q&&null!==b&&void 0!==b?d.joints.push(b):W.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else W.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const q=this._nodesSkinMap.get(d);if(d.joints.length>0&&void 0!==q){const b=64*G.length,P=new Float32Array(b/4);G.forEach(((b,d)=>{P.set(b.m,16*d)}));const W=this._bufferManager.createBufferView(P);this._accessors.push(this._bufferManager.createAccessor(W,"MAT4",5126,G.length)),d.inverseBindMatrices=this._accessors.length-1,this._skins.push(d);for(const d of q)d.skin=this._skins.length-1}}}async _exportSceneAsync(){const b={nodes:[]};if(this._babylonScene.metadata){const d=this._options.metadataSelector(this._babylonScene.metadata);d&&(b.extras=d)}const d=new Array,P=new Array,G=new Array;for(const C of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&qb(C,this._babylonScene.useRightHandedSystem)?G.push(...C.getChildren()):this._babylonScene.useRightHandedSystem?d.push(C):P.push(C);this._listAvailableCameras(),this._listAvailableSkeletons();const W=new Db(!0,!1);b.nodes.push(...await this._exportNodesAsync(P,W));const i=new Db(!1,!1);b.nodes.push(...await this._exportNodesAsync(d,i));const q=new Db(!1,!0);b.nodes.push(...await this._exportNodesAsync(G,q)),b.nodes.length&&this._scenes.push(b),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&ob._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,W.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(b){let d=this._shouldExportNodeMap.get(b);return void 0===d&&(d=this._options.shouldExportNode(b),this._shouldExportNodeMap.set(b,d)),d}async _exportNodesAsync(b,d){const P=new Array;this._exportBuffers(b,d);for(const G of b)await this._exportNodeAsync(G,P,d);return P}_collectBuffers(b,d,P,G,W){if(this._shouldExportNode(b)&&b instanceof s.d&&b.Qd){const i=b.Qd.getVertexBuffers();if(i)for(const G in i){if(!v(G))continue;const q=i[G];W.setHasVertexColorAlpha(q,b.hasVertexAlpha);const C=q._buffer,J=d.get(C)||[];d.set(C,J),-1===J.indexOf(q)&&J.push(q);const L=P.get(q)||[];P.set(q,L),-1===L.indexOf(b)&&L.push(b)}const q=b.morphTargetManager;if(q)for(let d=0;d<q.numTargets;d++){const P=q.getTarget(d),W=G.get(P)||[];G.set(P,W),-1===W.indexOf(b)&&W.push(b)}}for(const i of b.getChildren())this._collectBuffers(i,d,P,G,W)}_exportBuffers(b,d){const P=new Map,G=new Map,W=new Map;for(const C of b)this._collectBuffers(C,P,G,W,d);const i=Array.from(P.keys());for(const C of i){const b=C.getData();if(!b)throw new Error("Buffer data is not available");const W=P.get(C);if(!W)continue;const i=W[0].byteStride;if(W.some((b=>b.byteStride!==i)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const q=Pb(b).slice();for(const d of W){const b=G.get(d),{byteOffset:P,byteStride:W,componentCount:i,type:C,count:J,normalized:L,kind:Y}=I(d,b);switch(Y){case x.c.NormalKind:case x.c.TangentKind:(0,a.f)(q,P,W,i,C,J,L,(b=>{const d=Math.sqrt(b[0]*b[0]+b[1]*b[1]+b[2]*b[2]);if(d>0){const P=1/d;b[0]*=P,b[1]*=P,b[2]*=P}}));break;case x.c.ColorKind:{const d=b.filter((b=>b.material instanceof tb.Sd||null==b.material)).length;if(0==d)break;if(d!=b.length){O.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}C==x.c.UNSIGNED_BYTE&&O.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const G=new r.Nd,Y=new r.ci,s=this._babylonScene.getEngine().useExactSrgbConversions;(0,a.f)(q,P,W,i,C,J,L,(b=>{3===b.length?(G.DP(b,0),G.toLinearSpaceToRef(G,s),G.toArray(b,0)):(Y.DP(b,0),Y.toLinearSpaceToRef(Y,s),Y.toArray(b,0))}))}}}if(d.convertToRightHanded){for(const b of W){const d=G.get(b),{byteOffset:P,byteStride:W,componentCount:i,type:C,count:J,normalized:L,kind:Y}=I(b,d);switch(Y){case x.c.PositionKind:case x.c.NormalKind:case x.c.TangentKind:(0,a.f)(q,P,W,i,C,J,L,(b=>{b[0]=-b[0]}))}}d.convertedToRightHandedBuffers.set(C,q)}const J=this._bufferManager.createBufferView(q,i);d.setVertexBufferView(C,J);const L=new Map;for(const d of W){const b=G.get(d),{kind:P,totalVertices:W}=I(d,b);switch(P){case x.c.MatricesIndicesKind:case x.c.MatricesIndicesExtraKind:if(d.type==x.c.FLOAT){const b=d.getFloatData(W);null!==b&&L.set(d,b)}}}0!==L.size&&O.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const Y=Array.from(L.keys());for(const P of Y){const b=L.get(P);if(!b)continue;const G=b.some((b=>b>=256)),W=new(G?Uint16Array:Uint8Array)(b.length);for(let d=0;d<b.length;d++)W[d]=b[d];const i=this._bufferManager.createBufferView(W,4*(G?2:1));d.setRemappedBufferView(C,P,i)}}const q=Array.from(W.keys());for(const C of q){const b=W.get(C);if(!b)continue;const P=Ab(C,b[0],this._bufferManager,this._bufferViews,this._accessors,d.convertToRightHanded);for(const G of b)d.bindMorphDataToMesh(G,P)}}async _exportNodeAsync(b,d,P){let G=this._nodeMap.get(b);if(void 0!==G)return void(d.includes(G)||d.push(G));const W=await this._createNodeAsync(b,P);if(W){G=this._nodes.length,this._nodes.push(W),this._nodeMap.set(b,G),P.pushExportedNode(b),d.push(G);const i={name:"runtime animations",channels:[],samplers:[]},q=[];this._babylonScene.animationGroups.length||(ob._CreateMorphTargetAnimationFromMorphTargetAnimations(b,i,q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,P.convertToRightHanded,this._options.shouldExportAnimation),b.animations.length&&ob._CreateNodeAnimationFromNodeAnimations(b,i,q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,P.convertToRightHanded,this._options.shouldExportAnimation)),i.channels.length&&i.samplers.length&&this._animations.push(i),q.forEach((b=>{b.channels.length&&b.samplers.length&&this._animations.push(b)}))}const i=W?[]:d;for(const q of b.getChildren())await this._exportNodeAsync(q,i,P);W&&i.length&&(W.children=i)}async _createNodeAsync(b,d){if(!this._shouldExportNode(b))return null;const P={};if(b.name&&(P.name=b.name),b.metadata){const d=this._options.metadataSelector(b.metadata);d&&(P.extras=d)}if(b instanceof Y.b&&(this._setNodeTransformation(P,b,d.convertToRightHanded),b instanceof s.d)){const W=b instanceof E.d?b.sourceMesh:b;if(W.ld&&W.ld.length>0&&(P.mesh=await this._exportMeshAsync(W,d)),b.skeleton){const d=this._skinMap.get(b.skeleton);var G;if(void 0!==d)void 0===this._nodesSkinMap.get(d)&&this._nodesSkinMap.set(d,[]),null===(G=this._nodesSkinMap.get(d))||void 0===G||G.push(P)}}if(b instanceof V.d){const G=this._camerasMap.get(b);if(G){var W;void 0===this._nodesCameraMap.get(G)&&this._nodesCameraMap.set(G,[]),this._setCameraTransformation(P,b,d.convertToRightHanded);const q=b.parent;if(null!==q&&db(b,q)){const b=this._nodeMap.get(q);if(void 0!==b){var i;const d=this._nodes[b];return bb(P,d),null===(i=this._nodesCameraMap.get(G))||void 0===i||i.push(d),null}}null===(W=this._nodesCameraMap.get(G))||void 0===W||W.push(P)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",P,b,this._nodeMap,d.convertToRightHanded)?P:(O.e.Warn(`Not exporting node ${b.name}`),null)}_exportIndices(b,d,P,G,W,q,C,J,L){let x=b;L.mode=F(q);const Y=C!==i.e.CounterClockWiseSideOrientation,s=!J.wasAddedByNoopNode&&Y,E=function(b){switch(b){case i.e.TriangleFillMode:case i.e.TriangleStripDrawMode:case i.e.TriangleFanDrawMode:return!0}return!1}(q)&&s;if(E){if(q===i.e.TriangleStripDrawMode||q===i.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");L.mode=F(q);const C=d?new Uint32Array(G):new Uint16Array(G);if(b)for(let d=0;d+2<G;d+=3)C[d]=b[P+d]+W,C[d+1]=b[P+d+2]+W,C[d+2]=b[P+d+1]+W;else for(let b=0;b+2<G;b+=3)C[b]=b,C[b+1]=b+2,C[b+2]=b+1;x=C}else if(b&&0!==W){const i=d?new Uint32Array(G):new Uint16Array(G);for(let d=0;d<G;d++)i[d]=b[P+d]+W;x=i}if(x){let i=J.getIndicesAccessor(b,P,G,W,E);if(void 0===i){const q=function(b,d,P,G){if(b instanceof Uint16Array||b instanceof Uint32Array)return b;if(b instanceof Int32Array)return new Uint32Array(b.buffer,b.byteOffset,b.length);const W=b.slice(d,d+P);return G?new Uint32Array(W):new Uint16Array(W)}(x,0,G,d),C=this._bufferManager.createBufferView(q),L=d?5125:5123;this._accessors.push(this._bufferManager.createAccessor(C,"SCALAR",L,G,0)),i=this._accessors.length-1,J.setIndicesAccessor(b,P,G,W,E,i)}L.indices=i}}_exportVertexBuffer(b,d,P,G,W,i){const q=b.getKind();if(!v(q))return;if(q.startsWith("uv")&&!this._options.exportUnusedUVs&&(!d||!this._materialNeedsUVsSet.has(d)))return;let C=W.getVertexAccessor(b,P,G);if(void 0===C){const d=W.convertedToRightHandedBuffers.get(b._buffer)||b._buffer.getData(),i=q===x.c.PositionKind?function(b,d,P,G){const{byteOffset:W,byteStride:i,type:q,normalized:C}=d,J=d.getSize(),L=new Array(J).fill(1/0),x=new Array(J).fill(-1/0);return(0,a.f)(b,W+P*i,i,J,q,G*J,C,(b=>{for(let d=0;d<J;d++)L[d]=Math.min(L[d],b[d]),x[d]=Math.max(x[d],b[d])})),{min:L,max:x}}(d,b,P,G):void 0,J=(q===x.c.MatricesIndicesKind||q===x.c.MatricesIndicesExtraKind)&&b.type===x.c.FLOAT,L=J?x.c.UNSIGNED_BYTE:b.type,Y=J?void 0:b.normalized,s=J?W.getRemappedBufferView(b._buffer,b):W.getVertexBufferView(b._buffer),E=b.byteOffset+P*b.byteStride;this._accessors.push(this._bufferManager.createAccessor(s,function(b,d){if(b==x.c.ColorKind)return d?"VEC4":"VEC3";switch(b){case x.c.PositionKind:case x.c.NormalKind:return"VEC3";case x.c.TangentKind:case x.c.MatricesIndicesKind:case x.c.MatricesIndicesExtraKind:case x.c.MatricesWeightsKind:case x.c.MatricesWeightsExtraKind:return"VEC4";case x.c.UVKind:case x.c.UV2Kind:case x.c.UV3Kind:case x.c.UV4Kind:case x.c.UV5Kind:case x.c.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${b}`)}(q,W.hasVertexColorAlpha(b)),L,G,E,i,Y)),C=this._accessors.length-1,W.setVertexAccessor(b,P,G,C)}i.attributes[function(b){switch(b){case x.c.PositionKind:return"POSITION";case x.c.NormalKind:return"NORMAL";case x.c.TangentKind:return"TANGENT";case x.c.ColorKind:return"COLOR_0";case x.c.UVKind:return"TEXCOORD_0";case x.c.UV2Kind:return"TEXCOORD_1";case x.c.UV3Kind:return"TEXCOORD_2";case x.c.UV4Kind:return"TEXCOORD_3";case x.c.UV5Kind:return"TEXCOORD_4";case x.c.UV6Kind:return"TEXCOORD_5";case x.c.MatricesIndicesKind:return"JOINTS_0";case x.c.MatricesIndicesExtraKind:return"JOINTS_1";case x.c.MatricesWeightsKind:return"WEIGHTS_0";case x.c.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${b}`)}(q)]=C}async _exportMaterialAsync(b,d,P,G){let W=this._materialMap.get(b);if(void 0===W){const G=d&&Object.keys(d).some((b=>b.startsWith("uv")));if((b=b instanceof Eb.d?b.qq[P.materialIndex]:b)instanceof wb.d)W=await this._materialExporter.exportPBRMaterialAsync(b,"image/png",G);else{if(!(b instanceof tb.Sd))return void O.e.Warn(`Unsupported material '${b.name}' with type ${b.getClassName()}`);W=await this._materialExporter.exportStandardMaterialAsync(b,"image/png",G)}this._materialMap.set(b,W)}G.material=W}async _exportMeshAsync(b,d){var P;let G=d.getMesh(b);if(void 0!==G)return G;const W={primitives:[]};G=this._meshes.length,this._meshes.push(W),d.setMesh(b,G);const q=b.isUnIndexed?null:b.Id(),C=null===(P=b.Qd)||void 0===P?void 0:P.getVertexBuffers(),J=d.getMorphTargetsFromMesh(b),L=b instanceof fb.c,x=b instanceof cb,Y=b.ld;if(C&&Y&&Y.length>0)for(const w of Y){const P={attributes:{}},G=w.ab()||this._babylonScene.defaultMaterial;if(x){var s,E;const d={name:G.name},W=b,i=r.Nd.White(),q=(null===(s=W.material)||void 0===s?void 0:s.alpha)??1,C=(null===(E=W.greasedLineMaterial)||void 0===E?void 0:E.color)??i;(!C.equalsWithEpsilon(i,y.c)||q<1)&&(d.pbrMetallicRoughness={baseColorFactor:[...C.jd(),q]}),this._materials.push(d),P.material=this._materials.length-1}else if(L){const d={name:G.name},W=b;(!W.color.equalsWithEpsilon(r.Nd.White(),y.c)||W.alpha<1)&&(d.pbrMetallicRoughness={baseColorFactor:[...W.color.jd(),W.alpha]}),this._materials.push(d),P.material=this._materials.length-1}else await this._exportMaterialAsync(G,C,w,P);const Y=L||x?i.e.LineListDrawMode:b.overrideRenderingFillMode??G.fillMode,t=G._getEffectiveOrientation(b);this._exportIndices(q,q?(0,a.c)(q,w.indexCount,w.indexStart,w.verticesStart):w.verticesCount>65535,q?w.indexStart:w.verticesStart,q?w.indexCount:w.verticesCount,-w.verticesStart,Y,t,d,P);for(const b of Object.values(C))this._exportVertexBuffer(b,G,w.verticesStart,w.verticesCount,d,P);if(J){P.targets=[];for(const b of J)P.targets.push(b.attributes)}W.primitives.push(P),this._extensionsPostExportMeshPrimitive(P)}if(J){W.weights=[],W.extras||(W.extras={}),W.extras.targetNames=[];for(const b of J)W.weights.push(b.influence),W.extras.targetNames.push(b.name)}return G}}zb._ExtensionNames=new Array,zb._ExtensionFactories={};class Qb{static async GLTFAsync(b,d,P){P&&P.exportWithoutWaitingForScene||await b.whenReadyAsync();const G=new zb(b,P),W=await G.generateGLTFAsync(d.replace(/\.[^/.]+$/,""));return G.dispose(),W}static async GLBAsync(b,d,P){P&&P.exportWithoutWaitingForScene||await b.whenReadyAsync();const G=new zb(b,P),W=await G.generateGLBAsync(d.replace(/\.[^/.]+$/,""));return G.dispose(),W}}P(12250);const Ib="EXT_mesh_gpu_instancing";class mb{constructor(b){this.name=Ib,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(b,d,P,W,i,q){return await new Promise((b=>{if(d&&P instanceof nb.d&&P.hasThinInstances&&this._exporter){this._wasUsed=!0;const b=G.ed.Zero(),W=G.Quaternion.Identity(),C=G.ed.One(),J=P.thinInstanceGetWorldMatrices(),L=G.TmpVectors.ed[2],x=G.TmpVectors.Quaternion[1],Y=G.TmpVectors.ed[3];let s=!1,E=!1,w=!1;const t=new Float32Array(3*P.eq),r=new Float32Array(4*P.eq),B=new Float32Array(3*P.eq);let n=0;for(const d of J)d.decompose(Y,x,L),i&&(T(L),K(x)),t.set(L.jd(),3*n),r.set(x.normalize().jd(),4*n),B.set(Y.jd(),3*n),s=s||!L.equalsWithEpsilon(b),E=E||!x.equalsWithEpsilon(W),w=w||!Y.equalsWithEpsilon(C),n++;const Z={attributes:{}};s&&(Z.attributes.TRANSLATION=this._buildAccessor(t,"VEC3",P.eq,q)),E&&(Z.attributes.ROTATION=this._buildAccessor(r,"VEC4",P.eq,q)),w&&(Z.attributes.SCALE=this._buildAccessor(B,"VEC3",P.eq,q)),d.extensions=d.extensions||{},d.extensions[Ib]=Z}b(d)}))}_buildAccessor(b,d,P,G){const W=G.createBufferView(b),i=G.createAccessor(W,d,5126,P);return this._exporter._accessors.push(i),this._exporter._accessors.length-1}}zb.RegisterExtension(Ib,(b=>new mb(b)));var vb=P(12254),Fb=P(12266),hb=P(12269),Tb=P(12278);function Kb(b){return b===hb.c.PositionKind?"POSITION":b===hb.c.NormalKind?"NORMAL":b===hb.c.ColorKind?"COLOR":b.startsWith(hb.c.UVKind)?"TEX_COORD":"GENERIC"}const kb={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class bd extends vb.b{static get DefaultAvailable(){return(0,vb.g)(bd.DefaultConfiguration)}static get Default(){return bd._Default??(bd._Default=new bd),bd._Default}static ResetDefault(b){bd._Default&&(b||bd._Default.dispose(),bd._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(b,d){return{module:await(d||DracoEncoderModule)({wasmBinary:b})}}_getWorkerContent(){return`${Fb.k}(${Fb.n})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:bd.DefaultConfiguration)}async _encodeAsync(b,d,P){const G=P?(0,Tb.b)(kb,P):kb;if(this._workerPoolPromise){const P=await this._workerPoolPromise;return await new Promise(((W,i)=>{P.push(((P,q)=>{const C=b=>{P.removeEventListener("error",C),P.removeEventListener("message",J),i(b),q()},J=b=>{"encodeMeshDone"===b.data.id&&(P.removeEventListener("error",C),P.removeEventListener("message",J),W(b.data.encodedMeshData),q())};P.addEventListener("error",C),P.addEventListener("message",J);const L=[];for(const d of b)L.push(d.data.buffer);d&&L.push(d.buffer),P.postMessage({id:"encodeMesh",attributes:b,indices:d,options:G},L)}))}))}if(this._modulePromise){const P=await this._modulePromise;return(0,Fb.k)(P.module,b,d,G)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(b,d){if(0==b.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");b instanceof nb.d&&b.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===d||void 0===d?void 0:d.method)&&(O.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),d.method="MESH_SEQUENTIAL_ENCODING");const P=function(b){let d=b.Id(void 0,!0);return!d||d instanceof Uint32Array||d instanceof Uint16Array||(d=((0,a.c)(d,d.length)?Uint32Array:Uint16Array).from(d)),d}(b),G=function(b,d){const P=[];for(const G of b.getVerticesDataKinds()){if(null!==d&&void 0!==d&&d.includes(G)){if(G===hb.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const W=b.getVertexBuffer(G),i=W.getSize(),q=(0,a.r)(W.getData(),i,W.type,W.byteOffset,W.byteStride,W.normalized,b.getTotalVertices(),!0);P.push({kind:G,dracoName:Kb(G),size:i,data:q})}return P}(b,null===d||void 0===d?void 0:d.excludedAttributes);return await this._encodeAsync(G,P,d)}}bd.DefaultConfiguration={wasmUrl:`${W.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${W.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${W.Tools._DefaultCdnUrl}/draco_encoder.js`},bd._Default=null;const dd="KHR_draco_mesh_compression";class Pd{get wasUsed(){return this._wasUsed}constructor(b){this.name=dd,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===b.options.meshCompressionMethod&&bd.DefaultAvailable}dispose(){}postExportMeshPrimitive(b,d,P){if(!this.enabled)return;if(4!==b.mode&&5!==b.mode)return void O.e.Warn("Cannot compress primitive with mode "+b.mode+".");const G=[],W=[];let i=null;if(void 0!==b.indices){const q=P[b.indices],C=d.getBufferView(q);i=d.getData(C).slice(),G.push(C),W.push(q)}const q=[];for(const[x,Y]of Object.entries(b.attributes)){const b=P[Y],i=d.getBufferView(b),J=m(b.type),L=(0,a.r)(d.getData(i),J,b.componentType,b.byteOffset||0,i.byteStride||(0,a.m)(b.componentType)*J,b.normalized||!1,b.count,!0);q.push({kind:x,dracoName:(C=x,"POSITION"===C?"POSITION":"NORMAL"===C?"NORMAL":C.startsWith("COLOR")?"COLOR":C.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:m(b.type),data:L}),G.push(i),W.push(b)}var C;const J={method:b.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},L=bd.Default._encodeAsync(q,i,J).then((P=>{if(!P)return void O.e.Error("Draco encoding failed for primitive.");const i={bufferView:-1,attributes:P.attributeIds},q=d.createBufferView(P.data);d.setBufferView(i,q);for(const b of G)this._bufferViewsUsed.add(b);for(const b of W)this._accessorsUsed.add(b);b.extensions||(b.extensions={}),b.extensions[dd]=i})).catch((b=>{O.e.Error("Draco encoding failed for primitive: "+b)}));this._encodePromises.push(L),this._wasUsed=!0}async preGenerateBinaryAsync(b){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((d=>{b.getPropertiesWithBufferView(d).every((b=>this._accessorsUsed.has(b)))&&b.removeBufferView(d)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}zb.RegisterExtension(dd,(b=>new Pd(b)));var Gd=P(12285);const Wd="KHR_lights_punctual",id={name:"",color:[1,1,1],fC:1,range:Number.MAX_VALUE},qd={innerConeAngle:0,outerConeAngle:Math.PI/4},Cd=G.ed.Backward();class Jd{constructor(b){this.name=Wd,this.enabled=!0,this.required=!1,this._exporter=b}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Wd]=this._lights}async postExportNodeAsync(b,d,P,W,i){return await new Promise((q=>{if(!(P instanceof Zb.d))return void q(d);const C=P.getTypeID()==Zb.d.LIGHTTYPEID_POINTLIGHT?"point":P.getTypeID()==Zb.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":P.getTypeID()==Zb.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!C||!(P instanceof Gd.b))return O.e.Warn(`${b}: Light ${P.name} is not supported in ${Wd}`),void q(d);if(P.falloffType!==Zb.d.FALLOFF_GLTF&&O.e.Warn(`${b}: Light falloff for ${P.name} does not match the ${Wd} specification!`),!P.position.equalsToFloats(0,0,0)){const b=G.TmpVectors.ed[0].q(P.position);i&&T(b),d.translation=b.jd()}if("point"!==C){const b=P.direction.normalizeToRef(G.TmpVectors.ed[0]);i&&T(b);const W=G.Quaternion.FromUnitVectorsToRef(Cd,b,G.TmpVectors.Quaternion[0]);G.Quaternion.IsIdentity(W)||(d.rotation=W.jd())}const J={type:C,name:P.name,color:P.gC.jd(),fC:P.fC,range:P.range};if(Gb(J,id),"spot"===C){const b=P;J.spot={innerConeAngle:b.innerAngle/2,outerConeAngle:b.angle/2},Gb(J.spot,qd)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(J);const L={Ed:this._lights.lights.length-1},x=P.parent;if(x&&db(P,x)){const b=W.get(x);if(b){const P=this._exporter._nodes[b];return bb(d,P),P.extensions||(P.extensions={}),P.extensions[Wd]=L,void q(null)}}d.extensions||(d.extensions={}),d.extensions[Wd]=L,q(d)}))}}zb.RegisterExtension(Wd,(b=>new Jd(b)));var Ld=P(12188);const xd="KHR_materials_anisotropy";class Yd{constructor(b){this.name=xd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,d,P){const G=[];return P instanceof Ld.d&&P.anisotropy.isEnabled&&!P.anisotropy.legacy?(P.anisotropy.texture&&G.push(P.anisotropy.texture),G):[]}postExportMaterialAsync(b,d,P){return new Promise((b=>{if(P instanceof Ld.d){if(!P.anisotropy.isEnabled||P.anisotropy.legacy)return void b(d);this._wasUsed=!0,d.extensions=d.extensions||{};const G=this._exporter._materialExporter.getTextureInfo(P.anisotropy.texture),W={anisotropyStrength:P.anisotropy.fC,anisotropyRotation:P.anisotropy.angle,anisotropyTexture:G??void 0};null!==W.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(P),d.extensions[xd]=W}b(d)}))}}zb.RegisterExtension(xd,(b=>new Yd(b)));const sd="KHR_materials_clearcoat";class Ed{constructor(b){this.name=sd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,d,P){const G=[];return P instanceof Ld.d&&P.clearCoat.isEnabled?(P.clearCoat.texture&&G.push(P.clearCoat.texture),!P.clearCoat.useRoughnessFromMainTexture&&P.clearCoat.textureRoughness&&G.push(P.clearCoat.textureRoughness),P.clearCoat.bumpTexture&&G.push(P.clearCoat.bumpTexture),G):[]}postExportMaterialAsync(b,d,P){return new Promise((b=>{if(P instanceof Ld.d){if(!P.clearCoat.isEnabled)return void b(d);this._wasUsed=!0,d.extensions=d.extensions||{};const G=this._exporter._materialExporter.getTextureInfo(P.clearCoat.texture);let i;i=P.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(P.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(P.clearCoat.textureRoughness),P.clearCoat.isTintEnabled&&W.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${P.name}`),P.clearCoat.remapF0OnInterfaceChange&&W.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${P.name}`);const q=this._exporter._materialExporter.getTextureInfo(P.clearCoat.bumpTexture),C={clearcoatFactor:P.clearCoat.fC,clearcoatTexture:G??void 0,clearcoatRoughnessFactor:P.clearCoat.roughness,clearcoatRoughnessTexture:i??void 0,clearcoatNormalTexture:q??void 0};null===C.clearcoatTexture&&null===C.clearcoatRoughnessTexture&&null===C.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(P),d.extensions[sd]=C}b(d)}))}}zb.RegisterExtension(sd,(b=>new Ed(b)));const wd="KHR_materials_diffuse_transmission";function td(b,d){const P=d.subSurface;let G=null;return P.translucencyIntensityTexture?G=P.translucencyIntensityTexture:P.thicknessTexture&&P.useMaskFromThicknessTexture&&(G=P.thicknessTexture),G&&!P.useGltfStyleTextures?(O.e.Warn(`${b}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${d.name}`,1),null):G}class rd{constructor(b){this.name=wd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,d,P){const G=[];if(P instanceof wb.d&&this._isExtensionEnabled(P)){const d=td(b,P);return d&&G.push(d),P.subSurface.translucencyColorTexture&&G.push(P.subSurface.translucencyColorTexture),G}return G}_isExtensionEnabled(b){if(b.unlit)return!1;const d=b.subSurface;return!!d.isTranslucencyEnabled&&(!b.unlit&&!d.useAlbedoToTintTranslucency&&d.useGltfStyleTextures&&1===d.volumeIndexOfRefraction&&0===d.minimumThickness&&0===d.maximumThickness)}postExportMaterialAsync(b,d,P){return new Promise((G=>{if(P instanceof wb.d&&this._isExtensionEnabled(P)){this._wasUsed=!0;const G=P.subSurface,W=td(b,P),i=0==G.translucencyIntensity?void 0:G.translucencyIntensity,q=this._exporter._materialExporter.getTextureInfo(W)??void 0,C=!G.translucencyColor||G.translucencyColor.equalsFloats(1,1,1)?void 0:G.translucencyColor.jd(),J=this._exporter._materialExporter.getTextureInfo(G.translucencyColorTexture)??void 0,L={diffuseTransmissionFactor:i,diffuseTransmissionTexture:q,diffuseTransmissionColorFactor:C,diffuseTransmissionColorTexture:J};(q||J)&&this._exporter._materialNeedsUVsSet.add(P),d.extensions=d.extensions||{},d.extensions[wd]=L}G(d)}))}}zb.RegisterExtension(wd,(b=>new rd(b)));const Bd="KHR_materials_dispersion";class nd{constructor(){this.name=Bd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(b){if(b.unlit)return!1;const d=b.subSurface;return!(!d.isRefractionEnabled&&!d.isDispersionEnabled)}postExportMaterialAsync(b,d,P){return new Promise((b=>{if(P instanceof wb.d&&this._isExtensionEnabled(P)){this._wasUsed=!0;const b={dispersion:P.subSurface.dispersion};d.extensions=d.extensions||{},d.extensions[Bd]=b}b(d)}))}}zb.RegisterExtension(Bd,(()=>new nd));const Zd="KHR_materials_emissive_strength";class od{constructor(){this.name=Zd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(b,d,P){return await new Promise((b=>{if(!(P instanceof wb.d))return b(d);const G=P.emissiveColor.jd(),W=Math.max(...G);if(W>1){this._wasUsed=!0,d.extensions||(d.extensions={});const b={emissiveStrength:W},G=P.emissiveColor.scale(1/b.emissiveStrength);d.emissiveFactor=G.jd(),d.extensions[Zd]=b}return b(d)}))}}zb.RegisterExtension(Zd,(b=>new od));const Ad="KHR_materials_ior";class fd{constructor(){this.name=Ad,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(b){return!b.unlit&&(void 0!=b.indexOfRefraction&&1.5!=b.indexOfRefraction)}postExportMaterialAsync(b,d,P){return new Promise((b=>{if(P instanceof wb.d&&this._isExtensionEnabled(P)){this._wasUsed=!0;const b={ior:P.indexOfRefraction};d.extensions=d.extensions||{},d.extensions[Ad]=b}b(d)}))}}zb.RegisterExtension(Ad,(b=>new fd));const gd="KHR_materials_iridescence";class Xd{constructor(b){this.name=gd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,d,P){const G=[];return P instanceof Ld.d&&P.iridescence.isEnabled?(P.iridescence.texture&&G.push(P.iridescence.texture),P.iridescence.thicknessTexture&&P.iridescence.thicknessTexture!==P.iridescence.texture&&G.push(P.iridescence.thicknessTexture),G):[]}postExportMaterialAsync(b,d,P){return new Promise((b=>{if(P instanceof Ld.d){if(!P.iridescence.isEnabled)return void b(d);this._wasUsed=!0,d.extensions=d.extensions||{};const G=this._exporter._materialExporter.getTextureInfo(P.iridescence.texture),W=this._exporter._materialExporter.getTextureInfo(P.iridescence.thicknessTexture),i={iridescenceFactor:P.iridescence.fC,iridescenceIor:P.iridescence.indexOfRefraction,iridescenceThicknessMinimum:P.iridescence.minimumThickness,iridescenceThicknessMaximum:P.iridescence.maximumThickness,iridescenceTexture:G??void 0,iridescenceThicknessTexture:W??void 0};null===i.iridescenceTexture&&null===i.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(P),d.extensions[gd]=i}b(d)}))}}zb.RegisterExtension(gd,(b=>new Xd(b)));const ud="KHR_materials_sheen";class Md{constructor(b){this.name=ud,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,d,P){return P instanceof wb.d&&P.sheen.isEnabled&&P.sheen.texture?[P.sheen.texture]:[]}async postExportMaterialAsync(b,d,P){return await new Promise((b=>{if(P instanceof wb.d){if(!P.sheen.isEnabled)return void b(d);this._wasUsed=!0,null==d.extensions&&(d.extensions={});const G={sheenColorFactor:P.sheen.color.jd(),sheenRoughnessFactor:P.sheen.roughness??0};null===G.sheenColorTexture&&null===G.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(P),P.sheen.texture&&(G.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.texture)??void 0),P.sheen.textureRoughness&&!P.sheen.useRoughnessFromMainTexture?G.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.textureRoughness)??void 0:P.sheen.texture&&P.sheen.useRoughnessFromMainTexture&&(G.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.texture)??void 0),d.extensions[ud]=G}b(d)}))}}zb.RegisterExtension(ud,(b=>new Md(b)));const ed="KHR_materials_specular";class Rd{constructor(b){this.name=ed,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,d,P){const G=[];return P instanceof wb.d&&this._isExtensionEnabled(P)?(P.metallicReflectanceTexture&&G.push(P.metallicReflectanceTexture),P.reflectanceTexture&&G.push(P.reflectanceTexture),G):G}_isExtensionEnabled(b){return!b.unlit&&(void 0!=b.metallicF0Factor&&1!=b.metallicF0Factor||void 0!=b.metallicReflectanceColor&&!b.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(b))}_hasTexturesExtension(b){return null!=b.metallicReflectanceTexture||null!=b.reflectanceTexture}postExportMaterialAsync(b,d,P){return new Promise((b=>{if(P instanceof wb.d&&this._isExtensionEnabled(P)){this._wasUsed=!0,d.extensions=d.extensions||{};const b=this._exporter._materialExporter.getTextureInfo(P.metallicReflectanceTexture)??void 0,G=this._exporter._materialExporter.getTextureInfo(P.reflectanceTexture)??void 0,W={specularFactor:1==P.metallicF0Factor?void 0:P.metallicF0Factor,specularTexture:b,specularColorFactor:P.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:P.metallicReflectanceColor.jd(),specularColorTexture:G};this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),d.extensions[ed]=W}b(d)}))}}zb.RegisterExtension(ed,(b=>new Rd(b)));const Ud="KHR_materials_transmission";class Hd{constructor(b){this.name=Ud,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,d,P){const G=[];return P instanceof wb.d&&this._isExtensionEnabled(P)?(P.subSurface.thicknessTexture&&G.push(P.subSurface.thicknessTexture),G):G}_isExtensionEnabled(b){if(b.unlit)return!1;const d=b.subSurface;return d.isRefractionEnabled&&void 0!=d.refractionIntensity&&0!=d.refractionIntensity||this._hasTexturesExtension(b)}_hasTexturesExtension(b){return null!=b.subSurface.refractionIntensityTexture}async postExportMaterialAsync(b,d,P){if(P instanceof wb.d&&this._isExtensionEnabled(P)){this._wasUsed=!0;const G=P.subSurface,W={transmissionFactor:0===G.refractionIntensity?void 0:G.refractionIntensity};if(this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),G.refractionIntensityTexture)if(G.useGltfStyleTextures){const b=await this._exporter._materialExporter.exportTextureAsync(G.refractionIntensityTexture,"image/png");b&&(W.transmissionTexture=b)}else O.e.Warn(`${b}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);d.extensions||(d.extensions={}),d.extensions[Ud]=W}return d}}zb.RegisterExtension(Ud,(b=>new Hd(b)));const pd="KHR_materials_unlit";class Sd{constructor(){this.name=pd,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(b,d,P){return new Promise((b=>{let G=!1;P instanceof wb.d?G=P.unlit:P instanceof tb.Sd&&(G=P.disableLighting),G&&(this._wasUsed=!0,null==d.extensions&&(d.extensions={}),d.extensions[pd]={}),b(d)}))}}zb.RegisterExtension(pd,(()=>new Sd));const ld="KHR_materials_volume";class Nd{constructor(b){this.name=ld,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,d,P){const G=[];return P instanceof wb.d&&this._isExtensionEnabled(P)?(P.subSurface.thicknessTexture&&G.push(P.subSurface.thicknessTexture),G):G}_isExtensionEnabled(b){if(b.unlit)return!1;const d=b.subSurface;return!(!d.isRefractionEnabled&&!d.isTranslucencyEnabled)&&(void 0!=d.maximumThickness&&0!=d.maximumThickness||void 0!=d.tintColorAtDistance&&d.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=d.tintColor&&d.tintColor!=r.Nd.White()||this._hasTexturesExtension(b))}_hasTexturesExtension(b){return null!=b.subSurface.thicknessTexture}postExportMaterialAsync(b,d,P){return new Promise((b=>{if(P instanceof wb.d&&this._isExtensionEnabled(P)){this._wasUsed=!0;const b=P.subSurface,G={thicknessFactor:0==b.maximumThickness?void 0:b.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(b.thicknessTexture)??void 0,attenuationDistance:b.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:b.tintColorAtDistance,attenuationColor:b.tintColor.equalsFloats(1,1,1)?void 0:b.tintColor.jd()};this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),d.extensions=d.extensions||{},d.extensions[ld]=G}b(d)}))}}zb.RegisterExtension(ld,(b=>new Nd(b)));const jd="EXT_materials_diffuse_roughness";class ad{constructor(b){this.name=jd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,d,P){const G=[];return P instanceof Ld.d&&P._baseDiffuseRoughness?(P._baseDiffuseRoughnessTexture&&G.push(P._baseDiffuseRoughnessTexture),G):[]}postExportMaterialAsync(b,d,P){return new Promise((b=>{if(P instanceof Ld.d){if(!P._baseDiffuseRoughness)return void b(d);this._wasUsed=!0,d.extensions=d.extensions||{};const G=this._exporter._materialExporter.getTextureInfo(P._baseDiffuseRoughnessTexture),W={diffuseRoughnessFactor:P._baseDiffuseRoughness,diffuseRoughnessTexture:G??void 0};null!==W.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(P),d.extensions[jd]=W}b(d)}))}}zb.RegisterExtension(jd,(b=>new ad(b)));const Od="KHR_texture_transform";class Vd{constructor(){this.name=Od,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(b,d,P){if(P.Xb()||W.Tools.Warn(`${b}: /*@__KEY__*/"scene" is not defined for Babylon texture ${P.name}!`),(0!==P.uAng||0!==P.vAng)&&(W.Tools.Warn(`${b}: Texture ${P.name} with rotation in the u or v axis is not supported in glTF.`),0!==P.uRotationCenter||0!==P.vRotationCenter))return;const G={};let i=!1;if(0===P.uOffset&&0===P.vOffset||(G.offset=[P.uOffset,P.vOffset],i=!0),1===P.uScale&&1===P.vScale||(G.scale=[P.uScale,P.vScale],i=!0),0!==P.wAng){if(0!==P.uRotationCenter||0!==P.vRotationCenter){if(P.homogeneousRotationInUVTransform&&P.uScale!==P.vScale)return void W.Tools.Warn(`${b}: Texture ${P.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Od}.`);W.Tools.Warn(`${b}: Texture ${P.name} with non-origin rotation center will be exported using an adjusted offset with ${Od}.`),G.offset=function(b){const{uOffset:d,vOffset:P,uRotationCenter:G,vRotationCenter:W,uScale:i,vScale:q,wAng:C}=b,J=Math.cos(C),L=Math.sin(C),x=G*i,Y=W*q;return[d+(x*(1-J)+Y*L),P+(Y*(1-J)-x*L)]}(P)}G.rotation=-P.wAng,i=!0}0!==P.coordinatesIndex&&(G.texCoord=P.coordinatesIndex,i=!0),i&&(this._wasUsed=!0,d.extensions||(d.extensions={}),d.extensions[Od]=G)}}zb.RegisterExtension(Od,(()=>new Vd));class yd{static CreateSTL(b){let d=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",W=arguments.length>3&&void 0!==arguments[3]&&arguments[3],i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],q=arguments.length>5&&void 0!==arguments[5]&&arguments[5],C=arguments.length>6&&void 0!==arguments[6]&&arguments[6],J=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const L=function(b,d,P){const W=[3*b[P],3*b[P+1],3*b[P+2]],i=[new G.ed(d[W[0]],d[W[0]+2],d[W[0]+1]),new G.ed(d[W[1]],d[W[1]+2],d[W[1]+1]),new G.ed(d[W[2]],d[W[2]+2],d[W[2]+1])],q=i[0].Rd(i[1]),C=i[2].Rd(i[1]);return{v:i,n:G.ed.Cross(C,q).normalize()}},Y=function(b,d,P,G){return d=s(b,d,P.x,G),d=s(b,d,P.y,G),s(b,d,P.z,G)},s=function(b,d,P,G){return b.setFloat32(d,P,G),d+4},w=function(b){if(C){let d=b;b instanceof E.d&&(d=b.sourceMesh);const P=d.getVerticesData(x.c.PositionKind,!0,!0);if(!P)return[];const W=G.ed.Zero();let i;for(i=0;i<P.length;i+=3)G.ed.TransformCoordinatesFromFloatsToRef(P[i],P[i+1],P[i+2],b.zd(!0),W).toArray(P,i);return P}return b.getVerticesData(x.c.PositionKind)||[]};C&&(q=!0);let t="",r=0,B=0;if(W){for(let P=0;P<b.length;P++){const d=b[P].Id();r+=d?d.length/3:0}const d=new ArrayBuffer(84+50*r);t=new DataView(d),B+=80,t.setUint32(B,r,i),B+=4}else J||(t="solid stlmesh\r\n");for(let G=0;G<b.length;G++){const d=b[G];!W&&J&&(t+="solid "+d.name+"\r\n"),!q&&d instanceof nb.d&&d.bakeCurrentTransformIntoVertices();const P=w(d),C=d.Id()||[];for(let b=0;b<C.length;b+=3){const d=L(C,P,b);W?(B=Y(t,B,d.n,i),B=Y(t,B,d.v[0],i),B=Y(t,B,d.v[1],i),B=Y(t,B,d.v[2],i),B+=2):(t+="\tfacet normal "+d.n.x+" "+d.n.y+" "+d.n.z+"\r\n",t+="\t\touter loop\r\n",t+="\t\t\tvertex "+d.v[0].x+" "+d.v[0].y+" "+d.v[0].z+"\r\n",t+="\t\t\tvertex "+d.v[1].x+" "+d.v[1].y+" "+d.v[1].z+"\r\n",t+="\t\t\tvertex "+d.v[2].x+" "+d.v[2].y+" "+d.v[2].z+"\r\n",t+="\t\tendloop\r\n",t+="\tendfacet\r\n")}!W&&J&&(t+="endsolid "+name+"\r\n")}if(W||J||(t+="endsolid stlmesh"),d){const b=document.createElement("a"),d=new Blob([t],{type:"application/octet-stream"});b.href=window.URL.createObjectURL(d),b.download=P+".stl",b.click()}return t}}function cd(b,d){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const G=[];for(let W=0;W<b.length/P;W++){const i=b[W*P],q=b[W*P+1],C=b[W*P+2];G.push(`(${i.toPrecision(d.precision)}, ${q.toPrecision(d.precision)}, ${C.toPrecision(d.precision)})`)}return G.join(", ")}function Dd(b,d){const P=[];for(let G=0;G<b.length/2;G++){const W=b[2*G],i=b[2*G+1];P.push(`(${W.toPrecision(d.precision)}, ${(1-i).toPrecision(d.precision)})`)}return P.join(", ")}function zd(b,d){const P=b.getVerticesData(x.c.PositionKind),G=b.getVerticesData(x.c.NormalKind);if(P&&G)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(b){var d;const P=null!==(d=b.Id())&&void 0!==d&&d.length?b.getTotalIndices():b.getTotalVertices();return Array(P/3).fill(3).join(", ")}(b)}]\n\t\tint[] faceVertexIndices = [${function(b){const d=b.Id(),P=[];if(null!==d)for(let G=0;G<d.length;G++)P.push(d[G]);else{const d=b.getTotalVertices();for(let b=0;b<d;b++)P.push(b)}return P.join(", ")}(b)}]\n\t\tnormal3f[] normals = [${cd(G,d)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${cd(P,d)}]\n        ${function(b,d){let P="";for(let W=0;W<4;W++){const G=W>0?W:"",i=b.getVerticesData(x.c.UVKind+(G?G+1:""));i&&(P+=`\n\t\ttexCoord2f[] primvars:st${G} = [${Dd(i,d)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const G=b.getVerticesData(x.c.ColorKind);return G&&(P+=`\n\tcolor3f[] primvars:displayColor = [${cd(G,d,G.length/b.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),P}(b,d)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Qd(b,d){return`\n        def "Geometry"\n        {\n        ${zd(b,d)}\n        }\n        `}function Id(b){let d='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return d+=b,fflate.strToU8(d)}function md(b){const d=b.m;return`( ${vd(d,0)}, ${vd(d,4)}, ${vd(d,8)}, ${vd(d,12)} )`}function vd(b,d){return`(${b[d+0]}, ${b[d+1]}, ${b[d+2]}, ${b[d+3]})`}function Fd(b){const d="Object_"+b.uniqueId,P=function(b){const d=b.getWorldMatrix().clone(),P=b.Xb().useRightHandedSystem;if(!P){let G=b.parent;for(;G;){if(qb(G,P)){d.multiplyToRef(G.getWorldMatrix().invert(),d);break}G=G.parent}}return d.determinant()<0&&W.Tools.Warn(`Exporting mesh ${b.name} with negative scale. Result may look incorrect in destination engine.`),d}(b),G=md(P);return`def Xform "${d}" (\n\tprepend references = @./geometries/Geometry_${b.Qd.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${G}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${b.material.uniqueId}>\n}\n\n`}function hd(b){switch(b){case g.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case g.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case g.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Td(b){return`(${b.x}, ${b.y})`}function Kd(b){return`(${b.r}, ${b.g}, ${b.b})`}function kd(b,d,P,W,i,q){const C=b.getInternalTexture().uniqueId+"_"+b.invertY;i[C]=b;const J=b.coordinatesIndex>0?"st"+b.coordinatesIndex:"st",L=new G.Vector2(b.uScale,b.vScale),x=new G.Vector2(b.uOffset,b.vOffset),Y=b.wAng,s=Math.sin(Y),E=Math.cos(Y);return x.y=1-x.y-L.y,x.x+=s*L.x,x.y+=(1-E)*L.y,`\n    def Shader "PrimvarReader_${P}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${J}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${P}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${d.uniqueId}/PrimvarReader_${P}.outputs:result>\n        float inputs:rotation = ${(Y*(180/Math.PI)).toFixed(q.precision)}\n        float2 inputs:scale = ${Td(L)}\n        float2 inputs:translation = ${Td(x)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${b.uniqueId}_${P}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${C}.png@\n        float2 inputs:st.connect = </Materials/Material_${d.uniqueId}/Transform2d_${P}.outputs:result>\n        ${W?"float4 inputs:scale = "+function(b){return`(${b.r}, ${b.g}, ${b.b}, 1.0)`}(W):""}\n        token inputs:sourceColorSpace = "${b.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${hd(b.wrapU)}"\n        token inputs:wrapT = "${hd(b.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${d.needAlphaBlending()?"float outputs:a":""}\n    }`}function bP(b,d,P){const G="\t\t\t",W=[],i=[],{diffuseMap:q,gC:C,alphaCutOff:J,emissiveMap:L,emissive:x,normalMap:Y,roughnessMap:s,roughnessChannel:E,roughness:w,metalnessMap:t,metalnessChannel:B,metalness:n,aoMap:Z,aoMapChannel:o,aoMapIntensity:A,alphaMap:f,ior:g,clearCoatEnabled:X,clearCoat:u,clearCoatMap:M,clearCoatRoughness:e,clearCoatRoughnessMap:R}=function(b){const d={diffuseMap:null,gC:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return b instanceof tb.Sd?{...d,diffuseMap:b.diffuseTexture,gC:b.diffuseColor,alphaCutOff:b.alphaCutOff,emissiveMap:b.emissiveTexture,emissive:b.emissiveColor,roughness:1,alphaMap:b.opacityTexture}:b instanceof Ld.d?{...d,diffuseMap:b._albedoTexture,gC:b._albedoColor,alphaCutOff:b._alphaCutOff,emissiveMap:b._emissiveTexture,emissive:b._emissiveColor,normalMap:b._bumpTexture,roughnessMap:b._metallicTexture,roughnessChannel:b._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:b._roughness??1,metalnessMap:b._metallicTexture,metalnessChannel:b._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:b._metallic??0,aoMap:b._ambientTexture,aoMapChannel:b._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:b._ambientTextureStrength,alphaMap:b._opacityTexture,ior:b.subSurface.indexOfRefraction,clearCoatEnabled:b.clearCoat.isEnabled,clearCoat:b.clearCoat.fC,clearCoatMap:b.clearCoat.texture,clearCoatRoughness:b.clearCoat.roughness,clearCoatRoughnessMap:b.clearCoat.useRoughnessFromMainTexture?b.clearCoat.texture:b.clearCoat.textureRoughness}:d}(b);return null!==q?(W.push(`${G}color3f inputs:diffuseColor.connect = </Materials/Material_${b.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:rgb>`),b.needAlphaBlending()?W.push(`${G}float inputs:opacity.connect = </Materials/Material_${b.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:a>`):b.needAlphaTesting()&&(W.push(`${G}float inputs:opacity.connect = </Materials/Material_${b.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:a>`),W.push(`${G}float inputs:opacityThreshold = ${J}`)),i.push(kd(q,b,"diffuse",C,d,P))):W.push(`${G}color3f inputs:diffuseColor = ${Kd(C||r.Nd.White())}`),null!==L?(W.push(`${G}color3f inputs:emissiveColor.connect = </Materials/Material_${b.uniqueId}/Texture_${L.uniqueId}_emissive.outputs:rgb>`),i.push(kd(L,b,"emissive",x,d,P))):x&&x.toLuminance()>0&&W.push(`${G}color3f inputs:emissiveColor = ${Kd(x)}`),null!==Y&&(W.push(`${G}normal3f inputs:normal.connect = </Materials/Material_${b.uniqueId}/Texture_${Y.uniqueId}_normal.outputs:rgb>`),i.push(kd(Y,b,"normal",null,d,P))),null!==Z&&(W.push(`${G}float inputs:occlusion.connect = </Materials/Material_${b.uniqueId}/Texture_${Z.uniqueId}_occlusion.outputs:${o}>`),i.push(kd(Z,b,"occlusion",new r.Nd(A,A,A),d,P))),null!==s?(W.push(`${G}float inputs:roughness.connect = </Materials/Material_${b.uniqueId}/Texture_${s.uniqueId}_roughness.outputs:${E}>`),i.push(kd(s,b,"roughness",new r.Nd(w,w,w),d,P))):W.push(`${G}float inputs:roughness = ${w}`),null!==t?(W.push(`${G}float inputs:metallic.connect = </Materials/Material_${b.uniqueId}/Texture_${t.uniqueId}_metallic.outputs:${B}>`),i.push(kd(t,b,"metallic",new r.Nd(n,n,n),d,P))):W.push(`${G}float inputs:metallic = ${n}`),null!==f?(W.push(`${G}float inputs:opacity.connect = </Materials/Material_${b.uniqueId}/Texture_${f.uniqueId}_opacity.outputs:r>`),W.push(`${G}float inputs:opacityThreshold = 0.0001`),i.push(kd(f,b,"opacity",null,d,P))):W.push(`${G}float inputs:opacity = ${b.alpha}`),X&&(null!==M?(W.push(`${G}float inputs:clearcoat.connect = </Materials/Material_${b.uniqueId}/Texture_${M.uniqueId}_clearcoat.outputs:r>`),i.push(kd(M,b,"clearcoat",new r.Nd(u,u,u),d,P))):W.push(`${G}float inputs:clearcoat = ${u}`),null!==R?(W.push(`${G}float inputs:clearcoatRoughness.connect = </Materials/Material_${b.uniqueId}/Texture_${R.uniqueId}_clearcoatRoughness.outputs:g>`),i.push(kd(R,b,"clearcoatRoughness",new r.Nd(e,e,e),d,P))):W.push(`${G}float inputs:clearcoatRoughness = ${e}`)),W.push(`${G}float inputs:ior = ${g}`),`\n\tdef Material "Material_${b.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${W.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${b.uniqueId}/PreviewSurface.outputs:surface>\n\n${i.join("\n")}\n\n\t}\n`}async function dP(b,d,P){const i={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...d};"undefined"===typeof fflate&&await W.Tools.LoadScriptAsync(i.fflateUrl);const q={};q[i.modelFileName]=null;let C='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';C+=function(b){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===b.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${b.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${b.planeAnchoringAlignment}"`:""}\n            `}(i);const J={};for(const G of b.meshes){if(0===G.getTotalVertices())continue;const b=G,d=b.Qd,L=b.material;if(!L||!d||P&&!P(b))continue;if(-1!==["Sd","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(L.getClassName())){const P="geometries/Geometry_"+d.uniqueId+".usda";if(!(P in q)){const b=Qd(d,i);q[P]=Id(b)}L.uniqueId in J||(J[L.uniqueId]=L),C+=Fd(b)}else W.Tools.Warn("USDZExportAsync does not support this material type: "+L.getClassName())}b.activeCamera&&i.exportCamera&&(C+=function(b,d){const P="Camera_"+b.uniqueId,W=md(G.Matrix.RotationY(Math.PI).multiply(b.getWorldMatrix()));if(b.mode===g.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${P}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${W}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${b.Vd.toPrecision(d.precision)}, ${b.maxZ.toPrecision(d.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(b.orthoLeft||1)+Math.abs(b.orthoRight||1))).toPrecision(d.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(b.orthoTop||1)+Math.abs(b.orthoBottom||1))).toPrecision(d.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const G=b.getEngine().getAspectRatio(b),i=d.cameraSensorWidth||35;return`def Camera "${P}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${W}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${b.Vd.toPrecision(d.precision)}, ${b.maxZ.toPrecision(d.precision)})\n\t\t\tfloat focalLength = ${(i/(2*Math.tan(.5*b.fov))).toPrecision(d.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(i*G).toPrecision(d.precision)}\n\t\t\tfloat verticalAperture = ${(i/G).toPrecision(d.precision)}            \n\t\t}\n\t\n\t`}}(b.activeCamera,i)),C+="\n            }\n        }\n    }";const L={};C+=function(b,d,P){const G=[];for(const W in b){const i=b[W];G.push(bP(i,d,P))}return`\n    def "Materials"\n{\n${G.join("")}\n}\n\n`}(J,L,i),q[i.modelFileName]=fflate.strToU8(C);for(const G in L){const b=L[G],d=b.getSize(),P=await b.readPixels();if(!P)throw new Error("Texture data is not available");const W=await X.DumpTools.DumpDataAsync(d.width,d.height,P,"image/png",void 0,!1,!0);q[`textures/Texture_${G}.png`]=new Uint8Array(W).slice()}let x=0;for(const G in q){const b=q[G];if(!b)continue;x+=34+G.length;const d=63&x;if(4!==d){const P=new Uint8Array(64-d);q[G]=[b,{extra:{12345:P}}]}x=b.length}return fflate.zipSync(q,{level:0})}}}]);