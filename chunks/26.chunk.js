"use strict";(self.u4k1rqylno=self.u4k1rqylno||[]).push([[26],{12131:(e,E,H)=>{H.r(E),H.d(E,{EXT_materials_diffuse_roughness:()=>LE,EXT_mesh_gpu_instancing:()=>Ie,GLTF2Export:()=>Je,GLTFData:()=>A,KHR_draco_mesh_compression:()=>HE,KHR_lights_punctual:()=>DE,KHR_materials_anisotropy:()=>iE,KHR_materials_clearcoat:()=>UE,KHR_materials_diffuse_transmission:()=>hE,KHR_materials_dispersion:()=>XE,KHR_materials_emissive_strength:()=>WE,KHR_materials_ior:()=>YE,KHR_materials_iridescence:()=>wE,KHR_materials_sheen:()=>pE,KHR_materials_specular:()=>yE,KHR_materials_transmission:()=>KE,KHR_materials_unlit:()=>OE,KHR_materials_volume:()=>RE,KHR_texture_transform:()=>GE,OBJExport:()=>P,STLExport:()=>mH,USDZExportAsync:()=>EH,_ConvertToGLTFPBRMetallicRoughness:()=>l,_SolveMetallic:()=>K,__IGLTFExporterExtension:()=>M});var N=H(11738),u=H(11532),z=H(12047);class P{static OBJ(e,E,H,P){const M=[];let D=1,A=1;E&&(H||(H="mat"),M.push("mtllib "+H+".mtl"));for(let C=0;C<e.length;C++){const H=e[C],i=H.name||`mesh${C}}`;M.push(`o ${i}`);let V=null;if(P){const e=H.DM(!0);V=new N.Matrix,e.invertToRef(V),H.bakeTransformIntoVertices(e)}if(E){const e=H.material;e&&M.push("usemtl "+e.id)}const U=H.AM;if(!U){u.Tools.Warn("No geometry is present on the mesh");continue}const j=U.getVerticesData("position"),F=U.getVerticesData("normal"),h=U.getVerticesData("uv"),S=U.CM();let X=0,a=0;if(!j||!S){u.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const W=e[0].fe().useRightHandedSystem?1:-1;for(let e=0;e<j.length;e+=3)M.push("v "+j[e]*W+" "+j[e+1]+" "+j[e+2]),X++;if(null!=F)for(let e=0;e<F.length;e+=3)M.push("vn "+F[e]*W+" "+F[e+1]+" "+F[e+2]);if(null!=h)for(let e=0;e<h.length;e+=2)M.push("vt "+h[e]+" "+h[e+1]),a++;const r=["","",""],Y=(H.material||H.fe().defaultMaterial)._getEffectiveOrientation(H),[f,w]=Y===z.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let e=0;e<S.length;e+=3){const E=[String(S[e]+D),String(S[e+f]+D),String(S[e+w]+D)],H=[String(S[e]+A),String(S[e+f]+A),String(S[e+w]+A)],N=E,u=null!=h?H:r,z=null!=F?E:r;M.push("f "+N[0]+"/"+u[0]+"/"+z[0]+" "+N[1]+"/"+u[1]+"/"+z[1]+" "+N[2]+"/"+u[2]+"/"+z[2])}P&&V&&H.bakeTransformIntoVertices(V),D+=X,A+=a}return M.join("\n")}static MTL(e){const E=[],H=e.material;E.push("newmtl mat1"),E.push("  Ns "+H.specularPower.toFixed(4)),E.push("  Ni 1.5000"),E.push("  d "+H.alpha.toFixed(4)),E.push("  Tr 0.0000"),E.push("  Tf 1.0000 1.0000 1.0000"),E.push("  illum 2"),E.push("  Ka "+H.ambientColor.r.toFixed(4)+" "+H.ambientColor.g.toFixed(4)+" "+H.ambientColor.b.toFixed(4)),E.push("  Kd "+H.diffuseColor.r.toFixed(4)+" "+H.diffuseColor.g.toFixed(4)+" "+H.diffuseColor.b.toFixed(4)),E.push("  Ks "+H.specularColor.r.toFixed(4)+" "+H.specularColor.g.toFixed(4)+" "+H.specularColor.b.toFixed(4)),E.push("  Ke "+H.emissiveColor.r.toFixed(4)+" "+H.emissiveColor.g.toFixed(4)+" "+H.emissiveColor.b.toFixed(4));H.ambientTexture&&E.push("  map_Ka "+H.ambientTexture.name),H.diffuseTexture&&E.push("  map_Kd "+H.diffuseTexture.name),H.specularTexture&&E.push("  map_Ks "+H.specularTexture.name),H.bumpTexture&&E.push("  map_bump -imfchan z "+H.bumpTexture.name),H.opacityTexture&&E.push("  map_d "+H.opacityTexture.name);return E.join("\n")}}var M=0,D=H(11587);class A{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const e in this.files){const E=this.files[e],H=new Blob([E],{type:(0,D.l)(e)});u.Tools.Download(H,e)}}}var C=H(11818),i=H(12133),V=H(12140),U=H(12161),j=H(11862),F=H(11579),h=H(11789),S=H(11756);const X=S.HighestCommonFactor,a={...S,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:X};var W=H(11952),r=H(11712),Y=H(12192),f=H(12194),w=H(11946);const s=1e-6,p=new h.XE(.04,.04,.04),o=1024,y=h.XE.White(),b=h.XE.Black();function K(e,E,H){if(E<p.r)return 0;const N=p.r,u=e*H/(1-p.r)+E-2*p.r,z=u*u-4*N*(p.r-E);return a.Clamp((-u+Math.sqrt(z))/(2*N),0,1)}function l(e){const E=e.diffuseColor.toLinearSpace(e.fe().getEngine().useExactSrgbConversions).scale(.5),H=e.alpha,u=function(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new N.Vector2(0,1),H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new N.Vector2(0,.1),u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new N.Vector2(0,.1),z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new N.Vector2(1300,.1);return function(e,E,H,N,u){return(1-e)*(1-e)*(1-e)*E+3*(1-e)*(1-e)*e*H+3*(1-e)*e*e*N+e*e*e*u}(Math.pow(e/z.x,.333333),E.y,H.y,u.y,z.y)}(a.Clamp(e.specularPower,0,o));return{baseColorFactor:[E.r,E.g,E.b,H],metallicFactor:0,roughnessFactor:u}}function O(e,E){E.needAlphaBlending()?e.alphaMode="BLEND":E.needAlphaTesting()&&(e.alphaMode="MASK",e.alphaCutoff=E.alphaCutOff)}function v(e,E,H){const N=new Uint8Array(e*E*4);for(let u=0;u<N.length;u+=4)N[u]=N[u+1]=N[u+2]=N[u+3]=255;return Y.e.CreateRGBATexture(N,e,E,H)}function R(e){if(e instanceof Uint8Array){const E=e.length,H=new Float32Array(e.length);for(let N=0;N<E;++N)H[N]=e[N]/255;return H}if(e instanceof Float32Array)return e;throw new Error("Unsupported pixel format!")}class T{constructor(e){this._exporter=e,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(e){return e?this._textureMap.get(e)??null:null}async exportStandardMaterialAsync(e,E,H){const N=l(e),z={name:e.name};if(null==e.iM||e.iM||(e.twoSidedLighting||u.Tools.Warn(e.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),z.doubleSided=!0),H){const H=[],u=e.diffuseTexture;u&&H.push(this.exportTextureAsync(u,E).then((e=>{e&&(N.baseColorTexture=e)})));const P=e.bumpTexture;P&&H.push(this.exportTextureAsync(P,E).then((e=>{e&&(z.normalTexture=e,1!==P.level&&(z.normalTexture.scale=P.level))})));const M=e.emissiveTexture;M&&(z.emissiveFactor=[1,1,1],H.push(this.exportTextureAsync(M,E).then((e=>{e&&(z.emissiveTexture=e)}))));const D=e.ambientTexture;D&&H.push(this.exportTextureAsync(D,E).then((e=>{if(e){const E={index:e.index};z.occlusionTexture=E}}))),H.length>0&&(this._exporter._materialNeedsUVsSet.add(e),await Promise.all(H))}(e.alpha<1||e.opacityTexture)&&(e.alphaMode===f.d.ALPHA_COMBINE?z.alphaMode="BLEND":u.Tools.Warn(e.name+": glTF 2.0 does not support alpha mode: "+e.alphaMode.toString())),e.emissiveColor&&!e.emissiveColor.equalsWithEpsilon(b,s)&&(z.emissiveFactor=e.emissiveColor.uM()),z.pbrMetallicRoughness=N,O(z,e),await this._finishMaterialAsync(z,e,E);const P=this._exporter._materials;return P.push(z),P.length-1}async _finishMaterialAsync(e,E,H){const N=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",e,E),u=[];for(const z of N)u.push(this.exportTextureAsync(z,H));await Promise.all(u),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",e,E)}async _getImageDataAsync(e,E,N,u){const z=f.d.TEXTURETYPE_UNSIGNED_BYTE,P=this._exporter._babylonScene,M=P.getEngine(),D=M.createRawTexture(e,E,N,f.d.TEXTUREFORMAT_RGBA,!1,!0,r.b.NEAREST_SAMPLINGMODE,null,z);M.isWebGPU?await H.e(51).then(H.bind(H,14163)):await H.e(52).then(H.bind(H,14168)),await W.i.ApplyPostProcess("pass",D,P,z,f.d.TEXTURE_NEAREST_SAMPLINGMODE,f.d.TEXTUREFORMAT_RGBA);const A=await M._readTexturePixels(D,E,N);return await w.DumpTools.DumpDataAsync(E,N,A,u,void 0,!0,!0)}_resizeTexturesToSameDimensions(e,E,H){const N=e?e.getSize():{width:0,height:0},u=E?E.getSize():{width:0,height:0};let z,P;return N.width<u.width?(z=e&&e instanceof r.b?W.i.CreateResizedCopy(e,u.width,u.height,!0):v(u.width,u.height,H),P=E):N.width>u.width?(P=E&&E instanceof r.b?W.i.CreateResizedCopy(E,N.width,N.height,!0):v(N.width,N.height,H),z=e):(z=e,P=E),{texture1:z,texture2:P}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(e,E,H,N){const u=new Array;if(!e&&!E)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const z=e?e.fe():E?E.fe():null;if(z){var P;const M=this._resizeTexturesToSameDimensions(e,E,z),D=null===(P=M.texture1)||void 0===P?void 0:P.getSize();let A,C;const i=D.width,V=D.height,U=await M.texture1.readPixels(),j=await M.texture2.readPixels();if(!U)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(A=R(U),!j)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");C=R(j);const F=C.byteLength,S=new Uint8Array(F),X=new Uint8Array(F),a=4,W=b;let r=0,Y=0;for(let e=0;e<V;++e)for(let E=0;E<i;++E){const N=(i*e+E)*a,u={diffuseColor:new h.XE(A[N],A[N+1],A[N+2]).toLinearSpace(z.getEngine().useExactSrgbConversions).multiply(H.diffuseColor),specularColor:new h.XE(C[N],C[N+1],C[N+2]).toLinearSpace(z.getEngine().useExactSrgbConversions).multiply(H.specularColor),glossiness:C[N+3]*H.glossiness},P=this._convertSpecularGlossinessToMetallicRoughness(u);W.r=Math.max(W.r,P.baseColor.r),W.g=Math.max(W.g,P.baseColor.g),W.b=Math.max(W.b,P.baseColor.b),r=Math.max(r,P.metallic),Y=Math.max(Y,P.roughness),X[N]=255*P.baseColor.r,X[N+1]=255*P.baseColor.g,X[N+2]=255*P.baseColor.b,X[N+3]=M.texture1.zM?255*A[N+3]:255,S[N]=0,S[N+1]=255*P.roughness,S[N+2]=255*P.metallic,S[N+3]=255}const f={baseColor:W,metallic:r,roughness:Y};let w=!1,p=!1;for(let e=0;e<V;++e)for(let E=0;E<i;++E){const H=(i*e+E)*a;X[H]/=f.baseColor.r>s?f.baseColor.r:1,X[H+1]/=f.baseColor.g>s?f.baseColor.g:1,X[H+2]/=f.baseColor.b>s?f.baseColor.b:1;const N=h.XE.FromInts(X[H],X[H+1],X[H+2]).toGammaSpace(z.getEngine().useExactSrgbConversions);X[H]=255*N.r,X[H+1]=255*N.g,X[H+2]=255*N.b,N.equalsWithEpsilon(y,s)||(p=!0),S[H+1]/=f.roughness>s?f.roughness:1,S[H+2]/=f.metallic>s?f.metallic:1;h.XE.FromInts(255,S[H+1],S[H+2]).equalsWithEpsilon(y,s)||(w=!0)}return w&&u.push(this._getImageDataAsync(S,i,V,N).then((e=>{f.metallicRoughnessTextureData=e}))),p&&u.push(this._getImageDataAsync(X,i,V,N).then((e=>{f.baseColorTextureData=e}))),await Promise.all(u).then((()=>f))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(e){const E=this._getPerceivedBrightness(e.diffuseColor),H=this._getPerceivedBrightness(e.specularColor),N=1-this._getMaxComponent(e.specularColor),u=K(E,H,N),z=e.diffuseColor.scale(N/(1-p.r)/Math.max(1-u)),P=e.specularColor.FE(p.scale(1-u)).scale(1/Math.max(u));let M=h.XE.Lerp(z,P,u*u);M=M.clampToRef(0,1,M);return{baseColor:M,metallic:u,roughness:1-e.glossiness}}_getPerceivedBrightness(e){return e?Math.sqrt(.299*e.r*e.r+.587*e.g*e.g+.114*e.b*e.b):0}_getMaxComponent(e){return e?Math.max(e.r,Math.max(e.g,e.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(e,E,H,N){const u=[],z={baseColor:e._albedoColor,metallic:e._metallic,roughness:e._roughness};if(N){e._albedoTexture&&u.push(this.exportTextureAsync(e._albedoTexture,E).then((e=>{e&&(H.baseColorTexture=e)})));const N=e._metallicTexture;N&&u.push(this.exportTextureAsync(N,E).then((e=>{e&&(H.metallicRoughnessTexture=e)})))}return u.length>0&&(this._exporter._materialNeedsUVsSet.add(e),await Promise.all(u)),z}_getTextureSampler(e){const E={};if(!e||!(e instanceof r.b))return E;const H=this._getGLTFTextureWrapMode(e.wrapU);10497!==H&&(E.wrapS=H);const N=this._getGLTFTextureWrapMode(e.wrapV);switch(10497!==N&&(E.wrapT=N),e.samplingMode){case r.b.LINEAR_LINEAR:E.magFilter=9729,E.minFilter=9729;break;case r.b.LINEAR_NEAREST:E.magFilter=9729,E.minFilter=9728;break;case r.b.NEAREST_LINEAR:E.magFilter=9728,E.minFilter=9729;break;case r.b.NEAREST_LINEAR_MIPLINEAR:E.magFilter=9728,E.minFilter=9987;break;case r.b.NEAREST_NEAREST:E.magFilter=9728,E.minFilter=9728;break;case r.b.NEAREST_LINEAR_MIPNEAREST:E.magFilter=9728,E.minFilter=9985;break;case r.b.LINEAR_NEAREST_MIPNEAREST:E.magFilter=9729,E.minFilter=9984;break;case r.b.LINEAR_NEAREST_MIPLINEAR:E.magFilter=9729,E.minFilter=9986;break;case r.b.NEAREST_NEAREST_MIPLINEAR:E.magFilter=9728,E.minFilter=9986;break;case r.b.LINEAR_LINEAR_MIPLINEAR:E.magFilter=9729,E.minFilter=9987;break;case r.b.LINEAR_LINEAR_MIPNEAREST:E.magFilter=9729,E.minFilter=9985;break;case r.b.NEAREST_NEAREST_MIPNEAREST:E.magFilter=9728,E.minFilter=9984}return E}_getGLTFTextureWrapMode(e){switch(e){case r.b.WRAP_ADDRESSMODE:return 10497;case r.b.CLAMP_ADDRESSMODE:return 33071;case r.b.MIRROR_ADDRESSMODE:return 33648;default:return u.Tools.Error(`Unsupported Texture Wrap Mode ${e}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(e,E,H,N){const u={diffuseColor:e._albedoColor,specularColor:e._reflectivityColor,glossiness:e._microSurface},z=e._albedoTexture,P=e._reflectivityTexture,M=e._useMicroSurfaceFromReflectivityMapAlpha;if(P&&!M)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((z||P)&&N){this._exporter._materialNeedsUVsSet.add(e);const N=this._exportTextureSampler(z||P),M=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(z,P,u,E),D=this._exporter._textures;if(M.baseColorTextureData){const e=this._exportImage(`baseColor${D.length}`,E,M.baseColorTextureData);H.baseColorTexture=this._exportTextureInfo(e,N,null===z||void 0===z?void 0:z.coordinatesIndex)}if(M.metallicRoughnessTextureData){const e=this._exportImage(`metallicRoughness${D.length}`,E,M.metallicRoughnessTextureData);H.metallicRoughnessTexture=this._exportTextureInfo(e,N,null===P||void 0===P?void 0:P.coordinatesIndex)}return M}return this._convertSpecularGlossinessToMetallicRoughness(u)}async exportPBRMaterialAsync(e,E,H){const N={},u={name:e.name},z=e.isMetallicWorkflow();if(z){const E=e._albedoColor,H=e.alpha;E&&(N.baseColorFactor=[E.r,E.g,E.b,H])}const P=z?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(e,E,N,H):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(e,E,N,H);await this._setMetallicRoughnessPbrMaterialAsync(P,e,u,N,E,H),await this._finishMaterialAsync(u,e,E);const M=this._exporter._materials;return M.push(u),M.length-1}async _setMetallicRoughnessPbrMaterialAsync(e,E,H,N,z,P){if(O(H,E),e.baseColor.equalsWithEpsilon(y,s)&&a.WithinEpsilon(E.alpha,1,s)||(N.baseColorFactor=[e.baseColor.r,e.baseColor.g,e.baseColor.b,E.alpha]),null!=e.metallic&&1!==e.metallic&&(N.metallicFactor=e.metallic),null!=e.roughness&&1!==e.roughness&&(N.roughnessFactor=e.roughness),null==E.iM||E.iM||(E._twoSidedLighting||u.Tools.Warn(E.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),H.doubleSided=!0),P){const e=[],N=E._bumpTexture;N&&e.push(this.exportTextureAsync(N,z).then((e=>{e&&(H.normalTexture=e,1!==N.level&&(H.normalTexture.scale=N.level))})));const u=E._ambientTexture;u&&e.push(this.exportTextureAsync(u,z).then((e=>{if(e){const N={index:e.index,texCoord:e.texCoord,extensions:e.extensions};H.occlusionTexture=N;const u=E._ambientTextureStrength;u&&(N.strength=u)}})));const P=E._emissiveTexture;P&&e.push(this.exportTextureAsync(P,z).then((e=>{e&&(H.emissiveTexture=e)}))),e.length>0&&(this._exporter._materialNeedsUVsSet.add(E),await Promise.all(e))}const M=E._emissiveColor;M.equalsWithEpsilon(b,s)||(H.emissiveFactor=M.uM()),H.pbrMetallicRoughness=N}_getPixelsFromTextureAsync(e){return function(e){switch(e){case f.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case f.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case f.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case f.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case f.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case f.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case f.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case f.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case f.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case f.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case f.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case f.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case f.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case f.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case f.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case f.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case f.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case f.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case f.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case f.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case f.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(e.textureFormat)?(0,W.g)(e,e._texture.width,e._texture.height):(e.textureType,f.d.TEXTURETYPE_UNSIGNED_BYTE,e.readPixels())}async exportTextureAsync(e,E){const H=this._exporter._extensionsPreExportTextureAsync("exporter",e,E);return H?await H.then((async H=>H?await this._exportTextureInfoAsync(H,E):await this._exportTextureInfoAsync(e,E))):await this._exportTextureInfoAsync(e,E)}async _exportTextureInfoAsync(e,E){let H=this._textureMap.get(e);if(!H){const N=await this._getPixelsFromTextureAsync(e);if(!N)return null;const z=this._exportTextureSampler(e),P=e.mimeType;if(P)switch(P){case"image/jpeg":case"image/png":case"image/webp":E=P;break;default:u.Tools.Warn(`Unsupported media type: ${P}. Exporting texture as PNG.`)}const M=this._internalTextureToImage,D=e.getInternalTexture().uniqueId;M[D]||(M[D]={});let A=M[D][E];if(void 0===A){const H=e.getSize();A=(async()=>{const u=await this._getImageDataAsync(N,H.width,H.height,E);return this._exportImage(e.name,E,u)})(),M[D][E]=A}H=this._exportTextureInfo(await A,z,e.coordinatesIndex),this._textureMap.set(e,H),this._exporter._extensionsPostExportTextures("exporter",H,e)}return H}_exportImage(e,E,H){const N=this._exporter._images;let z;if(this._exporter._shouldUseGlb){z={name:e,mimeType:E,bufferView:void 0};const N=this._exporter._bufferManager.createBufferView(new Uint8Array(H));this._exporter._bufferManager.setBufferView(z,N)}else{const P=e.replace(/\.\/|\/|\.\\|\\/g,"_"),M=function(e){switch(e){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(E);let D=P+M;N.some((e=>e.uri===D))&&(D=`${P}_${u.Tools.RandomId()}${M}`),z={name:e,uri:D},this._exporter._imageData[D]={data:H,mimeType:E}}return N.push(z),N.length-1}_exportTextureInfo(e,E,H){const N=this._exporter._textures;let u=N.findIndex((H=>H.sampler==E&&H.source===e));-1===u&&(u=N.length,N.push({source:e,sampler:E}));const z={index:u};return H&&(z.texCoord=H),z}_exportTextureSampler(e){const E=this._getTextureSampler(e),H=this._exporter._samplers,N=H.findIndex((e=>e.minFilter===E.minFilter&&e.magFilter===E.magFilter&&e.wrapS===E.wrapS&&e.wrapT===E.wrapT));return-1!==N?N:(H.push(E),H.length-1)}}var L=H(11824),d=H(11548),G=H(12199),me=H(11746);const Q=N.jE.Zero(),Z=N.Quaternion.Identity(),k=N.jE.One(),J=new N.jE(-1,1,1);function B(e,E){const{byteOffset:H,byteStride:N,type:u,normalized:z}=e,P=e.getSize(),M=E.reduce(((e,E)=>E.getTotalVertices()>e?E.getTotalVertices():e),-Number.MAX_VALUE);return{byteOffset:H,byteStride:N,componentCount:P,type:u,count:M*P,normalized:z,totalVertices:M,kind:e.getKind()}}function I(e){switch(e){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function t(e){switch(e){case C.g.PositionKind:case C.g.NormalKind:case C.g.TangentKind:case C.g.ColorKind:case C.g.MatricesIndicesKind:case C.g.MatricesIndicesExtraKind:case C.g.MatricesWeightsKind:case C.g.MatricesWeightsExtraKind:case C.g.UVKind:case C.g.UV2Kind:case C.g.UV3Kind:case C.g.UV4Kind:case C.g.UV5Kind:case C.g.UV6Kind:return!0}return!1}function q(e){switch(e){case z.e.TriangleFillMode:return 4;case z.e.TriangleStripDrawMode:return 5;case z.e.TriangleFanDrawMode:return 6;case z.e.PointListDrawMode:case z.e.PointFillMode:return 0;case z.e.LineLoopDrawMode:return 2;case z.e.LineListDrawMode:return 1;case z.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${e}`)}function c(e){const E=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z);E>0&&(e.x/=E,e.y/=E,e.z/=E)}function n(e){return e.x*=-1,e}function g(e){if(e.x*e.x+e.y*e.y>.5){const E=Math.abs(e.x),H=Math.abs(e.y);if(E>H){const H=Math.sign(e.x);e.x=E,e.y*=-H,e.z*=-H,e.w*=H}else{const E=Math.sign(e.y);e.x*=-E,e.y=H,e.z*=E,e.w*=-E}}else{const E=Math.abs(e.z),H=Math.abs(e.w);if(E>H){const H=Math.sign(e.z);e.x*=-H,e.y*=H,e.z=E,e.w*=-H}else{const E=Math.sign(e.w);e.x*=E,e.y*=-E,e.z*=-E,e.w=H}}return e}function x(e){e.VM(-e.z,e.w,e.x,-e.y)}function ee(e,E){const H=N.jE.FromArrayToRef(E.translation||[0,0,0],0,N.TmpVectors.jE[0]),u=N.Quaternion.FromArrayToRef(E.rotation||[0,0,0,1],0,N.TmpVectors.Quaternion[0]),z=N.Matrix.ComposeToRef(k,u,H,N.TmpVectors.Matrix[0]),P=N.jE.FromArrayToRef(e.translation||[0,0,0],0,N.TmpVectors.jE[2]),M=N.Quaternion.FromArrayToRef(e.rotation||[0,0,0,1],0,N.TmpVectors.Quaternion[1]),D=N.Matrix.ComposeToRef(k,M,P,N.TmpVectors.Matrix[1]);z.multiplyToRef(D,D),D.decompose(void 0,u,H),H.equalsWithEpsilon(Q,me.d)?delete E.translation:E.translation=H.uM(),u.equalsWithEpsilon(Z,me.d)?delete E.rotation:E.rotation=u.uM(),E.scale&&delete E.scale}function Ee(e,E){if(!(E instanceof i.d))return!1;if(!(1===E.getChildren().length&&0===e.getChildren().length&&e.parent===E))return!1;const H=e.fe(),N=e instanceof G.d&&!H.useRightHandedSystem?J:k;return!!E.UM.equalsWithEpsilon(N,me.d)||(d.d.Warn(`Cannot collapse node ${e.name} into parent node ${E.name} with modified scaling.`),!1)}function He(e){if(e instanceof Array){const E=new Float32Array(e);return new Uint8Array(E.buffer,E.byteOffset,E.byteLength)}return ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):new Uint8Array(e)}function Ne(e,E){for(const[H,N]of Object.entries(e)){const u=E[H];(Array.isArray(N)&&Array.isArray(u)&&ue(N,u)||N===u)&&delete e[H]}return e}function ue(e,E){return e.length===E.length&&e.every(((e,H)=>e===E[H]))}const ze=N.Matrix.Compose(new N.jE(-1,1,1),N.Quaternion.Identity(),N.jE.Zero());function Pe(e,E){if(!(e instanceof i.d))return!1;if(E){if(!e.getWorldMatrix().equalsWithEpsilon(N.Matrix.IdentityReadOnly,me.d))return!1}else{if(!e.getWorldMatrix().multiplyToRef(ze,N.TmpVectors.Matrix[0]).equalsWithEpsilon(N.Matrix.IdentityReadOnly,me.d))return!1}return!(e instanceof V.d&&e.AM)}const Me=new Map([[Int8Array,(e,E,H)=>e.setInt8(E,H)],[Uint8Array,(e,E,H)=>e.setUint8(E,H)],[Uint8ClampedArray,(e,E,H)=>e.setUint8(E,H)],[Int16Array,(e,E,H)=>e.setInt16(E,H,!0)],[Uint16Array,(e,E,H)=>e.setUint16(E,H,!0)],[Int32Array,(e,E,H)=>e.setInt32(E,H,!0)],[Uint32Array,(e,E,H)=>e.setUint32(E,H,!0)],[Float32Array,(e,E,H)=>e.setFloat32(E,H,!0)],[Float64Array,(e,E,H)=>e.setFloat64(E,H,!0)]]);class De{writeTypedArray(e){this._checkGrowBuffer(e.byteLength);const E=Me.get(e.constructor);for(let H=0;H<e.length;H++)E(this._dataView,this._byteOffset,e[H]),this._byteOffset+=e.BYTES_PER_ELEMENT}constructor(e){this._data=new Uint8Array(e),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(e){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,e),this._byteOffset++}writeInt8(e){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,e),this._byteOffset++}writeInt16(e){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,e,!0),this._byteOffset+=2}writeUInt16(e){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,e,!0),this._byteOffset+=2}writeInt32(e){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,e,!0),this._byteOffset+=4}writeUInt32(e){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,e,!0),this._byteOffset+=4}writeFloat32(e){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,e,!0),this._byteOffset+=4}writeFloat64(e){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,e,!0),this._byteOffset+=8}_checkGrowBuffer(e){const E=this.byteOffset+e;if(E>this._data.byteLength){const e=new Uint8Array(2*E);e.set(this._data),this._data=e,this._dataView=new DataView(this._data.buffer)}}}function Ae(e){return e%4===0?4:e%2===0?2:1}class Ce{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(e){let E=0;this._bufferViewToData.forEach((e=>{E+=e.byteLength}));const H=new De(E),N=Array.from(this._bufferViewToData.keys()).sort(((e,E)=>Ae(E.byteLength)-Ae(e.byteLength)));for(const u of N){u.byteOffset=H.byteOffset,e.push(u);const E=e.length-1,N=this.getPropertiesWithBufferView(u);for(const e of N)e.bufferView=E;H.writeTypedArray(this._bufferViewToData.get(u)),this._bufferViewToData.delete(u)}return H.getOutputData()}createBufferView(e,E){const H={buffer:0,byteOffset:void 0,byteLength:e.byteLength,byteStride:E};return this._bufferViewToData.set(H,e),H}createAccessor(e,E,H,N,u,z,P){this._verifyBufferView(e);const M={bufferView:void 0,componentType:H,count:N,type:E,min:null===z||void 0===z?void 0:z.min,max:null===z||void 0===z?void 0:z.max,normalized:P,byteOffset:u};return this.setBufferView(M,e),this._accessorToBufferView.set(M,e),M}setBufferView(e,E){this._verifyBufferView(E);this.getPropertiesWithBufferView(E).push(e)}removeBufferView(e){const E=this.getPropertiesWithBufferView(e);for(const H of E)void 0!==H.bufferView&&delete H.bufferView;this._bufferViewToData.delete(e),this._bufferViewToProperties.delete(e),this._accessorToBufferView.forEach(((E,H)=>{E===e&&(void 0!==H.byteOffset&&delete H.byteOffset,this._accessorToBufferView.delete(H))}))}getBufferView(e){const E=this._accessorToBufferView.get(e);return this._verifyBufferView(E),E}getPropertiesWithBufferView(e){return this._verifyBufferView(e),this._bufferViewToProperties.set(e,this._bufferViewToProperties.get(e)??[]),this._bufferViewToProperties.get(e)}getData(e){return this._verifyBufferView(e),this._bufferViewToData.get(e)}_verifyBufferView(e){if(void 0===e||!this._bufferViewToData.has(e))throw new Error(`BufferView ${e} not found in BufferManager.`)}}var ie,Ve=H(12168),Ue=H(12190),je=H(12207),Fe=H(12094),he=H(12235),Se=H(12250),Xe=H(12165),ae=H(12256);!function(e){e[e.INTANGENT=0]="INTANGENT",e[e.OUTTANGENT=1]="OUTTANGENT"}(ie||(ie={}));class We{static _IsTransformable(e){return e&&(e instanceof i.d||e instanceof Ve.c||e instanceof ae.b)}static _CreateNodeAnimation(e,E,H,N,z){if(this._IsTransformable(e)){const P=[],M=[],D=E.getKeys(),A=We._CalculateMinMaxKeyFrames(D),C=We._DeduceInterpolation(D,H,N),i=C.interpolationType,V=C.shouldBakeAnimation;if(V?We._CreateBakedAnimation(e,E,H,A.min,A.max,E.framePerSecond,z,P,M,A,N):"LINEAR"===i||"STEP"===i?We._CreateLinearOrStepAnimation(e,E,H,P,M,N):"CUBICSPLINE"===i?We._CreateCubicSplineAnimation(e,E,H,P,M,N):We._CreateBakedAnimation(e,E,H,A.min,A.max,E.framePerSecond,z,P,M,A,N),P.length&&M.length){return{inputs:P,outputs:M,samplerInterpolation:i,inputsMin:V?A.min:u.Tools.FloatRound(A.min/E.framePerSecond),inputsMax:V?A.max:u.Tools.FloatRound(A.max/E.framePerSecond)}}}return null}static _DeduceAnimationInfo(e){let E=null,H="VEC3",N=!1;const z=e.targetProperty.split(".");switch(z[0]){case"UM":E="scale";break;case"position":E="translation";break;case"rotation":H="VEC4",E="rotation";break;case"rotationQuaternion":H="VEC4",N=!0,E="rotation";break;case"influence":H="SCALAR",E="weights";break;default:u.Tools.Error(`Unsupported animatable property ${z[0]}`)}return E?{animationChannelTargetPath:E,dataAccessorType:H,useQuaternion:N}:(u.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(e,E,H,N,u,z,P,M,D,A,C){let i;if(We._IsTransformable(e)&&e.animations)for(const V of e.animations){if(C&&!C(V))continue;const u=We._DeduceAnimationInfo(V);u&&(i={name:V.name,samplers:[],channels:[]},We._AddAnimation(`${V.name}`,V.hasRunningRuntimeAnimations?E:i,e,V,u.dataAccessorType,u.animationChannelTargetPath,N,z,P,M,u.useQuaternion,D,A),i.samplers.length&&i.channels.length&&H.push(i))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(e,E,H,N,u,z,P,M,D,A,C){let i;if(e instanceof Xe.c){const u=e.morphTargetManager;if(u)for(let V=0;V<u.numTargets;++V){const U=u.getTarget(V);for(const j of U.animations){if(C&&!C(j))continue;const U=new he.b(`${j.name}`,"influence",j.framePerSecond,j.dataType,j.loopMode,j.enableBlending),F=[],h=j.getKeys();for(let e=0;e<h.length;++e){const E=h[e];for(let e=0;e<u.numTargets;++e)e==V?F.push(E):F.push({frame:E.frame,value:0})}U.setKeys(F);const S=We._DeduceAnimationInfo(U);S&&(i={name:U.name,samplers:[],channels:[]},We._AddAnimation(j.name,j.hasRunningRuntimeAnimations?E:i,e,U,S.dataAccessorType,S.animationChannelTargetPath,N,z,P,M,S.useQuaternion,D,A,u.numTargets),i.samplers.length&&i.channels.length&&H.push(i))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(e,E,H,N,u,z,P,M,D){let A;if(e.animationGroups){const i=e.animationGroups;for(const V of i){const i=new Map,U=new Map,j=new Set,F=V.to-V.from;A={name:V.name,channels:[],samplers:[]};for(let E=0;E<V.targetedAnimations.length;++E){const F=V.targetedAnimations[E],h=F.target,S=F.animation;if(D&&!D(S))continue;const X=M.has(h);if(this._IsTransformable(h)||1===h.length&&this._IsTransformable(h[0])){const e=We._DeduceAnimationInfo(F.animation);if(e){const E=this._IsTransformable(h)?h:this._IsTransformable(h[0])?h[0]:null;E&&We._AddAnimation(`${S.name}`,A,E,S,e.dataAccessorType,e.animationChannelTargetPath,H,N,u,z,e.useQuaternion,P,X)}}else if(h instanceof Se.d||1===h.length&&h[0]instanceof Se.d){if(We._DeduceAnimationInfo(F.animation)){const E=h instanceof Se.d?h:h[0];if(E){const H=e.morphTargetManagers.find((e=>{for(let H=0;H<e.numTargets;++H)if(e.getTarget(H)===E)return!0;return!1}));if(H){const N=e.meshes.find((e=>e.morphTargetManager===H));var C;if(N)i.has(N)||i.set(N,new Map),null===(C=i.get(N))||void 0===C||C.set(E,S),j.add(N),U.set(N,S)}}}}}j.forEach((e=>{const E=e.morphTargetManager;let M=null;const D=[],C=U.get(e).getKeys(),j=C.length;for(let H=0;H<j;++H)for(let N=0;N<E.numTargets;++N){const u=E.getTarget(N),z=i.get(e);if(z){const E=z.get(u);E?(M||(M=new he.b(`${V.name}_${e.name}_MorphWeightAnimation`,"influence",E.framePerSecond,he.b.ANIMATIONTYPE_FLOAT,E.loopMode,E.enableBlending)),D.push(E.getKeys()[H])):D.push({frame:V.from+F/j*H,value:u.influence,inTangent:C[0].inTangent?0:void 0,outTangent:C[0].outTangent?0:void 0})}}M.setKeys(D);const h=We._DeduceAnimationInfo(M);h&&We._AddAnimation(`${V.name}_${e.name}_MorphWeightAnimation`,A,e,M,h.dataAccessorType,h.animationChannelTargetPath,H,N,u,z,h.useQuaternion,P,!1,null===E||void 0===E?void 0:E.numTargets)})),A.channels.length&&A.samplers.length&&E.push(A)}}}static _AddAnimation(e,E,H,u,z,P,M,D,A,C,i,V,U,j){const F=We._CreateNodeAnimation(H,u,P,i,V);let h,S,X,a,W,r;if(F){if(j){let e=0,E=0;const H=[];for(;F.inputs.length>0;)E=F.inputs.shift(),e%j==0&&H.push(E),e++;F.inputs=H}const e=M.get(H),u=new Float32Array(F.inputs);h=D.createBufferView(u),S=D.createAccessor(h,"SCALAR",5126,F.inputs.length,void 0,{min:[F.inputsMin],max:[F.inputsMax]}),C.push(S),X=C.length-1;const A=new N.Quaternion,i=new N.jE,V=new N.jE,Y=H instanceof Ve.c,f=I(z),w=new Float32Array(F.outputs.length*f);F.outputs.forEach((function(e,E){let H=e;switch(P){case"translation":U&&(N.jE.FromArrayToRef(e,0,V),n(V),V.toArray(H));break;case"rotation":4===e.length?N.Quaternion.FromArrayToRef(e,0,A):(H=new Array(4),N.jE.FromArrayToRef(e,0,i),N.Quaternion.FromEulerVectorToRef(i,A)),U&&(g(A),Y&&x(A)),A.toArray(H)}w.set(H,E*f)})),h=D.createBufferView(w),S=D.createAccessor(h,z,5126,F.outputs.length),C.push(S),a=C.length-1,W={interpolation:F.samplerInterpolation,input:X,output:a},E.samplers.push(W),r={sampler:E.samplers.length-1,target:{node:e,path:P}},E.channels.push(r)}}static _CreateBakedAnimation(e,E,H,z,P,M,D,A,C,i,V){let U;const j=N.Quaternion.Identity();let F,h=null,S=null,X=null,a=null,W=null,r=null;i.min=u.Tools.FloatRound(z/M);const Y=E.getKeys();for(let N=0,f=Y.length;N<f;++N){if(r=null,X=Y[N],N+1<f)if(a=Y[N+1],X.value.equals&&X.value.equals(a.value)||X.value===a.value){if(0!==N)continue;r=X.frame}else r=a.frame;else{if(W=Y[N-1],X.value.equals&&X.value.equals(W.value)||X.value===W.value)continue;r=P}if(r)for(let N=X.frame;N<=r;N+=D){if(F=u.Tools.FloatRound(N/M),F===h)continue;h=F,S=F;const z={key:0,repeatCount:0,loopMode:E.loopMode};U=E._interpolate(N,z),We._SetInterpolatedValue(e,U,F,E,H,j,A,C,V)}}S&&(i.max=S)}static _ConvertFactorToVector3OrQuaternion(e,E,H,z,P){const M=We._GetBasePositionRotationOrScale(E,z,P),D=H.targetProperty.split("."),A=D?D[1]:"",C=P?N.Quaternion.aE(M).normalize():N.jE.aE(M);switch(A){case"x":case"y":case"z":C[A]=e;break;case"w":C.w=e;break;default:u.Tools.Error(`glTFAnimation: Unsupported component name "${A}"!`)}return C}static _SetInterpolatedValue(e,E,H,u,z,P,M,D,A){let C;M.push(H),"weights"!==z?(u.dataType===he.b.ANIMATIONTYPE_FLOAT&&(E=this._ConvertFactorToVector3OrQuaternion(E,e,u,z,A)),"rotation"===z?(A?P=E:(C=E,N.Quaternion.RotationYawPitchRollToRef(C.y,C.x,C.z,P)),D.push(P.uM())):(C=E,D.push(C.uM()))):D.push([E])}static _CreateLinearOrStepAnimation(e,E,H,N,u,z){for(const P of E.getKeys())N.push(P.frame/E.framePerSecond),We._AddKeyframeValue(P,E,u,H,e,z)}static _CreateCubicSplineAnimation(e,E,H,N,u,z){E.getKeys().forEach((function(P){N.push(P.frame/E.framePerSecond),We._AddSplineTangent(ie.INTANGENT,u,H,"CUBICSPLINE",P,z),We._AddKeyframeValue(P,E,u,H,e,z),We._AddSplineTangent(ie.OUTTANGENT,u,H,"CUBICSPLINE",P,z)}))}static _GetBasePositionRotationOrScale(e,E,H){let u;if("rotation"===E)if(H){u=(e.rotationQuaternion??N.Quaternion.Identity()).uM()}else{u=(e.rotation??N.jE.Zero()).uM()}else if("translation"===E){u=(e.position??N.jE.Zero()).uM()}else{u=(e.UM??N.jE.One()).uM()}return u}static _AddKeyframeValue(e,E,H,z,P,M){let D;const A=E.dataType;if(A===he.b.ANIMATIONTYPE_VECTOR3){let E=e.value.uM();if("rotation"===z){const e=N.jE.aE(E);E=N.Quaternion.RotationYawPitchRoll(e.y,e.x,e.z).uM()}H.push(E)}else if(A===he.b.ANIMATIONTYPE_FLOAT){if("weights"===z)H.push([e.value]);else if(D=this._ConvertFactorToVector3OrQuaternion(e.value,P,E,z,M),D){if("rotation"===z){const e=M?D:N.Quaternion.RotationYawPitchRoll(D.y,D.x,D.z).normalize();H.push(e.uM())}H.push(D.uM())}}else A===he.b.ANIMATIONTYPE_QUATERNION?H.push(e.value.normalize().uM()):u.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(e,E,H){let N,u,z=!1;if("rotation"===E&&!H)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let P=0,M=e.length;P<M;++P)if(u=e[P],u.inTangent||u.outTangent)if(N){if("CUBICSPLINE"!==N){N="LINEAR",z=!0;break}}else N="CUBICSPLINE";else if(N){if("CUBICSPLINE"===N||u.interpolation&&1===u.interpolation&&"STEP"!==N){N="LINEAR",z=!0;break}}else N=u.interpolation&&1===u.interpolation?"STEP":"LINEAR";return N||(N="LINEAR"),{interpolationType:N,shouldBakeAnimation:z}}static _AddSplineTangent(e,E,H,u,z,P){let M;const D=e===ie.INTANGENT?z.inTangent:z.outTangent;if("CUBICSPLINE"===u){if("rotation"===H)if(D)if(P)M=D.uM();else{const e=D;M=N.Quaternion.RotationYawPitchRoll(e.y,e.x,e.z).uM()}else M=[0,0,0,0];else M="weights"===H?D?[D]:[0]:D?D.uM():[0,0,0];E.push(M)}}static _CalculateMinMaxKeyFrames(e){let E=1/0,H=-1/0;return e.forEach((function(e){E=Math.min(E,e.frame),H=Math.max(H,e.frame)})),{min:E,max:H}}}function re(e,E,H,z,P,M){const D={attributes:{},influence:e.influence,name:e.name},A=E.AM;if(!A)return u.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),D;const i=M?-1:1,V=N.jE.Zero();let U=0,j=0;if(e.hasPositions){const z=e.getPositions(),M=A.getVerticesData(C.g.PositionKind);if(M){const e=new Float32Array(M.length),E=[1/0,1/0,1/0],u=[-1/0,-1/0,-1/0];j=M.length/3,U=0;for(let H=U;H<j;++H){const P=N.jE.aE(M,3*H);N.jE.aE(z,3*H).subtractToRef(P,V),V.x*=i,E[0]=Math.min(E[0],V.x),u[0]=Math.max(u[0],V.x),E[1]=Math.min(E[1],V.y),u[1]=Math.max(u[1],V.y),E[2]=Math.min(E[2],V.z),u[2]=Math.max(u[2],V.z),e[3*H]=V.x,e[3*H+1]=V.y,e[3*H+2]=V.z}const A=H.createBufferView(e,12),C=H.createAccessor(A,"VEC3",5126,z.length/3,0,{min:E,max:u});P.push(C),D.attributes.POSITION=P.length-1}else u.Tools.Warn(`Morph target positions for mesh ${E.name} were not exported. Mesh does not have position vertex data`)}if(e.hasNormals){const z=e.getNormals(),M=A.getVerticesData(C.g.NormalKind);if(M){const e=new Float32Array(M.length);j=M.length/3,U=0;for(let H=U;H<j;++H){const E=N.jE.aE(M,3*H).normalize();N.jE.aE(z,3*H).normalize().subtractToRef(E,V),e[3*H]=V.x*i,e[3*H+1]=V.y,e[3*H+2]=V.z}const E=H.createBufferView(e,12),u=H.createAccessor(E,"VEC3",5126,z.length/3,0);P.push(u),D.attributes.NORMAL=P.length-1}else u.Tools.Warn(`Morph target normals for mesh ${E.name} were not exported. Mesh does not have normals vertex data`)}if(e.hasTangents){const z=e.getTangents(),M=A.getVerticesData(C.g.TangentKind);if(M){j=M.length/4;const e=new Float32Array(3*j);U=0;for(let H=U;H<j;++H){const E=N.jE.aE(M,4*H);c(E);const u=N.jE.aE(z,3*H);c(u),u.subtractToRef(E,V),e[3*H]=V.x*i,e[3*H+1]=V.y,e[3*H+2]=V.z}const E=H.createBufferView(e,12),u=H.createAccessor(E,"VEC3",5126,j,0);P.push(u),D.attributes.TANGENT=P.length-1}else u.Tools.Warn(`Morph target tangents for mesh ${E.name} were not exported. Mesh does not have tangents vertex data`)}if(e.hasColors){const z=e.getColors(),M=A.getVerticesData(C.g.ColorKind),i=A.getVertexBuffer(C.g.ColorKind);if(M&&i){const e=i.getSize();j=M.length/e;const E=new Float32Array(j*e);U=0;for(let H=U;H<j;++H)if(3===e){const u=N.jE.aE(M,H*e);N.jE.aE(z,H*e).subtractToRef(u,V),E[3*H]=V.x,E[3*H+1]=V.y,E[3*H+2]=V.z}else if(4===e){const u=new N.Vector4,P=N.Vector4.aE(M,H*e);N.Vector4.aE(z,H*e).subtractToRef(P,u),E[4*H]=u.x,E[4*H+1]=u.y,E[4*H+2]=u.z,E[4*H+3]=u.w}else u.Tools.Warn(`Unsupported number of components for color attribute: ${e}`);const A=H.createBufferView(E,4*e),C=H.createAccessor(A,3===e?"VEC3":"VEC4",5126,j,0);P.push(C),D.attributes.COLOR_0=P.length-1}else u.Tools.Warn(`Morph target colors for mesh ${E.name} were not exported. Mesh does not have colors vertex data`)}return D}var Ye=H(12265),fe=H(12117),we=H(12103),se=H(11690);class pe{}pe.DEFAULT_COLOR=h.XE.White(),pe.DEFAULT_WIDTH_ATTENUATED=1,pe.DEFAULT_WIDTH=.1;var oe=H(11940),ye=H(12274);class be{static ConvertPoints(e,E){if(e.length&&Array.isArray(e)&&"number"===typeof e[0])return[e];if(e.length&&Array.isArray(e[0])&&"number"===typeof e[0][0])return e;if(e.length&&!Array.isArray(e[0])&&e[0]instanceof N.jE){const E=[];for(let H=0;H<e.length;H++){const N=e[H];E.push(N.x,N.y,N.z)}return[E]}if(e.length>0&&Array.isArray(e[0])&&e[0].length>0&&e[0][0]instanceof N.jE){const E=[],H=e;for(const e of H)E.push(e.flatMap((e=>[e.x,e.y,e.z])));return E}if(e instanceof Float32Array){if(null!==E&&void 0!==E&&E.floatArrayStride){const H=[],N=3*E.floatArrayStride;for(let E=0;E<e.length;E+=N){const u=new Array(N);for(let H=0;H<N;H++)u[H]=e[E+H];H.push(u)}return H}return[Array.from(e)]}if(e.length&&e[0]instanceof Float32Array){const E=[];for(const H of e)E.push(Array.from(H));return E}return[]}static OmitZeroLengthPredicate(e,E,H){const N=[];return E.FE(e).lengthSquared()>0&&N.push([e,E]),H.FE(E).lengthSquared()>0&&N.push([E,H]),e.FE(H).lengthSquared()>0&&N.push([H,e]),0===N.length?null:N}static OmitDuplicatesPredicate(e,E,H,N){const u=[];return be._SearchInPoints(e,E,N)||u.push([e,E]),be._SearchInPoints(E,H,N)||u.push([E,H]),be._SearchInPoints(H,e,N)||u.push([H,e]),0===u.length?null:u}static _SearchInPoints(e,E,H){for(const P of H)for(let H=0;H<P.length;H++){var N,u,z;if(null!==(N=P[H])&&void 0!==N&&N.equals(e))if(null!==(u=P[H+1])&&void 0!==u&&u.equals(E)||null!==(z=P[H-1])&&void 0!==z&&z.equals(E))return!0}return!1}static MeshesToLines(e,E){const H=[];for(let u=0;u<e.length;u++){const z=e[u],P=z.getVerticesData(C.g.PositionKind),M=z.CM();if(P&&M)for(let e=0,D=0;e<M.length;e++){const A=3*M[D++],C=3*M[D++],i=3*M[D++],V=new N.jE(P[A],P[A+1],P[A+2]),U=new N.jE(P[C],P[C+1],P[C+2]),j=new N.jE(P[i],P[i+1],P[i+2]);if(E){const N=E(V,U,j,H,e,A,z,u,P,M);if(N)for(const e of N)H.push(e)}else H.push([V,U],[U,j],[j,V])}}return H}static ToVector3Array(e){if(Array.isArray(e[0])){const E=[],H=e;for(const e of H){const H=[];for(let E=0;E<e.length;E+=3)H.push(new N.jE(e[E],e[E+1],e[E+2]));E.push(H)}return E}const E=e,H=[];for(let u=0;u<E.length;u+=3)H.push(new N.jE(E[u],E[u+1],E[u+2]));return H}static ToNumberArray(e){return e.flatMap((e=>[e.x,e.y,e.z]))}static GetPointsCountInfo(e){const E=new Array(e.length);let H=0;for(let N=e.length;N--;)E[N]=e[N].length/3,H+=E[N];return{total:H,counts:E}}static GetLineLength(e){if(0===e.length)return 0;let E;E="number"===typeof e[0]?be.ToVector3Array(e):e;const H=N.TmpVectors.jE[0];let u=0;for(let N=0;N<E.length-1;N++){const e=E[N];u+=E[N+1].subtractToRef(e,H).length()}return u}static GetLineLengthArray(e){const E=new Float32Array(e.length/3);let H=0;for(let N=0,u=e.length/3-1;N<u;N++){let u=e[3*N+0],z=e[3*N+1],P=e[3*N+2];u-=e[3*N+3],z-=e[3*N+4],P-=e[3*N+5];H+=Math.sqrt(u*u+z*z+P*P),E[N+1]=H}return E}static SegmentizeSegmentByCount(e,E,H){const u=[],z=E.FE(e),P=N.TmpVectors.jE[0];P.jM(H);const M=N.TmpVectors.jE[1];z.divideToRef(P,M);let D=e.clone();u.push(D);for(let N=0;N<H;N++)D=D.clone(),u.push(D.addInPlace(M));return u}static SegmentizeLineBySegmentLength(e,E){const H=e[0]instanceof N.jE?be.GetLineSegments(e):"number"===typeof e[0]?be.GetLineSegments(be.ToVector3Array(e)):e,u=[];for(const N of H)if(N.length>E){const e=be.SegmentizeSegmentByCount(N.point1,N.point2,Math.ceil(N.length/E));for(const E of e)u.push(E)}else u.push(N.point1),u.push(N.point2);return u}static SegmentizeLineBySegmentCount(e,E){const H="number"===typeof e[0]?be.ToVector3Array(e):e,N=be.GetLineLength(H)/E;return be.SegmentizeLineBySegmentLength(H,N)}static GetLineSegments(e){const E=[];for(let H=0;H<e.length-1;H++){const N=e[H],u=e[H+1],z=u.FE(N).length();E.push({point1:N,point2:u,length:z})}return E}static GetMinMaxSegmentLength(e){const E=be.GetLineSegments(e).sort((e=>e.length));return{min:E[0].length,max:E[E.length-1].length}}static GetPositionOnLineByVisibility(e,E,H){let u=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const z=E*H;let P=0,M=0;const D=e.length;for(let N=0;N<D;N++){if(z<=P+e[N].length){M=N;break}P+=e[N].length}const A=(z-P)/e[M].length;return e[M].point2.subtractToRef(e[M].point1,N.TmpVectors.jE[0]),N.TmpVectors.jE[1]=N.TmpVectors.jE[0].multiplyByFloats(A,A,A),u||N.TmpVectors.jE[1].addInPlace(e[M].point1),N.TmpVectors.jE[1].clone()}static GetCircleLinePoints(e,E){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e,z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/E;const P=[];for(let M=0;M<=E;M++)P.push(new N.jE(Math.cos(M*z)*e,Math.sin(M*z)*u,H));return P}static GetBezierLinePoints(e,E,H,N){return oe.d.CreateQuadraticBezier(e,E,H,N).getPoints().flatMap((e=>[e.x,e.y,e.z]))}static GetArrowCap(e,E,H,N,u){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,P=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[e.clone(),e.add(E.multiplyByFloats(H,H,H))],widths:[N,u,z,P]}}static GetPointsFromText(e,E,H,N){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const P=[],M=(0,ye.c)(e,E,H,N);for(const D of M){for(const e of D.paths){const E=[],H=e.getPoints();for(const e of H)E.push(e.x,e.y,u);P.push(E)}if(z)for(const e of D.holes){const E=[],H=e.getPoints();for(const e of H)E.push(e.x,e.y,u);P.push(E)}}return P}static Color3toRGBAUint8(e){const E=new Uint8Array(4*e.length);for(let H=0,N=0;H<e.length;H++)E[N++]=255*e[H].r,E[N++]=255*e[H].g,E[N++]=255*e[H].b,E[N++]=255;return E}static CreateColorsTexture(e,E,H,N){const u=N.getEngine().getCaps().maxTextureSize??1,z=E.length>u?u:E.length,P=Math.ceil(E.length/u);P>1&&(E=[...E,...Array(z*P-E.length).fill(E[0])]);const M=be.Color3toRGBAUint8(E),D=new Y.e(M,z,P,j.b.TEXTUREFORMAT_RGBA,N,!1,!0,H);return D.name=e,D}static PrepareEmptyColorsTexture(e){if(!pe.EmptyColorsTexture){const E=new Uint8Array(4);pe.EmptyColorsTexture=new Y.e(E,1,1,j.b.TEXTUREFORMAT_RGBA,e,!1,!1,Y.e.NEAREST_NEAREST),pe.EmptyColorsTexture.name="grlEmptyColorsTexture"}return pe.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var e;null===(e=pe.EmptyColorsTexture)||void 0===e||e.dispose(),pe.EmptyColorsTexture=null}static BooleanToNumber(e){return e?1:0}}class Ke extends we.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class le extends fe.b{isCompatible(e){return!0}constructor(e,E,H){var u;H=H||{color:pe.DEFAULT_COLOR};const z=new Ke;z.GREASED_LINE_HAS_COLOR=!!H.color&&!H.useColors,z.GREASED_LINE_SIZE_ATTENUATION=H.sizeAttenuation??!1,z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===H.colorDistributionType,z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(E??e.fe()).useRightHandedSystem,z.GREASED_LINE_CAMERA_FACING=H.cameraFacing??!0,super(e,le.GREASED_LINE_MATERIAL_NAME,200,z,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(u=H)||void 0===u?void 0:u.forceGLSL)||le.ForceGLSL,this._scene=E??e.fe(),this._engine=this._scene.getEngine(),this._cameraFacing=H.cameraFacing??!0,this.visibility=H.visibility??1,this.useDash=H.useDash??!1,this.dashRatio=H.dashRatio??.5,this.dashOffset=H.dashOffset??0,this.width=H.width?H.width:H.sizeAttenuation?pe.DEFAULT_WIDTH_ATTENUATED:pe.DEFAULT_WIDTH,this._sizeAttenuation=H.sizeAttenuation??!1,this.colorMode=H.colorMode??0,this._color=H.color??null,this.useColors=H.useColors??!1,this._colorsDistributionType=H.colorDistributionType??0,this.colorsSampling=H.colorsSampling??Y.e.NEAREST_NEAREST,this._colors=H.oe??null,this.dashCount=H.dashCount??1,this.resolution=H.resolution??new N.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),H.colorsTexture?this.colorsTexture=H.colorsTexture:this._colors?this.colorsTexture=be.CreateColorsTexture(`${e.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??pe.DEFAULT_COLOR,be.PrepareEmptyColorsTexture(this._scene)),this._engine.cP.add((()=>{be.DisposeEmptyColorsTexture()}))}getAttributes(e){e.push("grl_offsets"),e.push("grl_widths"),e.push("grl_colorPointers"),e.push("grl_counters"),this._cameraFacing?(e.push("grl_previousAndSide"),e.push("grl_nextAndCounters")):e.push("grl_slopes")}getSamplers(e){e.push("grl_colors")}getActiveTextures(e){this.colorsTexture&&e.push(this.colorsTexture)}getUniforms(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const E=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&E.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===e&&E.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:E,vertex:this._cameraFacing&&this._isGLSL(e)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(e)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(e){if(this._cameraFacing){e.MM("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||e.MM("viewProjection",this._scene.getTransformMatrix());const E=N.TmpVectors.Vector4[0];E.x=this._aspect,E.y=this._resolution.x,E.z=this._resolution.y,E.w=this.width,e.updateVector4("grl_aspect_resolution_lineWidth",E)}const E=N.TmpVectors.Vector4[0];E.x=be.BooleanToNumber(this.useDash),E.y=this._dashArray,E.z=this.dashOffset,E.w=this.dashRatio,e.updateVector4("grl_dashOptions",E);const H=N.TmpVectors.Vector4[1];H.x=this.colorMode,H.y=this.visibility,H.z=this.colorsTexture?this.colorsTexture.getSize().width:0,H.w=be.BooleanToNumber(this.useColors),e.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",H),this._color&&e.updateColor3("grl_singleColor",this._color);const u=this.colorsTexture??pe.EmptyColorsTexture;e.setTexture("grl_colors",u),e.updateFloat2("grl_textureSize",(null===u||void 0===u?void 0:u.getSize().width)??1,(null===u||void 0===u?void 0:u.getSize().height)??1)}prepareDefines(e,E,H){e.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,e.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,e.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,e.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=E.useRightHandedSystem,e.GREASED_LINE_CAMERA_FACING=this._cameraFacing,e.GREASED_LINE_USE_OFFSETS=!!H.offsets}getClassName(){return le.GREASED_LINE_MATERIAL_NAME}getCustomCode(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(E)?function(e,E){if("vertex"===e){const e={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return E&&(e["!gl_Position\\=viewProjection\\*worldPos;"]="//"),e}return"fragment"===e?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(e,this._cameraFacing):function(e,E){if("vertex"===e){const e={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return E&&(e["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),e}return"fragment"===e?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(e,this._cameraFacing)}dispose(){var e;null===(e=this.colorsTexture)||void 0===e||e.dispose(),super.dispose()}get oe(){return this._colors}set oe(e){this.setColors(e)}setColors(e){var E;let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1],N=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const u=(null===(E=this._colors)||void 0===E?void 0:E.length)??0;var z;if(this._colors=e,null!==e&&0!==e.length){if(!H||N)if(this.colorsTexture&&u===e.length&&!N){const E=be.Color3toRGBAUint8(e);this.colorsTexture.update(E)}else{var P;null===(P=this.colorsTexture)||void 0===P||P.dispose(),this.colorsTexture=be.CreateColorsTexture(`${this._material.name}-colors-texture`,e,this.colorsSampling,this._scene)}}else null===(z=this.colorsTexture)||void 0===z||z.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(e){this._dashCount=e,this._dashArray=1/e}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(e){this._sizeAttenuation=e,this.markAllDefinesAsDirty()}get color(){return this._color}set color(e){this.setColor(e)}setColor(e){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==e||null!==this._color&&null===e?(this._color=e,E||this.markAllDefinesAsDirty()):this._color=e}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(e){this._colorsDistributionType=e,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(e){this._aspect=e.x/e.y,this._resolution=e}serialize(){const e=super.serialize(),E={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(E.oe=this._colors),this._color&&(E.color=this._color),e.greasedLineMaterialOptions=E,e}parse(e,E,H){var N;super.parse(e,E,H);const u=e.greasedLineMaterialOptions;null===(N=this.colorsTexture)||void 0===N||N.dispose(),u.color&&this.setColor(u.color,!0),u.colorDistributionType&&(this.colorsDistributionType=u.colorDistributionType),u.oe&&(this.oe=u.oe),u.colorsSampling&&(this.colorsSampling=u.colorsSampling),u.colorMode&&(this.colorMode=u.colorMode),u.useColors&&(this.useColors=u.useColors),u.visibility&&(this.visibility=u.visibility),u.useDash&&(this.useDash=u.useDash),u.dashCount&&(this.dashCount=u.dashCount),u.dashRatio&&(this.dashRatio=u.dashRatio),u.dashOffset&&(this.dashOffset=u.dashOffset),u.width&&(this.width=u.width),u.sizeAttenuation&&(this.sizeAttenuation=u.sizeAttenuation),u.resolution&&(this.resolution=u.resolution),this.oe?this.colorsTexture=be.CreateColorsTexture(`${this._material.name}-colors-texture`,this.oe,this.colorsSampling,E):be.PrepareEmptyColorsTexture(E),this.markAllDefinesAsDirty()}copyTo(e){var E;const H=e;null===(E=H.colorsTexture)||void 0===E||E.dispose(),this._colors&&(H.colorsTexture=be.CreateColorsTexture(`${H._material.name}-colors-texture`,this._colors,H.colorsSampling,this._scene)),H.setColor(this.color,!0),H.colorsDistributionType=this.colorsDistributionType,H.colorsSampling=this.colorsSampling,H.colorMode=this.colorMode,H.useColors=this.useColors,H.visibility=this.visibility,H.useDash=this.useDash,H.dashCount=this.dashCount,H.dashRatio=this.dashRatio,H.dashOffset=this.dashOffset,H.width=this.width,H.sizeAttenuation=this.sizeAttenuation,H.resolution=this.resolution,H.markAllDefinesAsDirty()}_isGLSL(e){return 0===e||this._forceGLSL}}le.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",le.ForceGLSL=!1,(0,se.g)(`BABYLON.${le.GREASED_LINE_MATERIAL_NAME}`,le);var Oe=H(12147),ve=H(11552),Re=H(11958),Te=H(11669);class Le extends Re.ShaderMaterial{constructor(e,E,u){const z=E.getEngine(),P=z.isWebGPU&&!(u.forceGLSL||Le.ForceGLSL),M=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];E.useRightHandedSystem&&M.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const D=["position","grl_widths","grl_offsets","grl_colorPointers"];u.cameraFacing?(M.push("GREASED_LINE_CAMERA_FACING"),D.push("grl_previousAndSide","grl_nextAndCounters")):(D.push("grl_slopes"),D.push("grl_counters"));const A=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(P||A.push("world","viewProjection","view","projection"),super(e,E,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:P?["Scene","Mesh"]:void 0,attributes:D,uniforms:A,samplers:P?[]:["grlColors"],defines:M,extraInitializationsAsync:async()=>{P?await Promise.all([H.e(66).then(H.bind(H,14806)),H.e(75).then(H.bind(H,14809))]):await Promise.all([H.e(69).then(H.bind(H,14814)),H.e(76).then(H.bind(H,14822))])},shaderLanguage:P?1:0}),this._color=h.XE.White(),this._colorsDistributionType=0,this._colorsTexture=null,u=u||{color:pe.DEFAULT_COLOR},this.visibility=u.visibility??1,this.useDash=u.useDash??!1,this.dashRatio=u.dashRatio??.5,this.dashOffset=u.dashOffset??0,this.dashCount=u.dashCount??1,this.width=u.width?u.width:u.sizeAttenuation&&u.cameraFacing?pe.DEFAULT_WIDTH_ATTENUATED:pe.DEFAULT_WIDTH,this.sizeAttenuation=u.sizeAttenuation??!1,this.color=u.color??h.XE.White(),this.useColors=u.useColors??!1,this.colorsDistributionType=u.colorDistributionType??0,this.colorsSampling=u.colorsSampling??Y.e.NEAREST_NEAREST,this.colorMode=u.colorMode??0,this._colors=u.oe??null,this._cameraFacing=u.cameraFacing??!0,this.resolution=u.resolution??new N.Vector2(z.getRenderWidth(),z.getRenderHeight()),u.colorsTexture?this.colorsTexture=u.colorsTexture:this._colors?this.colorsTexture=be.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,E):(this._color=this._color??pe.DEFAULT_COLOR,this.colorsTexture=be.PrepareEmptyColorsTexture(E)),P){const e=new Te.b;e.setParameters(),e.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",e)}z.cP.add((()=>{be.DisposeEmptyColorsTexture()}))}dispose(){var e;null===(e=this._colorsTexture)||void 0===e||e.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new N.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get oe(){return this._colors}set oe(e){this.setColors(e)}setColors(e){var E;let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1],N=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const u=(null===(E=this._colors)||void 0===E?void 0:E.length)??0;var z;if(this._colors=e,null!==e&&0!==e.length){if(!H||N)if(this._colorsTexture&&u===e.length&&!N){const E=be.Color3toRGBAUint8(e);this._colorsTexture.update(E)}else{var P;null===(P=this._colorsTexture)||void 0===P||P.dispose(),this.colorsTexture=be.CreateColorsTexture(`${this.name}-colors-texture`,e,this.colorsSampling,this.fe())}}else null===(z=this._colorsTexture)||void 0===z||z.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(e){this._colorsTexture=e,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(e){this._width=e,this.setFloat("grlWidth",e)}get useColors(){return this._useColors}set useColors(e){this._useColors=e,this.setFloat("grlUseColors",be.BooleanToNumber(e))}get colorsSampling(){return this._colorsSampling}set colorsSampling(e){this._colorsSampling=e}get visibility(){return this._visibility}set visibility(e){this._visibility=e,this.setFloat("grlVisibility",e)}get useDash(){return this._useDash}set useDash(e){this._useDash=e,this.setFloat("grlUseDash",be.BooleanToNumber(e))}get dashOffset(){return this._dashOffset}set dashOffset(e){this._dashOffset=e,this.setFloat("grlDashOffset",e)}get dashRatio(){return this._dashRatio}set dashRatio(e){this._dashRatio=e,this.setFloat("grlDashRatio",e)}get dashCount(){return this._dashCount}set dashCount(e){this._dashCount=e,this._dashArray=1/e,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(e){this._sizeAttenuation=e,this.setFloat("grlSizeAttenuation",be.BooleanToNumber(e))}get color(){return this._color}set color(e){this.setColor(e)}setColor(e){e=e??pe.DEFAULT_COLOR,this._color=e,this.setColor3("grlColor",e)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(e){this._colorsDistributionType=e,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(e){this._colorMode=e,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(e){this._resolution=e,this.setVector2("grlResolution",e),this.setFloat("grlAspect",e.x/e.y)}serialize(){const e=super.serialize(),E={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(E.oe=this._colors),e.greasedLineMaterialOptions=E,e}parse(e,E,H){var N;const u=e.greasedLineMaterialOptions;null===(N=this._colorsTexture)||void 0===N||N.dispose(),u.color&&(this.color=u.color),u.colorDistributionType&&(this.colorsDistributionType=u.colorDistributionType),u.colorsSampling&&(this.colorsSampling=u.colorsSampling),u.colorMode&&(this.colorMode=u.colorMode),u.useColors&&(this.useColors=u.useColors),u.visibility&&(this.visibility=u.visibility),u.useDash&&(this.useDash=u.useDash),u.dashCount&&(this.dashCount=u.dashCount),u.dashRatio&&(this.dashRatio=u.dashRatio),u.dashOffset&&(this.dashOffset=u.dashOffset),u.width&&(this.width=u.width),u.sizeAttenuation&&(this.sizeAttenuation=u.sizeAttenuation),u.resolution&&(this.resolution=u.resolution),u.oe?this.colorsTexture=be.CreateColorsTexture(`${this.name}-colors-texture`,u.oe,this.colorsSampling,this.fe()):this.colorsTexture=be.PrepareEmptyColorsTexture(E),this._cameraFacing=u.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var de,Ge,mE;Le.ForceGLSL=!1,function(e){e[e.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",e[e.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(de||(de={})),function(e){e[e.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",e[e.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",e[e.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Ge||(Ge={})),function(e){e[e.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",e[e.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",e[e.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",e[e.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",e[e.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(mE||(mE={}));class Qe extends Xe.c{constructor(e,E,H){super(e,E,null,null,!1,!1),this.name=e,this._options=H,this._lazy=!1,this._updatable=!1,this._engine=E.getEngine(),this._lazy=H.lazy??!1,this._updatable=H.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=H.colorPointers??[],this._widths=H.widths??new Array(H.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(e){let E=0;for(const N of this._points)E+=N.length;const H=E/3*2-this._widths.length;for(let N=0;N<H;N++)this._widths.push(e)}updateLazy(){var e,E;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(e=this._options.ribbonOptions)||void 0===e?void 0:e.smoothShading),!this.le&&this.refreshBoundingInfo(),null===(E=this.greasedLineMaterial)||void 0===E||E.updateLazy()}addPoints(e,E){for(const H of e)this._points.push(H);this._lazy||this.setPoints(this._points,E)}dispose(e){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(e,E)}isLazy(){return this._lazy}get ye(){return this._uvs}set ye(e){this._uvs=e instanceof Float32Array?e:new Float32Array(e),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(e){this.material instanceof Le&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===e||void 0===e?void 0:e.length)>0),this._offsets=e,this._offsetsBuffer?this._offsetsBuffer.update(e):this._createOffsetsBuffer(e)}get widths(){return this._widths}set widths(e){this._widths=e,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(e)}get colorPointers(){return this._colorPointers}set colorPointers(e){this._colorPointers=e,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(e)}get greasedLineMaterial(){var e,E;if(this.material&&this.material instanceof Le)return this.material;const H=null===(e=this.material)||void 0===e||null===(E=e.pluginManager)||void 0===E?void 0:E.getPlugin(le.GREASED_LINE_MATERIAL_NAME);return H||void 0}get points(){const e=[];return ve.e.DeepCopy(this._points,e),e}setPoints(e,E){this._points=be.ConvertPoints(e,(null===E||void 0===E?void 0:E.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==E&&void 0!==E&&E.colorPointers||this._updateColorPointers(),this._setPoints(this._points,E)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,ye:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(e){super.serialize(e),e.type=this.getClassName(),e.lineOptions=this._createLineOptions()}_createVertexBuffers(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new Oe.d;return E.se=this._vertexPositions,E.indices=this._indices,E.ye=this._uvs,e&&(E.pe=[],Oe.d.ComputeNormals(this._vertexPositions,this._indices,E.pe)),E.Ke(this,this._options.updatable),E}_createOffsetsBuffer(e){const E=this._scene.getEngine(),H=new C.c(E,e,this._updatable,3);this.setVerticesBuffer(H.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=H}}class Ze{constructor(e,E){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=e,this.wasAddedByNoopNode=E}getIndicesAccessor(e,E,H,N,u){var z,P,M,D;return null===(z=this._indicesAccessorMap.get(e))||void 0===z||null===(P=z.get(E))||void 0===P||null===(M=P.get(H))||void 0===M||null===(D=M.get(N))||void 0===D?void 0:D.get(u)}setIndicesAccessor(e,E,H,N,u,z){let P=this._indicesAccessorMap.get(e);P||(P=new Map,this._indicesAccessorMap.set(e,P));let M=P.get(E);M||(M=new Map,P.set(E,M));let D=M.get(H);D||(D=new Map,M.set(H,D));let A=D.get(N);A||(A=new Map,D.set(N,A)),A.set(u,z)}pushExportedNode(e){this._exportedNodes.has(e)||this._exportedNodes.add(e)}getNodesSet(){return this._exportedNodes}getVertexBufferView(e){return this._vertexBufferViewMap.get(e)}setVertexBufferView(e,E){this._vertexBufferViewMap.set(e,E)}setRemappedBufferView(e,E,H){this._remappedBufferView.set(e,new Map),this._remappedBufferView.get(e).set(E,H)}getRemappedBufferView(e,E){var H;return null===(H=this._remappedBufferView.get(e))||void 0===H?void 0:H.get(E)}getVertexAccessor(e,E,H){var N,u;return null===(N=this._vertexAccessorMap.get(e))||void 0===N||null===(u=N.get(E))||void 0===u?void 0:u.get(H)}setVertexAccessor(e,E,H,N){let u=this._vertexAccessorMap.get(e);u||(u=new Map,this._vertexAccessorMap.set(e,u));let z=u.get(E);z||(z=new Map,u.set(E,z)),z.set(H,N)}hasVertexColorAlpha(e){return this._vertexMapColorAlpha.get(e)||!1}setHasVertexColorAlpha(e,E){return this._vertexMapColorAlpha.set(e,E)}getMesh(e){return this._meshMap.get(e)}setMesh(e,E){this._meshMap.set(e,E)}bindMorphDataToMesh(e,E){const H=this._meshMorphTargetMap.get(e)||[];this._meshMorphTargetMap.set(e,H),-1===H.indexOf(E)&&H.push(E)}getMorphTargetsFromMesh(e){return this._meshMorphTargetMap.get(e)}}class ke{_ApplyExtension(e,E,H,N){if(H>=E.length)return Promise.resolve(e);const u=N(E[H],e);return u?u.then((async e=>e?await this._ApplyExtension(e,E,H+1,N):null)):this._ApplyExtension(e,E,H+1,N)}_ApplyExtensions(e,E){const H=[];for(const N of ke._ExtensionNames)H.push(this._extensions[N]);return this._ApplyExtension(e,H,0,E)}_extensionsPreExportTextureAsync(e,E,H){return this._ApplyExtensions(E,((E,N)=>E.preExportTextureAsync&&E.preExportTextureAsync(e,N,H)))}_extensionsPostExportNodeAsync(e,E,H,N,u){return this._ApplyExtensions(E,((E,z)=>E.postExportNodeAsync&&E.postExportNodeAsync(e,z,H,N,u,this._bufferManager)))}_extensionsPostExportMaterialAsync(e,E,H){return this._ApplyExtensions(E,((E,N)=>E.postExportMaterialAsync&&E.postExportMaterialAsync(e,N,H)))}_extensionsPostExportMaterialAdditionalTextures(e,E,H){const N=[];for(const u of ke._ExtensionNames){const z=this._extensions[u];z.postExportMaterialAdditionalTextures&&N.push(...z.postExportMaterialAdditionalTextures(e,E,H))}return N}_extensionsPostExportTextures(e,E,H){for(const N of ke._ExtensionNames){const u=this._extensions[N];u.postExportTexture&&u.postExportTexture(e,E,H)}}_extensionsPostExportMeshPrimitive(e){for(const E of ke._ExtensionNames){const H=this._extensions[E];H.postExportMeshPrimitive&&H.postExportMeshPrimitive(e,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const e of ke._ExtensionNames){const E=this._extensions[e];E.preGenerateBinaryAsync&&await E.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(e){for(const E of ke._ExtensionNames){const H=this._extensions[E];H.enabled&&e(H)}}_extensionsOnExporting(){this._forEachExtensions((e=>{var E,H,N;e.wasUsed&&((E=this._glTF).extensionsUsed||(E.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(e.name)&&this._glTF.extensionsUsed.push(e.name),e.required&&((H=this._glTF).extensionsRequired||(H.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(e.name)&&this._glTF.extensionsRequired.push(e.name)),(N=this._glTF).extensions||(N.extensions={}),e.onExporting&&e.onExporting())}))}_loadExtensions(){for(const e of ke._ExtensionNames){const E=ke._ExtensionFactories[e](this);this._extensions[e]=E}}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:F.d.LastCreatedScene,E=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${j.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new T(this),this._extensions={},this._bufferManager=new Ce,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!e)throw new Error("No scene available to export");this._babylonScene=e,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:e=>{var E;return null===e||void 0===e||null===(E=e.eM)||void 0===E?void 0:E.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...E},this._loadExtensions()}dispose(){for(const e in this._extensions){this._extensions[e].dispose()}}get options(){return this._options}static RegisterExtension(e,E){ke.UnregisterExtension(e)&&u.Tools.Warn(`Extension with the name ${e} already exists`),ke._ExtensionFactories[e]=E,ke._ExtensionNames.push(e)}static UnregisterExtension(e){if(!ke._ExtensionFactories[e])return!1;delete ke._ExtensionFactories[e];const E=ke._ExtensionNames.indexOf(e);return-1!==E&&ke._ExtensionNames.splice(E,1),!0}_generateJSON(e,E,H){const N={byteLength:e};return N.byteLength&&(this._glTF.buffers=[N]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.hE=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(N.uri=E+".bin"),H?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(e){const E=await this._generateBinaryAsync();this._extensionsOnExporting();const H=this._generateJSON(E.byteLength,e,!0),N=new Blob([E],{type:"application/octet-stream"}),u=e+".gltf",z=e+".bin",P=new A;if(P.files[u]=H,P.files[z]=N,this._imageData)for(const M in this._imageData)P.files[M]=new Blob([this._imageData[M].data],{type:this._imageData[M].mimeType});return P}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(e){const E=e%4;return 0===E?E:4-E}async generateGLBAsync(e){this._shouldUseGlb=!0;const E=await this._generateBinaryAsync();this._extensionsOnExporting();const H=this._generateJSON(E.byteLength),N=e+".glb";let u,z=H.length;if("undefined"!==typeof TextEncoder){u=(new TextEncoder).encode(H),z=u.length}const P=this._getPadding(z),M=this._getPadding(E.byteLength),D=28+z+P+E.byteLength+M,C=new De(D);if(C.writeUInt32(1179937895),C.writeUInt32(2),C.writeUInt32(D),C.writeUInt32(z+P),C.writeUInt32(1313821514),u)C.writeTypedArray(u);else{const e="_".charCodeAt(0);for(let E=0;E<z;++E){const N=H.charCodeAt(E);N!=H.codePointAt(E)?C.writeUInt8(e):C.writeUInt8(N)}}for(let A=0;A<P;++A)C.writeUInt8(32);C.writeUInt32(E.byteLength+M),C.writeUInt32(5130562),C.writeTypedArray(E);for(let A=0;A<M;++A)C.writeUInt8(0);const i=new A;return i.files[N]=new Blob([C.getOutputData()],{type:"application/octet-stream"}),i}_setNodeTransformation(e,E,H){if(E.getPivotPoint().equalsWithEpsilon(Q,me.d)||u.Tools.Warn("Pivot points are not supported in the glTF serializer"),!E.position.equalsWithEpsilon(Q,me.d)){const u=N.TmpVectors.jE[0].P(E.position);H&&n(u),e.translation=u.uM()}E.UM.equalsWithEpsilon(k,me.d)||(e.scale=E.UM.uM());const z=E.rotationQuaternion||N.Quaternion.FromEulerAngles(E.rotation.x,E.rotation.y,E.rotation.z);z.equalsWithEpsilon(Z,me.d)||(H&&g(z),e.rotation=z.normalize().uM())}_setCameraTransformation(e,E,H){if(!E.position.equalsWithEpsilon(Q,me.d)){const u=N.TmpVectors.jE[0].P(E.position);H&&n(u),e.translation=u.uM()}const u=E.rotationQuaternion||N.Quaternion.FromEulerAngles(E.rotation.x,E.rotation.y,E.rotation.z);H&&g(u),this._babylonScene.useRightHandedSystem||x(u),u.equalsWithEpsilon(Z,me.d)||(e.rotation=u.uM())}_listAvailableCameras(){for(const e of this._babylonScene.cameras){const E={type:e.mode===Ve.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(e.name&&(E.name=e.name),"perspective"===E.type)E.perspective={aspectRatio:e.getEngine().getAspectRatio(e),yfov:e.fovMode===Ve.c.FOVMODE_VERTICAL_FIXED?e.fov:e.fov*e.getEngine().getAspectRatio(e),znear:e.PM,zfar:e.maxZ};else if("orthographic"===E.type){const H=e.orthoLeft&&e.orthoRight?.5*(e.orthoRight-e.orthoLeft):.5*e.getEngine().getRenderWidth(),N=e.orthoBottom&&e.orthoTop?.5*(e.orthoTop-e.orthoBottom):.5*e.getEngine().getRenderHeight();E.orthographic={xmag:H,ymag:N,znear:e.PM,zfar:e.maxZ}}this._camerasMap.set(e,E)}}_exportAndAssignCameras(){const e=Array.from(this._camerasMap.values());for(const E of e){const e=this._nodesCameraMap.get(E);if(void 0!==e){this._cameras.push(E);for(const E of e)E.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const e of this._babylonScene.skeletons){if(e.bones.length<=0)continue;const E={joints:[]};this._skinMap.set(e,E)}}_exportAndAssignSkeletons(){for(const e of this._babylonScene.skeletons){if(e.bones.length<=0)continue;const E=this._skinMap.get(e);if(void 0==E)continue;const H={},N=[];let z=-1;for(let u=0;u<e.bones.length;++u){const E=e.bones[u],N=E.getIndex()??u;-1!==N&&(H[N]=E,N>z&&(z=N))}for(let e=0;e<=z;++e){const z=H[e];N.push(z.getAbsoluteInverseBindMatrix());const P=z.getTransformNode();if(null!==P){const e=this._nodeMap.get(P);P&&null!==e&&void 0!==e?E.joints.push(e):u.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else u.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const P=this._nodesSkinMap.get(E);if(E.joints.length>0&&void 0!==P){const e=64*N.length,H=new Float32Array(e/4);N.forEach(((e,E)=>{H.set(e.m,16*E)}));const u=this._bufferManager.createBufferView(H);this._accessors.push(this._bufferManager.createAccessor(u,"MAT4",5126,N.length)),E.inverseBindMatrices=this._accessors.length-1,this._skins.push(E);for(const E of P)E.skin=this._skins.length-1}}}async _exportSceneAsync(){const e={nodes:[]};if(this._babylonScene.metadata){const E=this._options.metadataSelector(this._babylonScene.metadata);E&&(e.extras=E)}const E=new Array,H=new Array,N=new Array;for(const M of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Pe(M,this._babylonScene.useRightHandedSystem)?N.push(...M.getChildren()):this._babylonScene.useRightHandedSystem?E.push(M):H.push(M);this._listAvailableCameras(),this._listAvailableSkeletons();const u=new Ze(!0,!1);e.nodes.push(...await this._exportNodesAsync(H,u));const z=new Ze(!1,!1);e.nodes.push(...await this._exportNodesAsync(E,z));const P=new Ze(!1,!0);e.nodes.push(...await this._exportNodesAsync(N,P)),e.nodes.length&&this._scenes.push(e),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&We._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,u.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(e){let E=this._shouldExportNodeMap.get(e);return void 0===E&&(E=this._options.shouldExportNode(e),this._shouldExportNodeMap.set(e,E)),E}async _exportNodesAsync(e,E){const H=new Array;this._exportBuffers(e,E);for(const N of e)await this._exportNodeAsync(N,H,E);return H}_collectBuffers(e,E,H,N,u){if(this._shouldExportNode(e)&&e instanceof V.d&&e.AM){const z=e.AM.getVertexBuffers();if(z)for(const N in z){if(!t(N))continue;const P=z[N];u.setHasVertexColorAlpha(P,e.hasVertexAlpha);const M=P._buffer,D=E.get(M)||[];E.set(M,D),-1===D.indexOf(P)&&D.push(P);const A=H.get(P)||[];H.set(P,A),-1===A.indexOf(e)&&A.push(e)}const P=e.morphTargetManager;if(P)for(let E=0;E<P.numTargets;E++){const H=P.getTarget(E),u=N.get(H)||[];N.set(H,u),-1===u.indexOf(e)&&u.push(e)}}for(const z of e.getChildren())this._collectBuffers(z,E,H,N,u)}_exportBuffers(e,E){const H=new Map,N=new Map,u=new Map;for(const M of e)this._collectBuffers(M,H,N,u,E);const z=Array.from(H.keys());for(const M of z){const e=M.getData();if(!e)throw new Error("Buffer data is not available");const u=H.get(M);if(!u)continue;const z=u[0].byteStride;if(u.some((e=>e.byteStride!==z)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const P=He(e).slice();for(const E of u){const e=N.get(E),{byteOffset:H,byteStride:u,componentCount:z,type:M,count:D,normalized:A,kind:i}=B(E,e);switch(i){case C.g.NormalKind:case C.g.TangentKind:(0,L.i)(P,H,u,z,M,D,A,(e=>{const E=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);if(E>0){const H=1/E;e[0]*=H,e[1]*=H,e[2]*=H}}));break;case C.g.ColorKind:{const E=e.filter((e=>e.material instanceof Fe.SE||null==e.material)).length;if(0==E)break;if(E!=e.length){d.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}M==C.g.UNSIGNED_BYTE&&d.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const N=new h.XE,i=new h.FM,V=this._babylonScene.getEngine().useExactSrgbConversions;(0,L.i)(P,H,u,z,M,D,A,(e=>{3===e.length?(N.VH(e,0),N.toLinearSpaceToRef(N,V),N.toArray(e,0)):(i.VH(e,0),i.toLinearSpaceToRef(i,V),i.toArray(e,0))}))}}}if(E.convertToRightHanded){for(const e of u){const E=N.get(e),{byteOffset:H,byteStride:u,componentCount:z,type:M,count:D,normalized:A,kind:i}=B(e,E);switch(i){case C.g.PositionKind:case C.g.NormalKind:case C.g.TangentKind:(0,L.i)(P,H,u,z,M,D,A,(e=>{e[0]=-e[0]}))}}E.convertedToRightHandedBuffers.set(M,P)}const D=this._bufferManager.createBufferView(P,z);E.setVertexBufferView(M,D);const A=new Map;for(const E of u){const e=N.get(E),{kind:H,totalVertices:u}=B(E,e);switch(H){case C.g.MatricesIndicesKind:case C.g.MatricesIndicesExtraKind:if(E.type==C.g.FLOAT){const e=E.getFloatData(u);null!==e&&A.set(E,e)}}}0!==A.size&&d.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const i=Array.from(A.keys());for(const H of i){const e=A.get(H);if(!e)continue;const N=e.some((e=>e>=256)),u=new(N?Uint16Array:Uint8Array)(e.length);for(let E=0;E<e.length;E++)u[E]=e[E];const z=this._bufferManager.createBufferView(u,4*(N?2:1));E.setRemappedBufferView(M,H,z)}}const P=Array.from(u.keys());for(const M of P){const e=u.get(M);if(!e)continue;const H=re(M,e[0],this._bufferManager,this._bufferViews,this._accessors,E.convertToRightHanded);for(const N of e)E.bindMorphDataToMesh(N,H)}}async _exportNodeAsync(e,E,H){let N=this._nodeMap.get(e);if(void 0!==N)return void(E.includes(N)||E.push(N));const u=await this._createNodeAsync(e,H);if(u){N=this._nodes.length,this._nodes.push(u),this._nodeMap.set(e,N),H.pushExportedNode(e),E.push(N);const z={name:"runtime animations",channels:[],samplers:[]},P=[];this._babylonScene.animationGroups.length||(We._CreateMorphTargetAnimationFromMorphTargetAnimations(e,z,P,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,H.convertToRightHanded,this._options.shouldExportAnimation),e.animations.length&&We._CreateNodeAnimationFromNodeAnimations(e,z,P,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,H.convertToRightHanded,this._options.shouldExportAnimation)),z.channels.length&&z.samplers.length&&this._animations.push(z),P.forEach((e=>{e.channels.length&&e.samplers.length&&this._animations.push(e)}))}const z=u?[]:E;for(const P of e.getChildren())await this._exportNodeAsync(P,z,H);u&&z.length&&(u.children=z)}async _createNodeAsync(e,E){if(!this._shouldExportNode(e))return null;const H={};if(e.name&&(H.name=e.name),e.metadata){const E=this._options.metadataSelector(e.metadata);E&&(H.extras=E)}if(e instanceof i.d&&(this._setNodeTransformation(H,e,E.convertToRightHanded),e instanceof V.d)){const u=e instanceof U.b?e.sourceMesh:e;if(u.NM&&u.NM.length>0&&(H.mesh=await this._exportMeshAsync(u,E)),e.skeleton){const E=this._skinMap.get(e.skeleton);var N;if(void 0!==E)void 0===this._nodesSkinMap.get(E)&&this._nodesSkinMap.set(E,[]),null===(N=this._nodesSkinMap.get(E))||void 0===N||N.push(H)}}if(e instanceof G.d){const N=this._camerasMap.get(e);if(N){var u;void 0===this._nodesCameraMap.get(N)&&this._nodesCameraMap.set(N,[]),this._setCameraTransformation(H,e,E.convertToRightHanded);const P=e.parent;if(null!==P&&Ee(e,P)){const e=this._nodeMap.get(P);if(void 0!==e){var z;const E=this._nodes[e];return ee(H,E),null===(z=this._nodesCameraMap.get(N))||void 0===z||z.push(E),null}}null===(u=this._nodesCameraMap.get(N))||void 0===u||u.push(H)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",H,e,this._nodeMap,E.convertToRightHanded)?H:(d.d.Warn(`Not exporting node ${e.name}`),null)}_exportIndices(e,E,H,N,u,P,M,D,A){let C=e;A.mode=q(P);const i=M!==z.e.CounterClockWiseSideOrientation,V=!D.wasAddedByNoopNode&&i,U=function(e){switch(e){case z.e.TriangleFillMode:case z.e.TriangleStripDrawMode:case z.e.TriangleFanDrawMode:return!0}return!1}(P)&&V;if(U){if(P===z.e.TriangleStripDrawMode||P===z.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");A.mode=q(P);const M=E?new Uint32Array(N):new Uint16Array(N);if(e)for(let E=0;E+2<N;E+=3)M[E]=e[H+E]+u,M[E+1]=e[H+E+2]+u,M[E+2]=e[H+E+1]+u;else for(let e=0;e+2<N;e+=3)M[e]=e,M[e+1]=e+2,M[e+2]=e+1;C=M}else if(e&&0!==u){const z=E?new Uint32Array(N):new Uint16Array(N);for(let E=0;E<N;E++)z[E]=e[H+E]+u;C=z}if(C){let z=D.getIndicesAccessor(e,H,N,u,U);if(void 0===z){const P=function(e,E,H,N){if(e instanceof Uint16Array||e instanceof Uint32Array)return e;if(e instanceof Int32Array)return new Uint32Array(e.buffer,e.byteOffset,e.length);const u=e.slice(E,E+H);return N?new Uint32Array(u):new Uint16Array(u)}(C,0,N,E),M=this._bufferManager.createBufferView(P),A=E?5125:5123;this._accessors.push(this._bufferManager.createAccessor(M,"SCALAR",A,N,0)),z=this._accessors.length-1,D.setIndicesAccessor(e,H,N,u,U,z)}A.indices=z}}_exportVertexBuffer(e,E,H,N,u,z){const P=e.getKind();if(!t(P))return;if(P.startsWith("uv")&&!this._options.exportUnusedUVs&&(!E||!this._materialNeedsUVsSet.has(E)))return;let M=u.getVertexAccessor(e,H,N);if(void 0===M){const E=u.convertedToRightHandedBuffers.get(e._buffer)||e._buffer.getData(),z=P===C.g.PositionKind?function(e,E,H,N){const{byteOffset:u,byteStride:z,type:P,normalized:M}=E,D=E.getSize(),A=new Array(D).fill(1/0),C=new Array(D).fill(-1/0);return(0,L.i)(e,u+H*z,z,D,P,N*D,M,(e=>{for(let E=0;E<D;E++)A[E]=Math.min(A[E],e[E]),C[E]=Math.max(C[E],e[E])})),{min:A,max:C}}(E,e,H,N):void 0,D=(P===C.g.MatricesIndicesKind||P===C.g.MatricesIndicesExtraKind)&&e.type===C.g.FLOAT,A=D?C.g.UNSIGNED_BYTE:e.type,i=D?void 0:e.normalized,V=D?u.getRemappedBufferView(e._buffer,e):u.getVertexBufferView(e._buffer),U=e.byteOffset+H*e.byteStride;this._accessors.push(this._bufferManager.createAccessor(V,function(e,E){if(e==C.g.ColorKind)return E?"VEC4":"VEC3";switch(e){case C.g.PositionKind:case C.g.NormalKind:return"VEC3";case C.g.TangentKind:case C.g.MatricesIndicesKind:case C.g.MatricesIndicesExtraKind:case C.g.MatricesWeightsKind:case C.g.MatricesWeightsExtraKind:return"VEC4";case C.g.UVKind:case C.g.UV2Kind:case C.g.UV3Kind:case C.g.UV4Kind:case C.g.UV5Kind:case C.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${e}`)}(P,u.hasVertexColorAlpha(e)),A,N,U,z,i)),M=this._accessors.length-1,u.setVertexAccessor(e,H,N,M)}z.attributes[function(e){switch(e){case C.g.PositionKind:return"POSITION";case C.g.NormalKind:return"NORMAL";case C.g.TangentKind:return"TANGENT";case C.g.ColorKind:return"COLOR_0";case C.g.UVKind:return"TEXCOORD_0";case C.g.UV2Kind:return"TEXCOORD_1";case C.g.UV3Kind:return"TEXCOORD_2";case C.g.UV4Kind:return"TEXCOORD_3";case C.g.UV5Kind:return"TEXCOORD_4";case C.g.UV6Kind:return"TEXCOORD_5";case C.g.MatricesIndicesKind:return"JOINTS_0";case C.g.MatricesIndicesExtraKind:return"JOINTS_1";case C.g.MatricesWeightsKind:return"WEIGHTS_0";case C.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${e}`)}(P)]=M}async _exportMaterialAsync(e,E,H,N){let u=this._materialMap.get(e);if(void 0===u){const N=E&&Object.keys(E).some((e=>e.startsWith("uv")));if((e=e instanceof Ue.e?e.hM[H.materialIndex]:e)instanceof je.b)u=await this._materialExporter.exportPBRMaterialAsync(e,"image/png",N);else{if(!(e instanceof Fe.SE))return void d.d.Warn(`Unsupported material '${e.name}' with type ${e.getClassName()}`);u=await this._materialExporter.exportStandardMaterialAsync(e,"image/png",N)}this._materialMap.set(e,u)}N.material=u}async _exportMeshAsync(e,E){var H;let N=E.getMesh(e);if(void 0!==N)return N;const u={primitives:[]};N=this._meshes.length,this._meshes.push(u),E.setMesh(e,N);const P=e.isUnIndexed?null:e.CM(),M=null===(H=e.AM)||void 0===H?void 0:H.getVertexBuffers(),D=E.getMorphTargetsFromMesh(e),A=e instanceof Ye.d,C=e instanceof Qe,i=e.NM;if(M&&i&&i.length>0)for(const j of i){const H={attributes:{}},N=j.Te()||this._babylonScene.defaultMaterial;if(C){var V,U;const E={name:N.name},u=e,z=h.XE.White(),P=(null===(V=u.material)||void 0===V?void 0:V.alpha)??1,M=(null===(U=u.greasedLineMaterial)||void 0===U?void 0:U.color)??z;(!M.equalsWithEpsilon(z,me.d)||P<1)&&(E.pbrMetallicRoughness={baseColorFactor:[...M.uM(),P]}),this._materials.push(E),H.material=this._materials.length-1}else if(A){const E={name:N.name},u=e;(!u.color.equalsWithEpsilon(h.XE.White(),me.d)||u.alpha<1)&&(E.pbrMetallicRoughness={baseColorFactor:[...u.color.uM(),u.alpha]}),this._materials.push(E),H.material=this._materials.length-1}else await this._exportMaterialAsync(N,M,j,H);const i=A||C?z.e.LineListDrawMode:e.overrideRenderingFillMode??N.fillMode,F=N._getEffectiveOrientation(e);this._exportIndices(P,P?(0,L.d)(P,j.indexCount,j.indexStart,j.verticesStart):j.verticesCount>65535,P?j.indexStart:j.verticesStart,P?j.indexCount:j.verticesCount,-j.verticesStart,i,F,E,H);for(const e of Object.values(M))this._exportVertexBuffer(e,N,j.verticesStart,j.verticesCount,E,H);if(D){H.targets=[];for(const e of D)H.targets.push(e.attributes)}u.primitives.push(H),this._extensionsPostExportMeshPrimitive(H)}if(D){u.weights=[],u.extras||(u.extras={}),u.extras.targetNames=[];for(const e of D)u.weights.push(e.influence),u.extras.targetNames.push(e.name)}return N}}ke._ExtensionNames=new Array,ke._ExtensionFactories={};class Je{static async GLTFAsync(e,E,H){H&&H.exportWithoutWaitingForScene||await e.whenReadyAsync();const N=new ke(e,H),u=await N.generateGLTFAsync(E.replace(/\.[^/.]+$/,""));return N.dispose(),u}static async GLBAsync(e,E,H){H&&H.exportWithoutWaitingForScene||await e.whenReadyAsync();const N=new ke(e,H),u=await N.generateGLBAsync(E.replace(/\.[^/.]+$/,""));return N.dispose(),u}}H(12288);const Be="EXT_mesh_gpu_instancing";class Ie{constructor(e){this.name=Be,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(e,E,H,u,z,P){return await new Promise((e=>{if(E&&H instanceof Xe.c&&H.hasThinInstances&&this._exporter){this._wasUsed=!0;const e=N.jE.Zero(),u=N.Quaternion.Identity(),M=N.jE.One(),D=H.thinInstanceGetWorldMatrices(),A=N.TmpVectors.jE[2],C=N.TmpVectors.Quaternion[1],i=N.TmpVectors.jE[3];let V=!1,U=!1,j=!1;const F=new Float32Array(3*H.SM),h=new Float32Array(4*H.SM),S=new Float32Array(3*H.SM);let X=0;for(const E of D)E.decompose(i,C,A),z&&(n(A),g(C)),F.set(A.uM(),3*X),h.set(C.normalize().uM(),4*X),S.set(i.uM(),3*X),V=V||!A.equalsWithEpsilon(e),U=U||!C.equalsWithEpsilon(u),j=j||!i.equalsWithEpsilon(M),X++;const a={attributes:{}};V&&(a.attributes.TRANSLATION=this._buildAccessor(F,"VEC3",H.SM,P)),U&&(a.attributes.ROTATION=this._buildAccessor(h,"VEC4",H.SM,P)),j&&(a.attributes.SCALE=this._buildAccessor(S,"VEC3",H.SM,P)),E.extensions=E.extensions||{},E.extensions[Be]=a}e(E)}))}_buildAccessor(e,E,H,N){const u=N.createBufferView(e),z=N.createAccessor(u,E,5126,H);return this._exporter._accessors.push(z),this._exporter._accessors.length-1}}ke.RegisterExtension(Be,(e=>new Ie(e)));var te=H(12292),qe=H(12307),ce=H(12313),ne=H(12322);function ge(e){return e===ce.c.PositionKind?"POSITION":e===ce.c.NormalKind?"NORMAL":e===ce.c.ColorKind?"COLOR":e.startsWith(ce.c.UVKind)?"TEX_COORD":"GENERIC"}const xe={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class eE extends te.e{static get DefaultAvailable(){return(0,te.k)(eE.DefaultConfiguration)}static get Default(){return eE._Default??(eE._Default=new eE),eE._Default}static ResetDefault(e){eE._Default&&(e||eE._Default.dispose(),eE._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(e,E){return{module:await(E||DracoEncoderModule)({wasmBinary:e})}}_getWorkerContent(){return`${qe.i}(${qe.m})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:eE.DefaultConfiguration)}async _encodeAsync(e,E,H){const N=H?(0,ne.d)(xe,H):xe;if(this._workerPoolPromise){const H=await this._workerPoolPromise;return await new Promise(((u,z)=>{H.push(((H,P)=>{const M=e=>{H.removeEventListener("error",M),H.removeEventListener("message",D),z(e),P()},D=e=>{"encodeMeshDone"===e.data.id&&(H.removeEventListener("error",M),H.removeEventListener("message",D),u(e.data.encodedMeshData),P())};H.addEventListener("error",M),H.addEventListener("message",D);const A=[];for(const E of e)A.push(E.data.buffer);E&&A.push(E.buffer),H.postMessage({id:"encodeMesh",attributes:e,indices:E,options:N},A)}))}))}if(this._modulePromise){const H=await this._modulePromise;return(0,qe.i)(H.module,e,E,N)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(e,E){if(0==e.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");e instanceof Xe.c&&e.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===E||void 0===E?void 0:E.method)&&(d.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),E.method="MESH_SEQUENTIAL_ENCODING");const H=function(e){let E=e.CM(void 0,!0);return!E||E instanceof Uint32Array||E instanceof Uint16Array||(E=((0,L.d)(E,E.length)?Uint32Array:Uint16Array).from(E)),E}(e),N=function(e,E){const H=[];for(const N of e.getVerticesDataKinds()){if(null!==E&&void 0!==E&&E.includes(N)){if(N===ce.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const u=e.getVertexBuffer(N),z=u.getSize(),P=(0,L.s)(u.getData(),z,u.type,u.byteOffset,u.byteStride,u.normalized,e.getTotalVertices(),!0);H.push({kind:N,dracoName:ge(N),size:z,data:P})}return H}(e,null===E||void 0===E?void 0:E.excludedAttributes);return await this._encodeAsync(N,H,E)}}eE.DefaultConfiguration={wasmUrl:`${u.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${u.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${u.Tools._DefaultCdnUrl}/draco_encoder.js`},eE._Default=null;const EE="KHR_draco_mesh_compression";class HE{get wasUsed(){return this._wasUsed}constructor(e){this.name=EE,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===e.options.meshCompressionMethod&&eE.DefaultAvailable}dispose(){}postExportMeshPrimitive(e,E,H){if(!this.enabled)return;if(4!==e.mode&&5!==e.mode)return void d.d.Warn("Cannot compress primitive with mode "+e.mode+".");const N=[],u=[];let z=null;if(void 0!==e.indices){const P=H[e.indices],M=E.getBufferView(P);z=E.getData(M).slice(),N.push(M),u.push(P)}const P=[];for(const[C,i]of Object.entries(e.attributes)){const e=H[i],z=E.getBufferView(e),D=I(e.type),A=(0,L.s)(E.getData(z),D,e.componentType,e.byteOffset||0,z.byteStride||(0,L.m)(e.componentType)*D,e.normalized||!1,e.count,!0);P.push({kind:C,dracoName:(M=C,"POSITION"===M?"POSITION":"NORMAL"===M?"NORMAL":M.startsWith("COLOR")?"COLOR":M.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:I(e.type),data:A}),N.push(z),u.push(e)}var M;const D={method:e.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},A=eE.Default._encodeAsync(P,z,D).then((H=>{if(!H)return void d.d.Error("Draco encoding failed for primitive.");const z={bufferView:-1,attributes:H.attributeIds},P=E.createBufferView(H.data);E.setBufferView(z,P);for(const e of N)this._bufferViewsUsed.add(e);for(const e of u)this._accessorsUsed.add(e);e.extensions||(e.extensions={}),e.extensions[EE]=z})).catch((e=>{d.d.Error("Draco encoding failed for primitive: "+e)}));this._encodePromises.push(A),this._wasUsed=!0}async preGenerateBinaryAsync(e){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((E=>{e.getPropertiesWithBufferView(E).every((e=>this._accessorsUsed.has(e)))&&e.removeBufferView(E)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}ke.RegisterExtension(EE,(e=>new HE(e)));var NE=H(12330);const uE="KHR_lights_punctual",zE={name:"",color:[1,1,1],XM:1,range:Number.MAX_VALUE},PE={innerConeAngle:0,outerConeAngle:Math.PI/4},ME=N.jE.Backward();class DE{constructor(e){this.name=uE,this.enabled=!0,this.required=!1,this._exporter=e}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[uE]=this._lights}async postExportNodeAsync(e,E,H,u,z){return await new Promise((P=>{if(!(H instanceof ae.b))return void P(E);const M=H.getTypeID()==ae.b.LIGHTTYPEID_POINTLIGHT?"point":H.getTypeID()==ae.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":H.getTypeID()==ae.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!M||!(H instanceof NE.e))return d.d.Warn(`${e}: Light ${H.name} is not supported in ${uE}`),void P(E);if(H.falloffType!==ae.b.FALLOFF_GLTF&&d.d.Warn(`${e}: Light falloff for ${H.name} does not match the ${uE} specification!`),!H.position.equalsToFloats(0,0,0)){const e=N.TmpVectors.jE[0].P(H.position);z&&n(e),E.translation=e.uM()}if("point"!==M){const e=H.direction.normalizeToRef(N.TmpVectors.jE[0]);z&&n(e);const u=N.Quaternion.FromUnitVectorsToRef(ME,e,N.TmpVectors.Quaternion[0]);N.Quaternion.IsIdentity(u)||(E.rotation=u.uM())}const D={type:M,name:H.name,color:H.aM.uM(),XM:H.XM,range:H.range};if(Ne(D,zE),"spot"===M){const e=H;D.spot={innerConeAngle:e.innerAngle/2,outerConeAngle:e.angle/2},Ne(D.spot,PE)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(D);const A={nz:this._lights.lights.length-1},C=H.parent;if(C&&Ee(H,C)){const e=u.get(C);if(e){const H=this._exporter._nodes[e];return ee(E,H),H.extensions||(H.extensions={}),H.extensions[uE]=A,void P(null)}}E.extensions||(E.extensions={}),E.extensions[uE]=A,P(E)}))}}ke.RegisterExtension(uE,(e=>new DE(e)));var AE=H(12224);const CE="KHR_materials_anisotropy";class iE{constructor(e){this.name=CE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,E,H){const N=[];return H instanceof AE.d&&H.anisotropy.isEnabled&&!H.anisotropy.legacy?(H.anisotropy.texture&&N.push(H.anisotropy.texture),N):[]}postExportMaterialAsync(e,E,H){return new Promise((e=>{if(H instanceof AE.d){if(!H.anisotropy.isEnabled||H.anisotropy.legacy)return void e(E);this._wasUsed=!0,E.extensions=E.extensions||{};const N=this._exporter._materialExporter.getTextureInfo(H.anisotropy.texture),u={anisotropyStrength:H.anisotropy.XM,anisotropyRotation:H.anisotropy.angle,anisotropyTexture:N??void 0};null!==u.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(H),E.extensions[CE]=u}e(E)}))}}ke.RegisterExtension(CE,(e=>new iE(e)));const VE="KHR_materials_clearcoat";class UE{constructor(e){this.name=VE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,E,H){const N=[];return H instanceof AE.d&&H.clearCoat.isEnabled?(H.clearCoat.texture&&N.push(H.clearCoat.texture),!H.clearCoat.useRoughnessFromMainTexture&&H.clearCoat.textureRoughness&&N.push(H.clearCoat.textureRoughness),H.clearCoat.bumpTexture&&N.push(H.clearCoat.bumpTexture),N):[]}postExportMaterialAsync(e,E,H){return new Promise((e=>{if(H instanceof AE.d){if(!H.clearCoat.isEnabled)return void e(E);this._wasUsed=!0,E.extensions=E.extensions||{};const N=this._exporter._materialExporter.getTextureInfo(H.clearCoat.texture);let z;z=H.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(H.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(H.clearCoat.textureRoughness),H.clearCoat.isTintEnabled&&u.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${H.name}`),H.clearCoat.remapF0OnInterfaceChange&&u.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${H.name}`);const P=this._exporter._materialExporter.getTextureInfo(H.clearCoat.bumpTexture),M={clearcoatFactor:H.clearCoat.XM,clearcoatTexture:N??void 0,clearcoatRoughnessFactor:H.clearCoat.roughness,clearcoatRoughnessTexture:z??void 0,clearcoatNormalTexture:P??void 0};null===M.clearcoatTexture&&null===M.clearcoatRoughnessTexture&&null===M.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(H),E.extensions[VE]=M}e(E)}))}}ke.RegisterExtension(VE,(e=>new UE(e)));const jE="KHR_materials_diffuse_transmission";function FE(e,E){const H=E.subSurface;let N=null;return H.translucencyIntensityTexture?N=H.translucencyIntensityTexture:H.thicknessTexture&&H.useMaskFromThicknessTexture&&(N=H.thicknessTexture),N&&!H.useGltfStyleTextures?(d.d.Warn(`${e}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${E.name}`,1),null):N}class hE{constructor(e){this.name=jE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,E,H){const N=[];if(H instanceof je.b&&this._isExtensionEnabled(H)){const E=FE(e,H);return E&&N.push(E),H.subSurface.translucencyColorTexture&&N.push(H.subSurface.translucencyColorTexture),N}return N}_isExtensionEnabled(e){if(e.unlit)return!1;const E=e.subSurface;return!!E.isTranslucencyEnabled&&(!e.unlit&&!E.useAlbedoToTintTranslucency&&E.useGltfStyleTextures&&1===E.volumeIndexOfRefraction&&0===E.minimumThickness&&0===E.maximumThickness)}postExportMaterialAsync(e,E,H){return new Promise((N=>{if(H instanceof je.b&&this._isExtensionEnabled(H)){this._wasUsed=!0;const N=H.subSurface,u=FE(e,H),z=0==N.translucencyIntensity?void 0:N.translucencyIntensity,P=this._exporter._materialExporter.getTextureInfo(u)??void 0,M=!N.translucencyColor||N.translucencyColor.equalsFloats(1,1,1)?void 0:N.translucencyColor.uM(),D=this._exporter._materialExporter.getTextureInfo(N.translucencyColorTexture)??void 0,A={diffuseTransmissionFactor:z,diffuseTransmissionTexture:P,diffuseTransmissionColorFactor:M,diffuseTransmissionColorTexture:D};(P||D)&&this._exporter._materialNeedsUVsSet.add(H),E.extensions=E.extensions||{},E.extensions[jE]=A}N(E)}))}}ke.RegisterExtension(jE,(e=>new hE(e)));const SE="KHR_materials_dispersion";class XE{constructor(){this.name=SE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(e){if(e.unlit)return!1;const E=e.subSurface;return!(!E.isRefractionEnabled&&!E.isDispersionEnabled)}postExportMaterialAsync(e,E,H){return new Promise((e=>{if(H instanceof je.b&&this._isExtensionEnabled(H)){this._wasUsed=!0;const e={dispersion:H.subSurface.dispersion};E.extensions=E.extensions||{},E.extensions[SE]=e}e(E)}))}}ke.RegisterExtension(SE,(()=>new XE));const aE="KHR_materials_emissive_strength";class WE{constructor(){this.name=aE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(e,E,H){return await new Promise((e=>{if(!(H instanceof je.b))return e(E);const N=H.emissiveColor.uM(),u=Math.max(...N);if(u>1){this._wasUsed=!0,E.extensions||(E.extensions={});const e={emissiveStrength:u},N=H.emissiveColor.scale(1/e.emissiveStrength);E.emissiveFactor=N.uM(),E.extensions[aE]=e}return e(E)}))}}ke.RegisterExtension(aE,(e=>new WE));const rE="KHR_materials_ior";class YE{constructor(){this.name=rE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(e){return!e.unlit&&(void 0!=e.indexOfRefraction&&1.5!=e.indexOfRefraction)}postExportMaterialAsync(e,E,H){return new Promise((e=>{if(H instanceof je.b&&this._isExtensionEnabled(H)){this._wasUsed=!0;const e={ior:H.indexOfRefraction};E.extensions=E.extensions||{},E.extensions[rE]=e}e(E)}))}}ke.RegisterExtension(rE,(e=>new YE));const fE="KHR_materials_iridescence";class wE{constructor(e){this.name=fE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,E,H){const N=[];return H instanceof AE.d&&H.iridescence.isEnabled?(H.iridescence.texture&&N.push(H.iridescence.texture),H.iridescence.thicknessTexture&&H.iridescence.thicknessTexture!==H.iridescence.texture&&N.push(H.iridescence.thicknessTexture),N):[]}postExportMaterialAsync(e,E,H){return new Promise((e=>{if(H instanceof AE.d){if(!H.iridescence.isEnabled)return void e(E);this._wasUsed=!0,E.extensions=E.extensions||{};const N=this._exporter._materialExporter.getTextureInfo(H.iridescence.texture),u=this._exporter._materialExporter.getTextureInfo(H.iridescence.thicknessTexture),z={iridescenceFactor:H.iridescence.XM,iridescenceIor:H.iridescence.indexOfRefraction,iridescenceThicknessMinimum:H.iridescence.minimumThickness,iridescenceThicknessMaximum:H.iridescence.maximumThickness,iridescenceTexture:N??void 0,iridescenceThicknessTexture:u??void 0};null===z.iridescenceTexture&&null===z.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(H),E.extensions[fE]=z}e(E)}))}}ke.RegisterExtension(fE,(e=>new wE(e)));const sE="KHR_materials_sheen";class pE{constructor(e){this.name=sE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,E,H){return H instanceof je.b&&H.sheen.isEnabled&&H.sheen.texture?[H.sheen.texture]:[]}async postExportMaterialAsync(e,E,H){return await new Promise((e=>{if(H instanceof je.b){if(!H.sheen.isEnabled)return void e(E);this._wasUsed=!0,null==E.extensions&&(E.extensions={});const N={sheenColorFactor:H.sheen.color.uM(),sheenRoughnessFactor:H.sheen.roughness??0};null===N.sheenColorTexture&&null===N.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(H),H.sheen.texture&&(N.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.texture)??void 0),H.sheen.textureRoughness&&!H.sheen.useRoughnessFromMainTexture?N.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.textureRoughness)??void 0:H.sheen.texture&&H.sheen.useRoughnessFromMainTexture&&(N.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.texture)??void 0),E.extensions[sE]=N}e(E)}))}}ke.RegisterExtension(sE,(e=>new pE(e)));const oE="KHR_materials_specular";class yE{constructor(e){this.name=oE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,E,H){const N=[];return H instanceof je.b&&this._isExtensionEnabled(H)?(H.metallicReflectanceTexture&&N.push(H.metallicReflectanceTexture),H.reflectanceTexture&&N.push(H.reflectanceTexture),N):N}_isExtensionEnabled(e){return!e.unlit&&(void 0!=e.metallicF0Factor&&1!=e.metallicF0Factor||void 0!=e.metallicReflectanceColor&&!e.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(e))}_hasTexturesExtension(e){return null!=e.metallicReflectanceTexture||null!=e.reflectanceTexture}postExportMaterialAsync(e,E,H){return new Promise((e=>{if(H instanceof je.b&&this._isExtensionEnabled(H)){this._wasUsed=!0,E.extensions=E.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(H.metallicReflectanceTexture)??void 0,N=this._exporter._materialExporter.getTextureInfo(H.reflectanceTexture)??void 0,u={specularFactor:1==H.metallicF0Factor?void 0:H.metallicF0Factor,specularTexture:e,specularColorFactor:H.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:H.metallicReflectanceColor.uM(),specularColorTexture:N};this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),E.extensions[oE]=u}e(E)}))}}ke.RegisterExtension(oE,(e=>new yE(e)));const bE="KHR_materials_transmission";class KE{constructor(e){this.name=bE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,E,H){const N=[];return H instanceof je.b&&this._isExtensionEnabled(H)?(H.subSurface.thicknessTexture&&N.push(H.subSurface.thicknessTexture),N):N}_isExtensionEnabled(e){if(e.unlit)return!1;const E=e.subSurface;return E.isRefractionEnabled&&void 0!=E.refractionIntensity&&0!=E.refractionIntensity||this._hasTexturesExtension(e)}_hasTexturesExtension(e){return null!=e.subSurface.refractionIntensityTexture}async postExportMaterialAsync(e,E,H){if(H instanceof je.b&&this._isExtensionEnabled(H)){this._wasUsed=!0;const N=H.subSurface,u={transmissionFactor:0===N.refractionIntensity?void 0:N.refractionIntensity};if(this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),N.refractionIntensityTexture)if(N.useGltfStyleTextures){const e=await this._exporter._materialExporter.exportTextureAsync(N.refractionIntensityTexture,"image/png");e&&(u.transmissionTexture=e)}else d.d.Warn(`${e}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);E.extensions||(E.extensions={}),E.extensions[bE]=u}return E}}ke.RegisterExtension(bE,(e=>new KE(e)));const lE="KHR_materials_unlit";class OE{constructor(){this.name=lE,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(e,E,H){return new Promise((e=>{let N=!1;H instanceof je.b?N=H.unlit:H instanceof Fe.SE&&(N=H.disableLighting),N&&(this._wasUsed=!0,null==E.extensions&&(E.extensions={}),E.extensions[lE]={}),e(E)}))}}ke.RegisterExtension(lE,(()=>new OE));const vE="KHR_materials_volume";class RE{constructor(e){this.name=vE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,E,H){const N=[];return H instanceof je.b&&this._isExtensionEnabled(H)?(H.subSurface.thicknessTexture&&N.push(H.subSurface.thicknessTexture),N):N}_isExtensionEnabled(e){if(e.unlit)return!1;const E=e.subSurface;return!(!E.isRefractionEnabled&&!E.isTranslucencyEnabled)&&(void 0!=E.maximumThickness&&0!=E.maximumThickness||void 0!=E.tintColorAtDistance&&E.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=E.tintColor&&E.tintColor!=h.XE.White()||this._hasTexturesExtension(e))}_hasTexturesExtension(e){return null!=e.subSurface.thicknessTexture}postExportMaterialAsync(e,E,H){return new Promise((e=>{if(H instanceof je.b&&this._isExtensionEnabled(H)){this._wasUsed=!0;const e=H.subSurface,N={thicknessFactor:0==e.maximumThickness?void 0:e.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(e.thicknessTexture)??void 0,attenuationDistance:e.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:e.tintColorAtDistance,attenuationColor:e.tintColor.equalsFloats(1,1,1)?void 0:e.tintColor.uM()};this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),E.extensions=E.extensions||{},E.extensions[vE]=N}e(E)}))}}ke.RegisterExtension(vE,(e=>new RE(e)));const TE="EXT_materials_diffuse_roughness";class LE{constructor(e){this.name=TE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,E,H){const N=[];return H instanceof AE.d&&H._baseDiffuseRoughness?(H._baseDiffuseRoughnessTexture&&N.push(H._baseDiffuseRoughnessTexture),N):[]}postExportMaterialAsync(e,E,H){return new Promise((e=>{if(H instanceof AE.d){if(!H._baseDiffuseRoughness)return void e(E);this._wasUsed=!0,E.extensions=E.extensions||{};const N=this._exporter._materialExporter.getTextureInfo(H._baseDiffuseRoughnessTexture),u={diffuseRoughnessFactor:H._baseDiffuseRoughness,diffuseRoughnessTexture:N??void 0};null!==u.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(H),E.extensions[TE]=u}e(E)}))}}ke.RegisterExtension(TE,(e=>new LE(e)));const dE="KHR_texture_transform";class GE{constructor(){this.name=dE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(e,E,H){if(H.fe()||u.Tools.Warn(`${e}: /*@__KEY__*/"scene" is not defined for Babylon texture ${H.name}!`),(0!==H.uAng||0!==H.vAng)&&(u.Tools.Warn(`${e}: Texture ${H.name} with rotation in the u or v axis is not supported in glTF.`),0!==H.uRotationCenter||0!==H.vRotationCenter))return;const N={};let z=!1;if(0===H.uOffset&&0===H.vOffset||(N.offset=[H.uOffset,H.vOffset],z=!0),1===H.uScale&&1===H.vScale||(N.scale=[H.uScale,H.vScale],z=!0),0!==H.wAng){if(0!==H.uRotationCenter||0!==H.vRotationCenter){if(H.homogeneousRotationInUVTransform&&H.uScale!==H.vScale)return void u.Tools.Warn(`${e}: Texture ${H.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${dE}.`);u.Tools.Warn(`${e}: Texture ${H.name} with non-origin rotation center will be exported using an adjusted offset with ${dE}.`),N.offset=function(e){const{uOffset:E,vOffset:H,uRotationCenter:N,vRotationCenter:u,uScale:z,vScale:P,wAng:M}=e,D=Math.cos(M),A=Math.sin(M),C=N*z,i=u*P;return[E+(C*(1-D)+i*A),H+(i*(1-D)-C*A)]}(H)}N.rotation=-H.wAng,z=!0}0!==H.coordinatesIndex&&(N.texCoord=H.coordinatesIndex,z=!0),z&&(this._wasUsed=!0,E.extensions||(E.extensions={}),E.extensions[dE]=N)}}ke.RegisterExtension(dE,(()=>new GE));class mH{static CreateSTL(e){let E=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",u=arguments.length>3&&void 0!==arguments[3]&&arguments[3],z=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],P=arguments.length>5&&void 0!==arguments[5]&&arguments[5],M=arguments.length>6&&void 0!==arguments[6]&&arguments[6],D=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const A=function(e,E,H){const u=[3*e[H],3*e[H+1],3*e[H+2]],z=[new N.jE(E[u[0]],E[u[0]+2],E[u[0]+1]),new N.jE(E[u[1]],E[u[1]+2],E[u[1]+1]),new N.jE(E[u[2]],E[u[2]+2],E[u[2]+1])],P=z[0].FE(z[1]),M=z[2].FE(z[1]);return{v:z,n:N.jE.Cross(M,P).normalize()}},i=function(e,E,H,N){return E=V(e,E,H.x,N),E=V(e,E,H.y,N),V(e,E,H.z,N)},V=function(e,E,H,N){return e.setFloat32(E,H,N),E+4},j=function(e){if(M){let E=e;e instanceof U.b&&(E=e.sourceMesh);const H=E.getVerticesData(C.g.PositionKind,!0,!0);if(!H)return[];const u=N.jE.Zero();let z;for(z=0;z<H.length;z+=3)N.jE.TransformCoordinatesFromFloatsToRef(H[z],H[z+1],H[z+2],e.DM(!0),u).toArray(H,z);return H}return e.getVerticesData(C.g.PositionKind)||[]};M&&(P=!0);let F="",h=0,S=0;if(u){for(let H=0;H<e.length;H++){const E=e[H].CM();h+=E?E.length/3:0}const E=new ArrayBuffer(84+50*h);F=new DataView(E),S+=80,F.setUint32(S,h,z),S+=4}else D||(F="solid stlmesh\r\n");for(let N=0;N<e.length;N++){const E=e[N];!u&&D&&(F+="solid "+E.name+"\r\n"),!P&&E instanceof Xe.c&&E.bakeCurrentTransformIntoVertices();const H=j(E),M=E.CM()||[];for(let e=0;e<M.length;e+=3){const E=A(M,H,e);u?(S=i(F,S,E.n,z),S=i(F,S,E.v[0],z),S=i(F,S,E.v[1],z),S=i(F,S,E.v[2],z),S+=2):(F+="\tfacet normal "+E.n.x+" "+E.n.y+" "+E.n.z+"\r\n",F+="\t\touter loop\r\n",F+="\t\t\tvertex "+E.v[0].x+" "+E.v[0].y+" "+E.v[0].z+"\r\n",F+="\t\t\tvertex "+E.v[1].x+" "+E.v[1].y+" "+E.v[1].z+"\r\n",F+="\t\t\tvertex "+E.v[2].x+" "+E.v[2].y+" "+E.v[2].z+"\r\n",F+="\t\tendloop\r\n",F+="\tendfacet\r\n")}!u&&D&&(F+="endsolid "+name+"\r\n")}if(u||D||(F+="endsolid stlmesh"),E){const e=document.createElement("a"),E=new Blob([F],{type:"application/octet-stream"});e.href=window.URL.createObjectURL(E),e.download=H+".stl",e.click()}return F}}function QE(e,E){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const N=[];for(let u=0;u<e.length/H;u++){const z=e[u*H],P=e[u*H+1],M=e[u*H+2];N.push(`(${z.toPrecision(E.precision)}, ${P.toPrecision(E.precision)}, ${M.toPrecision(E.precision)})`)}return N.join(", ")}function ZE(e,E){const H=[];for(let N=0;N<e.length/2;N++){const u=e[2*N],z=e[2*N+1];H.push(`(${u.toPrecision(E.precision)}, ${(1-z).toPrecision(E.precision)})`)}return H.join(", ")}function kE(e,E){const H=e.getVerticesData(C.g.PositionKind),N=e.getVerticesData(C.g.NormalKind);if(H&&N)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(e){var E;const H=null!==(E=e.CM())&&void 0!==E&&E.length?e.getTotalIndices():e.getTotalVertices();return Array(H/3).fill(3).join(", ")}(e)}]\n\t\tint[] faceVertexIndices = [${function(e){const E=e.CM(),H=[];if(null!==E)for(let N=0;N<E.length;N++)H.push(E[N]);else{const E=e.getTotalVertices();for(let e=0;e<E;e++)H.push(e)}return H.join(", ")}(e)}]\n\t\tnormal3f[] normals = [${QE(N,E)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${QE(H,E)}]\n        ${function(e,E){let H="";for(let u=0;u<4;u++){const N=u>0?u:"",z=e.getVerticesData(C.g.UVKind+(N?N+1:""));z&&(H+=`\n\t\ttexCoord2f[] primvars:st${N} = [${ZE(z,E)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const N=e.getVerticesData(C.g.ColorKind);return N&&(H+=`\n\tcolor3f[] primvars:displayColor = [${QE(N,E,N.length/e.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),H}(e,E)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function JE(e,E){return`\n        def "Geometry"\n        {\n        ${kE(e,E)}\n        }\n        `}function BE(e){let E='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return E+=e,fflate.strToU8(E)}function IE(e){const E=e.m;return`( ${tE(E,0)}, ${tE(E,4)}, ${tE(E,8)}, ${tE(E,12)} )`}function tE(e,E){return`(${e[E+0]}, ${e[E+1]}, ${e[E+2]}, ${e[E+3]})`}function qE(e){const E="Object_"+e.uniqueId,H=function(e){const E=e.getWorldMatrix().clone(),H=e.fe().useRightHandedSystem;if(!H){let N=e.parent;for(;N;){if(Pe(N,H)){E.multiplyToRef(N.getWorldMatrix().invert(),E);break}N=N.parent}}return E.determinant()<0&&u.Tools.Warn(`Exporting mesh ${e.name} with negative scale. Result may look incorrect in destination engine.`),E}(e),N=IE(H);return`def Xform "${E}" (\n\tprepend references = @./geometries/Geometry_${e.AM.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${N}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${e.material.uniqueId}>\n}\n\n`}function cE(e){switch(e){case f.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case f.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case f.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function nE(e){return`(${e.x}, ${e.y})`}function gE(e){return`(${e.r}, ${e.g}, ${e.b})`}function xE(e,E,H,u,z,P){const M=e.getInternalTexture().uniqueId+"_"+e.invertY;z[M]=e;const D=e.coordinatesIndex>0?"st"+e.coordinatesIndex:"st",A=new N.Vector2(e.uScale,e.vScale),C=new N.Vector2(e.uOffset,e.vOffset),i=e.wAng,V=Math.sin(i),U=Math.cos(i);return C.y=1-C.y-A.y,C.x+=V*A.x,C.y+=(1-U)*A.y,`\n    def Shader "PrimvarReader_${H}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${D}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${H}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${E.uniqueId}/PrimvarReader_${H}.outputs:result>\n        float inputs:rotation = ${(i*(180/Math.PI)).toFixed(P.precision)}\n        float2 inputs:scale = ${nE(A)}\n        float2 inputs:translation = ${nE(C)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${e.uniqueId}_${H}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${M}.png@\n        float2 inputs:st.connect = </Materials/Material_${E.uniqueId}/Transform2d_${H}.outputs:result>\n        ${u?"float4 inputs:scale = "+function(e){return`(${e.r}, ${e.g}, ${e.b}, 1.0)`}(u):""}\n        token inputs:sourceColorSpace = "${e.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${cE(e.wrapU)}"\n        token inputs:wrapT = "${cE(e.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${E.needAlphaBlending()?"float outputs:a":""}\n    }`}function eH(e,E,H){const N="\t\t\t",u=[],z=[],{diffuseMap:P,aM:M,alphaCutOff:D,emissiveMap:A,emissive:C,normalMap:i,roughnessMap:V,roughnessChannel:U,roughness:j,metalnessMap:F,metalnessChannel:S,metalness:X,aoMap:a,aoMapChannel:W,aoMapIntensity:r,alphaMap:Y,ior:f,clearCoatEnabled:w,clearCoat:s,clearCoatMap:p,clearCoatRoughness:o,clearCoatRoughnessMap:y}=function(e){const E={diffuseMap:null,aM:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return e instanceof Fe.SE?{...E,diffuseMap:e.diffuseTexture,aM:e.diffuseColor,alphaCutOff:e.alphaCutOff,emissiveMap:e.emissiveTexture,emissive:e.emissiveColor,roughness:1,alphaMap:e.opacityTexture}:e instanceof AE.d?{...E,diffuseMap:e._albedoTexture,aM:e._albedoColor,alphaCutOff:e._alphaCutOff,emissiveMap:e._emissiveTexture,emissive:e._emissiveColor,normalMap:e._bumpTexture,roughnessMap:e._metallicTexture,roughnessChannel:e._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:e._roughness??1,metalnessMap:e._metallicTexture,metalnessChannel:e._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:e._metallic??0,aoMap:e._ambientTexture,aoMapChannel:e._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:e._ambientTextureStrength,alphaMap:e._opacityTexture,ior:e.subSurface.indexOfRefraction,clearCoatEnabled:e.clearCoat.isEnabled,clearCoat:e.clearCoat.XM,clearCoatMap:e.clearCoat.texture,clearCoatRoughness:e.clearCoat.roughness,clearCoatRoughnessMap:e.clearCoat.useRoughnessFromMainTexture?e.clearCoat.texture:e.clearCoat.textureRoughness}:E}(e);return null!==P?(u.push(`${N}color3f inputs:diffuseColor.connect = </Materials/Material_${e.uniqueId}/Texture_${P.uniqueId}_diffuse.outputs:rgb>`),e.needAlphaBlending()?u.push(`${N}float inputs:opacity.connect = </Materials/Material_${e.uniqueId}/Texture_${P.uniqueId}_diffuse.outputs:a>`):e.needAlphaTesting()&&(u.push(`${N}float inputs:opacity.connect = </Materials/Material_${e.uniqueId}/Texture_${P.uniqueId}_diffuse.outputs:a>`),u.push(`${N}float inputs:opacityThreshold = ${D}`)),z.push(xE(P,e,"diffuse",M,E,H))):u.push(`${N}color3f inputs:diffuseColor = ${gE(M||h.XE.White())}`),null!==A?(u.push(`${N}color3f inputs:emissiveColor.connect = </Materials/Material_${e.uniqueId}/Texture_${A.uniqueId}_emissive.outputs:rgb>`),z.push(xE(A,e,"emissive",C,E,H))):C&&C.toLuminance()>0&&u.push(`${N}color3f inputs:emissiveColor = ${gE(C)}`),null!==i&&(u.push(`${N}normal3f inputs:normal.connect = </Materials/Material_${e.uniqueId}/Texture_${i.uniqueId}_normal.outputs:rgb>`),z.push(xE(i,e,"normal",null,E,H))),null!==a&&(u.push(`${N}float inputs:occlusion.connect = </Materials/Material_${e.uniqueId}/Texture_${a.uniqueId}_occlusion.outputs:${W}>`),z.push(xE(a,e,"occlusion",new h.XE(r,r,r),E,H))),null!==V?(u.push(`${N}float inputs:roughness.connect = </Materials/Material_${e.uniqueId}/Texture_${V.uniqueId}_roughness.outputs:${U}>`),z.push(xE(V,e,"roughness",new h.XE(j,j,j),E,H))):u.push(`${N}float inputs:roughness = ${j}`),null!==F?(u.push(`${N}float inputs:metallic.connect = </Materials/Material_${e.uniqueId}/Texture_${F.uniqueId}_metallic.outputs:${S}>`),z.push(xE(F,e,"metallic",new h.XE(X,X,X),E,H))):u.push(`${N}float inputs:metallic = ${X}`),null!==Y?(u.push(`${N}float inputs:opacity.connect = </Materials/Material_${e.uniqueId}/Texture_${Y.uniqueId}_opacity.outputs:r>`),u.push(`${N}float inputs:opacityThreshold = 0.0001`),z.push(xE(Y,e,"opacity",null,E,H))):u.push(`${N}float inputs:opacity = ${e.alpha}`),w&&(null!==p?(u.push(`${N}float inputs:clearcoat.connect = </Materials/Material_${e.uniqueId}/Texture_${p.uniqueId}_clearcoat.outputs:r>`),z.push(xE(p,e,"clearcoat",new h.XE(s,s,s),E,H))):u.push(`${N}float inputs:clearcoat = ${s}`),null!==y?(u.push(`${N}float inputs:clearcoatRoughness.connect = </Materials/Material_${e.uniqueId}/Texture_${y.uniqueId}_clearcoatRoughness.outputs:g>`),z.push(xE(y,e,"clearcoatRoughness",new h.XE(o,o,o),E,H))):u.push(`${N}float inputs:clearcoatRoughness = ${o}`)),u.push(`${N}float inputs:ior = ${f}`),`\n\tdef Material "Material_${e.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${u.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${e.uniqueId}/PreviewSurface.outputs:surface>\n\n${z.join("\n")}\n\n\t}\n`}async function EH(e,E,H){const z={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...E};"undefined"===typeof fflate&&await u.Tools.LoadScriptAsync(z.fflateUrl);const P={};P[z.modelFileName]=null;let M='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';M+=function(e){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===e.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${e.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${e.planeAnchoringAlignment}"`:""}\n            `}(z);const D={};for(const N of e.meshes){if(0===N.getTotalVertices())continue;const e=N,E=e.AM,A=e.material;if(!A||!E||H&&!H(e))continue;if(-1!==["SE","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(A.getClassName())){const H="geometries/Geometry_"+E.uniqueId+".usda";if(!(H in P)){const e=JE(E,z);P[H]=BE(e)}A.uniqueId in D||(D[A.uniqueId]=A),M+=qE(e)}else u.Tools.Warn("USDZExportAsync does not support this material type: "+A.getClassName())}e.activeCamera&&z.exportCamera&&(M+=function(e,E){const H="Camera_"+e.uniqueId,u=IE(N.Matrix.RotationY(Math.PI).multiply(e.getWorldMatrix()));if(e.mode===f.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${H}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${u}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${e.PM.toPrecision(E.precision)}, ${e.maxZ.toPrecision(E.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(e.orthoLeft||1)+Math.abs(e.orthoRight||1))).toPrecision(E.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(e.orthoTop||1)+Math.abs(e.orthoBottom||1))).toPrecision(E.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const N=e.getEngine().getAspectRatio(e),z=E.cameraSensorWidth||35;return`def Camera "${H}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${u}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${e.PM.toPrecision(E.precision)}, ${e.maxZ.toPrecision(E.precision)})\n\t\t\tfloat focalLength = ${(z/(2*Math.tan(.5*e.fov))).toPrecision(E.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(z*N).toPrecision(E.precision)}\n\t\t\tfloat verticalAperture = ${(z/N).toPrecision(E.precision)}            \n\t\t}\n\t\n\t`}}(e.activeCamera,z)),M+="\n            }\n        }\n    }";const A={};M+=function(e,E,H){const N=[];for(const u in e){const z=e[u];N.push(eH(z,E,H))}return`\n    def "Materials"\n{\n${N.join("")}\n}\n\n`}(D,A,z),P[z.modelFileName]=fflate.strToU8(M);for(const N in A){const e=A[N],E=e.getSize(),H=await e.readPixels();if(!H)throw new Error("Texture data is not available");const u=await w.DumpTools.DumpDataAsync(E.width,E.height,H,"image/png",void 0,!1,!0);P[`textures/Texture_${N}.png`]=new Uint8Array(u).slice()}let C=0;for(const N in P){const e=P[N];if(!e)continue;C+=34+N.length;const E=63&C;if(4!==E){const H=new Uint8Array(64-E);P[N]=[e,{extra:{12345:H}}]}C=e.length}return fflate.zipSync(P,{level:0})}}}]);