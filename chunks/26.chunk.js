"use strict";(self.ex92n20nlz8=self.ex92n20nlz8||[]).push([[26],{12989:(I,g,b)=>{b.r(g),b.d(g,{EXT_materials_diffuse_roughness:()=>Ag,EXT_mesh_gpu_instancing:()=>tI,GLTF2Export:()=>PI,GLTFData:()=>n,KHR_draco_mesh_compression:()=>bg,KHR_lights_punctual:()=>og,KHR_materials_anisotropy:()=>Dg,KHR_materials_clearcoat:()=>xg,KHR_materials_diffuse_transmission:()=>Sg,KHR_materials_dispersion:()=>Vg,KHR_materials_emissive_strength:()=>vg,KHR_materials_ior:()=>Rg,KHR_materials_iridescence:()=>mb,KHR_materials_sheen:()=>Fg,KHR_materials_specular:()=>dg,KHR_materials_transmission:()=>rg,KHR_materials_unlit:()=>Hg,KHR_materials_volume:()=>Ug,KHR_texture_transform:()=>Qg,OBJExport:()=>M,STLExport:()=>Lg,USDZExportAsync:()=>gb,_ConvertToGLTFPBRMetallicRoughness:()=>O,_SolveMetallic:()=>r,__IGLTFExporterExtension:()=>J});var e=b(12590),c=b(12409),z=b(12901);class M{static OBJ(I,g,b,M){const J=[];let o=1,n=1;g&&(b||(b="mat"),J.push("mtllib "+b+".mtl"));for(let G=0;G<I.length;G++){const b=I[G],D=b.name||`mesh${G}}`;J.push(`o ${D}`);let p=null;if(M){const I=b.Mb(!0);p=new e.Matrix,I.invertToRef(p),b.bakeTransformIntoVertices(I)}if(g){const I=b.material;I&&J.push("usemtl "+I.id)}const x=b.ob;if(!x){c.Tools.Warn("No geometry is present on the mesh");continue}const Z=x.getVerticesData("position"),k=x.getVerticesData("normal"),S=x.getVerticesData("uv"),f=x.nb();let V=0,a=0;if(!Z||!f){c.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const v=I[0].EI().useRightHandedSystem?1:-1;for(let I=0;I<Z.length;I+=3)J.push("v "+Z[I]*v+" "+Z[I+1]+" "+Z[I+2]),V++;if(null!=k)for(let I=0;I<k.length;I+=3)J.push("vn "+k[I]*v+" "+k[I+1]+" "+k[I+2]);if(null!=S)for(let I=0;I<S.length;I+=2)J.push("vt "+S[I]+" "+S[I+1]),a++;const X=["","",""],R=(b.material||b.EI().defaultMaterial)._getEffectiveOrientation(b),[E,mI]=R===z.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let I=0;I<f.length;I+=3){const g=[String(f[I]+o),String(f[I+E]+o),String(f[I+mI]+o)],b=[String(f[I]+n),String(f[I+E]+n),String(f[I+mI]+n)],e=g,c=null!=S?b:X,z=null!=k?g:X;J.push("f "+e[0]+"/"+c[0]+"/"+z[0]+" "+e[1]+"/"+c[1]+"/"+z[1]+" "+e[2]+"/"+c[2]+"/"+z[2])}M&&p&&b.bakeTransformIntoVertices(p),o+=V,n+=a}return J.join("\n")}static MTL(I){const g=[],b=I.material;g.push("newmtl mat1"),g.push("  Ns "+b.specularPower.toFixed(4)),g.push("  Ni 1.5000"),g.push("  d "+b.alpha.toFixed(4)),g.push("  Tr 0.0000"),g.push("  Tf 1.0000 1.0000 1.0000"),g.push("  illum 2"),g.push("  Ka "+b.ambientColor.r.toFixed(4)+" "+b.ambientColor.g.toFixed(4)+" "+b.ambientColor.b.toFixed(4)),g.push("  Kd "+b.diffuseColor.r.toFixed(4)+" "+b.diffuseColor.g.toFixed(4)+" "+b.diffuseColor.b.toFixed(4)),g.push("  Ks "+b.specularColor.r.toFixed(4)+" "+b.specularColor.g.toFixed(4)+" "+b.specularColor.b.toFixed(4)),g.push("  Ke "+b.emissiveColor.r.toFixed(4)+" "+b.emissiveColor.g.toFixed(4)+" "+b.emissiveColor.b.toFixed(4));b.ambientTexture&&g.push("  map_Ka "+b.ambientTexture.name),b.diffuseTexture&&g.push("  map_Kd "+b.diffuseTexture.name),b.specularTexture&&g.push("  map_Ks "+b.specularTexture.name),b.bumpTexture&&g.push("  map_bump -imfchan z "+b.bumpTexture.name),b.opacityTexture&&g.push("  map_d "+b.opacityTexture.name);return g.join("\n")}}var J=0,o=b(12456);class n{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const I in this.files){const g=this.files[I],b=new Blob([g],{type:(0,o.h)(I)});c.Tools.Download(b,I)}}}var G=b(12659),D=b(12995),p=b(13006),x=b(13021),Z=b(12718),k=b(12449),S=b(12637),f=b(12610);const V=f.HighestCommonFactor,a={...f,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:V};var v=b(12803),X=b(12572),R=b(13050),E=b(13058),mI=b(12796);const s=1e-6,F=new S.Eg(.04,.04,.04),Y=1024,d=S.Eg.White(),C=S.Eg.Black();function r(I,g,b){if(g<F.r)return 0;const e=F.r,c=I*b/(1-F.r)+g-2*F.r,z=c*c-4*e*(F.r-g);return a.Clamp((-c+Math.sqrt(z))/(2*e),0,1)}function O(I){const g=I.diffuseColor.toLinearSpace(I.EI().getEngine().useExactSrgbConversions).scale(.5),b=I.alpha,c=function(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new e.Vector2(0,1),b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new e.Vector2(0,.1),c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new e.Vector2(0,.1),z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new e.Vector2(1300,.1);return function(I,g,b,e,c){return(1-I)*(1-I)*(1-I)*g+3*(1-I)*(1-I)*I*b+3*(1-I)*I*I*e+I*I*I*c}(Math.pow(I/z.x,.333333),g.y,b.y,c.y,z.y)}(a.Clamp(I.specularPower,0,Y));return{baseColorFactor:[g.r,g.g,g.b,b],metallicFactor:0,roughnessFactor:c}}function H(I,g){g.needAlphaBlending()?I.alphaMode="BLEND":g.needAlphaTesting()&&(I.alphaMode="MASK",I.alphaCutoff=g.alphaCutOff)}function i(I,g,b){const e=new Uint8Array(I*g*4);for(let c=0;c<e.length;c+=4)e[c]=e[c+1]=e[c+2]=e[c+3]=255;return R.b.CreateRGBATexture(e,I,g,b)}function U(I){if(I instanceof Uint8Array){const g=I.length,b=new Float32Array(I.length);for(let e=0;e<g;++e)b[e]=I[e]/255;return b}if(I instanceof Float32Array)return I;throw new Error("Unsupported pixel format!")}class h{constructor(I){this._exporter=I,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(I){return I?this._textureMap.get(I)??null:null}async exportStandardMaterialAsync(I,g,b){const e=O(I),z={name:I.name};if(null==I.Gb||I.Gb||(I.twoSidedLighting||c.Tools.Warn(I.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),z.doubleSided=!0),b){const b=[],c=I.diffuseTexture;c&&b.push(this.exportTextureAsync(c,g).then((I=>{I&&(e.baseColorTexture=I)})));const M=I.bumpTexture;M&&b.push(this.exportTextureAsync(M,g).then((I=>{I&&(z.normalTexture=I,1!==M.level&&(z.normalTexture.scale=M.level))})));const J=I.emissiveTexture;J&&(z.emissiveFactor=[1,1,1],b.push(this.exportTextureAsync(J,g).then((I=>{I&&(z.emissiveTexture=I)}))));const o=I.ambientTexture;o&&b.push(this.exportTextureAsync(o,g).then((I=>{if(I){const g={index:I.index};z.occlusionTexture=g}}))),b.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(b))}(I.alpha<1||I.opacityTexture)&&(I.alphaMode===E.e.ALPHA_COMBINE?z.alphaMode="BLEND":c.Tools.Warn(I.name+": glTF 2.0 does not support alpha mode: "+I.alphaMode.toString())),I.emissiveColor&&!I.emissiveColor.equalsWithEpsilon(C,s)&&(z.emissiveFactor=I.emissiveColor.bb()),z.pbrMetallicRoughness=e,H(z,I),await this._finishMaterialAsync(z,I,g);const M=this._exporter._materials;return M.push(z),M.length-1}async _finishMaterialAsync(I,g,b){const e=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",I,g),c=[];for(const z of e)c.push(this.exportTextureAsync(z,b));await Promise.all(c),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",I,g)}async _getImageDataAsync(I,g,e,c){const z=E.e.TEXTURETYPE_UNSIGNED_BYTE,M=this._exporter._babylonScene,J=M.getEngine(),o=J.createRawTexture(I,g,e,E.e.TEXTUREFORMAT_RGBA,!1,!0,X.b.NEAREST_SAMPLINGMODE,null,z);J.isWebGPU?await b.e(51).then(b.bind(b,15035)):await b.e(52).then(b.bind(b,15040)),await v.l.ApplyPostProcess("pass",o,M,z,E.e.TEXTURE_NEAREST_SAMPLINGMODE,E.e.TEXTUREFORMAT_RGBA);const n=await J._readTexturePixels(o,g,e);return await mI.DumpTools.DumpDataAsync(g,e,n,c,void 0,!0,!0)}_resizeTexturesToSameDimensions(I,g,b){const e=I?I.getSize():{width:0,height:0},c=g?g.getSize():{width:0,height:0};let z,M;return e.width<c.width?(z=I&&I instanceof X.b?v.l.CreateResizedCopy(I,c.width,c.height,!0):i(c.width,c.height,b),M=g):e.width>c.width?(M=g&&g instanceof X.b?v.l.CreateResizedCopy(g,e.width,e.height,!0):i(e.width,e.height,b),z=I):(z=I,M=g),{texture1:z,texture2:M}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(I,g,b,e){const c=new Array;if(!I&&!g)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const z=I?I.EI():g?g.EI():null;if(z){var M;const J=this._resizeTexturesToSameDimensions(I,g,z),o=null===(M=J.texture1)||void 0===M?void 0:M.getSize();let n,G;const D=o.width,p=o.height,x=await J.texture1.readPixels(),Z=await J.texture2.readPixels();if(!x)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(n=U(x),!Z)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");G=U(Z);const k=G.byteLength,f=new Uint8Array(k),V=new Uint8Array(k),a=4,v=C;let X=0,R=0;for(let I=0;I<p;++I)for(let g=0;g<D;++g){const e=(D*I+g)*a,c={diffuseColor:new S.Eg(n[e],n[e+1],n[e+2]).toLinearSpace(z.getEngine().useExactSrgbConversions).multiply(b.diffuseColor),specularColor:new S.Eg(G[e],G[e+1],G[e+2]).toLinearSpace(z.getEngine().useExactSrgbConversions).multiply(b.specularColor),glossiness:G[e+3]*b.glossiness},M=this._convertSpecularGlossinessToMetallicRoughness(c);v.r=Math.max(v.r,M.baseColor.r),v.g=Math.max(v.g,M.baseColor.g),v.b=Math.max(v.b,M.baseColor.b),X=Math.max(X,M.metallic),R=Math.max(R,M.roughness),V[e]=255*M.baseColor.r,V[e+1]=255*M.baseColor.g,V[e+2]=255*M.baseColor.b,V[e+3]=J.texture1.eb?255*n[e+3]:255,f[e]=0,f[e+1]=255*M.roughness,f[e+2]=255*M.metallic,f[e+3]=255}const E={baseColor:v,metallic:X,roughness:R};let mI=!1,F=!1;for(let I=0;I<p;++I)for(let g=0;g<D;++g){const b=(D*I+g)*a;V[b]/=E.baseColor.r>s?E.baseColor.r:1,V[b+1]/=E.baseColor.g>s?E.baseColor.g:1,V[b+2]/=E.baseColor.b>s?E.baseColor.b:1;const e=S.Eg.FromInts(V[b],V[b+1],V[b+2]).toGammaSpace(z.getEngine().useExactSrgbConversions);V[b]=255*e.r,V[b+1]=255*e.g,V[b+2]=255*e.b,e.equalsWithEpsilon(d,s)||(F=!0),f[b+1]/=E.roughness>s?E.roughness:1,f[b+2]/=E.metallic>s?E.metallic:1;S.Eg.FromInts(255,f[b+1],f[b+2]).equalsWithEpsilon(d,s)||(mI=!0)}return mI&&c.push(this._getImageDataAsync(f,D,p,e).then((I=>{E.metallicRoughnessTextureData=I}))),F&&c.push(this._getImageDataAsync(V,D,p,e).then((I=>{E.baseColorTextureData=I}))),await Promise.all(c).then((()=>E))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(I){const g=this._getPerceivedBrightness(I.diffuseColor),b=this._getPerceivedBrightness(I.specularColor),e=1-this._getMaxComponent(I.specularColor),c=r(g,b,e),z=I.diffuseColor.scale(e/(1-F.r)/Math.max(1-c)),M=I.specularColor.ag(F.scale(1-c)).scale(1/Math.max(c));let J=S.Eg.Lerp(z,M,c*c);J=J.clampToRef(0,1,J);return{baseColor:J,metallic:c,roughness:1-I.glossiness}}_getPerceivedBrightness(I){return I?Math.sqrt(.299*I.r*I.r+.587*I.g*I.g+.114*I.b*I.b):0}_getMaxComponent(I){return I?Math.max(I.r,Math.max(I.g,I.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(I,g,b,e){const c=[],z={baseColor:I._albedoColor,metallic:I._metallic,roughness:I._roughness};if(e){I._albedoTexture&&c.push(this.exportTextureAsync(I._albedoTexture,g).then((I=>{I&&(b.baseColorTexture=I)})));const e=I._metallicTexture;e&&c.push(this.exportTextureAsync(e,g).then((I=>{I&&(b.metallicRoughnessTexture=I)})))}return c.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(c)),z}_getTextureSampler(I){const g={};if(!I||!(I instanceof X.b))return g;const b=this._getGLTFTextureWrapMode(I.wrapU);10497!==b&&(g.wrapS=b);const e=this._getGLTFTextureWrapMode(I.wrapV);switch(10497!==e&&(g.wrapT=e),I.samplingMode){case X.b.LINEAR_LINEAR:g.magFilter=9729,g.minFilter=9729;break;case X.b.LINEAR_NEAREST:g.magFilter=9729,g.minFilter=9728;break;case X.b.NEAREST_LINEAR:g.magFilter=9728,g.minFilter=9729;break;case X.b.NEAREST_LINEAR_MIPLINEAR:g.magFilter=9728,g.minFilter=9987;break;case X.b.NEAREST_NEAREST:g.magFilter=9728,g.minFilter=9728;break;case X.b.NEAREST_LINEAR_MIPNEAREST:g.magFilter=9728,g.minFilter=9985;break;case X.b.LINEAR_NEAREST_MIPNEAREST:g.magFilter=9729,g.minFilter=9984;break;case X.b.LINEAR_NEAREST_MIPLINEAR:g.magFilter=9729,g.minFilter=9986;break;case X.b.NEAREST_NEAREST_MIPLINEAR:g.magFilter=9728,g.minFilter=9986;break;case X.b.LINEAR_LINEAR_MIPLINEAR:g.magFilter=9729,g.minFilter=9987;break;case X.b.LINEAR_LINEAR_MIPNEAREST:g.magFilter=9729,g.minFilter=9985;break;case X.b.NEAREST_NEAREST_MIPNEAREST:g.magFilter=9728,g.minFilter=9984}return g}_getGLTFTextureWrapMode(I){switch(I){case X.b.WRAP_ADDRESSMODE:return 10497;case X.b.CLAMP_ADDRESSMODE:return 33071;case X.b.MIRROR_ADDRESSMODE:return 33648;default:return c.Tools.Error(`Unsupported Texture Wrap Mode ${I}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(I,g,b,e){const c={diffuseColor:I._albedoColor,specularColor:I._reflectivityColor,glossiness:I._microSurface},z=I._albedoTexture,M=I._reflectivityTexture,J=I._useMicroSurfaceFromReflectivityMapAlpha;if(M&&!J)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((z||M)&&e){this._exporter._materialNeedsUVsSet.add(I);const e=this._exportTextureSampler(z||M),J=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(z,M,c,g),o=this._exporter._textures;if(J.baseColorTextureData){const I=this._exportImage(`baseColor${o.length}`,g,J.baseColorTextureData);b.baseColorTexture=this._exportTextureInfo(I,e,null===z||void 0===z?void 0:z.coordinatesIndex)}if(J.metallicRoughnessTextureData){const I=this._exportImage(`metallicRoughness${o.length}`,g,J.metallicRoughnessTextureData);b.metallicRoughnessTexture=this._exportTextureInfo(I,e,null===M||void 0===M?void 0:M.coordinatesIndex)}return J}return this._convertSpecularGlossinessToMetallicRoughness(c)}async exportPBRMaterialAsync(I,g,b){const e={},c={name:I.name},z=I.isMetallicWorkflow();if(z){const g=I._albedoColor,b=I.alpha;g&&(e.baseColorFactor=[g.r,g.g,g.b,b])}const M=z?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(I,g,e,b):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(I,g,e,b);await this._setMetallicRoughnessPbrMaterialAsync(M,I,c,e,g,b),await this._finishMaterialAsync(c,I,g);const J=this._exporter._materials;return J.push(c),J.length-1}async _setMetallicRoughnessPbrMaterialAsync(I,g,b,e,z,M){if(H(b,g),I.baseColor.equalsWithEpsilon(d,s)&&a.WithinEpsilon(g.alpha,1,s)||(e.baseColorFactor=[I.baseColor.r,I.baseColor.g,I.baseColor.b,g.alpha]),null!=I.metallic&&1!==I.metallic&&(e.metallicFactor=I.metallic),null!=I.roughness&&1!==I.roughness&&(e.roughnessFactor=I.roughness),null==g.Gb||g.Gb||(g._twoSidedLighting||c.Tools.Warn(g.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),b.doubleSided=!0),M){const I=[],e=g._bumpTexture;e&&I.push(this.exportTextureAsync(e,z).then((I=>{I&&(b.normalTexture=I,1!==e.level&&(b.normalTexture.scale=e.level))})));const c=g._ambientTexture;c&&I.push(this.exportTextureAsync(c,z).then((I=>{if(I){const e={index:I.index,texCoord:I.texCoord,extensions:I.extensions};b.occlusionTexture=e;const c=g._ambientTextureStrength;c&&(e.strength=c)}})));const M=g._emissiveTexture;M&&I.push(this.exportTextureAsync(M,z).then((I=>{I&&(b.emissiveTexture=I)}))),I.length>0&&(this._exporter._materialNeedsUVsSet.add(g),await Promise.all(I))}const J=g._emissiveColor;J.equalsWithEpsilon(C,s)||(b.emissiveFactor=J.bb()),b.pbrMetallicRoughness=e}_getPixelsFromTextureAsync(I){return function(I){switch(I){case E.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case E.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case E.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case E.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case E.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case E.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case E.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case E.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case E.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case E.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case E.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case E.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case E.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case E.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case E.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case E.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case E.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case E.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case E.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case E.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case E.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(I.textureFormat)?(0,v.h)(I,I._texture.width,I._texture.height):(I.textureType,E.e.TEXTURETYPE_UNSIGNED_BYTE,I.readPixels())}async exportTextureAsync(I,g){const b=this._exporter._extensionsPreExportTextureAsync("exporter",I,g);return b?await b.then((async b=>b?await this._exportTextureInfoAsync(b,g):await this._exportTextureInfoAsync(I,g))):await this._exportTextureInfoAsync(I,g)}async _exportTextureInfoAsync(I,g){let b=this._textureMap.get(I);if(!b){const e=await this._getPixelsFromTextureAsync(I);if(!e)return null;const z=this._exportTextureSampler(I),M=I.mimeType;if(M)switch(M){case"image/jpeg":case"image/png":case"image/webp":g=M;break;default:c.Tools.Warn(`Unsupported media type: ${M}. Exporting texture as PNG.`)}const J=this._internalTextureToImage,o=I.getInternalTexture().uniqueId;J[o]||(J[o]={});let n=J[o][g];if(void 0===n){const b=I.getSize();n=(async()=>{const c=await this._getImageDataAsync(e,b.width,b.height,g);return this._exportImage(I.name,g,c)})(),J[o][g]=n}b=this._exportTextureInfo(await n,z,I.coordinatesIndex),this._textureMap.set(I,b),this._exporter._extensionsPostExportTextures("exporter",b,I)}return b}_exportImage(I,g,b){const e=this._exporter._images;let z;if(this._exporter._shouldUseGlb){z={name:I,mimeType:g,bufferView:void 0};const e=this._exporter._bufferManager.createBufferView(new Uint8Array(b));this._exporter._bufferManager.setBufferView(z,e)}else{const M=I.replace(/\.\/|\/|\.\\|\\/g,"_"),J=function(I){switch(I){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(g);let o=M+J;e.some((I=>I.uri===o))&&(o=`${M}_${c.Tools.RandomId()}${J}`),z={name:I,uri:o},this._exporter._imageData[o]={data:b,mimeType:g}}return e.push(z),e.length-1}_exportTextureInfo(I,g,b){const e=this._exporter._textures;let c=e.findIndex((b=>b.sampler==g&&b.source===I));-1===c&&(c=e.length,e.push({source:I,sampler:g}));const z={index:c};return b&&(z.texCoord=b),z}_exportTextureSampler(I){const g=this._getTextureSampler(I),b=this._exporter._samplers,e=b.findIndex((I=>I.minFilter===g.minFilter&&I.magFilter===g.magFilter&&I.wrapS===g.wrapS&&I.wrapT===g.wrapT));return-1!==e?e:(b.push(g),b.length-1)}}var A=b(12670),j=b(12420),Q=b(13062),L=b(12597);const N=e.Vg.Zero(),K=e.Quaternion.Identity(),B=e.Vg.One(),P=new e.Vg(-1,1,1);function u(I,g){const{byteOffset:b,byteStride:e,type:c,normalized:z}=I,M=I.getSize(),J=g.reduce(((I,g)=>g.getTotalVertices()>I?g.getTotalVertices():I),-Number.MAX_VALUE);return{byteOffset:b,byteStride:e,componentCount:M,type:c,count:J*M,normalized:z,totalVertices:J,kind:I.getKind()}}function t(I){switch(I){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function y(I){switch(I){case G.f.PositionKind:case G.f.NormalKind:case G.f.TangentKind:case G.f.ColorKind:case G.f.MatricesIndicesKind:case G.f.MatricesIndicesExtraKind:case G.f.MatricesWeightsKind:case G.f.MatricesWeightsExtraKind:case G.f.UVKind:case G.f.UV2Kind:case G.f.UV3Kind:case G.f.UV4Kind:case G.f.UV5Kind:case G.f.UV6Kind:return!0}return!1}function q(I){switch(I){case z.b.TriangleFillMode:return 4;case z.b.TriangleStripDrawMode:return 5;case z.b.TriangleFanDrawMode:return 6;case z.b.PointListDrawMode:case z.b.PointFillMode:return 0;case z.b.LineLoopDrawMode:return 2;case z.b.LineListDrawMode:return 1;case z.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${I}`)}function l(I){const g=Math.sqrt(I.x*I.x+I.y*I.y+I.z*I.z);g>0&&(I.x/=g,I.y/=g,I.z/=g)}function w(I){return I.x*=-1,I}function T(I){if(I.x*I.x+I.y*I.y>.5){const g=Math.abs(I.x),b=Math.abs(I.y);if(g>b){const b=Math.sign(I.x);I.x=g,I.y*=-b,I.z*=-b,I.w*=b}else{const g=Math.sign(I.y);I.x*=-g,I.y=b,I.z*=g,I.w*=-g}}else{const g=Math.abs(I.z),b=Math.abs(I.w);if(g>b){const b=Math.sign(I.z);I.x*=-b,I.y*=b,I.z=g,I.w*=-b}else{const g=Math.sign(I.w);I.x*=g,I.y*=-g,I.z*=-g,I.w=b}}return I}function W(I){I.Db(-I.z,I.w,I.x,-I.y)}function II(I,g){const b=e.Vg.FromArrayToRef(g.translation||[0,0,0],0,e.TmpVectors.Vg[0]),c=e.Quaternion.FromArrayToRef(g.rotation||[0,0,0,1],0,e.TmpVectors.Quaternion[0]),z=e.Matrix.ComposeToRef(B,c,b,e.TmpVectors.Matrix[0]),M=e.Vg.FromArrayToRef(I.translation||[0,0,0],0,e.TmpVectors.Vg[2]),J=e.Quaternion.FromArrayToRef(I.rotation||[0,0,0,1],0,e.TmpVectors.Quaternion[1]),o=e.Matrix.ComposeToRef(B,J,M,e.TmpVectors.Matrix[1]);z.multiplyToRef(o,o),o.decompose(void 0,c,b),b.equalsWithEpsilon(N,L.b)?delete g.translation:g.translation=b.bb(),c.equalsWithEpsilon(K,L.b)?delete g.rotation:g.rotation=c.bb(),g.scale&&delete g.scale}function gI(I,g){if(!(g instanceof D.d))return!1;if(!(1===g.getChildren().length&&0===I.getChildren().length&&I.parent===g))return!1;const b=I.EI(),e=I instanceof Q.d&&!b.useRightHandedSystem?P:B;return!!g.pb.equalsWithEpsilon(e,L.b)||(j.b.Warn(`Cannot collapse node ${I.name} into parent node ${g.name} with modified scaling.`),!1)}function bI(I){if(I instanceof Array){const g=new Float32Array(I);return new Uint8Array(g.buffer,g.byteOffset,g.byteLength)}return ArrayBuffer.isView(I)?new Uint8Array(I.buffer,I.byteOffset,I.byteLength):new Uint8Array(I)}function eI(I,g){for(const[b,e]of Object.entries(I)){const c=g[b];(Array.isArray(e)&&Array.isArray(c)&&cI(e,c)||e===c)&&delete I[b]}return I}function cI(I,g){return I.length===g.length&&I.every(((I,b)=>I===g[b]))}const zI=e.Matrix.Compose(new e.Vg(-1,1,1),e.Quaternion.Identity(),e.Vg.Zero());function MI(I,g){if(!(I instanceof D.d))return!1;if(g){if(!I.getWorldMatrix().equalsWithEpsilon(e.Matrix.IdentityReadOnly,L.b))return!1}else{if(!I.getWorldMatrix().multiplyToRef(zI,e.TmpVectors.Matrix[0]).equalsWithEpsilon(e.Matrix.IdentityReadOnly,L.b))return!1}return!(I instanceof p.e&&I.ob)}const JI=new Map([[Int8Array,(I,g,b)=>I.setInt8(g,b)],[Uint8Array,(I,g,b)=>I.setUint8(g,b)],[Uint8ClampedArray,(I,g,b)=>I.setUint8(g,b)],[Int16Array,(I,g,b)=>I.setInt16(g,b,!0)],[Uint16Array,(I,g,b)=>I.setUint16(g,b,!0)],[Int32Array,(I,g,b)=>I.setInt32(g,b,!0)],[Uint32Array,(I,g,b)=>I.setUint32(g,b,!0)],[Float32Array,(I,g,b)=>I.setFloat32(g,b,!0)],[Float64Array,(I,g,b)=>I.setFloat64(g,b,!0)]]);class oI{writeTypedArray(I){this._checkGrowBuffer(I.byteLength);const g=JI.get(I.constructor);for(let b=0;b<I.length;b++)g(this._dataView,this._byteOffset,I[b]),this._byteOffset+=I.BYTES_PER_ELEMENT}constructor(I){this._data=new Uint8Array(I),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(I){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,I),this._byteOffset++}writeInt8(I){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,I),this._byteOffset++}writeInt16(I){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,I,!0),this._byteOffset+=2}writeUInt16(I){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,I,!0),this._byteOffset+=2}writeInt32(I){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,I,!0),this._byteOffset+=4}writeUInt32(I){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,I,!0),this._byteOffset+=4}writeFloat32(I){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,I,!0),this._byteOffset+=4}writeFloat64(I){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,I,!0),this._byteOffset+=8}_checkGrowBuffer(I){const g=this.byteOffset+I;if(g>this._data.byteLength){const I=new Uint8Array(2*g);I.set(this._data),this._data=I,this._dataView=new DataView(this._data.buffer)}}}function nI(I){return I%4===0?4:I%2===0?2:1}class GI{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(I){let g=0;this._bufferViewToData.forEach((I=>{g+=I.byteLength}));const b=new oI(g),e=Array.from(this._bufferViewToData.keys()).sort(((I,g)=>nI(g.byteLength)-nI(I.byteLength)));for(const c of e){c.byteOffset=b.byteOffset,I.push(c);const g=I.length-1,e=this.getPropertiesWithBufferView(c);for(const I of e)I.bufferView=g;b.writeTypedArray(this._bufferViewToData.get(c)),this._bufferViewToData.delete(c)}return b.getOutputData()}createBufferView(I,g){const b={buffer:0,byteOffset:void 0,byteLength:I.byteLength,byteStride:g};return this._bufferViewToData.set(b,I),b}createAccessor(I,g,b,e,c,z,M){this._verifyBufferView(I);const J={bufferView:void 0,componentType:b,count:e,type:g,min:null===z||void 0===z?void 0:z.min,max:null===z||void 0===z?void 0:z.max,normalized:M,byteOffset:c};return this.setBufferView(J,I),this._accessorToBufferView.set(J,I),J}setBufferView(I,g){this._verifyBufferView(g);this.getPropertiesWithBufferView(g).push(I)}removeBufferView(I){const g=this.getPropertiesWithBufferView(I);for(const b of g)void 0!==b.bufferView&&delete b.bufferView;this._bufferViewToData.delete(I),this._bufferViewToProperties.delete(I),this._accessorToBufferView.forEach(((g,b)=>{g===I&&(void 0!==b.byteOffset&&delete b.byteOffset,this._accessorToBufferView.delete(b))}))}getBufferView(I){const g=this._accessorToBufferView.get(I);return this._verifyBufferView(g),g}getPropertiesWithBufferView(I){return this._verifyBufferView(I),this._bufferViewToProperties.set(I,this._bufferViewToProperties.get(I)??[]),this._bufferViewToProperties.get(I)}getData(I){return this._verifyBufferView(I),this._bufferViewToData.get(I)}_verifyBufferView(I){if(void 0===I||!this._bufferViewToData.has(I))throw new Error(`BufferView ${I} not found in BufferManager.`)}}var DI,pI=b(13031),xI=b(13045),ZI=b(13068),kI=b(12954),SI=b(13097),fI=b(13109),VI=b(13027),aI=b(13114);!function(I){I[I.INTANGENT=0]="INTANGENT",I[I.OUTTANGENT=1]="OUTTANGENT"}(DI||(DI={}));class vI{static _IsTransformable(I){return I&&(I instanceof D.d||I instanceof pI.b||I instanceof aI.d)}static _CreateNodeAnimation(I,g,b,e,z){if(this._IsTransformable(I)){const M=[],J=[],o=g.getKeys(),n=vI._CalculateMinMaxKeyFrames(o),G=vI._DeduceInterpolation(o,b,e),D=G.interpolationType,p=G.shouldBakeAnimation;if(p?vI._CreateBakedAnimation(I,g,b,n.min,n.max,g.framePerSecond,z,M,J,n,e):"LINEAR"===D||"STEP"===D?vI._CreateLinearOrStepAnimation(I,g,b,M,J,e):"CUBICSPLINE"===D?vI._CreateCubicSplineAnimation(I,g,b,M,J,e):vI._CreateBakedAnimation(I,g,b,n.min,n.max,g.framePerSecond,z,M,J,n,e),M.length&&J.length){return{inputs:M,outputs:J,samplerInterpolation:D,inputsMin:p?n.min:c.Tools.FloatRound(n.min/g.framePerSecond),inputsMax:p?n.max:c.Tools.FloatRound(n.max/g.framePerSecond)}}}return null}static _DeduceAnimationInfo(I){let g=null,b="VEC3",e=!1;const z=I.targetProperty.split(".");switch(z[0]){case"pb":g="scale";break;case"position":g="translation";break;case"rotation":b="VEC4",g="rotation";break;case"rotationQuaternion":b="VEC4",e=!0,g="rotation";break;case"influence":b="SCALAR",g="weights";break;default:c.Tools.Error(`Unsupported animatable property ${z[0]}`)}return g?{animationChannelTargetPath:g,dataAccessorType:b,useQuaternion:e}:(c.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(I,g,b,e,c,z,M,J,o,n,G){let D;if(vI._IsTransformable(I)&&I.animations)for(const p of I.animations){if(G&&!G(p))continue;const c=vI._DeduceAnimationInfo(p);c&&(D={name:p.name,samplers:[],channels:[]},vI._AddAnimation(`${p.name}`,p.hasRunningRuntimeAnimations?g:D,I,p,c.dataAccessorType,c.animationChannelTargetPath,e,z,M,J,c.useQuaternion,o,n),D.samplers.length&&D.channels.length&&b.push(D))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(I,g,b,e,c,z,M,J,o,n,G){let D;if(I instanceof VI.e){const c=I.morphTargetManager;if(c)for(let p=0;p<c.numTargets;++p){const x=c.getTarget(p);for(const Z of x.animations){if(G&&!G(Z))continue;const x=new SI.e(`${Z.name}`,"influence",Z.framePerSecond,Z.dataType,Z.loopMode,Z.enableBlending),k=[],S=Z.getKeys();for(let I=0;I<S.length;++I){const g=S[I];for(let I=0;I<c.numTargets;++I)I==p?k.push(g):k.push({frame:g.frame,value:0})}x.setKeys(k);const f=vI._DeduceAnimationInfo(x);f&&(D={name:x.name,samplers:[],channels:[]},vI._AddAnimation(Z.name,Z.hasRunningRuntimeAnimations?g:D,I,x,f.dataAccessorType,f.animationChannelTargetPath,e,z,M,J,f.useQuaternion,o,n,c.numTargets),D.samplers.length&&D.channels.length&&b.push(D))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(I,g,b,e,c,z,M,J,o){let n;if(I.animationGroups){const D=I.animationGroups;for(const p of D){const D=new Map,x=new Map,Z=new Set,k=p.to-p.from;n={name:p.name,channels:[],samplers:[]};for(let g=0;g<p.targetedAnimations.length;++g){const k=p.targetedAnimations[g],S=k.target,f=k.animation;if(o&&!o(f))continue;const V=J.has(S);if(this._IsTransformable(S)||1===S.length&&this._IsTransformable(S[0])){const I=vI._DeduceAnimationInfo(k.animation);if(I){const g=this._IsTransformable(S)?S:this._IsTransformable(S[0])?S[0]:null;g&&vI._AddAnimation(`${f.name}`,n,g,f,I.dataAccessorType,I.animationChannelTargetPath,b,e,c,z,I.useQuaternion,M,V)}}else if(S instanceof fI.c||1===S.length&&S[0]instanceof fI.c){if(vI._DeduceAnimationInfo(k.animation)){const g=S instanceof fI.c?S:S[0];if(g){const b=I.morphTargetManagers.find((I=>{for(let b=0;b<I.numTargets;++b)if(I.getTarget(b)===g)return!0;return!1}));if(b){const e=I.meshes.find((I=>I.morphTargetManager===b));var G;if(e)D.has(e)||D.set(e,new Map),null===(G=D.get(e))||void 0===G||G.set(g,f),Z.add(e),x.set(e,f)}}}}}Z.forEach((I=>{const g=I.morphTargetManager;let J=null;const o=[],G=x.get(I).getKeys(),Z=G.length;for(let b=0;b<Z;++b)for(let e=0;e<g.numTargets;++e){const c=g.getTarget(e),z=D.get(I);if(z){const g=z.get(c);g?(J||(J=new SI.e(`${p.name}_${I.name}_MorphWeightAnimation`,"influence",g.framePerSecond,SI.e.ANIMATIONTYPE_FLOAT,g.loopMode,g.enableBlending)),o.push(g.getKeys()[b])):o.push({frame:p.from+k/Z*b,value:c.influence,inTangent:G[0].inTangent?0:void 0,outTangent:G[0].outTangent?0:void 0})}}J.setKeys(o);const S=vI._DeduceAnimationInfo(J);S&&vI._AddAnimation(`${p.name}_${I.name}_MorphWeightAnimation`,n,I,J,S.dataAccessorType,S.animationChannelTargetPath,b,e,c,z,S.useQuaternion,M,!1,null===g||void 0===g?void 0:g.numTargets)})),n.channels.length&&n.samplers.length&&g.push(n)}}}static _AddAnimation(I,g,b,c,z,M,J,o,n,G,D,p,x,Z){const k=vI._CreateNodeAnimation(b,c,M,D,p);let S,f,V,a,v,X;if(k){if(Z){let I=0,g=0;const b=[];for(;k.inputs.length>0;)g=k.inputs.shift(),I%Z==0&&b.push(g),I++;k.inputs=b}const I=J.get(b),c=new Float32Array(k.inputs);S=o.createBufferView(c),f=o.createAccessor(S,"SCALAR",5126,k.inputs.length,void 0,{min:[k.inputsMin],max:[k.inputsMax]}),G.push(f),V=G.length-1;const n=new e.Quaternion,D=new e.Vg,p=new e.Vg,R=b instanceof pI.b,E=t(z),mI=new Float32Array(k.outputs.length*E);k.outputs.forEach((function(I,g){let b=I;switch(M){case"translation":x&&(e.Vg.FromArrayToRef(I,0,p),w(p),p.toArray(b));break;case"rotation":4===I.length?e.Quaternion.FromArrayToRef(I,0,n):(b=new Array(4),e.Vg.FromArrayToRef(I,0,D),e.Quaternion.FromEulerVectorToRef(D,n)),x&&(T(n),R&&W(n)),n.toArray(b)}mI.set(b,g*E)})),S=o.createBufferView(mI),f=o.createAccessor(S,z,5126,k.outputs.length),G.push(f),a=G.length-1,v={interpolation:k.samplerInterpolation,input:V,output:a},g.samplers.push(v),X={sampler:g.samplers.length-1,target:{node:I,path:M}},g.channels.push(X)}}static _CreateBakedAnimation(I,g,b,z,M,J,o,n,G,D,p){let x;const Z=e.Quaternion.Identity();let k,S=null,f=null,V=null,a=null,v=null,X=null;D.min=c.Tools.FloatRound(z/J);const R=g.getKeys();for(let e=0,E=R.length;e<E;++e){if(X=null,V=R[e],e+1<E)if(a=R[e+1],V.value.equals&&V.value.equals(a.value)||V.value===a.value){if(0!==e)continue;X=V.frame}else X=a.frame;else{if(v=R[e-1],V.value.equals&&V.value.equals(v.value)||V.value===v.value)continue;X=M}if(X)for(let e=V.frame;e<=X;e+=o){if(k=c.Tools.FloatRound(e/J),k===S)continue;S=k,f=k;const z={key:0,repeatCount:0,loopMode:g.loopMode};x=g._interpolate(e,z),vI._SetInterpolatedValue(I,x,k,g,b,Z,n,G,p)}}f&&(D.max=f)}static _ConvertFactorToVector3OrQuaternion(I,g,b,z,M){const J=vI._GetBasePositionRotationOrScale(g,z,M),o=b.targetProperty.split("."),n=o?o[1]:"",G=M?e.Quaternion.mb(J).normalize():e.Vg.mb(J);switch(n){case"x":case"y":case"z":G[n]=I;break;case"w":G.w=I;break;default:c.Tools.Error(`glTFAnimation: Unsupported component name "${n}"!`)}return G}static _SetInterpolatedValue(I,g,b,c,z,M,J,o,n){let G;J.push(b),"weights"!==z?(c.dataType===SI.e.ANIMATIONTYPE_FLOAT&&(g=this._ConvertFactorToVector3OrQuaternion(g,I,c,z,n)),"rotation"===z?(n?M=g:(G=g,e.Quaternion.RotationYawPitchRollToRef(G.y,G.x,G.z,M)),o.push(M.bb())):(G=g,o.push(G.bb()))):o.push([g])}static _CreateLinearOrStepAnimation(I,g,b,e,c,z){for(const M of g.getKeys())e.push(M.frame/g.framePerSecond),vI._AddKeyframeValue(M,g,c,b,I,z)}static _CreateCubicSplineAnimation(I,g,b,e,c,z){g.getKeys().forEach((function(M){e.push(M.frame/g.framePerSecond),vI._AddSplineTangent(DI.INTANGENT,c,b,"CUBICSPLINE",M,z),vI._AddKeyframeValue(M,g,c,b,I,z),vI._AddSplineTangent(DI.OUTTANGENT,c,b,"CUBICSPLINE",M,z)}))}static _GetBasePositionRotationOrScale(I,g,b){let c;if("rotation"===g)if(b){c=(I.rotationQuaternion??e.Quaternion.Identity()).bb()}else{c=(I.rotation??e.Vg.Zero()).bb()}else if("translation"===g){c=(I.position??e.Vg.Zero()).bb()}else{c=(I.pb??e.Vg.One()).bb()}return c}static _AddKeyframeValue(I,g,b,z,M,J){let o;const n=g.dataType;if(n===SI.e.ANIMATIONTYPE_VECTOR3){let g=I.value.bb();if("rotation"===z){const I=e.Vg.mb(g);g=e.Quaternion.RotationYawPitchRoll(I.y,I.x,I.z).bb()}b.push(g)}else if(n===SI.e.ANIMATIONTYPE_FLOAT){if("weights"===z)b.push([I.value]);else if(o=this._ConvertFactorToVector3OrQuaternion(I.value,M,g,z,J),o){if("rotation"===z){const I=J?o:e.Quaternion.RotationYawPitchRoll(o.y,o.x,o.z).normalize();b.push(I.bb())}b.push(o.bb())}}else n===SI.e.ANIMATIONTYPE_QUATERNION?b.push(I.value.normalize().bb()):c.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(I,g,b){let e,c,z=!1;if("rotation"===g&&!b)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let M=0,J=I.length;M<J;++M)if(c=I[M],c.inTangent||c.outTangent)if(e){if("CUBICSPLINE"!==e){e="LINEAR",z=!0;break}}else e="CUBICSPLINE";else if(e){if("CUBICSPLINE"===e||c.interpolation&&1===c.interpolation&&"STEP"!==e){e="LINEAR",z=!0;break}}else e=c.interpolation&&1===c.interpolation?"STEP":"LINEAR";return e||(e="LINEAR"),{interpolationType:e,shouldBakeAnimation:z}}static _AddSplineTangent(I,g,b,c,z,M){let J;const o=I===DI.INTANGENT?z.inTangent:z.outTangent;if("CUBICSPLINE"===c){if("rotation"===b)if(o)if(M)J=o.bb();else{const I=o;J=e.Quaternion.RotationYawPitchRoll(I.y,I.x,I.z).bb()}else J=[0,0,0,0];else J="weights"===b?o?[o]:[0]:o?o.bb():[0,0,0];g.push(J)}}static _CalculateMinMaxKeyFrames(I){let g=1/0,b=-1/0;return I.forEach((function(I){g=Math.min(g,I.frame),b=Math.max(b,I.frame)})),{min:g,max:b}}}function XI(I,g,b,z,M,J){const o={attributes:{},influence:I.influence,name:I.name},n=g.ob;if(!n)return c.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),o;const D=J?-1:1,p=e.Vg.Zero();let x=0,Z=0;if(I.hasPositions){const z=I.getPositions(),J=n.getVerticesData(G.f.PositionKind);if(J){const I=new Float32Array(J.length),g=[1/0,1/0,1/0],c=[-1/0,-1/0,-1/0];Z=J.length/3,x=0;for(let b=x;b<Z;++b){const M=e.Vg.mb(J,3*b);e.Vg.mb(z,3*b).subtractToRef(M,p),p.x*=D,g[0]=Math.min(g[0],p.x),c[0]=Math.max(c[0],p.x),g[1]=Math.min(g[1],p.y),c[1]=Math.max(c[1],p.y),g[2]=Math.min(g[2],p.z),c[2]=Math.max(c[2],p.z),I[3*b]=p.x,I[3*b+1]=p.y,I[3*b+2]=p.z}const n=b.createBufferView(I,12),G=b.createAccessor(n,"VEC3",5126,z.length/3,0,{min:g,max:c});M.push(G),o.attributes.POSITION=M.length-1}else c.Tools.Warn(`Morph target positions for mesh ${g.name} were not exported. Mesh does not have position vertex data`)}if(I.hasNormals){const z=I.getNormals(),J=n.getVerticesData(G.f.NormalKind);if(J){const I=new Float32Array(J.length);Z=J.length/3,x=0;for(let b=x;b<Z;++b){const g=e.Vg.mb(J,3*b).normalize();e.Vg.mb(z,3*b).normalize().subtractToRef(g,p),I[3*b]=p.x*D,I[3*b+1]=p.y,I[3*b+2]=p.z}const g=b.createBufferView(I,12),c=b.createAccessor(g,"VEC3",5126,z.length/3,0);M.push(c),o.attributes.NORMAL=M.length-1}else c.Tools.Warn(`Morph target normals for mesh ${g.name} were not exported. Mesh does not have normals vertex data`)}if(I.hasTangents){const z=I.getTangents(),J=n.getVerticesData(G.f.TangentKind);if(J){Z=J.length/4;const I=new Float32Array(3*Z);x=0;for(let b=x;b<Z;++b){const g=e.Vg.mb(J,4*b);l(g);const c=e.Vg.mb(z,3*b);l(c),c.subtractToRef(g,p),I[3*b]=p.x*D,I[3*b+1]=p.y,I[3*b+2]=p.z}const g=b.createBufferView(I,12),c=b.createAccessor(g,"VEC3",5126,Z,0);M.push(c),o.attributes.TANGENT=M.length-1}else c.Tools.Warn(`Morph target tangents for mesh ${g.name} were not exported. Mesh does not have tangents vertex data`)}if(I.hasColors){const z=I.getColors(),J=n.getVerticesData(G.f.ColorKind),D=n.getVertexBuffer(G.f.ColorKind);if(J&&D){const I=D.getSize();Z=J.length/I;const g=new Float32Array(Z*I);x=0;for(let b=x;b<Z;++b)if(3===I){const c=e.Vg.mb(J,b*I);e.Vg.mb(z,b*I).subtractToRef(c,p),g[3*b]=p.x,g[3*b+1]=p.y,g[3*b+2]=p.z}else if(4===I){const c=new e.Vector4,M=e.Vector4.mb(J,b*I);e.Vector4.mb(z,b*I).subtractToRef(M,c),g[4*b]=c.x,g[4*b+1]=c.y,g[4*b+2]=c.z,g[4*b+3]=c.w}else c.Tools.Warn(`Unsupported number of components for color attribute: ${I}`);const n=b.createBufferView(g,4*I),G=b.createAccessor(n,3===I?"VEC3":"VEC4",5126,Z,0);M.push(G),o.attributes.COLOR_0=M.length-1}else c.Tools.Warn(`Morph target colors for mesh ${g.name} were not exported. Mesh does not have colors vertex data`)}return o}var RI=b(13119),EI=b(12980),mg=b(12966),sI=b(12558);class FI{}FI.DEFAULT_COLOR=S.Eg.White(),FI.DEFAULT_WIDTH_ATTENUATED=1,FI.DEFAULT_WIDTH=.1;var YI=b(12791),dI=b(13121);class CI{static ConvertPoints(I,g){if(I.length&&Array.isArray(I)&&"number"===typeof I[0])return[I];if(I.length&&Array.isArray(I[0])&&"number"===typeof I[0][0])return I;if(I.length&&!Array.isArray(I[0])&&I[0]instanceof e.Vg){const g=[];for(let b=0;b<I.length;b++){const e=I[b];g.push(e.x,e.y,e.z)}return[g]}if(I.length>0&&Array.isArray(I[0])&&I[0].length>0&&I[0][0]instanceof e.Vg){const g=[],b=I;for(const I of b)g.push(I.flatMap((I=>[I.x,I.y,I.z])));return g}if(I instanceof Float32Array){if(null!==g&&void 0!==g&&g.floatArrayStride){const b=[],e=3*g.floatArrayStride;for(let g=0;g<I.length;g+=e){const c=new Array(e);for(let b=0;b<e;b++)c[b]=I[g+b];b.push(c)}return b}return[Array.from(I)]}if(I.length&&I[0]instanceof Float32Array){const g=[];for(const b of I)g.push(Array.from(b));return g}return[]}static OmitZeroLengthPredicate(I,g,b){const e=[];return g.ag(I).lengthSquared()>0&&e.push([I,g]),b.ag(g).lengthSquared()>0&&e.push([g,b]),I.ag(b).lengthSquared()>0&&e.push([b,I]),0===e.length?null:e}static OmitDuplicatesPredicate(I,g,b,e){const c=[];return CI._SearchInPoints(I,g,e)||c.push([I,g]),CI._SearchInPoints(g,b,e)||c.push([g,b]),CI._SearchInPoints(b,I,e)||c.push([b,I]),0===c.length?null:c}static _SearchInPoints(I,g,b){for(const M of b)for(let b=0;b<M.length;b++){var e,c,z;if(null!==(e=M[b])&&void 0!==e&&e.equals(I))if(null!==(c=M[b+1])&&void 0!==c&&c.equals(g)||null!==(z=M[b-1])&&void 0!==z&&z.equals(g))return!0}return!1}static MeshesToLines(I,g){const b=[];for(let c=0;c<I.length;c++){const z=I[c],M=z.getVerticesData(G.f.PositionKind),J=z.nb();if(M&&J)for(let I=0,o=0;I<J.length;I++){const n=3*J[o++],G=3*J[o++],D=3*J[o++],p=new e.Vg(M[n],M[n+1],M[n+2]),x=new e.Vg(M[G],M[G+1],M[G+2]),Z=new e.Vg(M[D],M[D+1],M[D+2]);if(g){const e=g(p,x,Z,b,I,n,z,c,M,J);if(e)for(const I of e)b.push(I)}else b.push([p,x],[x,Z],[Z,p])}}return b}static ToVector3Array(I){if(Array.isArray(I[0])){const g=[],b=I;for(const I of b){const b=[];for(let g=0;g<I.length;g+=3)b.push(new e.Vg(I[g],I[g+1],I[g+2]));g.push(b)}return g}const g=I,b=[];for(let c=0;c<g.length;c+=3)b.push(new e.Vg(g[c],g[c+1],g[c+2]));return b}static ToNumberArray(I){return I.flatMap((I=>[I.x,I.y,I.z]))}static GetPointsCountInfo(I){const g=new Array(I.length);let b=0;for(let e=I.length;e--;)g[e]=I[e].length/3,b+=g[e];return{total:b,counts:g}}static GetLineLength(I){if(0===I.length)return 0;let g;g="number"===typeof I[0]?CI.ToVector3Array(I):I;const b=e.TmpVectors.Vg[0];let c=0;for(let e=0;e<g.length-1;e++){const I=g[e];c+=g[e+1].subtractToRef(I,b).length()}return c}static GetLineLengthArray(I){const g=new Float32Array(I.length/3);let b=0;for(let e=0,c=I.length/3-1;e<c;e++){let c=I[3*e+0],z=I[3*e+1],M=I[3*e+2];c-=I[3*e+3],z-=I[3*e+4],M-=I[3*e+5];b+=Math.sqrt(c*c+z*z+M*M),g[e+1]=b}return g}static SegmentizeSegmentByCount(I,g,b){const c=[],z=g.ag(I),M=e.TmpVectors.Vg[0];M.kb(b);const J=e.TmpVectors.Vg[1];z.divideToRef(M,J);let o=I.clone();c.push(o);for(let e=0;e<b;e++)o=o.clone(),c.push(o.addInPlace(J));return c}static SegmentizeLineBySegmentLength(I,g){const b=I[0]instanceof e.Vg?CI.GetLineSegments(I):"number"===typeof I[0]?CI.GetLineSegments(CI.ToVector3Array(I)):I,c=[];for(const e of b)if(e.length>g){const I=CI.SegmentizeSegmentByCount(e.point1,e.point2,Math.ceil(e.length/g));for(const g of I)c.push(g)}else c.push(e.point1),c.push(e.point2);return c}static SegmentizeLineBySegmentCount(I,g){const b="number"===typeof I[0]?CI.ToVector3Array(I):I,e=CI.GetLineLength(b)/g;return CI.SegmentizeLineBySegmentLength(b,e)}static GetLineSegments(I){const g=[];for(let b=0;b<I.length-1;b++){const e=I[b],c=I[b+1],z=c.ag(e).length();g.push({point1:e,point2:c,length:z})}return g}static GetMinMaxSegmentLength(I){const g=CI.GetLineSegments(I).sort((I=>I.length));return{min:g[0].length,max:g[g.length-1].length}}static GetPositionOnLineByVisibility(I,g,b){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const z=g*b;let M=0,J=0;const o=I.length;for(let e=0;e<o;e++){if(z<=M+I[e].length){J=e;break}M+=I[e].length}const n=(z-M)/I[J].length;return I[J].point2.subtractToRef(I[J].point1,e.TmpVectors.Vg[0]),e.TmpVectors.Vg[1]=e.TmpVectors.Vg[0].multiplyByFloats(n,n,n),c||e.TmpVectors.Vg[1].addInPlace(I[J].point1),e.TmpVectors.Vg[1].clone()}static GetCircleLinePoints(I,g){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I,z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/g;const M=[];for(let J=0;J<=g;J++)M.push(new e.Vg(Math.cos(J*z)*I,Math.sin(J*z)*c,b));return M}static GetBezierLinePoints(I,g,b,e){return YI.f.CreateQuadraticBezier(I,g,b,e).getPoints().flatMap((I=>[I.x,I.y,I.z]))}static GetArrowCap(I,g,b,e,c){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,M=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[I.clone(),I.add(g.multiplyByFloats(b,b,b))],widths:[e,c,z,M]}}static GetPointsFromText(I,g,b,e){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const M=[],J=(0,dI.b)(I,g,b,e);for(const o of J){for(const I of o.paths){const g=[],b=I.getPoints();for(const I of b)g.push(I.x,I.y,c);M.push(g)}if(z)for(const I of o.holes){const g=[],b=I.getPoints();for(const I of b)g.push(I.x,I.y,c);M.push(g)}}return M}static Color3toRGBAUint8(I){const g=new Uint8Array(4*I.length);for(let b=0,e=0;b<I.length;b++)g[e++]=255*I[b].r,g[e++]=255*I[b].g,g[e++]=255*I[b].b,g[e++]=255;return g}static CreateColorsTexture(I,g,b,e){const c=e.getEngine().getCaps().maxTextureSize??1,z=g.length>c?c:g.length,M=Math.ceil(g.length/c);M>1&&(g=[...g,...Array(z*M-g.length).fill(g[0])]);const J=CI.Color3toRGBAUint8(g),o=new R.b(J,z,M,Z.c.TEXTUREFORMAT_RGBA,e,!1,!0,b);return o.name=I,o}static PrepareEmptyColorsTexture(I){if(!FI.EmptyColorsTexture){const g=new Uint8Array(4);FI.EmptyColorsTexture=new R.b(g,1,1,Z.c.TEXTUREFORMAT_RGBA,I,!1,!1,R.b.NEAREST_NEAREST),FI.EmptyColorsTexture.name="grlEmptyColorsTexture"}return FI.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var I;null===(I=FI.EmptyColorsTexture)||void 0===I||I.dispose(),FI.EmptyColorsTexture=null}static BooleanToNumber(I){return I?1:0}}class rI extends mg.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class OI extends EI.b{isCompatible(I){return!0}constructor(I,g,b){var c;b=b||{color:FI.DEFAULT_COLOR};const z=new rI;z.GREASED_LINE_HAS_COLOR=!!b.color&&!b.useColors,z.GREASED_LINE_SIZE_ATTENUATION=b.sizeAttenuation??!1,z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===b.colorDistributionType,z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(g??I.EI()).useRightHandedSystem,z.GREASED_LINE_CAMERA_FACING=b.cameraFacing??!0,super(I,OI.GREASED_LINE_MATERIAL_NAME,200,z,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(c=b)||void 0===c?void 0:c.forceGLSL)||OI.ForceGLSL,this._scene=g??I.EI(),this._engine=this._scene.getEngine(),this._cameraFacing=b.cameraFacing??!0,this.visibility=b.visibility??1,this.useDash=b.useDash??!1,this.dashRatio=b.dashRatio??.5,this.dashOffset=b.dashOffset??0,this.width=b.width?b.width:b.sizeAttenuation?FI.DEFAULT_WIDTH_ATTENUATED:FI.DEFAULT_WIDTH,this._sizeAttenuation=b.sizeAttenuation??!1,this.colorMode=b.colorMode??0,this._color=b.color??null,this.useColors=b.useColors??!1,this._colorsDistributionType=b.colorDistributionType??0,this.colorsSampling=b.colorsSampling??R.b.NEAREST_NEAREST,this._colors=b.YI??null,this.dashCount=b.dashCount??1,this.resolution=b.resolution??new e.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),b.colorsTexture?this.colorsTexture=b.colorsTexture:this._colors?this.colorsTexture=CI.CreateColorsTexture(`${I.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??FI.DEFAULT_COLOR,CI.PrepareEmptyColorsTexture(this._scene)),this._engine.Og.add((()=>{CI.DisposeEmptyColorsTexture()}))}getAttributes(I){I.push("grl_offsets"),I.push("grl_widths"),I.push("grl_colorPointers"),I.push("grl_counters"),this._cameraFacing?(I.push("grl_previousAndSide"),I.push("grl_nextAndCounters")):I.push("grl_slopes")}getSamplers(I){I.push("grl_colors")}getActiveTextures(I){this.colorsTexture&&I.push(this.colorsTexture)}getUniforms(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const g=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&g.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===I&&g.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:g,vertex:this._cameraFacing&&this._isGLSL(I)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(I)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(I){if(this._cameraFacing){I.zb("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||I.zb("viewProjection",this._scene.getTransformMatrix());const g=e.TmpVectors.Vector4[0];g.x=this._aspect,g.y=this._resolution.x,g.z=this._resolution.y,g.w=this.width,I.updateVector4("grl_aspect_resolution_lineWidth",g)}const g=e.TmpVectors.Vector4[0];g.x=CI.BooleanToNumber(this.useDash),g.y=this._dashArray,g.z=this.dashOffset,g.w=this.dashRatio,I.updateVector4("grl_dashOptions",g);const b=e.TmpVectors.Vector4[1];b.x=this.colorMode,b.y=this.visibility,b.z=this.colorsTexture?this.colorsTexture.getSize().width:0,b.w=CI.BooleanToNumber(this.useColors),I.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",b),this._color&&I.updateColor3("grl_singleColor",this._color);const c=this.colorsTexture??FI.EmptyColorsTexture;I.setTexture("grl_colors",c),I.updateFloat2("grl_textureSize",(null===c||void 0===c?void 0:c.getSize().width)??1,(null===c||void 0===c?void 0:c.getSize().height)??1)}prepareDefines(I,g,b){I.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,I.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,I.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,I.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=g.useRightHandedSystem,I.GREASED_LINE_CAMERA_FACING=this._cameraFacing,I.GREASED_LINE_USE_OFFSETS=!!b.offsets}getClassName(){return OI.GREASED_LINE_MATERIAL_NAME}getCustomCode(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(g)?function(I,g){if("vertex"===I){const I={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return g&&(I["!gl_Position\\=viewProjection\\*worldPos;"]="//"),I}return"fragment"===I?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(I,this._cameraFacing):function(I,g){if("vertex"===I){const I={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return g&&(I["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),I}return"fragment"===I?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(I,this._cameraFacing)}dispose(){var I;null===(I=this.colorsTexture)||void 0===I||I.dispose(),super.dispose()}get YI(){return this._colors}set YI(I){this.setColors(I)}setColors(I){var g;let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const c=(null===(g=this._colors)||void 0===g?void 0:g.length)??0;var z;if(this._colors=I,null!==I&&0!==I.length){if(!b||e)if(this.colorsTexture&&c===I.length&&!e){const g=CI.Color3toRGBAUint8(I);this.colorsTexture.update(g)}else{var M;null===(M=this.colorsTexture)||void 0===M||M.dispose(),this.colorsTexture=CI.CreateColorsTexture(`${this._material.name}-colors-texture`,I,this.colorsSampling,this._scene)}}else null===(z=this.colorsTexture)||void 0===z||z.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(I){this._dashCount=I,this._dashArray=1/I}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(I){this._sizeAttenuation=I,this.markAllDefinesAsDirty()}get color(){return this._color}set color(I){this.setColor(I)}setColor(I){let g=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==I||null!==this._color&&null===I?(this._color=I,g||this.markAllDefinesAsDirty()):this._color=I}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(I){this._colorsDistributionType=I,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(I){this._aspect=I.x/I.y,this._resolution=I}serialize(){const I=super.serialize(),g={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(g.YI=this._colors),this._color&&(g.color=this._color),I.greasedLineMaterialOptions=g,I}parse(I,g,b){var e;super.parse(I,g,b);const c=I.greasedLineMaterialOptions;null===(e=this.colorsTexture)||void 0===e||e.dispose(),c.color&&this.setColor(c.color,!0),c.colorDistributionType&&(this.colorsDistributionType=c.colorDistributionType),c.YI&&(this.YI=c.YI),c.colorsSampling&&(this.colorsSampling=c.colorsSampling),c.colorMode&&(this.colorMode=c.colorMode),c.useColors&&(this.useColors=c.useColors),c.visibility&&(this.visibility=c.visibility),c.useDash&&(this.useDash=c.useDash),c.dashCount&&(this.dashCount=c.dashCount),c.dashRatio&&(this.dashRatio=c.dashRatio),c.dashOffset&&(this.dashOffset=c.dashOffset),c.width&&(this.width=c.width),c.sizeAttenuation&&(this.sizeAttenuation=c.sizeAttenuation),c.resolution&&(this.resolution=c.resolution),this.YI?this.colorsTexture=CI.CreateColorsTexture(`${this._material.name}-colors-texture`,this.YI,this.colorsSampling,g):CI.PrepareEmptyColorsTexture(g),this.markAllDefinesAsDirty()}copyTo(I){var g;const b=I;null===(g=b.colorsTexture)||void 0===g||g.dispose(),this._colors&&(b.colorsTexture=CI.CreateColorsTexture(`${b._material.name}-colors-texture`,this._colors,b.colorsSampling,this._scene)),b.setColor(this.color,!0),b.colorsDistributionType=this.colorsDistributionType,b.colorsSampling=this.colorsSampling,b.colorMode=this.colorMode,b.useColors=this.useColors,b.visibility=this.visibility,b.useDash=this.useDash,b.dashCount=this.dashCount,b.dashRatio=this.dashRatio,b.dashOffset=this.dashOffset,b.width=this.width,b.sizeAttenuation=this.sizeAttenuation,b.resolution=this.resolution,b.markAllDefinesAsDirty()}_isGLSL(I){return 0===I||this._forceGLSL}}OI.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",OI.ForceGLSL=!1,(0,sI.g)(`BABYLON.${OI.GREASED_LINE_MATERIAL_NAME}`,OI);var HI=b(13013),iI=b(12426),UI=b(12808),hI=b(12538);class AI extends UI.ShaderMaterial{constructor(I,g,c){const z=g.getEngine(),M=z.isWebGPU&&!(c.forceGLSL||AI.ForceGLSL),J=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];g.useRightHandedSystem&&J.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const o=["position","grl_widths","grl_offsets","grl_colorPointers"];c.cameraFacing?(J.push("GREASED_LINE_CAMERA_FACING"),o.push("grl_previousAndSide","grl_nextAndCounters")):(o.push("grl_slopes"),o.push("grl_counters"));const n=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(M||n.push("world","viewProjection","view","projection"),super(I,g,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:M?["Scene","Mesh"]:void 0,attributes:o,uniforms:n,samplers:M?[]:["grlColors"],defines:J,extraInitializationsAsync:async()=>{M?await Promise.all([b.e(66).then(b.bind(b,15657)),b.e(75).then(b.bind(b,15665))]):await Promise.all([b.e(69).then(b.bind(b,15673)),b.e(76).then(b.bind(b,15680))])},shaderLanguage:M?1:0}),this._color=S.Eg.White(),this._colorsDistributionType=0,this._colorsTexture=null,c=c||{color:FI.DEFAULT_COLOR},this.visibility=c.visibility??1,this.useDash=c.useDash??!1,this.dashRatio=c.dashRatio??.5,this.dashOffset=c.dashOffset??0,this.dashCount=c.dashCount??1,this.width=c.width?c.width:c.sizeAttenuation&&c.cameraFacing?FI.DEFAULT_WIDTH_ATTENUATED:FI.DEFAULT_WIDTH,this.sizeAttenuation=c.sizeAttenuation??!1,this.color=c.color??S.Eg.White(),this.useColors=c.useColors??!1,this.colorsDistributionType=c.colorDistributionType??0,this.colorsSampling=c.colorsSampling??R.b.NEAREST_NEAREST,this.colorMode=c.colorMode??0,this._colors=c.YI??null,this._cameraFacing=c.cameraFacing??!0,this.resolution=c.resolution??new e.Vector2(z.getRenderWidth(),z.getRenderHeight()),c.colorsTexture?this.colorsTexture=c.colorsTexture:this._colors?this.colorsTexture=CI.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,g):(this._color=this._color??FI.DEFAULT_COLOR,this.colorsTexture=CI.PrepareEmptyColorsTexture(g)),M){const I=new hI.b;I.setParameters(),I.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",I)}z.Og.add((()=>{CI.DisposeEmptyColorsTexture()}))}dispose(){var I;null===(I=this._colorsTexture)||void 0===I||I.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new e.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get YI(){return this._colors}set YI(I){this.setColors(I)}setColors(I){var g;let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const c=(null===(g=this._colors)||void 0===g?void 0:g.length)??0;var z;if(this._colors=I,null!==I&&0!==I.length){if(!b||e)if(this._colorsTexture&&c===I.length&&!e){const g=CI.Color3toRGBAUint8(I);this._colorsTexture.update(g)}else{var M;null===(M=this._colorsTexture)||void 0===M||M.dispose(),this.colorsTexture=CI.CreateColorsTexture(`${this.name}-colors-texture`,I,this.colorsSampling,this.EI())}}else null===(z=this._colorsTexture)||void 0===z||z.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(I){this._colorsTexture=I,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(I){this._width=I,this.setFloat("grlWidth",I)}get useColors(){return this._useColors}set useColors(I){this._useColors=I,this.setFloat("grlUseColors",CI.BooleanToNumber(I))}get colorsSampling(){return this._colorsSampling}set colorsSampling(I){this._colorsSampling=I}get visibility(){return this._visibility}set visibility(I){this._visibility=I,this.setFloat("grlVisibility",I)}get useDash(){return this._useDash}set useDash(I){this._useDash=I,this.setFloat("grlUseDash",CI.BooleanToNumber(I))}get dashOffset(){return this._dashOffset}set dashOffset(I){this._dashOffset=I,this.setFloat("grlDashOffset",I)}get dashRatio(){return this._dashRatio}set dashRatio(I){this._dashRatio=I,this.setFloat("grlDashRatio",I)}get dashCount(){return this._dashCount}set dashCount(I){this._dashCount=I,this._dashArray=1/I,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(I){this._sizeAttenuation=I,this.setFloat("grlSizeAttenuation",CI.BooleanToNumber(I))}get color(){return this._color}set color(I){this.setColor(I)}setColor(I){I=I??FI.DEFAULT_COLOR,this._color=I,this.setColor3("grlColor",I)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(I){this._colorsDistributionType=I,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(I){this._colorMode=I,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(I){this._resolution=I,this.setVector2("grlResolution",I),this.setFloat("grlAspect",I.x/I.y)}serialize(){const I=super.serialize(),g={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(g.YI=this._colors),I.greasedLineMaterialOptions=g,I}parse(I,g,b){var e;const c=I.greasedLineMaterialOptions;null===(e=this._colorsTexture)||void 0===e||e.dispose(),c.color&&(this.color=c.color),c.colorDistributionType&&(this.colorsDistributionType=c.colorDistributionType),c.colorsSampling&&(this.colorsSampling=c.colorsSampling),c.colorMode&&(this.colorMode=c.colorMode),c.useColors&&(this.useColors=c.useColors),c.visibility&&(this.visibility=c.visibility),c.useDash&&(this.useDash=c.useDash),c.dashCount&&(this.dashCount=c.dashCount),c.dashRatio&&(this.dashRatio=c.dashRatio),c.dashOffset&&(this.dashOffset=c.dashOffset),c.width&&(this.width=c.width),c.sizeAttenuation&&(this.sizeAttenuation=c.sizeAttenuation),c.resolution&&(this.resolution=c.resolution),c.YI?this.colorsTexture=CI.CreateColorsTexture(`${this.name}-colors-texture`,c.YI,this.colorsSampling,this.EI()):this.colorsTexture=CI.PrepareEmptyColorsTexture(g),this._cameraFacing=c.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var jI,QI,LI;AI.ForceGLSL=!1,function(I){I[I.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",I[I.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(jI||(jI={})),function(I){I[I.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",I[I.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",I[I.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(QI||(QI={})),function(I){I[I.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",I[I.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",I[I.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",I[I.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",I[I.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(LI||(LI={}));class NI extends VI.e{constructor(I,g,b){super(I,g,null,null,!1,!1),this.name=I,this._options=b,this._lazy=!1,this._updatable=!1,this._engine=g.getEngine(),this._lazy=b.lazy??!1,this._updatable=b.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=b.colorPointers??[],this._widths=b.widths??new Array(b.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(I){let g=0;for(const e of this._points)g+=e.length;const b=g/3*2-this._widths.length;for(let e=0;e<b;e++)this._widths.push(I)}updateLazy(){var I,g;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(I=this._options.ribbonOptions)||void 0===I?void 0:I.smoothShading),!this.OI&&this.refreshBoundingInfo(),null===(g=this.greasedLineMaterial)||void 0===g||g.updateLazy()}addPoints(I,g){for(const b of I)this._points.push(b);this._lazy||this.setPoints(this._points,g)}dispose(I){let g=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(I,g)}isLazy(){return this._lazy}get dI(){return this._uvs}set dI(I){this._uvs=I instanceof Float32Array?I:new Float32Array(I),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(I){this.material instanceof AI&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===I||void 0===I?void 0:I.length)>0),this._offsets=I,this._offsetsBuffer?this._offsetsBuffer.update(I):this._createOffsetsBuffer(I)}get widths(){return this._widths}set widths(I){this._widths=I,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(I)}get colorPointers(){return this._colorPointers}set colorPointers(I){this._colorPointers=I,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(I)}get greasedLineMaterial(){var I,g;if(this.material&&this.material instanceof AI)return this.material;const b=null===(I=this.material)||void 0===I||null===(g=I.pluginManager)||void 0===g?void 0:g.getPlugin(OI.GREASED_LINE_MATERIAL_NAME);return b||void 0}get points(){const I=[];return iI.b.DeepCopy(this._points,I),I}setPoints(I,g){this._points=CI.ConvertPoints(I,(null===g||void 0===g?void 0:g.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==g&&void 0!==g&&g.colorPointers||this._updateColorPointers(),this._setPoints(this._points,g)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,dI:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(I){super.serialize(I),I.type=this.getClassName(),I.lineOptions=this._createLineOptions()}_createVertexBuffers(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const g=new HI.d;return g.sI=this._vertexPositions,g.indices=this._indices,g.dI=this._uvs,I&&(g.FI=[],HI.d.ComputeNormals(this._vertexPositions,this._indices,g.FI)),g.rI(this,this._options.updatable),g}_createOffsetsBuffer(I){const g=this._scene.getEngine(),b=new G.d(g,I,this._updatable,3);this.setVerticesBuffer(b.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=b}}class KI{constructor(I,g){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=I,this.wasAddedByNoopNode=g}getIndicesAccessor(I,g,b,e,c){var z,M,J,o;return null===(z=this._indicesAccessorMap.get(I))||void 0===z||null===(M=z.get(g))||void 0===M||null===(J=M.get(b))||void 0===J||null===(o=J.get(e))||void 0===o?void 0:o.get(c)}setIndicesAccessor(I,g,b,e,c,z){let M=this._indicesAccessorMap.get(I);M||(M=new Map,this._indicesAccessorMap.set(I,M));let J=M.get(g);J||(J=new Map,M.set(g,J));let o=J.get(b);o||(o=new Map,J.set(b,o));let n=o.get(e);n||(n=new Map,o.set(e,n)),n.set(c,z)}pushExportedNode(I){this._exportedNodes.has(I)||this._exportedNodes.add(I)}getNodesSet(){return this._exportedNodes}getVertexBufferView(I){return this._vertexBufferViewMap.get(I)}setVertexBufferView(I,g){this._vertexBufferViewMap.set(I,g)}setRemappedBufferView(I,g,b){this._remappedBufferView.set(I,new Map),this._remappedBufferView.get(I).set(g,b)}getRemappedBufferView(I,g){var b;return null===(b=this._remappedBufferView.get(I))||void 0===b?void 0:b.get(g)}getVertexAccessor(I,g,b){var e,c;return null===(e=this._vertexAccessorMap.get(I))||void 0===e||null===(c=e.get(g))||void 0===c?void 0:c.get(b)}setVertexAccessor(I,g,b,e){let c=this._vertexAccessorMap.get(I);c||(c=new Map,this._vertexAccessorMap.set(I,c));let z=c.get(g);z||(z=new Map,c.set(g,z)),z.set(b,e)}hasVertexColorAlpha(I){return this._vertexMapColorAlpha.get(I)||!1}setHasVertexColorAlpha(I,g){return this._vertexMapColorAlpha.set(I,g)}getMesh(I){return this._meshMap.get(I)}setMesh(I,g){this._meshMap.set(I,g)}bindMorphDataToMesh(I,g){const b=this._meshMorphTargetMap.get(I)||[];this._meshMorphTargetMap.set(I,b),-1===b.indexOf(g)&&b.push(g)}getMorphTargetsFromMesh(I){return this._meshMorphTargetMap.get(I)}}class BI{_ApplyExtension(I,g,b,e){if(b>=g.length)return Promise.resolve(I);const c=e(g[b],I);return c?c.then((async I=>I?await this._ApplyExtension(I,g,b+1,e):null)):this._ApplyExtension(I,g,b+1,e)}_ApplyExtensions(I,g){const b=[];for(const e of BI._ExtensionNames)b.push(this._extensions[e]);return this._ApplyExtension(I,b,0,g)}_extensionsPreExportTextureAsync(I,g,b){return this._ApplyExtensions(g,((g,e)=>g.preExportTextureAsync&&g.preExportTextureAsync(I,e,b)))}_extensionsPostExportNodeAsync(I,g,b,e,c){return this._ApplyExtensions(g,((g,z)=>g.postExportNodeAsync&&g.postExportNodeAsync(I,z,b,e,c,this._bufferManager)))}_extensionsPostExportMaterialAsync(I,g,b){return this._ApplyExtensions(g,((g,e)=>g.postExportMaterialAsync&&g.postExportMaterialAsync(I,e,b)))}_extensionsPostExportMaterialAdditionalTextures(I,g,b){const e=[];for(const c of BI._ExtensionNames){const z=this._extensions[c];z.postExportMaterialAdditionalTextures&&e.push(...z.postExportMaterialAdditionalTextures(I,g,b))}return e}_extensionsPostExportTextures(I,g,b){for(const e of BI._ExtensionNames){const c=this._extensions[e];c.postExportTexture&&c.postExportTexture(I,g,b)}}_extensionsPostExportMeshPrimitive(I){for(const g of BI._ExtensionNames){const b=this._extensions[g];b.postExportMeshPrimitive&&b.postExportMeshPrimitive(I,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const I of BI._ExtensionNames){const g=this._extensions[I];g.preGenerateBinaryAsync&&await g.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(I){for(const g of BI._ExtensionNames){const b=this._extensions[g];b.enabled&&I(b)}}_extensionsOnExporting(){this._forEachExtensions((I=>{var g,b,e;I.wasUsed&&((g=this._glTF).extensionsUsed||(g.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(I.name)&&this._glTF.extensionsUsed.push(I.name),I.required&&((b=this._glTF).extensionsRequired||(b.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(I.name)&&this._glTF.extensionsRequired.push(I.name)),(e=this._glTF).extensions||(e.extensions={}),I.onExporting&&I.onExporting())}))}_loadExtensions(){for(const I of BI._ExtensionNames){const g=BI._ExtensionFactories[I](this);this._extensions[I]=g}}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:k.b.LastCreatedScene,g=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${Z.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new h(this),this._extensions={},this._bufferManager=new GI,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!I)throw new Error("No scene available to export");this._babylonScene=I,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:I=>{var g;return null===I||void 0===I||null===(g=I.Lg)||void 0===g?void 0:g.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...g},this._loadExtensions()}dispose(){for(const I in this._extensions){this._extensions[I].dispose()}}get options(){return this._options}static RegisterExtension(I,g){BI.UnregisterExtension(I)&&c.Tools.Warn(`Extension with the name ${I} already exists`),BI._ExtensionFactories[I]=g,BI._ExtensionNames.push(I)}static UnregisterExtension(I){if(!BI._ExtensionFactories[I])return!1;delete BI._ExtensionFactories[I];const g=BI._ExtensionNames.indexOf(I);return-1!==g&&BI._ExtensionNames.splice(g,1),!0}_generateJSON(I,g,b){const e={byteLength:I};return e.byteLength&&(this._glTF.buffers=[e]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Xg=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(e.uri=g+".bin"),b?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(I){const g=await this._generateBinaryAsync();this._extensionsOnExporting();const b=this._generateJSON(g.byteLength,I,!0),e=new Blob([g],{type:"application/octet-stream"}),c=I+".gltf",z=I+".bin",M=new n;if(M.files[c]=b,M.files[z]=e,this._imageData)for(const J in this._imageData)M.files[J]=new Blob([this._imageData[J].data],{type:this._imageData[J].mimeType});return M}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(I){const g=I%4;return 0===g?g:4-g}async generateGLBAsync(I){this._shouldUseGlb=!0;const g=await this._generateBinaryAsync();this._extensionsOnExporting();const b=this._generateJSON(g.byteLength),e=I+".glb";let c,z=b.length;if("undefined"!==typeof TextEncoder){c=(new TextEncoder).encode(b),z=c.length}const M=this._getPadding(z),J=this._getPadding(g.byteLength),o=28+z+M+g.byteLength+J,G=new oI(o);if(G.writeUInt32(1179937895),G.writeUInt32(2),G.writeUInt32(o),G.writeUInt32(z+M),G.writeUInt32(1313821514),c)G.writeTypedArray(c);else{const I="_".charCodeAt(0);for(let g=0;g<z;++g){const e=b.charCodeAt(g);e!=b.codePointAt(g)?G.writeUInt8(I):G.writeUInt8(e)}}for(let n=0;n<M;++n)G.writeUInt8(32);G.writeUInt32(g.byteLength+J),G.writeUInt32(5130562),G.writeTypedArray(g);for(let n=0;n<J;++n)G.writeUInt8(0);const D=new n;return D.files[e]=new Blob([G.getOutputData()],{type:"application/octet-stream"}),D}_setNodeTransformation(I,g,b){if(g.getPivotPoint().equalsWithEpsilon(N,L.b)||c.Tools.Warn("Pivot points are not supported in the glTF serializer"),!g.position.equalsWithEpsilon(N,L.b)){const c=e.TmpVectors.Vg[0].G(g.position);b&&w(c),I.translation=c.bb()}g.pb.equalsWithEpsilon(B,L.b)||(I.scale=g.pb.bb());const z=g.rotationQuaternion||e.Quaternion.FromEulerAngles(g.rotation.x,g.rotation.y,g.rotation.z);z.equalsWithEpsilon(K,L.b)||(b&&T(z),I.rotation=z.normalize().bb())}_setCameraTransformation(I,g,b){if(!g.position.equalsWithEpsilon(N,L.b)){const c=e.TmpVectors.Vg[0].G(g.position);b&&w(c),I.translation=c.bb()}const c=g.rotationQuaternion||e.Quaternion.FromEulerAngles(g.rotation.x,g.rotation.y,g.rotation.z);b&&T(c),this._babylonScene.useRightHandedSystem||W(c),c.equalsWithEpsilon(K,L.b)||(I.rotation=c.bb())}_listAvailableCameras(){for(const I of this._babylonScene.cameras){const g={type:I.mode===pI.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(I.name&&(g.name=I.name),"perspective"===g.type)g.perspective={aspectRatio:I.getEngine().getAspectRatio(I),yfov:I.fovMode===pI.b.FOVMODE_VERTICAL_FIXED?I.fov:I.fov*I.getEngine().getAspectRatio(I),znear:I.cb,zfar:I.maxZ};else if("orthographic"===g.type){const b=I.orthoLeft&&I.orthoRight?.5*(I.orthoRight-I.orthoLeft):.5*I.getEngine().getRenderWidth(),e=I.orthoBottom&&I.orthoTop?.5*(I.orthoTop-I.orthoBottom):.5*I.getEngine().getRenderHeight();g.orthographic={xmag:b,ymag:e,znear:I.cb,zfar:I.maxZ}}this._camerasMap.set(I,g)}}_exportAndAssignCameras(){const I=Array.from(this._camerasMap.values());for(const g of I){const I=this._nodesCameraMap.get(g);if(void 0!==I){this._cameras.push(g);for(const g of I)g.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const I of this._babylonScene.skeletons){if(I.bones.length<=0)continue;const g={joints:[]};this._skinMap.set(I,g)}}_exportAndAssignSkeletons(){for(const I of this._babylonScene.skeletons){if(I.bones.length<=0)continue;const g=this._skinMap.get(I);if(void 0==g)continue;const b={},e=[];let z=-1;for(let c=0;c<I.bones.length;++c){const g=I.bones[c],e=g.getIndex()??c;-1!==e&&(b[e]=g,e>z&&(z=e))}for(let I=0;I<=z;++I){const z=b[I];e.push(z.getAbsoluteInverseBindMatrix());const M=z.getTransformNode();if(null!==M){const I=this._nodeMap.get(M);M&&null!==I&&void 0!==I?g.joints.push(I):c.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else c.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const M=this._nodesSkinMap.get(g);if(g.joints.length>0&&void 0!==M){const I=64*e.length,b=new Float32Array(I/4);e.forEach(((I,g)=>{b.set(I.m,16*g)}));const c=this._bufferManager.createBufferView(b);this._accessors.push(this._bufferManager.createAccessor(c,"MAT4",5126,e.length)),g.inverseBindMatrices=this._accessors.length-1,this._skins.push(g);for(const g of M)g.skin=this._skins.length-1}}}async _exportSceneAsync(){const I={nodes:[]};if(this._babylonScene.metadata){const g=this._options.metadataSelector(this._babylonScene.metadata);g&&(I.extras=g)}const g=new Array,b=new Array,e=new Array;for(const J of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&MI(J,this._babylonScene.useRightHandedSystem)?e.push(...J.getChildren()):this._babylonScene.useRightHandedSystem?g.push(J):b.push(J);this._listAvailableCameras(),this._listAvailableSkeletons();const c=new KI(!0,!1);I.nodes.push(...await this._exportNodesAsync(b,c));const z=new KI(!1,!1);I.nodes.push(...await this._exportNodesAsync(g,z));const M=new KI(!1,!0);I.nodes.push(...await this._exportNodesAsync(e,M)),I.nodes.length&&this._scenes.push(I),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&vI._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,c.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(I){let g=this._shouldExportNodeMap.get(I);return void 0===g&&(g=this._options.shouldExportNode(I),this._shouldExportNodeMap.set(I,g)),g}async _exportNodesAsync(I,g){const b=new Array;this._exportBuffers(I,g);for(const e of I)await this._exportNodeAsync(e,b,g);return b}_collectBuffers(I,g,b,e,c){if(this._shouldExportNode(I)&&I instanceof p.e&&I.ob){const z=I.ob.getVertexBuffers();if(z)for(const e in z){if(!y(e))continue;const M=z[e];c.setHasVertexColorAlpha(M,I.hasVertexAlpha);const J=M._buffer,o=g.get(J)||[];g.set(J,o),-1===o.indexOf(M)&&o.push(M);const n=b.get(M)||[];b.set(M,n),-1===n.indexOf(I)&&n.push(I)}const M=I.morphTargetManager;if(M)for(let g=0;g<M.numTargets;g++){const b=M.getTarget(g),c=e.get(b)||[];e.set(b,c),-1===c.indexOf(I)&&c.push(I)}}for(const z of I.getChildren())this._collectBuffers(z,g,b,e,c)}_exportBuffers(I,g){const b=new Map,e=new Map,c=new Map;for(const J of I)this._collectBuffers(J,b,e,c,g);const z=Array.from(b.keys());for(const J of z){const I=J.getData();if(!I)throw new Error("Buffer data is not available");const c=b.get(J);if(!c)continue;const z=c[0].byteStride;if(c.some((I=>I.byteStride!==z)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const M=bI(I).slice();for(const g of c){const I=e.get(g),{byteOffset:b,byteStride:c,componentCount:z,type:J,count:o,normalized:n,kind:D}=u(g,I);switch(D){case G.f.NormalKind:case G.f.TangentKind:(0,A.h)(M,b,c,z,J,o,n,(I=>{const g=Math.sqrt(I[0]*I[0]+I[1]*I[1]+I[2]*I[2]);if(g>0){const b=1/g;I[0]*=b,I[1]*=b,I[2]*=b}}));break;case G.f.ColorKind:{const g=I.filter((I=>I.material instanceof kI.Rg||null==I.material)).length;if(0==g)break;if(g!=I.length){j.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}J==G.f.UNSIGNED_BYTE&&j.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const e=new S.Eg,D=new S.Sb,p=this._babylonScene.getEngine().useExactSrgbConversions;(0,A.h)(M,b,c,z,J,o,n,(I=>{3===I.length?(e.Le(I,0),e.toLinearSpaceToRef(e,p),e.toArray(I,0)):(D.Le(I,0),D.toLinearSpaceToRef(D,p),D.toArray(I,0))}))}}}if(g.convertToRightHanded){for(const I of c){const g=e.get(I),{byteOffset:b,byteStride:c,componentCount:z,type:J,count:o,normalized:n,kind:D}=u(I,g);switch(D){case G.f.PositionKind:case G.f.NormalKind:case G.f.TangentKind:(0,A.h)(M,b,c,z,J,o,n,(I=>{I[0]=-I[0]}))}}g.convertedToRightHandedBuffers.set(J,M)}const o=this._bufferManager.createBufferView(M,z);g.setVertexBufferView(J,o);const n=new Map;for(const g of c){const I=e.get(g),{kind:b,totalVertices:c}=u(g,I);switch(b){case G.f.MatricesIndicesKind:case G.f.MatricesIndicesExtraKind:if(g.type==G.f.FLOAT){const I=g.getFloatData(c);null!==I&&n.set(g,I)}}}0!==n.size&&j.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const D=Array.from(n.keys());for(const b of D){const I=n.get(b);if(!I)continue;const e=I.some((I=>I>=256)),c=new(e?Uint16Array:Uint8Array)(I.length);for(let g=0;g<I.length;g++)c[g]=I[g];const z=this._bufferManager.createBufferView(c,4*(e?2:1));g.setRemappedBufferView(J,b,z)}}const M=Array.from(c.keys());for(const J of M){const I=c.get(J);if(!I)continue;const b=XI(J,I[0],this._bufferManager,this._bufferViews,this._accessors,g.convertToRightHanded);for(const e of I)g.bindMorphDataToMesh(e,b)}}async _exportNodeAsync(I,g,b){let e=this._nodeMap.get(I);if(void 0!==e)return void(g.includes(e)||g.push(e));const c=await this._createNodeAsync(I,b);if(c){e=this._nodes.length,this._nodes.push(c),this._nodeMap.set(I,e),b.pushExportedNode(I),g.push(e);const z={name:"runtime animations",channels:[],samplers:[]},M=[];this._babylonScene.animationGroups.length||(vI._CreateMorphTargetAnimationFromMorphTargetAnimations(I,z,M,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,b.convertToRightHanded,this._options.shouldExportAnimation),I.animations.length&&vI._CreateNodeAnimationFromNodeAnimations(I,z,M,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,b.convertToRightHanded,this._options.shouldExportAnimation)),z.channels.length&&z.samplers.length&&this._animations.push(z),M.forEach((I=>{I.channels.length&&I.samplers.length&&this._animations.push(I)}))}const z=c?[]:g;for(const M of I.getChildren())await this._exportNodeAsync(M,z,b);c&&z.length&&(c.children=z)}async _createNodeAsync(I,g){if(!this._shouldExportNode(I))return null;const b={};if(I.name&&(b.name=I.name),I.metadata){const g=this._options.metadataSelector(I.metadata);g&&(b.extras=g)}if(I instanceof D.d&&(this._setNodeTransformation(b,I,g.convertToRightHanded),I instanceof p.e)){const c=I instanceof x.e?I.sourceMesh:I;if(c.Ib&&c.Ib.length>0&&(b.mesh=await this._exportMeshAsync(c,g)),I.skeleton){const g=this._skinMap.get(I.skeleton);var e;if(void 0!==g)void 0===this._nodesSkinMap.get(g)&&this._nodesSkinMap.set(g,[]),null===(e=this._nodesSkinMap.get(g))||void 0===e||e.push(b)}}if(I instanceof Q.d){const e=this._camerasMap.get(I);if(e){var c;void 0===this._nodesCameraMap.get(e)&&this._nodesCameraMap.set(e,[]),this._setCameraTransformation(b,I,g.convertToRightHanded);const M=I.parent;if(null!==M&&gI(I,M)){const I=this._nodeMap.get(M);if(void 0!==I){var z;const g=this._nodes[I];return II(b,g),null===(z=this._nodesCameraMap.get(e))||void 0===z||z.push(g),null}}null===(c=this._nodesCameraMap.get(e))||void 0===c||c.push(b)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",b,I,this._nodeMap,g.convertToRightHanded)?b:(j.b.Warn(`Not exporting node ${I.name}`),null)}_exportIndices(I,g,b,e,c,M,J,o,n){let G=I;n.mode=q(M);const D=J!==z.b.CounterClockWiseSideOrientation,p=!o.wasAddedByNoopNode&&D,x=function(I){switch(I){case z.b.TriangleFillMode:case z.b.TriangleStripDrawMode:case z.b.TriangleFanDrawMode:return!0}return!1}(M)&&p;if(x){if(M===z.b.TriangleStripDrawMode||M===z.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");n.mode=q(M);const J=g?new Uint32Array(e):new Uint16Array(e);if(I)for(let g=0;g+2<e;g+=3)J[g]=I[b+g]+c,J[g+1]=I[b+g+2]+c,J[g+2]=I[b+g+1]+c;else for(let I=0;I+2<e;I+=3)J[I]=I,J[I+1]=I+2,J[I+2]=I+1;G=J}else if(I&&0!==c){const z=g?new Uint32Array(e):new Uint16Array(e);for(let g=0;g<e;g++)z[g]=I[b+g]+c;G=z}if(G){let z=o.getIndicesAccessor(I,b,e,c,x);if(void 0===z){const M=function(I,g,b,e){if(I instanceof Uint16Array||I instanceof Uint32Array)return I;if(I instanceof Int32Array)return new Uint32Array(I.buffer,I.byteOffset,I.length);const c=I.slice(g,g+b);return e?new Uint32Array(c):new Uint16Array(c)}(G,0,e,g),J=this._bufferManager.createBufferView(M),n=g?5125:5123;this._accessors.push(this._bufferManager.createAccessor(J,"SCALAR",n,e,0)),z=this._accessors.length-1,o.setIndicesAccessor(I,b,e,c,x,z)}n.indices=z}}_exportVertexBuffer(I,g,b,e,c,z){const M=I.getKind();if(!y(M))return;if(M.startsWith("uv")&&!this._options.exportUnusedUVs&&(!g||!this._materialNeedsUVsSet.has(g)))return;let J=c.getVertexAccessor(I,b,e);if(void 0===J){const g=c.convertedToRightHandedBuffers.get(I._buffer)||I._buffer.getData(),z=M===G.f.PositionKind?function(I,g,b,e){const{byteOffset:c,byteStride:z,type:M,normalized:J}=g,o=g.getSize(),n=new Array(o).fill(1/0),G=new Array(o).fill(-1/0);return(0,A.h)(I,c+b*z,z,o,M,e*o,J,(I=>{for(let g=0;g<o;g++)n[g]=Math.min(n[g],I[g]),G[g]=Math.max(G[g],I[g])})),{min:n,max:G}}(g,I,b,e):void 0,o=(M===G.f.MatricesIndicesKind||M===G.f.MatricesIndicesExtraKind)&&I.type===G.f.FLOAT,n=o?G.f.UNSIGNED_BYTE:I.type,D=o?void 0:I.normalized,p=o?c.getRemappedBufferView(I._buffer,I):c.getVertexBufferView(I._buffer),x=I.byteOffset+b*I.byteStride;this._accessors.push(this._bufferManager.createAccessor(p,function(I,g){if(I==G.f.ColorKind)return g?"VEC4":"VEC3";switch(I){case G.f.PositionKind:case G.f.NormalKind:return"VEC3";case G.f.TangentKind:case G.f.MatricesIndicesKind:case G.f.MatricesIndicesExtraKind:case G.f.MatricesWeightsKind:case G.f.MatricesWeightsExtraKind:return"VEC4";case G.f.UVKind:case G.f.UV2Kind:case G.f.UV3Kind:case G.f.UV4Kind:case G.f.UV5Kind:case G.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${I}`)}(M,c.hasVertexColorAlpha(I)),n,e,x,z,D)),J=this._accessors.length-1,c.setVertexAccessor(I,b,e,J)}z.attributes[function(I){switch(I){case G.f.PositionKind:return"POSITION";case G.f.NormalKind:return"NORMAL";case G.f.TangentKind:return"TANGENT";case G.f.ColorKind:return"COLOR_0";case G.f.UVKind:return"TEXCOORD_0";case G.f.UV2Kind:return"TEXCOORD_1";case G.f.UV3Kind:return"TEXCOORD_2";case G.f.UV4Kind:return"TEXCOORD_3";case G.f.UV5Kind:return"TEXCOORD_4";case G.f.UV6Kind:return"TEXCOORD_5";case G.f.MatricesIndicesKind:return"JOINTS_0";case G.f.MatricesIndicesExtraKind:return"JOINTS_1";case G.f.MatricesWeightsKind:return"WEIGHTS_0";case G.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${I}`)}(M)]=J}async _exportMaterialAsync(I,g,b,e){let c=this._materialMap.get(I);if(void 0===c){const e=g&&Object.keys(g).some((I=>I.startsWith("uv")));if((I=I instanceof xI.e?I.fb[b.materialIndex]:I)instanceof ZI.b)c=await this._materialExporter.exportPBRMaterialAsync(I,"image/png",e);else{if(!(I instanceof kI.Rg))return void j.b.Warn(`Unsupported material '${I.name}' with type ${I.getClassName()}`);c=await this._materialExporter.exportStandardMaterialAsync(I,"image/png",e)}this._materialMap.set(I,c)}e.material=c}async _exportMeshAsync(I,g){var b;let e=g.getMesh(I);if(void 0!==e)return e;const c={primitives:[]};e=this._meshes.length,this._meshes.push(c),g.setMesh(I,e);const M=I.isUnIndexed?null:I.nb(),J=null===(b=I.ob)||void 0===b?void 0:b.getVertexBuffers(),o=g.getMorphTargetsFromMesh(I),n=I instanceof RI.b,G=I instanceof NI,D=I.Ib;if(J&&D&&D.length>0)for(const Z of D){const b={attributes:{}},e=Z.hI()||this._babylonScene.defaultMaterial;if(G){var p,x;const g={name:e.name},c=I,z=S.Eg.White(),M=(null===(p=c.material)||void 0===p?void 0:p.alpha)??1,J=(null===(x=c.greasedLineMaterial)||void 0===x?void 0:x.color)??z;(!J.equalsWithEpsilon(z,L.b)||M<1)&&(g.pbrMetallicRoughness={baseColorFactor:[...J.bb(),M]}),this._materials.push(g),b.material=this._materials.length-1}else if(n){const g={name:e.name},c=I;(!c.color.equalsWithEpsilon(S.Eg.White(),L.b)||c.alpha<1)&&(g.pbrMetallicRoughness={baseColorFactor:[...c.color.bb(),c.alpha]}),this._materials.push(g),b.material=this._materials.length-1}else await this._exportMaterialAsync(e,J,Z,b);const D=n||G?z.b.LineListDrawMode:I.overrideRenderingFillMode??e.fillMode,k=e._getEffectiveOrientation(I);this._exportIndices(M,M?(0,A.d)(M,Z.indexCount,Z.indexStart,Z.verticesStart):Z.verticesCount>65535,M?Z.indexStart:Z.verticesStart,M?Z.indexCount:Z.verticesCount,-Z.verticesStart,D,k,g,b);for(const I of Object.values(J))this._exportVertexBuffer(I,e,Z.verticesStart,Z.verticesCount,g,b);if(o){b.targets=[];for(const I of o)b.targets.push(I.attributes)}c.primitives.push(b),this._extensionsPostExportMeshPrimitive(b)}if(o){c.weights=[],c.extras||(c.extras={}),c.extras.targetNames=[];for(const I of o)c.weights.push(I.influence),c.extras.targetNames.push(I.name)}return e}}BI._ExtensionNames=new Array,BI._ExtensionFactories={};class PI{static async GLTFAsync(I,g,b){b&&b.exportWithoutWaitingForScene||await I.whenReadyAsync();const e=new BI(I,b),c=await e.generateGLTFAsync(g.replace(/\.[^/.]+$/,""));return e.dispose(),c}static async GLBAsync(I,g,b){b&&b.exportWithoutWaitingForScene||await I.whenReadyAsync();const e=new BI(I,b),c=await e.generateGLBAsync(g.replace(/\.[^/.]+$/,""));return e.dispose(),c}}b(13135);const uI="EXT_mesh_gpu_instancing";class tI{constructor(I){this.name=uI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(I,g,b,c,z,M){return await new Promise((I=>{if(g&&b instanceof VI.e&&b.hasThinInstances&&this._exporter){this._wasUsed=!0;const I=e.Vg.Zero(),c=e.Quaternion.Identity(),J=e.Vg.One(),o=b.thinInstanceGetWorldMatrices(),n=e.TmpVectors.Vg[2],G=e.TmpVectors.Quaternion[1],D=e.TmpVectors.Vg[3];let p=!1,x=!1,Z=!1;const k=new Float32Array(3*b.ab),S=new Float32Array(4*b.ab),f=new Float32Array(3*b.ab);let V=0;for(const g of o)g.decompose(D,G,n),z&&(w(n),T(G)),k.set(n.bb(),3*V),S.set(G.normalize().bb(),4*V),f.set(D.bb(),3*V),p=p||!n.equalsWithEpsilon(I),x=x||!G.equalsWithEpsilon(c),Z=Z||!D.equalsWithEpsilon(J),V++;const a={attributes:{}};p&&(a.attributes.TRANSLATION=this._buildAccessor(k,"VEC3",b.ab,M)),x&&(a.attributes.ROTATION=this._buildAccessor(S,"VEC4",b.ab,M)),Z&&(a.attributes.SCALE=this._buildAccessor(f,"VEC3",b.ab,M)),g.extensions=g.extensions||{},g.extensions[uI]=a}I(g)}))}_buildAccessor(I,g,b,e){const c=e.createBufferView(I),z=e.createAccessor(c,g,5126,b);return this._exporter._accessors.push(z),this._exporter._accessors.length-1}}BI.RegisterExtension(uI,(I=>new tI(I)));var yI=b(13138),qI=b(13145),lI=b(13152),wI=b(13158);function TI(I){return I===lI.b.PositionKind?"POSITION":I===lI.b.NormalKind?"NORMAL":I===lI.b.ColorKind?"COLOR":I.startsWith(lI.b.UVKind)?"TEX_COORD":"GENERIC"}const WI={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Ig extends yI.c{static get DefaultAvailable(){return(0,yI.i)(Ig.DefaultConfiguration)}static get Default(){return Ig._Default??(Ig._Default=new Ig),Ig._Default}static ResetDefault(I){Ig._Default&&(I||Ig._Default.dispose(),Ig._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(I,g){return{module:await(g||DracoEncoderModule)({wasmBinary:I})}}_getWorkerContent(){return`${qI.h}(${qI.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ig.DefaultConfiguration)}async _encodeAsync(I,g,b){const e=b?(0,wI.e)(WI,b):WI;if(this._workerPoolPromise){const b=await this._workerPoolPromise;return await new Promise(((c,z)=>{b.push(((b,M)=>{const J=I=>{b.removeEventListener("error",J),b.removeEventListener("message",o),z(I),M()},o=I=>{"encodeMeshDone"===I.data.id&&(b.removeEventListener("error",J),b.removeEventListener("message",o),c(I.data.encodedMeshData),M())};b.addEventListener("error",J),b.addEventListener("message",o);const n=[];for(const g of I)n.push(g.data.buffer);g&&n.push(g.buffer),b.postMessage({id:"encodeMesh",attributes:I,indices:g,options:e},n)}))}))}if(this._modulePromise){const b=await this._modulePromise;return(0,qI.h)(b.module,I,g,e)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(I,g){if(0==I.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");I instanceof VI.e&&I.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===g||void 0===g?void 0:g.method)&&(j.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),g.method="MESH_SEQUENTIAL_ENCODING");const b=function(I){let g=I.nb(void 0,!0);return!g||g instanceof Uint32Array||g instanceof Uint16Array||(g=((0,A.d)(g,g.length)?Uint32Array:Uint16Array).from(g)),g}(I),e=function(I,g){const b=[];for(const e of I.getVerticesDataKinds()){if(null!==g&&void 0!==g&&g.includes(e)){if(e===lI.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const c=I.getVertexBuffer(e),z=c.getSize(),M=(0,A.v)(c.getData(),z,c.type,c.byteOffset,c.byteStride,c.normalized,I.getTotalVertices(),!0);b.push({kind:e,dracoName:TI(e),size:z,data:M})}return b}(I,null===g||void 0===g?void 0:g.excludedAttributes);return await this._encodeAsync(e,b,g)}}Ig.DefaultConfiguration={wasmUrl:`${c.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${c.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${c.Tools._DefaultCdnUrl}/draco_encoder.js`},Ig._Default=null;const gg="KHR_draco_mesh_compression";class bg{get wasUsed(){return this._wasUsed}constructor(I){this.name=gg,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===I.options.meshCompressionMethod&&Ig.DefaultAvailable}dispose(){}postExportMeshPrimitive(I,g,b){if(!this.enabled)return;if(4!==I.mode&&5!==I.mode)return void j.b.Warn("Cannot compress primitive with mode "+I.mode+".");const e=[],c=[];let z=null;if(void 0!==I.indices){const M=b[I.indices],J=g.getBufferView(M);z=g.getData(J).slice(),e.push(J),c.push(M)}const M=[];for(const[G,D]of Object.entries(I.attributes)){const I=b[D],z=g.getBufferView(I),o=t(I.type),n=(0,A.v)(g.getData(z),o,I.componentType,I.byteOffset||0,z.byteStride||(0,A.o)(I.componentType)*o,I.normalized||!1,I.count,!0);M.push({kind:G,dracoName:(J=G,"POSITION"===J?"POSITION":"NORMAL"===J?"NORMAL":J.startsWith("COLOR")?"COLOR":J.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:t(I.type),data:n}),e.push(z),c.push(I)}var J;const o={method:I.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},n=Ig.Default._encodeAsync(M,z,o).then((b=>{if(!b)return void j.b.Error("Draco encoding failed for primitive.");const z={bufferView:-1,attributes:b.attributeIds},M=g.createBufferView(b.data);g.setBufferView(z,M);for(const I of e)this._bufferViewsUsed.add(I);for(const I of c)this._accessorsUsed.add(I);I.extensions||(I.extensions={}),I.extensions[gg]=z})).catch((I=>{j.b.Error("Draco encoding failed for primitive: "+I)}));this._encodePromises.push(n),this._wasUsed=!0}async preGenerateBinaryAsync(I){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((g=>{I.getPropertiesWithBufferView(g).every((I=>this._accessorsUsed.has(I)))&&I.removeBufferView(g)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}BI.RegisterExtension(gg,(I=>new bg(I)));var eg=b(13161);const cg="KHR_lights_punctual",zg={name:"",color:[1,1,1],Xb:1,range:Number.MAX_VALUE},Mg={innerConeAngle:0,outerConeAngle:Math.PI/4},Jg=e.Vg.Backward();class og{constructor(I){this.name=cg,this.enabled=!0,this.required=!1,this._exporter=I}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[cg]=this._lights}async postExportNodeAsync(I,g,b,c,z){return await new Promise((M=>{if(!(b instanceof aI.d))return void M(g);const J=b.getTypeID()==aI.d.LIGHTTYPEID_POINTLIGHT?"point":b.getTypeID()==aI.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":b.getTypeID()==aI.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!J||!(b instanceof eg.b))return j.b.Warn(`${I}: Light ${b.name} is not supported in ${cg}`),void M(g);if(b.falloffType!==aI.d.FALLOFF_GLTF&&j.b.Warn(`${I}: Light falloff for ${b.name} does not match the ${cg} specification!`),!b.position.equalsToFloats(0,0,0)){const I=e.TmpVectors.Vg[0].G(b.position);z&&w(I),g.translation=I.bb()}if("point"!==J){const I=b.direction.normalizeToRef(e.TmpVectors.Vg[0]);z&&w(I);const c=e.Quaternion.FromUnitVectorsToRef(Jg,I,e.TmpVectors.Quaternion[0]);e.Quaternion.IsIdentity(c)||(g.rotation=c.bb())}const o={type:J,name:b.name,color:b.Rb.bb(),Xb:b.Xb,range:b.range};if(eI(o,zg),"spot"===J){const I=b;o.spot={innerConeAngle:I.innerAngle/2,outerConeAngle:I.angle/2},eI(o.spot,Mg)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(o);const n={vg:this._lights.lights.length-1},G=b.parent;if(G&&gI(b,G)){const I=c.get(G);if(I){const b=this._exporter._nodes[I];return II(g,b),b.extensions||(b.extensions={}),b.extensions[cg]=n,void M(null)}}g.extensions||(g.extensions={}),g.extensions[cg]=n,M(g)}))}}BI.RegisterExtension(cg,(I=>new og(I)));var ng=b(13086);const Gg="KHR_materials_anisotropy";class Dg{constructor(I){this.name=Gg,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,g,b){const e=[];return b instanceof ng.c&&b.anisotropy.isEnabled&&!b.anisotropy.legacy?(b.anisotropy.texture&&e.push(b.anisotropy.texture),e):[]}postExportMaterialAsync(I,g,b){return new Promise((I=>{if(b instanceof ng.c){if(!b.anisotropy.isEnabled||b.anisotropy.legacy)return void I(g);this._wasUsed=!0,g.extensions=g.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(b.anisotropy.texture),c={anisotropyStrength:b.anisotropy.Xb,anisotropyRotation:b.anisotropy.angle,anisotropyTexture:e??void 0};null!==c.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(b),g.extensions[Gg]=c}I(g)}))}}BI.RegisterExtension(Gg,(I=>new Dg(I)));const pg="KHR_materials_clearcoat";class xg{constructor(I){this.name=pg,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,g,b){const e=[];return b instanceof ng.c&&b.clearCoat.isEnabled?(b.clearCoat.texture&&e.push(b.clearCoat.texture),!b.clearCoat.useRoughnessFromMainTexture&&b.clearCoat.textureRoughness&&e.push(b.clearCoat.textureRoughness),b.clearCoat.bumpTexture&&e.push(b.clearCoat.bumpTexture),e):[]}postExportMaterialAsync(I,g,b){return new Promise((I=>{if(b instanceof ng.c){if(!b.clearCoat.isEnabled)return void I(g);this._wasUsed=!0,g.extensions=g.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(b.clearCoat.texture);let z;z=b.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(b.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(b.clearCoat.textureRoughness),b.clearCoat.isTintEnabled&&c.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${b.name}`),b.clearCoat.remapF0OnInterfaceChange&&c.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${b.name}`);const M=this._exporter._materialExporter.getTextureInfo(b.clearCoat.bumpTexture),J={clearcoatFactor:b.clearCoat.Xb,clearcoatTexture:e??void 0,clearcoatRoughnessFactor:b.clearCoat.roughness,clearcoatRoughnessTexture:z??void 0,clearcoatNormalTexture:M??void 0};null===J.clearcoatTexture&&null===J.clearcoatRoughnessTexture&&null===J.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(b),g.extensions[pg]=J}I(g)}))}}BI.RegisterExtension(pg,(I=>new xg(I)));const Zg="KHR_materials_diffuse_transmission";function kg(I,g){const b=g.subSurface;let e=null;return b.translucencyIntensityTexture?e=b.translucencyIntensityTexture:b.thicknessTexture&&b.useMaskFromThicknessTexture&&(e=b.thicknessTexture),e&&!b.useGltfStyleTextures?(j.b.Warn(`${I}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${g.name}`,1),null):e}class Sg{constructor(I){this.name=Zg,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,g,b){const e=[];if(b instanceof ZI.b&&this._isExtensionEnabled(b)){const g=kg(I,b);return g&&e.push(g),b.subSurface.translucencyColorTexture&&e.push(b.subSurface.translucencyColorTexture),e}return e}_isExtensionEnabled(I){if(I.unlit)return!1;const g=I.subSurface;return!!g.isTranslucencyEnabled&&(!I.unlit&&!g.useAlbedoToTintTranslucency&&g.useGltfStyleTextures&&1===g.volumeIndexOfRefraction&&0===g.minimumThickness&&0===g.maximumThickness)}postExportMaterialAsync(I,g,b){return new Promise((e=>{if(b instanceof ZI.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const e=b.subSurface,c=kg(I,b),z=0==e.translucencyIntensity?void 0:e.translucencyIntensity,M=this._exporter._materialExporter.getTextureInfo(c)??void 0,J=!e.translucencyColor||e.translucencyColor.equalsFloats(1,1,1)?void 0:e.translucencyColor.bb(),o=this._exporter._materialExporter.getTextureInfo(e.translucencyColorTexture)??void 0,n={diffuseTransmissionFactor:z,diffuseTransmissionTexture:M,diffuseTransmissionColorFactor:J,diffuseTransmissionColorTexture:o};(M||o)&&this._exporter._materialNeedsUVsSet.add(b),g.extensions=g.extensions||{},g.extensions[Zg]=n}e(g)}))}}BI.RegisterExtension(Zg,(I=>new Sg(I)));const fg="KHR_materials_dispersion";class Vg{constructor(){this.name=fg,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(I){if(I.unlit)return!1;const g=I.subSurface;return!(!g.isRefractionEnabled&&!g.isDispersionEnabled)}postExportMaterialAsync(I,g,b){return new Promise((I=>{if(b instanceof ZI.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const I={dispersion:b.subSurface.dispersion};g.extensions=g.extensions||{},g.extensions[fg]=I}I(g)}))}}BI.RegisterExtension(fg,(()=>new Vg));const ag="KHR_materials_emissive_strength";class vg{constructor(){this.name=ag,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(I,g,b){return await new Promise((I=>{if(!(b instanceof ZI.b))return I(g);const e=b.emissiveColor.bb(),c=Math.max(...e);if(c>1){this._wasUsed=!0,g.extensions||(g.extensions={});const I={emissiveStrength:c},e=b.emissiveColor.scale(1/I.emissiveStrength);g.emissiveFactor=e.bb(),g.extensions[ag]=I}return I(g)}))}}BI.RegisterExtension(ag,(I=>new vg));const Xg="KHR_materials_ior";class Rg{constructor(){this.name=Xg,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(I){return!I.unlit&&(void 0!=I.indexOfRefraction&&1.5!=I.indexOfRefraction)}postExportMaterialAsync(I,g,b){return new Promise((I=>{if(b instanceof ZI.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const I={ior:b.indexOfRefraction};g.extensions=g.extensions||{},g.extensions[Xg]=I}I(g)}))}}BI.RegisterExtension(Xg,(I=>new Rg));const Eg="KHR_materials_iridescence";class mb{constructor(I){this.name=Eg,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,g,b){const e=[];return b instanceof ng.c&&b.iridescence.isEnabled?(b.iridescence.texture&&e.push(b.iridescence.texture),b.iridescence.thicknessTexture&&b.iridescence.thicknessTexture!==b.iridescence.texture&&e.push(b.iridescence.thicknessTexture),e):[]}postExportMaterialAsync(I,g,b){return new Promise((I=>{if(b instanceof ng.c){if(!b.iridescence.isEnabled)return void I(g);this._wasUsed=!0,g.extensions=g.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(b.iridescence.texture),c=this._exporter._materialExporter.getTextureInfo(b.iridescence.thicknessTexture),z={iridescenceFactor:b.iridescence.Xb,iridescenceIor:b.iridescence.indexOfRefraction,iridescenceThicknessMinimum:b.iridescence.minimumThickness,iridescenceThicknessMaximum:b.iridescence.maximumThickness,iridescenceTexture:e??void 0,iridescenceThicknessTexture:c??void 0};null===z.iridescenceTexture&&null===z.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(b),g.extensions[Eg]=z}I(g)}))}}BI.RegisterExtension(Eg,(I=>new mb(I)));const sg="KHR_materials_sheen";class Fg{constructor(I){this.name=sg,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,g,b){return b instanceof ZI.b&&b.sheen.isEnabled&&b.sheen.texture?[b.sheen.texture]:[]}async postExportMaterialAsync(I,g,b){return await new Promise((I=>{if(b instanceof ZI.b){if(!b.sheen.isEnabled)return void I(g);this._wasUsed=!0,null==g.extensions&&(g.extensions={});const e={sheenColorFactor:b.sheen.color.bb(),sheenRoughnessFactor:b.sheen.roughness??0};null===e.sheenColorTexture&&null===e.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(b),b.sheen.texture&&(e.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.texture)??void 0),b.sheen.textureRoughness&&!b.sheen.useRoughnessFromMainTexture?e.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.textureRoughness)??void 0:b.sheen.texture&&b.sheen.useRoughnessFromMainTexture&&(e.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.texture)??void 0),g.extensions[sg]=e}I(g)}))}}BI.RegisterExtension(sg,(I=>new Fg(I)));const Yg="KHR_materials_specular";class dg{constructor(I){this.name=Yg,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,g,b){const e=[];return b instanceof ZI.b&&this._isExtensionEnabled(b)?(b.metallicReflectanceTexture&&e.push(b.metallicReflectanceTexture),b.reflectanceTexture&&e.push(b.reflectanceTexture),e):e}_isExtensionEnabled(I){return!I.unlit&&(void 0!=I.metallicF0Factor&&1!=I.metallicF0Factor||void 0!=I.metallicReflectanceColor&&!I.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(I))}_hasTexturesExtension(I){return null!=I.metallicReflectanceTexture||null!=I.reflectanceTexture}postExportMaterialAsync(I,g,b){return new Promise((I=>{if(b instanceof ZI.b&&this._isExtensionEnabled(b)){this._wasUsed=!0,g.extensions=g.extensions||{};const I=this._exporter._materialExporter.getTextureInfo(b.metallicReflectanceTexture)??void 0,e=this._exporter._materialExporter.getTextureInfo(b.reflectanceTexture)??void 0,c={specularFactor:1==b.metallicF0Factor?void 0:b.metallicF0Factor,specularTexture:I,specularColorFactor:b.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:b.metallicReflectanceColor.bb(),specularColorTexture:e};this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),g.extensions[Yg]=c}I(g)}))}}BI.RegisterExtension(Yg,(I=>new dg(I)));const Cg="KHR_materials_transmission";class rg{constructor(I){this.name=Cg,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,g,b){const e=[];return b instanceof ZI.b&&this._isExtensionEnabled(b)?(b.subSurface.thicknessTexture&&e.push(b.subSurface.thicknessTexture),e):e}_isExtensionEnabled(I){if(I.unlit)return!1;const g=I.subSurface;return g.isRefractionEnabled&&void 0!=g.refractionIntensity&&0!=g.refractionIntensity||this._hasTexturesExtension(I)}_hasTexturesExtension(I){return null!=I.subSurface.refractionIntensityTexture}async postExportMaterialAsync(I,g,b){if(b instanceof ZI.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const e=b.subSurface,c={transmissionFactor:0===e.refractionIntensity?void 0:e.refractionIntensity};if(this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),e.refractionIntensityTexture)if(e.useGltfStyleTextures){const I=await this._exporter._materialExporter.exportTextureAsync(e.refractionIntensityTexture,"image/png");I&&(c.transmissionTexture=I)}else j.b.Warn(`${I}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);g.extensions||(g.extensions={}),g.extensions[Cg]=c}return g}}BI.RegisterExtension(Cg,(I=>new rg(I)));const Og="KHR_materials_unlit";class Hg{constructor(){this.name=Og,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(I,g,b){return new Promise((I=>{let e=!1;b instanceof ZI.b?e=b.unlit:b instanceof kI.Rg&&(e=b.disableLighting),e&&(this._wasUsed=!0,null==g.extensions&&(g.extensions={}),g.extensions[Og]={}),I(g)}))}}BI.RegisterExtension(Og,(()=>new Hg));const ig="KHR_materials_volume";class Ug{constructor(I){this.name=ig,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,g,b){const e=[];return b instanceof ZI.b&&this._isExtensionEnabled(b)?(b.subSurface.thicknessTexture&&e.push(b.subSurface.thicknessTexture),e):e}_isExtensionEnabled(I){if(I.unlit)return!1;const g=I.subSurface;return!(!g.isRefractionEnabled&&!g.isTranslucencyEnabled)&&(void 0!=g.maximumThickness&&0!=g.maximumThickness||void 0!=g.tintColorAtDistance&&g.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=g.tintColor&&g.tintColor!=S.Eg.White()||this._hasTexturesExtension(I))}_hasTexturesExtension(I){return null!=I.subSurface.thicknessTexture}postExportMaterialAsync(I,g,b){return new Promise((I=>{if(b instanceof ZI.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const I=b.subSurface,e={thicknessFactor:0==I.maximumThickness?void 0:I.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(I.thicknessTexture)??void 0,attenuationDistance:I.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:I.tintColorAtDistance,attenuationColor:I.tintColor.equalsFloats(1,1,1)?void 0:I.tintColor.bb()};this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),g.extensions=g.extensions||{},g.extensions[ig]=e}I(g)}))}}BI.RegisterExtension(ig,(I=>new Ug(I)));const hg="EXT_materials_diffuse_roughness";class Ag{constructor(I){this.name=hg,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,g,b){const e=[];return b instanceof ng.c&&b._baseDiffuseRoughness?(b._baseDiffuseRoughnessTexture&&e.push(b._baseDiffuseRoughnessTexture),e):[]}postExportMaterialAsync(I,g,b){return new Promise((I=>{if(b instanceof ng.c){if(!b._baseDiffuseRoughness)return void I(g);this._wasUsed=!0,g.extensions=g.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(b._baseDiffuseRoughnessTexture),c={diffuseRoughnessFactor:b._baseDiffuseRoughness,diffuseRoughnessTexture:e??void 0};null!==c.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(b),g.extensions[hg]=c}I(g)}))}}BI.RegisterExtension(hg,(I=>new Ag(I)));const jg="KHR_texture_transform";class Qg{constructor(){this.name=jg,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(I,g,b){if(b.EI()||c.Tools.Warn(`${I}: /*@__KEY__*/"scene" is not defined for Babylon texture ${b.name}!`),(0!==b.uAng||0!==b.vAng)&&(c.Tools.Warn(`${I}: Texture ${b.name} with rotation in the u or v axis is not supported in glTF.`),0!==b.uRotationCenter||0!==b.vRotationCenter))return;const e={};let z=!1;if(0===b.uOffset&&0===b.vOffset||(e.offset=[b.uOffset,b.vOffset],z=!0),1===b.uScale&&1===b.vScale||(e.scale=[b.uScale,b.vScale],z=!0),0!==b.wAng){if(0!==b.uRotationCenter||0!==b.vRotationCenter){if(b.homogeneousRotationInUVTransform&&b.uScale!==b.vScale)return void c.Tools.Warn(`${I}: Texture ${b.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${jg}.`);c.Tools.Warn(`${I}: Texture ${b.name} with non-origin rotation center will be exported using an adjusted offset with ${jg}.`),e.offset=function(I){const{uOffset:g,vOffset:b,uRotationCenter:e,vRotationCenter:c,uScale:z,vScale:M,wAng:J}=I,o=Math.cos(J),n=Math.sin(J),G=e*z,D=c*M;return[g+(G*(1-o)+D*n),b+(D*(1-o)-G*n)]}(b)}e.rotation=-b.wAng,z=!0}0!==b.coordinatesIndex&&(e.texCoord=b.coordinatesIndex,z=!0),z&&(this._wasUsed=!0,g.extensions||(g.extensions={}),g.extensions[jg]=e)}}BI.RegisterExtension(jg,(()=>new Qg));class Lg{static CreateSTL(I){let g=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",c=arguments.length>3&&void 0!==arguments[3]&&arguments[3],z=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],M=arguments.length>5&&void 0!==arguments[5]&&arguments[5],J=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const n=function(I,g,b){const c=[3*I[b],3*I[b+1],3*I[b+2]],z=[new e.Vg(g[c[0]],g[c[0]+2],g[c[0]+1]),new e.Vg(g[c[1]],g[c[1]+2],g[c[1]+1]),new e.Vg(g[c[2]],g[c[2]+2],g[c[2]+1])],M=z[0].ag(z[1]),J=z[2].ag(z[1]);return{v:z,n:e.Vg.Cross(J,M).normalize()}},D=function(I,g,b,e){return g=p(I,g,b.x,e),g=p(I,g,b.y,e),p(I,g,b.z,e)},p=function(I,g,b,e){return I.setFloat32(g,b,e),g+4},Z=function(I){if(J){let g=I;I instanceof x.e&&(g=I.sourceMesh);const b=g.getVerticesData(G.f.PositionKind,!0,!0);if(!b)return[];const c=e.Vg.Zero();let z;for(z=0;z<b.length;z+=3)e.Vg.TransformCoordinatesFromFloatsToRef(b[z],b[z+1],b[z+2],I.Mb(!0),c).toArray(b,z);return b}return I.getVerticesData(G.f.PositionKind)||[]};J&&(M=!0);let k="",S=0,f=0;if(c){for(let b=0;b<I.length;b++){const g=I[b].nb();S+=g?g.length/3:0}const g=new ArrayBuffer(84+50*S);k=new DataView(g),f+=80,k.setUint32(f,S,z),f+=4}else o||(k="solid stlmesh\r\n");for(let e=0;e<I.length;e++){const g=I[e];!c&&o&&(k+="solid "+g.name+"\r\n"),!M&&g instanceof VI.e&&g.bakeCurrentTransformIntoVertices();const b=Z(g),J=g.nb()||[];for(let I=0;I<J.length;I+=3){const g=n(J,b,I);c?(f=D(k,f,g.n,z),f=D(k,f,g.v[0],z),f=D(k,f,g.v[1],z),f=D(k,f,g.v[2],z),f+=2):(k+="\tfacet normal "+g.n.x+" "+g.n.y+" "+g.n.z+"\r\n",k+="\t\touter loop\r\n",k+="\t\t\tvertex "+g.v[0].x+" "+g.v[0].y+" "+g.v[0].z+"\r\n",k+="\t\t\tvertex "+g.v[1].x+" "+g.v[1].y+" "+g.v[1].z+"\r\n",k+="\t\t\tvertex "+g.v[2].x+" "+g.v[2].y+" "+g.v[2].z+"\r\n",k+="\t\tendloop\r\n",k+="\tendfacet\r\n")}!c&&o&&(k+="endsolid "+name+"\r\n")}if(c||o||(k+="endsolid stlmesh"),g){const I=document.createElement("a"),g=new Blob([k],{type:"application/octet-stream"});I.href=window.URL.createObjectURL(g),I.download=b+".stl",I.click()}return k}}function Ng(I,g){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const e=[];for(let c=0;c<I.length/b;c++){const z=I[c*b],M=I[c*b+1],J=I[c*b+2];e.push(`(${z.toPrecision(g.precision)}, ${M.toPrecision(g.precision)}, ${J.toPrecision(g.precision)})`)}return e.join(", ")}function Kg(I,g){const b=[];for(let e=0;e<I.length/2;e++){const c=I[2*e],z=I[2*e+1];b.push(`(${c.toPrecision(g.precision)}, ${(1-z).toPrecision(g.precision)})`)}return b.join(", ")}function Bg(I,g){const b=I.getVerticesData(G.f.PositionKind),e=I.getVerticesData(G.f.NormalKind);if(b&&e)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(I){var g;const b=null!==(g=I.nb())&&void 0!==g&&g.length?I.getTotalIndices():I.getTotalVertices();return Array(b/3).fill(3).join(", ")}(I)}]\n\t\tint[] faceVertexIndices = [${function(I){const g=I.nb(),b=[];if(null!==g)for(let e=0;e<g.length;e++)b.push(g[e]);else{const g=I.getTotalVertices();for(let I=0;I<g;I++)b.push(I)}return b.join(", ")}(I)}]\n\t\tnormal3f[] normals = [${Ng(e,g)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Ng(b,g)}]\n        ${function(I,g){let b="";for(let c=0;c<4;c++){const e=c>0?c:"",z=I.getVerticesData(G.f.UVKind+(e?e+1:""));z&&(b+=`\n\t\ttexCoord2f[] primvars:st${e} = [${Kg(z,g)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const e=I.getVerticesData(G.f.ColorKind);return e&&(b+=`\n\tcolor3f[] primvars:displayColor = [${Ng(e,g,e.length/I.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),b}(I,g)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Pg(I,g){return`\n        def "Geometry"\n        {\n        ${Bg(I,g)}\n        }\n        `}function ug(I){let g='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return g+=I,fflate.strToU8(g)}function tg(I){const g=I.m;return`( ${yg(g,0)}, ${yg(g,4)}, ${yg(g,8)}, ${yg(g,12)} )`}function yg(I,g){return`(${I[g+0]}, ${I[g+1]}, ${I[g+2]}, ${I[g+3]})`}function qg(I){const g="Object_"+I.uniqueId,b=function(I){const g=I.getWorldMatrix().clone(),b=I.EI().useRightHandedSystem;if(!b){let e=I.parent;for(;e;){if(MI(e,b)){g.multiplyToRef(e.getWorldMatrix().invert(),g);break}e=e.parent}}return g.determinant()<0&&c.Tools.Warn(`Exporting mesh ${I.name} with negative scale. Result may look incorrect in destination engine.`),g}(I),e=tg(b);return`def Xform "${g}" (\n\tprepend references = @./geometries/Geometry_${I.ob.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${e}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${I.material.uniqueId}>\n}\n\n`}function lg(I){switch(I){case E.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case E.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case E.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function wg(I){return`(${I.x}, ${I.y})`}function Tg(I){return`(${I.r}, ${I.g}, ${I.b})`}function Wg(I,g,b,c,z,M){const J=I.getInternalTexture().uniqueId+"_"+I.invertY;z[J]=I;const o=I.coordinatesIndex>0?"st"+I.coordinatesIndex:"st",n=new e.Vector2(I.uScale,I.vScale),G=new e.Vector2(I.uOffset,I.vOffset),D=I.wAng,p=Math.sin(D),x=Math.cos(D);return G.y=1-G.y-n.y,G.x+=p*n.x,G.y+=(1-x)*n.y,`\n    def Shader "PrimvarReader_${b}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${o}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${b}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${g.uniqueId}/PrimvarReader_${b}.outputs:result>\n        float inputs:rotation = ${(D*(180/Math.PI)).toFixed(M.precision)}\n        float2 inputs:scale = ${wg(n)}\n        float2 inputs:translation = ${wg(G)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${I.uniqueId}_${b}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${J}.png@\n        float2 inputs:st.connect = </Materials/Material_${g.uniqueId}/Transform2d_${b}.outputs:result>\n        ${c?"float4 inputs:scale = "+function(I){return`(${I.r}, ${I.g}, ${I.b}, 1.0)`}(c):""}\n        token inputs:sourceColorSpace = "${I.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${lg(I.wrapU)}"\n        token inputs:wrapT = "${lg(I.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${g.needAlphaBlending()?"float outputs:a":""}\n    }`}function Ib(I,g,b){const e="\t\t\t",c=[],z=[],{diffuseMap:M,Rb:J,alphaCutOff:o,emissiveMap:n,emissive:G,normalMap:D,roughnessMap:p,roughnessChannel:x,roughness:Z,metalnessMap:k,metalnessChannel:f,metalness:V,aoMap:a,aoMapChannel:v,aoMapIntensity:X,alphaMap:R,ior:E,clearCoatEnabled:mI,clearCoat:s,clearCoatMap:F,clearCoatRoughness:Y,clearCoatRoughnessMap:d}=function(I){const g={diffuseMap:null,Rb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return I instanceof kI.Rg?{...g,diffuseMap:I.diffuseTexture,Rb:I.diffuseColor,alphaCutOff:I.alphaCutOff,emissiveMap:I.emissiveTexture,emissive:I.emissiveColor,roughness:1,alphaMap:I.opacityTexture}:I instanceof ng.c?{...g,diffuseMap:I._albedoTexture,Rb:I._albedoColor,alphaCutOff:I._alphaCutOff,emissiveMap:I._emissiveTexture,emissive:I._emissiveColor,normalMap:I._bumpTexture,roughnessMap:I._metallicTexture,roughnessChannel:I._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:I._roughness??1,metalnessMap:I._metallicTexture,metalnessChannel:I._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:I._metallic??0,aoMap:I._ambientTexture,aoMapChannel:I._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:I._ambientTextureStrength,alphaMap:I._opacityTexture,ior:I.subSurface.indexOfRefraction,clearCoatEnabled:I.clearCoat.isEnabled,clearCoat:I.clearCoat.Xb,clearCoatMap:I.clearCoat.texture,clearCoatRoughness:I.clearCoat.roughness,clearCoatRoughnessMap:I.clearCoat.useRoughnessFromMainTexture?I.clearCoat.texture:I.clearCoat.textureRoughness}:g}(I);return null!==M?(c.push(`${e}color3f inputs:diffuseColor.connect = </Materials/Material_${I.uniqueId}/Texture_${M.uniqueId}_diffuse.outputs:rgb>`),I.needAlphaBlending()?c.push(`${e}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${M.uniqueId}_diffuse.outputs:a>`):I.needAlphaTesting()&&(c.push(`${e}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${M.uniqueId}_diffuse.outputs:a>`),c.push(`${e}float inputs:opacityThreshold = ${o}`)),z.push(Wg(M,I,"diffuse",J,g,b))):c.push(`${e}color3f inputs:diffuseColor = ${Tg(J||S.Eg.White())}`),null!==n?(c.push(`${e}color3f inputs:emissiveColor.connect = </Materials/Material_${I.uniqueId}/Texture_${n.uniqueId}_emissive.outputs:rgb>`),z.push(Wg(n,I,"emissive",G,g,b))):G&&G.toLuminance()>0&&c.push(`${e}color3f inputs:emissiveColor = ${Tg(G)}`),null!==D&&(c.push(`${e}normal3f inputs:normal.connect = </Materials/Material_${I.uniqueId}/Texture_${D.uniqueId}_normal.outputs:rgb>`),z.push(Wg(D,I,"normal",null,g,b))),null!==a&&(c.push(`${e}float inputs:occlusion.connect = </Materials/Material_${I.uniqueId}/Texture_${a.uniqueId}_occlusion.outputs:${v}>`),z.push(Wg(a,I,"occlusion",new S.Eg(X,X,X),g,b))),null!==p?(c.push(`${e}float inputs:roughness.connect = </Materials/Material_${I.uniqueId}/Texture_${p.uniqueId}_roughness.outputs:${x}>`),z.push(Wg(p,I,"roughness",new S.Eg(Z,Z,Z),g,b))):c.push(`${e}float inputs:roughness = ${Z}`),null!==k?(c.push(`${e}float inputs:metallic.connect = </Materials/Material_${I.uniqueId}/Texture_${k.uniqueId}_metallic.outputs:${f}>`),z.push(Wg(k,I,"metallic",new S.Eg(V,V,V),g,b))):c.push(`${e}float inputs:metallic = ${V}`),null!==R?(c.push(`${e}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${R.uniqueId}_opacity.outputs:r>`),c.push(`${e}float inputs:opacityThreshold = 0.0001`),z.push(Wg(R,I,"opacity",null,g,b))):c.push(`${e}float inputs:opacity = ${I.alpha}`),mI&&(null!==F?(c.push(`${e}float inputs:clearcoat.connect = </Materials/Material_${I.uniqueId}/Texture_${F.uniqueId}_clearcoat.outputs:r>`),z.push(Wg(F,I,"clearcoat",new S.Eg(s,s,s),g,b))):c.push(`${e}float inputs:clearcoat = ${s}`),null!==d?(c.push(`${e}float inputs:clearcoatRoughness.connect = </Materials/Material_${I.uniqueId}/Texture_${d.uniqueId}_clearcoatRoughness.outputs:g>`),z.push(Wg(d,I,"clearcoatRoughness",new S.Eg(Y,Y,Y),g,b))):c.push(`${e}float inputs:clearcoatRoughness = ${Y}`)),c.push(`${e}float inputs:ior = ${E}`),`\n\tdef Material "Material_${I.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${c.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${I.uniqueId}/PreviewSurface.outputs:surface>\n\n${z.join("\n")}\n\n\t}\n`}async function gb(I,g,b){const z={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...g};"undefined"===typeof fflate&&await c.Tools.LoadScriptAsync(z.fflateUrl);const M={};M[z.modelFileName]=null;let J='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';J+=function(I){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===I.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${I.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${I.planeAnchoringAlignment}"`:""}\n            `}(z);const o={};for(const e of I.meshes){if(0===e.getTotalVertices())continue;const I=e,g=I.ob,n=I.material;if(!n||!g||b&&!b(I))continue;if(-1!==["Rg","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(n.getClassName())){const b="geometries/Geometry_"+g.uniqueId+".usda";if(!(b in M)){const I=Pg(g,z);M[b]=ug(I)}n.uniqueId in o||(o[n.uniqueId]=n),J+=qg(I)}else c.Tools.Warn("USDZExportAsync does not support this material type: "+n.getClassName())}I.activeCamera&&z.exportCamera&&(J+=function(I,g){const b="Camera_"+I.uniqueId,c=tg(e.Matrix.RotationY(Math.PI).multiply(I.getWorldMatrix()));if(I.mode===E.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${b}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${c}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${I.cb.toPrecision(g.precision)}, ${I.maxZ.toPrecision(g.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(I.orthoLeft||1)+Math.abs(I.orthoRight||1))).toPrecision(g.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(I.orthoTop||1)+Math.abs(I.orthoBottom||1))).toPrecision(g.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const e=I.getEngine().getAspectRatio(I),z=g.cameraSensorWidth||35;return`def Camera "${b}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${c}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${I.cb.toPrecision(g.precision)}, ${I.maxZ.toPrecision(g.precision)})\n\t\t\tfloat focalLength = ${(z/(2*Math.tan(.5*I.fov))).toPrecision(g.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(z*e).toPrecision(g.precision)}\n\t\t\tfloat verticalAperture = ${(z/e).toPrecision(g.precision)}            \n\t\t}\n\t\n\t`}}(I.activeCamera,z)),J+="\n            }\n        }\n    }";const n={};J+=function(I,g,b){const e=[];for(const c in I){const z=I[c];e.push(Ib(z,g,b))}return`\n    def "Materials"\n{\n${e.join("")}\n}\n\n`}(o,n,z),M[z.modelFileName]=fflate.strToU8(J);for(const e in n){const I=n[e],g=I.getSize(),b=await I.readPixels();if(!b)throw new Error("Texture data is not available");const c=await mI.DumpTools.DumpDataAsync(g.width,g.height,b,"image/png",void 0,!1,!0);M[`textures/Texture_${e}.png`]=new Uint8Array(c).slice()}let G=0;for(const e in M){const I=M[e];if(!I)continue;G+=34+e.length;const g=63&G;if(4!==g){const b=new Uint8Array(64-g);M[e]=[I,{extra:{12345:b}}]}G=I.length}return fflate.zipSync(M,{level:0})}}}]);