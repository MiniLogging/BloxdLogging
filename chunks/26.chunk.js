"use strict";(self.ozi0exxand9=self.ozi0exxand9||[]).push([[26],{11814:(f,v,Z)=>{Z.r(v),Z.d(v,{EXT_materials_diffuse_roughness:()=>qv,EXT_mesh_gpu_instancing:()=>df,GLTF2Export:()=>Gf,GLTFData:()=>H,KHR_draco_mesh_compression:()=>Vv,KHR_lights_punctual:()=>Hv,KHR_materials_anisotropy:()=>Wv,KHR_materials_clearcoat:()=>bv,KHR_materials_diffuse_transmission:()=>Uv,KHR_materials_dispersion:()=>Mv,KHR_materials_emissive_strength:()=>sv,KHR_materials_ior:()=>Yv,KHR_materials_iridescence:()=>Nv,KHR_materials_sheen:()=>Iv,KHR_materials_specular:()=>Bv,KHR_materials_transmission:()=>gv,KHR_materials_unlit:()=>tv,KHR_materials_volume:()=>Ev,KHR_texture_transform:()=>mv,OBJExport:()=>l,STLExport:()=>pv,USDZExportAsync:()=>ZZ,_ConvertToGLTFPBRMetallicRoughness:()=>g,_SolveMetallic:()=>P,__IGLTFExporterExtension:()=>e});var V=Z(11421),h=Z(11230),J=Z(11729);class l{static OBJ(f,v,Z,l){const e=[];let C=1,H=1;v&&(Z||(Z="mat"),e.push("mtllib "+Z+".mtl"));for(let O=0;O<f.length;O++){const Z=f[O],u=Z.name||`mesh${O}}`;e.push(`o ${u}`);let W=null;if(l){const f=Z.jh(!0);W=new V.Matrix,f.invertToRef(W),Z.bakeTransformIntoVertices(f)}if(v){const f=Z.material;f&&e.push("usemtl "+f.id)}const a=Z.qh;if(!a){h.Tools.Warn("No geometry is present on the mesh");continue}const b=a.getVerticesData("position"),X=a.getVerticesData("normal"),F=a.getVerticesData("uv"),U=a.dh();let K=0,M=0;if(!b||!U){h.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const A=f[0].Yf().useRightHandedSystem?1:-1;for(let f=0;f<b.length;f+=3)e.push("v "+b[f]*A+" "+b[f+1]+" "+b[f+2]),K++;if(null!=X)for(let f=0;f<X.length;f+=3)e.push("vn "+X[f]*A+" "+X[f+1]+" "+X[f+2]);if(null!=F)for(let f=0;f<F.length;f+=2)e.push("vt "+F[f]+" "+F[f+1]),M++;const s=["","",""],z=(Z.material||Z.Yf().defaultMaterial)._getEffectiveOrientation(Z),[Y,y]=z===J.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let f=0;f<U.length;f+=3){const v=[String(U[f]+C),String(U[f+Y]+C),String(U[f+y]+C)],Z=[String(U[f]+H),String(U[f+Y]+H),String(U[f+y]+H)],V=v,h=null!=F?Z:s,J=null!=X?v:s;e.push("f "+V[0]+"/"+h[0]+"/"+J[0]+" "+V[1]+"/"+h[1]+"/"+J[1]+" "+V[2]+"/"+h[2]+"/"+J[2])}l&&W&&Z.bakeTransformIntoVertices(W),C+=K,H+=M}return e.join("\n")}static MTL(f){const v=[],Z=f.material;v.push("newmtl mat1"),v.push("  Ns "+Z.specularPower.toFixed(4)),v.push("  Ni 1.5000"),v.push("  d "+Z.alpha.toFixed(4)),v.push("  Tr 0.0000"),v.push("  Tf 1.0000 1.0000 1.0000"),v.push("  illum 2"),v.push("  Ka "+Z.ambientColor.r.toFixed(4)+" "+Z.ambientColor.g.toFixed(4)+" "+Z.ambientColor.b.toFixed(4)),v.push("  Kd "+Z.diffuseColor.r.toFixed(4)+" "+Z.diffuseColor.g.toFixed(4)+" "+Z.diffuseColor.b.toFixed(4)),v.push("  Ks "+Z.specularColor.r.toFixed(4)+" "+Z.specularColor.g.toFixed(4)+" "+Z.specularColor.b.toFixed(4)),v.push("  Ke "+Z.emissiveColor.r.toFixed(4)+" "+Z.emissiveColor.g.toFixed(4)+" "+Z.emissiveColor.b.toFixed(4));Z.ambientTexture&&v.push("  map_Ka "+Z.ambientTexture.name),Z.diffuseTexture&&v.push("  map_Kd "+Z.diffuseTexture.name),Z.specularTexture&&v.push("  map_Ks "+Z.specularTexture.name),Z.bumpTexture&&v.push("  map_bump -imfchan z "+Z.bumpTexture.name),Z.opacityTexture&&v.push("  map_d "+Z.opacityTexture.name);return v.join("\n")}}var e=0,C=Z(11290);class H{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const f in this.files){const v=this.files[f],Z=new Blob([v],{type:(0,C.i)(f)});h.Tools.Download(Z,f)}}}var O=Z(11494),u=Z(11820),W=Z(11833),a=Z(11851),b=Z(11543),X=Z(11281),F=Z(11472),U=Z(11440);const K=U.HighestCommonFactor,M={...U,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:K};var A=Z(11628),s=Z(11401),z=Z(11885),Y=Z(11887),y=Z(11621);const N=1e-6,i=new F.Mv(.04,.04,.04),I=1024,T=F.Mv.White(),B=F.Mv.Black();function P(f,v,Z){if(v<i.r)return 0;const V=i.r,h=f*Z/(1-i.r)+v-2*i.r,J=h*h-4*V*(i.r-v);return M.Clamp((-h+Math.sqrt(J))/(2*V),0,1)}function g(f){const v=f.diffuseColor.toLinearSpace(f.Yf().getEngine().useExactSrgbConversions).scale(.5),Z=f.alpha,h=function(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new V.Vector2(0,1),Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new V.Vector2(0,.1),h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new V.Vector2(0,.1),J=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new V.Vector2(1300,.1);return function(f,v,Z,V,h){return(1-f)*(1-f)*(1-f)*v+3*(1-f)*(1-f)*f*Z+3*(1-f)*f*f*V+f*f*f*h}(Math.pow(f/J.x,.333333),v.y,Z.y,h.y,J.y)}(M.Clamp(f.specularPower,0,I));return{baseColorFactor:[v.r,v.g,v.b,Z],metallicFactor:0,roughnessFactor:h}}function w(f,v){v.needAlphaBlending()?f.alphaMode="BLEND":v.needAlphaTesting()&&(f.alphaMode="MASK",f.alphaCutoff=v.alphaCutOff)}function t(f,v,Z){const V=new Uint8Array(f*v*4);for(let h=0;h<V.length;h+=4)V[h]=V[h+1]=V[h+2]=V[h+3]=255;return z.c.CreateRGBATexture(V,f,v,Z)}function L(f){if(f instanceof Uint8Array){const v=f.length,Z=new Float32Array(f.length);for(let V=0;V<v;++V)Z[V]=f[V]/255;return Z}if(f instanceof Float32Array)return f;throw new Error("Unsupported pixel format!")}class E{constructor(f){this._exporter=f,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(f){return f?this._textureMap.get(f)??null:null}async exportStandardMaterialAsync(f,v,Z){const V=g(f),J={name:f.name};if(null==f.nh||f.nh||(f.twoSidedLighting||h.Tools.Warn(f.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),J.doubleSided=!0),Z){const Z=[],h=f.diffuseTexture;h&&Z.push(this.exportTextureAsync(h,v).then((f=>{f&&(V.baseColorTexture=f)})));const l=f.bumpTexture;l&&Z.push(this.exportTextureAsync(l,v).then((f=>{f&&(J.normalTexture=f,1!==l.level&&(J.normalTexture.scale=l.level))})));const e=f.emissiveTexture;e&&(J.emissiveFactor=[1,1,1],Z.push(this.exportTextureAsync(e,v).then((f=>{f&&(J.emissiveTexture=f)}))));const C=f.ambientTexture;C&&Z.push(this.exportTextureAsync(C,v).then((f=>{if(f){const v={index:f.index};J.occlusionTexture=v}}))),Z.length>0&&(this._exporter._materialNeedsUVsSet.add(f),await Promise.all(Z))}(f.alpha<1||f.opacityTexture)&&(f.alphaMode===Y.d.ALPHA_COMBINE?J.alphaMode="BLEND":h.Tools.Warn(f.name+": glTF 2.0 does not support alpha mode: "+f.alphaMode.toString())),f.emissiveColor&&!f.emissiveColor.equalsWithEpsilon(B,N)&&(J.emissiveFactor=f.emissiveColor.Ph()),J.pbrMetallicRoughness=V,w(J,f),await this._finishMaterialAsync(J,f,v);const l=this._exporter._materials;return l.push(J),l.length-1}async _finishMaterialAsync(f,v,Z){const V=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",f,v),h=[];for(const J of V)h.push(this.exportTextureAsync(J,Z));await Promise.all(h),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",f,v)}async _getImageDataAsync(f,v,V,h){const J=Y.d.TEXTURETYPE_UNSIGNED_BYTE,l=this._exporter._babylonScene,e=l.getEngine(),C=e.createRawTexture(f,v,V,Y.d.TEXTUREFORMAT_RGBA,!1,!0,s.e.NEAREST_SAMPLINGMODE,null,J);e.isWebGPU?await Z.e(51).then(Z.bind(Z,13861)):await Z.e(52).then(Z.bind(Z,13866)),await A.o.ApplyPostProcess("pass",C,l,J,Y.d.TEXTURE_NEAREST_SAMPLINGMODE,Y.d.TEXTUREFORMAT_RGBA);const H=await e._readTexturePixels(C,v,V);return await y.DumpTools.DumpDataAsync(v,V,H,h,void 0,!0,!0)}_resizeTexturesToSameDimensions(f,v,Z){const V=f?f.getSize():{width:0,height:0},h=v?v.getSize():{width:0,height:0};let J,l;return V.width<h.width?(J=f&&f instanceof s.e?A.o.CreateResizedCopy(f,h.width,h.height,!0):t(h.width,h.height,Z),l=v):V.width>h.width?(l=v&&v instanceof s.e?A.o.CreateResizedCopy(v,V.width,V.height,!0):t(V.width,V.height,Z),J=f):(J=f,l=v),{texture1:J,texture2:l}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(f,v,Z,V){const h=new Array;if(!f&&!v)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const J=f?f.Yf():v?v.Yf():null;if(J){var l;const e=this._resizeTexturesToSameDimensions(f,v,J),C=null===(l=e.texture1)||void 0===l?void 0:l.getSize();let H,O;const u=C.width,W=C.height,a=await e.texture1.readPixels(),b=await e.texture2.readPixels();if(!a)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(H=L(a),!b)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");O=L(b);const X=O.byteLength,U=new Uint8Array(X),K=new Uint8Array(X),M=4,A=B;let s=0,z=0;for(let f=0;f<W;++f)for(let v=0;v<u;++v){const V=(u*f+v)*M,h={diffuseColor:new F.Mv(H[V],H[V+1],H[V+2]).toLinearSpace(J.getEngine().useExactSrgbConversions).multiply(Z.diffuseColor),specularColor:new F.Mv(O[V],O[V+1],O[V+2]).toLinearSpace(J.getEngine().useExactSrgbConversions).multiply(Z.specularColor),glossiness:O[V+3]*Z.glossiness},l=this._convertSpecularGlossinessToMetallicRoughness(h);A.r=Math.max(A.r,l.baseColor.r),A.g=Math.max(A.g,l.baseColor.g),A.b=Math.max(A.b,l.baseColor.b),s=Math.max(s,l.metallic),z=Math.max(z,l.roughness),K[V]=255*l.baseColor.r,K[V+1]=255*l.baseColor.g,K[V+2]=255*l.baseColor.b,K[V+3]=e.texture1.th?255*H[V+3]:255,U[V]=0,U[V+1]=255*l.roughness,U[V+2]=255*l.metallic,U[V+3]=255}const Y={baseColor:A,metallic:s,roughness:z};let y=!1,i=!1;for(let f=0;f<W;++f)for(let v=0;v<u;++v){const Z=(u*f+v)*M;K[Z]/=Y.baseColor.r>N?Y.baseColor.r:1,K[Z+1]/=Y.baseColor.g>N?Y.baseColor.g:1,K[Z+2]/=Y.baseColor.b>N?Y.baseColor.b:1;const V=F.Mv.FromInts(K[Z],K[Z+1],K[Z+2]).toGammaSpace(J.getEngine().useExactSrgbConversions);K[Z]=255*V.r,K[Z+1]=255*V.g,K[Z+2]=255*V.b,V.equalsWithEpsilon(T,N)||(i=!0),U[Z+1]/=Y.roughness>N?Y.roughness:1,U[Z+2]/=Y.metallic>N?Y.metallic:1;F.Mv.FromInts(255,U[Z+1],U[Z+2]).equalsWithEpsilon(T,N)||(y=!0)}return y&&h.push(this._getImageDataAsync(U,u,W,V).then((f=>{Y.metallicRoughnessTextureData=f}))),i&&h.push(this._getImageDataAsync(K,u,W,V).then((f=>{Y.baseColorTextureData=f}))),await Promise.all(h).then((()=>Y))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(f){const v=this._getPerceivedBrightness(f.diffuseColor),Z=this._getPerceivedBrightness(f.specularColor),V=1-this._getMaxComponent(f.specularColor),h=P(v,Z,V),J=f.diffuseColor.scale(V/(1-i.r)/Math.max(1-h)),l=f.specularColor.Fv(i.scale(1-h)).scale(1/Math.max(h));let e=F.Mv.Lerp(J,l,h*h);e=e.clampToRef(0,1,e);return{baseColor:e,metallic:h,roughness:1-f.glossiness}}_getPerceivedBrightness(f){return f?Math.sqrt(.299*f.r*f.r+.587*f.g*f.g+.114*f.b*f.b):0}_getMaxComponent(f){return f?Math.max(f.r,Math.max(f.g,f.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(f,v,Z,V){const h=[],J={baseColor:f._albedoColor,metallic:f._metallic,roughness:f._roughness};if(V){f._albedoTexture&&h.push(this.exportTextureAsync(f._albedoTexture,v).then((f=>{f&&(Z.baseColorTexture=f)})));const V=f._metallicTexture;V&&h.push(this.exportTextureAsync(V,v).then((f=>{f&&(Z.metallicRoughnessTexture=f)})))}return h.length>0&&(this._exporter._materialNeedsUVsSet.add(f),await Promise.all(h)),J}_getTextureSampler(f){const v={};if(!f||!(f instanceof s.e))return v;const Z=this._getGLTFTextureWrapMode(f.wrapU);10497!==Z&&(v.wrapS=Z);const V=this._getGLTFTextureWrapMode(f.wrapV);switch(10497!==V&&(v.wrapT=V),f.samplingMode){case s.e.LINEAR_LINEAR:v.magFilter=9729,v.minFilter=9729;break;case s.e.LINEAR_NEAREST:v.magFilter=9729,v.minFilter=9728;break;case s.e.NEAREST_LINEAR:v.magFilter=9728,v.minFilter=9729;break;case s.e.NEAREST_LINEAR_MIPLINEAR:v.magFilter=9728,v.minFilter=9987;break;case s.e.NEAREST_NEAREST:v.magFilter=9728,v.minFilter=9728;break;case s.e.NEAREST_LINEAR_MIPNEAREST:v.magFilter=9728,v.minFilter=9985;break;case s.e.LINEAR_NEAREST_MIPNEAREST:v.magFilter=9729,v.minFilter=9984;break;case s.e.LINEAR_NEAREST_MIPLINEAR:v.magFilter=9729,v.minFilter=9986;break;case s.e.NEAREST_NEAREST_MIPLINEAR:v.magFilter=9728,v.minFilter=9986;break;case s.e.LINEAR_LINEAR_MIPLINEAR:v.magFilter=9729,v.minFilter=9987;break;case s.e.LINEAR_LINEAR_MIPNEAREST:v.magFilter=9729,v.minFilter=9985;break;case s.e.NEAREST_NEAREST_MIPNEAREST:v.magFilter=9728,v.minFilter=9984}return v}_getGLTFTextureWrapMode(f){switch(f){case s.e.WRAP_ADDRESSMODE:return 10497;case s.e.CLAMP_ADDRESSMODE:return 33071;case s.e.MIRROR_ADDRESSMODE:return 33648;default:return h.Tools.Error(`Unsupported Texture Wrap Mode ${f}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(f,v,Z,V){const h={diffuseColor:f._albedoColor,specularColor:f._reflectivityColor,glossiness:f._microSurface},J=f._albedoTexture,l=f._reflectivityTexture,e=f._useMicroSurfaceFromReflectivityMapAlpha;if(l&&!e)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((J||l)&&V){this._exporter._materialNeedsUVsSet.add(f);const V=this._exportTextureSampler(J||l),e=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(J,l,h,v),C=this._exporter._textures;if(e.baseColorTextureData){const f=this._exportImage(`baseColor${C.length}`,v,e.baseColorTextureData);Z.baseColorTexture=this._exportTextureInfo(f,V,null===J||void 0===J?void 0:J.coordinatesIndex)}if(e.metallicRoughnessTextureData){const f=this._exportImage(`metallicRoughness${C.length}`,v,e.metallicRoughnessTextureData);Z.metallicRoughnessTexture=this._exportTextureInfo(f,V,null===l||void 0===l?void 0:l.coordinatesIndex)}return e}return this._convertSpecularGlossinessToMetallicRoughness(h)}async exportPBRMaterialAsync(f,v,Z){const V={},h={name:f.name},J=f.isMetallicWorkflow();if(J){const v=f._albedoColor,Z=f.alpha;v&&(V.baseColorFactor=[v.r,v.g,v.b,Z])}const l=J?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(f,v,V,Z):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(f,v,V,Z);await this._setMetallicRoughnessPbrMaterialAsync(l,f,h,V,v,Z),await this._finishMaterialAsync(h,f,v);const e=this._exporter._materials;return e.push(h),e.length-1}async _setMetallicRoughnessPbrMaterialAsync(f,v,Z,V,J,l){if(w(Z,v),f.baseColor.equalsWithEpsilon(T,N)&&M.WithinEpsilon(v.alpha,1,N)||(V.baseColorFactor=[f.baseColor.r,f.baseColor.g,f.baseColor.b,v.alpha]),null!=f.metallic&&1!==f.metallic&&(V.metallicFactor=f.metallic),null!=f.roughness&&1!==f.roughness&&(V.roughnessFactor=f.roughness),null==v.nh||v.nh||(v._twoSidedLighting||h.Tools.Warn(v.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Z.doubleSided=!0),l){const f=[],V=v._bumpTexture;V&&f.push(this.exportTextureAsync(V,J).then((f=>{f&&(Z.normalTexture=f,1!==V.level&&(Z.normalTexture.scale=V.level))})));const h=v._ambientTexture;h&&f.push(this.exportTextureAsync(h,J).then((f=>{if(f){const V={index:f.index,texCoord:f.texCoord,extensions:f.extensions};Z.occlusionTexture=V;const h=v._ambientTextureStrength;h&&(V.strength=h)}})));const l=v._emissiveTexture;l&&f.push(this.exportTextureAsync(l,J).then((f=>{f&&(Z.emissiveTexture=f)}))),f.length>0&&(this._exporter._materialNeedsUVsSet.add(v),await Promise.all(f))}const e=v._emissiveColor;e.equalsWithEpsilon(B,N)||(Z.emissiveFactor=e.Ph()),Z.pbrMetallicRoughness=V}_getPixelsFromTextureAsync(f){return function(f){switch(f){case Y.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case Y.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case Y.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case Y.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case Y.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case Y.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case Y.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case Y.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case Y.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case Y.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case Y.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case Y.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case Y.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case Y.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case Y.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case Y.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case Y.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case Y.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Y.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Y.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case Y.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(f.textureFormat)?(0,A.k)(f,f._texture.width,f._texture.height):(f.textureType,Y.d.TEXTURETYPE_UNSIGNED_BYTE,f.readPixels())}async exportTextureAsync(f,v){const Z=this._exporter._extensionsPreExportTextureAsync("exporter",f,v);return Z?await Z.then((async Z=>Z?await this._exportTextureInfoAsync(Z,v):await this._exportTextureInfoAsync(f,v))):await this._exportTextureInfoAsync(f,v)}async _exportTextureInfoAsync(f,v){let Z=this._textureMap.get(f);if(!Z){const V=await this._getPixelsFromTextureAsync(f);if(!V)return null;const J=this._exportTextureSampler(f),l=f.mimeType;if(l)switch(l){case"image/jpeg":case"image/png":case"image/webp":v=l;break;default:h.Tools.Warn(`Unsupported media type: ${l}. Exporting texture as PNG.`)}const e=this._internalTextureToImage,C=f.getInternalTexture().uniqueId;e[C]||(e[C]={});let H=e[C][v];if(void 0===H){const Z=f.getSize();H=(async()=>{const h=await this._getImageDataAsync(V,Z.width,Z.height,v);return this._exportImage(f.name,v,h)})(),e[C][v]=H}Z=this._exportTextureInfo(await H,J,f.coordinatesIndex),this._textureMap.set(f,Z),this._exporter._extensionsPostExportTextures("exporter",Z,f)}return Z}_exportImage(f,v,Z){const V=this._exporter._images;let J;if(this._exporter._shouldUseGlb){J={name:f,mimeType:v,bufferView:void 0};const V=this._exporter._bufferManager.createBufferView(new Uint8Array(Z));this._exporter._bufferManager.setBufferView(J,V)}else{const l=f.replace(/\.\/|\/|\.\\|\\/g,"_"),e=function(f){switch(f){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(v);let C=l+e;V.some((f=>f.uri===C))&&(C=`${l}_${h.Tools.RandomId()}${e}`),J={name:f,uri:C},this._exporter._imageData[C]={data:Z,mimeType:v}}return V.push(J),V.length-1}_exportTextureInfo(f,v,Z){const V=this._exporter._textures;let h=V.findIndex((Z=>Z.sampler==v&&Z.source===f));-1===h&&(h=V.length,V.push({source:f,sampler:v}));const J={index:h};return Z&&(J.texCoord=Z),J}_exportTextureSampler(f){const v=this._getTextureSampler(f),Z=this._exporter._samplers,V=Z.findIndex((f=>f.minFilter===v.minFilter&&f.magFilter===v.magFilter&&f.wrapS===v.wrapS&&f.wrapT===v.wrapT));return-1!==V?V:(Z.push(v),Z.length-1)}}var j=Z(11503),q=Z(11247),c=Z(11889),m=Z(11428);const p=V.Xv.Zero(),k=V.Quaternion.Identity(),r=V.Xv.One(),o=new V.Xv(-1,1,1);function G(f,v){const{byteOffset:Z,byteStride:V,type:h,normalized:J}=f,l=f.getSize(),e=v.reduce(((f,v)=>v.getTotalVertices()>f?v.getTotalVertices():f),-Number.MAX_VALUE);return{byteOffset:Z,byteStride:V,componentCount:l,type:h,count:e*l,normalized:J,totalVertices:e,kind:f.getKind()}}function Q(f){switch(f){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function d(f){switch(f){case O.g.PositionKind:case O.g.NormalKind:case O.g.TangentKind:case O.g.ColorKind:case O.g.MatricesIndicesKind:case O.g.MatricesIndicesExtraKind:case O.g.MatricesWeightsKind:case O.g.MatricesWeightsExtraKind:case O.g.UVKind:case O.g.UV2Kind:case O.g.UV3Kind:case O.g.UV4Kind:case O.g.UV5Kind:case O.g.UV6Kind:return!0}return!1}function x(f){switch(f){case J.e.TriangleFillMode:return 4;case J.e.TriangleStripDrawMode:return 5;case J.e.TriangleFanDrawMode:return 6;case J.e.PointListDrawMode:case J.e.PointFillMode:return 0;case J.e.LineLoopDrawMode:return 2;case J.e.LineListDrawMode:return 1;case J.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${f}`)}function R(f){const v=Math.sqrt(f.x*f.x+f.y*f.y+f.z*f.z);v>0&&(f.x/=v,f.y/=v,f.z/=v)}function n(f){return f.x*=-1,f}function S(f){if(f.x*f.x+f.y*f.y>.5){const v=Math.abs(f.x),Z=Math.abs(f.y);if(v>Z){const Z=Math.sign(f.x);f.x=v,f.y*=-Z,f.z*=-Z,f.w*=Z}else{const v=Math.sign(f.y);f.x*=-v,f.y=Z,f.z*=v,f.w*=-v}}else{const v=Math.abs(f.z),Z=Math.abs(f.w);if(v>Z){const Z=Math.sign(f.z);f.x*=-Z,f.y*=Z,f.z=v,f.w*=-Z}else{const v=Math.sign(f.w);f.x*=v,f.y*=-v,f.z*=-v,f.w=Z}}return f}function D(f){f.fe(-f.z,f.w,f.x,-f.y)}function ff(f,v){const Z=V.Xv.FromArrayToRef(v.translation||[0,0,0],0,V.TmpVectors.Xv[0]),h=V.Quaternion.FromArrayToRef(v.rotation||[0,0,0,1],0,V.TmpVectors.Quaternion[0]),J=V.Matrix.ComposeToRef(r,h,Z,V.TmpVectors.Matrix[0]),l=V.Xv.FromArrayToRef(f.translation||[0,0,0],0,V.TmpVectors.Xv[2]),e=V.Quaternion.FromArrayToRef(f.rotation||[0,0,0,1],0,V.TmpVectors.Quaternion[1]),C=V.Matrix.ComposeToRef(r,e,l,V.TmpVectors.Matrix[1]);J.multiplyToRef(C,C),C.decompose(void 0,h,Z),Z.equalsWithEpsilon(p,m.c)?delete v.translation:v.translation=Z.Ph(),h.equalsWithEpsilon(k,m.c)?delete v.rotation:v.rotation=h.Ph(),v.scale&&delete v.scale}function vf(f,v){if(!(v instanceof u.e))return!1;if(!(1===v.getChildren().length&&0===f.getChildren().length&&f.parent===v))return!1;const Z=f.Yf(),V=f instanceof c.e&&!Z.useRightHandedSystem?o:r;return!!v.Ze.equalsWithEpsilon(V,m.c)||(q.e.Warn(`Cannot collapse node ${f.name} into parent node ${v.name} with modified scaling.`),!1)}function Zf(f){if(f instanceof Array){const v=new Float32Array(f);return new Uint8Array(v.buffer,v.byteOffset,v.byteLength)}return ArrayBuffer.isView(f)?new Uint8Array(f.buffer,f.byteOffset,f.byteLength):new Uint8Array(f)}function Vf(f,v){for(const[Z,V]of Object.entries(f)){const h=v[Z];(Array.isArray(V)&&Array.isArray(h)&&hf(V,h)||V===h)&&delete f[Z]}return f}function hf(f,v){return f.length===v.length&&f.every(((f,Z)=>f===v[Z]))}const Jf=V.Matrix.Compose(new V.Xv(-1,1,1),V.Quaternion.Identity(),V.Xv.Zero());function lf(f,v){if(!(f instanceof u.e))return!1;if(v){if(!f.getWorldMatrix().equalsWithEpsilon(V.Matrix.IdentityReadOnly,m.c))return!1}else{if(!f.getWorldMatrix().multiplyToRef(Jf,V.TmpVectors.Matrix[0]).equalsWithEpsilon(V.Matrix.IdentityReadOnly,m.c))return!1}return!(f instanceof W.e&&f.qh)}const ef=new Map([[Int8Array,(f,v,Z)=>f.setInt8(v,Z)],[Uint8Array,(f,v,Z)=>f.setUint8(v,Z)],[Uint8ClampedArray,(f,v,Z)=>f.setUint8(v,Z)],[Int16Array,(f,v,Z)=>f.setInt16(v,Z,!0)],[Uint16Array,(f,v,Z)=>f.setUint16(v,Z,!0)],[Int32Array,(f,v,Z)=>f.setInt32(v,Z,!0)],[Uint32Array,(f,v,Z)=>f.setUint32(v,Z,!0)],[Float32Array,(f,v,Z)=>f.setFloat32(v,Z,!0)],[Float64Array,(f,v,Z)=>f.setFloat64(v,Z,!0)]]);class Cf{writeTypedArray(f){this._checkGrowBuffer(f.byteLength);const v=ef.get(f.constructor);for(let Z=0;Z<f.length;Z++)v(this._dataView,this._byteOffset,f[Z]),this._byteOffset+=f.BYTES_PER_ELEMENT}constructor(f){this._data=new Uint8Array(f),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(f){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,f),this._byteOffset++}writeInt8(f){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,f),this._byteOffset++}writeInt16(f){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,f,!0),this._byteOffset+=2}writeUInt16(f){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,f,!0),this._byteOffset+=2}writeInt32(f){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,f,!0),this._byteOffset+=4}writeUInt32(f){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,f,!0),this._byteOffset+=4}writeFloat32(f){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,f,!0),this._byteOffset+=4}writeFloat64(f){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,f,!0),this._byteOffset+=8}_checkGrowBuffer(f){const v=this.byteOffset+f;if(v>this._data.byteLength){const f=new Uint8Array(2*v);f.set(this._data),this._data=f,this._dataView=new DataView(this._data.buffer)}}}function Hf(f){return f%4===0?4:f%2===0?2:1}class Of{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(f){let v=0;this._bufferViewToData.forEach((f=>{v+=f.byteLength}));const Z=new Cf(v),V=Array.from(this._bufferViewToData.keys()).sort(((f,v)=>Hf(v.byteLength)-Hf(f.byteLength)));for(const h of V){h.byteOffset=Z.byteOffset,f.push(h);const v=f.length-1,V=this.getPropertiesWithBufferView(h);for(const f of V)f.bufferView=v;Z.writeTypedArray(this._bufferViewToData.get(h)),this._bufferViewToData.delete(h)}return Z.getOutputData()}createBufferView(f,v){const Z={buffer:0,byteOffset:void 0,byteLength:f.byteLength,byteStride:v};return this._bufferViewToData.set(Z,f),Z}createAccessor(f,v,Z,V,h,J,l){this._verifyBufferView(f);const e={bufferView:void 0,componentType:Z,count:V,type:v,min:null===J||void 0===J?void 0:J.min,max:null===J||void 0===J?void 0:J.max,normalized:l,byteOffset:h};return this.setBufferView(e,f),this._accessorToBufferView.set(e,f),e}setBufferView(f,v){this._verifyBufferView(v);this.getPropertiesWithBufferView(v).push(f)}removeBufferView(f){const v=this.getPropertiesWithBufferView(f);for(const Z of v)void 0!==Z.bufferView&&delete Z.bufferView;this._bufferViewToData.delete(f),this._bufferViewToProperties.delete(f),this._accessorToBufferView.forEach(((v,Z)=>{v===f&&(void 0!==Z.byteOffset&&delete Z.byteOffset,this._accessorToBufferView.delete(Z))}))}getBufferView(f){const v=this._accessorToBufferView.get(f);return this._verifyBufferView(v),v}getPropertiesWithBufferView(f){return this._verifyBufferView(f),this._bufferViewToProperties.set(f,this._bufferViewToProperties.get(f)??[]),this._bufferViewToProperties.get(f)}getData(f){return this._verifyBufferView(f),this._bufferViewToData.get(f)}_verifyBufferView(f){if(void 0===f||!this._bufferViewToData.has(f))throw new Error(`BufferView ${f} not found in BufferManager.`)}}var uf,Wf=Z(11863),af=Z(11876),bf=Z(11891),Xf=Z(11777),Ff=Z(11921),Uf=Z(11934),Kf=Z(11859),Mf=Z(11942);!function(f){f[f.INTANGENT=0]="INTANGENT",f[f.OUTTANGENT=1]="OUTTANGENT"}(uf||(uf={}));class Af{static _IsTransformable(f){return f&&(f instanceof u.e||f instanceof Wf.d||f instanceof Mf.c)}static _CreateNodeAnimation(f,v,Z,V,J){if(this._IsTransformable(f)){const l=[],e=[],C=v.getKeys(),H=Af._CalculateMinMaxKeyFrames(C),O=Af._DeduceInterpolation(C,Z,V),u=O.interpolationType,W=O.shouldBakeAnimation;if(W?Af._CreateBakedAnimation(f,v,Z,H.min,H.max,v.framePerSecond,J,l,e,H,V):"LINEAR"===u||"STEP"===u?Af._CreateLinearOrStepAnimation(f,v,Z,l,e,V):"CUBICSPLINE"===u?Af._CreateCubicSplineAnimation(f,v,Z,l,e,V):Af._CreateBakedAnimation(f,v,Z,H.min,H.max,v.framePerSecond,J,l,e,H,V),l.length&&e.length){return{inputs:l,outputs:e,samplerInterpolation:u,inputsMin:W?H.min:h.Tools.FloatRound(H.min/v.framePerSecond),inputsMax:W?H.max:h.Tools.FloatRound(H.max/v.framePerSecond)}}}return null}static _DeduceAnimationInfo(f){let v=null,Z="VEC3",V=!1;const J=f.targetProperty.split(".");switch(J[0]){case"Ze":v="scale";break;case"position":v="translation";break;case"rotation":Z="VEC4",v="rotation";break;case"rotationQuaternion":Z="VEC4",V=!0,v="rotation";break;case"influence":Z="SCALAR",v="weights";break;default:h.Tools.Error(`Unsupported animatable property ${J[0]}`)}return v?{animationChannelTargetPath:v,dataAccessorType:Z,useQuaternion:V}:(h.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(f,v,Z,V,h,J,l,e,C,H,O){let u;if(Af._IsTransformable(f)&&f.animations)for(const W of f.animations){if(O&&!O(W))continue;const h=Af._DeduceAnimationInfo(W);h&&(u={name:W.name,samplers:[],channels:[]},Af._AddAnimation(`${W.name}`,W.hasRunningRuntimeAnimations?v:u,f,W,h.dataAccessorType,h.animationChannelTargetPath,V,J,l,e,h.useQuaternion,C,H),u.samplers.length&&u.channels.length&&Z.push(u))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(f,v,Z,V,h,J,l,e,C,H,O){let u;if(f instanceof Kf.d){const h=f.morphTargetManager;if(h)for(let W=0;W<h.numTargets;++W){const a=h.getTarget(W);for(const b of a.animations){if(O&&!O(b))continue;const a=new Ff.b(`${b.name}`,"influence",b.framePerSecond,b.dataType,b.loopMode,b.enableBlending),X=[],F=b.getKeys();for(let f=0;f<F.length;++f){const v=F[f];for(let f=0;f<h.numTargets;++f)f==W?X.push(v):X.push({frame:v.frame,value:0})}a.setKeys(X);const U=Af._DeduceAnimationInfo(a);U&&(u={name:a.name,samplers:[],channels:[]},Af._AddAnimation(b.name,b.hasRunningRuntimeAnimations?v:u,f,a,U.dataAccessorType,U.animationChannelTargetPath,V,J,l,e,U.useQuaternion,C,H,h.numTargets),u.samplers.length&&u.channels.length&&Z.push(u))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(f,v,Z,V,h,J,l,e,C){let H;if(f.animationGroups){const u=f.animationGroups;for(const W of u){const u=new Map,a=new Map,b=new Set,X=W.to-W.from;H={name:W.name,channels:[],samplers:[]};for(let v=0;v<W.targetedAnimations.length;++v){const X=W.targetedAnimations[v],F=X.target,U=X.animation;if(C&&!C(U))continue;const K=e.has(F);if(this._IsTransformable(F)||1===F.length&&this._IsTransformable(F[0])){const f=Af._DeduceAnimationInfo(X.animation);if(f){const v=this._IsTransformable(F)?F:this._IsTransformable(F[0])?F[0]:null;v&&Af._AddAnimation(`${U.name}`,H,v,U,f.dataAccessorType,f.animationChannelTargetPath,Z,V,h,J,f.useQuaternion,l,K)}}else if(F instanceof Uf.e||1===F.length&&F[0]instanceof Uf.e){if(Af._DeduceAnimationInfo(X.animation)){const v=F instanceof Uf.e?F:F[0];if(v){const Z=f.morphTargetManagers.find((f=>{for(let Z=0;Z<f.numTargets;++Z)if(f.getTarget(Z)===v)return!0;return!1}));if(Z){const V=f.meshes.find((f=>f.morphTargetManager===Z));var O;if(V)u.has(V)||u.set(V,new Map),null===(O=u.get(V))||void 0===O||O.set(v,U),b.add(V),a.set(V,U)}}}}}b.forEach((f=>{const v=f.morphTargetManager;let e=null;const C=[],O=a.get(f).getKeys(),b=O.length;for(let Z=0;Z<b;++Z)for(let V=0;V<v.numTargets;++V){const h=v.getTarget(V),J=u.get(f);if(J){const v=J.get(h);v?(e||(e=new Ff.b(`${W.name}_${f.name}_MorphWeightAnimation`,"influence",v.framePerSecond,Ff.b.ANIMATIONTYPE_FLOAT,v.loopMode,v.enableBlending)),C.push(v.getKeys()[Z])):C.push({frame:W.from+X/b*Z,value:h.influence,inTangent:O[0].inTangent?0:void 0,outTangent:O[0].outTangent?0:void 0})}}e.setKeys(C);const F=Af._DeduceAnimationInfo(e);F&&Af._AddAnimation(`${W.name}_${f.name}_MorphWeightAnimation`,H,f,e,F.dataAccessorType,F.animationChannelTargetPath,Z,V,h,J,F.useQuaternion,l,!1,null===v||void 0===v?void 0:v.numTargets)})),H.channels.length&&H.samplers.length&&v.push(H)}}}static _AddAnimation(f,v,Z,h,J,l,e,C,H,O,u,W,a,b){const X=Af._CreateNodeAnimation(Z,h,l,u,W);let F,U,K,M,A,s;if(X){if(b){let f=0,v=0;const Z=[];for(;X.inputs.length>0;)v=X.inputs.shift(),f%b==0&&Z.push(v),f++;X.inputs=Z}const f=e.get(Z),h=new Float32Array(X.inputs);F=C.createBufferView(h),U=C.createAccessor(F,"SCALAR",5126,X.inputs.length,void 0,{min:[X.inputsMin],max:[X.inputsMax]}),O.push(U),K=O.length-1;const H=new V.Quaternion,u=new V.Xv,W=new V.Xv,z=Z instanceof Wf.d,Y=Q(J),y=new Float32Array(X.outputs.length*Y);X.outputs.forEach((function(f,v){let Z=f;switch(l){case"translation":a&&(V.Xv.FromArrayToRef(f,0,W),n(W),W.toArray(Z));break;case"rotation":4===f.length?V.Quaternion.FromArrayToRef(f,0,H):(Z=new Array(4),V.Xv.FromArrayToRef(f,0,u),V.Quaternion.FromEulerVectorToRef(u,H)),a&&(S(H),z&&D(H)),H.toArray(Z)}y.set(Z,v*Y)})),F=C.createBufferView(y),U=C.createAccessor(F,J,5126,X.outputs.length),O.push(U),M=O.length-1,A={interpolation:X.samplerInterpolation,input:K,output:M},v.samplers.push(A),s={sampler:v.samplers.length-1,target:{node:f,path:l}},v.channels.push(s)}}static _CreateBakedAnimation(f,v,Z,J,l,e,C,H,O,u,W){let a;const b=V.Quaternion.Identity();let X,F=null,U=null,K=null,M=null,A=null,s=null;u.min=h.Tools.FloatRound(J/e);const z=v.getKeys();for(let V=0,Y=z.length;V<Y;++V){if(s=null,K=z[V],V+1<Y)if(M=z[V+1],K.value.equals&&K.value.equals(M.value)||K.value===M.value){if(0!==V)continue;s=K.frame}else s=M.frame;else{if(A=z[V-1],K.value.equals&&K.value.equals(A.value)||K.value===A.value)continue;s=l}if(s)for(let V=K.frame;V<=s;V+=C){if(X=h.Tools.FloatRound(V/e),X===F)continue;F=X,U=X;const J={key:0,repeatCount:0,loopMode:v.loopMode};a=v._interpolate(V,J),Af._SetInterpolatedValue(f,a,X,v,Z,b,H,O,W)}}U&&(u.max=U)}static _ConvertFactorToVector3OrQuaternion(f,v,Z,J,l){const e=Af._GetBasePositionRotationOrScale(v,J,l),C=Z.targetProperty.split("."),H=C?C[1]:"",O=l?V.Quaternion.Av(e).normalize():V.Xv.Av(e);switch(H){case"x":case"y":case"z":O[H]=f;break;case"w":O.w=f;break;default:h.Tools.Error(`glTFAnimation: Unsupported component name "${H}"!`)}return O}static _SetInterpolatedValue(f,v,Z,h,J,l,e,C,H){let O;e.push(Z),"weights"!==J?(h.dataType===Ff.b.ANIMATIONTYPE_FLOAT&&(v=this._ConvertFactorToVector3OrQuaternion(v,f,h,J,H)),"rotation"===J?(H?l=v:(O=v,V.Quaternion.RotationYawPitchRollToRef(O.y,O.x,O.z,l)),C.push(l.Ph())):(O=v,C.push(O.Ph()))):C.push([v])}static _CreateLinearOrStepAnimation(f,v,Z,V,h,J){for(const l of v.getKeys())V.push(l.frame/v.framePerSecond),Af._AddKeyframeValue(l,v,h,Z,f,J)}static _CreateCubicSplineAnimation(f,v,Z,V,h,J){v.getKeys().forEach((function(l){V.push(l.frame/v.framePerSecond),Af._AddSplineTangent(uf.INTANGENT,h,Z,"CUBICSPLINE",l,J),Af._AddKeyframeValue(l,v,h,Z,f,J),Af._AddSplineTangent(uf.OUTTANGENT,h,Z,"CUBICSPLINE",l,J)}))}static _GetBasePositionRotationOrScale(f,v,Z){let h;if("rotation"===v)if(Z){h=(f.rotationQuaternion??V.Quaternion.Identity()).Ph()}else{h=(f.rotation??V.Xv.Zero()).Ph()}else if("translation"===v){h=(f.position??V.Xv.Zero()).Ph()}else{h=(f.Ze??V.Xv.One()).Ph()}return h}static _AddKeyframeValue(f,v,Z,J,l,e){let C;const H=v.dataType;if(H===Ff.b.ANIMATIONTYPE_VECTOR3){let v=f.value.Ph();if("rotation"===J){const f=V.Xv.Av(v);v=V.Quaternion.RotationYawPitchRoll(f.y,f.x,f.z).Ph()}Z.push(v)}else if(H===Ff.b.ANIMATIONTYPE_FLOAT){if("weights"===J)Z.push([f.value]);else if(C=this._ConvertFactorToVector3OrQuaternion(f.value,l,v,J,e),C){if("rotation"===J){const f=e?C:V.Quaternion.RotationYawPitchRoll(C.y,C.x,C.z).normalize();Z.push(f.Ph())}Z.push(C.Ph())}}else H===Ff.b.ANIMATIONTYPE_QUATERNION?Z.push(f.value.normalize().Ph()):h.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(f,v,Z){let V,h,J=!1;if("rotation"===v&&!Z)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let l=0,e=f.length;l<e;++l)if(h=f[l],h.inTangent||h.outTangent)if(V){if("CUBICSPLINE"!==V){V="LINEAR",J=!0;break}}else V="CUBICSPLINE";else if(V){if("CUBICSPLINE"===V||h.interpolation&&1===h.interpolation&&"STEP"!==V){V="LINEAR",J=!0;break}}else V=h.interpolation&&1===h.interpolation?"STEP":"LINEAR";return V||(V="LINEAR"),{interpolationType:V,shouldBakeAnimation:J}}static _AddSplineTangent(f,v,Z,h,J,l){let e;const C=f===uf.INTANGENT?J.inTangent:J.outTangent;if("CUBICSPLINE"===h){if("rotation"===Z)if(C)if(l)e=C.Ph();else{const f=C;e=V.Quaternion.RotationYawPitchRoll(f.y,f.x,f.z).Ph()}else e=[0,0,0,0];else e="weights"===Z?C?[C]:[0]:C?C.Ph():[0,0,0];v.push(e)}}static _CalculateMinMaxKeyFrames(f){let v=1/0,Z=-1/0;return f.forEach((function(f){v=Math.min(v,f.frame),Z=Math.max(Z,f.frame)})),{min:v,max:Z}}}function sf(f,v,Z,J,l,e){const C={attributes:{},influence:f.influence,name:f.name},H=v.qh;if(!H)return h.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),C;const u=e?-1:1,W=V.Xv.Zero();let a=0,b=0;if(f.hasPositions){const J=f.getPositions(),e=H.getVerticesData(O.g.PositionKind);if(e){const f=new Float32Array(e.length),v=[1/0,1/0,1/0],h=[-1/0,-1/0,-1/0];b=e.length/3,a=0;for(let Z=a;Z<b;++Z){const l=V.Xv.Av(e,3*Z);V.Xv.Av(J,3*Z).subtractToRef(l,W),W.x*=u,v[0]=Math.min(v[0],W.x),h[0]=Math.max(h[0],W.x),v[1]=Math.min(v[1],W.y),h[1]=Math.max(h[1],W.y),v[2]=Math.min(v[2],W.z),h[2]=Math.max(h[2],W.z),f[3*Z]=W.x,f[3*Z+1]=W.y,f[3*Z+2]=W.z}const H=Z.createBufferView(f,12),O=Z.createAccessor(H,"VEC3",5126,J.length/3,0,{min:v,max:h});l.push(O),C.attributes.POSITION=l.length-1}else h.Tools.Warn(`Morph target positions for mesh ${v.name} were not exported. Mesh does not have position vertex data`)}if(f.hasNormals){const J=f.getNormals(),e=H.getVerticesData(O.g.NormalKind);if(e){const f=new Float32Array(e.length);b=e.length/3,a=0;for(let Z=a;Z<b;++Z){const v=V.Xv.Av(e,3*Z).normalize();V.Xv.Av(J,3*Z).normalize().subtractToRef(v,W),f[3*Z]=W.x*u,f[3*Z+1]=W.y,f[3*Z+2]=W.z}const v=Z.createBufferView(f,12),h=Z.createAccessor(v,"VEC3",5126,J.length/3,0);l.push(h),C.attributes.NORMAL=l.length-1}else h.Tools.Warn(`Morph target normals for mesh ${v.name} were not exported. Mesh does not have normals vertex data`)}if(f.hasTangents){const J=f.getTangents(),e=H.getVerticesData(O.g.TangentKind);if(e){b=e.length/4;const f=new Float32Array(3*b);a=0;for(let Z=a;Z<b;++Z){const v=V.Xv.Av(e,4*Z);R(v);const h=V.Xv.Av(J,3*Z);R(h),h.subtractToRef(v,W),f[3*Z]=W.x*u,f[3*Z+1]=W.y,f[3*Z+2]=W.z}const v=Z.createBufferView(f,12),h=Z.createAccessor(v,"VEC3",5126,b,0);l.push(h),C.attributes.TANGENT=l.length-1}else h.Tools.Warn(`Morph target tangents for mesh ${v.name} were not exported. Mesh does not have tangents vertex data`)}if(f.hasColors){const J=f.getColors(),e=H.getVerticesData(O.g.ColorKind),u=H.getVertexBuffer(O.g.ColorKind);if(e&&u){const f=u.getSize();b=e.length/f;const v=new Float32Array(b*f);a=0;for(let Z=a;Z<b;++Z)if(3===f){const h=V.Xv.Av(e,Z*f);V.Xv.Av(J,Z*f).subtractToRef(h,W),v[3*Z]=W.x,v[3*Z+1]=W.y,v[3*Z+2]=W.z}else if(4===f){const h=new V.Vector4,l=V.Vector4.Av(e,Z*f);V.Vector4.Av(J,Z*f).subtractToRef(l,h),v[4*Z]=h.x,v[4*Z+1]=h.y,v[4*Z+2]=h.z,v[4*Z+3]=h.w}else h.Tools.Warn(`Unsupported number of components for color attribute: ${f}`);const H=Z.createBufferView(v,4*f),O=Z.createAccessor(H,3===f?"VEC3":"VEC4",5126,b,0);l.push(O),C.attributes.COLOR_0=l.length-1}else h.Tools.Warn(`Morph target colors for mesh ${v.name} were not exported. Mesh does not have colors vertex data`)}return C}var zf=Z(11947),Yf=Z(11797),yf=Z(11786),Nf=Z(11372);class If{}If.DEFAULT_COLOR=F.Mv.White(),If.DEFAULT_WIDTH_ATTENUATED=1,If.DEFAULT_WIDTH=.1;var Tf=Z(11609),Bf=Z(11950);class Pf{static ConvertPoints(f,v){if(f.length&&Array.isArray(f)&&"number"===typeof f[0])return[f];if(f.length&&Array.isArray(f[0])&&"number"===typeof f[0][0])return f;if(f.length&&!Array.isArray(f[0])&&f[0]instanceof V.Xv){const v=[];for(let Z=0;Z<f.length;Z++){const V=f[Z];v.push(V.x,V.y,V.z)}return[v]}if(f.length>0&&Array.isArray(f[0])&&f[0].length>0&&f[0][0]instanceof V.Xv){const v=[],Z=f;for(const f of Z)v.push(f.flatMap((f=>[f.x,f.y,f.z])));return v}if(f instanceof Float32Array){if(null!==v&&void 0!==v&&v.floatArrayStride){const Z=[],V=3*v.floatArrayStride;for(let v=0;v<f.length;v+=V){const h=new Array(V);for(let Z=0;Z<V;Z++)h[Z]=f[v+Z];Z.push(h)}return Z}return[Array.from(f)]}if(f.length&&f[0]instanceof Float32Array){const v=[];for(const Z of f)v.push(Array.from(Z));return v}return[]}static OmitZeroLengthPredicate(f,v,Z){const V=[];return v.Fv(f).lengthSquared()>0&&V.push([f,v]),Z.Fv(v).lengthSquared()>0&&V.push([v,Z]),f.Fv(Z).lengthSquared()>0&&V.push([Z,f]),0===V.length?null:V}static OmitDuplicatesPredicate(f,v,Z,V){const h=[];return Pf._SearchInPoints(f,v,V)||h.push([f,v]),Pf._SearchInPoints(v,Z,V)||h.push([v,Z]),Pf._SearchInPoints(Z,f,V)||h.push([Z,f]),0===h.length?null:h}static _SearchInPoints(f,v,Z){for(const l of Z)for(let Z=0;Z<l.length;Z++){var V,h,J;if(null!==(V=l[Z])&&void 0!==V&&V.equals(f))if(null!==(h=l[Z+1])&&void 0!==h&&h.equals(v)||null!==(J=l[Z-1])&&void 0!==J&&J.equals(v))return!0}return!1}static MeshesToLines(f,v){const Z=[];for(let h=0;h<f.length;h++){const J=f[h],l=J.getVerticesData(O.g.PositionKind),e=J.dh();if(l&&e)for(let f=0,C=0;f<e.length;f++){const H=3*e[C++],O=3*e[C++],u=3*e[C++],W=new V.Xv(l[H],l[H+1],l[H+2]),a=new V.Xv(l[O],l[O+1],l[O+2]),b=new V.Xv(l[u],l[u+1],l[u+2]);if(v){const V=v(W,a,b,Z,f,H,J,h,l,e);if(V)for(const f of V)Z.push(f)}else Z.push([W,a],[a,b],[b,W])}}return Z}static ToVector3Array(f){if(Array.isArray(f[0])){const v=[],Z=f;for(const f of Z){const Z=[];for(let v=0;v<f.length;v+=3)Z.push(new V.Xv(f[v],f[v+1],f[v+2]));v.push(Z)}return v}const v=f,Z=[];for(let h=0;h<v.length;h+=3)Z.push(new V.Xv(v[h],v[h+1],v[h+2]));return Z}static ToNumberArray(f){return f.flatMap((f=>[f.x,f.y,f.z]))}static GetPointsCountInfo(f){const v=new Array(f.length);let Z=0;for(let V=f.length;V--;)v[V]=f[V].length/3,Z+=v[V];return{total:Z,counts:v}}static GetLineLength(f){if(0===f.length)return 0;let v;v="number"===typeof f[0]?Pf.ToVector3Array(f):f;const Z=V.TmpVectors.Xv[0];let h=0;for(let V=0;V<v.length-1;V++){const f=v[V];h+=v[V+1].subtractToRef(f,Z).length()}return h}static GetLineLengthArray(f){const v=new Float32Array(f.length/3);let Z=0;for(let V=0,h=f.length/3-1;V<h;V++){let h=f[3*V+0],J=f[3*V+1],l=f[3*V+2];h-=f[3*V+3],J-=f[3*V+4],l-=f[3*V+5];Z+=Math.sqrt(h*h+J*J+l*l),v[V+1]=Z}return v}static SegmentizeSegmentByCount(f,v,Z){const h=[],J=v.Fv(f),l=V.TmpVectors.Xv[0];l.Ve(Z);const e=V.TmpVectors.Xv[1];J.divideToRef(l,e);let C=f.clone();h.push(C);for(let V=0;V<Z;V++)C=C.clone(),h.push(C.addInPlace(e));return h}static SegmentizeLineBySegmentLength(f,v){const Z=f[0]instanceof V.Xv?Pf.GetLineSegments(f):"number"===typeof f[0]?Pf.GetLineSegments(Pf.ToVector3Array(f)):f,h=[];for(const V of Z)if(V.length>v){const f=Pf.SegmentizeSegmentByCount(V.point1,V.point2,Math.ceil(V.length/v));for(const v of f)h.push(v)}else h.push(V.point1),h.push(V.point2);return h}static SegmentizeLineBySegmentCount(f,v){const Z="number"===typeof f[0]?Pf.ToVector3Array(f):f,V=Pf.GetLineLength(Z)/v;return Pf.SegmentizeLineBySegmentLength(Z,V)}static GetLineSegments(f){const v=[];for(let Z=0;Z<f.length-1;Z++){const V=f[Z],h=f[Z+1],J=h.Fv(V).length();v.push({point1:V,point2:h,length:J})}return v}static GetMinMaxSegmentLength(f){const v=Pf.GetLineSegments(f).sort((f=>f.length));return{min:v[0].length,max:v[v.length-1].length}}static GetPositionOnLineByVisibility(f,v,Z){let h=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const J=v*Z;let l=0,e=0;const C=f.length;for(let V=0;V<C;V++){if(J<=l+f[V].length){e=V;break}l+=f[V].length}const H=(J-l)/f[e].length;return f[e].point2.subtractToRef(f[e].point1,V.TmpVectors.Xv[0]),V.TmpVectors.Xv[1]=V.TmpVectors.Xv[0].multiplyByFloats(H,H,H),h||V.TmpVectors.Xv[1].addInPlace(f[e].point1),V.TmpVectors.Xv[1].clone()}static GetCircleLinePoints(f,v){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:f,J=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/v;const l=[];for(let e=0;e<=v;e++)l.push(new V.Xv(Math.cos(e*J)*f,Math.sin(e*J)*h,Z));return l}static GetBezierLinePoints(f,v,Z,V){return Tf.g.CreateQuadraticBezier(f,v,Z,V).getPoints().flatMap((f=>[f.x,f.y,f.z]))}static GetArrowCap(f,v,Z,V,h){let J=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[f.clone(),f.add(v.multiplyByFloats(Z,Z,Z))],widths:[V,h,J,l]}}static GetPointsFromText(f,v,Z,V){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,J=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const l=[],e=(0,Bf.b)(f,v,Z,V);for(const C of e){for(const f of C.paths){const v=[],Z=f.getPoints();for(const f of Z)v.push(f.x,f.y,h);l.push(v)}if(J)for(const f of C.holes){const v=[],Z=f.getPoints();for(const f of Z)v.push(f.x,f.y,h);l.push(v)}}return l}static Color3toRGBAUint8(f){const v=new Uint8Array(4*f.length);for(let Z=0,V=0;Z<f.length;Z++)v[V++]=255*f[Z].r,v[V++]=255*f[Z].g,v[V++]=255*f[Z].b,v[V++]=255;return v}static CreateColorsTexture(f,v,Z,V){const h=V.getEngine().getCaps().maxTextureSize??1,J=v.length>h?h:v.length,l=Math.ceil(v.length/h);l>1&&(v=[...v,...Array(J*l-v.length).fill(v[0])]);const e=Pf.Color3toRGBAUint8(v),C=new z.c(e,J,l,b.d.TEXTUREFORMAT_RGBA,V,!1,!0,Z);return C.name=f,C}static PrepareEmptyColorsTexture(f){if(!If.EmptyColorsTexture){const v=new Uint8Array(4);If.EmptyColorsTexture=new z.c(v,1,1,b.d.TEXTUREFORMAT_RGBA,f,!1,!1,z.c.NEAREST_NEAREST),If.EmptyColorsTexture.name="grlEmptyColorsTexture"}return If.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var f;null===(f=If.EmptyColorsTexture)||void 0===f||f.dispose(),If.EmptyColorsTexture=null}static BooleanToNumber(f){return f?1:0}}class gf extends yf.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class wf extends Yf.c{isCompatible(f){return!0}constructor(f,v,Z){var h;Z=Z||{color:If.DEFAULT_COLOR};const J=new gf;J.GREASED_LINE_HAS_COLOR=!!Z.color&&!Z.useColors,J.GREASED_LINE_SIZE_ATTENUATION=Z.sizeAttenuation??!1,J.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===Z.colorDistributionType,J.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(v??f.Yf()).useRightHandedSystem,J.GREASED_LINE_CAMERA_FACING=Z.cameraFacing??!0,super(f,wf.GREASED_LINE_MATERIAL_NAME,200,J,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(h=Z)||void 0===h?void 0:h.forceGLSL)||wf.ForceGLSL,this._scene=v??f.Yf(),this._engine=this._scene.getEngine(),this._cameraFacing=Z.cameraFacing??!0,this.visibility=Z.visibility??1,this.useDash=Z.useDash??!1,this.dashRatio=Z.dashRatio??.5,this.dashOffset=Z.dashOffset??0,this.width=Z.width?Z.width:Z.sizeAttenuation?If.DEFAULT_WIDTH_ATTENUATED:If.DEFAULT_WIDTH,this._sizeAttenuation=Z.sizeAttenuation??!1,this.colorMode=Z.colorMode??0,this._color=Z.color??null,this.useColors=Z.useColors??!1,this._colorsDistributionType=Z.colorDistributionType??0,this.colorsSampling=Z.colorsSampling??z.c.NEAREST_NEAREST,this._colors=Z.If??null,this.dashCount=Z.dashCount??1,this.resolution=Z.resolution??new V.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),Z.colorsTexture?this.colorsTexture=Z.colorsTexture:this._colors?this.colorsTexture=Pf.CreateColorsTexture(`${f.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??If.DEFAULT_COLOR,Pf.PrepareEmptyColorsTexture(this._scene)),this._engine.Kh.add((()=>{Pf.DisposeEmptyColorsTexture()}))}getAttributes(f){f.push("grl_offsets"),f.push("grl_widths"),f.push("grl_colorPointers"),f.push("grl_counters"),this._cameraFacing?(f.push("grl_previousAndSide"),f.push("grl_nextAndCounters")):f.push("grl_slopes")}getSamplers(f){f.push("grl_colors")}getActiveTextures(f){this.colorsTexture&&f.push(this.colorsTexture)}getUniforms(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const v=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&v.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===f&&v.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:v,vertex:this._cameraFacing&&this._isGLSL(f)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(f)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(f){if(this._cameraFacing){f.Eh("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||f.Eh("viewProjection",this._scene.getTransformMatrix());const v=V.TmpVectors.Vector4[0];v.x=this._aspect,v.y=this._resolution.x,v.z=this._resolution.y,v.w=this.width,f.updateVector4("grl_aspect_resolution_lineWidth",v)}const v=V.TmpVectors.Vector4[0];v.x=Pf.BooleanToNumber(this.useDash),v.y=this._dashArray,v.z=this.dashOffset,v.w=this.dashRatio,f.updateVector4("grl_dashOptions",v);const Z=V.TmpVectors.Vector4[1];Z.x=this.colorMode,Z.y=this.visibility,Z.z=this.colorsTexture?this.colorsTexture.getSize().width:0,Z.w=Pf.BooleanToNumber(this.useColors),f.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",Z),this._color&&f.updateColor3("grl_singleColor",this._color);const h=this.colorsTexture??If.EmptyColorsTexture;f.setTexture("grl_colors",h),f.updateFloat2("grl_textureSize",(null===h||void 0===h?void 0:h.getSize().width)??1,(null===h||void 0===h?void 0:h.getSize().height)??1)}prepareDefines(f,v,Z){f.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,f.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,f.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,f.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=v.useRightHandedSystem,f.GREASED_LINE_CAMERA_FACING=this._cameraFacing,f.GREASED_LINE_USE_OFFSETS=!!Z.offsets}getClassName(){return wf.GREASED_LINE_MATERIAL_NAME}getCustomCode(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(v)?function(f,v){if("vertex"===f){const f={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return v&&(f["!gl_Position\\=viewProjection\\*worldPos;"]="//"),f}return"fragment"===f?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(f,this._cameraFacing):function(f,v){if("vertex"===f){const f={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return v&&(f["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),f}return"fragment"===f?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(f,this._cameraFacing)}dispose(){var f;null===(f=this.colorsTexture)||void 0===f||f.dispose(),super.dispose()}get If(){return this._colors}set If(f){this.setColors(f)}setColors(f){var v;let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const h=(null===(v=this._colors)||void 0===v?void 0:v.length)??0;var J;if(this._colors=f,null!==f&&0!==f.length){if(!Z||V)if(this.colorsTexture&&h===f.length&&!V){const v=Pf.Color3toRGBAUint8(f);this.colorsTexture.update(v)}else{var l;null===(l=this.colorsTexture)||void 0===l||l.dispose(),this.colorsTexture=Pf.CreateColorsTexture(`${this._material.name}-colors-texture`,f,this.colorsSampling,this._scene)}}else null===(J=this.colorsTexture)||void 0===J||J.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(f){this._dashCount=f,this._dashArray=1/f}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(f){this._sizeAttenuation=f,this.markAllDefinesAsDirty()}get color(){return this._color}set color(f){this.setColor(f)}setColor(f){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==f||null!==this._color&&null===f?(this._color=f,v||this.markAllDefinesAsDirty()):this._color=f}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(f){this._colorsDistributionType=f,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(f){this._aspect=f.x/f.y,this._resolution=f}serialize(){const f=super.serialize(),v={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(v.If=this._colors),this._color&&(v.color=this._color),f.greasedLineMaterialOptions=v,f}parse(f,v,Z){var V;super.parse(f,v,Z);const h=f.greasedLineMaterialOptions;null===(V=this.colorsTexture)||void 0===V||V.dispose(),h.color&&this.setColor(h.color,!0),h.colorDistributionType&&(this.colorsDistributionType=h.colorDistributionType),h.If&&(this.If=h.If),h.colorsSampling&&(this.colorsSampling=h.colorsSampling),h.colorMode&&(this.colorMode=h.colorMode),h.useColors&&(this.useColors=h.useColors),h.visibility&&(this.visibility=h.visibility),h.useDash&&(this.useDash=h.useDash),h.dashCount&&(this.dashCount=h.dashCount),h.dashRatio&&(this.dashRatio=h.dashRatio),h.dashOffset&&(this.dashOffset=h.dashOffset),h.width&&(this.width=h.width),h.sizeAttenuation&&(this.sizeAttenuation=h.sizeAttenuation),h.resolution&&(this.resolution=h.resolution),this.If?this.colorsTexture=Pf.CreateColorsTexture(`${this._material.name}-colors-texture`,this.If,this.colorsSampling,v):Pf.PrepareEmptyColorsTexture(v),this.markAllDefinesAsDirty()}copyTo(f){var v;const Z=f;null===(v=Z.colorsTexture)||void 0===v||v.dispose(),this._colors&&(Z.colorsTexture=Pf.CreateColorsTexture(`${Z._material.name}-colors-texture`,this._colors,Z.colorsSampling,this._scene)),Z.setColor(this.color,!0),Z.colorsDistributionType=this.colorsDistributionType,Z.colorsSampling=this.colorsSampling,Z.colorMode=this.colorMode,Z.useColors=this.useColors,Z.visibility=this.visibility,Z.useDash=this.useDash,Z.dashCount=this.dashCount,Z.dashRatio=this.dashRatio,Z.dashOffset=this.dashOffset,Z.width=this.width,Z.sizeAttenuation=this.sizeAttenuation,Z.resolution=this.resolution,Z.markAllDefinesAsDirty()}_isGLSL(f){return 0===f||this._forceGLSL}}wf.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",wf.ForceGLSL=!1,(0,Nf.h)(`BABYLON.${wf.GREASED_LINE_MATERIAL_NAME}`,wf);var tf=Z(11837),Lf=Z(11251),Ef=Z(11637),jf=Z(11362);class qf extends Ef.ShaderMaterial{constructor(f,v,h){const J=v.getEngine(),l=J.isWebGPU&&!(h.forceGLSL||qf.ForceGLSL),e=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];v.useRightHandedSystem&&e.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const C=["position","grl_widths","grl_offsets","grl_colorPointers"];h.cameraFacing?(e.push("GREASED_LINE_CAMERA_FACING"),C.push("grl_previousAndSide","grl_nextAndCounters")):(C.push("grl_slopes"),C.push("grl_counters"));const H=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(l||H.push("world","viewProjection","view","projection"),super(f,v,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:l?["Scene","Mesh"]:void 0,attributes:C,uniforms:H,samplers:l?[]:["grlColors"],defines:e,extraInitializationsAsync:async()=>{l?await Promise.all([Z.e(66).then(Z.bind(Z,14488)),Z.e(75).then(Z.bind(Z,14492))]):await Promise.all([Z.e(69).then(Z.bind(Z,14499)),Z.e(76).then(Z.bind(Z,14503))])},shaderLanguage:l?1:0}),this._color=F.Mv.White(),this._colorsDistributionType=0,this._colorsTexture=null,h=h||{color:If.DEFAULT_COLOR},this.visibility=h.visibility??1,this.useDash=h.useDash??!1,this.dashRatio=h.dashRatio??.5,this.dashOffset=h.dashOffset??0,this.dashCount=h.dashCount??1,this.width=h.width?h.width:h.sizeAttenuation&&h.cameraFacing?If.DEFAULT_WIDTH_ATTENUATED:If.DEFAULT_WIDTH,this.sizeAttenuation=h.sizeAttenuation??!1,this.color=h.color??F.Mv.White(),this.useColors=h.useColors??!1,this.colorsDistributionType=h.colorDistributionType??0,this.colorsSampling=h.colorsSampling??z.c.NEAREST_NEAREST,this.colorMode=h.colorMode??0,this._colors=h.If??null,this._cameraFacing=h.cameraFacing??!0,this.resolution=h.resolution??new V.Vector2(J.getRenderWidth(),J.getRenderHeight()),h.colorsTexture?this.colorsTexture=h.colorsTexture:this._colors?this.colorsTexture=Pf.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,v):(this._color=this._color??If.DEFAULT_COLOR,this.colorsTexture=Pf.PrepareEmptyColorsTexture(v)),l){const f=new jf.d;f.setParameters(),f.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",f)}J.Kh.add((()=>{Pf.DisposeEmptyColorsTexture()}))}dispose(){var f;null===(f=this._colorsTexture)||void 0===f||f.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new V.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get If(){return this._colors}set If(f){this.setColors(f)}setColors(f){var v;let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const h=(null===(v=this._colors)||void 0===v?void 0:v.length)??0;var J;if(this._colors=f,null!==f&&0!==f.length){if(!Z||V)if(this._colorsTexture&&h===f.length&&!V){const v=Pf.Color3toRGBAUint8(f);this._colorsTexture.update(v)}else{var l;null===(l=this._colorsTexture)||void 0===l||l.dispose(),this.colorsTexture=Pf.CreateColorsTexture(`${this.name}-colors-texture`,f,this.colorsSampling,this.Yf())}}else null===(J=this._colorsTexture)||void 0===J||J.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(f){this._colorsTexture=f,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(f){this._width=f,this.setFloat("grlWidth",f)}get useColors(){return this._useColors}set useColors(f){this._useColors=f,this.setFloat("grlUseColors",Pf.BooleanToNumber(f))}get colorsSampling(){return this._colorsSampling}set colorsSampling(f){this._colorsSampling=f}get visibility(){return this._visibility}set visibility(f){this._visibility=f,this.setFloat("grlVisibility",f)}get useDash(){return this._useDash}set useDash(f){this._useDash=f,this.setFloat("grlUseDash",Pf.BooleanToNumber(f))}get dashOffset(){return this._dashOffset}set dashOffset(f){this._dashOffset=f,this.setFloat("grlDashOffset",f)}get dashRatio(){return this._dashRatio}set dashRatio(f){this._dashRatio=f,this.setFloat("grlDashRatio",f)}get dashCount(){return this._dashCount}set dashCount(f){this._dashCount=f,this._dashArray=1/f,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(f){this._sizeAttenuation=f,this.setFloat("grlSizeAttenuation",Pf.BooleanToNumber(f))}get color(){return this._color}set color(f){this.setColor(f)}setColor(f){f=f??If.DEFAULT_COLOR,this._color=f,this.setColor3("grlColor",f)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(f){this._colorsDistributionType=f,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(f){this._colorMode=f,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(f){this._resolution=f,this.setVector2("grlResolution",f),this.setFloat("grlAspect",f.x/f.y)}serialize(){const f=super.serialize(),v={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(v.If=this._colors),f.greasedLineMaterialOptions=v,f}parse(f,v,Z){var V;const h=f.greasedLineMaterialOptions;null===(V=this._colorsTexture)||void 0===V||V.dispose(),h.color&&(this.color=h.color),h.colorDistributionType&&(this.colorsDistributionType=h.colorDistributionType),h.colorsSampling&&(this.colorsSampling=h.colorsSampling),h.colorMode&&(this.colorMode=h.colorMode),h.useColors&&(this.useColors=h.useColors),h.visibility&&(this.visibility=h.visibility),h.useDash&&(this.useDash=h.useDash),h.dashCount&&(this.dashCount=h.dashCount),h.dashRatio&&(this.dashRatio=h.dashRatio),h.dashOffset&&(this.dashOffset=h.dashOffset),h.width&&(this.width=h.width),h.sizeAttenuation&&(this.sizeAttenuation=h.sizeAttenuation),h.resolution&&(this.resolution=h.resolution),h.If?this.colorsTexture=Pf.CreateColorsTexture(`${this.name}-colors-texture`,h.If,this.colorsSampling,this.Yf()):this.colorsTexture=Pf.PrepareEmptyColorsTexture(v),this._cameraFacing=h.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var cf,mf,pf;qf.ForceGLSL=!1,function(f){f[f.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",f[f.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(cf||(cf={})),function(f){f[f.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",f[f.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",f[f.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(mf||(mf={})),function(f){f[f.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",f[f.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",f[f.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",f[f.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",f[f.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(pf||(pf={}));class kf extends Kf.d{constructor(f,v,Z){super(f,v,null,null,!1,!1),this.name=f,this._options=Z,this._lazy=!1,this._updatable=!1,this._engine=v.getEngine(),this._lazy=Z.lazy??!1,this._updatable=Z.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=Z.colorPointers??[],this._widths=Z.widths??new Array(Z.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(f){let v=0;for(const V of this._points)v+=V.length;const Z=v/3*2-this._widths.length;for(let V=0;V<Z;V++)this._widths.push(f)}updateLazy(){var f,v;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(f=this._options.ribbonOptions)||void 0===f?void 0:f.smoothShading),!this.gf&&this.refreshBoundingInfo(),null===(v=this.greasedLineMaterial)||void 0===v||v.updateLazy()}addPoints(f,v){for(const Z of f)this._points.push(Z);this._lazy||this.setPoints(this._points,v)}dispose(f){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(f,v)}isLazy(){return this._lazy}get Tf(){return this._uvs}set Tf(f){this._uvs=f instanceof Float32Array?f:new Float32Array(f),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(f){this.material instanceof qf&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===f||void 0===f?void 0:f.length)>0),this._offsets=f,this._offsetsBuffer?this._offsetsBuffer.update(f):this._createOffsetsBuffer(f)}get widths(){return this._widths}set widths(f){this._widths=f,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(f)}get colorPointers(){return this._colorPointers}set colorPointers(f){this._colorPointers=f,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(f)}get greasedLineMaterial(){var f,v;if(this.material&&this.material instanceof qf)return this.material;const Z=null===(f=this.material)||void 0===f||null===(v=f.pluginManager)||void 0===v?void 0:v.getPlugin(wf.GREASED_LINE_MATERIAL_NAME);return Z||void 0}get points(){const f=[];return Lf.c.DeepCopy(this._points,f),f}setPoints(f,v){this._points=Pf.ConvertPoints(f,(null===v||void 0===v?void 0:v.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==v&&void 0!==v&&v.colorPointers||this._updateColorPointers(),this._setPoints(this._points,v)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Tf:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(f){super.serialize(f),f.type=this.getClassName(),f.lineOptions=this._createLineOptions()}_createVertexBuffers(){let f=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new tf.b;return v.Nf=this._vertexPositions,v.indices=this._indices,v.Tf=this._uvs,f&&(v.if=[],tf.b.ComputeNormals(this._vertexPositions,this._indices,v.if)),v.Pf(this,this._options.updatable),v}_createOffsetsBuffer(f){const v=this._scene.getEngine(),Z=new O.e(v,f,this._updatable,3);this.setVerticesBuffer(Z.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=Z}}class rf{constructor(f,v){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=f,this.wasAddedByNoopNode=v}getIndicesAccessor(f,v,Z,V,h){var J,l,e,C;return null===(J=this._indicesAccessorMap.get(f))||void 0===J||null===(l=J.get(v))||void 0===l||null===(e=l.get(Z))||void 0===e||null===(C=e.get(V))||void 0===C?void 0:C.get(h)}setIndicesAccessor(f,v,Z,V,h,J){let l=this._indicesAccessorMap.get(f);l||(l=new Map,this._indicesAccessorMap.set(f,l));let e=l.get(v);e||(e=new Map,l.set(v,e));let C=e.get(Z);C||(C=new Map,e.set(Z,C));let H=C.get(V);H||(H=new Map,C.set(V,H)),H.set(h,J)}pushExportedNode(f){this._exportedNodes.has(f)||this._exportedNodes.add(f)}getNodesSet(){return this._exportedNodes}getVertexBufferView(f){return this._vertexBufferViewMap.get(f)}setVertexBufferView(f,v){this._vertexBufferViewMap.set(f,v)}setRemappedBufferView(f,v,Z){this._remappedBufferView.set(f,new Map),this._remappedBufferView.get(f).set(v,Z)}getRemappedBufferView(f,v){var Z;return null===(Z=this._remappedBufferView.get(f))||void 0===Z?void 0:Z.get(v)}getVertexAccessor(f,v,Z){var V,h;return null===(V=this._vertexAccessorMap.get(f))||void 0===V||null===(h=V.get(v))||void 0===h?void 0:h.get(Z)}setVertexAccessor(f,v,Z,V){let h=this._vertexAccessorMap.get(f);h||(h=new Map,this._vertexAccessorMap.set(f,h));let J=h.get(v);J||(J=new Map,h.set(v,J)),J.set(Z,V)}hasVertexColorAlpha(f){return this._vertexMapColorAlpha.get(f)||!1}setHasVertexColorAlpha(f,v){return this._vertexMapColorAlpha.set(f,v)}getMesh(f){return this._meshMap.get(f)}setMesh(f,v){this._meshMap.set(f,v)}bindMorphDataToMesh(f,v){const Z=this._meshMorphTargetMap.get(f)||[];this._meshMorphTargetMap.set(f,Z),-1===Z.indexOf(v)&&Z.push(v)}getMorphTargetsFromMesh(f){return this._meshMorphTargetMap.get(f)}}class of{_ApplyExtension(f,v,Z,V){if(Z>=v.length)return Promise.resolve(f);const h=V(v[Z],f);return h?h.then((async f=>f?await this._ApplyExtension(f,v,Z+1,V):null)):this._ApplyExtension(f,v,Z+1,V)}_ApplyExtensions(f,v){const Z=[];for(const V of of._ExtensionNames)Z.push(this._extensions[V]);return this._ApplyExtension(f,Z,0,v)}_extensionsPreExportTextureAsync(f,v,Z){return this._ApplyExtensions(v,((v,V)=>v.preExportTextureAsync&&v.preExportTextureAsync(f,V,Z)))}_extensionsPostExportNodeAsync(f,v,Z,V,h){return this._ApplyExtensions(v,((v,J)=>v.postExportNodeAsync&&v.postExportNodeAsync(f,J,Z,V,h,this._bufferManager)))}_extensionsPostExportMaterialAsync(f,v,Z){return this._ApplyExtensions(v,((v,V)=>v.postExportMaterialAsync&&v.postExportMaterialAsync(f,V,Z)))}_extensionsPostExportMaterialAdditionalTextures(f,v,Z){const V=[];for(const h of of._ExtensionNames){const J=this._extensions[h];J.postExportMaterialAdditionalTextures&&V.push(...J.postExportMaterialAdditionalTextures(f,v,Z))}return V}_extensionsPostExportTextures(f,v,Z){for(const V of of._ExtensionNames){const h=this._extensions[V];h.postExportTexture&&h.postExportTexture(f,v,Z)}}_extensionsPostExportMeshPrimitive(f){for(const v of of._ExtensionNames){const Z=this._extensions[v];Z.postExportMeshPrimitive&&Z.postExportMeshPrimitive(f,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const f of of._ExtensionNames){const v=this._extensions[f];v.preGenerateBinaryAsync&&await v.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(f){for(const v of of._ExtensionNames){const Z=this._extensions[v];Z.enabled&&f(Z)}}_extensionsOnExporting(){this._forEachExtensions((f=>{var v,Z,V;f.wasUsed&&((v=this._glTF).extensionsUsed||(v.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(f.name)&&this._glTF.extensionsUsed.push(f.name),f.required&&((Z=this._glTF).extensionsRequired||(Z.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(f.name)&&this._glTF.extensionsRequired.push(f.name)),(V=this._glTF).extensions||(V.extensions={}),f.onExporting&&f.onExporting())}))}_loadExtensions(){for(const f of of._ExtensionNames){const v=of._ExtensionFactories[f](this);this._extensions[f]=v}}constructor(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:X.c.LastCreatedScene,v=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${b.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new E(this),this._extensions={},this._bufferManager=new Of,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!f)throw new Error("No scene available to export");this._babylonScene=f,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:f=>{var v;return null===f||void 0===f||null===(v=f.yh)||void 0===v?void 0:v.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...v},this._loadExtensions()}dispose(){for(const f in this._extensions){this._extensions[f].dispose()}}get options(){return this._options}static RegisterExtension(f,v){of.UnregisterExtension(f)&&h.Tools.Warn(`Extension with the name ${f} already exists`),of._ExtensionFactories[f]=v,of._ExtensionNames.push(f)}static UnregisterExtension(f){if(!of._ExtensionFactories[f])return!1;delete of._ExtensionFactories[f];const v=of._ExtensionNames.indexOf(f);return-1!==v&&of._ExtensionNames.splice(v,1),!0}_generateJSON(f,v,Z){const V={byteLength:f};return V.byteLength&&(this._glTF.buffers=[V]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Uv=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(V.uri=v+".bin"),Z?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(f){const v=await this._generateBinaryAsync();this._extensionsOnExporting();const Z=this._generateJSON(v.byteLength,f,!0),V=new Blob([v],{type:"application/octet-stream"}),h=f+".gltf",J=f+".bin",l=new H;if(l.files[h]=Z,l.files[J]=V,this._imageData)for(const e in this._imageData)l.files[e]=new Blob([this._imageData[e].data],{type:this._imageData[e].mimeType});return l}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(f){const v=f%4;return 0===v?v:4-v}async generateGLBAsync(f){this._shouldUseGlb=!0;const v=await this._generateBinaryAsync();this._extensionsOnExporting();const Z=this._generateJSON(v.byteLength),V=f+".glb";let h,J=Z.length;if("undefined"!==typeof TextEncoder){h=(new TextEncoder).encode(Z),J=h.length}const l=this._getPadding(J),e=this._getPadding(v.byteLength),C=28+J+l+v.byteLength+e,O=new Cf(C);if(O.writeUInt32(1179937895),O.writeUInt32(2),O.writeUInt32(C),O.writeUInt32(J+l),O.writeUInt32(1313821514),h)O.writeTypedArray(h);else{const f="_".charCodeAt(0);for(let v=0;v<J;++v){const V=Z.charCodeAt(v);V!=Z.codePointAt(v)?O.writeUInt8(f):O.writeUInt8(V)}}for(let H=0;H<l;++H)O.writeUInt8(32);O.writeUInt32(v.byteLength+e),O.writeUInt32(5130562),O.writeTypedArray(v);for(let H=0;H<e;++H)O.writeUInt8(0);const u=new H;return u.files[V]=new Blob([O.getOutputData()],{type:"application/octet-stream"}),u}_setNodeTransformation(f,v,Z){if(v.getPivotPoint().equalsWithEpsilon(p,m.c)||h.Tools.Warn("Pivot points are not supported in the glTF serializer"),!v.position.equalsWithEpsilon(p,m.c)){const h=V.TmpVectors.Xv[0].h(v.position);Z&&n(h),f.translation=h.Ph()}v.Ze.equalsWithEpsilon(r,m.c)||(f.scale=v.Ze.Ph());const J=v.rotationQuaternion||V.Quaternion.FromEulerAngles(v.rotation.x,v.rotation.y,v.rotation.z);J.equalsWithEpsilon(k,m.c)||(Z&&S(J),f.rotation=J.normalize().Ph())}_setCameraTransformation(f,v,Z){if(!v.position.equalsWithEpsilon(p,m.c)){const h=V.TmpVectors.Xv[0].h(v.position);Z&&n(h),f.translation=h.Ph()}const h=v.rotationQuaternion||V.Quaternion.FromEulerAngles(v.rotation.x,v.rotation.y,v.rotation.z);Z&&S(h),this._babylonScene.useRightHandedSystem||D(h),h.equalsWithEpsilon(k,m.c)||(f.rotation=h.Ph())}_listAvailableCameras(){for(const f of this._babylonScene.cameras){const v={type:f.mode===Wf.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(f.name&&(v.name=f.name),"perspective"===v.type)v.perspective={aspectRatio:f.getEngine().getAspectRatio(f),yfov:f.fovMode===Wf.d.FOVMODE_VERTICAL_FIXED?f.fov:f.fov*f.getEngine().getAspectRatio(f),znear:f.Lh,zfar:f.maxZ};else if("orthographic"===v.type){const Z=f.orthoLeft&&f.orthoRight?.5*(f.orthoRight-f.orthoLeft):.5*f.getEngine().getRenderWidth(),V=f.orthoBottom&&f.orthoTop?.5*(f.orthoTop-f.orthoBottom):.5*f.getEngine().getRenderHeight();v.orthographic={xmag:Z,ymag:V,znear:f.Lh,zfar:f.maxZ}}this._camerasMap.set(f,v)}}_exportAndAssignCameras(){const f=Array.from(this._camerasMap.values());for(const v of f){const f=this._nodesCameraMap.get(v);if(void 0!==f){this._cameras.push(v);for(const v of f)v.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const f of this._babylonScene.skeletons){if(f.bones.length<=0)continue;const v={joints:[]};this._skinMap.set(f,v)}}_exportAndAssignSkeletons(){for(const f of this._babylonScene.skeletons){if(f.bones.length<=0)continue;const v=this._skinMap.get(f);if(void 0==v)continue;const Z={},V=[];let J=-1;for(let h=0;h<f.bones.length;++h){const v=f.bones[h],V=v.getIndex()??h;-1!==V&&(Z[V]=v,V>J&&(J=V))}for(let f=0;f<=J;++f){const J=Z[f];V.push(J.getAbsoluteInverseBindMatrix());const l=J.getTransformNode();if(null!==l){const f=this._nodeMap.get(l);l&&null!==f&&void 0!==f?v.joints.push(f):h.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else h.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const l=this._nodesSkinMap.get(v);if(v.joints.length>0&&void 0!==l){const f=64*V.length,Z=new Float32Array(f/4);V.forEach(((f,v)=>{Z.set(f.m,16*v)}));const h=this._bufferManager.createBufferView(Z);this._accessors.push(this._bufferManager.createAccessor(h,"MAT4",5126,V.length)),v.inverseBindMatrices=this._accessors.length-1,this._skins.push(v);for(const v of l)v.skin=this._skins.length-1}}}async _exportSceneAsync(){const f={nodes:[]};if(this._babylonScene.metadata){const v=this._options.metadataSelector(this._babylonScene.metadata);v&&(f.extras=v)}const v=new Array,Z=new Array,V=new Array;for(const e of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&lf(e,this._babylonScene.useRightHandedSystem)?V.push(...e.getChildren()):this._babylonScene.useRightHandedSystem?v.push(e):Z.push(e);this._listAvailableCameras(),this._listAvailableSkeletons();const h=new rf(!0,!1);f.nodes.push(...await this._exportNodesAsync(Z,h));const J=new rf(!1,!1);f.nodes.push(...await this._exportNodesAsync(v,J));const l=new rf(!1,!0);f.nodes.push(...await this._exportNodesAsync(V,l)),f.nodes.length&&this._scenes.push(f),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Af._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,h.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(f){let v=this._shouldExportNodeMap.get(f);return void 0===v&&(v=this._options.shouldExportNode(f),this._shouldExportNodeMap.set(f,v)),v}async _exportNodesAsync(f,v){const Z=new Array;this._exportBuffers(f,v);for(const V of f)await this._exportNodeAsync(V,Z,v);return Z}_collectBuffers(f,v,Z,V,h){if(this._shouldExportNode(f)&&f instanceof W.e&&f.qh){const J=f.qh.getVertexBuffers();if(J)for(const V in J){if(!d(V))continue;const l=J[V];h.setHasVertexColorAlpha(l,f.hasVertexAlpha);const e=l._buffer,C=v.get(e)||[];v.set(e,C),-1===C.indexOf(l)&&C.push(l);const H=Z.get(l)||[];Z.set(l,H),-1===H.indexOf(f)&&H.push(f)}const l=f.morphTargetManager;if(l)for(let v=0;v<l.numTargets;v++){const Z=l.getTarget(v),h=V.get(Z)||[];V.set(Z,h),-1===h.indexOf(f)&&h.push(f)}}for(const J of f.getChildren())this._collectBuffers(J,v,Z,V,h)}_exportBuffers(f,v){const Z=new Map,V=new Map,h=new Map;for(const e of f)this._collectBuffers(e,Z,V,h,v);const J=Array.from(Z.keys());for(const e of J){const f=e.getData();if(!f)throw new Error("Buffer data is not available");const h=Z.get(e);if(!h)continue;const J=h[0].byteStride;if(h.some((f=>f.byteStride!==J)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const l=Zf(f).slice();for(const v of h){const f=V.get(v),{byteOffset:Z,byteStride:h,componentCount:J,type:e,count:C,normalized:H,kind:u}=G(v,f);switch(u){case O.g.NormalKind:case O.g.TangentKind:(0,j.g)(l,Z,h,J,e,C,H,(f=>{const v=Math.sqrt(f[0]*f[0]+f[1]*f[1]+f[2]*f[2]);if(v>0){const Z=1/v;f[0]*=Z,f[1]*=Z,f[2]*=Z}}));break;case O.g.ColorKind:{const v=f.filter((f=>f.material instanceof Xf.Kv||null==f.material)).length;if(0==v)break;if(v!=f.length){q.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}e==O.g.UNSIGNED_BYTE&&q.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const V=new F.Mv,u=new F.he,W=this._babylonScene.getEngine().useExactSrgbConversions;(0,j.g)(l,Z,h,J,e,C,H,(f=>{3===f.length?(V.bZ(f,0),V.toLinearSpaceToRef(V,W),V.toArray(f,0)):(u.bZ(f,0),u.toLinearSpaceToRef(u,W),u.toArray(f,0))}))}}}if(v.convertToRightHanded){for(const f of h){const v=V.get(f),{byteOffset:Z,byteStride:h,componentCount:J,type:e,count:C,normalized:H,kind:u}=G(f,v);switch(u){case O.g.PositionKind:case O.g.NormalKind:case O.g.TangentKind:(0,j.g)(l,Z,h,J,e,C,H,(f=>{f[0]=-f[0]}))}}v.convertedToRightHandedBuffers.set(e,l)}const C=this._bufferManager.createBufferView(l,J);v.setVertexBufferView(e,C);const H=new Map;for(const v of h){const f=V.get(v),{kind:Z,totalVertices:h}=G(v,f);switch(Z){case O.g.MatricesIndicesKind:case O.g.MatricesIndicesExtraKind:if(v.type==O.g.FLOAT){const f=v.getFloatData(h);null!==f&&H.set(v,f)}}}0!==H.size&&q.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const u=Array.from(H.keys());for(const Z of u){const f=H.get(Z);if(!f)continue;const V=f.some((f=>f>=256)),h=new(V?Uint16Array:Uint8Array)(f.length);for(let v=0;v<f.length;v++)h[v]=f[v];const J=this._bufferManager.createBufferView(h,4*(V?2:1));v.setRemappedBufferView(e,Z,J)}}const l=Array.from(h.keys());for(const e of l){const f=h.get(e);if(!f)continue;const Z=sf(e,f[0],this._bufferManager,this._bufferViews,this._accessors,v.convertToRightHanded);for(const V of f)v.bindMorphDataToMesh(V,Z)}}async _exportNodeAsync(f,v,Z){let V=this._nodeMap.get(f);if(void 0!==V)return void(v.includes(V)||v.push(V));const h=await this._createNodeAsync(f,Z);if(h){V=this._nodes.length,this._nodes.push(h),this._nodeMap.set(f,V),Z.pushExportedNode(f),v.push(V);const J={name:"runtime animations",channels:[],samplers:[]},l=[];this._babylonScene.animationGroups.length||(Af._CreateMorphTargetAnimationFromMorphTargetAnimations(f,J,l,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Z.convertToRightHanded,this._options.shouldExportAnimation),f.animations.length&&Af._CreateNodeAnimationFromNodeAnimations(f,J,l,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Z.convertToRightHanded,this._options.shouldExportAnimation)),J.channels.length&&J.samplers.length&&this._animations.push(J),l.forEach((f=>{f.channels.length&&f.samplers.length&&this._animations.push(f)}))}const J=h?[]:v;for(const l of f.getChildren())await this._exportNodeAsync(l,J,Z);h&&J.length&&(h.children=J)}async _createNodeAsync(f,v){if(!this._shouldExportNode(f))return null;const Z={};if(f.name&&(Z.name=f.name),f.metadata){const v=this._options.metadataSelector(f.metadata);v&&(Z.extras=v)}if(f instanceof u.e&&(this._setNodeTransformation(Z,f,v.convertToRightHanded),f instanceof W.e)){const h=f instanceof a.c?f.sourceMesh:f;if(h.Bh&&h.Bh.length>0&&(Z.mesh=await this._exportMeshAsync(h,v)),f.skeleton){const v=this._skinMap.get(f.skeleton);var V;if(void 0!==v)void 0===this._nodesSkinMap.get(v)&&this._nodesSkinMap.set(v,[]),null===(V=this._nodesSkinMap.get(v))||void 0===V||V.push(Z)}}if(f instanceof c.e){const V=this._camerasMap.get(f);if(V){var h;void 0===this._nodesCameraMap.get(V)&&this._nodesCameraMap.set(V,[]),this._setCameraTransformation(Z,f,v.convertToRightHanded);const l=f.parent;if(null!==l&&vf(f,l)){const f=this._nodeMap.get(l);if(void 0!==f){var J;const v=this._nodes[f];return ff(Z,v),null===(J=this._nodesCameraMap.get(V))||void 0===J||J.push(v),null}}null===(h=this._nodesCameraMap.get(V))||void 0===h||h.push(Z)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",Z,f,this._nodeMap,v.convertToRightHanded)?Z:(q.e.Warn(`Not exporting node ${f.name}`),null)}_exportIndices(f,v,Z,V,h,l,e,C,H){let O=f;H.mode=x(l);const u=e!==J.e.CounterClockWiseSideOrientation,W=!C.wasAddedByNoopNode&&u,a=function(f){switch(f){case J.e.TriangleFillMode:case J.e.TriangleStripDrawMode:case J.e.TriangleFanDrawMode:return!0}return!1}(l)&&W;if(a){if(l===J.e.TriangleStripDrawMode||l===J.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");H.mode=x(l);const e=v?new Uint32Array(V):new Uint16Array(V);if(f)for(let v=0;v+2<V;v+=3)e[v]=f[Z+v]+h,e[v+1]=f[Z+v+2]+h,e[v+2]=f[Z+v+1]+h;else for(let f=0;f+2<V;f+=3)e[f]=f,e[f+1]=f+2,e[f+2]=f+1;O=e}else if(f&&0!==h){const J=v?new Uint32Array(V):new Uint16Array(V);for(let v=0;v<V;v++)J[v]=f[Z+v]+h;O=J}if(O){let J=C.getIndicesAccessor(f,Z,V,h,a);if(void 0===J){const l=function(f,v,Z,V){if(f instanceof Uint16Array||f instanceof Uint32Array)return f;if(f instanceof Int32Array)return new Uint32Array(f.buffer,f.byteOffset,f.length);const h=f.slice(v,v+Z);return V?new Uint32Array(h):new Uint16Array(h)}(O,0,V,v),e=this._bufferManager.createBufferView(l),H=v?5125:5123;this._accessors.push(this._bufferManager.createAccessor(e,"SCALAR",H,V,0)),J=this._accessors.length-1,C.setIndicesAccessor(f,Z,V,h,a,J)}H.indices=J}}_exportVertexBuffer(f,v,Z,V,h,J){const l=f.getKind();if(!d(l))return;if(l.startsWith("uv")&&!this._options.exportUnusedUVs&&(!v||!this._materialNeedsUVsSet.has(v)))return;let e=h.getVertexAccessor(f,Z,V);if(void 0===e){const v=h.convertedToRightHandedBuffers.get(f._buffer)||f._buffer.getData(),J=l===O.g.PositionKind?function(f,v,Z,V){const{byteOffset:h,byteStride:J,type:l,normalized:e}=v,C=v.getSize(),H=new Array(C).fill(1/0),O=new Array(C).fill(-1/0);return(0,j.g)(f,h+Z*J,J,C,l,V*C,e,(f=>{for(let v=0;v<C;v++)H[v]=Math.min(H[v],f[v]),O[v]=Math.max(O[v],f[v])})),{min:H,max:O}}(v,f,Z,V):void 0,C=(l===O.g.MatricesIndicesKind||l===O.g.MatricesIndicesExtraKind)&&f.type===O.g.FLOAT,H=C?O.g.UNSIGNED_BYTE:f.type,u=C?void 0:f.normalized,W=C?h.getRemappedBufferView(f._buffer,f):h.getVertexBufferView(f._buffer),a=f.byteOffset+Z*f.byteStride;this._accessors.push(this._bufferManager.createAccessor(W,function(f,v){if(f==O.g.ColorKind)return v?"VEC4":"VEC3";switch(f){case O.g.PositionKind:case O.g.NormalKind:return"VEC3";case O.g.TangentKind:case O.g.MatricesIndicesKind:case O.g.MatricesIndicesExtraKind:case O.g.MatricesWeightsKind:case O.g.MatricesWeightsExtraKind:return"VEC4";case O.g.UVKind:case O.g.UV2Kind:case O.g.UV3Kind:case O.g.UV4Kind:case O.g.UV5Kind:case O.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${f}`)}(l,h.hasVertexColorAlpha(f)),H,V,a,J,u)),e=this._accessors.length-1,h.setVertexAccessor(f,Z,V,e)}J.attributes[function(f){switch(f){case O.g.PositionKind:return"POSITION";case O.g.NormalKind:return"NORMAL";case O.g.TangentKind:return"TANGENT";case O.g.ColorKind:return"COLOR_0";case O.g.UVKind:return"TEXCOORD_0";case O.g.UV2Kind:return"TEXCOORD_1";case O.g.UV3Kind:return"TEXCOORD_2";case O.g.UV4Kind:return"TEXCOORD_3";case O.g.UV5Kind:return"TEXCOORD_4";case O.g.UV6Kind:return"TEXCOORD_5";case O.g.MatricesIndicesKind:return"JOINTS_0";case O.g.MatricesIndicesExtraKind:return"JOINTS_1";case O.g.MatricesWeightsKind:return"WEIGHTS_0";case O.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${f}`)}(l)]=e}async _exportMaterialAsync(f,v,Z,V){let h=this._materialMap.get(f);if(void 0===h){const V=v&&Object.keys(v).some((f=>f.startsWith("uv")));if((f=f instanceof af.c?f.ue[Z.materialIndex]:f)instanceof bf.c)h=await this._materialExporter.exportPBRMaterialAsync(f,"image/png",V);else{if(!(f instanceof Xf.Kv))return void q.e.Warn(`Unsupported material '${f.name}' with type ${f.getClassName()}`);h=await this._materialExporter.exportStandardMaterialAsync(f,"image/png",V)}this._materialMap.set(f,h)}V.material=h}async _exportMeshAsync(f,v){var Z;let V=v.getMesh(f);if(void 0!==V)return V;const h={primitives:[]};V=this._meshes.length,this._meshes.push(h),v.setMesh(f,V);const l=f.isUnIndexed?null:f.dh(),e=null===(Z=f.qh)||void 0===Z?void 0:Z.getVertexBuffers(),C=v.getMorphTargetsFromMesh(f),H=f instanceof zf.e,O=f instanceof kf,u=f.Bh;if(e&&u&&u.length>0)for(const b of u){const Z={attributes:{}},V=b.Ef()||this._babylonScene.defaultMaterial;if(O){var W,a;const v={name:V.name},h=f,J=F.Mv.White(),l=(null===(W=h.material)||void 0===W?void 0:W.alpha)??1,e=(null===(a=h.greasedLineMaterial)||void 0===a?void 0:a.color)??J;(!e.equalsWithEpsilon(J,m.c)||l<1)&&(v.pbrMetallicRoughness={baseColorFactor:[...e.Ph(),l]}),this._materials.push(v),Z.material=this._materials.length-1}else if(H){const v={name:V.name},h=f;(!h.color.equalsWithEpsilon(F.Mv.White(),m.c)||h.alpha<1)&&(v.pbrMetallicRoughness={baseColorFactor:[...h.color.Ph(),h.alpha]}),this._materials.push(v),Z.material=this._materials.length-1}else await this._exportMaterialAsync(V,e,b,Z);const u=H||O?J.e.LineListDrawMode:f.overrideRenderingFillMode??V.fillMode,X=V._getEffectiveOrientation(f);this._exportIndices(l,l?(0,j.e)(l,b.indexCount,b.indexStart,b.verticesStart):b.verticesCount>65535,l?b.indexStart:b.verticesStart,l?b.indexCount:b.verticesCount,-b.verticesStart,u,X,v,Z);for(const f of Object.values(e))this._exportVertexBuffer(f,V,b.verticesStart,b.verticesCount,v,Z);if(C){Z.targets=[];for(const f of C)Z.targets.push(f.attributes)}h.primitives.push(Z),this._extensionsPostExportMeshPrimitive(Z)}if(C){h.weights=[],h.extras||(h.extras={}),h.extras.targetNames=[];for(const f of C)h.weights.push(f.influence),h.extras.targetNames.push(f.name)}return V}}of._ExtensionNames=new Array,of._ExtensionFactories={};class Gf{static async GLTFAsync(f,v,Z){Z&&Z.exportWithoutWaitingForScene||await f.whenReadyAsync();const V=new of(f,Z),h=await V.generateGLTFAsync(v.replace(/\.[^/.]+$/,""));return V.dispose(),h}static async GLBAsync(f,v,Z){Z&&Z.exportWithoutWaitingForScene||await f.whenReadyAsync();const V=new of(f,Z),h=await V.generateGLBAsync(v.replace(/\.[^/.]+$/,""));return V.dispose(),h}}Z(11960);const Qf="EXT_mesh_gpu_instancing";class df{constructor(f){this.name=Qf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=f}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(f,v,Z,h,J,l){return await new Promise((f=>{if(v&&Z instanceof Kf.d&&Z.hasThinInstances&&this._exporter){this._wasUsed=!0;const f=V.Xv.Zero(),h=V.Quaternion.Identity(),e=V.Xv.One(),C=Z.thinInstanceGetWorldMatrices(),H=V.TmpVectors.Xv[2],O=V.TmpVectors.Quaternion[1],u=V.TmpVectors.Xv[3];let W=!1,a=!1,b=!1;const X=new Float32Array(3*Z.Fe),F=new Float32Array(4*Z.Fe),U=new Float32Array(3*Z.Fe);let K=0;for(const v of C)v.decompose(u,O,H),J&&(n(H),S(O)),X.set(H.Ph(),3*K),F.set(O.normalize().Ph(),4*K),U.set(u.Ph(),3*K),W=W||!H.equalsWithEpsilon(f),a=a||!O.equalsWithEpsilon(h),b=b||!u.equalsWithEpsilon(e),K++;const M={attributes:{}};W&&(M.attributes.TRANSLATION=this._buildAccessor(X,"VEC3",Z.Fe,l)),a&&(M.attributes.ROTATION=this._buildAccessor(F,"VEC4",Z.Fe,l)),b&&(M.attributes.SCALE=this._buildAccessor(U,"VEC3",Z.Fe,l)),v.extensions=v.extensions||{},v.extensions[Qf]=M}f(v)}))}_buildAccessor(f,v,Z,V){const h=V.createBufferView(f),J=V.createAccessor(h,v,5126,Z);return this._exporter._accessors.push(J),this._exporter._accessors.length-1}}of.RegisterExtension(Qf,(f=>new df(f)));var xf=Z(11962),Rf=Z(11976),nf=Z(11978),Sf=Z(11982);function Df(f){return f===nf.c.PositionKind?"POSITION":f===nf.c.NormalKind?"NORMAL":f===nf.c.ColorKind?"COLOR":f.startsWith(nf.c.UVKind)?"TEX_COORD":"GENERIC"}const fv={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class vv extends xf.e{static get DefaultAvailable(){return(0,xf.k)(vv.DefaultConfiguration)}static get Default(){return vv._Default??(vv._Default=new vv),vv._Default}static ResetDefault(f){vv._Default&&(f||vv._Default.dispose(),vv._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(f,v){return{module:await(v||DracoEncoderModule)({wasmBinary:f})}}_getWorkerContent(){return`${Rf.h}(${Rf.i})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:vv.DefaultConfiguration)}async _encodeAsync(f,v,Z){const V=Z?(0,Sf.c)(fv,Z):fv;if(this._workerPoolPromise){const Z=await this._workerPoolPromise;return await new Promise(((h,J)=>{Z.push(((Z,l)=>{const e=f=>{Z.removeEventListener("error",e),Z.removeEventListener("message",C),J(f),l()},C=f=>{"encodeMeshDone"===f.data.id&&(Z.removeEventListener("error",e),Z.removeEventListener("message",C),h(f.data.encodedMeshData),l())};Z.addEventListener("error",e),Z.addEventListener("message",C);const H=[];for(const v of f)H.push(v.data.buffer);v&&H.push(v.buffer),Z.postMessage({id:"encodeMesh",attributes:f,indices:v,options:V},H)}))}))}if(this._modulePromise){const Z=await this._modulePromise;return(0,Rf.h)(Z.module,f,v,V)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(f,v){if(0==f.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");f instanceof Kf.d&&f.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===v||void 0===v?void 0:v.method)&&(q.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),v.method="MESH_SEQUENTIAL_ENCODING");const Z=function(f){let v=f.dh(void 0,!0);return!v||v instanceof Uint32Array||v instanceof Uint16Array||(v=((0,j.e)(v,v.length)?Uint32Array:Uint16Array).from(v)),v}(f),V=function(f,v){const Z=[];for(const V of f.getVerticesDataKinds()){if(null!==v&&void 0!==v&&v.includes(V)){if(V===nf.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const h=f.getVertexBuffer(V),J=h.getSize(),l=(0,j.s)(h.getData(),J,h.type,h.byteOffset,h.byteStride,h.normalized,f.getTotalVertices(),!0);Z.push({kind:V,dracoName:Df(V),size:J,data:l})}return Z}(f,null===v||void 0===v?void 0:v.excludedAttributes);return await this._encodeAsync(V,Z,v)}}vv.DefaultConfiguration={wasmUrl:`${h.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${h.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${h.Tools._DefaultCdnUrl}/draco_encoder.js`},vv._Default=null;const Zv="KHR_draco_mesh_compression";class Vv{get wasUsed(){return this._wasUsed}constructor(f){this.name=Zv,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===f.options.meshCompressionMethod&&vv.DefaultAvailable}dispose(){}postExportMeshPrimitive(f,v,Z){if(!this.enabled)return;if(4!==f.mode&&5!==f.mode)return void q.e.Warn("Cannot compress primitive with mode "+f.mode+".");const V=[],h=[];let J=null;if(void 0!==f.indices){const l=Z[f.indices],e=v.getBufferView(l);J=v.getData(e).slice(),V.push(e),h.push(l)}const l=[];for(const[O,u]of Object.entries(f.attributes)){const f=Z[u],J=v.getBufferView(f),C=Q(f.type),H=(0,j.s)(v.getData(J),C,f.componentType,f.byteOffset||0,J.byteStride||(0,j.m)(f.componentType)*C,f.normalized||!1,f.count,!0);l.push({kind:O,dracoName:(e=O,"POSITION"===e?"POSITION":"NORMAL"===e?"NORMAL":e.startsWith("COLOR")?"COLOR":e.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:Q(f.type),data:H}),V.push(J),h.push(f)}var e;const C={method:f.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},H=vv.Default._encodeAsync(l,J,C).then((Z=>{if(!Z)return void q.e.Error("Draco encoding failed for primitive.");const J={bufferView:-1,attributes:Z.attributeIds},l=v.createBufferView(Z.data);v.setBufferView(J,l);for(const f of V)this._bufferViewsUsed.add(f);for(const f of h)this._accessorsUsed.add(f);f.extensions||(f.extensions={}),f.extensions[Zv]=J})).catch((f=>{q.e.Error("Draco encoding failed for primitive: "+f)}));this._encodePromises.push(H),this._wasUsed=!0}async preGenerateBinaryAsync(f){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((v=>{f.getPropertiesWithBufferView(v).every((f=>this._accessorsUsed.has(f)))&&f.removeBufferView(v)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}of.RegisterExtension(Zv,(f=>new Vv(f)));var hv=Z(11984);const Jv="KHR_lights_punctual",lv={name:"",color:[1,1,1],Ke:1,range:Number.MAX_VALUE},ev={innerConeAngle:0,outerConeAngle:Math.PI/4},Cv=V.Xv.Backward();class Hv{constructor(f){this.name=Jv,this.enabled=!0,this.required=!1,this._exporter=f}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Jv]=this._lights}async postExportNodeAsync(f,v,Z,h,J){return await new Promise((l=>{if(!(Z instanceof Mf.c))return void l(v);const e=Z.getTypeID()==Mf.c.LIGHTTYPEID_POINTLIGHT?"point":Z.getTypeID()==Mf.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":Z.getTypeID()==Mf.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!e||!(Z instanceof hv.b))return q.e.Warn(`${f}: Light ${Z.name} is not supported in ${Jv}`),void l(v);if(Z.falloffType!==Mf.c.FALLOFF_GLTF&&q.e.Warn(`${f}: Light falloff for ${Z.name} does not match the ${Jv} specification!`),!Z.position.equalsToFloats(0,0,0)){const f=V.TmpVectors.Xv[0].h(Z.position);J&&n(f),v.translation=f.Ph()}if("point"!==e){const f=Z.direction.normalizeToRef(V.TmpVectors.Xv[0]);J&&n(f);const h=V.Quaternion.FromUnitVectorsToRef(Cv,f,V.TmpVectors.Quaternion[0]);V.Quaternion.IsIdentity(h)||(v.rotation=h.Ph())}const C={type:e,name:Z.name,color:Z.Me.Ph(),Ke:Z.Ke,range:Z.range};if(Vf(C,lv),"spot"===e){const f=Z;C.spot={innerConeAngle:f.innerAngle/2,outerConeAngle:f.angle/2},Vf(C.spot,ev)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(C);const H={Vh:this._lights.lights.length-1},O=Z.parent;if(O&&vf(Z,O)){const f=h.get(O);if(f){const Z=this._exporter._nodes[f];return ff(v,Z),Z.extensions||(Z.extensions={}),Z.extensions[Jv]=H,void l(null)}}v.extensions||(v.extensions={}),v.extensions[Jv]=H,l(v)}))}}of.RegisterExtension(Jv,(f=>new Hv(f)));var Ov=Z(11906);const uv="KHR_materials_anisotropy";class Wv{constructor(f){this.name=uv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=f}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(f,v,Z){const V=[];return Z instanceof Ov.d&&Z.anisotropy.isEnabled&&!Z.anisotropy.legacy?(Z.anisotropy.texture&&V.push(Z.anisotropy.texture),V):[]}postExportMaterialAsync(f,v,Z){return new Promise((f=>{if(Z instanceof Ov.d){if(!Z.anisotropy.isEnabled||Z.anisotropy.legacy)return void f(v);this._wasUsed=!0,v.extensions=v.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(Z.anisotropy.texture),h={anisotropyStrength:Z.anisotropy.Ke,anisotropyRotation:Z.anisotropy.angle,anisotropyTexture:V??void 0};null!==h.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(Z),v.extensions[uv]=h}f(v)}))}}of.RegisterExtension(uv,(f=>new Wv(f)));const av="KHR_materials_clearcoat";class bv{constructor(f){this.name=av,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=f}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(f,v,Z){const V=[];return Z instanceof Ov.d&&Z.clearCoat.isEnabled?(Z.clearCoat.texture&&V.push(Z.clearCoat.texture),!Z.clearCoat.useRoughnessFromMainTexture&&Z.clearCoat.textureRoughness&&V.push(Z.clearCoat.textureRoughness),Z.clearCoat.bumpTexture&&V.push(Z.clearCoat.bumpTexture),V):[]}postExportMaterialAsync(f,v,Z){return new Promise((f=>{if(Z instanceof Ov.d){if(!Z.clearCoat.isEnabled)return void f(v);this._wasUsed=!0,v.extensions=v.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(Z.clearCoat.texture);let J;J=Z.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(Z.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(Z.clearCoat.textureRoughness),Z.clearCoat.isTintEnabled&&h.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${Z.name}`),Z.clearCoat.remapF0OnInterfaceChange&&h.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${Z.name}`);const l=this._exporter._materialExporter.getTextureInfo(Z.clearCoat.bumpTexture),e={clearcoatFactor:Z.clearCoat.Ke,clearcoatTexture:V??void 0,clearcoatRoughnessFactor:Z.clearCoat.roughness,clearcoatRoughnessTexture:J??void 0,clearcoatNormalTexture:l??void 0};null===e.clearcoatTexture&&null===e.clearcoatRoughnessTexture&&null===e.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Z),v.extensions[av]=e}f(v)}))}}of.RegisterExtension(av,(f=>new bv(f)));const Xv="KHR_materials_diffuse_transmission";function Fv(f,v){const Z=v.subSurface;let V=null;return Z.translucencyIntensityTexture?V=Z.translucencyIntensityTexture:Z.thicknessTexture&&Z.useMaskFromThicknessTexture&&(V=Z.thicknessTexture),V&&!Z.useGltfStyleTextures?(q.e.Warn(`${f}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${v.name}`,1),null):V}class Uv{constructor(f){this.name=Xv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=f}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(f,v,Z){const V=[];if(Z instanceof bf.c&&this._isExtensionEnabled(Z)){const v=Fv(f,Z);return v&&V.push(v),Z.subSurface.translucencyColorTexture&&V.push(Z.subSurface.translucencyColorTexture),V}return V}_isExtensionEnabled(f){if(f.unlit)return!1;const v=f.subSurface;return!!v.isTranslucencyEnabled&&(!f.unlit&&!v.useAlbedoToTintTranslucency&&v.useGltfStyleTextures&&1===v.volumeIndexOfRefraction&&0===v.minimumThickness&&0===v.maximumThickness)}postExportMaterialAsync(f,v,Z){return new Promise((V=>{if(Z instanceof bf.c&&this._isExtensionEnabled(Z)){this._wasUsed=!0;const V=Z.subSurface,h=Fv(f,Z),J=0==V.translucencyIntensity?void 0:V.translucencyIntensity,l=this._exporter._materialExporter.getTextureInfo(h)??void 0,e=!V.translucencyColor||V.translucencyColor.equalsFloats(1,1,1)?void 0:V.translucencyColor.Ph(),C=this._exporter._materialExporter.getTextureInfo(V.translucencyColorTexture)??void 0,H={diffuseTransmissionFactor:J,diffuseTransmissionTexture:l,diffuseTransmissionColorFactor:e,diffuseTransmissionColorTexture:C};(l||C)&&this._exporter._materialNeedsUVsSet.add(Z),v.extensions=v.extensions||{},v.extensions[Xv]=H}V(v)}))}}of.RegisterExtension(Xv,(f=>new Uv(f)));const Kv="KHR_materials_dispersion";class Mv{constructor(){this.name=Kv,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(f){if(f.unlit)return!1;const v=f.subSurface;return!(!v.isRefractionEnabled&&!v.isDispersionEnabled)}postExportMaterialAsync(f,v,Z){return new Promise((f=>{if(Z instanceof bf.c&&this._isExtensionEnabled(Z)){this._wasUsed=!0;const f={dispersion:Z.subSurface.dispersion};v.extensions=v.extensions||{},v.extensions[Kv]=f}f(v)}))}}of.RegisterExtension(Kv,(()=>new Mv));const Av="KHR_materials_emissive_strength";class sv{constructor(){this.name=Av,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(f,v,Z){return await new Promise((f=>{if(!(Z instanceof bf.c))return f(v);const V=Z.emissiveColor.Ph(),h=Math.max(...V);if(h>1){this._wasUsed=!0,v.extensions||(v.extensions={});const f={emissiveStrength:h},V=Z.emissiveColor.scale(1/f.emissiveStrength);v.emissiveFactor=V.Ph(),v.extensions[Av]=f}return f(v)}))}}of.RegisterExtension(Av,(f=>new sv));const zv="KHR_materials_ior";class Yv{constructor(){this.name=zv,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(f){return!f.unlit&&(void 0!=f.indexOfRefraction&&1.5!=f.indexOfRefraction)}postExportMaterialAsync(f,v,Z){return new Promise((f=>{if(Z instanceof bf.c&&this._isExtensionEnabled(Z)){this._wasUsed=!0;const f={ior:Z.indexOfRefraction};v.extensions=v.extensions||{},v.extensions[zv]=f}f(v)}))}}of.RegisterExtension(zv,(f=>new Yv));const yv="KHR_materials_iridescence";class Nv{constructor(f){this.name=yv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=f}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(f,v,Z){const V=[];return Z instanceof Ov.d&&Z.iridescence.isEnabled?(Z.iridescence.texture&&V.push(Z.iridescence.texture),Z.iridescence.thicknessTexture&&Z.iridescence.thicknessTexture!==Z.iridescence.texture&&V.push(Z.iridescence.thicknessTexture),V):[]}postExportMaterialAsync(f,v,Z){return new Promise((f=>{if(Z instanceof Ov.d){if(!Z.iridescence.isEnabled)return void f(v);this._wasUsed=!0,v.extensions=v.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(Z.iridescence.texture),h=this._exporter._materialExporter.getTextureInfo(Z.iridescence.thicknessTexture),J={iridescenceFactor:Z.iridescence.Ke,iridescenceIor:Z.iridescence.indexOfRefraction,iridescenceThicknessMinimum:Z.iridescence.minimumThickness,iridescenceThicknessMaximum:Z.iridescence.maximumThickness,iridescenceTexture:V??void 0,iridescenceThicknessTexture:h??void 0};null===J.iridescenceTexture&&null===J.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(Z),v.extensions[yv]=J}f(v)}))}}of.RegisterExtension(yv,(f=>new Nv(f)));const iv="KHR_materials_sheen";class Iv{constructor(f){this.name=iv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=f}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(f,v,Z){return Z instanceof bf.c&&Z.sheen.isEnabled&&Z.sheen.texture?[Z.sheen.texture]:[]}async postExportMaterialAsync(f,v,Z){return await new Promise((f=>{if(Z instanceof bf.c){if(!Z.sheen.isEnabled)return void f(v);this._wasUsed=!0,null==v.extensions&&(v.extensions={});const V={sheenColorFactor:Z.sheen.color.Ph(),sheenRoughnessFactor:Z.sheen.roughness??0};null===V.sheenColorTexture&&null===V.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Z),Z.sheen.texture&&(V.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(Z.sheen.texture)??void 0),Z.sheen.textureRoughness&&!Z.sheen.useRoughnessFromMainTexture?V.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Z.sheen.textureRoughness)??void 0:Z.sheen.texture&&Z.sheen.useRoughnessFromMainTexture&&(V.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Z.sheen.texture)??void 0),v.extensions[iv]=V}f(v)}))}}of.RegisterExtension(iv,(f=>new Iv(f)));const Tv="KHR_materials_specular";class Bv{constructor(f){this.name=Tv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=f}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(f,v,Z){const V=[];return Z instanceof bf.c&&this._isExtensionEnabled(Z)?(Z.metallicReflectanceTexture&&V.push(Z.metallicReflectanceTexture),Z.reflectanceTexture&&V.push(Z.reflectanceTexture),V):V}_isExtensionEnabled(f){return!f.unlit&&(void 0!=f.metallicF0Factor&&1!=f.metallicF0Factor||void 0!=f.metallicReflectanceColor&&!f.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(f))}_hasTexturesExtension(f){return null!=f.metallicReflectanceTexture||null!=f.reflectanceTexture}postExportMaterialAsync(f,v,Z){return new Promise((f=>{if(Z instanceof bf.c&&this._isExtensionEnabled(Z)){this._wasUsed=!0,v.extensions=v.extensions||{};const f=this._exporter._materialExporter.getTextureInfo(Z.metallicReflectanceTexture)??void 0,V=this._exporter._materialExporter.getTextureInfo(Z.reflectanceTexture)??void 0,h={specularFactor:1==Z.metallicF0Factor?void 0:Z.metallicF0Factor,specularTexture:f,specularColorFactor:Z.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:Z.metallicReflectanceColor.Ph(),specularColorTexture:V};this._hasTexturesExtension(Z)&&this._exporter._materialNeedsUVsSet.add(Z),v.extensions[Tv]=h}f(v)}))}}of.RegisterExtension(Tv,(f=>new Bv(f)));const Pv="KHR_materials_transmission";class gv{constructor(f){this.name=Pv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=f}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(f,v,Z){const V=[];return Z instanceof bf.c&&this._isExtensionEnabled(Z)?(Z.subSurface.thicknessTexture&&V.push(Z.subSurface.thicknessTexture),V):V}_isExtensionEnabled(f){if(f.unlit)return!1;const v=f.subSurface;return v.isRefractionEnabled&&void 0!=v.refractionIntensity&&0!=v.refractionIntensity||this._hasTexturesExtension(f)}_hasTexturesExtension(f){return null!=f.subSurface.refractionIntensityTexture}async postExportMaterialAsync(f,v,Z){if(Z instanceof bf.c&&this._isExtensionEnabled(Z)){this._wasUsed=!0;const V=Z.subSurface,h={transmissionFactor:0===V.refractionIntensity?void 0:V.refractionIntensity};if(this._hasTexturesExtension(Z)&&this._exporter._materialNeedsUVsSet.add(Z),V.refractionIntensityTexture)if(V.useGltfStyleTextures){const f=await this._exporter._materialExporter.exportTextureAsync(V.refractionIntensityTexture,"image/png");f&&(h.transmissionTexture=f)}else q.e.Warn(`${f}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);v.extensions||(v.extensions={}),v.extensions[Pv]=h}return v}}of.RegisterExtension(Pv,(f=>new gv(f)));const wv="KHR_materials_unlit";class tv{constructor(){this.name=wv,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(f,v,Z){return new Promise((f=>{let V=!1;Z instanceof bf.c?V=Z.unlit:Z instanceof Xf.Kv&&(V=Z.disableLighting),V&&(this._wasUsed=!0,null==v.extensions&&(v.extensions={}),v.extensions[wv]={}),f(v)}))}}of.RegisterExtension(wv,(()=>new tv));const Lv="KHR_materials_volume";class Ev{constructor(f){this.name=Lv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=f}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(f,v,Z){const V=[];return Z instanceof bf.c&&this._isExtensionEnabled(Z)?(Z.subSurface.thicknessTexture&&V.push(Z.subSurface.thicknessTexture),V):V}_isExtensionEnabled(f){if(f.unlit)return!1;const v=f.subSurface;return!(!v.isRefractionEnabled&&!v.isTranslucencyEnabled)&&(void 0!=v.maximumThickness&&0!=v.maximumThickness||void 0!=v.tintColorAtDistance&&v.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=v.tintColor&&v.tintColor!=F.Mv.White()||this._hasTexturesExtension(f))}_hasTexturesExtension(f){return null!=f.subSurface.thicknessTexture}postExportMaterialAsync(f,v,Z){return new Promise((f=>{if(Z instanceof bf.c&&this._isExtensionEnabled(Z)){this._wasUsed=!0;const f=Z.subSurface,V={thicknessFactor:0==f.maximumThickness?void 0:f.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(f.thicknessTexture)??void 0,attenuationDistance:f.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:f.tintColorAtDistance,attenuationColor:f.tintColor.equalsFloats(1,1,1)?void 0:f.tintColor.Ph()};this._hasTexturesExtension(Z)&&this._exporter._materialNeedsUVsSet.add(Z),v.extensions=v.extensions||{},v.extensions[Lv]=V}f(v)}))}}of.RegisterExtension(Lv,(f=>new Ev(f)));const jv="EXT_materials_diffuse_roughness";class qv{constructor(f){this.name=jv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=f}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(f,v,Z){const V=[];return Z instanceof Ov.d&&Z._baseDiffuseRoughness?(Z._baseDiffuseRoughnessTexture&&V.push(Z._baseDiffuseRoughnessTexture),V):[]}postExportMaterialAsync(f,v,Z){return new Promise((f=>{if(Z instanceof Ov.d){if(!Z._baseDiffuseRoughness)return void f(v);this._wasUsed=!0,v.extensions=v.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(Z._baseDiffuseRoughnessTexture),h={diffuseRoughnessFactor:Z._baseDiffuseRoughness,diffuseRoughnessTexture:V??void 0};null!==h.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(Z),v.extensions[jv]=h}f(v)}))}}of.RegisterExtension(jv,(f=>new qv(f)));const cv="KHR_texture_transform";class mv{constructor(){this.name=cv,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(f,v,Z){if(Z.Yf()||h.Tools.Warn(`${f}: /*@__KEY__*/"scene" is not defined for Babylon texture ${Z.name}!`),(0!==Z.uAng||0!==Z.vAng)&&(h.Tools.Warn(`${f}: Texture ${Z.name} with rotation in the u or v axis is not supported in glTF.`),0!==Z.uRotationCenter||0!==Z.vRotationCenter))return;const V={};let J=!1;if(0===Z.uOffset&&0===Z.vOffset||(V.offset=[Z.uOffset,Z.vOffset],J=!0),1===Z.uScale&&1===Z.vScale||(V.scale=[Z.uScale,Z.vScale],J=!0),0!==Z.wAng){if(0!==Z.uRotationCenter||0!==Z.vRotationCenter){if(Z.homogeneousRotationInUVTransform&&Z.uScale!==Z.vScale)return void h.Tools.Warn(`${f}: Texture ${Z.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${cv}.`);h.Tools.Warn(`${f}: Texture ${Z.name} with non-origin rotation center will be exported using an adjusted offset with ${cv}.`),V.offset=function(f){const{uOffset:v,vOffset:Z,uRotationCenter:V,vRotationCenter:h,uScale:J,vScale:l,wAng:e}=f,C=Math.cos(e),H=Math.sin(e),O=V*J,u=h*l;return[v+(O*(1-C)+u*H),Z+(u*(1-C)-O*H)]}(Z)}V.rotation=-Z.wAng,J=!0}0!==Z.coordinatesIndex&&(V.texCoord=Z.coordinatesIndex,J=!0),J&&(this._wasUsed=!0,v.extensions||(v.extensions={}),v.extensions[cv]=V)}}of.RegisterExtension(cv,(()=>new mv));class pv{static CreateSTL(f){let v=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",h=arguments.length>3&&void 0!==arguments[3]&&arguments[3],J=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],l=arguments.length>5&&void 0!==arguments[5]&&arguments[5],e=arguments.length>6&&void 0!==arguments[6]&&arguments[6],C=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const H=function(f,v,Z){const h=[3*f[Z],3*f[Z+1],3*f[Z+2]],J=[new V.Xv(v[h[0]],v[h[0]+2],v[h[0]+1]),new V.Xv(v[h[1]],v[h[1]+2],v[h[1]+1]),new V.Xv(v[h[2]],v[h[2]+2],v[h[2]+1])],l=J[0].Fv(J[1]),e=J[2].Fv(J[1]);return{v:J,n:V.Xv.Cross(e,l).normalize()}},u=function(f,v,Z,V){return v=W(f,v,Z.x,V),v=W(f,v,Z.y,V),W(f,v,Z.z,V)},W=function(f,v,Z,V){return f.setFloat32(v,Z,V),v+4},b=function(f){if(e){let v=f;f instanceof a.c&&(v=f.sourceMesh);const Z=v.getVerticesData(O.g.PositionKind,!0,!0);if(!Z)return[];const h=V.Xv.Zero();let J;for(J=0;J<Z.length;J+=3)V.Xv.TransformCoordinatesFromFloatsToRef(Z[J],Z[J+1],Z[J+2],f.jh(!0),h).toArray(Z,J);return Z}return f.getVerticesData(O.g.PositionKind)||[]};e&&(l=!0);let X="",F=0,U=0;if(h){for(let Z=0;Z<f.length;Z++){const v=f[Z].dh();F+=v?v.length/3:0}const v=new ArrayBuffer(84+50*F);X=new DataView(v),U+=80,X.setUint32(U,F,J),U+=4}else C||(X="solid stlmesh\r\n");for(let V=0;V<f.length;V++){const v=f[V];!h&&C&&(X+="solid "+v.name+"\r\n"),!l&&v instanceof Kf.d&&v.bakeCurrentTransformIntoVertices();const Z=b(v),e=v.dh()||[];for(let f=0;f<e.length;f+=3){const v=H(e,Z,f);h?(U=u(X,U,v.n,J),U=u(X,U,v.v[0],J),U=u(X,U,v.v[1],J),U=u(X,U,v.v[2],J),U+=2):(X+="\tfacet normal "+v.n.x+" "+v.n.y+" "+v.n.z+"\r\n",X+="\t\touter loop\r\n",X+="\t\t\tvertex "+v.v[0].x+" "+v.v[0].y+" "+v.v[0].z+"\r\n",X+="\t\t\tvertex "+v.v[1].x+" "+v.v[1].y+" "+v.v[1].z+"\r\n",X+="\t\t\tvertex "+v.v[2].x+" "+v.v[2].y+" "+v.v[2].z+"\r\n",X+="\t\tendloop\r\n",X+="\tendfacet\r\n")}!h&&C&&(X+="endsolid "+name+"\r\n")}if(h||C||(X+="endsolid stlmesh"),v){const f=document.createElement("a"),v=new Blob([X],{type:"application/octet-stream"});f.href=window.URL.createObjectURL(v),f.download=Z+".stl",f.click()}return X}}function kv(f,v){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const V=[];for(let h=0;h<f.length/Z;h++){const J=f[h*Z],l=f[h*Z+1],e=f[h*Z+2];V.push(`(${J.toPrecision(v.precision)}, ${l.toPrecision(v.precision)}, ${e.toPrecision(v.precision)})`)}return V.join(", ")}function rv(f,v){const Z=[];for(let V=0;V<f.length/2;V++){const h=f[2*V],J=f[2*V+1];Z.push(`(${h.toPrecision(v.precision)}, ${(1-J).toPrecision(v.precision)})`)}return Z.join(", ")}function ov(f,v){const Z=f.getVerticesData(O.g.PositionKind),V=f.getVerticesData(O.g.NormalKind);if(Z&&V)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(f){var v;const Z=null!==(v=f.dh())&&void 0!==v&&v.length?f.getTotalIndices():f.getTotalVertices();return Array(Z/3).fill(3).join(", ")}(f)}]\n\t\tint[] faceVertexIndices = [${function(f){const v=f.dh(),Z=[];if(null!==v)for(let V=0;V<v.length;V++)Z.push(v[V]);else{const v=f.getTotalVertices();for(let f=0;f<v;f++)Z.push(f)}return Z.join(", ")}(f)}]\n\t\tnormal3f[] normals = [${kv(V,v)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${kv(Z,v)}]\n        ${function(f,v){let Z="";for(let h=0;h<4;h++){const V=h>0?h:"",J=f.getVerticesData(O.g.UVKind+(V?V+1:""));J&&(Z+=`\n\t\ttexCoord2f[] primvars:st${V} = [${rv(J,v)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const V=f.getVerticesData(O.g.ColorKind);return V&&(Z+=`\n\tcolor3f[] primvars:displayColor = [${kv(V,v,V.length/f.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),Z}(f,v)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Gv(f,v){return`\n        def "Geometry"\n        {\n        ${ov(f,v)}\n        }\n        `}function Qv(f){let v='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return v+=f,fflate.strToU8(v)}function dv(f){const v=f.m;return`( ${xv(v,0)}, ${xv(v,4)}, ${xv(v,8)}, ${xv(v,12)} )`}function xv(f,v){return`(${f[v+0]}, ${f[v+1]}, ${f[v+2]}, ${f[v+3]})`}function Rv(f){const v="Object_"+f.uniqueId,Z=function(f){const v=f.getWorldMatrix().clone(),Z=f.Yf().useRightHandedSystem;if(!Z){let V=f.parent;for(;V;){if(lf(V,Z)){v.multiplyToRef(V.getWorldMatrix().invert(),v);break}V=V.parent}}return v.determinant()<0&&h.Tools.Warn(`Exporting mesh ${f.name} with negative scale. Result may look incorrect in destination engine.`),v}(f),V=dv(Z);return`def Xform "${v}" (\n\tprepend references = @./geometries/Geometry_${f.qh.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${V}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${f.material.uniqueId}>\n}\n\n`}function nv(f){switch(f){case Y.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case Y.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case Y.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Sv(f){return`(${f.x}, ${f.y})`}function Dv(f){return`(${f.r}, ${f.g}, ${f.b})`}function fZ(f,v,Z,h,J,l){const e=f.getInternalTexture().uniqueId+"_"+f.invertY;J[e]=f;const C=f.coordinatesIndex>0?"st"+f.coordinatesIndex:"st",H=new V.Vector2(f.uScale,f.vScale),O=new V.Vector2(f.uOffset,f.vOffset),u=f.wAng,W=Math.sin(u),a=Math.cos(u);return O.y=1-O.y-H.y,O.x+=W*H.x,O.y+=(1-a)*H.y,`\n    def Shader "PrimvarReader_${Z}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${C}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${Z}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${v.uniqueId}/PrimvarReader_${Z}.outputs:result>\n        float inputs:rotation = ${(u*(180/Math.PI)).toFixed(l.precision)}\n        float2 inputs:scale = ${Sv(H)}\n        float2 inputs:translation = ${Sv(O)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${f.uniqueId}_${Z}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${e}.png@\n        float2 inputs:st.connect = </Materials/Material_${v.uniqueId}/Transform2d_${Z}.outputs:result>\n        ${h?"float4 inputs:scale = "+function(f){return`(${f.r}, ${f.g}, ${f.b}, 1.0)`}(h):""}\n        token inputs:sourceColorSpace = "${f.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${nv(f.wrapU)}"\n        token inputs:wrapT = "${nv(f.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${v.needAlphaBlending()?"float outputs:a":""}\n    }`}function vZ(f,v,Z){const V="\t\t\t",h=[],J=[],{diffuseMap:l,Me:e,alphaCutOff:C,emissiveMap:H,emissive:O,normalMap:u,roughnessMap:W,roughnessChannel:a,roughness:b,metalnessMap:X,metalnessChannel:U,metalness:K,aoMap:M,aoMapChannel:A,aoMapIntensity:s,alphaMap:z,ior:Y,clearCoatEnabled:y,clearCoat:N,clearCoatMap:i,clearCoatRoughness:I,clearCoatRoughnessMap:T}=function(f){const v={diffuseMap:null,Me:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return f instanceof Xf.Kv?{...v,diffuseMap:f.diffuseTexture,Me:f.diffuseColor,alphaCutOff:f.alphaCutOff,emissiveMap:f.emissiveTexture,emissive:f.emissiveColor,roughness:1,alphaMap:f.opacityTexture}:f instanceof Ov.d?{...v,diffuseMap:f._albedoTexture,Me:f._albedoColor,alphaCutOff:f._alphaCutOff,emissiveMap:f._emissiveTexture,emissive:f._emissiveColor,normalMap:f._bumpTexture,roughnessMap:f._metallicTexture,roughnessChannel:f._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:f._roughness??1,metalnessMap:f._metallicTexture,metalnessChannel:f._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:f._metallic??0,aoMap:f._ambientTexture,aoMapChannel:f._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:f._ambientTextureStrength,alphaMap:f._opacityTexture,ior:f.subSurface.indexOfRefraction,clearCoatEnabled:f.clearCoat.isEnabled,clearCoat:f.clearCoat.Ke,clearCoatMap:f.clearCoat.texture,clearCoatRoughness:f.clearCoat.roughness,clearCoatRoughnessMap:f.clearCoat.useRoughnessFromMainTexture?f.clearCoat.texture:f.clearCoat.textureRoughness}:v}(f);return null!==l?(h.push(`${V}color3f inputs:diffuseColor.connect = </Materials/Material_${f.uniqueId}/Texture_${l.uniqueId}_diffuse.outputs:rgb>`),f.needAlphaBlending()?h.push(`${V}float inputs:opacity.connect = </Materials/Material_${f.uniqueId}/Texture_${l.uniqueId}_diffuse.outputs:a>`):f.needAlphaTesting()&&(h.push(`${V}float inputs:opacity.connect = </Materials/Material_${f.uniqueId}/Texture_${l.uniqueId}_diffuse.outputs:a>`),h.push(`${V}float inputs:opacityThreshold = ${C}`)),J.push(fZ(l,f,"diffuse",e,v,Z))):h.push(`${V}color3f inputs:diffuseColor = ${Dv(e||F.Mv.White())}`),null!==H?(h.push(`${V}color3f inputs:emissiveColor.connect = </Materials/Material_${f.uniqueId}/Texture_${H.uniqueId}_emissive.outputs:rgb>`),J.push(fZ(H,f,"emissive",O,v,Z))):O&&O.toLuminance()>0&&h.push(`${V}color3f inputs:emissiveColor = ${Dv(O)}`),null!==u&&(h.push(`${V}normal3f inputs:normal.connect = </Materials/Material_${f.uniqueId}/Texture_${u.uniqueId}_normal.outputs:rgb>`),J.push(fZ(u,f,"normal",null,v,Z))),null!==M&&(h.push(`${V}float inputs:occlusion.connect = </Materials/Material_${f.uniqueId}/Texture_${M.uniqueId}_occlusion.outputs:${A}>`),J.push(fZ(M,f,"occlusion",new F.Mv(s,s,s),v,Z))),null!==W?(h.push(`${V}float inputs:roughness.connect = </Materials/Material_${f.uniqueId}/Texture_${W.uniqueId}_roughness.outputs:${a}>`),J.push(fZ(W,f,"roughness",new F.Mv(b,b,b),v,Z))):h.push(`${V}float inputs:roughness = ${b}`),null!==X?(h.push(`${V}float inputs:metallic.connect = </Materials/Material_${f.uniqueId}/Texture_${X.uniqueId}_metallic.outputs:${U}>`),J.push(fZ(X,f,"metallic",new F.Mv(K,K,K),v,Z))):h.push(`${V}float inputs:metallic = ${K}`),null!==z?(h.push(`${V}float inputs:opacity.connect = </Materials/Material_${f.uniqueId}/Texture_${z.uniqueId}_opacity.outputs:r>`),h.push(`${V}float inputs:opacityThreshold = 0.0001`),J.push(fZ(z,f,"opacity",null,v,Z))):h.push(`${V}float inputs:opacity = ${f.alpha}`),y&&(null!==i?(h.push(`${V}float inputs:clearcoat.connect = </Materials/Material_${f.uniqueId}/Texture_${i.uniqueId}_clearcoat.outputs:r>`),J.push(fZ(i,f,"clearcoat",new F.Mv(N,N,N),v,Z))):h.push(`${V}float inputs:clearcoat = ${N}`),null!==T?(h.push(`${V}float inputs:clearcoatRoughness.connect = </Materials/Material_${f.uniqueId}/Texture_${T.uniqueId}_clearcoatRoughness.outputs:g>`),J.push(fZ(T,f,"clearcoatRoughness",new F.Mv(I,I,I),v,Z))):h.push(`${V}float inputs:clearcoatRoughness = ${I}`)),h.push(`${V}float inputs:ior = ${Y}`),`\n\tdef Material "Material_${f.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${h.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${f.uniqueId}/PreviewSurface.outputs:surface>\n\n${J.join("\n")}\n\n\t}\n`}async function ZZ(f,v,Z){const J={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...v};"undefined"===typeof fflate&&await h.Tools.LoadScriptAsync(J.fflateUrl);const l={};l[J.modelFileName]=null;let e='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';e+=function(f){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===f.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${f.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${f.planeAnchoringAlignment}"`:""}\n            `}(J);const C={};for(const V of f.meshes){if(0===V.getTotalVertices())continue;const f=V,v=f.qh,H=f.material;if(!H||!v||Z&&!Z(f))continue;if(-1!==["Kv","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(H.getClassName())){const Z="geometries/Geometry_"+v.uniqueId+".usda";if(!(Z in l)){const f=Gv(v,J);l[Z]=Qv(f)}H.uniqueId in C||(C[H.uniqueId]=H),e+=Rv(f)}else h.Tools.Warn("USDZExportAsync does not support this material type: "+H.getClassName())}f.activeCamera&&J.exportCamera&&(e+=function(f,v){const Z="Camera_"+f.uniqueId,h=dv(V.Matrix.RotationY(Math.PI).multiply(f.getWorldMatrix()));if(f.mode===Y.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${Z}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${h}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${f.Lh.toPrecision(v.precision)}, ${f.maxZ.toPrecision(v.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(f.orthoLeft||1)+Math.abs(f.orthoRight||1))).toPrecision(v.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(f.orthoTop||1)+Math.abs(f.orthoBottom||1))).toPrecision(v.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const V=f.getEngine().getAspectRatio(f),J=v.cameraSensorWidth||35;return`def Camera "${Z}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${h}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${f.Lh.toPrecision(v.precision)}, ${f.maxZ.toPrecision(v.precision)})\n\t\t\tfloat focalLength = ${(J/(2*Math.tan(.5*f.fov))).toPrecision(v.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(J*V).toPrecision(v.precision)}\n\t\t\tfloat verticalAperture = ${(J/V).toPrecision(v.precision)}            \n\t\t}\n\t\n\t`}}(f.activeCamera,J)),e+="\n            }\n        }\n    }";const H={};e+=function(f,v,Z){const V=[];for(const h in f){const J=f[h];V.push(vZ(J,v,Z))}return`\n    def "Materials"\n{\n${V.join("")}\n}\n\n`}(C,H,J),l[J.modelFileName]=fflate.strToU8(e);for(const V in H){const f=H[V],v=f.getSize(),Z=await f.readPixels();if(!Z)throw new Error("Texture data is not available");const h=await y.DumpTools.DumpDataAsync(v.width,v.height,Z,"image/png",void 0,!1,!0);l[`textures/Texture_${V}.png`]=new Uint8Array(h).slice()}let O=0;for(const V in l){const f=l[V];if(!f)continue;O+=34+V.length;const v=63&O;if(4!==v){const Z=new Uint8Array(64-v);l[V]=[f,{extra:{12345:Z}}]}O=f.length}return fflate.zipSync(l,{level:0})}}}]);