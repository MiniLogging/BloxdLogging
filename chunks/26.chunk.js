"use strict";(self.kdlk57exiqh=self.kdlk57exiqh||[]).push([[26],{12626:(i,x,e)=>{e.r(x),e.d(x,{EXT_materials_diffuse_roughness:()=>px,EXT_mesh_gpu_instancing:()=>ci,GLTF2Export:()=>yi,GLTFData:()=>b,KHR_draco_mesh_compression:()=>ex,KHR_lights_punctual:()=>ux,KHR_materials_anisotropy:()=>Ax,KHR_materials_clearcoat:()=>Lx,KHR_materials_diffuse_transmission:()=>zx,KHR_materials_dispersion:()=>Qx,KHR_materials_emissive_strength:()=>Vx,KHR_materials_ior:()=>fx,KHR_materials_iridescence:()=>Ox,KHR_materials_sheen:()=>Zx,KHR_materials_specular:()=>kx,KHR_materials_transmission:()=>me,KHR_materials_unlit:()=>Cx,KHR_materials_volume:()=>Ix,KHR_texture_transform:()=>Ux,OBJExport:()=>Y,STLExport:()=>Dx,USDZExportAsync:()=>xe,_ConvertToGLTFPBRMetallicRoughness:()=>X,_SolveMetallic:()=>mi,__IGLTFExporterExtension:()=>J});var j=e(12250),E=e(12061),a=e(12539);class Y{static OBJ(i,x,e,Y){const J=[];let u=1,b=1;x&&(e||(e="mat"),J.push("mtllib "+e+".mtl"));for(let g=0;g<i.length;g++){const e=i[g],A=e.name||`mesh${g}}`;J.push(`o ${A}`);let K=null;if(Y){const i=e.Re(!0);K=new j.Matrix,i.invertToRef(K),e.bakeTransformIntoVertices(i)}if(x){const i=e.material;i&&J.push("usemtl "+i.id)}const L=e.ye;if(!L){E.Tools.Warn("No geometry is present on the mesh");continue}const o=L.getVerticesData("position"),M=L.getVerticesData("normal"),z=L.getVerticesData("uv"),T=L.Pe();let Q=0,t=0;if(!o||!T){E.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const V=i[0].wi().useRightHandedSystem?1:-1;for(let i=0;i<o.length;i+=3)J.push("v "+o[i]*V+" "+o[i+1]+" "+o[i+2]),Q++;if(null!=M)for(let i=0;i<M.length;i+=3)J.push("vn "+M[i]*V+" "+M[i+1]+" "+M[i+2]);if(null!=z)for(let i=0;i<z.length;i+=2)J.push("vt "+z[i]+" "+z[i+1]),t++;const S=["","",""],f=(e.material||e.wi().defaultMaterial)._getEffectiveOrientation(e),[w,O]=f===a.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let i=0;i<T.length;i+=3){const x=[String(T[i]+u),String(T[i+w]+u),String(T[i+O]+u)],e=[String(T[i]+b),String(T[i+w]+b),String(T[i+O]+b)],j=x,E=null!=z?e:S,a=null!=M?x:S;J.push("f "+j[0]+"/"+E[0]+"/"+a[0]+" "+j[1]+"/"+E[1]+"/"+a[1]+" "+j[2]+"/"+E[2]+"/"+a[2])}Y&&K&&e.bakeTransformIntoVertices(K),u+=Q,b+=t}return J.join("\n")}static MTL(i){const x=[],e=i.material;x.push("newmtl mat1"),x.push("  Ns "+e.specularPower.toFixed(4)),x.push("  Ni 1.5000"),x.push("  d "+e.alpha.toFixed(4)),x.push("  Tr 0.0000"),x.push("  Tf 1.0000 1.0000 1.0000"),x.push("  illum 2"),x.push("  Ka "+e.ambientColor.r.toFixed(4)+" "+e.ambientColor.g.toFixed(4)+" "+e.ambientColor.b.toFixed(4)),x.push("  Kd "+e.diffuseColor.r.toFixed(4)+" "+e.diffuseColor.g.toFixed(4)+" "+e.diffuseColor.b.toFixed(4)),x.push("  Ks "+e.specularColor.r.toFixed(4)+" "+e.specularColor.g.toFixed(4)+" "+e.specularColor.b.toFixed(4)),x.push("  Ke "+e.emissiveColor.r.toFixed(4)+" "+e.emissiveColor.g.toFixed(4)+" "+e.emissiveColor.b.toFixed(4));e.ambientTexture&&x.push("  map_Ka "+e.ambientTexture.name),e.diffuseTexture&&x.push("  map_Kd "+e.diffuseTexture.name),e.specularTexture&&x.push("  map_Ks "+e.specularTexture.name),e.bumpTexture&&x.push("  map_bump -imfchan z "+e.bumpTexture.name),e.opacityTexture&&x.push("  map_d "+e.opacityTexture.name);return x.join("\n")}}var J=0,u=e(12115);class b{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const i in this.files){const x=this.files[i],e=new Blob([x],{type:(0,u.j)(i)});E.Tools.Download(e,i)}}}var g=e(12314),A=e(12633),K=e(12648),L=e(12672),o=e(12363),M=e(12108),z=e(12286),T=e(12264);const Q=T.HighestCommonFactor,t={...T,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:Q};var V=e(12442),S=e(12227),f=e(12702),w=e(12710),O=e(12439);const l=1e-6,Z=new z.MJ(.04,.04,.04),B=1024,k=z.MJ.White(),N=z.MJ.Black();function mi(i,x,e){if(x<Z.r)return 0;const j=Z.r,E=i*e/(1-Z.r)+x-2*Z.r,a=E*E-4*j*(Z.r-x);return t.Clamp((-E+Math.sqrt(a))/(2*j),0,1)}function X(i){const x=i.diffuseColor.toLinearSpace(i.wi().getEngine().useExactSrgbConversions).scale(.5),e=i.alpha,E=function(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new j.Vector2(0,1),e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new j.Vector2(0,.1),E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new j.Vector2(0,.1),a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new j.Vector2(1300,.1);return function(i,x,e,j,E){return(1-i)*(1-i)*(1-i)*x+3*(1-i)*(1-i)*i*e+3*(1-i)*i*i*j+i*i*i*E}(Math.pow(i/a.x,.333333),x.y,e.y,E.y,a.y)}(t.Clamp(i.specularPower,0,B));return{baseColorFactor:[x.r,x.g,x.b,e],metallicFactor:0,roughnessFactor:E}}function C(i,x){x.needAlphaBlending()?i.alphaMode="BLEND":x.needAlphaTesting()&&(i.alphaMode="MASK",i.alphaCutoff=x.alphaCutOff)}function n(i,x,e){const j=new Uint8Array(i*x*4);for(let E=0;E<j.length;E+=4)j[E]=j[E+1]=j[E+2]=j[E+3]=255;return f.e.CreateRGBATexture(j,i,x,e)}function I(i){if(i instanceof Uint8Array){const x=i.length,e=new Float32Array(i.length);for(let j=0;j<x;++j)e[j]=i[j]/255;return e}if(i instanceof Float32Array)return i;throw new Error("Unsupported pixel format!")}class d{constructor(i){this._exporter=i,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(i){return i?this._textureMap.get(i)??null:null}async exportStandardMaterialAsync(i,x,e){const j=X(i),a={name:i.name};if(null==i.qe||i.qe||(i.twoSidedLighting||E.Tools.Warn(i.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),a.doubleSided=!0),e){const e=[],E=i.diffuseTexture;E&&e.push(this.exportTextureAsync(E,x).then((i=>{i&&(j.baseColorTexture=i)})));const Y=i.bumpTexture;Y&&e.push(this.exportTextureAsync(Y,x).then((i=>{i&&(a.normalTexture=i,1!==Y.level&&(a.normalTexture.scale=Y.level))})));const J=i.emissiveTexture;J&&(a.emissiveFactor=[1,1,1],e.push(this.exportTextureAsync(J,x).then((i=>{i&&(a.emissiveTexture=i)}))));const u=i.ambientTexture;u&&e.push(this.exportTextureAsync(u,x).then((i=>{if(i){const x={index:i.index};a.occlusionTexture=x}}))),e.length>0&&(this._exporter._materialNeedsUVsSet.add(i),await Promise.all(e))}(i.alpha<1||i.opacityTexture)&&(i.alphaMode===w.b.ALPHA_COMBINE?a.alphaMode="BLEND":E.Tools.Warn(i.name+": glTF 2.0 does not support alpha mode: "+i.alphaMode.toString())),i.emissiveColor&&!i.emissiveColor.equalsWithEpsilon(N,l)&&(a.emissiveFactor=i.emissiveColor.de()),a.pbrMetallicRoughness=j,C(a,i),await this._finishMaterialAsync(a,i,x);const Y=this._exporter._materials;return Y.push(a),Y.length-1}async _finishMaterialAsync(i,x,e){const j=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",i,x),E=[];for(const a of j)E.push(this.exportTextureAsync(a,e));await Promise.all(E),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",i,x)}async _getImageDataAsync(i,x,j,E){const a=w.b.TEXTURETYPE_UNSIGNED_BYTE,Y=this._exporter._babylonScene,J=Y.getEngine(),u=J.createRawTexture(i,x,j,w.b.TEXTUREFORMAT_RGBA,!1,!0,S.d.NEAREST_SAMPLINGMODE,null,a);J.isWebGPU?await e.e(51).then(e.bind(e,14652)):await e.e(52).then(e.bind(e,14656)),await V.i.ApplyPostProcess("pass",u,Y,a,w.b.TEXTURE_NEAREST_SAMPLINGMODE,w.b.TEXTUREFORMAT_RGBA);const b=await J._readTexturePixels(u,x,j);return await O.DumpTools.DumpDataAsync(x,j,b,E,void 0,!0,!0)}_resizeTexturesToSameDimensions(i,x,e){const j=i?i.getSize():{width:0,height:0},E=x?x.getSize():{width:0,height:0};let a,Y;return j.width<E.width?(a=i&&i instanceof S.d?V.i.CreateResizedCopy(i,E.width,E.height,!0):n(E.width,E.height,e),Y=x):j.width>E.width?(Y=x&&x instanceof S.d?V.i.CreateResizedCopy(x,j.width,j.height,!0):n(j.width,j.height,e),a=i):(a=i,Y=x),{texture1:a,texture2:Y}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(i,x,e,j){const E=new Array;if(!i&&!x)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const a=i?i.wi():x?x.wi():null;if(a){var Y;const J=this._resizeTexturesToSameDimensions(i,x,a),u=null===(Y=J.texture1)||void 0===Y?void 0:Y.getSize();let b,g;const A=u.width,K=u.height,L=await J.texture1.readPixels(),o=await J.texture2.readPixels();if(!L)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(b=I(L),!o)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");g=I(o);const M=g.byteLength,T=new Uint8Array(M),Q=new Uint8Array(M),t=4,V=N;let S=0,f=0;for(let i=0;i<K;++i)for(let x=0;x<A;++x){const j=(A*i+x)*t,E={diffuseColor:new z.MJ(b[j],b[j+1],b[j+2]).toLinearSpace(a.getEngine().useExactSrgbConversions).multiply(e.diffuseColor),specularColor:new z.MJ(g[j],g[j+1],g[j+2]).toLinearSpace(a.getEngine().useExactSrgbConversions).multiply(e.specularColor),glossiness:g[j+3]*e.glossiness},Y=this._convertSpecularGlossinessToMetallicRoughness(E);V.r=Math.max(V.r,Y.baseColor.r),V.g=Math.max(V.g,Y.baseColor.g),V.b=Math.max(V.b,Y.baseColor.b),S=Math.max(S,Y.metallic),f=Math.max(f,Y.roughness),Q[j]=255*Y.baseColor.r,Q[j+1]=255*Y.baseColor.g,Q[j+2]=255*Y.baseColor.b,Q[j+3]=J.texture1.He?255*b[j+3]:255,T[j]=0,T[j+1]=255*Y.roughness,T[j+2]=255*Y.metallic,T[j+3]=255}const w={baseColor:V,metallic:S,roughness:f};let O=!1,Z=!1;for(let i=0;i<K;++i)for(let x=0;x<A;++x){const e=(A*i+x)*t;Q[e]/=w.baseColor.r>l?w.baseColor.r:1,Q[e+1]/=w.baseColor.g>l?w.baseColor.g:1,Q[e+2]/=w.baseColor.b>l?w.baseColor.b:1;const j=z.MJ.FromInts(Q[e],Q[e+1],Q[e+2]).toGammaSpace(a.getEngine().useExactSrgbConversions);Q[e]=255*j.r,Q[e+1]=255*j.g,Q[e+2]=255*j.b,j.equalsWithEpsilon(k,l)||(Z=!0),T[e+1]/=w.roughness>l?w.roughness:1,T[e+2]/=w.metallic>l?w.metallic:1;z.MJ.FromInts(255,T[e+1],T[e+2]).equalsWithEpsilon(k,l)||(O=!0)}return O&&E.push(this._getImageDataAsync(T,A,K,j).then((i=>{w.metallicRoughnessTextureData=i}))),Z&&E.push(this._getImageDataAsync(Q,A,K,j).then((i=>{w.baseColorTextureData=i}))),await Promise.all(E).then((()=>w))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(i){const x=this._getPerceivedBrightness(i.diffuseColor),e=this._getPerceivedBrightness(i.specularColor),j=1-this._getMaxComponent(i.specularColor),E=mi(x,e,j),a=i.diffuseColor.scale(j/(1-Z.r)/Math.max(1-E)),Y=i.specularColor.Cx(Z.scale(1-E)).scale(1/Math.max(E));let J=z.MJ.Lerp(a,Y,E*E);J=J.clampToRef(0,1,J);return{baseColor:J,metallic:E,roughness:1-i.glossiness}}_getPerceivedBrightness(i){return i?Math.sqrt(.299*i.r*i.r+.587*i.g*i.g+.114*i.b*i.b):0}_getMaxComponent(i){return i?Math.max(i.r,Math.max(i.g,i.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(i,x,e,j){const E=[],a={baseColor:i._albedoColor,metallic:i._metallic,roughness:i._roughness};if(j){i._albedoTexture&&E.push(this.exportTextureAsync(i._albedoTexture,x).then((i=>{i&&(e.baseColorTexture=i)})));const j=i._metallicTexture;j&&E.push(this.exportTextureAsync(j,x).then((i=>{i&&(e.metallicRoughnessTexture=i)})))}return E.length>0&&(this._exporter._materialNeedsUVsSet.add(i),await Promise.all(E)),a}_getTextureSampler(i){const x={};if(!i||!(i instanceof S.d))return x;const e=this._getGLTFTextureWrapMode(i.wrapU);10497!==e&&(x.wrapS=e);const j=this._getGLTFTextureWrapMode(i.wrapV);switch(10497!==j&&(x.wrapT=j),i.samplingMode){case S.d.LINEAR_LINEAR:x.magFilter=9729,x.minFilter=9729;break;case S.d.LINEAR_NEAREST:x.magFilter=9729,x.minFilter=9728;break;case S.d.NEAREST_LINEAR:x.magFilter=9728,x.minFilter=9729;break;case S.d.NEAREST_LINEAR_MIPLINEAR:x.magFilter=9728,x.minFilter=9987;break;case S.d.NEAREST_NEAREST:x.magFilter=9728,x.minFilter=9728;break;case S.d.NEAREST_LINEAR_MIPNEAREST:x.magFilter=9728,x.minFilter=9985;break;case S.d.LINEAR_NEAREST_MIPNEAREST:x.magFilter=9729,x.minFilter=9984;break;case S.d.LINEAR_NEAREST_MIPLINEAR:x.magFilter=9729,x.minFilter=9986;break;case S.d.NEAREST_NEAREST_MIPLINEAR:x.magFilter=9728,x.minFilter=9986;break;case S.d.LINEAR_LINEAR_MIPLINEAR:x.magFilter=9729,x.minFilter=9987;break;case S.d.LINEAR_LINEAR_MIPNEAREST:x.magFilter=9729,x.minFilter=9985;break;case S.d.NEAREST_NEAREST_MIPNEAREST:x.magFilter=9728,x.minFilter=9984}return x}_getGLTFTextureWrapMode(i){switch(i){case S.d.WRAP_ADDRESSMODE:return 10497;case S.d.CLAMP_ADDRESSMODE:return 33071;case S.d.MIRROR_ADDRESSMODE:return 33648;default:return E.Tools.Error(`Unsupported Texture Wrap Mode ${i}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(i,x,e,j){const E={diffuseColor:i._albedoColor,specularColor:i._reflectivityColor,glossiness:i._microSurface},a=i._albedoTexture,Y=i._reflectivityTexture,J=i._useMicroSurfaceFromReflectivityMapAlpha;if(Y&&!J)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((a||Y)&&j){this._exporter._materialNeedsUVsSet.add(i);const j=this._exportTextureSampler(a||Y),J=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(a,Y,E,x),u=this._exporter._textures;if(J.baseColorTextureData){const i=this._exportImage(`baseColor${u.length}`,x,J.baseColorTextureData);e.baseColorTexture=this._exportTextureInfo(i,j,null===a||void 0===a?void 0:a.coordinatesIndex)}if(J.metallicRoughnessTextureData){const i=this._exportImage(`metallicRoughness${u.length}`,x,J.metallicRoughnessTextureData);e.metallicRoughnessTexture=this._exportTextureInfo(i,j,null===Y||void 0===Y?void 0:Y.coordinatesIndex)}return J}return this._convertSpecularGlossinessToMetallicRoughness(E)}async exportPBRMaterialAsync(i,x,e){const j={},E={name:i.name},a=i.isMetallicWorkflow();if(a){const x=i._albedoColor,e=i.alpha;x&&(j.baseColorFactor=[x.r,x.g,x.b,e])}const Y=a?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(i,x,j,e):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(i,x,j,e);await this._setMetallicRoughnessPbrMaterialAsync(Y,i,E,j,x,e),await this._finishMaterialAsync(E,i,x);const J=this._exporter._materials;return J.push(E),J.length-1}async _setMetallicRoughnessPbrMaterialAsync(i,x,e,j,a,Y){if(C(e,x),i.baseColor.equalsWithEpsilon(k,l)&&t.WithinEpsilon(x.alpha,1,l)||(j.baseColorFactor=[i.baseColor.r,i.baseColor.g,i.baseColor.b,x.alpha]),null!=i.metallic&&1!==i.metallic&&(j.metallicFactor=i.metallic),null!=i.roughness&&1!==i.roughness&&(j.roughnessFactor=i.roughness),null==x.qe||x.qe||(x._twoSidedLighting||E.Tools.Warn(x.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),e.doubleSided=!0),Y){const i=[],j=x._bumpTexture;j&&i.push(this.exportTextureAsync(j,a).then((i=>{i&&(e.normalTexture=i,1!==j.level&&(e.normalTexture.scale=j.level))})));const E=x._ambientTexture;E&&i.push(this.exportTextureAsync(E,a).then((i=>{if(i){const j={index:i.index,texCoord:i.texCoord,extensions:i.extensions};e.occlusionTexture=j;const E=x._ambientTextureStrength;E&&(j.strength=E)}})));const Y=x._emissiveTexture;Y&&i.push(this.exportTextureAsync(Y,a).then((i=>{i&&(e.emissiveTexture=i)}))),i.length>0&&(this._exporter._materialNeedsUVsSet.add(x),await Promise.all(i))}const J=x._emissiveColor;J.equalsWithEpsilon(N,l)||(e.emissiveFactor=J.de()),e.pbrMetallicRoughness=j}_getPixelsFromTextureAsync(i){return function(i){switch(i){case w.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case w.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case w.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case w.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case w.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case w.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case w.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case w.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case w.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case w.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case w.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case w.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case w.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case w.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case w.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case w.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case w.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case w.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case w.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case w.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case w.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(i.textureFormat)?(0,V.f)(i,i._texture.width,i._texture.height):(i.textureType,w.b.TEXTURETYPE_UNSIGNED_BYTE,i.readPixels())}async exportTextureAsync(i,x){const e=this._exporter._extensionsPreExportTextureAsync("exporter",i,x);return e?await e.then((async e=>e?await this._exportTextureInfoAsync(e,x):await this._exportTextureInfoAsync(i,x))):await this._exportTextureInfoAsync(i,x)}async _exportTextureInfoAsync(i,x){let e=this._textureMap.get(i);if(!e){const j=await this._getPixelsFromTextureAsync(i);if(!j)return null;const a=this._exportTextureSampler(i),Y=i.mimeType;if(Y)switch(Y){case"image/jpeg":case"image/png":case"image/webp":x=Y;break;default:E.Tools.Warn(`Unsupported media type: ${Y}. Exporting texture as PNG.`)}const J=this._internalTextureToImage,u=i.getInternalTexture().uniqueId;J[u]||(J[u]={});let b=J[u][x];if(void 0===b){const e=i.getSize();b=(async()=>{const E=await this._getImageDataAsync(j,e.width,e.height,x);return this._exportImage(i.name,x,E)})(),J[u][x]=b}e=this._exportTextureInfo(await b,a,i.coordinatesIndex),this._textureMap.set(i,e),this._exporter._extensionsPostExportTextures("exporter",e,i)}return e}_exportImage(i,x,e){const j=this._exporter._images;let a;if(this._exporter._shouldUseGlb){a={name:i,mimeType:x,bufferView:void 0};const j=this._exporter._bufferManager.createBufferView(new Uint8Array(e));this._exporter._bufferManager.setBufferView(a,j)}else{const Y=i.replace(/\.\/|\/|\.\\|\\/g,"_"),J=function(i){switch(i){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(x);let u=Y+J;j.some((i=>i.uri===u))&&(u=`${Y}_${E.Tools.RandomId()}${J}`),a={name:i,uri:u},this._exporter._imageData[u]={data:e,mimeType:x}}return j.push(a),j.length-1}_exportTextureInfo(i,x,e){const j=this._exporter._textures;let E=j.findIndex((e=>e.sampler==x&&e.source===i));-1===E&&(E=j.length,j.push({source:i,sampler:x}));const a={index:E};return e&&(a.texCoord=e),a}_exportTextureSampler(i){const x=this._getTextureSampler(i),e=this._exporter._samplers,j=e.findIndex((i=>i.minFilter===x.minFilter&&i.magFilter===x.magFilter&&i.wrapS===x.wrapS&&i.wrapT===x.wrapT));return-1!==j?j:(e.push(x),e.length-1)}}var p=e(12320),H=e(12072),U=e(12717),D=e(12253);const h=j.KJ.Zero(),F=j.Quaternion.Identity(),R=j.KJ.One(),y=new j.KJ(-1,1,1);function r(i,x){const{byteOffset:e,byteStride:j,type:E,normalized:a}=i,Y=i.getSize(),J=x.reduce(((i,x)=>x.getTotalVertices()>i?x.getTotalVertices():i),-Number.MAX_VALUE);return{byteOffset:e,byteStride:j,componentCount:Y,type:E,count:J*Y,normalized:a,totalVertices:J,kind:i.getKind()}}function c(i){switch(i){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function P(i){switch(i){case g.f.PositionKind:case g.f.NormalKind:case g.f.TangentKind:case g.f.ColorKind:case g.f.MatricesIndicesKind:case g.f.MatricesIndicesExtraKind:case g.f.MatricesWeightsKind:case g.f.MatricesWeightsExtraKind:case g.f.UVKind:case g.f.UV2Kind:case g.f.UV3Kind:case g.f.UV4Kind:case g.f.UV5Kind:case g.f.UV6Kind:return!0}return!1}function q(i){switch(i){case a.e.TriangleFillMode:return 4;case a.e.TriangleStripDrawMode:return 5;case a.e.TriangleFanDrawMode:return 6;case a.e.PointListDrawMode:case a.e.PointFillMode:return 0;case a.e.LineLoopDrawMode:return 2;case a.e.LineListDrawMode:return 1;case a.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${i}`)}function W(i){const x=Math.sqrt(i.x*i.x+i.y*i.y+i.z*i.z);x>0&&(i.x/=x,i.y/=x,i.z/=x)}function G(i){return i.x*=-1,i}function v(i){if(i.x*i.x+i.y*i.y>.5){const x=Math.abs(i.x),e=Math.abs(i.y);if(x>e){const e=Math.sign(i.x);i.x=x,i.y*=-e,i.z*=-e,i.w*=e}else{const x=Math.sign(i.y);i.x*=-x,i.y=e,i.z*=x,i.w*=-x}}else{const x=Math.abs(i.z),e=Math.abs(i.w);if(x>e){const e=Math.sign(i.z);i.x*=-e,i.y*=e,i.z=x,i.w*=-e}else{const x=Math.sign(i.w);i.x*=x,i.y*=-x,i.z*=-x,i.w=e}}return i}function s(i){i.fJ(-i.z,i.w,i.x,-i.y)}function ii(i,x){const e=j.KJ.FromArrayToRef(x.translation||[0,0,0],0,j.TmpVectors.KJ[0]),E=j.Quaternion.FromArrayToRef(x.rotation||[0,0,0,1],0,j.TmpVectors.Quaternion[0]),a=j.Matrix.ComposeToRef(R,E,e,j.TmpVectors.Matrix[0]),Y=j.KJ.FromArrayToRef(i.translation||[0,0,0],0,j.TmpVectors.KJ[2]),J=j.Quaternion.FromArrayToRef(i.rotation||[0,0,0,1],0,j.TmpVectors.Quaternion[1]),u=j.Matrix.ComposeToRef(R,J,Y,j.TmpVectors.Matrix[1]);a.multiplyToRef(u,u),u.decompose(void 0,E,e),e.equalsWithEpsilon(h,D.e)?delete x.translation:x.translation=e.de(),E.equalsWithEpsilon(F,D.e)?delete x.rotation:x.rotation=E.de(),x.scale&&delete x.scale}function xi(i,x){if(!(x instanceof A.d))return!1;if(!(1===x.getChildren().length&&0===i.getChildren().length&&i.parent===x))return!1;const e=i.wi(),j=i instanceof U.d&&!e.useRightHandedSystem?y:R;return!!x.wJ.equalsWithEpsilon(j,D.e)||(H.c.Warn(`Cannot collapse node ${i.name} into parent node ${x.name} with modified scaling.`),!1)}function ei(i){if(i instanceof Array){const x=new Float32Array(i);return new Uint8Array(x.buffer,x.byteOffset,x.byteLength)}return ArrayBuffer.isView(i)?new Uint8Array(i.buffer,i.byteOffset,i.byteLength):new Uint8Array(i)}function ji(i,x){for(const[e,j]of Object.entries(i)){const E=x[e];(Array.isArray(j)&&Array.isArray(E)&&Ei(j,E)||j===E)&&delete i[e]}return i}function Ei(i,x){return i.length===x.length&&i.every(((i,e)=>i===x[e]))}const ai=j.Matrix.Compose(new j.KJ(-1,1,1),j.Quaternion.Identity(),j.KJ.Zero());function Yi(i,x){if(!(i instanceof A.d))return!1;if(x){if(!i.getWorldMatrix().equalsWithEpsilon(j.Matrix.IdentityReadOnly,D.e))return!1}else{if(!i.getWorldMatrix().multiplyToRef(ai,j.TmpVectors.Matrix[0]).equalsWithEpsilon(j.Matrix.IdentityReadOnly,D.e))return!1}return!(i instanceof K.e&&i.ye)}const Ji=new Map([[Int8Array,(i,x,e)=>i.setInt8(x,e)],[Uint8Array,(i,x,e)=>i.setUint8(x,e)],[Uint8ClampedArray,(i,x,e)=>i.setUint8(x,e)],[Int16Array,(i,x,e)=>i.setInt16(x,e,!0)],[Uint16Array,(i,x,e)=>i.setUint16(x,e,!0)],[Int32Array,(i,x,e)=>i.setInt32(x,e,!0)],[Uint32Array,(i,x,e)=>i.setUint32(x,e,!0)],[Float32Array,(i,x,e)=>i.setFloat32(x,e,!0)],[Float64Array,(i,x,e)=>i.setFloat64(x,e,!0)]]);class ui{writeTypedArray(i){this._checkGrowBuffer(i.byteLength);const x=Ji.get(i.constructor);for(let e=0;e<i.length;e++)x(this._dataView,this._byteOffset,i[e]),this._byteOffset+=i.BYTES_PER_ELEMENT}constructor(i){this._data=new Uint8Array(i),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(i){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,i),this._byteOffset++}writeInt8(i){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,i),this._byteOffset++}writeInt16(i){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,i,!0),this._byteOffset+=2}writeUInt16(i){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,i,!0),this._byteOffset+=2}writeInt32(i){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,i,!0),this._byteOffset+=4}writeUInt32(i){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,i,!0),this._byteOffset+=4}writeFloat32(i){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,i,!0),this._byteOffset+=4}writeFloat64(i){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,i,!0),this._byteOffset+=8}_checkGrowBuffer(i){const x=this.byteOffset+i;if(x>this._data.byteLength){const i=new Uint8Array(2*x);i.set(this._data),this._data=i,this._dataView=new DataView(this._data.buffer)}}}function bi(i){return i%4===0?4:i%2===0?2:1}class gi{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(i){let x=0;this._bufferViewToData.forEach((i=>{x+=i.byteLength}));const e=new ui(x),j=Array.from(this._bufferViewToData.keys()).sort(((i,x)=>bi(x.byteLength)-bi(i.byteLength)));for(const E of j){E.byteOffset=e.byteOffset,i.push(E);const x=i.length-1,j=this.getPropertiesWithBufferView(E);for(const i of j)i.bufferView=x;e.writeTypedArray(this._bufferViewToData.get(E)),this._bufferViewToData.delete(E)}return e.getOutputData()}createBufferView(i,x){const e={buffer:0,byteOffset:void 0,byteLength:i.byteLength,byteStride:x};return this._bufferViewToData.set(e,i),e}createAccessor(i,x,e,j,E,a,Y){this._verifyBufferView(i);const J={bufferView:void 0,componentType:e,count:j,type:x,min:null===a||void 0===a?void 0:a.min,max:null===a||void 0===a?void 0:a.max,normalized:Y,byteOffset:E};return this.setBufferView(J,i),this._accessorToBufferView.set(J,i),J}setBufferView(i,x){this._verifyBufferView(x);this.getPropertiesWithBufferView(x).push(i)}removeBufferView(i){const x=this.getPropertiesWithBufferView(i);for(const e of x)void 0!==e.bufferView&&delete e.bufferView;this._bufferViewToData.delete(i),this._bufferViewToProperties.delete(i),this._accessorToBufferView.forEach(((x,e)=>{x===i&&(void 0!==e.byteOffset&&delete e.byteOffset,this._accessorToBufferView.delete(e))}))}getBufferView(i){const x=this._accessorToBufferView.get(i);return this._verifyBufferView(x),x}getPropertiesWithBufferView(i){return this._verifyBufferView(i),this._bufferViewToProperties.set(i,this._bufferViewToProperties.get(i)??[]),this._bufferViewToProperties.get(i)}getData(i){return this._verifyBufferView(i),this._bufferViewToData.get(i)}_verifyBufferView(i){if(void 0===i||!this._bufferViewToData.has(i))throw new Error(`BufferView ${i} not found in BufferManager.`)}}var Ai,Ki=e(12677),Li=e(12698),oi=e(12722),Mi=e(12583),zi=e(12753),Ti=e(12765),Qi=e(12675),ti=e(12773);!function(i){i[i.INTANGENT=0]="INTANGENT",i[i.OUTTANGENT=1]="OUTTANGENT"}(Ai||(Ai={}));class Vi{static _IsTransformable(i){return i&&(i instanceof A.d||i instanceof Ki.b||i instanceof ti.e)}static _CreateNodeAnimation(i,x,e,j,a){if(this._IsTransformable(i)){const Y=[],J=[],u=x.getKeys(),b=Vi._CalculateMinMaxKeyFrames(u),g=Vi._DeduceInterpolation(u,e,j),A=g.interpolationType,K=g.shouldBakeAnimation;if(K?Vi._CreateBakedAnimation(i,x,e,b.min,b.max,x.framePerSecond,a,Y,J,b,j):"LINEAR"===A||"STEP"===A?Vi._CreateLinearOrStepAnimation(i,x,e,Y,J,j):"CUBICSPLINE"===A?Vi._CreateCubicSplineAnimation(i,x,e,Y,J,j):Vi._CreateBakedAnimation(i,x,e,b.min,b.max,x.framePerSecond,a,Y,J,b,j),Y.length&&J.length){return{inputs:Y,outputs:J,samplerInterpolation:A,inputsMin:K?b.min:E.Tools.FloatRound(b.min/x.framePerSecond),inputsMax:K?b.max:E.Tools.FloatRound(b.max/x.framePerSecond)}}}return null}static _DeduceAnimationInfo(i){let x=null,e="VEC3",j=!1;const a=i.targetProperty.split(".");switch(a[0]){case"wJ":x="scale";break;case"position":x="translation";break;case"rotation":e="VEC4",x="rotation";break;case"rotationQuaternion":e="VEC4",j=!0,x="rotation";break;case"influence":e="SCALAR",x="weights";break;default:E.Tools.Error(`Unsupported animatable property ${a[0]}`)}return x?{animationChannelTargetPath:x,dataAccessorType:e,useQuaternion:j}:(E.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(i,x,e,j,E,a,Y,J,u,b,g){let A;if(Vi._IsTransformable(i)&&i.animations)for(const K of i.animations){if(g&&!g(K))continue;const E=Vi._DeduceAnimationInfo(K);E&&(A={name:K.name,samplers:[],channels:[]},Vi._AddAnimation(`${K.name}`,K.hasRunningRuntimeAnimations?x:A,i,K,E.dataAccessorType,E.animationChannelTargetPath,j,a,Y,J,E.useQuaternion,u,b),A.samplers.length&&A.channels.length&&e.push(A))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(i,x,e,j,E,a,Y,J,u,b,g){let A;if(i instanceof Qi.c){const E=i.morphTargetManager;if(E)for(let K=0;K<E.numTargets;++K){const L=E.getTarget(K);for(const o of L.animations){if(g&&!g(o))continue;const L=new zi.c(`${o.name}`,"influence",o.framePerSecond,o.dataType,o.loopMode,o.enableBlending),M=[],z=o.getKeys();for(let i=0;i<z.length;++i){const x=z[i];for(let i=0;i<E.numTargets;++i)i==K?M.push(x):M.push({frame:x.frame,value:0})}L.setKeys(M);const T=Vi._DeduceAnimationInfo(L);T&&(A={name:L.name,samplers:[],channels:[]},Vi._AddAnimation(o.name,o.hasRunningRuntimeAnimations?x:A,i,L,T.dataAccessorType,T.animationChannelTargetPath,j,a,Y,J,T.useQuaternion,u,b,E.numTargets),A.samplers.length&&A.channels.length&&e.push(A))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(i,x,e,j,E,a,Y,J,u){let b;if(i.animationGroups){const A=i.animationGroups;for(const K of A){const A=new Map,L=new Map,o=new Set,M=K.to-K.from;b={name:K.name,channels:[],samplers:[]};for(let x=0;x<K.targetedAnimations.length;++x){const M=K.targetedAnimations[x],z=M.target,T=M.animation;if(u&&!u(T))continue;const Q=J.has(z);if(this._IsTransformable(z)||1===z.length&&this._IsTransformable(z[0])){const i=Vi._DeduceAnimationInfo(M.animation);if(i){const x=this._IsTransformable(z)?z:this._IsTransformable(z[0])?z[0]:null;x&&Vi._AddAnimation(`${T.name}`,b,x,T,i.dataAccessorType,i.animationChannelTargetPath,e,j,E,a,i.useQuaternion,Y,Q)}}else if(z instanceof Ti.c||1===z.length&&z[0]instanceof Ti.c){if(Vi._DeduceAnimationInfo(M.animation)){const x=z instanceof Ti.c?z:z[0];if(x){const e=i.morphTargetManagers.find((i=>{for(let e=0;e<i.numTargets;++e)if(i.getTarget(e)===x)return!0;return!1}));if(e){const j=i.meshes.find((i=>i.morphTargetManager===e));var g;if(j)A.has(j)||A.set(j,new Map),null===(g=A.get(j))||void 0===g||g.set(x,T),o.add(j),L.set(j,T)}}}}}o.forEach((i=>{const x=i.morphTargetManager;let J=null;const u=[],g=L.get(i).getKeys(),o=g.length;for(let e=0;e<o;++e)for(let j=0;j<x.numTargets;++j){const E=x.getTarget(j),a=A.get(i);if(a){const x=a.get(E);x?(J||(J=new zi.c(`${K.name}_${i.name}_MorphWeightAnimation`,"influence",x.framePerSecond,zi.c.ANIMATIONTYPE_FLOAT,x.loopMode,x.enableBlending)),u.push(x.getKeys()[e])):u.push({frame:K.from+M/o*e,value:E.influence,inTangent:g[0].inTangent?0:void 0,outTangent:g[0].outTangent?0:void 0})}}J.setKeys(u);const z=Vi._DeduceAnimationInfo(J);z&&Vi._AddAnimation(`${K.name}_${i.name}_MorphWeightAnimation`,b,i,J,z.dataAccessorType,z.animationChannelTargetPath,e,j,E,a,z.useQuaternion,Y,!1,null===x||void 0===x?void 0:x.numTargets)})),b.channels.length&&b.samplers.length&&x.push(b)}}}static _AddAnimation(i,x,e,E,a,Y,J,u,b,g,A,K,L,o){const M=Vi._CreateNodeAnimation(e,E,Y,A,K);let z,T,Q,t,V,S;if(M){if(o){let i=0,x=0;const e=[];for(;M.inputs.length>0;)x=M.inputs.shift(),i%o==0&&e.push(x),i++;M.inputs=e}const i=J.get(e),E=new Float32Array(M.inputs);z=u.createBufferView(E),T=u.createAccessor(z,"SCALAR",5126,M.inputs.length,void 0,{min:[M.inputsMin],max:[M.inputsMax]}),g.push(T),Q=g.length-1;const b=new j.Quaternion,A=new j.KJ,K=new j.KJ,f=e instanceof Ki.b,w=c(a),O=new Float32Array(M.outputs.length*w);M.outputs.forEach((function(i,x){let e=i;switch(Y){case"translation":L&&(j.KJ.FromArrayToRef(i,0,K),G(K),K.toArray(e));break;case"rotation":4===i.length?j.Quaternion.FromArrayToRef(i,0,b):(e=new Array(4),j.KJ.FromArrayToRef(i,0,A),j.Quaternion.FromEulerVectorToRef(A,b)),L&&(v(b),f&&s(b)),b.toArray(e)}O.set(e,x*w)})),z=u.createBufferView(O),T=u.createAccessor(z,a,5126,M.outputs.length),g.push(T),t=g.length-1,V={interpolation:M.samplerInterpolation,input:Q,output:t},x.samplers.push(V),S={sampler:x.samplers.length-1,target:{node:i,path:Y}},x.channels.push(S)}}static _CreateBakedAnimation(i,x,e,a,Y,J,u,b,g,A,K){let L;const o=j.Quaternion.Identity();let M,z=null,T=null,Q=null,t=null,V=null,S=null;A.min=E.Tools.FloatRound(a/J);const f=x.getKeys();for(let j=0,w=f.length;j<w;++j){if(S=null,Q=f[j],j+1<w)if(t=f[j+1],Q.value.equals&&Q.value.equals(t.value)||Q.value===t.value){if(0!==j)continue;S=Q.frame}else S=t.frame;else{if(V=f[j-1],Q.value.equals&&Q.value.equals(V.value)||Q.value===V.value)continue;S=Y}if(S)for(let j=Q.frame;j<=S;j+=u){if(M=E.Tools.FloatRound(j/J),M===z)continue;z=M,T=M;const a={key:0,repeatCount:0,loopMode:x.loopMode};L=x._interpolate(j,a),Vi._SetInterpolatedValue(i,L,M,x,e,o,b,g,K)}}T&&(A.max=T)}static _ConvertFactorToVector3OrQuaternion(i,x,e,a,Y){const J=Vi._GetBasePositionRotationOrScale(x,a,Y),u=e.targetProperty.split("."),b=u?u[1]:"",g=Y?j.Quaternion.zJ(J).normalize():j.KJ.zJ(J);switch(b){case"x":case"y":case"z":g[b]=i;break;case"w":g.w=i;break;default:E.Tools.Error(`glTFAnimation: Unsupported component name "${b}"!`)}return g}static _SetInterpolatedValue(i,x,e,E,a,Y,J,u,b){let g;J.push(e),"weights"!==a?(E.dataType===zi.c.ANIMATIONTYPE_FLOAT&&(x=this._ConvertFactorToVector3OrQuaternion(x,i,E,a,b)),"rotation"===a?(b?Y=x:(g=x,j.Quaternion.RotationYawPitchRollToRef(g.y,g.x,g.z,Y)),u.push(Y.de())):(g=x,u.push(g.de()))):u.push([x])}static _CreateLinearOrStepAnimation(i,x,e,j,E,a){for(const Y of x.getKeys())j.push(Y.frame/x.framePerSecond),Vi._AddKeyframeValue(Y,x,E,e,i,a)}static _CreateCubicSplineAnimation(i,x,e,j,E,a){x.getKeys().forEach((function(Y){j.push(Y.frame/x.framePerSecond),Vi._AddSplineTangent(Ai.INTANGENT,E,e,"CUBICSPLINE",Y,a),Vi._AddKeyframeValue(Y,x,E,e,i,a),Vi._AddSplineTangent(Ai.OUTTANGENT,E,e,"CUBICSPLINE",Y,a)}))}static _GetBasePositionRotationOrScale(i,x,e){let E;if("rotation"===x)if(e){E=(i.rotationQuaternion??j.Quaternion.Identity()).de()}else{E=(i.rotation??j.KJ.Zero()).de()}else if("translation"===x){E=(i.position??j.KJ.Zero()).de()}else{E=(i.wJ??j.KJ.One()).de()}return E}static _AddKeyframeValue(i,x,e,a,Y,J){let u;const b=x.dataType;if(b===zi.c.ANIMATIONTYPE_VECTOR3){let x=i.value.de();if("rotation"===a){const i=j.KJ.zJ(x);x=j.Quaternion.RotationYawPitchRoll(i.y,i.x,i.z).de()}e.push(x)}else if(b===zi.c.ANIMATIONTYPE_FLOAT){if("weights"===a)e.push([i.value]);else if(u=this._ConvertFactorToVector3OrQuaternion(i.value,Y,x,a,J),u){if("rotation"===a){const i=J?u:j.Quaternion.RotationYawPitchRoll(u.y,u.x,u.z).normalize();e.push(i.de())}e.push(u.de())}}else b===zi.c.ANIMATIONTYPE_QUATERNION?e.push(i.value.normalize().de()):E.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(i,x,e){let j,E,a=!1;if("rotation"===x&&!e)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let Y=0,J=i.length;Y<J;++Y)if(E=i[Y],E.inTangent||E.outTangent)if(j){if("CUBICSPLINE"!==j){j="LINEAR",a=!0;break}}else j="CUBICSPLINE";else if(j){if("CUBICSPLINE"===j||E.interpolation&&1===E.interpolation&&"STEP"!==j){j="LINEAR",a=!0;break}}else j=E.interpolation&&1===E.interpolation?"STEP":"LINEAR";return j||(j="LINEAR"),{interpolationType:j,shouldBakeAnimation:a}}static _AddSplineTangent(i,x,e,E,a,Y){let J;const u=i===Ai.INTANGENT?a.inTangent:a.outTangent;if("CUBICSPLINE"===E){if("rotation"===e)if(u)if(Y)J=u.de();else{const i=u;J=j.Quaternion.RotationYawPitchRoll(i.y,i.x,i.z).de()}else J=[0,0,0,0];else J="weights"===e?u?[u]:[0]:u?u.de():[0,0,0];x.push(J)}}static _CalculateMinMaxKeyFrames(i){let x=1/0,e=-1/0;return i.forEach((function(i){x=Math.min(x,i.frame),e=Math.max(e,i.frame)})),{min:x,max:e}}}function Si(i,x,e,a,Y,J){const u={attributes:{},influence:i.influence,name:i.name},b=x.ye;if(!b)return E.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),u;const A=J?-1:1,K=j.KJ.Zero();let L=0,o=0;if(i.hasPositions){const a=i.getPositions(),J=b.getVerticesData(g.f.PositionKind);if(J){const i=new Float32Array(J.length),x=[1/0,1/0,1/0],E=[-1/0,-1/0,-1/0];o=J.length/3,L=0;for(let e=L;e<o;++e){const Y=j.KJ.zJ(J,3*e);j.KJ.zJ(a,3*e).subtractToRef(Y,K),K.x*=A,x[0]=Math.min(x[0],K.x),E[0]=Math.max(E[0],K.x),x[1]=Math.min(x[1],K.y),E[1]=Math.max(E[1],K.y),x[2]=Math.min(x[2],K.z),E[2]=Math.max(E[2],K.z),i[3*e]=K.x,i[3*e+1]=K.y,i[3*e+2]=K.z}const b=e.createBufferView(i,12),g=e.createAccessor(b,"VEC3",5126,a.length/3,0,{min:x,max:E});Y.push(g),u.attributes.POSITION=Y.length-1}else E.Tools.Warn(`Morph target positions for mesh ${x.name} were not exported. Mesh does not have position vertex data`)}if(i.hasNormals){const a=i.getNormals(),J=b.getVerticesData(g.f.NormalKind);if(J){const i=new Float32Array(J.length);o=J.length/3,L=0;for(let e=L;e<o;++e){const x=j.KJ.zJ(J,3*e).normalize();j.KJ.zJ(a,3*e).normalize().subtractToRef(x,K),i[3*e]=K.x*A,i[3*e+1]=K.y,i[3*e+2]=K.z}const x=e.createBufferView(i,12),E=e.createAccessor(x,"VEC3",5126,a.length/3,0);Y.push(E),u.attributes.NORMAL=Y.length-1}else E.Tools.Warn(`Morph target normals for mesh ${x.name} were not exported. Mesh does not have normals vertex data`)}if(i.hasTangents){const a=i.getTangents(),J=b.getVerticesData(g.f.TangentKind);if(J){o=J.length/4;const i=new Float32Array(3*o);L=0;for(let e=L;e<o;++e){const x=j.KJ.zJ(J,4*e);W(x);const E=j.KJ.zJ(a,3*e);W(E),E.subtractToRef(x,K),i[3*e]=K.x*A,i[3*e+1]=K.y,i[3*e+2]=K.z}const x=e.createBufferView(i,12),E=e.createAccessor(x,"VEC3",5126,o,0);Y.push(E),u.attributes.TANGENT=Y.length-1}else E.Tools.Warn(`Morph target tangents for mesh ${x.name} were not exported. Mesh does not have tangents vertex data`)}if(i.hasColors){const a=i.getColors(),J=b.getVerticesData(g.f.ColorKind),A=b.getVertexBuffer(g.f.ColorKind);if(J&&A){const i=A.getSize();o=J.length/i;const x=new Float32Array(o*i);L=0;for(let e=L;e<o;++e)if(3===i){const E=j.KJ.zJ(J,e*i);j.KJ.zJ(a,e*i).subtractToRef(E,K),x[3*e]=K.x,x[3*e+1]=K.y,x[3*e+2]=K.z}else if(4===i){const E=new j.Vector4,Y=j.Vector4.zJ(J,e*i);j.Vector4.zJ(a,e*i).subtractToRef(Y,E),x[4*e]=E.x,x[4*e+1]=E.y,x[4*e+2]=E.z,x[4*e+3]=E.w}else E.Tools.Warn(`Unsupported number of components for color attribute: ${i}`);const b=e.createBufferView(x,4*i),g=e.createAccessor(b,3===i?"VEC3":"VEC4",5126,o,0);Y.push(g),u.attributes.COLOR_0=Y.length-1}else E.Tools.Warn(`Morph target colors for mesh ${x.name} were not exported. Mesh does not have colors vertex data`)}return u}var fi=e(12777),wi=e(12613),Oi=e(12591),li=e(12204);class Zi{}Zi.DEFAULT_COLOR=z.MJ.White(),Zi.DEFAULT_WIDTH_ATTENUATED=1,Zi.DEFAULT_WIDTH=.1;var Bi=e(12429),ki=e(12780);class Ni{static ConvertPoints(i,x){if(i.length&&Array.isArray(i)&&"number"===typeof i[0])return[i];if(i.length&&Array.isArray(i[0])&&"number"===typeof i[0][0])return i;if(i.length&&!Array.isArray(i[0])&&i[0]instanceof j.KJ){const x=[];for(let e=0;e<i.length;e++){const j=i[e];x.push(j.x,j.y,j.z)}return[x]}if(i.length>0&&Array.isArray(i[0])&&i[0].length>0&&i[0][0]instanceof j.KJ){const x=[],e=i;for(const i of e)x.push(i.flatMap((i=>[i.x,i.y,i.z])));return x}if(i instanceof Float32Array){if(null!==x&&void 0!==x&&x.floatArrayStride){const e=[],j=3*x.floatArrayStride;for(let x=0;x<i.length;x+=j){const E=new Array(j);for(let e=0;e<j;e++)E[e]=i[x+e];e.push(E)}return e}return[Array.from(i)]}if(i.length&&i[0]instanceof Float32Array){const x=[];for(const e of i)x.push(Array.from(e));return x}return[]}static OmitZeroLengthPredicate(i,x,e){const j=[];return x.Cx(i).lengthSquared()>0&&j.push([i,x]),e.Cx(x).lengthSquared()>0&&j.push([x,e]),i.Cx(e).lengthSquared()>0&&j.push([e,i]),0===j.length?null:j}static OmitDuplicatesPredicate(i,x,e,j){const E=[];return Ni._SearchInPoints(i,x,j)||E.push([i,x]),Ni._SearchInPoints(x,e,j)||E.push([x,e]),Ni._SearchInPoints(e,i,j)||E.push([e,i]),0===E.length?null:E}static _SearchInPoints(i,x,e){for(const Y of e)for(let e=0;e<Y.length;e++){var j,E,a;if(null!==(j=Y[e])&&void 0!==j&&j.equals(i))if(null!==(E=Y[e+1])&&void 0!==E&&E.equals(x)||null!==(a=Y[e-1])&&void 0!==a&&a.equals(x))return!0}return!1}static MeshesToLines(i,x){const e=[];for(let E=0;E<i.length;E++){const a=i[E],Y=a.getVerticesData(g.f.PositionKind),J=a.Pe();if(Y&&J)for(let i=0,u=0;i<J.length;i++){const b=3*J[u++],g=3*J[u++],A=3*J[u++],K=new j.KJ(Y[b],Y[b+1],Y[b+2]),L=new j.KJ(Y[g],Y[g+1],Y[g+2]),o=new j.KJ(Y[A],Y[A+1],Y[A+2]);if(x){const j=x(K,L,o,e,i,b,a,E,Y,J);if(j)for(const i of j)e.push(i)}else e.push([K,L],[L,o],[o,K])}}return e}static ToVector3Array(i){if(Array.isArray(i[0])){const x=[],e=i;for(const i of e){const e=[];for(let x=0;x<i.length;x+=3)e.push(new j.KJ(i[x],i[x+1],i[x+2]));x.push(e)}return x}const x=i,e=[];for(let E=0;E<x.length;E+=3)e.push(new j.KJ(x[E],x[E+1],x[E+2]));return e}static ToNumberArray(i){return i.flatMap((i=>[i.x,i.y,i.z]))}static GetPointsCountInfo(i){const x=new Array(i.length);let e=0;for(let j=i.length;j--;)x[j]=i[j].length/3,e+=x[j];return{total:e,counts:x}}static GetLineLength(i){if(0===i.length)return 0;let x;x="number"===typeof i[0]?Ni.ToVector3Array(i):i;const e=j.TmpVectors.KJ[0];let E=0;for(let j=0;j<x.length-1;j++){const i=x[j];E+=x[j+1].subtractToRef(i,e).length()}return E}static GetLineLengthArray(i){const x=new Float32Array(i.length/3);let e=0;for(let j=0,E=i.length/3-1;j<E;j++){let E=i[3*j+0],a=i[3*j+1],Y=i[3*j+2];E-=i[3*j+3],a-=i[3*j+4],Y-=i[3*j+5];e+=Math.sqrt(E*E+a*a+Y*Y),x[j+1]=e}return x}static SegmentizeSegmentByCount(i,x,e){const E=[],a=x.Cx(i),Y=j.TmpVectors.KJ[0];Y.OJ(e);const J=j.TmpVectors.KJ[1];a.divideToRef(Y,J);let u=i.clone();E.push(u);for(let j=0;j<e;j++)u=u.clone(),E.push(u.addInPlace(J));return E}static SegmentizeLineBySegmentLength(i,x){const e=i[0]instanceof j.KJ?Ni.GetLineSegments(i):"number"===typeof i[0]?Ni.GetLineSegments(Ni.ToVector3Array(i)):i,E=[];for(const j of e)if(j.length>x){const i=Ni.SegmentizeSegmentByCount(j.point1,j.point2,Math.ceil(j.length/x));for(const x of i)E.push(x)}else E.push(j.point1),E.push(j.point2);return E}static SegmentizeLineBySegmentCount(i,x){const e="number"===typeof i[0]?Ni.ToVector3Array(i):i,j=Ni.GetLineLength(e)/x;return Ni.SegmentizeLineBySegmentLength(e,j)}static GetLineSegments(i){const x=[];for(let e=0;e<i.length-1;e++){const j=i[e],E=i[e+1],a=E.Cx(j).length();x.push({point1:j,point2:E,length:a})}return x}static GetMinMaxSegmentLength(i){const x=Ni.GetLineSegments(i).sort((i=>i.length));return{min:x[0].length,max:x[x.length-1].length}}static GetPositionOnLineByVisibility(i,x,e){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=x*e;let Y=0,J=0;const u=i.length;for(let j=0;j<u;j++){if(a<=Y+i[j].length){J=j;break}Y+=i[j].length}const b=(a-Y)/i[J].length;return i[J].point2.subtractToRef(i[J].point1,j.TmpVectors.KJ[0]),j.TmpVectors.KJ[1]=j.TmpVectors.KJ[0].multiplyByFloats(b,b,b),E||j.TmpVectors.KJ[1].addInPlace(i[J].point1),j.TmpVectors.KJ[1].clone()}static GetCircleLinePoints(i,x){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:i,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/x;const Y=[];for(let J=0;J<=x;J++)Y.push(new j.KJ(Math.cos(J*a)*i,Math.sin(J*a)*E,e));return Y}static GetBezierLinePoints(i,x,e,j){return Bi.d.CreateQuadraticBezier(i,x,e,j).getPoints().flatMap((i=>[i.x,i.y,i.z]))}static GetArrowCap(i,x,e,j,E){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[i.clone(),i.add(x.multiplyByFloats(e,e,e))],widths:[j,E,a,Y]}}static GetPointsFromText(i,x,e,j){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const Y=[],J=(0,ki.e)(i,x,e,j);for(const u of J){for(const i of u.paths){const x=[],e=i.getPoints();for(const i of e)x.push(i.x,i.y,E);Y.push(x)}if(a)for(const i of u.holes){const x=[],e=i.getPoints();for(const i of e)x.push(i.x,i.y,E);Y.push(x)}}return Y}static Color3toRGBAUint8(i){const x=new Uint8Array(4*i.length);for(let e=0,j=0;e<i.length;e++)x[j++]=255*i[e].r,x[j++]=255*i[e].g,x[j++]=255*i[e].b,x[j++]=255;return x}static CreateColorsTexture(i,x,e,j){const E=j.getEngine().getCaps().maxTextureSize??1,a=x.length>E?E:x.length,Y=Math.ceil(x.length/E);Y>1&&(x=[...x,...Array(a*Y-x.length).fill(x[0])]);const J=Ni.Color3toRGBAUint8(x),u=new f.e(J,a,Y,o.c.TEXTUREFORMAT_RGBA,j,!1,!0,e);return u.name=i,u}static PrepareEmptyColorsTexture(i){if(!Zi.EmptyColorsTexture){const x=new Uint8Array(4);Zi.EmptyColorsTexture=new f.e(x,1,1,o.c.TEXTUREFORMAT_RGBA,i,!1,!1,f.e.NEAREST_NEAREST),Zi.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Zi.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var i;null===(i=Zi.EmptyColorsTexture)||void 0===i||i.dispose(),Zi.EmptyColorsTexture=null}static BooleanToNumber(i){return i?1:0}}class mx extends Oi.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Xi extends wi.e{isCompatible(i){return!0}constructor(i,x,e){var E;e=e||{color:Zi.DEFAULT_COLOR};const a=new mx;a.GREASED_LINE_HAS_COLOR=!!e.color&&!e.useColors,a.GREASED_LINE_SIZE_ATTENUATION=e.sizeAttenuation??!1,a.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===e.colorDistributionType,a.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(x??i.wi()).useRightHandedSystem,a.GREASED_LINE_CAMERA_FACING=e.cameraFacing??!0,super(i,Xi.GREASED_LINE_MATERIAL_NAME,200,a,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(E=e)||void 0===E?void 0:E.forceGLSL)||Xi.ForceGLSL,this._scene=x??i.wi(),this._engine=this._scene.getEngine(),this._cameraFacing=e.cameraFacing??!0,this.visibility=e.visibility??1,this.useDash=e.useDash??!1,this.dashRatio=e.dashRatio??.5,this.dashOffset=e.dashOffset??0,this.width=e.width?e.width:e.sizeAttenuation?Zi.DEFAULT_WIDTH_ATTENUATED:Zi.DEFAULT_WIDTH,this._sizeAttenuation=e.sizeAttenuation??!1,this.colorMode=e.colorMode??0,this._color=e.color??null,this.useColors=e.useColors??!1,this._colorsDistributionType=e.colorDistributionType??0,this.colorsSampling=e.colorsSampling??f.e.NEAREST_NEAREST,this._colors=e.Bi??null,this.dashCount=e.dashCount??1,this.resolution=e.resolution??new j.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),e.colorsTexture?this.colorsTexture=e.colorsTexture:this._colors?this.colorsTexture=Ni.CreateColorsTexture(`${i.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Zi.DEFAULT_COLOR,Ni.PrepareEmptyColorsTexture(this._scene)),this._engine.te.add((()=>{Ni.DisposeEmptyColorsTexture()}))}getAttributes(i){i.push("grl_offsets"),i.push("grl_widths"),i.push("grl_colorPointers"),i.push("grl_counters"),this._cameraFacing?(i.push("grl_previousAndSide"),i.push("grl_nextAndCounters")):i.push("grl_slopes")}getSamplers(i){i.push("grl_colors")}getActiveTextures(i){this.colorsTexture&&i.push(this.colorsTexture)}getUniforms(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const x=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&x.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===i&&x.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:x,vertex:this._cameraFacing&&this._isGLSL(i)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(i)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(i){if(this._cameraFacing){i.he("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||i.he("viewProjection",this._scene.getTransformMatrix());const x=j.TmpVectors.Vector4[0];x.x=this._aspect,x.y=this._resolution.x,x.z=this._resolution.y,x.w=this.width,i.updateVector4("grl_aspect_resolution_lineWidth",x)}const x=j.TmpVectors.Vector4[0];x.x=Ni.BooleanToNumber(this.useDash),x.y=this._dashArray,x.z=this.dashOffset,x.w=this.dashRatio,i.updateVector4("grl_dashOptions",x);const e=j.TmpVectors.Vector4[1];e.x=this.colorMode,e.y=this.visibility,e.z=this.colorsTexture?this.colorsTexture.getSize().width:0,e.w=Ni.BooleanToNumber(this.useColors),i.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",e),this._color&&i.updateColor3("grl_singleColor",this._color);const E=this.colorsTexture??Zi.EmptyColorsTexture;i.setTexture("grl_colors",E),i.updateFloat2("grl_textureSize",(null===E||void 0===E?void 0:E.getSize().width)??1,(null===E||void 0===E?void 0:E.getSize().height)??1)}prepareDefines(i,x,e){i.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,i.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,i.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,i.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=x.useRightHandedSystem,i.GREASED_LINE_CAMERA_FACING=this._cameraFacing,i.GREASED_LINE_USE_OFFSETS=!!e.offsets}getClassName(){return Xi.GREASED_LINE_MATERIAL_NAME}getCustomCode(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(x)?function(i,x){if("vertex"===i){const i={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return x&&(i["!gl_Position\\=viewProjection\\*worldPos;"]="//"),i}return"fragment"===i?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(i,this._cameraFacing):function(i,x){if("vertex"===i){const i={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return x&&(i["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),i}return"fragment"===i?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(i,this._cameraFacing)}dispose(){var i;null===(i=this.colorsTexture)||void 0===i||i.dispose(),super.dispose()}get Bi(){return this._colors}set Bi(i){this.setColors(i)}setColors(i){var x;let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],j=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(x=this._colors)||void 0===x?void 0:x.length)??0;var a;if(this._colors=i,null!==i&&0!==i.length){if(!e||j)if(this.colorsTexture&&E===i.length&&!j){const x=Ni.Color3toRGBAUint8(i);this.colorsTexture.update(x)}else{var Y;null===(Y=this.colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=Ni.CreateColorsTexture(`${this._material.name}-colors-texture`,i,this.colorsSampling,this._scene)}}else null===(a=this.colorsTexture)||void 0===a||a.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(i){this._dashCount=i,this._dashArray=1/i}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(i){this._sizeAttenuation=i,this.markAllDefinesAsDirty()}get color(){return this._color}set color(i){this.setColor(i)}setColor(i){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==i||null!==this._color&&null===i?(this._color=i,x||this.markAllDefinesAsDirty()):this._color=i}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(i){this._colorsDistributionType=i,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(i){this._aspect=i.x/i.y,this._resolution=i}serialize(){const i=super.serialize(),x={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(x.Bi=this._colors),this._color&&(x.color=this._color),i.greasedLineMaterialOptions=x,i}parse(i,x,e){var j;super.parse(i,x,e);const E=i.greasedLineMaterialOptions;null===(j=this.colorsTexture)||void 0===j||j.dispose(),E.color&&this.setColor(E.color,!0),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.Bi&&(this.Bi=E.Bi),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),this.Bi?this.colorsTexture=Ni.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Bi,this.colorsSampling,x):Ni.PrepareEmptyColorsTexture(x),this.markAllDefinesAsDirty()}copyTo(i){var x;const e=i;null===(x=e.colorsTexture)||void 0===x||x.dispose(),this._colors&&(e.colorsTexture=Ni.CreateColorsTexture(`${e._material.name}-colors-texture`,this._colors,e.colorsSampling,this._scene)),e.setColor(this.color,!0),e.colorsDistributionType=this.colorsDistributionType,e.colorsSampling=this.colorsSampling,e.colorMode=this.colorMode,e.useColors=this.useColors,e.visibility=this.visibility,e.useDash=this.useDash,e.dashCount=this.dashCount,e.dashRatio=this.dashRatio,e.dashOffset=this.dashOffset,e.width=this.width,e.sizeAttenuation=this.sizeAttenuation,e.resolution=this.resolution,e.markAllDefinesAsDirty()}_isGLSL(i){return 0===i||this._forceGLSL}}Xi.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Xi.ForceGLSL=!1,(0,li.f)(`BABYLON.${Xi.GREASED_LINE_MATERIAL_NAME}`,Xi);var Ci=e(12657),ni=e(12080),Ii=e(12444),di=e(12187);class pi extends Ii.ShaderMaterial{constructor(i,x,E){const a=x.getEngine(),Y=a.isWebGPU&&!(E.forceGLSL||pi.ForceGLSL),J=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];x.useRightHandedSystem&&J.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const u=["position","grl_widths","grl_offsets","grl_colorPointers"];E.cameraFacing?(J.push("GREASED_LINE_CAMERA_FACING"),u.push("grl_previousAndSide","grl_nextAndCounters")):(u.push("grl_slopes"),u.push("grl_counters"));const b=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(Y||b.push("world","viewProjection","view","projection"),super(i,x,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:Y?["Scene","Mesh"]:void 0,attributes:u,uniforms:b,samplers:Y?[]:["grlColors"],defines:J,extraInitializationsAsync:async()=>{Y?await Promise.all([e.e(66).then(e.bind(e,15284)),e.e(75).then(e.bind(e,15292))]):await Promise.all([e.e(69).then(e.bind(e,15299)),e.e(76).then(e.bind(e,15304))])},shaderLanguage:Y?1:0}),this._color=z.MJ.White(),this._colorsDistributionType=0,this._colorsTexture=null,E=E||{color:Zi.DEFAULT_COLOR},this.visibility=E.visibility??1,this.useDash=E.useDash??!1,this.dashRatio=E.dashRatio??.5,this.dashOffset=E.dashOffset??0,this.dashCount=E.dashCount??1,this.width=E.width?E.width:E.sizeAttenuation&&E.cameraFacing?Zi.DEFAULT_WIDTH_ATTENUATED:Zi.DEFAULT_WIDTH,this.sizeAttenuation=E.sizeAttenuation??!1,this.color=E.color??z.MJ.White(),this.useColors=E.useColors??!1,this.colorsDistributionType=E.colorDistributionType??0,this.colorsSampling=E.colorsSampling??f.e.NEAREST_NEAREST,this.colorMode=E.colorMode??0,this._colors=E.Bi??null,this._cameraFacing=E.cameraFacing??!0,this.resolution=E.resolution??new j.Vector2(a.getRenderWidth(),a.getRenderHeight()),E.colorsTexture?this.colorsTexture=E.colorsTexture:this._colors?this.colorsTexture=Ni.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,x):(this._color=this._color??Zi.DEFAULT_COLOR,this.colorsTexture=Ni.PrepareEmptyColorsTexture(x)),Y){const i=new di.b;i.setParameters(),i.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",i)}a.te.add((()=>{Ni.DisposeEmptyColorsTexture()}))}dispose(){var i;null===(i=this._colorsTexture)||void 0===i||i.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new j.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Bi(){return this._colors}set Bi(i){this.setColors(i)}setColors(i){var x;let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],j=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(x=this._colors)||void 0===x?void 0:x.length)??0;var a;if(this._colors=i,null!==i&&0!==i.length){if(!e||j)if(this._colorsTexture&&E===i.length&&!j){const x=Ni.Color3toRGBAUint8(i);this._colorsTexture.update(x)}else{var Y;null===(Y=this._colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=Ni.CreateColorsTexture(`${this.name}-colors-texture`,i,this.colorsSampling,this.wi())}}else null===(a=this._colorsTexture)||void 0===a||a.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(i){this._colorsTexture=i,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(i){this._width=i,this.setFloat("grlWidth",i)}get useColors(){return this._useColors}set useColors(i){this._useColors=i,this.setFloat("grlUseColors",Ni.BooleanToNumber(i))}get colorsSampling(){return this._colorsSampling}set colorsSampling(i){this._colorsSampling=i}get visibility(){return this._visibility}set visibility(i){this._visibility=i,this.setFloat("grlVisibility",i)}get useDash(){return this._useDash}set useDash(i){this._useDash=i,this.setFloat("grlUseDash",Ni.BooleanToNumber(i))}get dashOffset(){return this._dashOffset}set dashOffset(i){this._dashOffset=i,this.setFloat("grlDashOffset",i)}get dashRatio(){return this._dashRatio}set dashRatio(i){this._dashRatio=i,this.setFloat("grlDashRatio",i)}get dashCount(){return this._dashCount}set dashCount(i){this._dashCount=i,this._dashArray=1/i,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(i){this._sizeAttenuation=i,this.setFloat("grlSizeAttenuation",Ni.BooleanToNumber(i))}get color(){return this._color}set color(i){this.setColor(i)}setColor(i){i=i??Zi.DEFAULT_COLOR,this._color=i,this.setColor3("grlColor",i)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(i){this._colorsDistributionType=i,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(i){this._colorMode=i,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(i){this._resolution=i,this.setVector2("grlResolution",i),this.setFloat("grlAspect",i.x/i.y)}serialize(){const i=super.serialize(),x={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(x.Bi=this._colors),i.greasedLineMaterialOptions=x,i}parse(i,x,e){var j;const E=i.greasedLineMaterialOptions;null===(j=this._colorsTexture)||void 0===j||j.dispose(),E.color&&(this.color=E.color),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),E.Bi?this.colorsTexture=Ni.CreateColorsTexture(`${this.name}-colors-texture`,E.Bi,this.colorsSampling,this.wi()):this.colorsTexture=Ni.PrepareEmptyColorsTexture(x),this._cameraFacing=E.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Hi,Ui,Di;pi.ForceGLSL=!1,function(i){i[i.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",i[i.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Hi||(Hi={})),function(i){i[i.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",i[i.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",i[i.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Ui||(Ui={})),function(i){i[i.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",i[i.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",i[i.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",i[i.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",i[i.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Di||(Di={}));class hi extends Qi.c{constructor(i,x,e){super(i,x,null,null,!1,!1),this.name=i,this._options=e,this._lazy=!1,this._updatable=!1,this._engine=x.getEngine(),this._lazy=e.lazy??!1,this._updatable=e.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=e.colorPointers??[],this._widths=e.widths??new Array(e.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(i){let x=0;for(const j of this._points)x+=j.length;const e=x/3*2-this._widths.length;for(let j=0;j<e;j++)this._widths.push(i)}updateLazy(){var i,x;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(i=this._options.ribbonOptions)||void 0===i?void 0:i.smoothShading),!this.Xi&&this.refreshBoundingInfo(),null===(x=this.greasedLineMaterial)||void 0===x||x.updateLazy()}addPoints(i,x){for(const e of i)this._points.push(e);this._lazy||this.setPoints(this._points,x)}dispose(i){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(i,x)}isLazy(){return this._lazy}get ki(){return this._uvs}set ki(i){this._uvs=i instanceof Float32Array?i:new Float32Array(i),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(i){this.material instanceof pi&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===i||void 0===i?void 0:i.length)>0),this._offsets=i,this._offsetsBuffer?this._offsetsBuffer.update(i):this._createOffsetsBuffer(i)}get widths(){return this._widths}set widths(i){this._widths=i,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(i)}get colorPointers(){return this._colorPointers}set colorPointers(i){this._colorPointers=i,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(i)}get greasedLineMaterial(){var i,x;if(this.material&&this.material instanceof pi)return this.material;const e=null===(i=this.material)||void 0===i||null===(x=i.pluginManager)||void 0===x?void 0:x.getPlugin(Xi.GREASED_LINE_MATERIAL_NAME);return e||void 0}get points(){const i=[];return ni.d.DeepCopy(this._points,i),i}setPoints(i,x){this._points=Ni.ConvertPoints(i,(null===x||void 0===x?void 0:x.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==x&&void 0!==x&&x.colorPointers||this._updateColorPointers(),this._setPoints(this._points,x)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,ki:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(i){super.serialize(i),i.type=this.getClassName(),i.lineOptions=this._createLineOptions()}_createVertexBuffers(){let i=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new Ci.e;return x.li=this._vertexPositions,x.indices=this._indices,x.ki=this._uvs,i&&(x.Zi=[],Ci.e.ComputeNormals(this._vertexPositions,this._indices,x.Zi)),x.mx(this,this._options.updatable),x}_createOffsetsBuffer(i){const x=this._scene.getEngine(),e=new g.d(x,i,this._updatable,3);this.setVerticesBuffer(e.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=e}}class Fi{constructor(i,x){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=i,this.wasAddedByNoopNode=x}getIndicesAccessor(i,x,e,j,E){var a,Y,J,u;return null===(a=this._indicesAccessorMap.get(i))||void 0===a||null===(Y=a.get(x))||void 0===Y||null===(J=Y.get(e))||void 0===J||null===(u=J.get(j))||void 0===u?void 0:u.get(E)}setIndicesAccessor(i,x,e,j,E,a){let Y=this._indicesAccessorMap.get(i);Y||(Y=new Map,this._indicesAccessorMap.set(i,Y));let J=Y.get(x);J||(J=new Map,Y.set(x,J));let u=J.get(e);u||(u=new Map,J.set(e,u));let b=u.get(j);b||(b=new Map,u.set(j,b)),b.set(E,a)}pushExportedNode(i){this._exportedNodes.has(i)||this._exportedNodes.add(i)}getNodesSet(){return this._exportedNodes}getVertexBufferView(i){return this._vertexBufferViewMap.get(i)}setVertexBufferView(i,x){this._vertexBufferViewMap.set(i,x)}setRemappedBufferView(i,x,e){this._remappedBufferView.set(i,new Map),this._remappedBufferView.get(i).set(x,e)}getRemappedBufferView(i,x){var e;return null===(e=this._remappedBufferView.get(i))||void 0===e?void 0:e.get(x)}getVertexAccessor(i,x,e){var j,E;return null===(j=this._vertexAccessorMap.get(i))||void 0===j||null===(E=j.get(x))||void 0===E?void 0:E.get(e)}setVertexAccessor(i,x,e,j){let E=this._vertexAccessorMap.get(i);E||(E=new Map,this._vertexAccessorMap.set(i,E));let a=E.get(x);a||(a=new Map,E.set(x,a)),a.set(e,j)}hasVertexColorAlpha(i){return this._vertexMapColorAlpha.get(i)||!1}setHasVertexColorAlpha(i,x){return this._vertexMapColorAlpha.set(i,x)}getMesh(i){return this._meshMap.get(i)}setMesh(i,x){this._meshMap.set(i,x)}bindMorphDataToMesh(i,x){const e=this._meshMorphTargetMap.get(i)||[];this._meshMorphTargetMap.set(i,e),-1===e.indexOf(x)&&e.push(x)}getMorphTargetsFromMesh(i){return this._meshMorphTargetMap.get(i)}}class Ri{_ApplyExtension(i,x,e,j){if(e>=x.length)return Promise.resolve(i);const E=j(x[e],i);return E?E.then((async i=>i?await this._ApplyExtension(i,x,e+1,j):null)):this._ApplyExtension(i,x,e+1,j)}_ApplyExtensions(i,x){const e=[];for(const j of Ri._ExtensionNames)e.push(this._extensions[j]);return this._ApplyExtension(i,e,0,x)}_extensionsPreExportTextureAsync(i,x,e){return this._ApplyExtensions(x,((x,j)=>x.preExportTextureAsync&&x.preExportTextureAsync(i,j,e)))}_extensionsPostExportNodeAsync(i,x,e,j,E){return this._ApplyExtensions(x,((x,a)=>x.postExportNodeAsync&&x.postExportNodeAsync(i,a,e,j,E,this._bufferManager)))}_extensionsPostExportMaterialAsync(i,x,e){return this._ApplyExtensions(x,((x,j)=>x.postExportMaterialAsync&&x.postExportMaterialAsync(i,j,e)))}_extensionsPostExportMaterialAdditionalTextures(i,x,e){const j=[];for(const E of Ri._ExtensionNames){const a=this._extensions[E];a.postExportMaterialAdditionalTextures&&j.push(...a.postExportMaterialAdditionalTextures(i,x,e))}return j}_extensionsPostExportTextures(i,x,e){for(const j of Ri._ExtensionNames){const E=this._extensions[j];E.postExportTexture&&E.postExportTexture(i,x,e)}}_extensionsPostExportMeshPrimitive(i){for(const x of Ri._ExtensionNames){const e=this._extensions[x];e.postExportMeshPrimitive&&e.postExportMeshPrimitive(i,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const i of Ri._ExtensionNames){const x=this._extensions[i];x.preGenerateBinaryAsync&&await x.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(i){for(const x of Ri._ExtensionNames){const e=this._extensions[x];e.enabled&&i(e)}}_extensionsOnExporting(){this._forEachExtensions((i=>{var x,e,j;i.wasUsed&&((x=this._glTF).extensionsUsed||(x.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(i.name)&&this._glTF.extensionsUsed.push(i.name),i.required&&((e=this._glTF).extensionsRequired||(e.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(i.name)&&this._glTF.extensionsRequired.push(i.name)),(j=this._glTF).extensions||(j.extensions={}),i.onExporting&&i.onExporting())}))}_loadExtensions(){for(const i of Ri._ExtensionNames){const x=Ri._ExtensionFactories[i](this);this._extensions[i]=x}}constructor(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:M.e.LastCreatedScene,x=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${o.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new d(this),this._extensions={},this._bufferManager=new gi,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!i)throw new Error("No scene available to export");this._babylonScene=i,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:i=>{var x;return null===i||void 0===i||null===(x=i.Ne)||void 0===x?void 0:x.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...x},this._loadExtensions()}dispose(){for(const i in this._extensions){this._extensions[i].dispose()}}get options(){return this._options}static RegisterExtension(i,x){Ri.UnregisterExtension(i)&&E.Tools.Warn(`Extension with the name ${i} already exists`),Ri._ExtensionFactories[i]=x,Ri._ExtensionNames.push(i)}static UnregisterExtension(i){if(!Ri._ExtensionFactories[i])return!1;delete Ri._ExtensionFactories[i];const x=Ri._ExtensionNames.indexOf(i);return-1!==x&&Ri._ExtensionNames.splice(x,1),!0}_generateJSON(i,x,e){const j={byteLength:i};return j.byteLength&&(this._glTF.buffers=[j]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.LJ=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(j.uri=x+".bin"),e?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(i){const x=await this._generateBinaryAsync();this._extensionsOnExporting();const e=this._generateJSON(x.byteLength,i,!0),j=new Blob([x],{type:"application/octet-stream"}),E=i+".gltf",a=i+".bin",Y=new b;if(Y.files[E]=e,Y.files[a]=j,this._imageData)for(const J in this._imageData)Y.files[J]=new Blob([this._imageData[J].data],{type:this._imageData[J].mimeType});return Y}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(i){const x=i%4;return 0===x?x:4-x}async generateGLBAsync(i){this._shouldUseGlb=!0;const x=await this._generateBinaryAsync();this._extensionsOnExporting();const e=this._generateJSON(x.byteLength),j=i+".glb";let E,a=e.length;if("undefined"!==typeof TextEncoder){E=(new TextEncoder).encode(e),a=E.length}const Y=this._getPadding(a),J=this._getPadding(x.byteLength),u=28+a+Y+x.byteLength+J,g=new ui(u);if(g.writeUInt32(1179937895),g.writeUInt32(2),g.writeUInt32(u),g.writeUInt32(a+Y),g.writeUInt32(1313821514),E)g.writeTypedArray(E);else{const i="_".charCodeAt(0);for(let x=0;x<a;++x){const j=e.charCodeAt(x);j!=e.codePointAt(x)?g.writeUInt8(i):g.writeUInt8(j)}}for(let b=0;b<Y;++b)g.writeUInt8(32);g.writeUInt32(x.byteLength+J),g.writeUInt32(5130562),g.writeTypedArray(x);for(let b=0;b<J;++b)g.writeUInt8(0);const A=new b;return A.files[j]=new Blob([g.getOutputData()],{type:"application/octet-stream"}),A}_setNodeTransformation(i,x,e){if(x.getPivotPoint().equalsWithEpsilon(h,D.e)||E.Tools.Warn("Pivot points are not supported in the glTF serializer"),!x.position.equalsWithEpsilon(h,D.e)){const E=j.TmpVectors.KJ[0].A(x.position);e&&G(E),i.translation=E.de()}x.wJ.equalsWithEpsilon(R,D.e)||(i.scale=x.wJ.de());const a=x.rotationQuaternion||j.Quaternion.FromEulerAngles(x.rotation.x,x.rotation.y,x.rotation.z);a.equalsWithEpsilon(F,D.e)||(e&&v(a),i.rotation=a.normalize().de())}_setCameraTransformation(i,x,e){if(!x.position.equalsWithEpsilon(h,D.e)){const E=j.TmpVectors.KJ[0].A(x.position);e&&G(E),i.translation=E.de()}const E=x.rotationQuaternion||j.Quaternion.FromEulerAngles(x.rotation.x,x.rotation.y,x.rotation.z);e&&v(E),this._babylonScene.useRightHandedSystem||s(E),E.equalsWithEpsilon(F,D.e)||(i.rotation=E.de())}_listAvailableCameras(){for(const i of this._babylonScene.cameras){const x={type:i.mode===Ki.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(i.name&&(x.name=i.name),"perspective"===x.type)x.perspective={aspectRatio:i.getEngine().getAspectRatio(i),yfov:i.fovMode===Ki.b.FOVMODE_VERTICAL_FIXED?i.fov:i.fov*i.getEngine().getAspectRatio(i),znear:i.De,zfar:i.maxZ};else if("orthographic"===x.type){const e=i.orthoLeft&&i.orthoRight?.5*(i.orthoRight-i.orthoLeft):.5*i.getEngine().getRenderWidth(),j=i.orthoBottom&&i.orthoTop?.5*(i.orthoTop-i.orthoBottom):.5*i.getEngine().getRenderHeight();x.orthographic={xmag:e,ymag:j,znear:i.De,zfar:i.maxZ}}this._camerasMap.set(i,x)}}_exportAndAssignCameras(){const i=Array.from(this._camerasMap.values());for(const x of i){const i=this._nodesCameraMap.get(x);if(void 0!==i){this._cameras.push(x);for(const x of i)x.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const i of this._babylonScene.skeletons){if(i.bones.length<=0)continue;const x={joints:[]};this._skinMap.set(i,x)}}_exportAndAssignSkeletons(){for(const i of this._babylonScene.skeletons){if(i.bones.length<=0)continue;const x=this._skinMap.get(i);if(void 0==x)continue;const e={},j=[];let a=-1;for(let E=0;E<i.bones.length;++E){const x=i.bones[E],j=x.getIndex()??E;-1!==j&&(e[j]=x,j>a&&(a=j))}for(let i=0;i<=a;++i){const a=e[i];j.push(a.getAbsoluteInverseBindMatrix());const Y=a.getTransformNode();if(null!==Y){const i=this._nodeMap.get(Y);Y&&null!==i&&void 0!==i?x.joints.push(i):E.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else E.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const Y=this._nodesSkinMap.get(x);if(x.joints.length>0&&void 0!==Y){const i=64*j.length,e=new Float32Array(i/4);j.forEach(((i,x)=>{e.set(i.m,16*x)}));const E=this._bufferManager.createBufferView(e);this._accessors.push(this._bufferManager.createAccessor(E,"MAT4",5126,j.length)),x.inverseBindMatrices=this._accessors.length-1,this._skins.push(x);for(const x of Y)x.skin=this._skins.length-1}}}async _exportSceneAsync(){const i={nodes:[]};if(this._babylonScene.metadata){const x=this._options.metadataSelector(this._babylonScene.metadata);x&&(i.extras=x)}const x=new Array,e=new Array,j=new Array;for(const J of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Yi(J,this._babylonScene.useRightHandedSystem)?j.push(...J.getChildren()):this._babylonScene.useRightHandedSystem?x.push(J):e.push(J);this._listAvailableCameras(),this._listAvailableSkeletons();const E=new Fi(!0,!1);i.nodes.push(...await this._exportNodesAsync(e,E));const a=new Fi(!1,!1);i.nodes.push(...await this._exportNodesAsync(x,a));const Y=new Fi(!1,!0);i.nodes.push(...await this._exportNodesAsync(j,Y)),i.nodes.length&&this._scenes.push(i),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Vi._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,E.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(i){let x=this._shouldExportNodeMap.get(i);return void 0===x&&(x=this._options.shouldExportNode(i),this._shouldExportNodeMap.set(i,x)),x}async _exportNodesAsync(i,x){const e=new Array;this._exportBuffers(i,x);for(const j of i)await this._exportNodeAsync(j,e,x);return e}_collectBuffers(i,x,e,j,E){if(this._shouldExportNode(i)&&i instanceof K.e&&i.ye){const a=i.ye.getVertexBuffers();if(a)for(const j in a){if(!P(j))continue;const Y=a[j];E.setHasVertexColorAlpha(Y,i.hasVertexAlpha);const J=Y._buffer,u=x.get(J)||[];x.set(J,u),-1===u.indexOf(Y)&&u.push(Y);const b=e.get(Y)||[];e.set(Y,b),-1===b.indexOf(i)&&b.push(i)}const Y=i.morphTargetManager;if(Y)for(let x=0;x<Y.numTargets;x++){const e=Y.getTarget(x),E=j.get(e)||[];j.set(e,E),-1===E.indexOf(i)&&E.push(i)}}for(const a of i.getChildren())this._collectBuffers(a,x,e,j,E)}_exportBuffers(i,x){const e=new Map,j=new Map,E=new Map;for(const J of i)this._collectBuffers(J,e,j,E,x);const a=Array.from(e.keys());for(const J of a){const i=J.getData();if(!i)throw new Error("Buffer data is not available");const E=e.get(J);if(!E)continue;const a=E[0].byteStride;if(E.some((i=>i.byteStride!==a)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const Y=ei(i).slice();for(const x of E){const i=j.get(x),{byteOffset:e,byteStride:E,componentCount:a,type:J,count:u,normalized:b,kind:A}=r(x,i);switch(A){case g.f.NormalKind:case g.f.TangentKind:(0,p.j)(Y,e,E,a,J,u,b,(i=>{const x=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);if(x>0){const e=1/x;i[0]*=e,i[1]*=e,i[2]*=e}}));break;case g.f.ColorKind:{const x=i.filter((i=>i.material instanceof Mi.oJ||null==i.material)).length;if(0==x)break;if(x!=i.length){H.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}J==g.f.UNSIGNED_BYTE&&H.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const j=new z.MJ,A=new z.lJ,K=this._babylonScene.getEngine().useExactSrgbConversions;(0,p.j)(Y,e,E,a,J,u,b,(i=>{3===i.length?(j.AJ(i,0),j.toLinearSpaceToRef(j,K),j.toArray(i,0)):(A.AJ(i,0),A.toLinearSpaceToRef(A,K),A.toArray(i,0))}))}}}if(x.convertToRightHanded){for(const i of E){const x=j.get(i),{byteOffset:e,byteStride:E,componentCount:a,type:J,count:u,normalized:b,kind:A}=r(i,x);switch(A){case g.f.PositionKind:case g.f.NormalKind:case g.f.TangentKind:(0,p.j)(Y,e,E,a,J,u,b,(i=>{i[0]=-i[0]}))}}x.convertedToRightHandedBuffers.set(J,Y)}const u=this._bufferManager.createBufferView(Y,a);x.setVertexBufferView(J,u);const b=new Map;for(const x of E){const i=j.get(x),{kind:e,totalVertices:E}=r(x,i);switch(e){case g.f.MatricesIndicesKind:case g.f.MatricesIndicesExtraKind:if(x.type==g.f.FLOAT){const i=x.getFloatData(E);null!==i&&b.set(x,i)}}}0!==b.size&&H.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const A=Array.from(b.keys());for(const e of A){const i=b.get(e);if(!i)continue;const j=i.some((i=>i>=256)),E=new(j?Uint16Array:Uint8Array)(i.length);for(let x=0;x<i.length;x++)E[x]=i[x];const a=this._bufferManager.createBufferView(E,4*(j?2:1));x.setRemappedBufferView(J,e,a)}}const Y=Array.from(E.keys());for(const J of Y){const i=E.get(J);if(!i)continue;const e=Si(J,i[0],this._bufferManager,this._bufferViews,this._accessors,x.convertToRightHanded);for(const j of i)x.bindMorphDataToMesh(j,e)}}async _exportNodeAsync(i,x,e){let j=this._nodeMap.get(i);if(void 0!==j)return void(x.includes(j)||x.push(j));const E=await this._createNodeAsync(i,e);if(E){j=this._nodes.length,this._nodes.push(E),this._nodeMap.set(i,j),e.pushExportedNode(i),x.push(j);const a={name:"runtime animations",channels:[],samplers:[]},Y=[];this._babylonScene.animationGroups.length||(Vi._CreateMorphTargetAnimationFromMorphTargetAnimations(i,a,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,e.convertToRightHanded,this._options.shouldExportAnimation),i.animations.length&&Vi._CreateNodeAnimationFromNodeAnimations(i,a,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,e.convertToRightHanded,this._options.shouldExportAnimation)),a.channels.length&&a.samplers.length&&this._animations.push(a),Y.forEach((i=>{i.channels.length&&i.samplers.length&&this._animations.push(i)}))}const a=E?[]:x;for(const Y of i.getChildren())await this._exportNodeAsync(Y,a,e);E&&a.length&&(E.children=a)}async _createNodeAsync(i,x){if(!this._shouldExportNode(i))return null;const e={};if(i.name&&(e.name=i.name),i.metadata){const x=this._options.metadataSelector(i.metadata);x&&(e.extras=x)}if(i instanceof A.d&&(this._setNodeTransformation(e,i,x.convertToRightHanded),i instanceof K.e)){const E=i instanceof L.b?i.sourceMesh:i;if(E.ne&&E.ne.length>0&&(e.mesh=await this._exportMeshAsync(E,x)),i.skeleton){const x=this._skinMap.get(i.skeleton);var j;if(void 0!==x)void 0===this._nodesSkinMap.get(x)&&this._nodesSkinMap.set(x,[]),null===(j=this._nodesSkinMap.get(x))||void 0===j||j.push(e)}}if(i instanceof U.d){const j=this._camerasMap.get(i);if(j){var E;void 0===this._nodesCameraMap.get(j)&&this._nodesCameraMap.set(j,[]),this._setCameraTransformation(e,i,x.convertToRightHanded);const Y=i.parent;if(null!==Y&&xi(i,Y)){const i=this._nodeMap.get(Y);if(void 0!==i){var a;const x=this._nodes[i];return ii(e,x),null===(a=this._nodesCameraMap.get(j))||void 0===a||a.push(x),null}}null===(E=this._nodesCameraMap.get(j))||void 0===E||E.push(e)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",e,i,this._nodeMap,x.convertToRightHanded)?e:(H.c.Warn(`Not exporting node ${i.name}`),null)}_exportIndices(i,x,e,j,E,Y,J,u,b){let g=i;b.mode=q(Y);const A=J!==a.e.CounterClockWiseSideOrientation,K=!u.wasAddedByNoopNode&&A,L=function(i){switch(i){case a.e.TriangleFillMode:case a.e.TriangleStripDrawMode:case a.e.TriangleFanDrawMode:return!0}return!1}(Y)&&K;if(L){if(Y===a.e.TriangleStripDrawMode||Y===a.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");b.mode=q(Y);const J=x?new Uint32Array(j):new Uint16Array(j);if(i)for(let x=0;x+2<j;x+=3)J[x]=i[e+x]+E,J[x+1]=i[e+x+2]+E,J[x+2]=i[e+x+1]+E;else for(let i=0;i+2<j;i+=3)J[i]=i,J[i+1]=i+2,J[i+2]=i+1;g=J}else if(i&&0!==E){const a=x?new Uint32Array(j):new Uint16Array(j);for(let x=0;x<j;x++)a[x]=i[e+x]+E;g=a}if(g){let a=u.getIndicesAccessor(i,e,j,E,L);if(void 0===a){const Y=function(i,x,e,j){if(i instanceof Uint16Array||i instanceof Uint32Array)return i;if(i instanceof Int32Array)return new Uint32Array(i.buffer,i.byteOffset,i.length);const E=i.slice(x,x+e);return j?new Uint32Array(E):new Uint16Array(E)}(g,0,j,x),J=this._bufferManager.createBufferView(Y),b=x?5125:5123;this._accessors.push(this._bufferManager.createAccessor(J,"SCALAR",b,j,0)),a=this._accessors.length-1,u.setIndicesAccessor(i,e,j,E,L,a)}b.indices=a}}_exportVertexBuffer(i,x,e,j,E,a){const Y=i.getKind();if(!P(Y))return;if(Y.startsWith("uv")&&!this._options.exportUnusedUVs&&(!x||!this._materialNeedsUVsSet.has(x)))return;let J=E.getVertexAccessor(i,e,j);if(void 0===J){const x=E.convertedToRightHandedBuffers.get(i._buffer)||i._buffer.getData(),a=Y===g.f.PositionKind?function(i,x,e,j){const{byteOffset:E,byteStride:a,type:Y,normalized:J}=x,u=x.getSize(),b=new Array(u).fill(1/0),g=new Array(u).fill(-1/0);return(0,p.j)(i,E+e*a,a,u,Y,j*u,J,(i=>{for(let x=0;x<u;x++)b[x]=Math.min(b[x],i[x]),g[x]=Math.max(g[x],i[x])})),{min:b,max:g}}(x,i,e,j):void 0,u=(Y===g.f.MatricesIndicesKind||Y===g.f.MatricesIndicesExtraKind)&&i.type===g.f.FLOAT,b=u?g.f.UNSIGNED_BYTE:i.type,A=u?void 0:i.normalized,K=u?E.getRemappedBufferView(i._buffer,i):E.getVertexBufferView(i._buffer),L=i.byteOffset+e*i.byteStride;this._accessors.push(this._bufferManager.createAccessor(K,function(i,x){if(i==g.f.ColorKind)return x?"VEC4":"VEC3";switch(i){case g.f.PositionKind:case g.f.NormalKind:return"VEC3";case g.f.TangentKind:case g.f.MatricesIndicesKind:case g.f.MatricesIndicesExtraKind:case g.f.MatricesWeightsKind:case g.f.MatricesWeightsExtraKind:return"VEC4";case g.f.UVKind:case g.f.UV2Kind:case g.f.UV3Kind:case g.f.UV4Kind:case g.f.UV5Kind:case g.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${i}`)}(Y,E.hasVertexColorAlpha(i)),b,j,L,a,A)),J=this._accessors.length-1,E.setVertexAccessor(i,e,j,J)}a.attributes[function(i){switch(i){case g.f.PositionKind:return"POSITION";case g.f.NormalKind:return"NORMAL";case g.f.TangentKind:return"TANGENT";case g.f.ColorKind:return"COLOR_0";case g.f.UVKind:return"TEXCOORD_0";case g.f.UV2Kind:return"TEXCOORD_1";case g.f.UV3Kind:return"TEXCOORD_2";case g.f.UV4Kind:return"TEXCOORD_3";case g.f.UV5Kind:return"TEXCOORD_4";case g.f.UV6Kind:return"TEXCOORD_5";case g.f.MatricesIndicesKind:return"JOINTS_0";case g.f.MatricesIndicesExtraKind:return"JOINTS_1";case g.f.MatricesWeightsKind:return"WEIGHTS_0";case g.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${i}`)}(Y)]=J}async _exportMaterialAsync(i,x,e,j){let E=this._materialMap.get(i);if(void 0===E){const j=x&&Object.keys(x).some((i=>i.startsWith("uv")));if((i=i instanceof Li.b?i.ZJ[e.materialIndex]:i)instanceof oi.e)E=await this._materialExporter.exportPBRMaterialAsync(i,"image/png",j);else{if(!(i instanceof Mi.oJ))return void H.c.Warn(`Unsupported material '${i.name}' with type ${i.getClassName()}`);E=await this._materialExporter.exportStandardMaterialAsync(i,"image/png",j)}this._materialMap.set(i,E)}j.material=E}async _exportMeshAsync(i,x){var e;let j=x.getMesh(i);if(void 0!==j)return j;const E={primitives:[]};j=this._meshes.length,this._meshes.push(E),x.setMesh(i,j);const Y=i.isUnIndexed?null:i.Pe(),J=null===(e=i.ye)||void 0===e?void 0:e.getVertexBuffers(),u=x.getMorphTargetsFromMesh(i),b=i instanceof fi.b,g=i instanceof hi,A=i.ne;if(J&&A&&A.length>0)for(const o of A){const e={attributes:{}},j=o.di()||this._babylonScene.defaultMaterial;if(g){var K,L;const x={name:j.name},E=i,a=z.MJ.White(),Y=(null===(K=E.material)||void 0===K?void 0:K.alpha)??1,J=(null===(L=E.greasedLineMaterial)||void 0===L?void 0:L.color)??a;(!J.equalsWithEpsilon(a,D.e)||Y<1)&&(x.pbrMetallicRoughness={baseColorFactor:[...J.de(),Y]}),this._materials.push(x),e.material=this._materials.length-1}else if(b){const x={name:j.name},E=i;(!E.color.equalsWithEpsilon(z.MJ.White(),D.e)||E.alpha<1)&&(x.pbrMetallicRoughness={baseColorFactor:[...E.color.de(),E.alpha]}),this._materials.push(x),e.material=this._materials.length-1}else await this._exportMaterialAsync(j,J,o,e);const A=b||g?a.e.LineListDrawMode:i.overrideRenderingFillMode??j.fillMode,M=j._getEffectiveOrientation(i);this._exportIndices(Y,Y?(0,p.e)(Y,o.indexCount,o.indexStart,o.verticesStart):o.verticesCount>65535,Y?o.indexStart:o.verticesStart,Y?o.indexCount:o.verticesCount,-o.verticesStart,A,M,x,e);for(const i of Object.values(J))this._exportVertexBuffer(i,j,o.verticesStart,o.verticesCount,x,e);if(u){e.targets=[];for(const i of u)e.targets.push(i.attributes)}E.primitives.push(e),this._extensionsPostExportMeshPrimitive(e)}if(u){E.weights=[],E.extras||(E.extras={}),E.extras.targetNames=[];for(const i of u)E.weights.push(i.influence),E.extras.targetNames.push(i.name)}return j}}Ri._ExtensionNames=new Array,Ri._ExtensionFactories={};class yi{static async GLTFAsync(i,x,e){e&&e.exportWithoutWaitingForScene||await i.whenReadyAsync();const j=new Ri(i,e),E=await j.generateGLTFAsync(x.replace(/\.[^/.]+$/,""));return j.dispose(),E}static async GLBAsync(i,x,e){e&&e.exportWithoutWaitingForScene||await i.whenReadyAsync();const j=new Ri(i,e),E=await j.generateGLBAsync(x.replace(/\.[^/.]+$/,""));return j.dispose(),E}}e(12789);const ri="EXT_mesh_gpu_instancing";class ci{constructor(i){this.name=ri,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=i}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(i,x,e,E,a,Y){return await new Promise((i=>{if(x&&e instanceof Qi.c&&e.hasThinInstances&&this._exporter){this._wasUsed=!0;const i=j.KJ.Zero(),E=j.Quaternion.Identity(),J=j.KJ.One(),u=e.thinInstanceGetWorldMatrices(),b=j.TmpVectors.KJ[2],g=j.TmpVectors.Quaternion[1],A=j.TmpVectors.KJ[3];let K=!1,L=!1,o=!1;const M=new Float32Array(3*e.BJ),z=new Float32Array(4*e.BJ),T=new Float32Array(3*e.BJ);let Q=0;for(const x of u)x.decompose(A,g,b),a&&(G(b),v(g)),M.set(b.de(),3*Q),z.set(g.normalize().de(),4*Q),T.set(A.de(),3*Q),K=K||!b.equalsWithEpsilon(i),L=L||!g.equalsWithEpsilon(E),o=o||!A.equalsWithEpsilon(J),Q++;const t={attributes:{}};K&&(t.attributes.TRANSLATION=this._buildAccessor(M,"VEC3",e.BJ,Y)),L&&(t.attributes.ROTATION=this._buildAccessor(z,"VEC4",e.BJ,Y)),o&&(t.attributes.SCALE=this._buildAccessor(T,"VEC3",e.BJ,Y)),x.extensions=x.extensions||{},x.extensions[ri]=t}i(x)}))}_buildAccessor(i,x,e,j){const E=j.createBufferView(i),a=j.createAccessor(E,x,5126,e);return this._exporter._accessors.push(a),this._exporter._accessors.length-1}}Ri.RegisterExtension(ri,(i=>new ci(i)));var Pi=e(12793),qi=e(12807),Wi=e(12814),Gi=e(12817);function vi(i){return i===Wi.d.PositionKind?"POSITION":i===Wi.d.NormalKind?"NORMAL":i===Wi.d.ColorKind?"COLOR":i.startsWith(Wi.d.UVKind)?"TEX_COORD":"GENERIC"}const si={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class ix extends Pi.d{static get DefaultAvailable(){return(0,Pi.h)(ix.DefaultConfiguration)}static get Default(){return ix._Default??(ix._Default=new ix),ix._Default}static ResetDefault(i){ix._Default&&(i||ix._Default.dispose(),ix._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(i,x){return{module:await(x||DracoEncoderModule)({wasmBinary:i})}}_getWorkerContent(){return`${qi.g}(${qi.h})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:ix.DefaultConfiguration)}async _encodeAsync(i,x,e){const j=e?(0,Gi.b)(si,e):si;if(this._workerPoolPromise){const e=await this._workerPoolPromise;return await new Promise(((E,a)=>{e.push(((e,Y)=>{const J=i=>{e.removeEventListener("error",J),e.removeEventListener("message",u),a(i),Y()},u=i=>{"encodeMeshDone"===i.data.id&&(e.removeEventListener("error",J),e.removeEventListener("message",u),E(i.data.encodedMeshData),Y())};e.addEventListener("error",J),e.addEventListener("message",u);const b=[];for(const x of i)b.push(x.data.buffer);x&&b.push(x.buffer),e.postMessage({id:"encodeMesh",attributes:i,indices:x,options:j},b)}))}))}if(this._modulePromise){const e=await this._modulePromise;return(0,qi.g)(e.module,i,x,j)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(i,x){if(0==i.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");i instanceof Qi.c&&i.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===x||void 0===x?void 0:x.method)&&(H.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),x.method="MESH_SEQUENTIAL_ENCODING");const e=function(i){let x=i.Pe(void 0,!0);return!x||x instanceof Uint32Array||x instanceof Uint16Array||(x=((0,p.e)(x,x.length)?Uint32Array:Uint16Array).from(x)),x}(i),j=function(i,x){const e=[];for(const j of i.getVerticesDataKinds()){if(null!==x&&void 0!==x&&x.includes(j)){if(j===Wi.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const E=i.getVertexBuffer(j),a=E.getSize(),Y=(0,p.u)(E.getData(),a,E.type,E.byteOffset,E.byteStride,E.normalized,i.getTotalVertices(),!0);e.push({kind:j,dracoName:vi(j),size:a,data:Y})}return e}(i,null===x||void 0===x?void 0:x.excludedAttributes);return await this._encodeAsync(j,e,x)}}ix.DefaultConfiguration={wasmUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder.js`},ix._Default=null;const xx="KHR_draco_mesh_compression";class ex{get wasUsed(){return this._wasUsed}constructor(i){this.name=xx,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===i.options.meshCompressionMethod&&ix.DefaultAvailable}dispose(){}postExportMeshPrimitive(i,x,e){if(!this.enabled)return;if(4!==i.mode&&5!==i.mode)return void H.c.Warn("Cannot compress primitive with mode "+i.mode+".");const j=[],E=[];let a=null;if(void 0!==i.indices){const Y=e[i.indices],J=x.getBufferView(Y);a=x.getData(J).slice(),j.push(J),E.push(Y)}const Y=[];for(const[g,A]of Object.entries(i.attributes)){const i=e[A],a=x.getBufferView(i),u=c(i.type),b=(0,p.u)(x.getData(a),u,i.componentType,i.byteOffset||0,a.byteStride||(0,p.m)(i.componentType)*u,i.normalized||!1,i.count,!0);Y.push({kind:g,dracoName:(J=g,"POSITION"===J?"POSITION":"NORMAL"===J?"NORMAL":J.startsWith("COLOR")?"COLOR":J.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:c(i.type),data:b}),j.push(a),E.push(i)}var J;const u={method:i.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},b=ix.Default._encodeAsync(Y,a,u).then((e=>{if(!e)return void H.c.Error("Draco encoding failed for primitive.");const a={bufferView:-1,attributes:e.attributeIds},Y=x.createBufferView(e.data);x.setBufferView(a,Y);for(const i of j)this._bufferViewsUsed.add(i);for(const i of E)this._accessorsUsed.add(i);i.extensions||(i.extensions={}),i.extensions[xx]=a})).catch((i=>{H.c.Error("Draco encoding failed for primitive: "+i)}));this._encodePromises.push(b),this._wasUsed=!0}async preGenerateBinaryAsync(i){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((x=>{i.getPropertiesWithBufferView(x).every((i=>this._accessorsUsed.has(i)))&&i.removeBufferView(x)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Ri.RegisterExtension(xx,(i=>new ex(i)));var jx=e(12819);const Ex="KHR_lights_punctual",ax={name:"",color:[1,1,1],kJ:1,range:Number.MAX_VALUE},Yx={innerConeAngle:0,outerConeAngle:Math.PI/4},Jx=j.KJ.Backward();class ux{constructor(i){this.name=Ex,this.enabled=!0,this.required=!1,this._exporter=i}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Ex]=this._lights}async postExportNodeAsync(i,x,e,E,a){return await new Promise((Y=>{if(!(e instanceof ti.e))return void Y(x);const J=e.getTypeID()==ti.e.LIGHTTYPEID_POINTLIGHT?"point":e.getTypeID()==ti.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":e.getTypeID()==ti.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!J||!(e instanceof jx.c))return H.c.Warn(`${i}: Light ${e.name} is not supported in ${Ex}`),void Y(x);if(e.falloffType!==ti.e.FALLOFF_GLTF&&H.c.Warn(`${i}: Light falloff for ${e.name} does not match the ${Ex} specification!`),!e.position.equalsToFloats(0,0,0)){const i=j.TmpVectors.KJ[0].A(e.position);a&&G(i),x.translation=i.de()}if("point"!==J){const i=e.direction.normalizeToRef(j.TmpVectors.KJ[0]);a&&G(i);const E=j.Quaternion.FromUnitVectorsToRef(Jx,i,j.TmpVectors.Quaternion[0]);j.Quaternion.IsIdentity(E)||(x.rotation=E.de())}const u={type:J,name:e.name,color:e.NJ.de(),kJ:e.kJ,range:e.range};if(ji(u,ax),"spot"===J){const i=e;u.spot={innerConeAngle:i.innerAngle/2,outerConeAngle:i.angle/2},ji(u.spot,Yx)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(u);const b={ae:this._lights.lights.length-1},g=e.parent;if(g&&xi(e,g)){const i=E.get(g);if(i){const e=this._exporter._nodes[i];return ii(x,e),e.extensions||(e.extensions={}),e.extensions[Ex]=b,void Y(null)}}x.extensions||(x.extensions={}),x.extensions[Ex]=b,Y(x)}))}}Ri.RegisterExtension(Ex,(i=>new ux(i)));var bx=e(12735);const gx="KHR_materials_anisotropy";class Ax{constructor(i){this.name=gx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=i}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(i,x,e){const j=[];return e instanceof bx.b&&e.anisotropy.isEnabled&&!e.anisotropy.legacy?(e.anisotropy.texture&&j.push(e.anisotropy.texture),j):[]}postExportMaterialAsync(i,x,e){return new Promise((i=>{if(e instanceof bx.b){if(!e.anisotropy.isEnabled||e.anisotropy.legacy)return void i(x);this._wasUsed=!0,x.extensions=x.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(e.anisotropy.texture),E={anisotropyStrength:e.anisotropy.kJ,anisotropyRotation:e.anisotropy.angle,anisotropyTexture:j??void 0};null!==E.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(e),x.extensions[gx]=E}i(x)}))}}Ri.RegisterExtension(gx,(i=>new Ax(i)));const Kx="KHR_materials_clearcoat";class Lx{constructor(i){this.name=Kx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=i}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(i,x,e){const j=[];return e instanceof bx.b&&e.clearCoat.isEnabled?(e.clearCoat.texture&&j.push(e.clearCoat.texture),!e.clearCoat.useRoughnessFromMainTexture&&e.clearCoat.textureRoughness&&j.push(e.clearCoat.textureRoughness),e.clearCoat.bumpTexture&&j.push(e.clearCoat.bumpTexture),j):[]}postExportMaterialAsync(i,x,e){return new Promise((i=>{if(e instanceof bx.b){if(!e.clearCoat.isEnabled)return void i(x);this._wasUsed=!0,x.extensions=x.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(e.clearCoat.texture);let a;a=e.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(e.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(e.clearCoat.textureRoughness),e.clearCoat.isTintEnabled&&E.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${e.name}`),e.clearCoat.remapF0OnInterfaceChange&&E.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${e.name}`);const Y=this._exporter._materialExporter.getTextureInfo(e.clearCoat.bumpTexture),J={clearcoatFactor:e.clearCoat.kJ,clearcoatTexture:j??void 0,clearcoatRoughnessFactor:e.clearCoat.roughness,clearcoatRoughnessTexture:a??void 0,clearcoatNormalTexture:Y??void 0};null===J.clearcoatTexture&&null===J.clearcoatRoughnessTexture&&null===J.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(e),x.extensions[Kx]=J}i(x)}))}}Ri.RegisterExtension(Kx,(i=>new Lx(i)));const ox="KHR_materials_diffuse_transmission";function Mx(i,x){const e=x.subSurface;let j=null;return e.translucencyIntensityTexture?j=e.translucencyIntensityTexture:e.thicknessTexture&&e.useMaskFromThicknessTexture&&(j=e.thicknessTexture),j&&!e.useGltfStyleTextures?(H.c.Warn(`${i}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${x.name}`,1),null):j}class zx{constructor(i){this.name=ox,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=i}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(i,x,e){const j=[];if(e instanceof oi.e&&this._isExtensionEnabled(e)){const x=Mx(i,e);return x&&j.push(x),e.subSurface.translucencyColorTexture&&j.push(e.subSurface.translucencyColorTexture),j}return j}_isExtensionEnabled(i){if(i.unlit)return!1;const x=i.subSurface;return!!x.isTranslucencyEnabled&&(!i.unlit&&!x.useAlbedoToTintTranslucency&&x.useGltfStyleTextures&&1===x.volumeIndexOfRefraction&&0===x.minimumThickness&&0===x.maximumThickness)}postExportMaterialAsync(i,x,e){return new Promise((j=>{if(e instanceof oi.e&&this._isExtensionEnabled(e)){this._wasUsed=!0;const j=e.subSurface,E=Mx(i,e),a=0==j.translucencyIntensity?void 0:j.translucencyIntensity,Y=this._exporter._materialExporter.getTextureInfo(E)??void 0,J=!j.translucencyColor||j.translucencyColor.equalsFloats(1,1,1)?void 0:j.translucencyColor.de(),u=this._exporter._materialExporter.getTextureInfo(j.translucencyColorTexture)??void 0,b={diffuseTransmissionFactor:a,diffuseTransmissionTexture:Y,diffuseTransmissionColorFactor:J,diffuseTransmissionColorTexture:u};(Y||u)&&this._exporter._materialNeedsUVsSet.add(e),x.extensions=x.extensions||{},x.extensions[ox]=b}j(x)}))}}Ri.RegisterExtension(ox,(i=>new zx(i)));const Tx="KHR_materials_dispersion";class Qx{constructor(){this.name=Tx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(i){if(i.unlit)return!1;const x=i.subSurface;return!(!x.isRefractionEnabled&&!x.isDispersionEnabled)}postExportMaterialAsync(i,x,e){return new Promise((i=>{if(e instanceof oi.e&&this._isExtensionEnabled(e)){this._wasUsed=!0;const i={dispersion:e.subSurface.dispersion};x.extensions=x.extensions||{},x.extensions[Tx]=i}i(x)}))}}Ri.RegisterExtension(Tx,(()=>new Qx));const tx="KHR_materials_emissive_strength";class Vx{constructor(){this.name=tx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(i,x,e){return await new Promise((i=>{if(!(e instanceof oi.e))return i(x);const j=e.emissiveColor.de(),E=Math.max(...j);if(E>1){this._wasUsed=!0,x.extensions||(x.extensions={});const i={emissiveStrength:E},j=e.emissiveColor.scale(1/i.emissiveStrength);x.emissiveFactor=j.de(),x.extensions[tx]=i}return i(x)}))}}Ri.RegisterExtension(tx,(i=>new Vx));const Sx="KHR_materials_ior";class fx{constructor(){this.name=Sx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(i){return!i.unlit&&(void 0!=i.indexOfRefraction&&1.5!=i.indexOfRefraction)}postExportMaterialAsync(i,x,e){return new Promise((i=>{if(e instanceof oi.e&&this._isExtensionEnabled(e)){this._wasUsed=!0;const i={ior:e.indexOfRefraction};x.extensions=x.extensions||{},x.extensions[Sx]=i}i(x)}))}}Ri.RegisterExtension(Sx,(i=>new fx));const wx="KHR_materials_iridescence";class Ox{constructor(i){this.name=wx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=i}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(i,x,e){const j=[];return e instanceof bx.b&&e.iridescence.isEnabled?(e.iridescence.texture&&j.push(e.iridescence.texture),e.iridescence.thicknessTexture&&e.iridescence.thicknessTexture!==e.iridescence.texture&&j.push(e.iridescence.thicknessTexture),j):[]}postExportMaterialAsync(i,x,e){return new Promise((i=>{if(e instanceof bx.b){if(!e.iridescence.isEnabled)return void i(x);this._wasUsed=!0,x.extensions=x.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(e.iridescence.texture),E=this._exporter._materialExporter.getTextureInfo(e.iridescence.thicknessTexture),a={iridescenceFactor:e.iridescence.kJ,iridescenceIor:e.iridescence.indexOfRefraction,iridescenceThicknessMinimum:e.iridescence.minimumThickness,iridescenceThicknessMaximum:e.iridescence.maximumThickness,iridescenceTexture:j??void 0,iridescenceThicknessTexture:E??void 0};null===a.iridescenceTexture&&null===a.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(e),x.extensions[wx]=a}i(x)}))}}Ri.RegisterExtension(wx,(i=>new Ox(i)));const lx="KHR_materials_sheen";class Zx{constructor(i){this.name=lx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=i}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(i,x,e){return e instanceof oi.e&&e.sheen.isEnabled&&e.sheen.texture?[e.sheen.texture]:[]}async postExportMaterialAsync(i,x,e){return await new Promise((i=>{if(e instanceof oi.e){if(!e.sheen.isEnabled)return void i(x);this._wasUsed=!0,null==x.extensions&&(x.extensions={});const j={sheenColorFactor:e.sheen.color.de(),sheenRoughnessFactor:e.sheen.roughness??0};null===j.sheenColorTexture&&null===j.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(e),e.sheen.texture&&(j.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(e.sheen.texture)??void 0),e.sheen.textureRoughness&&!e.sheen.useRoughnessFromMainTexture?j.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(e.sheen.textureRoughness)??void 0:e.sheen.texture&&e.sheen.useRoughnessFromMainTexture&&(j.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(e.sheen.texture)??void 0),x.extensions[lx]=j}i(x)}))}}Ri.RegisterExtension(lx,(i=>new Zx(i)));const Bx="KHR_materials_specular";class kx{constructor(i){this.name=Bx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=i}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(i,x,e){const j=[];return e instanceof oi.e&&this._isExtensionEnabled(e)?(e.metallicReflectanceTexture&&j.push(e.metallicReflectanceTexture),e.reflectanceTexture&&j.push(e.reflectanceTexture),j):j}_isExtensionEnabled(i){return!i.unlit&&(void 0!=i.metallicF0Factor&&1!=i.metallicF0Factor||void 0!=i.metallicReflectanceColor&&!i.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(i))}_hasTexturesExtension(i){return null!=i.metallicReflectanceTexture||null!=i.reflectanceTexture}postExportMaterialAsync(i,x,e){return new Promise((i=>{if(e instanceof oi.e&&this._isExtensionEnabled(e)){this._wasUsed=!0,x.extensions=x.extensions||{};const i=this._exporter._materialExporter.getTextureInfo(e.metallicReflectanceTexture)??void 0,j=this._exporter._materialExporter.getTextureInfo(e.reflectanceTexture)??void 0,E={specularFactor:1==e.metallicF0Factor?void 0:e.metallicF0Factor,specularTexture:i,specularColorFactor:e.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:e.metallicReflectanceColor.de(),specularColorTexture:j};this._hasTexturesExtension(e)&&this._exporter._materialNeedsUVsSet.add(e),x.extensions[Bx]=E}i(x)}))}}Ri.RegisterExtension(Bx,(i=>new kx(i)));const Nx="KHR_materials_transmission";class me{constructor(i){this.name=Nx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=i}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(i,x,e){const j=[];return e instanceof oi.e&&this._isExtensionEnabled(e)?(e.subSurface.thicknessTexture&&j.push(e.subSurface.thicknessTexture),j):j}_isExtensionEnabled(i){if(i.unlit)return!1;const x=i.subSurface;return x.isRefractionEnabled&&void 0!=x.refractionIntensity&&0!=x.refractionIntensity||this._hasTexturesExtension(i)}_hasTexturesExtension(i){return null!=i.subSurface.refractionIntensityTexture}async postExportMaterialAsync(i,x,e){if(e instanceof oi.e&&this._isExtensionEnabled(e)){this._wasUsed=!0;const j=e.subSurface,E={transmissionFactor:0===j.refractionIntensity?void 0:j.refractionIntensity};if(this._hasTexturesExtension(e)&&this._exporter._materialNeedsUVsSet.add(e),j.refractionIntensityTexture)if(j.useGltfStyleTextures){const i=await this._exporter._materialExporter.exportTextureAsync(j.refractionIntensityTexture,"image/png");i&&(E.transmissionTexture=i)}else H.c.Warn(`${i}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);x.extensions||(x.extensions={}),x.extensions[Nx]=E}return x}}Ri.RegisterExtension(Nx,(i=>new me(i)));const Xx="KHR_materials_unlit";class Cx{constructor(){this.name=Xx,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(i,x,e){return new Promise((i=>{let j=!1;e instanceof oi.e?j=e.unlit:e instanceof Mi.oJ&&(j=e.disableLighting),j&&(this._wasUsed=!0,null==x.extensions&&(x.extensions={}),x.extensions[Xx]={}),i(x)}))}}Ri.RegisterExtension(Xx,(()=>new Cx));const nx="KHR_materials_volume";class Ix{constructor(i){this.name=nx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=i}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(i,x,e){const j=[];return e instanceof oi.e&&this._isExtensionEnabled(e)?(e.subSurface.thicknessTexture&&j.push(e.subSurface.thicknessTexture),j):j}_isExtensionEnabled(i){if(i.unlit)return!1;const x=i.subSurface;return!(!x.isRefractionEnabled&&!x.isTranslucencyEnabled)&&(void 0!=x.maximumThickness&&0!=x.maximumThickness||void 0!=x.tintColorAtDistance&&x.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=x.tintColor&&x.tintColor!=z.MJ.White()||this._hasTexturesExtension(i))}_hasTexturesExtension(i){return null!=i.subSurface.thicknessTexture}postExportMaterialAsync(i,x,e){return new Promise((i=>{if(e instanceof oi.e&&this._isExtensionEnabled(e)){this._wasUsed=!0;const i=e.subSurface,j={thicknessFactor:0==i.maximumThickness?void 0:i.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(i.thicknessTexture)??void 0,attenuationDistance:i.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:i.tintColorAtDistance,attenuationColor:i.tintColor.equalsFloats(1,1,1)?void 0:i.tintColor.de()};this._hasTexturesExtension(e)&&this._exporter._materialNeedsUVsSet.add(e),x.extensions=x.extensions||{},x.extensions[nx]=j}i(x)}))}}Ri.RegisterExtension(nx,(i=>new Ix(i)));const dx="EXT_materials_diffuse_roughness";class px{constructor(i){this.name=dx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=i}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(i,x,e){const j=[];return e instanceof bx.b&&e._baseDiffuseRoughness?(e._baseDiffuseRoughnessTexture&&j.push(e._baseDiffuseRoughnessTexture),j):[]}postExportMaterialAsync(i,x,e){return new Promise((i=>{if(e instanceof bx.b){if(!e._baseDiffuseRoughness)return void i(x);this._wasUsed=!0,x.extensions=x.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(e._baseDiffuseRoughnessTexture),E={diffuseRoughnessFactor:e._baseDiffuseRoughness,diffuseRoughnessTexture:j??void 0};null!==E.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(e),x.extensions[dx]=E}i(x)}))}}Ri.RegisterExtension(dx,(i=>new px(i)));const Hx="KHR_texture_transform";class Ux{constructor(){this.name=Hx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(i,x,e){if(e.wi()||E.Tools.Warn(`${i}: /*@__KEY__*/"scene" is not defined for Babylon texture ${e.name}!`),(0!==e.uAng||0!==e.vAng)&&(E.Tools.Warn(`${i}: Texture ${e.name} with rotation in the u or v axis is not supported in glTF.`),0!==e.uRotationCenter||0!==e.vRotationCenter))return;const j={};let a=!1;if(0===e.uOffset&&0===e.vOffset||(j.offset=[e.uOffset,e.vOffset],a=!0),1===e.uScale&&1===e.vScale||(j.scale=[e.uScale,e.vScale],a=!0),0!==e.wAng){if(0!==e.uRotationCenter||0!==e.vRotationCenter){if(e.homogeneousRotationInUVTransform&&e.uScale!==e.vScale)return void E.Tools.Warn(`${i}: Texture ${e.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Hx}.`);E.Tools.Warn(`${i}: Texture ${e.name} with non-origin rotation center will be exported using an adjusted offset with ${Hx}.`),j.offset=function(i){const{uOffset:x,vOffset:e,uRotationCenter:j,vRotationCenter:E,uScale:a,vScale:Y,wAng:J}=i,u=Math.cos(J),b=Math.sin(J),g=j*a,A=E*Y;return[x+(g*(1-u)+A*b),e+(A*(1-u)-g*b)]}(e)}j.rotation=-e.wAng,a=!0}0!==e.coordinatesIndex&&(j.texCoord=e.coordinatesIndex,a=!0),a&&(this._wasUsed=!0,x.extensions||(x.extensions={}),x.extensions[Hx]=j)}}Ri.RegisterExtension(Hx,(()=>new Ux));class Dx{static CreateSTL(i){let x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],Y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],J=arguments.length>6&&void 0!==arguments[6]&&arguments[6],u=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const b=function(i,x,e){const E=[3*i[e],3*i[e+1],3*i[e+2]],a=[new j.KJ(x[E[0]],x[E[0]+2],x[E[0]+1]),new j.KJ(x[E[1]],x[E[1]+2],x[E[1]+1]),new j.KJ(x[E[2]],x[E[2]+2],x[E[2]+1])],Y=a[0].Cx(a[1]),J=a[2].Cx(a[1]);return{v:a,n:j.KJ.Cross(J,Y).normalize()}},A=function(i,x,e,j){return x=K(i,x,e.x,j),x=K(i,x,e.y,j),K(i,x,e.z,j)},K=function(i,x,e,j){return i.setFloat32(x,e,j),x+4},o=function(i){if(J){let x=i;i instanceof L.b&&(x=i.sourceMesh);const e=x.getVerticesData(g.f.PositionKind,!0,!0);if(!e)return[];const E=j.KJ.Zero();let a;for(a=0;a<e.length;a+=3)j.KJ.TransformCoordinatesFromFloatsToRef(e[a],e[a+1],e[a+2],i.Re(!0),E).toArray(e,a);return e}return i.getVerticesData(g.f.PositionKind)||[]};J&&(Y=!0);let M="",z=0,T=0;if(E){for(let e=0;e<i.length;e++){const x=i[e].Pe();z+=x?x.length/3:0}const x=new ArrayBuffer(84+50*z);M=new DataView(x),T+=80,M.setUint32(T,z,a),T+=4}else u||(M="solid stlmesh\r\n");for(let j=0;j<i.length;j++){const x=i[j];!E&&u&&(M+="solid "+x.name+"\r\n"),!Y&&x instanceof Qi.c&&x.bakeCurrentTransformIntoVertices();const e=o(x),J=x.Pe()||[];for(let i=0;i<J.length;i+=3){const x=b(J,e,i);E?(T=A(M,T,x.n,a),T=A(M,T,x.v[0],a),T=A(M,T,x.v[1],a),T=A(M,T,x.v[2],a),T+=2):(M+="\tfacet normal "+x.n.x+" "+x.n.y+" "+x.n.z+"\r\n",M+="\t\touter loop\r\n",M+="\t\t\tvertex "+x.v[0].x+" "+x.v[0].y+" "+x.v[0].z+"\r\n",M+="\t\t\tvertex "+x.v[1].x+" "+x.v[1].y+" "+x.v[1].z+"\r\n",M+="\t\t\tvertex "+x.v[2].x+" "+x.v[2].y+" "+x.v[2].z+"\r\n",M+="\t\tendloop\r\n",M+="\tendfacet\r\n")}!E&&u&&(M+="endsolid "+name+"\r\n")}if(E||u||(M+="endsolid stlmesh"),x){const i=document.createElement("a"),x=new Blob([M],{type:"application/octet-stream"});i.href=window.URL.createObjectURL(x),i.download=e+".stl",i.click()}return M}}function hx(i,x){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const j=[];for(let E=0;E<i.length/e;E++){const a=i[E*e],Y=i[E*e+1],J=i[E*e+2];j.push(`(${a.toPrecision(x.precision)}, ${Y.toPrecision(x.precision)}, ${J.toPrecision(x.precision)})`)}return j.join(", ")}function Fx(i,x){const e=[];for(let j=0;j<i.length/2;j++){const E=i[2*j],a=i[2*j+1];e.push(`(${E.toPrecision(x.precision)}, ${(1-a).toPrecision(x.precision)})`)}return e.join(", ")}function Rx(i,x){const e=i.getVerticesData(g.f.PositionKind),j=i.getVerticesData(g.f.NormalKind);if(e&&j)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(i){var x;const e=null!==(x=i.Pe())&&void 0!==x&&x.length?i.getTotalIndices():i.getTotalVertices();return Array(e/3).fill(3).join(", ")}(i)}]\n\t\tint[] faceVertexIndices = [${function(i){const x=i.Pe(),e=[];if(null!==x)for(let j=0;j<x.length;j++)e.push(x[j]);else{const x=i.getTotalVertices();for(let i=0;i<x;i++)e.push(i)}return e.join(", ")}(i)}]\n\t\tnormal3f[] normals = [${hx(j,x)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${hx(e,x)}]\n        ${function(i,x){let e="";for(let E=0;E<4;E++){const j=E>0?E:"",a=i.getVerticesData(g.f.UVKind+(j?j+1:""));a&&(e+=`\n\t\ttexCoord2f[] primvars:st${j} = [${Fx(a,x)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const j=i.getVerticesData(g.f.ColorKind);return j&&(e+=`\n\tcolor3f[] primvars:displayColor = [${hx(j,x,j.length/i.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),e}(i,x)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function yx(i,x){return`\n        def "Geometry"\n        {\n        ${Rx(i,x)}\n        }\n        `}function rx(i){let x='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return x+=i,fflate.strToU8(x)}function cx(i){const x=i.m;return`( ${Px(x,0)}, ${Px(x,4)}, ${Px(x,8)}, ${Px(x,12)} )`}function Px(i,x){return`(${i[x+0]}, ${i[x+1]}, ${i[x+2]}, ${i[x+3]})`}function qx(i){const x="Object_"+i.uniqueId,e=function(i){const x=i.getWorldMatrix().clone(),e=i.wi().useRightHandedSystem;if(!e){let j=i.parent;for(;j;){if(Yi(j,e)){x.multiplyToRef(j.getWorldMatrix().invert(),x);break}j=j.parent}}return x.determinant()<0&&E.Tools.Warn(`Exporting mesh ${i.name} with negative scale. Result may look incorrect in destination engine.`),x}(i),j=cx(e);return`def Xform "${x}" (\n\tprepend references = @./geometries/Geometry_${i.ye.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${j}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${i.material.uniqueId}>\n}\n\n`}function Wx(i){switch(i){case w.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case w.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case w.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Gx(i){return`(${i.x}, ${i.y})`}function vx(i){return`(${i.r}, ${i.g}, ${i.b})`}function sx(i,x,e,E,a,Y){const J=i.getInternalTexture().uniqueId+"_"+i.invertY;a[J]=i;const u=i.coordinatesIndex>0?"st"+i.coordinatesIndex:"st",b=new j.Vector2(i.uScale,i.vScale),g=new j.Vector2(i.uOffset,i.vOffset),A=i.wAng,K=Math.sin(A),L=Math.cos(A);return g.y=1-g.y-b.y,g.x+=K*b.x,g.y+=(1-L)*b.y,`\n    def Shader "PrimvarReader_${e}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${u}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${e}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${x.uniqueId}/PrimvarReader_${e}.outputs:result>\n        float inputs:rotation = ${(A*(180/Math.PI)).toFixed(Y.precision)}\n        float2 inputs:scale = ${Gx(b)}\n        float2 inputs:translation = ${Gx(g)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${i.uniqueId}_${e}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${J}.png@\n        float2 inputs:st.connect = </Materials/Material_${x.uniqueId}/Transform2d_${e}.outputs:result>\n        ${E?"float4 inputs:scale = "+function(i){return`(${i.r}, ${i.g}, ${i.b}, 1.0)`}(E):""}\n        token inputs:sourceColorSpace = "${i.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Wx(i.wrapU)}"\n        token inputs:wrapT = "${Wx(i.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${x.needAlphaBlending()?"float outputs:a":""}\n    }`}function ie(i,x,e){const j="\t\t\t",E=[],a=[],{diffuseMap:Y,NJ:J,alphaCutOff:u,emissiveMap:b,emissive:g,normalMap:A,roughnessMap:K,roughnessChannel:L,roughness:o,metalnessMap:M,metalnessChannel:T,metalness:Q,aoMap:t,aoMapChannel:V,aoMapIntensity:S,alphaMap:f,ior:w,clearCoatEnabled:O,clearCoat:l,clearCoatMap:Z,clearCoatRoughness:B,clearCoatRoughnessMap:k}=function(i){const x={diffuseMap:null,NJ:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return i instanceof Mi.oJ?{...x,diffuseMap:i.diffuseTexture,NJ:i.diffuseColor,alphaCutOff:i.alphaCutOff,emissiveMap:i.emissiveTexture,emissive:i.emissiveColor,roughness:1,alphaMap:i.opacityTexture}:i instanceof bx.b?{...x,diffuseMap:i._albedoTexture,NJ:i._albedoColor,alphaCutOff:i._alphaCutOff,emissiveMap:i._emissiveTexture,emissive:i._emissiveColor,normalMap:i._bumpTexture,roughnessMap:i._metallicTexture,roughnessChannel:i._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:i._roughness??1,metalnessMap:i._metallicTexture,metalnessChannel:i._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:i._metallic??0,aoMap:i._ambientTexture,aoMapChannel:i._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:i._ambientTextureStrength,alphaMap:i._opacityTexture,ior:i.subSurface.indexOfRefraction,clearCoatEnabled:i.clearCoat.isEnabled,clearCoat:i.clearCoat.kJ,clearCoatMap:i.clearCoat.texture,clearCoatRoughness:i.clearCoat.roughness,clearCoatRoughnessMap:i.clearCoat.useRoughnessFromMainTexture?i.clearCoat.texture:i.clearCoat.textureRoughness}:x}(i);return null!==Y?(E.push(`${j}color3f inputs:diffuseColor.connect = </Materials/Material_${i.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:rgb>`),i.needAlphaBlending()?E.push(`${j}float inputs:opacity.connect = </Materials/Material_${i.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`):i.needAlphaTesting()&&(E.push(`${j}float inputs:opacity.connect = </Materials/Material_${i.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`),E.push(`${j}float inputs:opacityThreshold = ${u}`)),a.push(sx(Y,i,"diffuse",J,x,e))):E.push(`${j}color3f inputs:diffuseColor = ${vx(J||z.MJ.White())}`),null!==b?(E.push(`${j}color3f inputs:emissiveColor.connect = </Materials/Material_${i.uniqueId}/Texture_${b.uniqueId}_emissive.outputs:rgb>`),a.push(sx(b,i,"emissive",g,x,e))):g&&g.toLuminance()>0&&E.push(`${j}color3f inputs:emissiveColor = ${vx(g)}`),null!==A&&(E.push(`${j}normal3f inputs:normal.connect = </Materials/Material_${i.uniqueId}/Texture_${A.uniqueId}_normal.outputs:rgb>`),a.push(sx(A,i,"normal",null,x,e))),null!==t&&(E.push(`${j}float inputs:occlusion.connect = </Materials/Material_${i.uniqueId}/Texture_${t.uniqueId}_occlusion.outputs:${V}>`),a.push(sx(t,i,"occlusion",new z.MJ(S,S,S),x,e))),null!==K?(E.push(`${j}float inputs:roughness.connect = </Materials/Material_${i.uniqueId}/Texture_${K.uniqueId}_roughness.outputs:${L}>`),a.push(sx(K,i,"roughness",new z.MJ(o,o,o),x,e))):E.push(`${j}float inputs:roughness = ${o}`),null!==M?(E.push(`${j}float inputs:metallic.connect = </Materials/Material_${i.uniqueId}/Texture_${M.uniqueId}_metallic.outputs:${T}>`),a.push(sx(M,i,"metallic",new z.MJ(Q,Q,Q),x,e))):E.push(`${j}float inputs:metallic = ${Q}`),null!==f?(E.push(`${j}float inputs:opacity.connect = </Materials/Material_${i.uniqueId}/Texture_${f.uniqueId}_opacity.outputs:r>`),E.push(`${j}float inputs:opacityThreshold = 0.0001`),a.push(sx(f,i,"opacity",null,x,e))):E.push(`${j}float inputs:opacity = ${i.alpha}`),O&&(null!==Z?(E.push(`${j}float inputs:clearcoat.connect = </Materials/Material_${i.uniqueId}/Texture_${Z.uniqueId}_clearcoat.outputs:r>`),a.push(sx(Z,i,"clearcoat",new z.MJ(l,l,l),x,e))):E.push(`${j}float inputs:clearcoat = ${l}`),null!==k?(E.push(`${j}float inputs:clearcoatRoughness.connect = </Materials/Material_${i.uniqueId}/Texture_${k.uniqueId}_clearcoatRoughness.outputs:g>`),a.push(sx(k,i,"clearcoatRoughness",new z.MJ(B,B,B),x,e))):E.push(`${j}float inputs:clearcoatRoughness = ${B}`)),E.push(`${j}float inputs:ior = ${w}`),`\n\tdef Material "Material_${i.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${E.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${i.uniqueId}/PreviewSurface.outputs:surface>\n\n${a.join("\n")}\n\n\t}\n`}async function xe(i,x,e){const a={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...x};"undefined"===typeof fflate&&await E.Tools.LoadScriptAsync(a.fflateUrl);const Y={};Y[a.modelFileName]=null;let J='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';J+=function(i){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===i.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${i.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${i.planeAnchoringAlignment}"`:""}\n            `}(a);const u={};for(const j of i.meshes){if(0===j.getTotalVertices())continue;const i=j,x=i.ye,b=i.material;if(!b||!x||e&&!e(i))continue;if(-1!==["oJ","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(b.getClassName())){const e="geometries/Geometry_"+x.uniqueId+".usda";if(!(e in Y)){const i=yx(x,a);Y[e]=rx(i)}b.uniqueId in u||(u[b.uniqueId]=b),J+=qx(i)}else E.Tools.Warn("USDZExportAsync does not support this material type: "+b.getClassName())}i.activeCamera&&a.exportCamera&&(J+=function(i,x){const e="Camera_"+i.uniqueId,E=cx(j.Matrix.RotationY(Math.PI).multiply(i.getWorldMatrix()));if(i.mode===w.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${i.De.toPrecision(x.precision)}, ${i.maxZ.toPrecision(x.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(i.orthoLeft||1)+Math.abs(i.orthoRight||1))).toPrecision(x.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(i.orthoTop||1)+Math.abs(i.orthoBottom||1))).toPrecision(x.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const j=i.getEngine().getAspectRatio(i),a=x.cameraSensorWidth||35;return`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${i.De.toPrecision(x.precision)}, ${i.maxZ.toPrecision(x.precision)})\n\t\t\tfloat focalLength = ${(a/(2*Math.tan(.5*i.fov))).toPrecision(x.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(a*j).toPrecision(x.precision)}\n\t\t\tfloat verticalAperture = ${(a/j).toPrecision(x.precision)}            \n\t\t}\n\t\n\t`}}(i.activeCamera,a)),J+="\n            }\n        }\n    }";const b={};J+=function(i,x,e){const j=[];for(const E in i){const a=i[E];j.push(ie(a,x,e))}return`\n    def "Materials"\n{\n${j.join("")}\n}\n\n`}(u,b,a),Y[a.modelFileName]=fflate.strToU8(J);for(const j in b){const i=b[j],x=i.getSize(),e=await i.readPixels();if(!e)throw new Error("Texture data is not available");const E=await O.DumpTools.DumpDataAsync(x.width,x.height,e,"image/png",void 0,!1,!0);Y[`textures/Texture_${j}.png`]=new Uint8Array(E).slice()}let g=0;for(const j in Y){const i=Y[j];if(!i)continue;g+=34+j.length;const x=63&g;if(4!==x){const e=new Uint8Array(64-x);Y[j]=[i,{extra:{12345:e}}]}g=i.length}return fflate.zipSync(Y,{level:0})}}}]);