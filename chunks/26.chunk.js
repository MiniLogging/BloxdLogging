"use strict";(self["9x1utqq1axc"]=self["9x1utqq1axc"]||[]).push([[26],{12735:(y,c,A)=>{A.r(c),A.d(c,{EXT_materials_diffuse_roughness:()=>Jc,EXT_mesh_gpu_instancing:()=>ry,GLTF2Export:()=>Fy,GLTFData:()=>I,KHR_draco_mesh_compression:()=>Ac,KHR_lights_punctual:()=>hc,KHR_materials_anisotropy:()=>oc,KHR_materials_clearcoat:()=>Lc,KHR_materials_diffuse_transmission:()=>Pc,KHR_materials_dispersion:()=>tc,KHR_materials_emissive_strength:()=>Bc,KHR_materials_ior:()=>Cc,KHR_materials_iridescence:()=>mA,KHR_materials_sheen:()=>zc,KHR_materials_specular:()=>Mc,KHR_materials_transmission:()=>ac,KHR_materials_unlit:()=>Gc,KHR_materials_volume:()=>fc,KHR_texture_transform:()=>ec,OBJExport:()=>p,STLExport:()=>Qc,USDZExportAsync:()=>cA,_ConvertToGLTFPBRMetallicRoughness:()=>u,_SolveMetallic:()=>a,__IGLTFExporterExtension:()=>W});var l=A(12325),w=A(12144),N=A(12632);class p{static OBJ(y,c,A,p){const W=[];let h=1,I=1;c&&(A||(A="mat"),W.push("mtllib "+A+".mtl"));for(let q=0;q<y.length;q++){const A=y[q],o=A.name||`mesh${q}}`;W.push(`o ${o}`);let O=null;if(p){const y=A.Yc(!0);O=new l.Matrix,y.invertToRef(O),A.bakeTransformIntoVertices(y)}if(c){const y=A.material;y&&W.push("usemtl "+y.id)}const L=A.Rc;if(!L){w.Tools.Warn("No geometry is present on the mesh");continue}const i=L.getVerticesData("position"),H=L.getVerticesData("normal"),P=L.getVerticesData("uv"),D=L.rc();let t=0,s=0;if(!i||!D){w.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const B=y[0].mc().useRightHandedSystem?1:-1;for(let y=0;y<i.length;y+=3)W.push("v "+i[y]*B+" "+i[y+1]+" "+i[y+2]),t++;if(null!=H)for(let y=0;y<H.length;y+=3)W.push("vn "+H[y]*B+" "+H[y+1]+" "+H[y+2]);if(null!=P)for(let y=0;y<P.length;y+=2)W.push("vt "+P[y]+" "+P[y+1]),s++;const X=["","",""],C=(A.material||A.mc().defaultMaterial)._getEffectiveOrientation(A),[K,my]=C===N.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let y=0;y<D.length;y+=3){const c=[String(D[y]+h),String(D[y+K]+h),String(D[y+my]+h)],A=[String(D[y]+I),String(D[y+K]+I),String(D[y+my]+I)],l=c,w=null!=P?A:X,N=null!=H?c:X;W.push("f "+l[0]+"/"+w[0]+"/"+N[0]+" "+l[1]+"/"+w[1]+"/"+N[1]+" "+l[2]+"/"+w[2]+"/"+N[2])}p&&O&&A.bakeTransformIntoVertices(O),h+=t,I+=s}return W.join("\n")}static MTL(y){const c=[],A=y.material;c.push("newmtl mat1"),c.push("  Ns "+A.specularPower.toFixed(4)),c.push("  Ni 1.5000"),c.push("  d "+A.alpha.toFixed(4)),c.push("  Tr 0.0000"),c.push("  Tf 1.0000 1.0000 1.0000"),c.push("  illum 2"),c.push("  Ka "+A.ambientColor.r.toFixed(4)+" "+A.ambientColor.g.toFixed(4)+" "+A.ambientColor.b.toFixed(4)),c.push("  Kd "+A.diffuseColor.r.toFixed(4)+" "+A.diffuseColor.g.toFixed(4)+" "+A.diffuseColor.b.toFixed(4)),c.push("  Ks "+A.specularColor.r.toFixed(4)+" "+A.specularColor.g.toFixed(4)+" "+A.specularColor.b.toFixed(4)),c.push("  Ke "+A.emissiveColor.r.toFixed(4)+" "+A.emissiveColor.g.toFixed(4)+" "+A.emissiveColor.b.toFixed(4));A.ambientTexture&&c.push("  map_Ka "+A.ambientTexture.name),A.diffuseTexture&&c.push("  map_Kd "+A.diffuseTexture.name),A.specularTexture&&c.push("  map_Ks "+A.specularTexture.name),A.bumpTexture&&c.push("  map_bump -imfchan z "+A.bumpTexture.name),A.opacityTexture&&c.push("  map_d "+A.opacityTexture.name);return c.join("\n")}}var W=0,h=A(12191);class I{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const y in this.files){const c=this.files[y],A=new Blob([c],{type:(0,h.k)(y)});w.Tools.Download(A,y)}}}var q=A(12400),o=A(12737),O=A(12752),L=A(12767),i=A(12454),H=A(12184),P=A(12375),D=A(12340);const t=D.HighestCommonFactor,s={...D,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:t};var B=A(12547),X=A(12303),C=A(12793),K=A(12802),my=A(12545);const T=1e-6,z=new P.dc(.04,.04,.04),S=1024,M=P.dc.White(),k=P.dc.Black();function a(y,c,A){if(c<z.r)return 0;const l=z.r,w=y*A/(1-z.r)+c-2*z.r,N=w*w-4*l*(z.r-c);return s.Clamp((-w+Math.sqrt(N))/(2*l),0,1)}function u(y){const c=y.diffuseColor.toLinearSpace(y.mc().getEngine().useExactSrgbConversions).scale(.5),A=y.alpha,w=function(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new l.Vector2(0,1),A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new l.Vector2(0,.1),w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new l.Vector2(0,.1),N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new l.Vector2(1300,.1);return function(y,c,A,l,w){return(1-y)*(1-y)*(1-y)*c+3*(1-y)*(1-y)*y*A+3*(1-y)*y*y*l+y*y*y*w}(Math.pow(y/N.x,.333333),c.y,A.y,w.y,N.y)}(s.Clamp(y.specularPower,0,S));return{baseColorFactor:[c.r,c.g,c.b,A],metallicFactor:0,roughnessFactor:w}}function G(y,c){c.needAlphaBlending()?y.alphaMode="BLEND":c.needAlphaTesting()&&(y.alphaMode="MASK",y.alphaCutoff=c.alphaCutOff)}function j(y,c,A){const l=new Uint8Array(y*c*4);for(let w=0;w<l.length;w+=4)l[w]=l[w+1]=l[w+2]=l[w+3]=255;return C.b.CreateRGBATexture(l,y,c,A)}function f(y){if(y instanceof Uint8Array){const c=y.length,A=new Float32Array(y.length);for(let l=0;l<c;++l)A[l]=y[l]/255;return A}if(y instanceof Float32Array)return y;throw new Error("Unsupported pixel format!")}class V{constructor(y){this._exporter=y,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(y){return y?this._textureMap.get(y)??null:null}async exportStandardMaterialAsync(y,c,A){const l=u(y),N={name:y.name};if(null==y.nc||y.nc||(y.twoSidedLighting||w.Tools.Warn(y.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),N.doubleSided=!0),A){const A=[],w=y.diffuseTexture;w&&A.push(this.exportTextureAsync(w,c).then((y=>{y&&(l.baseColorTexture=y)})));const p=y.bumpTexture;p&&A.push(this.exportTextureAsync(p,c).then((y=>{y&&(N.normalTexture=y,1!==p.level&&(N.normalTexture.scale=p.level))})));const W=y.emissiveTexture;W&&(N.emissiveFactor=[1,1,1],A.push(this.exportTextureAsync(W,c).then((y=>{y&&(N.emissiveTexture=y)}))));const h=y.ambientTexture;h&&A.push(this.exportTextureAsync(h,c).then((y=>{if(y){const c={index:y.index};N.occlusionTexture=c}}))),A.length>0&&(this._exporter._materialNeedsUVsSet.add(y),await Promise.all(A))}(y.alpha<1||y.opacityTexture)&&(y.alphaMode===K.c.ALPHA_COMBINE?N.alphaMode="BLEND":w.Tools.Warn(y.name+": glTF 2.0 does not support alpha mode: "+y.alphaMode.toString())),y.emissiveColor&&!y.emissiveColor.equalsWithEpsilon(k,T)&&(N.emissiveFactor=y.emissiveColor.fc()),N.pbrMetallicRoughness=l,G(N,y),await this._finishMaterialAsync(N,y,c);const p=this._exporter._materials;return p.push(N),p.length-1}async _finishMaterialAsync(y,c,A){const l=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",y,c),w=[];for(const N of l)w.push(this.exportTextureAsync(N,A));await Promise.all(w),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",y,c)}async _getImageDataAsync(y,c,l,w){const N=K.c.TEXTURETYPE_UNSIGNED_BYTE,p=this._exporter._babylonScene,W=p.getEngine(),h=W.createRawTexture(y,c,l,K.c.TEXTUREFORMAT_RGBA,!1,!0,X.d.NEAREST_SAMPLINGMODE,null,N);W.isWebGPU?await A.e(51).then(A.bind(A,14799)):await A.e(52).then(A.bind(A,14801)),await B.l.ApplyPostProcess("pass",h,p,N,K.c.TEXTURE_NEAREST_SAMPLINGMODE,K.c.TEXTUREFORMAT_RGBA);const I=await W._readTexturePixels(h,c,l);return await my.DumpTools.DumpDataAsync(c,l,I,w,void 0,!0,!0)}_resizeTexturesToSameDimensions(y,c,A){const l=y?y.getSize():{width:0,height:0},w=c?c.getSize():{width:0,height:0};let N,p;return l.width<w.width?(N=y&&y instanceof X.d?B.l.CreateResizedCopy(y,w.width,w.height,!0):j(w.width,w.height,A),p=c):l.width>w.width?(p=c&&c instanceof X.d?B.l.CreateResizedCopy(c,l.width,l.height,!0):j(l.width,l.height,A),N=y):(N=y,p=c),{texture1:N,texture2:p}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(y,c,A,l){const w=new Array;if(!y&&!c)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const N=y?y.mc():c?c.mc():null;if(N){var p;const W=this._resizeTexturesToSameDimensions(y,c,N),h=null===(p=W.texture1)||void 0===p?void 0:p.getSize();let I,q;const o=h.width,O=h.height,L=await W.texture1.readPixels(),i=await W.texture2.readPixels();if(!L)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(I=f(L),!i)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");q=f(i);const H=q.byteLength,D=new Uint8Array(H),t=new Uint8Array(H),s=4,B=k;let X=0,C=0;for(let y=0;y<O;++y)for(let c=0;c<o;++c){const l=(o*y+c)*s,w={diffuseColor:new P.dc(I[l],I[l+1],I[l+2]).toLinearSpace(N.getEngine().useExactSrgbConversions).multiply(A.diffuseColor),specularColor:new P.dc(q[l],q[l+1],q[l+2]).toLinearSpace(N.getEngine().useExactSrgbConversions).multiply(A.specularColor),glossiness:q[l+3]*A.glossiness},p=this._convertSpecularGlossinessToMetallicRoughness(w);B.r=Math.max(B.r,p.baseColor.r),B.g=Math.max(B.g,p.baseColor.g),B.b=Math.max(B.b,p.baseColor.b),X=Math.max(X,p.metallic),C=Math.max(C,p.roughness),t[l]=255*p.baseColor.r,t[l+1]=255*p.baseColor.g,t[l+2]=255*p.baseColor.b,t[l+3]=W.texture1.Vc?255*I[l+3]:255,D[l]=0,D[l+1]=255*p.roughness,D[l+2]=255*p.metallic,D[l+3]=255}const K={baseColor:B,metallic:X,roughness:C};let my=!1,z=!1;for(let y=0;y<O;++y)for(let c=0;c<o;++c){const A=(o*y+c)*s;t[A]/=K.baseColor.r>T?K.baseColor.r:1,t[A+1]/=K.baseColor.g>T?K.baseColor.g:1,t[A+2]/=K.baseColor.b>T?K.baseColor.b:1;const l=P.dc.FromInts(t[A],t[A+1],t[A+2]).toGammaSpace(N.getEngine().useExactSrgbConversions);t[A]=255*l.r,t[A+1]=255*l.g,t[A+2]=255*l.b,l.equalsWithEpsilon(M,T)||(z=!0),D[A+1]/=K.roughness>T?K.roughness:1,D[A+2]/=K.metallic>T?K.metallic:1;P.dc.FromInts(255,D[A+1],D[A+2]).equalsWithEpsilon(M,T)||(my=!0)}return my&&w.push(this._getImageDataAsync(D,o,O,l).then((y=>{K.metallicRoughnessTextureData=y}))),z&&w.push(this._getImageDataAsync(t,o,O,l).then((y=>{K.baseColorTextureData=y}))),await Promise.all(w).then((()=>K))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(y){const c=this._getPerceivedBrightness(y.diffuseColor),A=this._getPerceivedBrightness(y.specularColor),l=1-this._getMaxComponent(y.specularColor),w=a(c,A,l),N=y.diffuseColor.scale(l/(1-z.r)/Math.max(1-w)),p=y.specularColor.xc(z.scale(1-w)).scale(1/Math.max(w));let W=P.dc.Lerp(N,p,w*w);W=W.clampToRef(0,1,W);return{baseColor:W,metallic:w,roughness:1-y.glossiness}}_getPerceivedBrightness(y){return y?Math.sqrt(.299*y.r*y.r+.587*y.g*y.g+.114*y.b*y.b):0}_getMaxComponent(y){return y?Math.max(y.r,Math.max(y.g,y.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(y,c,A,l){const w=[],N={baseColor:y._albedoColor,metallic:y._metallic,roughness:y._roughness};if(l){y._albedoTexture&&w.push(this.exportTextureAsync(y._albedoTexture,c).then((y=>{y&&(A.baseColorTexture=y)})));const l=y._metallicTexture;l&&w.push(this.exportTextureAsync(l,c).then((y=>{y&&(A.metallicRoughnessTexture=y)})))}return w.length>0&&(this._exporter._materialNeedsUVsSet.add(y),await Promise.all(w)),N}_getTextureSampler(y){const c={};if(!y||!(y instanceof X.d))return c;const A=this._getGLTFTextureWrapMode(y.wrapU);10497!==A&&(c.wrapS=A);const l=this._getGLTFTextureWrapMode(y.wrapV);switch(10497!==l&&(c.wrapT=l),y.samplingMode){case X.d.LINEAR_LINEAR:c.magFilter=9729,c.minFilter=9729;break;case X.d.LINEAR_NEAREST:c.magFilter=9729,c.minFilter=9728;break;case X.d.NEAREST_LINEAR:c.magFilter=9728,c.minFilter=9729;break;case X.d.NEAREST_LINEAR_MIPLINEAR:c.magFilter=9728,c.minFilter=9987;break;case X.d.NEAREST_NEAREST:c.magFilter=9728,c.minFilter=9728;break;case X.d.NEAREST_LINEAR_MIPNEAREST:c.magFilter=9728,c.minFilter=9985;break;case X.d.LINEAR_NEAREST_MIPNEAREST:c.magFilter=9729,c.minFilter=9984;break;case X.d.LINEAR_NEAREST_MIPLINEAR:c.magFilter=9729,c.minFilter=9986;break;case X.d.NEAREST_NEAREST_MIPLINEAR:c.magFilter=9728,c.minFilter=9986;break;case X.d.LINEAR_LINEAR_MIPLINEAR:c.magFilter=9729,c.minFilter=9987;break;case X.d.LINEAR_LINEAR_MIPNEAREST:c.magFilter=9729,c.minFilter=9985;break;case X.d.NEAREST_NEAREST_MIPNEAREST:c.magFilter=9728,c.minFilter=9984}return c}_getGLTFTextureWrapMode(y){switch(y){case X.d.WRAP_ADDRESSMODE:return 10497;case X.d.CLAMP_ADDRESSMODE:return 33071;case X.d.MIRROR_ADDRESSMODE:return 33648;default:return w.Tools.Error(`Unsupported Texture Wrap Mode ${y}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(y,c,A,l){const w={diffuseColor:y._albedoColor,specularColor:y._reflectivityColor,glossiness:y._microSurface},N=y._albedoTexture,p=y._reflectivityTexture,W=y._useMicroSurfaceFromReflectivityMapAlpha;if(p&&!W)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((N||p)&&l){this._exporter._materialNeedsUVsSet.add(y);const l=this._exportTextureSampler(N||p),W=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(N,p,w,c),h=this._exporter._textures;if(W.baseColorTextureData){const y=this._exportImage(`baseColor${h.length}`,c,W.baseColorTextureData);A.baseColorTexture=this._exportTextureInfo(y,l,null===N||void 0===N?void 0:N.coordinatesIndex)}if(W.metallicRoughnessTextureData){const y=this._exportImage(`metallicRoughness${h.length}`,c,W.metallicRoughnessTextureData);A.metallicRoughnessTexture=this._exportTextureInfo(y,l,null===p||void 0===p?void 0:p.coordinatesIndex)}return W}return this._convertSpecularGlossinessToMetallicRoughness(w)}async exportPBRMaterialAsync(y,c,A){const l={},w={name:y.name},N=y.isMetallicWorkflow();if(N){const c=y._albedoColor,A=y.alpha;c&&(l.baseColorFactor=[c.r,c.g,c.b,A])}const p=N?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(y,c,l,A):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(y,c,l,A);await this._setMetallicRoughnessPbrMaterialAsync(p,y,w,l,c,A),await this._finishMaterialAsync(w,y,c);const W=this._exporter._materials;return W.push(w),W.length-1}async _setMetallicRoughnessPbrMaterialAsync(y,c,A,l,N,p){if(G(A,c),y.baseColor.equalsWithEpsilon(M,T)&&s.WithinEpsilon(c.alpha,1,T)||(l.baseColorFactor=[y.baseColor.r,y.baseColor.g,y.baseColor.b,c.alpha]),null!=y.metallic&&1!==y.metallic&&(l.metallicFactor=y.metallic),null!=y.roughness&&1!==y.roughness&&(l.roughnessFactor=y.roughness),null==c.nc||c.nc||(c._twoSidedLighting||w.Tools.Warn(c.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),A.doubleSided=!0),p){const y=[],l=c._bumpTexture;l&&y.push(this.exportTextureAsync(l,N).then((y=>{y&&(A.normalTexture=y,1!==l.level&&(A.normalTexture.scale=l.level))})));const w=c._ambientTexture;w&&y.push(this.exportTextureAsync(w,N).then((y=>{if(y){const l={index:y.index,texCoord:y.texCoord,extensions:y.extensions};A.occlusionTexture=l;const w=c._ambientTextureStrength;w&&(l.strength=w)}})));const p=c._emissiveTexture;p&&y.push(this.exportTextureAsync(p,N).then((y=>{y&&(A.emissiveTexture=y)}))),y.length>0&&(this._exporter._materialNeedsUVsSet.add(c),await Promise.all(y))}const W=c._emissiveColor;W.equalsWithEpsilon(k,T)||(A.emissiveFactor=W.fc()),A.pbrMetallicRoughness=l}_getPixelsFromTextureAsync(y){return function(y){switch(y){case K.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case K.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case K.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case K.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case K.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case K.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case K.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case K.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case K.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case K.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case K.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case K.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case K.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case K.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case K.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case K.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case K.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case K.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case K.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case K.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case K.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(y.textureFormat)?(0,B.h)(y,y._texture.width,y._texture.height):(y.textureType,K.c.TEXTURETYPE_UNSIGNED_BYTE,y.readPixels())}async exportTextureAsync(y,c){const A=this._exporter._extensionsPreExportTextureAsync("exporter",y,c);return A?await A.then((async A=>A?await this._exportTextureInfoAsync(A,c):await this._exportTextureInfoAsync(y,c))):await this._exportTextureInfoAsync(y,c)}async _exportTextureInfoAsync(y,c){let A=this._textureMap.get(y);if(!A){const l=await this._getPixelsFromTextureAsync(y);if(!l)return null;const N=this._exportTextureSampler(y),p=y.mimeType;if(p)switch(p){case"image/jpeg":case"image/png":case"image/webp":c=p;break;default:w.Tools.Warn(`Unsupported media type: ${p}. Exporting texture as PNG.`)}const W=this._internalTextureToImage,h=y.getInternalTexture().uniqueId;W[h]||(W[h]={});let I=W[h][c];if(void 0===I){const A=y.getSize();I=(async()=>{const w=await this._getImageDataAsync(l,A.width,A.height,c);return this._exportImage(y.name,c,w)})(),W[h][c]=I}A=this._exportTextureInfo(await I,N,y.coordinatesIndex),this._textureMap.set(y,A),this._exporter._extensionsPostExportTextures("exporter",A,y)}return A}_exportImage(y,c,A){const l=this._exporter._images;let N;if(this._exporter._shouldUseGlb){N={name:y,mimeType:c,bufferView:void 0};const l=this._exporter._bufferManager.createBufferView(new Uint8Array(A));this._exporter._bufferManager.setBufferView(N,l)}else{const p=y.replace(/\.\/|\/|\.\\|\\/g,"_"),W=function(y){switch(y){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(c);let h=p+W;l.some((y=>y.uri===h))&&(h=`${p}_${w.Tools.RandomId()}${W}`),N={name:y,uri:h},this._exporter._imageData[h]={data:A,mimeType:c}}return l.push(N),l.length-1}_exportTextureInfo(y,c,A){const l=this._exporter._textures;let w=l.findIndex((A=>A.sampler==c&&A.source===y));-1===w&&(w=l.length,l.push({source:y,sampler:c}));const N={index:w};return A&&(N.texCoord=A),N}_exportTextureSampler(y){const c=this._getTextureSampler(y),A=this._exporter._samplers,l=A.findIndex((y=>y.minFilter===c.minFilter&&y.magFilter===c.magFilter&&y.wrapS===c.wrapS&&y.wrapT===c.wrapT));return-1!==l?l:(A.push(c),A.length-1)}}var J=A(12410),U=A(12161),e=A(12805),Q=A(12330);const Y=l.gc.Zero(),g=l.Quaternion.Identity(),x=l.gc.One(),F=new l.gc(-1,1,1);function R(y,c){const{byteOffset:A,byteStride:l,type:w,normalized:N}=y,p=y.getSize(),W=c.reduce(((y,c)=>c.getTotalVertices()>y?c.getTotalVertices():y),-Number.MAX_VALUE);return{byteOffset:A,byteStride:l,componentCount:p,type:w,count:W*p,normalized:N,totalVertices:W,kind:y.getKind()}}function r(y){switch(y){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function n(y){switch(y){case q.e.PositionKind:case q.e.NormalKind:case q.e.TangentKind:case q.e.ColorKind:case q.e.MatricesIndicesKind:case q.e.MatricesIndicesExtraKind:case q.e.MatricesWeightsKind:case q.e.MatricesWeightsExtraKind:case q.e.UVKind:case q.e.UV2Kind:case q.e.UV3Kind:case q.e.UV4Kind:case q.e.UV5Kind:case q.e.UV6Kind:return!0}return!1}function E(y){switch(y){case N.c.TriangleFillMode:return 4;case N.c.TriangleStripDrawMode:return 5;case N.c.TriangleFanDrawMode:return 6;case N.c.PointListDrawMode:case N.c.PointFillMode:return 0;case N.c.LineLoopDrawMode:return 2;case N.c.LineListDrawMode:return 1;case N.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${y}`)}function b(y){const c=Math.sqrt(y.x*y.x+y.y*y.y+y.z*y.z);c>0&&(y.x/=c,y.y/=c,y.z/=c)}function Z(y){return y.x*=-1,y}function v(y){if(y.x*y.x+y.y*y.y>.5){const c=Math.abs(y.x),A=Math.abs(y.y);if(c>A){const A=Math.sign(y.x);y.x=c,y.y*=-A,y.z*=-A,y.w*=A}else{const c=Math.sign(y.y);y.x*=-c,y.y=A,y.z*=c,y.w*=-c}}else{const c=Math.abs(y.z),A=Math.abs(y.w);if(c>A){const A=Math.sign(y.z);y.x*=-A,y.y*=A,y.z=c,y.w*=-A}else{const c=Math.sign(y.w);y.x*=c,y.y*=-c,y.z*=-c,y.w=A}}return y}function d(y){y.Ec(-y.z,y.w,y.x,-y.y)}function yy(y,c){const A=l.gc.FromArrayToRef(c.translation||[0,0,0],0,l.TmpVectors.gc[0]),w=l.Quaternion.FromArrayToRef(c.rotation||[0,0,0,1],0,l.TmpVectors.Quaternion[0]),N=l.Matrix.ComposeToRef(x,w,A,l.TmpVectors.Matrix[0]),p=l.gc.FromArrayToRef(y.translation||[0,0,0],0,l.TmpVectors.gc[2]),W=l.Quaternion.FromArrayToRef(y.rotation||[0,0,0,1],0,l.TmpVectors.Quaternion[1]),h=l.Matrix.ComposeToRef(x,W,p,l.TmpVectors.Matrix[1]);N.multiplyToRef(h,h),h.decompose(void 0,w,A),A.equalsWithEpsilon(Y,Q.b)?delete c.translation:c.translation=A.fc(),w.equalsWithEpsilon(g,Q.b)?delete c.rotation:c.rotation=w.fc(),c.scale&&delete c.scale}function cy(y,c){if(!(c instanceof o.d))return!1;if(!(1===c.getChildren().length&&0===y.getChildren().length&&y.parent===c))return!1;const A=y.mc(),l=y instanceof e.b&&!A.useRightHandedSystem?F:x;return!!c.bc.equalsWithEpsilon(l,Q.b)||(U.c.Warn(`Cannot collapse node ${y.name} into parent node ${c.name} with modified scaling.`),!1)}function Ay(y){if(y instanceof Array){const c=new Float32Array(y);return new Uint8Array(c.buffer,c.byteOffset,c.byteLength)}return ArrayBuffer.isView(y)?new Uint8Array(y.buffer,y.byteOffset,y.byteLength):new Uint8Array(y)}function ly(y,c){for(const[A,l]of Object.entries(y)){const w=c[A];(Array.isArray(l)&&Array.isArray(w)&&wy(l,w)||l===w)&&delete y[A]}return y}function wy(y,c){return y.length===c.length&&y.every(((y,A)=>y===c[A]))}const Ny=l.Matrix.Compose(new l.gc(-1,1,1),l.Quaternion.Identity(),l.gc.Zero());function py(y,c){if(!(y instanceof o.d))return!1;if(c){if(!y.getWorldMatrix().equalsWithEpsilon(l.Matrix.IdentityReadOnly,Q.b))return!1}else{if(!y.getWorldMatrix().multiplyToRef(Ny,l.TmpVectors.Matrix[0]).equalsWithEpsilon(l.Matrix.IdentityReadOnly,Q.b))return!1}return!(y instanceof O.c&&y.Rc)}const Wy=new Map([[Int8Array,(y,c,A)=>y.setInt8(c,A)],[Uint8Array,(y,c,A)=>y.setUint8(c,A)],[Uint8ClampedArray,(y,c,A)=>y.setUint8(c,A)],[Int16Array,(y,c,A)=>y.setInt16(c,A,!0)],[Uint16Array,(y,c,A)=>y.setUint16(c,A,!0)],[Int32Array,(y,c,A)=>y.setInt32(c,A,!0)],[Uint32Array,(y,c,A)=>y.setUint32(c,A,!0)],[Float32Array,(y,c,A)=>y.setFloat32(c,A,!0)],[Float64Array,(y,c,A)=>y.setFloat64(c,A,!0)]]);class hy{writeTypedArray(y){this._checkGrowBuffer(y.byteLength);const c=Wy.get(y.constructor);for(let A=0;A<y.length;A++)c(this._dataView,this._byteOffset,y[A]),this._byteOffset+=y.BYTES_PER_ELEMENT}constructor(y){this._data=new Uint8Array(y),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(y){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,y),this._byteOffset++}writeInt8(y){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,y),this._byteOffset++}writeInt16(y){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,y,!0),this._byteOffset+=2}writeUInt16(y){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,y,!0),this._byteOffset+=2}writeInt32(y){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,y,!0),this._byteOffset+=4}writeUInt32(y){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,y,!0),this._byteOffset+=4}writeFloat32(y){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,y,!0),this._byteOffset+=4}writeFloat64(y){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,y,!0),this._byteOffset+=8}_checkGrowBuffer(y){const c=this.byteOffset+y;if(c>this._data.byteLength){const y=new Uint8Array(2*c);y.set(this._data),this._data=y,this._dataView=new DataView(this._data.buffer)}}}function Iy(y){return y%4===0?4:y%2===0?2:1}class qy{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(y){let c=0;this._bufferViewToData.forEach((y=>{c+=y.byteLength}));const A=new hy(c),l=Array.from(this._bufferViewToData.keys()).sort(((y,c)=>Iy(c.byteLength)-Iy(y.byteLength)));for(const w of l){w.byteOffset=A.byteOffset,y.push(w);const c=y.length-1,l=this.getPropertiesWithBufferView(w);for(const y of l)y.bufferView=c;A.writeTypedArray(this._bufferViewToData.get(w)),this._bufferViewToData.delete(w)}return A.getOutputData()}createBufferView(y,c){const A={buffer:0,byteOffset:void 0,byteLength:y.byteLength,byteStride:c};return this._bufferViewToData.set(A,y),A}createAccessor(y,c,A,l,w,N,p){this._verifyBufferView(y);const W={bufferView:void 0,componentType:A,count:l,type:c,min:null===N||void 0===N?void 0:N.min,max:null===N||void 0===N?void 0:N.max,normalized:p,byteOffset:w};return this.setBufferView(W,y),this._accessorToBufferView.set(W,y),W}setBufferView(y,c){this._verifyBufferView(c);this.getPropertiesWithBufferView(c).push(y)}removeBufferView(y){const c=this.getPropertiesWithBufferView(y);for(const A of c)void 0!==A.bufferView&&delete A.bufferView;this._bufferViewToData.delete(y),this._bufferViewToProperties.delete(y),this._accessorToBufferView.forEach(((c,A)=>{c===y&&(void 0!==A.byteOffset&&delete A.byteOffset,this._accessorToBufferView.delete(A))}))}getBufferView(y){const c=this._accessorToBufferView.get(y);return this._verifyBufferView(c),c}getPropertiesWithBufferView(y){return this._verifyBufferView(y),this._bufferViewToProperties.set(y,this._bufferViewToProperties.get(y)??[]),this._bufferViewToProperties.get(y)}getData(y){return this._verifyBufferView(y),this._bufferViewToData.get(y)}_verifyBufferView(y){if(void 0===y||!this._bufferViewToData.has(y))throw new Error(`BufferView ${y} not found in BufferManager.`)}}var oy,Oy=A(12775),Ly=A(12791),iy=A(12808),Hy=A(12695),Py=A(12845),Dy=A(12852),ty=A(12773),sy=A(12860);!function(y){y[y.INTANGENT=0]="INTANGENT",y[y.OUTTANGENT=1]="OUTTANGENT"}(oy||(oy={}));class By{static _IsTransformable(y){return y&&(y instanceof o.d||y instanceof Oy.c||y instanceof sy.b)}static _CreateNodeAnimation(y,c,A,l,N){if(this._IsTransformable(y)){const p=[],W=[],h=c.getKeys(),I=By._CalculateMinMaxKeyFrames(h),q=By._DeduceInterpolation(h,A,l),o=q.interpolationType,O=q.shouldBakeAnimation;if(O?By._CreateBakedAnimation(y,c,A,I.min,I.max,c.framePerSecond,N,p,W,I,l):"LINEAR"===o||"STEP"===o?By._CreateLinearOrStepAnimation(y,c,A,p,W,l):"CUBICSPLINE"===o?By._CreateCubicSplineAnimation(y,c,A,p,W,l):By._CreateBakedAnimation(y,c,A,I.min,I.max,c.framePerSecond,N,p,W,I,l),p.length&&W.length){return{inputs:p,outputs:W,samplerInterpolation:o,inputsMin:O?I.min:w.Tools.FloatRound(I.min/c.framePerSecond),inputsMax:O?I.max:w.Tools.FloatRound(I.max/c.framePerSecond)}}}return null}static _DeduceAnimationInfo(y){let c=null,A="VEC3",l=!1;const N=y.targetProperty.split(".");switch(N[0]){case"bc":c="scale";break;case"position":c="translation";break;case"rotation":A="VEC4",c="rotation";break;case"rotationQuaternion":A="VEC4",l=!0,c="rotation";break;case"influence":A="SCALAR",c="weights";break;default:w.Tools.Error(`Unsupported animatable property ${N[0]}`)}return c?{animationChannelTargetPath:c,dataAccessorType:A,useQuaternion:l}:(w.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(y,c,A,l,w,N,p,W,h,I,q){let o;if(By._IsTransformable(y)&&y.animations)for(const O of y.animations){if(q&&!q(O))continue;const w=By._DeduceAnimationInfo(O);w&&(o={name:O.name,samplers:[],channels:[]},By._AddAnimation(`${O.name}`,O.hasRunningRuntimeAnimations?c:o,y,O,w.dataAccessorType,w.animationChannelTargetPath,l,N,p,W,w.useQuaternion,h,I),o.samplers.length&&o.channels.length&&A.push(o))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(y,c,A,l,w,N,p,W,h,I,q){let o;if(y instanceof ty.b){const w=y.morphTargetManager;if(w)for(let O=0;O<w.numTargets;++O){const L=w.getTarget(O);for(const i of L.animations){if(q&&!q(i))continue;const L=new Py.b(`${i.name}`,"influence",i.framePerSecond,i.dataType,i.loopMode,i.enableBlending),H=[],P=i.getKeys();for(let y=0;y<P.length;++y){const c=P[y];for(let y=0;y<w.numTargets;++y)y==O?H.push(c):H.push({frame:c.frame,value:0})}L.setKeys(H);const D=By._DeduceAnimationInfo(L);D&&(o={name:L.name,samplers:[],channels:[]},By._AddAnimation(i.name,i.hasRunningRuntimeAnimations?c:o,y,L,D.dataAccessorType,D.animationChannelTargetPath,l,N,p,W,D.useQuaternion,h,I,w.numTargets),o.samplers.length&&o.channels.length&&A.push(o))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(y,c,A,l,w,N,p,W,h){let I;if(y.animationGroups){const o=y.animationGroups;for(const O of o){const o=new Map,L=new Map,i=new Set,H=O.to-O.from;I={name:O.name,channels:[],samplers:[]};for(let c=0;c<O.targetedAnimations.length;++c){const H=O.targetedAnimations[c],P=H.target,D=H.animation;if(h&&!h(D))continue;const t=W.has(P);if(this._IsTransformable(P)||1===P.length&&this._IsTransformable(P[0])){const y=By._DeduceAnimationInfo(H.animation);if(y){const c=this._IsTransformable(P)?P:this._IsTransformable(P[0])?P[0]:null;c&&By._AddAnimation(`${D.name}`,I,c,D,y.dataAccessorType,y.animationChannelTargetPath,A,l,w,N,y.useQuaternion,p,t)}}else if(P instanceof Dy.b||1===P.length&&P[0]instanceof Dy.b){if(By._DeduceAnimationInfo(H.animation)){const c=P instanceof Dy.b?P:P[0];if(c){const A=y.morphTargetManagers.find((y=>{for(let A=0;A<y.numTargets;++A)if(y.getTarget(A)===c)return!0;return!1}));if(A){const l=y.meshes.find((y=>y.morphTargetManager===A));var q;if(l)o.has(l)||o.set(l,new Map),null===(q=o.get(l))||void 0===q||q.set(c,D),i.add(l),L.set(l,D)}}}}}i.forEach((y=>{const c=y.morphTargetManager;let W=null;const h=[],q=L.get(y).getKeys(),i=q.length;for(let A=0;A<i;++A)for(let l=0;l<c.numTargets;++l){const w=c.getTarget(l),N=o.get(y);if(N){const c=N.get(w);c?(W||(W=new Py.b(`${O.name}_${y.name}_MorphWeightAnimation`,"influence",c.framePerSecond,Py.b.ANIMATIONTYPE_FLOAT,c.loopMode,c.enableBlending)),h.push(c.getKeys()[A])):h.push({frame:O.from+H/i*A,value:w.influence,inTangent:q[0].inTangent?0:void 0,outTangent:q[0].outTangent?0:void 0})}}W.setKeys(h);const P=By._DeduceAnimationInfo(W);P&&By._AddAnimation(`${O.name}_${y.name}_MorphWeightAnimation`,I,y,W,P.dataAccessorType,P.animationChannelTargetPath,A,l,w,N,P.useQuaternion,p,!1,null===c||void 0===c?void 0:c.numTargets)})),I.channels.length&&I.samplers.length&&c.push(I)}}}static _AddAnimation(y,c,A,w,N,p,W,h,I,q,o,O,L,i){const H=By._CreateNodeAnimation(A,w,p,o,O);let P,D,t,s,B,X;if(H){if(i){let y=0,c=0;const A=[];for(;H.inputs.length>0;)c=H.inputs.shift(),y%i==0&&A.push(c),y++;H.inputs=A}const y=W.get(A),w=new Float32Array(H.inputs);P=h.createBufferView(w),D=h.createAccessor(P,"SCALAR",5126,H.inputs.length,void 0,{min:[H.inputsMin],max:[H.inputsMax]}),q.push(D),t=q.length-1;const I=new l.Quaternion,o=new l.gc,O=new l.gc,C=A instanceof Oy.c,K=r(N),my=new Float32Array(H.outputs.length*K);H.outputs.forEach((function(y,c){let A=y;switch(p){case"translation":L&&(l.gc.FromArrayToRef(y,0,O),Z(O),O.toArray(A));break;case"rotation":4===y.length?l.Quaternion.FromArrayToRef(y,0,I):(A=new Array(4),l.gc.FromArrayToRef(y,0,o),l.Quaternion.FromEulerVectorToRef(o,I)),L&&(v(I),C&&d(I)),I.toArray(A)}my.set(A,c*K)})),P=h.createBufferView(my),D=h.createAccessor(P,N,5126,H.outputs.length),q.push(D),s=q.length-1,B={interpolation:H.samplerInterpolation,input:t,output:s},c.samplers.push(B),X={sampler:c.samplers.length-1,target:{node:y,path:p}},c.channels.push(X)}}static _CreateBakedAnimation(y,c,A,N,p,W,h,I,q,o,O){let L;const i=l.Quaternion.Identity();let H,P=null,D=null,t=null,s=null,B=null,X=null;o.min=w.Tools.FloatRound(N/W);const C=c.getKeys();for(let l=0,K=C.length;l<K;++l){if(X=null,t=C[l],l+1<K)if(s=C[l+1],t.value.equals&&t.value.equals(s.value)||t.value===s.value){if(0!==l)continue;X=t.frame}else X=s.frame;else{if(B=C[l-1],t.value.equals&&t.value.equals(B.value)||t.value===B.value)continue;X=p}if(X)for(let l=t.frame;l<=X;l+=h){if(H=w.Tools.FloatRound(l/W),H===P)continue;P=H,D=H;const N={key:0,repeatCount:0,loopMode:c.loopMode};L=c._interpolate(l,N),By._SetInterpolatedValue(y,L,H,c,A,i,I,q,O)}}D&&(o.max=D)}static _ConvertFactorToVector3OrQuaternion(y,c,A,N,p){const W=By._GetBasePositionRotationOrScale(c,N,p),h=A.targetProperty.split("."),I=h?h[1]:"",q=p?l.Quaternion.yA(W).normalize():l.gc.yA(W);switch(I){case"x":case"y":case"z":q[I]=y;break;case"w":q.w=y;break;default:w.Tools.Error(`glTFAnimation: Unsupported component name "${I}"!`)}return q}static _SetInterpolatedValue(y,c,A,w,N,p,W,h,I){let q;W.push(A),"weights"!==N?(w.dataType===Py.b.ANIMATIONTYPE_FLOAT&&(c=this._ConvertFactorToVector3OrQuaternion(c,y,w,N,I)),"rotation"===N?(I?p=c:(q=c,l.Quaternion.RotationYawPitchRollToRef(q.y,q.x,q.z,p)),h.push(p.fc())):(q=c,h.push(q.fc()))):h.push([c])}static _CreateLinearOrStepAnimation(y,c,A,l,w,N){for(const p of c.getKeys())l.push(p.frame/c.framePerSecond),By._AddKeyframeValue(p,c,w,A,y,N)}static _CreateCubicSplineAnimation(y,c,A,l,w,N){c.getKeys().forEach((function(p){l.push(p.frame/c.framePerSecond),By._AddSplineTangent(oy.INTANGENT,w,A,"CUBICSPLINE",p,N),By._AddKeyframeValue(p,c,w,A,y,N),By._AddSplineTangent(oy.OUTTANGENT,w,A,"CUBICSPLINE",p,N)}))}static _GetBasePositionRotationOrScale(y,c,A){let w;if("rotation"===c)if(A){w=(y.rotationQuaternion??l.Quaternion.Identity()).fc()}else{w=(y.rotation??l.gc.Zero()).fc()}else if("translation"===c){w=(y.position??l.gc.Zero()).fc()}else{w=(y.bc??l.gc.One()).fc()}return w}static _AddKeyframeValue(y,c,A,N,p,W){let h;const I=c.dataType;if(I===Py.b.ANIMATIONTYPE_VECTOR3){let c=y.value.fc();if("rotation"===N){const y=l.gc.yA(c);c=l.Quaternion.RotationYawPitchRoll(y.y,y.x,y.z).fc()}A.push(c)}else if(I===Py.b.ANIMATIONTYPE_FLOAT){if("weights"===N)A.push([y.value]);else if(h=this._ConvertFactorToVector3OrQuaternion(y.value,p,c,N,W),h){if("rotation"===N){const y=W?h:l.Quaternion.RotationYawPitchRoll(h.y,h.x,h.z).normalize();A.push(y.fc())}A.push(h.fc())}}else I===Py.b.ANIMATIONTYPE_QUATERNION?A.push(y.value.normalize().fc()):w.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(y,c,A){let l,w,N=!1;if("rotation"===c&&!A)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let p=0,W=y.length;p<W;++p)if(w=y[p],w.inTangent||w.outTangent)if(l){if("CUBICSPLINE"!==l){l="LINEAR",N=!0;break}}else l="CUBICSPLINE";else if(l){if("CUBICSPLINE"===l||w.interpolation&&1===w.interpolation&&"STEP"!==l){l="LINEAR",N=!0;break}}else l=w.interpolation&&1===w.interpolation?"STEP":"LINEAR";return l||(l="LINEAR"),{interpolationType:l,shouldBakeAnimation:N}}static _AddSplineTangent(y,c,A,w,N,p){let W;const h=y===oy.INTANGENT?N.inTangent:N.outTangent;if("CUBICSPLINE"===w){if("rotation"===A)if(h)if(p)W=h.fc();else{const y=h;W=l.Quaternion.RotationYawPitchRoll(y.y,y.x,y.z).fc()}else W=[0,0,0,0];else W="weights"===A?h?[h]:[0]:h?h.fc():[0,0,0];c.push(W)}}static _CalculateMinMaxKeyFrames(y){let c=1/0,A=-1/0;return y.forEach((function(y){c=Math.min(c,y.frame),A=Math.max(A,y.frame)})),{min:c,max:A}}}function Xy(y,c,A,N,p,W){const h={attributes:{},influence:y.influence,name:y.name},I=c.Rc;if(!I)return w.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),h;const o=W?-1:1,O=l.gc.Zero();let L=0,i=0;if(y.hasPositions){const N=y.getPositions(),W=I.getVerticesData(q.e.PositionKind);if(W){const y=new Float32Array(W.length),c=[1/0,1/0,1/0],w=[-1/0,-1/0,-1/0];i=W.length/3,L=0;for(let A=L;A<i;++A){const p=l.gc.yA(W,3*A);l.gc.yA(N,3*A).subtractToRef(p,O),O.x*=o,c[0]=Math.min(c[0],O.x),w[0]=Math.max(w[0],O.x),c[1]=Math.min(c[1],O.y),w[1]=Math.max(w[1],O.y),c[2]=Math.min(c[2],O.z),w[2]=Math.max(w[2],O.z),y[3*A]=O.x,y[3*A+1]=O.y,y[3*A+2]=O.z}const I=A.createBufferView(y,12),q=A.createAccessor(I,"VEC3",5126,N.length/3,0,{min:c,max:w});p.push(q),h.attributes.POSITION=p.length-1}else w.Tools.Warn(`Morph target positions for mesh ${c.name} were not exported. Mesh does not have position vertex data`)}if(y.hasNormals){const N=y.getNormals(),W=I.getVerticesData(q.e.NormalKind);if(W){const y=new Float32Array(W.length);i=W.length/3,L=0;for(let A=L;A<i;++A){const c=l.gc.yA(W,3*A).normalize();l.gc.yA(N,3*A).normalize().subtractToRef(c,O),y[3*A]=O.x*o,y[3*A+1]=O.y,y[3*A+2]=O.z}const c=A.createBufferView(y,12),w=A.createAccessor(c,"VEC3",5126,N.length/3,0);p.push(w),h.attributes.NORMAL=p.length-1}else w.Tools.Warn(`Morph target normals for mesh ${c.name} were not exported. Mesh does not have normals vertex data`)}if(y.hasTangents){const N=y.getTangents(),W=I.getVerticesData(q.e.TangentKind);if(W){i=W.length/4;const y=new Float32Array(3*i);L=0;for(let A=L;A<i;++A){const c=l.gc.yA(W,4*A);b(c);const w=l.gc.yA(N,3*A);b(w),w.subtractToRef(c,O),y[3*A]=O.x*o,y[3*A+1]=O.y,y[3*A+2]=O.z}const c=A.createBufferView(y,12),w=A.createAccessor(c,"VEC3",5126,i,0);p.push(w),h.attributes.TANGENT=p.length-1}else w.Tools.Warn(`Morph target tangents for mesh ${c.name} were not exported. Mesh does not have tangents vertex data`)}if(y.hasColors){const N=y.getColors(),W=I.getVerticesData(q.e.ColorKind),o=I.getVertexBuffer(q.e.ColorKind);if(W&&o){const y=o.getSize();i=W.length/y;const c=new Float32Array(i*y);L=0;for(let A=L;A<i;++A)if(3===y){const w=l.gc.yA(W,A*y);l.gc.yA(N,A*y).subtractToRef(w,O),c[3*A]=O.x,c[3*A+1]=O.y,c[3*A+2]=O.z}else if(4===y){const w=new l.Vector4,p=l.Vector4.yA(W,A*y);l.Vector4.yA(N,A*y).subtractToRef(p,w),c[4*A]=w.x,c[4*A+1]=w.y,c[4*A+2]=w.z,c[4*A+3]=w.w}else w.Tools.Warn(`Unsupported number of components for color attribute: ${y}`);const I=A.createBufferView(c,4*y),q=A.createAccessor(I,3===y?"VEC3":"VEC4",5126,i,0);p.push(q),h.attributes.COLOR_0=p.length-1}else w.Tools.Warn(`Morph target colors for mesh ${c.name} were not exported. Mesh does not have colors vertex data`)}return h}var Cy=A(12869),Ky=A(12725),mc=A(12704),Ty=A(12283);class zy{}zy.DEFAULT_COLOR=P.dc.White(),zy.DEFAULT_WIDTH_ATTENUATED=1,zy.DEFAULT_WIDTH=.1;var Sy=A(12529),My=A(12876);class ky{static ConvertPoints(y,c){if(y.length&&Array.isArray(y)&&"number"===typeof y[0])return[y];if(y.length&&Array.isArray(y[0])&&"number"===typeof y[0][0])return y;if(y.length&&!Array.isArray(y[0])&&y[0]instanceof l.gc){const c=[];for(let A=0;A<y.length;A++){const l=y[A];c.push(l.x,l.y,l.z)}return[c]}if(y.length>0&&Array.isArray(y[0])&&y[0].length>0&&y[0][0]instanceof l.gc){const c=[],A=y;for(const y of A)c.push(y.flatMap((y=>[y.x,y.y,y.z])));return c}if(y instanceof Float32Array){if(null!==c&&void 0!==c&&c.floatArrayStride){const A=[],l=3*c.floatArrayStride;for(let c=0;c<y.length;c+=l){const w=new Array(l);for(let A=0;A<l;A++)w[A]=y[c+A];A.push(w)}return A}return[Array.from(y)]}if(y.length&&y[0]instanceof Float32Array){const c=[];for(const A of y)c.push(Array.from(A));return c}return[]}static OmitZeroLengthPredicate(y,c,A){const l=[];return c.xc(y).lengthSquared()>0&&l.push([y,c]),A.xc(c).lengthSquared()>0&&l.push([c,A]),y.xc(A).lengthSquared()>0&&l.push([A,y]),0===l.length?null:l}static OmitDuplicatesPredicate(y,c,A,l){const w=[];return ky._SearchInPoints(y,c,l)||w.push([y,c]),ky._SearchInPoints(c,A,l)||w.push([c,A]),ky._SearchInPoints(A,y,l)||w.push([A,y]),0===w.length?null:w}static _SearchInPoints(y,c,A){for(const p of A)for(let A=0;A<p.length;A++){var l,w,N;if(null!==(l=p[A])&&void 0!==l&&l.equals(y))if(null!==(w=p[A+1])&&void 0!==w&&w.equals(c)||null!==(N=p[A-1])&&void 0!==N&&N.equals(c))return!0}return!1}static MeshesToLines(y,c){const A=[];for(let w=0;w<y.length;w++){const N=y[w],p=N.getVerticesData(q.e.PositionKind),W=N.rc();if(p&&W)for(let y=0,h=0;y<W.length;y++){const I=3*W[h++],q=3*W[h++],o=3*W[h++],O=new l.gc(p[I],p[I+1],p[I+2]),L=new l.gc(p[q],p[q+1],p[q+2]),i=new l.gc(p[o],p[o+1],p[o+2]);if(c){const l=c(O,L,i,A,y,I,N,w,p,W);if(l)for(const y of l)A.push(y)}else A.push([O,L],[L,i],[i,O])}}return A}static ToVector3Array(y){if(Array.isArray(y[0])){const c=[],A=y;for(const y of A){const A=[];for(let c=0;c<y.length;c+=3)A.push(new l.gc(y[c],y[c+1],y[c+2]));c.push(A)}return c}const c=y,A=[];for(let w=0;w<c.length;w+=3)A.push(new l.gc(c[w],c[w+1],c[w+2]));return A}static ToNumberArray(y){return y.flatMap((y=>[y.x,y.y,y.z]))}static GetPointsCountInfo(y){const c=new Array(y.length);let A=0;for(let l=y.length;l--;)c[l]=y[l].length/3,A+=c[l];return{total:A,counts:c}}static GetLineLength(y){if(0===y.length)return 0;let c;c="number"===typeof y[0]?ky.ToVector3Array(y):y;const A=l.TmpVectors.gc[0];let w=0;for(let l=0;l<c.length-1;l++){const y=c[l];w+=c[l+1].subtractToRef(y,A).length()}return w}static GetLineLengthArray(y){const c=new Float32Array(y.length/3);let A=0;for(let l=0,w=y.length/3-1;l<w;l++){let w=y[3*l+0],N=y[3*l+1],p=y[3*l+2];w-=y[3*l+3],N-=y[3*l+4],p-=y[3*l+5];A+=Math.sqrt(w*w+N*N+p*p),c[l+1]=A}return c}static SegmentizeSegmentByCount(y,c,A){const w=[],N=c.xc(y),p=l.TmpVectors.gc[0];p.vc(A);const W=l.TmpVectors.gc[1];N.divideToRef(p,W);let h=y.clone();w.push(h);for(let l=0;l<A;l++)h=h.clone(),w.push(h.addInPlace(W));return w}static SegmentizeLineBySegmentLength(y,c){const A=y[0]instanceof l.gc?ky.GetLineSegments(y):"number"===typeof y[0]?ky.GetLineSegments(ky.ToVector3Array(y)):y,w=[];for(const l of A)if(l.length>c){const y=ky.SegmentizeSegmentByCount(l.point1,l.point2,Math.ceil(l.length/c));for(const c of y)w.push(c)}else w.push(l.point1),w.push(l.point2);return w}static SegmentizeLineBySegmentCount(y,c){const A="number"===typeof y[0]?ky.ToVector3Array(y):y,l=ky.GetLineLength(A)/c;return ky.SegmentizeLineBySegmentLength(A,l)}static GetLineSegments(y){const c=[];for(let A=0;A<y.length-1;A++){const l=y[A],w=y[A+1],N=w.xc(l).length();c.push({point1:l,point2:w,length:N})}return c}static GetMinMaxSegmentLength(y){const c=ky.GetLineSegments(y).sort((y=>y.length));return{min:c[0].length,max:c[c.length-1].length}}static GetPositionOnLineByVisibility(y,c,A){let w=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const N=c*A;let p=0,W=0;const h=y.length;for(let l=0;l<h;l++){if(N<=p+y[l].length){W=l;break}p+=y[l].length}const I=(N-p)/y[W].length;return y[W].point2.subtractToRef(y[W].point1,l.TmpVectors.gc[0]),l.TmpVectors.gc[1]=l.TmpVectors.gc[0].multiplyByFloats(I,I,I),w||l.TmpVectors.gc[1].addInPlace(y[W].point1),l.TmpVectors.gc[1].clone()}static GetCircleLinePoints(y,c){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:y,N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/c;const p=[];for(let W=0;W<=c;W++)p.push(new l.gc(Math.cos(W*N)*y,Math.sin(W*N)*w,A));return p}static GetBezierLinePoints(y,c,A,l){return Sy.g.CreateQuadraticBezier(y,c,A,l).getPoints().flatMap((y=>[y.x,y.y,y.z]))}static GetArrowCap(y,c,A,l,w){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,p=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[y.clone(),y.add(c.multiplyByFloats(A,A,A))],widths:[l,w,N,p]}}static GetPointsFromText(y,c,A,l){let w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const p=[],W=(0,My.c)(y,c,A,l);for(const h of W){for(const y of h.paths){const c=[],A=y.getPoints();for(const y of A)c.push(y.x,y.y,w);p.push(c)}if(N)for(const y of h.holes){const c=[],A=y.getPoints();for(const y of A)c.push(y.x,y.y,w);p.push(c)}}return p}static Color3toRGBAUint8(y){const c=new Uint8Array(4*y.length);for(let A=0,l=0;A<y.length;A++)c[l++]=255*y[A].r,c[l++]=255*y[A].g,c[l++]=255*y[A].b,c[l++]=255;return c}static CreateColorsTexture(y,c,A,l){const w=l.getEngine().getCaps().maxTextureSize??1,N=c.length>w?w:c.length,p=Math.ceil(c.length/w);p>1&&(c=[...c,...Array(N*p-c.length).fill(c[0])]);const W=ky.Color3toRGBAUint8(c),h=new C.b(W,N,p,i.c.TEXTUREFORMAT_RGBA,l,!1,!0,A);return h.name=y,h}static PrepareEmptyColorsTexture(y){if(!zy.EmptyColorsTexture){const c=new Uint8Array(4);zy.EmptyColorsTexture=new C.b(c,1,1,i.c.TEXTUREFORMAT_RGBA,y,!1,!1,C.b.NEAREST_NEAREST),zy.EmptyColorsTexture.name="grlEmptyColorsTexture"}return zy.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var y;null===(y=zy.EmptyColorsTexture)||void 0===y||y.dispose(),zy.EmptyColorsTexture=null}static BooleanToNumber(y){return y?1:0}}class ay extends mc.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class uy extends Ky.c{isCompatible(y){return!0}constructor(y,c,A){var w;A=A||{color:zy.DEFAULT_COLOR};const N=new ay;N.GREASED_LINE_HAS_COLOR=!!A.color&&!A.useColors,N.GREASED_LINE_SIZE_ATTENUATION=A.sizeAttenuation??!1,N.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===A.colorDistributionType,N.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(c??y.mc()).useRightHandedSystem,N.GREASED_LINE_CAMERA_FACING=A.cameraFacing??!0,super(y,uy.GREASED_LINE_MATERIAL_NAME,200,N,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(w=A)||void 0===w?void 0:w.forceGLSL)||uy.ForceGLSL,this._scene=c??y.mc(),this._engine=this._scene.getEngine(),this._cameraFacing=A.cameraFacing??!0,this.visibility=A.visibility??1,this.useDash=A.useDash??!1,this.dashRatio=A.dashRatio??.5,this.dashOffset=A.dashOffset??0,this.width=A.width?A.width:A.sizeAttenuation?zy.DEFAULT_WIDTH_ATTENUATED:zy.DEFAULT_WIDTH,this._sizeAttenuation=A.sizeAttenuation??!1,this.colorMode=A.colorMode??0,this._color=A.color??null,this.useColors=A.useColors??!1,this._colorsDistributionType=A.colorDistributionType??0,this.colorsSampling=A.colorsSampling??C.b.NEAREST_NEAREST,this._colors=A.My??null,this.dashCount=A.dashCount??1,this.resolution=A.resolution??new l.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),A.colorsTexture?this.colorsTexture=A.colorsTexture:this._colors?this.colorsTexture=ky.CreateColorsTexture(`${y.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??zy.DEFAULT_COLOR,ky.PrepareEmptyColorsTexture(this._scene)),this._engine.zc.add((()=>{ky.DisposeEmptyColorsTexture()}))}getAttributes(y){y.push("grl_offsets"),y.push("grl_widths"),y.push("grl_colorPointers"),y.push("grl_counters"),this._cameraFacing?(y.push("grl_previousAndSide"),y.push("grl_nextAndCounters")):y.push("grl_slopes")}getSamplers(y){y.push("grl_colors")}getActiveTextures(y){this.colorsTexture&&y.push(this.colorsTexture)}getUniforms(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const c=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&c.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===y&&c.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:c,vertex:this._cameraFacing&&this._isGLSL(y)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(y)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(y){if(this._cameraFacing){y.Qc("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||y.Qc("viewProjection",this._scene.getTransformMatrix());const c=l.TmpVectors.Vector4[0];c.x=this._aspect,c.y=this._resolution.x,c.z=this._resolution.y,c.w=this.width,y.updateVector4("grl_aspect_resolution_lineWidth",c)}const c=l.TmpVectors.Vector4[0];c.x=ky.BooleanToNumber(this.useDash),c.y=this._dashArray,c.z=this.dashOffset,c.w=this.dashRatio,y.updateVector4("grl_dashOptions",c);const A=l.TmpVectors.Vector4[1];A.x=this.colorMode,A.y=this.visibility,A.z=this.colorsTexture?this.colorsTexture.getSize().width:0,A.w=ky.BooleanToNumber(this.useColors),y.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",A),this._color&&y.updateColor3("grl_singleColor",this._color);const w=this.colorsTexture??zy.EmptyColorsTexture;y.setTexture("grl_colors",w),y.updateFloat2("grl_textureSize",(null===w||void 0===w?void 0:w.getSize().width)??1,(null===w||void 0===w?void 0:w.getSize().height)??1)}prepareDefines(y,c,A){y.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,y.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,y.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,y.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=c.useRightHandedSystem,y.GREASED_LINE_CAMERA_FACING=this._cameraFacing,y.GREASED_LINE_USE_OFFSETS=!!A.offsets}getClassName(){return uy.GREASED_LINE_MATERIAL_NAME}getCustomCode(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(c)?function(y,c){if("vertex"===y){const y={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return c&&(y["!gl_Position\\=viewProjection\\*worldPos;"]="//"),y}return"fragment"===y?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(y,this._cameraFacing):function(y,c){if("vertex"===y){const y={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return c&&(y["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),y}return"fragment"===y?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(y,this._cameraFacing)}dispose(){var y;null===(y=this.colorsTexture)||void 0===y||y.dispose(),super.dispose()}get My(){return this._colors}set My(y){this.setColors(y)}setColors(y){var c;let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const w=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var N;if(this._colors=y,null!==y&&0!==y.length){if(!A||l)if(this.colorsTexture&&w===y.length&&!l){const c=ky.Color3toRGBAUint8(y);this.colorsTexture.update(c)}else{var p;null===(p=this.colorsTexture)||void 0===p||p.dispose(),this.colorsTexture=ky.CreateColorsTexture(`${this._material.name}-colors-texture`,y,this.colorsSampling,this._scene)}}else null===(N=this.colorsTexture)||void 0===N||N.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(y){this._dashCount=y,this._dashArray=1/y}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(y){this._sizeAttenuation=y,this.markAllDefinesAsDirty()}get color(){return this._color}set color(y){this.setColor(y)}setColor(y){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==y||null!==this._color&&null===y?(this._color=y,c||this.markAllDefinesAsDirty()):this._color=y}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(y){this._colorsDistributionType=y,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(y){this._aspect=y.x/y.y,this._resolution=y}serialize(){const y=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(c.My=this._colors),this._color&&(c.color=this._color),y.greasedLineMaterialOptions=c,y}parse(y,c,A){var l;super.parse(y,c,A);const w=y.greasedLineMaterialOptions;null===(l=this.colorsTexture)||void 0===l||l.dispose(),w.color&&this.setColor(w.color,!0),w.colorDistributionType&&(this.colorsDistributionType=w.colorDistributionType),w.My&&(this.My=w.My),w.colorsSampling&&(this.colorsSampling=w.colorsSampling),w.colorMode&&(this.colorMode=w.colorMode),w.useColors&&(this.useColors=w.useColors),w.visibility&&(this.visibility=w.visibility),w.useDash&&(this.useDash=w.useDash),w.dashCount&&(this.dashCount=w.dashCount),w.dashRatio&&(this.dashRatio=w.dashRatio),w.dashOffset&&(this.dashOffset=w.dashOffset),w.width&&(this.width=w.width),w.sizeAttenuation&&(this.sizeAttenuation=w.sizeAttenuation),w.resolution&&(this.resolution=w.resolution),this.My?this.colorsTexture=ky.CreateColorsTexture(`${this._material.name}-colors-texture`,this.My,this.colorsSampling,c):ky.PrepareEmptyColorsTexture(c),this.markAllDefinesAsDirty()}copyTo(y){var c;const A=y;null===(c=A.colorsTexture)||void 0===c||c.dispose(),this._colors&&(A.colorsTexture=ky.CreateColorsTexture(`${A._material.name}-colors-texture`,this._colors,A.colorsSampling,this._scene)),A.setColor(this.color,!0),A.colorsDistributionType=this.colorsDistributionType,A.colorsSampling=this.colorsSampling,A.colorMode=this.colorMode,A.useColors=this.useColors,A.visibility=this.visibility,A.useDash=this.useDash,A.dashCount=this.dashCount,A.dashRatio=this.dashRatio,A.dashOffset=this.dashOffset,A.width=this.width,A.sizeAttenuation=this.sizeAttenuation,A.resolution=this.resolution,A.markAllDefinesAsDirty()}_isGLSL(y){return 0===y||this._forceGLSL}}uy.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",uy.ForceGLSL=!1,(0,Ty.f)(`BABYLON.${uy.GREASED_LINE_MATERIAL_NAME}`,uy);var Gy=A(12758),jy=A(12167),fy=A(12549),Vy=A(12258);class Jy extends fy.ShaderMaterial{constructor(y,c,w){const N=c.getEngine(),p=N.isWebGPU&&!(w.forceGLSL||Jy.ForceGLSL),W=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];c.useRightHandedSystem&&W.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const h=["position","grl_widths","grl_offsets","grl_colorPointers"];w.cameraFacing?(W.push("GREASED_LINE_CAMERA_FACING"),h.push("grl_previousAndSide","grl_nextAndCounters")):(h.push("grl_slopes"),h.push("grl_counters"));const I=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(p||I.push("world","viewProjection","view","projection"),super(y,c,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:p?["Scene","Mesh"]:void 0,attributes:h,uniforms:I,samplers:p?[]:["grlColors"],defines:W,extraInitializationsAsync:async()=>{p?await Promise.all([A.e(66).then(A.bind(A,15425)),A.e(75).then(A.bind(A,15432))]):await Promise.all([A.e(69).then(A.bind(A,15437)),A.e(76).then(A.bind(A,15446))])},shaderLanguage:p?1:0}),this._color=P.dc.White(),this._colorsDistributionType=0,this._colorsTexture=null,w=w||{color:zy.DEFAULT_COLOR},this.visibility=w.visibility??1,this.useDash=w.useDash??!1,this.dashRatio=w.dashRatio??.5,this.dashOffset=w.dashOffset??0,this.dashCount=w.dashCount??1,this.width=w.width?w.width:w.sizeAttenuation&&w.cameraFacing?zy.DEFAULT_WIDTH_ATTENUATED:zy.DEFAULT_WIDTH,this.sizeAttenuation=w.sizeAttenuation??!1,this.color=w.color??P.dc.White(),this.useColors=w.useColors??!1,this.colorsDistributionType=w.colorDistributionType??0,this.colorsSampling=w.colorsSampling??C.b.NEAREST_NEAREST,this.colorMode=w.colorMode??0,this._colors=w.My??null,this._cameraFacing=w.cameraFacing??!0,this.resolution=w.resolution??new l.Vector2(N.getRenderWidth(),N.getRenderHeight()),w.colorsTexture?this.colorsTexture=w.colorsTexture:this._colors?this.colorsTexture=ky.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,c):(this._color=this._color??zy.DEFAULT_COLOR,this.colorsTexture=ky.PrepareEmptyColorsTexture(c)),p){const y=new Vy.b;y.setParameters(),y.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",y)}N.zc.add((()=>{ky.DisposeEmptyColorsTexture()}))}dispose(){var y;null===(y=this._colorsTexture)||void 0===y||y.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new l.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get My(){return this._colors}set My(y){this.setColors(y)}setColors(y){var c;let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const w=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var N;if(this._colors=y,null!==y&&0!==y.length){if(!A||l)if(this._colorsTexture&&w===y.length&&!l){const c=ky.Color3toRGBAUint8(y);this._colorsTexture.update(c)}else{var p;null===(p=this._colorsTexture)||void 0===p||p.dispose(),this.colorsTexture=ky.CreateColorsTexture(`${this.name}-colors-texture`,y,this.colorsSampling,this.mc())}}else null===(N=this._colorsTexture)||void 0===N||N.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(y){this._colorsTexture=y,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(y){this._width=y,this.setFloat("grlWidth",y)}get useColors(){return this._useColors}set useColors(y){this._useColors=y,this.setFloat("grlUseColors",ky.BooleanToNumber(y))}get colorsSampling(){return this._colorsSampling}set colorsSampling(y){this._colorsSampling=y}get visibility(){return this._visibility}set visibility(y){this._visibility=y,this.setFloat("grlVisibility",y)}get useDash(){return this._useDash}set useDash(y){this._useDash=y,this.setFloat("grlUseDash",ky.BooleanToNumber(y))}get dashOffset(){return this._dashOffset}set dashOffset(y){this._dashOffset=y,this.setFloat("grlDashOffset",y)}get dashRatio(){return this._dashRatio}set dashRatio(y){this._dashRatio=y,this.setFloat("grlDashRatio",y)}get dashCount(){return this._dashCount}set dashCount(y){this._dashCount=y,this._dashArray=1/y,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(y){this._sizeAttenuation=y,this.setFloat("grlSizeAttenuation",ky.BooleanToNumber(y))}get color(){return this._color}set color(y){this.setColor(y)}setColor(y){y=y??zy.DEFAULT_COLOR,this._color=y,this.setColor3("grlColor",y)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(y){this._colorsDistributionType=y,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(y){this._colorMode=y,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(y){this._resolution=y,this.setVector2("grlResolution",y),this.setFloat("grlAspect",y.x/y.y)}serialize(){const y=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(c.My=this._colors),y.greasedLineMaterialOptions=c,y}parse(y,c,A){var l;const w=y.greasedLineMaterialOptions;null===(l=this._colorsTexture)||void 0===l||l.dispose(),w.color&&(this.color=w.color),w.colorDistributionType&&(this.colorsDistributionType=w.colorDistributionType),w.colorsSampling&&(this.colorsSampling=w.colorsSampling),w.colorMode&&(this.colorMode=w.colorMode),w.useColors&&(this.useColors=w.useColors),w.visibility&&(this.visibility=w.visibility),w.useDash&&(this.useDash=w.useDash),w.dashCount&&(this.dashCount=w.dashCount),w.dashRatio&&(this.dashRatio=w.dashRatio),w.dashOffset&&(this.dashOffset=w.dashOffset),w.width&&(this.width=w.width),w.sizeAttenuation&&(this.sizeAttenuation=w.sizeAttenuation),w.resolution&&(this.resolution=w.resolution),w.My?this.colorsTexture=ky.CreateColorsTexture(`${this.name}-colors-texture`,w.My,this.colorsSampling,this.mc()):this.colorsTexture=ky.PrepareEmptyColorsTexture(c),this._cameraFacing=w.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Uy,ey,Qy;Jy.ForceGLSL=!1,function(y){y[y.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",y[y.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Uy||(Uy={})),function(y){y[y.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",y[y.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",y[y.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(ey||(ey={})),function(y){y[y.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",y[y.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",y[y.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",y[y.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",y[y.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Qy||(Qy={}));class Yy extends ty.b{constructor(y,c,A){super(y,c,null,null,!1,!1),this.name=y,this._options=A,this._lazy=!1,this._updatable=!1,this._engine=c.getEngine(),this._lazy=A.lazy??!1,this._updatable=A.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=A.colorPointers??[],this._widths=A.widths??new Array(A.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(y){let c=0;for(const l of this._points)c+=l.length;const A=c/3*2-this._widths.length;for(let l=0;l<A;l++)this._widths.push(y)}updateLazy(){var y,c;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(y=this._options.ribbonOptions)||void 0===y?void 0:y.smoothShading),!this.jy&&this.refreshBoundingInfo(),null===(c=this.greasedLineMaterial)||void 0===c||c.updateLazy()}addPoints(y,c){for(const A of y)this._points.push(A);this._lazy||this.setPoints(this._points,c)}dispose(y){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(y,c)}isLazy(){return this._lazy}get ky(){return this._uvs}set ky(y){this._uvs=y instanceof Float32Array?y:new Float32Array(y),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(y){this.material instanceof Jy&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===y||void 0===y?void 0:y.length)>0),this._offsets=y,this._offsetsBuffer?this._offsetsBuffer.update(y):this._createOffsetsBuffer(y)}get widths(){return this._widths}set widths(y){this._widths=y,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(y)}get colorPointers(){return this._colorPointers}set colorPointers(y){this._colorPointers=y,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(y)}get greasedLineMaterial(){var y,c;if(this.material&&this.material instanceof Jy)return this.material;const A=null===(y=this.material)||void 0===y||null===(c=y.pluginManager)||void 0===c?void 0:c.getPlugin(uy.GREASED_LINE_MATERIAL_NAME);return A||void 0}get points(){const y=[];return jy.e.DeepCopy(this._points,y),y}setPoints(y,c){this._points=ky.ConvertPoints(y,(null===c||void 0===c?void 0:c.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==c&&void 0!==c&&c.colorPointers||this._updateColorPointers(),this._setPoints(this._points,c)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,ky:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(y){super.serialize(y),y.type=this.getClassName(),y.lineOptions=this._createLineOptions()}_createVertexBuffers(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new Gy.b;return c.zy=this._vertexPositions,c.indices=this._indices,c.ky=this._uvs,y&&(c.Sy=[],Gy.b.ComputeNormals(this._vertexPositions,this._indices,c.Sy)),c.Gy(this,this._options.updatable),c}_createOffsetsBuffer(y){const c=this._scene.getEngine(),A=new q.c(c,y,this._updatable,3);this.setVerticesBuffer(A.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=A}}class gy{constructor(y,c){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=y,this.wasAddedByNoopNode=c}getIndicesAccessor(y,c,A,l,w){var N,p,W,h;return null===(N=this._indicesAccessorMap.get(y))||void 0===N||null===(p=N.get(c))||void 0===p||null===(W=p.get(A))||void 0===W||null===(h=W.get(l))||void 0===h?void 0:h.get(w)}setIndicesAccessor(y,c,A,l,w,N){let p=this._indicesAccessorMap.get(y);p||(p=new Map,this._indicesAccessorMap.set(y,p));let W=p.get(c);W||(W=new Map,p.set(c,W));let h=W.get(A);h||(h=new Map,W.set(A,h));let I=h.get(l);I||(I=new Map,h.set(l,I)),I.set(w,N)}pushExportedNode(y){this._exportedNodes.has(y)||this._exportedNodes.add(y)}getNodesSet(){return this._exportedNodes}getVertexBufferView(y){return this._vertexBufferViewMap.get(y)}setVertexBufferView(y,c){this._vertexBufferViewMap.set(y,c)}setRemappedBufferView(y,c,A){this._remappedBufferView.set(y,new Map),this._remappedBufferView.get(y).set(c,A)}getRemappedBufferView(y,c){var A;return null===(A=this._remappedBufferView.get(y))||void 0===A?void 0:A.get(c)}getVertexAccessor(y,c,A){var l,w;return null===(l=this._vertexAccessorMap.get(y))||void 0===l||null===(w=l.get(c))||void 0===w?void 0:w.get(A)}setVertexAccessor(y,c,A,l){let w=this._vertexAccessorMap.get(y);w||(w=new Map,this._vertexAccessorMap.set(y,w));let N=w.get(c);N||(N=new Map,w.set(c,N)),N.set(A,l)}hasVertexColorAlpha(y){return this._vertexMapColorAlpha.get(y)||!1}setHasVertexColorAlpha(y,c){return this._vertexMapColorAlpha.set(y,c)}getMesh(y){return this._meshMap.get(y)}setMesh(y,c){this._meshMap.set(y,c)}bindMorphDataToMesh(y,c){const A=this._meshMorphTargetMap.get(y)||[];this._meshMorphTargetMap.set(y,A),-1===A.indexOf(c)&&A.push(c)}getMorphTargetsFromMesh(y){return this._meshMorphTargetMap.get(y)}}class xy{_ApplyExtension(y,c,A,l){if(A>=c.length)return Promise.resolve(y);const w=l(c[A],y);return w?w.then((async y=>y?await this._ApplyExtension(y,c,A+1,l):null)):this._ApplyExtension(y,c,A+1,l)}_ApplyExtensions(y,c){const A=[];for(const l of xy._ExtensionNames)A.push(this._extensions[l]);return this._ApplyExtension(y,A,0,c)}_extensionsPreExportTextureAsync(y,c,A){return this._ApplyExtensions(c,((c,l)=>c.preExportTextureAsync&&c.preExportTextureAsync(y,l,A)))}_extensionsPostExportNodeAsync(y,c,A,l,w){return this._ApplyExtensions(c,((c,N)=>c.postExportNodeAsync&&c.postExportNodeAsync(y,N,A,l,w,this._bufferManager)))}_extensionsPostExportMaterialAsync(y,c,A){return this._ApplyExtensions(c,((c,l)=>c.postExportMaterialAsync&&c.postExportMaterialAsync(y,l,A)))}_extensionsPostExportMaterialAdditionalTextures(y,c,A){const l=[];for(const w of xy._ExtensionNames){const N=this._extensions[w];N.postExportMaterialAdditionalTextures&&l.push(...N.postExportMaterialAdditionalTextures(y,c,A))}return l}_extensionsPostExportTextures(y,c,A){for(const l of xy._ExtensionNames){const w=this._extensions[l];w.postExportTexture&&w.postExportTexture(y,c,A)}}_extensionsPostExportMeshPrimitive(y){for(const c of xy._ExtensionNames){const A=this._extensions[c];A.postExportMeshPrimitive&&A.postExportMeshPrimitive(y,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const y of xy._ExtensionNames){const c=this._extensions[y];c.preGenerateBinaryAsync&&await c.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(y){for(const c of xy._ExtensionNames){const A=this._extensions[c];A.enabled&&y(A)}}_extensionsOnExporting(){this._forEachExtensions((y=>{var c,A,l;y.wasUsed&&((c=this._glTF).extensionsUsed||(c.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(y.name)&&this._glTF.extensionsUsed.push(y.name),y.required&&((A=this._glTF).extensionsRequired||(A.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(y.name)&&this._glTF.extensionsRequired.push(y.name)),(l=this._glTF).extensions||(l.extensions={}),y.onExporting&&y.onExporting())}))}_loadExtensions(){for(const y of xy._ExtensionNames){const c=xy._ExtensionFactories[y](this);this._extensions[y]=c}}constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:H.c.LastCreatedScene,c=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${i.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new V(this),this._extensions={},this._bufferManager=new qy,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!y)throw new Error("No scene available to export");this._babylonScene=y,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:y=>{var c;return null===y||void 0===y||null===(c=y.uc)||void 0===c?void 0:c.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...c},this._loadExtensions()}dispose(){for(const y in this._extensions){this._extensions[y].dispose()}}get options(){return this._options}static RegisterExtension(y,c){xy.UnregisterExtension(y)&&w.Tools.Warn(`Extension with the name ${y} already exists`),xy._ExtensionFactories[y]=c,xy._ExtensionNames.push(y)}static UnregisterExtension(y){if(!xy._ExtensionFactories[y])return!1;delete xy._ExtensionFactories[y];const c=xy._ExtensionNames.indexOf(y);return-1!==c&&xy._ExtensionNames.splice(c,1),!0}_generateJSON(y,c,A){const l={byteLength:y};return l.byteLength&&(this._glTF.buffers=[l]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Fc=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(l.uri=c+".bin"),A?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(y){const c=await this._generateBinaryAsync();this._extensionsOnExporting();const A=this._generateJSON(c.byteLength,y,!0),l=new Blob([c],{type:"application/octet-stream"}),w=y+".gltf",N=y+".bin",p=new I;if(p.files[w]=A,p.files[N]=l,this._imageData)for(const W in this._imageData)p.files[W]=new Blob([this._imageData[W].data],{type:this._imageData[W].mimeType});return p}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(y){const c=y%4;return 0===c?c:4-c}async generateGLBAsync(y){this._shouldUseGlb=!0;const c=await this._generateBinaryAsync();this._extensionsOnExporting();const A=this._generateJSON(c.byteLength),l=y+".glb";let w,N=A.length;if("undefined"!==typeof TextEncoder){w=(new TextEncoder).encode(A),N=w.length}const p=this._getPadding(N),W=this._getPadding(c.byteLength),h=28+N+p+c.byteLength+W,q=new hy(h);if(q.writeUInt32(1179937895),q.writeUInt32(2),q.writeUInt32(h),q.writeUInt32(N+p),q.writeUInt32(1313821514),w)q.writeTypedArray(w);else{const y="_".charCodeAt(0);for(let c=0;c<N;++c){const l=A.charCodeAt(c);l!=A.codePointAt(c)?q.writeUInt8(y):q.writeUInt8(l)}}for(let I=0;I<p;++I)q.writeUInt8(32);q.writeUInt32(c.byteLength+W),q.writeUInt32(5130562),q.writeTypedArray(c);for(let I=0;I<W;++I)q.writeUInt8(0);const o=new I;return o.files[l]=new Blob([q.getOutputData()],{type:"application/octet-stream"}),o}_setNodeTransformation(y,c,A){if(c.getPivotPoint().equalsWithEpsilon(Y,Q.b)||w.Tools.Warn("Pivot points are not supported in the glTF serializer"),!c.position.equalsWithEpsilon(Y,Q.b)){const w=l.TmpVectors.gc[0].p(c.position);A&&Z(w),y.translation=w.fc()}c.bc.equalsWithEpsilon(x,Q.b)||(y.scale=c.bc.fc());const N=c.rotationQuaternion||l.Quaternion.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);N.equalsWithEpsilon(g,Q.b)||(A&&v(N),y.rotation=N.normalize().fc())}_setCameraTransformation(y,c,A){if(!c.position.equalsWithEpsilon(Y,Q.b)){const w=l.TmpVectors.gc[0].p(c.position);A&&Z(w),y.translation=w.fc()}const w=c.rotationQuaternion||l.Quaternion.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);A&&v(w),this._babylonScene.useRightHandedSystem||d(w),w.equalsWithEpsilon(g,Q.b)||(y.rotation=w.fc())}_listAvailableCameras(){for(const y of this._babylonScene.cameras){const c={type:y.mode===Oy.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(y.name&&(c.name=y.name),"perspective"===c.type)c.perspective={aspectRatio:y.getEngine().getAspectRatio(y),yfov:y.fovMode===Oy.c.FOVMODE_VERTICAL_FIXED?y.fov:y.fov*y.getEngine().getAspectRatio(y),znear:y.ec,zfar:y.maxZ};else if("orthographic"===c.type){const A=y.orthoLeft&&y.orthoRight?.5*(y.orthoRight-y.orthoLeft):.5*y.getEngine().getRenderWidth(),l=y.orthoBottom&&y.orthoTop?.5*(y.orthoTop-y.orthoBottom):.5*y.getEngine().getRenderHeight();c.orthographic={xmag:A,ymag:l,znear:y.ec,zfar:y.maxZ}}this._camerasMap.set(y,c)}}_exportAndAssignCameras(){const y=Array.from(this._camerasMap.values());for(const c of y){const y=this._nodesCameraMap.get(c);if(void 0!==y){this._cameras.push(c);for(const c of y)c.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const y of this._babylonScene.skeletons){if(y.bones.length<=0)continue;const c={joints:[]};this._skinMap.set(y,c)}}_exportAndAssignSkeletons(){for(const y of this._babylonScene.skeletons){if(y.bones.length<=0)continue;const c=this._skinMap.get(y);if(void 0==c)continue;const A={},l=[];let N=-1;for(let w=0;w<y.bones.length;++w){const c=y.bones[w],l=c.getIndex()??w;-1!==l&&(A[l]=c,l>N&&(N=l))}for(let y=0;y<=N;++y){const N=A[y];l.push(N.getAbsoluteInverseBindMatrix());const p=N.getTransformNode();if(null!==p){const y=this._nodeMap.get(p);p&&null!==y&&void 0!==y?c.joints.push(y):w.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else w.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const p=this._nodesSkinMap.get(c);if(c.joints.length>0&&void 0!==p){const y=64*l.length,A=new Float32Array(y/4);l.forEach(((y,c)=>{A.set(y.m,16*c)}));const w=this._bufferManager.createBufferView(A);this._accessors.push(this._bufferManager.createAccessor(w,"MAT4",5126,l.length)),c.inverseBindMatrices=this._accessors.length-1,this._skins.push(c);for(const c of p)c.skin=this._skins.length-1}}}async _exportSceneAsync(){const y={nodes:[]};if(this._babylonScene.metadata){const c=this._options.metadataSelector(this._babylonScene.metadata);c&&(y.extras=c)}const c=new Array,A=new Array,l=new Array;for(const W of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&py(W,this._babylonScene.useRightHandedSystem)?l.push(...W.getChildren()):this._babylonScene.useRightHandedSystem?c.push(W):A.push(W);this._listAvailableCameras(),this._listAvailableSkeletons();const w=new gy(!0,!1);y.nodes.push(...await this._exportNodesAsync(A,w));const N=new gy(!1,!1);y.nodes.push(...await this._exportNodesAsync(c,N));const p=new gy(!1,!0);y.nodes.push(...await this._exportNodesAsync(l,p)),y.nodes.length&&this._scenes.push(y),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&By._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,w.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(y){let c=this._shouldExportNodeMap.get(y);return void 0===c&&(c=this._options.shouldExportNode(y),this._shouldExportNodeMap.set(y,c)),c}async _exportNodesAsync(y,c){const A=new Array;this._exportBuffers(y,c);for(const l of y)await this._exportNodeAsync(l,A,c);return A}_collectBuffers(y,c,A,l,w){if(this._shouldExportNode(y)&&y instanceof O.c&&y.Rc){const N=y.Rc.getVertexBuffers();if(N)for(const l in N){if(!n(l))continue;const p=N[l];w.setHasVertexColorAlpha(p,y.hasVertexAlpha);const W=p._buffer,h=c.get(W)||[];c.set(W,h),-1===h.indexOf(p)&&h.push(p);const I=A.get(p)||[];A.set(p,I),-1===I.indexOf(y)&&I.push(y)}const p=y.morphTargetManager;if(p)for(let c=0;c<p.numTargets;c++){const A=p.getTarget(c),w=l.get(A)||[];l.set(A,w),-1===w.indexOf(y)&&w.push(y)}}for(const N of y.getChildren())this._collectBuffers(N,c,A,l,w)}_exportBuffers(y,c){const A=new Map,l=new Map,w=new Map;for(const W of y)this._collectBuffers(W,A,l,w,c);const N=Array.from(A.keys());for(const W of N){const y=W.getData();if(!y)throw new Error("Buffer data is not available");const w=A.get(W);if(!w)continue;const N=w[0].byteStride;if(w.some((y=>y.byteStride!==N)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const p=Ay(y).slice();for(const c of w){const y=l.get(c),{byteOffset:A,byteStride:w,componentCount:N,type:W,count:h,normalized:I,kind:o}=R(c,y);switch(o){case q.e.NormalKind:case q.e.TangentKind:(0,J.m)(p,A,w,N,W,h,I,(y=>{const c=Math.sqrt(y[0]*y[0]+y[1]*y[1]+y[2]*y[2]);if(c>0){const A=1/c;y[0]*=A,y[1]*=A,y[2]*=A}}));break;case q.e.ColorKind:{const c=y.filter((y=>y.material instanceof Hy.Zc||null==y.material)).length;if(0==c)break;if(c!=y.length){U.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}W==q.e.UNSIGNED_BYTE&&U.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const l=new P.dc,o=new P.ip,O=this._babylonScene.getEngine().useExactSrgbConversions;(0,J.m)(p,A,w,N,W,h,I,(y=>{3===y.length?(l.nA(y,0),l.toLinearSpaceToRef(l,O),l.toArray(y,0)):(o.nA(y,0),o.toLinearSpaceToRef(o,O),o.toArray(y,0))}))}}}if(c.convertToRightHanded){for(const y of w){const c=l.get(y),{byteOffset:A,byteStride:w,componentCount:N,type:W,count:h,normalized:I,kind:o}=R(y,c);switch(o){case q.e.PositionKind:case q.e.NormalKind:case q.e.TangentKind:(0,J.m)(p,A,w,N,W,h,I,(y=>{y[0]=-y[0]}))}}c.convertedToRightHandedBuffers.set(W,p)}const h=this._bufferManager.createBufferView(p,N);c.setVertexBufferView(W,h);const I=new Map;for(const c of w){const y=l.get(c),{kind:A,totalVertices:w}=R(c,y);switch(A){case q.e.MatricesIndicesKind:case q.e.MatricesIndicesExtraKind:if(c.type==q.e.FLOAT){const y=c.getFloatData(w);null!==y&&I.set(c,y)}}}0!==I.size&&U.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const o=Array.from(I.keys());for(const A of o){const y=I.get(A);if(!y)continue;const l=y.some((y=>y>=256)),w=new(l?Uint16Array:Uint8Array)(y.length);for(let c=0;c<y.length;c++)w[c]=y[c];const N=this._bufferManager.createBufferView(w,4*(l?2:1));c.setRemappedBufferView(W,A,N)}}const p=Array.from(w.keys());for(const W of p){const y=w.get(W);if(!y)continue;const A=Xy(W,y[0],this._bufferManager,this._bufferViews,this._accessors,c.convertToRightHanded);for(const l of y)c.bindMorphDataToMesh(l,A)}}async _exportNodeAsync(y,c,A){let l=this._nodeMap.get(y);if(void 0!==l)return void(c.includes(l)||c.push(l));const w=await this._createNodeAsync(y,A);if(w){l=this._nodes.length,this._nodes.push(w),this._nodeMap.set(y,l),A.pushExportedNode(y),c.push(l);const N={name:"runtime animations",channels:[],samplers:[]},p=[];this._babylonScene.animationGroups.length||(By._CreateMorphTargetAnimationFromMorphTargetAnimations(y,N,p,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,A.convertToRightHanded,this._options.shouldExportAnimation),y.animations.length&&By._CreateNodeAnimationFromNodeAnimations(y,N,p,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,A.convertToRightHanded,this._options.shouldExportAnimation)),N.channels.length&&N.samplers.length&&this._animations.push(N),p.forEach((y=>{y.channels.length&&y.samplers.length&&this._animations.push(y)}))}const N=w?[]:c;for(const p of y.getChildren())await this._exportNodeAsync(p,N,A);w&&N.length&&(w.children=N)}async _createNodeAsync(y,c){if(!this._shouldExportNode(y))return null;const A={};if(y.name&&(A.name=y.name),y.metadata){const c=this._options.metadataSelector(y.metadata);c&&(A.extras=c)}if(y instanceof o.d&&(this._setNodeTransformation(A,y,c.convertToRightHanded),y instanceof O.c)){const w=y instanceof L.b?y.sourceMesh:y;if(w.jc&&w.jc.length>0&&(A.mesh=await this._exportMeshAsync(w,c)),y.skeleton){const c=this._skinMap.get(y.skeleton);var l;if(void 0!==c)void 0===this._nodesSkinMap.get(c)&&this._nodesSkinMap.set(c,[]),null===(l=this._nodesSkinMap.get(c))||void 0===l||l.push(A)}}if(y instanceof e.b){const l=this._camerasMap.get(y);if(l){var w;void 0===this._nodesCameraMap.get(l)&&this._nodesCameraMap.set(l,[]),this._setCameraTransformation(A,y,c.convertToRightHanded);const p=y.parent;if(null!==p&&cy(y,p)){const y=this._nodeMap.get(p);if(void 0!==y){var N;const c=this._nodes[y];return yy(A,c),null===(N=this._nodesCameraMap.get(l))||void 0===N||N.push(c),null}}null===(w=this._nodesCameraMap.get(l))||void 0===w||w.push(A)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",A,y,this._nodeMap,c.convertToRightHanded)?A:(U.c.Warn(`Not exporting node ${y.name}`),null)}_exportIndices(y,c,A,l,w,p,W,h,I){let q=y;I.mode=E(p);const o=W!==N.c.CounterClockWiseSideOrientation,O=!h.wasAddedByNoopNode&&o,L=function(y){switch(y){case N.c.TriangleFillMode:case N.c.TriangleStripDrawMode:case N.c.TriangleFanDrawMode:return!0}return!1}(p)&&O;if(L){if(p===N.c.TriangleStripDrawMode||p===N.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");I.mode=E(p);const W=c?new Uint32Array(l):new Uint16Array(l);if(y)for(let c=0;c+2<l;c+=3)W[c]=y[A+c]+w,W[c+1]=y[A+c+2]+w,W[c+2]=y[A+c+1]+w;else for(let y=0;y+2<l;y+=3)W[y]=y,W[y+1]=y+2,W[y+2]=y+1;q=W}else if(y&&0!==w){const N=c?new Uint32Array(l):new Uint16Array(l);for(let c=0;c<l;c++)N[c]=y[A+c]+w;q=N}if(q){let N=h.getIndicesAccessor(y,A,l,w,L);if(void 0===N){const p=function(y,c,A,l){if(y instanceof Uint16Array||y instanceof Uint32Array)return y;if(y instanceof Int32Array)return new Uint32Array(y.buffer,y.byteOffset,y.length);const w=y.slice(c,c+A);return l?new Uint32Array(w):new Uint16Array(w)}(q,0,l,c),W=this._bufferManager.createBufferView(p),I=c?5125:5123;this._accessors.push(this._bufferManager.createAccessor(W,"SCALAR",I,l,0)),N=this._accessors.length-1,h.setIndicesAccessor(y,A,l,w,L,N)}I.indices=N}}_exportVertexBuffer(y,c,A,l,w,N){const p=y.getKind();if(!n(p))return;if(p.startsWith("uv")&&!this._options.exportUnusedUVs&&(!c||!this._materialNeedsUVsSet.has(c)))return;let W=w.getVertexAccessor(y,A,l);if(void 0===W){const c=w.convertedToRightHandedBuffers.get(y._buffer)||y._buffer.getData(),N=p===q.e.PositionKind?function(y,c,A,l){const{byteOffset:w,byteStride:N,type:p,normalized:W}=c,h=c.getSize(),I=new Array(h).fill(1/0),q=new Array(h).fill(-1/0);return(0,J.m)(y,w+A*N,N,h,p,l*h,W,(y=>{for(let c=0;c<h;c++)I[c]=Math.min(I[c],y[c]),q[c]=Math.max(q[c],y[c])})),{min:I,max:q}}(c,y,A,l):void 0,h=(p===q.e.MatricesIndicesKind||p===q.e.MatricesIndicesExtraKind)&&y.type===q.e.FLOAT,I=h?q.e.UNSIGNED_BYTE:y.type,o=h?void 0:y.normalized,O=h?w.getRemappedBufferView(y._buffer,y):w.getVertexBufferView(y._buffer),L=y.byteOffset+A*y.byteStride;this._accessors.push(this._bufferManager.createAccessor(O,function(y,c){if(y==q.e.ColorKind)return c?"VEC4":"VEC3";switch(y){case q.e.PositionKind:case q.e.NormalKind:return"VEC3";case q.e.TangentKind:case q.e.MatricesIndicesKind:case q.e.MatricesIndicesExtraKind:case q.e.MatricesWeightsKind:case q.e.MatricesWeightsExtraKind:return"VEC4";case q.e.UVKind:case q.e.UV2Kind:case q.e.UV3Kind:case q.e.UV4Kind:case q.e.UV5Kind:case q.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${y}`)}(p,w.hasVertexColorAlpha(y)),I,l,L,N,o)),W=this._accessors.length-1,w.setVertexAccessor(y,A,l,W)}N.attributes[function(y){switch(y){case q.e.PositionKind:return"POSITION";case q.e.NormalKind:return"NORMAL";case q.e.TangentKind:return"TANGENT";case q.e.ColorKind:return"COLOR_0";case q.e.UVKind:return"TEXCOORD_0";case q.e.UV2Kind:return"TEXCOORD_1";case q.e.UV3Kind:return"TEXCOORD_2";case q.e.UV4Kind:return"TEXCOORD_3";case q.e.UV5Kind:return"TEXCOORD_4";case q.e.UV6Kind:return"TEXCOORD_5";case q.e.MatricesIndicesKind:return"JOINTS_0";case q.e.MatricesIndicesExtraKind:return"JOINTS_1";case q.e.MatricesWeightsKind:return"WEIGHTS_0";case q.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${y}`)}(p)]=W}async _exportMaterialAsync(y,c,A,l){let w=this._materialMap.get(y);if(void 0===w){const l=c&&Object.keys(c).some((y=>y.startsWith("uv")));if((y=y instanceof Ly.c?y.Up[A.materialIndex]:y)instanceof iy.c)w=await this._materialExporter.exportPBRMaterialAsync(y,"image/png",l);else{if(!(y instanceof Hy.Zc))return void U.c.Warn(`Unsupported material '${y.name}' with type ${y.getClassName()}`);w=await this._materialExporter.exportStandardMaterialAsync(y,"image/png",l)}this._materialMap.set(y,w)}l.material=w}async _exportMeshAsync(y,c){var A;let l=c.getMesh(y);if(void 0!==l)return l;const w={primitives:[]};l=this._meshes.length,this._meshes.push(w),c.setMesh(y,l);const p=y.isUnIndexed?null:y.rc(),W=null===(A=y.Rc)||void 0===A?void 0:A.getVertexBuffers(),h=c.getMorphTargetsFromMesh(y),I=y instanceof Cy.c,q=y instanceof Yy,o=y.jc;if(W&&o&&o.length>0)for(const i of o){const A={attributes:{}},l=i.ey()||this._babylonScene.defaultMaterial;if(q){var O,L;const c={name:l.name},w=y,N=P.dc.White(),p=(null===(O=w.material)||void 0===O?void 0:O.alpha)??1,W=(null===(L=w.greasedLineMaterial)||void 0===L?void 0:L.color)??N;(!W.equalsWithEpsilon(N,Q.b)||p<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...W.fc(),p]}),this._materials.push(c),A.material=this._materials.length-1}else if(I){const c={name:l.name},w=y;(!w.color.equalsWithEpsilon(P.dc.White(),Q.b)||w.alpha<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...w.color.fc(),w.alpha]}),this._materials.push(c),A.material=this._materials.length-1}else await this._exportMaterialAsync(l,W,i,A);const o=I||q?N.c.LineListDrawMode:y.overrideRenderingFillMode??l.fillMode,H=l._getEffectiveOrientation(y);this._exportIndices(p,p?(0,J.e)(p,i.indexCount,i.indexStart,i.verticesStart):i.verticesCount>65535,p?i.indexStart:i.verticesStart,p?i.indexCount:i.verticesCount,-i.verticesStart,o,H,c,A);for(const y of Object.values(W))this._exportVertexBuffer(y,l,i.verticesStart,i.verticesCount,c,A);if(h){A.targets=[];for(const y of h)A.targets.push(y.attributes)}w.primitives.push(A),this._extensionsPostExportMeshPrimitive(A)}if(h){w.weights=[],w.extras||(w.extras={}),w.extras.targetNames=[];for(const y of h)w.weights.push(y.influence),w.extras.targetNames.push(y.name)}return l}}xy._ExtensionNames=new Array,xy._ExtensionFactories={};class Fy{static async GLTFAsync(y,c,A){A&&A.exportWithoutWaitingForScene||await y.whenReadyAsync();const l=new xy(y,A),w=await l.generateGLTFAsync(c.replace(/\.[^/.]+$/,""));return l.dispose(),w}static async GLBAsync(y,c,A){A&&A.exportWithoutWaitingForScene||await y.whenReadyAsync();const l=new xy(y,A),w=await l.generateGLBAsync(c.replace(/\.[^/.]+$/,""));return l.dispose(),w}}A(12885);const Ry="EXT_mesh_gpu_instancing";class ry{constructor(y){this.name=Ry,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(y,c,A,w,N,p){return await new Promise((y=>{if(c&&A instanceof ty.b&&A.hasThinInstances&&this._exporter){this._wasUsed=!0;const y=l.gc.Zero(),w=l.Quaternion.Identity(),W=l.gc.One(),h=A.thinInstanceGetWorldMatrices(),I=l.TmpVectors.gc[2],q=l.TmpVectors.Quaternion[1],o=l.TmpVectors.gc[3];let O=!1,L=!1,i=!1;const H=new Float32Array(3*A.dp),P=new Float32Array(4*A.dp),D=new Float32Array(3*A.dp);let t=0;for(const c of h)c.decompose(o,q,I),N&&(Z(I),v(q)),H.set(I.fc(),3*t),P.set(q.normalize().fc(),4*t),D.set(o.fc(),3*t),O=O||!I.equalsWithEpsilon(y),L=L||!q.equalsWithEpsilon(w),i=i||!o.equalsWithEpsilon(W),t++;const s={attributes:{}};O&&(s.attributes.TRANSLATION=this._buildAccessor(H,"VEC3",A.dp,p)),L&&(s.attributes.ROTATION=this._buildAccessor(P,"VEC4",A.dp,p)),i&&(s.attributes.SCALE=this._buildAccessor(D,"VEC3",A.dp,p)),c.extensions=c.extensions||{},c.extensions[Ry]=s}y(c)}))}_buildAccessor(y,c,A,l){const w=l.createBufferView(y),N=l.createAccessor(w,c,5126,A);return this._exporter._accessors.push(N),this._exporter._accessors.length-1}}xy.RegisterExtension(Ry,(y=>new ry(y)));var ny=A(12887),Ey=A(12901),by=A(12904),Zy=A(12913);function vy(y){return y===by.e.PositionKind?"POSITION":y===by.e.NormalKind?"NORMAL":y===by.e.ColorKind?"COLOR":y.startsWith(by.e.UVKind)?"TEX_COORD":"GENERIC"}const dy={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class yc extends ny.b{static get DefaultAvailable(){return(0,ny.f)(yc.DefaultConfiguration)}static get Default(){return yc._Default??(yc._Default=new yc),yc._Default}static ResetDefault(y){yc._Default&&(y||yc._Default.dispose(),yc._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(y,c){return{module:await(c||DracoEncoderModule)({wasmBinary:y})}}_getWorkerContent(){return`${Ey.j}(${Ey.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:yc.DefaultConfiguration)}async _encodeAsync(y,c,A){const l=A?(0,Zy.d)(dy,A):dy;if(this._workerPoolPromise){const A=await this._workerPoolPromise;return await new Promise(((w,N)=>{A.push(((A,p)=>{const W=y=>{A.removeEventListener("error",W),A.removeEventListener("message",h),N(y),p()},h=y=>{"encodeMeshDone"===y.data.id&&(A.removeEventListener("error",W),A.removeEventListener("message",h),w(y.data.encodedMeshData),p())};A.addEventListener("error",W),A.addEventListener("message",h);const I=[];for(const c of y)I.push(c.data.buffer);c&&I.push(c.buffer),A.postMessage({id:"encodeMesh",attributes:y,indices:c,options:l},I)}))}))}if(this._modulePromise){const A=await this._modulePromise;return(0,Ey.j)(A.module,y,c,l)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(y,c){if(0==y.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");y instanceof ty.b&&y.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===c||void 0===c?void 0:c.method)&&(U.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),c.method="MESH_SEQUENTIAL_ENCODING");const A=function(y){let c=y.rc(void 0,!0);return!c||c instanceof Uint32Array||c instanceof Uint16Array||(c=((0,J.e)(c,c.length)?Uint32Array:Uint16Array).from(c)),c}(y),l=function(y,c){const A=[];for(const l of y.getVerticesDataKinds()){if(null!==c&&void 0!==c&&c.includes(l)){if(l===by.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const w=y.getVertexBuffer(l),N=w.getSize(),p=(0,J.y)(w.getData(),N,w.type,w.byteOffset,w.byteStride,w.normalized,y.getTotalVertices(),!0);A.push({kind:l,dracoName:vy(l),size:N,data:p})}return A}(y,null===c||void 0===c?void 0:c.excludedAttributes);return await this._encodeAsync(l,A,c)}}yc.DefaultConfiguration={wasmUrl:`${w.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${w.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${w.Tools._DefaultCdnUrl}/draco_encoder.js`},yc._Default=null;const cc="KHR_draco_mesh_compression";class Ac{get wasUsed(){return this._wasUsed}constructor(y){this.name=cc,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===y.options.meshCompressionMethod&&yc.DefaultAvailable}dispose(){}postExportMeshPrimitive(y,c,A){if(!this.enabled)return;if(4!==y.mode&&5!==y.mode)return void U.c.Warn("Cannot compress primitive with mode "+y.mode+".");const l=[],w=[];let N=null;if(void 0!==y.indices){const p=A[y.indices],W=c.getBufferView(p);N=c.getData(W).slice(),l.push(W),w.push(p)}const p=[];for(const[q,o]of Object.entries(y.attributes)){const y=A[o],N=c.getBufferView(y),h=r(y.type),I=(0,J.y)(c.getData(N),h,y.componentType,y.byteOffset||0,N.byteStride||(0,J.t)(y.componentType)*h,y.normalized||!1,y.count,!0);p.push({kind:q,dracoName:(W=q,"POSITION"===W?"POSITION":"NORMAL"===W?"NORMAL":W.startsWith("COLOR")?"COLOR":W.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:r(y.type),data:I}),l.push(N),w.push(y)}var W;const h={method:y.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},I=yc.Default._encodeAsync(p,N,h).then((A=>{if(!A)return void U.c.Error("Draco encoding failed for primitive.");const N={bufferView:-1,attributes:A.attributeIds},p=c.createBufferView(A.data);c.setBufferView(N,p);for(const y of l)this._bufferViewsUsed.add(y);for(const y of w)this._accessorsUsed.add(y);y.extensions||(y.extensions={}),y.extensions[cc]=N})).catch((y=>{U.c.Error("Draco encoding failed for primitive: "+y)}));this._encodePromises.push(I),this._wasUsed=!0}async preGenerateBinaryAsync(y){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((c=>{y.getPropertiesWithBufferView(c).every((y=>this._accessorsUsed.has(y)))&&y.removeBufferView(c)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}xy.RegisterExtension(cc,(y=>new Ac(y)));var lc=A(12915);const wc="KHR_lights_punctual",Nc={name:"",color:[1,1,1],JW:1,range:Number.MAX_VALUE},pc={innerConeAngle:0,outerConeAngle:Math.PI/4},Wc=l.gc.Backward();class hc{constructor(y){this.name=wc,this.enabled=!0,this.required=!1,this._exporter=y}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[wc]=this._lights}async postExportNodeAsync(y,c,A,w,N){return await new Promise((p=>{if(!(A instanceof sy.b))return void p(c);const W=A.getTypeID()==sy.b.LIGHTTYPEID_POINTLIGHT?"point":A.getTypeID()==sy.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":A.getTypeID()==sy.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!W||!(A instanceof lc.d))return U.c.Warn(`${y}: Light ${A.name} is not supported in ${wc}`),void p(c);if(A.falloffType!==sy.b.FALLOFF_GLTF&&U.c.Warn(`${y}: Light falloff for ${A.name} does not match the ${wc} specification!`),!A.position.equalsToFloats(0,0,0)){const y=l.TmpVectors.gc[0].p(A.position);N&&Z(y),c.translation=y.fc()}if("point"!==W){const y=A.direction.normalizeToRef(l.TmpVectors.gc[0]);N&&Z(y);const w=l.Quaternion.FromUnitVectorsToRef(Wc,y,l.TmpVectors.Quaternion[0]);l.Quaternion.IsIdentity(w)||(c.rotation=w.fc())}const h={type:W,name:A.name,color:A.UW.fc(),JW:A.JW,range:A.range};if(ly(h,Nc),"spot"===W){const y=A;h.spot={innerConeAngle:y.innerAngle/2,outerConeAngle:y.angle/2},ly(h.spot,pc)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(h);const I={tc:this._lights.lights.length-1},q=A.parent;if(q&&cy(A,q)){const y=w.get(q);if(y){const A=this._exporter._nodes[y];return yy(c,A),A.extensions||(A.extensions={}),A.extensions[wc]=I,void p(null)}}c.extensions||(c.extensions={}),c.extensions[wc]=I,p(c)}))}}xy.RegisterExtension(wc,(y=>new hc(y)));var Ic=A(12827);const qc="KHR_materials_anisotropy";class oc{constructor(y){this.name=qc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,c,A){const l=[];return A instanceof Ic.c&&A.anisotropy.isEnabled&&!A.anisotropy.legacy?(A.anisotropy.texture&&l.push(A.anisotropy.texture),l):[]}postExportMaterialAsync(y,c,A){return new Promise((y=>{if(A instanceof Ic.c){if(!A.anisotropy.isEnabled||A.anisotropy.legacy)return void y(c);this._wasUsed=!0,c.extensions=c.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(A.anisotropy.texture),w={anisotropyStrength:A.anisotropy.JW,anisotropyRotation:A.anisotropy.angle,anisotropyTexture:l??void 0};null!==w.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(A),c.extensions[qc]=w}y(c)}))}}xy.RegisterExtension(qc,(y=>new oc(y)));const Oc="KHR_materials_clearcoat";class Lc{constructor(y){this.name=Oc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,c,A){const l=[];return A instanceof Ic.c&&A.clearCoat.isEnabled?(A.clearCoat.texture&&l.push(A.clearCoat.texture),!A.clearCoat.useRoughnessFromMainTexture&&A.clearCoat.textureRoughness&&l.push(A.clearCoat.textureRoughness),A.clearCoat.bumpTexture&&l.push(A.clearCoat.bumpTexture),l):[]}postExportMaterialAsync(y,c,A){return new Promise((y=>{if(A instanceof Ic.c){if(!A.clearCoat.isEnabled)return void y(c);this._wasUsed=!0,c.extensions=c.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(A.clearCoat.texture);let N;N=A.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(A.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(A.clearCoat.textureRoughness),A.clearCoat.isTintEnabled&&w.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${A.name}`),A.clearCoat.remapF0OnInterfaceChange&&w.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${A.name}`);const p=this._exporter._materialExporter.getTextureInfo(A.clearCoat.bumpTexture),W={clearcoatFactor:A.clearCoat.JW,clearcoatTexture:l??void 0,clearcoatRoughnessFactor:A.clearCoat.roughness,clearcoatRoughnessTexture:N??void 0,clearcoatNormalTexture:p??void 0};null===W.clearcoatTexture&&null===W.clearcoatRoughnessTexture&&null===W.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(A),c.extensions[Oc]=W}y(c)}))}}xy.RegisterExtension(Oc,(y=>new Lc(y)));const ic="KHR_materials_diffuse_transmission";function Hc(y,c){const A=c.subSurface;let l=null;return A.translucencyIntensityTexture?l=A.translucencyIntensityTexture:A.thicknessTexture&&A.useMaskFromThicknessTexture&&(l=A.thicknessTexture),l&&!A.useGltfStyleTextures?(U.c.Warn(`${y}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${c.name}`,1),null):l}class Pc{constructor(y){this.name=ic,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,c,A){const l=[];if(A instanceof iy.c&&this._isExtensionEnabled(A)){const c=Hc(y,A);return c&&l.push(c),A.subSurface.translucencyColorTexture&&l.push(A.subSurface.translucencyColorTexture),l}return l}_isExtensionEnabled(y){if(y.unlit)return!1;const c=y.subSurface;return!!c.isTranslucencyEnabled&&(!y.unlit&&!c.useAlbedoToTintTranslucency&&c.useGltfStyleTextures&&1===c.volumeIndexOfRefraction&&0===c.minimumThickness&&0===c.maximumThickness)}postExportMaterialAsync(y,c,A){return new Promise((l=>{if(A instanceof iy.c&&this._isExtensionEnabled(A)){this._wasUsed=!0;const l=A.subSurface,w=Hc(y,A),N=0==l.translucencyIntensity?void 0:l.translucencyIntensity,p=this._exporter._materialExporter.getTextureInfo(w)??void 0,W=!l.translucencyColor||l.translucencyColor.equalsFloats(1,1,1)?void 0:l.translucencyColor.fc(),h=this._exporter._materialExporter.getTextureInfo(l.translucencyColorTexture)??void 0,I={diffuseTransmissionFactor:N,diffuseTransmissionTexture:p,diffuseTransmissionColorFactor:W,diffuseTransmissionColorTexture:h};(p||h)&&this._exporter._materialNeedsUVsSet.add(A),c.extensions=c.extensions||{},c.extensions[ic]=I}l(c)}))}}xy.RegisterExtension(ic,(y=>new Pc(y)));const Dc="KHR_materials_dispersion";class tc{constructor(){this.name=Dc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(y){if(y.unlit)return!1;const c=y.subSurface;return!(!c.isRefractionEnabled&&!c.isDispersionEnabled)}postExportMaterialAsync(y,c,A){return new Promise((y=>{if(A instanceof iy.c&&this._isExtensionEnabled(A)){this._wasUsed=!0;const y={dispersion:A.subSurface.dispersion};c.extensions=c.extensions||{},c.extensions[Dc]=y}y(c)}))}}xy.RegisterExtension(Dc,(()=>new tc));const sc="KHR_materials_emissive_strength";class Bc{constructor(){this.name=sc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(y,c,A){return await new Promise((y=>{if(!(A instanceof iy.c))return y(c);const l=A.emissiveColor.fc(),w=Math.max(...l);if(w>1){this._wasUsed=!0,c.extensions||(c.extensions={});const y={emissiveStrength:w},l=A.emissiveColor.scale(1/y.emissiveStrength);c.emissiveFactor=l.fc(),c.extensions[sc]=y}return y(c)}))}}xy.RegisterExtension(sc,(y=>new Bc));const Xc="KHR_materials_ior";class Cc{constructor(){this.name=Xc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(y){return!y.unlit&&(void 0!=y.indexOfRefraction&&1.5!=y.indexOfRefraction)}postExportMaterialAsync(y,c,A){return new Promise((y=>{if(A instanceof iy.c&&this._isExtensionEnabled(A)){this._wasUsed=!0;const y={ior:A.indexOfRefraction};c.extensions=c.extensions||{},c.extensions[Xc]=y}y(c)}))}}xy.RegisterExtension(Xc,(y=>new Cc));const Kc="KHR_materials_iridescence";class mA{constructor(y){this.name=Kc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,c,A){const l=[];return A instanceof Ic.c&&A.iridescence.isEnabled?(A.iridescence.texture&&l.push(A.iridescence.texture),A.iridescence.thicknessTexture&&A.iridescence.thicknessTexture!==A.iridescence.texture&&l.push(A.iridescence.thicknessTexture),l):[]}postExportMaterialAsync(y,c,A){return new Promise((y=>{if(A instanceof Ic.c){if(!A.iridescence.isEnabled)return void y(c);this._wasUsed=!0,c.extensions=c.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(A.iridescence.texture),w=this._exporter._materialExporter.getTextureInfo(A.iridescence.thicknessTexture),N={iridescenceFactor:A.iridescence.JW,iridescenceIor:A.iridescence.indexOfRefraction,iridescenceThicknessMinimum:A.iridescence.minimumThickness,iridescenceThicknessMaximum:A.iridescence.maximumThickness,iridescenceTexture:l??void 0,iridescenceThicknessTexture:w??void 0};null===N.iridescenceTexture&&null===N.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(A),c.extensions[Kc]=N}y(c)}))}}xy.RegisterExtension(Kc,(y=>new mA(y)));const Tc="KHR_materials_sheen";class zc{constructor(y){this.name=Tc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,c,A){return A instanceof iy.c&&A.sheen.isEnabled&&A.sheen.texture?[A.sheen.texture]:[]}async postExportMaterialAsync(y,c,A){return await new Promise((y=>{if(A instanceof iy.c){if(!A.sheen.isEnabled)return void y(c);this._wasUsed=!0,null==c.extensions&&(c.extensions={});const l={sheenColorFactor:A.sheen.color.fc(),sheenRoughnessFactor:A.sheen.roughness??0};null===l.sheenColorTexture&&null===l.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(A),A.sheen.texture&&(l.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(A.sheen.texture)??void 0),A.sheen.textureRoughness&&!A.sheen.useRoughnessFromMainTexture?l.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(A.sheen.textureRoughness)??void 0:A.sheen.texture&&A.sheen.useRoughnessFromMainTexture&&(l.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(A.sheen.texture)??void 0),c.extensions[Tc]=l}y(c)}))}}xy.RegisterExtension(Tc,(y=>new zc(y)));const Sc="KHR_materials_specular";class Mc{constructor(y){this.name=Sc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,c,A){const l=[];return A instanceof iy.c&&this._isExtensionEnabled(A)?(A.metallicReflectanceTexture&&l.push(A.metallicReflectanceTexture),A.reflectanceTexture&&l.push(A.reflectanceTexture),l):l}_isExtensionEnabled(y){return!y.unlit&&(void 0!=y.metallicF0Factor&&1!=y.metallicF0Factor||void 0!=y.metallicReflectanceColor&&!y.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(y))}_hasTexturesExtension(y){return null!=y.metallicReflectanceTexture||null!=y.reflectanceTexture}postExportMaterialAsync(y,c,A){return new Promise((y=>{if(A instanceof iy.c&&this._isExtensionEnabled(A)){this._wasUsed=!0,c.extensions=c.extensions||{};const y=this._exporter._materialExporter.getTextureInfo(A.metallicReflectanceTexture)??void 0,l=this._exporter._materialExporter.getTextureInfo(A.reflectanceTexture)??void 0,w={specularFactor:1==A.metallicF0Factor?void 0:A.metallicF0Factor,specularTexture:y,specularColorFactor:A.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:A.metallicReflectanceColor.fc(),specularColorTexture:l};this._hasTexturesExtension(A)&&this._exporter._materialNeedsUVsSet.add(A),c.extensions[Sc]=w}y(c)}))}}xy.RegisterExtension(Sc,(y=>new Mc(y)));const kc="KHR_materials_transmission";class ac{constructor(y){this.name=kc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,c,A){const l=[];return A instanceof iy.c&&this._isExtensionEnabled(A)?(A.subSurface.thicknessTexture&&l.push(A.subSurface.thicknessTexture),l):l}_isExtensionEnabled(y){if(y.unlit)return!1;const c=y.subSurface;return c.isRefractionEnabled&&void 0!=c.refractionIntensity&&0!=c.refractionIntensity||this._hasTexturesExtension(y)}_hasTexturesExtension(y){return null!=y.subSurface.refractionIntensityTexture}async postExportMaterialAsync(y,c,A){if(A instanceof iy.c&&this._isExtensionEnabled(A)){this._wasUsed=!0;const l=A.subSurface,w={transmissionFactor:0===l.refractionIntensity?void 0:l.refractionIntensity};if(this._hasTexturesExtension(A)&&this._exporter._materialNeedsUVsSet.add(A),l.refractionIntensityTexture)if(l.useGltfStyleTextures){const y=await this._exporter._materialExporter.exportTextureAsync(l.refractionIntensityTexture,"image/png");y&&(w.transmissionTexture=y)}else U.c.Warn(`${y}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);c.extensions||(c.extensions={}),c.extensions[kc]=w}return c}}xy.RegisterExtension(kc,(y=>new ac(y)));const uc="KHR_materials_unlit";class Gc{constructor(){this.name=uc,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(y,c,A){return new Promise((y=>{let l=!1;A instanceof iy.c?l=A.unlit:A instanceof Hy.Zc&&(l=A.disableLighting),l&&(this._wasUsed=!0,null==c.extensions&&(c.extensions={}),c.extensions[uc]={}),y(c)}))}}xy.RegisterExtension(uc,(()=>new Gc));const jc="KHR_materials_volume";class fc{constructor(y){this.name=jc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,c,A){const l=[];return A instanceof iy.c&&this._isExtensionEnabled(A)?(A.subSurface.thicknessTexture&&l.push(A.subSurface.thicknessTexture),l):l}_isExtensionEnabled(y){if(y.unlit)return!1;const c=y.subSurface;return!(!c.isRefractionEnabled&&!c.isTranslucencyEnabled)&&(void 0!=c.maximumThickness&&0!=c.maximumThickness||void 0!=c.tintColorAtDistance&&c.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=c.tintColor&&c.tintColor!=P.dc.White()||this._hasTexturesExtension(y))}_hasTexturesExtension(y){return null!=y.subSurface.thicknessTexture}postExportMaterialAsync(y,c,A){return new Promise((y=>{if(A instanceof iy.c&&this._isExtensionEnabled(A)){this._wasUsed=!0;const y=A.subSurface,l={thicknessFactor:0==y.maximumThickness?void 0:y.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(y.thicknessTexture)??void 0,attenuationDistance:y.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:y.tintColorAtDistance,attenuationColor:y.tintColor.equalsFloats(1,1,1)?void 0:y.tintColor.fc()};this._hasTexturesExtension(A)&&this._exporter._materialNeedsUVsSet.add(A),c.extensions=c.extensions||{},c.extensions[jc]=l}y(c)}))}}xy.RegisterExtension(jc,(y=>new fc(y)));const Vc="EXT_materials_diffuse_roughness";class Jc{constructor(y){this.name=Vc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,c,A){const l=[];return A instanceof Ic.c&&A._baseDiffuseRoughness?(A._baseDiffuseRoughnessTexture&&l.push(A._baseDiffuseRoughnessTexture),l):[]}postExportMaterialAsync(y,c,A){return new Promise((y=>{if(A instanceof Ic.c){if(!A._baseDiffuseRoughness)return void y(c);this._wasUsed=!0,c.extensions=c.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(A._baseDiffuseRoughnessTexture),w={diffuseRoughnessFactor:A._baseDiffuseRoughness,diffuseRoughnessTexture:l??void 0};null!==w.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(A),c.extensions[Vc]=w}y(c)}))}}xy.RegisterExtension(Vc,(y=>new Jc(y)));const Uc="KHR_texture_transform";class ec{constructor(){this.name=Uc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(y,c,A){if(A.mc()||w.Tools.Warn(`${y}: /*@__KEY__*/"scene" is not defined for Babylon texture ${A.name}!`),(0!==A.uAng||0!==A.vAng)&&(w.Tools.Warn(`${y}: Texture ${A.name} with rotation in the u or v axis is not supported in glTF.`),0!==A.uRotationCenter||0!==A.vRotationCenter))return;const l={};let N=!1;if(0===A.uOffset&&0===A.vOffset||(l.offset=[A.uOffset,A.vOffset],N=!0),1===A.uScale&&1===A.vScale||(l.scale=[A.uScale,A.vScale],N=!0),0!==A.wAng){if(0!==A.uRotationCenter||0!==A.vRotationCenter){if(A.homogeneousRotationInUVTransform&&A.uScale!==A.vScale)return void w.Tools.Warn(`${y}: Texture ${A.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Uc}.`);w.Tools.Warn(`${y}: Texture ${A.name} with non-origin rotation center will be exported using an adjusted offset with ${Uc}.`),l.offset=function(y){const{uOffset:c,vOffset:A,uRotationCenter:l,vRotationCenter:w,uScale:N,vScale:p,wAng:W}=y,h=Math.cos(W),I=Math.sin(W),q=l*N,o=w*p;return[c+(q*(1-h)+o*I),A+(o*(1-h)-q*I)]}(A)}l.rotation=-A.wAng,N=!0}0!==A.coordinatesIndex&&(l.texCoord=A.coordinatesIndex,N=!0),N&&(this._wasUsed=!0,c.extensions||(c.extensions={}),c.extensions[Uc]=l)}}xy.RegisterExtension(Uc,(()=>new ec));class Qc{static CreateSTL(y){let c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",w=arguments.length>3&&void 0!==arguments[3]&&arguments[3],N=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],p=arguments.length>5&&void 0!==arguments[5]&&arguments[5],W=arguments.length>6&&void 0!==arguments[6]&&arguments[6],h=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const I=function(y,c,A){const w=[3*y[A],3*y[A+1],3*y[A+2]],N=[new l.gc(c[w[0]],c[w[0]+2],c[w[0]+1]),new l.gc(c[w[1]],c[w[1]+2],c[w[1]+1]),new l.gc(c[w[2]],c[w[2]+2],c[w[2]+1])],p=N[0].xc(N[1]),W=N[2].xc(N[1]);return{v:N,n:l.gc.Cross(W,p).normalize()}},o=function(y,c,A,l){return c=O(y,c,A.x,l),c=O(y,c,A.y,l),O(y,c,A.z,l)},O=function(y,c,A,l){return y.setFloat32(c,A,l),c+4},i=function(y){if(W){let c=y;y instanceof L.b&&(c=y.sourceMesh);const A=c.getVerticesData(q.e.PositionKind,!0,!0);if(!A)return[];const w=l.gc.Zero();let N;for(N=0;N<A.length;N+=3)l.gc.TransformCoordinatesFromFloatsToRef(A[N],A[N+1],A[N+2],y.Yc(!0),w).toArray(A,N);return A}return y.getVerticesData(q.e.PositionKind)||[]};W&&(p=!0);let H="",P=0,D=0;if(w){for(let A=0;A<y.length;A++){const c=y[A].rc();P+=c?c.length/3:0}const c=new ArrayBuffer(84+50*P);H=new DataView(c),D+=80,H.setUint32(D,P,N),D+=4}else h||(H="solid stlmesh\r\n");for(let l=0;l<y.length;l++){const c=y[l];!w&&h&&(H+="solid "+c.name+"\r\n"),!p&&c instanceof ty.b&&c.bakeCurrentTransformIntoVertices();const A=i(c),W=c.rc()||[];for(let y=0;y<W.length;y+=3){const c=I(W,A,y);w?(D=o(H,D,c.n,N),D=o(H,D,c.v[0],N),D=o(H,D,c.v[1],N),D=o(H,D,c.v[2],N),D+=2):(H+="\tfacet normal "+c.n.x+" "+c.n.y+" "+c.n.z+"\r\n",H+="\t\touter loop\r\n",H+="\t\t\tvertex "+c.v[0].x+" "+c.v[0].y+" "+c.v[0].z+"\r\n",H+="\t\t\tvertex "+c.v[1].x+" "+c.v[1].y+" "+c.v[1].z+"\r\n",H+="\t\t\tvertex "+c.v[2].x+" "+c.v[2].y+" "+c.v[2].z+"\r\n",H+="\t\tendloop\r\n",H+="\tendfacet\r\n")}!w&&h&&(H+="endsolid "+name+"\r\n")}if(w||h||(H+="endsolid stlmesh"),c){const y=document.createElement("a"),c=new Blob([H],{type:"application/octet-stream"});y.href=window.URL.createObjectURL(c),y.download=A+".stl",y.click()}return H}}function Yc(y,c){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const l=[];for(let w=0;w<y.length/A;w++){const N=y[w*A],p=y[w*A+1],W=y[w*A+2];l.push(`(${N.toPrecision(c.precision)}, ${p.toPrecision(c.precision)}, ${W.toPrecision(c.precision)})`)}return l.join(", ")}function gc(y,c){const A=[];for(let l=0;l<y.length/2;l++){const w=y[2*l],N=y[2*l+1];A.push(`(${w.toPrecision(c.precision)}, ${(1-N).toPrecision(c.precision)})`)}return A.join(", ")}function xc(y,c){const A=y.getVerticesData(q.e.PositionKind),l=y.getVerticesData(q.e.NormalKind);if(A&&l)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(y){var c;const A=null!==(c=y.rc())&&void 0!==c&&c.length?y.getTotalIndices():y.getTotalVertices();return Array(A/3).fill(3).join(", ")}(y)}]\n\t\tint[] faceVertexIndices = [${function(y){const c=y.rc(),A=[];if(null!==c)for(let l=0;l<c.length;l++)A.push(c[l]);else{const c=y.getTotalVertices();for(let y=0;y<c;y++)A.push(y)}return A.join(", ")}(y)}]\n\t\tnormal3f[] normals = [${Yc(l,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Yc(A,c)}]\n        ${function(y,c){let A="";for(let w=0;w<4;w++){const l=w>0?w:"",N=y.getVerticesData(q.e.UVKind+(l?l+1:""));N&&(A+=`\n\t\ttexCoord2f[] primvars:st${l} = [${gc(N,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const l=y.getVerticesData(q.e.ColorKind);return l&&(A+=`\n\tcolor3f[] primvars:displayColor = [${Yc(l,c,l.length/y.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),A}(y,c)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Fc(y,c){return`\n        def "Geometry"\n        {\n        ${xc(y,c)}\n        }\n        `}function Rc(y){let c='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return c+=y,fflate.strToU8(c)}function rc(y){const c=y.m;return`( ${nc(c,0)}, ${nc(c,4)}, ${nc(c,8)}, ${nc(c,12)} )`}function nc(y,c){return`(${y[c+0]}, ${y[c+1]}, ${y[c+2]}, ${y[c+3]})`}function Ec(y){const c="Object_"+y.uniqueId,A=function(y){const c=y.getWorldMatrix().clone(),A=y.mc().useRightHandedSystem;if(!A){let l=y.parent;for(;l;){if(py(l,A)){c.multiplyToRef(l.getWorldMatrix().invert(),c);break}l=l.parent}}return c.determinant()<0&&w.Tools.Warn(`Exporting mesh ${y.name} with negative scale. Result may look incorrect in destination engine.`),c}(y),l=rc(A);return`def Xform "${c}" (\n\tprepend references = @./geometries/Geometry_${y.Rc.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${l}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${y.material.uniqueId}>\n}\n\n`}function bc(y){switch(y){case K.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case K.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case K.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Zc(y){return`(${y.x}, ${y.y})`}function vc(y){return`(${y.r}, ${y.g}, ${y.b})`}function dc(y,c,A,w,N,p){const W=y.getInternalTexture().uniqueId+"_"+y.invertY;N[W]=y;const h=y.coordinatesIndex>0?"st"+y.coordinatesIndex:"st",I=new l.Vector2(y.uScale,y.vScale),q=new l.Vector2(y.uOffset,y.vOffset),o=y.wAng,O=Math.sin(o),L=Math.cos(o);return q.y=1-q.y-I.y,q.x+=O*I.x,q.y+=(1-L)*I.y,`\n    def Shader "PrimvarReader_${A}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${h}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${A}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${c.uniqueId}/PrimvarReader_${A}.outputs:result>\n        float inputs:rotation = ${(o*(180/Math.PI)).toFixed(p.precision)}\n        float2 inputs:scale = ${Zc(I)}\n        float2 inputs:translation = ${Zc(q)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${y.uniqueId}_${A}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${W}.png@\n        float2 inputs:st.connect = </Materials/Material_${c.uniqueId}/Transform2d_${A}.outputs:result>\n        ${w?"float4 inputs:scale = "+function(y){return`(${y.r}, ${y.g}, ${y.b}, 1.0)`}(w):""}\n        token inputs:sourceColorSpace = "${y.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${bc(y.wrapU)}"\n        token inputs:wrapT = "${bc(y.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${c.needAlphaBlending()?"float outputs:a":""}\n    }`}function yA(y,c,A){const l="\t\t\t",w=[],N=[],{diffuseMap:p,UW:W,alphaCutOff:h,emissiveMap:I,emissive:q,normalMap:o,roughnessMap:O,roughnessChannel:L,roughness:i,metalnessMap:H,metalnessChannel:D,metalness:t,aoMap:s,aoMapChannel:B,aoMapIntensity:X,alphaMap:C,ior:K,clearCoatEnabled:my,clearCoat:T,clearCoatMap:z,clearCoatRoughness:S,clearCoatRoughnessMap:M}=function(y){const c={diffuseMap:null,UW:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return y instanceof Hy.Zc?{...c,diffuseMap:y.diffuseTexture,UW:y.diffuseColor,alphaCutOff:y.alphaCutOff,emissiveMap:y.emissiveTexture,emissive:y.emissiveColor,roughness:1,alphaMap:y.opacityTexture}:y instanceof Ic.c?{...c,diffuseMap:y._albedoTexture,UW:y._albedoColor,alphaCutOff:y._alphaCutOff,emissiveMap:y._emissiveTexture,emissive:y._emissiveColor,normalMap:y._bumpTexture,roughnessMap:y._metallicTexture,roughnessChannel:y._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:y._roughness??1,metalnessMap:y._metallicTexture,metalnessChannel:y._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:y._metallic??0,aoMap:y._ambientTexture,aoMapChannel:y._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:y._ambientTextureStrength,alphaMap:y._opacityTexture,ior:y.subSurface.indexOfRefraction,clearCoatEnabled:y.clearCoat.isEnabled,clearCoat:y.clearCoat.JW,clearCoatMap:y.clearCoat.texture,clearCoatRoughness:y.clearCoat.roughness,clearCoatRoughnessMap:y.clearCoat.useRoughnessFromMainTexture?y.clearCoat.texture:y.clearCoat.textureRoughness}:c}(y);return null!==p?(w.push(`${l}color3f inputs:diffuseColor.connect = </Materials/Material_${y.uniqueId}/Texture_${p.uniqueId}_diffuse.outputs:rgb>`),y.needAlphaBlending()?w.push(`${l}float inputs:opacity.connect = </Materials/Material_${y.uniqueId}/Texture_${p.uniqueId}_diffuse.outputs:a>`):y.needAlphaTesting()&&(w.push(`${l}float inputs:opacity.connect = </Materials/Material_${y.uniqueId}/Texture_${p.uniqueId}_diffuse.outputs:a>`),w.push(`${l}float inputs:opacityThreshold = ${h}`)),N.push(dc(p,y,"diffuse",W,c,A))):w.push(`${l}color3f inputs:diffuseColor = ${vc(W||P.dc.White())}`),null!==I?(w.push(`${l}color3f inputs:emissiveColor.connect = </Materials/Material_${y.uniqueId}/Texture_${I.uniqueId}_emissive.outputs:rgb>`),N.push(dc(I,y,"emissive",q,c,A))):q&&q.toLuminance()>0&&w.push(`${l}color3f inputs:emissiveColor = ${vc(q)}`),null!==o&&(w.push(`${l}normal3f inputs:normal.connect = </Materials/Material_${y.uniqueId}/Texture_${o.uniqueId}_normal.outputs:rgb>`),N.push(dc(o,y,"normal",null,c,A))),null!==s&&(w.push(`${l}float inputs:occlusion.connect = </Materials/Material_${y.uniqueId}/Texture_${s.uniqueId}_occlusion.outputs:${B}>`),N.push(dc(s,y,"occlusion",new P.dc(X,X,X),c,A))),null!==O?(w.push(`${l}float inputs:roughness.connect = </Materials/Material_${y.uniqueId}/Texture_${O.uniqueId}_roughness.outputs:${L}>`),N.push(dc(O,y,"roughness",new P.dc(i,i,i),c,A))):w.push(`${l}float inputs:roughness = ${i}`),null!==H?(w.push(`${l}float inputs:metallic.connect = </Materials/Material_${y.uniqueId}/Texture_${H.uniqueId}_metallic.outputs:${D}>`),N.push(dc(H,y,"metallic",new P.dc(t,t,t),c,A))):w.push(`${l}float inputs:metallic = ${t}`),null!==C?(w.push(`${l}float inputs:opacity.connect = </Materials/Material_${y.uniqueId}/Texture_${C.uniqueId}_opacity.outputs:r>`),w.push(`${l}float inputs:opacityThreshold = 0.0001`),N.push(dc(C,y,"opacity",null,c,A))):w.push(`${l}float inputs:opacity = ${y.alpha}`),my&&(null!==z?(w.push(`${l}float inputs:clearcoat.connect = </Materials/Material_${y.uniqueId}/Texture_${z.uniqueId}_clearcoat.outputs:r>`),N.push(dc(z,y,"clearcoat",new P.dc(T,T,T),c,A))):w.push(`${l}float inputs:clearcoat = ${T}`),null!==M?(w.push(`${l}float inputs:clearcoatRoughness.connect = </Materials/Material_${y.uniqueId}/Texture_${M.uniqueId}_clearcoatRoughness.outputs:g>`),N.push(dc(M,y,"clearcoatRoughness",new P.dc(S,S,S),c,A))):w.push(`${l}float inputs:clearcoatRoughness = ${S}`)),w.push(`${l}float inputs:ior = ${K}`),`\n\tdef Material "Material_${y.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${w.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${y.uniqueId}/PreviewSurface.outputs:surface>\n\n${N.join("\n")}\n\n\t}\n`}async function cA(y,c,A){const N={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...c};"undefined"===typeof fflate&&await w.Tools.LoadScriptAsync(N.fflateUrl);const p={};p[N.modelFileName]=null;let W='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';W+=function(y){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===y.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${y.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${y.planeAnchoringAlignment}"`:""}\n            `}(N);const h={};for(const l of y.meshes){if(0===l.getTotalVertices())continue;const y=l,c=y.Rc,I=y.material;if(!I||!c||A&&!A(y))continue;if(-1!==["Zc","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(I.getClassName())){const A="geometries/Geometry_"+c.uniqueId+".usda";if(!(A in p)){const y=Fc(c,N);p[A]=Rc(y)}I.uniqueId in h||(h[I.uniqueId]=I),W+=Ec(y)}else w.Tools.Warn("USDZExportAsync does not support this material type: "+I.getClassName())}y.activeCamera&&N.exportCamera&&(W+=function(y,c){const A="Camera_"+y.uniqueId,w=rc(l.Matrix.RotationY(Math.PI).multiply(y.getWorldMatrix()));if(y.mode===K.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${A}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${w}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${y.ec.toPrecision(c.precision)}, ${y.maxZ.toPrecision(c.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(y.orthoLeft||1)+Math.abs(y.orthoRight||1))).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(y.orthoTop||1)+Math.abs(y.orthoBottom||1))).toPrecision(c.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const l=y.getEngine().getAspectRatio(y),N=c.cameraSensorWidth||35;return`def Camera "${A}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${w}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${y.ec.toPrecision(c.precision)}, ${y.maxZ.toPrecision(c.precision)})\n\t\t\tfloat focalLength = ${(N/(2*Math.tan(.5*y.fov))).toPrecision(c.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(N*l).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(N/l).toPrecision(c.precision)}            \n\t\t}\n\t\n\t`}}(y.activeCamera,N)),W+="\n            }\n        }\n    }";const I={};W+=function(y,c,A){const l=[];for(const w in y){const N=y[w];l.push(yA(N,c,A))}return`\n    def "Materials"\n{\n${l.join("")}\n}\n\n`}(h,I,N),p[N.modelFileName]=fflate.strToU8(W);for(const l in I){const y=I[l],c=y.getSize(),A=await y.readPixels();if(!A)throw new Error("Texture data is not available");const w=await my.DumpTools.DumpDataAsync(c.width,c.height,A,"image/png",void 0,!1,!0);p[`textures/Texture_${l}.png`]=new Uint8Array(w).slice()}let q=0;for(const l in p){const y=p[l];if(!y)continue;q+=34+l.length;const c=63&q;if(4!==c){const A=new Uint8Array(64-c);p[l]=[y,{extra:{12345:A}}]}q=y.length}return fflate.zipSync(p,{level:0})}}}]);