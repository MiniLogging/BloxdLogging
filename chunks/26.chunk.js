"use strict";(self.v2pspxy442l=self.v2pspxy442l||[]).push([[26],{12847:(l,a,N)=>{N.r(a),N.d(a,{EXT_materials_diffuse_roughness:()=>La,EXT_mesh_gpu_instancing:()=>Gl,GLTF2Export:()=>sl,GLTFData:()=>T,KHR_draco_mesh_compression:()=>Na,KHR_lights_punctual:()=>Sa,KHR_materials_anisotropy:()=>na,KHR_materials_clearcoat:()=>Ha,KHR_materials_diffuse_transmission:()=>Ba,KHR_materials_dispersion:()=>Ca,KHR_materials_emissive_strength:()=>Aa,KHR_materials_ior:()=>qa,KHR_materials_iridescence:()=>za,KHR_materials_sheen:()=>ta,KHR_materials_specular:()=>ha,KHR_materials_transmission:()=>ka,KHR_materials_unlit:()=>ja,KHR_materials_volume:()=>pa,KHR_texture_transform:()=>Xa,OBJExport:()=>Z,STLExport:()=>Pa,USDZExportAsync:()=>aN,_ConvertToGLTFPBRMetallicRoughness:()=>Q,_SolveMetallic:()=>k,__IGLTFExporterExtension:()=>w});var U=N(12447),c=N(12254),K=N(12753);class Z{static OBJ(l,a,N,Z){const w=[];let S=1,T=1;a&&(N||(N="mat"),w.push("mtllib "+N+".mtl"));for(let J=0;J<l.length;J++){const N=l[J],n=N.name||`mesh${J}}`;w.push(`o ${n}`);let y=null;if(Z){const l=N.qc(!0);y=new U.Matrix,l.invertToRef(y),N.bakeTransformIntoVertices(l)}if(a){const l=N.material;l&&w.push("usemtl "+l.id)}const H=N.bc;if(!H){c.Tools.Warn("No geometry is present on the mesh");continue}const u=H.getVerticesData("position"),W=H.getVerticesData("normal"),B=H.getVerticesData("uv"),Y=H.zc();let C=0,M=0;if(!u||!Y){c.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const A=l[0].bl().useRightHandedSystem?1:-1;for(let l=0;l<u.length;l+=3)w.push("v "+u[l]*A+" "+u[l+1]+" "+u[l+2]),C++;if(null!=W)for(let l=0;l<W.length;l+=3)w.push("vn "+W[l]*A+" "+W[l+1]+" "+W[l+2]);if(null!=B)for(let l=0;l<B.length;l+=2)w.push("vt "+B[l]+" "+B[l+1]),M++;const E=["","",""],q=(N.material||N.bl().defaultMaterial)._getEffectiveOrientation(N),[b,z]=q===K.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let l=0;l<Y.length;l+=3){const a=[String(Y[l]+S),String(Y[l+b]+S),String(Y[l+z]+S)],N=[String(Y[l]+T),String(Y[l+b]+T),String(Y[l+z]+T)],U=a,c=null!=B?N:E,K=null!=W?a:E;w.push("f "+U[0]+"/"+c[0]+"/"+K[0]+" "+U[1]+"/"+c[1]+"/"+K[1]+" "+U[2]+"/"+c[2]+"/"+K[2])}Z&&y&&N.bakeTransformIntoVertices(y),S+=C,T+=M}return w.join("\n")}static MTL(l){const a=[],N=l.material;a.push("newmtl mat1"),a.push("  Ns "+N.specularPower.toFixed(4)),a.push("  Ni 1.5000"),a.push("  d "+N.alpha.toFixed(4)),a.push("  Tr 0.0000"),a.push("  Tf 1.0000 1.0000 1.0000"),a.push("  illum 2"),a.push("  Ka "+N.ambientColor.r.toFixed(4)+" "+N.ambientColor.g.toFixed(4)+" "+N.ambientColor.b.toFixed(4)),a.push("  Kd "+N.diffuseColor.r.toFixed(4)+" "+N.diffuseColor.g.toFixed(4)+" "+N.diffuseColor.b.toFixed(4)),a.push("  Ks "+N.specularColor.r.toFixed(4)+" "+N.specularColor.g.toFixed(4)+" "+N.specularColor.b.toFixed(4)),a.push("  Ke "+N.emissiveColor.r.toFixed(4)+" "+N.emissiveColor.g.toFixed(4)+" "+N.emissiveColor.b.toFixed(4));N.ambientTexture&&a.push("  map_Ka "+N.ambientTexture.name),N.diffuseTexture&&a.push("  map_Kd "+N.diffuseTexture.name),N.specularTexture&&a.push("  map_Ks "+N.specularTexture.name),N.bumpTexture&&a.push("  map_bump -imfchan z "+N.bumpTexture.name),N.opacityTexture&&a.push("  map_d "+N.opacityTexture.name);return a.join("\n")}}var w=0,S=N(12298);class T{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const l in this.files){const a=this.files[l],N=new Blob([a],{type:(0,S.i)(l)});c.Tools.Download(N,l)}}}var J=N(12506),n=N(12855),y=N(12868),H=N(12878),u=N(12564),W=N(12296),B=N(12479),Y=N(12461);const C=Y.HighestCommonFactor,M={...Y,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:C};var A=N(12668),E=N(12422),q=N(12903),b=N(12909),z=N(12664);const I=1e-6,t=new B.Ca(.04,.04,.04),O=1024,h=B.Ca.White(),i=B.Ca.Black();function k(l,a,N){if(a<t.r)return 0;const U=t.r,c=l*N/(1-t.r)+a-2*t.r,K=c*c-4*U*(t.r-a);return M.Clamp((-c+Math.sqrt(K))/(2*U),0,1)}function Q(l){const a=l.diffuseColor.toLinearSpace(l.bl().getEngine().useExactSrgbConversions).scale(.5),N=l.alpha,c=function(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new U.Vector2(0,1),N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new U.Vector2(0,.1),c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new U.Vector2(0,.1),K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new U.Vector2(1300,.1);return function(l,a,N,U,c){return(1-l)*(1-l)*(1-l)*a+3*(1-l)*(1-l)*l*N+3*(1-l)*l*l*U+l*l*l*c}(Math.pow(l/K.x,.333333),a.y,N.y,c.y,K.y)}(M.Clamp(l.specularPower,0,O));return{baseColorFactor:[a.r,a.g,a.b,N],metallicFactor:0,roughnessFactor:c}}function j(l,a){a.needAlphaBlending()?l.alphaMode="BLEND":a.needAlphaTesting()&&(l.alphaMode="MASK",l.alphaCutoff=a.alphaCutOff)}function f(l,a,N){const U=new Uint8Array(l*a*4);for(let c=0;c<U.length;c+=4)U[c]=U[c+1]=U[c+2]=U[c+3]=255;return q.d.CreateRGBATexture(U,l,a,N)}function p(l){if(l instanceof Uint8Array){const a=l.length,N=new Float32Array(l.length);for(let U=0;U<a;++U)N[U]=l[U]/255;return N}if(l instanceof Float32Array)return l;throw new Error("Unsupported pixel format!")}class R{constructor(l){this._exporter=l,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(l){return l?this._textureMap.get(l)??null:null}async exportStandardMaterialAsync(l,a,N){const U=Q(l),K={name:l.name};if(null==l.Ic||l.Ic||(l.twoSidedLighting||c.Tools.Warn(l.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),K.doubleSided=!0),N){const N=[],c=l.diffuseTexture;c&&N.push(this.exportTextureAsync(c,a).then((l=>{l&&(U.baseColorTexture=l)})));const Z=l.bumpTexture;Z&&N.push(this.exportTextureAsync(Z,a).then((l=>{l&&(K.normalTexture=l,1!==Z.level&&(K.normalTexture.scale=Z.level))})));const w=l.emissiveTexture;w&&(K.emissiveFactor=[1,1,1],N.push(this.exportTextureAsync(w,a).then((l=>{l&&(K.emissiveTexture=l)}))));const S=l.ambientTexture;S&&N.push(this.exportTextureAsync(S,a).then((l=>{if(l){const a={index:l.index};K.occlusionTexture=a}}))),N.length>0&&(this._exporter._materialNeedsUVsSet.add(l),await Promise.all(N))}(l.alpha<1||l.opacityTexture)&&(l.alphaMode===b.c.ALPHA_COMBINE?K.alphaMode="BLEND":c.Tools.Warn(l.name+": glTF 2.0 does not support alpha mode: "+l.alphaMode.toString())),l.emissiveColor&&!l.emissiveColor.equalsWithEpsilon(i,I)&&(K.emissiveFactor=l.emissiveColor.Bc()),K.pbrMetallicRoughness=U,j(K,l),await this._finishMaterialAsync(K,l,a);const Z=this._exporter._materials;return Z.push(K),Z.length-1}async _finishMaterialAsync(l,a,N){const U=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",l,a),c=[];for(const K of U)c.push(this.exportTextureAsync(K,N));await Promise.all(c),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",l,a)}async _getImageDataAsync(l,a,U,c){const K=b.c.TEXTURETYPE_UNSIGNED_BYTE,Z=this._exporter._babylonScene,w=Z.getEngine(),S=w.createRawTexture(l,a,U,b.c.TEXTUREFORMAT_RGBA,!1,!0,E.e.NEAREST_SAMPLINGMODE,null,K);w.isWebGPU?await N.e(51).then(N.bind(N,14912)):await N.e(52).then(N.bind(N,14917)),await A.k.ApplyPostProcess("pass",S,Z,K,b.c.TEXTURE_NEAREST_SAMPLINGMODE,b.c.TEXTUREFORMAT_RGBA);const T=await w._readTexturePixels(S,a,U);return await z.DumpTools.DumpDataAsync(a,U,T,c,void 0,!0,!0)}_resizeTexturesToSameDimensions(l,a,N){const U=l?l.getSize():{width:0,height:0},c=a?a.getSize():{width:0,height:0};let K,Z;return U.width<c.width?(K=l&&l instanceof E.e?A.k.CreateResizedCopy(l,c.width,c.height,!0):f(c.width,c.height,N),Z=a):U.width>c.width?(Z=a&&a instanceof E.e?A.k.CreateResizedCopy(a,U.width,U.height,!0):f(U.width,U.height,N),K=l):(K=l,Z=a),{texture1:K,texture2:Z}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(l,a,N,U){const c=new Array;if(!l&&!a)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const K=l?l.bl():a?a.bl():null;if(K){var Z;const w=this._resizeTexturesToSameDimensions(l,a,K),S=null===(Z=w.texture1)||void 0===Z?void 0:Z.getSize();let T,J;const n=S.width,y=S.height,H=await w.texture1.readPixels(),u=await w.texture2.readPixels();if(!H)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(T=p(H),!u)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");J=p(u);const W=J.byteLength,Y=new Uint8Array(W),C=new Uint8Array(W),M=4,A=i;let E=0,q=0;for(let l=0;l<y;++l)for(let a=0;a<n;++a){const U=(n*l+a)*M,c={diffuseColor:new B.Ca(T[U],T[U+1],T[U+2]).toLinearSpace(K.getEngine().useExactSrgbConversions).multiply(N.diffuseColor),specularColor:new B.Ca(J[U],J[U+1],J[U+2]).toLinearSpace(K.getEngine().useExactSrgbConversions).multiply(N.specularColor),glossiness:J[U+3]*N.glossiness},Z=this._convertSpecularGlossinessToMetallicRoughness(c);A.r=Math.max(A.r,Z.baseColor.r),A.g=Math.max(A.g,Z.baseColor.g),A.b=Math.max(A.b,Z.baseColor.b),E=Math.max(E,Z.metallic),q=Math.max(q,Z.roughness),C[U]=255*Z.baseColor.r,C[U+1]=255*Z.baseColor.g,C[U+2]=255*Z.baseColor.b,C[U+3]=w.texture1.Mc?255*T[U+3]:255,Y[U]=0,Y[U+1]=255*Z.roughness,Y[U+2]=255*Z.metallic,Y[U+3]=255}const b={baseColor:A,metallic:E,roughness:q};let z=!1,t=!1;for(let l=0;l<y;++l)for(let a=0;a<n;++a){const N=(n*l+a)*M;C[N]/=b.baseColor.r>I?b.baseColor.r:1,C[N+1]/=b.baseColor.g>I?b.baseColor.g:1,C[N+2]/=b.baseColor.b>I?b.baseColor.b:1;const U=B.Ca.FromInts(C[N],C[N+1],C[N+2]).toGammaSpace(K.getEngine().useExactSrgbConversions);C[N]=255*U.r,C[N+1]=255*U.g,C[N+2]=255*U.b,U.equalsWithEpsilon(h,I)||(t=!0),Y[N+1]/=b.roughness>I?b.roughness:1,Y[N+2]/=b.metallic>I?b.metallic:1;B.Ca.FromInts(255,Y[N+1],Y[N+2]).equalsWithEpsilon(h,I)||(z=!0)}return z&&c.push(this._getImageDataAsync(Y,n,y,U).then((l=>{b.metallicRoughnessTextureData=l}))),t&&c.push(this._getImageDataAsync(C,n,y,U).then((l=>{b.baseColorTextureData=l}))),await Promise.all(c).then((()=>b))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(l){const a=this._getPerceivedBrightness(l.diffuseColor),N=this._getPerceivedBrightness(l.specularColor),U=1-this._getMaxComponent(l.specularColor),c=k(a,N,U),K=l.diffuseColor.scale(U/(1-t.r)/Math.max(1-c)),Z=l.specularColor.Wa(t.scale(1-c)).scale(1/Math.max(c));let w=B.Ca.Lerp(K,Z,c*c);w=w.clampToRef(0,1,w);return{baseColor:w,metallic:c,roughness:1-l.glossiness}}_getPerceivedBrightness(l){return l?Math.sqrt(.299*l.r*l.r+.587*l.g*l.g+.114*l.b*l.b):0}_getMaxComponent(l){return l?Math.max(l.r,Math.max(l.g,l.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(l,a,N,U){const c=[],K={baseColor:l._albedoColor,metallic:l._metallic,roughness:l._roughness};if(U){l._albedoTexture&&c.push(this.exportTextureAsync(l._albedoTexture,a).then((l=>{l&&(N.baseColorTexture=l)})));const U=l._metallicTexture;U&&c.push(this.exportTextureAsync(U,a).then((l=>{l&&(N.metallicRoughnessTexture=l)})))}return c.length>0&&(this._exporter._materialNeedsUVsSet.add(l),await Promise.all(c)),K}_getTextureSampler(l){const a={};if(!l||!(l instanceof E.e))return a;const N=this._getGLTFTextureWrapMode(l.wrapU);10497!==N&&(a.wrapS=N);const U=this._getGLTFTextureWrapMode(l.wrapV);switch(10497!==U&&(a.wrapT=U),l.samplingMode){case E.e.LINEAR_LINEAR:a.magFilter=9729,a.minFilter=9729;break;case E.e.LINEAR_NEAREST:a.magFilter=9729,a.minFilter=9728;break;case E.e.NEAREST_LINEAR:a.magFilter=9728,a.minFilter=9729;break;case E.e.NEAREST_LINEAR_MIPLINEAR:a.magFilter=9728,a.minFilter=9987;break;case E.e.NEAREST_NEAREST:a.magFilter=9728,a.minFilter=9728;break;case E.e.NEAREST_LINEAR_MIPNEAREST:a.magFilter=9728,a.minFilter=9985;break;case E.e.LINEAR_NEAREST_MIPNEAREST:a.magFilter=9729,a.minFilter=9984;break;case E.e.LINEAR_NEAREST_MIPLINEAR:a.magFilter=9729,a.minFilter=9986;break;case E.e.NEAREST_NEAREST_MIPLINEAR:a.magFilter=9728,a.minFilter=9986;break;case E.e.LINEAR_LINEAR_MIPLINEAR:a.magFilter=9729,a.minFilter=9987;break;case E.e.LINEAR_LINEAR_MIPNEAREST:a.magFilter=9729,a.minFilter=9985;break;case E.e.NEAREST_NEAREST_MIPNEAREST:a.magFilter=9728,a.minFilter=9984}return a}_getGLTFTextureWrapMode(l){switch(l){case E.e.WRAP_ADDRESSMODE:return 10497;case E.e.CLAMP_ADDRESSMODE:return 33071;case E.e.MIRROR_ADDRESSMODE:return 33648;default:return c.Tools.Error(`Unsupported Texture Wrap Mode ${l}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(l,a,N,U){const c={diffuseColor:l._albedoColor,specularColor:l._reflectivityColor,glossiness:l._microSurface},K=l._albedoTexture,Z=l._reflectivityTexture,w=l._useMicroSurfaceFromReflectivityMapAlpha;if(Z&&!w)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((K||Z)&&U){this._exporter._materialNeedsUVsSet.add(l);const U=this._exportTextureSampler(K||Z),w=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(K,Z,c,a),S=this._exporter._textures;if(w.baseColorTextureData){const l=this._exportImage(`baseColor${S.length}`,a,w.baseColorTextureData);N.baseColorTexture=this._exportTextureInfo(l,U,null===K||void 0===K?void 0:K.coordinatesIndex)}if(w.metallicRoughnessTextureData){const l=this._exportImage(`metallicRoughness${S.length}`,a,w.metallicRoughnessTextureData);N.metallicRoughnessTexture=this._exportTextureInfo(l,U,null===Z||void 0===Z?void 0:Z.coordinatesIndex)}return w}return this._convertSpecularGlossinessToMetallicRoughness(c)}async exportPBRMaterialAsync(l,a,N){const U={},c={name:l.name},K=l.isMetallicWorkflow();if(K){const a=l._albedoColor,N=l.alpha;a&&(U.baseColorFactor=[a.r,a.g,a.b,N])}const Z=K?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(l,a,U,N):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(l,a,U,N);await this._setMetallicRoughnessPbrMaterialAsync(Z,l,c,U,a,N),await this._finishMaterialAsync(c,l,a);const w=this._exporter._materials;return w.push(c),w.length-1}async _setMetallicRoughnessPbrMaterialAsync(l,a,N,U,K,Z){if(j(N,a),l.baseColor.equalsWithEpsilon(h,I)&&M.WithinEpsilon(a.alpha,1,I)||(U.baseColorFactor=[l.baseColor.r,l.baseColor.g,l.baseColor.b,a.alpha]),null!=l.metallic&&1!==l.metallic&&(U.metallicFactor=l.metallic),null!=l.roughness&&1!==l.roughness&&(U.roughnessFactor=l.roughness),null==a.Ic||a.Ic||(a._twoSidedLighting||c.Tools.Warn(a.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),N.doubleSided=!0),Z){const l=[],U=a._bumpTexture;U&&l.push(this.exportTextureAsync(U,K).then((l=>{l&&(N.normalTexture=l,1!==U.level&&(N.normalTexture.scale=U.level))})));const c=a._ambientTexture;c&&l.push(this.exportTextureAsync(c,K).then((l=>{if(l){const U={index:l.index,texCoord:l.texCoord,extensions:l.extensions};N.occlusionTexture=U;const c=a._ambientTextureStrength;c&&(U.strength=c)}})));const Z=a._emissiveTexture;Z&&l.push(this.exportTextureAsync(Z,K).then((l=>{l&&(N.emissiveTexture=l)}))),l.length>0&&(this._exporter._materialNeedsUVsSet.add(a),await Promise.all(l))}const w=a._emissiveColor;w.equalsWithEpsilon(i,I)||(N.emissiveFactor=w.Bc()),N.pbrMetallicRoughness=U}_getPixelsFromTextureAsync(l){return function(l){switch(l){case b.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case b.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case b.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case b.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case b.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case b.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case b.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case b.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case b.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case b.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case b.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case b.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case b.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case b.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case b.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case b.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case b.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case b.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case b.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case b.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case b.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(l.textureFormat)?(0,A.h)(l,l._texture.width,l._texture.height):(l.textureType,b.c.TEXTURETYPE_UNSIGNED_BYTE,l.readPixels())}async exportTextureAsync(l,a){const N=this._exporter._extensionsPreExportTextureAsync("exporter",l,a);return N?await N.then((async N=>N?await this._exportTextureInfoAsync(N,a):await this._exportTextureInfoAsync(l,a))):await this._exportTextureInfoAsync(l,a)}async _exportTextureInfoAsync(l,a){let N=this._textureMap.get(l);if(!N){const U=await this._getPixelsFromTextureAsync(l);if(!U)return null;const K=this._exportTextureSampler(l),Z=l.mimeType;if(Z)switch(Z){case"image/jpeg":case"image/png":case"image/webp":a=Z;break;default:c.Tools.Warn(`Unsupported media type: ${Z}. Exporting texture as PNG.`)}const w=this._internalTextureToImage,S=l.getInternalTexture().uniqueId;w[S]||(w[S]={});let T=w[S][a];if(void 0===T){const N=l.getSize();T=(async()=>{const c=await this._getImageDataAsync(U,N.width,N.height,a);return this._exportImage(l.name,a,c)})(),w[S][a]=T}N=this._exportTextureInfo(await T,K,l.coordinatesIndex),this._textureMap.set(l,N),this._exporter._extensionsPostExportTextures("exporter",N,l)}return N}_exportImage(l,a,N){const U=this._exporter._images;let K;if(this._exporter._shouldUseGlb){K={name:l,mimeType:a,bufferView:void 0};const U=this._exporter._bufferManager.createBufferView(new Uint8Array(N));this._exporter._bufferManager.setBufferView(K,U)}else{const Z=l.replace(/\.\/|\/|\.\\|\\/g,"_"),w=function(l){switch(l){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(a);let S=Z+w;U.some((l=>l.uri===S))&&(S=`${Z}_${c.Tools.RandomId()}${w}`),K={name:l,uri:S},this._exporter._imageData[S]={data:N,mimeType:a}}return U.push(K),U.length-1}_exportTextureInfo(l,a,N){const U=this._exporter._textures;let c=U.findIndex((N=>N.sampler==a&&N.source===l));-1===c&&(c=U.length,U.push({source:l,sampler:a}));const K={index:c};return N&&(K.texCoord=N),K}_exportTextureSampler(l){const a=this._getTextureSampler(l),N=this._exporter._samplers,U=N.findIndex((l=>l.minFilter===a.minFilter&&l.magFilter===a.magFilter&&l.wrapS===a.wrapS&&l.wrapT===a.wrapT));return-1!==U?U:(N.push(a),N.length-1)}}var L=N(12520),r=N(12268),X=N(12916),P=N(12452);const d=U.ua.Zero(),F=U.Quaternion.Identity(),e=U.ua.One(),s=new U.ua(-1,1,1);function o(l,a){const{byteOffset:N,byteStride:U,type:c,normalized:K}=l,Z=l.getSize(),w=a.reduce(((l,a)=>a.getTotalVertices()>l?a.getTotalVertices():l),-Number.MAX_VALUE);return{byteOffset:N,byteStride:U,componentCount:Z,type:c,count:w*Z,normalized:K,totalVertices:w,kind:l.getKind()}}function G(l){switch(l){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function ml(l){switch(l){case J.h.PositionKind:case J.h.NormalKind:case J.h.TangentKind:case J.h.ColorKind:case J.h.MatricesIndicesKind:case J.h.MatricesIndicesExtraKind:case J.h.MatricesWeightsKind:case J.h.MatricesWeightsExtraKind:case J.h.UVKind:case J.h.UV2Kind:case J.h.UV3Kind:case J.h.UV4Kind:case J.h.UV5Kind:case J.h.UV6Kind:return!0}return!1}function x(l){switch(l){case K.c.TriangleFillMode:return 4;case K.c.TriangleStripDrawMode:return 5;case K.c.TriangleFanDrawMode:return 6;case K.c.PointListDrawMode:case K.c.PointFillMode:return 0;case K.c.LineLoopDrawMode:return 2;case K.c.LineListDrawMode:return 1;case K.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${l}`)}function V(l){const a=Math.sqrt(l.x*l.x+l.y*l.y+l.z*l.z);a>0&&(l.x/=a,l.y/=a,l.z/=a)}function D(l){return l.x*=-1,l}function v(l){if(l.x*l.x+l.y*l.y>.5){const a=Math.abs(l.x),N=Math.abs(l.y);if(a>N){const N=Math.sign(l.x);l.x=a,l.y*=-N,l.z*=-N,l.w*=N}else{const a=Math.sign(l.y);l.x*=-a,l.y=N,l.z*=a,l.w*=-a}}else{const a=Math.abs(l.z),N=Math.abs(l.w);if(a>N){const N=Math.sign(l.z);l.x*=-N,l.y*=N,l.z=a,l.w*=-N}else{const a=Math.sign(l.w);l.x*=a,l.y*=-a,l.z*=-a,l.w=N}}return l}function g(l){l.tc(-l.z,l.w,l.x,-l.y)}function ll(l,a){const N=U.ua.FromArrayToRef(a.translation||[0,0,0],0,U.TmpVectors.ua[0]),c=U.Quaternion.FromArrayToRef(a.rotation||[0,0,0,1],0,U.TmpVectors.Quaternion[0]),K=U.Matrix.ComposeToRef(e,c,N,U.TmpVectors.Matrix[0]),Z=U.ua.FromArrayToRef(l.translation||[0,0,0],0,U.TmpVectors.ua[2]),w=U.Quaternion.FromArrayToRef(l.rotation||[0,0,0,1],0,U.TmpVectors.Quaternion[1]),S=U.Matrix.ComposeToRef(e,w,Z,U.TmpVectors.Matrix[1]);K.multiplyToRef(S,S),S.decompose(void 0,c,N),N.equalsWithEpsilon(d,P.d)?delete a.translation:a.translation=N.Bc(),c.equalsWithEpsilon(F,P.d)?delete a.rotation:a.rotation=c.Bc(),a.scale&&delete a.scale}function al(l,a){if(!(a instanceof n.e))return!1;if(!(1===a.getChildren().length&&0===l.getChildren().length&&l.parent===a))return!1;const N=l.bl(),U=l instanceof X.d&&!N.useRightHandedSystem?s:e;return!!a.Oc.equalsWithEpsilon(U,P.d)||(r.b.Warn(`Cannot collapse node ${l.name} into parent node ${a.name} with modified scaling.`),!1)}function Nl(l){if(l instanceof Array){const a=new Float32Array(l);return new Uint8Array(a.buffer,a.byteOffset,a.byteLength)}return ArrayBuffer.isView(l)?new Uint8Array(l.buffer,l.byteOffset,l.byteLength):new Uint8Array(l)}function Ul(l,a){for(const[N,U]of Object.entries(l)){const c=a[N];(Array.isArray(U)&&Array.isArray(c)&&cl(U,c)||U===c)&&delete l[N]}return l}function cl(l,a){return l.length===a.length&&l.every(((l,N)=>l===a[N]))}const Kl=U.Matrix.Compose(new U.ua(-1,1,1),U.Quaternion.Identity(),U.ua.Zero());function Zl(l,a){if(!(l instanceof n.e))return!1;if(a){if(!l.getWorldMatrix().equalsWithEpsilon(U.Matrix.IdentityReadOnly,P.d))return!1}else{if(!l.getWorldMatrix().multiplyToRef(Kl,U.TmpVectors.Matrix[0]).equalsWithEpsilon(U.Matrix.IdentityReadOnly,P.d))return!1}return!(l instanceof y.b&&l.bc)}const wl=new Map([[Int8Array,(l,a,N)=>l.setInt8(a,N)],[Uint8Array,(l,a,N)=>l.setUint8(a,N)],[Uint8ClampedArray,(l,a,N)=>l.setUint8(a,N)],[Int16Array,(l,a,N)=>l.setInt16(a,N,!0)],[Uint16Array,(l,a,N)=>l.setUint16(a,N,!0)],[Int32Array,(l,a,N)=>l.setInt32(a,N,!0)],[Uint32Array,(l,a,N)=>l.setUint32(a,N,!0)],[Float32Array,(l,a,N)=>l.setFloat32(a,N,!0)],[Float64Array,(l,a,N)=>l.setFloat64(a,N,!0)]]);class Sl{writeTypedArray(l){this._checkGrowBuffer(l.byteLength);const a=wl.get(l.constructor);for(let N=0;N<l.length;N++)a(this._dataView,this._byteOffset,l[N]),this._byteOffset+=l.BYTES_PER_ELEMENT}constructor(l){this._data=new Uint8Array(l),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(l){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,l),this._byteOffset++}writeInt8(l){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,l),this._byteOffset++}writeInt16(l){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,l,!0),this._byteOffset+=2}writeUInt16(l){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,l,!0),this._byteOffset+=2}writeInt32(l){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,l,!0),this._byteOffset+=4}writeUInt32(l){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,l,!0),this._byteOffset+=4}writeFloat32(l){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,l,!0),this._byteOffset+=4}writeFloat64(l){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,l,!0),this._byteOffset+=8}_checkGrowBuffer(l){const a=this.byteOffset+l;if(a>this._data.byteLength){const l=new Uint8Array(2*a);l.set(this._data),this._data=l,this._dataView=new DataView(this._data.buffer)}}}function Tl(l){return l%4===0?4:l%2===0?2:1}class Jl{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(l){let a=0;this._bufferViewToData.forEach((l=>{a+=l.byteLength}));const N=new Sl(a),U=Array.from(this._bufferViewToData.keys()).sort(((l,a)=>Tl(a.byteLength)-Tl(l.byteLength)));for(const c of U){c.byteOffset=N.byteOffset,l.push(c);const a=l.length-1,U=this.getPropertiesWithBufferView(c);for(const l of U)l.bufferView=a;N.writeTypedArray(this._bufferViewToData.get(c)),this._bufferViewToData.delete(c)}return N.getOutputData()}createBufferView(l,a){const N={buffer:0,byteOffset:void 0,byteLength:l.byteLength,byteStride:a};return this._bufferViewToData.set(N,l),N}createAccessor(l,a,N,U,c,K,Z){this._verifyBufferView(l);const w={bufferView:void 0,componentType:N,count:U,type:a,min:null===K||void 0===K?void 0:K.min,max:null===K||void 0===K?void 0:K.max,normalized:Z,byteOffset:c};return this.setBufferView(w,l),this._accessorToBufferView.set(w,l),w}setBufferView(l,a){this._verifyBufferView(a);this.getPropertiesWithBufferView(a).push(l)}removeBufferView(l){const a=this.getPropertiesWithBufferView(l);for(const N of a)void 0!==N.bufferView&&delete N.bufferView;this._bufferViewToData.delete(l),this._bufferViewToProperties.delete(l),this._accessorToBufferView.forEach(((a,N)=>{a===l&&(void 0!==N.byteOffset&&delete N.byteOffset,this._accessorToBufferView.delete(N))}))}getBufferView(l){const a=this._accessorToBufferView.get(l);return this._verifyBufferView(a),a}getPropertiesWithBufferView(l){return this._verifyBufferView(l),this._bufferViewToProperties.set(l,this._bufferViewToProperties.get(l)??[]),this._bufferViewToProperties.get(l)}getData(l){return this._verifyBufferView(l),this._bufferViewToData.get(l)}_verifyBufferView(l){if(void 0===l||!this._bufferViewToData.has(l))throw new Error(`BufferView ${l} not found in BufferManager.`)}}var nl,yl=N(12885),Hl=N(12897),ul=N(12920),Wl=N(12811),Bl=N(12950),Yl=N(12962),Cl=N(12883),Ml=N(12966);!function(l){l[l.INTANGENT=0]="INTANGENT",l[l.OUTTANGENT=1]="OUTTANGENT"}(nl||(nl={}));class Al{static _IsTransformable(l){return l&&(l instanceof n.e||l instanceof yl.e||l instanceof Ml.c)}static _CreateNodeAnimation(l,a,N,U,K){if(this._IsTransformable(l)){const Z=[],w=[],S=a.getKeys(),T=Al._CalculateMinMaxKeyFrames(S),J=Al._DeduceInterpolation(S,N,U),n=J.interpolationType,y=J.shouldBakeAnimation;if(y?Al._CreateBakedAnimation(l,a,N,T.min,T.max,a.framePerSecond,K,Z,w,T,U):"LINEAR"===n||"STEP"===n?Al._CreateLinearOrStepAnimation(l,a,N,Z,w,U):"CUBICSPLINE"===n?Al._CreateCubicSplineAnimation(l,a,N,Z,w,U):Al._CreateBakedAnimation(l,a,N,T.min,T.max,a.framePerSecond,K,Z,w,T,U),Z.length&&w.length){return{inputs:Z,outputs:w,samplerInterpolation:n,inputsMin:y?T.min:c.Tools.FloatRound(T.min/a.framePerSecond),inputsMax:y?T.max:c.Tools.FloatRound(T.max/a.framePerSecond)}}}return null}static _DeduceAnimationInfo(l){let a=null,N="VEC3",U=!1;const K=l.targetProperty.split(".");switch(K[0]){case"Oc":a="scale";break;case"position":a="translation";break;case"rotation":N="VEC4",a="rotation";break;case"rotationQuaternion":N="VEC4",U=!0,a="rotation";break;case"influence":N="SCALAR",a="weights";break;default:c.Tools.Error(`Unsupported animatable property ${K[0]}`)}return a?{animationChannelTargetPath:a,dataAccessorType:N,useQuaternion:U}:(c.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(l,a,N,U,c,K,Z,w,S,T,J){let n;if(Al._IsTransformable(l)&&l.animations)for(const y of l.animations){if(J&&!J(y))continue;const c=Al._DeduceAnimationInfo(y);c&&(n={name:y.name,samplers:[],channels:[]},Al._AddAnimation(`${y.name}`,y.hasRunningRuntimeAnimations?a:n,l,y,c.dataAccessorType,c.animationChannelTargetPath,U,K,Z,w,c.useQuaternion,S,T),n.samplers.length&&n.channels.length&&N.push(n))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(l,a,N,U,c,K,Z,w,S,T,J){let n;if(l instanceof Cl.d){const c=l.morphTargetManager;if(c)for(let y=0;y<c.numTargets;++y){const H=c.getTarget(y);for(const u of H.animations){if(J&&!J(u))continue;const H=new Bl.d(`${u.name}`,"influence",u.framePerSecond,u.dataType,u.loopMode,u.enableBlending),W=[],B=u.getKeys();for(let l=0;l<B.length;++l){const a=B[l];for(let l=0;l<c.numTargets;++l)l==y?W.push(a):W.push({frame:a.frame,value:0})}H.setKeys(W);const Y=Al._DeduceAnimationInfo(H);Y&&(n={name:H.name,samplers:[],channels:[]},Al._AddAnimation(u.name,u.hasRunningRuntimeAnimations?a:n,l,H,Y.dataAccessorType,Y.animationChannelTargetPath,U,K,Z,w,Y.useQuaternion,S,T,c.numTargets),n.samplers.length&&n.channels.length&&N.push(n))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(l,a,N,U,c,K,Z,w,S){let T;if(l.animationGroups){const n=l.animationGroups;for(const y of n){const n=new Map,H=new Map,u=new Set,W=y.to-y.from;T={name:y.name,channels:[],samplers:[]};for(let a=0;a<y.targetedAnimations.length;++a){const W=y.targetedAnimations[a],B=W.target,Y=W.animation;if(S&&!S(Y))continue;const C=w.has(B);if(this._IsTransformable(B)||1===B.length&&this._IsTransformable(B[0])){const l=Al._DeduceAnimationInfo(W.animation);if(l){const a=this._IsTransformable(B)?B:this._IsTransformable(B[0])?B[0]:null;a&&Al._AddAnimation(`${Y.name}`,T,a,Y,l.dataAccessorType,l.animationChannelTargetPath,N,U,c,K,l.useQuaternion,Z,C)}}else if(B instanceof Yl.b||1===B.length&&B[0]instanceof Yl.b){if(Al._DeduceAnimationInfo(W.animation)){const a=B instanceof Yl.b?B:B[0];if(a){const N=l.morphTargetManagers.find((l=>{for(let N=0;N<l.numTargets;++N)if(l.getTarget(N)===a)return!0;return!1}));if(N){const U=l.meshes.find((l=>l.morphTargetManager===N));var J;if(U)n.has(U)||n.set(U,new Map),null===(J=n.get(U))||void 0===J||J.set(a,Y),u.add(U),H.set(U,Y)}}}}}u.forEach((l=>{const a=l.morphTargetManager;let w=null;const S=[],J=H.get(l).getKeys(),u=J.length;for(let N=0;N<u;++N)for(let U=0;U<a.numTargets;++U){const c=a.getTarget(U),K=n.get(l);if(K){const a=K.get(c);a?(w||(w=new Bl.d(`${y.name}_${l.name}_MorphWeightAnimation`,"influence",a.framePerSecond,Bl.d.ANIMATIONTYPE_FLOAT,a.loopMode,a.enableBlending)),S.push(a.getKeys()[N])):S.push({frame:y.from+W/u*N,value:c.influence,inTangent:J[0].inTangent?0:void 0,outTangent:J[0].outTangent?0:void 0})}}w.setKeys(S);const B=Al._DeduceAnimationInfo(w);B&&Al._AddAnimation(`${y.name}_${l.name}_MorphWeightAnimation`,T,l,w,B.dataAccessorType,B.animationChannelTargetPath,N,U,c,K,B.useQuaternion,Z,!1,null===a||void 0===a?void 0:a.numTargets)})),T.channels.length&&T.samplers.length&&a.push(T)}}}static _AddAnimation(l,a,N,c,K,Z,w,S,T,J,n,y,H,u){const W=Al._CreateNodeAnimation(N,c,Z,n,y);let B,Y,C,M,A,E;if(W){if(u){let l=0,a=0;const N=[];for(;W.inputs.length>0;)a=W.inputs.shift(),l%u==0&&N.push(a),l++;W.inputs=N}const l=w.get(N),c=new Float32Array(W.inputs);B=S.createBufferView(c),Y=S.createAccessor(B,"SCALAR",5126,W.inputs.length,void 0,{min:[W.inputsMin],max:[W.inputsMax]}),J.push(Y),C=J.length-1;const T=new U.Quaternion,n=new U.ua,y=new U.ua,q=N instanceof yl.e,b=G(K),z=new Float32Array(W.outputs.length*b);W.outputs.forEach((function(l,a){let N=l;switch(Z){case"translation":H&&(U.ua.FromArrayToRef(l,0,y),D(y),y.toArray(N));break;case"rotation":4===l.length?U.Quaternion.FromArrayToRef(l,0,T):(N=new Array(4),U.ua.FromArrayToRef(l,0,n),U.Quaternion.FromEulerVectorToRef(n,T)),H&&(v(T),q&&g(T)),T.toArray(N)}z.set(N,a*b)})),B=S.createBufferView(z),Y=S.createAccessor(B,K,5126,W.outputs.length),J.push(Y),M=J.length-1,A={interpolation:W.samplerInterpolation,input:C,output:M},a.samplers.push(A),E={sampler:a.samplers.length-1,target:{node:l,path:Z}},a.channels.push(E)}}static _CreateBakedAnimation(l,a,N,K,Z,w,S,T,J,n,y){let H;const u=U.Quaternion.Identity();let W,B=null,Y=null,C=null,M=null,A=null,E=null;n.min=c.Tools.FloatRound(K/w);const q=a.getKeys();for(let U=0,b=q.length;U<b;++U){if(E=null,C=q[U],U+1<b)if(M=q[U+1],C.value.equals&&C.value.equals(M.value)||C.value===M.value){if(0!==U)continue;E=C.frame}else E=M.frame;else{if(A=q[U-1],C.value.equals&&C.value.equals(A.value)||C.value===A.value)continue;E=Z}if(E)for(let U=C.frame;U<=E;U+=S){if(W=c.Tools.FloatRound(U/w),W===B)continue;B=W,Y=W;const K={key:0,repeatCount:0,loopMode:a.loopMode};H=a._interpolate(U,K),Al._SetInterpolatedValue(l,H,W,a,N,u,T,J,y)}}Y&&(n.max=Y)}static _ConvertFactorToVector3OrQuaternion(l,a,N,K,Z){const w=Al._GetBasePositionRotationOrScale(a,K,Z),S=N.targetProperty.split("."),T=S?S[1]:"",J=Z?U.Quaternion.Ma(w).normalize():U.ua.Ma(w);switch(T){case"x":case"y":case"z":J[T]=l;break;case"w":J.w=l;break;default:c.Tools.Error(`glTFAnimation: Unsupported component name "${T}"!`)}return J}static _SetInterpolatedValue(l,a,N,c,K,Z,w,S,T){let J;w.push(N),"weights"!==K?(c.dataType===Bl.d.ANIMATIONTYPE_FLOAT&&(a=this._ConvertFactorToVector3OrQuaternion(a,l,c,K,T)),"rotation"===K?(T?Z=a:(J=a,U.Quaternion.RotationYawPitchRollToRef(J.y,J.x,J.z,Z)),S.push(Z.Bc())):(J=a,S.push(J.Bc()))):S.push([a])}static _CreateLinearOrStepAnimation(l,a,N,U,c,K){for(const Z of a.getKeys())U.push(Z.frame/a.framePerSecond),Al._AddKeyframeValue(Z,a,c,N,l,K)}static _CreateCubicSplineAnimation(l,a,N,U,c,K){a.getKeys().forEach((function(Z){U.push(Z.frame/a.framePerSecond),Al._AddSplineTangent(nl.INTANGENT,c,N,"CUBICSPLINE",Z,K),Al._AddKeyframeValue(Z,a,c,N,l,K),Al._AddSplineTangent(nl.OUTTANGENT,c,N,"CUBICSPLINE",Z,K)}))}static _GetBasePositionRotationOrScale(l,a,N){let c;if("rotation"===a)if(N){c=(l.rotationQuaternion??U.Quaternion.Identity()).Bc()}else{c=(l.rotation??U.ua.Zero()).Bc()}else if("translation"===a){c=(l.position??U.ua.Zero()).Bc()}else{c=(l.Oc??U.ua.One()).Bc()}return c}static _AddKeyframeValue(l,a,N,K,Z,w){let S;const T=a.dataType;if(T===Bl.d.ANIMATIONTYPE_VECTOR3){let a=l.value.Bc();if("rotation"===K){const l=U.ua.Ma(a);a=U.Quaternion.RotationYawPitchRoll(l.y,l.x,l.z).Bc()}N.push(a)}else if(T===Bl.d.ANIMATIONTYPE_FLOAT){if("weights"===K)N.push([l.value]);else if(S=this._ConvertFactorToVector3OrQuaternion(l.value,Z,a,K,w),S){if("rotation"===K){const l=w?S:U.Quaternion.RotationYawPitchRoll(S.y,S.x,S.z).normalize();N.push(l.Bc())}N.push(S.Bc())}}else T===Bl.d.ANIMATIONTYPE_QUATERNION?N.push(l.value.normalize().Bc()):c.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(l,a,N){let U,c,K=!1;if("rotation"===a&&!N)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let Z=0,w=l.length;Z<w;++Z)if(c=l[Z],c.inTangent||c.outTangent)if(U){if("CUBICSPLINE"!==U){U="LINEAR",K=!0;break}}else U="CUBICSPLINE";else if(U){if("CUBICSPLINE"===U||c.interpolation&&1===c.interpolation&&"STEP"!==U){U="LINEAR",K=!0;break}}else U=c.interpolation&&1===c.interpolation?"STEP":"LINEAR";return U||(U="LINEAR"),{interpolationType:U,shouldBakeAnimation:K}}static _AddSplineTangent(l,a,N,c,K,Z){let w;const S=l===nl.INTANGENT?K.inTangent:K.outTangent;if("CUBICSPLINE"===c){if("rotation"===N)if(S)if(Z)w=S.Bc();else{const l=S;w=U.Quaternion.RotationYawPitchRoll(l.y,l.x,l.z).Bc()}else w=[0,0,0,0];else w="weights"===N?S?[S]:[0]:S?S.Bc():[0,0,0];a.push(w)}}static _CalculateMinMaxKeyFrames(l){let a=1/0,N=-1/0;return l.forEach((function(l){a=Math.min(a,l.frame),N=Math.max(N,l.frame)})),{min:a,max:N}}}function El(l,a,N,K,Z,w){const S={attributes:{},influence:l.influence,name:l.name},T=a.bc;if(!T)return c.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),S;const n=w?-1:1,y=U.ua.Zero();let H=0,u=0;if(l.hasPositions){const K=l.getPositions(),w=T.getVerticesData(J.h.PositionKind);if(w){const l=new Float32Array(w.length),a=[1/0,1/0,1/0],c=[-1/0,-1/0,-1/0];u=w.length/3,H=0;for(let N=H;N<u;++N){const Z=U.ua.Ma(w,3*N);U.ua.Ma(K,3*N).subtractToRef(Z,y),y.x*=n,a[0]=Math.min(a[0],y.x),c[0]=Math.max(c[0],y.x),a[1]=Math.min(a[1],y.y),c[1]=Math.max(c[1],y.y),a[2]=Math.min(a[2],y.z),c[2]=Math.max(c[2],y.z),l[3*N]=y.x,l[3*N+1]=y.y,l[3*N+2]=y.z}const T=N.createBufferView(l,12),J=N.createAccessor(T,"VEC3",5126,K.length/3,0,{min:a,max:c});Z.push(J),S.attributes.POSITION=Z.length-1}else c.Tools.Warn(`Morph target positions for mesh ${a.name} were not exported. Mesh does not have position vertex data`)}if(l.hasNormals){const K=l.getNormals(),w=T.getVerticesData(J.h.NormalKind);if(w){const l=new Float32Array(w.length);u=w.length/3,H=0;for(let N=H;N<u;++N){const a=U.ua.Ma(w,3*N).normalize();U.ua.Ma(K,3*N).normalize().subtractToRef(a,y),l[3*N]=y.x*n,l[3*N+1]=y.y,l[3*N+2]=y.z}const a=N.createBufferView(l,12),c=N.createAccessor(a,"VEC3",5126,K.length/3,0);Z.push(c),S.attributes.NORMAL=Z.length-1}else c.Tools.Warn(`Morph target normals for mesh ${a.name} were not exported. Mesh does not have normals vertex data`)}if(l.hasTangents){const K=l.getTangents(),w=T.getVerticesData(J.h.TangentKind);if(w){u=w.length/4;const l=new Float32Array(3*u);H=0;for(let N=H;N<u;++N){const a=U.ua.Ma(w,4*N);V(a);const c=U.ua.Ma(K,3*N);V(c),c.subtractToRef(a,y),l[3*N]=y.x*n,l[3*N+1]=y.y,l[3*N+2]=y.z}const a=N.createBufferView(l,12),c=N.createAccessor(a,"VEC3",5126,u,0);Z.push(c),S.attributes.TANGENT=Z.length-1}else c.Tools.Warn(`Morph target tangents for mesh ${a.name} were not exported. Mesh does not have tangents vertex data`)}if(l.hasColors){const K=l.getColors(),w=T.getVerticesData(J.h.ColorKind),n=T.getVertexBuffer(J.h.ColorKind);if(w&&n){const l=n.getSize();u=w.length/l;const a=new Float32Array(u*l);H=0;for(let N=H;N<u;++N)if(3===l){const c=U.ua.Ma(w,N*l);U.ua.Ma(K,N*l).subtractToRef(c,y),a[3*N]=y.x,a[3*N+1]=y.y,a[3*N+2]=y.z}else if(4===l){const c=new U.Vector4,Z=U.Vector4.Ma(w,N*l);U.Vector4.Ma(K,N*l).subtractToRef(Z,c),a[4*N]=c.x,a[4*N+1]=c.y,a[4*N+2]=c.z,a[4*N+3]=c.w}else c.Tools.Warn(`Unsupported number of components for color attribute: ${l}`);const T=N.createBufferView(a,4*l),J=N.createAccessor(T,3===l?"VEC3":"VEC4",5126,u,0);Z.push(J),S.attributes.COLOR_0=Z.length-1}else c.Tools.Warn(`Morph target colors for mesh ${a.name} were not exported. Mesh does not have colors vertex data`)}return S}var ql=N(12968),bl=N(12842),zl=N(12825),Il=N(12394);class tl{}tl.DEFAULT_COLOR=B.Ca.White(),tl.DEFAULT_WIDTH_ATTENUATED=1,tl.DEFAULT_WIDTH=.1;var Ol=N(12647),hl=N(12970);class il{static ConvertPoints(l,a){if(l.length&&Array.isArray(l)&&"number"===typeof l[0])return[l];if(l.length&&Array.isArray(l[0])&&"number"===typeof l[0][0])return l;if(l.length&&!Array.isArray(l[0])&&l[0]instanceof U.ua){const a=[];for(let N=0;N<l.length;N++){const U=l[N];a.push(U.x,U.y,U.z)}return[a]}if(l.length>0&&Array.isArray(l[0])&&l[0].length>0&&l[0][0]instanceof U.ua){const a=[],N=l;for(const l of N)a.push(l.flatMap((l=>[l.x,l.y,l.z])));return a}if(l instanceof Float32Array){if(null!==a&&void 0!==a&&a.floatArrayStride){const N=[],U=3*a.floatArrayStride;for(let a=0;a<l.length;a+=U){const c=new Array(U);for(let N=0;N<U;N++)c[N]=l[a+N];N.push(c)}return N}return[Array.from(l)]}if(l.length&&l[0]instanceof Float32Array){const a=[];for(const N of l)a.push(Array.from(N));return a}return[]}static OmitZeroLengthPredicate(l,a,N){const U=[];return a.Wa(l).lengthSquared()>0&&U.push([l,a]),N.Wa(a).lengthSquared()>0&&U.push([a,N]),l.Wa(N).lengthSquared()>0&&U.push([N,l]),0===U.length?null:U}static OmitDuplicatesPredicate(l,a,N,U){const c=[];return il._SearchInPoints(l,a,U)||c.push([l,a]),il._SearchInPoints(a,N,U)||c.push([a,N]),il._SearchInPoints(N,l,U)||c.push([N,l]),0===c.length?null:c}static _SearchInPoints(l,a,N){for(const Z of N)for(let N=0;N<Z.length;N++){var U,c,K;if(null!==(U=Z[N])&&void 0!==U&&U.equals(l))if(null!==(c=Z[N+1])&&void 0!==c&&c.equals(a)||null!==(K=Z[N-1])&&void 0!==K&&K.equals(a))return!0}return!1}static MeshesToLines(l,a){const N=[];for(let c=0;c<l.length;c++){const K=l[c],Z=K.getVerticesData(J.h.PositionKind),w=K.zc();if(Z&&w)for(let l=0,S=0;l<w.length;l++){const T=3*w[S++],J=3*w[S++],n=3*w[S++],y=new U.ua(Z[T],Z[T+1],Z[T+2]),H=new U.ua(Z[J],Z[J+1],Z[J+2]),u=new U.ua(Z[n],Z[n+1],Z[n+2]);if(a){const U=a(y,H,u,N,l,T,K,c,Z,w);if(U)for(const l of U)N.push(l)}else N.push([y,H],[H,u],[u,y])}}return N}static ToVector3Array(l){if(Array.isArray(l[0])){const a=[],N=l;for(const l of N){const N=[];for(let a=0;a<l.length;a+=3)N.push(new U.ua(l[a],l[a+1],l[a+2]));a.push(N)}return a}const a=l,N=[];for(let c=0;c<a.length;c+=3)N.push(new U.ua(a[c],a[c+1],a[c+2]));return N}static ToNumberArray(l){return l.flatMap((l=>[l.x,l.y,l.z]))}static GetPointsCountInfo(l){const a=new Array(l.length);let N=0;for(let U=l.length;U--;)a[U]=l[U].length/3,N+=a[U];return{total:N,counts:a}}static GetLineLength(l){if(0===l.length)return 0;let a;a="number"===typeof l[0]?il.ToVector3Array(l):l;const N=U.TmpVectors.ua[0];let c=0;for(let U=0;U<a.length-1;U++){const l=a[U];c+=a[U+1].subtractToRef(l,N).length()}return c}static GetLineLengthArray(l){const a=new Float32Array(l.length/3);let N=0;for(let U=0,c=l.length/3-1;U<c;U++){let c=l[3*U+0],K=l[3*U+1],Z=l[3*U+2];c-=l[3*U+3],K-=l[3*U+4],Z-=l[3*U+5];N+=Math.sqrt(c*c+K*K+Z*Z),a[U+1]=N}return a}static SegmentizeSegmentByCount(l,a,N){const c=[],K=a.Wa(l),Z=U.TmpVectors.ua[0];Z.hc(N);const w=U.TmpVectors.ua[1];K.divideToRef(Z,w);let S=l.clone();c.push(S);for(let U=0;U<N;U++)S=S.clone(),c.push(S.addInPlace(w));return c}static SegmentizeLineBySegmentLength(l,a){const N=l[0]instanceof U.ua?il.GetLineSegments(l):"number"===typeof l[0]?il.GetLineSegments(il.ToVector3Array(l)):l,c=[];for(const U of N)if(U.length>a){const l=il.SegmentizeSegmentByCount(U.point1,U.point2,Math.ceil(U.length/a));for(const a of l)c.push(a)}else c.push(U.point1),c.push(U.point2);return c}static SegmentizeLineBySegmentCount(l,a){const N="number"===typeof l[0]?il.ToVector3Array(l):l,U=il.GetLineLength(N)/a;return il.SegmentizeLineBySegmentLength(N,U)}static GetLineSegments(l){const a=[];for(let N=0;N<l.length-1;N++){const U=l[N],c=l[N+1],K=c.Wa(U).length();a.push({point1:U,point2:c,length:K})}return a}static GetMinMaxSegmentLength(l){const a=il.GetLineSegments(l).sort((l=>l.length));return{min:a[0].length,max:a[a.length-1].length}}static GetPositionOnLineByVisibility(l,a,N){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const K=a*N;let Z=0,w=0;const S=l.length;for(let U=0;U<S;U++){if(K<=Z+l[U].length){w=U;break}Z+=l[U].length}const T=(K-Z)/l[w].length;return l[w].point2.subtractToRef(l[w].point1,U.TmpVectors.ua[0]),U.TmpVectors.ua[1]=U.TmpVectors.ua[0].multiplyByFloats(T,T,T),c||U.TmpVectors.ua[1].addInPlace(l[w].point1),U.TmpVectors.ua[1].clone()}static GetCircleLinePoints(l,a){let N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:l,K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/a;const Z=[];for(let w=0;w<=a;w++)Z.push(new U.ua(Math.cos(w*K)*l,Math.sin(w*K)*c,N));return Z}static GetBezierLinePoints(l,a,N,U){return Ol.h.CreateQuadraticBezier(l,a,N,U).getPoints().flatMap((l=>[l.x,l.y,l.z]))}static GetArrowCap(l,a,N,U,c){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Z=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[l.clone(),l.add(a.multiplyByFloats(N,N,N))],widths:[U,c,K,Z]}}static GetPointsFromText(l,a,N,U){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,K=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const Z=[],w=(0,hl.e)(l,a,N,U);for(const S of w){for(const l of S.paths){const a=[],N=l.getPoints();for(const l of N)a.push(l.x,l.y,c);Z.push(a)}if(K)for(const l of S.holes){const a=[],N=l.getPoints();for(const l of N)a.push(l.x,l.y,c);Z.push(a)}}return Z}static Color3toRGBAUint8(l){const a=new Uint8Array(4*l.length);for(let N=0,U=0;N<l.length;N++)a[U++]=255*l[N].r,a[U++]=255*l[N].g,a[U++]=255*l[N].b,a[U++]=255;return a}static CreateColorsTexture(l,a,N,U){const c=U.getEngine().getCaps().maxTextureSize??1,K=a.length>c?c:a.length,Z=Math.ceil(a.length/c);Z>1&&(a=[...a,...Array(K*Z-a.length).fill(a[0])]);const w=il.Color3toRGBAUint8(a),S=new q.d(w,K,Z,u.d.TEXTUREFORMAT_RGBA,U,!1,!0,N);return S.name=l,S}static PrepareEmptyColorsTexture(l){if(!tl.EmptyColorsTexture){const a=new Uint8Array(4);tl.EmptyColorsTexture=new q.d(a,1,1,u.d.TEXTUREFORMAT_RGBA,l,!1,!1,q.d.NEAREST_NEAREST),tl.EmptyColorsTexture.name="grlEmptyColorsTexture"}return tl.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var l;null===(l=tl.EmptyColorsTexture)||void 0===l||l.dispose(),tl.EmptyColorsTexture=null}static BooleanToNumber(l){return l?1:0}}class kl extends zl.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Ql extends bl.b{isCompatible(l){return!0}constructor(l,a,N){var c;N=N||{color:tl.DEFAULT_COLOR};const K=new kl;K.GREASED_LINE_HAS_COLOR=!!N.color&&!N.useColors,K.GREASED_LINE_SIZE_ATTENUATION=N.sizeAttenuation??!1,K.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===N.colorDistributionType,K.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(a??l.bl()).useRightHandedSystem,K.GREASED_LINE_CAMERA_FACING=N.cameraFacing??!0,super(l,Ql.GREASED_LINE_MATERIAL_NAME,200,K,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(c=N)||void 0===c?void 0:c.forceGLSL)||Ql.ForceGLSL,this._scene=a??l.bl(),this._engine=this._scene.getEngine(),this._cameraFacing=N.cameraFacing??!0,this.visibility=N.visibility??1,this.useDash=N.useDash??!1,this.dashRatio=N.dashRatio??.5,this.dashOffset=N.dashOffset??0,this.width=N.width?N.width:N.sizeAttenuation?tl.DEFAULT_WIDTH_ATTENUATED:tl.DEFAULT_WIDTH,this._sizeAttenuation=N.sizeAttenuation??!1,this.colorMode=N.colorMode??0,this._color=N.color??null,this.useColors=N.useColors??!1,this._colorsDistributionType=N.colorDistributionType??0,this.colorsSampling=N.colorsSampling??q.d.NEAREST_NEAREST,this._colors=N.Ol??null,this.dashCount=N.dashCount??1,this.resolution=N.resolution??new U.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),N.colorsTexture?this.colorsTexture=N.colorsTexture:this._colors?this.colorsTexture=il.CreateColorsTexture(`${l.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??tl.DEFAULT_COLOR,il.PrepareEmptyColorsTexture(this._scene)),this._engine.Tc.add((()=>{il.DisposeEmptyColorsTexture()}))}getAttributes(l){l.push("grl_offsets"),l.push("grl_widths"),l.push("grl_colorPointers"),l.push("grl_counters"),this._cameraFacing?(l.push("grl_previousAndSide"),l.push("grl_nextAndCounters")):l.push("grl_slopes")}getSamplers(l){l.push("grl_colors")}getActiveTextures(l){this.colorsTexture&&l.push(this.colorsTexture)}getUniforms(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const a=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&a.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===l&&a.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:a,vertex:this._cameraFacing&&this._isGLSL(l)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(l)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(l){if(this._cameraFacing){l.Ec("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||l.Ec("viewProjection",this._scene.getTransformMatrix());const a=U.TmpVectors.Vector4[0];a.x=this._aspect,a.y=this._resolution.x,a.z=this._resolution.y,a.w=this.width,l.updateVector4("grl_aspect_resolution_lineWidth",a)}const a=U.TmpVectors.Vector4[0];a.x=il.BooleanToNumber(this.useDash),a.y=this._dashArray,a.z=this.dashOffset,a.w=this.dashRatio,l.updateVector4("grl_dashOptions",a);const N=U.TmpVectors.Vector4[1];N.x=this.colorMode,N.y=this.visibility,N.z=this.colorsTexture?this.colorsTexture.getSize().width:0,N.w=il.BooleanToNumber(this.useColors),l.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",N),this._color&&l.updateColor3("grl_singleColor",this._color);const c=this.colorsTexture??tl.EmptyColorsTexture;l.setTexture("grl_colors",c),l.updateFloat2("grl_textureSize",(null===c||void 0===c?void 0:c.getSize().width)??1,(null===c||void 0===c?void 0:c.getSize().height)??1)}prepareDefines(l,a,N){l.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,l.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,l.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,l.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=a.useRightHandedSystem,l.GREASED_LINE_CAMERA_FACING=this._cameraFacing,l.GREASED_LINE_USE_OFFSETS=!!N.offsets}getClassName(){return Ql.GREASED_LINE_MATERIAL_NAME}getCustomCode(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(a)?function(l,a){if("vertex"===l){const l={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return a&&(l["!gl_Position\\=viewProjection\\*worldPos;"]="//"),l}return"fragment"===l?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(l,this._cameraFacing):function(l,a){if("vertex"===l){const l={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return a&&(l["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),l}return"fragment"===l?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(l,this._cameraFacing)}dispose(){var l;null===(l=this.colorsTexture)||void 0===l||l.dispose(),super.dispose()}get Ol(){return this._colors}set Ol(l){this.setColors(l)}setColors(l){var a;let N=arguments.length>1&&void 0!==arguments[1]&&arguments[1],U=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const c=(null===(a=this._colors)||void 0===a?void 0:a.length)??0;var K;if(this._colors=l,null!==l&&0!==l.length){if(!N||U)if(this.colorsTexture&&c===l.length&&!U){const a=il.Color3toRGBAUint8(l);this.colorsTexture.update(a)}else{var Z;null===(Z=this.colorsTexture)||void 0===Z||Z.dispose(),this.colorsTexture=il.CreateColorsTexture(`${this._material.name}-colors-texture`,l,this.colorsSampling,this._scene)}}else null===(K=this.colorsTexture)||void 0===K||K.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(l){this._dashCount=l,this._dashArray=1/l}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(l){this._sizeAttenuation=l,this.markAllDefinesAsDirty()}get color(){return this._color}set color(l){this.setColor(l)}setColor(l){let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==l||null!==this._color&&null===l?(this._color=l,a||this.markAllDefinesAsDirty()):this._color=l}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(l){this._colorsDistributionType=l,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(l){this._aspect=l.x/l.y,this._resolution=l}serialize(){const l=super.serialize(),a={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(a.Ol=this._colors),this._color&&(a.color=this._color),l.greasedLineMaterialOptions=a,l}parse(l,a,N){var U;super.parse(l,a,N);const c=l.greasedLineMaterialOptions;null===(U=this.colorsTexture)||void 0===U||U.dispose(),c.color&&this.setColor(c.color,!0),c.colorDistributionType&&(this.colorsDistributionType=c.colorDistributionType),c.Ol&&(this.Ol=c.Ol),c.colorsSampling&&(this.colorsSampling=c.colorsSampling),c.colorMode&&(this.colorMode=c.colorMode),c.useColors&&(this.useColors=c.useColors),c.visibility&&(this.visibility=c.visibility),c.useDash&&(this.useDash=c.useDash),c.dashCount&&(this.dashCount=c.dashCount),c.dashRatio&&(this.dashRatio=c.dashRatio),c.dashOffset&&(this.dashOffset=c.dashOffset),c.width&&(this.width=c.width),c.sizeAttenuation&&(this.sizeAttenuation=c.sizeAttenuation),c.resolution&&(this.resolution=c.resolution),this.Ol?this.colorsTexture=il.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Ol,this.colorsSampling,a):il.PrepareEmptyColorsTexture(a),this.markAllDefinesAsDirty()}copyTo(l){var a;const N=l;null===(a=N.colorsTexture)||void 0===a||a.dispose(),this._colors&&(N.colorsTexture=il.CreateColorsTexture(`${N._material.name}-colors-texture`,this._colors,N.colorsSampling,this._scene)),N.setColor(this.color,!0),N.colorsDistributionType=this.colorsDistributionType,N.colorsSampling=this.colorsSampling,N.colorMode=this.colorMode,N.useColors=this.useColors,N.visibility=this.visibility,N.useDash=this.useDash,N.dashCount=this.dashCount,N.dashRatio=this.dashRatio,N.dashOffset=this.dashOffset,N.width=this.width,N.sizeAttenuation=this.sizeAttenuation,N.resolution=this.resolution,N.markAllDefinesAsDirty()}_isGLSL(l){return 0===l||this._forceGLSL}}Ql.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Ql.ForceGLSL=!1,(0,Il.g)(`BABYLON.${Ql.GREASED_LINE_MATERIAL_NAME}`,Ql);var jl=N(12870),fl=N(12274),pl=N(12671),Rl=N(12381);class Ll extends pl.ShaderMaterial{constructor(l,a,c){const K=a.getEngine(),Z=K.isWebGPU&&!(c.forceGLSL||Ll.ForceGLSL),w=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];a.useRightHandedSystem&&w.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const S=["position","grl_widths","grl_offsets","grl_colorPointers"];c.cameraFacing?(w.push("GREASED_LINE_CAMERA_FACING"),S.push("grl_previousAndSide","grl_nextAndCounters")):(S.push("grl_slopes"),S.push("grl_counters"));const T=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(Z||T.push("world","viewProjection","view","projection"),super(l,a,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:Z?["Scene","Mesh"]:void 0,attributes:S,uniforms:T,samplers:Z?[]:["grlColors"],defines:w,extraInitializationsAsync:async()=>{Z?await Promise.all([N.e(66).then(N.bind(N,15562)),N.e(75).then(N.bind(N,15570))]):await Promise.all([N.e(69).then(N.bind(N,15577)),N.e(76).then(N.bind(N,15580))])},shaderLanguage:Z?1:0}),this._color=B.Ca.White(),this._colorsDistributionType=0,this._colorsTexture=null,c=c||{color:tl.DEFAULT_COLOR},this.visibility=c.visibility??1,this.useDash=c.useDash??!1,this.dashRatio=c.dashRatio??.5,this.dashOffset=c.dashOffset??0,this.dashCount=c.dashCount??1,this.width=c.width?c.width:c.sizeAttenuation&&c.cameraFacing?tl.DEFAULT_WIDTH_ATTENUATED:tl.DEFAULT_WIDTH,this.sizeAttenuation=c.sizeAttenuation??!1,this.color=c.color??B.Ca.White(),this.useColors=c.useColors??!1,this.colorsDistributionType=c.colorDistributionType??0,this.colorsSampling=c.colorsSampling??q.d.NEAREST_NEAREST,this.colorMode=c.colorMode??0,this._colors=c.Ol??null,this._cameraFacing=c.cameraFacing??!0,this.resolution=c.resolution??new U.Vector2(K.getRenderWidth(),K.getRenderHeight()),c.colorsTexture?this.colorsTexture=c.colorsTexture:this._colors?this.colorsTexture=il.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,a):(this._color=this._color??tl.DEFAULT_COLOR,this.colorsTexture=il.PrepareEmptyColorsTexture(a)),Z){const l=new Rl.e;l.setParameters(),l.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",l)}K.Tc.add((()=>{il.DisposeEmptyColorsTexture()}))}dispose(){var l;null===(l=this._colorsTexture)||void 0===l||l.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new U.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Ol(){return this._colors}set Ol(l){this.setColors(l)}setColors(l){var a;let N=arguments.length>1&&void 0!==arguments[1]&&arguments[1],U=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const c=(null===(a=this._colors)||void 0===a?void 0:a.length)??0;var K;if(this._colors=l,null!==l&&0!==l.length){if(!N||U)if(this._colorsTexture&&c===l.length&&!U){const a=il.Color3toRGBAUint8(l);this._colorsTexture.update(a)}else{var Z;null===(Z=this._colorsTexture)||void 0===Z||Z.dispose(),this.colorsTexture=il.CreateColorsTexture(`${this.name}-colors-texture`,l,this.colorsSampling,this.bl())}}else null===(K=this._colorsTexture)||void 0===K||K.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(l){this._colorsTexture=l,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(l){this._width=l,this.setFloat("grlWidth",l)}get useColors(){return this._useColors}set useColors(l){this._useColors=l,this.setFloat("grlUseColors",il.BooleanToNumber(l))}get colorsSampling(){return this._colorsSampling}set colorsSampling(l){this._colorsSampling=l}get visibility(){return this._visibility}set visibility(l){this._visibility=l,this.setFloat("grlVisibility",l)}get useDash(){return this._useDash}set useDash(l){this._useDash=l,this.setFloat("grlUseDash",il.BooleanToNumber(l))}get dashOffset(){return this._dashOffset}set dashOffset(l){this._dashOffset=l,this.setFloat("grlDashOffset",l)}get dashRatio(){return this._dashRatio}set dashRatio(l){this._dashRatio=l,this.setFloat("grlDashRatio",l)}get dashCount(){return this._dashCount}set dashCount(l){this._dashCount=l,this._dashArray=1/l,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(l){this._sizeAttenuation=l,this.setFloat("grlSizeAttenuation",il.BooleanToNumber(l))}get color(){return this._color}set color(l){this.setColor(l)}setColor(l){l=l??tl.DEFAULT_COLOR,this._color=l,this.setColor3("grlColor",l)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(l){this._colorsDistributionType=l,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(l){this._colorMode=l,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(l){this._resolution=l,this.setVector2("grlResolution",l),this.setFloat("grlAspect",l.x/l.y)}serialize(){const l=super.serialize(),a={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(a.Ol=this._colors),l.greasedLineMaterialOptions=a,l}parse(l,a,N){var U;const c=l.greasedLineMaterialOptions;null===(U=this._colorsTexture)||void 0===U||U.dispose(),c.color&&(this.color=c.color),c.colorDistributionType&&(this.colorsDistributionType=c.colorDistributionType),c.colorsSampling&&(this.colorsSampling=c.colorsSampling),c.colorMode&&(this.colorMode=c.colorMode),c.useColors&&(this.useColors=c.useColors),c.visibility&&(this.visibility=c.visibility),c.useDash&&(this.useDash=c.useDash),c.dashCount&&(this.dashCount=c.dashCount),c.dashRatio&&(this.dashRatio=c.dashRatio),c.dashOffset&&(this.dashOffset=c.dashOffset),c.width&&(this.width=c.width),c.sizeAttenuation&&(this.sizeAttenuation=c.sizeAttenuation),c.resolution&&(this.resolution=c.resolution),c.Ol?this.colorsTexture=il.CreateColorsTexture(`${this.name}-colors-texture`,c.Ol,this.colorsSampling,this.bl()):this.colorsTexture=il.PrepareEmptyColorsTexture(a),this._cameraFacing=c.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var rl,Xl,Pl;Ll.ForceGLSL=!1,function(l){l[l.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",l[l.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(rl||(rl={})),function(l){l[l.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",l[l.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",l[l.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Xl||(Xl={})),function(l){l[l.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",l[l.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",l[l.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",l[l.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",l[l.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Pl||(Pl={}));class dl extends Cl.d{constructor(l,a,N){super(l,a,null,null,!1,!1),this.name=l,this._options=N,this._lazy=!1,this._updatable=!1,this._engine=a.getEngine(),this._lazy=N.lazy??!1,this._updatable=N.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=N.colorPointers??[],this._widths=N.widths??new Array(N.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(l){let a=0;for(const U of this._points)a+=U.length;const N=a/3*2-this._widths.length;for(let U=0;U<N;U++)this._widths.push(l)}updateLazy(){var l,a;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(l=this._options.ribbonOptions)||void 0===l?void 0:l.smoothShading),!this.Ql&&this.refreshBoundingInfo(),null===(a=this.greasedLineMaterial)||void 0===a||a.updateLazy()}addPoints(l,a){for(const N of l)this._points.push(N);this._lazy||this.setPoints(this._points,a)}dispose(l){let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(l,a)}isLazy(){return this._lazy}get hl(){return this._uvs}set hl(l){this._uvs=l instanceof Float32Array?l:new Float32Array(l),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(l){this.material instanceof Ll&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===l||void 0===l?void 0:l.length)>0),this._offsets=l,this._offsetsBuffer?this._offsetsBuffer.update(l):this._createOffsetsBuffer(l)}get widths(){return this._widths}set widths(l){this._widths=l,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(l)}get colorPointers(){return this._colorPointers}set colorPointers(l){this._colorPointers=l,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(l)}get greasedLineMaterial(){var l,a;if(this.material&&this.material instanceof Ll)return this.material;const N=null===(l=this.material)||void 0===l||null===(a=l.pluginManager)||void 0===a?void 0:a.getPlugin(Ql.GREASED_LINE_MATERIAL_NAME);return N||void 0}get points(){const l=[];return fl.b.DeepCopy(this._points,l),l}setPoints(l,a){this._points=il.ConvertPoints(l,(null===a||void 0===a?void 0:a.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==a&&void 0!==a&&a.colorPointers||this._updateColorPointers(),this._setPoints(this._points,a)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,hl:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(l){super.serialize(l),l.type=this.getClassName(),l.lineOptions=this._createLineOptions()}_createVertexBuffers(){let l=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=new jl.b;return a.Il=this._vertexPositions,a.indices=this._indices,a.hl=this._uvs,l&&(a.tl=[],jl.b.ComputeNormals(this._vertexPositions,this._indices,a.tl)),a.kl(this,this._options.updatable),a}_createOffsetsBuffer(l){const a=this._scene.getEngine(),N=new J.e(a,l,this._updatable,3);this.setVerticesBuffer(N.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=N}}class Fl{constructor(l,a){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=l,this.wasAddedByNoopNode=a}getIndicesAccessor(l,a,N,U,c){var K,Z,w,S;return null===(K=this._indicesAccessorMap.get(l))||void 0===K||null===(Z=K.get(a))||void 0===Z||null===(w=Z.get(N))||void 0===w||null===(S=w.get(U))||void 0===S?void 0:S.get(c)}setIndicesAccessor(l,a,N,U,c,K){let Z=this._indicesAccessorMap.get(l);Z||(Z=new Map,this._indicesAccessorMap.set(l,Z));let w=Z.get(a);w||(w=new Map,Z.set(a,w));let S=w.get(N);S||(S=new Map,w.set(N,S));let T=S.get(U);T||(T=new Map,S.set(U,T)),T.set(c,K)}pushExportedNode(l){this._exportedNodes.has(l)||this._exportedNodes.add(l)}getNodesSet(){return this._exportedNodes}getVertexBufferView(l){return this._vertexBufferViewMap.get(l)}setVertexBufferView(l,a){this._vertexBufferViewMap.set(l,a)}setRemappedBufferView(l,a,N){this._remappedBufferView.set(l,new Map),this._remappedBufferView.get(l).set(a,N)}getRemappedBufferView(l,a){var N;return null===(N=this._remappedBufferView.get(l))||void 0===N?void 0:N.get(a)}getVertexAccessor(l,a,N){var U,c;return null===(U=this._vertexAccessorMap.get(l))||void 0===U||null===(c=U.get(a))||void 0===c?void 0:c.get(N)}setVertexAccessor(l,a,N,U){let c=this._vertexAccessorMap.get(l);c||(c=new Map,this._vertexAccessorMap.set(l,c));let K=c.get(a);K||(K=new Map,c.set(a,K)),K.set(N,U)}hasVertexColorAlpha(l){return this._vertexMapColorAlpha.get(l)||!1}setHasVertexColorAlpha(l,a){return this._vertexMapColorAlpha.set(l,a)}getMesh(l){return this._meshMap.get(l)}setMesh(l,a){this._meshMap.set(l,a)}bindMorphDataToMesh(l,a){const N=this._meshMorphTargetMap.get(l)||[];this._meshMorphTargetMap.set(l,N),-1===N.indexOf(a)&&N.push(a)}getMorphTargetsFromMesh(l){return this._meshMorphTargetMap.get(l)}}class el{_ApplyExtension(l,a,N,U){if(N>=a.length)return Promise.resolve(l);const c=U(a[N],l);return c?c.then((async l=>l?await this._ApplyExtension(l,a,N+1,U):null)):this._ApplyExtension(l,a,N+1,U)}_ApplyExtensions(l,a){const N=[];for(const U of el._ExtensionNames)N.push(this._extensions[U]);return this._ApplyExtension(l,N,0,a)}_extensionsPreExportTextureAsync(l,a,N){return this._ApplyExtensions(a,((a,U)=>a.preExportTextureAsync&&a.preExportTextureAsync(l,U,N)))}_extensionsPostExportNodeAsync(l,a,N,U,c){return this._ApplyExtensions(a,((a,K)=>a.postExportNodeAsync&&a.postExportNodeAsync(l,K,N,U,c,this._bufferManager)))}_extensionsPostExportMaterialAsync(l,a,N){return this._ApplyExtensions(a,((a,U)=>a.postExportMaterialAsync&&a.postExportMaterialAsync(l,U,N)))}_extensionsPostExportMaterialAdditionalTextures(l,a,N){const U=[];for(const c of el._ExtensionNames){const K=this._extensions[c];K.postExportMaterialAdditionalTextures&&U.push(...K.postExportMaterialAdditionalTextures(l,a,N))}return U}_extensionsPostExportTextures(l,a,N){for(const U of el._ExtensionNames){const c=this._extensions[U];c.postExportTexture&&c.postExportTexture(l,a,N)}}_extensionsPostExportMeshPrimitive(l){for(const a of el._ExtensionNames){const N=this._extensions[a];N.postExportMeshPrimitive&&N.postExportMeshPrimitive(l,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const l of el._ExtensionNames){const a=this._extensions[l];a.preGenerateBinaryAsync&&await a.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(l){for(const a of el._ExtensionNames){const N=this._extensions[a];N.enabled&&l(N)}}_extensionsOnExporting(){this._forEachExtensions((l=>{var a,N,U;l.wasUsed&&((a=this._glTF).extensionsUsed||(a.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(l.name)&&this._glTF.extensionsUsed.push(l.name),l.required&&((N=this._glTF).extensionsRequired||(N.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(l.name)&&this._glTF.extensionsRequired.push(l.name)),(U=this._glTF).extensions||(U.extensions={}),l.onExporting&&l.onExporting())}))}_loadExtensions(){for(const l of el._ExtensionNames){const a=el._ExtensionFactories[l](this);this._extensions[l]=a}}constructor(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:W.e.LastCreatedScene,a=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${u.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new R(this),this._extensions={},this._bufferManager=new Jl,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!l)throw new Error("No scene available to export");this._babylonScene=l,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:l=>{var a;return null===l||void 0===l||null===(a=l.Hc)||void 0===a?void 0:a.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...a},this._loadExtensions()}dispose(){for(const l in this._extensions){this._extensions[l].dispose()}}get options(){return this._options}static RegisterExtension(l,a){el.UnregisterExtension(l)&&c.Tools.Warn(`Extension with the name ${l} already exists`),el._ExtensionFactories[l]=a,el._ExtensionNames.push(l)}static UnregisterExtension(l){if(!el._ExtensionFactories[l])return!1;delete el._ExtensionFactories[l];const a=el._ExtensionNames.indexOf(l);return-1!==a&&el._ExtensionNames.splice(a,1),!0}_generateJSON(l,a,N){const U={byteLength:l};return U.byteLength&&(this._glTF.buffers=[U]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Ba=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(U.uri=a+".bin"),N?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(l){const a=await this._generateBinaryAsync();this._extensionsOnExporting();const N=this._generateJSON(a.byteLength,l,!0),U=new Blob([a],{type:"application/octet-stream"}),c=l+".gltf",K=l+".bin",Z=new T;if(Z.files[c]=N,Z.files[K]=U,this._imageData)for(const w in this._imageData)Z.files[w]=new Blob([this._imageData[w].data],{type:this._imageData[w].mimeType});return Z}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(l){const a=l%4;return 0===a?a:4-a}async generateGLBAsync(l){this._shouldUseGlb=!0;const a=await this._generateBinaryAsync();this._extensionsOnExporting();const N=this._generateJSON(a.byteLength),U=l+".glb";let c,K=N.length;if("undefined"!==typeof TextEncoder){c=(new TextEncoder).encode(N),K=c.length}const Z=this._getPadding(K),w=this._getPadding(a.byteLength),S=28+K+Z+a.byteLength+w,J=new Sl(S);if(J.writeUInt32(1179937895),J.writeUInt32(2),J.writeUInt32(S),J.writeUInt32(K+Z),J.writeUInt32(1313821514),c)J.writeTypedArray(c);else{const l="_".charCodeAt(0);for(let a=0;a<K;++a){const U=N.charCodeAt(a);U!=N.codePointAt(a)?J.writeUInt8(l):J.writeUInt8(U)}}for(let T=0;T<Z;++T)J.writeUInt8(32);J.writeUInt32(a.byteLength+w),J.writeUInt32(5130562),J.writeTypedArray(a);for(let T=0;T<w;++T)J.writeUInt8(0);const n=new T;return n.files[U]=new Blob([J.getOutputData()],{type:"application/octet-stream"}),n}_setNodeTransformation(l,a,N){if(a.getPivotPoint().equalsWithEpsilon(d,P.d)||c.Tools.Warn("Pivot points are not supported in the glTF serializer"),!a.position.equalsWithEpsilon(d,P.d)){const c=U.TmpVectors.ua[0].K(a.position);N&&D(c),l.translation=c.Bc()}a.Oc.equalsWithEpsilon(e,P.d)||(l.scale=a.Oc.Bc());const K=a.rotationQuaternion||U.Quaternion.FromEulerAngles(a.rotation.x,a.rotation.y,a.rotation.z);K.equalsWithEpsilon(F,P.d)||(N&&v(K),l.rotation=K.normalize().Bc())}_setCameraTransformation(l,a,N){if(!a.position.equalsWithEpsilon(d,P.d)){const c=U.TmpVectors.ua[0].K(a.position);N&&D(c),l.translation=c.Bc()}const c=a.rotationQuaternion||U.Quaternion.FromEulerAngles(a.rotation.x,a.rotation.y,a.rotation.z);N&&v(c),this._babylonScene.useRightHandedSystem||g(c),c.equalsWithEpsilon(F,P.d)||(l.rotation=c.Bc())}_listAvailableCameras(){for(const l of this._babylonScene.cameras){const a={type:l.mode===yl.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(l.name&&(a.name=l.name),"perspective"===a.type)a.perspective={aspectRatio:l.getEngine().getAspectRatio(l),yfov:l.fovMode===yl.e.FOVMODE_VERTICAL_FIXED?l.fov:l.fov*l.getEngine().getAspectRatio(l),znear:l.Ac,zfar:l.maxZ};else if("orthographic"===a.type){const N=l.orthoLeft&&l.orthoRight?.5*(l.orthoRight-l.orthoLeft):.5*l.getEngine().getRenderWidth(),U=l.orthoBottom&&l.orthoTop?.5*(l.orthoTop-l.orthoBottom):.5*l.getEngine().getRenderHeight();a.orthographic={xmag:N,ymag:U,znear:l.Ac,zfar:l.maxZ}}this._camerasMap.set(l,a)}}_exportAndAssignCameras(){const l=Array.from(this._camerasMap.values());for(const a of l){const l=this._nodesCameraMap.get(a);if(void 0!==l){this._cameras.push(a);for(const a of l)a.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const l of this._babylonScene.skeletons){if(l.bones.length<=0)continue;const a={joints:[]};this._skinMap.set(l,a)}}_exportAndAssignSkeletons(){for(const l of this._babylonScene.skeletons){if(l.bones.length<=0)continue;const a=this._skinMap.get(l);if(void 0==a)continue;const N={},U=[];let K=-1;for(let c=0;c<l.bones.length;++c){const a=l.bones[c],U=a.getIndex()??c;-1!==U&&(N[U]=a,U>K&&(K=U))}for(let l=0;l<=K;++l){const K=N[l];U.push(K.getAbsoluteInverseBindMatrix());const Z=K.getTransformNode();if(null!==Z){const l=this._nodeMap.get(Z);Z&&null!==l&&void 0!==l?a.joints.push(l):c.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else c.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const Z=this._nodesSkinMap.get(a);if(a.joints.length>0&&void 0!==Z){const l=64*U.length,N=new Float32Array(l/4);U.forEach(((l,a)=>{N.set(l.m,16*a)}));const c=this._bufferManager.createBufferView(N);this._accessors.push(this._bufferManager.createAccessor(c,"MAT4",5126,U.length)),a.inverseBindMatrices=this._accessors.length-1,this._skins.push(a);for(const a of Z)a.skin=this._skins.length-1}}}async _exportSceneAsync(){const l={nodes:[]};if(this._babylonScene.metadata){const a=this._options.metadataSelector(this._babylonScene.metadata);a&&(l.extras=a)}const a=new Array,N=new Array,U=new Array;for(const w of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Zl(w,this._babylonScene.useRightHandedSystem)?U.push(...w.getChildren()):this._babylonScene.useRightHandedSystem?a.push(w):N.push(w);this._listAvailableCameras(),this._listAvailableSkeletons();const c=new Fl(!0,!1);l.nodes.push(...await this._exportNodesAsync(N,c));const K=new Fl(!1,!1);l.nodes.push(...await this._exportNodesAsync(a,K));const Z=new Fl(!1,!0);l.nodes.push(...await this._exportNodesAsync(U,Z)),l.nodes.length&&this._scenes.push(l),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Al._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,c.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(l){let a=this._shouldExportNodeMap.get(l);return void 0===a&&(a=this._options.shouldExportNode(l),this._shouldExportNodeMap.set(l,a)),a}async _exportNodesAsync(l,a){const N=new Array;this._exportBuffers(l,a);for(const U of l)await this._exportNodeAsync(U,N,a);return N}_collectBuffers(l,a,N,U,c){if(this._shouldExportNode(l)&&l instanceof y.b&&l.bc){const K=l.bc.getVertexBuffers();if(K)for(const U in K){if(!ml(U))continue;const Z=K[U];c.setHasVertexColorAlpha(Z,l.hasVertexAlpha);const w=Z._buffer,S=a.get(w)||[];a.set(w,S),-1===S.indexOf(Z)&&S.push(Z);const T=N.get(Z)||[];N.set(Z,T),-1===T.indexOf(l)&&T.push(l)}const Z=l.morphTargetManager;if(Z)for(let a=0;a<Z.numTargets;a++){const N=Z.getTarget(a),c=U.get(N)||[];U.set(N,c),-1===c.indexOf(l)&&c.push(l)}}for(const K of l.getChildren())this._collectBuffers(K,a,N,U,c)}_exportBuffers(l,a){const N=new Map,U=new Map,c=new Map;for(const w of l)this._collectBuffers(w,N,U,c,a);const K=Array.from(N.keys());for(const w of K){const l=w.getData();if(!l)throw new Error("Buffer data is not available");const c=N.get(w);if(!c)continue;const K=c[0].byteStride;if(c.some((l=>l.byteStride!==K)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const Z=Nl(l).slice();for(const a of c){const l=U.get(a),{byteOffset:N,byteStride:c,componentCount:K,type:w,count:S,normalized:T,kind:n}=o(a,l);switch(n){case J.h.NormalKind:case J.h.TangentKind:(0,L.i)(Z,N,c,K,w,S,T,(l=>{const a=Math.sqrt(l[0]*l[0]+l[1]*l[1]+l[2]*l[2]);if(a>0){const N=1/a;l[0]*=N,l[1]*=N,l[2]*=N}}));break;case J.h.ColorKind:{const a=l.filter((l=>l.material instanceof Wl.Ya||null==l.material)).length;if(0==a)break;if(a!=l.length){r.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}w==J.h.UNSIGNED_BYTE&&r.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const U=new B.Ca,n=new B.Qc,y=this._babylonScene.getEngine().useExactSrgbConversions;(0,L.i)(Z,N,c,K,w,S,T,(l=>{3===l.length?(U.yN(l,0),U.toLinearSpaceToRef(U,y),U.toArray(l,0)):(n.yN(l,0),n.toLinearSpaceToRef(n,y),n.toArray(l,0))}))}}}if(a.convertToRightHanded){for(const l of c){const a=U.get(l),{byteOffset:N,byteStride:c,componentCount:K,type:w,count:S,normalized:T,kind:n}=o(l,a);switch(n){case J.h.PositionKind:case J.h.NormalKind:case J.h.TangentKind:(0,L.i)(Z,N,c,K,w,S,T,(l=>{l[0]=-l[0]}))}}a.convertedToRightHandedBuffers.set(w,Z)}const S=this._bufferManager.createBufferView(Z,K);a.setVertexBufferView(w,S);const T=new Map;for(const a of c){const l=U.get(a),{kind:N,totalVertices:c}=o(a,l);switch(N){case J.h.MatricesIndicesKind:case J.h.MatricesIndicesExtraKind:if(a.type==J.h.FLOAT){const l=a.getFloatData(c);null!==l&&T.set(a,l)}}}0!==T.size&&r.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const n=Array.from(T.keys());for(const N of n){const l=T.get(N);if(!l)continue;const U=l.some((l=>l>=256)),c=new(U?Uint16Array:Uint8Array)(l.length);for(let a=0;a<l.length;a++)c[a]=l[a];const K=this._bufferManager.createBufferView(c,4*(U?2:1));a.setRemappedBufferView(w,N,K)}}const Z=Array.from(c.keys());for(const w of Z){const l=c.get(w);if(!l)continue;const N=El(w,l[0],this._bufferManager,this._bufferViews,this._accessors,a.convertToRightHanded);for(const U of l)a.bindMorphDataToMesh(U,N)}}async _exportNodeAsync(l,a,N){let U=this._nodeMap.get(l);if(void 0!==U)return void(a.includes(U)||a.push(U));const c=await this._createNodeAsync(l,N);if(c){U=this._nodes.length,this._nodes.push(c),this._nodeMap.set(l,U),N.pushExportedNode(l),a.push(U);const K={name:"runtime animations",channels:[],samplers:[]},Z=[];this._babylonScene.animationGroups.length||(Al._CreateMorphTargetAnimationFromMorphTargetAnimations(l,K,Z,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,N.convertToRightHanded,this._options.shouldExportAnimation),l.animations.length&&Al._CreateNodeAnimationFromNodeAnimations(l,K,Z,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,N.convertToRightHanded,this._options.shouldExportAnimation)),K.channels.length&&K.samplers.length&&this._animations.push(K),Z.forEach((l=>{l.channels.length&&l.samplers.length&&this._animations.push(l)}))}const K=c?[]:a;for(const Z of l.getChildren())await this._exportNodeAsync(Z,K,N);c&&K.length&&(c.children=K)}async _createNodeAsync(l,a){if(!this._shouldExportNode(l))return null;const N={};if(l.name&&(N.name=l.name),l.metadata){const a=this._options.metadataSelector(l.metadata);a&&(N.extras=a)}if(l instanceof n.e&&(this._setNodeTransformation(N,l,a.convertToRightHanded),l instanceof y.b)){const c=l instanceof H.d?l.sourceMesh:l;if(c.Wc&&c.Wc.length>0&&(N.mesh=await this._exportMeshAsync(c,a)),l.skeleton){const a=this._skinMap.get(l.skeleton);var U;if(void 0!==a)void 0===this._nodesSkinMap.get(a)&&this._nodesSkinMap.set(a,[]),null===(U=this._nodesSkinMap.get(a))||void 0===U||U.push(N)}}if(l instanceof X.d){const U=this._camerasMap.get(l);if(U){var c;void 0===this._nodesCameraMap.get(U)&&this._nodesCameraMap.set(U,[]),this._setCameraTransformation(N,l,a.convertToRightHanded);const Z=l.parent;if(null!==Z&&al(l,Z)){const l=this._nodeMap.get(Z);if(void 0!==l){var K;const a=this._nodes[l];return ll(N,a),null===(K=this._nodesCameraMap.get(U))||void 0===K||K.push(a),null}}null===(c=this._nodesCameraMap.get(U))||void 0===c||c.push(N)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",N,l,this._nodeMap,a.convertToRightHanded)?N:(r.b.Warn(`Not exporting node ${l.name}`),null)}_exportIndices(l,a,N,U,c,Z,w,S,T){let J=l;T.mode=x(Z);const n=w!==K.c.CounterClockWiseSideOrientation,y=!S.wasAddedByNoopNode&&n,H=function(l){switch(l){case K.c.TriangleFillMode:case K.c.TriangleStripDrawMode:case K.c.TriangleFanDrawMode:return!0}return!1}(Z)&&y;if(H){if(Z===K.c.TriangleStripDrawMode||Z===K.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");T.mode=x(Z);const w=a?new Uint32Array(U):new Uint16Array(U);if(l)for(let a=0;a+2<U;a+=3)w[a]=l[N+a]+c,w[a+1]=l[N+a+2]+c,w[a+2]=l[N+a+1]+c;else for(let l=0;l+2<U;l+=3)w[l]=l,w[l+1]=l+2,w[l+2]=l+1;J=w}else if(l&&0!==c){const K=a?new Uint32Array(U):new Uint16Array(U);for(let a=0;a<U;a++)K[a]=l[N+a]+c;J=K}if(J){let K=S.getIndicesAccessor(l,N,U,c,H);if(void 0===K){const Z=function(l,a,N,U){if(l instanceof Uint16Array||l instanceof Uint32Array)return l;if(l instanceof Int32Array)return new Uint32Array(l.buffer,l.byteOffset,l.length);const c=l.slice(a,a+N);return U?new Uint32Array(c):new Uint16Array(c)}(J,0,U,a),w=this._bufferManager.createBufferView(Z),T=a?5125:5123;this._accessors.push(this._bufferManager.createAccessor(w,"SCALAR",T,U,0)),K=this._accessors.length-1,S.setIndicesAccessor(l,N,U,c,H,K)}T.indices=K}}_exportVertexBuffer(l,a,N,U,c,K){const Z=l.getKind();if(!ml(Z))return;if(Z.startsWith("uv")&&!this._options.exportUnusedUVs&&(!a||!this._materialNeedsUVsSet.has(a)))return;let w=c.getVertexAccessor(l,N,U);if(void 0===w){const a=c.convertedToRightHandedBuffers.get(l._buffer)||l._buffer.getData(),K=Z===J.h.PositionKind?function(l,a,N,U){const{byteOffset:c,byteStride:K,type:Z,normalized:w}=a,S=a.getSize(),T=new Array(S).fill(1/0),J=new Array(S).fill(-1/0);return(0,L.i)(l,c+N*K,K,S,Z,U*S,w,(l=>{for(let a=0;a<S;a++)T[a]=Math.min(T[a],l[a]),J[a]=Math.max(J[a],l[a])})),{min:T,max:J}}(a,l,N,U):void 0,S=(Z===J.h.MatricesIndicesKind||Z===J.h.MatricesIndicesExtraKind)&&l.type===J.h.FLOAT,T=S?J.h.UNSIGNED_BYTE:l.type,n=S?void 0:l.normalized,y=S?c.getRemappedBufferView(l._buffer,l):c.getVertexBufferView(l._buffer),H=l.byteOffset+N*l.byteStride;this._accessors.push(this._bufferManager.createAccessor(y,function(l,a){if(l==J.h.ColorKind)return a?"VEC4":"VEC3";switch(l){case J.h.PositionKind:case J.h.NormalKind:return"VEC3";case J.h.TangentKind:case J.h.MatricesIndicesKind:case J.h.MatricesIndicesExtraKind:case J.h.MatricesWeightsKind:case J.h.MatricesWeightsExtraKind:return"VEC4";case J.h.UVKind:case J.h.UV2Kind:case J.h.UV3Kind:case J.h.UV4Kind:case J.h.UV5Kind:case J.h.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${l}`)}(Z,c.hasVertexColorAlpha(l)),T,U,H,K,n)),w=this._accessors.length-1,c.setVertexAccessor(l,N,U,w)}K.attributes[function(l){switch(l){case J.h.PositionKind:return"POSITION";case J.h.NormalKind:return"NORMAL";case J.h.TangentKind:return"TANGENT";case J.h.ColorKind:return"COLOR_0";case J.h.UVKind:return"TEXCOORD_0";case J.h.UV2Kind:return"TEXCOORD_1";case J.h.UV3Kind:return"TEXCOORD_2";case J.h.UV4Kind:return"TEXCOORD_3";case J.h.UV5Kind:return"TEXCOORD_4";case J.h.UV6Kind:return"TEXCOORD_5";case J.h.MatricesIndicesKind:return"JOINTS_0";case J.h.MatricesIndicesExtraKind:return"JOINTS_1";case J.h.MatricesWeightsKind:return"WEIGHTS_0";case J.h.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${l}`)}(Z)]=w}async _exportMaterialAsync(l,a,N,U){let c=this._materialMap.get(l);if(void 0===c){const U=a&&Object.keys(a).some((l=>l.startsWith("uv")));if((l=l instanceof Hl.e?l.jc[N.materialIndex]:l)instanceof ul.b)c=await this._materialExporter.exportPBRMaterialAsync(l,"image/png",U);else{if(!(l instanceof Wl.Ya))return void r.b.Warn(`Unsupported material '${l.name}' with type ${l.getClassName()}`);c=await this._materialExporter.exportStandardMaterialAsync(l,"image/png",U)}this._materialMap.set(l,c)}U.material=c}async _exportMeshAsync(l,a){var N;let U=a.getMesh(l);if(void 0!==U)return U;const c={primitives:[]};U=this._meshes.length,this._meshes.push(c),a.setMesh(l,U);const Z=l.isUnIndexed?null:l.zc(),w=null===(N=l.bc)||void 0===N?void 0:N.getVertexBuffers(),S=a.getMorphTargetsFromMesh(l),T=l instanceof ql.e,J=l instanceof dl,n=l.Wc;if(w&&n&&n.length>0)for(const u of n){const N={attributes:{}},U=u.Rl()||this._babylonScene.defaultMaterial;if(J){var y,H;const a={name:U.name},c=l,K=B.Ca.White(),Z=(null===(y=c.material)||void 0===y?void 0:y.alpha)??1,w=(null===(H=c.greasedLineMaterial)||void 0===H?void 0:H.color)??K;(!w.equalsWithEpsilon(K,P.d)||Z<1)&&(a.pbrMetallicRoughness={baseColorFactor:[...w.Bc(),Z]}),this._materials.push(a),N.material=this._materials.length-1}else if(T){const a={name:U.name},c=l;(!c.color.equalsWithEpsilon(B.Ca.White(),P.d)||c.alpha<1)&&(a.pbrMetallicRoughness={baseColorFactor:[...c.color.Bc(),c.alpha]}),this._materials.push(a),N.material=this._materials.length-1}else await this._exportMaterialAsync(U,w,u,N);const n=T||J?K.c.LineListDrawMode:l.overrideRenderingFillMode??U.fillMode,W=U._getEffectiveOrientation(l);this._exportIndices(Z,Z?(0,L.b)(Z,u.indexCount,u.indexStart,u.verticesStart):u.verticesCount>65535,Z?u.indexStart:u.verticesStart,Z?u.indexCount:u.verticesCount,-u.verticesStart,n,W,a,N);for(const l of Object.values(w))this._exportVertexBuffer(l,U,u.verticesStart,u.verticesCount,a,N);if(S){N.targets=[];for(const l of S)N.targets.push(l.attributes)}c.primitives.push(N),this._extensionsPostExportMeshPrimitive(N)}if(S){c.weights=[],c.extras||(c.extras={}),c.extras.targetNames=[];for(const l of S)c.weights.push(l.influence),c.extras.targetNames.push(l.name)}return U}}el._ExtensionNames=new Array,el._ExtensionFactories={};class sl{static async GLTFAsync(l,a,N){N&&N.exportWithoutWaitingForScene||await l.whenReadyAsync();const U=new el(l,N),c=await U.generateGLTFAsync(a.replace(/\.[^/.]+$/,""));return U.dispose(),c}static async GLBAsync(l,a,N){N&&N.exportWithoutWaitingForScene||await l.whenReadyAsync();const U=new el(l,N),c=await U.generateGLBAsync(a.replace(/\.[^/.]+$/,""));return U.dispose(),c}}N(12983);const ol="EXT_mesh_gpu_instancing";class Gl{constructor(l){this.name=ol,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=l}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(l,a,N,c,K,Z){return await new Promise((l=>{if(a&&N instanceof Cl.d&&N.hasThinInstances&&this._exporter){this._wasUsed=!0;const l=U.ua.Zero(),c=U.Quaternion.Identity(),w=U.ua.One(),S=N.thinInstanceGetWorldMatrices(),T=U.TmpVectors.ua[2],J=U.TmpVectors.Quaternion[1],n=U.TmpVectors.ua[3];let y=!1,H=!1,u=!1;const W=new Float32Array(3*N.fc),B=new Float32Array(4*N.fc),Y=new Float32Array(3*N.fc);let C=0;for(const a of S)a.decompose(n,J,T),K&&(D(T),v(J)),W.set(T.Bc(),3*C),B.set(J.normalize().Bc(),4*C),Y.set(n.Bc(),3*C),y=y||!T.equalsWithEpsilon(l),H=H||!J.equalsWithEpsilon(c),u=u||!n.equalsWithEpsilon(w),C++;const M={attributes:{}};y&&(M.attributes.TRANSLATION=this._buildAccessor(W,"VEC3",N.fc,Z)),H&&(M.attributes.ROTATION=this._buildAccessor(B,"VEC4",N.fc,Z)),u&&(M.attributes.SCALE=this._buildAccessor(Y,"VEC3",N.fc,Z)),a.extensions=a.extensions||{},a.extensions[ol]=M}l(a)}))}_buildAccessor(l,a,N,U){const c=U.createBufferView(l),K=U.createAccessor(c,a,5126,N);return this._exporter._accessors.push(K),this._exporter._accessors.length-1}}el.RegisterExtension(ol,(l=>new Gl(l)));var ma=N(12986),xl=N(13004),Vl=N(13009),Dl=N(13012);function vl(l){return l===Vl.e.PositionKind?"POSITION":l===Vl.e.NormalKind?"NORMAL":l===Vl.e.ColorKind?"COLOR":l.startsWith(Vl.e.UVKind)?"TEX_COORD":"GENERIC"}const gl={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class la extends ma.b{static get DefaultAvailable(){return(0,ma.f)(la.DefaultConfiguration)}static get Default(){return la._Default??(la._Default=new la),la._Default}static ResetDefault(l){la._Default&&(l||la._Default.dispose(),la._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(l,a){return{module:await(a||DracoEncoderModule)({wasmBinary:l})}}_getWorkerContent(){return`${xl.k}(${xl.m})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:la.DefaultConfiguration)}async _encodeAsync(l,a,N){const U=N?(0,Dl.e)(gl,N):gl;if(this._workerPoolPromise){const N=await this._workerPoolPromise;return await new Promise(((c,K)=>{N.push(((N,Z)=>{const w=l=>{N.removeEventListener("error",w),N.removeEventListener("message",S),K(l),Z()},S=l=>{"encodeMeshDone"===l.data.id&&(N.removeEventListener("error",w),N.removeEventListener("message",S),c(l.data.encodedMeshData),Z())};N.addEventListener("error",w),N.addEventListener("message",S);const T=[];for(const a of l)T.push(a.data.buffer);a&&T.push(a.buffer),N.postMessage({id:"encodeMesh",attributes:l,indices:a,options:U},T)}))}))}if(this._modulePromise){const N=await this._modulePromise;return(0,xl.k)(N.module,l,a,U)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(l,a){if(0==l.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");l instanceof Cl.d&&l.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===a||void 0===a?void 0:a.method)&&(r.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),a.method="MESH_SEQUENTIAL_ENCODING");const N=function(l){let a=l.zc(void 0,!0);return!a||a instanceof Uint32Array||a instanceof Uint16Array||(a=((0,L.b)(a,a.length)?Uint32Array:Uint16Array).from(a)),a}(l),U=function(l,a){const N=[];for(const U of l.getVerticesDataKinds()){if(null!==a&&void 0!==a&&a.includes(U)){if(U===Vl.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const c=l.getVertexBuffer(U),K=c.getSize(),Z=(0,L.v)(c.getData(),K,c.type,c.byteOffset,c.byteStride,c.normalized,l.getTotalVertices(),!0);N.push({kind:U,dracoName:vl(U),size:K,data:Z})}return N}(l,null===a||void 0===a?void 0:a.excludedAttributes);return await this._encodeAsync(U,N,a)}}la.DefaultConfiguration={wasmUrl:`${c.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${c.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${c.Tools._DefaultCdnUrl}/draco_encoder.js`},la._Default=null;const aa="KHR_draco_mesh_compression";class Na{get wasUsed(){return this._wasUsed}constructor(l){this.name=aa,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===l.options.meshCompressionMethod&&la.DefaultAvailable}dispose(){}postExportMeshPrimitive(l,a,N){if(!this.enabled)return;if(4!==l.mode&&5!==l.mode)return void r.b.Warn("Cannot compress primitive with mode "+l.mode+".");const U=[],c=[];let K=null;if(void 0!==l.indices){const Z=N[l.indices],w=a.getBufferView(Z);K=a.getData(w).slice(),U.push(w),c.push(Z)}const Z=[];for(const[J,n]of Object.entries(l.attributes)){const l=N[n],K=a.getBufferView(l),S=G(l.type),T=(0,L.v)(a.getData(K),S,l.componentType,l.byteOffset||0,K.byteStride||(0,L.n)(l.componentType)*S,l.normalized||!1,l.count,!0);Z.push({kind:J,dracoName:(w=J,"POSITION"===w?"POSITION":"NORMAL"===w?"NORMAL":w.startsWith("COLOR")?"COLOR":w.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:G(l.type),data:T}),U.push(K),c.push(l)}var w;const S={method:l.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},T=la.Default._encodeAsync(Z,K,S).then((N=>{if(!N)return void r.b.Error("Draco encoding failed for primitive.");const K={bufferView:-1,attributes:N.attributeIds},Z=a.createBufferView(N.data);a.setBufferView(K,Z);for(const l of U)this._bufferViewsUsed.add(l);for(const l of c)this._accessorsUsed.add(l);l.extensions||(l.extensions={}),l.extensions[aa]=K})).catch((l=>{r.b.Error("Draco encoding failed for primitive: "+l)}));this._encodePromises.push(T),this._wasUsed=!0}async preGenerateBinaryAsync(l){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((a=>{l.getPropertiesWithBufferView(a).every((l=>this._accessorsUsed.has(l)))&&l.removeBufferView(a)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}el.RegisterExtension(aa,(l=>new Na(l)));var Ua=N(13016);const ca="KHR_lights_punctual",Ka={name:"",color:[1,1,1],Rc:1,range:Number.MAX_VALUE},Za={innerConeAngle:0,outerConeAngle:Math.PI/4},wa=U.ua.Backward();class Sa{constructor(l){this.name=ca,this.enabled=!0,this.required=!1,this._exporter=l}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[ca]=this._lights}async postExportNodeAsync(l,a,N,c,K){return await new Promise((Z=>{if(!(N instanceof Ml.c))return void Z(a);const w=N.getTypeID()==Ml.c.LIGHTTYPEID_POINTLIGHT?"point":N.getTypeID()==Ml.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":N.getTypeID()==Ml.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!w||!(N instanceof Ua.b))return r.b.Warn(`${l}: Light ${N.name} is not supported in ${ca}`),void Z(a);if(N.falloffType!==Ml.c.FALLOFF_GLTF&&r.b.Warn(`${l}: Light falloff for ${N.name} does not match the ${ca} specification!`),!N.position.equalsToFloats(0,0,0)){const l=U.TmpVectors.ua[0].K(N.position);K&&D(l),a.translation=l.Bc()}if("point"!==w){const l=N.direction.normalizeToRef(U.TmpVectors.ua[0]);K&&D(l);const c=U.Quaternion.FromUnitVectorsToRef(wa,l,U.TmpVectors.Quaternion[0]);U.Quaternion.IsIdentity(c)||(a.rotation=c.Bc())}const S={type:w,name:N.name,color:N.Lc.Bc(),Rc:N.Rc,range:N.range};if(Ul(S,Ka),"spot"===w){const l=N;S.spot={innerConeAngle:l.innerAngle/2,outerConeAngle:l.angle/2},Ul(S.spot,Za)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(S);const T={cc:this._lights.lights.length-1},J=N.parent;if(J&&al(N,J)){const l=c.get(J);if(l){const N=this._exporter._nodes[l];return ll(a,N),N.extensions||(N.extensions={}),N.extensions[ca]=T,void Z(null)}}a.extensions||(a.extensions={}),a.extensions[ca]=T,Z(a)}))}}el.RegisterExtension(ca,(l=>new Sa(l)));var Ta=N(12934);const Ja="KHR_materials_anisotropy";class na{constructor(l){this.name=Ja,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=l}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(l,a,N){const U=[];return N instanceof Ta.b&&N.anisotropy.isEnabled&&!N.anisotropy.legacy?(N.anisotropy.texture&&U.push(N.anisotropy.texture),U):[]}postExportMaterialAsync(l,a,N){return new Promise((l=>{if(N instanceof Ta.b){if(!N.anisotropy.isEnabled||N.anisotropy.legacy)return void l(a);this._wasUsed=!0,a.extensions=a.extensions||{};const U=this._exporter._materialExporter.getTextureInfo(N.anisotropy.texture),c={anisotropyStrength:N.anisotropy.Rc,anisotropyRotation:N.anisotropy.angle,anisotropyTexture:U??void 0};null!==c.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(N),a.extensions[Ja]=c}l(a)}))}}el.RegisterExtension(Ja,(l=>new na(l)));const ya="KHR_materials_clearcoat";class Ha{constructor(l){this.name=ya,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=l}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(l,a,N){const U=[];return N instanceof Ta.b&&N.clearCoat.isEnabled?(N.clearCoat.texture&&U.push(N.clearCoat.texture),!N.clearCoat.useRoughnessFromMainTexture&&N.clearCoat.textureRoughness&&U.push(N.clearCoat.textureRoughness),N.clearCoat.bumpTexture&&U.push(N.clearCoat.bumpTexture),U):[]}postExportMaterialAsync(l,a,N){return new Promise((l=>{if(N instanceof Ta.b){if(!N.clearCoat.isEnabled)return void l(a);this._wasUsed=!0,a.extensions=a.extensions||{};const U=this._exporter._materialExporter.getTextureInfo(N.clearCoat.texture);let K;K=N.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(N.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(N.clearCoat.textureRoughness),N.clearCoat.isTintEnabled&&c.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${N.name}`),N.clearCoat.remapF0OnInterfaceChange&&c.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${N.name}`);const Z=this._exporter._materialExporter.getTextureInfo(N.clearCoat.bumpTexture),w={clearcoatFactor:N.clearCoat.Rc,clearcoatTexture:U??void 0,clearcoatRoughnessFactor:N.clearCoat.roughness,clearcoatRoughnessTexture:K??void 0,clearcoatNormalTexture:Z??void 0};null===w.clearcoatTexture&&null===w.clearcoatRoughnessTexture&&null===w.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(N),a.extensions[ya]=w}l(a)}))}}el.RegisterExtension(ya,(l=>new Ha(l)));const ua="KHR_materials_diffuse_transmission";function Wa(l,a){const N=a.subSurface;let U=null;return N.translucencyIntensityTexture?U=N.translucencyIntensityTexture:N.thicknessTexture&&N.useMaskFromThicknessTexture&&(U=N.thicknessTexture),U&&!N.useGltfStyleTextures?(r.b.Warn(`${l}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${a.name}`,1),null):U}class Ba{constructor(l){this.name=ua,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=l}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(l,a,N){const U=[];if(N instanceof ul.b&&this._isExtensionEnabled(N)){const a=Wa(l,N);return a&&U.push(a),N.subSurface.translucencyColorTexture&&U.push(N.subSurface.translucencyColorTexture),U}return U}_isExtensionEnabled(l){if(l.unlit)return!1;const a=l.subSurface;return!!a.isTranslucencyEnabled&&(!l.unlit&&!a.useAlbedoToTintTranslucency&&a.useGltfStyleTextures&&1===a.volumeIndexOfRefraction&&0===a.minimumThickness&&0===a.maximumThickness)}postExportMaterialAsync(l,a,N){return new Promise((U=>{if(N instanceof ul.b&&this._isExtensionEnabled(N)){this._wasUsed=!0;const U=N.subSurface,c=Wa(l,N),K=0==U.translucencyIntensity?void 0:U.translucencyIntensity,Z=this._exporter._materialExporter.getTextureInfo(c)??void 0,w=!U.translucencyColor||U.translucencyColor.equalsFloats(1,1,1)?void 0:U.translucencyColor.Bc(),S=this._exporter._materialExporter.getTextureInfo(U.translucencyColorTexture)??void 0,T={diffuseTransmissionFactor:K,diffuseTransmissionTexture:Z,diffuseTransmissionColorFactor:w,diffuseTransmissionColorTexture:S};(Z||S)&&this._exporter._materialNeedsUVsSet.add(N),a.extensions=a.extensions||{},a.extensions[ua]=T}U(a)}))}}el.RegisterExtension(ua,(l=>new Ba(l)));const Ya="KHR_materials_dispersion";class Ca{constructor(){this.name=Ya,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(l){if(l.unlit)return!1;const a=l.subSurface;return!(!a.isRefractionEnabled&&!a.isDispersionEnabled)}postExportMaterialAsync(l,a,N){return new Promise((l=>{if(N instanceof ul.b&&this._isExtensionEnabled(N)){this._wasUsed=!0;const l={dispersion:N.subSurface.dispersion};a.extensions=a.extensions||{},a.extensions[Ya]=l}l(a)}))}}el.RegisterExtension(Ya,(()=>new Ca));const Ma="KHR_materials_emissive_strength";class Aa{constructor(){this.name=Ma,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(l,a,N){return await new Promise((l=>{if(!(N instanceof ul.b))return l(a);const U=N.emissiveColor.Bc(),c=Math.max(...U);if(c>1){this._wasUsed=!0,a.extensions||(a.extensions={});const l={emissiveStrength:c},U=N.emissiveColor.scale(1/l.emissiveStrength);a.emissiveFactor=U.Bc(),a.extensions[Ma]=l}return l(a)}))}}el.RegisterExtension(Ma,(l=>new Aa));const Ea="KHR_materials_ior";class qa{constructor(){this.name=Ea,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(l){return!l.unlit&&(void 0!=l.indexOfRefraction&&1.5!=l.indexOfRefraction)}postExportMaterialAsync(l,a,N){return new Promise((l=>{if(N instanceof ul.b&&this._isExtensionEnabled(N)){this._wasUsed=!0;const l={ior:N.indexOfRefraction};a.extensions=a.extensions||{},a.extensions[Ea]=l}l(a)}))}}el.RegisterExtension(Ea,(l=>new qa));const ba="KHR_materials_iridescence";class za{constructor(l){this.name=ba,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=l}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(l,a,N){const U=[];return N instanceof Ta.b&&N.iridescence.isEnabled?(N.iridescence.texture&&U.push(N.iridescence.texture),N.iridescence.thicknessTexture&&N.iridescence.thicknessTexture!==N.iridescence.texture&&U.push(N.iridescence.thicknessTexture),U):[]}postExportMaterialAsync(l,a,N){return new Promise((l=>{if(N instanceof Ta.b){if(!N.iridescence.isEnabled)return void l(a);this._wasUsed=!0,a.extensions=a.extensions||{};const U=this._exporter._materialExporter.getTextureInfo(N.iridescence.texture),c=this._exporter._materialExporter.getTextureInfo(N.iridescence.thicknessTexture),K={iridescenceFactor:N.iridescence.Rc,iridescenceIor:N.iridescence.indexOfRefraction,iridescenceThicknessMinimum:N.iridescence.minimumThickness,iridescenceThicknessMaximum:N.iridescence.maximumThickness,iridescenceTexture:U??void 0,iridescenceThicknessTexture:c??void 0};null===K.iridescenceTexture&&null===K.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(N),a.extensions[ba]=K}l(a)}))}}el.RegisterExtension(ba,(l=>new za(l)));const Ia="KHR_materials_sheen";class ta{constructor(l){this.name=Ia,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=l}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(l,a,N){return N instanceof ul.b&&N.sheen.isEnabled&&N.sheen.texture?[N.sheen.texture]:[]}async postExportMaterialAsync(l,a,N){return await new Promise((l=>{if(N instanceof ul.b){if(!N.sheen.isEnabled)return void l(a);this._wasUsed=!0,null==a.extensions&&(a.extensions={});const U={sheenColorFactor:N.sheen.color.Bc(),sheenRoughnessFactor:N.sheen.roughness??0};null===U.sheenColorTexture&&null===U.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(N),N.sheen.texture&&(U.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(N.sheen.texture)??void 0),N.sheen.textureRoughness&&!N.sheen.useRoughnessFromMainTexture?U.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(N.sheen.textureRoughness)??void 0:N.sheen.texture&&N.sheen.useRoughnessFromMainTexture&&(U.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(N.sheen.texture)??void 0),a.extensions[Ia]=U}l(a)}))}}el.RegisterExtension(Ia,(l=>new ta(l)));const Oa="KHR_materials_specular";class ha{constructor(l){this.name=Oa,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=l}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(l,a,N){const U=[];return N instanceof ul.b&&this._isExtensionEnabled(N)?(N.metallicReflectanceTexture&&U.push(N.metallicReflectanceTexture),N.reflectanceTexture&&U.push(N.reflectanceTexture),U):U}_isExtensionEnabled(l){return!l.unlit&&(void 0!=l.metallicF0Factor&&1!=l.metallicF0Factor||void 0!=l.metallicReflectanceColor&&!l.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(l))}_hasTexturesExtension(l){return null!=l.metallicReflectanceTexture||null!=l.reflectanceTexture}postExportMaterialAsync(l,a,N){return new Promise((l=>{if(N instanceof ul.b&&this._isExtensionEnabled(N)){this._wasUsed=!0,a.extensions=a.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(N.metallicReflectanceTexture)??void 0,U=this._exporter._materialExporter.getTextureInfo(N.reflectanceTexture)??void 0,c={specularFactor:1==N.metallicF0Factor?void 0:N.metallicF0Factor,specularTexture:l,specularColorFactor:N.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:N.metallicReflectanceColor.Bc(),specularColorTexture:U};this._hasTexturesExtension(N)&&this._exporter._materialNeedsUVsSet.add(N),a.extensions[Oa]=c}l(a)}))}}el.RegisterExtension(Oa,(l=>new ha(l)));const ia="KHR_materials_transmission";class ka{constructor(l){this.name=ia,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=l}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(l,a,N){const U=[];return N instanceof ul.b&&this._isExtensionEnabled(N)?(N.subSurface.thicknessTexture&&U.push(N.subSurface.thicknessTexture),U):U}_isExtensionEnabled(l){if(l.unlit)return!1;const a=l.subSurface;return a.isRefractionEnabled&&void 0!=a.refractionIntensity&&0!=a.refractionIntensity||this._hasTexturesExtension(l)}_hasTexturesExtension(l){return null!=l.subSurface.refractionIntensityTexture}async postExportMaterialAsync(l,a,N){if(N instanceof ul.b&&this._isExtensionEnabled(N)){this._wasUsed=!0;const U=N.subSurface,c={transmissionFactor:0===U.refractionIntensity?void 0:U.refractionIntensity};if(this._hasTexturesExtension(N)&&this._exporter._materialNeedsUVsSet.add(N),U.refractionIntensityTexture)if(U.useGltfStyleTextures){const l=await this._exporter._materialExporter.exportTextureAsync(U.refractionIntensityTexture,"image/png");l&&(c.transmissionTexture=l)}else r.b.Warn(`${l}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);a.extensions||(a.extensions={}),a.extensions[ia]=c}return a}}el.RegisterExtension(ia,(l=>new ka(l)));const Qa="KHR_materials_unlit";class ja{constructor(){this.name=Qa,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(l,a,N){return new Promise((l=>{let U=!1;N instanceof ul.b?U=N.unlit:N instanceof Wl.Ya&&(U=N.disableLighting),U&&(this._wasUsed=!0,null==a.extensions&&(a.extensions={}),a.extensions[Qa]={}),l(a)}))}}el.RegisterExtension(Qa,(()=>new ja));const fa="KHR_materials_volume";class pa{constructor(l){this.name=fa,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=l}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(l,a,N){const U=[];return N instanceof ul.b&&this._isExtensionEnabled(N)?(N.subSurface.thicknessTexture&&U.push(N.subSurface.thicknessTexture),U):U}_isExtensionEnabled(l){if(l.unlit)return!1;const a=l.subSurface;return!(!a.isRefractionEnabled&&!a.isTranslucencyEnabled)&&(void 0!=a.maximumThickness&&0!=a.maximumThickness||void 0!=a.tintColorAtDistance&&a.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=a.tintColor&&a.tintColor!=B.Ca.White()||this._hasTexturesExtension(l))}_hasTexturesExtension(l){return null!=l.subSurface.thicknessTexture}postExportMaterialAsync(l,a,N){return new Promise((l=>{if(N instanceof ul.b&&this._isExtensionEnabled(N)){this._wasUsed=!0;const l=N.subSurface,U={thicknessFactor:0==l.maximumThickness?void 0:l.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(l.thicknessTexture)??void 0,attenuationDistance:l.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:l.tintColorAtDistance,attenuationColor:l.tintColor.equalsFloats(1,1,1)?void 0:l.tintColor.Bc()};this._hasTexturesExtension(N)&&this._exporter._materialNeedsUVsSet.add(N),a.extensions=a.extensions||{},a.extensions[fa]=U}l(a)}))}}el.RegisterExtension(fa,(l=>new pa(l)));const Ra="EXT_materials_diffuse_roughness";class La{constructor(l){this.name=Ra,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=l}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(l,a,N){const U=[];return N instanceof Ta.b&&N._baseDiffuseRoughness?(N._baseDiffuseRoughnessTexture&&U.push(N._baseDiffuseRoughnessTexture),U):[]}postExportMaterialAsync(l,a,N){return new Promise((l=>{if(N instanceof Ta.b){if(!N._baseDiffuseRoughness)return void l(a);this._wasUsed=!0,a.extensions=a.extensions||{};const U=this._exporter._materialExporter.getTextureInfo(N._baseDiffuseRoughnessTexture),c={diffuseRoughnessFactor:N._baseDiffuseRoughness,diffuseRoughnessTexture:U??void 0};null!==c.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(N),a.extensions[Ra]=c}l(a)}))}}el.RegisterExtension(Ra,(l=>new La(l)));const ra="KHR_texture_transform";class Xa{constructor(){this.name=ra,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(l,a,N){if(N.bl()||c.Tools.Warn(`${l}: /*@__KEY__*/"scene" is not defined for Babylon texture ${N.name}!`),(0!==N.uAng||0!==N.vAng)&&(c.Tools.Warn(`${l}: Texture ${N.name} with rotation in the u or v axis is not supported in glTF.`),0!==N.uRotationCenter||0!==N.vRotationCenter))return;const U={};let K=!1;if(0===N.uOffset&&0===N.vOffset||(U.offset=[N.uOffset,N.vOffset],K=!0),1===N.uScale&&1===N.vScale||(U.scale=[N.uScale,N.vScale],K=!0),0!==N.wAng){if(0!==N.uRotationCenter||0!==N.vRotationCenter){if(N.homogeneousRotationInUVTransform&&N.uScale!==N.vScale)return void c.Tools.Warn(`${l}: Texture ${N.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${ra}.`);c.Tools.Warn(`${l}: Texture ${N.name} with non-origin rotation center will be exported using an adjusted offset with ${ra}.`),U.offset=function(l){const{uOffset:a,vOffset:N,uRotationCenter:U,vRotationCenter:c,uScale:K,vScale:Z,wAng:w}=l,S=Math.cos(w),T=Math.sin(w),J=U*K,n=c*Z;return[a+(J*(1-S)+n*T),N+(n*(1-S)-J*T)]}(N)}U.rotation=-N.wAng,K=!0}0!==N.coordinatesIndex&&(U.texCoord=N.coordinatesIndex,K=!0),K&&(this._wasUsed=!0,a.extensions||(a.extensions={}),a.extensions[ra]=U)}}el.RegisterExtension(ra,(()=>new Xa));class Pa{static CreateSTL(l){let a=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",c=arguments.length>3&&void 0!==arguments[3]&&arguments[3],K=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],Z=arguments.length>5&&void 0!==arguments[5]&&arguments[5],w=arguments.length>6&&void 0!==arguments[6]&&arguments[6],S=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const T=function(l,a,N){const c=[3*l[N],3*l[N+1],3*l[N+2]],K=[new U.ua(a[c[0]],a[c[0]+2],a[c[0]+1]),new U.ua(a[c[1]],a[c[1]+2],a[c[1]+1]),new U.ua(a[c[2]],a[c[2]+2],a[c[2]+1])],Z=K[0].Wa(K[1]),w=K[2].Wa(K[1]);return{v:K,n:U.ua.Cross(w,Z).normalize()}},n=function(l,a,N,U){return a=y(l,a,N.x,U),a=y(l,a,N.y,U),y(l,a,N.z,U)},y=function(l,a,N,U){return l.setFloat32(a,N,U),a+4},u=function(l){if(w){let a=l;l instanceof H.d&&(a=l.sourceMesh);const N=a.getVerticesData(J.h.PositionKind,!0,!0);if(!N)return[];const c=U.ua.Zero();let K;for(K=0;K<N.length;K+=3)U.ua.TransformCoordinatesFromFloatsToRef(N[K],N[K+1],N[K+2],l.qc(!0),c).toArray(N,K);return N}return l.getVerticesData(J.h.PositionKind)||[]};w&&(Z=!0);let W="",B=0,Y=0;if(c){for(let N=0;N<l.length;N++){const a=l[N].zc();B+=a?a.length/3:0}const a=new ArrayBuffer(84+50*B);W=new DataView(a),Y+=80,W.setUint32(Y,B,K),Y+=4}else S||(W="solid stlmesh\r\n");for(let U=0;U<l.length;U++){const a=l[U];!c&&S&&(W+="solid "+a.name+"\r\n"),!Z&&a instanceof Cl.d&&a.bakeCurrentTransformIntoVertices();const N=u(a),w=a.zc()||[];for(let l=0;l<w.length;l+=3){const a=T(w,N,l);c?(Y=n(W,Y,a.n,K),Y=n(W,Y,a.v[0],K),Y=n(W,Y,a.v[1],K),Y=n(W,Y,a.v[2],K),Y+=2):(W+="\tfacet normal "+a.n.x+" "+a.n.y+" "+a.n.z+"\r\n",W+="\t\touter loop\r\n",W+="\t\t\tvertex "+a.v[0].x+" "+a.v[0].y+" "+a.v[0].z+"\r\n",W+="\t\t\tvertex "+a.v[1].x+" "+a.v[1].y+" "+a.v[1].z+"\r\n",W+="\t\t\tvertex "+a.v[2].x+" "+a.v[2].y+" "+a.v[2].z+"\r\n",W+="\t\tendloop\r\n",W+="\tendfacet\r\n")}!c&&S&&(W+="endsolid "+name+"\r\n")}if(c||S||(W+="endsolid stlmesh"),a){const l=document.createElement("a"),a=new Blob([W],{type:"application/octet-stream"});l.href=window.URL.createObjectURL(a),l.download=N+".stl",l.click()}return W}}function da(l,a){let N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const U=[];for(let c=0;c<l.length/N;c++){const K=l[c*N],Z=l[c*N+1],w=l[c*N+2];U.push(`(${K.toPrecision(a.precision)}, ${Z.toPrecision(a.precision)}, ${w.toPrecision(a.precision)})`)}return U.join(", ")}function Fa(l,a){const N=[];for(let U=0;U<l.length/2;U++){const c=l[2*U],K=l[2*U+1];N.push(`(${c.toPrecision(a.precision)}, ${(1-K).toPrecision(a.precision)})`)}return N.join(", ")}function ea(l,a){const N=l.getVerticesData(J.h.PositionKind),U=l.getVerticesData(J.h.NormalKind);if(N&&U)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(l){var a;const N=null!==(a=l.zc())&&void 0!==a&&a.length?l.getTotalIndices():l.getTotalVertices();return Array(N/3).fill(3).join(", ")}(l)}]\n\t\tint[] faceVertexIndices = [${function(l){const a=l.zc(),N=[];if(null!==a)for(let U=0;U<a.length;U++)N.push(a[U]);else{const a=l.getTotalVertices();for(let l=0;l<a;l++)N.push(l)}return N.join(", ")}(l)}]\n\t\tnormal3f[] normals = [${da(U,a)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${da(N,a)}]\n        ${function(l,a){let N="";for(let c=0;c<4;c++){const U=c>0?c:"",K=l.getVerticesData(J.h.UVKind+(U?U+1:""));K&&(N+=`\n\t\ttexCoord2f[] primvars:st${U} = [${Fa(K,a)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const U=l.getVerticesData(J.h.ColorKind);return U&&(N+=`\n\tcolor3f[] primvars:displayColor = [${da(U,a,U.length/l.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),N}(l,a)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function sa(l,a){return`\n        def "Geometry"\n        {\n        ${ea(l,a)}\n        }\n        `}function oa(l){let a='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return a+=l,fflate.strToU8(a)}function Ga(l){const a=l.m;return`( ${mN(a,0)}, ${mN(a,4)}, ${mN(a,8)}, ${mN(a,12)} )`}function mN(l,a){return`(${l[a+0]}, ${l[a+1]}, ${l[a+2]}, ${l[a+3]})`}function xa(l){const a="Object_"+l.uniqueId,N=function(l){const a=l.getWorldMatrix().clone(),N=l.bl().useRightHandedSystem;if(!N){let U=l.parent;for(;U;){if(Zl(U,N)){a.multiplyToRef(U.getWorldMatrix().invert(),a);break}U=U.parent}}return a.determinant()<0&&c.Tools.Warn(`Exporting mesh ${l.name} with negative scale. Result may look incorrect in destination engine.`),a}(l),U=Ga(N);return`def Xform "${a}" (\n\tprepend references = @./geometries/Geometry_${l.bc.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${U}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${l.material.uniqueId}>\n}\n\n`}function Va(l){switch(l){case b.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case b.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case b.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Da(l){return`(${l.x}, ${l.y})`}function va(l){return`(${l.r}, ${l.g}, ${l.b})`}function ga(l,a,N,c,K,Z){const w=l.getInternalTexture().uniqueId+"_"+l.invertY;K[w]=l;const S=l.coordinatesIndex>0?"st"+l.coordinatesIndex:"st",T=new U.Vector2(l.uScale,l.vScale),J=new U.Vector2(l.uOffset,l.vOffset),n=l.wAng,y=Math.sin(n),H=Math.cos(n);return J.y=1-J.y-T.y,J.x+=y*T.x,J.y+=(1-H)*T.y,`\n    def Shader "PrimvarReader_${N}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${S}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${N}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${a.uniqueId}/PrimvarReader_${N}.outputs:result>\n        float inputs:rotation = ${(n*(180/Math.PI)).toFixed(Z.precision)}\n        float2 inputs:scale = ${Da(T)}\n        float2 inputs:translation = ${Da(J)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${l.uniqueId}_${N}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${w}.png@\n        float2 inputs:st.connect = </Materials/Material_${a.uniqueId}/Transform2d_${N}.outputs:result>\n        ${c?"float4 inputs:scale = "+function(l){return`(${l.r}, ${l.g}, ${l.b}, 1.0)`}(c):""}\n        token inputs:sourceColorSpace = "${l.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Va(l.wrapU)}"\n        token inputs:wrapT = "${Va(l.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${a.needAlphaBlending()?"float outputs:a":""}\n    }`}function lN(l,a,N){const U="\t\t\t",c=[],K=[],{diffuseMap:Z,Lc:w,alphaCutOff:S,emissiveMap:T,emissive:J,normalMap:n,roughnessMap:y,roughnessChannel:H,roughness:u,metalnessMap:W,metalnessChannel:Y,metalness:C,aoMap:M,aoMapChannel:A,aoMapIntensity:E,alphaMap:q,ior:b,clearCoatEnabled:z,clearCoat:I,clearCoatMap:t,clearCoatRoughness:O,clearCoatRoughnessMap:h}=function(l){const a={diffuseMap:null,Lc:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return l instanceof Wl.Ya?{...a,diffuseMap:l.diffuseTexture,Lc:l.diffuseColor,alphaCutOff:l.alphaCutOff,emissiveMap:l.emissiveTexture,emissive:l.emissiveColor,roughness:1,alphaMap:l.opacityTexture}:l instanceof Ta.b?{...a,diffuseMap:l._albedoTexture,Lc:l._albedoColor,alphaCutOff:l._alphaCutOff,emissiveMap:l._emissiveTexture,emissive:l._emissiveColor,normalMap:l._bumpTexture,roughnessMap:l._metallicTexture,roughnessChannel:l._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:l._roughness??1,metalnessMap:l._metallicTexture,metalnessChannel:l._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:l._metallic??0,aoMap:l._ambientTexture,aoMapChannel:l._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:l._ambientTextureStrength,alphaMap:l._opacityTexture,ior:l.subSurface.indexOfRefraction,clearCoatEnabled:l.clearCoat.isEnabled,clearCoat:l.clearCoat.Rc,clearCoatMap:l.clearCoat.texture,clearCoatRoughness:l.clearCoat.roughness,clearCoatRoughnessMap:l.clearCoat.useRoughnessFromMainTexture?l.clearCoat.texture:l.clearCoat.textureRoughness}:a}(l);return null!==Z?(c.push(`${U}color3f inputs:diffuseColor.connect = </Materials/Material_${l.uniqueId}/Texture_${Z.uniqueId}_diffuse.outputs:rgb>`),l.needAlphaBlending()?c.push(`${U}float inputs:opacity.connect = </Materials/Material_${l.uniqueId}/Texture_${Z.uniqueId}_diffuse.outputs:a>`):l.needAlphaTesting()&&(c.push(`${U}float inputs:opacity.connect = </Materials/Material_${l.uniqueId}/Texture_${Z.uniqueId}_diffuse.outputs:a>`),c.push(`${U}float inputs:opacityThreshold = ${S}`)),K.push(ga(Z,l,"diffuse",w,a,N))):c.push(`${U}color3f inputs:diffuseColor = ${va(w||B.Ca.White())}`),null!==T?(c.push(`${U}color3f inputs:emissiveColor.connect = </Materials/Material_${l.uniqueId}/Texture_${T.uniqueId}_emissive.outputs:rgb>`),K.push(ga(T,l,"emissive",J,a,N))):J&&J.toLuminance()>0&&c.push(`${U}color3f inputs:emissiveColor = ${va(J)}`),null!==n&&(c.push(`${U}normal3f inputs:normal.connect = </Materials/Material_${l.uniqueId}/Texture_${n.uniqueId}_normal.outputs:rgb>`),K.push(ga(n,l,"normal",null,a,N))),null!==M&&(c.push(`${U}float inputs:occlusion.connect = </Materials/Material_${l.uniqueId}/Texture_${M.uniqueId}_occlusion.outputs:${A}>`),K.push(ga(M,l,"occlusion",new B.Ca(E,E,E),a,N))),null!==y?(c.push(`${U}float inputs:roughness.connect = </Materials/Material_${l.uniqueId}/Texture_${y.uniqueId}_roughness.outputs:${H}>`),K.push(ga(y,l,"roughness",new B.Ca(u,u,u),a,N))):c.push(`${U}float inputs:roughness = ${u}`),null!==W?(c.push(`${U}float inputs:metallic.connect = </Materials/Material_${l.uniqueId}/Texture_${W.uniqueId}_metallic.outputs:${Y}>`),K.push(ga(W,l,"metallic",new B.Ca(C,C,C),a,N))):c.push(`${U}float inputs:metallic = ${C}`),null!==q?(c.push(`${U}float inputs:opacity.connect = </Materials/Material_${l.uniqueId}/Texture_${q.uniqueId}_opacity.outputs:r>`),c.push(`${U}float inputs:opacityThreshold = 0.0001`),K.push(ga(q,l,"opacity",null,a,N))):c.push(`${U}float inputs:opacity = ${l.alpha}`),z&&(null!==t?(c.push(`${U}float inputs:clearcoat.connect = </Materials/Material_${l.uniqueId}/Texture_${t.uniqueId}_clearcoat.outputs:r>`),K.push(ga(t,l,"clearcoat",new B.Ca(I,I,I),a,N))):c.push(`${U}float inputs:clearcoat = ${I}`),null!==h?(c.push(`${U}float inputs:clearcoatRoughness.connect = </Materials/Material_${l.uniqueId}/Texture_${h.uniqueId}_clearcoatRoughness.outputs:g>`),K.push(ga(h,l,"clearcoatRoughness",new B.Ca(O,O,O),a,N))):c.push(`${U}float inputs:clearcoatRoughness = ${O}`)),c.push(`${U}float inputs:ior = ${b}`),`\n\tdef Material "Material_${l.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${c.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${l.uniqueId}/PreviewSurface.outputs:surface>\n\n${K.join("\n")}\n\n\t}\n`}async function aN(l,a,N){const K={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...a};"undefined"===typeof fflate&&await c.Tools.LoadScriptAsync(K.fflateUrl);const Z={};Z[K.modelFileName]=null;let w='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';w+=function(l){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===l.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${l.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${l.planeAnchoringAlignment}"`:""}\n            `}(K);const S={};for(const U of l.meshes){if(0===U.getTotalVertices())continue;const l=U,a=l.bc,T=l.material;if(!T||!a||N&&!N(l))continue;if(-1!==["Ya","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(T.getClassName())){const N="geometries/Geometry_"+a.uniqueId+".usda";if(!(N in Z)){const l=sa(a,K);Z[N]=oa(l)}T.uniqueId in S||(S[T.uniqueId]=T),w+=xa(l)}else c.Tools.Warn("USDZExportAsync does not support this material type: "+T.getClassName())}l.activeCamera&&K.exportCamera&&(w+=function(l,a){const N="Camera_"+l.uniqueId,c=Ga(U.Matrix.RotationY(Math.PI).multiply(l.getWorldMatrix()));if(l.mode===b.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${N}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${c}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${l.Ac.toPrecision(a.precision)}, ${l.maxZ.toPrecision(a.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(l.orthoLeft||1)+Math.abs(l.orthoRight||1))).toPrecision(a.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(l.orthoTop||1)+Math.abs(l.orthoBottom||1))).toPrecision(a.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const U=l.getEngine().getAspectRatio(l),K=a.cameraSensorWidth||35;return`def Camera "${N}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${c}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${l.Ac.toPrecision(a.precision)}, ${l.maxZ.toPrecision(a.precision)})\n\t\t\tfloat focalLength = ${(K/(2*Math.tan(.5*l.fov))).toPrecision(a.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(K*U).toPrecision(a.precision)}\n\t\t\tfloat verticalAperture = ${(K/U).toPrecision(a.precision)}            \n\t\t}\n\t\n\t`}}(l.activeCamera,K)),w+="\n            }\n        }\n    }";const T={};w+=function(l,a,N){const U=[];for(const c in l){const K=l[c];U.push(lN(K,a,N))}return`\n    def "Materials"\n{\n${U.join("")}\n}\n\n`}(S,T,K),Z[K.modelFileName]=fflate.strToU8(w);for(const U in T){const l=T[U],a=l.getSize(),N=await l.readPixels();if(!N)throw new Error("Texture data is not available");const c=await z.DumpTools.DumpDataAsync(a.width,a.height,N,"image/png",void 0,!1,!0);Z[`textures/Texture_${U}.png`]=new Uint8Array(c).slice()}let J=0;for(const U in Z){const l=Z[U];if(!l)continue;J+=34+U.length;const a=63&J;if(4!==a){const N=new Uint8Array(64-a);Z[U]=[l,{extra:{12345:N}}]}J=l.length}return fflate.zipSync(Z,{level:0})}}}]);