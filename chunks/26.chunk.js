"use strict";(self["80dd64vgxnn"]=self["80dd64vgxnn"]||[]).push([[26],{13133:(mm,o,u)=>{u.r(o),u.d(o,{EXT_materials_diffuse_roughness:()=>Xo,EXT_mesh_gpu_instancing:()=>nm,GLTF2Export:()=>vm,GLTFData:()=>K,KHR_draco_mesh_compression:()=>uo,KHR_lights_punctual:()=>po,KHR_materials_anisotropy:()=>Yo,KHR_materials_clearcoat:()=>xo,KHR_materials_diffuse_transmission:()=>Mo,KHR_materials_dispersion:()=>to,KHR_materials_emissive_strength:()=>bo,KHR_materials_ior:()=>No,KHR_materials_iridescence:()=>Po,KHR_materials_sheen:()=>go,KHR_materials_specular:()=>Fo,KHR_materials_transmission:()=>Ao,KHR_materials_unlit:()=>Io,KHR_materials_volume:()=>jo,KHR_texture_transform:()=>ko,OBJExport:()=>r,STLExport:()=>eo,USDZExportAsync:()=>uu,_ConvertToGLTFPBRMetallicRoughness:()=>y,_SolveMetallic:()=>A,__IGLTFExporterExtension:()=>w});var f=u(12740),B=u(12549),O=u(13050);class r{static OBJ(mm,o,u,r){const w=[];let p=1,K=1;o&&(u||(u="mat"),w.push("mtllib "+u+".mtl"));for(let z=0;z<mm.length;z++){const u=mm[z],Y=u.name||`mesh${z}}`;w.push(`o ${Y}`);let q=null;if(r){const mm=u.Df(!0);q=new f.Matrix,mm.invertToRef(q),u.bakeTransformIntoVertices(mm)}if(o){const mm=u.material;mm&&w.push("usemtl "+mm.id)}const x=u.br;if(!x){B.Tools.Warn("No geometry is present on the mesh");continue}const H=x.getVerticesData("position"),E=x.getVerticesData("normal"),M=x.getVerticesData("uv"),l=x.hr();let t=0,Q=0;if(!H||!l){B.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const b=mm[0].Pm().useRightHandedSystem?1:-1;for(let mm=0;mm<H.length;mm+=3)w.push("v "+H[mm]*b+" "+H[mm+1]+" "+H[mm+2]),t++;if(null!=E)for(let mm=0;mm<E.length;mm+=3)w.push("vn "+E[mm]*b+" "+E[mm+1]+" "+E[mm+2]);if(null!=M)for(let mm=0;mm<M.length;mm+=2)w.push("vt "+M[mm]+" "+M[mm+1]),Q++;const J=["","",""],N=(u.material||u.Pm().defaultMaterial)._getEffectiveOrientation(u),[S,P]=N===O.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let mm=0;mm<l.length;mm+=3){const o=[String(l[mm]+p),String(l[mm+S]+p),String(l[mm+P]+p)],u=[String(l[mm]+K),String(l[mm+S]+K),String(l[mm+P]+K)],f=o,B=null!=M?u:J,O=null!=E?o:J;w.push("f "+f[0]+"/"+B[0]+"/"+O[0]+" "+f[1]+"/"+B[1]+"/"+O[1]+" "+f[2]+"/"+B[2]+"/"+O[2])}r&&q&&u.bakeTransformIntoVertices(q),p+=t,K+=Q}return w.join("\n")}static MTL(mm){const o=[],u=mm.material;o.push("newmtl mat1"),o.push("  Ns "+u.specularPower.toFixed(4)),o.push("  Ni 1.5000"),o.push("  d "+u.alpha.toFixed(4)),o.push("  Tr 0.0000"),o.push("  Tf 1.0000 1.0000 1.0000"),o.push("  illum 2"),o.push("  Ka "+u.ambientColor.r.toFixed(4)+" "+u.ambientColor.g.toFixed(4)+" "+u.ambientColor.b.toFixed(4)),o.push("  Kd "+u.diffuseColor.r.toFixed(4)+" "+u.diffuseColor.g.toFixed(4)+" "+u.diffuseColor.b.toFixed(4)),o.push("  Ks "+u.specularColor.r.toFixed(4)+" "+u.specularColor.g.toFixed(4)+" "+u.specularColor.b.toFixed(4)),o.push("  Ke "+u.emissiveColor.r.toFixed(4)+" "+u.emissiveColor.g.toFixed(4)+" "+u.emissiveColor.b.toFixed(4));u.ambientTexture&&o.push("  map_Ka "+u.ambientTexture.name),u.diffuseTexture&&o.push("  map_Kd "+u.diffuseTexture.name),u.specularTexture&&o.push("  map_Ks "+u.specularTexture.name),u.bumpTexture&&o.push("  map_bump -imfchan z "+u.bumpTexture.name),u.opacityTexture&&o.push("  map_d "+u.opacityTexture.name);return o.join("\n")}}var w=0,p=u(12605);class K{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const mm in this.files){const o=this.files[mm],u=new Blob([o],{type:(0,p.i)(mm)});B.Tools.Download(u,mm)}}}var z=u(12809),Y=u(13139),q=u(13147),x=u(13160),H=u(12863),E=u(12596),M=u(12780),l=u(12752);const t=l.HighestCommonFactor,Q={...l,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:t};var b=u(12952),J=u(12727),N=u(13188),S=u(13190),P=u(12946);const R=1e-6,g=new M.No(.04,.04,.04),W=1024,F=M.No.White(),c=M.No.Black();function A(mm,o,u){if(o<g.r)return 0;const f=g.r,B=mm*u/(1-g.r)+o-2*g.r,O=B*B-4*f*(g.r-o);return Q.Clamp((-B+Math.sqrt(O))/(2*f),0,1)}function y(mm){const o=mm.diffuseColor.toLinearSpace(mm.Pm().getEngine().useExactSrgbConversions).scale(.5),u=mm.alpha,B=function(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new f.Vector2(0,1),u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new f.Vector2(0,.1),B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new f.Vector2(0,.1),O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new f.Vector2(1300,.1);return function(mm,o,u,f,B){return(1-mm)*(1-mm)*(1-mm)*o+3*(1-mm)*(1-mm)*mm*u+3*(1-mm)*mm*mm*f+mm*mm*mm*B}(Math.pow(mm/O.x,.333333),o.y,u.y,B.y,O.y)}(Q.Clamp(mm.specularPower,0,W));return{baseColorFactor:[o.r,o.g,o.b,u],metallicFactor:0,roughnessFactor:B}}function I(mm,o){o.needAlphaBlending()?mm.alphaMode="BLEND":o.needAlphaTesting()&&(mm.alphaMode="MASK",mm.alphaCutoff=o.alphaCutOff)}function s(mm,o,u){const f=new Uint8Array(mm*o*4);for(let B=0;B<f.length;B+=4)f[B]=f[B+1]=f[B+2]=f[B+3]=255;return N.d.CreateRGBATexture(f,mm,o,u)}function j(mm){if(mm instanceof Uint8Array){const o=mm.length,u=new Float32Array(mm.length);for(let f=0;f<o;++f)u[f]=mm[f]/255;return u}if(mm instanceof Float32Array)return mm;throw new Error("Unsupported pixel format!")}class a{constructor(mm){this._exporter=mm,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(mm){return mm?this._textureMap.get(mm)??null:null}async exportStandardMaterialAsync(mm,o,u){const f=y(mm),O={name:mm.name};if(null==mm.Bp||mm.Bp||(mm.twoSidedLighting||B.Tools.Warn(mm.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),O.doubleSided=!0),u){const u=[],B=mm.diffuseTexture;B&&u.push(this.exportTextureAsync(B,o).then((mm=>{mm&&(f.baseColorTexture=mm)})));const r=mm.bumpTexture;r&&u.push(this.exportTextureAsync(r,o).then((mm=>{mm&&(O.normalTexture=mm,1!==r.level&&(O.normalTexture.scale=r.level))})));const w=mm.emissiveTexture;w&&(O.emissiveFactor=[1,1,1],u.push(this.exportTextureAsync(w,o).then((mm=>{mm&&(O.emissiveTexture=mm)}))));const p=mm.ambientTexture;p&&u.push(this.exportTextureAsync(p,o).then((mm=>{if(mm){const o={index:mm.index};O.occlusionTexture=o}}))),u.length>0&&(this._exporter._materialNeedsUVsSet.add(mm),await Promise.all(u))}(mm.alpha<1||mm.opacityTexture)&&(mm.alphaMode===S.d.ALPHA_COMBINE?O.alphaMode="BLEND":B.Tools.Warn(mm.name+": glTF 2.0 does not support alpha mode: "+mm.alphaMode.toString())),mm.emissiveColor&&!mm.emissiveColor.equalsWithEpsilon(c,R)&&(O.emissiveFactor=mm.emissiveColor.df()),O.pbrMetallicRoughness=f,I(O,mm),await this._finishMaterialAsync(O,mm,o);const r=this._exporter._materials;return r.push(O),r.length-1}async _finishMaterialAsync(mm,o,u){const f=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",mm,o),B=[];for(const O of f)B.push(this.exportTextureAsync(O,u));await Promise.all(B),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",mm,o)}async _getImageDataAsync(mm,o,f,B){const O=S.d.TEXTURETYPE_UNSIGNED_BYTE,r=this._exporter._babylonScene,w=r.getEngine(),p=w.createRawTexture(mm,o,f,S.d.TEXTUREFORMAT_RGBA,!1,!0,J.b.NEAREST_SAMPLINGMODE,null,O);w.isWebGPU?await u.e(51).then(u.bind(u,15097)):await u.e(52).then(u.bind(u,15103)),await b.j.ApplyPostProcess("pass",p,r,O,S.d.TEXTURE_NEAREST_SAMPLINGMODE,S.d.TEXTUREFORMAT_RGBA);const K=await w._readTexturePixels(p,o,f);return await P.DumpTools.DumpDataAsync(o,f,K,B,void 0,!0,!0)}_resizeTexturesToSameDimensions(mm,o,u){const f=mm?mm.getSize():{width:0,height:0},B=o?o.getSize():{width:0,height:0};let O,r;return f.width<B.width?(O=mm&&mm instanceof J.b?b.j.CreateResizedCopy(mm,B.width,B.height,!0):s(B.width,B.height,u),r=o):f.width>B.width?(r=o&&o instanceof J.b?b.j.CreateResizedCopy(o,f.width,f.height,!0):s(f.width,f.height,u),O=mm):(O=mm,r=o),{texture1:O,texture2:r}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(mm,o,u,f){const B=new Array;if(!mm&&!o)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const O=mm?mm.Pm():o?o.Pm():null;if(O){var r;const w=this._resizeTexturesToSameDimensions(mm,o,O),p=null===(r=w.texture1)||void 0===r?void 0:r.getSize();let K,z;const Y=p.width,q=p.height,x=await w.texture1.readPixels(),H=await w.texture2.readPixels();if(!x)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(K=j(x),!H)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");z=j(H);const E=z.byteLength,l=new Uint8Array(E),t=new Uint8Array(E),Q=4,b=c;let J=0,N=0;for(let mm=0;mm<q;++mm)for(let o=0;o<Y;++o){const f=(Y*mm+o)*Q,B={diffuseColor:new M.No(K[f],K[f+1],K[f+2]).toLinearSpace(O.getEngine().useExactSrgbConversions).multiply(u.diffuseColor),specularColor:new M.No(z[f],z[f+1],z[f+2]).toLinearSpace(O.getEngine().useExactSrgbConversions).multiply(u.specularColor),glossiness:z[f+3]*u.glossiness},r=this._convertSpecularGlossinessToMetallicRoughness(B);b.r=Math.max(b.r,r.baseColor.r),b.g=Math.max(b.g,r.baseColor.g),b.b=Math.max(b.b,r.baseColor.b),J=Math.max(J,r.metallic),N=Math.max(N,r.roughness),t[f]=255*r.baseColor.r,t[f+1]=255*r.baseColor.g,t[f+2]=255*r.baseColor.b,t[f+3]=w.texture1.Uf?255*K[f+3]:255,l[f]=0,l[f+1]=255*r.roughness,l[f+2]=255*r.metallic,l[f+3]=255}const S={baseColor:b,metallic:J,roughness:N};let P=!1,g=!1;for(let mm=0;mm<q;++mm)for(let o=0;o<Y;++o){const u=(Y*mm+o)*Q;t[u]/=S.baseColor.r>R?S.baseColor.r:1,t[u+1]/=S.baseColor.g>R?S.baseColor.g:1,t[u+2]/=S.baseColor.b>R?S.baseColor.b:1;const f=M.No.FromInts(t[u],t[u+1],t[u+2]).toGammaSpace(O.getEngine().useExactSrgbConversions);t[u]=255*f.r,t[u+1]=255*f.g,t[u+2]=255*f.b,f.equalsWithEpsilon(F,R)||(g=!0),l[u+1]/=S.roughness>R?S.roughness:1,l[u+2]/=S.metallic>R?S.metallic:1;M.No.FromInts(255,l[u+1],l[u+2]).equalsWithEpsilon(F,R)||(P=!0)}return P&&B.push(this._getImageDataAsync(l,Y,q,f).then((mm=>{S.metallicRoughnessTextureData=mm}))),g&&B.push(this._getImageDataAsync(t,Y,q,f).then((mm=>{S.baseColorTextureData=mm}))),await Promise.all(B).then((()=>S))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(mm){const o=this._getPerceivedBrightness(mm.diffuseColor),u=this._getPerceivedBrightness(mm.specularColor),f=1-this._getMaxComponent(mm.specularColor),B=A(o,u,f),O=mm.diffuseColor.scale(f/(1-g.r)/Math.max(1-B)),r=mm.specularColor.Qo(g.scale(1-B)).scale(1/Math.max(B));let w=M.No.Lerp(O,r,B*B);w=w.clampToRef(0,1,w);return{baseColor:w,metallic:B,roughness:1-mm.glossiness}}_getPerceivedBrightness(mm){return mm?Math.sqrt(.299*mm.r*mm.r+.587*mm.g*mm.g+.114*mm.b*mm.b):0}_getMaxComponent(mm){return mm?Math.max(mm.r,Math.max(mm.g,mm.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(mm,o,u,f){const B=[],O={baseColor:mm._albedoColor,metallic:mm._metallic,roughness:mm._roughness};if(f){mm._albedoTexture&&B.push(this.exportTextureAsync(mm._albedoTexture,o).then((mm=>{mm&&(u.baseColorTexture=mm)})));const f=mm._metallicTexture;f&&B.push(this.exportTextureAsync(f,o).then((mm=>{mm&&(u.metallicRoughnessTexture=mm)})))}return B.length>0&&(this._exporter._materialNeedsUVsSet.add(mm),await Promise.all(B)),O}_getTextureSampler(mm){const o={};if(!mm||!(mm instanceof J.b))return o;const u=this._getGLTFTextureWrapMode(mm.wrapU);10497!==u&&(o.wrapS=u);const f=this._getGLTFTextureWrapMode(mm.wrapV);switch(10497!==f&&(o.wrapT=f),mm.samplingMode){case J.b.LINEAR_LINEAR:o.magFilter=9729,o.minFilter=9729;break;case J.b.LINEAR_NEAREST:o.magFilter=9729,o.minFilter=9728;break;case J.b.NEAREST_LINEAR:o.magFilter=9728,o.minFilter=9729;break;case J.b.NEAREST_LINEAR_MIPLINEAR:o.magFilter=9728,o.minFilter=9987;break;case J.b.NEAREST_NEAREST:o.magFilter=9728,o.minFilter=9728;break;case J.b.NEAREST_LINEAR_MIPNEAREST:o.magFilter=9728,o.minFilter=9985;break;case J.b.LINEAR_NEAREST_MIPNEAREST:o.magFilter=9729,o.minFilter=9984;break;case J.b.LINEAR_NEAREST_MIPLINEAR:o.magFilter=9729,o.minFilter=9986;break;case J.b.NEAREST_NEAREST_MIPLINEAR:o.magFilter=9728,o.minFilter=9986;break;case J.b.LINEAR_LINEAR_MIPLINEAR:o.magFilter=9729,o.minFilter=9987;break;case J.b.LINEAR_LINEAR_MIPNEAREST:o.magFilter=9729,o.minFilter=9985;break;case J.b.NEAREST_NEAREST_MIPNEAREST:o.magFilter=9728,o.minFilter=9984}return o}_getGLTFTextureWrapMode(mm){switch(mm){case J.b.WRAP_ADDRESSMODE:return 10497;case J.b.CLAMP_ADDRESSMODE:return 33071;case J.b.MIRROR_ADDRESSMODE:return 33648;default:return B.Tools.Error(`Unsupported Texture Wrap Mode ${mm}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(mm,o,u,f){const B={diffuseColor:mm._albedoColor,specularColor:mm._reflectivityColor,glossiness:mm._microSurface},O=mm._albedoTexture,r=mm._reflectivityTexture,w=mm._useMicroSurfaceFromReflectivityMapAlpha;if(r&&!w)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((O||r)&&f){this._exporter._materialNeedsUVsSet.add(mm);const f=this._exportTextureSampler(O||r),w=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(O,r,B,o),p=this._exporter._textures;if(w.baseColorTextureData){const mm=this._exportImage(`baseColor${p.length}`,o,w.baseColorTextureData);u.baseColorTexture=this._exportTextureInfo(mm,f,null===O||void 0===O?void 0:O.coordinatesIndex)}if(w.metallicRoughnessTextureData){const mm=this._exportImage(`metallicRoughness${p.length}`,o,w.metallicRoughnessTextureData);u.metallicRoughnessTexture=this._exportTextureInfo(mm,f,null===r||void 0===r?void 0:r.coordinatesIndex)}return w}return this._convertSpecularGlossinessToMetallicRoughness(B)}async exportPBRMaterialAsync(mm,o,u){const f={},B={name:mm.name},O=mm.isMetallicWorkflow();if(O){const o=mm._albedoColor,u=mm.alpha;o&&(f.baseColorFactor=[o.r,o.g,o.b,u])}const r=O?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(mm,o,f,u):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(mm,o,f,u);await this._setMetallicRoughnessPbrMaterialAsync(r,mm,B,f,o,u),await this._finishMaterialAsync(B,mm,o);const w=this._exporter._materials;return w.push(B),w.length-1}async _setMetallicRoughnessPbrMaterialAsync(mm,o,u,f,O,r){if(I(u,o),mm.baseColor.equalsWithEpsilon(F,R)&&Q.WithinEpsilon(o.alpha,1,R)||(f.baseColorFactor=[mm.baseColor.r,mm.baseColor.g,mm.baseColor.b,o.alpha]),null!=mm.metallic&&1!==mm.metallic&&(f.metallicFactor=mm.metallic),null!=mm.roughness&&1!==mm.roughness&&(f.roughnessFactor=mm.roughness),null==o.Bp||o.Bp||(o._twoSidedLighting||B.Tools.Warn(o.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),u.doubleSided=!0),r){const mm=[],f=o._bumpTexture;f&&mm.push(this.exportTextureAsync(f,O).then((mm=>{mm&&(u.normalTexture=mm,1!==f.level&&(u.normalTexture.scale=f.level))})));const B=o._ambientTexture;B&&mm.push(this.exportTextureAsync(B,O).then((mm=>{if(mm){const f={index:mm.index,texCoord:mm.texCoord,extensions:mm.extensions};u.occlusionTexture=f;const B=o._ambientTextureStrength;B&&(f.strength=B)}})));const r=o._emissiveTexture;r&&mm.push(this.exportTextureAsync(r,O).then((mm=>{mm&&(u.emissiveTexture=mm)}))),mm.length>0&&(this._exporter._materialNeedsUVsSet.add(o),await Promise.all(mm))}const w=o._emissiveColor;w.equalsWithEpsilon(c,R)||(u.emissiveFactor=w.df()),u.pbrMetallicRoughness=f}_getPixelsFromTextureAsync(mm){return function(mm){switch(mm){case S.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case S.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case S.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case S.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case S.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case S.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case S.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case S.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case S.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case S.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case S.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case S.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(mm.textureFormat)?(0,b.g)(mm,mm._texture.width,mm._texture.height):(mm.textureType,S.d.TEXTURETYPE_UNSIGNED_BYTE,mm.readPixels())}async exportTextureAsync(mm,o){const u=this._exporter._extensionsPreExportTextureAsync("exporter",mm,o);return u?await u.then((async u=>u?await this._exportTextureInfoAsync(u,o):await this._exportTextureInfoAsync(mm,o))):await this._exportTextureInfoAsync(mm,o)}async _exportTextureInfoAsync(mm,o){let u=this._textureMap.get(mm);if(!u){const f=await this._getPixelsFromTextureAsync(mm);if(!f)return null;const O=this._exportTextureSampler(mm),r=mm.mimeType;if(r)switch(r){case"image/jpeg":case"image/png":case"image/webp":o=r;break;default:B.Tools.Warn(`Unsupported media type: ${r}. Exporting texture as PNG.`)}const w=this._internalTextureToImage,p=mm.getInternalTexture().uniqueId;w[p]||(w[p]={});let K=w[p][o];if(void 0===K){const u=mm.getSize();K=(async()=>{const B=await this._getImageDataAsync(f,u.width,u.height,o);return this._exportImage(mm.name,o,B)})(),w[p][o]=K}u=this._exportTextureInfo(await K,O,mm.coordinatesIndex),this._textureMap.set(mm,u),this._exporter._extensionsPostExportTextures("exporter",u,mm)}return u}_exportImage(mm,o,u){const f=this._exporter._images;let O;if(this._exporter._shouldUseGlb){O={name:mm,mimeType:o,bufferView:void 0};const f=this._exporter._bufferManager.createBufferView(new Uint8Array(u));this._exporter._bufferManager.setBufferView(O,f)}else{const r=mm.replace(/\.\/|\/|\.\\|\\/g,"_"),w=function(mm){switch(mm){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(o);let p=r+w;f.some((mm=>mm.uri===p))&&(p=`${r}_${B.Tools.RandomId()}${w}`),O={name:mm,uri:p},this._exporter._imageData[p]={data:u,mimeType:o}}return f.push(O),f.length-1}_exportTextureInfo(mm,o,u){const f=this._exporter._textures;let B=f.findIndex((u=>u.sampler==o&&u.source===mm));-1===B&&(B=f.length,f.push({source:mm,sampler:o}));const O={index:B};return u&&(O.texCoord=u),O}_exportTextureSampler(mm){const o=this._getTextureSampler(mm),u=this._exporter._samplers,f=u.findIndex((mm=>mm.minFilter===o.minFilter&&mm.magFilter===o.magFilter&&mm.wrapS===o.wrapS&&mm.wrapT===o.wrapT));return-1!==f?f:(u.push(o),u.length-1)}}var X=u(12824),G=u(12565),k=u(13193),d=u(12746);const e=f.lo.Zero(),L=f.Quaternion.Identity(),C=f.lo.One(),v=new f.lo(-1,1,1);function V(mm,o){const{byteOffset:u,byteStride:f,type:B,normalized:O}=mm,r=mm.getSize(),w=o.reduce(((mm,o)=>o.getTotalVertices()>mm?o.getTotalVertices():mm),-Number.MAX_VALUE);return{byteOffset:u,byteStride:f,componentCount:r,type:B,count:w*r,normalized:O,totalVertices:w,kind:mm.getKind()}}function n(mm){switch(mm){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function U(mm){switch(mm){case z.f.PositionKind:case z.f.NormalKind:case z.f.TangentKind:case z.f.ColorKind:case z.f.MatricesIndicesKind:case z.f.MatricesIndicesExtraKind:case z.f.MatricesWeightsKind:case z.f.MatricesWeightsExtraKind:case z.f.UVKind:case z.f.UV2Kind:case z.f.UV3Kind:case z.f.UV4Kind:case z.f.UV5Kind:case z.f.UV6Kind:return!0}return!1}function h(mm){switch(mm){case O.c.TriangleFillMode:return 4;case O.c.TriangleStripDrawMode:return 5;case O.c.TriangleFanDrawMode:return 6;case O.c.PointListDrawMode:case O.c.PointFillMode:return 0;case O.c.LineLoopDrawMode:return 2;case O.c.LineListDrawMode:return 1;case O.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${mm}`)}function Z(mm){const o=Math.sqrt(mm.x*mm.x+mm.y*mm.y+mm.z*mm.z);o>0&&(mm.x/=o,mm.y/=o,mm.z/=o)}function T(mm){return mm.x*=-1,mm}function D(mm){if(mm.x*mm.x+mm.y*mm.y>.5){const o=Math.abs(mm.x),u=Math.abs(mm.y);if(o>u){const u=Math.sign(mm.x);mm.x=o,mm.y*=-u,mm.z*=-u,mm.w*=u}else{const o=Math.sign(mm.y);mm.x*=-o,mm.y=u,mm.z*=o,mm.w*=-o}}else{const o=Math.abs(mm.z),u=Math.abs(mm.w);if(o>u){const u=Math.sign(mm.z);mm.x*=-u,mm.y*=u,mm.z=o,mm.w*=-u}else{const o=Math.sign(mm.w);mm.x*=o,mm.y*=-o,mm.z*=-o,mm.w=u}}return mm}function i(mm){mm.Op(-mm.z,mm.w,mm.x,-mm.y)}function mo(mm,o){const u=f.lo.FromArrayToRef(o.translation||[0,0,0],0,f.TmpVectors.lo[0]),B=f.Quaternion.FromArrayToRef(o.rotation||[0,0,0,1],0,f.TmpVectors.Quaternion[0]),O=f.Matrix.ComposeToRef(C,B,u,f.TmpVectors.Matrix[0]),r=f.lo.FromArrayToRef(mm.translation||[0,0,0],0,f.TmpVectors.lo[2]),w=f.Quaternion.FromArrayToRef(mm.rotation||[0,0,0,1],0,f.TmpVectors.Quaternion[1]),p=f.Matrix.ComposeToRef(C,w,r,f.TmpVectors.Matrix[1]);O.multiplyToRef(p,p),p.decompose(void 0,B,u),u.equalsWithEpsilon(e,d.e)?delete o.translation:o.translation=u.df(),B.equalsWithEpsilon(L,d.e)?delete o.rotation:o.rotation=B.df(),o.scale&&delete o.scale}function om(mm,o){if(!(o instanceof Y.c))return!1;if(!(1===o.getChildren().length&&0===mm.getChildren().length&&mm.parent===o))return!1;const u=mm.Pm(),f=mm instanceof k.b&&!u.useRightHandedSystem?v:C;return!!o.rp.equalsWithEpsilon(f,d.e)||(G.e.Warn(`Cannot collapse node ${mm.name} into parent node ${o.name} with modified scaling.`),!1)}function um(mm){if(mm instanceof Array){const o=new Float32Array(mm);return new Uint8Array(o.buffer,o.byteOffset,o.byteLength)}return ArrayBuffer.isView(mm)?new Uint8Array(mm.buffer,mm.byteOffset,mm.byteLength):new Uint8Array(mm)}function fm(mm,o){for(const[u,f]of Object.entries(mm)){const B=o[u];(Array.isArray(f)&&Array.isArray(B)&&Bm(f,B)||f===B)&&delete mm[u]}return mm}function Bm(mm,o){return mm.length===o.length&&mm.every(((mm,u)=>mm===o[u]))}const Om=f.Matrix.Compose(new f.lo(-1,1,1),f.Quaternion.Identity(),f.lo.Zero());function rm(mm,o){if(!(mm instanceof Y.c))return!1;if(o){if(!mm.getWorldMatrix().equalsWithEpsilon(f.Matrix.IdentityReadOnly,d.e))return!1}else{if(!mm.getWorldMatrix().multiplyToRef(Om,f.TmpVectors.Matrix[0]).equalsWithEpsilon(f.Matrix.IdentityReadOnly,d.e))return!1}return!(mm instanceof q.b&&mm.br)}const wm=new Map([[Int8Array,(mm,o,u)=>mm.setInt8(o,u)],[Uint8Array,(mm,o,u)=>mm.setUint8(o,u)],[Uint8ClampedArray,(mm,o,u)=>mm.setUint8(o,u)],[Int16Array,(mm,o,u)=>mm.setInt16(o,u,!0)],[Uint16Array,(mm,o,u)=>mm.setUint16(o,u,!0)],[Int32Array,(mm,o,u)=>mm.setInt32(o,u,!0)],[Uint32Array,(mm,o,u)=>mm.setUint32(o,u,!0)],[Float32Array,(mm,o,u)=>mm.setFloat32(o,u,!0)],[Float64Array,(mm,o,u)=>mm.setFloat64(o,u,!0)]]);class pm{writeTypedArray(mm){this._checkGrowBuffer(mm.byteLength);const o=wm.get(mm.constructor);for(let u=0;u<mm.length;u++)o(this._dataView,this._byteOffset,mm[u]),this._byteOffset+=mm.BYTES_PER_ELEMENT}constructor(mm){this._data=new Uint8Array(mm),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(mm){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,mm),this._byteOffset++}writeInt8(mm){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,mm),this._byteOffset++}writeInt16(mm){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,mm,!0),this._byteOffset+=2}writeUInt16(mm){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,mm,!0),this._byteOffset+=2}writeInt32(mm){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,mm,!0),this._byteOffset+=4}writeUInt32(mm){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,mm,!0),this._byteOffset+=4}writeFloat32(mm){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,mm,!0),this._byteOffset+=4}writeFloat64(mm){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,mm,!0),this._byteOffset+=8}_checkGrowBuffer(mm){const o=this.byteOffset+mm;if(o>this._data.byteLength){const mm=new Uint8Array(2*o);mm.set(this._data),this._data=mm,this._dataView=new DataView(this._data.buffer)}}}function Km(mm){return mm%4===0?4:mm%2===0?2:1}class zm{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(mm){let o=0;this._bufferViewToData.forEach((mm=>{o+=mm.byteLength}));const u=new pm(o),f=Array.from(this._bufferViewToData.keys()).sort(((mm,o)=>Km(o.byteLength)-Km(mm.byteLength)));for(const B of f){B.byteOffset=u.byteOffset,mm.push(B);const o=mm.length-1,f=this.getPropertiesWithBufferView(B);for(const mm of f)mm.bufferView=o;u.writeTypedArray(this._bufferViewToData.get(B)),this._bufferViewToData.delete(B)}return u.getOutputData()}createBufferView(mm,o){const u={buffer:0,byteOffset:void 0,byteLength:mm.byteLength,byteStride:o};return this._bufferViewToData.set(u,mm),u}createAccessor(mm,o,u,f,B,O,r){this._verifyBufferView(mm);const w={bufferView:void 0,componentType:u,count:f,type:o,min:null===O||void 0===O?void 0:O.min,max:null===O||void 0===O?void 0:O.max,normalized:r,byteOffset:B};return this.setBufferView(w,mm),this._accessorToBufferView.set(w,mm),w}setBufferView(mm,o){this._verifyBufferView(o);this.getPropertiesWithBufferView(o).push(mm)}removeBufferView(mm){const o=this.getPropertiesWithBufferView(mm);for(const u of o)void 0!==u.bufferView&&delete u.bufferView;this._bufferViewToData.delete(mm),this._bufferViewToProperties.delete(mm),this._accessorToBufferView.forEach(((o,u)=>{o===mm&&(void 0!==u.byteOffset&&delete u.byteOffset,this._accessorToBufferView.delete(u))}))}getBufferView(mm){const o=this._accessorToBufferView.get(mm);return this._verifyBufferView(o),o}getPropertiesWithBufferView(mm){return this._verifyBufferView(mm),this._bufferViewToProperties.set(mm,this._bufferViewToProperties.get(mm)??[]),this._bufferViewToProperties.get(mm)}getData(mm){return this._verifyBufferView(mm),this._bufferViewToData.get(mm)}_verifyBufferView(mm){if(void 0===mm||!this._bufferViewToData.has(mm))throw new Error(`BufferView ${mm} not found in BufferManager.`)}}var Ym,qm=u(13170),xm=u(13184),Hm=u(13199),Em=u(13101),Mm=u(13233),lm=u(13249),tm=u(13166),Qm=u(13258);!function(mm){mm[mm.INTANGENT=0]="INTANGENT",mm[mm.OUTTANGENT=1]="OUTTANGENT"}(Ym||(Ym={}));class bm{static _IsTransformable(mm){return mm&&(mm instanceof Y.c||mm instanceof qm.b||mm instanceof Qm.c)}static _CreateNodeAnimation(mm,o,u,f,O){if(this._IsTransformable(mm)){const r=[],w=[],p=o.getKeys(),K=bm._CalculateMinMaxKeyFrames(p),z=bm._DeduceInterpolation(p,u,f),Y=z.interpolationType,q=z.shouldBakeAnimation;if(q?bm._CreateBakedAnimation(mm,o,u,K.min,K.max,o.framePerSecond,O,r,w,K,f):"LINEAR"===Y||"STEP"===Y?bm._CreateLinearOrStepAnimation(mm,o,u,r,w,f):"CUBICSPLINE"===Y?bm._CreateCubicSplineAnimation(mm,o,u,r,w,f):bm._CreateBakedAnimation(mm,o,u,K.min,K.max,o.framePerSecond,O,r,w,K,f),r.length&&w.length){return{inputs:r,outputs:w,samplerInterpolation:Y,inputsMin:q?K.min:B.Tools.FloatRound(K.min/o.framePerSecond),inputsMax:q?K.max:B.Tools.FloatRound(K.max/o.framePerSecond)}}}return null}static _DeduceAnimationInfo(mm){let o=null,u="VEC3",f=!1;const O=mm.targetProperty.split(".");switch(O[0]){case"rp":o="scale";break;case"position":o="translation";break;case"rotation":u="VEC4",o="rotation";break;case"rotationQuaternion":u="VEC4",f=!0,o="rotation";break;case"influence":u="SCALAR",o="weights";break;default:B.Tools.Error(`Unsupported animatable property ${O[0]}`)}return o?{animationChannelTargetPath:o,dataAccessorType:u,useQuaternion:f}:(B.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(mm,o,u,f,B,O,r,w,p,K,z){let Y;if(bm._IsTransformable(mm)&&mm.animations)for(const q of mm.animations){if(z&&!z(q))continue;const B=bm._DeduceAnimationInfo(q);B&&(Y={name:q.name,samplers:[],channels:[]},bm._AddAnimation(`${q.name}`,q.hasRunningRuntimeAnimations?o:Y,mm,q,B.dataAccessorType,B.animationChannelTargetPath,f,O,r,w,B.useQuaternion,p,K),Y.samplers.length&&Y.channels.length&&u.push(Y))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(mm,o,u,f,B,O,r,w,p,K,z){let Y;if(mm instanceof tm.d){const B=mm.morphTargetManager;if(B)for(let q=0;q<B.numTargets;++q){const x=B.getTarget(q);for(const H of x.animations){if(z&&!z(H))continue;const x=new Mm.d(`${H.name}`,"influence",H.framePerSecond,H.dataType,H.loopMode,H.enableBlending),E=[],M=H.getKeys();for(let mm=0;mm<M.length;++mm){const o=M[mm];for(let mm=0;mm<B.numTargets;++mm)mm==q?E.push(o):E.push({frame:o.frame,value:0})}x.setKeys(E);const l=bm._DeduceAnimationInfo(x);l&&(Y={name:x.name,samplers:[],channels:[]},bm._AddAnimation(H.name,H.hasRunningRuntimeAnimations?o:Y,mm,x,l.dataAccessorType,l.animationChannelTargetPath,f,O,r,w,l.useQuaternion,p,K,B.numTargets),Y.samplers.length&&Y.channels.length&&u.push(Y))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(mm,o,u,f,B,O,r,w,p){let K;if(mm.animationGroups){const Y=mm.animationGroups;for(const q of Y){const Y=new Map,x=new Map,H=new Set,E=q.to-q.from;K={name:q.name,channels:[],samplers:[]};for(let o=0;o<q.targetedAnimations.length;++o){const E=q.targetedAnimations[o],M=E.target,l=E.animation;if(p&&!p(l))continue;const t=w.has(M);if(this._IsTransformable(M)||1===M.length&&this._IsTransformable(M[0])){const mm=bm._DeduceAnimationInfo(E.animation);if(mm){const o=this._IsTransformable(M)?M:this._IsTransformable(M[0])?M[0]:null;o&&bm._AddAnimation(`${l.name}`,K,o,l,mm.dataAccessorType,mm.animationChannelTargetPath,u,f,B,O,mm.useQuaternion,r,t)}}else if(M instanceof lm.c||1===M.length&&M[0]instanceof lm.c){if(bm._DeduceAnimationInfo(E.animation)){const o=M instanceof lm.c?M:M[0];if(o){const u=mm.morphTargetManagers.find((mm=>{for(let u=0;u<mm.numTargets;++u)if(mm.getTarget(u)===o)return!0;return!1}));if(u){const f=mm.meshes.find((mm=>mm.morphTargetManager===u));var z;if(f)Y.has(f)||Y.set(f,new Map),null===(z=Y.get(f))||void 0===z||z.set(o,l),H.add(f),x.set(f,l)}}}}}H.forEach((mm=>{const o=mm.morphTargetManager;let w=null;const p=[],z=x.get(mm).getKeys(),H=z.length;for(let u=0;u<H;++u)for(let f=0;f<o.numTargets;++f){const B=o.getTarget(f),O=Y.get(mm);if(O){const o=O.get(B);o?(w||(w=new Mm.d(`${q.name}_${mm.name}_MorphWeightAnimation`,"influence",o.framePerSecond,Mm.d.ANIMATIONTYPE_FLOAT,o.loopMode,o.enableBlending)),p.push(o.getKeys()[u])):p.push({frame:q.from+E/H*u,value:B.influence,inTangent:z[0].inTangent?0:void 0,outTangent:z[0].outTangent?0:void 0})}}w.setKeys(p);const M=bm._DeduceAnimationInfo(w);M&&bm._AddAnimation(`${q.name}_${mm.name}_MorphWeightAnimation`,K,mm,w,M.dataAccessorType,M.animationChannelTargetPath,u,f,B,O,M.useQuaternion,r,!1,null===o||void 0===o?void 0:o.numTargets)})),K.channels.length&&K.samplers.length&&o.push(K)}}}static _AddAnimation(mm,o,u,B,O,r,w,p,K,z,Y,q,x,H){const E=bm._CreateNodeAnimation(u,B,r,Y,q);let M,l,t,Q,b,J;if(E){if(H){let mm=0,o=0;const u=[];for(;E.inputs.length>0;)o=E.inputs.shift(),mm%H==0&&u.push(o),mm++;E.inputs=u}const mm=w.get(u),B=new Float32Array(E.inputs);M=p.createBufferView(B),l=p.createAccessor(M,"SCALAR",5126,E.inputs.length,void 0,{min:[E.inputsMin],max:[E.inputsMax]}),z.push(l),t=z.length-1;const K=new f.Quaternion,Y=new f.lo,q=new f.lo,N=u instanceof qm.b,S=n(O),P=new Float32Array(E.outputs.length*S);E.outputs.forEach((function(mm,o){let u=mm;switch(r){case"translation":x&&(f.lo.FromArrayToRef(mm,0,q),T(q),q.toArray(u));break;case"rotation":4===mm.length?f.Quaternion.FromArrayToRef(mm,0,K):(u=new Array(4),f.lo.FromArrayToRef(mm,0,Y),f.Quaternion.FromEulerVectorToRef(Y,K)),x&&(D(K),N&&i(K)),K.toArray(u)}P.set(u,o*S)})),M=p.createBufferView(P),l=p.createAccessor(M,O,5126,E.outputs.length),z.push(l),Q=z.length-1,b={interpolation:E.samplerInterpolation,input:t,output:Q},o.samplers.push(b),J={sampler:o.samplers.length-1,target:{node:mm,path:r}},o.channels.push(J)}}static _CreateBakedAnimation(mm,o,u,O,r,w,p,K,z,Y,q){let x;const H=f.Quaternion.Identity();let E,M=null,l=null,t=null,Q=null,b=null,J=null;Y.min=B.Tools.FloatRound(O/w);const N=o.getKeys();for(let f=0,S=N.length;f<S;++f){if(J=null,t=N[f],f+1<S)if(Q=N[f+1],t.value.equals&&t.value.equals(Q.value)||t.value===Q.value){if(0!==f)continue;J=t.frame}else J=Q.frame;else{if(b=N[f-1],t.value.equals&&t.value.equals(b.value)||t.value===b.value)continue;J=r}if(J)for(let f=t.frame;f<=J;f+=p){if(E=B.Tools.FloatRound(f/w),E===M)continue;M=E,l=E;const O={key:0,repeatCount:0,loopMode:o.loopMode};x=o._interpolate(f,O),bm._SetInterpolatedValue(mm,x,E,o,u,H,K,z,q)}}l&&(Y.max=l)}static _ConvertFactorToVector3OrQuaternion(mm,o,u,O,r){const w=bm._GetBasePositionRotationOrScale(o,O,r),p=u.targetProperty.split("."),K=p?p[1]:"",z=r?f.Quaternion.So(w).normalize():f.lo.So(w);switch(K){case"x":case"y":case"z":z[K]=mm;break;case"w":z.w=mm;break;default:B.Tools.Error(`glTFAnimation: Unsupported component name "${K}"!`)}return z}static _SetInterpolatedValue(mm,o,u,B,O,r,w,p,K){let z;w.push(u),"weights"!==O?(B.dataType===Mm.d.ANIMATIONTYPE_FLOAT&&(o=this._ConvertFactorToVector3OrQuaternion(o,mm,B,O,K)),"rotation"===O?(K?r=o:(z=o,f.Quaternion.RotationYawPitchRollToRef(z.y,z.x,z.z,r)),p.push(r.df())):(z=o,p.push(z.df()))):p.push([o])}static _CreateLinearOrStepAnimation(mm,o,u,f,B,O){for(const r of o.getKeys())f.push(r.frame/o.framePerSecond),bm._AddKeyframeValue(r,o,B,u,mm,O)}static _CreateCubicSplineAnimation(mm,o,u,f,B,O){o.getKeys().forEach((function(r){f.push(r.frame/o.framePerSecond),bm._AddSplineTangent(Ym.INTANGENT,B,u,"CUBICSPLINE",r,O),bm._AddKeyframeValue(r,o,B,u,mm,O),bm._AddSplineTangent(Ym.OUTTANGENT,B,u,"CUBICSPLINE",r,O)}))}static _GetBasePositionRotationOrScale(mm,o,u){let B;if("rotation"===o)if(u){B=(mm.rotationQuaternion??f.Quaternion.Identity()).df()}else{B=(mm.rotation??f.lo.Zero()).df()}else if("translation"===o){B=(mm.position??f.lo.Zero()).df()}else{B=(mm.rp??f.lo.One()).df()}return B}static _AddKeyframeValue(mm,o,u,O,r,w){let p;const K=o.dataType;if(K===Mm.d.ANIMATIONTYPE_VECTOR3){let o=mm.value.df();if("rotation"===O){const mm=f.lo.So(o);o=f.Quaternion.RotationYawPitchRoll(mm.y,mm.x,mm.z).df()}u.push(o)}else if(K===Mm.d.ANIMATIONTYPE_FLOAT){if("weights"===O)u.push([mm.value]);else if(p=this._ConvertFactorToVector3OrQuaternion(mm.value,r,o,O,w),p){if("rotation"===O){const mm=w?p:f.Quaternion.RotationYawPitchRoll(p.y,p.x,p.z).normalize();u.push(mm.df())}u.push(p.df())}}else K===Mm.d.ANIMATIONTYPE_QUATERNION?u.push(mm.value.normalize().df()):B.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(mm,o,u){let f,B,O=!1;if("rotation"===o&&!u)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let r=0,w=mm.length;r<w;++r)if(B=mm[r],B.inTangent||B.outTangent)if(f){if("CUBICSPLINE"!==f){f="LINEAR",O=!0;break}}else f="CUBICSPLINE";else if(f){if("CUBICSPLINE"===f||B.interpolation&&1===B.interpolation&&"STEP"!==f){f="LINEAR",O=!0;break}}else f=B.interpolation&&1===B.interpolation?"STEP":"LINEAR";return f||(f="LINEAR"),{interpolationType:f,shouldBakeAnimation:O}}static _AddSplineTangent(mm,o,u,B,O,r){let w;const p=mm===Ym.INTANGENT?O.inTangent:O.outTangent;if("CUBICSPLINE"===B){if("rotation"===u)if(p)if(r)w=p.df();else{const mm=p;w=f.Quaternion.RotationYawPitchRoll(mm.y,mm.x,mm.z).df()}else w=[0,0,0,0];else w="weights"===u?p?[p]:[0]:p?p.df():[0,0,0];o.push(w)}}static _CalculateMinMaxKeyFrames(mm){let o=1/0,u=-1/0;return mm.forEach((function(mm){o=Math.min(o,mm.frame),u=Math.max(u,mm.frame)})),{min:o,max:u}}}function Jm(mm,o,u,O,r,w){const p={attributes:{},influence:mm.influence,name:mm.name},K=o.br;if(!K)return B.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),p;const Y=w?-1:1,q=f.lo.Zero();let x=0,H=0;if(mm.hasPositions){const O=mm.getPositions(),w=K.getVerticesData(z.f.PositionKind);if(w){const mm=new Float32Array(w.length),o=[1/0,1/0,1/0],B=[-1/0,-1/0,-1/0];H=w.length/3,x=0;for(let u=x;u<H;++u){const r=f.lo.So(w,3*u);f.lo.So(O,3*u).subtractToRef(r,q),q.x*=Y,o[0]=Math.min(o[0],q.x),B[0]=Math.max(B[0],q.x),o[1]=Math.min(o[1],q.y),B[1]=Math.max(B[1],q.y),o[2]=Math.min(o[2],q.z),B[2]=Math.max(B[2],q.z),mm[3*u]=q.x,mm[3*u+1]=q.y,mm[3*u+2]=q.z}const K=u.createBufferView(mm,12),z=u.createAccessor(K,"VEC3",5126,O.length/3,0,{min:o,max:B});r.push(z),p.attributes.POSITION=r.length-1}else B.Tools.Warn(`Morph target positions for mesh ${o.name} were not exported. Mesh does not have position vertex data`)}if(mm.hasNormals){const O=mm.getNormals(),w=K.getVerticesData(z.f.NormalKind);if(w){const mm=new Float32Array(w.length);H=w.length/3,x=0;for(let u=x;u<H;++u){const o=f.lo.So(w,3*u).normalize();f.lo.So(O,3*u).normalize().subtractToRef(o,q),mm[3*u]=q.x*Y,mm[3*u+1]=q.y,mm[3*u+2]=q.z}const o=u.createBufferView(mm,12),B=u.createAccessor(o,"VEC3",5126,O.length/3,0);r.push(B),p.attributes.NORMAL=r.length-1}else B.Tools.Warn(`Morph target normals for mesh ${o.name} were not exported. Mesh does not have normals vertex data`)}if(mm.hasTangents){const O=mm.getTangents(),w=K.getVerticesData(z.f.TangentKind);if(w){H=w.length/4;const mm=new Float32Array(3*H);x=0;for(let u=x;u<H;++u){const o=f.lo.So(w,4*u);Z(o);const B=f.lo.So(O,3*u);Z(B),B.subtractToRef(o,q),mm[3*u]=q.x*Y,mm[3*u+1]=q.y,mm[3*u+2]=q.z}const o=u.createBufferView(mm,12),B=u.createAccessor(o,"VEC3",5126,H,0);r.push(B),p.attributes.TANGENT=r.length-1}else B.Tools.Warn(`Morph target tangents for mesh ${o.name} were not exported. Mesh does not have tangents vertex data`)}if(mm.hasColors){const O=mm.getColors(),w=K.getVerticesData(z.f.ColorKind),Y=K.getVertexBuffer(z.f.ColorKind);if(w&&Y){const mm=Y.getSize();H=w.length/mm;const o=new Float32Array(H*mm);x=0;for(let u=x;u<H;++u)if(3===mm){const B=f.lo.So(w,u*mm);f.lo.So(O,u*mm).subtractToRef(B,q),o[3*u]=q.x,o[3*u+1]=q.y,o[3*u+2]=q.z}else if(4===mm){const B=new f.Vector4,r=f.Vector4.So(w,u*mm);f.Vector4.So(O,u*mm).subtractToRef(r,B),o[4*u]=B.x,o[4*u+1]=B.y,o[4*u+2]=B.z,o[4*u+3]=B.w}else B.Tools.Warn(`Unsupported number of components for color attribute: ${mm}`);const K=u.createBufferView(o,4*mm),z=u.createAccessor(K,3===mm?"VEC3":"VEC4",5126,H,0);r.push(z),p.attributes.COLOR_0=r.length-1}else B.Tools.Warn(`Morph target colors for mesh ${o.name} were not exported. Mesh does not have colors vertex data`)}return p}var Nm=u(13260),Sm=u(13122),Pm=u(13109),Rm=u(12702);class gm{}gm.DEFAULT_COLOR=M.No.White(),gm.DEFAULT_WIDTH_ATTENUATED=1,gm.DEFAULT_WIDTH=.1;var Wm=u(12934),Fm=u(13264);class cm{static ConvertPoints(mm,o){if(mm.length&&Array.isArray(mm)&&"number"===typeof mm[0])return[mm];if(mm.length&&Array.isArray(mm[0])&&"number"===typeof mm[0][0])return mm;if(mm.length&&!Array.isArray(mm[0])&&mm[0]instanceof f.lo){const o=[];for(let u=0;u<mm.length;u++){const f=mm[u];o.push(f.x,f.y,f.z)}return[o]}if(mm.length>0&&Array.isArray(mm[0])&&mm[0].length>0&&mm[0][0]instanceof f.lo){const o=[],u=mm;for(const mm of u)o.push(mm.flatMap((mm=>[mm.x,mm.y,mm.z])));return o}if(mm instanceof Float32Array){if(null!==o&&void 0!==o&&o.floatArrayStride){const u=[],f=3*o.floatArrayStride;for(let o=0;o<mm.length;o+=f){const B=new Array(f);for(let u=0;u<f;u++)B[u]=mm[o+u];u.push(B)}return u}return[Array.from(mm)]}if(mm.length&&mm[0]instanceof Float32Array){const o=[];for(const u of mm)o.push(Array.from(u));return o}return[]}static OmitZeroLengthPredicate(mm,o,u){const f=[];return o.Qo(mm).lengthSquared()>0&&f.push([mm,o]),u.Qo(o).lengthSquared()>0&&f.push([o,u]),mm.Qo(u).lengthSquared()>0&&f.push([u,mm]),0===f.length?null:f}static OmitDuplicatesPredicate(mm,o,u,f){const B=[];return cm._SearchInPoints(mm,o,f)||B.push([mm,o]),cm._SearchInPoints(o,u,f)||B.push([o,u]),cm._SearchInPoints(u,mm,f)||B.push([u,mm]),0===B.length?null:B}static _SearchInPoints(mm,o,u){for(const r of u)for(let u=0;u<r.length;u++){var f,B,O;if(null!==(f=r[u])&&void 0!==f&&f.equals(mm))if(null!==(B=r[u+1])&&void 0!==B&&B.equals(o)||null!==(O=r[u-1])&&void 0!==O&&O.equals(o))return!0}return!1}static MeshesToLines(mm,o){const u=[];for(let B=0;B<mm.length;B++){const O=mm[B],r=O.getVerticesData(z.f.PositionKind),w=O.hr();if(r&&w)for(let mm=0,p=0;mm<w.length;mm++){const K=3*w[p++],z=3*w[p++],Y=3*w[p++],q=new f.lo(r[K],r[K+1],r[K+2]),x=new f.lo(r[z],r[z+1],r[z+2]),H=new f.lo(r[Y],r[Y+1],r[Y+2]);if(o){const f=o(q,x,H,u,mm,K,O,B,r,w);if(f)for(const mm of f)u.push(mm)}else u.push([q,x],[x,H],[H,q])}}return u}static ToVector3Array(mm){if(Array.isArray(mm[0])){const o=[],u=mm;for(const mm of u){const u=[];for(let o=0;o<mm.length;o+=3)u.push(new f.lo(mm[o],mm[o+1],mm[o+2]));o.push(u)}return o}const o=mm,u=[];for(let B=0;B<o.length;B+=3)u.push(new f.lo(o[B],o[B+1],o[B+2]));return u}static ToNumberArray(mm){return mm.flatMap((mm=>[mm.x,mm.y,mm.z]))}static GetPointsCountInfo(mm){const o=new Array(mm.length);let u=0;for(let f=mm.length;f--;)o[f]=mm[f].length/3,u+=o[f];return{total:u,counts:o}}static GetLineLength(mm){if(0===mm.length)return 0;let o;o="number"===typeof mm[0]?cm.ToVector3Array(mm):mm;const u=f.TmpVectors.lo[0];let B=0;for(let f=0;f<o.length-1;f++){const mm=o[f];B+=o[f+1].subtractToRef(mm,u).length()}return B}static GetLineLengthArray(mm){const o=new Float32Array(mm.length/3);let u=0;for(let f=0,B=mm.length/3-1;f<B;f++){let B=mm[3*f+0],O=mm[3*f+1],r=mm[3*f+2];B-=mm[3*f+3],O-=mm[3*f+4],r-=mm[3*f+5];u+=Math.sqrt(B*B+O*O+r*r),o[f+1]=u}return o}static SegmentizeSegmentByCount(mm,o,u){const B=[],O=o.Qo(mm),r=f.TmpVectors.lo[0];r.wp(u);const w=f.TmpVectors.lo[1];O.divideToRef(r,w);let p=mm.clone();B.push(p);for(let f=0;f<u;f++)p=p.clone(),B.push(p.addInPlace(w));return B}static SegmentizeLineBySegmentLength(mm,o){const u=mm[0]instanceof f.lo?cm.GetLineSegments(mm):"number"===typeof mm[0]?cm.GetLineSegments(cm.ToVector3Array(mm)):mm,B=[];for(const f of u)if(f.length>o){const mm=cm.SegmentizeSegmentByCount(f.point1,f.point2,Math.ceil(f.length/o));for(const o of mm)B.push(o)}else B.push(f.point1),B.push(f.point2);return B}static SegmentizeLineBySegmentCount(mm,o){const u="number"===typeof mm[0]?cm.ToVector3Array(mm):mm,f=cm.GetLineLength(u)/o;return cm.SegmentizeLineBySegmentLength(u,f)}static GetLineSegments(mm){const o=[];for(let u=0;u<mm.length-1;u++){const f=mm[u],B=mm[u+1],O=B.Qo(f).length();o.push({point1:f,point2:B,length:O})}return o}static GetMinMaxSegmentLength(mm){const o=cm.GetLineSegments(mm).sort((mm=>mm.length));return{min:o[0].length,max:o[o.length-1].length}}static GetPositionOnLineByVisibility(mm,o,u){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const O=o*u;let r=0,w=0;const p=mm.length;for(let f=0;f<p;f++){if(O<=r+mm[f].length){w=f;break}r+=mm[f].length}const K=(O-r)/mm[w].length;return mm[w].point2.subtractToRef(mm[w].point1,f.TmpVectors.lo[0]),f.TmpVectors.lo[1]=f.TmpVectors.lo[0].multiplyByFloats(K,K,K),B||f.TmpVectors.lo[1].addInPlace(mm[w].point1),f.TmpVectors.lo[1].clone()}static GetCircleLinePoints(mm,o){let u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:mm,O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/o;const r=[];for(let w=0;w<=o;w++)r.push(new f.lo(Math.cos(w*O)*mm,Math.sin(w*O)*B,u));return r}static GetBezierLinePoints(mm,o,u,f){return Wm.h.CreateQuadraticBezier(mm,o,u,f).getPoints().flatMap((mm=>[mm.x,mm.y,mm.z]))}static GetArrowCap(mm,o,u,f,B){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,r=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[mm.clone(),mm.add(o.multiplyByFloats(u,u,u))],widths:[f,B,O,r]}}static GetPointsFromText(mm,o,u,f){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const r=[],w=(0,Fm.c)(mm,o,u,f);for(const p of w){for(const mm of p.paths){const o=[],u=mm.getPoints();for(const mm of u)o.push(mm.x,mm.y,B);r.push(o)}if(O)for(const mm of p.holes){const o=[],u=mm.getPoints();for(const mm of u)o.push(mm.x,mm.y,B);r.push(o)}}return r}static Color3toRGBAUint8(mm){const o=new Uint8Array(4*mm.length);for(let u=0,f=0;u<mm.length;u++)o[f++]=255*mm[u].r,o[f++]=255*mm[u].g,o[f++]=255*mm[u].b,o[f++]=255;return o}static CreateColorsTexture(mm,o,u,f){const B=f.getEngine().getCaps().maxTextureSize??1,O=o.length>B?B:o.length,r=Math.ceil(o.length/B);r>1&&(o=[...o,...Array(O*r-o.length).fill(o[0])]);const w=cm.Color3toRGBAUint8(o),p=new N.d(w,O,r,H.b.TEXTUREFORMAT_RGBA,f,!1,!0,u);return p.name=mm,p}static PrepareEmptyColorsTexture(mm){if(!gm.EmptyColorsTexture){const o=new Uint8Array(4);gm.EmptyColorsTexture=new N.d(o,1,1,H.b.TEXTUREFORMAT_RGBA,mm,!1,!1,N.d.NEAREST_NEAREST),gm.EmptyColorsTexture.name="grlEmptyColorsTexture"}return gm.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var mm;null===(mm=gm.EmptyColorsTexture)||void 0===mm||mm.dispose(),gm.EmptyColorsTexture=null}static BooleanToNumber(mm){return mm?1:0}}class Am extends Pm.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class ym extends Sm.d{isCompatible(mm){return!0}constructor(mm,o,u){var B;u=u||{color:gm.DEFAULT_COLOR};const O=new Am;O.GREASED_LINE_HAS_COLOR=!!u.color&&!u.useColors,O.GREASED_LINE_SIZE_ATTENUATION=u.sizeAttenuation??!1,O.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===u.colorDistributionType,O.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(o??mm.Pm()).useRightHandedSystem,O.GREASED_LINE_CAMERA_FACING=u.cameraFacing??!0,super(mm,ym.GREASED_LINE_MATERIAL_NAME,200,O,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(B=u)||void 0===B?void 0:B.forceGLSL)||ym.ForceGLSL,this._scene=o??mm.Pm(),this._engine=this._scene.getEngine(),this._cameraFacing=u.cameraFacing??!0,this.visibility=u.visibility??1,this.useDash=u.useDash??!1,this.dashRatio=u.dashRatio??.5,this.dashOffset=u.dashOffset??0,this.width=u.width?u.width:u.sizeAttenuation?gm.DEFAULT_WIDTH_ATTENUATED:gm.DEFAULT_WIDTH,this._sizeAttenuation=u.sizeAttenuation??!1,this.colorMode=u.colorMode??0,this._color=u.color??null,this.useColors=u.useColors??!1,this._colorsDistributionType=u.colorDistributionType??0,this.colorsSampling=u.colorsSampling??N.d.NEAREST_NEAREST,this._colors=u.Fm??null,this.dashCount=u.dashCount??1,this.resolution=u.resolution??new f.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),u.colorsTexture?this.colorsTexture=u.colorsTexture:this._colors?this.colorsTexture=cm.CreateColorsTexture(`${mm.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??gm.DEFAULT_COLOR,cm.PrepareEmptyColorsTexture(this._scene)),this._engine.Jf.add((()=>{cm.DisposeEmptyColorsTexture()}))}getAttributes(mm){mm.push("grl_offsets"),mm.push("grl_widths"),mm.push("grl_colorPointers"),mm.push("grl_counters"),this._cameraFacing?(mm.push("grl_previousAndSide"),mm.push("grl_nextAndCounters")):mm.push("grl_slopes")}getSamplers(mm){mm.push("grl_colors")}getActiveTextures(mm){this.colorsTexture&&mm.push(this.colorsTexture)}getUniforms(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const o=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&o.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===mm&&o.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:o,vertex:this._cameraFacing&&this._isGLSL(mm)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(mm)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(mm){if(this._cameraFacing){mm.Tf("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||mm.Tf("viewProjection",this._scene.getTransformMatrix());const o=f.TmpVectors.Vector4[0];o.x=this._aspect,o.y=this._resolution.x,o.z=this._resolution.y,o.w=this.width,mm.updateVector4("grl_aspect_resolution_lineWidth",o)}const o=f.TmpVectors.Vector4[0];o.x=cm.BooleanToNumber(this.useDash),o.y=this._dashArray,o.z=this.dashOffset,o.w=this.dashRatio,mm.updateVector4("grl_dashOptions",o);const u=f.TmpVectors.Vector4[1];u.x=this.colorMode,u.y=this.visibility,u.z=this.colorsTexture?this.colorsTexture.getSize().width:0,u.w=cm.BooleanToNumber(this.useColors),mm.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",u),this._color&&mm.updateColor3("grl_singleColor",this._color);const B=this.colorsTexture??gm.EmptyColorsTexture;mm.setTexture("grl_colors",B),mm.updateFloat2("grl_textureSize",(null===B||void 0===B?void 0:B.getSize().width)??1,(null===B||void 0===B?void 0:B.getSize().height)??1)}prepareDefines(mm,o,u){mm.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,mm.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,mm.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,mm.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=o.useRightHandedSystem,mm.GREASED_LINE_CAMERA_FACING=this._cameraFacing,mm.GREASED_LINE_USE_OFFSETS=!!u.offsets}getClassName(){return ym.GREASED_LINE_MATERIAL_NAME}getCustomCode(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(o)?function(mm,o){if("vertex"===mm){const mm={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return o&&(mm["!gl_Position\\=viewProjection\\*worldPos;"]="//"),mm}return"fragment"===mm?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(mm,this._cameraFacing):function(mm,o){if("vertex"===mm){const mm={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return o&&(mm["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),mm}return"fragment"===mm?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(mm,this._cameraFacing)}dispose(){var mm;null===(mm=this.colorsTexture)||void 0===mm||mm.dispose(),super.dispose()}get Fm(){return this._colors}set Fm(mm){this.setColors(mm)}setColors(mm){var o;let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1],f=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=(null===(o=this._colors)||void 0===o?void 0:o.length)??0;var O;if(this._colors=mm,null!==mm&&0!==mm.length){if(!u||f)if(this.colorsTexture&&B===mm.length&&!f){const o=cm.Color3toRGBAUint8(mm);this.colorsTexture.update(o)}else{var r;null===(r=this.colorsTexture)||void 0===r||r.dispose(),this.colorsTexture=cm.CreateColorsTexture(`${this._material.name}-colors-texture`,mm,this.colorsSampling,this._scene)}}else null===(O=this.colorsTexture)||void 0===O||O.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(mm){this._dashCount=mm,this._dashArray=1/mm}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(mm){this._sizeAttenuation=mm,this.markAllDefinesAsDirty()}get color(){return this._color}set color(mm){this.setColor(mm)}setColor(mm){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==mm||null!==this._color&&null===mm?(this._color=mm,o||this.markAllDefinesAsDirty()):this._color=mm}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(mm){this._colorsDistributionType=mm,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(mm){this._aspect=mm.x/mm.y,this._resolution=mm}serialize(){const mm=super.serialize(),o={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(o.Fm=this._colors),this._color&&(o.color=this._color),mm.greasedLineMaterialOptions=o,mm}parse(mm,o,u){var f;super.parse(mm,o,u);const B=mm.greasedLineMaterialOptions;null===(f=this.colorsTexture)||void 0===f||f.dispose(),B.color&&this.setColor(B.color,!0),B.colorDistributionType&&(this.colorsDistributionType=B.colorDistributionType),B.Fm&&(this.Fm=B.Fm),B.colorsSampling&&(this.colorsSampling=B.colorsSampling),B.colorMode&&(this.colorMode=B.colorMode),B.useColors&&(this.useColors=B.useColors),B.visibility&&(this.visibility=B.visibility),B.useDash&&(this.useDash=B.useDash),B.dashCount&&(this.dashCount=B.dashCount),B.dashRatio&&(this.dashRatio=B.dashRatio),B.dashOffset&&(this.dashOffset=B.dashOffset),B.width&&(this.width=B.width),B.sizeAttenuation&&(this.sizeAttenuation=B.sizeAttenuation),B.resolution&&(this.resolution=B.resolution),this.Fm?this.colorsTexture=cm.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Fm,this.colorsSampling,o):cm.PrepareEmptyColorsTexture(o),this.markAllDefinesAsDirty()}copyTo(mm){var o;const u=mm;null===(o=u.colorsTexture)||void 0===o||o.dispose(),this._colors&&(u.colorsTexture=cm.CreateColorsTexture(`${u._material.name}-colors-texture`,this._colors,u.colorsSampling,this._scene)),u.setColor(this.color,!0),u.colorsDistributionType=this.colorsDistributionType,u.colorsSampling=this.colorsSampling,u.colorMode=this.colorMode,u.useColors=this.useColors,u.visibility=this.visibility,u.useDash=this.useDash,u.dashCount=this.dashCount,u.dashRatio=this.dashRatio,u.dashOffset=this.dashOffset,u.width=this.width,u.sizeAttenuation=this.sizeAttenuation,u.resolution=this.resolution,u.markAllDefinesAsDirty()}_isGLSL(mm){return 0===mm||this._forceGLSL}}ym.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",ym.ForceGLSL=!1,(0,Rm.c)(`BABYLON.${ym.GREASED_LINE_MATERIAL_NAME}`,ym);var Im=u(13151),sm=u(12574),jm=u(12960),am=u(12680);class Xm extends jm.ShaderMaterial{constructor(mm,o,B){const O=o.getEngine(),r=O.isWebGPU&&!(B.forceGLSL||Xm.ForceGLSL),w=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];o.useRightHandedSystem&&w.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const p=["position","grl_widths","grl_offsets","grl_colorPointers"];B.cameraFacing?(w.push("GREASED_LINE_CAMERA_FACING"),p.push("grl_previousAndSide","grl_nextAndCounters")):(p.push("grl_slopes"),p.push("grl_counters"));const K=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(r||K.push("world","viewProjection","view","projection"),super(mm,o,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:r?["Scene","Mesh"]:void 0,attributes:p,uniforms:K,samplers:r?[]:["grlColors"],defines:w,extraInitializationsAsync:async()=>{r?await Promise.all([u.e(66).then(u.bind(u,15729)),u.e(75).then(u.bind(u,15736))]):await Promise.all([u.e(69).then(u.bind(u,15740)),u.e(76).then(u.bind(u,15742))])},shaderLanguage:r?1:0}),this._color=M.No.White(),this._colorsDistributionType=0,this._colorsTexture=null,B=B||{color:gm.DEFAULT_COLOR},this.visibility=B.visibility??1,this.useDash=B.useDash??!1,this.dashRatio=B.dashRatio??.5,this.dashOffset=B.dashOffset??0,this.dashCount=B.dashCount??1,this.width=B.width?B.width:B.sizeAttenuation&&B.cameraFacing?gm.DEFAULT_WIDTH_ATTENUATED:gm.DEFAULT_WIDTH,this.sizeAttenuation=B.sizeAttenuation??!1,this.color=B.color??M.No.White(),this.useColors=B.useColors??!1,this.colorsDistributionType=B.colorDistributionType??0,this.colorsSampling=B.colorsSampling??N.d.NEAREST_NEAREST,this.colorMode=B.colorMode??0,this._colors=B.Fm??null,this._cameraFacing=B.cameraFacing??!0,this.resolution=B.resolution??new f.Vector2(O.getRenderWidth(),O.getRenderHeight()),B.colorsTexture?this.colorsTexture=B.colorsTexture:this._colors?this.colorsTexture=cm.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,o):(this._color=this._color??gm.DEFAULT_COLOR,this.colorsTexture=cm.PrepareEmptyColorsTexture(o)),r){const mm=new am.e;mm.setParameters(),mm.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",mm)}O.Jf.add((()=>{cm.DisposeEmptyColorsTexture()}))}dispose(){var mm;null===(mm=this._colorsTexture)||void 0===mm||mm.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new f.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Fm(){return this._colors}set Fm(mm){this.setColors(mm)}setColors(mm){var o;let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1],f=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=(null===(o=this._colors)||void 0===o?void 0:o.length)??0;var O;if(this._colors=mm,null!==mm&&0!==mm.length){if(!u||f)if(this._colorsTexture&&B===mm.length&&!f){const o=cm.Color3toRGBAUint8(mm);this._colorsTexture.update(o)}else{var r;null===(r=this._colorsTexture)||void 0===r||r.dispose(),this.colorsTexture=cm.CreateColorsTexture(`${this.name}-colors-texture`,mm,this.colorsSampling,this.Pm())}}else null===(O=this._colorsTexture)||void 0===O||O.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(mm){this._colorsTexture=mm,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(mm){this._width=mm,this.setFloat("grlWidth",mm)}get useColors(){return this._useColors}set useColors(mm){this._useColors=mm,this.setFloat("grlUseColors",cm.BooleanToNumber(mm))}get colorsSampling(){return this._colorsSampling}set colorsSampling(mm){this._colorsSampling=mm}get visibility(){return this._visibility}set visibility(mm){this._visibility=mm,this.setFloat("grlVisibility",mm)}get useDash(){return this._useDash}set useDash(mm){this._useDash=mm,this.setFloat("grlUseDash",cm.BooleanToNumber(mm))}get dashOffset(){return this._dashOffset}set dashOffset(mm){this._dashOffset=mm,this.setFloat("grlDashOffset",mm)}get dashRatio(){return this._dashRatio}set dashRatio(mm){this._dashRatio=mm,this.setFloat("grlDashRatio",mm)}get dashCount(){return this._dashCount}set dashCount(mm){this._dashCount=mm,this._dashArray=1/mm,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(mm){this._sizeAttenuation=mm,this.setFloat("grlSizeAttenuation",cm.BooleanToNumber(mm))}get color(){return this._color}set color(mm){this.setColor(mm)}setColor(mm){mm=mm??gm.DEFAULT_COLOR,this._color=mm,this.setColor3("grlColor",mm)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(mm){this._colorsDistributionType=mm,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(mm){this._colorMode=mm,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(mm){this._resolution=mm,this.setVector2("grlResolution",mm),this.setFloat("grlAspect",mm.x/mm.y)}serialize(){const mm=super.serialize(),o={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(o.Fm=this._colors),mm.greasedLineMaterialOptions=o,mm}parse(mm,o,u){var f;const B=mm.greasedLineMaterialOptions;null===(f=this._colorsTexture)||void 0===f||f.dispose(),B.color&&(this.color=B.color),B.colorDistributionType&&(this.colorsDistributionType=B.colorDistributionType),B.colorsSampling&&(this.colorsSampling=B.colorsSampling),B.colorMode&&(this.colorMode=B.colorMode),B.useColors&&(this.useColors=B.useColors),B.visibility&&(this.visibility=B.visibility),B.useDash&&(this.useDash=B.useDash),B.dashCount&&(this.dashCount=B.dashCount),B.dashRatio&&(this.dashRatio=B.dashRatio),B.dashOffset&&(this.dashOffset=B.dashOffset),B.width&&(this.width=B.width),B.sizeAttenuation&&(this.sizeAttenuation=B.sizeAttenuation),B.resolution&&(this.resolution=B.resolution),B.Fm?this.colorsTexture=cm.CreateColorsTexture(`${this.name}-colors-texture`,B.Fm,this.colorsSampling,this.Pm()):this.colorsTexture=cm.PrepareEmptyColorsTexture(o),this._cameraFacing=B.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Gm,km,dm;Xm.ForceGLSL=!1,function(mm){mm[mm.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",mm[mm.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Gm||(Gm={})),function(mm){mm[mm.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",mm[mm.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",mm[mm.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(km||(km={})),function(mm){mm[mm.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",mm[mm.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",mm[mm.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",mm[mm.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",mm[mm.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(dm||(dm={}));class em extends tm.d{constructor(mm,o,u){super(mm,o,null,null,!1,!1),this.name=mm,this._options=u,this._lazy=!1,this._updatable=!1,this._engine=o.getEngine(),this._lazy=u.lazy??!1,this._updatable=u.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=u.colorPointers??[],this._widths=u.widths??new Array(u.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(mm){let o=0;for(const f of this._points)o+=f.length;const u=o/3*2-this._widths.length;for(let f=0;f<u;f++)this._widths.push(mm)}updateLazy(){var mm,o;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(mm=this._options.ribbonOptions)||void 0===mm?void 0:mm.smoothShading),!this.sm&&this.refreshBoundingInfo(),null===(o=this.greasedLineMaterial)||void 0===o||o.updateLazy()}addPoints(mm,o){for(const u of mm)this._points.push(u);this._lazy||this.setPoints(this._points,o)}dispose(mm){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(mm,o)}isLazy(){return this._lazy}get Am(){return this._uvs}set Am(mm){this._uvs=mm instanceof Float32Array?mm:new Float32Array(mm),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(mm){this.material instanceof Xm&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===mm||void 0===mm?void 0:mm.length)>0),this._offsets=mm,this._offsetsBuffer?this._offsetsBuffer.update(mm):this._createOffsetsBuffer(mm)}get widths(){return this._widths}set widths(mm){this._widths=mm,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(mm)}get colorPointers(){return this._colorPointers}set colorPointers(mm){this._colorPointers=mm,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(mm)}get greasedLineMaterial(){var mm,o;if(this.material&&this.material instanceof Xm)return this.material;const u=null===(mm=this.material)||void 0===mm||null===(o=mm.pluginManager)||void 0===o?void 0:o.getPlugin(ym.GREASED_LINE_MATERIAL_NAME);return u||void 0}get points(){const mm=[];return sm.b.DeepCopy(this._points,mm),mm}setPoints(mm,o){this._points=cm.ConvertPoints(mm,(null===o||void 0===o?void 0:o.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==o&&void 0!==o&&o.colorPointers||this._updateColorPointers(),this._setPoints(this._points,o)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Am:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(mm){super.serialize(mm),mm.type=this.getClassName(),mm.lineOptions=this._createLineOptions()}_createVertexBuffers(){let mm=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const o=new Im.b;return o.gm=this._vertexPositions,o.indices=this._indices,o.Am=this._uvs,mm&&(o.Wm=[],Im.b.ComputeNormals(this._vertexPositions,this._indices,o.Wm)),o.Im(this,this._options.updatable),o}_createOffsetsBuffer(mm){const o=this._scene.getEngine(),u=new z.c(o,mm,this._updatable,3);this.setVerticesBuffer(u.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=u}}class Lm{constructor(mm,o){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=mm,this.wasAddedByNoopNode=o}getIndicesAccessor(mm,o,u,f,B){var O,r,w,p;return null===(O=this._indicesAccessorMap.get(mm))||void 0===O||null===(r=O.get(o))||void 0===r||null===(w=r.get(u))||void 0===w||null===(p=w.get(f))||void 0===p?void 0:p.get(B)}setIndicesAccessor(mm,o,u,f,B,O){let r=this._indicesAccessorMap.get(mm);r||(r=new Map,this._indicesAccessorMap.set(mm,r));let w=r.get(o);w||(w=new Map,r.set(o,w));let p=w.get(u);p||(p=new Map,w.set(u,p));let K=p.get(f);K||(K=new Map,p.set(f,K)),K.set(B,O)}pushExportedNode(mm){this._exportedNodes.has(mm)||this._exportedNodes.add(mm)}getNodesSet(){return this._exportedNodes}getVertexBufferView(mm){return this._vertexBufferViewMap.get(mm)}setVertexBufferView(mm,o){this._vertexBufferViewMap.set(mm,o)}setRemappedBufferView(mm,o,u){this._remappedBufferView.set(mm,new Map),this._remappedBufferView.get(mm).set(o,u)}getRemappedBufferView(mm,o){var u;return null===(u=this._remappedBufferView.get(mm))||void 0===u?void 0:u.get(o)}getVertexAccessor(mm,o,u){var f,B;return null===(f=this._vertexAccessorMap.get(mm))||void 0===f||null===(B=f.get(o))||void 0===B?void 0:B.get(u)}setVertexAccessor(mm,o,u,f){let B=this._vertexAccessorMap.get(mm);B||(B=new Map,this._vertexAccessorMap.set(mm,B));let O=B.get(o);O||(O=new Map,B.set(o,O)),O.set(u,f)}hasVertexColorAlpha(mm){return this._vertexMapColorAlpha.get(mm)||!1}setHasVertexColorAlpha(mm,o){return this._vertexMapColorAlpha.set(mm,o)}getMesh(mm){return this._meshMap.get(mm)}setMesh(mm,o){this._meshMap.set(mm,o)}bindMorphDataToMesh(mm,o){const u=this._meshMorphTargetMap.get(mm)||[];this._meshMorphTargetMap.set(mm,u),-1===u.indexOf(o)&&u.push(o)}getMorphTargetsFromMesh(mm){return this._meshMorphTargetMap.get(mm)}}class Cm{_ApplyExtension(mm,o,u,f){if(u>=o.length)return Promise.resolve(mm);const B=f(o[u],mm);return B?B.then((async mm=>mm?await this._ApplyExtension(mm,o,u+1,f):null)):this._ApplyExtension(mm,o,u+1,f)}_ApplyExtensions(mm,o){const u=[];for(const f of Cm._ExtensionNames)u.push(this._extensions[f]);return this._ApplyExtension(mm,u,0,o)}_extensionsPreExportTextureAsync(mm,o,u){return this._ApplyExtensions(o,((o,f)=>o.preExportTextureAsync&&o.preExportTextureAsync(mm,f,u)))}_extensionsPostExportNodeAsync(mm,o,u,f,B){return this._ApplyExtensions(o,((o,O)=>o.postExportNodeAsync&&o.postExportNodeAsync(mm,O,u,f,B,this._bufferManager)))}_extensionsPostExportMaterialAsync(mm,o,u){return this._ApplyExtensions(o,((o,f)=>o.postExportMaterialAsync&&o.postExportMaterialAsync(mm,f,u)))}_extensionsPostExportMaterialAdditionalTextures(mm,o,u){const f=[];for(const B of Cm._ExtensionNames){const O=this._extensions[B];O.postExportMaterialAdditionalTextures&&f.push(...O.postExportMaterialAdditionalTextures(mm,o,u))}return f}_extensionsPostExportTextures(mm,o,u){for(const f of Cm._ExtensionNames){const B=this._extensions[f];B.postExportTexture&&B.postExportTexture(mm,o,u)}}_extensionsPostExportMeshPrimitive(mm){for(const o of Cm._ExtensionNames){const u=this._extensions[o];u.postExportMeshPrimitive&&u.postExportMeshPrimitive(mm,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const mm of Cm._ExtensionNames){const o=this._extensions[mm];o.preGenerateBinaryAsync&&await o.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(mm){for(const o of Cm._ExtensionNames){const u=this._extensions[o];u.enabled&&mm(u)}}_extensionsOnExporting(){this._forEachExtensions((mm=>{var o,u,f;mm.wasUsed&&((o=this._glTF).extensionsUsed||(o.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(mm.name)&&this._glTF.extensionsUsed.push(mm.name),mm.required&&((u=this._glTF).extensionsRequired||(u.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(mm.name)&&this._glTF.extensionsRequired.push(mm.name)),(f=this._glTF).extensions||(f.extensions={}),mm.onExporting&&mm.onExporting())}))}_loadExtensions(){for(const mm of Cm._ExtensionNames){const o=Cm._ExtensionFactories[mm](this);this._extensions[mm]=o}}constructor(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:E.d.LastCreatedScene,o=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${H.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new a(this),this._extensions={},this._bufferManager=new zm,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!mm)throw new Error("No scene available to export");this._babylonScene=mm,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:mm=>{var o;return null===mm||void 0===mm||null===(o=mm.Af)||void 0===o?void 0:o.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...o},this._loadExtensions()}dispose(){for(const mm in this._extensions){this._extensions[mm].dispose()}}get options(){return this._options}static RegisterExtension(mm,o){Cm.UnregisterExtension(mm)&&B.Tools.Warn(`Extension with the name ${mm} already exists`),Cm._ExtensionFactories[mm]=o,Cm._ExtensionNames.push(mm)}static UnregisterExtension(mm){if(!Cm._ExtensionFactories[mm])return!1;delete Cm._ExtensionFactories[mm];const o=Cm._ExtensionNames.indexOf(mm);return-1!==o&&Cm._ExtensionNames.splice(o,1),!0}_generateJSON(mm,o,u){const f={byteLength:mm};return f.byteLength&&(this._glTF.buffers=[f]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.bo=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(f.uri=o+".bin"),u?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(mm){const o=await this._generateBinaryAsync();this._extensionsOnExporting();const u=this._generateJSON(o.byteLength,mm,!0),f=new Blob([o],{type:"application/octet-stream"}),B=mm+".gltf",O=mm+".bin",r=new K;if(r.files[B]=u,r.files[O]=f,this._imageData)for(const w in this._imageData)r.files[w]=new Blob([this._imageData[w].data],{type:this._imageData[w].mimeType});return r}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(mm){const o=mm%4;return 0===o?o:4-o}async generateGLBAsync(mm){this._shouldUseGlb=!0;const o=await this._generateBinaryAsync();this._extensionsOnExporting();const u=this._generateJSON(o.byteLength),f=mm+".glb";let B,O=u.length;if("undefined"!==typeof TextEncoder){B=(new TextEncoder).encode(u),O=B.length}const r=this._getPadding(O),w=this._getPadding(o.byteLength),p=28+O+r+o.byteLength+w,z=new pm(p);if(z.writeUInt32(1179937895),z.writeUInt32(2),z.writeUInt32(p),z.writeUInt32(O+r),z.writeUInt32(1313821514),B)z.writeTypedArray(B);else{const mm="_".charCodeAt(0);for(let o=0;o<O;++o){const f=u.charCodeAt(o);f!=u.codePointAt(o)?z.writeUInt8(mm):z.writeUInt8(f)}}for(let K=0;K<r;++K)z.writeUInt8(32);z.writeUInt32(o.byteLength+w),z.writeUInt32(5130562),z.writeTypedArray(o);for(let K=0;K<w;++K)z.writeUInt8(0);const Y=new K;return Y.files[f]=new Blob([z.getOutputData()],{type:"application/octet-stream"}),Y}_setNodeTransformation(mm,o,u){if(o.getPivotPoint().equalsWithEpsilon(e,d.e)||B.Tools.Warn("Pivot points are not supported in the glTF serializer"),!o.position.equalsWithEpsilon(e,d.e)){const B=f.TmpVectors.lo[0].p(o.position);u&&T(B),mm.translation=B.df()}o.rp.equalsWithEpsilon(C,d.e)||(mm.scale=o.rp.df());const O=o.rotationQuaternion||f.Quaternion.FromEulerAngles(o.rotation.x,o.rotation.y,o.rotation.z);O.equalsWithEpsilon(L,d.e)||(u&&D(O),mm.rotation=O.normalize().df())}_setCameraTransformation(mm,o,u){if(!o.position.equalsWithEpsilon(e,d.e)){const B=f.TmpVectors.lo[0].p(o.position);u&&T(B),mm.translation=B.df()}const B=o.rotationQuaternion||f.Quaternion.FromEulerAngles(o.rotation.x,o.rotation.y,o.rotation.z);u&&D(B),this._babylonScene.useRightHandedSystem||i(B),B.equalsWithEpsilon(L,d.e)||(mm.rotation=B.df())}_listAvailableCameras(){for(const mm of this._babylonScene.cameras){const o={type:mm.mode===qm.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(mm.name&&(o.name=mm.name),"perspective"===o.type)o.perspective={aspectRatio:mm.getEngine().getAspectRatio(mm),yfov:mm.fovMode===qm.b.FOVMODE_VERTICAL_FIXED?mm.fov:mm.fov*mm.getEngine().getAspectRatio(mm),znear:mm.hf,zfar:mm.maxZ};else if("orthographic"===o.type){const u=mm.orthoLeft&&mm.orthoRight?.5*(mm.orthoRight-mm.orthoLeft):.5*mm.getEngine().getRenderWidth(),f=mm.orthoBottom&&mm.orthoTop?.5*(mm.orthoTop-mm.orthoBottom):.5*mm.getEngine().getRenderHeight();o.orthographic={xmag:u,ymag:f,znear:mm.hf,zfar:mm.maxZ}}this._camerasMap.set(mm,o)}}_exportAndAssignCameras(){const mm=Array.from(this._camerasMap.values());for(const o of mm){const mm=this._nodesCameraMap.get(o);if(void 0!==mm){this._cameras.push(o);for(const o of mm)o.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const mm of this._babylonScene.skeletons){if(mm.bones.length<=0)continue;const o={joints:[]};this._skinMap.set(mm,o)}}_exportAndAssignSkeletons(){for(const mm of this._babylonScene.skeletons){if(mm.bones.length<=0)continue;const o=this._skinMap.get(mm);if(void 0==o)continue;const u={},f=[];let O=-1;for(let B=0;B<mm.bones.length;++B){const o=mm.bones[B],f=o.getIndex()??B;-1!==f&&(u[f]=o,f>O&&(O=f))}for(let mm=0;mm<=O;++mm){const O=u[mm];f.push(O.getAbsoluteInverseBindMatrix());const r=O.getTransformNode();if(null!==r){const mm=this._nodeMap.get(r);r&&null!==mm&&void 0!==mm?o.joints.push(mm):B.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else B.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const r=this._nodesSkinMap.get(o);if(o.joints.length>0&&void 0!==r){const mm=64*f.length,u=new Float32Array(mm/4);f.forEach(((mm,o)=>{u.set(mm.m,16*o)}));const B=this._bufferManager.createBufferView(u);this._accessors.push(this._bufferManager.createAccessor(B,"MAT4",5126,f.length)),o.inverseBindMatrices=this._accessors.length-1,this._skins.push(o);for(const o of r)o.skin=this._skins.length-1}}}async _exportSceneAsync(){const mm={nodes:[]};if(this._babylonScene.metadata){const o=this._options.metadataSelector(this._babylonScene.metadata);o&&(mm.extras=o)}const o=new Array,u=new Array,f=new Array;for(const w of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&rm(w,this._babylonScene.useRightHandedSystem)?f.push(...w.getChildren()):this._babylonScene.useRightHandedSystem?o.push(w):u.push(w);this._listAvailableCameras(),this._listAvailableSkeletons();const B=new Lm(!0,!1);mm.nodes.push(...await this._exportNodesAsync(u,B));const O=new Lm(!1,!1);mm.nodes.push(...await this._exportNodesAsync(o,O));const r=new Lm(!1,!0);mm.nodes.push(...await this._exportNodesAsync(f,r)),mm.nodes.length&&this._scenes.push(mm),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&bm._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,B.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(mm){let o=this._shouldExportNodeMap.get(mm);return void 0===o&&(o=this._options.shouldExportNode(mm),this._shouldExportNodeMap.set(mm,o)),o}async _exportNodesAsync(mm,o){const u=new Array;this._exportBuffers(mm,o);for(const f of mm)await this._exportNodeAsync(f,u,o);return u}_collectBuffers(mm,o,u,f,B){if(this._shouldExportNode(mm)&&mm instanceof q.b&&mm.br){const O=mm.br.getVertexBuffers();if(O)for(const f in O){if(!U(f))continue;const r=O[f];B.setHasVertexColorAlpha(r,mm.hasVertexAlpha);const w=r._buffer,p=o.get(w)||[];o.set(w,p),-1===p.indexOf(r)&&p.push(r);const K=u.get(r)||[];u.set(r,K),-1===K.indexOf(mm)&&K.push(mm)}const r=mm.morphTargetManager;if(r)for(let o=0;o<r.numTargets;o++){const u=r.getTarget(o),B=f.get(u)||[];f.set(u,B),-1===B.indexOf(mm)&&B.push(mm)}}for(const O of mm.getChildren())this._collectBuffers(O,o,u,f,B)}_exportBuffers(mm,o){const u=new Map,f=new Map,B=new Map;for(const w of mm)this._collectBuffers(w,u,f,B,o);const O=Array.from(u.keys());for(const w of O){const mm=w.getData();if(!mm)throw new Error("Buffer data is not available");const B=u.get(w);if(!B)continue;const O=B[0].byteStride;if(B.some((mm=>mm.byteStride!==O)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const r=um(mm).slice();for(const o of B){const mm=f.get(o),{byteOffset:u,byteStride:B,componentCount:O,type:w,count:p,normalized:K,kind:Y}=V(o,mm);switch(Y){case z.f.NormalKind:case z.f.TangentKind:(0,X.f)(r,u,B,O,w,p,K,(mm=>{const o=Math.sqrt(mm[0]*mm[0]+mm[1]*mm[1]+mm[2]*mm[2]);if(o>0){const u=1/o;mm[0]*=u,mm[1]*=u,mm[2]*=u}}));break;case z.f.ColorKind:{const o=mm.filter((mm=>mm.material instanceof Em.Jo||null==mm.material)).length;if(0==o)break;if(o!=mm.length){G.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}w==z.f.UNSIGNED_BYTE&&G.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const f=new M.No,Y=new M.pp,q=this._babylonScene.getEngine().useExactSrgbConversions;(0,X.f)(r,u,B,O,w,p,K,(mm=>{3===mm.length?(f.bu(mm,0),f.toLinearSpaceToRef(f,q),f.toArray(mm,0)):(Y.bu(mm,0),Y.toLinearSpaceToRef(Y,q),Y.toArray(mm,0))}))}}}if(o.convertToRightHanded){for(const mm of B){const o=f.get(mm),{byteOffset:u,byteStride:B,componentCount:O,type:w,count:p,normalized:K,kind:Y}=V(mm,o);switch(Y){case z.f.PositionKind:case z.f.NormalKind:case z.f.TangentKind:(0,X.f)(r,u,B,O,w,p,K,(mm=>{mm[0]=-mm[0]}))}}o.convertedToRightHandedBuffers.set(w,r)}const p=this._bufferManager.createBufferView(r,O);o.setVertexBufferView(w,p);const K=new Map;for(const o of B){const mm=f.get(o),{kind:u,totalVertices:B}=V(o,mm);switch(u){case z.f.MatricesIndicesKind:case z.f.MatricesIndicesExtraKind:if(o.type==z.f.FLOAT){const mm=o.getFloatData(B);null!==mm&&K.set(o,mm)}}}0!==K.size&&G.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const Y=Array.from(K.keys());for(const u of Y){const mm=K.get(u);if(!mm)continue;const f=mm.some((mm=>mm>=256)),B=new(f?Uint16Array:Uint8Array)(mm.length);for(let o=0;o<mm.length;o++)B[o]=mm[o];const O=this._bufferManager.createBufferView(B,4*(f?2:1));o.setRemappedBufferView(w,u,O)}}const r=Array.from(B.keys());for(const w of r){const mm=B.get(w);if(!mm)continue;const u=Jm(w,mm[0],this._bufferManager,this._bufferViews,this._accessors,o.convertToRightHanded);for(const f of mm)o.bindMorphDataToMesh(f,u)}}async _exportNodeAsync(mm,o,u){let f=this._nodeMap.get(mm);if(void 0!==f)return void(o.includes(f)||o.push(f));const B=await this._createNodeAsync(mm,u);if(B){f=this._nodes.length,this._nodes.push(B),this._nodeMap.set(mm,f),u.pushExportedNode(mm),o.push(f);const O={name:"runtime animations",channels:[],samplers:[]},r=[];this._babylonScene.animationGroups.length||(bm._CreateMorphTargetAnimationFromMorphTargetAnimations(mm,O,r,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,u.convertToRightHanded,this._options.shouldExportAnimation),mm.animations.length&&bm._CreateNodeAnimationFromNodeAnimations(mm,O,r,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,u.convertToRightHanded,this._options.shouldExportAnimation)),O.channels.length&&O.samplers.length&&this._animations.push(O),r.forEach((mm=>{mm.channels.length&&mm.samplers.length&&this._animations.push(mm)}))}const O=B?[]:o;for(const r of mm.getChildren())await this._exportNodeAsync(r,O,u);B&&O.length&&(B.children=O)}async _createNodeAsync(mm,o){if(!this._shouldExportNode(mm))return null;const u={};if(mm.name&&(u.name=mm.name),mm.metadata){const o=this._options.metadataSelector(mm.metadata);o&&(u.extras=o)}if(mm instanceof Y.c&&(this._setNodeTransformation(u,mm,o.convertToRightHanded),mm instanceof q.b)){const B=mm instanceof x.b?mm.sourceMesh:mm;if(B.kf&&B.kf.length>0&&(u.mesh=await this._exportMeshAsync(B,o)),mm.skeleton){const o=this._skinMap.get(mm.skeleton);var f;if(void 0!==o)void 0===this._nodesSkinMap.get(o)&&this._nodesSkinMap.set(o,[]),null===(f=this._nodesSkinMap.get(o))||void 0===f||f.push(u)}}if(mm instanceof k.b){const f=this._camerasMap.get(mm);if(f){var B;void 0===this._nodesCameraMap.get(f)&&this._nodesCameraMap.set(f,[]),this._setCameraTransformation(u,mm,o.convertToRightHanded);const r=mm.parent;if(null!==r&&om(mm,r)){const mm=this._nodeMap.get(r);if(void 0!==mm){var O;const o=this._nodes[mm];return mo(u,o),null===(O=this._nodesCameraMap.get(f))||void 0===O||O.push(o),null}}null===(B=this._nodesCameraMap.get(f))||void 0===B||B.push(u)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",u,mm,this._nodeMap,o.convertToRightHanded)?u:(G.e.Warn(`Not exporting node ${mm.name}`),null)}_exportIndices(mm,o,u,f,B,r,w,p,K){let z=mm;K.mode=h(r);const Y=w!==O.c.CounterClockWiseSideOrientation,q=!p.wasAddedByNoopNode&&Y,x=function(mm){switch(mm){case O.c.TriangleFillMode:case O.c.TriangleStripDrawMode:case O.c.TriangleFanDrawMode:return!0}return!1}(r)&&q;if(x){if(r===O.c.TriangleStripDrawMode||r===O.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");K.mode=h(r);const w=o?new Uint32Array(f):new Uint16Array(f);if(mm)for(let o=0;o+2<f;o+=3)w[o]=mm[u+o]+B,w[o+1]=mm[u+o+2]+B,w[o+2]=mm[u+o+1]+B;else for(let mm=0;mm+2<f;mm+=3)w[mm]=mm,w[mm+1]=mm+2,w[mm+2]=mm+1;z=w}else if(mm&&0!==B){const O=o?new Uint32Array(f):new Uint16Array(f);for(let o=0;o<f;o++)O[o]=mm[u+o]+B;z=O}if(z){let O=p.getIndicesAccessor(mm,u,f,B,x);if(void 0===O){const r=function(mm,o,u,f){if(mm instanceof Uint16Array||mm instanceof Uint32Array)return mm;if(mm instanceof Int32Array)return new Uint32Array(mm.buffer,mm.byteOffset,mm.length);const B=mm.slice(o,o+u);return f?new Uint32Array(B):new Uint16Array(B)}(z,0,f,o),w=this._bufferManager.createBufferView(r),K=o?5125:5123;this._accessors.push(this._bufferManager.createAccessor(w,"SCALAR",K,f,0)),O=this._accessors.length-1,p.setIndicesAccessor(mm,u,f,B,x,O)}K.indices=O}}_exportVertexBuffer(mm,o,u,f,B,O){const r=mm.getKind();if(!U(r))return;if(r.startsWith("uv")&&!this._options.exportUnusedUVs&&(!o||!this._materialNeedsUVsSet.has(o)))return;let w=B.getVertexAccessor(mm,u,f);if(void 0===w){const o=B.convertedToRightHandedBuffers.get(mm._buffer)||mm._buffer.getData(),O=r===z.f.PositionKind?function(mm,o,u,f){const{byteOffset:B,byteStride:O,type:r,normalized:w}=o,p=o.getSize(),K=new Array(p).fill(1/0),z=new Array(p).fill(-1/0);return(0,X.f)(mm,B+u*O,O,p,r,f*p,w,(mm=>{for(let o=0;o<p;o++)K[o]=Math.min(K[o],mm[o]),z[o]=Math.max(z[o],mm[o])})),{min:K,max:z}}(o,mm,u,f):void 0,p=(r===z.f.MatricesIndicesKind||r===z.f.MatricesIndicesExtraKind)&&mm.type===z.f.FLOAT,K=p?z.f.UNSIGNED_BYTE:mm.type,Y=p?void 0:mm.normalized,q=p?B.getRemappedBufferView(mm._buffer,mm):B.getVertexBufferView(mm._buffer),x=mm.byteOffset+u*mm.byteStride;this._accessors.push(this._bufferManager.createAccessor(q,function(mm,o){if(mm==z.f.ColorKind)return o?"VEC4":"VEC3";switch(mm){case z.f.PositionKind:case z.f.NormalKind:return"VEC3";case z.f.TangentKind:case z.f.MatricesIndicesKind:case z.f.MatricesIndicesExtraKind:case z.f.MatricesWeightsKind:case z.f.MatricesWeightsExtraKind:return"VEC4";case z.f.UVKind:case z.f.UV2Kind:case z.f.UV3Kind:case z.f.UV4Kind:case z.f.UV5Kind:case z.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${mm}`)}(r,B.hasVertexColorAlpha(mm)),K,f,x,O,Y)),w=this._accessors.length-1,B.setVertexAccessor(mm,u,f,w)}O.attributes[function(mm){switch(mm){case z.f.PositionKind:return"POSITION";case z.f.NormalKind:return"NORMAL";case z.f.TangentKind:return"TANGENT";case z.f.ColorKind:return"COLOR_0";case z.f.UVKind:return"TEXCOORD_0";case z.f.UV2Kind:return"TEXCOORD_1";case z.f.UV3Kind:return"TEXCOORD_2";case z.f.UV4Kind:return"TEXCOORD_3";case z.f.UV5Kind:return"TEXCOORD_4";case z.f.UV6Kind:return"TEXCOORD_5";case z.f.MatricesIndicesKind:return"JOINTS_0";case z.f.MatricesIndicesExtraKind:return"JOINTS_1";case z.f.MatricesWeightsKind:return"WEIGHTS_0";case z.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${mm}`)}(r)]=w}async _exportMaterialAsync(mm,o,u,f){let B=this._materialMap.get(mm);if(void 0===B){const f=o&&Object.keys(o).some((mm=>mm.startsWith("uv")));if((mm=mm instanceof xm.e?mm.Kp[u.materialIndex]:mm)instanceof Hm.d)B=await this._materialExporter.exportPBRMaterialAsync(mm,"image/png",f);else{if(!(mm instanceof Em.Jo))return void G.e.Warn(`Unsupported material '${mm.name}' with type ${mm.getClassName()}`);B=await this._materialExporter.exportStandardMaterialAsync(mm,"image/png",f)}this._materialMap.set(mm,B)}f.material=B}async _exportMeshAsync(mm,o){var u;let f=o.getMesh(mm);if(void 0!==f)return f;const B={primitives:[]};f=this._meshes.length,this._meshes.push(B),o.setMesh(mm,f);const r=mm.isUnIndexed?null:mm.hr(),w=null===(u=mm.br)||void 0===u?void 0:u.getVertexBuffers(),p=o.getMorphTargetsFromMesh(mm),K=mm instanceof Nm.b,z=mm instanceof em,Y=mm.kf;if(w&&Y&&Y.length>0)for(const H of Y){const u={attributes:{}},f=H.Gm()||this._babylonScene.defaultMaterial;if(z){var q,x;const o={name:f.name},B=mm,O=M.No.White(),r=(null===(q=B.material)||void 0===q?void 0:q.alpha)??1,w=(null===(x=B.greasedLineMaterial)||void 0===x?void 0:x.color)??O;(!w.equalsWithEpsilon(O,d.e)||r<1)&&(o.pbrMetallicRoughness={baseColorFactor:[...w.df(),r]}),this._materials.push(o),u.material=this._materials.length-1}else if(K){const o={name:f.name},B=mm;(!B.color.equalsWithEpsilon(M.No.White(),d.e)||B.alpha<1)&&(o.pbrMetallicRoughness={baseColorFactor:[...B.color.df(),B.alpha]}),this._materials.push(o),u.material=this._materials.length-1}else await this._exportMaterialAsync(f,w,H,u);const Y=K||z?O.c.LineListDrawMode:mm.overrideRenderingFillMode??f.fillMode,E=f._getEffectiveOrientation(mm);this._exportIndices(r,r?(0,X.c)(r,H.indexCount,H.indexStart,H.verticesStart):H.verticesCount>65535,r?H.indexStart:H.verticesStart,r?H.indexCount:H.verticesCount,-H.verticesStart,Y,E,o,u);for(const mm of Object.values(w))this._exportVertexBuffer(mm,f,H.verticesStart,H.verticesCount,o,u);if(p){u.targets=[];for(const mm of p)u.targets.push(mm.attributes)}B.primitives.push(u),this._extensionsPostExportMeshPrimitive(u)}if(p){B.weights=[],B.extras||(B.extras={}),B.extras.targetNames=[];for(const mm of p)B.weights.push(mm.influence),B.extras.targetNames.push(mm.name)}return f}}Cm._ExtensionNames=new Array,Cm._ExtensionFactories={};class vm{static async GLTFAsync(mm,o,u){u&&u.exportWithoutWaitingForScene||await mm.whenReadyAsync();const f=new Cm(mm,u),B=await f.generateGLTFAsync(o.replace(/\.[^/.]+$/,""));return f.dispose(),B}static async GLBAsync(mm,o,u){u&&u.exportWithoutWaitingForScene||await mm.whenReadyAsync();const f=new Cm(mm,u),B=await f.generateGLBAsync(o.replace(/\.[^/.]+$/,""));return f.dispose(),B}}u(13280);const Vm="EXT_mesh_gpu_instancing";class nm{constructor(mm){this.name=Vm,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=mm}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(mm,o,u,B,O,r){return await new Promise((mm=>{if(o&&u instanceof tm.d&&u.hasThinInstances&&this._exporter){this._wasUsed=!0;const mm=f.lo.Zero(),B=f.Quaternion.Identity(),w=f.lo.One(),p=u.thinInstanceGetWorldMatrices(),K=f.TmpVectors.lo[2],z=f.TmpVectors.Quaternion[1],Y=f.TmpVectors.lo[3];let q=!1,x=!1,H=!1;const E=new Float32Array(3*u.zp),M=new Float32Array(4*u.zp),l=new Float32Array(3*u.zp);let t=0;for(const o of p)o.decompose(Y,z,K),O&&(T(K),D(z)),E.set(K.df(),3*t),M.set(z.normalize().df(),4*t),l.set(Y.df(),3*t),q=q||!K.equalsWithEpsilon(mm),x=x||!z.equalsWithEpsilon(B),H=H||!Y.equalsWithEpsilon(w),t++;const Q={attributes:{}};q&&(Q.attributes.TRANSLATION=this._buildAccessor(E,"VEC3",u.zp,r)),x&&(Q.attributes.ROTATION=this._buildAccessor(M,"VEC4",u.zp,r)),H&&(Q.attributes.SCALE=this._buildAccessor(l,"VEC3",u.zp,r)),o.extensions=o.extensions||{},o.extensions[Vm]=Q}mm(o)}))}_buildAccessor(mm,o,u,f){const B=f.createBufferView(mm),O=f.createAccessor(B,o,5126,u);return this._exporter._accessors.push(O),this._exporter._accessors.length-1}}Cm.RegisterExtension(Vm,(mm=>new nm(mm)));var Um=u(13284),hm=u(13295),Zm=u(13303),Tm=u(13307);function Dm(mm){return mm===Zm.c.PositionKind?"POSITION":mm===Zm.c.NormalKind?"NORMAL":mm===Zm.c.ColorKind?"COLOR":mm.startsWith(Zm.c.UVKind)?"TEX_COORD":"GENERIC"}const im={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class mu extends Um.e{static get DefaultAvailable(){return(0,Um.k)(mu.DefaultConfiguration)}static get Default(){return mu._Default??(mu._Default=new mu),mu._Default}static ResetDefault(mm){mu._Default&&(mm||mu._Default.dispose(),mu._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(mm,o){return{module:await(o||DracoEncoderModule)({wasmBinary:mm})}}_getWorkerContent(){return`${hm.j}(${hm.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:mu.DefaultConfiguration)}async _encodeAsync(mm,o,u){const f=u?(0,Tm.d)(im,u):im;if(this._workerPoolPromise){const u=await this._workerPoolPromise;return await new Promise(((B,O)=>{u.push(((u,r)=>{const w=mm=>{u.removeEventListener("error",w),u.removeEventListener("message",p),O(mm),r()},p=mm=>{"encodeMeshDone"===mm.data.id&&(u.removeEventListener("error",w),u.removeEventListener("message",p),B(mm.data.encodedMeshData),r())};u.addEventListener("error",w),u.addEventListener("message",p);const K=[];for(const o of mm)K.push(o.data.buffer);o&&K.push(o.buffer),u.postMessage({id:"encodeMesh",attributes:mm,indices:o,options:f},K)}))}))}if(this._modulePromise){const u=await this._modulePromise;return(0,hm.j)(u.module,mm,o,f)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(mm,o){if(0==mm.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");mm instanceof tm.d&&mm.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===o||void 0===o?void 0:o.method)&&(G.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),o.method="MESH_SEQUENTIAL_ENCODING");const u=function(mm){let o=mm.hr(void 0,!0);return!o||o instanceof Uint32Array||o instanceof Uint16Array||(o=((0,X.c)(o,o.length)?Uint32Array:Uint16Array).from(o)),o}(mm),f=function(mm,o){const u=[];for(const f of mm.getVerticesDataKinds()){if(null!==o&&void 0!==o&&o.includes(f)){if(f===Zm.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const B=mm.getVertexBuffer(f),O=B.getSize(),r=(0,X.n)(B.getData(),O,B.type,B.byteOffset,B.byteStride,B.normalized,mm.getTotalVertices(),!0);u.push({kind:f,dracoName:Dm(f),size:O,data:r})}return u}(mm,null===o||void 0===o?void 0:o.excludedAttributes);return await this._encodeAsync(f,u,o)}}mu.DefaultConfiguration={wasmUrl:`${B.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${B.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${B.Tools._DefaultCdnUrl}/draco_encoder.js`},mu._Default=null;const oo="KHR_draco_mesh_compression";class uo{get wasUsed(){return this._wasUsed}constructor(mm){this.name=oo,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===mm.options.meshCompressionMethod&&mu.DefaultAvailable}dispose(){}postExportMeshPrimitive(mm,o,u){if(!this.enabled)return;if(4!==mm.mode&&5!==mm.mode)return void G.e.Warn("Cannot compress primitive with mode "+mm.mode+".");const f=[],B=[];let O=null;if(void 0!==mm.indices){const r=u[mm.indices],w=o.getBufferView(r);O=o.getData(w).slice(),f.push(w),B.push(r)}const r=[];for(const[z,Y]of Object.entries(mm.attributes)){const mm=u[Y],O=o.getBufferView(mm),p=n(mm.type),K=(0,X.n)(o.getData(O),p,mm.componentType,mm.byteOffset||0,O.byteStride||(0,X.k)(mm.componentType)*p,mm.normalized||!1,mm.count,!0);r.push({kind:z,dracoName:(w=z,"POSITION"===w?"POSITION":"NORMAL"===w?"NORMAL":w.startsWith("COLOR")?"COLOR":w.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:n(mm.type),data:K}),f.push(O),B.push(mm)}var w;const p={method:mm.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},K=mu.Default._encodeAsync(r,O,p).then((u=>{if(!u)return void G.e.Error("Draco encoding failed for primitive.");const O={bufferView:-1,attributes:u.attributeIds},r=o.createBufferView(u.data);o.setBufferView(O,r);for(const mm of f)this._bufferViewsUsed.add(mm);for(const mm of B)this._accessorsUsed.add(mm);mm.extensions||(mm.extensions={}),mm.extensions[oo]=O})).catch((mm=>{G.e.Error("Draco encoding failed for primitive: "+mm)}));this._encodePromises.push(K),this._wasUsed=!0}async preGenerateBinaryAsync(mm){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((o=>{mm.getPropertiesWithBufferView(o).every((mm=>this._accessorsUsed.has(mm)))&&mm.removeBufferView(o)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Cm.RegisterExtension(oo,(mm=>new uo(mm)));var fo=u(13310);const Bo="KHR_lights_punctual",Oo={name:"",color:[1,1,1],Yp:1,range:Number.MAX_VALUE},ro={innerConeAngle:0,outerConeAngle:Math.PI/4},wo=f.lo.Backward();class po{constructor(mm){this.name=Bo,this.enabled=!0,this.required=!1,this._exporter=mm}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Bo]=this._lights}async postExportNodeAsync(mm,o,u,B,O){return await new Promise((r=>{if(!(u instanceof Qm.c))return void r(o);const w=u.getTypeID()==Qm.c.LIGHTTYPEID_POINTLIGHT?"point":u.getTypeID()==Qm.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":u.getTypeID()==Qm.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!w||!(u instanceof fo.e))return G.e.Warn(`${mm}: Light ${u.name} is not supported in ${Bo}`),void r(o);if(u.falloffType!==Qm.c.FALLOFF_GLTF&&G.e.Warn(`${mm}: Light falloff for ${u.name} does not match the ${Bo} specification!`),!u.position.equalsToFloats(0,0,0)){const mm=f.TmpVectors.lo[0].p(u.position);O&&T(mm),o.translation=mm.df()}if("point"!==w){const mm=u.direction.normalizeToRef(f.TmpVectors.lo[0]);O&&T(mm);const B=f.Quaternion.FromUnitVectorsToRef(wo,mm,f.TmpVectors.Quaternion[0]);f.Quaternion.IsIdentity(B)||(o.rotation=B.df())}const p={type:w,name:u.name,color:u.qp.df(),Yp:u.Yp,range:u.range};if(fm(p,Oo),"spot"===w){const mm=u;p.spot={innerConeAngle:mm.innerAngle/2,outerConeAngle:mm.angle/2},fm(p.spot,ro)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(p);const K={Ef:this._lights.lights.length-1},z=u.parent;if(z&&om(u,z)){const mm=B.get(z);if(mm){const u=this._exporter._nodes[mm];return mo(o,u),u.extensions||(u.extensions={}),u.extensions[Bo]=K,void r(null)}}o.extensions||(o.extensions={}),o.extensions[Bo]=K,r(o)}))}}Cm.RegisterExtension(Bo,(mm=>new po(mm)));var Ko=u(13212);const zo="KHR_materials_anisotropy";class Yo{constructor(mm){this.name=zo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=mm}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(mm,o,u){const f=[];return u instanceof Ko.e&&u.anisotropy.isEnabled&&!u.anisotropy.legacy?(u.anisotropy.texture&&f.push(u.anisotropy.texture),f):[]}postExportMaterialAsync(mm,o,u){return new Promise((mm=>{if(u instanceof Ko.e){if(!u.anisotropy.isEnabled||u.anisotropy.legacy)return void mm(o);this._wasUsed=!0,o.extensions=o.extensions||{};const f=this._exporter._materialExporter.getTextureInfo(u.anisotropy.texture),B={anisotropyStrength:u.anisotropy.Yp,anisotropyRotation:u.anisotropy.angle,anisotropyTexture:f??void 0};null!==B.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(u),o.extensions[zo]=B}mm(o)}))}}Cm.RegisterExtension(zo,(mm=>new Yo(mm)));const qo="KHR_materials_clearcoat";class xo{constructor(mm){this.name=qo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=mm}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(mm,o,u){const f=[];return u instanceof Ko.e&&u.clearCoat.isEnabled?(u.clearCoat.texture&&f.push(u.clearCoat.texture),!u.clearCoat.useRoughnessFromMainTexture&&u.clearCoat.textureRoughness&&f.push(u.clearCoat.textureRoughness),u.clearCoat.bumpTexture&&f.push(u.clearCoat.bumpTexture),f):[]}postExportMaterialAsync(mm,o,u){return new Promise((mm=>{if(u instanceof Ko.e){if(!u.clearCoat.isEnabled)return void mm(o);this._wasUsed=!0,o.extensions=o.extensions||{};const f=this._exporter._materialExporter.getTextureInfo(u.clearCoat.texture);let O;O=u.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(u.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(u.clearCoat.textureRoughness),u.clearCoat.isTintEnabled&&B.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${u.name}`),u.clearCoat.remapF0OnInterfaceChange&&B.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${u.name}`);const r=this._exporter._materialExporter.getTextureInfo(u.clearCoat.bumpTexture),w={clearcoatFactor:u.clearCoat.Yp,clearcoatTexture:f??void 0,clearcoatRoughnessFactor:u.clearCoat.roughness,clearcoatRoughnessTexture:O??void 0,clearcoatNormalTexture:r??void 0};null===w.clearcoatTexture&&null===w.clearcoatRoughnessTexture&&null===w.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(u),o.extensions[qo]=w}mm(o)}))}}Cm.RegisterExtension(qo,(mm=>new xo(mm)));const Ho="KHR_materials_diffuse_transmission";function Eo(mm,o){const u=o.subSurface;let f=null;return u.translucencyIntensityTexture?f=u.translucencyIntensityTexture:u.thicknessTexture&&u.useMaskFromThicknessTexture&&(f=u.thicknessTexture),f&&!u.useGltfStyleTextures?(G.e.Warn(`${mm}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${o.name}`,1),null):f}class Mo{constructor(mm){this.name=Ho,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=mm}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(mm,o,u){const f=[];if(u instanceof Hm.d&&this._isExtensionEnabled(u)){const o=Eo(mm,u);return o&&f.push(o),u.subSurface.translucencyColorTexture&&f.push(u.subSurface.translucencyColorTexture),f}return f}_isExtensionEnabled(mm){if(mm.unlit)return!1;const o=mm.subSurface;return!!o.isTranslucencyEnabled&&(!mm.unlit&&!o.useAlbedoToTintTranslucency&&o.useGltfStyleTextures&&1===o.volumeIndexOfRefraction&&0===o.minimumThickness&&0===o.maximumThickness)}postExportMaterialAsync(mm,o,u){return new Promise((f=>{if(u instanceof Hm.d&&this._isExtensionEnabled(u)){this._wasUsed=!0;const f=u.subSurface,B=Eo(mm,u),O=0==f.translucencyIntensity?void 0:f.translucencyIntensity,r=this._exporter._materialExporter.getTextureInfo(B)??void 0,w=!f.translucencyColor||f.translucencyColor.equalsFloats(1,1,1)?void 0:f.translucencyColor.df(),p=this._exporter._materialExporter.getTextureInfo(f.translucencyColorTexture)??void 0,K={diffuseTransmissionFactor:O,diffuseTransmissionTexture:r,diffuseTransmissionColorFactor:w,diffuseTransmissionColorTexture:p};(r||p)&&this._exporter._materialNeedsUVsSet.add(u),o.extensions=o.extensions||{},o.extensions[Ho]=K}f(o)}))}}Cm.RegisterExtension(Ho,(mm=>new Mo(mm)));const lo="KHR_materials_dispersion";class to{constructor(){this.name=lo,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(mm){if(mm.unlit)return!1;const o=mm.subSurface;return!(!o.isRefractionEnabled&&!o.isDispersionEnabled)}postExportMaterialAsync(mm,o,u){return new Promise((mm=>{if(u instanceof Hm.d&&this._isExtensionEnabled(u)){this._wasUsed=!0;const mm={dispersion:u.subSurface.dispersion};o.extensions=o.extensions||{},o.extensions[lo]=mm}mm(o)}))}}Cm.RegisterExtension(lo,(()=>new to));const Qo="KHR_materials_emissive_strength";class bo{constructor(){this.name=Qo,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(mm,o,u){return await new Promise((mm=>{if(!(u instanceof Hm.d))return mm(o);const f=u.emissiveColor.df(),B=Math.max(...f);if(B>1){this._wasUsed=!0,o.extensions||(o.extensions={});const mm={emissiveStrength:B},f=u.emissiveColor.scale(1/mm.emissiveStrength);o.emissiveFactor=f.df(),o.extensions[Qo]=mm}return mm(o)}))}}Cm.RegisterExtension(Qo,(mm=>new bo));const Jo="KHR_materials_ior";class No{constructor(){this.name=Jo,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(mm){return!mm.unlit&&(void 0!=mm.indexOfRefraction&&1.5!=mm.indexOfRefraction)}postExportMaterialAsync(mm,o,u){return new Promise((mm=>{if(u instanceof Hm.d&&this._isExtensionEnabled(u)){this._wasUsed=!0;const mm={ior:u.indexOfRefraction};o.extensions=o.extensions||{},o.extensions[Jo]=mm}mm(o)}))}}Cm.RegisterExtension(Jo,(mm=>new No));const So="KHR_materials_iridescence";class Po{constructor(mm){this.name=So,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=mm}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(mm,o,u){const f=[];return u instanceof Ko.e&&u.iridescence.isEnabled?(u.iridescence.texture&&f.push(u.iridescence.texture),u.iridescence.thicknessTexture&&u.iridescence.thicknessTexture!==u.iridescence.texture&&f.push(u.iridescence.thicknessTexture),f):[]}postExportMaterialAsync(mm,o,u){return new Promise((mm=>{if(u instanceof Ko.e){if(!u.iridescence.isEnabled)return void mm(o);this._wasUsed=!0,o.extensions=o.extensions||{};const f=this._exporter._materialExporter.getTextureInfo(u.iridescence.texture),B=this._exporter._materialExporter.getTextureInfo(u.iridescence.thicknessTexture),O={iridescenceFactor:u.iridescence.Yp,iridescenceIor:u.iridescence.indexOfRefraction,iridescenceThicknessMinimum:u.iridescence.minimumThickness,iridescenceThicknessMaximum:u.iridescence.maximumThickness,iridescenceTexture:f??void 0,iridescenceThicknessTexture:B??void 0};null===O.iridescenceTexture&&null===O.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(u),o.extensions[So]=O}mm(o)}))}}Cm.RegisterExtension(So,(mm=>new Po(mm)));const Ro="KHR_materials_sheen";class go{constructor(mm){this.name=Ro,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=mm}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(mm,o,u){return u instanceof Hm.d&&u.sheen.isEnabled&&u.sheen.texture?[u.sheen.texture]:[]}async postExportMaterialAsync(mm,o,u){return await new Promise((mm=>{if(u instanceof Hm.d){if(!u.sheen.isEnabled)return void mm(o);this._wasUsed=!0,null==o.extensions&&(o.extensions={});const f={sheenColorFactor:u.sheen.color.df(),sheenRoughnessFactor:u.sheen.roughness??0};null===f.sheenColorTexture&&null===f.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(u),u.sheen.texture&&(f.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(u.sheen.texture)??void 0),u.sheen.textureRoughness&&!u.sheen.useRoughnessFromMainTexture?f.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(u.sheen.textureRoughness)??void 0:u.sheen.texture&&u.sheen.useRoughnessFromMainTexture&&(f.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(u.sheen.texture)??void 0),o.extensions[Ro]=f}mm(o)}))}}Cm.RegisterExtension(Ro,(mm=>new go(mm)));const Wo="KHR_materials_specular";class Fo{constructor(mm){this.name=Wo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=mm}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(mm,o,u){const f=[];return u instanceof Hm.d&&this._isExtensionEnabled(u)?(u.metallicReflectanceTexture&&f.push(u.metallicReflectanceTexture),u.reflectanceTexture&&f.push(u.reflectanceTexture),f):f}_isExtensionEnabled(mm){return!mm.unlit&&(void 0!=mm.metallicF0Factor&&1!=mm.metallicF0Factor||void 0!=mm.metallicReflectanceColor&&!mm.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(mm))}_hasTexturesExtension(mm){return null!=mm.metallicReflectanceTexture||null!=mm.reflectanceTexture}postExportMaterialAsync(mm,o,u){return new Promise((mm=>{if(u instanceof Hm.d&&this._isExtensionEnabled(u)){this._wasUsed=!0,o.extensions=o.extensions||{};const mm=this._exporter._materialExporter.getTextureInfo(u.metallicReflectanceTexture)??void 0,f=this._exporter._materialExporter.getTextureInfo(u.reflectanceTexture)??void 0,B={specularFactor:1==u.metallicF0Factor?void 0:u.metallicF0Factor,specularTexture:mm,specularColorFactor:u.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:u.metallicReflectanceColor.df(),specularColorTexture:f};this._hasTexturesExtension(u)&&this._exporter._materialNeedsUVsSet.add(u),o.extensions[Wo]=B}mm(o)}))}}Cm.RegisterExtension(Wo,(mm=>new Fo(mm)));const co="KHR_materials_transmission";class Ao{constructor(mm){this.name=co,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=mm}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(mm,o,u){const f=[];return u instanceof Hm.d&&this._isExtensionEnabled(u)?(u.subSurface.thicknessTexture&&f.push(u.subSurface.thicknessTexture),f):f}_isExtensionEnabled(mm){if(mm.unlit)return!1;const o=mm.subSurface;return o.isRefractionEnabled&&void 0!=o.refractionIntensity&&0!=o.refractionIntensity||this._hasTexturesExtension(mm)}_hasTexturesExtension(mm){return null!=mm.subSurface.refractionIntensityTexture}async postExportMaterialAsync(mm,o,u){if(u instanceof Hm.d&&this._isExtensionEnabled(u)){this._wasUsed=!0;const f=u.subSurface,B={transmissionFactor:0===f.refractionIntensity?void 0:f.refractionIntensity};if(this._hasTexturesExtension(u)&&this._exporter._materialNeedsUVsSet.add(u),f.refractionIntensityTexture)if(f.useGltfStyleTextures){const mm=await this._exporter._materialExporter.exportTextureAsync(f.refractionIntensityTexture,"image/png");mm&&(B.transmissionTexture=mm)}else G.e.Warn(`${mm}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);o.extensions||(o.extensions={}),o.extensions[co]=B}return o}}Cm.RegisterExtension(co,(mm=>new Ao(mm)));const yo="KHR_materials_unlit";class Io{constructor(){this.name=yo,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(mm,o,u){return new Promise((mm=>{let f=!1;u instanceof Hm.d?f=u.unlit:u instanceof Em.Jo&&(f=u.disableLighting),f&&(this._wasUsed=!0,null==o.extensions&&(o.extensions={}),o.extensions[yo]={}),mm(o)}))}}Cm.RegisterExtension(yo,(()=>new Io));const so="KHR_materials_volume";class jo{constructor(mm){this.name=so,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=mm}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(mm,o,u){const f=[];return u instanceof Hm.d&&this._isExtensionEnabled(u)?(u.subSurface.thicknessTexture&&f.push(u.subSurface.thicknessTexture),f):f}_isExtensionEnabled(mm){if(mm.unlit)return!1;const o=mm.subSurface;return!(!o.isRefractionEnabled&&!o.isTranslucencyEnabled)&&(void 0!=o.maximumThickness&&0!=o.maximumThickness||void 0!=o.tintColorAtDistance&&o.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=o.tintColor&&o.tintColor!=M.No.White()||this._hasTexturesExtension(mm))}_hasTexturesExtension(mm){return null!=mm.subSurface.thicknessTexture}postExportMaterialAsync(mm,o,u){return new Promise((mm=>{if(u instanceof Hm.d&&this._isExtensionEnabled(u)){this._wasUsed=!0;const mm=u.subSurface,f={thicknessFactor:0==mm.maximumThickness?void 0:mm.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(mm.thicknessTexture)??void 0,attenuationDistance:mm.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:mm.tintColorAtDistance,attenuationColor:mm.tintColor.equalsFloats(1,1,1)?void 0:mm.tintColor.df()};this._hasTexturesExtension(u)&&this._exporter._materialNeedsUVsSet.add(u),o.extensions=o.extensions||{},o.extensions[so]=f}mm(o)}))}}Cm.RegisterExtension(so,(mm=>new jo(mm)));const ao="EXT_materials_diffuse_roughness";class Xo{constructor(mm){this.name=ao,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=mm}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(mm,o,u){const f=[];return u instanceof Ko.e&&u._baseDiffuseRoughness?(u._baseDiffuseRoughnessTexture&&f.push(u._baseDiffuseRoughnessTexture),f):[]}postExportMaterialAsync(mm,o,u){return new Promise((mm=>{if(u instanceof Ko.e){if(!u._baseDiffuseRoughness)return void mm(o);this._wasUsed=!0,o.extensions=o.extensions||{};const f=this._exporter._materialExporter.getTextureInfo(u._baseDiffuseRoughnessTexture),B={diffuseRoughnessFactor:u._baseDiffuseRoughness,diffuseRoughnessTexture:f??void 0};null!==B.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(u),o.extensions[ao]=B}mm(o)}))}}Cm.RegisterExtension(ao,(mm=>new Xo(mm)));const Go="KHR_texture_transform";class ko{constructor(){this.name=Go,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(mm,o,u){if(u.Pm()||B.Tools.Warn(`${mm}: /*@__KEY__*/"scene" is not defined for Babylon texture ${u.name}!`),(0!==u.uAng||0!==u.vAng)&&(B.Tools.Warn(`${mm}: Texture ${u.name} with rotation in the u or v axis is not supported in glTF.`),0!==u.uRotationCenter||0!==u.vRotationCenter))return;const f={};let O=!1;if(0===u.uOffset&&0===u.vOffset||(f.offset=[u.uOffset,u.vOffset],O=!0),1===u.uScale&&1===u.vScale||(f.scale=[u.uScale,u.vScale],O=!0),0!==u.wAng){if(0!==u.uRotationCenter||0!==u.vRotationCenter){if(u.homogeneousRotationInUVTransform&&u.uScale!==u.vScale)return void B.Tools.Warn(`${mm}: Texture ${u.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Go}.`);B.Tools.Warn(`${mm}: Texture ${u.name} with non-origin rotation center will be exported using an adjusted offset with ${Go}.`),f.offset=function(mm){const{uOffset:o,vOffset:u,uRotationCenter:f,vRotationCenter:B,uScale:O,vScale:r,wAng:w}=mm,p=Math.cos(w),K=Math.sin(w),z=f*O,Y=B*r;return[o+(z*(1-p)+Y*K),u+(Y*(1-p)-z*K)]}(u)}f.rotation=-u.wAng,O=!0}0!==u.coordinatesIndex&&(f.texCoord=u.coordinatesIndex,O=!0),O&&(this._wasUsed=!0,o.extensions||(o.extensions={}),o.extensions[Go]=f)}}Cm.RegisterExtension(Go,(()=>new ko));class eo{static CreateSTL(mm){let o=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",B=arguments.length>3&&void 0!==arguments[3]&&arguments[3],O=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=arguments.length>5&&void 0!==arguments[5]&&arguments[5],w=arguments.length>6&&void 0!==arguments[6]&&arguments[6],p=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const K=function(mm,o,u){const B=[3*mm[u],3*mm[u+1],3*mm[u+2]],O=[new f.lo(o[B[0]],o[B[0]+2],o[B[0]+1]),new f.lo(o[B[1]],o[B[1]+2],o[B[1]+1]),new f.lo(o[B[2]],o[B[2]+2],o[B[2]+1])],r=O[0].Qo(O[1]),w=O[2].Qo(O[1]);return{v:O,n:f.lo.Cross(w,r).normalize()}},Y=function(mm,o,u,f){return o=q(mm,o,u.x,f),o=q(mm,o,u.y,f),q(mm,o,u.z,f)},q=function(mm,o,u,f){return mm.setFloat32(o,u,f),o+4},H=function(mm){if(w){let o=mm;mm instanceof x.b&&(o=mm.sourceMesh);const u=o.getVerticesData(z.f.PositionKind,!0,!0);if(!u)return[];const B=f.lo.Zero();let O;for(O=0;O<u.length;O+=3)f.lo.TransformCoordinatesFromFloatsToRef(u[O],u[O+1],u[O+2],mm.Df(!0),B).toArray(u,O);return u}return mm.getVerticesData(z.f.PositionKind)||[]};w&&(r=!0);let E="",M=0,l=0;if(B){for(let u=0;u<mm.length;u++){const o=mm[u].hr();M+=o?o.length/3:0}const o=new ArrayBuffer(84+50*M);E=new DataView(o),l+=80,E.setUint32(l,M,O),l+=4}else p||(E="solid stlmesh\r\n");for(let f=0;f<mm.length;f++){const o=mm[f];!B&&p&&(E+="solid "+o.name+"\r\n"),!r&&o instanceof tm.d&&o.bakeCurrentTransformIntoVertices();const u=H(o),w=o.hr()||[];for(let mm=0;mm<w.length;mm+=3){const o=K(w,u,mm);B?(l=Y(E,l,o.n,O),l=Y(E,l,o.v[0],O),l=Y(E,l,o.v[1],O),l=Y(E,l,o.v[2],O),l+=2):(E+="\tfacet normal "+o.n.x+" "+o.n.y+" "+o.n.z+"\r\n",E+="\t\touter loop\r\n",E+="\t\t\tvertex "+o.v[0].x+" "+o.v[0].y+" "+o.v[0].z+"\r\n",E+="\t\t\tvertex "+o.v[1].x+" "+o.v[1].y+" "+o.v[1].z+"\r\n",E+="\t\t\tvertex "+o.v[2].x+" "+o.v[2].y+" "+o.v[2].z+"\r\n",E+="\t\tendloop\r\n",E+="\tendfacet\r\n")}!B&&p&&(E+="endsolid "+name+"\r\n")}if(B||p||(E+="endsolid stlmesh"),o){const mm=document.createElement("a"),o=new Blob([E],{type:"application/octet-stream"});mm.href=window.URL.createObjectURL(o),mm.download=u+".stl",mm.click()}return E}}function Lo(mm,o){let u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const f=[];for(let B=0;B<mm.length/u;B++){const O=mm[B*u],r=mm[B*u+1],w=mm[B*u+2];f.push(`(${O.toPrecision(o.precision)}, ${r.toPrecision(o.precision)}, ${w.toPrecision(o.precision)})`)}return f.join(", ")}function Co(mm,o){const u=[];for(let f=0;f<mm.length/2;f++){const B=mm[2*f],O=mm[2*f+1];u.push(`(${B.toPrecision(o.precision)}, ${(1-O).toPrecision(o.precision)})`)}return u.join(", ")}function vo(mm,o){const u=mm.getVerticesData(z.f.PositionKind),f=mm.getVerticesData(z.f.NormalKind);if(u&&f)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(mm){var o;const u=null!==(o=mm.hr())&&void 0!==o&&o.length?mm.getTotalIndices():mm.getTotalVertices();return Array(u/3).fill(3).join(", ")}(mm)}]\n\t\tint[] faceVertexIndices = [${function(mm){const o=mm.hr(),u=[];if(null!==o)for(let f=0;f<o.length;f++)u.push(o[f]);else{const o=mm.getTotalVertices();for(let mm=0;mm<o;mm++)u.push(mm)}return u.join(", ")}(mm)}]\n\t\tnormal3f[] normals = [${Lo(f,o)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Lo(u,o)}]\n        ${function(mm,o){let u="";for(let B=0;B<4;B++){const f=B>0?B:"",O=mm.getVerticesData(z.f.UVKind+(f?f+1:""));O&&(u+=`\n\t\ttexCoord2f[] primvars:st${f} = [${Co(O,o)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const f=mm.getVerticesData(z.f.ColorKind);return f&&(u+=`\n\tcolor3f[] primvars:displayColor = [${Lo(f,o,f.length/mm.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),u}(mm,o)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Vo(mm,o){return`\n        def "Geometry"\n        {\n        ${vo(mm,o)}\n        }\n        `}function no(mm){let o='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return o+=mm,fflate.strToU8(o)}function Uo(mm){const o=mm.m;return`( ${ho(o,0)}, ${ho(o,4)}, ${ho(o,8)}, ${ho(o,12)} )`}function ho(mm,o){return`(${mm[o+0]}, ${mm[o+1]}, ${mm[o+2]}, ${mm[o+3]})`}function Zo(mm){const o="Object_"+mm.uniqueId,u=function(mm){const o=mm.getWorldMatrix().clone(),u=mm.Pm().useRightHandedSystem;if(!u){let f=mm.parent;for(;f;){if(rm(f,u)){o.multiplyToRef(f.getWorldMatrix().invert(),o);break}f=f.parent}}return o.determinant()<0&&B.Tools.Warn(`Exporting mesh ${mm.name} with negative scale. Result may look incorrect in destination engine.`),o}(mm),f=Uo(u);return`def Xform "${o}" (\n\tprepend references = @./geometries/Geometry_${mm.br.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${f}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${mm.material.uniqueId}>\n}\n\n`}function To(mm){switch(mm){case S.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case S.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case S.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Do(mm){return`(${mm.x}, ${mm.y})`}function io(mm){return`(${mm.r}, ${mm.g}, ${mm.b})`}function mf(mm,o,u,B,O,r){const w=mm.getInternalTexture().uniqueId+"_"+mm.invertY;O[w]=mm;const p=mm.coordinatesIndex>0?"st"+mm.coordinatesIndex:"st",K=new f.Vector2(mm.uScale,mm.vScale),z=new f.Vector2(mm.uOffset,mm.vOffset),Y=mm.wAng,q=Math.sin(Y),x=Math.cos(Y);return z.y=1-z.y-K.y,z.x+=q*K.x,z.y+=(1-x)*K.y,`\n    def Shader "PrimvarReader_${u}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${p}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${u}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${o.uniqueId}/PrimvarReader_${u}.outputs:result>\n        float inputs:rotation = ${(Y*(180/Math.PI)).toFixed(r.precision)}\n        float2 inputs:scale = ${Do(K)}\n        float2 inputs:translation = ${Do(z)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${mm.uniqueId}_${u}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${w}.png@\n        float2 inputs:st.connect = </Materials/Material_${o.uniqueId}/Transform2d_${u}.outputs:result>\n        ${B?"float4 inputs:scale = "+function(mm){return`(${mm.r}, ${mm.g}, ${mm.b}, 1.0)`}(B):""}\n        token inputs:sourceColorSpace = "${mm.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${To(mm.wrapU)}"\n        token inputs:wrapT = "${To(mm.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${o.needAlphaBlending()?"float outputs:a":""}\n    }`}function ou(mm,o,u){const f="\t\t\t",B=[],O=[],{diffuseMap:r,qp:w,alphaCutOff:p,emissiveMap:K,emissive:z,normalMap:Y,roughnessMap:q,roughnessChannel:x,roughness:H,metalnessMap:E,metalnessChannel:l,metalness:t,aoMap:Q,aoMapChannel:b,aoMapIntensity:J,alphaMap:N,ior:S,clearCoatEnabled:P,clearCoat:R,clearCoatMap:g,clearCoatRoughness:W,clearCoatRoughnessMap:F}=function(mm){const o={diffuseMap:null,qp:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return mm instanceof Em.Jo?{...o,diffuseMap:mm.diffuseTexture,qp:mm.diffuseColor,alphaCutOff:mm.alphaCutOff,emissiveMap:mm.emissiveTexture,emissive:mm.emissiveColor,roughness:1,alphaMap:mm.opacityTexture}:mm instanceof Ko.e?{...o,diffuseMap:mm._albedoTexture,qp:mm._albedoColor,alphaCutOff:mm._alphaCutOff,emissiveMap:mm._emissiveTexture,emissive:mm._emissiveColor,normalMap:mm._bumpTexture,roughnessMap:mm._metallicTexture,roughnessChannel:mm._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:mm._roughness??1,metalnessMap:mm._metallicTexture,metalnessChannel:mm._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:mm._metallic??0,aoMap:mm._ambientTexture,aoMapChannel:mm._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:mm._ambientTextureStrength,alphaMap:mm._opacityTexture,ior:mm.subSurface.indexOfRefraction,clearCoatEnabled:mm.clearCoat.isEnabled,clearCoat:mm.clearCoat.Yp,clearCoatMap:mm.clearCoat.texture,clearCoatRoughness:mm.clearCoat.roughness,clearCoatRoughnessMap:mm.clearCoat.useRoughnessFromMainTexture?mm.clearCoat.texture:mm.clearCoat.textureRoughness}:o}(mm);return null!==r?(B.push(`${f}color3f inputs:diffuseColor.connect = </Materials/Material_${mm.uniqueId}/Texture_${r.uniqueId}_diffuse.outputs:rgb>`),mm.needAlphaBlending()?B.push(`${f}float inputs:opacity.connect = </Materials/Material_${mm.uniqueId}/Texture_${r.uniqueId}_diffuse.outputs:a>`):mm.needAlphaTesting()&&(B.push(`${f}float inputs:opacity.connect = </Materials/Material_${mm.uniqueId}/Texture_${r.uniqueId}_diffuse.outputs:a>`),B.push(`${f}float inputs:opacityThreshold = ${p}`)),O.push(mf(r,mm,"diffuse",w,o,u))):B.push(`${f}color3f inputs:diffuseColor = ${io(w||M.No.White())}`),null!==K?(B.push(`${f}color3f inputs:emissiveColor.connect = </Materials/Material_${mm.uniqueId}/Texture_${K.uniqueId}_emissive.outputs:rgb>`),O.push(mf(K,mm,"emissive",z,o,u))):z&&z.toLuminance()>0&&B.push(`${f}color3f inputs:emissiveColor = ${io(z)}`),null!==Y&&(B.push(`${f}normal3f inputs:normal.connect = </Materials/Material_${mm.uniqueId}/Texture_${Y.uniqueId}_normal.outputs:rgb>`),O.push(mf(Y,mm,"normal",null,o,u))),null!==Q&&(B.push(`${f}float inputs:occlusion.connect = </Materials/Material_${mm.uniqueId}/Texture_${Q.uniqueId}_occlusion.outputs:${b}>`),O.push(mf(Q,mm,"occlusion",new M.No(J,J,J),o,u))),null!==q?(B.push(`${f}float inputs:roughness.connect = </Materials/Material_${mm.uniqueId}/Texture_${q.uniqueId}_roughness.outputs:${x}>`),O.push(mf(q,mm,"roughness",new M.No(H,H,H),o,u))):B.push(`${f}float inputs:roughness = ${H}`),null!==E?(B.push(`${f}float inputs:metallic.connect = </Materials/Material_${mm.uniqueId}/Texture_${E.uniqueId}_metallic.outputs:${l}>`),O.push(mf(E,mm,"metallic",new M.No(t,t,t),o,u))):B.push(`${f}float inputs:metallic = ${t}`),null!==N?(B.push(`${f}float inputs:opacity.connect = </Materials/Material_${mm.uniqueId}/Texture_${N.uniqueId}_opacity.outputs:r>`),B.push(`${f}float inputs:opacityThreshold = 0.0001`),O.push(mf(N,mm,"opacity",null,o,u))):B.push(`${f}float inputs:opacity = ${mm.alpha}`),P&&(null!==g?(B.push(`${f}float inputs:clearcoat.connect = </Materials/Material_${mm.uniqueId}/Texture_${g.uniqueId}_clearcoat.outputs:r>`),O.push(mf(g,mm,"clearcoat",new M.No(R,R,R),o,u))):B.push(`${f}float inputs:clearcoat = ${R}`),null!==F?(B.push(`${f}float inputs:clearcoatRoughness.connect = </Materials/Material_${mm.uniqueId}/Texture_${F.uniqueId}_clearcoatRoughness.outputs:g>`),O.push(mf(F,mm,"clearcoatRoughness",new M.No(W,W,W),o,u))):B.push(`${f}float inputs:clearcoatRoughness = ${W}`)),B.push(`${f}float inputs:ior = ${S}`),`\n\tdef Material "Material_${mm.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${B.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${mm.uniqueId}/PreviewSurface.outputs:surface>\n\n${O.join("\n")}\n\n\t}\n`}async function uu(mm,o,u){const O={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...o};"undefined"===typeof fflate&&await B.Tools.LoadScriptAsync(O.fflateUrl);const r={};r[O.modelFileName]=null;let w='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';w+=function(mm){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===mm.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${mm.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${mm.planeAnchoringAlignment}"`:""}\n            `}(O);const p={};for(const f of mm.meshes){if(0===f.getTotalVertices())continue;const mm=f,o=mm.br,K=mm.material;if(!K||!o||u&&!u(mm))continue;if(-1!==["Jo","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(K.getClassName())){const u="geometries/Geometry_"+o.uniqueId+".usda";if(!(u in r)){const mm=Vo(o,O);r[u]=no(mm)}K.uniqueId in p||(p[K.uniqueId]=K),w+=Zo(mm)}else B.Tools.Warn("USDZExportAsync does not support this material type: "+K.getClassName())}mm.activeCamera&&O.exportCamera&&(w+=function(mm,o){const u="Camera_"+mm.uniqueId,B=Uo(f.Matrix.RotationY(Math.PI).multiply(mm.getWorldMatrix()));if(mm.mode===S.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${u}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${B}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${mm.hf.toPrecision(o.precision)}, ${mm.maxZ.toPrecision(o.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(mm.orthoLeft||1)+Math.abs(mm.orthoRight||1))).toPrecision(o.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(mm.orthoTop||1)+Math.abs(mm.orthoBottom||1))).toPrecision(o.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const f=mm.getEngine().getAspectRatio(mm),O=o.cameraSensorWidth||35;return`def Camera "${u}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${B}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${mm.hf.toPrecision(o.precision)}, ${mm.maxZ.toPrecision(o.precision)})\n\t\t\tfloat focalLength = ${(O/(2*Math.tan(.5*mm.fov))).toPrecision(o.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(O*f).toPrecision(o.precision)}\n\t\t\tfloat verticalAperture = ${(O/f).toPrecision(o.precision)}            \n\t\t}\n\t\n\t`}}(mm.activeCamera,O)),w+="\n            }\n        }\n    }";const K={};w+=function(mm,o,u){const f=[];for(const B in mm){const O=mm[B];f.push(ou(O,o,u))}return`\n    def "Materials"\n{\n${f.join("")}\n}\n\n`}(p,K,O),r[O.modelFileName]=fflate.strToU8(w);for(const f in K){const mm=K[f],o=mm.getSize(),u=await mm.readPixels();if(!u)throw new Error("Texture data is not available");const B=await P.DumpTools.DumpDataAsync(o.width,o.height,u,"image/png",void 0,!1,!0);r[`textures/Texture_${f}.png`]=new Uint8Array(B).slice()}let z=0;for(const f in r){const mm=r[f];if(!mm)continue;z+=34+f.length;const o=63&z;if(4!==o){const u=new Uint8Array(64-o);r[f]=[mm,{extra:{12345:u}}]}z=mm.length}return fflate.zipSync(r,{level:0})}}}]);