"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[26],{12617:(q,c,U)=>{var J=U(10976),Q=U(10886),s=U(10922),g=U(10995),X=U(10954),n=U(10988);X.d.prototype._partialLoadFile=function(q,c,U,J){let Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(q,(q=>{U[c]=q,U._internalCount++,6===U._internalCount&&J(U)}),void 0,void 0,!0,((q,c)=>{Q&&q&&Q(q.status+" "+q.statusText,c)}))},X.d.prototype._cascadeLoadFiles=function(q,c,U){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const Q=[];Q._internalCount=0;for(let s=0;s<6;s++)this._partialLoadFile(U[s],s,Q,c,J)},X.d.prototype._cascadeLoadImgs=function(q,c,U,J){let Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5?arguments[5]:void 0;const g=[];g._internalCount=0;for(let X=0;X<6;X++)this._partialLoadImg(J[X],X,g,q,c,U,Q,s)},X.d.prototype._partialLoadImg=function(q,c,U,J,Q,X){let n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,W=arguments.length>7?arguments[7]:void 0;const D=(0,g.b)();(0,s.s)(q,(q=>{U[c]=q,U._internalCount++,J&&J.removePendingData(D),6===U._internalCount&&X&&X(Q,U)}),((q,c)=>{J&&J.removePendingData(D),n&&n(q,c)}),J?J.offlineProvider:null,W),J&&J.addPendingData(D)},X.d.prototype.createCubeTextureBase=function(q,c,U,s){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,X=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,W=arguments.length>6?arguments[6]:void 0,D=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,u=arguments.length>8&&void 0!==arguments[8]&&arguments[8],K=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,r=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,H=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,b=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,h=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,o=arguments.length>14&&void 0!==arguments[14]&&arguments[14],a=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const p=H||new J.e(this,7);p.isCube=!0,p.url=q,p.generateMipMaps=!s,p._lodGenerationScale=K,p._lodGenerationOffset=r,p._useSRGBBuffer=!!o&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!s),p!==H&&(p.label=q.substring(0,60)),this._doNotHandleContextLost||(p._extension=D,p._files=U,p._buffer=a);const R=q;this._transformTextureUrl&&!H&&(q=this._transformTextureUrl(q));const I=D??function(q){const c=q.split("?")[0],U=c.lastIndexOf(".");return U>-1?c.substring(U).toLowerCase():""}(q),t=(0,n.c)(I),C=(q,c)=>{p.dispose(),X?X(q,c):q&&Q.c.Warn(q)},i=(J,X)=>{q===R?J&&C(J.status+" "+J.statusText,X):(Q.c.Warn(`Failed to load ${q}, falling back to the ${R}`),this.createCubeTextureBase(R,c,U,!!s,g,C,W,D,u,K,r,p,b,h,o,a))};if(t)t.then((J=>{const Q=q=>{b&&b(p,q),J.loadCubeData(q,p,u,g,((q,c)=>{C(q,c)}))};a?Q(a):U&&6===U.length?J.supportCascades?this._cascadeLoadFiles(c,(q=>Q(q.map((q=>new Uint8Array(q))))),U,C):C("Textures type does not support cascades."):this._loadFile(q,(q=>Q(new Uint8Array(q))),void 0,void 0,!0,i)}));else{if(!U||0===U.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(c,p,((q,c)=>{h&&h(q,c)}),U,C)}return this._internalTexturesCache.push(p),p}},13369:(q,c,U)=>{U.d(c,{DDSTools:()=>H});var J=U(10870),Q=U(10886),s=U(11450),g=U(11285);U(12617);const X=131072,n=131072;function W(q){return q.charCodeAt(0)+(q.charCodeAt(1)<<8)+(q.charCodeAt(2)<<16)+(q.charCodeAt(3)<<24)}const D=W("DXT1"),u=W("DXT3"),K=W("DXT5"),r=W("DX10");class H{static GetDDSInfo(q){const c=new Int32Array(q.buffer,q.byteOffset,31),U=new Int32Array(q.buffer,q.byteOffset,35);let J=1;c[2]&X&&(J=Math.max(1,c[7]));const Q=c[21],s=Q===r?U[32]:0;let g=0;switch(Q){case 113:g=2;break;case 116:g=1;break;case r:if(10===s){g=2;break}if(2===s){g=1;break}}return{width:c[4],height:c[3],mipmapCount:J,isFourCC:4===(4&c[20]),isRGB:64===(64&c[20]),isLuminance:(c[20]&n)===n,isCube:512===(512&c[28]),isCompressed:Q===D||Q===u||Q===K,dxgiFormat:s,textureType:g}}static _GetHalfFloatAsFloatRGBAArrayBuffer(q,c,U,J,Q,s){const X=new Float32Array(J),n=new Uint16Array(Q,U);let W=0;for(let D=0;D<c;D++)for(let c=0;c<q;c++){const U=4*(c+D*q);X[W]=(0,g.g)(n[U]),X[W+1]=(0,g.g)(n[U+1]),X[W+2]=(0,g.g)(n[U+2]),H.StoreLODInAlphaChannel?X[W+3]=s:X[W+3]=(0,g.g)(n[U+3]),W+=4}return X}static _GetHalfFloatRGBAArrayBuffer(q,c,U,J,Q,s){if(H.StoreLODInAlphaChannel){const X=new Uint16Array(J),n=new Uint16Array(Q,U);let W=0;for(let U=0;U<c;U++)for(let c=0;c<q;c++){const J=4*(c+U*q);X[W]=n[J],X[W+1]=n[J+1],X[W+2]=n[J+2],X[W+3]=(0,g.n)(s),W+=4}return X}return new Uint16Array(Q,U,J)}static _GetFloatRGBAArrayBuffer(q,c,U,J,Q,s){if(H.StoreLODInAlphaChannel){const g=new Float32Array(J),X=new Float32Array(Q,U);let n=0;for(let U=0;U<c;U++)for(let c=0;c<q;c++){const J=4*(c+U*q);g[n]=X[J],g[n+1]=X[J+1],g[n+2]=X[J+2],g[n+3]=s,n+=4}return g}return new Float32Array(Q,U,J)}static _GetFloatAsHalfFloatRGBAArrayBuffer(q,c,U,J,Q,s){const X=new Uint16Array(J),n=new Float32Array(Q,U);let W=0;for(let D=0;D<c;D++)for(let c=0;c<q;c++)X[W]=(0,g.n)(n[W]),X[W+1]=(0,g.n)(n[W+1]),X[W+2]=(0,g.n)(n[W+2]),H.StoreLODInAlphaChannel?X[W+3]=(0,g.n)(s):X[W+3]=(0,g.n)(n[W+3]),W+=4;return X}static _GetFloatAsUIntRGBAArrayBuffer(q,c,U,Q,s,g){const X=new Uint8Array(Q),n=new Float32Array(s,U);let W=0;for(let D=0;D<c;D++)for(let c=0;c<q;c++){const U=4*(c+D*q);X[W]=255*(0,J.Clamp)(n[U]),X[W+1]=255*(0,J.Clamp)(n[U+1]),X[W+2]=255*(0,J.Clamp)(n[U+2]),H.StoreLODInAlphaChannel?X[W+3]=g:X[W+3]=255*(0,J.Clamp)(n[U+3]),W+=4}return X}static _GetHalfFloatAsUIntRGBAArrayBuffer(q,c,U,Q,s,X){const n=new Uint8Array(Q),W=new Uint16Array(s,U);let D=0;for(let u=0;u<c;u++)for(let c=0;c<q;c++){const U=4*(c+u*q);n[D]=255*(0,J.Clamp)((0,g.g)(W[U])),n[D+1]=255*(0,J.Clamp)((0,g.g)(W[U+1])),n[D+2]=255*(0,J.Clamp)((0,g.g)(W[U+2])),H.StoreLODInAlphaChannel?n[D+3]=X:n[D+3]=255*(0,J.Clamp)((0,g.g)(W[U+3])),D+=4}return n}static _GetRGBAArrayBuffer(q,c,U,J,Q,s,g,X,n){const W=new Uint8Array(J),D=new Uint8Array(Q,U);let u=0;for(let K=0;K<c;K++)for(let c=0;c<q;c++){const U=4*(c+K*q);W[u]=D[U+s],W[u+1]=D[U+g],W[u+2]=D[U+X],W[u+3]=D[U+n],u+=4}return W}static _ExtractLongWordOrder(q){return 0===q||255===q||-16777216===q?0:1+H._ExtractLongWordOrder(q>>8)}static _GetRGBArrayBuffer(q,c,U,J,Q,s,g,X){const n=new Uint8Array(J),W=new Uint8Array(Q,U);let D=0;for(let u=0;u<c;u++)for(let c=0;c<q;c++){const U=3*(c+u*q);n[D]=W[U+s],n[D+1]=W[U+g],n[D+2]=W[U+X],D+=3}return n}static _GetLuminanceArrayBuffer(q,c,U,J,Q){const s=new Uint8Array(J),g=new Uint8Array(Q,U);let X=0;for(let n=0;n<c;n++)for(let c=0;c<q;c++){const U=c+n*q;s[X]=g[U],X++}return s}static UploadDDSLevels(q,c,U,J,g,n){let W=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,b=arguments.length>7?arguments[7]:void 0,h=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],o=null;J.sphericalPolynomial&&(o=[]);const a=!!q.getCaps().s3tc;c.generateMipMaps=g;const p=new Int32Array(U.buffer,U.byteOffset,31);let R,I,t,C,i,F,v,Y=0,k=0,V=1;if(542327876!==p[0])return void Q.c.Error("Invalid magic number in DDS header");if(!J.isFourCC&&!J.isRGB&&!J.isLuminance)return void Q.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(J.isCompressed&&!a)return void Q.c.Error("Compressed textures are not supported on this platform.");let O=p[22];C=p[1]+4;let G=!1;if(J.isFourCC)switch(R=p[21],R){case D:V=8,k=33777;break;case u:V=16,k=33778;break;case K:V=16,k=33779;break;case 113:G=!0,O=64;break;case 116:G=!0,O=128;break;case r:{C+=20;let q=!1;switch(J.dxgiFormat){case 10:G=!0,O=64,q=!0;break;case 2:G=!0,O=128,q=!0;break;case 88:J.isRGB=!0,J.isFourCC=!1,O=32,q=!0}if(q)break}default:return void Q.c.Error(["Unsupported FourCC code:",(S=R,String.fromCharCode(255&S,S>>8&255,S>>16&255,S>>24&255))])}var S;const Z=H._ExtractLongWordOrder(p[23]),x=H._ExtractLongWordOrder(p[24]),z=H._ExtractLongWordOrder(p[25]),y=H._ExtractLongWordOrder(p[26]);G&&(k=q._getRGBABufferInternalSizedFormat(J.textureType)),F=1,p[2]&X&&!1!==g&&(F=Math.max(1,p[7]));const M=b||0,T=q.getCaps();for(let Q=M;Q<n;Q++){for(I=p[4],t=p[3],v=0;v<F;++v){if(-1===W||W===v){const s=-1===W?v:0;if(!J.isCompressed&&J.isFourCC){c.format=5,Y=I*t*4;let J=null;if(q._badOS||q._badDesktopOS||!T.textureHalfFloat&&!T.textureFloat)128===O?(J=H._GetFloatAsUIntRGBAArrayBuffer(I,t,U.byteOffset+C,Y,U.buffer,s),o&&0==s&&o.push(H._GetFloatRGBAArrayBuffer(I,t,U.byteOffset+C,Y,U.buffer,s))):64===O&&(J=H._GetHalfFloatAsUIntRGBAArrayBuffer(I,t,U.byteOffset+C,Y,U.buffer,s),o&&0==s&&o.push(H._GetHalfFloatAsFloatRGBAArrayBuffer(I,t,U.byteOffset+C,Y,U.buffer,s))),c.type=0;else{const q=T.textureFloat&&(h&&T.textureFloatLinearFiltering||!h),Q=T.textureHalfFloat&&(h&&T.textureHalfFloatLinearFiltering||!h),g=(128===O||64===O&&!Q)&&q?1:(64===O||128===O&&!q)&&Q?2:0;let X,n=null;if(128===O)switch(g){case 1:X=H._GetFloatRGBAArrayBuffer,n=null;break;case 2:X=H._GetFloatAsHalfFloatRGBAArrayBuffer,n=H._GetFloatRGBAArrayBuffer;break;case 0:X=H._GetFloatAsUIntRGBAArrayBuffer,n=H._GetFloatRGBAArrayBuffer}else switch(g){case 1:X=H._GetHalfFloatAsFloatRGBAArrayBuffer,n=null;break;case 2:X=H._GetHalfFloatRGBAArrayBuffer,n=H._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:X=H._GetHalfFloatAsUIntRGBAArrayBuffer,n=H._GetHalfFloatAsFloatRGBAArrayBuffer}c.type=g,J=X(I,t,U.byteOffset+C,Y,U.buffer,s),o&&0==s&&o.push(n?n(I,t,U.byteOffset+C,Y,U.buffer,s):J)}J&&q._uploadDataToTextureDirectly(c,J,Q,s)}else if(J.isRGB)c.type=0,24===O?(c.format=4,Y=I*t*3,i=H._GetRGBArrayBuffer(I,t,U.byteOffset+C,Y,U.buffer,Z,x,z),q._uploadDataToTextureDirectly(c,i,Q,s)):(c.format=5,Y=I*t*4,i=H._GetRGBAArrayBuffer(I,t,U.byteOffset+C,Y,U.buffer,Z,x,z,y),q._uploadDataToTextureDirectly(c,i,Q,s));else if(J.isLuminance){const J=q._getUnpackAlignement(),g=I;Y=Math.floor((I+J-1)/J)*J*(t-1)+g,i=H._GetLuminanceArrayBuffer(I,t,U.byteOffset+C,Y,U.buffer),c.format=1,c.type=0,q._uploadDataToTextureDirectly(c,i,Q,s)}else Y=Math.max(4,I)/4*Math.max(4,t)/4*V,i=new Uint8Array(U.buffer,U.byteOffset+C,Y),c.type=0,q._uploadCompressedDataToTextureDirectly(c,k,I,t,i,Q,s)}C+=O?I*t*(O/8):Y,I*=.5,t*=.5,I=Math.max(1,I),t=Math.max(1,t)}if(void 0!==b)break}o&&o.length>0?J.sphericalPolynomial=s.c.ConvertCubeMapToSphericalPolynomial({size:p[4],right:o[0],left:o[1],up:o[2],down:o[3],front:o[4],back:o[5],format:5,type:1,gammaSpace:!1}):J.sphericalPolynomial=void 0}}H.StoreLODInAlphaChannel=!1}}]);