"use strict";(self.bjbkv7h3qsd=self.bjbkv7h3qsd||[]).push([[26],{11613:(G,A,j)=>{j.r(A),j.d(A,{EXT_materials_diffuse_roughness:()=>wA,EXT_mesh_gpu_instancing:()=>vG,GLTF2Export:()=>zG,GLTFData:()=>d,KHR_draco_mesh_compression:()=>jA,KHR_lights_punctual:()=>OA,KHR_materials_anisotropy:()=>HA,KHR_materials_clearcoat:()=>RA,KHR_materials_diffuse_transmission:()=>CA,KHR_materials_dispersion:()=>YA,KHR_materials_emissive_strength:()=>QA,KHR_materials_ior:()=>IA,KHR_materials_iridescence:()=>gA,KHR_materials_sheen:()=>EA,KHR_materials_specular:()=>bA,KHR_materials_transmission:()=>oA,KHR_materials_unlit:()=>JA,KHR_materials_volume:()=>eA,KHR_texture_transform:()=>PA,OBJExport:()=>x,STLExport:()=>NA,USDZExportAsync:()=>Aj,_ConvertToGLTFPBRMetallicRoughness:()=>W,_SolveMetallic:()=>o,__IGLTFExporterExtension:()=>s});var u=j(11218),k=j(11043),B=j(11526);class x{static OBJ(G,A,j,x){const s=[];let O=1,d=1;A&&(j||(j="mat"),s.push("mtllib "+j+".mtl"));for(let h=0;h<G.length;h++){const j=G[h],H=j.name||`mesh${h}}`;s.push(`o ${H}`);let F=null;if(x){const G=j.Us(!0);F=new u.Matrix,G.invertToRef(F),j.bakeTransformIntoVertices(G)}if(A){const G=j.material;G&&s.push("usemtl "+G.id)}const R=j.Ss;if(!R){k.Tools.Warn("No geometry is present on the mesh");continue}const U=R.getVerticesData("position"),S=R.getVerticesData("normal"),C=R.getVerticesData("uv"),t=R.Cs();let Y=0,n=0;if(!U||!t){k.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const Q=G[0].gG().useRightHandedSystem?1:-1;for(let G=0;G<U.length;G+=3)s.push("v "+U[G]*Q+" "+U[G+1]+" "+U[G+2]),Y++;if(null!=S)for(let G=0;G<S.length;G+=3)s.push("vn "+S[G]*Q+" "+S[G+1]+" "+S[G+2]);if(null!=C)for(let G=0;G<C.length;G+=2)s.push("vt "+C[G]+" "+C[G+1]),n++;const X=["","",""],I=(j.material||j.gG().defaultMaterial)._getEffectiveOrientation(j),[D,g]=I===B.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let G=0;G<t.length;G+=3){const A=[String(t[G]+O),String(t[G+D]+O),String(t[G+g]+O)],j=[String(t[G]+d),String(t[G+D]+d),String(t[G+g]+d)],u=A,k=null!=C?j:X,B=null!=S?A:X;s.push("f "+u[0]+"/"+k[0]+"/"+B[0]+" "+u[1]+"/"+k[1]+"/"+B[1]+" "+u[2]+"/"+k[2]+"/"+B[2])}x&&F&&j.bakeTransformIntoVertices(F),O+=Y,d+=n}return s.join("\n")}static MTL(G){const A=[],j=G.material;A.push("newmtl mat1"),A.push("  Ns "+j.specularPower.toFixed(4)),A.push("  Ni 1.5000"),A.push("  d "+j.alpha.toFixed(4)),A.push("  Tr 0.0000"),A.push("  Tf 1.0000 1.0000 1.0000"),A.push("  illum 2"),A.push("  Ka "+j.ambientColor.r.toFixed(4)+" "+j.ambientColor.g.toFixed(4)+" "+j.ambientColor.b.toFixed(4)),A.push("  Kd "+j.diffuseColor.r.toFixed(4)+" "+j.diffuseColor.g.toFixed(4)+" "+j.diffuseColor.b.toFixed(4)),A.push("  Ks "+j.specularColor.r.toFixed(4)+" "+j.specularColor.g.toFixed(4)+" "+j.specularColor.b.toFixed(4)),A.push("  Ke "+j.emissiveColor.r.toFixed(4)+" "+j.emissiveColor.g.toFixed(4)+" "+j.emissiveColor.b.toFixed(4));j.ambientTexture&&A.push("  map_Ka "+j.ambientTexture.name),j.diffuseTexture&&A.push("  map_Kd "+j.diffuseTexture.name),j.specularTexture&&A.push("  map_Ks "+j.specularTexture.name),j.bumpTexture&&A.push("  map_bump -imfchan z "+j.bumpTexture.name),j.opacityTexture&&A.push("  map_d "+j.opacityTexture.name);return A.join("\n")}}var s=0,O=j(11089);class d{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const G in this.files){const A=this.files[G],j=new Blob([A],{type:(0,O.j)(G)});k.Tools.Download(j,G)}}}var h=j(11290),H=j(11615),F=j(11621),R=j(11631),U=j(11345),S=j(11085),C=j(11262),t=j(11237);const Y=t.HighestCommonFactor,n={...t,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:Y};var Q=j(11447),X=j(11196),I=j(11662),D=j(11671),g=j(11441);const c=1e-6,E=new C.nA(.04,.04,.04),r=1024,b=C.nA.White(),M=C.nA.Black();function o(G,A,j){if(A<E.r)return 0;const u=E.r,k=G*j/(1-E.r)+A-2*E.r,B=k*k-4*u*(E.r-A);return n.Clamp((-k+Math.sqrt(B))/(2*u),0,1)}function W(G){const A=G.diffuseColor.toLinearSpace(G.gG().getEngine().useExactSrgbConversions).scale(.5),j=G.alpha,k=function(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new u.Vector2(0,1),j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new u.Vector2(0,.1),k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new u.Vector2(0,.1),B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new u.Vector2(1300,.1);return function(G,A,j,u,k){return(1-G)*(1-G)*(1-G)*A+3*(1-G)*(1-G)*G*j+3*(1-G)*G*G*u+G*G*G*k}(Math.pow(G/B.x,.333333),A.y,j.y,k.y,B.y)}(n.Clamp(G.specularPower,0,r));return{baseColorFactor:[A.r,A.g,A.b,j],metallicFactor:0,roughnessFactor:k}}function J(G,A){A.needAlphaBlending()?G.alphaMode="BLEND":A.needAlphaTesting()&&(G.alphaMode="MASK",G.alphaCutoff=A.alphaCutOff)}function p(G,A,j){const u=new Uint8Array(G*A*4);for(let k=0;k<u.length;k+=4)u[k]=u[k+1]=u[k+2]=u[k+3]=255;return I.d.CreateRGBATexture(u,G,A,j)}function e(G){if(G instanceof Uint8Array){const A=G.length,j=new Float32Array(G.length);for(let u=0;u<A;++u)j[u]=G[u]/255;return j}if(G instanceof Float32Array)return G;throw new Error("Unsupported pixel format!")}class l{constructor(G){this._exporter=G,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(G){return G?this._textureMap.get(G)??null:null}async exportStandardMaterialAsync(G,A,j){const u=W(G),B={name:G.name};if(null==G.ts||G.ts||(G.twoSidedLighting||k.Tools.Warn(G.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),B.doubleSided=!0),j){const j=[],k=G.diffuseTexture;k&&j.push(this.exportTextureAsync(k,A).then((G=>{G&&(u.baseColorTexture=G)})));const x=G.bumpTexture;x&&j.push(this.exportTextureAsync(x,A).then((G=>{G&&(B.normalTexture=G,1!==x.level&&(B.normalTexture.scale=x.level))})));const s=G.emissiveTexture;s&&(B.emissiveFactor=[1,1,1],j.push(this.exportTextureAsync(s,A).then((G=>{G&&(B.emissiveTexture=G)}))));const O=G.ambientTexture;O&&j.push(this.exportTextureAsync(O,A).then((G=>{if(G){const A={index:G.index};B.occlusionTexture=A}}))),j.length>0&&(this._exporter._materialNeedsUVsSet.add(G),await Promise.all(j))}(G.alpha<1||G.opacityTexture)&&(G.alphaMode===D.d.ALPHA_COMBINE?B.alphaMode="BLEND":k.Tools.Warn(G.name+": glTF 2.0 does not support alpha mode: "+G.alphaMode.toString())),G.emissiveColor&&!G.emissiveColor.equalsWithEpsilon(M,c)&&(B.emissiveFactor=G.emissiveColor.hs()),B.pbrMetallicRoughness=u,J(B,G),await this._finishMaterialAsync(B,G,A);const x=this._exporter._materials;return x.push(B),x.length-1}async _finishMaterialAsync(G,A,j){const u=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",G,A),k=[];for(const B of u)k.push(this.exportTextureAsync(B,j));await Promise.all(k),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",G,A)}async _getImageDataAsync(G,A,u,k){const B=D.d.TEXTURETYPE_UNSIGNED_BYTE,x=this._exporter._babylonScene,s=x.getEngine(),O=s.createRawTexture(G,A,u,D.d.TEXTUREFORMAT_RGBA,!1,!0,X.e.NEAREST_SAMPLINGMODE,null,B);s.isWebGPU?await j.e(51).then(j.bind(j,13675)):await j.e(52).then(j.bind(j,13681)),await Q.h.ApplyPostProcess("pass",O,x,B,D.d.TEXTURE_NEAREST_SAMPLINGMODE,D.d.TEXTUREFORMAT_RGBA);const d=await s._readTexturePixels(O,A,u);return await g.DumpTools.DumpDataAsync(A,u,d,k,void 0,!0,!0)}_resizeTexturesToSameDimensions(G,A,j){const u=G?G.getSize():{width:0,height:0},k=A?A.getSize():{width:0,height:0};let B,x;return u.width<k.width?(B=G&&G instanceof X.e?Q.h.CreateResizedCopy(G,k.width,k.height,!0):p(k.width,k.height,j),x=A):u.width>k.width?(x=A&&A instanceof X.e?Q.h.CreateResizedCopy(A,u.width,u.height,!0):p(u.width,u.height,j),B=G):(B=G,x=A),{texture1:B,texture2:x}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(G,A,j,u){const k=new Array;if(!G&&!A)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const B=G?G.gG():A?A.gG():null;if(B){var x;const s=this._resizeTexturesToSameDimensions(G,A,B),O=null===(x=s.texture1)||void 0===x?void 0:x.getSize();let d,h;const H=O.width,F=O.height,R=await s.texture1.readPixels(),U=await s.texture2.readPixels();if(!R)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(d=e(R),!U)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");h=e(U);const S=h.byteLength,t=new Uint8Array(S),Y=new Uint8Array(S),n=4,Q=M;let X=0,I=0;for(let G=0;G<F;++G)for(let A=0;A<H;++A){const u=(H*G+A)*n,k={diffuseColor:new C.nA(d[u],d[u+1],d[u+2]).toLinearSpace(B.getEngine().useExactSrgbConversions).multiply(j.diffuseColor),specularColor:new C.nA(h[u],h[u+1],h[u+2]).toLinearSpace(B.getEngine().useExactSrgbConversions).multiply(j.specularColor),glossiness:h[u+3]*j.glossiness},x=this._convertSpecularGlossinessToMetallicRoughness(k);Q.r=Math.max(Q.r,x.baseColor.r),Q.g=Math.max(Q.g,x.baseColor.g),Q.b=Math.max(Q.b,x.baseColor.b),X=Math.max(X,x.metallic),I=Math.max(I,x.roughness),Y[u]=255*x.baseColor.r,Y[u+1]=255*x.baseColor.g,Y[u+2]=255*x.baseColor.b,Y[u+3]=s.texture1.Hs?255*d[u+3]:255,t[u]=0,t[u+1]=255*x.roughness,t[u+2]=255*x.metallic,t[u+3]=255}const D={baseColor:Q,metallic:X,roughness:I};let g=!1,E=!1;for(let G=0;G<F;++G)for(let A=0;A<H;++A){const j=(H*G+A)*n;Y[j]/=D.baseColor.r>c?D.baseColor.r:1,Y[j+1]/=D.baseColor.g>c?D.baseColor.g:1,Y[j+2]/=D.baseColor.b>c?D.baseColor.b:1;const u=C.nA.FromInts(Y[j],Y[j+1],Y[j+2]).toGammaSpace(B.getEngine().useExactSrgbConversions);Y[j]=255*u.r,Y[j+1]=255*u.g,Y[j+2]=255*u.b,u.equalsWithEpsilon(b,c)||(E=!0),t[j+1]/=D.roughness>c?D.roughness:1,t[j+2]/=D.metallic>c?D.metallic:1;C.nA.FromInts(255,t[j+1],t[j+2]).equalsWithEpsilon(b,c)||(g=!0)}return g&&k.push(this._getImageDataAsync(t,H,F,u).then((G=>{D.metallicRoughnessTextureData=G}))),E&&k.push(this._getImageDataAsync(Y,H,F,u).then((G=>{D.baseColorTextureData=G}))),await Promise.all(k).then((()=>D))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(G){const A=this._getPerceivedBrightness(G.diffuseColor),j=this._getPerceivedBrightness(G.specularColor),u=1-this._getMaxComponent(G.specularColor),k=o(A,j,u),B=G.diffuseColor.scale(u/(1-E.r)/Math.max(1-k)),x=G.specularColor.CA(E.scale(1-k)).scale(1/Math.max(k));let s=C.nA.Lerp(B,x,k*k);s=s.clampToRef(0,1,s);return{baseColor:s,metallic:k,roughness:1-G.glossiness}}_getPerceivedBrightness(G){return G?Math.sqrt(.299*G.r*G.r+.587*G.g*G.g+.114*G.b*G.b):0}_getMaxComponent(G){return G?Math.max(G.r,Math.max(G.g,G.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(G,A,j,u){const k=[],B={baseColor:G._albedoColor,metallic:G._metallic,roughness:G._roughness};if(u){G._albedoTexture&&k.push(this.exportTextureAsync(G._albedoTexture,A).then((G=>{G&&(j.baseColorTexture=G)})));const u=G._metallicTexture;u&&k.push(this.exportTextureAsync(u,A).then((G=>{G&&(j.metallicRoughnessTexture=G)})))}return k.length>0&&(this._exporter._materialNeedsUVsSet.add(G),await Promise.all(k)),B}_getTextureSampler(G){const A={};if(!G||!(G instanceof X.e))return A;const j=this._getGLTFTextureWrapMode(G.wrapU);10497!==j&&(A.wrapS=j);const u=this._getGLTFTextureWrapMode(G.wrapV);switch(10497!==u&&(A.wrapT=u),G.samplingMode){case X.e.LINEAR_LINEAR:A.magFilter=9729,A.minFilter=9729;break;case X.e.LINEAR_NEAREST:A.magFilter=9729,A.minFilter=9728;break;case X.e.NEAREST_LINEAR:A.magFilter=9728,A.minFilter=9729;break;case X.e.NEAREST_LINEAR_MIPLINEAR:A.magFilter=9728,A.minFilter=9987;break;case X.e.NEAREST_NEAREST:A.magFilter=9728,A.minFilter=9728;break;case X.e.NEAREST_LINEAR_MIPNEAREST:A.magFilter=9728,A.minFilter=9985;break;case X.e.LINEAR_NEAREST_MIPNEAREST:A.magFilter=9729,A.minFilter=9984;break;case X.e.LINEAR_NEAREST_MIPLINEAR:A.magFilter=9729,A.minFilter=9986;break;case X.e.NEAREST_NEAREST_MIPLINEAR:A.magFilter=9728,A.minFilter=9986;break;case X.e.LINEAR_LINEAR_MIPLINEAR:A.magFilter=9729,A.minFilter=9987;break;case X.e.LINEAR_LINEAR_MIPNEAREST:A.magFilter=9729,A.minFilter=9985;break;case X.e.NEAREST_NEAREST_MIPNEAREST:A.magFilter=9728,A.minFilter=9984}return A}_getGLTFTextureWrapMode(G){switch(G){case X.e.WRAP_ADDRESSMODE:return 10497;case X.e.CLAMP_ADDRESSMODE:return 33071;case X.e.MIRROR_ADDRESSMODE:return 33648;default:return k.Tools.Error(`Unsupported Texture Wrap Mode ${G}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(G,A,j,u){const k={diffuseColor:G._albedoColor,specularColor:G._reflectivityColor,glossiness:G._microSurface},B=G._albedoTexture,x=G._reflectivityTexture,s=G._useMicroSurfaceFromReflectivityMapAlpha;if(x&&!s)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((B||x)&&u){this._exporter._materialNeedsUVsSet.add(G);const u=this._exportTextureSampler(B||x),s=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(B,x,k,A),O=this._exporter._textures;if(s.baseColorTextureData){const G=this._exportImage(`baseColor${O.length}`,A,s.baseColorTextureData);j.baseColorTexture=this._exportTextureInfo(G,u,null===B||void 0===B?void 0:B.coordinatesIndex)}if(s.metallicRoughnessTextureData){const G=this._exportImage(`metallicRoughness${O.length}`,A,s.metallicRoughnessTextureData);j.metallicRoughnessTexture=this._exportTextureInfo(G,u,null===x||void 0===x?void 0:x.coordinatesIndex)}return s}return this._convertSpecularGlossinessToMetallicRoughness(k)}async exportPBRMaterialAsync(G,A,j){const u={},k={name:G.name},B=G.isMetallicWorkflow();if(B){const A=G._albedoColor,j=G.alpha;A&&(u.baseColorFactor=[A.r,A.g,A.b,j])}const x=B?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(G,A,u,j):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(G,A,u,j);await this._setMetallicRoughnessPbrMaterialAsync(x,G,k,u,A,j),await this._finishMaterialAsync(k,G,A);const s=this._exporter._materials;return s.push(k),s.length-1}async _setMetallicRoughnessPbrMaterialAsync(G,A,j,u,B,x){if(J(j,A),G.baseColor.equalsWithEpsilon(b,c)&&n.WithinEpsilon(A.alpha,1,c)||(u.baseColorFactor=[G.baseColor.r,G.baseColor.g,G.baseColor.b,A.alpha]),null!=G.metallic&&1!==G.metallic&&(u.metallicFactor=G.metallic),null!=G.roughness&&1!==G.roughness&&(u.roughnessFactor=G.roughness),null==A.ts||A.ts||(A._twoSidedLighting||k.Tools.Warn(A.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),j.doubleSided=!0),x){const G=[],u=A._bumpTexture;u&&G.push(this.exportTextureAsync(u,B).then((G=>{G&&(j.normalTexture=G,1!==u.level&&(j.normalTexture.scale=u.level))})));const k=A._ambientTexture;k&&G.push(this.exportTextureAsync(k,B).then((G=>{if(G){const u={index:G.index,texCoord:G.texCoord,extensions:G.extensions};j.occlusionTexture=u;const k=A._ambientTextureStrength;k&&(u.strength=k)}})));const x=A._emissiveTexture;x&&G.push(this.exportTextureAsync(x,B).then((G=>{G&&(j.emissiveTexture=G)}))),G.length>0&&(this._exporter._materialNeedsUVsSet.add(A),await Promise.all(G))}const s=A._emissiveColor;s.equalsWithEpsilon(M,c)||(j.emissiveFactor=s.hs()),j.pbrMetallicRoughness=u}_getPixelsFromTextureAsync(G){return function(G){switch(G){case D.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case D.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case D.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case D.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case D.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case D.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case D.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case D.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case D.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case D.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case D.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(G.textureFormat)?(0,Q.e)(G,G._texture.width,G._texture.height):(G.textureType,D.d.TEXTURETYPE_UNSIGNED_BYTE,G.readPixels())}async exportTextureAsync(G,A){const j=this._exporter._extensionsPreExportTextureAsync("exporter",G,A);return j?await j.then((async j=>j?await this._exportTextureInfoAsync(j,A):await this._exportTextureInfoAsync(G,A))):await this._exportTextureInfoAsync(G,A)}async _exportTextureInfoAsync(G,A){let j=this._textureMap.get(G);if(!j){const u=await this._getPixelsFromTextureAsync(G);if(!u)return null;const B=this._exportTextureSampler(G),x=G.mimeType;if(x)switch(x){case"image/jpeg":case"image/png":case"image/webp":A=x;break;default:k.Tools.Warn(`Unsupported media type: ${x}. Exporting texture as PNG.`)}const s=this._internalTextureToImage,O=G.getInternalTexture().uniqueId;s[O]||(s[O]={});let d=s[O][A];if(void 0===d){const j=G.getSize();d=(async()=>{const k=await this._getImageDataAsync(u,j.width,j.height,A);return this._exportImage(G.name,A,k)})(),s[O][A]=d}j=this._exportTextureInfo(await d,B,G.coordinatesIndex),this._textureMap.set(G,j),this._exporter._extensionsPostExportTextures("exporter",j,G)}return j}_exportImage(G,A,j){const u=this._exporter._images;let B;if(this._exporter._shouldUseGlb){B={name:G,mimeType:A,bufferView:void 0};const u=this._exporter._bufferManager.createBufferView(new Uint8Array(j));this._exporter._bufferManager.setBufferView(B,u)}else{const x=G.replace(/\.\/|\/|\.\\|\\/g,"_"),s=function(G){switch(G){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(A);let O=x+s;u.some((G=>G.uri===O))&&(O=`${x}_${k.Tools.RandomId()}${s}`),B={name:G,uri:O},this._exporter._imageData[O]={data:j,mimeType:A}}return u.push(B),u.length-1}_exportTextureInfo(G,A,j){const u=this._exporter._textures;let k=u.findIndex((j=>j.sampler==A&&j.source===G));-1===k&&(k=u.length,u.push({source:G,sampler:A}));const B={index:k};return j&&(B.texCoord=j),B}_exportTextureSampler(G){const A=this._getTextureSampler(G),j=this._exporter._samplers,u=j.findIndex((G=>G.minFilter===A.minFilter&&G.magFilter===A.magFilter&&G.wrapS===A.wrapS&&G.wrapT===A.wrapT));return-1!==u?u:(j.push(A),j.length-1)}}var w=j(11299),Z=j(11065),P=j(11677),N=j(11222);const q=u.SA.Zero(),a=u.Quaternion.Identity(),y=u.SA.One(),z=new u.SA(-1,1,1);function f(G,A){const{byteOffset:j,byteStride:u,type:k,normalized:B}=G,x=G.getSize(),s=A.reduce(((G,A)=>A.getTotalVertices()>G?A.getTotalVertices():G),-Number.MAX_VALUE);return{byteOffset:j,byteStride:u,componentCount:x,type:k,count:s*x,normalized:B,totalVertices:s,kind:G.getKind()}}function v(G){switch(G){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function i(G){switch(G){case h.h.PositionKind:case h.h.NormalKind:case h.h.TangentKind:case h.h.ColorKind:case h.h.MatricesIndicesKind:case h.h.MatricesIndicesExtraKind:case h.h.MatricesWeightsKind:case h.h.MatricesWeightsExtraKind:case h.h.UVKind:case h.h.UV2Kind:case h.h.UV3Kind:case h.h.UV4Kind:case h.h.UV5Kind:case h.h.UV6Kind:return!0}return!1}function L(G){switch(G){case B.b.TriangleFillMode:return 4;case B.b.TriangleStripDrawMode:return 5;case B.b.TriangleFanDrawMode:return 6;case B.b.PointListDrawMode:case B.b.PointFillMode:return 0;case B.b.LineLoopDrawMode:return 2;case B.b.LineListDrawMode:return 1;case B.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${G}`)}function V(G){const A=Math.sqrt(G.x*G.x+G.y*G.y+G.z*G.z);A>0&&(G.x/=A,G.y/=A,G.z/=A)}function K(G){return G.x*=-1,G}function T(G){if(G.x*G.x+G.y*G.y>.5){const A=Math.abs(G.x),j=Math.abs(G.y);if(A>j){const j=Math.sign(G.x);G.x=A,G.y*=-j,G.z*=-j,G.w*=j}else{const A=Math.sign(G.y);G.x*=-A,G.y=j,G.z*=A,G.w*=-A}}else{const A=Math.abs(G.z),j=Math.abs(G.w);if(A>j){const j=Math.sign(G.z);G.x*=-j,G.y*=j,G.z=A,G.w*=-j}else{const A=Math.sign(G.w);G.x*=A,G.y*=-A,G.z*=-A,G.w=j}}return G}function m(G){G.Ys(-G.z,G.w,G.x,-G.y)}function GG(G,A){const j=u.SA.FromArrayToRef(A.translation||[0,0,0],0,u.TmpVectors.SA[0]),k=u.Quaternion.FromArrayToRef(A.rotation||[0,0,0,1],0,u.TmpVectors.Quaternion[0]),B=u.Matrix.ComposeToRef(y,k,j,u.TmpVectors.Matrix[0]),x=u.SA.FromArrayToRef(G.translation||[0,0,0],0,u.TmpVectors.SA[2]),s=u.Quaternion.FromArrayToRef(G.rotation||[0,0,0,1],0,u.TmpVectors.Quaternion[1]),O=u.Matrix.ComposeToRef(y,s,x,u.TmpVectors.Matrix[1]);B.multiplyToRef(O,O),O.decompose(void 0,k,j),j.equalsWithEpsilon(q,N.d)?delete A.translation:A.translation=j.hs(),k.equalsWithEpsilon(a,N.d)?delete A.rotation:A.rotation=k.hs(),A.scale&&delete A.scale}function AG(G,A){if(!(A instanceof H.c))return!1;if(!(1===A.getChildren().length&&0===G.getChildren().length&&G.parent===A))return!1;const j=G.gG(),u=G instanceof P.d&&!j.useRightHandedSystem?z:y;return!!A.ns.equalsWithEpsilon(u,N.d)||(Z.e.Warn(`Cannot collapse node ${G.name} into parent node ${A.name} with modified scaling.`),!1)}function jG(G){if(G instanceof Array){const A=new Float32Array(G);return new Uint8Array(A.buffer,A.byteOffset,A.byteLength)}return ArrayBuffer.isView(G)?new Uint8Array(G.buffer,G.byteOffset,G.byteLength):new Uint8Array(G)}function uG(G,A){for(const[j,u]of Object.entries(G)){const k=A[j];(Array.isArray(u)&&Array.isArray(k)&&kG(u,k)||u===k)&&delete G[j]}return G}function kG(G,A){return G.length===A.length&&G.every(((G,j)=>G===A[j]))}const BG=u.Matrix.Compose(new u.SA(-1,1,1),u.Quaternion.Identity(),u.SA.Zero());function xG(G,A){if(!(G instanceof H.c))return!1;if(A){if(!G.getWorldMatrix().equalsWithEpsilon(u.Matrix.IdentityReadOnly,N.d))return!1}else{if(!G.getWorldMatrix().multiplyToRef(BG,u.TmpVectors.Matrix[0]).equalsWithEpsilon(u.Matrix.IdentityReadOnly,N.d))return!1}return!(G instanceof F.b&&G.Ss)}const sG=new Map([[Int8Array,(G,A,j)=>G.setInt8(A,j)],[Uint8Array,(G,A,j)=>G.setUint8(A,j)],[Uint8ClampedArray,(G,A,j)=>G.setUint8(A,j)],[Int16Array,(G,A,j)=>G.setInt16(A,j,!0)],[Uint16Array,(G,A,j)=>G.setUint16(A,j,!0)],[Int32Array,(G,A,j)=>G.setInt32(A,j,!0)],[Uint32Array,(G,A,j)=>G.setUint32(A,j,!0)],[Float32Array,(G,A,j)=>G.setFloat32(A,j,!0)],[Float64Array,(G,A,j)=>G.setFloat64(A,j,!0)]]);class OG{writeTypedArray(G){this._checkGrowBuffer(G.byteLength);const A=sG.get(G.constructor);for(let j=0;j<G.length;j++)A(this._dataView,this._byteOffset,G[j]),this._byteOffset+=G.BYTES_PER_ELEMENT}constructor(G){this._data=new Uint8Array(G),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(G){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,G),this._byteOffset++}writeInt8(G){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,G),this._byteOffset++}writeInt16(G){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,G,!0),this._byteOffset+=2}writeUInt16(G){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,G,!0),this._byteOffset+=2}writeInt32(G){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,G,!0),this._byteOffset+=4}writeUInt32(G){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,G,!0),this._byteOffset+=4}writeFloat32(G){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,G,!0),this._byteOffset+=4}writeFloat64(G){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,G,!0),this._byteOffset+=8}_checkGrowBuffer(G){const A=this.byteOffset+G;if(A>this._data.byteLength){const G=new Uint8Array(2*A);G.set(this._data),this._data=G,this._dataView=new DataView(this._data.buffer)}}}function dG(G){return G%4===0?4:G%2===0?2:1}class hG{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(G){let A=0;this._bufferViewToData.forEach((G=>{A+=G.byteLength}));const j=new OG(A),u=Array.from(this._bufferViewToData.keys()).sort(((G,A)=>dG(A.byteLength)-dG(G.byteLength)));for(const k of u){k.byteOffset=j.byteOffset,G.push(k);const A=G.length-1,u=this.getPropertiesWithBufferView(k);for(const G of u)G.bufferView=A;j.writeTypedArray(this._bufferViewToData.get(k)),this._bufferViewToData.delete(k)}return j.getOutputData()}createBufferView(G,A){const j={buffer:0,byteOffset:void 0,byteLength:G.byteLength,byteStride:A};return this._bufferViewToData.set(j,G),j}createAccessor(G,A,j,u,k,B,x){this._verifyBufferView(G);const s={bufferView:void 0,componentType:j,count:u,type:A,min:null===B||void 0===B?void 0:B.min,max:null===B||void 0===B?void 0:B.max,normalized:x,byteOffset:k};return this.setBufferView(s,G),this._accessorToBufferView.set(s,G),s}setBufferView(G,A){this._verifyBufferView(A);this.getPropertiesWithBufferView(A).push(G)}removeBufferView(G){const A=this.getPropertiesWithBufferView(G);for(const j of A)void 0!==j.bufferView&&delete j.bufferView;this._bufferViewToData.delete(G),this._bufferViewToProperties.delete(G),this._accessorToBufferView.forEach(((A,j)=>{A===G&&(void 0!==j.byteOffset&&delete j.byteOffset,this._accessorToBufferView.delete(j))}))}getBufferView(G){const A=this._accessorToBufferView.get(G);return this._verifyBufferView(A),A}getPropertiesWithBufferView(G){return this._verifyBufferView(G),this._bufferViewToProperties.set(G,this._bufferViewToProperties.get(G)??[]),this._bufferViewToProperties.get(G)}getData(G){return this._verifyBufferView(G),this._bufferViewToData.get(G)}_verifyBufferView(G){if(void 0===G||!this._bufferViewToData.has(G))throw new Error(`BufferView ${G} not found in BufferManager.`)}}var HG,FG=j(11643),RG=j(11660),UG=j(11679),SG=j(11574),CG=j(11709),tG=j(11713),YG=j(11639),nG=j(11717);!function(G){G[G.INTANGENT=0]="INTANGENT",G[G.OUTTANGENT=1]="OUTTANGENT"}(HG||(HG={}));class QG{static _IsTransformable(G){return G&&(G instanceof H.c||G instanceof FG.d||G instanceof nG.b)}static _CreateNodeAnimation(G,A,j,u,B){if(this._IsTransformable(G)){const x=[],s=[],O=A.getKeys(),d=QG._CalculateMinMaxKeyFrames(O),h=QG._DeduceInterpolation(O,j,u),H=h.interpolationType,F=h.shouldBakeAnimation;if(F?QG._CreateBakedAnimation(G,A,j,d.min,d.max,A.framePerSecond,B,x,s,d,u):"LINEAR"===H||"STEP"===H?QG._CreateLinearOrStepAnimation(G,A,j,x,s,u):"CUBICSPLINE"===H?QG._CreateCubicSplineAnimation(G,A,j,x,s,u):QG._CreateBakedAnimation(G,A,j,d.min,d.max,A.framePerSecond,B,x,s,d,u),x.length&&s.length){return{inputs:x,outputs:s,samplerInterpolation:H,inputsMin:F?d.min:k.Tools.FloatRound(d.min/A.framePerSecond),inputsMax:F?d.max:k.Tools.FloatRound(d.max/A.framePerSecond)}}}return null}static _DeduceAnimationInfo(G){let A=null,j="VEC3",u=!1;const B=G.targetProperty.split(".");switch(B[0]){case"ns":A="scale";break;case"position":A="translation";break;case"rotation":j="VEC4",A="rotation";break;case"rotationQuaternion":j="VEC4",u=!0,A="rotation";break;case"influence":j="SCALAR",A="weights";break;default:k.Tools.Error(`Unsupported animatable property ${B[0]}`)}return A?{animationChannelTargetPath:A,dataAccessorType:j,useQuaternion:u}:(k.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(G,A,j,u,k,B,x,s,O,d,h){let H;if(QG._IsTransformable(G)&&G.animations)for(const F of G.animations){if(h&&!h(F))continue;const k=QG._DeduceAnimationInfo(F);k&&(H={name:F.name,samplers:[],channels:[]},QG._AddAnimation(`${F.name}`,F.hasRunningRuntimeAnimations?A:H,G,F,k.dataAccessorType,k.animationChannelTargetPath,u,B,x,s,k.useQuaternion,O,d),H.samplers.length&&H.channels.length&&j.push(H))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(G,A,j,u,k,B,x,s,O,d,h){let H;if(G instanceof YG.d){const k=G.morphTargetManager;if(k)for(let F=0;F<k.numTargets;++F){const R=k.getTarget(F);for(const U of R.animations){if(h&&!h(U))continue;const R=new CG.d(`${U.name}`,"influence",U.framePerSecond,U.dataType,U.loopMode,U.enableBlending),S=[],C=U.getKeys();for(let G=0;G<C.length;++G){const A=C[G];for(let G=0;G<k.numTargets;++G)G==F?S.push(A):S.push({frame:A.frame,value:0})}R.setKeys(S);const t=QG._DeduceAnimationInfo(R);t&&(H={name:R.name,samplers:[],channels:[]},QG._AddAnimation(U.name,U.hasRunningRuntimeAnimations?A:H,G,R,t.dataAccessorType,t.animationChannelTargetPath,u,B,x,s,t.useQuaternion,O,d,k.numTargets),H.samplers.length&&H.channels.length&&j.push(H))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(G,A,j,u,k,B,x,s,O){let d;if(G.animationGroups){const H=G.animationGroups;for(const F of H){const H=new Map,R=new Map,U=new Set,S=F.to-F.from;d={name:F.name,channels:[],samplers:[]};for(let A=0;A<F.targetedAnimations.length;++A){const S=F.targetedAnimations[A],C=S.target,t=S.animation;if(O&&!O(t))continue;const Y=s.has(C);if(this._IsTransformable(C)||1===C.length&&this._IsTransformable(C[0])){const G=QG._DeduceAnimationInfo(S.animation);if(G){const A=this._IsTransformable(C)?C:this._IsTransformable(C[0])?C[0]:null;A&&QG._AddAnimation(`${t.name}`,d,A,t,G.dataAccessorType,G.animationChannelTargetPath,j,u,k,B,G.useQuaternion,x,Y)}}else if(C instanceof tG.d||1===C.length&&C[0]instanceof tG.d){if(QG._DeduceAnimationInfo(S.animation)){const A=C instanceof tG.d?C:C[0];if(A){const j=G.morphTargetManagers.find((G=>{for(let j=0;j<G.numTargets;++j)if(G.getTarget(j)===A)return!0;return!1}));if(j){const u=G.meshes.find((G=>G.morphTargetManager===j));var h;if(u)H.has(u)||H.set(u,new Map),null===(h=H.get(u))||void 0===h||h.set(A,t),U.add(u),R.set(u,t)}}}}}U.forEach((G=>{const A=G.morphTargetManager;let s=null;const O=[],h=R.get(G).getKeys(),U=h.length;for(let j=0;j<U;++j)for(let u=0;u<A.numTargets;++u){const k=A.getTarget(u),B=H.get(G);if(B){const A=B.get(k);A?(s||(s=new CG.d(`${F.name}_${G.name}_MorphWeightAnimation`,"influence",A.framePerSecond,CG.d.ANIMATIONTYPE_FLOAT,A.loopMode,A.enableBlending)),O.push(A.getKeys()[j])):O.push({frame:F.from+S/U*j,value:k.influence,inTangent:h[0].inTangent?0:void 0,outTangent:h[0].outTangent?0:void 0})}}s.setKeys(O);const C=QG._DeduceAnimationInfo(s);C&&QG._AddAnimation(`${F.name}_${G.name}_MorphWeightAnimation`,d,G,s,C.dataAccessorType,C.animationChannelTargetPath,j,u,k,B,C.useQuaternion,x,!1,null===A||void 0===A?void 0:A.numTargets)})),d.channels.length&&d.samplers.length&&A.push(d)}}}static _AddAnimation(G,A,j,k,B,x,s,O,d,h,H,F,R,U){const S=QG._CreateNodeAnimation(j,k,x,H,F);let C,t,Y,n,Q,X;if(S){if(U){let G=0,A=0;const j=[];for(;S.inputs.length>0;)A=S.inputs.shift(),G%U==0&&j.push(A),G++;S.inputs=j}const G=s.get(j),k=new Float32Array(S.inputs);C=O.createBufferView(k),t=O.createAccessor(C,"SCALAR",5126,S.inputs.length,void 0,{min:[S.inputsMin],max:[S.inputsMax]}),h.push(t),Y=h.length-1;const d=new u.Quaternion,H=new u.SA,F=new u.SA,I=j instanceof FG.d,D=v(B),g=new Float32Array(S.outputs.length*D);S.outputs.forEach((function(G,A){let j=G;switch(x){case"translation":R&&(u.SA.FromArrayToRef(G,0,F),K(F),F.toArray(j));break;case"rotation":4===G.length?u.Quaternion.FromArrayToRef(G,0,d):(j=new Array(4),u.SA.FromArrayToRef(G,0,H),u.Quaternion.FromEulerVectorToRef(H,d)),R&&(T(d),I&&m(d)),d.toArray(j)}g.set(j,A*D)})),C=O.createBufferView(g),t=O.createAccessor(C,B,5126,S.outputs.length),h.push(t),n=h.length-1,Q={interpolation:S.samplerInterpolation,input:Y,output:n},A.samplers.push(Q),X={sampler:A.samplers.length-1,target:{node:G,path:x}},A.channels.push(X)}}static _CreateBakedAnimation(G,A,j,B,x,s,O,d,h,H,F){let R;const U=u.Quaternion.Identity();let S,C=null,t=null,Y=null,n=null,Q=null,X=null;H.min=k.Tools.FloatRound(B/s);const I=A.getKeys();for(let u=0,D=I.length;u<D;++u){if(X=null,Y=I[u],u+1<D)if(n=I[u+1],Y.value.equals&&Y.value.equals(n.value)||Y.value===n.value){if(0!==u)continue;X=Y.frame}else X=n.frame;else{if(Q=I[u-1],Y.value.equals&&Y.value.equals(Q.value)||Y.value===Q.value)continue;X=x}if(X)for(let u=Y.frame;u<=X;u+=O){if(S=k.Tools.FloatRound(u/s),S===C)continue;C=S,t=S;const B={key:0,repeatCount:0,loopMode:A.loopMode};R=A._interpolate(u,B),QG._SetInterpolatedValue(G,R,S,A,j,U,d,h,F)}}t&&(H.max=t)}static _ConvertFactorToVector3OrQuaternion(G,A,j,B,x){const s=QG._GetBasePositionRotationOrScale(A,B,x),O=j.targetProperty.split("."),d=O?O[1]:"",h=x?u.Quaternion.QA(s).normalize():u.SA.QA(s);switch(d){case"x":case"y":case"z":h[d]=G;break;case"w":h.w=G;break;default:k.Tools.Error(`glTFAnimation: Unsupported component name "${d}"!`)}return h}static _SetInterpolatedValue(G,A,j,k,B,x,s,O,d){let h;s.push(j),"weights"!==B?(k.dataType===CG.d.ANIMATIONTYPE_FLOAT&&(A=this._ConvertFactorToVector3OrQuaternion(A,G,k,B,d)),"rotation"===B?(d?x=A:(h=A,u.Quaternion.RotationYawPitchRollToRef(h.y,h.x,h.z,x)),O.push(x.hs())):(h=A,O.push(h.hs()))):O.push([A])}static _CreateLinearOrStepAnimation(G,A,j,u,k,B){for(const x of A.getKeys())u.push(x.frame/A.framePerSecond),QG._AddKeyframeValue(x,A,k,j,G,B)}static _CreateCubicSplineAnimation(G,A,j,u,k,B){A.getKeys().forEach((function(x){u.push(x.frame/A.framePerSecond),QG._AddSplineTangent(HG.INTANGENT,k,j,"CUBICSPLINE",x,B),QG._AddKeyframeValue(x,A,k,j,G,B),QG._AddSplineTangent(HG.OUTTANGENT,k,j,"CUBICSPLINE",x,B)}))}static _GetBasePositionRotationOrScale(G,A,j){let k;if("rotation"===A)if(j){k=(G.rotationQuaternion??u.Quaternion.Identity()).hs()}else{k=(G.rotation??u.SA.Zero()).hs()}else if("translation"===A){k=(G.position??u.SA.Zero()).hs()}else{k=(G.ns??u.SA.One()).hs()}return k}static _AddKeyframeValue(G,A,j,B,x,s){let O;const d=A.dataType;if(d===CG.d.ANIMATIONTYPE_VECTOR3){let A=G.value.hs();if("rotation"===B){const G=u.SA.QA(A);A=u.Quaternion.RotationYawPitchRoll(G.y,G.x,G.z).hs()}j.push(A)}else if(d===CG.d.ANIMATIONTYPE_FLOAT){if("weights"===B)j.push([G.value]);else if(O=this._ConvertFactorToVector3OrQuaternion(G.value,x,A,B,s),O){if("rotation"===B){const G=s?O:u.Quaternion.RotationYawPitchRoll(O.y,O.x,O.z).normalize();j.push(G.hs())}j.push(O.hs())}}else d===CG.d.ANIMATIONTYPE_QUATERNION?j.push(G.value.normalize().hs()):k.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(G,A,j){let u,k,B=!1;if("rotation"===A&&!j)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let x=0,s=G.length;x<s;++x)if(k=G[x],k.inTangent||k.outTangent)if(u){if("CUBICSPLINE"!==u){u="LINEAR",B=!0;break}}else u="CUBICSPLINE";else if(u){if("CUBICSPLINE"===u||k.interpolation&&1===k.interpolation&&"STEP"!==u){u="LINEAR",B=!0;break}}else u=k.interpolation&&1===k.interpolation?"STEP":"LINEAR";return u||(u="LINEAR"),{interpolationType:u,shouldBakeAnimation:B}}static _AddSplineTangent(G,A,j,k,B,x){let s;const O=G===HG.INTANGENT?B.inTangent:B.outTangent;if("CUBICSPLINE"===k){if("rotation"===j)if(O)if(x)s=O.hs();else{const G=O;s=u.Quaternion.RotationYawPitchRoll(G.y,G.x,G.z).hs()}else s=[0,0,0,0];else s="weights"===j?O?[O]:[0]:O?O.hs():[0,0,0];A.push(s)}}static _CalculateMinMaxKeyFrames(G){let A=1/0,j=-1/0;return G.forEach((function(G){A=Math.min(A,G.frame),j=Math.max(j,G.frame)})),{min:A,max:j}}}function XG(G,A,j,B,x,s){const O={attributes:{},influence:G.influence,name:G.name},d=A.Ss;if(!d)return k.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),O;const H=s?-1:1,F=u.SA.Zero();let R=0,U=0;if(G.hasPositions){const B=G.getPositions(),s=d.getVerticesData(h.h.PositionKind);if(s){const G=new Float32Array(s.length),A=[1/0,1/0,1/0],k=[-1/0,-1/0,-1/0];U=s.length/3,R=0;for(let j=R;j<U;++j){const x=u.SA.QA(s,3*j);u.SA.QA(B,3*j).subtractToRef(x,F),F.x*=H,A[0]=Math.min(A[0],F.x),k[0]=Math.max(k[0],F.x),A[1]=Math.min(A[1],F.y),k[1]=Math.max(k[1],F.y),A[2]=Math.min(A[2],F.z),k[2]=Math.max(k[2],F.z),G[3*j]=F.x,G[3*j+1]=F.y,G[3*j+2]=F.z}const d=j.createBufferView(G,12),h=j.createAccessor(d,"VEC3",5126,B.length/3,0,{min:A,max:k});x.push(h),O.attributes.POSITION=x.length-1}else k.Tools.Warn(`Morph target positions for mesh ${A.name} were not exported. Mesh does not have position vertex data`)}if(G.hasNormals){const B=G.getNormals(),s=d.getVerticesData(h.h.NormalKind);if(s){const G=new Float32Array(s.length);U=s.length/3,R=0;for(let j=R;j<U;++j){const A=u.SA.QA(s,3*j).normalize();u.SA.QA(B,3*j).normalize().subtractToRef(A,F),G[3*j]=F.x*H,G[3*j+1]=F.y,G[3*j+2]=F.z}const A=j.createBufferView(G,12),k=j.createAccessor(A,"VEC3",5126,B.length/3,0);x.push(k),O.attributes.NORMAL=x.length-1}else k.Tools.Warn(`Morph target normals for mesh ${A.name} were not exported. Mesh does not have normals vertex data`)}if(G.hasTangents){const B=G.getTangents(),s=d.getVerticesData(h.h.TangentKind);if(s){U=s.length/4;const G=new Float32Array(3*U);R=0;for(let j=R;j<U;++j){const A=u.SA.QA(s,4*j);V(A);const k=u.SA.QA(B,3*j);V(k),k.subtractToRef(A,F),G[3*j]=F.x*H,G[3*j+1]=F.y,G[3*j+2]=F.z}const A=j.createBufferView(G,12),k=j.createAccessor(A,"VEC3",5126,U,0);x.push(k),O.attributes.TANGENT=x.length-1}else k.Tools.Warn(`Morph target tangents for mesh ${A.name} were not exported. Mesh does not have tangents vertex data`)}if(G.hasColors){const B=G.getColors(),s=d.getVerticesData(h.h.ColorKind),H=d.getVertexBuffer(h.h.ColorKind);if(s&&H){const G=H.getSize();U=s.length/G;const A=new Float32Array(U*G);R=0;for(let j=R;j<U;++j)if(3===G){const k=u.SA.QA(s,j*G);u.SA.QA(B,j*G).subtractToRef(k,F),A[3*j]=F.x,A[3*j+1]=F.y,A[3*j+2]=F.z}else if(4===G){const k=new u.Vector4,x=u.Vector4.QA(s,j*G);u.Vector4.QA(B,j*G).subtractToRef(x,k),A[4*j]=k.x,A[4*j+1]=k.y,A[4*j+2]=k.z,A[4*j+3]=k.w}else k.Tools.Warn(`Unsupported number of components for color attribute: ${G}`);const d=j.createBufferView(A,4*G),h=j.createAccessor(d,3===G?"VEC3":"VEC4",5126,U,0);x.push(h),O.attributes.COLOR_0=x.length-1}else k.Tools.Warn(`Morph target colors for mesh ${A.name} were not exported. Mesh does not have colors vertex data`)}return O}var IG=j(11724),DG=j(11599),gG=j(11585),cG=j(11181);class EG{}EG.DEFAULT_COLOR=C.nA.White(),EG.DEFAULT_WIDTH_ATTENUATED=1,EG.DEFAULT_WIDTH=.1;var rG=j(11428),bG=j(11732);class MG{static ConvertPoints(G,A){if(G.length&&Array.isArray(G)&&"number"===typeof G[0])return[G];if(G.length&&Array.isArray(G[0])&&"number"===typeof G[0][0])return G;if(G.length&&!Array.isArray(G[0])&&G[0]instanceof u.SA){const A=[];for(let j=0;j<G.length;j++){const u=G[j];A.push(u.x,u.y,u.z)}return[A]}if(G.length>0&&Array.isArray(G[0])&&G[0].length>0&&G[0][0]instanceof u.SA){const A=[],j=G;for(const G of j)A.push(G.flatMap((G=>[G.x,G.y,G.z])));return A}if(G instanceof Float32Array){if(null!==A&&void 0!==A&&A.floatArrayStride){const j=[],u=3*A.floatArrayStride;for(let A=0;A<G.length;A+=u){const k=new Array(u);for(let j=0;j<u;j++)k[j]=G[A+j];j.push(k)}return j}return[Array.from(G)]}if(G.length&&G[0]instanceof Float32Array){const A=[];for(const j of G)A.push(Array.from(j));return A}return[]}static OmitZeroLengthPredicate(G,A,j){const u=[];return A.CA(G).lengthSquared()>0&&u.push([G,A]),j.CA(A).lengthSquared()>0&&u.push([A,j]),G.CA(j).lengthSquared()>0&&u.push([j,G]),0===u.length?null:u}static OmitDuplicatesPredicate(G,A,j,u){const k=[];return MG._SearchInPoints(G,A,u)||k.push([G,A]),MG._SearchInPoints(A,j,u)||k.push([A,j]),MG._SearchInPoints(j,G,u)||k.push([j,G]),0===k.length?null:k}static _SearchInPoints(G,A,j){for(const x of j)for(let j=0;j<x.length;j++){var u,k,B;if(null!==(u=x[j])&&void 0!==u&&u.equals(G))if(null!==(k=x[j+1])&&void 0!==k&&k.equals(A)||null!==(B=x[j-1])&&void 0!==B&&B.equals(A))return!0}return!1}static MeshesToLines(G,A){const j=[];for(let k=0;k<G.length;k++){const B=G[k],x=B.getVerticesData(h.h.PositionKind),s=B.Cs();if(x&&s)for(let G=0,O=0;G<s.length;G++){const d=3*s[O++],h=3*s[O++],H=3*s[O++],F=new u.SA(x[d],x[d+1],x[d+2]),R=new u.SA(x[h],x[h+1],x[h+2]),U=new u.SA(x[H],x[H+1],x[H+2]);if(A){const u=A(F,R,U,j,G,d,B,k,x,s);if(u)for(const G of u)j.push(G)}else j.push([F,R],[R,U],[U,F])}}return j}static ToVector3Array(G){if(Array.isArray(G[0])){const A=[],j=G;for(const G of j){const j=[];for(let A=0;A<G.length;A+=3)j.push(new u.SA(G[A],G[A+1],G[A+2]));A.push(j)}return A}const A=G,j=[];for(let k=0;k<A.length;k+=3)j.push(new u.SA(A[k],A[k+1],A[k+2]));return j}static ToNumberArray(G){return G.flatMap((G=>[G.x,G.y,G.z]))}static GetPointsCountInfo(G){const A=new Array(G.length);let j=0;for(let u=G.length;u--;)A[u]=G[u].length/3,j+=A[u];return{total:j,counts:A}}static GetLineLength(G){if(0===G.length)return 0;let A;A="number"===typeof G[0]?MG.ToVector3Array(G):G;const j=u.TmpVectors.SA[0];let k=0;for(let u=0;u<A.length-1;u++){const G=A[u];k+=A[u+1].subtractToRef(G,j).length()}return k}static GetLineLengthArray(G){const A=new Float32Array(G.length/3);let j=0;for(let u=0,k=G.length/3-1;u<k;u++){let k=G[3*u+0],B=G[3*u+1],x=G[3*u+2];k-=G[3*u+3],B-=G[3*u+4],x-=G[3*u+5];j+=Math.sqrt(k*k+B*B+x*x),A[u+1]=j}return A}static SegmentizeSegmentByCount(G,A,j){const k=[],B=A.CA(G),x=u.TmpVectors.SA[0];x.Qs(j);const s=u.TmpVectors.SA[1];B.divideToRef(x,s);let O=G.clone();k.push(O);for(let u=0;u<j;u++)O=O.clone(),k.push(O.addInPlace(s));return k}static SegmentizeLineBySegmentLength(G,A){const j=G[0]instanceof u.SA?MG.GetLineSegments(G):"number"===typeof G[0]?MG.GetLineSegments(MG.ToVector3Array(G)):G,k=[];for(const u of j)if(u.length>A){const G=MG.SegmentizeSegmentByCount(u.point1,u.point2,Math.ceil(u.length/A));for(const A of G)k.push(A)}else k.push(u.point1),k.push(u.point2);return k}static SegmentizeLineBySegmentCount(G,A){const j="number"===typeof G[0]?MG.ToVector3Array(G):G,u=MG.GetLineLength(j)/A;return MG.SegmentizeLineBySegmentLength(j,u)}static GetLineSegments(G){const A=[];for(let j=0;j<G.length-1;j++){const u=G[j],k=G[j+1],B=k.CA(u).length();A.push({point1:u,point2:k,length:B})}return A}static GetMinMaxSegmentLength(G){const A=MG.GetLineSegments(G).sort((G=>G.length));return{min:A[0].length,max:A[A.length-1].length}}static GetPositionOnLineByVisibility(G,A,j){let k=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const B=A*j;let x=0,s=0;const O=G.length;for(let u=0;u<O;u++){if(B<=x+G[u].length){s=u;break}x+=G[u].length}const d=(B-x)/G[s].length;return G[s].point2.subtractToRef(G[s].point1,u.TmpVectors.SA[0]),u.TmpVectors.SA[1]=u.TmpVectors.SA[0].multiplyByFloats(d,d,d),k||u.TmpVectors.SA[1].addInPlace(G[s].point1),u.TmpVectors.SA[1].clone()}static GetCircleLinePoints(G,A){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:G,B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/A;const x=[];for(let s=0;s<=A;s++)x.push(new u.SA(Math.cos(s*B)*G,Math.sin(s*B)*k,j));return x}static GetBezierLinePoints(G,A,j,u){return rG.c.CreateQuadraticBezier(G,A,j,u).getPoints().flatMap((G=>[G.x,G.y,G.z]))}static GetArrowCap(G,A,j,u,k){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,x=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[G.clone(),G.add(A.multiplyByFloats(j,j,j))],widths:[u,k,B,x]}}static GetPointsFromText(G,A,j,u){let k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const x=[],s=(0,bG.d)(G,A,j,u);for(const O of s){for(const G of O.paths){const A=[],j=G.getPoints();for(const G of j)A.push(G.x,G.y,k);x.push(A)}if(B)for(const G of O.holes){const A=[],j=G.getPoints();for(const G of j)A.push(G.x,G.y,k);x.push(A)}}return x}static Color3toRGBAUint8(G){const A=new Uint8Array(4*G.length);for(let j=0,u=0;j<G.length;j++)A[u++]=255*G[j].r,A[u++]=255*G[j].g,A[u++]=255*G[j].b,A[u++]=255;return A}static CreateColorsTexture(G,A,j,u){const k=u.getEngine().getCaps().maxTextureSize??1,B=A.length>k?k:A.length,x=Math.ceil(A.length/k);x>1&&(A=[...A,...Array(B*x-A.length).fill(A[0])]);const s=MG.Color3toRGBAUint8(A),O=new I.d(s,B,x,U.b.TEXTUREFORMAT_RGBA,u,!1,!0,j);return O.name=G,O}static PrepareEmptyColorsTexture(G){if(!EG.EmptyColorsTexture){const A=new Uint8Array(4);EG.EmptyColorsTexture=new I.d(A,1,1,U.b.TEXTUREFORMAT_RGBA,G,!1,!1,I.d.NEAREST_NEAREST),EG.EmptyColorsTexture.name="grlEmptyColorsTexture"}return EG.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var G;null===(G=EG.EmptyColorsTexture)||void 0===G||G.dispose(),EG.EmptyColorsTexture=null}static BooleanToNumber(G){return G?1:0}}class oG extends gG.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class WG extends DG.e{isCompatible(G){return!0}constructor(G,A,j){var k;j=j||{color:EG.DEFAULT_COLOR};const B=new oG;B.GREASED_LINE_HAS_COLOR=!!j.color&&!j.useColors,B.GREASED_LINE_SIZE_ATTENUATION=j.sizeAttenuation??!1,B.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===j.colorDistributionType,B.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(A??G.gG()).useRightHandedSystem,B.GREASED_LINE_CAMERA_FACING=j.cameraFacing??!0,super(G,WG.GREASED_LINE_MATERIAL_NAME,200,B,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(k=j)||void 0===k?void 0:k.forceGLSL)||WG.ForceGLSL,this._scene=A??G.gG(),this._engine=this._scene.getEngine(),this._cameraFacing=j.cameraFacing??!0,this.visibility=j.visibility??1,this.useDash=j.useDash??!1,this.dashRatio=j.dashRatio??.5,this.dashOffset=j.dashOffset??0,this.width=j.width?j.width:j.sizeAttenuation?EG.DEFAULT_WIDTH_ATTENUATED:EG.DEFAULT_WIDTH,this._sizeAttenuation=j.sizeAttenuation??!1,this.colorMode=j.colorMode??0,this._color=j.color??null,this.useColors=j.useColors??!1,this._colorsDistributionType=j.colorDistributionType??0,this.colorsSampling=j.colorsSampling??I.d.NEAREST_NEAREST,this._colors=j.bG??null,this.dashCount=j.dashCount??1,this.resolution=j.resolution??new u.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),j.colorsTexture?this.colorsTexture=j.colorsTexture:this._colors?this.colorsTexture=MG.CreateColorsTexture(`${G.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??EG.DEFAULT_COLOR,MG.PrepareEmptyColorsTexture(this._scene)),this._engine.ks.add((()=>{MG.DisposeEmptyColorsTexture()}))}getAttributes(G){G.push("grl_offsets"),G.push("grl_widths"),G.push("grl_colorPointers"),G.push("grl_counters"),this._cameraFacing?(G.push("grl_previousAndSide"),G.push("grl_nextAndCounters")):G.push("grl_slopes")}getSamplers(G){G.push("grl_colors")}getActiveTextures(G){this.colorsTexture&&G.push(this.colorsTexture)}getUniforms(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const A=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&A.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===G&&A.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:A,vertex:this._cameraFacing&&this._isGLSL(G)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(G)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(G){if(this._cameraFacing){G.Rs("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||G.Rs("viewProjection",this._scene.getTransformMatrix());const A=u.TmpVectors.Vector4[0];A.x=this._aspect,A.y=this._resolution.x,A.z=this._resolution.y,A.w=this.width,G.updateVector4("grl_aspect_resolution_lineWidth",A)}const A=u.TmpVectors.Vector4[0];A.x=MG.BooleanToNumber(this.useDash),A.y=this._dashArray,A.z=this.dashOffset,A.w=this.dashRatio,G.updateVector4("grl_dashOptions",A);const j=u.TmpVectors.Vector4[1];j.x=this.colorMode,j.y=this.visibility,j.z=this.colorsTexture?this.colorsTexture.getSize().width:0,j.w=MG.BooleanToNumber(this.useColors),G.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",j),this._color&&G.updateColor3("grl_singleColor",this._color);const k=this.colorsTexture??EG.EmptyColorsTexture;G.setTexture("grl_colors",k),G.updateFloat2("grl_textureSize",(null===k||void 0===k?void 0:k.getSize().width)??1,(null===k||void 0===k?void 0:k.getSize().height)??1)}prepareDefines(G,A,j){G.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,G.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,G.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,G.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=A.useRightHandedSystem,G.GREASED_LINE_CAMERA_FACING=this._cameraFacing,G.GREASED_LINE_USE_OFFSETS=!!j.offsets}getClassName(){return WG.GREASED_LINE_MATERIAL_NAME}getCustomCode(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(A)?function(G,A){if("vertex"===G){const G={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return A&&(G["!gl_Position\\=viewProjection\\*worldPos;"]="//"),G}return"fragment"===G?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(G,this._cameraFacing):function(G,A){if("vertex"===G){const G={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return A&&(G["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),G}return"fragment"===G?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(G,this._cameraFacing)}dispose(){var G;null===(G=this.colorsTexture)||void 0===G||G.dispose(),super.dispose()}get bG(){return this._colors}set bG(G){this.setColors(G)}setColors(G){var A;let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1],u=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const k=(null===(A=this._colors)||void 0===A?void 0:A.length)??0;var B;if(this._colors=G,null!==G&&0!==G.length){if(!j||u)if(this.colorsTexture&&k===G.length&&!u){const A=MG.Color3toRGBAUint8(G);this.colorsTexture.update(A)}else{var x;null===(x=this.colorsTexture)||void 0===x||x.dispose(),this.colorsTexture=MG.CreateColorsTexture(`${this._material.name}-colors-texture`,G,this.colorsSampling,this._scene)}}else null===(B=this.colorsTexture)||void 0===B||B.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(G){this._dashCount=G,this._dashArray=1/G}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(G){this._sizeAttenuation=G,this.markAllDefinesAsDirty()}get color(){return this._color}set color(G){this.setColor(G)}setColor(G){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==G||null!==this._color&&null===G?(this._color=G,A||this.markAllDefinesAsDirty()):this._color=G}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(G){this._colorsDistributionType=G,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(G){this._aspect=G.x/G.y,this._resolution=G}serialize(){const G=super.serialize(),A={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(A.bG=this._colors),this._color&&(A.color=this._color),G.greasedLineMaterialOptions=A,G}parse(G,A,j){var u;super.parse(G,A,j);const k=G.greasedLineMaterialOptions;null===(u=this.colorsTexture)||void 0===u||u.dispose(),k.color&&this.setColor(k.color,!0),k.colorDistributionType&&(this.colorsDistributionType=k.colorDistributionType),k.bG&&(this.bG=k.bG),k.colorsSampling&&(this.colorsSampling=k.colorsSampling),k.colorMode&&(this.colorMode=k.colorMode),k.useColors&&(this.useColors=k.useColors),k.visibility&&(this.visibility=k.visibility),k.useDash&&(this.useDash=k.useDash),k.dashCount&&(this.dashCount=k.dashCount),k.dashRatio&&(this.dashRatio=k.dashRatio),k.dashOffset&&(this.dashOffset=k.dashOffset),k.width&&(this.width=k.width),k.sizeAttenuation&&(this.sizeAttenuation=k.sizeAttenuation),k.resolution&&(this.resolution=k.resolution),this.bG?this.colorsTexture=MG.CreateColorsTexture(`${this._material.name}-colors-texture`,this.bG,this.colorsSampling,A):MG.PrepareEmptyColorsTexture(A),this.markAllDefinesAsDirty()}copyTo(G){var A;const j=G;null===(A=j.colorsTexture)||void 0===A||A.dispose(),this._colors&&(j.colorsTexture=MG.CreateColorsTexture(`${j._material.name}-colors-texture`,this._colors,j.colorsSampling,this._scene)),j.setColor(this.color,!0),j.colorsDistributionType=this.colorsDistributionType,j.colorsSampling=this.colorsSampling,j.colorMode=this.colorMode,j.useColors=this.useColors,j.visibility=this.visibility,j.useDash=this.useDash,j.dashCount=this.dashCount,j.dashRatio=this.dashRatio,j.dashOffset=this.dashOffset,j.width=this.width,j.sizeAttenuation=this.sizeAttenuation,j.resolution=this.resolution,j.markAllDefinesAsDirty()}_isGLSL(G){return 0===G||this._forceGLSL}}WG.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",WG.ForceGLSL=!1,(0,cG.h)(`BABYLON.${WG.GREASED_LINE_MATERIAL_NAME}`,WG);var JG=j(11623),pG=j(11069),eG=j(11449),lG=j(11160);class wG extends eG.ShaderMaterial{constructor(G,A,k){const B=A.getEngine(),x=B.isWebGPU&&!(k.forceGLSL||wG.ForceGLSL),s=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];A.useRightHandedSystem&&s.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const O=["position","grl_widths","grl_offsets","grl_colorPointers"];k.cameraFacing?(s.push("GREASED_LINE_CAMERA_FACING"),O.push("grl_previousAndSide","grl_nextAndCounters")):(O.push("grl_slopes"),O.push("grl_counters"));const d=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(x||d.push("world","viewProjection","view","projection"),super(G,A,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:x?["Scene","Mesh"]:void 0,attributes:O,uniforms:d,samplers:x?[]:["grlColors"],defines:s,extraInitializationsAsync:async()=>{x?await Promise.all([j.e(66).then(j.bind(j,14348)),j.e(75).then(j.bind(j,14357))]):await Promise.all([j.e(69).then(j.bind(j,14366)),j.e(76).then(j.bind(j,14371))])},shaderLanguage:x?1:0}),this._color=C.nA.White(),this._colorsDistributionType=0,this._colorsTexture=null,k=k||{color:EG.DEFAULT_COLOR},this.visibility=k.visibility??1,this.useDash=k.useDash??!1,this.dashRatio=k.dashRatio??.5,this.dashOffset=k.dashOffset??0,this.dashCount=k.dashCount??1,this.width=k.width?k.width:k.sizeAttenuation&&k.cameraFacing?EG.DEFAULT_WIDTH_ATTENUATED:EG.DEFAULT_WIDTH,this.sizeAttenuation=k.sizeAttenuation??!1,this.color=k.color??C.nA.White(),this.useColors=k.useColors??!1,this.colorsDistributionType=k.colorDistributionType??0,this.colorsSampling=k.colorsSampling??I.d.NEAREST_NEAREST,this.colorMode=k.colorMode??0,this._colors=k.bG??null,this._cameraFacing=k.cameraFacing??!0,this.resolution=k.resolution??new u.Vector2(B.getRenderWidth(),B.getRenderHeight()),k.colorsTexture?this.colorsTexture=k.colorsTexture:this._colors?this.colorsTexture=MG.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,A):(this._color=this._color??EG.DEFAULT_COLOR,this.colorsTexture=MG.PrepareEmptyColorsTexture(A)),x){const G=new lG.d;G.setParameters(),G.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",G)}B.ks.add((()=>{MG.DisposeEmptyColorsTexture()}))}dispose(){var G;null===(G=this._colorsTexture)||void 0===G||G.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new u.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get bG(){return this._colors}set bG(G){this.setColors(G)}setColors(G){var A;let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1],u=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const k=(null===(A=this._colors)||void 0===A?void 0:A.length)??0;var B;if(this._colors=G,null!==G&&0!==G.length){if(!j||u)if(this._colorsTexture&&k===G.length&&!u){const A=MG.Color3toRGBAUint8(G);this._colorsTexture.update(A)}else{var x;null===(x=this._colorsTexture)||void 0===x||x.dispose(),this.colorsTexture=MG.CreateColorsTexture(`${this.name}-colors-texture`,G,this.colorsSampling,this.gG())}}else null===(B=this._colorsTexture)||void 0===B||B.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(G){this._colorsTexture=G,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(G){this._width=G,this.setFloat("grlWidth",G)}get useColors(){return this._useColors}set useColors(G){this._useColors=G,this.setFloat("grlUseColors",MG.BooleanToNumber(G))}get colorsSampling(){return this._colorsSampling}set colorsSampling(G){this._colorsSampling=G}get visibility(){return this._visibility}set visibility(G){this._visibility=G,this.setFloat("grlVisibility",G)}get useDash(){return this._useDash}set useDash(G){this._useDash=G,this.setFloat("grlUseDash",MG.BooleanToNumber(G))}get dashOffset(){return this._dashOffset}set dashOffset(G){this._dashOffset=G,this.setFloat("grlDashOffset",G)}get dashRatio(){return this._dashRatio}set dashRatio(G){this._dashRatio=G,this.setFloat("grlDashRatio",G)}get dashCount(){return this._dashCount}set dashCount(G){this._dashCount=G,this._dashArray=1/G,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(G){this._sizeAttenuation=G,this.setFloat("grlSizeAttenuation",MG.BooleanToNumber(G))}get color(){return this._color}set color(G){this.setColor(G)}setColor(G){G=G??EG.DEFAULT_COLOR,this._color=G,this.setColor3("grlColor",G)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(G){this._colorsDistributionType=G,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(G){this._colorMode=G,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(G){this._resolution=G,this.setVector2("grlResolution",G),this.setFloat("grlAspect",G.x/G.y)}serialize(){const G=super.serialize(),A={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(A.bG=this._colors),G.greasedLineMaterialOptions=A,G}parse(G,A,j){var u;const k=G.greasedLineMaterialOptions;null===(u=this._colorsTexture)||void 0===u||u.dispose(),k.color&&(this.color=k.color),k.colorDistributionType&&(this.colorsDistributionType=k.colorDistributionType),k.colorsSampling&&(this.colorsSampling=k.colorsSampling),k.colorMode&&(this.colorMode=k.colorMode),k.useColors&&(this.useColors=k.useColors),k.visibility&&(this.visibility=k.visibility),k.useDash&&(this.useDash=k.useDash),k.dashCount&&(this.dashCount=k.dashCount),k.dashRatio&&(this.dashRatio=k.dashRatio),k.dashOffset&&(this.dashOffset=k.dashOffset),k.width&&(this.width=k.width),k.sizeAttenuation&&(this.sizeAttenuation=k.sizeAttenuation),k.resolution&&(this.resolution=k.resolution),k.bG?this.colorsTexture=MG.CreateColorsTexture(`${this.name}-colors-texture`,k.bG,this.colorsSampling,this.gG()):this.colorsTexture=MG.PrepareEmptyColorsTexture(A),this._cameraFacing=k.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var ZG,PG,NG;wG.ForceGLSL=!1,function(G){G[G.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",G[G.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(ZG||(ZG={})),function(G){G[G.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",G[G.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",G[G.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(PG||(PG={})),function(G){G[G.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",G[G.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",G[G.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",G[G.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",G[G.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(NG||(NG={}));class qG extends YG.d{constructor(G,A,j){super(G,A,null,null,!1,!1),this.name=G,this._options=j,this._lazy=!1,this._updatable=!1,this._engine=A.getEngine(),this._lazy=j.lazy??!1,this._updatable=j.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=j.colorPointers??[],this._widths=j.widths??new Array(j.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(G){let A=0;for(const u of this._points)A+=u.length;const j=A/3*2-this._widths.length;for(let u=0;u<j;u++)this._widths.push(G)}updateLazy(){var G,A;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(G=this._options.ribbonOptions)||void 0===G?void 0:G.smoothShading),!this.JG&&this.refreshBoundingInfo(),null===(A=this.greasedLineMaterial)||void 0===A||A.updateLazy()}addPoints(G,A){for(const j of G)this._points.push(j);this._lazy||this.setPoints(this._points,A)}dispose(G){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(G,A)}isLazy(){return this._lazy}get MG(){return this._uvs}set MG(G){this._uvs=G instanceof Float32Array?G:new Float32Array(G),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(G){this.material instanceof wG&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===G||void 0===G?void 0:G.length)>0),this._offsets=G,this._offsetsBuffer?this._offsetsBuffer.update(G):this._createOffsetsBuffer(G)}get widths(){return this._widths}set widths(G){this._widths=G,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(G)}get colorPointers(){return this._colorPointers}set colorPointers(G){this._colorPointers=G,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(G)}get greasedLineMaterial(){var G,A;if(this.material&&this.material instanceof wG)return this.material;const j=null===(G=this.material)||void 0===G||null===(A=G.pluginManager)||void 0===A?void 0:A.getPlugin(WG.GREASED_LINE_MATERIAL_NAME);return j||void 0}get points(){const G=[];return pG.c.DeepCopy(this._points,G),G}setPoints(G,A){this._points=MG.ConvertPoints(G,(null===A||void 0===A?void 0:A.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==A&&void 0!==A&&A.colorPointers||this._updateColorPointers(),this._setPoints(this._points,A)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,MG:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(G){super.serialize(G),G.type=this.getClassName(),G.lineOptions=this._createLineOptions()}_createVertexBuffers(){let G=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new JG.d;return A.EG=this._vertexPositions,A.indices=this._indices,A.MG=this._uvs,G&&(A.rG=[],JG.d.ComputeNormals(this._vertexPositions,this._indices,A.rG)),A.WG(this,this._options.updatable),A}_createOffsetsBuffer(G){const A=this._scene.getEngine(),j=new h.e(A,G,this._updatable,3);this.setVerticesBuffer(j.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=j}}class aG{constructor(G,A){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=G,this.wasAddedByNoopNode=A}getIndicesAccessor(G,A,j,u,k){var B,x,s,O;return null===(B=this._indicesAccessorMap.get(G))||void 0===B||null===(x=B.get(A))||void 0===x||null===(s=x.get(j))||void 0===s||null===(O=s.get(u))||void 0===O?void 0:O.get(k)}setIndicesAccessor(G,A,j,u,k,B){let x=this._indicesAccessorMap.get(G);x||(x=new Map,this._indicesAccessorMap.set(G,x));let s=x.get(A);s||(s=new Map,x.set(A,s));let O=s.get(j);O||(O=new Map,s.set(j,O));let d=O.get(u);d||(d=new Map,O.set(u,d)),d.set(k,B)}pushExportedNode(G){this._exportedNodes.has(G)||this._exportedNodes.add(G)}getNodesSet(){return this._exportedNodes}getVertexBufferView(G){return this._vertexBufferViewMap.get(G)}setVertexBufferView(G,A){this._vertexBufferViewMap.set(G,A)}setRemappedBufferView(G,A,j){this._remappedBufferView.set(G,new Map),this._remappedBufferView.get(G).set(A,j)}getRemappedBufferView(G,A){var j;return null===(j=this._remappedBufferView.get(G))||void 0===j?void 0:j.get(A)}getVertexAccessor(G,A,j){var u,k;return null===(u=this._vertexAccessorMap.get(G))||void 0===u||null===(k=u.get(A))||void 0===k?void 0:k.get(j)}setVertexAccessor(G,A,j,u){let k=this._vertexAccessorMap.get(G);k||(k=new Map,this._vertexAccessorMap.set(G,k));let B=k.get(A);B||(B=new Map,k.set(A,B)),B.set(j,u)}hasVertexColorAlpha(G){return this._vertexMapColorAlpha.get(G)||!1}setHasVertexColorAlpha(G,A){return this._vertexMapColorAlpha.set(G,A)}getMesh(G){return this._meshMap.get(G)}setMesh(G,A){this._meshMap.set(G,A)}bindMorphDataToMesh(G,A){const j=this._meshMorphTargetMap.get(G)||[];this._meshMorphTargetMap.set(G,j),-1===j.indexOf(A)&&j.push(A)}getMorphTargetsFromMesh(G){return this._meshMorphTargetMap.get(G)}}class yG{_ApplyExtension(G,A,j,u){if(j>=A.length)return Promise.resolve(G);const k=u(A[j],G);return k?k.then((async G=>G?await this._ApplyExtension(G,A,j+1,u):null)):this._ApplyExtension(G,A,j+1,u)}_ApplyExtensions(G,A){const j=[];for(const u of yG._ExtensionNames)j.push(this._extensions[u]);return this._ApplyExtension(G,j,0,A)}_extensionsPreExportTextureAsync(G,A,j){return this._ApplyExtensions(A,((A,u)=>A.preExportTextureAsync&&A.preExportTextureAsync(G,u,j)))}_extensionsPostExportNodeAsync(G,A,j,u,k){return this._ApplyExtensions(A,((A,B)=>A.postExportNodeAsync&&A.postExportNodeAsync(G,B,j,u,k,this._bufferManager)))}_extensionsPostExportMaterialAsync(G,A,j){return this._ApplyExtensions(A,((A,u)=>A.postExportMaterialAsync&&A.postExportMaterialAsync(G,u,j)))}_extensionsPostExportMaterialAdditionalTextures(G,A,j){const u=[];for(const k of yG._ExtensionNames){const B=this._extensions[k];B.postExportMaterialAdditionalTextures&&u.push(...B.postExportMaterialAdditionalTextures(G,A,j))}return u}_extensionsPostExportTextures(G,A,j){for(const u of yG._ExtensionNames){const k=this._extensions[u];k.postExportTexture&&k.postExportTexture(G,A,j)}}_extensionsPostExportMeshPrimitive(G){for(const A of yG._ExtensionNames){const j=this._extensions[A];j.postExportMeshPrimitive&&j.postExportMeshPrimitive(G,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const G of yG._ExtensionNames){const A=this._extensions[G];A.preGenerateBinaryAsync&&await A.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(G){for(const A of yG._ExtensionNames){const j=this._extensions[A];j.enabled&&G(j)}}_extensionsOnExporting(){this._forEachExtensions((G=>{var A,j,u;G.wasUsed&&((A=this._glTF).extensionsUsed||(A.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(G.name)&&this._glTF.extensionsUsed.push(G.name),G.required&&((j=this._glTF).extensionsRequired||(j.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(G.name)&&this._glTF.extensionsRequired.push(G.name)),(u=this._glTF).extensions||(u.extensions={}),G.onExporting&&G.onExporting())}))}_loadExtensions(){for(const G of yG._ExtensionNames){const A=yG._ExtensionFactories[G](this);this._extensions[G]=A}}constructor(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:S.d.LastCreatedScene,A=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${U.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new l(this),this._extensions={},this._bufferManager=new hG,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!G)throw new Error("No scene available to export");this._babylonScene=G,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:G=>{var A;return null===G||void 0===G||null===(A=G.ss)||void 0===A?void 0:A.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...A},this._loadExtensions()}dispose(){for(const G in this._extensions){this._extensions[G].dispose()}}get options(){return this._options}static RegisterExtension(G,A){yG.UnregisterExtension(G)&&k.Tools.Warn(`Extension with the name ${G} already exists`),yG._ExtensionFactories[G]=A,yG._ExtensionNames.push(G)}static UnregisterExtension(G){if(!yG._ExtensionFactories[G])return!1;delete yG._ExtensionFactories[G];const A=yG._ExtensionNames.indexOf(G);return-1!==A&&yG._ExtensionNames.splice(A,1),!0}_generateJSON(G,A,j){const u={byteLength:G};return u.byteLength&&(this._glTF.buffers=[u]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.tA=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(u.uri=A+".bin"),j?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(G){const A=await this._generateBinaryAsync();this._extensionsOnExporting();const j=this._generateJSON(A.byteLength,G,!0),u=new Blob([A],{type:"application/octet-stream"}),k=G+".gltf",B=G+".bin",x=new d;if(x.files[k]=j,x.files[B]=u,this._imageData)for(const s in this._imageData)x.files[s]=new Blob([this._imageData[s].data],{type:this._imageData[s].mimeType});return x}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(G){const A=G%4;return 0===A?A:4-A}async generateGLBAsync(G){this._shouldUseGlb=!0;const A=await this._generateBinaryAsync();this._extensionsOnExporting();const j=this._generateJSON(A.byteLength),u=G+".glb";let k,B=j.length;if("undefined"!==typeof TextEncoder){k=(new TextEncoder).encode(j),B=k.length}const x=this._getPadding(B),s=this._getPadding(A.byteLength),O=28+B+x+A.byteLength+s,h=new OG(O);if(h.writeUInt32(1179937895),h.writeUInt32(2),h.writeUInt32(O),h.writeUInt32(B+x),h.writeUInt32(1313821514),k)h.writeTypedArray(k);else{const G="_".charCodeAt(0);for(let A=0;A<B;++A){const u=j.charCodeAt(A);u!=j.codePointAt(A)?h.writeUInt8(G):h.writeUInt8(u)}}for(let d=0;d<x;++d)h.writeUInt8(32);h.writeUInt32(A.byteLength+s),h.writeUInt32(5130562),h.writeTypedArray(A);for(let d=0;d<s;++d)h.writeUInt8(0);const H=new d;return H.files[u]=new Blob([h.getOutputData()],{type:"application/octet-stream"}),H}_setNodeTransformation(G,A,j){if(A.getPivotPoint().equalsWithEpsilon(q,N.d)||k.Tools.Warn("Pivot points are not supported in the glTF serializer"),!A.position.equalsWithEpsilon(q,N.d)){const k=u.TmpVectors.SA[0].B(A.position);j&&K(k),G.translation=k.hs()}A.ns.equalsWithEpsilon(y,N.d)||(G.scale=A.ns.hs());const B=A.rotationQuaternion||u.Quaternion.FromEulerAngles(A.rotation.x,A.rotation.y,A.rotation.z);B.equalsWithEpsilon(a,N.d)||(j&&T(B),G.rotation=B.normalize().hs())}_setCameraTransformation(G,A,j){if(!A.position.equalsWithEpsilon(q,N.d)){const k=u.TmpVectors.SA[0].B(A.position);j&&K(k),G.translation=k.hs()}const k=A.rotationQuaternion||u.Quaternion.FromEulerAngles(A.rotation.x,A.rotation.y,A.rotation.z);j&&T(k),this._babylonScene.useRightHandedSystem||m(k),k.equalsWithEpsilon(a,N.d)||(G.rotation=k.hs())}_listAvailableCameras(){for(const G of this._babylonScene.cameras){const A={type:G.mode===FG.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(G.name&&(A.name=G.name),"perspective"===A.type)A.perspective={aspectRatio:G.getEngine().getAspectRatio(G),yfov:G.fovMode===FG.d.FOVMODE_VERTICAL_FIXED?G.fov:G.fov*G.getEngine().getAspectRatio(G),znear:G.Fs,zfar:G.maxZ};else if("orthographic"===A.type){const j=G.orthoLeft&&G.orthoRight?.5*(G.orthoRight-G.orthoLeft):.5*G.getEngine().getRenderWidth(),u=G.orthoBottom&&G.orthoTop?.5*(G.orthoTop-G.orthoBottom):.5*G.getEngine().getRenderHeight();A.orthographic={xmag:j,ymag:u,znear:G.Fs,zfar:G.maxZ}}this._camerasMap.set(G,A)}}_exportAndAssignCameras(){const G=Array.from(this._camerasMap.values());for(const A of G){const G=this._nodesCameraMap.get(A);if(void 0!==G){this._cameras.push(A);for(const A of G)A.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const G of this._babylonScene.skeletons){if(G.bones.length<=0)continue;const A={joints:[]};this._skinMap.set(G,A)}}_exportAndAssignSkeletons(){for(const G of this._babylonScene.skeletons){if(G.bones.length<=0)continue;const A=this._skinMap.get(G);if(void 0==A)continue;const j={},u=[];let B=-1;for(let k=0;k<G.bones.length;++k){const A=G.bones[k],u=A.getIndex()??k;-1!==u&&(j[u]=A,u>B&&(B=u))}for(let G=0;G<=B;++G){const B=j[G];u.push(B.getAbsoluteInverseBindMatrix());const x=B.getTransformNode();if(null!==x){const G=this._nodeMap.get(x);x&&null!==G&&void 0!==G?A.joints.push(G):k.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else k.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const x=this._nodesSkinMap.get(A);if(A.joints.length>0&&void 0!==x){const G=64*u.length,j=new Float32Array(G/4);u.forEach(((G,A)=>{j.set(G.m,16*A)}));const k=this._bufferManager.createBufferView(j);this._accessors.push(this._bufferManager.createAccessor(k,"MAT4",5126,u.length)),A.inverseBindMatrices=this._accessors.length-1,this._skins.push(A);for(const A of x)A.skin=this._skins.length-1}}}async _exportSceneAsync(){const G={nodes:[]};if(this._babylonScene.metadata){const A=this._options.metadataSelector(this._babylonScene.metadata);A&&(G.extras=A)}const A=new Array,j=new Array,u=new Array;for(const s of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&xG(s,this._babylonScene.useRightHandedSystem)?u.push(...s.getChildren()):this._babylonScene.useRightHandedSystem?A.push(s):j.push(s);this._listAvailableCameras(),this._listAvailableSkeletons();const k=new aG(!0,!1);G.nodes.push(...await this._exportNodesAsync(j,k));const B=new aG(!1,!1);G.nodes.push(...await this._exportNodesAsync(A,B));const x=new aG(!1,!0);G.nodes.push(...await this._exportNodesAsync(u,x)),G.nodes.length&&this._scenes.push(G),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&QG._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,k.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(G){let A=this._shouldExportNodeMap.get(G);return void 0===A&&(A=this._options.shouldExportNode(G),this._shouldExportNodeMap.set(G,A)),A}async _exportNodesAsync(G,A){const j=new Array;this._exportBuffers(G,A);for(const u of G)await this._exportNodeAsync(u,j,A);return j}_collectBuffers(G,A,j,u,k){if(this._shouldExportNode(G)&&G instanceof F.b&&G.Ss){const B=G.Ss.getVertexBuffers();if(B)for(const u in B){if(!i(u))continue;const x=B[u];k.setHasVertexColorAlpha(x,G.hasVertexAlpha);const s=x._buffer,O=A.get(s)||[];A.set(s,O),-1===O.indexOf(x)&&O.push(x);const d=j.get(x)||[];j.set(x,d),-1===d.indexOf(G)&&d.push(G)}const x=G.morphTargetManager;if(x)for(let A=0;A<x.numTargets;A++){const j=x.getTarget(A),k=u.get(j)||[];u.set(j,k),-1===k.indexOf(G)&&k.push(G)}}for(const B of G.getChildren())this._collectBuffers(B,A,j,u,k)}_exportBuffers(G,A){const j=new Map,u=new Map,k=new Map;for(const s of G)this._collectBuffers(s,j,u,k,A);const B=Array.from(j.keys());for(const s of B){const G=s.getData();if(!G)throw new Error("Buffer data is not available");const k=j.get(s);if(!k)continue;const B=k[0].byteStride;if(k.some((G=>G.byteStride!==B)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const x=jG(G).slice();for(const A of k){const G=u.get(A),{byteOffset:j,byteStride:k,componentCount:B,type:s,count:O,normalized:d,kind:H}=f(A,G);switch(H){case h.h.NormalKind:case h.h.TangentKind:(0,w.j)(x,j,k,B,s,O,d,(G=>{const A=Math.sqrt(G[0]*G[0]+G[1]*G[1]+G[2]*G[2]);if(A>0){const j=1/A;G[0]*=j,G[1]*=j,G[2]*=j}}));break;case h.h.ColorKind:{const A=G.filter((G=>G.material instanceof SG.YA||null==G.material)).length;if(0==A)break;if(A!=G.length){Z.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}s==h.h.UNSIGNED_BYTE&&Z.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const u=new C.nA,H=new C.Xs,F=this._babylonScene.getEngine().useExactSrgbConversions;(0,w.j)(x,j,k,B,s,O,d,(G=>{3===G.length?(u.Uj(G,0),u.toLinearSpaceToRef(u,F),u.toArray(G,0)):(H.Uj(G,0),H.toLinearSpaceToRef(H,F),H.toArray(G,0))}))}}}if(A.convertToRightHanded){for(const G of k){const A=u.get(G),{byteOffset:j,byteStride:k,componentCount:B,type:s,count:O,normalized:d,kind:H}=f(G,A);switch(H){case h.h.PositionKind:case h.h.NormalKind:case h.h.TangentKind:(0,w.j)(x,j,k,B,s,O,d,(G=>{G[0]=-G[0]}))}}A.convertedToRightHandedBuffers.set(s,x)}const O=this._bufferManager.createBufferView(x,B);A.setVertexBufferView(s,O);const d=new Map;for(const A of k){const G=u.get(A),{kind:j,totalVertices:k}=f(A,G);switch(j){case h.h.MatricesIndicesKind:case h.h.MatricesIndicesExtraKind:if(A.type==h.h.FLOAT){const G=A.getFloatData(k);null!==G&&d.set(A,G)}}}0!==d.size&&Z.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const H=Array.from(d.keys());for(const j of H){const G=d.get(j);if(!G)continue;const u=G.some((G=>G>=256)),k=new(u?Uint16Array:Uint8Array)(G.length);for(let A=0;A<G.length;A++)k[A]=G[A];const B=this._bufferManager.createBufferView(k,4*(u?2:1));A.setRemappedBufferView(s,j,B)}}const x=Array.from(k.keys());for(const s of x){const G=k.get(s);if(!G)continue;const j=XG(s,G[0],this._bufferManager,this._bufferViews,this._accessors,A.convertToRightHanded);for(const u of G)A.bindMorphDataToMesh(u,j)}}async _exportNodeAsync(G,A,j){let u=this._nodeMap.get(G);if(void 0!==u)return void(A.includes(u)||A.push(u));const k=await this._createNodeAsync(G,j);if(k){u=this._nodes.length,this._nodes.push(k),this._nodeMap.set(G,u),j.pushExportedNode(G),A.push(u);const B={name:"runtime animations",channels:[],samplers:[]},x=[];this._babylonScene.animationGroups.length||(QG._CreateMorphTargetAnimationFromMorphTargetAnimations(G,B,x,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,j.convertToRightHanded,this._options.shouldExportAnimation),G.animations.length&&QG._CreateNodeAnimationFromNodeAnimations(G,B,x,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,j.convertToRightHanded,this._options.shouldExportAnimation)),B.channels.length&&B.samplers.length&&this._animations.push(B),x.forEach((G=>{G.channels.length&&G.samplers.length&&this._animations.push(G)}))}const B=k?[]:A;for(const x of G.getChildren())await this._exportNodeAsync(x,B,j);k&&B.length&&(k.children=B)}async _createNodeAsync(G,A){if(!this._shouldExportNode(G))return null;const j={};if(G.name&&(j.name=G.name),G.metadata){const A=this._options.metadataSelector(G.metadata);A&&(j.extras=A)}if(G instanceof H.c&&(this._setNodeTransformation(j,G,A.convertToRightHanded),G instanceof F.b)){const k=G instanceof R.b?G.sourceMesh:G;if(k.ds&&k.ds.length>0&&(j.mesh=await this._exportMeshAsync(k,A)),G.skeleton){const A=this._skinMap.get(G.skeleton);var u;if(void 0!==A)void 0===this._nodesSkinMap.get(A)&&this._nodesSkinMap.set(A,[]),null===(u=this._nodesSkinMap.get(A))||void 0===u||u.push(j)}}if(G instanceof P.d){const u=this._camerasMap.get(G);if(u){var k;void 0===this._nodesCameraMap.get(u)&&this._nodesCameraMap.set(u,[]),this._setCameraTransformation(j,G,A.convertToRightHanded);const x=G.parent;if(null!==x&&AG(G,x)){const G=this._nodeMap.get(x);if(void 0!==G){var B;const A=this._nodes[G];return GG(j,A),null===(B=this._nodesCameraMap.get(u))||void 0===B||B.push(A),null}}null===(k=this._nodesCameraMap.get(u))||void 0===k||k.push(j)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",j,G,this._nodeMap,A.convertToRightHanded)?j:(Z.e.Warn(`Not exporting node ${G.name}`),null)}_exportIndices(G,A,j,u,k,x,s,O,d){let h=G;d.mode=L(x);const H=s!==B.b.CounterClockWiseSideOrientation,F=!O.wasAddedByNoopNode&&H,R=function(G){switch(G){case B.b.TriangleFillMode:case B.b.TriangleStripDrawMode:case B.b.TriangleFanDrawMode:return!0}return!1}(x)&&F;if(R){if(x===B.b.TriangleStripDrawMode||x===B.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");d.mode=L(x);const s=A?new Uint32Array(u):new Uint16Array(u);if(G)for(let A=0;A+2<u;A+=3)s[A]=G[j+A]+k,s[A+1]=G[j+A+2]+k,s[A+2]=G[j+A+1]+k;else for(let G=0;G+2<u;G+=3)s[G]=G,s[G+1]=G+2,s[G+2]=G+1;h=s}else if(G&&0!==k){const B=A?new Uint32Array(u):new Uint16Array(u);for(let A=0;A<u;A++)B[A]=G[j+A]+k;h=B}if(h){let B=O.getIndicesAccessor(G,j,u,k,R);if(void 0===B){const x=function(G,A,j,u){if(G instanceof Uint16Array||G instanceof Uint32Array)return G;if(G instanceof Int32Array)return new Uint32Array(G.buffer,G.byteOffset,G.length);const k=G.slice(A,A+j);return u?new Uint32Array(k):new Uint16Array(k)}(h,0,u,A),s=this._bufferManager.createBufferView(x),d=A?5125:5123;this._accessors.push(this._bufferManager.createAccessor(s,"SCALAR",d,u,0)),B=this._accessors.length-1,O.setIndicesAccessor(G,j,u,k,R,B)}d.indices=B}}_exportVertexBuffer(G,A,j,u,k,B){const x=G.getKind();if(!i(x))return;if(x.startsWith("uv")&&!this._options.exportUnusedUVs&&(!A||!this._materialNeedsUVsSet.has(A)))return;let s=k.getVertexAccessor(G,j,u);if(void 0===s){const A=k.convertedToRightHandedBuffers.get(G._buffer)||G._buffer.getData(),B=x===h.h.PositionKind?function(G,A,j,u){const{byteOffset:k,byteStride:B,type:x,normalized:s}=A,O=A.getSize(),d=new Array(O).fill(1/0),h=new Array(O).fill(-1/0);return(0,w.j)(G,k+j*B,B,O,x,u*O,s,(G=>{for(let A=0;A<O;A++)d[A]=Math.min(d[A],G[A]),h[A]=Math.max(h[A],G[A])})),{min:d,max:h}}(A,G,j,u):void 0,O=(x===h.h.MatricesIndicesKind||x===h.h.MatricesIndicesExtraKind)&&G.type===h.h.FLOAT,d=O?h.h.UNSIGNED_BYTE:G.type,H=O?void 0:G.normalized,F=O?k.getRemappedBufferView(G._buffer,G):k.getVertexBufferView(G._buffer),R=G.byteOffset+j*G.byteStride;this._accessors.push(this._bufferManager.createAccessor(F,function(G,A){if(G==h.h.ColorKind)return A?"VEC4":"VEC3";switch(G){case h.h.PositionKind:case h.h.NormalKind:return"VEC3";case h.h.TangentKind:case h.h.MatricesIndicesKind:case h.h.MatricesIndicesExtraKind:case h.h.MatricesWeightsKind:case h.h.MatricesWeightsExtraKind:return"VEC4";case h.h.UVKind:case h.h.UV2Kind:case h.h.UV3Kind:case h.h.UV4Kind:case h.h.UV5Kind:case h.h.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${G}`)}(x,k.hasVertexColorAlpha(G)),d,u,R,B,H)),s=this._accessors.length-1,k.setVertexAccessor(G,j,u,s)}B.attributes[function(G){switch(G){case h.h.PositionKind:return"POSITION";case h.h.NormalKind:return"NORMAL";case h.h.TangentKind:return"TANGENT";case h.h.ColorKind:return"COLOR_0";case h.h.UVKind:return"TEXCOORD_0";case h.h.UV2Kind:return"TEXCOORD_1";case h.h.UV3Kind:return"TEXCOORD_2";case h.h.UV4Kind:return"TEXCOORD_3";case h.h.UV5Kind:return"TEXCOORD_4";case h.h.UV6Kind:return"TEXCOORD_5";case h.h.MatricesIndicesKind:return"JOINTS_0";case h.h.MatricesIndicesExtraKind:return"JOINTS_1";case h.h.MatricesWeightsKind:return"WEIGHTS_0";case h.h.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${G}`)}(x)]=s}async _exportMaterialAsync(G,A,j,u){let k=this._materialMap.get(G);if(void 0===k){const u=A&&Object.keys(A).some((G=>G.startsWith("uv")));if((G=G instanceof RG.d?G.Is[j.materialIndex]:G)instanceof UG.c)k=await this._materialExporter.exportPBRMaterialAsync(G,"image/png",u);else{if(!(G instanceof SG.YA))return void Z.e.Warn(`Unsupported material '${G.name}' with type ${G.getClassName()}`);k=await this._materialExporter.exportStandardMaterialAsync(G,"image/png",u)}this._materialMap.set(G,k)}u.material=k}async _exportMeshAsync(G,A){var j;let u=A.getMesh(G);if(void 0!==u)return u;const k={primitives:[]};u=this._meshes.length,this._meshes.push(k),A.setMesh(G,u);const x=G.isUnIndexed?null:G.Cs(),s=null===(j=G.Ss)||void 0===j?void 0:j.getVertexBuffers(),O=A.getMorphTargetsFromMesh(G),d=G instanceof IG.c,h=G instanceof qG,H=G.ds;if(s&&H&&H.length>0)for(const U of H){const j={attributes:{}},u=U.wG()||this._babylonScene.defaultMaterial;if(h){var F,R;const A={name:u.name},k=G,B=C.nA.White(),x=(null===(F=k.material)||void 0===F?void 0:F.alpha)??1,s=(null===(R=k.greasedLineMaterial)||void 0===R?void 0:R.color)??B;(!s.equalsWithEpsilon(B,N.d)||x<1)&&(A.pbrMetallicRoughness={baseColorFactor:[...s.hs(),x]}),this._materials.push(A),j.material=this._materials.length-1}else if(d){const A={name:u.name},k=G;(!k.color.equalsWithEpsilon(C.nA.White(),N.d)||k.alpha<1)&&(A.pbrMetallicRoughness={baseColorFactor:[...k.color.hs(),k.alpha]}),this._materials.push(A),j.material=this._materials.length-1}else await this._exportMaterialAsync(u,s,U,j);const H=d||h?B.b.LineListDrawMode:G.overrideRenderingFillMode??u.fillMode,S=u._getEffectiveOrientation(G);this._exportIndices(x,x?(0,w.d)(x,U.indexCount,U.indexStart,U.verticesStart):U.verticesCount>65535,x?U.indexStart:U.verticesStart,x?U.indexCount:U.verticesCount,-U.verticesStart,H,S,A,j);for(const G of Object.values(s))this._exportVertexBuffer(G,u,U.verticesStart,U.verticesCount,A,j);if(O){j.targets=[];for(const G of O)j.targets.push(G.attributes)}k.primitives.push(j),this._extensionsPostExportMeshPrimitive(j)}if(O){k.weights=[],k.extras||(k.extras={}),k.extras.targetNames=[];for(const G of O)k.weights.push(G.influence),k.extras.targetNames.push(G.name)}return u}}yG._ExtensionNames=new Array,yG._ExtensionFactories={};class zG{static async GLTFAsync(G,A,j){j&&j.exportWithoutWaitingForScene||await G.whenReadyAsync();const u=new yG(G,j),k=await u.generateGLTFAsync(A.replace(/\.[^/.]+$/,""));return u.dispose(),k}static async GLBAsync(G,A,j){j&&j.exportWithoutWaitingForScene||await G.whenReadyAsync();const u=new yG(G,j),k=await u.generateGLBAsync(A.replace(/\.[^/.]+$/,""));return u.dispose(),k}}j(11740);const fG="EXT_mesh_gpu_instancing";class vG{constructor(G){this.name=fG,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(G,A,j,k,B,x){return await new Promise((G=>{if(A&&j instanceof YG.d&&j.hasThinInstances&&this._exporter){this._wasUsed=!0;const G=u.SA.Zero(),k=u.Quaternion.Identity(),s=u.SA.One(),O=j.thinInstanceGetWorldMatrices(),d=u.TmpVectors.SA[2],h=u.TmpVectors.Quaternion[1],H=u.TmpVectors.SA[3];let F=!1,R=!1,U=!1;const S=new Float32Array(3*j.Ds),C=new Float32Array(4*j.Ds),t=new Float32Array(3*j.Ds);let Y=0;for(const A of O)A.decompose(H,h,d),B&&(K(d),T(h)),S.set(d.hs(),3*Y),C.set(h.normalize().hs(),4*Y),t.set(H.hs(),3*Y),F=F||!d.equalsWithEpsilon(G),R=R||!h.equalsWithEpsilon(k),U=U||!H.equalsWithEpsilon(s),Y++;const n={attributes:{}};F&&(n.attributes.TRANSLATION=this._buildAccessor(S,"VEC3",j.Ds,x)),R&&(n.attributes.ROTATION=this._buildAccessor(C,"VEC4",j.Ds,x)),U&&(n.attributes.SCALE=this._buildAccessor(t,"VEC3",j.Ds,x)),A.extensions=A.extensions||{},A.extensions[fG]=n}G(A)}))}_buildAccessor(G,A,j,u){const k=u.createBufferView(G),B=u.createAccessor(k,A,5126,j);return this._exporter._accessors.push(B),this._exporter._accessors.length-1}}yG.RegisterExtension(fG,(G=>new vG(G)));var iG=j(11746),LG=j(11752),VG=j(11756),KG=j(11765);function TG(G){return G===VG.c.PositionKind?"POSITION":G===VG.c.NormalKind?"NORMAL":G===VG.c.ColorKind?"COLOR":G.startsWith(VG.c.UVKind)?"TEX_COORD":"GENERIC"}const mG={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class GA extends iG.b{static get DefaultAvailable(){return(0,iG.g)(GA.DefaultConfiguration)}static get Default(){return GA._Default??(GA._Default=new GA),GA._Default}static ResetDefault(G){GA._Default&&(G||GA._Default.dispose(),GA._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(G,A){return{module:await(A||DracoEncoderModule)({wasmBinary:G})}}_getWorkerContent(){return`${LG.g}(${LG.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:GA.DefaultConfiguration)}async _encodeAsync(G,A,j){const u=j?(0,KG.d)(mG,j):mG;if(this._workerPoolPromise){const j=await this._workerPoolPromise;return await new Promise(((k,B)=>{j.push(((j,x)=>{const s=G=>{j.removeEventListener("error",s),j.removeEventListener("message",O),B(G),x()},O=G=>{"encodeMeshDone"===G.data.id&&(j.removeEventListener("error",s),j.removeEventListener("message",O),k(G.data.encodedMeshData),x())};j.addEventListener("error",s),j.addEventListener("message",O);const d=[];for(const A of G)d.push(A.data.buffer);A&&d.push(A.buffer),j.postMessage({id:"encodeMesh",attributes:G,indices:A,options:u},d)}))}))}if(this._modulePromise){const j=await this._modulePromise;return(0,LG.g)(j.module,G,A,u)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(G,A){if(0==G.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");G instanceof YG.d&&G.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===A||void 0===A?void 0:A.method)&&(Z.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),A.method="MESH_SEQUENTIAL_ENCODING");const j=function(G){let A=G.Cs(void 0,!0);return!A||A instanceof Uint32Array||A instanceof Uint16Array||(A=((0,w.d)(A,A.length)?Uint32Array:Uint16Array).from(A)),A}(G),u=function(G,A){const j=[];for(const u of G.getVerticesDataKinds()){if(null!==A&&void 0!==A&&A.includes(u)){if(u===VG.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const k=G.getVertexBuffer(u),B=k.getSize(),x=(0,w.t)(k.getData(),B,k.type,k.byteOffset,k.byteStride,k.normalized,G.getTotalVertices(),!0);j.push({kind:u,dracoName:TG(u),size:B,data:x})}return j}(G,null===A||void 0===A?void 0:A.excludedAttributes);return await this._encodeAsync(u,j,A)}}GA.DefaultConfiguration={wasmUrl:`${k.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${k.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${k.Tools._DefaultCdnUrl}/draco_encoder.js`},GA._Default=null;const AA="KHR_draco_mesh_compression";class jA{get wasUsed(){return this._wasUsed}constructor(G){this.name=AA,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===G.options.meshCompressionMethod&&GA.DefaultAvailable}dispose(){}postExportMeshPrimitive(G,A,j){if(!this.enabled)return;if(4!==G.mode&&5!==G.mode)return void Z.e.Warn("Cannot compress primitive with mode "+G.mode+".");const u=[],k=[];let B=null;if(void 0!==G.indices){const x=j[G.indices],s=A.getBufferView(x);B=A.getData(s).slice(),u.push(s),k.push(x)}const x=[];for(const[h,H]of Object.entries(G.attributes)){const G=j[H],B=A.getBufferView(G),O=v(G.type),d=(0,w.t)(A.getData(B),O,G.componentType,G.byteOffset||0,B.byteStride||(0,w.p)(G.componentType)*O,G.normalized||!1,G.count,!0);x.push({kind:h,dracoName:(s=h,"POSITION"===s?"POSITION":"NORMAL"===s?"NORMAL":s.startsWith("COLOR")?"COLOR":s.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:v(G.type),data:d}),u.push(B),k.push(G)}var s;const O={method:G.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},d=GA.Default._encodeAsync(x,B,O).then((j=>{if(!j)return void Z.e.Error("Draco encoding failed for primitive.");const B={bufferView:-1,attributes:j.attributeIds},x=A.createBufferView(j.data);A.setBufferView(B,x);for(const G of u)this._bufferViewsUsed.add(G);for(const G of k)this._accessorsUsed.add(G);G.extensions||(G.extensions={}),G.extensions[AA]=B})).catch((G=>{Z.e.Error("Draco encoding failed for primitive: "+G)}));this._encodePromises.push(d),this._wasUsed=!0}async preGenerateBinaryAsync(G){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((A=>{G.getPropertiesWithBufferView(A).every((G=>this._accessorsUsed.has(G)))&&G.removeBufferView(A)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}yG.RegisterExtension(AA,(G=>new jA(G)));var uA=j(11774);const kA="KHR_lights_punctual",BA={name:"",color:[1,1,1],gs:1,range:Number.MAX_VALUE},xA={innerConeAngle:0,outerConeAngle:Math.PI/4},sA=u.SA.Backward();class OA{constructor(G){this.name=kA,this.enabled=!0,this.required=!1,this._exporter=G}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[kA]=this._lights}async postExportNodeAsync(G,A,j,k,B){return await new Promise((x=>{if(!(j instanceof nG.b))return void x(A);const s=j.getTypeID()==nG.b.LIGHTTYPEID_POINTLIGHT?"point":j.getTypeID()==nG.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":j.getTypeID()==nG.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!s||!(j instanceof uA.d))return Z.e.Warn(`${G}: Light ${j.name} is not supported in ${kA}`),void x(A);if(j.falloffType!==nG.b.FALLOFF_GLTF&&Z.e.Warn(`${G}: Light falloff for ${j.name} does not match the ${kA} specification!`),!j.position.equalsToFloats(0,0,0)){const G=u.TmpVectors.SA[0].B(j.position);B&&K(G),A.translation=G.hs()}if("point"!==s){const G=j.direction.normalizeToRef(u.TmpVectors.SA[0]);B&&K(G);const k=u.Quaternion.FromUnitVectorsToRef(sA,G,u.TmpVectors.Quaternion[0]);u.Quaternion.IsIdentity(k)||(A.rotation=k.hs())}const O={type:s,name:j.name,color:j.cs.hs(),gs:j.gs,range:j.range};if(uG(O,BA),"spot"===s){const G=j;O.spot={innerConeAngle:G.innerAngle/2,outerConeAngle:G.angle/2},uG(O.spot,xA)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(O);const d={Gs:this._lights.lights.length-1},h=j.parent;if(h&&AG(j,h)){const G=k.get(h);if(G){const j=this._exporter._nodes[G];return GG(A,j),j.extensions||(j.extensions={}),j.extensions[kA]=d,void x(null)}}A.extensions||(A.extensions={}),A.extensions[kA]=d,x(A)}))}}yG.RegisterExtension(kA,(G=>new OA(G)));var dA=j(11696);const hA="KHR_materials_anisotropy";class HA{constructor(G){this.name=hA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,A,j){const u=[];return j instanceof dA.e&&j.anisotropy.isEnabled&&!j.anisotropy.legacy?(j.anisotropy.texture&&u.push(j.anisotropy.texture),u):[]}postExportMaterialAsync(G,A,j){return new Promise((G=>{if(j instanceof dA.e){if(!j.anisotropy.isEnabled||j.anisotropy.legacy)return void G(A);this._wasUsed=!0,A.extensions=A.extensions||{};const u=this._exporter._materialExporter.getTextureInfo(j.anisotropy.texture),k={anisotropyStrength:j.anisotropy.gs,anisotropyRotation:j.anisotropy.angle,anisotropyTexture:u??void 0};null!==k.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(j),A.extensions[hA]=k}G(A)}))}}yG.RegisterExtension(hA,(G=>new HA(G)));const FA="KHR_materials_clearcoat";class RA{constructor(G){this.name=FA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,A,j){const u=[];return j instanceof dA.e&&j.clearCoat.isEnabled?(j.clearCoat.texture&&u.push(j.clearCoat.texture),!j.clearCoat.useRoughnessFromMainTexture&&j.clearCoat.textureRoughness&&u.push(j.clearCoat.textureRoughness),j.clearCoat.bumpTexture&&u.push(j.clearCoat.bumpTexture),u):[]}postExportMaterialAsync(G,A,j){return new Promise((G=>{if(j instanceof dA.e){if(!j.clearCoat.isEnabled)return void G(A);this._wasUsed=!0,A.extensions=A.extensions||{};const u=this._exporter._materialExporter.getTextureInfo(j.clearCoat.texture);let B;B=j.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(j.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(j.clearCoat.textureRoughness),j.clearCoat.isTintEnabled&&k.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${j.name}`),j.clearCoat.remapF0OnInterfaceChange&&k.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${j.name}`);const x=this._exporter._materialExporter.getTextureInfo(j.clearCoat.bumpTexture),s={clearcoatFactor:j.clearCoat.gs,clearcoatTexture:u??void 0,clearcoatRoughnessFactor:j.clearCoat.roughness,clearcoatRoughnessTexture:B??void 0,clearcoatNormalTexture:x??void 0};null===s.clearcoatTexture&&null===s.clearcoatRoughnessTexture&&null===s.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(j),A.extensions[FA]=s}G(A)}))}}yG.RegisterExtension(FA,(G=>new RA(G)));const UA="KHR_materials_diffuse_transmission";function SA(G,A){const j=A.subSurface;let u=null;return j.translucencyIntensityTexture?u=j.translucencyIntensityTexture:j.thicknessTexture&&j.useMaskFromThicknessTexture&&(u=j.thicknessTexture),u&&!j.useGltfStyleTextures?(Z.e.Warn(`${G}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${A.name}`,1),null):u}class CA{constructor(G){this.name=UA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,A,j){const u=[];if(j instanceof UG.c&&this._isExtensionEnabled(j)){const A=SA(G,j);return A&&u.push(A),j.subSurface.translucencyColorTexture&&u.push(j.subSurface.translucencyColorTexture),u}return u}_isExtensionEnabled(G){if(G.unlit)return!1;const A=G.subSurface;return!!A.isTranslucencyEnabled&&(!G.unlit&&!A.useAlbedoToTintTranslucency&&A.useGltfStyleTextures&&1===A.volumeIndexOfRefraction&&0===A.minimumThickness&&0===A.maximumThickness)}postExportMaterialAsync(G,A,j){return new Promise((u=>{if(j instanceof UG.c&&this._isExtensionEnabled(j)){this._wasUsed=!0;const u=j.subSurface,k=SA(G,j),B=0==u.translucencyIntensity?void 0:u.translucencyIntensity,x=this._exporter._materialExporter.getTextureInfo(k)??void 0,s=!u.translucencyColor||u.translucencyColor.equalsFloats(1,1,1)?void 0:u.translucencyColor.hs(),O=this._exporter._materialExporter.getTextureInfo(u.translucencyColorTexture)??void 0,d={diffuseTransmissionFactor:B,diffuseTransmissionTexture:x,diffuseTransmissionColorFactor:s,diffuseTransmissionColorTexture:O};(x||O)&&this._exporter._materialNeedsUVsSet.add(j),A.extensions=A.extensions||{},A.extensions[UA]=d}u(A)}))}}yG.RegisterExtension(UA,(G=>new CA(G)));const tA="KHR_materials_dispersion";class YA{constructor(){this.name=tA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(G){if(G.unlit)return!1;const A=G.subSurface;return!(!A.isRefractionEnabled&&!A.isDispersionEnabled)}postExportMaterialAsync(G,A,j){return new Promise((G=>{if(j instanceof UG.c&&this._isExtensionEnabled(j)){this._wasUsed=!0;const G={dispersion:j.subSurface.dispersion};A.extensions=A.extensions||{},A.extensions[tA]=G}G(A)}))}}yG.RegisterExtension(tA,(()=>new YA));const nA="KHR_materials_emissive_strength";class QA{constructor(){this.name=nA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(G,A,j){return await new Promise((G=>{if(!(j instanceof UG.c))return G(A);const u=j.emissiveColor.hs(),k=Math.max(...u);if(k>1){this._wasUsed=!0,A.extensions||(A.extensions={});const G={emissiveStrength:k},u=j.emissiveColor.scale(1/G.emissiveStrength);A.emissiveFactor=u.hs(),A.extensions[nA]=G}return G(A)}))}}yG.RegisterExtension(nA,(G=>new QA));const XA="KHR_materials_ior";class IA{constructor(){this.name=XA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(G){return!G.unlit&&(void 0!=G.indexOfRefraction&&1.5!=G.indexOfRefraction)}postExportMaterialAsync(G,A,j){return new Promise((G=>{if(j instanceof UG.c&&this._isExtensionEnabled(j)){this._wasUsed=!0;const G={ior:j.indexOfRefraction};A.extensions=A.extensions||{},A.extensions[XA]=G}G(A)}))}}yG.RegisterExtension(XA,(G=>new IA));const DA="KHR_materials_iridescence";class gA{constructor(G){this.name=DA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,A,j){const u=[];return j instanceof dA.e&&j.iridescence.isEnabled?(j.iridescence.texture&&u.push(j.iridescence.texture),j.iridescence.thicknessTexture&&j.iridescence.thicknessTexture!==j.iridescence.texture&&u.push(j.iridescence.thicknessTexture),u):[]}postExportMaterialAsync(G,A,j){return new Promise((G=>{if(j instanceof dA.e){if(!j.iridescence.isEnabled)return void G(A);this._wasUsed=!0,A.extensions=A.extensions||{};const u=this._exporter._materialExporter.getTextureInfo(j.iridescence.texture),k=this._exporter._materialExporter.getTextureInfo(j.iridescence.thicknessTexture),B={iridescenceFactor:j.iridescence.gs,iridescenceIor:j.iridescence.indexOfRefraction,iridescenceThicknessMinimum:j.iridescence.minimumThickness,iridescenceThicknessMaximum:j.iridescence.maximumThickness,iridescenceTexture:u??void 0,iridescenceThicknessTexture:k??void 0};null===B.iridescenceTexture&&null===B.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(j),A.extensions[DA]=B}G(A)}))}}yG.RegisterExtension(DA,(G=>new gA(G)));const cA="KHR_materials_sheen";class EA{constructor(G){this.name=cA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,A,j){return j instanceof UG.c&&j.sheen.isEnabled&&j.sheen.texture?[j.sheen.texture]:[]}async postExportMaterialAsync(G,A,j){return await new Promise((G=>{if(j instanceof UG.c){if(!j.sheen.isEnabled)return void G(A);this._wasUsed=!0,null==A.extensions&&(A.extensions={});const u={sheenColorFactor:j.sheen.color.hs(),sheenRoughnessFactor:j.sheen.roughness??0};null===u.sheenColorTexture&&null===u.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(j),j.sheen.texture&&(u.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(j.sheen.texture)??void 0),j.sheen.textureRoughness&&!j.sheen.useRoughnessFromMainTexture?u.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(j.sheen.textureRoughness)??void 0:j.sheen.texture&&j.sheen.useRoughnessFromMainTexture&&(u.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(j.sheen.texture)??void 0),A.extensions[cA]=u}G(A)}))}}yG.RegisterExtension(cA,(G=>new EA(G)));const rA="KHR_materials_specular";class bA{constructor(G){this.name=rA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,A,j){const u=[];return j instanceof UG.c&&this._isExtensionEnabled(j)?(j.metallicReflectanceTexture&&u.push(j.metallicReflectanceTexture),j.reflectanceTexture&&u.push(j.reflectanceTexture),u):u}_isExtensionEnabled(G){return!G.unlit&&(void 0!=G.metallicF0Factor&&1!=G.metallicF0Factor||void 0!=G.metallicReflectanceColor&&!G.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(G))}_hasTexturesExtension(G){return null!=G.metallicReflectanceTexture||null!=G.reflectanceTexture}postExportMaterialAsync(G,A,j){return new Promise((G=>{if(j instanceof UG.c&&this._isExtensionEnabled(j)){this._wasUsed=!0,A.extensions=A.extensions||{};const G=this._exporter._materialExporter.getTextureInfo(j.metallicReflectanceTexture)??void 0,u=this._exporter._materialExporter.getTextureInfo(j.reflectanceTexture)??void 0,k={specularFactor:1==j.metallicF0Factor?void 0:j.metallicF0Factor,specularTexture:G,specularColorFactor:j.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:j.metallicReflectanceColor.hs(),specularColorTexture:u};this._hasTexturesExtension(j)&&this._exporter._materialNeedsUVsSet.add(j),A.extensions[rA]=k}G(A)}))}}yG.RegisterExtension(rA,(G=>new bA(G)));const MA="KHR_materials_transmission";class oA{constructor(G){this.name=MA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,A,j){const u=[];return j instanceof UG.c&&this._isExtensionEnabled(j)?(j.subSurface.thicknessTexture&&u.push(j.subSurface.thicknessTexture),u):u}_isExtensionEnabled(G){if(G.unlit)return!1;const A=G.subSurface;return A.isRefractionEnabled&&void 0!=A.refractionIntensity&&0!=A.refractionIntensity||this._hasTexturesExtension(G)}_hasTexturesExtension(G){return null!=G.subSurface.refractionIntensityTexture}async postExportMaterialAsync(G,A,j){if(j instanceof UG.c&&this._isExtensionEnabled(j)){this._wasUsed=!0;const u=j.subSurface,k={transmissionFactor:0===u.refractionIntensity?void 0:u.refractionIntensity};if(this._hasTexturesExtension(j)&&this._exporter._materialNeedsUVsSet.add(j),u.refractionIntensityTexture)if(u.useGltfStyleTextures){const G=await this._exporter._materialExporter.exportTextureAsync(u.refractionIntensityTexture,"image/png");G&&(k.transmissionTexture=G)}else Z.e.Warn(`${G}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);A.extensions||(A.extensions={}),A.extensions[MA]=k}return A}}yG.RegisterExtension(MA,(G=>new oA(G)));const WA="KHR_materials_unlit";class JA{constructor(){this.name=WA,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(G,A,j){return new Promise((G=>{let u=!1;j instanceof UG.c?u=j.unlit:j instanceof SG.YA&&(u=j.disableLighting),u&&(this._wasUsed=!0,null==A.extensions&&(A.extensions={}),A.extensions[WA]={}),G(A)}))}}yG.RegisterExtension(WA,(()=>new JA));const pA="KHR_materials_volume";class eA{constructor(G){this.name=pA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,A,j){const u=[];return j instanceof UG.c&&this._isExtensionEnabled(j)?(j.subSurface.thicknessTexture&&u.push(j.subSurface.thicknessTexture),u):u}_isExtensionEnabled(G){if(G.unlit)return!1;const A=G.subSurface;return!(!A.isRefractionEnabled&&!A.isTranslucencyEnabled)&&(void 0!=A.maximumThickness&&0!=A.maximumThickness||void 0!=A.tintColorAtDistance&&A.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=A.tintColor&&A.tintColor!=C.nA.White()||this._hasTexturesExtension(G))}_hasTexturesExtension(G){return null!=G.subSurface.thicknessTexture}postExportMaterialAsync(G,A,j){return new Promise((G=>{if(j instanceof UG.c&&this._isExtensionEnabled(j)){this._wasUsed=!0;const G=j.subSurface,u={thicknessFactor:0==G.maximumThickness?void 0:G.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(G.thicknessTexture)??void 0,attenuationDistance:G.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:G.tintColorAtDistance,attenuationColor:G.tintColor.equalsFloats(1,1,1)?void 0:G.tintColor.hs()};this._hasTexturesExtension(j)&&this._exporter._materialNeedsUVsSet.add(j),A.extensions=A.extensions||{},A.extensions[pA]=u}G(A)}))}}yG.RegisterExtension(pA,(G=>new eA(G)));const lA="EXT_materials_diffuse_roughness";class wA{constructor(G){this.name=lA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,A,j){const u=[];return j instanceof dA.e&&j._baseDiffuseRoughness?(j._baseDiffuseRoughnessTexture&&u.push(j._baseDiffuseRoughnessTexture),u):[]}postExportMaterialAsync(G,A,j){return new Promise((G=>{if(j instanceof dA.e){if(!j._baseDiffuseRoughness)return void G(A);this._wasUsed=!0,A.extensions=A.extensions||{};const u=this._exporter._materialExporter.getTextureInfo(j._baseDiffuseRoughnessTexture),k={diffuseRoughnessFactor:j._baseDiffuseRoughness,diffuseRoughnessTexture:u??void 0};null!==k.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(j),A.extensions[lA]=k}G(A)}))}}yG.RegisterExtension(lA,(G=>new wA(G)));const ZA="KHR_texture_transform";class PA{constructor(){this.name=ZA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(G,A,j){if(j.gG()||k.Tools.Warn(`${G}: /*@__KEY__*/"scene" is not defined for Babylon texture ${j.name}!`),(0!==j.uAng||0!==j.vAng)&&(k.Tools.Warn(`${G}: Texture ${j.name} with rotation in the u or v axis is not supported in glTF.`),0!==j.uRotationCenter||0!==j.vRotationCenter))return;const u={};let B=!1;if(0===j.uOffset&&0===j.vOffset||(u.offset=[j.uOffset,j.vOffset],B=!0),1===j.uScale&&1===j.vScale||(u.scale=[j.uScale,j.vScale],B=!0),0!==j.wAng){if(0!==j.uRotationCenter||0!==j.vRotationCenter){if(j.homogeneousRotationInUVTransform&&j.uScale!==j.vScale)return void k.Tools.Warn(`${G}: Texture ${j.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${ZA}.`);k.Tools.Warn(`${G}: Texture ${j.name} with non-origin rotation center will be exported using an adjusted offset with ${ZA}.`),u.offset=function(G){const{uOffset:A,vOffset:j,uRotationCenter:u,vRotationCenter:k,uScale:B,vScale:x,wAng:s}=G,O=Math.cos(s),d=Math.sin(s),h=u*B,H=k*x;return[A+(h*(1-O)+H*d),j+(H*(1-O)-h*d)]}(j)}u.rotation=-j.wAng,B=!0}0!==j.coordinatesIndex&&(u.texCoord=j.coordinatesIndex,B=!0),B&&(this._wasUsed=!0,A.extensions||(A.extensions={}),A.extensions[ZA]=u)}}yG.RegisterExtension(ZA,(()=>new PA));class NA{static CreateSTL(G){let A=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",k=arguments.length>3&&void 0!==arguments[3]&&arguments[3],B=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],x=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],O=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const d=function(G,A,j){const k=[3*G[j],3*G[j+1],3*G[j+2]],B=[new u.SA(A[k[0]],A[k[0]+2],A[k[0]+1]),new u.SA(A[k[1]],A[k[1]+2],A[k[1]+1]),new u.SA(A[k[2]],A[k[2]+2],A[k[2]+1])],x=B[0].CA(B[1]),s=B[2].CA(B[1]);return{v:B,n:u.SA.Cross(s,x).normalize()}},H=function(G,A,j,u){return A=F(G,A,j.x,u),A=F(G,A,j.y,u),F(G,A,j.z,u)},F=function(G,A,j,u){return G.setFloat32(A,j,u),A+4},U=function(G){if(s){let A=G;G instanceof R.b&&(A=G.sourceMesh);const j=A.getVerticesData(h.h.PositionKind,!0,!0);if(!j)return[];const k=u.SA.Zero();let B;for(B=0;B<j.length;B+=3)u.SA.TransformCoordinatesFromFloatsToRef(j[B],j[B+1],j[B+2],G.Us(!0),k).toArray(j,B);return j}return G.getVerticesData(h.h.PositionKind)||[]};s&&(x=!0);let S="",C=0,t=0;if(k){for(let j=0;j<G.length;j++){const A=G[j].Cs();C+=A?A.length/3:0}const A=new ArrayBuffer(84+50*C);S=new DataView(A),t+=80,S.setUint32(t,C,B),t+=4}else O||(S="solid stlmesh\r\n");for(let u=0;u<G.length;u++){const A=G[u];!k&&O&&(S+="solid "+A.name+"\r\n"),!x&&A instanceof YG.d&&A.bakeCurrentTransformIntoVertices();const j=U(A),s=A.Cs()||[];for(let G=0;G<s.length;G+=3){const A=d(s,j,G);k?(t=H(S,t,A.n,B),t=H(S,t,A.v[0],B),t=H(S,t,A.v[1],B),t=H(S,t,A.v[2],B),t+=2):(S+="\tfacet normal "+A.n.x+" "+A.n.y+" "+A.n.z+"\r\n",S+="\t\touter loop\r\n",S+="\t\t\tvertex "+A.v[0].x+" "+A.v[0].y+" "+A.v[0].z+"\r\n",S+="\t\t\tvertex "+A.v[1].x+" "+A.v[1].y+" "+A.v[1].z+"\r\n",S+="\t\t\tvertex "+A.v[2].x+" "+A.v[2].y+" "+A.v[2].z+"\r\n",S+="\t\tendloop\r\n",S+="\tendfacet\r\n")}!k&&O&&(S+="endsolid "+name+"\r\n")}if(k||O||(S+="endsolid stlmesh"),A){const G=document.createElement("a"),A=new Blob([S],{type:"application/octet-stream"});G.href=window.URL.createObjectURL(A),G.download=j+".stl",G.click()}return S}}function qA(G,A){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const u=[];for(let k=0;k<G.length/j;k++){const B=G[k*j],x=G[k*j+1],s=G[k*j+2];u.push(`(${B.toPrecision(A.precision)}, ${x.toPrecision(A.precision)}, ${s.toPrecision(A.precision)})`)}return u.join(", ")}function aA(G,A){const j=[];for(let u=0;u<G.length/2;u++){const k=G[2*u],B=G[2*u+1];j.push(`(${k.toPrecision(A.precision)}, ${(1-B).toPrecision(A.precision)})`)}return j.join(", ")}function yA(G,A){const j=G.getVerticesData(h.h.PositionKind),u=G.getVerticesData(h.h.NormalKind);if(j&&u)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(G){var A;const j=null!==(A=G.Cs())&&void 0!==A&&A.length?G.getTotalIndices():G.getTotalVertices();return Array(j/3).fill(3).join(", ")}(G)}]\n\t\tint[] faceVertexIndices = [${function(G){const A=G.Cs(),j=[];if(null!==A)for(let u=0;u<A.length;u++)j.push(A[u]);else{const A=G.getTotalVertices();for(let G=0;G<A;G++)j.push(G)}return j.join(", ")}(G)}]\n\t\tnormal3f[] normals = [${qA(u,A)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${qA(j,A)}]\n        ${function(G,A){let j="";for(let k=0;k<4;k++){const u=k>0?k:"",B=G.getVerticesData(h.h.UVKind+(u?u+1:""));B&&(j+=`\n\t\ttexCoord2f[] primvars:st${u} = [${aA(B,A)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const u=G.getVerticesData(h.h.ColorKind);return u&&(j+=`\n\tcolor3f[] primvars:displayColor = [${qA(u,A,u.length/G.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),j}(G,A)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function zA(G,A){return`\n        def "Geometry"\n        {\n        ${yA(G,A)}\n        }\n        `}function fA(G){let A='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return A+=G,fflate.strToU8(A)}function vA(G){const A=G.m;return`( ${iA(A,0)}, ${iA(A,4)}, ${iA(A,8)}, ${iA(A,12)} )`}function iA(G,A){return`(${G[A+0]}, ${G[A+1]}, ${G[A+2]}, ${G[A+3]})`}function LA(G){const A="Object_"+G.uniqueId,j=function(G){const A=G.getWorldMatrix().clone(),j=G.gG().useRightHandedSystem;if(!j){let u=G.parent;for(;u;){if(xG(u,j)){A.multiplyToRef(u.getWorldMatrix().invert(),A);break}u=u.parent}}return A.determinant()<0&&k.Tools.Warn(`Exporting mesh ${G.name} with negative scale. Result may look incorrect in destination engine.`),A}(G),u=vA(j);return`def Xform "${A}" (\n\tprepend references = @./geometries/Geometry_${G.Ss.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${u}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${G.material.uniqueId}>\n}\n\n`}function VA(G){switch(G){case D.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case D.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case D.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function KA(G){return`(${G.x}, ${G.y})`}function TA(G){return`(${G.r}, ${G.g}, ${G.b})`}function mA(G,A,j,k,B,x){const s=G.getInternalTexture().uniqueId+"_"+G.invertY;B[s]=G;const O=G.coordinatesIndex>0?"st"+G.coordinatesIndex:"st",d=new u.Vector2(G.uScale,G.vScale),h=new u.Vector2(G.uOffset,G.vOffset),H=G.wAng,F=Math.sin(H),R=Math.cos(H);return h.y=1-h.y-d.y,h.x+=F*d.x,h.y+=(1-R)*d.y,`\n    def Shader "PrimvarReader_${j}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${O}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${j}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${A.uniqueId}/PrimvarReader_${j}.outputs:result>\n        float inputs:rotation = ${(H*(180/Math.PI)).toFixed(x.precision)}\n        float2 inputs:scale = ${KA(d)}\n        float2 inputs:translation = ${KA(h)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${G.uniqueId}_${j}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${s}.png@\n        float2 inputs:st.connect = </Materials/Material_${A.uniqueId}/Transform2d_${j}.outputs:result>\n        ${k?"float4 inputs:scale = "+function(G){return`(${G.r}, ${G.g}, ${G.b}, 1.0)`}(k):""}\n        token inputs:sourceColorSpace = "${G.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${VA(G.wrapU)}"\n        token inputs:wrapT = "${VA(G.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${A.needAlphaBlending()?"float outputs:a":""}\n    }`}function Gj(G,A,j){const u="\t\t\t",k=[],B=[],{diffuseMap:x,cs:s,alphaCutOff:O,emissiveMap:d,emissive:h,normalMap:H,roughnessMap:F,roughnessChannel:R,roughness:U,metalnessMap:S,metalnessChannel:t,metalness:Y,aoMap:n,aoMapChannel:Q,aoMapIntensity:X,alphaMap:I,ior:D,clearCoatEnabled:g,clearCoat:c,clearCoatMap:E,clearCoatRoughness:r,clearCoatRoughnessMap:b}=function(G){const A={diffuseMap:null,cs:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return G instanceof SG.YA?{...A,diffuseMap:G.diffuseTexture,cs:G.diffuseColor,alphaCutOff:G.alphaCutOff,emissiveMap:G.emissiveTexture,emissive:G.emissiveColor,roughness:1,alphaMap:G.opacityTexture}:G instanceof dA.e?{...A,diffuseMap:G._albedoTexture,cs:G._albedoColor,alphaCutOff:G._alphaCutOff,emissiveMap:G._emissiveTexture,emissive:G._emissiveColor,normalMap:G._bumpTexture,roughnessMap:G._metallicTexture,roughnessChannel:G._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:G._roughness??1,metalnessMap:G._metallicTexture,metalnessChannel:G._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:G._metallic??0,aoMap:G._ambientTexture,aoMapChannel:G._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:G._ambientTextureStrength,alphaMap:G._opacityTexture,ior:G.subSurface.indexOfRefraction,clearCoatEnabled:G.clearCoat.isEnabled,clearCoat:G.clearCoat.gs,clearCoatMap:G.clearCoat.texture,clearCoatRoughness:G.clearCoat.roughness,clearCoatRoughnessMap:G.clearCoat.useRoughnessFromMainTexture?G.clearCoat.texture:G.clearCoat.textureRoughness}:A}(G);return null!==x?(k.push(`${u}color3f inputs:diffuseColor.connect = </Materials/Material_${G.uniqueId}/Texture_${x.uniqueId}_diffuse.outputs:rgb>`),G.needAlphaBlending()?k.push(`${u}float inputs:opacity.connect = </Materials/Material_${G.uniqueId}/Texture_${x.uniqueId}_diffuse.outputs:a>`):G.needAlphaTesting()&&(k.push(`${u}float inputs:opacity.connect = </Materials/Material_${G.uniqueId}/Texture_${x.uniqueId}_diffuse.outputs:a>`),k.push(`${u}float inputs:opacityThreshold = ${O}`)),B.push(mA(x,G,"diffuse",s,A,j))):k.push(`${u}color3f inputs:diffuseColor = ${TA(s||C.nA.White())}`),null!==d?(k.push(`${u}color3f inputs:emissiveColor.connect = </Materials/Material_${G.uniqueId}/Texture_${d.uniqueId}_emissive.outputs:rgb>`),B.push(mA(d,G,"emissive",h,A,j))):h&&h.toLuminance()>0&&k.push(`${u}color3f inputs:emissiveColor = ${TA(h)}`),null!==H&&(k.push(`${u}normal3f inputs:normal.connect = </Materials/Material_${G.uniqueId}/Texture_${H.uniqueId}_normal.outputs:rgb>`),B.push(mA(H,G,"normal",null,A,j))),null!==n&&(k.push(`${u}float inputs:occlusion.connect = </Materials/Material_${G.uniqueId}/Texture_${n.uniqueId}_occlusion.outputs:${Q}>`),B.push(mA(n,G,"occlusion",new C.nA(X,X,X),A,j))),null!==F?(k.push(`${u}float inputs:roughness.connect = </Materials/Material_${G.uniqueId}/Texture_${F.uniqueId}_roughness.outputs:${R}>`),B.push(mA(F,G,"roughness",new C.nA(U,U,U),A,j))):k.push(`${u}float inputs:roughness = ${U}`),null!==S?(k.push(`${u}float inputs:metallic.connect = </Materials/Material_${G.uniqueId}/Texture_${S.uniqueId}_metallic.outputs:${t}>`),B.push(mA(S,G,"metallic",new C.nA(Y,Y,Y),A,j))):k.push(`${u}float inputs:metallic = ${Y}`),null!==I?(k.push(`${u}float inputs:opacity.connect = </Materials/Material_${G.uniqueId}/Texture_${I.uniqueId}_opacity.outputs:r>`),k.push(`${u}float inputs:opacityThreshold = 0.0001`),B.push(mA(I,G,"opacity",null,A,j))):k.push(`${u}float inputs:opacity = ${G.alpha}`),g&&(null!==E?(k.push(`${u}float inputs:clearcoat.connect = </Materials/Material_${G.uniqueId}/Texture_${E.uniqueId}_clearcoat.outputs:r>`),B.push(mA(E,G,"clearcoat",new C.nA(c,c,c),A,j))):k.push(`${u}float inputs:clearcoat = ${c}`),null!==b?(k.push(`${u}float inputs:clearcoatRoughness.connect = </Materials/Material_${G.uniqueId}/Texture_${b.uniqueId}_clearcoatRoughness.outputs:g>`),B.push(mA(b,G,"clearcoatRoughness",new C.nA(r,r,r),A,j))):k.push(`${u}float inputs:clearcoatRoughness = ${r}`)),k.push(`${u}float inputs:ior = ${D}`),`\n\tdef Material "Material_${G.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${k.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${G.uniqueId}/PreviewSurface.outputs:surface>\n\n${B.join("\n")}\n\n\t}\n`}async function Aj(G,A,j){const B={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...A};"undefined"===typeof fflate&&await k.Tools.LoadScriptAsync(B.fflateUrl);const x={};x[B.modelFileName]=null;let s='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';s+=function(G){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===G.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${G.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${G.planeAnchoringAlignment}"`:""}\n            `}(B);const O={};for(const u of G.meshes){if(0===u.getTotalVertices())continue;const G=u,A=G.Ss,d=G.material;if(!d||!A||j&&!j(G))continue;if(-1!==["YA","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(d.getClassName())){const j="geometries/Geometry_"+A.uniqueId+".usda";if(!(j in x)){const G=zA(A,B);x[j]=fA(G)}d.uniqueId in O||(O[d.uniqueId]=d),s+=LA(G)}else k.Tools.Warn("USDZExportAsync does not support this material type: "+d.getClassName())}G.activeCamera&&B.exportCamera&&(s+=function(G,A){const j="Camera_"+G.uniqueId,k=vA(u.Matrix.RotationY(Math.PI).multiply(G.getWorldMatrix()));if(G.mode===D.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${j}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${k}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${G.Fs.toPrecision(A.precision)}, ${G.maxZ.toPrecision(A.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(G.orthoLeft||1)+Math.abs(G.orthoRight||1))).toPrecision(A.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(G.orthoTop||1)+Math.abs(G.orthoBottom||1))).toPrecision(A.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const u=G.getEngine().getAspectRatio(G),B=A.cameraSensorWidth||35;return`def Camera "${j}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${k}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${G.Fs.toPrecision(A.precision)}, ${G.maxZ.toPrecision(A.precision)})\n\t\t\tfloat focalLength = ${(B/(2*Math.tan(.5*G.fov))).toPrecision(A.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(B*u).toPrecision(A.precision)}\n\t\t\tfloat verticalAperture = ${(B/u).toPrecision(A.precision)}            \n\t\t}\n\t\n\t`}}(G.activeCamera,B)),s+="\n            }\n        }\n    }";const d={};s+=function(G,A,j){const u=[];for(const k in G){const B=G[k];u.push(Gj(B,A,j))}return`\n    def "Materials"\n{\n${u.join("")}\n}\n\n`}(O,d,B),x[B.modelFileName]=fflate.strToU8(s);for(const u in d){const G=d[u],A=G.getSize(),j=await G.readPixels();if(!j)throw new Error("Texture data is not available");const k=await g.DumpTools.DumpDataAsync(A.width,A.height,j,"image/png",void 0,!1,!0);x[`textures/Texture_${u}.png`]=new Uint8Array(k).slice()}let h=0;for(const u in x){const G=x[u];if(!G)continue;h+=34+u.length;const A=63&h;if(4!==A){const j=new Uint8Array(64-A);x[u]=[G,{extra:{12345:j}}]}h=G.length}return fflate.zipSync(x,{level:0})}}}]);