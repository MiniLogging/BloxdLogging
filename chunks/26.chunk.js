"use strict";(self["9jl1vn4ei5r"]=self["9jl1vn4ei5r"]||[]).push([[26],{12222:(M,p,b)=>{b.r(p),b.d(p,{EXT_materials_diffuse_roughness:()=>cp,EXT_mesh_gpu_instancing:()=>tM,GLTF2Export:()=>vM,GLTFData:()=>O,KHR_draco_mesh_compression:()=>bp,KHR_lights_punctual:()=>Tp,KHR_materials_anisotropy:()=>Fp,KHR_materials_clearcoat:()=>Wp,KHR_materials_diffuse_transmission:()=>jp,KHR_materials_dispersion:()=>Dp,KHR_materials_emissive_strength:()=>sp,KHR_materials_ior:()=>fp,KHR_materials_iridescence:()=>yp,KHR_materials_sheen:()=>Pp,KHR_materials_specular:()=>Np,KHR_materials_transmission:()=>Yp,KHR_materials_unlit:()=>Ep,KHR_materials_volume:()=>gp,KHR_texture_transform:()=>Vp,OBJExport:()=>k,STLExport:()=>hp,USDZExportAsync:()=>pb,_ConvertToGLTFPBRMetallicRoughness:()=>w,_SolveMetallic:()=>Y,__IGLTFExporterExtension:()=>u});var Q=b(11796),q=b(11621),B=b(12129);class k{static OBJ(M,p,b,k){const u=[];let T=1,O=1;p&&(b||(b="mat"),u.push("mtllib "+b+".mtl"));for(let H=0;H<M.length;H++){const b=M[H],F=b.name||`mesh${H}}`;u.push(`o ${F}`);let o=null;if(k){const M=b.ib(!0);o=new Q.Matrix,M.invertToRef(o),b.bakeTransformIntoVertices(M)}if(p){const M=b.material;M&&u.push("usemtl "+M.id)}const W=b.Ab;if(!W){q.Tools.Warn("No geometry is present on the mesh");continue}const i=W.getVerticesData("position"),A=W.getVerticesData("normal"),j=W.getVerticesData("uv"),K=W.jb();let D=0,a=0;if(!i||!K){q.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const s=M[0].RM().useRightHandedSystem?1:-1;for(let M=0;M<i.length;M+=3)u.push("v "+i[M]*s+" "+i[M+1]+" "+i[M+2]),D++;if(null!=A)for(let M=0;M<A.length;M+=3)u.push("vn "+A[M]*s+" "+A[M+1]+" "+A[M+2]);if(null!=j)for(let M=0;M<j.length;M+=2)u.push("vt "+j[M]+" "+j[M+1]),a++;const S=["","",""],f=(b.material||b.RM().defaultMaterial)._getEffectiveOrientation(b),[R,y]=f===B.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let M=0;M<K.length;M+=3){const p=[String(K[M]+T),String(K[M+R]+T),String(K[M+y]+T)],b=[String(K[M]+O),String(K[M+R]+O),String(K[M+y]+O)],Q=p,q=null!=j?b:S,B=null!=A?p:S;u.push("f "+Q[0]+"/"+q[0]+"/"+B[0]+" "+Q[1]+"/"+q[1]+"/"+B[1]+" "+Q[2]+"/"+q[2]+"/"+B[2])}k&&o&&b.bakeTransformIntoVertices(o),T+=D,O+=a}return u.join("\n")}static MTL(M){const p=[],b=M.material;p.push("newmtl mat1"),p.push("  Ns "+b.specularPower.toFixed(4)),p.push("  Ni 1.5000"),p.push("  d "+b.alpha.toFixed(4)),p.push("  Tr 0.0000"),p.push("  Tf 1.0000 1.0000 1.0000"),p.push("  illum 2"),p.push("  Ka "+b.ambientColor.r.toFixed(4)+" "+b.ambientColor.g.toFixed(4)+" "+b.ambientColor.b.toFixed(4)),p.push("  Kd "+b.diffuseColor.r.toFixed(4)+" "+b.diffuseColor.g.toFixed(4)+" "+b.diffuseColor.b.toFixed(4)),p.push("  Ks "+b.specularColor.r.toFixed(4)+" "+b.specularColor.g.toFixed(4)+" "+b.specularColor.b.toFixed(4)),p.push("  Ke "+b.emissiveColor.r.toFixed(4)+" "+b.emissiveColor.g.toFixed(4)+" "+b.emissiveColor.b.toFixed(4));b.ambientTexture&&p.push("  map_Ka "+b.ambientTexture.name),b.diffuseTexture&&p.push("  map_Kd "+b.diffuseTexture.name),b.specularTexture&&p.push("  map_Ks "+b.specularTexture.name),b.bumpTexture&&p.push("  map_bump -imfchan z "+b.bumpTexture.name),b.opacityTexture&&p.push("  map_d "+b.opacityTexture.name);return p.join("\n")}}var u=0,T=b(11671);class O{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const M in this.files){const p=this.files[M],b=new Blob([p],{type:(0,T.g)(M)});q.Tools.Download(b,M)}}}var H=b(11857),F=b(12231),o=b(12242),W=b(12255),i=b(11911),A=b(11664),j=b(11833),K=b(11806);const D=K.HighestCommonFactor,a={...K,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:D};var s=b(12022),S=b(11780),f=b(12284),R=b(12290),y=b(12016);const x=1e-6,P=new j.ap(.04,.04,.04),L=1024,N=j.ap.White(),r=j.ap.Black();function Y(M,p,b){if(p<P.r)return 0;const Q=P.r,q=M*b/(1-P.r)+p-2*P.r,B=q*q-4*Q*(P.r-p);return a.Clamp((-q+Math.sqrt(B))/(2*Q),0,1)}function w(M){const p=M.diffuseColor.toLinearSpace(M.RM().getEngine().useExactSrgbConversions).scale(.5),b=M.alpha,q=function(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Q.Vector2(0,1),b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Q.Vector2(0,.1),q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Q.Vector2(0,.1),B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new Q.Vector2(1300,.1);return function(M,p,b,Q,q){return(1-M)*(1-M)*(1-M)*p+3*(1-M)*(1-M)*M*b+3*(1-M)*M*M*Q+M*M*M*q}(Math.pow(M/B.x,.333333),p.y,b.y,q.y,B.y)}(a.Clamp(M.specularPower,0,L));return{baseColorFactor:[p.r,p.g,p.b,b],metallicFactor:0,roughnessFactor:q}}function E(M,p){p.needAlphaBlending()?M.alphaMode="BLEND":p.needAlphaTesting()&&(M.alphaMode="MASK",M.alphaCutoff=p.alphaCutOff)}function n(M,p,b){const Q=new Uint8Array(M*p*4);for(let q=0;q<Q.length;q+=4)Q[q]=Q[q+1]=Q[q+2]=Q[q+3]=255;return f.e.CreateRGBATexture(Q,M,p,b)}function g(M){if(M instanceof Uint8Array){const p=M.length,b=new Float32Array(M.length);for(let Q=0;Q<p;++Q)b[Q]=M[Q]/255;return b}if(M instanceof Float32Array)return M;throw new Error("Unsupported pixel format!")}class U{constructor(M){this._exporter=M,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(M){return M?this._textureMap.get(M)??null:null}async exportStandardMaterialAsync(M,p,b){const Q=w(M),B={name:M.name};if(null==M.Kb||M.Kb||(M.twoSidedLighting||q.Tools.Warn(M.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),B.doubleSided=!0),b){const b=[],q=M.diffuseTexture;q&&b.push(this.exportTextureAsync(q,p).then((M=>{M&&(Q.baseColorTexture=M)})));const k=M.bumpTexture;k&&b.push(this.exportTextureAsync(k,p).then((M=>{M&&(B.normalTexture=M,1!==k.level&&(B.normalTexture.scale=k.level))})));const u=M.emissiveTexture;u&&(B.emissiveFactor=[1,1,1],b.push(this.exportTextureAsync(u,p).then((M=>{M&&(B.emissiveTexture=M)}))));const T=M.ambientTexture;T&&b.push(this.exportTextureAsync(T,p).then((M=>{if(M){const p={index:M.index};B.occlusionTexture=p}}))),b.length>0&&(this._exporter._materialNeedsUVsSet.add(M),await Promise.all(b))}(M.alpha<1||M.opacityTexture)&&(M.alphaMode===R.c.ALPHA_COMBINE?B.alphaMode="BLEND":q.Tools.Warn(M.name+": glTF 2.0 does not support alpha mode: "+M.alphaMode.toString())),M.emissiveColor&&!M.emissiveColor.equalsWithEpsilon(r,x)&&(B.emissiveFactor=M.emissiveColor.Ob()),B.pbrMetallicRoughness=Q,E(B,M),await this._finishMaterialAsync(B,M,p);const k=this._exporter._materials;return k.push(B),k.length-1}async _finishMaterialAsync(M,p,b){const Q=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",M,p),q=[];for(const B of Q)q.push(this.exportTextureAsync(B,b));await Promise.all(q),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",M,p)}async _getImageDataAsync(M,p,Q,q){const B=R.c.TEXTURETYPE_UNSIGNED_BYTE,k=this._exporter._babylonScene,u=k.getEngine(),T=u.createRawTexture(M,p,Q,R.c.TEXTUREFORMAT_RGBA,!1,!0,S.b.NEAREST_SAMPLINGMODE,null,B);u.isWebGPU?await b.e(51).then(b.bind(b,14197)):await b.e(52).then(b.bind(b,14201)),await s.k.ApplyPostProcess("pass",T,k,B,R.c.TEXTURE_NEAREST_SAMPLINGMODE,R.c.TEXTUREFORMAT_RGBA);const O=await u._readTexturePixels(T,p,Q);return await y.DumpTools.DumpDataAsync(p,Q,O,q,void 0,!0,!0)}_resizeTexturesToSameDimensions(M,p,b){const Q=M?M.getSize():{width:0,height:0},q=p?p.getSize():{width:0,height:0};let B,k;return Q.width<q.width?(B=M&&M instanceof S.b?s.k.CreateResizedCopy(M,q.width,q.height,!0):n(q.width,q.height,b),k=p):Q.width>q.width?(k=p&&p instanceof S.b?s.k.CreateResizedCopy(p,Q.width,Q.height,!0):n(Q.width,Q.height,b),B=M):(B=M,k=p),{texture1:B,texture2:k}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(M,p,b,Q){const q=new Array;if(!M&&!p)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const B=M?M.RM():p?p.RM():null;if(B){var k;const u=this._resizeTexturesToSameDimensions(M,p,B),T=null===(k=u.texture1)||void 0===k?void 0:k.getSize();let O,H;const F=T.width,o=T.height,W=await u.texture1.readPixels(),i=await u.texture2.readPixels();if(!W)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(O=g(W),!i)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");H=g(i);const A=H.byteLength,K=new Uint8Array(A),D=new Uint8Array(A),a=4,s=r;let S=0,f=0;for(let M=0;M<o;++M)for(let p=0;p<F;++p){const Q=(F*M+p)*a,q={diffuseColor:new j.ap(O[Q],O[Q+1],O[Q+2]).toLinearSpace(B.getEngine().useExactSrgbConversions).multiply(b.diffuseColor),specularColor:new j.ap(H[Q],H[Q+1],H[Q+2]).toLinearSpace(B.getEngine().useExactSrgbConversions).multiply(b.specularColor),glossiness:H[Q+3]*b.glossiness},k=this._convertSpecularGlossinessToMetallicRoughness(q);s.r=Math.max(s.r,k.baseColor.r),s.g=Math.max(s.g,k.baseColor.g),s.b=Math.max(s.b,k.baseColor.b),S=Math.max(S,k.metallic),f=Math.max(f,k.roughness),D[Q]=255*k.baseColor.r,D[Q+1]=255*k.baseColor.g,D[Q+2]=255*k.baseColor.b,D[Q+3]=u.texture1.Hb?255*O[Q+3]:255,K[Q]=0,K[Q+1]=255*k.roughness,K[Q+2]=255*k.metallic,K[Q+3]=255}const R={baseColor:s,metallic:S,roughness:f};let y=!1,P=!1;for(let M=0;M<o;++M)for(let p=0;p<F;++p){const b=(F*M+p)*a;D[b]/=R.baseColor.r>x?R.baseColor.r:1,D[b+1]/=R.baseColor.g>x?R.baseColor.g:1,D[b+2]/=R.baseColor.b>x?R.baseColor.b:1;const Q=j.ap.FromInts(D[b],D[b+1],D[b+2]).toGammaSpace(B.getEngine().useExactSrgbConversions);D[b]=255*Q.r,D[b+1]=255*Q.g,D[b+2]=255*Q.b,Q.equalsWithEpsilon(N,x)||(P=!0),K[b+1]/=R.roughness>x?R.roughness:1,K[b+2]/=R.metallic>x?R.metallic:1;j.ap.FromInts(255,K[b+1],K[b+2]).equalsWithEpsilon(N,x)||(y=!0)}return y&&q.push(this._getImageDataAsync(K,F,o,Q).then((M=>{R.metallicRoughnessTextureData=M}))),P&&q.push(this._getImageDataAsync(D,F,o,Q).then((M=>{R.baseColorTextureData=M}))),await Promise.all(q).then((()=>R))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(M){const p=this._getPerceivedBrightness(M.diffuseColor),b=this._getPerceivedBrightness(M.specularColor),Q=1-this._getMaxComponent(M.specularColor),q=Y(p,b,Q),B=M.diffuseColor.scale(Q/(1-P.r)/Math.max(1-q)),k=M.specularColor.jp(P.scale(1-q)).scale(1/Math.max(q));let u=j.ap.Lerp(B,k,q*q);u=u.clampToRef(0,1,u);return{baseColor:u,metallic:q,roughness:1-M.glossiness}}_getPerceivedBrightness(M){return M?Math.sqrt(.299*M.r*M.r+.587*M.g*M.g+.114*M.b*M.b):0}_getMaxComponent(M){return M?Math.max(M.r,Math.max(M.g,M.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(M,p,b,Q){const q=[],B={baseColor:M._albedoColor,metallic:M._metallic,roughness:M._roughness};if(Q){M._albedoTexture&&q.push(this.exportTextureAsync(M._albedoTexture,p).then((M=>{M&&(b.baseColorTexture=M)})));const Q=M._metallicTexture;Q&&q.push(this.exportTextureAsync(Q,p).then((M=>{M&&(b.metallicRoughnessTexture=M)})))}return q.length>0&&(this._exporter._materialNeedsUVsSet.add(M),await Promise.all(q)),B}_getTextureSampler(M){const p={};if(!M||!(M instanceof S.b))return p;const b=this._getGLTFTextureWrapMode(M.wrapU);10497!==b&&(p.wrapS=b);const Q=this._getGLTFTextureWrapMode(M.wrapV);switch(10497!==Q&&(p.wrapT=Q),M.samplingMode){case S.b.LINEAR_LINEAR:p.magFilter=9729,p.minFilter=9729;break;case S.b.LINEAR_NEAREST:p.magFilter=9729,p.minFilter=9728;break;case S.b.NEAREST_LINEAR:p.magFilter=9728,p.minFilter=9729;break;case S.b.NEAREST_LINEAR_MIPLINEAR:p.magFilter=9728,p.minFilter=9987;break;case S.b.NEAREST_NEAREST:p.magFilter=9728,p.minFilter=9728;break;case S.b.NEAREST_LINEAR_MIPNEAREST:p.magFilter=9728,p.minFilter=9985;break;case S.b.LINEAR_NEAREST_MIPNEAREST:p.magFilter=9729,p.minFilter=9984;break;case S.b.LINEAR_NEAREST_MIPLINEAR:p.magFilter=9729,p.minFilter=9986;break;case S.b.NEAREST_NEAREST_MIPLINEAR:p.magFilter=9728,p.minFilter=9986;break;case S.b.LINEAR_LINEAR_MIPLINEAR:p.magFilter=9729,p.minFilter=9987;break;case S.b.LINEAR_LINEAR_MIPNEAREST:p.magFilter=9729,p.minFilter=9985;break;case S.b.NEAREST_NEAREST_MIPNEAREST:p.magFilter=9728,p.minFilter=9984}return p}_getGLTFTextureWrapMode(M){switch(M){case S.b.WRAP_ADDRESSMODE:return 10497;case S.b.CLAMP_ADDRESSMODE:return 33071;case S.b.MIRROR_ADDRESSMODE:return 33648;default:return q.Tools.Error(`Unsupported Texture Wrap Mode ${M}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(M,p,b,Q){const q={diffuseColor:M._albedoColor,specularColor:M._reflectivityColor,glossiness:M._microSurface},B=M._albedoTexture,k=M._reflectivityTexture,u=M._useMicroSurfaceFromReflectivityMapAlpha;if(k&&!u)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((B||k)&&Q){this._exporter._materialNeedsUVsSet.add(M);const Q=this._exportTextureSampler(B||k),u=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(B,k,q,p),T=this._exporter._textures;if(u.baseColorTextureData){const M=this._exportImage(`baseColor${T.length}`,p,u.baseColorTextureData);b.baseColorTexture=this._exportTextureInfo(M,Q,null===B||void 0===B?void 0:B.coordinatesIndex)}if(u.metallicRoughnessTextureData){const M=this._exportImage(`metallicRoughness${T.length}`,p,u.metallicRoughnessTextureData);b.metallicRoughnessTexture=this._exportTextureInfo(M,Q,null===k||void 0===k?void 0:k.coordinatesIndex)}return u}return this._convertSpecularGlossinessToMetallicRoughness(q)}async exportPBRMaterialAsync(M,p,b){const Q={},q={name:M.name},B=M.isMetallicWorkflow();if(B){const p=M._albedoColor,b=M.alpha;p&&(Q.baseColorFactor=[p.r,p.g,p.b,b])}const k=B?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(M,p,Q,b):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(M,p,Q,b);await this._setMetallicRoughnessPbrMaterialAsync(k,M,q,Q,p,b),await this._finishMaterialAsync(q,M,p);const u=this._exporter._materials;return u.push(q),u.length-1}async _setMetallicRoughnessPbrMaterialAsync(M,p,b,Q,B,k){if(E(b,p),M.baseColor.equalsWithEpsilon(N,x)&&a.WithinEpsilon(p.alpha,1,x)||(Q.baseColorFactor=[M.baseColor.r,M.baseColor.g,M.baseColor.b,p.alpha]),null!=M.metallic&&1!==M.metallic&&(Q.metallicFactor=M.metallic),null!=M.roughness&&1!==M.roughness&&(Q.roughnessFactor=M.roughness),null==p.Kb||p.Kb||(p._twoSidedLighting||q.Tools.Warn(p.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),b.doubleSided=!0),k){const M=[],Q=p._bumpTexture;Q&&M.push(this.exportTextureAsync(Q,B).then((M=>{M&&(b.normalTexture=M,1!==Q.level&&(b.normalTexture.scale=Q.level))})));const q=p._ambientTexture;q&&M.push(this.exportTextureAsync(q,B).then((M=>{if(M){const Q={index:M.index,texCoord:M.texCoord,extensions:M.extensions};b.occlusionTexture=Q;const q=p._ambientTextureStrength;q&&(Q.strength=q)}})));const k=p._emissiveTexture;k&&M.push(this.exportTextureAsync(k,B).then((M=>{M&&(b.emissiveTexture=M)}))),M.length>0&&(this._exporter._materialNeedsUVsSet.add(p),await Promise.all(M))}const u=p._emissiveColor;u.equalsWithEpsilon(r,x)||(b.emissiveFactor=u.Ob()),b.pbrMetallicRoughness=Q}_getPixelsFromTextureAsync(M){return function(M){switch(M){case R.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case R.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case R.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case R.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case R.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case R.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case R.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case R.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case R.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case R.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case R.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case R.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(M.textureFormat)?(0,s.j)(M,M._texture.width,M._texture.height):(M.textureType,R.c.TEXTURETYPE_UNSIGNED_BYTE,M.readPixels())}async exportTextureAsync(M,p){const b=this._exporter._extensionsPreExportTextureAsync("exporter",M,p);return b?await b.then((async b=>b?await this._exportTextureInfoAsync(b,p):await this._exportTextureInfoAsync(M,p))):await this._exportTextureInfoAsync(M,p)}async _exportTextureInfoAsync(M,p){let b=this._textureMap.get(M);if(!b){const Q=await this._getPixelsFromTextureAsync(M);if(!Q)return null;const B=this._exportTextureSampler(M),k=M.mimeType;if(k)switch(k){case"image/jpeg":case"image/png":case"image/webp":p=k;break;default:q.Tools.Warn(`Unsupported media type: ${k}. Exporting texture as PNG.`)}const u=this._internalTextureToImage,T=M.getInternalTexture().uniqueId;u[T]||(u[T]={});let O=u[T][p];if(void 0===O){const b=M.getSize();O=(async()=>{const q=await this._getImageDataAsync(Q,b.width,b.height,p);return this._exportImage(M.name,p,q)})(),u[T][p]=O}b=this._exportTextureInfo(await O,B,M.coordinatesIndex),this._textureMap.set(M,b),this._exporter._extensionsPostExportTextures("exporter",b,M)}return b}_exportImage(M,p,b){const Q=this._exporter._images;let B;if(this._exporter._shouldUseGlb){B={name:M,mimeType:p,bufferView:void 0};const Q=this._exporter._bufferManager.createBufferView(new Uint8Array(b));this._exporter._bufferManager.setBufferView(B,Q)}else{const k=M.replace(/\.\/|\/|\.\\|\\/g,"_"),u=function(M){switch(M){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(p);let T=k+u;Q.some((M=>M.uri===T))&&(T=`${k}_${q.Tools.RandomId()}${u}`),B={name:M,uri:T},this._exporter._imageData[T]={data:b,mimeType:p}}return Q.push(B),Q.length-1}_exportTextureInfo(M,p,b){const Q=this._exporter._textures;let q=Q.findIndex((b=>b.sampler==p&&b.source===M));-1===q&&(q=Q.length,Q.push({source:M,sampler:p}));const B={index:q};return b&&(B.texCoord=b),B}_exportTextureSampler(M){const p=this._getTextureSampler(M),b=this._exporter._samplers,Q=b.findIndex((M=>M.minFilter===p.minFilter&&M.magFilter===p.magFilter&&M.wrapS===p.wrapS&&M.wrapT===p.wrapT));return-1!==Q?Q:(b.push(p),b.length-1)}}var c=b(11863),d=b(11637),V=b(12297),h=b(11798);const I=Q.Ap.Zero(),Z=Q.Quaternion.Identity(),J=Q.Ap.One(),v=new Q.Ap(-1,1,1);function z(M,p){const{byteOffset:b,byteStride:Q,type:q,normalized:B}=M,k=M.getSize(),u=p.reduce(((M,p)=>p.getTotalVertices()>M?p.getTotalVertices():M),-Number.MAX_VALUE);return{byteOffset:b,byteStride:Q,componentCount:k,type:q,count:u*k,normalized:B,totalVertices:u,kind:M.getKind()}}function t(M){switch(M){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function e(M){switch(M){case H.f.PositionKind:case H.f.NormalKind:case H.f.TangentKind:case H.f.ColorKind:case H.f.MatricesIndicesKind:case H.f.MatricesIndicesExtraKind:case H.f.MatricesWeightsKind:case H.f.MatricesWeightsExtraKind:case H.f.UVKind:case H.f.UV2Kind:case H.f.UV3Kind:case H.f.UV4Kind:case H.f.UV5Kind:case H.f.UV6Kind:return!0}return!1}function G(M){switch(M){case B.e.TriangleFillMode:return 4;case B.e.TriangleStripDrawMode:return 5;case B.e.TriangleFanDrawMode:return 6;case B.e.PointListDrawMode:case B.e.PointFillMode:return 0;case B.e.LineLoopDrawMode:return 2;case B.e.LineListDrawMode:return 1;case B.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${M}`)}function mM(M){const p=Math.sqrt(M.x*M.x+M.y*M.y+M.z*M.z);p>0&&(M.x/=p,M.y/=p,M.z/=p)}function C(M){return M.x*=-1,M}function X(M){if(M.x*M.x+M.y*M.y>.5){const p=Math.abs(M.x),b=Math.abs(M.y);if(p>b){const b=Math.sign(M.x);M.x=p,M.y*=-b,M.z*=-b,M.w*=b}else{const p=Math.sign(M.y);M.x*=-p,M.y=b,M.z*=p,M.w*=-p}}else{const p=Math.abs(M.z),b=Math.abs(M.w);if(p>b){const b=Math.sign(M.z);M.x*=-b,M.y*=b,M.z=p,M.w*=-b}else{const p=Math.sign(M.w);M.x*=p,M.y*=-p,M.z*=-p,M.w=b}}return M}function l(M){M.Db(-M.z,M.w,M.x,-M.y)}function MM(M,p){const b=Q.Ap.FromArrayToRef(p.translation||[0,0,0],0,Q.TmpVectors.Ap[0]),q=Q.Quaternion.FromArrayToRef(p.rotation||[0,0,0,1],0,Q.TmpVectors.Quaternion[0]),B=Q.Matrix.ComposeToRef(J,q,b,Q.TmpVectors.Matrix[0]),k=Q.Ap.FromArrayToRef(M.translation||[0,0,0],0,Q.TmpVectors.Ap[2]),u=Q.Quaternion.FromArrayToRef(M.rotation||[0,0,0,1],0,Q.TmpVectors.Quaternion[1]),T=Q.Matrix.ComposeToRef(J,u,k,Q.TmpVectors.Matrix[1]);B.multiplyToRef(T,T),T.decompose(void 0,q,b),b.equalsWithEpsilon(I,h.d)?delete p.translation:p.translation=b.Ob(),q.equalsWithEpsilon(Z,h.d)?delete p.rotation:p.rotation=q.Ob(),p.scale&&delete p.scale}function pM(M,p){if(!(p instanceof F.c))return!1;if(!(1===p.getChildren().length&&0===M.getChildren().length&&M.parent===p))return!1;const b=M.RM(),Q=M instanceof V.e&&!b.useRightHandedSystem?v:J;return!!p.ab.equalsWithEpsilon(Q,h.d)||(d.c.Warn(`Cannot collapse node ${M.name} into parent node ${p.name} with modified scaling.`),!1)}function bM(M){if(M instanceof Array){const p=new Float32Array(M);return new Uint8Array(p.buffer,p.byteOffset,p.byteLength)}return ArrayBuffer.isView(M)?new Uint8Array(M.buffer,M.byteOffset,M.byteLength):new Uint8Array(M)}function QM(M,p){for(const[b,Q]of Object.entries(M)){const q=p[b];(Array.isArray(Q)&&Array.isArray(q)&&qM(Q,q)||Q===q)&&delete M[b]}return M}function qM(M,p){return M.length===p.length&&M.every(((M,b)=>M===p[b]))}const BM=Q.Matrix.Compose(new Q.Ap(-1,1,1),Q.Quaternion.Identity(),Q.Ap.Zero());function kM(M,p){if(!(M instanceof F.c))return!1;if(p){if(!M.getWorldMatrix().equalsWithEpsilon(Q.Matrix.IdentityReadOnly,h.d))return!1}else{if(!M.getWorldMatrix().multiplyToRef(BM,Q.TmpVectors.Matrix[0]).equalsWithEpsilon(Q.Matrix.IdentityReadOnly,h.d))return!1}return!(M instanceof o.b&&M.Ab)}const uM=new Map([[Int8Array,(M,p,b)=>M.setInt8(p,b)],[Uint8Array,(M,p,b)=>M.setUint8(p,b)],[Uint8ClampedArray,(M,p,b)=>M.setUint8(p,b)],[Int16Array,(M,p,b)=>M.setInt16(p,b,!0)],[Uint16Array,(M,p,b)=>M.setUint16(p,b,!0)],[Int32Array,(M,p,b)=>M.setInt32(p,b,!0)],[Uint32Array,(M,p,b)=>M.setUint32(p,b,!0)],[Float32Array,(M,p,b)=>M.setFloat32(p,b,!0)],[Float64Array,(M,p,b)=>M.setFloat64(p,b,!0)]]);class TM{writeTypedArray(M){this._checkGrowBuffer(M.byteLength);const p=uM.get(M.constructor);for(let b=0;b<M.length;b++)p(this._dataView,this._byteOffset,M[b]),this._byteOffset+=M.BYTES_PER_ELEMENT}constructor(M){this._data=new Uint8Array(M),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(M){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,M),this._byteOffset++}writeInt8(M){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,M),this._byteOffset++}writeInt16(M){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,M,!0),this._byteOffset+=2}writeUInt16(M){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,M,!0),this._byteOffset+=2}writeInt32(M){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,M,!0),this._byteOffset+=4}writeUInt32(M){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,M,!0),this._byteOffset+=4}writeFloat32(M){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,M,!0),this._byteOffset+=4}writeFloat64(M){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,M,!0),this._byteOffset+=8}_checkGrowBuffer(M){const p=this.byteOffset+M;if(p>this._data.byteLength){const M=new Uint8Array(2*p);M.set(this._data),this._data=M,this._dataView=new DataView(this._data.buffer)}}}function OM(M){return M%4===0?4:M%2===0?2:1}class HM{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(M){let p=0;this._bufferViewToData.forEach((M=>{p+=M.byteLength}));const b=new TM(p),Q=Array.from(this._bufferViewToData.keys()).sort(((M,p)=>OM(p.byteLength)-OM(M.byteLength)));for(const q of Q){q.byteOffset=b.byteOffset,M.push(q);const p=M.length-1,Q=this.getPropertiesWithBufferView(q);for(const M of Q)M.bufferView=p;b.writeTypedArray(this._bufferViewToData.get(q)),this._bufferViewToData.delete(q)}return b.getOutputData()}createBufferView(M,p){const b={buffer:0,byteOffset:void 0,byteLength:M.byteLength,byteStride:p};return this._bufferViewToData.set(b,M),b}createAccessor(M,p,b,Q,q,B,k){this._verifyBufferView(M);const u={bufferView:void 0,componentType:b,count:Q,type:p,min:null===B||void 0===B?void 0:B.min,max:null===B||void 0===B?void 0:B.max,normalized:k,byteOffset:q};return this.setBufferView(u,M),this._accessorToBufferView.set(u,M),u}setBufferView(M,p){this._verifyBufferView(p);this.getPropertiesWithBufferView(p).push(M)}removeBufferView(M){const p=this.getPropertiesWithBufferView(M);for(const b of p)void 0!==b.bufferView&&delete b.bufferView;this._bufferViewToData.delete(M),this._bufferViewToProperties.delete(M),this._accessorToBufferView.forEach(((p,b)=>{p===M&&(void 0!==b.byteOffset&&delete b.byteOffset,this._accessorToBufferView.delete(b))}))}getBufferView(M){const p=this._accessorToBufferView.get(M);return this._verifyBufferView(p),p}getPropertiesWithBufferView(M){return this._verifyBufferView(M),this._bufferViewToProperties.set(M,this._bufferViewToProperties.get(M)??[]),this._bufferViewToProperties.get(M)}getData(M){return this._verifyBufferView(M),this._bufferViewToData.get(M)}_verifyBufferView(M){if(void 0===M||!this._bufferViewToData.has(M))throw new Error(`BufferView ${M} not found in BufferManager.`)}}var FM,oM=b(12262),WM=b(12277),iM=b(12305),AM=b(12175),jM=b(12342),KM=b(12347),DM=b(12257),aM=b(12349);!function(M){M[M.INTANGENT=0]="INTANGENT",M[M.OUTTANGENT=1]="OUTTANGENT"}(FM||(FM={}));class sM{static _IsTransformable(M){return M&&(M instanceof F.c||M instanceof oM.b||M instanceof aM.e)}static _CreateNodeAnimation(M,p,b,Q,B){if(this._IsTransformable(M)){const k=[],u=[],T=p.getKeys(),O=sM._CalculateMinMaxKeyFrames(T),H=sM._DeduceInterpolation(T,b,Q),F=H.interpolationType,o=H.shouldBakeAnimation;if(o?sM._CreateBakedAnimation(M,p,b,O.min,O.max,p.framePerSecond,B,k,u,O,Q):"LINEAR"===F||"STEP"===F?sM._CreateLinearOrStepAnimation(M,p,b,k,u,Q):"CUBICSPLINE"===F?sM._CreateCubicSplineAnimation(M,p,b,k,u,Q):sM._CreateBakedAnimation(M,p,b,O.min,O.max,p.framePerSecond,B,k,u,O,Q),k.length&&u.length){return{inputs:k,outputs:u,samplerInterpolation:F,inputsMin:o?O.min:q.Tools.FloatRound(O.min/p.framePerSecond),inputsMax:o?O.max:q.Tools.FloatRound(O.max/p.framePerSecond)}}}return null}static _DeduceAnimationInfo(M){let p=null,b="VEC3",Q=!1;const B=M.targetProperty.split(".");switch(B[0]){case"ab":p="scale";break;case"position":p="translation";break;case"rotation":b="VEC4",p="rotation";break;case"rotationQuaternion":b="VEC4",Q=!0,p="rotation";break;case"influence":b="SCALAR",p="weights";break;default:q.Tools.Error(`Unsupported animatable property ${B[0]}`)}return p?{animationChannelTargetPath:p,dataAccessorType:b,useQuaternion:Q}:(q.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(M,p,b,Q,q,B,k,u,T,O,H){let F;if(sM._IsTransformable(M)&&M.animations)for(const o of M.animations){if(H&&!H(o))continue;const q=sM._DeduceAnimationInfo(o);q&&(F={name:o.name,samplers:[],channels:[]},sM._AddAnimation(`${o.name}`,o.hasRunningRuntimeAnimations?p:F,M,o,q.dataAccessorType,q.animationChannelTargetPath,Q,B,k,u,q.useQuaternion,T,O),F.samplers.length&&F.channels.length&&b.push(F))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(M,p,b,Q,q,B,k,u,T,O,H){let F;if(M instanceof DM.d){const q=M.morphTargetManager;if(q)for(let o=0;o<q.numTargets;++o){const W=q.getTarget(o);for(const i of W.animations){if(H&&!H(i))continue;const W=new jM.c(`${i.name}`,"influence",i.framePerSecond,i.dataType,i.loopMode,i.enableBlending),A=[],j=i.getKeys();for(let M=0;M<j.length;++M){const p=j[M];for(let M=0;M<q.numTargets;++M)M==o?A.push(p):A.push({frame:p.frame,value:0})}W.setKeys(A);const K=sM._DeduceAnimationInfo(W);K&&(F={name:W.name,samplers:[],channels:[]},sM._AddAnimation(i.name,i.hasRunningRuntimeAnimations?p:F,M,W,K.dataAccessorType,K.animationChannelTargetPath,Q,B,k,u,K.useQuaternion,T,O,q.numTargets),F.samplers.length&&F.channels.length&&b.push(F))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(M,p,b,Q,q,B,k,u,T){let O;if(M.animationGroups){const F=M.animationGroups;for(const o of F){const F=new Map,W=new Map,i=new Set,A=o.to-o.from;O={name:o.name,channels:[],samplers:[]};for(let p=0;p<o.targetedAnimations.length;++p){const A=o.targetedAnimations[p],j=A.target,K=A.animation;if(T&&!T(K))continue;const D=u.has(j);if(this._IsTransformable(j)||1===j.length&&this._IsTransformable(j[0])){const M=sM._DeduceAnimationInfo(A.animation);if(M){const p=this._IsTransformable(j)?j:this._IsTransformable(j[0])?j[0]:null;p&&sM._AddAnimation(`${K.name}`,O,p,K,M.dataAccessorType,M.animationChannelTargetPath,b,Q,q,B,M.useQuaternion,k,D)}}else if(j instanceof KM.e||1===j.length&&j[0]instanceof KM.e){if(sM._DeduceAnimationInfo(A.animation)){const p=j instanceof KM.e?j:j[0];if(p){const b=M.morphTargetManagers.find((M=>{for(let b=0;b<M.numTargets;++b)if(M.getTarget(b)===p)return!0;return!1}));if(b){const Q=M.meshes.find((M=>M.morphTargetManager===b));var H;if(Q)F.has(Q)||F.set(Q,new Map),null===(H=F.get(Q))||void 0===H||H.set(p,K),i.add(Q),W.set(Q,K)}}}}}i.forEach((M=>{const p=M.morphTargetManager;let u=null;const T=[],H=W.get(M).getKeys(),i=H.length;for(let b=0;b<i;++b)for(let Q=0;Q<p.numTargets;++Q){const q=p.getTarget(Q),B=F.get(M);if(B){const p=B.get(q);p?(u||(u=new jM.c(`${o.name}_${M.name}_MorphWeightAnimation`,"influence",p.framePerSecond,jM.c.ANIMATIONTYPE_FLOAT,p.loopMode,p.enableBlending)),T.push(p.getKeys()[b])):T.push({frame:o.from+A/i*b,value:q.influence,inTangent:H[0].inTangent?0:void 0,outTangent:H[0].outTangent?0:void 0})}}u.setKeys(T);const j=sM._DeduceAnimationInfo(u);j&&sM._AddAnimation(`${o.name}_${M.name}_MorphWeightAnimation`,O,M,u,j.dataAccessorType,j.animationChannelTargetPath,b,Q,q,B,j.useQuaternion,k,!1,null===p||void 0===p?void 0:p.numTargets)})),O.channels.length&&O.samplers.length&&p.push(O)}}}static _AddAnimation(M,p,b,q,B,k,u,T,O,H,F,o,W,i){const A=sM._CreateNodeAnimation(b,q,k,F,o);let j,K,D,a,s,S;if(A){if(i){let M=0,p=0;const b=[];for(;A.inputs.length>0;)p=A.inputs.shift(),M%i==0&&b.push(p),M++;A.inputs=b}const M=u.get(b),q=new Float32Array(A.inputs);j=T.createBufferView(q),K=T.createAccessor(j,"SCALAR",5126,A.inputs.length,void 0,{min:[A.inputsMin],max:[A.inputsMax]}),H.push(K),D=H.length-1;const O=new Q.Quaternion,F=new Q.Ap,o=new Q.Ap,f=b instanceof oM.b,R=t(B),y=new Float32Array(A.outputs.length*R);A.outputs.forEach((function(M,p){let b=M;switch(k){case"translation":W&&(Q.Ap.FromArrayToRef(M,0,o),C(o),o.toArray(b));break;case"rotation":4===M.length?Q.Quaternion.FromArrayToRef(M,0,O):(b=new Array(4),Q.Ap.FromArrayToRef(M,0,F),Q.Quaternion.FromEulerVectorToRef(F,O)),W&&(X(O),f&&l(O)),O.toArray(b)}y.set(b,p*R)})),j=T.createBufferView(y),K=T.createAccessor(j,B,5126,A.outputs.length),H.push(K),a=H.length-1,s={interpolation:A.samplerInterpolation,input:D,output:a},p.samplers.push(s),S={sampler:p.samplers.length-1,target:{node:M,path:k}},p.channels.push(S)}}static _CreateBakedAnimation(M,p,b,B,k,u,T,O,H,F,o){let W;const i=Q.Quaternion.Identity();let A,j=null,K=null,D=null,a=null,s=null,S=null;F.min=q.Tools.FloatRound(B/u);const f=p.getKeys();for(let Q=0,R=f.length;Q<R;++Q){if(S=null,D=f[Q],Q+1<R)if(a=f[Q+1],D.value.equals&&D.value.equals(a.value)||D.value===a.value){if(0!==Q)continue;S=D.frame}else S=a.frame;else{if(s=f[Q-1],D.value.equals&&D.value.equals(s.value)||D.value===s.value)continue;S=k}if(S)for(let Q=D.frame;Q<=S;Q+=T){if(A=q.Tools.FloatRound(Q/u),A===j)continue;j=A,K=A;const B={key:0,repeatCount:0,loopMode:p.loopMode};W=p._interpolate(Q,B),sM._SetInterpolatedValue(M,W,A,p,b,i,O,H,o)}}K&&(F.max=K)}static _ConvertFactorToVector3OrQuaternion(M,p,b,B,k){const u=sM._GetBasePositionRotationOrScale(p,B,k),T=b.targetProperty.split("."),O=T?T[1]:"",H=k?Q.Quaternion.sp(u).normalize():Q.Ap.sp(u);switch(O){case"x":case"y":case"z":H[O]=M;break;case"w":H.w=M;break;default:q.Tools.Error(`glTFAnimation: Unsupported component name "${O}"!`)}return H}static _SetInterpolatedValue(M,p,b,q,B,k,u,T,O){let H;u.push(b),"weights"!==B?(q.dataType===jM.c.ANIMATIONTYPE_FLOAT&&(p=this._ConvertFactorToVector3OrQuaternion(p,M,q,B,O)),"rotation"===B?(O?k=p:(H=p,Q.Quaternion.RotationYawPitchRollToRef(H.y,H.x,H.z,k)),T.push(k.Ob())):(H=p,T.push(H.Ob()))):T.push([p])}static _CreateLinearOrStepAnimation(M,p,b,Q,q,B){for(const k of p.getKeys())Q.push(k.frame/p.framePerSecond),sM._AddKeyframeValue(k,p,q,b,M,B)}static _CreateCubicSplineAnimation(M,p,b,Q,q,B){p.getKeys().forEach((function(k){Q.push(k.frame/p.framePerSecond),sM._AddSplineTangent(FM.INTANGENT,q,b,"CUBICSPLINE",k,B),sM._AddKeyframeValue(k,p,q,b,M,B),sM._AddSplineTangent(FM.OUTTANGENT,q,b,"CUBICSPLINE",k,B)}))}static _GetBasePositionRotationOrScale(M,p,b){let q;if("rotation"===p)if(b){q=(M.rotationQuaternion??Q.Quaternion.Identity()).Ob()}else{q=(M.rotation??Q.Ap.Zero()).Ob()}else if("translation"===p){q=(M.position??Q.Ap.Zero()).Ob()}else{q=(M.ab??Q.Ap.One()).Ob()}return q}static _AddKeyframeValue(M,p,b,B,k,u){let T;const O=p.dataType;if(O===jM.c.ANIMATIONTYPE_VECTOR3){let p=M.value.Ob();if("rotation"===B){const M=Q.Ap.sp(p);p=Q.Quaternion.RotationYawPitchRoll(M.y,M.x,M.z).Ob()}b.push(p)}else if(O===jM.c.ANIMATIONTYPE_FLOAT){if("weights"===B)b.push([M.value]);else if(T=this._ConvertFactorToVector3OrQuaternion(M.value,k,p,B,u),T){if("rotation"===B){const M=u?T:Q.Quaternion.RotationYawPitchRoll(T.y,T.x,T.z).normalize();b.push(M.Ob())}b.push(T.Ob())}}else O===jM.c.ANIMATIONTYPE_QUATERNION?b.push(M.value.normalize().Ob()):q.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(M,p,b){let Q,q,B=!1;if("rotation"===p&&!b)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let k=0,u=M.length;k<u;++k)if(q=M[k],q.inTangent||q.outTangent)if(Q){if("CUBICSPLINE"!==Q){Q="LINEAR",B=!0;break}}else Q="CUBICSPLINE";else if(Q){if("CUBICSPLINE"===Q||q.interpolation&&1===q.interpolation&&"STEP"!==Q){Q="LINEAR",B=!0;break}}else Q=q.interpolation&&1===q.interpolation?"STEP":"LINEAR";return Q||(Q="LINEAR"),{interpolationType:Q,shouldBakeAnimation:B}}static _AddSplineTangent(M,p,b,q,B,k){let u;const T=M===FM.INTANGENT?B.inTangent:B.outTangent;if("CUBICSPLINE"===q){if("rotation"===b)if(T)if(k)u=T.Ob();else{const M=T;u=Q.Quaternion.RotationYawPitchRoll(M.y,M.x,M.z).Ob()}else u=[0,0,0,0];else u="weights"===b?T?[T]:[0]:T?T.Ob():[0,0,0];p.push(u)}}static _CalculateMinMaxKeyFrames(M){let p=1/0,b=-1/0;return M.forEach((function(M){p=Math.min(p,M.frame),b=Math.max(b,M.frame)})),{min:p,max:b}}}function SM(M,p,b,B,k,u){const T={attributes:{},influence:M.influence,name:M.name},O=p.Ab;if(!O)return q.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),T;const F=u?-1:1,o=Q.Ap.Zero();let W=0,i=0;if(M.hasPositions){const B=M.getPositions(),u=O.getVerticesData(H.f.PositionKind);if(u){const M=new Float32Array(u.length),p=[1/0,1/0,1/0],q=[-1/0,-1/0,-1/0];i=u.length/3,W=0;for(let b=W;b<i;++b){const k=Q.Ap.sp(u,3*b);Q.Ap.sp(B,3*b).subtractToRef(k,o),o.x*=F,p[0]=Math.min(p[0],o.x),q[0]=Math.max(q[0],o.x),p[1]=Math.min(p[1],o.y),q[1]=Math.max(q[1],o.y),p[2]=Math.min(p[2],o.z),q[2]=Math.max(q[2],o.z),M[3*b]=o.x,M[3*b+1]=o.y,M[3*b+2]=o.z}const O=b.createBufferView(M,12),H=b.createAccessor(O,"VEC3",5126,B.length/3,0,{min:p,max:q});k.push(H),T.attributes.POSITION=k.length-1}else q.Tools.Warn(`Morph target positions for mesh ${p.name} were not exported. Mesh does not have position vertex data`)}if(M.hasNormals){const B=M.getNormals(),u=O.getVerticesData(H.f.NormalKind);if(u){const M=new Float32Array(u.length);i=u.length/3,W=0;for(let b=W;b<i;++b){const p=Q.Ap.sp(u,3*b).normalize();Q.Ap.sp(B,3*b).normalize().subtractToRef(p,o),M[3*b]=o.x*F,M[3*b+1]=o.y,M[3*b+2]=o.z}const p=b.createBufferView(M,12),q=b.createAccessor(p,"VEC3",5126,B.length/3,0);k.push(q),T.attributes.NORMAL=k.length-1}else q.Tools.Warn(`Morph target normals for mesh ${p.name} were not exported. Mesh does not have normals vertex data`)}if(M.hasTangents){const B=M.getTangents(),u=O.getVerticesData(H.f.TangentKind);if(u){i=u.length/4;const M=new Float32Array(3*i);W=0;for(let b=W;b<i;++b){const p=Q.Ap.sp(u,4*b);mM(p);const q=Q.Ap.sp(B,3*b);mM(q),q.subtractToRef(p,o),M[3*b]=o.x*F,M[3*b+1]=o.y,M[3*b+2]=o.z}const p=b.createBufferView(M,12),q=b.createAccessor(p,"VEC3",5126,i,0);k.push(q),T.attributes.TANGENT=k.length-1}else q.Tools.Warn(`Morph target tangents for mesh ${p.name} were not exported. Mesh does not have tangents vertex data`)}if(M.hasColors){const B=M.getColors(),u=O.getVerticesData(H.f.ColorKind),F=O.getVertexBuffer(H.f.ColorKind);if(u&&F){const M=F.getSize();i=u.length/M;const p=new Float32Array(i*M);W=0;for(let b=W;b<i;++b)if(3===M){const q=Q.Ap.sp(u,b*M);Q.Ap.sp(B,b*M).subtractToRef(q,o),p[3*b]=o.x,p[3*b+1]=o.y,p[3*b+2]=o.z}else if(4===M){const q=new Q.Vector4,k=Q.Vector4.sp(u,b*M);Q.Vector4.sp(B,b*M).subtractToRef(k,q),p[4*b]=q.x,p[4*b+1]=q.y,p[4*b+2]=q.z,p[4*b+3]=q.w}else q.Tools.Warn(`Unsupported number of components for color attribute: ${M}`);const O=b.createBufferView(p,4*M),H=b.createAccessor(O,3===M?"VEC3":"VEC4",5126,i,0);k.push(H),T.attributes.COLOR_0=k.length-1}else q.Tools.Warn(`Morph target colors for mesh ${p.name} were not exported. Mesh does not have colors vertex data`)}return T}var fM=b(12356),RM=b(12207),yM=b(12186),xM=b(11757);class PM{}PM.DEFAULT_COLOR=j.ap.White(),PM.DEFAULT_WIDTH_ATTENUATED=1,PM.DEFAULT_WIDTH=.1;var LM=b(12001),NM=b(12362);class rM{static ConvertPoints(M,p){if(M.length&&Array.isArray(M)&&"number"===typeof M[0])return[M];if(M.length&&Array.isArray(M[0])&&"number"===typeof M[0][0])return M;if(M.length&&!Array.isArray(M[0])&&M[0]instanceof Q.Ap){const p=[];for(let b=0;b<M.length;b++){const Q=M[b];p.push(Q.x,Q.y,Q.z)}return[p]}if(M.length>0&&Array.isArray(M[0])&&M[0].length>0&&M[0][0]instanceof Q.Ap){const p=[],b=M;for(const M of b)p.push(M.flatMap((M=>[M.x,M.y,M.z])));return p}if(M instanceof Float32Array){if(null!==p&&void 0!==p&&p.floatArrayStride){const b=[],Q=3*p.floatArrayStride;for(let p=0;p<M.length;p+=Q){const q=new Array(Q);for(let b=0;b<Q;b++)q[b]=M[p+b];b.push(q)}return b}return[Array.from(M)]}if(M.length&&M[0]instanceof Float32Array){const p=[];for(const b of M)p.push(Array.from(b));return p}return[]}static OmitZeroLengthPredicate(M,p,b){const Q=[];return p.jp(M).lengthSquared()>0&&Q.push([M,p]),b.jp(p).lengthSquared()>0&&Q.push([p,b]),M.jp(b).lengthSquared()>0&&Q.push([b,M]),0===Q.length?null:Q}static OmitDuplicatesPredicate(M,p,b,Q){const q=[];return rM._SearchInPoints(M,p,Q)||q.push([M,p]),rM._SearchInPoints(p,b,Q)||q.push([p,b]),rM._SearchInPoints(b,M,Q)||q.push([b,M]),0===q.length?null:q}static _SearchInPoints(M,p,b){for(const k of b)for(let b=0;b<k.length;b++){var Q,q,B;if(null!==(Q=k[b])&&void 0!==Q&&Q.equals(M))if(null!==(q=k[b+1])&&void 0!==q&&q.equals(p)||null!==(B=k[b-1])&&void 0!==B&&B.equals(p))return!0}return!1}static MeshesToLines(M,p){const b=[];for(let q=0;q<M.length;q++){const B=M[q],k=B.getVerticesData(H.f.PositionKind),u=B.jb();if(k&&u)for(let M=0,T=0;M<u.length;M++){const O=3*u[T++],H=3*u[T++],F=3*u[T++],o=new Q.Ap(k[O],k[O+1],k[O+2]),W=new Q.Ap(k[H],k[H+1],k[H+2]),i=new Q.Ap(k[F],k[F+1],k[F+2]);if(p){const Q=p(o,W,i,b,M,O,B,q,k,u);if(Q)for(const M of Q)b.push(M)}else b.push([o,W],[W,i],[i,o])}}return b}static ToVector3Array(M){if(Array.isArray(M[0])){const p=[],b=M;for(const M of b){const b=[];for(let p=0;p<M.length;p+=3)b.push(new Q.Ap(M[p],M[p+1],M[p+2]));p.push(b)}return p}const p=M,b=[];for(let q=0;q<p.length;q+=3)b.push(new Q.Ap(p[q],p[q+1],p[q+2]));return b}static ToNumberArray(M){return M.flatMap((M=>[M.x,M.y,M.z]))}static GetPointsCountInfo(M){const p=new Array(M.length);let b=0;for(let Q=M.length;Q--;)p[Q]=M[Q].length/3,b+=p[Q];return{total:b,counts:p}}static GetLineLength(M){if(0===M.length)return 0;let p;p="number"===typeof M[0]?rM.ToVector3Array(M):M;const b=Q.TmpVectors.Ap[0];let q=0;for(let Q=0;Q<p.length-1;Q++){const M=p[Q];q+=p[Q+1].subtractToRef(M,b).length()}return q}static GetLineLengthArray(M){const p=new Float32Array(M.length/3);let b=0;for(let Q=0,q=M.length/3-1;Q<q;Q++){let q=M[3*Q+0],B=M[3*Q+1],k=M[3*Q+2];q-=M[3*Q+3],B-=M[3*Q+4],k-=M[3*Q+5];b+=Math.sqrt(q*q+B*B+k*k),p[Q+1]=b}return p}static SegmentizeSegmentByCount(M,p,b){const q=[],B=p.jp(M),k=Q.TmpVectors.Ap[0];k.sb(b);const u=Q.TmpVectors.Ap[1];B.divideToRef(k,u);let T=M.clone();q.push(T);for(let Q=0;Q<b;Q++)T=T.clone(),q.push(T.addInPlace(u));return q}static SegmentizeLineBySegmentLength(M,p){const b=M[0]instanceof Q.Ap?rM.GetLineSegments(M):"number"===typeof M[0]?rM.GetLineSegments(rM.ToVector3Array(M)):M,q=[];for(const Q of b)if(Q.length>p){const M=rM.SegmentizeSegmentByCount(Q.point1,Q.point2,Math.ceil(Q.length/p));for(const p of M)q.push(p)}else q.push(Q.point1),q.push(Q.point2);return q}static SegmentizeLineBySegmentCount(M,p){const b="number"===typeof M[0]?rM.ToVector3Array(M):M,Q=rM.GetLineLength(b)/p;return rM.SegmentizeLineBySegmentLength(b,Q)}static GetLineSegments(M){const p=[];for(let b=0;b<M.length-1;b++){const Q=M[b],q=M[b+1],B=q.jp(Q).length();p.push({point1:Q,point2:q,length:B})}return p}static GetMinMaxSegmentLength(M){const p=rM.GetLineSegments(M).sort((M=>M.length));return{min:p[0].length,max:p[p.length-1].length}}static GetPositionOnLineByVisibility(M,p,b){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const B=p*b;let k=0,u=0;const T=M.length;for(let Q=0;Q<T;Q++){if(B<=k+M[Q].length){u=Q;break}k+=M[Q].length}const O=(B-k)/M[u].length;return M[u].point2.subtractToRef(M[u].point1,Q.TmpVectors.Ap[0]),Q.TmpVectors.Ap[1]=Q.TmpVectors.Ap[0].multiplyByFloats(O,O,O),q||Q.TmpVectors.Ap[1].addInPlace(M[u].point1),Q.TmpVectors.Ap[1].clone()}static GetCircleLinePoints(M,p){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:M,B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/p;const k=[];for(let u=0;u<=p;u++)k.push(new Q.Ap(Math.cos(u*B)*M,Math.sin(u*B)*q,b));return k}static GetBezierLinePoints(M,p,b,Q){return LM.d.CreateQuadraticBezier(M,p,b,Q).getPoints().flatMap((M=>[M.x,M.y,M.z]))}static GetArrowCap(M,p,b,Q,q){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,k=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[M.clone(),M.add(p.multiplyByFloats(b,b,b))],widths:[Q,q,B,k]}}static GetPointsFromText(M,p,b,Q){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const k=[],u=(0,NM.d)(M,p,b,Q);for(const T of u){for(const M of T.paths){const p=[],b=M.getPoints();for(const M of b)p.push(M.x,M.y,q);k.push(p)}if(B)for(const M of T.holes){const p=[],b=M.getPoints();for(const M of b)p.push(M.x,M.y,q);k.push(p)}}return k}static Color3toRGBAUint8(M){const p=new Uint8Array(4*M.length);for(let b=0,Q=0;b<M.length;b++)p[Q++]=255*M[b].r,p[Q++]=255*M[b].g,p[Q++]=255*M[b].b,p[Q++]=255;return p}static CreateColorsTexture(M,p,b,Q){const q=Q.getEngine().getCaps().maxTextureSize??1,B=p.length>q?q:p.length,k=Math.ceil(p.length/q);k>1&&(p=[...p,...Array(B*k-p.length).fill(p[0])]);const u=rM.Color3toRGBAUint8(p),T=new f.e(u,B,k,i.e.TEXTUREFORMAT_RGBA,Q,!1,!0,b);return T.name=M,T}static PrepareEmptyColorsTexture(M){if(!PM.EmptyColorsTexture){const p=new Uint8Array(4);PM.EmptyColorsTexture=new f.e(p,1,1,i.e.TEXTUREFORMAT_RGBA,M,!1,!1,f.e.NEAREST_NEAREST),PM.EmptyColorsTexture.name="grlEmptyColorsTexture"}return PM.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var M;null===(M=PM.EmptyColorsTexture)||void 0===M||M.dispose(),PM.EmptyColorsTexture=null}static BooleanToNumber(M){return M?1:0}}class YM extends yM.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class wM extends RM.c{isCompatible(M){return!0}constructor(M,p,b){var q;b=b||{color:PM.DEFAULT_COLOR};const B=new YM;B.GREASED_LINE_HAS_COLOR=!!b.color&&!b.useColors,B.GREASED_LINE_SIZE_ATTENUATION=b.sizeAttenuation??!1,B.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===b.colorDistributionType,B.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(p??M.RM()).useRightHandedSystem,B.GREASED_LINE_CAMERA_FACING=b.cameraFacing??!0,super(M,wM.GREASED_LINE_MATERIAL_NAME,200,B,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(q=b)||void 0===q?void 0:q.forceGLSL)||wM.ForceGLSL,this._scene=p??M.RM(),this._engine=this._scene.getEngine(),this._cameraFacing=b.cameraFacing??!0,this.visibility=b.visibility??1,this.useDash=b.useDash??!1,this.dashRatio=b.dashRatio??.5,this.dashOffset=b.dashOffset??0,this.width=b.width?b.width:b.sizeAttenuation?PM.DEFAULT_WIDTH_ATTENUATED:PM.DEFAULT_WIDTH,this._sizeAttenuation=b.sizeAttenuation??!1,this.colorMode=b.colorMode??0,this._color=b.color??null,this.useColors=b.useColors??!1,this._colorsDistributionType=b.colorDistributionType??0,this.colorsSampling=b.colorsSampling??f.e.NEAREST_NEAREST,this._colors=b.LM??null,this.dashCount=b.dashCount??1,this.resolution=b.resolution??new Q.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),b.colorsTexture?this.colorsTexture=b.colorsTexture:this._colors?this.colorsTexture=rM.CreateColorsTexture(`${M.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??PM.DEFAULT_COLOR,rM.PrepareEmptyColorsTexture(this._scene)),this._engine.bb.add((()=>{rM.DisposeEmptyColorsTexture()}))}getAttributes(M){M.push("grl_offsets"),M.push("grl_widths"),M.push("grl_colorPointers"),M.push("grl_counters"),this._cameraFacing?(M.push("grl_previousAndSide"),M.push("grl_nextAndCounters")):M.push("grl_slopes")}getSamplers(M){M.push("grl_colors")}getActiveTextures(M){this.colorsTexture&&M.push(this.colorsTexture)}getUniforms(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const p=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&p.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===M&&p.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:p,vertex:this._cameraFacing&&this._isGLSL(M)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(M)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(M){if(this._cameraFacing){M.ob("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||M.ob("viewProjection",this._scene.getTransformMatrix());const p=Q.TmpVectors.Vector4[0];p.x=this._aspect,p.y=this._resolution.x,p.z=this._resolution.y,p.w=this.width,M.updateVector4("grl_aspect_resolution_lineWidth",p)}const p=Q.TmpVectors.Vector4[0];p.x=rM.BooleanToNumber(this.useDash),p.y=this._dashArray,p.z=this.dashOffset,p.w=this.dashRatio,M.updateVector4("grl_dashOptions",p);const b=Q.TmpVectors.Vector4[1];b.x=this.colorMode,b.y=this.visibility,b.z=this.colorsTexture?this.colorsTexture.getSize().width:0,b.w=rM.BooleanToNumber(this.useColors),M.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",b),this._color&&M.updateColor3("grl_singleColor",this._color);const q=this.colorsTexture??PM.EmptyColorsTexture;M.setTexture("grl_colors",q),M.updateFloat2("grl_textureSize",(null===q||void 0===q?void 0:q.getSize().width)??1,(null===q||void 0===q?void 0:q.getSize().height)??1)}prepareDefines(M,p,b){M.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,M.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,M.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,M.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=p.useRightHandedSystem,M.GREASED_LINE_CAMERA_FACING=this._cameraFacing,M.GREASED_LINE_USE_OFFSETS=!!b.offsets}getClassName(){return wM.GREASED_LINE_MATERIAL_NAME}getCustomCode(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(p)?function(M,p){if("vertex"===M){const M={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return p&&(M["!gl_Position\\=viewProjection\\*worldPos;"]="//"),M}return"fragment"===M?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(M,this._cameraFacing):function(M,p){if("vertex"===M){const M={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return p&&(M["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),M}return"fragment"===M?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(M,this._cameraFacing)}dispose(){var M;null===(M=this.colorsTexture)||void 0===M||M.dispose(),super.dispose()}get LM(){return this._colors}set LM(M){this.setColors(M)}setColors(M){var p;let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const q=(null===(p=this._colors)||void 0===p?void 0:p.length)??0;var B;if(this._colors=M,null!==M&&0!==M.length){if(!b||Q)if(this.colorsTexture&&q===M.length&&!Q){const p=rM.Color3toRGBAUint8(M);this.colorsTexture.update(p)}else{var k;null===(k=this.colorsTexture)||void 0===k||k.dispose(),this.colorsTexture=rM.CreateColorsTexture(`${this._material.name}-colors-texture`,M,this.colorsSampling,this._scene)}}else null===(B=this.colorsTexture)||void 0===B||B.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(M){this._dashCount=M,this._dashArray=1/M}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(M){this._sizeAttenuation=M,this.markAllDefinesAsDirty()}get color(){return this._color}set color(M){this.setColor(M)}setColor(M){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==M||null!==this._color&&null===M?(this._color=M,p||this.markAllDefinesAsDirty()):this._color=M}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(M){this._colorsDistributionType=M,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(M){this._aspect=M.x/M.y,this._resolution=M}serialize(){const M=super.serialize(),p={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(p.LM=this._colors),this._color&&(p.color=this._color),M.greasedLineMaterialOptions=p,M}parse(M,p,b){var Q;super.parse(M,p,b);const q=M.greasedLineMaterialOptions;null===(Q=this.colorsTexture)||void 0===Q||Q.dispose(),q.color&&this.setColor(q.color,!0),q.colorDistributionType&&(this.colorsDistributionType=q.colorDistributionType),q.LM&&(this.LM=q.LM),q.colorsSampling&&(this.colorsSampling=q.colorsSampling),q.colorMode&&(this.colorMode=q.colorMode),q.useColors&&(this.useColors=q.useColors),q.visibility&&(this.visibility=q.visibility),q.useDash&&(this.useDash=q.useDash),q.dashCount&&(this.dashCount=q.dashCount),q.dashRatio&&(this.dashRatio=q.dashRatio),q.dashOffset&&(this.dashOffset=q.dashOffset),q.width&&(this.width=q.width),q.sizeAttenuation&&(this.sizeAttenuation=q.sizeAttenuation),q.resolution&&(this.resolution=q.resolution),this.LM?this.colorsTexture=rM.CreateColorsTexture(`${this._material.name}-colors-texture`,this.LM,this.colorsSampling,p):rM.PrepareEmptyColorsTexture(p),this.markAllDefinesAsDirty()}copyTo(M){var p;const b=M;null===(p=b.colorsTexture)||void 0===p||p.dispose(),this._colors&&(b.colorsTexture=rM.CreateColorsTexture(`${b._material.name}-colors-texture`,this._colors,b.colorsSampling,this._scene)),b.setColor(this.color,!0),b.colorsDistributionType=this.colorsDistributionType,b.colorsSampling=this.colorsSampling,b.colorMode=this.colorMode,b.useColors=this.useColors,b.visibility=this.visibility,b.useDash=this.useDash,b.dashCount=this.dashCount,b.dashRatio=this.dashRatio,b.dashOffset=this.dashOffset,b.width=this.width,b.sizeAttenuation=this.sizeAttenuation,b.resolution=this.resolution,b.markAllDefinesAsDirty()}_isGLSL(M){return 0===M||this._forceGLSL}}wM.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",wM.ForceGLSL=!1,(0,xM.g)(`BABYLON.${wM.GREASED_LINE_MATERIAL_NAME}`,wM);var EM=b(12246),nM=b(11641),gM=b(12031),UM=b(11736);class cM extends gM.ShaderMaterial{constructor(M,p,q){const B=p.getEngine(),k=B.isWebGPU&&!(q.forceGLSL||cM.ForceGLSL),u=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];p.useRightHandedSystem&&u.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const T=["position","grl_widths","grl_offsets","grl_colorPointers"];q.cameraFacing?(u.push("GREASED_LINE_CAMERA_FACING"),T.push("grl_previousAndSide","grl_nextAndCounters")):(T.push("grl_slopes"),T.push("grl_counters"));const O=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(k||O.push("world","viewProjection","view","projection"),super(M,p,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:k?["Scene","Mesh"]:void 0,attributes:T,uniforms:O,samplers:k?[]:["grlColors"],defines:u,extraInitializationsAsync:async()=>{k?await Promise.all([b.e(66).then(b.bind(b,14888)),b.e(75).then(b.bind(b,14894))]):await Promise.all([b.e(69).then(b.bind(b,14897)),b.e(76).then(b.bind(b,14902))])},shaderLanguage:k?1:0}),this._color=j.ap.White(),this._colorsDistributionType=0,this._colorsTexture=null,q=q||{color:PM.DEFAULT_COLOR},this.visibility=q.visibility??1,this.useDash=q.useDash??!1,this.dashRatio=q.dashRatio??.5,this.dashOffset=q.dashOffset??0,this.dashCount=q.dashCount??1,this.width=q.width?q.width:q.sizeAttenuation&&q.cameraFacing?PM.DEFAULT_WIDTH_ATTENUATED:PM.DEFAULT_WIDTH,this.sizeAttenuation=q.sizeAttenuation??!1,this.color=q.color??j.ap.White(),this.useColors=q.useColors??!1,this.colorsDistributionType=q.colorDistributionType??0,this.colorsSampling=q.colorsSampling??f.e.NEAREST_NEAREST,this.colorMode=q.colorMode??0,this._colors=q.LM??null,this._cameraFacing=q.cameraFacing??!0,this.resolution=q.resolution??new Q.Vector2(B.getRenderWidth(),B.getRenderHeight()),q.colorsTexture?this.colorsTexture=q.colorsTexture:this._colors?this.colorsTexture=rM.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,p):(this._color=this._color??PM.DEFAULT_COLOR,this.colorsTexture=rM.PrepareEmptyColorsTexture(p)),k){const M=new UM.d;M.setParameters(),M.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",M)}B.bb.add((()=>{rM.DisposeEmptyColorsTexture()}))}dispose(){var M;null===(M=this._colorsTexture)||void 0===M||M.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new Q.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get LM(){return this._colors}set LM(M){this.setColors(M)}setColors(M){var p;let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const q=(null===(p=this._colors)||void 0===p?void 0:p.length)??0;var B;if(this._colors=M,null!==M&&0!==M.length){if(!b||Q)if(this._colorsTexture&&q===M.length&&!Q){const p=rM.Color3toRGBAUint8(M);this._colorsTexture.update(p)}else{var k;null===(k=this._colorsTexture)||void 0===k||k.dispose(),this.colorsTexture=rM.CreateColorsTexture(`${this.name}-colors-texture`,M,this.colorsSampling,this.RM())}}else null===(B=this._colorsTexture)||void 0===B||B.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(M){this._colorsTexture=M,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(M){this._width=M,this.setFloat("grlWidth",M)}get useColors(){return this._useColors}set useColors(M){this._useColors=M,this.setFloat("grlUseColors",rM.BooleanToNumber(M))}get colorsSampling(){return this._colorsSampling}set colorsSampling(M){this._colorsSampling=M}get visibility(){return this._visibility}set visibility(M){this._visibility=M,this.setFloat("grlVisibility",M)}get useDash(){return this._useDash}set useDash(M){this._useDash=M,this.setFloat("grlUseDash",rM.BooleanToNumber(M))}get dashOffset(){return this._dashOffset}set dashOffset(M){this._dashOffset=M,this.setFloat("grlDashOffset",M)}get dashRatio(){return this._dashRatio}set dashRatio(M){this._dashRatio=M,this.setFloat("grlDashRatio",M)}get dashCount(){return this._dashCount}set dashCount(M){this._dashCount=M,this._dashArray=1/M,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(M){this._sizeAttenuation=M,this.setFloat("grlSizeAttenuation",rM.BooleanToNumber(M))}get color(){return this._color}set color(M){this.setColor(M)}setColor(M){M=M??PM.DEFAULT_COLOR,this._color=M,this.setColor3("grlColor",M)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(M){this._colorsDistributionType=M,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(M){this._colorMode=M,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(M){this._resolution=M,this.setVector2("grlResolution",M),this.setFloat("grlAspect",M.x/M.y)}serialize(){const M=super.serialize(),p={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(p.LM=this._colors),M.greasedLineMaterialOptions=p,M}parse(M,p,b){var Q;const q=M.greasedLineMaterialOptions;null===(Q=this._colorsTexture)||void 0===Q||Q.dispose(),q.color&&(this.color=q.color),q.colorDistributionType&&(this.colorsDistributionType=q.colorDistributionType),q.colorsSampling&&(this.colorsSampling=q.colorsSampling),q.colorMode&&(this.colorMode=q.colorMode),q.useColors&&(this.useColors=q.useColors),q.visibility&&(this.visibility=q.visibility),q.useDash&&(this.useDash=q.useDash),q.dashCount&&(this.dashCount=q.dashCount),q.dashRatio&&(this.dashRatio=q.dashRatio),q.dashOffset&&(this.dashOffset=q.dashOffset),q.width&&(this.width=q.width),q.sizeAttenuation&&(this.sizeAttenuation=q.sizeAttenuation),q.resolution&&(this.resolution=q.resolution),q.LM?this.colorsTexture=rM.CreateColorsTexture(`${this.name}-colors-texture`,q.LM,this.colorsSampling,this.RM()):this.colorsTexture=rM.PrepareEmptyColorsTexture(p),this._cameraFacing=q.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var dM,VM,hM;cM.ForceGLSL=!1,function(M){M[M.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",M[M.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(dM||(dM={})),function(M){M[M.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",M[M.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",M[M.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(VM||(VM={})),function(M){M[M.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",M[M.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",M[M.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",M[M.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",M[M.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(hM||(hM={}));class IM extends DM.d{constructor(M,p,b){super(M,p,null,null,!1,!1),this.name=M,this._options=b,this._lazy=!1,this._updatable=!1,this._engine=p.getEngine(),this._lazy=b.lazy??!1,this._updatable=b.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=b.colorPointers??[],this._widths=b.widths??new Array(b.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(M){let p=0;for(const Q of this._points)p+=Q.length;const b=p/3*2-this._widths.length;for(let Q=0;Q<b;Q++)this._widths.push(M)}updateLazy(){var M,p;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(M=this._options.ribbonOptions)||void 0===M?void 0:M.smoothShading),!this.wM&&this.refreshBoundingInfo(),null===(p=this.greasedLineMaterial)||void 0===p||p.updateLazy()}addPoints(M,p){for(const b of M)this._points.push(b);this._lazy||this.setPoints(this._points,p)}dispose(M){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(M,p)}isLazy(){return this._lazy}get NM(){return this._uvs}set NM(M){this._uvs=M instanceof Float32Array?M:new Float32Array(M),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(M){this.material instanceof cM&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===M||void 0===M?void 0:M.length)>0),this._offsets=M,this._offsetsBuffer?this._offsetsBuffer.update(M):this._createOffsetsBuffer(M)}get widths(){return this._widths}set widths(M){this._widths=M,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(M)}get colorPointers(){return this._colorPointers}set colorPointers(M){this._colorPointers=M,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(M)}get greasedLineMaterial(){var M,p;if(this.material&&this.material instanceof cM)return this.material;const b=null===(M=this.material)||void 0===M||null===(p=M.pluginManager)||void 0===p?void 0:p.getPlugin(wM.GREASED_LINE_MATERIAL_NAME);return b||void 0}get points(){const M=[];return nM.c.DeepCopy(this._points,M),M}setPoints(M,p){this._points=rM.ConvertPoints(M,(null===p||void 0===p?void 0:p.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==p&&void 0!==p&&p.colorPointers||this._updateColorPointers(),this._setPoints(this._points,p)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,NM:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(M){super.serialize(M),M.type=this.getClassName(),M.lineOptions=this._createLineOptions()}_createVertexBuffers(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=new EM.e;return p.xM=this._vertexPositions,p.indices=this._indices,p.NM=this._uvs,M&&(p.PM=[],EM.e.ComputeNormals(this._vertexPositions,this._indices,p.PM)),p.YM(this,this._options.updatable),p}_createOffsetsBuffer(M){const p=this._scene.getEngine(),b=new H.d(p,M,this._updatable,3);this.setVerticesBuffer(b.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=b}}class ZM{constructor(M,p){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=M,this.wasAddedByNoopNode=p}getIndicesAccessor(M,p,b,Q,q){var B,k,u,T;return null===(B=this._indicesAccessorMap.get(M))||void 0===B||null===(k=B.get(p))||void 0===k||null===(u=k.get(b))||void 0===u||null===(T=u.get(Q))||void 0===T?void 0:T.get(q)}setIndicesAccessor(M,p,b,Q,q,B){let k=this._indicesAccessorMap.get(M);k||(k=new Map,this._indicesAccessorMap.set(M,k));let u=k.get(p);u||(u=new Map,k.set(p,u));let T=u.get(b);T||(T=new Map,u.set(b,T));let O=T.get(Q);O||(O=new Map,T.set(Q,O)),O.set(q,B)}pushExportedNode(M){this._exportedNodes.has(M)||this._exportedNodes.add(M)}getNodesSet(){return this._exportedNodes}getVertexBufferView(M){return this._vertexBufferViewMap.get(M)}setVertexBufferView(M,p){this._vertexBufferViewMap.set(M,p)}setRemappedBufferView(M,p,b){this._remappedBufferView.set(M,new Map),this._remappedBufferView.get(M).set(p,b)}getRemappedBufferView(M,p){var b;return null===(b=this._remappedBufferView.get(M))||void 0===b?void 0:b.get(p)}getVertexAccessor(M,p,b){var Q,q;return null===(Q=this._vertexAccessorMap.get(M))||void 0===Q||null===(q=Q.get(p))||void 0===q?void 0:q.get(b)}setVertexAccessor(M,p,b,Q){let q=this._vertexAccessorMap.get(M);q||(q=new Map,this._vertexAccessorMap.set(M,q));let B=q.get(p);B||(B=new Map,q.set(p,B)),B.set(b,Q)}hasVertexColorAlpha(M){return this._vertexMapColorAlpha.get(M)||!1}setHasVertexColorAlpha(M,p){return this._vertexMapColorAlpha.set(M,p)}getMesh(M){return this._meshMap.get(M)}setMesh(M,p){this._meshMap.set(M,p)}bindMorphDataToMesh(M,p){const b=this._meshMorphTargetMap.get(M)||[];this._meshMorphTargetMap.set(M,b),-1===b.indexOf(p)&&b.push(p)}getMorphTargetsFromMesh(M){return this._meshMorphTargetMap.get(M)}}class JM{_ApplyExtension(M,p,b,Q){if(b>=p.length)return Promise.resolve(M);const q=Q(p[b],M);return q?q.then((async M=>M?await this._ApplyExtension(M,p,b+1,Q):null)):this._ApplyExtension(M,p,b+1,Q)}_ApplyExtensions(M,p){const b=[];for(const Q of JM._ExtensionNames)b.push(this._extensions[Q]);return this._ApplyExtension(M,b,0,p)}_extensionsPreExportTextureAsync(M,p,b){return this._ApplyExtensions(p,((p,Q)=>p.preExportTextureAsync&&p.preExportTextureAsync(M,Q,b)))}_extensionsPostExportNodeAsync(M,p,b,Q,q){return this._ApplyExtensions(p,((p,B)=>p.postExportNodeAsync&&p.postExportNodeAsync(M,B,b,Q,q,this._bufferManager)))}_extensionsPostExportMaterialAsync(M,p,b){return this._ApplyExtensions(p,((p,Q)=>p.postExportMaterialAsync&&p.postExportMaterialAsync(M,Q,b)))}_extensionsPostExportMaterialAdditionalTextures(M,p,b){const Q=[];for(const q of JM._ExtensionNames){const B=this._extensions[q];B.postExportMaterialAdditionalTextures&&Q.push(...B.postExportMaterialAdditionalTextures(M,p,b))}return Q}_extensionsPostExportTextures(M,p,b){for(const Q of JM._ExtensionNames){const q=this._extensions[Q];q.postExportTexture&&q.postExportTexture(M,p,b)}}_extensionsPostExportMeshPrimitive(M){for(const p of JM._ExtensionNames){const b=this._extensions[p];b.postExportMeshPrimitive&&b.postExportMeshPrimitive(M,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const M of JM._ExtensionNames){const p=this._extensions[M];p.preGenerateBinaryAsync&&await p.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(M){for(const p of JM._ExtensionNames){const b=this._extensions[p];b.enabled&&M(b)}}_extensionsOnExporting(){this._forEachExtensions((M=>{var p,b,Q;M.wasUsed&&((p=this._glTF).extensionsUsed||(p.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(M.name)&&this._glTF.extensionsUsed.push(M.name),M.required&&((b=this._glTF).extensionsRequired||(b.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(M.name)&&this._glTF.extensionsRequired.push(M.name)),(Q=this._glTF).extensions||(Q.extensions={}),M.onExporting&&M.onExporting())}))}_loadExtensions(){for(const M of JM._ExtensionNames){const p=JM._ExtensionFactories[M](this);this._extensions[M]=p}}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:A.c.LastCreatedScene,p=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${i.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new U(this),this._extensions={},this._bufferManager=new HM,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!M)throw new Error("No scene available to export");this._babylonScene=M,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:M=>{var p;return null===M||void 0===M||null===(p=M.Bb)||void 0===p?void 0:p.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...p},this._loadExtensions()}dispose(){for(const M in this._extensions){this._extensions[M].dispose()}}get options(){return this._options}static RegisterExtension(M,p){JM.UnregisterExtension(M)&&q.Tools.Warn(`Extension with the name ${M} already exists`),JM._ExtensionFactories[M]=p,JM._ExtensionNames.push(M)}static UnregisterExtension(M){if(!JM._ExtensionFactories[M])return!1;delete JM._ExtensionFactories[M];const p=JM._ExtensionNames.indexOf(M);return-1!==p&&JM._ExtensionNames.splice(p,1),!0}_generateJSON(M,p,b){const Q={byteLength:M};return Q.byteLength&&(this._glTF.buffers=[Q]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Kp=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(Q.uri=p+".bin"),b?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(M){const p=await this._generateBinaryAsync();this._extensionsOnExporting();const b=this._generateJSON(p.byteLength,M,!0),Q=new Blob([p],{type:"application/octet-stream"}),q=M+".gltf",B=M+".bin",k=new O;if(k.files[q]=b,k.files[B]=Q,this._imageData)for(const u in this._imageData)k.files[u]=new Blob([this._imageData[u].data],{type:this._imageData[u].mimeType});return k}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(M){const p=M%4;return 0===p?p:4-p}async generateGLBAsync(M){this._shouldUseGlb=!0;const p=await this._generateBinaryAsync();this._extensionsOnExporting();const b=this._generateJSON(p.byteLength),Q=M+".glb";let q,B=b.length;if("undefined"!==typeof TextEncoder){q=(new TextEncoder).encode(b),B=q.length}const k=this._getPadding(B),u=this._getPadding(p.byteLength),T=28+B+k+p.byteLength+u,H=new TM(T);if(H.writeUInt32(1179937895),H.writeUInt32(2),H.writeUInt32(T),H.writeUInt32(B+k),H.writeUInt32(1313821514),q)H.writeTypedArray(q);else{const M="_".charCodeAt(0);for(let p=0;p<B;++p){const Q=b.charCodeAt(p);Q!=b.codePointAt(p)?H.writeUInt8(M):H.writeUInt8(Q)}}for(let O=0;O<k;++O)H.writeUInt8(32);H.writeUInt32(p.byteLength+u),H.writeUInt32(5130562),H.writeTypedArray(p);for(let O=0;O<u;++O)H.writeUInt8(0);const F=new O;return F.files[Q]=new Blob([H.getOutputData()],{type:"application/octet-stream"}),F}_setNodeTransformation(M,p,b){if(p.getPivotPoint().equalsWithEpsilon(I,h.d)||q.Tools.Warn("Pivot points are not supported in the glTF serializer"),!p.position.equalsWithEpsilon(I,h.d)){const q=Q.TmpVectors.Ap[0].B(p.position);b&&C(q),M.translation=q.Ob()}p.ab.equalsWithEpsilon(J,h.d)||(M.scale=p.ab.Ob());const B=p.rotationQuaternion||Q.Quaternion.FromEulerAngles(p.rotation.x,p.rotation.y,p.rotation.z);B.equalsWithEpsilon(Z,h.d)||(b&&X(B),M.rotation=B.normalize().Ob())}_setCameraTransformation(M,p,b){if(!p.position.equalsWithEpsilon(I,h.d)){const q=Q.TmpVectors.Ap[0].B(p.position);b&&C(q),M.translation=q.Ob()}const q=p.rotationQuaternion||Q.Quaternion.FromEulerAngles(p.rotation.x,p.rotation.y,p.rotation.z);b&&X(q),this._babylonScene.useRightHandedSystem||l(q),q.equalsWithEpsilon(Z,h.d)||(M.rotation=q.Ob())}_listAvailableCameras(){for(const M of this._babylonScene.cameras){const p={type:M.mode===oM.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(M.name&&(p.name=M.name),"perspective"===p.type)p.perspective={aspectRatio:M.getEngine().getAspectRatio(M),yfov:M.fovMode===oM.b.FOVMODE_VERTICAL_FIXED?M.fov:M.fov*M.getEngine().getAspectRatio(M),znear:M.Fb,zfar:M.maxZ};else if("orthographic"===p.type){const b=M.orthoLeft&&M.orthoRight?.5*(M.orthoRight-M.orthoLeft):.5*M.getEngine().getRenderWidth(),Q=M.orthoBottom&&M.orthoTop?.5*(M.orthoTop-M.orthoBottom):.5*M.getEngine().getRenderHeight();p.orthographic={xmag:b,ymag:Q,znear:M.Fb,zfar:M.maxZ}}this._camerasMap.set(M,p)}}_exportAndAssignCameras(){const M=Array.from(this._camerasMap.values());for(const p of M){const M=this._nodesCameraMap.get(p);if(void 0!==M){this._cameras.push(p);for(const p of M)p.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const M of this._babylonScene.skeletons){if(M.bones.length<=0)continue;const p={joints:[]};this._skinMap.set(M,p)}}_exportAndAssignSkeletons(){for(const M of this._babylonScene.skeletons){if(M.bones.length<=0)continue;const p=this._skinMap.get(M);if(void 0==p)continue;const b={},Q=[];let B=-1;for(let q=0;q<M.bones.length;++q){const p=M.bones[q],Q=p.getIndex()??q;-1!==Q&&(b[Q]=p,Q>B&&(B=Q))}for(let M=0;M<=B;++M){const B=b[M];Q.push(B.getAbsoluteInverseBindMatrix());const k=B.getTransformNode();if(null!==k){const M=this._nodeMap.get(k);k&&null!==M&&void 0!==M?p.joints.push(M):q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const k=this._nodesSkinMap.get(p);if(p.joints.length>0&&void 0!==k){const M=64*Q.length,b=new Float32Array(M/4);Q.forEach(((M,p)=>{b.set(M.m,16*p)}));const q=this._bufferManager.createBufferView(b);this._accessors.push(this._bufferManager.createAccessor(q,"MAT4",5126,Q.length)),p.inverseBindMatrices=this._accessors.length-1,this._skins.push(p);for(const p of k)p.skin=this._skins.length-1}}}async _exportSceneAsync(){const M={nodes:[]};if(this._babylonScene.metadata){const p=this._options.metadataSelector(this._babylonScene.metadata);p&&(M.extras=p)}const p=new Array,b=new Array,Q=new Array;for(const u of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&kM(u,this._babylonScene.useRightHandedSystem)?Q.push(...u.getChildren()):this._babylonScene.useRightHandedSystem?p.push(u):b.push(u);this._listAvailableCameras(),this._listAvailableSkeletons();const q=new ZM(!0,!1);M.nodes.push(...await this._exportNodesAsync(b,q));const B=new ZM(!1,!1);M.nodes.push(...await this._exportNodesAsync(p,B));const k=new ZM(!1,!0);M.nodes.push(...await this._exportNodesAsync(Q,k)),M.nodes.length&&this._scenes.push(M),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&sM._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,q.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(M){let p=this._shouldExportNodeMap.get(M);return void 0===p&&(p=this._options.shouldExportNode(M),this._shouldExportNodeMap.set(M,p)),p}async _exportNodesAsync(M,p){const b=new Array;this._exportBuffers(M,p);for(const Q of M)await this._exportNodeAsync(Q,b,p);return b}_collectBuffers(M,p,b,Q,q){if(this._shouldExportNode(M)&&M instanceof o.b&&M.Ab){const B=M.Ab.getVertexBuffers();if(B)for(const Q in B){if(!e(Q))continue;const k=B[Q];q.setHasVertexColorAlpha(k,M.hasVertexAlpha);const u=k._buffer,T=p.get(u)||[];p.set(u,T),-1===T.indexOf(k)&&T.push(k);const O=b.get(k)||[];b.set(k,O),-1===O.indexOf(M)&&O.push(M)}const k=M.morphTargetManager;if(k)for(let p=0;p<k.numTargets;p++){const b=k.getTarget(p),q=Q.get(b)||[];Q.set(b,q),-1===q.indexOf(M)&&q.push(M)}}for(const B of M.getChildren())this._collectBuffers(B,p,b,Q,q)}_exportBuffers(M,p){const b=new Map,Q=new Map,q=new Map;for(const u of M)this._collectBuffers(u,b,Q,q,p);const B=Array.from(b.keys());for(const u of B){const M=u.getData();if(!M)throw new Error("Buffer data is not available");const q=b.get(u);if(!q)continue;const B=q[0].byteStride;if(q.some((M=>M.byteStride!==B)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const k=bM(M).slice();for(const p of q){const M=Q.get(p),{byteOffset:b,byteStride:q,componentCount:B,type:u,count:T,normalized:O,kind:F}=z(p,M);switch(F){case H.f.NormalKind:case H.f.TangentKind:(0,c.g)(k,b,q,B,u,T,O,(M=>{const p=Math.sqrt(M[0]*M[0]+M[1]*M[1]+M[2]*M[2]);if(p>0){const b=1/p;M[0]*=b,M[1]*=b,M[2]*=b}}));break;case H.f.ColorKind:{const p=M.filter((M=>M.material instanceof AM.Dp||null==M.material)).length;if(0==p)break;if(p!=M.length){d.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}u==H.f.UNSIGNED_BYTE&&d.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const Q=new j.ap,F=new j.Sb,o=this._babylonScene.getEngine().useExactSrgbConversions;(0,c.g)(k,b,q,B,u,T,O,(M=>{3===M.length?(Q.oQ(M,0),Q.toLinearSpaceToRef(Q,o),Q.toArray(M,0)):(F.oQ(M,0),F.toLinearSpaceToRef(F,o),F.toArray(M,0))}))}}}if(p.convertToRightHanded){for(const M of q){const p=Q.get(M),{byteOffset:b,byteStride:q,componentCount:B,type:u,count:T,normalized:O,kind:F}=z(M,p);switch(F){case H.f.PositionKind:case H.f.NormalKind:case H.f.TangentKind:(0,c.g)(k,b,q,B,u,T,O,(M=>{M[0]=-M[0]}))}}p.convertedToRightHandedBuffers.set(u,k)}const T=this._bufferManager.createBufferView(k,B);p.setVertexBufferView(u,T);const O=new Map;for(const p of q){const M=Q.get(p),{kind:b,totalVertices:q}=z(p,M);switch(b){case H.f.MatricesIndicesKind:case H.f.MatricesIndicesExtraKind:if(p.type==H.f.FLOAT){const M=p.getFloatData(q);null!==M&&O.set(p,M)}}}0!==O.size&&d.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const F=Array.from(O.keys());for(const b of F){const M=O.get(b);if(!M)continue;const Q=M.some((M=>M>=256)),q=new(Q?Uint16Array:Uint8Array)(M.length);for(let p=0;p<M.length;p++)q[p]=M[p];const B=this._bufferManager.createBufferView(q,4*(Q?2:1));p.setRemappedBufferView(u,b,B)}}const k=Array.from(q.keys());for(const u of k){const M=q.get(u);if(!M)continue;const b=SM(u,M[0],this._bufferManager,this._bufferViews,this._accessors,p.convertToRightHanded);for(const Q of M)p.bindMorphDataToMesh(Q,b)}}async _exportNodeAsync(M,p,b){let Q=this._nodeMap.get(M);if(void 0!==Q)return void(p.includes(Q)||p.push(Q));const q=await this._createNodeAsync(M,b);if(q){Q=this._nodes.length,this._nodes.push(q),this._nodeMap.set(M,Q),b.pushExportedNode(M),p.push(Q);const B={name:"runtime animations",channels:[],samplers:[]},k=[];this._babylonScene.animationGroups.length||(sM._CreateMorphTargetAnimationFromMorphTargetAnimations(M,B,k,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,b.convertToRightHanded,this._options.shouldExportAnimation),M.animations.length&&sM._CreateNodeAnimationFromNodeAnimations(M,B,k,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,b.convertToRightHanded,this._options.shouldExportAnimation)),B.channels.length&&B.samplers.length&&this._animations.push(B),k.forEach((M=>{M.channels.length&&M.samplers.length&&this._animations.push(M)}))}const B=q?[]:p;for(const k of M.getChildren())await this._exportNodeAsync(k,B,b);q&&B.length&&(q.children=B)}async _createNodeAsync(M,p){if(!this._shouldExportNode(M))return null;const b={};if(M.name&&(b.name=M.name),M.metadata){const p=this._options.metadataSelector(M.metadata);p&&(b.extras=p)}if(M instanceof F.c&&(this._setNodeTransformation(b,M,p.convertToRightHanded),M instanceof o.b)){const q=M instanceof W.d?M.sourceMesh:M;if(q.Tb&&q.Tb.length>0&&(b.mesh=await this._exportMeshAsync(q,p)),M.skeleton){const p=this._skinMap.get(M.skeleton);var Q;if(void 0!==p)void 0===this._nodesSkinMap.get(p)&&this._nodesSkinMap.set(p,[]),null===(Q=this._nodesSkinMap.get(p))||void 0===Q||Q.push(b)}}if(M instanceof V.e){const Q=this._camerasMap.get(M);if(Q){var q;void 0===this._nodesCameraMap.get(Q)&&this._nodesCameraMap.set(Q,[]),this._setCameraTransformation(b,M,p.convertToRightHanded);const k=M.parent;if(null!==k&&pM(M,k)){const M=this._nodeMap.get(k);if(void 0!==M){var B;const p=this._nodes[M];return MM(b,p),null===(B=this._nodesCameraMap.get(Q))||void 0===B||B.push(p),null}}null===(q=this._nodesCameraMap.get(Q))||void 0===q||q.push(b)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",b,M,this._nodeMap,p.convertToRightHanded)?b:(d.c.Warn(`Not exporting node ${M.name}`),null)}_exportIndices(M,p,b,Q,q,k,u,T,O){let H=M;O.mode=G(k);const F=u!==B.e.CounterClockWiseSideOrientation,o=!T.wasAddedByNoopNode&&F,W=function(M){switch(M){case B.e.TriangleFillMode:case B.e.TriangleStripDrawMode:case B.e.TriangleFanDrawMode:return!0}return!1}(k)&&o;if(W){if(k===B.e.TriangleStripDrawMode||k===B.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");O.mode=G(k);const u=p?new Uint32Array(Q):new Uint16Array(Q);if(M)for(let p=0;p+2<Q;p+=3)u[p]=M[b+p]+q,u[p+1]=M[b+p+2]+q,u[p+2]=M[b+p+1]+q;else for(let M=0;M+2<Q;M+=3)u[M]=M,u[M+1]=M+2,u[M+2]=M+1;H=u}else if(M&&0!==q){const B=p?new Uint32Array(Q):new Uint16Array(Q);for(let p=0;p<Q;p++)B[p]=M[b+p]+q;H=B}if(H){let B=T.getIndicesAccessor(M,b,Q,q,W);if(void 0===B){const k=function(M,p,b,Q){if(M instanceof Uint16Array||M instanceof Uint32Array)return M;if(M instanceof Int32Array)return new Uint32Array(M.buffer,M.byteOffset,M.length);const q=M.slice(p,p+b);return Q?new Uint32Array(q):new Uint16Array(q)}(H,0,Q,p),u=this._bufferManager.createBufferView(k),O=p?5125:5123;this._accessors.push(this._bufferManager.createAccessor(u,"SCALAR",O,Q,0)),B=this._accessors.length-1,T.setIndicesAccessor(M,b,Q,q,W,B)}O.indices=B}}_exportVertexBuffer(M,p,b,Q,q,B){const k=M.getKind();if(!e(k))return;if(k.startsWith("uv")&&!this._options.exportUnusedUVs&&(!p||!this._materialNeedsUVsSet.has(p)))return;let u=q.getVertexAccessor(M,b,Q);if(void 0===u){const p=q.convertedToRightHandedBuffers.get(M._buffer)||M._buffer.getData(),B=k===H.f.PositionKind?function(M,p,b,Q){const{byteOffset:q,byteStride:B,type:k,normalized:u}=p,T=p.getSize(),O=new Array(T).fill(1/0),H=new Array(T).fill(-1/0);return(0,c.g)(M,q+b*B,B,T,k,Q*T,u,(M=>{for(let p=0;p<T;p++)O[p]=Math.min(O[p],M[p]),H[p]=Math.max(H[p],M[p])})),{min:O,max:H}}(p,M,b,Q):void 0,T=(k===H.f.MatricesIndicesKind||k===H.f.MatricesIndicesExtraKind)&&M.type===H.f.FLOAT,O=T?H.f.UNSIGNED_BYTE:M.type,F=T?void 0:M.normalized,o=T?q.getRemappedBufferView(M._buffer,M):q.getVertexBufferView(M._buffer),W=M.byteOffset+b*M.byteStride;this._accessors.push(this._bufferManager.createAccessor(o,function(M,p){if(M==H.f.ColorKind)return p?"VEC4":"VEC3";switch(M){case H.f.PositionKind:case H.f.NormalKind:return"VEC3";case H.f.TangentKind:case H.f.MatricesIndicesKind:case H.f.MatricesIndicesExtraKind:case H.f.MatricesWeightsKind:case H.f.MatricesWeightsExtraKind:return"VEC4";case H.f.UVKind:case H.f.UV2Kind:case H.f.UV3Kind:case H.f.UV4Kind:case H.f.UV5Kind:case H.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${M}`)}(k,q.hasVertexColorAlpha(M)),O,Q,W,B,F)),u=this._accessors.length-1,q.setVertexAccessor(M,b,Q,u)}B.attributes[function(M){switch(M){case H.f.PositionKind:return"POSITION";case H.f.NormalKind:return"NORMAL";case H.f.TangentKind:return"TANGENT";case H.f.ColorKind:return"COLOR_0";case H.f.UVKind:return"TEXCOORD_0";case H.f.UV2Kind:return"TEXCOORD_1";case H.f.UV3Kind:return"TEXCOORD_2";case H.f.UV4Kind:return"TEXCOORD_3";case H.f.UV5Kind:return"TEXCOORD_4";case H.f.UV6Kind:return"TEXCOORD_5";case H.f.MatricesIndicesKind:return"JOINTS_0";case H.f.MatricesIndicesExtraKind:return"JOINTS_1";case H.f.MatricesWeightsKind:return"WEIGHTS_0";case H.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${M}`)}(k)]=u}async _exportMaterialAsync(M,p,b,Q){let q=this._materialMap.get(M);if(void 0===q){const Q=p&&Object.keys(p).some((M=>M.startsWith("uv")));if((M=M instanceof WM.d?M.fb[b.materialIndex]:M)instanceof iM.d)q=await this._materialExporter.exportPBRMaterialAsync(M,"image/png",Q);else{if(!(M instanceof AM.Dp))return void d.c.Warn(`Unsupported material '${M.name}' with type ${M.getClassName()}`);q=await this._materialExporter.exportStandardMaterialAsync(M,"image/png",Q)}this._materialMap.set(M,q)}Q.material=q}async _exportMeshAsync(M,p){var b;let Q=p.getMesh(M);if(void 0!==Q)return Q;const q={primitives:[]};Q=this._meshes.length,this._meshes.push(q),p.setMesh(M,Q);const k=M.isUnIndexed?null:M.jb(),u=null===(b=M.Ab)||void 0===b?void 0:b.getVertexBuffers(),T=p.getMorphTargetsFromMesh(M),O=M instanceof fM.c,H=M instanceof IM,F=M.Tb;if(u&&F&&F.length>0)for(const i of F){const b={attributes:{}},Q=i.UM()||this._babylonScene.defaultMaterial;if(H){var o,W;const p={name:Q.name},q=M,B=j.ap.White(),k=(null===(o=q.material)||void 0===o?void 0:o.alpha)??1,u=(null===(W=q.greasedLineMaterial)||void 0===W?void 0:W.color)??B;(!u.equalsWithEpsilon(B,h.d)||k<1)&&(p.pbrMetallicRoughness={baseColorFactor:[...u.Ob(),k]}),this._materials.push(p),b.material=this._materials.length-1}else if(O){const p={name:Q.name},q=M;(!q.color.equalsWithEpsilon(j.ap.White(),h.d)||q.alpha<1)&&(p.pbrMetallicRoughness={baseColorFactor:[...q.color.Ob(),q.alpha]}),this._materials.push(p),b.material=this._materials.length-1}else await this._exportMaterialAsync(Q,u,i,b);const F=O||H?B.e.LineListDrawMode:M.overrideRenderingFillMode??Q.fillMode,A=Q._getEffectiveOrientation(M);this._exportIndices(k,k?(0,c.b)(k,i.indexCount,i.indexStart,i.verticesStart):i.verticesCount>65535,k?i.indexStart:i.verticesStart,k?i.indexCount:i.verticesCount,-i.verticesStart,F,A,p,b);for(const M of Object.values(u))this._exportVertexBuffer(M,Q,i.verticesStart,i.verticesCount,p,b);if(T){b.targets=[];for(const M of T)b.targets.push(M.attributes)}q.primitives.push(b),this._extensionsPostExportMeshPrimitive(b)}if(T){q.weights=[],q.extras||(q.extras={}),q.extras.targetNames=[];for(const M of T)q.weights.push(M.influence),q.extras.targetNames.push(M.name)}return Q}}JM._ExtensionNames=new Array,JM._ExtensionFactories={};class vM{static async GLTFAsync(M,p,b){b&&b.exportWithoutWaitingForScene||await M.whenReadyAsync();const Q=new JM(M,b),q=await Q.generateGLTFAsync(p.replace(/\.[^/.]+$/,""));return Q.dispose(),q}static async GLBAsync(M,p,b){b&&b.exportWithoutWaitingForScene||await M.whenReadyAsync();const Q=new JM(M,b),q=await Q.generateGLBAsync(p.replace(/\.[^/.]+$/,""));return Q.dispose(),q}}b(12367);const zM="EXT_mesh_gpu_instancing";class tM{constructor(M){this.name=zM,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(M,p,b,q,B,k){return await new Promise((M=>{if(p&&b instanceof DM.d&&b.hasThinInstances&&this._exporter){this._wasUsed=!0;const M=Q.Ap.Zero(),q=Q.Quaternion.Identity(),u=Q.Ap.One(),T=b.thinInstanceGetWorldMatrices(),O=Q.TmpVectors.Ap[2],H=Q.TmpVectors.Quaternion[1],F=Q.TmpVectors.Ap[3];let o=!1,W=!1,i=!1;const A=new Float32Array(3*b.Rb),j=new Float32Array(4*b.Rb),K=new Float32Array(3*b.Rb);let D=0;for(const p of T)p.decompose(F,H,O),B&&(C(O),X(H)),A.set(O.Ob(),3*D),j.set(H.normalize().Ob(),4*D),K.set(F.Ob(),3*D),o=o||!O.equalsWithEpsilon(M),W=W||!H.equalsWithEpsilon(q),i=i||!F.equalsWithEpsilon(u),D++;const a={attributes:{}};o&&(a.attributes.TRANSLATION=this._buildAccessor(A,"VEC3",b.Rb,k)),W&&(a.attributes.ROTATION=this._buildAccessor(j,"VEC4",b.Rb,k)),i&&(a.attributes.SCALE=this._buildAccessor(K,"VEC3",b.Rb,k)),p.extensions=p.extensions||{},p.extensions[zM]=a}M(p)}))}_buildAccessor(M,p,b,Q){const q=Q.createBufferView(M),B=Q.createAccessor(q,p,5126,b);return this._exporter._accessors.push(B),this._exporter._accessors.length-1}}JM.RegisterExtension(zM,(M=>new tM(M)));var eM=b(12372),GM=b(12386),mp=b(12390),CM=b(12392);function XM(M){return M===mp.b.PositionKind?"POSITION":M===mp.b.NormalKind?"NORMAL":M===mp.b.ColorKind?"COLOR":M.startsWith(mp.b.UVKind)?"TEX_COORD":"GENERIC"}const lM={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Mp extends eM.b{static get DefaultAvailable(){return(0,eM.e)(Mp.DefaultConfiguration)}static get Default(){return Mp._Default??(Mp._Default=new Mp),Mp._Default}static ResetDefault(M){Mp._Default&&(M||Mp._Default.dispose(),Mp._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(M,p){return{module:await(p||DracoEncoderModule)({wasmBinary:M})}}_getWorkerContent(){return`${GM.k}(${GM.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Mp.DefaultConfiguration)}async _encodeAsync(M,p,b){const Q=b?(0,CM.c)(lM,b):lM;if(this._workerPoolPromise){const b=await this._workerPoolPromise;return await new Promise(((q,B)=>{b.push(((b,k)=>{const u=M=>{b.removeEventListener("error",u),b.removeEventListener("message",T),B(M),k()},T=M=>{"encodeMeshDone"===M.data.id&&(b.removeEventListener("error",u),b.removeEventListener("message",T),q(M.data.encodedMeshData),k())};b.addEventListener("error",u),b.addEventListener("message",T);const O=[];for(const p of M)O.push(p.data.buffer);p&&O.push(p.buffer),b.postMessage({id:"encodeMesh",attributes:M,indices:p,options:Q},O)}))}))}if(this._modulePromise){const b=await this._modulePromise;return(0,GM.k)(b.module,M,p,Q)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(M,p){if(0==M.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");M instanceof DM.d&&M.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===p||void 0===p?void 0:p.method)&&(d.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),p.method="MESH_SEQUENTIAL_ENCODING");const b=function(M){let p=M.jb(void 0,!0);return!p||p instanceof Uint32Array||p instanceof Uint16Array||(p=((0,c.b)(p,p.length)?Uint32Array:Uint16Array).from(p)),p}(M),Q=function(M,p){const b=[];for(const Q of M.getVerticesDataKinds()){if(null!==p&&void 0!==p&&p.includes(Q)){if(Q===mp.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const q=M.getVertexBuffer(Q),B=q.getSize(),k=(0,c.m)(q.getData(),B,q.type,q.byteOffset,q.byteStride,q.normalized,M.getTotalVertices(),!0);b.push({kind:Q,dracoName:XM(Q),size:B,data:k})}return b}(M,null===p||void 0===p?void 0:p.excludedAttributes);return await this._encodeAsync(Q,b,p)}}Mp.DefaultConfiguration={wasmUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder.js`},Mp._Default=null;const pp="KHR_draco_mesh_compression";class bp{get wasUsed(){return this._wasUsed}constructor(M){this.name=pp,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===M.options.meshCompressionMethod&&Mp.DefaultAvailable}dispose(){}postExportMeshPrimitive(M,p,b){if(!this.enabled)return;if(4!==M.mode&&5!==M.mode)return void d.c.Warn("Cannot compress primitive with mode "+M.mode+".");const Q=[],q=[];let B=null;if(void 0!==M.indices){const k=b[M.indices],u=p.getBufferView(k);B=p.getData(u).slice(),Q.push(u),q.push(k)}const k=[];for(const[H,F]of Object.entries(M.attributes)){const M=b[F],B=p.getBufferView(M),T=t(M.type),O=(0,c.m)(p.getData(B),T,M.componentType,M.byteOffset||0,B.byteStride||(0,c.j)(M.componentType)*T,M.normalized||!1,M.count,!0);k.push({kind:H,dracoName:(u=H,"POSITION"===u?"POSITION":"NORMAL"===u?"NORMAL":u.startsWith("COLOR")?"COLOR":u.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:t(M.type),data:O}),Q.push(B),q.push(M)}var u;const T={method:M.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},O=Mp.Default._encodeAsync(k,B,T).then((b=>{if(!b)return void d.c.Error("Draco encoding failed for primitive.");const B={bufferView:-1,attributes:b.attributeIds},k=p.createBufferView(b.data);p.setBufferView(B,k);for(const M of Q)this._bufferViewsUsed.add(M);for(const M of q)this._accessorsUsed.add(M);M.extensions||(M.extensions={}),M.extensions[pp]=B})).catch((M=>{d.c.Error("Draco encoding failed for primitive: "+M)}));this._encodePromises.push(O),this._wasUsed=!0}async preGenerateBinaryAsync(M){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((p=>{M.getPropertiesWithBufferView(p).every((M=>this._accessorsUsed.has(M)))&&M.removeBufferView(p)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}JM.RegisterExtension(pp,(M=>new bp(M)));var Qp=b(12397);const qp="KHR_lights_punctual",Bp={name:"",color:[1,1,1],yb:1,range:Number.MAX_VALUE},kp={innerConeAngle:0,outerConeAngle:Math.PI/4},upM=Q.Ap.Backward();class Tp{constructor(M){this.name=qp,this.enabled=!0,this.required=!1,this._exporter=M}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[qp]=this._lights}async postExportNodeAsync(M,p,b,q,B){return await new Promise((k=>{if(!(b instanceof aM.e))return void k(p);const u=b.getTypeID()==aM.e.LIGHTTYPEID_POINTLIGHT?"point":b.getTypeID()==aM.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":b.getTypeID()==aM.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!u||!(b instanceof Qp.c))return d.c.Warn(`${M}: Light ${b.name} is not supported in ${qp}`),void k(p);if(b.falloffType!==aM.e.FALLOFF_GLTF&&d.c.Warn(`${M}: Light falloff for ${b.name} does not match the ${qp} specification!`),!b.position.equalsToFloats(0,0,0)){const M=Q.TmpVectors.Ap[0].B(b.position);B&&C(M),p.translation=M.Ob()}if("point"!==u){const M=b.direction.normalizeToRef(Q.TmpVectors.Ap[0]);B&&C(M);const q=Q.Quaternion.FromUnitVectorsToRef(upM,M,Q.TmpVectors.Quaternion[0]);Q.Quaternion.IsIdentity(q)||(p.rotation=q.Ob())}const T={type:u,name:b.name,color:b.Pb.Ob(),yb:b.yb,range:b.range};if(QM(T,Bp),"spot"===u){const M=b;T.spot={innerConeAngle:M.innerAngle/2,outerConeAngle:M.angle/2},QM(T.spot,kp)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(T);const O={mb:this._lights.lights.length-1},H=b.parent;if(H&&pM(b,H)){const M=q.get(H);if(M){const b=this._exporter._nodes[M];return MM(p,b),b.extensions||(b.extensions={}),b.extensions[qp]=O,void k(null)}}p.extensions||(p.extensions={}),p.extensions[qp]=O,k(p)}))}}JM.RegisterExtension(qp,(M=>new Tp(M)));var Op=b(12324);const Hp="KHR_materials_anisotropy";class Fp{constructor(M){this.name=Hp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,p,b){const Q=[];return b instanceof Op.e&&b.anisotropy.isEnabled&&!b.anisotropy.legacy?(b.anisotropy.texture&&Q.push(b.anisotropy.texture),Q):[]}postExportMaterialAsync(M,p,b){return new Promise((M=>{if(b instanceof Op.e){if(!b.anisotropy.isEnabled||b.anisotropy.legacy)return void M(p);this._wasUsed=!0,p.extensions=p.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(b.anisotropy.texture),q={anisotropyStrength:b.anisotropy.yb,anisotropyRotation:b.anisotropy.angle,anisotropyTexture:Q??void 0};null!==q.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(b),p.extensions[Hp]=q}M(p)}))}}JM.RegisterExtension(Hp,(M=>new Fp(M)));const op="KHR_materials_clearcoat";class Wp{constructor(M){this.name=op,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,p,b){const Q=[];return b instanceof Op.e&&b.clearCoat.isEnabled?(b.clearCoat.texture&&Q.push(b.clearCoat.texture),!b.clearCoat.useRoughnessFromMainTexture&&b.clearCoat.textureRoughness&&Q.push(b.clearCoat.textureRoughness),b.clearCoat.bumpTexture&&Q.push(b.clearCoat.bumpTexture),Q):[]}postExportMaterialAsync(M,p,b){return new Promise((M=>{if(b instanceof Op.e){if(!b.clearCoat.isEnabled)return void M(p);this._wasUsed=!0,p.extensions=p.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(b.clearCoat.texture);let B;B=b.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(b.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(b.clearCoat.textureRoughness),b.clearCoat.isTintEnabled&&q.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${b.name}`),b.clearCoat.remapF0OnInterfaceChange&&q.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${b.name}`);const k=this._exporter._materialExporter.getTextureInfo(b.clearCoat.bumpTexture),u={clearcoatFactor:b.clearCoat.yb,clearcoatTexture:Q??void 0,clearcoatRoughnessFactor:b.clearCoat.roughness,clearcoatRoughnessTexture:B??void 0,clearcoatNormalTexture:k??void 0};null===u.clearcoatTexture&&null===u.clearcoatRoughnessTexture&&null===u.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(b),p.extensions[op]=u}M(p)}))}}JM.RegisterExtension(op,(M=>new Wp(M)));const ip="KHR_materials_diffuse_transmission";function Ap(M,p){const b=p.subSurface;let Q=null;return b.translucencyIntensityTexture?Q=b.translucencyIntensityTexture:b.thicknessTexture&&b.useMaskFromThicknessTexture&&(Q=b.thicknessTexture),Q&&!b.useGltfStyleTextures?(d.c.Warn(`${M}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${p.name}`,1),null):Q}class jp{constructor(M){this.name=ip,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,p,b){const Q=[];if(b instanceof iM.d&&this._isExtensionEnabled(b)){const p=Ap(M,b);return p&&Q.push(p),b.subSurface.translucencyColorTexture&&Q.push(b.subSurface.translucencyColorTexture),Q}return Q}_isExtensionEnabled(M){if(M.unlit)return!1;const p=M.subSurface;return!!p.isTranslucencyEnabled&&(!M.unlit&&!p.useAlbedoToTintTranslucency&&p.useGltfStyleTextures&&1===p.volumeIndexOfRefraction&&0===p.minimumThickness&&0===p.maximumThickness)}postExportMaterialAsync(M,p,b){return new Promise((Q=>{if(b instanceof iM.d&&this._isExtensionEnabled(b)){this._wasUsed=!0;const Q=b.subSurface,q=Ap(M,b),B=0==Q.translucencyIntensity?void 0:Q.translucencyIntensity,k=this._exporter._materialExporter.getTextureInfo(q)??void 0,u=!Q.translucencyColor||Q.translucencyColor.equalsFloats(1,1,1)?void 0:Q.translucencyColor.Ob(),T=this._exporter._materialExporter.getTextureInfo(Q.translucencyColorTexture)??void 0,O={diffuseTransmissionFactor:B,diffuseTransmissionTexture:k,diffuseTransmissionColorFactor:u,diffuseTransmissionColorTexture:T};(k||T)&&this._exporter._materialNeedsUVsSet.add(b),p.extensions=p.extensions||{},p.extensions[ip]=O}Q(p)}))}}JM.RegisterExtension(ip,(M=>new jp(M)));const Kp="KHR_materials_dispersion";class Dp{constructor(){this.name=Kp,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(M){if(M.unlit)return!1;const p=M.subSurface;return!(!p.isRefractionEnabled&&!p.isDispersionEnabled)}postExportMaterialAsync(M,p,b){return new Promise((M=>{if(b instanceof iM.d&&this._isExtensionEnabled(b)){this._wasUsed=!0;const M={dispersion:b.subSurface.dispersion};p.extensions=p.extensions||{},p.extensions[Kp]=M}M(p)}))}}JM.RegisterExtension(Kp,(()=>new Dp));const ap="KHR_materials_emissive_strength";class sp{constructor(){this.name=ap,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(M,p,b){return await new Promise((M=>{if(!(b instanceof iM.d))return M(p);const Q=b.emissiveColor.Ob(),q=Math.max(...Q);if(q>1){this._wasUsed=!0,p.extensions||(p.extensions={});const M={emissiveStrength:q},Q=b.emissiveColor.scale(1/M.emissiveStrength);p.emissiveFactor=Q.Ob(),p.extensions[ap]=M}return M(p)}))}}JM.RegisterExtension(ap,(M=>new sp));const Sp="KHR_materials_ior";class fp{constructor(){this.name=Sp,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(M){return!M.unlit&&(void 0!=M.indexOfRefraction&&1.5!=M.indexOfRefraction)}postExportMaterialAsync(M,p,b){return new Promise((M=>{if(b instanceof iM.d&&this._isExtensionEnabled(b)){this._wasUsed=!0;const M={ior:b.indexOfRefraction};p.extensions=p.extensions||{},p.extensions[Sp]=M}M(p)}))}}JM.RegisterExtension(Sp,(M=>new fp));const Rp="KHR_materials_iridescence";class yp{constructor(M){this.name=Rp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,p,b){const Q=[];return b instanceof Op.e&&b.iridescence.isEnabled?(b.iridescence.texture&&Q.push(b.iridescence.texture),b.iridescence.thicknessTexture&&b.iridescence.thicknessTexture!==b.iridescence.texture&&Q.push(b.iridescence.thicknessTexture),Q):[]}postExportMaterialAsync(M,p,b){return new Promise((M=>{if(b instanceof Op.e){if(!b.iridescence.isEnabled)return void M(p);this._wasUsed=!0,p.extensions=p.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(b.iridescence.texture),q=this._exporter._materialExporter.getTextureInfo(b.iridescence.thicknessTexture),B={iridescenceFactor:b.iridescence.yb,iridescenceIor:b.iridescence.indexOfRefraction,iridescenceThicknessMinimum:b.iridescence.minimumThickness,iridescenceThicknessMaximum:b.iridescence.maximumThickness,iridescenceTexture:Q??void 0,iridescenceThicknessTexture:q??void 0};null===B.iridescenceTexture&&null===B.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(b),p.extensions[Rp]=B}M(p)}))}}JM.RegisterExtension(Rp,(M=>new yp(M)));const xp="KHR_materials_sheen";class Pp{constructor(M){this.name=xp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,p,b){return b instanceof iM.d&&b.sheen.isEnabled&&b.sheen.texture?[b.sheen.texture]:[]}async postExportMaterialAsync(M,p,b){return await new Promise((M=>{if(b instanceof iM.d){if(!b.sheen.isEnabled)return void M(p);this._wasUsed=!0,null==p.extensions&&(p.extensions={});const Q={sheenColorFactor:b.sheen.color.Ob(),sheenRoughnessFactor:b.sheen.roughness??0};null===Q.sheenColorTexture&&null===Q.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(b),b.sheen.texture&&(Q.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.texture)??void 0),b.sheen.textureRoughness&&!b.sheen.useRoughnessFromMainTexture?Q.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.textureRoughness)??void 0:b.sheen.texture&&b.sheen.useRoughnessFromMainTexture&&(Q.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.texture)??void 0),p.extensions[xp]=Q}M(p)}))}}JM.RegisterExtension(xp,(M=>new Pp(M)));const Lp="KHR_materials_specular";class Np{constructor(M){this.name=Lp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,p,b){const Q=[];return b instanceof iM.d&&this._isExtensionEnabled(b)?(b.metallicReflectanceTexture&&Q.push(b.metallicReflectanceTexture),b.reflectanceTexture&&Q.push(b.reflectanceTexture),Q):Q}_isExtensionEnabled(M){return!M.unlit&&(void 0!=M.metallicF0Factor&&1!=M.metallicF0Factor||void 0!=M.metallicReflectanceColor&&!M.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(M))}_hasTexturesExtension(M){return null!=M.metallicReflectanceTexture||null!=M.reflectanceTexture}postExportMaterialAsync(M,p,b){return new Promise((M=>{if(b instanceof iM.d&&this._isExtensionEnabled(b)){this._wasUsed=!0,p.extensions=p.extensions||{};const M=this._exporter._materialExporter.getTextureInfo(b.metallicReflectanceTexture)??void 0,Q=this._exporter._materialExporter.getTextureInfo(b.reflectanceTexture)??void 0,q={specularFactor:1==b.metallicF0Factor?void 0:b.metallicF0Factor,specularTexture:M,specularColorFactor:b.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:b.metallicReflectanceColor.Ob(),specularColorTexture:Q};this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),p.extensions[Lp]=q}M(p)}))}}JM.RegisterExtension(Lp,(M=>new Np(M)));const rp="KHR_materials_transmission";class Yp{constructor(M){this.name=rp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,p,b){const Q=[];return b instanceof iM.d&&this._isExtensionEnabled(b)?(b.subSurface.thicknessTexture&&Q.push(b.subSurface.thicknessTexture),Q):Q}_isExtensionEnabled(M){if(M.unlit)return!1;const p=M.subSurface;return p.isRefractionEnabled&&void 0!=p.refractionIntensity&&0!=p.refractionIntensity||this._hasTexturesExtension(M)}_hasTexturesExtension(M){return null!=M.subSurface.refractionIntensityTexture}async postExportMaterialAsync(M,p,b){if(b instanceof iM.d&&this._isExtensionEnabled(b)){this._wasUsed=!0;const Q=b.subSurface,q={transmissionFactor:0===Q.refractionIntensity?void 0:Q.refractionIntensity};if(this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),Q.refractionIntensityTexture)if(Q.useGltfStyleTextures){const M=await this._exporter._materialExporter.exportTextureAsync(Q.refractionIntensityTexture,"image/png");M&&(q.transmissionTexture=M)}else d.c.Warn(`${M}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);p.extensions||(p.extensions={}),p.extensions[rp]=q}return p}}JM.RegisterExtension(rp,(M=>new Yp(M)));const wp="KHR_materials_unlit";class Ep{constructor(){this.name=wp,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(M,p,b){return new Promise((M=>{let Q=!1;b instanceof iM.d?Q=b.unlit:b instanceof AM.Dp&&(Q=b.disableLighting),Q&&(this._wasUsed=!0,null==p.extensions&&(p.extensions={}),p.extensions[wp]={}),M(p)}))}}JM.RegisterExtension(wp,(()=>new Ep));const np="KHR_materials_volume";class gp{constructor(M){this.name=np,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,p,b){const Q=[];return b instanceof iM.d&&this._isExtensionEnabled(b)?(b.subSurface.thicknessTexture&&Q.push(b.subSurface.thicknessTexture),Q):Q}_isExtensionEnabled(M){if(M.unlit)return!1;const p=M.subSurface;return!(!p.isRefractionEnabled&&!p.isTranslucencyEnabled)&&(void 0!=p.maximumThickness&&0!=p.maximumThickness||void 0!=p.tintColorAtDistance&&p.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=p.tintColor&&p.tintColor!=j.ap.White()||this._hasTexturesExtension(M))}_hasTexturesExtension(M){return null!=M.subSurface.thicknessTexture}postExportMaterialAsync(M,p,b){return new Promise((M=>{if(b instanceof iM.d&&this._isExtensionEnabled(b)){this._wasUsed=!0;const M=b.subSurface,Q={thicknessFactor:0==M.maximumThickness?void 0:M.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(M.thicknessTexture)??void 0,attenuationDistance:M.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:M.tintColorAtDistance,attenuationColor:M.tintColor.equalsFloats(1,1,1)?void 0:M.tintColor.Ob()};this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),p.extensions=p.extensions||{},p.extensions[np]=Q}M(p)}))}}JM.RegisterExtension(np,(M=>new gp(M)));const Up="EXT_materials_diffuse_roughness";class cp{constructor(M){this.name=Up,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,p,b){const Q=[];return b instanceof Op.e&&b._baseDiffuseRoughness?(b._baseDiffuseRoughnessTexture&&Q.push(b._baseDiffuseRoughnessTexture),Q):[]}postExportMaterialAsync(M,p,b){return new Promise((M=>{if(b instanceof Op.e){if(!b._baseDiffuseRoughness)return void M(p);this._wasUsed=!0,p.extensions=p.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(b._baseDiffuseRoughnessTexture),q={diffuseRoughnessFactor:b._baseDiffuseRoughness,diffuseRoughnessTexture:Q??void 0};null!==q.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(b),p.extensions[Up]=q}M(p)}))}}JM.RegisterExtension(Up,(M=>new cp(M)));const dp="KHR_texture_transform";class Vp{constructor(){this.name=dp,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(M,p,b){if(b.RM()||q.Tools.Warn(`${M}: /*@__KEY__*/"scene" is not defined for Babylon texture ${b.name}!`),(0!==b.uAng||0!==b.vAng)&&(q.Tools.Warn(`${M}: Texture ${b.name} with rotation in the u or v axis is not supported in glTF.`),0!==b.uRotationCenter||0!==b.vRotationCenter))return;const Q={};let B=!1;if(0===b.uOffset&&0===b.vOffset||(Q.offset=[b.uOffset,b.vOffset],B=!0),1===b.uScale&&1===b.vScale||(Q.scale=[b.uScale,b.vScale],B=!0),0!==b.wAng){if(0!==b.uRotationCenter||0!==b.vRotationCenter){if(b.homogeneousRotationInUVTransform&&b.uScale!==b.vScale)return void q.Tools.Warn(`${M}: Texture ${b.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${dp}.`);q.Tools.Warn(`${M}: Texture ${b.name} with non-origin rotation center will be exported using an adjusted offset with ${dp}.`),Q.offset=function(M){const{uOffset:p,vOffset:b,uRotationCenter:Q,vRotationCenter:q,uScale:B,vScale:k,wAng:u}=M,T=Math.cos(u),O=Math.sin(u),H=Q*B,F=q*k;return[p+(H*(1-T)+F*O),b+(F*(1-T)-H*O)]}(b)}Q.rotation=-b.wAng,B=!0}0!==b.coordinatesIndex&&(Q.texCoord=b.coordinatesIndex,B=!0),B&&(this._wasUsed=!0,p.extensions||(p.extensions={}),p.extensions[dp]=Q)}}JM.RegisterExtension(dp,(()=>new Vp));class hp{static CreateSTL(M){let p=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],B=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],k=arguments.length>5&&void 0!==arguments[5]&&arguments[5],u=arguments.length>6&&void 0!==arguments[6]&&arguments[6],T=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const O=function(M,p,b){const q=[3*M[b],3*M[b+1],3*M[b+2]],B=[new Q.Ap(p[q[0]],p[q[0]+2],p[q[0]+1]),new Q.Ap(p[q[1]],p[q[1]+2],p[q[1]+1]),new Q.Ap(p[q[2]],p[q[2]+2],p[q[2]+1])],k=B[0].jp(B[1]),u=B[2].jp(B[1]);return{v:B,n:Q.Ap.Cross(u,k).normalize()}},F=function(M,p,b,Q){return p=o(M,p,b.x,Q),p=o(M,p,b.y,Q),o(M,p,b.z,Q)},o=function(M,p,b,Q){return M.setFloat32(p,b,Q),p+4},i=function(M){if(u){let p=M;M instanceof W.d&&(p=M.sourceMesh);const b=p.getVerticesData(H.f.PositionKind,!0,!0);if(!b)return[];const q=Q.Ap.Zero();let B;for(B=0;B<b.length;B+=3)Q.Ap.TransformCoordinatesFromFloatsToRef(b[B],b[B+1],b[B+2],M.ib(!0),q).toArray(b,B);return b}return M.getVerticesData(H.f.PositionKind)||[]};u&&(k=!0);let A="",j=0,K=0;if(q){for(let b=0;b<M.length;b++){const p=M[b].jb();j+=p?p.length/3:0}const p=new ArrayBuffer(84+50*j);A=new DataView(p),K+=80,A.setUint32(K,j,B),K+=4}else T||(A="solid stlmesh\r\n");for(let Q=0;Q<M.length;Q++){const p=M[Q];!q&&T&&(A+="solid "+p.name+"\r\n"),!k&&p instanceof DM.d&&p.bakeCurrentTransformIntoVertices();const b=i(p),u=p.jb()||[];for(let M=0;M<u.length;M+=3){const p=O(u,b,M);q?(K=F(A,K,p.n,B),K=F(A,K,p.v[0],B),K=F(A,K,p.v[1],B),K=F(A,K,p.v[2],B),K+=2):(A+="\tfacet normal "+p.n.x+" "+p.n.y+" "+p.n.z+"\r\n",A+="\t\touter loop\r\n",A+="\t\t\tvertex "+p.v[0].x+" "+p.v[0].y+" "+p.v[0].z+"\r\n",A+="\t\t\tvertex "+p.v[1].x+" "+p.v[1].y+" "+p.v[1].z+"\r\n",A+="\t\t\tvertex "+p.v[2].x+" "+p.v[2].y+" "+p.v[2].z+"\r\n",A+="\t\tendloop\r\n",A+="\tendfacet\r\n")}!q&&T&&(A+="endsolid "+name+"\r\n")}if(q||T||(A+="endsolid stlmesh"),p){const M=document.createElement("a"),p=new Blob([A],{type:"application/octet-stream"});M.href=window.URL.createObjectURL(p),M.download=b+".stl",M.click()}return A}}function Ip(M,p){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const Q=[];for(let q=0;q<M.length/b;q++){const B=M[q*b],k=M[q*b+1],u=M[q*b+2];Q.push(`(${B.toPrecision(p.precision)}, ${k.toPrecision(p.precision)}, ${u.toPrecision(p.precision)})`)}return Q.join(", ")}function Zp(M,p){const b=[];for(let Q=0;Q<M.length/2;Q++){const q=M[2*Q],B=M[2*Q+1];b.push(`(${q.toPrecision(p.precision)}, ${(1-B).toPrecision(p.precision)})`)}return b.join(", ")}function Jp(M,p){const b=M.getVerticesData(H.f.PositionKind),Q=M.getVerticesData(H.f.NormalKind);if(b&&Q)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(M){var p;const b=null!==(p=M.jb())&&void 0!==p&&p.length?M.getTotalIndices():M.getTotalVertices();return Array(b/3).fill(3).join(", ")}(M)}]\n\t\tint[] faceVertexIndices = [${function(M){const p=M.jb(),b=[];if(null!==p)for(let Q=0;Q<p.length;Q++)b.push(p[Q]);else{const p=M.getTotalVertices();for(let M=0;M<p;M++)b.push(M)}return b.join(", ")}(M)}]\n\t\tnormal3f[] normals = [${Ip(Q,p)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Ip(b,p)}]\n        ${function(M,p){let b="";for(let q=0;q<4;q++){const Q=q>0?q:"",B=M.getVerticesData(H.f.UVKind+(Q?Q+1:""));B&&(b+=`\n\t\ttexCoord2f[] primvars:st${Q} = [${Zp(B,p)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const Q=M.getVerticesData(H.f.ColorKind);return Q&&(b+=`\n\tcolor3f[] primvars:displayColor = [${Ip(Q,p,Q.length/M.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),b}(M,p)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function vp(M,p){return`\n        def "Geometry"\n        {\n        ${Jp(M,p)}\n        }\n        `}function zp(M){let p='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return p+=M,fflate.strToU8(p)}function tp(M){const p=M.m;return`( ${ep(p,0)}, ${ep(p,4)}, ${ep(p,8)}, ${ep(p,12)} )`}function ep(M,p){return`(${M[p+0]}, ${M[p+1]}, ${M[p+2]}, ${M[p+3]})`}function Gp(M){const p="Object_"+M.uniqueId,b=function(M){const p=M.getWorldMatrix().clone(),b=M.RM().useRightHandedSystem;if(!b){let Q=M.parent;for(;Q;){if(kM(Q,b)){p.multiplyToRef(Q.getWorldMatrix().invert(),p);break}Q=Q.parent}}return p.determinant()<0&&q.Tools.Warn(`Exporting mesh ${M.name} with negative scale. Result may look incorrect in destination engine.`),p}(M),Q=tp(b);return`def Xform "${p}" (\n\tprepend references = @./geometries/Geometry_${M.Ab.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${Q}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${M.material.uniqueId}>\n}\n\n`}function mb(M){switch(M){case R.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case R.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case R.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Cp(M){return`(${M.x}, ${M.y})`}function Xp(M){return`(${M.r}, ${M.g}, ${M.b})`}function lp(M,p,b,q,B,k){const u=M.getInternalTexture().uniqueId+"_"+M.invertY;B[u]=M;const T=M.coordinatesIndex>0?"st"+M.coordinatesIndex:"st",O=new Q.Vector2(M.uScale,M.vScale),H=new Q.Vector2(M.uOffset,M.vOffset),F=M.wAng,o=Math.sin(F),W=Math.cos(F);return H.y=1-H.y-O.y,H.x+=o*O.x,H.y+=(1-W)*O.y,`\n    def Shader "PrimvarReader_${b}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${T}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${b}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${p.uniqueId}/PrimvarReader_${b}.outputs:result>\n        float inputs:rotation = ${(F*(180/Math.PI)).toFixed(k.precision)}\n        float2 inputs:scale = ${Cp(O)}\n        float2 inputs:translation = ${Cp(H)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${M.uniqueId}_${b}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${u}.png@\n        float2 inputs:st.connect = </Materials/Material_${p.uniqueId}/Transform2d_${b}.outputs:result>\n        ${q?"float4 inputs:scale = "+function(M){return`(${M.r}, ${M.g}, ${M.b}, 1.0)`}(q):""}\n        token inputs:sourceColorSpace = "${M.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${mb(M.wrapU)}"\n        token inputs:wrapT = "${mb(M.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${p.needAlphaBlending()?"float outputs:a":""}\n    }`}function Mb(M,p,b){const Q="\t\t\t",q=[],B=[],{diffuseMap:k,Pb:u,alphaCutOff:T,emissiveMap:O,emissive:H,normalMap:F,roughnessMap:o,roughnessChannel:W,roughness:i,metalnessMap:A,metalnessChannel:K,metalness:D,aoMap:a,aoMapChannel:s,aoMapIntensity:S,alphaMap:f,ior:R,clearCoatEnabled:y,clearCoat:x,clearCoatMap:P,clearCoatRoughness:L,clearCoatRoughnessMap:N}=function(M){const p={diffuseMap:null,Pb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return M instanceof AM.Dp?{...p,diffuseMap:M.diffuseTexture,Pb:M.diffuseColor,alphaCutOff:M.alphaCutOff,emissiveMap:M.emissiveTexture,emissive:M.emissiveColor,roughness:1,alphaMap:M.opacityTexture}:M instanceof Op.e?{...p,diffuseMap:M._albedoTexture,Pb:M._albedoColor,alphaCutOff:M._alphaCutOff,emissiveMap:M._emissiveTexture,emissive:M._emissiveColor,normalMap:M._bumpTexture,roughnessMap:M._metallicTexture,roughnessChannel:M._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:M._roughness??1,metalnessMap:M._metallicTexture,metalnessChannel:M._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:M._metallic??0,aoMap:M._ambientTexture,aoMapChannel:M._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:M._ambientTextureStrength,alphaMap:M._opacityTexture,ior:M.subSurface.indexOfRefraction,clearCoatEnabled:M.clearCoat.isEnabled,clearCoat:M.clearCoat.yb,clearCoatMap:M.clearCoat.texture,clearCoatRoughness:M.clearCoat.roughness,clearCoatRoughnessMap:M.clearCoat.useRoughnessFromMainTexture?M.clearCoat.texture:M.clearCoat.textureRoughness}:p}(M);return null!==k?(q.push(`${Q}color3f inputs:diffuseColor.connect = </Materials/Material_${M.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:rgb>`),M.needAlphaBlending()?q.push(`${Q}float inputs:opacity.connect = </Materials/Material_${M.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:a>`):M.needAlphaTesting()&&(q.push(`${Q}float inputs:opacity.connect = </Materials/Material_${M.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:a>`),q.push(`${Q}float inputs:opacityThreshold = ${T}`)),B.push(lp(k,M,"diffuse",u,p,b))):q.push(`${Q}color3f inputs:diffuseColor = ${Xp(u||j.ap.White())}`),null!==O?(q.push(`${Q}color3f inputs:emissiveColor.connect = </Materials/Material_${M.uniqueId}/Texture_${O.uniqueId}_emissive.outputs:rgb>`),B.push(lp(O,M,"emissive",H,p,b))):H&&H.toLuminance()>0&&q.push(`${Q}color3f inputs:emissiveColor = ${Xp(H)}`),null!==F&&(q.push(`${Q}normal3f inputs:normal.connect = </Materials/Material_${M.uniqueId}/Texture_${F.uniqueId}_normal.outputs:rgb>`),B.push(lp(F,M,"normal",null,p,b))),null!==a&&(q.push(`${Q}float inputs:occlusion.connect = </Materials/Material_${M.uniqueId}/Texture_${a.uniqueId}_occlusion.outputs:${s}>`),B.push(lp(a,M,"occlusion",new j.ap(S,S,S),p,b))),null!==o?(q.push(`${Q}float inputs:roughness.connect = </Materials/Material_${M.uniqueId}/Texture_${o.uniqueId}_roughness.outputs:${W}>`),B.push(lp(o,M,"roughness",new j.ap(i,i,i),p,b))):q.push(`${Q}float inputs:roughness = ${i}`),null!==A?(q.push(`${Q}float inputs:metallic.connect = </Materials/Material_${M.uniqueId}/Texture_${A.uniqueId}_metallic.outputs:${K}>`),B.push(lp(A,M,"metallic",new j.ap(D,D,D),p,b))):q.push(`${Q}float inputs:metallic = ${D}`),null!==f?(q.push(`${Q}float inputs:opacity.connect = </Materials/Material_${M.uniqueId}/Texture_${f.uniqueId}_opacity.outputs:r>`),q.push(`${Q}float inputs:opacityThreshold = 0.0001`),B.push(lp(f,M,"opacity",null,p,b))):q.push(`${Q}float inputs:opacity = ${M.alpha}`),y&&(null!==P?(q.push(`${Q}float inputs:clearcoat.connect = </Materials/Material_${M.uniqueId}/Texture_${P.uniqueId}_clearcoat.outputs:r>`),B.push(lp(P,M,"clearcoat",new j.ap(x,x,x),p,b))):q.push(`${Q}float inputs:clearcoat = ${x}`),null!==N?(q.push(`${Q}float inputs:clearcoatRoughness.connect = </Materials/Material_${M.uniqueId}/Texture_${N.uniqueId}_clearcoatRoughness.outputs:g>`),B.push(lp(N,M,"clearcoatRoughness",new j.ap(L,L,L),p,b))):q.push(`${Q}float inputs:clearcoatRoughness = ${L}`)),q.push(`${Q}float inputs:ior = ${R}`),`\n\tdef Material "Material_${M.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${q.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${M.uniqueId}/PreviewSurface.outputs:surface>\n\n${B.join("\n")}\n\n\t}\n`}async function pb(M,p,b){const B={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...p};"undefined"===typeof fflate&&await q.Tools.LoadScriptAsync(B.fflateUrl);const k={};k[B.modelFileName]=null;let u='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';u+=function(M){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===M.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${M.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${M.planeAnchoringAlignment}"`:""}\n            `}(B);const T={};for(const Q of M.meshes){if(0===Q.getTotalVertices())continue;const M=Q,p=M.Ab,O=M.material;if(!O||!p||b&&!b(M))continue;if(-1!==["Dp","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(O.getClassName())){const b="geometries/Geometry_"+p.uniqueId+".usda";if(!(b in k)){const M=vp(p,B);k[b]=zp(M)}O.uniqueId in T||(T[O.uniqueId]=O),u+=Gp(M)}else q.Tools.Warn("USDZExportAsync does not support this material type: "+O.getClassName())}M.activeCamera&&B.exportCamera&&(u+=function(M,p){const b="Camera_"+M.uniqueId,q=tp(Q.Matrix.RotationY(Math.PI).multiply(M.getWorldMatrix()));if(M.mode===R.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${b}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${M.Fb.toPrecision(p.precision)}, ${M.maxZ.toPrecision(p.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(M.orthoLeft||1)+Math.abs(M.orthoRight||1))).toPrecision(p.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(M.orthoTop||1)+Math.abs(M.orthoBottom||1))).toPrecision(p.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const Q=M.getEngine().getAspectRatio(M),B=p.cameraSensorWidth||35;return`def Camera "${b}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${M.Fb.toPrecision(p.precision)}, ${M.maxZ.toPrecision(p.precision)})\n\t\t\tfloat focalLength = ${(B/(2*Math.tan(.5*M.fov))).toPrecision(p.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(B*Q).toPrecision(p.precision)}\n\t\t\tfloat verticalAperture = ${(B/Q).toPrecision(p.precision)}            \n\t\t}\n\t\n\t`}}(M.activeCamera,B)),u+="\n            }\n        }\n    }";const O={};u+=function(M,p,b){const Q=[];for(const q in M){const B=M[q];Q.push(Mb(B,p,b))}return`\n    def "Materials"\n{\n${Q.join("")}\n}\n\n`}(T,O,B),k[B.modelFileName]=fflate.strToU8(u);for(const Q in O){const M=O[Q],p=M.getSize(),b=await M.readPixels();if(!b)throw new Error("Texture data is not available");const q=await y.DumpTools.DumpDataAsync(p.width,p.height,b,"image/png",void 0,!1,!0);k[`textures/Texture_${Q}.png`]=new Uint8Array(q).slice()}let H=0;for(const Q in k){const M=k[Q];if(!M)continue;H+=34+Q.length;const p=63&H;if(4!==p){const b=new Uint8Array(64-p);k[Q]=[M,{extra:{12345:b}}]}H=M.length}return fflate.zipSync(k,{level:0})}}}]);