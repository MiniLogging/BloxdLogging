"use strict";(self.ksd6jhs1yr=self.ksd6jhs1yr||[]).push([[26],{12799:(C,c,d)=>{d.r(c),d.d(c,{EXT_materials_diffuse_roughness:()=>xc,EXT_mesh_gpu_instancing:()=>FC,GLTF2Export:()=>IC,GLTFData:()=>j,KHR_draco_mesh_compression:()=>dc,KHR_lights_punctual:()=>pc,KHR_materials_anisotropy:()=>kc,KHR_materials_clearcoat:()=>Uc,KHR_materials_diffuse_transmission:()=>qc,KHR_materials_dispersion:()=>tc,KHR_materials_emissive_strength:()=>nc,KHR_materials_ior:()=>Ec,KHR_materials_iridescence:()=>rc,KHR_materials_sheen:()=>Kc,KHR_materials_specular:()=>hc,KHR_materials_transmission:()=>fc,KHR_materials_unlit:()=>zc,KHR_materials_volume:()=>Jc,KHR_texture_transform:()=>vc,OBJExport:()=>V,STLExport:()=>Dc,USDZExportAsync:()=>cd,_ConvertToGLTFPBRMetallicRoughness:()=>T,_SolveMetallic:()=>f,__IGLTFExporterExtension:()=>R});var b=d(12403),X=d(12219),P=d(12714);class V{static OBJ(C,c,d,V){const R=[];let p=1,j=1;c&&(d||(d="mat"),R.push("mtllib "+d+".mtl"));for(let g=0;g<C.length;g++){const d=C[g],k=d.name||`mesh${g}}`;R.push(`o ${k}`);let Z=null;if(V){const C=d.Tc(!0);Z=new b.Matrix,C.invertToRef(Z),d.bakeTransformIntoVertices(C)}if(c){const C=d.material;C&&R.push("usemtl "+C.id)}const U=d.zc;if(!U){X.Tools.Warn("No geometry is present on the mesh");continue}const A=U.getVerticesData("position"),u=U.getVerticesData("normal"),q=U.getVerticesData("uv"),B=U.wc();let t=0,e=0;if(!A||!B){X.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const n=C[0].NC().useRightHandedSystem?1:-1;for(let C=0;C<A.length;C+=3)R.push("v "+A[C]*n+" "+A[C+1]+" "+A[C+2]),t++;if(null!=u)for(let C=0;C<u.length;C+=3)R.push("vn "+u[C]*n+" "+u[C+1]+" "+u[C+2]);if(null!=q)for(let C=0;C<q.length;C+=2)R.push("vt "+q[C]+" "+q[C+1]),e++;const W=["","",""],E=(d.material||d.NC().defaultMaterial)._getEffectiveOrientation(d),[N,r]=E===P.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let C=0;C<B.length;C+=3){const c=[String(B[C]+p),String(B[C+N]+p),String(B[C+r]+p)],d=[String(B[C]+j),String(B[C+N]+j),String(B[C+r]+j)],b=c,X=null!=q?d:W,P=null!=u?c:W;R.push("f "+b[0]+"/"+X[0]+"/"+P[0]+" "+b[1]+"/"+X[1]+"/"+P[1]+" "+b[2]+"/"+X[2]+"/"+P[2])}V&&Z&&d.bakeTransformIntoVertices(Z),p+=t,j+=e}return R.join("\n")}static MTL(C){const c=[],d=C.material;c.push("newmtl mat1"),c.push("  Ns "+d.specularPower.toFixed(4)),c.push("  Ni 1.5000"),c.push("  d "+d.alpha.toFixed(4)),c.push("  Tr 0.0000"),c.push("  Tf 1.0000 1.0000 1.0000"),c.push("  illum 2"),c.push("  Ka "+d.ambientColor.r.toFixed(4)+" "+d.ambientColor.g.toFixed(4)+" "+d.ambientColor.b.toFixed(4)),c.push("  Kd "+d.diffuseColor.r.toFixed(4)+" "+d.diffuseColor.g.toFixed(4)+" "+d.diffuseColor.b.toFixed(4)),c.push("  Ks "+d.specularColor.r.toFixed(4)+" "+d.specularColor.g.toFixed(4)+" "+d.specularColor.b.toFixed(4)),c.push("  Ke "+d.emissiveColor.r.toFixed(4)+" "+d.emissiveColor.g.toFixed(4)+" "+d.emissiveColor.b.toFixed(4));d.ambientTexture&&c.push("  map_Ka "+d.ambientTexture.name),d.diffuseTexture&&c.push("  map_Kd "+d.diffuseTexture.name),d.specularTexture&&c.push("  map_Ks "+d.specularTexture.name),d.bumpTexture&&c.push("  map_bump -imfchan z "+d.bumpTexture.name),d.opacityTexture&&c.push("  map_d "+d.opacityTexture.name);return c.join("\n")}}var R=0,p=d(12258);class j{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const C in this.files){const c=this.files[C],d=new Blob([c],{type:(0,p.h)(C)});X.Tools.Download(d,C)}}}var g=d(12471),k=d(12807),Z=d(12821),U=d(12839),A=d(12529),u=d(12255),q=d(12438),B=d(12418);const t=B.HighestCommonFactor,e={...B,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:t};var n=d(12628),W=d(12375),E=d(12883),N=d(12886),r=d(12622);const M=1e-6,K=new q.pd(.04,.04,.04),i=1024,h=q.pd.White(),L=q.pd.Black();function f(C,c,d){if(c<K.r)return 0;const b=K.r,X=C*d/(1-K.r)+c-2*K.r,P=X*X-4*b*(K.r-c);return e.Clamp((-X+Math.sqrt(P))/(2*b),0,1)}function T(C){const c=C.diffuseColor.toLinearSpace(C.NC().getEngine().useExactSrgbConversions).scale(.5),d=C.alpha,X=function(C){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new b.Vector2(0,1),d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new b.Vector2(0,.1),X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new b.Vector2(0,.1),P=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new b.Vector2(1300,.1);return function(C,c,d,b,X){return(1-C)*(1-C)*(1-C)*c+3*(1-C)*(1-C)*C*d+3*(1-C)*C*C*b+C*C*C*X}(Math.pow(C/P.x,.333333),c.y,d.y,X.y,P.y)}(e.Clamp(C.specularPower,0,i));return{baseColorFactor:[c.r,c.g,c.b,d],metallicFactor:0,roughnessFactor:X}}function z(C,c){c.needAlphaBlending()?C.alphaMode="BLEND":c.needAlphaTesting()&&(C.alphaMode="MASK",C.alphaCutoff=c.alphaCutOff)}function w(C,c,d){const b=new Uint8Array(C*c*4);for(let X=0;X<b.length;X+=4)b[X]=b[X+1]=b[X+2]=b[X+3]=255;return E.e.CreateRGBATexture(b,C,c,d)}function J(C){if(C instanceof Uint8Array){const c=C.length,d=new Float32Array(C.length);for(let b=0;b<c;++b)d[b]=C[b]/255;return d}if(C instanceof Float32Array)return C;throw new Error("Unsupported pixel format!")}class y{constructor(C){this._exporter=C,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(C){return C?this._textureMap.get(C)??null:null}async exportStandardMaterialAsync(C,c,d){const b=T(C),P={name:C.name};if(null==C.Jc||C.Jc||(C.twoSidedLighting||X.Tools.Warn(C.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),P.doubleSided=!0),d){const d=[],X=C.diffuseTexture;X&&d.push(this.exportTextureAsync(X,c).then((C=>{C&&(b.baseColorTexture=C)})));const V=C.bumpTexture;V&&d.push(this.exportTextureAsync(V,c).then((C=>{C&&(P.normalTexture=C,1!==V.level&&(P.normalTexture.scale=V.level))})));const R=C.emissiveTexture;R&&(P.emissiveFactor=[1,1,1],d.push(this.exportTextureAsync(R,c).then((C=>{C&&(P.emissiveTexture=C)}))));const p=C.ambientTexture;p&&d.push(this.exportTextureAsync(p,c).then((C=>{if(C){const c={index:C.index};P.occlusionTexture=c}}))),d.length>0&&(this._exporter._materialNeedsUVsSet.add(C),await Promise.all(d))}(C.alpha<1||C.opacityTexture)&&(C.alphaMode===N.d.ALPHA_COMBINE?P.alphaMode="BLEND":X.Tools.Warn(C.name+": glTF 2.0 does not support alpha mode: "+C.alphaMode.toString())),C.emissiveColor&&!C.emissiveColor.equalsWithEpsilon(L,M)&&(P.emissiveFactor=C.emissiveColor.rc()),P.pbrMetallicRoughness=b,z(P,C),await this._finishMaterialAsync(P,C,c);const V=this._exporter._materials;return V.push(P),V.length-1}async _finishMaterialAsync(C,c,d){const b=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",C,c),X=[];for(const P of b)X.push(this.exportTextureAsync(P,d));await Promise.all(X),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",C,c)}async _getImageDataAsync(C,c,b,X){const P=N.d.TEXTURETYPE_UNSIGNED_BYTE,V=this._exporter._babylonScene,R=V.getEngine(),p=R.createRawTexture(C,c,b,N.d.TEXTUREFORMAT_RGBA,!1,!0,W.b.NEAREST_SAMPLINGMODE,null,P);R.isWebGPU?await d.e(51).then(d.bind(d,14919)):await d.e(52).then(d.bind(d,14923)),await n.f.ApplyPostProcess("pass",p,V,P,N.d.TEXTURE_NEAREST_SAMPLINGMODE,N.d.TEXTUREFORMAT_RGBA);const j=await R._readTexturePixels(p,c,b);return await r.DumpTools.DumpDataAsync(c,b,j,X,void 0,!0,!0)}_resizeTexturesToSameDimensions(C,c,d){const b=C?C.getSize():{width:0,height:0},X=c?c.getSize():{width:0,height:0};let P,V;return b.width<X.width?(P=C&&C instanceof W.b?n.f.CreateResizedCopy(C,X.width,X.height,!0):w(X.width,X.height,d),V=c):b.width>X.width?(V=c&&c instanceof W.b?n.f.CreateResizedCopy(c,b.width,b.height,!0):w(b.width,b.height,d),P=C):(P=C,V=c),{texture1:P,texture2:V}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(C,c,d,b){const X=new Array;if(!C&&!c)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const P=C?C.NC():c?c.NC():null;if(P){var V;const R=this._resizeTexturesToSameDimensions(C,c,P),p=null===(V=R.texture1)||void 0===V?void 0:V.getSize();let j,g;const k=p.width,Z=p.height,U=await R.texture1.readPixels(),A=await R.texture2.readPixels();if(!U)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(j=J(U),!A)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");g=J(A);const u=g.byteLength,B=new Uint8Array(u),t=new Uint8Array(u),e=4,n=L;let W=0,E=0;for(let C=0;C<Z;++C)for(let c=0;c<k;++c){const b=(k*C+c)*e,X={diffuseColor:new q.pd(j[b],j[b+1],j[b+2]).toLinearSpace(P.getEngine().useExactSrgbConversions).multiply(d.diffuseColor),specularColor:new q.pd(g[b],g[b+1],g[b+2]).toLinearSpace(P.getEngine().useExactSrgbConversions).multiply(d.specularColor),glossiness:g[b+3]*d.glossiness},V=this._convertSpecularGlossinessToMetallicRoughness(X);n.r=Math.max(n.r,V.baseColor.r),n.g=Math.max(n.g,V.baseColor.g),n.b=Math.max(n.b,V.baseColor.b),W=Math.max(W,V.metallic),E=Math.max(E,V.roughness),t[b]=255*V.baseColor.r,t[b+1]=255*V.baseColor.g,t[b+2]=255*V.baseColor.b,t[b+3]=R.texture1.Kc?255*j[b+3]:255,B[b]=0,B[b+1]=255*V.roughness,B[b+2]=255*V.metallic,B[b+3]=255}const N={baseColor:n,metallic:W,roughness:E};let r=!1,K=!1;for(let C=0;C<Z;++C)for(let c=0;c<k;++c){const d=(k*C+c)*e;t[d]/=N.baseColor.r>M?N.baseColor.r:1,t[d+1]/=N.baseColor.g>M?N.baseColor.g:1,t[d+2]/=N.baseColor.b>M?N.baseColor.b:1;const b=q.pd.FromInts(t[d],t[d+1],t[d+2]).toGammaSpace(P.getEngine().useExactSrgbConversions);t[d]=255*b.r,t[d+1]=255*b.g,t[d+2]=255*b.b,b.equalsWithEpsilon(h,M)||(K=!0),B[d+1]/=N.roughness>M?N.roughness:1,B[d+2]/=N.metallic>M?N.metallic:1;q.pd.FromInts(255,B[d+1],B[d+2]).equalsWithEpsilon(h,M)||(r=!0)}return r&&X.push(this._getImageDataAsync(B,k,Z,b).then((C=>{N.metallicRoughnessTextureData=C}))),K&&X.push(this._getImageDataAsync(t,k,Z,b).then((C=>{N.baseColorTextureData=C}))),await Promise.all(X).then((()=>N))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(C){const c=this._getPerceivedBrightness(C.diffuseColor),d=this._getPerceivedBrightness(C.specularColor),b=1-this._getMaxComponent(C.specularColor),X=f(c,d,b),P=C.diffuseColor.scale(b/(1-K.r)/Math.max(1-X)),V=C.specularColor.Xd(K.scale(1-X)).scale(1/Math.max(X));let R=q.pd.Lerp(P,V,X*X);R=R.clampToRef(0,1,R);return{baseColor:R,metallic:X,roughness:1-C.glossiness}}_getPerceivedBrightness(C){return C?Math.sqrt(.299*C.r*C.r+.587*C.g*C.g+.114*C.b*C.b):0}_getMaxComponent(C){return C?Math.max(C.r,Math.max(C.g,C.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(C,c,d,b){const X=[],P={baseColor:C._albedoColor,metallic:C._metallic,roughness:C._roughness};if(b){C._albedoTexture&&X.push(this.exportTextureAsync(C._albedoTexture,c).then((C=>{C&&(d.baseColorTexture=C)})));const b=C._metallicTexture;b&&X.push(this.exportTextureAsync(b,c).then((C=>{C&&(d.metallicRoughnessTexture=C)})))}return X.length>0&&(this._exporter._materialNeedsUVsSet.add(C),await Promise.all(X)),P}_getTextureSampler(C){const c={};if(!C||!(C instanceof W.b))return c;const d=this._getGLTFTextureWrapMode(C.wrapU);10497!==d&&(c.wrapS=d);const b=this._getGLTFTextureWrapMode(C.wrapV);switch(10497!==b&&(c.wrapT=b),C.samplingMode){case W.b.LINEAR_LINEAR:c.magFilter=9729,c.minFilter=9729;break;case W.b.LINEAR_NEAREST:c.magFilter=9729,c.minFilter=9728;break;case W.b.NEAREST_LINEAR:c.magFilter=9728,c.minFilter=9729;break;case W.b.NEAREST_LINEAR_MIPLINEAR:c.magFilter=9728,c.minFilter=9987;break;case W.b.NEAREST_NEAREST:c.magFilter=9728,c.minFilter=9728;break;case W.b.NEAREST_LINEAR_MIPNEAREST:c.magFilter=9728,c.minFilter=9985;break;case W.b.LINEAR_NEAREST_MIPNEAREST:c.magFilter=9729,c.minFilter=9984;break;case W.b.LINEAR_NEAREST_MIPLINEAR:c.magFilter=9729,c.minFilter=9986;break;case W.b.NEAREST_NEAREST_MIPLINEAR:c.magFilter=9728,c.minFilter=9986;break;case W.b.LINEAR_LINEAR_MIPLINEAR:c.magFilter=9729,c.minFilter=9987;break;case W.b.LINEAR_LINEAR_MIPNEAREST:c.magFilter=9729,c.minFilter=9985;break;case W.b.NEAREST_NEAREST_MIPNEAREST:c.magFilter=9728,c.minFilter=9984}return c}_getGLTFTextureWrapMode(C){switch(C){case W.b.WRAP_ADDRESSMODE:return 10497;case W.b.CLAMP_ADDRESSMODE:return 33071;case W.b.MIRROR_ADDRESSMODE:return 33648;default:return X.Tools.Error(`Unsupported Texture Wrap Mode ${C}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(C,c,d,b){const X={diffuseColor:C._albedoColor,specularColor:C._reflectivityColor,glossiness:C._microSurface},P=C._albedoTexture,V=C._reflectivityTexture,R=C._useMicroSurfaceFromReflectivityMapAlpha;if(V&&!R)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((P||V)&&b){this._exporter._materialNeedsUVsSet.add(C);const b=this._exportTextureSampler(P||V),R=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(P,V,X,c),p=this._exporter._textures;if(R.baseColorTextureData){const C=this._exportImage(`baseColor${p.length}`,c,R.baseColorTextureData);d.baseColorTexture=this._exportTextureInfo(C,b,null===P||void 0===P?void 0:P.coordinatesIndex)}if(R.metallicRoughnessTextureData){const C=this._exportImage(`metallicRoughness${p.length}`,c,R.metallicRoughnessTextureData);d.metallicRoughnessTexture=this._exportTextureInfo(C,b,null===V||void 0===V?void 0:V.coordinatesIndex)}return R}return this._convertSpecularGlossinessToMetallicRoughness(X)}async exportPBRMaterialAsync(C,c,d){const b={},X={name:C.name},P=C.isMetallicWorkflow();if(P){const c=C._albedoColor,d=C.alpha;c&&(b.baseColorFactor=[c.r,c.g,c.b,d])}const V=P?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(C,c,b,d):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(C,c,b,d);await this._setMetallicRoughnessPbrMaterialAsync(V,C,X,b,c,d),await this._finishMaterialAsync(X,C,c);const R=this._exporter._materials;return R.push(X),R.length-1}async _setMetallicRoughnessPbrMaterialAsync(C,c,d,b,P,V){if(z(d,c),C.baseColor.equalsWithEpsilon(h,M)&&e.WithinEpsilon(c.alpha,1,M)||(b.baseColorFactor=[C.baseColor.r,C.baseColor.g,C.baseColor.b,c.alpha]),null!=C.metallic&&1!==C.metallic&&(b.metallicFactor=C.metallic),null!=C.roughness&&1!==C.roughness&&(b.roughnessFactor=C.roughness),null==c.Jc||c.Jc||(c._twoSidedLighting||X.Tools.Warn(c.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),d.doubleSided=!0),V){const C=[],b=c._bumpTexture;b&&C.push(this.exportTextureAsync(b,P).then((C=>{C&&(d.normalTexture=C,1!==b.level&&(d.normalTexture.scale=b.level))})));const X=c._ambientTexture;X&&C.push(this.exportTextureAsync(X,P).then((C=>{if(C){const b={index:C.index,texCoord:C.texCoord,extensions:C.extensions};d.occlusionTexture=b;const X=c._ambientTextureStrength;X&&(b.strength=X)}})));const V=c._emissiveTexture;V&&C.push(this.exportTextureAsync(V,P).then((C=>{C&&(d.emissiveTexture=C)}))),C.length>0&&(this._exporter._materialNeedsUVsSet.add(c),await Promise.all(C))}const R=c._emissiveColor;R.equalsWithEpsilon(L,M)||(d.emissiveFactor=R.rc()),d.pbrMetallicRoughness=b}_getPixelsFromTextureAsync(C){return function(C){switch(C){case N.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case N.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case N.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case N.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case N.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case N.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case N.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case N.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case N.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case N.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case N.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case N.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case N.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case N.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case N.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case N.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case N.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case N.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case N.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case N.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case N.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(C.textureFormat)?(0,n.e)(C,C._texture.width,C._texture.height):(C.textureType,N.d.TEXTURETYPE_UNSIGNED_BYTE,C.readPixels())}async exportTextureAsync(C,c){const d=this._exporter._extensionsPreExportTextureAsync("exporter",C,c);return d?await d.then((async d=>d?await this._exportTextureInfoAsync(d,c):await this._exportTextureInfoAsync(C,c))):await this._exportTextureInfoAsync(C,c)}async _exportTextureInfoAsync(C,c){let d=this._textureMap.get(C);if(!d){const b=await this._getPixelsFromTextureAsync(C);if(!b)return null;const P=this._exportTextureSampler(C),V=C.mimeType;if(V)switch(V){case"image/jpeg":case"image/png":case"image/webp":c=V;break;default:X.Tools.Warn(`Unsupported media type: ${V}. Exporting texture as PNG.`)}const R=this._internalTextureToImage,p=C.getInternalTexture().uniqueId;R[p]||(R[p]={});let j=R[p][c];if(void 0===j){const d=C.getSize();j=(async()=>{const X=await this._getImageDataAsync(b,d.width,d.height,c);return this._exportImage(C.name,c,X)})(),R[p][c]=j}d=this._exportTextureInfo(await j,P,C.coordinatesIndex),this._textureMap.set(C,d),this._exporter._extensionsPostExportTextures("exporter",d,C)}return d}_exportImage(C,c,d){const b=this._exporter._images;let P;if(this._exporter._shouldUseGlb){P={name:C,mimeType:c,bufferView:void 0};const b=this._exporter._bufferManager.createBufferView(new Uint8Array(d));this._exporter._bufferManager.setBufferView(P,b)}else{const V=C.replace(/\.\/|\/|\.\\|\\/g,"_"),R=function(C){switch(C){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(c);let p=V+R;b.some((C=>C.uri===p))&&(p=`${V}_${X.Tools.RandomId()}${R}`),P={name:C,uri:p},this._exporter._imageData[p]={data:d,mimeType:c}}return b.push(P),b.length-1}_exportTextureInfo(C,c,d){const b=this._exporter._textures;let X=b.findIndex((d=>d.sampler==c&&d.source===C));-1===X&&(X=b.length,b.push({source:C,sampler:c}));const P={index:X};return d&&(P.texCoord=d),P}_exportTextureSampler(C){const c=this._getTextureSampler(C),d=this._exporter._samplers,b=d.findIndex((C=>C.minFilter===c.minFilter&&C.magFilter===c.magFilter&&C.wrapS===c.wrapS&&C.wrapT===c.wrapT));return-1!==b?b:(d.push(c),d.length-1)}}var x=d(12483),H=d(12233),v=d(12891),D=d(12412);const s=b.dd.Zero(),mC=b.Quaternion.Identity(),Q=b.dd.One(),I=new b.dd(-1,1,1);function o(C,c){const{byteOffset:d,byteStride:b,type:X,normalized:P}=C,V=C.getSize(),R=c.reduce(((C,c)=>c.getTotalVertices()>C?c.getTotalVertices():C),-Number.MAX_VALUE);return{byteOffset:d,byteStride:b,componentCount:V,type:X,count:R*V,normalized:P,totalVertices:R,kind:C.getKind()}}function F(C){switch(C){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function Y(C){switch(C){case g.g.PositionKind:case g.g.NormalKind:case g.g.TangentKind:case g.g.ColorKind:case g.g.MatricesIndicesKind:case g.g.MatricesIndicesExtraKind:case g.g.MatricesWeightsKind:case g.g.MatricesWeightsExtraKind:case g.g.UVKind:case g.g.UV2Kind:case g.g.UV3Kind:case g.g.UV4Kind:case g.g.UV5Kind:case g.g.UV6Kind:return!0}return!1}function l(C){switch(C){case P.e.TriangleFillMode:return 4;case P.e.TriangleStripDrawMode:return 5;case P.e.TriangleFanDrawMode:return 6;case P.e.PointListDrawMode:case P.e.PointFillMode:return 0;case P.e.LineLoopDrawMode:return 2;case P.e.LineListDrawMode:return 1;case P.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${C}`)}function S(C){const c=Math.sqrt(C.x*C.x+C.y*C.y+C.z*C.z);c>0&&(C.x/=c,C.y/=c,C.z/=c)}function G(C){return C.x*=-1,C}function a(C){if(C.x*C.x+C.y*C.y>.5){const c=Math.abs(C.x),d=Math.abs(C.y);if(c>d){const d=Math.sign(C.x);C.x=c,C.y*=-d,C.z*=-d,C.w*=d}else{const c=Math.sign(C.y);C.x*=-c,C.y=d,C.z*=c,C.w*=-c}}else{const c=Math.abs(C.z),d=Math.abs(C.w);if(c>d){const d=Math.sign(C.z);C.x*=-d,C.y*=d,C.z=c,C.w*=-d}else{const c=Math.sign(C.w);C.x*=c,C.y*=-c,C.z*=-c,C.w=d}}return C}function O(C){C.yc(-C.z,C.w,C.x,-C.y)}function CC(C,c){const d=b.dd.FromArrayToRef(c.translation||[0,0,0],0,b.TmpVectors.dd[0]),X=b.Quaternion.FromArrayToRef(c.rotation||[0,0,0,1],0,b.TmpVectors.Quaternion[0]),P=b.Matrix.ComposeToRef(Q,X,d,b.TmpVectors.Matrix[0]),V=b.dd.FromArrayToRef(C.translation||[0,0,0],0,b.TmpVectors.dd[2]),R=b.Quaternion.FromArrayToRef(C.rotation||[0,0,0,1],0,b.TmpVectors.Quaternion[1]),p=b.Matrix.ComposeToRef(Q,R,V,b.TmpVectors.Matrix[1]);P.multiplyToRef(p,p),p.decompose(void 0,X,d),d.equalsWithEpsilon(s,D.d)?delete c.translation:c.translation=d.rc(),X.equalsWithEpsilon(mC,D.d)?delete c.rotation:c.rotation=X.rc(),c.scale&&delete c.scale}function cC(C,c){if(!(c instanceof k.e))return!1;if(!(1===c.getChildren().length&&0===C.getChildren().length&&C.parent===c))return!1;const d=C.NC(),b=C instanceof v.b&&!d.useRightHandedSystem?I:Q;return!!c.xc.equalsWithEpsilon(b,D.d)||(H.d.Warn(`Cannot collapse node ${C.name} into parent node ${c.name} with modified scaling.`),!1)}function dC(C){if(C instanceof Array){const c=new Float32Array(C);return new Uint8Array(c.buffer,c.byteOffset,c.byteLength)}return ArrayBuffer.isView(C)?new Uint8Array(C.buffer,C.byteOffset,C.byteLength):new Uint8Array(C)}function bC(C,c){for(const[d,b]of Object.entries(C)){const X=c[d];(Array.isArray(b)&&Array.isArray(X)&&XC(b,X)||b===X)&&delete C[d]}return C}function XC(C,c){return C.length===c.length&&C.every(((C,d)=>C===c[d]))}const PC=b.Matrix.Compose(new b.dd(-1,1,1),b.Quaternion.Identity(),b.dd.Zero());function VC(C,c){if(!(C instanceof k.e))return!1;if(c){if(!C.getWorldMatrix().equalsWithEpsilon(b.Matrix.IdentityReadOnly,D.d))return!1}else{if(!C.getWorldMatrix().multiplyToRef(PC,b.TmpVectors.Matrix[0]).equalsWithEpsilon(b.Matrix.IdentityReadOnly,D.d))return!1}return!(C instanceof Z.c&&C.zc)}const RC=new Map([[Int8Array,(C,c,d)=>C.setInt8(c,d)],[Uint8Array,(C,c,d)=>C.setUint8(c,d)],[Uint8ClampedArray,(C,c,d)=>C.setUint8(c,d)],[Int16Array,(C,c,d)=>C.setInt16(c,d,!0)],[Uint16Array,(C,c,d)=>C.setUint16(c,d,!0)],[Int32Array,(C,c,d)=>C.setInt32(c,d,!0)],[Uint32Array,(C,c,d)=>C.setUint32(c,d,!0)],[Float32Array,(C,c,d)=>C.setFloat32(c,d,!0)],[Float64Array,(C,c,d)=>C.setFloat64(c,d,!0)]]);class pC{writeTypedArray(C){this._checkGrowBuffer(C.byteLength);const c=RC.get(C.constructor);for(let d=0;d<C.length;d++)c(this._dataView,this._byteOffset,C[d]),this._byteOffset+=C.BYTES_PER_ELEMENT}constructor(C){this._data=new Uint8Array(C),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(C){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,C),this._byteOffset++}writeInt8(C){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,C),this._byteOffset++}writeInt16(C){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,C,!0),this._byteOffset+=2}writeUInt16(C){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,C,!0),this._byteOffset+=2}writeInt32(C){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,C,!0),this._byteOffset+=4}writeUInt32(C){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,C,!0),this._byteOffset+=4}writeFloat32(C){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,C,!0),this._byteOffset+=4}writeFloat64(C){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,C,!0),this._byteOffset+=8}_checkGrowBuffer(C){const c=this.byteOffset+C;if(c>this._data.byteLength){const C=new Uint8Array(2*c);C.set(this._data),this._data=C,this._dataView=new DataView(this._data.buffer)}}}function jC(C){return C%4===0?4:C%2===0?2:1}class gC{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(C){let c=0;this._bufferViewToData.forEach((C=>{c+=C.byteLength}));const d=new pC(c),b=Array.from(this._bufferViewToData.keys()).sort(((C,c)=>jC(c.byteLength)-jC(C.byteLength)));for(const X of b){X.byteOffset=d.byteOffset,C.push(X);const c=C.length-1,b=this.getPropertiesWithBufferView(X);for(const C of b)C.bufferView=c;d.writeTypedArray(this._bufferViewToData.get(X)),this._bufferViewToData.delete(X)}return d.getOutputData()}createBufferView(C,c){const d={buffer:0,byteOffset:void 0,byteLength:C.byteLength,byteStride:c};return this._bufferViewToData.set(d,C),d}createAccessor(C,c,d,b,X,P,V){this._verifyBufferView(C);const R={bufferView:void 0,componentType:d,count:b,type:c,min:null===P||void 0===P?void 0:P.min,max:null===P||void 0===P?void 0:P.max,normalized:V,byteOffset:X};return this.setBufferView(R,C),this._accessorToBufferView.set(R,C),R}setBufferView(C,c){this._verifyBufferView(c);this.getPropertiesWithBufferView(c).push(C)}removeBufferView(C){const c=this.getPropertiesWithBufferView(C);for(const d of c)void 0!==d.bufferView&&delete d.bufferView;this._bufferViewToData.delete(C),this._bufferViewToProperties.delete(C),this._accessorToBufferView.forEach(((c,d)=>{c===C&&(void 0!==d.byteOffset&&delete d.byteOffset,this._accessorToBufferView.delete(d))}))}getBufferView(C){const c=this._accessorToBufferView.get(C);return this._verifyBufferView(c),c}getPropertiesWithBufferView(C){return this._verifyBufferView(C),this._bufferViewToProperties.set(C,this._bufferViewToProperties.get(C)??[]),this._bufferViewToProperties.get(C)}getData(C){return this._verifyBufferView(C),this._bufferViewToData.get(C)}_verifyBufferView(C){if(void 0===C||!this._bufferViewToData.has(C))throw new Error(`BufferView ${C} not found in BufferManager.`)}}var kC,ZC=d(12857),UC=d(12874),AC=d(12893),uC=d(12759),qC=d(12924),BC=d(12935),tC=d(12848),eC=d(12942);!function(C){C[C.INTANGENT=0]="INTANGENT",C[C.OUTTANGENT=1]="OUTTANGENT"}(kC||(kC={}));class nC{static _IsTransformable(C){return C&&(C instanceof k.e||C instanceof ZC.d||C instanceof eC.b)}static _CreateNodeAnimation(C,c,d,b,P){if(this._IsTransformable(C)){const V=[],R=[],p=c.getKeys(),j=nC._CalculateMinMaxKeyFrames(p),g=nC._DeduceInterpolation(p,d,b),k=g.interpolationType,Z=g.shouldBakeAnimation;if(Z?nC._CreateBakedAnimation(C,c,d,j.min,j.max,c.framePerSecond,P,V,R,j,b):"LINEAR"===k||"STEP"===k?nC._CreateLinearOrStepAnimation(C,c,d,V,R,b):"CUBICSPLINE"===k?nC._CreateCubicSplineAnimation(C,c,d,V,R,b):nC._CreateBakedAnimation(C,c,d,j.min,j.max,c.framePerSecond,P,V,R,j,b),V.length&&R.length){return{inputs:V,outputs:R,samplerInterpolation:k,inputsMin:Z?j.min:X.Tools.FloatRound(j.min/c.framePerSecond),inputsMax:Z?j.max:X.Tools.FloatRound(j.max/c.framePerSecond)}}}return null}static _DeduceAnimationInfo(C){let c=null,d="VEC3",b=!1;const P=C.targetProperty.split(".");switch(P[0]){case"xc":c="scale";break;case"position":c="translation";break;case"rotation":d="VEC4",c="rotation";break;case"rotationQuaternion":d="VEC4",b=!0,c="rotation";break;case"influence":d="SCALAR",c="weights";break;default:X.Tools.Error(`Unsupported animatable property ${P[0]}`)}return c?{animationChannelTargetPath:c,dataAccessorType:d,useQuaternion:b}:(X.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(C,c,d,b,X,P,V,R,p,j,g){let k;if(nC._IsTransformable(C)&&C.animations)for(const Z of C.animations){if(g&&!g(Z))continue;const X=nC._DeduceAnimationInfo(Z);X&&(k={name:Z.name,samplers:[],channels:[]},nC._AddAnimation(`${Z.name}`,Z.hasRunningRuntimeAnimations?c:k,C,Z,X.dataAccessorType,X.animationChannelTargetPath,b,P,V,R,X.useQuaternion,p,j),k.samplers.length&&k.channels.length&&d.push(k))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(C,c,d,b,X,P,V,R,p,j,g){let k;if(C instanceof tC.b){const X=C.morphTargetManager;if(X)for(let Z=0;Z<X.numTargets;++Z){const U=X.getTarget(Z);for(const A of U.animations){if(g&&!g(A))continue;const U=new qC.b(`${A.name}`,"influence",A.framePerSecond,A.dataType,A.loopMode,A.enableBlending),u=[],q=A.getKeys();for(let C=0;C<q.length;++C){const c=q[C];for(let C=0;C<X.numTargets;++C)C==Z?u.push(c):u.push({frame:c.frame,value:0})}U.setKeys(u);const B=nC._DeduceAnimationInfo(U);B&&(k={name:U.name,samplers:[],channels:[]},nC._AddAnimation(A.name,A.hasRunningRuntimeAnimations?c:k,C,U,B.dataAccessorType,B.animationChannelTargetPath,b,P,V,R,B.useQuaternion,p,j,X.numTargets),k.samplers.length&&k.channels.length&&d.push(k))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(C,c,d,b,X,P,V,R,p){let j;if(C.animationGroups){const k=C.animationGroups;for(const Z of k){const k=new Map,U=new Map,A=new Set,u=Z.to-Z.from;j={name:Z.name,channels:[],samplers:[]};for(let c=0;c<Z.targetedAnimations.length;++c){const u=Z.targetedAnimations[c],q=u.target,B=u.animation;if(p&&!p(B))continue;const t=R.has(q);if(this._IsTransformable(q)||1===q.length&&this._IsTransformable(q[0])){const C=nC._DeduceAnimationInfo(u.animation);if(C){const c=this._IsTransformable(q)?q:this._IsTransformable(q[0])?q[0]:null;c&&nC._AddAnimation(`${B.name}`,j,c,B,C.dataAccessorType,C.animationChannelTargetPath,d,b,X,P,C.useQuaternion,V,t)}}else if(q instanceof BC.d||1===q.length&&q[0]instanceof BC.d){if(nC._DeduceAnimationInfo(u.animation)){const c=q instanceof BC.d?q:q[0];if(c){const d=C.morphTargetManagers.find((C=>{for(let d=0;d<C.numTargets;++d)if(C.getTarget(d)===c)return!0;return!1}));if(d){const b=C.meshes.find((C=>C.morphTargetManager===d));var g;if(b)k.has(b)||k.set(b,new Map),null===(g=k.get(b))||void 0===g||g.set(c,B),A.add(b),U.set(b,B)}}}}}A.forEach((C=>{const c=C.morphTargetManager;let R=null;const p=[],g=U.get(C).getKeys(),A=g.length;for(let d=0;d<A;++d)for(let b=0;b<c.numTargets;++b){const X=c.getTarget(b),P=k.get(C);if(P){const c=P.get(X);c?(R||(R=new qC.b(`${Z.name}_${C.name}_MorphWeightAnimation`,"influence",c.framePerSecond,qC.b.ANIMATIONTYPE_FLOAT,c.loopMode,c.enableBlending)),p.push(c.getKeys()[d])):p.push({frame:Z.from+u/A*d,value:X.influence,inTangent:g[0].inTangent?0:void 0,outTangent:g[0].outTangent?0:void 0})}}R.setKeys(p);const q=nC._DeduceAnimationInfo(R);q&&nC._AddAnimation(`${Z.name}_${C.name}_MorphWeightAnimation`,j,C,R,q.dataAccessorType,q.animationChannelTargetPath,d,b,X,P,q.useQuaternion,V,!1,null===c||void 0===c?void 0:c.numTargets)})),j.channels.length&&j.samplers.length&&c.push(j)}}}static _AddAnimation(C,c,d,X,P,V,R,p,j,g,k,Z,U,A){const u=nC._CreateNodeAnimation(d,X,V,k,Z);let q,B,t,e,n,W;if(u){if(A){let C=0,c=0;const d=[];for(;u.inputs.length>0;)c=u.inputs.shift(),C%A==0&&d.push(c),C++;u.inputs=d}const C=R.get(d),X=new Float32Array(u.inputs);q=p.createBufferView(X),B=p.createAccessor(q,"SCALAR",5126,u.inputs.length,void 0,{min:[u.inputsMin],max:[u.inputsMax]}),g.push(B),t=g.length-1;const j=new b.Quaternion,k=new b.dd,Z=new b.dd,E=d instanceof ZC.d,N=F(P),r=new Float32Array(u.outputs.length*N);u.outputs.forEach((function(C,c){let d=C;switch(V){case"translation":U&&(b.dd.FromArrayToRef(C,0,Z),G(Z),Z.toArray(d));break;case"rotation":4===C.length?b.Quaternion.FromArrayToRef(C,0,j):(d=new Array(4),b.dd.FromArrayToRef(C,0,k),b.Quaternion.FromEulerVectorToRef(k,j)),U&&(a(j),E&&O(j)),j.toArray(d)}r.set(d,c*N)})),q=p.createBufferView(r),B=p.createAccessor(q,P,5126,u.outputs.length),g.push(B),e=g.length-1,n={interpolation:u.samplerInterpolation,input:t,output:e},c.samplers.push(n),W={sampler:c.samplers.length-1,target:{node:C,path:V}},c.channels.push(W)}}static _CreateBakedAnimation(C,c,d,P,V,R,p,j,g,k,Z){let U;const A=b.Quaternion.Identity();let u,q=null,B=null,t=null,e=null,n=null,W=null;k.min=X.Tools.FloatRound(P/R);const E=c.getKeys();for(let b=0,N=E.length;b<N;++b){if(W=null,t=E[b],b+1<N)if(e=E[b+1],t.value.equals&&t.value.equals(e.value)||t.value===e.value){if(0!==b)continue;W=t.frame}else W=e.frame;else{if(n=E[b-1],t.value.equals&&t.value.equals(n.value)||t.value===n.value)continue;W=V}if(W)for(let b=t.frame;b<=W;b+=p){if(u=X.Tools.FloatRound(b/R),u===q)continue;q=u,B=u;const P={key:0,repeatCount:0,loopMode:c.loopMode};U=c._interpolate(b,P),nC._SetInterpolatedValue(C,U,u,c,d,A,j,g,Z)}}B&&(k.max=B)}static _ConvertFactorToVector3OrQuaternion(C,c,d,P,V){const R=nC._GetBasePositionRotationOrScale(c,P,V),p=d.targetProperty.split("."),j=p?p[1]:"",g=V?b.Quaternion.jd(R).normalize():b.dd.jd(R);switch(j){case"x":case"y":case"z":g[j]=C;break;case"w":g.w=C;break;default:X.Tools.Error(`glTFAnimation: Unsupported component name "${j}"!`)}return g}static _SetInterpolatedValue(C,c,d,X,P,V,R,p,j){let g;R.push(d),"weights"!==P?(X.dataType===qC.b.ANIMATIONTYPE_FLOAT&&(c=this._ConvertFactorToVector3OrQuaternion(c,C,X,P,j)),"rotation"===P?(j?V=c:(g=c,b.Quaternion.RotationYawPitchRollToRef(g.y,g.x,g.z,V)),p.push(V.rc())):(g=c,p.push(g.rc()))):p.push([c])}static _CreateLinearOrStepAnimation(C,c,d,b,X,P){for(const V of c.getKeys())b.push(V.frame/c.framePerSecond),nC._AddKeyframeValue(V,c,X,d,C,P)}static _CreateCubicSplineAnimation(C,c,d,b,X,P){c.getKeys().forEach((function(V){b.push(V.frame/c.framePerSecond),nC._AddSplineTangent(kC.INTANGENT,X,d,"CUBICSPLINE",V,P),nC._AddKeyframeValue(V,c,X,d,C,P),nC._AddSplineTangent(kC.OUTTANGENT,X,d,"CUBICSPLINE",V,P)}))}static _GetBasePositionRotationOrScale(C,c,d){let X;if("rotation"===c)if(d){X=(C.rotationQuaternion??b.Quaternion.Identity()).rc()}else{X=(C.rotation??b.dd.Zero()).rc()}else if("translation"===c){X=(C.position??b.dd.Zero()).rc()}else{X=(C.xc??b.dd.One()).rc()}return X}static _AddKeyframeValue(C,c,d,P,V,R){let p;const j=c.dataType;if(j===qC.b.ANIMATIONTYPE_VECTOR3){let c=C.value.rc();if("rotation"===P){const C=b.dd.jd(c);c=b.Quaternion.RotationYawPitchRoll(C.y,C.x,C.z).rc()}d.push(c)}else if(j===qC.b.ANIMATIONTYPE_FLOAT){if("weights"===P)d.push([C.value]);else if(p=this._ConvertFactorToVector3OrQuaternion(C.value,V,c,P,R),p){if("rotation"===P){const C=R?p:b.Quaternion.RotationYawPitchRoll(p.y,p.x,p.z).normalize();d.push(C.rc())}d.push(p.rc())}}else j===qC.b.ANIMATIONTYPE_QUATERNION?d.push(C.value.normalize().rc()):X.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(C,c,d){let b,X,P=!1;if("rotation"===c&&!d)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let V=0,R=C.length;V<R;++V)if(X=C[V],X.inTangent||X.outTangent)if(b){if("CUBICSPLINE"!==b){b="LINEAR",P=!0;break}}else b="CUBICSPLINE";else if(b){if("CUBICSPLINE"===b||X.interpolation&&1===X.interpolation&&"STEP"!==b){b="LINEAR",P=!0;break}}else b=X.interpolation&&1===X.interpolation?"STEP":"LINEAR";return b||(b="LINEAR"),{interpolationType:b,shouldBakeAnimation:P}}static _AddSplineTangent(C,c,d,X,P,V){let R;const p=C===kC.INTANGENT?P.inTangent:P.outTangent;if("CUBICSPLINE"===X){if("rotation"===d)if(p)if(V)R=p.rc();else{const C=p;R=b.Quaternion.RotationYawPitchRoll(C.y,C.x,C.z).rc()}else R=[0,0,0,0];else R="weights"===d?p?[p]:[0]:p?p.rc():[0,0,0];c.push(R)}}static _CalculateMinMaxKeyFrames(C){let c=1/0,d=-1/0;return C.forEach((function(C){c=Math.min(c,C.frame),d=Math.max(d,C.frame)})),{min:c,max:d}}}function WC(C,c,d,P,V,R){const p={attributes:{},influence:C.influence,name:C.name},j=c.zc;if(!j)return X.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),p;const k=R?-1:1,Z=b.dd.Zero();let U=0,A=0;if(C.hasPositions){const P=C.getPositions(),R=j.getVerticesData(g.g.PositionKind);if(R){const C=new Float32Array(R.length),c=[1/0,1/0,1/0],X=[-1/0,-1/0,-1/0];A=R.length/3,U=0;for(let d=U;d<A;++d){const V=b.dd.jd(R,3*d);b.dd.jd(P,3*d).subtractToRef(V,Z),Z.x*=k,c[0]=Math.min(c[0],Z.x),X[0]=Math.max(X[0],Z.x),c[1]=Math.min(c[1],Z.y),X[1]=Math.max(X[1],Z.y),c[2]=Math.min(c[2],Z.z),X[2]=Math.max(X[2],Z.z),C[3*d]=Z.x,C[3*d+1]=Z.y,C[3*d+2]=Z.z}const j=d.createBufferView(C,12),g=d.createAccessor(j,"VEC3",5126,P.length/3,0,{min:c,max:X});V.push(g),p.attributes.POSITION=V.length-1}else X.Tools.Warn(`Morph target positions for mesh ${c.name} were not exported. Mesh does not have position vertex data`)}if(C.hasNormals){const P=C.getNormals(),R=j.getVerticesData(g.g.NormalKind);if(R){const C=new Float32Array(R.length);A=R.length/3,U=0;for(let d=U;d<A;++d){const c=b.dd.jd(R,3*d).normalize();b.dd.jd(P,3*d).normalize().subtractToRef(c,Z),C[3*d]=Z.x*k,C[3*d+1]=Z.y,C[3*d+2]=Z.z}const c=d.createBufferView(C,12),X=d.createAccessor(c,"VEC3",5126,P.length/3,0);V.push(X),p.attributes.NORMAL=V.length-1}else X.Tools.Warn(`Morph target normals for mesh ${c.name} were not exported. Mesh does not have normals vertex data`)}if(C.hasTangents){const P=C.getTangents(),R=j.getVerticesData(g.g.TangentKind);if(R){A=R.length/4;const C=new Float32Array(3*A);U=0;for(let d=U;d<A;++d){const c=b.dd.jd(R,4*d);S(c);const X=b.dd.jd(P,3*d);S(X),X.subtractToRef(c,Z),C[3*d]=Z.x*k,C[3*d+1]=Z.y,C[3*d+2]=Z.z}const c=d.createBufferView(C,12),X=d.createAccessor(c,"VEC3",5126,A,0);V.push(X),p.attributes.TANGENT=V.length-1}else X.Tools.Warn(`Morph target tangents for mesh ${c.name} were not exported. Mesh does not have tangents vertex data`)}if(C.hasColors){const P=C.getColors(),R=j.getVerticesData(g.g.ColorKind),k=j.getVertexBuffer(g.g.ColorKind);if(R&&k){const C=k.getSize();A=R.length/C;const c=new Float32Array(A*C);U=0;for(let d=U;d<A;++d)if(3===C){const X=b.dd.jd(R,d*C);b.dd.jd(P,d*C).subtractToRef(X,Z),c[3*d]=Z.x,c[3*d+1]=Z.y,c[3*d+2]=Z.z}else if(4===C){const X=new b.Vector4,V=b.Vector4.jd(R,d*C);b.Vector4.jd(P,d*C).subtractToRef(V,X),c[4*d]=X.x,c[4*d+1]=X.y,c[4*d+2]=X.z,c[4*d+3]=X.w}else X.Tools.Warn(`Unsupported number of components for color attribute: ${C}`);const j=d.createBufferView(c,4*C),g=d.createAccessor(j,3===C?"VEC3":"VEC4",5126,A,0);V.push(g),p.attributes.COLOR_0=V.length-1}else X.Tools.Warn(`Morph target colors for mesh ${c.name} were not exported. Mesh does not have colors vertex data`)}return p}var EC=d(12951),NC=d(12790),rC=d(12774),MC=d(12345);class KC{}KC.DEFAULT_COLOR=q.pd.White(),KC.DEFAULT_WIDTH_ATTENUATED=1,KC.DEFAULT_WIDTH=.1;var iC=d(12614),hC=d(12956);class LC{static ConvertPoints(C,c){if(C.length&&Array.isArray(C)&&"number"===typeof C[0])return[C];if(C.length&&Array.isArray(C[0])&&"number"===typeof C[0][0])return C;if(C.length&&!Array.isArray(C[0])&&C[0]instanceof b.dd){const c=[];for(let d=0;d<C.length;d++){const b=C[d];c.push(b.x,b.y,b.z)}return[c]}if(C.length>0&&Array.isArray(C[0])&&C[0].length>0&&C[0][0]instanceof b.dd){const c=[],d=C;for(const C of d)c.push(C.flatMap((C=>[C.x,C.y,C.z])));return c}if(C instanceof Float32Array){if(null!==c&&void 0!==c&&c.floatArrayStride){const d=[],b=3*c.floatArrayStride;for(let c=0;c<C.length;c+=b){const X=new Array(b);for(let d=0;d<b;d++)X[d]=C[c+d];d.push(X)}return d}return[Array.from(C)]}if(C.length&&C[0]instanceof Float32Array){const c=[];for(const d of C)c.push(Array.from(d));return c}return[]}static OmitZeroLengthPredicate(C,c,d){const b=[];return c.Xd(C).lengthSquared()>0&&b.push([C,c]),d.Xd(c).lengthSquared()>0&&b.push([c,d]),C.Xd(d).lengthSquared()>0&&b.push([d,C]),0===b.length?null:b}static OmitDuplicatesPredicate(C,c,d,b){const X=[];return LC._SearchInPoints(C,c,b)||X.push([C,c]),LC._SearchInPoints(c,d,b)||X.push([c,d]),LC._SearchInPoints(d,C,b)||X.push([d,C]),0===X.length?null:X}static _SearchInPoints(C,c,d){for(const V of d)for(let d=0;d<V.length;d++){var b,X,P;if(null!==(b=V[d])&&void 0!==b&&b.equals(C))if(null!==(X=V[d+1])&&void 0!==X&&X.equals(c)||null!==(P=V[d-1])&&void 0!==P&&P.equals(c))return!0}return!1}static MeshesToLines(C,c){const d=[];for(let X=0;X<C.length;X++){const P=C[X],V=P.getVerticesData(g.g.PositionKind),R=P.wc();if(V&&R)for(let C=0,p=0;C<R.length;C++){const j=3*R[p++],g=3*R[p++],k=3*R[p++],Z=new b.dd(V[j],V[j+1],V[j+2]),U=new b.dd(V[g],V[g+1],V[g+2]),A=new b.dd(V[k],V[k+1],V[k+2]);if(c){const b=c(Z,U,A,d,C,j,P,X,V,R);if(b)for(const C of b)d.push(C)}else d.push([Z,U],[U,A],[A,Z])}}return d}static ToVector3Array(C){if(Array.isArray(C[0])){const c=[],d=C;for(const C of d){const d=[];for(let c=0;c<C.length;c+=3)d.push(new b.dd(C[c],C[c+1],C[c+2]));c.push(d)}return c}const c=C,d=[];for(let X=0;X<c.length;X+=3)d.push(new b.dd(c[X],c[X+1],c[X+2]));return d}static ToNumberArray(C){return C.flatMap((C=>[C.x,C.y,C.z]))}static GetPointsCountInfo(C){const c=new Array(C.length);let d=0;for(let b=C.length;b--;)c[b]=C[b].length/3,d+=c[b];return{total:d,counts:c}}static GetLineLength(C){if(0===C.length)return 0;let c;c="number"===typeof C[0]?LC.ToVector3Array(C):C;const d=b.TmpVectors.dd[0];let X=0;for(let b=0;b<c.length-1;b++){const C=c[b];X+=c[b+1].subtractToRef(C,d).length()}return X}static GetLineLengthArray(C){const c=new Float32Array(C.length/3);let d=0;for(let b=0,X=C.length/3-1;b<X;b++){let X=C[3*b+0],P=C[3*b+1],V=C[3*b+2];X-=C[3*b+3],P-=C[3*b+4],V-=C[3*b+5];d+=Math.sqrt(X*X+P*P+V*V),c[b+1]=d}return c}static SegmentizeSegmentByCount(C,c,d){const X=[],P=c.Xd(C),V=b.TmpVectors.dd[0];V.Hc(d);const R=b.TmpVectors.dd[1];P.divideToRef(V,R);let p=C.clone();X.push(p);for(let b=0;b<d;b++)p=p.clone(),X.push(p.addInPlace(R));return X}static SegmentizeLineBySegmentLength(C,c){const d=C[0]instanceof b.dd?LC.GetLineSegments(C):"number"===typeof C[0]?LC.GetLineSegments(LC.ToVector3Array(C)):C,X=[];for(const b of d)if(b.length>c){const C=LC.SegmentizeSegmentByCount(b.point1,b.point2,Math.ceil(b.length/c));for(const c of C)X.push(c)}else X.push(b.point1),X.push(b.point2);return X}static SegmentizeLineBySegmentCount(C,c){const d="number"===typeof C[0]?LC.ToVector3Array(C):C,b=LC.GetLineLength(d)/c;return LC.SegmentizeLineBySegmentLength(d,b)}static GetLineSegments(C){const c=[];for(let d=0;d<C.length-1;d++){const b=C[d],X=C[d+1],P=X.Xd(b).length();c.push({point1:b,point2:X,length:P})}return c}static GetMinMaxSegmentLength(C){const c=LC.GetLineSegments(C).sort((C=>C.length));return{min:c[0].length,max:c[c.length-1].length}}static GetPositionOnLineByVisibility(C,c,d){let X=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const P=c*d;let V=0,R=0;const p=C.length;for(let b=0;b<p;b++){if(P<=V+C[b].length){R=b;break}V+=C[b].length}const j=(P-V)/C[R].length;return C[R].point2.subtractToRef(C[R].point1,b.TmpVectors.dd[0]),b.TmpVectors.dd[1]=b.TmpVectors.dd[0].multiplyByFloats(j,j,j),X||b.TmpVectors.dd[1].addInPlace(C[R].point1),b.TmpVectors.dd[1].clone()}static GetCircleLinePoints(C,c){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C,P=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/c;const V=[];for(let R=0;R<=c;R++)V.push(new b.dd(Math.cos(R*P)*C,Math.sin(R*P)*X,d));return V}static GetBezierLinePoints(C,c,d,b){return iC.f.CreateQuadraticBezier(C,c,d,b).getPoints().flatMap((C=>[C.x,C.y,C.z]))}static GetArrowCap(C,c,d,b,X){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,V=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[C.clone(),C.add(c.multiplyByFloats(d,d,d))],widths:[b,X,P,V]}}static GetPointsFromText(C,c,d,b){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,P=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const V=[],R=(0,hC.b)(C,c,d,b);for(const p of R){for(const C of p.paths){const c=[],d=C.getPoints();for(const C of d)c.push(C.x,C.y,X);V.push(c)}if(P)for(const C of p.holes){const c=[],d=C.getPoints();for(const C of d)c.push(C.x,C.y,X);V.push(c)}}return V}static Color3toRGBAUint8(C){const c=new Uint8Array(4*C.length);for(let d=0,b=0;d<C.length;d++)c[b++]=255*C[d].r,c[b++]=255*C[d].g,c[b++]=255*C[d].b,c[b++]=255;return c}static CreateColorsTexture(C,c,d,b){const X=b.getEngine().getCaps().maxTextureSize??1,P=c.length>X?X:c.length,V=Math.ceil(c.length/X);V>1&&(c=[...c,...Array(P*V-c.length).fill(c[0])]);const R=LC.Color3toRGBAUint8(c),p=new E.e(R,P,V,A.b.TEXTUREFORMAT_RGBA,b,!1,!0,d);return p.name=C,p}static PrepareEmptyColorsTexture(C){if(!KC.EmptyColorsTexture){const c=new Uint8Array(4);KC.EmptyColorsTexture=new E.e(c,1,1,A.b.TEXTUREFORMAT_RGBA,C,!1,!1,E.e.NEAREST_NEAREST),KC.EmptyColorsTexture.name="grlEmptyColorsTexture"}return KC.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var C;null===(C=KC.EmptyColorsTexture)||void 0===C||C.dispose(),KC.EmptyColorsTexture=null}static BooleanToNumber(C){return C?1:0}}class fC extends rC.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class TC extends NC.c{isCompatible(C){return!0}constructor(C,c,d){var X;d=d||{color:KC.DEFAULT_COLOR};const P=new fC;P.GREASED_LINE_HAS_COLOR=!!d.color&&!d.useColors,P.GREASED_LINE_SIZE_ATTENUATION=d.sizeAttenuation??!1,P.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===d.colorDistributionType,P.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(c??C.NC()).useRightHandedSystem,P.GREASED_LINE_CAMERA_FACING=d.cameraFacing??!0,super(C,TC.GREASED_LINE_MATERIAL_NAME,200,P,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(X=d)||void 0===X?void 0:X.forceGLSL)||TC.ForceGLSL,this._scene=c??C.NC(),this._engine=this._scene.getEngine(),this._cameraFacing=d.cameraFacing??!0,this.visibility=d.visibility??1,this.useDash=d.useDash??!1,this.dashRatio=d.dashRatio??.5,this.dashOffset=d.dashOffset??0,this.width=d.width?d.width:d.sizeAttenuation?KC.DEFAULT_WIDTH_ATTENUATED:KC.DEFAULT_WIDTH,this._sizeAttenuation=d.sizeAttenuation??!1,this.colorMode=d.colorMode??0,this._color=d.color??null,this.useColors=d.useColors??!1,this._colorsDistributionType=d.colorDistributionType??0,this.colorsSampling=d.colorsSampling??E.e.NEAREST_NEAREST,this._colors=d.iC??null,this.dashCount=d.dashCount??1,this.resolution=d.resolution??new b.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),d.colorsTexture?this.colorsTexture=d.colorsTexture:this._colors?this.colorsTexture=LC.CreateColorsTexture(`${C.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??KC.DEFAULT_COLOR,LC.PrepareEmptyColorsTexture(this._scene)),this._engine.Uc.add((()=>{LC.DisposeEmptyColorsTexture()}))}getAttributes(C){C.push("grl_offsets"),C.push("grl_widths"),C.push("grl_colorPointers"),C.push("grl_counters"),this._cameraFacing?(C.push("grl_previousAndSide"),C.push("grl_nextAndCounters")):C.push("grl_slopes")}getSamplers(C){C.push("grl_colors")}getActiveTextures(C){this.colorsTexture&&C.push(this.colorsTexture)}getUniforms(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const c=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&c.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===C&&c.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:c,vertex:this._cameraFacing&&this._isGLSL(C)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(C)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(C){if(this._cameraFacing){C.fc("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||C.fc("viewProjection",this._scene.getTransformMatrix());const c=b.TmpVectors.Vector4[0];c.x=this._aspect,c.y=this._resolution.x,c.z=this._resolution.y,c.w=this.width,C.updateVector4("grl_aspect_resolution_lineWidth",c)}const c=b.TmpVectors.Vector4[0];c.x=LC.BooleanToNumber(this.useDash),c.y=this._dashArray,c.z=this.dashOffset,c.w=this.dashRatio,C.updateVector4("grl_dashOptions",c);const d=b.TmpVectors.Vector4[1];d.x=this.colorMode,d.y=this.visibility,d.z=this.colorsTexture?this.colorsTexture.getSize().width:0,d.w=LC.BooleanToNumber(this.useColors),C.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",d),this._color&&C.updateColor3("grl_singleColor",this._color);const X=this.colorsTexture??KC.EmptyColorsTexture;C.setTexture("grl_colors",X),C.updateFloat2("grl_textureSize",(null===X||void 0===X?void 0:X.getSize().width)??1,(null===X||void 0===X?void 0:X.getSize().height)??1)}prepareDefines(C,c,d){C.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,C.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,C.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,C.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=c.useRightHandedSystem,C.GREASED_LINE_CAMERA_FACING=this._cameraFacing,C.GREASED_LINE_USE_OFFSETS=!!d.offsets}getClassName(){return TC.GREASED_LINE_MATERIAL_NAME}getCustomCode(C){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(c)?function(C,c){if("vertex"===C){const C={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return c&&(C["!gl_Position\\=viewProjection\\*worldPos;"]="//"),C}return"fragment"===C?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(C,this._cameraFacing):function(C,c){if("vertex"===C){const C={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return c&&(C["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),C}return"fragment"===C?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(C,this._cameraFacing)}dispose(){var C;null===(C=this.colorsTexture)||void 0===C||C.dispose(),super.dispose()}get iC(){return this._colors}set iC(C){this.setColors(C)}setColors(C){var c;let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const X=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var P;if(this._colors=C,null!==C&&0!==C.length){if(!d||b)if(this.colorsTexture&&X===C.length&&!b){const c=LC.Color3toRGBAUint8(C);this.colorsTexture.update(c)}else{var V;null===(V=this.colorsTexture)||void 0===V||V.dispose(),this.colorsTexture=LC.CreateColorsTexture(`${this._material.name}-colors-texture`,C,this.colorsSampling,this._scene)}}else null===(P=this.colorsTexture)||void 0===P||P.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(C){this._dashCount=C,this._dashArray=1/C}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(C){this._sizeAttenuation=C,this.markAllDefinesAsDirty()}get color(){return this._color}set color(C){this.setColor(C)}setColor(C){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==C||null!==this._color&&null===C?(this._color=C,c||this.markAllDefinesAsDirty()):this._color=C}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(C){this._colorsDistributionType=C,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(C){this._aspect=C.x/C.y,this._resolution=C}serialize(){const C=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(c.iC=this._colors),this._color&&(c.color=this._color),C.greasedLineMaterialOptions=c,C}parse(C,c,d){var b;super.parse(C,c,d);const X=C.greasedLineMaterialOptions;null===(b=this.colorsTexture)||void 0===b||b.dispose(),X.color&&this.setColor(X.color,!0),X.colorDistributionType&&(this.colorsDistributionType=X.colorDistributionType),X.iC&&(this.iC=X.iC),X.colorsSampling&&(this.colorsSampling=X.colorsSampling),X.colorMode&&(this.colorMode=X.colorMode),X.useColors&&(this.useColors=X.useColors),X.visibility&&(this.visibility=X.visibility),X.useDash&&(this.useDash=X.useDash),X.dashCount&&(this.dashCount=X.dashCount),X.dashRatio&&(this.dashRatio=X.dashRatio),X.dashOffset&&(this.dashOffset=X.dashOffset),X.width&&(this.width=X.width),X.sizeAttenuation&&(this.sizeAttenuation=X.sizeAttenuation),X.resolution&&(this.resolution=X.resolution),this.iC?this.colorsTexture=LC.CreateColorsTexture(`${this._material.name}-colors-texture`,this.iC,this.colorsSampling,c):LC.PrepareEmptyColorsTexture(c),this.markAllDefinesAsDirty()}copyTo(C){var c;const d=C;null===(c=d.colorsTexture)||void 0===c||c.dispose(),this._colors&&(d.colorsTexture=LC.CreateColorsTexture(`${d._material.name}-colors-texture`,this._colors,d.colorsSampling,this._scene)),d.setColor(this.color,!0),d.colorsDistributionType=this.colorsDistributionType,d.colorsSampling=this.colorsSampling,d.colorMode=this.colorMode,d.useColors=this.useColors,d.visibility=this.visibility,d.useDash=this.useDash,d.dashCount=this.dashCount,d.dashRatio=this.dashRatio,d.dashOffset=this.dashOffset,d.width=this.width,d.sizeAttenuation=this.sizeAttenuation,d.resolution=this.resolution,d.markAllDefinesAsDirty()}_isGLSL(C){return 0===C||this._forceGLSL}}TC.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",TC.ForceGLSL=!1,(0,MC.e)(`BABYLON.${TC.GREASED_LINE_MATERIAL_NAME}`,TC);var zC=d(12828),wC=d(12235),JC=d(12631),yC=d(12320);class xC extends JC.ShaderMaterial{constructor(C,c,X){const P=c.getEngine(),V=P.isWebGPU&&!(X.forceGLSL||xC.ForceGLSL),R=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];c.useRightHandedSystem&&R.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const p=["position","grl_widths","grl_offsets","grl_colorPointers"];X.cameraFacing?(R.push("GREASED_LINE_CAMERA_FACING"),p.push("grl_previousAndSide","grl_nextAndCounters")):(p.push("grl_slopes"),p.push("grl_counters"));const j=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(V||j.push("world","viewProjection","view","projection"),super(C,c,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:V?["Scene","Mesh"]:void 0,attributes:p,uniforms:j,samplers:V?[]:["grlColors"],defines:R,extraInitializationsAsync:async()=>{V?await Promise.all([d.e(66).then(d.bind(d,15536)),d.e(75).then(d.bind(d,15545))]):await Promise.all([d.e(69).then(d.bind(d,15548)),d.e(76).then(d.bind(d,15554))])},shaderLanguage:V?1:0}),this._color=q.pd.White(),this._colorsDistributionType=0,this._colorsTexture=null,X=X||{color:KC.DEFAULT_COLOR},this.visibility=X.visibility??1,this.useDash=X.useDash??!1,this.dashRatio=X.dashRatio??.5,this.dashOffset=X.dashOffset??0,this.dashCount=X.dashCount??1,this.width=X.width?X.width:X.sizeAttenuation&&X.cameraFacing?KC.DEFAULT_WIDTH_ATTENUATED:KC.DEFAULT_WIDTH,this.sizeAttenuation=X.sizeAttenuation??!1,this.color=X.color??q.pd.White(),this.useColors=X.useColors??!1,this.colorsDistributionType=X.colorDistributionType??0,this.colorsSampling=X.colorsSampling??E.e.NEAREST_NEAREST,this.colorMode=X.colorMode??0,this._colors=X.iC??null,this._cameraFacing=X.cameraFacing??!0,this.resolution=X.resolution??new b.Vector2(P.getRenderWidth(),P.getRenderHeight()),X.colorsTexture?this.colorsTexture=X.colorsTexture:this._colors?this.colorsTexture=LC.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,c):(this._color=this._color??KC.DEFAULT_COLOR,this.colorsTexture=LC.PrepareEmptyColorsTexture(c)),V){const C=new yC.e;C.setParameters(),C.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",C)}P.Uc.add((()=>{LC.DisposeEmptyColorsTexture()}))}dispose(){var C;null===(C=this._colorsTexture)||void 0===C||C.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new b.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get iC(){return this._colors}set iC(C){this.setColors(C)}setColors(C){var c;let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const X=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var P;if(this._colors=C,null!==C&&0!==C.length){if(!d||b)if(this._colorsTexture&&X===C.length&&!b){const c=LC.Color3toRGBAUint8(C);this._colorsTexture.update(c)}else{var V;null===(V=this._colorsTexture)||void 0===V||V.dispose(),this.colorsTexture=LC.CreateColorsTexture(`${this.name}-colors-texture`,C,this.colorsSampling,this.NC())}}else null===(P=this._colorsTexture)||void 0===P||P.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(C){this._colorsTexture=C,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(C){this._width=C,this.setFloat("grlWidth",C)}get useColors(){return this._useColors}set useColors(C){this._useColors=C,this.setFloat("grlUseColors",LC.BooleanToNumber(C))}get colorsSampling(){return this._colorsSampling}set colorsSampling(C){this._colorsSampling=C}get visibility(){return this._visibility}set visibility(C){this._visibility=C,this.setFloat("grlVisibility",C)}get useDash(){return this._useDash}set useDash(C){this._useDash=C,this.setFloat("grlUseDash",LC.BooleanToNumber(C))}get dashOffset(){return this._dashOffset}set dashOffset(C){this._dashOffset=C,this.setFloat("grlDashOffset",C)}get dashRatio(){return this._dashRatio}set dashRatio(C){this._dashRatio=C,this.setFloat("grlDashRatio",C)}get dashCount(){return this._dashCount}set dashCount(C){this._dashCount=C,this._dashArray=1/C,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(C){this._sizeAttenuation=C,this.setFloat("grlSizeAttenuation",LC.BooleanToNumber(C))}get color(){return this._color}set color(C){this.setColor(C)}setColor(C){C=C??KC.DEFAULT_COLOR,this._color=C,this.setColor3("grlColor",C)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(C){this._colorsDistributionType=C,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(C){this._colorMode=C,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(C){this._resolution=C,this.setVector2("grlResolution",C),this.setFloat("grlAspect",C.x/C.y)}serialize(){const C=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(c.iC=this._colors),C.greasedLineMaterialOptions=c,C}parse(C,c,d){var b;const X=C.greasedLineMaterialOptions;null===(b=this._colorsTexture)||void 0===b||b.dispose(),X.color&&(this.color=X.color),X.colorDistributionType&&(this.colorsDistributionType=X.colorDistributionType),X.colorsSampling&&(this.colorsSampling=X.colorsSampling),X.colorMode&&(this.colorMode=X.colorMode),X.useColors&&(this.useColors=X.useColors),X.visibility&&(this.visibility=X.visibility),X.useDash&&(this.useDash=X.useDash),X.dashCount&&(this.dashCount=X.dashCount),X.dashRatio&&(this.dashRatio=X.dashRatio),X.dashOffset&&(this.dashOffset=X.dashOffset),X.width&&(this.width=X.width),X.sizeAttenuation&&(this.sizeAttenuation=X.sizeAttenuation),X.resolution&&(this.resolution=X.resolution),X.iC?this.colorsTexture=LC.CreateColorsTexture(`${this.name}-colors-texture`,X.iC,this.colorsSampling,this.NC()):this.colorsTexture=LC.PrepareEmptyColorsTexture(c),this._cameraFacing=X.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var HC,vC,DC;xC.ForceGLSL=!1,function(C){C[C.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",C[C.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(HC||(HC={})),function(C){C[C.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",C[C.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",C[C.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(vC||(vC={})),function(C){C[C.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",C[C.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",C[C.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",C[C.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",C[C.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(DC||(DC={}));class sC extends tC.b{constructor(C,c,d){super(C,c,null,null,!1,!1),this.name=C,this._options=d,this._lazy=!1,this._updatable=!1,this._engine=c.getEngine(),this._lazy=d.lazy??!1,this._updatable=d.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=d.colorPointers??[],this._widths=d.widths??new Array(d.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(C){let c=0;for(const b of this._points)c+=b.length;const d=c/3*2-this._widths.length;for(let b=0;b<d;b++)this._widths.push(C)}updateLazy(){var C,c;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(C=this._options.ribbonOptions)||void 0===C?void 0:C.smoothShading),!this.TC&&this.refreshBoundingInfo(),null===(c=this.greasedLineMaterial)||void 0===c||c.updateLazy()}addPoints(C,c){for(const d of C)this._points.push(d);this._lazy||this.setPoints(this._points,c)}dispose(C){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(C,c)}isLazy(){return this._lazy}get hC(){return this._uvs}set hC(C){this._uvs=C instanceof Float32Array?C:new Float32Array(C),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(C){this.material instanceof xC&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===C||void 0===C?void 0:C.length)>0),this._offsets=C,this._offsetsBuffer?this._offsetsBuffer.update(C):this._createOffsetsBuffer(C)}get widths(){return this._widths}set widths(C){this._widths=C,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(C)}get colorPointers(){return this._colorPointers}set colorPointers(C){this._colorPointers=C,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(C)}get greasedLineMaterial(){var C,c;if(this.material&&this.material instanceof xC)return this.material;const d=null===(C=this.material)||void 0===C||null===(c=C.pluginManager)||void 0===c?void 0:c.getPlugin(TC.GREASED_LINE_MATERIAL_NAME);return d||void 0}get points(){const C=[];return wC.d.DeepCopy(this._points,C),C}setPoints(C,c){this._points=LC.ConvertPoints(C,(null===c||void 0===c?void 0:c.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==c&&void 0!==c&&c.colorPointers||this._updateColorPointers(),this._setPoints(this._points,c)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,hC:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(C){super.serialize(C),C.type=this.getClassName(),C.lineOptions=this._createLineOptions()}_createVertexBuffers(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new zC.e;return c.MC=this._vertexPositions,c.indices=this._indices,c.hC=this._uvs,C&&(c.KC=[],zC.e.ComputeNormals(this._vertexPositions,this._indices,c.KC)),c.fC(this,this._options.updatable),c}_createOffsetsBuffer(C){const c=this._scene.getEngine(),d=new g.d(c,C,this._updatable,3);this.setVerticesBuffer(d.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=d}}class mc{constructor(C,c){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=C,this.wasAddedByNoopNode=c}getIndicesAccessor(C,c,d,b,X){var P,V,R,p;return null===(P=this._indicesAccessorMap.get(C))||void 0===P||null===(V=P.get(c))||void 0===V||null===(R=V.get(d))||void 0===R||null===(p=R.get(b))||void 0===p?void 0:p.get(X)}setIndicesAccessor(C,c,d,b,X,P){let V=this._indicesAccessorMap.get(C);V||(V=new Map,this._indicesAccessorMap.set(C,V));let R=V.get(c);R||(R=new Map,V.set(c,R));let p=R.get(d);p||(p=new Map,R.set(d,p));let j=p.get(b);j||(j=new Map,p.set(b,j)),j.set(X,P)}pushExportedNode(C){this._exportedNodes.has(C)||this._exportedNodes.add(C)}getNodesSet(){return this._exportedNodes}getVertexBufferView(C){return this._vertexBufferViewMap.get(C)}setVertexBufferView(C,c){this._vertexBufferViewMap.set(C,c)}setRemappedBufferView(C,c,d){this._remappedBufferView.set(C,new Map),this._remappedBufferView.get(C).set(c,d)}getRemappedBufferView(C,c){var d;return null===(d=this._remappedBufferView.get(C))||void 0===d?void 0:d.get(c)}getVertexAccessor(C,c,d){var b,X;return null===(b=this._vertexAccessorMap.get(C))||void 0===b||null===(X=b.get(c))||void 0===X?void 0:X.get(d)}setVertexAccessor(C,c,d,b){let X=this._vertexAccessorMap.get(C);X||(X=new Map,this._vertexAccessorMap.set(C,X));let P=X.get(c);P||(P=new Map,X.set(c,P)),P.set(d,b)}hasVertexColorAlpha(C){return this._vertexMapColorAlpha.get(C)||!1}setHasVertexColorAlpha(C,c){return this._vertexMapColorAlpha.set(C,c)}getMesh(C){return this._meshMap.get(C)}setMesh(C,c){this._meshMap.set(C,c)}bindMorphDataToMesh(C,c){const d=this._meshMorphTargetMap.get(C)||[];this._meshMorphTargetMap.set(C,d),-1===d.indexOf(c)&&d.push(c)}getMorphTargetsFromMesh(C){return this._meshMorphTargetMap.get(C)}}class QC{_ApplyExtension(C,c,d,b){if(d>=c.length)return Promise.resolve(C);const X=b(c[d],C);return X?X.then((async C=>C?await this._ApplyExtension(C,c,d+1,b):null)):this._ApplyExtension(C,c,d+1,b)}_ApplyExtensions(C,c){const d=[];for(const b of QC._ExtensionNames)d.push(this._extensions[b]);return this._ApplyExtension(C,d,0,c)}_extensionsPreExportTextureAsync(C,c,d){return this._ApplyExtensions(c,((c,b)=>c.preExportTextureAsync&&c.preExportTextureAsync(C,b,d)))}_extensionsPostExportNodeAsync(C,c,d,b,X){return this._ApplyExtensions(c,((c,P)=>c.postExportNodeAsync&&c.postExportNodeAsync(C,P,d,b,X,this._bufferManager)))}_extensionsPostExportMaterialAsync(C,c,d){return this._ApplyExtensions(c,((c,b)=>c.postExportMaterialAsync&&c.postExportMaterialAsync(C,b,d)))}_extensionsPostExportMaterialAdditionalTextures(C,c,d){const b=[];for(const X of QC._ExtensionNames){const P=this._extensions[X];P.postExportMaterialAdditionalTextures&&b.push(...P.postExportMaterialAdditionalTextures(C,c,d))}return b}_extensionsPostExportTextures(C,c,d){for(const b of QC._ExtensionNames){const X=this._extensions[b];X.postExportTexture&&X.postExportTexture(C,c,d)}}_extensionsPostExportMeshPrimitive(C){for(const c of QC._ExtensionNames){const d=this._extensions[c];d.postExportMeshPrimitive&&d.postExportMeshPrimitive(C,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const C of QC._ExtensionNames){const c=this._extensions[C];c.preGenerateBinaryAsync&&await c.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(C){for(const c of QC._ExtensionNames){const d=this._extensions[c];d.enabled&&C(d)}}_extensionsOnExporting(){this._forEachExtensions((C=>{var c,d,b;C.wasUsed&&((c=this._glTF).extensionsUsed||(c.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(C.name)&&this._glTF.extensionsUsed.push(C.name),C.required&&((d=this._glTF).extensionsRequired||(d.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(C.name)&&this._glTF.extensionsRequired.push(C.name)),(b=this._glTF).extensions||(b.extensions={}),C.onExporting&&C.onExporting())}))}_loadExtensions(){for(const C of QC._ExtensionNames){const c=QC._ExtensionFactories[C](this);this._extensions[C]=c}}constructor(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:u.c.LastCreatedScene,c=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${A.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new y(this),this._extensions={},this._bufferManager=new gC,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!C)throw new Error("No scene available to export");this._babylonScene=C,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:C=>{var c;return null===C||void 0===C||null===(c=C.ec)||void 0===c?void 0:c.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...c},this._loadExtensions()}dispose(){for(const C in this._extensions){this._extensions[C].dispose()}}get options(){return this._options}static RegisterExtension(C,c){QC.UnregisterExtension(C)&&X.Tools.Warn(`Extension with the name ${C} already exists`),QC._ExtensionFactories[C]=c,QC._ExtensionNames.push(C)}static UnregisterExtension(C){if(!QC._ExtensionFactories[C])return!1;delete QC._ExtensionFactories[C];const c=QC._ExtensionNames.indexOf(C);return-1!==c&&QC._ExtensionNames.splice(c,1),!0}_generateJSON(C,c,d){const b={byteLength:C};return b.byteLength&&(this._glTF.buffers=[b]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Pd=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(b.uri=c+".bin"),d?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(C){const c=await this._generateBinaryAsync();this._extensionsOnExporting();const d=this._generateJSON(c.byteLength,C,!0),b=new Blob([c],{type:"application/octet-stream"}),X=C+".gltf",P=C+".bin",V=new j;if(V.files[X]=d,V.files[P]=b,this._imageData)for(const R in this._imageData)V.files[R]=new Blob([this._imageData[R].data],{type:this._imageData[R].mimeType});return V}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(C){const c=C%4;return 0===c?c:4-c}async generateGLBAsync(C){this._shouldUseGlb=!0;const c=await this._generateBinaryAsync();this._extensionsOnExporting();const d=this._generateJSON(c.byteLength),b=C+".glb";let X,P=d.length;if("undefined"!==typeof TextEncoder){X=(new TextEncoder).encode(d),P=X.length}const V=this._getPadding(P),R=this._getPadding(c.byteLength),p=28+P+V+c.byteLength+R,g=new pC(p);if(g.writeUInt32(1179937895),g.writeUInt32(2),g.writeUInt32(p),g.writeUInt32(P+V),g.writeUInt32(1313821514),X)g.writeTypedArray(X);else{const C="_".charCodeAt(0);for(let c=0;c<P;++c){const b=d.charCodeAt(c);b!=d.codePointAt(c)?g.writeUInt8(C):g.writeUInt8(b)}}for(let j=0;j<V;++j)g.writeUInt8(32);g.writeUInt32(c.byteLength+R),g.writeUInt32(5130562),g.writeTypedArray(c);for(let j=0;j<R;++j)g.writeUInt8(0);const k=new j;return k.files[b]=new Blob([g.getOutputData()],{type:"application/octet-stream"}),k}_setNodeTransformation(C,c,d){if(c.getPivotPoint().equalsWithEpsilon(s,D.d)||X.Tools.Warn("Pivot points are not supported in the glTF serializer"),!c.position.equalsWithEpsilon(s,D.d)){const X=b.TmpVectors.dd[0].V(c.position);d&&G(X),C.translation=X.rc()}c.xc.equalsWithEpsilon(Q,D.d)||(C.scale=c.xc.rc());const P=c.rotationQuaternion||b.Quaternion.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);P.equalsWithEpsilon(mC,D.d)||(d&&a(P),C.rotation=P.normalize().rc())}_setCameraTransformation(C,c,d){if(!c.position.equalsWithEpsilon(s,D.d)){const X=b.TmpVectors.dd[0].V(c.position);d&&G(X),C.translation=X.rc()}const X=c.rotationQuaternion||b.Quaternion.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);d&&a(X),this._babylonScene.useRightHandedSystem||O(X),X.equalsWithEpsilon(mC,D.d)||(C.rotation=X.rc())}_listAvailableCameras(){for(const C of this._babylonScene.cameras){const c={type:C.mode===ZC.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(C.name&&(c.name=C.name),"perspective"===c.type)c.perspective={aspectRatio:C.getEngine().getAspectRatio(C),yfov:C.fovMode===ZC.d.FOVMODE_VERTICAL_FIXED?C.fov:C.fov*C.getEngine().getAspectRatio(C),znear:C.Lc,zfar:C.maxZ};else if("orthographic"===c.type){const d=C.orthoLeft&&C.orthoRight?.5*(C.orthoRight-C.orthoLeft):.5*C.getEngine().getRenderWidth(),b=C.orthoBottom&&C.orthoTop?.5*(C.orthoTop-C.orthoBottom):.5*C.getEngine().getRenderHeight();c.orthographic={xmag:d,ymag:b,znear:C.Lc,zfar:C.maxZ}}this._camerasMap.set(C,c)}}_exportAndAssignCameras(){const C=Array.from(this._camerasMap.values());for(const c of C){const C=this._nodesCameraMap.get(c);if(void 0!==C){this._cameras.push(c);for(const c of C)c.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const C of this._babylonScene.skeletons){if(C.bones.length<=0)continue;const c={joints:[]};this._skinMap.set(C,c)}}_exportAndAssignSkeletons(){for(const C of this._babylonScene.skeletons){if(C.bones.length<=0)continue;const c=this._skinMap.get(C);if(void 0==c)continue;const d={},b=[];let P=-1;for(let X=0;X<C.bones.length;++X){const c=C.bones[X],b=c.getIndex()??X;-1!==b&&(d[b]=c,b>P&&(P=b))}for(let C=0;C<=P;++C){const P=d[C];b.push(P.getAbsoluteInverseBindMatrix());const V=P.getTransformNode();if(null!==V){const C=this._nodeMap.get(V);V&&null!==C&&void 0!==C?c.joints.push(C):X.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else X.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const V=this._nodesSkinMap.get(c);if(c.joints.length>0&&void 0!==V){const C=64*b.length,d=new Float32Array(C/4);b.forEach(((C,c)=>{d.set(C.m,16*c)}));const X=this._bufferManager.createBufferView(d);this._accessors.push(this._bufferManager.createAccessor(X,"MAT4",5126,b.length)),c.inverseBindMatrices=this._accessors.length-1,this._skins.push(c);for(const c of V)c.skin=this._skins.length-1}}}async _exportSceneAsync(){const C={nodes:[]};if(this._babylonScene.metadata){const c=this._options.metadataSelector(this._babylonScene.metadata);c&&(C.extras=c)}const c=new Array,d=new Array,b=new Array;for(const R of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&VC(R,this._babylonScene.useRightHandedSystem)?b.push(...R.getChildren()):this._babylonScene.useRightHandedSystem?c.push(R):d.push(R);this._listAvailableCameras(),this._listAvailableSkeletons();const X=new mc(!0,!1);C.nodes.push(...await this._exportNodesAsync(d,X));const P=new mc(!1,!1);C.nodes.push(...await this._exportNodesAsync(c,P));const V=new mc(!1,!0);C.nodes.push(...await this._exportNodesAsync(b,V)),C.nodes.length&&this._scenes.push(C),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&nC._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,X.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(C){let c=this._shouldExportNodeMap.get(C);return void 0===c&&(c=this._options.shouldExportNode(C),this._shouldExportNodeMap.set(C,c)),c}async _exportNodesAsync(C,c){const d=new Array;this._exportBuffers(C,c);for(const b of C)await this._exportNodeAsync(b,d,c);return d}_collectBuffers(C,c,d,b,X){if(this._shouldExportNode(C)&&C instanceof Z.c&&C.zc){const P=C.zc.getVertexBuffers();if(P)for(const b in P){if(!Y(b))continue;const V=P[b];X.setHasVertexColorAlpha(V,C.hasVertexAlpha);const R=V._buffer,p=c.get(R)||[];c.set(R,p),-1===p.indexOf(V)&&p.push(V);const j=d.get(V)||[];d.set(V,j),-1===j.indexOf(C)&&j.push(C)}const V=C.morphTargetManager;if(V)for(let c=0;c<V.numTargets;c++){const d=V.getTarget(c),X=b.get(d)||[];b.set(d,X),-1===X.indexOf(C)&&X.push(C)}}for(const P of C.getChildren())this._collectBuffers(P,c,d,b,X)}_exportBuffers(C,c){const d=new Map,b=new Map,X=new Map;for(const R of C)this._collectBuffers(R,d,b,X,c);const P=Array.from(d.keys());for(const R of P){const C=R.getData();if(!C)throw new Error("Buffer data is not available");const X=d.get(R);if(!X)continue;const P=X[0].byteStride;if(X.some((C=>C.byteStride!==P)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const V=dC(C).slice();for(const c of X){const C=b.get(c),{byteOffset:d,byteStride:X,componentCount:P,type:R,count:p,normalized:j,kind:k}=o(c,C);switch(k){case g.g.NormalKind:case g.g.TangentKind:(0,x.h)(V,d,X,P,R,p,j,(C=>{const c=Math.sqrt(C[0]*C[0]+C[1]*C[1]+C[2]*C[2]);if(c>0){const d=1/c;C[0]*=d,C[1]*=d,C[2]*=d}}));break;case g.g.ColorKind:{const c=C.filter((C=>C.material instanceof uC.Rd||null==C.material)).length;if(0==c)break;if(c!=C.length){H.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}R==g.g.UNSIGNED_BYTE&&H.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const b=new q.pd,k=new q.vc,Z=this._babylonScene.getEngine().useExactSrgbConversions;(0,x.h)(V,d,X,P,R,p,j,(C=>{3===C.length?(b.uX(C,0),b.toLinearSpaceToRef(b,Z),b.toArray(C,0)):(k.uX(C,0),k.toLinearSpaceToRef(k,Z),k.toArray(C,0))}))}}}if(c.convertToRightHanded){for(const C of X){const c=b.get(C),{byteOffset:d,byteStride:X,componentCount:P,type:R,count:p,normalized:j,kind:k}=o(C,c);switch(k){case g.g.PositionKind:case g.g.NormalKind:case g.g.TangentKind:(0,x.h)(V,d,X,P,R,p,j,(C=>{C[0]=-C[0]}))}}c.convertedToRightHandedBuffers.set(R,V)}const p=this._bufferManager.createBufferView(V,P);c.setVertexBufferView(R,p);const j=new Map;for(const c of X){const C=b.get(c),{kind:d,totalVertices:X}=o(c,C);switch(d){case g.g.MatricesIndicesKind:case g.g.MatricesIndicesExtraKind:if(c.type==g.g.FLOAT){const C=c.getFloatData(X);null!==C&&j.set(c,C)}}}0!==j.size&&H.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const k=Array.from(j.keys());for(const d of k){const C=j.get(d);if(!C)continue;const b=C.some((C=>C>=256)),X=new(b?Uint16Array:Uint8Array)(C.length);for(let c=0;c<C.length;c++)X[c]=C[c];const P=this._bufferManager.createBufferView(X,4*(b?2:1));c.setRemappedBufferView(R,d,P)}}const V=Array.from(X.keys());for(const R of V){const C=X.get(R);if(!C)continue;const d=WC(R,C[0],this._bufferManager,this._bufferViews,this._accessors,c.convertToRightHanded);for(const b of C)c.bindMorphDataToMesh(b,d)}}async _exportNodeAsync(C,c,d){let b=this._nodeMap.get(C);if(void 0!==b)return void(c.includes(b)||c.push(b));const X=await this._createNodeAsync(C,d);if(X){b=this._nodes.length,this._nodes.push(X),this._nodeMap.set(C,b),d.pushExportedNode(C),c.push(b);const P={name:"runtime animations",channels:[],samplers:[]},V=[];this._babylonScene.animationGroups.length||(nC._CreateMorphTargetAnimationFromMorphTargetAnimations(C,P,V,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,d.convertToRightHanded,this._options.shouldExportAnimation),C.animations.length&&nC._CreateNodeAnimationFromNodeAnimations(C,P,V,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,d.convertToRightHanded,this._options.shouldExportAnimation)),P.channels.length&&P.samplers.length&&this._animations.push(P),V.forEach((C=>{C.channels.length&&C.samplers.length&&this._animations.push(C)}))}const P=X?[]:c;for(const V of C.getChildren())await this._exportNodeAsync(V,P,d);X&&P.length&&(X.children=P)}async _createNodeAsync(C,c){if(!this._shouldExportNode(C))return null;const d={};if(C.name&&(d.name=C.name),C.metadata){const c=this._options.metadataSelector(C.metadata);c&&(d.extras=c)}if(C instanceof k.e&&(this._setNodeTransformation(d,C,c.convertToRightHanded),C instanceof Z.c)){const X=C instanceof U.e?C.sourceMesh:C;if(X.Nc&&X.Nc.length>0&&(d.mesh=await this._exportMeshAsync(X,c)),C.skeleton){const c=this._skinMap.get(C.skeleton);var b;if(void 0!==c)void 0===this._nodesSkinMap.get(c)&&this._nodesSkinMap.set(c,[]),null===(b=this._nodesSkinMap.get(c))||void 0===b||b.push(d)}}if(C instanceof v.b){const b=this._camerasMap.get(C);if(b){var X;void 0===this._nodesCameraMap.get(b)&&this._nodesCameraMap.set(b,[]),this._setCameraTransformation(d,C,c.convertToRightHanded);const V=C.parent;if(null!==V&&cC(C,V)){const C=this._nodeMap.get(V);if(void 0!==C){var P;const c=this._nodes[C];return CC(d,c),null===(P=this._nodesCameraMap.get(b))||void 0===P||P.push(c),null}}null===(X=this._nodesCameraMap.get(b))||void 0===X||X.push(d)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",d,C,this._nodeMap,c.convertToRightHanded)?d:(H.d.Warn(`Not exporting node ${C.name}`),null)}_exportIndices(C,c,d,b,X,V,R,p,j){let g=C;j.mode=l(V);const k=R!==P.e.CounterClockWiseSideOrientation,Z=!p.wasAddedByNoopNode&&k,U=function(C){switch(C){case P.e.TriangleFillMode:case P.e.TriangleStripDrawMode:case P.e.TriangleFanDrawMode:return!0}return!1}(V)&&Z;if(U){if(V===P.e.TriangleStripDrawMode||V===P.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");j.mode=l(V);const R=c?new Uint32Array(b):new Uint16Array(b);if(C)for(let c=0;c+2<b;c+=3)R[c]=C[d+c]+X,R[c+1]=C[d+c+2]+X,R[c+2]=C[d+c+1]+X;else for(let C=0;C+2<b;C+=3)R[C]=C,R[C+1]=C+2,R[C+2]=C+1;g=R}else if(C&&0!==X){const P=c?new Uint32Array(b):new Uint16Array(b);for(let c=0;c<b;c++)P[c]=C[d+c]+X;g=P}if(g){let P=p.getIndicesAccessor(C,d,b,X,U);if(void 0===P){const V=function(C,c,d,b){if(C instanceof Uint16Array||C instanceof Uint32Array)return C;if(C instanceof Int32Array)return new Uint32Array(C.buffer,C.byteOffset,C.length);const X=C.slice(c,c+d);return b?new Uint32Array(X):new Uint16Array(X)}(g,0,b,c),R=this._bufferManager.createBufferView(V),j=c?5125:5123;this._accessors.push(this._bufferManager.createAccessor(R,"SCALAR",j,b,0)),P=this._accessors.length-1,p.setIndicesAccessor(C,d,b,X,U,P)}j.indices=P}}_exportVertexBuffer(C,c,d,b,X,P){const V=C.getKind();if(!Y(V))return;if(V.startsWith("uv")&&!this._options.exportUnusedUVs&&(!c||!this._materialNeedsUVsSet.has(c)))return;let R=X.getVertexAccessor(C,d,b);if(void 0===R){const c=X.convertedToRightHandedBuffers.get(C._buffer)||C._buffer.getData(),P=V===g.g.PositionKind?function(C,c,d,b){const{byteOffset:X,byteStride:P,type:V,normalized:R}=c,p=c.getSize(),j=new Array(p).fill(1/0),g=new Array(p).fill(-1/0);return(0,x.h)(C,X+d*P,P,p,V,b*p,R,(C=>{for(let c=0;c<p;c++)j[c]=Math.min(j[c],C[c]),g[c]=Math.max(g[c],C[c])})),{min:j,max:g}}(c,C,d,b):void 0,p=(V===g.g.MatricesIndicesKind||V===g.g.MatricesIndicesExtraKind)&&C.type===g.g.FLOAT,j=p?g.g.UNSIGNED_BYTE:C.type,k=p?void 0:C.normalized,Z=p?X.getRemappedBufferView(C._buffer,C):X.getVertexBufferView(C._buffer),U=C.byteOffset+d*C.byteStride;this._accessors.push(this._bufferManager.createAccessor(Z,function(C,c){if(C==g.g.ColorKind)return c?"VEC4":"VEC3";switch(C){case g.g.PositionKind:case g.g.NormalKind:return"VEC3";case g.g.TangentKind:case g.g.MatricesIndicesKind:case g.g.MatricesIndicesExtraKind:case g.g.MatricesWeightsKind:case g.g.MatricesWeightsExtraKind:return"VEC4";case g.g.UVKind:case g.g.UV2Kind:case g.g.UV3Kind:case g.g.UV4Kind:case g.g.UV5Kind:case g.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${C}`)}(V,X.hasVertexColorAlpha(C)),j,b,U,P,k)),R=this._accessors.length-1,X.setVertexAccessor(C,d,b,R)}P.attributes[function(C){switch(C){case g.g.PositionKind:return"POSITION";case g.g.NormalKind:return"NORMAL";case g.g.TangentKind:return"TANGENT";case g.g.ColorKind:return"COLOR_0";case g.g.UVKind:return"TEXCOORD_0";case g.g.UV2Kind:return"TEXCOORD_1";case g.g.UV3Kind:return"TEXCOORD_2";case g.g.UV4Kind:return"TEXCOORD_3";case g.g.UV5Kind:return"TEXCOORD_4";case g.g.UV6Kind:return"TEXCOORD_5";case g.g.MatricesIndicesKind:return"JOINTS_0";case g.g.MatricesIndicesExtraKind:return"JOINTS_1";case g.g.MatricesWeightsKind:return"WEIGHTS_0";case g.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${C}`)}(V)]=R}async _exportMaterialAsync(C,c,d,b){let X=this._materialMap.get(C);if(void 0===X){const b=c&&Object.keys(c).some((C=>C.startsWith("uv")));if((C=C instanceof UC.c?C.Dc[d.materialIndex]:C)instanceof AC.c)X=await this._materialExporter.exportPBRMaterialAsync(C,"image/png",b);else{if(!(C instanceof uC.Rd))return void H.d.Warn(`Unsupported material '${C.name}' with type ${C.getClassName()}`);X=await this._materialExporter.exportStandardMaterialAsync(C,"image/png",b)}this._materialMap.set(C,X)}b.material=X}async _exportMeshAsync(C,c){var d;let b=c.getMesh(C);if(void 0!==b)return b;const X={primitives:[]};b=this._meshes.length,this._meshes.push(X),c.setMesh(C,b);const V=C.isUnIndexed?null:C.wc(),R=null===(d=C.zc)||void 0===d?void 0:d.getVertexBuffers(),p=c.getMorphTargetsFromMesh(C),j=C instanceof EC.b,g=C instanceof sC,k=C.Nc;if(R&&k&&k.length>0)for(const A of k){const d={attributes:{}},b=A.yC()||this._babylonScene.defaultMaterial;if(g){var Z,U;const c={name:b.name},X=C,P=q.pd.White(),V=(null===(Z=X.material)||void 0===Z?void 0:Z.alpha)??1,R=(null===(U=X.greasedLineMaterial)||void 0===U?void 0:U.color)??P;(!R.equalsWithEpsilon(P,D.d)||V<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...R.rc(),V]}),this._materials.push(c),d.material=this._materials.length-1}else if(j){const c={name:b.name},X=C;(!X.color.equalsWithEpsilon(q.pd.White(),D.d)||X.alpha<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...X.color.rc(),X.alpha]}),this._materials.push(c),d.material=this._materials.length-1}else await this._exportMaterialAsync(b,R,A,d);const k=j||g?P.e.LineListDrawMode:C.overrideRenderingFillMode??b.fillMode,u=b._getEffectiveOrientation(C);this._exportIndices(V,V?(0,x.d)(V,A.indexCount,A.indexStart,A.verticesStart):A.verticesCount>65535,V?A.indexStart:A.verticesStart,V?A.indexCount:A.verticesCount,-A.verticesStart,k,u,c,d);for(const C of Object.values(R))this._exportVertexBuffer(C,b,A.verticesStart,A.verticesCount,c,d);if(p){d.targets=[];for(const C of p)d.targets.push(C.attributes)}X.primitives.push(d),this._extensionsPostExportMeshPrimitive(d)}if(p){X.weights=[],X.extras||(X.extras={}),X.extras.targetNames=[];for(const C of p)X.weights.push(C.influence),X.extras.targetNames.push(C.name)}return b}}QC._ExtensionNames=new Array,QC._ExtensionFactories={};class IC{static async GLTFAsync(C,c,d){d&&d.exportWithoutWaitingForScene||await C.whenReadyAsync();const b=new QC(C,d),X=await b.generateGLTFAsync(c.replace(/\.[^/.]+$/,""));return b.dispose(),X}static async GLBAsync(C,c,d){d&&d.exportWithoutWaitingForScene||await C.whenReadyAsync();const b=new QC(C,d),X=await b.generateGLBAsync(c.replace(/\.[^/.]+$/,""));return b.dispose(),X}}d(12973);const oC="EXT_mesh_gpu_instancing";class FC{constructor(C){this.name=oC,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(C,c,d,X,P,V){return await new Promise((C=>{if(c&&d instanceof tC.b&&d.hasThinInstances&&this._exporter){this._wasUsed=!0;const C=b.dd.Zero(),X=b.Quaternion.Identity(),R=b.dd.One(),p=d.thinInstanceGetWorldMatrices(),j=b.TmpVectors.dd[2],g=b.TmpVectors.Quaternion[1],k=b.TmpVectors.dd[3];let Z=!1,U=!1,A=!1;const u=new Float32Array(3*d.sc),q=new Float32Array(4*d.sc),B=new Float32Array(3*d.sc);let t=0;for(const c of p)c.decompose(k,g,j),P&&(G(j),a(g)),u.set(j.rc(),3*t),q.set(g.normalize().rc(),4*t),B.set(k.rc(),3*t),Z=Z||!j.equalsWithEpsilon(C),U=U||!g.equalsWithEpsilon(X),A=A||!k.equalsWithEpsilon(R),t++;const e={attributes:{}};Z&&(e.attributes.TRANSLATION=this._buildAccessor(u,"VEC3",d.sc,V)),U&&(e.attributes.ROTATION=this._buildAccessor(q,"VEC4",d.sc,V)),A&&(e.attributes.SCALE=this._buildAccessor(B,"VEC3",d.sc,V)),c.extensions=c.extensions||{},c.extensions[oC]=e}C(c)}))}_buildAccessor(C,c,d,b){const X=b.createBufferView(C),P=b.createAccessor(X,c,5126,d);return this._exporter._accessors.push(P),this._exporter._accessors.length-1}}QC.RegisterExtension(oC,(C=>new FC(C)));var YC=d(12982),lC=d(12996),SC=d(13005),GC=d(13010);function aC(C){return C===SC.d.PositionKind?"POSITION":C===SC.d.NormalKind?"NORMAL":C===SC.d.ColorKind?"COLOR":C.startsWith(SC.d.UVKind)?"TEX_COORD":"GENERIC"}const OC={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Cc extends YC.e{static get DefaultAvailable(){return(0,YC.i)(Cc.DefaultConfiguration)}static get Default(){return Cc._Default??(Cc._Default=new Cc),Cc._Default}static ResetDefault(C){Cc._Default&&(C||Cc._Default.dispose(),Cc._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(C,c){return{module:await(c||DracoEncoderModule)({wasmBinary:C})}}_getWorkerContent(){return`${lC.i}(${lC.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Cc.DefaultConfiguration)}async _encodeAsync(C,c,d){const b=d?(0,GC.d)(OC,d):OC;if(this._workerPoolPromise){const d=await this._workerPoolPromise;return await new Promise(((X,P)=>{d.push(((d,V)=>{const R=C=>{d.removeEventListener("error",R),d.removeEventListener("message",p),P(C),V()},p=C=>{"encodeMeshDone"===C.data.id&&(d.removeEventListener("error",R),d.removeEventListener("message",p),X(C.data.encodedMeshData),V())};d.addEventListener("error",R),d.addEventListener("message",p);const j=[];for(const c of C)j.push(c.data.buffer);c&&j.push(c.buffer),d.postMessage({id:"encodeMesh",attributes:C,indices:c,options:b},j)}))}))}if(this._modulePromise){const d=await this._modulePromise;return(0,lC.i)(d.module,C,c,b)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(C,c){if(0==C.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");C instanceof tC.b&&C.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===c||void 0===c?void 0:c.method)&&(H.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),c.method="MESH_SEQUENTIAL_ENCODING");const d=function(C){let c=C.wc(void 0,!0);return!c||c instanceof Uint32Array||c instanceof Uint16Array||(c=((0,x.d)(c,c.length)?Uint32Array:Uint16Array).from(c)),c}(C),b=function(C,c){const d=[];for(const b of C.getVerticesDataKinds()){if(null!==c&&void 0!==c&&c.includes(b)){if(b===SC.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const X=C.getVertexBuffer(b),P=X.getSize(),V=(0,x.v)(X.getData(),P,X.type,X.byteOffset,X.byteStride,X.normalized,C.getTotalVertices(),!0);d.push({kind:b,dracoName:aC(b),size:P,data:V})}return d}(C,null===c||void 0===c?void 0:c.excludedAttributes);return await this._encodeAsync(b,d,c)}}Cc.DefaultConfiguration={wasmUrl:`${X.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${X.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${X.Tools._DefaultCdnUrl}/draco_encoder.js`},Cc._Default=null;const cc="KHR_draco_mesh_compression";class dc{get wasUsed(){return this._wasUsed}constructor(C){this.name=cc,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===C.options.meshCompressionMethod&&Cc.DefaultAvailable}dispose(){}postExportMeshPrimitive(C,c,d){if(!this.enabled)return;if(4!==C.mode&&5!==C.mode)return void H.d.Warn("Cannot compress primitive with mode "+C.mode+".");const b=[],X=[];let P=null;if(void 0!==C.indices){const V=d[C.indices],R=c.getBufferView(V);P=c.getData(R).slice(),b.push(R),X.push(V)}const V=[];for(const[g,k]of Object.entries(C.attributes)){const C=d[k],P=c.getBufferView(C),p=F(C.type),j=(0,x.v)(c.getData(P),p,C.componentType,C.byteOffset||0,P.byteStride||(0,x.p)(C.componentType)*p,C.normalized||!1,C.count,!0);V.push({kind:g,dracoName:(R=g,"POSITION"===R?"POSITION":"NORMAL"===R?"NORMAL":R.startsWith("COLOR")?"COLOR":R.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:F(C.type),data:j}),b.push(P),X.push(C)}var R;const p={method:C.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},j=Cc.Default._encodeAsync(V,P,p).then((d=>{if(!d)return void H.d.Error("Draco encoding failed for primitive.");const P={bufferView:-1,attributes:d.attributeIds},V=c.createBufferView(d.data);c.setBufferView(P,V);for(const C of b)this._bufferViewsUsed.add(C);for(const C of X)this._accessorsUsed.add(C);C.extensions||(C.extensions={}),C.extensions[cc]=P})).catch((C=>{H.d.Error("Draco encoding failed for primitive: "+C)}));this._encodePromises.push(j),this._wasUsed=!0}async preGenerateBinaryAsync(C){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((c=>{C.getPropertiesWithBufferView(c).every((C=>this._accessorsUsed.has(C)))&&C.removeBufferView(c)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}QC.RegisterExtension(cc,(C=>new dc(C)));var bc=d(13018);const Xc="KHR_lights_punctual",Pc={name:"",color:[1,1,1],Qc:1,range:Number.MAX_VALUE},Vc={innerConeAngle:0,outerConeAngle:Math.PI/4},Rc=b.dd.Backward();class pc{constructor(C){this.name=Xc,this.enabled=!0,this.required=!1,this._exporter=C}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Xc]=this._lights}async postExportNodeAsync(C,c,d,X,P){return await new Promise((V=>{if(!(d instanceof eC.b))return void V(c);const R=d.getTypeID()==eC.b.LIGHTTYPEID_POINTLIGHT?"point":d.getTypeID()==eC.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":d.getTypeID()==eC.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!R||!(d instanceof bc.e))return H.d.Warn(`${C}: Light ${d.name} is not supported in ${Xc}`),void V(c);if(d.falloffType!==eC.b.FALLOFF_GLTF&&H.d.Warn(`${C}: Light falloff for ${d.name} does not match the ${Xc} specification!`),!d.position.equalsToFloats(0,0,0)){const C=b.TmpVectors.dd[0].V(d.position);P&&G(C),c.translation=C.rc()}if("point"!==R){const C=d.direction.normalizeToRef(b.TmpVectors.dd[0]);P&&G(C);const X=b.Quaternion.FromUnitVectorsToRef(Rc,C,b.TmpVectors.Quaternion[0]);b.Quaternion.IsIdentity(X)||(c.rotation=X.rc())}const p={type:R,name:d.name,color:d.Ic.rc(),Qc:d.Qc,range:d.range};if(bC(p,Pc),"spot"===R){const C=d;p.spot={innerConeAngle:C.innerAngle/2,outerConeAngle:C.angle/2},bC(p.spot,Vc)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(p);const j={jc:this._lights.lights.length-1},g=d.parent;if(g&&cC(d,g)){const C=X.get(g);if(C){const d=this._exporter._nodes[C];return CC(c,d),d.extensions||(d.extensions={}),d.extensions[Xc]=j,void V(null)}}c.extensions||(c.extensions={}),c.extensions[Xc]=j,V(c)}))}}QC.RegisterExtension(Xc,(C=>new pc(C)));var jc=d(12908);const gc="KHR_materials_anisotropy";class kc{constructor(C){this.name=gc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,c,d){const b=[];return d instanceof jc.b&&d.anisotropy.isEnabled&&!d.anisotropy.legacy?(d.anisotropy.texture&&b.push(d.anisotropy.texture),b):[]}postExportMaterialAsync(C,c,d){return new Promise((C=>{if(d instanceof jc.b){if(!d.anisotropy.isEnabled||d.anisotropy.legacy)return void C(c);this._wasUsed=!0,c.extensions=c.extensions||{};const b=this._exporter._materialExporter.getTextureInfo(d.anisotropy.texture),X={anisotropyStrength:d.anisotropy.Qc,anisotropyRotation:d.anisotropy.angle,anisotropyTexture:b??void 0};null!==X.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(d),c.extensions[gc]=X}C(c)}))}}QC.RegisterExtension(gc,(C=>new kc(C)));const Zc="KHR_materials_clearcoat";class Uc{constructor(C){this.name=Zc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,c,d){const b=[];return d instanceof jc.b&&d.clearCoat.isEnabled?(d.clearCoat.texture&&b.push(d.clearCoat.texture),!d.clearCoat.useRoughnessFromMainTexture&&d.clearCoat.textureRoughness&&b.push(d.clearCoat.textureRoughness),d.clearCoat.bumpTexture&&b.push(d.clearCoat.bumpTexture),b):[]}postExportMaterialAsync(C,c,d){return new Promise((C=>{if(d instanceof jc.b){if(!d.clearCoat.isEnabled)return void C(c);this._wasUsed=!0,c.extensions=c.extensions||{};const b=this._exporter._materialExporter.getTextureInfo(d.clearCoat.texture);let P;P=d.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(d.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(d.clearCoat.textureRoughness),d.clearCoat.isTintEnabled&&X.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${d.name}`),d.clearCoat.remapF0OnInterfaceChange&&X.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${d.name}`);const V=this._exporter._materialExporter.getTextureInfo(d.clearCoat.bumpTexture),R={clearcoatFactor:d.clearCoat.Qc,clearcoatTexture:b??void 0,clearcoatRoughnessFactor:d.clearCoat.roughness,clearcoatRoughnessTexture:P??void 0,clearcoatNormalTexture:V??void 0};null===R.clearcoatTexture&&null===R.clearcoatRoughnessTexture&&null===R.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(d),c.extensions[Zc]=R}C(c)}))}}QC.RegisterExtension(Zc,(C=>new Uc(C)));const Ac="KHR_materials_diffuse_transmission";function uc(C,c){const d=c.subSurface;let b=null;return d.translucencyIntensityTexture?b=d.translucencyIntensityTexture:d.thicknessTexture&&d.useMaskFromThicknessTexture&&(b=d.thicknessTexture),b&&!d.useGltfStyleTextures?(H.d.Warn(`${C}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${c.name}`,1),null):b}class qc{constructor(C){this.name=Ac,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,c,d){const b=[];if(d instanceof AC.c&&this._isExtensionEnabled(d)){const c=uc(C,d);return c&&b.push(c),d.subSurface.translucencyColorTexture&&b.push(d.subSurface.translucencyColorTexture),b}return b}_isExtensionEnabled(C){if(C.unlit)return!1;const c=C.subSurface;return!!c.isTranslucencyEnabled&&(!C.unlit&&!c.useAlbedoToTintTranslucency&&c.useGltfStyleTextures&&1===c.volumeIndexOfRefraction&&0===c.minimumThickness&&0===c.maximumThickness)}postExportMaterialAsync(C,c,d){return new Promise((b=>{if(d instanceof AC.c&&this._isExtensionEnabled(d)){this._wasUsed=!0;const b=d.subSurface,X=uc(C,d),P=0==b.translucencyIntensity?void 0:b.translucencyIntensity,V=this._exporter._materialExporter.getTextureInfo(X)??void 0,R=!b.translucencyColor||b.translucencyColor.equalsFloats(1,1,1)?void 0:b.translucencyColor.rc(),p=this._exporter._materialExporter.getTextureInfo(b.translucencyColorTexture)??void 0,j={diffuseTransmissionFactor:P,diffuseTransmissionTexture:V,diffuseTransmissionColorFactor:R,diffuseTransmissionColorTexture:p};(V||p)&&this._exporter._materialNeedsUVsSet.add(d),c.extensions=c.extensions||{},c.extensions[Ac]=j}b(c)}))}}QC.RegisterExtension(Ac,(C=>new qc(C)));const Bc="KHR_materials_dispersion";class tc{constructor(){this.name=Bc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(C){if(C.unlit)return!1;const c=C.subSurface;return!(!c.isRefractionEnabled&&!c.isDispersionEnabled)}postExportMaterialAsync(C,c,d){return new Promise((C=>{if(d instanceof AC.c&&this._isExtensionEnabled(d)){this._wasUsed=!0;const C={dispersion:d.subSurface.dispersion};c.extensions=c.extensions||{},c.extensions[Bc]=C}C(c)}))}}QC.RegisterExtension(Bc,(()=>new tc));const ec="KHR_materials_emissive_strength";class nc{constructor(){this.name=ec,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(C,c,d){return await new Promise((C=>{if(!(d instanceof AC.c))return C(c);const b=d.emissiveColor.rc(),X=Math.max(...b);if(X>1){this._wasUsed=!0,c.extensions||(c.extensions={});const C={emissiveStrength:X},b=d.emissiveColor.scale(1/C.emissiveStrength);c.emissiveFactor=b.rc(),c.extensions[ec]=C}return C(c)}))}}QC.RegisterExtension(ec,(C=>new nc));const Wc="KHR_materials_ior";class Ec{constructor(){this.name=Wc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(C){return!C.unlit&&(void 0!=C.indexOfRefraction&&1.5!=C.indexOfRefraction)}postExportMaterialAsync(C,c,d){return new Promise((C=>{if(d instanceof AC.c&&this._isExtensionEnabled(d)){this._wasUsed=!0;const C={ior:d.indexOfRefraction};c.extensions=c.extensions||{},c.extensions[Wc]=C}C(c)}))}}QC.RegisterExtension(Wc,(C=>new Ec));const Nc="KHR_materials_iridescence";class rc{constructor(C){this.name=Nc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,c,d){const b=[];return d instanceof jc.b&&d.iridescence.isEnabled?(d.iridescence.texture&&b.push(d.iridescence.texture),d.iridescence.thicknessTexture&&d.iridescence.thicknessTexture!==d.iridescence.texture&&b.push(d.iridescence.thicknessTexture),b):[]}postExportMaterialAsync(C,c,d){return new Promise((C=>{if(d instanceof jc.b){if(!d.iridescence.isEnabled)return void C(c);this._wasUsed=!0,c.extensions=c.extensions||{};const b=this._exporter._materialExporter.getTextureInfo(d.iridescence.texture),X=this._exporter._materialExporter.getTextureInfo(d.iridescence.thicknessTexture),P={iridescenceFactor:d.iridescence.Qc,iridescenceIor:d.iridescence.indexOfRefraction,iridescenceThicknessMinimum:d.iridescence.minimumThickness,iridescenceThicknessMaximum:d.iridescence.maximumThickness,iridescenceTexture:b??void 0,iridescenceThicknessTexture:X??void 0};null===P.iridescenceTexture&&null===P.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(d),c.extensions[Nc]=P}C(c)}))}}QC.RegisterExtension(Nc,(C=>new rc(C)));const Mc="KHR_materials_sheen";class Kc{constructor(C){this.name=Mc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,c,d){return d instanceof AC.c&&d.sheen.isEnabled&&d.sheen.texture?[d.sheen.texture]:[]}async postExportMaterialAsync(C,c,d){return await new Promise((C=>{if(d instanceof AC.c){if(!d.sheen.isEnabled)return void C(c);this._wasUsed=!0,null==c.extensions&&(c.extensions={});const b={sheenColorFactor:d.sheen.color.rc(),sheenRoughnessFactor:d.sheen.roughness??0};null===b.sheenColorTexture&&null===b.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(d),d.sheen.texture&&(b.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(d.sheen.texture)??void 0),d.sheen.textureRoughness&&!d.sheen.useRoughnessFromMainTexture?b.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(d.sheen.textureRoughness)??void 0:d.sheen.texture&&d.sheen.useRoughnessFromMainTexture&&(b.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(d.sheen.texture)??void 0),c.extensions[Mc]=b}C(c)}))}}QC.RegisterExtension(Mc,(C=>new Kc(C)));const ic="KHR_materials_specular";class hc{constructor(C){this.name=ic,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,c,d){const b=[];return d instanceof AC.c&&this._isExtensionEnabled(d)?(d.metallicReflectanceTexture&&b.push(d.metallicReflectanceTexture),d.reflectanceTexture&&b.push(d.reflectanceTexture),b):b}_isExtensionEnabled(C){return!C.unlit&&(void 0!=C.metallicF0Factor&&1!=C.metallicF0Factor||void 0!=C.metallicReflectanceColor&&!C.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(C))}_hasTexturesExtension(C){return null!=C.metallicReflectanceTexture||null!=C.reflectanceTexture}postExportMaterialAsync(C,c,d){return new Promise((C=>{if(d instanceof AC.c&&this._isExtensionEnabled(d)){this._wasUsed=!0,c.extensions=c.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(d.metallicReflectanceTexture)??void 0,b=this._exporter._materialExporter.getTextureInfo(d.reflectanceTexture)??void 0,X={specularFactor:1==d.metallicF0Factor?void 0:d.metallicF0Factor,specularTexture:C,specularColorFactor:d.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:d.metallicReflectanceColor.rc(),specularColorTexture:b};this._hasTexturesExtension(d)&&this._exporter._materialNeedsUVsSet.add(d),c.extensions[ic]=X}C(c)}))}}QC.RegisterExtension(ic,(C=>new hc(C)));const Lc="KHR_materials_transmission";class fc{constructor(C){this.name=Lc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,c,d){const b=[];return d instanceof AC.c&&this._isExtensionEnabled(d)?(d.subSurface.thicknessTexture&&b.push(d.subSurface.thicknessTexture),b):b}_isExtensionEnabled(C){if(C.unlit)return!1;const c=C.subSurface;return c.isRefractionEnabled&&void 0!=c.refractionIntensity&&0!=c.refractionIntensity||this._hasTexturesExtension(C)}_hasTexturesExtension(C){return null!=C.subSurface.refractionIntensityTexture}async postExportMaterialAsync(C,c,d){if(d instanceof AC.c&&this._isExtensionEnabled(d)){this._wasUsed=!0;const b=d.subSurface,X={transmissionFactor:0===b.refractionIntensity?void 0:b.refractionIntensity};if(this._hasTexturesExtension(d)&&this._exporter._materialNeedsUVsSet.add(d),b.refractionIntensityTexture)if(b.useGltfStyleTextures){const C=await this._exporter._materialExporter.exportTextureAsync(b.refractionIntensityTexture,"image/png");C&&(X.transmissionTexture=C)}else H.d.Warn(`${C}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);c.extensions||(c.extensions={}),c.extensions[Lc]=X}return c}}QC.RegisterExtension(Lc,(C=>new fc(C)));const Tc="KHR_materials_unlit";class zc{constructor(){this.name=Tc,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(C,c,d){return new Promise((C=>{let b=!1;d instanceof AC.c?b=d.unlit:d instanceof uC.Rd&&(b=d.disableLighting),b&&(this._wasUsed=!0,null==c.extensions&&(c.extensions={}),c.extensions[Tc]={}),C(c)}))}}QC.RegisterExtension(Tc,(()=>new zc));const wc="KHR_materials_volume";class Jc{constructor(C){this.name=wc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,c,d){const b=[];return d instanceof AC.c&&this._isExtensionEnabled(d)?(d.subSurface.thicknessTexture&&b.push(d.subSurface.thicknessTexture),b):b}_isExtensionEnabled(C){if(C.unlit)return!1;const c=C.subSurface;return!(!c.isRefractionEnabled&&!c.isTranslucencyEnabled)&&(void 0!=c.maximumThickness&&0!=c.maximumThickness||void 0!=c.tintColorAtDistance&&c.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=c.tintColor&&c.tintColor!=q.pd.White()||this._hasTexturesExtension(C))}_hasTexturesExtension(C){return null!=C.subSurface.thicknessTexture}postExportMaterialAsync(C,c,d){return new Promise((C=>{if(d instanceof AC.c&&this._isExtensionEnabled(d)){this._wasUsed=!0;const C=d.subSurface,b={thicknessFactor:0==C.maximumThickness?void 0:C.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(C.thicknessTexture)??void 0,attenuationDistance:C.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:C.tintColorAtDistance,attenuationColor:C.tintColor.equalsFloats(1,1,1)?void 0:C.tintColor.rc()};this._hasTexturesExtension(d)&&this._exporter._materialNeedsUVsSet.add(d),c.extensions=c.extensions||{},c.extensions[wc]=b}C(c)}))}}QC.RegisterExtension(wc,(C=>new Jc(C)));const yc="EXT_materials_diffuse_roughness";class xc{constructor(C){this.name=yc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,c,d){const b=[];return d instanceof jc.b&&d._baseDiffuseRoughness?(d._baseDiffuseRoughnessTexture&&b.push(d._baseDiffuseRoughnessTexture),b):[]}postExportMaterialAsync(C,c,d){return new Promise((C=>{if(d instanceof jc.b){if(!d._baseDiffuseRoughness)return void C(c);this._wasUsed=!0,c.extensions=c.extensions||{};const b=this._exporter._materialExporter.getTextureInfo(d._baseDiffuseRoughnessTexture),X={diffuseRoughnessFactor:d._baseDiffuseRoughness,diffuseRoughnessTexture:b??void 0};null!==X.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(d),c.extensions[yc]=X}C(c)}))}}QC.RegisterExtension(yc,(C=>new xc(C)));const Hc="KHR_texture_transform";class vc{constructor(){this.name=Hc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(C,c,d){if(d.NC()||X.Tools.Warn(`${C}: /*@__KEY__*/"scene" is not defined for Babylon texture ${d.name}!`),(0!==d.uAng||0!==d.vAng)&&(X.Tools.Warn(`${C}: Texture ${d.name} with rotation in the u or v axis is not supported in glTF.`),0!==d.uRotationCenter||0!==d.vRotationCenter))return;const b={};let P=!1;if(0===d.uOffset&&0===d.vOffset||(b.offset=[d.uOffset,d.vOffset],P=!0),1===d.uScale&&1===d.vScale||(b.scale=[d.uScale,d.vScale],P=!0),0!==d.wAng){if(0!==d.uRotationCenter||0!==d.vRotationCenter){if(d.homogeneousRotationInUVTransform&&d.uScale!==d.vScale)return void X.Tools.Warn(`${C}: Texture ${d.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Hc}.`);X.Tools.Warn(`${C}: Texture ${d.name} with non-origin rotation center will be exported using an adjusted offset with ${Hc}.`),b.offset=function(C){const{uOffset:c,vOffset:d,uRotationCenter:b,vRotationCenter:X,uScale:P,vScale:V,wAng:R}=C,p=Math.cos(R),j=Math.sin(R),g=b*P,k=X*V;return[c+(g*(1-p)+k*j),d+(k*(1-p)-g*j)]}(d)}b.rotation=-d.wAng,P=!0}0!==d.coordinatesIndex&&(b.texCoord=d.coordinatesIndex,P=!0),P&&(this._wasUsed=!0,c.extensions||(c.extensions={}),c.extensions[Hc]=b)}}QC.RegisterExtension(Hc,(()=>new vc));class Dc{static CreateSTL(C){let c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",X=arguments.length>3&&void 0!==arguments[3]&&arguments[3],P=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],V=arguments.length>5&&void 0!==arguments[5]&&arguments[5],R=arguments.length>6&&void 0!==arguments[6]&&arguments[6],p=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const j=function(C,c,d){const X=[3*C[d],3*C[d+1],3*C[d+2]],P=[new b.dd(c[X[0]],c[X[0]+2],c[X[0]+1]),new b.dd(c[X[1]],c[X[1]+2],c[X[1]+1]),new b.dd(c[X[2]],c[X[2]+2],c[X[2]+1])],V=P[0].Xd(P[1]),R=P[2].Xd(P[1]);return{v:P,n:b.dd.Cross(R,V).normalize()}},k=function(C,c,d,b){return c=Z(C,c,d.x,b),c=Z(C,c,d.y,b),Z(C,c,d.z,b)},Z=function(C,c,d,b){return C.setFloat32(c,d,b),c+4},A=function(C){if(R){let c=C;C instanceof U.e&&(c=C.sourceMesh);const d=c.getVerticesData(g.g.PositionKind,!0,!0);if(!d)return[];const X=b.dd.Zero();let P;for(P=0;P<d.length;P+=3)b.dd.TransformCoordinatesFromFloatsToRef(d[P],d[P+1],d[P+2],C.Tc(!0),X).toArray(d,P);return d}return C.getVerticesData(g.g.PositionKind)||[]};R&&(V=!0);let u="",q=0,B=0;if(X){for(let d=0;d<C.length;d++){const c=C[d].wc();q+=c?c.length/3:0}const c=new ArrayBuffer(84+50*q);u=new DataView(c),B+=80,u.setUint32(B,q,P),B+=4}else p||(u="solid stlmesh\r\n");for(let b=0;b<C.length;b++){const c=C[b];!X&&p&&(u+="solid "+c.name+"\r\n"),!V&&c instanceof tC.b&&c.bakeCurrentTransformIntoVertices();const d=A(c),R=c.wc()||[];for(let C=0;C<R.length;C+=3){const c=j(R,d,C);X?(B=k(u,B,c.n,P),B=k(u,B,c.v[0],P),B=k(u,B,c.v[1],P),B=k(u,B,c.v[2],P),B+=2):(u+="\tfacet normal "+c.n.x+" "+c.n.y+" "+c.n.z+"\r\n",u+="\t\touter loop\r\n",u+="\t\t\tvertex "+c.v[0].x+" "+c.v[0].y+" "+c.v[0].z+"\r\n",u+="\t\t\tvertex "+c.v[1].x+" "+c.v[1].y+" "+c.v[1].z+"\r\n",u+="\t\t\tvertex "+c.v[2].x+" "+c.v[2].y+" "+c.v[2].z+"\r\n",u+="\t\tendloop\r\n",u+="\tendfacet\r\n")}!X&&p&&(u+="endsolid "+name+"\r\n")}if(X||p||(u+="endsolid stlmesh"),c){const C=document.createElement("a"),c=new Blob([u],{type:"application/octet-stream"});C.href=window.URL.createObjectURL(c),C.download=d+".stl",C.click()}return u}}function sc(C,c){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const b=[];for(let X=0;X<C.length/d;X++){const P=C[X*d],V=C[X*d+1],R=C[X*d+2];b.push(`(${P.toPrecision(c.precision)}, ${V.toPrecision(c.precision)}, ${R.toPrecision(c.precision)})`)}return b.join(", ")}function md(C,c){const d=[];for(let b=0;b<C.length/2;b++){const X=C[2*b],P=C[2*b+1];d.push(`(${X.toPrecision(c.precision)}, ${(1-P).toPrecision(c.precision)})`)}return d.join(", ")}function Qc(C,c){const d=C.getVerticesData(g.g.PositionKind),b=C.getVerticesData(g.g.NormalKind);if(d&&b)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(C){var c;const d=null!==(c=C.wc())&&void 0!==c&&c.length?C.getTotalIndices():C.getTotalVertices();return Array(d/3).fill(3).join(", ")}(C)}]\n\t\tint[] faceVertexIndices = [${function(C){const c=C.wc(),d=[];if(null!==c)for(let b=0;b<c.length;b++)d.push(c[b]);else{const c=C.getTotalVertices();for(let C=0;C<c;C++)d.push(C)}return d.join(", ")}(C)}]\n\t\tnormal3f[] normals = [${sc(b,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${sc(d,c)}]\n        ${function(C,c){let d="";for(let X=0;X<4;X++){const b=X>0?X:"",P=C.getVerticesData(g.g.UVKind+(b?b+1:""));P&&(d+=`\n\t\ttexCoord2f[] primvars:st${b} = [${md(P,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const b=C.getVerticesData(g.g.ColorKind);return b&&(d+=`\n\tcolor3f[] primvars:displayColor = [${sc(b,c,b.length/C.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),d}(C,c)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Ic(C,c){return`\n        def "Geometry"\n        {\n        ${Qc(C,c)}\n        }\n        `}function oc(C){let c='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return c+=C,fflate.strToU8(c)}function Fc(C){const c=C.m;return`( ${Yc(c,0)}, ${Yc(c,4)}, ${Yc(c,8)}, ${Yc(c,12)} )`}function Yc(C,c){return`(${C[c+0]}, ${C[c+1]}, ${C[c+2]}, ${C[c+3]})`}function lc(C){const c="Object_"+C.uniqueId,d=function(C){const c=C.getWorldMatrix().clone(),d=C.NC().useRightHandedSystem;if(!d){let b=C.parent;for(;b;){if(VC(b,d)){c.multiplyToRef(b.getWorldMatrix().invert(),c);break}b=b.parent}}return c.determinant()<0&&X.Tools.Warn(`Exporting mesh ${C.name} with negative scale. Result may look incorrect in destination engine.`),c}(C),b=Fc(d);return`def Xform "${c}" (\n\tprepend references = @./geometries/Geometry_${C.zc.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${b}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${C.material.uniqueId}>\n}\n\n`}function Sc(C){switch(C){case N.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case N.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case N.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Gc(C){return`(${C.x}, ${C.y})`}function ac(C){return`(${C.r}, ${C.g}, ${C.b})`}function Oc(C,c,d,X,P,V){const R=C.getInternalTexture().uniqueId+"_"+C.invertY;P[R]=C;const p=C.coordinatesIndex>0?"st"+C.coordinatesIndex:"st",j=new b.Vector2(C.uScale,C.vScale),g=new b.Vector2(C.uOffset,C.vOffset),k=C.wAng,Z=Math.sin(k),U=Math.cos(k);return g.y=1-g.y-j.y,g.x+=Z*j.x,g.y+=(1-U)*j.y,`\n    def Shader "PrimvarReader_${d}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${p}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${d}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${c.uniqueId}/PrimvarReader_${d}.outputs:result>\n        float inputs:rotation = ${(k*(180/Math.PI)).toFixed(V.precision)}\n        float2 inputs:scale = ${Gc(j)}\n        float2 inputs:translation = ${Gc(g)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${C.uniqueId}_${d}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${R}.png@\n        float2 inputs:st.connect = </Materials/Material_${c.uniqueId}/Transform2d_${d}.outputs:result>\n        ${X?"float4 inputs:scale = "+function(C){return`(${C.r}, ${C.g}, ${C.b}, 1.0)`}(X):""}\n        token inputs:sourceColorSpace = "${C.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Sc(C.wrapU)}"\n        token inputs:wrapT = "${Sc(C.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${c.needAlphaBlending()?"float outputs:a":""}\n    }`}function Cd(C,c,d){const b="\t\t\t",X=[],P=[],{diffuseMap:V,Ic:R,alphaCutOff:p,emissiveMap:j,emissive:g,normalMap:k,roughnessMap:Z,roughnessChannel:U,roughness:A,metalnessMap:u,metalnessChannel:B,metalness:t,aoMap:e,aoMapChannel:n,aoMapIntensity:W,alphaMap:E,ior:N,clearCoatEnabled:r,clearCoat:M,clearCoatMap:K,clearCoatRoughness:i,clearCoatRoughnessMap:h}=function(C){const c={diffuseMap:null,Ic:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return C instanceof uC.Rd?{...c,diffuseMap:C.diffuseTexture,Ic:C.diffuseColor,alphaCutOff:C.alphaCutOff,emissiveMap:C.emissiveTexture,emissive:C.emissiveColor,roughness:1,alphaMap:C.opacityTexture}:C instanceof jc.b?{...c,diffuseMap:C._albedoTexture,Ic:C._albedoColor,alphaCutOff:C._alphaCutOff,emissiveMap:C._emissiveTexture,emissive:C._emissiveColor,normalMap:C._bumpTexture,roughnessMap:C._metallicTexture,roughnessChannel:C._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:C._roughness??1,metalnessMap:C._metallicTexture,metalnessChannel:C._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:C._metallic??0,aoMap:C._ambientTexture,aoMapChannel:C._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:C._ambientTextureStrength,alphaMap:C._opacityTexture,ior:C.subSurface.indexOfRefraction,clearCoatEnabled:C.clearCoat.isEnabled,clearCoat:C.clearCoat.Qc,clearCoatMap:C.clearCoat.texture,clearCoatRoughness:C.clearCoat.roughness,clearCoatRoughnessMap:C.clearCoat.useRoughnessFromMainTexture?C.clearCoat.texture:C.clearCoat.textureRoughness}:c}(C);return null!==V?(X.push(`${b}color3f inputs:diffuseColor.connect = </Materials/Material_${C.uniqueId}/Texture_${V.uniqueId}_diffuse.outputs:rgb>`),C.needAlphaBlending()?X.push(`${b}float inputs:opacity.connect = </Materials/Material_${C.uniqueId}/Texture_${V.uniqueId}_diffuse.outputs:a>`):C.needAlphaTesting()&&(X.push(`${b}float inputs:opacity.connect = </Materials/Material_${C.uniqueId}/Texture_${V.uniqueId}_diffuse.outputs:a>`),X.push(`${b}float inputs:opacityThreshold = ${p}`)),P.push(Oc(V,C,"diffuse",R,c,d))):X.push(`${b}color3f inputs:diffuseColor = ${ac(R||q.pd.White())}`),null!==j?(X.push(`${b}color3f inputs:emissiveColor.connect = </Materials/Material_${C.uniqueId}/Texture_${j.uniqueId}_emissive.outputs:rgb>`),P.push(Oc(j,C,"emissive",g,c,d))):g&&g.toLuminance()>0&&X.push(`${b}color3f inputs:emissiveColor = ${ac(g)}`),null!==k&&(X.push(`${b}normal3f inputs:normal.connect = </Materials/Material_${C.uniqueId}/Texture_${k.uniqueId}_normal.outputs:rgb>`),P.push(Oc(k,C,"normal",null,c,d))),null!==e&&(X.push(`${b}float inputs:occlusion.connect = </Materials/Material_${C.uniqueId}/Texture_${e.uniqueId}_occlusion.outputs:${n}>`),P.push(Oc(e,C,"occlusion",new q.pd(W,W,W),c,d))),null!==Z?(X.push(`${b}float inputs:roughness.connect = </Materials/Material_${C.uniqueId}/Texture_${Z.uniqueId}_roughness.outputs:${U}>`),P.push(Oc(Z,C,"roughness",new q.pd(A,A,A),c,d))):X.push(`${b}float inputs:roughness = ${A}`),null!==u?(X.push(`${b}float inputs:metallic.connect = </Materials/Material_${C.uniqueId}/Texture_${u.uniqueId}_metallic.outputs:${B}>`),P.push(Oc(u,C,"metallic",new q.pd(t,t,t),c,d))):X.push(`${b}float inputs:metallic = ${t}`),null!==E?(X.push(`${b}float inputs:opacity.connect = </Materials/Material_${C.uniqueId}/Texture_${E.uniqueId}_opacity.outputs:r>`),X.push(`${b}float inputs:opacityThreshold = 0.0001`),P.push(Oc(E,C,"opacity",null,c,d))):X.push(`${b}float inputs:opacity = ${C.alpha}`),r&&(null!==K?(X.push(`${b}float inputs:clearcoat.connect = </Materials/Material_${C.uniqueId}/Texture_${K.uniqueId}_clearcoat.outputs:r>`),P.push(Oc(K,C,"clearcoat",new q.pd(M,M,M),c,d))):X.push(`${b}float inputs:clearcoat = ${M}`),null!==h?(X.push(`${b}float inputs:clearcoatRoughness.connect = </Materials/Material_${C.uniqueId}/Texture_${h.uniqueId}_clearcoatRoughness.outputs:g>`),P.push(Oc(h,C,"clearcoatRoughness",new q.pd(i,i,i),c,d))):X.push(`${b}float inputs:clearcoatRoughness = ${i}`)),X.push(`${b}float inputs:ior = ${N}`),`\n\tdef Material "Material_${C.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${X.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${C.uniqueId}/PreviewSurface.outputs:surface>\n\n${P.join("\n")}\n\n\t}\n`}async function cd(C,c,d){const P={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...c};"undefined"===typeof fflate&&await X.Tools.LoadScriptAsync(P.fflateUrl);const V={};V[P.modelFileName]=null;let R='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';R+=function(C){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===C.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${C.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${C.planeAnchoringAlignment}"`:""}\n            `}(P);const p={};for(const b of C.meshes){if(0===b.getTotalVertices())continue;const C=b,c=C.zc,j=C.material;if(!j||!c||d&&!d(C))continue;if(-1!==["Rd","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(j.getClassName())){const d="geometries/Geometry_"+c.uniqueId+".usda";if(!(d in V)){const C=Ic(c,P);V[d]=oc(C)}j.uniqueId in p||(p[j.uniqueId]=j),R+=lc(C)}else X.Tools.Warn("USDZExportAsync does not support this material type: "+j.getClassName())}C.activeCamera&&P.exportCamera&&(R+=function(C,c){const d="Camera_"+C.uniqueId,X=Fc(b.Matrix.RotationY(Math.PI).multiply(C.getWorldMatrix()));if(C.mode===N.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${d}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${X}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${C.Lc.toPrecision(c.precision)}, ${C.maxZ.toPrecision(c.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(C.orthoLeft||1)+Math.abs(C.orthoRight||1))).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(C.orthoTop||1)+Math.abs(C.orthoBottom||1))).toPrecision(c.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const b=C.getEngine().getAspectRatio(C),P=c.cameraSensorWidth||35;return`def Camera "${d}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${X}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${C.Lc.toPrecision(c.precision)}, ${C.maxZ.toPrecision(c.precision)})\n\t\t\tfloat focalLength = ${(P/(2*Math.tan(.5*C.fov))).toPrecision(c.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(P*b).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(P/b).toPrecision(c.precision)}            \n\t\t}\n\t\n\t`}}(C.activeCamera,P)),R+="\n            }\n        }\n    }";const j={};R+=function(C,c,d){const b=[];for(const X in C){const P=C[X];b.push(Cd(P,c,d))}return`\n    def "Materials"\n{\n${b.join("")}\n}\n\n`}(p,j,P),V[P.modelFileName]=fflate.strToU8(R);for(const b in j){const C=j[b],c=C.getSize(),d=await C.readPixels();if(!d)throw new Error("Texture data is not available");const X=await r.DumpTools.DumpDataAsync(c.width,c.height,d,"image/png",void 0,!1,!0);V[`textures/Texture_${b}.png`]=new Uint8Array(X).slice()}let g=0;for(const b in V){const C=V[b];if(!C)continue;g+=34+b.length;const c=63&g;if(4!==c){const d=new Uint8Array(64-c);V[b]=[C,{extra:{12345:d}}]}g=C.length}return fflate.zipSync(V,{level:0})}}}]);