"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[26],{11698:(F,b,Q)=>{Q.r(b),Q.d(b,{EXT_materials_diffuse_roughness:()=>ob,EXT_mesh_gpu_instancing:()=>JF,GLTF2Export:()=>uF,GLTFData:()=>q,KHR_draco_mesh_compression:()=>Qb,KHR_lights_punctual:()=>Zb,KHR_materials_anisotropy:()=>Kb,KHR_materials_clearcoat:()=>Nb,KHR_materials_diffuse_transmission:()=>cb,KHR_materials_dispersion:()=>Lb,KHR_materials_emissive_strength:()=>fb,KHR_materials_ior:()=>mb,KHR_materials_iridescence:()=>pb,KHR_materials_sheen:()=>Pb,KHR_materials_specular:()=>jb,KHR_materials_transmission:()=>Yb,KHR_materials_unlit:()=>Vb,KHR_materials_volume:()=>lb,KHR_texture_transform:()=>Ob,OBJExport:()=>g,STLExport:()=>xb,USDZExportAsync:()=>bQ,_ConvertToGLTFPBRMetallicRoughness:()=>s,_SolveMetallic:()=>Y,__IGLTFExporterExtension:()=>W});var C=Q(11309),z=Q(11128),t=Q(11607);class g{static OBJ(F,b,Q,g){const W=[];let Z=1,q=1;b&&(Q||(Q="mat"),W.push("mtllib "+Q+".mtl"));for(let G=0;G<F.length;G++){const Q=F[G],K=Q.name||`mesh${G}}`;W.push(`o ${K}`);let e=null;if(g){const F=Q.Rb(!0);e=new C.Matrix,F.invertToRef(e),Q.bakeTransformIntoVertices(F)}if(b){const F=Q.material;F&&W.push("usemtl "+F.id)}const N=Q.pb;if(!N){z.Tools.Warn("No geometry is present on the mesh");continue}const y=N.getVerticesData("position"),E=N.getVerticesData("normal"),c=N.getVerticesData("uv"),X=N.Pb();let L=0,i=0;if(!y||!X){z.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const f=F[0].RF().useRightHandedSystem?1:-1;for(let F=0;F<y.length;F+=3)W.push("v "+y[F]*f+" "+y[F+1]+" "+y[F+2]),L++;if(null!=E)for(let F=0;F<E.length;F+=3)W.push("vn "+E[F]*f+" "+E[F+1]+" "+E[F+2]);if(null!=c)for(let F=0;F<c.length;F+=2)W.push("vt "+c[F]+" "+c[F+1]),i++;const k=["","",""],m=(Q.material||Q.RF().defaultMaterial)._getEffectiveOrientation(Q),[R,p]=m===t.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let F=0;F<X.length;F+=3){const b=[String(X[F]+Z),String(X[F+R]+Z),String(X[F+p]+Z)],Q=[String(X[F]+q),String(X[F+R]+q),String(X[F+p]+q)],C=b,z=null!=c?Q:k,t=null!=E?b:k;W.push("f "+C[0]+"/"+z[0]+"/"+t[0]+" "+C[1]+"/"+z[1]+"/"+t[1]+" "+C[2]+"/"+z[2]+"/"+t[2])}g&&e&&Q.bakeTransformIntoVertices(e),Z+=L,q+=i}return W.join("\n")}static MTL(F){const b=[],Q=F.material;b.push("newmtl mat1"),b.push("  Ns "+Q.specularPower.toFixed(4)),b.push("  Ni 1.5000"),b.push("  d "+Q.alpha.toFixed(4)),b.push("  Tr 0.0000"),b.push("  Tf 1.0000 1.0000 1.0000"),b.push("  illum 2"),b.push("  Ka "+Q.ambientColor.r.toFixed(4)+" "+Q.ambientColor.g.toFixed(4)+" "+Q.ambientColor.b.toFixed(4)),b.push("  Kd "+Q.diffuseColor.r.toFixed(4)+" "+Q.diffuseColor.g.toFixed(4)+" "+Q.diffuseColor.b.toFixed(4)),b.push("  Ks "+Q.specularColor.r.toFixed(4)+" "+Q.specularColor.g.toFixed(4)+" "+Q.specularColor.b.toFixed(4)),b.push("  Ke "+Q.emissiveColor.r.toFixed(4)+" "+Q.emissiveColor.g.toFixed(4)+" "+Q.emissiveColor.b.toFixed(4));Q.ambientTexture&&b.push("  map_Ka "+Q.ambientTexture.name),Q.diffuseTexture&&b.push("  map_Kd "+Q.diffuseTexture.name),Q.specularTexture&&b.push("  map_Ks "+Q.specularTexture.name),Q.bumpTexture&&b.push("  map_bump -imfchan z "+Q.bumpTexture.name),Q.opacityTexture&&b.push("  map_d "+Q.opacityTexture.name);return b.join("\n")}}var W=0,Z=Q(11170);class q{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const F in this.files){const b=this.files[F],Q=new Blob([b],{type:(0,Z.k)(F)});z.Tools.Download(Q,F)}}}var G=Q(11372),K=Q(11706),e=Q(11724),N=Q(11738),y=Q(11441),E=Q(11161),c=Q(11359),X=Q(11329);const L=X.HighestCommonFactor,i={...X,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:L};var f=Q(11529),k=Q(11287),m=Q(11768),R=Q(11776),p=Q(11526);const D=1e-6,P=new c.GQ(.04,.04,.04),n=1024,j=c.GQ.White(),w=c.GQ.Black();function Y(F,b,Q){if(b<P.r)return 0;const C=P.r,z=F*Q/(1-P.r)+b-2*P.r,t=z*z-4*C*(P.r-b);return i.Clamp((-z+Math.sqrt(t))/(2*C),0,1)}function s(F){const b=F.diffuseColor.toLinearSpace(F.RF().getEngine().useExactSrgbConversions).scale(.5),Q=F.alpha,z=function(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new C.Vector2(0,1),Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new C.Vector2(0,.1),z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new C.Vector2(0,.1),t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new C.Vector2(1300,.1);return function(F,b,Q,C,z){return(1-F)*(1-F)*(1-F)*b+3*(1-F)*(1-F)*F*Q+3*(1-F)*F*F*C+F*F*F*z}(Math.pow(F/t.x,.333333),b.y,Q.y,z.y,t.y)}(i.Clamp(F.specularPower,0,n));return{baseColorFactor:[b.r,b.g,b.b,Q],metallicFactor:0,roughnessFactor:z}}function V(F,b){b.needAlphaBlending()?F.alphaMode="BLEND":b.needAlphaTesting()&&(F.alphaMode="MASK",F.alphaCutoff=b.alphaCutOff)}function h(F,b,Q){const C=new Uint8Array(F*b*4);for(let z=0;z<C.length;z+=4)C[z]=C[z+1]=C[z+2]=C[z+3]=255;return m.c.CreateRGBATexture(C,F,b,Q)}function l(F){if(F instanceof Uint8Array){const b=F.length,Q=new Float32Array(F.length);for(let C=0;C<b;++C)Q[C]=F[C]/255;return Q}if(F instanceof Float32Array)return F;throw new Error("Unsupported pixel format!")}class T{constructor(F){this._exporter=F,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(F){return F?this._textureMap.get(F)??null:null}async exportStandardMaterialAsync(F,b,Q){const C=s(F),t={name:F.name};if(null==F.nb||F.nb||(F.twoSidedLighting||z.Tools.Warn(F.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),t.doubleSided=!0),Q){const Q=[],z=F.diffuseTexture;z&&Q.push(this.exportTextureAsync(z,b).then((F=>{F&&(C.baseColorTexture=F)})));const g=F.bumpTexture;g&&Q.push(this.exportTextureAsync(g,b).then((F=>{F&&(t.normalTexture=F,1!==g.level&&(t.normalTexture.scale=g.level))})));const W=F.emissiveTexture;W&&(t.emissiveFactor=[1,1,1],Q.push(this.exportTextureAsync(W,b).then((F=>{F&&(t.emissiveTexture=F)}))));const Z=F.ambientTexture;Z&&Q.push(this.exportTextureAsync(Z,b).then((F=>{if(F){const b={index:F.index};t.occlusionTexture=b}}))),Q.length>0&&(this._exporter._materialNeedsUVsSet.add(F),await Promise.all(Q))}(F.alpha<1||F.opacityTexture)&&(F.alphaMode===R.c.ALPHA_COMBINE?t.alphaMode="BLEND":z.Tools.Warn(F.name+": glTF 2.0 does not support alpha mode: "+F.alphaMode.toString())),F.emissiveColor&&!F.emissiveColor.equalsWithEpsilon(w,D)&&(t.emissiveFactor=F.emissiveColor.Lb()),t.pbrMetallicRoughness=C,V(t,F),await this._finishMaterialAsync(t,F,b);const g=this._exporter._materials;return g.push(t),g.length-1}async _finishMaterialAsync(F,b,Q){const C=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",F,b),z=[];for(const t of C)z.push(this.exportTextureAsync(t,Q));await Promise.all(z),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",F,b)}async _getImageDataAsync(F,b,C,z){const t=R.c.TEXTURETYPE_UNSIGNED_BYTE,g=this._exporter._babylonScene,W=g.getEngine(),Z=W.createRawTexture(F,b,C,R.c.TEXTUREFORMAT_RGBA,!1,!0,k.b.NEAREST_SAMPLINGMODE,null,t);W.isWebGPU?await Q.e(51).then(Q.bind(Q,13728)):await Q.e(52).then(Q.bind(Q,13733)),await f.j.ApplyPostProcess("pass",Z,g,t,R.c.TEXTURE_NEAREST_SAMPLINGMODE,R.c.TEXTUREFORMAT_RGBA);const q=await W._readTexturePixels(Z,b,C);return await p.DumpTools.DumpDataAsync(b,C,q,z,void 0,!0,!0)}_resizeTexturesToSameDimensions(F,b,Q){const C=F?F.getSize():{width:0,height:0},z=b?b.getSize():{width:0,height:0};let t,g;return C.width<z.width?(t=F&&F instanceof k.b?f.j.CreateResizedCopy(F,z.width,z.height,!0):h(z.width,z.height,Q),g=b):C.width>z.width?(g=b&&b instanceof k.b?f.j.CreateResizedCopy(b,C.width,C.height,!0):h(C.width,C.height,Q),t=F):(t=F,g=b),{texture1:t,texture2:g}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(F,b,Q,C){const z=new Array;if(!F&&!b)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const t=F?F.RF():b?b.RF():null;if(t){var g;const W=this._resizeTexturesToSameDimensions(F,b,t),Z=null===(g=W.texture1)||void 0===g?void 0:g.getSize();let q,G;const K=Z.width,e=Z.height,N=await W.texture1.readPixels(),y=await W.texture2.readPixels();if(!N)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(q=l(N),!y)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");G=l(y);const E=G.byteLength,X=new Uint8Array(E),L=new Uint8Array(E),i=4,f=w;let k=0,m=0;for(let F=0;F<e;++F)for(let b=0;b<K;++b){const C=(K*F+b)*i,z={diffuseColor:new c.GQ(q[C],q[C+1],q[C+2]).toLinearSpace(t.getEngine().useExactSrgbConversions).multiply(Q.diffuseColor),specularColor:new c.GQ(G[C],G[C+1],G[C+2]).toLinearSpace(t.getEngine().useExactSrgbConversions).multiply(Q.specularColor),glossiness:G[C+3]*Q.glossiness},g=this._convertSpecularGlossinessToMetallicRoughness(z);f.r=Math.max(f.r,g.baseColor.r),f.g=Math.max(f.g,g.baseColor.g),f.b=Math.max(f.b,g.baseColor.b),k=Math.max(k,g.metallic),m=Math.max(m,g.roughness),L[C]=255*g.baseColor.r,L[C+1]=255*g.baseColor.g,L[C+2]=255*g.baseColor.b,L[C+3]=W.texture1.ib?255*q[C+3]:255,X[C]=0,X[C+1]=255*g.roughness,X[C+2]=255*g.metallic,X[C+3]=255}const R={baseColor:f,metallic:k,roughness:m};let p=!1,P=!1;for(let F=0;F<e;++F)for(let b=0;b<K;++b){const Q=(K*F+b)*i;L[Q]/=R.baseColor.r>D?R.baseColor.r:1,L[Q+1]/=R.baseColor.g>D?R.baseColor.g:1,L[Q+2]/=R.baseColor.b>D?R.baseColor.b:1;const C=c.GQ.FromInts(L[Q],L[Q+1],L[Q+2]).toGammaSpace(t.getEngine().useExactSrgbConversions);L[Q]=255*C.r,L[Q+1]=255*C.g,L[Q+2]=255*C.b,C.equalsWithEpsilon(j,D)||(P=!0),X[Q+1]/=R.roughness>D?R.roughness:1,X[Q+2]/=R.metallic>D?R.metallic:1;c.GQ.FromInts(255,X[Q+1],X[Q+2]).equalsWithEpsilon(j,D)||(p=!0)}return p&&z.push(this._getImageDataAsync(X,K,e,C).then((F=>{R.metallicRoughnessTextureData=F}))),P&&z.push(this._getImageDataAsync(L,K,e,C).then((F=>{R.baseColorTextureData=F}))),await Promise.all(z).then((()=>R))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(F){const b=this._getPerceivedBrightness(F.diffuseColor),Q=this._getPerceivedBrightness(F.specularColor),C=1-this._getMaxComponent(F.specularColor),z=Y(b,Q,C),t=F.diffuseColor.scale(C/(1-P.r)/Math.max(1-z)),g=F.specularColor.WQ(P.scale(1-z)).scale(1/Math.max(z));let W=c.GQ.Lerp(t,g,z*z);W=W.clampToRef(0,1,W);return{baseColor:W,metallic:z,roughness:1-F.glossiness}}_getPerceivedBrightness(F){return F?Math.sqrt(.299*F.r*F.r+.587*F.g*F.g+.114*F.b*F.b):0}_getMaxComponent(F){return F?Math.max(F.r,Math.max(F.g,F.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(F,b,Q,C){const z=[],t={baseColor:F._albedoColor,metallic:F._metallic,roughness:F._roughness};if(C){F._albedoTexture&&z.push(this.exportTextureAsync(F._albedoTexture,b).then((F=>{F&&(Q.baseColorTexture=F)})));const C=F._metallicTexture;C&&z.push(this.exportTextureAsync(C,b).then((F=>{F&&(Q.metallicRoughnessTexture=F)})))}return z.length>0&&(this._exporter._materialNeedsUVsSet.add(F),await Promise.all(z)),t}_getTextureSampler(F){const b={};if(!F||!(F instanceof k.b))return b;const Q=this._getGLTFTextureWrapMode(F.wrapU);10497!==Q&&(b.wrapS=Q);const C=this._getGLTFTextureWrapMode(F.wrapV);switch(10497!==C&&(b.wrapT=C),F.samplingMode){case k.b.LINEAR_LINEAR:b.magFilter=9729,b.minFilter=9729;break;case k.b.LINEAR_NEAREST:b.magFilter=9729,b.minFilter=9728;break;case k.b.NEAREST_LINEAR:b.magFilter=9728,b.minFilter=9729;break;case k.b.NEAREST_LINEAR_MIPLINEAR:b.magFilter=9728,b.minFilter=9987;break;case k.b.NEAREST_NEAREST:b.magFilter=9728,b.minFilter=9728;break;case k.b.NEAREST_LINEAR_MIPNEAREST:b.magFilter=9728,b.minFilter=9985;break;case k.b.LINEAR_NEAREST_MIPNEAREST:b.magFilter=9729,b.minFilter=9984;break;case k.b.LINEAR_NEAREST_MIPLINEAR:b.magFilter=9729,b.minFilter=9986;break;case k.b.NEAREST_NEAREST_MIPLINEAR:b.magFilter=9728,b.minFilter=9986;break;case k.b.LINEAR_LINEAR_MIPLINEAR:b.magFilter=9729,b.minFilter=9987;break;case k.b.LINEAR_LINEAR_MIPNEAREST:b.magFilter=9729,b.minFilter=9985;break;case k.b.NEAREST_NEAREST_MIPNEAREST:b.magFilter=9728,b.minFilter=9984}return b}_getGLTFTextureWrapMode(F){switch(F){case k.b.WRAP_ADDRESSMODE:return 10497;case k.b.CLAMP_ADDRESSMODE:return 33071;case k.b.MIRROR_ADDRESSMODE:return 33648;default:return z.Tools.Error(`Unsupported Texture Wrap Mode ${F}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(F,b,Q,C){const z={diffuseColor:F._albedoColor,specularColor:F._reflectivityColor,glossiness:F._microSurface},t=F._albedoTexture,g=F._reflectivityTexture,W=F._useMicroSurfaceFromReflectivityMapAlpha;if(g&&!W)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((t||g)&&C){this._exporter._materialNeedsUVsSet.add(F);const C=this._exportTextureSampler(t||g),W=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(t,g,z,b),Z=this._exporter._textures;if(W.baseColorTextureData){const F=this._exportImage(`baseColor${Z.length}`,b,W.baseColorTextureData);Q.baseColorTexture=this._exportTextureInfo(F,C,null===t||void 0===t?void 0:t.coordinatesIndex)}if(W.metallicRoughnessTextureData){const F=this._exportImage(`metallicRoughness${Z.length}`,b,W.metallicRoughnessTextureData);Q.metallicRoughnessTexture=this._exportTextureInfo(F,C,null===g||void 0===g?void 0:g.coordinatesIndex)}return W}return this._convertSpecularGlossinessToMetallicRoughness(z)}async exportPBRMaterialAsync(F,b,Q){const C={},z={name:F.name},t=F.isMetallicWorkflow();if(t){const b=F._albedoColor,Q=F.alpha;b&&(C.baseColorFactor=[b.r,b.g,b.b,Q])}const g=t?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(F,b,C,Q):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(F,b,C,Q);await this._setMetallicRoughnessPbrMaterialAsync(g,F,z,C,b,Q),await this._finishMaterialAsync(z,F,b);const W=this._exporter._materials;return W.push(z),W.length-1}async _setMetallicRoughnessPbrMaterialAsync(F,b,Q,C,t,g){if(V(Q,b),F.baseColor.equalsWithEpsilon(j,D)&&i.WithinEpsilon(b.alpha,1,D)||(C.baseColorFactor=[F.baseColor.r,F.baseColor.g,F.baseColor.b,b.alpha]),null!=F.metallic&&1!==F.metallic&&(C.metallicFactor=F.metallic),null!=F.roughness&&1!==F.roughness&&(C.roughnessFactor=F.roughness),null==b.nb||b.nb||(b._twoSidedLighting||z.Tools.Warn(b.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Q.doubleSided=!0),g){const F=[],C=b._bumpTexture;C&&F.push(this.exportTextureAsync(C,t).then((F=>{F&&(Q.normalTexture=F,1!==C.level&&(Q.normalTexture.scale=C.level))})));const z=b._ambientTexture;z&&F.push(this.exportTextureAsync(z,t).then((F=>{if(F){const C={index:F.index,texCoord:F.texCoord,extensions:F.extensions};Q.occlusionTexture=C;const z=b._ambientTextureStrength;z&&(C.strength=z)}})));const g=b._emissiveTexture;g&&F.push(this.exportTextureAsync(g,t).then((F=>{F&&(Q.emissiveTexture=F)}))),F.length>0&&(this._exporter._materialNeedsUVsSet.add(b),await Promise.all(F))}const W=b._emissiveColor;W.equalsWithEpsilon(w,D)||(Q.emissiveFactor=W.Lb()),Q.pbrMetallicRoughness=C}_getPixelsFromTextureAsync(F){return function(F){switch(F){case R.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case R.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case R.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case R.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case R.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case R.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case R.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case R.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case R.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case R.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case R.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case R.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case R.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(F.textureFormat)?(0,f.g)(F,F._texture.width,F._texture.height):(F.textureType,R.c.TEXTURETYPE_UNSIGNED_BYTE,F.readPixels())}async exportTextureAsync(F,b){const Q=this._exporter._extensionsPreExportTextureAsync("exporter",F,b);return Q?await Q.then((async Q=>Q?await this._exportTextureInfoAsync(Q,b):await this._exportTextureInfoAsync(F,b))):await this._exportTextureInfoAsync(F,b)}async _exportTextureInfoAsync(F,b){let Q=this._textureMap.get(F);if(!Q){const C=await this._getPixelsFromTextureAsync(F);if(!C)return null;const t=this._exportTextureSampler(F),g=F.mimeType;if(g)switch(g){case"image/jpeg":case"image/png":case"image/webp":b=g;break;default:z.Tools.Warn(`Unsupported media type: ${g}. Exporting texture as PNG.`)}const W=this._internalTextureToImage,Z=F.getInternalTexture().uniqueId;W[Z]||(W[Z]={});let q=W[Z][b];if(void 0===q){const Q=F.getSize();q=(async()=>{const z=await this._getImageDataAsync(C,Q.width,Q.height,b);return this._exportImage(F.name,b,z)})(),W[Z][b]=q}Q=this._exportTextureInfo(await q,t,F.coordinatesIndex),this._textureMap.set(F,Q),this._exporter._extensionsPostExportTextures("exporter",Q,F)}return Q}_exportImage(F,b,Q){const C=this._exporter._images;let t;if(this._exporter._shouldUseGlb){t={name:F,mimeType:b,bufferView:void 0};const C=this._exporter._bufferManager.createBufferView(new Uint8Array(Q));this._exporter._bufferManager.setBufferView(t,C)}else{const g=F.replace(/\.\/|\/|\.\\|\\/g,"_"),W=function(F){switch(F){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(b);let Z=g+W;C.some((F=>F.uri===Z))&&(Z=`${g}_${z.Tools.RandomId()}${W}`),t={name:F,uri:Z},this._exporter._imageData[Z]={data:Q,mimeType:b}}return C.push(t),C.length-1}_exportTextureInfo(F,b,Q){const C=this._exporter._textures;let z=C.findIndex((Q=>Q.sampler==b&&Q.source===F));-1===z&&(z=C.length,C.push({source:F,sampler:b}));const t={index:z};return Q&&(t.texCoord=Q),t}_exportTextureSampler(F){const b=this._getTextureSampler(F),Q=this._exporter._samplers,C=Q.findIndex((F=>F.minFilter===b.minFilter&&F.magFilter===b.magFilter&&F.wrapS===b.wrapS&&F.wrapT===b.wrapT));return-1!==C?C:(Q.push(b),Q.length-1)}}var o=Q(11384),S=Q(11146),O=Q(11783),x=Q(11318);const a=C.gQ.Zero(),A=C.Quaternion.Identity(),U=C.gQ.One(),u=new C.gQ(-1,1,1);function v(F,b){const{byteOffset:Q,byteStride:C,type:z,normalized:t}=F,g=F.getSize(),W=b.reduce(((F,b)=>b.getTotalVertices()>F?b.getTotalVertices():F),-Number.MAX_VALUE);return{byteOffset:Q,byteStride:C,componentCount:g,type:z,count:W*g,normalized:t,totalVertices:W,kind:F.getKind()}}function J(F){switch(F){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function I(F){switch(F){case G.e.PositionKind:case G.e.NormalKind:case G.e.TangentKind:case G.e.ColorKind:case G.e.MatricesIndicesKind:case G.e.MatricesIndicesExtraKind:case G.e.MatricesWeightsKind:case G.e.MatricesWeightsExtraKind:case G.e.UVKind:case G.e.UV2Kind:case G.e.UV3Kind:case G.e.UV4Kind:case G.e.UV5Kind:case G.e.UV6Kind:return!0}return!1}function M(F){switch(F){case t.c.TriangleFillMode:return 4;case t.c.TriangleStripDrawMode:return 5;case t.c.TriangleFanDrawMode:return 6;case t.c.PointListDrawMode:case t.c.PointFillMode:return 0;case t.c.LineLoopDrawMode:return 2;case t.c.LineListDrawMode:return 1;case t.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${F}`)}function r(F){const b=Math.sqrt(F.x*F.x+F.y*F.y+F.z*F.z);b>0&&(F.x/=b,F.y/=b,F.z/=b)}function H(F){return F.x*=-1,F}function B(F){if(F.x*F.x+F.y*F.y>.5){const b=Math.abs(F.x),Q=Math.abs(F.y);if(b>Q){const Q=Math.sign(F.x);F.x=b,F.y*=-Q,F.z*=-Q,F.w*=Q}else{const b=Math.sign(F.y);F.x*=-b,F.y=Q,F.z*=b,F.w*=-b}}else{const b=Math.abs(F.z),Q=Math.abs(F.w);if(b>Q){const Q=Math.sign(F.z);F.x*=-Q,F.y*=Q,F.z=b,F.w*=-Q}else{const b=Math.sign(F.w);F.x*=b,F.y*=-b,F.z*=-b,F.w=Q}}return F}function d(F){F.jb(-F.z,F.w,F.x,-F.y)}function FF(F,b){const Q=C.gQ.FromArrayToRef(b.translation||[0,0,0],0,C.TmpVectors.gQ[0]),z=C.Quaternion.FromArrayToRef(b.rotation||[0,0,0,1],0,C.TmpVectors.Quaternion[0]),t=C.Matrix.ComposeToRef(U,z,Q,C.TmpVectors.Matrix[0]),g=C.gQ.FromArrayToRef(F.translation||[0,0,0],0,C.TmpVectors.gQ[2]),W=C.Quaternion.FromArrayToRef(F.rotation||[0,0,0,1],0,C.TmpVectors.Quaternion[1]),Z=C.Matrix.ComposeToRef(U,W,g,C.TmpVectors.Matrix[1]);t.multiplyToRef(Z,Z),Z.decompose(void 0,z,Q),Q.equalsWithEpsilon(a,x.c)?delete b.translation:b.translation=Q.Lb(),z.equalsWithEpsilon(A,x.c)?delete b.rotation:b.rotation=z.Lb(),b.scale&&delete b.scale}function bF(F,b){if(!(b instanceof K.d))return!1;if(!(1===b.getChildren().length&&0===F.getChildren().length&&F.parent===b))return!1;const Q=F.RF(),C=F instanceof O.e&&!Q.useRightHandedSystem?u:U;return!!b.wb.equalsWithEpsilon(C,x.c)||(S.e.Warn(`Cannot collapse node ${F.name} into parent node ${b.name} with modified scaling.`),!1)}function QF(F){if(F instanceof Array){const b=new Float32Array(F);return new Uint8Array(b.buffer,b.byteOffset,b.byteLength)}return ArrayBuffer.isView(F)?new Uint8Array(F.buffer,F.byteOffset,F.byteLength):new Uint8Array(F)}function CF(F,b){for(const[Q,C]of Object.entries(F)){const z=b[Q];(Array.isArray(C)&&Array.isArray(z)&&zF(C,z)||C===z)&&delete F[Q]}return F}function zF(F,b){return F.length===b.length&&F.every(((F,Q)=>F===b[Q]))}const tF=C.Matrix.Compose(new C.gQ(-1,1,1),C.Quaternion.Identity(),C.gQ.Zero());function gF(F,b){if(!(F instanceof K.d))return!1;if(b){if(!F.getWorldMatrix().equalsWithEpsilon(C.Matrix.IdentityReadOnly,x.c))return!1}else{if(!F.getWorldMatrix().multiplyToRef(tF,C.TmpVectors.Matrix[0]).equalsWithEpsilon(C.Matrix.IdentityReadOnly,x.c))return!1}return!(F instanceof e.d&&F.pb)}const WF=new Map([[Int8Array,(F,b,Q)=>F.setInt8(b,Q)],[Uint8Array,(F,b,Q)=>F.setUint8(b,Q)],[Uint8ClampedArray,(F,b,Q)=>F.setUint8(b,Q)],[Int16Array,(F,b,Q)=>F.setInt16(b,Q,!0)],[Uint16Array,(F,b,Q)=>F.setUint16(b,Q,!0)],[Int32Array,(F,b,Q)=>F.setInt32(b,Q,!0)],[Uint32Array,(F,b,Q)=>F.setUint32(b,Q,!0)],[Float32Array,(F,b,Q)=>F.setFloat32(b,Q,!0)],[Float64Array,(F,b,Q)=>F.setFloat64(b,Q,!0)]]);class ZF{writeTypedArray(F){this._checkGrowBuffer(F.byteLength);const b=WF.get(F.constructor);for(let Q=0;Q<F.length;Q++)b(this._dataView,this._byteOffset,F[Q]),this._byteOffset+=F.BYTES_PER_ELEMENT}constructor(F){this._data=new Uint8Array(F),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(F){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,F),this._byteOffset++}writeInt8(F){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,F),this._byteOffset++}writeInt16(F){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,F,!0),this._byteOffset+=2}writeUInt16(F){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,F,!0),this._byteOffset+=2}writeInt32(F){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,F,!0),this._byteOffset+=4}writeUInt32(F){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,F,!0),this._byteOffset+=4}writeFloat32(F){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,F,!0),this._byteOffset+=4}writeFloat64(F){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,F,!0),this._byteOffset+=8}_checkGrowBuffer(F){const b=this.byteOffset+F;if(b>this._data.byteLength){const F=new Uint8Array(2*b);F.set(this._data),this._data=F,this._dataView=new DataView(this._data.buffer)}}}function qF(F){return F%4===0?4:F%2===0?2:1}class GF{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(F){let b=0;this._bufferViewToData.forEach((F=>{b+=F.byteLength}));const Q=new ZF(b),C=Array.from(this._bufferViewToData.keys()).sort(((F,b)=>qF(b.byteLength)-qF(F.byteLength)));for(const z of C){z.byteOffset=Q.byteOffset,F.push(z);const b=F.length-1,C=this.getPropertiesWithBufferView(z);for(const F of C)F.bufferView=b;Q.writeTypedArray(this._bufferViewToData.get(z)),this._bufferViewToData.delete(z)}return Q.getOutputData()}createBufferView(F,b){const Q={buffer:0,byteOffset:void 0,byteLength:F.byteLength,byteStride:b};return this._bufferViewToData.set(Q,F),Q}createAccessor(F,b,Q,C,z,t,g){this._verifyBufferView(F);const W={bufferView:void 0,componentType:Q,count:C,type:b,min:null===t||void 0===t?void 0:t.min,max:null===t||void 0===t?void 0:t.max,normalized:g,byteOffset:z};return this.setBufferView(W,F),this._accessorToBufferView.set(W,F),W}setBufferView(F,b){this._verifyBufferView(b);this.getPropertiesWithBufferView(b).push(F)}removeBufferView(F){const b=this.getPropertiesWithBufferView(F);for(const Q of b)void 0!==Q.bufferView&&delete Q.bufferView;this._bufferViewToData.delete(F),this._bufferViewToProperties.delete(F),this._accessorToBufferView.forEach(((b,Q)=>{b===F&&(void 0!==Q.byteOffset&&delete Q.byteOffset,this._accessorToBufferView.delete(Q))}))}getBufferView(F){const b=this._accessorToBufferView.get(F);return this._verifyBufferView(b),b}getPropertiesWithBufferView(F){return this._verifyBufferView(F),this._bufferViewToProperties.set(F,this._bufferViewToProperties.get(F)??[]),this._bufferViewToProperties.get(F)}getData(F){return this._verifyBufferView(F),this._bufferViewToData.get(F)}_verifyBufferView(F){if(void 0===F||!this._bufferViewToData.has(F))throw new Error(`BufferView ${F} not found in BufferManager.`)}}var KF,eF=Q(11750),NF=Q(11764),yF=Q(11791),EF=Q(11662),cF=Q(11812),XF=Q(11823),LF=Q(11746),iF=Q(11827);!function(F){F[F.INTANGENT=0]="INTANGENT",F[F.OUTTANGENT=1]="OUTTANGENT"}(KF||(KF={}));class fF{static _IsTransformable(F){return F&&(F instanceof K.d||F instanceof eF.b||F instanceof iF.e)}static _CreateNodeAnimation(F,b,Q,C,t){if(this._IsTransformable(F)){const g=[],W=[],Z=b.getKeys(),q=fF._CalculateMinMaxKeyFrames(Z),G=fF._DeduceInterpolation(Z,Q,C),K=G.interpolationType,e=G.shouldBakeAnimation;if(e?fF._CreateBakedAnimation(F,b,Q,q.min,q.max,b.framePerSecond,t,g,W,q,C):"LINEAR"===K||"STEP"===K?fF._CreateLinearOrStepAnimation(F,b,Q,g,W,C):"CUBICSPLINE"===K?fF._CreateCubicSplineAnimation(F,b,Q,g,W,C):fF._CreateBakedAnimation(F,b,Q,q.min,q.max,b.framePerSecond,t,g,W,q,C),g.length&&W.length){return{inputs:g,outputs:W,samplerInterpolation:K,inputsMin:e?q.min:z.Tools.FloatRound(q.min/b.framePerSecond),inputsMax:e?q.max:z.Tools.FloatRound(q.max/b.framePerSecond)}}}return null}static _DeduceAnimationInfo(F){let b=null,Q="VEC3",C=!1;const t=F.targetProperty.split(".");switch(t[0]){case"wb":b="scale";break;case"position":b="translation";break;case"rotation":Q="VEC4",b="rotation";break;case"rotationQuaternion":Q="VEC4",C=!0,b="rotation";break;case"influence":Q="SCALAR",b="weights";break;default:z.Tools.Error(`Unsupported animatable property ${t[0]}`)}return b?{animationChannelTargetPath:b,dataAccessorType:Q,useQuaternion:C}:(z.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(F,b,Q,C,z,t,g,W,Z,q,G){let K;if(fF._IsTransformable(F)&&F.animations)for(const e of F.animations){if(G&&!G(e))continue;const z=fF._DeduceAnimationInfo(e);z&&(K={name:e.name,samplers:[],channels:[]},fF._AddAnimation(`${e.name}`,e.hasRunningRuntimeAnimations?b:K,F,e,z.dataAccessorType,z.animationChannelTargetPath,C,t,g,W,z.useQuaternion,Z,q),K.samplers.length&&K.channels.length&&Q.push(K))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(F,b,Q,C,z,t,g,W,Z,q,G){let K;if(F instanceof LF.b){const z=F.morphTargetManager;if(z)for(let e=0;e<z.numTargets;++e){const N=z.getTarget(e);for(const y of N.animations){if(G&&!G(y))continue;const N=new cF.b(`${y.name}`,"influence",y.framePerSecond,y.dataType,y.loopMode,y.enableBlending),E=[],c=y.getKeys();for(let F=0;F<c.length;++F){const b=c[F];for(let F=0;F<z.numTargets;++F)F==e?E.push(b):E.push({frame:b.frame,value:0})}N.setKeys(E);const X=fF._DeduceAnimationInfo(N);X&&(K={name:N.name,samplers:[],channels:[]},fF._AddAnimation(y.name,y.hasRunningRuntimeAnimations?b:K,F,N,X.dataAccessorType,X.animationChannelTargetPath,C,t,g,W,X.useQuaternion,Z,q,z.numTargets),K.samplers.length&&K.channels.length&&Q.push(K))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(F,b,Q,C,z,t,g,W,Z){let q;if(F.animationGroups){const K=F.animationGroups;for(const e of K){const K=new Map,N=new Map,y=new Set,E=e.to-e.from;q={name:e.name,channels:[],samplers:[]};for(let b=0;b<e.targetedAnimations.length;++b){const E=e.targetedAnimations[b],c=E.target,X=E.animation;if(Z&&!Z(X))continue;const L=W.has(c);if(this._IsTransformable(c)||1===c.length&&this._IsTransformable(c[0])){const F=fF._DeduceAnimationInfo(E.animation);if(F){const b=this._IsTransformable(c)?c:this._IsTransformable(c[0])?c[0]:null;b&&fF._AddAnimation(`${X.name}`,q,b,X,F.dataAccessorType,F.animationChannelTargetPath,Q,C,z,t,F.useQuaternion,g,L)}}else if(c instanceof XF.d||1===c.length&&c[0]instanceof XF.d){if(fF._DeduceAnimationInfo(E.animation)){const b=c instanceof XF.d?c:c[0];if(b){const Q=F.morphTargetManagers.find((F=>{for(let Q=0;Q<F.numTargets;++Q)if(F.getTarget(Q)===b)return!0;return!1}));if(Q){const C=F.meshes.find((F=>F.morphTargetManager===Q));var G;if(C)K.has(C)||K.set(C,new Map),null===(G=K.get(C))||void 0===G||G.set(b,X),y.add(C),N.set(C,X)}}}}}y.forEach((F=>{const b=F.morphTargetManager;let W=null;const Z=[],G=N.get(F).getKeys(),y=G.length;for(let Q=0;Q<y;++Q)for(let C=0;C<b.numTargets;++C){const z=b.getTarget(C),t=K.get(F);if(t){const b=t.get(z);b?(W||(W=new cF.b(`${e.name}_${F.name}_MorphWeightAnimation`,"influence",b.framePerSecond,cF.b.ANIMATIONTYPE_FLOAT,b.loopMode,b.enableBlending)),Z.push(b.getKeys()[Q])):Z.push({frame:e.from+E/y*Q,value:z.influence,inTangent:G[0].inTangent?0:void 0,outTangent:G[0].outTangent?0:void 0})}}W.setKeys(Z);const c=fF._DeduceAnimationInfo(W);c&&fF._AddAnimation(`${e.name}_${F.name}_MorphWeightAnimation`,q,F,W,c.dataAccessorType,c.animationChannelTargetPath,Q,C,z,t,c.useQuaternion,g,!1,null===b||void 0===b?void 0:b.numTargets)})),q.channels.length&&q.samplers.length&&b.push(q)}}}static _AddAnimation(F,b,Q,z,t,g,W,Z,q,G,K,e,N,y){const E=fF._CreateNodeAnimation(Q,z,g,K,e);let c,X,L,i,f,k;if(E){if(y){let F=0,b=0;const Q=[];for(;E.inputs.length>0;)b=E.inputs.shift(),F%y==0&&Q.push(b),F++;E.inputs=Q}const F=W.get(Q),z=new Float32Array(E.inputs);c=Z.createBufferView(z),X=Z.createAccessor(c,"SCALAR",5126,E.inputs.length,void 0,{min:[E.inputsMin],max:[E.inputsMax]}),G.push(X),L=G.length-1;const q=new C.Quaternion,K=new C.gQ,e=new C.gQ,m=Q instanceof eF.b,R=J(t),p=new Float32Array(E.outputs.length*R);E.outputs.forEach((function(F,b){let Q=F;switch(g){case"translation":N&&(C.gQ.FromArrayToRef(F,0,e),H(e),e.toArray(Q));break;case"rotation":4===F.length?C.Quaternion.FromArrayToRef(F,0,q):(Q=new Array(4),C.gQ.FromArrayToRef(F,0,K),C.Quaternion.FromEulerVectorToRef(K,q)),N&&(B(q),m&&d(q)),q.toArray(Q)}p.set(Q,b*R)})),c=Z.createBufferView(p),X=Z.createAccessor(c,t,5126,E.outputs.length),G.push(X),i=G.length-1,f={interpolation:E.samplerInterpolation,input:L,output:i},b.samplers.push(f),k={sampler:b.samplers.length-1,target:{node:F,path:g}},b.channels.push(k)}}static _CreateBakedAnimation(F,b,Q,t,g,W,Z,q,G,K,e){let N;const y=C.Quaternion.Identity();let E,c=null,X=null,L=null,i=null,f=null,k=null;K.min=z.Tools.FloatRound(t/W);const m=b.getKeys();for(let C=0,R=m.length;C<R;++C){if(k=null,L=m[C],C+1<R)if(i=m[C+1],L.value.equals&&L.value.equals(i.value)||L.value===i.value){if(0!==C)continue;k=L.frame}else k=i.frame;else{if(f=m[C-1],L.value.equals&&L.value.equals(f.value)||L.value===f.value)continue;k=g}if(k)for(let C=L.frame;C<=k;C+=Z){if(E=z.Tools.FloatRound(C/W),E===c)continue;c=E,X=E;const t={key:0,repeatCount:0,loopMode:b.loopMode};N=b._interpolate(C,t),fF._SetInterpolatedValue(F,N,E,b,Q,y,q,G,e)}}X&&(K.max=X)}static _ConvertFactorToVector3OrQuaternion(F,b,Q,t,g){const W=fF._GetBasePositionRotationOrScale(b,t,g),Z=Q.targetProperty.split("."),q=Z?Z[1]:"",G=g?C.Quaternion.KQ(W).normalize():C.gQ.KQ(W);switch(q){case"x":case"y":case"z":G[q]=F;break;case"w":G.w=F;break;default:z.Tools.Error(`glTFAnimation: Unsupported component name "${q}"!`)}return G}static _SetInterpolatedValue(F,b,Q,z,t,g,W,Z,q){let G;W.push(Q),"weights"!==t?(z.dataType===cF.b.ANIMATIONTYPE_FLOAT&&(b=this._ConvertFactorToVector3OrQuaternion(b,F,z,t,q)),"rotation"===t?(q?g=b:(G=b,C.Quaternion.RotationYawPitchRollToRef(G.y,G.x,G.z,g)),Z.push(g.Lb())):(G=b,Z.push(G.Lb()))):Z.push([b])}static _CreateLinearOrStepAnimation(F,b,Q,C,z,t){for(const g of b.getKeys())C.push(g.frame/b.framePerSecond),fF._AddKeyframeValue(g,b,z,Q,F,t)}static _CreateCubicSplineAnimation(F,b,Q,C,z,t){b.getKeys().forEach((function(g){C.push(g.frame/b.framePerSecond),fF._AddSplineTangent(KF.INTANGENT,z,Q,"CUBICSPLINE",g,t),fF._AddKeyframeValue(g,b,z,Q,F,t),fF._AddSplineTangent(KF.OUTTANGENT,z,Q,"CUBICSPLINE",g,t)}))}static _GetBasePositionRotationOrScale(F,b,Q){let z;if("rotation"===b)if(Q){z=(F.rotationQuaternion??C.Quaternion.Identity()).Lb()}else{z=(F.rotation??C.gQ.Zero()).Lb()}else if("translation"===b){z=(F.position??C.gQ.Zero()).Lb()}else{z=(F.wb??C.gQ.One()).Lb()}return z}static _AddKeyframeValue(F,b,Q,t,g,W){let Z;const q=b.dataType;if(q===cF.b.ANIMATIONTYPE_VECTOR3){let b=F.value.Lb();if("rotation"===t){const F=C.gQ.KQ(b);b=C.Quaternion.RotationYawPitchRoll(F.y,F.x,F.z).Lb()}Q.push(b)}else if(q===cF.b.ANIMATIONTYPE_FLOAT){if("weights"===t)Q.push([F.value]);else if(Z=this._ConvertFactorToVector3OrQuaternion(F.value,g,b,t,W),Z){if("rotation"===t){const F=W?Z:C.Quaternion.RotationYawPitchRoll(Z.y,Z.x,Z.z).normalize();Q.push(F.Lb())}Q.push(Z.Lb())}}else q===cF.b.ANIMATIONTYPE_QUATERNION?Q.push(F.value.normalize().Lb()):z.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(F,b,Q){let C,z,t=!1;if("rotation"===b&&!Q)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let g=0,W=F.length;g<W;++g)if(z=F[g],z.inTangent||z.outTangent)if(C){if("CUBICSPLINE"!==C){C="LINEAR",t=!0;break}}else C="CUBICSPLINE";else if(C){if("CUBICSPLINE"===C||z.interpolation&&1===z.interpolation&&"STEP"!==C){C="LINEAR",t=!0;break}}else C=z.interpolation&&1===z.interpolation?"STEP":"LINEAR";return C||(C="LINEAR"),{interpolationType:C,shouldBakeAnimation:t}}static _AddSplineTangent(F,b,Q,z,t,g){let W;const Z=F===KF.INTANGENT?t.inTangent:t.outTangent;if("CUBICSPLINE"===z){if("rotation"===Q)if(Z)if(g)W=Z.Lb();else{const F=Z;W=C.Quaternion.RotationYawPitchRoll(F.y,F.x,F.z).Lb()}else W=[0,0,0,0];else W="weights"===Q?Z?[Z]:[0]:Z?Z.Lb():[0,0,0];b.push(W)}}static _CalculateMinMaxKeyFrames(F){let b=1/0,Q=-1/0;return F.forEach((function(F){b=Math.min(b,F.frame),Q=Math.max(Q,F.frame)})),{min:b,max:Q}}}function kF(F,b,Q,t,g,W){const Z={attributes:{},influence:F.influence,name:F.name},q=b.pb;if(!q)return z.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),Z;const K=W?-1:1,e=C.gQ.Zero();let N=0,y=0;if(F.hasPositions){const t=F.getPositions(),W=q.getVerticesData(G.e.PositionKind);if(W){const F=new Float32Array(W.length),b=[1/0,1/0,1/0],z=[-1/0,-1/0,-1/0];y=W.length/3,N=0;for(let Q=N;Q<y;++Q){const g=C.gQ.KQ(W,3*Q);C.gQ.KQ(t,3*Q).subtractToRef(g,e),e.x*=K,b[0]=Math.min(b[0],e.x),z[0]=Math.max(z[0],e.x),b[1]=Math.min(b[1],e.y),z[1]=Math.max(z[1],e.y),b[2]=Math.min(b[2],e.z),z[2]=Math.max(z[2],e.z),F[3*Q]=e.x,F[3*Q+1]=e.y,F[3*Q+2]=e.z}const q=Q.createBufferView(F,12),G=Q.createAccessor(q,"VEC3",5126,t.length/3,0,{min:b,max:z});g.push(G),Z.attributes.POSITION=g.length-1}else z.Tools.Warn(`Morph target positions for mesh ${b.name} were not exported. Mesh does not have position vertex data`)}if(F.hasNormals){const t=F.getNormals(),W=q.getVerticesData(G.e.NormalKind);if(W){const F=new Float32Array(W.length);y=W.length/3,N=0;for(let Q=N;Q<y;++Q){const b=C.gQ.KQ(W,3*Q).normalize();C.gQ.KQ(t,3*Q).normalize().subtractToRef(b,e),F[3*Q]=e.x*K,F[3*Q+1]=e.y,F[3*Q+2]=e.z}const b=Q.createBufferView(F,12),z=Q.createAccessor(b,"VEC3",5126,t.length/3,0);g.push(z),Z.attributes.NORMAL=g.length-1}else z.Tools.Warn(`Morph target normals for mesh ${b.name} were not exported. Mesh does not have normals vertex data`)}if(F.hasTangents){const t=F.getTangents(),W=q.getVerticesData(G.e.TangentKind);if(W){y=W.length/4;const F=new Float32Array(3*y);N=0;for(let Q=N;Q<y;++Q){const b=C.gQ.KQ(W,4*Q);r(b);const z=C.gQ.KQ(t,3*Q);r(z),z.subtractToRef(b,e),F[3*Q]=e.x*K,F[3*Q+1]=e.y,F[3*Q+2]=e.z}const b=Q.createBufferView(F,12),z=Q.createAccessor(b,"VEC3",5126,y,0);g.push(z),Z.attributes.TANGENT=g.length-1}else z.Tools.Warn(`Morph target tangents for mesh ${b.name} were not exported. Mesh does not have tangents vertex data`)}if(F.hasColors){const t=F.getColors(),W=q.getVerticesData(G.e.ColorKind),K=q.getVertexBuffer(G.e.ColorKind);if(W&&K){const F=K.getSize();y=W.length/F;const b=new Float32Array(y*F);N=0;for(let Q=N;Q<y;++Q)if(3===F){const z=C.gQ.KQ(W,Q*F);C.gQ.KQ(t,Q*F).subtractToRef(z,e),b[3*Q]=e.x,b[3*Q+1]=e.y,b[3*Q+2]=e.z}else if(4===F){const z=new C.Vector4,g=C.Vector4.KQ(W,Q*F);C.Vector4.KQ(t,Q*F).subtractToRef(g,z),b[4*Q]=z.x,b[4*Q+1]=z.y,b[4*Q+2]=z.z,b[4*Q+3]=z.w}else z.Tools.Warn(`Unsupported number of components for color attribute: ${F}`);const q=Q.createBufferView(b,4*F),G=Q.createAccessor(q,3===F?"VEC3":"VEC4",5126,y,0);g.push(G),Z.attributes.COLOR_0=g.length-1}else z.Tools.Warn(`Morph target colors for mesh ${b.name} were not exported. Mesh does not have colors vertex data`)}return Z}var mF=Q(11835),RF=Q(11690),pF=Q(11673),DF=Q(11265);class PF{}PF.DEFAULT_COLOR=c.GQ.White(),PF.DEFAULT_WIDTH_ATTENUATED=1,PF.DEFAULT_WIDTH=.1;var nF=Q(11515),jF=Q(11840);class wF{static ConvertPoints(F,b){if(F.length&&Array.isArray(F)&&"number"===typeof F[0])return[F];if(F.length&&Array.isArray(F[0])&&"number"===typeof F[0][0])return F;if(F.length&&!Array.isArray(F[0])&&F[0]instanceof C.gQ){const b=[];for(let Q=0;Q<F.length;Q++){const C=F[Q];b.push(C.x,C.y,C.z)}return[b]}if(F.length>0&&Array.isArray(F[0])&&F[0].length>0&&F[0][0]instanceof C.gQ){const b=[],Q=F;for(const F of Q)b.push(F.flatMap((F=>[F.x,F.y,F.z])));return b}if(F instanceof Float32Array){if(null!==b&&void 0!==b&&b.floatArrayStride){const Q=[],C=3*b.floatArrayStride;for(let b=0;b<F.length;b+=C){const z=new Array(C);for(let Q=0;Q<C;Q++)z[Q]=F[b+Q];Q.push(z)}return Q}return[Array.from(F)]}if(F.length&&F[0]instanceof Float32Array){const b=[];for(const Q of F)b.push(Array.from(Q));return b}return[]}static OmitZeroLengthPredicate(F,b,Q){const C=[];return b.WQ(F).lengthSquared()>0&&C.push([F,b]),Q.WQ(b).lengthSquared()>0&&C.push([b,Q]),F.WQ(Q).lengthSquared()>0&&C.push([Q,F]),0===C.length?null:C}static OmitDuplicatesPredicate(F,b,Q,C){const z=[];return wF._SearchInPoints(F,b,C)||z.push([F,b]),wF._SearchInPoints(b,Q,C)||z.push([b,Q]),wF._SearchInPoints(Q,F,C)||z.push([Q,F]),0===z.length?null:z}static _SearchInPoints(F,b,Q){for(const g of Q)for(let Q=0;Q<g.length;Q++){var C,z,t;if(null!==(C=g[Q])&&void 0!==C&&C.equals(F))if(null!==(z=g[Q+1])&&void 0!==z&&z.equals(b)||null!==(t=g[Q-1])&&void 0!==t&&t.equals(b))return!0}return!1}static MeshesToLines(F,b){const Q=[];for(let z=0;z<F.length;z++){const t=F[z],g=t.getVerticesData(G.e.PositionKind),W=t.Pb();if(g&&W)for(let F=0,Z=0;F<W.length;F++){const q=3*W[Z++],G=3*W[Z++],K=3*W[Z++],e=new C.gQ(g[q],g[q+1],g[q+2]),N=new C.gQ(g[G],g[G+1],g[G+2]),y=new C.gQ(g[K],g[K+1],g[K+2]);if(b){const C=b(e,N,y,Q,F,q,t,z,g,W);if(C)for(const F of C)Q.push(F)}else Q.push([e,N],[N,y],[y,e])}}return Q}static ToVector3Array(F){if(Array.isArray(F[0])){const b=[],Q=F;for(const F of Q){const Q=[];for(let b=0;b<F.length;b+=3)Q.push(new C.gQ(F[b],F[b+1],F[b+2]));b.push(Q)}return b}const b=F,Q=[];for(let z=0;z<b.length;z+=3)Q.push(new C.gQ(b[z],b[z+1],b[z+2]));return Q}static ToNumberArray(F){return F.flatMap((F=>[F.x,F.y,F.z]))}static GetPointsCountInfo(F){const b=new Array(F.length);let Q=0;for(let C=F.length;C--;)b[C]=F[C].length/3,Q+=b[C];return{total:Q,counts:b}}static GetLineLength(F){if(0===F.length)return 0;let b;b="number"===typeof F[0]?wF.ToVector3Array(F):F;const Q=C.TmpVectors.gQ[0];let z=0;for(let C=0;C<b.length-1;C++){const F=b[C];z+=b[C+1].subtractToRef(F,Q).length()}return z}static GetLineLengthArray(F){const b=new Float32Array(F.length/3);let Q=0;for(let C=0,z=F.length/3-1;C<z;C++){let z=F[3*C+0],t=F[3*C+1],g=F[3*C+2];z-=F[3*C+3],t-=F[3*C+4],g-=F[3*C+5];Q+=Math.sqrt(z*z+t*t+g*g),b[C+1]=Q}return b}static SegmentizeSegmentByCount(F,b,Q){const z=[],t=b.WQ(F),g=C.TmpVectors.gQ[0];g.Yb(Q);const W=C.TmpVectors.gQ[1];t.divideToRef(g,W);let Z=F.clone();z.push(Z);for(let C=0;C<Q;C++)Z=Z.clone(),z.push(Z.addInPlace(W));return z}static SegmentizeLineBySegmentLength(F,b){const Q=F[0]instanceof C.gQ?wF.GetLineSegments(F):"number"===typeof F[0]?wF.GetLineSegments(wF.ToVector3Array(F)):F,z=[];for(const C of Q)if(C.length>b){const F=wF.SegmentizeSegmentByCount(C.point1,C.point2,Math.ceil(C.length/b));for(const b of F)z.push(b)}else z.push(C.point1),z.push(C.point2);return z}static SegmentizeLineBySegmentCount(F,b){const Q="number"===typeof F[0]?wF.ToVector3Array(F):F,C=wF.GetLineLength(Q)/b;return wF.SegmentizeLineBySegmentLength(Q,C)}static GetLineSegments(F){const b=[];for(let Q=0;Q<F.length-1;Q++){const C=F[Q],z=F[Q+1],t=z.WQ(C).length();b.push({point1:C,point2:z,length:t})}return b}static GetMinMaxSegmentLength(F){const b=wF.GetLineSegments(F).sort((F=>F.length));return{min:b[0].length,max:b[b.length-1].length}}static GetPositionOnLineByVisibility(F,b,Q){let z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const t=b*Q;let g=0,W=0;const Z=F.length;for(let C=0;C<Z;C++){if(t<=g+F[C].length){W=C;break}g+=F[C].length}const q=(t-g)/F[W].length;return F[W].point2.subtractToRef(F[W].point1,C.TmpVectors.gQ[0]),C.TmpVectors.gQ[1]=C.TmpVectors.gQ[0].multiplyByFloats(q,q,q),z||C.TmpVectors.gQ[1].addInPlace(F[W].point1),C.TmpVectors.gQ[1].clone()}static GetCircleLinePoints(F,b){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:F,t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/b;const g=[];for(let W=0;W<=b;W++)g.push(new C.gQ(Math.cos(W*t)*F,Math.sin(W*t)*z,Q));return g}static GetBezierLinePoints(F,b,Q,C){return nF.g.CreateQuadraticBezier(F,b,Q,C).getPoints().flatMap((F=>[F.x,F.y,F.z]))}static GetArrowCap(F,b,Q,C,z){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[F.clone(),F.add(b.multiplyByFloats(Q,Q,Q))],widths:[C,z,t,g]}}static GetPointsFromText(F,b,Q,C){let z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const g=[],W=(0,jF.b)(F,b,Q,C);for(const Z of W){for(const F of Z.paths){const b=[],Q=F.getPoints();for(const F of Q)b.push(F.x,F.y,z);g.push(b)}if(t)for(const F of Z.holes){const b=[],Q=F.getPoints();for(const F of Q)b.push(F.x,F.y,z);g.push(b)}}return g}static Color3toRGBAUint8(F){const b=new Uint8Array(4*F.length);for(let Q=0,C=0;Q<F.length;Q++)b[C++]=255*F[Q].r,b[C++]=255*F[Q].g,b[C++]=255*F[Q].b,b[C++]=255;return b}static CreateColorsTexture(F,b,Q,C){const z=C.getEngine().getCaps().maxTextureSize??1,t=b.length>z?z:b.length,g=Math.ceil(b.length/z);g>1&&(b=[...b,...Array(t*g-b.length).fill(b[0])]);const W=wF.Color3toRGBAUint8(b),Z=new m.c(W,t,g,y.c.TEXTUREFORMAT_RGBA,C,!1,!0,Q);return Z.name=F,Z}static PrepareEmptyColorsTexture(F){if(!PF.EmptyColorsTexture){const b=new Uint8Array(4);PF.EmptyColorsTexture=new m.c(b,1,1,y.c.TEXTUREFORMAT_RGBA,F,!1,!1,m.c.NEAREST_NEAREST),PF.EmptyColorsTexture.name="grlEmptyColorsTexture"}return PF.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var F;null===(F=PF.EmptyColorsTexture)||void 0===F||F.dispose(),PF.EmptyColorsTexture=null}static BooleanToNumber(F){return F?1:0}}class YF extends pF.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class sF extends RF.e{isCompatible(F){return!0}constructor(F,b,Q){var z;Q=Q||{color:PF.DEFAULT_COLOR};const t=new YF;t.GREASED_LINE_HAS_COLOR=!!Q.color&&!Q.useColors,t.GREASED_LINE_SIZE_ATTENUATION=Q.sizeAttenuation??!1,t.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===Q.colorDistributionType,t.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(b??F.RF()).useRightHandedSystem,t.GREASED_LINE_CAMERA_FACING=Q.cameraFacing??!0,super(F,sF.GREASED_LINE_MATERIAL_NAME,200,t,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(z=Q)||void 0===z?void 0:z.forceGLSL)||sF.ForceGLSL,this._scene=b??F.RF(),this._engine=this._scene.getEngine(),this._cameraFacing=Q.cameraFacing??!0,this.visibility=Q.visibility??1,this.useDash=Q.useDash??!1,this.dashRatio=Q.dashRatio??.5,this.dashOffset=Q.dashOffset??0,this.width=Q.width?Q.width:Q.sizeAttenuation?PF.DEFAULT_WIDTH_ATTENUATED:PF.DEFAULT_WIDTH,this._sizeAttenuation=Q.sizeAttenuation??!1,this.colorMode=Q.colorMode??0,this._color=Q.color??null,this.useColors=Q.useColors??!1,this._colorsDistributionType=Q.colorDistributionType??0,this.colorsSampling=Q.colorsSampling??m.c.NEAREST_NEAREST,this._colors=Q.nF??null,this.dashCount=Q.dashCount??1,this.resolution=Q.resolution??new C.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),Q.colorsTexture?this.colorsTexture=Q.colorsTexture:this._colors?this.colorsTexture=wF.CreateColorsTexture(`${F.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??PF.DEFAULT_COLOR,wF.PrepareEmptyColorsTexture(this._scene)),this._engine.Kb.add((()=>{wF.DisposeEmptyColorsTexture()}))}getAttributes(F){F.push("grl_offsets"),F.push("grl_widths"),F.push("grl_colorPointers"),F.push("grl_counters"),this._cameraFacing?(F.push("grl_previousAndSide"),F.push("grl_nextAndCounters")):F.push("grl_slopes")}getSamplers(F){F.push("grl_colors")}getActiveTextures(F){this.colorsTexture&&F.push(this.colorsTexture)}getUniforms(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const b=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&b.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===F&&b.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:b,vertex:this._cameraFacing&&this._isGLSL(F)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(F)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(F){if(this._cameraFacing){F.mb("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||F.mb("viewProjection",this._scene.getTransformMatrix());const b=C.TmpVectors.Vector4[0];b.x=this._aspect,b.y=this._resolution.x,b.z=this._resolution.y,b.w=this.width,F.updateVector4("grl_aspect_resolution_lineWidth",b)}const b=C.TmpVectors.Vector4[0];b.x=wF.BooleanToNumber(this.useDash),b.y=this._dashArray,b.z=this.dashOffset,b.w=this.dashRatio,F.updateVector4("grl_dashOptions",b);const Q=C.TmpVectors.Vector4[1];Q.x=this.colorMode,Q.y=this.visibility,Q.z=this.colorsTexture?this.colorsTexture.getSize().width:0,Q.w=wF.BooleanToNumber(this.useColors),F.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",Q),this._color&&F.updateColor3("grl_singleColor",this._color);const z=this.colorsTexture??PF.EmptyColorsTexture;F.setTexture("grl_colors",z),F.updateFloat2("grl_textureSize",(null===z||void 0===z?void 0:z.getSize().width)??1,(null===z||void 0===z?void 0:z.getSize().height)??1)}prepareDefines(F,b,Q){F.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,F.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,F.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,F.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=b.useRightHandedSystem,F.GREASED_LINE_CAMERA_FACING=this._cameraFacing,F.GREASED_LINE_USE_OFFSETS=!!Q.offsets}getClassName(){return sF.GREASED_LINE_MATERIAL_NAME}getCustomCode(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(b)?function(F,b){if("vertex"===F){const F={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return b&&(F["!gl_Position\\=viewProjection\\*worldPos;"]="//"),F}return"fragment"===F?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(F,this._cameraFacing):function(F,b){if("vertex"===F){const F={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return b&&(F["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),F}return"fragment"===F?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(F,this._cameraFacing)}dispose(){var F;null===(F=this.colorsTexture)||void 0===F||F.dispose(),super.dispose()}get nF(){return this._colors}set nF(F){this.setColors(F)}setColors(F){var b;let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const z=(null===(b=this._colors)||void 0===b?void 0:b.length)??0;var t;if(this._colors=F,null!==F&&0!==F.length){if(!Q||C)if(this.colorsTexture&&z===F.length&&!C){const b=wF.Color3toRGBAUint8(F);this.colorsTexture.update(b)}else{var g;null===(g=this.colorsTexture)||void 0===g||g.dispose(),this.colorsTexture=wF.CreateColorsTexture(`${this._material.name}-colors-texture`,F,this.colorsSampling,this._scene)}}else null===(t=this.colorsTexture)||void 0===t||t.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(F){this._dashCount=F,this._dashArray=1/F}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(F){this._sizeAttenuation=F,this.markAllDefinesAsDirty()}get color(){return this._color}set color(F){this.setColor(F)}setColor(F){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==F||null!==this._color&&null===F?(this._color=F,b||this.markAllDefinesAsDirty()):this._color=F}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(F){this._colorsDistributionType=F,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(F){this._aspect=F.x/F.y,this._resolution=F}serialize(){const F=super.serialize(),b={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(b.nF=this._colors),this._color&&(b.color=this._color),F.greasedLineMaterialOptions=b,F}parse(F,b,Q){var C;super.parse(F,b,Q);const z=F.greasedLineMaterialOptions;null===(C=this.colorsTexture)||void 0===C||C.dispose(),z.color&&this.setColor(z.color,!0),z.colorDistributionType&&(this.colorsDistributionType=z.colorDistributionType),z.nF&&(this.nF=z.nF),z.colorsSampling&&(this.colorsSampling=z.colorsSampling),z.colorMode&&(this.colorMode=z.colorMode),z.useColors&&(this.useColors=z.useColors),z.visibility&&(this.visibility=z.visibility),z.useDash&&(this.useDash=z.useDash),z.dashCount&&(this.dashCount=z.dashCount),z.dashRatio&&(this.dashRatio=z.dashRatio),z.dashOffset&&(this.dashOffset=z.dashOffset),z.width&&(this.width=z.width),z.sizeAttenuation&&(this.sizeAttenuation=z.sizeAttenuation),z.resolution&&(this.resolution=z.resolution),this.nF?this.colorsTexture=wF.CreateColorsTexture(`${this._material.name}-colors-texture`,this.nF,this.colorsSampling,b):wF.PrepareEmptyColorsTexture(b),this.markAllDefinesAsDirty()}copyTo(F){var b;const Q=F;null===(b=Q.colorsTexture)||void 0===b||b.dispose(),this._colors&&(Q.colorsTexture=wF.CreateColorsTexture(`${Q._material.name}-colors-texture`,this._colors,Q.colorsSampling,this._scene)),Q.setColor(this.color,!0),Q.colorsDistributionType=this.colorsDistributionType,Q.colorsSampling=this.colorsSampling,Q.colorMode=this.colorMode,Q.useColors=this.useColors,Q.visibility=this.visibility,Q.useDash=this.useDash,Q.dashCount=this.dashCount,Q.dashRatio=this.dashRatio,Q.dashOffset=this.dashOffset,Q.width=this.width,Q.sizeAttenuation=this.sizeAttenuation,Q.resolution=this.resolution,Q.markAllDefinesAsDirty()}_isGLSL(F){return 0===F||this._forceGLSL}}sF.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",sF.ForceGLSL=!1,(0,DF.g)(`BABYLON.${sF.GREASED_LINE_MATERIAL_NAME}`,sF);var VF=Q(11730),hF=Q(11148),lF=Q(11534),TF=Q(11250);class oF extends lF.ShaderMaterial{constructor(F,b,z){const t=b.getEngine(),g=t.isWebGPU&&!(z.forceGLSL||oF.ForceGLSL),W=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];b.useRightHandedSystem&&W.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const Z=["position","grl_widths","grl_offsets","grl_colorPointers"];z.cameraFacing?(W.push("GREASED_LINE_CAMERA_FACING"),Z.push("grl_previousAndSide","grl_nextAndCounters")):(Z.push("grl_slopes"),Z.push("grl_counters"));const q=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(g||q.push("world","viewProjection","view","projection"),super(F,b,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:g?["Scene","Mesh"]:void 0,attributes:Z,uniforms:q,samplers:g?[]:["grlColors"],defines:W,extraInitializationsAsync:async()=>{g?await Promise.all([Q.e(66).then(Q.bind(Q,14383)),Q.e(75).then(Q.bind(Q,14392))]):await Promise.all([Q.e(69).then(Q.bind(Q,14400)),Q.e(76).then(Q.bind(Q,14403))])},shaderLanguage:g?1:0}),this._color=c.GQ.White(),this._colorsDistributionType=0,this._colorsTexture=null,z=z||{color:PF.DEFAULT_COLOR},this.visibility=z.visibility??1,this.useDash=z.useDash??!1,this.dashRatio=z.dashRatio??.5,this.dashOffset=z.dashOffset??0,this.dashCount=z.dashCount??1,this.width=z.width?z.width:z.sizeAttenuation&&z.cameraFacing?PF.DEFAULT_WIDTH_ATTENUATED:PF.DEFAULT_WIDTH,this.sizeAttenuation=z.sizeAttenuation??!1,this.color=z.color??c.GQ.White(),this.useColors=z.useColors??!1,this.colorsDistributionType=z.colorDistributionType??0,this.colorsSampling=z.colorsSampling??m.c.NEAREST_NEAREST,this.colorMode=z.colorMode??0,this._colors=z.nF??null,this._cameraFacing=z.cameraFacing??!0,this.resolution=z.resolution??new C.Vector2(t.getRenderWidth(),t.getRenderHeight()),z.colorsTexture?this.colorsTexture=z.colorsTexture:this._colors?this.colorsTexture=wF.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,b):(this._color=this._color??PF.DEFAULT_COLOR,this.colorsTexture=wF.PrepareEmptyColorsTexture(b)),g){const F=new TF.d;F.setParameters(),F.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",F)}t.Kb.add((()=>{wF.DisposeEmptyColorsTexture()}))}dispose(){var F;null===(F=this._colorsTexture)||void 0===F||F.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new C.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get nF(){return this._colors}set nF(F){this.setColors(F)}setColors(F){var b;let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const z=(null===(b=this._colors)||void 0===b?void 0:b.length)??0;var t;if(this._colors=F,null!==F&&0!==F.length){if(!Q||C)if(this._colorsTexture&&z===F.length&&!C){const b=wF.Color3toRGBAUint8(F);this._colorsTexture.update(b)}else{var g;null===(g=this._colorsTexture)||void 0===g||g.dispose(),this.colorsTexture=wF.CreateColorsTexture(`${this.name}-colors-texture`,F,this.colorsSampling,this.RF())}}else null===(t=this._colorsTexture)||void 0===t||t.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(F){this._colorsTexture=F,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(F){this._width=F,this.setFloat("grlWidth",F)}get useColors(){return this._useColors}set useColors(F){this._useColors=F,this.setFloat("grlUseColors",wF.BooleanToNumber(F))}get colorsSampling(){return this._colorsSampling}set colorsSampling(F){this._colorsSampling=F}get visibility(){return this._visibility}set visibility(F){this._visibility=F,this.setFloat("grlVisibility",F)}get useDash(){return this._useDash}set useDash(F){this._useDash=F,this.setFloat("grlUseDash",wF.BooleanToNumber(F))}get dashOffset(){return this._dashOffset}set dashOffset(F){this._dashOffset=F,this.setFloat("grlDashOffset",F)}get dashRatio(){return this._dashRatio}set dashRatio(F){this._dashRatio=F,this.setFloat("grlDashRatio",F)}get dashCount(){return this._dashCount}set dashCount(F){this._dashCount=F,this._dashArray=1/F,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(F){this._sizeAttenuation=F,this.setFloat("grlSizeAttenuation",wF.BooleanToNumber(F))}get color(){return this._color}set color(F){this.setColor(F)}setColor(F){F=F??PF.DEFAULT_COLOR,this._color=F,this.setColor3("grlColor",F)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(F){this._colorsDistributionType=F,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(F){this._colorMode=F,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(F){this._resolution=F,this.setVector2("grlResolution",F),this.setFloat("grlAspect",F.x/F.y)}serialize(){const F=super.serialize(),b={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(b.nF=this._colors),F.greasedLineMaterialOptions=b,F}parse(F,b,Q){var C;const z=F.greasedLineMaterialOptions;null===(C=this._colorsTexture)||void 0===C||C.dispose(),z.color&&(this.color=z.color),z.colorDistributionType&&(this.colorsDistributionType=z.colorDistributionType),z.colorsSampling&&(this.colorsSampling=z.colorsSampling),z.colorMode&&(this.colorMode=z.colorMode),z.useColors&&(this.useColors=z.useColors),z.visibility&&(this.visibility=z.visibility),z.useDash&&(this.useDash=z.useDash),z.dashCount&&(this.dashCount=z.dashCount),z.dashRatio&&(this.dashRatio=z.dashRatio),z.dashOffset&&(this.dashOffset=z.dashOffset),z.width&&(this.width=z.width),z.sizeAttenuation&&(this.sizeAttenuation=z.sizeAttenuation),z.resolution&&(this.resolution=z.resolution),z.nF?this.colorsTexture=wF.CreateColorsTexture(`${this.name}-colors-texture`,z.nF,this.colorsSampling,this.RF()):this.colorsTexture=wF.PrepareEmptyColorsTexture(b),this._cameraFacing=z.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var SF,OF,xF;oF.ForceGLSL=!1,function(F){F[F.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",F[F.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(SF||(SF={})),function(F){F[F.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",F[F.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",F[F.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(OF||(OF={})),function(F){F[F.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",F[F.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",F[F.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",F[F.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",F[F.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(xF||(xF={}));class aF extends LF.b{constructor(F,b,Q){super(F,b,null,null,!1,!1),this.name=F,this._options=Q,this._lazy=!1,this._updatable=!1,this._engine=b.getEngine(),this._lazy=Q.lazy??!1,this._updatable=Q.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=Q.colorPointers??[],this._widths=Q.widths??new Array(Q.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(F){let b=0;for(const C of this._points)b+=C.length;const Q=b/3*2-this._widths.length;for(let C=0;C<Q;C++)this._widths.push(F)}updateLazy(){var F,b;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(F=this._options.ribbonOptions)||void 0===F?void 0:F.smoothShading),!this.sF&&this.refreshBoundingInfo(),null===(b=this.greasedLineMaterial)||void 0===b||b.updateLazy()}addPoints(F,b){for(const Q of F)this._points.push(Q);this._lazy||this.setPoints(this._points,b)}dispose(F){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(F,b)}isLazy(){return this._lazy}get jF(){return this._uvs}set jF(F){this._uvs=F instanceof Float32Array?F:new Float32Array(F),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(F){this.material instanceof oF&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===F||void 0===F?void 0:F.length)>0),this._offsets=F,this._offsetsBuffer?this._offsetsBuffer.update(F):this._createOffsetsBuffer(F)}get widths(){return this._widths}set widths(F){this._widths=F,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(F)}get colorPointers(){return this._colorPointers}set colorPointers(F){this._colorPointers=F,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(F)}get greasedLineMaterial(){var F,b;if(this.material&&this.material instanceof oF)return this.material;const Q=null===(F=this.material)||void 0===F||null===(b=F.pluginManager)||void 0===b?void 0:b.getPlugin(sF.GREASED_LINE_MATERIAL_NAME);return Q||void 0}get points(){const F=[];return hF.d.DeepCopy(this._points,F),F}setPoints(F,b){this._points=wF.ConvertPoints(F,(null===b||void 0===b?void 0:b.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==b&&void 0!==b&&b.colorPointers||this._updateColorPointers(),this._setPoints(this._points,b)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,jF:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(F){super.serialize(F),F.type=this.getClassName(),F.lineOptions=this._createLineOptions()}_createVertexBuffers(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new VF.d;return b.DF=this._vertexPositions,b.indices=this._indices,b.jF=this._uvs,F&&(b.PF=[],VF.d.ComputeNormals(this._vertexPositions,this._indices,b.PF)),b.YF(this,this._options.updatable),b}_createOffsetsBuffer(F){const b=this._scene.getEngine(),Q=new G.d(b,F,this._updatable,3);this.setVerticesBuffer(Q.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=Q}}class AF{constructor(F,b){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=F,this.wasAddedByNoopNode=b}getIndicesAccessor(F,b,Q,C,z){var t,g,W,Z;return null===(t=this._indicesAccessorMap.get(F))||void 0===t||null===(g=t.get(b))||void 0===g||null===(W=g.get(Q))||void 0===W||null===(Z=W.get(C))||void 0===Z?void 0:Z.get(z)}setIndicesAccessor(F,b,Q,C,z,t){let g=this._indicesAccessorMap.get(F);g||(g=new Map,this._indicesAccessorMap.set(F,g));let W=g.get(b);W||(W=new Map,g.set(b,W));let Z=W.get(Q);Z||(Z=new Map,W.set(Q,Z));let q=Z.get(C);q||(q=new Map,Z.set(C,q)),q.set(z,t)}pushExportedNode(F){this._exportedNodes.has(F)||this._exportedNodes.add(F)}getNodesSet(){return this._exportedNodes}getVertexBufferView(F){return this._vertexBufferViewMap.get(F)}setVertexBufferView(F,b){this._vertexBufferViewMap.set(F,b)}setRemappedBufferView(F,b,Q){this._remappedBufferView.set(F,new Map),this._remappedBufferView.get(F).set(b,Q)}getRemappedBufferView(F,b){var Q;return null===(Q=this._remappedBufferView.get(F))||void 0===Q?void 0:Q.get(b)}getVertexAccessor(F,b,Q){var C,z;return null===(C=this._vertexAccessorMap.get(F))||void 0===C||null===(z=C.get(b))||void 0===z?void 0:z.get(Q)}setVertexAccessor(F,b,Q,C){let z=this._vertexAccessorMap.get(F);z||(z=new Map,this._vertexAccessorMap.set(F,z));let t=z.get(b);t||(t=new Map,z.set(b,t)),t.set(Q,C)}hasVertexColorAlpha(F){return this._vertexMapColorAlpha.get(F)||!1}setHasVertexColorAlpha(F,b){return this._vertexMapColorAlpha.set(F,b)}getMesh(F){return this._meshMap.get(F)}setMesh(F,b){this._meshMap.set(F,b)}bindMorphDataToMesh(F,b){const Q=this._meshMorphTargetMap.get(F)||[];this._meshMorphTargetMap.set(F,Q),-1===Q.indexOf(b)&&Q.push(b)}getMorphTargetsFromMesh(F){return this._meshMorphTargetMap.get(F)}}class UF{_ApplyExtension(F,b,Q,C){if(Q>=b.length)return Promise.resolve(F);const z=C(b[Q],F);return z?z.then((async F=>F?await this._ApplyExtension(F,b,Q+1,C):null)):this._ApplyExtension(F,b,Q+1,C)}_ApplyExtensions(F,b){const Q=[];for(const C of UF._ExtensionNames)Q.push(this._extensions[C]);return this._ApplyExtension(F,Q,0,b)}_extensionsPreExportTextureAsync(F,b,Q){return this._ApplyExtensions(b,((b,C)=>b.preExportTextureAsync&&b.preExportTextureAsync(F,C,Q)))}_extensionsPostExportNodeAsync(F,b,Q,C,z){return this._ApplyExtensions(b,((b,t)=>b.postExportNodeAsync&&b.postExportNodeAsync(F,t,Q,C,z,this._bufferManager)))}_extensionsPostExportMaterialAsync(F,b,Q){return this._ApplyExtensions(b,((b,C)=>b.postExportMaterialAsync&&b.postExportMaterialAsync(F,C,Q)))}_extensionsPostExportMaterialAdditionalTextures(F,b,Q){const C=[];for(const z of UF._ExtensionNames){const t=this._extensions[z];t.postExportMaterialAdditionalTextures&&C.push(...t.postExportMaterialAdditionalTextures(F,b,Q))}return C}_extensionsPostExportTextures(F,b,Q){for(const C of UF._ExtensionNames){const z=this._extensions[C];z.postExportTexture&&z.postExportTexture(F,b,Q)}}_extensionsPostExportMeshPrimitive(F){for(const b of UF._ExtensionNames){const Q=this._extensions[b];Q.postExportMeshPrimitive&&Q.postExportMeshPrimitive(F,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const F of UF._ExtensionNames){const b=this._extensions[F];b.preGenerateBinaryAsync&&await b.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(F){for(const b of UF._ExtensionNames){const Q=this._extensions[b];Q.enabled&&F(Q)}}_extensionsOnExporting(){this._forEachExtensions((F=>{var b,Q,C;F.wasUsed&&((b=this._glTF).extensionsUsed||(b.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(F.name)&&this._glTF.extensionsUsed.push(F.name),F.required&&((Q=this._glTF).extensionsRequired||(Q.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(F.name)&&this._glTF.extensionsRequired.push(F.name)),(C=this._glTF).extensions||(C.extensions={}),F.onExporting&&F.onExporting())}))}_loadExtensions(){for(const F of UF._ExtensionNames){const b=UF._ExtensionFactories[F](this);this._extensions[F]=b}}constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:E.d.LastCreatedScene,b=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${y.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new T(this),this._extensions={},this._bufferManager=new GF,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!F)throw new Error("No scene available to export");this._babylonScene=F,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:F=>{var b;return null===F||void 0===F||null===(b=F.yb)||void 0===b?void 0:b.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...b},this._loadExtensions()}dispose(){for(const F in this._extensions){this._extensions[F].dispose()}}get options(){return this._options}static RegisterExtension(F,b){UF.UnregisterExtension(F)&&z.Tools.Warn(`Extension with the name ${F} already exists`),UF._ExtensionFactories[F]=b,UF._ExtensionNames.push(F)}static UnregisterExtension(F){if(!UF._ExtensionFactories[F])return!1;delete UF._ExtensionFactories[F];const b=UF._ExtensionNames.indexOf(F);return-1!==b&&UF._ExtensionNames.splice(b,1),!0}_generateJSON(F,b,Q){const C={byteLength:F};return C.byteLength&&(this._glTF.buffers=[C]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.ZQ=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(C.uri=b+".bin"),Q?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(F){const b=await this._generateBinaryAsync();this._extensionsOnExporting();const Q=this._generateJSON(b.byteLength,F,!0),C=new Blob([b],{type:"application/octet-stream"}),z=F+".gltf",t=F+".bin",g=new q;if(g.files[z]=Q,g.files[t]=C,this._imageData)for(const W in this._imageData)g.files[W]=new Blob([this._imageData[W].data],{type:this._imageData[W].mimeType});return g}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(F){const b=F%4;return 0===b?b:4-b}async generateGLBAsync(F){this._shouldUseGlb=!0;const b=await this._generateBinaryAsync();this._extensionsOnExporting();const Q=this._generateJSON(b.byteLength),C=F+".glb";let z,t=Q.length;if("undefined"!==typeof TextEncoder){z=(new TextEncoder).encode(Q),t=z.length}const g=this._getPadding(t),W=this._getPadding(b.byteLength),Z=28+t+g+b.byteLength+W,G=new ZF(Z);if(G.writeUInt32(1179937895),G.writeUInt32(2),G.writeUInt32(Z),G.writeUInt32(t+g),G.writeUInt32(1313821514),z)G.writeTypedArray(z);else{const F="_".charCodeAt(0);for(let b=0;b<t;++b){const C=Q.charCodeAt(b);C!=Q.codePointAt(b)?G.writeUInt8(F):G.writeUInt8(C)}}for(let q=0;q<g;++q)G.writeUInt8(32);G.writeUInt32(b.byteLength+W),G.writeUInt32(5130562),G.writeTypedArray(b);for(let q=0;q<W;++q)G.writeUInt8(0);const K=new q;return K.files[C]=new Blob([G.getOutputData()],{type:"application/octet-stream"}),K}_setNodeTransformation(F,b,Q){if(b.getPivotPoint().equalsWithEpsilon(a,x.c)||z.Tools.Warn("Pivot points are not supported in the glTF serializer"),!b.position.equalsWithEpsilon(a,x.c)){const z=C.TmpVectors.gQ[0].W(b.position);Q&&H(z),F.translation=z.Lb()}b.wb.equalsWithEpsilon(U,x.c)||(F.scale=b.wb.Lb());const t=b.rotationQuaternion||C.Quaternion.FromEulerAngles(b.rotation.x,b.rotation.y,b.rotation.z);t.equalsWithEpsilon(A,x.c)||(Q&&B(t),F.rotation=t.normalize().Lb())}_setCameraTransformation(F,b,Q){if(!b.position.equalsWithEpsilon(a,x.c)){const z=C.TmpVectors.gQ[0].W(b.position);Q&&H(z),F.translation=z.Lb()}const z=b.rotationQuaternion||C.Quaternion.FromEulerAngles(b.rotation.x,b.rotation.y,b.rotation.z);Q&&B(z),this._babylonScene.useRightHandedSystem||d(z),z.equalsWithEpsilon(A,x.c)||(F.rotation=z.Lb())}_listAvailableCameras(){for(const F of this._babylonScene.cameras){const b={type:F.mode===eF.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(F.name&&(b.name=F.name),"perspective"===b.type)b.perspective={aspectRatio:F.getEngine().getAspectRatio(F),yfov:F.fovMode===eF.b.FOVMODE_VERTICAL_FIXED?F.fov:F.fov*F.getEngine().getAspectRatio(F),znear:F.kb,zfar:F.maxZ};else if("orthographic"===b.type){const Q=F.orthoLeft&&F.orthoRight?.5*(F.orthoRight-F.orthoLeft):.5*F.getEngine().getRenderWidth(),C=F.orthoBottom&&F.orthoTop?.5*(F.orthoTop-F.orthoBottom):.5*F.getEngine().getRenderHeight();b.orthographic={xmag:Q,ymag:C,znear:F.kb,zfar:F.maxZ}}this._camerasMap.set(F,b)}}_exportAndAssignCameras(){const F=Array.from(this._camerasMap.values());for(const b of F){const F=this._nodesCameraMap.get(b);if(void 0!==F){this._cameras.push(b);for(const b of F)b.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const F of this._babylonScene.skeletons){if(F.bones.length<=0)continue;const b={joints:[]};this._skinMap.set(F,b)}}_exportAndAssignSkeletons(){for(const F of this._babylonScene.skeletons){if(F.bones.length<=0)continue;const b=this._skinMap.get(F);if(void 0==b)continue;const Q={},C=[];let t=-1;for(let z=0;z<F.bones.length;++z){const b=F.bones[z],C=b.getIndex()??z;-1!==C&&(Q[C]=b,C>t&&(t=C))}for(let F=0;F<=t;++F){const t=Q[F];C.push(t.getAbsoluteInverseBindMatrix());const g=t.getTransformNode();if(null!==g){const F=this._nodeMap.get(g);g&&null!==F&&void 0!==F?b.joints.push(F):z.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else z.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const g=this._nodesSkinMap.get(b);if(b.joints.length>0&&void 0!==g){const F=64*C.length,Q=new Float32Array(F/4);C.forEach(((F,b)=>{Q.set(F.m,16*b)}));const z=this._bufferManager.createBufferView(Q);this._accessors.push(this._bufferManager.createAccessor(z,"MAT4",5126,C.length)),b.inverseBindMatrices=this._accessors.length-1,this._skins.push(b);for(const b of g)b.skin=this._skins.length-1}}}async _exportSceneAsync(){const F={nodes:[]};if(this._babylonScene.metadata){const b=this._options.metadataSelector(this._babylonScene.metadata);b&&(F.extras=b)}const b=new Array,Q=new Array,C=new Array;for(const W of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&gF(W,this._babylonScene.useRightHandedSystem)?C.push(...W.getChildren()):this._babylonScene.useRightHandedSystem?b.push(W):Q.push(W);this._listAvailableCameras(),this._listAvailableSkeletons();const z=new AF(!0,!1);F.nodes.push(...await this._exportNodesAsync(Q,z));const t=new AF(!1,!1);F.nodes.push(...await this._exportNodesAsync(b,t));const g=new AF(!1,!0);F.nodes.push(...await this._exportNodesAsync(C,g)),F.nodes.length&&this._scenes.push(F),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&fF._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,z.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(F){let b=this._shouldExportNodeMap.get(F);return void 0===b&&(b=this._options.shouldExportNode(F),this._shouldExportNodeMap.set(F,b)),b}async _exportNodesAsync(F,b){const Q=new Array;this._exportBuffers(F,b);for(const C of F)await this._exportNodeAsync(C,Q,b);return Q}_collectBuffers(F,b,Q,C,z){if(this._shouldExportNode(F)&&F instanceof e.d&&F.pb){const t=F.pb.getVertexBuffers();if(t)for(const C in t){if(!I(C))continue;const g=t[C];z.setHasVertexColorAlpha(g,F.hasVertexAlpha);const W=g._buffer,Z=b.get(W)||[];b.set(W,Z),-1===Z.indexOf(g)&&Z.push(g);const q=Q.get(g)||[];Q.set(g,q),-1===q.indexOf(F)&&q.push(F)}const g=F.morphTargetManager;if(g)for(let b=0;b<g.numTargets;b++){const Q=g.getTarget(b),z=C.get(Q)||[];C.set(Q,z),-1===z.indexOf(F)&&z.push(F)}}for(const t of F.getChildren())this._collectBuffers(t,b,Q,C,z)}_exportBuffers(F,b){const Q=new Map,C=new Map,z=new Map;for(const W of F)this._collectBuffers(W,Q,C,z,b);const t=Array.from(Q.keys());for(const W of t){const F=W.getData();if(!F)throw new Error("Buffer data is not available");const z=Q.get(W);if(!z)continue;const t=z[0].byteStride;if(z.some((F=>F.byteStride!==t)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const g=QF(F).slice();for(const b of z){const F=C.get(b),{byteOffset:Q,byteStride:z,componentCount:t,type:W,count:Z,normalized:q,kind:K}=v(b,F);switch(K){case G.e.NormalKind:case G.e.TangentKind:(0,o.l)(g,Q,z,t,W,Z,q,(F=>{const b=Math.sqrt(F[0]*F[0]+F[1]*F[1]+F[2]*F[2]);if(b>0){const Q=1/b;F[0]*=Q,F[1]*=Q,F[2]*=Q}}));break;case G.e.ColorKind:{const b=F.filter((F=>F.material instanceof EF.qQ||null==F.material)).length;if(0==b)break;if(b!=F.length){S.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}W==G.e.UNSIGNED_BYTE&&S.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const C=new c.GQ,K=new c.sb,e=this._babylonScene.getEngine().useExactSrgbConversions;(0,o.l)(g,Q,z,t,W,Z,q,(F=>{3===F.length?(C.tC(F,0),C.toLinearSpaceToRef(C,e),C.toArray(F,0)):(K.tC(F,0),K.toLinearSpaceToRef(K,e),K.toArray(F,0))}))}}}if(b.convertToRightHanded){for(const F of z){const b=C.get(F),{byteOffset:Q,byteStride:z,componentCount:t,type:W,count:Z,normalized:q,kind:K}=v(F,b);switch(K){case G.e.PositionKind:case G.e.NormalKind:case G.e.TangentKind:(0,o.l)(g,Q,z,t,W,Z,q,(F=>{F[0]=-F[0]}))}}b.convertedToRightHandedBuffers.set(W,g)}const Z=this._bufferManager.createBufferView(g,t);b.setVertexBufferView(W,Z);const q=new Map;for(const b of z){const F=C.get(b),{kind:Q,totalVertices:z}=v(b,F);switch(Q){case G.e.MatricesIndicesKind:case G.e.MatricesIndicesExtraKind:if(b.type==G.e.FLOAT){const F=b.getFloatData(z);null!==F&&q.set(b,F)}}}0!==q.size&&S.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const K=Array.from(q.keys());for(const Q of K){const F=q.get(Q);if(!F)continue;const C=F.some((F=>F>=256)),z=new(C?Uint16Array:Uint8Array)(F.length);for(let b=0;b<F.length;b++)z[b]=F[b];const t=this._bufferManager.createBufferView(z,4*(C?2:1));b.setRemappedBufferView(W,Q,t)}}const g=Array.from(z.keys());for(const W of g){const F=z.get(W);if(!F)continue;const Q=kF(W,F[0],this._bufferManager,this._bufferViews,this._accessors,b.convertToRightHanded);for(const C of F)b.bindMorphDataToMesh(C,Q)}}async _exportNodeAsync(F,b,Q){let C=this._nodeMap.get(F);if(void 0!==C)return void(b.includes(C)||b.push(C));const z=await this._createNodeAsync(F,Q);if(z){C=this._nodes.length,this._nodes.push(z),this._nodeMap.set(F,C),Q.pushExportedNode(F),b.push(C);const t={name:"runtime animations",channels:[],samplers:[]},g=[];this._babylonScene.animationGroups.length||(fF._CreateMorphTargetAnimationFromMorphTargetAnimations(F,t,g,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Q.convertToRightHanded,this._options.shouldExportAnimation),F.animations.length&&fF._CreateNodeAnimationFromNodeAnimations(F,t,g,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Q.convertToRightHanded,this._options.shouldExportAnimation)),t.channels.length&&t.samplers.length&&this._animations.push(t),g.forEach((F=>{F.channels.length&&F.samplers.length&&this._animations.push(F)}))}const t=z?[]:b;for(const g of F.getChildren())await this._exportNodeAsync(g,t,Q);z&&t.length&&(z.children=t)}async _createNodeAsync(F,b){if(!this._shouldExportNode(F))return null;const Q={};if(F.name&&(Q.name=F.name),F.metadata){const b=this._options.metadataSelector(F.metadata);b&&(Q.extras=b)}if(F instanceof K.d&&(this._setNodeTransformation(Q,F,b.convertToRightHanded),F instanceof e.d)){const z=F instanceof N.e?F.sourceMesh:F;if(z.Xb&&z.Xb.length>0&&(Q.mesh=await this._exportMeshAsync(z,b)),F.skeleton){const b=this._skinMap.get(F.skeleton);var C;if(void 0!==b)void 0===this._nodesSkinMap.get(b)&&this._nodesSkinMap.set(b,[]),null===(C=this._nodesSkinMap.get(b))||void 0===C||C.push(Q)}}if(F instanceof O.e){const C=this._camerasMap.get(F);if(C){var z;void 0===this._nodesCameraMap.get(C)&&this._nodesCameraMap.set(C,[]),this._setCameraTransformation(Q,F,b.convertToRightHanded);const g=F.parent;if(null!==g&&bF(F,g)){const F=this._nodeMap.get(g);if(void 0!==F){var t;const b=this._nodes[F];return FF(Q,b),null===(t=this._nodesCameraMap.get(C))||void 0===t||t.push(b),null}}null===(z=this._nodesCameraMap.get(C))||void 0===z||z.push(Q)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",Q,F,this._nodeMap,b.convertToRightHanded)?Q:(S.e.Warn(`Not exporting node ${F.name}`),null)}_exportIndices(F,b,Q,C,z,g,W,Z,q){let G=F;q.mode=M(g);const K=W!==t.c.CounterClockWiseSideOrientation,e=!Z.wasAddedByNoopNode&&K,N=function(F){switch(F){case t.c.TriangleFillMode:case t.c.TriangleStripDrawMode:case t.c.TriangleFanDrawMode:return!0}return!1}(g)&&e;if(N){if(g===t.c.TriangleStripDrawMode||g===t.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");q.mode=M(g);const W=b?new Uint32Array(C):new Uint16Array(C);if(F)for(let b=0;b+2<C;b+=3)W[b]=F[Q+b]+z,W[b+1]=F[Q+b+2]+z,W[b+2]=F[Q+b+1]+z;else for(let F=0;F+2<C;F+=3)W[F]=F,W[F+1]=F+2,W[F+2]=F+1;G=W}else if(F&&0!==z){const t=b?new Uint32Array(C):new Uint16Array(C);for(let b=0;b<C;b++)t[b]=F[Q+b]+z;G=t}if(G){let t=Z.getIndicesAccessor(F,Q,C,z,N);if(void 0===t){const g=function(F,b,Q,C){if(F instanceof Uint16Array||F instanceof Uint32Array)return F;if(F instanceof Int32Array)return new Uint32Array(F.buffer,F.byteOffset,F.length);const z=F.slice(b,b+Q);return C?new Uint32Array(z):new Uint16Array(z)}(G,0,C,b),W=this._bufferManager.createBufferView(g),q=b?5125:5123;this._accessors.push(this._bufferManager.createAccessor(W,"SCALAR",q,C,0)),t=this._accessors.length-1,Z.setIndicesAccessor(F,Q,C,z,N,t)}q.indices=t}}_exportVertexBuffer(F,b,Q,C,z,t){const g=F.getKind();if(!I(g))return;if(g.startsWith("uv")&&!this._options.exportUnusedUVs&&(!b||!this._materialNeedsUVsSet.has(b)))return;let W=z.getVertexAccessor(F,Q,C);if(void 0===W){const b=z.convertedToRightHandedBuffers.get(F._buffer)||F._buffer.getData(),t=g===G.e.PositionKind?function(F,b,Q,C){const{byteOffset:z,byteStride:t,type:g,normalized:W}=b,Z=b.getSize(),q=new Array(Z).fill(1/0),G=new Array(Z).fill(-1/0);return(0,o.l)(F,z+Q*t,t,Z,g,C*Z,W,(F=>{for(let b=0;b<Z;b++)q[b]=Math.min(q[b],F[b]),G[b]=Math.max(G[b],F[b])})),{min:q,max:G}}(b,F,Q,C):void 0,Z=(g===G.e.MatricesIndicesKind||g===G.e.MatricesIndicesExtraKind)&&F.type===G.e.FLOAT,q=Z?G.e.UNSIGNED_BYTE:F.type,K=Z?void 0:F.normalized,e=Z?z.getRemappedBufferView(F._buffer,F):z.getVertexBufferView(F._buffer),N=F.byteOffset+Q*F.byteStride;this._accessors.push(this._bufferManager.createAccessor(e,function(F,b){if(F==G.e.ColorKind)return b?"VEC4":"VEC3";switch(F){case G.e.PositionKind:case G.e.NormalKind:return"VEC3";case G.e.TangentKind:case G.e.MatricesIndicesKind:case G.e.MatricesIndicesExtraKind:case G.e.MatricesWeightsKind:case G.e.MatricesWeightsExtraKind:return"VEC4";case G.e.UVKind:case G.e.UV2Kind:case G.e.UV3Kind:case G.e.UV4Kind:case G.e.UV5Kind:case G.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${F}`)}(g,z.hasVertexColorAlpha(F)),q,C,N,t,K)),W=this._accessors.length-1,z.setVertexAccessor(F,Q,C,W)}t.attributes[function(F){switch(F){case G.e.PositionKind:return"POSITION";case G.e.NormalKind:return"NORMAL";case G.e.TangentKind:return"TANGENT";case G.e.ColorKind:return"COLOR_0";case G.e.UVKind:return"TEXCOORD_0";case G.e.UV2Kind:return"TEXCOORD_1";case G.e.UV3Kind:return"TEXCOORD_2";case G.e.UV4Kind:return"TEXCOORD_3";case G.e.UV5Kind:return"TEXCOORD_4";case G.e.UV6Kind:return"TEXCOORD_5";case G.e.MatricesIndicesKind:return"JOINTS_0";case G.e.MatricesIndicesExtraKind:return"JOINTS_1";case G.e.MatricesWeightsKind:return"WEIGHTS_0";case G.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${F}`)}(g)]=W}async _exportMaterialAsync(F,b,Q,C){let z=this._materialMap.get(F);if(void 0===z){const C=b&&Object.keys(b).some((F=>F.startsWith("uv")));if((F=F instanceof NF.c?F.Vb[Q.materialIndex]:F)instanceof yF.c)z=await this._materialExporter.exportPBRMaterialAsync(F,"image/png",C);else{if(!(F instanceof EF.qQ))return void S.e.Warn(`Unsupported material '${F.name}' with type ${F.getClassName()}`);z=await this._materialExporter.exportStandardMaterialAsync(F,"image/png",C)}this._materialMap.set(F,z)}C.material=z}async _exportMeshAsync(F,b){var Q;let C=b.getMesh(F);if(void 0!==C)return C;const z={primitives:[]};C=this._meshes.length,this._meshes.push(z),b.setMesh(F,C);const g=F.isUnIndexed?null:F.Pb(),W=null===(Q=F.pb)||void 0===Q?void 0:Q.getVertexBuffers(),Z=b.getMorphTargetsFromMesh(F),q=F instanceof mF.d,G=F instanceof aF,K=F.Xb;if(W&&K&&K.length>0)for(const y of K){const Q={attributes:{}},C=y.TF()||this._babylonScene.defaultMaterial;if(G){var e,N;const b={name:C.name},z=F,t=c.GQ.White(),g=(null===(e=z.material)||void 0===e?void 0:e.alpha)??1,W=(null===(N=z.greasedLineMaterial)||void 0===N?void 0:N.color)??t;(!W.equalsWithEpsilon(t,x.c)||g<1)&&(b.pbrMetallicRoughness={baseColorFactor:[...W.Lb(),g]}),this._materials.push(b),Q.material=this._materials.length-1}else if(q){const b={name:C.name},z=F;(!z.color.equalsWithEpsilon(c.GQ.White(),x.c)||z.alpha<1)&&(b.pbrMetallicRoughness={baseColorFactor:[...z.color.Lb(),z.alpha]}),this._materials.push(b),Q.material=this._materials.length-1}else await this._exportMaterialAsync(C,W,y,Q);const K=q||G?t.c.LineListDrawMode:F.overrideRenderingFillMode??C.fillMode,E=C._getEffectiveOrientation(F);this._exportIndices(g,g?(0,o.e)(g,y.indexCount,y.indexStart,y.verticesStart):y.verticesCount>65535,g?y.indexStart:y.verticesStart,g?y.indexCount:y.verticesCount,-y.verticesStart,K,E,b,Q);for(const F of Object.values(W))this._exportVertexBuffer(F,C,y.verticesStart,y.verticesCount,b,Q);if(Z){Q.targets=[];for(const F of Z)Q.targets.push(F.attributes)}z.primitives.push(Q),this._extensionsPostExportMeshPrimitive(Q)}if(Z){z.weights=[],z.extras||(z.extras={}),z.extras.targetNames=[];for(const F of Z)z.weights.push(F.influence),z.extras.targetNames.push(F.name)}return C}}UF._ExtensionNames=new Array,UF._ExtensionFactories={};class uF{static async GLTFAsync(F,b,Q){Q&&Q.exportWithoutWaitingForScene||await F.whenReadyAsync();const C=new UF(F,Q),z=await C.generateGLTFAsync(b.replace(/\.[^/.]+$/,""));return C.dispose(),z}static async GLBAsync(F,b,Q){Q&&Q.exportWithoutWaitingForScene||await F.whenReadyAsync();const C=new UF(F,Q),z=await C.generateGLBAsync(b.replace(/\.[^/.]+$/,""));return C.dispose(),z}}Q(11849);const vF="EXT_mesh_gpu_instancing";class JF{constructor(F){this.name=vF,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(F,b,Q,z,t,g){return await new Promise((F=>{if(b&&Q instanceof LF.b&&Q.hasThinInstances&&this._exporter){this._wasUsed=!0;const F=C.gQ.Zero(),z=C.Quaternion.Identity(),W=C.gQ.One(),Z=Q.thinInstanceGetWorldMatrices(),q=C.TmpVectors.gQ[2],G=C.TmpVectors.Quaternion[1],K=C.TmpVectors.gQ[3];let e=!1,N=!1,y=!1;const E=new Float32Array(3*Q.hb),c=new Float32Array(4*Q.hb),X=new Float32Array(3*Q.hb);let L=0;for(const b of Z)b.decompose(K,G,q),t&&(H(q),B(G)),E.set(q.Lb(),3*L),c.set(G.normalize().Lb(),4*L),X.set(K.Lb(),3*L),e=e||!q.equalsWithEpsilon(F),N=N||!G.equalsWithEpsilon(z),y=y||!K.equalsWithEpsilon(W),L++;const i={attributes:{}};e&&(i.attributes.TRANSLATION=this._buildAccessor(E,"VEC3",Q.hb,g)),N&&(i.attributes.ROTATION=this._buildAccessor(c,"VEC4",Q.hb,g)),y&&(i.attributes.SCALE=this._buildAccessor(X,"VEC3",Q.hb,g)),b.extensions=b.extensions||{},b.extensions[vF]=i}F(b)}))}_buildAccessor(F,b,Q,C){const z=C.createBufferView(F),t=C.createAccessor(z,b,5126,Q);return this._exporter._accessors.push(t),this._exporter._accessors.length-1}}UF.RegisterExtension(vF,(F=>new JF(F)));var IF=Q(11856),MF=Q(11861),rF=Q(11870),HF=Q(11878);function BF(F){return F===rF.e.PositionKind?"POSITION":F===rF.e.NormalKind?"NORMAL":F===rF.e.ColorKind?"COLOR":F.startsWith(rF.e.UVKind)?"TEX_COORD":"GENERIC"}const dF={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Fb extends IF.b{static get DefaultAvailable(){return(0,IF.i)(Fb.DefaultConfiguration)}static get Default(){return Fb._Default??(Fb._Default=new Fb),Fb._Default}static ResetDefault(F){Fb._Default&&(F||Fb._Default.dispose(),Fb._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(F,b){return{module:await(b||DracoEncoderModule)({wasmBinary:F})}}_getWorkerContent(){return`${MF.i}(${MF.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Fb.DefaultConfiguration)}async _encodeAsync(F,b,Q){const C=Q?(0,HF.d)(dF,Q):dF;if(this._workerPoolPromise){const Q=await this._workerPoolPromise;return await new Promise(((z,t)=>{Q.push(((Q,g)=>{const W=F=>{Q.removeEventListener("error",W),Q.removeEventListener("message",Z),t(F),g()},Z=F=>{"encodeMeshDone"===F.data.id&&(Q.removeEventListener("error",W),Q.removeEventListener("message",Z),z(F.data.encodedMeshData),g())};Q.addEventListener("error",W),Q.addEventListener("message",Z);const q=[];for(const b of F)q.push(b.data.buffer);b&&q.push(b.buffer),Q.postMessage({id:"encodeMesh",attributes:F,indices:b,options:C},q)}))}))}if(this._modulePromise){const Q=await this._modulePromise;return(0,MF.i)(Q.module,F,b,C)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(F,b){if(0==F.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");F instanceof LF.b&&F.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===b||void 0===b?void 0:b.method)&&(S.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),b.method="MESH_SEQUENTIAL_ENCODING");const Q=function(F){let b=F.Pb(void 0,!0);return!b||b instanceof Uint32Array||b instanceof Uint16Array||(b=((0,o.e)(b,b.length)?Uint32Array:Uint16Array).from(b)),b}(F),C=function(F,b){const Q=[];for(const C of F.getVerticesDataKinds()){if(null!==b&&void 0!==b&&b.includes(C)){if(C===rF.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const z=F.getVertexBuffer(C),t=z.getSize(),g=(0,o.y)(z.getData(),t,z.type,z.byteOffset,z.byteStride,z.normalized,F.getTotalVertices(),!0);Q.push({kind:C,dracoName:BF(C),size:t,data:g})}return Q}(F,null===b||void 0===b?void 0:b.excludedAttributes);return await this._encodeAsync(C,Q,b)}}Fb.DefaultConfiguration={wasmUrl:`${z.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${z.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${z.Tools._DefaultCdnUrl}/draco_encoder.js`},Fb._Default=null;const bb="KHR_draco_mesh_compression";class Qb{get wasUsed(){return this._wasUsed}constructor(F){this.name=bb,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===F.options.meshCompressionMethod&&Fb.DefaultAvailable}dispose(){}postExportMeshPrimitive(F,b,Q){if(!this.enabled)return;if(4!==F.mode&&5!==F.mode)return void S.e.Warn("Cannot compress primitive with mode "+F.mode+".");const C=[],z=[];let t=null;if(void 0!==F.indices){const g=Q[F.indices],W=b.getBufferView(g);t=b.getData(W).slice(),C.push(W),z.push(g)}const g=[];for(const[G,K]of Object.entries(F.attributes)){const F=Q[K],t=b.getBufferView(F),Z=J(F.type),q=(0,o.y)(b.getData(t),Z,F.componentType,F.byteOffset||0,t.byteStride||(0,o.t)(F.componentType)*Z,F.normalized||!1,F.count,!0);g.push({kind:G,dracoName:(W=G,"POSITION"===W?"POSITION":"NORMAL"===W?"NORMAL":W.startsWith("COLOR")?"COLOR":W.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:J(F.type),data:q}),C.push(t),z.push(F)}var W;const Z={method:F.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},q=Fb.Default._encodeAsync(g,t,Z).then((Q=>{if(!Q)return void S.e.Error("Draco encoding failed for primitive.");const t={bufferView:-1,attributes:Q.attributeIds},g=b.createBufferView(Q.data);b.setBufferView(t,g);for(const F of C)this._bufferViewsUsed.add(F);for(const F of z)this._accessorsUsed.add(F);F.extensions||(F.extensions={}),F.extensions[bb]=t})).catch((F=>{S.e.Error("Draco encoding failed for primitive: "+F)}));this._encodePromises.push(q),this._wasUsed=!0}async preGenerateBinaryAsync(F){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((b=>{F.getPropertiesWithBufferView(b).every((F=>this._accessorsUsed.has(F)))&&F.removeBufferView(b)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}UF.RegisterExtension(bb,(F=>new Qb(F)));var Cb=Q(11881);const zb="KHR_lights_punctual",tb={name:"",color:[1,1,1],lb:1,range:Number.MAX_VALUE},gb={innerConeAngle:0,outerConeAngle:Math.PI/4},Wb=C.gQ.Backward();class Zb{constructor(F){this.name=zb,this.enabled=!0,this.required=!1,this._exporter=F}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[zb]=this._lights}async postExportNodeAsync(F,b,Q,z,t){return await new Promise((g=>{if(!(Q instanceof iF.e))return void g(b);const W=Q.getTypeID()==iF.e.LIGHTTYPEID_POINTLIGHT?"point":Q.getTypeID()==iF.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":Q.getTypeID()==iF.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!W||!(Q instanceof Cb.e))return S.e.Warn(`${F}: Light ${Q.name} is not supported in ${zb}`),void g(b);if(Q.falloffType!==iF.e.FALLOFF_GLTF&&S.e.Warn(`${F}: Light falloff for ${Q.name} does not match the ${zb} specification!`),!Q.position.equalsToFloats(0,0,0)){const F=C.TmpVectors.gQ[0].W(Q.position);t&&H(F),b.translation=F.Lb()}if("point"!==W){const F=Q.direction.normalizeToRef(C.TmpVectors.gQ[0]);t&&H(F);const z=C.Quaternion.FromUnitVectorsToRef(Wb,F,C.TmpVectors.Quaternion[0]);C.Quaternion.IsIdentity(z)||(b.rotation=z.Lb())}const Z={type:W,name:Q.name,color:Q.Tb.Lb(),lb:Q.lb,range:Q.range};if(CF(Z,tb),"spot"===W){const F=Q;Z.spot={innerConeAngle:F.innerAngle/2,outerConeAngle:F.angle/2},CF(Z.spot,gb)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(Z);const q={Zb:this._lights.lights.length-1},G=Q.parent;if(G&&bF(Q,G)){const F=z.get(G);if(F){const Q=this._exporter._nodes[F];return FF(b,Q),Q.extensions||(Q.extensions={}),Q.extensions[zb]=q,void g(null)}}b.extensions||(b.extensions={}),b.extensions[zb]=q,g(b)}))}}UF.RegisterExtension(zb,(F=>new Zb(F)));var qb=Q(11798);const Gb="KHR_materials_anisotropy";class Kb{constructor(F){this.name=Gb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,b,Q){const C=[];return Q instanceof qb.d&&Q.anisotropy.isEnabled&&!Q.anisotropy.legacy?(Q.anisotropy.texture&&C.push(Q.anisotropy.texture),C):[]}postExportMaterialAsync(F,b,Q){return new Promise((F=>{if(Q instanceof qb.d){if(!Q.anisotropy.isEnabled||Q.anisotropy.legacy)return void F(b);this._wasUsed=!0,b.extensions=b.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(Q.anisotropy.texture),z={anisotropyStrength:Q.anisotropy.lb,anisotropyRotation:Q.anisotropy.angle,anisotropyTexture:C??void 0};null!==z.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(Q),b.extensions[Gb]=z}F(b)}))}}UF.RegisterExtension(Gb,(F=>new Kb(F)));const eb="KHR_materials_clearcoat";class Nb{constructor(F){this.name=eb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,b,Q){const C=[];return Q instanceof qb.d&&Q.clearCoat.isEnabled?(Q.clearCoat.texture&&C.push(Q.clearCoat.texture),!Q.clearCoat.useRoughnessFromMainTexture&&Q.clearCoat.textureRoughness&&C.push(Q.clearCoat.textureRoughness),Q.clearCoat.bumpTexture&&C.push(Q.clearCoat.bumpTexture),C):[]}postExportMaterialAsync(F,b,Q){return new Promise((F=>{if(Q instanceof qb.d){if(!Q.clearCoat.isEnabled)return void F(b);this._wasUsed=!0,b.extensions=b.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(Q.clearCoat.texture);let t;t=Q.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(Q.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(Q.clearCoat.textureRoughness),Q.clearCoat.isTintEnabled&&z.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${Q.name}`),Q.clearCoat.remapF0OnInterfaceChange&&z.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${Q.name}`);const g=this._exporter._materialExporter.getTextureInfo(Q.clearCoat.bumpTexture),W={clearcoatFactor:Q.clearCoat.lb,clearcoatTexture:C??void 0,clearcoatRoughnessFactor:Q.clearCoat.roughness,clearcoatRoughnessTexture:t??void 0,clearcoatNormalTexture:g??void 0};null===W.clearcoatTexture&&null===W.clearcoatRoughnessTexture&&null===W.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Q),b.extensions[eb]=W}F(b)}))}}UF.RegisterExtension(eb,(F=>new Nb(F)));const yb="KHR_materials_diffuse_transmission";function Eb(F,b){const Q=b.subSurface;let C=null;return Q.translucencyIntensityTexture?C=Q.translucencyIntensityTexture:Q.thicknessTexture&&Q.useMaskFromThicknessTexture&&(C=Q.thicknessTexture),C&&!Q.useGltfStyleTextures?(S.e.Warn(`${F}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${b.name}`,1),null):C}class cb{constructor(F){this.name=yb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,b,Q){const C=[];if(Q instanceof yF.c&&this._isExtensionEnabled(Q)){const b=Eb(F,Q);return b&&C.push(b),Q.subSurface.translucencyColorTexture&&C.push(Q.subSurface.translucencyColorTexture),C}return C}_isExtensionEnabled(F){if(F.unlit)return!1;const b=F.subSurface;return!!b.isTranslucencyEnabled&&(!F.unlit&&!b.useAlbedoToTintTranslucency&&b.useGltfStyleTextures&&1===b.volumeIndexOfRefraction&&0===b.minimumThickness&&0===b.maximumThickness)}postExportMaterialAsync(F,b,Q){return new Promise((C=>{if(Q instanceof yF.c&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const C=Q.subSurface,z=Eb(F,Q),t=0==C.translucencyIntensity?void 0:C.translucencyIntensity,g=this._exporter._materialExporter.getTextureInfo(z)??void 0,W=!C.translucencyColor||C.translucencyColor.equalsFloats(1,1,1)?void 0:C.translucencyColor.Lb(),Z=this._exporter._materialExporter.getTextureInfo(C.translucencyColorTexture)??void 0,q={diffuseTransmissionFactor:t,diffuseTransmissionTexture:g,diffuseTransmissionColorFactor:W,diffuseTransmissionColorTexture:Z};(g||Z)&&this._exporter._materialNeedsUVsSet.add(Q),b.extensions=b.extensions||{},b.extensions[yb]=q}C(b)}))}}UF.RegisterExtension(yb,(F=>new cb(F)));const Xb="KHR_materials_dispersion";class Lb{constructor(){this.name=Xb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(F){if(F.unlit)return!1;const b=F.subSurface;return!(!b.isRefractionEnabled&&!b.isDispersionEnabled)}postExportMaterialAsync(F,b,Q){return new Promise((F=>{if(Q instanceof yF.c&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const F={dispersion:Q.subSurface.dispersion};b.extensions=b.extensions||{},b.extensions[Xb]=F}F(b)}))}}UF.RegisterExtension(Xb,(()=>new Lb));const ib="KHR_materials_emissive_strength";class fb{constructor(){this.name=ib,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(F,b,Q){return await new Promise((F=>{if(!(Q instanceof yF.c))return F(b);const C=Q.emissiveColor.Lb(),z=Math.max(...C);if(z>1){this._wasUsed=!0,b.extensions||(b.extensions={});const F={emissiveStrength:z},C=Q.emissiveColor.scale(1/F.emissiveStrength);b.emissiveFactor=C.Lb(),b.extensions[ib]=F}return F(b)}))}}UF.RegisterExtension(ib,(F=>new fb));const kb="KHR_materials_ior";class mb{constructor(){this.name=kb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(F){return!F.unlit&&(void 0!=F.indexOfRefraction&&1.5!=F.indexOfRefraction)}postExportMaterialAsync(F,b,Q){return new Promise((F=>{if(Q instanceof yF.c&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const F={ior:Q.indexOfRefraction};b.extensions=b.extensions||{},b.extensions[kb]=F}F(b)}))}}UF.RegisterExtension(kb,(F=>new mb));const Rb="KHR_materials_iridescence";class pb{constructor(F){this.name=Rb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,b,Q){const C=[];return Q instanceof qb.d&&Q.iridescence.isEnabled?(Q.iridescence.texture&&C.push(Q.iridescence.texture),Q.iridescence.thicknessTexture&&Q.iridescence.thicknessTexture!==Q.iridescence.texture&&C.push(Q.iridescence.thicknessTexture),C):[]}postExportMaterialAsync(F,b,Q){return new Promise((F=>{if(Q instanceof qb.d){if(!Q.iridescence.isEnabled)return void F(b);this._wasUsed=!0,b.extensions=b.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(Q.iridescence.texture),z=this._exporter._materialExporter.getTextureInfo(Q.iridescence.thicknessTexture),t={iridescenceFactor:Q.iridescence.lb,iridescenceIor:Q.iridescence.indexOfRefraction,iridescenceThicknessMinimum:Q.iridescence.minimumThickness,iridescenceThicknessMaximum:Q.iridescence.maximumThickness,iridescenceTexture:C??void 0,iridescenceThicknessTexture:z??void 0};null===t.iridescenceTexture&&null===t.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(Q),b.extensions[Rb]=t}F(b)}))}}UF.RegisterExtension(Rb,(F=>new pb(F)));const Db="KHR_materials_sheen";class Pb{constructor(F){this.name=Db,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,b,Q){return Q instanceof yF.c&&Q.sheen.isEnabled&&Q.sheen.texture?[Q.sheen.texture]:[]}async postExportMaterialAsync(F,b,Q){return await new Promise((F=>{if(Q instanceof yF.c){if(!Q.sheen.isEnabled)return void F(b);this._wasUsed=!0,null==b.extensions&&(b.extensions={});const C={sheenColorFactor:Q.sheen.color.Lb(),sheenRoughnessFactor:Q.sheen.roughness??0};null===C.sheenColorTexture&&null===C.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Q),Q.sheen.texture&&(C.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(Q.sheen.texture)??void 0),Q.sheen.textureRoughness&&!Q.sheen.useRoughnessFromMainTexture?C.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Q.sheen.textureRoughness)??void 0:Q.sheen.texture&&Q.sheen.useRoughnessFromMainTexture&&(C.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Q.sheen.texture)??void 0),b.extensions[Db]=C}F(b)}))}}UF.RegisterExtension(Db,(F=>new Pb(F)));const nb="KHR_materials_specular";class jb{constructor(F){this.name=nb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,b,Q){const C=[];return Q instanceof yF.c&&this._isExtensionEnabled(Q)?(Q.metallicReflectanceTexture&&C.push(Q.metallicReflectanceTexture),Q.reflectanceTexture&&C.push(Q.reflectanceTexture),C):C}_isExtensionEnabled(F){return!F.unlit&&(void 0!=F.metallicF0Factor&&1!=F.metallicF0Factor||void 0!=F.metallicReflectanceColor&&!F.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(F))}_hasTexturesExtension(F){return null!=F.metallicReflectanceTexture||null!=F.reflectanceTexture}postExportMaterialAsync(F,b,Q){return new Promise((F=>{if(Q instanceof yF.c&&this._isExtensionEnabled(Q)){this._wasUsed=!0,b.extensions=b.extensions||{};const F=this._exporter._materialExporter.getTextureInfo(Q.metallicReflectanceTexture)??void 0,C=this._exporter._materialExporter.getTextureInfo(Q.reflectanceTexture)??void 0,z={specularFactor:1==Q.metallicF0Factor?void 0:Q.metallicF0Factor,specularTexture:F,specularColorFactor:Q.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:Q.metallicReflectanceColor.Lb(),specularColorTexture:C};this._hasTexturesExtension(Q)&&this._exporter._materialNeedsUVsSet.add(Q),b.extensions[nb]=z}F(b)}))}}UF.RegisterExtension(nb,(F=>new jb(F)));const wb="KHR_materials_transmission";class Yb{constructor(F){this.name=wb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,b,Q){const C=[];return Q instanceof yF.c&&this._isExtensionEnabled(Q)?(Q.subSurface.thicknessTexture&&C.push(Q.subSurface.thicknessTexture),C):C}_isExtensionEnabled(F){if(F.unlit)return!1;const b=F.subSurface;return b.isRefractionEnabled&&void 0!=b.refractionIntensity&&0!=b.refractionIntensity||this._hasTexturesExtension(F)}_hasTexturesExtension(F){return null!=F.subSurface.refractionIntensityTexture}async postExportMaterialAsync(F,b,Q){if(Q instanceof yF.c&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const C=Q.subSurface,z={transmissionFactor:0===C.refractionIntensity?void 0:C.refractionIntensity};if(this._hasTexturesExtension(Q)&&this._exporter._materialNeedsUVsSet.add(Q),C.refractionIntensityTexture)if(C.useGltfStyleTextures){const F=await this._exporter._materialExporter.exportTextureAsync(C.refractionIntensityTexture,"image/png");F&&(z.transmissionTexture=F)}else S.e.Warn(`${F}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);b.extensions||(b.extensions={}),b.extensions[wb]=z}return b}}UF.RegisterExtension(wb,(F=>new Yb(F)));const sb="KHR_materials_unlit";class Vb{constructor(){this.name=sb,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(F,b,Q){return new Promise((F=>{let C=!1;Q instanceof yF.c?C=Q.unlit:Q instanceof EF.qQ&&(C=Q.disableLighting),C&&(this._wasUsed=!0,null==b.extensions&&(b.extensions={}),b.extensions[sb]={}),F(b)}))}}UF.RegisterExtension(sb,(()=>new Vb));const hb="KHR_materials_volume";class lb{constructor(F){this.name=hb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,b,Q){const C=[];return Q instanceof yF.c&&this._isExtensionEnabled(Q)?(Q.subSurface.thicknessTexture&&C.push(Q.subSurface.thicknessTexture),C):C}_isExtensionEnabled(F){if(F.unlit)return!1;const b=F.subSurface;return!(!b.isRefractionEnabled&&!b.isTranslucencyEnabled)&&(void 0!=b.maximumThickness&&0!=b.maximumThickness||void 0!=b.tintColorAtDistance&&b.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=b.tintColor&&b.tintColor!=c.GQ.White()||this._hasTexturesExtension(F))}_hasTexturesExtension(F){return null!=F.subSurface.thicknessTexture}postExportMaterialAsync(F,b,Q){return new Promise((F=>{if(Q instanceof yF.c&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const F=Q.subSurface,C={thicknessFactor:0==F.maximumThickness?void 0:F.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(F.thicknessTexture)??void 0,attenuationDistance:F.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:F.tintColorAtDistance,attenuationColor:F.tintColor.equalsFloats(1,1,1)?void 0:F.tintColor.Lb()};this._hasTexturesExtension(Q)&&this._exporter._materialNeedsUVsSet.add(Q),b.extensions=b.extensions||{},b.extensions[hb]=C}F(b)}))}}UF.RegisterExtension(hb,(F=>new lb(F)));const Tb="EXT_materials_diffuse_roughness";class ob{constructor(F){this.name=Tb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,b,Q){const C=[];return Q instanceof qb.d&&Q._baseDiffuseRoughness?(Q._baseDiffuseRoughnessTexture&&C.push(Q._baseDiffuseRoughnessTexture),C):[]}postExportMaterialAsync(F,b,Q){return new Promise((F=>{if(Q instanceof qb.d){if(!Q._baseDiffuseRoughness)return void F(b);this._wasUsed=!0,b.extensions=b.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(Q._baseDiffuseRoughnessTexture),z={diffuseRoughnessFactor:Q._baseDiffuseRoughness,diffuseRoughnessTexture:C??void 0};null!==z.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(Q),b.extensions[Tb]=z}F(b)}))}}UF.RegisterExtension(Tb,(F=>new ob(F)));const Sb="KHR_texture_transform";class Ob{constructor(){this.name=Sb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(F,b,Q){if(Q.RF()||z.Tools.Warn(`${F}: /*@__KEY__*/"scene" is not defined for Babylon texture ${Q.name}!`),(0!==Q.uAng||0!==Q.vAng)&&(z.Tools.Warn(`${F}: Texture ${Q.name} with rotation in the u or v axis is not supported in glTF.`),0!==Q.uRotationCenter||0!==Q.vRotationCenter))return;const C={};let t=!1;if(0===Q.uOffset&&0===Q.vOffset||(C.offset=[Q.uOffset,Q.vOffset],t=!0),1===Q.uScale&&1===Q.vScale||(C.scale=[Q.uScale,Q.vScale],t=!0),0!==Q.wAng){if(0!==Q.uRotationCenter||0!==Q.vRotationCenter){if(Q.homogeneousRotationInUVTransform&&Q.uScale!==Q.vScale)return void z.Tools.Warn(`${F}: Texture ${Q.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Sb}.`);z.Tools.Warn(`${F}: Texture ${Q.name} with non-origin rotation center will be exported using an adjusted offset with ${Sb}.`),C.offset=function(F){const{uOffset:b,vOffset:Q,uRotationCenter:C,vRotationCenter:z,uScale:t,vScale:g,wAng:W}=F,Z=Math.cos(W),q=Math.sin(W),G=C*t,K=z*g;return[b+(G*(1-Z)+K*q),Q+(K*(1-Z)-G*q)]}(Q)}C.rotation=-Q.wAng,t=!0}0!==Q.coordinatesIndex&&(C.texCoord=Q.coordinatesIndex,t=!0),t&&(this._wasUsed=!0,b.extensions||(b.extensions={}),b.extensions[Sb]=C)}}UF.RegisterExtension(Sb,(()=>new Ob));class xb{static CreateSTL(F){let b=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",z=arguments.length>3&&void 0!==arguments[3]&&arguments[3],t=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],g=arguments.length>5&&void 0!==arguments[5]&&arguments[5],W=arguments.length>6&&void 0!==arguments[6]&&arguments[6],Z=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const q=function(F,b,Q){const z=[3*F[Q],3*F[Q+1],3*F[Q+2]],t=[new C.gQ(b[z[0]],b[z[0]+2],b[z[0]+1]),new C.gQ(b[z[1]],b[z[1]+2],b[z[1]+1]),new C.gQ(b[z[2]],b[z[2]+2],b[z[2]+1])],g=t[0].WQ(t[1]),W=t[2].WQ(t[1]);return{v:t,n:C.gQ.Cross(W,g).normalize()}},K=function(F,b,Q,C){return b=e(F,b,Q.x,C),b=e(F,b,Q.y,C),e(F,b,Q.z,C)},e=function(F,b,Q,C){return F.setFloat32(b,Q,C),b+4},y=function(F){if(W){let b=F;F instanceof N.e&&(b=F.sourceMesh);const Q=b.getVerticesData(G.e.PositionKind,!0,!0);if(!Q)return[];const z=C.gQ.Zero();let t;for(t=0;t<Q.length;t+=3)C.gQ.TransformCoordinatesFromFloatsToRef(Q[t],Q[t+1],Q[t+2],F.Rb(!0),z).toArray(Q,t);return Q}return F.getVerticesData(G.e.PositionKind)||[]};W&&(g=!0);let E="",c=0,X=0;if(z){for(let Q=0;Q<F.length;Q++){const b=F[Q].Pb();c+=b?b.length/3:0}const b=new ArrayBuffer(84+50*c);E=new DataView(b),X+=80,E.setUint32(X,c,t),X+=4}else Z||(E="solid stlmesh\r\n");for(let C=0;C<F.length;C++){const b=F[C];!z&&Z&&(E+="solid "+b.name+"\r\n"),!g&&b instanceof LF.b&&b.bakeCurrentTransformIntoVertices();const Q=y(b),W=b.Pb()||[];for(let F=0;F<W.length;F+=3){const b=q(W,Q,F);z?(X=K(E,X,b.n,t),X=K(E,X,b.v[0],t),X=K(E,X,b.v[1],t),X=K(E,X,b.v[2],t),X+=2):(E+="\tfacet normal "+b.n.x+" "+b.n.y+" "+b.n.z+"\r\n",E+="\t\touter loop\r\n",E+="\t\t\tvertex "+b.v[0].x+" "+b.v[0].y+" "+b.v[0].z+"\r\n",E+="\t\t\tvertex "+b.v[1].x+" "+b.v[1].y+" "+b.v[1].z+"\r\n",E+="\t\t\tvertex "+b.v[2].x+" "+b.v[2].y+" "+b.v[2].z+"\r\n",E+="\t\tendloop\r\n",E+="\tendfacet\r\n")}!z&&Z&&(E+="endsolid "+name+"\r\n")}if(z||Z||(E+="endsolid stlmesh"),b){const F=document.createElement("a"),b=new Blob([E],{type:"application/octet-stream"});F.href=window.URL.createObjectURL(b),F.download=Q+".stl",F.click()}return E}}function ab(F,b){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const C=[];for(let z=0;z<F.length/Q;z++){const t=F[z*Q],g=F[z*Q+1],W=F[z*Q+2];C.push(`(${t.toPrecision(b.precision)}, ${g.toPrecision(b.precision)}, ${W.toPrecision(b.precision)})`)}return C.join(", ")}function Ab(F,b){const Q=[];for(let C=0;C<F.length/2;C++){const z=F[2*C],t=F[2*C+1];Q.push(`(${z.toPrecision(b.precision)}, ${(1-t).toPrecision(b.precision)})`)}return Q.join(", ")}function Ub(F,b){const Q=F.getVerticesData(G.e.PositionKind),C=F.getVerticesData(G.e.NormalKind);if(Q&&C)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(F){var b;const Q=null!==(b=F.Pb())&&void 0!==b&&b.length?F.getTotalIndices():F.getTotalVertices();return Array(Q/3).fill(3).join(", ")}(F)}]\n\t\tint[] faceVertexIndices = [${function(F){const b=F.Pb(),Q=[];if(null!==b)for(let C=0;C<b.length;C++)Q.push(b[C]);else{const b=F.getTotalVertices();for(let F=0;F<b;F++)Q.push(F)}return Q.join(", ")}(F)}]\n\t\tnormal3f[] normals = [${ab(C,b)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${ab(Q,b)}]\n        ${function(F,b){let Q="";for(let z=0;z<4;z++){const C=z>0?z:"",t=F.getVerticesData(G.e.UVKind+(C?C+1:""));t&&(Q+=`\n\t\ttexCoord2f[] primvars:st${C} = [${Ab(t,b)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const C=F.getVerticesData(G.e.ColorKind);return C&&(Q+=`\n\tcolor3f[] primvars:displayColor = [${ab(C,b,C.length/F.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),Q}(F,b)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function ub(F,b){return`\n        def "Geometry"\n        {\n        ${Ub(F,b)}\n        }\n        `}function vb(F){let b='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return b+=F,fflate.strToU8(b)}function Jb(F){const b=F.m;return`( ${Ib(b,0)}, ${Ib(b,4)}, ${Ib(b,8)}, ${Ib(b,12)} )`}function Ib(F,b){return`(${F[b+0]}, ${F[b+1]}, ${F[b+2]}, ${F[b+3]})`}function Mb(F){const b="Object_"+F.uniqueId,Q=function(F){const b=F.getWorldMatrix().clone(),Q=F.RF().useRightHandedSystem;if(!Q){let C=F.parent;for(;C;){if(gF(C,Q)){b.multiplyToRef(C.getWorldMatrix().invert(),b);break}C=C.parent}}return b.determinant()<0&&z.Tools.Warn(`Exporting mesh ${F.name} with negative scale. Result may look incorrect in destination engine.`),b}(F),C=Jb(Q);return`def Xform "${b}" (\n\tprepend references = @./geometries/Geometry_${F.pb.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${C}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${F.material.uniqueId}>\n}\n\n`}function rb(F){switch(F){case R.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case R.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case R.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Hb(F){return`(${F.x}, ${F.y})`}function Bb(F){return`(${F.r}, ${F.g}, ${F.b})`}function db(F,b,Q,z,t,g){const W=F.getInternalTexture().uniqueId+"_"+F.invertY;t[W]=F;const Z=F.coordinatesIndex>0?"st"+F.coordinatesIndex:"st",q=new C.Vector2(F.uScale,F.vScale),G=new C.Vector2(F.uOffset,F.vOffset),K=F.wAng,e=Math.sin(K),N=Math.cos(K);return G.y=1-G.y-q.y,G.x+=e*q.x,G.y+=(1-N)*q.y,`\n    def Shader "PrimvarReader_${Q}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${Z}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${Q}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${b.uniqueId}/PrimvarReader_${Q}.outputs:result>\n        float inputs:rotation = ${(K*(180/Math.PI)).toFixed(g.precision)}\n        float2 inputs:scale = ${Hb(q)}\n        float2 inputs:translation = ${Hb(G)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${F.uniqueId}_${Q}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${W}.png@\n        float2 inputs:st.connect = </Materials/Material_${b.uniqueId}/Transform2d_${Q}.outputs:result>\n        ${z?"float4 inputs:scale = "+function(F){return`(${F.r}, ${F.g}, ${F.b}, 1.0)`}(z):""}\n        token inputs:sourceColorSpace = "${F.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${rb(F.wrapU)}"\n        token inputs:wrapT = "${rb(F.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${b.needAlphaBlending()?"float outputs:a":""}\n    }`}function FQ(F,b,Q){const C="\t\t\t",z=[],t=[],{diffuseMap:g,Tb:W,alphaCutOff:Z,emissiveMap:q,emissive:G,normalMap:K,roughnessMap:e,roughnessChannel:N,roughness:y,metalnessMap:E,metalnessChannel:X,metalness:L,aoMap:i,aoMapChannel:f,aoMapIntensity:k,alphaMap:m,ior:R,clearCoatEnabled:p,clearCoat:D,clearCoatMap:P,clearCoatRoughness:n,clearCoatRoughnessMap:j}=function(F){const b={diffuseMap:null,Tb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return F instanceof EF.qQ?{...b,diffuseMap:F.diffuseTexture,Tb:F.diffuseColor,alphaCutOff:F.alphaCutOff,emissiveMap:F.emissiveTexture,emissive:F.emissiveColor,roughness:1,alphaMap:F.opacityTexture}:F instanceof qb.d?{...b,diffuseMap:F._albedoTexture,Tb:F._albedoColor,alphaCutOff:F._alphaCutOff,emissiveMap:F._emissiveTexture,emissive:F._emissiveColor,normalMap:F._bumpTexture,roughnessMap:F._metallicTexture,roughnessChannel:F._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:F._roughness??1,metalnessMap:F._metallicTexture,metalnessChannel:F._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:F._metallic??0,aoMap:F._ambientTexture,aoMapChannel:F._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:F._ambientTextureStrength,alphaMap:F._opacityTexture,ior:F.subSurface.indexOfRefraction,clearCoatEnabled:F.clearCoat.isEnabled,clearCoat:F.clearCoat.lb,clearCoatMap:F.clearCoat.texture,clearCoatRoughness:F.clearCoat.roughness,clearCoatRoughnessMap:F.clearCoat.useRoughnessFromMainTexture?F.clearCoat.texture:F.clearCoat.textureRoughness}:b}(F);return null!==g?(z.push(`${C}color3f inputs:diffuseColor.connect = </Materials/Material_${F.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:rgb>`),F.needAlphaBlending()?z.push(`${C}float inputs:opacity.connect = </Materials/Material_${F.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:a>`):F.needAlphaTesting()&&(z.push(`${C}float inputs:opacity.connect = </Materials/Material_${F.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:a>`),z.push(`${C}float inputs:opacityThreshold = ${Z}`)),t.push(db(g,F,"diffuse",W,b,Q))):z.push(`${C}color3f inputs:diffuseColor = ${Bb(W||c.GQ.White())}`),null!==q?(z.push(`${C}color3f inputs:emissiveColor.connect = </Materials/Material_${F.uniqueId}/Texture_${q.uniqueId}_emissive.outputs:rgb>`),t.push(db(q,F,"emissive",G,b,Q))):G&&G.toLuminance()>0&&z.push(`${C}color3f inputs:emissiveColor = ${Bb(G)}`),null!==K&&(z.push(`${C}normal3f inputs:normal.connect = </Materials/Material_${F.uniqueId}/Texture_${K.uniqueId}_normal.outputs:rgb>`),t.push(db(K,F,"normal",null,b,Q))),null!==i&&(z.push(`${C}float inputs:occlusion.connect = </Materials/Material_${F.uniqueId}/Texture_${i.uniqueId}_occlusion.outputs:${f}>`),t.push(db(i,F,"occlusion",new c.GQ(k,k,k),b,Q))),null!==e?(z.push(`${C}float inputs:roughness.connect = </Materials/Material_${F.uniqueId}/Texture_${e.uniqueId}_roughness.outputs:${N}>`),t.push(db(e,F,"roughness",new c.GQ(y,y,y),b,Q))):z.push(`${C}float inputs:roughness = ${y}`),null!==E?(z.push(`${C}float inputs:metallic.connect = </Materials/Material_${F.uniqueId}/Texture_${E.uniqueId}_metallic.outputs:${X}>`),t.push(db(E,F,"metallic",new c.GQ(L,L,L),b,Q))):z.push(`${C}float inputs:metallic = ${L}`),null!==m?(z.push(`${C}float inputs:opacity.connect = </Materials/Material_${F.uniqueId}/Texture_${m.uniqueId}_opacity.outputs:r>`),z.push(`${C}float inputs:opacityThreshold = 0.0001`),t.push(db(m,F,"opacity",null,b,Q))):z.push(`${C}float inputs:opacity = ${F.alpha}`),p&&(null!==P?(z.push(`${C}float inputs:clearcoat.connect = </Materials/Material_${F.uniqueId}/Texture_${P.uniqueId}_clearcoat.outputs:r>`),t.push(db(P,F,"clearcoat",new c.GQ(D,D,D),b,Q))):z.push(`${C}float inputs:clearcoat = ${D}`),null!==j?(z.push(`${C}float inputs:clearcoatRoughness.connect = </Materials/Material_${F.uniqueId}/Texture_${j.uniqueId}_clearcoatRoughness.outputs:g>`),t.push(db(j,F,"clearcoatRoughness",new c.GQ(n,n,n),b,Q))):z.push(`${C}float inputs:clearcoatRoughness = ${n}`)),z.push(`${C}float inputs:ior = ${R}`),`\n\tdef Material "Material_${F.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${z.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${F.uniqueId}/PreviewSurface.outputs:surface>\n\n${t.join("\n")}\n\n\t}\n`}async function bQ(F,b,Q){const t={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...b};"undefined"===typeof fflate&&await z.Tools.LoadScriptAsync(t.fflateUrl);const g={};g[t.modelFileName]=null;let W='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';W+=function(F){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===F.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${F.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${F.planeAnchoringAlignment}"`:""}\n            `}(t);const Z={};for(const C of F.meshes){if(0===C.getTotalVertices())continue;const F=C,b=F.pb,q=F.material;if(!q||!b||Q&&!Q(F))continue;if(-1!==["qQ","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(q.getClassName())){const Q="geometries/Geometry_"+b.uniqueId+".usda";if(!(Q in g)){const F=ub(b,t);g[Q]=vb(F)}q.uniqueId in Z||(Z[q.uniqueId]=q),W+=Mb(F)}else z.Tools.Warn("USDZExportAsync does not support this material type: "+q.getClassName())}F.activeCamera&&t.exportCamera&&(W+=function(F,b){const Q="Camera_"+F.uniqueId,z=Jb(C.Matrix.RotationY(Math.PI).multiply(F.getWorldMatrix()));if(F.mode===R.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${Q}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${z}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${F.kb.toPrecision(b.precision)}, ${F.maxZ.toPrecision(b.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(F.orthoLeft||1)+Math.abs(F.orthoRight||1))).toPrecision(b.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(F.orthoTop||1)+Math.abs(F.orthoBottom||1))).toPrecision(b.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const C=F.getEngine().getAspectRatio(F),t=b.cameraSensorWidth||35;return`def Camera "${Q}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${z}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${F.kb.toPrecision(b.precision)}, ${F.maxZ.toPrecision(b.precision)})\n\t\t\tfloat focalLength = ${(t/(2*Math.tan(.5*F.fov))).toPrecision(b.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(t*C).toPrecision(b.precision)}\n\t\t\tfloat verticalAperture = ${(t/C).toPrecision(b.precision)}            \n\t\t}\n\t\n\t`}}(F.activeCamera,t)),W+="\n            }\n        }\n    }";const q={};W+=function(F,b,Q){const C=[];for(const z in F){const t=F[z];C.push(FQ(t,b,Q))}return`\n    def "Materials"\n{\n${C.join("")}\n}\n\n`}(Z,q,t),g[t.modelFileName]=fflate.strToU8(W);for(const C in q){const F=q[C],b=F.getSize(),Q=await F.readPixels();if(!Q)throw new Error("Texture data is not available");const z=await p.DumpTools.DumpDataAsync(b.width,b.height,Q,"image/png",void 0,!1,!0);g[`textures/Texture_${C}.png`]=new Uint8Array(z).slice()}let G=0;for(const C in g){const F=g[C];if(!F)continue;G+=34+C.length;const b=63&G;if(4!==b){const Q=new Uint8Array(64-b);g[C]=[F,{extra:{12345:Q}}]}G=F.length}return fflate.zipSync(g,{level:0})}}}]);