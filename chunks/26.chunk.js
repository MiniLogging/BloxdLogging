"use strict";(self.zjjkhojdx1=self.zjjkhojdx1||[]).push([[26],{11645:(k,h,o)=>{o.r(h),o.d(h,{EXT_materials_diffuse_roughness:()=>Hh,EXT_mesh_gpu_instancing:()=>rk,GLTF2Export:()=>Lk,GLTFData:()=>l,KHR_draco_mesh_compression:()=>oh,KHR_lights_punctual:()=>Gh,KHR_materials_anisotropy:()=>Kh,KHR_materials_clearcoat:()=>Nh,KHR_materials_diffuse_transmission:()=>Wh,KHR_materials_dispersion:()=>Mh,KHR_materials_emissive_strength:()=>jh,KHR_materials_ior:()=>bh,KHR_materials_iridescence:()=>ih,KHR_materials_sheen:()=>Rh,KHR_materials_specular:()=>Zh,KHR_materials_transmission:()=>Dh,KHR_materials_unlit:()=>Qh,KHR_materials_volume:()=>Eh,KHR_texture_transform:()=>Oh,OBJExport:()=>Y,STLExport:()=>zh,USDZExportAsync:()=>ho,_ConvertToGLTFPBRMetallicRoughness:()=>U,_SolveMetallic:()=>D,__IGLTFExporterExtension:()=>J});var x=o(11239),I=o(11078),q=o(11551);class Y{static OBJ(k,h,o,Y){const J=[];let G=1,l=1;h&&(o||(o="mat"),J.push("mtllib "+o+".mtl"));for(let A=0;A<k.length;A++){const o=k[A],K=o.name||`mesh${A}}`;J.push(`o ${K}`);let a=null;if(Y){const k=o.eq(!0);a=new x.Matrix,k.invertToRef(a),o.bakeTransformIntoVertices(k)}if(h){const k=o.material;k&&J.push("usemtl "+k.id)}const N=o.jJ;if(!N){I.Tools.Warn("No geometry is present on the mesh");continue}const X=N.getVerticesData("position"),c=N.getVerticesData("normal"),W=N.getVerticesData("uv"),f=N.dJ();let M=0,T=0;if(!X||!f){I.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const j=k[0].ik().useRightHandedSystem?1:-1;for(let k=0;k<X.length;k+=3)J.push("v "+X[k]*j+" "+X[k+1]+" "+X[k+2]),M++;if(null!=c)for(let k=0;k<c.length;k+=3)J.push("vn "+c[k]*j+" "+c[k+1]+" "+c[k+2]);if(null!=W)for(let k=0;k<W.length;k+=2)J.push("vt "+W[k]+" "+W[k+1]),T++;const d=["","",""],b=(o.material||o.ik().defaultMaterial)._getEffectiveOrientation(o),[V,i]=b===q.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let k=0;k<f.length;k+=3){const h=[String(f[k]+G),String(f[k+V]+G),String(f[k+i]+G)],o=[String(f[k]+l),String(f[k+V]+l),String(f[k+i]+l)],x=h,I=null!=W?o:d,q=null!=c?h:d;J.push("f "+x[0]+"/"+I[0]+"/"+q[0]+" "+x[1]+"/"+I[1]+"/"+q[1]+" "+x[2]+"/"+I[2]+"/"+q[2])}Y&&a&&o.bakeTransformIntoVertices(a),G+=M,l+=T}return J.join("\n")}static MTL(k){const h=[],o=k.material;h.push("newmtl mat1"),h.push("  Ns "+o.specularPower.toFixed(4)),h.push("  Ni 1.5000"),h.push("  d "+o.alpha.toFixed(4)),h.push("  Tr 0.0000"),h.push("  Tf 1.0000 1.0000 1.0000"),h.push("  illum 2"),h.push("  Ka "+o.ambientColor.r.toFixed(4)+" "+o.ambientColor.g.toFixed(4)+" "+o.ambientColor.b.toFixed(4)),h.push("  Kd "+o.diffuseColor.r.toFixed(4)+" "+o.diffuseColor.g.toFixed(4)+" "+o.diffuseColor.b.toFixed(4)),h.push("  Ks "+o.specularColor.r.toFixed(4)+" "+o.specularColor.g.toFixed(4)+" "+o.specularColor.b.toFixed(4)),h.push("  Ke "+o.emissiveColor.r.toFixed(4)+" "+o.emissiveColor.g.toFixed(4)+" "+o.emissiveColor.b.toFixed(4));o.ambientTexture&&h.push("  map_Ka "+o.ambientTexture.name),o.diffuseTexture&&h.push("  map_Kd "+o.diffuseTexture.name),o.specularTexture&&h.push("  map_Ks "+o.specularTexture.name),o.bumpTexture&&h.push("  map_bump -imfchan z "+o.bumpTexture.name),o.opacityTexture&&h.push("  map_d "+o.opacityTexture.name);return h.join("\n")}}var J=0,G=o(11127);class l{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const k in this.files){const h=this.files[k],o=new Blob([h],{type:(0,G.g)(k)});I.Tools.Download(o,k)}}}var A=o(11308),K=o(11648),a=o(11663),N=o(11688),X=o(11369),c=o(11120),W=o(11281),f=o(11260);const M=f.HighestCommonFactor,T={...f,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:M};var j=o(11461),d=o(11223),b=o(11727),V=o(11733),i=o(11456);const F=1e-6,R=new W.Zh(.04,.04,.04),s=1024,Z=W.Zh.White(),w=W.Zh.Black();function D(k,h,o){if(h<R.r)return 0;const x=R.r,I=k*o/(1-R.r)+h-2*R.r,q=I*I-4*x*(R.r-h);return T.Clamp((-I+Math.sqrt(q))/(2*x),0,1)}function U(k){const h=k.diffuseColor.toLinearSpace(k.ik().getEngine().useExactSrgbConversions).scale(.5),o=k.alpha,I=function(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new x.Vector2(0,1),o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new x.Vector2(0,.1),I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new x.Vector2(0,.1),q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new x.Vector2(1300,.1);return function(k,h,o,x,I){return(1-k)*(1-k)*(1-k)*h+3*(1-k)*(1-k)*k*o+3*(1-k)*k*k*x+k*k*k*I}(Math.pow(k/q.x,.333333),h.y,o.y,I.y,q.y)}(T.Clamp(k.specularPower,0,s));return{baseColorFactor:[h.r,h.g,h.b,o],metallicFactor:0,roughnessFactor:I}}function Q(k,h){h.needAlphaBlending()?k.alphaMode="BLEND":h.needAlphaTesting()&&(k.alphaMode="MASK",k.alphaCutoff=h.alphaCutOff)}function B(k,h,o){const x=new Uint8Array(k*h*4);for(let I=0;I<x.length;I+=4)x[I]=x[I+1]=x[I+2]=x[I+3]=255;return b.c.CreateRGBATexture(x,k,h,o)}function E(k){if(k instanceof Uint8Array){const h=k.length,o=new Float32Array(k.length);for(let x=0;x<h;++x)o[x]=k[x]/255;return o}if(k instanceof Float32Array)return k;throw new Error("Unsupported pixel format!")}class n{constructor(k){this._exporter=k,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(k){return k?this._textureMap.get(k)??null:null}async exportStandardMaterialAsync(k,h,o){const x=U(k),q={name:k.name};if(null==k.bJ||k.bJ||(k.twoSidedLighting||I.Tools.Warn(k.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),q.doubleSided=!0),o){const o=[],I=k.diffuseTexture;I&&o.push(this.exportTextureAsync(I,h).then((k=>{k&&(x.baseColorTexture=k)})));const Y=k.bumpTexture;Y&&o.push(this.exportTextureAsync(Y,h).then((k=>{k&&(q.normalTexture=k,1!==Y.level&&(q.normalTexture.scale=Y.level))})));const J=k.emissiveTexture;J&&(q.emissiveFactor=[1,1,1],o.push(this.exportTextureAsync(J,h).then((k=>{k&&(q.emissiveTexture=k)}))));const G=k.ambientTexture;G&&o.push(this.exportTextureAsync(G,h).then((k=>{if(k){const h={index:k.index};q.occlusionTexture=h}}))),o.length>0&&(this._exporter._materialNeedsUVsSet.add(k),await Promise.all(o))}(k.alpha<1||k.opacityTexture)&&(k.alphaMode===V.e.ALPHA_COMBINE?q.alphaMode="BLEND":I.Tools.Warn(k.name+": glTF 2.0 does not support alpha mode: "+k.alphaMode.toString())),k.emissiveColor&&!k.emissiveColor.equalsWithEpsilon(w,F)&&(q.emissiveFactor=k.emissiveColor.rh()),q.pbrMetallicRoughness=x,Q(q,k),await this._finishMaterialAsync(q,k,h);const Y=this._exporter._materials;return Y.push(q),Y.length-1}async _finishMaterialAsync(k,h,o){const x=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",k,h),I=[];for(const q of x)I.push(this.exportTextureAsync(q,o));await Promise.all(I),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",k,h)}async _getImageDataAsync(k,h,x,I){const q=V.e.TEXTURETYPE_UNSIGNED_BYTE,Y=this._exporter._babylonScene,J=Y.getEngine(),G=J.createRawTexture(k,h,x,V.e.TEXTUREFORMAT_RGBA,!1,!0,d.b.NEAREST_SAMPLINGMODE,null,q);J.isWebGPU?await o.e(51).then(o.bind(o,13688)):await o.e(52).then(o.bind(o,13693)),await j.k.ApplyPostProcess("pass",G,Y,q,V.e.TEXTURE_NEAREST_SAMPLINGMODE,V.e.TEXTUREFORMAT_RGBA);const l=await J._readTexturePixels(G,h,x);return await i.DumpTools.DumpDataAsync(h,x,l,I,void 0,!0,!0)}_resizeTexturesToSameDimensions(k,h,o){const x=k?k.getSize():{width:0,height:0},I=h?h.getSize():{width:0,height:0};let q,Y;return x.width<I.width?(q=k&&k instanceof d.b?j.k.CreateResizedCopy(k,I.width,I.height,!0):B(I.width,I.height,o),Y=h):x.width>I.width?(Y=h&&h instanceof d.b?j.k.CreateResizedCopy(h,x.width,x.height,!0):B(x.width,x.height,o),q=k):(q=k,Y=h),{texture1:q,texture2:Y}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(k,h,o,x){const I=new Array;if(!k&&!h)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const q=k?k.ik():h?h.ik():null;if(q){var Y;const J=this._resizeTexturesToSameDimensions(k,h,q),G=null===(Y=J.texture1)||void 0===Y?void 0:Y.getSize();let l,A;const K=G.width,a=G.height,N=await J.texture1.readPixels(),X=await J.texture2.readPixels();if(!N)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(l=E(N),!X)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");A=E(X);const c=A.byteLength,f=new Uint8Array(c),M=new Uint8Array(c),T=4,j=w;let d=0,b=0;for(let k=0;k<a;++k)for(let h=0;h<K;++h){const x=(K*k+h)*T,I={diffuseColor:new W.Zh(l[x],l[x+1],l[x+2]).toLinearSpace(q.getEngine().useExactSrgbConversions).multiply(o.diffuseColor),specularColor:new W.Zh(A[x],A[x+1],A[x+2]).toLinearSpace(q.getEngine().useExactSrgbConversions).multiply(o.specularColor),glossiness:A[x+3]*o.glossiness},Y=this._convertSpecularGlossinessToMetallicRoughness(I);j.r=Math.max(j.r,Y.baseColor.r),j.g=Math.max(j.g,Y.baseColor.g),j.b=Math.max(j.b,Y.baseColor.b),d=Math.max(d,Y.metallic),b=Math.max(b,Y.roughness),M[x]=255*Y.baseColor.r,M[x+1]=255*Y.baseColor.g,M[x+2]=255*Y.baseColor.b,M[x+3]=J.texture1.Sh?255*l[x+3]:255,f[x]=0,f[x+1]=255*Y.roughness,f[x+2]=255*Y.metallic,f[x+3]=255}const V={baseColor:j,metallic:d,roughness:b};let i=!1,R=!1;for(let k=0;k<a;++k)for(let h=0;h<K;++h){const o=(K*k+h)*T;M[o]/=V.baseColor.r>F?V.baseColor.r:1,M[o+1]/=V.baseColor.g>F?V.baseColor.g:1,M[o+2]/=V.baseColor.b>F?V.baseColor.b:1;const x=W.Zh.FromInts(M[o],M[o+1],M[o+2]).toGammaSpace(q.getEngine().useExactSrgbConversions);M[o]=255*x.r,M[o+1]=255*x.g,M[o+2]=255*x.b,x.equalsWithEpsilon(Z,F)||(R=!0),f[o+1]/=V.roughness>F?V.roughness:1,f[o+2]/=V.metallic>F?V.metallic:1;W.Zh.FromInts(255,f[o+1],f[o+2]).equalsWithEpsilon(Z,F)||(i=!0)}return i&&I.push(this._getImageDataAsync(f,K,a,x).then((k=>{V.metallicRoughnessTextureData=k}))),R&&I.push(this._getImageDataAsync(M,K,a,x).then((k=>{V.baseColorTextureData=k}))),await Promise.all(I).then((()=>V))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(k){const h=this._getPerceivedBrightness(k.diffuseColor),o=this._getPerceivedBrightness(k.specularColor),x=1-this._getMaxComponent(k.specularColor),I=D(h,o,x),q=k.diffuseColor.scale(x/(1-R.r)/Math.max(1-I)),Y=k.specularColor.ih(R.scale(1-I)).scale(1/Math.max(I));let J=W.Zh.Lerp(q,Y,I*I);J=J.clampToRef(0,1,J);return{baseColor:J,metallic:I,roughness:1-k.glossiness}}_getPerceivedBrightness(k){return k?Math.sqrt(.299*k.r*k.r+.587*k.g*k.g+.114*k.b*k.b):0}_getMaxComponent(k){return k?Math.max(k.r,Math.max(k.g,k.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(k,h,o,x){const I=[],q={baseColor:k._albedoColor,metallic:k._metallic,roughness:k._roughness};if(x){k._albedoTexture&&I.push(this.exportTextureAsync(k._albedoTexture,h).then((k=>{k&&(o.baseColorTexture=k)})));const x=k._metallicTexture;x&&I.push(this.exportTextureAsync(x,h).then((k=>{k&&(o.metallicRoughnessTexture=k)})))}return I.length>0&&(this._exporter._materialNeedsUVsSet.add(k),await Promise.all(I)),q}_getTextureSampler(k){const h={};if(!k||!(k instanceof d.b))return h;const o=this._getGLTFTextureWrapMode(k.wrapU);10497!==o&&(h.wrapS=o);const x=this._getGLTFTextureWrapMode(k.wrapV);switch(10497!==x&&(h.wrapT=x),k.samplingMode){case d.b.LINEAR_LINEAR:h.magFilter=9729,h.minFilter=9729;break;case d.b.LINEAR_NEAREST:h.magFilter=9729,h.minFilter=9728;break;case d.b.NEAREST_LINEAR:h.magFilter=9728,h.minFilter=9729;break;case d.b.NEAREST_LINEAR_MIPLINEAR:h.magFilter=9728,h.minFilter=9987;break;case d.b.NEAREST_NEAREST:h.magFilter=9728,h.minFilter=9728;break;case d.b.NEAREST_LINEAR_MIPNEAREST:h.magFilter=9728,h.minFilter=9985;break;case d.b.LINEAR_NEAREST_MIPNEAREST:h.magFilter=9729,h.minFilter=9984;break;case d.b.LINEAR_NEAREST_MIPLINEAR:h.magFilter=9729,h.minFilter=9986;break;case d.b.NEAREST_NEAREST_MIPLINEAR:h.magFilter=9728,h.minFilter=9986;break;case d.b.LINEAR_LINEAR_MIPLINEAR:h.magFilter=9729,h.minFilter=9987;break;case d.b.LINEAR_LINEAR_MIPNEAREST:h.magFilter=9729,h.minFilter=9985;break;case d.b.NEAREST_NEAREST_MIPNEAREST:h.magFilter=9728,h.minFilter=9984}return h}_getGLTFTextureWrapMode(k){switch(k){case d.b.WRAP_ADDRESSMODE:return 10497;case d.b.CLAMP_ADDRESSMODE:return 33071;case d.b.MIRROR_ADDRESSMODE:return 33648;default:return I.Tools.Error(`Unsupported Texture Wrap Mode ${k}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(k,h,o,x){const I={diffuseColor:k._albedoColor,specularColor:k._reflectivityColor,glossiness:k._microSurface},q=k._albedoTexture,Y=k._reflectivityTexture,J=k._useMicroSurfaceFromReflectivityMapAlpha;if(Y&&!J)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((q||Y)&&x){this._exporter._materialNeedsUVsSet.add(k);const x=this._exportTextureSampler(q||Y),J=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(q,Y,I,h),G=this._exporter._textures;if(J.baseColorTextureData){const k=this._exportImage(`baseColor${G.length}`,h,J.baseColorTextureData);o.baseColorTexture=this._exportTextureInfo(k,x,null===q||void 0===q?void 0:q.coordinatesIndex)}if(J.metallicRoughnessTextureData){const k=this._exportImage(`metallicRoughness${G.length}`,h,J.metallicRoughnessTextureData);o.metallicRoughnessTexture=this._exportTextureInfo(k,x,null===Y||void 0===Y?void 0:Y.coordinatesIndex)}return J}return this._convertSpecularGlossinessToMetallicRoughness(I)}async exportPBRMaterialAsync(k,h,o){const x={},I={name:k.name},q=k.isMetallicWorkflow();if(q){const h=k._albedoColor,o=k.alpha;h&&(x.baseColorFactor=[h.r,h.g,h.b,o])}const Y=q?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(k,h,x,o):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(k,h,x,o);await this._setMetallicRoughnessPbrMaterialAsync(Y,k,I,x,h,o),await this._finishMaterialAsync(I,k,h);const J=this._exporter._materials;return J.push(I),J.length-1}async _setMetallicRoughnessPbrMaterialAsync(k,h,o,x,q,Y){if(Q(o,h),k.baseColor.equalsWithEpsilon(Z,F)&&T.WithinEpsilon(h.alpha,1,F)||(x.baseColorFactor=[k.baseColor.r,k.baseColor.g,k.baseColor.b,h.alpha]),null!=k.metallic&&1!==k.metallic&&(x.metallicFactor=k.metallic),null!=k.roughness&&1!==k.roughness&&(x.roughnessFactor=k.roughness),null==h.bJ||h.bJ||(h._twoSidedLighting||I.Tools.Warn(h.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),o.doubleSided=!0),Y){const k=[],x=h._bumpTexture;x&&k.push(this.exportTextureAsync(x,q).then((k=>{k&&(o.normalTexture=k,1!==x.level&&(o.normalTexture.scale=x.level))})));const I=h._ambientTexture;I&&k.push(this.exportTextureAsync(I,q).then((k=>{if(k){const x={index:k.index,texCoord:k.texCoord,extensions:k.extensions};o.occlusionTexture=x;const I=h._ambientTextureStrength;I&&(x.strength=I)}})));const Y=h._emissiveTexture;Y&&k.push(this.exportTextureAsync(Y,q).then((k=>{k&&(o.emissiveTexture=k)}))),k.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(k))}const J=h._emissiveColor;J.equalsWithEpsilon(w,F)||(o.emissiveFactor=J.rh()),o.pbrMetallicRoughness=x}_getPixelsFromTextureAsync(k){return function(k){switch(k){case V.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case V.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case V.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case V.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case V.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case V.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case V.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case V.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case V.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case V.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case V.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case V.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case V.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case V.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case V.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case V.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case V.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case V.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case V.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case V.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case V.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(k.textureFormat)?(0,j.i)(k,k._texture.width,k._texture.height):(k.textureType,V.e.TEXTURETYPE_UNSIGNED_BYTE,k.readPixels())}async exportTextureAsync(k,h){const o=this._exporter._extensionsPreExportTextureAsync("exporter",k,h);return o?await o.then((async o=>o?await this._exportTextureInfoAsync(o,h):await this._exportTextureInfoAsync(k,h))):await this._exportTextureInfoAsync(k,h)}async _exportTextureInfoAsync(k,h){let o=this._textureMap.get(k);if(!o){const x=await this._getPixelsFromTextureAsync(k);if(!x)return null;const q=this._exportTextureSampler(k),Y=k.mimeType;if(Y)switch(Y){case"image/jpeg":case"image/png":case"image/webp":h=Y;break;default:I.Tools.Warn(`Unsupported media type: ${Y}. Exporting texture as PNG.`)}const J=this._internalTextureToImage,G=k.getInternalTexture().uniqueId;J[G]||(J[G]={});let l=J[G][h];if(void 0===l){const o=k.getSize();l=(async()=>{const I=await this._getImageDataAsync(x,o.width,o.height,h);return this._exportImage(k.name,h,I)})(),J[G][h]=l}o=this._exportTextureInfo(await l,q,k.coordinatesIndex),this._textureMap.set(k,o),this._exporter._extensionsPostExportTextures("exporter",o,k)}return o}_exportImage(k,h,o){const x=this._exporter._images;let q;if(this._exporter._shouldUseGlb){q={name:k,mimeType:h,bufferView:void 0};const x=this._exporter._bufferManager.createBufferView(new Uint8Array(o));this._exporter._bufferManager.setBufferView(q,x)}else{const Y=k.replace(/\.\/|\/|\.\\|\\/g,"_"),J=function(k){switch(k){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(h);let G=Y+J;x.some((k=>k.uri===G))&&(G=`${Y}_${I.Tools.RandomId()}${J}`),q={name:k,uri:G},this._exporter._imageData[G]={data:o,mimeType:h}}return x.push(q),x.length-1}_exportTextureInfo(k,h,o){const x=this._exporter._textures;let I=x.findIndex((o=>o.sampler==h&&o.source===k));-1===I&&(I=x.length,x.push({source:k,sampler:h}));const q={index:I};return o&&(q.texCoord=o),q}_exportTextureSampler(k){const h=this._getTextureSampler(k),o=this._exporter._samplers,x=o.findIndex((k=>k.minFilter===h.minFilter&&k.magFilter===h.magFilter&&k.wrapS===h.wrapS&&k.wrapT===h.wrapT));return-1!==x?x:(o.push(h),o.length-1)}}var H=o(11323),y=o(11098),O=o(11741),z=o(11248);const p=x.Vh.Zero(),v=x.Quaternion.Identity(),m=x.Vh.One(),L=new x.Vh(-1,1,1);function P(k,h){const{byteOffset:o,byteStride:x,type:I,normalized:q}=k,Y=k.getSize(),J=h.reduce(((k,h)=>h.getTotalVertices()>k?h.getTotalVertices():k),-Number.MAX_VALUE);return{byteOffset:o,byteStride:x,componentCount:Y,type:I,count:J*Y,normalized:q,totalVertices:J,kind:k.getKind()}}function r(k){switch(k){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function t(k){switch(k){case A.g.PositionKind:case A.g.NormalKind:case A.g.TangentKind:case A.g.ColorKind:case A.g.MatricesIndicesKind:case A.g.MatricesIndicesExtraKind:case A.g.MatricesWeightsKind:case A.g.MatricesWeightsExtraKind:case A.g.UVKind:case A.g.UV2Kind:case A.g.UV3Kind:case A.g.UV4Kind:case A.g.UV5Kind:case A.g.UV6Kind:return!0}return!1}function S(k){switch(k){case q.e.TriangleFillMode:return 4;case q.e.TriangleStripDrawMode:return 5;case q.e.TriangleFanDrawMode:return 6;case q.e.PointListDrawMode:case q.e.PointFillMode:return 0;case q.e.LineLoopDrawMode:return 2;case q.e.LineListDrawMode:return 1;case q.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${k}`)}function C(k){const h=Math.sqrt(k.x*k.x+k.y*k.y+k.z*k.z);h>0&&(k.x/=h,k.y/=h,k.z/=h)}function g(k){return k.x*=-1,k}function e(k){if(k.x*k.x+k.y*k.y>.5){const h=Math.abs(k.x),o=Math.abs(k.y);if(h>o){const o=Math.sign(k.x);k.x=h,k.y*=-o,k.z*=-o,k.w*=o}else{const h=Math.sign(k.y);k.x*=-h,k.y=o,k.z*=h,k.w*=-h}}else{const h=Math.abs(k.z),o=Math.abs(k.w);if(h>o){const o=Math.sign(k.z);k.x*=-o,k.y*=o,k.z=h,k.w*=-o}else{const h=Math.sign(k.w);k.x*=h,k.y*=-h,k.z*=-h,k.w=o}}return k}function u(k){k.VJ(-k.z,k.w,k.x,-k.y)}function kk(k,h){const o=x.Vh.FromArrayToRef(h.translation||[0,0,0],0,x.TmpVectors.Vh[0]),I=x.Quaternion.FromArrayToRef(h.rotation||[0,0,0,1],0,x.TmpVectors.Quaternion[0]),q=x.Matrix.ComposeToRef(m,I,o,x.TmpVectors.Matrix[0]),Y=x.Vh.FromArrayToRef(k.translation||[0,0,0],0,x.TmpVectors.Vh[2]),J=x.Quaternion.FromArrayToRef(k.rotation||[0,0,0,1],0,x.TmpVectors.Quaternion[1]),G=x.Matrix.ComposeToRef(m,J,Y,x.TmpVectors.Matrix[1]);q.multiplyToRef(G,G),G.decompose(void 0,I,o),o.equalsWithEpsilon(p,z.d)?delete h.translation:h.translation=o.rh(),I.equalsWithEpsilon(v,z.d)?delete h.rotation:h.rotation=I.rh(),h.scale&&delete h.scale}function hk(k,h){if(!(h instanceof K.e))return!1;if(!(1===h.getChildren().length&&0===k.getChildren().length&&k.parent===h))return!1;const o=k.ik(),x=k instanceof O.e&&!o.useRightHandedSystem?L:m;return!!h.iJ.equalsWithEpsilon(x,z.d)||(y.c.Warn(`Cannot collapse node ${k.name} into parent node ${h.name} with modified scaling.`),!1)}function ok(k){if(k instanceof Array){const h=new Float32Array(k);return new Uint8Array(h.buffer,h.byteOffset,h.byteLength)}return ArrayBuffer.isView(k)?new Uint8Array(k.buffer,k.byteOffset,k.byteLength):new Uint8Array(k)}function xk(k,h){for(const[o,x]of Object.entries(k)){const I=h[o];(Array.isArray(x)&&Array.isArray(I)&&Ik(x,I)||x===I)&&delete k[o]}return k}function Ik(k,h){return k.length===h.length&&k.every(((k,o)=>k===h[o]))}const qk=x.Matrix.Compose(new x.Vh(-1,1,1),x.Quaternion.Identity(),x.Vh.Zero());function Yk(k,h){if(!(k instanceof K.e))return!1;if(h){if(!k.getWorldMatrix().equalsWithEpsilon(x.Matrix.IdentityReadOnly,z.d))return!1}else{if(!k.getWorldMatrix().multiplyToRef(qk,x.TmpVectors.Matrix[0]).equalsWithEpsilon(x.Matrix.IdentityReadOnly,z.d))return!1}return!(k instanceof a.d&&k.jJ)}const Jk=new Map([[Int8Array,(k,h,o)=>k.setInt8(h,o)],[Uint8Array,(k,h,o)=>k.setUint8(h,o)],[Uint8ClampedArray,(k,h,o)=>k.setUint8(h,o)],[Int16Array,(k,h,o)=>k.setInt16(h,o,!0)],[Uint16Array,(k,h,o)=>k.setUint16(h,o,!0)],[Int32Array,(k,h,o)=>k.setInt32(h,o,!0)],[Uint32Array,(k,h,o)=>k.setUint32(h,o,!0)],[Float32Array,(k,h,o)=>k.setFloat32(h,o,!0)],[Float64Array,(k,h,o)=>k.setFloat64(h,o,!0)]]);class Gk{writeTypedArray(k){this._checkGrowBuffer(k.byteLength);const h=Jk.get(k.constructor);for(let o=0;o<k.length;o++)h(this._dataView,this._byteOffset,k[o]),this._byteOffset+=k.BYTES_PER_ELEMENT}constructor(k){this._data=new Uint8Array(k),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(k){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,k),this._byteOffset++}writeInt8(k){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,k),this._byteOffset++}writeInt16(k){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,k,!0),this._byteOffset+=2}writeUInt16(k){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,k,!0),this._byteOffset+=2}writeInt32(k){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,k,!0),this._byteOffset+=4}writeUInt32(k){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,k,!0),this._byteOffset+=4}writeFloat32(k){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,k,!0),this._byteOffset+=4}writeFloat64(k){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,k,!0),this._byteOffset+=8}_checkGrowBuffer(k){const h=this.byteOffset+k;if(h>this._data.byteLength){const k=new Uint8Array(2*h);k.set(this._data),this._data=k,this._dataView=new DataView(this._data.buffer)}}}function lk(k){return k%4===0?4:k%2===0?2:1}class Ak{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(k){let h=0;this._bufferViewToData.forEach((k=>{h+=k.byteLength}));const o=new Gk(h),x=Array.from(this._bufferViewToData.keys()).sort(((k,h)=>lk(h.byteLength)-lk(k.byteLength)));for(const I of x){I.byteOffset=o.byteOffset,k.push(I);const h=k.length-1,x=this.getPropertiesWithBufferView(I);for(const k of x)k.bufferView=h;o.writeTypedArray(this._bufferViewToData.get(I)),this._bufferViewToData.delete(I)}return o.getOutputData()}createBufferView(k,h){const o={buffer:0,byteOffset:void 0,byteLength:k.byteLength,byteStride:h};return this._bufferViewToData.set(o,k),o}createAccessor(k,h,o,x,I,q,Y){this._verifyBufferView(k);const J={bufferView:void 0,componentType:o,count:x,type:h,min:null===q||void 0===q?void 0:q.min,max:null===q||void 0===q?void 0:q.max,normalized:Y,byteOffset:I};return this.setBufferView(J,k),this._accessorToBufferView.set(J,k),J}setBufferView(k,h){this._verifyBufferView(h);this.getPropertiesWithBufferView(h).push(k)}removeBufferView(k){const h=this.getPropertiesWithBufferView(k);for(const o of h)void 0!==o.bufferView&&delete o.bufferView;this._bufferViewToData.delete(k),this._bufferViewToProperties.delete(k),this._accessorToBufferView.forEach(((h,o)=>{h===k&&(void 0!==o.byteOffset&&delete o.byteOffset,this._accessorToBufferView.delete(o))}))}getBufferView(k){const h=this._accessorToBufferView.get(k);return this._verifyBufferView(h),h}getPropertiesWithBufferView(k){return this._verifyBufferView(k),this._bufferViewToProperties.set(k,this._bufferViewToProperties.get(k)??[]),this._bufferViewToProperties.get(k)}getData(k){return this._verifyBufferView(k),this._bufferViewToData.get(k)}_verifyBufferView(k){if(void 0===k||!this._bufferViewToData.has(k))throw new Error(`BufferView ${k} not found in BufferManager.`)}}var Kk,ak=o(11699),Nk=o(11718),Xk=o(11749),ck=o(11610),Wk=o(11783),fk=o(11792),Mk=o(11696),Tk=o(11799);!function(k){k[k.INTANGENT=0]="INTANGENT",k[k.OUTTANGENT=1]="OUTTANGENT"}(Kk||(Kk={}));class jk{static _IsTransformable(k){return k&&(k instanceof K.e||k instanceof ak.d||k instanceof Tk.d)}static _CreateNodeAnimation(k,h,o,x,q){if(this._IsTransformable(k)){const Y=[],J=[],G=h.getKeys(),l=jk._CalculateMinMaxKeyFrames(G),A=jk._DeduceInterpolation(G,o,x),K=A.interpolationType,a=A.shouldBakeAnimation;if(a?jk._CreateBakedAnimation(k,h,o,l.min,l.max,h.framePerSecond,q,Y,J,l,x):"LINEAR"===K||"STEP"===K?jk._CreateLinearOrStepAnimation(k,h,o,Y,J,x):"CUBICSPLINE"===K?jk._CreateCubicSplineAnimation(k,h,o,Y,J,x):jk._CreateBakedAnimation(k,h,o,l.min,l.max,h.framePerSecond,q,Y,J,l,x),Y.length&&J.length){return{inputs:Y,outputs:J,samplerInterpolation:K,inputsMin:a?l.min:I.Tools.FloatRound(l.min/h.framePerSecond),inputsMax:a?l.max:I.Tools.FloatRound(l.max/h.framePerSecond)}}}return null}static _DeduceAnimationInfo(k){let h=null,o="VEC3",x=!1;const q=k.targetProperty.split(".");switch(q[0]){case"iJ":h="scale";break;case"position":h="translation";break;case"rotation":o="VEC4",h="rotation";break;case"rotationQuaternion":o="VEC4",x=!0,h="rotation";break;case"influence":o="SCALAR",h="weights";break;default:I.Tools.Error(`Unsupported animatable property ${q[0]}`)}return h?{animationChannelTargetPath:h,dataAccessorType:o,useQuaternion:x}:(I.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(k,h,o,x,I,q,Y,J,G,l,A){let K;if(jk._IsTransformable(k)&&k.animations)for(const a of k.animations){if(A&&!A(a))continue;const I=jk._DeduceAnimationInfo(a);I&&(K={name:a.name,samplers:[],channels:[]},jk._AddAnimation(`${a.name}`,a.hasRunningRuntimeAnimations?h:K,k,a,I.dataAccessorType,I.animationChannelTargetPath,x,q,Y,J,I.useQuaternion,G,l),K.samplers.length&&K.channels.length&&o.push(K))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(k,h,o,x,I,q,Y,J,G,l,A){let K;if(k instanceof Mk.e){const I=k.morphTargetManager;if(I)for(let a=0;a<I.numTargets;++a){const N=I.getTarget(a);for(const X of N.animations){if(A&&!A(X))continue;const N=new Wk.c(`${X.name}`,"influence",X.framePerSecond,X.dataType,X.loopMode,X.enableBlending),c=[],W=X.getKeys();for(let k=0;k<W.length;++k){const h=W[k];for(let k=0;k<I.numTargets;++k)k==a?c.push(h):c.push({frame:h.frame,value:0})}N.setKeys(c);const f=jk._DeduceAnimationInfo(N);f&&(K={name:N.name,samplers:[],channels:[]},jk._AddAnimation(X.name,X.hasRunningRuntimeAnimations?h:K,k,N,f.dataAccessorType,f.animationChannelTargetPath,x,q,Y,J,f.useQuaternion,G,l,I.numTargets),K.samplers.length&&K.channels.length&&o.push(K))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(k,h,o,x,I,q,Y,J,G){let l;if(k.animationGroups){const K=k.animationGroups;for(const a of K){const K=new Map,N=new Map,X=new Set,c=a.to-a.from;l={name:a.name,channels:[],samplers:[]};for(let h=0;h<a.targetedAnimations.length;++h){const c=a.targetedAnimations[h],W=c.target,f=c.animation;if(G&&!G(f))continue;const M=J.has(W);if(this._IsTransformable(W)||1===W.length&&this._IsTransformable(W[0])){const k=jk._DeduceAnimationInfo(c.animation);if(k){const h=this._IsTransformable(W)?W:this._IsTransformable(W[0])?W[0]:null;h&&jk._AddAnimation(`${f.name}`,l,h,f,k.dataAccessorType,k.animationChannelTargetPath,o,x,I,q,k.useQuaternion,Y,M)}}else if(W instanceof fk.e||1===W.length&&W[0]instanceof fk.e){if(jk._DeduceAnimationInfo(c.animation)){const h=W instanceof fk.e?W:W[0];if(h){const o=k.morphTargetManagers.find((k=>{for(let o=0;o<k.numTargets;++o)if(k.getTarget(o)===h)return!0;return!1}));if(o){const x=k.meshes.find((k=>k.morphTargetManager===o));var A;if(x)K.has(x)||K.set(x,new Map),null===(A=K.get(x))||void 0===A||A.set(h,f),X.add(x),N.set(x,f)}}}}}X.forEach((k=>{const h=k.morphTargetManager;let J=null;const G=[],A=N.get(k).getKeys(),X=A.length;for(let o=0;o<X;++o)for(let x=0;x<h.numTargets;++x){const I=h.getTarget(x),q=K.get(k);if(q){const h=q.get(I);h?(J||(J=new Wk.c(`${a.name}_${k.name}_MorphWeightAnimation`,"influence",h.framePerSecond,Wk.c.ANIMATIONTYPE_FLOAT,h.loopMode,h.enableBlending)),G.push(h.getKeys()[o])):G.push({frame:a.from+c/X*o,value:I.influence,inTangent:A[0].inTangent?0:void 0,outTangent:A[0].outTangent?0:void 0})}}J.setKeys(G);const W=jk._DeduceAnimationInfo(J);W&&jk._AddAnimation(`${a.name}_${k.name}_MorphWeightAnimation`,l,k,J,W.dataAccessorType,W.animationChannelTargetPath,o,x,I,q,W.useQuaternion,Y,!1,null===h||void 0===h?void 0:h.numTargets)})),l.channels.length&&l.samplers.length&&h.push(l)}}}static _AddAnimation(k,h,o,I,q,Y,J,G,l,A,K,a,N,X){const c=jk._CreateNodeAnimation(o,I,Y,K,a);let W,f,M,T,j,d;if(c){if(X){let k=0,h=0;const o=[];for(;c.inputs.length>0;)h=c.inputs.shift(),k%X==0&&o.push(h),k++;c.inputs=o}const k=J.get(o),I=new Float32Array(c.inputs);W=G.createBufferView(I),f=G.createAccessor(W,"SCALAR",5126,c.inputs.length,void 0,{min:[c.inputsMin],max:[c.inputsMax]}),A.push(f),M=A.length-1;const l=new x.Quaternion,K=new x.Vh,a=new x.Vh,b=o instanceof ak.d,V=r(q),i=new Float32Array(c.outputs.length*V);c.outputs.forEach((function(k,h){let o=k;switch(Y){case"translation":N&&(x.Vh.FromArrayToRef(k,0,a),g(a),a.toArray(o));break;case"rotation":4===k.length?x.Quaternion.FromArrayToRef(k,0,l):(o=new Array(4),x.Vh.FromArrayToRef(k,0,K),x.Quaternion.FromEulerVectorToRef(K,l)),N&&(e(l),b&&u(l)),l.toArray(o)}i.set(o,h*V)})),W=G.createBufferView(i),f=G.createAccessor(W,q,5126,c.outputs.length),A.push(f),T=A.length-1,j={interpolation:c.samplerInterpolation,input:M,output:T},h.samplers.push(j),d={sampler:h.samplers.length-1,target:{node:k,path:Y}},h.channels.push(d)}}static _CreateBakedAnimation(k,h,o,q,Y,J,G,l,A,K,a){let N;const X=x.Quaternion.Identity();let c,W=null,f=null,M=null,T=null,j=null,d=null;K.min=I.Tools.FloatRound(q/J);const b=h.getKeys();for(let x=0,V=b.length;x<V;++x){if(d=null,M=b[x],x+1<V)if(T=b[x+1],M.value.equals&&M.value.equals(T.value)||M.value===T.value){if(0!==x)continue;d=M.frame}else d=T.frame;else{if(j=b[x-1],M.value.equals&&M.value.equals(j.value)||M.value===j.value)continue;d=Y}if(d)for(let x=M.frame;x<=d;x+=G){if(c=I.Tools.FloatRound(x/J),c===W)continue;W=c,f=c;const q={key:0,repeatCount:0,loopMode:h.loopMode};N=h._interpolate(x,q),jk._SetInterpolatedValue(k,N,c,h,o,X,l,A,a)}}f&&(K.max=f)}static _ConvertFactorToVector3OrQuaternion(k,h,o,q,Y){const J=jk._GetBasePositionRotationOrScale(h,q,Y),G=o.targetProperty.split("."),l=G?G[1]:"",A=Y?x.Quaternion.Uh(J).normalize():x.Vh.Uh(J);switch(l){case"x":case"y":case"z":A[l]=k;break;case"w":A.w=k;break;default:I.Tools.Error(`glTFAnimation: Unsupported component name "${l}"!`)}return A}static _SetInterpolatedValue(k,h,o,I,q,Y,J,G,l){let A;J.push(o),"weights"!==q?(I.dataType===Wk.c.ANIMATIONTYPE_FLOAT&&(h=this._ConvertFactorToVector3OrQuaternion(h,k,I,q,l)),"rotation"===q?(l?Y=h:(A=h,x.Quaternion.RotationYawPitchRollToRef(A.y,A.x,A.z,Y)),G.push(Y.rh())):(A=h,G.push(A.rh()))):G.push([h])}static _CreateLinearOrStepAnimation(k,h,o,x,I,q){for(const Y of h.getKeys())x.push(Y.frame/h.framePerSecond),jk._AddKeyframeValue(Y,h,I,o,k,q)}static _CreateCubicSplineAnimation(k,h,o,x,I,q){h.getKeys().forEach((function(Y){x.push(Y.frame/h.framePerSecond),jk._AddSplineTangent(Kk.INTANGENT,I,o,"CUBICSPLINE",Y,q),jk._AddKeyframeValue(Y,h,I,o,k,q),jk._AddSplineTangent(Kk.OUTTANGENT,I,o,"CUBICSPLINE",Y,q)}))}static _GetBasePositionRotationOrScale(k,h,o){let I;if("rotation"===h)if(o){I=(k.rotationQuaternion??x.Quaternion.Identity()).rh()}else{I=(k.rotation??x.Vh.Zero()).rh()}else if("translation"===h){I=(k.position??x.Vh.Zero()).rh()}else{I=(k.iJ??x.Vh.One()).rh()}return I}static _AddKeyframeValue(k,h,o,q,Y,J){let G;const l=h.dataType;if(l===Wk.c.ANIMATIONTYPE_VECTOR3){let h=k.value.rh();if("rotation"===q){const k=x.Vh.Uh(h);h=x.Quaternion.RotationYawPitchRoll(k.y,k.x,k.z).rh()}o.push(h)}else if(l===Wk.c.ANIMATIONTYPE_FLOAT){if("weights"===q)o.push([k.value]);else if(G=this._ConvertFactorToVector3OrQuaternion(k.value,Y,h,q,J),G){if("rotation"===q){const k=J?G:x.Quaternion.RotationYawPitchRoll(G.y,G.x,G.z).normalize();o.push(k.rh())}o.push(G.rh())}}else l===Wk.c.ANIMATIONTYPE_QUATERNION?o.push(k.value.normalize().rh()):I.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(k,h,o){let x,I,q=!1;if("rotation"===h&&!o)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let Y=0,J=k.length;Y<J;++Y)if(I=k[Y],I.inTangent||I.outTangent)if(x){if("CUBICSPLINE"!==x){x="LINEAR",q=!0;break}}else x="CUBICSPLINE";else if(x){if("CUBICSPLINE"===x||I.interpolation&&1===I.interpolation&&"STEP"!==x){x="LINEAR",q=!0;break}}else x=I.interpolation&&1===I.interpolation?"STEP":"LINEAR";return x||(x="LINEAR"),{interpolationType:x,shouldBakeAnimation:q}}static _AddSplineTangent(k,h,o,I,q,Y){let J;const G=k===Kk.INTANGENT?q.inTangent:q.outTangent;if("CUBICSPLINE"===I){if("rotation"===o)if(G)if(Y)J=G.rh();else{const k=G;J=x.Quaternion.RotationYawPitchRoll(k.y,k.x,k.z).rh()}else J=[0,0,0,0];else J="weights"===o?G?[G]:[0]:G?G.rh():[0,0,0];h.push(J)}}static _CalculateMinMaxKeyFrames(k){let h=1/0,o=-1/0;return k.forEach((function(k){h=Math.min(h,k.frame),o=Math.max(o,k.frame)})),{min:h,max:o}}}function dk(k,h,o,q,Y,J){const G={attributes:{},influence:k.influence,name:k.name},l=h.jJ;if(!l)return I.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),G;const K=J?-1:1,a=x.Vh.Zero();let N=0,X=0;if(k.hasPositions){const q=k.getPositions(),J=l.getVerticesData(A.g.PositionKind);if(J){const k=new Float32Array(J.length),h=[1/0,1/0,1/0],I=[-1/0,-1/0,-1/0];X=J.length/3,N=0;for(let o=N;o<X;++o){const Y=x.Vh.Uh(J,3*o);x.Vh.Uh(q,3*o).subtractToRef(Y,a),a.x*=K,h[0]=Math.min(h[0],a.x),I[0]=Math.max(I[0],a.x),h[1]=Math.min(h[1],a.y),I[1]=Math.max(I[1],a.y),h[2]=Math.min(h[2],a.z),I[2]=Math.max(I[2],a.z),k[3*o]=a.x,k[3*o+1]=a.y,k[3*o+2]=a.z}const l=o.createBufferView(k,12),A=o.createAccessor(l,"VEC3",5126,q.length/3,0,{min:h,max:I});Y.push(A),G.attributes.POSITION=Y.length-1}else I.Tools.Warn(`Morph target positions for mesh ${h.name} were not exported. Mesh does not have position vertex data`)}if(k.hasNormals){const q=k.getNormals(),J=l.getVerticesData(A.g.NormalKind);if(J){const k=new Float32Array(J.length);X=J.length/3,N=0;for(let o=N;o<X;++o){const h=x.Vh.Uh(J,3*o).normalize();x.Vh.Uh(q,3*o).normalize().subtractToRef(h,a),k[3*o]=a.x*K,k[3*o+1]=a.y,k[3*o+2]=a.z}const h=o.createBufferView(k,12),I=o.createAccessor(h,"VEC3",5126,q.length/3,0);Y.push(I),G.attributes.NORMAL=Y.length-1}else I.Tools.Warn(`Morph target normals for mesh ${h.name} were not exported. Mesh does not have normals vertex data`)}if(k.hasTangents){const q=k.getTangents(),J=l.getVerticesData(A.g.TangentKind);if(J){X=J.length/4;const k=new Float32Array(3*X);N=0;for(let o=N;o<X;++o){const h=x.Vh.Uh(J,4*o);C(h);const I=x.Vh.Uh(q,3*o);C(I),I.subtractToRef(h,a),k[3*o]=a.x*K,k[3*o+1]=a.y,k[3*o+2]=a.z}const h=o.createBufferView(k,12),I=o.createAccessor(h,"VEC3",5126,X,0);Y.push(I),G.attributes.TANGENT=Y.length-1}else I.Tools.Warn(`Morph target tangents for mesh ${h.name} were not exported. Mesh does not have tangents vertex data`)}if(k.hasColors){const q=k.getColors(),J=l.getVerticesData(A.g.ColorKind),K=l.getVertexBuffer(A.g.ColorKind);if(J&&K){const k=K.getSize();X=J.length/k;const h=new Float32Array(X*k);N=0;for(let o=N;o<X;++o)if(3===k){const I=x.Vh.Uh(J,o*k);x.Vh.Uh(q,o*k).subtractToRef(I,a),h[3*o]=a.x,h[3*o+1]=a.y,h[3*o+2]=a.z}else if(4===k){const I=new x.Vector4,Y=x.Vector4.Uh(J,o*k);x.Vector4.Uh(q,o*k).subtractToRef(Y,I),h[4*o]=I.x,h[4*o+1]=I.y,h[4*o+2]=I.z,h[4*o+3]=I.w}else I.Tools.Warn(`Unsupported number of components for color attribute: ${k}`);const l=o.createBufferView(h,4*k),A=o.createAccessor(l,3===k?"VEC3":"VEC4",5126,X,0);Y.push(A),G.attributes.COLOR_0=Y.length-1}else I.Tools.Warn(`Morph target colors for mesh ${h.name} were not exported. Mesh does not have colors vertex data`)}return G}var bk=o(11805),Vk=o(11631),ik=o(11617),Fk=o(11199);class Rk{}Rk.DEFAULT_COLOR=W.Zh.White(),Rk.DEFAULT_WIDTH_ATTENUATED=1,Rk.DEFAULT_WIDTH=.1;var sk=o(11448),Zk=o(11812);class wk{static ConvertPoints(k,h){if(k.length&&Array.isArray(k)&&"number"===typeof k[0])return[k];if(k.length&&Array.isArray(k[0])&&"number"===typeof k[0][0])return k;if(k.length&&!Array.isArray(k[0])&&k[0]instanceof x.Vh){const h=[];for(let o=0;o<k.length;o++){const x=k[o];h.push(x.x,x.y,x.z)}return[h]}if(k.length>0&&Array.isArray(k[0])&&k[0].length>0&&k[0][0]instanceof x.Vh){const h=[],o=k;for(const k of o)h.push(k.flatMap((k=>[k.x,k.y,k.z])));return h}if(k instanceof Float32Array){if(null!==h&&void 0!==h&&h.floatArrayStride){const o=[],x=3*h.floatArrayStride;for(let h=0;h<k.length;h+=x){const I=new Array(x);for(let o=0;o<x;o++)I[o]=k[h+o];o.push(I)}return o}return[Array.from(k)]}if(k.length&&k[0]instanceof Float32Array){const h=[];for(const o of k)h.push(Array.from(o));return h}return[]}static OmitZeroLengthPredicate(k,h,o){const x=[];return h.ih(k).lengthSquared()>0&&x.push([k,h]),o.ih(h).lengthSquared()>0&&x.push([h,o]),k.ih(o).lengthSquared()>0&&x.push([o,k]),0===x.length?null:x}static OmitDuplicatesPredicate(k,h,o,x){const I=[];return wk._SearchInPoints(k,h,x)||I.push([k,h]),wk._SearchInPoints(h,o,x)||I.push([h,o]),wk._SearchInPoints(o,k,x)||I.push([o,k]),0===I.length?null:I}static _SearchInPoints(k,h,o){for(const Y of o)for(let o=0;o<Y.length;o++){var x,I,q;if(null!==(x=Y[o])&&void 0!==x&&x.equals(k))if(null!==(I=Y[o+1])&&void 0!==I&&I.equals(h)||null!==(q=Y[o-1])&&void 0!==q&&q.equals(h))return!0}return!1}static MeshesToLines(k,h){const o=[];for(let I=0;I<k.length;I++){const q=k[I],Y=q.getVerticesData(A.g.PositionKind),J=q.dJ();if(Y&&J)for(let k=0,G=0;k<J.length;k++){const l=3*J[G++],A=3*J[G++],K=3*J[G++],a=new x.Vh(Y[l],Y[l+1],Y[l+2]),N=new x.Vh(Y[A],Y[A+1],Y[A+2]),X=new x.Vh(Y[K],Y[K+1],Y[K+2]);if(h){const x=h(a,N,X,o,k,l,q,I,Y,J);if(x)for(const k of x)o.push(k)}else o.push([a,N],[N,X],[X,a])}}return o}static ToVector3Array(k){if(Array.isArray(k[0])){const h=[],o=k;for(const k of o){const o=[];for(let h=0;h<k.length;h+=3)o.push(new x.Vh(k[h],k[h+1],k[h+2]));h.push(o)}return h}const h=k,o=[];for(let I=0;I<h.length;I+=3)o.push(new x.Vh(h[I],h[I+1],h[I+2]));return o}static ToNumberArray(k){return k.flatMap((k=>[k.x,k.y,k.z]))}static GetPointsCountInfo(k){const h=new Array(k.length);let o=0;for(let x=k.length;x--;)h[x]=k[x].length/3,o+=h[x];return{total:o,counts:h}}static GetLineLength(k){if(0===k.length)return 0;let h;h="number"===typeof k[0]?wk.ToVector3Array(k):k;const o=x.TmpVectors.Vh[0];let I=0;for(let x=0;x<h.length-1;x++){const k=h[x];I+=h[x+1].subtractToRef(k,o).length()}return I}static GetLineLengthArray(k){const h=new Float32Array(k.length/3);let o=0;for(let x=0,I=k.length/3-1;x<I;x++){let I=k[3*x+0],q=k[3*x+1],Y=k[3*x+2];I-=k[3*x+3],q-=k[3*x+4],Y-=k[3*x+5];o+=Math.sqrt(I*I+q*q+Y*Y),h[x+1]=o}return h}static SegmentizeSegmentByCount(k,h,o){const I=[],q=h.ih(k),Y=x.TmpVectors.Vh[0];Y.FJ(o);const J=x.TmpVectors.Vh[1];q.divideToRef(Y,J);let G=k.clone();I.push(G);for(let x=0;x<o;x++)G=G.clone(),I.push(G.addInPlace(J));return I}static SegmentizeLineBySegmentLength(k,h){const o=k[0]instanceof x.Vh?wk.GetLineSegments(k):"number"===typeof k[0]?wk.GetLineSegments(wk.ToVector3Array(k)):k,I=[];for(const x of o)if(x.length>h){const k=wk.SegmentizeSegmentByCount(x.point1,x.point2,Math.ceil(x.length/h));for(const h of k)I.push(h)}else I.push(x.point1),I.push(x.point2);return I}static SegmentizeLineBySegmentCount(k,h){const o="number"===typeof k[0]?wk.ToVector3Array(k):k,x=wk.GetLineLength(o)/h;return wk.SegmentizeLineBySegmentLength(o,x)}static GetLineSegments(k){const h=[];for(let o=0;o<k.length-1;o++){const x=k[o],I=k[o+1],q=I.ih(x).length();h.push({point1:x,point2:I,length:q})}return h}static GetMinMaxSegmentLength(k){const h=wk.GetLineSegments(k).sort((k=>k.length));return{min:h[0].length,max:h[h.length-1].length}}static GetPositionOnLineByVisibility(k,h,o){let I=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const q=h*o;let Y=0,J=0;const G=k.length;for(let x=0;x<G;x++){if(q<=Y+k[x].length){J=x;break}Y+=k[x].length}const l=(q-Y)/k[J].length;return k[J].point2.subtractToRef(k[J].point1,x.TmpVectors.Vh[0]),x.TmpVectors.Vh[1]=x.TmpVectors.Vh[0].multiplyByFloats(l,l,l),I||x.TmpVectors.Vh[1].addInPlace(k[J].point1),x.TmpVectors.Vh[1].clone()}static GetCircleLinePoints(k,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k,q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/h;const Y=[];for(let J=0;J<=h;J++)Y.push(new x.Vh(Math.cos(J*q)*k,Math.sin(J*q)*I,o));return Y}static GetBezierLinePoints(k,h,o,x){return sk.g.CreateQuadraticBezier(k,h,o,x).getPoints().flatMap((k=>[k.x,k.y,k.z]))}static GetArrowCap(k,h,o,x,I){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[k.clone(),k.add(h.multiplyByFloats(o,o,o))],widths:[x,I,q,Y]}}static GetPointsFromText(k,h,o,x){let I=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const Y=[],J=(0,Zk.c)(k,h,o,x);for(const G of J){for(const k of G.paths){const h=[],o=k.getPoints();for(const k of o)h.push(k.x,k.y,I);Y.push(h)}if(q)for(const k of G.holes){const h=[],o=k.getPoints();for(const k of o)h.push(k.x,k.y,I);Y.push(h)}}return Y}static Color3toRGBAUint8(k){const h=new Uint8Array(4*k.length);for(let o=0,x=0;o<k.length;o++)h[x++]=255*k[o].r,h[x++]=255*k[o].g,h[x++]=255*k[o].b,h[x++]=255;return h}static CreateColorsTexture(k,h,o,x){const I=x.getEngine().getCaps().maxTextureSize??1,q=h.length>I?I:h.length,Y=Math.ceil(h.length/I);Y>1&&(h=[...h,...Array(q*Y-h.length).fill(h[0])]);const J=wk.Color3toRGBAUint8(h),G=new b.c(J,q,Y,X.c.TEXTUREFORMAT_RGBA,x,!1,!0,o);return G.name=k,G}static PrepareEmptyColorsTexture(k){if(!Rk.EmptyColorsTexture){const h=new Uint8Array(4);Rk.EmptyColorsTexture=new b.c(h,1,1,X.c.TEXTUREFORMAT_RGBA,k,!1,!1,b.c.NEAREST_NEAREST),Rk.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Rk.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var k;null===(k=Rk.EmptyColorsTexture)||void 0===k||k.dispose(),Rk.EmptyColorsTexture=null}static BooleanToNumber(k){return k?1:0}}class Dk extends ik.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Uk extends Vk.c{isCompatible(k){return!0}constructor(k,h,o){var I;o=o||{color:Rk.DEFAULT_COLOR};const q=new Dk;q.GREASED_LINE_HAS_COLOR=!!o.color&&!o.useColors,q.GREASED_LINE_SIZE_ATTENUATION=o.sizeAttenuation??!1,q.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===o.colorDistributionType,q.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(h??k.ik()).useRightHandedSystem,q.GREASED_LINE_CAMERA_FACING=o.cameraFacing??!0,super(k,Uk.GREASED_LINE_MATERIAL_NAME,200,q,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(I=o)||void 0===I?void 0:I.forceGLSL)||Uk.ForceGLSL,this._scene=h??k.ik(),this._engine=this._scene.getEngine(),this._cameraFacing=o.cameraFacing??!0,this.visibility=o.visibility??1,this.useDash=o.useDash??!1,this.dashRatio=o.dashRatio??.5,this.dashOffset=o.dashOffset??0,this.width=o.width?o.width:o.sizeAttenuation?Rk.DEFAULT_WIDTH_ATTENUATED:Rk.DEFAULT_WIDTH,this._sizeAttenuation=o.sizeAttenuation??!1,this.colorMode=o.colorMode??0,this._color=o.color??null,this.useColors=o.useColors??!1,this._colorsDistributionType=o.colorDistributionType??0,this.colorsSampling=o.colorsSampling??b.c.NEAREST_NEAREST,this._colors=o.Zk??null,this.dashCount=o.dashCount??1,this.resolution=o.resolution??new x.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),o.colorsTexture?this.colorsTexture=o.colorsTexture:this._colors?this.colorsTexture=wk.CreateColorsTexture(`${k.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Rk.DEFAULT_COLOR,wk.PrepareEmptyColorsTexture(this._scene)),this._engine.sh.add((()=>{wk.DisposeEmptyColorsTexture()}))}getAttributes(k){k.push("grl_offsets"),k.push("grl_widths"),k.push("grl_colorPointers"),k.push("grl_counters"),this._cameraFacing?(k.push("grl_previousAndSide"),k.push("grl_nextAndCounters")):k.push("grl_slopes")}getSamplers(k){k.push("grl_colors")}getActiveTextures(k){this.colorsTexture&&k.push(this.colorsTexture)}getUniforms(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const h=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&h.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===k&&h.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:h,vertex:this._cameraFacing&&this._isGLSL(k)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(k)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(k){if(this._cameraFacing){k.qq("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||k.qq("viewProjection",this._scene.getTransformMatrix());const h=x.TmpVectors.Vector4[0];h.x=this._aspect,h.y=this._resolution.x,h.z=this._resolution.y,h.w=this.width,k.updateVector4("grl_aspect_resolution_lineWidth",h)}const h=x.TmpVectors.Vector4[0];h.x=wk.BooleanToNumber(this.useDash),h.y=this._dashArray,h.z=this.dashOffset,h.w=this.dashRatio,k.updateVector4("grl_dashOptions",h);const o=x.TmpVectors.Vector4[1];o.x=this.colorMode,o.y=this.visibility,o.z=this.colorsTexture?this.colorsTexture.getSize().width:0,o.w=wk.BooleanToNumber(this.useColors),k.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",o),this._color&&k.updateColor3("grl_singleColor",this._color);const I=this.colorsTexture??Rk.EmptyColorsTexture;k.setTexture("grl_colors",I),k.updateFloat2("grl_textureSize",(null===I||void 0===I?void 0:I.getSize().width)??1,(null===I||void 0===I?void 0:I.getSize().height)??1)}prepareDefines(k,h,o){k.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,k.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,k.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,k.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=h.useRightHandedSystem,k.GREASED_LINE_CAMERA_FACING=this._cameraFacing,k.GREASED_LINE_USE_OFFSETS=!!o.offsets}getClassName(){return Uk.GREASED_LINE_MATERIAL_NAME}getCustomCode(k){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(h)?function(k,h){if("vertex"===k){const k={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return h&&(k["!gl_Position\\=viewProjection\\*worldPos;"]="//"),k}return"fragment"===k?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(k,this._cameraFacing):function(k,h){if("vertex"===k){const k={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return h&&(k["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),k}return"fragment"===k?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(k,this._cameraFacing)}dispose(){var k;null===(k=this.colorsTexture)||void 0===k||k.dispose(),super.dispose()}get Zk(){return this._colors}set Zk(k){this.setColors(k)}setColors(k){var h;let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],x=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const I=(null===(h=this._colors)||void 0===h?void 0:h.length)??0;var q;if(this._colors=k,null!==k&&0!==k.length){if(!o||x)if(this.colorsTexture&&I===k.length&&!x){const h=wk.Color3toRGBAUint8(k);this.colorsTexture.update(h)}else{var Y;null===(Y=this.colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=wk.CreateColorsTexture(`${this._material.name}-colors-texture`,k,this.colorsSampling,this._scene)}}else null===(q=this.colorsTexture)||void 0===q||q.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(k){this._dashCount=k,this._dashArray=1/k}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(k){this._sizeAttenuation=k,this.markAllDefinesAsDirty()}get color(){return this._color}set color(k){this.setColor(k)}setColor(k){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==k||null!==this._color&&null===k?(this._color=k,h||this.markAllDefinesAsDirty()):this._color=k}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(k){this._colorsDistributionType=k,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(k){this._aspect=k.x/k.y,this._resolution=k}serialize(){const k=super.serialize(),h={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(h.Zk=this._colors),this._color&&(h.color=this._color),k.greasedLineMaterialOptions=h,k}parse(k,h,o){var x;super.parse(k,h,o);const I=k.greasedLineMaterialOptions;null===(x=this.colorsTexture)||void 0===x||x.dispose(),I.color&&this.setColor(I.color,!0),I.colorDistributionType&&(this.colorsDistributionType=I.colorDistributionType),I.Zk&&(this.Zk=I.Zk),I.colorsSampling&&(this.colorsSampling=I.colorsSampling),I.colorMode&&(this.colorMode=I.colorMode),I.useColors&&(this.useColors=I.useColors),I.visibility&&(this.visibility=I.visibility),I.useDash&&(this.useDash=I.useDash),I.dashCount&&(this.dashCount=I.dashCount),I.dashRatio&&(this.dashRatio=I.dashRatio),I.dashOffset&&(this.dashOffset=I.dashOffset),I.width&&(this.width=I.width),I.sizeAttenuation&&(this.sizeAttenuation=I.sizeAttenuation),I.resolution&&(this.resolution=I.resolution),this.Zk?this.colorsTexture=wk.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Zk,this.colorsSampling,h):wk.PrepareEmptyColorsTexture(h),this.markAllDefinesAsDirty()}copyTo(k){var h;const o=k;null===(h=o.colorsTexture)||void 0===h||h.dispose(),this._colors&&(o.colorsTexture=wk.CreateColorsTexture(`${o._material.name}-colors-texture`,this._colors,o.colorsSampling,this._scene)),o.setColor(this.color,!0),o.colorsDistributionType=this.colorsDistributionType,o.colorsSampling=this.colorsSampling,o.colorMode=this.colorMode,o.useColors=this.useColors,o.visibility=this.visibility,o.useDash=this.useDash,o.dashCount=this.dashCount,o.dashRatio=this.dashRatio,o.dashOffset=this.dashOffset,o.width=this.width,o.sizeAttenuation=this.sizeAttenuation,o.resolution=this.resolution,o.markAllDefinesAsDirty()}_isGLSL(k){return 0===k||this._forceGLSL}}Uk.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Uk.ForceGLSL=!1,(0,Fk.g)(`BABYLON.${Uk.GREASED_LINE_MATERIAL_NAME}`,Uk);var Qk=o(11672),Bk=o(11103),Ek=o(11470),nk=o(11183);class Hk extends Ek.ShaderMaterial{constructor(k,h,I){const q=h.getEngine(),Y=q.isWebGPU&&!(I.forceGLSL||Hk.ForceGLSL),J=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];h.useRightHandedSystem&&J.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const G=["position","grl_widths","grl_offsets","grl_colorPointers"];I.cameraFacing?(J.push("GREASED_LINE_CAMERA_FACING"),G.push("grl_previousAndSide","grl_nextAndCounters")):(G.push("grl_slopes"),G.push("grl_counters"));const l=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(Y||l.push("world","viewProjection","view","projection"),super(k,h,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:Y?["Scene","Mesh"]:void 0,attributes:G,uniforms:l,samplers:Y?[]:["grlColors"],defines:J,extraInitializationsAsync:async()=>{Y?await Promise.all([o.e(66).then(o.bind(o,14323)),o.e(75).then(o.bind(o,14331))]):await Promise.all([o.e(69).then(o.bind(o,14336)),o.e(76).then(o.bind(o,14344))])},shaderLanguage:Y?1:0}),this._color=W.Zh.White(),this._colorsDistributionType=0,this._colorsTexture=null,I=I||{color:Rk.DEFAULT_COLOR},this.visibility=I.visibility??1,this.useDash=I.useDash??!1,this.dashRatio=I.dashRatio??.5,this.dashOffset=I.dashOffset??0,this.dashCount=I.dashCount??1,this.width=I.width?I.width:I.sizeAttenuation&&I.cameraFacing?Rk.DEFAULT_WIDTH_ATTENUATED:Rk.DEFAULT_WIDTH,this.sizeAttenuation=I.sizeAttenuation??!1,this.color=I.color??W.Zh.White(),this.useColors=I.useColors??!1,this.colorsDistributionType=I.colorDistributionType??0,this.colorsSampling=I.colorsSampling??b.c.NEAREST_NEAREST,this.colorMode=I.colorMode??0,this._colors=I.Zk??null,this._cameraFacing=I.cameraFacing??!0,this.resolution=I.resolution??new x.Vector2(q.getRenderWidth(),q.getRenderHeight()),I.colorsTexture?this.colorsTexture=I.colorsTexture:this._colors?this.colorsTexture=wk.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,h):(this._color=this._color??Rk.DEFAULT_COLOR,this.colorsTexture=wk.PrepareEmptyColorsTexture(h)),Y){const k=new nk.c;k.setParameters(),k.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",k)}q.sh.add((()=>{wk.DisposeEmptyColorsTexture()}))}dispose(){var k;null===(k=this._colorsTexture)||void 0===k||k.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new x.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Zk(){return this._colors}set Zk(k){this.setColors(k)}setColors(k){var h;let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],x=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const I=(null===(h=this._colors)||void 0===h?void 0:h.length)??0;var q;if(this._colors=k,null!==k&&0!==k.length){if(!o||x)if(this._colorsTexture&&I===k.length&&!x){const h=wk.Color3toRGBAUint8(k);this._colorsTexture.update(h)}else{var Y;null===(Y=this._colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=wk.CreateColorsTexture(`${this.name}-colors-texture`,k,this.colorsSampling,this.ik())}}else null===(q=this._colorsTexture)||void 0===q||q.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(k){this._colorsTexture=k,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(k){this._width=k,this.setFloat("grlWidth",k)}get useColors(){return this._useColors}set useColors(k){this._useColors=k,this.setFloat("grlUseColors",wk.BooleanToNumber(k))}get colorsSampling(){return this._colorsSampling}set colorsSampling(k){this._colorsSampling=k}get visibility(){return this._visibility}set visibility(k){this._visibility=k,this.setFloat("grlVisibility",k)}get useDash(){return this._useDash}set useDash(k){this._useDash=k,this.setFloat("grlUseDash",wk.BooleanToNumber(k))}get dashOffset(){return this._dashOffset}set dashOffset(k){this._dashOffset=k,this.setFloat("grlDashOffset",k)}get dashRatio(){return this._dashRatio}set dashRatio(k){this._dashRatio=k,this.setFloat("grlDashRatio",k)}get dashCount(){return this._dashCount}set dashCount(k){this._dashCount=k,this._dashArray=1/k,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(k){this._sizeAttenuation=k,this.setFloat("grlSizeAttenuation",wk.BooleanToNumber(k))}get color(){return this._color}set color(k){this.setColor(k)}setColor(k){k=k??Rk.DEFAULT_COLOR,this._color=k,this.setColor3("grlColor",k)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(k){this._colorsDistributionType=k,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(k){this._colorMode=k,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(k){this._resolution=k,this.setVector2("grlResolution",k),this.setFloat("grlAspect",k.x/k.y)}serialize(){const k=super.serialize(),h={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(h.Zk=this._colors),k.greasedLineMaterialOptions=h,k}parse(k,h,o){var x;const I=k.greasedLineMaterialOptions;null===(x=this._colorsTexture)||void 0===x||x.dispose(),I.color&&(this.color=I.color),I.colorDistributionType&&(this.colorsDistributionType=I.colorDistributionType),I.colorsSampling&&(this.colorsSampling=I.colorsSampling),I.colorMode&&(this.colorMode=I.colorMode),I.useColors&&(this.useColors=I.useColors),I.visibility&&(this.visibility=I.visibility),I.useDash&&(this.useDash=I.useDash),I.dashCount&&(this.dashCount=I.dashCount),I.dashRatio&&(this.dashRatio=I.dashRatio),I.dashOffset&&(this.dashOffset=I.dashOffset),I.width&&(this.width=I.width),I.sizeAttenuation&&(this.sizeAttenuation=I.sizeAttenuation),I.resolution&&(this.resolution=I.resolution),I.Zk?this.colorsTexture=wk.CreateColorsTexture(`${this.name}-colors-texture`,I.Zk,this.colorsSampling,this.ik()):this.colorsTexture=wk.PrepareEmptyColorsTexture(h),this._cameraFacing=I.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var yk,Ok,zk;Hk.ForceGLSL=!1,function(k){k[k.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",k[k.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(yk||(yk={})),function(k){k[k.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",k[k.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",k[k.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Ok||(Ok={})),function(k){k[k.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",k[k.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",k[k.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",k[k.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",k[k.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(zk||(zk={}));class pk extends Mk.e{constructor(k,h,o){super(k,h,null,null,!1,!1),this.name=k,this._options=o,this._lazy=!1,this._updatable=!1,this._engine=h.getEngine(),this._lazy=o.lazy??!1,this._updatable=o.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=o.colorPointers??[],this._widths=o.widths??new Array(o.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(k){let h=0;for(const x of this._points)h+=x.length;const o=h/3*2-this._widths.length;for(let x=0;x<o;x++)this._widths.push(k)}updateLazy(){var k,h;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(k=this._options.ribbonOptions)||void 0===k?void 0:k.smoothShading),!this.Qk&&this.refreshBoundingInfo(),null===(h=this.greasedLineMaterial)||void 0===h||h.updateLazy()}addPoints(k,h){for(const o of k)this._points.push(o);this._lazy||this.setPoints(this._points,h)}dispose(k){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(k,h)}isLazy(){return this._lazy}get wk(){return this._uvs}set wk(k){this._uvs=k instanceof Float32Array?k:new Float32Array(k),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(k){this.material instanceof Hk&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===k||void 0===k?void 0:k.length)>0),this._offsets=k,this._offsetsBuffer?this._offsetsBuffer.update(k):this._createOffsetsBuffer(k)}get widths(){return this._widths}set widths(k){this._widths=k,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(k)}get colorPointers(){return this._colorPointers}set colorPointers(k){this._colorPointers=k,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(k)}get greasedLineMaterial(){var k,h;if(this.material&&this.material instanceof Hk)return this.material;const o=null===(k=this.material)||void 0===k||null===(h=k.pluginManager)||void 0===h?void 0:h.getPlugin(Uk.GREASED_LINE_MATERIAL_NAME);return o||void 0}get points(){const k=[];return Bk.d.DeepCopy(this._points,k),k}setPoints(k,h){this._points=wk.ConvertPoints(k,(null===h||void 0===h?void 0:h.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==h&&void 0!==h&&h.colorPointers||this._updateColorPointers(),this._setPoints(this._points,h)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,wk:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(k){super.serialize(k),k.type=this.getClassName(),k.lineOptions=this._createLineOptions()}_createVertexBuffers(){let k=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new Qk.e;return h.Rk=this._vertexPositions,h.indices=this._indices,h.wk=this._uvs,k&&(h.sk=[],Qk.e.ComputeNormals(this._vertexPositions,this._indices,h.sk)),h.Uk(this,this._options.updatable),h}_createOffsetsBuffer(k){const h=this._scene.getEngine(),o=new A.d(h,k,this._updatable,3);this.setVerticesBuffer(o.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=o}}class vk{constructor(k,h){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=k,this.wasAddedByNoopNode=h}getIndicesAccessor(k,h,o,x,I){var q,Y,J,G;return null===(q=this._indicesAccessorMap.get(k))||void 0===q||null===(Y=q.get(h))||void 0===Y||null===(J=Y.get(o))||void 0===J||null===(G=J.get(x))||void 0===G?void 0:G.get(I)}setIndicesAccessor(k,h,o,x,I,q){let Y=this._indicesAccessorMap.get(k);Y||(Y=new Map,this._indicesAccessorMap.set(k,Y));let J=Y.get(h);J||(J=new Map,Y.set(h,J));let G=J.get(o);G||(G=new Map,J.set(o,G));let l=G.get(x);l||(l=new Map,G.set(x,l)),l.set(I,q)}pushExportedNode(k){this._exportedNodes.has(k)||this._exportedNodes.add(k)}getNodesSet(){return this._exportedNodes}getVertexBufferView(k){return this._vertexBufferViewMap.get(k)}setVertexBufferView(k,h){this._vertexBufferViewMap.set(k,h)}setRemappedBufferView(k,h,o){this._remappedBufferView.set(k,new Map),this._remappedBufferView.get(k).set(h,o)}getRemappedBufferView(k,h){var o;return null===(o=this._remappedBufferView.get(k))||void 0===o?void 0:o.get(h)}getVertexAccessor(k,h,o){var x,I;return null===(x=this._vertexAccessorMap.get(k))||void 0===x||null===(I=x.get(h))||void 0===I?void 0:I.get(o)}setVertexAccessor(k,h,o,x){let I=this._vertexAccessorMap.get(k);I||(I=new Map,this._vertexAccessorMap.set(k,I));let q=I.get(h);q||(q=new Map,I.set(h,q)),q.set(o,x)}hasVertexColorAlpha(k){return this._vertexMapColorAlpha.get(k)||!1}setHasVertexColorAlpha(k,h){return this._vertexMapColorAlpha.set(k,h)}getMesh(k){return this._meshMap.get(k)}setMesh(k,h){this._meshMap.set(k,h)}bindMorphDataToMesh(k,h){const o=this._meshMorphTargetMap.get(k)||[];this._meshMorphTargetMap.set(k,o),-1===o.indexOf(h)&&o.push(h)}getMorphTargetsFromMesh(k){return this._meshMorphTargetMap.get(k)}}class mk{_ApplyExtension(k,h,o,x){if(o>=h.length)return Promise.resolve(k);const I=x(h[o],k);return I?I.then((async k=>k?await this._ApplyExtension(k,h,o+1,x):null)):this._ApplyExtension(k,h,o+1,x)}_ApplyExtensions(k,h){const o=[];for(const x of mk._ExtensionNames)o.push(this._extensions[x]);return this._ApplyExtension(k,o,0,h)}_extensionsPreExportTextureAsync(k,h,o){return this._ApplyExtensions(h,((h,x)=>h.preExportTextureAsync&&h.preExportTextureAsync(k,x,o)))}_extensionsPostExportNodeAsync(k,h,o,x,I){return this._ApplyExtensions(h,((h,q)=>h.postExportNodeAsync&&h.postExportNodeAsync(k,q,o,x,I,this._bufferManager)))}_extensionsPostExportMaterialAsync(k,h,o){return this._ApplyExtensions(h,((h,x)=>h.postExportMaterialAsync&&h.postExportMaterialAsync(k,x,o)))}_extensionsPostExportMaterialAdditionalTextures(k,h,o){const x=[];for(const I of mk._ExtensionNames){const q=this._extensions[I];q.postExportMaterialAdditionalTextures&&x.push(...q.postExportMaterialAdditionalTextures(k,h,o))}return x}_extensionsPostExportTextures(k,h,o){for(const x of mk._ExtensionNames){const I=this._extensions[x];I.postExportTexture&&I.postExportTexture(k,h,o)}}_extensionsPostExportMeshPrimitive(k){for(const h of mk._ExtensionNames){const o=this._extensions[h];o.postExportMeshPrimitive&&o.postExportMeshPrimitive(k,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const k of mk._ExtensionNames){const h=this._extensions[k];h.preGenerateBinaryAsync&&await h.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(k){for(const h of mk._ExtensionNames){const o=this._extensions[h];o.enabled&&k(o)}}_extensionsOnExporting(){this._forEachExtensions((k=>{var h,o,x;k.wasUsed&&((h=this._glTF).extensionsUsed||(h.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(k.name)&&this._glTF.extensionsUsed.push(k.name),k.required&&((o=this._glTF).extensionsRequired||(o.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(k.name)&&this._glTF.extensionsRequired.push(k.name)),(x=this._glTF).extensions||(x.extensions={}),k.onExporting&&k.onExporting())}))}_loadExtensions(){for(const k of mk._ExtensionNames){const h=mk._ExtensionFactories[k](this);this._extensions[k]=h}}constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:c.b.LastCreatedScene,h=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${X.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new n(this),this._extensions={},this._bufferManager=new Ak,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!k)throw new Error("No scene available to export");this._babylonScene=k,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:k=>{var h;return null===k||void 0===k||null===(h=k.Bh)||void 0===h?void 0:h.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...h},this._loadExtensions()}dispose(){for(const k in this._extensions){this._extensions[k].dispose()}}get options(){return this._options}static RegisterExtension(k,h){mk.UnregisterExtension(k)&&I.Tools.Warn(`Extension with the name ${k} already exists`),mk._ExtensionFactories[k]=h,mk._ExtensionNames.push(k)}static UnregisterExtension(k){if(!mk._ExtensionFactories[k])return!1;delete mk._ExtensionFactories[k];const h=mk._ExtensionNames.indexOf(k);return-1!==h&&mk._ExtensionNames.splice(h,1),!0}_generateJSON(k,h,o){const x={byteLength:k};return x.byteLength&&(this._glTF.buffers=[x]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Fh=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(x.uri=h+".bin"),o?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(k){const h=await this._generateBinaryAsync();this._extensionsOnExporting();const o=this._generateJSON(h.byteLength,k,!0),x=new Blob([h],{type:"application/octet-stream"}),I=k+".gltf",q=k+".bin",Y=new l;if(Y.files[I]=o,Y.files[q]=x,this._imageData)for(const J in this._imageData)Y.files[J]=new Blob([this._imageData[J].data],{type:this._imageData[J].mimeType});return Y}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(k){const h=k%4;return 0===h?h:4-h}async generateGLBAsync(k){this._shouldUseGlb=!0;const h=await this._generateBinaryAsync();this._extensionsOnExporting();const o=this._generateJSON(h.byteLength),x=k+".glb";let I,q=o.length;if("undefined"!==typeof TextEncoder){I=(new TextEncoder).encode(o),q=I.length}const Y=this._getPadding(q),J=this._getPadding(h.byteLength),G=28+q+Y+h.byteLength+J,A=new Gk(G);if(A.writeUInt32(1179937895),A.writeUInt32(2),A.writeUInt32(G),A.writeUInt32(q+Y),A.writeUInt32(1313821514),I)A.writeTypedArray(I);else{const k="_".charCodeAt(0);for(let h=0;h<q;++h){const x=o.charCodeAt(h);x!=o.codePointAt(h)?A.writeUInt8(k):A.writeUInt8(x)}}for(let l=0;l<Y;++l)A.writeUInt8(32);A.writeUInt32(h.byteLength+J),A.writeUInt32(5130562),A.writeTypedArray(h);for(let l=0;l<J;++l)A.writeUInt8(0);const K=new l;return K.files[x]=new Blob([A.getOutputData()],{type:"application/octet-stream"}),K}_setNodeTransformation(k,h,o){if(h.getPivotPoint().equalsWithEpsilon(p,z.d)||I.Tools.Warn("Pivot points are not supported in the glTF serializer"),!h.position.equalsWithEpsilon(p,z.d)){const I=x.TmpVectors.Vh[0].Y(h.position);o&&g(I),k.translation=I.rh()}h.iJ.equalsWithEpsilon(m,z.d)||(k.scale=h.iJ.rh());const q=h.rotationQuaternion||x.Quaternion.FromEulerAngles(h.rotation.x,h.rotation.y,h.rotation.z);q.equalsWithEpsilon(v,z.d)||(o&&e(q),k.rotation=q.normalize().rh())}_setCameraTransformation(k,h,o){if(!h.position.equalsWithEpsilon(p,z.d)){const I=x.TmpVectors.Vh[0].Y(h.position);o&&g(I),k.translation=I.rh()}const I=h.rotationQuaternion||x.Quaternion.FromEulerAngles(h.rotation.x,h.rotation.y,h.rotation.z);o&&e(I),this._babylonScene.useRightHandedSystem||u(I),I.equalsWithEpsilon(v,z.d)||(k.rotation=I.rh())}_listAvailableCameras(){for(const k of this._babylonScene.cameras){const h={type:k.mode===ak.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(k.name&&(h.name=k.name),"perspective"===h.type)h.perspective={aspectRatio:k.getEngine().getAspectRatio(k),yfov:k.fovMode===ak.d.FOVMODE_VERTICAL_FIXED?k.fov:k.fov*k.getEngine().getAspectRatio(k),znear:k.nx,zfar:k.maxZ};else if("orthographic"===h.type){const o=k.orthoLeft&&k.orthoRight?.5*(k.orthoRight-k.orthoLeft):.5*k.getEngine().getRenderWidth(),x=k.orthoBottom&&k.orthoTop?.5*(k.orthoTop-k.orthoBottom):.5*k.getEngine().getRenderHeight();h.orthographic={xmag:o,ymag:x,znear:k.nx,zfar:k.maxZ}}this._camerasMap.set(k,h)}}_exportAndAssignCameras(){const k=Array.from(this._camerasMap.values());for(const h of k){const k=this._nodesCameraMap.get(h);if(void 0!==k){this._cameras.push(h);for(const h of k)h.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const k of this._babylonScene.skeletons){if(k.bones.length<=0)continue;const h={joints:[]};this._skinMap.set(k,h)}}_exportAndAssignSkeletons(){for(const k of this._babylonScene.skeletons){if(k.bones.length<=0)continue;const h=this._skinMap.get(k);if(void 0==h)continue;const o={},x=[];let q=-1;for(let I=0;I<k.bones.length;++I){const h=k.bones[I],x=h.getIndex()??I;-1!==x&&(o[x]=h,x>q&&(q=x))}for(let k=0;k<=q;++k){const q=o[k];x.push(q.getAbsoluteInverseBindMatrix());const Y=q.getTransformNode();if(null!==Y){const k=this._nodeMap.get(Y);Y&&null!==k&&void 0!==k?h.joints.push(k):I.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else I.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const Y=this._nodesSkinMap.get(h);if(h.joints.length>0&&void 0!==Y){const k=64*x.length,o=new Float32Array(k/4);x.forEach(((k,h)=>{o.set(k.m,16*h)}));const I=this._bufferManager.createBufferView(o);this._accessors.push(this._bufferManager.createAccessor(I,"MAT4",5126,x.length)),h.inverseBindMatrices=this._accessors.length-1,this._skins.push(h);for(const h of Y)h.skin=this._skins.length-1}}}async _exportSceneAsync(){const k={nodes:[]};if(this._babylonScene.metadata){const h=this._options.metadataSelector(this._babylonScene.metadata);h&&(k.extras=h)}const h=new Array,o=new Array,x=new Array;for(const J of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Yk(J,this._babylonScene.useRightHandedSystem)?x.push(...J.getChildren()):this._babylonScene.useRightHandedSystem?h.push(J):o.push(J);this._listAvailableCameras(),this._listAvailableSkeletons();const I=new vk(!0,!1);k.nodes.push(...await this._exportNodesAsync(o,I));const q=new vk(!1,!1);k.nodes.push(...await this._exportNodesAsync(h,q));const Y=new vk(!1,!0);k.nodes.push(...await this._exportNodesAsync(x,Y)),k.nodes.length&&this._scenes.push(k),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&jk._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,I.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(k){let h=this._shouldExportNodeMap.get(k);return void 0===h&&(h=this._options.shouldExportNode(k),this._shouldExportNodeMap.set(k,h)),h}async _exportNodesAsync(k,h){const o=new Array;this._exportBuffers(k,h);for(const x of k)await this._exportNodeAsync(x,o,h);return o}_collectBuffers(k,h,o,x,I){if(this._shouldExportNode(k)&&k instanceof a.d&&k.jJ){const q=k.jJ.getVertexBuffers();if(q)for(const x in q){if(!t(x))continue;const Y=q[x];I.setHasVertexColorAlpha(Y,k.hasVertexAlpha);const J=Y._buffer,G=h.get(J)||[];h.set(J,G),-1===G.indexOf(Y)&&G.push(Y);const l=o.get(Y)||[];o.set(Y,l),-1===l.indexOf(k)&&l.push(k)}const Y=k.morphTargetManager;if(Y)for(let h=0;h<Y.numTargets;h++){const o=Y.getTarget(h),I=x.get(o)||[];x.set(o,I),-1===I.indexOf(k)&&I.push(k)}}for(const q of k.getChildren())this._collectBuffers(q,h,o,x,I)}_exportBuffers(k,h){const o=new Map,x=new Map,I=new Map;for(const J of k)this._collectBuffers(J,o,x,I,h);const q=Array.from(o.keys());for(const J of q){const k=J.getData();if(!k)throw new Error("Buffer data is not available");const I=o.get(J);if(!I)continue;const q=I[0].byteStride;if(I.some((k=>k.byteStride!==q)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const Y=ok(k).slice();for(const h of I){const k=x.get(h),{byteOffset:o,byteStride:I,componentCount:q,type:J,count:G,normalized:l,kind:K}=P(h,k);switch(K){case A.g.NormalKind:case A.g.TangentKind:(0,H.g)(Y,o,I,q,J,G,l,(k=>{const h=Math.sqrt(k[0]*k[0]+k[1]*k[1]+k[2]*k[2]);if(h>0){const o=1/h;k[0]*=o,k[1]*=o,k[2]*=o}}));break;case A.g.ColorKind:{const h=k.filter((k=>k.material instanceof ck.Rh||null==k.material)).length;if(0==h)break;if(h!=k.length){y.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}J==A.g.UNSIGNED_BYTE&&y.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const x=new W.Zh,K=new W.RJ,a=this._babylonScene.getEngine().useExactSrgbConversions;(0,H.g)(Y,o,I,q,J,G,l,(k=>{3===k.length?(x.Qo(k,0),x.toLinearSpaceToRef(x,a),x.toArray(k,0)):(K.Qo(k,0),K.toLinearSpaceToRef(K,a),K.toArray(k,0))}))}}}if(h.convertToRightHanded){for(const k of I){const h=x.get(k),{byteOffset:o,byteStride:I,componentCount:q,type:J,count:G,normalized:l,kind:K}=P(k,h);switch(K){case A.g.PositionKind:case A.g.NormalKind:case A.g.TangentKind:(0,H.g)(Y,o,I,q,J,G,l,(k=>{k[0]=-k[0]}))}}h.convertedToRightHandedBuffers.set(J,Y)}const G=this._bufferManager.createBufferView(Y,q);h.setVertexBufferView(J,G);const l=new Map;for(const h of I){const k=x.get(h),{kind:o,totalVertices:I}=P(h,k);switch(o){case A.g.MatricesIndicesKind:case A.g.MatricesIndicesExtraKind:if(h.type==A.g.FLOAT){const k=h.getFloatData(I);null!==k&&l.set(h,k)}}}0!==l.size&&y.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const K=Array.from(l.keys());for(const o of K){const k=l.get(o);if(!k)continue;const x=k.some((k=>k>=256)),I=new(x?Uint16Array:Uint8Array)(k.length);for(let h=0;h<k.length;h++)I[h]=k[h];const q=this._bufferManager.createBufferView(I,4*(x?2:1));h.setRemappedBufferView(J,o,q)}}const Y=Array.from(I.keys());for(const J of Y){const k=I.get(J);if(!k)continue;const o=dk(J,k[0],this._bufferManager,this._bufferViews,this._accessors,h.convertToRightHanded);for(const x of k)h.bindMorphDataToMesh(x,o)}}async _exportNodeAsync(k,h,o){let x=this._nodeMap.get(k);if(void 0!==x)return void(h.includes(x)||h.push(x));const I=await this._createNodeAsync(k,o);if(I){x=this._nodes.length,this._nodes.push(I),this._nodeMap.set(k,x),o.pushExportedNode(k),h.push(x);const q={name:"runtime animations",channels:[],samplers:[]},Y=[];this._babylonScene.animationGroups.length||(jk._CreateMorphTargetAnimationFromMorphTargetAnimations(k,q,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,o.convertToRightHanded,this._options.shouldExportAnimation),k.animations.length&&jk._CreateNodeAnimationFromNodeAnimations(k,q,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,o.convertToRightHanded,this._options.shouldExportAnimation)),q.channels.length&&q.samplers.length&&this._animations.push(q),Y.forEach((k=>{k.channels.length&&k.samplers.length&&this._animations.push(k)}))}const q=I?[]:h;for(const Y of k.getChildren())await this._exportNodeAsync(Y,q,o);I&&q.length&&(I.children=q)}async _createNodeAsync(k,h){if(!this._shouldExportNode(k))return null;const o={};if(k.name&&(o.name=k.name),k.metadata){const h=this._options.metadataSelector(k.metadata);h&&(o.extras=h)}if(k instanceof K.e&&(this._setNodeTransformation(o,k,h.convertToRightHanded),k instanceof a.d)){const I=k instanceof N.c?k.sourceMesh:k;if(I.Oh&&I.Oh.length>0&&(o.mesh=await this._exportMeshAsync(I,h)),k.skeleton){const h=this._skinMap.get(k.skeleton);var x;if(void 0!==h)void 0===this._nodesSkinMap.get(h)&&this._nodesSkinMap.set(h,[]),null===(x=this._nodesSkinMap.get(h))||void 0===x||x.push(o)}}if(k instanceof O.e){const x=this._camerasMap.get(k);if(x){var I;void 0===this._nodesCameraMap.get(x)&&this._nodesCameraMap.set(x,[]),this._setCameraTransformation(o,k,h.convertToRightHanded);const Y=k.parent;if(null!==Y&&hk(k,Y)){const k=this._nodeMap.get(Y);if(void 0!==k){var q;const h=this._nodes[k];return kk(o,h),null===(q=this._nodesCameraMap.get(x))||void 0===q||q.push(h),null}}null===(I=this._nodesCameraMap.get(x))||void 0===I||I.push(o)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",o,k,this._nodeMap,h.convertToRightHanded)?o:(y.c.Warn(`Not exporting node ${k.name}`),null)}_exportIndices(k,h,o,x,I,Y,J,G,l){let A=k;l.mode=S(Y);const K=J!==q.e.CounterClockWiseSideOrientation,a=!G.wasAddedByNoopNode&&K,N=function(k){switch(k){case q.e.TriangleFillMode:case q.e.TriangleStripDrawMode:case q.e.TriangleFanDrawMode:return!0}return!1}(Y)&&a;if(N){if(Y===q.e.TriangleStripDrawMode||Y===q.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");l.mode=S(Y);const J=h?new Uint32Array(x):new Uint16Array(x);if(k)for(let h=0;h+2<x;h+=3)J[h]=k[o+h]+I,J[h+1]=k[o+h+2]+I,J[h+2]=k[o+h+1]+I;else for(let k=0;k+2<x;k+=3)J[k]=k,J[k+1]=k+2,J[k+2]=k+1;A=J}else if(k&&0!==I){const q=h?new Uint32Array(x):new Uint16Array(x);for(let h=0;h<x;h++)q[h]=k[o+h]+I;A=q}if(A){let q=G.getIndicesAccessor(k,o,x,I,N);if(void 0===q){const Y=function(k,h,o,x){if(k instanceof Uint16Array||k instanceof Uint32Array)return k;if(k instanceof Int32Array)return new Uint32Array(k.buffer,k.byteOffset,k.length);const I=k.slice(h,h+o);return x?new Uint32Array(I):new Uint16Array(I)}(A,0,x,h),J=this._bufferManager.createBufferView(Y),l=h?5125:5123;this._accessors.push(this._bufferManager.createAccessor(J,"SCALAR",l,x,0)),q=this._accessors.length-1,G.setIndicesAccessor(k,o,x,I,N,q)}l.indices=q}}_exportVertexBuffer(k,h,o,x,I,q){const Y=k.getKind();if(!t(Y))return;if(Y.startsWith("uv")&&!this._options.exportUnusedUVs&&(!h||!this._materialNeedsUVsSet.has(h)))return;let J=I.getVertexAccessor(k,o,x);if(void 0===J){const h=I.convertedToRightHandedBuffers.get(k._buffer)||k._buffer.getData(),q=Y===A.g.PositionKind?function(k,h,o,x){const{byteOffset:I,byteStride:q,type:Y,normalized:J}=h,G=h.getSize(),l=new Array(G).fill(1/0),A=new Array(G).fill(-1/0);return(0,H.g)(k,I+o*q,q,G,Y,x*G,J,(k=>{for(let h=0;h<G;h++)l[h]=Math.min(l[h],k[h]),A[h]=Math.max(A[h],k[h])})),{min:l,max:A}}(h,k,o,x):void 0,G=(Y===A.g.MatricesIndicesKind||Y===A.g.MatricesIndicesExtraKind)&&k.type===A.g.FLOAT,l=G?A.g.UNSIGNED_BYTE:k.type,K=G?void 0:k.normalized,a=G?I.getRemappedBufferView(k._buffer,k):I.getVertexBufferView(k._buffer),N=k.byteOffset+o*k.byteStride;this._accessors.push(this._bufferManager.createAccessor(a,function(k,h){if(k==A.g.ColorKind)return h?"VEC4":"VEC3";switch(k){case A.g.PositionKind:case A.g.NormalKind:return"VEC3";case A.g.TangentKind:case A.g.MatricesIndicesKind:case A.g.MatricesIndicesExtraKind:case A.g.MatricesWeightsKind:case A.g.MatricesWeightsExtraKind:return"VEC4";case A.g.UVKind:case A.g.UV2Kind:case A.g.UV3Kind:case A.g.UV4Kind:case A.g.UV5Kind:case A.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${k}`)}(Y,I.hasVertexColorAlpha(k)),l,x,N,q,K)),J=this._accessors.length-1,I.setVertexAccessor(k,o,x,J)}q.attributes[function(k){switch(k){case A.g.PositionKind:return"POSITION";case A.g.NormalKind:return"NORMAL";case A.g.TangentKind:return"TANGENT";case A.g.ColorKind:return"COLOR_0";case A.g.UVKind:return"TEXCOORD_0";case A.g.UV2Kind:return"TEXCOORD_1";case A.g.UV3Kind:return"TEXCOORD_2";case A.g.UV4Kind:return"TEXCOORD_3";case A.g.UV5Kind:return"TEXCOORD_4";case A.g.UV6Kind:return"TEXCOORD_5";case A.g.MatricesIndicesKind:return"JOINTS_0";case A.g.MatricesIndicesExtraKind:return"JOINTS_1";case A.g.MatricesWeightsKind:return"WEIGHTS_0";case A.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${k}`)}(Y)]=J}async _exportMaterialAsync(k,h,o,x){let I=this._materialMap.get(k);if(void 0===I){const x=h&&Object.keys(h).some((k=>k.startsWith("uv")));if((k=k instanceof Nk.e?k.sJ[o.materialIndex]:k)instanceof Xk.d)I=await this._materialExporter.exportPBRMaterialAsync(k,"image/png",x);else{if(!(k instanceof ck.Rh))return void y.c.Warn(`Unsupported material '${k.name}' with type ${k.getClassName()}`);I=await this._materialExporter.exportStandardMaterialAsync(k,"image/png",x)}this._materialMap.set(k,I)}x.material=I}async _exportMeshAsync(k,h){var o;let x=h.getMesh(k);if(void 0!==x)return x;const I={primitives:[]};x=this._meshes.length,this._meshes.push(I),h.setMesh(k,x);const Y=k.isUnIndexed?null:k.dJ(),J=null===(o=k.jJ)||void 0===o?void 0:o.getVertexBuffers(),G=h.getMorphTargetsFromMesh(k),l=k instanceof bk.b,A=k instanceof pk,K=k.Oh;if(J&&K&&K.length>0)for(const X of K){const o={attributes:{}},x=X.Hk()||this._babylonScene.defaultMaterial;if(A){var a,N;const h={name:x.name},I=k,q=W.Zh.White(),Y=(null===(a=I.material)||void 0===a?void 0:a.alpha)??1,J=(null===(N=I.greasedLineMaterial)||void 0===N?void 0:N.color)??q;(!J.equalsWithEpsilon(q,z.d)||Y<1)&&(h.pbrMetallicRoughness={baseColorFactor:[...J.rh(),Y]}),this._materials.push(h),o.material=this._materials.length-1}else if(l){const h={name:x.name},I=k;(!I.color.equalsWithEpsilon(W.Zh.White(),z.d)||I.alpha<1)&&(h.pbrMetallicRoughness={baseColorFactor:[...I.color.rh(),I.alpha]}),this._materials.push(h),o.material=this._materials.length-1}else await this._exportMaterialAsync(x,J,X,o);const K=l||A?q.e.LineListDrawMode:k.overrideRenderingFillMode??x.fillMode,c=x._getEffectiveOrientation(k);this._exportIndices(Y,Y?(0,H.d)(Y,X.indexCount,X.indexStart,X.verticesStart):X.verticesCount>65535,Y?X.indexStart:X.verticesStart,Y?X.indexCount:X.verticesCount,-X.verticesStart,K,c,h,o);for(const k of Object.values(J))this._exportVertexBuffer(k,x,X.verticesStart,X.verticesCount,h,o);if(G){o.targets=[];for(const k of G)o.targets.push(k.attributes)}I.primitives.push(o),this._extensionsPostExportMeshPrimitive(o)}if(G){I.weights=[],I.extras||(I.extras={}),I.extras.targetNames=[];for(const k of G)I.weights.push(k.influence),I.extras.targetNames.push(k.name)}return x}}mk._ExtensionNames=new Array,mk._ExtensionFactories={};class Lk{static async GLTFAsync(k,h,o){o&&o.exportWithoutWaitingForScene||await k.whenReadyAsync();const x=new mk(k,o),I=await x.generateGLTFAsync(h.replace(/\.[^/.]+$/,""));return x.dispose(),I}static async GLBAsync(k,h,o){o&&o.exportWithoutWaitingForScene||await k.whenReadyAsync();const x=new mk(k,o),I=await x.generateGLBAsync(h.replace(/\.[^/.]+$/,""));return x.dispose(),I}}o(11821);const Pk="EXT_mesh_gpu_instancing";class rk{constructor(k){this.name=Pk,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(k,h,o,I,q,Y){return await new Promise((k=>{if(h&&o instanceof Mk.e&&o.hasThinInstances&&this._exporter){this._wasUsed=!0;const k=x.Vh.Zero(),I=x.Quaternion.Identity(),J=x.Vh.One(),G=o.thinInstanceGetWorldMatrices(),l=x.TmpVectors.Vh[2],A=x.TmpVectors.Quaternion[1],K=x.TmpVectors.Vh[3];let a=!1,N=!1,X=!1;const c=new Float32Array(3*o.ZJ),W=new Float32Array(4*o.ZJ),f=new Float32Array(3*o.ZJ);let M=0;for(const h of G)h.decompose(K,A,l),q&&(g(l),e(A)),c.set(l.rh(),3*M),W.set(A.normalize().rh(),4*M),f.set(K.rh(),3*M),a=a||!l.equalsWithEpsilon(k),N=N||!A.equalsWithEpsilon(I),X=X||!K.equalsWithEpsilon(J),M++;const T={attributes:{}};a&&(T.attributes.TRANSLATION=this._buildAccessor(c,"VEC3",o.ZJ,Y)),N&&(T.attributes.ROTATION=this._buildAccessor(W,"VEC4",o.ZJ,Y)),X&&(T.attributes.SCALE=this._buildAccessor(f,"VEC3",o.ZJ,Y)),h.extensions=h.extensions||{},h.extensions[Pk]=T}k(h)}))}_buildAccessor(k,h,o,x){const I=x.createBufferView(k),q=x.createAccessor(I,h,5126,o);return this._exporter._accessors.push(q),this._exporter._accessors.length-1}}mk.RegisterExtension(Pk,(k=>new rk(k)));var tk=o(11823),Sk=o(11839),Ck=o(11841),gk=o(11845);function ek(k){return k===Ck.e.PositionKind?"POSITION":k===Ck.e.NormalKind?"NORMAL":k===Ck.e.ColorKind?"COLOR":k.startsWith(Ck.e.UVKind)?"TEX_COORD":"GENERIC"}const uk={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class kh extends tk.e{static get DefaultAvailable(){return(0,tk.h)(kh.DefaultConfiguration)}static get Default(){return kh._Default??(kh._Default=new kh),kh._Default}static ResetDefault(k){kh._Default&&(k||kh._Default.dispose(),kh._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(k,h){return{module:await(h||DracoEncoderModule)({wasmBinary:k})}}_getWorkerContent(){return`${Sk.k}(${Sk.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:kh.DefaultConfiguration)}async _encodeAsync(k,h,o){const x=o?(0,gk.d)(uk,o):uk;if(this._workerPoolPromise){const o=await this._workerPoolPromise;return await new Promise(((I,q)=>{o.push(((o,Y)=>{const J=k=>{o.removeEventListener("error",J),o.removeEventListener("message",G),q(k),Y()},G=k=>{"encodeMeshDone"===k.data.id&&(o.removeEventListener("error",J),o.removeEventListener("message",G),I(k.data.encodedMeshData),Y())};o.addEventListener("error",J),o.addEventListener("message",G);const l=[];for(const h of k)l.push(h.data.buffer);h&&l.push(h.buffer),o.postMessage({id:"encodeMesh",attributes:k,indices:h,options:x},l)}))}))}if(this._modulePromise){const o=await this._modulePromise;return(0,Sk.k)(o.module,k,h,x)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(k,h){if(0==k.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");k instanceof Mk.e&&k.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===h||void 0===h?void 0:h.method)&&(y.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),h.method="MESH_SEQUENTIAL_ENCODING");const o=function(k){let h=k.dJ(void 0,!0);return!h||h instanceof Uint32Array||h instanceof Uint16Array||(h=((0,H.d)(h,h.length)?Uint32Array:Uint16Array).from(h)),h}(k),x=function(k,h){const o=[];for(const x of k.getVerticesDataKinds()){if(null!==h&&void 0!==h&&h.includes(x)){if(x===Ck.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const I=k.getVertexBuffer(x),q=I.getSize(),Y=(0,H.m)(I.getData(),q,I.type,I.byteOffset,I.byteStride,I.normalized,k.getTotalVertices(),!0);o.push({kind:x,dracoName:ek(x),size:q,data:Y})}return o}(k,null===h||void 0===h?void 0:h.excludedAttributes);return await this._encodeAsync(x,o,h)}}kh.DefaultConfiguration={wasmUrl:`${I.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${I.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${I.Tools._DefaultCdnUrl}/draco_encoder.js`},kh._Default=null;const hh="KHR_draco_mesh_compression";class oh{get wasUsed(){return this._wasUsed}constructor(k){this.name=hh,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===k.options.meshCompressionMethod&&kh.DefaultAvailable}dispose(){}postExportMeshPrimitive(k,h,o){if(!this.enabled)return;if(4!==k.mode&&5!==k.mode)return void y.c.Warn("Cannot compress primitive with mode "+k.mode+".");const x=[],I=[];let q=null;if(void 0!==k.indices){const Y=o[k.indices],J=h.getBufferView(Y);q=h.getData(J).slice(),x.push(J),I.push(Y)}const Y=[];for(const[A,K]of Object.entries(k.attributes)){const k=o[K],q=h.getBufferView(k),G=r(k.type),l=(0,H.m)(h.getData(q),G,k.componentType,k.byteOffset||0,q.byteStride||(0,H.j)(k.componentType)*G,k.normalized||!1,k.count,!0);Y.push({kind:A,dracoName:(J=A,"POSITION"===J?"POSITION":"NORMAL"===J?"NORMAL":J.startsWith("COLOR")?"COLOR":J.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:r(k.type),data:l}),x.push(q),I.push(k)}var J;const G={method:k.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},l=kh.Default._encodeAsync(Y,q,G).then((o=>{if(!o)return void y.c.Error("Draco encoding failed for primitive.");const q={bufferView:-1,attributes:o.attributeIds},Y=h.createBufferView(o.data);h.setBufferView(q,Y);for(const k of x)this._bufferViewsUsed.add(k);for(const k of I)this._accessorsUsed.add(k);k.extensions||(k.extensions={}),k.extensions[hh]=q})).catch((k=>{y.c.Error("Draco encoding failed for primitive: "+k)}));this._encodePromises.push(l),this._wasUsed=!0}async preGenerateBinaryAsync(k){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((h=>{k.getPropertiesWithBufferView(h).every((k=>this._accessorsUsed.has(k)))&&k.removeBufferView(h)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}mk.RegisterExtension(hh,(k=>new oh(k)));var xh=o(11853);const Ih="KHR_lights_punctual",qh={name:"",color:[1,1,1],wJ:1,range:Number.MAX_VALUE},Yh={innerConeAngle:0,outerConeAngle:Math.PI/4},Jh=x.Vh.Backward();class Gh{constructor(k){this.name=Ih,this.enabled=!0,this.required=!1,this._exporter=k}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Ih]=this._lights}async postExportNodeAsync(k,h,o,I,q){return await new Promise((Y=>{if(!(o instanceof Tk.d))return void Y(h);const J=o.getTypeID()==Tk.d.LIGHTTYPEID_POINTLIGHT?"point":o.getTypeID()==Tk.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":o.getTypeID()==Tk.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!J||!(o instanceof xh.d))return y.c.Warn(`${k}: Light ${o.name} is not supported in ${Ih}`),void Y(h);if(o.falloffType!==Tk.d.FALLOFF_GLTF&&y.c.Warn(`${k}: Light falloff for ${o.name} does not match the ${Ih} specification!`),!o.position.equalsToFloats(0,0,0)){const k=x.TmpVectors.Vh[0].Y(o.position);q&&g(k),h.translation=k.rh()}if("point"!==J){const k=o.direction.normalizeToRef(x.TmpVectors.Vh[0]);q&&g(k);const I=x.Quaternion.FromUnitVectorsToRef(Jh,k,x.TmpVectors.Quaternion[0]);x.Quaternion.IsIdentity(I)||(h.rotation=I.rh())}const G={type:J,name:o.name,color:o.DJ.rh(),wJ:o.wJ,range:o.range};if(xk(G,qh),"spot"===J){const k=o;G.spot={innerConeAngle:k.innerAngle/2,outerConeAngle:k.angle/2},xk(G.spot,Yh)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(G);const l={Th:this._lights.lights.length-1},A=o.parent;if(A&&hk(o,A)){const k=I.get(A);if(k){const o=this._exporter._nodes[k];return kk(h,o),o.extensions||(o.extensions={}),o.extensions[Ih]=l,void Y(null)}}h.extensions||(h.extensions={}),h.extensions[Ih]=l,Y(h)}))}}mk.RegisterExtension(Ih,(k=>new Gh(k)));var lh=o(11764);const Ah="KHR_materials_anisotropy";class Kh{constructor(k){this.name=Ah,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,h,o){const x=[];return o instanceof lh.b&&o.anisotropy.isEnabled&&!o.anisotropy.legacy?(o.anisotropy.texture&&x.push(o.anisotropy.texture),x):[]}postExportMaterialAsync(k,h,o){return new Promise((k=>{if(o instanceof lh.b){if(!o.anisotropy.isEnabled||o.anisotropy.legacy)return void k(h);this._wasUsed=!0,h.extensions=h.extensions||{};const x=this._exporter._materialExporter.getTextureInfo(o.anisotropy.texture),I={anisotropyStrength:o.anisotropy.wJ,anisotropyRotation:o.anisotropy.angle,anisotropyTexture:x??void 0};null!==I.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(o),h.extensions[Ah]=I}k(h)}))}}mk.RegisterExtension(Ah,(k=>new Kh(k)));const ah="KHR_materials_clearcoat";class Nh{constructor(k){this.name=ah,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,h,o){const x=[];return o instanceof lh.b&&o.clearCoat.isEnabled?(o.clearCoat.texture&&x.push(o.clearCoat.texture),!o.clearCoat.useRoughnessFromMainTexture&&o.clearCoat.textureRoughness&&x.push(o.clearCoat.textureRoughness),o.clearCoat.bumpTexture&&x.push(o.clearCoat.bumpTexture),x):[]}postExportMaterialAsync(k,h,o){return new Promise((k=>{if(o instanceof lh.b){if(!o.clearCoat.isEnabled)return void k(h);this._wasUsed=!0,h.extensions=h.extensions||{};const x=this._exporter._materialExporter.getTextureInfo(o.clearCoat.texture);let q;q=o.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(o.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(o.clearCoat.textureRoughness),o.clearCoat.isTintEnabled&&I.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${o.name}`),o.clearCoat.remapF0OnInterfaceChange&&I.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${o.name}`);const Y=this._exporter._materialExporter.getTextureInfo(o.clearCoat.bumpTexture),J={clearcoatFactor:o.clearCoat.wJ,clearcoatTexture:x??void 0,clearcoatRoughnessFactor:o.clearCoat.roughness,clearcoatRoughnessTexture:q??void 0,clearcoatNormalTexture:Y??void 0};null===J.clearcoatTexture&&null===J.clearcoatRoughnessTexture&&null===J.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(o),h.extensions[ah]=J}k(h)}))}}mk.RegisterExtension(ah,(k=>new Nh(k)));const Xh="KHR_materials_diffuse_transmission";function ch(k,h){const o=h.subSurface;let x=null;return o.translucencyIntensityTexture?x=o.translucencyIntensityTexture:o.thicknessTexture&&o.useMaskFromThicknessTexture&&(x=o.thicknessTexture),x&&!o.useGltfStyleTextures?(y.c.Warn(`${k}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${h.name}`,1),null):x}class Wh{constructor(k){this.name=Xh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,h,o){const x=[];if(o instanceof Xk.d&&this._isExtensionEnabled(o)){const h=ch(k,o);return h&&x.push(h),o.subSurface.translucencyColorTexture&&x.push(o.subSurface.translucencyColorTexture),x}return x}_isExtensionEnabled(k){if(k.unlit)return!1;const h=k.subSurface;return!!h.isTranslucencyEnabled&&(!k.unlit&&!h.useAlbedoToTintTranslucency&&h.useGltfStyleTextures&&1===h.volumeIndexOfRefraction&&0===h.minimumThickness&&0===h.maximumThickness)}postExportMaterialAsync(k,h,o){return new Promise((x=>{if(o instanceof Xk.d&&this._isExtensionEnabled(o)){this._wasUsed=!0;const x=o.subSurface,I=ch(k,o),q=0==x.translucencyIntensity?void 0:x.translucencyIntensity,Y=this._exporter._materialExporter.getTextureInfo(I)??void 0,J=!x.translucencyColor||x.translucencyColor.equalsFloats(1,1,1)?void 0:x.translucencyColor.rh(),G=this._exporter._materialExporter.getTextureInfo(x.translucencyColorTexture)??void 0,l={diffuseTransmissionFactor:q,diffuseTransmissionTexture:Y,diffuseTransmissionColorFactor:J,diffuseTransmissionColorTexture:G};(Y||G)&&this._exporter._materialNeedsUVsSet.add(o),h.extensions=h.extensions||{},h.extensions[Xh]=l}x(h)}))}}mk.RegisterExtension(Xh,(k=>new Wh(k)));const fh="KHR_materials_dispersion";class Mh{constructor(){this.name=fh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(k){if(k.unlit)return!1;const h=k.subSurface;return!(!h.isRefractionEnabled&&!h.isDispersionEnabled)}postExportMaterialAsync(k,h,o){return new Promise((k=>{if(o instanceof Xk.d&&this._isExtensionEnabled(o)){this._wasUsed=!0;const k={dispersion:o.subSurface.dispersion};h.extensions=h.extensions||{},h.extensions[fh]=k}k(h)}))}}mk.RegisterExtension(fh,(()=>new Mh));const Th="KHR_materials_emissive_strength";class jh{constructor(){this.name=Th,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(k,h,o){return await new Promise((k=>{if(!(o instanceof Xk.d))return k(h);const x=o.emissiveColor.rh(),I=Math.max(...x);if(I>1){this._wasUsed=!0,h.extensions||(h.extensions={});const k={emissiveStrength:I},x=o.emissiveColor.scale(1/k.emissiveStrength);h.emissiveFactor=x.rh(),h.extensions[Th]=k}return k(h)}))}}mk.RegisterExtension(Th,(k=>new jh));const dh="KHR_materials_ior";class bh{constructor(){this.name=dh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(k){return!k.unlit&&(void 0!=k.indexOfRefraction&&1.5!=k.indexOfRefraction)}postExportMaterialAsync(k,h,o){return new Promise((k=>{if(o instanceof Xk.d&&this._isExtensionEnabled(o)){this._wasUsed=!0;const k={ior:o.indexOfRefraction};h.extensions=h.extensions||{},h.extensions[dh]=k}k(h)}))}}mk.RegisterExtension(dh,(k=>new bh));const Vh="KHR_materials_iridescence";class ih{constructor(k){this.name=Vh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,h,o){const x=[];return o instanceof lh.b&&o.iridescence.isEnabled?(o.iridescence.texture&&x.push(o.iridescence.texture),o.iridescence.thicknessTexture&&o.iridescence.thicknessTexture!==o.iridescence.texture&&x.push(o.iridescence.thicknessTexture),x):[]}postExportMaterialAsync(k,h,o){return new Promise((k=>{if(o instanceof lh.b){if(!o.iridescence.isEnabled)return void k(h);this._wasUsed=!0,h.extensions=h.extensions||{};const x=this._exporter._materialExporter.getTextureInfo(o.iridescence.texture),I=this._exporter._materialExporter.getTextureInfo(o.iridescence.thicknessTexture),q={iridescenceFactor:o.iridescence.wJ,iridescenceIor:o.iridescence.indexOfRefraction,iridescenceThicknessMinimum:o.iridescence.minimumThickness,iridescenceThicknessMaximum:o.iridescence.maximumThickness,iridescenceTexture:x??void 0,iridescenceThicknessTexture:I??void 0};null===q.iridescenceTexture&&null===q.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(o),h.extensions[Vh]=q}k(h)}))}}mk.RegisterExtension(Vh,(k=>new ih(k)));const Fh="KHR_materials_sheen";class Rh{constructor(k){this.name=Fh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,h,o){return o instanceof Xk.d&&o.sheen.isEnabled&&o.sheen.texture?[o.sheen.texture]:[]}async postExportMaterialAsync(k,h,o){return await new Promise((k=>{if(o instanceof Xk.d){if(!o.sheen.isEnabled)return void k(h);this._wasUsed=!0,null==h.extensions&&(h.extensions={});const x={sheenColorFactor:o.sheen.color.rh(),sheenRoughnessFactor:o.sheen.roughness??0};null===x.sheenColorTexture&&null===x.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(o),o.sheen.texture&&(x.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.texture)??void 0),o.sheen.textureRoughness&&!o.sheen.useRoughnessFromMainTexture?x.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.textureRoughness)??void 0:o.sheen.texture&&o.sheen.useRoughnessFromMainTexture&&(x.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.texture)??void 0),h.extensions[Fh]=x}k(h)}))}}mk.RegisterExtension(Fh,(k=>new Rh(k)));const sh="KHR_materials_specular";class Zh{constructor(k){this.name=sh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,h,o){const x=[];return o instanceof Xk.d&&this._isExtensionEnabled(o)?(o.metallicReflectanceTexture&&x.push(o.metallicReflectanceTexture),o.reflectanceTexture&&x.push(o.reflectanceTexture),x):x}_isExtensionEnabled(k){return!k.unlit&&(void 0!=k.metallicF0Factor&&1!=k.metallicF0Factor||void 0!=k.metallicReflectanceColor&&!k.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(k))}_hasTexturesExtension(k){return null!=k.metallicReflectanceTexture||null!=k.reflectanceTexture}postExportMaterialAsync(k,h,o){return new Promise((k=>{if(o instanceof Xk.d&&this._isExtensionEnabled(o)){this._wasUsed=!0,h.extensions=h.extensions||{};const k=this._exporter._materialExporter.getTextureInfo(o.metallicReflectanceTexture)??void 0,x=this._exporter._materialExporter.getTextureInfo(o.reflectanceTexture)??void 0,I={specularFactor:1==o.metallicF0Factor?void 0:o.metallicF0Factor,specularTexture:k,specularColorFactor:o.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:o.metallicReflectanceColor.rh(),specularColorTexture:x};this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),h.extensions[sh]=I}k(h)}))}}mk.RegisterExtension(sh,(k=>new Zh(k)));const wh="KHR_materials_transmission";class Dh{constructor(k){this.name=wh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,h,o){const x=[];return o instanceof Xk.d&&this._isExtensionEnabled(o)?(o.subSurface.thicknessTexture&&x.push(o.subSurface.thicknessTexture),x):x}_isExtensionEnabled(k){if(k.unlit)return!1;const h=k.subSurface;return h.isRefractionEnabled&&void 0!=h.refractionIntensity&&0!=h.refractionIntensity||this._hasTexturesExtension(k)}_hasTexturesExtension(k){return null!=k.subSurface.refractionIntensityTexture}async postExportMaterialAsync(k,h,o){if(o instanceof Xk.d&&this._isExtensionEnabled(o)){this._wasUsed=!0;const x=o.subSurface,I={transmissionFactor:0===x.refractionIntensity?void 0:x.refractionIntensity};if(this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),x.refractionIntensityTexture)if(x.useGltfStyleTextures){const k=await this._exporter._materialExporter.exportTextureAsync(x.refractionIntensityTexture,"image/png");k&&(I.transmissionTexture=k)}else y.c.Warn(`${k}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);h.extensions||(h.extensions={}),h.extensions[wh]=I}return h}}mk.RegisterExtension(wh,(k=>new Dh(k)));const Uh="KHR_materials_unlit";class Qh{constructor(){this.name=Uh,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(k,h,o){return new Promise((k=>{let x=!1;o instanceof Xk.d?x=o.unlit:o instanceof ck.Rh&&(x=o.disableLighting),x&&(this._wasUsed=!0,null==h.extensions&&(h.extensions={}),h.extensions[Uh]={}),k(h)}))}}mk.RegisterExtension(Uh,(()=>new Qh));const Bh="KHR_materials_volume";class Eh{constructor(k){this.name=Bh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,h,o){const x=[];return o instanceof Xk.d&&this._isExtensionEnabled(o)?(o.subSurface.thicknessTexture&&x.push(o.subSurface.thicknessTexture),x):x}_isExtensionEnabled(k){if(k.unlit)return!1;const h=k.subSurface;return!(!h.isRefractionEnabled&&!h.isTranslucencyEnabled)&&(void 0!=h.maximumThickness&&0!=h.maximumThickness||void 0!=h.tintColorAtDistance&&h.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=h.tintColor&&h.tintColor!=W.Zh.White()||this._hasTexturesExtension(k))}_hasTexturesExtension(k){return null!=k.subSurface.thicknessTexture}postExportMaterialAsync(k,h,o){return new Promise((k=>{if(o instanceof Xk.d&&this._isExtensionEnabled(o)){this._wasUsed=!0;const k=o.subSurface,x={thicknessFactor:0==k.maximumThickness?void 0:k.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(k.thicknessTexture)??void 0,attenuationDistance:k.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:k.tintColorAtDistance,attenuationColor:k.tintColor.equalsFloats(1,1,1)?void 0:k.tintColor.rh()};this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),h.extensions=h.extensions||{},h.extensions[Bh]=x}k(h)}))}}mk.RegisterExtension(Bh,(k=>new Eh(k)));const nh="EXT_materials_diffuse_roughness";class Hh{constructor(k){this.name=nh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,h,o){const x=[];return o instanceof lh.b&&o._baseDiffuseRoughness?(o._baseDiffuseRoughnessTexture&&x.push(o._baseDiffuseRoughnessTexture),x):[]}postExportMaterialAsync(k,h,o){return new Promise((k=>{if(o instanceof lh.b){if(!o._baseDiffuseRoughness)return void k(h);this._wasUsed=!0,h.extensions=h.extensions||{};const x=this._exporter._materialExporter.getTextureInfo(o._baseDiffuseRoughnessTexture),I={diffuseRoughnessFactor:o._baseDiffuseRoughness,diffuseRoughnessTexture:x??void 0};null!==I.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(o),h.extensions[nh]=I}k(h)}))}}mk.RegisterExtension(nh,(k=>new Hh(k)));const yh="KHR_texture_transform";class Oh{constructor(){this.name=yh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(k,h,o){if(o.ik()||I.Tools.Warn(`${k}: /*@__KEY__*/"scene" is not defined for Babylon texture ${o.name}!`),(0!==o.uAng||0!==o.vAng)&&(I.Tools.Warn(`${k}: Texture ${o.name} with rotation in the u or v axis is not supported in glTF.`),0!==o.uRotationCenter||0!==o.vRotationCenter))return;const x={};let q=!1;if(0===o.uOffset&&0===o.vOffset||(x.offset=[o.uOffset,o.vOffset],q=!0),1===o.uScale&&1===o.vScale||(x.scale=[o.uScale,o.vScale],q=!0),0!==o.wAng){if(0!==o.uRotationCenter||0!==o.vRotationCenter){if(o.homogeneousRotationInUVTransform&&o.uScale!==o.vScale)return void I.Tools.Warn(`${k}: Texture ${o.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${yh}.`);I.Tools.Warn(`${k}: Texture ${o.name} with non-origin rotation center will be exported using an adjusted offset with ${yh}.`),x.offset=function(k){const{uOffset:h,vOffset:o,uRotationCenter:x,vRotationCenter:I,uScale:q,vScale:Y,wAng:J}=k,G=Math.cos(J),l=Math.sin(J),A=x*q,K=I*Y;return[h+(A*(1-G)+K*l),o+(K*(1-G)-A*l)]}(o)}x.rotation=-o.wAng,q=!0}0!==o.coordinatesIndex&&(x.texCoord=o.coordinatesIndex,q=!0),q&&(this._wasUsed=!0,h.extensions||(h.extensions={}),h.extensions[yh]=x)}}mk.RegisterExtension(yh,(()=>new Oh));class zh{static CreateSTL(k){let h=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",I=arguments.length>3&&void 0!==arguments[3]&&arguments[3],q=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],Y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],J=arguments.length>6&&void 0!==arguments[6]&&arguments[6],G=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const l=function(k,h,o){const I=[3*k[o],3*k[o+1],3*k[o+2]],q=[new x.Vh(h[I[0]],h[I[0]+2],h[I[0]+1]),new x.Vh(h[I[1]],h[I[1]+2],h[I[1]+1]),new x.Vh(h[I[2]],h[I[2]+2],h[I[2]+1])],Y=q[0].ih(q[1]),J=q[2].ih(q[1]);return{v:q,n:x.Vh.Cross(J,Y).normalize()}},K=function(k,h,o,x){return h=a(k,h,o.x,x),h=a(k,h,o.y,x),a(k,h,o.z,x)},a=function(k,h,o,x){return k.setFloat32(h,o,x),h+4},X=function(k){if(J){let h=k;k instanceof N.c&&(h=k.sourceMesh);const o=h.getVerticesData(A.g.PositionKind,!0,!0);if(!o)return[];const I=x.Vh.Zero();let q;for(q=0;q<o.length;q+=3)x.Vh.TransformCoordinatesFromFloatsToRef(o[q],o[q+1],o[q+2],k.eq(!0),I).toArray(o,q);return o}return k.getVerticesData(A.g.PositionKind)||[]};J&&(Y=!0);let c="",W=0,f=0;if(I){for(let o=0;o<k.length;o++){const h=k[o].dJ();W+=h?h.length/3:0}const h=new ArrayBuffer(84+50*W);c=new DataView(h),f+=80,c.setUint32(f,W,q),f+=4}else G||(c="solid stlmesh\r\n");for(let x=0;x<k.length;x++){const h=k[x];!I&&G&&(c+="solid "+h.name+"\r\n"),!Y&&h instanceof Mk.e&&h.bakeCurrentTransformIntoVertices();const o=X(h),J=h.dJ()||[];for(let k=0;k<J.length;k+=3){const h=l(J,o,k);I?(f=K(c,f,h.n,q),f=K(c,f,h.v[0],q),f=K(c,f,h.v[1],q),f=K(c,f,h.v[2],q),f+=2):(c+="\tfacet normal "+h.n.x+" "+h.n.y+" "+h.n.z+"\r\n",c+="\t\touter loop\r\n",c+="\t\t\tvertex "+h.v[0].x+" "+h.v[0].y+" "+h.v[0].z+"\r\n",c+="\t\t\tvertex "+h.v[1].x+" "+h.v[1].y+" "+h.v[1].z+"\r\n",c+="\t\t\tvertex "+h.v[2].x+" "+h.v[2].y+" "+h.v[2].z+"\r\n",c+="\t\tendloop\r\n",c+="\tendfacet\r\n")}!I&&G&&(c+="endsolid "+name+"\r\n")}if(I||G||(c+="endsolid stlmesh"),h){const k=document.createElement("a"),h=new Blob([c],{type:"application/octet-stream"});k.href=window.URL.createObjectURL(h),k.download=o+".stl",k.click()}return c}}function ph(k,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const x=[];for(let I=0;I<k.length/o;I++){const q=k[I*o],Y=k[I*o+1],J=k[I*o+2];x.push(`(${q.toPrecision(h.precision)}, ${Y.toPrecision(h.precision)}, ${J.toPrecision(h.precision)})`)}return x.join(", ")}function vh(k,h){const o=[];for(let x=0;x<k.length/2;x++){const I=k[2*x],q=k[2*x+1];o.push(`(${I.toPrecision(h.precision)}, ${(1-q).toPrecision(h.precision)})`)}return o.join(", ")}function mh(k,h){const o=k.getVerticesData(A.g.PositionKind),x=k.getVerticesData(A.g.NormalKind);if(o&&x)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(k){var h;const o=null!==(h=k.dJ())&&void 0!==h&&h.length?k.getTotalIndices():k.getTotalVertices();return Array(o/3).fill(3).join(", ")}(k)}]\n\t\tint[] faceVertexIndices = [${function(k){const h=k.dJ(),o=[];if(null!==h)for(let x=0;x<h.length;x++)o.push(h[x]);else{const h=k.getTotalVertices();for(let k=0;k<h;k++)o.push(k)}return o.join(", ")}(k)}]\n\t\tnormal3f[] normals = [${ph(x,h)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${ph(o,h)}]\n        ${function(k,h){let o="";for(let I=0;I<4;I++){const x=I>0?I:"",q=k.getVerticesData(A.g.UVKind+(x?x+1:""));q&&(o+=`\n\t\ttexCoord2f[] primvars:st${x} = [${vh(q,h)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const x=k.getVerticesData(A.g.ColorKind);return x&&(o+=`\n\tcolor3f[] primvars:displayColor = [${ph(x,h,x.length/k.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),o}(k,h)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Lh(k,h){return`\n        def "Geometry"\n        {\n        ${mh(k,h)}\n        }\n        `}function Ph(k){let h='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return h+=k,fflate.strToU8(h)}function rh(k){const h=k.m;return`( ${th(h,0)}, ${th(h,4)}, ${th(h,8)}, ${th(h,12)} )`}function th(k,h){return`(${k[h+0]}, ${k[h+1]}, ${k[h+2]}, ${k[h+3]})`}function Sh(k){const h="Object_"+k.uniqueId,o=function(k){const h=k.getWorldMatrix().clone(),o=k.ik().useRightHandedSystem;if(!o){let x=k.parent;for(;x;){if(Yk(x,o)){h.multiplyToRef(x.getWorldMatrix().invert(),h);break}x=x.parent}}return h.determinant()<0&&I.Tools.Warn(`Exporting mesh ${k.name} with negative scale. Result may look incorrect in destination engine.`),h}(k),x=rh(o);return`def Xform "${h}" (\n\tprepend references = @./geometries/Geometry_${k.jJ.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${x}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${k.material.uniqueId}>\n}\n\n`}function Ch(k){switch(k){case V.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case V.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case V.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function gh(k){return`(${k.x}, ${k.y})`}function eh(k){return`(${k.r}, ${k.g}, ${k.b})`}function uh(k,h,o,I,q,Y){const J=k.getInternalTexture().uniqueId+"_"+k.invertY;q[J]=k;const G=k.coordinatesIndex>0?"st"+k.coordinatesIndex:"st",l=new x.Vector2(k.uScale,k.vScale),A=new x.Vector2(k.uOffset,k.vOffset),K=k.wAng,a=Math.sin(K),N=Math.cos(K);return A.y=1-A.y-l.y,A.x+=a*l.x,A.y+=(1-N)*l.y,`\n    def Shader "PrimvarReader_${o}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${G}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${o}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${h.uniqueId}/PrimvarReader_${o}.outputs:result>\n        float inputs:rotation = ${(K*(180/Math.PI)).toFixed(Y.precision)}\n        float2 inputs:scale = ${gh(l)}\n        float2 inputs:translation = ${gh(A)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${k.uniqueId}_${o}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${J}.png@\n        float2 inputs:st.connect = </Materials/Material_${h.uniqueId}/Transform2d_${o}.outputs:result>\n        ${I?"float4 inputs:scale = "+function(k){return`(${k.r}, ${k.g}, ${k.b}, 1.0)`}(I):""}\n        token inputs:sourceColorSpace = "${k.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Ch(k.wrapU)}"\n        token inputs:wrapT = "${Ch(k.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${h.needAlphaBlending()?"float outputs:a":""}\n    }`}function ko(k,h,o){const x="\t\t\t",I=[],q=[],{diffuseMap:Y,DJ:J,alphaCutOff:G,emissiveMap:l,emissive:A,normalMap:K,roughnessMap:a,roughnessChannel:N,roughness:X,metalnessMap:c,metalnessChannel:f,metalness:M,aoMap:T,aoMapChannel:j,aoMapIntensity:d,alphaMap:b,ior:V,clearCoatEnabled:i,clearCoat:F,clearCoatMap:R,clearCoatRoughness:s,clearCoatRoughnessMap:Z}=function(k){const h={diffuseMap:null,DJ:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return k instanceof ck.Rh?{...h,diffuseMap:k.diffuseTexture,DJ:k.diffuseColor,alphaCutOff:k.alphaCutOff,emissiveMap:k.emissiveTexture,emissive:k.emissiveColor,roughness:1,alphaMap:k.opacityTexture}:k instanceof lh.b?{...h,diffuseMap:k._albedoTexture,DJ:k._albedoColor,alphaCutOff:k._alphaCutOff,emissiveMap:k._emissiveTexture,emissive:k._emissiveColor,normalMap:k._bumpTexture,roughnessMap:k._metallicTexture,roughnessChannel:k._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:k._roughness??1,metalnessMap:k._metallicTexture,metalnessChannel:k._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:k._metallic??0,aoMap:k._ambientTexture,aoMapChannel:k._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:k._ambientTextureStrength,alphaMap:k._opacityTexture,ior:k.subSurface.indexOfRefraction,clearCoatEnabled:k.clearCoat.isEnabled,clearCoat:k.clearCoat.wJ,clearCoatMap:k.clearCoat.texture,clearCoatRoughness:k.clearCoat.roughness,clearCoatRoughnessMap:k.clearCoat.useRoughnessFromMainTexture?k.clearCoat.texture:k.clearCoat.textureRoughness}:h}(k);return null!==Y?(I.push(`${x}color3f inputs:diffuseColor.connect = </Materials/Material_${k.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:rgb>`),k.needAlphaBlending()?I.push(`${x}float inputs:opacity.connect = </Materials/Material_${k.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`):k.needAlphaTesting()&&(I.push(`${x}float inputs:opacity.connect = </Materials/Material_${k.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`),I.push(`${x}float inputs:opacityThreshold = ${G}`)),q.push(uh(Y,k,"diffuse",J,h,o))):I.push(`${x}color3f inputs:diffuseColor = ${eh(J||W.Zh.White())}`),null!==l?(I.push(`${x}color3f inputs:emissiveColor.connect = </Materials/Material_${k.uniqueId}/Texture_${l.uniqueId}_emissive.outputs:rgb>`),q.push(uh(l,k,"emissive",A,h,o))):A&&A.toLuminance()>0&&I.push(`${x}color3f inputs:emissiveColor = ${eh(A)}`),null!==K&&(I.push(`${x}normal3f inputs:normal.connect = </Materials/Material_${k.uniqueId}/Texture_${K.uniqueId}_normal.outputs:rgb>`),q.push(uh(K,k,"normal",null,h,o))),null!==T&&(I.push(`${x}float inputs:occlusion.connect = </Materials/Material_${k.uniqueId}/Texture_${T.uniqueId}_occlusion.outputs:${j}>`),q.push(uh(T,k,"occlusion",new W.Zh(d,d,d),h,o))),null!==a?(I.push(`${x}float inputs:roughness.connect = </Materials/Material_${k.uniqueId}/Texture_${a.uniqueId}_roughness.outputs:${N}>`),q.push(uh(a,k,"roughness",new W.Zh(X,X,X),h,o))):I.push(`${x}float inputs:roughness = ${X}`),null!==c?(I.push(`${x}float inputs:metallic.connect = </Materials/Material_${k.uniqueId}/Texture_${c.uniqueId}_metallic.outputs:${f}>`),q.push(uh(c,k,"metallic",new W.Zh(M,M,M),h,o))):I.push(`${x}float inputs:metallic = ${M}`),null!==b?(I.push(`${x}float inputs:opacity.connect = </Materials/Material_${k.uniqueId}/Texture_${b.uniqueId}_opacity.outputs:r>`),I.push(`${x}float inputs:opacityThreshold = 0.0001`),q.push(uh(b,k,"opacity",null,h,o))):I.push(`${x}float inputs:opacity = ${k.alpha}`),i&&(null!==R?(I.push(`${x}float inputs:clearcoat.connect = </Materials/Material_${k.uniqueId}/Texture_${R.uniqueId}_clearcoat.outputs:r>`),q.push(uh(R,k,"clearcoat",new W.Zh(F,F,F),h,o))):I.push(`${x}float inputs:clearcoat = ${F}`),null!==Z?(I.push(`${x}float inputs:clearcoatRoughness.connect = </Materials/Material_${k.uniqueId}/Texture_${Z.uniqueId}_clearcoatRoughness.outputs:g>`),q.push(uh(Z,k,"clearcoatRoughness",new W.Zh(s,s,s),h,o))):I.push(`${x}float inputs:clearcoatRoughness = ${s}`)),I.push(`${x}float inputs:ior = ${V}`),`\n\tdef Material "Material_${k.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${I.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${k.uniqueId}/PreviewSurface.outputs:surface>\n\n${q.join("\n")}\n\n\t}\n`}async function ho(k,h,o){const q={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...h};"undefined"===typeof fflate&&await I.Tools.LoadScriptAsync(q.fflateUrl);const Y={};Y[q.modelFileName]=null;let J='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';J+=function(k){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===k.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${k.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${k.planeAnchoringAlignment}"`:""}\n            `}(q);const G={};for(const x of k.meshes){if(0===x.getTotalVertices())continue;const k=x,h=k.jJ,l=k.material;if(!l||!h||o&&!o(k))continue;if(-1!==["Rh","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(l.getClassName())){const o="geometries/Geometry_"+h.uniqueId+".usda";if(!(o in Y)){const k=Lh(h,q);Y[o]=Ph(k)}l.uniqueId in G||(G[l.uniqueId]=l),J+=Sh(k)}else I.Tools.Warn("USDZExportAsync does not support this material type: "+l.getClassName())}k.activeCamera&&q.exportCamera&&(J+=function(k,h){const o="Camera_"+k.uniqueId,I=rh(x.Matrix.RotationY(Math.PI).multiply(k.getWorldMatrix()));if(k.mode===V.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${o}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${I}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${k.nx.toPrecision(h.precision)}, ${k.maxZ.toPrecision(h.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(k.orthoLeft||1)+Math.abs(k.orthoRight||1))).toPrecision(h.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(k.orthoTop||1)+Math.abs(k.orthoBottom||1))).toPrecision(h.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const x=k.getEngine().getAspectRatio(k),q=h.cameraSensorWidth||35;return`def Camera "${o}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${I}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${k.nx.toPrecision(h.precision)}, ${k.maxZ.toPrecision(h.precision)})\n\t\t\tfloat focalLength = ${(q/(2*Math.tan(.5*k.fov))).toPrecision(h.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(q*x).toPrecision(h.precision)}\n\t\t\tfloat verticalAperture = ${(q/x).toPrecision(h.precision)}            \n\t\t}\n\t\n\t`}}(k.activeCamera,q)),J+="\n            }\n        }\n    }";const l={};J+=function(k,h,o){const x=[];for(const I in k){const q=k[I];x.push(ko(q,h,o))}return`\n    def "Materials"\n{\n${x.join("")}\n}\n\n`}(G,l,q),Y[q.modelFileName]=fflate.strToU8(J);for(const x in l){const k=l[x],h=k.getSize(),o=await k.readPixels();if(!o)throw new Error("Texture data is not available");const I=await i.DumpTools.DumpDataAsync(h.width,h.height,o,"image/png",void 0,!1,!0);Y[`textures/Texture_${x}.png`]=new Uint8Array(I).slice()}let A=0;for(const x in Y){const k=Y[x];if(!k)continue;A+=34+x.length;const h=63&A;if(4!==h){const o=new Uint8Array(64-h);Y[x]=[k,{extra:{12345:o}}]}A=k.length}return fflate.zipSync(Y,{level:0})}}}]);