"use strict";(self.g111kvdsqxc=self.g111kvdsqxc||[]).push([[26],{11693:(K,H,M)=>{M.r(H),M.d(H,{EXT_materials_diffuse_roughness:()=>pH,EXT_mesh_gpu_instancing:()=>rK,GLTF2Export:()=>FK,GLTFData:()=>I,KHR_draco_mesh_compression:()=>MH,KHR_lights_punctual:()=>WH,KHR_materials_anisotropy:()=>zH,KHR_materials_clearcoat:()=>aH,KHR_materials_diffuse_transmission:()=>LH,KHR_materials_dispersion:()=>BH,KHR_materials_emissive_strength:()=>iH,KHR_materials_ior:()=>EH,KHR_materials_iridescence:()=>sH,KHR_materials_sheen:()=>VH,KHR_materials_specular:()=>cH,KHR_materials_transmission:()=>TH,KHR_materials_unlit:()=>xH,KHR_materials_volume:()=>JH,KHR_texture_transform:()=>RH,OBJExport:()=>y,STLExport:()=>tH,USDZExportAsync:()=>HM,_ConvertToGLTFPBRMetallicRoughness:()=>d,_SolveMetallic:()=>T,__IGLTFExporterExtension:()=>h});var q=M(11290),w=M(11100),u=M(11605);class y{static OBJ(K,H,M,y){const h=[];let W=1,I=1;H&&(M||(M="mat"),h.push("mtllib "+M+".mtl"));for(let f=0;f<K.length;f++){const M=K[f],z=M.name||`mesh${f}}`;h.push(`o ${z}`);let G=null;if(y){const K=M.zh(!0);G=new q.Matrix,K.invertToRef(G),M.bakeTransformIntoVertices(K)}if(H){const K=M.material;K&&h.push("usemtl "+K.id)}const a=M.Gh;if(!a){w.Tools.Warn("No geometry is present on the mesh");continue}const v=a.getVerticesData("position"),O=a.getVerticesData("normal"),L=a.getVerticesData("uv"),S=a.ah();let B=0,C=0;if(!v||!S){w.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const i=K[0].sK().useRightHandedSystem?1:-1;for(let K=0;K<v.length;K+=3)h.push("v "+v[K]*i+" "+v[K+1]+" "+v[K+2]),B++;if(null!=O)for(let K=0;K<O.length;K+=3)h.push("vn "+O[K]*i+" "+O[K+1]+" "+O[K+2]);if(null!=L)for(let K=0;K<L.length;K+=2)h.push("vt "+L[K]+" "+L[K+1]),C++;const Z=["","",""],E=(M.material||M.sK().defaultMaterial)._getEffectiveOrientation(M),[l,s]=E===u.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let K=0;K<S.length;K+=3){const H=[String(S[K]+W),String(S[K+l]+W),String(S[K+s]+W)],M=[String(S[K]+I),String(S[K+l]+I),String(S[K+s]+I)],q=H,w=null!=L?M:Z,u=null!=O?H:Z;h.push("f "+q[0]+"/"+w[0]+"/"+u[0]+" "+q[1]+"/"+w[1]+"/"+u[1]+" "+q[2]+"/"+w[2]+"/"+u[2])}y&&G&&M.bakeTransformIntoVertices(G),W+=B,I+=C}return h.join("\n")}static MTL(K){const H=[],M=K.material;H.push("newmtl mat1"),H.push("  Ns "+M.specularPower.toFixed(4)),H.push("  Ni 1.5000"),H.push("  d "+M.alpha.toFixed(4)),H.push("  Tr 0.0000"),H.push("  Tf 1.0000 1.0000 1.0000"),H.push("  illum 2"),H.push("  Ka "+M.ambientColor.r.toFixed(4)+" "+M.ambientColor.g.toFixed(4)+" "+M.ambientColor.b.toFixed(4)),H.push("  Kd "+M.diffuseColor.r.toFixed(4)+" "+M.diffuseColor.g.toFixed(4)+" "+M.diffuseColor.b.toFixed(4)),H.push("  Ks "+M.specularColor.r.toFixed(4)+" "+M.specularColor.g.toFixed(4)+" "+M.specularColor.b.toFixed(4)),H.push("  Ke "+M.emissiveColor.r.toFixed(4)+" "+M.emissiveColor.g.toFixed(4)+" "+M.emissiveColor.b.toFixed(4));M.ambientTexture&&H.push("  map_Ka "+M.ambientTexture.name),M.diffuseTexture&&H.push("  map_Kd "+M.diffuseTexture.name),M.specularTexture&&H.push("  map_Ks "+M.specularTexture.name),M.bumpTexture&&H.push("  map_bump -imfchan z "+M.bumpTexture.name),M.opacityTexture&&H.push("  map_d "+M.opacityTexture.name);return H.join("\n")}}var h=0,W=M(11152);class I{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const K in this.files){const H=this.files[K],M=new Blob([H],{type:(0,W.i)(K)});w.Tools.Download(M,K)}}}var f=M(11366),z=M(11697),G=M(11712),a=M(11722),v=M(11412),O=M(11143),L=M(11329),S=M(11307);const B=S.HighestCommonFactor,C={...S,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:B};var i=M(11507),Z=M(11267),E=M(11758),l=M(11765),s=M(11502);const D=1e-6,V=new L.CH(.04,.04,.04),n=1024,c=L.CH.White(),k=L.CH.Black();function T(K,H,M){if(H<V.r)return 0;const q=V.r,w=K*M/(1-V.r)+H-2*V.r,u=w*w-4*q*(V.r-H);return C.Clamp((-w+Math.sqrt(u))/(2*q),0,1)}function d(K){const H=K.diffuseColor.toLinearSpace(K.sK().getEngine().useExactSrgbConversions).scale(.5),M=K.alpha,w=function(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new q.Vector2(0,1),M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new q.Vector2(0,.1),w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new q.Vector2(0,.1),u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new q.Vector2(1300,.1);return function(K,H,M,q,w){return(1-K)*(1-K)*(1-K)*H+3*(1-K)*(1-K)*K*M+3*(1-K)*K*K*q+K*K*K*w}(Math.pow(K/u.x,.333333),H.y,M.y,w.y,u.y)}(C.Clamp(K.specularPower,0,n));return{baseColorFactor:[H.r,H.g,H.b,M],metallicFactor:0,roughnessFactor:w}}function x(K,H){H.needAlphaBlending()?K.alphaMode="BLEND":H.needAlphaTesting()&&(K.alphaMode="MASK",K.alphaCutoff=H.alphaCutOff)}function Q(K,H,M){const q=new Uint8Array(K*H*4);for(let w=0;w<q.length;w+=4)q[w]=q[w+1]=q[w+2]=q[w+3]=255;return E.d.CreateRGBATexture(q,K,H,M)}function J(K){if(K instanceof Uint8Array){const H=K.length,M=new Float32Array(K.length);for(let q=0;q<H;++q)M[q]=K[q]/255;return M}if(K instanceof Float32Array)return K;throw new Error("Unsupported pixel format!")}class N{constructor(K){this._exporter=K,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(K){return K?this._textureMap.get(K)??null:null}async exportStandardMaterialAsync(K,H,M){const q=d(K),u={name:K.name};if(null==K.Oh||K.Oh||(K.twoSidedLighting||w.Tools.Warn(K.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),u.doubleSided=!0),M){const M=[],w=K.diffuseTexture;w&&M.push(this.exportTextureAsync(w,H).then((K=>{K&&(q.baseColorTexture=K)})));const y=K.bumpTexture;y&&M.push(this.exportTextureAsync(y,H).then((K=>{K&&(u.normalTexture=K,1!==y.level&&(u.normalTexture.scale=y.level))})));const h=K.emissiveTexture;h&&(u.emissiveFactor=[1,1,1],M.push(this.exportTextureAsync(h,H).then((K=>{K&&(u.emissiveTexture=K)}))));const W=K.ambientTexture;W&&M.push(this.exportTextureAsync(W,H).then((K=>{if(K){const H={index:K.index};u.occlusionTexture=H}}))),M.length>0&&(this._exporter._materialNeedsUVsSet.add(K),await Promise.all(M))}(K.alpha<1||K.opacityTexture)&&(K.alphaMode===l.d.ALPHA_COMBINE?u.alphaMode="BLEND":w.Tools.Warn(K.name+": glTF 2.0 does not support alpha mode: "+K.alphaMode.toString())),K.emissiveColor&&!K.emissiveColor.equalsWithEpsilon(k,D)&&(u.emissiveFactor=K.emissiveColor.hh()),u.pbrMetallicRoughness=q,x(u,K),await this._finishMaterialAsync(u,K,H);const y=this._exporter._materials;return y.push(u),y.length-1}async _finishMaterialAsync(K,H,M){const q=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",K,H),w=[];for(const u of q)w.push(this.exportTextureAsync(u,M));await Promise.all(w),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",K,H)}async _getImageDataAsync(K,H,q,w){const u=l.d.TEXTURETYPE_UNSIGNED_BYTE,y=this._exporter._babylonScene,h=y.getEngine(),W=h.createRawTexture(K,H,q,l.d.TEXTUREFORMAT_RGBA,!1,!0,Z.b.NEAREST_SAMPLINGMODE,null,u);h.isWebGPU?await M.e(51).then(M.bind(M,13754)):await M.e(52).then(M.bind(M,13758)),await i.l.ApplyPostProcess("pass",W,y,u,l.d.TEXTURE_NEAREST_SAMPLINGMODE,l.d.TEXTUREFORMAT_RGBA);const I=await h._readTexturePixels(W,H,q);return await s.DumpTools.DumpDataAsync(H,q,I,w,void 0,!0,!0)}_resizeTexturesToSameDimensions(K,H,M){const q=K?K.getSize():{width:0,height:0},w=H?H.getSize():{width:0,height:0};let u,y;return q.width<w.width?(u=K&&K instanceof Z.b?i.l.CreateResizedCopy(K,w.width,w.height,!0):Q(w.width,w.height,M),y=H):q.width>w.width?(y=H&&H instanceof Z.b?i.l.CreateResizedCopy(H,q.width,q.height,!0):Q(q.width,q.height,M),u=K):(u=K,y=H),{texture1:u,texture2:y}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(K,H,M,q){const w=new Array;if(!K&&!H)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const u=K?K.sK():H?H.sK():null;if(u){var y;const h=this._resizeTexturesToSameDimensions(K,H,u),W=null===(y=h.texture1)||void 0===y?void 0:y.getSize();let I,f;const z=W.width,G=W.height,a=await h.texture1.readPixels(),v=await h.texture2.readPixels();if(!a)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(I=J(a),!v)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");f=J(v);const O=f.byteLength,S=new Uint8Array(O),B=new Uint8Array(O),C=4,i=k;let Z=0,E=0;for(let K=0;K<G;++K)for(let H=0;H<z;++H){const q=(z*K+H)*C,w={diffuseColor:new L.CH(I[q],I[q+1],I[q+2]).toLinearSpace(u.getEngine().useExactSrgbConversions).multiply(M.diffuseColor),specularColor:new L.CH(f[q],f[q+1],f[q+2]).toLinearSpace(u.getEngine().useExactSrgbConversions).multiply(M.specularColor),glossiness:f[q+3]*M.glossiness},y=this._convertSpecularGlossinessToMetallicRoughness(w);i.r=Math.max(i.r,y.baseColor.r),i.g=Math.max(i.g,y.baseColor.g),i.b=Math.max(i.b,y.baseColor.b),Z=Math.max(Z,y.metallic),E=Math.max(E,y.roughness),B[q]=255*y.baseColor.r,B[q+1]=255*y.baseColor.g,B[q+2]=255*y.baseColor.b,B[q+3]=h.texture1.Wh?255*I[q+3]:255,S[q]=0,S[q+1]=255*y.roughness,S[q+2]=255*y.metallic,S[q+3]=255}const l={baseColor:i,metallic:Z,roughness:E};let s=!1,V=!1;for(let K=0;K<G;++K)for(let H=0;H<z;++H){const M=(z*K+H)*C;B[M]/=l.baseColor.r>D?l.baseColor.r:1,B[M+1]/=l.baseColor.g>D?l.baseColor.g:1,B[M+2]/=l.baseColor.b>D?l.baseColor.b:1;const q=L.CH.FromInts(B[M],B[M+1],B[M+2]).toGammaSpace(u.getEngine().useExactSrgbConversions);B[M]=255*q.r,B[M+1]=255*q.g,B[M+2]=255*q.b,q.equalsWithEpsilon(c,D)||(V=!0),S[M+1]/=l.roughness>D?l.roughness:1,S[M+2]/=l.metallic>D?l.metallic:1;L.CH.FromInts(255,S[M+1],S[M+2]).equalsWithEpsilon(c,D)||(s=!0)}return s&&w.push(this._getImageDataAsync(S,z,G,q).then((K=>{l.metallicRoughnessTextureData=K}))),V&&w.push(this._getImageDataAsync(B,z,G,q).then((K=>{l.baseColorTextureData=K}))),await Promise.all(w).then((()=>l))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(K){const H=this._getPerceivedBrightness(K.diffuseColor),M=this._getPerceivedBrightness(K.specularColor),q=1-this._getMaxComponent(K.specularColor),w=T(H,M,q),u=K.diffuseColor.scale(q/(1-V.r)/Math.max(1-w)),y=K.specularColor.LH(V.scale(1-w)).scale(1/Math.max(w));let h=L.CH.Lerp(u,y,w*w);h=h.clampToRef(0,1,h);return{baseColor:h,metallic:w,roughness:1-K.glossiness}}_getPerceivedBrightness(K){return K?Math.sqrt(.299*K.r*K.r+.587*K.g*K.g+.114*K.b*K.b):0}_getMaxComponent(K){return K?Math.max(K.r,Math.max(K.g,K.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(K,H,M,q){const w=[],u={baseColor:K._albedoColor,metallic:K._metallic,roughness:K._roughness};if(q){K._albedoTexture&&w.push(this.exportTextureAsync(K._albedoTexture,H).then((K=>{K&&(M.baseColorTexture=K)})));const q=K._metallicTexture;q&&w.push(this.exportTextureAsync(q,H).then((K=>{K&&(M.metallicRoughnessTexture=K)})))}return w.length>0&&(this._exporter._materialNeedsUVsSet.add(K),await Promise.all(w)),u}_getTextureSampler(K){const H={};if(!K||!(K instanceof Z.b))return H;const M=this._getGLTFTextureWrapMode(K.wrapU);10497!==M&&(H.wrapS=M);const q=this._getGLTFTextureWrapMode(K.wrapV);switch(10497!==q&&(H.wrapT=q),K.samplingMode){case Z.b.LINEAR_LINEAR:H.magFilter=9729,H.minFilter=9729;break;case Z.b.LINEAR_NEAREST:H.magFilter=9729,H.minFilter=9728;break;case Z.b.NEAREST_LINEAR:H.magFilter=9728,H.minFilter=9729;break;case Z.b.NEAREST_LINEAR_MIPLINEAR:H.magFilter=9728,H.minFilter=9987;break;case Z.b.NEAREST_NEAREST:H.magFilter=9728,H.minFilter=9728;break;case Z.b.NEAREST_LINEAR_MIPNEAREST:H.magFilter=9728,H.minFilter=9985;break;case Z.b.LINEAR_NEAREST_MIPNEAREST:H.magFilter=9729,H.minFilter=9984;break;case Z.b.LINEAR_NEAREST_MIPLINEAR:H.magFilter=9729,H.minFilter=9986;break;case Z.b.NEAREST_NEAREST_MIPLINEAR:H.magFilter=9728,H.minFilter=9986;break;case Z.b.LINEAR_LINEAR_MIPLINEAR:H.magFilter=9729,H.minFilter=9987;break;case Z.b.LINEAR_LINEAR_MIPNEAREST:H.magFilter=9729,H.minFilter=9985;break;case Z.b.NEAREST_NEAREST_MIPNEAREST:H.magFilter=9728,H.minFilter=9984}return H}_getGLTFTextureWrapMode(K){switch(K){case Z.b.WRAP_ADDRESSMODE:return 10497;case Z.b.CLAMP_ADDRESSMODE:return 33071;case Z.b.MIRROR_ADDRESSMODE:return 33648;default:return w.Tools.Error(`Unsupported Texture Wrap Mode ${K}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(K,H,M,q){const w={diffuseColor:K._albedoColor,specularColor:K._reflectivityColor,glossiness:K._microSurface},u=K._albedoTexture,y=K._reflectivityTexture,h=K._useMicroSurfaceFromReflectivityMapAlpha;if(y&&!h)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((u||y)&&q){this._exporter._materialNeedsUVsSet.add(K);const q=this._exportTextureSampler(u||y),h=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(u,y,w,H),W=this._exporter._textures;if(h.baseColorTextureData){const K=this._exportImage(`baseColor${W.length}`,H,h.baseColorTextureData);M.baseColorTexture=this._exportTextureInfo(K,q,null===u||void 0===u?void 0:u.coordinatesIndex)}if(h.metallicRoughnessTextureData){const K=this._exportImage(`metallicRoughness${W.length}`,H,h.metallicRoughnessTextureData);M.metallicRoughnessTexture=this._exportTextureInfo(K,q,null===y||void 0===y?void 0:y.coordinatesIndex)}return h}return this._convertSpecularGlossinessToMetallicRoughness(w)}async exportPBRMaterialAsync(K,H,M){const q={},w={name:K.name},u=K.isMetallicWorkflow();if(u){const H=K._albedoColor,M=K.alpha;H&&(q.baseColorFactor=[H.r,H.g,H.b,M])}const y=u?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(K,H,q,M):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(K,H,q,M);await this._setMetallicRoughnessPbrMaterialAsync(y,K,w,q,H,M),await this._finishMaterialAsync(w,K,H);const h=this._exporter._materials;return h.push(w),h.length-1}async _setMetallicRoughnessPbrMaterialAsync(K,H,M,q,u,y){if(x(M,H),K.baseColor.equalsWithEpsilon(c,D)&&C.WithinEpsilon(H.alpha,1,D)||(q.baseColorFactor=[K.baseColor.r,K.baseColor.g,K.baseColor.b,H.alpha]),null!=K.metallic&&1!==K.metallic&&(q.metallicFactor=K.metallic),null!=K.roughness&&1!==K.roughness&&(q.roughnessFactor=K.roughness),null==H.Oh||H.Oh||(H._twoSidedLighting||w.Tools.Warn(H.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),M.doubleSided=!0),y){const K=[],q=H._bumpTexture;q&&K.push(this.exportTextureAsync(q,u).then((K=>{K&&(M.normalTexture=K,1!==q.level&&(M.normalTexture.scale=q.level))})));const w=H._ambientTexture;w&&K.push(this.exportTextureAsync(w,u).then((K=>{if(K){const q={index:K.index,texCoord:K.texCoord,extensions:K.extensions};M.occlusionTexture=q;const w=H._ambientTextureStrength;w&&(q.strength=w)}})));const y=H._emissiveTexture;y&&K.push(this.exportTextureAsync(y,u).then((K=>{K&&(M.emissiveTexture=K)}))),K.length>0&&(this._exporter._materialNeedsUVsSet.add(H),await Promise.all(K))}const h=H._emissiveColor;h.equalsWithEpsilon(k,D)||(M.emissiveFactor=h.hh()),M.pbrMetallicRoughness=q}_getPixelsFromTextureAsync(K){return function(K){switch(K){case l.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case l.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case l.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case l.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case l.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case l.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case l.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case l.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case l.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case l.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case l.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case l.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case l.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case l.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case l.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case l.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case l.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case l.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case l.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case l.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case l.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(K.textureFormat)?(0,i.k)(K,K._texture.width,K._texture.height):(K.textureType,l.d.TEXTURETYPE_UNSIGNED_BYTE,K.readPixels())}async exportTextureAsync(K,H){const M=this._exporter._extensionsPreExportTextureAsync("exporter",K,H);return M?await M.then((async M=>M?await this._exportTextureInfoAsync(M,H):await this._exportTextureInfoAsync(K,H))):await this._exportTextureInfoAsync(K,H)}async _exportTextureInfoAsync(K,H){let M=this._textureMap.get(K);if(!M){const q=await this._getPixelsFromTextureAsync(K);if(!q)return null;const u=this._exportTextureSampler(K),y=K.mimeType;if(y)switch(y){case"image/jpeg":case"image/png":case"image/webp":H=y;break;default:w.Tools.Warn(`Unsupported media type: ${y}. Exporting texture as PNG.`)}const h=this._internalTextureToImage,W=K.getInternalTexture().uniqueId;h[W]||(h[W]={});let I=h[W][H];if(void 0===I){const M=K.getSize();I=(async()=>{const w=await this._getImageDataAsync(q,M.width,M.height,H);return this._exportImage(K.name,H,w)})(),h[W][H]=I}M=this._exportTextureInfo(await I,u,K.coordinatesIndex),this._textureMap.set(K,M),this._exporter._extensionsPostExportTextures("exporter",M,K)}return M}_exportImage(K,H,M){const q=this._exporter._images;let u;if(this._exporter._shouldUseGlb){u={name:K,mimeType:H,bufferView:void 0};const q=this._exporter._bufferManager.createBufferView(new Uint8Array(M));this._exporter._bufferManager.setBufferView(u,q)}else{const y=K.replace(/\.\/|\/|\.\\|\\/g,"_"),h=function(K){switch(K){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(H);let W=y+h;q.some((K=>K.uri===W))&&(W=`${y}_${w.Tools.RandomId()}${h}`),u={name:K,uri:W},this._exporter._imageData[W]={data:M,mimeType:H}}return q.push(u),q.length-1}_exportTextureInfo(K,H,M){const q=this._exporter._textures;let w=q.findIndex((M=>M.sampler==H&&M.source===K));-1===w&&(w=q.length,q.push({source:K,sampler:H}));const u={index:w};return M&&(u.texCoord=M),u}_exportTextureSampler(K){const H=this._getTextureSampler(K),M=this._exporter._samplers,q=M.findIndex((K=>K.minFilter===H.minFilter&&K.magFilter===H.magFilter&&K.wrapS===H.wrapS&&K.wrapT===H.wrapT));return-1!==q?q:(M.push(H),M.length-1)}}var p=M(11376),o=M(11112),R=M(11774),t=M(11297);const U=q.OH.Zero(),j=q.Quaternion.Identity(),m=q.OH.One(),F=new q.OH(-1,1,1);function Y(K,H){const{byteOffset:M,byteStride:q,type:w,normalized:u}=K,y=K.getSize(),h=H.reduce(((K,H)=>H.getTotalVertices()>K?H.getTotalVertices():K),-Number.MAX_VALUE);return{byteOffset:M,byteStride:q,componentCount:y,type:w,count:h*y,normalized:u,totalVertices:h,kind:K.getKind()}}function r(K){switch(K){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function e(K){switch(K){case f.d.PositionKind:case f.d.NormalKind:case f.d.TangentKind:case f.d.ColorKind:case f.d.MatricesIndicesKind:case f.d.MatricesIndicesExtraKind:case f.d.MatricesWeightsKind:case f.d.MatricesWeightsExtraKind:case f.d.UVKind:case f.d.UV2Kind:case f.d.UV3Kind:case f.d.UV4Kind:case f.d.UV5Kind:case f.d.UV6Kind:return!0}return!1}function b(K){switch(K){case u.c.TriangleFillMode:return 4;case u.c.TriangleStripDrawMode:return 5;case u.c.TriangleFanDrawMode:return 6;case u.c.PointListDrawMode:case u.c.PointFillMode:return 0;case u.c.LineLoopDrawMode:return 2;case u.c.LineListDrawMode:return 1;case u.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${K}`)}function P(K){const H=Math.sqrt(K.x*K.x+K.y*K.y+K.z*K.z);H>0&&(K.x/=H,K.y/=H,K.z/=H)}function g(K){return K.x*=-1,K}function X(K){if(K.x*K.x+K.y*K.y>.5){const H=Math.abs(K.x),M=Math.abs(K.y);if(H>M){const M=Math.sign(K.x);K.x=H,K.y*=-M,K.z*=-M,K.w*=M}else{const H=Math.sign(K.y);K.x*=-H,K.y=M,K.z*=H,K.w*=-H}}else{const H=Math.abs(K.z),M=Math.abs(K.w);if(H>M){const M=Math.sign(K.z);K.x*=-M,K.y*=M,K.z=H,K.w*=-M}else{const H=Math.sign(K.w);K.x*=H,K.y*=-H,K.z*=-H,K.w=M}}return K}function A(K){K.Lh(-K.z,K.w,K.x,-K.y)}function KK(K,H){const M=q.OH.FromArrayToRef(H.translation||[0,0,0],0,q.TmpVectors.OH[0]),w=q.Quaternion.FromArrayToRef(H.rotation||[0,0,0,1],0,q.TmpVectors.Quaternion[0]),u=q.Matrix.ComposeToRef(m,w,M,q.TmpVectors.Matrix[0]),y=q.OH.FromArrayToRef(K.translation||[0,0,0],0,q.TmpVectors.OH[2]),h=q.Quaternion.FromArrayToRef(K.rotation||[0,0,0,1],0,q.TmpVectors.Quaternion[1]),W=q.Matrix.ComposeToRef(m,h,y,q.TmpVectors.Matrix[1]);u.multiplyToRef(W,W),W.decompose(void 0,w,M),M.equalsWithEpsilon(U,t.d)?delete H.translation:H.translation=M.hh(),w.equalsWithEpsilon(j,t.d)?delete H.rotation:H.rotation=w.hh(),H.scale&&delete H.scale}function HK(K,H){if(!(H instanceof z.e))return!1;if(!(1===H.getChildren().length&&0===K.getChildren().length&&K.parent===H))return!1;const M=K.sK(),q=K instanceof R.e&&!M.useRightHandedSystem?F:m;return!!H.Sh.equalsWithEpsilon(q,t.d)||(o.e.Warn(`Cannot collapse node ${K.name} into parent node ${H.name} with modified scaling.`),!1)}function MK(K){if(K instanceof Array){const H=new Float32Array(K);return new Uint8Array(H.buffer,H.byteOffset,H.byteLength)}return ArrayBuffer.isView(K)?new Uint8Array(K.buffer,K.byteOffset,K.byteLength):new Uint8Array(K)}function qK(K,H){for(const[M,q]of Object.entries(K)){const w=H[M];(Array.isArray(q)&&Array.isArray(w)&&wK(q,w)||q===w)&&delete K[M]}return K}function wK(K,H){return K.length===H.length&&K.every(((K,M)=>K===H[M]))}const uK=q.Matrix.Compose(new q.OH(-1,1,1),q.Quaternion.Identity(),q.OH.Zero());function yK(K,H){if(!(K instanceof z.e))return!1;if(H){if(!K.getWorldMatrix().equalsWithEpsilon(q.Matrix.IdentityReadOnly,t.d))return!1}else{if(!K.getWorldMatrix().multiplyToRef(uK,q.TmpVectors.Matrix[0]).equalsWithEpsilon(q.Matrix.IdentityReadOnly,t.d))return!1}return!(K instanceof G.c&&K.Gh)}const hK=new Map([[Int8Array,(K,H,M)=>K.setInt8(H,M)],[Uint8Array,(K,H,M)=>K.setUint8(H,M)],[Uint8ClampedArray,(K,H,M)=>K.setUint8(H,M)],[Int16Array,(K,H,M)=>K.setInt16(H,M,!0)],[Uint16Array,(K,H,M)=>K.setUint16(H,M,!0)],[Int32Array,(K,H,M)=>K.setInt32(H,M,!0)],[Uint32Array,(K,H,M)=>K.setUint32(H,M,!0)],[Float32Array,(K,H,M)=>K.setFloat32(H,M,!0)],[Float64Array,(K,H,M)=>K.setFloat64(H,M,!0)]]);class WK{writeTypedArray(K){this._checkGrowBuffer(K.byteLength);const H=hK.get(K.constructor);for(let M=0;M<K.length;M++)H(this._dataView,this._byteOffset,K[M]),this._byteOffset+=K.BYTES_PER_ELEMENT}constructor(K){this._data=new Uint8Array(K),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(K){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,K),this._byteOffset++}writeInt8(K){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,K),this._byteOffset++}writeInt16(K){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,K,!0),this._byteOffset+=2}writeUInt16(K){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,K,!0),this._byteOffset+=2}writeInt32(K){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,K,!0),this._byteOffset+=4}writeUInt32(K){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,K,!0),this._byteOffset+=4}writeFloat32(K){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,K,!0),this._byteOffset+=4}writeFloat64(K){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,K,!0),this._byteOffset+=8}_checkGrowBuffer(K){const H=this.byteOffset+K;if(H>this._data.byteLength){const K=new Uint8Array(2*H);K.set(this._data),this._data=K,this._dataView=new DataView(this._data.buffer)}}}function IK(K){return K%4===0?4:K%2===0?2:1}class fK{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(K){let H=0;this._bufferViewToData.forEach((K=>{H+=K.byteLength}));const M=new WK(H),q=Array.from(this._bufferViewToData.keys()).sort(((K,H)=>IK(H.byteLength)-IK(K.byteLength)));for(const w of q){w.byteOffset=M.byteOffset,K.push(w);const H=K.length-1,q=this.getPropertiesWithBufferView(w);for(const K of q)K.bufferView=H;M.writeTypedArray(this._bufferViewToData.get(w)),this._bufferViewToData.delete(w)}return M.getOutputData()}createBufferView(K,H){const M={buffer:0,byteOffset:void 0,byteLength:K.byteLength,byteStride:H};return this._bufferViewToData.set(M,K),M}createAccessor(K,H,M,q,w,u,y){this._verifyBufferView(K);const h={bufferView:void 0,componentType:M,count:q,type:H,min:null===u||void 0===u?void 0:u.min,max:null===u||void 0===u?void 0:u.max,normalized:y,byteOffset:w};return this.setBufferView(h,K),this._accessorToBufferView.set(h,K),h}setBufferView(K,H){this._verifyBufferView(H);this.getPropertiesWithBufferView(H).push(K)}removeBufferView(K){const H=this.getPropertiesWithBufferView(K);for(const M of H)void 0!==M.bufferView&&delete M.bufferView;this._bufferViewToData.delete(K),this._bufferViewToProperties.delete(K),this._accessorToBufferView.forEach(((H,M)=>{H===K&&(void 0!==M.byteOffset&&delete M.byteOffset,this._accessorToBufferView.delete(M))}))}getBufferView(K){const H=this._accessorToBufferView.get(K);return this._verifyBufferView(H),H}getPropertiesWithBufferView(K){return this._verifyBufferView(K),this._bufferViewToProperties.set(K,this._bufferViewToProperties.get(K)??[]),this._bufferViewToProperties.get(K)}getData(K){return this._verifyBufferView(K),this._bufferViewToData.get(K)}_verifyBufferView(K){if(void 0===K||!this._bufferViewToData.has(K))throw new Error(`BufferView ${K} not found in BufferManager.`)}}var zK,GK=M(11733),aK=M(11754),vK=M(11779),OK=M(11659),LK=M(11811),SK=M(11822),BK=M(11726),CK=M(11824);!function(K){K[K.INTANGENT=0]="INTANGENT",K[K.OUTTANGENT=1]="OUTTANGENT"}(zK||(zK={}));class iK{static _IsTransformable(K){return K&&(K instanceof z.e||K instanceof GK.b||K instanceof CK.e)}static _CreateNodeAnimation(K,H,M,q,u){if(this._IsTransformable(K)){const y=[],h=[],W=H.getKeys(),I=iK._CalculateMinMaxKeyFrames(W),f=iK._DeduceInterpolation(W,M,q),z=f.interpolationType,G=f.shouldBakeAnimation;if(G?iK._CreateBakedAnimation(K,H,M,I.min,I.max,H.framePerSecond,u,y,h,I,q):"LINEAR"===z||"STEP"===z?iK._CreateLinearOrStepAnimation(K,H,M,y,h,q):"CUBICSPLINE"===z?iK._CreateCubicSplineAnimation(K,H,M,y,h,q):iK._CreateBakedAnimation(K,H,M,I.min,I.max,H.framePerSecond,u,y,h,I,q),y.length&&h.length){return{inputs:y,outputs:h,samplerInterpolation:z,inputsMin:G?I.min:w.Tools.FloatRound(I.min/H.framePerSecond),inputsMax:G?I.max:w.Tools.FloatRound(I.max/H.framePerSecond)}}}return null}static _DeduceAnimationInfo(K){let H=null,M="VEC3",q=!1;const u=K.targetProperty.split(".");switch(u[0]){case"Sh":H="scale";break;case"position":H="translation";break;case"rotation":M="VEC4",H="rotation";break;case"rotationQuaternion":M="VEC4",q=!0,H="rotation";break;case"influence":M="SCALAR",H="weights";break;default:w.Tools.Error(`Unsupported animatable property ${u[0]}`)}return H?{animationChannelTargetPath:H,dataAccessorType:M,useQuaternion:q}:(w.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(K,H,M,q,w,u,y,h,W,I,f){let z;if(iK._IsTransformable(K)&&K.animations)for(const G of K.animations){if(f&&!f(G))continue;const w=iK._DeduceAnimationInfo(G);w&&(z={name:G.name,samplers:[],channels:[]},iK._AddAnimation(`${G.name}`,G.hasRunningRuntimeAnimations?H:z,K,G,w.dataAccessorType,w.animationChannelTargetPath,q,u,y,h,w.useQuaternion,W,I),z.samplers.length&&z.channels.length&&M.push(z))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(K,H,M,q,w,u,y,h,W,I,f){let z;if(K instanceof BK.b){const w=K.morphTargetManager;if(w)for(let G=0;G<w.numTargets;++G){const a=w.getTarget(G);for(const v of a.animations){if(f&&!f(v))continue;const a=new LK.d(`${v.name}`,"influence",v.framePerSecond,v.dataType,v.loopMode,v.enableBlending),O=[],L=v.getKeys();for(let K=0;K<L.length;++K){const H=L[K];for(let K=0;K<w.numTargets;++K)K==G?O.push(H):O.push({frame:H.frame,value:0})}a.setKeys(O);const S=iK._DeduceAnimationInfo(a);S&&(z={name:a.name,samplers:[],channels:[]},iK._AddAnimation(v.name,v.hasRunningRuntimeAnimations?H:z,K,a,S.dataAccessorType,S.animationChannelTargetPath,q,u,y,h,S.useQuaternion,W,I,w.numTargets),z.samplers.length&&z.channels.length&&M.push(z))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(K,H,M,q,w,u,y,h,W){let I;if(K.animationGroups){const z=K.animationGroups;for(const G of z){const z=new Map,a=new Map,v=new Set,O=G.to-G.from;I={name:G.name,channels:[],samplers:[]};for(let H=0;H<G.targetedAnimations.length;++H){const O=G.targetedAnimations[H],L=O.target,S=O.animation;if(W&&!W(S))continue;const B=h.has(L);if(this._IsTransformable(L)||1===L.length&&this._IsTransformable(L[0])){const K=iK._DeduceAnimationInfo(O.animation);if(K){const H=this._IsTransformable(L)?L:this._IsTransformable(L[0])?L[0]:null;H&&iK._AddAnimation(`${S.name}`,I,H,S,K.dataAccessorType,K.animationChannelTargetPath,M,q,w,u,K.useQuaternion,y,B)}}else if(L instanceof SK.e||1===L.length&&L[0]instanceof SK.e){if(iK._DeduceAnimationInfo(O.animation)){const H=L instanceof SK.e?L:L[0];if(H){const M=K.morphTargetManagers.find((K=>{for(let M=0;M<K.numTargets;++M)if(K.getTarget(M)===H)return!0;return!1}));if(M){const q=K.meshes.find((K=>K.morphTargetManager===M));var f;if(q)z.has(q)||z.set(q,new Map),null===(f=z.get(q))||void 0===f||f.set(H,S),v.add(q),a.set(q,S)}}}}}v.forEach((K=>{const H=K.morphTargetManager;let h=null;const W=[],f=a.get(K).getKeys(),v=f.length;for(let M=0;M<v;++M)for(let q=0;q<H.numTargets;++q){const w=H.getTarget(q),u=z.get(K);if(u){const H=u.get(w);H?(h||(h=new LK.d(`${G.name}_${K.name}_MorphWeightAnimation`,"influence",H.framePerSecond,LK.d.ANIMATIONTYPE_FLOAT,H.loopMode,H.enableBlending)),W.push(H.getKeys()[M])):W.push({frame:G.from+O/v*M,value:w.influence,inTangent:f[0].inTangent?0:void 0,outTangent:f[0].outTangent?0:void 0})}}h.setKeys(W);const L=iK._DeduceAnimationInfo(h);L&&iK._AddAnimation(`${G.name}_${K.name}_MorphWeightAnimation`,I,K,h,L.dataAccessorType,L.animationChannelTargetPath,M,q,w,u,L.useQuaternion,y,!1,null===H||void 0===H?void 0:H.numTargets)})),I.channels.length&&I.samplers.length&&H.push(I)}}}static _AddAnimation(K,H,M,w,u,y,h,W,I,f,z,G,a,v){const O=iK._CreateNodeAnimation(M,w,y,z,G);let L,S,B,C,i,Z;if(O){if(v){let K=0,H=0;const M=[];for(;O.inputs.length>0;)H=O.inputs.shift(),K%v==0&&M.push(H),K++;O.inputs=M}const K=h.get(M),w=new Float32Array(O.inputs);L=W.createBufferView(w),S=W.createAccessor(L,"SCALAR",5126,O.inputs.length,void 0,{min:[O.inputsMin],max:[O.inputsMax]}),f.push(S),B=f.length-1;const I=new q.Quaternion,z=new q.OH,G=new q.OH,E=M instanceof GK.b,l=r(u),s=new Float32Array(O.outputs.length*l);O.outputs.forEach((function(K,H){let M=K;switch(y){case"translation":a&&(q.OH.FromArrayToRef(K,0,G),g(G),G.toArray(M));break;case"rotation":4===K.length?q.Quaternion.FromArrayToRef(K,0,I):(M=new Array(4),q.OH.FromArrayToRef(K,0,z),q.Quaternion.FromEulerVectorToRef(z,I)),a&&(X(I),E&&A(I)),I.toArray(M)}s.set(M,H*l)})),L=W.createBufferView(s),S=W.createAccessor(L,u,5126,O.outputs.length),f.push(S),C=f.length-1,i={interpolation:O.samplerInterpolation,input:B,output:C},H.samplers.push(i),Z={sampler:H.samplers.length-1,target:{node:K,path:y}},H.channels.push(Z)}}static _CreateBakedAnimation(K,H,M,u,y,h,W,I,f,z,G){let a;const v=q.Quaternion.Identity();let O,L=null,S=null,B=null,C=null,i=null,Z=null;z.min=w.Tools.FloatRound(u/h);const E=H.getKeys();for(let q=0,l=E.length;q<l;++q){if(Z=null,B=E[q],q+1<l)if(C=E[q+1],B.value.equals&&B.value.equals(C.value)||B.value===C.value){if(0!==q)continue;Z=B.frame}else Z=C.frame;else{if(i=E[q-1],B.value.equals&&B.value.equals(i.value)||B.value===i.value)continue;Z=y}if(Z)for(let q=B.frame;q<=Z;q+=W){if(O=w.Tools.FloatRound(q/h),O===L)continue;L=O,S=O;const u={key:0,repeatCount:0,loopMode:H.loopMode};a=H._interpolate(q,u),iK._SetInterpolatedValue(K,a,O,H,M,v,I,f,G)}}S&&(z.max=S)}static _ConvertFactorToVector3OrQuaternion(K,H,M,u,y){const h=iK._GetBasePositionRotationOrScale(H,u,y),W=M.targetProperty.split("."),I=W?W[1]:"",f=y?q.Quaternion.iH(h).normalize():q.OH.iH(h);switch(I){case"x":case"y":case"z":f[I]=K;break;case"w":f.w=K;break;default:w.Tools.Error(`glTFAnimation: Unsupported component name "${I}"!`)}return f}static _SetInterpolatedValue(K,H,M,w,u,y,h,W,I){let f;h.push(M),"weights"!==u?(w.dataType===LK.d.ANIMATIONTYPE_FLOAT&&(H=this._ConvertFactorToVector3OrQuaternion(H,K,w,u,I)),"rotation"===u?(I?y=H:(f=H,q.Quaternion.RotationYawPitchRollToRef(f.y,f.x,f.z,y)),W.push(y.hh())):(f=H,W.push(f.hh()))):W.push([H])}static _CreateLinearOrStepAnimation(K,H,M,q,w,u){for(const y of H.getKeys())q.push(y.frame/H.framePerSecond),iK._AddKeyframeValue(y,H,w,M,K,u)}static _CreateCubicSplineAnimation(K,H,M,q,w,u){H.getKeys().forEach((function(y){q.push(y.frame/H.framePerSecond),iK._AddSplineTangent(zK.INTANGENT,w,M,"CUBICSPLINE",y,u),iK._AddKeyframeValue(y,H,w,M,K,u),iK._AddSplineTangent(zK.OUTTANGENT,w,M,"CUBICSPLINE",y,u)}))}static _GetBasePositionRotationOrScale(K,H,M){let w;if("rotation"===H)if(M){w=(K.rotationQuaternion??q.Quaternion.Identity()).hh()}else{w=(K.rotation??q.OH.Zero()).hh()}else if("translation"===H){w=(K.position??q.OH.Zero()).hh()}else{w=(K.Sh??q.OH.One()).hh()}return w}static _AddKeyframeValue(K,H,M,u,y,h){let W;const I=H.dataType;if(I===LK.d.ANIMATIONTYPE_VECTOR3){let H=K.value.hh();if("rotation"===u){const K=q.OH.iH(H);H=q.Quaternion.RotationYawPitchRoll(K.y,K.x,K.z).hh()}M.push(H)}else if(I===LK.d.ANIMATIONTYPE_FLOAT){if("weights"===u)M.push([K.value]);else if(W=this._ConvertFactorToVector3OrQuaternion(K.value,y,H,u,h),W){if("rotation"===u){const K=h?W:q.Quaternion.RotationYawPitchRoll(W.y,W.x,W.z).normalize();M.push(K.hh())}M.push(W.hh())}}else I===LK.d.ANIMATIONTYPE_QUATERNION?M.push(K.value.normalize().hh()):w.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(K,H,M){let q,w,u=!1;if("rotation"===H&&!M)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let y=0,h=K.length;y<h;++y)if(w=K[y],w.inTangent||w.outTangent)if(q){if("CUBICSPLINE"!==q){q="LINEAR",u=!0;break}}else q="CUBICSPLINE";else if(q){if("CUBICSPLINE"===q||w.interpolation&&1===w.interpolation&&"STEP"!==q){q="LINEAR",u=!0;break}}else q=w.interpolation&&1===w.interpolation?"STEP":"LINEAR";return q||(q="LINEAR"),{interpolationType:q,shouldBakeAnimation:u}}static _AddSplineTangent(K,H,M,w,u,y){let h;const W=K===zK.INTANGENT?u.inTangent:u.outTangent;if("CUBICSPLINE"===w){if("rotation"===M)if(W)if(y)h=W.hh();else{const K=W;h=q.Quaternion.RotationYawPitchRoll(K.y,K.x,K.z).hh()}else h=[0,0,0,0];else h="weights"===M?W?[W]:[0]:W?W.hh():[0,0,0];H.push(h)}}static _CalculateMinMaxKeyFrames(K){let H=1/0,M=-1/0;return K.forEach((function(K){H=Math.min(H,K.frame),M=Math.max(M,K.frame)})),{min:H,max:M}}}function ZK(K,H,M,u,y,h){const W={attributes:{},influence:K.influence,name:K.name},I=H.Gh;if(!I)return w.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),W;const z=h?-1:1,G=q.OH.Zero();let a=0,v=0;if(K.hasPositions){const u=K.getPositions(),h=I.getVerticesData(f.d.PositionKind);if(h){const K=new Float32Array(h.length),H=[1/0,1/0,1/0],w=[-1/0,-1/0,-1/0];v=h.length/3,a=0;for(let M=a;M<v;++M){const y=q.OH.iH(h,3*M);q.OH.iH(u,3*M).subtractToRef(y,G),G.x*=z,H[0]=Math.min(H[0],G.x),w[0]=Math.max(w[0],G.x),H[1]=Math.min(H[1],G.y),w[1]=Math.max(w[1],G.y),H[2]=Math.min(H[2],G.z),w[2]=Math.max(w[2],G.z),K[3*M]=G.x,K[3*M+1]=G.y,K[3*M+2]=G.z}const I=M.createBufferView(K,12),f=M.createAccessor(I,"VEC3",5126,u.length/3,0,{min:H,max:w});y.push(f),W.attributes.POSITION=y.length-1}else w.Tools.Warn(`Morph target positions for mesh ${H.name} were not exported. Mesh does not have position vertex data`)}if(K.hasNormals){const u=K.getNormals(),h=I.getVerticesData(f.d.NormalKind);if(h){const K=new Float32Array(h.length);v=h.length/3,a=0;for(let M=a;M<v;++M){const H=q.OH.iH(h,3*M).normalize();q.OH.iH(u,3*M).normalize().subtractToRef(H,G),K[3*M]=G.x*z,K[3*M+1]=G.y,K[3*M+2]=G.z}const H=M.createBufferView(K,12),w=M.createAccessor(H,"VEC3",5126,u.length/3,0);y.push(w),W.attributes.NORMAL=y.length-1}else w.Tools.Warn(`Morph target normals for mesh ${H.name} were not exported. Mesh does not have normals vertex data`)}if(K.hasTangents){const u=K.getTangents(),h=I.getVerticesData(f.d.TangentKind);if(h){v=h.length/4;const K=new Float32Array(3*v);a=0;for(let M=a;M<v;++M){const H=q.OH.iH(h,4*M);P(H);const w=q.OH.iH(u,3*M);P(w),w.subtractToRef(H,G),K[3*M]=G.x*z,K[3*M+1]=G.y,K[3*M+2]=G.z}const H=M.createBufferView(K,12),w=M.createAccessor(H,"VEC3",5126,v,0);y.push(w),W.attributes.TANGENT=y.length-1}else w.Tools.Warn(`Morph target tangents for mesh ${H.name} were not exported. Mesh does not have tangents vertex data`)}if(K.hasColors){const u=K.getColors(),h=I.getVerticesData(f.d.ColorKind),z=I.getVertexBuffer(f.d.ColorKind);if(h&&z){const K=z.getSize();v=h.length/K;const H=new Float32Array(v*K);a=0;for(let M=a;M<v;++M)if(3===K){const w=q.OH.iH(h,M*K);q.OH.iH(u,M*K).subtractToRef(w,G),H[3*M]=G.x,H[3*M+1]=G.y,H[3*M+2]=G.z}else if(4===K){const w=new q.Vector4,y=q.Vector4.iH(h,M*K);q.Vector4.iH(u,M*K).subtractToRef(y,w),H[4*M]=w.x,H[4*M+1]=w.y,H[4*M+2]=w.z,H[4*M+3]=w.w}else w.Tools.Warn(`Unsupported number of components for color attribute: ${K}`);const I=M.createBufferView(H,4*K),f=M.createAccessor(I,3===K?"VEC3":"VEC4",5126,v,0);y.push(f),W.attributes.COLOR_0=y.length-1}else w.Tools.Warn(`Morph target colors for mesh ${H.name} were not exported. Mesh does not have colors vertex data`)}return W}var EK=M(11831),lK=M(11684),sK=M(11673),DK=M(11242);class VK{}VK.DEFAULT_COLOR=L.CH.White(),VK.DEFAULT_WIDTH_ATTENUATED=1,VK.DEFAULT_WIDTH=.1;var nK=M(11496),cK=M(11837);class kK{static ConvertPoints(K,H){if(K.length&&Array.isArray(K)&&"number"===typeof K[0])return[K];if(K.length&&Array.isArray(K[0])&&"number"===typeof K[0][0])return K;if(K.length&&!Array.isArray(K[0])&&K[0]instanceof q.OH){const H=[];for(let M=0;M<K.length;M++){const q=K[M];H.push(q.x,q.y,q.z)}return[H]}if(K.length>0&&Array.isArray(K[0])&&K[0].length>0&&K[0][0]instanceof q.OH){const H=[],M=K;for(const K of M)H.push(K.flatMap((K=>[K.x,K.y,K.z])));return H}if(K instanceof Float32Array){if(null!==H&&void 0!==H&&H.floatArrayStride){const M=[],q=3*H.floatArrayStride;for(let H=0;H<K.length;H+=q){const w=new Array(q);for(let M=0;M<q;M++)w[M]=K[H+M];M.push(w)}return M}return[Array.from(K)]}if(K.length&&K[0]instanceof Float32Array){const H=[];for(const M of K)H.push(Array.from(M));return H}return[]}static OmitZeroLengthPredicate(K,H,M){const q=[];return H.LH(K).lengthSquared()>0&&q.push([K,H]),M.LH(H).lengthSquared()>0&&q.push([H,M]),K.LH(M).lengthSquared()>0&&q.push([M,K]),0===q.length?null:q}static OmitDuplicatesPredicate(K,H,M,q){const w=[];return kK._SearchInPoints(K,H,q)||w.push([K,H]),kK._SearchInPoints(H,M,q)||w.push([H,M]),kK._SearchInPoints(M,K,q)||w.push([M,K]),0===w.length?null:w}static _SearchInPoints(K,H,M){for(const y of M)for(let M=0;M<y.length;M++){var q,w,u;if(null!==(q=y[M])&&void 0!==q&&q.equals(K))if(null!==(w=y[M+1])&&void 0!==w&&w.equals(H)||null!==(u=y[M-1])&&void 0!==u&&u.equals(H))return!0}return!1}static MeshesToLines(K,H){const M=[];for(let w=0;w<K.length;w++){const u=K[w],y=u.getVerticesData(f.d.PositionKind),h=u.ah();if(y&&h)for(let K=0,W=0;K<h.length;K++){const I=3*h[W++],f=3*h[W++],z=3*h[W++],G=new q.OH(y[I],y[I+1],y[I+2]),a=new q.OH(y[f],y[f+1],y[f+2]),v=new q.OH(y[z],y[z+1],y[z+2]);if(H){const q=H(G,a,v,M,K,I,u,w,y,h);if(q)for(const K of q)M.push(K)}else M.push([G,a],[a,v],[v,G])}}return M}static ToVector3Array(K){if(Array.isArray(K[0])){const H=[],M=K;for(const K of M){const M=[];for(let H=0;H<K.length;H+=3)M.push(new q.OH(K[H],K[H+1],K[H+2]));H.push(M)}return H}const H=K,M=[];for(let w=0;w<H.length;w+=3)M.push(new q.OH(H[w],H[w+1],H[w+2]));return M}static ToNumberArray(K){return K.flatMap((K=>[K.x,K.y,K.z]))}static GetPointsCountInfo(K){const H=new Array(K.length);let M=0;for(let q=K.length;q--;)H[q]=K[q].length/3,M+=H[q];return{total:M,counts:H}}static GetLineLength(K){if(0===K.length)return 0;let H;H="number"===typeof K[0]?kK.ToVector3Array(K):K;const M=q.TmpVectors.OH[0];let w=0;for(let q=0;q<H.length-1;q++){const K=H[q];w+=H[q+1].subtractToRef(K,M).length()}return w}static GetLineLengthArray(K){const H=new Float32Array(K.length/3);let M=0;for(let q=0,w=K.length/3-1;q<w;q++){let w=K[3*q+0],u=K[3*q+1],y=K[3*q+2];w-=K[3*q+3],u-=K[3*q+4],y-=K[3*q+5];M+=Math.sqrt(w*w+u*u+y*y),H[q+1]=M}return H}static SegmentizeSegmentByCount(K,H,M){const w=[],u=H.LH(K),y=q.TmpVectors.OH[0];y.Bh(M);const h=q.TmpVectors.OH[1];u.divideToRef(y,h);let W=K.clone();w.push(W);for(let q=0;q<M;q++)W=W.clone(),w.push(W.addInPlace(h));return w}static SegmentizeLineBySegmentLength(K,H){const M=K[0]instanceof q.OH?kK.GetLineSegments(K):"number"===typeof K[0]?kK.GetLineSegments(kK.ToVector3Array(K)):K,w=[];for(const q of M)if(q.length>H){const K=kK.SegmentizeSegmentByCount(q.point1,q.point2,Math.ceil(q.length/H));for(const H of K)w.push(H)}else w.push(q.point1),w.push(q.point2);return w}static SegmentizeLineBySegmentCount(K,H){const M="number"===typeof K[0]?kK.ToVector3Array(K):K,q=kK.GetLineLength(M)/H;return kK.SegmentizeLineBySegmentLength(M,q)}static GetLineSegments(K){const H=[];for(let M=0;M<K.length-1;M++){const q=K[M],w=K[M+1],u=w.LH(q).length();H.push({point1:q,point2:w,length:u})}return H}static GetMinMaxSegmentLength(K){const H=kK.GetLineSegments(K).sort((K=>K.length));return{min:H[0].length,max:H[H.length-1].length}}static GetPositionOnLineByVisibility(K,H,M){let w=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const u=H*M;let y=0,h=0;const W=K.length;for(let q=0;q<W;q++){if(u<=y+K[q].length){h=q;break}y+=K[q].length}const I=(u-y)/K[h].length;return K[h].point2.subtractToRef(K[h].point1,q.TmpVectors.OH[0]),q.TmpVectors.OH[1]=q.TmpVectors.OH[0].multiplyByFloats(I,I,I),w||q.TmpVectors.OH[1].addInPlace(K[h].point1),q.TmpVectors.OH[1].clone()}static GetCircleLinePoints(K,H){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:K,u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/H;const y=[];for(let h=0;h<=H;h++)y.push(new q.OH(Math.cos(h*u)*K,Math.sin(h*u)*w,M));return y}static GetBezierLinePoints(K,H,M,q){return nK.h.CreateQuadraticBezier(K,H,M,q).getPoints().flatMap((K=>[K.x,K.y,K.z]))}static GetArrowCap(K,H,M,q,w){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[K.clone(),K.add(H.multiplyByFloats(M,M,M))],widths:[q,w,u,y]}}static GetPointsFromText(K,H,M,q){let w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,u=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const y=[],h=(0,cK.c)(K,H,M,q);for(const W of h){for(const K of W.paths){const H=[],M=K.getPoints();for(const K of M)H.push(K.x,K.y,w);y.push(H)}if(u)for(const K of W.holes){const H=[],M=K.getPoints();for(const K of M)H.push(K.x,K.y,w);y.push(H)}}return y}static Color3toRGBAUint8(K){const H=new Uint8Array(4*K.length);for(let M=0,q=0;M<K.length;M++)H[q++]=255*K[M].r,H[q++]=255*K[M].g,H[q++]=255*K[M].b,H[q++]=255;return H}static CreateColorsTexture(K,H,M,q){const w=q.getEngine().getCaps().maxTextureSize??1,u=H.length>w?w:H.length,y=Math.ceil(H.length/w);y>1&&(H=[...H,...Array(u*y-H.length).fill(H[0])]);const h=kK.Color3toRGBAUint8(H),W=new E.d(h,u,y,v.c.TEXTUREFORMAT_RGBA,q,!1,!0,M);return W.name=K,W}static PrepareEmptyColorsTexture(K){if(!VK.EmptyColorsTexture){const H=new Uint8Array(4);VK.EmptyColorsTexture=new E.d(H,1,1,v.c.TEXTUREFORMAT_RGBA,K,!1,!1,E.d.NEAREST_NEAREST),VK.EmptyColorsTexture.name="grlEmptyColorsTexture"}return VK.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var K;null===(K=VK.EmptyColorsTexture)||void 0===K||K.dispose(),VK.EmptyColorsTexture=null}static BooleanToNumber(K){return K?1:0}}class TK extends sK.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class dK extends lK.b{isCompatible(K){return!0}constructor(K,H,M){var w;M=M||{color:VK.DEFAULT_COLOR};const u=new TK;u.GREASED_LINE_HAS_COLOR=!!M.color&&!M.useColors,u.GREASED_LINE_SIZE_ATTENUATION=M.sizeAttenuation??!1,u.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===M.colorDistributionType,u.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(H??K.sK()).useRightHandedSystem,u.GREASED_LINE_CAMERA_FACING=M.cameraFacing??!0,super(K,dK.GREASED_LINE_MATERIAL_NAME,200,u,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(w=M)||void 0===w?void 0:w.forceGLSL)||dK.ForceGLSL,this._scene=H??K.sK(),this._engine=this._scene.getEngine(),this._cameraFacing=M.cameraFacing??!0,this.visibility=M.visibility??1,this.useDash=M.useDash??!1,this.dashRatio=M.dashRatio??.5,this.dashOffset=M.dashOffset??0,this.width=M.width?M.width:M.sizeAttenuation?VK.DEFAULT_WIDTH_ATTENUATED:VK.DEFAULT_WIDTH,this._sizeAttenuation=M.sizeAttenuation??!1,this.colorMode=M.colorMode??0,this._color=M.color??null,this.useColors=M.useColors??!1,this._colorsDistributionType=M.colorDistributionType??0,this.colorsSampling=M.colorsSampling??E.d.NEAREST_NEAREST,this._colors=M.cK??null,this.dashCount=M.dashCount??1,this.resolution=M.resolution??new q.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),M.colorsTexture?this.colorsTexture=M.colorsTexture:this._colors?this.colorsTexture=kK.CreateColorsTexture(`${K.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??VK.DEFAULT_COLOR,kK.PrepareEmptyColorsTexture(this._scene)),this._engine.Hh.add((()=>{kK.DisposeEmptyColorsTexture()}))}getAttributes(K){K.push("grl_offsets"),K.push("grl_widths"),K.push("grl_colorPointers"),K.push("grl_counters"),this._cameraFacing?(K.push("grl_previousAndSide"),K.push("grl_nextAndCounters")):K.push("grl_slopes")}getSamplers(K){K.push("grl_colors")}getActiveTextures(K){this.colorsTexture&&K.push(this.colorsTexture)}getUniforms(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const H=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&H.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===K&&H.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:H,vertex:this._cameraFacing&&this._isGLSL(K)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(K)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(K){if(this._cameraFacing){K.fh("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||K.fh("viewProjection",this._scene.getTransformMatrix());const H=q.TmpVectors.Vector4[0];H.x=this._aspect,H.y=this._resolution.x,H.z=this._resolution.y,H.w=this.width,K.updateVector4("grl_aspect_resolution_lineWidth",H)}const H=q.TmpVectors.Vector4[0];H.x=kK.BooleanToNumber(this.useDash),H.y=this._dashArray,H.z=this.dashOffset,H.w=this.dashRatio,K.updateVector4("grl_dashOptions",H);const M=q.TmpVectors.Vector4[1];M.x=this.colorMode,M.y=this.visibility,M.z=this.colorsTexture?this.colorsTexture.getSize().width:0,M.w=kK.BooleanToNumber(this.useColors),K.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",M),this._color&&K.updateColor3("grl_singleColor",this._color);const w=this.colorsTexture??VK.EmptyColorsTexture;K.setTexture("grl_colors",w),K.updateFloat2("grl_textureSize",(null===w||void 0===w?void 0:w.getSize().width)??1,(null===w||void 0===w?void 0:w.getSize().height)??1)}prepareDefines(K,H,M){K.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,K.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,K.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,K.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=H.useRightHandedSystem,K.GREASED_LINE_CAMERA_FACING=this._cameraFacing,K.GREASED_LINE_USE_OFFSETS=!!M.offsets}getClassName(){return dK.GREASED_LINE_MATERIAL_NAME}getCustomCode(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(H)?function(K,H){if("vertex"===K){const K={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return H&&(K["!gl_Position\\=viewProjection\\*worldPos;"]="//"),K}return"fragment"===K?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(K,this._cameraFacing):function(K,H){if("vertex"===K){const K={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return H&&(K["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),K}return"fragment"===K?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(K,this._cameraFacing)}dispose(){var K;null===(K=this.colorsTexture)||void 0===K||K.dispose(),super.dispose()}get cK(){return this._colors}set cK(K){this.setColors(K)}setColors(K){var H;let M=arguments.length>1&&void 0!==arguments[1]&&arguments[1],q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const w=(null===(H=this._colors)||void 0===H?void 0:H.length)??0;var u;if(this._colors=K,null!==K&&0!==K.length){if(!M||q)if(this.colorsTexture&&w===K.length&&!q){const H=kK.Color3toRGBAUint8(K);this.colorsTexture.update(H)}else{var y;null===(y=this.colorsTexture)||void 0===y||y.dispose(),this.colorsTexture=kK.CreateColorsTexture(`${this._material.name}-colors-texture`,K,this.colorsSampling,this._scene)}}else null===(u=this.colorsTexture)||void 0===u||u.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(K){this._dashCount=K,this._dashArray=1/K}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(K){this._sizeAttenuation=K,this.markAllDefinesAsDirty()}get color(){return this._color}set color(K){this.setColor(K)}setColor(K){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==K||null!==this._color&&null===K?(this._color=K,H||this.markAllDefinesAsDirty()):this._color=K}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(K){this._colorsDistributionType=K,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(K){this._aspect=K.x/K.y,this._resolution=K}serialize(){const K=super.serialize(),H={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(H.cK=this._colors),this._color&&(H.color=this._color),K.greasedLineMaterialOptions=H,K}parse(K,H,M){var q;super.parse(K,H,M);const w=K.greasedLineMaterialOptions;null===(q=this.colorsTexture)||void 0===q||q.dispose(),w.color&&this.setColor(w.color,!0),w.colorDistributionType&&(this.colorsDistributionType=w.colorDistributionType),w.cK&&(this.cK=w.cK),w.colorsSampling&&(this.colorsSampling=w.colorsSampling),w.colorMode&&(this.colorMode=w.colorMode),w.useColors&&(this.useColors=w.useColors),w.visibility&&(this.visibility=w.visibility),w.useDash&&(this.useDash=w.useDash),w.dashCount&&(this.dashCount=w.dashCount),w.dashRatio&&(this.dashRatio=w.dashRatio),w.dashOffset&&(this.dashOffset=w.dashOffset),w.width&&(this.width=w.width),w.sizeAttenuation&&(this.sizeAttenuation=w.sizeAttenuation),w.resolution&&(this.resolution=w.resolution),this.cK?this.colorsTexture=kK.CreateColorsTexture(`${this._material.name}-colors-texture`,this.cK,this.colorsSampling,H):kK.PrepareEmptyColorsTexture(H),this.markAllDefinesAsDirty()}copyTo(K){var H;const M=K;null===(H=M.colorsTexture)||void 0===H||H.dispose(),this._colors&&(M.colorsTexture=kK.CreateColorsTexture(`${M._material.name}-colors-texture`,this._colors,M.colorsSampling,this._scene)),M.setColor(this.color,!0),M.colorsDistributionType=this.colorsDistributionType,M.colorsSampling=this.colorsSampling,M.colorMode=this.colorMode,M.useColors=this.useColors,M.visibility=this.visibility,M.useDash=this.useDash,M.dashCount=this.dashCount,M.dashRatio=this.dashRatio,M.dashOffset=this.dashOffset,M.width=this.width,M.sizeAttenuation=this.sizeAttenuation,M.resolution=this.resolution,M.markAllDefinesAsDirty()}_isGLSL(K){return 0===K||this._forceGLSL}}dK.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",dK.ForceGLSL=!1,(0,DK.f)(`BABYLON.${dK.GREASED_LINE_MATERIAL_NAME}`,dK);var xK=M(11714),QK=M(11118),JK=M(11514),NK=M(11223);class pK extends JK.ShaderMaterial{constructor(K,H,w){const u=H.getEngine(),y=u.isWebGPU&&!(w.forceGLSL||pK.ForceGLSL),h=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];H.useRightHandedSystem&&h.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const W=["position","grl_widths","grl_offsets","grl_colorPointers"];w.cameraFacing?(h.push("GREASED_LINE_CAMERA_FACING"),W.push("grl_previousAndSide","grl_nextAndCounters")):(W.push("grl_slopes"),W.push("grl_counters"));const I=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(y||I.push("world","viewProjection","view","projection"),super(K,H,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:y?["Scene","Mesh"]:void 0,attributes:W,uniforms:I,samplers:y?[]:["grlColors"],defines:h,extraInitializationsAsync:async()=>{y?await Promise.all([M.e(66).then(M.bind(M,14388)),M.e(75).then(M.bind(M,14396))]):await Promise.all([M.e(69).then(M.bind(M,14404)),M.e(76).then(M.bind(M,14407))])},shaderLanguage:y?1:0}),this._color=L.CH.White(),this._colorsDistributionType=0,this._colorsTexture=null,w=w||{color:VK.DEFAULT_COLOR},this.visibility=w.visibility??1,this.useDash=w.useDash??!1,this.dashRatio=w.dashRatio??.5,this.dashOffset=w.dashOffset??0,this.dashCount=w.dashCount??1,this.width=w.width?w.width:w.sizeAttenuation&&w.cameraFacing?VK.DEFAULT_WIDTH_ATTENUATED:VK.DEFAULT_WIDTH,this.sizeAttenuation=w.sizeAttenuation??!1,this.color=w.color??L.CH.White(),this.useColors=w.useColors??!1,this.colorsDistributionType=w.colorDistributionType??0,this.colorsSampling=w.colorsSampling??E.d.NEAREST_NEAREST,this.colorMode=w.colorMode??0,this._colors=w.cK??null,this._cameraFacing=w.cameraFacing??!0,this.resolution=w.resolution??new q.Vector2(u.getRenderWidth(),u.getRenderHeight()),w.colorsTexture?this.colorsTexture=w.colorsTexture:this._colors?this.colorsTexture=kK.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,H):(this._color=this._color??VK.DEFAULT_COLOR,this.colorsTexture=kK.PrepareEmptyColorsTexture(H)),y){const K=new NK.c;K.setParameters(),K.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",K)}u.Hh.add((()=>{kK.DisposeEmptyColorsTexture()}))}dispose(){var K;null===(K=this._colorsTexture)||void 0===K||K.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new q.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get cK(){return this._colors}set cK(K){this.setColors(K)}setColors(K){var H;let M=arguments.length>1&&void 0!==arguments[1]&&arguments[1],q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const w=(null===(H=this._colors)||void 0===H?void 0:H.length)??0;var u;if(this._colors=K,null!==K&&0!==K.length){if(!M||q)if(this._colorsTexture&&w===K.length&&!q){const H=kK.Color3toRGBAUint8(K);this._colorsTexture.update(H)}else{var y;null===(y=this._colorsTexture)||void 0===y||y.dispose(),this.colorsTexture=kK.CreateColorsTexture(`${this.name}-colors-texture`,K,this.colorsSampling,this.sK())}}else null===(u=this._colorsTexture)||void 0===u||u.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(K){this._colorsTexture=K,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(K){this._width=K,this.setFloat("grlWidth",K)}get useColors(){return this._useColors}set useColors(K){this._useColors=K,this.setFloat("grlUseColors",kK.BooleanToNumber(K))}get colorsSampling(){return this._colorsSampling}set colorsSampling(K){this._colorsSampling=K}get visibility(){return this._visibility}set visibility(K){this._visibility=K,this.setFloat("grlVisibility",K)}get useDash(){return this._useDash}set useDash(K){this._useDash=K,this.setFloat("grlUseDash",kK.BooleanToNumber(K))}get dashOffset(){return this._dashOffset}set dashOffset(K){this._dashOffset=K,this.setFloat("grlDashOffset",K)}get dashRatio(){return this._dashRatio}set dashRatio(K){this._dashRatio=K,this.setFloat("grlDashRatio",K)}get dashCount(){return this._dashCount}set dashCount(K){this._dashCount=K,this._dashArray=1/K,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(K){this._sizeAttenuation=K,this.setFloat("grlSizeAttenuation",kK.BooleanToNumber(K))}get color(){return this._color}set color(K){this.setColor(K)}setColor(K){K=K??VK.DEFAULT_COLOR,this._color=K,this.setColor3("grlColor",K)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(K){this._colorsDistributionType=K,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(K){this._colorMode=K,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(K){this._resolution=K,this.setVector2("grlResolution",K),this.setFloat("grlAspect",K.x/K.y)}serialize(){const K=super.serialize(),H={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(H.cK=this._colors),K.greasedLineMaterialOptions=H,K}parse(K,H,M){var q;const w=K.greasedLineMaterialOptions;null===(q=this._colorsTexture)||void 0===q||q.dispose(),w.color&&(this.color=w.color),w.colorDistributionType&&(this.colorsDistributionType=w.colorDistributionType),w.colorsSampling&&(this.colorsSampling=w.colorsSampling),w.colorMode&&(this.colorMode=w.colorMode),w.useColors&&(this.useColors=w.useColors),w.visibility&&(this.visibility=w.visibility),w.useDash&&(this.useDash=w.useDash),w.dashCount&&(this.dashCount=w.dashCount),w.dashRatio&&(this.dashRatio=w.dashRatio),w.dashOffset&&(this.dashOffset=w.dashOffset),w.width&&(this.width=w.width),w.sizeAttenuation&&(this.sizeAttenuation=w.sizeAttenuation),w.resolution&&(this.resolution=w.resolution),w.cK?this.colorsTexture=kK.CreateColorsTexture(`${this.name}-colors-texture`,w.cK,this.colorsSampling,this.sK()):this.colorsTexture=kK.PrepareEmptyColorsTexture(H),this._cameraFacing=w.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var oK,RK,tK;pK.ForceGLSL=!1,function(K){K[K.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",K[K.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(oK||(oK={})),function(K){K[K.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",K[K.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",K[K.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(RK||(RK={})),function(K){K[K.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",K[K.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",K[K.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",K[K.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",K[K.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(tK||(tK={}));class UK extends BK.b{constructor(K,H,M){super(K,H,null,null,!1,!1),this.name=K,this._options=M,this._lazy=!1,this._updatable=!1,this._engine=H.getEngine(),this._lazy=M.lazy??!1,this._updatable=M.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=M.colorPointers??[],this._widths=M.widths??new Array(M.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(K){let H=0;for(const q of this._points)H+=q.length;const M=H/3*2-this._widths.length;for(let q=0;q<M;q++)this._widths.push(K)}updateLazy(){var K,H;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(K=this._options.ribbonOptions)||void 0===K?void 0:K.smoothShading),!this.xK&&this.refreshBoundingInfo(),null===(H=this.greasedLineMaterial)||void 0===H||H.updateLazy()}addPoints(K,H){for(const M of K)this._points.push(M);this._lazy||this.setPoints(this._points,H)}dispose(K){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(K,H)}isLazy(){return this._lazy}get kK(){return this._uvs}set kK(K){this._uvs=K instanceof Float32Array?K:new Float32Array(K),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(K){this.material instanceof pK&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===K||void 0===K?void 0:K.length)>0),this._offsets=K,this._offsetsBuffer?this._offsetsBuffer.update(K):this._createOffsetsBuffer(K)}get widths(){return this._widths}set widths(K){this._widths=K,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(K)}get colorPointers(){return this._colorPointers}set colorPointers(K){this._colorPointers=K,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(K)}get greasedLineMaterial(){var K,H;if(this.material&&this.material instanceof pK)return this.material;const M=null===(K=this.material)||void 0===K||null===(H=K.pluginManager)||void 0===H?void 0:H.getPlugin(dK.GREASED_LINE_MATERIAL_NAME);return M||void 0}get points(){const K=[];return QK.b.DeepCopy(this._points,K),K}setPoints(K,H){this._points=kK.ConvertPoints(K,(null===H||void 0===H?void 0:H.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==H&&void 0!==H&&H.colorPointers||this._updateColorPointers(),this._setPoints(this._points,H)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,kK:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(K){super.serialize(K),K.type=this.getClassName(),K.lineOptions=this._createLineOptions()}_createVertexBuffers(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=new xK.d;return H.VK=this._vertexPositions,H.indices=this._indices,H.kK=this._uvs,K&&(H.nK=[],xK.d.ComputeNormals(this._vertexPositions,this._indices,H.nK)),H.dK(this,this._options.updatable),H}_createOffsetsBuffer(K){const H=this._scene.getEngine(),M=new f.c(H,K,this._updatable,3);this.setVerticesBuffer(M.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=M}}class jK{constructor(K,H){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=K,this.wasAddedByNoopNode=H}getIndicesAccessor(K,H,M,q,w){var u,y,h,W;return null===(u=this._indicesAccessorMap.get(K))||void 0===u||null===(y=u.get(H))||void 0===y||null===(h=y.get(M))||void 0===h||null===(W=h.get(q))||void 0===W?void 0:W.get(w)}setIndicesAccessor(K,H,M,q,w,u){let y=this._indicesAccessorMap.get(K);y||(y=new Map,this._indicesAccessorMap.set(K,y));let h=y.get(H);h||(h=new Map,y.set(H,h));let W=h.get(M);W||(W=new Map,h.set(M,W));let I=W.get(q);I||(I=new Map,W.set(q,I)),I.set(w,u)}pushExportedNode(K){this._exportedNodes.has(K)||this._exportedNodes.add(K)}getNodesSet(){return this._exportedNodes}getVertexBufferView(K){return this._vertexBufferViewMap.get(K)}setVertexBufferView(K,H){this._vertexBufferViewMap.set(K,H)}setRemappedBufferView(K,H,M){this._remappedBufferView.set(K,new Map),this._remappedBufferView.get(K).set(H,M)}getRemappedBufferView(K,H){var M;return null===(M=this._remappedBufferView.get(K))||void 0===M?void 0:M.get(H)}getVertexAccessor(K,H,M){var q,w;return null===(q=this._vertexAccessorMap.get(K))||void 0===q||null===(w=q.get(H))||void 0===w?void 0:w.get(M)}setVertexAccessor(K,H,M,q){let w=this._vertexAccessorMap.get(K);w||(w=new Map,this._vertexAccessorMap.set(K,w));let u=w.get(H);u||(u=new Map,w.set(H,u)),u.set(M,q)}hasVertexColorAlpha(K){return this._vertexMapColorAlpha.get(K)||!1}setHasVertexColorAlpha(K,H){return this._vertexMapColorAlpha.set(K,H)}getMesh(K){return this._meshMap.get(K)}setMesh(K,H){this._meshMap.set(K,H)}bindMorphDataToMesh(K,H){const M=this._meshMorphTargetMap.get(K)||[];this._meshMorphTargetMap.set(K,M),-1===M.indexOf(H)&&M.push(H)}getMorphTargetsFromMesh(K){return this._meshMorphTargetMap.get(K)}}class mK{_ApplyExtension(K,H,M,q){if(M>=H.length)return Promise.resolve(K);const w=q(H[M],K);return w?w.then((async K=>K?await this._ApplyExtension(K,H,M+1,q):null)):this._ApplyExtension(K,H,M+1,q)}_ApplyExtensions(K,H){const M=[];for(const q of mK._ExtensionNames)M.push(this._extensions[q]);return this._ApplyExtension(K,M,0,H)}_extensionsPreExportTextureAsync(K,H,M){return this._ApplyExtensions(H,((H,q)=>H.preExportTextureAsync&&H.preExportTextureAsync(K,q,M)))}_extensionsPostExportNodeAsync(K,H,M,q,w){return this._ApplyExtensions(H,((H,u)=>H.postExportNodeAsync&&H.postExportNodeAsync(K,u,M,q,w,this._bufferManager)))}_extensionsPostExportMaterialAsync(K,H,M){return this._ApplyExtensions(H,((H,q)=>H.postExportMaterialAsync&&H.postExportMaterialAsync(K,q,M)))}_extensionsPostExportMaterialAdditionalTextures(K,H,M){const q=[];for(const w of mK._ExtensionNames){const u=this._extensions[w];u.postExportMaterialAdditionalTextures&&q.push(...u.postExportMaterialAdditionalTextures(K,H,M))}return q}_extensionsPostExportTextures(K,H,M){for(const q of mK._ExtensionNames){const w=this._extensions[q];w.postExportTexture&&w.postExportTexture(K,H,M)}}_extensionsPostExportMeshPrimitive(K){for(const H of mK._ExtensionNames){const M=this._extensions[H];M.postExportMeshPrimitive&&M.postExportMeshPrimitive(K,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const K of mK._ExtensionNames){const H=this._extensions[K];H.preGenerateBinaryAsync&&await H.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(K){for(const H of mK._ExtensionNames){const M=this._extensions[H];M.enabled&&K(M)}}_extensionsOnExporting(){this._forEachExtensions((K=>{var H,M,q;K.wasUsed&&((H=this._glTF).extensionsUsed||(H.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(K.name)&&this._glTF.extensionsUsed.push(K.name),K.required&&((M=this._glTF).extensionsRequired||(M.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(K.name)&&this._glTF.extensionsRequired.push(K.name)),(q=this._glTF).extensions||(q.extensions={}),K.onExporting&&K.onExporting())}))}_loadExtensions(){for(const K of mK._ExtensionNames){const H=mK._ExtensionFactories[K](this);this._extensions[K]=H}}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:O.b.LastCreatedScene,H=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${v.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new N(this),this._extensions={},this._bufferManager=new fK,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!K)throw new Error("No scene available to export");this._babylonScene=K,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:K=>{var H;return null===K||void 0===K||null===(H=K.wh)||void 0===H?void 0:H.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...H},this._loadExtensions()}dispose(){for(const K in this._extensions){this._extensions[K].dispose()}}get options(){return this._options}static RegisterExtension(K,H){mK.UnregisterExtension(K)&&w.Tools.Warn(`Extension with the name ${K} already exists`),mK._ExtensionFactories[K]=H,mK._ExtensionNames.push(K)}static UnregisterExtension(K){if(!mK._ExtensionFactories[K])return!1;delete mK._ExtensionFactories[K];const H=mK._ExtensionNames.indexOf(K);return-1!==H&&mK._ExtensionNames.splice(H,1),!0}_generateJSON(K,H,M){const q={byteLength:K};return q.byteLength&&(this._glTF.buffers=[q]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.SH=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(q.uri=H+".bin"),M?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(K){const H=await this._generateBinaryAsync();this._extensionsOnExporting();const M=this._generateJSON(H.byteLength,K,!0),q=new Blob([H],{type:"application/octet-stream"}),w=K+".gltf",u=K+".bin",y=new I;if(y.files[w]=M,y.files[u]=q,this._imageData)for(const h in this._imageData)y.files[h]=new Blob([this._imageData[h].data],{type:this._imageData[h].mimeType});return y}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(K){const H=K%4;return 0===H?H:4-H}async generateGLBAsync(K){this._shouldUseGlb=!0;const H=await this._generateBinaryAsync();this._extensionsOnExporting();const M=this._generateJSON(H.byteLength),q=K+".glb";let w,u=M.length;if("undefined"!==typeof TextEncoder){w=(new TextEncoder).encode(M),u=w.length}const y=this._getPadding(u),h=this._getPadding(H.byteLength),W=28+u+y+H.byteLength+h,f=new WK(W);if(f.writeUInt32(1179937895),f.writeUInt32(2),f.writeUInt32(W),f.writeUInt32(u+y),f.writeUInt32(1313821514),w)f.writeTypedArray(w);else{const K="_".charCodeAt(0);for(let H=0;H<u;++H){const q=M.charCodeAt(H);q!=M.codePointAt(H)?f.writeUInt8(K):f.writeUInt8(q)}}for(let I=0;I<y;++I)f.writeUInt8(32);f.writeUInt32(H.byteLength+h),f.writeUInt32(5130562),f.writeTypedArray(H);for(let I=0;I<h;++I)f.writeUInt8(0);const z=new I;return z.files[q]=new Blob([f.getOutputData()],{type:"application/octet-stream"}),z}_setNodeTransformation(K,H,M){if(H.getPivotPoint().equalsWithEpsilon(U,t.d)||w.Tools.Warn("Pivot points are not supported in the glTF serializer"),!H.position.equalsWithEpsilon(U,t.d)){const w=q.TmpVectors.OH[0].q(H.position);M&&g(w),K.translation=w.hh()}H.Sh.equalsWithEpsilon(m,t.d)||(K.scale=H.Sh.hh());const u=H.rotationQuaternion||q.Quaternion.FromEulerAngles(H.rotation.x,H.rotation.y,H.rotation.z);u.equalsWithEpsilon(j,t.d)||(M&&X(u),K.rotation=u.normalize().hh())}_setCameraTransformation(K,H,M){if(!H.position.equalsWithEpsilon(U,t.d)){const w=q.TmpVectors.OH[0].q(H.position);M&&g(w),K.translation=w.hh()}const w=H.rotationQuaternion||q.Quaternion.FromEulerAngles(H.rotation.x,H.rotation.y,H.rotation.z);M&&X(w),this._babylonScene.useRightHandedSystem||A(w),w.equalsWithEpsilon(j,t.d)||(K.rotation=w.hh())}_listAvailableCameras(){for(const K of this._babylonScene.cameras){const H={type:K.mode===GK.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(K.name&&(H.name=K.name),"perspective"===H.type)H.perspective={aspectRatio:K.getEngine().getAspectRatio(K),yfov:K.fovMode===GK.b.FOVMODE_VERTICAL_FIXED?K.fov:K.fov*K.getEngine().getAspectRatio(K),znear:K.Ih,zfar:K.maxZ};else if("orthographic"===H.type){const M=K.orthoLeft&&K.orthoRight?.5*(K.orthoRight-K.orthoLeft):.5*K.getEngine().getRenderWidth(),q=K.orthoBottom&&K.orthoTop?.5*(K.orthoTop-K.orthoBottom):.5*K.getEngine().getRenderHeight();H.orthographic={xmag:M,ymag:q,znear:K.Ih,zfar:K.maxZ}}this._camerasMap.set(K,H)}}_exportAndAssignCameras(){const K=Array.from(this._camerasMap.values());for(const H of K){const K=this._nodesCameraMap.get(H);if(void 0!==K){this._cameras.push(H);for(const H of K)H.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const K of this._babylonScene.skeletons){if(K.bones.length<=0)continue;const H={joints:[]};this._skinMap.set(K,H)}}_exportAndAssignSkeletons(){for(const K of this._babylonScene.skeletons){if(K.bones.length<=0)continue;const H=this._skinMap.get(K);if(void 0==H)continue;const M={},q=[];let u=-1;for(let w=0;w<K.bones.length;++w){const H=K.bones[w],q=H.getIndex()??w;-1!==q&&(M[q]=H,q>u&&(u=q))}for(let K=0;K<=u;++K){const u=M[K];q.push(u.getAbsoluteInverseBindMatrix());const y=u.getTransformNode();if(null!==y){const K=this._nodeMap.get(y);y&&null!==K&&void 0!==K?H.joints.push(K):w.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else w.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const y=this._nodesSkinMap.get(H);if(H.joints.length>0&&void 0!==y){const K=64*q.length,M=new Float32Array(K/4);q.forEach(((K,H)=>{M.set(K.m,16*H)}));const w=this._bufferManager.createBufferView(M);this._accessors.push(this._bufferManager.createAccessor(w,"MAT4",5126,q.length)),H.inverseBindMatrices=this._accessors.length-1,this._skins.push(H);for(const H of y)H.skin=this._skins.length-1}}}async _exportSceneAsync(){const K={nodes:[]};if(this._babylonScene.metadata){const H=this._options.metadataSelector(this._babylonScene.metadata);H&&(K.extras=H)}const H=new Array,M=new Array,q=new Array;for(const h of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&yK(h,this._babylonScene.useRightHandedSystem)?q.push(...h.getChildren()):this._babylonScene.useRightHandedSystem?H.push(h):M.push(h);this._listAvailableCameras(),this._listAvailableSkeletons();const w=new jK(!0,!1);K.nodes.push(...await this._exportNodesAsync(M,w));const u=new jK(!1,!1);K.nodes.push(...await this._exportNodesAsync(H,u));const y=new jK(!1,!0);K.nodes.push(...await this._exportNodesAsync(q,y)),K.nodes.length&&this._scenes.push(K),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&iK._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,w.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(K){let H=this._shouldExportNodeMap.get(K);return void 0===H&&(H=this._options.shouldExportNode(K),this._shouldExportNodeMap.set(K,H)),H}async _exportNodesAsync(K,H){const M=new Array;this._exportBuffers(K,H);for(const q of K)await this._exportNodeAsync(q,M,H);return M}_collectBuffers(K,H,M,q,w){if(this._shouldExportNode(K)&&K instanceof G.c&&K.Gh){const u=K.Gh.getVertexBuffers();if(u)for(const q in u){if(!e(q))continue;const y=u[q];w.setHasVertexColorAlpha(y,K.hasVertexAlpha);const h=y._buffer,W=H.get(h)||[];H.set(h,W),-1===W.indexOf(y)&&W.push(y);const I=M.get(y)||[];M.set(y,I),-1===I.indexOf(K)&&I.push(K)}const y=K.morphTargetManager;if(y)for(let H=0;H<y.numTargets;H++){const M=y.getTarget(H),w=q.get(M)||[];q.set(M,w),-1===w.indexOf(K)&&w.push(K)}}for(const u of K.getChildren())this._collectBuffers(u,H,M,q,w)}_exportBuffers(K,H){const M=new Map,q=new Map,w=new Map;for(const h of K)this._collectBuffers(h,M,q,w,H);const u=Array.from(M.keys());for(const h of u){const K=h.getData();if(!K)throw new Error("Buffer data is not available");const w=M.get(h);if(!w)continue;const u=w[0].byteStride;if(w.some((K=>K.byteStride!==u)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const y=MK(K).slice();for(const H of w){const K=q.get(H),{byteOffset:M,byteStride:w,componentCount:u,type:h,count:W,normalized:I,kind:z}=Y(H,K);switch(z){case f.d.NormalKind:case f.d.TangentKind:(0,p.f)(y,M,w,u,h,W,I,(K=>{const H=Math.sqrt(K[0]*K[0]+K[1]*K[1]+K[2]*K[2]);if(H>0){const M=1/H;K[0]*=M,K[1]*=M,K[2]*=M}}));break;case f.d.ColorKind:{const H=K.filter((K=>K.material instanceof OK.BH||null==K.material)).length;if(0==H)break;if(H!=K.length){o.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}h==f.d.UNSIGNED_BYTE&&o.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const q=new L.CH,z=new L.Ch,G=this._babylonScene.getEngine().useExactSrgbConversions;(0,p.f)(y,M,w,u,h,W,I,(K=>{3===K.length?(q.aM(K,0),q.toLinearSpaceToRef(q,G),q.toArray(K,0)):(z.aM(K,0),z.toLinearSpaceToRef(z,G),z.toArray(K,0))}))}}}if(H.convertToRightHanded){for(const K of w){const H=q.get(K),{byteOffset:M,byteStride:w,componentCount:u,type:h,count:W,normalized:I,kind:z}=Y(K,H);switch(z){case f.d.PositionKind:case f.d.NormalKind:case f.d.TangentKind:(0,p.f)(y,M,w,u,h,W,I,(K=>{K[0]=-K[0]}))}}H.convertedToRightHandedBuffers.set(h,y)}const W=this._bufferManager.createBufferView(y,u);H.setVertexBufferView(h,W);const I=new Map;for(const H of w){const K=q.get(H),{kind:M,totalVertices:w}=Y(H,K);switch(M){case f.d.MatricesIndicesKind:case f.d.MatricesIndicesExtraKind:if(H.type==f.d.FLOAT){const K=H.getFloatData(w);null!==K&&I.set(H,K)}}}0!==I.size&&o.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const z=Array.from(I.keys());for(const M of z){const K=I.get(M);if(!K)continue;const q=K.some((K=>K>=256)),w=new(q?Uint16Array:Uint8Array)(K.length);for(let H=0;H<K.length;H++)w[H]=K[H];const u=this._bufferManager.createBufferView(w,4*(q?2:1));H.setRemappedBufferView(h,M,u)}}const y=Array.from(w.keys());for(const h of y){const K=w.get(h);if(!K)continue;const M=ZK(h,K[0],this._bufferManager,this._bufferViews,this._accessors,H.convertToRightHanded);for(const q of K)H.bindMorphDataToMesh(q,M)}}async _exportNodeAsync(K,H,M){let q=this._nodeMap.get(K);if(void 0!==q)return void(H.includes(q)||H.push(q));const w=await this._createNodeAsync(K,M);if(w){q=this._nodes.length,this._nodes.push(w),this._nodeMap.set(K,q),M.pushExportedNode(K),H.push(q);const u={name:"runtime animations",channels:[],samplers:[]},y=[];this._babylonScene.animationGroups.length||(iK._CreateMorphTargetAnimationFromMorphTargetAnimations(K,u,y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,M.convertToRightHanded,this._options.shouldExportAnimation),K.animations.length&&iK._CreateNodeAnimationFromNodeAnimations(K,u,y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,M.convertToRightHanded,this._options.shouldExportAnimation)),u.channels.length&&u.samplers.length&&this._animations.push(u),y.forEach((K=>{K.channels.length&&K.samplers.length&&this._animations.push(K)}))}const u=w?[]:H;for(const y of K.getChildren())await this._exportNodeAsync(y,u,M);w&&u.length&&(w.children=u)}async _createNodeAsync(K,H){if(!this._shouldExportNode(K))return null;const M={};if(K.name&&(M.name=K.name),K.metadata){const H=this._options.metadataSelector(K.metadata);H&&(M.extras=H)}if(K instanceof z.e&&(this._setNodeTransformation(M,K,H.convertToRightHanded),K instanceof G.c)){const w=K instanceof a.b?K.sourceMesh:K;if(w.yh&&w.yh.length>0&&(M.mesh=await this._exportMeshAsync(w,H)),K.skeleton){const H=this._skinMap.get(K.skeleton);var q;if(void 0!==H)void 0===this._nodesSkinMap.get(H)&&this._nodesSkinMap.set(H,[]),null===(q=this._nodesSkinMap.get(H))||void 0===q||q.push(M)}}if(K instanceof R.e){const q=this._camerasMap.get(K);if(q){var w;void 0===this._nodesCameraMap.get(q)&&this._nodesCameraMap.set(q,[]),this._setCameraTransformation(M,K,H.convertToRightHanded);const y=K.parent;if(null!==y&&HK(K,y)){const K=this._nodeMap.get(y);if(void 0!==K){var u;const H=this._nodes[K];return KK(M,H),null===(u=this._nodesCameraMap.get(q))||void 0===u||u.push(H),null}}null===(w=this._nodesCameraMap.get(q))||void 0===w||w.push(M)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",M,K,this._nodeMap,H.convertToRightHanded)?M:(o.e.Warn(`Not exporting node ${K.name}`),null)}_exportIndices(K,H,M,q,w,y,h,W,I){let f=K;I.mode=b(y);const z=h!==u.c.CounterClockWiseSideOrientation,G=!W.wasAddedByNoopNode&&z,a=function(K){switch(K){case u.c.TriangleFillMode:case u.c.TriangleStripDrawMode:case u.c.TriangleFanDrawMode:return!0}return!1}(y)&&G;if(a){if(y===u.c.TriangleStripDrawMode||y===u.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");I.mode=b(y);const h=H?new Uint32Array(q):new Uint16Array(q);if(K)for(let H=0;H+2<q;H+=3)h[H]=K[M+H]+w,h[H+1]=K[M+H+2]+w,h[H+2]=K[M+H+1]+w;else for(let K=0;K+2<q;K+=3)h[K]=K,h[K+1]=K+2,h[K+2]=K+1;f=h}else if(K&&0!==w){const u=H?new Uint32Array(q):new Uint16Array(q);for(let H=0;H<q;H++)u[H]=K[M+H]+w;f=u}if(f){let u=W.getIndicesAccessor(K,M,q,w,a);if(void 0===u){const y=function(K,H,M,q){if(K instanceof Uint16Array||K instanceof Uint32Array)return K;if(K instanceof Int32Array)return new Uint32Array(K.buffer,K.byteOffset,K.length);const w=K.slice(H,H+M);return q?new Uint32Array(w):new Uint16Array(w)}(f,0,q,H),h=this._bufferManager.createBufferView(y),I=H?5125:5123;this._accessors.push(this._bufferManager.createAccessor(h,"SCALAR",I,q,0)),u=this._accessors.length-1,W.setIndicesAccessor(K,M,q,w,a,u)}I.indices=u}}_exportVertexBuffer(K,H,M,q,w,u){const y=K.getKind();if(!e(y))return;if(y.startsWith("uv")&&!this._options.exportUnusedUVs&&(!H||!this._materialNeedsUVsSet.has(H)))return;let h=w.getVertexAccessor(K,M,q);if(void 0===h){const H=w.convertedToRightHandedBuffers.get(K._buffer)||K._buffer.getData(),u=y===f.d.PositionKind?function(K,H,M,q){const{byteOffset:w,byteStride:u,type:y,normalized:h}=H,W=H.getSize(),I=new Array(W).fill(1/0),f=new Array(W).fill(-1/0);return(0,p.f)(K,w+M*u,u,W,y,q*W,h,(K=>{for(let H=0;H<W;H++)I[H]=Math.min(I[H],K[H]),f[H]=Math.max(f[H],K[H])})),{min:I,max:f}}(H,K,M,q):void 0,W=(y===f.d.MatricesIndicesKind||y===f.d.MatricesIndicesExtraKind)&&K.type===f.d.FLOAT,I=W?f.d.UNSIGNED_BYTE:K.type,z=W?void 0:K.normalized,G=W?w.getRemappedBufferView(K._buffer,K):w.getVertexBufferView(K._buffer),a=K.byteOffset+M*K.byteStride;this._accessors.push(this._bufferManager.createAccessor(G,function(K,H){if(K==f.d.ColorKind)return H?"VEC4":"VEC3";switch(K){case f.d.PositionKind:case f.d.NormalKind:return"VEC3";case f.d.TangentKind:case f.d.MatricesIndicesKind:case f.d.MatricesIndicesExtraKind:case f.d.MatricesWeightsKind:case f.d.MatricesWeightsExtraKind:return"VEC4";case f.d.UVKind:case f.d.UV2Kind:case f.d.UV3Kind:case f.d.UV4Kind:case f.d.UV5Kind:case f.d.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${K}`)}(y,w.hasVertexColorAlpha(K)),I,q,a,u,z)),h=this._accessors.length-1,w.setVertexAccessor(K,M,q,h)}u.attributes[function(K){switch(K){case f.d.PositionKind:return"POSITION";case f.d.NormalKind:return"NORMAL";case f.d.TangentKind:return"TANGENT";case f.d.ColorKind:return"COLOR_0";case f.d.UVKind:return"TEXCOORD_0";case f.d.UV2Kind:return"TEXCOORD_1";case f.d.UV3Kind:return"TEXCOORD_2";case f.d.UV4Kind:return"TEXCOORD_3";case f.d.UV5Kind:return"TEXCOORD_4";case f.d.UV6Kind:return"TEXCOORD_5";case f.d.MatricesIndicesKind:return"JOINTS_0";case f.d.MatricesIndicesExtraKind:return"JOINTS_1";case f.d.MatricesWeightsKind:return"WEIGHTS_0";case f.d.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${K}`)}(y)]=h}async _exportMaterialAsync(K,H,M,q){let w=this._materialMap.get(K);if(void 0===w){const q=H&&Object.keys(H).some((K=>K.startsWith("uv")));if((K=K instanceof aK.b?K.ih[M.materialIndex]:K)instanceof vK.b)w=await this._materialExporter.exportPBRMaterialAsync(K,"image/png",q);else{if(!(K instanceof OK.BH))return void o.e.Warn(`Unsupported material '${K.name}' with type ${K.getClassName()}`);w=await this._materialExporter.exportStandardMaterialAsync(K,"image/png",q)}this._materialMap.set(K,w)}q.material=w}async _exportMeshAsync(K,H){var M;let q=H.getMesh(K);if(void 0!==q)return q;const w={primitives:[]};q=this._meshes.length,this._meshes.push(w),H.setMesh(K,q);const y=K.isUnIndexed?null:K.ah(),h=null===(M=K.Gh)||void 0===M?void 0:M.getVertexBuffers(),W=H.getMorphTargetsFromMesh(K),I=K instanceof EK.b,f=K instanceof UK,z=K.yh;if(h&&z&&z.length>0)for(const v of z){const M={attributes:{}},q=v.pK()||this._babylonScene.defaultMaterial;if(f){var G,a;const H={name:q.name},w=K,u=L.CH.White(),y=(null===(G=w.material)||void 0===G?void 0:G.alpha)??1,h=(null===(a=w.greasedLineMaterial)||void 0===a?void 0:a.color)??u;(!h.equalsWithEpsilon(u,t.d)||y<1)&&(H.pbrMetallicRoughness={baseColorFactor:[...h.hh(),y]}),this._materials.push(H),M.material=this._materials.length-1}else if(I){const H={name:q.name},w=K;(!w.color.equalsWithEpsilon(L.CH.White(),t.d)||w.alpha<1)&&(H.pbrMetallicRoughness={baseColorFactor:[...w.color.hh(),w.alpha]}),this._materials.push(H),M.material=this._materials.length-1}else await this._exportMaterialAsync(q,h,v,M);const z=I||f?u.c.LineListDrawMode:K.overrideRenderingFillMode??q.fillMode,O=q._getEffectiveOrientation(K);this._exportIndices(y,y?(0,p.c)(y,v.indexCount,v.indexStart,v.verticesStart):v.verticesCount>65535,y?v.indexStart:v.verticesStart,y?v.indexCount:v.verticesCount,-v.verticesStart,z,O,H,M);for(const K of Object.values(h))this._exportVertexBuffer(K,q,v.verticesStart,v.verticesCount,H,M);if(W){M.targets=[];for(const K of W)M.targets.push(K.attributes)}w.primitives.push(M),this._extensionsPostExportMeshPrimitive(M)}if(W){w.weights=[],w.extras||(w.extras={}),w.extras.targetNames=[];for(const K of W)w.weights.push(K.influence),w.extras.targetNames.push(K.name)}return q}}mK._ExtensionNames=new Array,mK._ExtensionFactories={};class FK{static async GLTFAsync(K,H,M){M&&M.exportWithoutWaitingForScene||await K.whenReadyAsync();const q=new mK(K,M),w=await q.generateGLTFAsync(H.replace(/\.[^/.]+$/,""));return q.dispose(),w}static async GLBAsync(K,H,M){M&&M.exportWithoutWaitingForScene||await K.whenReadyAsync();const q=new mK(K,M),w=await q.generateGLBAsync(H.replace(/\.[^/.]+$/,""));return q.dispose(),w}}M(11855);const YK="EXT_mesh_gpu_instancing";class rK{constructor(K){this.name=YK,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(K,H,M,w,u,y){return await new Promise((K=>{if(H&&M instanceof BK.b&&M.hasThinInstances&&this._exporter){this._wasUsed=!0;const K=q.OH.Zero(),w=q.Quaternion.Identity(),h=q.OH.One(),W=M.thinInstanceGetWorldMatrices(),I=q.TmpVectors.OH[2],f=q.TmpVectors.Quaternion[1],z=q.TmpVectors.OH[3];let G=!1,a=!1,v=!1;const O=new Float32Array(3*M.Zh),L=new Float32Array(4*M.Zh),S=new Float32Array(3*M.Zh);let B=0;for(const H of W)H.decompose(z,f,I),u&&(g(I),X(f)),O.set(I.hh(),3*B),L.set(f.normalize().hh(),4*B),S.set(z.hh(),3*B),G=G||!I.equalsWithEpsilon(K),a=a||!f.equalsWithEpsilon(w),v=v||!z.equalsWithEpsilon(h),B++;const C={attributes:{}};G&&(C.attributes.TRANSLATION=this._buildAccessor(O,"VEC3",M.Zh,y)),a&&(C.attributes.ROTATION=this._buildAccessor(L,"VEC4",M.Zh,y)),v&&(C.attributes.SCALE=this._buildAccessor(S,"VEC3",M.Zh,y)),H.extensions=H.extensions||{},H.extensions[YK]=C}K(H)}))}_buildAccessor(K,H,M,q){const w=q.createBufferView(K),u=q.createAccessor(w,H,5126,M);return this._exporter._accessors.push(u),this._exporter._accessors.length-1}}mK.RegisterExtension(YK,(K=>new rK(K)));var eK=M(11863),bK=M(11877),PK=M(11886),gK=M(11893);function XK(K){return K===PK.e.PositionKind?"POSITION":K===PK.e.NormalKind?"NORMAL":K===PK.e.ColorKind?"COLOR":K.startsWith(PK.e.UVKind)?"TEX_COORD":"GENERIC"}const AK={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class KH extends eK.e{static get DefaultAvailable(){return(0,eK.k)(KH.DefaultConfiguration)}static get Default(){return KH._Default??(KH._Default=new KH),KH._Default}static ResetDefault(K){KH._Default&&(K||KH._Default.dispose(),KH._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(K,H){return{module:await(H||DracoEncoderModule)({wasmBinary:K})}}_getWorkerContent(){return`${bK.k}(${bK.n})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:KH.DefaultConfiguration)}async _encodeAsync(K,H,M){const q=M?(0,gK.c)(AK,M):AK;if(this._workerPoolPromise){const M=await this._workerPoolPromise;return await new Promise(((w,u)=>{M.push(((M,y)=>{const h=K=>{M.removeEventListener("error",h),M.removeEventListener("message",W),u(K),y()},W=K=>{"encodeMeshDone"===K.data.id&&(M.removeEventListener("error",h),M.removeEventListener("message",W),w(K.data.encodedMeshData),y())};M.addEventListener("error",h),M.addEventListener("message",W);const I=[];for(const H of K)I.push(H.data.buffer);H&&I.push(H.buffer),M.postMessage({id:"encodeMesh",attributes:K,indices:H,options:q},I)}))}))}if(this._modulePromise){const M=await this._modulePromise;return(0,bK.k)(M.module,K,H,q)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(K,H){if(0==K.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");K instanceof BK.b&&K.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===H||void 0===H?void 0:H.method)&&(o.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),H.method="MESH_SEQUENTIAL_ENCODING");const M=function(K){let H=K.ah(void 0,!0);return!H||H instanceof Uint32Array||H instanceof Uint16Array||(H=((0,p.c)(H,H.length)?Uint32Array:Uint16Array).from(H)),H}(K),q=function(K,H){const M=[];for(const q of K.getVerticesDataKinds()){if(null!==H&&void 0!==H&&H.includes(q)){if(q===PK.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const w=K.getVertexBuffer(q),u=w.getSize(),y=(0,p.n)(w.getData(),u,w.type,w.byteOffset,w.byteStride,w.normalized,K.getTotalVertices(),!0);M.push({kind:q,dracoName:XK(q),size:u,data:y})}return M}(K,null===H||void 0===H?void 0:H.excludedAttributes);return await this._encodeAsync(q,M,H)}}KH.DefaultConfiguration={wasmUrl:`${w.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${w.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${w.Tools._DefaultCdnUrl}/draco_encoder.js`},KH._Default=null;const HH="KHR_draco_mesh_compression";class MH{get wasUsed(){return this._wasUsed}constructor(K){this.name=HH,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===K.options.meshCompressionMethod&&KH.DefaultAvailable}dispose(){}postExportMeshPrimitive(K,H,M){if(!this.enabled)return;if(4!==K.mode&&5!==K.mode)return void o.e.Warn("Cannot compress primitive with mode "+K.mode+".");const q=[],w=[];let u=null;if(void 0!==K.indices){const y=M[K.indices],h=H.getBufferView(y);u=H.getData(h).slice(),q.push(h),w.push(y)}const y=[];for(const[f,z]of Object.entries(K.attributes)){const K=M[z],u=H.getBufferView(K),W=r(K.type),I=(0,p.n)(H.getData(u),W,K.componentType,K.byteOffset||0,u.byteStride||(0,p.j)(K.componentType)*W,K.normalized||!1,K.count,!0);y.push({kind:f,dracoName:(h=f,"POSITION"===h?"POSITION":"NORMAL"===h?"NORMAL":h.startsWith("COLOR")?"COLOR":h.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:r(K.type),data:I}),q.push(u),w.push(K)}var h;const W={method:K.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},I=KH.Default._encodeAsync(y,u,W).then((M=>{if(!M)return void o.e.Error("Draco encoding failed for primitive.");const u={bufferView:-1,attributes:M.attributeIds},y=H.createBufferView(M.data);H.setBufferView(u,y);for(const K of q)this._bufferViewsUsed.add(K);for(const K of w)this._accessorsUsed.add(K);K.extensions||(K.extensions={}),K.extensions[HH]=u})).catch((K=>{o.e.Error("Draco encoding failed for primitive: "+K)}));this._encodePromises.push(I),this._wasUsed=!0}async preGenerateBinaryAsync(K){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((H=>{K.getPropertiesWithBufferView(H).every((K=>this._accessorsUsed.has(K)))&&K.removeBufferView(H)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}mK.RegisterExtension(HH,(K=>new MH(K)));var qH=M(11898);const wH="KHR_lights_punctual",uH={name:"",color:[1,1,1],Eh:1,range:Number.MAX_VALUE},yH={innerConeAngle:0,outerConeAngle:Math.PI/4},hH=q.OH.Backward();class WH{constructor(K){this.name=wH,this.enabled=!0,this.required=!1,this._exporter=K}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[wH]=this._lights}async postExportNodeAsync(K,H,M,w,u){return await new Promise((y=>{if(!(M instanceof CK.e))return void y(H);const h=M.getTypeID()==CK.e.LIGHTTYPEID_POINTLIGHT?"point":M.getTypeID()==CK.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":M.getTypeID()==CK.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!h||!(M instanceof qH.b))return o.e.Warn(`${K}: Light ${M.name} is not supported in ${wH}`),void y(H);if(M.falloffType!==CK.e.FALLOFF_GLTF&&o.e.Warn(`${K}: Light falloff for ${M.name} does not match the ${wH} specification!`),!M.position.equalsToFloats(0,0,0)){const K=q.TmpVectors.OH[0].q(M.position);u&&g(K),H.translation=K.hh()}if("point"!==h){const K=M.direction.normalizeToRef(q.TmpVectors.OH[0]);u&&g(K);const w=q.Quaternion.FromUnitVectorsToRef(hH,K,q.TmpVectors.Quaternion[0]);q.Quaternion.IsIdentity(w)||(H.rotation=w.hh())}const W={type:h,name:M.name,color:M.sh.hh(),Eh:M.Eh,range:M.range};if(qK(W,uH),"spot"===h){const K=M;W.spot={innerConeAngle:K.innerAngle/2,outerConeAngle:K.angle/2},qK(W.spot,yH)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(W);const I={eq:this._lights.lights.length-1},f=M.parent;if(f&&HK(M,f)){const K=w.get(f);if(K){const M=this._exporter._nodes[K];return KK(H,M),M.extensions||(M.extensions={}),M.extensions[wH]=I,void y(null)}}H.extensions||(H.extensions={}),H.extensions[wH]=I,y(H)}))}}mK.RegisterExtension(wH,(K=>new WH(K)));var IH=M(11792);const fH="KHR_materials_anisotropy";class zH{constructor(K){this.name=fH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,H,M){const q=[];return M instanceof IH.d&&M.anisotropy.isEnabled&&!M.anisotropy.legacy?(M.anisotropy.texture&&q.push(M.anisotropy.texture),q):[]}postExportMaterialAsync(K,H,M){return new Promise((K=>{if(M instanceof IH.d){if(!M.anisotropy.isEnabled||M.anisotropy.legacy)return void K(H);this._wasUsed=!0,H.extensions=H.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(M.anisotropy.texture),w={anisotropyStrength:M.anisotropy.Eh,anisotropyRotation:M.anisotropy.angle,anisotropyTexture:q??void 0};null!==w.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(M),H.extensions[fH]=w}K(H)}))}}mK.RegisterExtension(fH,(K=>new zH(K)));const GH="KHR_materials_clearcoat";class aH{constructor(K){this.name=GH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,H,M){const q=[];return M instanceof IH.d&&M.clearCoat.isEnabled?(M.clearCoat.texture&&q.push(M.clearCoat.texture),!M.clearCoat.useRoughnessFromMainTexture&&M.clearCoat.textureRoughness&&q.push(M.clearCoat.textureRoughness),M.clearCoat.bumpTexture&&q.push(M.clearCoat.bumpTexture),q):[]}postExportMaterialAsync(K,H,M){return new Promise((K=>{if(M instanceof IH.d){if(!M.clearCoat.isEnabled)return void K(H);this._wasUsed=!0,H.extensions=H.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(M.clearCoat.texture);let u;u=M.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(M.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(M.clearCoat.textureRoughness),M.clearCoat.isTintEnabled&&w.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${M.name}`),M.clearCoat.remapF0OnInterfaceChange&&w.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${M.name}`);const y=this._exporter._materialExporter.getTextureInfo(M.clearCoat.bumpTexture),h={clearcoatFactor:M.clearCoat.Eh,clearcoatTexture:q??void 0,clearcoatRoughnessFactor:M.clearCoat.roughness,clearcoatRoughnessTexture:u??void 0,clearcoatNormalTexture:y??void 0};null===h.clearcoatTexture&&null===h.clearcoatRoughnessTexture&&null===h.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(M),H.extensions[GH]=h}K(H)}))}}mK.RegisterExtension(GH,(K=>new aH(K)));const vH="KHR_materials_diffuse_transmission";function OH(K,H){const M=H.subSurface;let q=null;return M.translucencyIntensityTexture?q=M.translucencyIntensityTexture:M.thicknessTexture&&M.useMaskFromThicknessTexture&&(q=M.thicknessTexture),q&&!M.useGltfStyleTextures?(o.e.Warn(`${K}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${H.name}`,1),null):q}class LH{constructor(K){this.name=vH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,H,M){const q=[];if(M instanceof vK.b&&this._isExtensionEnabled(M)){const H=OH(K,M);return H&&q.push(H),M.subSurface.translucencyColorTexture&&q.push(M.subSurface.translucencyColorTexture),q}return q}_isExtensionEnabled(K){if(K.unlit)return!1;const H=K.subSurface;return!!H.isTranslucencyEnabled&&(!K.unlit&&!H.useAlbedoToTintTranslucency&&H.useGltfStyleTextures&&1===H.volumeIndexOfRefraction&&0===H.minimumThickness&&0===H.maximumThickness)}postExportMaterialAsync(K,H,M){return new Promise((q=>{if(M instanceof vK.b&&this._isExtensionEnabled(M)){this._wasUsed=!0;const q=M.subSurface,w=OH(K,M),u=0==q.translucencyIntensity?void 0:q.translucencyIntensity,y=this._exporter._materialExporter.getTextureInfo(w)??void 0,h=!q.translucencyColor||q.translucencyColor.equalsFloats(1,1,1)?void 0:q.translucencyColor.hh(),W=this._exporter._materialExporter.getTextureInfo(q.translucencyColorTexture)??void 0,I={diffuseTransmissionFactor:u,diffuseTransmissionTexture:y,diffuseTransmissionColorFactor:h,diffuseTransmissionColorTexture:W};(y||W)&&this._exporter._materialNeedsUVsSet.add(M),H.extensions=H.extensions||{},H.extensions[vH]=I}q(H)}))}}mK.RegisterExtension(vH,(K=>new LH(K)));const SH="KHR_materials_dispersion";class BH{constructor(){this.name=SH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(K){if(K.unlit)return!1;const H=K.subSurface;return!(!H.isRefractionEnabled&&!H.isDispersionEnabled)}postExportMaterialAsync(K,H,M){return new Promise((K=>{if(M instanceof vK.b&&this._isExtensionEnabled(M)){this._wasUsed=!0;const K={dispersion:M.subSurface.dispersion};H.extensions=H.extensions||{},H.extensions[SH]=K}K(H)}))}}mK.RegisterExtension(SH,(()=>new BH));const CH="KHR_materials_emissive_strength";class iH{constructor(){this.name=CH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(K,H,M){return await new Promise((K=>{if(!(M instanceof vK.b))return K(H);const q=M.emissiveColor.hh(),w=Math.max(...q);if(w>1){this._wasUsed=!0,H.extensions||(H.extensions={});const K={emissiveStrength:w},q=M.emissiveColor.scale(1/K.emissiveStrength);H.emissiveFactor=q.hh(),H.extensions[CH]=K}return K(H)}))}}mK.RegisterExtension(CH,(K=>new iH));const ZH="KHR_materials_ior";class EH{constructor(){this.name=ZH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(K){return!K.unlit&&(void 0!=K.indexOfRefraction&&1.5!=K.indexOfRefraction)}postExportMaterialAsync(K,H,M){return new Promise((K=>{if(M instanceof vK.b&&this._isExtensionEnabled(M)){this._wasUsed=!0;const K={ior:M.indexOfRefraction};H.extensions=H.extensions||{},H.extensions[ZH]=K}K(H)}))}}mK.RegisterExtension(ZH,(K=>new EH));const lH="KHR_materials_iridescence";class sH{constructor(K){this.name=lH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,H,M){const q=[];return M instanceof IH.d&&M.iridescence.isEnabled?(M.iridescence.texture&&q.push(M.iridescence.texture),M.iridescence.thicknessTexture&&M.iridescence.thicknessTexture!==M.iridescence.texture&&q.push(M.iridescence.thicknessTexture),q):[]}postExportMaterialAsync(K,H,M){return new Promise((K=>{if(M instanceof IH.d){if(!M.iridescence.isEnabled)return void K(H);this._wasUsed=!0,H.extensions=H.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(M.iridescence.texture),w=this._exporter._materialExporter.getTextureInfo(M.iridescence.thicknessTexture),u={iridescenceFactor:M.iridescence.Eh,iridescenceIor:M.iridescence.indexOfRefraction,iridescenceThicknessMinimum:M.iridescence.minimumThickness,iridescenceThicknessMaximum:M.iridescence.maximumThickness,iridescenceTexture:q??void 0,iridescenceThicknessTexture:w??void 0};null===u.iridescenceTexture&&null===u.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(M),H.extensions[lH]=u}K(H)}))}}mK.RegisterExtension(lH,(K=>new sH(K)));const DH="KHR_materials_sheen";class VH{constructor(K){this.name=DH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,H,M){return M instanceof vK.b&&M.sheen.isEnabled&&M.sheen.texture?[M.sheen.texture]:[]}async postExportMaterialAsync(K,H,M){return await new Promise((K=>{if(M instanceof vK.b){if(!M.sheen.isEnabled)return void K(H);this._wasUsed=!0,null==H.extensions&&(H.extensions={});const q={sheenColorFactor:M.sheen.color.hh(),sheenRoughnessFactor:M.sheen.roughness??0};null===q.sheenColorTexture&&null===q.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(M),M.sheen.texture&&(q.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(M.sheen.texture)??void 0),M.sheen.textureRoughness&&!M.sheen.useRoughnessFromMainTexture?q.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(M.sheen.textureRoughness)??void 0:M.sheen.texture&&M.sheen.useRoughnessFromMainTexture&&(q.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(M.sheen.texture)??void 0),H.extensions[DH]=q}K(H)}))}}mK.RegisterExtension(DH,(K=>new VH(K)));const nH="KHR_materials_specular";class cH{constructor(K){this.name=nH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,H,M){const q=[];return M instanceof vK.b&&this._isExtensionEnabled(M)?(M.metallicReflectanceTexture&&q.push(M.metallicReflectanceTexture),M.reflectanceTexture&&q.push(M.reflectanceTexture),q):q}_isExtensionEnabled(K){return!K.unlit&&(void 0!=K.metallicF0Factor&&1!=K.metallicF0Factor||void 0!=K.metallicReflectanceColor&&!K.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(K))}_hasTexturesExtension(K){return null!=K.metallicReflectanceTexture||null!=K.reflectanceTexture}postExportMaterialAsync(K,H,M){return new Promise((K=>{if(M instanceof vK.b&&this._isExtensionEnabled(M)){this._wasUsed=!0,H.extensions=H.extensions||{};const K=this._exporter._materialExporter.getTextureInfo(M.metallicReflectanceTexture)??void 0,q=this._exporter._materialExporter.getTextureInfo(M.reflectanceTexture)??void 0,w={specularFactor:1==M.metallicF0Factor?void 0:M.metallicF0Factor,specularTexture:K,specularColorFactor:M.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:M.metallicReflectanceColor.hh(),specularColorTexture:q};this._hasTexturesExtension(M)&&this._exporter._materialNeedsUVsSet.add(M),H.extensions[nH]=w}K(H)}))}}mK.RegisterExtension(nH,(K=>new cH(K)));const kH="KHR_materials_transmission";class TH{constructor(K){this.name=kH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,H,M){const q=[];return M instanceof vK.b&&this._isExtensionEnabled(M)?(M.subSurface.thicknessTexture&&q.push(M.subSurface.thicknessTexture),q):q}_isExtensionEnabled(K){if(K.unlit)return!1;const H=K.subSurface;return H.isRefractionEnabled&&void 0!=H.refractionIntensity&&0!=H.refractionIntensity||this._hasTexturesExtension(K)}_hasTexturesExtension(K){return null!=K.subSurface.refractionIntensityTexture}async postExportMaterialAsync(K,H,M){if(M instanceof vK.b&&this._isExtensionEnabled(M)){this._wasUsed=!0;const q=M.subSurface,w={transmissionFactor:0===q.refractionIntensity?void 0:q.refractionIntensity};if(this._hasTexturesExtension(M)&&this._exporter._materialNeedsUVsSet.add(M),q.refractionIntensityTexture)if(q.useGltfStyleTextures){const K=await this._exporter._materialExporter.exportTextureAsync(q.refractionIntensityTexture,"image/png");K&&(w.transmissionTexture=K)}else o.e.Warn(`${K}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);H.extensions||(H.extensions={}),H.extensions[kH]=w}return H}}mK.RegisterExtension(kH,(K=>new TH(K)));const dH="KHR_materials_unlit";class xH{constructor(){this.name=dH,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(K,H,M){return new Promise((K=>{let q=!1;M instanceof vK.b?q=M.unlit:M instanceof OK.BH&&(q=M.disableLighting),q&&(this._wasUsed=!0,null==H.extensions&&(H.extensions={}),H.extensions[dH]={}),K(H)}))}}mK.RegisterExtension(dH,(()=>new xH));const QH="KHR_materials_volume";class JH{constructor(K){this.name=QH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,H,M){const q=[];return M instanceof vK.b&&this._isExtensionEnabled(M)?(M.subSurface.thicknessTexture&&q.push(M.subSurface.thicknessTexture),q):q}_isExtensionEnabled(K){if(K.unlit)return!1;const H=K.subSurface;return!(!H.isRefractionEnabled&&!H.isTranslucencyEnabled)&&(void 0!=H.maximumThickness&&0!=H.maximumThickness||void 0!=H.tintColorAtDistance&&H.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=H.tintColor&&H.tintColor!=L.CH.White()||this._hasTexturesExtension(K))}_hasTexturesExtension(K){return null!=K.subSurface.thicknessTexture}postExportMaterialAsync(K,H,M){return new Promise((K=>{if(M instanceof vK.b&&this._isExtensionEnabled(M)){this._wasUsed=!0;const K=M.subSurface,q={thicknessFactor:0==K.maximumThickness?void 0:K.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(K.thicknessTexture)??void 0,attenuationDistance:K.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:K.tintColorAtDistance,attenuationColor:K.tintColor.equalsFloats(1,1,1)?void 0:K.tintColor.hh()};this._hasTexturesExtension(M)&&this._exporter._materialNeedsUVsSet.add(M),H.extensions=H.extensions||{},H.extensions[QH]=q}K(H)}))}}mK.RegisterExtension(QH,(K=>new JH(K)));const NH="EXT_materials_diffuse_roughness";class pH{constructor(K){this.name=NH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,H,M){const q=[];return M instanceof IH.d&&M._baseDiffuseRoughness?(M._baseDiffuseRoughnessTexture&&q.push(M._baseDiffuseRoughnessTexture),q):[]}postExportMaterialAsync(K,H,M){return new Promise((K=>{if(M instanceof IH.d){if(!M._baseDiffuseRoughness)return void K(H);this._wasUsed=!0,H.extensions=H.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(M._baseDiffuseRoughnessTexture),w={diffuseRoughnessFactor:M._baseDiffuseRoughness,diffuseRoughnessTexture:q??void 0};null!==w.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(M),H.extensions[NH]=w}K(H)}))}}mK.RegisterExtension(NH,(K=>new pH(K)));const oH="KHR_texture_transform";class RH{constructor(){this.name=oH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(K,H,M){if(M.sK()||w.Tools.Warn(`${K}: /*@__KEY__*/"scene" is not defined for Babylon texture ${M.name}!`),(0!==M.uAng||0!==M.vAng)&&(w.Tools.Warn(`${K}: Texture ${M.name} with rotation in the u or v axis is not supported in glTF.`),0!==M.uRotationCenter||0!==M.vRotationCenter))return;const q={};let u=!1;if(0===M.uOffset&&0===M.vOffset||(q.offset=[M.uOffset,M.vOffset],u=!0),1===M.uScale&&1===M.vScale||(q.scale=[M.uScale,M.vScale],u=!0),0!==M.wAng){if(0!==M.uRotationCenter||0!==M.vRotationCenter){if(M.homogeneousRotationInUVTransform&&M.uScale!==M.vScale)return void w.Tools.Warn(`${K}: Texture ${M.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${oH}.`);w.Tools.Warn(`${K}: Texture ${M.name} with non-origin rotation center will be exported using an adjusted offset with ${oH}.`),q.offset=function(K){const{uOffset:H,vOffset:M,uRotationCenter:q,vRotationCenter:w,uScale:u,vScale:y,wAng:h}=K,W=Math.cos(h),I=Math.sin(h),f=q*u,z=w*y;return[H+(f*(1-W)+z*I),M+(z*(1-W)-f*I)]}(M)}q.rotation=-M.wAng,u=!0}0!==M.coordinatesIndex&&(q.texCoord=M.coordinatesIndex,u=!0),u&&(this._wasUsed=!0,H.extensions||(H.extensions={}),H.extensions[oH]=q)}}mK.RegisterExtension(oH,(()=>new RH));class tH{static CreateSTL(K){let H=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",w=arguments.length>3&&void 0!==arguments[3]&&arguments[3],u=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],h=arguments.length>6&&void 0!==arguments[6]&&arguments[6],W=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const I=function(K,H,M){const w=[3*K[M],3*K[M+1],3*K[M+2]],u=[new q.OH(H[w[0]],H[w[0]+2],H[w[0]+1]),new q.OH(H[w[1]],H[w[1]+2],H[w[1]+1]),new q.OH(H[w[2]],H[w[2]+2],H[w[2]+1])],y=u[0].LH(u[1]),h=u[2].LH(u[1]);return{v:u,n:q.OH.Cross(h,y).normalize()}},z=function(K,H,M,q){return H=G(K,H,M.x,q),H=G(K,H,M.y,q),G(K,H,M.z,q)},G=function(K,H,M,q){return K.setFloat32(H,M,q),H+4},v=function(K){if(h){let H=K;K instanceof a.b&&(H=K.sourceMesh);const M=H.getVerticesData(f.d.PositionKind,!0,!0);if(!M)return[];const w=q.OH.Zero();let u;for(u=0;u<M.length;u+=3)q.OH.TransformCoordinatesFromFloatsToRef(M[u],M[u+1],M[u+2],K.zh(!0),w).toArray(M,u);return M}return K.getVerticesData(f.d.PositionKind)||[]};h&&(y=!0);let O="",L=0,S=0;if(w){for(let M=0;M<K.length;M++){const H=K[M].ah();L+=H?H.length/3:0}const H=new ArrayBuffer(84+50*L);O=new DataView(H),S+=80,O.setUint32(S,L,u),S+=4}else W||(O="solid stlmesh\r\n");for(let q=0;q<K.length;q++){const H=K[q];!w&&W&&(O+="solid "+H.name+"\r\n"),!y&&H instanceof BK.b&&H.bakeCurrentTransformIntoVertices();const M=v(H),h=H.ah()||[];for(let K=0;K<h.length;K+=3){const H=I(h,M,K);w?(S=z(O,S,H.n,u),S=z(O,S,H.v[0],u),S=z(O,S,H.v[1],u),S=z(O,S,H.v[2],u),S+=2):(O+="\tfacet normal "+H.n.x+" "+H.n.y+" "+H.n.z+"\r\n",O+="\t\touter loop\r\n",O+="\t\t\tvertex "+H.v[0].x+" "+H.v[0].y+" "+H.v[0].z+"\r\n",O+="\t\t\tvertex "+H.v[1].x+" "+H.v[1].y+" "+H.v[1].z+"\r\n",O+="\t\t\tvertex "+H.v[2].x+" "+H.v[2].y+" "+H.v[2].z+"\r\n",O+="\t\tendloop\r\n",O+="\tendfacet\r\n")}!w&&W&&(O+="endsolid "+name+"\r\n")}if(w||W||(O+="endsolid stlmesh"),H){const K=document.createElement("a"),H=new Blob([O],{type:"application/octet-stream"});K.href=window.URL.createObjectURL(H),K.download=M+".stl",K.click()}return O}}function UH(K,H){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const q=[];for(let w=0;w<K.length/M;w++){const u=K[w*M],y=K[w*M+1],h=K[w*M+2];q.push(`(${u.toPrecision(H.precision)}, ${y.toPrecision(H.precision)}, ${h.toPrecision(H.precision)})`)}return q.join(", ")}function jH(K,H){const M=[];for(let q=0;q<K.length/2;q++){const w=K[2*q],u=K[2*q+1];M.push(`(${w.toPrecision(H.precision)}, ${(1-u).toPrecision(H.precision)})`)}return M.join(", ")}function mH(K,H){const M=K.getVerticesData(f.d.PositionKind),q=K.getVerticesData(f.d.NormalKind);if(M&&q)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(K){var H;const M=null!==(H=K.ah())&&void 0!==H&&H.length?K.getTotalIndices():K.getTotalVertices();return Array(M/3).fill(3).join(", ")}(K)}]\n\t\tint[] faceVertexIndices = [${function(K){const H=K.ah(),M=[];if(null!==H)for(let q=0;q<H.length;q++)M.push(H[q]);else{const H=K.getTotalVertices();for(let K=0;K<H;K++)M.push(K)}return M.join(", ")}(K)}]\n\t\tnormal3f[] normals = [${UH(q,H)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${UH(M,H)}]\n        ${function(K,H){let M="";for(let w=0;w<4;w++){const q=w>0?w:"",u=K.getVerticesData(f.d.UVKind+(q?q+1:""));u&&(M+=`\n\t\ttexCoord2f[] primvars:st${q} = [${jH(u,H)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const q=K.getVerticesData(f.d.ColorKind);return q&&(M+=`\n\tcolor3f[] primvars:displayColor = [${UH(q,H,q.length/K.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),M}(K,H)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function FH(K,H){return`\n        def "Geometry"\n        {\n        ${mH(K,H)}\n        }\n        `}function YH(K){let H='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return H+=K,fflate.strToU8(H)}function rH(K){const H=K.m;return`( ${eH(H,0)}, ${eH(H,4)}, ${eH(H,8)}, ${eH(H,12)} )`}function eH(K,H){return`(${K[H+0]}, ${K[H+1]}, ${K[H+2]}, ${K[H+3]})`}function bH(K){const H="Object_"+K.uniqueId,M=function(K){const H=K.getWorldMatrix().clone(),M=K.sK().useRightHandedSystem;if(!M){let q=K.parent;for(;q;){if(yK(q,M)){H.multiplyToRef(q.getWorldMatrix().invert(),H);break}q=q.parent}}return H.determinant()<0&&w.Tools.Warn(`Exporting mesh ${K.name} with negative scale. Result may look incorrect in destination engine.`),H}(K),q=rH(M);return`def Xform "${H}" (\n\tprepend references = @./geometries/Geometry_${K.Gh.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${q}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${K.material.uniqueId}>\n}\n\n`}function PH(K){switch(K){case l.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case l.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case l.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function gH(K){return`(${K.x}, ${K.y})`}function XH(K){return`(${K.r}, ${K.g}, ${K.b})`}function AH(K,H,M,w,u,y){const h=K.getInternalTexture().uniqueId+"_"+K.invertY;u[h]=K;const W=K.coordinatesIndex>0?"st"+K.coordinatesIndex:"st",I=new q.Vector2(K.uScale,K.vScale),f=new q.Vector2(K.uOffset,K.vOffset),z=K.wAng,G=Math.sin(z),a=Math.cos(z);return f.y=1-f.y-I.y,f.x+=G*I.x,f.y+=(1-a)*I.y,`\n    def Shader "PrimvarReader_${M}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${W}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${M}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${H.uniqueId}/PrimvarReader_${M}.outputs:result>\n        float inputs:rotation = ${(z*(180/Math.PI)).toFixed(y.precision)}\n        float2 inputs:scale = ${gH(I)}\n        float2 inputs:translation = ${gH(f)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${K.uniqueId}_${M}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${h}.png@\n        float2 inputs:st.connect = </Materials/Material_${H.uniqueId}/Transform2d_${M}.outputs:result>\n        ${w?"float4 inputs:scale = "+function(K){return`(${K.r}, ${K.g}, ${K.b}, 1.0)`}(w):""}\n        token inputs:sourceColorSpace = "${K.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${PH(K.wrapU)}"\n        token inputs:wrapT = "${PH(K.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${H.needAlphaBlending()?"float outputs:a":""}\n    }`}function KM(K,H,M){const q="\t\t\t",w=[],u=[],{diffuseMap:y,sh:h,alphaCutOff:W,emissiveMap:I,emissive:f,normalMap:z,roughnessMap:G,roughnessChannel:a,roughness:v,metalnessMap:O,metalnessChannel:S,metalness:B,aoMap:C,aoMapChannel:i,aoMapIntensity:Z,alphaMap:E,ior:l,clearCoatEnabled:s,clearCoat:D,clearCoatMap:V,clearCoatRoughness:n,clearCoatRoughnessMap:c}=function(K){const H={diffuseMap:null,sh:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return K instanceof OK.BH?{...H,diffuseMap:K.diffuseTexture,sh:K.diffuseColor,alphaCutOff:K.alphaCutOff,emissiveMap:K.emissiveTexture,emissive:K.emissiveColor,roughness:1,alphaMap:K.opacityTexture}:K instanceof IH.d?{...H,diffuseMap:K._albedoTexture,sh:K._albedoColor,alphaCutOff:K._alphaCutOff,emissiveMap:K._emissiveTexture,emissive:K._emissiveColor,normalMap:K._bumpTexture,roughnessMap:K._metallicTexture,roughnessChannel:K._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:K._roughness??1,metalnessMap:K._metallicTexture,metalnessChannel:K._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:K._metallic??0,aoMap:K._ambientTexture,aoMapChannel:K._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:K._ambientTextureStrength,alphaMap:K._opacityTexture,ior:K.subSurface.indexOfRefraction,clearCoatEnabled:K.clearCoat.isEnabled,clearCoat:K.clearCoat.Eh,clearCoatMap:K.clearCoat.texture,clearCoatRoughness:K.clearCoat.roughness,clearCoatRoughnessMap:K.clearCoat.useRoughnessFromMainTexture?K.clearCoat.texture:K.clearCoat.textureRoughness}:H}(K);return null!==y?(w.push(`${q}color3f inputs:diffuseColor.connect = </Materials/Material_${K.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:rgb>`),K.needAlphaBlending()?w.push(`${q}float inputs:opacity.connect = </Materials/Material_${K.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:a>`):K.needAlphaTesting()&&(w.push(`${q}float inputs:opacity.connect = </Materials/Material_${K.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:a>`),w.push(`${q}float inputs:opacityThreshold = ${W}`)),u.push(AH(y,K,"diffuse",h,H,M))):w.push(`${q}color3f inputs:diffuseColor = ${XH(h||L.CH.White())}`),null!==I?(w.push(`${q}color3f inputs:emissiveColor.connect = </Materials/Material_${K.uniqueId}/Texture_${I.uniqueId}_emissive.outputs:rgb>`),u.push(AH(I,K,"emissive",f,H,M))):f&&f.toLuminance()>0&&w.push(`${q}color3f inputs:emissiveColor = ${XH(f)}`),null!==z&&(w.push(`${q}normal3f inputs:normal.connect = </Materials/Material_${K.uniqueId}/Texture_${z.uniqueId}_normal.outputs:rgb>`),u.push(AH(z,K,"normal",null,H,M))),null!==C&&(w.push(`${q}float inputs:occlusion.connect = </Materials/Material_${K.uniqueId}/Texture_${C.uniqueId}_occlusion.outputs:${i}>`),u.push(AH(C,K,"occlusion",new L.CH(Z,Z,Z),H,M))),null!==G?(w.push(`${q}float inputs:roughness.connect = </Materials/Material_${K.uniqueId}/Texture_${G.uniqueId}_roughness.outputs:${a}>`),u.push(AH(G,K,"roughness",new L.CH(v,v,v),H,M))):w.push(`${q}float inputs:roughness = ${v}`),null!==O?(w.push(`${q}float inputs:metallic.connect = </Materials/Material_${K.uniqueId}/Texture_${O.uniqueId}_metallic.outputs:${S}>`),u.push(AH(O,K,"metallic",new L.CH(B,B,B),H,M))):w.push(`${q}float inputs:metallic = ${B}`),null!==E?(w.push(`${q}float inputs:opacity.connect = </Materials/Material_${K.uniqueId}/Texture_${E.uniqueId}_opacity.outputs:r>`),w.push(`${q}float inputs:opacityThreshold = 0.0001`),u.push(AH(E,K,"opacity",null,H,M))):w.push(`${q}float inputs:opacity = ${K.alpha}`),s&&(null!==V?(w.push(`${q}float inputs:clearcoat.connect = </Materials/Material_${K.uniqueId}/Texture_${V.uniqueId}_clearcoat.outputs:r>`),u.push(AH(V,K,"clearcoat",new L.CH(D,D,D),H,M))):w.push(`${q}float inputs:clearcoat = ${D}`),null!==c?(w.push(`${q}float inputs:clearcoatRoughness.connect = </Materials/Material_${K.uniqueId}/Texture_${c.uniqueId}_clearcoatRoughness.outputs:g>`),u.push(AH(c,K,"clearcoatRoughness",new L.CH(n,n,n),H,M))):w.push(`${q}float inputs:clearcoatRoughness = ${n}`)),w.push(`${q}float inputs:ior = ${l}`),`\n\tdef Material "Material_${K.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${w.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${K.uniqueId}/PreviewSurface.outputs:surface>\n\n${u.join("\n")}\n\n\t}\n`}async function HM(K,H,M){const u={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...H};"undefined"===typeof fflate&&await w.Tools.LoadScriptAsync(u.fflateUrl);const y={};y[u.modelFileName]=null;let h='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';h+=function(K){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===K.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${K.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${K.planeAnchoringAlignment}"`:""}\n            `}(u);const W={};for(const q of K.meshes){if(0===q.getTotalVertices())continue;const K=q,H=K.Gh,I=K.material;if(!I||!H||M&&!M(K))continue;if(-1!==["BH","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(I.getClassName())){const M="geometries/Geometry_"+H.uniqueId+".usda";if(!(M in y)){const K=FH(H,u);y[M]=YH(K)}I.uniqueId in W||(W[I.uniqueId]=I),h+=bH(K)}else w.Tools.Warn("USDZExportAsync does not support this material type: "+I.getClassName())}K.activeCamera&&u.exportCamera&&(h+=function(K,H){const M="Camera_"+K.uniqueId,w=rH(q.Matrix.RotationY(Math.PI).multiply(K.getWorldMatrix()));if(K.mode===l.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${M}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${w}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${K.Ih.toPrecision(H.precision)}, ${K.maxZ.toPrecision(H.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(K.orthoLeft||1)+Math.abs(K.orthoRight||1))).toPrecision(H.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(K.orthoTop||1)+Math.abs(K.orthoBottom||1))).toPrecision(H.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const q=K.getEngine().getAspectRatio(K),u=H.cameraSensorWidth||35;return`def Camera "${M}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${w}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${K.Ih.toPrecision(H.precision)}, ${K.maxZ.toPrecision(H.precision)})\n\t\t\tfloat focalLength = ${(u/(2*Math.tan(.5*K.fov))).toPrecision(H.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(u*q).toPrecision(H.precision)}\n\t\t\tfloat verticalAperture = ${(u/q).toPrecision(H.precision)}            \n\t\t}\n\t\n\t`}}(K.activeCamera,u)),h+="\n            }\n        }\n    }";const I={};h+=function(K,H,M){const q=[];for(const w in K){const u=K[w];q.push(KM(u,H,M))}return`\n    def "Materials"\n{\n${q.join("")}\n}\n\n`}(W,I,u),y[u.modelFileName]=fflate.strToU8(h);for(const q in I){const K=I[q],H=K.getSize(),M=await K.readPixels();if(!M)throw new Error("Texture data is not available");const w=await s.DumpTools.DumpDataAsync(H.width,H.height,M,"image/png",void 0,!1,!0);y[`textures/Texture_${q}.png`]=new Uint8Array(w).slice()}let f=0;for(const q in y){const K=y[q];if(!K)continue;f+=34+q.length;const H=63&f;if(4!==H){const M=new Uint8Array(64-H);y[q]=[K,{extra:{12345:M}}]}f=K.length}return fflate.zipSync(y,{level:0})}}}]);