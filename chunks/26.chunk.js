"use strict";(self.agop5zpabxv=self.agop5zpabxv||[]).push([[26],{12717:(H,u,J)=>{J.r(u),J.d(u,{EXT_materials_diffuse_roughness:()=>Wu,EXT_mesh_gpu_instancing:()=>xH,GLTF2Export:()=>oH,GLTFData:()=>b,KHR_draco_mesh_compression:()=>Ju,KHR_lights_punctual:()=>Bu,KHR_materials_anisotropy:()=>Gu,KHR_materials_clearcoat:()=>mJ,KHR_materials_diffuse_transmission:()=>pu,KHR_materials_dispersion:()=>ku,KHR_materials_emissive_strength:()=>ju,KHR_materials_ior:()=>Lu,KHR_materials_iridescence:()=>Yu,KHR_materials_sheen:()=>su,KHR_materials_specular:()=>tu,KHR_materials_transmission:()=>cu,KHR_materials_unlit:()=>Vu,KHR_materials_volume:()=>Ru,KHR_texture_transform:()=>iu,OBJExport:()=>w,STLExport:()=>Su,USDZExportAsync:()=>uJ,_ConvertToGLTFPBRMetallicRoughness:()=>n,_SolveMetallic:()=>c,__IGLTFExporterExtension:()=>g});var O=J(12338),U=J(12171),h=J(12651);class w{static OBJ(H,u,J,w){const g=[];let B=1,b=1;u&&(J||(J="mat"),g.push("mtllib "+J+".mtl"));for(let d=0;d<H.length;d++){const J=H[d],G=J.name||`mesh${d}}`;g.push(`o ${G}`);let P=null;if(w){const H=J.dg(!0);P=new O.Matrix,H.invertToRef(P),J.bakeTransformIntoVertices(H)}if(u){const H=J.material;H&&g.push("usemtl "+H.id)}const mH=J.Gg;if(!mH){U.Tools.Warn("No geometry is present on the mesh");continue}const l=mH.getVerticesData("position"),r=mH.getVerticesData("normal"),p=mH.getVerticesData("uv"),a=mH.rg();let k=0,C=0;if(!l||!a){U.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const j=H[0].ZH().useRightHandedSystem?1:-1;for(let H=0;H<l.length;H+=3)g.push("v "+l[H]*j+" "+l[H+1]+" "+l[H+2]),k++;if(null!=r)for(let H=0;H<r.length;H+=3)g.push("vn "+r[H]*j+" "+r[H+1]+" "+r[H+2]);if(null!=p)for(let H=0;H<p.length;H+=2)g.push("vt "+p[H]+" "+p[H+1]),C++;const M=["","",""],L=(J.material||J.ZH().defaultMaterial)._getEffectiveOrientation(J),[Z,Y]=L===h.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let H=0;H<a.length;H+=3){const u=[String(a[H]+B),String(a[H+Z]+B),String(a[H+Y]+B)],J=[String(a[H]+b),String(a[H+Z]+b),String(a[H+Y]+b)],O=u,U=null!=p?J:M,h=null!=r?u:M;g.push("f "+O[0]+"/"+U[0]+"/"+h[0]+" "+O[1]+"/"+U[1]+"/"+h[1]+" "+O[2]+"/"+U[2]+"/"+h[2])}w&&P&&J.bakeTransformIntoVertices(P),B+=k,b+=C}return g.join("\n")}static MTL(H){const u=[],J=H.material;u.push("newmtl mat1"),u.push("  Ns "+J.specularPower.toFixed(4)),u.push("  Ni 1.5000"),u.push("  d "+J.alpha.toFixed(4)),u.push("  Tr 0.0000"),u.push("  Tf 1.0000 1.0000 1.0000"),u.push("  illum 2"),u.push("  Ka "+J.ambientColor.r.toFixed(4)+" "+J.ambientColor.g.toFixed(4)+" "+J.ambientColor.b.toFixed(4)),u.push("  Kd "+J.diffuseColor.r.toFixed(4)+" "+J.diffuseColor.g.toFixed(4)+" "+J.diffuseColor.b.toFixed(4)),u.push("  Ks "+J.specularColor.r.toFixed(4)+" "+J.specularColor.g.toFixed(4)+" "+J.specularColor.b.toFixed(4)),u.push("  Ke "+J.emissiveColor.r.toFixed(4)+" "+J.emissiveColor.g.toFixed(4)+" "+J.emissiveColor.b.toFixed(4));J.ambientTexture&&u.push("  map_Ka "+J.ambientTexture.name),J.diffuseTexture&&u.push("  map_Kd "+J.diffuseTexture.name),J.specularTexture&&u.push("  map_Ks "+J.specularTexture.name),J.bumpTexture&&u.push("  map_bump -imfchan z "+J.bumpTexture.name),J.opacityTexture&&u.push("  map_d "+J.opacityTexture.name);return u.join("\n")}}var g=0,B=J(12210);class b{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const H in this.files){const u=this.files[H],J=new Blob([u],{type:(0,B.h)(H)});U.Tools.Download(J,H)}}}var d=J(12410),G=J(12724),P=J(12741),mH=J(12763),l=J(12452),r=J(12203),p=J(12379),a=J(12349);const k=a.HighestCommonFactor,C={...a,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:k};var j=J(12555),M=J(12321),L=J(12801),Z=J(12806),Y=J(12546);const F=1e-6,s=new p.ku(.04,.04,.04),A=1024,t=p.ku.White(),e=p.ku.Black();function c(H,u,J){if(u<s.r)return 0;const O=s.r,U=H*J/(1-s.r)+u-2*s.r,h=U*U-4*O*(s.r-u);return C.Clamp((-U+Math.sqrt(h))/(2*O),0,1)}function n(H){const u=H.diffuseColor.toLinearSpace(H.ZH().getEngine().useExactSrgbConversions).scale(.5),J=H.alpha,U=function(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new O.Vector2(0,1),J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new O.Vector2(0,.1),U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new O.Vector2(0,.1),h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new O.Vector2(1300,.1);return function(H,u,J,O,U){return(1-H)*(1-H)*(1-H)*u+3*(1-H)*(1-H)*H*J+3*(1-H)*H*H*O+H*H*H*U}(Math.pow(H/h.x,.333333),u.y,J.y,U.y,h.y)}(C.Clamp(H.specularPower,0,A));return{baseColorFactor:[u.r,u.g,u.b,J],metallicFactor:0,roughnessFactor:U}}function V(H,u){u.needAlphaBlending()?H.alphaMode="BLEND":u.needAlphaTesting()&&(H.alphaMode="MASK",H.alphaCutoff=u.alphaCutOff)}function T(H,u,J){const O=new Uint8Array(H*u*4);for(let U=0;U<O.length;U+=4)O[U]=O[U+1]=O[U+2]=O[U+3]=255;return L.d.CreateRGBATexture(O,H,u,J)}function R(H){if(H instanceof Uint8Array){const u=H.length,J=new Float32Array(H.length);for(let O=0;O<u;++O)J[O]=H[O]/255;return J}if(H instanceof Float32Array)return H;throw new Error("Unsupported pixel format!")}class X{constructor(H){this._exporter=H,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(H){return H?this._textureMap.get(H)??null:null}async exportStandardMaterialAsync(H,u,J){const O=n(H),h={name:H.name};if(null==H.ag||H.ag||(H.twoSidedLighting||U.Tools.Warn(H.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),h.doubleSided=!0),J){const J=[],U=H.diffuseTexture;U&&J.push(this.exportTextureAsync(U,u).then((H=>{H&&(O.baseColorTexture=H)})));const w=H.bumpTexture;w&&J.push(this.exportTextureAsync(w,u).then((H=>{H&&(h.normalTexture=H,1!==w.level&&(h.normalTexture.scale=w.level))})));const g=H.emissiveTexture;g&&(h.emissiveFactor=[1,1,1],J.push(this.exportTextureAsync(g,u).then((H=>{H&&(h.emissiveTexture=H)}))));const B=H.ambientTexture;B&&J.push(this.exportTextureAsync(B,u).then((H=>{if(H){const u={index:H.index};h.occlusionTexture=u}}))),J.length>0&&(this._exporter._materialNeedsUVsSet.add(H),await Promise.all(J))}(H.alpha<1||H.opacityTexture)&&(H.alphaMode===Z.b.ALPHA_COMBINE?h.alphaMode="BLEND":U.Tools.Warn(H.name+": glTF 2.0 does not support alpha mode: "+H.alphaMode.toString())),H.emissiveColor&&!H.emissiveColor.equalsWithEpsilon(e,F)&&(h.emissiveFactor=H.emissiveColor.Hg()),h.pbrMetallicRoughness=O,V(h,H),await this._finishMaterialAsync(h,H,u);const w=this._exporter._materials;return w.push(h),w.length-1}async _finishMaterialAsync(H,u,J){const O=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",H,u),U=[];for(const h of O)U.push(this.exportTextureAsync(h,J));await Promise.all(U),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",H,u)}async _getImageDataAsync(H,u,O,U){const h=Z.b.TEXTURETYPE_UNSIGNED_BYTE,w=this._exporter._babylonScene,g=w.getEngine(),B=g.createRawTexture(H,u,O,Z.b.TEXTUREFORMAT_RGBA,!1,!0,M.b.NEAREST_SAMPLINGMODE,null,h);g.isWebGPU?await J.e(51).then(J.bind(J,14784)):await J.e(52).then(J.bind(J,14792)),await j.m.ApplyPostProcess("pass",B,w,h,Z.b.TEXTURE_NEAREST_SAMPLINGMODE,Z.b.TEXTUREFORMAT_RGBA);const b=await g._readTexturePixels(B,u,O);return await Y.DumpTools.DumpDataAsync(u,O,b,U,void 0,!0,!0)}_resizeTexturesToSameDimensions(H,u,J){const O=H?H.getSize():{width:0,height:0},U=u?u.getSize():{width:0,height:0};let h,w;return O.width<U.width?(h=H&&H instanceof M.b?j.m.CreateResizedCopy(H,U.width,U.height,!0):T(U.width,U.height,J),w=u):O.width>U.width?(w=u&&u instanceof M.b?j.m.CreateResizedCopy(u,O.width,O.height,!0):T(O.width,O.height,J),h=H):(h=H,w=u),{texture1:h,texture2:w}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(H,u,J,O){const U=new Array;if(!H&&!u)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const h=H?H.ZH():u?u.ZH():null;if(h){var w;const g=this._resizeTexturesToSameDimensions(H,u,h),B=null===(w=g.texture1)||void 0===w?void 0:w.getSize();let b,d;const G=B.width,P=B.height,mH=await g.texture1.readPixels(),l=await g.texture2.readPixels();if(!mH)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(b=R(mH),!l)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");d=R(l);const r=d.byteLength,a=new Uint8Array(r),k=new Uint8Array(r),C=4,j=e;let M=0,L=0;for(let H=0;H<P;++H)for(let u=0;u<G;++u){const O=(G*H+u)*C,U={diffuseColor:new p.ku(b[O],b[O+1],b[O+2]).toLinearSpace(h.getEngine().useExactSrgbConversions).multiply(J.diffuseColor),specularColor:new p.ku(d[O],d[O+1],d[O+2]).toLinearSpace(h.getEngine().useExactSrgbConversions).multiply(J.specularColor),glossiness:d[O+3]*J.glossiness},w=this._convertSpecularGlossinessToMetallicRoughness(U);j.r=Math.max(j.r,w.baseColor.r),j.g=Math.max(j.g,w.baseColor.g),j.b=Math.max(j.b,w.baseColor.b),M=Math.max(M,w.metallic),L=Math.max(L,w.roughness),k[O]=255*w.baseColor.r,k[O+1]=255*w.baseColor.g,k[O+2]=255*w.baseColor.b,k[O+3]=g.texture1.Og?255*b[O+3]:255,a[O]=0,a[O+1]=255*w.roughness,a[O+2]=255*w.metallic,a[O+3]=255}const Z={baseColor:j,metallic:M,roughness:L};let Y=!1,s=!1;for(let H=0;H<P;++H)for(let u=0;u<G;++u){const J=(G*H+u)*C;k[J]/=Z.baseColor.r>F?Z.baseColor.r:1,k[J+1]/=Z.baseColor.g>F?Z.baseColor.g:1,k[J+2]/=Z.baseColor.b>F?Z.baseColor.b:1;const O=p.ku.FromInts(k[J],k[J+1],k[J+2]).toGammaSpace(h.getEngine().useExactSrgbConversions);k[J]=255*O.r,k[J+1]=255*O.g,k[J+2]=255*O.b,O.equalsWithEpsilon(t,F)||(s=!0),a[J+1]/=Z.roughness>F?Z.roughness:1,a[J+2]/=Z.metallic>F?Z.metallic:1;p.ku.FromInts(255,a[J+1],a[J+2]).equalsWithEpsilon(t,F)||(Y=!0)}return Y&&U.push(this._getImageDataAsync(a,G,P,O).then((H=>{Z.metallicRoughnessTextureData=H}))),s&&U.push(this._getImageDataAsync(k,G,P,O).then((H=>{Z.baseColorTextureData=H}))),await Promise.all(U).then((()=>Z))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(H){const u=this._getPerceivedBrightness(H.diffuseColor),J=this._getPerceivedBrightness(H.specularColor),O=1-this._getMaxComponent(H.specularColor),U=c(u,J,O),h=H.diffuseColor.scale(O/(1-s.r)/Math.max(1-U)),w=H.specularColor.ru(s.scale(1-U)).scale(1/Math.max(U));let g=p.ku.Lerp(h,w,U*U);g=g.clampToRef(0,1,g);return{baseColor:g,metallic:U,roughness:1-H.glossiness}}_getPerceivedBrightness(H){return H?Math.sqrt(.299*H.r*H.r+.587*H.g*H.g+.114*H.b*H.b):0}_getMaxComponent(H){return H?Math.max(H.r,Math.max(H.g,H.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(H,u,J,O){const U=[],h={baseColor:H._albedoColor,metallic:H._metallic,roughness:H._roughness};if(O){H._albedoTexture&&U.push(this.exportTextureAsync(H._albedoTexture,u).then((H=>{H&&(J.baseColorTexture=H)})));const O=H._metallicTexture;O&&U.push(this.exportTextureAsync(O,u).then((H=>{H&&(J.metallicRoughnessTexture=H)})))}return U.length>0&&(this._exporter._materialNeedsUVsSet.add(H),await Promise.all(U)),h}_getTextureSampler(H){const u={};if(!H||!(H instanceof M.b))return u;const J=this._getGLTFTextureWrapMode(H.wrapU);10497!==J&&(u.wrapS=J);const O=this._getGLTFTextureWrapMode(H.wrapV);switch(10497!==O&&(u.wrapT=O),H.samplingMode){case M.b.LINEAR_LINEAR:u.magFilter=9729,u.minFilter=9729;break;case M.b.LINEAR_NEAREST:u.magFilter=9729,u.minFilter=9728;break;case M.b.NEAREST_LINEAR:u.magFilter=9728,u.minFilter=9729;break;case M.b.NEAREST_LINEAR_MIPLINEAR:u.magFilter=9728,u.minFilter=9987;break;case M.b.NEAREST_NEAREST:u.magFilter=9728,u.minFilter=9728;break;case M.b.NEAREST_LINEAR_MIPNEAREST:u.magFilter=9728,u.minFilter=9985;break;case M.b.LINEAR_NEAREST_MIPNEAREST:u.magFilter=9729,u.minFilter=9984;break;case M.b.LINEAR_NEAREST_MIPLINEAR:u.magFilter=9729,u.minFilter=9986;break;case M.b.NEAREST_NEAREST_MIPLINEAR:u.magFilter=9728,u.minFilter=9986;break;case M.b.LINEAR_LINEAR_MIPLINEAR:u.magFilter=9729,u.minFilter=9987;break;case M.b.LINEAR_LINEAR_MIPNEAREST:u.magFilter=9729,u.minFilter=9985;break;case M.b.NEAREST_NEAREST_MIPNEAREST:u.magFilter=9728,u.minFilter=9984}return u}_getGLTFTextureWrapMode(H){switch(H){case M.b.WRAP_ADDRESSMODE:return 10497;case M.b.CLAMP_ADDRESSMODE:return 33071;case M.b.MIRROR_ADDRESSMODE:return 33648;default:return U.Tools.Error(`Unsupported Texture Wrap Mode ${H}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(H,u,J,O){const U={diffuseColor:H._albedoColor,specularColor:H._reflectivityColor,glossiness:H._microSurface},h=H._albedoTexture,w=H._reflectivityTexture,g=H._useMicroSurfaceFromReflectivityMapAlpha;if(w&&!g)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((h||w)&&O){this._exporter._materialNeedsUVsSet.add(H);const O=this._exportTextureSampler(h||w),g=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(h,w,U,u),B=this._exporter._textures;if(g.baseColorTextureData){const H=this._exportImage(`baseColor${B.length}`,u,g.baseColorTextureData);J.baseColorTexture=this._exportTextureInfo(H,O,null===h||void 0===h?void 0:h.coordinatesIndex)}if(g.metallicRoughnessTextureData){const H=this._exportImage(`metallicRoughness${B.length}`,u,g.metallicRoughnessTextureData);J.metallicRoughnessTexture=this._exportTextureInfo(H,O,null===w||void 0===w?void 0:w.coordinatesIndex)}return g}return this._convertSpecularGlossinessToMetallicRoughness(U)}async exportPBRMaterialAsync(H,u,J){const O={},U={name:H.name},h=H.isMetallicWorkflow();if(h){const u=H._albedoColor,J=H.alpha;u&&(O.baseColorFactor=[u.r,u.g,u.b,J])}const w=h?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(H,u,O,J):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(H,u,O,J);await this._setMetallicRoughnessPbrMaterialAsync(w,H,U,O,u,J),await this._finishMaterialAsync(U,H,u);const g=this._exporter._materials;return g.push(U),g.length-1}async _setMetallicRoughnessPbrMaterialAsync(H,u,J,O,h,w){if(V(J,u),H.baseColor.equalsWithEpsilon(t,F)&&C.WithinEpsilon(u.alpha,1,F)||(O.baseColorFactor=[H.baseColor.r,H.baseColor.g,H.baseColor.b,u.alpha]),null!=H.metallic&&1!==H.metallic&&(O.metallicFactor=H.metallic),null!=H.roughness&&1!==H.roughness&&(O.roughnessFactor=H.roughness),null==u.ag||u.ag||(u._twoSidedLighting||U.Tools.Warn(u.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),J.doubleSided=!0),w){const H=[],O=u._bumpTexture;O&&H.push(this.exportTextureAsync(O,h).then((H=>{H&&(J.normalTexture=H,1!==O.level&&(J.normalTexture.scale=O.level))})));const U=u._ambientTexture;U&&H.push(this.exportTextureAsync(U,h).then((H=>{if(H){const O={index:H.index,texCoord:H.texCoord,extensions:H.extensions};J.occlusionTexture=O;const U=u._ambientTextureStrength;U&&(O.strength=U)}})));const w=u._emissiveTexture;w&&H.push(this.exportTextureAsync(w,h).then((H=>{H&&(J.emissiveTexture=H)}))),H.length>0&&(this._exporter._materialNeedsUVsSet.add(u),await Promise.all(H))}const g=u._emissiveColor;g.equalsWithEpsilon(e,F)||(J.emissiveFactor=g.Hg()),J.pbrMetallicRoughness=O}_getPixelsFromTextureAsync(H){return function(H){switch(H){case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case Z.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Z.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case Z.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(H.textureFormat)?(0,j.l)(H,H._texture.width,H._texture.height):(H.textureType,Z.b.TEXTURETYPE_UNSIGNED_BYTE,H.readPixels())}async exportTextureAsync(H,u){const J=this._exporter._extensionsPreExportTextureAsync("exporter",H,u);return J?await J.then((async J=>J?await this._exportTextureInfoAsync(J,u):await this._exportTextureInfoAsync(H,u))):await this._exportTextureInfoAsync(H,u)}async _exportTextureInfoAsync(H,u){let J=this._textureMap.get(H);if(!J){const O=await this._getPixelsFromTextureAsync(H);if(!O)return null;const h=this._exportTextureSampler(H),w=H.mimeType;if(w)switch(w){case"image/jpeg":case"image/png":case"image/webp":u=w;break;default:U.Tools.Warn(`Unsupported media type: ${w}. Exporting texture as PNG.`)}const g=this._internalTextureToImage,B=H.getInternalTexture().uniqueId;g[B]||(g[B]={});let b=g[B][u];if(void 0===b){const J=H.getSize();b=(async()=>{const U=await this._getImageDataAsync(O,J.width,J.height,u);return this._exportImage(H.name,u,U)})(),g[B][u]=b}J=this._exportTextureInfo(await b,h,H.coordinatesIndex),this._textureMap.set(H,J),this._exporter._extensionsPostExportTextures("exporter",J,H)}return J}_exportImage(H,u,J){const O=this._exporter._images;let h;if(this._exporter._shouldUseGlb){h={name:H,mimeType:u,bufferView:void 0};const O=this._exporter._bufferManager.createBufferView(new Uint8Array(J));this._exporter._bufferManager.setBufferView(h,O)}else{const w=H.replace(/\.\/|\/|\.\\|\\/g,"_"),g=function(H){switch(H){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(u);let B=w+g;O.some((H=>H.uri===B))&&(B=`${w}_${U.Tools.RandomId()}${g}`),h={name:H,uri:B},this._exporter._imageData[B]={data:J,mimeType:u}}return O.push(h),O.length-1}_exportTextureInfo(H,u,J){const O=this._exporter._textures;let U=O.findIndex((J=>J.sampler==u&&J.source===H));-1===U&&(U=O.length,O.push({source:H,sampler:u}));const h={index:U};return J&&(h.texCoord=J),h}_exportTextureSampler(H){const u=this._getTextureSampler(H),J=this._exporter._samplers,O=J.findIndex((H=>H.minFilter===u.minFilter&&H.magFilter===u.magFilter&&H.wrapS===u.wrapS&&H.wrapT===u.wrapT));return-1!==O?O:(J.push(u),J.length-1)}}var W=J(12425),f=J(12185),i=J(12811),S=J(12343);const v=O.lu.Zero(),I=O.Quaternion.Identity(),D=O.lu.One(),o=new O.lu(-1,1,1);function y(H,u){const{byteOffset:J,byteStride:O,type:U,normalized:h}=H,w=H.getSize(),g=u.reduce(((H,u)=>u.getTotalVertices()>H?u.getTotalVertices():H),-Number.MAX_VALUE);return{byteOffset:J,byteStride:O,componentCount:w,type:U,count:g*w,normalized:h,totalVertices:g,kind:H.getKind()}}function x(H){switch(H){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function z(H){switch(H){case d.d.PositionKind:case d.d.NormalKind:case d.d.TangentKind:case d.d.ColorKind:case d.d.MatricesIndicesKind:case d.d.MatricesIndicesExtraKind:case d.d.MatricesWeightsKind:case d.d.MatricesWeightsExtraKind:case d.d.UVKind:case d.d.UV2Kind:case d.d.UV3Kind:case d.d.UV4Kind:case d.d.UV5Kind:case d.d.UV6Kind:return!0}return!1}function K(H){switch(H){case h.b.TriangleFillMode:return 4;case h.b.TriangleStripDrawMode:return 5;case h.b.TriangleFanDrawMode:return 6;case h.b.PointListDrawMode:case h.b.PointFillMode:return 0;case h.b.LineLoopDrawMode:return 2;case h.b.LineListDrawMode:return 1;case h.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${H}`)}function N(H){const u=Math.sqrt(H.x*H.x+H.y*H.y+H.z*H.z);u>0&&(H.x/=u,H.y/=u,H.z/=u)}function q(H){return H.x*=-1,H}function E(H){if(H.x*H.x+H.y*H.y>.5){const u=Math.abs(H.x),J=Math.abs(H.y);if(u>J){const J=Math.sign(H.x);H.x=u,H.y*=-J,H.z*=-J,H.w*=J}else{const u=Math.sign(H.y);H.x*=-u,H.y=J,H.z*=u,H.w*=-u}}else{const u=Math.abs(H.z),J=Math.abs(H.w);if(u>J){const J=Math.sign(H.z);H.x*=-J,H.y*=J,H.z=u,H.w*=-J}else{const u=Math.sign(H.w);H.x*=u,H.y*=-u,H.z*=-u,H.w=J}}return H}function Q(H){H.kg(-H.z,H.w,H.x,-H.y)}function HH(H,u){const J=O.lu.FromArrayToRef(u.translation||[0,0,0],0,O.TmpVectors.lu[0]),U=O.Quaternion.FromArrayToRef(u.rotation||[0,0,0,1],0,O.TmpVectors.Quaternion[0]),h=O.Matrix.ComposeToRef(D,U,J,O.TmpVectors.Matrix[0]),w=O.lu.FromArrayToRef(H.translation||[0,0,0],0,O.TmpVectors.lu[2]),g=O.Quaternion.FromArrayToRef(H.rotation||[0,0,0,1],0,O.TmpVectors.Quaternion[1]),B=O.Matrix.ComposeToRef(D,g,w,O.TmpVectors.Matrix[1]);h.multiplyToRef(B,B),B.decompose(void 0,U,J),J.equalsWithEpsilon(v,S.d)?delete u.translation:u.translation=J.Hg(),U.equalsWithEpsilon(I,S.d)?delete u.rotation:u.rotation=U.Hg(),u.scale&&delete u.scale}function uH(H,u){if(!(u instanceof G.c))return!1;if(!(1===u.getChildren().length&&0===H.getChildren().length&&H.parent===u))return!1;const J=H.ZH(),O=H instanceof i.e&&!J.useRightHandedSystem?o:D;return!!u.Cg.equalsWithEpsilon(O,S.d)||(f.b.Warn(`Cannot collapse node ${H.name} into parent node ${u.name} with modified scaling.`),!1)}function JH(H){if(H instanceof Array){const u=new Float32Array(H);return new Uint8Array(u.buffer,u.byteOffset,u.byteLength)}return ArrayBuffer.isView(H)?new Uint8Array(H.buffer,H.byteOffset,H.byteLength):new Uint8Array(H)}function OH(H,u){for(const[J,O]of Object.entries(H)){const U=u[J];(Array.isArray(O)&&Array.isArray(U)&&UH(O,U)||O===U)&&delete H[J]}return H}function UH(H,u){return H.length===u.length&&H.every(((H,J)=>H===u[J]))}const hH=O.Matrix.Compose(new O.lu(-1,1,1),O.Quaternion.Identity(),O.lu.Zero());function wH(H,u){if(!(H instanceof G.c))return!1;if(u){if(!H.getWorldMatrix().equalsWithEpsilon(O.Matrix.IdentityReadOnly,S.d))return!1}else{if(!H.getWorldMatrix().multiplyToRef(hH,O.TmpVectors.Matrix[0]).equalsWithEpsilon(O.Matrix.IdentityReadOnly,S.d))return!1}return!(H instanceof P.c&&H.Gg)}const gH=new Map([[Int8Array,(H,u,J)=>H.setInt8(u,J)],[Uint8Array,(H,u,J)=>H.setUint8(u,J)],[Uint8ClampedArray,(H,u,J)=>H.setUint8(u,J)],[Int16Array,(H,u,J)=>H.setInt16(u,J,!0)],[Uint16Array,(H,u,J)=>H.setUint16(u,J,!0)],[Int32Array,(H,u,J)=>H.setInt32(u,J,!0)],[Uint32Array,(H,u,J)=>H.setUint32(u,J,!0)],[Float32Array,(H,u,J)=>H.setFloat32(u,J,!0)],[Float64Array,(H,u,J)=>H.setFloat64(u,J,!0)]]);class BH{writeTypedArray(H){this._checkGrowBuffer(H.byteLength);const u=gH.get(H.constructor);for(let J=0;J<H.length;J++)u(this._dataView,this._byteOffset,H[J]),this._byteOffset+=H.BYTES_PER_ELEMENT}constructor(H){this._data=new Uint8Array(H),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(H){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,H),this._byteOffset++}writeInt8(H){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,H),this._byteOffset++}writeInt16(H){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,H,!0),this._byteOffset+=2}writeUInt16(H){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,H,!0),this._byteOffset+=2}writeInt32(H){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,H,!0),this._byteOffset+=4}writeUInt32(H){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,H,!0),this._byteOffset+=4}writeFloat32(H){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,H,!0),this._byteOffset+=4}writeFloat64(H){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,H,!0),this._byteOffset+=8}_checkGrowBuffer(H){const u=this.byteOffset+H;if(u>this._data.byteLength){const H=new Uint8Array(2*u);H.set(this._data),this._data=H,this._dataView=new DataView(this._data.buffer)}}}function bH(H){return H%4===0?4:H%2===0?2:1}class dH{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(H){let u=0;this._bufferViewToData.forEach((H=>{u+=H.byteLength}));const J=new BH(u),O=Array.from(this._bufferViewToData.keys()).sort(((H,u)=>bH(u.byteLength)-bH(H.byteLength)));for(const U of O){U.byteOffset=J.byteOffset,H.push(U);const u=H.length-1,O=this.getPropertiesWithBufferView(U);for(const H of O)H.bufferView=u;J.writeTypedArray(this._bufferViewToData.get(U)),this._bufferViewToData.delete(U)}return J.getOutputData()}createBufferView(H,u){const J={buffer:0,byteOffset:void 0,byteLength:H.byteLength,byteStride:u};return this._bufferViewToData.set(J,H),J}createAccessor(H,u,J,O,U,h,w){this._verifyBufferView(H);const g={bufferView:void 0,componentType:J,count:O,type:u,min:null===h||void 0===h?void 0:h.min,max:null===h||void 0===h?void 0:h.max,normalized:w,byteOffset:U};return this.setBufferView(g,H),this._accessorToBufferView.set(g,H),g}setBufferView(H,u){this._verifyBufferView(u);this.getPropertiesWithBufferView(u).push(H)}removeBufferView(H){const u=this.getPropertiesWithBufferView(H);for(const J of u)void 0!==J.bufferView&&delete J.bufferView;this._bufferViewToData.delete(H),this._bufferViewToProperties.delete(H),this._accessorToBufferView.forEach(((u,J)=>{u===H&&(void 0!==J.byteOffset&&delete J.byteOffset,this._accessorToBufferView.delete(J))}))}getBufferView(H){const u=this._accessorToBufferView.get(H);return this._verifyBufferView(u),u}getPropertiesWithBufferView(H){return this._verifyBufferView(H),this._bufferViewToProperties.set(H,this._bufferViewToProperties.get(H)??[]),this._bufferViewToProperties.get(H)}getData(H){return this._verifyBufferView(H),this._bufferViewToData.get(H)}_verifyBufferView(H){if(void 0===H||!this._bufferViewToData.has(H))throw new Error(`BufferView ${H} not found in BufferManager.`)}}var GH,PH=J(12774),mu=J(12793),lH=J(12818),rH=J(12681),pH=J(12852),aH=J(12866),kH=J(12770),CH=J(12872);!function(H){H[H.INTANGENT=0]="INTANGENT",H[H.OUTTANGENT=1]="OUTTANGENT"}(GH||(GH={}));class jH{static _IsTransformable(H){return H&&(H instanceof G.c||H instanceof PH.c||H instanceof CH.d)}static _CreateNodeAnimation(H,u,J,O,h){if(this._IsTransformable(H)){const w=[],g=[],B=u.getKeys(),b=jH._CalculateMinMaxKeyFrames(B),d=jH._DeduceInterpolation(B,J,O),G=d.interpolationType,P=d.shouldBakeAnimation;if(P?jH._CreateBakedAnimation(H,u,J,b.min,b.max,u.framePerSecond,h,w,g,b,O):"LINEAR"===G||"STEP"===G?jH._CreateLinearOrStepAnimation(H,u,J,w,g,O):"CUBICSPLINE"===G?jH._CreateCubicSplineAnimation(H,u,J,w,g,O):jH._CreateBakedAnimation(H,u,J,b.min,b.max,u.framePerSecond,h,w,g,b,O),w.length&&g.length){return{inputs:w,outputs:g,samplerInterpolation:G,inputsMin:P?b.min:U.Tools.FloatRound(b.min/u.framePerSecond),inputsMax:P?b.max:U.Tools.FloatRound(b.max/u.framePerSecond)}}}return null}static _DeduceAnimationInfo(H){let u=null,J="VEC3",O=!1;const h=H.targetProperty.split(".");switch(h[0]){case"Cg":u="scale";break;case"position":u="translation";break;case"rotation":J="VEC4",u="rotation";break;case"rotationQuaternion":J="VEC4",O=!0,u="rotation";break;case"influence":J="SCALAR",u="weights";break;default:U.Tools.Error(`Unsupported animatable property ${h[0]}`)}return u?{animationChannelTargetPath:u,dataAccessorType:J,useQuaternion:O}:(U.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(H,u,J,O,U,h,w,g,B,b,d){let G;if(jH._IsTransformable(H)&&H.animations)for(const P of H.animations){if(d&&!d(P))continue;const U=jH._DeduceAnimationInfo(P);U&&(G={name:P.name,samplers:[],channels:[]},jH._AddAnimation(`${P.name}`,P.hasRunningRuntimeAnimations?u:G,H,P,U.dataAccessorType,U.animationChannelTargetPath,O,h,w,g,U.useQuaternion,B,b),G.samplers.length&&G.channels.length&&J.push(G))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(H,u,J,O,U,h,w,g,B,b,d){let G;if(H instanceof kH.c){const U=H.morphTargetManager;if(U)for(let P=0;P<U.numTargets;++P){const mH=U.getTarget(P);for(const l of mH.animations){if(d&&!d(l))continue;const mH=new pH.e(`${l.name}`,"influence",l.framePerSecond,l.dataType,l.loopMode,l.enableBlending),r=[],p=l.getKeys();for(let H=0;H<p.length;++H){const u=p[H];for(let H=0;H<U.numTargets;++H)H==P?r.push(u):r.push({frame:u.frame,value:0})}mH.setKeys(r);const a=jH._DeduceAnimationInfo(mH);a&&(G={name:mH.name,samplers:[],channels:[]},jH._AddAnimation(l.name,l.hasRunningRuntimeAnimations?u:G,H,mH,a.dataAccessorType,a.animationChannelTargetPath,O,h,w,g,a.useQuaternion,B,b,U.numTargets),G.samplers.length&&G.channels.length&&J.push(G))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(H,u,J,O,U,h,w,g,B){let b;if(H.animationGroups){const G=H.animationGroups;for(const P of G){const G=new Map,mH=new Map,l=new Set,r=P.to-P.from;b={name:P.name,channels:[],samplers:[]};for(let u=0;u<P.targetedAnimations.length;++u){const r=P.targetedAnimations[u],p=r.target,a=r.animation;if(B&&!B(a))continue;const k=g.has(p);if(this._IsTransformable(p)||1===p.length&&this._IsTransformable(p[0])){const H=jH._DeduceAnimationInfo(r.animation);if(H){const u=this._IsTransformable(p)?p:this._IsTransformable(p[0])?p[0]:null;u&&jH._AddAnimation(`${a.name}`,b,u,a,H.dataAccessorType,H.animationChannelTargetPath,J,O,U,h,H.useQuaternion,w,k)}}else if(p instanceof aH.c||1===p.length&&p[0]instanceof aH.c){if(jH._DeduceAnimationInfo(r.animation)){const u=p instanceof aH.c?p:p[0];if(u){const J=H.morphTargetManagers.find((H=>{for(let J=0;J<H.numTargets;++J)if(H.getTarget(J)===u)return!0;return!1}));if(J){const O=H.meshes.find((H=>H.morphTargetManager===J));var d;if(O)G.has(O)||G.set(O,new Map),null===(d=G.get(O))||void 0===d||d.set(u,a),l.add(O),mH.set(O,a)}}}}}l.forEach((H=>{const u=H.morphTargetManager;let g=null;const B=[],d=mH.get(H).getKeys(),l=d.length;for(let J=0;J<l;++J)for(let O=0;O<u.numTargets;++O){const U=u.getTarget(O),h=G.get(H);if(h){const u=h.get(U);u?(g||(g=new pH.e(`${P.name}_${H.name}_MorphWeightAnimation`,"influence",u.framePerSecond,pH.e.ANIMATIONTYPE_FLOAT,u.loopMode,u.enableBlending)),B.push(u.getKeys()[J])):B.push({frame:P.from+r/l*J,value:U.influence,inTangent:d[0].inTangent?0:void 0,outTangent:d[0].outTangent?0:void 0})}}g.setKeys(B);const p=jH._DeduceAnimationInfo(g);p&&jH._AddAnimation(`${P.name}_${H.name}_MorphWeightAnimation`,b,H,g,p.dataAccessorType,p.animationChannelTargetPath,J,O,U,h,p.useQuaternion,w,!1,null===u||void 0===u?void 0:u.numTargets)})),b.channels.length&&b.samplers.length&&u.push(b)}}}static _AddAnimation(H,u,J,U,h,w,g,B,b,d,G,P,mH,l){const r=jH._CreateNodeAnimation(J,U,w,G,P);let p,a,k,C,j,M;if(r){if(l){let H=0,u=0;const J=[];for(;r.inputs.length>0;)u=r.inputs.shift(),H%l==0&&J.push(u),H++;r.inputs=J}const H=g.get(J),U=new Float32Array(r.inputs);p=B.createBufferView(U),a=B.createAccessor(p,"SCALAR",5126,r.inputs.length,void 0,{min:[r.inputsMin],max:[r.inputsMax]}),d.push(a),k=d.length-1;const b=new O.Quaternion,G=new O.lu,P=new O.lu,L=J instanceof PH.c,Z=x(h),Y=new Float32Array(r.outputs.length*Z);r.outputs.forEach((function(H,u){let J=H;switch(w){case"translation":mH&&(O.lu.FromArrayToRef(H,0,P),q(P),P.toArray(J));break;case"rotation":4===H.length?O.Quaternion.FromArrayToRef(H,0,b):(J=new Array(4),O.lu.FromArrayToRef(H,0,G),O.Quaternion.FromEulerVectorToRef(G,b)),mH&&(E(b),L&&Q(b)),b.toArray(J)}Y.set(J,u*Z)})),p=B.createBufferView(Y),a=B.createAccessor(p,h,5126,r.outputs.length),d.push(a),C=d.length-1,j={interpolation:r.samplerInterpolation,input:k,output:C},u.samplers.push(j),M={sampler:u.samplers.length-1,target:{node:H,path:w}},u.channels.push(M)}}static _CreateBakedAnimation(H,u,J,h,w,g,B,b,d,G,P){let mH;const l=O.Quaternion.Identity();let r,p=null,a=null,k=null,C=null,j=null,M=null;G.min=U.Tools.FloatRound(h/g);const L=u.getKeys();for(let O=0,Z=L.length;O<Z;++O){if(M=null,k=L[O],O+1<Z)if(C=L[O+1],k.value.equals&&k.value.equals(C.value)||k.value===C.value){if(0!==O)continue;M=k.frame}else M=C.frame;else{if(j=L[O-1],k.value.equals&&k.value.equals(j.value)||k.value===j.value)continue;M=w}if(M)for(let O=k.frame;O<=M;O+=B){if(r=U.Tools.FloatRound(O/g),r===p)continue;p=r,a=r;const h={key:0,repeatCount:0,loopMode:u.loopMode};mH=u._interpolate(O,h),jH._SetInterpolatedValue(H,mH,r,u,J,l,b,d,P)}}a&&(G.max=a)}static _ConvertFactorToVector3OrQuaternion(H,u,J,h,w){const g=jH._GetBasePositionRotationOrScale(u,h,w),B=J.targetProperty.split("."),b=B?B[1]:"",d=w?O.Quaternion.Cu(g).normalize():O.lu.Cu(g);switch(b){case"x":case"y":case"z":d[b]=H;break;case"w":d.w=H;break;default:U.Tools.Error(`glTFAnimation: Unsupported component name "${b}"!`)}return d}static _SetInterpolatedValue(H,u,J,U,h,w,g,B,b){let d;g.push(J),"weights"!==h?(U.dataType===pH.e.ANIMATIONTYPE_FLOAT&&(u=this._ConvertFactorToVector3OrQuaternion(u,H,U,h,b)),"rotation"===h?(b?w=u:(d=u,O.Quaternion.RotationYawPitchRollToRef(d.y,d.x,d.z,w)),B.push(w.Hg())):(d=u,B.push(d.Hg()))):B.push([u])}static _CreateLinearOrStepAnimation(H,u,J,O,U,h){for(const w of u.getKeys())O.push(w.frame/u.framePerSecond),jH._AddKeyframeValue(w,u,U,J,H,h)}static _CreateCubicSplineAnimation(H,u,J,O,U,h){u.getKeys().forEach((function(w){O.push(w.frame/u.framePerSecond),jH._AddSplineTangent(GH.INTANGENT,U,J,"CUBICSPLINE",w,h),jH._AddKeyframeValue(w,u,U,J,H,h),jH._AddSplineTangent(GH.OUTTANGENT,U,J,"CUBICSPLINE",w,h)}))}static _GetBasePositionRotationOrScale(H,u,J){let U;if("rotation"===u)if(J){U=(H.rotationQuaternion??O.Quaternion.Identity()).Hg()}else{U=(H.rotation??O.lu.Zero()).Hg()}else if("translation"===u){U=(H.position??O.lu.Zero()).Hg()}else{U=(H.Cg??O.lu.One()).Hg()}return U}static _AddKeyframeValue(H,u,J,h,w,g){let B;const b=u.dataType;if(b===pH.e.ANIMATIONTYPE_VECTOR3){let u=H.value.Hg();if("rotation"===h){const H=O.lu.Cu(u);u=O.Quaternion.RotationYawPitchRoll(H.y,H.x,H.z).Hg()}J.push(u)}else if(b===pH.e.ANIMATIONTYPE_FLOAT){if("weights"===h)J.push([H.value]);else if(B=this._ConvertFactorToVector3OrQuaternion(H.value,w,u,h,g),B){if("rotation"===h){const H=g?B:O.Quaternion.RotationYawPitchRoll(B.y,B.x,B.z).normalize();J.push(H.Hg())}J.push(B.Hg())}}else b===pH.e.ANIMATIONTYPE_QUATERNION?J.push(H.value.normalize().Hg()):U.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(H,u,J){let O,U,h=!1;if("rotation"===u&&!J)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let w=0,g=H.length;w<g;++w)if(U=H[w],U.inTangent||U.outTangent)if(O){if("CUBICSPLINE"!==O){O="LINEAR",h=!0;break}}else O="CUBICSPLINE";else if(O){if("CUBICSPLINE"===O||U.interpolation&&1===U.interpolation&&"STEP"!==O){O="LINEAR",h=!0;break}}else O=U.interpolation&&1===U.interpolation?"STEP":"LINEAR";return O||(O="LINEAR"),{interpolationType:O,shouldBakeAnimation:h}}static _AddSplineTangent(H,u,J,U,h,w){let g;const B=H===GH.INTANGENT?h.inTangent:h.outTangent;if("CUBICSPLINE"===U){if("rotation"===J)if(B)if(w)g=B.Hg();else{const H=B;g=O.Quaternion.RotationYawPitchRoll(H.y,H.x,H.z).Hg()}else g=[0,0,0,0];else g="weights"===J?B?[B]:[0]:B?B.Hg():[0,0,0];u.push(g)}}static _CalculateMinMaxKeyFrames(H){let u=1/0,J=-1/0;return H.forEach((function(H){u=Math.min(u,H.frame),J=Math.max(J,H.frame)})),{min:u,max:J}}}function MH(H,u,J,h,w,g){const B={attributes:{},influence:H.influence,name:H.name},b=u.Gg;if(!b)return U.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),B;const G=g?-1:1,P=O.lu.Zero();let mH=0,l=0;if(H.hasPositions){const h=H.getPositions(),g=b.getVerticesData(d.d.PositionKind);if(g){const H=new Float32Array(g.length),u=[1/0,1/0,1/0],U=[-1/0,-1/0,-1/0];l=g.length/3,mH=0;for(let J=mH;J<l;++J){const w=O.lu.Cu(g,3*J);O.lu.Cu(h,3*J).subtractToRef(w,P),P.x*=G,u[0]=Math.min(u[0],P.x),U[0]=Math.max(U[0],P.x),u[1]=Math.min(u[1],P.y),U[1]=Math.max(U[1],P.y),u[2]=Math.min(u[2],P.z),U[2]=Math.max(U[2],P.z),H[3*J]=P.x,H[3*J+1]=P.y,H[3*J+2]=P.z}const b=J.createBufferView(H,12),d=J.createAccessor(b,"VEC3",5126,h.length/3,0,{min:u,max:U});w.push(d),B.attributes.POSITION=w.length-1}else U.Tools.Warn(`Morph target positions for mesh ${u.name} were not exported. Mesh does not have position vertex data`)}if(H.hasNormals){const h=H.getNormals(),g=b.getVerticesData(d.d.NormalKind);if(g){const H=new Float32Array(g.length);l=g.length/3,mH=0;for(let J=mH;J<l;++J){const u=O.lu.Cu(g,3*J).normalize();O.lu.Cu(h,3*J).normalize().subtractToRef(u,P),H[3*J]=P.x*G,H[3*J+1]=P.y,H[3*J+2]=P.z}const u=J.createBufferView(H,12),U=J.createAccessor(u,"VEC3",5126,h.length/3,0);w.push(U),B.attributes.NORMAL=w.length-1}else U.Tools.Warn(`Morph target normals for mesh ${u.name} were not exported. Mesh does not have normals vertex data`)}if(H.hasTangents){const h=H.getTangents(),g=b.getVerticesData(d.d.TangentKind);if(g){l=g.length/4;const H=new Float32Array(3*l);mH=0;for(let J=mH;J<l;++J){const u=O.lu.Cu(g,4*J);N(u);const U=O.lu.Cu(h,3*J);N(U),U.subtractToRef(u,P),H[3*J]=P.x*G,H[3*J+1]=P.y,H[3*J+2]=P.z}const u=J.createBufferView(H,12),U=J.createAccessor(u,"VEC3",5126,l,0);w.push(U),B.attributes.TANGENT=w.length-1}else U.Tools.Warn(`Morph target tangents for mesh ${u.name} were not exported. Mesh does not have tangents vertex data`)}if(H.hasColors){const h=H.getColors(),g=b.getVerticesData(d.d.ColorKind),G=b.getVertexBuffer(d.d.ColorKind);if(g&&G){const H=G.getSize();l=g.length/H;const u=new Float32Array(l*H);mH=0;for(let J=mH;J<l;++J)if(3===H){const U=O.lu.Cu(g,J*H);O.lu.Cu(h,J*H).subtractToRef(U,P),u[3*J]=P.x,u[3*J+1]=P.y,u[3*J+2]=P.z}else if(4===H){const U=new O.Vector4,w=O.Vector4.Cu(g,J*H);O.Vector4.Cu(h,J*H).subtractToRef(w,U),u[4*J]=U.x,u[4*J+1]=U.y,u[4*J+2]=U.z,u[4*J+3]=U.w}else U.Tools.Warn(`Unsupported number of components for color attribute: ${H}`);const b=J.createBufferView(u,4*H),d=J.createAccessor(b,3===H?"VEC3":"VEC4",5126,l,0);w.push(d),B.attributes.COLOR_0=w.length-1}else U.Tools.Warn(`Morph target colors for mesh ${u.name} were not exported. Mesh does not have colors vertex data`)}return B}var LH=J(12876),ZH=J(12707),YH=J(12691),FH=J(12304);class sH{}sH.DEFAULT_COLOR=p.ku.White(),sH.DEFAULT_WIDTH_ATTENUATED=1,sH.DEFAULT_WIDTH=.1;var AH=J(12532),tH=J(12878);class eH{static ConvertPoints(H,u){if(H.length&&Array.isArray(H)&&"number"===typeof H[0])return[H];if(H.length&&Array.isArray(H[0])&&"number"===typeof H[0][0])return H;if(H.length&&!Array.isArray(H[0])&&H[0]instanceof O.lu){const u=[];for(let J=0;J<H.length;J++){const O=H[J];u.push(O.x,O.y,O.z)}return[u]}if(H.length>0&&Array.isArray(H[0])&&H[0].length>0&&H[0][0]instanceof O.lu){const u=[],J=H;for(const H of J)u.push(H.flatMap((H=>[H.x,H.y,H.z])));return u}if(H instanceof Float32Array){if(null!==u&&void 0!==u&&u.floatArrayStride){const J=[],O=3*u.floatArrayStride;for(let u=0;u<H.length;u+=O){const U=new Array(O);for(let J=0;J<O;J++)U[J]=H[u+J];J.push(U)}return J}return[Array.from(H)]}if(H.length&&H[0]instanceof Float32Array){const u=[];for(const J of H)u.push(Array.from(J));return u}return[]}static OmitZeroLengthPredicate(H,u,J){const O=[];return u.ru(H).lengthSquared()>0&&O.push([H,u]),J.ru(u).lengthSquared()>0&&O.push([u,J]),H.ru(J).lengthSquared()>0&&O.push([J,H]),0===O.length?null:O}static OmitDuplicatesPredicate(H,u,J,O){const U=[];return eH._SearchInPoints(H,u,O)||U.push([H,u]),eH._SearchInPoints(u,J,O)||U.push([u,J]),eH._SearchInPoints(J,H,O)||U.push([J,H]),0===U.length?null:U}static _SearchInPoints(H,u,J){for(const w of J)for(let J=0;J<w.length;J++){var O,U,h;if(null!==(O=w[J])&&void 0!==O&&O.equals(H))if(null!==(U=w[J+1])&&void 0!==U&&U.equals(u)||null!==(h=w[J-1])&&void 0!==h&&h.equals(u))return!0}return!1}static MeshesToLines(H,u){const J=[];for(let U=0;U<H.length;U++){const h=H[U],w=h.getVerticesData(d.d.PositionKind),g=h.rg();if(w&&g)for(let H=0,B=0;H<g.length;H++){const b=3*g[B++],d=3*g[B++],G=3*g[B++],P=new O.lu(w[b],w[b+1],w[b+2]),mH=new O.lu(w[d],w[d+1],w[d+2]),l=new O.lu(w[G],w[G+1],w[G+2]);if(u){const O=u(P,mH,l,J,H,b,h,U,w,g);if(O)for(const H of O)J.push(H)}else J.push([P,mH],[mH,l],[l,P])}}return J}static ToVector3Array(H){if(Array.isArray(H[0])){const u=[],J=H;for(const H of J){const J=[];for(let u=0;u<H.length;u+=3)J.push(new O.lu(H[u],H[u+1],H[u+2]));u.push(J)}return u}const u=H,J=[];for(let U=0;U<u.length;U+=3)J.push(new O.lu(u[U],u[U+1],u[U+2]));return J}static ToNumberArray(H){return H.flatMap((H=>[H.x,H.y,H.z]))}static GetPointsCountInfo(H){const u=new Array(H.length);let J=0;for(let O=H.length;O--;)u[O]=H[O].length/3,J+=u[O];return{total:J,counts:u}}static GetLineLength(H){if(0===H.length)return 0;let u;u="number"===typeof H[0]?eH.ToVector3Array(H):H;const J=O.TmpVectors.lu[0];let U=0;for(let O=0;O<u.length-1;O++){const H=u[O];U+=u[O+1].subtractToRef(H,J).length()}return U}static GetLineLengthArray(H){const u=new Float32Array(H.length/3);let J=0;for(let O=0,U=H.length/3-1;O<U;O++){let U=H[3*O+0],h=H[3*O+1],w=H[3*O+2];U-=H[3*O+3],h-=H[3*O+4],w-=H[3*O+5];J+=Math.sqrt(U*U+h*h+w*w),u[O+1]=J}return u}static SegmentizeSegmentByCount(H,u,J){const U=[],h=u.ru(H),w=O.TmpVectors.lu[0];w.jg(J);const g=O.TmpVectors.lu[1];h.divideToRef(w,g);let B=H.clone();U.push(B);for(let O=0;O<J;O++)B=B.clone(),U.push(B.addInPlace(g));return U}static SegmentizeLineBySegmentLength(H,u){const J=H[0]instanceof O.lu?eH.GetLineSegments(H):"number"===typeof H[0]?eH.GetLineSegments(eH.ToVector3Array(H)):H,U=[];for(const O of J)if(O.length>u){const H=eH.SegmentizeSegmentByCount(O.point1,O.point2,Math.ceil(O.length/u));for(const u of H)U.push(u)}else U.push(O.point1),U.push(O.point2);return U}static SegmentizeLineBySegmentCount(H,u){const J="number"===typeof H[0]?eH.ToVector3Array(H):H,O=eH.GetLineLength(J)/u;return eH.SegmentizeLineBySegmentLength(J,O)}static GetLineSegments(H){const u=[];for(let J=0;J<H.length-1;J++){const O=H[J],U=H[J+1],h=U.ru(O).length();u.push({point1:O,point2:U,length:h})}return u}static GetMinMaxSegmentLength(H){const u=eH.GetLineSegments(H).sort((H=>H.length));return{min:u[0].length,max:u[u.length-1].length}}static GetPositionOnLineByVisibility(H,u,J){let U=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const h=u*J;let w=0,g=0;const B=H.length;for(let O=0;O<B;O++){if(h<=w+H[O].length){g=O;break}w+=H[O].length}const b=(h-w)/H[g].length;return H[g].point2.subtractToRef(H[g].point1,O.TmpVectors.lu[0]),O.TmpVectors.lu[1]=O.TmpVectors.lu[0].multiplyByFloats(b,b,b),U||O.TmpVectors.lu[1].addInPlace(H[g].point1),O.TmpVectors.lu[1].clone()}static GetCircleLinePoints(H,u){let J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:H,h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/u;const w=[];for(let g=0;g<=u;g++)w.push(new O.lu(Math.cos(g*h)*H,Math.sin(g*h)*U,J));return w}static GetBezierLinePoints(H,u,J,O){return AH.e.CreateQuadraticBezier(H,u,J,O).getPoints().flatMap((H=>[H.x,H.y,H.z]))}static GetArrowCap(H,u,J,O,U){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,w=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[H.clone(),H.add(u.multiplyByFloats(J,J,J))],widths:[O,U,h,w]}}static GetPointsFromText(H,u,J,O){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const w=[],g=(0,tH.b)(H,u,J,O);for(const B of g){for(const H of B.paths){const u=[],J=H.getPoints();for(const H of J)u.push(H.x,H.y,U);w.push(u)}if(h)for(const H of B.holes){const u=[],J=H.getPoints();for(const H of J)u.push(H.x,H.y,U);w.push(u)}}return w}static Color3toRGBAUint8(H){const u=new Uint8Array(4*H.length);for(let J=0,O=0;J<H.length;J++)u[O++]=255*H[J].r,u[O++]=255*H[J].g,u[O++]=255*H[J].b,u[O++]=255;return u}static CreateColorsTexture(H,u,J,O){const U=O.getEngine().getCaps().maxTextureSize??1,h=u.length>U?U:u.length,w=Math.ceil(u.length/U);w>1&&(u=[...u,...Array(h*w-u.length).fill(u[0])]);const g=eH.Color3toRGBAUint8(u),B=new L.d(g,h,w,l.e.TEXTUREFORMAT_RGBA,O,!1,!0,J);return B.name=H,B}static PrepareEmptyColorsTexture(H){if(!sH.EmptyColorsTexture){const u=new Uint8Array(4);sH.EmptyColorsTexture=new L.d(u,1,1,l.e.TEXTUREFORMAT_RGBA,H,!1,!1,L.d.NEAREST_NEAREST),sH.EmptyColorsTexture.name="grlEmptyColorsTexture"}return sH.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var H;null===(H=sH.EmptyColorsTexture)||void 0===H||H.dispose(),sH.EmptyColorsTexture=null}static BooleanToNumber(H){return H?1:0}}class cH extends YH.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class nH extends ZH.b{isCompatible(H){return!0}constructor(H,u,J){var U;J=J||{color:sH.DEFAULT_COLOR};const h=new cH;h.GREASED_LINE_HAS_COLOR=!!J.color&&!J.useColors,h.GREASED_LINE_SIZE_ATTENUATION=J.sizeAttenuation??!1,h.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===J.colorDistributionType,h.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(u??H.ZH()).useRightHandedSystem,h.GREASED_LINE_CAMERA_FACING=J.cameraFacing??!0,super(H,nH.GREASED_LINE_MATERIAL_NAME,200,h,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(U=J)||void 0===U?void 0:U.forceGLSL)||nH.ForceGLSL,this._scene=u??H.ZH(),this._engine=this._scene.getEngine(),this._cameraFacing=J.cameraFacing??!0,this.visibility=J.visibility??1,this.useDash=J.useDash??!1,this.dashRatio=J.dashRatio??.5,this.dashOffset=J.dashOffset??0,this.width=J.width?J.width:J.sizeAttenuation?sH.DEFAULT_WIDTH_ATTENUATED:sH.DEFAULT_WIDTH,this._sizeAttenuation=J.sizeAttenuation??!1,this.colorMode=J.colorMode??0,this._color=J.color??null,this.useColors=J.useColors??!1,this._colorsDistributionType=J.colorDistributionType??0,this.colorsSampling=J.colorsSampling??L.d.NEAREST_NEAREST,this._colors=J.AH??null,this.dashCount=J.dashCount??1,this.resolution=J.resolution??new O.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),J.colorsTexture?this.colorsTexture=J.colorsTexture:this._colors?this.colorsTexture=eH.CreateColorsTexture(`${H.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??sH.DEFAULT_COLOR,eH.PrepareEmptyColorsTexture(this._scene)),this._engine.nh.add((()=>{eH.DisposeEmptyColorsTexture()}))}getAttributes(H){H.push("grl_offsets"),H.push("grl_widths"),H.push("grl_colorPointers"),H.push("grl_counters"),this._cameraFacing?(H.push("grl_previousAndSide"),H.push("grl_nextAndCounters")):H.push("grl_slopes")}getSamplers(H){H.push("grl_colors")}getActiveTextures(H){this.colorsTexture&&H.push(this.colorsTexture)}getUniforms(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const u=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&u.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===H&&u.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:u,vertex:this._cameraFacing&&this._isGLSL(H)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(H)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(H){if(this._cameraFacing){H.wg("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||H.wg("viewProjection",this._scene.getTransformMatrix());const u=O.TmpVectors.Vector4[0];u.x=this._aspect,u.y=this._resolution.x,u.z=this._resolution.y,u.w=this.width,H.updateVector4("grl_aspect_resolution_lineWidth",u)}const u=O.TmpVectors.Vector4[0];u.x=eH.BooleanToNumber(this.useDash),u.y=this._dashArray,u.z=this.dashOffset,u.w=this.dashRatio,H.updateVector4("grl_dashOptions",u);const J=O.TmpVectors.Vector4[1];J.x=this.colorMode,J.y=this.visibility,J.z=this.colorsTexture?this.colorsTexture.getSize().width:0,J.w=eH.BooleanToNumber(this.useColors),H.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",J),this._color&&H.updateColor3("grl_singleColor",this._color);const U=this.colorsTexture??sH.EmptyColorsTexture;H.setTexture("grl_colors",U),H.updateFloat2("grl_textureSize",(null===U||void 0===U?void 0:U.getSize().width)??1,(null===U||void 0===U?void 0:U.getSize().height)??1)}prepareDefines(H,u,J){H.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,H.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,H.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,H.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=u.useRightHandedSystem,H.GREASED_LINE_CAMERA_FACING=this._cameraFacing,H.GREASED_LINE_USE_OFFSETS=!!J.offsets}getClassName(){return nH.GREASED_LINE_MATERIAL_NAME}getCustomCode(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(u)?function(H,u){if("vertex"===H){const H={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return u&&(H["!gl_Position\\=viewProjection\\*worldPos;"]="//"),H}return"fragment"===H?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(H,this._cameraFacing):function(H,u){if("vertex"===H){const H={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return u&&(H["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),H}return"fragment"===H?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(H,this._cameraFacing)}dispose(){var H;null===(H=this.colorsTexture)||void 0===H||H.dispose(),super.dispose()}get AH(){return this._colors}set AH(H){this.setColors(H)}setColors(H){var u;let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1],O=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const U=(null===(u=this._colors)||void 0===u?void 0:u.length)??0;var h;if(this._colors=H,null!==H&&0!==H.length){if(!J||O)if(this.colorsTexture&&U===H.length&&!O){const u=eH.Color3toRGBAUint8(H);this.colorsTexture.update(u)}else{var w;null===(w=this.colorsTexture)||void 0===w||w.dispose(),this.colorsTexture=eH.CreateColorsTexture(`${this._material.name}-colors-texture`,H,this.colorsSampling,this._scene)}}else null===(h=this.colorsTexture)||void 0===h||h.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(H){this._dashCount=H,this._dashArray=1/H}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(H){this._sizeAttenuation=H,this.markAllDefinesAsDirty()}get color(){return this._color}set color(H){this.setColor(H)}setColor(H){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==H||null!==this._color&&null===H?(this._color=H,u||this.markAllDefinesAsDirty()):this._color=H}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(H){this._colorsDistributionType=H,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(H){this._aspect=H.x/H.y,this._resolution=H}serialize(){const H=super.serialize(),u={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(u.AH=this._colors),this._color&&(u.color=this._color),H.greasedLineMaterialOptions=u,H}parse(H,u,J){var O;super.parse(H,u,J);const U=H.greasedLineMaterialOptions;null===(O=this.colorsTexture)||void 0===O||O.dispose(),U.color&&this.setColor(U.color,!0),U.colorDistributionType&&(this.colorsDistributionType=U.colorDistributionType),U.AH&&(this.AH=U.AH),U.colorsSampling&&(this.colorsSampling=U.colorsSampling),U.colorMode&&(this.colorMode=U.colorMode),U.useColors&&(this.useColors=U.useColors),U.visibility&&(this.visibility=U.visibility),U.useDash&&(this.useDash=U.useDash),U.dashCount&&(this.dashCount=U.dashCount),U.dashRatio&&(this.dashRatio=U.dashRatio),U.dashOffset&&(this.dashOffset=U.dashOffset),U.width&&(this.width=U.width),U.sizeAttenuation&&(this.sizeAttenuation=U.sizeAttenuation),U.resolution&&(this.resolution=U.resolution),this.AH?this.colorsTexture=eH.CreateColorsTexture(`${this._material.name}-colors-texture`,this.AH,this.colorsSampling,u):eH.PrepareEmptyColorsTexture(u),this.markAllDefinesAsDirty()}copyTo(H){var u;const J=H;null===(u=J.colorsTexture)||void 0===u||u.dispose(),this._colors&&(J.colorsTexture=eH.CreateColorsTexture(`${J._material.name}-colors-texture`,this._colors,J.colorsSampling,this._scene)),J.setColor(this.color,!0),J.colorsDistributionType=this.colorsDistributionType,J.colorsSampling=this.colorsSampling,J.colorMode=this.colorMode,J.useColors=this.useColors,J.visibility=this.visibility,J.useDash=this.useDash,J.dashCount=this.dashCount,J.dashRatio=this.dashRatio,J.dashOffset=this.dashOffset,J.width=this.width,J.sizeAttenuation=this.sizeAttenuation,J.resolution=this.resolution,J.markAllDefinesAsDirty()}_isGLSL(H){return 0===H||this._forceGLSL}}nH.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",nH.ForceGLSL=!1,(0,FH.f)(`BABYLON.${nH.GREASED_LINE_MATERIAL_NAME}`,nH);var VH=J(12746),TH=J(12191),RH=J(12561),XH=J(12284);class WH extends RH.ShaderMaterial{constructor(H,u,U){const h=u.getEngine(),w=h.isWebGPU&&!(U.forceGLSL||WH.ForceGLSL),g=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];u.useRightHandedSystem&&g.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const B=["position","grl_widths","grl_offsets","grl_colorPointers"];U.cameraFacing?(g.push("GREASED_LINE_CAMERA_FACING"),B.push("grl_previousAndSide","grl_nextAndCounters")):(B.push("grl_slopes"),B.push("grl_counters"));const b=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(w||b.push("world","viewProjection","view","projection"),super(H,u,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:w?["Scene","Mesh"]:void 0,attributes:B,uniforms:b,samplers:w?[]:["grlColors"],defines:g,extraInitializationsAsync:async()=>{w?await Promise.all([J.e(66).then(J.bind(J,15416)),J.e(75).then(J.bind(J,15424))]):await Promise.all([J.e(69).then(J.bind(J,15432)),J.e(76).then(J.bind(J,15437))])},shaderLanguage:w?1:0}),this._color=p.ku.White(),this._colorsDistributionType=0,this._colorsTexture=null,U=U||{color:sH.DEFAULT_COLOR},this.visibility=U.visibility??1,this.useDash=U.useDash??!1,this.dashRatio=U.dashRatio??.5,this.dashOffset=U.dashOffset??0,this.dashCount=U.dashCount??1,this.width=U.width?U.width:U.sizeAttenuation&&U.cameraFacing?sH.DEFAULT_WIDTH_ATTENUATED:sH.DEFAULT_WIDTH,this.sizeAttenuation=U.sizeAttenuation??!1,this.color=U.color??p.ku.White(),this.useColors=U.useColors??!1,this.colorsDistributionType=U.colorDistributionType??0,this.colorsSampling=U.colorsSampling??L.d.NEAREST_NEAREST,this.colorMode=U.colorMode??0,this._colors=U.AH??null,this._cameraFacing=U.cameraFacing??!0,this.resolution=U.resolution??new O.Vector2(h.getRenderWidth(),h.getRenderHeight()),U.colorsTexture?this.colorsTexture=U.colorsTexture:this._colors?this.colorsTexture=eH.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,u):(this._color=this._color??sH.DEFAULT_COLOR,this.colorsTexture=eH.PrepareEmptyColorsTexture(u)),w){const H=new XH.d;H.setParameters(),H.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",H)}h.nh.add((()=>{eH.DisposeEmptyColorsTexture()}))}dispose(){var H;null===(H=this._colorsTexture)||void 0===H||H.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new O.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get AH(){return this._colors}set AH(H){this.setColors(H)}setColors(H){var u;let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1],O=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const U=(null===(u=this._colors)||void 0===u?void 0:u.length)??0;var h;if(this._colors=H,null!==H&&0!==H.length){if(!J||O)if(this._colorsTexture&&U===H.length&&!O){const u=eH.Color3toRGBAUint8(H);this._colorsTexture.update(u)}else{var w;null===(w=this._colorsTexture)||void 0===w||w.dispose(),this.colorsTexture=eH.CreateColorsTexture(`${this.name}-colors-texture`,H,this.colorsSampling,this.ZH())}}else null===(h=this._colorsTexture)||void 0===h||h.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(H){this._colorsTexture=H,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(H){this._width=H,this.setFloat("grlWidth",H)}get useColors(){return this._useColors}set useColors(H){this._useColors=H,this.setFloat("grlUseColors",eH.BooleanToNumber(H))}get colorsSampling(){return this._colorsSampling}set colorsSampling(H){this._colorsSampling=H}get visibility(){return this._visibility}set visibility(H){this._visibility=H,this.setFloat("grlVisibility",H)}get useDash(){return this._useDash}set useDash(H){this._useDash=H,this.setFloat("grlUseDash",eH.BooleanToNumber(H))}get dashOffset(){return this._dashOffset}set dashOffset(H){this._dashOffset=H,this.setFloat("grlDashOffset",H)}get dashRatio(){return this._dashRatio}set dashRatio(H){this._dashRatio=H,this.setFloat("grlDashRatio",H)}get dashCount(){return this._dashCount}set dashCount(H){this._dashCount=H,this._dashArray=1/H,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(H){this._sizeAttenuation=H,this.setFloat("grlSizeAttenuation",eH.BooleanToNumber(H))}get color(){return this._color}set color(H){this.setColor(H)}setColor(H){H=H??sH.DEFAULT_COLOR,this._color=H,this.setColor3("grlColor",H)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(H){this._colorsDistributionType=H,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(H){this._colorMode=H,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(H){this._resolution=H,this.setVector2("grlResolution",H),this.setFloat("grlAspect",H.x/H.y)}serialize(){const H=super.serialize(),u={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(u.AH=this._colors),H.greasedLineMaterialOptions=u,H}parse(H,u,J){var O;const U=H.greasedLineMaterialOptions;null===(O=this._colorsTexture)||void 0===O||O.dispose(),U.color&&(this.color=U.color),U.colorDistributionType&&(this.colorsDistributionType=U.colorDistributionType),U.colorsSampling&&(this.colorsSampling=U.colorsSampling),U.colorMode&&(this.colorMode=U.colorMode),U.useColors&&(this.useColors=U.useColors),U.visibility&&(this.visibility=U.visibility),U.useDash&&(this.useDash=U.useDash),U.dashCount&&(this.dashCount=U.dashCount),U.dashRatio&&(this.dashRatio=U.dashRatio),U.dashOffset&&(this.dashOffset=U.dashOffset),U.width&&(this.width=U.width),U.sizeAttenuation&&(this.sizeAttenuation=U.sizeAttenuation),U.resolution&&(this.resolution=U.resolution),U.AH?this.colorsTexture=eH.CreateColorsTexture(`${this.name}-colors-texture`,U.AH,this.colorsSampling,this.ZH()):this.colorsTexture=eH.PrepareEmptyColorsTexture(u),this._cameraFacing=U.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var fH,iH,SH;WH.ForceGLSL=!1,function(H){H[H.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",H[H.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(fH||(fH={})),function(H){H[H.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",H[H.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",H[H.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(iH||(iH={})),function(H){H[H.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",H[H.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",H[H.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",H[H.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",H[H.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(SH||(SH={}));class vH extends kH.c{constructor(H,u,J){super(H,u,null,null,!1,!1),this.name=H,this._options=J,this._lazy=!1,this._updatable=!1,this._engine=u.getEngine(),this._lazy=J.lazy??!1,this._updatable=J.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=J.colorPointers??[],this._widths=J.widths??new Array(J.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(H){let u=0;for(const O of this._points)u+=O.length;const J=u/3*2-this._widths.length;for(let O=0;O<J;O++)this._widths.push(H)}updateLazy(){var H,u;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(H=this._options.ribbonOptions)||void 0===H?void 0:H.smoothShading),!this.nH&&this.refreshBoundingInfo(),null===(u=this.greasedLineMaterial)||void 0===u||u.updateLazy()}addPoints(H,u){for(const J of H)this._points.push(J);this._lazy||this.setPoints(this._points,u)}dispose(H){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(H,u)}isLazy(){return this._lazy}get tH(){return this._uvs}set tH(H){this._uvs=H instanceof Float32Array?H:new Float32Array(H),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(H){this.material instanceof WH&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===H||void 0===H?void 0:H.length)>0),this._offsets=H,this._offsetsBuffer?this._offsetsBuffer.update(H):this._createOffsetsBuffer(H)}get widths(){return this._widths}set widths(H){this._widths=H,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(H)}get colorPointers(){return this._colorPointers}set colorPointers(H){this._colorPointers=H,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(H)}get greasedLineMaterial(){var H,u;if(this.material&&this.material instanceof WH)return this.material;const J=null===(H=this.material)||void 0===H||null===(u=H.pluginManager)||void 0===u?void 0:u.getPlugin(nH.GREASED_LINE_MATERIAL_NAME);return J||void 0}get points(){const H=[];return TH.e.DeepCopy(this._points,H),H}setPoints(H,u){this._points=eH.ConvertPoints(H,(null===u||void 0===u?void 0:u.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==u&&void 0!==u&&u.colorPointers||this._updateColorPointers(),this._setPoints(this._points,u)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,tH:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(H){super.serialize(H),H.type=this.getClassName(),H.lineOptions=this._createLineOptions()}_createVertexBuffers(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new VH.d;return u.FH=this._vertexPositions,u.indices=this._indices,u.tH=this._uvs,H&&(u.sH=[],VH.d.ComputeNormals(this._vertexPositions,this._indices,u.sH)),u.cH(this,this._options.updatable),u}_createOffsetsBuffer(H){const u=this._scene.getEngine(),J=new d.b(u,H,this._updatable,3);this.setVerticesBuffer(J.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=J}}class IH{constructor(H,u){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=H,this.wasAddedByNoopNode=u}getIndicesAccessor(H,u,J,O,U){var h,w,g,B;return null===(h=this._indicesAccessorMap.get(H))||void 0===h||null===(w=h.get(u))||void 0===w||null===(g=w.get(J))||void 0===g||null===(B=g.get(O))||void 0===B?void 0:B.get(U)}setIndicesAccessor(H,u,J,O,U,h){let w=this._indicesAccessorMap.get(H);w||(w=new Map,this._indicesAccessorMap.set(H,w));let g=w.get(u);g||(g=new Map,w.set(u,g));let B=g.get(J);B||(B=new Map,g.set(J,B));let b=B.get(O);b||(b=new Map,B.set(O,b)),b.set(U,h)}pushExportedNode(H){this._exportedNodes.has(H)||this._exportedNodes.add(H)}getNodesSet(){return this._exportedNodes}getVertexBufferView(H){return this._vertexBufferViewMap.get(H)}setVertexBufferView(H,u){this._vertexBufferViewMap.set(H,u)}setRemappedBufferView(H,u,J){this._remappedBufferView.set(H,new Map),this._remappedBufferView.get(H).set(u,J)}getRemappedBufferView(H,u){var J;return null===(J=this._remappedBufferView.get(H))||void 0===J?void 0:J.get(u)}getVertexAccessor(H,u,J){var O,U;return null===(O=this._vertexAccessorMap.get(H))||void 0===O||null===(U=O.get(u))||void 0===U?void 0:U.get(J)}setVertexAccessor(H,u,J,O){let U=this._vertexAccessorMap.get(H);U||(U=new Map,this._vertexAccessorMap.set(H,U));let h=U.get(u);h||(h=new Map,U.set(u,h)),h.set(J,O)}hasVertexColorAlpha(H){return this._vertexMapColorAlpha.get(H)||!1}setHasVertexColorAlpha(H,u){return this._vertexMapColorAlpha.set(H,u)}getMesh(H){return this._meshMap.get(H)}setMesh(H,u){this._meshMap.set(H,u)}bindMorphDataToMesh(H,u){const J=this._meshMorphTargetMap.get(H)||[];this._meshMorphTargetMap.set(H,J),-1===J.indexOf(u)&&J.push(u)}getMorphTargetsFromMesh(H){return this._meshMorphTargetMap.get(H)}}class DH{_ApplyExtension(H,u,J,O){if(J>=u.length)return Promise.resolve(H);const U=O(u[J],H);return U?U.then((async H=>H?await this._ApplyExtension(H,u,J+1,O):null)):this._ApplyExtension(H,u,J+1,O)}_ApplyExtensions(H,u){const J=[];for(const O of DH._ExtensionNames)J.push(this._extensions[O]);return this._ApplyExtension(H,J,0,u)}_extensionsPreExportTextureAsync(H,u,J){return this._ApplyExtensions(u,((u,O)=>u.preExportTextureAsync&&u.preExportTextureAsync(H,O,J)))}_extensionsPostExportNodeAsync(H,u,J,O,U){return this._ApplyExtensions(u,((u,h)=>u.postExportNodeAsync&&u.postExportNodeAsync(H,h,J,O,U,this._bufferManager)))}_extensionsPostExportMaterialAsync(H,u,J){return this._ApplyExtensions(u,((u,O)=>u.postExportMaterialAsync&&u.postExportMaterialAsync(H,O,J)))}_extensionsPostExportMaterialAdditionalTextures(H,u,J){const O=[];for(const U of DH._ExtensionNames){const h=this._extensions[U];h.postExportMaterialAdditionalTextures&&O.push(...h.postExportMaterialAdditionalTextures(H,u,J))}return O}_extensionsPostExportTextures(H,u,J){for(const O of DH._ExtensionNames){const U=this._extensions[O];U.postExportTexture&&U.postExportTexture(H,u,J)}}_extensionsPostExportMeshPrimitive(H){for(const u of DH._ExtensionNames){const J=this._extensions[u];J.postExportMeshPrimitive&&J.postExportMeshPrimitive(H,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const H of DH._ExtensionNames){const u=this._extensions[H];u.preGenerateBinaryAsync&&await u.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(H){for(const u of DH._ExtensionNames){const J=this._extensions[u];J.enabled&&H(J)}}_extensionsOnExporting(){this._forEachExtensions((H=>{var u,J,O;H.wasUsed&&((u=this._glTF).extensionsUsed||(u.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(H.name)&&this._glTF.extensionsUsed.push(H.name),H.required&&((J=this._glTF).extensionsRequired||(J.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(H.name)&&this._glTF.extensionsRequired.push(H.name)),(O=this._glTF).extensions||(O.extensions={}),H.onExporting&&H.onExporting())}))}_loadExtensions(){for(const H of DH._ExtensionNames){const u=DH._ExtensionFactories[H](this);this._extensions[H]=u}}constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r.e.LastCreatedScene,u=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${l.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new X(this),this._extensions={},this._bufferManager=new dH,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!H)throw new Error("No scene available to export");this._babylonScene=H,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:H=>{var u;return null===H||void 0===H||null===(u=H.xh)||void 0===u?void 0:u.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...u},this._loadExtensions()}dispose(){for(const H in this._extensions){this._extensions[H].dispose()}}get options(){return this._options}static RegisterExtension(H,u){DH.UnregisterExtension(H)&&U.Tools.Warn(`Extension with the name ${H} already exists`),DH._ExtensionFactories[H]=u,DH._ExtensionNames.push(H)}static UnregisterExtension(H){if(!DH._ExtensionFactories[H])return!1;delete DH._ExtensionFactories[H];const u=DH._ExtensionNames.indexOf(H);return-1!==u&&DH._ExtensionNames.splice(u,1),!0}_generateJSON(H,u,J){const O={byteLength:H};return O.byteLength&&(this._glTF.buffers=[O]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.pu=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(O.uri=u+".bin"),J?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(H){const u=await this._generateBinaryAsync();this._extensionsOnExporting();const J=this._generateJSON(u.byteLength,H,!0),O=new Blob([u],{type:"application/octet-stream"}),U=H+".gltf",h=H+".bin",w=new b;if(w.files[U]=J,w.files[h]=O,this._imageData)for(const g in this._imageData)w.files[g]=new Blob([this._imageData[g].data],{type:this._imageData[g].mimeType});return w}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(H){const u=H%4;return 0===u?u:4-u}async generateGLBAsync(H){this._shouldUseGlb=!0;const u=await this._generateBinaryAsync();this._extensionsOnExporting();const J=this._generateJSON(u.byteLength),O=H+".glb";let U,h=J.length;if("undefined"!==typeof TextEncoder){U=(new TextEncoder).encode(J),h=U.length}const w=this._getPadding(h),g=this._getPadding(u.byteLength),B=28+h+w+u.byteLength+g,d=new BH(B);if(d.writeUInt32(1179937895),d.writeUInt32(2),d.writeUInt32(B),d.writeUInt32(h+w),d.writeUInt32(1313821514),U)d.writeTypedArray(U);else{const H="_".charCodeAt(0);for(let u=0;u<h;++u){const O=J.charCodeAt(u);O!=J.codePointAt(u)?d.writeUInt8(H):d.writeUInt8(O)}}for(let b=0;b<w;++b)d.writeUInt8(32);d.writeUInt32(u.byteLength+g),d.writeUInt32(5130562),d.writeTypedArray(u);for(let b=0;b<g;++b)d.writeUInt8(0);const G=new b;return G.files[O]=new Blob([d.getOutputData()],{type:"application/octet-stream"}),G}_setNodeTransformation(H,u,J){if(u.getPivotPoint().equalsWithEpsilon(v,S.d)||U.Tools.Warn("Pivot points are not supported in the glTF serializer"),!u.position.equalsWithEpsilon(v,S.d)){const U=O.TmpVectors.lu[0].O(u.position);J&&q(U),H.translation=U.Hg()}u.Cg.equalsWithEpsilon(D,S.d)||(H.scale=u.Cg.Hg());const h=u.rotationQuaternion||O.Quaternion.FromEulerAngles(u.rotation.x,u.rotation.y,u.rotation.z);h.equalsWithEpsilon(I,S.d)||(J&&E(h),H.rotation=h.normalize().Hg())}_setCameraTransformation(H,u,J){if(!u.position.equalsWithEpsilon(v,S.d)){const U=O.TmpVectors.lu[0].O(u.position);J&&q(U),H.translation=U.Hg()}const U=u.rotationQuaternion||O.Quaternion.FromEulerAngles(u.rotation.x,u.rotation.y,u.rotation.z);J&&E(U),this._babylonScene.useRightHandedSystem||Q(U),U.equalsWithEpsilon(I,S.d)||(H.rotation=U.Hg())}_listAvailableCameras(){for(const H of this._babylonScene.cameras){const u={type:H.mode===PH.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(H.name&&(u.name=H.name),"perspective"===u.type)u.perspective={aspectRatio:H.getEngine().getAspectRatio(H),yfov:H.fovMode===PH.c.FOVMODE_VERTICAL_FIXED?H.fov:H.fov*H.getEngine().getAspectRatio(H),znear:H.Ug,zfar:H.maxZ};else if("orthographic"===u.type){const J=H.orthoLeft&&H.orthoRight?.5*(H.orthoRight-H.orthoLeft):.5*H.getEngine().getRenderWidth(),O=H.orthoBottom&&H.orthoTop?.5*(H.orthoTop-H.orthoBottom):.5*H.getEngine().getRenderHeight();u.orthographic={xmag:J,ymag:O,znear:H.Ug,zfar:H.maxZ}}this._camerasMap.set(H,u)}}_exportAndAssignCameras(){const H=Array.from(this._camerasMap.values());for(const u of H){const H=this._nodesCameraMap.get(u);if(void 0!==H){this._cameras.push(u);for(const u of H)u.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const H of this._babylonScene.skeletons){if(H.bones.length<=0)continue;const u={joints:[]};this._skinMap.set(H,u)}}_exportAndAssignSkeletons(){for(const H of this._babylonScene.skeletons){if(H.bones.length<=0)continue;const u=this._skinMap.get(H);if(void 0==u)continue;const J={},O=[];let h=-1;for(let U=0;U<H.bones.length;++U){const u=H.bones[U],O=u.getIndex()??U;-1!==O&&(J[O]=u,O>h&&(h=O))}for(let H=0;H<=h;++H){const h=J[H];O.push(h.getAbsoluteInverseBindMatrix());const w=h.getTransformNode();if(null!==w){const H=this._nodeMap.get(w);w&&null!==H&&void 0!==H?u.joints.push(H):U.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else U.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const w=this._nodesSkinMap.get(u);if(u.joints.length>0&&void 0!==w){const H=64*O.length,J=new Float32Array(H/4);O.forEach(((H,u)=>{J.set(H.m,16*u)}));const U=this._bufferManager.createBufferView(J);this._accessors.push(this._bufferManager.createAccessor(U,"MAT4",5126,O.length)),u.inverseBindMatrices=this._accessors.length-1,this._skins.push(u);for(const u of w)u.skin=this._skins.length-1}}}async _exportSceneAsync(){const H={nodes:[]};if(this._babylonScene.metadata){const u=this._options.metadataSelector(this._babylonScene.metadata);u&&(H.extras=u)}const u=new Array,J=new Array,O=new Array;for(const g of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&wH(g,this._babylonScene.useRightHandedSystem)?O.push(...g.getChildren()):this._babylonScene.useRightHandedSystem?u.push(g):J.push(g);this._listAvailableCameras(),this._listAvailableSkeletons();const U=new IH(!0,!1);H.nodes.push(...await this._exportNodesAsync(J,U));const h=new IH(!1,!1);H.nodes.push(...await this._exportNodesAsync(u,h));const w=new IH(!1,!0);H.nodes.push(...await this._exportNodesAsync(O,w)),H.nodes.length&&this._scenes.push(H),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&jH._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,U.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(H){let u=this._shouldExportNodeMap.get(H);return void 0===u&&(u=this._options.shouldExportNode(H),this._shouldExportNodeMap.set(H,u)),u}async _exportNodesAsync(H,u){const J=new Array;this._exportBuffers(H,u);for(const O of H)await this._exportNodeAsync(O,J,u);return J}_collectBuffers(H,u,J,O,U){if(this._shouldExportNode(H)&&H instanceof P.c&&H.Gg){const h=H.Gg.getVertexBuffers();if(h)for(const O in h){if(!z(O))continue;const w=h[O];U.setHasVertexColorAlpha(w,H.hasVertexAlpha);const g=w._buffer,B=u.get(g)||[];u.set(g,B),-1===B.indexOf(w)&&B.push(w);const b=J.get(w)||[];J.set(w,b),-1===b.indexOf(H)&&b.push(H)}const w=H.morphTargetManager;if(w)for(let u=0;u<w.numTargets;u++){const J=w.getTarget(u),U=O.get(J)||[];O.set(J,U),-1===U.indexOf(H)&&U.push(H)}}for(const h of H.getChildren())this._collectBuffers(h,u,J,O,U)}_exportBuffers(H,u){const J=new Map,O=new Map,U=new Map;for(const g of H)this._collectBuffers(g,J,O,U,u);const h=Array.from(J.keys());for(const g of h){const H=g.getData();if(!H)throw new Error("Buffer data is not available");const U=J.get(g);if(!U)continue;const h=U[0].byteStride;if(U.some((H=>H.byteStride!==h)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const w=JH(H).slice();for(const u of U){const H=O.get(u),{byteOffset:J,byteStride:U,componentCount:h,type:g,count:B,normalized:b,kind:G}=y(u,H);switch(G){case d.d.NormalKind:case d.d.TangentKind:(0,W.i)(w,J,U,h,g,B,b,(H=>{const u=Math.sqrt(H[0]*H[0]+H[1]*H[1]+H[2]*H[2]);if(u>0){const J=1/u;H[0]*=J,H[1]*=J,H[2]*=J}}));break;case d.d.ColorKind:{const u=H.filter((H=>H.material instanceof rH.au||null==H.material)).length;if(0==u)break;if(u!=H.length){f.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}g==d.d.UNSIGNED_BYTE&&f.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const O=new p.ku,G=new p.Mg,P=this._babylonScene.getEngine().useExactSrgbConversions;(0,W.i)(w,J,U,h,g,B,b,(H=>{3===H.length?(O.mO(H,0),O.toLinearSpaceToRef(O,P),O.toArray(H,0)):(G.mO(H,0),G.toLinearSpaceToRef(G,P),G.toArray(H,0))}))}}}if(u.convertToRightHanded){for(const H of U){const u=O.get(H),{byteOffset:J,byteStride:U,componentCount:h,type:g,count:B,normalized:b,kind:G}=y(H,u);switch(G){case d.d.PositionKind:case d.d.NormalKind:case d.d.TangentKind:(0,W.i)(w,J,U,h,g,B,b,(H=>{H[0]=-H[0]}))}}u.convertedToRightHandedBuffers.set(g,w)}const B=this._bufferManager.createBufferView(w,h);u.setVertexBufferView(g,B);const b=new Map;for(const u of U){const H=O.get(u),{kind:J,totalVertices:U}=y(u,H);switch(J){case d.d.MatricesIndicesKind:case d.d.MatricesIndicesExtraKind:if(u.type==d.d.FLOAT){const H=u.getFloatData(U);null!==H&&b.set(u,H)}}}0!==b.size&&f.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const G=Array.from(b.keys());for(const J of G){const H=b.get(J);if(!H)continue;const O=H.some((H=>H>=256)),U=new(O?Uint16Array:Uint8Array)(H.length);for(let u=0;u<H.length;u++)U[u]=H[u];const h=this._bufferManager.createBufferView(U,4*(O?2:1));u.setRemappedBufferView(g,J,h)}}const w=Array.from(U.keys());for(const g of w){const H=U.get(g);if(!H)continue;const J=MH(g,H[0],this._bufferManager,this._bufferViews,this._accessors,u.convertToRightHanded);for(const O of H)u.bindMorphDataToMesh(O,J)}}async _exportNodeAsync(H,u,J){let O=this._nodeMap.get(H);if(void 0!==O)return void(u.includes(O)||u.push(O));const U=await this._createNodeAsync(H,J);if(U){O=this._nodes.length,this._nodes.push(U),this._nodeMap.set(H,O),J.pushExportedNode(H),u.push(O);const h={name:"runtime animations",channels:[],samplers:[]},w=[];this._babylonScene.animationGroups.length||(jH._CreateMorphTargetAnimationFromMorphTargetAnimations(H,h,w,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,J.convertToRightHanded,this._options.shouldExportAnimation),H.animations.length&&jH._CreateNodeAnimationFromNodeAnimations(H,h,w,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,J.convertToRightHanded,this._options.shouldExportAnimation)),h.channels.length&&h.samplers.length&&this._animations.push(h),w.forEach((H=>{H.channels.length&&H.samplers.length&&this._animations.push(H)}))}const h=U?[]:u;for(const w of H.getChildren())await this._exportNodeAsync(w,h,J);U&&h.length&&(U.children=h)}async _createNodeAsync(H,u){if(!this._shouldExportNode(H))return null;const J={};if(H.name&&(J.name=H.name),H.metadata){const u=this._options.metadataSelector(H.metadata);u&&(J.extras=u)}if(H instanceof G.c&&(this._setNodeTransformation(J,H,u.convertToRightHanded),H instanceof P.c)){const U=H instanceof mH.c?H.sourceMesh:H;if(U.mg&&U.mg.length>0&&(J.mesh=await this._exportMeshAsync(U,u)),H.skeleton){const u=this._skinMap.get(H.skeleton);var O;if(void 0!==u)void 0===this._nodesSkinMap.get(u)&&this._nodesSkinMap.set(u,[]),null===(O=this._nodesSkinMap.get(u))||void 0===O||O.push(J)}}if(H instanceof i.e){const O=this._camerasMap.get(H);if(O){var U;void 0===this._nodesCameraMap.get(O)&&this._nodesCameraMap.set(O,[]),this._setCameraTransformation(J,H,u.convertToRightHanded);const w=H.parent;if(null!==w&&uH(H,w)){const H=this._nodeMap.get(w);if(void 0!==H){var h;const u=this._nodes[H];return HH(J,u),null===(h=this._nodesCameraMap.get(O))||void 0===h||h.push(u),null}}null===(U=this._nodesCameraMap.get(O))||void 0===U||U.push(J)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",J,H,this._nodeMap,u.convertToRightHanded)?J:(f.b.Warn(`Not exporting node ${H.name}`),null)}_exportIndices(H,u,J,O,U,w,g,B,b){let d=H;b.mode=K(w);const G=g!==h.b.CounterClockWiseSideOrientation,P=!B.wasAddedByNoopNode&&G,mH=function(H){switch(H){case h.b.TriangleFillMode:case h.b.TriangleStripDrawMode:case h.b.TriangleFanDrawMode:return!0}return!1}(w)&&P;if(mH){if(w===h.b.TriangleStripDrawMode||w===h.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");b.mode=K(w);const g=u?new Uint32Array(O):new Uint16Array(O);if(H)for(let u=0;u+2<O;u+=3)g[u]=H[J+u]+U,g[u+1]=H[J+u+2]+U,g[u+2]=H[J+u+1]+U;else for(let H=0;H+2<O;H+=3)g[H]=H,g[H+1]=H+2,g[H+2]=H+1;d=g}else if(H&&0!==U){const h=u?new Uint32Array(O):new Uint16Array(O);for(let u=0;u<O;u++)h[u]=H[J+u]+U;d=h}if(d){let h=B.getIndicesAccessor(H,J,O,U,mH);if(void 0===h){const w=function(H,u,J,O){if(H instanceof Uint16Array||H instanceof Uint32Array)return H;if(H instanceof Int32Array)return new Uint32Array(H.buffer,H.byteOffset,H.length);const U=H.slice(u,u+J);return O?new Uint32Array(U):new Uint16Array(U)}(d,0,O,u),g=this._bufferManager.createBufferView(w),b=u?5125:5123;this._accessors.push(this._bufferManager.createAccessor(g,"SCALAR",b,O,0)),h=this._accessors.length-1,B.setIndicesAccessor(H,J,O,U,mH,h)}b.indices=h}}_exportVertexBuffer(H,u,J,O,U,h){const w=H.getKind();if(!z(w))return;if(w.startsWith("uv")&&!this._options.exportUnusedUVs&&(!u||!this._materialNeedsUVsSet.has(u)))return;let g=U.getVertexAccessor(H,J,O);if(void 0===g){const u=U.convertedToRightHandedBuffers.get(H._buffer)||H._buffer.getData(),h=w===d.d.PositionKind?function(H,u,J,O){const{byteOffset:U,byteStride:h,type:w,normalized:g}=u,B=u.getSize(),b=new Array(B).fill(1/0),d=new Array(B).fill(-1/0);return(0,W.i)(H,U+J*h,h,B,w,O*B,g,(H=>{for(let u=0;u<B;u++)b[u]=Math.min(b[u],H[u]),d[u]=Math.max(d[u],H[u])})),{min:b,max:d}}(u,H,J,O):void 0,B=(w===d.d.MatricesIndicesKind||w===d.d.MatricesIndicesExtraKind)&&H.type===d.d.FLOAT,b=B?d.d.UNSIGNED_BYTE:H.type,G=B?void 0:H.normalized,P=B?U.getRemappedBufferView(H._buffer,H):U.getVertexBufferView(H._buffer),mH=H.byteOffset+J*H.byteStride;this._accessors.push(this._bufferManager.createAccessor(P,function(H,u){if(H==d.d.ColorKind)return u?"VEC4":"VEC3";switch(H){case d.d.PositionKind:case d.d.NormalKind:return"VEC3";case d.d.TangentKind:case d.d.MatricesIndicesKind:case d.d.MatricesIndicesExtraKind:case d.d.MatricesWeightsKind:case d.d.MatricesWeightsExtraKind:return"VEC4";case d.d.UVKind:case d.d.UV2Kind:case d.d.UV3Kind:case d.d.UV4Kind:case d.d.UV5Kind:case d.d.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${H}`)}(w,U.hasVertexColorAlpha(H)),b,O,mH,h,G)),g=this._accessors.length-1,U.setVertexAccessor(H,J,O,g)}h.attributes[function(H){switch(H){case d.d.PositionKind:return"POSITION";case d.d.NormalKind:return"NORMAL";case d.d.TangentKind:return"TANGENT";case d.d.ColorKind:return"COLOR_0";case d.d.UVKind:return"TEXCOORD_0";case d.d.UV2Kind:return"TEXCOORD_1";case d.d.UV3Kind:return"TEXCOORD_2";case d.d.UV4Kind:return"TEXCOORD_3";case d.d.UV5Kind:return"TEXCOORD_4";case d.d.UV6Kind:return"TEXCOORD_5";case d.d.MatricesIndicesKind:return"JOINTS_0";case d.d.MatricesIndicesExtraKind:return"JOINTS_1";case d.d.MatricesWeightsKind:return"WEIGHTS_0";case d.d.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${H}`)}(w)]=g}async _exportMaterialAsync(H,u,J,O){let U=this._materialMap.get(H);if(void 0===U){const O=u&&Object.keys(u).some((H=>H.startsWith("uv")));if((H=H instanceof mu.c?H.Lg[J.materialIndex]:H)instanceof lH.b)U=await this._materialExporter.exportPBRMaterialAsync(H,"image/png",O);else{if(!(H instanceof rH.au))return void f.b.Warn(`Unsupported material '${H.name}' with type ${H.getClassName()}`);U=await this._materialExporter.exportStandardMaterialAsync(H,"image/png",O)}this._materialMap.set(H,U)}O.material=U}async _exportMeshAsync(H,u){var J;let O=u.getMesh(H);if(void 0!==O)return O;const U={primitives:[]};O=this._meshes.length,this._meshes.push(U),u.setMesh(H,O);const w=H.isUnIndexed?null:H.rg(),g=null===(J=H.Gg)||void 0===J?void 0:J.getVertexBuffers(),B=u.getMorphTargetsFromMesh(H),b=H instanceof LH.b,d=H instanceof vH,G=H.mg;if(g&&G&&G.length>0)for(const l of G){const J={attributes:{}},O=l.XH()||this._babylonScene.defaultMaterial;if(d){var P,mH;const u={name:O.name},U=H,h=p.ku.White(),w=(null===(P=U.material)||void 0===P?void 0:P.alpha)??1,g=(null===(mH=U.greasedLineMaterial)||void 0===mH?void 0:mH.color)??h;(!g.equalsWithEpsilon(h,S.d)||w<1)&&(u.pbrMetallicRoughness={baseColorFactor:[...g.Hg(),w]}),this._materials.push(u),J.material=this._materials.length-1}else if(b){const u={name:O.name},U=H;(!U.color.equalsWithEpsilon(p.ku.White(),S.d)||U.alpha<1)&&(u.pbrMetallicRoughness={baseColorFactor:[...U.color.Hg(),U.alpha]}),this._materials.push(u),J.material=this._materials.length-1}else await this._exportMaterialAsync(O,g,l,J);const G=b||d?h.b.LineListDrawMode:H.overrideRenderingFillMode??O.fillMode,r=O._getEffectiveOrientation(H);this._exportIndices(w,w?(0,W.d)(w,l.indexCount,l.indexStart,l.verticesStart):l.verticesCount>65535,w?l.indexStart:l.verticesStart,w?l.indexCount:l.verticesCount,-l.verticesStart,G,r,u,J);for(const H of Object.values(g))this._exportVertexBuffer(H,O,l.verticesStart,l.verticesCount,u,J);if(B){J.targets=[];for(const H of B)J.targets.push(H.attributes)}U.primitives.push(J),this._extensionsPostExportMeshPrimitive(J)}if(B){U.weights=[],U.extras||(U.extras={}),U.extras.targetNames=[];for(const H of B)U.weights.push(H.influence),U.extras.targetNames.push(H.name)}return O}}DH._ExtensionNames=new Array,DH._ExtensionFactories={};class oH{static async GLTFAsync(H,u,J){J&&J.exportWithoutWaitingForScene||await H.whenReadyAsync();const O=new DH(H,J),U=await O.generateGLTFAsync(u.replace(/\.[^/.]+$/,""));return O.dispose(),U}static async GLBAsync(H,u,J){J&&J.exportWithoutWaitingForScene||await H.whenReadyAsync();const O=new DH(H,J),U=await O.generateGLBAsync(u.replace(/\.[^/.]+$/,""));return O.dispose(),U}}J(12889);const yH="EXT_mesh_gpu_instancing";class xH{constructor(H){this.name=yH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(H,u,J,U,h,w){return await new Promise((H=>{if(u&&J instanceof kH.c&&J.hasThinInstances&&this._exporter){this._wasUsed=!0;const H=O.lu.Zero(),U=O.Quaternion.Identity(),g=O.lu.One(),B=J.thinInstanceGetWorldMatrices(),b=O.TmpVectors.lu[2],d=O.TmpVectors.Quaternion[1],G=O.TmpVectors.lu[3];let P=!1,mH=!1,l=!1;const r=new Float32Array(3*J.Zg),p=new Float32Array(4*J.Zg),a=new Float32Array(3*J.Zg);let k=0;for(const u of B)u.decompose(G,d,b),h&&(q(b),E(d)),r.set(b.Hg(),3*k),p.set(d.normalize().Hg(),4*k),a.set(G.Hg(),3*k),P=P||!b.equalsWithEpsilon(H),mH=mH||!d.equalsWithEpsilon(U),l=l||!G.equalsWithEpsilon(g),k++;const C={attributes:{}};P&&(C.attributes.TRANSLATION=this._buildAccessor(r,"VEC3",J.Zg,w)),mH&&(C.attributes.ROTATION=this._buildAccessor(p,"VEC4",J.Zg,w)),l&&(C.attributes.SCALE=this._buildAccessor(a,"VEC3",J.Zg,w)),u.extensions=u.extensions||{},u.extensions[yH]=C}H(u)}))}_buildAccessor(H,u,J,O){const U=O.createBufferView(H),h=O.createAccessor(U,u,5126,J);return this._exporter._accessors.push(h),this._exporter._accessors.length-1}}DH.RegisterExtension(yH,(H=>new xH(H)));var zH=J(12895),KH=J(12911),NH=J(12917),qH=J(12920);function EH(H){return H===NH.c.PositionKind?"POSITION":H===NH.c.NormalKind?"NORMAL":H===NH.c.ColorKind?"COLOR":H.startsWith(NH.c.UVKind)?"TEX_COORD":"GENERIC"}const QH={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Hu extends zH.b{static get DefaultAvailable(){return(0,zH.i)(Hu.DefaultConfiguration)}static get Default(){return Hu._Default??(Hu._Default=new Hu),Hu._Default}static ResetDefault(H){Hu._Default&&(H||Hu._Default.dispose(),Hu._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(H,u){return{module:await(u||DracoEncoderModule)({wasmBinary:H})}}_getWorkerContent(){return`${KH.l}(${KH.o})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Hu.DefaultConfiguration)}async _encodeAsync(H,u,J){const O=J?(0,qH.e)(QH,J):QH;if(this._workerPoolPromise){const J=await this._workerPoolPromise;return await new Promise(((U,h)=>{J.push(((J,w)=>{const g=H=>{J.removeEventListener("error",g),J.removeEventListener("message",B),h(H),w()},B=H=>{"encodeMeshDone"===H.data.id&&(J.removeEventListener("error",g),J.removeEventListener("message",B),U(H.data.encodedMeshData),w())};J.addEventListener("error",g),J.addEventListener("message",B);const b=[];for(const u of H)b.push(u.data.buffer);u&&b.push(u.buffer),J.postMessage({id:"encodeMesh",attributes:H,indices:u,options:O},b)}))}))}if(this._modulePromise){const J=await this._modulePromise;return(0,KH.l)(J.module,H,u,O)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(H,u){if(0==H.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");H instanceof kH.c&&H.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===u||void 0===u?void 0:u.method)&&(f.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),u.method="MESH_SEQUENTIAL_ENCODING");const J=function(H){let u=H.rg(void 0,!0);return!u||u instanceof Uint32Array||u instanceof Uint16Array||(u=((0,W.d)(u,u.length)?Uint32Array:Uint16Array).from(u)),u}(H),O=function(H,u){const J=[];for(const O of H.getVerticesDataKinds()){if(null!==u&&void 0!==u&&u.includes(O)){if(O===NH.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const U=H.getVertexBuffer(O),h=U.getSize(),w=(0,W.s)(U.getData(),h,U.type,U.byteOffset,U.byteStride,U.normalized,H.getTotalVertices(),!0);J.push({kind:O,dracoName:EH(O),size:h,data:w})}return J}(H,null===u||void 0===u?void 0:u.excludedAttributes);return await this._encodeAsync(O,J,u)}}Hu.DefaultConfiguration={wasmUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder.js`},Hu._Default=null;const uu="KHR_draco_mesh_compression";class Ju{get wasUsed(){return this._wasUsed}constructor(H){this.name=uu,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===H.options.meshCompressionMethod&&Hu.DefaultAvailable}dispose(){}postExportMeshPrimitive(H,u,J){if(!this.enabled)return;if(4!==H.mode&&5!==H.mode)return void f.b.Warn("Cannot compress primitive with mode "+H.mode+".");const O=[],U=[];let h=null;if(void 0!==H.indices){const w=J[H.indices],g=u.getBufferView(w);h=u.getData(g).slice(),O.push(g),U.push(w)}const w=[];for(const[d,G]of Object.entries(H.attributes)){const H=J[G],h=u.getBufferView(H),B=x(H.type),b=(0,W.s)(u.getData(h),B,H.componentType,H.byteOffset||0,h.byteStride||(0,W.n)(H.componentType)*B,H.normalized||!1,H.count,!0);w.push({kind:d,dracoName:(g=d,"POSITION"===g?"POSITION":"NORMAL"===g?"NORMAL":g.startsWith("COLOR")?"COLOR":g.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:x(H.type),data:b}),O.push(h),U.push(H)}var g;const B={method:H.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},b=Hu.Default._encodeAsync(w,h,B).then((J=>{if(!J)return void f.b.Error("Draco encoding failed for primitive.");const h={bufferView:-1,attributes:J.attributeIds},w=u.createBufferView(J.data);u.setBufferView(h,w);for(const H of O)this._bufferViewsUsed.add(H);for(const H of U)this._accessorsUsed.add(H);H.extensions||(H.extensions={}),H.extensions[uu]=h})).catch((H=>{f.b.Error("Draco encoding failed for primitive: "+H)}));this._encodePromises.push(b),this._wasUsed=!0}async preGenerateBinaryAsync(H){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((u=>{H.getPropertiesWithBufferView(u).every((H=>this._accessorsUsed.has(H)))&&H.removeBufferView(u)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}DH.RegisterExtension(uu,(H=>new Ju(H)));var Ou=J(12926);const Uu="KHR_lights_punctual",hu={name:"",color:[1,1,1],Yg:1,range:Number.MAX_VALUE},wu={innerConeAngle:0,outerConeAngle:Math.PI/4},gu=O.lu.Backward();class Bu{constructor(H){this.name=Uu,this.enabled=!0,this.required=!1,this._exporter=H}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Uu]=this._lights}async postExportNodeAsync(H,u,J,U,h){return await new Promise((w=>{if(!(J instanceof CH.d))return void w(u);const g=J.getTypeID()==CH.d.LIGHTTYPEID_POINTLIGHT?"point":J.getTypeID()==CH.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":J.getTypeID()==CH.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!g||!(J instanceof Ou.e))return f.b.Warn(`${H}: Light ${J.name} is not supported in ${Uu}`),void w(u);if(J.falloffType!==CH.d.FALLOFF_GLTF&&f.b.Warn(`${H}: Light falloff for ${J.name} does not match the ${Uu} specification!`),!J.position.equalsToFloats(0,0,0)){const H=O.TmpVectors.lu[0].O(J.position);h&&q(H),u.translation=H.Hg()}if("point"!==g){const H=J.direction.normalizeToRef(O.TmpVectors.lu[0]);h&&q(H);const U=O.Quaternion.FromUnitVectorsToRef(gu,H,O.TmpVectors.Quaternion[0]);O.Quaternion.IsIdentity(U)||(u.rotation=U.Hg())}const B={type:g,name:J.name,color:J.Fg.Hg(),Yg:J.Yg,range:J.range};if(OH(B,hu),"spot"===g){const H=J;B.spot={innerConeAngle:H.innerAngle/2,outerConeAngle:H.angle/2},OH(B.spot,wu)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(B);const b={Ph:this._lights.lights.length-1},d=J.parent;if(d&&uH(J,d)){const H=U.get(d);if(H){const J=this._exporter._nodes[H];return HH(u,J),J.extensions||(J.extensions={}),J.extensions[Uu]=b,void w(null)}}u.extensions||(u.extensions={}),u.extensions[Uu]=b,w(u)}))}}DH.RegisterExtension(Uu,(H=>new Bu(H)));var bu=J(12839);const du="KHR_materials_anisotropy";class Gu{constructor(H){this.name=du,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,u,J){const O=[];return J instanceof bu.d&&J.anisotropy.isEnabled&&!J.anisotropy.legacy?(J.anisotropy.texture&&O.push(J.anisotropy.texture),O):[]}postExportMaterialAsync(H,u,J){return new Promise((H=>{if(J instanceof bu.d){if(!J.anisotropy.isEnabled||J.anisotropy.legacy)return void H(u);this._wasUsed=!0,u.extensions=u.extensions||{};const O=this._exporter._materialExporter.getTextureInfo(J.anisotropy.texture),U={anisotropyStrength:J.anisotropy.Yg,anisotropyRotation:J.anisotropy.angle,anisotropyTexture:O??void 0};null!==U.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(J),u.extensions[du]=U}H(u)}))}}DH.RegisterExtension(du,(H=>new Gu(H)));const Pu="KHR_materials_clearcoat";class mJ{constructor(H){this.name=Pu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,u,J){const O=[];return J instanceof bu.d&&J.clearCoat.isEnabled?(J.clearCoat.texture&&O.push(J.clearCoat.texture),!J.clearCoat.useRoughnessFromMainTexture&&J.clearCoat.textureRoughness&&O.push(J.clearCoat.textureRoughness),J.clearCoat.bumpTexture&&O.push(J.clearCoat.bumpTexture),O):[]}postExportMaterialAsync(H,u,J){return new Promise((H=>{if(J instanceof bu.d){if(!J.clearCoat.isEnabled)return void H(u);this._wasUsed=!0,u.extensions=u.extensions||{};const O=this._exporter._materialExporter.getTextureInfo(J.clearCoat.texture);let h;h=J.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(J.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(J.clearCoat.textureRoughness),J.clearCoat.isTintEnabled&&U.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${J.name}`),J.clearCoat.remapF0OnInterfaceChange&&U.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${J.name}`);const w=this._exporter._materialExporter.getTextureInfo(J.clearCoat.bumpTexture),g={clearcoatFactor:J.clearCoat.Yg,clearcoatTexture:O??void 0,clearcoatRoughnessFactor:J.clearCoat.roughness,clearcoatRoughnessTexture:h??void 0,clearcoatNormalTexture:w??void 0};null===g.clearcoatTexture&&null===g.clearcoatRoughnessTexture&&null===g.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(J),u.extensions[Pu]=g}H(u)}))}}DH.RegisterExtension(Pu,(H=>new mJ(H)));const lu="KHR_materials_diffuse_transmission";function ru(H,u){const J=u.subSurface;let O=null;return J.translucencyIntensityTexture?O=J.translucencyIntensityTexture:J.thicknessTexture&&J.useMaskFromThicknessTexture&&(O=J.thicknessTexture),O&&!J.useGltfStyleTextures?(f.b.Warn(`${H}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${u.name}`,1),null):O}class pu{constructor(H){this.name=lu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,u,J){const O=[];if(J instanceof lH.b&&this._isExtensionEnabled(J)){const u=ru(H,J);return u&&O.push(u),J.subSurface.translucencyColorTexture&&O.push(J.subSurface.translucencyColorTexture),O}return O}_isExtensionEnabled(H){if(H.unlit)return!1;const u=H.subSurface;return!!u.isTranslucencyEnabled&&(!H.unlit&&!u.useAlbedoToTintTranslucency&&u.useGltfStyleTextures&&1===u.volumeIndexOfRefraction&&0===u.minimumThickness&&0===u.maximumThickness)}postExportMaterialAsync(H,u,J){return new Promise((O=>{if(J instanceof lH.b&&this._isExtensionEnabled(J)){this._wasUsed=!0;const O=J.subSurface,U=ru(H,J),h=0==O.translucencyIntensity?void 0:O.translucencyIntensity,w=this._exporter._materialExporter.getTextureInfo(U)??void 0,g=!O.translucencyColor||O.translucencyColor.equalsFloats(1,1,1)?void 0:O.translucencyColor.Hg(),B=this._exporter._materialExporter.getTextureInfo(O.translucencyColorTexture)??void 0,b={diffuseTransmissionFactor:h,diffuseTransmissionTexture:w,diffuseTransmissionColorFactor:g,diffuseTransmissionColorTexture:B};(w||B)&&this._exporter._materialNeedsUVsSet.add(J),u.extensions=u.extensions||{},u.extensions[lu]=b}O(u)}))}}DH.RegisterExtension(lu,(H=>new pu(H)));const au="KHR_materials_dispersion";class ku{constructor(){this.name=au,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(H){if(H.unlit)return!1;const u=H.subSurface;return!(!u.isRefractionEnabled&&!u.isDispersionEnabled)}postExportMaterialAsync(H,u,J){return new Promise((H=>{if(J instanceof lH.b&&this._isExtensionEnabled(J)){this._wasUsed=!0;const H={dispersion:J.subSurface.dispersion};u.extensions=u.extensions||{},u.extensions[au]=H}H(u)}))}}DH.RegisterExtension(au,(()=>new ku));const Cu="KHR_materials_emissive_strength";class ju{constructor(){this.name=Cu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(H,u,J){return await new Promise((H=>{if(!(J instanceof lH.b))return H(u);const O=J.emissiveColor.Hg(),U=Math.max(...O);if(U>1){this._wasUsed=!0,u.extensions||(u.extensions={});const H={emissiveStrength:U},O=J.emissiveColor.scale(1/H.emissiveStrength);u.emissiveFactor=O.Hg(),u.extensions[Cu]=H}return H(u)}))}}DH.RegisterExtension(Cu,(H=>new ju));const Mu="KHR_materials_ior";class Lu{constructor(){this.name=Mu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(H){return!H.unlit&&(void 0!=H.indexOfRefraction&&1.5!=H.indexOfRefraction)}postExportMaterialAsync(H,u,J){return new Promise((H=>{if(J instanceof lH.b&&this._isExtensionEnabled(J)){this._wasUsed=!0;const H={ior:J.indexOfRefraction};u.extensions=u.extensions||{},u.extensions[Mu]=H}H(u)}))}}DH.RegisterExtension(Mu,(H=>new Lu));const Zu="KHR_materials_iridescence";class Yu{constructor(H){this.name=Zu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,u,J){const O=[];return J instanceof bu.d&&J.iridescence.isEnabled?(J.iridescence.texture&&O.push(J.iridescence.texture),J.iridescence.thicknessTexture&&J.iridescence.thicknessTexture!==J.iridescence.texture&&O.push(J.iridescence.thicknessTexture),O):[]}postExportMaterialAsync(H,u,J){return new Promise((H=>{if(J instanceof bu.d){if(!J.iridescence.isEnabled)return void H(u);this._wasUsed=!0,u.extensions=u.extensions||{};const O=this._exporter._materialExporter.getTextureInfo(J.iridescence.texture),U=this._exporter._materialExporter.getTextureInfo(J.iridescence.thicknessTexture),h={iridescenceFactor:J.iridescence.Yg,iridescenceIor:J.iridescence.indexOfRefraction,iridescenceThicknessMinimum:J.iridescence.minimumThickness,iridescenceThicknessMaximum:J.iridescence.maximumThickness,iridescenceTexture:O??void 0,iridescenceThicknessTexture:U??void 0};null===h.iridescenceTexture&&null===h.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(J),u.extensions[Zu]=h}H(u)}))}}DH.RegisterExtension(Zu,(H=>new Yu(H)));const Fu="KHR_materials_sheen";class su{constructor(H){this.name=Fu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,u,J){return J instanceof lH.b&&J.sheen.isEnabled&&J.sheen.texture?[J.sheen.texture]:[]}async postExportMaterialAsync(H,u,J){return await new Promise((H=>{if(J instanceof lH.b){if(!J.sheen.isEnabled)return void H(u);this._wasUsed=!0,null==u.extensions&&(u.extensions={});const O={sheenColorFactor:J.sheen.color.Hg(),sheenRoughnessFactor:J.sheen.roughness??0};null===O.sheenColorTexture&&null===O.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(J),J.sheen.texture&&(O.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(J.sheen.texture)??void 0),J.sheen.textureRoughness&&!J.sheen.useRoughnessFromMainTexture?O.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(J.sheen.textureRoughness)??void 0:J.sheen.texture&&J.sheen.useRoughnessFromMainTexture&&(O.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(J.sheen.texture)??void 0),u.extensions[Fu]=O}H(u)}))}}DH.RegisterExtension(Fu,(H=>new su(H)));const Au="KHR_materials_specular";class tu{constructor(H){this.name=Au,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,u,J){const O=[];return J instanceof lH.b&&this._isExtensionEnabled(J)?(J.metallicReflectanceTexture&&O.push(J.metallicReflectanceTexture),J.reflectanceTexture&&O.push(J.reflectanceTexture),O):O}_isExtensionEnabled(H){return!H.unlit&&(void 0!=H.metallicF0Factor&&1!=H.metallicF0Factor||void 0!=H.metallicReflectanceColor&&!H.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(H))}_hasTexturesExtension(H){return null!=H.metallicReflectanceTexture||null!=H.reflectanceTexture}postExportMaterialAsync(H,u,J){return new Promise((H=>{if(J instanceof lH.b&&this._isExtensionEnabled(J)){this._wasUsed=!0,u.extensions=u.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(J.metallicReflectanceTexture)??void 0,O=this._exporter._materialExporter.getTextureInfo(J.reflectanceTexture)??void 0,U={specularFactor:1==J.metallicF0Factor?void 0:J.metallicF0Factor,specularTexture:H,specularColorFactor:J.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:J.metallicReflectanceColor.Hg(),specularColorTexture:O};this._hasTexturesExtension(J)&&this._exporter._materialNeedsUVsSet.add(J),u.extensions[Au]=U}H(u)}))}}DH.RegisterExtension(Au,(H=>new tu(H)));const eu="KHR_materials_transmission";class cu{constructor(H){this.name=eu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,u,J){const O=[];return J instanceof lH.b&&this._isExtensionEnabled(J)?(J.subSurface.thicknessTexture&&O.push(J.subSurface.thicknessTexture),O):O}_isExtensionEnabled(H){if(H.unlit)return!1;const u=H.subSurface;return u.isRefractionEnabled&&void 0!=u.refractionIntensity&&0!=u.refractionIntensity||this._hasTexturesExtension(H)}_hasTexturesExtension(H){return null!=H.subSurface.refractionIntensityTexture}async postExportMaterialAsync(H,u,J){if(J instanceof lH.b&&this._isExtensionEnabled(J)){this._wasUsed=!0;const O=J.subSurface,U={transmissionFactor:0===O.refractionIntensity?void 0:O.refractionIntensity};if(this._hasTexturesExtension(J)&&this._exporter._materialNeedsUVsSet.add(J),O.refractionIntensityTexture)if(O.useGltfStyleTextures){const H=await this._exporter._materialExporter.exportTextureAsync(O.refractionIntensityTexture,"image/png");H&&(U.transmissionTexture=H)}else f.b.Warn(`${H}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);u.extensions||(u.extensions={}),u.extensions[eu]=U}return u}}DH.RegisterExtension(eu,(H=>new cu(H)));const nu="KHR_materials_unlit";class Vu{constructor(){this.name=nu,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(H,u,J){return new Promise((H=>{let O=!1;J instanceof lH.b?O=J.unlit:J instanceof rH.au&&(O=J.disableLighting),O&&(this._wasUsed=!0,null==u.extensions&&(u.extensions={}),u.extensions[nu]={}),H(u)}))}}DH.RegisterExtension(nu,(()=>new Vu));const Tu="KHR_materials_volume";class Ru{constructor(H){this.name=Tu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,u,J){const O=[];return J instanceof lH.b&&this._isExtensionEnabled(J)?(J.subSurface.thicknessTexture&&O.push(J.subSurface.thicknessTexture),O):O}_isExtensionEnabled(H){if(H.unlit)return!1;const u=H.subSurface;return!(!u.isRefractionEnabled&&!u.isTranslucencyEnabled)&&(void 0!=u.maximumThickness&&0!=u.maximumThickness||void 0!=u.tintColorAtDistance&&u.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=u.tintColor&&u.tintColor!=p.ku.White()||this._hasTexturesExtension(H))}_hasTexturesExtension(H){return null!=H.subSurface.thicknessTexture}postExportMaterialAsync(H,u,J){return new Promise((H=>{if(J instanceof lH.b&&this._isExtensionEnabled(J)){this._wasUsed=!0;const H=J.subSurface,O={thicknessFactor:0==H.maximumThickness?void 0:H.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(H.thicknessTexture)??void 0,attenuationDistance:H.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:H.tintColorAtDistance,attenuationColor:H.tintColor.equalsFloats(1,1,1)?void 0:H.tintColor.Hg()};this._hasTexturesExtension(J)&&this._exporter._materialNeedsUVsSet.add(J),u.extensions=u.extensions||{},u.extensions[Tu]=O}H(u)}))}}DH.RegisterExtension(Tu,(H=>new Ru(H)));const Xu="EXT_materials_diffuse_roughness";class Wu{constructor(H){this.name=Xu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,u,J){const O=[];return J instanceof bu.d&&J._baseDiffuseRoughness?(J._baseDiffuseRoughnessTexture&&O.push(J._baseDiffuseRoughnessTexture),O):[]}postExportMaterialAsync(H,u,J){return new Promise((H=>{if(J instanceof bu.d){if(!J._baseDiffuseRoughness)return void H(u);this._wasUsed=!0,u.extensions=u.extensions||{};const O=this._exporter._materialExporter.getTextureInfo(J._baseDiffuseRoughnessTexture),U={diffuseRoughnessFactor:J._baseDiffuseRoughness,diffuseRoughnessTexture:O??void 0};null!==U.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(J),u.extensions[Xu]=U}H(u)}))}}DH.RegisterExtension(Xu,(H=>new Wu(H)));const fu="KHR_texture_transform";class iu{constructor(){this.name=fu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(H,u,J){if(J.ZH()||U.Tools.Warn(`${H}: /*@__KEY__*/"scene" is not defined for Babylon texture ${J.name}!`),(0!==J.uAng||0!==J.vAng)&&(U.Tools.Warn(`${H}: Texture ${J.name} with rotation in the u or v axis is not supported in glTF.`),0!==J.uRotationCenter||0!==J.vRotationCenter))return;const O={};let h=!1;if(0===J.uOffset&&0===J.vOffset||(O.offset=[J.uOffset,J.vOffset],h=!0),1===J.uScale&&1===J.vScale||(O.scale=[J.uScale,J.vScale],h=!0),0!==J.wAng){if(0!==J.uRotationCenter||0!==J.vRotationCenter){if(J.homogeneousRotationInUVTransform&&J.uScale!==J.vScale)return void U.Tools.Warn(`${H}: Texture ${J.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${fu}.`);U.Tools.Warn(`${H}: Texture ${J.name} with non-origin rotation center will be exported using an adjusted offset with ${fu}.`),O.offset=function(H){const{uOffset:u,vOffset:J,uRotationCenter:O,vRotationCenter:U,uScale:h,vScale:w,wAng:g}=H,B=Math.cos(g),b=Math.sin(g),d=O*h,G=U*w;return[u+(d*(1-B)+G*b),J+(G*(1-B)-d*b)]}(J)}O.rotation=-J.wAng,h=!0}0!==J.coordinatesIndex&&(O.texCoord=J.coordinatesIndex,h=!0),h&&(this._wasUsed=!0,u.extensions||(u.extensions={}),u.extensions[fu]=O)}}DH.RegisterExtension(fu,(()=>new iu));class Su{static CreateSTL(H){let u=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",U=arguments.length>3&&void 0!==arguments[3]&&arguments[3],h=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],w=arguments.length>5&&void 0!==arguments[5]&&arguments[5],g=arguments.length>6&&void 0!==arguments[6]&&arguments[6],B=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const b=function(H,u,J){const U=[3*H[J],3*H[J+1],3*H[J+2]],h=[new O.lu(u[U[0]],u[U[0]+2],u[U[0]+1]),new O.lu(u[U[1]],u[U[1]+2],u[U[1]+1]),new O.lu(u[U[2]],u[U[2]+2],u[U[2]+1])],w=h[0].ru(h[1]),g=h[2].ru(h[1]);return{v:h,n:O.lu.Cross(g,w).normalize()}},G=function(H,u,J,O){return u=P(H,u,J.x,O),u=P(H,u,J.y,O),P(H,u,J.z,O)},P=function(H,u,J,O){return H.setFloat32(u,J,O),u+4},l=function(H){if(g){let u=H;H instanceof mH.c&&(u=H.sourceMesh);const J=u.getVerticesData(d.d.PositionKind,!0,!0);if(!J)return[];const U=O.lu.Zero();let h;for(h=0;h<J.length;h+=3)O.lu.TransformCoordinatesFromFloatsToRef(J[h],J[h+1],J[h+2],H.dg(!0),U).toArray(J,h);return J}return H.getVerticesData(d.d.PositionKind)||[]};g&&(w=!0);let r="",p=0,a=0;if(U){for(let J=0;J<H.length;J++){const u=H[J].rg();p+=u?u.length/3:0}const u=new ArrayBuffer(84+50*p);r=new DataView(u),a+=80,r.setUint32(a,p,h),a+=4}else B||(r="solid stlmesh\r\n");for(let O=0;O<H.length;O++){const u=H[O];!U&&B&&(r+="solid "+u.name+"\r\n"),!w&&u instanceof kH.c&&u.bakeCurrentTransformIntoVertices();const J=l(u),g=u.rg()||[];for(let H=0;H<g.length;H+=3){const u=b(g,J,H);U?(a=G(r,a,u.n,h),a=G(r,a,u.v[0],h),a=G(r,a,u.v[1],h),a=G(r,a,u.v[2],h),a+=2):(r+="\tfacet normal "+u.n.x+" "+u.n.y+" "+u.n.z+"\r\n",r+="\t\touter loop\r\n",r+="\t\t\tvertex "+u.v[0].x+" "+u.v[0].y+" "+u.v[0].z+"\r\n",r+="\t\t\tvertex "+u.v[1].x+" "+u.v[1].y+" "+u.v[1].z+"\r\n",r+="\t\t\tvertex "+u.v[2].x+" "+u.v[2].y+" "+u.v[2].z+"\r\n",r+="\t\tendloop\r\n",r+="\tendfacet\r\n")}!U&&B&&(r+="endsolid "+name+"\r\n")}if(U||B||(r+="endsolid stlmesh"),u){const H=document.createElement("a"),u=new Blob([r],{type:"application/octet-stream"});H.href=window.URL.createObjectURL(u),H.download=J+".stl",H.click()}return r}}function vu(H,u){let J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const O=[];for(let U=0;U<H.length/J;U++){const h=H[U*J],w=H[U*J+1],g=H[U*J+2];O.push(`(${h.toPrecision(u.precision)}, ${w.toPrecision(u.precision)}, ${g.toPrecision(u.precision)})`)}return O.join(", ")}function Iu(H,u){const J=[];for(let O=0;O<H.length/2;O++){const U=H[2*O],h=H[2*O+1];J.push(`(${U.toPrecision(u.precision)}, ${(1-h).toPrecision(u.precision)})`)}return J.join(", ")}function Du(H,u){const J=H.getVerticesData(d.d.PositionKind),O=H.getVerticesData(d.d.NormalKind);if(J&&O)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(H){var u;const J=null!==(u=H.rg())&&void 0!==u&&u.length?H.getTotalIndices():H.getTotalVertices();return Array(J/3).fill(3).join(", ")}(H)}]\n\t\tint[] faceVertexIndices = [${function(H){const u=H.rg(),J=[];if(null!==u)for(let O=0;O<u.length;O++)J.push(u[O]);else{const u=H.getTotalVertices();for(let H=0;H<u;H++)J.push(H)}return J.join(", ")}(H)}]\n\t\tnormal3f[] normals = [${vu(O,u)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${vu(J,u)}]\n        ${function(H,u){let J="";for(let U=0;U<4;U++){const O=U>0?U:"",h=H.getVerticesData(d.d.UVKind+(O?O+1:""));h&&(J+=`\n\t\ttexCoord2f[] primvars:st${O} = [${Iu(h,u)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const O=H.getVerticesData(d.d.ColorKind);return O&&(J+=`\n\tcolor3f[] primvars:displayColor = [${vu(O,u,O.length/H.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),J}(H,u)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function ou(H,u){return`\n        def "Geometry"\n        {\n        ${Du(H,u)}\n        }\n        `}function yu(H){let u='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return u+=H,fflate.strToU8(u)}function xu(H){const u=H.m;return`( ${zu(u,0)}, ${zu(u,4)}, ${zu(u,8)}, ${zu(u,12)} )`}function zu(H,u){return`(${H[u+0]}, ${H[u+1]}, ${H[u+2]}, ${H[u+3]})`}function Ku(H){const u="Object_"+H.uniqueId,J=function(H){const u=H.getWorldMatrix().clone(),J=H.ZH().useRightHandedSystem;if(!J){let O=H.parent;for(;O;){if(wH(O,J)){u.multiplyToRef(O.getWorldMatrix().invert(),u);break}O=O.parent}}return u.determinant()<0&&U.Tools.Warn(`Exporting mesh ${H.name} with negative scale. Result may look incorrect in destination engine.`),u}(H),O=xu(J);return`def Xform "${u}" (\n\tprepend references = @./geometries/Geometry_${H.Gg.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${O}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${H.material.uniqueId}>\n}\n\n`}function Nu(H){switch(H){case Z.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case Z.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case Z.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function qu(H){return`(${H.x}, ${H.y})`}function Eu(H){return`(${H.r}, ${H.g}, ${H.b})`}function Qu(H,u,J,U,h,w){const g=H.getInternalTexture().uniqueId+"_"+H.invertY;h[g]=H;const B=H.coordinatesIndex>0?"st"+H.coordinatesIndex:"st",b=new O.Vector2(H.uScale,H.vScale),d=new O.Vector2(H.uOffset,H.vOffset),G=H.wAng,P=Math.sin(G),mH=Math.cos(G);return d.y=1-d.y-b.y,d.x+=P*b.x,d.y+=(1-mH)*b.y,`\n    def Shader "PrimvarReader_${J}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${B}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${J}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${u.uniqueId}/PrimvarReader_${J}.outputs:result>\n        float inputs:rotation = ${(G*(180/Math.PI)).toFixed(w.precision)}\n        float2 inputs:scale = ${qu(b)}\n        float2 inputs:translation = ${qu(d)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${H.uniqueId}_${J}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${g}.png@\n        float2 inputs:st.connect = </Materials/Material_${u.uniqueId}/Transform2d_${J}.outputs:result>\n        ${U?"float4 inputs:scale = "+function(H){return`(${H.r}, ${H.g}, ${H.b}, 1.0)`}(U):""}\n        token inputs:sourceColorSpace = "${H.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Nu(H.wrapU)}"\n        token inputs:wrapT = "${Nu(H.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${u.needAlphaBlending()?"float outputs:a":""}\n    }`}function HJ(H,u,J){const O="\t\t\t",U=[],h=[],{diffuseMap:w,Fg:g,alphaCutOff:B,emissiveMap:b,emissive:d,normalMap:G,roughnessMap:P,roughnessChannel:mH,roughness:l,metalnessMap:r,metalnessChannel:a,metalness:k,aoMap:C,aoMapChannel:j,aoMapIntensity:M,alphaMap:L,ior:Z,clearCoatEnabled:Y,clearCoat:F,clearCoatMap:s,clearCoatRoughness:A,clearCoatRoughnessMap:t}=function(H){const u={diffuseMap:null,Fg:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return H instanceof rH.au?{...u,diffuseMap:H.diffuseTexture,Fg:H.diffuseColor,alphaCutOff:H.alphaCutOff,emissiveMap:H.emissiveTexture,emissive:H.emissiveColor,roughness:1,alphaMap:H.opacityTexture}:H instanceof bu.d?{...u,diffuseMap:H._albedoTexture,Fg:H._albedoColor,alphaCutOff:H._alphaCutOff,emissiveMap:H._emissiveTexture,emissive:H._emissiveColor,normalMap:H._bumpTexture,roughnessMap:H._metallicTexture,roughnessChannel:H._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:H._roughness??1,metalnessMap:H._metallicTexture,metalnessChannel:H._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:H._metallic??0,aoMap:H._ambientTexture,aoMapChannel:H._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:H._ambientTextureStrength,alphaMap:H._opacityTexture,ior:H.subSurface.indexOfRefraction,clearCoatEnabled:H.clearCoat.isEnabled,clearCoat:H.clearCoat.Yg,clearCoatMap:H.clearCoat.texture,clearCoatRoughness:H.clearCoat.roughness,clearCoatRoughnessMap:H.clearCoat.useRoughnessFromMainTexture?H.clearCoat.texture:H.clearCoat.textureRoughness}:u}(H);return null!==w?(U.push(`${O}color3f inputs:diffuseColor.connect = </Materials/Material_${H.uniqueId}/Texture_${w.uniqueId}_diffuse.outputs:rgb>`),H.needAlphaBlending()?U.push(`${O}float inputs:opacity.connect = </Materials/Material_${H.uniqueId}/Texture_${w.uniqueId}_diffuse.outputs:a>`):H.needAlphaTesting()&&(U.push(`${O}float inputs:opacity.connect = </Materials/Material_${H.uniqueId}/Texture_${w.uniqueId}_diffuse.outputs:a>`),U.push(`${O}float inputs:opacityThreshold = ${B}`)),h.push(Qu(w,H,"diffuse",g,u,J))):U.push(`${O}color3f inputs:diffuseColor = ${Eu(g||p.ku.White())}`),null!==b?(U.push(`${O}color3f inputs:emissiveColor.connect = </Materials/Material_${H.uniqueId}/Texture_${b.uniqueId}_emissive.outputs:rgb>`),h.push(Qu(b,H,"emissive",d,u,J))):d&&d.toLuminance()>0&&U.push(`${O}color3f inputs:emissiveColor = ${Eu(d)}`),null!==G&&(U.push(`${O}normal3f inputs:normal.connect = </Materials/Material_${H.uniqueId}/Texture_${G.uniqueId}_normal.outputs:rgb>`),h.push(Qu(G,H,"normal",null,u,J))),null!==C&&(U.push(`${O}float inputs:occlusion.connect = </Materials/Material_${H.uniqueId}/Texture_${C.uniqueId}_occlusion.outputs:${j}>`),h.push(Qu(C,H,"occlusion",new p.ku(M,M,M),u,J))),null!==P?(U.push(`${O}float inputs:roughness.connect = </Materials/Material_${H.uniqueId}/Texture_${P.uniqueId}_roughness.outputs:${mH}>`),h.push(Qu(P,H,"roughness",new p.ku(l,l,l),u,J))):U.push(`${O}float inputs:roughness = ${l}`),null!==r?(U.push(`${O}float inputs:metallic.connect = </Materials/Material_${H.uniqueId}/Texture_${r.uniqueId}_metallic.outputs:${a}>`),h.push(Qu(r,H,"metallic",new p.ku(k,k,k),u,J))):U.push(`${O}float inputs:metallic = ${k}`),null!==L?(U.push(`${O}float inputs:opacity.connect = </Materials/Material_${H.uniqueId}/Texture_${L.uniqueId}_opacity.outputs:r>`),U.push(`${O}float inputs:opacityThreshold = 0.0001`),h.push(Qu(L,H,"opacity",null,u,J))):U.push(`${O}float inputs:opacity = ${H.alpha}`),Y&&(null!==s?(U.push(`${O}float inputs:clearcoat.connect = </Materials/Material_${H.uniqueId}/Texture_${s.uniqueId}_clearcoat.outputs:r>`),h.push(Qu(s,H,"clearcoat",new p.ku(F,F,F),u,J))):U.push(`${O}float inputs:clearcoat = ${F}`),null!==t?(U.push(`${O}float inputs:clearcoatRoughness.connect = </Materials/Material_${H.uniqueId}/Texture_${t.uniqueId}_clearcoatRoughness.outputs:g>`),h.push(Qu(t,H,"clearcoatRoughness",new p.ku(A,A,A),u,J))):U.push(`${O}float inputs:clearcoatRoughness = ${A}`)),U.push(`${O}float inputs:ior = ${Z}`),`\n\tdef Material "Material_${H.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${U.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${H.uniqueId}/PreviewSurface.outputs:surface>\n\n${h.join("\n")}\n\n\t}\n`}async function uJ(H,u,J){const h={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...u};"undefined"===typeof fflate&&await U.Tools.LoadScriptAsync(h.fflateUrl);const w={};w[h.modelFileName]=null;let g='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';g+=function(H){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===H.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${H.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${H.planeAnchoringAlignment}"`:""}\n            `}(h);const B={};for(const O of H.meshes){if(0===O.getTotalVertices())continue;const H=O,u=H.Gg,b=H.material;if(!b||!u||J&&!J(H))continue;if(-1!==["au","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(b.getClassName())){const J="geometries/Geometry_"+u.uniqueId+".usda";if(!(J in w)){const H=ou(u,h);w[J]=yu(H)}b.uniqueId in B||(B[b.uniqueId]=b),g+=Ku(H)}else U.Tools.Warn("USDZExportAsync does not support this material type: "+b.getClassName())}H.activeCamera&&h.exportCamera&&(g+=function(H,u){const J="Camera_"+H.uniqueId,U=xu(O.Matrix.RotationY(Math.PI).multiply(H.getWorldMatrix()));if(H.mode===Z.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${J}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${U}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${H.Ug.toPrecision(u.precision)}, ${H.maxZ.toPrecision(u.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(H.orthoLeft||1)+Math.abs(H.orthoRight||1))).toPrecision(u.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(H.orthoTop||1)+Math.abs(H.orthoBottom||1))).toPrecision(u.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const O=H.getEngine().getAspectRatio(H),h=u.cameraSensorWidth||35;return`def Camera "${J}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${U}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${H.Ug.toPrecision(u.precision)}, ${H.maxZ.toPrecision(u.precision)})\n\t\t\tfloat focalLength = ${(h/(2*Math.tan(.5*H.fov))).toPrecision(u.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(h*O).toPrecision(u.precision)}\n\t\t\tfloat verticalAperture = ${(h/O).toPrecision(u.precision)}            \n\t\t}\n\t\n\t`}}(H.activeCamera,h)),g+="\n            }\n        }\n    }";const b={};g+=function(H,u,J){const O=[];for(const U in H){const h=H[U];O.push(HJ(h,u,J))}return`\n    def "Materials"\n{\n${O.join("")}\n}\n\n`}(B,b,h),w[h.modelFileName]=fflate.strToU8(g);for(const O in b){const H=b[O],u=H.getSize(),J=await H.readPixels();if(!J)throw new Error("Texture data is not available");const U=await Y.DumpTools.DumpDataAsync(u.width,u.height,J,"image/png",void 0,!1,!0);w[`textures/Texture_${O}.png`]=new Uint8Array(U).slice()}let d=0;for(const O in w){const H=w[O];if(!H)continue;d+=34+O.length;const u=63&d;if(4!==u){const J=new Uint8Array(64-u);w[O]=[H,{extra:{12345:J}}]}d=H.length}return fflate.zipSync(w,{level:0})}}}]);