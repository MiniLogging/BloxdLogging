"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[26],{13230:(Y,b,C)=>{C.r(b),C.d(b,{EXT_materials_diffuse_roughness:()=>hb,EXT_mesh_gpu_instancing:()=>kY,GLTF2Export:()=>dY,GLTFData:()=>r,KHR_draco_mesh_compression:()=>Cb,KHR_lights_punctual:()=>gb,KHR_materials_anisotropy:()=>Fb,KHR_materials_clearcoat:()=>Sb,KHR_materials_diffuse_transmission:()=>Ib,KHR_materials_dispersion:()=>Qb,KHR_materials_emissive_strength:()=>pb,KHR_materials_ior:()=>Lb,KHR_materials_iridescence:()=>cb,KHR_materials_sheen:()=>Xb,KHR_materials_specular:()=>Tb,KHR_materials_transmission:()=>vb,KHR_materials_unlit:()=>Jb,KHR_materials_volume:()=>ob,KHR_texture_transform:()=>Hb,OBJExport:()=>E,STLExport:()=>ib,USDZExportAsync:()=>bC,_ConvertToGLTFPBRMetallicRoughness:()=>z,_SolveMetallic:()=>v,__IGLTFExporterExtension:()=>B});var R=C(12831),q=C(12645),A=C(13143);class E{static OBJ(Y,b,C,E){const B=[];let g=1,r=1;b&&(C||(C="mat"),B.push("mtllib "+C+".mtl"));for(let O=0;O<Y.length;O++){const C=Y[O],F=C.name||`mesh${O}}`;B.push(`o ${F}`);let y=null;if(E){const Y=C.Tb(!0);y=new R.Matrix,Y.invertToRef(y),C.bakeTransformIntoVertices(Y)}if(b){const Y=C.material;Y&&B.push("usemtl "+Y.id)}const S=C.Pb;if(!S){q.Tools.Warn("No geometry is present on the mesh");continue}const n=S.getVerticesData("position"),t=S.getVerticesData("normal"),I=S.getVerticesData("uv"),w=S.zb();let Q=0,N=0;if(!n||!w){q.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const p=Y[0].uY().useRightHandedSystem?1:-1;for(let Y=0;Y<n.length;Y+=3)B.push("v "+n[Y]*p+" "+n[Y+1]+" "+n[Y+2]),Q++;if(null!=t)for(let Y=0;Y<t.length;Y+=3)B.push("vn "+t[Y]*p+" "+t[Y+1]+" "+t[Y+2]);if(null!=I)for(let Y=0;Y<I.length;Y+=2)B.push("vt "+I[Y]+" "+I[Y+1]),N++;const mY=["","",""],L=(C.material||C.uY().defaultMaterial)._getEffectiveOrientation(C),[u,c]=L===A.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let Y=0;Y<w.length;Y+=3){const b=[String(w[Y]+g),String(w[Y+u]+g),String(w[Y+c]+g)],C=[String(w[Y]+r),String(w[Y+u]+r),String(w[Y+c]+r)],R=b,q=null!=I?C:mY,A=null!=t?b:mY;B.push("f "+R[0]+"/"+q[0]+"/"+A[0]+" "+R[1]+"/"+q[1]+"/"+A[1]+" "+R[2]+"/"+q[2]+"/"+A[2])}E&&y&&C.bakeTransformIntoVertices(y),g+=Q,r+=N}return B.join("\n")}static MTL(Y){const b=[],C=Y.material;b.push("newmtl mat1"),b.push("  Ns "+C.specularPower.toFixed(4)),b.push("  Ni 1.5000"),b.push("  d "+C.alpha.toFixed(4)),b.push("  Tr 0.0000"),b.push("  Tf 1.0000 1.0000 1.0000"),b.push("  illum 2"),b.push("  Ka "+C.ambientColor.r.toFixed(4)+" "+C.ambientColor.g.toFixed(4)+" "+C.ambientColor.b.toFixed(4)),b.push("  Kd "+C.diffuseColor.r.toFixed(4)+" "+C.diffuseColor.g.toFixed(4)+" "+C.diffuseColor.b.toFixed(4)),b.push("  Ks "+C.specularColor.r.toFixed(4)+" "+C.specularColor.g.toFixed(4)+" "+C.specularColor.b.toFixed(4)),b.push("  Ke "+C.emissiveColor.r.toFixed(4)+" "+C.emissiveColor.g.toFixed(4)+" "+C.emissiveColor.b.toFixed(4));C.ambientTexture&&b.push("  map_Ka "+C.ambientTexture.name),C.diffuseTexture&&b.push("  map_Kd "+C.diffuseTexture.name),C.specularTexture&&b.push("  map_Ks "+C.specularTexture.name),C.bumpTexture&&b.push("  map_bump -imfchan z "+C.bumpTexture.name),C.opacityTexture&&b.push("  map_d "+C.opacityTexture.name);return b.join("\n")}}var B=0,g=C(12709);class r{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const Y in this.files){const b=this.files[Y],C=new Blob([b],{type:(0,g.l)(Y)});q.Tools.Download(C,Y)}}}var O=C(12903),F=C(13239),y=C(13249),S=C(13270),n=C(12957),t=C(12702),I=C(12880),w=C(12852);const Q=w.HighestCommonFactor,N={...w,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:Q};var p=C(13062),mY=C(12814),L=C(13307),u=C(13310),c=C(13053);const l=1e-6,X=new I.rC(.04,.04,.04),j=1024,T=I.rC.White(),P=I.rC.Black();function v(Y,b,C){if(b<X.r)return 0;const R=X.r,q=Y*C/(1-X.r)+b-2*X.r,A=q*q-4*R*(X.r-b);return N.Clamp((-q+Math.sqrt(A))/(2*R),0,1)}function z(Y){const b=Y.diffuseColor.toLinearSpace(Y.uY().getEngine().useExactSrgbConversions).scale(.5),C=Y.alpha,q=function(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new R.Vector2(0,1),C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new R.Vector2(0,.1),q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new R.Vector2(0,.1),A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new R.Vector2(1300,.1);return function(Y,b,C,R,q){return(1-Y)*(1-Y)*(1-Y)*b+3*(1-Y)*(1-Y)*Y*C+3*(1-Y)*Y*Y*R+Y*Y*Y*q}(Math.pow(Y/A.x,.333333),b.y,C.y,q.y,A.y)}(N.Clamp(Y.specularPower,0,j));return{baseColorFactor:[b.r,b.g,b.b,C],metallicFactor:0,roughnessFactor:q}}function J(Y,b){b.needAlphaBlending()?Y.alphaMode="BLEND":b.needAlphaTesting()&&(Y.alphaMode="MASK",Y.alphaCutoff=b.alphaCutOff)}function U(Y,b,C){const R=new Uint8Array(Y*b*4);for(let q=0;q<R.length;q+=4)R[q]=R[q+1]=R[q+2]=R[q+3]=255;return L.b.CreateRGBATexture(R,Y,b,C)}function o(Y){if(Y instanceof Uint8Array){const b=Y.length,C=new Float32Array(Y.length);for(let R=0;R<b;++R)C[R]=Y[R]/255;return C}if(Y instanceof Float32Array)return Y;throw new Error("Unsupported pixel format!")}class G{constructor(Y){this._exporter=Y,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(Y){return Y?this._textureMap.get(Y)??null:null}async exportStandardMaterialAsync(Y,b,C){const R=z(Y),A={name:Y.name};if(null==Y.Jb||Y.Jb||(Y.twoSidedLighting||q.Tools.Warn(Y.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),A.doubleSided=!0),C){const C=[],q=Y.diffuseTexture;q&&C.push(this.exportTextureAsync(q,b).then((Y=>{Y&&(R.baseColorTexture=Y)})));const E=Y.bumpTexture;E&&C.push(this.exportTextureAsync(E,b).then((Y=>{Y&&(A.normalTexture=Y,1!==E.level&&(A.normalTexture.scale=E.level))})));const B=Y.emissiveTexture;B&&(A.emissiveFactor=[1,1,1],C.push(this.exportTextureAsync(B,b).then((Y=>{Y&&(A.emissiveTexture=Y)}))));const g=Y.ambientTexture;g&&C.push(this.exportTextureAsync(g,b).then((Y=>{if(Y){const b={index:Y.index};A.occlusionTexture=b}}))),C.length>0&&(this._exporter._materialNeedsUVsSet.add(Y),await Promise.all(C))}(Y.alpha<1||Y.opacityTexture)&&(Y.alphaMode===u.e.ALPHA_COMBINE?A.alphaMode="BLEND":q.Tools.Warn(Y.name+": glTF 2.0 does not support alpha mode: "+Y.alphaMode.toString())),Y.emissiveColor&&!Y.emissiveColor.equalsWithEpsilon(P,l)&&(A.emissiveFactor=Y.emissiveColor.cb()),A.pbrMetallicRoughness=R,J(A,Y),await this._finishMaterialAsync(A,Y,b);const E=this._exporter._materials;return E.push(A),E.length-1}async _finishMaterialAsync(Y,b,C){const R=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",Y,b),q=[];for(const A of R)q.push(this.exportTextureAsync(A,C));await Promise.all(q),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",Y,b)}async _getImageDataAsync(Y,b,R,q){const A=u.e.TEXTURETYPE_UNSIGNED_BYTE,E=this._exporter._babylonScene,B=E.getEngine(),g=B.createRawTexture(Y,b,R,u.e.TEXTUREFORMAT_RGBA,!1,!0,mY.b.NEAREST_SAMPLINGMODE,null,A);B.isWebGPU?await C.e(51).then(C.bind(C,15405)):await C.e(52).then(C.bind(C,15407)),await p.n.ApplyPostProcess("pass",g,E,A,u.e.TEXTURE_NEAREST_SAMPLINGMODE,u.e.TEXTUREFORMAT_RGBA);const r=await B._readTexturePixels(g,b,R);return await c.DumpTools.DumpDataAsync(b,R,r,q,void 0,!0,!0)}_resizeTexturesToSameDimensions(Y,b,C){const R=Y?Y.getSize():{width:0,height:0},q=b?b.getSize():{width:0,height:0};let A,E;return R.width<q.width?(A=Y&&Y instanceof mY.b?p.n.CreateResizedCopy(Y,q.width,q.height,!0):U(q.width,q.height,C),E=b):R.width>q.width?(E=b&&b instanceof mY.b?p.n.CreateResizedCopy(b,R.width,R.height,!0):U(R.width,R.height,C),A=Y):(A=Y,E=b),{texture1:A,texture2:E}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Y,b,C,R){const q=new Array;if(!Y&&!b)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const A=Y?Y.uY():b?b.uY():null;if(A){var E;const B=this._resizeTexturesToSameDimensions(Y,b,A),g=null===(E=B.texture1)||void 0===E?void 0:E.getSize();let r,O;const F=g.width,y=g.height,S=await B.texture1.readPixels(),n=await B.texture2.readPixels();if(!S)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(r=o(S),!n)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");O=o(n);const t=O.byteLength,w=new Uint8Array(t),Q=new Uint8Array(t),N=4,p=P;let mY=0,L=0;for(let Y=0;Y<y;++Y)for(let b=0;b<F;++b){const R=(F*Y+b)*N,q={diffuseColor:new I.rC(r[R],r[R+1],r[R+2]).toLinearSpace(A.getEngine().useExactSrgbConversions).multiply(C.diffuseColor),specularColor:new I.rC(O[R],O[R+1],O[R+2]).toLinearSpace(A.getEngine().useExactSrgbConversions).multiply(C.specularColor),glossiness:O[R+3]*C.glossiness},E=this._convertSpecularGlossinessToMetallicRoughness(q);p.r=Math.max(p.r,E.baseColor.r),p.g=Math.max(p.g,E.baseColor.g),p.b=Math.max(p.b,E.baseColor.b),mY=Math.max(mY,E.metallic),L=Math.max(L,E.roughness),Q[R]=255*E.baseColor.r,Q[R+1]=255*E.baseColor.g,Q[R+2]=255*E.baseColor.b,Q[R+3]=B.texture1.lb?255*r[R+3]:255,w[R]=0,w[R+1]=255*E.roughness,w[R+2]=255*E.metallic,w[R+3]=255}const u={baseColor:p,metallic:mY,roughness:L};let c=!1,X=!1;for(let Y=0;Y<y;++Y)for(let b=0;b<F;++b){const C=(F*Y+b)*N;Q[C]/=u.baseColor.r>l?u.baseColor.r:1,Q[C+1]/=u.baseColor.g>l?u.baseColor.g:1,Q[C+2]/=u.baseColor.b>l?u.baseColor.b:1;const R=I.rC.FromInts(Q[C],Q[C+1],Q[C+2]).toGammaSpace(A.getEngine().useExactSrgbConversions);Q[C]=255*R.r,Q[C+1]=255*R.g,Q[C+2]=255*R.b,R.equalsWithEpsilon(T,l)||(X=!0),w[C+1]/=u.roughness>l?u.roughness:1,w[C+2]/=u.metallic>l?u.metallic:1;I.rC.FromInts(255,w[C+1],w[C+2]).equalsWithEpsilon(T,l)||(c=!0)}return c&&q.push(this._getImageDataAsync(w,F,y,R).then((Y=>{u.metallicRoughnessTextureData=Y}))),X&&q.push(this._getImageDataAsync(Q,F,y,R).then((Y=>{u.baseColorTextureData=Y}))),await Promise.all(q).then((()=>u))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(Y){const b=this._getPerceivedBrightness(Y.diffuseColor),C=this._getPerceivedBrightness(Y.specularColor),R=1-this._getMaxComponent(Y.specularColor),q=v(b,C,R),A=Y.diffuseColor.scale(R/(1-X.r)/Math.max(1-q)),E=Y.specularColor.EC(X.scale(1-q)).scale(1/Math.max(q));let B=I.rC.Lerp(A,E,q*q);B=B.clampToRef(0,1,B);return{baseColor:B,metallic:q,roughness:1-Y.glossiness}}_getPerceivedBrightness(Y){return Y?Math.sqrt(.299*Y.r*Y.r+.587*Y.g*Y.g+.114*Y.b*Y.b):0}_getMaxComponent(Y){return Y?Math.max(Y.r,Math.max(Y.g,Y.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(Y,b,C,R){const q=[],A={baseColor:Y._albedoColor,metallic:Y._metallic,roughness:Y._roughness};if(R){Y._albedoTexture&&q.push(this.exportTextureAsync(Y._albedoTexture,b).then((Y=>{Y&&(C.baseColorTexture=Y)})));const R=Y._metallicTexture;R&&q.push(this.exportTextureAsync(R,b).then((Y=>{Y&&(C.metallicRoughnessTexture=Y)})))}return q.length>0&&(this._exporter._materialNeedsUVsSet.add(Y),await Promise.all(q)),A}_getTextureSampler(Y){const b={};if(!Y||!(Y instanceof mY.b))return b;const C=this._getGLTFTextureWrapMode(Y.wrapU);10497!==C&&(b.wrapS=C);const R=this._getGLTFTextureWrapMode(Y.wrapV);switch(10497!==R&&(b.wrapT=R),Y.samplingMode){case mY.b.LINEAR_LINEAR:b.magFilter=9729,b.minFilter=9729;break;case mY.b.LINEAR_NEAREST:b.magFilter=9729,b.minFilter=9728;break;case mY.b.NEAREST_LINEAR:b.magFilter=9728,b.minFilter=9729;break;case mY.b.NEAREST_LINEAR_MIPLINEAR:b.magFilter=9728,b.minFilter=9987;break;case mY.b.NEAREST_NEAREST:b.magFilter=9728,b.minFilter=9728;break;case mY.b.NEAREST_LINEAR_MIPNEAREST:b.magFilter=9728,b.minFilter=9985;break;case mY.b.LINEAR_NEAREST_MIPNEAREST:b.magFilter=9729,b.minFilter=9984;break;case mY.b.LINEAR_NEAREST_MIPLINEAR:b.magFilter=9729,b.minFilter=9986;break;case mY.b.NEAREST_NEAREST_MIPLINEAR:b.magFilter=9728,b.minFilter=9986;break;case mY.b.LINEAR_LINEAR_MIPLINEAR:b.magFilter=9729,b.minFilter=9987;break;case mY.b.LINEAR_LINEAR_MIPNEAREST:b.magFilter=9729,b.minFilter=9985;break;case mY.b.NEAREST_NEAREST_MIPNEAREST:b.magFilter=9728,b.minFilter=9984}return b}_getGLTFTextureWrapMode(Y){switch(Y){case mY.b.WRAP_ADDRESSMODE:return 10497;case mY.b.CLAMP_ADDRESSMODE:return 33071;case mY.b.MIRROR_ADDRESSMODE:return 33648;default:return q.Tools.Error(`Unsupported Texture Wrap Mode ${Y}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(Y,b,C,R){const q={diffuseColor:Y._albedoColor,specularColor:Y._reflectivityColor,glossiness:Y._microSurface},A=Y._albedoTexture,E=Y._reflectivityTexture,B=Y._useMicroSurfaceFromReflectivityMapAlpha;if(E&&!B)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((A||E)&&R){this._exporter._materialNeedsUVsSet.add(Y);const R=this._exportTextureSampler(A||E),B=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(A,E,q,b),g=this._exporter._textures;if(B.baseColorTextureData){const Y=this._exportImage(`baseColor${g.length}`,b,B.baseColorTextureData);C.baseColorTexture=this._exportTextureInfo(Y,R,null===A||void 0===A?void 0:A.coordinatesIndex)}if(B.metallicRoughnessTextureData){const Y=this._exportImage(`metallicRoughness${g.length}`,b,B.metallicRoughnessTextureData);C.metallicRoughnessTexture=this._exportTextureInfo(Y,R,null===E||void 0===E?void 0:E.coordinatesIndex)}return B}return this._convertSpecularGlossinessToMetallicRoughness(q)}async exportPBRMaterialAsync(Y,b,C){const R={},q={name:Y.name},A=Y.isMetallicWorkflow();if(A){const b=Y._albedoColor,C=Y.alpha;b&&(R.baseColorFactor=[b.r,b.g,b.b,C])}const E=A?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(Y,b,R,C):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(Y,b,R,C);await this._setMetallicRoughnessPbrMaterialAsync(E,Y,q,R,b,C),await this._finishMaterialAsync(q,Y,b);const B=this._exporter._materials;return B.push(q),B.length-1}async _setMetallicRoughnessPbrMaterialAsync(Y,b,C,R,A,E){if(J(C,b),Y.baseColor.equalsWithEpsilon(T,l)&&N.WithinEpsilon(b.alpha,1,l)||(R.baseColorFactor=[Y.baseColor.r,Y.baseColor.g,Y.baseColor.b,b.alpha]),null!=Y.metallic&&1!==Y.metallic&&(R.metallicFactor=Y.metallic),null!=Y.roughness&&1!==Y.roughness&&(R.roughnessFactor=Y.roughness),null==b.Jb||b.Jb||(b._twoSidedLighting||q.Tools.Warn(b.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),C.doubleSided=!0),E){const Y=[],R=b._bumpTexture;R&&Y.push(this.exportTextureAsync(R,A).then((Y=>{Y&&(C.normalTexture=Y,1!==R.level&&(C.normalTexture.scale=R.level))})));const q=b._ambientTexture;q&&Y.push(this.exportTextureAsync(q,A).then((Y=>{if(Y){const R={index:Y.index,texCoord:Y.texCoord,extensions:Y.extensions};C.occlusionTexture=R;const q=b._ambientTextureStrength;q&&(R.strength=q)}})));const E=b._emissiveTexture;E&&Y.push(this.exportTextureAsync(E,A).then((Y=>{Y&&(C.emissiveTexture=Y)}))),Y.length>0&&(this._exporter._materialNeedsUVsSet.add(b),await Promise.all(Y))}const B=b._emissiveColor;B.equalsWithEpsilon(P,l)||(C.emissiveFactor=B.cb()),C.pbrMetallicRoughness=R}_getPixelsFromTextureAsync(Y){return function(Y){switch(Y){case u.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case u.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case u.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case u.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case u.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case u.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case u.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case u.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case u.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case u.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case u.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case u.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(Y.textureFormat)?(0,p.l)(Y,Y._texture.width,Y._texture.height):(Y.textureType,u.e.TEXTURETYPE_UNSIGNED_BYTE,Y.readPixels())}async exportTextureAsync(Y,b){const C=this._exporter._extensionsPreExportTextureAsync("exporter",Y,b);return C?await C.then((async C=>C?await this._exportTextureInfoAsync(C,b):await this._exportTextureInfoAsync(Y,b))):await this._exportTextureInfoAsync(Y,b)}async _exportTextureInfoAsync(Y,b){let C=this._textureMap.get(Y);if(!C){const R=await this._getPixelsFromTextureAsync(Y);if(!R)return null;const A=this._exportTextureSampler(Y),E=Y.mimeType;if(E)switch(E){case"image/jpeg":case"image/png":case"image/webp":b=E;break;default:q.Tools.Warn(`Unsupported media type: ${E}. Exporting texture as PNG.`)}const B=this._internalTextureToImage,g=Y.getInternalTexture().uniqueId;B[g]||(B[g]={});let r=B[g][b];if(void 0===r){const C=Y.getSize();r=(async()=>{const q=await this._getImageDataAsync(R,C.width,C.height,b);return this._exportImage(Y.name,b,q)})(),B[g][b]=r}C=this._exportTextureInfo(await r,A,Y.coordinatesIndex),this._textureMap.set(Y,C),this._exporter._extensionsPostExportTextures("exporter",C,Y)}return C}_exportImage(Y,b,C){const R=this._exporter._images;let A;if(this._exporter._shouldUseGlb){A={name:Y,mimeType:b,bufferView:void 0};const R=this._exporter._bufferManager.createBufferView(new Uint8Array(C));this._exporter._bufferManager.setBufferView(A,R)}else{const E=Y.replace(/\.\/|\/|\.\\|\\/g,"_"),B=function(Y){switch(Y){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(b);let g=E+B;R.some((Y=>Y.uri===g))&&(g=`${E}_${q.Tools.RandomId()}${B}`),A={name:Y,uri:g},this._exporter._imageData[g]={data:C,mimeType:b}}return R.push(A),R.length-1}_exportTextureInfo(Y,b,C){const R=this._exporter._textures;let q=R.findIndex((C=>C.sampler==b&&C.source===Y));-1===q&&(q=R.length,R.push({source:Y,sampler:b}));const A={index:q};return C&&(A.texCoord=C),A}_exportTextureSampler(Y){const b=this._getTextureSampler(Y),C=this._exporter._samplers,R=C.findIndex((Y=>Y.minFilter===b.minFilter&&Y.magFilter===b.magFilter&&Y.wrapS===b.wrapS&&Y.wrapT===b.wrapT));return-1!==R?R:(C.push(b),C.length-1)}}var h=C(12909),e=C(12669),H=C(13314),i=C(12837);const W=R.AC.Zero(),s=R.Quaternion.Identity(),D=R.AC.One(),d=new R.AC(-1,1,1);function V(Y,b){const{byteOffset:C,byteStride:R,type:q,normalized:A}=Y,E=Y.getSize(),B=b.reduce(((Y,b)=>b.getTotalVertices()>Y?b.getTotalVertices():Y),-Number.MAX_VALUE);return{byteOffset:C,byteStride:R,componentCount:E,type:q,count:B*E,normalized:A,totalVertices:B,kind:Y.getKind()}}function k(Y){switch(Y){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function x(Y){switch(Y){case O.e.PositionKind:case O.e.NormalKind:case O.e.TangentKind:case O.e.ColorKind:case O.e.MatricesIndicesKind:case O.e.MatricesIndicesExtraKind:case O.e.MatricesWeightsKind:case O.e.MatricesWeightsExtraKind:case O.e.UVKind:case O.e.UV2Kind:case O.e.UV3Kind:case O.e.UV4Kind:case O.e.UV5Kind:case O.e.UV6Kind:return!0}return!1}function a(Y){switch(Y){case A.e.TriangleFillMode:return 4;case A.e.TriangleStripDrawMode:return 5;case A.e.TriangleFanDrawMode:return 6;case A.e.PointListDrawMode:case A.e.PointFillMode:return 0;case A.e.LineLoopDrawMode:return 2;case A.e.LineListDrawMode:return 1;case A.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${Y}`)}function M(Y){const b=Math.sqrt(Y.x*Y.x+Y.y*Y.y+Y.z*Y.z);b>0&&(Y.x/=b,Y.y/=b,Y.z/=b)}function K(Y){return Y.x*=-1,Y}function f(Y){if(Y.x*Y.x+Y.y*Y.y>.5){const b=Math.abs(Y.x),C=Math.abs(Y.y);if(b>C){const C=Math.sign(Y.x);Y.x=b,Y.y*=-C,Y.z*=-C,Y.w*=C}else{const b=Math.sign(Y.y);Y.x*=-b,Y.y=C,Y.z*=b,Y.w*=-b}}else{const b=Math.abs(Y.z),C=Math.abs(Y.w);if(b>C){const C=Math.sign(Y.z);Y.x*=-C,Y.y*=C,Y.z=b,Y.w*=-C}else{const b=Math.sign(Y.w);Y.x*=b,Y.y*=-b,Y.z*=-b,Y.w=C}}return Y}function Z(Y){Y.Ub(-Y.z,Y.w,Y.x,-Y.y)}function YY(Y,b){const C=R.AC.FromArrayToRef(b.translation||[0,0,0],0,R.TmpVectors.AC[0]),q=R.Quaternion.FromArrayToRef(b.rotation||[0,0,0,1],0,R.TmpVectors.Quaternion[0]),A=R.Matrix.ComposeToRef(D,q,C,R.TmpVectors.Matrix[0]),E=R.AC.FromArrayToRef(Y.translation||[0,0,0],0,R.TmpVectors.AC[2]),B=R.Quaternion.FromArrayToRef(Y.rotation||[0,0,0,1],0,R.TmpVectors.Quaternion[1]),g=R.Matrix.ComposeToRef(D,B,E,R.TmpVectors.Matrix[1]);A.multiplyToRef(g,g),g.decompose(void 0,q,C),C.equalsWithEpsilon(W,i.e)?delete b.translation:b.translation=C.cb(),q.equalsWithEpsilon(s,i.e)?delete b.rotation:b.rotation=q.cb(),b.scale&&delete b.scale}function bY(Y,b){if(!(b instanceof F.e))return!1;if(!(1===b.getChildren().length&&0===Y.getChildren().length&&Y.parent===b))return!1;const C=Y.uY(),R=Y instanceof H.c&&!C.useRightHandedSystem?d:D;return!!b.ob.equalsWithEpsilon(R,i.e)||(e.e.Warn(`Cannot collapse node ${Y.name} into parent node ${b.name} with modified scaling.`),!1)}function CY(Y){if(Y instanceof Array){const b=new Float32Array(Y);return new Uint8Array(b.buffer,b.byteOffset,b.byteLength)}return ArrayBuffer.isView(Y)?new Uint8Array(Y.buffer,Y.byteOffset,Y.byteLength):new Uint8Array(Y)}function RY(Y,b){for(const[C,R]of Object.entries(Y)){const q=b[C];(Array.isArray(R)&&Array.isArray(q)&&qY(R,q)||R===q)&&delete Y[C]}return Y}function qY(Y,b){return Y.length===b.length&&Y.every(((Y,C)=>Y===b[C]))}const AY=R.Matrix.Compose(new R.AC(-1,1,1),R.Quaternion.Identity(),R.AC.Zero());function EY(Y,b){if(!(Y instanceof F.e))return!1;if(b){if(!Y.getWorldMatrix().equalsWithEpsilon(R.Matrix.IdentityReadOnly,i.e))return!1}else{if(!Y.getWorldMatrix().multiplyToRef(AY,R.TmpVectors.Matrix[0]).equalsWithEpsilon(R.Matrix.IdentityReadOnly,i.e))return!1}return!(Y instanceof y.b&&Y.Pb)}const BY=new Map([[Int8Array,(Y,b,C)=>Y.setInt8(b,C)],[Uint8Array,(Y,b,C)=>Y.setUint8(b,C)],[Uint8ClampedArray,(Y,b,C)=>Y.setUint8(b,C)],[Int16Array,(Y,b,C)=>Y.setInt16(b,C,!0)],[Uint16Array,(Y,b,C)=>Y.setUint16(b,C,!0)],[Int32Array,(Y,b,C)=>Y.setInt32(b,C,!0)],[Uint32Array,(Y,b,C)=>Y.setUint32(b,C,!0)],[Float32Array,(Y,b,C)=>Y.setFloat32(b,C,!0)],[Float64Array,(Y,b,C)=>Y.setFloat64(b,C,!0)]]);class gY{writeTypedArray(Y){this._checkGrowBuffer(Y.byteLength);const b=BY.get(Y.constructor);for(let C=0;C<Y.length;C++)b(this._dataView,this._byteOffset,Y[C]),this._byteOffset+=Y.BYTES_PER_ELEMENT}constructor(Y){this._data=new Uint8Array(Y),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(Y){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,Y),this._byteOffset++}writeInt8(Y){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,Y),this._byteOffset++}writeInt16(Y){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,Y,!0),this._byteOffset+=2}writeUInt16(Y){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,Y,!0),this._byteOffset+=2}writeInt32(Y){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,Y,!0),this._byteOffset+=4}writeUInt32(Y){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,Y,!0),this._byteOffset+=4}writeFloat32(Y){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,Y,!0),this._byteOffset+=4}writeFloat64(Y){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,Y,!0),this._byteOffset+=8}_checkGrowBuffer(Y){const b=this.byteOffset+Y;if(b>this._data.byteLength){const Y=new Uint8Array(2*b);Y.set(this._data),this._data=Y,this._dataView=new DataView(this._data.buffer)}}}function rY(Y){return Y%4===0?4:Y%2===0?2:1}class OY{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(Y){let b=0;this._bufferViewToData.forEach((Y=>{b+=Y.byteLength}));const C=new gY(b),R=Array.from(this._bufferViewToData.keys()).sort(((Y,b)=>rY(b.byteLength)-rY(Y.byteLength)));for(const q of R){q.byteOffset=C.byteOffset,Y.push(q);const b=Y.length-1,R=this.getPropertiesWithBufferView(q);for(const Y of R)Y.bufferView=b;C.writeTypedArray(this._bufferViewToData.get(q)),this._bufferViewToData.delete(q)}return C.getOutputData()}createBufferView(Y,b){const C={buffer:0,byteOffset:void 0,byteLength:Y.byteLength,byteStride:b};return this._bufferViewToData.set(C,Y),C}createAccessor(Y,b,C,R,q,A,E){this._verifyBufferView(Y);const B={bufferView:void 0,componentType:C,count:R,type:b,min:null===A||void 0===A?void 0:A.min,max:null===A||void 0===A?void 0:A.max,normalized:E,byteOffset:q};return this.setBufferView(B,Y),this._accessorToBufferView.set(B,Y),B}setBufferView(Y,b){this._verifyBufferView(b);this.getPropertiesWithBufferView(b).push(Y)}removeBufferView(Y){const b=this.getPropertiesWithBufferView(Y);for(const C of b)void 0!==C.bufferView&&delete C.bufferView;this._bufferViewToData.delete(Y),this._bufferViewToProperties.delete(Y),this._accessorToBufferView.forEach(((b,C)=>{b===Y&&(void 0!==C.byteOffset&&delete C.byteOffset,this._accessorToBufferView.delete(C))}))}getBufferView(Y){const b=this._accessorToBufferView.get(Y);return this._verifyBufferView(b),b}getPropertiesWithBufferView(Y){return this._verifyBufferView(Y),this._bufferViewToProperties.set(Y,this._bufferViewToProperties.get(Y)??[]),this._bufferViewToProperties.get(Y)}getData(Y){return this._verifyBufferView(Y),this._bufferViewToData.get(Y)}_verifyBufferView(Y){if(void 0===Y||!this._bufferViewToData.has(Y))throw new Error(`BufferView ${Y} not found in BufferManager.`)}}var FY,yY=C(13279),SY=C(13303),nY=C(13320),tY=C(13196),IY=C(13351),wY=C(13357),QY=C(13273),NY=C(13366);!function(Y){Y[Y.INTANGENT=0]="INTANGENT",Y[Y.OUTTANGENT=1]="OUTTANGENT"}(FY||(FY={}));class pY{static _IsTransformable(Y){return Y&&(Y instanceof F.e||Y instanceof yY.c||Y instanceof NY.e)}static _CreateNodeAnimation(Y,b,C,R,A){if(this._IsTransformable(Y)){const E=[],B=[],g=b.getKeys(),r=pY._CalculateMinMaxKeyFrames(g),O=pY._DeduceInterpolation(g,C,R),F=O.interpolationType,y=O.shouldBakeAnimation;if(y?pY._CreateBakedAnimation(Y,b,C,r.min,r.max,b.framePerSecond,A,E,B,r,R):"LINEAR"===F||"STEP"===F?pY._CreateLinearOrStepAnimation(Y,b,C,E,B,R):"CUBICSPLINE"===F?pY._CreateCubicSplineAnimation(Y,b,C,E,B,R):pY._CreateBakedAnimation(Y,b,C,r.min,r.max,b.framePerSecond,A,E,B,r,R),E.length&&B.length){return{inputs:E,outputs:B,samplerInterpolation:F,inputsMin:y?r.min:q.Tools.FloatRound(r.min/b.framePerSecond),inputsMax:y?r.max:q.Tools.FloatRound(r.max/b.framePerSecond)}}}return null}static _DeduceAnimationInfo(Y){let b=null,C="VEC3",R=!1;const A=Y.targetProperty.split(".");switch(A[0]){case"ob":b="scale";break;case"position":b="translation";break;case"rotation":C="VEC4",b="rotation";break;case"rotationQuaternion":C="VEC4",R=!0,b="rotation";break;case"influence":C="SCALAR",b="weights";break;default:q.Tools.Error(`Unsupported animatable property ${A[0]}`)}return b?{animationChannelTargetPath:b,dataAccessorType:C,useQuaternion:R}:(q.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(Y,b,C,R,q,A,E,B,g,r,O){let F;if(pY._IsTransformable(Y)&&Y.animations)for(const y of Y.animations){if(O&&!O(y))continue;const q=pY._DeduceAnimationInfo(y);q&&(F={name:y.name,samplers:[],channels:[]},pY._AddAnimation(`${y.name}`,y.hasRunningRuntimeAnimations?b:F,Y,y,q.dataAccessorType,q.animationChannelTargetPath,R,A,E,B,q.useQuaternion,g,r),F.samplers.length&&F.channels.length&&C.push(F))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(Y,b,C,R,q,A,E,B,g,r,O){let F;if(Y instanceof QY.d){const q=Y.morphTargetManager;if(q)for(let y=0;y<q.numTargets;++y){const S=q.getTarget(y);for(const n of S.animations){if(O&&!O(n))continue;const S=new IY.e(`${n.name}`,"influence",n.framePerSecond,n.dataType,n.loopMode,n.enableBlending),t=[],I=n.getKeys();for(let Y=0;Y<I.length;++Y){const b=I[Y];for(let Y=0;Y<q.numTargets;++Y)Y==y?t.push(b):t.push({frame:b.frame,value:0})}S.setKeys(t);const w=pY._DeduceAnimationInfo(S);w&&(F={name:S.name,samplers:[],channels:[]},pY._AddAnimation(n.name,n.hasRunningRuntimeAnimations?b:F,Y,S,w.dataAccessorType,w.animationChannelTargetPath,R,A,E,B,w.useQuaternion,g,r,q.numTargets),F.samplers.length&&F.channels.length&&C.push(F))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(Y,b,C,R,q,A,E,B,g){let r;if(Y.animationGroups){const F=Y.animationGroups;for(const y of F){const F=new Map,S=new Map,n=new Set,t=y.to-y.from;r={name:y.name,channels:[],samplers:[]};for(let b=0;b<y.targetedAnimations.length;++b){const t=y.targetedAnimations[b],I=t.target,w=t.animation;if(g&&!g(w))continue;const Q=B.has(I);if(this._IsTransformable(I)||1===I.length&&this._IsTransformable(I[0])){const Y=pY._DeduceAnimationInfo(t.animation);if(Y){const b=this._IsTransformable(I)?I:this._IsTransformable(I[0])?I[0]:null;b&&pY._AddAnimation(`${w.name}`,r,b,w,Y.dataAccessorType,Y.animationChannelTargetPath,C,R,q,A,Y.useQuaternion,E,Q)}}else if(I instanceof wY.c||1===I.length&&I[0]instanceof wY.c){if(pY._DeduceAnimationInfo(t.animation)){const b=I instanceof wY.c?I:I[0];if(b){const C=Y.morphTargetManagers.find((Y=>{for(let C=0;C<Y.numTargets;++C)if(Y.getTarget(C)===b)return!0;return!1}));if(C){const R=Y.meshes.find((Y=>Y.morphTargetManager===C));var O;if(R)F.has(R)||F.set(R,new Map),null===(O=F.get(R))||void 0===O||O.set(b,w),n.add(R),S.set(R,w)}}}}}n.forEach((Y=>{const b=Y.morphTargetManager;let B=null;const g=[],O=S.get(Y).getKeys(),n=O.length;for(let C=0;C<n;++C)for(let R=0;R<b.numTargets;++R){const q=b.getTarget(R),A=F.get(Y);if(A){const b=A.get(q);b?(B||(B=new IY.e(`${y.name}_${Y.name}_MorphWeightAnimation`,"influence",b.framePerSecond,IY.e.ANIMATIONTYPE_FLOAT,b.loopMode,b.enableBlending)),g.push(b.getKeys()[C])):g.push({frame:y.from+t/n*C,value:q.influence,inTangent:O[0].inTangent?0:void 0,outTangent:O[0].outTangent?0:void 0})}}B.setKeys(g);const I=pY._DeduceAnimationInfo(B);I&&pY._AddAnimation(`${y.name}_${Y.name}_MorphWeightAnimation`,r,Y,B,I.dataAccessorType,I.animationChannelTargetPath,C,R,q,A,I.useQuaternion,E,!1,null===b||void 0===b?void 0:b.numTargets)})),r.channels.length&&r.samplers.length&&b.push(r)}}}static _AddAnimation(Y,b,C,q,A,E,B,g,r,O,F,y,S,n){const t=pY._CreateNodeAnimation(C,q,E,F,y);let I,w,Q,N,p,mY;if(t){if(n){let Y=0,b=0;const C=[];for(;t.inputs.length>0;)b=t.inputs.shift(),Y%n==0&&C.push(b),Y++;t.inputs=C}const Y=B.get(C),q=new Float32Array(t.inputs);I=g.createBufferView(q),w=g.createAccessor(I,"SCALAR",5126,t.inputs.length,void 0,{min:[t.inputsMin],max:[t.inputsMax]}),O.push(w),Q=O.length-1;const r=new R.Quaternion,F=new R.AC,y=new R.AC,L=C instanceof yY.c,u=k(A),c=new Float32Array(t.outputs.length*u);t.outputs.forEach((function(Y,b){let C=Y;switch(E){case"translation":S&&(R.AC.FromArrayToRef(Y,0,y),K(y),y.toArray(C));break;case"rotation":4===Y.length?R.Quaternion.FromArrayToRef(Y,0,r):(C=new Array(4),R.AC.FromArrayToRef(Y,0,F),R.Quaternion.FromEulerVectorToRef(F,r)),S&&(f(r),L&&Z(r)),r.toArray(C)}c.set(C,b*u)})),I=g.createBufferView(c),w=g.createAccessor(I,A,5126,t.outputs.length),O.push(w),N=O.length-1,p={interpolation:t.samplerInterpolation,input:Q,output:N},b.samplers.push(p),mY={sampler:b.samplers.length-1,target:{node:Y,path:E}},b.channels.push(mY)}}static _CreateBakedAnimation(Y,b,C,A,E,B,g,r,O,F,y){let S;const n=R.Quaternion.Identity();let t,I=null,w=null,Q=null,N=null,p=null,mY=null;F.min=q.Tools.FloatRound(A/B);const L=b.getKeys();for(let R=0,u=L.length;R<u;++R){if(mY=null,Q=L[R],R+1<u)if(N=L[R+1],Q.value.equals&&Q.value.equals(N.value)||Q.value===N.value){if(0!==R)continue;mY=Q.frame}else mY=N.frame;else{if(p=L[R-1],Q.value.equals&&Q.value.equals(p.value)||Q.value===p.value)continue;mY=E}if(mY)for(let R=Q.frame;R<=mY;R+=g){if(t=q.Tools.FloatRound(R/B),t===I)continue;I=t,w=t;const A={key:0,repeatCount:0,loopMode:b.loopMode};S=b._interpolate(R,A),pY._SetInterpolatedValue(Y,S,t,b,C,n,r,O,y)}}w&&(F.max=w)}static _ConvertFactorToVector3OrQuaternion(Y,b,C,A,E){const B=pY._GetBasePositionRotationOrScale(b,A,E),g=C.targetProperty.split("."),r=g?g[1]:"",O=E?R.Quaternion.OC(B).normalize():R.AC.OC(B);switch(r){case"x":case"y":case"z":O[r]=Y;break;case"w":O.w=Y;break;default:q.Tools.Error(`glTFAnimation: Unsupported component name "${r}"!`)}return O}static _SetInterpolatedValue(Y,b,C,q,A,E,B,g,r){let O;B.push(C),"weights"!==A?(q.dataType===IY.e.ANIMATIONTYPE_FLOAT&&(b=this._ConvertFactorToVector3OrQuaternion(b,Y,q,A,r)),"rotation"===A?(r?E=b:(O=b,R.Quaternion.RotationYawPitchRollToRef(O.y,O.x,O.z,E)),g.push(E.cb())):(O=b,g.push(O.cb()))):g.push([b])}static _CreateLinearOrStepAnimation(Y,b,C,R,q,A){for(const E of b.getKeys())R.push(E.frame/b.framePerSecond),pY._AddKeyframeValue(E,b,q,C,Y,A)}static _CreateCubicSplineAnimation(Y,b,C,R,q,A){b.getKeys().forEach((function(E){R.push(E.frame/b.framePerSecond),pY._AddSplineTangent(FY.INTANGENT,q,C,"CUBICSPLINE",E,A),pY._AddKeyframeValue(E,b,q,C,Y,A),pY._AddSplineTangent(FY.OUTTANGENT,q,C,"CUBICSPLINE",E,A)}))}static _GetBasePositionRotationOrScale(Y,b,C){let q;if("rotation"===b)if(C){q=(Y.rotationQuaternion??R.Quaternion.Identity()).cb()}else{q=(Y.rotation??R.AC.Zero()).cb()}else if("translation"===b){q=(Y.position??R.AC.Zero()).cb()}else{q=(Y.ob??R.AC.One()).cb()}return q}static _AddKeyframeValue(Y,b,C,A,E,B){let g;const r=b.dataType;if(r===IY.e.ANIMATIONTYPE_VECTOR3){let b=Y.value.cb();if("rotation"===A){const Y=R.AC.OC(b);b=R.Quaternion.RotationYawPitchRoll(Y.y,Y.x,Y.z).cb()}C.push(b)}else if(r===IY.e.ANIMATIONTYPE_FLOAT){if("weights"===A)C.push([Y.value]);else if(g=this._ConvertFactorToVector3OrQuaternion(Y.value,E,b,A,B),g){if("rotation"===A){const Y=B?g:R.Quaternion.RotationYawPitchRoll(g.y,g.x,g.z).normalize();C.push(Y.cb())}C.push(g.cb())}}else r===IY.e.ANIMATIONTYPE_QUATERNION?C.push(Y.value.normalize().cb()):q.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(Y,b,C){let R,q,A=!1;if("rotation"===b&&!C)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let E=0,B=Y.length;E<B;++E)if(q=Y[E],q.inTangent||q.outTangent)if(R){if("CUBICSPLINE"!==R){R="LINEAR",A=!0;break}}else R="CUBICSPLINE";else if(R){if("CUBICSPLINE"===R||q.interpolation&&1===q.interpolation&&"STEP"!==R){R="LINEAR",A=!0;break}}else R=q.interpolation&&1===q.interpolation?"STEP":"LINEAR";return R||(R="LINEAR"),{interpolationType:R,shouldBakeAnimation:A}}static _AddSplineTangent(Y,b,C,q,A,E){let B;const g=Y===FY.INTANGENT?A.inTangent:A.outTangent;if("CUBICSPLINE"===q){if("rotation"===C)if(g)if(E)B=g.cb();else{const Y=g;B=R.Quaternion.RotationYawPitchRoll(Y.y,Y.x,Y.z).cb()}else B=[0,0,0,0];else B="weights"===C?g?[g]:[0]:g?g.cb():[0,0,0];b.push(B)}}static _CalculateMinMaxKeyFrames(Y){let b=1/0,C=-1/0;return Y.forEach((function(Y){b=Math.min(b,Y.frame),C=Math.max(C,Y.frame)})),{min:b,max:C}}}function mb(Y,b,C,A,E,B){const g={attributes:{},influence:Y.influence,name:Y.name},r=b.Pb;if(!r)return q.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),g;const F=B?-1:1,y=R.AC.Zero();let S=0,n=0;if(Y.hasPositions){const A=Y.getPositions(),B=r.getVerticesData(O.e.PositionKind);if(B){const Y=new Float32Array(B.length),b=[1/0,1/0,1/0],q=[-1/0,-1/0,-1/0];n=B.length/3,S=0;for(let C=S;C<n;++C){const E=R.AC.OC(B,3*C);R.AC.OC(A,3*C).subtractToRef(E,y),y.x*=F,b[0]=Math.min(b[0],y.x),q[0]=Math.max(q[0],y.x),b[1]=Math.min(b[1],y.y),q[1]=Math.max(q[1],y.y),b[2]=Math.min(b[2],y.z),q[2]=Math.max(q[2],y.z),Y[3*C]=y.x,Y[3*C+1]=y.y,Y[3*C+2]=y.z}const r=C.createBufferView(Y,12),O=C.createAccessor(r,"VEC3",5126,A.length/3,0,{min:b,max:q});E.push(O),g.attributes.POSITION=E.length-1}else q.Tools.Warn(`Morph target positions for mesh ${b.name} were not exported. Mesh does not have position vertex data`)}if(Y.hasNormals){const A=Y.getNormals(),B=r.getVerticesData(O.e.NormalKind);if(B){const Y=new Float32Array(B.length);n=B.length/3,S=0;for(let C=S;C<n;++C){const b=R.AC.OC(B,3*C).normalize();R.AC.OC(A,3*C).normalize().subtractToRef(b,y),Y[3*C]=y.x*F,Y[3*C+1]=y.y,Y[3*C+2]=y.z}const b=C.createBufferView(Y,12),q=C.createAccessor(b,"VEC3",5126,A.length/3,0);E.push(q),g.attributes.NORMAL=E.length-1}else q.Tools.Warn(`Morph target normals for mesh ${b.name} were not exported. Mesh does not have normals vertex data`)}if(Y.hasTangents){const A=Y.getTangents(),B=r.getVerticesData(O.e.TangentKind);if(B){n=B.length/4;const Y=new Float32Array(3*n);S=0;for(let C=S;C<n;++C){const b=R.AC.OC(B,4*C);M(b);const q=R.AC.OC(A,3*C);M(q),q.subtractToRef(b,y),Y[3*C]=y.x*F,Y[3*C+1]=y.y,Y[3*C+2]=y.z}const b=C.createBufferView(Y,12),q=C.createAccessor(b,"VEC3",5126,n,0);E.push(q),g.attributes.TANGENT=E.length-1}else q.Tools.Warn(`Morph target tangents for mesh ${b.name} were not exported. Mesh does not have tangents vertex data`)}if(Y.hasColors){const A=Y.getColors(),B=r.getVerticesData(O.e.ColorKind),F=r.getVertexBuffer(O.e.ColorKind);if(B&&F){const Y=F.getSize();n=B.length/Y;const b=new Float32Array(n*Y);S=0;for(let C=S;C<n;++C)if(3===Y){const q=R.AC.OC(B,C*Y);R.AC.OC(A,C*Y).subtractToRef(q,y),b[3*C]=y.x,b[3*C+1]=y.y,b[3*C+2]=y.z}else if(4===Y){const q=new R.Vector4,E=R.Vector4.OC(B,C*Y);R.Vector4.OC(A,C*Y).subtractToRef(E,q),b[4*C]=q.x,b[4*C+1]=q.y,b[4*C+2]=q.z,b[4*C+3]=q.w}else q.Tools.Warn(`Unsupported number of components for color attribute: ${Y}`);const r=C.createBufferView(b,4*Y),O=C.createAccessor(r,3===Y?"VEC3":"VEC4",5126,n,0);E.push(O),g.attributes.COLOR_0=E.length-1}else q.Tools.Warn(`Morph target colors for mesh ${b.name} were not exported. Mesh does not have colors vertex data`)}return g}var LY=C(13374),uY=C(13220),cY=C(13207),lY=C(12790);class XY{}XY.DEFAULT_COLOR=I.rC.White(),XY.DEFAULT_WIDTH_ATTENUATED=1,XY.DEFAULT_WIDTH=.1;var jY=C(13046),TY=C(13377);class PY{static ConvertPoints(Y,b){if(Y.length&&Array.isArray(Y)&&"number"===typeof Y[0])return[Y];if(Y.length&&Array.isArray(Y[0])&&"number"===typeof Y[0][0])return Y;if(Y.length&&!Array.isArray(Y[0])&&Y[0]instanceof R.AC){const b=[];for(let C=0;C<Y.length;C++){const R=Y[C];b.push(R.x,R.y,R.z)}return[b]}if(Y.length>0&&Array.isArray(Y[0])&&Y[0].length>0&&Y[0][0]instanceof R.AC){const b=[],C=Y;for(const Y of C)b.push(Y.flatMap((Y=>[Y.x,Y.y,Y.z])));return b}if(Y instanceof Float32Array){if(null!==b&&void 0!==b&&b.floatArrayStride){const C=[],R=3*b.floatArrayStride;for(let b=0;b<Y.length;b+=R){const q=new Array(R);for(let C=0;C<R;C++)q[C]=Y[b+C];C.push(q)}return C}return[Array.from(Y)]}if(Y.length&&Y[0]instanceof Float32Array){const b=[];for(const C of Y)b.push(Array.from(C));return b}return[]}static OmitZeroLengthPredicate(Y,b,C){const R=[];return b.EC(Y).lengthSquared()>0&&R.push([Y,b]),C.EC(b).lengthSquared()>0&&R.push([b,C]),Y.EC(C).lengthSquared()>0&&R.push([C,Y]),0===R.length?null:R}static OmitDuplicatesPredicate(Y,b,C,R){const q=[];return PY._SearchInPoints(Y,b,R)||q.push([Y,b]),PY._SearchInPoints(b,C,R)||q.push([b,C]),PY._SearchInPoints(C,Y,R)||q.push([C,Y]),0===q.length?null:q}static _SearchInPoints(Y,b,C){for(const E of C)for(let C=0;C<E.length;C++){var R,q,A;if(null!==(R=E[C])&&void 0!==R&&R.equals(Y))if(null!==(q=E[C+1])&&void 0!==q&&q.equals(b)||null!==(A=E[C-1])&&void 0!==A&&A.equals(b))return!0}return!1}static MeshesToLines(Y,b){const C=[];for(let q=0;q<Y.length;q++){const A=Y[q],E=A.getVerticesData(O.e.PositionKind),B=A.zb();if(E&&B)for(let Y=0,g=0;Y<B.length;Y++){const r=3*B[g++],O=3*B[g++],F=3*B[g++],y=new R.AC(E[r],E[r+1],E[r+2]),S=new R.AC(E[O],E[O+1],E[O+2]),n=new R.AC(E[F],E[F+1],E[F+2]);if(b){const R=b(y,S,n,C,Y,r,A,q,E,B);if(R)for(const Y of R)C.push(Y)}else C.push([y,S],[S,n],[n,y])}}return C}static ToVector3Array(Y){if(Array.isArray(Y[0])){const b=[],C=Y;for(const Y of C){const C=[];for(let b=0;b<Y.length;b+=3)C.push(new R.AC(Y[b],Y[b+1],Y[b+2]));b.push(C)}return b}const b=Y,C=[];for(let q=0;q<b.length;q+=3)C.push(new R.AC(b[q],b[q+1],b[q+2]));return C}static ToNumberArray(Y){return Y.flatMap((Y=>[Y.x,Y.y,Y.z]))}static GetPointsCountInfo(Y){const b=new Array(Y.length);let C=0;for(let R=Y.length;R--;)b[R]=Y[R].length/3,C+=b[R];return{total:C,counts:b}}static GetLineLength(Y){if(0===Y.length)return 0;let b;b="number"===typeof Y[0]?PY.ToVector3Array(Y):Y;const C=R.TmpVectors.AC[0];let q=0;for(let R=0;R<b.length-1;R++){const Y=b[R];q+=b[R+1].subtractToRef(Y,C).length()}return q}static GetLineLengthArray(Y){const b=new Float32Array(Y.length/3);let C=0;for(let R=0,q=Y.length/3-1;R<q;R++){let q=Y[3*R+0],A=Y[3*R+1],E=Y[3*R+2];q-=Y[3*R+3],A-=Y[3*R+4],E-=Y[3*R+5];C+=Math.sqrt(q*q+A*A+E*E),b[R+1]=C}return b}static SegmentizeSegmentByCount(Y,b,C){const q=[],A=b.EC(Y),E=R.TmpVectors.AC[0];E.Gb(C);const B=R.TmpVectors.AC[1];A.divideToRef(E,B);let g=Y.clone();q.push(g);for(let R=0;R<C;R++)g=g.clone(),q.push(g.addInPlace(B));return q}static SegmentizeLineBySegmentLength(Y,b){const C=Y[0]instanceof R.AC?PY.GetLineSegments(Y):"number"===typeof Y[0]?PY.GetLineSegments(PY.ToVector3Array(Y)):Y,q=[];for(const R of C)if(R.length>b){const Y=PY.SegmentizeSegmentByCount(R.point1,R.point2,Math.ceil(R.length/b));for(const b of Y)q.push(b)}else q.push(R.point1),q.push(R.point2);return q}static SegmentizeLineBySegmentCount(Y,b){const C="number"===typeof Y[0]?PY.ToVector3Array(Y):Y,R=PY.GetLineLength(C)/b;return PY.SegmentizeLineBySegmentLength(C,R)}static GetLineSegments(Y){const b=[];for(let C=0;C<Y.length-1;C++){const R=Y[C],q=Y[C+1],A=q.EC(R).length();b.push({point1:R,point2:q,length:A})}return b}static GetMinMaxSegmentLength(Y){const b=PY.GetLineSegments(Y).sort((Y=>Y.length));return{min:b[0].length,max:b[b.length-1].length}}static GetPositionOnLineByVisibility(Y,b,C){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const A=b*C;let E=0,B=0;const g=Y.length;for(let R=0;R<g;R++){if(A<=E+Y[R].length){B=R;break}E+=Y[R].length}const r=(A-E)/Y[B].length;return Y[B].point2.subtractToRef(Y[B].point1,R.TmpVectors.AC[0]),R.TmpVectors.AC[1]=R.TmpVectors.AC[0].multiplyByFloats(r,r,r),q||R.TmpVectors.AC[1].addInPlace(Y[B].point1),R.TmpVectors.AC[1].clone()}static GetCircleLinePoints(Y,b){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Y,A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/b;const E=[];for(let B=0;B<=b;B++)E.push(new R.AC(Math.cos(B*A)*Y,Math.sin(B*A)*q,C));return E}static GetBezierLinePoints(Y,b,C,R){return jY.g.CreateQuadraticBezier(Y,b,C,R).getPoints().flatMap((Y=>[Y.x,Y.y,Y.z]))}static GetArrowCap(Y,b,C,R,q){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,E=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[Y.clone(),Y.add(b.multiplyByFloats(C,C,C))],widths:[R,q,A,E]}}static GetPointsFromText(Y,b,C,R){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,A=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const E=[],B=(0,TY.d)(Y,b,C,R);for(const g of B){for(const Y of g.paths){const b=[],C=Y.getPoints();for(const Y of C)b.push(Y.x,Y.y,q);E.push(b)}if(A)for(const Y of g.holes){const b=[],C=Y.getPoints();for(const Y of C)b.push(Y.x,Y.y,q);E.push(b)}}return E}static Color3toRGBAUint8(Y){const b=new Uint8Array(4*Y.length);for(let C=0,R=0;C<Y.length;C++)b[R++]=255*Y[C].r,b[R++]=255*Y[C].g,b[R++]=255*Y[C].b,b[R++]=255;return b}static CreateColorsTexture(Y,b,C,R){const q=R.getEngine().getCaps().maxTextureSize??1,A=b.length>q?q:b.length,E=Math.ceil(b.length/q);E>1&&(b=[...b,...Array(A*E-b.length).fill(b[0])]);const B=PY.Color3toRGBAUint8(b),g=new L.b(B,A,E,n.c.TEXTUREFORMAT_RGBA,R,!1,!0,C);return g.name=Y,g}static PrepareEmptyColorsTexture(Y){if(!XY.EmptyColorsTexture){const b=new Uint8Array(4);XY.EmptyColorsTexture=new L.b(b,1,1,n.c.TEXTUREFORMAT_RGBA,Y,!1,!1,L.b.NEAREST_NEAREST),XY.EmptyColorsTexture.name="grlEmptyColorsTexture"}return XY.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var Y;null===(Y=XY.EmptyColorsTexture)||void 0===Y||Y.dispose(),XY.EmptyColorsTexture=null}static BooleanToNumber(Y){return Y?1:0}}class vY extends cY.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class zY extends uY.c{isCompatible(Y){return!0}constructor(Y,b,C){var q;C=C||{color:XY.DEFAULT_COLOR};const A=new vY;A.GREASED_LINE_HAS_COLOR=!!C.color&&!C.useColors,A.GREASED_LINE_SIZE_ATTENUATION=C.sizeAttenuation??!1,A.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===C.colorDistributionType,A.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(b??Y.uY()).useRightHandedSystem,A.GREASED_LINE_CAMERA_FACING=C.cameraFacing??!0,super(Y,zY.GREASED_LINE_MATERIAL_NAME,200,A,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(q=C)||void 0===q?void 0:q.forceGLSL)||zY.ForceGLSL,this._scene=b??Y.uY(),this._engine=this._scene.getEngine(),this._cameraFacing=C.cameraFacing??!0,this.visibility=C.visibility??1,this.useDash=C.useDash??!1,this.dashRatio=C.dashRatio??.5,this.dashOffset=C.dashOffset??0,this.width=C.width?C.width:C.sizeAttenuation?XY.DEFAULT_WIDTH_ATTENUATED:XY.DEFAULT_WIDTH,this._sizeAttenuation=C.sizeAttenuation??!1,this.colorMode=C.colorMode??0,this._color=C.color??null,this.useColors=C.useColors??!1,this._colorsDistributionType=C.colorDistributionType??0,this.colorsSampling=C.colorsSampling??L.b.NEAREST_NEAREST,this._colors=C.jY??null,this.dashCount=C.dashCount??1,this.resolution=C.resolution??new R.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),C.colorsTexture?this.colorsTexture=C.colorsTexture:this._colors?this.colorsTexture=PY.CreateColorsTexture(`${Y.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??XY.DEFAULT_COLOR,PY.PrepareEmptyColorsTexture(this._scene)),this._engine.Sb.add((()=>{PY.DisposeEmptyColorsTexture()}))}getAttributes(Y){Y.push("grl_offsets"),Y.push("grl_widths"),Y.push("grl_colorPointers"),Y.push("grl_counters"),this._cameraFacing?(Y.push("grl_previousAndSide"),Y.push("grl_nextAndCounters")):Y.push("grl_slopes")}getSamplers(Y){Y.push("grl_colors")}getActiveTextures(Y){this.colorsTexture&&Y.push(this.colorsTexture)}getUniforms(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const b=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&b.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===Y&&b.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:b,vertex:this._cameraFacing&&this._isGLSL(Y)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(Y)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(Y){if(this._cameraFacing){Y.jb("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||Y.jb("viewProjection",this._scene.getTransformMatrix());const b=R.TmpVectors.Vector4[0];b.x=this._aspect,b.y=this._resolution.x,b.z=this._resolution.y,b.w=this.width,Y.updateVector4("grl_aspect_resolution_lineWidth",b)}const b=R.TmpVectors.Vector4[0];b.x=PY.BooleanToNumber(this.useDash),b.y=this._dashArray,b.z=this.dashOffset,b.w=this.dashRatio,Y.updateVector4("grl_dashOptions",b);const C=R.TmpVectors.Vector4[1];C.x=this.colorMode,C.y=this.visibility,C.z=this.colorsTexture?this.colorsTexture.getSize().width:0,C.w=PY.BooleanToNumber(this.useColors),Y.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",C),this._color&&Y.updateColor3("grl_singleColor",this._color);const q=this.colorsTexture??XY.EmptyColorsTexture;Y.setTexture("grl_colors",q),Y.updateFloat2("grl_textureSize",(null===q||void 0===q?void 0:q.getSize().width)??1,(null===q||void 0===q?void 0:q.getSize().height)??1)}prepareDefines(Y,b,C){Y.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,Y.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,Y.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,Y.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=b.useRightHandedSystem,Y.GREASED_LINE_CAMERA_FACING=this._cameraFacing,Y.GREASED_LINE_USE_OFFSETS=!!C.offsets}getClassName(){return zY.GREASED_LINE_MATERIAL_NAME}getCustomCode(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(b)?function(Y,b){if("vertex"===Y){const Y={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return b&&(Y["!gl_Position\\=viewProjection\\*worldPos;"]="//"),Y}return"fragment"===Y?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(Y,this._cameraFacing):function(Y,b){if("vertex"===Y){const Y={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return b&&(Y["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),Y}return"fragment"===Y?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(Y,this._cameraFacing)}dispose(){var Y;null===(Y=this.colorsTexture)||void 0===Y||Y.dispose(),super.dispose()}get jY(){return this._colors}set jY(Y){this.setColors(Y)}setColors(Y){var b;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],R=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const q=(null===(b=this._colors)||void 0===b?void 0:b.length)??0;var A;if(this._colors=Y,null!==Y&&0!==Y.length){if(!C||R)if(this.colorsTexture&&q===Y.length&&!R){const b=PY.Color3toRGBAUint8(Y);this.colorsTexture.update(b)}else{var E;null===(E=this.colorsTexture)||void 0===E||E.dispose(),this.colorsTexture=PY.CreateColorsTexture(`${this._material.name}-colors-texture`,Y,this.colorsSampling,this._scene)}}else null===(A=this.colorsTexture)||void 0===A||A.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(Y){this._dashCount=Y,this._dashArray=1/Y}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Y){this._sizeAttenuation=Y,this.markAllDefinesAsDirty()}get color(){return this._color}set color(Y){this.setColor(Y)}setColor(Y){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==Y||null!==this._color&&null===Y?(this._color=Y,b||this.markAllDefinesAsDirty()):this._color=Y}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Y){this._colorsDistributionType=Y,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(Y){this._aspect=Y.x/Y.y,this._resolution=Y}serialize(){const Y=super.serialize(),b={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(b.jY=this._colors),this._color&&(b.color=this._color),Y.greasedLineMaterialOptions=b,Y}parse(Y,b,C){var R;super.parse(Y,b,C);const q=Y.greasedLineMaterialOptions;null===(R=this.colorsTexture)||void 0===R||R.dispose(),q.color&&this.setColor(q.color,!0),q.colorDistributionType&&(this.colorsDistributionType=q.colorDistributionType),q.jY&&(this.jY=q.jY),q.colorsSampling&&(this.colorsSampling=q.colorsSampling),q.colorMode&&(this.colorMode=q.colorMode),q.useColors&&(this.useColors=q.useColors),q.visibility&&(this.visibility=q.visibility),q.useDash&&(this.useDash=q.useDash),q.dashCount&&(this.dashCount=q.dashCount),q.dashRatio&&(this.dashRatio=q.dashRatio),q.dashOffset&&(this.dashOffset=q.dashOffset),q.width&&(this.width=q.width),q.sizeAttenuation&&(this.sizeAttenuation=q.sizeAttenuation),q.resolution&&(this.resolution=q.resolution),this.jY?this.colorsTexture=PY.CreateColorsTexture(`${this._material.name}-colors-texture`,this.jY,this.colorsSampling,b):PY.PrepareEmptyColorsTexture(b),this.markAllDefinesAsDirty()}copyTo(Y){var b;const C=Y;null===(b=C.colorsTexture)||void 0===b||b.dispose(),this._colors&&(C.colorsTexture=PY.CreateColorsTexture(`${C._material.name}-colors-texture`,this._colors,C.colorsSampling,this._scene)),C.setColor(this.color,!0),C.colorsDistributionType=this.colorsDistributionType,C.colorsSampling=this.colorsSampling,C.colorMode=this.colorMode,C.useColors=this.useColors,C.visibility=this.visibility,C.useDash=this.useDash,C.dashCount=this.dashCount,C.dashRatio=this.dashRatio,C.dashOffset=this.dashOffset,C.width=this.width,C.sizeAttenuation=this.sizeAttenuation,C.resolution=this.resolution,C.markAllDefinesAsDirty()}_isGLSL(Y){return 0===Y||this._forceGLSL}}zY.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",zY.ForceGLSL=!1,(0,lY.g)(`BABYLON.${zY.GREASED_LINE_MATERIAL_NAME}`,zY);var JY=C(13258),UY=C(12678),oY=C(13068),GY=C(12771);class hY extends oY.ShaderMaterial{constructor(Y,b,q){const A=b.getEngine(),E=A.isWebGPU&&!(q.forceGLSL||hY.ForceGLSL),B=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];b.useRightHandedSystem&&B.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const g=["position","grl_widths","grl_offsets","grl_colorPointers"];q.cameraFacing?(B.push("GREASED_LINE_CAMERA_FACING"),g.push("grl_previousAndSide","grl_nextAndCounters")):(g.push("grl_slopes"),g.push("grl_counters"));const r=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(E||r.push("world","viewProjection","view","projection"),super(Y,b,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:E?["Scene","Mesh"]:void 0,attributes:g,uniforms:r,samplers:E?[]:["grlColors"],defines:B,extraInitializationsAsync:async()=>{E?await Promise.all([C.e(66).then(C.bind(C,16029)),C.e(75).then(C.bind(C,16032))]):await Promise.all([C.e(69).then(C.bind(C,16034)),C.e(76).then(C.bind(C,16041))])},shaderLanguage:E?1:0}),this._color=I.rC.White(),this._colorsDistributionType=0,this._colorsTexture=null,q=q||{color:XY.DEFAULT_COLOR},this.visibility=q.visibility??1,this.useDash=q.useDash??!1,this.dashRatio=q.dashRatio??.5,this.dashOffset=q.dashOffset??0,this.dashCount=q.dashCount??1,this.width=q.width?q.width:q.sizeAttenuation&&q.cameraFacing?XY.DEFAULT_WIDTH_ATTENUATED:XY.DEFAULT_WIDTH,this.sizeAttenuation=q.sizeAttenuation??!1,this.color=q.color??I.rC.White(),this.useColors=q.useColors??!1,this.colorsDistributionType=q.colorDistributionType??0,this.colorsSampling=q.colorsSampling??L.b.NEAREST_NEAREST,this.colorMode=q.colorMode??0,this._colors=q.jY??null,this._cameraFacing=q.cameraFacing??!0,this.resolution=q.resolution??new R.Vector2(A.getRenderWidth(),A.getRenderHeight()),q.colorsTexture?this.colorsTexture=q.colorsTexture:this._colors?this.colorsTexture=PY.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,b):(this._color=this._color??XY.DEFAULT_COLOR,this.colorsTexture=PY.PrepareEmptyColorsTexture(b)),E){const Y=new GY.d;Y.setParameters(),Y.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",Y)}A.Sb.add((()=>{PY.DisposeEmptyColorsTexture()}))}dispose(){var Y;null===(Y=this._colorsTexture)||void 0===Y||Y.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new R.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get jY(){return this._colors}set jY(Y){this.setColors(Y)}setColors(Y){var b;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],R=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const q=(null===(b=this._colors)||void 0===b?void 0:b.length)??0;var A;if(this._colors=Y,null!==Y&&0!==Y.length){if(!C||R)if(this._colorsTexture&&q===Y.length&&!R){const b=PY.Color3toRGBAUint8(Y);this._colorsTexture.update(b)}else{var E;null===(E=this._colorsTexture)||void 0===E||E.dispose(),this.colorsTexture=PY.CreateColorsTexture(`${this.name}-colors-texture`,Y,this.colorsSampling,this.uY())}}else null===(A=this._colorsTexture)||void 0===A||A.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(Y){this._colorsTexture=Y,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(Y){this._width=Y,this.setFloat("grlWidth",Y)}get useColors(){return this._useColors}set useColors(Y){this._useColors=Y,this.setFloat("grlUseColors",PY.BooleanToNumber(Y))}get colorsSampling(){return this._colorsSampling}set colorsSampling(Y){this._colorsSampling=Y}get visibility(){return this._visibility}set visibility(Y){this._visibility=Y,this.setFloat("grlVisibility",Y)}get useDash(){return this._useDash}set useDash(Y){this._useDash=Y,this.setFloat("grlUseDash",PY.BooleanToNumber(Y))}get dashOffset(){return this._dashOffset}set dashOffset(Y){this._dashOffset=Y,this.setFloat("grlDashOffset",Y)}get dashRatio(){return this._dashRatio}set dashRatio(Y){this._dashRatio=Y,this.setFloat("grlDashRatio",Y)}get dashCount(){return this._dashCount}set dashCount(Y){this._dashCount=Y,this._dashArray=1/Y,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Y){this._sizeAttenuation=Y,this.setFloat("grlSizeAttenuation",PY.BooleanToNumber(Y))}get color(){return this._color}set color(Y){this.setColor(Y)}setColor(Y){Y=Y??XY.DEFAULT_COLOR,this._color=Y,this.setColor3("grlColor",Y)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Y){this._colorsDistributionType=Y,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(Y){this._colorMode=Y,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(Y){this._resolution=Y,this.setVector2("grlResolution",Y),this.setFloat("grlAspect",Y.x/Y.y)}serialize(){const Y=super.serialize(),b={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(b.jY=this._colors),Y.greasedLineMaterialOptions=b,Y}parse(Y,b,C){var R;const q=Y.greasedLineMaterialOptions;null===(R=this._colorsTexture)||void 0===R||R.dispose(),q.color&&(this.color=q.color),q.colorDistributionType&&(this.colorsDistributionType=q.colorDistributionType),q.colorsSampling&&(this.colorsSampling=q.colorsSampling),q.colorMode&&(this.colorMode=q.colorMode),q.useColors&&(this.useColors=q.useColors),q.visibility&&(this.visibility=q.visibility),q.useDash&&(this.useDash=q.useDash),q.dashCount&&(this.dashCount=q.dashCount),q.dashRatio&&(this.dashRatio=q.dashRatio),q.dashOffset&&(this.dashOffset=q.dashOffset),q.width&&(this.width=q.width),q.sizeAttenuation&&(this.sizeAttenuation=q.sizeAttenuation),q.resolution&&(this.resolution=q.resolution),q.jY?this.colorsTexture=PY.CreateColorsTexture(`${this.name}-colors-texture`,q.jY,this.colorsSampling,this.uY()):this.colorsTexture=PY.PrepareEmptyColorsTexture(b),this._cameraFacing=q.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var eY,HY,iY;hY.ForceGLSL=!1,function(Y){Y[Y.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",Y[Y.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(eY||(eY={})),function(Y){Y[Y.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",Y[Y.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",Y[Y.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(HY||(HY={})),function(Y){Y[Y.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",Y[Y.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",Y[Y.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",Y[Y.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",Y[Y.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(iY||(iY={}));class WY extends QY.d{constructor(Y,b,C){super(Y,b,null,null,!1,!1),this.name=Y,this._options=C,this._lazy=!1,this._updatable=!1,this._engine=b.getEngine(),this._lazy=C.lazy??!1,this._updatable=C.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=C.colorPointers??[],this._widths=C.widths??new Array(C.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(Y){let b=0;for(const R of this._points)b+=R.length;const C=b/3*2-this._widths.length;for(let R=0;R<C;R++)this._widths.push(Y)}updateLazy(){var Y,b;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(Y=this._options.ribbonOptions)||void 0===Y?void 0:Y.smoothShading),!this.zY&&this.refreshBoundingInfo(),null===(b=this.greasedLineMaterial)||void 0===b||b.updateLazy()}addPoints(Y,b){for(const C of Y)this._points.push(C);this._lazy||this.setPoints(this._points,b)}dispose(Y){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(Y,b)}isLazy(){return this._lazy}get TY(){return this._uvs}set TY(Y){this._uvs=Y instanceof Float32Array?Y:new Float32Array(Y),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(Y){this.material instanceof hY&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===Y||void 0===Y?void 0:Y.length)>0),this._offsets=Y,this._offsetsBuffer?this._offsetsBuffer.update(Y):this._createOffsetsBuffer(Y)}get widths(){return this._widths}set widths(Y){this._widths=Y,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(Y)}get colorPointers(){return this._colorPointers}set colorPointers(Y){this._colorPointers=Y,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(Y)}get greasedLineMaterial(){var Y,b;if(this.material&&this.material instanceof hY)return this.material;const C=null===(Y=this.material)||void 0===Y||null===(b=Y.pluginManager)||void 0===b?void 0:b.getPlugin(zY.GREASED_LINE_MATERIAL_NAME);return C||void 0}get points(){const Y=[];return UY.c.DeepCopy(this._points,Y),Y}setPoints(Y,b){this._points=PY.ConvertPoints(Y,(null===b||void 0===b?void 0:b.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==b&&void 0!==b&&b.colorPointers||this._updateColorPointers(),this._setPoints(this._points,b)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,TY:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(Y){super.serialize(Y),Y.type=this.getClassName(),Y.lineOptions=this._createLineOptions()}_createVertexBuffers(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new JY.e;return b.lY=this._vertexPositions,b.indices=this._indices,b.TY=this._uvs,Y&&(b.XY=[],JY.e.ComputeNormals(this._vertexPositions,this._indices,b.XY)),b.vY(this,this._options.updatable),b}_createOffsetsBuffer(Y){const b=this._scene.getEngine(),C=new O.d(b,Y,this._updatable,3);this.setVerticesBuffer(C.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=C}}class sY{constructor(Y,b){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=Y,this.wasAddedByNoopNode=b}getIndicesAccessor(Y,b,C,R,q){var A,E,B,g;return null===(A=this._indicesAccessorMap.get(Y))||void 0===A||null===(E=A.get(b))||void 0===E||null===(B=E.get(C))||void 0===B||null===(g=B.get(R))||void 0===g?void 0:g.get(q)}setIndicesAccessor(Y,b,C,R,q,A){let E=this._indicesAccessorMap.get(Y);E||(E=new Map,this._indicesAccessorMap.set(Y,E));let B=E.get(b);B||(B=new Map,E.set(b,B));let g=B.get(C);g||(g=new Map,B.set(C,g));let r=g.get(R);r||(r=new Map,g.set(R,r)),r.set(q,A)}pushExportedNode(Y){this._exportedNodes.has(Y)||this._exportedNodes.add(Y)}getNodesSet(){return this._exportedNodes}getVertexBufferView(Y){return this._vertexBufferViewMap.get(Y)}setVertexBufferView(Y,b){this._vertexBufferViewMap.set(Y,b)}setRemappedBufferView(Y,b,C){this._remappedBufferView.set(Y,new Map),this._remappedBufferView.get(Y).set(b,C)}getRemappedBufferView(Y,b){var C;return null===(C=this._remappedBufferView.get(Y))||void 0===C?void 0:C.get(b)}getVertexAccessor(Y,b,C){var R,q;return null===(R=this._vertexAccessorMap.get(Y))||void 0===R||null===(q=R.get(b))||void 0===q?void 0:q.get(C)}setVertexAccessor(Y,b,C,R){let q=this._vertexAccessorMap.get(Y);q||(q=new Map,this._vertexAccessorMap.set(Y,q));let A=q.get(b);A||(A=new Map,q.set(b,A)),A.set(C,R)}hasVertexColorAlpha(Y){return this._vertexMapColorAlpha.get(Y)||!1}setHasVertexColorAlpha(Y,b){return this._vertexMapColorAlpha.set(Y,b)}getMesh(Y){return this._meshMap.get(Y)}setMesh(Y,b){this._meshMap.set(Y,b)}bindMorphDataToMesh(Y,b){const C=this._meshMorphTargetMap.get(Y)||[];this._meshMorphTargetMap.set(Y,C),-1===C.indexOf(b)&&C.push(b)}getMorphTargetsFromMesh(Y){return this._meshMorphTargetMap.get(Y)}}class DY{_ApplyExtension(Y,b,C,R){if(C>=b.length)return Promise.resolve(Y);const q=R(b[C],Y);return q?q.then((async Y=>Y?await this._ApplyExtension(Y,b,C+1,R):null)):this._ApplyExtension(Y,b,C+1,R)}_ApplyExtensions(Y,b){const C=[];for(const R of DY._ExtensionNames)C.push(this._extensions[R]);return this._ApplyExtension(Y,C,0,b)}_extensionsPreExportTextureAsync(Y,b,C){return this._ApplyExtensions(b,((b,R)=>b.preExportTextureAsync&&b.preExportTextureAsync(Y,R,C)))}_extensionsPostExportNodeAsync(Y,b,C,R,q){return this._ApplyExtensions(b,((b,A)=>b.postExportNodeAsync&&b.postExportNodeAsync(Y,A,C,R,q,this._bufferManager)))}_extensionsPostExportMaterialAsync(Y,b,C){return this._ApplyExtensions(b,((b,R)=>b.postExportMaterialAsync&&b.postExportMaterialAsync(Y,R,C)))}_extensionsPostExportMaterialAdditionalTextures(Y,b,C){const R=[];for(const q of DY._ExtensionNames){const A=this._extensions[q];A.postExportMaterialAdditionalTextures&&R.push(...A.postExportMaterialAdditionalTextures(Y,b,C))}return R}_extensionsPostExportTextures(Y,b,C){for(const R of DY._ExtensionNames){const q=this._extensions[R];q.postExportTexture&&q.postExportTexture(Y,b,C)}}_extensionsPostExportMeshPrimitive(Y){for(const b of DY._ExtensionNames){const C=this._extensions[b];C.postExportMeshPrimitive&&C.postExportMeshPrimitive(Y,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const Y of DY._ExtensionNames){const b=this._extensions[Y];b.preGenerateBinaryAsync&&await b.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(Y){for(const b of DY._ExtensionNames){const C=this._extensions[b];C.enabled&&Y(C)}}_extensionsOnExporting(){this._forEachExtensions((Y=>{var b,C,R;Y.wasUsed&&((b=this._glTF).extensionsUsed||(b.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(Y.name)&&this._glTF.extensionsUsed.push(Y.name),Y.required&&((C=this._glTF).extensionsRequired||(C.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(Y.name)&&this._glTF.extensionsRequired.push(Y.name)),(R=this._glTF).extensions||(R.extensions={}),Y.onExporting&&Y.onExporting())}))}_loadExtensions(){for(const Y of DY._ExtensionNames){const b=DY._ExtensionFactories[Y](this);this._extensions[Y]=b}}constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.d.LastCreatedScene,b=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${n.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new G(this),this._extensions={},this._bufferManager=new OY,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!Y)throw new Error("No scene available to export");this._babylonScene=Y,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:Y=>{var b;return null===Y||void 0===Y||null===(b=Y.Qb)||void 0===b?void 0:b.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...b},this._loadExtensions()}dispose(){for(const Y in this._extensions){this._extensions[Y].dispose()}}get options(){return this._options}static RegisterExtension(Y,b){DY.UnregisterExtension(Y)&&q.Tools.Warn(`Extension with the name ${Y} already exists`),DY._ExtensionFactories[Y]=b,DY._ExtensionNames.push(Y)}static UnregisterExtension(Y){if(!DY._ExtensionFactories[Y])return!1;delete DY._ExtensionFactories[Y];const b=DY._ExtensionNames.indexOf(Y);return-1!==b&&DY._ExtensionNames.splice(b,1),!0}_generateJSON(Y,b,C){const R={byteLength:Y};return R.byteLength&&(this._glTF.buffers=[R]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.BC=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(R.uri=b+".bin"),C?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(Y){const b=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(b.byteLength,Y,!0),R=new Blob([b],{type:"application/octet-stream"}),q=Y+".gltf",A=Y+".bin",E=new r;if(E.files[q]=C,E.files[A]=R,this._imageData)for(const B in this._imageData)E.files[B]=new Blob([this._imageData[B].data],{type:this._imageData[B].mimeType});return E}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(Y){const b=Y%4;return 0===b?b:4-b}async generateGLBAsync(Y){this._shouldUseGlb=!0;const b=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(b.byteLength),R=Y+".glb";let q,A=C.length;if("undefined"!==typeof TextEncoder){q=(new TextEncoder).encode(C),A=q.length}const E=this._getPadding(A),B=this._getPadding(b.byteLength),g=28+A+E+b.byteLength+B,O=new gY(g);if(O.writeUInt32(1179937895),O.writeUInt32(2),O.writeUInt32(g),O.writeUInt32(A+E),O.writeUInt32(1313821514),q)O.writeTypedArray(q);else{const Y="_".charCodeAt(0);for(let b=0;b<A;++b){const R=C.charCodeAt(b);R!=C.codePointAt(b)?O.writeUInt8(Y):O.writeUInt8(R)}}for(let r=0;r<E;++r)O.writeUInt8(32);O.writeUInt32(b.byteLength+B),O.writeUInt32(5130562),O.writeTypedArray(b);for(let r=0;r<B;++r)O.writeUInt8(0);const F=new r;return F.files[R]=new Blob([O.getOutputData()],{type:"application/octet-stream"}),F}_setNodeTransformation(Y,b,C){if(b.getPivotPoint().equalsWithEpsilon(W,i.e)||q.Tools.Warn("Pivot points are not supported in the glTF serializer"),!b.position.equalsWithEpsilon(W,i.e)){const q=R.TmpVectors.AC[0].q(b.position);C&&K(q),Y.translation=q.cb()}b.ob.equalsWithEpsilon(D,i.e)||(Y.scale=b.ob.cb());const A=b.rotationQuaternion||R.Quaternion.FromEulerAngles(b.rotation.x,b.rotation.y,b.rotation.z);A.equalsWithEpsilon(s,i.e)||(C&&f(A),Y.rotation=A.normalize().cb())}_setCameraTransformation(Y,b,C){if(!b.position.equalsWithEpsilon(W,i.e)){const q=R.TmpVectors.AC[0].q(b.position);C&&K(q),Y.translation=q.cb()}const q=b.rotationQuaternion||R.Quaternion.FromEulerAngles(b.rotation.x,b.rotation.y,b.rotation.z);C&&f(q),this._babylonScene.useRightHandedSystem||Z(q),q.equalsWithEpsilon(s,i.e)||(Y.rotation=q.cb())}_listAvailableCameras(){for(const Y of this._babylonScene.cameras){const b={type:Y.mode===yY.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(Y.name&&(b.name=Y.name),"perspective"===b.type)b.perspective={aspectRatio:Y.getEngine().getAspectRatio(Y),yfov:Y.fovMode===yY.c.FOVMODE_VERTICAL_FIXED?Y.fov:Y.fov*Y.getEngine().getAspectRatio(Y),znear:Y.Xb,zfar:Y.maxZ};else if("orthographic"===b.type){const C=Y.orthoLeft&&Y.orthoRight?.5*(Y.orthoRight-Y.orthoLeft):.5*Y.getEngine().getRenderWidth(),R=Y.orthoBottom&&Y.orthoTop?.5*(Y.orthoTop-Y.orthoBottom):.5*Y.getEngine().getRenderHeight();b.orthographic={xmag:C,ymag:R,znear:Y.Xb,zfar:Y.maxZ}}this._camerasMap.set(Y,b)}}_exportAndAssignCameras(){const Y=Array.from(this._camerasMap.values());for(const b of Y){const Y=this._nodesCameraMap.get(b);if(void 0!==Y){this._cameras.push(b);for(const b of Y)b.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const Y of this._babylonScene.skeletons){if(Y.bones.length<=0)continue;const b={joints:[]};this._skinMap.set(Y,b)}}_exportAndAssignSkeletons(){for(const Y of this._babylonScene.skeletons){if(Y.bones.length<=0)continue;const b=this._skinMap.get(Y);if(void 0==b)continue;const C={},R=[];let A=-1;for(let q=0;q<Y.bones.length;++q){const b=Y.bones[q],R=b.getIndex()??q;-1!==R&&(C[R]=b,R>A&&(A=R))}for(let Y=0;Y<=A;++Y){const A=C[Y];R.push(A.getAbsoluteInverseBindMatrix());const E=A.getTransformNode();if(null!==E){const Y=this._nodeMap.get(E);E&&null!==Y&&void 0!==Y?b.joints.push(Y):q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const E=this._nodesSkinMap.get(b);if(b.joints.length>0&&void 0!==E){const Y=64*R.length,C=new Float32Array(Y/4);R.forEach(((Y,b)=>{C.set(Y.m,16*b)}));const q=this._bufferManager.createBufferView(C);this._accessors.push(this._bufferManager.createAccessor(q,"MAT4",5126,R.length)),b.inverseBindMatrices=this._accessors.length-1,this._skins.push(b);for(const b of E)b.skin=this._skins.length-1}}}async _exportSceneAsync(){const Y={nodes:[]};if(this._babylonScene.metadata){const b=this._options.metadataSelector(this._babylonScene.metadata);b&&(Y.extras=b)}const b=new Array,C=new Array,R=new Array;for(const B of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&EY(B,this._babylonScene.useRightHandedSystem)?R.push(...B.getChildren()):this._babylonScene.useRightHandedSystem?b.push(B):C.push(B);this._listAvailableCameras(),this._listAvailableSkeletons();const q=new sY(!0,!1);Y.nodes.push(...await this._exportNodesAsync(C,q));const A=new sY(!1,!1);Y.nodes.push(...await this._exportNodesAsync(b,A));const E=new sY(!1,!0);Y.nodes.push(...await this._exportNodesAsync(R,E)),Y.nodes.length&&this._scenes.push(Y),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&pY._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,q.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(Y){let b=this._shouldExportNodeMap.get(Y);return void 0===b&&(b=this._options.shouldExportNode(Y),this._shouldExportNodeMap.set(Y,b)),b}async _exportNodesAsync(Y,b){const C=new Array;this._exportBuffers(Y,b);for(const R of Y)await this._exportNodeAsync(R,C,b);return C}_collectBuffers(Y,b,C,R,q){if(this._shouldExportNode(Y)&&Y instanceof y.b&&Y.Pb){const A=Y.Pb.getVertexBuffers();if(A)for(const R in A){if(!x(R))continue;const E=A[R];q.setHasVertexColorAlpha(E,Y.hasVertexAlpha);const B=E._buffer,g=b.get(B)||[];b.set(B,g),-1===g.indexOf(E)&&g.push(E);const r=C.get(E)||[];C.set(E,r),-1===r.indexOf(Y)&&r.push(Y)}const E=Y.morphTargetManager;if(E)for(let b=0;b<E.numTargets;b++){const C=E.getTarget(b),q=R.get(C)||[];R.set(C,q),-1===q.indexOf(Y)&&q.push(Y)}}for(const A of Y.getChildren())this._collectBuffers(A,b,C,R,q)}_exportBuffers(Y,b){const C=new Map,R=new Map,q=new Map;for(const B of Y)this._collectBuffers(B,C,R,q,b);const A=Array.from(C.keys());for(const B of A){const Y=B.getData();if(!Y)throw new Error("Buffer data is not available");const q=C.get(B);if(!q)continue;const A=q[0].byteStride;if(q.some((Y=>Y.byteStride!==A)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const E=CY(Y).slice();for(const b of q){const Y=R.get(b),{byteOffset:C,byteStride:q,componentCount:A,type:B,count:g,normalized:r,kind:F}=V(b,Y);switch(F){case O.e.NormalKind:case O.e.TangentKind:(0,h.h)(E,C,q,A,B,g,r,(Y=>{const b=Math.sqrt(Y[0]*Y[0]+Y[1]*Y[1]+Y[2]*Y[2]);if(b>0){const C=1/b;Y[0]*=C,Y[1]*=C,Y[2]*=C}}));break;case O.e.ColorKind:{const b=Y.filter((Y=>Y.material instanceof tY.gC||null==Y.material)).length;if(0==b)break;if(b!=Y.length){e.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}B==O.e.UNSIGNED_BYTE&&e.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const R=new I.rC,F=new I.hb,y=this._babylonScene.getEngine().useExactSrgbConversions;(0,h.h)(E,C,q,A,B,g,r,(Y=>{3===Y.length?(R.ER(Y,0),R.toLinearSpaceToRef(R,y),R.toArray(Y,0)):(F.ER(Y,0),F.toLinearSpaceToRef(F,y),F.toArray(Y,0))}))}}}if(b.convertToRightHanded){for(const Y of q){const b=R.get(Y),{byteOffset:C,byteStride:q,componentCount:A,type:B,count:g,normalized:r,kind:F}=V(Y,b);switch(F){case O.e.PositionKind:case O.e.NormalKind:case O.e.TangentKind:(0,h.h)(E,C,q,A,B,g,r,(Y=>{Y[0]=-Y[0]}))}}b.convertedToRightHandedBuffers.set(B,E)}const g=this._bufferManager.createBufferView(E,A);b.setVertexBufferView(B,g);const r=new Map;for(const b of q){const Y=R.get(b),{kind:C,totalVertices:q}=V(b,Y);switch(C){case O.e.MatricesIndicesKind:case O.e.MatricesIndicesExtraKind:if(b.type==O.e.FLOAT){const Y=b.getFloatData(q);null!==Y&&r.set(b,Y)}}}0!==r.size&&e.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const F=Array.from(r.keys());for(const C of F){const Y=r.get(C);if(!Y)continue;const R=Y.some((Y=>Y>=256)),q=new(R?Uint16Array:Uint8Array)(Y.length);for(let b=0;b<Y.length;b++)q[b]=Y[b];const A=this._bufferManager.createBufferView(q,4*(R?2:1));b.setRemappedBufferView(B,C,A)}}const E=Array.from(q.keys());for(const B of E){const Y=q.get(B);if(!Y)continue;const C=mb(B,Y[0],this._bufferManager,this._bufferViews,this._accessors,b.convertToRightHanded);for(const R of Y)b.bindMorphDataToMesh(R,C)}}async _exportNodeAsync(Y,b,C){let R=this._nodeMap.get(Y);if(void 0!==R)return void(b.includes(R)||b.push(R));const q=await this._createNodeAsync(Y,C);if(q){R=this._nodes.length,this._nodes.push(q),this._nodeMap.set(Y,R),C.pushExportedNode(Y),b.push(R);const A={name:"runtime animations",channels:[],samplers:[]},E=[];this._babylonScene.animationGroups.length||(pY._CreateMorphTargetAnimationFromMorphTargetAnimations(Y,A,E,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation),Y.animations.length&&pY._CreateNodeAnimationFromNodeAnimations(Y,A,E,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation)),A.channels.length&&A.samplers.length&&this._animations.push(A),E.forEach((Y=>{Y.channels.length&&Y.samplers.length&&this._animations.push(Y)}))}const A=q?[]:b;for(const E of Y.getChildren())await this._exportNodeAsync(E,A,C);q&&A.length&&(q.children=A)}async _createNodeAsync(Y,b){if(!this._shouldExportNode(Y))return null;const C={};if(Y.name&&(C.name=Y.name),Y.metadata){const b=this._options.metadataSelector(Y.metadata);b&&(C.extras=b)}if(Y instanceof F.e&&(this._setNodeTransformation(C,Y,b.convertToRightHanded),Y instanceof y.b)){const q=Y instanceof S.b?Y.sourceMesh:Y;if(q.ub&&q.ub.length>0&&(C.mesh=await this._exportMeshAsync(q,b)),Y.skeleton){const b=this._skinMap.get(Y.skeleton);var R;if(void 0!==b)void 0===this._nodesSkinMap.get(b)&&this._nodesSkinMap.set(b,[]),null===(R=this._nodesSkinMap.get(b))||void 0===R||R.push(C)}}if(Y instanceof H.c){const R=this._camerasMap.get(Y);if(R){var q;void 0===this._nodesCameraMap.get(R)&&this._nodesCameraMap.set(R,[]),this._setCameraTransformation(C,Y,b.convertToRightHanded);const E=Y.parent;if(null!==E&&bY(Y,E)){const Y=this._nodeMap.get(E);if(void 0!==Y){var A;const b=this._nodes[Y];return YY(C,b),null===(A=this._nodesCameraMap.get(R))||void 0===A||A.push(b),null}}null===(q=this._nodesCameraMap.get(R))||void 0===q||q.push(C)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",C,Y,this._nodeMap,b.convertToRightHanded)?C:(e.e.Warn(`Not exporting node ${Y.name}`),null)}_exportIndices(Y,b,C,R,q,E,B,g,r){let O=Y;r.mode=a(E);const F=B!==A.e.CounterClockWiseSideOrientation,y=!g.wasAddedByNoopNode&&F,S=function(Y){switch(Y){case A.e.TriangleFillMode:case A.e.TriangleStripDrawMode:case A.e.TriangleFanDrawMode:return!0}return!1}(E)&&y;if(S){if(E===A.e.TriangleStripDrawMode||E===A.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");r.mode=a(E);const B=b?new Uint32Array(R):new Uint16Array(R);if(Y)for(let b=0;b+2<R;b+=3)B[b]=Y[C+b]+q,B[b+1]=Y[C+b+2]+q,B[b+2]=Y[C+b+1]+q;else for(let Y=0;Y+2<R;Y+=3)B[Y]=Y,B[Y+1]=Y+2,B[Y+2]=Y+1;O=B}else if(Y&&0!==q){const A=b?new Uint32Array(R):new Uint16Array(R);for(let b=0;b<R;b++)A[b]=Y[C+b]+q;O=A}if(O){let A=g.getIndicesAccessor(Y,C,R,q,S);if(void 0===A){const E=function(Y,b,C,R){if(Y instanceof Uint16Array||Y instanceof Uint32Array)return Y;if(Y instanceof Int32Array)return new Uint32Array(Y.buffer,Y.byteOffset,Y.length);const q=Y.slice(b,b+C);return R?new Uint32Array(q):new Uint16Array(q)}(O,0,R,b),B=this._bufferManager.createBufferView(E),r=b?5125:5123;this._accessors.push(this._bufferManager.createAccessor(B,"SCALAR",r,R,0)),A=this._accessors.length-1,g.setIndicesAccessor(Y,C,R,q,S,A)}r.indices=A}}_exportVertexBuffer(Y,b,C,R,q,A){const E=Y.getKind();if(!x(E))return;if(E.startsWith("uv")&&!this._options.exportUnusedUVs&&(!b||!this._materialNeedsUVsSet.has(b)))return;let B=q.getVertexAccessor(Y,C,R);if(void 0===B){const b=q.convertedToRightHandedBuffers.get(Y._buffer)||Y._buffer.getData(),A=E===O.e.PositionKind?function(Y,b,C,R){const{byteOffset:q,byteStride:A,type:E,normalized:B}=b,g=b.getSize(),r=new Array(g).fill(1/0),O=new Array(g).fill(-1/0);return(0,h.h)(Y,q+C*A,A,g,E,R*g,B,(Y=>{for(let b=0;b<g;b++)r[b]=Math.min(r[b],Y[b]),O[b]=Math.max(O[b],Y[b])})),{min:r,max:O}}(b,Y,C,R):void 0,g=(E===O.e.MatricesIndicesKind||E===O.e.MatricesIndicesExtraKind)&&Y.type===O.e.FLOAT,r=g?O.e.UNSIGNED_BYTE:Y.type,F=g?void 0:Y.normalized,y=g?q.getRemappedBufferView(Y._buffer,Y):q.getVertexBufferView(Y._buffer),S=Y.byteOffset+C*Y.byteStride;this._accessors.push(this._bufferManager.createAccessor(y,function(Y,b){if(Y==O.e.ColorKind)return b?"VEC4":"VEC3";switch(Y){case O.e.PositionKind:case O.e.NormalKind:return"VEC3";case O.e.TangentKind:case O.e.MatricesIndicesKind:case O.e.MatricesIndicesExtraKind:case O.e.MatricesWeightsKind:case O.e.MatricesWeightsExtraKind:return"VEC4";case O.e.UVKind:case O.e.UV2Kind:case O.e.UV3Kind:case O.e.UV4Kind:case O.e.UV5Kind:case O.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${Y}`)}(E,q.hasVertexColorAlpha(Y)),r,R,S,A,F)),B=this._accessors.length-1,q.setVertexAccessor(Y,C,R,B)}A.attributes[function(Y){switch(Y){case O.e.PositionKind:return"POSITION";case O.e.NormalKind:return"NORMAL";case O.e.TangentKind:return"TANGENT";case O.e.ColorKind:return"COLOR_0";case O.e.UVKind:return"TEXCOORD_0";case O.e.UV2Kind:return"TEXCOORD_1";case O.e.UV3Kind:return"TEXCOORD_2";case O.e.UV4Kind:return"TEXCOORD_3";case O.e.UV5Kind:return"TEXCOORD_4";case O.e.UV6Kind:return"TEXCOORD_5";case O.e.MatricesIndicesKind:return"JOINTS_0";case O.e.MatricesIndicesExtraKind:return"JOINTS_1";case O.e.MatricesWeightsKind:return"WEIGHTS_0";case O.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${Y}`)}(E)]=B}async _exportMaterialAsync(Y,b,C,R){let q=this._materialMap.get(Y);if(void 0===q){const R=b&&Object.keys(b).some((Y=>Y.startsWith("uv")));if((Y=Y instanceof SY.d?Y.eb[C.materialIndex]:Y)instanceof nY.b)q=await this._materialExporter.exportPBRMaterialAsync(Y,"image/png",R);else{if(!(Y instanceof tY.gC))return void e.e.Warn(`Unsupported material '${Y.name}' with type ${Y.getClassName()}`);q=await this._materialExporter.exportStandardMaterialAsync(Y,"image/png",R)}this._materialMap.set(Y,q)}R.material=q}async _exportMeshAsync(Y,b){var C;let R=b.getMesh(Y);if(void 0!==R)return R;const q={primitives:[]};R=this._meshes.length,this._meshes.push(q),b.setMesh(Y,R);const E=Y.isUnIndexed?null:Y.zb(),B=null===(C=Y.Pb)||void 0===C?void 0:C.getVertexBuffers(),g=b.getMorphTargetsFromMesh(Y),r=Y instanceof LY.c,O=Y instanceof WY,F=Y.ub;if(B&&F&&F.length>0)for(const n of F){const C={attributes:{}},R=n.GY()||this._babylonScene.defaultMaterial;if(O){var y,S;const b={name:R.name},q=Y,A=I.rC.White(),E=(null===(y=q.material)||void 0===y?void 0:y.alpha)??1,B=(null===(S=q.greasedLineMaterial)||void 0===S?void 0:S.color)??A;(!B.equalsWithEpsilon(A,i.e)||E<1)&&(b.pbrMetallicRoughness={baseColorFactor:[...B.cb(),E]}),this._materials.push(b),C.material=this._materials.length-1}else if(r){const b={name:R.name},q=Y;(!q.color.equalsWithEpsilon(I.rC.White(),i.e)||q.alpha<1)&&(b.pbrMetallicRoughness={baseColorFactor:[...q.color.cb(),q.alpha]}),this._materials.push(b),C.material=this._materials.length-1}else await this._exportMaterialAsync(R,B,n,C);const F=r||O?A.e.LineListDrawMode:Y.overrideRenderingFillMode??R.fillMode,t=R._getEffectiveOrientation(Y);this._exportIndices(E,E?(0,h.b)(E,n.indexCount,n.indexStart,n.verticesStart):n.verticesCount>65535,E?n.indexStart:n.verticesStart,E?n.indexCount:n.verticesCount,-n.verticesStart,F,t,b,C);for(const Y of Object.values(B))this._exportVertexBuffer(Y,R,n.verticesStart,n.verticesCount,b,C);if(g){C.targets=[];for(const Y of g)C.targets.push(Y.attributes)}q.primitives.push(C),this._extensionsPostExportMeshPrimitive(C)}if(g){q.weights=[],q.extras||(q.extras={}),q.extras.targetNames=[];for(const Y of g)q.weights.push(Y.influence),q.extras.targetNames.push(Y.name)}return R}}DY._ExtensionNames=new Array,DY._ExtensionFactories={};class dY{static async GLTFAsync(Y,b,C){C&&C.exportWithoutWaitingForScene||await Y.whenReadyAsync();const R=new DY(Y,C),q=await R.generateGLTFAsync(b.replace(/\.[^/.]+$/,""));return R.dispose(),q}static async GLBAsync(Y,b,C){C&&C.exportWithoutWaitingForScene||await Y.whenReadyAsync();const R=new DY(Y,C),q=await R.generateGLBAsync(b.replace(/\.[^/.]+$/,""));return R.dispose(),q}}C(13386);const VY="EXT_mesh_gpu_instancing";class kY{constructor(Y){this.name=VY,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(Y,b,C,q,A,E){return await new Promise((Y=>{if(b&&C instanceof QY.d&&C.hasThinInstances&&this._exporter){this._wasUsed=!0;const Y=R.AC.Zero(),q=R.Quaternion.Identity(),B=R.AC.One(),g=C.thinInstanceGetWorldMatrices(),r=R.TmpVectors.AC[2],O=R.TmpVectors.Quaternion[1],F=R.TmpVectors.AC[3];let y=!1,S=!1,n=!1;const t=new Float32Array(3*C.Hb),I=new Float32Array(4*C.Hb),w=new Float32Array(3*C.Hb);let Q=0;for(const b of g)b.decompose(F,O,r),A&&(K(r),f(O)),t.set(r.cb(),3*Q),I.set(O.normalize().cb(),4*Q),w.set(F.cb(),3*Q),y=y||!r.equalsWithEpsilon(Y),S=S||!O.equalsWithEpsilon(q),n=n||!F.equalsWithEpsilon(B),Q++;const N={attributes:{}};y&&(N.attributes.TRANSLATION=this._buildAccessor(t,"VEC3",C.Hb,E)),S&&(N.attributes.ROTATION=this._buildAccessor(I,"VEC4",C.Hb,E)),n&&(N.attributes.SCALE=this._buildAccessor(w,"VEC3",C.Hb,E)),b.extensions=b.extensions||{},b.extensions[VY]=N}Y(b)}))}_buildAccessor(Y,b,C,R){const q=R.createBufferView(Y),A=R.createAccessor(q,b,5126,C);return this._exporter._accessors.push(A),this._exporter._accessors.length-1}}DY.RegisterExtension(VY,(Y=>new kY(Y)));var xY=C(13392),aY=C(13404),MY=C(13410),KY=C(13417);function fY(Y){return Y===MY.b.PositionKind?"POSITION":Y===MY.b.NormalKind?"NORMAL":Y===MY.b.ColorKind?"COLOR":Y.startsWith(MY.b.UVKind)?"TEX_COORD":"GENERIC"}const ZY={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Yb extends xY.c{static get DefaultAvailable(){return(0,xY.h)(Yb.DefaultConfiguration)}static get Default(){return Yb._Default??(Yb._Default=new Yb),Yb._Default}static ResetDefault(Y){Yb._Default&&(Y||Yb._Default.dispose(),Yb._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(Y,b){return{module:await(b||DracoEncoderModule)({wasmBinary:Y})}}_getWorkerContent(){return`${aY.g}(${aY.h})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Yb.DefaultConfiguration)}async _encodeAsync(Y,b,C){const R=C?(0,KY.b)(ZY,C):ZY;if(this._workerPoolPromise){const C=await this._workerPoolPromise;return await new Promise(((q,A)=>{C.push(((C,E)=>{const B=Y=>{C.removeEventListener("error",B),C.removeEventListener("message",g),A(Y),E()},g=Y=>{"encodeMeshDone"===Y.data.id&&(C.removeEventListener("error",B),C.removeEventListener("message",g),q(Y.data.encodedMeshData),E())};C.addEventListener("error",B),C.addEventListener("message",g);const r=[];for(const b of Y)r.push(b.data.buffer);b&&r.push(b.buffer),C.postMessage({id:"encodeMesh",attributes:Y,indices:b,options:R},r)}))}))}if(this._modulePromise){const C=await this._modulePromise;return(0,aY.g)(C.module,Y,b,R)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(Y,b){if(0==Y.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");Y instanceof QY.d&&Y.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===b||void 0===b?void 0:b.method)&&(e.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),b.method="MESH_SEQUENTIAL_ENCODING");const C=function(Y){let b=Y.zb(void 0,!0);return!b||b instanceof Uint32Array||b instanceof Uint16Array||(b=((0,h.b)(b,b.length)?Uint32Array:Uint16Array).from(b)),b}(Y),R=function(Y,b){const C=[];for(const R of Y.getVerticesDataKinds()){if(null!==b&&void 0!==b&&b.includes(R)){if(R===MY.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const q=Y.getVertexBuffer(R),A=q.getSize(),E=(0,h.r)(q.getData(),A,q.type,q.byteOffset,q.byteStride,q.normalized,Y.getTotalVertices(),!0);C.push({kind:R,dracoName:fY(R),size:A,data:E})}return C}(Y,null===b||void 0===b?void 0:b.excludedAttributes);return await this._encodeAsync(R,C,b)}}Yb.DefaultConfiguration={wasmUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder.js`},Yb._Default=null;const bb="KHR_draco_mesh_compression";class Cb{get wasUsed(){return this._wasUsed}constructor(Y){this.name=bb,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===Y.options.meshCompressionMethod&&Yb.DefaultAvailable}dispose(){}postExportMeshPrimitive(Y,b,C){if(!this.enabled)return;if(4!==Y.mode&&5!==Y.mode)return void e.e.Warn("Cannot compress primitive with mode "+Y.mode+".");const R=[],q=[];let A=null;if(void 0!==Y.indices){const E=C[Y.indices],B=b.getBufferView(E);A=b.getData(B).slice(),R.push(B),q.push(E)}const E=[];for(const[O,F]of Object.entries(Y.attributes)){const Y=C[F],A=b.getBufferView(Y),g=k(Y.type),r=(0,h.r)(b.getData(A),g,Y.componentType,Y.byteOffset||0,A.byteStride||(0,h.n)(Y.componentType)*g,Y.normalized||!1,Y.count,!0);E.push({kind:O,dracoName:(B=O,"POSITION"===B?"POSITION":"NORMAL"===B?"NORMAL":B.startsWith("COLOR")?"COLOR":B.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:k(Y.type),data:r}),R.push(A),q.push(Y)}var B;const g={method:Y.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},r=Yb.Default._encodeAsync(E,A,g).then((C=>{if(!C)return void e.e.Error("Draco encoding failed for primitive.");const A={bufferView:-1,attributes:C.attributeIds},E=b.createBufferView(C.data);b.setBufferView(A,E);for(const Y of R)this._bufferViewsUsed.add(Y);for(const Y of q)this._accessorsUsed.add(Y);Y.extensions||(Y.extensions={}),Y.extensions[bb]=A})).catch((Y=>{e.e.Error("Draco encoding failed for primitive: "+Y)}));this._encodePromises.push(r),this._wasUsed=!0}async preGenerateBinaryAsync(Y){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((b=>{Y.getPropertiesWithBufferView(b).every((Y=>this._accessorsUsed.has(Y)))&&Y.removeBufferView(b)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}DY.RegisterExtension(bb,(Y=>new Cb(Y)));var Rb=C(13421);const qb="KHR_lights_punctual",Ab={name:"",color:[1,1,1],ib:1,range:Number.MAX_VALUE},Eb={innerConeAngle:0,outerConeAngle:Math.PI/4},Bb=R.AC.Backward();class gb{constructor(Y){this.name=qb,this.enabled=!0,this.required=!1,this._exporter=Y}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[qb]=this._lights}async postExportNodeAsync(Y,b,C,q,A){return await new Promise((E=>{if(!(C instanceof NY.e))return void E(b);const B=C.getTypeID()==NY.e.LIGHTTYPEID_POINTLIGHT?"point":C.getTypeID()==NY.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":C.getTypeID()==NY.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!B||!(C instanceof Rb.c))return e.e.Warn(`${Y}: Light ${C.name} is not supported in ${qb}`),void E(b);if(C.falloffType!==NY.e.FALLOFF_GLTF&&e.e.Warn(`${Y}: Light falloff for ${C.name} does not match the ${qb} specification!`),!C.position.equalsToFloats(0,0,0)){const Y=R.TmpVectors.AC[0].q(C.position);A&&K(Y),b.translation=Y.cb()}if("point"!==B){const Y=C.direction.normalizeToRef(R.TmpVectors.AC[0]);A&&K(Y);const q=R.Quaternion.FromUnitVectorsToRef(Bb,Y,R.TmpVectors.Quaternion[0]);R.Quaternion.IsIdentity(q)||(b.rotation=q.cb())}const g={type:B,name:C.name,color:C.Wb.cb(),ib:C.ib,range:C.range};if(RY(g,Ab),"spot"===B){const Y=C;g.spot={innerConeAngle:Y.innerAngle/2,outerConeAngle:Y.angle/2},RY(g.spot,Eb)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(g);const r={rb:this._lights.lights.length-1},O=C.parent;if(O&&bY(C,O)){const Y=q.get(O);if(Y){const C=this._exporter._nodes[Y];return YY(b,C),C.extensions||(C.extensions={}),C.extensions[qb]=r,void E(null)}}b.extensions||(b.extensions={}),b.extensions[qb]=r,E(b)}))}}DY.RegisterExtension(qb,(Y=>new gb(Y)));var rb=C(13331);const Ob="KHR_materials_anisotropy";class Fb{constructor(Y){this.name=Ob,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,b,C){const R=[];return C instanceof rb.d&&C.anisotropy.isEnabled&&!C.anisotropy.legacy?(C.anisotropy.texture&&R.push(C.anisotropy.texture),R):[]}postExportMaterialAsync(Y,b,C){return new Promise((Y=>{if(C instanceof rb.d){if(!C.anisotropy.isEnabled||C.anisotropy.legacy)return void Y(b);this._wasUsed=!0,b.extensions=b.extensions||{};const R=this._exporter._materialExporter.getTextureInfo(C.anisotropy.texture),q={anisotropyStrength:C.anisotropy.ib,anisotropyRotation:C.anisotropy.angle,anisotropyTexture:R??void 0};null!==q.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(C),b.extensions[Ob]=q}Y(b)}))}}DY.RegisterExtension(Ob,(Y=>new Fb(Y)));const yb="KHR_materials_clearcoat";class Sb{constructor(Y){this.name=yb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,b,C){const R=[];return C instanceof rb.d&&C.clearCoat.isEnabled?(C.clearCoat.texture&&R.push(C.clearCoat.texture),!C.clearCoat.useRoughnessFromMainTexture&&C.clearCoat.textureRoughness&&R.push(C.clearCoat.textureRoughness),C.clearCoat.bumpTexture&&R.push(C.clearCoat.bumpTexture),R):[]}postExportMaterialAsync(Y,b,C){return new Promise((Y=>{if(C instanceof rb.d){if(!C.clearCoat.isEnabled)return void Y(b);this._wasUsed=!0,b.extensions=b.extensions||{};const R=this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture);let A;A=C.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(C.clearCoat.textureRoughness),C.clearCoat.isTintEnabled&&q.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${C.name}`),C.clearCoat.remapF0OnInterfaceChange&&q.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${C.name}`);const E=this._exporter._materialExporter.getTextureInfo(C.clearCoat.bumpTexture),B={clearcoatFactor:C.clearCoat.ib,clearcoatTexture:R??void 0,clearcoatRoughnessFactor:C.clearCoat.roughness,clearcoatRoughnessTexture:A??void 0,clearcoatNormalTexture:E??void 0};null===B.clearcoatTexture&&null===B.clearcoatRoughnessTexture&&null===B.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),b.extensions[yb]=B}Y(b)}))}}DY.RegisterExtension(yb,(Y=>new Sb(Y)));const nb="KHR_materials_diffuse_transmission";function tb(Y,b){const C=b.subSurface;let R=null;return C.translucencyIntensityTexture?R=C.translucencyIntensityTexture:C.thicknessTexture&&C.useMaskFromThicknessTexture&&(R=C.thicknessTexture),R&&!C.useGltfStyleTextures?(e.e.Warn(`${Y}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${b.name}`,1),null):R}class Ib{constructor(Y){this.name=nb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,b,C){const R=[];if(C instanceof nY.b&&this._isExtensionEnabled(C)){const b=tb(Y,C);return b&&R.push(b),C.subSurface.translucencyColorTexture&&R.push(C.subSurface.translucencyColorTexture),R}return R}_isExtensionEnabled(Y){if(Y.unlit)return!1;const b=Y.subSurface;return!!b.isTranslucencyEnabled&&(!Y.unlit&&!b.useAlbedoToTintTranslucency&&b.useGltfStyleTextures&&1===b.volumeIndexOfRefraction&&0===b.minimumThickness&&0===b.maximumThickness)}postExportMaterialAsync(Y,b,C){return new Promise((R=>{if(C instanceof nY.b&&this._isExtensionEnabled(C)){this._wasUsed=!0;const R=C.subSurface,q=tb(Y,C),A=0==R.translucencyIntensity?void 0:R.translucencyIntensity,E=this._exporter._materialExporter.getTextureInfo(q)??void 0,B=!R.translucencyColor||R.translucencyColor.equalsFloats(1,1,1)?void 0:R.translucencyColor.cb(),g=this._exporter._materialExporter.getTextureInfo(R.translucencyColorTexture)??void 0,r={diffuseTransmissionFactor:A,diffuseTransmissionTexture:E,diffuseTransmissionColorFactor:B,diffuseTransmissionColorTexture:g};(E||g)&&this._exporter._materialNeedsUVsSet.add(C),b.extensions=b.extensions||{},b.extensions[nb]=r}R(b)}))}}DY.RegisterExtension(nb,(Y=>new Ib(Y)));const wb="KHR_materials_dispersion";class Qb{constructor(){this.name=wb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Y){if(Y.unlit)return!1;const b=Y.subSurface;return!(!b.isRefractionEnabled&&!b.isDispersionEnabled)}postExportMaterialAsync(Y,b,C){return new Promise((Y=>{if(C instanceof nY.b&&this._isExtensionEnabled(C)){this._wasUsed=!0;const Y={dispersion:C.subSurface.dispersion};b.extensions=b.extensions||{},b.extensions[wb]=Y}Y(b)}))}}DY.RegisterExtension(wb,(()=>new Qb));const Nb="KHR_materials_emissive_strength";class pb{constructor(){this.name=Nb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(Y,b,C){return await new Promise((Y=>{if(!(C instanceof nY.b))return Y(b);const R=C.emissiveColor.cb(),q=Math.max(...R);if(q>1){this._wasUsed=!0,b.extensions||(b.extensions={});const Y={emissiveStrength:q},R=C.emissiveColor.scale(1/Y.emissiveStrength);b.emissiveFactor=R.cb(),b.extensions[Nb]=Y}return Y(b)}))}}DY.RegisterExtension(Nb,(Y=>new pb));const mC="KHR_materials_ior";class Lb{constructor(){this.name=mC,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Y){return!Y.unlit&&(void 0!=Y.indexOfRefraction&&1.5!=Y.indexOfRefraction)}postExportMaterialAsync(Y,b,C){return new Promise((Y=>{if(C instanceof nY.b&&this._isExtensionEnabled(C)){this._wasUsed=!0;const Y={ior:C.indexOfRefraction};b.extensions=b.extensions||{},b.extensions[mC]=Y}Y(b)}))}}DY.RegisterExtension(mC,(Y=>new Lb));const ub="KHR_materials_iridescence";class cb{constructor(Y){this.name=ub,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,b,C){const R=[];return C instanceof rb.d&&C.iridescence.isEnabled?(C.iridescence.texture&&R.push(C.iridescence.texture),C.iridescence.thicknessTexture&&C.iridescence.thicknessTexture!==C.iridescence.texture&&R.push(C.iridescence.thicknessTexture),R):[]}postExportMaterialAsync(Y,b,C){return new Promise((Y=>{if(C instanceof rb.d){if(!C.iridescence.isEnabled)return void Y(b);this._wasUsed=!0,b.extensions=b.extensions||{};const R=this._exporter._materialExporter.getTextureInfo(C.iridescence.texture),q=this._exporter._materialExporter.getTextureInfo(C.iridescence.thicknessTexture),A={iridescenceFactor:C.iridescence.ib,iridescenceIor:C.iridescence.indexOfRefraction,iridescenceThicknessMinimum:C.iridescence.minimumThickness,iridescenceThicknessMaximum:C.iridescence.maximumThickness,iridescenceTexture:R??void 0,iridescenceThicknessTexture:q??void 0};null===A.iridescenceTexture&&null===A.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(C),b.extensions[ub]=A}Y(b)}))}}DY.RegisterExtension(ub,(Y=>new cb(Y)));const lb="KHR_materials_sheen";class Xb{constructor(Y){this.name=lb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,b,C){return C instanceof nY.b&&C.sheen.isEnabled&&C.sheen.texture?[C.sheen.texture]:[]}async postExportMaterialAsync(Y,b,C){return await new Promise((Y=>{if(C instanceof nY.b){if(!C.sheen.isEnabled)return void Y(b);this._wasUsed=!0,null==b.extensions&&(b.extensions={});const R={sheenColorFactor:C.sheen.color.cb(),sheenRoughnessFactor:C.sheen.roughness??0};null===R.sheenColorTexture&&null===R.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),C.sheen.texture&&(R.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),C.sheen.textureRoughness&&!C.sheen.useRoughnessFromMainTexture?R.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.textureRoughness)??void 0:C.sheen.texture&&C.sheen.useRoughnessFromMainTexture&&(R.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),b.extensions[lb]=R}Y(b)}))}}DY.RegisterExtension(lb,(Y=>new Xb(Y)));const jb="KHR_materials_specular";class Tb{constructor(Y){this.name=jb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,b,C){const R=[];return C instanceof nY.b&&this._isExtensionEnabled(C)?(C.metallicReflectanceTexture&&R.push(C.metallicReflectanceTexture),C.reflectanceTexture&&R.push(C.reflectanceTexture),R):R}_isExtensionEnabled(Y){return!Y.unlit&&(void 0!=Y.metallicF0Factor&&1!=Y.metallicF0Factor||void 0!=Y.metallicReflectanceColor&&!Y.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(Y))}_hasTexturesExtension(Y){return null!=Y.metallicReflectanceTexture||null!=Y.reflectanceTexture}postExportMaterialAsync(Y,b,C){return new Promise((Y=>{if(C instanceof nY.b&&this._isExtensionEnabled(C)){this._wasUsed=!0,b.extensions=b.extensions||{};const Y=this._exporter._materialExporter.getTextureInfo(C.metallicReflectanceTexture)??void 0,R=this._exporter._materialExporter.getTextureInfo(C.reflectanceTexture)??void 0,q={specularFactor:1==C.metallicF0Factor?void 0:C.metallicF0Factor,specularTexture:Y,specularColorFactor:C.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:C.metallicReflectanceColor.cb(),specularColorTexture:R};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),b.extensions[jb]=q}Y(b)}))}}DY.RegisterExtension(jb,(Y=>new Tb(Y)));const Pb="KHR_materials_transmission";class vb{constructor(Y){this.name=Pb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,b,C){const R=[];return C instanceof nY.b&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&R.push(C.subSurface.thicknessTexture),R):R}_isExtensionEnabled(Y){if(Y.unlit)return!1;const b=Y.subSurface;return b.isRefractionEnabled&&void 0!=b.refractionIntensity&&0!=b.refractionIntensity||this._hasTexturesExtension(Y)}_hasTexturesExtension(Y){return null!=Y.subSurface.refractionIntensityTexture}async postExportMaterialAsync(Y,b,C){if(C instanceof nY.b&&this._isExtensionEnabled(C)){this._wasUsed=!0;const R=C.subSurface,q={transmissionFactor:0===R.refractionIntensity?void 0:R.refractionIntensity};if(this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),R.refractionIntensityTexture)if(R.useGltfStyleTextures){const Y=await this._exporter._materialExporter.exportTextureAsync(R.refractionIntensityTexture,"image/png");Y&&(q.transmissionTexture=Y)}else e.e.Warn(`${Y}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);b.extensions||(b.extensions={}),b.extensions[Pb]=q}return b}}DY.RegisterExtension(Pb,(Y=>new vb(Y)));const zb="KHR_materials_unlit";class Jb{constructor(){this.name=zb,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(Y,b,C){return new Promise((Y=>{let R=!1;C instanceof nY.b?R=C.unlit:C instanceof tY.gC&&(R=C.disableLighting),R&&(this._wasUsed=!0,null==b.extensions&&(b.extensions={}),b.extensions[zb]={}),Y(b)}))}}DY.RegisterExtension(zb,(()=>new Jb));const Ub="KHR_materials_volume";class ob{constructor(Y){this.name=Ub,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,b,C){const R=[];return C instanceof nY.b&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&R.push(C.subSurface.thicknessTexture),R):R}_isExtensionEnabled(Y){if(Y.unlit)return!1;const b=Y.subSurface;return!(!b.isRefractionEnabled&&!b.isTranslucencyEnabled)&&(void 0!=b.maximumThickness&&0!=b.maximumThickness||void 0!=b.tintColorAtDistance&&b.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=b.tintColor&&b.tintColor!=I.rC.White()||this._hasTexturesExtension(Y))}_hasTexturesExtension(Y){return null!=Y.subSurface.thicknessTexture}postExportMaterialAsync(Y,b,C){return new Promise((Y=>{if(C instanceof nY.b&&this._isExtensionEnabled(C)){this._wasUsed=!0;const Y=C.subSurface,R={thicknessFactor:0==Y.maximumThickness?void 0:Y.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(Y.thicknessTexture)??void 0,attenuationDistance:Y.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:Y.tintColorAtDistance,attenuationColor:Y.tintColor.equalsFloats(1,1,1)?void 0:Y.tintColor.cb()};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),b.extensions=b.extensions||{},b.extensions[Ub]=R}Y(b)}))}}DY.RegisterExtension(Ub,(Y=>new ob(Y)));const Gb="EXT_materials_diffuse_roughness";class hb{constructor(Y){this.name=Gb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,b,C){const R=[];return C instanceof rb.d&&C._baseDiffuseRoughness?(C._baseDiffuseRoughnessTexture&&R.push(C._baseDiffuseRoughnessTexture),R):[]}postExportMaterialAsync(Y,b,C){return new Promise((Y=>{if(C instanceof rb.d){if(!C._baseDiffuseRoughness)return void Y(b);this._wasUsed=!0,b.extensions=b.extensions||{};const R=this._exporter._materialExporter.getTextureInfo(C._baseDiffuseRoughnessTexture),q={diffuseRoughnessFactor:C._baseDiffuseRoughness,diffuseRoughnessTexture:R??void 0};null!==q.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(C),b.extensions[Gb]=q}Y(b)}))}}DY.RegisterExtension(Gb,(Y=>new hb(Y)));const eb="KHR_texture_transform";class Hb{constructor(){this.name=eb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(Y,b,C){if(C.uY()||q.Tools.Warn(`${Y}: /*@__KEY__*/"scene" is not defined for Babylon texture ${C.name}!`),(0!==C.uAng||0!==C.vAng)&&(q.Tools.Warn(`${Y}: Texture ${C.name} with rotation in the u or v axis is not supported in glTF.`),0!==C.uRotationCenter||0!==C.vRotationCenter))return;const R={};let A=!1;if(0===C.uOffset&&0===C.vOffset||(R.offset=[C.uOffset,C.vOffset],A=!0),1===C.uScale&&1===C.vScale||(R.scale=[C.uScale,C.vScale],A=!0),0!==C.wAng){if(0!==C.uRotationCenter||0!==C.vRotationCenter){if(C.homogeneousRotationInUVTransform&&C.uScale!==C.vScale)return void q.Tools.Warn(`${Y}: Texture ${C.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${eb}.`);q.Tools.Warn(`${Y}: Texture ${C.name} with non-origin rotation center will be exported using an adjusted offset with ${eb}.`),R.offset=function(Y){const{uOffset:b,vOffset:C,uRotationCenter:R,vRotationCenter:q,uScale:A,vScale:E,wAng:B}=Y,g=Math.cos(B),r=Math.sin(B),O=R*A,F=q*E;return[b+(O*(1-g)+F*r),C+(F*(1-g)-O*r)]}(C)}R.rotation=-C.wAng,A=!0}0!==C.coordinatesIndex&&(R.texCoord=C.coordinatesIndex,A=!0),A&&(this._wasUsed=!0,b.extensions||(b.extensions={}),b.extensions[eb]=R)}}DY.RegisterExtension(eb,(()=>new Hb));class ib{static CreateSTL(Y){let b=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],A=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],E=arguments.length>5&&void 0!==arguments[5]&&arguments[5],B=arguments.length>6&&void 0!==arguments[6]&&arguments[6],g=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const r=function(Y,b,C){const q=[3*Y[C],3*Y[C+1],3*Y[C+2]],A=[new R.AC(b[q[0]],b[q[0]+2],b[q[0]+1]),new R.AC(b[q[1]],b[q[1]+2],b[q[1]+1]),new R.AC(b[q[2]],b[q[2]+2],b[q[2]+1])],E=A[0].EC(A[1]),B=A[2].EC(A[1]);return{v:A,n:R.AC.Cross(B,E).normalize()}},F=function(Y,b,C,R){return b=y(Y,b,C.x,R),b=y(Y,b,C.y,R),y(Y,b,C.z,R)},y=function(Y,b,C,R){return Y.setFloat32(b,C,R),b+4},n=function(Y){if(B){let b=Y;Y instanceof S.b&&(b=Y.sourceMesh);const C=b.getVerticesData(O.e.PositionKind,!0,!0);if(!C)return[];const q=R.AC.Zero();let A;for(A=0;A<C.length;A+=3)R.AC.TransformCoordinatesFromFloatsToRef(C[A],C[A+1],C[A+2],Y.Tb(!0),q).toArray(C,A);return C}return Y.getVerticesData(O.e.PositionKind)||[]};B&&(E=!0);let t="",I=0,w=0;if(q){for(let C=0;C<Y.length;C++){const b=Y[C].zb();I+=b?b.length/3:0}const b=new ArrayBuffer(84+50*I);t=new DataView(b),w+=80,t.setUint32(w,I,A),w+=4}else g||(t="solid stlmesh\r\n");for(let R=0;R<Y.length;R++){const b=Y[R];!q&&g&&(t+="solid "+b.name+"\r\n"),!E&&b instanceof QY.d&&b.bakeCurrentTransformIntoVertices();const C=n(b),B=b.zb()||[];for(let Y=0;Y<B.length;Y+=3){const b=r(B,C,Y);q?(w=F(t,w,b.n,A),w=F(t,w,b.v[0],A),w=F(t,w,b.v[1],A),w=F(t,w,b.v[2],A),w+=2):(t+="\tfacet normal "+b.n.x+" "+b.n.y+" "+b.n.z+"\r\n",t+="\t\touter loop\r\n",t+="\t\t\tvertex "+b.v[0].x+" "+b.v[0].y+" "+b.v[0].z+"\r\n",t+="\t\t\tvertex "+b.v[1].x+" "+b.v[1].y+" "+b.v[1].z+"\r\n",t+="\t\t\tvertex "+b.v[2].x+" "+b.v[2].y+" "+b.v[2].z+"\r\n",t+="\t\tendloop\r\n",t+="\tendfacet\r\n")}!q&&g&&(t+="endsolid "+name+"\r\n")}if(q||g||(t+="endsolid stlmesh"),b){const Y=document.createElement("a"),b=new Blob([t],{type:"application/octet-stream"});Y.href=window.URL.createObjectURL(b),Y.download=C+".stl",Y.click()}return t}}function Wb(Y,b){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const R=[];for(let q=0;q<Y.length/C;q++){const A=Y[q*C],E=Y[q*C+1],B=Y[q*C+2];R.push(`(${A.toPrecision(b.precision)}, ${E.toPrecision(b.precision)}, ${B.toPrecision(b.precision)})`)}return R.join(", ")}function sb(Y,b){const C=[];for(let R=0;R<Y.length/2;R++){const q=Y[2*R],A=Y[2*R+1];C.push(`(${q.toPrecision(b.precision)}, ${(1-A).toPrecision(b.precision)})`)}return C.join(", ")}function Db(Y,b){const C=Y.getVerticesData(O.e.PositionKind),R=Y.getVerticesData(O.e.NormalKind);if(C&&R)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(Y){var b;const C=null!==(b=Y.zb())&&void 0!==b&&b.length?Y.getTotalIndices():Y.getTotalVertices();return Array(C/3).fill(3).join(", ")}(Y)}]\n\t\tint[] faceVertexIndices = [${function(Y){const b=Y.zb(),C=[];if(null!==b)for(let R=0;R<b.length;R++)C.push(b[R]);else{const b=Y.getTotalVertices();for(let Y=0;Y<b;Y++)C.push(Y)}return C.join(", ")}(Y)}]\n\t\tnormal3f[] normals = [${Wb(R,b)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Wb(C,b)}]\n        ${function(Y,b){let C="";for(let q=0;q<4;q++){const R=q>0?q:"",A=Y.getVerticesData(O.e.UVKind+(R?R+1:""));A&&(C+=`\n\t\ttexCoord2f[] primvars:st${R} = [${sb(A,b)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const R=Y.getVerticesData(O.e.ColorKind);return R&&(C+=`\n\tcolor3f[] primvars:displayColor = [${Wb(R,b,R.length/Y.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),C}(Y,b)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function db(Y,b){return`\n        def "Geometry"\n        {\n        ${Db(Y,b)}\n        }\n        `}function Vb(Y){let b='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return b+=Y,fflate.strToU8(b)}function kb(Y){const b=Y.m;return`( ${xb(b,0)}, ${xb(b,4)}, ${xb(b,8)}, ${xb(b,12)} )`}function xb(Y,b){return`(${Y[b+0]}, ${Y[b+1]}, ${Y[b+2]}, ${Y[b+3]})`}function ab(Y){const b="Object_"+Y.uniqueId,C=function(Y){const b=Y.getWorldMatrix().clone(),C=Y.uY().useRightHandedSystem;if(!C){let R=Y.parent;for(;R;){if(EY(R,C)){b.multiplyToRef(R.getWorldMatrix().invert(),b);break}R=R.parent}}return b.determinant()<0&&q.Tools.Warn(`Exporting mesh ${Y.name} with negative scale. Result may look incorrect in destination engine.`),b}(Y),R=kb(C);return`def Xform "${b}" (\n\tprepend references = @./geometries/Geometry_${Y.Pb.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${R}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${Y.material.uniqueId}>\n}\n\n`}function Mb(Y){switch(Y){case u.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case u.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case u.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Kb(Y){return`(${Y.x}, ${Y.y})`}function fb(Y){return`(${Y.r}, ${Y.g}, ${Y.b})`}function Zb(Y,b,C,q,A,E){const B=Y.getInternalTexture().uniqueId+"_"+Y.invertY;A[B]=Y;const g=Y.coordinatesIndex>0?"st"+Y.coordinatesIndex:"st",r=new R.Vector2(Y.uScale,Y.vScale),O=new R.Vector2(Y.uOffset,Y.vOffset),F=Y.wAng,y=Math.sin(F),S=Math.cos(F);return O.y=1-O.y-r.y,O.x+=y*r.x,O.y+=(1-S)*r.y,`\n    def Shader "PrimvarReader_${C}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${g}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${C}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${b.uniqueId}/PrimvarReader_${C}.outputs:result>\n        float inputs:rotation = ${(F*(180/Math.PI)).toFixed(E.precision)}\n        float2 inputs:scale = ${Kb(r)}\n        float2 inputs:translation = ${Kb(O)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${Y.uniqueId}_${C}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${B}.png@\n        float2 inputs:st.connect = </Materials/Material_${b.uniqueId}/Transform2d_${C}.outputs:result>\n        ${q?"float4 inputs:scale = "+function(Y){return`(${Y.r}, ${Y.g}, ${Y.b}, 1.0)`}(q):""}\n        token inputs:sourceColorSpace = "${Y.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Mb(Y.wrapU)}"\n        token inputs:wrapT = "${Mb(Y.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${b.needAlphaBlending()?"float outputs:a":""}\n    }`}function YC(Y,b,C){const R="\t\t\t",q=[],A=[],{diffuseMap:E,Wb:B,alphaCutOff:g,emissiveMap:r,emissive:O,normalMap:F,roughnessMap:y,roughnessChannel:S,roughness:n,metalnessMap:t,metalnessChannel:w,metalness:Q,aoMap:N,aoMapChannel:p,aoMapIntensity:mY,alphaMap:L,ior:u,clearCoatEnabled:c,clearCoat:l,clearCoatMap:X,clearCoatRoughness:j,clearCoatRoughnessMap:T}=function(Y){const b={diffuseMap:null,Wb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return Y instanceof tY.gC?{...b,diffuseMap:Y.diffuseTexture,Wb:Y.diffuseColor,alphaCutOff:Y.alphaCutOff,emissiveMap:Y.emissiveTexture,emissive:Y.emissiveColor,roughness:1,alphaMap:Y.opacityTexture}:Y instanceof rb.d?{...b,diffuseMap:Y._albedoTexture,Wb:Y._albedoColor,alphaCutOff:Y._alphaCutOff,emissiveMap:Y._emissiveTexture,emissive:Y._emissiveColor,normalMap:Y._bumpTexture,roughnessMap:Y._metallicTexture,roughnessChannel:Y._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:Y._roughness??1,metalnessMap:Y._metallicTexture,metalnessChannel:Y._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:Y._metallic??0,aoMap:Y._ambientTexture,aoMapChannel:Y._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:Y._ambientTextureStrength,alphaMap:Y._opacityTexture,ior:Y.subSurface.indexOfRefraction,clearCoatEnabled:Y.clearCoat.isEnabled,clearCoat:Y.clearCoat.ib,clearCoatMap:Y.clearCoat.texture,clearCoatRoughness:Y.clearCoat.roughness,clearCoatRoughnessMap:Y.clearCoat.useRoughnessFromMainTexture?Y.clearCoat.texture:Y.clearCoat.textureRoughness}:b}(Y);return null!==E?(q.push(`${R}color3f inputs:diffuseColor.connect = </Materials/Material_${Y.uniqueId}/Texture_${E.uniqueId}_diffuse.outputs:rgb>`),Y.needAlphaBlending()?q.push(`${R}float inputs:opacity.connect = </Materials/Material_${Y.uniqueId}/Texture_${E.uniqueId}_diffuse.outputs:a>`):Y.needAlphaTesting()&&(q.push(`${R}float inputs:opacity.connect = </Materials/Material_${Y.uniqueId}/Texture_${E.uniqueId}_diffuse.outputs:a>`),q.push(`${R}float inputs:opacityThreshold = ${g}`)),A.push(Zb(E,Y,"diffuse",B,b,C))):q.push(`${R}color3f inputs:diffuseColor = ${fb(B||I.rC.White())}`),null!==r?(q.push(`${R}color3f inputs:emissiveColor.connect = </Materials/Material_${Y.uniqueId}/Texture_${r.uniqueId}_emissive.outputs:rgb>`),A.push(Zb(r,Y,"emissive",O,b,C))):O&&O.toLuminance()>0&&q.push(`${R}color3f inputs:emissiveColor = ${fb(O)}`),null!==F&&(q.push(`${R}normal3f inputs:normal.connect = </Materials/Material_${Y.uniqueId}/Texture_${F.uniqueId}_normal.outputs:rgb>`),A.push(Zb(F,Y,"normal",null,b,C))),null!==N&&(q.push(`${R}float inputs:occlusion.connect = </Materials/Material_${Y.uniqueId}/Texture_${N.uniqueId}_occlusion.outputs:${p}>`),A.push(Zb(N,Y,"occlusion",new I.rC(mY,mY,mY),b,C))),null!==y?(q.push(`${R}float inputs:roughness.connect = </Materials/Material_${Y.uniqueId}/Texture_${y.uniqueId}_roughness.outputs:${S}>`),A.push(Zb(y,Y,"roughness",new I.rC(n,n,n),b,C))):q.push(`${R}float inputs:roughness = ${n}`),null!==t?(q.push(`${R}float inputs:metallic.connect = </Materials/Material_${Y.uniqueId}/Texture_${t.uniqueId}_metallic.outputs:${w}>`),A.push(Zb(t,Y,"metallic",new I.rC(Q,Q,Q),b,C))):q.push(`${R}float inputs:metallic = ${Q}`),null!==L?(q.push(`${R}float inputs:opacity.connect = </Materials/Material_${Y.uniqueId}/Texture_${L.uniqueId}_opacity.outputs:r>`),q.push(`${R}float inputs:opacityThreshold = 0.0001`),A.push(Zb(L,Y,"opacity",null,b,C))):q.push(`${R}float inputs:opacity = ${Y.alpha}`),c&&(null!==X?(q.push(`${R}float inputs:clearcoat.connect = </Materials/Material_${Y.uniqueId}/Texture_${X.uniqueId}_clearcoat.outputs:r>`),A.push(Zb(X,Y,"clearcoat",new I.rC(l,l,l),b,C))):q.push(`${R}float inputs:clearcoat = ${l}`),null!==T?(q.push(`${R}float inputs:clearcoatRoughness.connect = </Materials/Material_${Y.uniqueId}/Texture_${T.uniqueId}_clearcoatRoughness.outputs:g>`),A.push(Zb(T,Y,"clearcoatRoughness",new I.rC(j,j,j),b,C))):q.push(`${R}float inputs:clearcoatRoughness = ${j}`)),q.push(`${R}float inputs:ior = ${u}`),`\n\tdef Material "Material_${Y.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${q.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${Y.uniqueId}/PreviewSurface.outputs:surface>\n\n${A.join("\n")}\n\n\t}\n`}async function bC(Y,b,C){const A={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...b};"undefined"===typeof fflate&&await q.Tools.LoadScriptAsync(A.fflateUrl);const E={};E[A.modelFileName]=null;let B='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';B+=function(Y){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===Y.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${Y.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${Y.planeAnchoringAlignment}"`:""}\n            `}(A);const g={};for(const R of Y.meshes){if(0===R.getTotalVertices())continue;const Y=R,b=Y.Pb,r=Y.material;if(!r||!b||C&&!C(Y))continue;if(-1!==["gC","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(r.getClassName())){const C="geometries/Geometry_"+b.uniqueId+".usda";if(!(C in E)){const Y=db(b,A);E[C]=Vb(Y)}r.uniqueId in g||(g[r.uniqueId]=r),B+=ab(Y)}else q.Tools.Warn("USDZExportAsync does not support this material type: "+r.getClassName())}Y.activeCamera&&A.exportCamera&&(B+=function(Y,b){const C="Camera_"+Y.uniqueId,q=kb(R.Matrix.RotationY(Math.PI).multiply(Y.getWorldMatrix()));if(Y.mode===u.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Y.Xb.toPrecision(b.precision)}, ${Y.maxZ.toPrecision(b.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(Y.orthoLeft||1)+Math.abs(Y.orthoRight||1))).toPrecision(b.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(Y.orthoTop||1)+Math.abs(Y.orthoBottom||1))).toPrecision(b.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const R=Y.getEngine().getAspectRatio(Y),A=b.cameraSensorWidth||35;return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Y.Xb.toPrecision(b.precision)}, ${Y.maxZ.toPrecision(b.precision)})\n\t\t\tfloat focalLength = ${(A/(2*Math.tan(.5*Y.fov))).toPrecision(b.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(A*R).toPrecision(b.precision)}\n\t\t\tfloat verticalAperture = ${(A/R).toPrecision(b.precision)}            \n\t\t}\n\t\n\t`}}(Y.activeCamera,A)),B+="\n            }\n        }\n    }";const r={};B+=function(Y,b,C){const R=[];for(const q in Y){const A=Y[q];R.push(YC(A,b,C))}return`\n    def "Materials"\n{\n${R.join("")}\n}\n\n`}(g,r,A),E[A.modelFileName]=fflate.strToU8(B);for(const R in r){const Y=r[R],b=Y.getSize(),C=await Y.readPixels();if(!C)throw new Error("Texture data is not available");const q=await c.DumpTools.DumpDataAsync(b.width,b.height,C,"image/png",void 0,!1,!0);E[`textures/Texture_${R}.png`]=new Uint8Array(q).slice()}let O=0;for(const R in E){const Y=E[R];if(!Y)continue;O+=34+R.length;const b=63&O;if(4!==b){const C=new Uint8Array(64-b);E[R]=[Y,{extra:{12345:C}}]}O=Y.length}return fflate.zipSync(E,{level:0})}}}]);