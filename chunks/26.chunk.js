"use strict";(self.rsqbdnwe5e=self.rsqbdnwe5e||[]).push([[26],{12789:(N,p,T)=>{T.r(p),T.d(p,{EXT_materials_diffuse_roughness:()=>hp,EXT_mesh_gpu_instancing:()=>EN,GLTF2Export:()=>cN,GLTFData:()=>e,KHR_draco_mesh_compression:()=>Tp,KHR_lights_punctual:()=>yp,KHR_materials_anisotropy:()=>Mp,KHR_materials_clearcoat:()=>lp,KHR_materials_diffuse_transmission:()=>Ip,KHR_materials_dispersion:()=>np,KHR_materials_emissive_strength:()=>gp,KHR_materials_ior:()=>ip,KHR_materials_iridescence:()=>Fp,KHR_materials_sheen:()=>Wp,KHR_materials_specular:()=>Rp,KHR_materials_transmission:()=>fp,KHR_materials_unlit:()=>op,KHR_materials_volume:()=>mT,KHR_texture_transform:()=>Vp,OBJExport:()=>U,STLExport:()=>rp,USDZExportAsync:()=>pT,_ConvertToGLTFPBRMetallicRoughness:()=>G,_SolveMetallic:()=>f,__IGLTFExporterExtension:()=>X});var A=T(12371),a=T(12190),C=T(12705);class U{static OBJ(N,p,T,U){const X=[];let y=1,e=1;p&&(T||(T="mat"),X.push("mtllib "+T+".mtl"));for(let H=0;H<N.length;H++){const T=N[H],M=T.name||`mesh${H}}`;X.push(`o ${M}`);let b=null;if(U){const N=T.HX(!0);b=new A.Matrix,N.invertToRef(b),T.bakeTransformIntoVertices(N)}if(p){const N=T.material;N&&X.push("usemtl "+N.id)}const l=T.MX;if(!l){a.Tools.Warn("No geometry is present on the mesh");continue}const k=l.getVerticesData("position"),x=l.getVerticesData("normal"),I=l.getVerticesData("uv"),L=l.bX();let n=0,w=0;if(!k||!L){a.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const g=N[0].KN().useRightHandedSystem?1:-1;for(let N=0;N<k.length;N+=3)X.push("v "+k[N]*g+" "+k[N+1]+" "+k[N+2]),n++;if(null!=x)for(let N=0;N<x.length;N+=3)X.push("vn "+x[N]*g+" "+x[N+1]+" "+x[N+2]);if(null!=I)for(let N=0;N<I.length;N+=2)X.push("vt "+I[N]+" "+I[N+1]),w++;const P=["","",""],i=(T.material||T.KN().defaultMaterial)._getEffectiveOrientation(T),[K,F]=i===C.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let N=0;N<L.length;N+=3){const p=[String(L[N]+y),String(L[N+K]+y),String(L[N+F]+y)],T=[String(L[N]+e),String(L[N+K]+e),String(L[N+F]+e)],A=p,a=null!=I?T:P,C=null!=x?p:P;X.push("f "+A[0]+"/"+a[0]+"/"+C[0]+" "+A[1]+"/"+a[1]+"/"+C[1]+" "+A[2]+"/"+a[2]+"/"+C[2])}U&&b&&T.bakeTransformIntoVertices(b),y+=n,e+=w}return X.join("\n")}static MTL(N){const p=[],T=N.material;p.push("newmtl mat1"),p.push("  Ns "+T.specularPower.toFixed(4)),p.push("  Ni 1.5000"),p.push("  d "+T.alpha.toFixed(4)),p.push("  Tr 0.0000"),p.push("  Tf 1.0000 1.0000 1.0000"),p.push("  illum 2"),p.push("  Ka "+T.ambientColor.r.toFixed(4)+" "+T.ambientColor.g.toFixed(4)+" "+T.ambientColor.b.toFixed(4)),p.push("  Kd "+T.diffuseColor.r.toFixed(4)+" "+T.diffuseColor.g.toFixed(4)+" "+T.diffuseColor.b.toFixed(4)),p.push("  Ks "+T.specularColor.r.toFixed(4)+" "+T.specularColor.g.toFixed(4)+" "+T.specularColor.b.toFixed(4)),p.push("  Ke "+T.emissiveColor.r.toFixed(4)+" "+T.emissiveColor.g.toFixed(4)+" "+T.emissiveColor.b.toFixed(4));T.ambientTexture&&p.push("  map_Ka "+T.ambientTexture.name),T.diffuseTexture&&p.push("  map_Kd "+T.diffuseTexture.name),T.specularTexture&&p.push("  map_Ks "+T.specularTexture.name),T.bumpTexture&&p.push("  map_bump -imfchan z "+T.bumpTexture.name),T.opacityTexture&&p.push("  map_d "+T.opacityTexture.name);return p.join("\n")}}var X=0,y=T(12240);class e{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const N in this.files){const p=this.files[N],T=new Blob([p],{type:(0,y.h)(N)});a.Tools.Download(T,N)}}}var H=T(12451),M=T(12794),b=T(12806),l=T(12829),k=T(12505),x=T(12231),I=T(12421),L=T(12390);const n=L.HighestCommonFactor,w={...L,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:n};var g=T(12608),P=T(12352),i=T(12856),K=T(12862),F=T(12606);const v=1e-6,W=new I.wp(.04,.04,.04),z=1024,R=I.wp.White(),J=I.wp.Black();function f(N,p,T){if(p<W.r)return 0;const A=W.r,a=N*T/(1-W.r)+p-2*W.r,C=a*a-4*A*(W.r-p);return w.Clamp((-a+Math.sqrt(C))/(2*A),0,1)}function G(N){const p=N.diffuseColor.toLinearSpace(N.KN().getEngine().useExactSrgbConversions).scale(.5),T=N.alpha,a=function(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new A.Vector2(0,1),T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new A.Vector2(0,.1),a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new A.Vector2(0,.1),C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new A.Vector2(1300,.1);return function(N,p,T,A,a){return(1-N)*(1-N)*(1-N)*p+3*(1-N)*(1-N)*N*T+3*(1-N)*N*N*A+N*N*N*a}(Math.pow(N/C.x,.333333),p.y,T.y,a.y,C.y)}(w.Clamp(N.specularPower,0,z));return{baseColorFactor:[p.r,p.g,p.b,T],metallicFactor:0,roughnessFactor:a}}function o(N,p){p.needAlphaBlending()?N.alphaMode="BLEND":p.needAlphaTesting()&&(N.alphaMode="MASK",N.alphaCutoff=p.alphaCutOff)}function Z(N,p,T){const A=new Uint8Array(N*p*4);for(let a=0;a<A.length;a+=4)A[a]=A[a+1]=A[a+2]=A[a+3]=255;return i.d.CreateRGBATexture(A,N,p,T)}function mN(N){if(N instanceof Uint8Array){const p=N.length,T=new Float32Array(N.length);for(let A=0;A<p;++A)T[A]=N[A]/255;return T}if(N instanceof Float32Array)return N;throw new Error("Unsupported pixel format!")}class q{constructor(N){this._exporter=N,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(N){return N?this._textureMap.get(N)??null:null}async exportStandardMaterialAsync(N,p,T){const A=G(N),C={name:N.name};if(null==N.lX||N.lX||(N.twoSidedLighting||a.Tools.Warn(N.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),C.doubleSided=!0),T){const T=[],a=N.diffuseTexture;a&&T.push(this.exportTextureAsync(a,p).then((N=>{N&&(A.baseColorTexture=N)})));const U=N.bumpTexture;U&&T.push(this.exportTextureAsync(U,p).then((N=>{N&&(C.normalTexture=N,1!==U.level&&(C.normalTexture.scale=U.level))})));const X=N.emissiveTexture;X&&(C.emissiveFactor=[1,1,1],T.push(this.exportTextureAsync(X,p).then((N=>{N&&(C.emissiveTexture=N)}))));const y=N.ambientTexture;y&&T.push(this.exportTextureAsync(y,p).then((N=>{if(N){const p={index:N.index};C.occlusionTexture=p}}))),T.length>0&&(this._exporter._materialNeedsUVsSet.add(N),await Promise.all(T))}(N.alpha<1||N.opacityTexture)&&(N.alphaMode===K.e.ALPHA_COMBINE?C.alphaMode="BLEND":a.Tools.Warn(N.name+": glTF 2.0 does not support alpha mode: "+N.alphaMode.toString())),N.emissiveColor&&!N.emissiveColor.equalsWithEpsilon(J,v)&&(C.emissiveFactor=N.emissiveColor.UX()),C.pbrMetallicRoughness=A,o(C,N),await this._finishMaterialAsync(C,N,p);const U=this._exporter._materials;return U.push(C),U.length-1}async _finishMaterialAsync(N,p,T){const A=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",N,p),a=[];for(const C of A)a.push(this.exportTextureAsync(C,T));await Promise.all(a),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",N,p)}async _getImageDataAsync(N,p,A,a){const C=K.e.TEXTURETYPE_UNSIGNED_BYTE,U=this._exporter._babylonScene,X=U.getEngine(),y=X.createRawTexture(N,p,A,K.e.TEXTUREFORMAT_RGBA,!1,!0,P.c.NEAREST_SAMPLINGMODE,null,C);X.isWebGPU?await T.e(51).then(T.bind(T,14823)):await T.e(52).then(T.bind(T,14826)),await g.j.ApplyPostProcess("pass",y,U,C,K.e.TEXTURE_NEAREST_SAMPLINGMODE,K.e.TEXTUREFORMAT_RGBA);const e=await X._readTexturePixels(y,p,A);return await F.DumpTools.DumpDataAsync(p,A,e,a,void 0,!0,!0)}_resizeTexturesToSameDimensions(N,p,T){const A=N?N.getSize():{width:0,height:0},a=p?p.getSize():{width:0,height:0};let C,U;return A.width<a.width?(C=N&&N instanceof P.c?g.j.CreateResizedCopy(N,a.width,a.height,!0):Z(a.width,a.height,T),U=p):A.width>a.width?(U=p&&p instanceof P.c?g.j.CreateResizedCopy(p,A.width,A.height,!0):Z(A.width,A.height,T),C=N):(C=N,U=p),{texture1:C,texture2:U}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(N,p,T,A){const a=new Array;if(!N&&!p)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const C=N?N.KN():p?p.KN():null;if(C){var U;const X=this._resizeTexturesToSameDimensions(N,p,C),y=null===(U=X.texture1)||void 0===U?void 0:U.getSize();let e,H;const M=y.width,b=y.height,l=await X.texture1.readPixels(),k=await X.texture2.readPixels();if(!l)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(e=mN(l),!k)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");H=mN(k);const x=H.byteLength,L=new Uint8Array(x),n=new Uint8Array(x),w=4,g=J;let P=0,i=0;for(let N=0;N<b;++N)for(let p=0;p<M;++p){const A=(M*N+p)*w,a={diffuseColor:new I.wp(e[A],e[A+1],e[A+2]).toLinearSpace(C.getEngine().useExactSrgbConversions).multiply(T.diffuseColor),specularColor:new I.wp(H[A],H[A+1],H[A+2]).toLinearSpace(C.getEngine().useExactSrgbConversions).multiply(T.specularColor),glossiness:H[A+3]*T.glossiness},U=this._convertSpecularGlossinessToMetallicRoughness(a);g.r=Math.max(g.r,U.baseColor.r),g.g=Math.max(g.g,U.baseColor.g),g.b=Math.max(g.b,U.baseColor.b),P=Math.max(P,U.metallic),i=Math.max(i,U.roughness),n[A]=255*U.baseColor.r,n[A+1]=255*U.baseColor.g,n[A+2]=255*U.baseColor.b,n[A+3]=X.texture1.XX?255*e[A+3]:255,L[A]=0,L[A+1]=255*U.roughness,L[A+2]=255*U.metallic,L[A+3]=255}const K={baseColor:g,metallic:P,roughness:i};let F=!1,W=!1;for(let N=0;N<b;++N)for(let p=0;p<M;++p){const T=(M*N+p)*w;n[T]/=K.baseColor.r>v?K.baseColor.r:1,n[T+1]/=K.baseColor.g>v?K.baseColor.g:1,n[T+2]/=K.baseColor.b>v?K.baseColor.b:1;const A=I.wp.FromInts(n[T],n[T+1],n[T+2]).toGammaSpace(C.getEngine().useExactSrgbConversions);n[T]=255*A.r,n[T+1]=255*A.g,n[T+2]=255*A.b,A.equalsWithEpsilon(R,v)||(W=!0),L[T+1]/=K.roughness>v?K.roughness:1,L[T+2]/=K.metallic>v?K.metallic:1;I.wp.FromInts(255,L[T+1],L[T+2]).equalsWithEpsilon(R,v)||(F=!0)}return F&&a.push(this._getImageDataAsync(L,M,b,A).then((N=>{K.metallicRoughnessTextureData=N}))),W&&a.push(this._getImageDataAsync(n,M,b,A).then((N=>{K.baseColorTextureData=N}))),await Promise.all(a).then((()=>K))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(N){const p=this._getPerceivedBrightness(N.diffuseColor),T=this._getPerceivedBrightness(N.specularColor),A=1-this._getMaxComponent(N.specularColor),a=f(p,T,A),C=N.diffuseColor.scale(A/(1-W.r)/Math.max(1-a)),U=N.specularColor.Ip(W.scale(1-a)).scale(1/Math.max(a));let X=I.wp.Lerp(C,U,a*a);X=X.clampToRef(0,1,X);return{baseColor:X,metallic:a,roughness:1-N.glossiness}}_getPerceivedBrightness(N){return N?Math.sqrt(.299*N.r*N.r+.587*N.g*N.g+.114*N.b*N.b):0}_getMaxComponent(N){return N?Math.max(N.r,Math.max(N.g,N.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(N,p,T,A){const a=[],C={baseColor:N._albedoColor,metallic:N._metallic,roughness:N._roughness};if(A){N._albedoTexture&&a.push(this.exportTextureAsync(N._albedoTexture,p).then((N=>{N&&(T.baseColorTexture=N)})));const A=N._metallicTexture;A&&a.push(this.exportTextureAsync(A,p).then((N=>{N&&(T.metallicRoughnessTexture=N)})))}return a.length>0&&(this._exporter._materialNeedsUVsSet.add(N),await Promise.all(a)),C}_getTextureSampler(N){const p={};if(!N||!(N instanceof P.c))return p;const T=this._getGLTFTextureWrapMode(N.wrapU);10497!==T&&(p.wrapS=T);const A=this._getGLTFTextureWrapMode(N.wrapV);switch(10497!==A&&(p.wrapT=A),N.samplingMode){case P.c.LINEAR_LINEAR:p.magFilter=9729,p.minFilter=9729;break;case P.c.LINEAR_NEAREST:p.magFilter=9729,p.minFilter=9728;break;case P.c.NEAREST_LINEAR:p.magFilter=9728,p.minFilter=9729;break;case P.c.NEAREST_LINEAR_MIPLINEAR:p.magFilter=9728,p.minFilter=9987;break;case P.c.NEAREST_NEAREST:p.magFilter=9728,p.minFilter=9728;break;case P.c.NEAREST_LINEAR_MIPNEAREST:p.magFilter=9728,p.minFilter=9985;break;case P.c.LINEAR_NEAREST_MIPNEAREST:p.magFilter=9729,p.minFilter=9984;break;case P.c.LINEAR_NEAREST_MIPLINEAR:p.magFilter=9729,p.minFilter=9986;break;case P.c.NEAREST_NEAREST_MIPLINEAR:p.magFilter=9728,p.minFilter=9986;break;case P.c.LINEAR_LINEAR_MIPLINEAR:p.magFilter=9729,p.minFilter=9987;break;case P.c.LINEAR_LINEAR_MIPNEAREST:p.magFilter=9729,p.minFilter=9985;break;case P.c.NEAREST_NEAREST_MIPNEAREST:p.magFilter=9728,p.minFilter=9984}return p}_getGLTFTextureWrapMode(N){switch(N){case P.c.WRAP_ADDRESSMODE:return 10497;case P.c.CLAMP_ADDRESSMODE:return 33071;case P.c.MIRROR_ADDRESSMODE:return 33648;default:return a.Tools.Error(`Unsupported Texture Wrap Mode ${N}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(N,p,T,A){const a={diffuseColor:N._albedoColor,specularColor:N._reflectivityColor,glossiness:N._microSurface},C=N._albedoTexture,U=N._reflectivityTexture,X=N._useMicroSurfaceFromReflectivityMapAlpha;if(U&&!X)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((C||U)&&A){this._exporter._materialNeedsUVsSet.add(N);const A=this._exportTextureSampler(C||U),X=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(C,U,a,p),y=this._exporter._textures;if(X.baseColorTextureData){const N=this._exportImage(`baseColor${y.length}`,p,X.baseColorTextureData);T.baseColorTexture=this._exportTextureInfo(N,A,null===C||void 0===C?void 0:C.coordinatesIndex)}if(X.metallicRoughnessTextureData){const N=this._exportImage(`metallicRoughness${y.length}`,p,X.metallicRoughnessTextureData);T.metallicRoughnessTexture=this._exportTextureInfo(N,A,null===U||void 0===U?void 0:U.coordinatesIndex)}return X}return this._convertSpecularGlossinessToMetallicRoughness(a)}async exportPBRMaterialAsync(N,p,T){const A={},a={name:N.name},C=N.isMetallicWorkflow();if(C){const p=N._albedoColor,T=N.alpha;p&&(A.baseColorFactor=[p.r,p.g,p.b,T])}const U=C?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(N,p,A,T):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(N,p,A,T);await this._setMetallicRoughnessPbrMaterialAsync(U,N,a,A,p,T),await this._finishMaterialAsync(a,N,p);const X=this._exporter._materials;return X.push(a),X.length-1}async _setMetallicRoughnessPbrMaterialAsync(N,p,T,A,C,U){if(o(T,p),N.baseColor.equalsWithEpsilon(R,v)&&w.WithinEpsilon(p.alpha,1,v)||(A.baseColorFactor=[N.baseColor.r,N.baseColor.g,N.baseColor.b,p.alpha]),null!=N.metallic&&1!==N.metallic&&(A.metallicFactor=N.metallic),null!=N.roughness&&1!==N.roughness&&(A.roughnessFactor=N.roughness),null==p.lX||p.lX||(p._twoSidedLighting||a.Tools.Warn(p.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),T.doubleSided=!0),U){const N=[],A=p._bumpTexture;A&&N.push(this.exportTextureAsync(A,C).then((N=>{N&&(T.normalTexture=N,1!==A.level&&(T.normalTexture.scale=A.level))})));const a=p._ambientTexture;a&&N.push(this.exportTextureAsync(a,C).then((N=>{if(N){const A={index:N.index,texCoord:N.texCoord,extensions:N.extensions};T.occlusionTexture=A;const a=p._ambientTextureStrength;a&&(A.strength=a)}})));const U=p._emissiveTexture;U&&N.push(this.exportTextureAsync(U,C).then((N=>{N&&(T.emissiveTexture=N)}))),N.length>0&&(this._exporter._materialNeedsUVsSet.add(p),await Promise.all(N))}const X=p._emissiveColor;X.equalsWithEpsilon(J,v)||(T.emissiveFactor=X.UX()),T.pbrMetallicRoughness=A}_getPixelsFromTextureAsync(N){return function(N){switch(N){case K.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case K.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case K.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case K.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case K.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case K.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case K.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case K.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case K.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case K.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case K.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case K.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(N.textureFormat)?(0,g.g)(N,N._texture.width,N._texture.height):(N.textureType,K.e.TEXTURETYPE_UNSIGNED_BYTE,N.readPixels())}async exportTextureAsync(N,p){const T=this._exporter._extensionsPreExportTextureAsync("exporter",N,p);return T?await T.then((async T=>T?await this._exportTextureInfoAsync(T,p):await this._exportTextureInfoAsync(N,p))):await this._exportTextureInfoAsync(N,p)}async _exportTextureInfoAsync(N,p){let T=this._textureMap.get(N);if(!T){const A=await this._getPixelsFromTextureAsync(N);if(!A)return null;const C=this._exportTextureSampler(N),U=N.mimeType;if(U)switch(U){case"image/jpeg":case"image/png":case"image/webp":p=U;break;default:a.Tools.Warn(`Unsupported media type: ${U}. Exporting texture as PNG.`)}const X=this._internalTextureToImage,y=N.getInternalTexture().uniqueId;X[y]||(X[y]={});let e=X[y][p];if(void 0===e){const T=N.getSize();e=(async()=>{const a=await this._getImageDataAsync(A,T.width,T.height,p);return this._exportImage(N.name,p,a)})(),X[y][p]=e}T=this._exportTextureInfo(await e,C,N.coordinatesIndex),this._textureMap.set(N,T),this._exporter._extensionsPostExportTextures("exporter",T,N)}return T}_exportImage(N,p,T){const A=this._exporter._images;let C;if(this._exporter._shouldUseGlb){C={name:N,mimeType:p,bufferView:void 0};const A=this._exporter._bufferManager.createBufferView(new Uint8Array(T));this._exporter._bufferManager.setBufferView(C,A)}else{const U=N.replace(/\.\/|\/|\.\\|\\/g,"_"),X=function(N){switch(N){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(p);let y=U+X;A.some((N=>N.uri===y))&&(y=`${U}_${a.Tools.RandomId()}${X}`),C={name:N,uri:y},this._exporter._imageData[y]={data:T,mimeType:p}}return A.push(C),A.length-1}_exportTextureInfo(N,p,T){const A=this._exporter._textures;let a=A.findIndex((T=>T.sampler==p&&T.source===N));-1===a&&(a=A.length,A.push({source:N,sampler:p}));const C={index:a};return T&&(C.texCoord=T),C}_exportTextureSampler(N){const p=this._getTextureSampler(N),T=this._exporter._samplers,A=T.findIndex((N=>N.minFilter===p.minFilter&&N.magFilter===p.magFilter&&N.wrapS===p.wrapS&&N.wrapT===p.wrapT));return-1!==A?A:(T.push(p),T.length-1)}}var h=T(12459),j=T(12205),V=T(12871),r=T(12376);const u=A.xp.Zero(),Y=A.Quaternion.Identity(),D=A.xp.One(),c=new A.xp(-1,1,1);function Q(N,p){const{byteOffset:T,byteStride:A,type:a,normalized:C}=N,U=N.getSize(),X=p.reduce(((N,p)=>p.getTotalVertices()>N?p.getTotalVertices():N),-Number.MAX_VALUE);return{byteOffset:T,byteStride:A,componentCount:U,type:a,count:X*U,normalized:C,totalVertices:X,kind:N.getKind()}}function E(N){switch(N){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function O(N){switch(N){case H.f.PositionKind:case H.f.NormalKind:case H.f.TangentKind:case H.f.ColorKind:case H.f.MatricesIndicesKind:case H.f.MatricesIndicesExtraKind:case H.f.MatricesWeightsKind:case H.f.MatricesWeightsExtraKind:case H.f.UVKind:case H.f.UV2Kind:case H.f.UV3Kind:case H.f.UV4Kind:case H.f.UV5Kind:case H.f.UV6Kind:return!0}return!1}function B(N){switch(N){case C.c.TriangleFillMode:return 4;case C.c.TriangleStripDrawMode:return 5;case C.c.TriangleFanDrawMode:return 6;case C.c.PointListDrawMode:case C.c.PointFillMode:return 0;case C.c.LineLoopDrawMode:return 2;case C.c.LineListDrawMode:return 1;case C.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${N}`)}function d(N){const p=Math.sqrt(N.x*N.x+N.y*N.y+N.z*N.z);p>0&&(N.x/=p,N.y/=p,N.z/=p)}function t(N){return N.x*=-1,N}function S(N){if(N.x*N.x+N.y*N.y>.5){const p=Math.abs(N.x),T=Math.abs(N.y);if(p>T){const T=Math.sign(N.x);N.x=p,N.y*=-T,N.z*=-T,N.w*=T}else{const p=Math.sign(N.y);N.x*=-p,N.y=T,N.z*=p,N.w*=-p}}else{const p=Math.abs(N.z),T=Math.abs(N.w);if(p>T){const T=Math.sign(N.z);N.x*=-T,N.y*=T,N.z=p,N.w*=-T}else{const p=Math.sign(N.w);N.x*=p,N.y*=-p,N.z*=-p,N.w=T}}return N}function s(N){N.kX(-N.z,N.w,N.x,-N.y)}function NN(N,p){const T=A.xp.FromArrayToRef(p.translation||[0,0,0],0,A.TmpVectors.xp[0]),a=A.Quaternion.FromArrayToRef(p.rotation||[0,0,0,1],0,A.TmpVectors.Quaternion[0]),C=A.Matrix.ComposeToRef(D,a,T,A.TmpVectors.Matrix[0]),U=A.xp.FromArrayToRef(N.translation||[0,0,0],0,A.TmpVectors.xp[2]),X=A.Quaternion.FromArrayToRef(N.rotation||[0,0,0,1],0,A.TmpVectors.Quaternion[1]),y=A.Matrix.ComposeToRef(D,X,U,A.TmpVectors.Matrix[1]);C.multiplyToRef(y,y),y.decompose(void 0,a,T),T.equalsWithEpsilon(u,r.b)?delete p.translation:p.translation=T.UX(),a.equalsWithEpsilon(Y,r.b)?delete p.rotation:p.rotation=a.UX(),p.scale&&delete p.scale}function pN(N,p){if(!(p instanceof M.b))return!1;if(!(1===p.getChildren().length&&0===N.getChildren().length&&N.parent===p))return!1;const T=N.KN(),A=N instanceof V.c&&!T.useRightHandedSystem?c:D;return!!p.xX.equalsWithEpsilon(A,r.b)||(j.d.Warn(`Cannot collapse node ${N.name} into parent node ${p.name} with modified scaling.`),!1)}function TN(N){if(N instanceof Array){const p=new Float32Array(N);return new Uint8Array(p.buffer,p.byteOffset,p.byteLength)}return ArrayBuffer.isView(N)?new Uint8Array(N.buffer,N.byteOffset,N.byteLength):new Uint8Array(N)}function AN(N,p){for(const[T,A]of Object.entries(N)){const a=p[T];(Array.isArray(A)&&Array.isArray(a)&&aN(A,a)||A===a)&&delete N[T]}return N}function aN(N,p){return N.length===p.length&&N.every(((N,T)=>N===p[T]))}const CN=A.Matrix.Compose(new A.xp(-1,1,1),A.Quaternion.Identity(),A.xp.Zero());function UN(N,p){if(!(N instanceof M.b))return!1;if(p){if(!N.getWorldMatrix().equalsWithEpsilon(A.Matrix.IdentityReadOnly,r.b))return!1}else{if(!N.getWorldMatrix().multiplyToRef(CN,A.TmpVectors.Matrix[0]).equalsWithEpsilon(A.Matrix.IdentityReadOnly,r.b))return!1}return!(N instanceof b.c&&N.MX)}const XN=new Map([[Int8Array,(N,p,T)=>N.setInt8(p,T)],[Uint8Array,(N,p,T)=>N.setUint8(p,T)],[Uint8ClampedArray,(N,p,T)=>N.setUint8(p,T)],[Int16Array,(N,p,T)=>N.setInt16(p,T,!0)],[Uint16Array,(N,p,T)=>N.setUint16(p,T,!0)],[Int32Array,(N,p,T)=>N.setInt32(p,T,!0)],[Uint32Array,(N,p,T)=>N.setUint32(p,T,!0)],[Float32Array,(N,p,T)=>N.setFloat32(p,T,!0)],[Float64Array,(N,p,T)=>N.setFloat64(p,T,!0)]]);class yN{writeTypedArray(N){this._checkGrowBuffer(N.byteLength);const p=XN.get(N.constructor);for(let T=0;T<N.length;T++)p(this._dataView,this._byteOffset,N[T]),this._byteOffset+=N.BYTES_PER_ELEMENT}constructor(N){this._data=new Uint8Array(N),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(N){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,N),this._byteOffset++}writeInt8(N){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,N),this._byteOffset++}writeInt16(N){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,N,!0),this._byteOffset+=2}writeUInt16(N){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,N,!0),this._byteOffset+=2}writeInt32(N){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,N,!0),this._byteOffset+=4}writeUInt32(N){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,N,!0),this._byteOffset+=4}writeFloat32(N){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,N,!0),this._byteOffset+=4}writeFloat64(N){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,N,!0),this._byteOffset+=8}_checkGrowBuffer(N){const p=this.byteOffset+N;if(p>this._data.byteLength){const N=new Uint8Array(2*p);N.set(this._data),this._data=N,this._dataView=new DataView(this._data.buffer)}}}function eN(N){return N%4===0?4:N%2===0?2:1}class HN{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(N){let p=0;this._bufferViewToData.forEach((N=>{p+=N.byteLength}));const T=new yN(p),A=Array.from(this._bufferViewToData.keys()).sort(((N,p)=>eN(p.byteLength)-eN(N.byteLength)));for(const a of A){a.byteOffset=T.byteOffset,N.push(a);const p=N.length-1,A=this.getPropertiesWithBufferView(a);for(const N of A)N.bufferView=p;T.writeTypedArray(this._bufferViewToData.get(a)),this._bufferViewToData.delete(a)}return T.getOutputData()}createBufferView(N,p){const T={buffer:0,byteOffset:void 0,byteLength:N.byteLength,byteStride:p};return this._bufferViewToData.set(T,N),T}createAccessor(N,p,T,A,a,C,U){this._verifyBufferView(N);const X={bufferView:void 0,componentType:T,count:A,type:p,min:null===C||void 0===C?void 0:C.min,max:null===C||void 0===C?void 0:C.max,normalized:U,byteOffset:a};return this.setBufferView(X,N),this._accessorToBufferView.set(X,N),X}setBufferView(N,p){this._verifyBufferView(p);this.getPropertiesWithBufferView(p).push(N)}removeBufferView(N){const p=this.getPropertiesWithBufferView(N);for(const T of p)void 0!==T.bufferView&&delete T.bufferView;this._bufferViewToData.delete(N),this._bufferViewToProperties.delete(N),this._accessorToBufferView.forEach(((p,T)=>{p===N&&(void 0!==T.byteOffset&&delete T.byteOffset,this._accessorToBufferView.delete(T))}))}getBufferView(N){const p=this._accessorToBufferView.get(N);return this._verifyBufferView(p),p}getPropertiesWithBufferView(N){return this._verifyBufferView(N),this._bufferViewToProperties.set(N,this._bufferViewToProperties.get(N)??[]),this._bufferViewToProperties.get(N)}getData(N){return this._verifyBufferView(N),this._bufferViewToData.get(N)}_verifyBufferView(N){if(void 0===N||!this._bufferViewToData.has(N))throw new Error(`BufferView ${N} not found in BufferManager.`)}}var MN,bN=T(12837),lN=T(12847),kN=T(12880),xN=T(12745),IN=T(12912),LN=T(12916),nN=T(12833),wN=T(12921);!function(N){N[N.INTANGENT=0]="INTANGENT",N[N.OUTTANGENT=1]="OUTTANGENT"}(MN||(MN={}));class gN{static _IsTransformable(N){return N&&(N instanceof M.b||N instanceof bN.d||N instanceof wN.c)}static _CreateNodeAnimation(N,p,T,A,C){if(this._IsTransformable(N)){const U=[],X=[],y=p.getKeys(),e=gN._CalculateMinMaxKeyFrames(y),H=gN._DeduceInterpolation(y,T,A),M=H.interpolationType,b=H.shouldBakeAnimation;if(b?gN._CreateBakedAnimation(N,p,T,e.min,e.max,p.framePerSecond,C,U,X,e,A):"LINEAR"===M||"STEP"===M?gN._CreateLinearOrStepAnimation(N,p,T,U,X,A):"CUBICSPLINE"===M?gN._CreateCubicSplineAnimation(N,p,T,U,X,A):gN._CreateBakedAnimation(N,p,T,e.min,e.max,p.framePerSecond,C,U,X,e,A),U.length&&X.length){return{inputs:U,outputs:X,samplerInterpolation:M,inputsMin:b?e.min:a.Tools.FloatRound(e.min/p.framePerSecond),inputsMax:b?e.max:a.Tools.FloatRound(e.max/p.framePerSecond)}}}return null}static _DeduceAnimationInfo(N){let p=null,T="VEC3",A=!1;const C=N.targetProperty.split(".");switch(C[0]){case"xX":p="scale";break;case"position":p="translation";break;case"rotation":T="VEC4",p="rotation";break;case"rotationQuaternion":T="VEC4",A=!0,p="rotation";break;case"influence":T="SCALAR",p="weights";break;default:a.Tools.Error(`Unsupported animatable property ${C[0]}`)}return p?{animationChannelTargetPath:p,dataAccessorType:T,useQuaternion:A}:(a.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(N,p,T,A,a,C,U,X,y,e,H){let M;if(gN._IsTransformable(N)&&N.animations)for(const b of N.animations){if(H&&!H(b))continue;const a=gN._DeduceAnimationInfo(b);a&&(M={name:b.name,samplers:[],channels:[]},gN._AddAnimation(`${b.name}`,b.hasRunningRuntimeAnimations?p:M,N,b,a.dataAccessorType,a.animationChannelTargetPath,A,C,U,X,a.useQuaternion,y,e),M.samplers.length&&M.channels.length&&T.push(M))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(N,p,T,A,a,C,U,X,y,e,H){let M;if(N instanceof nN.d){const a=N.morphTargetManager;if(a)for(let b=0;b<a.numTargets;++b){const l=a.getTarget(b);for(const k of l.animations){if(H&&!H(k))continue;const l=new IN.b(`${k.name}`,"influence",k.framePerSecond,k.dataType,k.loopMode,k.enableBlending),x=[],I=k.getKeys();for(let N=0;N<I.length;++N){const p=I[N];for(let N=0;N<a.numTargets;++N)N==b?x.push(p):x.push({frame:p.frame,value:0})}l.setKeys(x);const L=gN._DeduceAnimationInfo(l);L&&(M={name:l.name,samplers:[],channels:[]},gN._AddAnimation(k.name,k.hasRunningRuntimeAnimations?p:M,N,l,L.dataAccessorType,L.animationChannelTargetPath,A,C,U,X,L.useQuaternion,y,e,a.numTargets),M.samplers.length&&M.channels.length&&T.push(M))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(N,p,T,A,a,C,U,X,y){let e;if(N.animationGroups){const M=N.animationGroups;for(const b of M){const M=new Map,l=new Map,k=new Set,x=b.to-b.from;e={name:b.name,channels:[],samplers:[]};for(let p=0;p<b.targetedAnimations.length;++p){const x=b.targetedAnimations[p],I=x.target,L=x.animation;if(y&&!y(L))continue;const n=X.has(I);if(this._IsTransformable(I)||1===I.length&&this._IsTransformable(I[0])){const N=gN._DeduceAnimationInfo(x.animation);if(N){const p=this._IsTransformable(I)?I:this._IsTransformable(I[0])?I[0]:null;p&&gN._AddAnimation(`${L.name}`,e,p,L,N.dataAccessorType,N.animationChannelTargetPath,T,A,a,C,N.useQuaternion,U,n)}}else if(I instanceof LN.c||1===I.length&&I[0]instanceof LN.c){if(gN._DeduceAnimationInfo(x.animation)){const p=I instanceof LN.c?I:I[0];if(p){const T=N.morphTargetManagers.find((N=>{for(let T=0;T<N.numTargets;++T)if(N.getTarget(T)===p)return!0;return!1}));if(T){const A=N.meshes.find((N=>N.morphTargetManager===T));var H;if(A)M.has(A)||M.set(A,new Map),null===(H=M.get(A))||void 0===H||H.set(p,L),k.add(A),l.set(A,L)}}}}}k.forEach((N=>{const p=N.morphTargetManager;let X=null;const y=[],H=l.get(N).getKeys(),k=H.length;for(let T=0;T<k;++T)for(let A=0;A<p.numTargets;++A){const a=p.getTarget(A),C=M.get(N);if(C){const p=C.get(a);p?(X||(X=new IN.b(`${b.name}_${N.name}_MorphWeightAnimation`,"influence",p.framePerSecond,IN.b.ANIMATIONTYPE_FLOAT,p.loopMode,p.enableBlending)),y.push(p.getKeys()[T])):y.push({frame:b.from+x/k*T,value:a.influence,inTangent:H[0].inTangent?0:void 0,outTangent:H[0].outTangent?0:void 0})}}X.setKeys(y);const I=gN._DeduceAnimationInfo(X);I&&gN._AddAnimation(`${b.name}_${N.name}_MorphWeightAnimation`,e,N,X,I.dataAccessorType,I.animationChannelTargetPath,T,A,a,C,I.useQuaternion,U,!1,null===p||void 0===p?void 0:p.numTargets)})),e.channels.length&&e.samplers.length&&p.push(e)}}}static _AddAnimation(N,p,T,a,C,U,X,y,e,H,M,b,l,k){const x=gN._CreateNodeAnimation(T,a,U,M,b);let I,L,n,w,g,P;if(x){if(k){let N=0,p=0;const T=[];for(;x.inputs.length>0;)p=x.inputs.shift(),N%k==0&&T.push(p),N++;x.inputs=T}const N=X.get(T),a=new Float32Array(x.inputs);I=y.createBufferView(a),L=y.createAccessor(I,"SCALAR",5126,x.inputs.length,void 0,{min:[x.inputsMin],max:[x.inputsMax]}),H.push(L),n=H.length-1;const e=new A.Quaternion,M=new A.xp,b=new A.xp,i=T instanceof bN.d,K=E(C),F=new Float32Array(x.outputs.length*K);x.outputs.forEach((function(N,p){let T=N;switch(U){case"translation":l&&(A.xp.FromArrayToRef(N,0,b),t(b),b.toArray(T));break;case"rotation":4===N.length?A.Quaternion.FromArrayToRef(N,0,e):(T=new Array(4),A.xp.FromArrayToRef(N,0,M),A.Quaternion.FromEulerVectorToRef(M,e)),l&&(S(e),i&&s(e)),e.toArray(T)}F.set(T,p*K)})),I=y.createBufferView(F),L=y.createAccessor(I,C,5126,x.outputs.length),H.push(L),w=H.length-1,g={interpolation:x.samplerInterpolation,input:n,output:w},p.samplers.push(g),P={sampler:p.samplers.length-1,target:{node:N,path:U}},p.channels.push(P)}}static _CreateBakedAnimation(N,p,T,C,U,X,y,e,H,M,b){let l;const k=A.Quaternion.Identity();let x,I=null,L=null,n=null,w=null,g=null,P=null;M.min=a.Tools.FloatRound(C/X);const i=p.getKeys();for(let A=0,K=i.length;A<K;++A){if(P=null,n=i[A],A+1<K)if(w=i[A+1],n.value.equals&&n.value.equals(w.value)||n.value===w.value){if(0!==A)continue;P=n.frame}else P=w.frame;else{if(g=i[A-1],n.value.equals&&n.value.equals(g.value)||n.value===g.value)continue;P=U}if(P)for(let A=n.frame;A<=P;A+=y){if(x=a.Tools.FloatRound(A/X),x===I)continue;I=x,L=x;const C={key:0,repeatCount:0,loopMode:p.loopMode};l=p._interpolate(A,C),gN._SetInterpolatedValue(N,l,x,p,T,k,e,H,b)}}L&&(M.max=L)}static _ConvertFactorToVector3OrQuaternion(N,p,T,C,U){const X=gN._GetBasePositionRotationOrScale(p,C,U),y=T.targetProperty.split("."),e=y?y[1]:"",H=U?A.Quaternion.gp(X).normalize():A.xp.gp(X);switch(e){case"x":case"y":case"z":H[e]=N;break;case"w":H.w=N;break;default:a.Tools.Error(`glTFAnimation: Unsupported component name "${e}"!`)}return H}static _SetInterpolatedValue(N,p,T,a,C,U,X,y,e){let H;X.push(T),"weights"!==C?(a.dataType===IN.b.ANIMATIONTYPE_FLOAT&&(p=this._ConvertFactorToVector3OrQuaternion(p,N,a,C,e)),"rotation"===C?(e?U=p:(H=p,A.Quaternion.RotationYawPitchRollToRef(H.y,H.x,H.z,U)),y.push(U.UX())):(H=p,y.push(H.UX()))):y.push([p])}static _CreateLinearOrStepAnimation(N,p,T,A,a,C){for(const U of p.getKeys())A.push(U.frame/p.framePerSecond),gN._AddKeyframeValue(U,p,a,T,N,C)}static _CreateCubicSplineAnimation(N,p,T,A,a,C){p.getKeys().forEach((function(U){A.push(U.frame/p.framePerSecond),gN._AddSplineTangent(MN.INTANGENT,a,T,"CUBICSPLINE",U,C),gN._AddKeyframeValue(U,p,a,T,N,C),gN._AddSplineTangent(MN.OUTTANGENT,a,T,"CUBICSPLINE",U,C)}))}static _GetBasePositionRotationOrScale(N,p,T){let a;if("rotation"===p)if(T){a=(N.rotationQuaternion??A.Quaternion.Identity()).UX()}else{a=(N.rotation??A.xp.Zero()).UX()}else if("translation"===p){a=(N.position??A.xp.Zero()).UX()}else{a=(N.xX??A.xp.One()).UX()}return a}static _AddKeyframeValue(N,p,T,C,U,X){let y;const e=p.dataType;if(e===IN.b.ANIMATIONTYPE_VECTOR3){let p=N.value.UX();if("rotation"===C){const N=A.xp.gp(p);p=A.Quaternion.RotationYawPitchRoll(N.y,N.x,N.z).UX()}T.push(p)}else if(e===IN.b.ANIMATIONTYPE_FLOAT){if("weights"===C)T.push([N.value]);else if(y=this._ConvertFactorToVector3OrQuaternion(N.value,U,p,C,X),y){if("rotation"===C){const N=X?y:A.Quaternion.RotationYawPitchRoll(y.y,y.x,y.z).normalize();T.push(N.UX())}T.push(y.UX())}}else e===IN.b.ANIMATIONTYPE_QUATERNION?T.push(N.value.normalize().UX()):a.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(N,p,T){let A,a,C=!1;if("rotation"===p&&!T)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let U=0,X=N.length;U<X;++U)if(a=N[U],a.inTangent||a.outTangent)if(A){if("CUBICSPLINE"!==A){A="LINEAR",C=!0;break}}else A="CUBICSPLINE";else if(A){if("CUBICSPLINE"===A||a.interpolation&&1===a.interpolation&&"STEP"!==A){A="LINEAR",C=!0;break}}else A=a.interpolation&&1===a.interpolation?"STEP":"LINEAR";return A||(A="LINEAR"),{interpolationType:A,shouldBakeAnimation:C}}static _AddSplineTangent(N,p,T,a,C,U){let X;const y=N===MN.INTANGENT?C.inTangent:C.outTangent;if("CUBICSPLINE"===a){if("rotation"===T)if(y)if(U)X=y.UX();else{const N=y;X=A.Quaternion.RotationYawPitchRoll(N.y,N.x,N.z).UX()}else X=[0,0,0,0];else X="weights"===T?y?[y]:[0]:y?y.UX():[0,0,0];p.push(X)}}static _CalculateMinMaxKeyFrames(N){let p=1/0,T=-1/0;return N.forEach((function(N){p=Math.min(p,N.frame),T=Math.max(T,N.frame)})),{min:p,max:T}}}function PN(N,p,T,C,U,X){const y={attributes:{},influence:N.influence,name:N.name},e=p.MX;if(!e)return a.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),y;const M=X?-1:1,b=A.xp.Zero();let l=0,k=0;if(N.hasPositions){const C=N.getPositions(),X=e.getVerticesData(H.f.PositionKind);if(X){const N=new Float32Array(X.length),p=[1/0,1/0,1/0],a=[-1/0,-1/0,-1/0];k=X.length/3,l=0;for(let T=l;T<k;++T){const U=A.xp.gp(X,3*T);A.xp.gp(C,3*T).subtractToRef(U,b),b.x*=M,p[0]=Math.min(p[0],b.x),a[0]=Math.max(a[0],b.x),p[1]=Math.min(p[1],b.y),a[1]=Math.max(a[1],b.y),p[2]=Math.min(p[2],b.z),a[2]=Math.max(a[2],b.z),N[3*T]=b.x,N[3*T+1]=b.y,N[3*T+2]=b.z}const e=T.createBufferView(N,12),H=T.createAccessor(e,"VEC3",5126,C.length/3,0,{min:p,max:a});U.push(H),y.attributes.POSITION=U.length-1}else a.Tools.Warn(`Morph target positions for mesh ${p.name} were not exported. Mesh does not have position vertex data`)}if(N.hasNormals){const C=N.getNormals(),X=e.getVerticesData(H.f.NormalKind);if(X){const N=new Float32Array(X.length);k=X.length/3,l=0;for(let T=l;T<k;++T){const p=A.xp.gp(X,3*T).normalize();A.xp.gp(C,3*T).normalize().subtractToRef(p,b),N[3*T]=b.x*M,N[3*T+1]=b.y,N[3*T+2]=b.z}const p=T.createBufferView(N,12),a=T.createAccessor(p,"VEC3",5126,C.length/3,0);U.push(a),y.attributes.NORMAL=U.length-1}else a.Tools.Warn(`Morph target normals for mesh ${p.name} were not exported. Mesh does not have normals vertex data`)}if(N.hasTangents){const C=N.getTangents(),X=e.getVerticesData(H.f.TangentKind);if(X){k=X.length/4;const N=new Float32Array(3*k);l=0;for(let T=l;T<k;++T){const p=A.xp.gp(X,4*T);d(p);const a=A.xp.gp(C,3*T);d(a),a.subtractToRef(p,b),N[3*T]=b.x*M,N[3*T+1]=b.y,N[3*T+2]=b.z}const p=T.createBufferView(N,12),a=T.createAccessor(p,"VEC3",5126,k,0);U.push(a),y.attributes.TANGENT=U.length-1}else a.Tools.Warn(`Morph target tangents for mesh ${p.name} were not exported. Mesh does not have tangents vertex data`)}if(N.hasColors){const C=N.getColors(),X=e.getVerticesData(H.f.ColorKind),M=e.getVertexBuffer(H.f.ColorKind);if(X&&M){const N=M.getSize();k=X.length/N;const p=new Float32Array(k*N);l=0;for(let T=l;T<k;++T)if(3===N){const a=A.xp.gp(X,T*N);A.xp.gp(C,T*N).subtractToRef(a,b),p[3*T]=b.x,p[3*T+1]=b.y,p[3*T+2]=b.z}else if(4===N){const a=new A.Vector4,U=A.Vector4.gp(X,T*N);A.Vector4.gp(C,T*N).subtractToRef(U,a),p[4*T]=a.x,p[4*T+1]=a.y,p[4*T+2]=a.z,p[4*T+3]=a.w}else a.Tools.Warn(`Unsupported number of components for color attribute: ${N}`);const e=T.createBufferView(p,4*N),H=T.createAccessor(e,3===N?"VEC3":"VEC4",5126,k,0);U.push(H),y.attributes.COLOR_0=U.length-1}else a.Tools.Warn(`Morph target colors for mesh ${p.name} were not exported. Mesh does not have colors vertex data`)}return y}var iN=T(12930),KN=T(12777),FN=T(12761),vN=T(12331);class WN{}WN.DEFAULT_COLOR=I.wp.White(),WN.DEFAULT_WIDTH_ATTENUATED=1,WN.DEFAULT_WIDTH=.1;var zN=T(12589),RN=T(12938);class JN{static ConvertPoints(N,p){if(N.length&&Array.isArray(N)&&"number"===typeof N[0])return[N];if(N.length&&Array.isArray(N[0])&&"number"===typeof N[0][0])return N;if(N.length&&!Array.isArray(N[0])&&N[0]instanceof A.xp){const p=[];for(let T=0;T<N.length;T++){const A=N[T];p.push(A.x,A.y,A.z)}return[p]}if(N.length>0&&Array.isArray(N[0])&&N[0].length>0&&N[0][0]instanceof A.xp){const p=[],T=N;for(const N of T)p.push(N.flatMap((N=>[N.x,N.y,N.z])));return p}if(N instanceof Float32Array){if(null!==p&&void 0!==p&&p.floatArrayStride){const T=[],A=3*p.floatArrayStride;for(let p=0;p<N.length;p+=A){const a=new Array(A);for(let T=0;T<A;T++)a[T]=N[p+T];T.push(a)}return T}return[Array.from(N)]}if(N.length&&N[0]instanceof Float32Array){const p=[];for(const T of N)p.push(Array.from(T));return p}return[]}static OmitZeroLengthPredicate(N,p,T){const A=[];return p.Ip(N).lengthSquared()>0&&A.push([N,p]),T.Ip(p).lengthSquared()>0&&A.push([p,T]),N.Ip(T).lengthSquared()>0&&A.push([T,N]),0===A.length?null:A}static OmitDuplicatesPredicate(N,p,T,A){const a=[];return JN._SearchInPoints(N,p,A)||a.push([N,p]),JN._SearchInPoints(p,T,A)||a.push([p,T]),JN._SearchInPoints(T,N,A)||a.push([T,N]),0===a.length?null:a}static _SearchInPoints(N,p,T){for(const U of T)for(let T=0;T<U.length;T++){var A,a,C;if(null!==(A=U[T])&&void 0!==A&&A.equals(N))if(null!==(a=U[T+1])&&void 0!==a&&a.equals(p)||null!==(C=U[T-1])&&void 0!==C&&C.equals(p))return!0}return!1}static MeshesToLines(N,p){const T=[];for(let a=0;a<N.length;a++){const C=N[a],U=C.getVerticesData(H.f.PositionKind),X=C.bX();if(U&&X)for(let N=0,y=0;N<X.length;N++){const e=3*X[y++],H=3*X[y++],M=3*X[y++],b=new A.xp(U[e],U[e+1],U[e+2]),l=new A.xp(U[H],U[H+1],U[H+2]),k=new A.xp(U[M],U[M+1],U[M+2]);if(p){const A=p(b,l,k,T,N,e,C,a,U,X);if(A)for(const N of A)T.push(N)}else T.push([b,l],[l,k],[k,b])}}return T}static ToVector3Array(N){if(Array.isArray(N[0])){const p=[],T=N;for(const N of T){const T=[];for(let p=0;p<N.length;p+=3)T.push(new A.xp(N[p],N[p+1],N[p+2]));p.push(T)}return p}const p=N,T=[];for(let a=0;a<p.length;a+=3)T.push(new A.xp(p[a],p[a+1],p[a+2]));return T}static ToNumberArray(N){return N.flatMap((N=>[N.x,N.y,N.z]))}static GetPointsCountInfo(N){const p=new Array(N.length);let T=0;for(let A=N.length;A--;)p[A]=N[A].length/3,T+=p[A];return{total:T,counts:p}}static GetLineLength(N){if(0===N.length)return 0;let p;p="number"===typeof N[0]?JN.ToVector3Array(N):N;const T=A.TmpVectors.xp[0];let a=0;for(let A=0;A<p.length-1;A++){const N=p[A];a+=p[A+1].subtractToRef(N,T).length()}return a}static GetLineLengthArray(N){const p=new Float32Array(N.length/3);let T=0;for(let A=0,a=N.length/3-1;A<a;A++){let a=N[3*A+0],C=N[3*A+1],U=N[3*A+2];a-=N[3*A+3],C-=N[3*A+4],U-=N[3*A+5];T+=Math.sqrt(a*a+C*C+U*U),p[A+1]=T}return p}static SegmentizeSegmentByCount(N,p,T){const a=[],C=p.Ip(N),U=A.TmpVectors.xp[0];U.IX(T);const X=A.TmpVectors.xp[1];C.divideToRef(U,X);let y=N.clone();a.push(y);for(let A=0;A<T;A++)y=y.clone(),a.push(y.addInPlace(X));return a}static SegmentizeLineBySegmentLength(N,p){const T=N[0]instanceof A.xp?JN.GetLineSegments(N):"number"===typeof N[0]?JN.GetLineSegments(JN.ToVector3Array(N)):N,a=[];for(const A of T)if(A.length>p){const N=JN.SegmentizeSegmentByCount(A.point1,A.point2,Math.ceil(A.length/p));for(const p of N)a.push(p)}else a.push(A.point1),a.push(A.point2);return a}static SegmentizeLineBySegmentCount(N,p){const T="number"===typeof N[0]?JN.ToVector3Array(N):N,A=JN.GetLineLength(T)/p;return JN.SegmentizeLineBySegmentLength(T,A)}static GetLineSegments(N){const p=[];for(let T=0;T<N.length-1;T++){const A=N[T],a=N[T+1],C=a.Ip(A).length();p.push({point1:A,point2:a,length:C})}return p}static GetMinMaxSegmentLength(N){const p=JN.GetLineSegments(N).sort((N=>N.length));return{min:p[0].length,max:p[p.length-1].length}}static GetPositionOnLineByVisibility(N,p,T){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const C=p*T;let U=0,X=0;const y=N.length;for(let A=0;A<y;A++){if(C<=U+N[A].length){X=A;break}U+=N[A].length}const e=(C-U)/N[X].length;return N[X].point2.subtractToRef(N[X].point1,A.TmpVectors.xp[0]),A.TmpVectors.xp[1]=A.TmpVectors.xp[0].multiplyByFloats(e,e,e),a||A.TmpVectors.xp[1].addInPlace(N[X].point1),A.TmpVectors.xp[1].clone()}static GetCircleLinePoints(N,p){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N,C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/p;const U=[];for(let X=0;X<=p;X++)U.push(new A.xp(Math.cos(X*C)*N,Math.sin(X*C)*a,T));return U}static GetBezierLinePoints(N,p,T,A){return zN.g.CreateQuadraticBezier(N,p,T,A).getPoints().flatMap((N=>[N.x,N.y,N.z]))}static GetArrowCap(N,p,T,A,a){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[N.clone(),N.add(p.multiplyByFloats(T,T,T))],widths:[A,a,C,U]}}static GetPointsFromText(N,p,T,A){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const U=[],X=(0,RN.d)(N,p,T,A);for(const y of X){for(const N of y.paths){const p=[],T=N.getPoints();for(const N of T)p.push(N.x,N.y,a);U.push(p)}if(C)for(const N of y.holes){const p=[],T=N.getPoints();for(const N of T)p.push(N.x,N.y,a);U.push(p)}}return U}static Color3toRGBAUint8(N){const p=new Uint8Array(4*N.length);for(let T=0,A=0;T<N.length;T++)p[A++]=255*N[T].r,p[A++]=255*N[T].g,p[A++]=255*N[T].b,p[A++]=255;return p}static CreateColorsTexture(N,p,T,A){const a=A.getEngine().getCaps().maxTextureSize??1,C=p.length>a?a:p.length,U=Math.ceil(p.length/a);U>1&&(p=[...p,...Array(C*U-p.length).fill(p[0])]);const X=JN.Color3toRGBAUint8(p),y=new i.d(X,C,U,k.d.TEXTUREFORMAT_RGBA,A,!1,!0,T);return y.name=N,y}static PrepareEmptyColorsTexture(N){if(!WN.EmptyColorsTexture){const p=new Uint8Array(4);WN.EmptyColorsTexture=new i.d(p,1,1,k.d.TEXTUREFORMAT_RGBA,N,!1,!1,i.d.NEAREST_NEAREST),WN.EmptyColorsTexture.name="grlEmptyColorsTexture"}return WN.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var N;null===(N=WN.EmptyColorsTexture)||void 0===N||N.dispose(),WN.EmptyColorsTexture=null}static BooleanToNumber(N){return N?1:0}}class fN extends FN.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class GN extends KN.c{isCompatible(N){return!0}constructor(N,p,T){var a;T=T||{color:WN.DEFAULT_COLOR};const C=new fN;C.GREASED_LINE_HAS_COLOR=!!T.color&&!T.useColors,C.GREASED_LINE_SIZE_ATTENUATION=T.sizeAttenuation??!1,C.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===T.colorDistributionType,C.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(p??N.KN()).useRightHandedSystem,C.GREASED_LINE_CAMERA_FACING=T.cameraFacing??!0,super(N,GN.GREASED_LINE_MATERIAL_NAME,200,C,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(a=T)||void 0===a?void 0:a.forceGLSL)||GN.ForceGLSL,this._scene=p??N.KN(),this._engine=this._scene.getEngine(),this._cameraFacing=T.cameraFacing??!0,this.visibility=T.visibility??1,this.useDash=T.useDash??!1,this.dashRatio=T.dashRatio??.5,this.dashOffset=T.dashOffset??0,this.width=T.width?T.width:T.sizeAttenuation?WN.DEFAULT_WIDTH_ATTENUATED:WN.DEFAULT_WIDTH,this._sizeAttenuation=T.sizeAttenuation??!1,this.colorMode=T.colorMode??0,this._color=T.color??null,this.useColors=T.useColors??!1,this._colorsDistributionType=T.colorDistributionType??0,this.colorsSampling=T.colorsSampling??i.d.NEAREST_NEAREST,this._colors=T.zN??null,this.dashCount=T.dashCount??1,this.resolution=T.resolution??new A.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),T.colorsTexture?this.colorsTexture=T.colorsTexture:this._colors?this.colorsTexture=JN.CreateColorsTexture(`${N.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??WN.DEFAULT_COLOR,JN.PrepareEmptyColorsTexture(this._scene)),this._engine.SU.add((()=>{JN.DisposeEmptyColorsTexture()}))}getAttributes(N){N.push("grl_offsets"),N.push("grl_widths"),N.push("grl_colorPointers"),N.push("grl_counters"),this._cameraFacing?(N.push("grl_previousAndSide"),N.push("grl_nextAndCounters")):N.push("grl_slopes")}getSamplers(N){N.push("grl_colors")}getActiveTextures(N){this.colorsTexture&&N.push(this.colorsTexture)}getUniforms(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const p=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&p.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===N&&p.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:p,vertex:this._cameraFacing&&this._isGLSL(N)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(N)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(N){if(this._cameraFacing){N.eX("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||N.eX("viewProjection",this._scene.getTransformMatrix());const p=A.TmpVectors.Vector4[0];p.x=this._aspect,p.y=this._resolution.x,p.z=this._resolution.y,p.w=this.width,N.updateVector4("grl_aspect_resolution_lineWidth",p)}const p=A.TmpVectors.Vector4[0];p.x=JN.BooleanToNumber(this.useDash),p.y=this._dashArray,p.z=this.dashOffset,p.w=this.dashRatio,N.updateVector4("grl_dashOptions",p);const T=A.TmpVectors.Vector4[1];T.x=this.colorMode,T.y=this.visibility,T.z=this.colorsTexture?this.colorsTexture.getSize().width:0,T.w=JN.BooleanToNumber(this.useColors),N.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",T),this._color&&N.updateColor3("grl_singleColor",this._color);const a=this.colorsTexture??WN.EmptyColorsTexture;N.setTexture("grl_colors",a),N.updateFloat2("grl_textureSize",(null===a||void 0===a?void 0:a.getSize().width)??1,(null===a||void 0===a?void 0:a.getSize().height)??1)}prepareDefines(N,p,T){N.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,N.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,N.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,N.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=p.useRightHandedSystem,N.GREASED_LINE_CAMERA_FACING=this._cameraFacing,N.GREASED_LINE_USE_OFFSETS=!!T.offsets}getClassName(){return GN.GREASED_LINE_MATERIAL_NAME}getCustomCode(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(p)?function(N,p){if("vertex"===N){const N={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return p&&(N["!gl_Position\\=viewProjection\\*worldPos;"]="//"),N}return"fragment"===N?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(N,this._cameraFacing):function(N,p){if("vertex"===N){const N={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return p&&(N["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),N}return"fragment"===N?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(N,this._cameraFacing)}dispose(){var N;null===(N=this.colorsTexture)||void 0===N||N.dispose(),super.dispose()}get zN(){return this._colors}set zN(N){this.setColors(N)}setColors(N){var p;let T=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=(null===(p=this._colors)||void 0===p?void 0:p.length)??0;var C;if(this._colors=N,null!==N&&0!==N.length){if(!T||A)if(this.colorsTexture&&a===N.length&&!A){const p=JN.Color3toRGBAUint8(N);this.colorsTexture.update(p)}else{var U;null===(U=this.colorsTexture)||void 0===U||U.dispose(),this.colorsTexture=JN.CreateColorsTexture(`${this._material.name}-colors-texture`,N,this.colorsSampling,this._scene)}}else null===(C=this.colorsTexture)||void 0===C||C.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(N){this._dashCount=N,this._dashArray=1/N}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(N){this._sizeAttenuation=N,this.markAllDefinesAsDirty()}get color(){return this._color}set color(N){this.setColor(N)}setColor(N){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==N||null!==this._color&&null===N?(this._color=N,p||this.markAllDefinesAsDirty()):this._color=N}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(N){this._colorsDistributionType=N,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(N){this._aspect=N.x/N.y,this._resolution=N}serialize(){const N=super.serialize(),p={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(p.zN=this._colors),this._color&&(p.color=this._color),N.greasedLineMaterialOptions=p,N}parse(N,p,T){var A;super.parse(N,p,T);const a=N.greasedLineMaterialOptions;null===(A=this.colorsTexture)||void 0===A||A.dispose(),a.color&&this.setColor(a.color,!0),a.colorDistributionType&&(this.colorsDistributionType=a.colorDistributionType),a.zN&&(this.zN=a.zN),a.colorsSampling&&(this.colorsSampling=a.colorsSampling),a.colorMode&&(this.colorMode=a.colorMode),a.useColors&&(this.useColors=a.useColors),a.visibility&&(this.visibility=a.visibility),a.useDash&&(this.useDash=a.useDash),a.dashCount&&(this.dashCount=a.dashCount),a.dashRatio&&(this.dashRatio=a.dashRatio),a.dashOffset&&(this.dashOffset=a.dashOffset),a.width&&(this.width=a.width),a.sizeAttenuation&&(this.sizeAttenuation=a.sizeAttenuation),a.resolution&&(this.resolution=a.resolution),this.zN?this.colorsTexture=JN.CreateColorsTexture(`${this._material.name}-colors-texture`,this.zN,this.colorsSampling,p):JN.PrepareEmptyColorsTexture(p),this.markAllDefinesAsDirty()}copyTo(N){var p;const T=N;null===(p=T.colorsTexture)||void 0===p||p.dispose(),this._colors&&(T.colorsTexture=JN.CreateColorsTexture(`${T._material.name}-colors-texture`,this._colors,T.colorsSampling,this._scene)),T.setColor(this.color,!0),T.colorsDistributionType=this.colorsDistributionType,T.colorsSampling=this.colorsSampling,T.colorMode=this.colorMode,T.useColors=this.useColors,T.visibility=this.visibility,T.useDash=this.useDash,T.dashCount=this.dashCount,T.dashRatio=this.dashRatio,T.dashOffset=this.dashOffset,T.width=this.width,T.sizeAttenuation=this.sizeAttenuation,T.resolution=this.resolution,T.markAllDefinesAsDirty()}_isGLSL(N){return 0===N||this._forceGLSL}}GN.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",GN.ForceGLSL=!1,(0,vN.d)(`BABYLON.${GN.GREASED_LINE_MATERIAL_NAME}`,GN);var oN=T(12813),ZN=T(12211),mp=T(12615),qN=T(12309);class hN extends mp.ShaderMaterial{constructor(N,p,a){const C=p.getEngine(),U=C.isWebGPU&&!(a.forceGLSL||hN.ForceGLSL),X=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];p.useRightHandedSystem&&X.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const y=["position","grl_widths","grl_offsets","grl_colorPointers"];a.cameraFacing?(X.push("GREASED_LINE_CAMERA_FACING"),y.push("grl_previousAndSide","grl_nextAndCounters")):(y.push("grl_slopes"),y.push("grl_counters"));const e=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(U||e.push("world","viewProjection","view","projection"),super(N,p,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:U?["Scene","Mesh"]:void 0,attributes:y,uniforms:e,samplers:U?[]:["grlColors"],defines:X,extraInitializationsAsync:async()=>{U?await Promise.all([T.e(66).then(T.bind(T,15448)),T.e(75).then(T.bind(T,15454))]):await Promise.all([T.e(69).then(T.bind(T,15463)),T.e(76).then(T.bind(T,15468))])},shaderLanguage:U?1:0}),this._color=I.wp.White(),this._colorsDistributionType=0,this._colorsTexture=null,a=a||{color:WN.DEFAULT_COLOR},this.visibility=a.visibility??1,this.useDash=a.useDash??!1,this.dashRatio=a.dashRatio??.5,this.dashOffset=a.dashOffset??0,this.dashCount=a.dashCount??1,this.width=a.width?a.width:a.sizeAttenuation&&a.cameraFacing?WN.DEFAULT_WIDTH_ATTENUATED:WN.DEFAULT_WIDTH,this.sizeAttenuation=a.sizeAttenuation??!1,this.color=a.color??I.wp.White(),this.useColors=a.useColors??!1,this.colorsDistributionType=a.colorDistributionType??0,this.colorsSampling=a.colorsSampling??i.d.NEAREST_NEAREST,this.colorMode=a.colorMode??0,this._colors=a.zN??null,this._cameraFacing=a.cameraFacing??!0,this.resolution=a.resolution??new A.Vector2(C.getRenderWidth(),C.getRenderHeight()),a.colorsTexture?this.colorsTexture=a.colorsTexture:this._colors?this.colorsTexture=JN.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,p):(this._color=this._color??WN.DEFAULT_COLOR,this.colorsTexture=JN.PrepareEmptyColorsTexture(p)),U){const N=new qN.c;N.setParameters(),N.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",N)}C.SU.add((()=>{JN.DisposeEmptyColorsTexture()}))}dispose(){var N;null===(N=this._colorsTexture)||void 0===N||N.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new A.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get zN(){return this._colors}set zN(N){this.setColors(N)}setColors(N){var p;let T=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=(null===(p=this._colors)||void 0===p?void 0:p.length)??0;var C;if(this._colors=N,null!==N&&0!==N.length){if(!T||A)if(this._colorsTexture&&a===N.length&&!A){const p=JN.Color3toRGBAUint8(N);this._colorsTexture.update(p)}else{var U;null===(U=this._colorsTexture)||void 0===U||U.dispose(),this.colorsTexture=JN.CreateColorsTexture(`${this.name}-colors-texture`,N,this.colorsSampling,this.KN())}}else null===(C=this._colorsTexture)||void 0===C||C.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(N){this._colorsTexture=N,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(N){this._width=N,this.setFloat("grlWidth",N)}get useColors(){return this._useColors}set useColors(N){this._useColors=N,this.setFloat("grlUseColors",JN.BooleanToNumber(N))}get colorsSampling(){return this._colorsSampling}set colorsSampling(N){this._colorsSampling=N}get visibility(){return this._visibility}set visibility(N){this._visibility=N,this.setFloat("grlVisibility",N)}get useDash(){return this._useDash}set useDash(N){this._useDash=N,this.setFloat("grlUseDash",JN.BooleanToNumber(N))}get dashOffset(){return this._dashOffset}set dashOffset(N){this._dashOffset=N,this.setFloat("grlDashOffset",N)}get dashRatio(){return this._dashRatio}set dashRatio(N){this._dashRatio=N,this.setFloat("grlDashRatio",N)}get dashCount(){return this._dashCount}set dashCount(N){this._dashCount=N,this._dashArray=1/N,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(N){this._sizeAttenuation=N,this.setFloat("grlSizeAttenuation",JN.BooleanToNumber(N))}get color(){return this._color}set color(N){this.setColor(N)}setColor(N){N=N??WN.DEFAULT_COLOR,this._color=N,this.setColor3("grlColor",N)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(N){this._colorsDistributionType=N,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(N){this._colorMode=N,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(N){this._resolution=N,this.setVector2("grlResolution",N),this.setFloat("grlAspect",N.x/N.y)}serialize(){const N=super.serialize(),p={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(p.zN=this._colors),N.greasedLineMaterialOptions=p,N}parse(N,p,T){var A;const a=N.greasedLineMaterialOptions;null===(A=this._colorsTexture)||void 0===A||A.dispose(),a.color&&(this.color=a.color),a.colorDistributionType&&(this.colorsDistributionType=a.colorDistributionType),a.colorsSampling&&(this.colorsSampling=a.colorsSampling),a.colorMode&&(this.colorMode=a.colorMode),a.useColors&&(this.useColors=a.useColors),a.visibility&&(this.visibility=a.visibility),a.useDash&&(this.useDash=a.useDash),a.dashCount&&(this.dashCount=a.dashCount),a.dashRatio&&(this.dashRatio=a.dashRatio),a.dashOffset&&(this.dashOffset=a.dashOffset),a.width&&(this.width=a.width),a.sizeAttenuation&&(this.sizeAttenuation=a.sizeAttenuation),a.resolution&&(this.resolution=a.resolution),a.zN?this.colorsTexture=JN.CreateColorsTexture(`${this.name}-colors-texture`,a.zN,this.colorsSampling,this.KN()):this.colorsTexture=JN.PrepareEmptyColorsTexture(p),this._cameraFacing=a.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var jN,VN,rN;hN.ForceGLSL=!1,function(N){N[N.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",N[N.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(jN||(jN={})),function(N){N[N.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",N[N.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",N[N.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(VN||(VN={})),function(N){N[N.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",N[N.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",N[N.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",N[N.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",N[N.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(rN||(rN={}));class uN extends nN.d{constructor(N,p,T){super(N,p,null,null,!1,!1),this.name=N,this._options=T,this._lazy=!1,this._updatable=!1,this._engine=p.getEngine(),this._lazy=T.lazy??!1,this._updatable=T.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=T.colorPointers??[],this._widths=T.widths??new Array(T.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(N){let p=0;for(const A of this._points)p+=A.length;const T=p/3*2-this._widths.length;for(let A=0;A<T;A++)this._widths.push(N)}updateLazy(){var N,p;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(N=this._options.ribbonOptions)||void 0===N?void 0:N.smoothShading),!this.GN&&this.refreshBoundingInfo(),null===(p=this.greasedLineMaterial)||void 0===p||p.updateLazy()}addPoints(N,p){for(const T of N)this._points.push(T);this._lazy||this.setPoints(this._points,p)}dispose(N){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(N,p)}isLazy(){return this._lazy}get RN(){return this._uvs}set RN(N){this._uvs=N instanceof Float32Array?N:new Float32Array(N),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(N){this.material instanceof hN&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===N||void 0===N?void 0:N.length)>0),this._offsets=N,this._offsetsBuffer?this._offsetsBuffer.update(N):this._createOffsetsBuffer(N)}get widths(){return this._widths}set widths(N){this._widths=N,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(N)}get colorPointers(){return this._colorPointers}set colorPointers(N){this._colorPointers=N,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(N)}get greasedLineMaterial(){var N,p;if(this.material&&this.material instanceof hN)return this.material;const T=null===(N=this.material)||void 0===N||null===(p=N.pluginManager)||void 0===p?void 0:p.getPlugin(GN.GREASED_LINE_MATERIAL_NAME);return T||void 0}get points(){const N=[];return ZN.d.DeepCopy(this._points,N),N}setPoints(N,p){this._points=JN.ConvertPoints(N,(null===p||void 0===p?void 0:p.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==p&&void 0!==p&&p.colorPointers||this._updateColorPointers(),this._setPoints(this._points,p)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,RN:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(N){super.serialize(N),N.type=this.getClassName(),N.lineOptions=this._createLineOptions()}_createVertexBuffers(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=new oN.c;return p.vN=this._vertexPositions,p.indices=this._indices,p.RN=this._uvs,N&&(p.WN=[],oN.c.ComputeNormals(this._vertexPositions,this._indices,p.WN)),p.fN(this,this._options.updatable),p}_createOffsetsBuffer(N){const p=this._scene.getEngine(),T=new H.e(p,N,this._updatable,3);this.setVerticesBuffer(T.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=T}}class YN{constructor(N,p){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=N,this.wasAddedByNoopNode=p}getIndicesAccessor(N,p,T,A,a){var C,U,X,y;return null===(C=this._indicesAccessorMap.get(N))||void 0===C||null===(U=C.get(p))||void 0===U||null===(X=U.get(T))||void 0===X||null===(y=X.get(A))||void 0===y?void 0:y.get(a)}setIndicesAccessor(N,p,T,A,a,C){let U=this._indicesAccessorMap.get(N);U||(U=new Map,this._indicesAccessorMap.set(N,U));let X=U.get(p);X||(X=new Map,U.set(p,X));let y=X.get(T);y||(y=new Map,X.set(T,y));let e=y.get(A);e||(e=new Map,y.set(A,e)),e.set(a,C)}pushExportedNode(N){this._exportedNodes.has(N)||this._exportedNodes.add(N)}getNodesSet(){return this._exportedNodes}getVertexBufferView(N){return this._vertexBufferViewMap.get(N)}setVertexBufferView(N,p){this._vertexBufferViewMap.set(N,p)}setRemappedBufferView(N,p,T){this._remappedBufferView.set(N,new Map),this._remappedBufferView.get(N).set(p,T)}getRemappedBufferView(N,p){var T;return null===(T=this._remappedBufferView.get(N))||void 0===T?void 0:T.get(p)}getVertexAccessor(N,p,T){var A,a;return null===(A=this._vertexAccessorMap.get(N))||void 0===A||null===(a=A.get(p))||void 0===a?void 0:a.get(T)}setVertexAccessor(N,p,T,A){let a=this._vertexAccessorMap.get(N);a||(a=new Map,this._vertexAccessorMap.set(N,a));let C=a.get(p);C||(C=new Map,a.set(p,C)),C.set(T,A)}hasVertexColorAlpha(N){return this._vertexMapColorAlpha.get(N)||!1}setHasVertexColorAlpha(N,p){return this._vertexMapColorAlpha.set(N,p)}getMesh(N){return this._meshMap.get(N)}setMesh(N,p){this._meshMap.set(N,p)}bindMorphDataToMesh(N,p){const T=this._meshMorphTargetMap.get(N)||[];this._meshMorphTargetMap.set(N,T),-1===T.indexOf(p)&&T.push(p)}getMorphTargetsFromMesh(N){return this._meshMorphTargetMap.get(N)}}class DN{_ApplyExtension(N,p,T,A){if(T>=p.length)return Promise.resolve(N);const a=A(p[T],N);return a?a.then((async N=>N?await this._ApplyExtension(N,p,T+1,A):null)):this._ApplyExtension(N,p,T+1,A)}_ApplyExtensions(N,p){const T=[];for(const A of DN._ExtensionNames)T.push(this._extensions[A]);return this._ApplyExtension(N,T,0,p)}_extensionsPreExportTextureAsync(N,p,T){return this._ApplyExtensions(p,((p,A)=>p.preExportTextureAsync&&p.preExportTextureAsync(N,A,T)))}_extensionsPostExportNodeAsync(N,p,T,A,a){return this._ApplyExtensions(p,((p,C)=>p.postExportNodeAsync&&p.postExportNodeAsync(N,C,T,A,a,this._bufferManager)))}_extensionsPostExportMaterialAsync(N,p,T){return this._ApplyExtensions(p,((p,A)=>p.postExportMaterialAsync&&p.postExportMaterialAsync(N,A,T)))}_extensionsPostExportMaterialAdditionalTextures(N,p,T){const A=[];for(const a of DN._ExtensionNames){const C=this._extensions[a];C.postExportMaterialAdditionalTextures&&A.push(...C.postExportMaterialAdditionalTextures(N,p,T))}return A}_extensionsPostExportTextures(N,p,T){for(const A of DN._ExtensionNames){const a=this._extensions[A];a.postExportTexture&&a.postExportTexture(N,p,T)}}_extensionsPostExportMeshPrimitive(N){for(const p of DN._ExtensionNames){const T=this._extensions[p];T.postExportMeshPrimitive&&T.postExportMeshPrimitive(N,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const N of DN._ExtensionNames){const p=this._extensions[N];p.preGenerateBinaryAsync&&await p.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(N){for(const p of DN._ExtensionNames){const T=this._extensions[p];T.enabled&&N(T)}}_extensionsOnExporting(){this._forEachExtensions((N=>{var p,T,A;N.wasUsed&&((p=this._glTF).extensionsUsed||(p.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(N.name)&&this._glTF.extensionsUsed.push(N.name),N.required&&((T=this._glTF).extensionsRequired||(T.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(N.name)&&this._glTF.extensionsRequired.push(N.name)),(A=this._glTF).extensions||(A.extensions={}),N.onExporting&&N.onExporting())}))}_loadExtensions(){for(const N of DN._ExtensionNames){const p=DN._ExtensionFactories[N](this);this._extensions[N]=p}}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:x.b.LastCreatedScene,p=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${k.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new q(this),this._extensions={},this._bufferManager=new HN,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!N)throw new Error("No scene available to export");this._babylonScene=N,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:N=>{var p;return null===N||void 0===N||null===(p=N.TX)||void 0===p?void 0:p.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...p},this._loadExtensions()}dispose(){for(const N in this._extensions){this._extensions[N].dispose()}}get options(){return this._options}static RegisterExtension(N,p){DN.UnregisterExtension(N)&&a.Tools.Warn(`Extension with the name ${N} already exists`),DN._ExtensionFactories[N]=p,DN._ExtensionNames.push(N)}static UnregisterExtension(N){if(!DN._ExtensionFactories[N])return!1;delete DN._ExtensionFactories[N];const p=DN._ExtensionNames.indexOf(N);return-1!==p&&DN._ExtensionNames.splice(p,1),!0}_generateJSON(N,p,T){const A={byteLength:N};return A.byteLength&&(this._glTF.buffers=[A]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Lp=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(A.uri=p+".bin"),T?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(N){const p=await this._generateBinaryAsync();this._extensionsOnExporting();const T=this._generateJSON(p.byteLength,N,!0),A=new Blob([p],{type:"application/octet-stream"}),a=N+".gltf",C=N+".bin",U=new e;if(U.files[a]=T,U.files[C]=A,this._imageData)for(const X in this._imageData)U.files[X]=new Blob([this._imageData[X].data],{type:this._imageData[X].mimeType});return U}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(N){const p=N%4;return 0===p?p:4-p}async generateGLBAsync(N){this._shouldUseGlb=!0;const p=await this._generateBinaryAsync();this._extensionsOnExporting();const T=this._generateJSON(p.byteLength),A=N+".glb";let a,C=T.length;if("undefined"!==typeof TextEncoder){a=(new TextEncoder).encode(T),C=a.length}const U=this._getPadding(C),X=this._getPadding(p.byteLength),y=28+C+U+p.byteLength+X,H=new yN(y);if(H.writeUInt32(1179937895),H.writeUInt32(2),H.writeUInt32(y),H.writeUInt32(C+U),H.writeUInt32(1313821514),a)H.writeTypedArray(a);else{const N="_".charCodeAt(0);for(let p=0;p<C;++p){const A=T.charCodeAt(p);A!=T.codePointAt(p)?H.writeUInt8(N):H.writeUInt8(A)}}for(let e=0;e<U;++e)H.writeUInt8(32);H.writeUInt32(p.byteLength+X),H.writeUInt32(5130562),H.writeTypedArray(p);for(let e=0;e<X;++e)H.writeUInt8(0);const M=new e;return M.files[A]=new Blob([H.getOutputData()],{type:"application/octet-stream"}),M}_setNodeTransformation(N,p,T){if(p.getPivotPoint().equalsWithEpsilon(u,r.b)||a.Tools.Warn("Pivot points are not supported in the glTF serializer"),!p.position.equalsWithEpsilon(u,r.b)){const a=A.TmpVectors.xp[0].A(p.position);T&&t(a),N.translation=a.UX()}p.xX.equalsWithEpsilon(D,r.b)||(N.scale=p.xX.UX());const C=p.rotationQuaternion||A.Quaternion.FromEulerAngles(p.rotation.x,p.rotation.y,p.rotation.z);C.equalsWithEpsilon(Y,r.b)||(T&&S(C),N.rotation=C.normalize().UX())}_setCameraTransformation(N,p,T){if(!p.position.equalsWithEpsilon(u,r.b)){const a=A.TmpVectors.xp[0].A(p.position);T&&t(a),N.translation=a.UX()}const a=p.rotationQuaternion||A.Quaternion.FromEulerAngles(p.rotation.x,p.rotation.y,p.rotation.z);T&&S(a),this._babylonScene.useRightHandedSystem||s(a),a.equalsWithEpsilon(Y,r.b)||(N.rotation=a.UX())}_listAvailableCameras(){for(const N of this._babylonScene.cameras){const p={type:N.mode===bN.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(N.name&&(p.name=N.name),"perspective"===p.type)p.perspective={aspectRatio:N.getEngine().getAspectRatio(N),yfov:N.fovMode===bN.d.FOVMODE_VERTICAL_FIXED?N.fov:N.fov*N.getEngine().getAspectRatio(N),znear:N.yX,zfar:N.maxZ};else if("orthographic"===p.type){const T=N.orthoLeft&&N.orthoRight?.5*(N.orthoRight-N.orthoLeft):.5*N.getEngine().getRenderWidth(),A=N.orthoBottom&&N.orthoTop?.5*(N.orthoTop-N.orthoBottom):.5*N.getEngine().getRenderHeight();p.orthographic={xmag:T,ymag:A,znear:N.yX,zfar:N.maxZ}}this._camerasMap.set(N,p)}}_exportAndAssignCameras(){const N=Array.from(this._camerasMap.values());for(const p of N){const N=this._nodesCameraMap.get(p);if(void 0!==N){this._cameras.push(p);for(const p of N)p.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const N of this._babylonScene.skeletons){if(N.bones.length<=0)continue;const p={joints:[]};this._skinMap.set(N,p)}}_exportAndAssignSkeletons(){for(const N of this._babylonScene.skeletons){if(N.bones.length<=0)continue;const p=this._skinMap.get(N);if(void 0==p)continue;const T={},A=[];let C=-1;for(let a=0;a<N.bones.length;++a){const p=N.bones[a],A=p.getIndex()??a;-1!==A&&(T[A]=p,A>C&&(C=A))}for(let N=0;N<=C;++N){const C=T[N];A.push(C.getAbsoluteInverseBindMatrix());const U=C.getTransformNode();if(null!==U){const N=this._nodeMap.get(U);U&&null!==N&&void 0!==N?p.joints.push(N):a.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else a.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const U=this._nodesSkinMap.get(p);if(p.joints.length>0&&void 0!==U){const N=64*A.length,T=new Float32Array(N/4);A.forEach(((N,p)=>{T.set(N.m,16*p)}));const a=this._bufferManager.createBufferView(T);this._accessors.push(this._bufferManager.createAccessor(a,"MAT4",5126,A.length)),p.inverseBindMatrices=this._accessors.length-1,this._skins.push(p);for(const p of U)p.skin=this._skins.length-1}}}async _exportSceneAsync(){const N={nodes:[]};if(this._babylonScene.metadata){const p=this._options.metadataSelector(this._babylonScene.metadata);p&&(N.extras=p)}const p=new Array,T=new Array,A=new Array;for(const X of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&UN(X,this._babylonScene.useRightHandedSystem)?A.push(...X.getChildren()):this._babylonScene.useRightHandedSystem?p.push(X):T.push(X);this._listAvailableCameras(),this._listAvailableSkeletons();const a=new YN(!0,!1);N.nodes.push(...await this._exportNodesAsync(T,a));const C=new YN(!1,!1);N.nodes.push(...await this._exportNodesAsync(p,C));const U=new YN(!1,!0);N.nodes.push(...await this._exportNodesAsync(A,U)),N.nodes.length&&this._scenes.push(N),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&gN._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,a.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(N){let p=this._shouldExportNodeMap.get(N);return void 0===p&&(p=this._options.shouldExportNode(N),this._shouldExportNodeMap.set(N,p)),p}async _exportNodesAsync(N,p){const T=new Array;this._exportBuffers(N,p);for(const A of N)await this._exportNodeAsync(A,T,p);return T}_collectBuffers(N,p,T,A,a){if(this._shouldExportNode(N)&&N instanceof b.c&&N.MX){const C=N.MX.getVertexBuffers();if(C)for(const A in C){if(!O(A))continue;const U=C[A];a.setHasVertexColorAlpha(U,N.hasVertexAlpha);const X=U._buffer,y=p.get(X)||[];p.set(X,y),-1===y.indexOf(U)&&y.push(U);const e=T.get(U)||[];T.set(U,e),-1===e.indexOf(N)&&e.push(N)}const U=N.morphTargetManager;if(U)for(let p=0;p<U.numTargets;p++){const T=U.getTarget(p),a=A.get(T)||[];A.set(T,a),-1===a.indexOf(N)&&a.push(N)}}for(const C of N.getChildren())this._collectBuffers(C,p,T,A,a)}_exportBuffers(N,p){const T=new Map,A=new Map,a=new Map;for(const X of N)this._collectBuffers(X,T,A,a,p);const C=Array.from(T.keys());for(const X of C){const N=X.getData();if(!N)throw new Error("Buffer data is not available");const a=T.get(X);if(!a)continue;const C=a[0].byteStride;if(a.some((N=>N.byteStride!==C)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const U=TN(N).slice();for(const p of a){const N=A.get(p),{byteOffset:T,byteStride:a,componentCount:C,type:X,count:y,normalized:e,kind:M}=Q(p,N);switch(M){case H.f.NormalKind:case H.f.TangentKind:(0,h.e)(U,T,a,C,X,y,e,(N=>{const p=Math.sqrt(N[0]*N[0]+N[1]*N[1]+N[2]*N[2]);if(p>0){const T=1/p;N[0]*=T,N[1]*=T,N[2]*=T}}));break;case H.f.ColorKind:{const p=N.filter((N=>N.material instanceof xN.np||null==N.material)).length;if(0==p)break;if(p!=N.length){j.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}X==H.f.UNSIGNED_BYTE&&j.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const A=new I.wp,M=new I.LX,b=this._babylonScene.getEngine().useExactSrgbConversions;(0,h.e)(U,T,a,C,X,y,e,(N=>{3===N.length?(A.IT(N,0),A.toLinearSpaceToRef(A,b),A.toArray(N,0)):(M.IT(N,0),M.toLinearSpaceToRef(M,b),M.toArray(N,0))}))}}}if(p.convertToRightHanded){for(const N of a){const p=A.get(N),{byteOffset:T,byteStride:a,componentCount:C,type:X,count:y,normalized:e,kind:M}=Q(N,p);switch(M){case H.f.PositionKind:case H.f.NormalKind:case H.f.TangentKind:(0,h.e)(U,T,a,C,X,y,e,(N=>{N[0]=-N[0]}))}}p.convertedToRightHandedBuffers.set(X,U)}const y=this._bufferManager.createBufferView(U,C);p.setVertexBufferView(X,y);const e=new Map;for(const p of a){const N=A.get(p),{kind:T,totalVertices:a}=Q(p,N);switch(T){case H.f.MatricesIndicesKind:case H.f.MatricesIndicesExtraKind:if(p.type==H.f.FLOAT){const N=p.getFloatData(a);null!==N&&e.set(p,N)}}}0!==e.size&&j.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const M=Array.from(e.keys());for(const T of M){const N=e.get(T);if(!N)continue;const A=N.some((N=>N>=256)),a=new(A?Uint16Array:Uint8Array)(N.length);for(let p=0;p<N.length;p++)a[p]=N[p];const C=this._bufferManager.createBufferView(a,4*(A?2:1));p.setRemappedBufferView(X,T,C)}}const U=Array.from(a.keys());for(const X of U){const N=a.get(X);if(!N)continue;const T=PN(X,N[0],this._bufferManager,this._bufferViews,this._accessors,p.convertToRightHanded);for(const A of N)p.bindMorphDataToMesh(A,T)}}async _exportNodeAsync(N,p,T){let A=this._nodeMap.get(N);if(void 0!==A)return void(p.includes(A)||p.push(A));const a=await this._createNodeAsync(N,T);if(a){A=this._nodes.length,this._nodes.push(a),this._nodeMap.set(N,A),T.pushExportedNode(N),p.push(A);const C={name:"runtime animations",channels:[],samplers:[]},U=[];this._babylonScene.animationGroups.length||(gN._CreateMorphTargetAnimationFromMorphTargetAnimations(N,C,U,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,T.convertToRightHanded,this._options.shouldExportAnimation),N.animations.length&&gN._CreateNodeAnimationFromNodeAnimations(N,C,U,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,T.convertToRightHanded,this._options.shouldExportAnimation)),C.channels.length&&C.samplers.length&&this._animations.push(C),U.forEach((N=>{N.channels.length&&N.samplers.length&&this._animations.push(N)}))}const C=a?[]:p;for(const U of N.getChildren())await this._exportNodeAsync(U,C,T);a&&C.length&&(a.children=C)}async _createNodeAsync(N,p){if(!this._shouldExportNode(N))return null;const T={};if(N.name&&(T.name=N.name),N.metadata){const p=this._options.metadataSelector(N.metadata);p&&(T.extras=p)}if(N instanceof M.b&&(this._setNodeTransformation(T,N,p.convertToRightHanded),N instanceof b.c)){const a=N instanceof l.d?N.sourceMesh:N;if(a.CX&&a.CX.length>0&&(T.mesh=await this._exportMeshAsync(a,p)),N.skeleton){const p=this._skinMap.get(N.skeleton);var A;if(void 0!==p)void 0===this._nodesSkinMap.get(p)&&this._nodesSkinMap.set(p,[]),null===(A=this._nodesSkinMap.get(p))||void 0===A||A.push(T)}}if(N instanceof V.c){const A=this._camerasMap.get(N);if(A){var a;void 0===this._nodesCameraMap.get(A)&&this._nodesCameraMap.set(A,[]),this._setCameraTransformation(T,N,p.convertToRightHanded);const U=N.parent;if(null!==U&&pN(N,U)){const N=this._nodeMap.get(U);if(void 0!==N){var C;const p=this._nodes[N];return NN(T,p),null===(C=this._nodesCameraMap.get(A))||void 0===C||C.push(p),null}}null===(a=this._nodesCameraMap.get(A))||void 0===a||a.push(T)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",T,N,this._nodeMap,p.convertToRightHanded)?T:(j.d.Warn(`Not exporting node ${N.name}`),null)}_exportIndices(N,p,T,A,a,U,X,y,e){let H=N;e.mode=B(U);const M=X!==C.c.CounterClockWiseSideOrientation,b=!y.wasAddedByNoopNode&&M,l=function(N){switch(N){case C.c.TriangleFillMode:case C.c.TriangleStripDrawMode:case C.c.TriangleFanDrawMode:return!0}return!1}(U)&&b;if(l){if(U===C.c.TriangleStripDrawMode||U===C.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");e.mode=B(U);const X=p?new Uint32Array(A):new Uint16Array(A);if(N)for(let p=0;p+2<A;p+=3)X[p]=N[T+p]+a,X[p+1]=N[T+p+2]+a,X[p+2]=N[T+p+1]+a;else for(let N=0;N+2<A;N+=3)X[N]=N,X[N+1]=N+2,X[N+2]=N+1;H=X}else if(N&&0!==a){const C=p?new Uint32Array(A):new Uint16Array(A);for(let p=0;p<A;p++)C[p]=N[T+p]+a;H=C}if(H){let C=y.getIndicesAccessor(N,T,A,a,l);if(void 0===C){const U=function(N,p,T,A){if(N instanceof Uint16Array||N instanceof Uint32Array)return N;if(N instanceof Int32Array)return new Uint32Array(N.buffer,N.byteOffset,N.length);const a=N.slice(p,p+T);return A?new Uint32Array(a):new Uint16Array(a)}(H,0,A,p),X=this._bufferManager.createBufferView(U),e=p?5125:5123;this._accessors.push(this._bufferManager.createAccessor(X,"SCALAR",e,A,0)),C=this._accessors.length-1,y.setIndicesAccessor(N,T,A,a,l,C)}e.indices=C}}_exportVertexBuffer(N,p,T,A,a,C){const U=N.getKind();if(!O(U))return;if(U.startsWith("uv")&&!this._options.exportUnusedUVs&&(!p||!this._materialNeedsUVsSet.has(p)))return;let X=a.getVertexAccessor(N,T,A);if(void 0===X){const p=a.convertedToRightHandedBuffers.get(N._buffer)||N._buffer.getData(),C=U===H.f.PositionKind?function(N,p,T,A){const{byteOffset:a,byteStride:C,type:U,normalized:X}=p,y=p.getSize(),e=new Array(y).fill(1/0),H=new Array(y).fill(-1/0);return(0,h.e)(N,a+T*C,C,y,U,A*y,X,(N=>{for(let p=0;p<y;p++)e[p]=Math.min(e[p],N[p]),H[p]=Math.max(H[p],N[p])})),{min:e,max:H}}(p,N,T,A):void 0,y=(U===H.f.MatricesIndicesKind||U===H.f.MatricesIndicesExtraKind)&&N.type===H.f.FLOAT,e=y?H.f.UNSIGNED_BYTE:N.type,M=y?void 0:N.normalized,b=y?a.getRemappedBufferView(N._buffer,N):a.getVertexBufferView(N._buffer),l=N.byteOffset+T*N.byteStride;this._accessors.push(this._bufferManager.createAccessor(b,function(N,p){if(N==H.f.ColorKind)return p?"VEC4":"VEC3";switch(N){case H.f.PositionKind:case H.f.NormalKind:return"VEC3";case H.f.TangentKind:case H.f.MatricesIndicesKind:case H.f.MatricesIndicesExtraKind:case H.f.MatricesWeightsKind:case H.f.MatricesWeightsExtraKind:return"VEC4";case H.f.UVKind:case H.f.UV2Kind:case H.f.UV3Kind:case H.f.UV4Kind:case H.f.UV5Kind:case H.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${N}`)}(U,a.hasVertexColorAlpha(N)),e,A,l,C,M)),X=this._accessors.length-1,a.setVertexAccessor(N,T,A,X)}C.attributes[function(N){switch(N){case H.f.PositionKind:return"POSITION";case H.f.NormalKind:return"NORMAL";case H.f.TangentKind:return"TANGENT";case H.f.ColorKind:return"COLOR_0";case H.f.UVKind:return"TEXCOORD_0";case H.f.UV2Kind:return"TEXCOORD_1";case H.f.UV3Kind:return"TEXCOORD_2";case H.f.UV4Kind:return"TEXCOORD_3";case H.f.UV5Kind:return"TEXCOORD_4";case H.f.UV6Kind:return"TEXCOORD_5";case H.f.MatricesIndicesKind:return"JOINTS_0";case H.f.MatricesIndicesExtraKind:return"JOINTS_1";case H.f.MatricesWeightsKind:return"WEIGHTS_0";case H.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${N}`)}(U)]=X}async _exportMaterialAsync(N,p,T,A){let a=this._materialMap.get(N);if(void 0===a){const A=p&&Object.keys(p).some((N=>N.startsWith("uv")));if((N=N instanceof lN.d?N.nX[T.materialIndex]:N)instanceof kN.b)a=await this._materialExporter.exportPBRMaterialAsync(N,"image/png",A);else{if(!(N instanceof xN.np))return void j.d.Warn(`Unsupported material '${N.name}' with type ${N.getClassName()}`);a=await this._materialExporter.exportStandardMaterialAsync(N,"image/png",A)}this._materialMap.set(N,a)}A.material=a}async _exportMeshAsync(N,p){var T;let A=p.getMesh(N);if(void 0!==A)return A;const a={primitives:[]};A=this._meshes.length,this._meshes.push(a),p.setMesh(N,A);const U=N.isUnIndexed?null:N.bX(),X=null===(T=N.MX)||void 0===T?void 0:T.getVertexBuffers(),y=p.getMorphTargetsFromMesh(N),e=N instanceof iN.b,H=N instanceof uN,M=N.CX;if(X&&M&&M.length>0)for(const k of M){const T={attributes:{}},A=k.qN()||this._babylonScene.defaultMaterial;if(H){var b,l;const p={name:A.name},a=N,C=I.wp.White(),U=(null===(b=a.material)||void 0===b?void 0:b.alpha)??1,X=(null===(l=a.greasedLineMaterial)||void 0===l?void 0:l.color)??C;(!X.equalsWithEpsilon(C,r.b)||U<1)&&(p.pbrMetallicRoughness={baseColorFactor:[...X.UX(),U]}),this._materials.push(p),T.material=this._materials.length-1}else if(e){const p={name:A.name},a=N;(!a.color.equalsWithEpsilon(I.wp.White(),r.b)||a.alpha<1)&&(p.pbrMetallicRoughness={baseColorFactor:[...a.color.UX(),a.alpha]}),this._materials.push(p),T.material=this._materials.length-1}else await this._exportMaterialAsync(A,X,k,T);const M=e||H?C.c.LineListDrawMode:N.overrideRenderingFillMode??A.fillMode,x=A._getEffectiveOrientation(N);this._exportIndices(U,U?(0,h.b)(U,k.indexCount,k.indexStart,k.verticesStart):k.verticesCount>65535,U?k.indexStart:k.verticesStart,U?k.indexCount:k.verticesCount,-k.verticesStart,M,x,p,T);for(const N of Object.values(X))this._exportVertexBuffer(N,A,k.verticesStart,k.verticesCount,p,T);if(y){T.targets=[];for(const N of y)T.targets.push(N.attributes)}a.primitives.push(T),this._extensionsPostExportMeshPrimitive(T)}if(y){a.weights=[],a.extras||(a.extras={}),a.extras.targetNames=[];for(const N of y)a.weights.push(N.influence),a.extras.targetNames.push(N.name)}return A}}DN._ExtensionNames=new Array,DN._ExtensionFactories={};class cN{static async GLTFAsync(N,p,T){T&&T.exportWithoutWaitingForScene||await N.whenReadyAsync();const A=new DN(N,T),a=await A.generateGLTFAsync(p.replace(/\.[^/.]+$/,""));return A.dispose(),a}static async GLBAsync(N,p,T){T&&T.exportWithoutWaitingForScene||await N.whenReadyAsync();const A=new DN(N,T),a=await A.generateGLBAsync(p.replace(/\.[^/.]+$/,""));return A.dispose(),a}}T(12943);const QN="EXT_mesh_gpu_instancing";class EN{constructor(N){this.name=QN,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(N,p,T,a,C,U){return await new Promise((N=>{if(p&&T instanceof nN.d&&T.hasThinInstances&&this._exporter){this._wasUsed=!0;const N=A.xp.Zero(),a=A.Quaternion.Identity(),X=A.xp.One(),y=T.thinInstanceGetWorldMatrices(),e=A.TmpVectors.xp[2],H=A.TmpVectors.Quaternion[1],M=A.TmpVectors.xp[3];let b=!1,l=!1,k=!1;const x=new Float32Array(3*T.wX),I=new Float32Array(4*T.wX),L=new Float32Array(3*T.wX);let n=0;for(const p of y)p.decompose(M,H,e),C&&(t(e),S(H)),x.set(e.UX(),3*n),I.set(H.normalize().UX(),4*n),L.set(M.UX(),3*n),b=b||!e.equalsWithEpsilon(N),l=l||!H.equalsWithEpsilon(a),k=k||!M.equalsWithEpsilon(X),n++;const w={attributes:{}};b&&(w.attributes.TRANSLATION=this._buildAccessor(x,"VEC3",T.wX,U)),l&&(w.attributes.ROTATION=this._buildAccessor(I,"VEC4",T.wX,U)),k&&(w.attributes.SCALE=this._buildAccessor(L,"VEC3",T.wX,U)),p.extensions=p.extensions||{},p.extensions[QN]=w}N(p)}))}_buildAccessor(N,p,T,A){const a=A.createBufferView(N),C=A.createAccessor(a,p,5126,T);return this._exporter._accessors.push(C),this._exporter._accessors.length-1}}DN.RegisterExtension(QN,(N=>new EN(N)));var ON=T(12950),BN=T(12960),dN=T(12963),tN=T(12972);function SN(N){return N===dN.b.PositionKind?"POSITION":N===dN.b.NormalKind?"NORMAL":N===dN.b.ColorKind?"COLOR":N.startsWith(dN.b.UVKind)?"TEX_COORD":"GENERIC"}const sN={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Np extends ON.c{static get DefaultAvailable(){return(0,ON.j)(Np.DefaultConfiguration)}static get Default(){return Np._Default??(Np._Default=new Np),Np._Default}static ResetDefault(N){Np._Default&&(N||Np._Default.dispose(),Np._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(N,p){return{module:await(p||DracoEncoderModule)({wasmBinary:N})}}_getWorkerContent(){return`${BN.j}(${BN.m})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Np.DefaultConfiguration)}async _encodeAsync(N,p,T){const A=T?(0,tN.e)(sN,T):sN;if(this._workerPoolPromise){const T=await this._workerPoolPromise;return await new Promise(((a,C)=>{T.push(((T,U)=>{const X=N=>{T.removeEventListener("error",X),T.removeEventListener("message",y),C(N),U()},y=N=>{"encodeMeshDone"===N.data.id&&(T.removeEventListener("error",X),T.removeEventListener("message",y),a(N.data.encodedMeshData),U())};T.addEventListener("error",X),T.addEventListener("message",y);const e=[];for(const p of N)e.push(p.data.buffer);p&&e.push(p.buffer),T.postMessage({id:"encodeMesh",attributes:N,indices:p,options:A},e)}))}))}if(this._modulePromise){const T=await this._modulePromise;return(0,BN.j)(T.module,N,p,A)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(N,p){if(0==N.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");N instanceof nN.d&&N.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===p||void 0===p?void 0:p.method)&&(j.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),p.method="MESH_SEQUENTIAL_ENCODING");const T=function(N){let p=N.bX(void 0,!0);return!p||p instanceof Uint32Array||p instanceof Uint16Array||(p=((0,h.b)(p,p.length)?Uint32Array:Uint16Array).from(p)),p}(N),A=function(N,p){const T=[];for(const A of N.getVerticesDataKinds()){if(null!==p&&void 0!==p&&p.includes(A)){if(A===dN.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const a=N.getVertexBuffer(A),C=a.getSize(),U=(0,h.m)(a.getData(),C,a.type,a.byteOffset,a.byteStride,a.normalized,N.getTotalVertices(),!0);T.push({kind:A,dracoName:SN(A),size:C,data:U})}return T}(N,null===p||void 0===p?void 0:p.excludedAttributes);return await this._encodeAsync(A,T,p)}}Np.DefaultConfiguration={wasmUrl:`${a.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${a.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${a.Tools._DefaultCdnUrl}/draco_encoder.js`},Np._Default=null;const pp="KHR_draco_mesh_compression";class Tp{get wasUsed(){return this._wasUsed}constructor(N){this.name=pp,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===N.options.meshCompressionMethod&&Np.DefaultAvailable}dispose(){}postExportMeshPrimitive(N,p,T){if(!this.enabled)return;if(4!==N.mode&&5!==N.mode)return void j.d.Warn("Cannot compress primitive with mode "+N.mode+".");const A=[],a=[];let C=null;if(void 0!==N.indices){const U=T[N.indices],X=p.getBufferView(U);C=p.getData(X).slice(),A.push(X),a.push(U)}const U=[];for(const[H,M]of Object.entries(N.attributes)){const N=T[M],C=p.getBufferView(N),y=E(N.type),e=(0,h.m)(p.getData(C),y,N.componentType,N.byteOffset||0,C.byteStride||(0,h.j)(N.componentType)*y,N.normalized||!1,N.count,!0);U.push({kind:H,dracoName:(X=H,"POSITION"===X?"POSITION":"NORMAL"===X?"NORMAL":X.startsWith("COLOR")?"COLOR":X.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:E(N.type),data:e}),A.push(C),a.push(N)}var X;const y={method:N.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},e=Np.Default._encodeAsync(U,C,y).then((T=>{if(!T)return void j.d.Error("Draco encoding failed for primitive.");const C={bufferView:-1,attributes:T.attributeIds},U=p.createBufferView(T.data);p.setBufferView(C,U);for(const N of A)this._bufferViewsUsed.add(N);for(const N of a)this._accessorsUsed.add(N);N.extensions||(N.extensions={}),N.extensions[pp]=C})).catch((N=>{j.d.Error("Draco encoding failed for primitive: "+N)}));this._encodePromises.push(e),this._wasUsed=!0}async preGenerateBinaryAsync(N){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((p=>{N.getPropertiesWithBufferView(p).every((N=>this._accessorsUsed.has(N)))&&N.removeBufferView(p)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}DN.RegisterExtension(pp,(N=>new Tp(N)));var Ap=T(12978);const ap="KHR_lights_punctual",Cp={name:"",color:[1,1,1],gX:1,range:Number.MAX_VALUE},Up={innerConeAngle:0,outerConeAngle:Math.PI/4},Xp=A.xp.Backward();class yp{constructor(N){this.name=ap,this.enabled=!0,this.required=!1,this._exporter=N}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[ap]=this._lights}async postExportNodeAsync(N,p,T,a,C){return await new Promise((U=>{if(!(T instanceof wN.c))return void U(p);const X=T.getTypeID()==wN.c.LIGHTTYPEID_POINTLIGHT?"point":T.getTypeID()==wN.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":T.getTypeID()==wN.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!X||!(T instanceof Ap.b))return j.d.Warn(`${N}: Light ${T.name} is not supported in ${ap}`),void U(p);if(T.falloffType!==wN.c.FALLOFF_GLTF&&j.d.Warn(`${N}: Light falloff for ${T.name} does not match the ${ap} specification!`),!T.position.equalsToFloats(0,0,0)){const N=A.TmpVectors.xp[0].A(T.position);C&&t(N),p.translation=N.UX()}if("point"!==X){const N=T.direction.normalizeToRef(A.TmpVectors.xp[0]);C&&t(N);const a=A.Quaternion.FromUnitVectorsToRef(Xp,N,A.TmpVectors.Quaternion[0]);A.Quaternion.IsIdentity(a)||(p.rotation=a.UX())}const y={type:X,name:T.name,color:T.PX.UX(),gX:T.gX,range:T.range};if(AN(y,Cp),"spot"===X){const N=T;y.spot={innerConeAngle:N.innerAngle/2,outerConeAngle:N.angle/2},AN(y.spot,Up)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(y);const e={XC:this._lights.lights.length-1},H=T.parent;if(H&&pN(T,H)){const N=a.get(H);if(N){const T=this._exporter._nodes[N];return NN(p,T),T.extensions||(T.extensions={}),T.extensions[ap]=e,void U(null)}}p.extensions||(p.extensions={}),p.extensions[ap]=e,U(p)}))}}DN.RegisterExtension(ap,(N=>new yp(N)));var ep=T(12893);const Hp="KHR_materials_anisotropy";class Mp{constructor(N){this.name=Hp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,p,T){const A=[];return T instanceof ep.d&&T.anisotropy.isEnabled&&!T.anisotropy.legacy?(T.anisotropy.texture&&A.push(T.anisotropy.texture),A):[]}postExportMaterialAsync(N,p,T){return new Promise((N=>{if(T instanceof ep.d){if(!T.anisotropy.isEnabled||T.anisotropy.legacy)return void N(p);this._wasUsed=!0,p.extensions=p.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(T.anisotropy.texture),a={anisotropyStrength:T.anisotropy.gX,anisotropyRotation:T.anisotropy.angle,anisotropyTexture:A??void 0};null!==a.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(T),p.extensions[Hp]=a}N(p)}))}}DN.RegisterExtension(Hp,(N=>new Mp(N)));const bp="KHR_materials_clearcoat";class lp{constructor(N){this.name=bp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,p,T){const A=[];return T instanceof ep.d&&T.clearCoat.isEnabled?(T.clearCoat.texture&&A.push(T.clearCoat.texture),!T.clearCoat.useRoughnessFromMainTexture&&T.clearCoat.textureRoughness&&A.push(T.clearCoat.textureRoughness),T.clearCoat.bumpTexture&&A.push(T.clearCoat.bumpTexture),A):[]}postExportMaterialAsync(N,p,T){return new Promise((N=>{if(T instanceof ep.d){if(!T.clearCoat.isEnabled)return void N(p);this._wasUsed=!0,p.extensions=p.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(T.clearCoat.texture);let C;C=T.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(T.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(T.clearCoat.textureRoughness),T.clearCoat.isTintEnabled&&a.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${T.name}`),T.clearCoat.remapF0OnInterfaceChange&&a.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${T.name}`);const U=this._exporter._materialExporter.getTextureInfo(T.clearCoat.bumpTexture),X={clearcoatFactor:T.clearCoat.gX,clearcoatTexture:A??void 0,clearcoatRoughnessFactor:T.clearCoat.roughness,clearcoatRoughnessTexture:C??void 0,clearcoatNormalTexture:U??void 0};null===X.clearcoatTexture&&null===X.clearcoatRoughnessTexture&&null===X.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(T),p.extensions[bp]=X}N(p)}))}}DN.RegisterExtension(bp,(N=>new lp(N)));const kp="KHR_materials_diffuse_transmission";function xp(N,p){const T=p.subSurface;let A=null;return T.translucencyIntensityTexture?A=T.translucencyIntensityTexture:T.thicknessTexture&&T.useMaskFromThicknessTexture&&(A=T.thicknessTexture),A&&!T.useGltfStyleTextures?(j.d.Warn(`${N}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${p.name}`,1),null):A}class Ip{constructor(N){this.name=kp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,p,T){const A=[];if(T instanceof kN.b&&this._isExtensionEnabled(T)){const p=xp(N,T);return p&&A.push(p),T.subSurface.translucencyColorTexture&&A.push(T.subSurface.translucencyColorTexture),A}return A}_isExtensionEnabled(N){if(N.unlit)return!1;const p=N.subSurface;return!!p.isTranslucencyEnabled&&(!N.unlit&&!p.useAlbedoToTintTranslucency&&p.useGltfStyleTextures&&1===p.volumeIndexOfRefraction&&0===p.minimumThickness&&0===p.maximumThickness)}postExportMaterialAsync(N,p,T){return new Promise((A=>{if(T instanceof kN.b&&this._isExtensionEnabled(T)){this._wasUsed=!0;const A=T.subSurface,a=xp(N,T),C=0==A.translucencyIntensity?void 0:A.translucencyIntensity,U=this._exporter._materialExporter.getTextureInfo(a)??void 0,X=!A.translucencyColor||A.translucencyColor.equalsFloats(1,1,1)?void 0:A.translucencyColor.UX(),y=this._exporter._materialExporter.getTextureInfo(A.translucencyColorTexture)??void 0,e={diffuseTransmissionFactor:C,diffuseTransmissionTexture:U,diffuseTransmissionColorFactor:X,diffuseTransmissionColorTexture:y};(U||y)&&this._exporter._materialNeedsUVsSet.add(T),p.extensions=p.extensions||{},p.extensions[kp]=e}A(p)}))}}DN.RegisterExtension(kp,(N=>new Ip(N)));const Lp="KHR_materials_dispersion";class np{constructor(){this.name=Lp,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(N){if(N.unlit)return!1;const p=N.subSurface;return!(!p.isRefractionEnabled&&!p.isDispersionEnabled)}postExportMaterialAsync(N,p,T){return new Promise((N=>{if(T instanceof kN.b&&this._isExtensionEnabled(T)){this._wasUsed=!0;const N={dispersion:T.subSurface.dispersion};p.extensions=p.extensions||{},p.extensions[Lp]=N}N(p)}))}}DN.RegisterExtension(Lp,(()=>new np));const wp="KHR_materials_emissive_strength";class gp{constructor(){this.name=wp,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(N,p,T){return await new Promise((N=>{if(!(T instanceof kN.b))return N(p);const A=T.emissiveColor.UX(),a=Math.max(...A);if(a>1){this._wasUsed=!0,p.extensions||(p.extensions={});const N={emissiveStrength:a},A=T.emissiveColor.scale(1/N.emissiveStrength);p.emissiveFactor=A.UX(),p.extensions[wp]=N}return N(p)}))}}DN.RegisterExtension(wp,(N=>new gp));const Pp="KHR_materials_ior";class ip{constructor(){this.name=Pp,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(N){return!N.unlit&&(void 0!=N.indexOfRefraction&&1.5!=N.indexOfRefraction)}postExportMaterialAsync(N,p,T){return new Promise((N=>{if(T instanceof kN.b&&this._isExtensionEnabled(T)){this._wasUsed=!0;const N={ior:T.indexOfRefraction};p.extensions=p.extensions||{},p.extensions[Pp]=N}N(p)}))}}DN.RegisterExtension(Pp,(N=>new ip));const Kp="KHR_materials_iridescence";class Fp{constructor(N){this.name=Kp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,p,T){const A=[];return T instanceof ep.d&&T.iridescence.isEnabled?(T.iridescence.texture&&A.push(T.iridescence.texture),T.iridescence.thicknessTexture&&T.iridescence.thicknessTexture!==T.iridescence.texture&&A.push(T.iridescence.thicknessTexture),A):[]}postExportMaterialAsync(N,p,T){return new Promise((N=>{if(T instanceof ep.d){if(!T.iridescence.isEnabled)return void N(p);this._wasUsed=!0,p.extensions=p.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(T.iridescence.texture),a=this._exporter._materialExporter.getTextureInfo(T.iridescence.thicknessTexture),C={iridescenceFactor:T.iridescence.gX,iridescenceIor:T.iridescence.indexOfRefraction,iridescenceThicknessMinimum:T.iridescence.minimumThickness,iridescenceThicknessMaximum:T.iridescence.maximumThickness,iridescenceTexture:A??void 0,iridescenceThicknessTexture:a??void 0};null===C.iridescenceTexture&&null===C.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(T),p.extensions[Kp]=C}N(p)}))}}DN.RegisterExtension(Kp,(N=>new Fp(N)));const vp="KHR_materials_sheen";class Wp{constructor(N){this.name=vp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,p,T){return T instanceof kN.b&&T.sheen.isEnabled&&T.sheen.texture?[T.sheen.texture]:[]}async postExportMaterialAsync(N,p,T){return await new Promise((N=>{if(T instanceof kN.b){if(!T.sheen.isEnabled)return void N(p);this._wasUsed=!0,null==p.extensions&&(p.extensions={});const A={sheenColorFactor:T.sheen.color.UX(),sheenRoughnessFactor:T.sheen.roughness??0};null===A.sheenColorTexture&&null===A.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(T),T.sheen.texture&&(A.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(T.sheen.texture)??void 0),T.sheen.textureRoughness&&!T.sheen.useRoughnessFromMainTexture?A.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(T.sheen.textureRoughness)??void 0:T.sheen.texture&&T.sheen.useRoughnessFromMainTexture&&(A.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(T.sheen.texture)??void 0),p.extensions[vp]=A}N(p)}))}}DN.RegisterExtension(vp,(N=>new Wp(N)));const zp="KHR_materials_specular";class Rp{constructor(N){this.name=zp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,p,T){const A=[];return T instanceof kN.b&&this._isExtensionEnabled(T)?(T.metallicReflectanceTexture&&A.push(T.metallicReflectanceTexture),T.reflectanceTexture&&A.push(T.reflectanceTexture),A):A}_isExtensionEnabled(N){return!N.unlit&&(void 0!=N.metallicF0Factor&&1!=N.metallicF0Factor||void 0!=N.metallicReflectanceColor&&!N.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(N))}_hasTexturesExtension(N){return null!=N.metallicReflectanceTexture||null!=N.reflectanceTexture}postExportMaterialAsync(N,p,T){return new Promise((N=>{if(T instanceof kN.b&&this._isExtensionEnabled(T)){this._wasUsed=!0,p.extensions=p.extensions||{};const N=this._exporter._materialExporter.getTextureInfo(T.metallicReflectanceTexture)??void 0,A=this._exporter._materialExporter.getTextureInfo(T.reflectanceTexture)??void 0,a={specularFactor:1==T.metallicF0Factor?void 0:T.metallicF0Factor,specularTexture:N,specularColorFactor:T.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:T.metallicReflectanceColor.UX(),specularColorTexture:A};this._hasTexturesExtension(T)&&this._exporter._materialNeedsUVsSet.add(T),p.extensions[zp]=a}N(p)}))}}DN.RegisterExtension(zp,(N=>new Rp(N)));const Jp="KHR_materials_transmission";class fp{constructor(N){this.name=Jp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,p,T){const A=[];return T instanceof kN.b&&this._isExtensionEnabled(T)?(T.subSurface.thicknessTexture&&A.push(T.subSurface.thicknessTexture),A):A}_isExtensionEnabled(N){if(N.unlit)return!1;const p=N.subSurface;return p.isRefractionEnabled&&void 0!=p.refractionIntensity&&0!=p.refractionIntensity||this._hasTexturesExtension(N)}_hasTexturesExtension(N){return null!=N.subSurface.refractionIntensityTexture}async postExportMaterialAsync(N,p,T){if(T instanceof kN.b&&this._isExtensionEnabled(T)){this._wasUsed=!0;const A=T.subSurface,a={transmissionFactor:0===A.refractionIntensity?void 0:A.refractionIntensity};if(this._hasTexturesExtension(T)&&this._exporter._materialNeedsUVsSet.add(T),A.refractionIntensityTexture)if(A.useGltfStyleTextures){const N=await this._exporter._materialExporter.exportTextureAsync(A.refractionIntensityTexture,"image/png");N&&(a.transmissionTexture=N)}else j.d.Warn(`${N}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);p.extensions||(p.extensions={}),p.extensions[Jp]=a}return p}}DN.RegisterExtension(Jp,(N=>new fp(N)));const Gp="KHR_materials_unlit";class op{constructor(){this.name=Gp,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(N,p,T){return new Promise((N=>{let A=!1;T instanceof kN.b?A=T.unlit:T instanceof xN.np&&(A=T.disableLighting),A&&(this._wasUsed=!0,null==p.extensions&&(p.extensions={}),p.extensions[Gp]={}),N(p)}))}}DN.RegisterExtension(Gp,(()=>new op));const Zp="KHR_materials_volume";class mT{constructor(N){this.name=Zp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,p,T){const A=[];return T instanceof kN.b&&this._isExtensionEnabled(T)?(T.subSurface.thicknessTexture&&A.push(T.subSurface.thicknessTexture),A):A}_isExtensionEnabled(N){if(N.unlit)return!1;const p=N.subSurface;return!(!p.isRefractionEnabled&&!p.isTranslucencyEnabled)&&(void 0!=p.maximumThickness&&0!=p.maximumThickness||void 0!=p.tintColorAtDistance&&p.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=p.tintColor&&p.tintColor!=I.wp.White()||this._hasTexturesExtension(N))}_hasTexturesExtension(N){return null!=N.subSurface.thicknessTexture}postExportMaterialAsync(N,p,T){return new Promise((N=>{if(T instanceof kN.b&&this._isExtensionEnabled(T)){this._wasUsed=!0;const N=T.subSurface,A={thicknessFactor:0==N.maximumThickness?void 0:N.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(N.thicknessTexture)??void 0,attenuationDistance:N.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:N.tintColorAtDistance,attenuationColor:N.tintColor.equalsFloats(1,1,1)?void 0:N.tintColor.UX()};this._hasTexturesExtension(T)&&this._exporter._materialNeedsUVsSet.add(T),p.extensions=p.extensions||{},p.extensions[Zp]=A}N(p)}))}}DN.RegisterExtension(Zp,(N=>new mT(N)));const qp="EXT_materials_diffuse_roughness";class hp{constructor(N){this.name=qp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,p,T){const A=[];return T instanceof ep.d&&T._baseDiffuseRoughness?(T._baseDiffuseRoughnessTexture&&A.push(T._baseDiffuseRoughnessTexture),A):[]}postExportMaterialAsync(N,p,T){return new Promise((N=>{if(T instanceof ep.d){if(!T._baseDiffuseRoughness)return void N(p);this._wasUsed=!0,p.extensions=p.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(T._baseDiffuseRoughnessTexture),a={diffuseRoughnessFactor:T._baseDiffuseRoughness,diffuseRoughnessTexture:A??void 0};null!==a.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(T),p.extensions[qp]=a}N(p)}))}}DN.RegisterExtension(qp,(N=>new hp(N)));const jp="KHR_texture_transform";class Vp{constructor(){this.name=jp,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(N,p,T){if(T.KN()||a.Tools.Warn(`${N}: /*@__KEY__*/"scene" is not defined for Babylon texture ${T.name}!`),(0!==T.uAng||0!==T.vAng)&&(a.Tools.Warn(`${N}: Texture ${T.name} with rotation in the u or v axis is not supported in glTF.`),0!==T.uRotationCenter||0!==T.vRotationCenter))return;const A={};let C=!1;if(0===T.uOffset&&0===T.vOffset||(A.offset=[T.uOffset,T.vOffset],C=!0),1===T.uScale&&1===T.vScale||(A.scale=[T.uScale,T.vScale],C=!0),0!==T.wAng){if(0!==T.uRotationCenter||0!==T.vRotationCenter){if(T.homogeneousRotationInUVTransform&&T.uScale!==T.vScale)return void a.Tools.Warn(`${N}: Texture ${T.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${jp}.`);a.Tools.Warn(`${N}: Texture ${T.name} with non-origin rotation center will be exported using an adjusted offset with ${jp}.`),A.offset=function(N){const{uOffset:p,vOffset:T,uRotationCenter:A,vRotationCenter:a,uScale:C,vScale:U,wAng:X}=N,y=Math.cos(X),e=Math.sin(X),H=A*C,M=a*U;return[p+(H*(1-y)+M*e),T+(M*(1-y)-H*e)]}(T)}A.rotation=-T.wAng,C=!0}0!==T.coordinatesIndex&&(A.texCoord=T.coordinatesIndex,C=!0),C&&(this._wasUsed=!0,p.extensions||(p.extensions={}),p.extensions[jp]=A)}}DN.RegisterExtension(jp,(()=>new Vp));class rp{static CreateSTL(N){let p=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],C=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],U=arguments.length>5&&void 0!==arguments[5]&&arguments[5],X=arguments.length>6&&void 0!==arguments[6]&&arguments[6],y=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const e=function(N,p,T){const a=[3*N[T],3*N[T+1],3*N[T+2]],C=[new A.xp(p[a[0]],p[a[0]+2],p[a[0]+1]),new A.xp(p[a[1]],p[a[1]+2],p[a[1]+1]),new A.xp(p[a[2]],p[a[2]+2],p[a[2]+1])],U=C[0].Ip(C[1]),X=C[2].Ip(C[1]);return{v:C,n:A.xp.Cross(X,U).normalize()}},M=function(N,p,T,A){return p=b(N,p,T.x,A),p=b(N,p,T.y,A),b(N,p,T.z,A)},b=function(N,p,T,A){return N.setFloat32(p,T,A),p+4},k=function(N){if(X){let p=N;N instanceof l.d&&(p=N.sourceMesh);const T=p.getVerticesData(H.f.PositionKind,!0,!0);if(!T)return[];const a=A.xp.Zero();let C;for(C=0;C<T.length;C+=3)A.xp.TransformCoordinatesFromFloatsToRef(T[C],T[C+1],T[C+2],N.HX(!0),a).toArray(T,C);return T}return N.getVerticesData(H.f.PositionKind)||[]};X&&(U=!0);let x="",I=0,L=0;if(a){for(let T=0;T<N.length;T++){const p=N[T].bX();I+=p?p.length/3:0}const p=new ArrayBuffer(84+50*I);x=new DataView(p),L+=80,x.setUint32(L,I,C),L+=4}else y||(x="solid stlmesh\r\n");for(let A=0;A<N.length;A++){const p=N[A];!a&&y&&(x+="solid "+p.name+"\r\n"),!U&&p instanceof nN.d&&p.bakeCurrentTransformIntoVertices();const T=k(p),X=p.bX()||[];for(let N=0;N<X.length;N+=3){const p=e(X,T,N);a?(L=M(x,L,p.n,C),L=M(x,L,p.v[0],C),L=M(x,L,p.v[1],C),L=M(x,L,p.v[2],C),L+=2):(x+="\tfacet normal "+p.n.x+" "+p.n.y+" "+p.n.z+"\r\n",x+="\t\touter loop\r\n",x+="\t\t\tvertex "+p.v[0].x+" "+p.v[0].y+" "+p.v[0].z+"\r\n",x+="\t\t\tvertex "+p.v[1].x+" "+p.v[1].y+" "+p.v[1].z+"\r\n",x+="\t\t\tvertex "+p.v[2].x+" "+p.v[2].y+" "+p.v[2].z+"\r\n",x+="\t\tendloop\r\n",x+="\tendfacet\r\n")}!a&&y&&(x+="endsolid "+name+"\r\n")}if(a||y||(x+="endsolid stlmesh"),p){const N=document.createElement("a"),p=new Blob([x],{type:"application/octet-stream"});N.href=window.URL.createObjectURL(p),N.download=T+".stl",N.click()}return x}}function upN(N,p){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const A=[];for(let a=0;a<N.length/T;a++){const C=N[a*T],U=N[a*T+1],X=N[a*T+2];A.push(`(${C.toPrecision(p.precision)}, ${U.toPrecision(p.precision)}, ${X.toPrecision(p.precision)})`)}return A.join(", ")}function Yp(N,p){const T=[];for(let A=0;A<N.length/2;A++){const a=N[2*A],C=N[2*A+1];T.push(`(${a.toPrecision(p.precision)}, ${(1-C).toPrecision(p.precision)})`)}return T.join(", ")}function Dp(N,p){const T=N.getVerticesData(H.f.PositionKind),A=N.getVerticesData(H.f.NormalKind);if(T&&A)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(N){var p;const T=null!==(p=N.bX())&&void 0!==p&&p.length?N.getTotalIndices():N.getTotalVertices();return Array(T/3).fill(3).join(", ")}(N)}]\n\t\tint[] faceVertexIndices = [${function(N){const p=N.bX(),T=[];if(null!==p)for(let A=0;A<p.length;A++)T.push(p[A]);else{const p=N.getTotalVertices();for(let N=0;N<p;N++)T.push(N)}return T.join(", ")}(N)}]\n\t\tnormal3f[] normals = [${upN(A,p)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${upN(T,p)}]\n        ${function(N,p){let T="";for(let a=0;a<4;a++){const A=a>0?a:"",C=N.getVerticesData(H.f.UVKind+(A?A+1:""));C&&(T+=`\n\t\ttexCoord2f[] primvars:st${A} = [${Yp(C,p)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const A=N.getVerticesData(H.f.ColorKind);return A&&(T+=`\n\tcolor3f[] primvars:displayColor = [${upN(A,p,A.length/N.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),T}(N,p)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function cp(N,p){return`\n        def "Geometry"\n        {\n        ${Dp(N,p)}\n        }\n        `}function Qp(N){let p='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return p+=N,fflate.strToU8(p)}function Ep(N){const p=N.m;return`( ${Op(p,0)}, ${Op(p,4)}, ${Op(p,8)}, ${Op(p,12)} )`}function Op(N,p){return`(${N[p+0]}, ${N[p+1]}, ${N[p+2]}, ${N[p+3]})`}function Bp(N){const p="Object_"+N.uniqueId,T=function(N){const p=N.getWorldMatrix().clone(),T=N.KN().useRightHandedSystem;if(!T){let A=N.parent;for(;A;){if(UN(A,T)){p.multiplyToRef(A.getWorldMatrix().invert(),p);break}A=A.parent}}return p.determinant()<0&&a.Tools.Warn(`Exporting mesh ${N.name} with negative scale. Result may look incorrect in destination engine.`),p}(N),A=Ep(T);return`def Xform "${p}" (\n\tprepend references = @./geometries/Geometry_${N.MX.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${A}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${N.material.uniqueId}>\n}\n\n`}function dp(N){switch(N){case K.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case K.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case K.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function tp(N){return`(${N.x}, ${N.y})`}function Sp(N){return`(${N.r}, ${N.g}, ${N.b})`}function sp(N,p,T,a,C,U){const X=N.getInternalTexture().uniqueId+"_"+N.invertY;C[X]=N;const y=N.coordinatesIndex>0?"st"+N.coordinatesIndex:"st",e=new A.Vector2(N.uScale,N.vScale),H=new A.Vector2(N.uOffset,N.vOffset),M=N.wAng,b=Math.sin(M),l=Math.cos(M);return H.y=1-H.y-e.y,H.x+=b*e.x,H.y+=(1-l)*e.y,`\n    def Shader "PrimvarReader_${T}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${y}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${T}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${p.uniqueId}/PrimvarReader_${T}.outputs:result>\n        float inputs:rotation = ${(M*(180/Math.PI)).toFixed(U.precision)}\n        float2 inputs:scale = ${tp(e)}\n        float2 inputs:translation = ${tp(H)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${N.uniqueId}_${T}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${X}.png@\n        float2 inputs:st.connect = </Materials/Material_${p.uniqueId}/Transform2d_${T}.outputs:result>\n        ${a?"float4 inputs:scale = "+function(N){return`(${N.r}, ${N.g}, ${N.b}, 1.0)`}(a):""}\n        token inputs:sourceColorSpace = "${N.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${dp(N.wrapU)}"\n        token inputs:wrapT = "${dp(N.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${p.needAlphaBlending()?"float outputs:a":""}\n    }`}function NT(N,p,T){const A="\t\t\t",a=[],C=[],{diffuseMap:U,PX:X,alphaCutOff:y,emissiveMap:e,emissive:H,normalMap:M,roughnessMap:b,roughnessChannel:l,roughness:k,metalnessMap:x,metalnessChannel:L,metalness:n,aoMap:w,aoMapChannel:g,aoMapIntensity:P,alphaMap:i,ior:K,clearCoatEnabled:F,clearCoat:v,clearCoatMap:W,clearCoatRoughness:z,clearCoatRoughnessMap:R}=function(N){const p={diffuseMap:null,PX:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return N instanceof xN.np?{...p,diffuseMap:N.diffuseTexture,PX:N.diffuseColor,alphaCutOff:N.alphaCutOff,emissiveMap:N.emissiveTexture,emissive:N.emissiveColor,roughness:1,alphaMap:N.opacityTexture}:N instanceof ep.d?{...p,diffuseMap:N._albedoTexture,PX:N._albedoColor,alphaCutOff:N._alphaCutOff,emissiveMap:N._emissiveTexture,emissive:N._emissiveColor,normalMap:N._bumpTexture,roughnessMap:N._metallicTexture,roughnessChannel:N._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:N._roughness??1,metalnessMap:N._metallicTexture,metalnessChannel:N._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:N._metallic??0,aoMap:N._ambientTexture,aoMapChannel:N._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:N._ambientTextureStrength,alphaMap:N._opacityTexture,ior:N.subSurface.indexOfRefraction,clearCoatEnabled:N.clearCoat.isEnabled,clearCoat:N.clearCoat.gX,clearCoatMap:N.clearCoat.texture,clearCoatRoughness:N.clearCoat.roughness,clearCoatRoughnessMap:N.clearCoat.useRoughnessFromMainTexture?N.clearCoat.texture:N.clearCoat.textureRoughness}:p}(N);return null!==U?(a.push(`${A}color3f inputs:diffuseColor.connect = </Materials/Material_${N.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:rgb>`),N.needAlphaBlending()?a.push(`${A}float inputs:opacity.connect = </Materials/Material_${N.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:a>`):N.needAlphaTesting()&&(a.push(`${A}float inputs:opacity.connect = </Materials/Material_${N.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:a>`),a.push(`${A}float inputs:opacityThreshold = ${y}`)),C.push(sp(U,N,"diffuse",X,p,T))):a.push(`${A}color3f inputs:diffuseColor = ${Sp(X||I.wp.White())}`),null!==e?(a.push(`${A}color3f inputs:emissiveColor.connect = </Materials/Material_${N.uniqueId}/Texture_${e.uniqueId}_emissive.outputs:rgb>`),C.push(sp(e,N,"emissive",H,p,T))):H&&H.toLuminance()>0&&a.push(`${A}color3f inputs:emissiveColor = ${Sp(H)}`),null!==M&&(a.push(`${A}normal3f inputs:normal.connect = </Materials/Material_${N.uniqueId}/Texture_${M.uniqueId}_normal.outputs:rgb>`),C.push(sp(M,N,"normal",null,p,T))),null!==w&&(a.push(`${A}float inputs:occlusion.connect = </Materials/Material_${N.uniqueId}/Texture_${w.uniqueId}_occlusion.outputs:${g}>`),C.push(sp(w,N,"occlusion",new I.wp(P,P,P),p,T))),null!==b?(a.push(`${A}float inputs:roughness.connect = </Materials/Material_${N.uniqueId}/Texture_${b.uniqueId}_roughness.outputs:${l}>`),C.push(sp(b,N,"roughness",new I.wp(k,k,k),p,T))):a.push(`${A}float inputs:roughness = ${k}`),null!==x?(a.push(`${A}float inputs:metallic.connect = </Materials/Material_${N.uniqueId}/Texture_${x.uniqueId}_metallic.outputs:${L}>`),C.push(sp(x,N,"metallic",new I.wp(n,n,n),p,T))):a.push(`${A}float inputs:metallic = ${n}`),null!==i?(a.push(`${A}float inputs:opacity.connect = </Materials/Material_${N.uniqueId}/Texture_${i.uniqueId}_opacity.outputs:r>`),a.push(`${A}float inputs:opacityThreshold = 0.0001`),C.push(sp(i,N,"opacity",null,p,T))):a.push(`${A}float inputs:opacity = ${N.alpha}`),F&&(null!==W?(a.push(`${A}float inputs:clearcoat.connect = </Materials/Material_${N.uniqueId}/Texture_${W.uniqueId}_clearcoat.outputs:r>`),C.push(sp(W,N,"clearcoat",new I.wp(v,v,v),p,T))):a.push(`${A}float inputs:clearcoat = ${v}`),null!==R?(a.push(`${A}float inputs:clearcoatRoughness.connect = </Materials/Material_${N.uniqueId}/Texture_${R.uniqueId}_clearcoatRoughness.outputs:g>`),C.push(sp(R,N,"clearcoatRoughness",new I.wp(z,z,z),p,T))):a.push(`${A}float inputs:clearcoatRoughness = ${z}`)),a.push(`${A}float inputs:ior = ${K}`),`\n\tdef Material "Material_${N.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${a.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${N.uniqueId}/PreviewSurface.outputs:surface>\n\n${C.join("\n")}\n\n\t}\n`}async function pT(N,p,T){const C={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...p};"undefined"===typeof fflate&&await a.Tools.LoadScriptAsync(C.fflateUrl);const U={};U[C.modelFileName]=null;let X='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';X+=function(N){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===N.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${N.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${N.planeAnchoringAlignment}"`:""}\n            `}(C);const y={};for(const A of N.meshes){if(0===A.getTotalVertices())continue;const N=A,p=N.MX,e=N.material;if(!e||!p||T&&!T(N))continue;if(-1!==["np","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(e.getClassName())){const T="geometries/Geometry_"+p.uniqueId+".usda";if(!(T in U)){const N=cp(p,C);U[T]=Qp(N)}e.uniqueId in y||(y[e.uniqueId]=e),X+=Bp(N)}else a.Tools.Warn("USDZExportAsync does not support this material type: "+e.getClassName())}N.activeCamera&&C.exportCamera&&(X+=function(N,p){const T="Camera_"+N.uniqueId,a=Ep(A.Matrix.RotationY(Math.PI).multiply(N.getWorldMatrix()));if(N.mode===K.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${T}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${a}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${N.yX.toPrecision(p.precision)}, ${N.maxZ.toPrecision(p.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(N.orthoLeft||1)+Math.abs(N.orthoRight||1))).toPrecision(p.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(N.orthoTop||1)+Math.abs(N.orthoBottom||1))).toPrecision(p.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const A=N.getEngine().getAspectRatio(N),C=p.cameraSensorWidth||35;return`def Camera "${T}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${a}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${N.yX.toPrecision(p.precision)}, ${N.maxZ.toPrecision(p.precision)})\n\t\t\tfloat focalLength = ${(C/(2*Math.tan(.5*N.fov))).toPrecision(p.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(C*A).toPrecision(p.precision)}\n\t\t\tfloat verticalAperture = ${(C/A).toPrecision(p.precision)}            \n\t\t}\n\t\n\t`}}(N.activeCamera,C)),X+="\n            }\n        }\n    }";const e={};X+=function(N,p,T){const A=[];for(const a in N){const C=N[a];A.push(NT(C,p,T))}return`\n    def "Materials"\n{\n${A.join("")}\n}\n\n`}(y,e,C),U[C.modelFileName]=fflate.strToU8(X);for(const A in e){const N=e[A],p=N.getSize(),T=await N.readPixels();if(!T)throw new Error("Texture data is not available");const a=await F.DumpTools.DumpDataAsync(p.width,p.height,T,"image/png",void 0,!1,!0);U[`textures/Texture_${A}.png`]=new Uint8Array(a).slice()}let H=0;for(const A in U){const N=U[A];if(!N)continue;H+=34+A.length;const p=63&H;if(4!==p){const T=new Uint8Array(64-p);U[A]=[N,{extra:{12345:T}}]}H=N.length}return fflate.zipSync(U,{level:0})}}}]);