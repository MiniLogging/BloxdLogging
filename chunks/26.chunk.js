"use strict";(self["7c63p8lin4r"]=self["7c63p8lin4r"]||[]).push([[26],{13312:(z,u,U)=>{U.r(u),U.d(u,{EXT_materials_diffuse_roughness:()=>Fu,EXT_mesh_gpu_instancing:()=>nz,GLTF2Export:()=>az,GLTFData:()=>R,KHR_draco_mesh_compression:()=>Ju,KHR_lights_punctual:()=>Ru,KHR_materials_anisotropy:()=>mU,KHR_materials_clearcoat:()=>Au,KHR_materials_diffuse_transmission:()=>ru,KHR_materials_dispersion:()=>Tu,KHR_materials_emissive_strength:()=>hu,KHR_materials_ior:()=>Vu,KHR_materials_iridescence:()=>Ou,KHR_materials_sheen:()=>Qu,KHR_materials_specular:()=>Yu,KHR_materials_transmission:()=>Nu,KHR_materials_unlit:()=>cu,KHR_materials_volume:()=>ju,KHR_texture_transform:()=>ku,OBJExport:()=>g,STLExport:()=>Bu,USDZExportAsync:()=>UU,_ConvertToGLTFPBRMetallicRoughness:()=>D,_SolveMetallic:()=>N,__IGLTFExporterExtension:()=>w});var J=U(12914),v=U(12748),f=U(13224);class g{static OBJ(z,u,U,g){const w=[];let P=1,R=1;u&&(U||(U="mat"),w.push("mtllib "+U+".mtl"));for(let S=0;S<z.length;S++){const U=z[S],d=U.name||"mesh".concat(S,"}");w.push("o ".concat(d));let mz=null;if(g){const z=U.af(!0);mz=new J.Matrix,z.invertToRef(mz),U.bakeTransformIntoVertices(z)}if(u){const z=U.material;z&&w.push("usemtl "+z.id)}const Z=U.nf;if(!Z){v.Tools.Warn("No geometry is present on the mesh");continue}const A=Z.getVerticesData("position"),E=Z.getVerticesData("normal"),C=Z.getVerticesData("uv"),r=Z.lf();let M=0,T=0;if(!A||!r){v.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const X=z[0].Vz().useRightHandedSystem?1:-1;for(let z=0;z<A.length;z+=3)w.push("v "+A[z]*X+" "+A[z+1]+" "+A[z+2]),M++;if(null!=E)for(let z=0;z<E.length;z+=3)w.push("vn "+E[z]*X+" "+E[z+1]+" "+E[z+2]);if(null!=C)for(let z=0;z<C.length;z+=2)w.push("vt "+C[z]+" "+C[z+1]),T++;const h=["","",""],t=(U.material||U.Vz().defaultMaterial)._getEffectiveOrientation(U),[V,L]=t===f.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let z=0;z<r.length;z+=3){const u=[String(r[z]+P),String(r[z+V]+P),String(r[z+L]+P)],U=[String(r[z]+R),String(r[z+V]+R),String(r[z+L]+R)],J=u,v=null!=C?U:h,f=null!=E?u:h;w.push("f "+J[0]+"/"+v[0]+"/"+f[0]+" "+J[1]+"/"+v[1]+"/"+f[1]+" "+J[2]+"/"+v[2]+"/"+f[2])}g&&mz&&U.bakeTransformIntoVertices(mz),P+=M,R+=T}return w.join("\n")}static MTL(z){const u=[],U=z.material;u.push("newmtl mat1"),u.push("  Ns "+U.specularPower.toFixed(4)),u.push("  Ni 1.5000"),u.push("  d "+U.alpha.toFixed(4)),u.push("  Tr 0.0000"),u.push("  Tf 1.0000 1.0000 1.0000"),u.push("  illum 2"),u.push("  Ka "+U.ambientColor.r.toFixed(4)+" "+U.ambientColor.g.toFixed(4)+" "+U.ambientColor.b.toFixed(4)),u.push("  Kd "+U.diffuseColor.r.toFixed(4)+" "+U.diffuseColor.g.toFixed(4)+" "+U.diffuseColor.b.toFixed(4)),u.push("  Ks "+U.specularColor.r.toFixed(4)+" "+U.specularColor.g.toFixed(4)+" "+U.specularColor.b.toFixed(4)),u.push("  Ke "+U.emissiveColor.r.toFixed(4)+" "+U.emissiveColor.g.toFixed(4)+" "+U.emissiveColor.b.toFixed(4));U.ambientTexture&&u.push("  map_Ka "+U.ambientTexture.name),U.diffuseTexture&&u.push("  map_Kd "+U.diffuseTexture.name),U.specularTexture&&u.push("  map_Ks "+U.specularTexture.name),U.bumpTexture&&u.push("  map_bump -imfchan z "+U.bumpTexture.name),U.opacityTexture&&u.push("  map_d "+U.opacityTexture.name);return u.join("\n")}}var w=0,P=U(12800);class R{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const z in this.files){const u=this.files[z],U=new Blob([u],{type:(0,P.e)(z)});v.Tools.Download(U,z)}}}var S=U(21),d=U(13e3),mz=U(13314),Z=U(13320),A=U(13333),E=U(13050),C=U(12797),r=U(12967),M=U(12935);const T=M.HighestCommonFactor,X=(0,S.e)((0,S.e)({},M),{},{TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:T});var h=U(13148),t=U(12894),V=U(13353),L=U(13360),O=U(13144);const x=1e-6,Q=new r.Tu(.04,.04,.04),K=1024,Y=r.Tu.White(),p=r.Tu.Black();function N(z,u,U){if(u<Q.r)return 0;const J=Q.r,v=z*U/(1-Q.r)+u-2*Q.r,f=v*v-4*J*(Q.r-u);return X.Clamp((-v+Math.sqrt(f))/(2*J),0,1)}function D(z){const u=z.diffuseColor.toLinearSpace(z.Vz().getEngine().useExactSrgbConversions).scale(.5),U=z.alpha,v=function(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new J.Vector2(0,1),U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new J.Vector2(0,.1),v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new J.Vector2(0,.1),f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new J.Vector2(1300,.1);return function(z,u,U,J,v){return(1-z)*(1-z)*(1-z)*u+3*(1-z)*(1-z)*z*U+3*(1-z)*z*z*J+z*z*z*v}(Math.pow(z/f.x,.333333),u.y,U.y,v.y,f.y)}(X.Clamp(z.specularPower,0,K));return{baseColorFactor:[u.r,u.g,u.b,U],metallicFactor:0,roughnessFactor:v}}function c(z,u){u.needAlphaBlending()?z.alphaMode="BLEND":u.needAlphaTesting()&&(z.alphaMode="MASK",z.alphaCutoff=u.alphaCutOff)}function W(z,u,U){const J=new Uint8Array(z*u*4);for(let v=0;v<J.length;v+=4)J[v]=J[v+1]=J[v+2]=J[v+3]=255;return V.b.CreateRGBATexture(J,z,u,U)}function j(z){if(z instanceof Uint8Array){const u=z.length,U=new Float32Array(z.length);for(let J=0;J<u;++J)U[J]=z[J]/255;return U}if(z instanceof Float32Array)return z;throw new Error("Unsupported pixel format!")}class I{constructor(z){this._exporter=z,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(z){var u;return z&&null!==(u=this._textureMap.get(z))&&void 0!==u?u:null}async exportStandardMaterialAsync(z,u,U){const J=D(z),f={name:z.name};if(null==z.ef||z.ef||(z.twoSidedLighting||v.Tools.Warn(z.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),f.doubleSided=!0),U){const U=[],v=z.diffuseTexture;v&&U.push(this.exportTextureAsync(v,u).then((z=>{z&&(J.baseColorTexture=z)})));const g=z.bumpTexture;g&&U.push(this.exportTextureAsync(g,u).then((z=>{z&&(f.normalTexture=z,1!==g.level&&(f.normalTexture.scale=g.level))})));const w=z.emissiveTexture;w&&(f.emissiveFactor=[1,1,1],U.push(this.exportTextureAsync(w,u).then((z=>{z&&(f.emissiveTexture=z)}))));const P=z.ambientTexture;P&&U.push(this.exportTextureAsync(P,u).then((z=>{if(z){const u={index:z.index};f.occlusionTexture=u}}))),U.length>0&&(this._exporter._materialNeedsUVsSet.add(z),await Promise.all(U))}(z.alpha<1||z.opacityTexture)&&(z.alphaMode===L.d.ALPHA_COMBINE?f.alphaMode="BLEND":v.Tools.Warn(z.name+": glTF 2.0 does not support alpha mode: "+z.alphaMode.toString())),z.emissiveColor&&!z.emissiveColor.equalsWithEpsilon(p,x)&&(f.emissiveFactor=z.emissiveColor.jf()),f.pbrMetallicRoughness=J,c(f,z),await this._finishMaterialAsync(f,z,u);const g=this._exporter._materials;return g.push(f),g.length-1}async _finishMaterialAsync(z,u,U){const J=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",z,u),v=[];for(const f of J)v.push(this.exportTextureAsync(f,U));await Promise.all(v),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",z,u)}async _getImageDataAsync(z,u,J,v){const f=L.d.TEXTURETYPE_UNSIGNED_BYTE,g=this._exporter._babylonScene,w=g.getEngine(),P=w.createRawTexture(z,u,J,L.d.TEXTUREFORMAT_RGBA,!1,!0,t.e.NEAREST_SAMPLINGMODE,null,f);w.isWebGPU?await U.e(51).then(U.bind(U,15032)):await U.e(52).then(U.bind(U,15034)),await h.k.ApplyPostProcess("pass",P,g,f,L.d.TEXTURE_NEAREST_SAMPLINGMODE,L.d.TEXTUREFORMAT_RGBA);const R=await w._readTexturePixels(P,u,J);return await O.DumpTools.DumpDataAsync(u,J,R,v,void 0,!0,!0)}_resizeTexturesToSameDimensions(z,u,U){const J=z?z.getSize():{width:0,height:0},v=u?u.getSize():{width:0,height:0};let f,g;return J.width<v.width?(f=z&&z instanceof t.e?h.k.CreateResizedCopy(z,v.width,v.height,!0):W(v.width,v.height,U),g=u):J.width>v.width?(g=u&&u instanceof t.e?h.k.CreateResizedCopy(u,J.width,J.height,!0):W(J.width,J.height,U),f=z):(f=z,g=u),{texture1:f,texture2:g}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(z,u,U,J){const v=new Array;if(!z&&!u)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const f=z?z.Vz():u?u.Vz():null;if(f){var g;const w=this._resizeTexturesToSameDimensions(z,u,f),P=null===(g=w.texture1)||void 0===g?void 0:g.getSize();let R,S;const d=P.width,mz=P.height,Z=await w.texture1.readPixels(),A=await w.texture2.readPixels();if(!Z)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(R=j(Z),!A)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");S=j(A);const E=S.byteLength,C=new Uint8Array(E),M=new Uint8Array(E),T=4,X=p;let h=0,t=0;for(let z=0;z<mz;++z)for(let u=0;u<d;++u){const J=(d*z+u)*T,v={diffuseColor:new r.Tu(R[J],R[J+1],R[J+2]).toLinearSpace(f.getEngine().useExactSrgbConversions).multiply(U.diffuseColor),specularColor:new r.Tu(S[J],S[J+1],S[J+2]).toLinearSpace(f.getEngine().useExactSrgbConversions).multiply(U.specularColor),glossiness:S[J+3]*U.glossiness},g=this._convertSpecularGlossinessToMetallicRoughness(v);X.r=Math.max(X.r,g.baseColor.r),X.g=Math.max(X.g,g.baseColor.g),X.b=Math.max(X.b,g.baseColor.b),h=Math.max(h,g.metallic),t=Math.max(t,g.roughness),M[J]=255*g.baseColor.r,M[J+1]=255*g.baseColor.g,M[J+2]=255*g.baseColor.b,M[J+3]=w.texture1.kf?255*R[J+3]:255,C[J]=0,C[J+1]=255*g.roughness,C[J+2]=255*g.metallic,C[J+3]=255}const V={baseColor:X,metallic:h,roughness:t};let L=!1,O=!1;for(let z=0;z<mz;++z)for(let u=0;u<d;++u){const U=(d*z+u)*T;M[U]/=V.baseColor.r>x?V.baseColor.r:1,M[U+1]/=V.baseColor.g>x?V.baseColor.g:1,M[U+2]/=V.baseColor.b>x?V.baseColor.b:1;const J=r.Tu.FromInts(M[U],M[U+1],M[U+2]).toGammaSpace(f.getEngine().useExactSrgbConversions);M[U]=255*J.r,M[U+1]=255*J.g,M[U+2]=255*J.b,J.equalsWithEpsilon(Y,x)||(O=!0),C[U+1]/=V.roughness>x?V.roughness:1,C[U+2]/=V.metallic>x?V.metallic:1;r.Tu.FromInts(255,C[U+1],C[U+2]).equalsWithEpsilon(Y,x)||(L=!0)}return L&&v.push(this._getImageDataAsync(C,d,mz,J).then((z=>{V.metallicRoughnessTextureData=z}))),O&&v.push(this._getImageDataAsync(M,d,mz,J).then((z=>{V.baseColorTextureData=z}))),await Promise.all(v).then((()=>V))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(z){const u=this._getPerceivedBrightness(z.diffuseColor),U=this._getPerceivedBrightness(z.specularColor),J=1-this._getMaxComponent(z.specularColor),v=N(u,U,J),f=z.diffuseColor.scale(J/(1-Q.r)/Math.max(1-v)),g=z.specularColor.Cu(Q.scale(1-v)).scale(1/Math.max(v));let w=r.Tu.Lerp(f,g,v*v);w=w.clampToRef(0,1,w);return{baseColor:w,metallic:v,roughness:1-z.glossiness}}_getPerceivedBrightness(z){return z?Math.sqrt(.299*z.r*z.r+.587*z.g*z.g+.114*z.b*z.b):0}_getMaxComponent(z){return z?Math.max(z.r,Math.max(z.g,z.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(z,u,U,J){const v=[],f={baseColor:z._albedoColor,metallic:z._metallic,roughness:z._roughness};if(J){z._albedoTexture&&v.push(this.exportTextureAsync(z._albedoTexture,u).then((z=>{z&&(U.baseColorTexture=z)})));const J=z._metallicTexture;J&&v.push(this.exportTextureAsync(J,u).then((z=>{z&&(U.metallicRoughnessTexture=z)})))}return v.length>0&&(this._exporter._materialNeedsUVsSet.add(z),await Promise.all(v)),f}_getTextureSampler(z){const u={};if(!z||!(z instanceof t.e))return u;const U=this._getGLTFTextureWrapMode(z.wrapU);10497!==U&&(u.wrapS=U);const J=this._getGLTFTextureWrapMode(z.wrapV);switch(10497!==J&&(u.wrapT=J),z.samplingMode){case t.e.LINEAR_LINEAR:u.magFilter=9729,u.minFilter=9729;break;case t.e.LINEAR_NEAREST:u.magFilter=9729,u.minFilter=9728;break;case t.e.NEAREST_LINEAR:u.magFilter=9728,u.minFilter=9729;break;case t.e.NEAREST_LINEAR_MIPLINEAR:u.magFilter=9728,u.minFilter=9987;break;case t.e.NEAREST_NEAREST:u.magFilter=9728,u.minFilter=9728;break;case t.e.NEAREST_LINEAR_MIPNEAREST:u.magFilter=9728,u.minFilter=9985;break;case t.e.LINEAR_NEAREST_MIPNEAREST:u.magFilter=9729,u.minFilter=9984;break;case t.e.LINEAR_NEAREST_MIPLINEAR:u.magFilter=9729,u.minFilter=9986;break;case t.e.NEAREST_NEAREST_MIPLINEAR:u.magFilter=9728,u.minFilter=9986;break;case t.e.LINEAR_LINEAR_MIPLINEAR:u.magFilter=9729,u.minFilter=9987;break;case t.e.LINEAR_LINEAR_MIPNEAREST:u.magFilter=9729,u.minFilter=9985;break;case t.e.NEAREST_NEAREST_MIPNEAREST:u.magFilter=9728,u.minFilter=9984}return u}_getGLTFTextureWrapMode(z){switch(z){case t.e.WRAP_ADDRESSMODE:return 10497;case t.e.CLAMP_ADDRESSMODE:return 33071;case t.e.MIRROR_ADDRESSMODE:return 33648;default:return v.Tools.Error("Unsupported Texture Wrap Mode ".concat(z,"!")),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(z,u,U,J){const v={diffuseColor:z._albedoColor,specularColor:z._reflectivityColor,glossiness:z._microSurface},f=z._albedoTexture,g=z._reflectivityTexture,w=z._useMicroSurfaceFromReflectivityMapAlpha;if(g&&!w)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((f||g)&&J){this._exporter._materialNeedsUVsSet.add(z);const J=this._exportTextureSampler(f||g),w=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(f,g,v,u),P=this._exporter._textures;if(w.baseColorTextureData){const z=this._exportImage("baseColor".concat(P.length),u,w.baseColorTextureData);U.baseColorTexture=this._exportTextureInfo(z,J,null===f||void 0===f?void 0:f.coordinatesIndex)}if(w.metallicRoughnessTextureData){const z=this._exportImage("metallicRoughness".concat(P.length),u,w.metallicRoughnessTextureData);U.metallicRoughnessTexture=this._exportTextureInfo(z,J,null===g||void 0===g?void 0:g.coordinatesIndex)}return w}return this._convertSpecularGlossinessToMetallicRoughness(v)}async exportPBRMaterialAsync(z,u,U){const J={},v={name:z.name},f=z.isMetallicWorkflow();if(f){const u=z._albedoColor,U=z.alpha;u&&(J.baseColorFactor=[u.r,u.g,u.b,U])}const g=f?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(z,u,J,U):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(z,u,J,U);await this._setMetallicRoughnessPbrMaterialAsync(g,z,v,J,u,U),await this._finishMaterialAsync(v,z,u);const w=this._exporter._materials;return w.push(v),w.length-1}async _setMetallicRoughnessPbrMaterialAsync(z,u,U,J,f,g){if(c(U,u),z.baseColor.equalsWithEpsilon(Y,x)&&X.WithinEpsilon(u.alpha,1,x)||(J.baseColorFactor=[z.baseColor.r,z.baseColor.g,z.baseColor.b,u.alpha]),null!=z.metallic&&1!==z.metallic&&(J.metallicFactor=z.metallic),null!=z.roughness&&1!==z.roughness&&(J.roughnessFactor=z.roughness),null==u.ef||u.ef||(u._twoSidedLighting||v.Tools.Warn(u.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),U.doubleSided=!0),g){const z=[],J=u._bumpTexture;J&&z.push(this.exportTextureAsync(J,f).then((z=>{z&&(U.normalTexture=z,1!==J.level&&(U.normalTexture.scale=J.level))})));const v=u._ambientTexture;v&&z.push(this.exportTextureAsync(v,f).then((z=>{if(z){const J={index:z.index,texCoord:z.texCoord,extensions:z.extensions};U.occlusionTexture=J;const v=u._ambientTextureStrength;v&&(J.strength=v)}})));const g=u._emissiveTexture;g&&z.push(this.exportTextureAsync(g,f).then((z=>{z&&(U.emissiveTexture=z)}))),z.length>0&&(this._exporter._materialNeedsUVsSet.add(u),await Promise.all(z))}const w=u._emissiveColor;w.equalsWithEpsilon(p,x)||(U.emissiveFactor=w.jf()),U.pbrMetallicRoughness=J}_getPixelsFromTextureAsync(z){return function(z){switch(z){case L.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case L.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case L.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case L.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case L.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case L.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case L.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case L.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case L.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case L.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case L.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case L.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case L.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case L.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case L.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case L.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case L.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case L.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case L.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case L.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case L.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(z.textureFormat)?(0,h.j)(z,z._texture.width,z._texture.height):(z.textureType,L.d.TEXTURETYPE_UNSIGNED_BYTE,z.readPixels())}async exportTextureAsync(z,u){const U=this._exporter._extensionsPreExportTextureAsync("exporter",z,u);return U?await U.then((async U=>U?await this._exportTextureInfoAsync(U,u):await this._exportTextureInfoAsync(z,u))):await this._exportTextureInfoAsync(z,u)}async _exportTextureInfoAsync(z,u){let U=this._textureMap.get(z);if(!U){const J=await this._getPixelsFromTextureAsync(z);if(!J)return null;const f=this._exportTextureSampler(z),g=z.mimeType;if(g)switch(g){case"image/jpeg":case"image/png":case"image/webp":u=g;break;default:v.Tools.Warn("Unsupported media type: ".concat(g,". Exporting texture as PNG."))}const w=this._internalTextureToImage,P=z.getInternalTexture().uniqueId;w[P]||(w[P]={});let R=w[P][u];if(void 0===R){const U=z.getSize();R=(async()=>{const v=await this._getImageDataAsync(J,U.width,U.height,u);return this._exportImage(z.name,u,v)})(),w[P][u]=R}U=this._exportTextureInfo(await R,f,z.coordinatesIndex),this._textureMap.set(z,U),this._exporter._extensionsPostExportTextures("exporter",U,z)}return U}_exportImage(z,u,U){const J=this._exporter._images;let f;if(this._exporter._shouldUseGlb){f={name:z,mimeType:u,bufferView:void 0};const J=this._exporter._bufferManager.createBufferView(new Uint8Array(U));this._exporter._bufferManager.setBufferView(f,J)}else{const g=z.replace(/\.\/|\/|\.\\|\\/g,"_"),w=function(z){switch(z){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(u);let P=g+w;J.some((z=>z.uri===P))&&(P="".concat(g,"_").concat(v.Tools.RandomId()).concat(w)),f={name:z,uri:P},this._exporter._imageData[P]={data:U,mimeType:u}}return J.push(f),J.length-1}_exportTextureInfo(z,u,U){const J=this._exporter._textures;let v=J.findIndex((U=>U.sampler==u&&U.source===z));-1===v&&(v=J.length,J.push({source:z,sampler:u}));const f={index:v};return U&&(f.texCoord=U),f}_exportTextureSampler(z){const u=this._getTextureSampler(z),U=this._exporter._samplers,J=U.findIndex((z=>z.minFilter===u.minFilter&&z.magFilter===u.magFilter&&z.wrapS===u.wrapS&&z.wrapT===u.wrapT));return-1!==J?J:(U.push(u),U.length-1)}}var F=U(13004),b=U(12760),k=U(13364),B=U(12917);const y=J.Eu.Zero(),H=J.Quaternion.Identity(),G=J.Eu.One(),a=new J.Eu(-1,1,1);function i(z,u){const{byteOffset:U,byteStride:J,type:v,normalized:f}=z,g=z.getSize(),w=u.reduce(((z,u)=>u.getTotalVertices()>z?u.getTotalVertices():z),-Number.MAX_VALUE);return{byteOffset:U,byteStride:J,componentCount:g,type:v,count:w*g,normalized:f,totalVertices:w,kind:z.getKind()}}function n(z){switch(z){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function q(z){switch(z){case d.g.PositionKind:case d.g.NormalKind:case d.g.TangentKind:case d.g.ColorKind:case d.g.MatricesIndicesKind:case d.g.MatricesIndicesExtraKind:case d.g.MatricesWeightsKind:case d.g.MatricesWeightsExtraKind:case d.g.UVKind:case d.g.UV2Kind:case d.g.UV3Kind:case d.g.UV4Kind:case d.g.UV5Kind:case d.g.UV6Kind:return!0}return!1}function o(z){switch(z){case f.e.TriangleFillMode:return 4;case f.e.TriangleStripDrawMode:return 5;case f.e.TriangleFanDrawMode:return 6;case f.e.PointListDrawMode:case f.e.PointFillMode:return 0;case f.e.LineLoopDrawMode:return 2;case f.e.LineListDrawMode:return 1;case f.e.LineStripDrawMode:return 3}throw new Error("Unknown fill mode: ".concat(z))}function s(z){const u=Math.sqrt(z.x*z.x+z.y*z.y+z.z*z.z);u>0&&(z.x/=u,z.y/=u,z.z/=u)}function l(z){return z.x*=-1,z}function e(z){if(z.x*z.x+z.y*z.y>.5){const u=Math.abs(z.x),U=Math.abs(z.y);if(u>U){const U=Math.sign(z.x);z.x=u,z.y*=-U,z.z*=-U,z.w*=U}else{const u=Math.sign(z.y);z.x*=-u,z.y=U,z.z*=u,z.w*=-u}}else{const u=Math.abs(z.z),U=Math.abs(z.w);if(u>U){const U=Math.sign(z.z);z.x*=-U,z.y*=U,z.z=u,z.w*=-U}else{const u=Math.sign(z.w);z.x*=u,z.y*=-u,z.z*=-u,z.w=U}}return z}function zz(z){z.zg(-z.z,z.w,z.x,-z.y)}function uz(z,u){const U=J.Eu.FromArrayToRef(u.translation||[0,0,0],0,J.TmpVectors.Eu[0]),v=J.Quaternion.FromArrayToRef(u.rotation||[0,0,0,1],0,J.TmpVectors.Quaternion[0]),f=J.Matrix.ComposeToRef(G,v,U,J.TmpVectors.Matrix[0]),g=J.Eu.FromArrayToRef(z.translation||[0,0,0],0,J.TmpVectors.Eu[2]),w=J.Quaternion.FromArrayToRef(z.rotation||[0,0,0,1],0,J.TmpVectors.Quaternion[1]),P=J.Matrix.ComposeToRef(G,w,g,J.TmpVectors.Matrix[1]);f.multiplyToRef(P,P),P.decompose(void 0,v,U),U.equalsWithEpsilon(y,B.d)?delete u.translation:u.translation=U.jf(),v.equalsWithEpsilon(H,B.d)?delete u.rotation:u.rotation=v.jf(),u.scale&&delete u.scale}function Uz(z,u){if(!(u instanceof mz.c))return!1;if(!(1===u.getChildren().length&&0===z.getChildren().length&&z.parent===u))return!1;const U=z.Vz(),J=z instanceof k.d&&!U.useRightHandedSystem?a:G;return!!u.Ug.equalsWithEpsilon(J,B.d)||(b.d.Warn("Cannot collapse node ".concat(z.name," into parent node ").concat(u.name," with modified scaling.")),!1)}function Jz(z){if(z instanceof Array){const u=new Float32Array(z);return new Uint8Array(u.buffer,u.byteOffset,u.byteLength)}return ArrayBuffer.isView(z)?new Uint8Array(z.buffer,z.byteOffset,z.byteLength):new Uint8Array(z)}function vz(z,u){for(const[U,J]of Object.entries(z)){const v=u[U];(Array.isArray(J)&&Array.isArray(v)&&fz(J,v)||J===v)&&delete z[U]}return z}function fz(z,u){return z.length===u.length&&z.every(((z,U)=>z===u[U]))}const gz=J.Matrix.Compose(new J.Eu(-1,1,1),J.Quaternion.Identity(),J.Eu.Zero());function wz(z,u){if(!(z instanceof mz.c))return!1;if(u){if(!z.getWorldMatrix().equalsWithEpsilon(J.Matrix.IdentityReadOnly,B.d))return!1}else{if(!z.getWorldMatrix().multiplyToRef(gz,J.TmpVectors.Matrix[0]).equalsWithEpsilon(J.Matrix.IdentityReadOnly,B.d))return!1}return!(z instanceof Z.d&&z.nf)}const Pz=new Map([[Int8Array,(z,u,U)=>z.setInt8(u,U)],[Uint8Array,(z,u,U)=>z.setUint8(u,U)],[Uint8ClampedArray,(z,u,U)=>z.setUint8(u,U)],[Int16Array,(z,u,U)=>z.setInt16(u,U,!0)],[Uint16Array,(z,u,U)=>z.setUint16(u,U,!0)],[Int32Array,(z,u,U)=>z.setInt32(u,U,!0)],[Uint32Array,(z,u,U)=>z.setUint32(u,U,!0)],[Float32Array,(z,u,U)=>z.setFloat32(u,U,!0)],[Float64Array,(z,u,U)=>z.setFloat64(u,U,!0)]]);class Rz{writeTypedArray(z){this._checkGrowBuffer(z.byteLength);const u=Pz.get(z.constructor);for(let U=0;U<z.length;U++)u(this._dataView,this._byteOffset,z[U]),this._byteOffset+=z.BYTES_PER_ELEMENT}constructor(z){this._data=new Uint8Array(z),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(z){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,z),this._byteOffset++}writeInt8(z){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,z),this._byteOffset++}writeInt16(z){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,z,!0),this._byteOffset+=2}writeUInt16(z){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,z,!0),this._byteOffset+=2}writeInt32(z){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,z,!0),this._byteOffset+=4}writeUInt32(z){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,z,!0),this._byteOffset+=4}writeFloat32(z){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,z,!0),this._byteOffset+=4}writeFloat64(z){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,z,!0),this._byteOffset+=8}_checkGrowBuffer(z){const u=this.byteOffset+z;if(u>this._data.byteLength){const z=new Uint8Array(2*u);z.set(this._data),this._data=z,this._dataView=new DataView(this._data.buffer)}}}function Sz(z){return z%4===0?4:z%2===0?2:1}class dz{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(z){let u=0;this._bufferViewToData.forEach((z=>{u+=z.byteLength}));const U=new Rz(u),J=Array.from(this._bufferViewToData.keys()).sort(((z,u)=>Sz(u.byteLength)-Sz(z.byteLength)));for(const v of J){v.byteOffset=U.byteOffset,z.push(v);const u=z.length-1,J=this.getPropertiesWithBufferView(v);for(const z of J)z.bufferView=u;U.writeTypedArray(this._bufferViewToData.get(v)),this._bufferViewToData.delete(v)}return U.getOutputData()}createBufferView(z,u){const U={buffer:0,byteOffset:void 0,byteLength:z.byteLength,byteStride:u};return this._bufferViewToData.set(U,z),U}createAccessor(z,u,U,J,v,f,g){this._verifyBufferView(z);const w={bufferView:void 0,componentType:U,count:J,type:u,min:null===f||void 0===f?void 0:f.min,max:null===f||void 0===f?void 0:f.max,normalized:g,byteOffset:v};return this.setBufferView(w,z),this._accessorToBufferView.set(w,z),w}setBufferView(z,u){this._verifyBufferView(u);this.getPropertiesWithBufferView(u).push(z)}removeBufferView(z){const u=this.getPropertiesWithBufferView(z);for(const U of u)void 0!==U.bufferView&&delete U.bufferView;this._bufferViewToData.delete(z),this._bufferViewToProperties.delete(z),this._accessorToBufferView.forEach(((u,U)=>{u===z&&(void 0!==U.byteOffset&&delete U.byteOffset,this._accessorToBufferView.delete(U))}))}getBufferView(z){const u=this._accessorToBufferView.get(z);return this._verifyBufferView(u),u}getPropertiesWithBufferView(z){var u;return this._verifyBufferView(z),this._bufferViewToProperties.set(z,null!==(u=this._bufferViewToProperties.get(z))&&void 0!==u?u:[]),this._bufferViewToProperties.get(z)}getData(z){return this._verifyBufferView(z),this._bufferViewToData.get(z)}_verifyBufferView(z){if(void 0===z||!this._bufferViewToData.has(z))throw new Error("BufferView ".concat(z," not found in BufferManager."))}}var mu,Zz=U(13338),Az=U(13348),Ez=U(13369),Cz=U(13271),rz=U(13406),Mz=U(13419),Tz=U(13335),Xz=U(13428);!function(z){z[z.INTANGENT=0]="INTANGENT",z[z.OUTTANGENT=1]="OUTTANGENT"}(mu||(mu={}));class hz{static _IsTransformable(z){return z&&(z instanceof mz.c||z instanceof Zz.b||z instanceof Xz.c)}static _CreateNodeAnimation(z,u,U,J,f){if(this._IsTransformable(z)){const g=[],w=[],P=u.getKeys(),R=hz._CalculateMinMaxKeyFrames(P),S=hz._DeduceInterpolation(P,U,J),d=S.interpolationType,mz=S.shouldBakeAnimation;if(mz?hz._CreateBakedAnimation(z,u,U,R.min,R.max,u.framePerSecond,f,g,w,R,J):"LINEAR"===d||"STEP"===d?hz._CreateLinearOrStepAnimation(z,u,U,g,w,J):"CUBICSPLINE"===d?hz._CreateCubicSplineAnimation(z,u,U,g,w,J):hz._CreateBakedAnimation(z,u,U,R.min,R.max,u.framePerSecond,f,g,w,R,J),g.length&&w.length){return{inputs:g,outputs:w,samplerInterpolation:d,inputsMin:mz?R.min:v.Tools.FloatRound(R.min/u.framePerSecond),inputsMax:mz?R.max:v.Tools.FloatRound(R.max/u.framePerSecond)}}}return null}static _DeduceAnimationInfo(z){let u=null,U="VEC3",J=!1;const f=z.targetProperty.split(".");switch(f[0]){case"Ug":u="scale";break;case"position":u="translation";break;case"rotation":U="VEC4",u="rotation";break;case"rotationQuaternion":U="VEC4",J=!0,u="rotation";break;case"influence":U="SCALAR",u="weights";break;default:v.Tools.Error("Unsupported animatable property ".concat(f[0]))}return u?{animationChannelTargetPath:u,dataAccessorType:U,useQuaternion:J}:(v.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(z,u,U,J,v,f,g,w,P,R,S){let d;if(hz._IsTransformable(z)&&z.animations)for(const mz of z.animations){if(S&&!S(mz))continue;const v=hz._DeduceAnimationInfo(mz);v&&(d={name:mz.name,samplers:[],channels:[]},hz._AddAnimation("".concat(mz.name),mz.hasRunningRuntimeAnimations?u:d,z,mz,v.dataAccessorType,v.animationChannelTargetPath,J,f,g,w,v.useQuaternion,P,R),d.samplers.length&&d.channels.length&&U.push(d))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(z,u,U,J,v,f,g,w,P,R,S){let d;if(z instanceof Tz.e){const v=z.morphTargetManager;if(v)for(let mz=0;mz<v.numTargets;++mz){const Z=v.getTarget(mz);for(const A of Z.animations){if(S&&!S(A))continue;const Z=new rz.b("".concat(A.name),"influence",A.framePerSecond,A.dataType,A.loopMode,A.enableBlending),E=[],C=A.getKeys();for(let z=0;z<C.length;++z){const u=C[z];for(let z=0;z<v.numTargets;++z)z==mz?E.push(u):E.push({frame:u.frame,value:0})}Z.setKeys(E);const r=hz._DeduceAnimationInfo(Z);r&&(d={name:Z.name,samplers:[],channels:[]},hz._AddAnimation(A.name,A.hasRunningRuntimeAnimations?u:d,z,Z,r.dataAccessorType,r.animationChannelTargetPath,J,f,g,w,r.useQuaternion,P,R,v.numTargets),d.samplers.length&&d.channels.length&&U.push(d))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(z,u,U,J,v,f,g,w,P){let R;if(z.animationGroups){const d=z.animationGroups;for(const mz of d){const d=new Map,Z=new Map,A=new Set,E=mz.to-mz.from;R={name:mz.name,channels:[],samplers:[]};for(let u=0;u<mz.targetedAnimations.length;++u){const E=mz.targetedAnimations[u],C=E.target,r=E.animation;if(P&&!P(r))continue;const M=w.has(C);if(this._IsTransformable(C)||1===C.length&&this._IsTransformable(C[0])){const z=hz._DeduceAnimationInfo(E.animation);if(z){const u=this._IsTransformable(C)?C:this._IsTransformable(C[0])?C[0]:null;u&&hz._AddAnimation("".concat(r.name),R,u,r,z.dataAccessorType,z.animationChannelTargetPath,U,J,v,f,z.useQuaternion,g,M)}}else if(C instanceof Mz.e||1===C.length&&C[0]instanceof Mz.e){if(hz._DeduceAnimationInfo(E.animation)){const u=C instanceof Mz.e?C:C[0];if(u){const U=z.morphTargetManagers.find((z=>{for(let U=0;U<z.numTargets;++U)if(z.getTarget(U)===u)return!0;return!1}));if(U){const J=z.meshes.find((z=>z.morphTargetManager===U));var S;if(J)d.has(J)||d.set(J,new Map),null===(S=d.get(J))||void 0===S||S.set(u,r),A.add(J),Z.set(J,r)}}}}}A.forEach((z=>{const u=z.morphTargetManager;let w=null;const P=[],S=Z.get(z).getKeys(),A=S.length;for(let U=0;U<A;++U)for(let J=0;J<u.numTargets;++J){const v=u.getTarget(J),f=d.get(z);if(f){const u=f.get(v);u?(w||(w=new rz.b("".concat(mz.name,"_").concat(z.name,"_MorphWeightAnimation"),"influence",u.framePerSecond,rz.b.ANIMATIONTYPE_FLOAT,u.loopMode,u.enableBlending)),P.push(u.getKeys()[U])):P.push({frame:mz.from+E/A*U,value:v.influence,inTangent:S[0].inTangent?0:void 0,outTangent:S[0].outTangent?0:void 0})}}w.setKeys(P);const C=hz._DeduceAnimationInfo(w);C&&hz._AddAnimation("".concat(mz.name,"_").concat(z.name,"_MorphWeightAnimation"),R,z,w,C.dataAccessorType,C.animationChannelTargetPath,U,J,v,f,C.useQuaternion,g,!1,null===u||void 0===u?void 0:u.numTargets)})),R.channels.length&&R.samplers.length&&u.push(R)}}}static _AddAnimation(z,u,U,v,f,g,w,P,R,S,d,mz,Z,A){const E=hz._CreateNodeAnimation(U,v,g,d,mz);let C,r,M,T,X,h;if(E){if(A){let z=0,u=0;const U=[];for(;E.inputs.length>0;)u=E.inputs.shift(),z%A==0&&U.push(u),z++;E.inputs=U}const z=w.get(U),v=new Float32Array(E.inputs);C=P.createBufferView(v),r=P.createAccessor(C,"SCALAR",5126,E.inputs.length,void 0,{min:[E.inputsMin],max:[E.inputsMax]}),S.push(r),M=S.length-1;const R=new J.Quaternion,d=new J.Eu,mz=new J.Eu,t=U instanceof Zz.b,V=n(f),L=new Float32Array(E.outputs.length*V);E.outputs.forEach((function(z,u){let U=z;switch(g){case"translation":Z&&(J.Eu.FromArrayToRef(z,0,mz),l(mz),mz.toArray(U));break;case"rotation":4===z.length?J.Quaternion.FromArrayToRef(z,0,R):(U=new Array(4),J.Eu.FromArrayToRef(z,0,d),J.Quaternion.FromEulerVectorToRef(d,R)),Z&&(e(R),t&&zz(R)),R.toArray(U)}L.set(U,u*V)})),C=P.createBufferView(L),r=P.createAccessor(C,f,5126,E.outputs.length),S.push(r),T=S.length-1,X={interpolation:E.samplerInterpolation,input:M,output:T},u.samplers.push(X),h={sampler:u.samplers.length-1,target:{node:z,path:g}},u.channels.push(h)}}static _CreateBakedAnimation(z,u,U,f,g,w,P,R,S,d,mz){let Z;const A=J.Quaternion.Identity();let E,C=null,r=null,M=null,T=null,X=null,h=null;d.min=v.Tools.FloatRound(f/w);const t=u.getKeys();for(let J=0,V=t.length;J<V;++J){if(h=null,M=t[J],J+1<V)if(T=t[J+1],M.value.equals&&M.value.equals(T.value)||M.value===T.value){if(0!==J)continue;h=M.frame}else h=T.frame;else{if(X=t[J-1],M.value.equals&&M.value.equals(X.value)||M.value===X.value)continue;h=g}if(h)for(let J=M.frame;J<=h;J+=P){if(E=v.Tools.FloatRound(J/w),E===C)continue;C=E,r=E;const f={key:0,repeatCount:0,loopMode:u.loopMode};Z=u._interpolate(J,f),hz._SetInterpolatedValue(z,Z,E,u,U,A,R,S,mz)}}r&&(d.max=r)}static _ConvertFactorToVector3OrQuaternion(z,u,U,f,g){const w=hz._GetBasePositionRotationOrScale(u,f,g),P=U.targetProperty.split("."),R=P?P[1]:"",S=g?J.Quaternion.Xu(w).normalize():J.Eu.Xu(w);switch(R){case"x":case"y":case"z":S[R]=z;break;case"w":S.w=z;break;default:v.Tools.Error('glTFAnimation: Unsupported component name "'.concat(R,'"!'))}return S}static _SetInterpolatedValue(z,u,U,v,f,g,w,P,R){let S;w.push(U),"weights"!==f?(v.dataType===rz.b.ANIMATIONTYPE_FLOAT&&(u=this._ConvertFactorToVector3OrQuaternion(u,z,v,f,R)),"rotation"===f?(R?g=u:(S=u,J.Quaternion.RotationYawPitchRollToRef(S.y,S.x,S.z,g)),P.push(g.jf())):(S=u,P.push(S.jf()))):P.push([u])}static _CreateLinearOrStepAnimation(z,u,U,J,v,f){for(const g of u.getKeys())J.push(g.frame/u.framePerSecond),hz._AddKeyframeValue(g,u,v,U,z,f)}static _CreateCubicSplineAnimation(z,u,U,J,v,f){u.getKeys().forEach((function(g){J.push(g.frame/u.framePerSecond),hz._AddSplineTangent(mu.INTANGENT,v,U,"CUBICSPLINE",g,f),hz._AddKeyframeValue(g,u,v,U,z,f),hz._AddSplineTangent(mu.OUTTANGENT,v,U,"CUBICSPLINE",g,f)}))}static _GetBasePositionRotationOrScale(z,u,U){let v;if("rotation"===u)if(U){const u=z.rotationQuaternion;v=(null!==u&&void 0!==u?u:J.Quaternion.Identity()).jf()}else{const u=z.rotation;v=(null!==u&&void 0!==u?u:J.Eu.Zero()).jf()}else if("translation"===u){const u=z.position;v=(null!==u&&void 0!==u?u:J.Eu.Zero()).jf()}else{const u=z.Ug;v=(null!==u&&void 0!==u?u:J.Eu.One()).jf()}return v}static _AddKeyframeValue(z,u,U,f,g,w){let P;const R=u.dataType;if(R===rz.b.ANIMATIONTYPE_VECTOR3){let u=z.value.jf();if("rotation"===f){const z=J.Eu.Xu(u);u=J.Quaternion.RotationYawPitchRoll(z.y,z.x,z.z).jf()}U.push(u)}else if(R===rz.b.ANIMATIONTYPE_FLOAT){if("weights"===f)U.push([z.value]);else if(P=this._ConvertFactorToVector3OrQuaternion(z.value,g,u,f,w),P){if("rotation"===f){const z=w?P:J.Quaternion.RotationYawPitchRoll(P.y,P.x,P.z).normalize();U.push(z.jf())}U.push(P.jf())}}else R===rz.b.ANIMATIONTYPE_QUATERNION?U.push(z.value.normalize().jf()):v.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(z,u,U){let J,v,f=!1;if("rotation"===u&&!U)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let g=0,w=z.length;g<w;++g)if(v=z[g],v.inTangent||v.outTangent)if(J){if("CUBICSPLINE"!==J){J="LINEAR",f=!0;break}}else J="CUBICSPLINE";else if(J){if("CUBICSPLINE"===J||v.interpolation&&1===v.interpolation&&"STEP"!==J){J="LINEAR",f=!0;break}}else J=v.interpolation&&1===v.interpolation?"STEP":"LINEAR";return J||(J="LINEAR"),{interpolationType:J,shouldBakeAnimation:f}}static _AddSplineTangent(z,u,U,v,f,g){let w;const P=z===mu.INTANGENT?f.inTangent:f.outTangent;if("CUBICSPLINE"===v){if("rotation"===U)if(P)if(g)w=P.jf();else{const z=P;w=J.Quaternion.RotationYawPitchRoll(z.y,z.x,z.z).jf()}else w=[0,0,0,0];else w="weights"===U?P?[P]:[0]:P?P.jf():[0,0,0];u.push(w)}}static _CalculateMinMaxKeyFrames(z){let u=1/0,U=-1/0;return z.forEach((function(z){u=Math.min(u,z.frame),U=Math.max(U,z.frame)})),{min:u,max:U}}}function tz(z,u,U,f,g,w){const P={attributes:{},influence:z.influence,name:z.name},R=u.nf;if(!R)return v.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),P;const S=w?-1:1,mz=J.Eu.Zero();let Z=0,A=0;if(z.hasPositions){const f=z.getPositions(),w=R.getVerticesData(d.g.PositionKind);if(w){const z=new Float32Array(w.length),u=[1/0,1/0,1/0],v=[-1/0,-1/0,-1/0];A=w.length/3,Z=0;for(let U=Z;U<A;++U){const g=J.Eu.Xu(w,3*U);J.Eu.Xu(f,3*U).subtractToRef(g,mz),mz.x*=S,u[0]=Math.min(u[0],mz.x),v[0]=Math.max(v[0],mz.x),u[1]=Math.min(u[1],mz.y),v[1]=Math.max(v[1],mz.y),u[2]=Math.min(u[2],mz.z),v[2]=Math.max(v[2],mz.z),z[3*U]=mz.x,z[3*U+1]=mz.y,z[3*U+2]=mz.z}const R=U.createBufferView(z,12),d=U.createAccessor(R,"VEC3",5126,f.length/3,0,{min:u,max:v});g.push(d),P.attributes.POSITION=g.length-1}else v.Tools.Warn("Morph target positions for mesh ".concat(u.name," were not exported. Mesh does not have position vertex data"))}if(z.hasNormals){const f=z.getNormals(),w=R.getVerticesData(d.g.NormalKind);if(w){const z=new Float32Array(w.length);A=w.length/3,Z=0;for(let U=Z;U<A;++U){const u=J.Eu.Xu(w,3*U).normalize();J.Eu.Xu(f,3*U).normalize().subtractToRef(u,mz),z[3*U]=mz.x*S,z[3*U+1]=mz.y,z[3*U+2]=mz.z}const u=U.createBufferView(z,12),v=U.createAccessor(u,"VEC3",5126,f.length/3,0);g.push(v),P.attributes.NORMAL=g.length-1}else v.Tools.Warn("Morph target normals for mesh ".concat(u.name," were not exported. Mesh does not have normals vertex data"))}if(z.hasTangents){const f=z.getTangents(),w=R.getVerticesData(d.g.TangentKind);if(w){A=w.length/4;const z=new Float32Array(3*A);Z=0;for(let U=Z;U<A;++U){const u=J.Eu.Xu(w,4*U);s(u);const v=J.Eu.Xu(f,3*U);s(v),v.subtractToRef(u,mz),z[3*U]=mz.x*S,z[3*U+1]=mz.y,z[3*U+2]=mz.z}const u=U.createBufferView(z,12),v=U.createAccessor(u,"VEC3",5126,A,0);g.push(v),P.attributes.TANGENT=g.length-1}else v.Tools.Warn("Morph target tangents for mesh ".concat(u.name," were not exported. Mesh does not have tangents vertex data"))}if(z.hasColors){const f=z.getColors(),w=R.getVerticesData(d.g.ColorKind),S=R.getVertexBuffer(d.g.ColorKind);if(w&&S){const z=S.getSize();A=w.length/z;const u=new Float32Array(A*z);Z=0;for(let U=Z;U<A;++U)if(3===z){const v=J.Eu.Xu(w,U*z);J.Eu.Xu(f,U*z).subtractToRef(v,mz),u[3*U]=mz.x,u[3*U+1]=mz.y,u[3*U+2]=mz.z}else if(4===z){const v=new J.Vector4,g=J.Vector4.Xu(w,U*z);J.Vector4.Xu(f,U*z).subtractToRef(g,v),u[4*U]=v.x,u[4*U+1]=v.y,u[4*U+2]=v.z,u[4*U+3]=v.w}else v.Tools.Warn("Unsupported number of components for color attribute: ".concat(z));const R=U.createBufferView(u,4*z),d=U.createAccessor(R,3===z?"VEC3":"VEC4",5126,A,0);g.push(d),P.attributes.COLOR_0=g.length-1}else v.Tools.Warn("Morph target colors for mesh ".concat(u.name," were not exported. Mesh does not have colors vertex data"))}return P}var Vz=U(13431),Lz=U(13300),Oz=U(13283),xz=U(12875);class Qz{}Qz.DEFAULT_COLOR=r.Tu.White(),Qz.DEFAULT_WIDTH_ATTENUATED=1,Qz.DEFAULT_WIDTH=.1;var Kz=U(13132),Yz=U(13433);class pz{static ConvertPoints(z,u){if(z.length&&Array.isArray(z)&&"number"===typeof z[0])return[z];if(z.length&&Array.isArray(z[0])&&"number"===typeof z[0][0])return z;if(z.length&&!Array.isArray(z[0])&&z[0]instanceof J.Eu){const u=[];for(let U=0;U<z.length;U++){const J=z[U];u.push(J.x,J.y,J.z)}return[u]}if(z.length>0&&Array.isArray(z[0])&&z[0].length>0&&z[0][0]instanceof J.Eu){const u=[],U=z;for(const z of U)u.push(z.flatMap((z=>[z.x,z.y,z.z])));return u}if(z instanceof Float32Array){if(null!==u&&void 0!==u&&u.floatArrayStride){const U=[],J=3*u.floatArrayStride;for(let u=0;u<z.length;u+=J){const v=new Array(J);for(let U=0;U<J;U++)v[U]=z[u+U];U.push(v)}return U}return[Array.from(z)]}if(z.length&&z[0]instanceof Float32Array){const u=[];for(const U of z)u.push(Array.from(U));return u}return[]}static OmitZeroLengthPredicate(z,u,U){const J=[];return u.Cu(z).lengthSquared()>0&&J.push([z,u]),U.Cu(u).lengthSquared()>0&&J.push([u,U]),z.Cu(U).lengthSquared()>0&&J.push([U,z]),0===J.length?null:J}static OmitDuplicatesPredicate(z,u,U,J){const v=[];return pz._SearchInPoints(z,u,J)||v.push([z,u]),pz._SearchInPoints(u,U,J)||v.push([u,U]),pz._SearchInPoints(U,z,J)||v.push([U,z]),0===v.length?null:v}static _SearchInPoints(z,u,U){for(const g of U)for(let U=0;U<g.length;U++){var J,v,f;if(null!==(J=g[U])&&void 0!==J&&J.equals(z))if(null!==(v=g[U+1])&&void 0!==v&&v.equals(u)||null!==(f=g[U-1])&&void 0!==f&&f.equals(u))return!0}return!1}static MeshesToLines(z,u){const U=[];for(let v=0;v<z.length;v++){const f=z[v],g=f.getVerticesData(d.g.PositionKind),w=f.lf();if(g&&w)for(let z=0,P=0;z<w.length;z++){const R=3*w[P++],S=3*w[P++],d=3*w[P++],mz=new J.Eu(g[R],g[R+1],g[R+2]),Z=new J.Eu(g[S],g[S+1],g[S+2]),A=new J.Eu(g[d],g[d+1],g[d+2]);if(u){const J=u(mz,Z,A,U,z,R,f,v,g,w);if(J)for(const z of J)U.push(z)}else U.push([mz,Z],[Z,A],[A,mz])}}return U}static ToVector3Array(z){if(Array.isArray(z[0])){const u=[],U=z;for(const z of U){const U=[];for(let u=0;u<z.length;u+=3)U.push(new J.Eu(z[u],z[u+1],z[u+2]));u.push(U)}return u}const u=z,U=[];for(let v=0;v<u.length;v+=3)U.push(new J.Eu(u[v],u[v+1],u[v+2]));return U}static ToNumberArray(z){return z.flatMap((z=>[z.x,z.y,z.z]))}static GetPointsCountInfo(z){const u=new Array(z.length);let U=0;for(let J=z.length;J--;)u[J]=z[J].length/3,U+=u[J];return{total:U,counts:u}}static GetLineLength(z){if(0===z.length)return 0;let u;u="number"===typeof z[0]?pz.ToVector3Array(z):z;const U=J.TmpVectors.Eu[0];let v=0;for(let J=0;J<u.length-1;J++){const z=u[J];v+=u[J+1].subtractToRef(z,U).length()}return v}static GetLineLengthArray(z){const u=new Float32Array(z.length/3);let U=0;for(let J=0,v=z.length/3-1;J<v;J++){let v=z[3*J+0],f=z[3*J+1],g=z[3*J+2];v-=z[3*J+3],f-=z[3*J+4],g-=z[3*J+5];U+=Math.sqrt(v*v+f*f+g*g),u[J+1]=U}return u}static SegmentizeSegmentByCount(z,u,U){const v=[],f=u.Cu(z),g=J.TmpVectors.Eu[0];g.fg(U);const w=J.TmpVectors.Eu[1];f.divideToRef(g,w);let P=z.clone();v.push(P);for(let J=0;J<U;J++)P=P.clone(),v.push(P.addInPlace(w));return v}static SegmentizeLineBySegmentLength(z,u){const U=z[0]instanceof J.Eu?pz.GetLineSegments(z):"number"===typeof z[0]?pz.GetLineSegments(pz.ToVector3Array(z)):z,v=[];for(const J of U)if(J.length>u){const z=pz.SegmentizeSegmentByCount(J.point1,J.point2,Math.ceil(J.length/u));for(const u of z)v.push(u)}else v.push(J.point1),v.push(J.point2);return v}static SegmentizeLineBySegmentCount(z,u){const U="number"===typeof z[0]?pz.ToVector3Array(z):z,J=pz.GetLineLength(U)/u;return pz.SegmentizeLineBySegmentLength(U,J)}static GetLineSegments(z){const u=[];for(let U=0;U<z.length-1;U++){const J=z[U],v=z[U+1],f=v.Cu(J).length();u.push({point1:J,point2:v,length:f})}return u}static GetMinMaxSegmentLength(z){const u=pz.GetLineSegments(z).sort((z=>z.length));return{min:u[0].length,max:u[u.length-1].length}}static GetPositionOnLineByVisibility(z,u,U){let v=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const f=u*U;let g=0,w=0;const P=z.length;for(let J=0;J<P;J++){if(f<=g+z[J].length){w=J;break}g+=z[J].length}const R=(f-g)/z[w].length;return z[w].point2.subtractToRef(z[w].point1,J.TmpVectors.Eu[0]),J.TmpVectors.Eu[1]=J.TmpVectors.Eu[0].multiplyByFloats(R,R,R),v||J.TmpVectors.Eu[1].addInPlace(z[w].point1),J.TmpVectors.Eu[1].clone()}static GetCircleLinePoints(z,u){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z,f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/u;const g=[];for(let w=0;w<=u;w++)g.push(new J.Eu(Math.cos(w*f)*z,Math.sin(w*f)*v,U));return g}static GetBezierLinePoints(z,u,U,J){return Kz.f.CreateQuadraticBezier(z,u,U,J).getPoints().flatMap((z=>[z.x,z.y,z.z]))}static GetArrowCap(z,u,U,J,v){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[z.clone(),z.add(u.multiplyByFloats(U,U,U))],widths:[J,v,f,g]}}static GetPointsFromText(z,u,U,J){let v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,f=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const g=[],w=(0,Yz.d)(z,u,U,J);for(const P of w){for(const z of P.paths){const u=[],U=z.getPoints();for(const z of U)u.push(z.x,z.y,v);g.push(u)}if(f)for(const z of P.holes){const u=[],U=z.getPoints();for(const z of U)u.push(z.x,z.y,v);g.push(u)}}return g}static Color3toRGBAUint8(z){const u=new Uint8Array(4*z.length);for(let U=0,J=0;U<z.length;U++)u[J++]=255*z[U].r,u[J++]=255*z[U].g,u[J++]=255*z[U].b,u[J++]=255;return u}static CreateColorsTexture(z,u,U,J){var v;const f=null!==(v=J.getEngine().getCaps().maxTextureSize)&&void 0!==v?v:1,g=u.length>f?f:u.length,w=Math.ceil(u.length/f);w>1&&(u=[...u,...Array(g*w-u.length).fill(u[0])]);const P=pz.Color3toRGBAUint8(u),R=new V.b(P,g,w,E.b.TEXTUREFORMAT_RGBA,J,!1,!0,U);return R.name=z,R}static PrepareEmptyColorsTexture(z){if(!Qz.EmptyColorsTexture){const u=new Uint8Array(4);Qz.EmptyColorsTexture=new V.b(u,1,1,E.b.TEXTUREFORMAT_RGBA,z,!1,!1,V.b.NEAREST_NEAREST),Qz.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Qz.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var z;null===(z=Qz.EmptyColorsTexture)||void 0===z||z.dispose(),Qz.EmptyColorsTexture=null}static BooleanToNumber(z){return z?1:0}}class Nz extends Oz.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Dz extends Lz.e{isCompatible(z){return!0}constructor(z,u,U){var v,f,g,w,P,R,S,d,mz,Z,A,E,C,r,M,T,X;U=U||{color:Qz.DEFAULT_COLOR};const h=new Nz;var t;(h.GREASED_LINE_HAS_COLOR=!!U.color&&!U.useColors,h.GREASED_LINE_SIZE_ATTENUATION=null!==(v=U.sizeAttenuation)&&void 0!==v&&v,h.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===U.colorDistributionType,h.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(null!==u&&void 0!==u?u:z.Vz()).useRightHandedSystem,h.GREASED_LINE_CAMERA_FACING=null===(f=U.cameraFacing)||void 0===f||f,super(z,Dz.GREASED_LINE_MATERIAL_NAME,200,h,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(g=U)||void 0===g?void 0:g.forceGLSL)||Dz.ForceGLSL,this._scene=null!==u&&void 0!==u?u:z.Vz(),this._engine=this._scene.getEngine(),this._cameraFacing=null===(w=U.cameraFacing)||void 0===w||w,this.visibility=null!==(P=U.visibility)&&void 0!==P?P:1,this.useDash=null!==(R=U.useDash)&&void 0!==R&&R,this.dashRatio=null!==(S=U.dashRatio)&&void 0!==S?S:.5,this.dashOffset=null!==(d=U.dashOffset)&&void 0!==d?d:0,this.width=U.width?U.width:U.sizeAttenuation?Qz.DEFAULT_WIDTH_ATTENUATED:Qz.DEFAULT_WIDTH,this._sizeAttenuation=null!==(mz=U.sizeAttenuation)&&void 0!==mz&&mz,this.colorMode=null!==(Z=U.colorMode)&&void 0!==Z?Z:0,this._color=null!==(A=U.color)&&void 0!==A?A:null,this.useColors=null!==(E=U.useColors)&&void 0!==E&&E,this._colorsDistributionType=null!==(C=U.colorDistributionType)&&void 0!==C?C:0,this.colorsSampling=null!==(r=U.colorsSampling)&&void 0!==r?r:V.b.NEAREST_NEAREST,this._colors=null!==(M=U.Qz)&&void 0!==M?M:null,this.dashCount=null!==(T=U.dashCount)&&void 0!==T?T:1,this.resolution=null!==(X=U.resolution)&&void 0!==X?X:new J.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),U.colorsTexture)?this.colorsTexture=U.colorsTexture:this._colors?this.colorsTexture=pz.CreateColorsTexture("".concat(z.name,"-colors-texture"),this._colors,this.colorsSampling,this._scene):(this._color=null!==(t=this._color)&&void 0!==t?t:Qz.DEFAULT_COLOR,pz.PrepareEmptyColorsTexture(this._scene));this._engine.Xf.add((()=>{pz.DisposeEmptyColorsTexture()}))}getAttributes(z){z.push("grl_offsets"),z.push("grl_widths"),z.push("grl_colorPointers"),z.push("grl_counters"),this._cameraFacing?(z.push("grl_previousAndSide"),z.push("grl_nextAndCounters")):z.push("grl_slopes")}getSamplers(z){z.push("grl_colors")}getActiveTextures(z){this.colorsTexture&&z.push(this.colorsTexture)}getUniforms(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const u=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&u.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===z&&u.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:u,vertex:this._cameraFacing&&this._isGLSL(z)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(z)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(z){var u,U,v;if(this._cameraFacing){z.Gf("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||z.Gf("viewProjection",this._scene.getTransformMatrix());const u=J.TmpVectors.Vector4[0];u.x=this._aspect,u.y=this._resolution.x,u.z=this._resolution.y,u.w=this.width,z.updateVector4("grl_aspect_resolution_lineWidth",u)}const f=J.TmpVectors.Vector4[0];f.x=pz.BooleanToNumber(this.useDash),f.y=this._dashArray,f.z=this.dashOffset,f.w=this.dashRatio,z.updateVector4("grl_dashOptions",f);const g=J.TmpVectors.Vector4[1];g.x=this.colorMode,g.y=this.visibility,g.z=this.colorsTexture?this.colorsTexture.getSize().width:0,g.w=pz.BooleanToNumber(this.useColors),z.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",g),this._color&&z.updateColor3("grl_singleColor",this._color);const w=null!==(u=this.colorsTexture)&&void 0!==u?u:Qz.EmptyColorsTexture;z.setTexture("grl_colors",w),z.updateFloat2("grl_textureSize",null!==(U=null===w||void 0===w?void 0:w.getSize().width)&&void 0!==U?U:1,null!==(v=null===w||void 0===w?void 0:w.getSize().height)&&void 0!==v?v:1)}prepareDefines(z,u,U){z.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,z.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=u.useRightHandedSystem,z.GREASED_LINE_CAMERA_FACING=this._cameraFacing,z.GREASED_LINE_USE_OFFSETS=!!U.offsets}getClassName(){return Dz.GREASED_LINE_MATERIAL_NAME}getCustomCode(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(u)?function(z,u){if("vertex"===z){const z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return u&&(z["!gl_Position\\=viewProjection\\*worldPos;"]="//"),z}return"fragment"===z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ".concat(0,".) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == ",1,".) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == ",2,".) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == ",0,".) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ",1,".) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ",2,".) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                ")}:null}(z,this._cameraFacing):function(z,u){if("vertex"===z){const z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return u&&(z["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),z}return"fragment"===z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ".concat(0,".) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ",1,".) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ",2,".) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == ",0,".) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ",1,".) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ",2,".) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                ")}:null}(z,this._cameraFacing)}dispose(){var z;null===(z=this.colorsTexture)||void 0===z||z.dispose(),super.dispose()}get Qz(){return this._colors}set Qz(z){this.setColors(z)}setColors(z){var u,U;let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1],v=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const f=null!==(u=null===(U=this._colors)||void 0===U?void 0:U.length)&&void 0!==u?u:0;var g;if(this._colors=z,null!==z&&0!==z.length){if(!J||v)if(this.colorsTexture&&f===z.length&&!v){const u=pz.Color3toRGBAUint8(z);this.colorsTexture.update(u)}else{var w;null===(w=this.colorsTexture)||void 0===w||w.dispose(),this.colorsTexture=pz.CreateColorsTexture("".concat(this._material.name,"-colors-texture"),z,this.colorsSampling,this._scene)}}else null===(g=this.colorsTexture)||void 0===g||g.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(z){this._dashCount=z,this._dashArray=1/z}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(z){this._sizeAttenuation=z,this.markAllDefinesAsDirty()}get color(){return this._color}set color(z){this.setColor(z)}setColor(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==z||null!==this._color&&null===z?(this._color=z,u||this.markAllDefinesAsDirty()):this._color=z}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(z){this._colorsDistributionType=z,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(z){this._aspect=z.x/z.y,this._resolution=z}serialize(){const z=super.serialize(),u={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(u.Qz=this._colors),this._color&&(u.color=this._color),z.greasedLineMaterialOptions=u,z}parse(z,u,U){var J;super.parse(z,u,U);const v=z.greasedLineMaterialOptions;null===(J=this.colorsTexture)||void 0===J||J.dispose(),v.color&&this.setColor(v.color,!0),v.colorDistributionType&&(this.colorsDistributionType=v.colorDistributionType),v.Qz&&(this.Qz=v.Qz),v.colorsSampling&&(this.colorsSampling=v.colorsSampling),v.colorMode&&(this.colorMode=v.colorMode),v.useColors&&(this.useColors=v.useColors),v.visibility&&(this.visibility=v.visibility),v.useDash&&(this.useDash=v.useDash),v.dashCount&&(this.dashCount=v.dashCount),v.dashRatio&&(this.dashRatio=v.dashRatio),v.dashOffset&&(this.dashOffset=v.dashOffset),v.width&&(this.width=v.width),v.sizeAttenuation&&(this.sizeAttenuation=v.sizeAttenuation),v.resolution&&(this.resolution=v.resolution),this.Qz?this.colorsTexture=pz.CreateColorsTexture("".concat(this._material.name,"-colors-texture"),this.Qz,this.colorsSampling,u):pz.PrepareEmptyColorsTexture(u),this.markAllDefinesAsDirty()}copyTo(z){var u;const U=z;null===(u=U.colorsTexture)||void 0===u||u.dispose(),this._colors&&(U.colorsTexture=pz.CreateColorsTexture("".concat(U._material.name,"-colors-texture"),this._colors,U.colorsSampling,this._scene)),U.setColor(this.color,!0),U.colorsDistributionType=this.colorsDistributionType,U.colorsSampling=this.colorsSampling,U.colorMode=this.colorMode,U.useColors=this.useColors,U.visibility=this.visibility,U.useDash=this.useDash,U.dashCount=this.dashCount,U.dashRatio=this.dashRatio,U.dashOffset=this.dashOffset,U.width=this.width,U.sizeAttenuation=this.sizeAttenuation,U.resolution=this.resolution,U.markAllDefinesAsDirty()}_isGLSL(z){return 0===z||this._forceGLSL}}Dz.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Dz.ForceGLSL=!1,(0,xz.f)("BABYLON.".concat(Dz.GREASED_LINE_MATERIAL_NAME),Dz);var cz=U(13322),Wz=U(12768),jz=U(13153),Iz=U(12859);class Fz extends jz.ShaderMaterial{constructor(z,u,v){var f,g,w,P,R,S,d,mz,Z,A,E,C,M,T;const X=u.getEngine(),h=X.isWebGPU&&!(v.forceGLSL||Fz.ForceGLSL),t=["COLOR_DISTRIBUTION_TYPE_LINE ".concat(1,"."),"COLOR_DISTRIBUTION_TYPE_SEGMENT ".concat(0,"."),"COLOR_MODE_SET ".concat(0,"."),"COLOR_MODE_ADD ".concat(1,"."),"COLOR_MODE_MULTIPLY ".concat(2,".")];u.useRightHandedSystem&&t.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const L=["position","grl_widths","grl_offsets","grl_colorPointers"];v.cameraFacing?(t.push("GREASED_LINE_CAMERA_FACING"),L.push("grl_previousAndSide","grl_nextAndCounters")):(L.push("grl_slopes"),L.push("grl_counters"));const O=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];var x;(h||O.push("world","viewProjection","view","projection"),super(z,u,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:h?["Scene","Mesh"]:void 0,attributes:L,uniforms:O,samplers:h?[]:["grlColors"],defines:t,extraInitializationsAsync:async()=>{h?await Promise.all([U.e(66).then(U.bind(U,15628)),U.e(75).then(U.bind(U,15630))]):await Promise.all([U.e(69).then(U.bind(U,15638)),U.e(76).then(U.bind(U,15645))])},shaderLanguage:h?1:0}),this._color=r.Tu.White(),this._colorsDistributionType=0,this._colorsTexture=null,v=v||{color:Qz.DEFAULT_COLOR},this.visibility=null!==(f=v.visibility)&&void 0!==f?f:1,this.useDash=null!==(g=v.useDash)&&void 0!==g&&g,this.dashRatio=null!==(w=v.dashRatio)&&void 0!==w?w:.5,this.dashOffset=null!==(P=v.dashOffset)&&void 0!==P?P:0,this.dashCount=null!==(R=v.dashCount)&&void 0!==R?R:1,this.width=v.width?v.width:v.sizeAttenuation&&v.cameraFacing?Qz.DEFAULT_WIDTH_ATTENUATED:Qz.DEFAULT_WIDTH,this.sizeAttenuation=null!==(S=v.sizeAttenuation)&&void 0!==S&&S,this.color=null!==(d=v.color)&&void 0!==d?d:r.Tu.White(),this.useColors=null!==(mz=v.useColors)&&void 0!==mz&&mz,this.colorsDistributionType=null!==(Z=v.colorDistributionType)&&void 0!==Z?Z:0,this.colorsSampling=null!==(A=v.colorsSampling)&&void 0!==A?A:V.b.NEAREST_NEAREST,this.colorMode=null!==(E=v.colorMode)&&void 0!==E?E:0,this._colors=null!==(C=v.Qz)&&void 0!==C?C:null,this._cameraFacing=null===(M=v.cameraFacing)||void 0===M||M,this.resolution=null!==(T=v.resolution)&&void 0!==T?T:new J.Vector2(X.getRenderWidth(),X.getRenderHeight()),v.colorsTexture)?this.colorsTexture=v.colorsTexture:this._colors?this.colorsTexture=pz.CreateColorsTexture("".concat(this.name,"-colors-texture"),this._colors,this.colorsSampling,u):(this._color=null!==(x=this._color)&&void 0!==x?x:Qz.DEFAULT_COLOR,this.colorsTexture=pz.PrepareEmptyColorsTexture(u));if(h){const z=new Iz.c;z.setParameters(),z.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",z)}X.Xf.add((()=>{pz.DisposeEmptyColorsTexture()}))}dispose(){var z;null===(z=this._colorsTexture)||void 0===z||z.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new J.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Qz(){return this._colors}set Qz(z){this.setColors(z)}setColors(z){var u,U;let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1],v=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const f=null!==(u=null===(U=this._colors)||void 0===U?void 0:U.length)&&void 0!==u?u:0;var g;if(this._colors=z,null!==z&&0!==z.length){if(!J||v)if(this._colorsTexture&&f===z.length&&!v){const u=pz.Color3toRGBAUint8(z);this._colorsTexture.update(u)}else{var w;null===(w=this._colorsTexture)||void 0===w||w.dispose(),this.colorsTexture=pz.CreateColorsTexture("".concat(this.name,"-colors-texture"),z,this.colorsSampling,this.Vz())}}else null===(g=this._colorsTexture)||void 0===g||g.dispose()}get colorsTexture(){var z;return null!==(z=this._colorsTexture)&&void 0!==z?z:null}set colorsTexture(z){this._colorsTexture=z,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(z){this._width=z,this.setFloat("grlWidth",z)}get useColors(){return this._useColors}set useColors(z){this._useColors=z,this.setFloat("grlUseColors",pz.BooleanToNumber(z))}get colorsSampling(){return this._colorsSampling}set colorsSampling(z){this._colorsSampling=z}get visibility(){return this._visibility}set visibility(z){this._visibility=z,this.setFloat("grlVisibility",z)}get useDash(){return this._useDash}set useDash(z){this._useDash=z,this.setFloat("grlUseDash",pz.BooleanToNumber(z))}get dashOffset(){return this._dashOffset}set dashOffset(z){this._dashOffset=z,this.setFloat("grlDashOffset",z)}get dashRatio(){return this._dashRatio}set dashRatio(z){this._dashRatio=z,this.setFloat("grlDashRatio",z)}get dashCount(){return this._dashCount}set dashCount(z){this._dashCount=z,this._dashArray=1/z,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(z){this._sizeAttenuation=z,this.setFloat("grlSizeAttenuation",pz.BooleanToNumber(z))}get color(){return this._color}set color(z){this.setColor(z)}setColor(z){var u;z=null!==(u=z)&&void 0!==u?u:Qz.DEFAULT_COLOR,this._color=z,this.setColor3("grlColor",z)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(z){this._colorsDistributionType=z,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(z){this._colorMode=z,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(z){this._resolution=z,this.setVector2("grlResolution",z),this.setFloat("grlAspect",z.x/z.y)}serialize(){const z=super.serialize(),u={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(u.Qz=this._colors),z.greasedLineMaterialOptions=u,z}parse(z,u,U){var J,v;const f=z.greasedLineMaterialOptions;null===(J=this._colorsTexture)||void 0===J||J.dispose(),f.color&&(this.color=f.color),f.colorDistributionType&&(this.colorsDistributionType=f.colorDistributionType),f.colorsSampling&&(this.colorsSampling=f.colorsSampling),f.colorMode&&(this.colorMode=f.colorMode),f.useColors&&(this.useColors=f.useColors),f.visibility&&(this.visibility=f.visibility),f.useDash&&(this.useDash=f.useDash),f.dashCount&&(this.dashCount=f.dashCount),f.dashRatio&&(this.dashRatio=f.dashRatio),f.dashOffset&&(this.dashOffset=f.dashOffset),f.width&&(this.width=f.width),f.sizeAttenuation&&(this.sizeAttenuation=f.sizeAttenuation),f.resolution&&(this.resolution=f.resolution),f.Qz?this.colorsTexture=pz.CreateColorsTexture("".concat(this.name,"-colors-texture"),f.Qz,this.colorsSampling,this.Vz()):this.colorsTexture=pz.PrepareEmptyColorsTexture(u),this._cameraFacing=null===(v=f.cameraFacing)||void 0===v||v,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var bz,kz,Bz;Fz.ForceGLSL=!1,function(z){z[z.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",z[z.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(bz||(bz={})),function(z){z[z.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",z[z.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",z[z.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(kz||(kz={})),function(z){z[z.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",z[z.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",z[z.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",z[z.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",z[z.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Bz||(Bz={}));class yz extends Tz.e{constructor(z,u,U){var J,v,f,g;super(z,u,null,null,!1,!1),this.name=z,this._options=U,this._lazy=!1,this._updatable=!1,this._engine=u.getEngine(),this._lazy=null!==(J=U.lazy)&&void 0!==J&&J,this._updatable=null!==(v=U.updatable)&&void 0!==v&&v,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=null!==(f=U.colorPointers)&&void 0!==f?f:[],this._widths=null!==(g=U.widths)&&void 0!==g?g:new Array(U.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(z){let u=0;for(const J of this._points)u+=J.length;const U=u/3*2-this._widths.length;for(let J=0;J<U;J++)this._widths.push(z)}updateLazy(){var z,u;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(z=this._options.ribbonOptions)||void 0===z?void 0:z.smoothShading),!this.Nz&&this.refreshBoundingInfo(),null===(u=this.greasedLineMaterial)||void 0===u||u.updateLazy()}addPoints(z,u){for(const U of z)this._points.push(U);this._lazy||this.setPoints(this._points,u)}dispose(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(z,u)}isLazy(){return this._lazy}get Kz(){return this._uvs}set Kz(z){this._uvs=z instanceof Float32Array?z:new Float32Array(z),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(z){this.material instanceof Fz&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===z||void 0===z?void 0:z.length)>0),this._offsets=z,this._offsetsBuffer?this._offsetsBuffer.update(z):this._createOffsetsBuffer(z)}get widths(){return this._widths}set widths(z){this._widths=z,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(z)}get colorPointers(){return this._colorPointers}set colorPointers(z){this._colorPointers=z,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(z)}get greasedLineMaterial(){var z,u;if(this.material&&this.material instanceof Fz)return this.material;const U=null===(z=this.material)||void 0===z||null===(u=z.pluginManager)||void 0===u?void 0:u.getPlugin(Dz.GREASED_LINE_MATERIAL_NAME);return U||void 0}get points(){const z=[];return Wz.c.DeepCopy(this._points,z),z}setPoints(z,u){var U;this._points=pz.ConvertPoints(z,null!==(U=null===u||void 0===u?void 0:u.pointsOptions)&&void 0!==U?U:this._options.pointsOptions),this._updateWidths(),null!==u&&void 0!==u&&u.colorPointers||this._updateColorPointers(),this._setPoints(this._points,u)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Kz:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(z){super.serialize(z),z.type=this.getClassName(),z.lineOptions=this._createLineOptions()}_createVertexBuffers(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new cz.e;return u.Oz=this._vertexPositions,u.indices=this._indices,u.Kz=this._uvs,z&&(u.xz=[],cz.e.ComputeNormals(this._vertexPositions,this._indices,u.xz)),u.pz(this,this._options.updatable),u}_createOffsetsBuffer(z){const u=this._scene.getEngine(),U=new d.e(u,z,this._updatable,3);this.setVerticesBuffer(U.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=U}}class Hz{constructor(z,u){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=z,this.wasAddedByNoopNode=u}getIndicesAccessor(z,u,U,J,v){var f,g,w,P;return null===(f=this._indicesAccessorMap.get(z))||void 0===f||null===(g=f.get(u))||void 0===g||null===(w=g.get(U))||void 0===w||null===(P=w.get(J))||void 0===P?void 0:P.get(v)}setIndicesAccessor(z,u,U,J,v,f){let g=this._indicesAccessorMap.get(z);g||(g=new Map,this._indicesAccessorMap.set(z,g));let w=g.get(u);w||(w=new Map,g.set(u,w));let P=w.get(U);P||(P=new Map,w.set(U,P));let R=P.get(J);R||(R=new Map,P.set(J,R)),R.set(v,f)}pushExportedNode(z){this._exportedNodes.has(z)||this._exportedNodes.add(z)}getNodesSet(){return this._exportedNodes}getVertexBufferView(z){return this._vertexBufferViewMap.get(z)}setVertexBufferView(z,u){this._vertexBufferViewMap.set(z,u)}setRemappedBufferView(z,u,U){this._remappedBufferView.set(z,new Map),this._remappedBufferView.get(z).set(u,U)}getRemappedBufferView(z,u){var U;return null===(U=this._remappedBufferView.get(z))||void 0===U?void 0:U.get(u)}getVertexAccessor(z,u,U){var J,v;return null===(J=this._vertexAccessorMap.get(z))||void 0===J||null===(v=J.get(u))||void 0===v?void 0:v.get(U)}setVertexAccessor(z,u,U,J){let v=this._vertexAccessorMap.get(z);v||(v=new Map,this._vertexAccessorMap.set(z,v));let f=v.get(u);f||(f=new Map,v.set(u,f)),f.set(U,J)}hasVertexColorAlpha(z){return this._vertexMapColorAlpha.get(z)||!1}setHasVertexColorAlpha(z,u){return this._vertexMapColorAlpha.set(z,u)}getMesh(z){return this._meshMap.get(z)}setMesh(z,u){this._meshMap.set(z,u)}bindMorphDataToMesh(z,u){const U=this._meshMorphTargetMap.get(z)||[];this._meshMorphTargetMap.set(z,U),-1===U.indexOf(u)&&U.push(u)}getMorphTargetsFromMesh(z){return this._meshMorphTargetMap.get(z)}}class Gz{_ApplyExtension(z,u,U,J){if(U>=u.length)return Promise.resolve(z);const v=J(u[U],z);return v?v.then((async z=>z?await this._ApplyExtension(z,u,U+1,J):null)):this._ApplyExtension(z,u,U+1,J)}_ApplyExtensions(z,u){const U=[];for(const J of Gz._ExtensionNames)U.push(this._extensions[J]);return this._ApplyExtension(z,U,0,u)}_extensionsPreExportTextureAsync(z,u,U){return this._ApplyExtensions(u,((u,J)=>u.preExportTextureAsync&&u.preExportTextureAsync(z,J,U)))}_extensionsPostExportNodeAsync(z,u,U,J,v){return this._ApplyExtensions(u,((u,f)=>u.postExportNodeAsync&&u.postExportNodeAsync(z,f,U,J,v,this._bufferManager)))}_extensionsPostExportMaterialAsync(z,u,U){return this._ApplyExtensions(u,((u,J)=>u.postExportMaterialAsync&&u.postExportMaterialAsync(z,J,U)))}_extensionsPostExportMaterialAdditionalTextures(z,u,U){const J=[];for(const v of Gz._ExtensionNames){const f=this._extensions[v];f.postExportMaterialAdditionalTextures&&J.push(...f.postExportMaterialAdditionalTextures(z,u,U))}return J}_extensionsPostExportTextures(z,u,U){for(const J of Gz._ExtensionNames){const v=this._extensions[J];v.postExportTexture&&v.postExportTexture(z,u,U)}}_extensionsPostExportMeshPrimitive(z){for(const u of Gz._ExtensionNames){const U=this._extensions[u];U.postExportMeshPrimitive&&U.postExportMeshPrimitive(z,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const z of Gz._ExtensionNames){const u=this._extensions[z];u.preGenerateBinaryAsync&&await u.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(z){for(const u of Gz._ExtensionNames){const U=this._extensions[u];U.enabled&&z(U)}}_extensionsOnExporting(){this._forEachExtensions((z=>{var u,U,J;z.wasUsed&&((u=this._glTF).extensionsUsed||(u.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(z.name)&&this._glTF.extensionsUsed.push(z.name),z.required&&((U=this._glTF).extensionsRequired||(U.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(z.name)&&this._glTF.extensionsRequired.push(z.name)),(J=this._glTF).extensions||(J.extensions={}),z.onExporting&&z.onExporting())}))}_loadExtensions(){for(const z of Gz._ExtensionNames){const u=Gz._ExtensionFactories[z](this);this._extensions[z]=u}}constructor(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:C.e.LastCreatedScene,u=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:"Babylon.js v".concat(E.b.Version),version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new I(this),this._extensions={},this._bufferManager=new dz,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!z)throw new Error("No scene available to export");this._babylonScene=z,this._options=(0,S.e)({shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:z=>{var u;return null===z||void 0===z||null===(u=z.Kf)||void 0===u?void 0:u.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None"},u),this._loadExtensions()}dispose(){for(const z in this._extensions){this._extensions[z].dispose()}}get options(){return this._options}static RegisterExtension(z,u){Gz.UnregisterExtension(z)&&v.Tools.Warn("Extension with the name ".concat(z," already exists")),Gz._ExtensionFactories[z]=u,Gz._ExtensionNames.push(z)}static UnregisterExtension(z){if(!Gz._ExtensionFactories[z])return!1;delete Gz._ExtensionFactories[z];const u=Gz._ExtensionNames.indexOf(z);return-1!==u&&Gz._ExtensionNames.splice(u,1),!0}_generateJSON(z,u,U){const J={byteLength:z};return J.byteLength&&(this._glTF.buffers=[J]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.ru=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(J.uri=u+".bin"),U?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(z){const u=await this._generateBinaryAsync();this._extensionsOnExporting();const U=this._generateJSON(u.byteLength,z,!0),J=new Blob([u],{type:"application/octet-stream"}),v=z+".gltf",f=z+".bin",g=new R;if(g.files[v]=U,g.files[f]=J,this._imageData)for(const w in this._imageData)g.files[w]=new Blob([this._imageData[w].data],{type:this._imageData[w].mimeType});return g}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(z){const u=z%4;return 0===u?u:4-u}async generateGLBAsync(z){this._shouldUseGlb=!0;const u=await this._generateBinaryAsync();this._extensionsOnExporting();const U=this._generateJSON(u.byteLength),J=z+".glb";let v,f=U.length;if("undefined"!==typeof TextEncoder){v=(new TextEncoder).encode(U),f=v.length}const g=this._getPadding(f),w=this._getPadding(u.byteLength),P=28+f+g+u.byteLength+w,S=new Rz(P);if(S.writeUInt32(1179937895),S.writeUInt32(2),S.writeUInt32(P),S.writeUInt32(f+g),S.writeUInt32(1313821514),v)S.writeTypedArray(v);else{const z="_".charCodeAt(0);for(let u=0;u<f;++u){const J=U.charCodeAt(u);J!=U.codePointAt(u)?S.writeUInt8(z):S.writeUInt8(J)}}for(let R=0;R<g;++R)S.writeUInt8(32);S.writeUInt32(u.byteLength+w),S.writeUInt32(5130562),S.writeTypedArray(u);for(let R=0;R<w;++R)S.writeUInt8(0);const d=new R;return d.files[J]=new Blob([S.getOutputData()],{type:"application/octet-stream"}),d}_setNodeTransformation(z,u,U){if(u.getPivotPoint().equalsWithEpsilon(y,B.d)||v.Tools.Warn("Pivot points are not supported in the glTF serializer"),!u.position.equalsWithEpsilon(y,B.d)){const v=J.TmpVectors.Eu[0].v(u.position);U&&l(v),z.translation=v.jf()}u.Ug.equalsWithEpsilon(G,B.d)||(z.scale=u.Ug.jf());const f=u.rotationQuaternion||J.Quaternion.FromEulerAngles(u.rotation.x,u.rotation.y,u.rotation.z);f.equalsWithEpsilon(H,B.d)||(U&&e(f),z.rotation=f.normalize().jf())}_setCameraTransformation(z,u,U){if(!u.position.equalsWithEpsilon(y,B.d)){const v=J.TmpVectors.Eu[0].v(u.position);U&&l(v),z.translation=v.jf()}const v=u.rotationQuaternion||J.Quaternion.FromEulerAngles(u.rotation.x,u.rotation.y,u.rotation.z);U&&e(v),this._babylonScene.useRightHandedSystem||zz(v),v.equalsWithEpsilon(H,B.d)||(z.rotation=v.jf())}_listAvailableCameras(){for(const z of this._babylonScene.cameras){const u={type:z.mode===Zz.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(z.name&&(u.name=z.name),"perspective"===u.type)u.perspective={aspectRatio:z.getEngine().getAspectRatio(z),yfov:z.fovMode===Zz.b.FOVMODE_VERTICAL_FIXED?z.fov:z.fov*z.getEngine().getAspectRatio(z),znear:z.Bf,zfar:z.maxZ};else if("orthographic"===u.type){const U=z.orthoLeft&&z.orthoRight?.5*(z.orthoRight-z.orthoLeft):.5*z.getEngine().getRenderWidth(),J=z.orthoBottom&&z.orthoTop?.5*(z.orthoTop-z.orthoBottom):.5*z.getEngine().getRenderHeight();u.orthographic={xmag:U,ymag:J,znear:z.Bf,zfar:z.maxZ}}this._camerasMap.set(z,u)}}_exportAndAssignCameras(){const z=Array.from(this._camerasMap.values());for(const u of z){const z=this._nodesCameraMap.get(u);if(void 0!==z){this._cameras.push(u);for(const u of z)u.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const z of this._babylonScene.skeletons){if(z.bones.length<=0)continue;const u={joints:[]};this._skinMap.set(z,u)}}_exportAndAssignSkeletons(){for(const u of this._babylonScene.skeletons){if(u.bones.length<=0)continue;const U=this._skinMap.get(u);if(void 0==U)continue;const J={},f=[];let g=-1;for(let v=0;v<u.bones.length;++v){var z;const U=u.bones[v],f=null!==(z=U.getIndex())&&void 0!==z?z:v;-1!==f&&(J[f]=U,f>g&&(g=f))}for(let z=0;z<=g;++z){const u=J[z];f.push(u.getAbsoluteInverseBindMatrix());const g=u.getTransformNode();if(null!==g){const z=this._nodeMap.get(g);g&&null!==z&&void 0!==z?U.joints.push(z):v.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else v.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const w=this._nodesSkinMap.get(U);if(U.joints.length>0&&void 0!==w){const z=64*f.length,u=new Float32Array(z/4);f.forEach(((z,U)=>{u.set(z.m,16*U)}));const J=this._bufferManager.createBufferView(u);this._accessors.push(this._bufferManager.createAccessor(J,"MAT4",5126,f.length)),U.inverseBindMatrices=this._accessors.length-1,this._skins.push(U);for(const U of w)U.skin=this._skins.length-1}}}async _exportSceneAsync(){const z={nodes:[]};if(this._babylonScene.metadata){const u=this._options.metadataSelector(this._babylonScene.metadata);u&&(z.extras=u)}const u=new Array,U=new Array,J=new Array;for(const w of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&wz(w,this._babylonScene.useRightHandedSystem)?J.push(...w.getChildren()):this._babylonScene.useRightHandedSystem?u.push(w):U.push(w);this._listAvailableCameras(),this._listAvailableSkeletons();const v=new Hz(!0,!1);z.nodes.push(...await this._exportNodesAsync(U,v));const f=new Hz(!1,!1);z.nodes.push(...await this._exportNodesAsync(u,f));const g=new Hz(!1,!0);z.nodes.push(...await this._exportNodesAsync(J,g)),z.nodes.length&&this._scenes.push(z),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&hz._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,v.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(z){let u=this._shouldExportNodeMap.get(z);return void 0===u&&(u=this._options.shouldExportNode(z),this._shouldExportNodeMap.set(z,u)),u}async _exportNodesAsync(z,u){const U=new Array;this._exportBuffers(z,u);for(const J of z)await this._exportNodeAsync(J,U,u);return U}_collectBuffers(z,u,U,J,v){if(this._shouldExportNode(z)&&z instanceof Z.d&&z.nf){const f=z.nf.getVertexBuffers();if(f)for(const J in f){if(!q(J))continue;const g=f[J];v.setHasVertexColorAlpha(g,z.hasVertexAlpha);const w=g._buffer,P=u.get(w)||[];u.set(w,P),-1===P.indexOf(g)&&P.push(g);const R=U.get(g)||[];U.set(g,R),-1===R.indexOf(z)&&R.push(z)}const g=z.morphTargetManager;if(g)for(let u=0;u<g.numTargets;u++){const U=g.getTarget(u),v=J.get(U)||[];J.set(U,v),-1===v.indexOf(z)&&v.push(z)}}for(const f of z.getChildren())this._collectBuffers(f,u,U,J,v)}_exportBuffers(z,u){const U=new Map,J=new Map,v=new Map;for(const w of z)this._collectBuffers(w,U,J,v,u);const f=Array.from(U.keys());for(const w of f){const z=w.getData();if(!z)throw new Error("Buffer data is not available");const v=U.get(w);if(!v)continue;const f=v[0].byteStride;if(v.some((z=>z.byteStride!==f)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const g=Jz(z).slice();for(const u of v){const z=J.get(u),{byteOffset:U,byteStride:v,componentCount:f,type:w,count:P,normalized:R,kind:S}=i(u,z);switch(S){case d.g.NormalKind:case d.g.TangentKind:(0,F.j)(g,U,v,f,w,P,R,(z=>{const u=Math.sqrt(z[0]*z[0]+z[1]*z[1]+z[2]*z[2]);if(u>0){const U=1/u;z[0]*=U,z[1]*=U,z[2]*=U}}));break;case d.g.ColorKind:{const u=z.filter((z=>z.material instanceof Cz.Mu||null==z.material)).length;if(0==u)break;if(u!=z.length){b.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}w==d.g.UNSIGNED_BYTE&&b.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const J=new r.Tu,S=new r.wg,mz=this._babylonScene.getEngine().useExactSrgbConversions;(0,F.j)(g,U,v,f,w,P,R,(z=>{3===z.length?(J.CU(z,0),J.toLinearSpaceToRef(J,mz),J.toArray(z,0)):(S.CU(z,0),S.toLinearSpaceToRef(S,mz),S.toArray(z,0))}))}}}if(u.convertToRightHanded){for(const z of v){const u=J.get(z),{byteOffset:U,byteStride:v,componentCount:f,type:w,count:P,normalized:R,kind:S}=i(z,u);switch(S){case d.g.PositionKind:case d.g.NormalKind:case d.g.TangentKind:(0,F.j)(g,U,v,f,w,P,R,(z=>{z[0]=-z[0]}))}}u.convertedToRightHandedBuffers.set(w,g)}const P=this._bufferManager.createBufferView(g,f);u.setVertexBufferView(w,P);const R=new Map;for(const u of v){const z=J.get(u),{kind:U,totalVertices:v}=i(u,z);switch(U){case d.g.MatricesIndicesKind:case d.g.MatricesIndicesExtraKind:if(u.type==d.g.FLOAT){const z=u.getFloatData(v);null!==z&&R.set(u,z)}}}0!==R.size&&b.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const S=Array.from(R.keys());for(const U of S){const z=R.get(U);if(!z)continue;const J=z.some((z=>z>=256)),v=new(J?Uint16Array:Uint8Array)(z.length);for(let u=0;u<z.length;u++)v[u]=z[u];const f=this._bufferManager.createBufferView(v,4*(J?2:1));u.setRemappedBufferView(w,U,f)}}const g=Array.from(v.keys());for(const w of g){const z=v.get(w);if(!z)continue;const U=tz(w,z[0],this._bufferManager,this._bufferViews,this._accessors,u.convertToRightHanded);for(const J of z)u.bindMorphDataToMesh(J,U)}}async _exportNodeAsync(z,u,U){let J=this._nodeMap.get(z);if(void 0!==J)return void(u.includes(J)||u.push(J));const v=await this._createNodeAsync(z,U);if(v){J=this._nodes.length,this._nodes.push(v),this._nodeMap.set(z,J),U.pushExportedNode(z),u.push(J);const f={name:"runtime animations",channels:[],samplers:[]},g=[];this._babylonScene.animationGroups.length||(hz._CreateMorphTargetAnimationFromMorphTargetAnimations(z,f,g,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,U.convertToRightHanded,this._options.shouldExportAnimation),z.animations.length&&hz._CreateNodeAnimationFromNodeAnimations(z,f,g,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,U.convertToRightHanded,this._options.shouldExportAnimation)),f.channels.length&&f.samplers.length&&this._animations.push(f),g.forEach((z=>{z.channels.length&&z.samplers.length&&this._animations.push(z)}))}const f=v?[]:u;for(const g of z.getChildren())await this._exportNodeAsync(g,f,U);v&&f.length&&(v.children=f)}async _createNodeAsync(z,u){if(!this._shouldExportNode(z))return null;const U={};if(z.name&&(U.name=z.name),z.metadata){const u=this._options.metadataSelector(z.metadata);u&&(U.extras=u)}if(z instanceof mz.c&&(this._setNodeTransformation(U,z,u.convertToRightHanded),z instanceof Z.d)){const v=z instanceof A.c?z.sourceMesh:z;if(v.cf&&v.cf.length>0&&(U.mesh=await this._exportMeshAsync(v,u)),z.skeleton){const u=this._skinMap.get(z.skeleton);var J;if(void 0!==u)void 0===this._nodesSkinMap.get(u)&&this._nodesSkinMap.set(u,[]),null===(J=this._nodesSkinMap.get(u))||void 0===J||J.push(U)}}if(z instanceof k.d){const J=this._camerasMap.get(z);if(J){var v;void 0===this._nodesCameraMap.get(J)&&this._nodesCameraMap.set(J,[]),this._setCameraTransformation(U,z,u.convertToRightHanded);const g=z.parent;if(null!==g&&Uz(z,g)){const z=this._nodeMap.get(g);if(void 0!==z){var f;const u=this._nodes[z];return uz(U,u),null===(f=this._nodesCameraMap.get(J))||void 0===f||f.push(u),null}}null===(v=this._nodesCameraMap.get(J))||void 0===v||v.push(U)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",U,z,this._nodeMap,u.convertToRightHanded)?U:(b.d.Warn("Not exporting node ".concat(z.name)),null)}_exportIndices(z,u,U,J,v,g,w,P,R){let S=z;R.mode=o(g);const d=w!==f.e.CounterClockWiseSideOrientation,mz=!P.wasAddedByNoopNode&&d,Z=function(z){switch(z){case f.e.TriangleFillMode:case f.e.TriangleStripDrawMode:case f.e.TriangleFanDrawMode:return!0}return!1}(g)&&mz;if(Z){if(g===f.e.TriangleStripDrawMode||g===f.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");R.mode=o(g);const w=u?new Uint32Array(J):new Uint16Array(J);if(z)for(let u=0;u+2<J;u+=3)w[u]=z[U+u]+v,w[u+1]=z[U+u+2]+v,w[u+2]=z[U+u+1]+v;else for(let z=0;z+2<J;z+=3)w[z]=z,w[z+1]=z+2,w[z+2]=z+1;S=w}else if(z&&0!==v){const f=u?new Uint32Array(J):new Uint16Array(J);for(let u=0;u<J;u++)f[u]=z[U+u]+v;S=f}if(S){let f=P.getIndicesAccessor(z,U,J,v,Z);if(void 0===f){const g=function(z,u,U,J){if(z instanceof Uint16Array||z instanceof Uint32Array)return z;if(z instanceof Int32Array)return new Uint32Array(z.buffer,z.byteOffset,z.length);const v=z.slice(u,u+U);return J?new Uint32Array(v):new Uint16Array(v)}(S,0,J,u),w=this._bufferManager.createBufferView(g),R=u?5125:5123;this._accessors.push(this._bufferManager.createAccessor(w,"SCALAR",R,J,0)),f=this._accessors.length-1,P.setIndicesAccessor(z,U,J,v,Z,f)}R.indices=f}}_exportVertexBuffer(z,u,U,J,v,f){const g=z.getKind();if(!q(g))return;if(g.startsWith("uv")&&!this._options.exportUnusedUVs&&(!u||!this._materialNeedsUVsSet.has(u)))return;let w=v.getVertexAccessor(z,U,J);if(void 0===w){const u=v.convertedToRightHandedBuffers.get(z._buffer)||z._buffer.getData(),f=g===d.g.PositionKind?function(z,u,U,J){const{byteOffset:v,byteStride:f,type:g,normalized:w}=u,P=u.getSize(),R=new Array(P).fill(1/0),S=new Array(P).fill(-1/0);return(0,F.j)(z,v+U*f,f,P,g,J*P,w,(z=>{for(let u=0;u<P;u++)R[u]=Math.min(R[u],z[u]),S[u]=Math.max(S[u],z[u])})),{min:R,max:S}}(u,z,U,J):void 0,P=(g===d.g.MatricesIndicesKind||g===d.g.MatricesIndicesExtraKind)&&z.type===d.g.FLOAT,R=P?d.g.UNSIGNED_BYTE:z.type,S=P?void 0:z.normalized,mz=P?v.getRemappedBufferView(z._buffer,z):v.getVertexBufferView(z._buffer),Z=z.byteOffset+U*z.byteStride;this._accessors.push(this._bufferManager.createAccessor(mz,function(z,u){if(z==d.g.ColorKind)return u?"VEC4":"VEC3";switch(z){case d.g.PositionKind:case d.g.NormalKind:return"VEC3";case d.g.TangentKind:case d.g.MatricesIndicesKind:case d.g.MatricesIndicesExtraKind:case d.g.MatricesWeightsKind:case d.g.MatricesWeightsExtraKind:return"VEC4";case d.g.UVKind:case d.g.UV2Kind:case d.g.UV3Kind:case d.g.UV4Kind:case d.g.UV5Kind:case d.g.UV6Kind:return"VEC2"}throw new Error("Unknown kind ".concat(z))}(g,v.hasVertexColorAlpha(z)),R,J,Z,f,S)),w=this._accessors.length-1,v.setVertexAccessor(z,U,J,w)}f.attributes[function(z){switch(z){case d.g.PositionKind:return"POSITION";case d.g.NormalKind:return"NORMAL";case d.g.TangentKind:return"TANGENT";case d.g.ColorKind:return"COLOR_0";case d.g.UVKind:return"TEXCOORD_0";case d.g.UV2Kind:return"TEXCOORD_1";case d.g.UV3Kind:return"TEXCOORD_2";case d.g.UV4Kind:return"TEXCOORD_3";case d.g.UV5Kind:return"TEXCOORD_4";case d.g.UV6Kind:return"TEXCOORD_5";case d.g.MatricesIndicesKind:return"JOINTS_0";case d.g.MatricesIndicesExtraKind:return"JOINTS_1";case d.g.MatricesWeightsKind:return"WEIGHTS_0";case d.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error("Unknown kind: ".concat(z))}(g)]=w}async _exportMaterialAsync(z,u,U,J){let v=this._materialMap.get(z);if(void 0===v){const J=u&&Object.keys(u).some((z=>z.startsWith("uv")));if((z=z instanceof Az.d?z.Pg[U.materialIndex]:z)instanceof Ez.e)v=await this._materialExporter.exportPBRMaterialAsync(z,"image/png",J);else{if(!(z instanceof Cz.Mu))return void b.d.Warn("Unsupported material '".concat(z.name,"' with type ").concat(z.getClassName()));v=await this._materialExporter.exportStandardMaterialAsync(z,"image/png",J)}this._materialMap.set(z,v)}J.material=v}async _exportMeshAsync(z,u){var U;let J=u.getMesh(z);if(void 0!==J)return J;const v={primitives:[]};J=this._meshes.length,this._meshes.push(v),u.setMesh(z,J);const g=z.isUnIndexed?null:z.lf(),w=null===(U=z.nf)||void 0===U?void 0:U.getVertexBuffers(),P=u.getMorphTargetsFromMesh(z),R=z instanceof Vz.b,S=z instanceof yz,d=z.cf;if(w&&d&&d.length>0)for(const M of d){var mz;const U={attributes:{}},J=M.jz()||this._babylonScene.defaultMaterial;if(S){var Z,A,E,C;const u={name:J.name},v=z,f=r.Tu.White(),g=null!==(Z=null===(A=v.material)||void 0===A?void 0:A.alpha)&&void 0!==Z?Z:1,w=null!==(E=null===(C=v.greasedLineMaterial)||void 0===C?void 0:C.color)&&void 0!==E?E:f;(!w.equalsWithEpsilon(f,B.d)||g<1)&&(u.pbrMetallicRoughness={baseColorFactor:[...w.jf(),g]}),this._materials.push(u),U.material=this._materials.length-1}else if(R){const u={name:J.name},v=z;(!v.color.equalsWithEpsilon(r.Tu.White(),B.d)||v.alpha<1)&&(u.pbrMetallicRoughness={baseColorFactor:[...v.color.jf(),v.alpha]}),this._materials.push(u),U.material=this._materials.length-1}else await this._exportMaterialAsync(J,w,M,U);const d=R||S?f.e.LineListDrawMode:null!==(mz=z.overrideRenderingFillMode)&&void 0!==mz?mz:J.fillMode,T=J._getEffectiveOrientation(z);this._exportIndices(g,g?(0,F.b)(g,M.indexCount,M.indexStart,M.verticesStart):M.verticesCount>65535,g?M.indexStart:M.verticesStart,g?M.indexCount:M.verticesCount,-M.verticesStart,d,T,u,U);for(const z of Object.values(w))this._exportVertexBuffer(z,J,M.verticesStart,M.verticesCount,u,U);if(P){U.targets=[];for(const z of P)U.targets.push(z.attributes)}v.primitives.push(U),this._extensionsPostExportMeshPrimitive(U)}if(P){v.weights=[],v.extras||(v.extras={}),v.extras.targetNames=[];for(const z of P)v.weights.push(z.influence),v.extras.targetNames.push(z.name)}return J}}Gz._ExtensionNames=new Array,Gz._ExtensionFactories={};class az{static async GLTFAsync(z,u,U){U&&U.exportWithoutWaitingForScene||await z.whenReadyAsync();const J=new Gz(z,U),v=await J.generateGLTFAsync(u.replace(/\.[^/.]+$/,""));return J.dispose(),v}static async GLBAsync(z,u,U){U&&U.exportWithoutWaitingForScene||await z.whenReadyAsync();const J=new Gz(z,U),v=await J.generateGLBAsync(u.replace(/\.[^/.]+$/,""));return J.dispose(),v}}U(13439);const iz="EXT_mesh_gpu_instancing";class nz{constructor(z){this.name=iz,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(z,u,U,v,f,g){return await new Promise((z=>{if(u&&U instanceof Tz.e&&U.hasThinInstances&&this._exporter){this._wasUsed=!0;const z=J.Eu.Zero(),v=J.Quaternion.Identity(),w=J.Eu.One(),P=U.thinInstanceGetWorldMatrices(),R=J.TmpVectors.Eu[2],S=J.TmpVectors.Quaternion[1],d=J.TmpVectors.Eu[3];let mz=!1,Z=!1,A=!1;const E=new Float32Array(3*U.Eg),C=new Float32Array(4*U.Eg),r=new Float32Array(3*U.Eg);let M=0;for(const u of P)u.decompose(d,S,R),f&&(l(R),e(S)),E.set(R.jf(),3*M),C.set(S.normalize().jf(),4*M),r.set(d.jf(),3*M),mz=mz||!R.equalsWithEpsilon(z),Z=Z||!S.equalsWithEpsilon(v),A=A||!d.equalsWithEpsilon(w),M++;const T={attributes:{}};mz&&(T.attributes.TRANSLATION=this._buildAccessor(E,"VEC3",U.Eg,g)),Z&&(T.attributes.ROTATION=this._buildAccessor(C,"VEC4",U.Eg,g)),A&&(T.attributes.SCALE=this._buildAccessor(r,"VEC3",U.Eg,g)),u.extensions=u.extensions||{},u.extensions[iz]=T}z(u)}))}_buildAccessor(z,u,U,J){const v=J.createBufferView(z),f=J.createAccessor(v,u,5126,U);return this._exporter._accessors.push(f),this._exporter._accessors.length-1}}Gz.RegisterExtension(iz,(z=>new nz(z)));var qz=U(13448),oz=U(13452),sz=U(13455),lz=U(13460);function ez(z){return z===sz.b.PositionKind?"POSITION":z===sz.b.NormalKind?"NORMAL":z===sz.b.ColorKind?"COLOR":z.startsWith(sz.b.UVKind)?"TEX_COORD":"GENERIC"}const zu={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class uu extends qz.d{static get DefaultAvailable(){return(0,qz.l)(uu.DefaultConfiguration)}static get Default(){var z;return null!==(z=uu._Default)&&void 0!==z||(uu._Default=new uu),uu._Default}static ResetDefault(z){uu._Default&&(z||uu._Default.dispose(),uu._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(z,u){return{module:await(u||DracoEncoderModule)({wasmBinary:z})}}_getWorkerContent(){return"".concat(oz.k,"(").concat(oz.m,")()")}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:uu.DefaultConfiguration)}async _encodeAsync(z,u,U){const J=U?(0,lz.d)(zu,U):zu;if(this._workerPoolPromise){const U=await this._workerPoolPromise;return await new Promise(((v,f)=>{U.push(((U,g)=>{const w=z=>{U.removeEventListener("error",w),U.removeEventListener("message",P),f(z),g()},P=z=>{"encodeMeshDone"===z.data.id&&(U.removeEventListener("error",w),U.removeEventListener("message",P),v(z.data.encodedMeshData),g())};U.addEventListener("error",w),U.addEventListener("message",P);const R=[];for(const u of z)R.push(u.data.buffer);u&&R.push(u.buffer),U.postMessage({id:"encodeMesh",attributes:z,indices:u,options:J},R)}))}))}if(this._modulePromise){const U=await this._modulePromise;return(0,oz.k)(U.module,z,u,J)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(z,u){if(0==z.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");z instanceof Tz.e&&z.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===u||void 0===u?void 0:u.method)&&(b.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),u.method="MESH_SEQUENTIAL_ENCODING");const U=function(z){let u=z.lf(void 0,!0);return!u||u instanceof Uint32Array||u instanceof Uint16Array||(u=((0,F.b)(u,u.length)?Uint32Array:Uint16Array).from(u)),u}(z),J=function(z,u){const U=[];for(const J of z.getVerticesDataKinds()){if(null!==u&&void 0!==u&&u.includes(J)){if(J===sz.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const v=z.getVertexBuffer(J),f=v.getSize(),g=(0,F.t)(v.getData(),f,v.type,v.byteOffset,v.byteStride,v.normalized,z.getTotalVertices(),!0);U.push({kind:J,dracoName:ez(J),size:f,data:g})}return U}(z,null===u||void 0===u?void 0:u.excludedAttributes);return await this._encodeAsync(J,U,u)}}uu.DefaultConfiguration={wasmUrl:"".concat(v.Tools._DefaultCdnUrl,"/draco_encoder_wasm_wrapper.js"),wasmBinaryUrl:"".concat(v.Tools._DefaultCdnUrl,"/draco_encoder.wasm"),fallbackUrl:"".concat(v.Tools._DefaultCdnUrl,"/draco_encoder.js")},uu._Default=null;const Uu="KHR_draco_mesh_compression";class Ju{get wasUsed(){return this._wasUsed}constructor(z){this.name=Uu,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===z.options.meshCompressionMethod&&uu.DefaultAvailable}dispose(){}postExportMeshPrimitive(z,u,U){if(!this.enabled)return;if(4!==z.mode&&5!==z.mode)return void b.d.Warn("Cannot compress primitive with mode "+z.mode+".");const J=[],v=[];let f=null;if(void 0!==z.indices){const g=U[z.indices],w=u.getBufferView(g);f=u.getData(w).slice(),J.push(w),v.push(g)}const g=[];for(const[S,d]of Object.entries(z.attributes)){const z=U[d],f=u.getBufferView(z),P=n(z.type),R=(0,F.t)(u.getData(f),P,z.componentType,z.byteOffset||0,f.byteStride||(0,F.l)(z.componentType)*P,z.normalized||!1,z.count,!0);g.push({kind:S,dracoName:(w=S,"POSITION"===w?"POSITION":"NORMAL"===w?"NORMAL":w.startsWith("COLOR")?"COLOR":w.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:n(z.type),data:R}),J.push(f),v.push(z)}var w;const P={method:z.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},R=uu.Default._encodeAsync(g,f,P).then((U=>{if(!U)return void b.d.Error("Draco encoding failed for primitive.");const f={bufferView:-1,attributes:U.attributeIds},g=u.createBufferView(U.data);u.setBufferView(f,g);for(const z of J)this._bufferViewsUsed.add(z);for(const z of v)this._accessorsUsed.add(z);z.extensions||(z.extensions={}),z.extensions[Uu]=f})).catch((z=>{b.d.Error("Draco encoding failed for primitive: "+z)}));this._encodePromises.push(R),this._wasUsed=!0}async preGenerateBinaryAsync(z){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((u=>{z.getPropertiesWithBufferView(u).every((z=>this._accessorsUsed.has(z)))&&z.removeBufferView(u)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Gz.RegisterExtension(Uu,(z=>new Ju(z)));var vu=U(13463);const fu="KHR_lights_punctual",gu={name:"",color:[1,1,1],Cg:1,range:Number.MAX_VALUE},wu={innerConeAngle:0,outerConeAngle:Math.PI/4},Pu=J.Eu.Backward();class Ru{constructor(z){this.name=fu,this.enabled=!0,this.required=!1,this._exporter=z}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[fu]=this._lights}async postExportNodeAsync(z,u,U,v,f){return await new Promise((g=>{if(!(U instanceof Xz.c))return void g(u);const w=U.getTypeID()==Xz.c.LIGHTTYPEID_POINTLIGHT?"point":U.getTypeID()==Xz.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":U.getTypeID()==Xz.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!w||!(U instanceof vu.e))return b.d.Warn("".concat(z,": Light ").concat(U.name," is not supported in ").concat(fu)),void g(u);if(U.falloffType!==Xz.c.FALLOFF_GLTF&&b.d.Warn("".concat(z,": Light falloff for ").concat(U.name," does not match the ").concat(fu," specification!")),!U.position.equalsToFloats(0,0,0)){const z=J.TmpVectors.Eu[0].v(U.position);f&&l(z),u.translation=z.jf()}if("point"!==w){const z=U.direction.normalizeToRef(J.TmpVectors.Eu[0]);f&&l(z);const v=J.Quaternion.FromUnitVectorsToRef(Pu,z,J.TmpVectors.Quaternion[0]);J.Quaternion.IsIdentity(v)||(u.rotation=v.jf())}const P={type:w,name:U.name,color:U.Mg.jf(),Cg:U.Cg,range:U.range};if(vz(P,gu),"spot"===w){const z=U;P.spot={innerConeAngle:z.innerAngle/2,outerConeAngle:z.angle/2},vz(P.spot,wu)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(P);const R={Pf:this._lights.lights.length-1},S=U.parent;if(S&&Uz(U,S)){const z=v.get(S);if(z){const U=this._exporter._nodes[z];return uz(u,U),U.extensions||(U.extensions={}),U.extensions[fu]=R,void g(null)}}u.extensions||(u.extensions={}),u.extensions[fu]=R,g(u)}))}}Gz.RegisterExtension(fu,(z=>new Ru(z)));var Su=U(13388);const du="KHR_materials_anisotropy";class mU{constructor(z){this.name=du,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,U){const J=[];return U instanceof Su.c&&U.anisotropy.isEnabled&&!U.anisotropy.legacy?(U.anisotropy.texture&&J.push(U.anisotropy.texture),J):[]}postExportMaterialAsync(z,u,U){return new Promise((z=>{if(U instanceof Su.c){if(!U.anisotropy.isEnabled||U.anisotropy.legacy)return void z(u);this._wasUsed=!0,u.extensions=u.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(U.anisotropy.texture),v={anisotropyStrength:U.anisotropy.Cg,anisotropyRotation:U.anisotropy.angle,anisotropyTexture:null!==J&&void 0!==J?J:void 0};null!==v.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(U),u.extensions[du]=v}z(u)}))}}Gz.RegisterExtension(du,(z=>new mU(z)));const Zu="KHR_materials_clearcoat";class Au{constructor(z){this.name=Zu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,U){const J=[];return U instanceof Su.c&&U.clearCoat.isEnabled?(U.clearCoat.texture&&J.push(U.clearCoat.texture),!U.clearCoat.useRoughnessFromMainTexture&&U.clearCoat.textureRoughness&&J.push(U.clearCoat.textureRoughness),U.clearCoat.bumpTexture&&J.push(U.clearCoat.bumpTexture),J):[]}postExportMaterialAsync(z,u,U){return new Promise((z=>{if(U instanceof Su.c){var J;if(!U.clearCoat.isEnabled)return void z(u);this._wasUsed=!0,u.extensions=u.extensions||{};const f=this._exporter._materialExporter.getTextureInfo(U.clearCoat.texture);let g;g=U.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(U.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(U.clearCoat.textureRoughness),U.clearCoat.isTintEnabled&&v.Tools.Warn("Clear Color tint is not supported for glTF export. Ignoring for: ".concat(U.name)),U.clearCoat.remapF0OnInterfaceChange&&v.Tools.Warn("Clear Color F0 remapping is not supported for glTF export. Ignoring for: ".concat(U.name));const w=this._exporter._materialExporter.getTextureInfo(U.clearCoat.bumpTexture),P={clearcoatFactor:U.clearCoat.Cg,clearcoatTexture:null!==f&&void 0!==f?f:void 0,clearcoatRoughnessFactor:U.clearCoat.roughness,clearcoatRoughnessTexture:null!==(J=g)&&void 0!==J?J:void 0,clearcoatNormalTexture:null!==w&&void 0!==w?w:void 0};null===P.clearcoatTexture&&null===P.clearcoatRoughnessTexture&&null===P.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(U),u.extensions[Zu]=P}z(u)}))}}Gz.RegisterExtension(Zu,(z=>new Au(z)));const Eu="KHR_materials_diffuse_transmission";function Cu(z,u){const U=u.subSurface;let J=null;return U.translucencyIntensityTexture?J=U.translucencyIntensityTexture:U.thicknessTexture&&U.useMaskFromThicknessTexture&&(J=U.thicknessTexture),J&&!U.useGltfStyleTextures?(b.d.Warn("".concat(z,": Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ").concat(u.name),1),null):J}class ru{constructor(z){this.name=Eu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,U){const J=[];if(U instanceof Ez.e&&this._isExtensionEnabled(U)){const u=Cu(z,U);return u&&J.push(u),U.subSurface.translucencyColorTexture&&J.push(U.subSurface.translucencyColorTexture),J}return J}_isExtensionEnabled(z){if(z.unlit)return!1;const u=z.subSurface;return!!u.isTranslucencyEnabled&&(!z.unlit&&!u.useAlbedoToTintTranslucency&&u.useGltfStyleTextures&&1===u.volumeIndexOfRefraction&&0===u.minimumThickness&&0===u.maximumThickness)}postExportMaterialAsync(z,u,U){return new Promise((J=>{if(U instanceof Ez.e&&this._isExtensionEnabled(U)){var v,f;this._wasUsed=!0;const J=U.subSurface,g=Cu(z,U),w=0==J.translucencyIntensity?void 0:J.translucencyIntensity,P=null!==(v=this._exporter._materialExporter.getTextureInfo(g))&&void 0!==v?v:void 0,R=!J.translucencyColor||J.translucencyColor.equalsFloats(1,1,1)?void 0:J.translucencyColor.jf(),S=null!==(f=this._exporter._materialExporter.getTextureInfo(J.translucencyColorTexture))&&void 0!==f?f:void 0,d={diffuseTransmissionFactor:w,diffuseTransmissionTexture:P,diffuseTransmissionColorFactor:R,diffuseTransmissionColorTexture:S};(P||S)&&this._exporter._materialNeedsUVsSet.add(U),u.extensions=u.extensions||{},u.extensions[Eu]=d}J(u)}))}}Gz.RegisterExtension(Eu,(z=>new ru(z)));const Mu="KHR_materials_dispersion";class Tu{constructor(){this.name=Mu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(z){if(z.unlit)return!1;const u=z.subSurface;return!(!u.isRefractionEnabled&&!u.isDispersionEnabled)}postExportMaterialAsync(z,u,U){return new Promise((z=>{if(U instanceof Ez.e&&this._isExtensionEnabled(U)){this._wasUsed=!0;const z={dispersion:U.subSurface.dispersion};u.extensions=u.extensions||{},u.extensions[Mu]=z}z(u)}))}}Gz.RegisterExtension(Mu,(()=>new Tu));const Xu="KHR_materials_emissive_strength";class hu{constructor(){this.name=Xu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(z,u,U){return await new Promise((z=>{if(!(U instanceof Ez.e))return z(u);const J=U.emissiveColor.jf(),v=Math.max(...J);if(v>1){this._wasUsed=!0,u.extensions||(u.extensions={});const z={emissiveStrength:v},J=U.emissiveColor.scale(1/z.emissiveStrength);u.emissiveFactor=J.jf(),u.extensions[Xu]=z}return z(u)}))}}Gz.RegisterExtension(Xu,(z=>new hu));const tu="KHR_materials_ior";class Vu{constructor(){this.name=tu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(z){return!z.unlit&&(void 0!=z.indexOfRefraction&&1.5!=z.indexOfRefraction)}postExportMaterialAsync(z,u,U){return new Promise((z=>{if(U instanceof Ez.e&&this._isExtensionEnabled(U)){this._wasUsed=!0;const z={ior:U.indexOfRefraction};u.extensions=u.extensions||{},u.extensions[tu]=z}z(u)}))}}Gz.RegisterExtension(tu,(z=>new Vu));const Lu="KHR_materials_iridescence";class Ou{constructor(z){this.name=Lu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,U){const J=[];return U instanceof Su.c&&U.iridescence.isEnabled?(U.iridescence.texture&&J.push(U.iridescence.texture),U.iridescence.thicknessTexture&&U.iridescence.thicknessTexture!==U.iridescence.texture&&J.push(U.iridescence.thicknessTexture),J):[]}postExportMaterialAsync(z,u,U){return new Promise((z=>{if(U instanceof Su.c){if(!U.iridescence.isEnabled)return void z(u);this._wasUsed=!0,u.extensions=u.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(U.iridescence.texture),v=this._exporter._materialExporter.getTextureInfo(U.iridescence.thicknessTexture),f={iridescenceFactor:U.iridescence.Cg,iridescenceIor:U.iridescence.indexOfRefraction,iridescenceThicknessMinimum:U.iridescence.minimumThickness,iridescenceThicknessMaximum:U.iridescence.maximumThickness,iridescenceTexture:null!==J&&void 0!==J?J:void 0,iridescenceThicknessTexture:null!==v&&void 0!==v?v:void 0};null===f.iridescenceTexture&&null===f.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(U),u.extensions[Lu]=f}z(u)}))}}Gz.RegisterExtension(Lu,(z=>new Ou(z)));const xu="KHR_materials_sheen";class Qu{constructor(z){this.name=xu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,U){return U instanceof Ez.e&&U.sheen.isEnabled&&U.sheen.texture?[U.sheen.texture]:[]}async postExportMaterialAsync(z,u,U){return await new Promise((z=>{if(U instanceof Ez.e){var J;if(!U.sheen.isEnabled)return void z(u);this._wasUsed=!0,null==u.extensions&&(u.extensions={});const w={sheenColorFactor:U.sheen.color.jf(),sheenRoughnessFactor:null!==(J=U.sheen.roughness)&&void 0!==J?J:0};var v,f;if(null===w.sheenColorTexture&&null===w.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(U),U.sheen.texture)w.sheenColorTexture=null!==(v=this._exporter._materialExporter.getTextureInfo(U.sheen.texture))&&void 0!==v?v:void 0;if(U.sheen.textureRoughness&&!U.sheen.useRoughnessFromMainTexture)w.sheenRoughnessTexture=null!==(f=this._exporter._materialExporter.getTextureInfo(U.sheen.textureRoughness))&&void 0!==f?f:void 0;else if(U.sheen.texture&&U.sheen.useRoughnessFromMainTexture){var g;w.sheenRoughnessTexture=null!==(g=this._exporter._materialExporter.getTextureInfo(U.sheen.texture))&&void 0!==g?g:void 0}u.extensions[xu]=w}z(u)}))}}Gz.RegisterExtension(xu,(z=>new Qu(z)));const Ku="KHR_materials_specular";class Yu{constructor(z){this.name=Ku,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,U){const J=[];return U instanceof Ez.e&&this._isExtensionEnabled(U)?(U.metallicReflectanceTexture&&J.push(U.metallicReflectanceTexture),U.reflectanceTexture&&J.push(U.reflectanceTexture),J):J}_isExtensionEnabled(z){return!z.unlit&&(void 0!=z.metallicF0Factor&&1!=z.metallicF0Factor||void 0!=z.metallicReflectanceColor&&!z.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(z))}_hasTexturesExtension(z){return null!=z.metallicReflectanceTexture||null!=z.reflectanceTexture}postExportMaterialAsync(z,u,U){return new Promise((z=>{if(U instanceof Ez.e&&this._isExtensionEnabled(U)){var J,v;this._wasUsed=!0,u.extensions=u.extensions||{};const z=null!==(J=this._exporter._materialExporter.getTextureInfo(U.metallicReflectanceTexture))&&void 0!==J?J:void 0,f=null!==(v=this._exporter._materialExporter.getTextureInfo(U.reflectanceTexture))&&void 0!==v?v:void 0,g={specularFactor:1==U.metallicF0Factor?void 0:U.metallicF0Factor,specularTexture:z,specularColorFactor:U.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:U.metallicReflectanceColor.jf(),specularColorTexture:f};this._hasTexturesExtension(U)&&this._exporter._materialNeedsUVsSet.add(U),u.extensions[Ku]=g}z(u)}))}}Gz.RegisterExtension(Ku,(z=>new Yu(z)));const pu="KHR_materials_transmission";class Nu{constructor(z){this.name=pu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,U){const J=[];return U instanceof Ez.e&&this._isExtensionEnabled(U)?(U.subSurface.thicknessTexture&&J.push(U.subSurface.thicknessTexture),J):J}_isExtensionEnabled(z){if(z.unlit)return!1;const u=z.subSurface;return u.isRefractionEnabled&&void 0!=u.refractionIntensity&&0!=u.refractionIntensity||this._hasTexturesExtension(z)}_hasTexturesExtension(z){return null!=z.subSurface.refractionIntensityTexture}async postExportMaterialAsync(z,u,U){if(U instanceof Ez.e&&this._isExtensionEnabled(U)){this._wasUsed=!0;const J=U.subSurface,v={transmissionFactor:0===J.refractionIntensity?void 0:J.refractionIntensity};if(this._hasTexturesExtension(U)&&this._exporter._materialNeedsUVsSet.add(U),J.refractionIntensityTexture)if(J.useGltfStyleTextures){const z=await this._exporter._materialExporter.exportTextureAsync(J.refractionIntensityTexture,"image/png");z&&(v.transmissionTexture=z)}else b.d.Warn("".concat(z,": Exporting a subsurface refraction intensity texture without `useGltfStyleTextures` is not supported"));u.extensions||(u.extensions={}),u.extensions[pu]=v}return u}}Gz.RegisterExtension(pu,(z=>new Nu(z)));const Du="KHR_materials_unlit";class cu{constructor(){this.name=Du,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(z,u,U){return new Promise((z=>{let J=!1;U instanceof Ez.e?J=U.unlit:U instanceof Cz.Mu&&(J=U.disableLighting),J&&(this._wasUsed=!0,null==u.extensions&&(u.extensions={}),u.extensions[Du]={}),z(u)}))}}Gz.RegisterExtension(Du,(()=>new cu));const Wu="KHR_materials_volume";class ju{constructor(z){this.name=Wu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,U){const J=[];return U instanceof Ez.e&&this._isExtensionEnabled(U)?(U.subSurface.thicknessTexture&&J.push(U.subSurface.thicknessTexture),J):J}_isExtensionEnabled(z){if(z.unlit)return!1;const u=z.subSurface;return!(!u.isRefractionEnabled&&!u.isTranslucencyEnabled)&&(void 0!=u.maximumThickness&&0!=u.maximumThickness||void 0!=u.tintColorAtDistance&&u.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=u.tintColor&&u.tintColor!=r.Tu.White()||this._hasTexturesExtension(z))}_hasTexturesExtension(z){return null!=z.subSurface.thicknessTexture}postExportMaterialAsync(z,u,U){return new Promise((z=>{if(U instanceof Ez.e&&this._isExtensionEnabled(U)){var J;this._wasUsed=!0;const z=U.subSurface,v={thicknessFactor:0==z.maximumThickness?void 0:z.maximumThickness,thicknessTexture:null!==(J=this._exporter._materialExporter.getTextureInfo(z.thicknessTexture))&&void 0!==J?J:void 0,attenuationDistance:z.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:z.tintColorAtDistance,attenuationColor:z.tintColor.equalsFloats(1,1,1)?void 0:z.tintColor.jf()};this._hasTexturesExtension(U)&&this._exporter._materialNeedsUVsSet.add(U),u.extensions=u.extensions||{},u.extensions[Wu]=v}z(u)}))}}Gz.RegisterExtension(Wu,(z=>new ju(z)));const Iu="EXT_materials_diffuse_roughness";class Fu{constructor(z){this.name=Iu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,U){const J=[];return U instanceof Su.c&&U._baseDiffuseRoughness?(U._baseDiffuseRoughnessTexture&&J.push(U._baseDiffuseRoughnessTexture),J):[]}postExportMaterialAsync(z,u,U){return new Promise((z=>{if(U instanceof Su.c){if(!U._baseDiffuseRoughness)return void z(u);this._wasUsed=!0,u.extensions=u.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(U._baseDiffuseRoughnessTexture),v={diffuseRoughnessFactor:U._baseDiffuseRoughness,diffuseRoughnessTexture:null!==J&&void 0!==J?J:void 0};null!==v.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(U),u.extensions[Iu]=v}z(u)}))}}Gz.RegisterExtension(Iu,(z=>new Fu(z)));const bu="KHR_texture_transform";class ku{constructor(){this.name=bu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(z,u,U){if(U.Vz()||v.Tools.Warn("".concat(z,': "scene" is not defined for Babylon texture ').concat(U.name,"!")),(0!==U.uAng||0!==U.vAng)&&(v.Tools.Warn("".concat(z,": Texture ").concat(U.name," with rotation in the u or v axis is not supported in glTF.")),0!==U.uRotationCenter||0!==U.vRotationCenter))return;const J={};let f=!1;if(0===U.uOffset&&0===U.vOffset||(J.offset=[U.uOffset,U.vOffset],f=!0),1===U.uScale&&1===U.vScale||(J.scale=[U.uScale,U.vScale],f=!0),0!==U.wAng){if(0!==U.uRotationCenter||0!==U.vRotationCenter){if(U.homogeneousRotationInUVTransform&&U.uScale!==U.vScale)return void v.Tools.Warn("".concat(z,": Texture ").concat(U.name," with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ").concat(bu,"."));v.Tools.Warn("".concat(z,": Texture ").concat(U.name," with non-origin rotation center will be exported using an adjusted offset with ").concat(bu,".")),J.offset=function(z){const{uOffset:u,vOffset:U,uRotationCenter:J,vRotationCenter:v,uScale:f,vScale:g,wAng:w}=z,P=Math.cos(w),R=Math.sin(w),S=J*f,d=v*g;return[u+(S*(1-P)+d*R),U+(d*(1-P)-S*R)]}(U)}J.rotation=-U.wAng,f=!0}0!==U.coordinatesIndex&&(J.texCoord=U.coordinatesIndex,f=!0),f&&(this._wasUsed=!0,u.extensions||(u.extensions={}),u.extensions[bu]=J)}}Gz.RegisterExtension(bu,(()=>new ku));class Bu{static CreateSTL(z){let u=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",v=arguments.length>3&&void 0!==arguments[3]&&arguments[3],f=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],g=arguments.length>5&&void 0!==arguments[5]&&arguments[5],w=arguments.length>6&&void 0!==arguments[6]&&arguments[6],P=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const R=function(z,u,U){const v=[3*z[U],3*z[U+1],3*z[U+2]],f=[new J.Eu(u[v[0]],u[v[0]+2],u[v[0]+1]),new J.Eu(u[v[1]],u[v[1]+2],u[v[1]+1]),new J.Eu(u[v[2]],u[v[2]+2],u[v[2]+1])],g=f[0].Cu(f[1]),w=f[2].Cu(f[1]);return{v:f,n:J.Eu.Cross(w,g).normalize()}},S=function(z,u,U,J){return u=mz(z,u,U.x,J),u=mz(z,u,U.y,J),mz(z,u,U.z,J)},mz=function(z,u,U,J){return z.setFloat32(u,U,J),u+4},Z=function(z){if(w){let u=z;z instanceof A.c&&(u=z.sourceMesh);const U=u.getVerticesData(d.g.PositionKind,!0,!0);if(!U)return[];const v=J.Eu.Zero();let f;for(f=0;f<U.length;f+=3)J.Eu.TransformCoordinatesFromFloatsToRef(U[f],U[f+1],U[f+2],z.af(!0),v).toArray(U,f);return U}return z.getVerticesData(d.g.PositionKind)||[]};w&&(g=!0);let E="",C=0,r=0;if(v){for(let U=0;U<z.length;U++){const u=z[U].lf();C+=u?u.length/3:0}const u=new ArrayBuffer(84+50*C);E=new DataView(u),r+=80,E.setUint32(r,C,f),r+=4}else P||(E="solid stlmesh\r\n");for(let J=0;J<z.length;J++){const u=z[J];!v&&P&&(E+="solid "+u.name+"\r\n"),!g&&u instanceof Tz.e&&u.bakeCurrentTransformIntoVertices();const U=Z(u),w=u.lf()||[];for(let z=0;z<w.length;z+=3){const u=R(w,U,z);v?(r=S(E,r,u.n,f),r=S(E,r,u.v[0],f),r=S(E,r,u.v[1],f),r=S(E,r,u.v[2],f),r+=2):(E+="\tfacet normal "+u.n.x+" "+u.n.y+" "+u.n.z+"\r\n",E+="\t\touter loop\r\n",E+="\t\t\tvertex "+u.v[0].x+" "+u.v[0].y+" "+u.v[0].z+"\r\n",E+="\t\t\tvertex "+u.v[1].x+" "+u.v[1].y+" "+u.v[1].z+"\r\n",E+="\t\t\tvertex "+u.v[2].x+" "+u.v[2].y+" "+u.v[2].z+"\r\n",E+="\t\tendloop\r\n",E+="\tendfacet\r\n")}!v&&P&&(E+="endsolid "+name+"\r\n")}if(v||P||(E+="endsolid stlmesh"),u){const z=document.createElement("a"),u=new Blob([E],{type:"application/octet-stream"});z.href=window.URL.createObjectURL(u),z.download=U+".stl",z.click()}return E}}function yu(z,u){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const J=[];for(let v=0;v<z.length/U;v++){const f=z[v*U],g=z[v*U+1],w=z[v*U+2];J.push("(".concat(f.toPrecision(u.precision),", ").concat(g.toPrecision(u.precision),", ").concat(w.toPrecision(u.precision),")"))}return J.join(", ")}function Hu(z,u){const U=[];for(let J=0;J<z.length/2;J++){const v=z[2*J],f=z[2*J+1];U.push("(".concat(v.toPrecision(u.precision),", ").concat((1-f).toPrecision(u.precision),")"))}return U.join(", ")}function Gu(z,u){const U=z.getVerticesData(d.g.PositionKind),J=z.getVerticesData(d.g.NormalKind);if(U&&J)return'\n\tdef Mesh "'.concat("Geometry",'"\n\t{\n\t\tint[] faceVertexCounts = [').concat(function(z){var u;const U=null!==(u=z.lf())&&void 0!==u&&u.length?z.getTotalIndices():z.getTotalVertices();return Array(U/3).fill(3).join(", ")}(z),"]\n\t\tint[] faceVertexIndices = [").concat(function(z){const u=z.lf(),U=[];if(null!==u)for(let J=0;J<u.length;J++)U.push(u[J]);else{const u=z.getTotalVertices();for(let z=0;z<u;z++)U.push(z)}return U.join(", ")}(z),"]\n\t\tnormal3f[] normals = [").concat(yu(J,u),'] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [').concat(yu(U,u),"]\n        ").concat(function(z,u){let U="";for(let v=0;v<4;v++){const J=v>0?v:"",f=z.getVerticesData(d.g.UVKind+(J?J+1:""));f&&(U+="\n\t\ttexCoord2f[] primvars:st".concat(J," = [").concat(Hu(f,u),'] (\n\t\t\tinterpolation = "vertex"\n\t\t)'))}const J=z.getVerticesData(d.g.ColorKind);return J&&(U+="\n\tcolor3f[] primvars:displayColor = [".concat(yu(J,u,J.length/z.getTotalVertices()),'] (\n\t\tinterpolation = "vertex"\n\t\t)')),U}(z,u),'\n\t\tuniform token subdivisionScheme = "none"\n\t}\n')}function au(z,u){const U=Gu(z,u);return'\n        def "Geometry"\n        {\n        '.concat(U,"\n        }\n        ")}function iu(z){let u='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return u+=z,fflate.strToU8(u)}function nu(z){const u=z.m;return"( ".concat(qu(u,0),", ").concat(qu(u,4),", ").concat(qu(u,8),", ").concat(qu(u,12)," )")}function qu(z,u){return"(".concat(z[u+0],", ").concat(z[u+1],", ").concat(z[u+2],", ").concat(z[u+3],")")}function ou(z){const u="Object_"+z.uniqueId,U=function(z){const u=z.getWorldMatrix().clone(),U=z.Vz().useRightHandedSystem;if(!U){let J=z.parent;for(;J;){if(wz(J,U)){u.multiplyToRef(J.getWorldMatrix().invert(),u);break}J=J.parent}}return u.determinant()<0&&v.Tools.Warn("Exporting mesh ".concat(z.name," with negative scale. Result may look incorrect in destination engine.")),u}(z),J=nu(U);return'def Xform "'.concat(u,'" (\n\tprepend references = @./geometries/Geometry_').concat(z.nf.uniqueId,'.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ').concat(J,'\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_').concat(z.material.uniqueId,">\n}\n\n")}function su(z){switch(z){case L.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case L.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case L.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function lu(z){return"(".concat(z.x,", ").concat(z.y,")")}function eu(z){return"(".concat(z.r,", ").concat(z.g,", ").concat(z.b,")")}function zU(z,u,U,v,f,g){const w=z.getInternalTexture().uniqueId+"_"+z.invertY;f[w]=z;const P=z.coordinatesIndex>0?"st"+z.coordinatesIndex:"st",R=new J.Vector2(z.uScale,z.vScale),S=new J.Vector2(z.uOffset,z.vOffset),d=z.wAng,mz=Math.sin(d),Z=Math.cos(d);return S.y=1-S.y-R.y,S.x+=mz*R.x,S.y+=(1-Z)*R.y,'\n    def Shader "PrimvarReader_'.concat(U,'"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "').concat(P,'"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_').concat(U,'"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_').concat(u.uniqueId,"/PrimvarReader_").concat(U,".outputs:result>\n        float inputs:rotation = ").concat((d*(180/Math.PI)).toFixed(g.precision),"\n        float2 inputs:scale = ").concat(lu(R),"\n        float2 inputs:translation = ").concat(lu(S),'\n        float2 outputs:result\n    }\n\n    def Shader "Texture_').concat(z.uniqueId,"_").concat(U,'"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_').concat(w,".png@\n        float2 inputs:st.connect = </Materials/Material_").concat(u.uniqueId,"/Transform2d_").concat(U,".outputs:result>\n        ").concat(v?"float4 inputs:scale = "+function(z){return"(".concat(z.r,", ").concat(z.g,", ").concat(z.b,", 1.0)")}(v):"",'\n        token inputs:sourceColorSpace = "').concat(z.gammaSpace?"raw":"sRGB",'"\n        token inputs:wrapS = "').concat(su(z.wrapU),'"\n        token inputs:wrapT = "').concat(su(z.wrapV),'"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ').concat(u.needAlphaBlending()?"float outputs:a":"","\n    }")}function uU(z,u,U){const J="\t\t\t",v=[],f=[],{diffuseMap:g,Mg:w,alphaCutOff:P,emissiveMap:R,emissive:d,normalMap:mz,roughnessMap:Z,roughnessChannel:A,roughness:E,metalnessMap:C,metalnessChannel:M,metalness:T,aoMap:X,aoMapChannel:h,aoMapIntensity:t,alphaMap:V,ior:L,clearCoatEnabled:O,clearCoat:x,clearCoatMap:Q,clearCoatRoughness:K,clearCoatRoughnessMap:Y}=function(z){const u={diffuseMap:null,Mg:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return z instanceof Cz.Mu?(0,S.e)((0,S.e)({},u),{},{diffuseMap:z.diffuseTexture,Mg:z.diffuseColor,alphaCutOff:z.alphaCutOff,emissiveMap:z.emissiveTexture,emissive:z.emissiveColor,roughness:1,alphaMap:z.opacityTexture}):z instanceof Su.c?(0,S.e)((0,S.e)({},u),{},{diffuseMap:z._albedoTexture,Mg:z._albedoColor,alphaCutOff:z._alphaCutOff,emissiveMap:z._emissiveTexture,emissive:z._emissiveColor,normalMap:z._bumpTexture,roughnessMap:z._metallicTexture,roughnessChannel:z._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:null!==(U=z._roughness)&&void 0!==U?U:1,metalnessMap:z._metallicTexture,metalnessChannel:z._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:null!==(J=z._metallic)&&void 0!==J?J:0,aoMap:z._ambientTexture,aoMapChannel:z._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:z._ambientTextureStrength,alphaMap:z._opacityTexture,ior:z.subSurface.indexOfRefraction,clearCoatEnabled:z.clearCoat.isEnabled,clearCoat:z.clearCoat.Cg,clearCoatMap:z.clearCoat.texture,clearCoatRoughness:z.clearCoat.roughness,clearCoatRoughnessMap:z.clearCoat.useRoughnessFromMainTexture?z.clearCoat.texture:z.clearCoat.textureRoughness}):u;var U,J}(z);return null!==g?(v.push("".concat(J,"color3f inputs:diffuseColor.connect = </Materials/Material_").concat(z.uniqueId,"/Texture_").concat(g.uniqueId,"_diffuse.outputs:rgb>")),z.needAlphaBlending()?v.push("".concat(J,"float inputs:opacity.connect = </Materials/Material_").concat(z.uniqueId,"/Texture_").concat(g.uniqueId,"_diffuse.outputs:a>")):z.needAlphaTesting()&&(v.push("".concat(J,"float inputs:opacity.connect = </Materials/Material_").concat(z.uniqueId,"/Texture_").concat(g.uniqueId,"_diffuse.outputs:a>")),v.push("".concat(J,"float inputs:opacityThreshold = ").concat(P))),f.push(zU(g,z,"diffuse",w,u,U))):v.push("".concat(J,"color3f inputs:diffuseColor = ").concat(eu(w||r.Tu.White()))),null!==R?(v.push("".concat(J,"color3f inputs:emissiveColor.connect = </Materials/Material_").concat(z.uniqueId,"/Texture_").concat(R.uniqueId,"_emissive.outputs:rgb>")),f.push(zU(R,z,"emissive",d,u,U))):d&&d.toLuminance()>0&&v.push("".concat(J,"color3f inputs:emissiveColor = ").concat(eu(d))),null!==mz&&(v.push("".concat(J,"normal3f inputs:normal.connect = </Materials/Material_").concat(z.uniqueId,"/Texture_").concat(mz.uniqueId,"_normal.outputs:rgb>")),f.push(zU(mz,z,"normal",null,u,U))),null!==X&&(v.push("".concat(J,"float inputs:occlusion.connect = </Materials/Material_").concat(z.uniqueId,"/Texture_").concat(X.uniqueId,"_occlusion.outputs:").concat(h,">")),f.push(zU(X,z,"occlusion",new r.Tu(t,t,t),u,U))),null!==Z?(v.push("".concat(J,"float inputs:roughness.connect = </Materials/Material_").concat(z.uniqueId,"/Texture_").concat(Z.uniqueId,"_roughness.outputs:").concat(A,">")),f.push(zU(Z,z,"roughness",new r.Tu(E,E,E),u,U))):v.push("".concat(J,"float inputs:roughness = ").concat(E)),null!==C?(v.push("".concat(J,"float inputs:metallic.connect = </Materials/Material_").concat(z.uniqueId,"/Texture_").concat(C.uniqueId,"_metallic.outputs:").concat(M,">")),f.push(zU(C,z,"metallic",new r.Tu(T,T,T),u,U))):v.push("".concat(J,"float inputs:metallic = ").concat(T)),null!==V?(v.push("".concat(J,"float inputs:opacity.connect = </Materials/Material_").concat(z.uniqueId,"/Texture_").concat(V.uniqueId,"_opacity.outputs:r>")),v.push("".concat(J,"float inputs:opacityThreshold = 0.0001")),f.push(zU(V,z,"opacity",null,u,U))):v.push("".concat(J,"float inputs:opacity = ").concat(z.alpha)),O&&(null!==Q?(v.push("".concat(J,"float inputs:clearcoat.connect = </Materials/Material_").concat(z.uniqueId,"/Texture_").concat(Q.uniqueId,"_clearcoat.outputs:r>")),f.push(zU(Q,z,"clearcoat",new r.Tu(x,x,x),u,U))):v.push("".concat(J,"float inputs:clearcoat = ").concat(x)),null!==Y?(v.push("".concat(J,"float inputs:clearcoatRoughness.connect = </Materials/Material_").concat(z.uniqueId,"/Texture_").concat(Y.uniqueId,"_clearcoatRoughness.outputs:g>")),f.push(zU(Y,z,"clearcoatRoughness",new r.Tu(K,K,K),u,U))):v.push("".concat(J,"float inputs:clearcoatRoughness = ").concat(K))),v.push("".concat(J,"float inputs:ior = ").concat(L)),'\n\tdef Material "Material_'.concat(z.uniqueId,'"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n').concat(v.join("\n"),"\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_").concat(z.uniqueId,"/PreviewSurface.outputs:surface>\n\n").concat(f.join("\n"),"\n\n\t}\n")}async function UU(z,u,U){const f=(0,S.e)({fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35},u);"undefined"===typeof fflate&&await v.Tools.LoadScriptAsync(f.fflateUrl);const g={};g[f.modelFileName]=null;let w='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';w+=function(z){const u=!0===z.includeAnchoringProperties?'\n\t\ttoken preliminary:anchoring:type = "'.concat(z.anchoringType,'"\n\t\ttoken preliminary:planeAnchoring:alignment = "').concat(z.planeAnchoringAlignment,'"'):"";return'def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {'.concat(u,"\n            ")}(f);const P={};for(const J of z.meshes){if(0===J.getTotalVertices())continue;const z=J,u=z.nf,R=z.material;if(!R||!u||U&&!U(z))continue;if(-1!==["Mu","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(R.getClassName())){const U="geometries/Geometry_"+u.uniqueId+".usda";if(!(U in g)){const z=au(u,f);g[U]=iu(z)}R.uniqueId in P||(P[R.uniqueId]=R),w+=ou(z)}else v.Tools.Warn("USDZExportAsync does not support this material type: "+R.getClassName())}z.activeCamera&&f.exportCamera&&(w+=function(z,u){const U="Camera_"+z.uniqueId,v=nu(J.Matrix.RotationY(Math.PI).multiply(z.getWorldMatrix()));if(z.mode===L.d.ORTHOGRAPHIC_CAMERA)return'def Camera "'.concat(U,'"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ').concat(v,'\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (').concat(z.Bf.toPrecision(u.precision),", ").concat(z.maxZ.toPrecision(u.precision),")\n\t\t\tfloat horizontalAperture = ").concat((10*(Math.abs(z.orthoLeft||1)+Math.abs(z.orthoRight||1))).toPrecision(u.precision),"\n\t\t\tfloat verticalAperture = ").concat((10*(Math.abs(z.orthoTop||1)+Math.abs(z.orthoBottom||1))).toPrecision(u.precision),'\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t');{const J=z.getEngine().getAspectRatio(z),f=u.cameraSensorWidth||35;return'def Camera "'.concat(U,'"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ').concat(v,'\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (').concat(z.Bf.toPrecision(u.precision),", ").concat(z.maxZ.toPrecision(u.precision),")\n\t\t\tfloat focalLength = ").concat((f/(2*Math.tan(.5*z.fov))).toPrecision(u.precision),'\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ').concat((f*J).toPrecision(u.precision),"\n\t\t\tfloat verticalAperture = ").concat((f/J).toPrecision(u.precision),"            \n\t\t}\n\t\n\t")}}(z.activeCamera,f)),w+="\n            }\n        }\n    }";const R={};w+=function(z,u,U){const J=[];for(const v in z){const f=z[v];J.push(uU(f,u,U))}return'\n    def "Materials"\n{\n'.concat(J.join(""),"\n}\n\n")}(P,R,f),g[f.modelFileName]=fflate.strToU8(w);for(const J in R){const z=R[J],u=z.getSize(),U=await z.readPixels();if(!U)throw new Error("Texture data is not available");const v=await O.DumpTools.DumpDataAsync(u.width,u.height,U,"image/png",void 0,!1,!0);g["textures/Texture_".concat(J,".png")]=new Uint8Array(v).slice()}let d=0;for(const J in g){const z=g[J];if(!z)continue;d+=34+J.length;const u=63&d;if(4!==u){const U=new Uint8Array(64-u);g[J]=[z,{extra:{12345:U}}]}d=z.length}return fflate.zipSync(g,{level:0})}}}]);