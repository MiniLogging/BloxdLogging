"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[26],{12747:(s,Z,o)=>{var t=o(11044),j=o(10955),S=o(10982),a=o(11070),O=o(11013),v=o(11059);O.e.prototype._partialLoadFile=function(s,Z,o,t){let j=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(s,(s=>{o[Z]=s,o._internalCount++,6===o._internalCount&&t(o)}),void 0,void 0,!0,((s,Z)=>{j&&s&&j(s.status+" "+s.statusText,Z)}))},O.e.prototype._cascadeLoadFiles=function(s,Z,o){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const j=[];j._internalCount=0;for(let S=0;S<6;S++)this._partialLoadFile(o[S],S,j,Z,t)},O.e.prototype._cascadeLoadImgs=function(s,Z,o,t){let j=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,S=arguments.length>5?arguments[5]:void 0;const a=[];a._internalCount=0;for(let O=0;O<6;O++)this._partialLoadImg(t[O],O,a,s,Z,o,j,S)},O.e.prototype._partialLoadImg=function(s,Z,o,t,j,O){let v=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,G=arguments.length>7?arguments[7]:void 0;const B=(0,a.c)();(0,S.x)(s,(s=>{o[Z]=s,o._internalCount++,t&&t.removePendingData(B),6===o._internalCount&&O&&O(j,o)}),((s,Z)=>{t&&t.removePendingData(B),v&&v(s,Z)}),t?t.offlineProvider:null,G),t&&t.addPendingData(B)},O.e.prototype.createCubeTextureBase=function(s,Z,o,S){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,G=arguments.length>6?arguments[6]:void 0,B=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,Q=arguments.length>8&&void 0!==arguments[8]&&arguments[8],D=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,z=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,Y=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,b=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,f=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,A=arguments.length>14&&void 0!==arguments[14]&&arguments[14],d=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const U=Y||new t.b(this,7);U.isCube=!0,U.url=s,U.generateMipMaps=!S,U._lodGenerationScale=D,U._lodGenerationOffset=z,U._useSRGBBuffer=!!A&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!S),U!==Y&&(U.label=s.substring(0,60)),this._doNotHandleContextLost||(U._extension=B,U._files=o,U._buffer=d);const u=s;this._transformTextureUrl&&!Y&&(s=this._transformTextureUrl(s));const H=B??function(s){const Z=s.split("?")[0],o=Z.lastIndexOf(".");return o>-1?Z.substring(o).toLowerCase():""}(s),F=(0,v.c)(H),i=(s,Z)=>{U.dispose(),O?O(s,Z):s&&j.b.Warn(s)},N=(t,O)=>{s===u?t&&i(t.status+" "+t.statusText,O):(j.b.Warn(`Failed to load ${s}, falling back to the ${u}`),this.createCubeTextureBase(u,Z,o,!!S,a,i,G,B,Q,D,z,U,b,f,A,d))};if(F)F.then((t=>{const j=s=>{b&&b(U,s),t.loadCubeData(s,U,Q,a,((s,Z)=>{i(s,Z)}))};d?j(d):o&&6===o.length?t.supportCascades?this._cascadeLoadFiles(Z,(s=>j(s.map((s=>new Uint8Array(s))))),o,i):i("Textures type does not support cascades."):this._loadFile(s,(s=>j(new Uint8Array(s))),void 0,void 0,!0,N)}));else{if(!o||0===o.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(Z,U,((s,Z)=>{f&&f(s,Z)}),o,i)}return this._internalTexturesCache.push(U),U}},13498:(s,Z,o)=>{o.d(Z,{DDSTools:()=>Y});var t=o(10935),j=o(10955),S=o(11581),a=o(11405);o(12747);const O=131072,v=131072;function G(s){return s.charCodeAt(0)+(s.charCodeAt(1)<<8)+(s.charCodeAt(2)<<16)+(s.charCodeAt(3)<<24)}const B=G("DXT1"),Q=G("DXT3"),D=G("DXT5"),z=G("DX10");class Y{static GetDDSInfo(s){const Z=new Int32Array(s.buffer,s.byteOffset,31),o=new Int32Array(s.buffer,s.byteOffset,35);let t=1;Z[2]&O&&(t=Math.max(1,Z[7]));const j=Z[21],S=j===z?o[32]:0;let a=0;switch(j){case 113:a=2;break;case 116:a=1;break;case z:if(10===S){a=2;break}if(2===S){a=1;break}}return{width:Z[4],height:Z[3],mipmapCount:t,isFourCC:4===(4&Z[20]),isRGB:64===(64&Z[20]),isLuminance:(Z[20]&v)===v,isCube:512===(512&Z[28]),isCompressed:j===B||j===Q||j===D,dxgiFormat:S,textureType:a}}static _GetHalfFloatAsFloatRGBAArrayBuffer(s,Z,o,t,j,S){const O=new Float32Array(t),v=new Uint16Array(j,o);let G=0;for(let B=0;B<Z;B++)for(let Z=0;Z<s;Z++){const o=4*(Z+B*s);O[G]=(0,a.e)(v[o]),O[G+1]=(0,a.e)(v[o+1]),O[G+2]=(0,a.e)(v[o+2]),Y.StoreLODInAlphaChannel?O[G+3]=S:O[G+3]=(0,a.e)(v[o+3]),G+=4}return O}static _GetHalfFloatRGBAArrayBuffer(s,Z,o,t,j,S){if(Y.StoreLODInAlphaChannel){const O=new Uint16Array(t),v=new Uint16Array(j,o);let G=0;for(let o=0;o<Z;o++)for(let Z=0;Z<s;Z++){const t=4*(Z+o*s);O[G]=v[t],O[G+1]=v[t+1],O[G+2]=v[t+2],O[G+3]=(0,a.k)(S),G+=4}return O}return new Uint16Array(j,o,t)}static _GetFloatRGBAArrayBuffer(s,Z,o,t,j,S){if(Y.StoreLODInAlphaChannel){const a=new Float32Array(t),O=new Float32Array(j,o);let v=0;for(let o=0;o<Z;o++)for(let Z=0;Z<s;Z++){const t=4*(Z+o*s);a[v]=O[t],a[v+1]=O[t+1],a[v+2]=O[t+2],a[v+3]=S,v+=4}return a}return new Float32Array(j,o,t)}static _GetFloatAsHalfFloatRGBAArrayBuffer(s,Z,o,t,j,S){const O=new Uint16Array(t),v=new Float32Array(j,o);let G=0;for(let B=0;B<Z;B++)for(let Z=0;Z<s;Z++)O[G]=(0,a.k)(v[G]),O[G+1]=(0,a.k)(v[G+1]),O[G+2]=(0,a.k)(v[G+2]),Y.StoreLODInAlphaChannel?O[G+3]=(0,a.k)(S):O[G+3]=(0,a.k)(v[G+3]),G+=4;return O}static _GetFloatAsUIntRGBAArrayBuffer(s,Z,o,j,S,a){const O=new Uint8Array(j),v=new Float32Array(S,o);let G=0;for(let B=0;B<Z;B++)for(let Z=0;Z<s;Z++){const o=4*(Z+B*s);O[G]=255*(0,t.Clamp)(v[o]),O[G+1]=255*(0,t.Clamp)(v[o+1]),O[G+2]=255*(0,t.Clamp)(v[o+2]),Y.StoreLODInAlphaChannel?O[G+3]=a:O[G+3]=255*(0,t.Clamp)(v[o+3]),G+=4}return O}static _GetHalfFloatAsUIntRGBAArrayBuffer(s,Z,o,j,S,O){const v=new Uint8Array(j),G=new Uint16Array(S,o);let B=0;for(let Q=0;Q<Z;Q++)for(let Z=0;Z<s;Z++){const o=4*(Z+Q*s);v[B]=255*(0,t.Clamp)((0,a.e)(G[o])),v[B+1]=255*(0,t.Clamp)((0,a.e)(G[o+1])),v[B+2]=255*(0,t.Clamp)((0,a.e)(G[o+2])),Y.StoreLODInAlphaChannel?v[B+3]=O:v[B+3]=255*(0,t.Clamp)((0,a.e)(G[o+3])),B+=4}return v}static _GetRGBAArrayBuffer(s,Z,o,t,j,S,a,O,v){const G=new Uint8Array(t),B=new Uint8Array(j,o);let Q=0;for(let D=0;D<Z;D++)for(let Z=0;Z<s;Z++){const o=4*(Z+D*s);G[Q]=B[o+S],G[Q+1]=B[o+a],G[Q+2]=B[o+O],G[Q+3]=B[o+v],Q+=4}return G}static _ExtractLongWordOrder(s){return 0===s||255===s||-16777216===s?0:1+Y._ExtractLongWordOrder(s>>8)}static _GetRGBArrayBuffer(s,Z,o,t,j,S,a,O){const v=new Uint8Array(t),G=new Uint8Array(j,o);let B=0;for(let Q=0;Q<Z;Q++)for(let Z=0;Z<s;Z++){const o=3*(Z+Q*s);v[B]=G[o+S],v[B+1]=G[o+a],v[B+2]=G[o+O],B+=3}return v}static _GetLuminanceArrayBuffer(s,Z,o,t,j){const S=new Uint8Array(t),a=new Uint8Array(j,o);let O=0;for(let v=0;v<Z;v++)for(let Z=0;Z<s;Z++){const o=Z+v*s;S[O]=a[o],O++}return S}static UploadDDSLevels(s,Z,o,t,a,v){let G=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,b=arguments.length>7?arguments[7]:void 0,f=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],A=null;t.sphericalPolynomial&&(A=[]);const d=!!s.getCaps().s3tc;Z.generateMipMaps=a;const U=new Int32Array(o.buffer,o.byteOffset,31);let u,H,F,i,N,L,V,g=0,l=0,R=1;if(542327876!==U[0])return void j.b.Error("Invalid magic number in DDS header");if(!t.isFourCC&&!t.isRGB&&!t.isLuminance)return void j.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(t.isCompressed&&!d)return void j.b.Error("Compressed textures are not supported on this platform.");let e=U[22];i=U[1]+4;let c=!1;if(t.isFourCC)switch(u=U[21],u){case B:R=8,l=33777;break;case Q:R=16,l=33778;break;case D:R=16,l=33779;break;case 113:c=!0,e=64;break;case 116:c=!0,e=128;break;case z:{i+=20;let s=!1;switch(t.dxgiFormat){case 10:c=!0,e=64,s=!0;break;case 2:c=!0,e=128,s=!0;break;case 88:t.isRGB=!0,t.isFourCC=!1,e=32,s=!0}if(s)break}default:return void j.b.Error(["Unsupported FourCC code:",(w=u,String.fromCharCode(255&w,w>>8&255,w>>16&255,w>>24&255))])}var w;const X=Y._ExtractLongWordOrder(U[23]),W=Y._ExtractLongWordOrder(U[24]),q=Y._ExtractLongWordOrder(U[25]),h=Y._ExtractLongWordOrder(U[26]);c&&(l=s._getRGBABufferInternalSizedFormat(t.textureType)),L=1,U[2]&O&&!1!==a&&(L=Math.max(1,U[7]));const M=b||0,x=s.getCaps();for(let j=M;j<v;j++){for(H=U[4],F=U[3],V=0;V<L;++V){if(-1===G||G===V){const S=-1===G?V:0;if(!t.isCompressed&&t.isFourCC){Z.format=5,g=H*F*4;let t=null;if(s._badOS||s._badDesktopOS||!x.textureHalfFloat&&!x.textureFloat)128===e?(t=Y._GetFloatAsUIntRGBAArrayBuffer(H,F,o.byteOffset+i,g,o.buffer,S),A&&0==S&&A.push(Y._GetFloatRGBAArrayBuffer(H,F,o.byteOffset+i,g,o.buffer,S))):64===e&&(t=Y._GetHalfFloatAsUIntRGBAArrayBuffer(H,F,o.byteOffset+i,g,o.buffer,S),A&&0==S&&A.push(Y._GetHalfFloatAsFloatRGBAArrayBuffer(H,F,o.byteOffset+i,g,o.buffer,S))),Z.type=0;else{const s=x.textureFloat&&(f&&x.textureFloatLinearFiltering||!f),j=x.textureHalfFloat&&(f&&x.textureHalfFloatLinearFiltering||!f),a=(128===e||64===e&&!j)&&s?1:(64===e||128===e&&!s)&&j?2:0;let O,v=null;if(128===e)switch(a){case 1:O=Y._GetFloatRGBAArrayBuffer,v=null;break;case 2:O=Y._GetFloatAsHalfFloatRGBAArrayBuffer,v=Y._GetFloatRGBAArrayBuffer;break;case 0:O=Y._GetFloatAsUIntRGBAArrayBuffer,v=Y._GetFloatRGBAArrayBuffer}else switch(a){case 1:O=Y._GetHalfFloatAsFloatRGBAArrayBuffer,v=null;break;case 2:O=Y._GetHalfFloatRGBAArrayBuffer,v=Y._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:O=Y._GetHalfFloatAsUIntRGBAArrayBuffer,v=Y._GetHalfFloatAsFloatRGBAArrayBuffer}Z.type=a,t=O(H,F,o.byteOffset+i,g,o.buffer,S),A&&0==S&&A.push(v?v(H,F,o.byteOffset+i,g,o.buffer,S):t)}t&&s._uploadDataToTextureDirectly(Z,t,j,S)}else if(t.isRGB)Z.type=0,24===e?(Z.format=4,g=H*F*3,N=Y._GetRGBArrayBuffer(H,F,o.byteOffset+i,g,o.buffer,X,W,q),s._uploadDataToTextureDirectly(Z,N,j,S)):(Z.format=5,g=H*F*4,N=Y._GetRGBAArrayBuffer(H,F,o.byteOffset+i,g,o.buffer,X,W,q,h),s._uploadDataToTextureDirectly(Z,N,j,S));else if(t.isLuminance){const t=s._getUnpackAlignement(),a=H;g=Math.floor((H+t-1)/t)*t*(F-1)+a,N=Y._GetLuminanceArrayBuffer(H,F,o.byteOffset+i,g,o.buffer),Z.format=1,Z.type=0,s._uploadDataToTextureDirectly(Z,N,j,S)}else g=Math.max(4,H)/4*Math.max(4,F)/4*R,N=new Uint8Array(o.buffer,o.byteOffset+i,g),Z.type=0,s._uploadCompressedDataToTextureDirectly(Z,l,H,F,N,j,S)}i+=e?H*F*(e/8):g,H*=.5,F*=.5,H=Math.max(1,H),F=Math.max(1,F)}if(void 0!==b)break}A&&A.length>0?t.sphericalPolynomial=S.b.ConvertCubeMapToSphericalPolynomial({size:U[4],right:A[0],left:A[1],up:A[2],down:A[3],front:A[4],back:A[5],format:5,type:1,gammaSpace:!1}):t.sphericalPolynomial=void 0}}Y.StoreLODInAlphaChannel=!1}}]);