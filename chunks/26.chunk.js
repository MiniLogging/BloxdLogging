"use strict";(self.i6szn8jgzh=self.i6szn8jgzh||[]).push([[26],{12178:(b,n,i)=>{i.r(n),i.d(n,{EXT_materials_diffuse_roughness:()=>Rn,EXT_mesh_gpu_instancing:()=>Sb,GLTF2Export:()=>cb,GLTFData:()=>B,KHR_draco_mesh_compression:()=>en,KHR_lights_punctual:()=>Bn,KHR_materials_anisotropy:()=>Zn,KHR_materials_clearcoat:()=>zn,KHR_materials_diffuse_transmission:()=>On,KHR_materials_dispersion:()=>dn,KHR_materials_emissive_strength:()=>on,KHR_materials_ior:()=>jn,KHR_materials_iridescence:()=>Dn,KHR_materials_sheen:()=>yn,KHR_materials_specular:()=>An,KHR_materials_transmission:()=>Cn,KHR_materials_unlit:()=>wn,KHR_materials_volume:()=>Wn,KHR_texture_transform:()=>rn,OBJExport:()=>U,STLExport:()=>Xn,USDZExportAsync:()=>ii,_ConvertToGLTFPBRMetallicRoughness:()=>C,_SolveMetallic:()=>E,__IGLTFExporterExtension:()=>Y});var e=i(11778),V=i(11605),Q=i(12095);class U{static OBJ(b,n,i,U){const Y=[];let L=1,B=1;n&&(i||(i="mat"),Y.push("mtllib "+i+".mtl"));for(let mb=0;mb<b.length;mb++){const i=b[mb],N=i.name||`mesh${mb}}`;Y.push(`o ${N}`);let Z=null;if(U){const b=i.we(!0);Z=new e.Matrix,b.invertToRef(Z),i.bakeTransformIntoVertices(b)}if(n){const b=i.material;b&&Y.push("usemtl "+b.id)}const T=i.We;if(!T){V.Tools.Warn("No geometry is present on the mesh");continue}const z=T.getVerticesData("position"),K=T.getVerticesData("normal"),I=T.getVerticesData("uv"),O=T.Je();let u=0,d=0;if(!z||!O){V.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const G=b[0].ab().useRightHandedSystem?1:-1;for(let b=0;b<z.length;b+=3)Y.push("v "+z[b]*G+" "+z[b+1]+" "+z[b+2]),u++;if(null!=K)for(let b=0;b<K.length;b+=3)Y.push("vn "+K[b]*G+" "+K[b+1]+" "+K[b+2]);if(null!=I)for(let b=0;b<I.length;b+=2)Y.push("vt "+I[b]+" "+I[b+1]),d++;const o=["","",""],M=(i.material||i.ab().defaultMaterial)._getEffectiveOrientation(i),[j,a]=M===Q.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let b=0;b<O.length;b+=3){const n=[String(O[b]+L),String(O[b+j]+L),String(O[b+a]+L)],i=[String(O[b]+B),String(O[b+j]+B),String(O[b+a]+B)],e=n,V=null!=I?i:o,Q=null!=K?n:o;Y.push("f "+e[0]+"/"+V[0]+"/"+Q[0]+" "+e[1]+"/"+V[1]+"/"+Q[1]+" "+e[2]+"/"+V[2]+"/"+Q[2])}U&&Z&&i.bakeTransformIntoVertices(Z),L+=u,B+=d}return Y.join("\n")}static MTL(b){const n=[],i=b.material;n.push("newmtl mat1"),n.push("  Ns "+i.specularPower.toFixed(4)),n.push("  Ni 1.5000"),n.push("  d "+i.alpha.toFixed(4)),n.push("  Tr 0.0000"),n.push("  Tf 1.0000 1.0000 1.0000"),n.push("  illum 2"),n.push("  Ka "+i.ambientColor.r.toFixed(4)+" "+i.ambientColor.g.toFixed(4)+" "+i.ambientColor.b.toFixed(4)),n.push("  Kd "+i.diffuseColor.r.toFixed(4)+" "+i.diffuseColor.g.toFixed(4)+" "+i.diffuseColor.b.toFixed(4)),n.push("  Ks "+i.specularColor.r.toFixed(4)+" "+i.specularColor.g.toFixed(4)+" "+i.specularColor.b.toFixed(4)),n.push("  Ke "+i.emissiveColor.r.toFixed(4)+" "+i.emissiveColor.g.toFixed(4)+" "+i.emissiveColor.b.toFixed(4));i.ambientTexture&&n.push("  map_Ka "+i.ambientTexture.name),i.diffuseTexture&&n.push("  map_Kd "+i.diffuseTexture.name),i.specularTexture&&n.push("  map_Ks "+i.specularTexture.name),i.bumpTexture&&n.push("  map_bump -imfchan z "+i.bumpTexture.name),i.opacityTexture&&n.push("  map_d "+i.opacityTexture.name);return n.join("\n")}}var Y=0,L=i(11655);class B{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const b in this.files){const n=this.files[b],i=new Blob([n],{type:(0,L.g)(b)});V.Tools.Download(i,b)}}}var mb=i(11842),N=i(12185),Z=i(12190),T=i(12209),z=i(11894),K=i(11646),I=i(11822),O=i(11796);const u=O.HighestCommonFactor,d={...O,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:u};var G=i(11994),o=i(11748),M=i(12244),j=i(12247),a=i(11989);const D=1e-6,x=new I.Mn(.04,.04,.04),y=1024,s=I.Mn.White(),A=I.Mn.Black();function E(b,n,i){if(n<x.r)return 0;const e=x.r,V=b*i/(1-x.r)+n-2*x.r,Q=V*V-4*e*(x.r-n);return d.Clamp((-V+Math.sqrt(Q))/(2*e),0,1)}function C(b){const n=b.diffuseColor.toLinearSpace(b.ab().getEngine().useExactSrgbConversions).scale(.5),i=b.alpha,V=function(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new e.Vector2(0,1),i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new e.Vector2(0,.1),V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new e.Vector2(0,.1),Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new e.Vector2(1300,.1);return function(b,n,i,e,V){return(1-b)*(1-b)*(1-b)*n+3*(1-b)*(1-b)*b*i+3*(1-b)*b*b*e+b*b*b*V}(Math.pow(b/Q.x,.333333),n.y,i.y,V.y,Q.y)}(d.Clamp(b.specularPower,0,y));return{baseColorFactor:[n.r,n.g,n.b,i],metallicFactor:0,roughnessFactor:V}}function t(b,n){n.needAlphaBlending()?b.alphaMode="BLEND":n.needAlphaTesting()&&(b.alphaMode="MASK",b.alphaCutoff=n.alphaCutOff)}function w(b,n,i){const e=new Uint8Array(b*n*4);for(let V=0;V<e.length;V+=4)e[V]=e[V+1]=e[V+2]=e[V+3]=255;return M.d.CreateRGBATexture(e,b,n,i)}function h(b){if(b instanceof Uint8Array){const n=b.length,i=new Float32Array(b.length);for(let e=0;e<n;++e)i[e]=b[e]/255;return i}if(b instanceof Float32Array)return b;throw new Error("Unsupported pixel format!")}class W{constructor(b){this._exporter=b,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(b){return b?this._textureMap.get(b)??null:null}async exportStandardMaterialAsync(b,n,i){const e=C(b),Q={name:b.name};if(null==b.Re||b.Re||(b.twoSidedLighting||V.Tools.Warn(b.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Q.doubleSided=!0),i){const i=[],V=b.diffuseTexture;V&&i.push(this.exportTextureAsync(V,n).then((b=>{b&&(e.baseColorTexture=b)})));const U=b.bumpTexture;U&&i.push(this.exportTextureAsync(U,n).then((b=>{b&&(Q.normalTexture=b,1!==U.level&&(Q.normalTexture.scale=U.level))})));const Y=b.emissiveTexture;Y&&(Q.emissiveFactor=[1,1,1],i.push(this.exportTextureAsync(Y,n).then((b=>{b&&(Q.emissiveTexture=b)}))));const L=b.ambientTexture;L&&i.push(this.exportTextureAsync(L,n).then((b=>{if(b){const n={index:b.index};Q.occlusionTexture=n}}))),i.length>0&&(this._exporter._materialNeedsUVsSet.add(b),await Promise.all(i))}(b.alpha<1||b.opacityTexture)&&(b.alphaMode===j.e.ALPHA_COMBINE?Q.alphaMode="BLEND":V.Tools.Warn(b.name+": glTF 2.0 does not support alpha mode: "+b.alphaMode.toString())),b.emissiveColor&&!b.emissiveColor.equalsWithEpsilon(A,D)&&(Q.emissiveFactor=b.emissiveColor.ye()),Q.pbrMetallicRoughness=e,t(Q,b),await this._finishMaterialAsync(Q,b,n);const U=this._exporter._materials;return U.push(Q),U.length-1}async _finishMaterialAsync(b,n,i){const e=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",b,n),V=[];for(const Q of e)V.push(this.exportTextureAsync(Q,i));await Promise.all(V),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",b,n)}async _getImageDataAsync(b,n,e,V){const Q=j.e.TEXTURETYPE_UNSIGNED_BYTE,U=this._exporter._babylonScene,Y=U.getEngine(),L=Y.createRawTexture(b,n,e,j.e.TEXTUREFORMAT_RGBA,!1,!0,o.e.NEAREST_SAMPLINGMODE,null,Q);Y.isWebGPU?await i.e(51).then(i.bind(i,14334)):await i.e(52).then(i.bind(i,14339)),await G.m.ApplyPostProcess("pass",L,U,Q,j.e.TEXTURE_NEAREST_SAMPLINGMODE,j.e.TEXTUREFORMAT_RGBA);const B=await Y._readTexturePixels(L,n,e);return await a.DumpTools.DumpDataAsync(n,e,B,V,void 0,!0,!0)}_resizeTexturesToSameDimensions(b,n,i){const e=b?b.getSize():{width:0,height:0},V=n?n.getSize():{width:0,height:0};let Q,U;return e.width<V.width?(Q=b&&b instanceof o.e?G.m.CreateResizedCopy(b,V.width,V.height,!0):w(V.width,V.height,i),U=n):e.width>V.width?(U=n&&n instanceof o.e?G.m.CreateResizedCopy(n,e.width,e.height,!0):w(e.width,e.height,i),Q=b):(Q=b,U=n),{texture1:Q,texture2:U}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(b,n,i,e){const V=new Array;if(!b&&!n)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const Q=b?b.ab():n?n.ab():null;if(Q){var U;const Y=this._resizeTexturesToSameDimensions(b,n,Q),L=null===(U=Y.texture1)||void 0===U?void 0:U.getSize();let B,mb;const N=L.width,Z=L.height,T=await Y.texture1.readPixels(),z=await Y.texture2.readPixels();if(!T)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(B=h(T),!z)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");mb=h(z);const K=mb.byteLength,O=new Uint8Array(K),u=new Uint8Array(K),d=4,G=A;let o=0,M=0;for(let b=0;b<Z;++b)for(let n=0;n<N;++n){const e=(N*b+n)*d,V={diffuseColor:new I.Mn(B[e],B[e+1],B[e+2]).toLinearSpace(Q.getEngine().useExactSrgbConversions).multiply(i.diffuseColor),specularColor:new I.Mn(mb[e],mb[e+1],mb[e+2]).toLinearSpace(Q.getEngine().useExactSrgbConversions).multiply(i.specularColor),glossiness:mb[e+3]*i.glossiness},U=this._convertSpecularGlossinessToMetallicRoughness(V);G.r=Math.max(G.r,U.baseColor.r),G.g=Math.max(G.g,U.baseColor.g),G.b=Math.max(G.b,U.baseColor.b),o=Math.max(o,U.metallic),M=Math.max(M,U.roughness),u[e]=255*U.baseColor.r,u[e+1]=255*U.baseColor.g,u[e+2]=255*U.baseColor.b,u[e+3]=Y.texture1.se?255*B[e+3]:255,O[e]=0,O[e+1]=255*U.roughness,O[e+2]=255*U.metallic,O[e+3]=255}const j={baseColor:G,metallic:o,roughness:M};let a=!1,x=!1;for(let b=0;b<Z;++b)for(let n=0;n<N;++n){const i=(N*b+n)*d;u[i]/=j.baseColor.r>D?j.baseColor.r:1,u[i+1]/=j.baseColor.g>D?j.baseColor.g:1,u[i+2]/=j.baseColor.b>D?j.baseColor.b:1;const e=I.Mn.FromInts(u[i],u[i+1],u[i+2]).toGammaSpace(Q.getEngine().useExactSrgbConversions);u[i]=255*e.r,u[i+1]=255*e.g,u[i+2]=255*e.b,e.equalsWithEpsilon(s,D)||(x=!0),O[i+1]/=j.roughness>D?j.roughness:1,O[i+2]/=j.metallic>D?j.metallic:1;I.Mn.FromInts(255,O[i+1],O[i+2]).equalsWithEpsilon(s,D)||(a=!0)}return a&&V.push(this._getImageDataAsync(O,N,Z,e).then((b=>{j.metallicRoughnessTextureData=b}))),x&&V.push(this._getImageDataAsync(u,N,Z,e).then((b=>{j.baseColorTextureData=b}))),await Promise.all(V).then((()=>j))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(b){const n=this._getPerceivedBrightness(b.diffuseColor),i=this._getPerceivedBrightness(b.specularColor),e=1-this._getMaxComponent(b.specularColor),V=E(n,i,e),Q=b.diffuseColor.scale(e/(1-x.r)/Math.max(1-V)),U=b.specularColor.un(x.scale(1-V)).scale(1/Math.max(V));let Y=I.Mn.Lerp(Q,U,V*V);Y=Y.clampToRef(0,1,Y);return{baseColor:Y,metallic:V,roughness:1-b.glossiness}}_getPerceivedBrightness(b){return b?Math.sqrt(.299*b.r*b.r+.587*b.g*b.g+.114*b.b*b.b):0}_getMaxComponent(b){return b?Math.max(b.r,Math.max(b.g,b.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(b,n,i,e){const V=[],Q={baseColor:b._albedoColor,metallic:b._metallic,roughness:b._roughness};if(e){b._albedoTexture&&V.push(this.exportTextureAsync(b._albedoTexture,n).then((b=>{b&&(i.baseColorTexture=b)})));const e=b._metallicTexture;e&&V.push(this.exportTextureAsync(e,n).then((b=>{b&&(i.metallicRoughnessTexture=b)})))}return V.length>0&&(this._exporter._materialNeedsUVsSet.add(b),await Promise.all(V)),Q}_getTextureSampler(b){const n={};if(!b||!(b instanceof o.e))return n;const i=this._getGLTFTextureWrapMode(b.wrapU);10497!==i&&(n.wrapS=i);const e=this._getGLTFTextureWrapMode(b.wrapV);switch(10497!==e&&(n.wrapT=e),b.samplingMode){case o.e.LINEAR_LINEAR:n.magFilter=9729,n.minFilter=9729;break;case o.e.LINEAR_NEAREST:n.magFilter=9729,n.minFilter=9728;break;case o.e.NEAREST_LINEAR:n.magFilter=9728,n.minFilter=9729;break;case o.e.NEAREST_LINEAR_MIPLINEAR:n.magFilter=9728,n.minFilter=9987;break;case o.e.NEAREST_NEAREST:n.magFilter=9728,n.minFilter=9728;break;case o.e.NEAREST_LINEAR_MIPNEAREST:n.magFilter=9728,n.minFilter=9985;break;case o.e.LINEAR_NEAREST_MIPNEAREST:n.magFilter=9729,n.minFilter=9984;break;case o.e.LINEAR_NEAREST_MIPLINEAR:n.magFilter=9729,n.minFilter=9986;break;case o.e.NEAREST_NEAREST_MIPLINEAR:n.magFilter=9728,n.minFilter=9986;break;case o.e.LINEAR_LINEAR_MIPLINEAR:n.magFilter=9729,n.minFilter=9987;break;case o.e.LINEAR_LINEAR_MIPNEAREST:n.magFilter=9729,n.minFilter=9985;break;case o.e.NEAREST_NEAREST_MIPNEAREST:n.magFilter=9728,n.minFilter=9984}return n}_getGLTFTextureWrapMode(b){switch(b){case o.e.WRAP_ADDRESSMODE:return 10497;case o.e.CLAMP_ADDRESSMODE:return 33071;case o.e.MIRROR_ADDRESSMODE:return 33648;default:return V.Tools.Error(`Unsupported Texture Wrap Mode ${b}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(b,n,i,e){const V={diffuseColor:b._albedoColor,specularColor:b._reflectivityColor,glossiness:b._microSurface},Q=b._albedoTexture,U=b._reflectivityTexture,Y=b._useMicroSurfaceFromReflectivityMapAlpha;if(U&&!Y)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((Q||U)&&e){this._exporter._materialNeedsUVsSet.add(b);const e=this._exportTextureSampler(Q||U),Y=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Q,U,V,n),L=this._exporter._textures;if(Y.baseColorTextureData){const b=this._exportImage(`baseColor${L.length}`,n,Y.baseColorTextureData);i.baseColorTexture=this._exportTextureInfo(b,e,null===Q||void 0===Q?void 0:Q.coordinatesIndex)}if(Y.metallicRoughnessTextureData){const b=this._exportImage(`metallicRoughness${L.length}`,n,Y.metallicRoughnessTextureData);i.metallicRoughnessTexture=this._exportTextureInfo(b,e,null===U||void 0===U?void 0:U.coordinatesIndex)}return Y}return this._convertSpecularGlossinessToMetallicRoughness(V)}async exportPBRMaterialAsync(b,n,i){const e={},V={name:b.name},Q=b.isMetallicWorkflow();if(Q){const n=b._albedoColor,i=b.alpha;n&&(e.baseColorFactor=[n.r,n.g,n.b,i])}const U=Q?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(b,n,e,i):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(b,n,e,i);await this._setMetallicRoughnessPbrMaterialAsync(U,b,V,e,n,i),await this._finishMaterialAsync(V,b,n);const Y=this._exporter._materials;return Y.push(V),Y.length-1}async _setMetallicRoughnessPbrMaterialAsync(b,n,i,e,Q,U){if(t(i,n),b.baseColor.equalsWithEpsilon(s,D)&&d.WithinEpsilon(n.alpha,1,D)||(e.baseColorFactor=[b.baseColor.r,b.baseColor.g,b.baseColor.b,n.alpha]),null!=b.metallic&&1!==b.metallic&&(e.metallicFactor=b.metallic),null!=b.roughness&&1!==b.roughness&&(e.roughnessFactor=b.roughness),null==n.Re||n.Re||(n._twoSidedLighting||V.Tools.Warn(n.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),i.doubleSided=!0),U){const b=[],e=n._bumpTexture;e&&b.push(this.exportTextureAsync(e,Q).then((b=>{b&&(i.normalTexture=b,1!==e.level&&(i.normalTexture.scale=e.level))})));const V=n._ambientTexture;V&&b.push(this.exportTextureAsync(V,Q).then((b=>{if(b){const e={index:b.index,texCoord:b.texCoord,extensions:b.extensions};i.occlusionTexture=e;const V=n._ambientTextureStrength;V&&(e.strength=V)}})));const U=n._emissiveTexture;U&&b.push(this.exportTextureAsync(U,Q).then((b=>{b&&(i.emissiveTexture=b)}))),b.length>0&&(this._exporter._materialNeedsUVsSet.add(n),await Promise.all(b))}const Y=n._emissiveColor;Y.equalsWithEpsilon(A,D)||(i.emissiveFactor=Y.ye()),i.pbrMetallicRoughness=e}_getPixelsFromTextureAsync(b){return function(b){switch(b){case j.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case j.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case j.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case j.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case j.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case j.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case j.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case j.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case j.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case j.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case j.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case j.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case j.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case j.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case j.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case j.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case j.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case j.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case j.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case j.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case j.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(b.textureFormat)?(0,G.i)(b,b._texture.width,b._texture.height):(b.textureType,j.e.TEXTURETYPE_UNSIGNED_BYTE,b.readPixels())}async exportTextureAsync(b,n){const i=this._exporter._extensionsPreExportTextureAsync("exporter",b,n);return i?await i.then((async i=>i?await this._exportTextureInfoAsync(i,n):await this._exportTextureInfoAsync(b,n))):await this._exportTextureInfoAsync(b,n)}async _exportTextureInfoAsync(b,n){let i=this._textureMap.get(b);if(!i){const e=await this._getPixelsFromTextureAsync(b);if(!e)return null;const Q=this._exportTextureSampler(b),U=b.mimeType;if(U)switch(U){case"image/jpeg":case"image/png":case"image/webp":n=U;break;default:V.Tools.Warn(`Unsupported media type: ${U}. Exporting texture as PNG.`)}const Y=this._internalTextureToImage,L=b.getInternalTexture().uniqueId;Y[L]||(Y[L]={});let B=Y[L][n];if(void 0===B){const i=b.getSize();B=(async()=>{const V=await this._getImageDataAsync(e,i.width,i.height,n);return this._exportImage(b.name,n,V)})(),Y[L][n]=B}i=this._exportTextureInfo(await B,Q,b.coordinatesIndex),this._textureMap.set(b,i),this._exporter._extensionsPostExportTextures("exporter",i,b)}return i}_exportImage(b,n,i){const e=this._exporter._images;let Q;if(this._exporter._shouldUseGlb){Q={name:b,mimeType:n,bufferView:void 0};const e=this._exporter._bufferManager.createBufferView(new Uint8Array(i));this._exporter._bufferManager.setBufferView(Q,e)}else{const U=b.replace(/\.\/|\/|\.\\|\\/g,"_"),Y=function(b){switch(b){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(n);let L=U+Y;e.some((b=>b.uri===L))&&(L=`${U}_${V.Tools.RandomId()}${Y}`),Q={name:b,uri:L},this._exporter._imageData[L]={data:i,mimeType:n}}return e.push(Q),e.length-1}_exportTextureInfo(b,n,i){const e=this._exporter._textures;let V=e.findIndex((i=>i.sampler==n&&i.source===b));-1===V&&(V=e.length,e.push({source:b,sampler:n}));const Q={index:V};return i&&(Q.texCoord=i),Q}_exportTextureSampler(b){const n=this._getTextureSampler(b),i=this._exporter._samplers,e=i.findIndex((b=>b.minFilter===n.minFilter&&b.magFilter===n.magFilter&&b.wrapS===n.wrapS&&b.wrapT===n.wrapT));return-1!==e?e:(i.push(n),i.length-1)}}var J=i(11854),R=i(11621),k=i(12252),r=i(11786);const X=e.On.Zero(),g=e.Quaternion.Identity(),P=e.On.One(),c=new e.On(-1,1,1);function q(b,n){const{byteOffset:i,byteStride:e,type:V,normalized:Q}=b,U=b.getSize(),Y=n.reduce(((b,n)=>n.getTotalVertices()>b?n.getTotalVertices():b),-Number.MAX_VALUE);return{byteOffset:i,byteStride:e,componentCount:U,type:V,count:Y*U,normalized:Q,totalVertices:Y,kind:b.getKind()}}function S(b){switch(b){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function H(b){switch(b){case mb.g.PositionKind:case mb.g.NormalKind:case mb.g.TangentKind:case mb.g.ColorKind:case mb.g.MatricesIndicesKind:case mb.g.MatricesIndicesExtraKind:case mb.g.MatricesWeightsKind:case mb.g.MatricesWeightsExtraKind:case mb.g.UVKind:case mb.g.UV2Kind:case mb.g.UV3Kind:case mb.g.UV4Kind:case mb.g.UV5Kind:case mb.g.UV6Kind:return!0}return!1}function l(b){switch(b){case Q.b.TriangleFillMode:return 4;case Q.b.TriangleStripDrawMode:return 5;case Q.b.TriangleFanDrawMode:return 6;case Q.b.PointListDrawMode:case Q.b.PointFillMode:return 0;case Q.b.LineLoopDrawMode:return 2;case Q.b.LineListDrawMode:return 1;case Q.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${b}`)}function v(b){const n=Math.sqrt(b.x*b.x+b.y*b.y+b.z*b.z);n>0&&(b.x/=n,b.y/=n,b.z/=n)}function p(b){return b.x*=-1,b}function f(b){if(b.x*b.x+b.y*b.y>.5){const n=Math.abs(b.x),i=Math.abs(b.y);if(n>i){const i=Math.sign(b.x);b.x=n,b.y*=-i,b.z*=-i,b.w*=i}else{const n=Math.sign(b.y);b.x*=-n,b.y=i,b.z*=n,b.w*=-n}}else{const n=Math.abs(b.z),i=Math.abs(b.w);if(n>i){const i=Math.sign(b.z);b.x*=-i,b.y*=i,b.z=n,b.w*=-i}else{const n=Math.sign(b.w);b.x*=n,b.y*=-n,b.z*=-n,b.w=i}}return b}function F(b){b.re(-b.z,b.w,b.x,-b.y)}function bb(b,n){const i=e.On.FromArrayToRef(n.translation||[0,0,0],0,e.TmpVectors.On[0]),V=e.Quaternion.FromArrayToRef(n.rotation||[0,0,0,1],0,e.TmpVectors.Quaternion[0]),Q=e.Matrix.ComposeToRef(P,V,i,e.TmpVectors.Matrix[0]),U=e.On.FromArrayToRef(b.translation||[0,0,0],0,e.TmpVectors.On[2]),Y=e.Quaternion.FromArrayToRef(b.rotation||[0,0,0,1],0,e.TmpVectors.Quaternion[1]),L=e.Matrix.ComposeToRef(P,Y,U,e.TmpVectors.Matrix[1]);Q.multiplyToRef(L,L),L.decompose(void 0,V,i),i.equalsWithEpsilon(X,r.c)?delete n.translation:n.translation=i.ye(),V.equalsWithEpsilon(g,r.c)?delete n.rotation:n.rotation=V.ye(),n.scale&&delete n.scale}function nb(b,n){if(!(n instanceof N.e))return!1;if(!(1===n.getChildren().length&&0===b.getChildren().length&&b.parent===n))return!1;const i=b.ab(),e=b instanceof k.b&&!i.useRightHandedSystem?c:P;return!!n.ge.equalsWithEpsilon(e,r.c)||(R.b.Warn(`Cannot collapse node ${b.name} into parent node ${n.name} with modified scaling.`),!1)}function ib(b){if(b instanceof Array){const n=new Float32Array(b);return new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}return ArrayBuffer.isView(b)?new Uint8Array(b.buffer,b.byteOffset,b.byteLength):new Uint8Array(b)}function eb(b,n){for(const[i,e]of Object.entries(b)){const V=n[i];(Array.isArray(e)&&Array.isArray(V)&&Vb(e,V)||e===V)&&delete b[i]}return b}function Vb(b,n){return b.length===n.length&&b.every(((b,i)=>b===n[i]))}const Qb=e.Matrix.Compose(new e.On(-1,1,1),e.Quaternion.Identity(),e.On.Zero());function Ub(b,n){if(!(b instanceof N.e))return!1;if(n){if(!b.getWorldMatrix().equalsWithEpsilon(e.Matrix.IdentityReadOnly,r.c))return!1}else{if(!b.getWorldMatrix().multiplyToRef(Qb,e.TmpVectors.Matrix[0]).equalsWithEpsilon(e.Matrix.IdentityReadOnly,r.c))return!1}return!(b instanceof Z.d&&b.We)}const Yb=new Map([[Int8Array,(b,n,i)=>b.setInt8(n,i)],[Uint8Array,(b,n,i)=>b.setUint8(n,i)],[Uint8ClampedArray,(b,n,i)=>b.setUint8(n,i)],[Int16Array,(b,n,i)=>b.setInt16(n,i,!0)],[Uint16Array,(b,n,i)=>b.setUint16(n,i,!0)],[Int32Array,(b,n,i)=>b.setInt32(n,i,!0)],[Uint32Array,(b,n,i)=>b.setUint32(n,i,!0)],[Float32Array,(b,n,i)=>b.setFloat32(n,i,!0)],[Float64Array,(b,n,i)=>b.setFloat64(n,i,!0)]]);class Lb{writeTypedArray(b){this._checkGrowBuffer(b.byteLength);const n=Yb.get(b.constructor);for(let i=0;i<b.length;i++)n(this._dataView,this._byteOffset,b[i]),this._byteOffset+=b.BYTES_PER_ELEMENT}constructor(b){this._data=new Uint8Array(b),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(b){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,b),this._byteOffset++}writeInt8(b){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,b),this._byteOffset++}writeInt16(b){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,b,!0),this._byteOffset+=2}writeUInt16(b){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,b,!0),this._byteOffset+=2}writeInt32(b){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,b,!0),this._byteOffset+=4}writeUInt32(b){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,b,!0),this._byteOffset+=4}writeFloat32(b){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,b,!0),this._byteOffset+=4}writeFloat64(b){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,b,!0),this._byteOffset+=8}_checkGrowBuffer(b){const n=this.byteOffset+b;if(n>this._data.byteLength){const b=new Uint8Array(2*n);b.set(this._data),this._data=b,this._dataView=new DataView(this._data.buffer)}}}function Bb(b){return b%4===0?4:b%2===0?2:1}class mn{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(b){let n=0;this._bufferViewToData.forEach((b=>{n+=b.byteLength}));const i=new Lb(n),e=Array.from(this._bufferViewToData.keys()).sort(((b,n)=>Bb(n.byteLength)-Bb(b.byteLength)));for(const V of e){V.byteOffset=i.byteOffset,b.push(V);const n=b.length-1,e=this.getPropertiesWithBufferView(V);for(const b of e)b.bufferView=n;i.writeTypedArray(this._bufferViewToData.get(V)),this._bufferViewToData.delete(V)}return i.getOutputData()}createBufferView(b,n){const i={buffer:0,byteOffset:void 0,byteLength:b.byteLength,byteStride:n};return this._bufferViewToData.set(i,b),i}createAccessor(b,n,i,e,V,Q,U){this._verifyBufferView(b);const Y={bufferView:void 0,componentType:i,count:e,type:n,min:null===Q||void 0===Q?void 0:Q.min,max:null===Q||void 0===Q?void 0:Q.max,normalized:U,byteOffset:V};return this.setBufferView(Y,b),this._accessorToBufferView.set(Y,b),Y}setBufferView(b,n){this._verifyBufferView(n);this.getPropertiesWithBufferView(n).push(b)}removeBufferView(b){const n=this.getPropertiesWithBufferView(b);for(const i of n)void 0!==i.bufferView&&delete i.bufferView;this._bufferViewToData.delete(b),this._bufferViewToProperties.delete(b),this._accessorToBufferView.forEach(((n,i)=>{n===b&&(void 0!==i.byteOffset&&delete i.byteOffset,this._accessorToBufferView.delete(i))}))}getBufferView(b){const n=this._accessorToBufferView.get(b);return this._verifyBufferView(n),n}getPropertiesWithBufferView(b){return this._verifyBufferView(b),this._bufferViewToProperties.set(b,this._bufferViewToProperties.get(b)??[]),this._bufferViewToProperties.get(b)}getData(b){return this._verifyBufferView(b),this._bufferViewToData.get(b)}_verifyBufferView(b){if(void 0===b||!this._bufferViewToData.has(b))throw new Error(`BufferView ${b} not found in BufferManager.`)}}var Nb,Zb=i(12222),Tb=i(12235),zb=i(12261),Kb=i(12151),Ib=i(12301),Ob=i(12310),ub=i(12215),db=i(12317);!function(b){b[b.INTANGENT=0]="INTANGENT",b[b.OUTTANGENT=1]="OUTTANGENT"}(Nb||(Nb={}));class Gb{static _IsTransformable(b){return b&&(b instanceof N.e||b instanceof Zb.c||b instanceof db.c)}static _CreateNodeAnimation(b,n,i,e,Q){if(this._IsTransformable(b)){const U=[],Y=[],L=n.getKeys(),B=Gb._CalculateMinMaxKeyFrames(L),mb=Gb._DeduceInterpolation(L,i,e),N=mb.interpolationType,Z=mb.shouldBakeAnimation;if(Z?Gb._CreateBakedAnimation(b,n,i,B.min,B.max,n.framePerSecond,Q,U,Y,B,e):"LINEAR"===N||"STEP"===N?Gb._CreateLinearOrStepAnimation(b,n,i,U,Y,e):"CUBICSPLINE"===N?Gb._CreateCubicSplineAnimation(b,n,i,U,Y,e):Gb._CreateBakedAnimation(b,n,i,B.min,B.max,n.framePerSecond,Q,U,Y,B,e),U.length&&Y.length){return{inputs:U,outputs:Y,samplerInterpolation:N,inputsMin:Z?B.min:V.Tools.FloatRound(B.min/n.framePerSecond),inputsMax:Z?B.max:V.Tools.FloatRound(B.max/n.framePerSecond)}}}return null}static _DeduceAnimationInfo(b){let n=null,i="VEC3",e=!1;const Q=b.targetProperty.split(".");switch(Q[0]){case"ge":n="scale";break;case"position":n="translation";break;case"rotation":i="VEC4",n="rotation";break;case"rotationQuaternion":i="VEC4",e=!0,n="rotation";break;case"influence":i="SCALAR",n="weights";break;default:V.Tools.Error(`Unsupported animatable property ${Q[0]}`)}return n?{animationChannelTargetPath:n,dataAccessorType:i,useQuaternion:e}:(V.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(b,n,i,e,V,Q,U,Y,L,B,mb){let N;if(Gb._IsTransformable(b)&&b.animations)for(const Z of b.animations){if(mb&&!mb(Z))continue;const V=Gb._DeduceAnimationInfo(Z);V&&(N={name:Z.name,samplers:[],channels:[]},Gb._AddAnimation(`${Z.name}`,Z.hasRunningRuntimeAnimations?n:N,b,Z,V.dataAccessorType,V.animationChannelTargetPath,e,Q,U,Y,V.useQuaternion,L,B),N.samplers.length&&N.channels.length&&i.push(N))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(b,n,i,e,V,Q,U,Y,L,B,mb){let N;if(b instanceof ub.b){const V=b.morphTargetManager;if(V)for(let Z=0;Z<V.numTargets;++Z){const T=V.getTarget(Z);for(const z of T.animations){if(mb&&!mb(z))continue;const T=new Ib.c(`${z.name}`,"influence",z.framePerSecond,z.dataType,z.loopMode,z.enableBlending),K=[],I=z.getKeys();for(let b=0;b<I.length;++b){const n=I[b];for(let b=0;b<V.numTargets;++b)b==Z?K.push(n):K.push({frame:n.frame,value:0})}T.setKeys(K);const O=Gb._DeduceAnimationInfo(T);O&&(N={name:T.name,samplers:[],channels:[]},Gb._AddAnimation(z.name,z.hasRunningRuntimeAnimations?n:N,b,T,O.dataAccessorType,O.animationChannelTargetPath,e,Q,U,Y,O.useQuaternion,L,B,V.numTargets),N.samplers.length&&N.channels.length&&i.push(N))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(b,n,i,e,V,Q,U,Y,L){let B;if(b.animationGroups){const N=b.animationGroups;for(const Z of N){const N=new Map,T=new Map,z=new Set,K=Z.to-Z.from;B={name:Z.name,channels:[],samplers:[]};for(let n=0;n<Z.targetedAnimations.length;++n){const K=Z.targetedAnimations[n],I=K.target,O=K.animation;if(L&&!L(O))continue;const u=Y.has(I);if(this._IsTransformable(I)||1===I.length&&this._IsTransformable(I[0])){const b=Gb._DeduceAnimationInfo(K.animation);if(b){const n=this._IsTransformable(I)?I:this._IsTransformable(I[0])?I[0]:null;n&&Gb._AddAnimation(`${O.name}`,B,n,O,b.dataAccessorType,b.animationChannelTargetPath,i,e,V,Q,b.useQuaternion,U,u)}}else if(I instanceof Ob.c||1===I.length&&I[0]instanceof Ob.c){if(Gb._DeduceAnimationInfo(K.animation)){const n=I instanceof Ob.c?I:I[0];if(n){const i=b.morphTargetManagers.find((b=>{for(let i=0;i<b.numTargets;++i)if(b.getTarget(i)===n)return!0;return!1}));if(i){const e=b.meshes.find((b=>b.morphTargetManager===i));var mb;if(e)N.has(e)||N.set(e,new Map),null===(mb=N.get(e))||void 0===mb||mb.set(n,O),z.add(e),T.set(e,O)}}}}}z.forEach((b=>{const n=b.morphTargetManager;let Y=null;const L=[],mb=T.get(b).getKeys(),z=mb.length;for(let i=0;i<z;++i)for(let e=0;e<n.numTargets;++e){const V=n.getTarget(e),Q=N.get(b);if(Q){const n=Q.get(V);n?(Y||(Y=new Ib.c(`${Z.name}_${b.name}_MorphWeightAnimation`,"influence",n.framePerSecond,Ib.c.ANIMATIONTYPE_FLOAT,n.loopMode,n.enableBlending)),L.push(n.getKeys()[i])):L.push({frame:Z.from+K/z*i,value:V.influence,inTangent:mb[0].inTangent?0:void 0,outTangent:mb[0].outTangent?0:void 0})}}Y.setKeys(L);const I=Gb._DeduceAnimationInfo(Y);I&&Gb._AddAnimation(`${Z.name}_${b.name}_MorphWeightAnimation`,B,b,Y,I.dataAccessorType,I.animationChannelTargetPath,i,e,V,Q,I.useQuaternion,U,!1,null===n||void 0===n?void 0:n.numTargets)})),B.channels.length&&B.samplers.length&&n.push(B)}}}static _AddAnimation(b,n,i,V,Q,U,Y,L,B,mb,N,Z,T,z){const K=Gb._CreateNodeAnimation(i,V,U,N,Z);let I,O,u,d,G,o;if(K){if(z){let b=0,n=0;const i=[];for(;K.inputs.length>0;)n=K.inputs.shift(),b%z==0&&i.push(n),b++;K.inputs=i}const b=Y.get(i),V=new Float32Array(K.inputs);I=L.createBufferView(V),O=L.createAccessor(I,"SCALAR",5126,K.inputs.length,void 0,{min:[K.inputsMin],max:[K.inputsMax]}),mb.push(O),u=mb.length-1;const B=new e.Quaternion,N=new e.On,Z=new e.On,M=i instanceof Zb.c,j=S(Q),a=new Float32Array(K.outputs.length*j);K.outputs.forEach((function(b,n){let i=b;switch(U){case"translation":T&&(e.On.FromArrayToRef(b,0,Z),p(Z),Z.toArray(i));break;case"rotation":4===b.length?e.Quaternion.FromArrayToRef(b,0,B):(i=new Array(4),e.On.FromArrayToRef(b,0,N),e.Quaternion.FromEulerVectorToRef(N,B)),T&&(f(B),M&&F(B)),B.toArray(i)}a.set(i,n*j)})),I=L.createBufferView(a),O=L.createAccessor(I,Q,5126,K.outputs.length),mb.push(O),d=mb.length-1,G={interpolation:K.samplerInterpolation,input:u,output:d},n.samplers.push(G),o={sampler:n.samplers.length-1,target:{node:b,path:U}},n.channels.push(o)}}static _CreateBakedAnimation(b,n,i,Q,U,Y,L,B,mb,N,Z){let T;const z=e.Quaternion.Identity();let K,I=null,O=null,u=null,d=null,G=null,o=null;N.min=V.Tools.FloatRound(Q/Y);const M=n.getKeys();for(let e=0,j=M.length;e<j;++e){if(o=null,u=M[e],e+1<j)if(d=M[e+1],u.value.equals&&u.value.equals(d.value)||u.value===d.value){if(0!==e)continue;o=u.frame}else o=d.frame;else{if(G=M[e-1],u.value.equals&&u.value.equals(G.value)||u.value===G.value)continue;o=U}if(o)for(let e=u.frame;e<=o;e+=L){if(K=V.Tools.FloatRound(e/Y),K===I)continue;I=K,O=K;const Q={key:0,repeatCount:0,loopMode:n.loopMode};T=n._interpolate(e,Q),Gb._SetInterpolatedValue(b,T,K,n,i,z,B,mb,Z)}}O&&(N.max=O)}static _ConvertFactorToVector3OrQuaternion(b,n,i,Q,U){const Y=Gb._GetBasePositionRotationOrScale(n,Q,U),L=i.targetProperty.split("."),B=L?L[1]:"",mb=U?e.Quaternion.jn(Y).normalize():e.On.jn(Y);switch(B){case"x":case"y":case"z":mb[B]=b;break;case"w":mb.w=b;break;default:V.Tools.Error(`glTFAnimation: Unsupported component name "${B}"!`)}return mb}static _SetInterpolatedValue(b,n,i,V,Q,U,Y,L,B){let mb;Y.push(i),"weights"!==Q?(V.dataType===Ib.c.ANIMATIONTYPE_FLOAT&&(n=this._ConvertFactorToVector3OrQuaternion(n,b,V,Q,B)),"rotation"===Q?(B?U=n:(mb=n,e.Quaternion.RotationYawPitchRollToRef(mb.y,mb.x,mb.z,U)),L.push(U.ye())):(mb=n,L.push(mb.ye()))):L.push([n])}static _CreateLinearOrStepAnimation(b,n,i,e,V,Q){for(const U of n.getKeys())e.push(U.frame/n.framePerSecond),Gb._AddKeyframeValue(U,n,V,i,b,Q)}static _CreateCubicSplineAnimation(b,n,i,e,V,Q){n.getKeys().forEach((function(U){e.push(U.frame/n.framePerSecond),Gb._AddSplineTangent(Nb.INTANGENT,V,i,"CUBICSPLINE",U,Q),Gb._AddKeyframeValue(U,n,V,i,b,Q),Gb._AddSplineTangent(Nb.OUTTANGENT,V,i,"CUBICSPLINE",U,Q)}))}static _GetBasePositionRotationOrScale(b,n,i){let V;if("rotation"===n)if(i){V=(b.rotationQuaternion??e.Quaternion.Identity()).ye()}else{V=(b.rotation??e.On.Zero()).ye()}else if("translation"===n){V=(b.position??e.On.Zero()).ye()}else{V=(b.ge??e.On.One()).ye()}return V}static _AddKeyframeValue(b,n,i,Q,U,Y){let L;const B=n.dataType;if(B===Ib.c.ANIMATIONTYPE_VECTOR3){let n=b.value.ye();if("rotation"===Q){const b=e.On.jn(n);n=e.Quaternion.RotationYawPitchRoll(b.y,b.x,b.z).ye()}i.push(n)}else if(B===Ib.c.ANIMATIONTYPE_FLOAT){if("weights"===Q)i.push([b.value]);else if(L=this._ConvertFactorToVector3OrQuaternion(b.value,U,n,Q,Y),L){if("rotation"===Q){const b=Y?L:e.Quaternion.RotationYawPitchRoll(L.y,L.x,L.z).normalize();i.push(b.ye())}i.push(L.ye())}}else B===Ib.c.ANIMATIONTYPE_QUATERNION?i.push(b.value.normalize().ye()):V.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(b,n,i){let e,V,Q=!1;if("rotation"===n&&!i)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let U=0,Y=b.length;U<Y;++U)if(V=b[U],V.inTangent||V.outTangent)if(e){if("CUBICSPLINE"!==e){e="LINEAR",Q=!0;break}}else e="CUBICSPLINE";else if(e){if("CUBICSPLINE"===e||V.interpolation&&1===V.interpolation&&"STEP"!==e){e="LINEAR",Q=!0;break}}else e=V.interpolation&&1===V.interpolation?"STEP":"LINEAR";return e||(e="LINEAR"),{interpolationType:e,shouldBakeAnimation:Q}}static _AddSplineTangent(b,n,i,V,Q,U){let Y;const L=b===Nb.INTANGENT?Q.inTangent:Q.outTangent;if("CUBICSPLINE"===V){if("rotation"===i)if(L)if(U)Y=L.ye();else{const b=L;Y=e.Quaternion.RotationYawPitchRoll(b.y,b.x,b.z).ye()}else Y=[0,0,0,0];else Y="weights"===i?L?[L]:[0]:L?L.ye():[0,0,0];n.push(Y)}}static _CalculateMinMaxKeyFrames(b){let n=1/0,i=-1/0;return b.forEach((function(b){n=Math.min(n,b.frame),i=Math.max(i,b.frame)})),{min:n,max:i}}}function ob(b,n,i,Q,U,Y){const L={attributes:{},influence:b.influence,name:b.name},B=n.We;if(!B)return V.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),L;const N=Y?-1:1,Z=e.On.Zero();let T=0,z=0;if(b.hasPositions){const Q=b.getPositions(),Y=B.getVerticesData(mb.g.PositionKind);if(Y){const b=new Float32Array(Y.length),n=[1/0,1/0,1/0],V=[-1/0,-1/0,-1/0];z=Y.length/3,T=0;for(let i=T;i<z;++i){const U=e.On.jn(Y,3*i);e.On.jn(Q,3*i).subtractToRef(U,Z),Z.x*=N,n[0]=Math.min(n[0],Z.x),V[0]=Math.max(V[0],Z.x),n[1]=Math.min(n[1],Z.y),V[1]=Math.max(V[1],Z.y),n[2]=Math.min(n[2],Z.z),V[2]=Math.max(V[2],Z.z),b[3*i]=Z.x,b[3*i+1]=Z.y,b[3*i+2]=Z.z}const B=i.createBufferView(b,12),mb=i.createAccessor(B,"VEC3",5126,Q.length/3,0,{min:n,max:V});U.push(mb),L.attributes.POSITION=U.length-1}else V.Tools.Warn(`Morph target positions for mesh ${n.name} were not exported. Mesh does not have position vertex data`)}if(b.hasNormals){const Q=b.getNormals(),Y=B.getVerticesData(mb.g.NormalKind);if(Y){const b=new Float32Array(Y.length);z=Y.length/3,T=0;for(let i=T;i<z;++i){const n=e.On.jn(Y,3*i).normalize();e.On.jn(Q,3*i).normalize().subtractToRef(n,Z),b[3*i]=Z.x*N,b[3*i+1]=Z.y,b[3*i+2]=Z.z}const n=i.createBufferView(b,12),V=i.createAccessor(n,"VEC3",5126,Q.length/3,0);U.push(V),L.attributes.NORMAL=U.length-1}else V.Tools.Warn(`Morph target normals for mesh ${n.name} were not exported. Mesh does not have normals vertex data`)}if(b.hasTangents){const Q=b.getTangents(),Y=B.getVerticesData(mb.g.TangentKind);if(Y){z=Y.length/4;const b=new Float32Array(3*z);T=0;for(let i=T;i<z;++i){const n=e.On.jn(Y,4*i);v(n);const V=e.On.jn(Q,3*i);v(V),V.subtractToRef(n,Z),b[3*i]=Z.x*N,b[3*i+1]=Z.y,b[3*i+2]=Z.z}const n=i.createBufferView(b,12),V=i.createAccessor(n,"VEC3",5126,z,0);U.push(V),L.attributes.TANGENT=U.length-1}else V.Tools.Warn(`Morph target tangents for mesh ${n.name} were not exported. Mesh does not have tangents vertex data`)}if(b.hasColors){const Q=b.getColors(),Y=B.getVerticesData(mb.g.ColorKind),N=B.getVertexBuffer(mb.g.ColorKind);if(Y&&N){const b=N.getSize();z=Y.length/b;const n=new Float32Array(z*b);T=0;for(let i=T;i<z;++i)if(3===b){const V=e.On.jn(Y,i*b);e.On.jn(Q,i*b).subtractToRef(V,Z),n[3*i]=Z.x,n[3*i+1]=Z.y,n[3*i+2]=Z.z}else if(4===b){const V=new e.Vector4,U=e.Vector4.jn(Y,i*b);e.Vector4.jn(Q,i*b).subtractToRef(U,V),n[4*i]=V.x,n[4*i+1]=V.y,n[4*i+2]=V.z,n[4*i+3]=V.w}else V.Tools.Warn(`Unsupported number of components for color attribute: ${b}`);const B=i.createBufferView(n,4*b),mb=i.createAccessor(B,3===b?"VEC3":"VEC4",5126,z,0);U.push(mb),L.attributes.COLOR_0=U.length-1}else V.Tools.Warn(`Morph target colors for mesh ${n.name} were not exported. Mesh does not have colors vertex data`)}return L}var Mb=i(12325),jb=i(12171),ab=i(12159),Db=i(11734);class xb{}xb.DEFAULT_COLOR=I.Mn.White(),xb.DEFAULT_WIDTH_ATTENUATED=1,xb.DEFAULT_WIDTH=.1;var yb=i(11978),sb=i(12333);class Ab{static ConvertPoints(b,n){if(b.length&&Array.isArray(b)&&"number"===typeof b[0])return[b];if(b.length&&Array.isArray(b[0])&&"number"===typeof b[0][0])return b;if(b.length&&!Array.isArray(b[0])&&b[0]instanceof e.On){const n=[];for(let i=0;i<b.length;i++){const e=b[i];n.push(e.x,e.y,e.z)}return[n]}if(b.length>0&&Array.isArray(b[0])&&b[0].length>0&&b[0][0]instanceof e.On){const n=[],i=b;for(const b of i)n.push(b.flatMap((b=>[b.x,b.y,b.z])));return n}if(b instanceof Float32Array){if(null!==n&&void 0!==n&&n.floatArrayStride){const i=[],e=3*n.floatArrayStride;for(let n=0;n<b.length;n+=e){const V=new Array(e);for(let i=0;i<e;i++)V[i]=b[n+i];i.push(V)}return i}return[Array.from(b)]}if(b.length&&b[0]instanceof Float32Array){const n=[];for(const i of b)n.push(Array.from(i));return n}return[]}static OmitZeroLengthPredicate(b,n,i){const e=[];return n.un(b).lengthSquared()>0&&e.push([b,n]),i.un(n).lengthSquared()>0&&e.push([n,i]),b.un(i).lengthSquared()>0&&e.push([i,b]),0===e.length?null:e}static OmitDuplicatesPredicate(b,n,i,e){const V=[];return Ab._SearchInPoints(b,n,e)||V.push([b,n]),Ab._SearchInPoints(n,i,e)||V.push([n,i]),Ab._SearchInPoints(i,b,e)||V.push([i,b]),0===V.length?null:V}static _SearchInPoints(b,n,i){for(const U of i)for(let i=0;i<U.length;i++){var e,V,Q;if(null!==(e=U[i])&&void 0!==e&&e.equals(b))if(null!==(V=U[i+1])&&void 0!==V&&V.equals(n)||null!==(Q=U[i-1])&&void 0!==Q&&Q.equals(n))return!0}return!1}static MeshesToLines(b,n){const i=[];for(let V=0;V<b.length;V++){const Q=b[V],U=Q.getVerticesData(mb.g.PositionKind),Y=Q.Je();if(U&&Y)for(let b=0,L=0;b<Y.length;b++){const B=3*Y[L++],mb=3*Y[L++],N=3*Y[L++],Z=new e.On(U[B],U[B+1],U[B+2]),T=new e.On(U[mb],U[mb+1],U[mb+2]),z=new e.On(U[N],U[N+1],U[N+2]);if(n){const e=n(Z,T,z,i,b,B,Q,V,U,Y);if(e)for(const b of e)i.push(b)}else i.push([Z,T],[T,z],[z,Z])}}return i}static ToVector3Array(b){if(Array.isArray(b[0])){const n=[],i=b;for(const b of i){const i=[];for(let n=0;n<b.length;n+=3)i.push(new e.On(b[n],b[n+1],b[n+2]));n.push(i)}return n}const n=b,i=[];for(let V=0;V<n.length;V+=3)i.push(new e.On(n[V],n[V+1],n[V+2]));return i}static ToNumberArray(b){return b.flatMap((b=>[b.x,b.y,b.z]))}static GetPointsCountInfo(b){const n=new Array(b.length);let i=0;for(let e=b.length;e--;)n[e]=b[e].length/3,i+=n[e];return{total:i,counts:n}}static GetLineLength(b){if(0===b.length)return 0;let n;n="number"===typeof b[0]?Ab.ToVector3Array(b):b;const i=e.TmpVectors.On[0];let V=0;for(let e=0;e<n.length-1;e++){const b=n[e];V+=n[e+1].subtractToRef(b,i).length()}return V}static GetLineLengthArray(b){const n=new Float32Array(b.length/3);let i=0;for(let e=0,V=b.length/3-1;e<V;e++){let V=b[3*e+0],Q=b[3*e+1],U=b[3*e+2];V-=b[3*e+3],Q-=b[3*e+4],U-=b[3*e+5];i+=Math.sqrt(V*V+Q*Q+U*U),n[e+1]=i}return n}static SegmentizeSegmentByCount(b,n,i){const V=[],Q=n.un(b),U=e.TmpVectors.On[0];U.Fe(i);const Y=e.TmpVectors.On[1];Q.divideToRef(U,Y);let L=b.clone();V.push(L);for(let e=0;e<i;e++)L=L.clone(),V.push(L.addInPlace(Y));return V}static SegmentizeLineBySegmentLength(b,n){const i=b[0]instanceof e.On?Ab.GetLineSegments(b):"number"===typeof b[0]?Ab.GetLineSegments(Ab.ToVector3Array(b)):b,V=[];for(const e of i)if(e.length>n){const b=Ab.SegmentizeSegmentByCount(e.point1,e.point2,Math.ceil(e.length/n));for(const n of b)V.push(n)}else V.push(e.point1),V.push(e.point2);return V}static SegmentizeLineBySegmentCount(b,n){const i="number"===typeof b[0]?Ab.ToVector3Array(b):b,e=Ab.GetLineLength(i)/n;return Ab.SegmentizeLineBySegmentLength(i,e)}static GetLineSegments(b){const n=[];for(let i=0;i<b.length-1;i++){const e=b[i],V=b[i+1],Q=V.un(e).length();n.push({point1:e,point2:V,length:Q})}return n}static GetMinMaxSegmentLength(b){const n=Ab.GetLineSegments(b).sort((b=>b.length));return{min:n[0].length,max:n[n.length-1].length}}static GetPositionOnLineByVisibility(b,n,i){let V=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const Q=n*i;let U=0,Y=0;const L=b.length;for(let e=0;e<L;e++){if(Q<=U+b[e].length){Y=e;break}U+=b[e].length}const B=(Q-U)/b[Y].length;return b[Y].point2.subtractToRef(b[Y].point1,e.TmpVectors.On[0]),e.TmpVectors.On[1]=e.TmpVectors.On[0].multiplyByFloats(B,B,B),V||e.TmpVectors.On[1].addInPlace(b[Y].point1),e.TmpVectors.On[1].clone()}static GetCircleLinePoints(b,n){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:b,Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/n;const U=[];for(let Y=0;Y<=n;Y++)U.push(new e.On(Math.cos(Y*Q)*b,Math.sin(Y*Q)*V,i));return U}static GetBezierLinePoints(b,n,i,e){return yb.f.CreateQuadraticBezier(b,n,i,e).getPoints().flatMap((b=>[b.x,b.y,b.z]))}static GetArrowCap(b,n,i,e,V){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[b.clone(),b.add(n.multiplyByFloats(i,i,i))],widths:[e,V,Q,U]}}static GetPointsFromText(b,n,i,e){let V=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,Q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const U=[],Y=(0,sb.b)(b,n,i,e);for(const L of Y){for(const b of L.paths){const n=[],i=b.getPoints();for(const b of i)n.push(b.x,b.y,V);U.push(n)}if(Q)for(const b of L.holes){const n=[],i=b.getPoints();for(const b of i)n.push(b.x,b.y,V);U.push(n)}}return U}static Color3toRGBAUint8(b){const n=new Uint8Array(4*b.length);for(let i=0,e=0;i<b.length;i++)n[e++]=255*b[i].r,n[e++]=255*b[i].g,n[e++]=255*b[i].b,n[e++]=255;return n}static CreateColorsTexture(b,n,i,e){const V=e.getEngine().getCaps().maxTextureSize??1,Q=n.length>V?V:n.length,U=Math.ceil(n.length/V);U>1&&(n=[...n,...Array(Q*U-n.length).fill(n[0])]);const Y=Ab.Color3toRGBAUint8(n),L=new M.d(Y,Q,U,z.c.TEXTUREFORMAT_RGBA,e,!1,!0,i);return L.name=b,L}static PrepareEmptyColorsTexture(b){if(!xb.EmptyColorsTexture){const n=new Uint8Array(4);xb.EmptyColorsTexture=new M.d(n,1,1,z.c.TEXTUREFORMAT_RGBA,b,!1,!1,M.d.NEAREST_NEAREST),xb.EmptyColorsTexture.name="grlEmptyColorsTexture"}return xb.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var b;null===(b=xb.EmptyColorsTexture)||void 0===b||b.dispose(),xb.EmptyColorsTexture=null}static BooleanToNumber(b){return b?1:0}}class Eb extends ab.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Cb extends jb.c{isCompatible(b){return!0}constructor(b,n,i){var V;i=i||{color:xb.DEFAULT_COLOR};const Q=new Eb;Q.GREASED_LINE_HAS_COLOR=!!i.color&&!i.useColors,Q.GREASED_LINE_SIZE_ATTENUATION=i.sizeAttenuation??!1,Q.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===i.colorDistributionType,Q.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(n??b.ab()).useRightHandedSystem,Q.GREASED_LINE_CAMERA_FACING=i.cameraFacing??!0,super(b,Cb.GREASED_LINE_MATERIAL_NAME,200,Q,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(V=i)||void 0===V?void 0:V.forceGLSL)||Cb.ForceGLSL,this._scene=n??b.ab(),this._engine=this._scene.getEngine(),this._cameraFacing=i.cameraFacing??!0,this.visibility=i.visibility??1,this.useDash=i.useDash??!1,this.dashRatio=i.dashRatio??.5,this.dashOffset=i.dashOffset??0,this.width=i.width?i.width:i.sizeAttenuation?xb.DEFAULT_WIDTH_ATTENUATED:xb.DEFAULT_WIDTH,this._sizeAttenuation=i.sizeAttenuation??!1,this.colorMode=i.colorMode??0,this._color=i.color??null,this.useColors=i.useColors??!1,this._colorsDistributionType=i.colorDistributionType??0,this.colorsSampling=i.colorsSampling??M.d.NEAREST_NEAREST,this._colors=i.sb??null,this.dashCount=i.dashCount??1,this.resolution=i.resolution??new e.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),i.colorsTexture?this.colorsTexture=i.colorsTexture:this._colors?this.colorsTexture=Ab.CreateColorsTexture(`${b.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??xb.DEFAULT_COLOR,Ab.PrepareEmptyColorsTexture(this._scene)),this._engine.Qe.add((()=>{Ab.DisposeEmptyColorsTexture()}))}getAttributes(b){b.push("grl_offsets"),b.push("grl_widths"),b.push("grl_colorPointers"),b.push("grl_counters"),this._cameraFacing?(b.push("grl_previousAndSide"),b.push("grl_nextAndCounters")):b.push("grl_slopes")}getSamplers(b){b.push("grl_colors")}getActiveTextures(b){this.colorsTexture&&b.push(this.colorsTexture)}getUniforms(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&n.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===b&&n.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:n,vertex:this._cameraFacing&&this._isGLSL(b)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(b)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(b){if(this._cameraFacing){b.Ee("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||b.Ee("viewProjection",this._scene.getTransformMatrix());const n=e.TmpVectors.Vector4[0];n.x=this._aspect,n.y=this._resolution.x,n.z=this._resolution.y,n.w=this.width,b.updateVector4("grl_aspect_resolution_lineWidth",n)}const n=e.TmpVectors.Vector4[0];n.x=Ab.BooleanToNumber(this.useDash),n.y=this._dashArray,n.z=this.dashOffset,n.w=this.dashRatio,b.updateVector4("grl_dashOptions",n);const i=e.TmpVectors.Vector4[1];i.x=this.colorMode,i.y=this.visibility,i.z=this.colorsTexture?this.colorsTexture.getSize().width:0,i.w=Ab.BooleanToNumber(this.useColors),b.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",i),this._color&&b.updateColor3("grl_singleColor",this._color);const V=this.colorsTexture??xb.EmptyColorsTexture;b.setTexture("grl_colors",V),b.updateFloat2("grl_textureSize",(null===V||void 0===V?void 0:V.getSize().width)??1,(null===V||void 0===V?void 0:V.getSize().height)??1)}prepareDefines(b,n,i){b.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,b.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,b.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,b.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=n.useRightHandedSystem,b.GREASED_LINE_CAMERA_FACING=this._cameraFacing,b.GREASED_LINE_USE_OFFSETS=!!i.offsets}getClassName(){return Cb.GREASED_LINE_MATERIAL_NAME}getCustomCode(b){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(n)?function(b,n){if("vertex"===b){const b={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return n&&(b["!gl_Position\\=viewProjection\\*worldPos;"]="//"),b}return"fragment"===b?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(b,this._cameraFacing):function(b,n){if("vertex"===b){const b={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return n&&(b["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),b}return"fragment"===b?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(b,this._cameraFacing)}dispose(){var b;null===(b=this.colorsTexture)||void 0===b||b.dispose(),super.dispose()}get sb(){return this._colors}set sb(b){this.setColors(b)}setColors(b){var n;let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const V=(null===(n=this._colors)||void 0===n?void 0:n.length)??0;var Q;if(this._colors=b,null!==b&&0!==b.length){if(!i||e)if(this.colorsTexture&&V===b.length&&!e){const n=Ab.Color3toRGBAUint8(b);this.colorsTexture.update(n)}else{var U;null===(U=this.colorsTexture)||void 0===U||U.dispose(),this.colorsTexture=Ab.CreateColorsTexture(`${this._material.name}-colors-texture`,b,this.colorsSampling,this._scene)}}else null===(Q=this.colorsTexture)||void 0===Q||Q.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(b){this._dashCount=b,this._dashArray=1/b}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(b){this._sizeAttenuation=b,this.markAllDefinesAsDirty()}get color(){return this._color}set color(b){this.setColor(b)}setColor(b){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==b||null!==this._color&&null===b?(this._color=b,n||this.markAllDefinesAsDirty()):this._color=b}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(b){this._colorsDistributionType=b,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(b){this._aspect=b.x/b.y,this._resolution=b}serialize(){const b=super.serialize(),n={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(n.sb=this._colors),this._color&&(n.color=this._color),b.greasedLineMaterialOptions=n,b}parse(b,n,i){var e;super.parse(b,n,i);const V=b.greasedLineMaterialOptions;null===(e=this.colorsTexture)||void 0===e||e.dispose(),V.color&&this.setColor(V.color,!0),V.colorDistributionType&&(this.colorsDistributionType=V.colorDistributionType),V.sb&&(this.sb=V.sb),V.colorsSampling&&(this.colorsSampling=V.colorsSampling),V.colorMode&&(this.colorMode=V.colorMode),V.useColors&&(this.useColors=V.useColors),V.visibility&&(this.visibility=V.visibility),V.useDash&&(this.useDash=V.useDash),V.dashCount&&(this.dashCount=V.dashCount),V.dashRatio&&(this.dashRatio=V.dashRatio),V.dashOffset&&(this.dashOffset=V.dashOffset),V.width&&(this.width=V.width),V.sizeAttenuation&&(this.sizeAttenuation=V.sizeAttenuation),V.resolution&&(this.resolution=V.resolution),this.sb?this.colorsTexture=Ab.CreateColorsTexture(`${this._material.name}-colors-texture`,this.sb,this.colorsSampling,n):Ab.PrepareEmptyColorsTexture(n),this.markAllDefinesAsDirty()}copyTo(b){var n;const i=b;null===(n=i.colorsTexture)||void 0===n||n.dispose(),this._colors&&(i.colorsTexture=Ab.CreateColorsTexture(`${i._material.name}-colors-texture`,this._colors,i.colorsSampling,this._scene)),i.setColor(this.color,!0),i.colorsDistributionType=this.colorsDistributionType,i.colorsSampling=this.colorsSampling,i.colorMode=this.colorMode,i.useColors=this.useColors,i.visibility=this.visibility,i.useDash=this.useDash,i.dashCount=this.dashCount,i.dashRatio=this.dashRatio,i.dashOffset=this.dashOffset,i.width=this.width,i.sizeAttenuation=this.sizeAttenuation,i.resolution=this.resolution,i.markAllDefinesAsDirty()}_isGLSL(b){return 0===b||this._forceGLSL}}Cb.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Cb.ForceGLSL=!1,(0,Db.i)(`BABYLON.${Cb.GREASED_LINE_MATERIAL_NAME}`,Cb);var tb=i(12198),wb=i(11625),hb=i(12003),Wb=i(11713);class Jb extends hb.ShaderMaterial{constructor(b,n,V){const Q=n.getEngine(),U=Q.isWebGPU&&!(V.forceGLSL||Jb.ForceGLSL),Y=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];n.useRightHandedSystem&&Y.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const L=["position","grl_widths","grl_offsets","grl_colorPointers"];V.cameraFacing?(Y.push("GREASED_LINE_CAMERA_FACING"),L.push("grl_previousAndSide","grl_nextAndCounters")):(L.push("grl_slopes"),L.push("grl_counters"));const B=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(U||B.push("world","viewProjection","view","projection"),super(b,n,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:U?["Scene","Mesh"]:void 0,attributes:L,uniforms:B,samplers:U?[]:["grlColors"],defines:Y,extraInitializationsAsync:async()=>{U?await Promise.all([i.e(66).then(i.bind(i,14997)),i.e(75).then(i.bind(i,15004))]):await Promise.all([i.e(69).then(i.bind(i,15007)),i.e(76).then(i.bind(i,15012))])},shaderLanguage:U?1:0}),this._color=I.Mn.White(),this._colorsDistributionType=0,this._colorsTexture=null,V=V||{color:xb.DEFAULT_COLOR},this.visibility=V.visibility??1,this.useDash=V.useDash??!1,this.dashRatio=V.dashRatio??.5,this.dashOffset=V.dashOffset??0,this.dashCount=V.dashCount??1,this.width=V.width?V.width:V.sizeAttenuation&&V.cameraFacing?xb.DEFAULT_WIDTH_ATTENUATED:xb.DEFAULT_WIDTH,this.sizeAttenuation=V.sizeAttenuation??!1,this.color=V.color??I.Mn.White(),this.useColors=V.useColors??!1,this.colorsDistributionType=V.colorDistributionType??0,this.colorsSampling=V.colorsSampling??M.d.NEAREST_NEAREST,this.colorMode=V.colorMode??0,this._colors=V.sb??null,this._cameraFacing=V.cameraFacing??!0,this.resolution=V.resolution??new e.Vector2(Q.getRenderWidth(),Q.getRenderHeight()),V.colorsTexture?this.colorsTexture=V.colorsTexture:this._colors?this.colorsTexture=Ab.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,n):(this._color=this._color??xb.DEFAULT_COLOR,this.colorsTexture=Ab.PrepareEmptyColorsTexture(n)),U){const b=new Wb.d;b.setParameters(),b.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",b)}Q.Qe.add((()=>{Ab.DisposeEmptyColorsTexture()}))}dispose(){var b;null===(b=this._colorsTexture)||void 0===b||b.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new e.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get sb(){return this._colors}set sb(b){this.setColors(b)}setColors(b){var n;let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const V=(null===(n=this._colors)||void 0===n?void 0:n.length)??0;var Q;if(this._colors=b,null!==b&&0!==b.length){if(!i||e)if(this._colorsTexture&&V===b.length&&!e){const n=Ab.Color3toRGBAUint8(b);this._colorsTexture.update(n)}else{var U;null===(U=this._colorsTexture)||void 0===U||U.dispose(),this.colorsTexture=Ab.CreateColorsTexture(`${this.name}-colors-texture`,b,this.colorsSampling,this.ab())}}else null===(Q=this._colorsTexture)||void 0===Q||Q.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(b){this._colorsTexture=b,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(b){this._width=b,this.setFloat("grlWidth",b)}get useColors(){return this._useColors}set useColors(b){this._useColors=b,this.setFloat("grlUseColors",Ab.BooleanToNumber(b))}get colorsSampling(){return this._colorsSampling}set colorsSampling(b){this._colorsSampling=b}get visibility(){return this._visibility}set visibility(b){this._visibility=b,this.setFloat("grlVisibility",b)}get useDash(){return this._useDash}set useDash(b){this._useDash=b,this.setFloat("grlUseDash",Ab.BooleanToNumber(b))}get dashOffset(){return this._dashOffset}set dashOffset(b){this._dashOffset=b,this.setFloat("grlDashOffset",b)}get dashRatio(){return this._dashRatio}set dashRatio(b){this._dashRatio=b,this.setFloat("grlDashRatio",b)}get dashCount(){return this._dashCount}set dashCount(b){this._dashCount=b,this._dashArray=1/b,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(b){this._sizeAttenuation=b,this.setFloat("grlSizeAttenuation",Ab.BooleanToNumber(b))}get color(){return this._color}set color(b){this.setColor(b)}setColor(b){b=b??xb.DEFAULT_COLOR,this._color=b,this.setColor3("grlColor",b)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(b){this._colorsDistributionType=b,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(b){this._colorMode=b,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(b){this._resolution=b,this.setVector2("grlResolution",b),this.setFloat("grlAspect",b.x/b.y)}serialize(){const b=super.serialize(),n={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(n.sb=this._colors),b.greasedLineMaterialOptions=n,b}parse(b,n,i){var e;const V=b.greasedLineMaterialOptions;null===(e=this._colorsTexture)||void 0===e||e.dispose(),V.color&&(this.color=V.color),V.colorDistributionType&&(this.colorsDistributionType=V.colorDistributionType),V.colorsSampling&&(this.colorsSampling=V.colorsSampling),V.colorMode&&(this.colorMode=V.colorMode),V.useColors&&(this.useColors=V.useColors),V.visibility&&(this.visibility=V.visibility),V.useDash&&(this.useDash=V.useDash),V.dashCount&&(this.dashCount=V.dashCount),V.dashRatio&&(this.dashRatio=V.dashRatio),V.dashOffset&&(this.dashOffset=V.dashOffset),V.width&&(this.width=V.width),V.sizeAttenuation&&(this.sizeAttenuation=V.sizeAttenuation),V.resolution&&(this.resolution=V.resolution),V.sb?this.colorsTexture=Ab.CreateColorsTexture(`${this.name}-colors-texture`,V.sb,this.colorsSampling,this.ab()):this.colorsTexture=Ab.PrepareEmptyColorsTexture(n),this._cameraFacing=V.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Rb,kb,rb;Jb.ForceGLSL=!1,function(b){b[b.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",b[b.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Rb||(Rb={})),function(b){b[b.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",b[b.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",b[b.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(kb||(kb={})),function(b){b[b.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",b[b.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",b[b.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",b[b.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",b[b.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(rb||(rb={}));class Xb extends ub.b{constructor(b,n,i){super(b,n,null,null,!1,!1),this.name=b,this._options=i,this._lazy=!1,this._updatable=!1,this._engine=n.getEngine(),this._lazy=i.lazy??!1,this._updatable=i.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=i.colorPointers??[],this._widths=i.widths??new Array(i.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(b){let n=0;for(const e of this._points)n+=e.length;const i=n/3*2-this._widths.length;for(let e=0;e<i;e++)this._widths.push(b)}updateLazy(){var b,n;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(b=this._options.ribbonOptions)||void 0===b?void 0:b.smoothShading),!this.tb&&this.refreshBoundingInfo(),null===(n=this.greasedLineMaterial)||void 0===n||n.updateLazy()}addPoints(b,n){for(const i of b)this._points.push(i);this._lazy||this.setPoints(this._points,n)}dispose(b){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(b,n)}isLazy(){return this._lazy}get Ab(){return this._uvs}set Ab(b){this._uvs=b instanceof Float32Array?b:new Float32Array(b),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(b){this.material instanceof Jb&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===b||void 0===b?void 0:b.length)>0),this._offsets=b,this._offsetsBuffer?this._offsetsBuffer.update(b):this._createOffsetsBuffer(b)}get widths(){return this._widths}set widths(b){this._widths=b,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(b)}get colorPointers(){return this._colorPointers}set colorPointers(b){this._colorPointers=b,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(b)}get greasedLineMaterial(){var b,n;if(this.material&&this.material instanceof Jb)return this.material;const i=null===(b=this.material)||void 0===b||null===(n=b.pluginManager)||void 0===n?void 0:n.getPlugin(Cb.GREASED_LINE_MATERIAL_NAME);return i||void 0}get points(){const b=[];return wb.e.DeepCopy(this._points,b),b}setPoints(b,n){this._points=Ab.ConvertPoints(b,(null===n||void 0===n?void 0:n.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==n&&void 0!==n&&n.colorPointers||this._updateColorPointers(),this._setPoints(this._points,n)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Ab:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(b){super.serialize(b),b.type=this.getClassName(),b.lineOptions=this._createLineOptions()}_createVertexBuffers(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=new tb.d;return n.xb=this._vertexPositions,n.indices=this._indices,n.Ab=this._uvs,b&&(n.yb=[],tb.d.ComputeNormals(this._vertexPositions,this._indices,n.yb)),n.Cb(this,this._options.updatable),n}_createOffsetsBuffer(b){const n=this._scene.getEngine(),i=new mb.e(n,b,this._updatable,3);this.setVerticesBuffer(i.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=i}}class gb{constructor(b,n){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=b,this.wasAddedByNoopNode=n}getIndicesAccessor(b,n,i,e,V){var Q,U,Y,L;return null===(Q=this._indicesAccessorMap.get(b))||void 0===Q||null===(U=Q.get(n))||void 0===U||null===(Y=U.get(i))||void 0===Y||null===(L=Y.get(e))||void 0===L?void 0:L.get(V)}setIndicesAccessor(b,n,i,e,V,Q){let U=this._indicesAccessorMap.get(b);U||(U=new Map,this._indicesAccessorMap.set(b,U));let Y=U.get(n);Y||(Y=new Map,U.set(n,Y));let L=Y.get(i);L||(L=new Map,Y.set(i,L));let B=L.get(e);B||(B=new Map,L.set(e,B)),B.set(V,Q)}pushExportedNode(b){this._exportedNodes.has(b)||this._exportedNodes.add(b)}getNodesSet(){return this._exportedNodes}getVertexBufferView(b){return this._vertexBufferViewMap.get(b)}setVertexBufferView(b,n){this._vertexBufferViewMap.set(b,n)}setRemappedBufferView(b,n,i){this._remappedBufferView.set(b,new Map),this._remappedBufferView.get(b).set(n,i)}getRemappedBufferView(b,n){var i;return null===(i=this._remappedBufferView.get(b))||void 0===i?void 0:i.get(n)}getVertexAccessor(b,n,i){var e,V;return null===(e=this._vertexAccessorMap.get(b))||void 0===e||null===(V=e.get(n))||void 0===V?void 0:V.get(i)}setVertexAccessor(b,n,i,e){let V=this._vertexAccessorMap.get(b);V||(V=new Map,this._vertexAccessorMap.set(b,V));let Q=V.get(n);Q||(Q=new Map,V.set(n,Q)),Q.set(i,e)}hasVertexColorAlpha(b){return this._vertexMapColorAlpha.get(b)||!1}setHasVertexColorAlpha(b,n){return this._vertexMapColorAlpha.set(b,n)}getMesh(b){return this._meshMap.get(b)}setMesh(b,n){this._meshMap.set(b,n)}bindMorphDataToMesh(b,n){const i=this._meshMorphTargetMap.get(b)||[];this._meshMorphTargetMap.set(b,i),-1===i.indexOf(n)&&i.push(n)}getMorphTargetsFromMesh(b){return this._meshMorphTargetMap.get(b)}}class Pb{_ApplyExtension(b,n,i,e){if(i>=n.length)return Promise.resolve(b);const V=e(n[i],b);return V?V.then((async b=>b?await this._ApplyExtension(b,n,i+1,e):null)):this._ApplyExtension(b,n,i+1,e)}_ApplyExtensions(b,n){const i=[];for(const e of Pb._ExtensionNames)i.push(this._extensions[e]);return this._ApplyExtension(b,i,0,n)}_extensionsPreExportTextureAsync(b,n,i){return this._ApplyExtensions(n,((n,e)=>n.preExportTextureAsync&&n.preExportTextureAsync(b,e,i)))}_extensionsPostExportNodeAsync(b,n,i,e,V){return this._ApplyExtensions(n,((n,Q)=>n.postExportNodeAsync&&n.postExportNodeAsync(b,Q,i,e,V,this._bufferManager)))}_extensionsPostExportMaterialAsync(b,n,i){return this._ApplyExtensions(n,((n,e)=>n.postExportMaterialAsync&&n.postExportMaterialAsync(b,e,i)))}_extensionsPostExportMaterialAdditionalTextures(b,n,i){const e=[];for(const V of Pb._ExtensionNames){const Q=this._extensions[V];Q.postExportMaterialAdditionalTextures&&e.push(...Q.postExportMaterialAdditionalTextures(b,n,i))}return e}_extensionsPostExportTextures(b,n,i){for(const e of Pb._ExtensionNames){const V=this._extensions[e];V.postExportTexture&&V.postExportTexture(b,n,i)}}_extensionsPostExportMeshPrimitive(b){for(const n of Pb._ExtensionNames){const i=this._extensions[n];i.postExportMeshPrimitive&&i.postExportMeshPrimitive(b,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const b of Pb._ExtensionNames){const n=this._extensions[b];n.preGenerateBinaryAsync&&await n.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(b){for(const n of Pb._ExtensionNames){const i=this._extensions[n];i.enabled&&b(i)}}_extensionsOnExporting(){this._forEachExtensions((b=>{var n,i,e;b.wasUsed&&((n=this._glTF).extensionsUsed||(n.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(b.name)&&this._glTF.extensionsUsed.push(b.name),b.required&&((i=this._glTF).extensionsRequired||(i.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(b.name)&&this._glTF.extensionsRequired.push(b.name)),(e=this._glTF).extensions||(e.extensions={}),b.onExporting&&b.onExporting())}))}_loadExtensions(){for(const b of Pb._ExtensionNames){const n=Pb._ExtensionFactories[b](this);this._extensions[b]=n}}constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:K.d.LastCreatedScene,n=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${z.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new W(this),this._extensions={},this._bufferManager=new mn,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!b)throw new Error("No scene available to export");this._babylonScene=b,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:b=>{var n;return null===b||void 0===b||null===(n=b.Ne)||void 0===n?void 0:n.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...n},this._loadExtensions()}dispose(){for(const b in this._extensions){this._extensions[b].dispose()}}get options(){return this._options}static RegisterExtension(b,n){Pb.UnregisterExtension(b)&&V.Tools.Warn(`Extension with the name ${b} already exists`),Pb._ExtensionFactories[b]=n,Pb._ExtensionNames.push(b)}static UnregisterExtension(b){if(!Pb._ExtensionFactories[b])return!1;delete Pb._ExtensionFactories[b];const n=Pb._ExtensionNames.indexOf(b);return-1!==n&&Pb._ExtensionNames.splice(n,1),!0}_generateJSON(b,n,i){const e={byteLength:b};return e.byteLength&&(this._glTF.buffers=[e]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.dn=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(e.uri=n+".bin"),i?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(b){const n=await this._generateBinaryAsync();this._extensionsOnExporting();const i=this._generateJSON(n.byteLength,b,!0),e=new Blob([n],{type:"application/octet-stream"}),V=b+".gltf",Q=b+".bin",U=new B;if(U.files[V]=i,U.files[Q]=e,this._imageData)for(const Y in this._imageData)U.files[Y]=new Blob([this._imageData[Y].data],{type:this._imageData[Y].mimeType});return U}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(b){const n=b%4;return 0===n?n:4-n}async generateGLBAsync(b){this._shouldUseGlb=!0;const n=await this._generateBinaryAsync();this._extensionsOnExporting();const i=this._generateJSON(n.byteLength),e=b+".glb";let V,Q=i.length;if("undefined"!==typeof TextEncoder){V=(new TextEncoder).encode(i),Q=V.length}const U=this._getPadding(Q),Y=this._getPadding(n.byteLength),L=28+Q+U+n.byteLength+Y,mb=new Lb(L);if(mb.writeUInt32(1179937895),mb.writeUInt32(2),mb.writeUInt32(L),mb.writeUInt32(Q+U),mb.writeUInt32(1313821514),V)mb.writeTypedArray(V);else{const b="_".charCodeAt(0);for(let n=0;n<Q;++n){const e=i.charCodeAt(n);e!=i.codePointAt(n)?mb.writeUInt8(b):mb.writeUInt8(e)}}for(let B=0;B<U;++B)mb.writeUInt8(32);mb.writeUInt32(n.byteLength+Y),mb.writeUInt32(5130562),mb.writeTypedArray(n);for(let B=0;B<Y;++B)mb.writeUInt8(0);const N=new B;return N.files[e]=new Blob([mb.getOutputData()],{type:"application/octet-stream"}),N}_setNodeTransformation(b,n,i){if(n.getPivotPoint().equalsWithEpsilon(X,r.c)||V.Tools.Warn("Pivot points are not supported in the glTF serializer"),!n.position.equalsWithEpsilon(X,r.c)){const V=e.TmpVectors.On[0].L(n.position);i&&p(V),b.translation=V.ye()}n.ge.equalsWithEpsilon(P,r.c)||(b.scale=n.ge.ye());const Q=n.rotationQuaternion||e.Quaternion.FromEulerAngles(n.rotation.x,n.rotation.y,n.rotation.z);Q.equalsWithEpsilon(g,r.c)||(i&&f(Q),b.rotation=Q.normalize().ye())}_setCameraTransformation(b,n,i){if(!n.position.equalsWithEpsilon(X,r.c)){const V=e.TmpVectors.On[0].L(n.position);i&&p(V),b.translation=V.ye()}const V=n.rotationQuaternion||e.Quaternion.FromEulerAngles(n.rotation.x,n.rotation.y,n.rotation.z);i&&f(V),this._babylonScene.useRightHandedSystem||F(V),V.equalsWithEpsilon(g,r.c)||(b.rotation=V.ye())}_listAvailableCameras(){for(const b of this._babylonScene.cameras){const n={type:b.mode===Zb.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(b.name&&(n.name=b.name),"perspective"===n.type)n.perspective={aspectRatio:b.getEngine().getAspectRatio(b),yfov:b.fovMode===Zb.c.FOVMODE_VERTICAL_FIXED?b.fov:b.fov*b.getEngine().getAspectRatio(b),znear:b.Ae,zfar:b.maxZ};else if("orthographic"===n.type){const i=b.orthoLeft&&b.orthoRight?.5*(b.orthoRight-b.orthoLeft):.5*b.getEngine().getRenderWidth(),e=b.orthoBottom&&b.orthoTop?.5*(b.orthoTop-b.orthoBottom):.5*b.getEngine().getRenderHeight();n.orthographic={xmag:i,ymag:e,znear:b.Ae,zfar:b.maxZ}}this._camerasMap.set(b,n)}}_exportAndAssignCameras(){const b=Array.from(this._camerasMap.values());for(const n of b){const b=this._nodesCameraMap.get(n);if(void 0!==b){this._cameras.push(n);for(const n of b)n.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const b of this._babylonScene.skeletons){if(b.bones.length<=0)continue;const n={joints:[]};this._skinMap.set(b,n)}}_exportAndAssignSkeletons(){for(const b of this._babylonScene.skeletons){if(b.bones.length<=0)continue;const n=this._skinMap.get(b);if(void 0==n)continue;const i={},e=[];let Q=-1;for(let V=0;V<b.bones.length;++V){const n=b.bones[V],e=n.getIndex()??V;-1!==e&&(i[e]=n,e>Q&&(Q=e))}for(let b=0;b<=Q;++b){const Q=i[b];e.push(Q.getAbsoluteInverseBindMatrix());const U=Q.getTransformNode();if(null!==U){const b=this._nodeMap.get(U);U&&null!==b&&void 0!==b?n.joints.push(b):V.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else V.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const U=this._nodesSkinMap.get(n);if(n.joints.length>0&&void 0!==U){const b=64*e.length,i=new Float32Array(b/4);e.forEach(((b,n)=>{i.set(b.m,16*n)}));const V=this._bufferManager.createBufferView(i);this._accessors.push(this._bufferManager.createAccessor(V,"MAT4",5126,e.length)),n.inverseBindMatrices=this._accessors.length-1,this._skins.push(n);for(const n of U)n.skin=this._skins.length-1}}}async _exportSceneAsync(){const b={nodes:[]};if(this._babylonScene.metadata){const n=this._options.metadataSelector(this._babylonScene.metadata);n&&(b.extras=n)}const n=new Array,i=new Array,e=new Array;for(const Y of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Ub(Y,this._babylonScene.useRightHandedSystem)?e.push(...Y.getChildren()):this._babylonScene.useRightHandedSystem?n.push(Y):i.push(Y);this._listAvailableCameras(),this._listAvailableSkeletons();const V=new gb(!0,!1);b.nodes.push(...await this._exportNodesAsync(i,V));const Q=new gb(!1,!1);b.nodes.push(...await this._exportNodesAsync(n,Q));const U=new gb(!1,!0);b.nodes.push(...await this._exportNodesAsync(e,U)),b.nodes.length&&this._scenes.push(b),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Gb._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,V.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(b){let n=this._shouldExportNodeMap.get(b);return void 0===n&&(n=this._options.shouldExportNode(b),this._shouldExportNodeMap.set(b,n)),n}async _exportNodesAsync(b,n){const i=new Array;this._exportBuffers(b,n);for(const e of b)await this._exportNodeAsync(e,i,n);return i}_collectBuffers(b,n,i,e,V){if(this._shouldExportNode(b)&&b instanceof Z.d&&b.We){const Q=b.We.getVertexBuffers();if(Q)for(const e in Q){if(!H(e))continue;const U=Q[e];V.setHasVertexColorAlpha(U,b.hasVertexAlpha);const Y=U._buffer,L=n.get(Y)||[];n.set(Y,L),-1===L.indexOf(U)&&L.push(U);const B=i.get(U)||[];i.set(U,B),-1===B.indexOf(b)&&B.push(b)}const U=b.morphTargetManager;if(U)for(let n=0;n<U.numTargets;n++){const i=U.getTarget(n),V=e.get(i)||[];e.set(i,V),-1===V.indexOf(b)&&V.push(b)}}for(const Q of b.getChildren())this._collectBuffers(Q,n,i,e,V)}_exportBuffers(b,n){const i=new Map,e=new Map,V=new Map;for(const Y of b)this._collectBuffers(Y,i,e,V,n);const Q=Array.from(i.keys());for(const Y of Q){const b=Y.getData();if(!b)throw new Error("Buffer data is not available");const V=i.get(Y);if(!V)continue;const Q=V[0].byteStride;if(V.some((b=>b.byteStride!==Q)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const U=ib(b).slice();for(const n of V){const b=e.get(n),{byteOffset:i,byteStride:V,componentCount:Q,type:Y,count:L,normalized:B,kind:N}=q(n,b);switch(N){case mb.g.NormalKind:case mb.g.TangentKind:(0,J.j)(U,i,V,Q,Y,L,B,(b=>{const n=Math.sqrt(b[0]*b[0]+b[1]*b[1]+b[2]*b[2]);if(n>0){const i=1/n;b[0]*=i,b[1]*=i,b[2]*=i}}));break;case mb.g.ColorKind:{const n=b.filter((b=>b.material instanceof Kb.Gn||null==b.material)).length;if(0==n)break;if(n!=b.length){R.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}Y==mb.g.UNSIGNED_BYTE&&R.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const e=new I.Mn,N=new I.IV,Z=this._babylonScene.getEngine().useExactSrgbConversions;(0,J.j)(U,i,V,Q,Y,L,B,(b=>{3===b.length?(e.Gi(b,0),e.toLinearSpaceToRef(e,Z),e.toArray(b,0)):(N.Gi(b,0),N.toLinearSpaceToRef(N,Z),N.toArray(b,0))}))}}}if(n.convertToRightHanded){for(const b of V){const n=e.get(b),{byteOffset:i,byteStride:V,componentCount:Q,type:Y,count:L,normalized:B,kind:N}=q(b,n);switch(N){case mb.g.PositionKind:case mb.g.NormalKind:case mb.g.TangentKind:(0,J.j)(U,i,V,Q,Y,L,B,(b=>{b[0]=-b[0]}))}}n.convertedToRightHandedBuffers.set(Y,U)}const L=this._bufferManager.createBufferView(U,Q);n.setVertexBufferView(Y,L);const B=new Map;for(const n of V){const b=e.get(n),{kind:i,totalVertices:V}=q(n,b);switch(i){case mb.g.MatricesIndicesKind:case mb.g.MatricesIndicesExtraKind:if(n.type==mb.g.FLOAT){const b=n.getFloatData(V);null!==b&&B.set(n,b)}}}0!==B.size&&R.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const N=Array.from(B.keys());for(const i of N){const b=B.get(i);if(!b)continue;const e=b.some((b=>b>=256)),V=new(e?Uint16Array:Uint8Array)(b.length);for(let n=0;n<b.length;n++)V[n]=b[n];const Q=this._bufferManager.createBufferView(V,4*(e?2:1));n.setRemappedBufferView(Y,i,Q)}}const U=Array.from(V.keys());for(const Y of U){const b=V.get(Y);if(!b)continue;const i=ob(Y,b[0],this._bufferManager,this._bufferViews,this._accessors,n.convertToRightHanded);for(const e of b)n.bindMorphDataToMesh(e,i)}}async _exportNodeAsync(b,n,i){let e=this._nodeMap.get(b);if(void 0!==e)return void(n.includes(e)||n.push(e));const V=await this._createNodeAsync(b,i);if(V){e=this._nodes.length,this._nodes.push(V),this._nodeMap.set(b,e),i.pushExportedNode(b),n.push(e);const Q={name:"runtime animations",channels:[],samplers:[]},U=[];this._babylonScene.animationGroups.length||(Gb._CreateMorphTargetAnimationFromMorphTargetAnimations(b,Q,U,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,i.convertToRightHanded,this._options.shouldExportAnimation),b.animations.length&&Gb._CreateNodeAnimationFromNodeAnimations(b,Q,U,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,i.convertToRightHanded,this._options.shouldExportAnimation)),Q.channels.length&&Q.samplers.length&&this._animations.push(Q),U.forEach((b=>{b.channels.length&&b.samplers.length&&this._animations.push(b)}))}const Q=V?[]:n;for(const U of b.getChildren())await this._exportNodeAsync(U,Q,i);V&&Q.length&&(V.children=Q)}async _createNodeAsync(b,n){if(!this._shouldExportNode(b))return null;const i={};if(b.name&&(i.name=b.name),b.metadata){const n=this._options.metadataSelector(b.metadata);n&&(i.extras=n)}if(b instanceof N.e&&(this._setNodeTransformation(i,b,n.convertToRightHanded),b instanceof Z.d)){const V=b instanceof T.e?b.sourceMesh:b;if(V.xe&&V.xe.length>0&&(i.mesh=await this._exportMeshAsync(V,n)),b.skeleton){const n=this._skinMap.get(b.skeleton);var e;if(void 0!==n)void 0===this._nodesSkinMap.get(n)&&this._nodesSkinMap.set(n,[]),null===(e=this._nodesSkinMap.get(n))||void 0===e||e.push(i)}}if(b instanceof k.b){const e=this._camerasMap.get(b);if(e){var V;void 0===this._nodesCameraMap.get(e)&&this._nodesCameraMap.set(e,[]),this._setCameraTransformation(i,b,n.convertToRightHanded);const U=b.parent;if(null!==U&&nb(b,U)){const b=this._nodeMap.get(U);if(void 0!==b){var Q;const n=this._nodes[b];return bb(i,n),null===(Q=this._nodesCameraMap.get(e))||void 0===Q||Q.push(n),null}}null===(V=this._nodesCameraMap.get(e))||void 0===V||V.push(i)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",i,b,this._nodeMap,n.convertToRightHanded)?i:(R.b.Warn(`Not exporting node ${b.name}`),null)}_exportIndices(b,n,i,e,V,U,Y,L,B){let mb=b;B.mode=l(U);const N=Y!==Q.b.CounterClockWiseSideOrientation,Z=!L.wasAddedByNoopNode&&N,T=function(b){switch(b){case Q.b.TriangleFillMode:case Q.b.TriangleStripDrawMode:case Q.b.TriangleFanDrawMode:return!0}return!1}(U)&&Z;if(T){if(U===Q.b.TriangleStripDrawMode||U===Q.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");B.mode=l(U);const Y=n?new Uint32Array(e):new Uint16Array(e);if(b)for(let n=0;n+2<e;n+=3)Y[n]=b[i+n]+V,Y[n+1]=b[i+n+2]+V,Y[n+2]=b[i+n+1]+V;else for(let b=0;b+2<e;b+=3)Y[b]=b,Y[b+1]=b+2,Y[b+2]=b+1;mb=Y}else if(b&&0!==V){const Q=n?new Uint32Array(e):new Uint16Array(e);for(let n=0;n<e;n++)Q[n]=b[i+n]+V;mb=Q}if(mb){let Q=L.getIndicesAccessor(b,i,e,V,T);if(void 0===Q){const U=function(b,n,i,e){if(b instanceof Uint16Array||b instanceof Uint32Array)return b;if(b instanceof Int32Array)return new Uint32Array(b.buffer,b.byteOffset,b.length);const V=b.slice(n,n+i);return e?new Uint32Array(V):new Uint16Array(V)}(mb,0,e,n),Y=this._bufferManager.createBufferView(U),B=n?5125:5123;this._accessors.push(this._bufferManager.createAccessor(Y,"SCALAR",B,e,0)),Q=this._accessors.length-1,L.setIndicesAccessor(b,i,e,V,T,Q)}B.indices=Q}}_exportVertexBuffer(b,n,i,e,V,Q){const U=b.getKind();if(!H(U))return;if(U.startsWith("uv")&&!this._options.exportUnusedUVs&&(!n||!this._materialNeedsUVsSet.has(n)))return;let Y=V.getVertexAccessor(b,i,e);if(void 0===Y){const n=V.convertedToRightHandedBuffers.get(b._buffer)||b._buffer.getData(),Q=U===mb.g.PositionKind?function(b,n,i,e){const{byteOffset:V,byteStride:Q,type:U,normalized:Y}=n,L=n.getSize(),B=new Array(L).fill(1/0),mb=new Array(L).fill(-1/0);return(0,J.j)(b,V+i*Q,Q,L,U,e*L,Y,(b=>{for(let n=0;n<L;n++)B[n]=Math.min(B[n],b[n]),mb[n]=Math.max(mb[n],b[n])})),{min:B,max:mb}}(n,b,i,e):void 0,L=(U===mb.g.MatricesIndicesKind||U===mb.g.MatricesIndicesExtraKind)&&b.type===mb.g.FLOAT,B=L?mb.g.UNSIGNED_BYTE:b.type,N=L?void 0:b.normalized,Z=L?V.getRemappedBufferView(b._buffer,b):V.getVertexBufferView(b._buffer),T=b.byteOffset+i*b.byteStride;this._accessors.push(this._bufferManager.createAccessor(Z,function(b,n){if(b==mb.g.ColorKind)return n?"VEC4":"VEC3";switch(b){case mb.g.PositionKind:case mb.g.NormalKind:return"VEC3";case mb.g.TangentKind:case mb.g.MatricesIndicesKind:case mb.g.MatricesIndicesExtraKind:case mb.g.MatricesWeightsKind:case mb.g.MatricesWeightsExtraKind:return"VEC4";case mb.g.UVKind:case mb.g.UV2Kind:case mb.g.UV3Kind:case mb.g.UV4Kind:case mb.g.UV5Kind:case mb.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${b}`)}(U,V.hasVertexColorAlpha(b)),B,e,T,Q,N)),Y=this._accessors.length-1,V.setVertexAccessor(b,i,e,Y)}Q.attributes[function(b){switch(b){case mb.g.PositionKind:return"POSITION";case mb.g.NormalKind:return"NORMAL";case mb.g.TangentKind:return"TANGENT";case mb.g.ColorKind:return"COLOR_0";case mb.g.UVKind:return"TEXCOORD_0";case mb.g.UV2Kind:return"TEXCOORD_1";case mb.g.UV3Kind:return"TEXCOORD_2";case mb.g.UV4Kind:return"TEXCOORD_3";case mb.g.UV5Kind:return"TEXCOORD_4";case mb.g.UV6Kind:return"TEXCOORD_5";case mb.g.MatricesIndicesKind:return"JOINTS_0";case mb.g.MatricesIndicesExtraKind:return"JOINTS_1";case mb.g.MatricesWeightsKind:return"WEIGHTS_0";case mb.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${b}`)}(U)]=Y}async _exportMaterialAsync(b,n,i,e){let V=this._materialMap.get(b);if(void 0===V){const e=n&&Object.keys(n).some((b=>b.startsWith("uv")));if((b=b instanceof Tb.e?b.QQ[i.materialIndex]:b)instanceof zb.c)V=await this._materialExporter.exportPBRMaterialAsync(b,"image/png",e);else{if(!(b instanceof Kb.Gn))return void R.b.Warn(`Unsupported material '${b.name}' with type ${b.getClassName()}`);V=await this._materialExporter.exportStandardMaterialAsync(b,"image/png",e)}this._materialMap.set(b,V)}e.material=V}async _exportMeshAsync(b,n){var i;let e=n.getMesh(b);if(void 0!==e)return e;const V={primitives:[]};e=this._meshes.length,this._meshes.push(V),n.setMesh(b,e);const U=b.isUnIndexed?null:b.Je(),Y=null===(i=b.We)||void 0===i?void 0:i.getVertexBuffers(),L=n.getMorphTargetsFromMesh(b),B=b instanceof Mb.b,mb=b instanceof Xb,N=b.xe;if(Y&&N&&N.length>0)for(const z of N){const i={attributes:{}},e=z.Jb()||this._babylonScene.defaultMaterial;if(mb){var Z,T;const n={name:e.name},V=b,Q=I.Mn.White(),U=(null===(Z=V.material)||void 0===Z?void 0:Z.alpha)??1,Y=(null===(T=V.greasedLineMaterial)||void 0===T?void 0:T.color)??Q;(!Y.equalsWithEpsilon(Q,r.c)||U<1)&&(n.pbrMetallicRoughness={baseColorFactor:[...Y.ye(),U]}),this._materials.push(n),i.material=this._materials.length-1}else if(B){const n={name:e.name},V=b;(!V.color.equalsWithEpsilon(I.Mn.White(),r.c)||V.alpha<1)&&(n.pbrMetallicRoughness={baseColorFactor:[...V.color.ye(),V.alpha]}),this._materials.push(n),i.material=this._materials.length-1}else await this._exportMaterialAsync(e,Y,z,i);const N=B||mb?Q.b.LineListDrawMode:b.overrideRenderingFillMode??e.fillMode,K=e._getEffectiveOrientation(b);this._exportIndices(U,U?(0,J.c)(U,z.indexCount,z.indexStart,z.verticesStart):z.verticesCount>65535,U?z.indexStart:z.verticesStart,U?z.indexCount:z.verticesCount,-z.verticesStart,N,K,n,i);for(const b of Object.values(Y))this._exportVertexBuffer(b,e,z.verticesStart,z.verticesCount,n,i);if(L){i.targets=[];for(const b of L)i.targets.push(b.attributes)}V.primitives.push(i),this._extensionsPostExportMeshPrimitive(i)}if(L){V.weights=[],V.extras||(V.extras={}),V.extras.targetNames=[];for(const b of L)V.weights.push(b.influence),V.extras.targetNames.push(b.name)}return e}}Pb._ExtensionNames=new Array,Pb._ExtensionFactories={};class cb{static async GLTFAsync(b,n,i){i&&i.exportWithoutWaitingForScene||await b.whenReadyAsync();const e=new Pb(b,i),V=await e.generateGLTFAsync(n.replace(/\.[^/.]+$/,""));return e.dispose(),V}static async GLBAsync(b,n,i){i&&i.exportWithoutWaitingForScene||await b.whenReadyAsync();const e=new Pb(b,i),V=await e.generateGLBAsync(n.replace(/\.[^/.]+$/,""));return e.dispose(),V}}i(12348);const qb="EXT_mesh_gpu_instancing";class Sb{constructor(b){this.name=qb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(b,n,i,V,Q,U){return await new Promise((b=>{if(n&&i instanceof ub.b&&i.hasThinInstances&&this._exporter){this._wasUsed=!0;const b=e.On.Zero(),V=e.Quaternion.Identity(),Y=e.On.One(),L=i.thinInstanceGetWorldMatrices(),B=e.TmpVectors.On[2],mb=e.TmpVectors.Quaternion[1],N=e.TmpVectors.On[3];let Z=!1,T=!1,z=!1;const K=new Float32Array(3*i.dY),I=new Float32Array(4*i.dY),O=new Float32Array(3*i.dY);let u=0;for(const n of L)n.decompose(N,mb,B),Q&&(p(B),f(mb)),K.set(B.ye(),3*u),I.set(mb.normalize().ye(),4*u),O.set(N.ye(),3*u),Z=Z||!B.equalsWithEpsilon(b),T=T||!mb.equalsWithEpsilon(V),z=z||!N.equalsWithEpsilon(Y),u++;const d={attributes:{}};Z&&(d.attributes.TRANSLATION=this._buildAccessor(K,"VEC3",i.dY,U)),T&&(d.attributes.ROTATION=this._buildAccessor(I,"VEC4",i.dY,U)),z&&(d.attributes.SCALE=this._buildAccessor(O,"VEC3",i.dY,U)),n.extensions=n.extensions||{},n.extensions[qb]=d}b(n)}))}_buildAccessor(b,n,i,e){const V=e.createBufferView(b),Q=e.createAccessor(V,n,5126,i);return this._exporter._accessors.push(Q),this._exporter._accessors.length-1}}Pb.RegisterExtension(qb,(b=>new Sb(b)));var Hb=i(12351),lb=i(12364),vb=i(12370),pb=i(12379);function fb(b){return b===vb.d.PositionKind?"POSITION":b===vb.d.NormalKind?"NORMAL":b===vb.d.ColorKind?"COLOR":b.startsWith(vb.d.UVKind)?"TEX_COORD":"GENERIC"}const Fb={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class bn extends Hb.d{static get DefaultAvailable(){return(0,Hb.g)(bn.DefaultConfiguration)}static get Default(){return bn._Default??(bn._Default=new bn),bn._Default}static ResetDefault(b){bn._Default&&(b||bn._Default.dispose(),bn._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(b,n){return{module:await(n||DracoEncoderModule)({wasmBinary:b})}}_getWorkerContent(){return`${lb.i}(${lb.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:bn.DefaultConfiguration)}async _encodeAsync(b,n,i){const e=i?(0,pb.e)(Fb,i):Fb;if(this._workerPoolPromise){const i=await this._workerPoolPromise;return await new Promise(((V,Q)=>{i.push(((i,U)=>{const Y=b=>{i.removeEventListener("error",Y),i.removeEventListener("message",L),Q(b),U()},L=b=>{"encodeMeshDone"===b.data.id&&(i.removeEventListener("error",Y),i.removeEventListener("message",L),V(b.data.encodedMeshData),U())};i.addEventListener("error",Y),i.addEventListener("message",L);const B=[];for(const n of b)B.push(n.data.buffer);n&&B.push(n.buffer),i.postMessage({id:"encodeMesh",attributes:b,indices:n,options:e},B)}))}))}if(this._modulePromise){const i=await this._modulePromise;return(0,lb.i)(i.module,b,n,e)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(b,n){if(0==b.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");b instanceof ub.b&&b.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===n||void 0===n?void 0:n.method)&&(R.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),n.method="MESH_SEQUENTIAL_ENCODING");const i=function(b){let n=b.Je(void 0,!0);return!n||n instanceof Uint32Array||n instanceof Uint16Array||(n=((0,J.c)(n,n.length)?Uint32Array:Uint16Array).from(n)),n}(b),e=function(b,n){const i=[];for(const e of b.getVerticesDataKinds()){if(null!==n&&void 0!==n&&n.includes(e)){if(e===vb.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const V=b.getVertexBuffer(e),Q=V.getSize(),U=(0,J.t)(V.getData(),Q,V.type,V.byteOffset,V.byteStride,V.normalized,b.getTotalVertices(),!0);i.push({kind:e,dracoName:fb(e),size:Q,data:U})}return i}(b,null===n||void 0===n?void 0:n.excludedAttributes);return await this._encodeAsync(e,i,n)}}bn.DefaultConfiguration={wasmUrl:`${V.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${V.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${V.Tools._DefaultCdnUrl}/draco_encoder.js`},bn._Default=null;const nn="KHR_draco_mesh_compression";class en{get wasUsed(){return this._wasUsed}constructor(b){this.name=nn,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===b.options.meshCompressionMethod&&bn.DefaultAvailable}dispose(){}postExportMeshPrimitive(b,n,i){if(!this.enabled)return;if(4!==b.mode&&5!==b.mode)return void R.b.Warn("Cannot compress primitive with mode "+b.mode+".");const e=[],V=[];let Q=null;if(void 0!==b.indices){const U=i[b.indices],Y=n.getBufferView(U);Q=n.getData(Y).slice(),e.push(Y),V.push(U)}const U=[];for(const[mb,N]of Object.entries(b.attributes)){const b=i[N],Q=n.getBufferView(b),L=S(b.type),B=(0,J.t)(n.getData(Q),L,b.componentType,b.byteOffset||0,Q.byteStride||(0,J.r)(b.componentType)*L,b.normalized||!1,b.count,!0);U.push({kind:mb,dracoName:(Y=mb,"POSITION"===Y?"POSITION":"NORMAL"===Y?"NORMAL":Y.startsWith("COLOR")?"COLOR":Y.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:S(b.type),data:B}),e.push(Q),V.push(b)}var Y;const L={method:b.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},B=bn.Default._encodeAsync(U,Q,L).then((i=>{if(!i)return void R.b.Error("Draco encoding failed for primitive.");const Q={bufferView:-1,attributes:i.attributeIds},U=n.createBufferView(i.data);n.setBufferView(Q,U);for(const b of e)this._bufferViewsUsed.add(b);for(const b of V)this._accessorsUsed.add(b);b.extensions||(b.extensions={}),b.extensions[nn]=Q})).catch((b=>{R.b.Error("Draco encoding failed for primitive: "+b)}));this._encodePromises.push(B),this._wasUsed=!0}async preGenerateBinaryAsync(b){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((n=>{b.getPropertiesWithBufferView(n).every((b=>this._accessorsUsed.has(b)))&&b.removeBufferView(n)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Pb.RegisterExtension(nn,(b=>new en(b)));var Vn=i(12388);const Qn="KHR_lights_punctual",Un={name:"",color:[1,1,1],GY:1,range:Number.MAX_VALUE},Yn={innerConeAngle:0,outerConeAngle:Math.PI/4},Ln=e.On.Backward();class Bn{constructor(b){this.name=Qn,this.enabled=!0,this.required=!1,this._exporter=b}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Qn]=this._lights}async postExportNodeAsync(b,n,i,V,Q){return await new Promise((U=>{if(!(i instanceof db.c))return void U(n);const Y=i.getTypeID()==db.c.LIGHTTYPEID_POINTLIGHT?"point":i.getTypeID()==db.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":i.getTypeID()==db.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!Y||!(i instanceof Vn.d))return R.b.Warn(`${b}: Light ${i.name} is not supported in ${Qn}`),void U(n);if(i.falloffType!==db.c.FALLOFF_GLTF&&R.b.Warn(`${b}: Light falloff for ${i.name} does not match the ${Qn} specification!`),!i.position.equalsToFloats(0,0,0)){const b=e.TmpVectors.On[0].L(i.position);Q&&p(b),n.translation=b.ye()}if("point"!==Y){const b=i.direction.normalizeToRef(e.TmpVectors.On[0]);Q&&p(b);const V=e.Quaternion.FromUnitVectorsToRef(Ln,b,e.TmpVectors.Quaternion[0]);e.Quaternion.IsIdentity(V)||(n.rotation=V.ye())}const L={type:Y,name:i.name,color:i.oY.ye(),GY:i.GY,range:i.range};if(eb(L,Un),"spot"===Y){const b=i;L.spot={innerConeAngle:b.innerAngle/2,outerConeAngle:b.angle/2},eb(L.spot,Yn)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(L);const B={ai:this._lights.lights.length-1},mb=i.parent;if(mb&&nb(i,mb)){const b=V.get(mb);if(b){const i=this._exporter._nodes[b];return bb(n,i),i.extensions||(i.extensions={}),i.extensions[Qn]=B,void U(null)}}n.extensions||(n.extensions={}),n.extensions[Qn]=B,U(n)}))}}Pb.RegisterExtension(Qn,(b=>new Bn(b)));var mi=i(12284);const Nn="KHR_materials_anisotropy";class Zn{constructor(b){this.name=Nn,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,n,i){const e=[];return i instanceof mi.c&&i.anisotropy.isEnabled&&!i.anisotropy.legacy?(i.anisotropy.texture&&e.push(i.anisotropy.texture),e):[]}postExportMaterialAsync(b,n,i){return new Promise((b=>{if(i instanceof mi.c){if(!i.anisotropy.isEnabled||i.anisotropy.legacy)return void b(n);this._wasUsed=!0,n.extensions=n.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(i.anisotropy.texture),V={anisotropyStrength:i.anisotropy.GY,anisotropyRotation:i.anisotropy.angle,anisotropyTexture:e??void 0};null!==V.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(i),n.extensions[Nn]=V}b(n)}))}}Pb.RegisterExtension(Nn,(b=>new Zn(b)));const Tn="KHR_materials_clearcoat";class zn{constructor(b){this.name=Tn,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,n,i){const e=[];return i instanceof mi.c&&i.clearCoat.isEnabled?(i.clearCoat.texture&&e.push(i.clearCoat.texture),!i.clearCoat.useRoughnessFromMainTexture&&i.clearCoat.textureRoughness&&e.push(i.clearCoat.textureRoughness),i.clearCoat.bumpTexture&&e.push(i.clearCoat.bumpTexture),e):[]}postExportMaterialAsync(b,n,i){return new Promise((b=>{if(i instanceof mi.c){if(!i.clearCoat.isEnabled)return void b(n);this._wasUsed=!0,n.extensions=n.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(i.clearCoat.texture);let Q;Q=i.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(i.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(i.clearCoat.textureRoughness),i.clearCoat.isTintEnabled&&V.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${i.name}`),i.clearCoat.remapF0OnInterfaceChange&&V.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${i.name}`);const U=this._exporter._materialExporter.getTextureInfo(i.clearCoat.bumpTexture),Y={clearcoatFactor:i.clearCoat.GY,clearcoatTexture:e??void 0,clearcoatRoughnessFactor:i.clearCoat.roughness,clearcoatRoughnessTexture:Q??void 0,clearcoatNormalTexture:U??void 0};null===Y.clearcoatTexture&&null===Y.clearcoatRoughnessTexture&&null===Y.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(i),n.extensions[Tn]=Y}b(n)}))}}Pb.RegisterExtension(Tn,(b=>new zn(b)));const Kn="KHR_materials_diffuse_transmission";function In(b,n){const i=n.subSurface;let e=null;return i.translucencyIntensityTexture?e=i.translucencyIntensityTexture:i.thicknessTexture&&i.useMaskFromThicknessTexture&&(e=i.thicknessTexture),e&&!i.useGltfStyleTextures?(R.b.Warn(`${b}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${n.name}`,1),null):e}class On{constructor(b){this.name=Kn,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,n,i){const e=[];if(i instanceof zb.c&&this._isExtensionEnabled(i)){const n=In(b,i);return n&&e.push(n),i.subSurface.translucencyColorTexture&&e.push(i.subSurface.translucencyColorTexture),e}return e}_isExtensionEnabled(b){if(b.unlit)return!1;const n=b.subSurface;return!!n.isTranslucencyEnabled&&(!b.unlit&&!n.useAlbedoToTintTranslucency&&n.useGltfStyleTextures&&1===n.volumeIndexOfRefraction&&0===n.minimumThickness&&0===n.maximumThickness)}postExportMaterialAsync(b,n,i){return new Promise((e=>{if(i instanceof zb.c&&this._isExtensionEnabled(i)){this._wasUsed=!0;const e=i.subSurface,V=In(b,i),Q=0==e.translucencyIntensity?void 0:e.translucencyIntensity,U=this._exporter._materialExporter.getTextureInfo(V)??void 0,Y=!e.translucencyColor||e.translucencyColor.equalsFloats(1,1,1)?void 0:e.translucencyColor.ye(),L=this._exporter._materialExporter.getTextureInfo(e.translucencyColorTexture)??void 0,B={diffuseTransmissionFactor:Q,diffuseTransmissionTexture:U,diffuseTransmissionColorFactor:Y,diffuseTransmissionColorTexture:L};(U||L)&&this._exporter._materialNeedsUVsSet.add(i),n.extensions=n.extensions||{},n.extensions[Kn]=B}e(n)}))}}Pb.RegisterExtension(Kn,(b=>new On(b)));const un="KHR_materials_dispersion";class dn{constructor(){this.name=un,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(b){if(b.unlit)return!1;const n=b.subSurface;return!(!n.isRefractionEnabled&&!n.isDispersionEnabled)}postExportMaterialAsync(b,n,i){return new Promise((b=>{if(i instanceof zb.c&&this._isExtensionEnabled(i)){this._wasUsed=!0;const b={dispersion:i.subSurface.dispersion};n.extensions=n.extensions||{},n.extensions[un]=b}b(n)}))}}Pb.RegisterExtension(un,(()=>new dn));const Gn="KHR_materials_emissive_strength";class on{constructor(){this.name=Gn,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(b,n,i){return await new Promise((b=>{if(!(i instanceof zb.c))return b(n);const e=i.emissiveColor.ye(),V=Math.max(...e);if(V>1){this._wasUsed=!0,n.extensions||(n.extensions={});const b={emissiveStrength:V},e=i.emissiveColor.scale(1/b.emissiveStrength);n.emissiveFactor=e.ye(),n.extensions[Gn]=b}return b(n)}))}}Pb.RegisterExtension(Gn,(b=>new on));const Mn="KHR_materials_ior";class jn{constructor(){this.name=Mn,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(b){return!b.unlit&&(void 0!=b.indexOfRefraction&&1.5!=b.indexOfRefraction)}postExportMaterialAsync(b,n,i){return new Promise((b=>{if(i instanceof zb.c&&this._isExtensionEnabled(i)){this._wasUsed=!0;const b={ior:i.indexOfRefraction};n.extensions=n.extensions||{},n.extensions[Mn]=b}b(n)}))}}Pb.RegisterExtension(Mn,(b=>new jn));const an="KHR_materials_iridescence";class Dn{constructor(b){this.name=an,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,n,i){const e=[];return i instanceof mi.c&&i.iridescence.isEnabled?(i.iridescence.texture&&e.push(i.iridescence.texture),i.iridescence.thicknessTexture&&i.iridescence.thicknessTexture!==i.iridescence.texture&&e.push(i.iridescence.thicknessTexture),e):[]}postExportMaterialAsync(b,n,i){return new Promise((b=>{if(i instanceof mi.c){if(!i.iridescence.isEnabled)return void b(n);this._wasUsed=!0,n.extensions=n.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(i.iridescence.texture),V=this._exporter._materialExporter.getTextureInfo(i.iridescence.thicknessTexture),Q={iridescenceFactor:i.iridescence.GY,iridescenceIor:i.iridescence.indexOfRefraction,iridescenceThicknessMinimum:i.iridescence.minimumThickness,iridescenceThicknessMaximum:i.iridescence.maximumThickness,iridescenceTexture:e??void 0,iridescenceThicknessTexture:V??void 0};null===Q.iridescenceTexture&&null===Q.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(i),n.extensions[an]=Q}b(n)}))}}Pb.RegisterExtension(an,(b=>new Dn(b)));const xn="KHR_materials_sheen";class yn{constructor(b){this.name=xn,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,n,i){return i instanceof zb.c&&i.sheen.isEnabled&&i.sheen.texture?[i.sheen.texture]:[]}async postExportMaterialAsync(b,n,i){return await new Promise((b=>{if(i instanceof zb.c){if(!i.sheen.isEnabled)return void b(n);this._wasUsed=!0,null==n.extensions&&(n.extensions={});const e={sheenColorFactor:i.sheen.color.ye(),sheenRoughnessFactor:i.sheen.roughness??0};null===e.sheenColorTexture&&null===e.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(i),i.sheen.texture&&(e.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.texture)??void 0),i.sheen.textureRoughness&&!i.sheen.useRoughnessFromMainTexture?e.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.textureRoughness)??void 0:i.sheen.texture&&i.sheen.useRoughnessFromMainTexture&&(e.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.texture)??void 0),n.extensions[xn]=e}b(n)}))}}Pb.RegisterExtension(xn,(b=>new yn(b)));const sn="KHR_materials_specular";class An{constructor(b){this.name=sn,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,n,i){const e=[];return i instanceof zb.c&&this._isExtensionEnabled(i)?(i.metallicReflectanceTexture&&e.push(i.metallicReflectanceTexture),i.reflectanceTexture&&e.push(i.reflectanceTexture),e):e}_isExtensionEnabled(b){return!b.unlit&&(void 0!=b.metallicF0Factor&&1!=b.metallicF0Factor||void 0!=b.metallicReflectanceColor&&!b.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(b))}_hasTexturesExtension(b){return null!=b.metallicReflectanceTexture||null!=b.reflectanceTexture}postExportMaterialAsync(b,n,i){return new Promise((b=>{if(i instanceof zb.c&&this._isExtensionEnabled(i)){this._wasUsed=!0,n.extensions=n.extensions||{};const b=this._exporter._materialExporter.getTextureInfo(i.metallicReflectanceTexture)??void 0,e=this._exporter._materialExporter.getTextureInfo(i.reflectanceTexture)??void 0,V={specularFactor:1==i.metallicF0Factor?void 0:i.metallicF0Factor,specularTexture:b,specularColorFactor:i.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:i.metallicReflectanceColor.ye(),specularColorTexture:e};this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),n.extensions[sn]=V}b(n)}))}}Pb.RegisterExtension(sn,(b=>new An(b)));const En="KHR_materials_transmission";class Cn{constructor(b){this.name=En,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,n,i){const e=[];return i instanceof zb.c&&this._isExtensionEnabled(i)?(i.subSurface.thicknessTexture&&e.push(i.subSurface.thicknessTexture),e):e}_isExtensionEnabled(b){if(b.unlit)return!1;const n=b.subSurface;return n.isRefractionEnabled&&void 0!=n.refractionIntensity&&0!=n.refractionIntensity||this._hasTexturesExtension(b)}_hasTexturesExtension(b){return null!=b.subSurface.refractionIntensityTexture}async postExportMaterialAsync(b,n,i){if(i instanceof zb.c&&this._isExtensionEnabled(i)){this._wasUsed=!0;const e=i.subSurface,V={transmissionFactor:0===e.refractionIntensity?void 0:e.refractionIntensity};if(this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),e.refractionIntensityTexture)if(e.useGltfStyleTextures){const b=await this._exporter._materialExporter.exportTextureAsync(e.refractionIntensityTexture,"image/png");b&&(V.transmissionTexture=b)}else R.b.Warn(`${b}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);n.extensions||(n.extensions={}),n.extensions[En]=V}return n}}Pb.RegisterExtension(En,(b=>new Cn(b)));const tn="KHR_materials_unlit";class wn{constructor(){this.name=tn,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(b,n,i){return new Promise((b=>{let e=!1;i instanceof zb.c?e=i.unlit:i instanceof Kb.Gn&&(e=i.disableLighting),e&&(this._wasUsed=!0,null==n.extensions&&(n.extensions={}),n.extensions[tn]={}),b(n)}))}}Pb.RegisterExtension(tn,(()=>new wn));const hn="KHR_materials_volume";class Wn{constructor(b){this.name=hn,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,n,i){const e=[];return i instanceof zb.c&&this._isExtensionEnabled(i)?(i.subSurface.thicknessTexture&&e.push(i.subSurface.thicknessTexture),e):e}_isExtensionEnabled(b){if(b.unlit)return!1;const n=b.subSurface;return!(!n.isRefractionEnabled&&!n.isTranslucencyEnabled)&&(void 0!=n.maximumThickness&&0!=n.maximumThickness||void 0!=n.tintColorAtDistance&&n.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=n.tintColor&&n.tintColor!=I.Mn.White()||this._hasTexturesExtension(b))}_hasTexturesExtension(b){return null!=b.subSurface.thicknessTexture}postExportMaterialAsync(b,n,i){return new Promise((b=>{if(i instanceof zb.c&&this._isExtensionEnabled(i)){this._wasUsed=!0;const b=i.subSurface,e={thicknessFactor:0==b.maximumThickness?void 0:b.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(b.thicknessTexture)??void 0,attenuationDistance:b.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:b.tintColorAtDistance,attenuationColor:b.tintColor.equalsFloats(1,1,1)?void 0:b.tintColor.ye()};this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),n.extensions=n.extensions||{},n.extensions[hn]=e}b(n)}))}}Pb.RegisterExtension(hn,(b=>new Wn(b)));const Jn="EXT_materials_diffuse_roughness";class Rn{constructor(b){this.name=Jn,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=b}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(b,n,i){const e=[];return i instanceof mi.c&&i._baseDiffuseRoughness?(i._baseDiffuseRoughnessTexture&&e.push(i._baseDiffuseRoughnessTexture),e):[]}postExportMaterialAsync(b,n,i){return new Promise((b=>{if(i instanceof mi.c){if(!i._baseDiffuseRoughness)return void b(n);this._wasUsed=!0,n.extensions=n.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(i._baseDiffuseRoughnessTexture),V={diffuseRoughnessFactor:i._baseDiffuseRoughness,diffuseRoughnessTexture:e??void 0};null!==V.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(i),n.extensions[Jn]=V}b(n)}))}}Pb.RegisterExtension(Jn,(b=>new Rn(b)));const kn="KHR_texture_transform";class rn{constructor(){this.name=kn,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(b,n,i){if(i.ab()||V.Tools.Warn(`${b}: /*@__KEY__*/"scene" is not defined for Babylon texture ${i.name}!`),(0!==i.uAng||0!==i.vAng)&&(V.Tools.Warn(`${b}: Texture ${i.name} with rotation in the u or v axis is not supported in glTF.`),0!==i.uRotationCenter||0!==i.vRotationCenter))return;const e={};let Q=!1;if(0===i.uOffset&&0===i.vOffset||(e.offset=[i.uOffset,i.vOffset],Q=!0),1===i.uScale&&1===i.vScale||(e.scale=[i.uScale,i.vScale],Q=!0),0!==i.wAng){if(0!==i.uRotationCenter||0!==i.vRotationCenter){if(i.homogeneousRotationInUVTransform&&i.uScale!==i.vScale)return void V.Tools.Warn(`${b}: Texture ${i.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${kn}.`);V.Tools.Warn(`${b}: Texture ${i.name} with non-origin rotation center will be exported using an adjusted offset with ${kn}.`),e.offset=function(b){const{uOffset:n,vOffset:i,uRotationCenter:e,vRotationCenter:V,uScale:Q,vScale:U,wAng:Y}=b,L=Math.cos(Y),B=Math.sin(Y),mb=e*Q,N=V*U;return[n+(mb*(1-L)+N*B),i+(N*(1-L)-mb*B)]}(i)}e.rotation=-i.wAng,Q=!0}0!==i.coordinatesIndex&&(e.texCoord=i.coordinatesIndex,Q=!0),Q&&(this._wasUsed=!0,n.extensions||(n.extensions={}),n.extensions[kn]=e)}}Pb.RegisterExtension(kn,(()=>new rn));class Xn{static CreateSTL(b){let n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",V=arguments.length>3&&void 0!==arguments[3]&&arguments[3],Q=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],U=arguments.length>5&&void 0!==arguments[5]&&arguments[5],Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6],L=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const B=function(b,n,i){const V=[3*b[i],3*b[i+1],3*b[i+2]],Q=[new e.On(n[V[0]],n[V[0]+2],n[V[0]+1]),new e.On(n[V[1]],n[V[1]+2],n[V[1]+1]),new e.On(n[V[2]],n[V[2]+2],n[V[2]+1])],U=Q[0].un(Q[1]),Y=Q[2].un(Q[1]);return{v:Q,n:e.On.Cross(Y,U).normalize()}},N=function(b,n,i,e){return n=Z(b,n,i.x,e),n=Z(b,n,i.y,e),Z(b,n,i.z,e)},Z=function(b,n,i,e){return b.setFloat32(n,i,e),n+4},z=function(b){if(Y){let n=b;b instanceof T.e&&(n=b.sourceMesh);const i=n.getVerticesData(mb.g.PositionKind,!0,!0);if(!i)return[];const V=e.On.Zero();let Q;for(Q=0;Q<i.length;Q+=3)e.On.TransformCoordinatesFromFloatsToRef(i[Q],i[Q+1],i[Q+2],b.we(!0),V).toArray(i,Q);return i}return b.getVerticesData(mb.g.PositionKind)||[]};Y&&(U=!0);let K="",I=0,O=0;if(V){for(let i=0;i<b.length;i++){const n=b[i].Je();I+=n?n.length/3:0}const n=new ArrayBuffer(84+50*I);K=new DataView(n),O+=80,K.setUint32(O,I,Q),O+=4}else L||(K="solid stlmesh\r\n");for(let e=0;e<b.length;e++){const n=b[e];!V&&L&&(K+="solid "+n.name+"\r\n"),!U&&n instanceof ub.b&&n.bakeCurrentTransformIntoVertices();const i=z(n),Y=n.Je()||[];for(let b=0;b<Y.length;b+=3){const n=B(Y,i,b);V?(O=N(K,O,n.n,Q),O=N(K,O,n.v[0],Q),O=N(K,O,n.v[1],Q),O=N(K,O,n.v[2],Q),O+=2):(K+="\tfacet normal "+n.n.x+" "+n.n.y+" "+n.n.z+"\r\n",K+="\t\touter loop\r\n",K+="\t\t\tvertex "+n.v[0].x+" "+n.v[0].y+" "+n.v[0].z+"\r\n",K+="\t\t\tvertex "+n.v[1].x+" "+n.v[1].y+" "+n.v[1].z+"\r\n",K+="\t\t\tvertex "+n.v[2].x+" "+n.v[2].y+" "+n.v[2].z+"\r\n",K+="\t\tendloop\r\n",K+="\tendfacet\r\n")}!V&&L&&(K+="endsolid "+name+"\r\n")}if(V||L||(K+="endsolid stlmesh"),n){const b=document.createElement("a"),n=new Blob([K],{type:"application/octet-stream"});b.href=window.URL.createObjectURL(n),b.download=i+".stl",b.click()}return K}}function gn(b,n){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const e=[];for(let V=0;V<b.length/i;V++){const Q=b[V*i],U=b[V*i+1],Y=b[V*i+2];e.push(`(${Q.toPrecision(n.precision)}, ${U.toPrecision(n.precision)}, ${Y.toPrecision(n.precision)})`)}return e.join(", ")}function Pn(b,n){const i=[];for(let e=0;e<b.length/2;e++){const V=b[2*e],Q=b[2*e+1];i.push(`(${V.toPrecision(n.precision)}, ${(1-Q).toPrecision(n.precision)})`)}return i.join(", ")}function cn(b,n){const i=b.getVerticesData(mb.g.PositionKind),e=b.getVerticesData(mb.g.NormalKind);if(i&&e)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(b){var n;const i=null!==(n=b.Je())&&void 0!==n&&n.length?b.getTotalIndices():b.getTotalVertices();return Array(i/3).fill(3).join(", ")}(b)}]\n\t\tint[] faceVertexIndices = [${function(b){const n=b.Je(),i=[];if(null!==n)for(let e=0;e<n.length;e++)i.push(n[e]);else{const n=b.getTotalVertices();for(let b=0;b<n;b++)i.push(b)}return i.join(", ")}(b)}]\n\t\tnormal3f[] normals = [${gn(e,n)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${gn(i,n)}]\n        ${function(b,n){let i="";for(let V=0;V<4;V++){const e=V>0?V:"",Q=b.getVerticesData(mb.g.UVKind+(e?e+1:""));Q&&(i+=`\n\t\ttexCoord2f[] primvars:st${e} = [${Pn(Q,n)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const e=b.getVerticesData(mb.g.ColorKind);return e&&(i+=`\n\tcolor3f[] primvars:displayColor = [${gn(e,n,e.length/b.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),i}(b,n)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function qn(b,n){return`\n        def "Geometry"\n        {\n        ${cn(b,n)}\n        }\n        `}function Sn(b){let n='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return n+=b,fflate.strToU8(n)}function Hn(b){const n=b.m;return`( ${ln(n,0)}, ${ln(n,4)}, ${ln(n,8)}, ${ln(n,12)} )`}function ln(b,n){return`(${b[n+0]}, ${b[n+1]}, ${b[n+2]}, ${b[n+3]})`}function vn(b){const n="Object_"+b.uniqueId,i=function(b){const n=b.getWorldMatrix().clone(),i=b.ab().useRightHandedSystem;if(!i){let e=b.parent;for(;e;){if(Ub(e,i)){n.multiplyToRef(e.getWorldMatrix().invert(),n);break}e=e.parent}}return n.determinant()<0&&V.Tools.Warn(`Exporting mesh ${b.name} with negative scale. Result may look incorrect in destination engine.`),n}(b),e=Hn(i);return`def Xform "${n}" (\n\tprepend references = @./geometries/Geometry_${b.We.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${e}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${b.material.uniqueId}>\n}\n\n`}function pn(b){switch(b){case j.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case j.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case j.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function fn(b){return`(${b.x}, ${b.y})`}function Fn(b){return`(${b.r}, ${b.g}, ${b.b})`}function bi(b,n,i,V,Q,U){const Y=b.getInternalTexture().uniqueId+"_"+b.invertY;Q[Y]=b;const L=b.coordinatesIndex>0?"st"+b.coordinatesIndex:"st",B=new e.Vector2(b.uScale,b.vScale),mb=new e.Vector2(b.uOffset,b.vOffset),N=b.wAng,Z=Math.sin(N),T=Math.cos(N);return mb.y=1-mb.y-B.y,mb.x+=Z*B.x,mb.y+=(1-T)*B.y,`\n    def Shader "PrimvarReader_${i}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${L}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${i}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${n.uniqueId}/PrimvarReader_${i}.outputs:result>\n        float inputs:rotation = ${(N*(180/Math.PI)).toFixed(U.precision)}\n        float2 inputs:scale = ${fn(B)}\n        float2 inputs:translation = ${fn(mb)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${b.uniqueId}_${i}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${Y}.png@\n        float2 inputs:st.connect = </Materials/Material_${n.uniqueId}/Transform2d_${i}.outputs:result>\n        ${V?"float4 inputs:scale = "+function(b){return`(${b.r}, ${b.g}, ${b.b}, 1.0)`}(V):""}\n        token inputs:sourceColorSpace = "${b.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${pn(b.wrapU)}"\n        token inputs:wrapT = "${pn(b.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${n.needAlphaBlending()?"float outputs:a":""}\n    }`}function ni(b,n,i){const e="\t\t\t",V=[],Q=[],{diffuseMap:U,oY:Y,alphaCutOff:L,emissiveMap:B,emissive:mb,normalMap:N,roughnessMap:Z,roughnessChannel:T,roughness:z,metalnessMap:K,metalnessChannel:O,metalness:u,aoMap:d,aoMapChannel:G,aoMapIntensity:o,alphaMap:M,ior:j,clearCoatEnabled:a,clearCoat:D,clearCoatMap:x,clearCoatRoughness:y,clearCoatRoughnessMap:s}=function(b){const n={diffuseMap:null,oY:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return b instanceof Kb.Gn?{...n,diffuseMap:b.diffuseTexture,oY:b.diffuseColor,alphaCutOff:b.alphaCutOff,emissiveMap:b.emissiveTexture,emissive:b.emissiveColor,roughness:1,alphaMap:b.opacityTexture}:b instanceof mi.c?{...n,diffuseMap:b._albedoTexture,oY:b._albedoColor,alphaCutOff:b._alphaCutOff,emissiveMap:b._emissiveTexture,emissive:b._emissiveColor,normalMap:b._bumpTexture,roughnessMap:b._metallicTexture,roughnessChannel:b._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:b._roughness??1,metalnessMap:b._metallicTexture,metalnessChannel:b._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:b._metallic??0,aoMap:b._ambientTexture,aoMapChannel:b._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:b._ambientTextureStrength,alphaMap:b._opacityTexture,ior:b.subSurface.indexOfRefraction,clearCoatEnabled:b.clearCoat.isEnabled,clearCoat:b.clearCoat.GY,clearCoatMap:b.clearCoat.texture,clearCoatRoughness:b.clearCoat.roughness,clearCoatRoughnessMap:b.clearCoat.useRoughnessFromMainTexture?b.clearCoat.texture:b.clearCoat.textureRoughness}:n}(b);return null!==U?(V.push(`${e}color3f inputs:diffuseColor.connect = </Materials/Material_${b.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:rgb>`),b.needAlphaBlending()?V.push(`${e}float inputs:opacity.connect = </Materials/Material_${b.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:a>`):b.needAlphaTesting()&&(V.push(`${e}float inputs:opacity.connect = </Materials/Material_${b.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:a>`),V.push(`${e}float inputs:opacityThreshold = ${L}`)),Q.push(bi(U,b,"diffuse",Y,n,i))):V.push(`${e}color3f inputs:diffuseColor = ${Fn(Y||I.Mn.White())}`),null!==B?(V.push(`${e}color3f inputs:emissiveColor.connect = </Materials/Material_${b.uniqueId}/Texture_${B.uniqueId}_emissive.outputs:rgb>`),Q.push(bi(B,b,"emissive",mb,n,i))):mb&&mb.toLuminance()>0&&V.push(`${e}color3f inputs:emissiveColor = ${Fn(mb)}`),null!==N&&(V.push(`${e}normal3f inputs:normal.connect = </Materials/Material_${b.uniqueId}/Texture_${N.uniqueId}_normal.outputs:rgb>`),Q.push(bi(N,b,"normal",null,n,i))),null!==d&&(V.push(`${e}float inputs:occlusion.connect = </Materials/Material_${b.uniqueId}/Texture_${d.uniqueId}_occlusion.outputs:${G}>`),Q.push(bi(d,b,"occlusion",new I.Mn(o,o,o),n,i))),null!==Z?(V.push(`${e}float inputs:roughness.connect = </Materials/Material_${b.uniqueId}/Texture_${Z.uniqueId}_roughness.outputs:${T}>`),Q.push(bi(Z,b,"roughness",new I.Mn(z,z,z),n,i))):V.push(`${e}float inputs:roughness = ${z}`),null!==K?(V.push(`${e}float inputs:metallic.connect = </Materials/Material_${b.uniqueId}/Texture_${K.uniqueId}_metallic.outputs:${O}>`),Q.push(bi(K,b,"metallic",new I.Mn(u,u,u),n,i))):V.push(`${e}float inputs:metallic = ${u}`),null!==M?(V.push(`${e}float inputs:opacity.connect = </Materials/Material_${b.uniqueId}/Texture_${M.uniqueId}_opacity.outputs:r>`),V.push(`${e}float inputs:opacityThreshold = 0.0001`),Q.push(bi(M,b,"opacity",null,n,i))):V.push(`${e}float inputs:opacity = ${b.alpha}`),a&&(null!==x?(V.push(`${e}float inputs:clearcoat.connect = </Materials/Material_${b.uniqueId}/Texture_${x.uniqueId}_clearcoat.outputs:r>`),Q.push(bi(x,b,"clearcoat",new I.Mn(D,D,D),n,i))):V.push(`${e}float inputs:clearcoat = ${D}`),null!==s?(V.push(`${e}float inputs:clearcoatRoughness.connect = </Materials/Material_${b.uniqueId}/Texture_${s.uniqueId}_clearcoatRoughness.outputs:g>`),Q.push(bi(s,b,"clearcoatRoughness",new I.Mn(y,y,y),n,i))):V.push(`${e}float inputs:clearcoatRoughness = ${y}`)),V.push(`${e}float inputs:ior = ${j}`),`\n\tdef Material "Material_${b.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${V.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${b.uniqueId}/PreviewSurface.outputs:surface>\n\n${Q.join("\n")}\n\n\t}\n`}async function ii(b,n,i){const Q={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...n};"undefined"===typeof fflate&&await V.Tools.LoadScriptAsync(Q.fflateUrl);const U={};U[Q.modelFileName]=null;let Y='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';Y+=function(b){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===b.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${b.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${b.planeAnchoringAlignment}"`:""}\n            `}(Q);const L={};for(const e of b.meshes){if(0===e.getTotalVertices())continue;const b=e,n=b.We,B=b.material;if(!B||!n||i&&!i(b))continue;if(-1!==["Gn","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(B.getClassName())){const i="geometries/Geometry_"+n.uniqueId+".usda";if(!(i in U)){const b=qn(n,Q);U[i]=Sn(b)}B.uniqueId in L||(L[B.uniqueId]=B),Y+=vn(b)}else V.Tools.Warn("USDZExportAsync does not support this material type: "+B.getClassName())}b.activeCamera&&Q.exportCamera&&(Y+=function(b,n){const i="Camera_"+b.uniqueId,V=Hn(e.Matrix.RotationY(Math.PI).multiply(b.getWorldMatrix()));if(b.mode===j.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${i}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${V}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${b.Ae.toPrecision(n.precision)}, ${b.maxZ.toPrecision(n.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(b.orthoLeft||1)+Math.abs(b.orthoRight||1))).toPrecision(n.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(b.orthoTop||1)+Math.abs(b.orthoBottom||1))).toPrecision(n.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const e=b.getEngine().getAspectRatio(b),Q=n.cameraSensorWidth||35;return`def Camera "${i}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${V}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${b.Ae.toPrecision(n.precision)}, ${b.maxZ.toPrecision(n.precision)})\n\t\t\tfloat focalLength = ${(Q/(2*Math.tan(.5*b.fov))).toPrecision(n.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(Q*e).toPrecision(n.precision)}\n\t\t\tfloat verticalAperture = ${(Q/e).toPrecision(n.precision)}            \n\t\t}\n\t\n\t`}}(b.activeCamera,Q)),Y+="\n            }\n        }\n    }";const B={};Y+=function(b,n,i){const e=[];for(const V in b){const Q=b[V];e.push(ni(Q,n,i))}return`\n    def "Materials"\n{\n${e.join("")}\n}\n\n`}(L,B,Q),U[Q.modelFileName]=fflate.strToU8(Y);for(const e in B){const b=B[e],n=b.getSize(),i=await b.readPixels();if(!i)throw new Error("Texture data is not available");const V=await a.DumpTools.DumpDataAsync(n.width,n.height,i,"image/png",void 0,!1,!0);U[`textures/Texture_${e}.png`]=new Uint8Array(V).slice()}let mb=0;for(const e in U){const b=U[e];if(!b)continue;mb+=34+e.length;const n=63&mb;if(4!==n){const i=new Uint8Array(64-n);U[e]=[b,{extra:{12345:i}}]}mb=b.length}return fflate.zipSync(U,{level:0})}}}]);