"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[26],{11610:(P,f,Y)=>{Y.r(f),Y.d(f,{EXT_materials_diffuse_roughness:()=>xf,EXT_mesh_gpu_instancing:()=>BP,GLTF2Export:()=>GP,GLTFData:()=>d,KHR_draco_mesh_compression:()=>Yf,KHR_lights_punctual:()=>wf,KHR_materials_anisotropy:()=>yf,KHR_materials_clearcoat:()=>uf,KHR_materials_diffuse_transmission:()=>Kf,KHR_materials_dispersion:()=>Vf,KHR_materials_emissive_strength:()=>nf,KHR_materials_ior:()=>vf,KHR_materials_iridescence:()=>Tf,KHR_materials_sheen:()=>Df,KHR_materials_specular:()=>ef,KHR_materials_transmission:()=>af,KHR_materials_unlit:()=>Jf,KHR_materials_volume:()=>If,KHR_texture_transform:()=>Zf,OBJExport:()=>L,STLExport:()=>Af,USDZExportAsync:()=>YY,_ConvertToGLTFPBRMetallicRoughness:()=>a,_SolveMetallic:()=>s,__IGLTFExporterExtension:()=>o});var C=Y(11179),q=Y(11014),m=Y(11524);class L{static OBJ(P,f,Y,L){const o=[];let w=1,d=1;f&&(Y||(Y="mat"),o.push("mtllib "+Y+".mtl"));for(let R=0;R<P.length;R++){const Y=P[R],y=Y.name||`mesh${R}}`;o.push(`o ${y}`);let r=null;if(L){const P=Y.XC(!0);r=new C.Matrix,P.invertToRef(r),Y.bakeTransformIntoVertices(P)}if(f){const P=Y.material;P&&o.push("usemtl "+P.id)}const i=Y.qq;if(!i){q.Tools.Warn("No geometry is present on the mesh");continue}const u=i.getVerticesData("position"),g=i.getVerticesData("normal"),S=i.getVerticesData("uv"),K=i.eq();let M=0,V=0;if(!u||!K){q.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const O=P[0].vP().useRightHandedSystem?1:-1;for(let P=0;P<u.length;P+=3)o.push("v "+u[P]*O+" "+u[P+1]+" "+u[P+2]),M++;if(null!=g)for(let P=0;P<g.length;P+=3)o.push("vn "+g[P]*O+" "+g[P+1]+" "+g[P+2]);if(null!=S)for(let P=0;P<S.length;P+=2)o.push("vt "+S[P]+" "+S[P+1]),V++;const n=["","",""],l=(Y.material||Y.vP().defaultMaterial)._getEffectiveOrientation(Y),[v,c]=l===m.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let P=0;P<K.length;P+=3){const f=[String(K[P]+w),String(K[P+v]+w),String(K[P+c]+w)],Y=[String(K[P]+d),String(K[P+v]+d),String(K[P+c]+d)],C=f,q=null!=S?Y:n,m=null!=g?f:n;o.push("f "+C[0]+"/"+q[0]+"/"+m[0]+" "+C[1]+"/"+q[1]+"/"+m[1]+" "+C[2]+"/"+q[2]+"/"+m[2])}L&&r&&Y.bakeTransformIntoVertices(r),w+=M,d+=V}return o.join("\n")}static MTL(P){const f=[],Y=P.material;f.push("newmtl mat1"),f.push("  Ns "+Y.specularPower.toFixed(4)),f.push("  Ni 1.5000"),f.push("  d "+Y.alpha.toFixed(4)),f.push("  Tr 0.0000"),f.push("  Tf 1.0000 1.0000 1.0000"),f.push("  illum 2"),f.push("  Ka "+Y.ambientColor.r.toFixed(4)+" "+Y.ambientColor.g.toFixed(4)+" "+Y.ambientColor.b.toFixed(4)),f.push("  Kd "+Y.diffuseColor.r.toFixed(4)+" "+Y.diffuseColor.g.toFixed(4)+" "+Y.diffuseColor.b.toFixed(4)),f.push("  Ks "+Y.specularColor.r.toFixed(4)+" "+Y.specularColor.g.toFixed(4)+" "+Y.specularColor.b.toFixed(4)),f.push("  Ke "+Y.emissiveColor.r.toFixed(4)+" "+Y.emissiveColor.g.toFixed(4)+" "+Y.emissiveColor.b.toFixed(4));Y.ambientTexture&&f.push("  map_Ka "+Y.ambientTexture.name),Y.diffuseTexture&&f.push("  map_Kd "+Y.diffuseTexture.name),Y.specularTexture&&f.push("  map_Ks "+Y.specularTexture.name),Y.bumpTexture&&f.push("  map_bump -imfchan z "+Y.bumpTexture.name),Y.opacityTexture&&f.push("  map_d "+Y.opacityTexture.name);return f.join("\n")}}var o=0,w=Y(11059);class d{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const P in this.files){const f=this.files[P],Y=new Blob([f],{type:(0,w.h)(P)});q.Tools.Download(Y,P)}}}var R=Y(11255),y=Y(11612),r=Y(11622),i=Y(11641),u=Y(11319),g=Y(11052),S=Y(11228),K=Y(11198);const M=K.HighestCommonFactor,V={...K,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:M};var O=Y(11421),n=Y(11160),l=Y(11671),v=Y(11676),c=Y(11413);const T=1e-6,U=new S.Df(.04,.04,.04),D=1024,j=S.Df.White(),e=S.Df.Black();function s(P,f,Y){if(f<U.r)return 0;const C=U.r,q=P*Y/(1-U.r)+f-2*U.r,m=q*q-4*C*(U.r-f);return V.Clamp((-q+Math.sqrt(m))/(2*C),0,1)}function a(P){const f=P.diffuseColor.toLinearSpace(P.vP().getEngine().useExactSrgbConversions).scale(.5),Y=P.alpha,q=function(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new C.Vector2(0,1),Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new C.Vector2(0,.1),q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new C.Vector2(0,.1),m=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new C.Vector2(1300,.1);return function(P,f,Y,C,q){return(1-P)*(1-P)*(1-P)*f+3*(1-P)*(1-P)*P*Y+3*(1-P)*P*P*C+P*P*P*q}(Math.pow(P/m.x,.333333),f.y,Y.y,q.y,m.y)}(V.Clamp(P.specularPower,0,D));return{baseColorFactor:[f.r,f.g,f.b,Y],metallicFactor:0,roughnessFactor:q}}function Q(P,f){f.needAlphaBlending()?P.alphaMode="BLEND":f.needAlphaTesting()&&(P.alphaMode="MASK",P.alphaCutoff=f.alphaCutOff)}function J(P,f,Y){const C=new Uint8Array(P*f*4);for(let q=0;q<C.length;q+=4)C[q]=C[q+1]=C[q+2]=C[q+3]=255;return l.d.CreateRGBATexture(C,P,f,Y)}function N(P){if(P instanceof Uint8Array){const f=P.length,Y=new Float32Array(P.length);for(let C=0;C<f;++C)Y[C]=P[C]/255;return Y}if(P instanceof Float32Array)return P;throw new Error("Unsupported pixel format!")}class I{constructor(P){this._exporter=P,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(P){return P?this._textureMap.get(P)??null:null}async exportStandardMaterialAsync(P,f,Y){const C=a(P),m={name:P.name};if(null==P.XL||P.XL||(P.twoSidedLighting||q.Tools.Warn(P.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),m.doubleSided=!0),Y){const Y=[],q=P.diffuseTexture;q&&Y.push(this.exportTextureAsync(q,f).then((P=>{P&&(C.baseColorTexture=P)})));const L=P.bumpTexture;L&&Y.push(this.exportTextureAsync(L,f).then((P=>{P&&(m.normalTexture=P,1!==L.level&&(m.normalTexture.scale=L.level))})));const o=P.emissiveTexture;o&&(m.emissiveFactor=[1,1,1],Y.push(this.exportTextureAsync(o,f).then((P=>{P&&(m.emissiveTexture=P)}))));const w=P.ambientTexture;w&&Y.push(this.exportTextureAsync(w,f).then((P=>{if(P){const f={index:P.index};m.occlusionTexture=f}}))),Y.length>0&&(this._exporter._materialNeedsUVsSet.add(P),await Promise.all(Y))}(P.alpha<1||P.opacityTexture)&&(P.alphaMode===v.e.ALPHA_COMBINE?m.alphaMode="BLEND":q.Tools.Warn(P.name+": glTF 2.0 does not support alpha mode: "+P.alphaMode.toString())),P.emissiveColor&&!P.emissiveColor.equalsWithEpsilon(e,T)&&(m.emissiveFactor=P.emissiveColor.If()),m.pbrMetallicRoughness=C,Q(m,P),await this._finishMaterialAsync(m,P,f);const L=this._exporter._materials;return L.push(m),L.length-1}async _finishMaterialAsync(P,f,Y){const C=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",P,f),q=[];for(const m of C)q.push(this.exportTextureAsync(m,Y));await Promise.all(q),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",P,f)}async _getImageDataAsync(P,f,C,q){const m=v.e.TEXTURETYPE_UNSIGNED_BYTE,L=this._exporter._babylonScene,o=L.getEngine(),w=o.createRawTexture(P,f,C,v.e.TEXTUREFORMAT_RGBA,!1,!0,n.c.NEAREST_SAMPLINGMODE,null,m);o.isWebGPU?await Y.e(51).then(Y.bind(Y,13699)):await Y.e(52).then(Y.bind(Y,13705)),await O.h.ApplyPostProcess("pass",w,L,m,v.e.TEXTURE_NEAREST_SAMPLINGMODE,v.e.TEXTUREFORMAT_RGBA);const d=await o._readTexturePixels(w,f,C);return await c.DumpTools.DumpDataAsync(f,C,d,q,void 0,!0,!0)}_resizeTexturesToSameDimensions(P,f,Y){const C=P?P.getSize():{width:0,height:0},q=f?f.getSize():{width:0,height:0};let m,L;return C.width<q.width?(m=P&&P instanceof n.c?O.h.CreateResizedCopy(P,q.width,q.height,!0):J(q.width,q.height,Y),L=f):C.width>q.width?(L=f&&f instanceof n.c?O.h.CreateResizedCopy(f,C.width,C.height,!0):J(C.width,C.height,Y),m=P):(m=P,L=f),{texture1:m,texture2:L}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(P,f,Y,C){const q=new Array;if(!P&&!f)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const m=P?P.vP():f?f.vP():null;if(m){var L;const o=this._resizeTexturesToSameDimensions(P,f,m),w=null===(L=o.texture1)||void 0===L?void 0:L.getSize();let d,R;const y=w.width,r=w.height,i=await o.texture1.readPixels(),u=await o.texture2.readPixels();if(!i)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(d=N(i),!u)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");R=N(u);const g=R.byteLength,K=new Uint8Array(g),M=new Uint8Array(g),V=4,O=e;let n=0,l=0;for(let P=0;P<r;++P)for(let f=0;f<y;++f){const C=(y*P+f)*V,q={diffuseColor:new S.Df(d[C],d[C+1],d[C+2]).toLinearSpace(m.getEngine().useExactSrgbConversions).multiply(Y.diffuseColor),specularColor:new S.Df(R[C],R[C+1],R[C+2]).toLinearSpace(m.getEngine().useExactSrgbConversions).multiply(Y.specularColor),glossiness:R[C+3]*Y.glossiness},L=this._convertSpecularGlossinessToMetallicRoughness(q);O.r=Math.max(O.r,L.baseColor.r),O.g=Math.max(O.g,L.baseColor.g),O.b=Math.max(O.b,L.baseColor.b),n=Math.max(n,L.metallic),l=Math.max(l,L.roughness),M[C]=255*L.baseColor.r,M[C+1]=255*L.baseColor.g,M[C+2]=255*L.baseColor.b,M[C+3]=o.texture1.Gf?255*d[C+3]:255,K[C]=0,K[C+1]=255*L.roughness,K[C+2]=255*L.metallic,K[C+3]=255}const v={baseColor:O,metallic:n,roughness:l};let c=!1,U=!1;for(let P=0;P<r;++P)for(let f=0;f<y;++f){const Y=(y*P+f)*V;M[Y]/=v.baseColor.r>T?v.baseColor.r:1,M[Y+1]/=v.baseColor.g>T?v.baseColor.g:1,M[Y+2]/=v.baseColor.b>T?v.baseColor.b:1;const C=S.Df.FromInts(M[Y],M[Y+1],M[Y+2]).toGammaSpace(m.getEngine().useExactSrgbConversions);M[Y]=255*C.r,M[Y+1]=255*C.g,M[Y+2]=255*C.b,C.equalsWithEpsilon(j,T)||(U=!0),K[Y+1]/=v.roughness>T?v.roughness:1,K[Y+2]/=v.metallic>T?v.metallic:1;S.Df.FromInts(255,K[Y+1],K[Y+2]).equalsWithEpsilon(j,T)||(c=!0)}return c&&q.push(this._getImageDataAsync(K,y,r,C).then((P=>{v.metallicRoughnessTextureData=P}))),U&&q.push(this._getImageDataAsync(M,y,r,C).then((P=>{v.baseColorTextureData=P}))),await Promise.all(q).then((()=>v))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(P){const f=this._getPerceivedBrightness(P.diffuseColor),Y=this._getPerceivedBrightness(P.specularColor),C=1-this._getMaxComponent(P.specularColor),q=s(f,Y,C),m=P.diffuseColor.scale(C/(1-U.r)/Math.max(1-q)),L=P.specularColor.nf(U.scale(1-q)).scale(1/Math.max(q));let o=S.Df.Lerp(m,L,q*q);o=o.clampToRef(0,1,o);return{baseColor:o,metallic:q,roughness:1-P.glossiness}}_getPerceivedBrightness(P){return P?Math.sqrt(.299*P.r*P.r+.587*P.g*P.g+.114*P.b*P.b):0}_getMaxComponent(P){return P?Math.max(P.r,Math.max(P.g,P.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(P,f,Y,C){const q=[],m={baseColor:P._albedoColor,metallic:P._metallic,roughness:P._roughness};if(C){P._albedoTexture&&q.push(this.exportTextureAsync(P._albedoTexture,f).then((P=>{P&&(Y.baseColorTexture=P)})));const C=P._metallicTexture;C&&q.push(this.exportTextureAsync(C,f).then((P=>{P&&(Y.metallicRoughnessTexture=P)})))}return q.length>0&&(this._exporter._materialNeedsUVsSet.add(P),await Promise.all(q)),m}_getTextureSampler(P){const f={};if(!P||!(P instanceof n.c))return f;const Y=this._getGLTFTextureWrapMode(P.wrapU);10497!==Y&&(f.wrapS=Y);const C=this._getGLTFTextureWrapMode(P.wrapV);switch(10497!==C&&(f.wrapT=C),P.samplingMode){case n.c.LINEAR_LINEAR:f.magFilter=9729,f.minFilter=9729;break;case n.c.LINEAR_NEAREST:f.magFilter=9729,f.minFilter=9728;break;case n.c.NEAREST_LINEAR:f.magFilter=9728,f.minFilter=9729;break;case n.c.NEAREST_LINEAR_MIPLINEAR:f.magFilter=9728,f.minFilter=9987;break;case n.c.NEAREST_NEAREST:f.magFilter=9728,f.minFilter=9728;break;case n.c.NEAREST_LINEAR_MIPNEAREST:f.magFilter=9728,f.minFilter=9985;break;case n.c.LINEAR_NEAREST_MIPNEAREST:f.magFilter=9729,f.minFilter=9984;break;case n.c.LINEAR_NEAREST_MIPLINEAR:f.magFilter=9729,f.minFilter=9986;break;case n.c.NEAREST_NEAREST_MIPLINEAR:f.magFilter=9728,f.minFilter=9986;break;case n.c.LINEAR_LINEAR_MIPLINEAR:f.magFilter=9729,f.minFilter=9987;break;case n.c.LINEAR_LINEAR_MIPNEAREST:f.magFilter=9729,f.minFilter=9985;break;case n.c.NEAREST_NEAREST_MIPNEAREST:f.magFilter=9728,f.minFilter=9984}return f}_getGLTFTextureWrapMode(P){switch(P){case n.c.WRAP_ADDRESSMODE:return 10497;case n.c.CLAMP_ADDRESSMODE:return 33071;case n.c.MIRROR_ADDRESSMODE:return 33648;default:return q.Tools.Error(`Unsupported Texture Wrap Mode ${P}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(P,f,Y,C){const q={diffuseColor:P._albedoColor,specularColor:P._reflectivityColor,glossiness:P._microSurface},m=P._albedoTexture,L=P._reflectivityTexture,o=P._useMicroSurfaceFromReflectivityMapAlpha;if(L&&!o)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((m||L)&&C){this._exporter._materialNeedsUVsSet.add(P);const C=this._exportTextureSampler(m||L),o=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(m,L,q,f),w=this._exporter._textures;if(o.baseColorTextureData){const P=this._exportImage(`baseColor${w.length}`,f,o.baseColorTextureData);Y.baseColorTexture=this._exportTextureInfo(P,C,null===m||void 0===m?void 0:m.coordinatesIndex)}if(o.metallicRoughnessTextureData){const P=this._exportImage(`metallicRoughness${w.length}`,f,o.metallicRoughnessTextureData);Y.metallicRoughnessTexture=this._exportTextureInfo(P,C,null===L||void 0===L?void 0:L.coordinatesIndex)}return o}return this._convertSpecularGlossinessToMetallicRoughness(q)}async exportPBRMaterialAsync(P,f,Y){const C={},q={name:P.name},m=P.isMetallicWorkflow();if(m){const f=P._albedoColor,Y=P.alpha;f&&(C.baseColorFactor=[f.r,f.g,f.b,Y])}const L=m?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(P,f,C,Y):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(P,f,C,Y);await this._setMetallicRoughnessPbrMaterialAsync(L,P,q,C,f,Y),await this._finishMaterialAsync(q,P,f);const o=this._exporter._materials;return o.push(q),o.length-1}async _setMetallicRoughnessPbrMaterialAsync(P,f,Y,C,m,L){if(Q(Y,f),P.baseColor.equalsWithEpsilon(j,T)&&V.WithinEpsilon(f.alpha,1,T)||(C.baseColorFactor=[P.baseColor.r,P.baseColor.g,P.baseColor.b,f.alpha]),null!=P.metallic&&1!==P.metallic&&(C.metallicFactor=P.metallic),null!=P.roughness&&1!==P.roughness&&(C.roughnessFactor=P.roughness),null==f.XL||f.XL||(f._twoSidedLighting||q.Tools.Warn(f.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Y.doubleSided=!0),L){const P=[],C=f._bumpTexture;C&&P.push(this.exportTextureAsync(C,m).then((P=>{P&&(Y.normalTexture=P,1!==C.level&&(Y.normalTexture.scale=C.level))})));const q=f._ambientTexture;q&&P.push(this.exportTextureAsync(q,m).then((P=>{if(P){const C={index:P.index,texCoord:P.texCoord,extensions:P.extensions};Y.occlusionTexture=C;const q=f._ambientTextureStrength;q&&(C.strength=q)}})));const L=f._emissiveTexture;L&&P.push(this.exportTextureAsync(L,m).then((P=>{P&&(Y.emissiveTexture=P)}))),P.length>0&&(this._exporter._materialNeedsUVsSet.add(f),await Promise.all(P))}const o=f._emissiveColor;o.equalsWithEpsilon(e,T)||(Y.emissiveFactor=o.If()),Y.pbrMetallicRoughness=C}_getPixelsFromTextureAsync(P){return function(P){switch(P){case v.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case v.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case v.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case v.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case v.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case v.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case v.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case v.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case v.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case v.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case v.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case v.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case v.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case v.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case v.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case v.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case v.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case v.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case v.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case v.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case v.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(P.textureFormat)?(0,O.g)(P,P._texture.width,P._texture.height):(P.textureType,v.e.TEXTURETYPE_UNSIGNED_BYTE,P.readPixels())}async exportTextureAsync(P,f){const Y=this._exporter._extensionsPreExportTextureAsync("exporter",P,f);return Y?await Y.then((async Y=>Y?await this._exportTextureInfoAsync(Y,f):await this._exportTextureInfoAsync(P,f))):await this._exportTextureInfoAsync(P,f)}async _exportTextureInfoAsync(P,f){let Y=this._textureMap.get(P);if(!Y){const C=await this._getPixelsFromTextureAsync(P);if(!C)return null;const m=this._exportTextureSampler(P),L=P.mimeType;if(L)switch(L){case"image/jpeg":case"image/png":case"image/webp":f=L;break;default:q.Tools.Warn(`Unsupported media type: ${L}. Exporting texture as PNG.`)}const o=this._internalTextureToImage,w=P.getInternalTexture().uniqueId;o[w]||(o[w]={});let d=o[w][f];if(void 0===d){const Y=P.getSize();d=(async()=>{const q=await this._getImageDataAsync(C,Y.width,Y.height,f);return this._exportImage(P.name,f,q)})(),o[w][f]=d}Y=this._exportTextureInfo(await d,m,P.coordinatesIndex),this._textureMap.set(P,Y),this._exporter._extensionsPostExportTextures("exporter",Y,P)}return Y}_exportImage(P,f,Y){const C=this._exporter._images;let m;if(this._exporter._shouldUseGlb){m={name:P,mimeType:f,bufferView:void 0};const C=this._exporter._bufferManager.createBufferView(new Uint8Array(Y));this._exporter._bufferManager.setBufferView(m,C)}else{const L=P.replace(/\.\/|\/|\.\\|\\/g,"_"),o=function(P){switch(P){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(f);let w=L+o;C.some((P=>P.uri===w))&&(w=`${L}_${q.Tools.RandomId()}${o}`),m={name:P,uri:w},this._exporter._imageData[w]={data:Y,mimeType:f}}return C.push(m),C.length-1}_exportTextureInfo(P,f,Y){const C=this._exporter._textures;let q=C.findIndex((Y=>Y.sampler==f&&Y.source===P));-1===q&&(q=C.length,C.push({source:P,sampler:f}));const m={index:q};return Y&&(m.texCoord=Y),m}_exportTextureSampler(P){const f=this._getTextureSampler(P),Y=this._exporter._samplers,C=Y.findIndex((P=>P.minFilter===f.minFilter&&P.magFilter===f.magFilter&&P.wrapS===f.wrapS&&P.wrapT===f.wrapT));return-1!==C?C:(Y.push(f),Y.length-1)}}var X=Y(11273),x=Y(11025),k=Y(11684),Z=Y(11187);const A=C.Of.Zero(),E=C.Quaternion.Identity(),t=C.Of.One(),G=new C.Of(-1,1,1);function z(P,f){const{byteOffset:Y,byteStride:C,type:q,normalized:m}=P,L=P.getSize(),o=f.reduce(((P,f)=>f.getTotalVertices()>P?f.getTotalVertices():P),-Number.MAX_VALUE);return{byteOffset:Y,byteStride:C,componentCount:L,type:q,count:o*L,normalized:m,totalVertices:o,kind:P.getKind()}}function B(P){switch(P){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function b(P){switch(P){case R.d.PositionKind:case R.d.NormalKind:case R.d.TangentKind:case R.d.ColorKind:case R.d.MatricesIndicesKind:case R.d.MatricesIndicesExtraKind:case R.d.MatricesWeightsKind:case R.d.MatricesWeightsExtraKind:case R.d.UVKind:case R.d.UV2Kind:case R.d.UV3Kind:case R.d.UV4Kind:case R.d.UV5Kind:case R.d.UV6Kind:return!0}return!1}function H(P){switch(P){case m.d.TriangleFillMode:return 4;case m.d.TriangleStripDrawMode:return 5;case m.d.TriangleFanDrawMode:return 6;case m.d.PointListDrawMode:case m.d.PointFillMode:return 0;case m.d.LineLoopDrawMode:return 2;case m.d.LineListDrawMode:return 1;case m.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${P}`)}function W(P){const f=Math.sqrt(P.x*P.x+P.y*P.y+P.z*P.z);f>0&&(P.x/=f,P.y/=f,P.z/=f)}function p(P){return P.x*=-1,P}function h(P){if(P.x*P.x+P.y*P.y>.5){const f=Math.abs(P.x),Y=Math.abs(P.y);if(f>Y){const Y=Math.sign(P.x);P.x=f,P.y*=-Y,P.z*=-Y,P.w*=Y}else{const f=Math.sign(P.y);P.x*=-f,P.y=Y,P.z*=f,P.w*=-f}}else{const f=Math.abs(P.z),Y=Math.abs(P.w);if(f>Y){const Y=Math.sign(P.z);P.x*=-Y,P.y*=Y,P.z=f,P.w*=-Y}else{const f=Math.sign(P.w);P.x*=f,P.y*=-f,P.z*=-f,P.w=Y}}return P}function F(P){P.do(-P.z,P.w,P.x,-P.y)}function PP(P,f){const Y=C.Of.FromArrayToRef(f.translation||[0,0,0],0,C.TmpVectors.Of[0]),q=C.Quaternion.FromArrayToRef(f.rotation||[0,0,0,1],0,C.TmpVectors.Quaternion[0]),m=C.Matrix.ComposeToRef(t,q,Y,C.TmpVectors.Matrix[0]),L=C.Of.FromArrayToRef(P.translation||[0,0,0],0,C.TmpVectors.Of[2]),o=C.Quaternion.FromArrayToRef(P.rotation||[0,0,0,1],0,C.TmpVectors.Quaternion[1]),w=C.Matrix.ComposeToRef(t,o,L,C.TmpVectors.Matrix[1]);m.multiplyToRef(w,w),w.decompose(void 0,q,Y),Y.equalsWithEpsilon(A,Z.c)?delete f.translation:f.translation=Y.If(),q.equalsWithEpsilon(E,Z.c)?delete f.rotation:f.rotation=q.If(),f.scale&&delete f.scale}function fP(P,f){if(!(f instanceof y.c))return!1;if(!(1===f.getChildren().length&&0===P.getChildren().length&&P.parent===f))return!1;const Y=P.vP(),C=P instanceof k.e&&!Y.useRightHandedSystem?G:t;return!!f.Ro.equalsWithEpsilon(C,Z.c)||(x.e.Warn(`Cannot collapse node ${P.name} into parent node ${f.name} with modified scaling.`),!1)}function YP(P){if(P instanceof Array){const f=new Float32Array(P);return new Uint8Array(f.buffer,f.byteOffset,f.byteLength)}return ArrayBuffer.isView(P)?new Uint8Array(P.buffer,P.byteOffset,P.byteLength):new Uint8Array(P)}function CP(P,f){for(const[Y,C]of Object.entries(P)){const q=f[Y];(Array.isArray(C)&&Array.isArray(q)&&qP(C,q)||C===q)&&delete P[Y]}return P}function qP(P,f){return P.length===f.length&&P.every(((P,Y)=>P===f[Y]))}const mP=C.Matrix.Compose(new C.Of(-1,1,1),C.Quaternion.Identity(),C.Of.Zero());function LP(P,f){if(!(P instanceof y.c))return!1;if(f){if(!P.getWorldMatrix().equalsWithEpsilon(C.Matrix.IdentityReadOnly,Z.c))return!1}else{if(!P.getWorldMatrix().multiplyToRef(mP,C.TmpVectors.Matrix[0]).equalsWithEpsilon(C.Matrix.IdentityReadOnly,Z.c))return!1}return!(P instanceof r.b&&P.qq)}const oP=new Map([[Int8Array,(P,f,Y)=>P.setInt8(f,Y)],[Uint8Array,(P,f,Y)=>P.setUint8(f,Y)],[Uint8ClampedArray,(P,f,Y)=>P.setUint8(f,Y)],[Int16Array,(P,f,Y)=>P.setInt16(f,Y,!0)],[Uint16Array,(P,f,Y)=>P.setUint16(f,Y,!0)],[Int32Array,(P,f,Y)=>P.setInt32(f,Y,!0)],[Uint32Array,(P,f,Y)=>P.setUint32(f,Y,!0)],[Float32Array,(P,f,Y)=>P.setFloat32(f,Y,!0)],[Float64Array,(P,f,Y)=>P.setFloat64(f,Y,!0)]]);class wP{writeTypedArray(P){this._checkGrowBuffer(P.byteLength);const f=oP.get(P.constructor);for(let Y=0;Y<P.length;Y++)f(this._dataView,this._byteOffset,P[Y]),this._byteOffset+=P.BYTES_PER_ELEMENT}constructor(P){this._data=new Uint8Array(P),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(P){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,P),this._byteOffset++}writeInt8(P){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,P),this._byteOffset++}writeInt16(P){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,P,!0),this._byteOffset+=2}writeUInt16(P){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,P,!0),this._byteOffset+=2}writeInt32(P){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,P,!0),this._byteOffset+=4}writeUInt32(P){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,P,!0),this._byteOffset+=4}writeFloat32(P){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,P,!0),this._byteOffset+=4}writeFloat64(P){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,P,!0),this._byteOffset+=8}_checkGrowBuffer(P){const f=this.byteOffset+P;if(f>this._data.byteLength){const P=new Uint8Array(2*f);P.set(this._data),this._data=P,this._dataView=new DataView(this._data.buffer)}}}function dP(P){return P%4===0?4:P%2===0?2:1}class RP{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(P){let f=0;this._bufferViewToData.forEach((P=>{f+=P.byteLength}));const Y=new wP(f),C=Array.from(this._bufferViewToData.keys()).sort(((P,f)=>dP(f.byteLength)-dP(P.byteLength)));for(const q of C){q.byteOffset=Y.byteOffset,P.push(q);const f=P.length-1,C=this.getPropertiesWithBufferView(q);for(const P of C)P.bufferView=f;Y.writeTypedArray(this._bufferViewToData.get(q)),this._bufferViewToData.delete(q)}return Y.getOutputData()}createBufferView(P,f){const Y={buffer:0,byteOffset:void 0,byteLength:P.byteLength,byteStride:f};return this._bufferViewToData.set(Y,P),Y}createAccessor(P,f,Y,C,q,m,L){this._verifyBufferView(P);const o={bufferView:void 0,componentType:Y,count:C,type:f,min:null===m||void 0===m?void 0:m.min,max:null===m||void 0===m?void 0:m.max,normalized:L,byteOffset:q};return this.setBufferView(o,P),this._accessorToBufferView.set(o,P),o}setBufferView(P,f){this._verifyBufferView(f);this.getPropertiesWithBufferView(f).push(P)}removeBufferView(P){const f=this.getPropertiesWithBufferView(P);for(const Y of f)void 0!==Y.bufferView&&delete Y.bufferView;this._bufferViewToData.delete(P),this._bufferViewToProperties.delete(P),this._accessorToBufferView.forEach(((f,Y)=>{f===P&&(void 0!==Y.byteOffset&&delete Y.byteOffset,this._accessorToBufferView.delete(Y))}))}getBufferView(P){const f=this._accessorToBufferView.get(P);return this._verifyBufferView(f),f}getPropertiesWithBufferView(P){return this._verifyBufferView(P),this._bufferViewToProperties.set(P,this._bufferViewToProperties.get(P)??[]),this._bufferViewToProperties.get(P)}getData(P){return this._verifyBufferView(P),this._bufferViewToData.get(P)}_verifyBufferView(P){if(void 0===P||!this._bufferViewToData.has(P))throw new Error(`BufferView ${P} not found in BufferManager.`)}}var yP,rP=Y(11657),iP=Y(11665),uP=Y(11687),gP=Y(11569),SP=Y(11727),KP=Y(11734),MP=Y(11648),VP=Y(11742);!function(P){P[P.INTANGENT=0]="INTANGENT",P[P.OUTTANGENT=1]="OUTTANGENT"}(yP||(yP={}));class OP{static _IsTransformable(P){return P&&(P instanceof y.c||P instanceof rP.e||P instanceof VP.d)}static _CreateNodeAnimation(P,f,Y,C,m){if(this._IsTransformable(P)){const L=[],o=[],w=f.getKeys(),d=OP._CalculateMinMaxKeyFrames(w),R=OP._DeduceInterpolation(w,Y,C),y=R.interpolationType,r=R.shouldBakeAnimation;if(r?OP._CreateBakedAnimation(P,f,Y,d.min,d.max,f.framePerSecond,m,L,o,d,C):"LINEAR"===y||"STEP"===y?OP._CreateLinearOrStepAnimation(P,f,Y,L,o,C):"CUBICSPLINE"===y?OP._CreateCubicSplineAnimation(P,f,Y,L,o,C):OP._CreateBakedAnimation(P,f,Y,d.min,d.max,f.framePerSecond,m,L,o,d,C),L.length&&o.length){return{inputs:L,outputs:o,samplerInterpolation:y,inputsMin:r?d.min:q.Tools.FloatRound(d.min/f.framePerSecond),inputsMax:r?d.max:q.Tools.FloatRound(d.max/f.framePerSecond)}}}return null}static _DeduceAnimationInfo(P){let f=null,Y="VEC3",C=!1;const m=P.targetProperty.split(".");switch(m[0]){case"Ro":f="scale";break;case"position":f="translation";break;case"rotation":Y="VEC4",f="rotation";break;case"rotationQuaternion":Y="VEC4",C=!0,f="rotation";break;case"influence":Y="SCALAR",f="weights";break;default:q.Tools.Error(`Unsupported animatable property ${m[0]}`)}return f?{animationChannelTargetPath:f,dataAccessorType:Y,useQuaternion:C}:(q.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(P,f,Y,C,q,m,L,o,w,d,R){let y;if(OP._IsTransformable(P)&&P.animations)for(const r of P.animations){if(R&&!R(r))continue;const q=OP._DeduceAnimationInfo(r);q&&(y={name:r.name,samplers:[],channels:[]},OP._AddAnimation(`${r.name}`,r.hasRunningRuntimeAnimations?f:y,P,r,q.dataAccessorType,q.animationChannelTargetPath,C,m,L,o,q.useQuaternion,w,d),y.samplers.length&&y.channels.length&&Y.push(y))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(P,f,Y,C,q,m,L,o,w,d,R){let y;if(P instanceof MP.c){const q=P.morphTargetManager;if(q)for(let r=0;r<q.numTargets;++r){const i=q.getTarget(r);for(const u of i.animations){if(R&&!R(u))continue;const i=new SP.b(`${u.name}`,"influence",u.framePerSecond,u.dataType,u.loopMode,u.enableBlending),g=[],S=u.getKeys();for(let P=0;P<S.length;++P){const f=S[P];for(let P=0;P<q.numTargets;++P)P==r?g.push(f):g.push({frame:f.frame,value:0})}i.setKeys(g);const K=OP._DeduceAnimationInfo(i);K&&(y={name:i.name,samplers:[],channels:[]},OP._AddAnimation(u.name,u.hasRunningRuntimeAnimations?f:y,P,i,K.dataAccessorType,K.animationChannelTargetPath,C,m,L,o,K.useQuaternion,w,d,q.numTargets),y.samplers.length&&y.channels.length&&Y.push(y))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(P,f,Y,C,q,m,L,o,w){let d;if(P.animationGroups){const y=P.animationGroups;for(const r of y){const y=new Map,i=new Map,u=new Set,g=r.to-r.from;d={name:r.name,channels:[],samplers:[]};for(let f=0;f<r.targetedAnimations.length;++f){const g=r.targetedAnimations[f],S=g.target,K=g.animation;if(w&&!w(K))continue;const M=o.has(S);if(this._IsTransformable(S)||1===S.length&&this._IsTransformable(S[0])){const P=OP._DeduceAnimationInfo(g.animation);if(P){const f=this._IsTransformable(S)?S:this._IsTransformable(S[0])?S[0]:null;f&&OP._AddAnimation(`${K.name}`,d,f,K,P.dataAccessorType,P.animationChannelTargetPath,Y,C,q,m,P.useQuaternion,L,M)}}else if(S instanceof KP.e||1===S.length&&S[0]instanceof KP.e){if(OP._DeduceAnimationInfo(g.animation)){const f=S instanceof KP.e?S:S[0];if(f){const Y=P.morphTargetManagers.find((P=>{for(let Y=0;Y<P.numTargets;++Y)if(P.getTarget(Y)===f)return!0;return!1}));if(Y){const C=P.meshes.find((P=>P.morphTargetManager===Y));var R;if(C)y.has(C)||y.set(C,new Map),null===(R=y.get(C))||void 0===R||R.set(f,K),u.add(C),i.set(C,K)}}}}}u.forEach((P=>{const f=P.morphTargetManager;let o=null;const w=[],R=i.get(P).getKeys(),u=R.length;for(let Y=0;Y<u;++Y)for(let C=0;C<f.numTargets;++C){const q=f.getTarget(C),m=y.get(P);if(m){const f=m.get(q);f?(o||(o=new SP.b(`${r.name}_${P.name}_MorphWeightAnimation`,"influence",f.framePerSecond,SP.b.ANIMATIONTYPE_FLOAT,f.loopMode,f.enableBlending)),w.push(f.getKeys()[Y])):w.push({frame:r.from+g/u*Y,value:q.influence,inTangent:R[0].inTangent?0:void 0,outTangent:R[0].outTangent?0:void 0})}}o.setKeys(w);const S=OP._DeduceAnimationInfo(o);S&&OP._AddAnimation(`${r.name}_${P.name}_MorphWeightAnimation`,d,P,o,S.dataAccessorType,S.animationChannelTargetPath,Y,C,q,m,S.useQuaternion,L,!1,null===f||void 0===f?void 0:f.numTargets)})),d.channels.length&&d.samplers.length&&f.push(d)}}}static _AddAnimation(P,f,Y,q,m,L,o,w,d,R,y,r,i,u){const g=OP._CreateNodeAnimation(Y,q,L,y,r);let S,K,M,V,O,n;if(g){if(u){let P=0,f=0;const Y=[];for(;g.inputs.length>0;)f=g.inputs.shift(),P%u==0&&Y.push(f),P++;g.inputs=Y}const P=o.get(Y),q=new Float32Array(g.inputs);S=w.createBufferView(q),K=w.createAccessor(S,"SCALAR",5126,g.inputs.length,void 0,{min:[g.inputsMin],max:[g.inputsMax]}),R.push(K),M=R.length-1;const d=new C.Quaternion,y=new C.Of,r=new C.Of,l=Y instanceof rP.e,v=B(m),c=new Float32Array(g.outputs.length*v);g.outputs.forEach((function(P,f){let Y=P;switch(L){case"translation":i&&(C.Of.FromArrayToRef(P,0,r),p(r),r.toArray(Y));break;case"rotation":4===P.length?C.Quaternion.FromArrayToRef(P,0,d):(Y=new Array(4),C.Of.FromArrayToRef(P,0,y),C.Quaternion.FromEulerVectorToRef(y,d)),i&&(h(d),l&&F(d)),d.toArray(Y)}c.set(Y,f*v)})),S=w.createBufferView(c),K=w.createAccessor(S,m,5126,g.outputs.length),R.push(K),V=R.length-1,O={interpolation:g.samplerInterpolation,input:M,output:V},f.samplers.push(O),n={sampler:f.samplers.length-1,target:{node:P,path:L}},f.channels.push(n)}}static _CreateBakedAnimation(P,f,Y,m,L,o,w,d,R,y,r){let i;const u=C.Quaternion.Identity();let g,S=null,K=null,M=null,V=null,O=null,n=null;y.min=q.Tools.FloatRound(m/o);const l=f.getKeys();for(let C=0,v=l.length;C<v;++C){if(n=null,M=l[C],C+1<v)if(V=l[C+1],M.value.equals&&M.value.equals(V.value)||M.value===V.value){if(0!==C)continue;n=M.frame}else n=V.frame;else{if(O=l[C-1],M.value.equals&&M.value.equals(O.value)||M.value===O.value)continue;n=L}if(n)for(let C=M.frame;C<=n;C+=w){if(g=q.Tools.FloatRound(C/o),g===S)continue;S=g,K=g;const m={key:0,repeatCount:0,loopMode:f.loopMode};i=f._interpolate(C,m),OP._SetInterpolatedValue(P,i,g,f,Y,u,d,R,r)}}K&&(y.max=K)}static _ConvertFactorToVector3OrQuaternion(P,f,Y,m,L){const o=OP._GetBasePositionRotationOrScale(f,m,L),w=Y.targetProperty.split("."),d=w?w[1]:"",R=L?C.Quaternion.ef(o).normalize():C.Of.ef(o);switch(d){case"x":case"y":case"z":R[d]=P;break;case"w":R.w=P;break;default:q.Tools.Error(`glTFAnimation: Unsupported component name "${d}"!`)}return R}static _SetInterpolatedValue(P,f,Y,q,m,L,o,w,d){let R;o.push(Y),"weights"!==m?(q.dataType===SP.b.ANIMATIONTYPE_FLOAT&&(f=this._ConvertFactorToVector3OrQuaternion(f,P,q,m,d)),"rotation"===m?(d?L=f:(R=f,C.Quaternion.RotationYawPitchRollToRef(R.y,R.x,R.z,L)),w.push(L.If())):(R=f,w.push(R.If()))):w.push([f])}static _CreateLinearOrStepAnimation(P,f,Y,C,q,m){for(const L of f.getKeys())C.push(L.frame/f.framePerSecond),OP._AddKeyframeValue(L,f,q,Y,P,m)}static _CreateCubicSplineAnimation(P,f,Y,C,q,m){f.getKeys().forEach((function(L){C.push(L.frame/f.framePerSecond),OP._AddSplineTangent(yP.INTANGENT,q,Y,"CUBICSPLINE",L,m),OP._AddKeyframeValue(L,f,q,Y,P,m),OP._AddSplineTangent(yP.OUTTANGENT,q,Y,"CUBICSPLINE",L,m)}))}static _GetBasePositionRotationOrScale(P,f,Y){let q;if("rotation"===f)if(Y){q=(P.rotationQuaternion??C.Quaternion.Identity()).If()}else{q=(P.rotation??C.Of.Zero()).If()}else if("translation"===f){q=(P.position??C.Of.Zero()).If()}else{q=(P.Ro??C.Of.One()).If()}return q}static _AddKeyframeValue(P,f,Y,m,L,o){let w;const d=f.dataType;if(d===SP.b.ANIMATIONTYPE_VECTOR3){let f=P.value.If();if("rotation"===m){const P=C.Of.ef(f);f=C.Quaternion.RotationYawPitchRoll(P.y,P.x,P.z).If()}Y.push(f)}else if(d===SP.b.ANIMATIONTYPE_FLOAT){if("weights"===m)Y.push([P.value]);else if(w=this._ConvertFactorToVector3OrQuaternion(P.value,L,f,m,o),w){if("rotation"===m){const P=o?w:C.Quaternion.RotationYawPitchRoll(w.y,w.x,w.z).normalize();Y.push(P.If())}Y.push(w.If())}}else d===SP.b.ANIMATIONTYPE_QUATERNION?Y.push(P.value.normalize().If()):q.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(P,f,Y){let C,q,m=!1;if("rotation"===f&&!Y)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let L=0,o=P.length;L<o;++L)if(q=P[L],q.inTangent||q.outTangent)if(C){if("CUBICSPLINE"!==C){C="LINEAR",m=!0;break}}else C="CUBICSPLINE";else if(C){if("CUBICSPLINE"===C||q.interpolation&&1===q.interpolation&&"STEP"!==C){C="LINEAR",m=!0;break}}else C=q.interpolation&&1===q.interpolation?"STEP":"LINEAR";return C||(C="LINEAR"),{interpolationType:C,shouldBakeAnimation:m}}static _AddSplineTangent(P,f,Y,q,m,L){let o;const w=P===yP.INTANGENT?m.inTangent:m.outTangent;if("CUBICSPLINE"===q){if("rotation"===Y)if(w)if(L)o=w.If();else{const P=w;o=C.Quaternion.RotationYawPitchRoll(P.y,P.x,P.z).If()}else o=[0,0,0,0];else o="weights"===Y?w?[w]:[0]:w?w.If():[0,0,0];f.push(o)}}static _CalculateMinMaxKeyFrames(P){let f=1/0,Y=-1/0;return P.forEach((function(P){f=Math.min(f,P.frame),Y=Math.max(Y,P.frame)})),{min:f,max:Y}}}function nP(P,f,Y,m,L,o){const w={attributes:{},influence:P.influence,name:P.name},d=f.qq;if(!d)return q.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),w;const y=o?-1:1,r=C.Of.Zero();let i=0,u=0;if(P.hasPositions){const m=P.getPositions(),o=d.getVerticesData(R.d.PositionKind);if(o){const P=new Float32Array(o.length),f=[1/0,1/0,1/0],q=[-1/0,-1/0,-1/0];u=o.length/3,i=0;for(let Y=i;Y<u;++Y){const L=C.Of.ef(o,3*Y);C.Of.ef(m,3*Y).subtractToRef(L,r),r.x*=y,f[0]=Math.min(f[0],r.x),q[0]=Math.max(q[0],r.x),f[1]=Math.min(f[1],r.y),q[1]=Math.max(q[1],r.y),f[2]=Math.min(f[2],r.z),q[2]=Math.max(q[2],r.z),P[3*Y]=r.x,P[3*Y+1]=r.y,P[3*Y+2]=r.z}const d=Y.createBufferView(P,12),R=Y.createAccessor(d,"VEC3",5126,m.length/3,0,{min:f,max:q});L.push(R),w.attributes.POSITION=L.length-1}else q.Tools.Warn(`Morph target positions for mesh ${f.name} were not exported. Mesh does not have position vertex data`)}if(P.hasNormals){const m=P.getNormals(),o=d.getVerticesData(R.d.NormalKind);if(o){const P=new Float32Array(o.length);u=o.length/3,i=0;for(let Y=i;Y<u;++Y){const f=C.Of.ef(o,3*Y).normalize();C.Of.ef(m,3*Y).normalize().subtractToRef(f,r),P[3*Y]=r.x*y,P[3*Y+1]=r.y,P[3*Y+2]=r.z}const f=Y.createBufferView(P,12),q=Y.createAccessor(f,"VEC3",5126,m.length/3,0);L.push(q),w.attributes.NORMAL=L.length-1}else q.Tools.Warn(`Morph target normals for mesh ${f.name} were not exported. Mesh does not have normals vertex data`)}if(P.hasTangents){const m=P.getTangents(),o=d.getVerticesData(R.d.TangentKind);if(o){u=o.length/4;const P=new Float32Array(3*u);i=0;for(let Y=i;Y<u;++Y){const f=C.Of.ef(o,4*Y);W(f);const q=C.Of.ef(m,3*Y);W(q),q.subtractToRef(f,r),P[3*Y]=r.x*y,P[3*Y+1]=r.y,P[3*Y+2]=r.z}const f=Y.createBufferView(P,12),q=Y.createAccessor(f,"VEC3",5126,u,0);L.push(q),w.attributes.TANGENT=L.length-1}else q.Tools.Warn(`Morph target tangents for mesh ${f.name} were not exported. Mesh does not have tangents vertex data`)}if(P.hasColors){const m=P.getColors(),o=d.getVerticesData(R.d.ColorKind),y=d.getVertexBuffer(R.d.ColorKind);if(o&&y){const P=y.getSize();u=o.length/P;const f=new Float32Array(u*P);i=0;for(let Y=i;Y<u;++Y)if(3===P){const q=C.Of.ef(o,Y*P);C.Of.ef(m,Y*P).subtractToRef(q,r),f[3*Y]=r.x,f[3*Y+1]=r.y,f[3*Y+2]=r.z}else if(4===P){const q=new C.Vector4,L=C.Vector4.ef(o,Y*P);C.Vector4.ef(m,Y*P).subtractToRef(L,q),f[4*Y]=q.x,f[4*Y+1]=q.y,f[4*Y+2]=q.z,f[4*Y+3]=q.w}else q.Tools.Warn(`Unsupported number of components for color attribute: ${P}`);const d=Y.createBufferView(f,4*P),R=Y.createAccessor(d,3===P?"VEC3":"VEC4",5126,u,0);L.push(R),w.attributes.COLOR_0=L.length-1}else q.Tools.Warn(`Morph target colors for mesh ${f.name} were not exported. Mesh does not have colors vertex data`)}return w}var lP=Y(11751),vP=Y(11598),cP=Y(11583),TP=Y(11134);class UP{}UP.DEFAULT_COLOR=S.Df.White(),UP.DEFAULT_WIDTH_ATTENUATED=1,UP.DEFAULT_WIDTH=.1;var DP=Y(11405),jP=Y(11756);class eP{static ConvertPoints(P,f){if(P.length&&Array.isArray(P)&&"number"===typeof P[0])return[P];if(P.length&&Array.isArray(P[0])&&"number"===typeof P[0][0])return P;if(P.length&&!Array.isArray(P[0])&&P[0]instanceof C.Of){const f=[];for(let Y=0;Y<P.length;Y++){const C=P[Y];f.push(C.x,C.y,C.z)}return[f]}if(P.length>0&&Array.isArray(P[0])&&P[0].length>0&&P[0][0]instanceof C.Of){const f=[],Y=P;for(const P of Y)f.push(P.flatMap((P=>[P.x,P.y,P.z])));return f}if(P instanceof Float32Array){if(null!==f&&void 0!==f&&f.floatArrayStride){const Y=[],C=3*f.floatArrayStride;for(let f=0;f<P.length;f+=C){const q=new Array(C);for(let Y=0;Y<C;Y++)q[Y]=P[f+Y];Y.push(q)}return Y}return[Array.from(P)]}if(P.length&&P[0]instanceof Float32Array){const f=[];for(const Y of P)f.push(Array.from(Y));return f}return[]}static OmitZeroLengthPredicate(P,f,Y){const C=[];return f.nf(P).lengthSquared()>0&&C.push([P,f]),Y.nf(f).lengthSquared()>0&&C.push([f,Y]),P.nf(Y).lengthSquared()>0&&C.push([Y,P]),0===C.length?null:C}static OmitDuplicatesPredicate(P,f,Y,C){const q=[];return eP._SearchInPoints(P,f,C)||q.push([P,f]),eP._SearchInPoints(f,Y,C)||q.push([f,Y]),eP._SearchInPoints(Y,P,C)||q.push([Y,P]),0===q.length?null:q}static _SearchInPoints(P,f,Y){for(const L of Y)for(let Y=0;Y<L.length;Y++){var C,q,m;if(null!==(C=L[Y])&&void 0!==C&&C.equals(P))if(null!==(q=L[Y+1])&&void 0!==q&&q.equals(f)||null!==(m=L[Y-1])&&void 0!==m&&m.equals(f))return!0}return!1}static MeshesToLines(P,f){const Y=[];for(let q=0;q<P.length;q++){const m=P[q],L=m.getVerticesData(R.d.PositionKind),o=m.eq();if(L&&o)for(let P=0,w=0;P<o.length;P++){const d=3*o[w++],R=3*o[w++],y=3*o[w++],r=new C.Of(L[d],L[d+1],L[d+2]),i=new C.Of(L[R],L[R+1],L[R+2]),u=new C.Of(L[y],L[y+1],L[y+2]);if(f){const C=f(r,i,u,Y,P,d,m,q,L,o);if(C)for(const P of C)Y.push(P)}else Y.push([r,i],[i,u],[u,r])}}return Y}static ToVector3Array(P){if(Array.isArray(P[0])){const f=[],Y=P;for(const P of Y){const Y=[];for(let f=0;f<P.length;f+=3)Y.push(new C.Of(P[f],P[f+1],P[f+2]));f.push(Y)}return f}const f=P,Y=[];for(let q=0;q<f.length;q+=3)Y.push(new C.Of(f[q],f[q+1],f[q+2]));return Y}static ToNumberArray(P){return P.flatMap((P=>[P.x,P.y,P.z]))}static GetPointsCountInfo(P){const f=new Array(P.length);let Y=0;for(let C=P.length;C--;)f[C]=P[C].length/3,Y+=f[C];return{total:Y,counts:f}}static GetLineLength(P){if(0===P.length)return 0;let f;f="number"===typeof P[0]?eP.ToVector3Array(P):P;const Y=C.TmpVectors.Of[0];let q=0;for(let C=0;C<f.length-1;C++){const P=f[C];q+=f[C+1].subtractToRef(P,Y).length()}return q}static GetLineLengthArray(P){const f=new Float32Array(P.length/3);let Y=0;for(let C=0,q=P.length/3-1;C<q;C++){let q=P[3*C+0],m=P[3*C+1],L=P[3*C+2];q-=P[3*C+3],m-=P[3*C+4],L-=P[3*C+5];Y+=Math.sqrt(q*q+m*m+L*L),f[C+1]=Y}return f}static SegmentizeSegmentByCount(P,f,Y){const q=[],m=f.nf(P),L=C.TmpVectors.Of[0];L.yo(Y);const o=C.TmpVectors.Of[1];m.divideToRef(L,o);let w=P.clone();q.push(w);for(let C=0;C<Y;C++)w=w.clone(),q.push(w.addInPlace(o));return q}static SegmentizeLineBySegmentLength(P,f){const Y=P[0]instanceof C.Of?eP.GetLineSegments(P):"number"===typeof P[0]?eP.GetLineSegments(eP.ToVector3Array(P)):P,q=[];for(const C of Y)if(C.length>f){const P=eP.SegmentizeSegmentByCount(C.point1,C.point2,Math.ceil(C.length/f));for(const f of P)q.push(f)}else q.push(C.point1),q.push(C.point2);return q}static SegmentizeLineBySegmentCount(P,f){const Y="number"===typeof P[0]?eP.ToVector3Array(P):P,C=eP.GetLineLength(Y)/f;return eP.SegmentizeLineBySegmentLength(Y,C)}static GetLineSegments(P){const f=[];for(let Y=0;Y<P.length-1;Y++){const C=P[Y],q=P[Y+1],m=q.nf(C).length();f.push({point1:C,point2:q,length:m})}return f}static GetMinMaxSegmentLength(P){const f=eP.GetLineSegments(P).sort((P=>P.length));return{min:f[0].length,max:f[f.length-1].length}}static GetPositionOnLineByVisibility(P,f,Y){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const m=f*Y;let L=0,o=0;const w=P.length;for(let C=0;C<w;C++){if(m<=L+P[C].length){o=C;break}L+=P[C].length}const d=(m-L)/P[o].length;return P[o].point2.subtractToRef(P[o].point1,C.TmpVectors.Of[0]),C.TmpVectors.Of[1]=C.TmpVectors.Of[0].multiplyByFloats(d,d,d),q||C.TmpVectors.Of[1].addInPlace(P[o].point1),C.TmpVectors.Of[1].clone()}static GetCircleLinePoints(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P,m=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/f;const L=[];for(let o=0;o<=f;o++)L.push(new C.Of(Math.cos(o*m)*P,Math.sin(o*m)*q,Y));return L}static GetBezierLinePoints(P,f,Y,C){return DP.f.CreateQuadraticBezier(P,f,Y,C).getPoints().flatMap((P=>[P.x,P.y,P.z]))}static GetArrowCap(P,f,Y,C,q){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,L=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[P.clone(),P.add(f.multiplyByFloats(Y,Y,Y))],widths:[C,q,m,L]}}static GetPointsFromText(P,f,Y,C){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,m=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const L=[],o=(0,jP.c)(P,f,Y,C);for(const w of o){for(const P of w.paths){const f=[],Y=P.getPoints();for(const P of Y)f.push(P.x,P.y,q);L.push(f)}if(m)for(const P of w.holes){const f=[],Y=P.getPoints();for(const P of Y)f.push(P.x,P.y,q);L.push(f)}}return L}static Color3toRGBAUint8(P){const f=new Uint8Array(4*P.length);for(let Y=0,C=0;Y<P.length;Y++)f[C++]=255*P[Y].r,f[C++]=255*P[Y].g,f[C++]=255*P[Y].b,f[C++]=255;return f}static CreateColorsTexture(P,f,Y,C){const q=C.getEngine().getCaps().maxTextureSize??1,m=f.length>q?q:f.length,L=Math.ceil(f.length/q);L>1&&(f=[...f,...Array(m*L-f.length).fill(f[0])]);const o=eP.Color3toRGBAUint8(f),w=new l.d(o,m,L,u.c.TEXTUREFORMAT_RGBA,C,!1,!0,Y);return w.name=P,w}static PrepareEmptyColorsTexture(P){if(!UP.EmptyColorsTexture){const f=new Uint8Array(4);UP.EmptyColorsTexture=new l.d(f,1,1,u.c.TEXTUREFORMAT_RGBA,P,!1,!1,l.d.NEAREST_NEAREST),UP.EmptyColorsTexture.name="grlEmptyColorsTexture"}return UP.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var P;null===(P=UP.EmptyColorsTexture)||void 0===P||P.dispose(),UP.EmptyColorsTexture=null}static BooleanToNumber(P){return P?1:0}}class sP extends cP.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class aP extends vP.b{isCompatible(P){return!0}constructor(P,f,Y){var q;Y=Y||{color:UP.DEFAULT_COLOR};const m=new sP;m.GREASED_LINE_HAS_COLOR=!!Y.color&&!Y.useColors,m.GREASED_LINE_SIZE_ATTENUATION=Y.sizeAttenuation??!1,m.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===Y.colorDistributionType,m.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(f??P.vP()).useRightHandedSystem,m.GREASED_LINE_CAMERA_FACING=Y.cameraFacing??!0,super(P,aP.GREASED_LINE_MATERIAL_NAME,200,m,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(q=Y)||void 0===q?void 0:q.forceGLSL)||aP.ForceGLSL,this._scene=f??P.vP(),this._engine=this._scene.getEngine(),this._cameraFacing=Y.cameraFacing??!0,this.visibility=Y.visibility??1,this.useDash=Y.useDash??!1,this.dashRatio=Y.dashRatio??.5,this.dashOffset=Y.dashOffset??0,this.width=Y.width?Y.width:Y.sizeAttenuation?UP.DEFAULT_WIDTH_ATTENUATED:UP.DEFAULT_WIDTH,this._sizeAttenuation=Y.sizeAttenuation??!1,this.colorMode=Y.colorMode??0,this._color=Y.color??null,this.useColors=Y.useColors??!1,this._colorsDistributionType=Y.colorDistributionType??0,this.colorsSampling=Y.colorsSampling??l.d.NEAREST_NEAREST,this._colors=Y.DP??null,this.dashCount=Y.dashCount??1,this.resolution=Y.resolution??new C.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),Y.colorsTexture?this.colorsTexture=Y.colorsTexture:this._colors?this.colorsTexture=eP.CreateColorsTexture(`${P.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??UP.DEFAULT_COLOR,eP.PrepareEmptyColorsTexture(this._scene)),this._engine.vf.add((()=>{eP.DisposeEmptyColorsTexture()}))}getAttributes(P){P.push("grl_offsets"),P.push("grl_widths"),P.push("grl_colorPointers"),P.push("grl_counters"),this._cameraFacing?(P.push("grl_previousAndSide"),P.push("grl_nextAndCounters")):P.push("grl_slopes")}getSamplers(P){P.push("grl_colors")}getActiveTextures(P){this.colorsTexture&&P.push(this.colorsTexture)}getUniforms(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const f=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&f.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===P&&f.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:f,vertex:this._cameraFacing&&this._isGLSL(P)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(P)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(P){if(this._cameraFacing){P.bf("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||P.bf("viewProjection",this._scene.getTransformMatrix());const f=C.TmpVectors.Vector4[0];f.x=this._aspect,f.y=this._resolution.x,f.z=this._resolution.y,f.w=this.width,P.updateVector4("grl_aspect_resolution_lineWidth",f)}const f=C.TmpVectors.Vector4[0];f.x=eP.BooleanToNumber(this.useDash),f.y=this._dashArray,f.z=this.dashOffset,f.w=this.dashRatio,P.updateVector4("grl_dashOptions",f);const Y=C.TmpVectors.Vector4[1];Y.x=this.colorMode,Y.y=this.visibility,Y.z=this.colorsTexture?this.colorsTexture.getSize().width:0,Y.w=eP.BooleanToNumber(this.useColors),P.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",Y),this._color&&P.updateColor3("grl_singleColor",this._color);const q=this.colorsTexture??UP.EmptyColorsTexture;P.setTexture("grl_colors",q),P.updateFloat2("grl_textureSize",(null===q||void 0===q?void 0:q.getSize().width)??1,(null===q||void 0===q?void 0:q.getSize().height)??1)}prepareDefines(P,f,Y){P.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,P.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,P.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,P.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=f.useRightHandedSystem,P.GREASED_LINE_CAMERA_FACING=this._cameraFacing,P.GREASED_LINE_USE_OFFSETS=!!Y.offsets}getClassName(){return aP.GREASED_LINE_MATERIAL_NAME}getCustomCode(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(f)?function(P,f){if("vertex"===P){const P={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return f&&(P["!gl_Position\\=viewProjection\\*worldPos;"]="//"),P}return"fragment"===P?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(P,this._cameraFacing):function(P,f){if("vertex"===P){const P={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return f&&(P["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),P}return"fragment"===P?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(P,this._cameraFacing)}dispose(){var P;null===(P=this.colorsTexture)||void 0===P||P.dispose(),super.dispose()}get DP(){return this._colors}set DP(P){this.setColors(P)}setColors(P){var f;let Y=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const q=(null===(f=this._colors)||void 0===f?void 0:f.length)??0;var m;if(this._colors=P,null!==P&&0!==P.length){if(!Y||C)if(this.colorsTexture&&q===P.length&&!C){const f=eP.Color3toRGBAUint8(P);this.colorsTexture.update(f)}else{var L;null===(L=this.colorsTexture)||void 0===L||L.dispose(),this.colorsTexture=eP.CreateColorsTexture(`${this._material.name}-colors-texture`,P,this.colorsSampling,this._scene)}}else null===(m=this.colorsTexture)||void 0===m||m.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(P){this._dashCount=P,this._dashArray=1/P}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(P){this._sizeAttenuation=P,this.markAllDefinesAsDirty()}get color(){return this._color}set color(P){this.setColor(P)}setColor(P){let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==P||null!==this._color&&null===P?(this._color=P,f||this.markAllDefinesAsDirty()):this._color=P}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(P){this._colorsDistributionType=P,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(P){this._aspect=P.x/P.y,this._resolution=P}serialize(){const P=super.serialize(),f={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(f.DP=this._colors),this._color&&(f.color=this._color),P.greasedLineMaterialOptions=f,P}parse(P,f,Y){var C;super.parse(P,f,Y);const q=P.greasedLineMaterialOptions;null===(C=this.colorsTexture)||void 0===C||C.dispose(),q.color&&this.setColor(q.color,!0),q.colorDistributionType&&(this.colorsDistributionType=q.colorDistributionType),q.DP&&(this.DP=q.DP),q.colorsSampling&&(this.colorsSampling=q.colorsSampling),q.colorMode&&(this.colorMode=q.colorMode),q.useColors&&(this.useColors=q.useColors),q.visibility&&(this.visibility=q.visibility),q.useDash&&(this.useDash=q.useDash),q.dashCount&&(this.dashCount=q.dashCount),q.dashRatio&&(this.dashRatio=q.dashRatio),q.dashOffset&&(this.dashOffset=q.dashOffset),q.width&&(this.width=q.width),q.sizeAttenuation&&(this.sizeAttenuation=q.sizeAttenuation),q.resolution&&(this.resolution=q.resolution),this.DP?this.colorsTexture=eP.CreateColorsTexture(`${this._material.name}-colors-texture`,this.DP,this.colorsSampling,f):eP.PrepareEmptyColorsTexture(f),this.markAllDefinesAsDirty()}copyTo(P){var f;const Y=P;null===(f=Y.colorsTexture)||void 0===f||f.dispose(),this._colors&&(Y.colorsTexture=eP.CreateColorsTexture(`${Y._material.name}-colors-texture`,this._colors,Y.colorsSampling,this._scene)),Y.setColor(this.color,!0),Y.colorsDistributionType=this.colorsDistributionType,Y.colorsSampling=this.colorsSampling,Y.colorMode=this.colorMode,Y.useColors=this.useColors,Y.visibility=this.visibility,Y.useDash=this.useDash,Y.dashCount=this.dashCount,Y.dashRatio=this.dashRatio,Y.dashOffset=this.dashOffset,Y.width=this.width,Y.sizeAttenuation=this.sizeAttenuation,Y.resolution=this.resolution,Y.markAllDefinesAsDirty()}_isGLSL(P){return 0===P||this._forceGLSL}}aP.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",aP.ForceGLSL=!1,(0,TP.d)(`BABYLON.${aP.GREASED_LINE_MATERIAL_NAME}`,aP);var QP=Y(11625),JP=Y(11031),NP=Y(11427),IP=Y(11125);class XP extends NP.ShaderMaterial{constructor(P,f,q){const m=f.getEngine(),L=m.isWebGPU&&!(q.forceGLSL||XP.ForceGLSL),o=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];f.useRightHandedSystem&&o.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const w=["position","grl_widths","grl_offsets","grl_colorPointers"];q.cameraFacing?(o.push("GREASED_LINE_CAMERA_FACING"),w.push("grl_previousAndSide","grl_nextAndCounters")):(w.push("grl_slopes"),w.push("grl_counters"));const d=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(L||d.push("world","viewProjection","view","projection"),super(P,f,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:L?["Scene","Mesh"]:void 0,attributes:w,uniforms:d,samplers:L?[]:["grlColors"],defines:o,extraInitializationsAsync:async()=>{L?await Promise.all([Y.e(66).then(Y.bind(Y,14321)),Y.e(75).then(Y.bind(Y,14328))]):await Promise.all([Y.e(69).then(Y.bind(Y,14336)),Y.e(76).then(Y.bind(Y,14342))])},shaderLanguage:L?1:0}),this._color=S.Df.White(),this._colorsDistributionType=0,this._colorsTexture=null,q=q||{color:UP.DEFAULT_COLOR},this.visibility=q.visibility??1,this.useDash=q.useDash??!1,this.dashRatio=q.dashRatio??.5,this.dashOffset=q.dashOffset??0,this.dashCount=q.dashCount??1,this.width=q.width?q.width:q.sizeAttenuation&&q.cameraFacing?UP.DEFAULT_WIDTH_ATTENUATED:UP.DEFAULT_WIDTH,this.sizeAttenuation=q.sizeAttenuation??!1,this.color=q.color??S.Df.White(),this.useColors=q.useColors??!1,this.colorsDistributionType=q.colorDistributionType??0,this.colorsSampling=q.colorsSampling??l.d.NEAREST_NEAREST,this.colorMode=q.colorMode??0,this._colors=q.DP??null,this._cameraFacing=q.cameraFacing??!0,this.resolution=q.resolution??new C.Vector2(m.getRenderWidth(),m.getRenderHeight()),q.colorsTexture?this.colorsTexture=q.colorsTexture:this._colors?this.colorsTexture=eP.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,f):(this._color=this._color??UP.DEFAULT_COLOR,this.colorsTexture=eP.PrepareEmptyColorsTexture(f)),L){const P=new IP.c;P.setParameters(),P.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",P)}m.vf.add((()=>{eP.DisposeEmptyColorsTexture()}))}dispose(){var P;null===(P=this._colorsTexture)||void 0===P||P.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new C.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get DP(){return this._colors}set DP(P){this.setColors(P)}setColors(P){var f;let Y=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const q=(null===(f=this._colors)||void 0===f?void 0:f.length)??0;var m;if(this._colors=P,null!==P&&0!==P.length){if(!Y||C)if(this._colorsTexture&&q===P.length&&!C){const f=eP.Color3toRGBAUint8(P);this._colorsTexture.update(f)}else{var L;null===(L=this._colorsTexture)||void 0===L||L.dispose(),this.colorsTexture=eP.CreateColorsTexture(`${this.name}-colors-texture`,P,this.colorsSampling,this.vP())}}else null===(m=this._colorsTexture)||void 0===m||m.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(P){this._colorsTexture=P,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(P){this._width=P,this.setFloat("grlWidth",P)}get useColors(){return this._useColors}set useColors(P){this._useColors=P,this.setFloat("grlUseColors",eP.BooleanToNumber(P))}get colorsSampling(){return this._colorsSampling}set colorsSampling(P){this._colorsSampling=P}get visibility(){return this._visibility}set visibility(P){this._visibility=P,this.setFloat("grlVisibility",P)}get useDash(){return this._useDash}set useDash(P){this._useDash=P,this.setFloat("grlUseDash",eP.BooleanToNumber(P))}get dashOffset(){return this._dashOffset}set dashOffset(P){this._dashOffset=P,this.setFloat("grlDashOffset",P)}get dashRatio(){return this._dashRatio}set dashRatio(P){this._dashRatio=P,this.setFloat("grlDashRatio",P)}get dashCount(){return this._dashCount}set dashCount(P){this._dashCount=P,this._dashArray=1/P,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(P){this._sizeAttenuation=P,this.setFloat("grlSizeAttenuation",eP.BooleanToNumber(P))}get color(){return this._color}set color(P){this.setColor(P)}setColor(P){P=P??UP.DEFAULT_COLOR,this._color=P,this.setColor3("grlColor",P)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(P){this._colorsDistributionType=P,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(P){this._colorMode=P,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(P){this._resolution=P,this.setVector2("grlResolution",P),this.setFloat("grlAspect",P.x/P.y)}serialize(){const P=super.serialize(),f={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(f.DP=this._colors),P.greasedLineMaterialOptions=f,P}parse(P,f,Y){var C;const q=P.greasedLineMaterialOptions;null===(C=this._colorsTexture)||void 0===C||C.dispose(),q.color&&(this.color=q.color),q.colorDistributionType&&(this.colorsDistributionType=q.colorDistributionType),q.colorsSampling&&(this.colorsSampling=q.colorsSampling),q.colorMode&&(this.colorMode=q.colorMode),q.useColors&&(this.useColors=q.useColors),q.visibility&&(this.visibility=q.visibility),q.useDash&&(this.useDash=q.useDash),q.dashCount&&(this.dashCount=q.dashCount),q.dashRatio&&(this.dashRatio=q.dashRatio),q.dashOffset&&(this.dashOffset=q.dashOffset),q.width&&(this.width=q.width),q.sizeAttenuation&&(this.sizeAttenuation=q.sizeAttenuation),q.resolution&&(this.resolution=q.resolution),q.DP?this.colorsTexture=eP.CreateColorsTexture(`${this.name}-colors-texture`,q.DP,this.colorsSampling,this.vP()):this.colorsTexture=eP.PrepareEmptyColorsTexture(f),this._cameraFacing=q.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var xP,kP,ZP;XP.ForceGLSL=!1,function(P){P[P.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",P[P.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(xP||(xP={})),function(P){P[P.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",P[P.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",P[P.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(kP||(kP={})),function(P){P[P.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",P[P.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",P[P.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",P[P.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",P[P.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(ZP||(ZP={}));class AP extends MP.c{constructor(P,f,Y){super(P,f,null,null,!1,!1),this.name=P,this._options=Y,this._lazy=!1,this._updatable=!1,this._engine=f.getEngine(),this._lazy=Y.lazy??!1,this._updatable=Y.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=Y.colorPointers??[],this._widths=Y.widths??new Array(Y.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(P){let f=0;for(const C of this._points)f+=C.length;const Y=f/3*2-this._widths.length;for(let C=0;C<Y;C++)this._widths.push(P)}updateLazy(){var P,f;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(P=this._options.ribbonOptions)||void 0===P?void 0:P.smoothShading),!this.aP&&this.refreshBoundingInfo(),null===(f=this.greasedLineMaterial)||void 0===f||f.updateLazy()}addPoints(P,f){for(const Y of P)this._points.push(Y);this._lazy||this.setPoints(this._points,f)}dispose(P){let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(P,f)}isLazy(){return this._lazy}get jP(){return this._uvs}set jP(P){this._uvs=P instanceof Float32Array?P:new Float32Array(P),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(P){this.material instanceof XP&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===P||void 0===P?void 0:P.length)>0),this._offsets=P,this._offsetsBuffer?this._offsetsBuffer.update(P):this._createOffsetsBuffer(P)}get widths(){return this._widths}set widths(P){this._widths=P,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(P)}get colorPointers(){return this._colorPointers}set colorPointers(P){this._colorPointers=P,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(P)}get greasedLineMaterial(){var P,f;if(this.material&&this.material instanceof XP)return this.material;const Y=null===(P=this.material)||void 0===P||null===(f=P.pluginManager)||void 0===f?void 0:f.getPlugin(aP.GREASED_LINE_MATERIAL_NAME);return Y||void 0}get points(){const P=[];return JP.e.DeepCopy(this._points,P),P}setPoints(P,f){this._points=eP.ConvertPoints(P,(null===f||void 0===f?void 0:f.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==f&&void 0!==f&&f.colorPointers||this._updateColorPointers(),this._setPoints(this._points,f)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,jP:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(P){super.serialize(P),P.type=this.getClassName(),P.lineOptions=this._createLineOptions()}_createVertexBuffers(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const f=new QP.c;return f.TP=this._vertexPositions,f.indices=this._indices,f.jP=this._uvs,P&&(f.UP=[],QP.c.ComputeNormals(this._vertexPositions,this._indices,f.UP)),f.sP(this,this._options.updatable),f}_createOffsetsBuffer(P){const f=this._scene.getEngine(),Y=new R.c(f,P,this._updatable,3);this.setVerticesBuffer(Y.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=Y}}class EP{constructor(P,f){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=P,this.wasAddedByNoopNode=f}getIndicesAccessor(P,f,Y,C,q){var m,L,o,w;return null===(m=this._indicesAccessorMap.get(P))||void 0===m||null===(L=m.get(f))||void 0===L||null===(o=L.get(Y))||void 0===o||null===(w=o.get(C))||void 0===w?void 0:w.get(q)}setIndicesAccessor(P,f,Y,C,q,m){let L=this._indicesAccessorMap.get(P);L||(L=new Map,this._indicesAccessorMap.set(P,L));let o=L.get(f);o||(o=new Map,L.set(f,o));let w=o.get(Y);w||(w=new Map,o.set(Y,w));let d=w.get(C);d||(d=new Map,w.set(C,d)),d.set(q,m)}pushExportedNode(P){this._exportedNodes.has(P)||this._exportedNodes.add(P)}getNodesSet(){return this._exportedNodes}getVertexBufferView(P){return this._vertexBufferViewMap.get(P)}setVertexBufferView(P,f){this._vertexBufferViewMap.set(P,f)}setRemappedBufferView(P,f,Y){this._remappedBufferView.set(P,new Map),this._remappedBufferView.get(P).set(f,Y)}getRemappedBufferView(P,f){var Y;return null===(Y=this._remappedBufferView.get(P))||void 0===Y?void 0:Y.get(f)}getVertexAccessor(P,f,Y){var C,q;return null===(C=this._vertexAccessorMap.get(P))||void 0===C||null===(q=C.get(f))||void 0===q?void 0:q.get(Y)}setVertexAccessor(P,f,Y,C){let q=this._vertexAccessorMap.get(P);q||(q=new Map,this._vertexAccessorMap.set(P,q));let m=q.get(f);m||(m=new Map,q.set(f,m)),m.set(Y,C)}hasVertexColorAlpha(P){return this._vertexMapColorAlpha.get(P)||!1}setHasVertexColorAlpha(P,f){return this._vertexMapColorAlpha.set(P,f)}getMesh(P){return this._meshMap.get(P)}setMesh(P,f){this._meshMap.set(P,f)}bindMorphDataToMesh(P,f){const Y=this._meshMorphTargetMap.get(P)||[];this._meshMorphTargetMap.set(P,Y),-1===Y.indexOf(f)&&Y.push(f)}getMorphTargetsFromMesh(P){return this._meshMorphTargetMap.get(P)}}class tP{_ApplyExtension(P,f,Y,C){if(Y>=f.length)return Promise.resolve(P);const q=C(f[Y],P);return q?q.then((async P=>P?await this._ApplyExtension(P,f,Y+1,C):null)):this._ApplyExtension(P,f,Y+1,C)}_ApplyExtensions(P,f){const Y=[];for(const C of tP._ExtensionNames)Y.push(this._extensions[C]);return this._ApplyExtension(P,Y,0,f)}_extensionsPreExportTextureAsync(P,f,Y){return this._ApplyExtensions(f,((f,C)=>f.preExportTextureAsync&&f.preExportTextureAsync(P,C,Y)))}_extensionsPostExportNodeAsync(P,f,Y,C,q){return this._ApplyExtensions(f,((f,m)=>f.postExportNodeAsync&&f.postExportNodeAsync(P,m,Y,C,q,this._bufferManager)))}_extensionsPostExportMaterialAsync(P,f,Y){return this._ApplyExtensions(f,((f,C)=>f.postExportMaterialAsync&&f.postExportMaterialAsync(P,C,Y)))}_extensionsPostExportMaterialAdditionalTextures(P,f,Y){const C=[];for(const q of tP._ExtensionNames){const m=this._extensions[q];m.postExportMaterialAdditionalTextures&&C.push(...m.postExportMaterialAdditionalTextures(P,f,Y))}return C}_extensionsPostExportTextures(P,f,Y){for(const C of tP._ExtensionNames){const q=this._extensions[C];q.postExportTexture&&q.postExportTexture(P,f,Y)}}_extensionsPostExportMeshPrimitive(P){for(const f of tP._ExtensionNames){const Y=this._extensions[f];Y.postExportMeshPrimitive&&Y.postExportMeshPrimitive(P,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const P of tP._ExtensionNames){const f=this._extensions[P];f.preGenerateBinaryAsync&&await f.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(P){for(const f of tP._ExtensionNames){const Y=this._extensions[f];Y.enabled&&P(Y)}}_extensionsOnExporting(){this._forEachExtensions((P=>{var f,Y,C;P.wasUsed&&((f=this._glTF).extensionsUsed||(f.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(P.name)&&this._glTF.extensionsUsed.push(P.name),P.required&&((Y=this._glTF).extensionsRequired||(Y.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(P.name)&&this._glTF.extensionsRequired.push(P.name)),(C=this._glTF).extensions||(C.extensions={}),P.onExporting&&P.onExporting())}))}_loadExtensions(){for(const P of tP._ExtensionNames){const f=tP._ExtensionFactories[P](this);this._extensions[P]=f}}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:g.e.LastCreatedScene,f=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${u.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new I(this),this._extensions={},this._bufferManager=new RP,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!P)throw new Error("No scene available to export");this._babylonScene=P,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:P=>{var f;return null===P||void 0===P||null===(f=P.jf)||void 0===f?void 0:f.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...f},this._loadExtensions()}dispose(){for(const P in this._extensions){this._extensions[P].dispose()}}get options(){return this._options}static RegisterExtension(P,f){tP.UnregisterExtension(P)&&q.Tools.Warn(`Extension with the name ${P} already exists`),tP._ExtensionFactories[P]=f,tP._ExtensionNames.push(P)}static UnregisterExtension(P){if(!tP._ExtensionFactories[P])return!1;delete tP._ExtensionFactories[P];const f=tP._ExtensionNames.indexOf(P);return-1!==f&&tP._ExtensionNames.splice(f,1),!0}_generateJSON(P,f,Y){const C={byteLength:P};return C.byteLength&&(this._glTF.buffers=[C]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.lf=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(C.uri=f+".bin"),Y?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(P){const f=await this._generateBinaryAsync();this._extensionsOnExporting();const Y=this._generateJSON(f.byteLength,P,!0),C=new Blob([f],{type:"application/octet-stream"}),q=P+".gltf",m=P+".bin",L=new d;if(L.files[q]=Y,L.files[m]=C,this._imageData)for(const o in this._imageData)L.files[o]=new Blob([this._imageData[o].data],{type:this._imageData[o].mimeType});return L}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(P){const f=P%4;return 0===f?f:4-f}async generateGLBAsync(P){this._shouldUseGlb=!0;const f=await this._generateBinaryAsync();this._extensionsOnExporting();const Y=this._generateJSON(f.byteLength),C=P+".glb";let q,m=Y.length;if("undefined"!==typeof TextEncoder){q=(new TextEncoder).encode(Y),m=q.length}const L=this._getPadding(m),o=this._getPadding(f.byteLength),w=28+m+L+f.byteLength+o,R=new wP(w);if(R.writeUInt32(1179937895),R.writeUInt32(2),R.writeUInt32(w),R.writeUInt32(m+L),R.writeUInt32(1313821514),q)R.writeTypedArray(q);else{const P="_".charCodeAt(0);for(let f=0;f<m;++f){const C=Y.charCodeAt(f);C!=Y.codePointAt(f)?R.writeUInt8(P):R.writeUInt8(C)}}for(let d=0;d<L;++d)R.writeUInt8(32);R.writeUInt32(f.byteLength+o),R.writeUInt32(5130562),R.writeTypedArray(f);for(let d=0;d<o;++d)R.writeUInt8(0);const y=new d;return y.files[C]=new Blob([R.getOutputData()],{type:"application/octet-stream"}),y}_setNodeTransformation(P,f,Y){if(f.getPivotPoint().equalsWithEpsilon(A,Z.c)||q.Tools.Warn("Pivot points are not supported in the glTF serializer"),!f.position.equalsWithEpsilon(A,Z.c)){const q=C.TmpVectors.Of[0].q(f.position);Y&&p(q),P.translation=q.If()}f.Ro.equalsWithEpsilon(t,Z.c)||(P.scale=f.Ro.If());const m=f.rotationQuaternion||C.Quaternion.FromEulerAngles(f.rotation.x,f.rotation.y,f.rotation.z);m.equalsWithEpsilon(E,Z.c)||(Y&&h(m),P.rotation=m.normalize().If())}_setCameraTransformation(P,f,Y){if(!f.position.equalsWithEpsilon(A,Z.c)){const q=C.TmpVectors.Of[0].q(f.position);Y&&p(q),P.translation=q.If()}const q=f.rotationQuaternion||C.Quaternion.FromEulerAngles(f.rotation.x,f.rotation.y,f.rotation.z);Y&&h(q),this._babylonScene.useRightHandedSystem||F(q),q.equalsWithEpsilon(E,Z.c)||(P.rotation=q.If())}_listAvailableCameras(){for(const P of this._babylonScene.cameras){const f={type:P.mode===rP.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(P.name&&(f.name=P.name),"perspective"===f.type)f.perspective={aspectRatio:P.getEngine().getAspectRatio(P),yfov:P.fovMode===rP.e.FOVMODE_VERTICAL_FIXED?P.fov:P.fov*P.getEngine().getAspectRatio(P),znear:P.zf,zfar:P.maxZ};else if("orthographic"===f.type){const Y=P.orthoLeft&&P.orthoRight?.5*(P.orthoRight-P.orthoLeft):.5*P.getEngine().getRenderWidth(),C=P.orthoBottom&&P.orthoTop?.5*(P.orthoTop-P.orthoBottom):.5*P.getEngine().getRenderHeight();f.orthographic={xmag:Y,ymag:C,znear:P.zf,zfar:P.maxZ}}this._camerasMap.set(P,f)}}_exportAndAssignCameras(){const P=Array.from(this._camerasMap.values());for(const f of P){const P=this._nodesCameraMap.get(f);if(void 0!==P){this._cameras.push(f);for(const f of P)f.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const P of this._babylonScene.skeletons){if(P.bones.length<=0)continue;const f={joints:[]};this._skinMap.set(P,f)}}_exportAndAssignSkeletons(){for(const P of this._babylonScene.skeletons){if(P.bones.length<=0)continue;const f=this._skinMap.get(P);if(void 0==f)continue;const Y={},C=[];let m=-1;for(let q=0;q<P.bones.length;++q){const f=P.bones[q],C=f.getIndex()??q;-1!==C&&(Y[C]=f,C>m&&(m=C))}for(let P=0;P<=m;++P){const m=Y[P];C.push(m.getAbsoluteInverseBindMatrix());const L=m.getTransformNode();if(null!==L){const P=this._nodeMap.get(L);L&&null!==P&&void 0!==P?f.joints.push(P):q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const L=this._nodesSkinMap.get(f);if(f.joints.length>0&&void 0!==L){const P=64*C.length,Y=new Float32Array(P/4);C.forEach(((P,f)=>{Y.set(P.m,16*f)}));const q=this._bufferManager.createBufferView(Y);this._accessors.push(this._bufferManager.createAccessor(q,"MAT4",5126,C.length)),f.inverseBindMatrices=this._accessors.length-1,this._skins.push(f);for(const f of L)f.skin=this._skins.length-1}}}async _exportSceneAsync(){const P={nodes:[]};if(this._babylonScene.metadata){const f=this._options.metadataSelector(this._babylonScene.metadata);f&&(P.extras=f)}const f=new Array,Y=new Array,C=new Array;for(const o of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&LP(o,this._babylonScene.useRightHandedSystem)?C.push(...o.getChildren()):this._babylonScene.useRightHandedSystem?f.push(o):Y.push(o);this._listAvailableCameras(),this._listAvailableSkeletons();const q=new EP(!0,!1);P.nodes.push(...await this._exportNodesAsync(Y,q));const m=new EP(!1,!1);P.nodes.push(...await this._exportNodesAsync(f,m));const L=new EP(!1,!0);P.nodes.push(...await this._exportNodesAsync(C,L)),P.nodes.length&&this._scenes.push(P),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&OP._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,q.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(P){let f=this._shouldExportNodeMap.get(P);return void 0===f&&(f=this._options.shouldExportNode(P),this._shouldExportNodeMap.set(P,f)),f}async _exportNodesAsync(P,f){const Y=new Array;this._exportBuffers(P,f);for(const C of P)await this._exportNodeAsync(C,Y,f);return Y}_collectBuffers(P,f,Y,C,q){if(this._shouldExportNode(P)&&P instanceof r.b&&P.qq){const m=P.qq.getVertexBuffers();if(m)for(const C in m){if(!b(C))continue;const L=m[C];q.setHasVertexColorAlpha(L,P.hasVertexAlpha);const o=L._buffer,w=f.get(o)||[];f.set(o,w),-1===w.indexOf(L)&&w.push(L);const d=Y.get(L)||[];Y.set(L,d),-1===d.indexOf(P)&&d.push(P)}const L=P.morphTargetManager;if(L)for(let f=0;f<L.numTargets;f++){const Y=L.getTarget(f),q=C.get(Y)||[];C.set(Y,q),-1===q.indexOf(P)&&q.push(P)}}for(const m of P.getChildren())this._collectBuffers(m,f,Y,C,q)}_exportBuffers(P,f){const Y=new Map,C=new Map,q=new Map;for(const o of P)this._collectBuffers(o,Y,C,q,f);const m=Array.from(Y.keys());for(const o of m){const P=o.getData();if(!P)throw new Error("Buffer data is not available");const q=Y.get(o);if(!q)continue;const m=q[0].byteStride;if(q.some((P=>P.byteStride!==m)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const L=YP(P).slice();for(const f of q){const P=C.get(f),{byteOffset:Y,byteStride:q,componentCount:m,type:o,count:w,normalized:d,kind:y}=z(f,P);switch(y){case R.d.NormalKind:case R.d.TangentKind:(0,X.i)(L,Y,q,m,o,w,d,(P=>{const f=Math.sqrt(P[0]*P[0]+P[1]*P[1]+P[2]*P[2]);if(f>0){const Y=1/f;P[0]*=Y,P[1]*=Y,P[2]*=Y}}));break;case R.d.ColorKind:{const f=P.filter((P=>P.material instanceof gP.Uf||null==P.material)).length;if(0==f)break;if(f!=P.length){x.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}o==R.d.UNSIGNED_BYTE&&x.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const C=new S.Df,y=new S.ro,r=this._babylonScene.getEngine().useExactSrgbConversions;(0,X.i)(L,Y,q,m,o,w,d,(P=>{3===P.length?(C.jY(P,0),C.toLinearSpaceToRef(C,r),C.toArray(P,0)):(y.jY(P,0),y.toLinearSpaceToRef(y,r),y.toArray(P,0))}))}}}if(f.convertToRightHanded){for(const P of q){const f=C.get(P),{byteOffset:Y,byteStride:q,componentCount:m,type:o,count:w,normalized:d,kind:y}=z(P,f);switch(y){case R.d.PositionKind:case R.d.NormalKind:case R.d.TangentKind:(0,X.i)(L,Y,q,m,o,w,d,(P=>{P[0]=-P[0]}))}}f.convertedToRightHandedBuffers.set(o,L)}const w=this._bufferManager.createBufferView(L,m);f.setVertexBufferView(o,w);const d=new Map;for(const f of q){const P=C.get(f),{kind:Y,totalVertices:q}=z(f,P);switch(Y){case R.d.MatricesIndicesKind:case R.d.MatricesIndicesExtraKind:if(f.type==R.d.FLOAT){const P=f.getFloatData(q);null!==P&&d.set(f,P)}}}0!==d.size&&x.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const y=Array.from(d.keys());for(const Y of y){const P=d.get(Y);if(!P)continue;const C=P.some((P=>P>=256)),q=new(C?Uint16Array:Uint8Array)(P.length);for(let f=0;f<P.length;f++)q[f]=P[f];const m=this._bufferManager.createBufferView(q,4*(C?2:1));f.setRemappedBufferView(o,Y,m)}}const L=Array.from(q.keys());for(const o of L){const P=q.get(o);if(!P)continue;const Y=nP(o,P[0],this._bufferManager,this._bufferViews,this._accessors,f.convertToRightHanded);for(const C of P)f.bindMorphDataToMesh(C,Y)}}async _exportNodeAsync(P,f,Y){let C=this._nodeMap.get(P);if(void 0!==C)return void(f.includes(C)||f.push(C));const q=await this._createNodeAsync(P,Y);if(q){C=this._nodes.length,this._nodes.push(q),this._nodeMap.set(P,C),Y.pushExportedNode(P),f.push(C);const m={name:"runtime animations",channels:[],samplers:[]},L=[];this._babylonScene.animationGroups.length||(OP._CreateMorphTargetAnimationFromMorphTargetAnimations(P,m,L,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Y.convertToRightHanded,this._options.shouldExportAnimation),P.animations.length&&OP._CreateNodeAnimationFromNodeAnimations(P,m,L,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Y.convertToRightHanded,this._options.shouldExportAnimation)),m.channels.length&&m.samplers.length&&this._animations.push(m),L.forEach((P=>{P.channels.length&&P.samplers.length&&this._animations.push(P)}))}const m=q?[]:f;for(const L of P.getChildren())await this._exportNodeAsync(L,m,Y);q&&m.length&&(q.children=m)}async _createNodeAsync(P,f){if(!this._shouldExportNode(P))return null;const Y={};if(P.name&&(Y.name=P.name),P.metadata){const f=this._options.metadataSelector(P.metadata);f&&(Y.extras=f)}if(P instanceof y.c&&(this._setNodeTransformation(Y,P,f.convertToRightHanded),P instanceof r.b)){const q=P instanceof i.b?P.sourceMesh:P;if(q.Jf&&q.Jf.length>0&&(Y.mesh=await this._exportMeshAsync(q,f)),P.skeleton){const f=this._skinMap.get(P.skeleton);var C;if(void 0!==f)void 0===this._nodesSkinMap.get(f)&&this._nodesSkinMap.set(f,[]),null===(C=this._nodesSkinMap.get(f))||void 0===C||C.push(Y)}}if(P instanceof k.e){const C=this._camerasMap.get(P);if(C){var q;void 0===this._nodesCameraMap.get(C)&&this._nodesCameraMap.set(C,[]),this._setCameraTransformation(Y,P,f.convertToRightHanded);const L=P.parent;if(null!==L&&fP(P,L)){const P=this._nodeMap.get(L);if(void 0!==P){var m;const f=this._nodes[P];return PP(Y,f),null===(m=this._nodesCameraMap.get(C))||void 0===m||m.push(f),null}}null===(q=this._nodesCameraMap.get(C))||void 0===q||q.push(Y)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",Y,P,this._nodeMap,f.convertToRightHanded)?Y:(x.e.Warn(`Not exporting node ${P.name}`),null)}_exportIndices(P,f,Y,C,q,L,o,w,d){let R=P;d.mode=H(L);const y=o!==m.d.CounterClockWiseSideOrientation,r=!w.wasAddedByNoopNode&&y,i=function(P){switch(P){case m.d.TriangleFillMode:case m.d.TriangleStripDrawMode:case m.d.TriangleFanDrawMode:return!0}return!1}(L)&&r;if(i){if(L===m.d.TriangleStripDrawMode||L===m.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");d.mode=H(L);const o=f?new Uint32Array(C):new Uint16Array(C);if(P)for(let f=0;f+2<C;f+=3)o[f]=P[Y+f]+q,o[f+1]=P[Y+f+2]+q,o[f+2]=P[Y+f+1]+q;else for(let P=0;P+2<C;P+=3)o[P]=P,o[P+1]=P+2,o[P+2]=P+1;R=o}else if(P&&0!==q){const m=f?new Uint32Array(C):new Uint16Array(C);for(let f=0;f<C;f++)m[f]=P[Y+f]+q;R=m}if(R){let m=w.getIndicesAccessor(P,Y,C,q,i);if(void 0===m){const L=function(P,f,Y,C){if(P instanceof Uint16Array||P instanceof Uint32Array)return P;if(P instanceof Int32Array)return new Uint32Array(P.buffer,P.byteOffset,P.length);const q=P.slice(f,f+Y);return C?new Uint32Array(q):new Uint16Array(q)}(R,0,C,f),o=this._bufferManager.createBufferView(L),d=f?5125:5123;this._accessors.push(this._bufferManager.createAccessor(o,"SCALAR",d,C,0)),m=this._accessors.length-1,w.setIndicesAccessor(P,Y,C,q,i,m)}d.indices=m}}_exportVertexBuffer(P,f,Y,C,q,m){const L=P.getKind();if(!b(L))return;if(L.startsWith("uv")&&!this._options.exportUnusedUVs&&(!f||!this._materialNeedsUVsSet.has(f)))return;let o=q.getVertexAccessor(P,Y,C);if(void 0===o){const f=q.convertedToRightHandedBuffers.get(P._buffer)||P._buffer.getData(),m=L===R.d.PositionKind?function(P,f,Y,C){const{byteOffset:q,byteStride:m,type:L,normalized:o}=f,w=f.getSize(),d=new Array(w).fill(1/0),R=new Array(w).fill(-1/0);return(0,X.i)(P,q+Y*m,m,w,L,C*w,o,(P=>{for(let f=0;f<w;f++)d[f]=Math.min(d[f],P[f]),R[f]=Math.max(R[f],P[f])})),{min:d,max:R}}(f,P,Y,C):void 0,w=(L===R.d.MatricesIndicesKind||L===R.d.MatricesIndicesExtraKind)&&P.type===R.d.FLOAT,d=w?R.d.UNSIGNED_BYTE:P.type,y=w?void 0:P.normalized,r=w?q.getRemappedBufferView(P._buffer,P):q.getVertexBufferView(P._buffer),i=P.byteOffset+Y*P.byteStride;this._accessors.push(this._bufferManager.createAccessor(r,function(P,f){if(P==R.d.ColorKind)return f?"VEC4":"VEC3";switch(P){case R.d.PositionKind:case R.d.NormalKind:return"VEC3";case R.d.TangentKind:case R.d.MatricesIndicesKind:case R.d.MatricesIndicesExtraKind:case R.d.MatricesWeightsKind:case R.d.MatricesWeightsExtraKind:return"VEC4";case R.d.UVKind:case R.d.UV2Kind:case R.d.UV3Kind:case R.d.UV4Kind:case R.d.UV5Kind:case R.d.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${P}`)}(L,q.hasVertexColorAlpha(P)),d,C,i,m,y)),o=this._accessors.length-1,q.setVertexAccessor(P,Y,C,o)}m.attributes[function(P){switch(P){case R.d.PositionKind:return"POSITION";case R.d.NormalKind:return"NORMAL";case R.d.TangentKind:return"TANGENT";case R.d.ColorKind:return"COLOR_0";case R.d.UVKind:return"TEXCOORD_0";case R.d.UV2Kind:return"TEXCOORD_1";case R.d.UV3Kind:return"TEXCOORD_2";case R.d.UV4Kind:return"TEXCOORD_3";case R.d.UV5Kind:return"TEXCOORD_4";case R.d.UV6Kind:return"TEXCOORD_5";case R.d.MatricesIndicesKind:return"JOINTS_0";case R.d.MatricesIndicesExtraKind:return"JOINTS_1";case R.d.MatricesWeightsKind:return"WEIGHTS_0";case R.d.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${P}`)}(L)]=o}async _exportMaterialAsync(P,f,Y,C){let q=this._materialMap.get(P);if(void 0===q){const C=f&&Object.keys(f).some((P=>P.startsWith("uv")));if((P=P instanceof iP.c?P.io[Y.materialIndex]:P)instanceof uP.d)q=await this._materialExporter.exportPBRMaterialAsync(P,"image/png",C);else{if(!(P instanceof gP.Uf))return void x.e.Warn(`Unsupported material '${P.name}' with type ${P.getClassName()}`);q=await this._materialExporter.exportStandardMaterialAsync(P,"image/png",C)}this._materialMap.set(P,q)}C.material=q}async _exportMeshAsync(P,f){var Y;let C=f.getMesh(P);if(void 0!==C)return C;const q={primitives:[]};C=this._meshes.length,this._meshes.push(q),f.setMesh(P,C);const L=P.isUnIndexed?null:P.eq(),o=null===(Y=P.qq)||void 0===Y?void 0:Y.getVertexBuffers(),w=f.getMorphTargetsFromMesh(P),d=P instanceof lP.e,R=P instanceof AP,y=P.Jf;if(o&&y&&y.length>0)for(const u of y){const Y={attributes:{}},C=u.IP()||this._babylonScene.defaultMaterial;if(R){var r,i;const f={name:C.name},q=P,m=S.Df.White(),L=(null===(r=q.material)||void 0===r?void 0:r.alpha)??1,o=(null===(i=q.greasedLineMaterial)||void 0===i?void 0:i.color)??m;(!o.equalsWithEpsilon(m,Z.c)||L<1)&&(f.pbrMetallicRoughness={baseColorFactor:[...o.If(),L]}),this._materials.push(f),Y.material=this._materials.length-1}else if(d){const f={name:C.name},q=P;(!q.color.equalsWithEpsilon(S.Df.White(),Z.c)||q.alpha<1)&&(f.pbrMetallicRoughness={baseColorFactor:[...q.color.If(),q.alpha]}),this._materials.push(f),Y.material=this._materials.length-1}else await this._exportMaterialAsync(C,o,u,Y);const y=d||R?m.d.LineListDrawMode:P.overrideRenderingFillMode??C.fillMode,g=C._getEffectiveOrientation(P);this._exportIndices(L,L?(0,X.c)(L,u.indexCount,u.indexStart,u.verticesStart):u.verticesCount>65535,L?u.indexStart:u.verticesStart,L?u.indexCount:u.verticesCount,-u.verticesStart,y,g,f,Y);for(const P of Object.values(o))this._exportVertexBuffer(P,C,u.verticesStart,u.verticesCount,f,Y);if(w){Y.targets=[];for(const P of w)Y.targets.push(P.attributes)}q.primitives.push(Y),this._extensionsPostExportMeshPrimitive(Y)}if(w){q.weights=[],q.extras||(q.extras={}),q.extras.targetNames=[];for(const P of w)q.weights.push(P.influence),q.extras.targetNames.push(P.name)}return C}}tP._ExtensionNames=new Array,tP._ExtensionFactories={};class GP{static async GLTFAsync(P,f,Y){Y&&Y.exportWithoutWaitingForScene||await P.whenReadyAsync();const C=new tP(P,Y),q=await C.generateGLTFAsync(f.replace(/\.[^/.]+$/,""));return C.dispose(),q}static async GLBAsync(P,f,Y){Y&&Y.exportWithoutWaitingForScene||await P.whenReadyAsync();const C=new tP(P,Y),q=await C.generateGLBAsync(f.replace(/\.[^/.]+$/,""));return C.dispose(),q}}Y(11773);const zP="EXT_mesh_gpu_instancing";class BP{constructor(P){this.name=zP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(P,f,Y,q,m,L){return await new Promise((P=>{if(f&&Y instanceof MP.c&&Y.hasThinInstances&&this._exporter){this._wasUsed=!0;const P=C.Of.Zero(),q=C.Quaternion.Identity(),o=C.Of.One(),w=Y.thinInstanceGetWorldMatrices(),d=C.TmpVectors.Of[2],R=C.TmpVectors.Quaternion[1],y=C.TmpVectors.Of[3];let r=!1,i=!1,u=!1;const g=new Float32Array(3*Y.uo),S=new Float32Array(4*Y.uo),K=new Float32Array(3*Y.uo);let M=0;for(const f of w)f.decompose(y,R,d),m&&(p(d),h(R)),g.set(d.If(),3*M),S.set(R.normalize().If(),4*M),K.set(y.If(),3*M),r=r||!d.equalsWithEpsilon(P),i=i||!R.equalsWithEpsilon(q),u=u||!y.equalsWithEpsilon(o),M++;const V={attributes:{}};r&&(V.attributes.TRANSLATION=this._buildAccessor(g,"VEC3",Y.uo,L)),i&&(V.attributes.ROTATION=this._buildAccessor(S,"VEC4",Y.uo,L)),u&&(V.attributes.SCALE=this._buildAccessor(K,"VEC3",Y.uo,L)),f.extensions=f.extensions||{},f.extensions[zP]=V}P(f)}))}_buildAccessor(P,f,Y,C){const q=C.createBufferView(P),m=C.createAccessor(q,f,5126,Y);return this._exporter._accessors.push(m),this._exporter._accessors.length-1}}tP.RegisterExtension(zP,(P=>new BP(P)));var bP=Y(11781),HP=Y(11795),WP=Y(11800),pP=Y(11806);function hP(P){return P===WP.e.PositionKind?"POSITION":P===WP.e.NormalKind?"NORMAL":P===WP.e.ColorKind?"COLOR":P.startsWith(WP.e.UVKind)?"TEX_COORD":"GENERIC"}const FP={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Pf extends bP.e{static get DefaultAvailable(){return(0,bP.j)(Pf.DefaultConfiguration)}static get Default(){return Pf._Default??(Pf._Default=new Pf),Pf._Default}static ResetDefault(P){Pf._Default&&(P||Pf._Default.dispose(),Pf._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(P,f){return{module:await(f||DracoEncoderModule)({wasmBinary:P})}}_getWorkerContent(){return`${HP.f}(${HP.i})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Pf.DefaultConfiguration)}async _encodeAsync(P,f,Y){const C=Y?(0,pP.b)(FP,Y):FP;if(this._workerPoolPromise){const Y=await this._workerPoolPromise;return await new Promise(((q,m)=>{Y.push(((Y,L)=>{const o=P=>{Y.removeEventListener("error",o),Y.removeEventListener("message",w),m(P),L()},w=P=>{"encodeMeshDone"===P.data.id&&(Y.removeEventListener("error",o),Y.removeEventListener("message",w),q(P.data.encodedMeshData),L())};Y.addEventListener("error",o),Y.addEventListener("message",w);const d=[];for(const f of P)d.push(f.data.buffer);f&&d.push(f.buffer),Y.postMessage({id:"encodeMesh",attributes:P,indices:f,options:C},d)}))}))}if(this._modulePromise){const Y=await this._modulePromise;return(0,HP.f)(Y.module,P,f,C)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(P,f){if(0==P.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");P instanceof MP.c&&P.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===f||void 0===f?void 0:f.method)&&(x.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),f.method="MESH_SEQUENTIAL_ENCODING");const Y=function(P){let f=P.eq(void 0,!0);return!f||f instanceof Uint32Array||f instanceof Uint16Array||(f=((0,X.c)(f,f.length)?Uint32Array:Uint16Array).from(f)),f}(P),C=function(P,f){const Y=[];for(const C of P.getVerticesDataKinds()){if(null!==f&&void 0!==f&&f.includes(C)){if(C===WP.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const q=P.getVertexBuffer(C),m=q.getSize(),L=(0,X.q)(q.getData(),m,q.type,q.byteOffset,q.byteStride,q.normalized,P.getTotalVertices(),!0);Y.push({kind:C,dracoName:hP(C),size:m,data:L})}return Y}(P,null===f||void 0===f?void 0:f.excludedAttributes);return await this._encodeAsync(C,Y,f)}}Pf.DefaultConfiguration={wasmUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder.js`},Pf._Default=null;const ff="KHR_draco_mesh_compression";class Yf{get wasUsed(){return this._wasUsed}constructor(P){this.name=ff,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===P.options.meshCompressionMethod&&Pf.DefaultAvailable}dispose(){}postExportMeshPrimitive(P,f,Y){if(!this.enabled)return;if(4!==P.mode&&5!==P.mode)return void x.e.Warn("Cannot compress primitive with mode "+P.mode+".");const C=[],q=[];let m=null;if(void 0!==P.indices){const L=Y[P.indices],o=f.getBufferView(L);m=f.getData(o).slice(),C.push(o),q.push(L)}const L=[];for(const[R,y]of Object.entries(P.attributes)){const P=Y[y],m=f.getBufferView(P),w=B(P.type),d=(0,X.q)(f.getData(m),w,P.componentType,P.byteOffset||0,m.byteStride||(0,X.o)(P.componentType)*w,P.normalized||!1,P.count,!0);L.push({kind:R,dracoName:(o=R,"POSITION"===o?"POSITION":"NORMAL"===o?"NORMAL":o.startsWith("COLOR")?"COLOR":o.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:B(P.type),data:d}),C.push(m),q.push(P)}var o;const w={method:P.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},d=Pf.Default._encodeAsync(L,m,w).then((Y=>{if(!Y)return void x.e.Error("Draco encoding failed for primitive.");const m={bufferView:-1,attributes:Y.attributeIds},L=f.createBufferView(Y.data);f.setBufferView(m,L);for(const P of C)this._bufferViewsUsed.add(P);for(const P of q)this._accessorsUsed.add(P);P.extensions||(P.extensions={}),P.extensions[ff]=m})).catch((P=>{x.e.Error("Draco encoding failed for primitive: "+P)}));this._encodePromises.push(d),this._wasUsed=!0}async preGenerateBinaryAsync(P){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((f=>{P.getPropertiesWithBufferView(f).every((P=>this._accessorsUsed.has(P)))&&P.removeBufferView(f)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}tP.RegisterExtension(ff,(P=>new Yf(P)));var Cf=Y(11812);const qf="KHR_lights_punctual",mf={name:"",color:[1,1,1],So:1,range:Number.MAX_VALUE},Lf={innerConeAngle:0,outerConeAngle:Math.PI/4},of=C.Of.Backward();class wf{constructor(P){this.name=qf,this.enabled=!0,this.required=!1,this._exporter=P}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[qf]=this._lights}async postExportNodeAsync(P,f,Y,q,m){return await new Promise((L=>{if(!(Y instanceof VP.d))return void L(f);const o=Y.getTypeID()==VP.d.LIGHTTYPEID_POINTLIGHT?"point":Y.getTypeID()==VP.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":Y.getTypeID()==VP.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!o||!(Y instanceof Cf.c))return x.e.Warn(`${P}: Light ${Y.name} is not supported in ${qf}`),void L(f);if(Y.falloffType!==VP.d.FALLOFF_GLTF&&x.e.Warn(`${P}: Light falloff for ${Y.name} does not match the ${qf} specification!`),!Y.position.equalsToFloats(0,0,0)){const P=C.TmpVectors.Of[0].q(Y.position);m&&p(P),f.translation=P.If()}if("point"!==o){const P=Y.direction.normalizeToRef(C.TmpVectors.Of[0]);m&&p(P);const q=C.Quaternion.FromUnitVectorsToRef(of,P,C.TmpVectors.Quaternion[0]);C.Quaternion.IsIdentity(q)||(f.rotation=q.If())}const w={type:o,name:Y.name,color:Y.Ko.If(),So:Y.So,range:Y.range};if(CP(w,mf),"spot"===o){const P=Y;w.spot={innerConeAngle:P.innerAngle/2,outerConeAngle:P.angle/2},CP(w.spot,Lf)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(w);const d={Sf:this._lights.lights.length-1},R=Y.parent;if(R&&fP(Y,R)){const P=q.get(R);if(P){const Y=this._exporter._nodes[P];return PP(f,Y),Y.extensions||(Y.extensions={}),Y.extensions[qf]=d,void L(null)}}f.extensions||(f.extensions={}),f.extensions[qf]=d,L(f)}))}}tP.RegisterExtension(qf,(P=>new wf(P)));var df=Y(11712);const Rf="KHR_materials_anisotropy";class yf{constructor(P){this.name=Rf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,f,Y){const C=[];return Y instanceof df.e&&Y.anisotropy.isEnabled&&!Y.anisotropy.legacy?(Y.anisotropy.texture&&C.push(Y.anisotropy.texture),C):[]}postExportMaterialAsync(P,f,Y){return new Promise((P=>{if(Y instanceof df.e){if(!Y.anisotropy.isEnabled||Y.anisotropy.legacy)return void P(f);this._wasUsed=!0,f.extensions=f.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(Y.anisotropy.texture),q={anisotropyStrength:Y.anisotropy.So,anisotropyRotation:Y.anisotropy.angle,anisotropyTexture:C??void 0};null!==q.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(Y),f.extensions[Rf]=q}P(f)}))}}tP.RegisterExtension(Rf,(P=>new yf(P)));const rf="KHR_materials_clearcoat";class uf{constructor(P){this.name=rf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,f,Y){const C=[];return Y instanceof df.e&&Y.clearCoat.isEnabled?(Y.clearCoat.texture&&C.push(Y.clearCoat.texture),!Y.clearCoat.useRoughnessFromMainTexture&&Y.clearCoat.textureRoughness&&C.push(Y.clearCoat.textureRoughness),Y.clearCoat.bumpTexture&&C.push(Y.clearCoat.bumpTexture),C):[]}postExportMaterialAsync(P,f,Y){return new Promise((P=>{if(Y instanceof df.e){if(!Y.clearCoat.isEnabled)return void P(f);this._wasUsed=!0,f.extensions=f.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(Y.clearCoat.texture);let m;m=Y.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(Y.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(Y.clearCoat.textureRoughness),Y.clearCoat.isTintEnabled&&q.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${Y.name}`),Y.clearCoat.remapF0OnInterfaceChange&&q.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${Y.name}`);const L=this._exporter._materialExporter.getTextureInfo(Y.clearCoat.bumpTexture),o={clearcoatFactor:Y.clearCoat.So,clearcoatTexture:C??void 0,clearcoatRoughnessFactor:Y.clearCoat.roughness,clearcoatRoughnessTexture:m??void 0,clearcoatNormalTexture:L??void 0};null===o.clearcoatTexture&&null===o.clearcoatRoughnessTexture&&null===o.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Y),f.extensions[rf]=o}P(f)}))}}tP.RegisterExtension(rf,(P=>new uf(P)));const gf="KHR_materials_diffuse_transmission";function Sf(P,f){const Y=f.subSurface;let C=null;return Y.translucencyIntensityTexture?C=Y.translucencyIntensityTexture:Y.thicknessTexture&&Y.useMaskFromThicknessTexture&&(C=Y.thicknessTexture),C&&!Y.useGltfStyleTextures?(x.e.Warn(`${P}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${f.name}`,1),null):C}class Kf{constructor(P){this.name=gf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,f,Y){const C=[];if(Y instanceof uP.d&&this._isExtensionEnabled(Y)){const f=Sf(P,Y);return f&&C.push(f),Y.subSurface.translucencyColorTexture&&C.push(Y.subSurface.translucencyColorTexture),C}return C}_isExtensionEnabled(P){if(P.unlit)return!1;const f=P.subSurface;return!!f.isTranslucencyEnabled&&(!P.unlit&&!f.useAlbedoToTintTranslucency&&f.useGltfStyleTextures&&1===f.volumeIndexOfRefraction&&0===f.minimumThickness&&0===f.maximumThickness)}postExportMaterialAsync(P,f,Y){return new Promise((C=>{if(Y instanceof uP.d&&this._isExtensionEnabled(Y)){this._wasUsed=!0;const C=Y.subSurface,q=Sf(P,Y),m=0==C.translucencyIntensity?void 0:C.translucencyIntensity,L=this._exporter._materialExporter.getTextureInfo(q)??void 0,o=!C.translucencyColor||C.translucencyColor.equalsFloats(1,1,1)?void 0:C.translucencyColor.If(),w=this._exporter._materialExporter.getTextureInfo(C.translucencyColorTexture)??void 0,d={diffuseTransmissionFactor:m,diffuseTransmissionTexture:L,diffuseTransmissionColorFactor:o,diffuseTransmissionColorTexture:w};(L||w)&&this._exporter._materialNeedsUVsSet.add(Y),f.extensions=f.extensions||{},f.extensions[gf]=d}C(f)}))}}tP.RegisterExtension(gf,(P=>new Kf(P)));const Mf="KHR_materials_dispersion";class Vf{constructor(){this.name=Mf,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(P){if(P.unlit)return!1;const f=P.subSurface;return!(!f.isRefractionEnabled&&!f.isDispersionEnabled)}postExportMaterialAsync(P,f,Y){return new Promise((P=>{if(Y instanceof uP.d&&this._isExtensionEnabled(Y)){this._wasUsed=!0;const P={dispersion:Y.subSurface.dispersion};f.extensions=f.extensions||{},f.extensions[Mf]=P}P(f)}))}}tP.RegisterExtension(Mf,(()=>new Vf));const Of="KHR_materials_emissive_strength";class nf{constructor(){this.name=Of,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(P,f,Y){return await new Promise((P=>{if(!(Y instanceof uP.d))return P(f);const C=Y.emissiveColor.If(),q=Math.max(...C);if(q>1){this._wasUsed=!0,f.extensions||(f.extensions={});const P={emissiveStrength:q},C=Y.emissiveColor.scale(1/P.emissiveStrength);f.emissiveFactor=C.If(),f.extensions[Of]=P}return P(f)}))}}tP.RegisterExtension(Of,(P=>new nf));const lf="KHR_materials_ior";class vf{constructor(){this.name=lf,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(P){return!P.unlit&&(void 0!=P.indexOfRefraction&&1.5!=P.indexOfRefraction)}postExportMaterialAsync(P,f,Y){return new Promise((P=>{if(Y instanceof uP.d&&this._isExtensionEnabled(Y)){this._wasUsed=!0;const P={ior:Y.indexOfRefraction};f.extensions=f.extensions||{},f.extensions[lf]=P}P(f)}))}}tP.RegisterExtension(lf,(P=>new vf));const cf="KHR_materials_iridescence";class Tf{constructor(P){this.name=cf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,f,Y){const C=[];return Y instanceof df.e&&Y.iridescence.isEnabled?(Y.iridescence.texture&&C.push(Y.iridescence.texture),Y.iridescence.thicknessTexture&&Y.iridescence.thicknessTexture!==Y.iridescence.texture&&C.push(Y.iridescence.thicknessTexture),C):[]}postExportMaterialAsync(P,f,Y){return new Promise((P=>{if(Y instanceof df.e){if(!Y.iridescence.isEnabled)return void P(f);this._wasUsed=!0,f.extensions=f.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(Y.iridescence.texture),q=this._exporter._materialExporter.getTextureInfo(Y.iridescence.thicknessTexture),m={iridescenceFactor:Y.iridescence.So,iridescenceIor:Y.iridescence.indexOfRefraction,iridescenceThicknessMinimum:Y.iridescence.minimumThickness,iridescenceThicknessMaximum:Y.iridescence.maximumThickness,iridescenceTexture:C??void 0,iridescenceThicknessTexture:q??void 0};null===m.iridescenceTexture&&null===m.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(Y),f.extensions[cf]=m}P(f)}))}}tP.RegisterExtension(cf,(P=>new Tf(P)));const Uf="KHR_materials_sheen";class Df{constructor(P){this.name=Uf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,f,Y){return Y instanceof uP.d&&Y.sheen.isEnabled&&Y.sheen.texture?[Y.sheen.texture]:[]}async postExportMaterialAsync(P,f,Y){return await new Promise((P=>{if(Y instanceof uP.d){if(!Y.sheen.isEnabled)return void P(f);this._wasUsed=!0,null==f.extensions&&(f.extensions={});const C={sheenColorFactor:Y.sheen.color.If(),sheenRoughnessFactor:Y.sheen.roughness??0};null===C.sheenColorTexture&&null===C.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Y),Y.sheen.texture&&(C.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(Y.sheen.texture)??void 0),Y.sheen.textureRoughness&&!Y.sheen.useRoughnessFromMainTexture?C.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Y.sheen.textureRoughness)??void 0:Y.sheen.texture&&Y.sheen.useRoughnessFromMainTexture&&(C.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Y.sheen.texture)??void 0),f.extensions[Uf]=C}P(f)}))}}tP.RegisterExtension(Uf,(P=>new Df(P)));const jf="KHR_materials_specular";class ef{constructor(P){this.name=jf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,f,Y){const C=[];return Y instanceof uP.d&&this._isExtensionEnabled(Y)?(Y.metallicReflectanceTexture&&C.push(Y.metallicReflectanceTexture),Y.reflectanceTexture&&C.push(Y.reflectanceTexture),C):C}_isExtensionEnabled(P){return!P.unlit&&(void 0!=P.metallicF0Factor&&1!=P.metallicF0Factor||void 0!=P.metallicReflectanceColor&&!P.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(P))}_hasTexturesExtension(P){return null!=P.metallicReflectanceTexture||null!=P.reflectanceTexture}postExportMaterialAsync(P,f,Y){return new Promise((P=>{if(Y instanceof uP.d&&this._isExtensionEnabled(Y)){this._wasUsed=!0,f.extensions=f.extensions||{};const P=this._exporter._materialExporter.getTextureInfo(Y.metallicReflectanceTexture)??void 0,C=this._exporter._materialExporter.getTextureInfo(Y.reflectanceTexture)??void 0,q={specularFactor:1==Y.metallicF0Factor?void 0:Y.metallicF0Factor,specularTexture:P,specularColorFactor:Y.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:Y.metallicReflectanceColor.If(),specularColorTexture:C};this._hasTexturesExtension(Y)&&this._exporter._materialNeedsUVsSet.add(Y),f.extensions[jf]=q}P(f)}))}}tP.RegisterExtension(jf,(P=>new ef(P)));const sf="KHR_materials_transmission";class af{constructor(P){this.name=sf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,f,Y){const C=[];return Y instanceof uP.d&&this._isExtensionEnabled(Y)?(Y.subSurface.thicknessTexture&&C.push(Y.subSurface.thicknessTexture),C):C}_isExtensionEnabled(P){if(P.unlit)return!1;const f=P.subSurface;return f.isRefractionEnabled&&void 0!=f.refractionIntensity&&0!=f.refractionIntensity||this._hasTexturesExtension(P)}_hasTexturesExtension(P){return null!=P.subSurface.refractionIntensityTexture}async postExportMaterialAsync(P,f,Y){if(Y instanceof uP.d&&this._isExtensionEnabled(Y)){this._wasUsed=!0;const C=Y.subSurface,q={transmissionFactor:0===C.refractionIntensity?void 0:C.refractionIntensity};if(this._hasTexturesExtension(Y)&&this._exporter._materialNeedsUVsSet.add(Y),C.refractionIntensityTexture)if(C.useGltfStyleTextures){const P=await this._exporter._materialExporter.exportTextureAsync(C.refractionIntensityTexture,"image/png");P&&(q.transmissionTexture=P)}else x.e.Warn(`${P}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);f.extensions||(f.extensions={}),f.extensions[sf]=q}return f}}tP.RegisterExtension(sf,(P=>new af(P)));const Qf="KHR_materials_unlit";class Jf{constructor(){this.name=Qf,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(P,f,Y){return new Promise((P=>{let C=!1;Y instanceof uP.d?C=Y.unlit:Y instanceof gP.Uf&&(C=Y.disableLighting),C&&(this._wasUsed=!0,null==f.extensions&&(f.extensions={}),f.extensions[Qf]={}),P(f)}))}}tP.RegisterExtension(Qf,(()=>new Jf));const Nf="KHR_materials_volume";class If{constructor(P){this.name=Nf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,f,Y){const C=[];return Y instanceof uP.d&&this._isExtensionEnabled(Y)?(Y.subSurface.thicknessTexture&&C.push(Y.subSurface.thicknessTexture),C):C}_isExtensionEnabled(P){if(P.unlit)return!1;const f=P.subSurface;return!(!f.isRefractionEnabled&&!f.isTranslucencyEnabled)&&(void 0!=f.maximumThickness&&0!=f.maximumThickness||void 0!=f.tintColorAtDistance&&f.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=f.tintColor&&f.tintColor!=S.Df.White()||this._hasTexturesExtension(P))}_hasTexturesExtension(P){return null!=P.subSurface.thicknessTexture}postExportMaterialAsync(P,f,Y){return new Promise((P=>{if(Y instanceof uP.d&&this._isExtensionEnabled(Y)){this._wasUsed=!0;const P=Y.subSurface,C={thicknessFactor:0==P.maximumThickness?void 0:P.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(P.thicknessTexture)??void 0,attenuationDistance:P.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:P.tintColorAtDistance,attenuationColor:P.tintColor.equalsFloats(1,1,1)?void 0:P.tintColor.If()};this._hasTexturesExtension(Y)&&this._exporter._materialNeedsUVsSet.add(Y),f.extensions=f.extensions||{},f.extensions[Nf]=C}P(f)}))}}tP.RegisterExtension(Nf,(P=>new If(P)));const Xf="EXT_materials_diffuse_roughness";class xf{constructor(P){this.name=Xf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,f,Y){const C=[];return Y instanceof df.e&&Y._baseDiffuseRoughness?(Y._baseDiffuseRoughnessTexture&&C.push(Y._baseDiffuseRoughnessTexture),C):[]}postExportMaterialAsync(P,f,Y){return new Promise((P=>{if(Y instanceof df.e){if(!Y._baseDiffuseRoughness)return void P(f);this._wasUsed=!0,f.extensions=f.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(Y._baseDiffuseRoughnessTexture),q={diffuseRoughnessFactor:Y._baseDiffuseRoughness,diffuseRoughnessTexture:C??void 0};null!==q.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(Y),f.extensions[Xf]=q}P(f)}))}}tP.RegisterExtension(Xf,(P=>new xf(P)));const kf="KHR_texture_transform";class Zf{constructor(){this.name=kf,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(P,f,Y){if(Y.vP()||q.Tools.Warn(`${P}: /*@__KEY__*/"scene" is not defined for Babylon texture ${Y.name}!`),(0!==Y.uAng||0!==Y.vAng)&&(q.Tools.Warn(`${P}: Texture ${Y.name} with rotation in the u or v axis is not supported in glTF.`),0!==Y.uRotationCenter||0!==Y.vRotationCenter))return;const C={};let m=!1;if(0===Y.uOffset&&0===Y.vOffset||(C.offset=[Y.uOffset,Y.vOffset],m=!0),1===Y.uScale&&1===Y.vScale||(C.scale=[Y.uScale,Y.vScale],m=!0),0!==Y.wAng){if(0!==Y.uRotationCenter||0!==Y.vRotationCenter){if(Y.homogeneousRotationInUVTransform&&Y.uScale!==Y.vScale)return void q.Tools.Warn(`${P}: Texture ${Y.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${kf}.`);q.Tools.Warn(`${P}: Texture ${Y.name} with non-origin rotation center will be exported using an adjusted offset with ${kf}.`),C.offset=function(P){const{uOffset:f,vOffset:Y,uRotationCenter:C,vRotationCenter:q,uScale:m,vScale:L,wAng:o}=P,w=Math.cos(o),d=Math.sin(o),R=C*m,y=q*L;return[f+(R*(1-w)+y*d),Y+(y*(1-w)-R*d)]}(Y)}C.rotation=-Y.wAng,m=!0}0!==Y.coordinatesIndex&&(C.texCoord=Y.coordinatesIndex,m=!0),m&&(this._wasUsed=!0,f.extensions||(f.extensions={}),f.extensions[kf]=C)}}tP.RegisterExtension(kf,(()=>new Zf));class Af{static CreateSTL(P){let f=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],m=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],L=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],w=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const d=function(P,f,Y){const q=[3*P[Y],3*P[Y+1],3*P[Y+2]],m=[new C.Of(f[q[0]],f[q[0]+2],f[q[0]+1]),new C.Of(f[q[1]],f[q[1]+2],f[q[1]+1]),new C.Of(f[q[2]],f[q[2]+2],f[q[2]+1])],L=m[0].nf(m[1]),o=m[2].nf(m[1]);return{v:m,n:C.Of.Cross(o,L).normalize()}},y=function(P,f,Y,C){return f=r(P,f,Y.x,C),f=r(P,f,Y.y,C),r(P,f,Y.z,C)},r=function(P,f,Y,C){return P.setFloat32(f,Y,C),f+4},u=function(P){if(o){let f=P;P instanceof i.b&&(f=P.sourceMesh);const Y=f.getVerticesData(R.d.PositionKind,!0,!0);if(!Y)return[];const q=C.Of.Zero();let m;for(m=0;m<Y.length;m+=3)C.Of.TransformCoordinatesFromFloatsToRef(Y[m],Y[m+1],Y[m+2],P.XC(!0),q).toArray(Y,m);return Y}return P.getVerticesData(R.d.PositionKind)||[]};o&&(L=!0);let g="",S=0,K=0;if(q){for(let Y=0;Y<P.length;Y++){const f=P[Y].eq();S+=f?f.length/3:0}const f=new ArrayBuffer(84+50*S);g=new DataView(f),K+=80,g.setUint32(K,S,m),K+=4}else w||(g="solid stlmesh\r\n");for(let C=0;C<P.length;C++){const f=P[C];!q&&w&&(g+="solid "+f.name+"\r\n"),!L&&f instanceof MP.c&&f.bakeCurrentTransformIntoVertices();const Y=u(f),o=f.eq()||[];for(let P=0;P<o.length;P+=3){const f=d(o,Y,P);q?(K=y(g,K,f.n,m),K=y(g,K,f.v[0],m),K=y(g,K,f.v[1],m),K=y(g,K,f.v[2],m),K+=2):(g+="\tfacet normal "+f.n.x+" "+f.n.y+" "+f.n.z+"\r\n",g+="\t\touter loop\r\n",g+="\t\t\tvertex "+f.v[0].x+" "+f.v[0].y+" "+f.v[0].z+"\r\n",g+="\t\t\tvertex "+f.v[1].x+" "+f.v[1].y+" "+f.v[1].z+"\r\n",g+="\t\t\tvertex "+f.v[2].x+" "+f.v[2].y+" "+f.v[2].z+"\r\n",g+="\t\tendloop\r\n",g+="\tendfacet\r\n")}!q&&w&&(g+="endsolid "+name+"\r\n")}if(q||w||(g+="endsolid stlmesh"),f){const P=document.createElement("a"),f=new Blob([g],{type:"application/octet-stream"});P.href=window.URL.createObjectURL(f),P.download=Y+".stl",P.click()}return g}}function Ef(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const C=[];for(let q=0;q<P.length/Y;q++){const m=P[q*Y],L=P[q*Y+1],o=P[q*Y+2];C.push(`(${m.toPrecision(f.precision)}, ${L.toPrecision(f.precision)}, ${o.toPrecision(f.precision)})`)}return C.join(", ")}function tf(P,f){const Y=[];for(let C=0;C<P.length/2;C++){const q=P[2*C],m=P[2*C+1];Y.push(`(${q.toPrecision(f.precision)}, ${(1-m).toPrecision(f.precision)})`)}return Y.join(", ")}function Gf(P,f){const Y=P.getVerticesData(R.d.PositionKind),C=P.getVerticesData(R.d.NormalKind);if(Y&&C)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(P){var f;const Y=null!==(f=P.eq())&&void 0!==f&&f.length?P.getTotalIndices():P.getTotalVertices();return Array(Y/3).fill(3).join(", ")}(P)}]\n\t\tint[] faceVertexIndices = [${function(P){const f=P.eq(),Y=[];if(null!==f)for(let C=0;C<f.length;C++)Y.push(f[C]);else{const f=P.getTotalVertices();for(let P=0;P<f;P++)Y.push(P)}return Y.join(", ")}(P)}]\n\t\tnormal3f[] normals = [${Ef(C,f)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Ef(Y,f)}]\n        ${function(P,f){let Y="";for(let q=0;q<4;q++){const C=q>0?q:"",m=P.getVerticesData(R.d.UVKind+(C?C+1:""));m&&(Y+=`\n\t\ttexCoord2f[] primvars:st${C} = [${tf(m,f)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const C=P.getVerticesData(R.d.ColorKind);return C&&(Y+=`\n\tcolor3f[] primvars:displayColor = [${Ef(C,f,C.length/P.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),Y}(P,f)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function zf(P,f){return`\n        def "Geometry"\n        {\n        ${Gf(P,f)}\n        }\n        `}function Bf(P){let f='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return f+=P,fflate.strToU8(f)}function bf(P){const f=P.m;return`( ${Hf(f,0)}, ${Hf(f,4)}, ${Hf(f,8)}, ${Hf(f,12)} )`}function Hf(P,f){return`(${P[f+0]}, ${P[f+1]}, ${P[f+2]}, ${P[f+3]})`}function Wf(P){const f="Object_"+P.uniqueId,Y=function(P){const f=P.getWorldMatrix().clone(),Y=P.vP().useRightHandedSystem;if(!Y){let C=P.parent;for(;C;){if(LP(C,Y)){f.multiplyToRef(C.getWorldMatrix().invert(),f);break}C=C.parent}}return f.determinant()<0&&q.Tools.Warn(`Exporting mesh ${P.name} with negative scale. Result may look incorrect in destination engine.`),f}(P),C=bf(Y);return`def Xform "${f}" (\n\tprepend references = @./geometries/Geometry_${P.qq.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${C}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${P.material.uniqueId}>\n}\n\n`}function pf(P){switch(P){case v.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case v.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case v.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function hf(P){return`(${P.x}, ${P.y})`}function Ff(P){return`(${P.r}, ${P.g}, ${P.b})`}function PY(P,f,Y,q,m,L){const o=P.getInternalTexture().uniqueId+"_"+P.invertY;m[o]=P;const w=P.coordinatesIndex>0?"st"+P.coordinatesIndex:"st",d=new C.Vector2(P.uScale,P.vScale),R=new C.Vector2(P.uOffset,P.vOffset),y=P.wAng,r=Math.sin(y),i=Math.cos(y);return R.y=1-R.y-d.y,R.x+=r*d.x,R.y+=(1-i)*d.y,`\n    def Shader "PrimvarReader_${Y}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${w}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${Y}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${f.uniqueId}/PrimvarReader_${Y}.outputs:result>\n        float inputs:rotation = ${(y*(180/Math.PI)).toFixed(L.precision)}\n        float2 inputs:scale = ${hf(d)}\n        float2 inputs:translation = ${hf(R)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${P.uniqueId}_${Y}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${o}.png@\n        float2 inputs:st.connect = </Materials/Material_${f.uniqueId}/Transform2d_${Y}.outputs:result>\n        ${q?"float4 inputs:scale = "+function(P){return`(${P.r}, ${P.g}, ${P.b}, 1.0)`}(q):""}\n        token inputs:sourceColorSpace = "${P.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${pf(P.wrapU)}"\n        token inputs:wrapT = "${pf(P.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${f.needAlphaBlending()?"float outputs:a":""}\n    }`}function fY(P,f,Y){const C="\t\t\t",q=[],m=[],{diffuseMap:L,Ko:o,alphaCutOff:w,emissiveMap:d,emissive:R,normalMap:y,roughnessMap:r,roughnessChannel:i,roughness:u,metalnessMap:g,metalnessChannel:K,metalness:M,aoMap:V,aoMapChannel:O,aoMapIntensity:n,alphaMap:l,ior:v,clearCoatEnabled:c,clearCoat:T,clearCoatMap:U,clearCoatRoughness:D,clearCoatRoughnessMap:j}=function(P){const f={diffuseMap:null,Ko:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return P instanceof gP.Uf?{...f,diffuseMap:P.diffuseTexture,Ko:P.diffuseColor,alphaCutOff:P.alphaCutOff,emissiveMap:P.emissiveTexture,emissive:P.emissiveColor,roughness:1,alphaMap:P.opacityTexture}:P instanceof df.e?{...f,diffuseMap:P._albedoTexture,Ko:P._albedoColor,alphaCutOff:P._alphaCutOff,emissiveMap:P._emissiveTexture,emissive:P._emissiveColor,normalMap:P._bumpTexture,roughnessMap:P._metallicTexture,roughnessChannel:P._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:P._roughness??1,metalnessMap:P._metallicTexture,metalnessChannel:P._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:P._metallic??0,aoMap:P._ambientTexture,aoMapChannel:P._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:P._ambientTextureStrength,alphaMap:P._opacityTexture,ior:P.subSurface.indexOfRefraction,clearCoatEnabled:P.clearCoat.isEnabled,clearCoat:P.clearCoat.So,clearCoatMap:P.clearCoat.texture,clearCoatRoughness:P.clearCoat.roughness,clearCoatRoughnessMap:P.clearCoat.useRoughnessFromMainTexture?P.clearCoat.texture:P.clearCoat.textureRoughness}:f}(P);return null!==L?(q.push(`${C}color3f inputs:diffuseColor.connect = </Materials/Material_${P.uniqueId}/Texture_${L.uniqueId}_diffuse.outputs:rgb>`),P.needAlphaBlending()?q.push(`${C}float inputs:opacity.connect = </Materials/Material_${P.uniqueId}/Texture_${L.uniqueId}_diffuse.outputs:a>`):P.needAlphaTesting()&&(q.push(`${C}float inputs:opacity.connect = </Materials/Material_${P.uniqueId}/Texture_${L.uniqueId}_diffuse.outputs:a>`),q.push(`${C}float inputs:opacityThreshold = ${w}`)),m.push(PY(L,P,"diffuse",o,f,Y))):q.push(`${C}color3f inputs:diffuseColor = ${Ff(o||S.Df.White())}`),null!==d?(q.push(`${C}color3f inputs:emissiveColor.connect = </Materials/Material_${P.uniqueId}/Texture_${d.uniqueId}_emissive.outputs:rgb>`),m.push(PY(d,P,"emissive",R,f,Y))):R&&R.toLuminance()>0&&q.push(`${C}color3f inputs:emissiveColor = ${Ff(R)}`),null!==y&&(q.push(`${C}normal3f inputs:normal.connect = </Materials/Material_${P.uniqueId}/Texture_${y.uniqueId}_normal.outputs:rgb>`),m.push(PY(y,P,"normal",null,f,Y))),null!==V&&(q.push(`${C}float inputs:occlusion.connect = </Materials/Material_${P.uniqueId}/Texture_${V.uniqueId}_occlusion.outputs:${O}>`),m.push(PY(V,P,"occlusion",new S.Df(n,n,n),f,Y))),null!==r?(q.push(`${C}float inputs:roughness.connect = </Materials/Material_${P.uniqueId}/Texture_${r.uniqueId}_roughness.outputs:${i}>`),m.push(PY(r,P,"roughness",new S.Df(u,u,u),f,Y))):q.push(`${C}float inputs:roughness = ${u}`),null!==g?(q.push(`${C}float inputs:metallic.connect = </Materials/Material_${P.uniqueId}/Texture_${g.uniqueId}_metallic.outputs:${K}>`),m.push(PY(g,P,"metallic",new S.Df(M,M,M),f,Y))):q.push(`${C}float inputs:metallic = ${M}`),null!==l?(q.push(`${C}float inputs:opacity.connect = </Materials/Material_${P.uniqueId}/Texture_${l.uniqueId}_opacity.outputs:r>`),q.push(`${C}float inputs:opacityThreshold = 0.0001`),m.push(PY(l,P,"opacity",null,f,Y))):q.push(`${C}float inputs:opacity = ${P.alpha}`),c&&(null!==U?(q.push(`${C}float inputs:clearcoat.connect = </Materials/Material_${P.uniqueId}/Texture_${U.uniqueId}_clearcoat.outputs:r>`),m.push(PY(U,P,"clearcoat",new S.Df(T,T,T),f,Y))):q.push(`${C}float inputs:clearcoat = ${T}`),null!==j?(q.push(`${C}float inputs:clearcoatRoughness.connect = </Materials/Material_${P.uniqueId}/Texture_${j.uniqueId}_clearcoatRoughness.outputs:g>`),m.push(PY(j,P,"clearcoatRoughness",new S.Df(D,D,D),f,Y))):q.push(`${C}float inputs:clearcoatRoughness = ${D}`)),q.push(`${C}float inputs:ior = ${v}`),`\n\tdef Material "Material_${P.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${q.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${P.uniqueId}/PreviewSurface.outputs:surface>\n\n${m.join("\n")}\n\n\t}\n`}async function YY(P,f,Y){const m={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...f};"undefined"===typeof fflate&&await q.Tools.LoadScriptAsync(m.fflateUrl);const L={};L[m.modelFileName]=null;let o='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';o+=function(P){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===P.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${P.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${P.planeAnchoringAlignment}"`:""}\n            `}(m);const w={};for(const C of P.meshes){if(0===C.getTotalVertices())continue;const P=C,f=P.qq,d=P.material;if(!d||!f||Y&&!Y(P))continue;if(-1!==["Uf","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(d.getClassName())){const Y="geometries/Geometry_"+f.uniqueId+".usda";if(!(Y in L)){const P=zf(f,m);L[Y]=Bf(P)}d.uniqueId in w||(w[d.uniqueId]=d),o+=Wf(P)}else q.Tools.Warn("USDZExportAsync does not support this material type: "+d.getClassName())}P.activeCamera&&m.exportCamera&&(o+=function(P,f){const Y="Camera_"+P.uniqueId,q=bf(C.Matrix.RotationY(Math.PI).multiply(P.getWorldMatrix()));if(P.mode===v.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${Y}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${P.zf.toPrecision(f.precision)}, ${P.maxZ.toPrecision(f.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(P.orthoLeft||1)+Math.abs(P.orthoRight||1))).toPrecision(f.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(P.orthoTop||1)+Math.abs(P.orthoBottom||1))).toPrecision(f.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const C=P.getEngine().getAspectRatio(P),m=f.cameraSensorWidth||35;return`def Camera "${Y}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${P.zf.toPrecision(f.precision)}, ${P.maxZ.toPrecision(f.precision)})\n\t\t\tfloat focalLength = ${(m/(2*Math.tan(.5*P.fov))).toPrecision(f.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(m*C).toPrecision(f.precision)}\n\t\t\tfloat verticalAperture = ${(m/C).toPrecision(f.precision)}            \n\t\t}\n\t\n\t`}}(P.activeCamera,m)),o+="\n            }\n        }\n    }";const d={};o+=function(P,f,Y){const C=[];for(const q in P){const m=P[q];C.push(fY(m,f,Y))}return`\n    def "Materials"\n{\n${C.join("")}\n}\n\n`}(w,d,m),L[m.modelFileName]=fflate.strToU8(o);for(const C in d){const P=d[C],f=P.getSize(),Y=await P.readPixels();if(!Y)throw new Error("Texture data is not available");const q=await c.DumpTools.DumpDataAsync(f.width,f.height,Y,"image/png",void 0,!1,!0);L[`textures/Texture_${C}.png`]=new Uint8Array(q).slice()}let R=0;for(const C in L){const P=L[C];if(!P)continue;R+=34+C.length;const f=63&R;if(4!==f){const Y=new Uint8Array(64-f);L[C]=[P,{extra:{12345:Y}}]}R=P.length}return fflate.zipSync(L,{level:0})}}}]);