"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[26],{12876:(u,R,I)=>{I.r(R),I.d(R,{EXT_materials_diffuse_roughness:()=>kR,EXT_mesh_gpu_instancing:()=>mR,GLTF2Export:()=>Nu,GLTFData:()=>t,KHR_draco_mesh_compression:()=>IR,KHR_lights_punctual:()=>sR,KHR_materials_anisotropy:()=>SR,KHR_materials_clearcoat:()=>rR,KHR_materials_diffuse_transmission:()=>ER,KHR_materials_dispersion:()=>fR,KHR_materials_emissive_strength:()=>QR,KHR_materials_ior:()=>qR,KHR_materials_iridescence:()=>YR,KHR_materials_sheen:()=>oR,KHR_materials_specular:()=>hR,KHR_materials_transmission:()=>gR,KHR_materials_unlit:()=>pR,KHR_materials_volume:()=>ZR,KHR_texture_transform:()=>iR,OBJExport:()=>C,STLExport:()=>WR,USDZExportAsync:()=>RI,_ConvertToGLTFPBRMetallicRoughness:()=>v,_SolveMetallic:()=>g,__IGLTFExporterExtension:()=>D});var B=I(12481),U=I(12294),K=I(12796);class C{static OBJ(u,R,I,C){const D=[];let s=1,t=1;R&&(I||(I="mat"),D.push("mtllib "+I+".mtl"));for(let G=0;G<u.length;G++){const I=u[G],S=I.name||`mesh${G}}`;D.push(`o ${S}`);let b=null;if(C){const u=I.bD(!0);b=new B.Matrix,u.invertToRef(b),I.bakeTransformIntoVertices(u)}if(R){const u=I.material;u&&D.push("usemtl "+u.id)}const r=I.rD;if(!r){U.Tools.Warn("No geometry is present on the mesh");continue}const P=r.getVerticesData("position"),X=r.getVerticesData("normal"),E=r.getVerticesData("uv"),z=r.PD();let f=0,T=0;if(!P||!z){U.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const Q=u[0].eu().useRightHandedSystem?1:-1;for(let u=0;u<P.length;u+=3)D.push("v "+P[u]*Q+" "+P[u+1]+" "+P[u+2]),f++;if(null!=X)for(let u=0;u<X.length;u+=3)D.push("vn "+X[u]*Q+" "+X[u+1]+" "+X[u+2]);if(null!=E)for(let u=0;u<E.length;u+=2)D.push("vt "+E[u]+" "+E[u+1]),T++;const V=["","",""],q=(I.material||I.eu().defaultMaterial)._getEffectiveOrientation(I),[e,Y]=q===K.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let u=0;u<z.length;u+=3){const R=[String(z[u]+s),String(z[u+e]+s),String(z[u+Y]+s)],I=[String(z[u]+t),String(z[u+e]+t),String(z[u+Y]+t)],B=R,U=null!=E?I:V,K=null!=X?R:V;D.push("f "+B[0]+"/"+U[0]+"/"+K[0]+" "+B[1]+"/"+U[1]+"/"+K[1]+" "+B[2]+"/"+U[2]+"/"+K[2])}C&&b&&I.bakeTransformIntoVertices(b),s+=f,t+=T}return D.join("\n")}static MTL(u){const R=[],I=u.material;R.push("newmtl mat1"),R.push("  Ns "+I.specularPower.toFixed(4)),R.push("  Ni 1.5000"),R.push("  d "+I.alpha.toFixed(4)),R.push("  Tr 0.0000"),R.push("  Tf 1.0000 1.0000 1.0000"),R.push("  illum 2"),R.push("  Ka "+I.ambientColor.r.toFixed(4)+" "+I.ambientColor.g.toFixed(4)+" "+I.ambientColor.b.toFixed(4)),R.push("  Kd "+I.diffuseColor.r.toFixed(4)+" "+I.diffuseColor.g.toFixed(4)+" "+I.diffuseColor.b.toFixed(4)),R.push("  Ks "+I.specularColor.r.toFixed(4)+" "+I.specularColor.g.toFixed(4)+" "+I.specularColor.b.toFixed(4)),R.push("  Ke "+I.emissiveColor.r.toFixed(4)+" "+I.emissiveColor.g.toFixed(4)+" "+I.emissiveColor.b.toFixed(4));I.ambientTexture&&R.push("  map_Ka "+I.ambientTexture.name),I.diffuseTexture&&R.push("  map_Kd "+I.diffuseTexture.name),I.specularTexture&&R.push("  map_Ks "+I.specularTexture.name),I.bumpTexture&&R.push("  map_bump -imfchan z "+I.bumpTexture.name),I.opacityTexture&&R.push("  map_d "+I.opacityTexture.name);return R.join("\n")}}var D=0,s=I(12348);class t{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const u in this.files){const R=this.files[u],I=new Blob([R],{type:(0,s.h)(u)});U.Tools.Download(I,u)}}}var G=I(12549),S=I(12883),b=I(12890),r=I(12903),P=I(12593),X=I(12346),E=I(12518),z=I(12491);const f=z.HighestCommonFactor,T={...z,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:f};var Q=I(12693),V=I(12460),q=I(12937),e=I(12940),Y=I(12689);const M=1e-6,o=new E.fR(.04,.04,.04),j=1024,h=E.fR.White(),x=E.fR.Black();function g(u,R,I){if(R<o.r)return 0;const B=o.r,U=u*I/(1-o.r)+R-2*o.r,K=U*U-4*B*(o.r-R);return T.Clamp((-U+Math.sqrt(K))/(2*B),0,1)}function v(u){const R=u.diffuseColor.toLinearSpace(u.eu().getEngine().useExactSrgbConversions).scale(.5),I=u.alpha,U=function(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new B.Vector2(0,1),I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new B.Vector2(0,.1),U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new B.Vector2(0,.1),K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new B.Vector2(1300,.1);return function(u,R,I,B,U){return(1-u)*(1-u)*(1-u)*R+3*(1-u)*(1-u)*u*I+3*(1-u)*u*u*B+u*u*u*U}(Math.pow(u/K.x,.333333),R.y,I.y,U.y,K.y)}(T.Clamp(u.specularPower,0,j));return{baseColorFactor:[R.r,R.g,R.b,I],metallicFactor:0,roughnessFactor:U}}function p(u,R){R.needAlphaBlending()?u.alphaMode="BLEND":R.needAlphaTesting()&&(u.alphaMode="MASK",u.alphaCutoff=R.alphaCutOff)}function l(u,R,I){const B=new Uint8Array(u*R*4);for(let U=0;U<B.length;U+=4)B[U]=B[U+1]=B[U+2]=B[U+3]=255;return q.d.CreateRGBATexture(B,u,R,I)}function Z(u){if(u instanceof Uint8Array){const R=u.length,I=new Float32Array(u.length);for(let B=0;B<R;++B)I[B]=u[B]/255;return I}if(u instanceof Float32Array)return u;throw new Error("Unsupported pixel format!")}class c{constructor(u){this._exporter=u,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(u){return u?this._textureMap.get(u)??null:null}async exportStandardMaterialAsync(u,R,I){const B=v(u),K={name:u.name};if(null==u.XD||u.XD||(u.twoSidedLighting||U.Tools.Warn(u.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),K.doubleSided=!0),I){const I=[],U=u.diffuseTexture;U&&I.push(this.exportTextureAsync(U,R).then((u=>{u&&(B.baseColorTexture=u)})));const C=u.bumpTexture;C&&I.push(this.exportTextureAsync(C,R).then((u=>{u&&(K.normalTexture=u,1!==C.level&&(K.normalTexture.scale=C.level))})));const D=u.emissiveTexture;D&&(K.emissiveFactor=[1,1,1],I.push(this.exportTextureAsync(D,R).then((u=>{u&&(K.emissiveTexture=u)}))));const s=u.ambientTexture;s&&I.push(this.exportTextureAsync(s,R).then((u=>{if(u){const R={index:u.index};K.occlusionTexture=R}}))),I.length>0&&(this._exporter._materialNeedsUVsSet.add(u),await Promise.all(I))}(u.alpha<1||u.opacityTexture)&&(u.alphaMode===e.e.ALPHA_COMBINE?K.alphaMode="BLEND":U.Tools.Warn(u.name+": glTF 2.0 does not support alpha mode: "+u.alphaMode.toString())),u.emissiveColor&&!u.emissiveColor.equalsWithEpsilon(x,M)&&(K.emissiveFactor=u.emissiveColor.sD()),K.pbrMetallicRoughness=B,p(K,u),await this._finishMaterialAsync(K,u,R);const C=this._exporter._materials;return C.push(K),C.length-1}async _finishMaterialAsync(u,R,I){const B=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",u,R),U=[];for(const K of B)U.push(this.exportTextureAsync(K,I));await Promise.all(U),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",u,R)}async _getImageDataAsync(u,R,B,U){const K=e.e.TEXTURETYPE_UNSIGNED_BYTE,C=this._exporter._babylonScene,D=C.getEngine(),s=D.createRawTexture(u,R,B,e.e.TEXTUREFORMAT_RGBA,!1,!0,V.b.NEAREST_SAMPLINGMODE,null,K);D.isWebGPU?await I.e(51).then(I.bind(I,14940)):await I.e(52).then(I.bind(I,14949)),await Q.m.ApplyPostProcess("pass",s,C,K,e.e.TEXTURE_NEAREST_SAMPLINGMODE,e.e.TEXTUREFORMAT_RGBA);const t=await D._readTexturePixels(s,R,B);return await Y.DumpTools.DumpDataAsync(R,B,t,U,void 0,!0,!0)}_resizeTexturesToSameDimensions(u,R,I){const B=u?u.getSize():{width:0,height:0},U=R?R.getSize():{width:0,height:0};let K,C;return B.width<U.width?(K=u&&u instanceof V.b?Q.m.CreateResizedCopy(u,U.width,U.height,!0):l(U.width,U.height,I),C=R):B.width>U.width?(C=R&&R instanceof V.b?Q.m.CreateResizedCopy(R,B.width,B.height,!0):l(B.width,B.height,I),K=u):(K=u,C=R),{texture1:K,texture2:C}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(u,R,I,B){const U=new Array;if(!u&&!R)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const K=u?u.eu():R?R.eu():null;if(K){var C;const D=this._resizeTexturesToSameDimensions(u,R,K),s=null===(C=D.texture1)||void 0===C?void 0:C.getSize();let t,G;const S=s.width,b=s.height,r=await D.texture1.readPixels(),P=await D.texture2.readPixels();if(!r)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(t=Z(r),!P)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");G=Z(P);const X=G.byteLength,z=new Uint8Array(X),f=new Uint8Array(X),T=4,Q=x;let V=0,q=0;for(let u=0;u<b;++u)for(let R=0;R<S;++R){const B=(S*u+R)*T,U={diffuseColor:new E.fR(t[B],t[B+1],t[B+2]).toLinearSpace(K.getEngine().useExactSrgbConversions).multiply(I.diffuseColor),specularColor:new E.fR(G[B],G[B+1],G[B+2]).toLinearSpace(K.getEngine().useExactSrgbConversions).multiply(I.specularColor),glossiness:G[B+3]*I.glossiness},C=this._convertSpecularGlossinessToMetallicRoughness(U);Q.r=Math.max(Q.r,C.baseColor.r),Q.g=Math.max(Q.g,C.baseColor.g),Q.b=Math.max(Q.b,C.baseColor.b),V=Math.max(V,C.metallic),q=Math.max(q,C.roughness),f[B]=255*C.baseColor.r,f[B+1]=255*C.baseColor.g,f[B+2]=255*C.baseColor.b,f[B+3]=D.texture1.tD?255*t[B+3]:255,z[B]=0,z[B+1]=255*C.roughness,z[B+2]=255*C.metallic,z[B+3]=255}const e={baseColor:Q,metallic:V,roughness:q};let Y=!1,o=!1;for(let u=0;u<b;++u)for(let R=0;R<S;++R){const I=(S*u+R)*T;f[I]/=e.baseColor.r>M?e.baseColor.r:1,f[I+1]/=e.baseColor.g>M?e.baseColor.g:1,f[I+2]/=e.baseColor.b>M?e.baseColor.b:1;const B=E.fR.FromInts(f[I],f[I+1],f[I+2]).toGammaSpace(K.getEngine().useExactSrgbConversions);f[I]=255*B.r,f[I+1]=255*B.g,f[I+2]=255*B.b,B.equalsWithEpsilon(h,M)||(o=!0),z[I+1]/=e.roughness>M?e.roughness:1,z[I+2]/=e.metallic>M?e.metallic:1;E.fR.FromInts(255,z[I+1],z[I+2]).equalsWithEpsilon(h,M)||(Y=!0)}return Y&&U.push(this._getImageDataAsync(z,S,b,B).then((u=>{e.metallicRoughnessTextureData=u}))),o&&U.push(this._getImageDataAsync(f,S,b,B).then((u=>{e.baseColorTextureData=u}))),await Promise.all(U).then((()=>e))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(u){const R=this._getPerceivedBrightness(u.diffuseColor),I=this._getPerceivedBrightness(u.specularColor),B=1-this._getMaxComponent(u.specularColor),U=g(R,I,B),K=u.diffuseColor.scale(B/(1-o.r)/Math.max(1-U)),C=u.specularColor.XR(o.scale(1-U)).scale(1/Math.max(U));let D=E.fR.Lerp(K,C,U*U);D=D.clampToRef(0,1,D);return{baseColor:D,metallic:U,roughness:1-u.glossiness}}_getPerceivedBrightness(u){return u?Math.sqrt(.299*u.r*u.r+.587*u.g*u.g+.114*u.b*u.b):0}_getMaxComponent(u){return u?Math.max(u.r,Math.max(u.g,u.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(u,R,I,B){const U=[],K={baseColor:u._albedoColor,metallic:u._metallic,roughness:u._roughness};if(B){u._albedoTexture&&U.push(this.exportTextureAsync(u._albedoTexture,R).then((u=>{u&&(I.baseColorTexture=u)})));const B=u._metallicTexture;B&&U.push(this.exportTextureAsync(B,R).then((u=>{u&&(I.metallicRoughnessTexture=u)})))}return U.length>0&&(this._exporter._materialNeedsUVsSet.add(u),await Promise.all(U)),K}_getTextureSampler(u){const R={};if(!u||!(u instanceof V.b))return R;const I=this._getGLTFTextureWrapMode(u.wrapU);10497!==I&&(R.wrapS=I);const B=this._getGLTFTextureWrapMode(u.wrapV);switch(10497!==B&&(R.wrapT=B),u.samplingMode){case V.b.LINEAR_LINEAR:R.magFilter=9729,R.minFilter=9729;break;case V.b.LINEAR_NEAREST:R.magFilter=9729,R.minFilter=9728;break;case V.b.NEAREST_LINEAR:R.magFilter=9728,R.minFilter=9729;break;case V.b.NEAREST_LINEAR_MIPLINEAR:R.magFilter=9728,R.minFilter=9987;break;case V.b.NEAREST_NEAREST:R.magFilter=9728,R.minFilter=9728;break;case V.b.NEAREST_LINEAR_MIPNEAREST:R.magFilter=9728,R.minFilter=9985;break;case V.b.LINEAR_NEAREST_MIPNEAREST:R.magFilter=9729,R.minFilter=9984;break;case V.b.LINEAR_NEAREST_MIPLINEAR:R.magFilter=9729,R.minFilter=9986;break;case V.b.NEAREST_NEAREST_MIPLINEAR:R.magFilter=9728,R.minFilter=9986;break;case V.b.LINEAR_LINEAR_MIPLINEAR:R.magFilter=9729,R.minFilter=9987;break;case V.b.LINEAR_LINEAR_MIPNEAREST:R.magFilter=9729,R.minFilter=9985;break;case V.b.NEAREST_NEAREST_MIPNEAREST:R.magFilter=9728,R.minFilter=9984}return R}_getGLTFTextureWrapMode(u){switch(u){case V.b.WRAP_ADDRESSMODE:return 10497;case V.b.CLAMP_ADDRESSMODE:return 33071;case V.b.MIRROR_ADDRESSMODE:return 33648;default:return U.Tools.Error(`Unsupported Texture Wrap Mode ${u}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(u,R,I,B){const U={diffuseColor:u._albedoColor,specularColor:u._reflectivityColor,glossiness:u._microSurface},K=u._albedoTexture,C=u._reflectivityTexture,D=u._useMicroSurfaceFromReflectivityMapAlpha;if(C&&!D)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((K||C)&&B){this._exporter._materialNeedsUVsSet.add(u);const B=this._exportTextureSampler(K||C),D=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(K,C,U,R),s=this._exporter._textures;if(D.baseColorTextureData){const u=this._exportImage(`baseColor${s.length}`,R,D.baseColorTextureData);I.baseColorTexture=this._exportTextureInfo(u,B,null===K||void 0===K?void 0:K.coordinatesIndex)}if(D.metallicRoughnessTextureData){const u=this._exportImage(`metallicRoughness${s.length}`,R,D.metallicRoughnessTextureData);I.metallicRoughnessTexture=this._exportTextureInfo(u,B,null===C||void 0===C?void 0:C.coordinatesIndex)}return D}return this._convertSpecularGlossinessToMetallicRoughness(U)}async exportPBRMaterialAsync(u,R,I){const B={},U={name:u.name},K=u.isMetallicWorkflow();if(K){const R=u._albedoColor,I=u.alpha;R&&(B.baseColorFactor=[R.r,R.g,R.b,I])}const C=K?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(u,R,B,I):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(u,R,B,I);await this._setMetallicRoughnessPbrMaterialAsync(C,u,U,B,R,I),await this._finishMaterialAsync(U,u,R);const D=this._exporter._materials;return D.push(U),D.length-1}async _setMetallicRoughnessPbrMaterialAsync(u,R,I,B,K,C){if(p(I,R),u.baseColor.equalsWithEpsilon(h,M)&&T.WithinEpsilon(R.alpha,1,M)||(B.baseColorFactor=[u.baseColor.r,u.baseColor.g,u.baseColor.b,R.alpha]),null!=u.metallic&&1!==u.metallic&&(B.metallicFactor=u.metallic),null!=u.roughness&&1!==u.roughness&&(B.roughnessFactor=u.roughness),null==R.XD||R.XD||(R._twoSidedLighting||U.Tools.Warn(R.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),I.doubleSided=!0),C){const u=[],B=R._bumpTexture;B&&u.push(this.exportTextureAsync(B,K).then((u=>{u&&(I.normalTexture=u,1!==B.level&&(I.normalTexture.scale=B.level))})));const U=R._ambientTexture;U&&u.push(this.exportTextureAsync(U,K).then((u=>{if(u){const B={index:u.index,texCoord:u.texCoord,extensions:u.extensions};I.occlusionTexture=B;const U=R._ambientTextureStrength;U&&(B.strength=U)}})));const C=R._emissiveTexture;C&&u.push(this.exportTextureAsync(C,K).then((u=>{u&&(I.emissiveTexture=u)}))),u.length>0&&(this._exporter._materialNeedsUVsSet.add(R),await Promise.all(u))}const D=R._emissiveColor;D.equalsWithEpsilon(x,M)||(I.emissiveFactor=D.sD()),I.pbrMetallicRoughness=B}_getPixelsFromTextureAsync(u){return function(u){switch(u){case e.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case e.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case e.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case e.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case e.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case e.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case e.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case e.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case e.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case e.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case e.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case e.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case e.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case e.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case e.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case e.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case e.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case e.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case e.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case e.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case e.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(u.textureFormat)?(0,Q.j)(u,u._texture.width,u._texture.height):(u.textureType,e.e.TEXTURETYPE_UNSIGNED_BYTE,u.readPixels())}async exportTextureAsync(u,R){const I=this._exporter._extensionsPreExportTextureAsync("exporter",u,R);return I?await I.then((async I=>I?await this._exportTextureInfoAsync(I,R):await this._exportTextureInfoAsync(u,R))):await this._exportTextureInfoAsync(u,R)}async _exportTextureInfoAsync(u,R){let I=this._textureMap.get(u);if(!I){const B=await this._getPixelsFromTextureAsync(u);if(!B)return null;const K=this._exportTextureSampler(u),C=u.mimeType;if(C)switch(C){case"image/jpeg":case"image/png":case"image/webp":R=C;break;default:U.Tools.Warn(`Unsupported media type: ${C}. Exporting texture as PNG.`)}const D=this._internalTextureToImage,s=u.getInternalTexture().uniqueId;D[s]||(D[s]={});let t=D[s][R];if(void 0===t){const I=u.getSize();t=(async()=>{const U=await this._getImageDataAsync(B,I.width,I.height,R);return this._exportImage(u.name,R,U)})(),D[s][R]=t}I=this._exportTextureInfo(await t,K,u.coordinatesIndex),this._textureMap.set(u,I),this._exporter._extensionsPostExportTextures("exporter",I,u)}return I}_exportImage(u,R,I){const B=this._exporter._images;let K;if(this._exporter._shouldUseGlb){K={name:u,mimeType:R,bufferView:void 0};const B=this._exporter._bufferManager.createBufferView(new Uint8Array(I));this._exporter._bufferManager.setBufferView(K,B)}else{const C=u.replace(/\.\/|\/|\.\\|\\/g,"_"),D=function(u){switch(u){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(R);let s=C+D;B.some((u=>u.uri===s))&&(s=`${C}_${U.Tools.RandomId()}${D}`),K={name:u,uri:s},this._exporter._imageData[s]={data:I,mimeType:R}}return B.push(K),B.length-1}_exportTextureInfo(u,R,I){const B=this._exporter._textures;let U=B.findIndex((I=>I.sampler==R&&I.source===u));-1===U&&(U=B.length,B.push({source:u,sampler:R}));const K={index:U};return I&&(K.texCoord=I),K}_exportTextureSampler(u){const R=this._getTextureSampler(u),I=this._exporter._samplers,B=I.findIndex((u=>u.minFilter===R.minFilter&&u.magFilter===R.magFilter&&u.wrapS===R.wrapS&&u.wrapT===R.wrapT));return-1!==B?B:(I.push(R),I.length-1)}}var k=I(12560),w=I(12315),i=I(12946),W=I(12485);const a=B.PR.Zero(),A=B.Quaternion.Identity(),O=B.PR.One(),N=new B.PR(-1,1,1);function J(u,R){const{byteOffset:I,byteStride:B,type:U,normalized:K}=u,C=u.getSize(),D=R.reduce(((u,R)=>R.getTotalVertices()>u?R.getTotalVertices():u),-Number.MAX_VALUE);return{byteOffset:I,byteStride:B,componentCount:C,type:U,count:D*C,normalized:K,totalVertices:D,kind:u.getKind()}}function mu(u){switch(u){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function L(u){switch(u){case G.i.PositionKind:case G.i.NormalKind:case G.i.TangentKind:case G.i.ColorKind:case G.i.MatricesIndicesKind:case G.i.MatricesIndicesExtraKind:case G.i.MatricesWeightsKind:case G.i.MatricesWeightsExtraKind:case G.i.UVKind:case G.i.UV2Kind:case G.i.UV3Kind:case G.i.UV4Kind:case G.i.UV5Kind:case G.i.UV6Kind:return!0}return!1}function H(u){switch(u){case K.c.TriangleFillMode:return 4;case K.c.TriangleStripDrawMode:return 5;case K.c.TriangleFanDrawMode:return 6;case K.c.PointListDrawMode:case K.c.PointFillMode:return 0;case K.c.LineLoopDrawMode:return 2;case K.c.LineListDrawMode:return 1;case K.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${u}`)}function y(u){const R=Math.sqrt(u.x*u.x+u.y*u.y+u.z*u.z);R>0&&(u.x/=R,u.y/=R,u.z/=R)}function F(u){return u.x*=-1,u}function n(u){if(u.x*u.x+u.y*u.y>.5){const R=Math.abs(u.x),I=Math.abs(u.y);if(R>I){const I=Math.sign(u.x);u.x=R,u.y*=-I,u.z*=-I,u.w*=I}else{const R=Math.sign(u.y);u.x*=-R,u.y=I,u.z*=R,u.w*=-R}}else{const R=Math.abs(u.z),I=Math.abs(u.w);if(R>I){const I=Math.sign(u.z);u.x*=-I,u.y*=I,u.z=R,u.w*=-I}else{const R=Math.sign(u.w);u.x*=R,u.y*=-R,u.z*=-R,u.w=I}}return u}function d(u){u.ED(-u.z,u.w,u.x,-u.y)}function uu(u,R){const I=B.PR.FromArrayToRef(R.translation||[0,0,0],0,B.TmpVectors.PR[0]),U=B.Quaternion.FromArrayToRef(R.rotation||[0,0,0,1],0,B.TmpVectors.Quaternion[0]),K=B.Matrix.ComposeToRef(O,U,I,B.TmpVectors.Matrix[0]),C=B.PR.FromArrayToRef(u.translation||[0,0,0],0,B.TmpVectors.PR[2]),D=B.Quaternion.FromArrayToRef(u.rotation||[0,0,0,1],0,B.TmpVectors.Quaternion[1]),s=B.Matrix.ComposeToRef(O,D,C,B.TmpVectors.Matrix[1]);K.multiplyToRef(s,s),s.decompose(void 0,U,I),I.equalsWithEpsilon(a,W.c)?delete R.translation:R.translation=I.sD(),U.equalsWithEpsilon(A,W.c)?delete R.rotation:R.rotation=U.sD(),R.scale&&delete R.scale}function Ru(u,R){if(!(R instanceof S.e))return!1;if(!(1===R.getChildren().length&&0===u.getChildren().length&&u.parent===R))return!1;const I=u.eu(),B=u instanceof i.c&&!I.useRightHandedSystem?N:O;return!!R.zD.equalsWithEpsilon(B,W.c)||(w.b.Warn(`Cannot collapse node ${u.name} into parent node ${R.name} with modified scaling.`),!1)}function Iu(u){if(u instanceof Array){const R=new Float32Array(u);return new Uint8Array(R.buffer,R.byteOffset,R.byteLength)}return ArrayBuffer.isView(u)?new Uint8Array(u.buffer,u.byteOffset,u.byteLength):new Uint8Array(u)}function Bu(u,R){for(const[I,B]of Object.entries(u)){const U=R[I];(Array.isArray(B)&&Array.isArray(U)&&Uu(B,U)||B===U)&&delete u[I]}return u}function Uu(u,R){return u.length===R.length&&u.every(((u,I)=>u===R[I]))}const Ku=B.Matrix.Compose(new B.PR(-1,1,1),B.Quaternion.Identity(),B.PR.Zero());function Cu(u,R){if(!(u instanceof S.e))return!1;if(R){if(!u.getWorldMatrix().equalsWithEpsilon(B.Matrix.IdentityReadOnly,W.c))return!1}else{if(!u.getWorldMatrix().multiplyToRef(Ku,B.TmpVectors.Matrix[0]).equalsWithEpsilon(B.Matrix.IdentityReadOnly,W.c))return!1}return!(u instanceof b.b&&u.rD)}const Du=new Map([[Int8Array,(u,R,I)=>u.setInt8(R,I)],[Uint8Array,(u,R,I)=>u.setUint8(R,I)],[Uint8ClampedArray,(u,R,I)=>u.setUint8(R,I)],[Int16Array,(u,R,I)=>u.setInt16(R,I,!0)],[Uint16Array,(u,R,I)=>u.setUint16(R,I,!0)],[Int32Array,(u,R,I)=>u.setInt32(R,I,!0)],[Uint32Array,(u,R,I)=>u.setUint32(R,I,!0)],[Float32Array,(u,R,I)=>u.setFloat32(R,I,!0)],[Float64Array,(u,R,I)=>u.setFloat64(R,I,!0)]]);class su{writeTypedArray(u){this._checkGrowBuffer(u.byteLength);const R=Du.get(u.constructor);for(let I=0;I<u.length;I++)R(this._dataView,this._byteOffset,u[I]),this._byteOffset+=u.BYTES_PER_ELEMENT}constructor(u){this._data=new Uint8Array(u),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(u){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,u),this._byteOffset++}writeInt8(u){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,u),this._byteOffset++}writeInt16(u){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,u,!0),this._byteOffset+=2}writeUInt16(u){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,u,!0),this._byteOffset+=2}writeInt32(u){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,u,!0),this._byteOffset+=4}writeUInt32(u){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,u,!0),this._byteOffset+=4}writeFloat32(u){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,u,!0),this._byteOffset+=4}writeFloat64(u){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,u,!0),this._byteOffset+=8}_checkGrowBuffer(u){const R=this.byteOffset+u;if(R>this._data.byteLength){const u=new Uint8Array(2*R);u.set(this._data),this._data=u,this._dataView=new DataView(this._data.buffer)}}}function tu(u){return u%4===0?4:u%2===0?2:1}class Gu{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(u){let R=0;this._bufferViewToData.forEach((u=>{R+=u.byteLength}));const I=new su(R),B=Array.from(this._bufferViewToData.keys()).sort(((u,R)=>tu(R.byteLength)-tu(u.byteLength)));for(const U of B){U.byteOffset=I.byteOffset,u.push(U);const R=u.length-1,B=this.getPropertiesWithBufferView(U);for(const u of B)u.bufferView=R;I.writeTypedArray(this._bufferViewToData.get(U)),this._bufferViewToData.delete(U)}return I.getOutputData()}createBufferView(u,R){const I={buffer:0,byteOffset:void 0,byteLength:u.byteLength,byteStride:R};return this._bufferViewToData.set(I,u),I}createAccessor(u,R,I,B,U,K,C){this._verifyBufferView(u);const D={bufferView:void 0,componentType:I,count:B,type:R,min:null===K||void 0===K?void 0:K.min,max:null===K||void 0===K?void 0:K.max,normalized:C,byteOffset:U};return this.setBufferView(D,u),this._accessorToBufferView.set(D,u),D}setBufferView(u,R){this._verifyBufferView(R);this.getPropertiesWithBufferView(R).push(u)}removeBufferView(u){const R=this.getPropertiesWithBufferView(u);for(const I of R)void 0!==I.bufferView&&delete I.bufferView;this._bufferViewToData.delete(u),this._bufferViewToProperties.delete(u),this._accessorToBufferView.forEach(((R,I)=>{R===u&&(void 0!==I.byteOffset&&delete I.byteOffset,this._accessorToBufferView.delete(I))}))}getBufferView(u){const R=this._accessorToBufferView.get(u);return this._verifyBufferView(R),R}getPropertiesWithBufferView(u){return this._verifyBufferView(u),this._bufferViewToProperties.set(u,this._bufferViewToProperties.get(u)??[]),this._bufferViewToProperties.get(u)}getData(u){return this._verifyBufferView(u),this._bufferViewToData.get(u)}_verifyBufferView(u){if(void 0===u||!this._bufferViewToData.has(u))throw new Error(`BufferView ${u} not found in BufferManager.`)}}var Su,bu=I(12910),ru=I(12929),Pu=I(12952),Xu=I(12846),Eu=I(12982),zu=I(12995),fu=I(12907),Tu=I(12999);!function(u){u[u.INTANGENT=0]="INTANGENT",u[u.OUTTANGENT=1]="OUTTANGENT"}(Su||(Su={}));class Qu{static _IsTransformable(u){return u&&(u instanceof S.e||u instanceof bu.e||u instanceof Tu.d)}static _CreateNodeAnimation(u,R,I,B,K){if(this._IsTransformable(u)){const C=[],D=[],s=R.getKeys(),t=Qu._CalculateMinMaxKeyFrames(s),G=Qu._DeduceInterpolation(s,I,B),S=G.interpolationType,b=G.shouldBakeAnimation;if(b?Qu._CreateBakedAnimation(u,R,I,t.min,t.max,R.framePerSecond,K,C,D,t,B):"LINEAR"===S||"STEP"===S?Qu._CreateLinearOrStepAnimation(u,R,I,C,D,B):"CUBICSPLINE"===S?Qu._CreateCubicSplineAnimation(u,R,I,C,D,B):Qu._CreateBakedAnimation(u,R,I,t.min,t.max,R.framePerSecond,K,C,D,t,B),C.length&&D.length){return{inputs:C,outputs:D,samplerInterpolation:S,inputsMin:b?t.min:U.Tools.FloatRound(t.min/R.framePerSecond),inputsMax:b?t.max:U.Tools.FloatRound(t.max/R.framePerSecond)}}}return null}static _DeduceAnimationInfo(u){let R=null,I="VEC3",B=!1;const K=u.targetProperty.split(".");switch(K[0]){case"zD":R="scale";break;case"position":R="translation";break;case"rotation":I="VEC4",R="rotation";break;case"rotationQuaternion":I="VEC4",B=!0,R="rotation";break;case"influence":I="SCALAR",R="weights";break;default:U.Tools.Error(`Unsupported animatable property ${K[0]}`)}return R?{animationChannelTargetPath:R,dataAccessorType:I,useQuaternion:B}:(U.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(u,R,I,B,U,K,C,D,s,t,G){let S;if(Qu._IsTransformable(u)&&u.animations)for(const b of u.animations){if(G&&!G(b))continue;const U=Qu._DeduceAnimationInfo(b);U&&(S={name:b.name,samplers:[],channels:[]},Qu._AddAnimation(`${b.name}`,b.hasRunningRuntimeAnimations?R:S,u,b,U.dataAccessorType,U.animationChannelTargetPath,B,K,C,D,U.useQuaternion,s,t),S.samplers.length&&S.channels.length&&I.push(S))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(u,R,I,B,U,K,C,D,s,t,G){let S;if(u instanceof fu.b){const U=u.morphTargetManager;if(U)for(let b=0;b<U.numTargets;++b){const r=U.getTarget(b);for(const P of r.animations){if(G&&!G(P))continue;const r=new Eu.d(`${P.name}`,"influence",P.framePerSecond,P.dataType,P.loopMode,P.enableBlending),X=[],E=P.getKeys();for(let u=0;u<E.length;++u){const R=E[u];for(let u=0;u<U.numTargets;++u)u==b?X.push(R):X.push({frame:R.frame,value:0})}r.setKeys(X);const z=Qu._DeduceAnimationInfo(r);z&&(S={name:r.name,samplers:[],channels:[]},Qu._AddAnimation(P.name,P.hasRunningRuntimeAnimations?R:S,u,r,z.dataAccessorType,z.animationChannelTargetPath,B,K,C,D,z.useQuaternion,s,t,U.numTargets),S.samplers.length&&S.channels.length&&I.push(S))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(u,R,I,B,U,K,C,D,s){let t;if(u.animationGroups){const S=u.animationGroups;for(const b of S){const S=new Map,r=new Map,P=new Set,X=b.to-b.from;t={name:b.name,channels:[],samplers:[]};for(let R=0;R<b.targetedAnimations.length;++R){const X=b.targetedAnimations[R],E=X.target,z=X.animation;if(s&&!s(z))continue;const f=D.has(E);if(this._IsTransformable(E)||1===E.length&&this._IsTransformable(E[0])){const u=Qu._DeduceAnimationInfo(X.animation);if(u){const R=this._IsTransformable(E)?E:this._IsTransformable(E[0])?E[0]:null;R&&Qu._AddAnimation(`${z.name}`,t,R,z,u.dataAccessorType,u.animationChannelTargetPath,I,B,U,K,u.useQuaternion,C,f)}}else if(E instanceof zu.b||1===E.length&&E[0]instanceof zu.b){if(Qu._DeduceAnimationInfo(X.animation)){const R=E instanceof zu.b?E:E[0];if(R){const I=u.morphTargetManagers.find((u=>{for(let I=0;I<u.numTargets;++I)if(u.getTarget(I)===R)return!0;return!1}));if(I){const B=u.meshes.find((u=>u.morphTargetManager===I));var G;if(B)S.has(B)||S.set(B,new Map),null===(G=S.get(B))||void 0===G||G.set(R,z),P.add(B),r.set(B,z)}}}}}P.forEach((u=>{const R=u.morphTargetManager;let D=null;const s=[],G=r.get(u).getKeys(),P=G.length;for(let I=0;I<P;++I)for(let B=0;B<R.numTargets;++B){const U=R.getTarget(B),K=S.get(u);if(K){const R=K.get(U);R?(D||(D=new Eu.d(`${b.name}_${u.name}_MorphWeightAnimation`,"influence",R.framePerSecond,Eu.d.ANIMATIONTYPE_FLOAT,R.loopMode,R.enableBlending)),s.push(R.getKeys()[I])):s.push({frame:b.from+X/P*I,value:U.influence,inTangent:G[0].inTangent?0:void 0,outTangent:G[0].outTangent?0:void 0})}}D.setKeys(s);const E=Qu._DeduceAnimationInfo(D);E&&Qu._AddAnimation(`${b.name}_${u.name}_MorphWeightAnimation`,t,u,D,E.dataAccessorType,E.animationChannelTargetPath,I,B,U,K,E.useQuaternion,C,!1,null===R||void 0===R?void 0:R.numTargets)})),t.channels.length&&t.samplers.length&&R.push(t)}}}static _AddAnimation(u,R,I,U,K,C,D,s,t,G,S,b,r,P){const X=Qu._CreateNodeAnimation(I,U,C,S,b);let E,z,f,T,Q,V;if(X){if(P){let u=0,R=0;const I=[];for(;X.inputs.length>0;)R=X.inputs.shift(),u%P==0&&I.push(R),u++;X.inputs=I}const u=D.get(I),U=new Float32Array(X.inputs);E=s.createBufferView(U),z=s.createAccessor(E,"SCALAR",5126,X.inputs.length,void 0,{min:[X.inputsMin],max:[X.inputsMax]}),G.push(z),f=G.length-1;const t=new B.Quaternion,S=new B.PR,b=new B.PR,q=I instanceof bu.e,e=mu(K),Y=new Float32Array(X.outputs.length*e);X.outputs.forEach((function(u,R){let I=u;switch(C){case"translation":r&&(B.PR.FromArrayToRef(u,0,b),F(b),b.toArray(I));break;case"rotation":4===u.length?B.Quaternion.FromArrayToRef(u,0,t):(I=new Array(4),B.PR.FromArrayToRef(u,0,S),B.Quaternion.FromEulerVectorToRef(S,t)),r&&(n(t),q&&d(t)),t.toArray(I)}Y.set(I,R*e)})),E=s.createBufferView(Y),z=s.createAccessor(E,K,5126,X.outputs.length),G.push(z),T=G.length-1,Q={interpolation:X.samplerInterpolation,input:f,output:T},R.samplers.push(Q),V={sampler:R.samplers.length-1,target:{node:u,path:C}},R.channels.push(V)}}static _CreateBakedAnimation(u,R,I,K,C,D,s,t,G,S,b){let r;const P=B.Quaternion.Identity();let X,E=null,z=null,f=null,T=null,Q=null,V=null;S.min=U.Tools.FloatRound(K/D);const q=R.getKeys();for(let B=0,e=q.length;B<e;++B){if(V=null,f=q[B],B+1<e)if(T=q[B+1],f.value.equals&&f.value.equals(T.value)||f.value===T.value){if(0!==B)continue;V=f.frame}else V=T.frame;else{if(Q=q[B-1],f.value.equals&&f.value.equals(Q.value)||f.value===Q.value)continue;V=C}if(V)for(let B=f.frame;B<=V;B+=s){if(X=U.Tools.FloatRound(B/D),X===E)continue;E=X,z=X;const K={key:0,repeatCount:0,loopMode:R.loopMode};r=R._interpolate(B,K),Qu._SetInterpolatedValue(u,r,X,R,I,P,t,G,b)}}z&&(S.max=z)}static _ConvertFactorToVector3OrQuaternion(u,R,I,K,C){const D=Qu._GetBasePositionRotationOrScale(R,K,C),s=I.targetProperty.split("."),t=s?s[1]:"",G=C?B.Quaternion.TR(D).normalize():B.PR.TR(D);switch(t){case"x":case"y":case"z":G[t]=u;break;case"w":G.w=u;break;default:U.Tools.Error(`glTFAnimation: Unsupported component name "${t}"!`)}return G}static _SetInterpolatedValue(u,R,I,U,K,C,D,s,t){let G;D.push(I),"weights"!==K?(U.dataType===Eu.d.ANIMATIONTYPE_FLOAT&&(R=this._ConvertFactorToVector3OrQuaternion(R,u,U,K,t)),"rotation"===K?(t?C=R:(G=R,B.Quaternion.RotationYawPitchRollToRef(G.y,G.x,G.z,C)),s.push(C.sD())):(G=R,s.push(G.sD()))):s.push([R])}static _CreateLinearOrStepAnimation(u,R,I,B,U,K){for(const C of R.getKeys())B.push(C.frame/R.framePerSecond),Qu._AddKeyframeValue(C,R,U,I,u,K)}static _CreateCubicSplineAnimation(u,R,I,B,U,K){R.getKeys().forEach((function(C){B.push(C.frame/R.framePerSecond),Qu._AddSplineTangent(Su.INTANGENT,U,I,"CUBICSPLINE",C,K),Qu._AddKeyframeValue(C,R,U,I,u,K),Qu._AddSplineTangent(Su.OUTTANGENT,U,I,"CUBICSPLINE",C,K)}))}static _GetBasePositionRotationOrScale(u,R,I){let U;if("rotation"===R)if(I){U=(u.rotationQuaternion??B.Quaternion.Identity()).sD()}else{U=(u.rotation??B.PR.Zero()).sD()}else if("translation"===R){U=(u.position??B.PR.Zero()).sD()}else{U=(u.zD??B.PR.One()).sD()}return U}static _AddKeyframeValue(u,R,I,K,C,D){let s;const t=R.dataType;if(t===Eu.d.ANIMATIONTYPE_VECTOR3){let R=u.value.sD();if("rotation"===K){const u=B.PR.TR(R);R=B.Quaternion.RotationYawPitchRoll(u.y,u.x,u.z).sD()}I.push(R)}else if(t===Eu.d.ANIMATIONTYPE_FLOAT){if("weights"===K)I.push([u.value]);else if(s=this._ConvertFactorToVector3OrQuaternion(u.value,C,R,K,D),s){if("rotation"===K){const u=D?s:B.Quaternion.RotationYawPitchRoll(s.y,s.x,s.z).normalize();I.push(u.sD())}I.push(s.sD())}}else t===Eu.d.ANIMATIONTYPE_QUATERNION?I.push(u.value.normalize().sD()):U.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(u,R,I){let B,U,K=!1;if("rotation"===R&&!I)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let C=0,D=u.length;C<D;++C)if(U=u[C],U.inTangent||U.outTangent)if(B){if("CUBICSPLINE"!==B){B="LINEAR",K=!0;break}}else B="CUBICSPLINE";else if(B){if("CUBICSPLINE"===B||U.interpolation&&1===U.interpolation&&"STEP"!==B){B="LINEAR",K=!0;break}}else B=U.interpolation&&1===U.interpolation?"STEP":"LINEAR";return B||(B="LINEAR"),{interpolationType:B,shouldBakeAnimation:K}}static _AddSplineTangent(u,R,I,U,K,C){let D;const s=u===Su.INTANGENT?K.inTangent:K.outTangent;if("CUBICSPLINE"===U){if("rotation"===I)if(s)if(C)D=s.sD();else{const u=s;D=B.Quaternion.RotationYawPitchRoll(u.y,u.x,u.z).sD()}else D=[0,0,0,0];else D="weights"===I?s?[s]:[0]:s?s.sD():[0,0,0];R.push(D)}}static _CalculateMinMaxKeyFrames(u){let R=1/0,I=-1/0;return u.forEach((function(u){R=Math.min(R,u.frame),I=Math.max(I,u.frame)})),{min:R,max:I}}}function Vu(u,R,I,K,C,D){const s={attributes:{},influence:u.influence,name:u.name},t=R.rD;if(!t)return U.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),s;const S=D?-1:1,b=B.PR.Zero();let r=0,P=0;if(u.hasPositions){const K=u.getPositions(),D=t.getVerticesData(G.i.PositionKind);if(D){const u=new Float32Array(D.length),R=[1/0,1/0,1/0],U=[-1/0,-1/0,-1/0];P=D.length/3,r=0;for(let I=r;I<P;++I){const C=B.PR.TR(D,3*I);B.PR.TR(K,3*I).subtractToRef(C,b),b.x*=S,R[0]=Math.min(R[0],b.x),U[0]=Math.max(U[0],b.x),R[1]=Math.min(R[1],b.y),U[1]=Math.max(U[1],b.y),R[2]=Math.min(R[2],b.z),U[2]=Math.max(U[2],b.z),u[3*I]=b.x,u[3*I+1]=b.y,u[3*I+2]=b.z}const t=I.createBufferView(u,12),G=I.createAccessor(t,"VEC3",5126,K.length/3,0,{min:R,max:U});C.push(G),s.attributes.POSITION=C.length-1}else U.Tools.Warn(`Morph target positions for mesh ${R.name} were not exported. Mesh does not have position vertex data`)}if(u.hasNormals){const K=u.getNormals(),D=t.getVerticesData(G.i.NormalKind);if(D){const u=new Float32Array(D.length);P=D.length/3,r=0;for(let I=r;I<P;++I){const R=B.PR.TR(D,3*I).normalize();B.PR.TR(K,3*I).normalize().subtractToRef(R,b),u[3*I]=b.x*S,u[3*I+1]=b.y,u[3*I+2]=b.z}const R=I.createBufferView(u,12),U=I.createAccessor(R,"VEC3",5126,K.length/3,0);C.push(U),s.attributes.NORMAL=C.length-1}else U.Tools.Warn(`Morph target normals for mesh ${R.name} were not exported. Mesh does not have normals vertex data`)}if(u.hasTangents){const K=u.getTangents(),D=t.getVerticesData(G.i.TangentKind);if(D){P=D.length/4;const u=new Float32Array(3*P);r=0;for(let I=r;I<P;++I){const R=B.PR.TR(D,4*I);y(R);const U=B.PR.TR(K,3*I);y(U),U.subtractToRef(R,b),u[3*I]=b.x*S,u[3*I+1]=b.y,u[3*I+2]=b.z}const R=I.createBufferView(u,12),U=I.createAccessor(R,"VEC3",5126,P,0);C.push(U),s.attributes.TANGENT=C.length-1}else U.Tools.Warn(`Morph target tangents for mesh ${R.name} were not exported. Mesh does not have tangents vertex data`)}if(u.hasColors){const K=u.getColors(),D=t.getVerticesData(G.i.ColorKind),S=t.getVertexBuffer(G.i.ColorKind);if(D&&S){const u=S.getSize();P=D.length/u;const R=new Float32Array(P*u);r=0;for(let I=r;I<P;++I)if(3===u){const U=B.PR.TR(D,I*u);B.PR.TR(K,I*u).subtractToRef(U,b),R[3*I]=b.x,R[3*I+1]=b.y,R[3*I+2]=b.z}else if(4===u){const U=new B.Vector4,C=B.Vector4.TR(D,I*u);B.Vector4.TR(K,I*u).subtractToRef(C,U),R[4*I]=U.x,R[4*I+1]=U.y,R[4*I+2]=U.z,R[4*I+3]=U.w}else U.Tools.Warn(`Unsupported number of components for color attribute: ${u}`);const t=I.createBufferView(R,4*u),G=I.createAccessor(t,3===u?"VEC3":"VEC4",5126,P,0);C.push(G),s.attributes.COLOR_0=C.length-1}else U.Tools.Warn(`Morph target colors for mesh ${R.name} were not exported. Mesh does not have colors vertex data`)}return s}var qu=I(13002),eu=I(12865),Yu=I(12851),Mu=I(12433);class ou{}ou.DEFAULT_COLOR=E.fR.White(),ou.DEFAULT_WIDTH_ATTENUATED=1,ou.DEFAULT_WIDTH=.1;var ju=I(12681),hu=I(13010);class xu{static ConvertPoints(u,R){if(u.length&&Array.isArray(u)&&"number"===typeof u[0])return[u];if(u.length&&Array.isArray(u[0])&&"number"===typeof u[0][0])return u;if(u.length&&!Array.isArray(u[0])&&u[0]instanceof B.PR){const R=[];for(let I=0;I<u.length;I++){const B=u[I];R.push(B.x,B.y,B.z)}return[R]}if(u.length>0&&Array.isArray(u[0])&&u[0].length>0&&u[0][0]instanceof B.PR){const R=[],I=u;for(const u of I)R.push(u.flatMap((u=>[u.x,u.y,u.z])));return R}if(u instanceof Float32Array){if(null!==R&&void 0!==R&&R.floatArrayStride){const I=[],B=3*R.floatArrayStride;for(let R=0;R<u.length;R+=B){const U=new Array(B);for(let I=0;I<B;I++)U[I]=u[R+I];I.push(U)}return I}return[Array.from(u)]}if(u.length&&u[0]instanceof Float32Array){const R=[];for(const I of u)R.push(Array.from(I));return R}return[]}static OmitZeroLengthPredicate(u,R,I){const B=[];return R.XR(u).lengthSquared()>0&&B.push([u,R]),I.XR(R).lengthSquared()>0&&B.push([R,I]),u.XR(I).lengthSquared()>0&&B.push([I,u]),0===B.length?null:B}static OmitDuplicatesPredicate(u,R,I,B){const U=[];return xu._SearchInPoints(u,R,B)||U.push([u,R]),xu._SearchInPoints(R,I,B)||U.push([R,I]),xu._SearchInPoints(I,u,B)||U.push([I,u]),0===U.length?null:U}static _SearchInPoints(u,R,I){for(const C of I)for(let I=0;I<C.length;I++){var B,U,K;if(null!==(B=C[I])&&void 0!==B&&B.equals(u))if(null!==(U=C[I+1])&&void 0!==U&&U.equals(R)||null!==(K=C[I-1])&&void 0!==K&&K.equals(R))return!0}return!1}static MeshesToLines(u,R){const I=[];for(let U=0;U<u.length;U++){const K=u[U],C=K.getVerticesData(G.i.PositionKind),D=K.PD();if(C&&D)for(let u=0,s=0;u<D.length;u++){const t=3*D[s++],G=3*D[s++],S=3*D[s++],b=new B.PR(C[t],C[t+1],C[t+2]),r=new B.PR(C[G],C[G+1],C[G+2]),P=new B.PR(C[S],C[S+1],C[S+2]);if(R){const B=R(b,r,P,I,u,t,K,U,C,D);if(B)for(const u of B)I.push(u)}else I.push([b,r],[r,P],[P,b])}}return I}static ToVector3Array(u){if(Array.isArray(u[0])){const R=[],I=u;for(const u of I){const I=[];for(let R=0;R<u.length;R+=3)I.push(new B.PR(u[R],u[R+1],u[R+2]));R.push(I)}return R}const R=u,I=[];for(let U=0;U<R.length;U+=3)I.push(new B.PR(R[U],R[U+1],R[U+2]));return I}static ToNumberArray(u){return u.flatMap((u=>[u.x,u.y,u.z]))}static GetPointsCountInfo(u){const R=new Array(u.length);let I=0;for(let B=u.length;B--;)R[B]=u[B].length/3,I+=R[B];return{total:I,counts:R}}static GetLineLength(u){if(0===u.length)return 0;let R;R="number"===typeof u[0]?xu.ToVector3Array(u):u;const I=B.TmpVectors.PR[0];let U=0;for(let B=0;B<R.length-1;B++){const u=R[B];U+=R[B+1].subtractToRef(u,I).length()}return U}static GetLineLengthArray(u){const R=new Float32Array(u.length/3);let I=0;for(let B=0,U=u.length/3-1;B<U;B++){let U=u[3*B+0],K=u[3*B+1],C=u[3*B+2];U-=u[3*B+3],K-=u[3*B+4],C-=u[3*B+5];I+=Math.sqrt(U*U+K*K+C*C),R[B+1]=I}return R}static SegmentizeSegmentByCount(u,R,I){const U=[],K=R.XR(u),C=B.TmpVectors.PR[0];C.fD(I);const D=B.TmpVectors.PR[1];K.divideToRef(C,D);let s=u.clone();U.push(s);for(let B=0;B<I;B++)s=s.clone(),U.push(s.addInPlace(D));return U}static SegmentizeLineBySegmentLength(u,R){const I=u[0]instanceof B.PR?xu.GetLineSegments(u):"number"===typeof u[0]?xu.GetLineSegments(xu.ToVector3Array(u)):u,U=[];for(const B of I)if(B.length>R){const u=xu.SegmentizeSegmentByCount(B.point1,B.point2,Math.ceil(B.length/R));for(const R of u)U.push(R)}else U.push(B.point1),U.push(B.point2);return U}static SegmentizeLineBySegmentCount(u,R){const I="number"===typeof u[0]?xu.ToVector3Array(u):u,B=xu.GetLineLength(I)/R;return xu.SegmentizeLineBySegmentLength(I,B)}static GetLineSegments(u){const R=[];for(let I=0;I<u.length-1;I++){const B=u[I],U=u[I+1],K=U.XR(B).length();R.push({point1:B,point2:U,length:K})}return R}static GetMinMaxSegmentLength(u){const R=xu.GetLineSegments(u).sort((u=>u.length));return{min:R[0].length,max:R[R.length-1].length}}static GetPositionOnLineByVisibility(u,R,I){let U=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const K=R*I;let C=0,D=0;const s=u.length;for(let B=0;B<s;B++){if(K<=C+u[B].length){D=B;break}C+=u[B].length}const t=(K-C)/u[D].length;return u[D].point2.subtractToRef(u[D].point1,B.TmpVectors.PR[0]),B.TmpVectors.PR[1]=B.TmpVectors.PR[0].multiplyByFloats(t,t,t),U||B.TmpVectors.PR[1].addInPlace(u[D].point1),B.TmpVectors.PR[1].clone()}static GetCircleLinePoints(u,R){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:u,K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/R;const C=[];for(let D=0;D<=R;D++)C.push(new B.PR(Math.cos(D*K)*u,Math.sin(D*K)*U,I));return C}static GetBezierLinePoints(u,R,I,B){return ju.g.CreateQuadraticBezier(u,R,I,B).getPoints().flatMap((u=>[u.x,u.y,u.z]))}static GetArrowCap(u,R,I,B,U){let K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,C=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[u.clone(),u.add(R.multiplyByFloats(I,I,I))],widths:[B,U,K,C]}}static GetPointsFromText(u,R,I,B){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,K=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const C=[],D=(0,hu.b)(u,R,I,B);for(const s of D){for(const u of s.paths){const R=[],I=u.getPoints();for(const u of I)R.push(u.x,u.y,U);C.push(R)}if(K)for(const u of s.holes){const R=[],I=u.getPoints();for(const u of I)R.push(u.x,u.y,U);C.push(R)}}return C}static Color3toRGBAUint8(u){const R=new Uint8Array(4*u.length);for(let I=0,B=0;I<u.length;I++)R[B++]=255*u[I].r,R[B++]=255*u[I].g,R[B++]=255*u[I].b,R[B++]=255;return R}static CreateColorsTexture(u,R,I,B){const U=B.getEngine().getCaps().maxTextureSize??1,K=R.length>U?U:R.length,C=Math.ceil(R.length/U);C>1&&(R=[...R,...Array(K*C-R.length).fill(R[0])]);const D=xu.Color3toRGBAUint8(R),s=new q.d(D,K,C,P.c.TEXTUREFORMAT_RGBA,B,!1,!0,I);return s.name=u,s}static PrepareEmptyColorsTexture(u){if(!ou.EmptyColorsTexture){const R=new Uint8Array(4);ou.EmptyColorsTexture=new q.d(R,1,1,P.c.TEXTUREFORMAT_RGBA,u,!1,!1,q.d.NEAREST_NEAREST),ou.EmptyColorsTexture.name="grlEmptyColorsTexture"}return ou.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var u;null===(u=ou.EmptyColorsTexture)||void 0===u||u.dispose(),ou.EmptyColorsTexture=null}static BooleanToNumber(u){return u?1:0}}class gu extends Yu.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class vu extends eu.c{isCompatible(u){return!0}constructor(u,R,I){var U;I=I||{color:ou.DEFAULT_COLOR};const K=new gu;K.GREASED_LINE_HAS_COLOR=!!I.color&&!I.useColors,K.GREASED_LINE_SIZE_ATTENUATION=I.sizeAttenuation??!1,K.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===I.colorDistributionType,K.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(R??u.eu()).useRightHandedSystem,K.GREASED_LINE_CAMERA_FACING=I.cameraFacing??!0,super(u,vu.GREASED_LINE_MATERIAL_NAME,200,K,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(U=I)||void 0===U?void 0:U.forceGLSL)||vu.ForceGLSL,this._scene=R??u.eu(),this._engine=this._scene.getEngine(),this._cameraFacing=I.cameraFacing??!0,this.visibility=I.visibility??1,this.useDash=I.useDash??!1,this.dashRatio=I.dashRatio??.5,this.dashOffset=I.dashOffset??0,this.width=I.width?I.width:I.sizeAttenuation?ou.DEFAULT_WIDTH_ATTENUATED:ou.DEFAULT_WIDTH,this._sizeAttenuation=I.sizeAttenuation??!1,this.colorMode=I.colorMode??0,this._color=I.color??null,this.useColors=I.useColors??!1,this._colorsDistributionType=I.colorDistributionType??0,this.colorsSampling=I.colorsSampling??q.d.NEAREST_NEAREST,this._colors=I.ju??null,this.dashCount=I.dashCount??1,this.resolution=I.resolution??new B.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),I.colorsTexture?this.colorsTexture=I.colorsTexture:this._colors?this.colorsTexture=xu.CreateColorsTexture(`${u.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??ou.DEFAULT_COLOR,xu.PrepareEmptyColorsTexture(this._scene)),this._engine.uD.add((()=>{xu.DisposeEmptyColorsTexture()}))}getAttributes(u){u.push("grl_offsets"),u.push("grl_widths"),u.push("grl_colorPointers"),u.push("grl_counters"),this._cameraFacing?(u.push("grl_previousAndSide"),u.push("grl_nextAndCounters")):u.push("grl_slopes")}getSamplers(u){u.push("grl_colors")}getActiveTextures(u){this.colorsTexture&&u.push(this.colorsTexture)}getUniforms(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const R=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&R.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===u&&R.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:R,vertex:this._cameraFacing&&this._isGLSL(u)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(u)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(u){if(this._cameraFacing){u.SD("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||u.SD("viewProjection",this._scene.getTransformMatrix());const R=B.TmpVectors.Vector4[0];R.x=this._aspect,R.y=this._resolution.x,R.z=this._resolution.y,R.w=this.width,u.updateVector4("grl_aspect_resolution_lineWidth",R)}const R=B.TmpVectors.Vector4[0];R.x=xu.BooleanToNumber(this.useDash),R.y=this._dashArray,R.z=this.dashOffset,R.w=this.dashRatio,u.updateVector4("grl_dashOptions",R);const I=B.TmpVectors.Vector4[1];I.x=this.colorMode,I.y=this.visibility,I.z=this.colorsTexture?this.colorsTexture.getSize().width:0,I.w=xu.BooleanToNumber(this.useColors),u.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",I),this._color&&u.updateColor3("grl_singleColor",this._color);const U=this.colorsTexture??ou.EmptyColorsTexture;u.setTexture("grl_colors",U),u.updateFloat2("grl_textureSize",(null===U||void 0===U?void 0:U.getSize().width)??1,(null===U||void 0===U?void 0:U.getSize().height)??1)}prepareDefines(u,R,I){u.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,u.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,u.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,u.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=R.useRightHandedSystem,u.GREASED_LINE_CAMERA_FACING=this._cameraFacing,u.GREASED_LINE_USE_OFFSETS=!!I.offsets}getClassName(){return vu.GREASED_LINE_MATERIAL_NAME}getCustomCode(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(R)?function(u,R){if("vertex"===u){const u={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return R&&(u["!gl_Position\\=viewProjection\\*worldPos;"]="//"),u}return"fragment"===u?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(u,this._cameraFacing):function(u,R){if("vertex"===u){const u={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return R&&(u["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),u}return"fragment"===u?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(u,this._cameraFacing)}dispose(){var u;null===(u=this.colorsTexture)||void 0===u||u.dispose(),super.dispose()}get ju(){return this._colors}set ju(u){this.setColors(u)}setColors(u){var R;let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],B=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const U=(null===(R=this._colors)||void 0===R?void 0:R.length)??0;var K;if(this._colors=u,null!==u&&0!==u.length){if(!I||B)if(this.colorsTexture&&U===u.length&&!B){const R=xu.Color3toRGBAUint8(u);this.colorsTexture.update(R)}else{var C;null===(C=this.colorsTexture)||void 0===C||C.dispose(),this.colorsTexture=xu.CreateColorsTexture(`${this._material.name}-colors-texture`,u,this.colorsSampling,this._scene)}}else null===(K=this.colorsTexture)||void 0===K||K.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(u){this._dashCount=u,this._dashArray=1/u}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(u){this._sizeAttenuation=u,this.markAllDefinesAsDirty()}get color(){return this._color}set color(u){this.setColor(u)}setColor(u){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==u||null!==this._color&&null===u?(this._color=u,R||this.markAllDefinesAsDirty()):this._color=u}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(u){this._colorsDistributionType=u,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(u){this._aspect=u.x/u.y,this._resolution=u}serialize(){const u=super.serialize(),R={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(R.ju=this._colors),this._color&&(R.color=this._color),u.greasedLineMaterialOptions=R,u}parse(u,R,I){var B;super.parse(u,R,I);const U=u.greasedLineMaterialOptions;null===(B=this.colorsTexture)||void 0===B||B.dispose(),U.color&&this.setColor(U.color,!0),U.colorDistributionType&&(this.colorsDistributionType=U.colorDistributionType),U.ju&&(this.ju=U.ju),U.colorsSampling&&(this.colorsSampling=U.colorsSampling),U.colorMode&&(this.colorMode=U.colorMode),U.useColors&&(this.useColors=U.useColors),U.visibility&&(this.visibility=U.visibility),U.useDash&&(this.useDash=U.useDash),U.dashCount&&(this.dashCount=U.dashCount),U.dashRatio&&(this.dashRatio=U.dashRatio),U.dashOffset&&(this.dashOffset=U.dashOffset),U.width&&(this.width=U.width),U.sizeAttenuation&&(this.sizeAttenuation=U.sizeAttenuation),U.resolution&&(this.resolution=U.resolution),this.ju?this.colorsTexture=xu.CreateColorsTexture(`${this._material.name}-colors-texture`,this.ju,this.colorsSampling,R):xu.PrepareEmptyColorsTexture(R),this.markAllDefinesAsDirty()}copyTo(u){var R;const I=u;null===(R=I.colorsTexture)||void 0===R||R.dispose(),this._colors&&(I.colorsTexture=xu.CreateColorsTexture(`${I._material.name}-colors-texture`,this._colors,I.colorsSampling,this._scene)),I.setColor(this.color,!0),I.colorsDistributionType=this.colorsDistributionType,I.colorsSampling=this.colorsSampling,I.colorMode=this.colorMode,I.useColors=this.useColors,I.visibility=this.visibility,I.useDash=this.useDash,I.dashCount=this.dashCount,I.dashRatio=this.dashRatio,I.dashOffset=this.dashOffset,I.width=this.width,I.sizeAttenuation=this.sizeAttenuation,I.resolution=this.resolution,I.markAllDefinesAsDirty()}_isGLSL(u){return 0===u||this._forceGLSL}}vu.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",vu.ForceGLSL=!1,(0,Mu.e)(`BABYLON.${vu.GREASED_LINE_MATERIAL_NAME}`,vu);var pu=I(12892),lu=I(12320),Zu=I(12701),cu=I(12422);class ku extends Zu.ShaderMaterial{constructor(u,R,U){const K=R.getEngine(),C=K.isWebGPU&&!(U.forceGLSL||ku.ForceGLSL),D=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];R.useRightHandedSystem&&D.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const s=["position","grl_widths","grl_offsets","grl_colorPointers"];U.cameraFacing?(D.push("GREASED_LINE_CAMERA_FACING"),s.push("grl_previousAndSide","grl_nextAndCounters")):(s.push("grl_slopes"),s.push("grl_counters"));const t=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(C||t.push("world","viewProjection","view","projection"),super(u,R,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:C?["Scene","Mesh"]:void 0,attributes:s,uniforms:t,samplers:C?[]:["grlColors"],defines:D,extraInitializationsAsync:async()=>{C?await Promise.all([I.e(66).then(I.bind(I,15605)),I.e(75).then(I.bind(I,15608))]):await Promise.all([I.e(69).then(I.bind(I,15614)),I.e(76).then(I.bind(I,15616))])},shaderLanguage:C?1:0}),this._color=E.fR.White(),this._colorsDistributionType=0,this._colorsTexture=null,U=U||{color:ou.DEFAULT_COLOR},this.visibility=U.visibility??1,this.useDash=U.useDash??!1,this.dashRatio=U.dashRatio??.5,this.dashOffset=U.dashOffset??0,this.dashCount=U.dashCount??1,this.width=U.width?U.width:U.sizeAttenuation&&U.cameraFacing?ou.DEFAULT_WIDTH_ATTENUATED:ou.DEFAULT_WIDTH,this.sizeAttenuation=U.sizeAttenuation??!1,this.color=U.color??E.fR.White(),this.useColors=U.useColors??!1,this.colorsDistributionType=U.colorDistributionType??0,this.colorsSampling=U.colorsSampling??q.d.NEAREST_NEAREST,this.colorMode=U.colorMode??0,this._colors=U.ju??null,this._cameraFacing=U.cameraFacing??!0,this.resolution=U.resolution??new B.Vector2(K.getRenderWidth(),K.getRenderHeight()),U.colorsTexture?this.colorsTexture=U.colorsTexture:this._colors?this.colorsTexture=xu.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,R):(this._color=this._color??ou.DEFAULT_COLOR,this.colorsTexture=xu.PrepareEmptyColorsTexture(R)),C){const u=new cu.e;u.setParameters(),u.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",u)}K.uD.add((()=>{xu.DisposeEmptyColorsTexture()}))}dispose(){var u;null===(u=this._colorsTexture)||void 0===u||u.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new B.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get ju(){return this._colors}set ju(u){this.setColors(u)}setColors(u){var R;let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],B=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const U=(null===(R=this._colors)||void 0===R?void 0:R.length)??0;var K;if(this._colors=u,null!==u&&0!==u.length){if(!I||B)if(this._colorsTexture&&U===u.length&&!B){const R=xu.Color3toRGBAUint8(u);this._colorsTexture.update(R)}else{var C;null===(C=this._colorsTexture)||void 0===C||C.dispose(),this.colorsTexture=xu.CreateColorsTexture(`${this.name}-colors-texture`,u,this.colorsSampling,this.eu())}}else null===(K=this._colorsTexture)||void 0===K||K.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(u){this._colorsTexture=u,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(u){this._width=u,this.setFloat("grlWidth",u)}get useColors(){return this._useColors}set useColors(u){this._useColors=u,this.setFloat("grlUseColors",xu.BooleanToNumber(u))}get colorsSampling(){return this._colorsSampling}set colorsSampling(u){this._colorsSampling=u}get visibility(){return this._visibility}set visibility(u){this._visibility=u,this.setFloat("grlVisibility",u)}get useDash(){return this._useDash}set useDash(u){this._useDash=u,this.setFloat("grlUseDash",xu.BooleanToNumber(u))}get dashOffset(){return this._dashOffset}set dashOffset(u){this._dashOffset=u,this.setFloat("grlDashOffset",u)}get dashRatio(){return this._dashRatio}set dashRatio(u){this._dashRatio=u,this.setFloat("grlDashRatio",u)}get dashCount(){return this._dashCount}set dashCount(u){this._dashCount=u,this._dashArray=1/u,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(u){this._sizeAttenuation=u,this.setFloat("grlSizeAttenuation",xu.BooleanToNumber(u))}get color(){return this._color}set color(u){this.setColor(u)}setColor(u){u=u??ou.DEFAULT_COLOR,this._color=u,this.setColor3("grlColor",u)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(u){this._colorsDistributionType=u,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(u){this._colorMode=u,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(u){this._resolution=u,this.setVector2("grlResolution",u),this.setFloat("grlAspect",u.x/u.y)}serialize(){const u=super.serialize(),R={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(R.ju=this._colors),u.greasedLineMaterialOptions=R,u}parse(u,R,I){var B;const U=u.greasedLineMaterialOptions;null===(B=this._colorsTexture)||void 0===B||B.dispose(),U.color&&(this.color=U.color),U.colorDistributionType&&(this.colorsDistributionType=U.colorDistributionType),U.colorsSampling&&(this.colorsSampling=U.colorsSampling),U.colorMode&&(this.colorMode=U.colorMode),U.useColors&&(this.useColors=U.useColors),U.visibility&&(this.visibility=U.visibility),U.useDash&&(this.useDash=U.useDash),U.dashCount&&(this.dashCount=U.dashCount),U.dashRatio&&(this.dashRatio=U.dashRatio),U.dashOffset&&(this.dashOffset=U.dashOffset),U.width&&(this.width=U.width),U.sizeAttenuation&&(this.sizeAttenuation=U.sizeAttenuation),U.resolution&&(this.resolution=U.resolution),U.ju?this.colorsTexture=xu.CreateColorsTexture(`${this.name}-colors-texture`,U.ju,this.colorsSampling,this.eu()):this.colorsTexture=xu.PrepareEmptyColorsTexture(R),this._cameraFacing=U.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var wu,iu,Wu;ku.ForceGLSL=!1,function(u){u[u.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",u[u.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(wu||(wu={})),function(u){u[u.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",u[u.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",u[u.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(iu||(iu={})),function(u){u[u.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",u[u.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",u[u.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",u[u.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",u[u.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Wu||(Wu={}));class au extends fu.b{constructor(u,R,I){super(u,R,null,null,!1,!1),this.name=u,this._options=I,this._lazy=!1,this._updatable=!1,this._engine=R.getEngine(),this._lazy=I.lazy??!1,this._updatable=I.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=I.colorPointers??[],this._widths=I.widths??new Array(I.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(u){let R=0;for(const B of this._points)R+=B.length;const I=R/3*2-this._widths.length;for(let B=0;B<I;B++)this._widths.push(u)}updateLazy(){var u,R;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(u=this._options.ribbonOptions)||void 0===u?void 0:u.smoothShading),!this.vu&&this.refreshBoundingInfo(),null===(R=this.greasedLineMaterial)||void 0===R||R.updateLazy()}addPoints(u,R){for(const I of u)this._points.push(I);this._lazy||this.setPoints(this._points,R)}dispose(u){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(u,R)}isLazy(){return this._lazy}get hu(){return this._uvs}set hu(u){this._uvs=u instanceof Float32Array?u:new Float32Array(u),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(u){this.material instanceof ku&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===u||void 0===u?void 0:u.length)>0),this._offsets=u,this._offsetsBuffer?this._offsetsBuffer.update(u):this._createOffsetsBuffer(u)}get widths(){return this._widths}set widths(u){this._widths=u,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(u)}get colorPointers(){return this._colorPointers}set colorPointers(u){this._colorPointers=u,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(u)}get greasedLineMaterial(){var u,R;if(this.material&&this.material instanceof ku)return this.material;const I=null===(u=this.material)||void 0===u||null===(R=u.pluginManager)||void 0===R?void 0:R.getPlugin(vu.GREASED_LINE_MATERIAL_NAME);return I||void 0}get points(){const u=[];return lu.d.DeepCopy(this._points,u),u}setPoints(u,R){this._points=xu.ConvertPoints(u,(null===R||void 0===R?void 0:R.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==R&&void 0!==R&&R.colorPointers||this._updateColorPointers(),this._setPoints(this._points,R)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,hu:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(u){super.serialize(u),u.type=this.getClassName(),u.lineOptions=this._createLineOptions()}_createVertexBuffers(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const R=new pu.b;return R.Mu=this._vertexPositions,R.indices=this._indices,R.hu=this._uvs,u&&(R.ou=[],pu.b.ComputeNormals(this._vertexPositions,this._indices,R.ou)),R.gu(this,this._options.updatable),R}_createOffsetsBuffer(u){const R=this._scene.getEngine(),I=new G.e(R,u,this._updatable,3);this.setVerticesBuffer(I.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=I}}class Au{constructor(u,R){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=u,this.wasAddedByNoopNode=R}getIndicesAccessor(u,R,I,B,U){var K,C,D,s;return null===(K=this._indicesAccessorMap.get(u))||void 0===K||null===(C=K.get(R))||void 0===C||null===(D=C.get(I))||void 0===D||null===(s=D.get(B))||void 0===s?void 0:s.get(U)}setIndicesAccessor(u,R,I,B,U,K){let C=this._indicesAccessorMap.get(u);C||(C=new Map,this._indicesAccessorMap.set(u,C));let D=C.get(R);D||(D=new Map,C.set(R,D));let s=D.get(I);s||(s=new Map,D.set(I,s));let t=s.get(B);t||(t=new Map,s.set(B,t)),t.set(U,K)}pushExportedNode(u){this._exportedNodes.has(u)||this._exportedNodes.add(u)}getNodesSet(){return this._exportedNodes}getVertexBufferView(u){return this._vertexBufferViewMap.get(u)}setVertexBufferView(u,R){this._vertexBufferViewMap.set(u,R)}setRemappedBufferView(u,R,I){this._remappedBufferView.set(u,new Map),this._remappedBufferView.get(u).set(R,I)}getRemappedBufferView(u,R){var I;return null===(I=this._remappedBufferView.get(u))||void 0===I?void 0:I.get(R)}getVertexAccessor(u,R,I){var B,U;return null===(B=this._vertexAccessorMap.get(u))||void 0===B||null===(U=B.get(R))||void 0===U?void 0:U.get(I)}setVertexAccessor(u,R,I,B){let U=this._vertexAccessorMap.get(u);U||(U=new Map,this._vertexAccessorMap.set(u,U));let K=U.get(R);K||(K=new Map,U.set(R,K)),K.set(I,B)}hasVertexColorAlpha(u){return this._vertexMapColorAlpha.get(u)||!1}setHasVertexColorAlpha(u,R){return this._vertexMapColorAlpha.set(u,R)}getMesh(u){return this._meshMap.get(u)}setMesh(u,R){this._meshMap.set(u,R)}bindMorphDataToMesh(u,R){const I=this._meshMorphTargetMap.get(u)||[];this._meshMorphTargetMap.set(u,I),-1===I.indexOf(R)&&I.push(R)}getMorphTargetsFromMesh(u){return this._meshMorphTargetMap.get(u)}}class Ou{_ApplyExtension(u,R,I,B){if(I>=R.length)return Promise.resolve(u);const U=B(R[I],u);return U?U.then((async u=>u?await this._ApplyExtension(u,R,I+1,B):null)):this._ApplyExtension(u,R,I+1,B)}_ApplyExtensions(u,R){const I=[];for(const B of Ou._ExtensionNames)I.push(this._extensions[B]);return this._ApplyExtension(u,I,0,R)}_extensionsPreExportTextureAsync(u,R,I){return this._ApplyExtensions(R,((R,B)=>R.preExportTextureAsync&&R.preExportTextureAsync(u,B,I)))}_extensionsPostExportNodeAsync(u,R,I,B,U){return this._ApplyExtensions(R,((R,K)=>R.postExportNodeAsync&&R.postExportNodeAsync(u,K,I,B,U,this._bufferManager)))}_extensionsPostExportMaterialAsync(u,R,I){return this._ApplyExtensions(R,((R,B)=>R.postExportMaterialAsync&&R.postExportMaterialAsync(u,B,I)))}_extensionsPostExportMaterialAdditionalTextures(u,R,I){const B=[];for(const U of Ou._ExtensionNames){const K=this._extensions[U];K.postExportMaterialAdditionalTextures&&B.push(...K.postExportMaterialAdditionalTextures(u,R,I))}return B}_extensionsPostExportTextures(u,R,I){for(const B of Ou._ExtensionNames){const U=this._extensions[B];U.postExportTexture&&U.postExportTexture(u,R,I)}}_extensionsPostExportMeshPrimitive(u){for(const R of Ou._ExtensionNames){const I=this._extensions[R];I.postExportMeshPrimitive&&I.postExportMeshPrimitive(u,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const u of Ou._ExtensionNames){const R=this._extensions[u];R.preGenerateBinaryAsync&&await R.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(u){for(const R of Ou._ExtensionNames){const I=this._extensions[R];I.enabled&&u(I)}}_extensionsOnExporting(){this._forEachExtensions((u=>{var R,I,B;u.wasUsed&&((R=this._glTF).extensionsUsed||(R.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(u.name)&&this._glTF.extensionsUsed.push(u.name),u.required&&((I=this._glTF).extensionsRequired||(I.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(u.name)&&this._glTF.extensionsRequired.push(u.name)),(B=this._glTF).extensions||(B.extensions={}),u.onExporting&&u.onExporting())}))}_loadExtensions(){for(const u of Ou._ExtensionNames){const R=Ou._ExtensionFactories[u](this);this._extensions[u]=R}}constructor(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:X.e.LastCreatedScene,R=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${P.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new c(this),this._extensions={},this._bufferManager=new Gu,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!u)throw new Error("No scene available to export");this._babylonScene=u,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:u=>{var R;return null===u||void 0===u||null===(R=u.UD)||void 0===R?void 0:R.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...R},this._loadExtensions()}dispose(){for(const u in this._extensions){this._extensions[u].dispose()}}get options(){return this._options}static RegisterExtension(u,R){Ou.UnregisterExtension(u)&&U.Tools.Warn(`Extension with the name ${u} already exists`),Ou._ExtensionFactories[u]=R,Ou._ExtensionNames.push(u)}static UnregisterExtension(u){if(!Ou._ExtensionFactories[u])return!1;delete Ou._ExtensionFactories[u];const R=Ou._ExtensionNames.indexOf(u);return-1!==R&&Ou._ExtensionNames.splice(R,1),!0}_generateJSON(u,R,I){const B={byteLength:u};return B.byteLength&&(this._glTF.buffers=[B]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.ER=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(B.uri=R+".bin"),I?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(u){const R=await this._generateBinaryAsync();this._extensionsOnExporting();const I=this._generateJSON(R.byteLength,u,!0),B=new Blob([R],{type:"application/octet-stream"}),U=u+".gltf",K=u+".bin",C=new t;if(C.files[U]=I,C.files[K]=B,this._imageData)for(const D in this._imageData)C.files[D]=new Blob([this._imageData[D].data],{type:this._imageData[D].mimeType});return C}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(u){const R=u%4;return 0===R?R:4-R}async generateGLBAsync(u){this._shouldUseGlb=!0;const R=await this._generateBinaryAsync();this._extensionsOnExporting();const I=this._generateJSON(R.byteLength),B=u+".glb";let U,K=I.length;if("undefined"!==typeof TextEncoder){U=(new TextEncoder).encode(I),K=U.length}const C=this._getPadding(K),D=this._getPadding(R.byteLength),s=28+K+C+R.byteLength+D,G=new su(s);if(G.writeUInt32(1179937895),G.writeUInt32(2),G.writeUInt32(s),G.writeUInt32(K+C),G.writeUInt32(1313821514),U)G.writeTypedArray(U);else{const u="_".charCodeAt(0);for(let R=0;R<K;++R){const B=I.charCodeAt(R);B!=I.codePointAt(R)?G.writeUInt8(u):G.writeUInt8(B)}}for(let t=0;t<C;++t)G.writeUInt8(32);G.writeUInt32(R.byteLength+D),G.writeUInt32(5130562),G.writeTypedArray(R);for(let t=0;t<D;++t)G.writeUInt8(0);const S=new t;return S.files[B]=new Blob([G.getOutputData()],{type:"application/octet-stream"}),S}_setNodeTransformation(u,R,I){if(R.getPivotPoint().equalsWithEpsilon(a,W.c)||U.Tools.Warn("Pivot points are not supported in the glTF serializer"),!R.position.equalsWithEpsilon(a,W.c)){const U=B.TmpVectors.PR[0].B(R.position);I&&F(U),u.translation=U.sD()}R.zD.equalsWithEpsilon(O,W.c)||(u.scale=R.zD.sD());const K=R.rotationQuaternion||B.Quaternion.FromEulerAngles(R.rotation.x,R.rotation.y,R.rotation.z);K.equalsWithEpsilon(A,W.c)||(I&&n(K),u.rotation=K.normalize().sD())}_setCameraTransformation(u,R,I){if(!R.position.equalsWithEpsilon(a,W.c)){const U=B.TmpVectors.PR[0].B(R.position);I&&F(U),u.translation=U.sD()}const U=R.rotationQuaternion||B.Quaternion.FromEulerAngles(R.rotation.x,R.rotation.y,R.rotation.z);I&&n(U),this._babylonScene.useRightHandedSystem||d(U),U.equalsWithEpsilon(A,W.c)||(u.rotation=U.sD())}_listAvailableCameras(){for(const u of this._babylonScene.cameras){const R={type:u.mode===bu.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(u.name&&(R.name=u.name),"perspective"===R.type)R.perspective={aspectRatio:u.getEngine().getAspectRatio(u),yfov:u.fovMode===bu.e.FOVMODE_VERTICAL_FIXED?u.fov:u.fov*u.getEngine().getAspectRatio(u),znear:u.GD,zfar:u.maxZ};else if("orthographic"===R.type){const I=u.orthoLeft&&u.orthoRight?.5*(u.orthoRight-u.orthoLeft):.5*u.getEngine().getRenderWidth(),B=u.orthoBottom&&u.orthoTop?.5*(u.orthoTop-u.orthoBottom):.5*u.getEngine().getRenderHeight();R.orthographic={xmag:I,ymag:B,znear:u.GD,zfar:u.maxZ}}this._camerasMap.set(u,R)}}_exportAndAssignCameras(){const u=Array.from(this._camerasMap.values());for(const R of u){const u=this._nodesCameraMap.get(R);if(void 0!==u){this._cameras.push(R);for(const R of u)R.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const u of this._babylonScene.skeletons){if(u.bones.length<=0)continue;const R={joints:[]};this._skinMap.set(u,R)}}_exportAndAssignSkeletons(){for(const u of this._babylonScene.skeletons){if(u.bones.length<=0)continue;const R=this._skinMap.get(u);if(void 0==R)continue;const I={},B=[];let K=-1;for(let U=0;U<u.bones.length;++U){const R=u.bones[U],B=R.getIndex()??U;-1!==B&&(I[B]=R,B>K&&(K=B))}for(let u=0;u<=K;++u){const K=I[u];B.push(K.getAbsoluteInverseBindMatrix());const C=K.getTransformNode();if(null!==C){const u=this._nodeMap.get(C);C&&null!==u&&void 0!==u?R.joints.push(u):U.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else U.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const C=this._nodesSkinMap.get(R);if(R.joints.length>0&&void 0!==C){const u=64*B.length,I=new Float32Array(u/4);B.forEach(((u,R)=>{I.set(u.m,16*R)}));const U=this._bufferManager.createBufferView(I);this._accessors.push(this._bufferManager.createAccessor(U,"MAT4",5126,B.length)),R.inverseBindMatrices=this._accessors.length-1,this._skins.push(R);for(const R of C)R.skin=this._skins.length-1}}}async _exportSceneAsync(){const u={nodes:[]};if(this._babylonScene.metadata){const R=this._options.metadataSelector(this._babylonScene.metadata);R&&(u.extras=R)}const R=new Array,I=new Array,B=new Array;for(const D of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Cu(D,this._babylonScene.useRightHandedSystem)?B.push(...D.getChildren()):this._babylonScene.useRightHandedSystem?R.push(D):I.push(D);this._listAvailableCameras(),this._listAvailableSkeletons();const U=new Au(!0,!1);u.nodes.push(...await this._exportNodesAsync(I,U));const K=new Au(!1,!1);u.nodes.push(...await this._exportNodesAsync(R,K));const C=new Au(!1,!0);u.nodes.push(...await this._exportNodesAsync(B,C)),u.nodes.length&&this._scenes.push(u),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Qu._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,U.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(u){let R=this._shouldExportNodeMap.get(u);return void 0===R&&(R=this._options.shouldExportNode(u),this._shouldExportNodeMap.set(u,R)),R}async _exportNodesAsync(u,R){const I=new Array;this._exportBuffers(u,R);for(const B of u)await this._exportNodeAsync(B,I,R);return I}_collectBuffers(u,R,I,B,U){if(this._shouldExportNode(u)&&u instanceof b.b&&u.rD){const K=u.rD.getVertexBuffers();if(K)for(const B in K){if(!L(B))continue;const C=K[B];U.setHasVertexColorAlpha(C,u.hasVertexAlpha);const D=C._buffer,s=R.get(D)||[];R.set(D,s),-1===s.indexOf(C)&&s.push(C);const t=I.get(C)||[];I.set(C,t),-1===t.indexOf(u)&&t.push(u)}const C=u.morphTargetManager;if(C)for(let R=0;R<C.numTargets;R++){const I=C.getTarget(R),U=B.get(I)||[];B.set(I,U),-1===U.indexOf(u)&&U.push(u)}}for(const K of u.getChildren())this._collectBuffers(K,R,I,B,U)}_exportBuffers(u,R){const I=new Map,B=new Map,U=new Map;for(const D of u)this._collectBuffers(D,I,B,U,R);const K=Array.from(I.keys());for(const D of K){const u=D.getData();if(!u)throw new Error("Buffer data is not available");const U=I.get(D);if(!U)continue;const K=U[0].byteStride;if(U.some((u=>u.byteStride!==K)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const C=Iu(u).slice();for(const R of U){const u=B.get(R),{byteOffset:I,byteStride:U,componentCount:K,type:D,count:s,normalized:t,kind:S}=J(R,u);switch(S){case G.i.NormalKind:case G.i.TangentKind:(0,k.j)(C,I,U,K,D,s,t,(u=>{const R=Math.sqrt(u[0]*u[0]+u[1]*u[1]+u[2]*u[2]);if(R>0){const I=1/R;u[0]*=I,u[1]*=I,u[2]*=I}}));break;case G.i.ColorKind:{const R=u.filter((u=>u.material instanceof Xu.zR||null==u.material)).length;if(0==R)break;if(R!=u.length){w.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}D==G.i.UNSIGNED_BYTE&&w.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const B=new E.fR,S=new E.TD,b=this._babylonScene.getEngine().useExactSrgbConversions;(0,k.j)(C,I,U,K,D,s,t,(u=>{3===u.length?(B.bI(u,0),B.toLinearSpaceToRef(B,b),B.toArray(u,0)):(S.bI(u,0),S.toLinearSpaceToRef(S,b),S.toArray(u,0))}))}}}if(R.convertToRightHanded){for(const u of U){const R=B.get(u),{byteOffset:I,byteStride:U,componentCount:K,type:D,count:s,normalized:t,kind:S}=J(u,R);switch(S){case G.i.PositionKind:case G.i.NormalKind:case G.i.TangentKind:(0,k.j)(C,I,U,K,D,s,t,(u=>{u[0]=-u[0]}))}}R.convertedToRightHandedBuffers.set(D,C)}const s=this._bufferManager.createBufferView(C,K);R.setVertexBufferView(D,s);const t=new Map;for(const R of U){const u=B.get(R),{kind:I,totalVertices:U}=J(R,u);switch(I){case G.i.MatricesIndicesKind:case G.i.MatricesIndicesExtraKind:if(R.type==G.i.FLOAT){const u=R.getFloatData(U);null!==u&&t.set(R,u)}}}0!==t.size&&w.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const S=Array.from(t.keys());for(const I of S){const u=t.get(I);if(!u)continue;const B=u.some((u=>u>=256)),U=new(B?Uint16Array:Uint8Array)(u.length);for(let R=0;R<u.length;R++)U[R]=u[R];const K=this._bufferManager.createBufferView(U,4*(B?2:1));R.setRemappedBufferView(D,I,K)}}const C=Array.from(U.keys());for(const D of C){const u=U.get(D);if(!u)continue;const I=Vu(D,u[0],this._bufferManager,this._bufferViews,this._accessors,R.convertToRightHanded);for(const B of u)R.bindMorphDataToMesh(B,I)}}async _exportNodeAsync(u,R,I){let B=this._nodeMap.get(u);if(void 0!==B)return void(R.includes(B)||R.push(B));const U=await this._createNodeAsync(u,I);if(U){B=this._nodes.length,this._nodes.push(U),this._nodeMap.set(u,B),I.pushExportedNode(u),R.push(B);const K={name:"runtime animations",channels:[],samplers:[]},C=[];this._babylonScene.animationGroups.length||(Qu._CreateMorphTargetAnimationFromMorphTargetAnimations(u,K,C,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,I.convertToRightHanded,this._options.shouldExportAnimation),u.animations.length&&Qu._CreateNodeAnimationFromNodeAnimations(u,K,C,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,I.convertToRightHanded,this._options.shouldExportAnimation)),K.channels.length&&K.samplers.length&&this._animations.push(K),C.forEach((u=>{u.channels.length&&u.samplers.length&&this._animations.push(u)}))}const K=U?[]:R;for(const C of u.getChildren())await this._exportNodeAsync(C,K,I);U&&K.length&&(U.children=K)}async _createNodeAsync(u,R){if(!this._shouldExportNode(u))return null;const I={};if(u.name&&(I.name=u.name),u.metadata){const R=this._options.metadataSelector(u.metadata);R&&(I.extras=R)}if(u instanceof S.e&&(this._setNodeTransformation(I,u,R.convertToRightHanded),u instanceof b.b)){const U=u instanceof r.d?u.sourceMesh:u;if(U.DD&&U.DD.length>0&&(I.mesh=await this._exportMeshAsync(U,R)),u.skeleton){const R=this._skinMap.get(u.skeleton);var B;if(void 0!==R)void 0===this._nodesSkinMap.get(R)&&this._nodesSkinMap.set(R,[]),null===(B=this._nodesSkinMap.get(R))||void 0===B||B.push(I)}}if(u instanceof i.c){const B=this._camerasMap.get(u);if(B){var U;void 0===this._nodesCameraMap.get(B)&&this._nodesCameraMap.set(B,[]),this._setCameraTransformation(I,u,R.convertToRightHanded);const C=u.parent;if(null!==C&&Ru(u,C)){const u=this._nodeMap.get(C);if(void 0!==u){var K;const R=this._nodes[u];return uu(I,R),null===(K=this._nodesCameraMap.get(B))||void 0===K||K.push(R),null}}null===(U=this._nodesCameraMap.get(B))||void 0===U||U.push(I)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",I,u,this._nodeMap,R.convertToRightHanded)?I:(w.b.Warn(`Not exporting node ${u.name}`),null)}_exportIndices(u,R,I,B,U,C,D,s,t){let G=u;t.mode=H(C);const S=D!==K.c.CounterClockWiseSideOrientation,b=!s.wasAddedByNoopNode&&S,r=function(u){switch(u){case K.c.TriangleFillMode:case K.c.TriangleStripDrawMode:case K.c.TriangleFanDrawMode:return!0}return!1}(C)&&b;if(r){if(C===K.c.TriangleStripDrawMode||C===K.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");t.mode=H(C);const D=R?new Uint32Array(B):new Uint16Array(B);if(u)for(let R=0;R+2<B;R+=3)D[R]=u[I+R]+U,D[R+1]=u[I+R+2]+U,D[R+2]=u[I+R+1]+U;else for(let u=0;u+2<B;u+=3)D[u]=u,D[u+1]=u+2,D[u+2]=u+1;G=D}else if(u&&0!==U){const K=R?new Uint32Array(B):new Uint16Array(B);for(let R=0;R<B;R++)K[R]=u[I+R]+U;G=K}if(G){let K=s.getIndicesAccessor(u,I,B,U,r);if(void 0===K){const C=function(u,R,I,B){if(u instanceof Uint16Array||u instanceof Uint32Array)return u;if(u instanceof Int32Array)return new Uint32Array(u.buffer,u.byteOffset,u.length);const U=u.slice(R,R+I);return B?new Uint32Array(U):new Uint16Array(U)}(G,0,B,R),D=this._bufferManager.createBufferView(C),t=R?5125:5123;this._accessors.push(this._bufferManager.createAccessor(D,"SCALAR",t,B,0)),K=this._accessors.length-1,s.setIndicesAccessor(u,I,B,U,r,K)}t.indices=K}}_exportVertexBuffer(u,R,I,B,U,K){const C=u.getKind();if(!L(C))return;if(C.startsWith("uv")&&!this._options.exportUnusedUVs&&(!R||!this._materialNeedsUVsSet.has(R)))return;let D=U.getVertexAccessor(u,I,B);if(void 0===D){const R=U.convertedToRightHandedBuffers.get(u._buffer)||u._buffer.getData(),K=C===G.i.PositionKind?function(u,R,I,B){const{byteOffset:U,byteStride:K,type:C,normalized:D}=R,s=R.getSize(),t=new Array(s).fill(1/0),G=new Array(s).fill(-1/0);return(0,k.j)(u,U+I*K,K,s,C,B*s,D,(u=>{for(let R=0;R<s;R++)t[R]=Math.min(t[R],u[R]),G[R]=Math.max(G[R],u[R])})),{min:t,max:G}}(R,u,I,B):void 0,s=(C===G.i.MatricesIndicesKind||C===G.i.MatricesIndicesExtraKind)&&u.type===G.i.FLOAT,t=s?G.i.UNSIGNED_BYTE:u.type,S=s?void 0:u.normalized,b=s?U.getRemappedBufferView(u._buffer,u):U.getVertexBufferView(u._buffer),r=u.byteOffset+I*u.byteStride;this._accessors.push(this._bufferManager.createAccessor(b,function(u,R){if(u==G.i.ColorKind)return R?"VEC4":"VEC3";switch(u){case G.i.PositionKind:case G.i.NormalKind:return"VEC3";case G.i.TangentKind:case G.i.MatricesIndicesKind:case G.i.MatricesIndicesExtraKind:case G.i.MatricesWeightsKind:case G.i.MatricesWeightsExtraKind:return"VEC4";case G.i.UVKind:case G.i.UV2Kind:case G.i.UV3Kind:case G.i.UV4Kind:case G.i.UV5Kind:case G.i.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${u}`)}(C,U.hasVertexColorAlpha(u)),t,B,r,K,S)),D=this._accessors.length-1,U.setVertexAccessor(u,I,B,D)}K.attributes[function(u){switch(u){case G.i.PositionKind:return"POSITION";case G.i.NormalKind:return"NORMAL";case G.i.TangentKind:return"TANGENT";case G.i.ColorKind:return"COLOR_0";case G.i.UVKind:return"TEXCOORD_0";case G.i.UV2Kind:return"TEXCOORD_1";case G.i.UV3Kind:return"TEXCOORD_2";case G.i.UV4Kind:return"TEXCOORD_3";case G.i.UV5Kind:return"TEXCOORD_4";case G.i.UV6Kind:return"TEXCOORD_5";case G.i.MatricesIndicesKind:return"JOINTS_0";case G.i.MatricesIndicesExtraKind:return"JOINTS_1";case G.i.MatricesWeightsKind:return"WEIGHTS_0";case G.i.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${u}`)}(C)]=D}async _exportMaterialAsync(u,R,I,B){let U=this._materialMap.get(u);if(void 0===U){const B=R&&Object.keys(R).some((u=>u.startsWith("uv")));if((u=u instanceof ru.c?u.QD[I.materialIndex]:u)instanceof Pu.c)U=await this._materialExporter.exportPBRMaterialAsync(u,"image/png",B);else{if(!(u instanceof Xu.zR))return void w.b.Warn(`Unsupported material '${u.name}' with type ${u.getClassName()}`);U=await this._materialExporter.exportStandardMaterialAsync(u,"image/png",B)}this._materialMap.set(u,U)}B.material=U}async _exportMeshAsync(u,R){var I;let B=R.getMesh(u);if(void 0!==B)return B;const U={primitives:[]};B=this._meshes.length,this._meshes.push(U),R.setMesh(u,B);const C=u.isUnIndexed?null:u.PD(),D=null===(I=u.rD)||void 0===I?void 0:I.getVertexBuffers(),s=R.getMorphTargetsFromMesh(u),t=u instanceof qu.c,G=u instanceof au,S=u.DD;if(D&&S&&S.length>0)for(const P of S){const I={attributes:{}},B=P.cu()||this._babylonScene.defaultMaterial;if(G){var b,r;const R={name:B.name},U=u,K=E.fR.White(),C=(null===(b=U.material)||void 0===b?void 0:b.alpha)??1,D=(null===(r=U.greasedLineMaterial)||void 0===r?void 0:r.color)??K;(!D.equalsWithEpsilon(K,W.c)||C<1)&&(R.pbrMetallicRoughness={baseColorFactor:[...D.sD(),C]}),this._materials.push(R),I.material=this._materials.length-1}else if(t){const R={name:B.name},U=u;(!U.color.equalsWithEpsilon(E.fR.White(),W.c)||U.alpha<1)&&(R.pbrMetallicRoughness={baseColorFactor:[...U.color.sD(),U.alpha]}),this._materials.push(R),I.material=this._materials.length-1}else await this._exportMaterialAsync(B,D,P,I);const S=t||G?K.c.LineListDrawMode:u.overrideRenderingFillMode??B.fillMode,X=B._getEffectiveOrientation(u);this._exportIndices(C,C?(0,k.e)(C,P.indexCount,P.indexStart,P.verticesStart):P.verticesCount>65535,C?P.indexStart:P.verticesStart,C?P.indexCount:P.verticesCount,-P.verticesStart,S,X,R,I);for(const u of Object.values(D))this._exportVertexBuffer(u,B,P.verticesStart,P.verticesCount,R,I);if(s){I.targets=[];for(const u of s)I.targets.push(u.attributes)}U.primitives.push(I),this._extensionsPostExportMeshPrimitive(I)}if(s){U.weights=[],U.extras||(U.extras={}),U.extras.targetNames=[];for(const u of s)U.weights.push(u.influence),U.extras.targetNames.push(u.name)}return B}}Ou._ExtensionNames=new Array,Ou._ExtensionFactories={};class Nu{static async GLTFAsync(u,R,I){I&&I.exportWithoutWaitingForScene||await u.whenReadyAsync();const B=new Ou(u,I),U=await B.generateGLTFAsync(R.replace(/\.[^/.]+$/,""));return B.dispose(),U}static async GLBAsync(u,R,I){I&&I.exportWithoutWaitingForScene||await u.whenReadyAsync();const B=new Ou(u,I),U=await B.generateGLBAsync(R.replace(/\.[^/.]+$/,""));return B.dispose(),U}}I(13020);const Ju="EXT_mesh_gpu_instancing";class mR{constructor(u){this.name=Ju,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=u}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(u,R,I,U,K,C){return await new Promise((u=>{if(R&&I instanceof fu.b&&I.hasThinInstances&&this._exporter){this._wasUsed=!0;const u=B.PR.Zero(),U=B.Quaternion.Identity(),D=B.PR.One(),s=I.thinInstanceGetWorldMatrices(),t=B.TmpVectors.PR[2],G=B.TmpVectors.Quaternion[1],S=B.TmpVectors.PR[3];let b=!1,r=!1,P=!1;const X=new Float32Array(3*I.VD),E=new Float32Array(4*I.VD),z=new Float32Array(3*I.VD);let f=0;for(const R of s)R.decompose(S,G,t),K&&(F(t),n(G)),X.set(t.sD(),3*f),E.set(G.normalize().sD(),4*f),z.set(S.sD(),3*f),b=b||!t.equalsWithEpsilon(u),r=r||!G.equalsWithEpsilon(U),P=P||!S.equalsWithEpsilon(D),f++;const T={attributes:{}};b&&(T.attributes.TRANSLATION=this._buildAccessor(X,"VEC3",I.VD,C)),r&&(T.attributes.ROTATION=this._buildAccessor(E,"VEC4",I.VD,C)),P&&(T.attributes.SCALE=this._buildAccessor(z,"VEC3",I.VD,C)),R.extensions=R.extensions||{},R.extensions[Ju]=T}u(R)}))}_buildAccessor(u,R,I,B){const U=B.createBufferView(u),K=B.createAccessor(U,R,5126,I);return this._exporter._accessors.push(K),this._exporter._accessors.length-1}}Ou.RegisterExtension(Ju,(u=>new mR(u)));var Lu=I(13022),Hu=I(13032),yu=I(13041),Fu=I(13049);function nu(u){return u===yu.b.PositionKind?"POSITION":u===yu.b.NormalKind?"NORMAL":u===yu.b.ColorKind?"COLOR":u.startsWith(yu.b.UVKind)?"TEX_COORD":"GENERIC"}const du={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class uR extends Lu.c{static get DefaultAvailable(){return(0,Lu.e)(uR.DefaultConfiguration)}static get Default(){return uR._Default??(uR._Default=new uR),uR._Default}static ResetDefault(u){uR._Default&&(u||uR._Default.dispose(),uR._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(u,R){return{module:await(R||DracoEncoderModule)({wasmBinary:u})}}_getWorkerContent(){return`${Hu.i}(${Hu.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:uR.DefaultConfiguration)}async _encodeAsync(u,R,I){const B=I?(0,Fu.d)(du,I):du;if(this._workerPoolPromise){const I=await this._workerPoolPromise;return await new Promise(((U,K)=>{I.push(((I,C)=>{const D=u=>{I.removeEventListener("error",D),I.removeEventListener("message",s),K(u),C()},s=u=>{"encodeMeshDone"===u.data.id&&(I.removeEventListener("error",D),I.removeEventListener("message",s),U(u.data.encodedMeshData),C())};I.addEventListener("error",D),I.addEventListener("message",s);const t=[];for(const R of u)t.push(R.data.buffer);R&&t.push(R.buffer),I.postMessage({id:"encodeMesh",attributes:u,indices:R,options:B},t)}))}))}if(this._modulePromise){const I=await this._modulePromise;return(0,Hu.i)(I.module,u,R,B)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(u,R){if(0==u.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");u instanceof fu.b&&u.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===R||void 0===R?void 0:R.method)&&(w.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),R.method="MESH_SEQUENTIAL_ENCODING");const I=function(u){let R=u.PD(void 0,!0);return!R||R instanceof Uint32Array||R instanceof Uint16Array||(R=((0,k.e)(R,R.length)?Uint32Array:Uint16Array).from(R)),R}(u),B=function(u,R){const I=[];for(const B of u.getVerticesDataKinds()){if(null!==R&&void 0!==R&&R.includes(B)){if(B===yu.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const U=u.getVertexBuffer(B),K=U.getSize(),C=(0,k.s)(U.getData(),K,U.type,U.byteOffset,U.byteStride,U.normalized,u.getTotalVertices(),!0);I.push({kind:B,dracoName:nu(B),size:K,data:C})}return I}(u,null===R||void 0===R?void 0:R.excludedAttributes);return await this._encodeAsync(B,I,R)}}uR.DefaultConfiguration={wasmUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder.js`},uR._Default=null;const RR="KHR_draco_mesh_compression";class IR{get wasUsed(){return this._wasUsed}constructor(u){this.name=RR,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===u.options.meshCompressionMethod&&uR.DefaultAvailable}dispose(){}postExportMeshPrimitive(u,R,I){if(!this.enabled)return;if(4!==u.mode&&5!==u.mode)return void w.b.Warn("Cannot compress primitive with mode "+u.mode+".");const B=[],U=[];let K=null;if(void 0!==u.indices){const C=I[u.indices],D=R.getBufferView(C);K=R.getData(D).slice(),B.push(D),U.push(C)}const C=[];for(const[G,S]of Object.entries(u.attributes)){const u=I[S],K=R.getBufferView(u),s=mu(u.type),t=(0,k.s)(R.getData(K),s,u.componentType,u.byteOffset||0,K.byteStride||(0,k.n)(u.componentType)*s,u.normalized||!1,u.count,!0);C.push({kind:G,dracoName:(D=G,"POSITION"===D?"POSITION":"NORMAL"===D?"NORMAL":D.startsWith("COLOR")?"COLOR":D.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:mu(u.type),data:t}),B.push(K),U.push(u)}var D;const s={method:u.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},t=uR.Default._encodeAsync(C,K,s).then((I=>{if(!I)return void w.b.Error("Draco encoding failed for primitive.");const K={bufferView:-1,attributes:I.attributeIds},C=R.createBufferView(I.data);R.setBufferView(K,C);for(const u of B)this._bufferViewsUsed.add(u);for(const u of U)this._accessorsUsed.add(u);u.extensions||(u.extensions={}),u.extensions[RR]=K})).catch((u=>{w.b.Error("Draco encoding failed for primitive: "+u)}));this._encodePromises.push(t),this._wasUsed=!0}async preGenerateBinaryAsync(u){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((R=>{u.getPropertiesWithBufferView(R).every((u=>this._accessorsUsed.has(u)))&&u.removeBufferView(R)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Ou.RegisterExtension(RR,(u=>new IR(u)));var BR=I(13051);const UR="KHR_lights_punctual",KR={name:"",color:[1,1,1],qD:1,range:Number.MAX_VALUE},CR={innerConeAngle:0,outerConeAngle:Math.PI/4},DR=B.PR.Backward();class sR{constructor(u){this.name=UR,this.enabled=!0,this.required=!1,this._exporter=u}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[UR]=this._lights}async postExportNodeAsync(u,R,I,U,K){return await new Promise((C=>{if(!(I instanceof Tu.d))return void C(R);const D=I.getTypeID()==Tu.d.LIGHTTYPEID_POINTLIGHT?"point":I.getTypeID()==Tu.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":I.getTypeID()==Tu.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!D||!(I instanceof BR.d))return w.b.Warn(`${u}: Light ${I.name} is not supported in ${UR}`),void C(R);if(I.falloffType!==Tu.d.FALLOFF_GLTF&&w.b.Warn(`${u}: Light falloff for ${I.name} does not match the ${UR} specification!`),!I.position.equalsToFloats(0,0,0)){const u=B.TmpVectors.PR[0].B(I.position);K&&F(u),R.translation=u.sD()}if("point"!==D){const u=I.direction.normalizeToRef(B.TmpVectors.PR[0]);K&&F(u);const U=B.Quaternion.FromUnitVectorsToRef(DR,u,B.TmpVectors.Quaternion[0]);B.Quaternion.IsIdentity(U)||(R.rotation=U.sD())}const s={type:D,name:I.name,color:I.eD.sD(),qD:I.qD,range:I.range};if(Bu(s,KR),"spot"===D){const u=I;s.spot={innerConeAngle:u.innerAngle/2,outerConeAngle:u.angle/2},Bu(s.spot,CR)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(s);const t={yC:this._lights.lights.length-1},G=I.parent;if(G&&Ru(I,G)){const u=U.get(G);if(u){const I=this._exporter._nodes[u];return uu(R,I),I.extensions||(I.extensions={}),I.extensions[UR]=t,void C(null)}}R.extensions||(R.extensions={}),R.extensions[UR]=t,C(R)}))}}Ou.RegisterExtension(UR,(u=>new sR(u)));var tR=I(12969);const GR="KHR_materials_anisotropy";class SR{constructor(u){this.name=GR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=u}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(u,R,I){const B=[];return I instanceof tR.e&&I.anisotropy.isEnabled&&!I.anisotropy.legacy?(I.anisotropy.texture&&B.push(I.anisotropy.texture),B):[]}postExportMaterialAsync(u,R,I){return new Promise((u=>{if(I instanceof tR.e){if(!I.anisotropy.isEnabled||I.anisotropy.legacy)return void u(R);this._wasUsed=!0,R.extensions=R.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(I.anisotropy.texture),U={anisotropyStrength:I.anisotropy.qD,anisotropyRotation:I.anisotropy.angle,anisotropyTexture:B??void 0};null!==U.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(I),R.extensions[GR]=U}u(R)}))}}Ou.RegisterExtension(GR,(u=>new SR(u)));const bR="KHR_materials_clearcoat";class rR{constructor(u){this.name=bR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=u}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(u,R,I){const B=[];return I instanceof tR.e&&I.clearCoat.isEnabled?(I.clearCoat.texture&&B.push(I.clearCoat.texture),!I.clearCoat.useRoughnessFromMainTexture&&I.clearCoat.textureRoughness&&B.push(I.clearCoat.textureRoughness),I.clearCoat.bumpTexture&&B.push(I.clearCoat.bumpTexture),B):[]}postExportMaterialAsync(u,R,I){return new Promise((u=>{if(I instanceof tR.e){if(!I.clearCoat.isEnabled)return void u(R);this._wasUsed=!0,R.extensions=R.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(I.clearCoat.texture);let K;K=I.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(I.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(I.clearCoat.textureRoughness),I.clearCoat.isTintEnabled&&U.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${I.name}`),I.clearCoat.remapF0OnInterfaceChange&&U.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${I.name}`);const C=this._exporter._materialExporter.getTextureInfo(I.clearCoat.bumpTexture),D={clearcoatFactor:I.clearCoat.qD,clearcoatTexture:B??void 0,clearcoatRoughnessFactor:I.clearCoat.roughness,clearcoatRoughnessTexture:K??void 0,clearcoatNormalTexture:C??void 0};null===D.clearcoatTexture&&null===D.clearcoatRoughnessTexture&&null===D.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(I),R.extensions[bR]=D}u(R)}))}}Ou.RegisterExtension(bR,(u=>new rR(u)));const PR="KHR_materials_diffuse_transmission";function XR(u,R){const I=R.subSurface;let B=null;return I.translucencyIntensityTexture?B=I.translucencyIntensityTexture:I.thicknessTexture&&I.useMaskFromThicknessTexture&&(B=I.thicknessTexture),B&&!I.useGltfStyleTextures?(w.b.Warn(`${u}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${R.name}`,1),null):B}class ER{constructor(u){this.name=PR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=u}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(u,R,I){const B=[];if(I instanceof Pu.c&&this._isExtensionEnabled(I)){const R=XR(u,I);return R&&B.push(R),I.subSurface.translucencyColorTexture&&B.push(I.subSurface.translucencyColorTexture),B}return B}_isExtensionEnabled(u){if(u.unlit)return!1;const R=u.subSurface;return!!R.isTranslucencyEnabled&&(!u.unlit&&!R.useAlbedoToTintTranslucency&&R.useGltfStyleTextures&&1===R.volumeIndexOfRefraction&&0===R.minimumThickness&&0===R.maximumThickness)}postExportMaterialAsync(u,R,I){return new Promise((B=>{if(I instanceof Pu.c&&this._isExtensionEnabled(I)){this._wasUsed=!0;const B=I.subSurface,U=XR(u,I),K=0==B.translucencyIntensity?void 0:B.translucencyIntensity,C=this._exporter._materialExporter.getTextureInfo(U)??void 0,D=!B.translucencyColor||B.translucencyColor.equalsFloats(1,1,1)?void 0:B.translucencyColor.sD(),s=this._exporter._materialExporter.getTextureInfo(B.translucencyColorTexture)??void 0,t={diffuseTransmissionFactor:K,diffuseTransmissionTexture:C,diffuseTransmissionColorFactor:D,diffuseTransmissionColorTexture:s};(C||s)&&this._exporter._materialNeedsUVsSet.add(I),R.extensions=R.extensions||{},R.extensions[PR]=t}B(R)}))}}Ou.RegisterExtension(PR,(u=>new ER(u)));const zR="KHR_materials_dispersion";class fR{constructor(){this.name=zR,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(u){if(u.unlit)return!1;const R=u.subSurface;return!(!R.isRefractionEnabled&&!R.isDispersionEnabled)}postExportMaterialAsync(u,R,I){return new Promise((u=>{if(I instanceof Pu.c&&this._isExtensionEnabled(I)){this._wasUsed=!0;const u={dispersion:I.subSurface.dispersion};R.extensions=R.extensions||{},R.extensions[zR]=u}u(R)}))}}Ou.RegisterExtension(zR,(()=>new fR));const TR="KHR_materials_emissive_strength";class QR{constructor(){this.name=TR,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(u,R,I){return await new Promise((u=>{if(!(I instanceof Pu.c))return u(R);const B=I.emissiveColor.sD(),U=Math.max(...B);if(U>1){this._wasUsed=!0,R.extensions||(R.extensions={});const u={emissiveStrength:U},B=I.emissiveColor.scale(1/u.emissiveStrength);R.emissiveFactor=B.sD(),R.extensions[TR]=u}return u(R)}))}}Ou.RegisterExtension(TR,(u=>new QR));const VR="KHR_materials_ior";class qR{constructor(){this.name=VR,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(u){return!u.unlit&&(void 0!=u.indexOfRefraction&&1.5!=u.indexOfRefraction)}postExportMaterialAsync(u,R,I){return new Promise((u=>{if(I instanceof Pu.c&&this._isExtensionEnabled(I)){this._wasUsed=!0;const u={ior:I.indexOfRefraction};R.extensions=R.extensions||{},R.extensions[VR]=u}u(R)}))}}Ou.RegisterExtension(VR,(u=>new qR));const eR="KHR_materials_iridescence";class YR{constructor(u){this.name=eR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=u}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(u,R,I){const B=[];return I instanceof tR.e&&I.iridescence.isEnabled?(I.iridescence.texture&&B.push(I.iridescence.texture),I.iridescence.thicknessTexture&&I.iridescence.thicknessTexture!==I.iridescence.texture&&B.push(I.iridescence.thicknessTexture),B):[]}postExportMaterialAsync(u,R,I){return new Promise((u=>{if(I instanceof tR.e){if(!I.iridescence.isEnabled)return void u(R);this._wasUsed=!0,R.extensions=R.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(I.iridescence.texture),U=this._exporter._materialExporter.getTextureInfo(I.iridescence.thicknessTexture),K={iridescenceFactor:I.iridescence.qD,iridescenceIor:I.iridescence.indexOfRefraction,iridescenceThicknessMinimum:I.iridescence.minimumThickness,iridescenceThicknessMaximum:I.iridescence.maximumThickness,iridescenceTexture:B??void 0,iridescenceThicknessTexture:U??void 0};null===K.iridescenceTexture&&null===K.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(I),R.extensions[eR]=K}u(R)}))}}Ou.RegisterExtension(eR,(u=>new YR(u)));const MR="KHR_materials_sheen";class oR{constructor(u){this.name=MR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=u}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(u,R,I){return I instanceof Pu.c&&I.sheen.isEnabled&&I.sheen.texture?[I.sheen.texture]:[]}async postExportMaterialAsync(u,R,I){return await new Promise((u=>{if(I instanceof Pu.c){if(!I.sheen.isEnabled)return void u(R);this._wasUsed=!0,null==R.extensions&&(R.extensions={});const B={sheenColorFactor:I.sheen.color.sD(),sheenRoughnessFactor:I.sheen.roughness??0};null===B.sheenColorTexture&&null===B.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(I),I.sheen.texture&&(B.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(I.sheen.texture)??void 0),I.sheen.textureRoughness&&!I.sheen.useRoughnessFromMainTexture?B.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(I.sheen.textureRoughness)??void 0:I.sheen.texture&&I.sheen.useRoughnessFromMainTexture&&(B.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(I.sheen.texture)??void 0),R.extensions[MR]=B}u(R)}))}}Ou.RegisterExtension(MR,(u=>new oR(u)));const jR="KHR_materials_specular";class hR{constructor(u){this.name=jR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=u}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(u,R,I){const B=[];return I instanceof Pu.c&&this._isExtensionEnabled(I)?(I.metallicReflectanceTexture&&B.push(I.metallicReflectanceTexture),I.reflectanceTexture&&B.push(I.reflectanceTexture),B):B}_isExtensionEnabled(u){return!u.unlit&&(void 0!=u.metallicF0Factor&&1!=u.metallicF0Factor||void 0!=u.metallicReflectanceColor&&!u.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(u))}_hasTexturesExtension(u){return null!=u.metallicReflectanceTexture||null!=u.reflectanceTexture}postExportMaterialAsync(u,R,I){return new Promise((u=>{if(I instanceof Pu.c&&this._isExtensionEnabled(I)){this._wasUsed=!0,R.extensions=R.extensions||{};const u=this._exporter._materialExporter.getTextureInfo(I.metallicReflectanceTexture)??void 0,B=this._exporter._materialExporter.getTextureInfo(I.reflectanceTexture)??void 0,U={specularFactor:1==I.metallicF0Factor?void 0:I.metallicF0Factor,specularTexture:u,specularColorFactor:I.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:I.metallicReflectanceColor.sD(),specularColorTexture:B};this._hasTexturesExtension(I)&&this._exporter._materialNeedsUVsSet.add(I),R.extensions[jR]=U}u(R)}))}}Ou.RegisterExtension(jR,(u=>new hR(u)));const xR="KHR_materials_transmission";class gR{constructor(u){this.name=xR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=u}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(u,R,I){const B=[];return I instanceof Pu.c&&this._isExtensionEnabled(I)?(I.subSurface.thicknessTexture&&B.push(I.subSurface.thicknessTexture),B):B}_isExtensionEnabled(u){if(u.unlit)return!1;const R=u.subSurface;return R.isRefractionEnabled&&void 0!=R.refractionIntensity&&0!=R.refractionIntensity||this._hasTexturesExtension(u)}_hasTexturesExtension(u){return null!=u.subSurface.refractionIntensityTexture}async postExportMaterialAsync(u,R,I){if(I instanceof Pu.c&&this._isExtensionEnabled(I)){this._wasUsed=!0;const B=I.subSurface,U={transmissionFactor:0===B.refractionIntensity?void 0:B.refractionIntensity};if(this._hasTexturesExtension(I)&&this._exporter._materialNeedsUVsSet.add(I),B.refractionIntensityTexture)if(B.useGltfStyleTextures){const u=await this._exporter._materialExporter.exportTextureAsync(B.refractionIntensityTexture,"image/png");u&&(U.transmissionTexture=u)}else w.b.Warn(`${u}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);R.extensions||(R.extensions={}),R.extensions[xR]=U}return R}}Ou.RegisterExtension(xR,(u=>new gR(u)));const vR="KHR_materials_unlit";class pR{constructor(){this.name=vR,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(u,R,I){return new Promise((u=>{let B=!1;I instanceof Pu.c?B=I.unlit:I instanceof Xu.zR&&(B=I.disableLighting),B&&(this._wasUsed=!0,null==R.extensions&&(R.extensions={}),R.extensions[vR]={}),u(R)}))}}Ou.RegisterExtension(vR,(()=>new pR));const lR="KHR_materials_volume";class ZR{constructor(u){this.name=lR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=u}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(u,R,I){const B=[];return I instanceof Pu.c&&this._isExtensionEnabled(I)?(I.subSurface.thicknessTexture&&B.push(I.subSurface.thicknessTexture),B):B}_isExtensionEnabled(u){if(u.unlit)return!1;const R=u.subSurface;return!(!R.isRefractionEnabled&&!R.isTranslucencyEnabled)&&(void 0!=R.maximumThickness&&0!=R.maximumThickness||void 0!=R.tintColorAtDistance&&R.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=R.tintColor&&R.tintColor!=E.fR.White()||this._hasTexturesExtension(u))}_hasTexturesExtension(u){return null!=u.subSurface.thicknessTexture}postExportMaterialAsync(u,R,I){return new Promise((u=>{if(I instanceof Pu.c&&this._isExtensionEnabled(I)){this._wasUsed=!0;const u=I.subSurface,B={thicknessFactor:0==u.maximumThickness?void 0:u.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(u.thicknessTexture)??void 0,attenuationDistance:u.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:u.tintColorAtDistance,attenuationColor:u.tintColor.equalsFloats(1,1,1)?void 0:u.tintColor.sD()};this._hasTexturesExtension(I)&&this._exporter._materialNeedsUVsSet.add(I),R.extensions=R.extensions||{},R.extensions[lR]=B}u(R)}))}}Ou.RegisterExtension(lR,(u=>new ZR(u)));const cR="EXT_materials_diffuse_roughness";class kR{constructor(u){this.name=cR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=u}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(u,R,I){const B=[];return I instanceof tR.e&&I._baseDiffuseRoughness?(I._baseDiffuseRoughnessTexture&&B.push(I._baseDiffuseRoughnessTexture),B):[]}postExportMaterialAsync(u,R,I){return new Promise((u=>{if(I instanceof tR.e){if(!I._baseDiffuseRoughness)return void u(R);this._wasUsed=!0,R.extensions=R.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(I._baseDiffuseRoughnessTexture),U={diffuseRoughnessFactor:I._baseDiffuseRoughness,diffuseRoughnessTexture:B??void 0};null!==U.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(I),R.extensions[cR]=U}u(R)}))}}Ou.RegisterExtension(cR,(u=>new kR(u)));const wR="KHR_texture_transform";class iR{constructor(){this.name=wR,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(u,R,I){if(I.eu()||U.Tools.Warn(`${u}: /*@__KEY__*/"scene" is not defined for Babylon texture ${I.name}!`),(0!==I.uAng||0!==I.vAng)&&(U.Tools.Warn(`${u}: Texture ${I.name} with rotation in the u or v axis is not supported in glTF.`),0!==I.uRotationCenter||0!==I.vRotationCenter))return;const B={};let K=!1;if(0===I.uOffset&&0===I.vOffset||(B.offset=[I.uOffset,I.vOffset],K=!0),1===I.uScale&&1===I.vScale||(B.scale=[I.uScale,I.vScale],K=!0),0!==I.wAng){if(0!==I.uRotationCenter||0!==I.vRotationCenter){if(I.homogeneousRotationInUVTransform&&I.uScale!==I.vScale)return void U.Tools.Warn(`${u}: Texture ${I.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${wR}.`);U.Tools.Warn(`${u}: Texture ${I.name} with non-origin rotation center will be exported using an adjusted offset with ${wR}.`),B.offset=function(u){const{uOffset:R,vOffset:I,uRotationCenter:B,vRotationCenter:U,uScale:K,vScale:C,wAng:D}=u,s=Math.cos(D),t=Math.sin(D),G=B*K,S=U*C;return[R+(G*(1-s)+S*t),I+(S*(1-s)-G*t)]}(I)}B.rotation=-I.wAng,K=!0}0!==I.coordinatesIndex&&(B.texCoord=I.coordinatesIndex,K=!0),K&&(this._wasUsed=!0,R.extensions||(R.extensions={}),R.extensions[wR]=B)}}Ou.RegisterExtension(wR,(()=>new iR));class WR{static CreateSTL(u){let R=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",U=arguments.length>3&&void 0!==arguments[3]&&arguments[3],K=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],C=arguments.length>5&&void 0!==arguments[5]&&arguments[5],D=arguments.length>6&&void 0!==arguments[6]&&arguments[6],s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const t=function(u,R,I){const U=[3*u[I],3*u[I+1],3*u[I+2]],K=[new B.PR(R[U[0]],R[U[0]+2],R[U[0]+1]),new B.PR(R[U[1]],R[U[1]+2],R[U[1]+1]),new B.PR(R[U[2]],R[U[2]+2],R[U[2]+1])],C=K[0].XR(K[1]),D=K[2].XR(K[1]);return{v:K,n:B.PR.Cross(D,C).normalize()}},S=function(u,R,I,B){return R=b(u,R,I.x,B),R=b(u,R,I.y,B),b(u,R,I.z,B)},b=function(u,R,I,B){return u.setFloat32(R,I,B),R+4},P=function(u){if(D){let R=u;u instanceof r.d&&(R=u.sourceMesh);const I=R.getVerticesData(G.i.PositionKind,!0,!0);if(!I)return[];const U=B.PR.Zero();let K;for(K=0;K<I.length;K+=3)B.PR.TransformCoordinatesFromFloatsToRef(I[K],I[K+1],I[K+2],u.bD(!0),U).toArray(I,K);return I}return u.getVerticesData(G.i.PositionKind)||[]};D&&(C=!0);let X="",E=0,z=0;if(U){for(let I=0;I<u.length;I++){const R=u[I].PD();E+=R?R.length/3:0}const R=new ArrayBuffer(84+50*E);X=new DataView(R),z+=80,X.setUint32(z,E,K),z+=4}else s||(X="solid stlmesh\r\n");for(let B=0;B<u.length;B++){const R=u[B];!U&&s&&(X+="solid "+R.name+"\r\n"),!C&&R instanceof fu.b&&R.bakeCurrentTransformIntoVertices();const I=P(R),D=R.PD()||[];for(let u=0;u<D.length;u+=3){const R=t(D,I,u);U?(z=S(X,z,R.n,K),z=S(X,z,R.v[0],K),z=S(X,z,R.v[1],K),z=S(X,z,R.v[2],K),z+=2):(X+="\tfacet normal "+R.n.x+" "+R.n.y+" "+R.n.z+"\r\n",X+="\t\touter loop\r\n",X+="\t\t\tvertex "+R.v[0].x+" "+R.v[0].y+" "+R.v[0].z+"\r\n",X+="\t\t\tvertex "+R.v[1].x+" "+R.v[1].y+" "+R.v[1].z+"\r\n",X+="\t\t\tvertex "+R.v[2].x+" "+R.v[2].y+" "+R.v[2].z+"\r\n",X+="\t\tendloop\r\n",X+="\tendfacet\r\n")}!U&&s&&(X+="endsolid "+name+"\r\n")}if(U||s||(X+="endsolid stlmesh"),R){const u=document.createElement("a"),R=new Blob([X],{type:"application/octet-stream"});u.href=window.URL.createObjectURL(R),u.download=I+".stl",u.click()}return X}}function aR(u,R){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const B=[];for(let U=0;U<u.length/I;U++){const K=u[U*I],C=u[U*I+1],D=u[U*I+2];B.push(`(${K.toPrecision(R.precision)}, ${C.toPrecision(R.precision)}, ${D.toPrecision(R.precision)})`)}return B.join(", ")}function AR(u,R){const I=[];for(let B=0;B<u.length/2;B++){const U=u[2*B],K=u[2*B+1];I.push(`(${U.toPrecision(R.precision)}, ${(1-K).toPrecision(R.precision)})`)}return I.join(", ")}function OR(u,R){const I=u.getVerticesData(G.i.PositionKind),B=u.getVerticesData(G.i.NormalKind);if(I&&B)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(u){var R;const I=null!==(R=u.PD())&&void 0!==R&&R.length?u.getTotalIndices():u.getTotalVertices();return Array(I/3).fill(3).join(", ")}(u)}]\n\t\tint[] faceVertexIndices = [${function(u){const R=u.PD(),I=[];if(null!==R)for(let B=0;B<R.length;B++)I.push(R[B]);else{const R=u.getTotalVertices();for(let u=0;u<R;u++)I.push(u)}return I.join(", ")}(u)}]\n\t\tnormal3f[] normals = [${aR(B,R)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${aR(I,R)}]\n        ${function(u,R){let I="";for(let U=0;U<4;U++){const B=U>0?U:"",K=u.getVerticesData(G.i.UVKind+(B?B+1:""));K&&(I+=`\n\t\ttexCoord2f[] primvars:st${B} = [${AR(K,R)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const B=u.getVerticesData(G.i.ColorKind);return B&&(I+=`\n\tcolor3f[] primvars:displayColor = [${aR(B,R,B.length/u.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),I}(u,R)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function NR(u,R){return`\n        def "Geometry"\n        {\n        ${OR(u,R)}\n        }\n        `}function JR(u){let R='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return R+=u,fflate.strToU8(R)}function mI(u){const R=u.m;return`( ${LR(R,0)}, ${LR(R,4)}, ${LR(R,8)}, ${LR(R,12)} )`}function LR(u,R){return`(${u[R+0]}, ${u[R+1]}, ${u[R+2]}, ${u[R+3]})`}function HR(u){const R="Object_"+u.uniqueId,I=function(u){const R=u.getWorldMatrix().clone(),I=u.eu().useRightHandedSystem;if(!I){let B=u.parent;for(;B;){if(Cu(B,I)){R.multiplyToRef(B.getWorldMatrix().invert(),R);break}B=B.parent}}return R.determinant()<0&&U.Tools.Warn(`Exporting mesh ${u.name} with negative scale. Result may look incorrect in destination engine.`),R}(u),B=mI(I);return`def Xform "${R}" (\n\tprepend references = @./geometries/Geometry_${u.rD.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${B}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${u.material.uniqueId}>\n}\n\n`}function yR(u){switch(u){case e.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case e.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case e.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function FR(u){return`(${u.x}, ${u.y})`}function nR(u){return`(${u.r}, ${u.g}, ${u.b})`}function dR(u,R,I,U,K,C){const D=u.getInternalTexture().uniqueId+"_"+u.invertY;K[D]=u;const s=u.coordinatesIndex>0?"st"+u.coordinatesIndex:"st",t=new B.Vector2(u.uScale,u.vScale),G=new B.Vector2(u.uOffset,u.vOffset),S=u.wAng,b=Math.sin(S),r=Math.cos(S);return G.y=1-G.y-t.y,G.x+=b*t.x,G.y+=(1-r)*t.y,`\n    def Shader "PrimvarReader_${I}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${s}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${I}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${R.uniqueId}/PrimvarReader_${I}.outputs:result>\n        float inputs:rotation = ${(S*(180/Math.PI)).toFixed(C.precision)}\n        float2 inputs:scale = ${FR(t)}\n        float2 inputs:translation = ${FR(G)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${u.uniqueId}_${I}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${D}.png@\n        float2 inputs:st.connect = </Materials/Material_${R.uniqueId}/Transform2d_${I}.outputs:result>\n        ${U?"float4 inputs:scale = "+function(u){return`(${u.r}, ${u.g}, ${u.b}, 1.0)`}(U):""}\n        token inputs:sourceColorSpace = "${u.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${yR(u.wrapU)}"\n        token inputs:wrapT = "${yR(u.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${R.needAlphaBlending()?"float outputs:a":""}\n    }`}function uI(u,R,I){const B="\t\t\t",U=[],K=[],{diffuseMap:C,eD:D,alphaCutOff:s,emissiveMap:t,emissive:G,normalMap:S,roughnessMap:b,roughnessChannel:r,roughness:P,metalnessMap:X,metalnessChannel:z,metalness:f,aoMap:T,aoMapChannel:Q,aoMapIntensity:V,alphaMap:q,ior:e,clearCoatEnabled:Y,clearCoat:M,clearCoatMap:o,clearCoatRoughness:j,clearCoatRoughnessMap:h}=function(u){const R={diffuseMap:null,eD:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return u instanceof Xu.zR?{...R,diffuseMap:u.diffuseTexture,eD:u.diffuseColor,alphaCutOff:u.alphaCutOff,emissiveMap:u.emissiveTexture,emissive:u.emissiveColor,roughness:1,alphaMap:u.opacityTexture}:u instanceof tR.e?{...R,diffuseMap:u._albedoTexture,eD:u._albedoColor,alphaCutOff:u._alphaCutOff,emissiveMap:u._emissiveTexture,emissive:u._emissiveColor,normalMap:u._bumpTexture,roughnessMap:u._metallicTexture,roughnessChannel:u._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:u._roughness??1,metalnessMap:u._metallicTexture,metalnessChannel:u._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:u._metallic??0,aoMap:u._ambientTexture,aoMapChannel:u._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:u._ambientTextureStrength,alphaMap:u._opacityTexture,ior:u.subSurface.indexOfRefraction,clearCoatEnabled:u.clearCoat.isEnabled,clearCoat:u.clearCoat.qD,clearCoatMap:u.clearCoat.texture,clearCoatRoughness:u.clearCoat.roughness,clearCoatRoughnessMap:u.clearCoat.useRoughnessFromMainTexture?u.clearCoat.texture:u.clearCoat.textureRoughness}:R}(u);return null!==C?(U.push(`${B}color3f inputs:diffuseColor.connect = </Materials/Material_${u.uniqueId}/Texture_${C.uniqueId}_diffuse.outputs:rgb>`),u.needAlphaBlending()?U.push(`${B}float inputs:opacity.connect = </Materials/Material_${u.uniqueId}/Texture_${C.uniqueId}_diffuse.outputs:a>`):u.needAlphaTesting()&&(U.push(`${B}float inputs:opacity.connect = </Materials/Material_${u.uniqueId}/Texture_${C.uniqueId}_diffuse.outputs:a>`),U.push(`${B}float inputs:opacityThreshold = ${s}`)),K.push(dR(C,u,"diffuse",D,R,I))):U.push(`${B}color3f inputs:diffuseColor = ${nR(D||E.fR.White())}`),null!==t?(U.push(`${B}color3f inputs:emissiveColor.connect = </Materials/Material_${u.uniqueId}/Texture_${t.uniqueId}_emissive.outputs:rgb>`),K.push(dR(t,u,"emissive",G,R,I))):G&&G.toLuminance()>0&&U.push(`${B}color3f inputs:emissiveColor = ${nR(G)}`),null!==S&&(U.push(`${B}normal3f inputs:normal.connect = </Materials/Material_${u.uniqueId}/Texture_${S.uniqueId}_normal.outputs:rgb>`),K.push(dR(S,u,"normal",null,R,I))),null!==T&&(U.push(`${B}float inputs:occlusion.connect = </Materials/Material_${u.uniqueId}/Texture_${T.uniqueId}_occlusion.outputs:${Q}>`),K.push(dR(T,u,"occlusion",new E.fR(V,V,V),R,I))),null!==b?(U.push(`${B}float inputs:roughness.connect = </Materials/Material_${u.uniqueId}/Texture_${b.uniqueId}_roughness.outputs:${r}>`),K.push(dR(b,u,"roughness",new E.fR(P,P,P),R,I))):U.push(`${B}float inputs:roughness = ${P}`),null!==X?(U.push(`${B}float inputs:metallic.connect = </Materials/Material_${u.uniqueId}/Texture_${X.uniqueId}_metallic.outputs:${z}>`),K.push(dR(X,u,"metallic",new E.fR(f,f,f),R,I))):U.push(`${B}float inputs:metallic = ${f}`),null!==q?(U.push(`${B}float inputs:opacity.connect = </Materials/Material_${u.uniqueId}/Texture_${q.uniqueId}_opacity.outputs:r>`),U.push(`${B}float inputs:opacityThreshold = 0.0001`),K.push(dR(q,u,"opacity",null,R,I))):U.push(`${B}float inputs:opacity = ${u.alpha}`),Y&&(null!==o?(U.push(`${B}float inputs:clearcoat.connect = </Materials/Material_${u.uniqueId}/Texture_${o.uniqueId}_clearcoat.outputs:r>`),K.push(dR(o,u,"clearcoat",new E.fR(M,M,M),R,I))):U.push(`${B}float inputs:clearcoat = ${M}`),null!==h?(U.push(`${B}float inputs:clearcoatRoughness.connect = </Materials/Material_${u.uniqueId}/Texture_${h.uniqueId}_clearcoatRoughness.outputs:g>`),K.push(dR(h,u,"clearcoatRoughness",new E.fR(j,j,j),R,I))):U.push(`${B}float inputs:clearcoatRoughness = ${j}`)),U.push(`${B}float inputs:ior = ${e}`),`\n\tdef Material "Material_${u.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${U.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${u.uniqueId}/PreviewSurface.outputs:surface>\n\n${K.join("\n")}\n\n\t}\n`}async function RI(u,R,I){const K={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...R};"undefined"===typeof fflate&&await U.Tools.LoadScriptAsync(K.fflateUrl);const C={};C[K.modelFileName]=null;let D='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';D+=function(u){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===u.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${u.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${u.planeAnchoringAlignment}"`:""}\n            `}(K);const s={};for(const B of u.meshes){if(0===B.getTotalVertices())continue;const u=B,R=u.rD,t=u.material;if(!t||!R||I&&!I(u))continue;if(-1!==["zR","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(t.getClassName())){const I="geometries/Geometry_"+R.uniqueId+".usda";if(!(I in C)){const u=NR(R,K);C[I]=JR(u)}t.uniqueId in s||(s[t.uniqueId]=t),D+=HR(u)}else U.Tools.Warn("USDZExportAsync does not support this material type: "+t.getClassName())}u.activeCamera&&K.exportCamera&&(D+=function(u,R){const I="Camera_"+u.uniqueId,U=mI(B.Matrix.RotationY(Math.PI).multiply(u.getWorldMatrix()));if(u.mode===e.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${I}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${U}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${u.GD.toPrecision(R.precision)}, ${u.maxZ.toPrecision(R.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(u.orthoLeft||1)+Math.abs(u.orthoRight||1))).toPrecision(R.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(u.orthoTop||1)+Math.abs(u.orthoBottom||1))).toPrecision(R.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const B=u.getEngine().getAspectRatio(u),K=R.cameraSensorWidth||35;return`def Camera "${I}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${U}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${u.GD.toPrecision(R.precision)}, ${u.maxZ.toPrecision(R.precision)})\n\t\t\tfloat focalLength = ${(K/(2*Math.tan(.5*u.fov))).toPrecision(R.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(K*B).toPrecision(R.precision)}\n\t\t\tfloat verticalAperture = ${(K/B).toPrecision(R.precision)}            \n\t\t}\n\t\n\t`}}(u.activeCamera,K)),D+="\n            }\n        }\n    }";const t={};D+=function(u,R,I){const B=[];for(const U in u){const K=u[U];B.push(uI(K,R,I))}return`\n    def "Materials"\n{\n${B.join("")}\n}\n\n`}(s,t,K),C[K.modelFileName]=fflate.strToU8(D);for(const B in t){const u=t[B],R=u.getSize(),I=await u.readPixels();if(!I)throw new Error("Texture data is not available");const U=await Y.DumpTools.DumpDataAsync(R.width,R.height,I,"image/png",void 0,!1,!0);C[`textures/Texture_${B}.png`]=new Uint8Array(U).slice()}let G=0;for(const B in C){const u=C[B];if(!u)continue;G+=34+B.length;const R=63&G;if(4!==R){const I=new Uint8Array(64-R);C[B]=[u,{extra:{12345:I}}]}G=u.length}return fflate.zipSync(C,{level:0})}}}]);