"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[26],{11589:(R,J,B)=>{B.r(J),B.d(J,{EXT_materials_diffuse_roughness:()=>GJ,EXT_mesh_gpu_instancing:()=>KR,GLTF2Export:()=>bR,GLTFData:()=>e,KHR_draco_mesh_compression:()=>BJ,KHR_lights_punctual:()=>qJ,KHR_materials_anisotropy:()=>lJ,KHR_materials_clearcoat:()=>OJ,KHR_materials_diffuse_transmission:()=>AJ,KHR_materials_dispersion:()=>SJ,KHR_materials_emissive_strength:()=>aJ,KHR_materials_ior:()=>xJ,KHR_materials_iridescence:()=>VJ,KHR_materials_sheen:()=>HJ,KHR_materials_specular:()=>XJ,KHR_materials_transmission:()=>zJ,KHR_materials_unlit:()=>iJ,KHR_materials_volume:()=>kJ,KHR_texture_transform:()=>LJ,OBJExport:()=>N,STLExport:()=>jJ,USDZExportAsync:()=>JB,_ConvertToGLTFPBRMetallicRoughness:()=>p,_SolveMetallic:()=>z,__IGLTFExporterExtension:()=>r});var Q=B(11186),h=B(11030),y=B(11504);class N{static OBJ(R,J,B,N){const r=[];let q=1,e=1;J&&(B||(B="mat"),r.push("mtllib "+B+".mtl"));for(let D=0;D<R.length;D++){const B=R[D],l=B.name||`mesh${D}}`;r.push(`o ${l}`);let E=null;if(N){const R=B.ny(!0);E=new Q.Matrix,R.invertToRef(E),B.bakeTransformIntoVertices(R)}if(J){const R=B.material;R&&r.push("usemtl "+R.id)}const O=B.py;if(!O){h.Tools.Warn("No geometry is present on the mesh");continue}const n=O.getVerticesData("position"),P=O.getVerticesData("normal"),A=O.getVerticesData("uv"),u=O.hr();let S=0,f=0;if(!n||!u){h.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const a=R[0].IR().useRightHandedSystem?1:-1;for(let R=0;R<n.length;R+=3)r.push("v "+n[R]*a+" "+n[R+1]+" "+n[R+2]),S++;if(null!=P)for(let R=0;R<P.length;R+=3)r.push("vn "+P[R]*a+" "+P[R+1]+" "+P[R+2]);if(null!=A)for(let R=0;R<A.length;R+=2)r.push("vt "+A[R]+" "+A[R+1]),f++;const s=["","",""],x=(B.material||B.IR().defaultMaterial)._getEffectiveOrientation(B),[I,V]=x===y.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let R=0;R<u.length;R+=3){const J=[String(u[R]+q),String(u[R+I]+q),String(u[R+V]+q)],B=[String(u[R]+e),String(u[R+I]+e),String(u[R+V]+e)],Q=J,h=null!=A?B:s,y=null!=P?J:s;r.push("f "+Q[0]+"/"+h[0]+"/"+y[0]+" "+Q[1]+"/"+h[1]+"/"+y[1]+" "+Q[2]+"/"+h[2]+"/"+y[2])}N&&E&&B.bakeTransformIntoVertices(E),q+=S,e+=f}return r.join("\n")}static MTL(R){const J=[],B=R.material;J.push("newmtl mat1"),J.push("  Ns "+B.specularPower.toFixed(4)),J.push("  Ni 1.5000"),J.push("  d "+B.alpha.toFixed(4)),J.push("  Tr 0.0000"),J.push("  Tf 1.0000 1.0000 1.0000"),J.push("  illum 2"),J.push("  Ka "+B.ambientColor.r.toFixed(4)+" "+B.ambientColor.g.toFixed(4)+" "+B.ambientColor.b.toFixed(4)),J.push("  Kd "+B.diffuseColor.r.toFixed(4)+" "+B.diffuseColor.g.toFixed(4)+" "+B.diffuseColor.b.toFixed(4)),J.push("  Ks "+B.specularColor.r.toFixed(4)+" "+B.specularColor.g.toFixed(4)+" "+B.specularColor.b.toFixed(4)),J.push("  Ke "+B.emissiveColor.r.toFixed(4)+" "+B.emissiveColor.g.toFixed(4)+" "+B.emissiveColor.b.toFixed(4));B.ambientTexture&&J.push("  map_Ka "+B.ambientTexture.name),B.diffuseTexture&&J.push("  map_Kd "+B.diffuseTexture.name),B.specularTexture&&J.push("  map_Ks "+B.specularTexture.name),B.bumpTexture&&J.push("  map_bump -imfchan z "+B.bumpTexture.name),B.opacityTexture&&J.push("  map_d "+B.opacityTexture.name);return J.join("\n")}}var r=0,q=B(11073);class e{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const R in this.files){const J=this.files[R],B=new Blob([J],{type:(0,q.i)(R)});h.Tools.Download(B,R)}}}var D=B(11262),l=B(11595),E=B(11604),O=B(11624),n=B(11310),P=B(11065),A=B(11224),u=B(11201);const S=u.HighestCommonFactor,f={...u,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:S};var a=B(11408),s=B(11161),x=B(11653),I=B(11662),V=B(11402);const M=1e-6,H=new A.SJ(.04,.04,.04),d=1024,X=A.SJ.White(),c=A.SJ.Black();function z(R,J,B){if(J<H.r)return 0;const Q=H.r,h=R*B/(1-H.r)+J-2*H.r,y=h*h-4*Q*(H.r-J);return f.Clamp((-h+Math.sqrt(y))/(2*Q),0,1)}function p(R){const J=R.diffuseColor.toLinearSpace(R.IR().getEngine().useExactSrgbConversions).scale(.5),B=R.alpha,h=function(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Q.Vector2(0,1),B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Q.Vector2(0,.1),h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Q.Vector2(0,.1),y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new Q.Vector2(1300,.1);return function(R,J,B,Q,h){return(1-R)*(1-R)*(1-R)*J+3*(1-R)*(1-R)*R*B+3*(1-R)*R*R*Q+R*R*R*h}(Math.pow(R/y.x,.333333),J.y,B.y,h.y,y.y)}(f.Clamp(R.specularPower,0,d));return{baseColorFactor:[J.r,J.g,J.b,B],metallicFactor:0,roughnessFactor:h}}function i(R,J){J.needAlphaBlending()?R.alphaMode="BLEND":J.needAlphaTesting()&&(R.alphaMode="MASK",R.alphaCutoff=J.alphaCutOff)}function W(R,J,B){const Q=new Uint8Array(R*J*4);for(let h=0;h<Q.length;h+=4)Q[h]=Q[h+1]=Q[h+2]=Q[h+3]=255;return x.b.CreateRGBATexture(Q,R,J,B)}function k(R){if(R instanceof Uint8Array){const J=R.length,B=new Float32Array(R.length);for(let Q=0;Q<J;++Q)B[Q]=R[Q]/255;return B}if(R instanceof Float32Array)return R;throw new Error("Unsupported pixel format!")}class Y{constructor(R){this._exporter=R,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(R){return R?this._textureMap.get(R)??null:null}async exportStandardMaterialAsync(R,J,B){const Q=p(R),y={name:R.name};if(null==R.Pr||R.Pr||(R.twoSidedLighting||h.Tools.Warn(R.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),y.doubleSided=!0),B){const B=[],h=R.diffuseTexture;h&&B.push(this.exportTextureAsync(h,J).then((R=>{R&&(Q.baseColorTexture=R)})));const N=R.bumpTexture;N&&B.push(this.exportTextureAsync(N,J).then((R=>{R&&(y.normalTexture=R,1!==N.level&&(y.normalTexture.scale=N.level))})));const r=R.emissiveTexture;r&&(y.emissiveFactor=[1,1,1],B.push(this.exportTextureAsync(r,J).then((R=>{R&&(y.emissiveTexture=R)}))));const q=R.ambientTexture;q&&B.push(this.exportTextureAsync(q,J).then((R=>{if(R){const J={index:R.index};y.occlusionTexture=J}}))),B.length>0&&(this._exporter._materialNeedsUVsSet.add(R),await Promise.all(B))}(R.alpha<1||R.opacityTexture)&&(R.alphaMode===I.e.ALPHA_COMBINE?y.alphaMode="BLEND":h.Tools.Warn(R.name+": glTF 2.0 does not support alpha mode: "+R.alphaMode.toString())),R.emissiveColor&&!R.emissiveColor.equalsWithEpsilon(c,M)&&(y.emissiveFactor=R.emissiveColor.Ch()),y.pbrMetallicRoughness=Q,i(y,R),await this._finishMaterialAsync(y,R,J);const N=this._exporter._materials;return N.push(y),N.length-1}async _finishMaterialAsync(R,J,B){const Q=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",R,J),h=[];for(const y of Q)h.push(this.exportTextureAsync(y,B));await Promise.all(h),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",R,J)}async _getImageDataAsync(R,J,Q,h){const y=I.e.TEXTURETYPE_UNSIGNED_BYTE,N=this._exporter._babylonScene,r=N.getEngine(),q=r.createRawTexture(R,J,Q,I.e.TEXTUREFORMAT_RGBA,!1,!0,s.d.NEAREST_SAMPLINGMODE,null,y);r.isWebGPU?await B.e(51).then(B.bind(B,13671)):await B.e(52).then(B.bind(B,13677)),await a.j.ApplyPostProcess("pass",q,N,y,I.e.TEXTURE_NEAREST_SAMPLINGMODE,I.e.TEXTUREFORMAT_RGBA);const e=await r._readTexturePixels(q,J,Q);return await V.DumpTools.DumpDataAsync(J,Q,e,h,void 0,!0,!0)}_resizeTexturesToSameDimensions(R,J,B){const Q=R?R.getSize():{width:0,height:0},h=J?J.getSize():{width:0,height:0};let y,N;return Q.width<h.width?(y=R&&R instanceof s.d?a.j.CreateResizedCopy(R,h.width,h.height,!0):W(h.width,h.height,B),N=J):Q.width>h.width?(N=J&&J instanceof s.d?a.j.CreateResizedCopy(J,Q.width,Q.height,!0):W(Q.width,Q.height,B),y=R):(y=R,N=J),{texture1:y,texture2:N}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(R,J,B,Q){const h=new Array;if(!R&&!J)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const y=R?R.IR():J?J.IR():null;if(y){var N;const r=this._resizeTexturesToSameDimensions(R,J,y),q=null===(N=r.texture1)||void 0===N?void 0:N.getSize();let e,D;const l=q.width,E=q.height,O=await r.texture1.readPixels(),n=await r.texture2.readPixels();if(!O)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(e=k(O),!n)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");D=k(n);const P=D.byteLength,u=new Uint8Array(P),S=new Uint8Array(P),f=4,a=c;let s=0,x=0;for(let R=0;R<E;++R)for(let J=0;J<l;++J){const Q=(l*R+J)*f,h={diffuseColor:new A.SJ(e[Q],e[Q+1],e[Q+2]).toLinearSpace(y.getEngine().useExactSrgbConversions).multiply(B.diffuseColor),specularColor:new A.SJ(D[Q],D[Q+1],D[Q+2]).toLinearSpace(y.getEngine().useExactSrgbConversions).multiply(B.specularColor),glossiness:D[Q+3]*B.glossiness},N=this._convertSpecularGlossinessToMetallicRoughness(h);a.r=Math.max(a.r,N.baseColor.r),a.g=Math.max(a.g,N.baseColor.g),a.b=Math.max(a.b,N.baseColor.b),s=Math.max(s,N.metallic),x=Math.max(x,N.roughness),S[Q]=255*N.baseColor.r,S[Q+1]=255*N.baseColor.g,S[Q+2]=255*N.baseColor.b,S[Q+3]=r.texture1.bh?255*e[Q+3]:255,u[Q]=0,u[Q+1]=255*N.roughness,u[Q+2]=255*N.metallic,u[Q+3]=255}const I={baseColor:a,metallic:s,roughness:x};let V=!1,H=!1;for(let R=0;R<E;++R)for(let J=0;J<l;++J){const B=(l*R+J)*f;S[B]/=I.baseColor.r>M?I.baseColor.r:1,S[B+1]/=I.baseColor.g>M?I.baseColor.g:1,S[B+2]/=I.baseColor.b>M?I.baseColor.b:1;const Q=A.SJ.FromInts(S[B],S[B+1],S[B+2]).toGammaSpace(y.getEngine().useExactSrgbConversions);S[B]=255*Q.r,S[B+1]=255*Q.g,S[B+2]=255*Q.b,Q.equalsWithEpsilon(X,M)||(H=!0),u[B+1]/=I.roughness>M?I.roughness:1,u[B+2]/=I.metallic>M?I.metallic:1;A.SJ.FromInts(255,u[B+1],u[B+2]).equalsWithEpsilon(X,M)||(V=!0)}return V&&h.push(this._getImageDataAsync(u,l,E,Q).then((R=>{I.metallicRoughnessTextureData=R}))),H&&h.push(this._getImageDataAsync(S,l,E,Q).then((R=>{I.baseColorTextureData=R}))),await Promise.all(h).then((()=>I))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(R){const J=this._getPerceivedBrightness(R.diffuseColor),B=this._getPerceivedBrightness(R.specularColor),Q=1-this._getMaxComponent(R.specularColor),h=z(J,B,Q),y=R.diffuseColor.scale(Q/(1-H.r)/Math.max(1-h)),N=R.specularColor.PJ(H.scale(1-h)).scale(1/Math.max(h));let r=A.SJ.Lerp(y,N,h*h);r=r.clampToRef(0,1,r);return{baseColor:r,metallic:h,roughness:1-R.glossiness}}_getPerceivedBrightness(R){return R?Math.sqrt(.299*R.r*R.r+.587*R.g*R.g+.114*R.b*R.b):0}_getMaxComponent(R){return R?Math.max(R.r,Math.max(R.g,R.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(R,J,B,Q){const h=[],y={baseColor:R._albedoColor,metallic:R._metallic,roughness:R._roughness};if(Q){R._albedoTexture&&h.push(this.exportTextureAsync(R._albedoTexture,J).then((R=>{R&&(B.baseColorTexture=R)})));const Q=R._metallicTexture;Q&&h.push(this.exportTextureAsync(Q,J).then((R=>{R&&(B.metallicRoughnessTexture=R)})))}return h.length>0&&(this._exporter._materialNeedsUVsSet.add(R),await Promise.all(h)),y}_getTextureSampler(R){const J={};if(!R||!(R instanceof s.d))return J;const B=this._getGLTFTextureWrapMode(R.wrapU);10497!==B&&(J.wrapS=B);const Q=this._getGLTFTextureWrapMode(R.wrapV);switch(10497!==Q&&(J.wrapT=Q),R.samplingMode){case s.d.LINEAR_LINEAR:J.magFilter=9729,J.minFilter=9729;break;case s.d.LINEAR_NEAREST:J.magFilter=9729,J.minFilter=9728;break;case s.d.NEAREST_LINEAR:J.magFilter=9728,J.minFilter=9729;break;case s.d.NEAREST_LINEAR_MIPLINEAR:J.magFilter=9728,J.minFilter=9987;break;case s.d.NEAREST_NEAREST:J.magFilter=9728,J.minFilter=9728;break;case s.d.NEAREST_LINEAR_MIPNEAREST:J.magFilter=9728,J.minFilter=9985;break;case s.d.LINEAR_NEAREST_MIPNEAREST:J.magFilter=9729,J.minFilter=9984;break;case s.d.LINEAR_NEAREST_MIPLINEAR:J.magFilter=9729,J.minFilter=9986;break;case s.d.NEAREST_NEAREST_MIPLINEAR:J.magFilter=9728,J.minFilter=9986;break;case s.d.LINEAR_LINEAR_MIPLINEAR:J.magFilter=9729,J.minFilter=9987;break;case s.d.LINEAR_LINEAR_MIPNEAREST:J.magFilter=9729,J.minFilter=9985;break;case s.d.NEAREST_NEAREST_MIPNEAREST:J.magFilter=9728,J.minFilter=9984}return J}_getGLTFTextureWrapMode(R){switch(R){case s.d.WRAP_ADDRESSMODE:return 10497;case s.d.CLAMP_ADDRESSMODE:return 33071;case s.d.MIRROR_ADDRESSMODE:return 33648;default:return h.Tools.Error(`Unsupported Texture Wrap Mode ${R}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(R,J,B,Q){const h={diffuseColor:R._albedoColor,specularColor:R._reflectivityColor,glossiness:R._microSurface},y=R._albedoTexture,N=R._reflectivityTexture,r=R._useMicroSurfaceFromReflectivityMapAlpha;if(N&&!r)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((y||N)&&Q){this._exporter._materialNeedsUVsSet.add(R);const Q=this._exportTextureSampler(y||N),r=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(y,N,h,J),q=this._exporter._textures;if(r.baseColorTextureData){const R=this._exportImage(`baseColor${q.length}`,J,r.baseColorTextureData);B.baseColorTexture=this._exportTextureInfo(R,Q,null===y||void 0===y?void 0:y.coordinatesIndex)}if(r.metallicRoughnessTextureData){const R=this._exportImage(`metallicRoughness${q.length}`,J,r.metallicRoughnessTextureData);B.metallicRoughnessTexture=this._exportTextureInfo(R,Q,null===N||void 0===N?void 0:N.coordinatesIndex)}return r}return this._convertSpecularGlossinessToMetallicRoughness(h)}async exportPBRMaterialAsync(R,J,B){const Q={},h={name:R.name},y=R.isMetallicWorkflow();if(y){const J=R._albedoColor,B=R.alpha;J&&(Q.baseColorFactor=[J.r,J.g,J.b,B])}const N=y?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(R,J,Q,B):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(R,J,Q,B);await this._setMetallicRoughnessPbrMaterialAsync(N,R,h,Q,J,B),await this._finishMaterialAsync(h,R,J);const r=this._exporter._materials;return r.push(h),r.length-1}async _setMetallicRoughnessPbrMaterialAsync(R,J,B,Q,y,N){if(i(B,J),R.baseColor.equalsWithEpsilon(X,M)&&f.WithinEpsilon(J.alpha,1,M)||(Q.baseColorFactor=[R.baseColor.r,R.baseColor.g,R.baseColor.b,J.alpha]),null!=R.metallic&&1!==R.metallic&&(Q.metallicFactor=R.metallic),null!=R.roughness&&1!==R.roughness&&(Q.roughnessFactor=R.roughness),null==J.Pr||J.Pr||(J._twoSidedLighting||h.Tools.Warn(J.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),B.doubleSided=!0),N){const R=[],Q=J._bumpTexture;Q&&R.push(this.exportTextureAsync(Q,y).then((R=>{R&&(B.normalTexture=R,1!==Q.level&&(B.normalTexture.scale=Q.level))})));const h=J._ambientTexture;h&&R.push(this.exportTextureAsync(h,y).then((R=>{if(R){const Q={index:R.index,texCoord:R.texCoord,extensions:R.extensions};B.occlusionTexture=Q;const h=J._ambientTextureStrength;h&&(Q.strength=h)}})));const N=J._emissiveTexture;N&&R.push(this.exportTextureAsync(N,y).then((R=>{R&&(B.emissiveTexture=R)}))),R.length>0&&(this._exporter._materialNeedsUVsSet.add(J),await Promise.all(R))}const r=J._emissiveColor;r.equalsWithEpsilon(c,M)||(B.emissiveFactor=r.Ch()),B.pbrMetallicRoughness=Q}_getPixelsFromTextureAsync(R){return function(R){switch(R){case I.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case I.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case I.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case I.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case I.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case I.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case I.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case I.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case I.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case I.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case I.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case I.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case I.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case I.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case I.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case I.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case I.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case I.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case I.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case I.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case I.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(R.textureFormat)?(0,a.h)(R,R._texture.width,R._texture.height):(R.textureType,I.e.TEXTURETYPE_UNSIGNED_BYTE,R.readPixels())}async exportTextureAsync(R,J){const B=this._exporter._extensionsPreExportTextureAsync("exporter",R,J);return B?await B.then((async B=>B?await this._exportTextureInfoAsync(B,J):await this._exportTextureInfoAsync(R,J))):await this._exportTextureInfoAsync(R,J)}async _exportTextureInfoAsync(R,J){let B=this._textureMap.get(R);if(!B){const Q=await this._getPixelsFromTextureAsync(R);if(!Q)return null;const y=this._exportTextureSampler(R),N=R.mimeType;if(N)switch(N){case"image/jpeg":case"image/png":case"image/webp":J=N;break;default:h.Tools.Warn(`Unsupported media type: ${N}. Exporting texture as PNG.`)}const r=this._internalTextureToImage,q=R.getInternalTexture().uniqueId;r[q]||(r[q]={});let e=r[q][J];if(void 0===e){const B=R.getSize();e=(async()=>{const h=await this._getImageDataAsync(Q,B.width,B.height,J);return this._exportImage(R.name,J,h)})(),r[q][J]=e}B=this._exportTextureInfo(await e,y,R.coordinatesIndex),this._textureMap.set(R,B),this._exporter._extensionsPostExportTextures("exporter",B,R)}return B}_exportImage(R,J,B){const Q=this._exporter._images;let y;if(this._exporter._shouldUseGlb){y={name:R,mimeType:J,bufferView:void 0};const Q=this._exporter._bufferManager.createBufferView(new Uint8Array(B));this._exporter._bufferManager.setBufferView(y,Q)}else{const N=R.replace(/\.\/|\/|\.\\|\\/g,"_"),r=function(R){switch(R){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(J);let q=N+r;Q.some((R=>R.uri===q))&&(q=`${N}_${h.Tools.RandomId()}${r}`),y={name:R,uri:q},this._exporter._imageData[q]={data:B,mimeType:J}}return Q.push(y),Q.length-1}_exportTextureInfo(R,J,B){const Q=this._exporter._textures;let h=Q.findIndex((B=>B.sampler==J&&B.source===R));-1===h&&(h=Q.length,Q.push({source:R,sampler:J}));const y={index:h};return B&&(y.texCoord=B),y}_exportTextureSampler(R){const J=this._getTextureSampler(R),B=this._exporter._samplers,Q=B.findIndex((R=>R.minFilter===J.minFilter&&R.magFilter===J.magFilter&&R.wrapS===J.wrapS&&R.wrapT===J.wrapT));return-1!==Q?Q:(B.push(J),B.length-1)}}var G=B(11272),g=B(11043),L=B(11670),j=B(11189);const T=Q.nJ.Zero(),F=Q.Quaternion.Identity(),C=Q.nJ.One(),b=new Q.nJ(-1,1,1);function w(R,J){const{byteOffset:B,byteStride:Q,type:h,normalized:y}=R,N=R.getSize(),r=J.reduce(((R,J)=>J.getTotalVertices()>R?J.getTotalVertices():R),-Number.MAX_VALUE);return{byteOffset:B,byteStride:Q,componentCount:N,type:h,count:r*N,normalized:y,totalVertices:r,kind:R.getKind()}}function K(R){switch(R){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function v(R){switch(R){case D.h.PositionKind:case D.h.NormalKind:case D.h.TangentKind:case D.h.ColorKind:case D.h.MatricesIndicesKind:case D.h.MatricesIndicesExtraKind:case D.h.MatricesWeightsKind:case D.h.MatricesWeightsExtraKind:case D.h.UVKind:case D.h.UV2Kind:case D.h.UV3Kind:case D.h.UV4Kind:case D.h.UV5Kind:case D.h.UV6Kind:return!0}return!1}function m(R){switch(R){case y.b.TriangleFillMode:return 4;case y.b.TriangleStripDrawMode:return 5;case y.b.TriangleFanDrawMode:return 6;case y.b.PointListDrawMode:case y.b.PointFillMode:return 0;case y.b.LineLoopDrawMode:return 2;case y.b.LineListDrawMode:return 1;case y.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${R}`)}function o(R){const J=Math.sqrt(R.x*R.x+R.y*R.y+R.z*R.z);J>0&&(R.x/=J,R.y/=J,R.z/=J)}function t(R){return R.x*=-1,R}function Z(R){if(R.x*R.x+R.y*R.y>.5){const J=Math.abs(R.x),B=Math.abs(R.y);if(J>B){const B=Math.sign(R.x);R.x=J,R.y*=-B,R.z*=-B,R.w*=B}else{const J=Math.sign(R.y);R.x*=-J,R.y=B,R.z*=J,R.w*=-J}}else{const J=Math.abs(R.z),B=Math.abs(R.w);if(J>B){const B=Math.sign(R.z);R.x*=-B,R.y*=B,R.z=J,R.w*=-B}else{const J=Math.sign(R.w);R.x*=J,R.y*=-J,R.z*=-J,R.w=B}}return R}function U(R){R.Ar(-R.z,R.w,R.x,-R.y)}function RR(R,J){const B=Q.nJ.FromArrayToRef(J.translation||[0,0,0],0,Q.TmpVectors.nJ[0]),h=Q.Quaternion.FromArrayToRef(J.rotation||[0,0,0,1],0,Q.TmpVectors.Quaternion[0]),y=Q.Matrix.ComposeToRef(C,h,B,Q.TmpVectors.Matrix[0]),N=Q.nJ.FromArrayToRef(R.translation||[0,0,0],0,Q.TmpVectors.nJ[2]),r=Q.Quaternion.FromArrayToRef(R.rotation||[0,0,0,1],0,Q.TmpVectors.Quaternion[1]),q=Q.Matrix.ComposeToRef(C,r,N,Q.TmpVectors.Matrix[1]);y.multiplyToRef(q,q),q.decompose(void 0,h,B),B.equalsWithEpsilon(T,j.d)?delete J.translation:J.translation=B.Ch(),h.equalsWithEpsilon(F,j.d)?delete J.rotation:J.rotation=h.Ch(),J.scale&&delete J.scale}function JR(R,J){if(!(J instanceof l.e))return!1;if(!(1===J.getChildren().length&&0===R.getChildren().length&&R.parent===J))return!1;const B=R.IR(),Q=R instanceof L.e&&!B.useRightHandedSystem?b:C;return!!J.ur.equalsWithEpsilon(Q,j.d)||(g.d.Warn(`Cannot collapse node ${R.name} into parent node ${J.name} with modified scaling.`),!1)}function BR(R){if(R instanceof Array){const J=new Float32Array(R);return new Uint8Array(J.buffer,J.byteOffset,J.byteLength)}return ArrayBuffer.isView(R)?new Uint8Array(R.buffer,R.byteOffset,R.byteLength):new Uint8Array(R)}function QR(R,J){for(const[B,Q]of Object.entries(R)){const h=J[B];(Array.isArray(Q)&&Array.isArray(h)&&hR(Q,h)||Q===h)&&delete R[B]}return R}function hR(R,J){return R.length===J.length&&R.every(((R,B)=>R===J[B]))}const yR=Q.Matrix.Compose(new Q.nJ(-1,1,1),Q.Quaternion.Identity(),Q.nJ.Zero());function NR(R,J){if(!(R instanceof l.e))return!1;if(J){if(!R.getWorldMatrix().equalsWithEpsilon(Q.Matrix.IdentityReadOnly,j.d))return!1}else{if(!R.getWorldMatrix().multiplyToRef(yR,Q.TmpVectors.Matrix[0]).equalsWithEpsilon(Q.Matrix.IdentityReadOnly,j.d))return!1}return!(R instanceof E.d&&R.py)}const rR=new Map([[Int8Array,(R,J,B)=>R.setInt8(J,B)],[Uint8Array,(R,J,B)=>R.setUint8(J,B)],[Uint8ClampedArray,(R,J,B)=>R.setUint8(J,B)],[Int16Array,(R,J,B)=>R.setInt16(J,B,!0)],[Uint16Array,(R,J,B)=>R.setUint16(J,B,!0)],[Int32Array,(R,J,B)=>R.setInt32(J,B,!0)],[Uint32Array,(R,J,B)=>R.setUint32(J,B,!0)],[Float32Array,(R,J,B)=>R.setFloat32(J,B,!0)],[Float64Array,(R,J,B)=>R.setFloat64(J,B,!0)]]);class qR{writeTypedArray(R){this._checkGrowBuffer(R.byteLength);const J=rR.get(R.constructor);for(let B=0;B<R.length;B++)J(this._dataView,this._byteOffset,R[B]),this._byteOffset+=R.BYTES_PER_ELEMENT}constructor(R){this._data=new Uint8Array(R),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(R){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,R),this._byteOffset++}writeInt8(R){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,R),this._byteOffset++}writeInt16(R){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,R,!0),this._byteOffset+=2}writeUInt16(R){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,R,!0),this._byteOffset+=2}writeInt32(R){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,R,!0),this._byteOffset+=4}writeUInt32(R){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,R,!0),this._byteOffset+=4}writeFloat32(R){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,R,!0),this._byteOffset+=4}writeFloat64(R){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,R,!0),this._byteOffset+=8}_checkGrowBuffer(R){const J=this.byteOffset+R;if(J>this._data.byteLength){const R=new Uint8Array(2*J);R.set(this._data),this._data=R,this._dataView=new DataView(this._data.buffer)}}}function eR(R){return R%4===0?4:R%2===0?2:1}class DR{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(R){let J=0;this._bufferViewToData.forEach((R=>{J+=R.byteLength}));const B=new qR(J),Q=Array.from(this._bufferViewToData.keys()).sort(((R,J)=>eR(J.byteLength)-eR(R.byteLength)));for(const h of Q){h.byteOffset=B.byteOffset,R.push(h);const J=R.length-1,Q=this.getPropertiesWithBufferView(h);for(const R of Q)R.bufferView=J;B.writeTypedArray(this._bufferViewToData.get(h)),this._bufferViewToData.delete(h)}return B.getOutputData()}createBufferView(R,J){const B={buffer:0,byteOffset:void 0,byteLength:R.byteLength,byteStride:J};return this._bufferViewToData.set(B,R),B}createAccessor(R,J,B,Q,h,y,N){this._verifyBufferView(R);const r={bufferView:void 0,componentType:B,count:Q,type:J,min:null===y||void 0===y?void 0:y.min,max:null===y||void 0===y?void 0:y.max,normalized:N,byteOffset:h};return this.setBufferView(r,R),this._accessorToBufferView.set(r,R),r}setBufferView(R,J){this._verifyBufferView(J);this.getPropertiesWithBufferView(J).push(R)}removeBufferView(R){const J=this.getPropertiesWithBufferView(R);for(const B of J)void 0!==B.bufferView&&delete B.bufferView;this._bufferViewToData.delete(R),this._bufferViewToProperties.delete(R),this._accessorToBufferView.forEach(((J,B)=>{J===R&&(void 0!==B.byteOffset&&delete B.byteOffset,this._accessorToBufferView.delete(B))}))}getBufferView(R){const J=this._accessorToBufferView.get(R);return this._verifyBufferView(J),J}getPropertiesWithBufferView(R){return this._verifyBufferView(R),this._bufferViewToProperties.set(R,this._bufferViewToProperties.get(R)??[]),this._bufferViewToProperties.get(R)}getData(R){return this._verifyBufferView(R),this._bufferViewToData.get(R)}_verifyBufferView(R){if(void 0===R||!this._bufferViewToData.has(R))throw new Error(`BufferView ${R} not found in BufferManager.`)}}var lR,ER=B(11634),OR=B(11650),nR=B(11679),PR=B(11551),AR=B(11718),uR=B(11728),SR=B(11628),fR=B(11733);!function(R){R[R.INTANGENT=0]="INTANGENT",R[R.OUTTANGENT=1]="OUTTANGENT"}(lR||(lR={}));class aR{static _IsTransformable(R){return R&&(R instanceof l.e||R instanceof ER.d||R instanceof fR.e)}static _CreateNodeAnimation(R,J,B,Q,y){if(this._IsTransformable(R)){const N=[],r=[],q=J.getKeys(),e=aR._CalculateMinMaxKeyFrames(q),D=aR._DeduceInterpolation(q,B,Q),l=D.interpolationType,E=D.shouldBakeAnimation;if(E?aR._CreateBakedAnimation(R,J,B,e.min,e.max,J.framePerSecond,y,N,r,e,Q):"LINEAR"===l||"STEP"===l?aR._CreateLinearOrStepAnimation(R,J,B,N,r,Q):"CUBICSPLINE"===l?aR._CreateCubicSplineAnimation(R,J,B,N,r,Q):aR._CreateBakedAnimation(R,J,B,e.min,e.max,J.framePerSecond,y,N,r,e,Q),N.length&&r.length){return{inputs:N,outputs:r,samplerInterpolation:l,inputsMin:E?e.min:h.Tools.FloatRound(e.min/J.framePerSecond),inputsMax:E?e.max:h.Tools.FloatRound(e.max/J.framePerSecond)}}}return null}static _DeduceAnimationInfo(R){let J=null,B="VEC3",Q=!1;const y=R.targetProperty.split(".");switch(y[0]){case"ur":J="scale";break;case"position":J="translation";break;case"rotation":B="VEC4",J="rotation";break;case"rotationQuaternion":B="VEC4",Q=!0,J="rotation";break;case"influence":B="SCALAR",J="weights";break;default:h.Tools.Error(`Unsupported animatable property ${y[0]}`)}return J?{animationChannelTargetPath:J,dataAccessorType:B,useQuaternion:Q}:(h.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(R,J,B,Q,h,y,N,r,q,e,D){let l;if(aR._IsTransformable(R)&&R.animations)for(const E of R.animations){if(D&&!D(E))continue;const h=aR._DeduceAnimationInfo(E);h&&(l={name:E.name,samplers:[],channels:[]},aR._AddAnimation(`${E.name}`,E.hasRunningRuntimeAnimations?J:l,R,E,h.dataAccessorType,h.animationChannelTargetPath,Q,y,N,r,h.useQuaternion,q,e),l.samplers.length&&l.channels.length&&B.push(l))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(R,J,B,Q,h,y,N,r,q,e,D){let l;if(R instanceof SR.e){const h=R.morphTargetManager;if(h)for(let E=0;E<h.numTargets;++E){const O=h.getTarget(E);for(const n of O.animations){if(D&&!D(n))continue;const O=new AR.c(`${n.name}`,"influence",n.framePerSecond,n.dataType,n.loopMode,n.enableBlending),P=[],A=n.getKeys();for(let R=0;R<A.length;++R){const J=A[R];for(let R=0;R<h.numTargets;++R)R==E?P.push(J):P.push({frame:J.frame,value:0})}O.setKeys(P);const u=aR._DeduceAnimationInfo(O);u&&(l={name:O.name,samplers:[],channels:[]},aR._AddAnimation(n.name,n.hasRunningRuntimeAnimations?J:l,R,O,u.dataAccessorType,u.animationChannelTargetPath,Q,y,N,r,u.useQuaternion,q,e,h.numTargets),l.samplers.length&&l.channels.length&&B.push(l))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(R,J,B,Q,h,y,N,r,q){let e;if(R.animationGroups){const l=R.animationGroups;for(const E of l){const l=new Map,O=new Map,n=new Set,P=E.to-E.from;e={name:E.name,channels:[],samplers:[]};for(let J=0;J<E.targetedAnimations.length;++J){const P=E.targetedAnimations[J],A=P.target,u=P.animation;if(q&&!q(u))continue;const S=r.has(A);if(this._IsTransformable(A)||1===A.length&&this._IsTransformable(A[0])){const R=aR._DeduceAnimationInfo(P.animation);if(R){const J=this._IsTransformable(A)?A:this._IsTransformable(A[0])?A[0]:null;J&&aR._AddAnimation(`${u.name}`,e,J,u,R.dataAccessorType,R.animationChannelTargetPath,B,Q,h,y,R.useQuaternion,N,S)}}else if(A instanceof uR.e||1===A.length&&A[0]instanceof uR.e){if(aR._DeduceAnimationInfo(P.animation)){const J=A instanceof uR.e?A:A[0];if(J){const B=R.morphTargetManagers.find((R=>{for(let B=0;B<R.numTargets;++B)if(R.getTarget(B)===J)return!0;return!1}));if(B){const Q=R.meshes.find((R=>R.morphTargetManager===B));var D;if(Q)l.has(Q)||l.set(Q,new Map),null===(D=l.get(Q))||void 0===D||D.set(J,u),n.add(Q),O.set(Q,u)}}}}}n.forEach((R=>{const J=R.morphTargetManager;let r=null;const q=[],D=O.get(R).getKeys(),n=D.length;for(let B=0;B<n;++B)for(let Q=0;Q<J.numTargets;++Q){const h=J.getTarget(Q),y=l.get(R);if(y){const J=y.get(h);J?(r||(r=new AR.c(`${E.name}_${R.name}_MorphWeightAnimation`,"influence",J.framePerSecond,AR.c.ANIMATIONTYPE_FLOAT,J.loopMode,J.enableBlending)),q.push(J.getKeys()[B])):q.push({frame:E.from+P/n*B,value:h.influence,inTangent:D[0].inTangent?0:void 0,outTangent:D[0].outTangent?0:void 0})}}r.setKeys(q);const A=aR._DeduceAnimationInfo(r);A&&aR._AddAnimation(`${E.name}_${R.name}_MorphWeightAnimation`,e,R,r,A.dataAccessorType,A.animationChannelTargetPath,B,Q,h,y,A.useQuaternion,N,!1,null===J||void 0===J?void 0:J.numTargets)})),e.channels.length&&e.samplers.length&&J.push(e)}}}static _AddAnimation(R,J,B,h,y,N,r,q,e,D,l,E,O,n){const P=aR._CreateNodeAnimation(B,h,N,l,E);let A,u,S,f,a,s;if(P){if(n){let R=0,J=0;const B=[];for(;P.inputs.length>0;)J=P.inputs.shift(),R%n==0&&B.push(J),R++;P.inputs=B}const R=r.get(B),h=new Float32Array(P.inputs);A=q.createBufferView(h),u=q.createAccessor(A,"SCALAR",5126,P.inputs.length,void 0,{min:[P.inputsMin],max:[P.inputsMax]}),D.push(u),S=D.length-1;const e=new Q.Quaternion,l=new Q.nJ,E=new Q.nJ,x=B instanceof ER.d,I=K(y),V=new Float32Array(P.outputs.length*I);P.outputs.forEach((function(R,J){let B=R;switch(N){case"translation":O&&(Q.nJ.FromArrayToRef(R,0,E),t(E),E.toArray(B));break;case"rotation":4===R.length?Q.Quaternion.FromArrayToRef(R,0,e):(B=new Array(4),Q.nJ.FromArrayToRef(R,0,l),Q.Quaternion.FromEulerVectorToRef(l,e)),O&&(Z(e),x&&U(e)),e.toArray(B)}V.set(B,J*I)})),A=q.createBufferView(V),u=q.createAccessor(A,y,5126,P.outputs.length),D.push(u),f=D.length-1,a={interpolation:P.samplerInterpolation,input:S,output:f},J.samplers.push(a),s={sampler:J.samplers.length-1,target:{node:R,path:N}},J.channels.push(s)}}static _CreateBakedAnimation(R,J,B,y,N,r,q,e,D,l,E){let O;const n=Q.Quaternion.Identity();let P,A=null,u=null,S=null,f=null,a=null,s=null;l.min=h.Tools.FloatRound(y/r);const x=J.getKeys();for(let Q=0,I=x.length;Q<I;++Q){if(s=null,S=x[Q],Q+1<I)if(f=x[Q+1],S.value.equals&&S.value.equals(f.value)||S.value===f.value){if(0!==Q)continue;s=S.frame}else s=f.frame;else{if(a=x[Q-1],S.value.equals&&S.value.equals(a.value)||S.value===a.value)continue;s=N}if(s)for(let Q=S.frame;Q<=s;Q+=q){if(P=h.Tools.FloatRound(Q/r),P===A)continue;A=P,u=P;const y={key:0,repeatCount:0,loopMode:J.loopMode};O=J._interpolate(Q,y),aR._SetInterpolatedValue(R,O,P,J,B,n,e,D,E)}}u&&(l.max=u)}static _ConvertFactorToVector3OrQuaternion(R,J,B,y,N){const r=aR._GetBasePositionRotationOrScale(J,y,N),q=B.targetProperty.split("."),e=q?q[1]:"",D=N?Q.Quaternion.fJ(r).normalize():Q.nJ.fJ(r);switch(e){case"x":case"y":case"z":D[e]=R;break;case"w":D.w=R;break;default:h.Tools.Error(`glTFAnimation: Unsupported component name "${e}"!`)}return D}static _SetInterpolatedValue(R,J,B,h,y,N,r,q,e){let D;r.push(B),"weights"!==y?(h.dataType===AR.c.ANIMATIONTYPE_FLOAT&&(J=this._ConvertFactorToVector3OrQuaternion(J,R,h,y,e)),"rotation"===y?(e?N=J:(D=J,Q.Quaternion.RotationYawPitchRollToRef(D.y,D.x,D.z,N)),q.push(N.Ch())):(D=J,q.push(D.Ch()))):q.push([J])}static _CreateLinearOrStepAnimation(R,J,B,Q,h,y){for(const N of J.getKeys())Q.push(N.frame/J.framePerSecond),aR._AddKeyframeValue(N,J,h,B,R,y)}static _CreateCubicSplineAnimation(R,J,B,Q,h,y){J.getKeys().forEach((function(N){Q.push(N.frame/J.framePerSecond),aR._AddSplineTangent(lR.INTANGENT,h,B,"CUBICSPLINE",N,y),aR._AddKeyframeValue(N,J,h,B,R,y),aR._AddSplineTangent(lR.OUTTANGENT,h,B,"CUBICSPLINE",N,y)}))}static _GetBasePositionRotationOrScale(R,J,B){let h;if("rotation"===J)if(B){h=(R.rotationQuaternion??Q.Quaternion.Identity()).Ch()}else{h=(R.rotation??Q.nJ.Zero()).Ch()}else if("translation"===J){h=(R.position??Q.nJ.Zero()).Ch()}else{h=(R.ur??Q.nJ.One()).Ch()}return h}static _AddKeyframeValue(R,J,B,y,N,r){let q;const e=J.dataType;if(e===AR.c.ANIMATIONTYPE_VECTOR3){let J=R.value.Ch();if("rotation"===y){const R=Q.nJ.fJ(J);J=Q.Quaternion.RotationYawPitchRoll(R.y,R.x,R.z).Ch()}B.push(J)}else if(e===AR.c.ANIMATIONTYPE_FLOAT){if("weights"===y)B.push([R.value]);else if(q=this._ConvertFactorToVector3OrQuaternion(R.value,N,J,y,r),q){if("rotation"===y){const R=r?q:Q.Quaternion.RotationYawPitchRoll(q.y,q.x,q.z).normalize();B.push(R.Ch())}B.push(q.Ch())}}else e===AR.c.ANIMATIONTYPE_QUATERNION?B.push(R.value.normalize().Ch()):h.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(R,J,B){let Q,h,y=!1;if("rotation"===J&&!B)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let N=0,r=R.length;N<r;++N)if(h=R[N],h.inTangent||h.outTangent)if(Q){if("CUBICSPLINE"!==Q){Q="LINEAR",y=!0;break}}else Q="CUBICSPLINE";else if(Q){if("CUBICSPLINE"===Q||h.interpolation&&1===h.interpolation&&"STEP"!==Q){Q="LINEAR",y=!0;break}}else Q=h.interpolation&&1===h.interpolation?"STEP":"LINEAR";return Q||(Q="LINEAR"),{interpolationType:Q,shouldBakeAnimation:y}}static _AddSplineTangent(R,J,B,h,y,N){let r;const q=R===lR.INTANGENT?y.inTangent:y.outTangent;if("CUBICSPLINE"===h){if("rotation"===B)if(q)if(N)r=q.Ch();else{const R=q;r=Q.Quaternion.RotationYawPitchRoll(R.y,R.x,R.z).Ch()}else r=[0,0,0,0];else r="weights"===B?q?[q]:[0]:q?q.Ch():[0,0,0];J.push(r)}}static _CalculateMinMaxKeyFrames(R){let J=1/0,B=-1/0;return R.forEach((function(R){J=Math.min(J,R.frame),B=Math.max(B,R.frame)})),{min:J,max:B}}}function sR(R,J,B,y,N,r){const q={attributes:{},influence:R.influence,name:R.name},e=J.py;if(!e)return h.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),q;const l=r?-1:1,E=Q.nJ.Zero();let O=0,n=0;if(R.hasPositions){const y=R.getPositions(),r=e.getVerticesData(D.h.PositionKind);if(r){const R=new Float32Array(r.length),J=[1/0,1/0,1/0],h=[-1/0,-1/0,-1/0];n=r.length/3,O=0;for(let B=O;B<n;++B){const N=Q.nJ.fJ(r,3*B);Q.nJ.fJ(y,3*B).subtractToRef(N,E),E.x*=l,J[0]=Math.min(J[0],E.x),h[0]=Math.max(h[0],E.x),J[1]=Math.min(J[1],E.y),h[1]=Math.max(h[1],E.y),J[2]=Math.min(J[2],E.z),h[2]=Math.max(h[2],E.z),R[3*B]=E.x,R[3*B+1]=E.y,R[3*B+2]=E.z}const e=B.createBufferView(R,12),D=B.createAccessor(e,"VEC3",5126,y.length/3,0,{min:J,max:h});N.push(D),q.attributes.POSITION=N.length-1}else h.Tools.Warn(`Morph target positions for mesh ${J.name} were not exported. Mesh does not have position vertex data`)}if(R.hasNormals){const y=R.getNormals(),r=e.getVerticesData(D.h.NormalKind);if(r){const R=new Float32Array(r.length);n=r.length/3,O=0;for(let B=O;B<n;++B){const J=Q.nJ.fJ(r,3*B).normalize();Q.nJ.fJ(y,3*B).normalize().subtractToRef(J,E),R[3*B]=E.x*l,R[3*B+1]=E.y,R[3*B+2]=E.z}const J=B.createBufferView(R,12),h=B.createAccessor(J,"VEC3",5126,y.length/3,0);N.push(h),q.attributes.NORMAL=N.length-1}else h.Tools.Warn(`Morph target normals for mesh ${J.name} were not exported. Mesh does not have normals vertex data`)}if(R.hasTangents){const y=R.getTangents(),r=e.getVerticesData(D.h.TangentKind);if(r){n=r.length/4;const R=new Float32Array(3*n);O=0;for(let B=O;B<n;++B){const J=Q.nJ.fJ(r,4*B);o(J);const h=Q.nJ.fJ(y,3*B);o(h),h.subtractToRef(J,E),R[3*B]=E.x*l,R[3*B+1]=E.y,R[3*B+2]=E.z}const J=B.createBufferView(R,12),h=B.createAccessor(J,"VEC3",5126,n,0);N.push(h),q.attributes.TANGENT=N.length-1}else h.Tools.Warn(`Morph target tangents for mesh ${J.name} were not exported. Mesh does not have tangents vertex data`)}if(R.hasColors){const y=R.getColors(),r=e.getVerticesData(D.h.ColorKind),l=e.getVertexBuffer(D.h.ColorKind);if(r&&l){const R=l.getSize();n=r.length/R;const J=new Float32Array(n*R);O=0;for(let B=O;B<n;++B)if(3===R){const h=Q.nJ.fJ(r,B*R);Q.nJ.fJ(y,B*R).subtractToRef(h,E),J[3*B]=E.x,J[3*B+1]=E.y,J[3*B+2]=E.z}else if(4===R){const h=new Q.Vector4,N=Q.Vector4.fJ(r,B*R);Q.Vector4.fJ(y,B*R).subtractToRef(N,h),J[4*B]=h.x,J[4*B+1]=h.y,J[4*B+2]=h.z,J[4*B+3]=h.w}else h.Tools.Warn(`Unsupported number of components for color attribute: ${R}`);const e=B.createBufferView(J,4*R),D=B.createAccessor(e,3===R?"VEC3":"VEC4",5126,n,0);N.push(D),q.attributes.COLOR_0=N.length-1}else h.Tools.Warn(`Morph target colors for mesh ${J.name} were not exported. Mesh does not have colors vertex data`)}return q}var xR=B(11741),IR=B(11579),VR=B(11559),MR=B(11142);class HR{}HR.DEFAULT_COLOR=A.SJ.White(),HR.DEFAULT_WIDTH_ATTENUATED=1,HR.DEFAULT_WIDTH=.1;var dR=B(11392),XR=B(11747);class cR{static ConvertPoints(R,J){if(R.length&&Array.isArray(R)&&"number"===typeof R[0])return[R];if(R.length&&Array.isArray(R[0])&&"number"===typeof R[0][0])return R;if(R.length&&!Array.isArray(R[0])&&R[0]instanceof Q.nJ){const J=[];for(let B=0;B<R.length;B++){const Q=R[B];J.push(Q.x,Q.y,Q.z)}return[J]}if(R.length>0&&Array.isArray(R[0])&&R[0].length>0&&R[0][0]instanceof Q.nJ){const J=[],B=R;for(const R of B)J.push(R.flatMap((R=>[R.x,R.y,R.z])));return J}if(R instanceof Float32Array){if(null!==J&&void 0!==J&&J.floatArrayStride){const B=[],Q=3*J.floatArrayStride;for(let J=0;J<R.length;J+=Q){const h=new Array(Q);for(let B=0;B<Q;B++)h[B]=R[J+B];B.push(h)}return B}return[Array.from(R)]}if(R.length&&R[0]instanceof Float32Array){const J=[];for(const B of R)J.push(Array.from(B));return J}return[]}static OmitZeroLengthPredicate(R,J,B){const Q=[];return J.PJ(R).lengthSquared()>0&&Q.push([R,J]),B.PJ(J).lengthSquared()>0&&Q.push([J,B]),R.PJ(B).lengthSquared()>0&&Q.push([B,R]),0===Q.length?null:Q}static OmitDuplicatesPredicate(R,J,B,Q){const h=[];return cR._SearchInPoints(R,J,Q)||h.push([R,J]),cR._SearchInPoints(J,B,Q)||h.push([J,B]),cR._SearchInPoints(B,R,Q)||h.push([B,R]),0===h.length?null:h}static _SearchInPoints(R,J,B){for(const N of B)for(let B=0;B<N.length;B++){var Q,h,y;if(null!==(Q=N[B])&&void 0!==Q&&Q.equals(R))if(null!==(h=N[B+1])&&void 0!==h&&h.equals(J)||null!==(y=N[B-1])&&void 0!==y&&y.equals(J))return!0}return!1}static MeshesToLines(R,J){const B=[];for(let h=0;h<R.length;h++){const y=R[h],N=y.getVerticesData(D.h.PositionKind),r=y.hr();if(N&&r)for(let R=0,q=0;R<r.length;R++){const e=3*r[q++],D=3*r[q++],l=3*r[q++],E=new Q.nJ(N[e],N[e+1],N[e+2]),O=new Q.nJ(N[D],N[D+1],N[D+2]),n=new Q.nJ(N[l],N[l+1],N[l+2]);if(J){const Q=J(E,O,n,B,R,e,y,h,N,r);if(Q)for(const R of Q)B.push(R)}else B.push([E,O],[O,n],[n,E])}}return B}static ToVector3Array(R){if(Array.isArray(R[0])){const J=[],B=R;for(const R of B){const B=[];for(let J=0;J<R.length;J+=3)B.push(new Q.nJ(R[J],R[J+1],R[J+2]));J.push(B)}return J}const J=R,B=[];for(let h=0;h<J.length;h+=3)B.push(new Q.nJ(J[h],J[h+1],J[h+2]));return B}static ToNumberArray(R){return R.flatMap((R=>[R.x,R.y,R.z]))}static GetPointsCountInfo(R){const J=new Array(R.length);let B=0;for(let Q=R.length;Q--;)J[Q]=R[Q].length/3,B+=J[Q];return{total:B,counts:J}}static GetLineLength(R){if(0===R.length)return 0;let J;J="number"===typeof R[0]?cR.ToVector3Array(R):R;const B=Q.TmpVectors.nJ[0];let h=0;for(let Q=0;Q<J.length-1;Q++){const R=J[Q];h+=J[Q+1].subtractToRef(R,B).length()}return h}static GetLineLengthArray(R){const J=new Float32Array(R.length/3);let B=0;for(let Q=0,h=R.length/3-1;Q<h;Q++){let h=R[3*Q+0],y=R[3*Q+1],N=R[3*Q+2];h-=R[3*Q+3],y-=R[3*Q+4],N-=R[3*Q+5];B+=Math.sqrt(h*h+y*y+N*N),J[Q+1]=B}return J}static SegmentizeSegmentByCount(R,J,B){const h=[],y=J.PJ(R),N=Q.TmpVectors.nJ[0];N.Sr(B);const r=Q.TmpVectors.nJ[1];y.divideToRef(N,r);let q=R.clone();h.push(q);for(let Q=0;Q<B;Q++)q=q.clone(),h.push(q.addInPlace(r));return h}static SegmentizeLineBySegmentLength(R,J){const B=R[0]instanceof Q.nJ?cR.GetLineSegments(R):"number"===typeof R[0]?cR.GetLineSegments(cR.ToVector3Array(R)):R,h=[];for(const Q of B)if(Q.length>J){const R=cR.SegmentizeSegmentByCount(Q.point1,Q.point2,Math.ceil(Q.length/J));for(const J of R)h.push(J)}else h.push(Q.point1),h.push(Q.point2);return h}static SegmentizeLineBySegmentCount(R,J){const B="number"===typeof R[0]?cR.ToVector3Array(R):R,Q=cR.GetLineLength(B)/J;return cR.SegmentizeLineBySegmentLength(B,Q)}static GetLineSegments(R){const J=[];for(let B=0;B<R.length-1;B++){const Q=R[B],h=R[B+1],y=h.PJ(Q).length();J.push({point1:Q,point2:h,length:y})}return J}static GetMinMaxSegmentLength(R){const J=cR.GetLineSegments(R).sort((R=>R.length));return{min:J[0].length,max:J[J.length-1].length}}static GetPositionOnLineByVisibility(R,J,B){let h=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const y=J*B;let N=0,r=0;const q=R.length;for(let Q=0;Q<q;Q++){if(y<=N+R[Q].length){r=Q;break}N+=R[Q].length}const e=(y-N)/R[r].length;return R[r].point2.subtractToRef(R[r].point1,Q.TmpVectors.nJ[0]),Q.TmpVectors.nJ[1]=Q.TmpVectors.nJ[0].multiplyByFloats(e,e,e),h||Q.TmpVectors.nJ[1].addInPlace(R[r].point1),Q.TmpVectors.nJ[1].clone()}static GetCircleLinePoints(R,J){let B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:R,y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/J;const N=[];for(let r=0;r<=J;r++)N.push(new Q.nJ(Math.cos(r*y)*R,Math.sin(r*y)*h,B));return N}static GetBezierLinePoints(R,J,B,Q){return dR.f.CreateQuadraticBezier(R,J,B,Q).getPoints().flatMap((R=>[R.x,R.y,R.z]))}static GetArrowCap(R,J,B,Q,h){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,N=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[R.clone(),R.add(J.multiplyByFloats(B,B,B))],widths:[Q,h,y,N]}}static GetPointsFromText(R,J,B,Q){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const N=[],r=(0,XR.e)(R,J,B,Q);for(const q of r){for(const R of q.paths){const J=[],B=R.getPoints();for(const R of B)J.push(R.x,R.y,h);N.push(J)}if(y)for(const R of q.holes){const J=[],B=R.getPoints();for(const R of B)J.push(R.x,R.y,h);N.push(J)}}return N}static Color3toRGBAUint8(R){const J=new Uint8Array(4*R.length);for(let B=0,Q=0;B<R.length;B++)J[Q++]=255*R[B].r,J[Q++]=255*R[B].g,J[Q++]=255*R[B].b,J[Q++]=255;return J}static CreateColorsTexture(R,J,B,Q){const h=Q.getEngine().getCaps().maxTextureSize??1,y=J.length>h?h:J.length,N=Math.ceil(J.length/h);N>1&&(J=[...J,...Array(y*N-J.length).fill(J[0])]);const r=cR.Color3toRGBAUint8(J),q=new x.b(r,y,N,n.d.TEXTUREFORMAT_RGBA,Q,!1,!0,B);return q.name=R,q}static PrepareEmptyColorsTexture(R){if(!HR.EmptyColorsTexture){const J=new Uint8Array(4);HR.EmptyColorsTexture=new x.b(J,1,1,n.d.TEXTUREFORMAT_RGBA,R,!1,!1,x.b.NEAREST_NEAREST),HR.EmptyColorsTexture.name="grlEmptyColorsTexture"}return HR.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var R;null===(R=HR.EmptyColorsTexture)||void 0===R||R.dispose(),HR.EmptyColorsTexture=null}static BooleanToNumber(R){return R?1:0}}class zR extends VR.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class pR extends IR.d{isCompatible(R){return!0}constructor(R,J,B){var h;B=B||{color:HR.DEFAULT_COLOR};const y=new zR;y.GREASED_LINE_HAS_COLOR=!!B.color&&!B.useColors,y.GREASED_LINE_SIZE_ATTENUATION=B.sizeAttenuation??!1,y.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===B.colorDistributionType,y.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(J??R.IR()).useRightHandedSystem,y.GREASED_LINE_CAMERA_FACING=B.cameraFacing??!0,super(R,pR.GREASED_LINE_MATERIAL_NAME,200,y,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(h=B)||void 0===h?void 0:h.forceGLSL)||pR.ForceGLSL,this._scene=J??R.IR(),this._engine=this._scene.getEngine(),this._cameraFacing=B.cameraFacing??!0,this.visibility=B.visibility??1,this.useDash=B.useDash??!1,this.dashRatio=B.dashRatio??.5,this.dashOffset=B.dashOffset??0,this.width=B.width?B.width:B.sizeAttenuation?HR.DEFAULT_WIDTH_ATTENUATED:HR.DEFAULT_WIDTH,this._sizeAttenuation=B.sizeAttenuation??!1,this.colorMode=B.colorMode??0,this._color=B.color??null,this.useColors=B.useColors??!1,this._colorsDistributionType=B.colorDistributionType??0,this.colorsSampling=B.colorsSampling??x.b.NEAREST_NEAREST,this._colors=B.dR??null,this.dashCount=B.dashCount??1,this.resolution=B.resolution??new Q.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),B.colorsTexture?this.colorsTexture=B.colorsTexture:this._colors?this.colorsTexture=cR.CreateColorsTexture(`${R.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??HR.DEFAULT_COLOR,cR.PrepareEmptyColorsTexture(this._scene)),this._engine.eh.add((()=>{cR.DisposeEmptyColorsTexture()}))}getAttributes(R){R.push("grl_offsets"),R.push("grl_widths"),R.push("grl_colorPointers"),R.push("grl_counters"),this._cameraFacing?(R.push("grl_previousAndSide"),R.push("grl_nextAndCounters")):R.push("grl_slopes")}getSamplers(R){R.push("grl_colors")}getActiveTextures(R){this.colorsTexture&&R.push(this.colorsTexture)}getUniforms(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const J=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&J.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===R&&J.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:J,vertex:this._cameraFacing&&this._isGLSL(R)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(R)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(R){if(this._cameraFacing){R.th("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||R.th("viewProjection",this._scene.getTransformMatrix());const J=Q.TmpVectors.Vector4[0];J.x=this._aspect,J.y=this._resolution.x,J.z=this._resolution.y,J.w=this.width,R.updateVector4("grl_aspect_resolution_lineWidth",J)}const J=Q.TmpVectors.Vector4[0];J.x=cR.BooleanToNumber(this.useDash),J.y=this._dashArray,J.z=this.dashOffset,J.w=this.dashRatio,R.updateVector4("grl_dashOptions",J);const B=Q.TmpVectors.Vector4[1];B.x=this.colorMode,B.y=this.visibility,B.z=this.colorsTexture?this.colorsTexture.getSize().width:0,B.w=cR.BooleanToNumber(this.useColors),R.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",B),this._color&&R.updateColor3("grl_singleColor",this._color);const h=this.colorsTexture??HR.EmptyColorsTexture;R.setTexture("grl_colors",h),R.updateFloat2("grl_textureSize",(null===h||void 0===h?void 0:h.getSize().width)??1,(null===h||void 0===h?void 0:h.getSize().height)??1)}prepareDefines(R,J,B){R.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,R.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,R.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,R.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=J.useRightHandedSystem,R.GREASED_LINE_CAMERA_FACING=this._cameraFacing,R.GREASED_LINE_USE_OFFSETS=!!B.offsets}getClassName(){return pR.GREASED_LINE_MATERIAL_NAME}getCustomCode(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(J)?function(R,J){if("vertex"===R){const R={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return J&&(R["!gl_Position\\=viewProjection\\*worldPos;"]="//"),R}return"fragment"===R?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(R,this._cameraFacing):function(R,J){if("vertex"===R){const R={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return J&&(R["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),R}return"fragment"===R?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(R,this._cameraFacing)}dispose(){var R;null===(R=this.colorsTexture)||void 0===R||R.dispose(),super.dispose()}get dR(){return this._colors}set dR(R){this.setColors(R)}setColors(R){var J;let B=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const h=(null===(J=this._colors)||void 0===J?void 0:J.length)??0;var y;if(this._colors=R,null!==R&&0!==R.length){if(!B||Q)if(this.colorsTexture&&h===R.length&&!Q){const J=cR.Color3toRGBAUint8(R);this.colorsTexture.update(J)}else{var N;null===(N=this.colorsTexture)||void 0===N||N.dispose(),this.colorsTexture=cR.CreateColorsTexture(`${this._material.name}-colors-texture`,R,this.colorsSampling,this._scene)}}else null===(y=this.colorsTexture)||void 0===y||y.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(R){this._dashCount=R,this._dashArray=1/R}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(R){this._sizeAttenuation=R,this.markAllDefinesAsDirty()}get color(){return this._color}set color(R){this.setColor(R)}setColor(R){let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==R||null!==this._color&&null===R?(this._color=R,J||this.markAllDefinesAsDirty()):this._color=R}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(R){this._colorsDistributionType=R,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(R){this._aspect=R.x/R.y,this._resolution=R}serialize(){const R=super.serialize(),J={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(J.dR=this._colors),this._color&&(J.color=this._color),R.greasedLineMaterialOptions=J,R}parse(R,J,B){var Q;super.parse(R,J,B);const h=R.greasedLineMaterialOptions;null===(Q=this.colorsTexture)||void 0===Q||Q.dispose(),h.color&&this.setColor(h.color,!0),h.colorDistributionType&&(this.colorsDistributionType=h.colorDistributionType),h.dR&&(this.dR=h.dR),h.colorsSampling&&(this.colorsSampling=h.colorsSampling),h.colorMode&&(this.colorMode=h.colorMode),h.useColors&&(this.useColors=h.useColors),h.visibility&&(this.visibility=h.visibility),h.useDash&&(this.useDash=h.useDash),h.dashCount&&(this.dashCount=h.dashCount),h.dashRatio&&(this.dashRatio=h.dashRatio),h.dashOffset&&(this.dashOffset=h.dashOffset),h.width&&(this.width=h.width),h.sizeAttenuation&&(this.sizeAttenuation=h.sizeAttenuation),h.resolution&&(this.resolution=h.resolution),this.dR?this.colorsTexture=cR.CreateColorsTexture(`${this._material.name}-colors-texture`,this.dR,this.colorsSampling,J):cR.PrepareEmptyColorsTexture(J),this.markAllDefinesAsDirty()}copyTo(R){var J;const B=R;null===(J=B.colorsTexture)||void 0===J||J.dispose(),this._colors&&(B.colorsTexture=cR.CreateColorsTexture(`${B._material.name}-colors-texture`,this._colors,B.colorsSampling,this._scene)),B.setColor(this.color,!0),B.colorsDistributionType=this.colorsDistributionType,B.colorsSampling=this.colorsSampling,B.colorMode=this.colorMode,B.useColors=this.useColors,B.visibility=this.visibility,B.useDash=this.useDash,B.dashCount=this.dashCount,B.dashRatio=this.dashRatio,B.dashOffset=this.dashOffset,B.width=this.width,B.sizeAttenuation=this.sizeAttenuation,B.resolution=this.resolution,B.markAllDefinesAsDirty()}_isGLSL(R){return 0===R||this._forceGLSL}}pR.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",pR.ForceGLSL=!1,(0,MR.h)(`BABYLON.${pR.GREASED_LINE_MATERIAL_NAME}`,pR);var iR=B(11613),WR=B(11045),kR=B(11417),YR=B(11128);class GR extends kR.ShaderMaterial{constructor(R,J,h){const y=J.getEngine(),N=y.isWebGPU&&!(h.forceGLSL||GR.ForceGLSL),r=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];J.useRightHandedSystem&&r.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const q=["position","grl_widths","grl_offsets","grl_colorPointers"];h.cameraFacing?(r.push("GREASED_LINE_CAMERA_FACING"),q.push("grl_previousAndSide","grl_nextAndCounters")):(q.push("grl_slopes"),q.push("grl_counters"));const e=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(N||e.push("world","viewProjection","view","projection"),super(R,J,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:N?["Scene","Mesh"]:void 0,attributes:q,uniforms:e,samplers:N?[]:["grlColors"],defines:r,extraInitializationsAsync:async()=>{N?await Promise.all([B.e(66).then(B.bind(B,14291)),B.e(75).then(B.bind(B,14297))]):await Promise.all([B.e(69).then(B.bind(B,14299)),B.e(76).then(B.bind(B,14308))])},shaderLanguage:N?1:0}),this._color=A.SJ.White(),this._colorsDistributionType=0,this._colorsTexture=null,h=h||{color:HR.DEFAULT_COLOR},this.visibility=h.visibility??1,this.useDash=h.useDash??!1,this.dashRatio=h.dashRatio??.5,this.dashOffset=h.dashOffset??0,this.dashCount=h.dashCount??1,this.width=h.width?h.width:h.sizeAttenuation&&h.cameraFacing?HR.DEFAULT_WIDTH_ATTENUATED:HR.DEFAULT_WIDTH,this.sizeAttenuation=h.sizeAttenuation??!1,this.color=h.color??A.SJ.White(),this.useColors=h.useColors??!1,this.colorsDistributionType=h.colorDistributionType??0,this.colorsSampling=h.colorsSampling??x.b.NEAREST_NEAREST,this.colorMode=h.colorMode??0,this._colors=h.dR??null,this._cameraFacing=h.cameraFacing??!0,this.resolution=h.resolution??new Q.Vector2(y.getRenderWidth(),y.getRenderHeight()),h.colorsTexture?this.colorsTexture=h.colorsTexture:this._colors?this.colorsTexture=cR.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,J):(this._color=this._color??HR.DEFAULT_COLOR,this.colorsTexture=cR.PrepareEmptyColorsTexture(J)),N){const R=new YR.d;R.setParameters(),R.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",R)}y.eh.add((()=>{cR.DisposeEmptyColorsTexture()}))}dispose(){var R;null===(R=this._colorsTexture)||void 0===R||R.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new Q.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dR(){return this._colors}set dR(R){this.setColors(R)}setColors(R){var J;let B=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const h=(null===(J=this._colors)||void 0===J?void 0:J.length)??0;var y;if(this._colors=R,null!==R&&0!==R.length){if(!B||Q)if(this._colorsTexture&&h===R.length&&!Q){const J=cR.Color3toRGBAUint8(R);this._colorsTexture.update(J)}else{var N;null===(N=this._colorsTexture)||void 0===N||N.dispose(),this.colorsTexture=cR.CreateColorsTexture(`${this.name}-colors-texture`,R,this.colorsSampling,this.IR())}}else null===(y=this._colorsTexture)||void 0===y||y.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(R){this._colorsTexture=R,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(R){this._width=R,this.setFloat("grlWidth",R)}get useColors(){return this._useColors}set useColors(R){this._useColors=R,this.setFloat("grlUseColors",cR.BooleanToNumber(R))}get colorsSampling(){return this._colorsSampling}set colorsSampling(R){this._colorsSampling=R}get visibility(){return this._visibility}set visibility(R){this._visibility=R,this.setFloat("grlVisibility",R)}get useDash(){return this._useDash}set useDash(R){this._useDash=R,this.setFloat("grlUseDash",cR.BooleanToNumber(R))}get dashOffset(){return this._dashOffset}set dashOffset(R){this._dashOffset=R,this.setFloat("grlDashOffset",R)}get dashRatio(){return this._dashRatio}set dashRatio(R){this._dashRatio=R,this.setFloat("grlDashRatio",R)}get dashCount(){return this._dashCount}set dashCount(R){this._dashCount=R,this._dashArray=1/R,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(R){this._sizeAttenuation=R,this.setFloat("grlSizeAttenuation",cR.BooleanToNumber(R))}get color(){return this._color}set color(R){this.setColor(R)}setColor(R){R=R??HR.DEFAULT_COLOR,this._color=R,this.setColor3("grlColor",R)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(R){this._colorsDistributionType=R,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(R){this._colorMode=R,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(R){this._resolution=R,this.setVector2("grlResolution",R),this.setFloat("grlAspect",R.x/R.y)}serialize(){const R=super.serialize(),J={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(J.dR=this._colors),R.greasedLineMaterialOptions=J,R}parse(R,J,B){var Q;const h=R.greasedLineMaterialOptions;null===(Q=this._colorsTexture)||void 0===Q||Q.dispose(),h.color&&(this.color=h.color),h.colorDistributionType&&(this.colorsDistributionType=h.colorDistributionType),h.colorsSampling&&(this.colorsSampling=h.colorsSampling),h.colorMode&&(this.colorMode=h.colorMode),h.useColors&&(this.useColors=h.useColors),h.visibility&&(this.visibility=h.visibility),h.useDash&&(this.useDash=h.useDash),h.dashCount&&(this.dashCount=h.dashCount),h.dashRatio&&(this.dashRatio=h.dashRatio),h.dashOffset&&(this.dashOffset=h.dashOffset),h.width&&(this.width=h.width),h.sizeAttenuation&&(this.sizeAttenuation=h.sizeAttenuation),h.resolution&&(this.resolution=h.resolution),h.dR?this.colorsTexture=cR.CreateColorsTexture(`${this.name}-colors-texture`,h.dR,this.colorsSampling,this.IR()):this.colorsTexture=cR.PrepareEmptyColorsTexture(J),this._cameraFacing=h.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var gR,LR,jR;GR.ForceGLSL=!1,function(R){R[R.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",R[R.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(gR||(gR={})),function(R){R[R.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",R[R.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",R[R.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(LR||(LR={})),function(R){R[R.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",R[R.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",R[R.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",R[R.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",R[R.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(jR||(jR={}));class TR extends SR.e{constructor(R,J,B){super(R,J,null,null,!1,!1),this.name=R,this._options=B,this._lazy=!1,this._updatable=!1,this._engine=J.getEngine(),this._lazy=B.lazy??!1,this._updatable=B.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=B.colorPointers??[],this._widths=B.widths??new Array(B.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(R){let J=0;for(const Q of this._points)J+=Q.length;const B=J/3*2-this._widths.length;for(let Q=0;Q<B;Q++)this._widths.push(R)}updateLazy(){var R,J;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(R=this._options.ribbonOptions)||void 0===R?void 0:R.smoothShading),!this.pR&&this.refreshBoundingInfo(),null===(J=this.greasedLineMaterial)||void 0===J||J.updateLazy()}addPoints(R,J){for(const B of R)this._points.push(B);this._lazy||this.setPoints(this._points,J)}dispose(R){let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(R,J)}isLazy(){return this._lazy}get XR(){return this._uvs}set XR(R){this._uvs=R instanceof Float32Array?R:new Float32Array(R),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(R){this.material instanceof GR&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===R||void 0===R?void 0:R.length)>0),this._offsets=R,this._offsetsBuffer?this._offsetsBuffer.update(R):this._createOffsetsBuffer(R)}get widths(){return this._widths}set widths(R){this._widths=R,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(R)}get colorPointers(){return this._colorPointers}set colorPointers(R){this._colorPointers=R,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(R)}get greasedLineMaterial(){var R,J;if(this.material&&this.material instanceof GR)return this.material;const B=null===(R=this.material)||void 0===R||null===(J=R.pluginManager)||void 0===J?void 0:J.getPlugin(pR.GREASED_LINE_MATERIAL_NAME);return B||void 0}get points(){const R=[];return WR.d.DeepCopy(this._points,R),R}setPoints(R,J){this._points=cR.ConvertPoints(R,(null===J||void 0===J?void 0:J.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==J&&void 0!==J&&J.colorPointers||this._updateColorPointers(),this._setPoints(this._points,J)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,XR:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(R){super.serialize(R),R.type=this.getClassName(),R.lineOptions=this._createLineOptions()}_createVertexBuffers(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const J=new iR.e;return J.MR=this._vertexPositions,J.indices=this._indices,J.XR=this._uvs,R&&(J.HR=[],iR.e.ComputeNormals(this._vertexPositions,this._indices,J.HR)),J.zR(this,this._options.updatable),J}_createOffsetsBuffer(R){const J=this._scene.getEngine(),B=new D.d(J,R,this._updatable,3);this.setVerticesBuffer(B.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=B}}class FR{constructor(R,J){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=R,this.wasAddedByNoopNode=J}getIndicesAccessor(R,J,B,Q,h){var y,N,r,q;return null===(y=this._indicesAccessorMap.get(R))||void 0===y||null===(N=y.get(J))||void 0===N||null===(r=N.get(B))||void 0===r||null===(q=r.get(Q))||void 0===q?void 0:q.get(h)}setIndicesAccessor(R,J,B,Q,h,y){let N=this._indicesAccessorMap.get(R);N||(N=new Map,this._indicesAccessorMap.set(R,N));let r=N.get(J);r||(r=new Map,N.set(J,r));let q=r.get(B);q||(q=new Map,r.set(B,q));let e=q.get(Q);e||(e=new Map,q.set(Q,e)),e.set(h,y)}pushExportedNode(R){this._exportedNodes.has(R)||this._exportedNodes.add(R)}getNodesSet(){return this._exportedNodes}getVertexBufferView(R){return this._vertexBufferViewMap.get(R)}setVertexBufferView(R,J){this._vertexBufferViewMap.set(R,J)}setRemappedBufferView(R,J,B){this._remappedBufferView.set(R,new Map),this._remappedBufferView.get(R).set(J,B)}getRemappedBufferView(R,J){var B;return null===(B=this._remappedBufferView.get(R))||void 0===B?void 0:B.get(J)}getVertexAccessor(R,J,B){var Q,h;return null===(Q=this._vertexAccessorMap.get(R))||void 0===Q||null===(h=Q.get(J))||void 0===h?void 0:h.get(B)}setVertexAccessor(R,J,B,Q){let h=this._vertexAccessorMap.get(R);h||(h=new Map,this._vertexAccessorMap.set(R,h));let y=h.get(J);y||(y=new Map,h.set(J,y)),y.set(B,Q)}hasVertexColorAlpha(R){return this._vertexMapColorAlpha.get(R)||!1}setHasVertexColorAlpha(R,J){return this._vertexMapColorAlpha.set(R,J)}getMesh(R){return this._meshMap.get(R)}setMesh(R,J){this._meshMap.set(R,J)}bindMorphDataToMesh(R,J){const B=this._meshMorphTargetMap.get(R)||[];this._meshMorphTargetMap.set(R,B),-1===B.indexOf(J)&&B.push(J)}getMorphTargetsFromMesh(R){return this._meshMorphTargetMap.get(R)}}class CR{_ApplyExtension(R,J,B,Q){if(B>=J.length)return Promise.resolve(R);const h=Q(J[B],R);return h?h.then((async R=>R?await this._ApplyExtension(R,J,B+1,Q):null)):this._ApplyExtension(R,J,B+1,Q)}_ApplyExtensions(R,J){const B=[];for(const Q of CR._ExtensionNames)B.push(this._extensions[Q]);return this._ApplyExtension(R,B,0,J)}_extensionsPreExportTextureAsync(R,J,B){return this._ApplyExtensions(J,((J,Q)=>J.preExportTextureAsync&&J.preExportTextureAsync(R,Q,B)))}_extensionsPostExportNodeAsync(R,J,B,Q,h){return this._ApplyExtensions(J,((J,y)=>J.postExportNodeAsync&&J.postExportNodeAsync(R,y,B,Q,h,this._bufferManager)))}_extensionsPostExportMaterialAsync(R,J,B){return this._ApplyExtensions(J,((J,Q)=>J.postExportMaterialAsync&&J.postExportMaterialAsync(R,Q,B)))}_extensionsPostExportMaterialAdditionalTextures(R,J,B){const Q=[];for(const h of CR._ExtensionNames){const y=this._extensions[h];y.postExportMaterialAdditionalTextures&&Q.push(...y.postExportMaterialAdditionalTextures(R,J,B))}return Q}_extensionsPostExportTextures(R,J,B){for(const Q of CR._ExtensionNames){const h=this._extensions[Q];h.postExportTexture&&h.postExportTexture(R,J,B)}}_extensionsPostExportMeshPrimitive(R){for(const J of CR._ExtensionNames){const B=this._extensions[J];B.postExportMeshPrimitive&&B.postExportMeshPrimitive(R,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const R of CR._ExtensionNames){const J=this._extensions[R];J.preGenerateBinaryAsync&&await J.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(R){for(const J of CR._ExtensionNames){const B=this._extensions[J];B.enabled&&R(B)}}_extensionsOnExporting(){this._forEachExtensions((R=>{var J,B,Q;R.wasUsed&&((J=this._glTF).extensionsUsed||(J.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(R.name)&&this._glTF.extensionsUsed.push(R.name),R.required&&((B=this._glTF).extensionsRequired||(B.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(R.name)&&this._glTF.extensionsRequired.push(R.name)),(Q=this._glTF).extensions||(Q.extensions={}),R.onExporting&&R.onExporting())}))}_loadExtensions(){for(const R of CR._ExtensionNames){const J=CR._ExtensionFactories[R](this);this._extensions[R]=J}}constructor(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:P.e.LastCreatedScene,J=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${n.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new Y(this),this._extensions={},this._bufferManager=new DR,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!R)throw new Error("No scene available to export");this._babylonScene=R,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:R=>{var J;return null===R||void 0===R||null===(J=R.xh)||void 0===J?void 0:J.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...J},this._loadExtensions()}dispose(){for(const R in this._extensions){this._extensions[R].dispose()}}get options(){return this._options}static RegisterExtension(R,J){CR.UnregisterExtension(R)&&h.Tools.Warn(`Extension with the name ${R} already exists`),CR._ExtensionFactories[R]=J,CR._ExtensionNames.push(R)}static UnregisterExtension(R){if(!CR._ExtensionFactories[R])return!1;delete CR._ExtensionFactories[R];const J=CR._ExtensionNames.indexOf(R);return-1!==J&&CR._ExtensionNames.splice(J,1),!0}_generateJSON(R,J,B){const Q={byteLength:R};return Q.byteLength&&(this._glTF.buffers=[Q]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.AJ=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(Q.uri=J+".bin"),B?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(R){const J=await this._generateBinaryAsync();this._extensionsOnExporting();const B=this._generateJSON(J.byteLength,R,!0),Q=new Blob([J],{type:"application/octet-stream"}),h=R+".gltf",y=R+".bin",N=new e;if(N.files[h]=B,N.files[y]=Q,this._imageData)for(const r in this._imageData)N.files[r]=new Blob([this._imageData[r].data],{type:this._imageData[r].mimeType});return N}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(R){const J=R%4;return 0===J?J:4-J}async generateGLBAsync(R){this._shouldUseGlb=!0;const J=await this._generateBinaryAsync();this._extensionsOnExporting();const B=this._generateJSON(J.byteLength),Q=R+".glb";let h,y=B.length;if("undefined"!==typeof TextEncoder){h=(new TextEncoder).encode(B),y=h.length}const N=this._getPadding(y),r=this._getPadding(J.byteLength),q=28+y+N+J.byteLength+r,D=new qR(q);if(D.writeUInt32(1179937895),D.writeUInt32(2),D.writeUInt32(q),D.writeUInt32(y+N),D.writeUInt32(1313821514),h)D.writeTypedArray(h);else{const R="_".charCodeAt(0);for(let J=0;J<y;++J){const Q=B.charCodeAt(J);Q!=B.codePointAt(J)?D.writeUInt8(R):D.writeUInt8(Q)}}for(let e=0;e<N;++e)D.writeUInt8(32);D.writeUInt32(J.byteLength+r),D.writeUInt32(5130562),D.writeTypedArray(J);for(let e=0;e<r;++e)D.writeUInt8(0);const l=new e;return l.files[Q]=new Blob([D.getOutputData()],{type:"application/octet-stream"}),l}_setNodeTransformation(R,J,B){if(J.getPivotPoint().equalsWithEpsilon(T,j.d)||h.Tools.Warn("Pivot points are not supported in the glTF serializer"),!J.position.equalsWithEpsilon(T,j.d)){const h=Q.TmpVectors.nJ[0].h(J.position);B&&t(h),R.translation=h.Ch()}J.ur.equalsWithEpsilon(C,j.d)||(R.scale=J.ur.Ch());const y=J.rotationQuaternion||Q.Quaternion.FromEulerAngles(J.rotation.x,J.rotation.y,J.rotation.z);y.equalsWithEpsilon(F,j.d)||(B&&Z(y),R.rotation=y.normalize().Ch())}_setCameraTransformation(R,J,B){if(!J.position.equalsWithEpsilon(T,j.d)){const h=Q.TmpVectors.nJ[0].h(J.position);B&&t(h),R.translation=h.Ch()}const h=J.rotationQuaternion||Q.Quaternion.FromEulerAngles(J.rotation.x,J.rotation.y,J.rotation.z);B&&Z(h),this._babylonScene.useRightHandedSystem||U(h),h.equalsWithEpsilon(F,j.d)||(R.rotation=h.Ch())}_listAvailableCameras(){for(const R of this._babylonScene.cameras){const J={type:R.mode===ER.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(R.name&&(J.name=R.name),"perspective"===J.type)J.perspective={aspectRatio:R.getEngine().getAspectRatio(R),yfov:R.fovMode===ER.d.FOVMODE_VERTICAL_FIXED?R.fov:R.fov*R.getEngine().getAspectRatio(R),znear:R.mh,zfar:R.maxZ};else if("orthographic"===J.type){const B=R.orthoLeft&&R.orthoRight?.5*(R.orthoRight-R.orthoLeft):.5*R.getEngine().getRenderWidth(),Q=R.orthoBottom&&R.orthoTop?.5*(R.orthoTop-R.orthoBottom):.5*R.getEngine().getRenderHeight();J.orthographic={xmag:B,ymag:Q,znear:R.mh,zfar:R.maxZ}}this._camerasMap.set(R,J)}}_exportAndAssignCameras(){const R=Array.from(this._camerasMap.values());for(const J of R){const R=this._nodesCameraMap.get(J);if(void 0!==R){this._cameras.push(J);for(const J of R)J.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const R of this._babylonScene.skeletons){if(R.bones.length<=0)continue;const J={joints:[]};this._skinMap.set(R,J)}}_exportAndAssignSkeletons(){for(const R of this._babylonScene.skeletons){if(R.bones.length<=0)continue;const J=this._skinMap.get(R);if(void 0==J)continue;const B={},Q=[];let y=-1;for(let h=0;h<R.bones.length;++h){const J=R.bones[h],Q=J.getIndex()??h;-1!==Q&&(B[Q]=J,Q>y&&(y=Q))}for(let R=0;R<=y;++R){const y=B[R];Q.push(y.getAbsoluteInverseBindMatrix());const N=y.getTransformNode();if(null!==N){const R=this._nodeMap.get(N);N&&null!==R&&void 0!==R?J.joints.push(R):h.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else h.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const N=this._nodesSkinMap.get(J);if(J.joints.length>0&&void 0!==N){const R=64*Q.length,B=new Float32Array(R/4);Q.forEach(((R,J)=>{B.set(R.m,16*J)}));const h=this._bufferManager.createBufferView(B);this._accessors.push(this._bufferManager.createAccessor(h,"MAT4",5126,Q.length)),J.inverseBindMatrices=this._accessors.length-1,this._skins.push(J);for(const J of N)J.skin=this._skins.length-1}}}async _exportSceneAsync(){const R={nodes:[]};if(this._babylonScene.metadata){const J=this._options.metadataSelector(this._babylonScene.metadata);J&&(R.extras=J)}const J=new Array,B=new Array,Q=new Array;for(const r of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&NR(r,this._babylonScene.useRightHandedSystem)?Q.push(...r.getChildren()):this._babylonScene.useRightHandedSystem?J.push(r):B.push(r);this._listAvailableCameras(),this._listAvailableSkeletons();const h=new FR(!0,!1);R.nodes.push(...await this._exportNodesAsync(B,h));const y=new FR(!1,!1);R.nodes.push(...await this._exportNodesAsync(J,y));const N=new FR(!1,!0);R.nodes.push(...await this._exportNodesAsync(Q,N)),R.nodes.length&&this._scenes.push(R),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&aR._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,h.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(R){let J=this._shouldExportNodeMap.get(R);return void 0===J&&(J=this._options.shouldExportNode(R),this._shouldExportNodeMap.set(R,J)),J}async _exportNodesAsync(R,J){const B=new Array;this._exportBuffers(R,J);for(const Q of R)await this._exportNodeAsync(Q,B,J);return B}_collectBuffers(R,J,B,Q,h){if(this._shouldExportNode(R)&&R instanceof E.d&&R.py){const y=R.py.getVertexBuffers();if(y)for(const Q in y){if(!v(Q))continue;const N=y[Q];h.setHasVertexColorAlpha(N,R.hasVertexAlpha);const r=N._buffer,q=J.get(r)||[];J.set(r,q),-1===q.indexOf(N)&&q.push(N);const e=B.get(N)||[];B.set(N,e),-1===e.indexOf(R)&&e.push(R)}const N=R.morphTargetManager;if(N)for(let J=0;J<N.numTargets;J++){const B=N.getTarget(J),h=Q.get(B)||[];Q.set(B,h),-1===h.indexOf(R)&&h.push(R)}}for(const y of R.getChildren())this._collectBuffers(y,J,B,Q,h)}_exportBuffers(R,J){const B=new Map,Q=new Map,h=new Map;for(const r of R)this._collectBuffers(r,B,Q,h,J);const y=Array.from(B.keys());for(const r of y){const R=r.getData();if(!R)throw new Error("Buffer data is not available");const h=B.get(r);if(!h)continue;const y=h[0].byteStride;if(h.some((R=>R.byteStride!==y)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const N=BR(R).slice();for(const J of h){const R=Q.get(J),{byteOffset:B,byteStride:h,componentCount:y,type:r,count:q,normalized:e,kind:l}=w(J,R);switch(l){case D.h.NormalKind:case D.h.TangentKind:(0,G.l)(N,B,h,y,r,q,e,(R=>{const J=Math.sqrt(R[0]*R[0]+R[1]*R[1]+R[2]*R[2]);if(J>0){const B=1/J;R[0]*=B,R[1]*=B,R[2]*=B}}));break;case D.h.ColorKind:{const J=R.filter((R=>R.material instanceof PR.uJ||null==R.material)).length;if(0==J)break;if(J!=R.length){g.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}r==D.h.UNSIGNED_BYTE&&g.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const Q=new A.SJ,l=new A.ar,E=this._babylonScene.getEngine().useExactSrgbConversions;(0,G.l)(N,B,h,y,r,q,e,(R=>{3===R.length?(Q.EB(R,0),Q.toLinearSpaceToRef(Q,E),Q.toArray(R,0)):(l.EB(R,0),l.toLinearSpaceToRef(l,E),l.toArray(R,0))}))}}}if(J.convertToRightHanded){for(const R of h){const J=Q.get(R),{byteOffset:B,byteStride:h,componentCount:y,type:r,count:q,normalized:e,kind:l}=w(R,J);switch(l){case D.h.PositionKind:case D.h.NormalKind:case D.h.TangentKind:(0,G.l)(N,B,h,y,r,q,e,(R=>{R[0]=-R[0]}))}}J.convertedToRightHandedBuffers.set(r,N)}const q=this._bufferManager.createBufferView(N,y);J.setVertexBufferView(r,q);const e=new Map;for(const J of h){const R=Q.get(J),{kind:B,totalVertices:h}=w(J,R);switch(B){case D.h.MatricesIndicesKind:case D.h.MatricesIndicesExtraKind:if(J.type==D.h.FLOAT){const R=J.getFloatData(h);null!==R&&e.set(J,R)}}}0!==e.size&&g.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const l=Array.from(e.keys());for(const B of l){const R=e.get(B);if(!R)continue;const Q=R.some((R=>R>=256)),h=new(Q?Uint16Array:Uint8Array)(R.length);for(let J=0;J<R.length;J++)h[J]=R[J];const y=this._bufferManager.createBufferView(h,4*(Q?2:1));J.setRemappedBufferView(r,B,y)}}const N=Array.from(h.keys());for(const r of N){const R=h.get(r);if(!R)continue;const B=sR(r,R[0],this._bufferManager,this._bufferViews,this._accessors,J.convertToRightHanded);for(const Q of R)J.bindMorphDataToMesh(Q,B)}}async _exportNodeAsync(R,J,B){let Q=this._nodeMap.get(R);if(void 0!==Q)return void(J.includes(Q)||J.push(Q));const h=await this._createNodeAsync(R,B);if(h){Q=this._nodes.length,this._nodes.push(h),this._nodeMap.set(R,Q),B.pushExportedNode(R),J.push(Q);const y={name:"runtime animations",channels:[],samplers:[]},N=[];this._babylonScene.animationGroups.length||(aR._CreateMorphTargetAnimationFromMorphTargetAnimations(R,y,N,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,B.convertToRightHanded,this._options.shouldExportAnimation),R.animations.length&&aR._CreateNodeAnimationFromNodeAnimations(R,y,N,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,B.convertToRightHanded,this._options.shouldExportAnimation)),y.channels.length&&y.samplers.length&&this._animations.push(y),N.forEach((R=>{R.channels.length&&R.samplers.length&&this._animations.push(R)}))}const y=h?[]:J;for(const N of R.getChildren())await this._exportNodeAsync(N,y,B);h&&y.length&&(h.children=y)}async _createNodeAsync(R,J){if(!this._shouldExportNode(R))return null;const B={};if(R.name&&(B.name=R.name),R.metadata){const J=this._options.metadataSelector(R.metadata);J&&(B.extras=J)}if(R instanceof l.e&&(this._setNodeTransformation(B,R,J.convertToRightHanded),R instanceof E.d)){const h=R instanceof O.c?R.sourceMesh:R;if(h.Fh&&h.Fh.length>0&&(B.mesh=await this._exportMeshAsync(h,J)),R.skeleton){const J=this._skinMap.get(R.skeleton);var Q;if(void 0!==J)void 0===this._nodesSkinMap.get(J)&&this._nodesSkinMap.set(J,[]),null===(Q=this._nodesSkinMap.get(J))||void 0===Q||Q.push(B)}}if(R instanceof L.e){const Q=this._camerasMap.get(R);if(Q){var h;void 0===this._nodesCameraMap.get(Q)&&this._nodesCameraMap.set(Q,[]),this._setCameraTransformation(B,R,J.convertToRightHanded);const N=R.parent;if(null!==N&&JR(R,N)){const R=this._nodeMap.get(N);if(void 0!==R){var y;const J=this._nodes[R];return RR(B,J),null===(y=this._nodesCameraMap.get(Q))||void 0===y||y.push(J),null}}null===(h=this._nodesCameraMap.get(Q))||void 0===h||h.push(B)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",B,R,this._nodeMap,J.convertToRightHanded)?B:(g.d.Warn(`Not exporting node ${R.name}`),null)}_exportIndices(R,J,B,Q,h,N,r,q,e){let D=R;e.mode=m(N);const l=r!==y.b.CounterClockWiseSideOrientation,E=!q.wasAddedByNoopNode&&l,O=function(R){switch(R){case y.b.TriangleFillMode:case y.b.TriangleStripDrawMode:case y.b.TriangleFanDrawMode:return!0}return!1}(N)&&E;if(O){if(N===y.b.TriangleStripDrawMode||N===y.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");e.mode=m(N);const r=J?new Uint32Array(Q):new Uint16Array(Q);if(R)for(let J=0;J+2<Q;J+=3)r[J]=R[B+J]+h,r[J+1]=R[B+J+2]+h,r[J+2]=R[B+J+1]+h;else for(let R=0;R+2<Q;R+=3)r[R]=R,r[R+1]=R+2,r[R+2]=R+1;D=r}else if(R&&0!==h){const y=J?new Uint32Array(Q):new Uint16Array(Q);for(let J=0;J<Q;J++)y[J]=R[B+J]+h;D=y}if(D){let y=q.getIndicesAccessor(R,B,Q,h,O);if(void 0===y){const N=function(R,J,B,Q){if(R instanceof Uint16Array||R instanceof Uint32Array)return R;if(R instanceof Int32Array)return new Uint32Array(R.buffer,R.byteOffset,R.length);const h=R.slice(J,J+B);return Q?new Uint32Array(h):new Uint16Array(h)}(D,0,Q,J),r=this._bufferManager.createBufferView(N),e=J?5125:5123;this._accessors.push(this._bufferManager.createAccessor(r,"SCALAR",e,Q,0)),y=this._accessors.length-1,q.setIndicesAccessor(R,B,Q,h,O,y)}e.indices=y}}_exportVertexBuffer(R,J,B,Q,h,y){const N=R.getKind();if(!v(N))return;if(N.startsWith("uv")&&!this._options.exportUnusedUVs&&(!J||!this._materialNeedsUVsSet.has(J)))return;let r=h.getVertexAccessor(R,B,Q);if(void 0===r){const J=h.convertedToRightHandedBuffers.get(R._buffer)||R._buffer.getData(),y=N===D.h.PositionKind?function(R,J,B,Q){const{byteOffset:h,byteStride:y,type:N,normalized:r}=J,q=J.getSize(),e=new Array(q).fill(1/0),D=new Array(q).fill(-1/0);return(0,G.l)(R,h+B*y,y,q,N,Q*q,r,(R=>{for(let J=0;J<q;J++)e[J]=Math.min(e[J],R[J]),D[J]=Math.max(D[J],R[J])})),{min:e,max:D}}(J,R,B,Q):void 0,q=(N===D.h.MatricesIndicesKind||N===D.h.MatricesIndicesExtraKind)&&R.type===D.h.FLOAT,e=q?D.h.UNSIGNED_BYTE:R.type,l=q?void 0:R.normalized,E=q?h.getRemappedBufferView(R._buffer,R):h.getVertexBufferView(R._buffer),O=R.byteOffset+B*R.byteStride;this._accessors.push(this._bufferManager.createAccessor(E,function(R,J){if(R==D.h.ColorKind)return J?"VEC4":"VEC3";switch(R){case D.h.PositionKind:case D.h.NormalKind:return"VEC3";case D.h.TangentKind:case D.h.MatricesIndicesKind:case D.h.MatricesIndicesExtraKind:case D.h.MatricesWeightsKind:case D.h.MatricesWeightsExtraKind:return"VEC4";case D.h.UVKind:case D.h.UV2Kind:case D.h.UV3Kind:case D.h.UV4Kind:case D.h.UV5Kind:case D.h.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${R}`)}(N,h.hasVertexColorAlpha(R)),e,Q,O,y,l)),r=this._accessors.length-1,h.setVertexAccessor(R,B,Q,r)}y.attributes[function(R){switch(R){case D.h.PositionKind:return"POSITION";case D.h.NormalKind:return"NORMAL";case D.h.TangentKind:return"TANGENT";case D.h.ColorKind:return"COLOR_0";case D.h.UVKind:return"TEXCOORD_0";case D.h.UV2Kind:return"TEXCOORD_1";case D.h.UV3Kind:return"TEXCOORD_2";case D.h.UV4Kind:return"TEXCOORD_3";case D.h.UV5Kind:return"TEXCOORD_4";case D.h.UV6Kind:return"TEXCOORD_5";case D.h.MatricesIndicesKind:return"JOINTS_0";case D.h.MatricesIndicesExtraKind:return"JOINTS_1";case D.h.MatricesWeightsKind:return"WEIGHTS_0";case D.h.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${R}`)}(N)]=r}async _exportMaterialAsync(R,J,B,Q){let h=this._materialMap.get(R);if(void 0===h){const Q=J&&Object.keys(J).some((R=>R.startsWith("uv")));if((R=R instanceof OR.e?R.sr[B.materialIndex]:R)instanceof nR.b)h=await this._materialExporter.exportPBRMaterialAsync(R,"image/png",Q);else{if(!(R instanceof PR.uJ))return void g.d.Warn(`Unsupported material '${R.name}' with type ${R.getClassName()}`);h=await this._materialExporter.exportStandardMaterialAsync(R,"image/png",Q)}this._materialMap.set(R,h)}Q.material=h}async _exportMeshAsync(R,J){var B;let Q=J.getMesh(R);if(void 0!==Q)return Q;const h={primitives:[]};Q=this._meshes.length,this._meshes.push(h),J.setMesh(R,Q);const N=R.isUnIndexed?null:R.hr(),r=null===(B=R.py)||void 0===B?void 0:B.getVertexBuffers(),q=J.getMorphTargetsFromMesh(R),e=R instanceof xR.b,D=R instanceof TR,l=R.Fh;if(r&&l&&l.length>0)for(const n of l){const B={attributes:{}},Q=n.YR()||this._babylonScene.defaultMaterial;if(D){var E,O;const J={name:Q.name},h=R,y=A.SJ.White(),N=(null===(E=h.material)||void 0===E?void 0:E.alpha)??1,r=(null===(O=h.greasedLineMaterial)||void 0===O?void 0:O.color)??y;(!r.equalsWithEpsilon(y,j.d)||N<1)&&(J.pbrMetallicRoughness={baseColorFactor:[...r.Ch(),N]}),this._materials.push(J),B.material=this._materials.length-1}else if(e){const J={name:Q.name},h=R;(!h.color.equalsWithEpsilon(A.SJ.White(),j.d)||h.alpha<1)&&(J.pbrMetallicRoughness={baseColorFactor:[...h.color.Ch(),h.alpha]}),this._materials.push(J),B.material=this._materials.length-1}else await this._exportMaterialAsync(Q,r,n,B);const l=e||D?y.b.LineListDrawMode:R.overrideRenderingFillMode??Q.fillMode,P=Q._getEffectiveOrientation(R);this._exportIndices(N,N?(0,G.e)(N,n.indexCount,n.indexStart,n.verticesStart):n.verticesCount>65535,N?n.indexStart:n.verticesStart,N?n.indexCount:n.verticesCount,-n.verticesStart,l,P,J,B);for(const R of Object.values(r))this._exportVertexBuffer(R,Q,n.verticesStart,n.verticesCount,J,B);if(q){B.targets=[];for(const R of q)B.targets.push(R.attributes)}h.primitives.push(B),this._extensionsPostExportMeshPrimitive(B)}if(q){h.weights=[],h.extras||(h.extras={}),h.extras.targetNames=[];for(const R of q)h.weights.push(R.influence),h.extras.targetNames.push(R.name)}return Q}}CR._ExtensionNames=new Array,CR._ExtensionFactories={};class bR{static async GLTFAsync(R,J,B){B&&B.exportWithoutWaitingForScene||await R.whenReadyAsync();const Q=new CR(R,B),h=await Q.generateGLTFAsync(J.replace(/\.[^/.]+$/,""));return Q.dispose(),h}static async GLBAsync(R,J,B){B&&B.exportWithoutWaitingForScene||await R.whenReadyAsync();const Q=new CR(R,B),h=await Q.generateGLBAsync(J.replace(/\.[^/.]+$/,""));return Q.dispose(),h}}B(11755);const wR="EXT_mesh_gpu_instancing";class KR{constructor(R){this.name=wR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(R,J,B,h,y,N){return await new Promise((R=>{if(J&&B instanceof SR.e&&B.hasThinInstances&&this._exporter){this._wasUsed=!0;const R=Q.nJ.Zero(),h=Q.Quaternion.Identity(),r=Q.nJ.One(),q=B.thinInstanceGetWorldMatrices(),e=Q.TmpVectors.nJ[2],D=Q.TmpVectors.Quaternion[1],l=Q.TmpVectors.nJ[3];let E=!1,O=!1,n=!1;const P=new Float32Array(3*B.Ir),A=new Float32Array(4*B.Ir),u=new Float32Array(3*B.Ir);let S=0;for(const J of q)J.decompose(l,D,e),y&&(t(e),Z(D)),P.set(e.Ch(),3*S),A.set(D.normalize().Ch(),4*S),u.set(l.Ch(),3*S),E=E||!e.equalsWithEpsilon(R),O=O||!D.equalsWithEpsilon(h),n=n||!l.equalsWithEpsilon(r),S++;const f={attributes:{}};E&&(f.attributes.TRANSLATION=this._buildAccessor(P,"VEC3",B.Ir,N)),O&&(f.attributes.ROTATION=this._buildAccessor(A,"VEC4",B.Ir,N)),n&&(f.attributes.SCALE=this._buildAccessor(u,"VEC3",B.Ir,N)),J.extensions=J.extensions||{},J.extensions[wR]=f}R(J)}))}_buildAccessor(R,J,B,Q){const h=Q.createBufferView(R),y=Q.createAccessor(h,J,5126,B);return this._exporter._accessors.push(y),this._exporter._accessors.length-1}}CR.RegisterExtension(wR,(R=>new KR(R)));var vR=B(11763),mR=B(11771),oR=B(11776),tR=B(11781);function ZR(R){return R===oR.d.PositionKind?"POSITION":R===oR.d.NormalKind?"NORMAL":R===oR.d.ColorKind?"COLOR":R.startsWith(oR.d.UVKind)?"TEX_COORD":"GENERIC"}const UR={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class RJ extends vR.d{static get DefaultAvailable(){return(0,vR.i)(RJ.DefaultConfiguration)}static get Default(){return RJ._Default??(RJ._Default=new RJ),RJ._Default}static ResetDefault(R){RJ._Default&&(R||RJ._Default.dispose(),RJ._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(R,J){return{module:await(J||DracoEncoderModule)({wasmBinary:R})}}_getWorkerContent(){return`${mR.i}(${mR.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:RJ.DefaultConfiguration)}async _encodeAsync(R,J,B){const Q=B?(0,tR.e)(UR,B):UR;if(this._workerPoolPromise){const B=await this._workerPoolPromise;return await new Promise(((h,y)=>{B.push(((B,N)=>{const r=R=>{B.removeEventListener("error",r),B.removeEventListener("message",q),y(R),N()},q=R=>{"encodeMeshDone"===R.data.id&&(B.removeEventListener("error",r),B.removeEventListener("message",q),h(R.data.encodedMeshData),N())};B.addEventListener("error",r),B.addEventListener("message",q);const e=[];for(const J of R)e.push(J.data.buffer);J&&e.push(J.buffer),B.postMessage({id:"encodeMesh",attributes:R,indices:J,options:Q},e)}))}))}if(this._modulePromise){const B=await this._modulePromise;return(0,mR.i)(B.module,R,J,Q)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(R,J){if(0==R.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");R instanceof SR.e&&R.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===J||void 0===J?void 0:J.method)&&(g.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),J.method="MESH_SEQUENTIAL_ENCODING");const B=function(R){let J=R.hr(void 0,!0);return!J||J instanceof Uint32Array||J instanceof Uint16Array||(J=((0,G.e)(J,J.length)?Uint32Array:Uint16Array).from(J)),J}(R),Q=function(R,J){const B=[];for(const Q of R.getVerticesDataKinds()){if(null!==J&&void 0!==J&&J.includes(Q)){if(Q===oR.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const h=R.getVertexBuffer(Q),y=h.getSize(),N=(0,G.u)(h.getData(),y,h.type,h.byteOffset,h.byteStride,h.normalized,R.getTotalVertices(),!0);B.push({kind:Q,dracoName:ZR(Q),size:y,data:N})}return B}(R,null===J||void 0===J?void 0:J.excludedAttributes);return await this._encodeAsync(Q,B,J)}}RJ.DefaultConfiguration={wasmUrl:`${h.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${h.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${h.Tools._DefaultCdnUrl}/draco_encoder.js`},RJ._Default=null;const JJ="KHR_draco_mesh_compression";class BJ{get wasUsed(){return this._wasUsed}constructor(R){this.name=JJ,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===R.options.meshCompressionMethod&&RJ.DefaultAvailable}dispose(){}postExportMeshPrimitive(R,J,B){if(!this.enabled)return;if(4!==R.mode&&5!==R.mode)return void g.d.Warn("Cannot compress primitive with mode "+R.mode+".");const Q=[],h=[];let y=null;if(void 0!==R.indices){const N=B[R.indices],r=J.getBufferView(N);y=J.getData(r).slice(),Q.push(r),h.push(N)}const N=[];for(const[D,l]of Object.entries(R.attributes)){const R=B[l],y=J.getBufferView(R),q=K(R.type),e=(0,G.u)(J.getData(y),q,R.componentType,R.byteOffset||0,y.byteStride||(0,G.p)(R.componentType)*q,R.normalized||!1,R.count,!0);N.push({kind:D,dracoName:(r=D,"POSITION"===r?"POSITION":"NORMAL"===r?"NORMAL":r.startsWith("COLOR")?"COLOR":r.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:K(R.type),data:e}),Q.push(y),h.push(R)}var r;const q={method:R.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},e=RJ.Default._encodeAsync(N,y,q).then((B=>{if(!B)return void g.d.Error("Draco encoding failed for primitive.");const y={bufferView:-1,attributes:B.attributeIds},N=J.createBufferView(B.data);J.setBufferView(y,N);for(const R of Q)this._bufferViewsUsed.add(R);for(const R of h)this._accessorsUsed.add(R);R.extensions||(R.extensions={}),R.extensions[JJ]=y})).catch((R=>{g.d.Error("Draco encoding failed for primitive: "+R)}));this._encodePromises.push(e),this._wasUsed=!0}async preGenerateBinaryAsync(R){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((J=>{R.getPropertiesWithBufferView(J).every((R=>this._accessorsUsed.has(R)))&&R.removeBufferView(J)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}CR.RegisterExtension(JJ,(R=>new BJ(R)));var QJ=B(11790);const hJ="KHR_lights_punctual",yJ={name:"",color:[1,1,1],Vr:1,range:Number.MAX_VALUE},NJ={innerConeAngle:0,outerConeAngle:Math.PI/4},rJ=Q.nJ.Backward();class qJ{constructor(R){this.name=hJ,this.enabled=!0,this.required=!1,this._exporter=R}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[hJ]=this._lights}async postExportNodeAsync(R,J,B,h,y){return await new Promise((N=>{if(!(B instanceof fR.e))return void N(J);const r=B.getTypeID()==fR.e.LIGHTTYPEID_POINTLIGHT?"point":B.getTypeID()==fR.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":B.getTypeID()==fR.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!r||!(B instanceof QJ.d))return g.d.Warn(`${R}: Light ${B.name} is not supported in ${hJ}`),void N(J);if(B.falloffType!==fR.e.FALLOFF_GLTF&&g.d.Warn(`${R}: Light falloff for ${B.name} does not match the ${hJ} specification!`),!B.position.equalsToFloats(0,0,0)){const R=Q.TmpVectors.nJ[0].h(B.position);y&&t(R),J.translation=R.Ch()}if("point"!==r){const R=B.direction.normalizeToRef(Q.TmpVectors.nJ[0]);y&&t(R);const h=Q.Quaternion.FromUnitVectorsToRef(rJ,R,Q.TmpVectors.Quaternion[0]);Q.Quaternion.IsIdentity(h)||(J.rotation=h.Ch())}const q={type:r,name:B.name,color:B.Mr.Ch(),Vr:B.Vr,range:B.range};if(QR(q,yJ),"spot"===r){const R=B;q.spot={innerConeAngle:R.innerAngle/2,outerConeAngle:R.angle/2},QR(q.spot,NJ)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(q);const e={hh:this._lights.lights.length-1},D=B.parent;if(D&&JR(B,D)){const R=h.get(D);if(R){const B=this._exporter._nodes[R];return RR(J,B),B.extensions||(B.extensions={}),B.extensions[hJ]=e,void N(null)}}J.extensions||(J.extensions={}),J.extensions[hJ]=e,N(J)}))}}CR.RegisterExtension(hJ,(R=>new qJ(R)));var eJ=B(11699);const DJ="KHR_materials_anisotropy";class lJ{constructor(R){this.name=DJ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,J,B){const Q=[];return B instanceof eJ.d&&B.anisotropy.isEnabled&&!B.anisotropy.legacy?(B.anisotropy.texture&&Q.push(B.anisotropy.texture),Q):[]}postExportMaterialAsync(R,J,B){return new Promise((R=>{if(B instanceof eJ.d){if(!B.anisotropy.isEnabled||B.anisotropy.legacy)return void R(J);this._wasUsed=!0,J.extensions=J.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(B.anisotropy.texture),h={anisotropyStrength:B.anisotropy.Vr,anisotropyRotation:B.anisotropy.angle,anisotropyTexture:Q??void 0};null!==h.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(B),J.extensions[DJ]=h}R(J)}))}}CR.RegisterExtension(DJ,(R=>new lJ(R)));const EJ="KHR_materials_clearcoat";class OJ{constructor(R){this.name=EJ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,J,B){const Q=[];return B instanceof eJ.d&&B.clearCoat.isEnabled?(B.clearCoat.texture&&Q.push(B.clearCoat.texture),!B.clearCoat.useRoughnessFromMainTexture&&B.clearCoat.textureRoughness&&Q.push(B.clearCoat.textureRoughness),B.clearCoat.bumpTexture&&Q.push(B.clearCoat.bumpTexture),Q):[]}postExportMaterialAsync(R,J,B){return new Promise((R=>{if(B instanceof eJ.d){if(!B.clearCoat.isEnabled)return void R(J);this._wasUsed=!0,J.extensions=J.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(B.clearCoat.texture);let y;y=B.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(B.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(B.clearCoat.textureRoughness),B.clearCoat.isTintEnabled&&h.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${B.name}`),B.clearCoat.remapF0OnInterfaceChange&&h.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${B.name}`);const N=this._exporter._materialExporter.getTextureInfo(B.clearCoat.bumpTexture),r={clearcoatFactor:B.clearCoat.Vr,clearcoatTexture:Q??void 0,clearcoatRoughnessFactor:B.clearCoat.roughness,clearcoatRoughnessTexture:y??void 0,clearcoatNormalTexture:N??void 0};null===r.clearcoatTexture&&null===r.clearcoatRoughnessTexture&&null===r.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(B),J.extensions[EJ]=r}R(J)}))}}CR.RegisterExtension(EJ,(R=>new OJ(R)));const nJ="KHR_materials_diffuse_transmission";function PJ(R,J){const B=J.subSurface;let Q=null;return B.translucencyIntensityTexture?Q=B.translucencyIntensityTexture:B.thicknessTexture&&B.useMaskFromThicknessTexture&&(Q=B.thicknessTexture),Q&&!B.useGltfStyleTextures?(g.d.Warn(`${R}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${J.name}`,1),null):Q}class AJ{constructor(R){this.name=nJ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,J,B){const Q=[];if(B instanceof nR.b&&this._isExtensionEnabled(B)){const J=PJ(R,B);return J&&Q.push(J),B.subSurface.translucencyColorTexture&&Q.push(B.subSurface.translucencyColorTexture),Q}return Q}_isExtensionEnabled(R){if(R.unlit)return!1;const J=R.subSurface;return!!J.isTranslucencyEnabled&&(!R.unlit&&!J.useAlbedoToTintTranslucency&&J.useGltfStyleTextures&&1===J.volumeIndexOfRefraction&&0===J.minimumThickness&&0===J.maximumThickness)}postExportMaterialAsync(R,J,B){return new Promise((Q=>{if(B instanceof nR.b&&this._isExtensionEnabled(B)){this._wasUsed=!0;const Q=B.subSurface,h=PJ(R,B),y=0==Q.translucencyIntensity?void 0:Q.translucencyIntensity,N=this._exporter._materialExporter.getTextureInfo(h)??void 0,r=!Q.translucencyColor||Q.translucencyColor.equalsFloats(1,1,1)?void 0:Q.translucencyColor.Ch(),q=this._exporter._materialExporter.getTextureInfo(Q.translucencyColorTexture)??void 0,e={diffuseTransmissionFactor:y,diffuseTransmissionTexture:N,diffuseTransmissionColorFactor:r,diffuseTransmissionColorTexture:q};(N||q)&&this._exporter._materialNeedsUVsSet.add(B),J.extensions=J.extensions||{},J.extensions[nJ]=e}Q(J)}))}}CR.RegisterExtension(nJ,(R=>new AJ(R)));const uJ="KHR_materials_dispersion";class SJ{constructor(){this.name=uJ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(R){if(R.unlit)return!1;const J=R.subSurface;return!(!J.isRefractionEnabled&&!J.isDispersionEnabled)}postExportMaterialAsync(R,J,B){return new Promise((R=>{if(B instanceof nR.b&&this._isExtensionEnabled(B)){this._wasUsed=!0;const R={dispersion:B.subSurface.dispersion};J.extensions=J.extensions||{},J.extensions[uJ]=R}R(J)}))}}CR.RegisterExtension(uJ,(()=>new SJ));const fJ="KHR_materials_emissive_strength";class aJ{constructor(){this.name=fJ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(R,J,B){return await new Promise((R=>{if(!(B instanceof nR.b))return R(J);const Q=B.emissiveColor.Ch(),h=Math.max(...Q);if(h>1){this._wasUsed=!0,J.extensions||(J.extensions={});const R={emissiveStrength:h},Q=B.emissiveColor.scale(1/R.emissiveStrength);J.emissiveFactor=Q.Ch(),J.extensions[fJ]=R}return R(J)}))}}CR.RegisterExtension(fJ,(R=>new aJ));const sJ="KHR_materials_ior";class xJ{constructor(){this.name=sJ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(R){return!R.unlit&&(void 0!=R.indexOfRefraction&&1.5!=R.indexOfRefraction)}postExportMaterialAsync(R,J,B){return new Promise((R=>{if(B instanceof nR.b&&this._isExtensionEnabled(B)){this._wasUsed=!0;const R={ior:B.indexOfRefraction};J.extensions=J.extensions||{},J.extensions[sJ]=R}R(J)}))}}CR.RegisterExtension(sJ,(R=>new xJ));const IJ="KHR_materials_iridescence";class VJ{constructor(R){this.name=IJ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,J,B){const Q=[];return B instanceof eJ.d&&B.iridescence.isEnabled?(B.iridescence.texture&&Q.push(B.iridescence.texture),B.iridescence.thicknessTexture&&B.iridescence.thicknessTexture!==B.iridescence.texture&&Q.push(B.iridescence.thicknessTexture),Q):[]}postExportMaterialAsync(R,J,B){return new Promise((R=>{if(B instanceof eJ.d){if(!B.iridescence.isEnabled)return void R(J);this._wasUsed=!0,J.extensions=J.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(B.iridescence.texture),h=this._exporter._materialExporter.getTextureInfo(B.iridescence.thicknessTexture),y={iridescenceFactor:B.iridescence.Vr,iridescenceIor:B.iridescence.indexOfRefraction,iridescenceThicknessMinimum:B.iridescence.minimumThickness,iridescenceThicknessMaximum:B.iridescence.maximumThickness,iridescenceTexture:Q??void 0,iridescenceThicknessTexture:h??void 0};null===y.iridescenceTexture&&null===y.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(B),J.extensions[IJ]=y}R(J)}))}}CR.RegisterExtension(IJ,(R=>new VJ(R)));const MJ="KHR_materials_sheen";class HJ{constructor(R){this.name=MJ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,J,B){return B instanceof nR.b&&B.sheen.isEnabled&&B.sheen.texture?[B.sheen.texture]:[]}async postExportMaterialAsync(R,J,B){return await new Promise((R=>{if(B instanceof nR.b){if(!B.sheen.isEnabled)return void R(J);this._wasUsed=!0,null==J.extensions&&(J.extensions={});const Q={sheenColorFactor:B.sheen.color.Ch(),sheenRoughnessFactor:B.sheen.roughness??0};null===Q.sheenColorTexture&&null===Q.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(B),B.sheen.texture&&(Q.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(B.sheen.texture)??void 0),B.sheen.textureRoughness&&!B.sheen.useRoughnessFromMainTexture?Q.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(B.sheen.textureRoughness)??void 0:B.sheen.texture&&B.sheen.useRoughnessFromMainTexture&&(Q.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(B.sheen.texture)??void 0),J.extensions[MJ]=Q}R(J)}))}}CR.RegisterExtension(MJ,(R=>new HJ(R)));const dJ="KHR_materials_specular";class XJ{constructor(R){this.name=dJ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,J,B){const Q=[];return B instanceof nR.b&&this._isExtensionEnabled(B)?(B.metallicReflectanceTexture&&Q.push(B.metallicReflectanceTexture),B.reflectanceTexture&&Q.push(B.reflectanceTexture),Q):Q}_isExtensionEnabled(R){return!R.unlit&&(void 0!=R.metallicF0Factor&&1!=R.metallicF0Factor||void 0!=R.metallicReflectanceColor&&!R.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(R))}_hasTexturesExtension(R){return null!=R.metallicReflectanceTexture||null!=R.reflectanceTexture}postExportMaterialAsync(R,J,B){return new Promise((R=>{if(B instanceof nR.b&&this._isExtensionEnabled(B)){this._wasUsed=!0,J.extensions=J.extensions||{};const R=this._exporter._materialExporter.getTextureInfo(B.metallicReflectanceTexture)??void 0,Q=this._exporter._materialExporter.getTextureInfo(B.reflectanceTexture)??void 0,h={specularFactor:1==B.metallicF0Factor?void 0:B.metallicF0Factor,specularTexture:R,specularColorFactor:B.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:B.metallicReflectanceColor.Ch(),specularColorTexture:Q};this._hasTexturesExtension(B)&&this._exporter._materialNeedsUVsSet.add(B),J.extensions[dJ]=h}R(J)}))}}CR.RegisterExtension(dJ,(R=>new XJ(R)));const cJ="KHR_materials_transmission";class zJ{constructor(R){this.name=cJ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,J,B){const Q=[];return B instanceof nR.b&&this._isExtensionEnabled(B)?(B.subSurface.thicknessTexture&&Q.push(B.subSurface.thicknessTexture),Q):Q}_isExtensionEnabled(R){if(R.unlit)return!1;const J=R.subSurface;return J.isRefractionEnabled&&void 0!=J.refractionIntensity&&0!=J.refractionIntensity||this._hasTexturesExtension(R)}_hasTexturesExtension(R){return null!=R.subSurface.refractionIntensityTexture}async postExportMaterialAsync(R,J,B){if(B instanceof nR.b&&this._isExtensionEnabled(B)){this._wasUsed=!0;const Q=B.subSurface,h={transmissionFactor:0===Q.refractionIntensity?void 0:Q.refractionIntensity};if(this._hasTexturesExtension(B)&&this._exporter._materialNeedsUVsSet.add(B),Q.refractionIntensityTexture)if(Q.useGltfStyleTextures){const R=await this._exporter._materialExporter.exportTextureAsync(Q.refractionIntensityTexture,"image/png");R&&(h.transmissionTexture=R)}else g.d.Warn(`${R}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);J.extensions||(J.extensions={}),J.extensions[cJ]=h}return J}}CR.RegisterExtension(cJ,(R=>new zJ(R)));const pJ="KHR_materials_unlit";class iJ{constructor(){this.name=pJ,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(R,J,B){return new Promise((R=>{let Q=!1;B instanceof nR.b?Q=B.unlit:B instanceof PR.uJ&&(Q=B.disableLighting),Q&&(this._wasUsed=!0,null==J.extensions&&(J.extensions={}),J.extensions[pJ]={}),R(J)}))}}CR.RegisterExtension(pJ,(()=>new iJ));const WJ="KHR_materials_volume";class kJ{constructor(R){this.name=WJ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,J,B){const Q=[];return B instanceof nR.b&&this._isExtensionEnabled(B)?(B.subSurface.thicknessTexture&&Q.push(B.subSurface.thicknessTexture),Q):Q}_isExtensionEnabled(R){if(R.unlit)return!1;const J=R.subSurface;return!(!J.isRefractionEnabled&&!J.isTranslucencyEnabled)&&(void 0!=J.maximumThickness&&0!=J.maximumThickness||void 0!=J.tintColorAtDistance&&J.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=J.tintColor&&J.tintColor!=A.SJ.White()||this._hasTexturesExtension(R))}_hasTexturesExtension(R){return null!=R.subSurface.thicknessTexture}postExportMaterialAsync(R,J,B){return new Promise((R=>{if(B instanceof nR.b&&this._isExtensionEnabled(B)){this._wasUsed=!0;const R=B.subSurface,Q={thicknessFactor:0==R.maximumThickness?void 0:R.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(R.thicknessTexture)??void 0,attenuationDistance:R.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:R.tintColorAtDistance,attenuationColor:R.tintColor.equalsFloats(1,1,1)?void 0:R.tintColor.Ch()};this._hasTexturesExtension(B)&&this._exporter._materialNeedsUVsSet.add(B),J.extensions=J.extensions||{},J.extensions[WJ]=Q}R(J)}))}}CR.RegisterExtension(WJ,(R=>new kJ(R)));const YJ="EXT_materials_diffuse_roughness";class GJ{constructor(R){this.name=YJ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,J,B){const Q=[];return B instanceof eJ.d&&B._baseDiffuseRoughness?(B._baseDiffuseRoughnessTexture&&Q.push(B._baseDiffuseRoughnessTexture),Q):[]}postExportMaterialAsync(R,J,B){return new Promise((R=>{if(B instanceof eJ.d){if(!B._baseDiffuseRoughness)return void R(J);this._wasUsed=!0,J.extensions=J.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(B._baseDiffuseRoughnessTexture),h={diffuseRoughnessFactor:B._baseDiffuseRoughness,diffuseRoughnessTexture:Q??void 0};null!==h.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(B),J.extensions[YJ]=h}R(J)}))}}CR.RegisterExtension(YJ,(R=>new GJ(R)));const gJ="KHR_texture_transform";class LJ{constructor(){this.name=gJ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(R,J,B){if(B.IR()||h.Tools.Warn(`${R}: /*@__KEY__*/"scene" is not defined for Babylon texture ${B.name}!`),(0!==B.uAng||0!==B.vAng)&&(h.Tools.Warn(`${R}: Texture ${B.name} with rotation in the u or v axis is not supported in glTF.`),0!==B.uRotationCenter||0!==B.vRotationCenter))return;const Q={};let y=!1;if(0===B.uOffset&&0===B.vOffset||(Q.offset=[B.uOffset,B.vOffset],y=!0),1===B.uScale&&1===B.vScale||(Q.scale=[B.uScale,B.vScale],y=!0),0!==B.wAng){if(0!==B.uRotationCenter||0!==B.vRotationCenter){if(B.homogeneousRotationInUVTransform&&B.uScale!==B.vScale)return void h.Tools.Warn(`${R}: Texture ${B.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${gJ}.`);h.Tools.Warn(`${R}: Texture ${B.name} with non-origin rotation center will be exported using an adjusted offset with ${gJ}.`),Q.offset=function(R){const{uOffset:J,vOffset:B,uRotationCenter:Q,vRotationCenter:h,uScale:y,vScale:N,wAng:r}=R,q=Math.cos(r),e=Math.sin(r),D=Q*y,l=h*N;return[J+(D*(1-q)+l*e),B+(l*(1-q)-D*e)]}(B)}Q.rotation=-B.wAng,y=!0}0!==B.coordinatesIndex&&(Q.texCoord=B.coordinatesIndex,y=!0),y&&(this._wasUsed=!0,J.extensions||(J.extensions={}),J.extensions[gJ]=Q)}}CR.RegisterExtension(gJ,(()=>new LJ));class jJ{static CreateSTL(R){let J=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",h=arguments.length>3&&void 0!==arguments[3]&&arguments[3],y=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],N=arguments.length>5&&void 0!==arguments[5]&&arguments[5],r=arguments.length>6&&void 0!==arguments[6]&&arguments[6],q=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const e=function(R,J,B){const h=[3*R[B],3*R[B+1],3*R[B+2]],y=[new Q.nJ(J[h[0]],J[h[0]+2],J[h[0]+1]),new Q.nJ(J[h[1]],J[h[1]+2],J[h[1]+1]),new Q.nJ(J[h[2]],J[h[2]+2],J[h[2]+1])],N=y[0].PJ(y[1]),r=y[2].PJ(y[1]);return{v:y,n:Q.nJ.Cross(r,N).normalize()}},l=function(R,J,B,Q){return J=E(R,J,B.x,Q),J=E(R,J,B.y,Q),E(R,J,B.z,Q)},E=function(R,J,B,Q){return R.setFloat32(J,B,Q),J+4},n=function(R){if(r){let J=R;R instanceof O.c&&(J=R.sourceMesh);const B=J.getVerticesData(D.h.PositionKind,!0,!0);if(!B)return[];const h=Q.nJ.Zero();let y;for(y=0;y<B.length;y+=3)Q.nJ.TransformCoordinatesFromFloatsToRef(B[y],B[y+1],B[y+2],R.ny(!0),h).toArray(B,y);return B}return R.getVerticesData(D.h.PositionKind)||[]};r&&(N=!0);let P="",A=0,u=0;if(h){for(let B=0;B<R.length;B++){const J=R[B].hr();A+=J?J.length/3:0}const J=new ArrayBuffer(84+50*A);P=new DataView(J),u+=80,P.setUint32(u,A,y),u+=4}else q||(P="solid stlmesh\r\n");for(let Q=0;Q<R.length;Q++){const J=R[Q];!h&&q&&(P+="solid "+J.name+"\r\n"),!N&&J instanceof SR.e&&J.bakeCurrentTransformIntoVertices();const B=n(J),r=J.hr()||[];for(let R=0;R<r.length;R+=3){const J=e(r,B,R);h?(u=l(P,u,J.n,y),u=l(P,u,J.v[0],y),u=l(P,u,J.v[1],y),u=l(P,u,J.v[2],y),u+=2):(P+="\tfacet normal "+J.n.x+" "+J.n.y+" "+J.n.z+"\r\n",P+="\t\touter loop\r\n",P+="\t\t\tvertex "+J.v[0].x+" "+J.v[0].y+" "+J.v[0].z+"\r\n",P+="\t\t\tvertex "+J.v[1].x+" "+J.v[1].y+" "+J.v[1].z+"\r\n",P+="\t\t\tvertex "+J.v[2].x+" "+J.v[2].y+" "+J.v[2].z+"\r\n",P+="\t\tendloop\r\n",P+="\tendfacet\r\n")}!h&&q&&(P+="endsolid "+name+"\r\n")}if(h||q||(P+="endsolid stlmesh"),J){const R=document.createElement("a"),J=new Blob([P],{type:"application/octet-stream"});R.href=window.URL.createObjectURL(J),R.download=B+".stl",R.click()}return P}}function TJ(R,J){let B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const Q=[];for(let h=0;h<R.length/B;h++){const y=R[h*B],N=R[h*B+1],r=R[h*B+2];Q.push(`(${y.toPrecision(J.precision)}, ${N.toPrecision(J.precision)}, ${r.toPrecision(J.precision)})`)}return Q.join(", ")}function FJ(R,J){const B=[];for(let Q=0;Q<R.length/2;Q++){const h=R[2*Q],y=R[2*Q+1];B.push(`(${h.toPrecision(J.precision)}, ${(1-y).toPrecision(J.precision)})`)}return B.join(", ")}function CJ(R,J){const B=R.getVerticesData(D.h.PositionKind),Q=R.getVerticesData(D.h.NormalKind);if(B&&Q)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(R){var J;const B=null!==(J=R.hr())&&void 0!==J&&J.length?R.getTotalIndices():R.getTotalVertices();return Array(B/3).fill(3).join(", ")}(R)}]\n\t\tint[] faceVertexIndices = [${function(R){const J=R.hr(),B=[];if(null!==J)for(let Q=0;Q<J.length;Q++)B.push(J[Q]);else{const J=R.getTotalVertices();for(let R=0;R<J;R++)B.push(R)}return B.join(", ")}(R)}]\n\t\tnormal3f[] normals = [${TJ(Q,J)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${TJ(B,J)}]\n        ${function(R,J){let B="";for(let h=0;h<4;h++){const Q=h>0?h:"",y=R.getVerticesData(D.h.UVKind+(Q?Q+1:""));y&&(B+=`\n\t\ttexCoord2f[] primvars:st${Q} = [${FJ(y,J)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const Q=R.getVerticesData(D.h.ColorKind);return Q&&(B+=`\n\tcolor3f[] primvars:displayColor = [${TJ(Q,J,Q.length/R.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),B}(R,J)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function bJ(R,J){return`\n        def "Geometry"\n        {\n        ${CJ(R,J)}\n        }\n        `}function wJ(R){let J='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return J+=R,fflate.strToU8(J)}function KJ(R){const J=R.m;return`( ${vJ(J,0)}, ${vJ(J,4)}, ${vJ(J,8)}, ${vJ(J,12)} )`}function vJ(R,J){return`(${R[J+0]}, ${R[J+1]}, ${R[J+2]}, ${R[J+3]})`}function mJ(R){const J="Object_"+R.uniqueId,B=function(R){const J=R.getWorldMatrix().clone(),B=R.IR().useRightHandedSystem;if(!B){let Q=R.parent;for(;Q;){if(NR(Q,B)){J.multiplyToRef(Q.getWorldMatrix().invert(),J);break}Q=Q.parent}}return J.determinant()<0&&h.Tools.Warn(`Exporting mesh ${R.name} with negative scale. Result may look incorrect in destination engine.`),J}(R),Q=KJ(B);return`def Xform "${J}" (\n\tprepend references = @./geometries/Geometry_${R.py.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${Q}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${R.material.uniqueId}>\n}\n\n`}function oJ(R){switch(R){case I.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case I.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case I.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function tJ(R){return`(${R.x}, ${R.y})`}function ZJ(R){return`(${R.r}, ${R.g}, ${R.b})`}function UJ(R,J,B,h,y,N){const r=R.getInternalTexture().uniqueId+"_"+R.invertY;y[r]=R;const q=R.coordinatesIndex>0?"st"+R.coordinatesIndex:"st",e=new Q.Vector2(R.uScale,R.vScale),D=new Q.Vector2(R.uOffset,R.vOffset),l=R.wAng,E=Math.sin(l),O=Math.cos(l);return D.y=1-D.y-e.y,D.x+=E*e.x,D.y+=(1-O)*e.y,`\n    def Shader "PrimvarReader_${B}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${q}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${B}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${J.uniqueId}/PrimvarReader_${B}.outputs:result>\n        float inputs:rotation = ${(l*(180/Math.PI)).toFixed(N.precision)}\n        float2 inputs:scale = ${tJ(e)}\n        float2 inputs:translation = ${tJ(D)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${R.uniqueId}_${B}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${r}.png@\n        float2 inputs:st.connect = </Materials/Material_${J.uniqueId}/Transform2d_${B}.outputs:result>\n        ${h?"float4 inputs:scale = "+function(R){return`(${R.r}, ${R.g}, ${R.b}, 1.0)`}(h):""}\n        token inputs:sourceColorSpace = "${R.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${oJ(R.wrapU)}"\n        token inputs:wrapT = "${oJ(R.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${J.needAlphaBlending()?"float outputs:a":""}\n    }`}function RB(R,J,B){const Q="\t\t\t",h=[],y=[],{diffuseMap:N,Mr:r,alphaCutOff:q,emissiveMap:e,emissive:D,normalMap:l,roughnessMap:E,roughnessChannel:O,roughness:n,metalnessMap:P,metalnessChannel:u,metalness:S,aoMap:f,aoMapChannel:a,aoMapIntensity:s,alphaMap:x,ior:I,clearCoatEnabled:V,clearCoat:M,clearCoatMap:H,clearCoatRoughness:d,clearCoatRoughnessMap:X}=function(R){const J={diffuseMap:null,Mr:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return R instanceof PR.uJ?{...J,diffuseMap:R.diffuseTexture,Mr:R.diffuseColor,alphaCutOff:R.alphaCutOff,emissiveMap:R.emissiveTexture,emissive:R.emissiveColor,roughness:1,alphaMap:R.opacityTexture}:R instanceof eJ.d?{...J,diffuseMap:R._albedoTexture,Mr:R._albedoColor,alphaCutOff:R._alphaCutOff,emissiveMap:R._emissiveTexture,emissive:R._emissiveColor,normalMap:R._bumpTexture,roughnessMap:R._metallicTexture,roughnessChannel:R._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:R._roughness??1,metalnessMap:R._metallicTexture,metalnessChannel:R._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:R._metallic??0,aoMap:R._ambientTexture,aoMapChannel:R._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:R._ambientTextureStrength,alphaMap:R._opacityTexture,ior:R.subSurface.indexOfRefraction,clearCoatEnabled:R.clearCoat.isEnabled,clearCoat:R.clearCoat.Vr,clearCoatMap:R.clearCoat.texture,clearCoatRoughness:R.clearCoat.roughness,clearCoatRoughnessMap:R.clearCoat.useRoughnessFromMainTexture?R.clearCoat.texture:R.clearCoat.textureRoughness}:J}(R);return null!==N?(h.push(`${Q}color3f inputs:diffuseColor.connect = </Materials/Material_${R.uniqueId}/Texture_${N.uniqueId}_diffuse.outputs:rgb>`),R.needAlphaBlending()?h.push(`${Q}float inputs:opacity.connect = </Materials/Material_${R.uniqueId}/Texture_${N.uniqueId}_diffuse.outputs:a>`):R.needAlphaTesting()&&(h.push(`${Q}float inputs:opacity.connect = </Materials/Material_${R.uniqueId}/Texture_${N.uniqueId}_diffuse.outputs:a>`),h.push(`${Q}float inputs:opacityThreshold = ${q}`)),y.push(UJ(N,R,"diffuse",r,J,B))):h.push(`${Q}color3f inputs:diffuseColor = ${ZJ(r||A.SJ.White())}`),null!==e?(h.push(`${Q}color3f inputs:emissiveColor.connect = </Materials/Material_${R.uniqueId}/Texture_${e.uniqueId}_emissive.outputs:rgb>`),y.push(UJ(e,R,"emissive",D,J,B))):D&&D.toLuminance()>0&&h.push(`${Q}color3f inputs:emissiveColor = ${ZJ(D)}`),null!==l&&(h.push(`${Q}normal3f inputs:normal.connect = </Materials/Material_${R.uniqueId}/Texture_${l.uniqueId}_normal.outputs:rgb>`),y.push(UJ(l,R,"normal",null,J,B))),null!==f&&(h.push(`${Q}float inputs:occlusion.connect = </Materials/Material_${R.uniqueId}/Texture_${f.uniqueId}_occlusion.outputs:${a}>`),y.push(UJ(f,R,"occlusion",new A.SJ(s,s,s),J,B))),null!==E?(h.push(`${Q}float inputs:roughness.connect = </Materials/Material_${R.uniqueId}/Texture_${E.uniqueId}_roughness.outputs:${O}>`),y.push(UJ(E,R,"roughness",new A.SJ(n,n,n),J,B))):h.push(`${Q}float inputs:roughness = ${n}`),null!==P?(h.push(`${Q}float inputs:metallic.connect = </Materials/Material_${R.uniqueId}/Texture_${P.uniqueId}_metallic.outputs:${u}>`),y.push(UJ(P,R,"metallic",new A.SJ(S,S,S),J,B))):h.push(`${Q}float inputs:metallic = ${S}`),null!==x?(h.push(`${Q}float inputs:opacity.connect = </Materials/Material_${R.uniqueId}/Texture_${x.uniqueId}_opacity.outputs:r>`),h.push(`${Q}float inputs:opacityThreshold = 0.0001`),y.push(UJ(x,R,"opacity",null,J,B))):h.push(`${Q}float inputs:opacity = ${R.alpha}`),V&&(null!==H?(h.push(`${Q}float inputs:clearcoat.connect = </Materials/Material_${R.uniqueId}/Texture_${H.uniqueId}_clearcoat.outputs:r>`),y.push(UJ(H,R,"clearcoat",new A.SJ(M,M,M),J,B))):h.push(`${Q}float inputs:clearcoat = ${M}`),null!==X?(h.push(`${Q}float inputs:clearcoatRoughness.connect = </Materials/Material_${R.uniqueId}/Texture_${X.uniqueId}_clearcoatRoughness.outputs:g>`),y.push(UJ(X,R,"clearcoatRoughness",new A.SJ(d,d,d),J,B))):h.push(`${Q}float inputs:clearcoatRoughness = ${d}`)),h.push(`${Q}float inputs:ior = ${I}`),`\n\tdef Material "Material_${R.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${h.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${R.uniqueId}/PreviewSurface.outputs:surface>\n\n${y.join("\n")}\n\n\t}\n`}async function JB(R,J,B){const y={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...J};"undefined"===typeof fflate&&await h.Tools.LoadScriptAsync(y.fflateUrl);const N={};N[y.modelFileName]=null;let r='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';r+=function(R){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===R.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${R.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${R.planeAnchoringAlignment}"`:""}\n            `}(y);const q={};for(const Q of R.meshes){if(0===Q.getTotalVertices())continue;const R=Q,J=R.py,e=R.material;if(!e||!J||B&&!B(R))continue;if(-1!==["uJ","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(e.getClassName())){const B="geometries/Geometry_"+J.uniqueId+".usda";if(!(B in N)){const R=bJ(J,y);N[B]=wJ(R)}e.uniqueId in q||(q[e.uniqueId]=e),r+=mJ(R)}else h.Tools.Warn("USDZExportAsync does not support this material type: "+e.getClassName())}R.activeCamera&&y.exportCamera&&(r+=function(R,J){const B="Camera_"+R.uniqueId,h=KJ(Q.Matrix.RotationY(Math.PI).multiply(R.getWorldMatrix()));if(R.mode===I.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${B}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${h}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${R.mh.toPrecision(J.precision)}, ${R.maxZ.toPrecision(J.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(R.orthoLeft||1)+Math.abs(R.orthoRight||1))).toPrecision(J.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(R.orthoTop||1)+Math.abs(R.orthoBottom||1))).toPrecision(J.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const Q=R.getEngine().getAspectRatio(R),y=J.cameraSensorWidth||35;return`def Camera "${B}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${h}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${R.mh.toPrecision(J.precision)}, ${R.maxZ.toPrecision(J.precision)})\n\t\t\tfloat focalLength = ${(y/(2*Math.tan(.5*R.fov))).toPrecision(J.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(y*Q).toPrecision(J.precision)}\n\t\t\tfloat verticalAperture = ${(y/Q).toPrecision(J.precision)}            \n\t\t}\n\t\n\t`}}(R.activeCamera,y)),r+="\n            }\n        }\n    }";const e={};r+=function(R,J,B){const Q=[];for(const h in R){const y=R[h];Q.push(RB(y,J,B))}return`\n    def "Materials"\n{\n${Q.join("")}\n}\n\n`}(q,e,y),N[y.modelFileName]=fflate.strToU8(r);for(const Q in e){const R=e[Q],J=R.getSize(),B=await R.readPixels();if(!B)throw new Error("Texture data is not available");const h=await V.DumpTools.DumpDataAsync(J.width,J.height,B,"image/png",void 0,!1,!0);N[`textures/Texture_${Q}.png`]=new Uint8Array(h).slice()}let D=0;for(const Q in N){const R=N[Q];if(!R)continue;D+=34+Q.length;const J=63&D;if(4!==J){const B=new Uint8Array(64-J);N[Q]=[R,{extra:{12345:B}}]}D=R.length}return fflate.zipSync(N,{level:0})}}}]);