"use strict";(self.zcqpiao938m=self.zcqpiao938m||[]).push([[26],{12243:(C,U,K)=>{K.r(U),K.d(U,{EXT_materials_diffuse_roughness:()=>wU,EXT_mesh_gpu_instancing:()=>xC,GLTF2Export:()=>YC,GLTFData:()=>z,KHR_draco_mesh_compression:()=>KU,KHR_lights_punctual:()=>tU,KHR_materials_anisotropy:()=>pU,KHR_materials_clearcoat:()=>uU,KHR_materials_diffuse_transmission:()=>QU,KHR_materials_dispersion:()=>fU,KHR_materials_emissive_strength:()=>ZU,KHR_materials_ior:()=>HU,KHR_materials_iridescence:()=>TU,KHR_materials_sheen:()=>aU,KHR_materials_specular:()=>iU,KHR_materials_transmission:()=>lU,KHR_materials_unlit:()=>JU,KHR_materials_volume:()=>BU,KHR_texture_transform:()=>cU,OBJExport:()=>A,STLExport:()=>NU,USDZExportAsync:()=>UK,_ConvertToGLTFPBRMetallicRoughness:()=>G,_SolveMetallic:()=>l,__IGLTFExporterExtension:()=>e});var m=K(11827),O=K(11660),X=K(12158);class A{static OBJ(C,U,K,A){const e=[];let t=1,z=1;U&&(K||(K="mat"),e.push("mtllib "+K+".mtl"));for(let j=0;j<C.length;j++){const K=C[j],p=K.name||`mesh${j}}`;e.push(`o ${p}`);let E=null;if(A){const C=K.te(!0);E=new m.Matrix,C.invertToRef(E),K.bakeTransformIntoVertices(C)}if(U){const C=K.material;C&&e.push("usemtl "+C.id)}const u=K.ze;if(!u){O.Tools.Warn("No geometry is present on the mesh");continue}const b=u.getVerticesData("position"),v=u.getVerticesData("normal"),Q=u.getVerticesData("uv"),V=u.je();let f=0,F=0;if(!b||!V){O.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const Z=C[0].dC().useRightHandedSystem?1:-1;for(let C=0;C<b.length;C+=3)e.push("v "+b[C]*Z+" "+b[C+1]+" "+b[C+2]),f++;if(null!=v)for(let C=0;C<v.length;C+=3)e.push("vn "+v[C]*Z+" "+v[C+1]+" "+v[C+2]);if(null!=Q)for(let C=0;C<Q.length;C+=2)e.push("vt "+Q[C]+" "+Q[C+1]),F++;const P=["","",""],H=(K.material||K.dC().defaultMaterial)._getEffectiveOrientation(K),[d,T]=H===X.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let C=0;C<V.length;C+=3){const U=[String(V[C]+t),String(V[C+d]+t),String(V[C+T]+t)],K=[String(V[C]+z),String(V[C+d]+z),String(V[C+T]+z)],m=U,O=null!=Q?K:P,X=null!=v?U:P;e.push("f "+m[0]+"/"+O[0]+"/"+X[0]+" "+m[1]+"/"+O[1]+"/"+X[1]+" "+m[2]+"/"+O[2]+"/"+X[2])}A&&E&&K.bakeTransformIntoVertices(E),t+=f,z+=F}return e.join("\n")}static MTL(C){const U=[],K=C.material;U.push("newmtl mat1"),U.push("  Ns "+K.specularPower.toFixed(4)),U.push("  Ni 1.5000"),U.push("  d "+K.alpha.toFixed(4)),U.push("  Tr 0.0000"),U.push("  Tf 1.0000 1.0000 1.0000"),U.push("  illum 2"),U.push("  Ka "+K.ambientColor.r.toFixed(4)+" "+K.ambientColor.g.toFixed(4)+" "+K.ambientColor.b.toFixed(4)),U.push("  Kd "+K.diffuseColor.r.toFixed(4)+" "+K.diffuseColor.g.toFixed(4)+" "+K.diffuseColor.b.toFixed(4)),U.push("  Ks "+K.specularColor.r.toFixed(4)+" "+K.specularColor.g.toFixed(4)+" "+K.specularColor.b.toFixed(4)),U.push("  Ke "+K.emissiveColor.r.toFixed(4)+" "+K.emissiveColor.g.toFixed(4)+" "+K.emissiveColor.b.toFixed(4));K.ambientTexture&&U.push("  map_Ka "+K.ambientTexture.name),K.diffuseTexture&&U.push("  map_Kd "+K.diffuseTexture.name),K.specularTexture&&U.push("  map_Ks "+K.specularTexture.name),K.bumpTexture&&U.push("  map_bump -imfchan z "+K.bumpTexture.name),K.opacityTexture&&U.push("  map_d "+K.opacityTexture.name);return U.join("\n")}}var e=0,t=K(11709);class z{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const C in this.files){const U=this.files[C],K=new Blob([U],{type:(0,t.h)(C)});O.Tools.Download(K,C)}}}var j=K(11905),p=K(12249),E=K(12262),u=K(12281),b=K(11958),v=K(11703),Q=K(11879),V=K(11846);const f=V.HighestCommonFactor,F={...V,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:f};var Z=K(12067),P=K(11808),H=K(12318),d=K(12321),T=K(12061);const y=1e-6,a=new Q.fU(.04,.04,.04),r=1024,i=Q.fU.White(),D=Q.fU.Black();function l(C,U,K){if(U<a.r)return 0;const m=a.r,O=C*K/(1-a.r)+U-2*a.r,X=O*O-4*m*(a.r-U);return F.Clamp((-O+Math.sqrt(X))/(2*m),0,1)}function G(C){const U=C.diffuseColor.toLinearSpace(C.dC().getEngine().useExactSrgbConversions).scale(.5),K=C.alpha,O=function(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new m.Vector2(0,1),K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new m.Vector2(0,.1),O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new m.Vector2(0,.1),X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new m.Vector2(1300,.1);return function(C,U,K,m,O){return(1-C)*(1-C)*(1-C)*U+3*(1-C)*(1-C)*C*K+3*(1-C)*C*C*m+C*C*C*O}(Math.pow(C/X.x,.333333),U.y,K.y,O.y,X.y)}(F.Clamp(C.specularPower,0,r));return{baseColorFactor:[U.r,U.g,U.b,K],metallicFactor:0,roughnessFactor:O}}function J(C,U){U.needAlphaBlending()?C.alphaMode="BLEND":U.needAlphaTesting()&&(C.alphaMode="MASK",C.alphaCutoff=U.alphaCutOff)}function o(C,U,K){const m=new Uint8Array(C*U*4);for(let O=0;O<m.length;O+=4)m[O]=m[O+1]=m[O+2]=m[O+3]=255;return H.d.CreateRGBATexture(m,C,U,K)}function B(C){if(C instanceof Uint8Array){const U=C.length,K=new Float32Array(C.length);for(let m=0;m<U;++m)K[m]=C[m]/255;return K}if(C instanceof Float32Array)return C;throw new Error("Unsupported pixel format!")}class k{constructor(C){this._exporter=C,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(C){return C?this._textureMap.get(C)??null:null}async exportStandardMaterialAsync(C,U,K){const m=G(C),X={name:C.name};if(null==C.pe||C.pe||(C.twoSidedLighting||O.Tools.Warn(C.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),X.doubleSided=!0),K){const K=[],O=C.diffuseTexture;O&&K.push(this.exportTextureAsync(O,U).then((C=>{C&&(m.baseColorTexture=C)})));const A=C.bumpTexture;A&&K.push(this.exportTextureAsync(A,U).then((C=>{C&&(X.normalTexture=C,1!==A.level&&(X.normalTexture.scale=A.level))})));const e=C.emissiveTexture;e&&(X.emissiveFactor=[1,1,1],K.push(this.exportTextureAsync(e,U).then((C=>{C&&(X.emissiveTexture=C)}))));const t=C.ambientTexture;t&&K.push(this.exportTextureAsync(t,U).then((C=>{if(C){const U={index:C.index};X.occlusionTexture=U}}))),K.length>0&&(this._exporter._materialNeedsUVsSet.add(C),await Promise.all(K))}(C.alpha<1||C.opacityTexture)&&(C.alphaMode===d.c.ALPHA_COMBINE?X.alphaMode="BLEND":O.Tools.Warn(C.name+": glTF 2.0 does not support alpha mode: "+C.alphaMode.toString())),C.emissiveColor&&!C.emissiveColor.equalsWithEpsilon(D,y)&&(X.emissiveFactor=C.emissiveColor.Oe()),X.pbrMetallicRoughness=m,J(X,C),await this._finishMaterialAsync(X,C,U);const A=this._exporter._materials;return A.push(X),A.length-1}async _finishMaterialAsync(C,U,K){const m=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",C,U),O=[];for(const X of m)O.push(this.exportTextureAsync(X,K));await Promise.all(O),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",C,U)}async _getImageDataAsync(C,U,m,O){const X=d.c.TEXTURETYPE_UNSIGNED_BYTE,A=this._exporter._babylonScene,e=A.getEngine(),t=e.createRawTexture(C,U,m,d.c.TEXTUREFORMAT_RGBA,!1,!0,P.b.NEAREST_SAMPLINGMODE,null,X);e.isWebGPU?await K.e(51).then(K.bind(K,14281)):await K.e(52).then(K.bind(K,14289)),await Z.k.ApplyPostProcess("pass",t,A,X,d.c.TEXTURE_NEAREST_SAMPLINGMODE,d.c.TEXTUREFORMAT_RGBA);const z=await e._readTexturePixels(t,U,m);return await T.DumpTools.DumpDataAsync(U,m,z,O,void 0,!0,!0)}_resizeTexturesToSameDimensions(C,U,K){const m=C?C.getSize():{width:0,height:0},O=U?U.getSize():{width:0,height:0};let X,A;return m.width<O.width?(X=C&&C instanceof P.b?Z.k.CreateResizedCopy(C,O.width,O.height,!0):o(O.width,O.height,K),A=U):m.width>O.width?(A=U&&U instanceof P.b?Z.k.CreateResizedCopy(U,m.width,m.height,!0):o(m.width,m.height,K),X=C):(X=C,A=U),{texture1:X,texture2:A}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(C,U,K,m){const O=new Array;if(!C&&!U)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const X=C?C.dC():U?U.dC():null;if(X){var A;const e=this._resizeTexturesToSameDimensions(C,U,X),t=null===(A=e.texture1)||void 0===A?void 0:A.getSize();let z,j;const p=t.width,E=t.height,u=await e.texture1.readPixels(),b=await e.texture2.readPixels();if(!u)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(z=B(u),!b)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");j=B(b);const v=j.byteLength,V=new Uint8Array(v),f=new Uint8Array(v),F=4,Z=D;let P=0,H=0;for(let C=0;C<E;++C)for(let U=0;U<p;++U){const m=(p*C+U)*F,O={diffuseColor:new Q.fU(z[m],z[m+1],z[m+2]).toLinearSpace(X.getEngine().useExactSrgbConversions).multiply(K.diffuseColor),specularColor:new Q.fU(j[m],j[m+1],j[m+2]).toLinearSpace(X.getEngine().useExactSrgbConversions).multiply(K.specularColor),glossiness:j[m+3]*K.glossiness},A=this._convertSpecularGlossinessToMetallicRoughness(O);Z.r=Math.max(Z.r,A.baseColor.r),Z.g=Math.max(Z.g,A.baseColor.g),Z.b=Math.max(Z.b,A.baseColor.b),P=Math.max(P,A.metallic),H=Math.max(H,A.roughness),f[m]=255*A.baseColor.r,f[m+1]=255*A.baseColor.g,f[m+2]=255*A.baseColor.b,f[m+3]=e.texture1.Xe?255*z[m+3]:255,V[m]=0,V[m+1]=255*A.roughness,V[m+2]=255*A.metallic,V[m+3]=255}const d={baseColor:Z,metallic:P,roughness:H};let T=!1,a=!1;for(let C=0;C<E;++C)for(let U=0;U<p;++U){const K=(p*C+U)*F;f[K]/=d.baseColor.r>y?d.baseColor.r:1,f[K+1]/=d.baseColor.g>y?d.baseColor.g:1,f[K+2]/=d.baseColor.b>y?d.baseColor.b:1;const m=Q.fU.FromInts(f[K],f[K+1],f[K+2]).toGammaSpace(X.getEngine().useExactSrgbConversions);f[K]=255*m.r,f[K+1]=255*m.g,f[K+2]=255*m.b,m.equalsWithEpsilon(i,y)||(a=!0),V[K+1]/=d.roughness>y?d.roughness:1,V[K+2]/=d.metallic>y?d.metallic:1;Q.fU.FromInts(255,V[K+1],V[K+2]).equalsWithEpsilon(i,y)||(T=!0)}return T&&O.push(this._getImageDataAsync(V,p,E,m).then((C=>{d.metallicRoughnessTextureData=C}))),a&&O.push(this._getImageDataAsync(f,p,E,m).then((C=>{d.baseColorTextureData=C}))),await Promise.all(O).then((()=>d))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(C){const U=this._getPerceivedBrightness(C.diffuseColor),K=this._getPerceivedBrightness(C.specularColor),m=1-this._getMaxComponent(C.specularColor),O=l(U,K,m),X=C.diffuseColor.scale(m/(1-a.r)/Math.max(1-O)),A=C.specularColor.vU(a.scale(1-O)).scale(1/Math.max(O));let e=Q.fU.Lerp(X,A,O*O);e=e.clampToRef(0,1,e);return{baseColor:e,metallic:O,roughness:1-C.glossiness}}_getPerceivedBrightness(C){return C?Math.sqrt(.299*C.r*C.r+.587*C.g*C.g+.114*C.b*C.b):0}_getMaxComponent(C){return C?Math.max(C.r,Math.max(C.g,C.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(C,U,K,m){const O=[],X={baseColor:C._albedoColor,metallic:C._metallic,roughness:C._roughness};if(m){C._albedoTexture&&O.push(this.exportTextureAsync(C._albedoTexture,U).then((C=>{C&&(K.baseColorTexture=C)})));const m=C._metallicTexture;m&&O.push(this.exportTextureAsync(m,U).then((C=>{C&&(K.metallicRoughnessTexture=C)})))}return O.length>0&&(this._exporter._materialNeedsUVsSet.add(C),await Promise.all(O)),X}_getTextureSampler(C){const U={};if(!C||!(C instanceof P.b))return U;const K=this._getGLTFTextureWrapMode(C.wrapU);10497!==K&&(U.wrapS=K);const m=this._getGLTFTextureWrapMode(C.wrapV);switch(10497!==m&&(U.wrapT=m),C.samplingMode){case P.b.LINEAR_LINEAR:U.magFilter=9729,U.minFilter=9729;break;case P.b.LINEAR_NEAREST:U.magFilter=9729,U.minFilter=9728;break;case P.b.NEAREST_LINEAR:U.magFilter=9728,U.minFilter=9729;break;case P.b.NEAREST_LINEAR_MIPLINEAR:U.magFilter=9728,U.minFilter=9987;break;case P.b.NEAREST_NEAREST:U.magFilter=9728,U.minFilter=9728;break;case P.b.NEAREST_LINEAR_MIPNEAREST:U.magFilter=9728,U.minFilter=9985;break;case P.b.LINEAR_NEAREST_MIPNEAREST:U.magFilter=9729,U.minFilter=9984;break;case P.b.LINEAR_NEAREST_MIPLINEAR:U.magFilter=9729,U.minFilter=9986;break;case P.b.NEAREST_NEAREST_MIPLINEAR:U.magFilter=9728,U.minFilter=9986;break;case P.b.LINEAR_LINEAR_MIPLINEAR:U.magFilter=9729,U.minFilter=9987;break;case P.b.LINEAR_LINEAR_MIPNEAREST:U.magFilter=9729,U.minFilter=9985;break;case P.b.NEAREST_NEAREST_MIPNEAREST:U.magFilter=9728,U.minFilter=9984}return U}_getGLTFTextureWrapMode(C){switch(C){case P.b.WRAP_ADDRESSMODE:return 10497;case P.b.CLAMP_ADDRESSMODE:return 33071;case P.b.MIRROR_ADDRESSMODE:return 33648;default:return O.Tools.Error(`Unsupported Texture Wrap Mode ${C}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(C,U,K,m){const O={diffuseColor:C._albedoColor,specularColor:C._reflectivityColor,glossiness:C._microSurface},X=C._albedoTexture,A=C._reflectivityTexture,e=C._useMicroSurfaceFromReflectivityMapAlpha;if(A&&!e)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((X||A)&&m){this._exporter._materialNeedsUVsSet.add(C);const m=this._exportTextureSampler(X||A),e=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(X,A,O,U),t=this._exporter._textures;if(e.baseColorTextureData){const C=this._exportImage(`baseColor${t.length}`,U,e.baseColorTextureData);K.baseColorTexture=this._exportTextureInfo(C,m,null===X||void 0===X?void 0:X.coordinatesIndex)}if(e.metallicRoughnessTextureData){const C=this._exportImage(`metallicRoughness${t.length}`,U,e.metallicRoughnessTextureData);K.metallicRoughnessTexture=this._exportTextureInfo(C,m,null===A||void 0===A?void 0:A.coordinatesIndex)}return e}return this._convertSpecularGlossinessToMetallicRoughness(O)}async exportPBRMaterialAsync(C,U,K){const m={},O={name:C.name},X=C.isMetallicWorkflow();if(X){const U=C._albedoColor,K=C.alpha;U&&(m.baseColorFactor=[U.r,U.g,U.b,K])}const A=X?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(C,U,m,K):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(C,U,m,K);await this._setMetallicRoughnessPbrMaterialAsync(A,C,O,m,U,K),await this._finishMaterialAsync(O,C,U);const e=this._exporter._materials;return e.push(O),e.length-1}async _setMetallicRoughnessPbrMaterialAsync(C,U,K,m,X,A){if(J(K,U),C.baseColor.equalsWithEpsilon(i,y)&&F.WithinEpsilon(U.alpha,1,y)||(m.baseColorFactor=[C.baseColor.r,C.baseColor.g,C.baseColor.b,U.alpha]),null!=C.metallic&&1!==C.metallic&&(m.metallicFactor=C.metallic),null!=C.roughness&&1!==C.roughness&&(m.roughnessFactor=C.roughness),null==U.pe||U.pe||(U._twoSidedLighting||O.Tools.Warn(U.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),K.doubleSided=!0),A){const C=[],m=U._bumpTexture;m&&C.push(this.exportTextureAsync(m,X).then((C=>{C&&(K.normalTexture=C,1!==m.level&&(K.normalTexture.scale=m.level))})));const O=U._ambientTexture;O&&C.push(this.exportTextureAsync(O,X).then((C=>{if(C){const m={index:C.index,texCoord:C.texCoord,extensions:C.extensions};K.occlusionTexture=m;const O=U._ambientTextureStrength;O&&(m.strength=O)}})));const A=U._emissiveTexture;A&&C.push(this.exportTextureAsync(A,X).then((C=>{C&&(K.emissiveTexture=C)}))),C.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(C))}const e=U._emissiveColor;e.equalsWithEpsilon(D,y)||(K.emissiveFactor=e.Oe()),K.pbrMetallicRoughness=m}_getPixelsFromTextureAsync(C){return function(C){switch(C){case d.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case d.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case d.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case d.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case d.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case d.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case d.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case d.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case d.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case d.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case d.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case d.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case d.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case d.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case d.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case d.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case d.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case d.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case d.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case d.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case d.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(C.textureFormat)?(0,Z.i)(C,C._texture.width,C._texture.height):(C.textureType,d.c.TEXTURETYPE_UNSIGNED_BYTE,C.readPixels())}async exportTextureAsync(C,U){const K=this._exporter._extensionsPreExportTextureAsync("exporter",C,U);return K?await K.then((async K=>K?await this._exportTextureInfoAsync(K,U):await this._exportTextureInfoAsync(C,U))):await this._exportTextureInfoAsync(C,U)}async _exportTextureInfoAsync(C,U){let K=this._textureMap.get(C);if(!K){const m=await this._getPixelsFromTextureAsync(C);if(!m)return null;const X=this._exportTextureSampler(C),A=C.mimeType;if(A)switch(A){case"image/jpeg":case"image/png":case"image/webp":U=A;break;default:O.Tools.Warn(`Unsupported media type: ${A}. Exporting texture as PNG.`)}const e=this._internalTextureToImage,t=C.getInternalTexture().uniqueId;e[t]||(e[t]={});let z=e[t][U];if(void 0===z){const K=C.getSize();z=(async()=>{const O=await this._getImageDataAsync(m,K.width,K.height,U);return this._exportImage(C.name,U,O)})(),e[t][U]=z}K=this._exportTextureInfo(await z,X,C.coordinatesIndex),this._textureMap.set(C,K),this._exporter._extensionsPostExportTextures("exporter",K,C)}return K}_exportImage(C,U,K){const m=this._exporter._images;let X;if(this._exporter._shouldUseGlb){X={name:C,mimeType:U,bufferView:void 0};const m=this._exporter._bufferManager.createBufferView(new Uint8Array(K));this._exporter._bufferManager.setBufferView(X,m)}else{const A=C.replace(/\.\/|\/|\.\\|\\/g,"_"),e=function(C){switch(C){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(U);let t=A+e;m.some((C=>C.uri===t))&&(t=`${A}_${O.Tools.RandomId()}${e}`),X={name:C,uri:t},this._exporter._imageData[t]={data:K,mimeType:U}}return m.push(X),m.length-1}_exportTextureInfo(C,U,K){const m=this._exporter._textures;let O=m.findIndex((K=>K.sampler==U&&K.source===C));-1===O&&(O=m.length,m.push({source:C,sampler:U}));const X={index:O};return K&&(X.texCoord=K),X}_exportTextureSampler(C){const U=this._getTextureSampler(C),K=this._exporter._samplers,m=K.findIndex((C=>C.minFilter===U.minFilter&&C.magFilter===U.magFilter&&C.wrapS===U.wrapS&&C.wrapT===U.wrapT));return-1!==m?m:(K.push(U),K.length-1)}}var w=K(11918),h=K(11679),c=K(12323),N=K(11835);const g=m.bU.Zero(),M=m.Quaternion.Identity(),L=m.bU.One(),Y=new m.bU(-1,1,1);function W(C,U){const{byteOffset:K,byteStride:m,type:O,normalized:X}=C,A=C.getSize(),e=U.reduce(((C,U)=>U.getTotalVertices()>C?U.getTotalVertices():C),-Number.MAX_VALUE);return{byteOffset:K,byteStride:m,componentCount:A,type:O,count:e*A,normalized:X,totalVertices:e,kind:C.getKind()}}function x(C){switch(C){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function n(C){switch(C){case j.d.PositionKind:case j.d.NormalKind:case j.d.TangentKind:case j.d.ColorKind:case j.d.MatricesIndicesKind:case j.d.MatricesIndicesExtraKind:case j.d.MatricesWeightsKind:case j.d.MatricesWeightsExtraKind:case j.d.UVKind:case j.d.UV2Kind:case j.d.UV3Kind:case j.d.UV4Kind:case j.d.UV5Kind:case j.d.UV6Kind:return!0}return!1}function S(C){switch(C){case X.e.TriangleFillMode:return 4;case X.e.TriangleStripDrawMode:return 5;case X.e.TriangleFanDrawMode:return 6;case X.e.PointListDrawMode:case X.e.PointFillMode:return 0;case X.e.LineLoopDrawMode:return 2;case X.e.LineListDrawMode:return 1;case X.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${C}`)}function s(C){const U=Math.sqrt(C.x*C.x+C.y*C.y+C.z*C.z);U>0&&(C.x/=U,C.y/=U,C.z/=U)}function R(C){return C.x*=-1,C}function q(C){if(C.x*C.x+C.y*C.y>.5){const U=Math.abs(C.x),K=Math.abs(C.y);if(U>K){const K=Math.sign(C.x);C.x=U,C.y*=-K,C.z*=-K,C.w*=K}else{const U=Math.sign(C.y);C.x*=-U,C.y=K,C.z*=U,C.w*=-U}}else{const U=Math.abs(C.z),K=Math.abs(C.w);if(U>K){const K=Math.sign(C.z);C.x*=-K,C.y*=K,C.z=U,C.w*=-K}else{const U=Math.sign(C.w);C.x*=U,C.y*=-U,C.z*=-U,C.w=K}}return C}function I(C){C.Ee(-C.z,C.w,C.x,-C.y)}function CC(C,U){const K=m.bU.FromArrayToRef(U.translation||[0,0,0],0,m.TmpVectors.bU[0]),O=m.Quaternion.FromArrayToRef(U.rotation||[0,0,0,1],0,m.TmpVectors.Quaternion[0]),X=m.Matrix.ComposeToRef(L,O,K,m.TmpVectors.Matrix[0]),A=m.bU.FromArrayToRef(C.translation||[0,0,0],0,m.TmpVectors.bU[2]),e=m.Quaternion.FromArrayToRef(C.rotation||[0,0,0,1],0,m.TmpVectors.Quaternion[1]),t=m.Matrix.ComposeToRef(L,e,A,m.TmpVectors.Matrix[1]);X.multiplyToRef(t,t),t.decompose(void 0,O,K),K.equalsWithEpsilon(g,N.d)?delete U.translation:U.translation=K.Oe(),O.equalsWithEpsilon(M,N.d)?delete U.rotation:U.rotation=O.Oe(),U.scale&&delete U.scale}function UC(C,U){if(!(U instanceof p.b))return!1;if(!(1===U.getChildren().length&&0===C.getChildren().length&&C.parent===U))return!1;const K=C.dC(),m=C instanceof c.d&&!K.useRightHandedSystem?Y:L;return!!U.ue.equalsWithEpsilon(m,N.d)||(h.d.Warn(`Cannot collapse node ${C.name} into parent node ${U.name} with modified scaling.`),!1)}function KC(C){if(C instanceof Array){const U=new Float32Array(C);return new Uint8Array(U.buffer,U.byteOffset,U.byteLength)}return ArrayBuffer.isView(C)?new Uint8Array(C.buffer,C.byteOffset,C.byteLength):new Uint8Array(C)}function mC(C,U){for(const[K,m]of Object.entries(C)){const O=U[K];(Array.isArray(m)&&Array.isArray(O)&&OC(m,O)||m===O)&&delete C[K]}return C}function OC(C,U){return C.length===U.length&&C.every(((C,K)=>C===U[K]))}const XC=m.Matrix.Compose(new m.bU(-1,1,1),m.Quaternion.Identity(),m.bU.Zero());function AC(C,U){if(!(C instanceof p.b))return!1;if(U){if(!C.getWorldMatrix().equalsWithEpsilon(m.Matrix.IdentityReadOnly,N.d))return!1}else{if(!C.getWorldMatrix().multiplyToRef(XC,m.TmpVectors.Matrix[0]).equalsWithEpsilon(m.Matrix.IdentityReadOnly,N.d))return!1}return!(C instanceof E.d&&C.ze)}const eC=new Map([[Int8Array,(C,U,K)=>C.setInt8(U,K)],[Uint8Array,(C,U,K)=>C.setUint8(U,K)],[Uint8ClampedArray,(C,U,K)=>C.setUint8(U,K)],[Int16Array,(C,U,K)=>C.setInt16(U,K,!0)],[Uint16Array,(C,U,K)=>C.setUint16(U,K,!0)],[Int32Array,(C,U,K)=>C.setInt32(U,K,!0)],[Uint32Array,(C,U,K)=>C.setUint32(U,K,!0)],[Float32Array,(C,U,K)=>C.setFloat32(U,K,!0)],[Float64Array,(C,U,K)=>C.setFloat64(U,K,!0)]]);class tC{writeTypedArray(C){this._checkGrowBuffer(C.byteLength);const U=eC.get(C.constructor);for(let K=0;K<C.length;K++)U(this._dataView,this._byteOffset,C[K]),this._byteOffset+=C.BYTES_PER_ELEMENT}constructor(C){this._data=new Uint8Array(C),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(C){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,C),this._byteOffset++}writeInt8(C){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,C),this._byteOffset++}writeInt16(C){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,C,!0),this._byteOffset+=2}writeUInt16(C){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,C,!0),this._byteOffset+=2}writeInt32(C){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,C,!0),this._byteOffset+=4}writeUInt32(C){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,C,!0),this._byteOffset+=4}writeFloat32(C){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,C,!0),this._byteOffset+=4}writeFloat64(C){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,C,!0),this._byteOffset+=8}_checkGrowBuffer(C){const U=this.byteOffset+C;if(U>this._data.byteLength){const C=new Uint8Array(2*U);C.set(this._data),this._data=C,this._dataView=new DataView(this._data.buffer)}}}function zC(C){return C%4===0?4:C%2===0?2:1}class jC{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(C){let U=0;this._bufferViewToData.forEach((C=>{U+=C.byteLength}));const K=new tC(U),m=Array.from(this._bufferViewToData.keys()).sort(((C,U)=>zC(U.byteLength)-zC(C.byteLength)));for(const O of m){O.byteOffset=K.byteOffset,C.push(O);const U=C.length-1,m=this.getPropertiesWithBufferView(O);for(const C of m)C.bufferView=U;K.writeTypedArray(this._bufferViewToData.get(O)),this._bufferViewToData.delete(O)}return K.getOutputData()}createBufferView(C,U){const K={buffer:0,byteOffset:void 0,byteLength:C.byteLength,byteStride:U};return this._bufferViewToData.set(K,C),K}createAccessor(C,U,K,m,O,X,A){this._verifyBufferView(C);const e={bufferView:void 0,componentType:K,count:m,type:U,min:null===X||void 0===X?void 0:X.min,max:null===X||void 0===X?void 0:X.max,normalized:A,byteOffset:O};return this.setBufferView(e,C),this._accessorToBufferView.set(e,C),e}setBufferView(C,U){this._verifyBufferView(U);this.getPropertiesWithBufferView(U).push(C)}removeBufferView(C){const U=this.getPropertiesWithBufferView(C);for(const K of U)void 0!==K.bufferView&&delete K.bufferView;this._bufferViewToData.delete(C),this._bufferViewToProperties.delete(C),this._accessorToBufferView.forEach(((U,K)=>{U===C&&(void 0!==K.byteOffset&&delete K.byteOffset,this._accessorToBufferView.delete(K))}))}getBufferView(C){const U=this._accessorToBufferView.get(C);return this._verifyBufferView(U),U}getPropertiesWithBufferView(C){return this._verifyBufferView(C),this._bufferViewToProperties.set(C,this._bufferViewToProperties.get(C)??[]),this._bufferViewToProperties.get(C)}getData(C){return this._verifyBufferView(C),this._bufferViewToData.get(C)}_verifyBufferView(C){if(void 0===C||!this._bufferViewToData.has(C))throw new Error(`BufferView ${C} not found in BufferManager.`)}}var pC,EC=K(12292),uC=K(12310),bC=K(12328),vC=K(12205),QC=K(12357),VC=K(12364),fC=K(12285),FC=K(12367);!function(C){C[C.INTANGENT=0]="INTANGENT",C[C.OUTTANGENT=1]="OUTTANGENT"}(pC||(pC={}));class ZC{static _IsTransformable(C){return C&&(C instanceof p.b||C instanceof EC.b||C instanceof FC.e)}static _CreateNodeAnimation(C,U,K,m,X){if(this._IsTransformable(C)){const A=[],e=[],t=U.getKeys(),z=ZC._CalculateMinMaxKeyFrames(t),j=ZC._DeduceInterpolation(t,K,m),p=j.interpolationType,E=j.shouldBakeAnimation;if(E?ZC._CreateBakedAnimation(C,U,K,z.min,z.max,U.framePerSecond,X,A,e,z,m):"LINEAR"===p||"STEP"===p?ZC._CreateLinearOrStepAnimation(C,U,K,A,e,m):"CUBICSPLINE"===p?ZC._CreateCubicSplineAnimation(C,U,K,A,e,m):ZC._CreateBakedAnimation(C,U,K,z.min,z.max,U.framePerSecond,X,A,e,z,m),A.length&&e.length){return{inputs:A,outputs:e,samplerInterpolation:p,inputsMin:E?z.min:O.Tools.FloatRound(z.min/U.framePerSecond),inputsMax:E?z.max:O.Tools.FloatRound(z.max/U.framePerSecond)}}}return null}static _DeduceAnimationInfo(C){let U=null,K="VEC3",m=!1;const X=C.targetProperty.split(".");switch(X[0]){case"ue":U="scale";break;case"position":U="translation";break;case"rotation":K="VEC4",U="rotation";break;case"rotationQuaternion":K="VEC4",m=!0,U="rotation";break;case"influence":K="SCALAR",U="weights";break;default:O.Tools.Error(`Unsupported animatable property ${X[0]}`)}return U?{animationChannelTargetPath:U,dataAccessorType:K,useQuaternion:m}:(O.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(C,U,K,m,O,X,A,e,t,z,j){let p;if(ZC._IsTransformable(C)&&C.animations)for(const E of C.animations){if(j&&!j(E))continue;const O=ZC._DeduceAnimationInfo(E);O&&(p={name:E.name,samplers:[],channels:[]},ZC._AddAnimation(`${E.name}`,E.hasRunningRuntimeAnimations?U:p,C,E,O.dataAccessorType,O.animationChannelTargetPath,m,X,A,e,O.useQuaternion,t,z),p.samplers.length&&p.channels.length&&K.push(p))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(C,U,K,m,O,X,A,e,t,z,j){let p;if(C instanceof fC.b){const O=C.morphTargetManager;if(O)for(let E=0;E<O.numTargets;++E){const u=O.getTarget(E);for(const b of u.animations){if(j&&!j(b))continue;const u=new QC.c(`${b.name}`,"influence",b.framePerSecond,b.dataType,b.loopMode,b.enableBlending),v=[],Q=b.getKeys();for(let C=0;C<Q.length;++C){const U=Q[C];for(let C=0;C<O.numTargets;++C)C==E?v.push(U):v.push({frame:U.frame,value:0})}u.setKeys(v);const V=ZC._DeduceAnimationInfo(u);V&&(p={name:u.name,samplers:[],channels:[]},ZC._AddAnimation(b.name,b.hasRunningRuntimeAnimations?U:p,C,u,V.dataAccessorType,V.animationChannelTargetPath,m,X,A,e,V.useQuaternion,t,z,O.numTargets),p.samplers.length&&p.channels.length&&K.push(p))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(C,U,K,m,O,X,A,e,t){let z;if(C.animationGroups){const p=C.animationGroups;for(const E of p){const p=new Map,u=new Map,b=new Set,v=E.to-E.from;z={name:E.name,channels:[],samplers:[]};for(let U=0;U<E.targetedAnimations.length;++U){const v=E.targetedAnimations[U],Q=v.target,V=v.animation;if(t&&!t(V))continue;const f=e.has(Q);if(this._IsTransformable(Q)||1===Q.length&&this._IsTransformable(Q[0])){const C=ZC._DeduceAnimationInfo(v.animation);if(C){const U=this._IsTransformable(Q)?Q:this._IsTransformable(Q[0])?Q[0]:null;U&&ZC._AddAnimation(`${V.name}`,z,U,V,C.dataAccessorType,C.animationChannelTargetPath,K,m,O,X,C.useQuaternion,A,f)}}else if(Q instanceof VC.d||1===Q.length&&Q[0]instanceof VC.d){if(ZC._DeduceAnimationInfo(v.animation)){const U=Q instanceof VC.d?Q:Q[0];if(U){const K=C.morphTargetManagers.find((C=>{for(let K=0;K<C.numTargets;++K)if(C.getTarget(K)===U)return!0;return!1}));if(K){const m=C.meshes.find((C=>C.morphTargetManager===K));var j;if(m)p.has(m)||p.set(m,new Map),null===(j=p.get(m))||void 0===j||j.set(U,V),b.add(m),u.set(m,V)}}}}}b.forEach((C=>{const U=C.morphTargetManager;let e=null;const t=[],j=u.get(C).getKeys(),b=j.length;for(let K=0;K<b;++K)for(let m=0;m<U.numTargets;++m){const O=U.getTarget(m),X=p.get(C);if(X){const U=X.get(O);U?(e||(e=new QC.c(`${E.name}_${C.name}_MorphWeightAnimation`,"influence",U.framePerSecond,QC.c.ANIMATIONTYPE_FLOAT,U.loopMode,U.enableBlending)),t.push(U.getKeys()[K])):t.push({frame:E.from+v/b*K,value:O.influence,inTangent:j[0].inTangent?0:void 0,outTangent:j[0].outTangent?0:void 0})}}e.setKeys(t);const Q=ZC._DeduceAnimationInfo(e);Q&&ZC._AddAnimation(`${E.name}_${C.name}_MorphWeightAnimation`,z,C,e,Q.dataAccessorType,Q.animationChannelTargetPath,K,m,O,X,Q.useQuaternion,A,!1,null===U||void 0===U?void 0:U.numTargets)})),z.channels.length&&z.samplers.length&&U.push(z)}}}static _AddAnimation(C,U,K,O,X,A,e,t,z,j,p,E,u,b){const v=ZC._CreateNodeAnimation(K,O,A,p,E);let Q,V,f,F,Z,P;if(v){if(b){let C=0,U=0;const K=[];for(;v.inputs.length>0;)U=v.inputs.shift(),C%b==0&&K.push(U),C++;v.inputs=K}const C=e.get(K),O=new Float32Array(v.inputs);Q=t.createBufferView(O),V=t.createAccessor(Q,"SCALAR",5126,v.inputs.length,void 0,{min:[v.inputsMin],max:[v.inputsMax]}),j.push(V),f=j.length-1;const z=new m.Quaternion,p=new m.bU,E=new m.bU,H=K instanceof EC.b,d=x(X),T=new Float32Array(v.outputs.length*d);v.outputs.forEach((function(C,U){let K=C;switch(A){case"translation":u&&(m.bU.FromArrayToRef(C,0,E),R(E),E.toArray(K));break;case"rotation":4===C.length?m.Quaternion.FromArrayToRef(C,0,z):(K=new Array(4),m.bU.FromArrayToRef(C,0,p),m.Quaternion.FromEulerVectorToRef(p,z)),u&&(q(z),H&&I(z)),z.toArray(K)}T.set(K,U*d)})),Q=t.createBufferView(T),V=t.createAccessor(Q,X,5126,v.outputs.length),j.push(V),F=j.length-1,Z={interpolation:v.samplerInterpolation,input:f,output:F},U.samplers.push(Z),P={sampler:U.samplers.length-1,target:{node:C,path:A}},U.channels.push(P)}}static _CreateBakedAnimation(C,U,K,X,A,e,t,z,j,p,E){let u;const b=m.Quaternion.Identity();let v,Q=null,V=null,f=null,F=null,Z=null,P=null;p.min=O.Tools.FloatRound(X/e);const H=U.getKeys();for(let m=0,d=H.length;m<d;++m){if(P=null,f=H[m],m+1<d)if(F=H[m+1],f.value.equals&&f.value.equals(F.value)||f.value===F.value){if(0!==m)continue;P=f.frame}else P=F.frame;else{if(Z=H[m-1],f.value.equals&&f.value.equals(Z.value)||f.value===Z.value)continue;P=A}if(P)for(let m=f.frame;m<=P;m+=t){if(v=O.Tools.FloatRound(m/e),v===Q)continue;Q=v,V=v;const X={key:0,repeatCount:0,loopMode:U.loopMode};u=U._interpolate(m,X),ZC._SetInterpolatedValue(C,u,v,U,K,b,z,j,E)}}V&&(p.max=V)}static _ConvertFactorToVector3OrQuaternion(C,U,K,X,A){const e=ZC._GetBasePositionRotationOrScale(U,X,A),t=K.targetProperty.split("."),z=t?t[1]:"",j=A?m.Quaternion.FU(e).normalize():m.bU.FU(e);switch(z){case"x":case"y":case"z":j[z]=C;break;case"w":j.w=C;break;default:O.Tools.Error(`glTFAnimation: Unsupported component name "${z}"!`)}return j}static _SetInterpolatedValue(C,U,K,O,X,A,e,t,z){let j;e.push(K),"weights"!==X?(O.dataType===QC.c.ANIMATIONTYPE_FLOAT&&(U=this._ConvertFactorToVector3OrQuaternion(U,C,O,X,z)),"rotation"===X?(z?A=U:(j=U,m.Quaternion.RotationYawPitchRollToRef(j.y,j.x,j.z,A)),t.push(A.Oe())):(j=U,t.push(j.Oe()))):t.push([U])}static _CreateLinearOrStepAnimation(C,U,K,m,O,X){for(const A of U.getKeys())m.push(A.frame/U.framePerSecond),ZC._AddKeyframeValue(A,U,O,K,C,X)}static _CreateCubicSplineAnimation(C,U,K,m,O,X){U.getKeys().forEach((function(A){m.push(A.frame/U.framePerSecond),ZC._AddSplineTangent(pC.INTANGENT,O,K,"CUBICSPLINE",A,X),ZC._AddKeyframeValue(A,U,O,K,C,X),ZC._AddSplineTangent(pC.OUTTANGENT,O,K,"CUBICSPLINE",A,X)}))}static _GetBasePositionRotationOrScale(C,U,K){let O;if("rotation"===U)if(K){O=(C.rotationQuaternion??m.Quaternion.Identity()).Oe()}else{O=(C.rotation??m.bU.Zero()).Oe()}else if("translation"===U){O=(C.position??m.bU.Zero()).Oe()}else{O=(C.ue??m.bU.One()).Oe()}return O}static _AddKeyframeValue(C,U,K,X,A,e){let t;const z=U.dataType;if(z===QC.c.ANIMATIONTYPE_VECTOR3){let U=C.value.Oe();if("rotation"===X){const C=m.bU.FU(U);U=m.Quaternion.RotationYawPitchRoll(C.y,C.x,C.z).Oe()}K.push(U)}else if(z===QC.c.ANIMATIONTYPE_FLOAT){if("weights"===X)K.push([C.value]);else if(t=this._ConvertFactorToVector3OrQuaternion(C.value,A,U,X,e),t){if("rotation"===X){const C=e?t:m.Quaternion.RotationYawPitchRoll(t.y,t.x,t.z).normalize();K.push(C.Oe())}K.push(t.Oe())}}else z===QC.c.ANIMATIONTYPE_QUATERNION?K.push(C.value.normalize().Oe()):O.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(C,U,K){let m,O,X=!1;if("rotation"===U&&!K)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let A=0,e=C.length;A<e;++A)if(O=C[A],O.inTangent||O.outTangent)if(m){if("CUBICSPLINE"!==m){m="LINEAR",X=!0;break}}else m="CUBICSPLINE";else if(m){if("CUBICSPLINE"===m||O.interpolation&&1===O.interpolation&&"STEP"!==m){m="LINEAR",X=!0;break}}else m=O.interpolation&&1===O.interpolation?"STEP":"LINEAR";return m||(m="LINEAR"),{interpolationType:m,shouldBakeAnimation:X}}static _AddSplineTangent(C,U,K,O,X,A){let e;const t=C===pC.INTANGENT?X.inTangent:X.outTangent;if("CUBICSPLINE"===O){if("rotation"===K)if(t)if(A)e=t.Oe();else{const C=t;e=m.Quaternion.RotationYawPitchRoll(C.y,C.x,C.z).Oe()}else e=[0,0,0,0];else e="weights"===K?t?[t]:[0]:t?t.Oe():[0,0,0];U.push(e)}}static _CalculateMinMaxKeyFrames(C){let U=1/0,K=-1/0;return C.forEach((function(C){U=Math.min(U,C.frame),K=Math.max(K,C.frame)})),{min:U,max:K}}}function PC(C,U,K,X,A,e){const t={attributes:{},influence:C.influence,name:C.name},z=U.ze;if(!z)return O.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),t;const p=e?-1:1,E=m.bU.Zero();let u=0,b=0;if(C.hasPositions){const X=C.getPositions(),e=z.getVerticesData(j.d.PositionKind);if(e){const C=new Float32Array(e.length),U=[1/0,1/0,1/0],O=[-1/0,-1/0,-1/0];b=e.length/3,u=0;for(let K=u;K<b;++K){const A=m.bU.FU(e,3*K);m.bU.FU(X,3*K).subtractToRef(A,E),E.x*=p,U[0]=Math.min(U[0],E.x),O[0]=Math.max(O[0],E.x),U[1]=Math.min(U[1],E.y),O[1]=Math.max(O[1],E.y),U[2]=Math.min(U[2],E.z),O[2]=Math.max(O[2],E.z),C[3*K]=E.x,C[3*K+1]=E.y,C[3*K+2]=E.z}const z=K.createBufferView(C,12),j=K.createAccessor(z,"VEC3",5126,X.length/3,0,{min:U,max:O});A.push(j),t.attributes.POSITION=A.length-1}else O.Tools.Warn(`Morph target positions for mesh ${U.name} were not exported. Mesh does not have position vertex data`)}if(C.hasNormals){const X=C.getNormals(),e=z.getVerticesData(j.d.NormalKind);if(e){const C=new Float32Array(e.length);b=e.length/3,u=0;for(let K=u;K<b;++K){const U=m.bU.FU(e,3*K).normalize();m.bU.FU(X,3*K).normalize().subtractToRef(U,E),C[3*K]=E.x*p,C[3*K+1]=E.y,C[3*K+2]=E.z}const U=K.createBufferView(C,12),O=K.createAccessor(U,"VEC3",5126,X.length/3,0);A.push(O),t.attributes.NORMAL=A.length-1}else O.Tools.Warn(`Morph target normals for mesh ${U.name} were not exported. Mesh does not have normals vertex data`)}if(C.hasTangents){const X=C.getTangents(),e=z.getVerticesData(j.d.TangentKind);if(e){b=e.length/4;const C=new Float32Array(3*b);u=0;for(let K=u;K<b;++K){const U=m.bU.FU(e,4*K);s(U);const O=m.bU.FU(X,3*K);s(O),O.subtractToRef(U,E),C[3*K]=E.x*p,C[3*K+1]=E.y,C[3*K+2]=E.z}const U=K.createBufferView(C,12),O=K.createAccessor(U,"VEC3",5126,b,0);A.push(O),t.attributes.TANGENT=A.length-1}else O.Tools.Warn(`Morph target tangents for mesh ${U.name} were not exported. Mesh does not have tangents vertex data`)}if(C.hasColors){const X=C.getColors(),e=z.getVerticesData(j.d.ColorKind),p=z.getVertexBuffer(j.d.ColorKind);if(e&&p){const C=p.getSize();b=e.length/C;const U=new Float32Array(b*C);u=0;for(let K=u;K<b;++K)if(3===C){const O=m.bU.FU(e,K*C);m.bU.FU(X,K*C).subtractToRef(O,E),U[3*K]=E.x,U[3*K+1]=E.y,U[3*K+2]=E.z}else if(4===C){const O=new m.Vector4,A=m.Vector4.FU(e,K*C);m.Vector4.FU(X,K*C).subtractToRef(A,O),U[4*K]=O.x,U[4*K+1]=O.y,U[4*K+2]=O.z,U[4*K+3]=O.w}else O.Tools.Warn(`Unsupported number of components for color attribute: ${C}`);const z=K.createBufferView(U,4*C),j=K.createAccessor(z,3===C?"VEC3":"VEC4",5126,b,0);A.push(j),t.attributes.COLOR_0=A.length-1}else O.Tools.Warn(`Morph target colors for mesh ${U.name} were not exported. Mesh does not have colors vertex data`)}return t}var HC=K(12376),dC=K(12232),TC=K(12216),yC=K(11789);class aC{}aC.DEFAULT_COLOR=Q.fU.White(),aC.DEFAULT_WIDTH_ATTENUATED=1,aC.DEFAULT_WIDTH=.1;var rC=K(12045),iC=K(12383);class DC{static ConvertPoints(C,U){if(C.length&&Array.isArray(C)&&"number"===typeof C[0])return[C];if(C.length&&Array.isArray(C[0])&&"number"===typeof C[0][0])return C;if(C.length&&!Array.isArray(C[0])&&C[0]instanceof m.bU){const U=[];for(let K=0;K<C.length;K++){const m=C[K];U.push(m.x,m.y,m.z)}return[U]}if(C.length>0&&Array.isArray(C[0])&&C[0].length>0&&C[0][0]instanceof m.bU){const U=[],K=C;for(const C of K)U.push(C.flatMap((C=>[C.x,C.y,C.z])));return U}if(C instanceof Float32Array){if(null!==U&&void 0!==U&&U.floatArrayStride){const K=[],m=3*U.floatArrayStride;for(let U=0;U<C.length;U+=m){const O=new Array(m);for(let K=0;K<m;K++)O[K]=C[U+K];K.push(O)}return K}return[Array.from(C)]}if(C.length&&C[0]instanceof Float32Array){const U=[];for(const K of C)U.push(Array.from(K));return U}return[]}static OmitZeroLengthPredicate(C,U,K){const m=[];return U.vU(C).lengthSquared()>0&&m.push([C,U]),K.vU(U).lengthSquared()>0&&m.push([U,K]),C.vU(K).lengthSquared()>0&&m.push([K,C]),0===m.length?null:m}static OmitDuplicatesPredicate(C,U,K,m){const O=[];return DC._SearchInPoints(C,U,m)||O.push([C,U]),DC._SearchInPoints(U,K,m)||O.push([U,K]),DC._SearchInPoints(K,C,m)||O.push([K,C]),0===O.length?null:O}static _SearchInPoints(C,U,K){for(const A of K)for(let K=0;K<A.length;K++){var m,O,X;if(null!==(m=A[K])&&void 0!==m&&m.equals(C))if(null!==(O=A[K+1])&&void 0!==O&&O.equals(U)||null!==(X=A[K-1])&&void 0!==X&&X.equals(U))return!0}return!1}static MeshesToLines(C,U){const K=[];for(let O=0;O<C.length;O++){const X=C[O],A=X.getVerticesData(j.d.PositionKind),e=X.je();if(A&&e)for(let C=0,t=0;C<e.length;C++){const z=3*e[t++],j=3*e[t++],p=3*e[t++],E=new m.bU(A[z],A[z+1],A[z+2]),u=new m.bU(A[j],A[j+1],A[j+2]),b=new m.bU(A[p],A[p+1],A[p+2]);if(U){const m=U(E,u,b,K,C,z,X,O,A,e);if(m)for(const C of m)K.push(C)}else K.push([E,u],[u,b],[b,E])}}return K}static ToVector3Array(C){if(Array.isArray(C[0])){const U=[],K=C;for(const C of K){const K=[];for(let U=0;U<C.length;U+=3)K.push(new m.bU(C[U],C[U+1],C[U+2]));U.push(K)}return U}const U=C,K=[];for(let O=0;O<U.length;O+=3)K.push(new m.bU(U[O],U[O+1],U[O+2]));return K}static ToNumberArray(C){return C.flatMap((C=>[C.x,C.y,C.z]))}static GetPointsCountInfo(C){const U=new Array(C.length);let K=0;for(let m=C.length;m--;)U[m]=C[m].length/3,K+=U[m];return{total:K,counts:U}}static GetLineLength(C){if(0===C.length)return 0;let U;U="number"===typeof C[0]?DC.ToVector3Array(C):C;const K=m.TmpVectors.bU[0];let O=0;for(let m=0;m<U.length-1;m++){const C=U[m];O+=U[m+1].subtractToRef(C,K).length()}return O}static GetLineLengthArray(C){const U=new Float32Array(C.length/3);let K=0;for(let m=0,O=C.length/3-1;m<O;m++){let O=C[3*m+0],X=C[3*m+1],A=C[3*m+2];O-=C[3*m+3],X-=C[3*m+4],A-=C[3*m+5];K+=Math.sqrt(O*O+X*X+A*A),U[m+1]=K}return U}static SegmentizeSegmentByCount(C,U,K){const O=[],X=U.vU(C),A=m.TmpVectors.bU[0];A.be(K);const e=m.TmpVectors.bU[1];X.divideToRef(A,e);let t=C.clone();O.push(t);for(let m=0;m<K;m++)t=t.clone(),O.push(t.addInPlace(e));return O}static SegmentizeLineBySegmentLength(C,U){const K=C[0]instanceof m.bU?DC.GetLineSegments(C):"number"===typeof C[0]?DC.GetLineSegments(DC.ToVector3Array(C)):C,O=[];for(const m of K)if(m.length>U){const C=DC.SegmentizeSegmentByCount(m.point1,m.point2,Math.ceil(m.length/U));for(const U of C)O.push(U)}else O.push(m.point1),O.push(m.point2);return O}static SegmentizeLineBySegmentCount(C,U){const K="number"===typeof C[0]?DC.ToVector3Array(C):C,m=DC.GetLineLength(K)/U;return DC.SegmentizeLineBySegmentLength(K,m)}static GetLineSegments(C){const U=[];for(let K=0;K<C.length-1;K++){const m=C[K],O=C[K+1],X=O.vU(m).length();U.push({point1:m,point2:O,length:X})}return U}static GetMinMaxSegmentLength(C){const U=DC.GetLineSegments(C).sort((C=>C.length));return{min:U[0].length,max:U[U.length-1].length}}static GetPositionOnLineByVisibility(C,U,K){let O=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const X=U*K;let A=0,e=0;const t=C.length;for(let m=0;m<t;m++){if(X<=A+C[m].length){e=m;break}A+=C[m].length}const z=(X-A)/C[e].length;return C[e].point2.subtractToRef(C[e].point1,m.TmpVectors.bU[0]),m.TmpVectors.bU[1]=m.TmpVectors.bU[0].multiplyByFloats(z,z,z),O||m.TmpVectors.bU[1].addInPlace(C[e].point1),m.TmpVectors.bU[1].clone()}static GetCircleLinePoints(C,U){let K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C,X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/U;const A=[];for(let e=0;e<=U;e++)A.push(new m.bU(Math.cos(e*X)*C,Math.sin(e*X)*O,K));return A}static GetBezierLinePoints(C,U,K,m){return rC.e.CreateQuadraticBezier(C,U,K,m).getPoints().flatMap((C=>[C.x,C.y,C.z]))}static GetArrowCap(C,U,K,m,O){let X=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,A=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[C.clone(),C.add(U.multiplyByFloats(K,K,K))],widths:[m,O,X,A]}}static GetPointsFromText(C,U,K,m){let O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,X=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const A=[],e=(0,iC.e)(C,U,K,m);for(const t of e){for(const C of t.paths){const U=[],K=C.getPoints();for(const C of K)U.push(C.x,C.y,O);A.push(U)}if(X)for(const C of t.holes){const U=[],K=C.getPoints();for(const C of K)U.push(C.x,C.y,O);A.push(U)}}return A}static Color3toRGBAUint8(C){const U=new Uint8Array(4*C.length);for(let K=0,m=0;K<C.length;K++)U[m++]=255*C[K].r,U[m++]=255*C[K].g,U[m++]=255*C[K].b,U[m++]=255;return U}static CreateColorsTexture(C,U,K,m){const O=m.getEngine().getCaps().maxTextureSize??1,X=U.length>O?O:U.length,A=Math.ceil(U.length/O);A>1&&(U=[...U,...Array(X*A-U.length).fill(U[0])]);const e=DC.Color3toRGBAUint8(U),t=new H.d(e,X,A,b.c.TEXTUREFORMAT_RGBA,m,!1,!0,K);return t.name=C,t}static PrepareEmptyColorsTexture(C){if(!aC.EmptyColorsTexture){const U=new Uint8Array(4);aC.EmptyColorsTexture=new H.d(U,1,1,b.c.TEXTUREFORMAT_RGBA,C,!1,!1,H.d.NEAREST_NEAREST),aC.EmptyColorsTexture.name="grlEmptyColorsTexture"}return aC.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var C;null===(C=aC.EmptyColorsTexture)||void 0===C||C.dispose(),aC.EmptyColorsTexture=null}static BooleanToNumber(C){return C?1:0}}class lC extends TC.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class GC extends dC.b{isCompatible(C){return!0}constructor(C,U,K){var O;K=K||{color:aC.DEFAULT_COLOR};const X=new lC;X.GREASED_LINE_HAS_COLOR=!!K.color&&!K.useColors,X.GREASED_LINE_SIZE_ATTENUATION=K.sizeAttenuation??!1,X.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===K.colorDistributionType,X.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(U??C.dC()).useRightHandedSystem,X.GREASED_LINE_CAMERA_FACING=K.cameraFacing??!0,super(C,GC.GREASED_LINE_MATERIAL_NAME,200,X,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(O=K)||void 0===O?void 0:O.forceGLSL)||GC.ForceGLSL,this._scene=U??C.dC(),this._engine=this._scene.getEngine(),this._cameraFacing=K.cameraFacing??!0,this.visibility=K.visibility??1,this.useDash=K.useDash??!1,this.dashRatio=K.dashRatio??.5,this.dashOffset=K.dashOffset??0,this.width=K.width?K.width:K.sizeAttenuation?aC.DEFAULT_WIDTH_ATTENUATED:aC.DEFAULT_WIDTH,this._sizeAttenuation=K.sizeAttenuation??!1,this.colorMode=K.colorMode??0,this._color=K.color??null,this.useColors=K.useColors??!1,this._colorsDistributionType=K.colorDistributionType??0,this.colorsSampling=K.colorsSampling??H.d.NEAREST_NEAREST,this._colors=K.rC??null,this.dashCount=K.dashCount??1,this.resolution=K.resolution??new m.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),K.colorsTexture?this.colorsTexture=K.colorsTexture:this._colors?this.colorsTexture=DC.CreateColorsTexture(`${C.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??aC.DEFAULT_COLOR,DC.PrepareEmptyColorsTexture(this._scene)),this._engine.RA.add((()=>{DC.DisposeEmptyColorsTexture()}))}getAttributes(C){C.push("grl_offsets"),C.push("grl_widths"),C.push("grl_colorPointers"),C.push("grl_counters"),this._cameraFacing?(C.push("grl_previousAndSide"),C.push("grl_nextAndCounters")):C.push("grl_slopes")}getSamplers(C){C.push("grl_colors")}getActiveTextures(C){this.colorsTexture&&C.push(this.colorsTexture)}getUniforms(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const U=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&U.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===C&&U.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:U,vertex:this._cameraFacing&&this._isGLSL(C)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(C)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(C){if(this._cameraFacing){C.ee("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||C.ee("viewProjection",this._scene.getTransformMatrix());const U=m.TmpVectors.Vector4[0];U.x=this._aspect,U.y=this._resolution.x,U.z=this._resolution.y,U.w=this.width,C.updateVector4("grl_aspect_resolution_lineWidth",U)}const U=m.TmpVectors.Vector4[0];U.x=DC.BooleanToNumber(this.useDash),U.y=this._dashArray,U.z=this.dashOffset,U.w=this.dashRatio,C.updateVector4("grl_dashOptions",U);const K=m.TmpVectors.Vector4[1];K.x=this.colorMode,K.y=this.visibility,K.z=this.colorsTexture?this.colorsTexture.getSize().width:0,K.w=DC.BooleanToNumber(this.useColors),C.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",K),this._color&&C.updateColor3("grl_singleColor",this._color);const O=this.colorsTexture??aC.EmptyColorsTexture;C.setTexture("grl_colors",O),C.updateFloat2("grl_textureSize",(null===O||void 0===O?void 0:O.getSize().width)??1,(null===O||void 0===O?void 0:O.getSize().height)??1)}prepareDefines(C,U,K){C.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,C.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,C.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,C.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=U.useRightHandedSystem,C.GREASED_LINE_CAMERA_FACING=this._cameraFacing,C.GREASED_LINE_USE_OFFSETS=!!K.offsets}getClassName(){return GC.GREASED_LINE_MATERIAL_NAME}getCustomCode(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(U)?function(C,U){if("vertex"===C){const C={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return U&&(C["!gl_Position\\=viewProjection\\*worldPos;"]="//"),C}return"fragment"===C?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(C,this._cameraFacing):function(C,U){if("vertex"===C){const C={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return U&&(C["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),C}return"fragment"===C?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(C,this._cameraFacing)}dispose(){var C;null===(C=this.colorsTexture)||void 0===C||C.dispose(),super.dispose()}get rC(){return this._colors}set rC(C){this.setColors(C)}setColors(C){var U;let K=arguments.length>1&&void 0!==arguments[1]&&arguments[1],m=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const O=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var X;if(this._colors=C,null!==C&&0!==C.length){if(!K||m)if(this.colorsTexture&&O===C.length&&!m){const U=DC.Color3toRGBAUint8(C);this.colorsTexture.update(U)}else{var A;null===(A=this.colorsTexture)||void 0===A||A.dispose(),this.colorsTexture=DC.CreateColorsTexture(`${this._material.name}-colors-texture`,C,this.colorsSampling,this._scene)}}else null===(X=this.colorsTexture)||void 0===X||X.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(C){this._dashCount=C,this._dashArray=1/C}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(C){this._sizeAttenuation=C,this.markAllDefinesAsDirty()}get color(){return this._color}set color(C){this.setColor(C)}setColor(C){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==C||null!==this._color&&null===C?(this._color=C,U||this.markAllDefinesAsDirty()):this._color=C}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(C){this._colorsDistributionType=C,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(C){this._aspect=C.x/C.y,this._resolution=C}serialize(){const C=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(U.rC=this._colors),this._color&&(U.color=this._color),C.greasedLineMaterialOptions=U,C}parse(C,U,K){var m;super.parse(C,U,K);const O=C.greasedLineMaterialOptions;null===(m=this.colorsTexture)||void 0===m||m.dispose(),O.color&&this.setColor(O.color,!0),O.colorDistributionType&&(this.colorsDistributionType=O.colorDistributionType),O.rC&&(this.rC=O.rC),O.colorsSampling&&(this.colorsSampling=O.colorsSampling),O.colorMode&&(this.colorMode=O.colorMode),O.useColors&&(this.useColors=O.useColors),O.visibility&&(this.visibility=O.visibility),O.useDash&&(this.useDash=O.useDash),O.dashCount&&(this.dashCount=O.dashCount),O.dashRatio&&(this.dashRatio=O.dashRatio),O.dashOffset&&(this.dashOffset=O.dashOffset),O.width&&(this.width=O.width),O.sizeAttenuation&&(this.sizeAttenuation=O.sizeAttenuation),O.resolution&&(this.resolution=O.resolution),this.rC?this.colorsTexture=DC.CreateColorsTexture(`${this._material.name}-colors-texture`,this.rC,this.colorsSampling,U):DC.PrepareEmptyColorsTexture(U),this.markAllDefinesAsDirty()}copyTo(C){var U;const K=C;null===(U=K.colorsTexture)||void 0===U||U.dispose(),this._colors&&(K.colorsTexture=DC.CreateColorsTexture(`${K._material.name}-colors-texture`,this._colors,K.colorsSampling,this._scene)),K.setColor(this.color,!0),K.colorsDistributionType=this.colorsDistributionType,K.colorsSampling=this.colorsSampling,K.colorMode=this.colorMode,K.useColors=this.useColors,K.visibility=this.visibility,K.useDash=this.useDash,K.dashCount=this.dashCount,K.dashRatio=this.dashRatio,K.dashOffset=this.dashOffset,K.width=this.width,K.sizeAttenuation=this.sizeAttenuation,K.resolution=this.resolution,K.markAllDefinesAsDirty()}_isGLSL(C){return 0===C||this._forceGLSL}}GC.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",GC.ForceGLSL=!1,(0,yC.h)(`BABYLON.${GC.GREASED_LINE_MATERIAL_NAME}`,GC);var JC=K(12265),oC=K(11685),BC=K(12072),kC=K(11775);class wC extends BC.ShaderMaterial{constructor(C,U,O){const X=U.getEngine(),A=X.isWebGPU&&!(O.forceGLSL||wC.ForceGLSL),e=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];U.useRightHandedSystem&&e.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const t=["position","grl_widths","grl_offsets","grl_colorPointers"];O.cameraFacing?(e.push("GREASED_LINE_CAMERA_FACING"),t.push("grl_previousAndSide","grl_nextAndCounters")):(t.push("grl_slopes"),t.push("grl_counters"));const z=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(A||z.push("world","viewProjection","view","projection"),super(C,U,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:A?["Scene","Mesh"]:void 0,attributes:t,uniforms:z,samplers:A?[]:["grlColors"],defines:e,extraInitializationsAsync:async()=>{A?await Promise.all([K.e(66).then(K.bind(K,14916)),K.e(75).then(K.bind(K,14923))]):await Promise.all([K.e(69).then(K.bind(K,14928)),K.e(76).then(K.bind(K,14933))])},shaderLanguage:A?1:0}),this._color=Q.fU.White(),this._colorsDistributionType=0,this._colorsTexture=null,O=O||{color:aC.DEFAULT_COLOR},this.visibility=O.visibility??1,this.useDash=O.useDash??!1,this.dashRatio=O.dashRatio??.5,this.dashOffset=O.dashOffset??0,this.dashCount=O.dashCount??1,this.width=O.width?O.width:O.sizeAttenuation&&O.cameraFacing?aC.DEFAULT_WIDTH_ATTENUATED:aC.DEFAULT_WIDTH,this.sizeAttenuation=O.sizeAttenuation??!1,this.color=O.color??Q.fU.White(),this.useColors=O.useColors??!1,this.colorsDistributionType=O.colorDistributionType??0,this.colorsSampling=O.colorsSampling??H.d.NEAREST_NEAREST,this.colorMode=O.colorMode??0,this._colors=O.rC??null,this._cameraFacing=O.cameraFacing??!0,this.resolution=O.resolution??new m.Vector2(X.getRenderWidth(),X.getRenderHeight()),O.colorsTexture?this.colorsTexture=O.colorsTexture:this._colors?this.colorsTexture=DC.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,U):(this._color=this._color??aC.DEFAULT_COLOR,this.colorsTexture=DC.PrepareEmptyColorsTexture(U)),A){const C=new kC.d;C.setParameters(),C.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",C)}X.RA.add((()=>{DC.DisposeEmptyColorsTexture()}))}dispose(){var C;null===(C=this._colorsTexture)||void 0===C||C.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new m.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get rC(){return this._colors}set rC(C){this.setColors(C)}setColors(C){var U;let K=arguments.length>1&&void 0!==arguments[1]&&arguments[1],m=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const O=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var X;if(this._colors=C,null!==C&&0!==C.length){if(!K||m)if(this._colorsTexture&&O===C.length&&!m){const U=DC.Color3toRGBAUint8(C);this._colorsTexture.update(U)}else{var A;null===(A=this._colorsTexture)||void 0===A||A.dispose(),this.colorsTexture=DC.CreateColorsTexture(`${this.name}-colors-texture`,C,this.colorsSampling,this.dC())}}else null===(X=this._colorsTexture)||void 0===X||X.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(C){this._colorsTexture=C,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(C){this._width=C,this.setFloat("grlWidth",C)}get useColors(){return this._useColors}set useColors(C){this._useColors=C,this.setFloat("grlUseColors",DC.BooleanToNumber(C))}get colorsSampling(){return this._colorsSampling}set colorsSampling(C){this._colorsSampling=C}get visibility(){return this._visibility}set visibility(C){this._visibility=C,this.setFloat("grlVisibility",C)}get useDash(){return this._useDash}set useDash(C){this._useDash=C,this.setFloat("grlUseDash",DC.BooleanToNumber(C))}get dashOffset(){return this._dashOffset}set dashOffset(C){this._dashOffset=C,this.setFloat("grlDashOffset",C)}get dashRatio(){return this._dashRatio}set dashRatio(C){this._dashRatio=C,this.setFloat("grlDashRatio",C)}get dashCount(){return this._dashCount}set dashCount(C){this._dashCount=C,this._dashArray=1/C,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(C){this._sizeAttenuation=C,this.setFloat("grlSizeAttenuation",DC.BooleanToNumber(C))}get color(){return this._color}set color(C){this.setColor(C)}setColor(C){C=C??aC.DEFAULT_COLOR,this._color=C,this.setColor3("grlColor",C)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(C){this._colorsDistributionType=C,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(C){this._colorMode=C,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(C){this._resolution=C,this.setVector2("grlResolution",C),this.setFloat("grlAspect",C.x/C.y)}serialize(){const C=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(U.rC=this._colors),C.greasedLineMaterialOptions=U,C}parse(C,U,K){var m;const O=C.greasedLineMaterialOptions;null===(m=this._colorsTexture)||void 0===m||m.dispose(),O.color&&(this.color=O.color),O.colorDistributionType&&(this.colorsDistributionType=O.colorDistributionType),O.colorsSampling&&(this.colorsSampling=O.colorsSampling),O.colorMode&&(this.colorMode=O.colorMode),O.useColors&&(this.useColors=O.useColors),O.visibility&&(this.visibility=O.visibility),O.useDash&&(this.useDash=O.useDash),O.dashCount&&(this.dashCount=O.dashCount),O.dashRatio&&(this.dashRatio=O.dashRatio),O.dashOffset&&(this.dashOffset=O.dashOffset),O.width&&(this.width=O.width),O.sizeAttenuation&&(this.sizeAttenuation=O.sizeAttenuation),O.resolution&&(this.resolution=O.resolution),O.rC?this.colorsTexture=DC.CreateColorsTexture(`${this.name}-colors-texture`,O.rC,this.colorsSampling,this.dC()):this.colorsTexture=DC.PrepareEmptyColorsTexture(U),this._cameraFacing=O.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var hC,cC,NC;wC.ForceGLSL=!1,function(C){C[C.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",C[C.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(hC||(hC={})),function(C){C[C.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",C[C.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",C[C.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(cC||(cC={})),function(C){C[C.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",C[C.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",C[C.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",C[C.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",C[C.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(NC||(NC={}));class gC extends fC.b{constructor(C,U,K){super(C,U,null,null,!1,!1),this.name=C,this._options=K,this._lazy=!1,this._updatable=!1,this._engine=U.getEngine(),this._lazy=K.lazy??!1,this._updatable=K.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=K.colorPointers??[],this._widths=K.widths??new Array(K.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(C){let U=0;for(const m of this._points)U+=m.length;const K=U/3*2-this._widths.length;for(let m=0;m<K;m++)this._widths.push(C)}updateLazy(){var C,U;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(C=this._options.ribbonOptions)||void 0===C?void 0:C.smoothShading),!this.GC&&this.refreshBoundingInfo(),null===(U=this.greasedLineMaterial)||void 0===U||U.updateLazy()}addPoints(C,U){for(const K of C)this._points.push(K);this._lazy||this.setPoints(this._points,U)}dispose(C){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(C,U)}isLazy(){return this._lazy}get iC(){return this._uvs}set iC(C){this._uvs=C instanceof Float32Array?C:new Float32Array(C),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(C){this.material instanceof wC&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===C||void 0===C?void 0:C.length)>0),this._offsets=C,this._offsetsBuffer?this._offsetsBuffer.update(C):this._createOffsetsBuffer(C)}get widths(){return this._widths}set widths(C){this._widths=C,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(C)}get colorPointers(){return this._colorPointers}set colorPointers(C){this._colorPointers=C,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(C)}get greasedLineMaterial(){var C,U;if(this.material&&this.material instanceof wC)return this.material;const K=null===(C=this.material)||void 0===C||null===(U=C.pluginManager)||void 0===U?void 0:U.getPlugin(GC.GREASED_LINE_MATERIAL_NAME);return K||void 0}get points(){const C=[];return oC.b.DeepCopy(this._points,C),C}setPoints(C,U){this._points=DC.ConvertPoints(C,(null===U||void 0===U?void 0:U.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==U&&void 0!==U&&U.colorPointers||this._updateColorPointers(),this._setPoints(this._points,U)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,iC:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(C){super.serialize(C),C.type=this.getClassName(),C.lineOptions=this._createLineOptions()}_createVertexBuffers(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new JC.e;return U.yC=this._vertexPositions,U.indices=this._indices,U.iC=this._uvs,C&&(U.aC=[],JC.e.ComputeNormals(this._vertexPositions,this._indices,U.aC)),U.lC(this,this._options.updatable),U}_createOffsetsBuffer(C){const U=this._scene.getEngine(),K=new j.b(U,C,this._updatable,3);this.setVerticesBuffer(K.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=K}}class MC{constructor(C,U){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=C,this.wasAddedByNoopNode=U}getIndicesAccessor(C,U,K,m,O){var X,A,e,t;return null===(X=this._indicesAccessorMap.get(C))||void 0===X||null===(A=X.get(U))||void 0===A||null===(e=A.get(K))||void 0===e||null===(t=e.get(m))||void 0===t?void 0:t.get(O)}setIndicesAccessor(C,U,K,m,O,X){let A=this._indicesAccessorMap.get(C);A||(A=new Map,this._indicesAccessorMap.set(C,A));let e=A.get(U);e||(e=new Map,A.set(U,e));let t=e.get(K);t||(t=new Map,e.set(K,t));let z=t.get(m);z||(z=new Map,t.set(m,z)),z.set(O,X)}pushExportedNode(C){this._exportedNodes.has(C)||this._exportedNodes.add(C)}getNodesSet(){return this._exportedNodes}getVertexBufferView(C){return this._vertexBufferViewMap.get(C)}setVertexBufferView(C,U){this._vertexBufferViewMap.set(C,U)}setRemappedBufferView(C,U,K){this._remappedBufferView.set(C,new Map),this._remappedBufferView.get(C).set(U,K)}getRemappedBufferView(C,U){var K;return null===(K=this._remappedBufferView.get(C))||void 0===K?void 0:K.get(U)}getVertexAccessor(C,U,K){var m,O;return null===(m=this._vertexAccessorMap.get(C))||void 0===m||null===(O=m.get(U))||void 0===O?void 0:O.get(K)}setVertexAccessor(C,U,K,m){let O=this._vertexAccessorMap.get(C);O||(O=new Map,this._vertexAccessorMap.set(C,O));let X=O.get(U);X||(X=new Map,O.set(U,X)),X.set(K,m)}hasVertexColorAlpha(C){return this._vertexMapColorAlpha.get(C)||!1}setHasVertexColorAlpha(C,U){return this._vertexMapColorAlpha.set(C,U)}getMesh(C){return this._meshMap.get(C)}setMesh(C,U){this._meshMap.set(C,U)}bindMorphDataToMesh(C,U){const K=this._meshMorphTargetMap.get(C)||[];this._meshMorphTargetMap.set(C,K),-1===K.indexOf(U)&&K.push(U)}getMorphTargetsFromMesh(C){return this._meshMorphTargetMap.get(C)}}class LC{_ApplyExtension(C,U,K,m){if(K>=U.length)return Promise.resolve(C);const O=m(U[K],C);return O?O.then((async C=>C?await this._ApplyExtension(C,U,K+1,m):null)):this._ApplyExtension(C,U,K+1,m)}_ApplyExtensions(C,U){const K=[];for(const m of LC._ExtensionNames)K.push(this._extensions[m]);return this._ApplyExtension(C,K,0,U)}_extensionsPreExportTextureAsync(C,U,K){return this._ApplyExtensions(U,((U,m)=>U.preExportTextureAsync&&U.preExportTextureAsync(C,m,K)))}_extensionsPostExportNodeAsync(C,U,K,m,O){return this._ApplyExtensions(U,((U,X)=>U.postExportNodeAsync&&U.postExportNodeAsync(C,X,K,m,O,this._bufferManager)))}_extensionsPostExportMaterialAsync(C,U,K){return this._ApplyExtensions(U,((U,m)=>U.postExportMaterialAsync&&U.postExportMaterialAsync(C,m,K)))}_extensionsPostExportMaterialAdditionalTextures(C,U,K){const m=[];for(const O of LC._ExtensionNames){const X=this._extensions[O];X.postExportMaterialAdditionalTextures&&m.push(...X.postExportMaterialAdditionalTextures(C,U,K))}return m}_extensionsPostExportTextures(C,U,K){for(const m of LC._ExtensionNames){const O=this._extensions[m];O.postExportTexture&&O.postExportTexture(C,U,K)}}_extensionsPostExportMeshPrimitive(C){for(const U of LC._ExtensionNames){const K=this._extensions[U];K.postExportMeshPrimitive&&K.postExportMeshPrimitive(C,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const C of LC._ExtensionNames){const U=this._extensions[C];U.preGenerateBinaryAsync&&await U.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(C){for(const U of LC._ExtensionNames){const K=this._extensions[U];K.enabled&&C(K)}}_extensionsOnExporting(){this._forEachExtensions((C=>{var U,K,m;C.wasUsed&&((U=this._glTF).extensionsUsed||(U.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(C.name)&&this._glTF.extensionsUsed.push(C.name),C.required&&((K=this._glTF).extensionsRequired||(K.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(C.name)&&this._glTF.extensionsRequired.push(C.name)),(m=this._glTF).extensions||(m.extensions={}),C.onExporting&&C.onExporting())}))}_loadExtensions(){for(const C of LC._ExtensionNames){const U=LC._ExtensionFactories[C](this);this._extensions[C]=U}}constructor(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:v.c.LastCreatedScene,U=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${b.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new k(this),this._extensions={},this._bufferManager=new jC,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!C)throw new Error("No scene available to export");this._babylonScene=C,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:C=>{var U;return null===C||void 0===C||null===(U=C.Ce)||void 0===U?void 0:U.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...U},this._loadExtensions()}dispose(){for(const C in this._extensions){this._extensions[C].dispose()}}get options(){return this._options}static RegisterExtension(C,U){LC.UnregisterExtension(C)&&O.Tools.Warn(`Extension with the name ${C} already exists`),LC._ExtensionFactories[C]=U,LC._ExtensionNames.push(C)}static UnregisterExtension(C){if(!LC._ExtensionFactories[C])return!1;delete LC._ExtensionFactories[C];const U=LC._ExtensionNames.indexOf(C);return-1!==U&&LC._ExtensionNames.splice(U,1),!0}_generateJSON(C,U,K){const m={byteLength:C};return m.byteLength&&(this._glTF.buffers=[m]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.QU=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(m.uri=U+".bin"),K?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(C){const U=await this._generateBinaryAsync();this._extensionsOnExporting();const K=this._generateJSON(U.byteLength,C,!0),m=new Blob([U],{type:"application/octet-stream"}),O=C+".gltf",X=C+".bin",A=new z;if(A.files[O]=K,A.files[X]=m,this._imageData)for(const e in this._imageData)A.files[e]=new Blob([this._imageData[e].data],{type:this._imageData[e].mimeType});return A}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(C){const U=C%4;return 0===U?U:4-U}async generateGLBAsync(C){this._shouldUseGlb=!0;const U=await this._generateBinaryAsync();this._extensionsOnExporting();const K=this._generateJSON(U.byteLength),m=C+".glb";let O,X=K.length;if("undefined"!==typeof TextEncoder){O=(new TextEncoder).encode(K),X=O.length}const A=this._getPadding(X),e=this._getPadding(U.byteLength),t=28+X+A+U.byteLength+e,j=new tC(t);if(j.writeUInt32(1179937895),j.writeUInt32(2),j.writeUInt32(t),j.writeUInt32(X+A),j.writeUInt32(1313821514),O)j.writeTypedArray(O);else{const C="_".charCodeAt(0);for(let U=0;U<X;++U){const m=K.charCodeAt(U);m!=K.codePointAt(U)?j.writeUInt8(C):j.writeUInt8(m)}}for(let z=0;z<A;++z)j.writeUInt8(32);j.writeUInt32(U.byteLength+e),j.writeUInt32(5130562),j.writeTypedArray(U);for(let z=0;z<e;++z)j.writeUInt8(0);const p=new z;return p.files[m]=new Blob([j.getOutputData()],{type:"application/octet-stream"}),p}_setNodeTransformation(C,U,K){if(U.getPivotPoint().equalsWithEpsilon(g,N.d)||O.Tools.Warn("Pivot points are not supported in the glTF serializer"),!U.position.equalsWithEpsilon(g,N.d)){const O=m.TmpVectors.bU[0].m(U.position);K&&R(O),C.translation=O.Oe()}U.ue.equalsWithEpsilon(L,N.d)||(C.scale=U.ue.Oe());const X=U.rotationQuaternion||m.Quaternion.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);X.equalsWithEpsilon(M,N.d)||(K&&q(X),C.rotation=X.normalize().Oe())}_setCameraTransformation(C,U,K){if(!U.position.equalsWithEpsilon(g,N.d)){const O=m.TmpVectors.bU[0].m(U.position);K&&R(O),C.translation=O.Oe()}const O=U.rotationQuaternion||m.Quaternion.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);K&&q(O),this._babylonScene.useRightHandedSystem||I(O),O.equalsWithEpsilon(M,N.d)||(C.rotation=O.Oe())}_listAvailableCameras(){for(const C of this._babylonScene.cameras){const U={type:C.mode===EC.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(C.name&&(U.name=C.name),"perspective"===U.type)U.perspective={aspectRatio:C.getEngine().getAspectRatio(C),yfov:C.fovMode===EC.b.FOVMODE_VERTICAL_FIXED?C.fov:C.fov*C.getEngine().getAspectRatio(C),znear:C.Ae,zfar:C.maxZ};else if("orthographic"===U.type){const K=C.orthoLeft&&C.orthoRight?.5*(C.orthoRight-C.orthoLeft):.5*C.getEngine().getRenderWidth(),m=C.orthoBottom&&C.orthoTop?.5*(C.orthoTop-C.orthoBottom):.5*C.getEngine().getRenderHeight();U.orthographic={xmag:K,ymag:m,znear:C.Ae,zfar:C.maxZ}}this._camerasMap.set(C,U)}}_exportAndAssignCameras(){const C=Array.from(this._camerasMap.values());for(const U of C){const C=this._nodesCameraMap.get(U);if(void 0!==C){this._cameras.push(U);for(const U of C)U.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const C of this._babylonScene.skeletons){if(C.bones.length<=0)continue;const U={joints:[]};this._skinMap.set(C,U)}}_exportAndAssignSkeletons(){for(const C of this._babylonScene.skeletons){if(C.bones.length<=0)continue;const U=this._skinMap.get(C);if(void 0==U)continue;const K={},m=[];let X=-1;for(let O=0;O<C.bones.length;++O){const U=C.bones[O],m=U.getIndex()??O;-1!==m&&(K[m]=U,m>X&&(X=m))}for(let C=0;C<=X;++C){const X=K[C];m.push(X.getAbsoluteInverseBindMatrix());const A=X.getTransformNode();if(null!==A){const C=this._nodeMap.get(A);A&&null!==C&&void 0!==C?U.joints.push(C):O.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else O.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const A=this._nodesSkinMap.get(U);if(U.joints.length>0&&void 0!==A){const C=64*m.length,K=new Float32Array(C/4);m.forEach(((C,U)=>{K.set(C.m,16*U)}));const O=this._bufferManager.createBufferView(K);this._accessors.push(this._bufferManager.createAccessor(O,"MAT4",5126,m.length)),U.inverseBindMatrices=this._accessors.length-1,this._skins.push(U);for(const U of A)U.skin=this._skins.length-1}}}async _exportSceneAsync(){const C={nodes:[]};if(this._babylonScene.metadata){const U=this._options.metadataSelector(this._babylonScene.metadata);U&&(C.extras=U)}const U=new Array,K=new Array,m=new Array;for(const e of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&AC(e,this._babylonScene.useRightHandedSystem)?m.push(...e.getChildren()):this._babylonScene.useRightHandedSystem?U.push(e):K.push(e);this._listAvailableCameras(),this._listAvailableSkeletons();const O=new MC(!0,!1);C.nodes.push(...await this._exportNodesAsync(K,O));const X=new MC(!1,!1);C.nodes.push(...await this._exportNodesAsync(U,X));const A=new MC(!1,!0);C.nodes.push(...await this._exportNodesAsync(m,A)),C.nodes.length&&this._scenes.push(C),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&ZC._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,O.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(C){let U=this._shouldExportNodeMap.get(C);return void 0===U&&(U=this._options.shouldExportNode(C),this._shouldExportNodeMap.set(C,U)),U}async _exportNodesAsync(C,U){const K=new Array;this._exportBuffers(C,U);for(const m of C)await this._exportNodeAsync(m,K,U);return K}_collectBuffers(C,U,K,m,O){if(this._shouldExportNode(C)&&C instanceof E.d&&C.ze){const X=C.ze.getVertexBuffers();if(X)for(const m in X){if(!n(m))continue;const A=X[m];O.setHasVertexColorAlpha(A,C.hasVertexAlpha);const e=A._buffer,t=U.get(e)||[];U.set(e,t),-1===t.indexOf(A)&&t.push(A);const z=K.get(A)||[];K.set(A,z),-1===z.indexOf(C)&&z.push(C)}const A=C.morphTargetManager;if(A)for(let U=0;U<A.numTargets;U++){const K=A.getTarget(U),O=m.get(K)||[];m.set(K,O),-1===O.indexOf(C)&&O.push(C)}}for(const X of C.getChildren())this._collectBuffers(X,U,K,m,O)}_exportBuffers(C,U){const K=new Map,m=new Map,O=new Map;for(const e of C)this._collectBuffers(e,K,m,O,U);const X=Array.from(K.keys());for(const e of X){const C=e.getData();if(!C)throw new Error("Buffer data is not available");const O=K.get(e);if(!O)continue;const X=O[0].byteStride;if(O.some((C=>C.byteStride!==X)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const A=KC(C).slice();for(const U of O){const C=m.get(U),{byteOffset:K,byteStride:O,componentCount:X,type:e,count:t,normalized:z,kind:p}=W(U,C);switch(p){case j.d.NormalKind:case j.d.TangentKind:(0,w.h)(A,K,O,X,e,t,z,(C=>{const U=Math.sqrt(C[0]*C[0]+C[1]*C[1]+C[2]*C[2]);if(U>0){const K=1/U;C[0]*=K,C[1]*=K,C[2]*=K}}));break;case j.d.ColorKind:{const U=C.filter((C=>C.material instanceof vC.VU||null==C.material)).length;if(0==U)break;if(U!=C.length){h.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}e==j.d.UNSIGNED_BYTE&&h.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const m=new Q.fU,p=new Q.ve,E=this._babylonScene.getEngine().useExactSrgbConversions;(0,w.h)(A,K,O,X,e,t,z,(C=>{3===C.length?(m.uK(C,0),m.toLinearSpaceToRef(m,E),m.toArray(C,0)):(p.uK(C,0),p.toLinearSpaceToRef(p,E),p.toArray(C,0))}))}}}if(U.convertToRightHanded){for(const C of O){const U=m.get(C),{byteOffset:K,byteStride:O,componentCount:X,type:e,count:t,normalized:z,kind:p}=W(C,U);switch(p){case j.d.PositionKind:case j.d.NormalKind:case j.d.TangentKind:(0,w.h)(A,K,O,X,e,t,z,(C=>{C[0]=-C[0]}))}}U.convertedToRightHandedBuffers.set(e,A)}const t=this._bufferManager.createBufferView(A,X);U.setVertexBufferView(e,t);const z=new Map;for(const U of O){const C=m.get(U),{kind:K,totalVertices:O}=W(U,C);switch(K){case j.d.MatricesIndicesKind:case j.d.MatricesIndicesExtraKind:if(U.type==j.d.FLOAT){const C=U.getFloatData(O);null!==C&&z.set(U,C)}}}0!==z.size&&h.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const p=Array.from(z.keys());for(const K of p){const C=z.get(K);if(!C)continue;const m=C.some((C=>C>=256)),O=new(m?Uint16Array:Uint8Array)(C.length);for(let U=0;U<C.length;U++)O[U]=C[U];const X=this._bufferManager.createBufferView(O,4*(m?2:1));U.setRemappedBufferView(e,K,X)}}const A=Array.from(O.keys());for(const e of A){const C=O.get(e);if(!C)continue;const K=PC(e,C[0],this._bufferManager,this._bufferViews,this._accessors,U.convertToRightHanded);for(const m of C)U.bindMorphDataToMesh(m,K)}}async _exportNodeAsync(C,U,K){let m=this._nodeMap.get(C);if(void 0!==m)return void(U.includes(m)||U.push(m));const O=await this._createNodeAsync(C,K);if(O){m=this._nodes.length,this._nodes.push(O),this._nodeMap.set(C,m),K.pushExportedNode(C),U.push(m);const X={name:"runtime animations",channels:[],samplers:[]},A=[];this._babylonScene.animationGroups.length||(ZC._CreateMorphTargetAnimationFromMorphTargetAnimations(C,X,A,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,K.convertToRightHanded,this._options.shouldExportAnimation),C.animations.length&&ZC._CreateNodeAnimationFromNodeAnimations(C,X,A,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,K.convertToRightHanded,this._options.shouldExportAnimation)),X.channels.length&&X.samplers.length&&this._animations.push(X),A.forEach((C=>{C.channels.length&&C.samplers.length&&this._animations.push(C)}))}const X=O?[]:U;for(const A of C.getChildren())await this._exportNodeAsync(A,X,K);O&&X.length&&(O.children=X)}async _createNodeAsync(C,U){if(!this._shouldExportNode(C))return null;const K={};if(C.name&&(K.name=C.name),C.metadata){const U=this._options.metadataSelector(C.metadata);U&&(K.extras=U)}if(C instanceof p.b&&(this._setNodeTransformation(K,C,U.convertToRightHanded),C instanceof E.d)){const O=C instanceof u.d?C.sourceMesh:C;if(O.me&&O.me.length>0&&(K.mesh=await this._exportMeshAsync(O,U)),C.skeleton){const U=this._skinMap.get(C.skeleton);var m;if(void 0!==U)void 0===this._nodesSkinMap.get(U)&&this._nodesSkinMap.set(U,[]),null===(m=this._nodesSkinMap.get(U))||void 0===m||m.push(K)}}if(C instanceof c.d){const m=this._camerasMap.get(C);if(m){var O;void 0===this._nodesCameraMap.get(m)&&this._nodesCameraMap.set(m,[]),this._setCameraTransformation(K,C,U.convertToRightHanded);const A=C.parent;if(null!==A&&UC(C,A)){const C=this._nodeMap.get(A);if(void 0!==C){var X;const U=this._nodes[C];return CC(K,U),null===(X=this._nodesCameraMap.get(m))||void 0===X||X.push(U),null}}null===(O=this._nodesCameraMap.get(m))||void 0===O||O.push(K)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",K,C,this._nodeMap,U.convertToRightHanded)?K:(h.d.Warn(`Not exporting node ${C.name}`),null)}_exportIndices(C,U,K,m,O,A,e,t,z){let j=C;z.mode=S(A);const p=e!==X.e.CounterClockWiseSideOrientation,E=!t.wasAddedByNoopNode&&p,u=function(C){switch(C){case X.e.TriangleFillMode:case X.e.TriangleStripDrawMode:case X.e.TriangleFanDrawMode:return!0}return!1}(A)&&E;if(u){if(A===X.e.TriangleStripDrawMode||A===X.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");z.mode=S(A);const e=U?new Uint32Array(m):new Uint16Array(m);if(C)for(let U=0;U+2<m;U+=3)e[U]=C[K+U]+O,e[U+1]=C[K+U+2]+O,e[U+2]=C[K+U+1]+O;else for(let C=0;C+2<m;C+=3)e[C]=C,e[C+1]=C+2,e[C+2]=C+1;j=e}else if(C&&0!==O){const X=U?new Uint32Array(m):new Uint16Array(m);for(let U=0;U<m;U++)X[U]=C[K+U]+O;j=X}if(j){let X=t.getIndicesAccessor(C,K,m,O,u);if(void 0===X){const A=function(C,U,K,m){if(C instanceof Uint16Array||C instanceof Uint32Array)return C;if(C instanceof Int32Array)return new Uint32Array(C.buffer,C.byteOffset,C.length);const O=C.slice(U,U+K);return m?new Uint32Array(O):new Uint16Array(O)}(j,0,m,U),e=this._bufferManager.createBufferView(A),z=U?5125:5123;this._accessors.push(this._bufferManager.createAccessor(e,"SCALAR",z,m,0)),X=this._accessors.length-1,t.setIndicesAccessor(C,K,m,O,u,X)}z.indices=X}}_exportVertexBuffer(C,U,K,m,O,X){const A=C.getKind();if(!n(A))return;if(A.startsWith("uv")&&!this._options.exportUnusedUVs&&(!U||!this._materialNeedsUVsSet.has(U)))return;let e=O.getVertexAccessor(C,K,m);if(void 0===e){const U=O.convertedToRightHandedBuffers.get(C._buffer)||C._buffer.getData(),X=A===j.d.PositionKind?function(C,U,K,m){const{byteOffset:O,byteStride:X,type:A,normalized:e}=U,t=U.getSize(),z=new Array(t).fill(1/0),j=new Array(t).fill(-1/0);return(0,w.h)(C,O+K*X,X,t,A,m*t,e,(C=>{for(let U=0;U<t;U++)z[U]=Math.min(z[U],C[U]),j[U]=Math.max(j[U],C[U])})),{min:z,max:j}}(U,C,K,m):void 0,t=(A===j.d.MatricesIndicesKind||A===j.d.MatricesIndicesExtraKind)&&C.type===j.d.FLOAT,z=t?j.d.UNSIGNED_BYTE:C.type,p=t?void 0:C.normalized,E=t?O.getRemappedBufferView(C._buffer,C):O.getVertexBufferView(C._buffer),u=C.byteOffset+K*C.byteStride;this._accessors.push(this._bufferManager.createAccessor(E,function(C,U){if(C==j.d.ColorKind)return U?"VEC4":"VEC3";switch(C){case j.d.PositionKind:case j.d.NormalKind:return"VEC3";case j.d.TangentKind:case j.d.MatricesIndicesKind:case j.d.MatricesIndicesExtraKind:case j.d.MatricesWeightsKind:case j.d.MatricesWeightsExtraKind:return"VEC4";case j.d.UVKind:case j.d.UV2Kind:case j.d.UV3Kind:case j.d.UV4Kind:case j.d.UV5Kind:case j.d.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${C}`)}(A,O.hasVertexColorAlpha(C)),z,m,u,X,p)),e=this._accessors.length-1,O.setVertexAccessor(C,K,m,e)}X.attributes[function(C){switch(C){case j.d.PositionKind:return"POSITION";case j.d.NormalKind:return"NORMAL";case j.d.TangentKind:return"TANGENT";case j.d.ColorKind:return"COLOR_0";case j.d.UVKind:return"TEXCOORD_0";case j.d.UV2Kind:return"TEXCOORD_1";case j.d.UV3Kind:return"TEXCOORD_2";case j.d.UV4Kind:return"TEXCOORD_3";case j.d.UV5Kind:return"TEXCOORD_4";case j.d.UV6Kind:return"TEXCOORD_5";case j.d.MatricesIndicesKind:return"JOINTS_0";case j.d.MatricesIndicesExtraKind:return"JOINTS_1";case j.d.MatricesWeightsKind:return"WEIGHTS_0";case j.d.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${C}`)}(A)]=e}async _exportMaterialAsync(C,U,K,m){let O=this._materialMap.get(C);if(void 0===O){const m=U&&Object.keys(U).some((C=>C.startsWith("uv")));if((C=C instanceof uC.c?C.Qe[K.materialIndex]:C)instanceof bC.e)O=await this._materialExporter.exportPBRMaterialAsync(C,"image/png",m);else{if(!(C instanceof vC.VU))return void h.d.Warn(`Unsupported material '${C.name}' with type ${C.getClassName()}`);O=await this._materialExporter.exportStandardMaterialAsync(C,"image/png",m)}this._materialMap.set(C,O)}m.material=O}async _exportMeshAsync(C,U){var K;let m=U.getMesh(C);if(void 0!==m)return m;const O={primitives:[]};m=this._meshes.length,this._meshes.push(O),U.setMesh(C,m);const A=C.isUnIndexed?null:C.je(),e=null===(K=C.ze)||void 0===K?void 0:K.getVertexBuffers(),t=U.getMorphTargetsFromMesh(C),z=C instanceof HC.e,j=C instanceof gC,p=C.me;if(e&&p&&p.length>0)for(const b of p){const K={attributes:{}},m=b.kC()||this._babylonScene.defaultMaterial;if(j){var E,u;const U={name:m.name},O=C,X=Q.fU.White(),A=(null===(E=O.material)||void 0===E?void 0:E.alpha)??1,e=(null===(u=O.greasedLineMaterial)||void 0===u?void 0:u.color)??X;(!e.equalsWithEpsilon(X,N.d)||A<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...e.Oe(),A]}),this._materials.push(U),K.material=this._materials.length-1}else if(z){const U={name:m.name},O=C;(!O.color.equalsWithEpsilon(Q.fU.White(),N.d)||O.alpha<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...O.color.Oe(),O.alpha]}),this._materials.push(U),K.material=this._materials.length-1}else await this._exportMaterialAsync(m,e,b,K);const p=z||j?X.e.LineListDrawMode:C.overrideRenderingFillMode??m.fillMode,v=m._getEffectiveOrientation(C);this._exportIndices(A,A?(0,w.c)(A,b.indexCount,b.indexStart,b.verticesStart):b.verticesCount>65535,A?b.indexStart:b.verticesStart,A?b.indexCount:b.verticesCount,-b.verticesStart,p,v,U,K);for(const C of Object.values(e))this._exportVertexBuffer(C,m,b.verticesStart,b.verticesCount,U,K);if(t){K.targets=[];for(const C of t)K.targets.push(C.attributes)}O.primitives.push(K),this._extensionsPostExportMeshPrimitive(K)}if(t){O.weights=[],O.extras||(O.extras={}),O.extras.targetNames=[];for(const C of t)O.weights.push(C.influence),O.extras.targetNames.push(C.name)}return m}}LC._ExtensionNames=new Array,LC._ExtensionFactories={};class YC{static async GLTFAsync(C,U,K){K&&K.exportWithoutWaitingForScene||await C.whenReadyAsync();const m=new LC(C,K),O=await m.generateGLTFAsync(U.replace(/\.[^/.]+$/,""));return m.dispose(),O}static async GLBAsync(C,U,K){K&&K.exportWithoutWaitingForScene||await C.whenReadyAsync();const m=new LC(C,K),O=await m.generateGLBAsync(U.replace(/\.[^/.]+$/,""));return m.dispose(),O}}K(12393);const WC="EXT_mesh_gpu_instancing";class xC{constructor(C){this.name=WC,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(C,U,K,O,X,A){return await new Promise((C=>{if(U&&K instanceof fC.b&&K.hasThinInstances&&this._exporter){this._wasUsed=!0;const C=m.bU.Zero(),O=m.Quaternion.Identity(),e=m.bU.One(),t=K.thinInstanceGetWorldMatrices(),z=m.TmpVectors.bU[2],j=m.TmpVectors.Quaternion[1],p=m.TmpVectors.bU[3];let E=!1,u=!1,b=!1;const v=new Float32Array(3*K.Ve),Q=new Float32Array(4*K.Ve),V=new Float32Array(3*K.Ve);let f=0;for(const U of t)U.decompose(p,j,z),X&&(R(z),q(j)),v.set(z.Oe(),3*f),Q.set(j.normalize().Oe(),4*f),V.set(p.Oe(),3*f),E=E||!z.equalsWithEpsilon(C),u=u||!j.equalsWithEpsilon(O),b=b||!p.equalsWithEpsilon(e),f++;const F={attributes:{}};E&&(F.attributes.TRANSLATION=this._buildAccessor(v,"VEC3",K.Ve,A)),u&&(F.attributes.ROTATION=this._buildAccessor(Q,"VEC4",K.Ve,A)),b&&(F.attributes.SCALE=this._buildAccessor(V,"VEC3",K.Ve,A)),U.extensions=U.extensions||{},U.extensions[WC]=F}C(U)}))}_buildAccessor(C,U,K,m){const O=m.createBufferView(C),X=m.createAccessor(O,U,5126,K);return this._exporter._accessors.push(X),this._exporter._accessors.length-1}}LC.RegisterExtension(WC,(C=>new xC(C)));var nC=K(12396),SC=K(12400),sC=K(12409),RC=K(12415);function qC(C){return C===sC.d.PositionKind?"POSITION":C===sC.d.NormalKind?"NORMAL":C===sC.d.ColorKind?"COLOR":C.startsWith(sC.d.UVKind)?"TEX_COORD":"GENERIC"}const IC={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class CU extends nC.b{static get DefaultAvailable(){return(0,nC.e)(CU.DefaultConfiguration)}static get Default(){return CU._Default??(CU._Default=new CU),CU._Default}static ResetDefault(C){CU._Default&&(C||CU._Default.dispose(),CU._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(C,U){return{module:await(U||DracoEncoderModule)({wasmBinary:C})}}_getWorkerContent(){return`${SC.g}(${SC.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:CU.DefaultConfiguration)}async _encodeAsync(C,U,K){const m=K?(0,RC.b)(IC,K):IC;if(this._workerPoolPromise){const K=await this._workerPoolPromise;return await new Promise(((O,X)=>{K.push(((K,A)=>{const e=C=>{K.removeEventListener("error",e),K.removeEventListener("message",t),X(C),A()},t=C=>{"encodeMeshDone"===C.data.id&&(K.removeEventListener("error",e),K.removeEventListener("message",t),O(C.data.encodedMeshData),A())};K.addEventListener("error",e),K.addEventListener("message",t);const z=[];for(const U of C)z.push(U.data.buffer);U&&z.push(U.buffer),K.postMessage({id:"encodeMesh",attributes:C,indices:U,options:m},z)}))}))}if(this._modulePromise){const K=await this._modulePromise;return(0,SC.g)(K.module,C,U,m)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(C,U){if(0==C.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");C instanceof fC.b&&C.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===U||void 0===U?void 0:U.method)&&(h.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),U.method="MESH_SEQUENTIAL_ENCODING");const K=function(C){let U=C.je(void 0,!0);return!U||U instanceof Uint32Array||U instanceof Uint16Array||(U=((0,w.c)(U,U.length)?Uint32Array:Uint16Array).from(U)),U}(C),m=function(C,U){const K=[];for(const m of C.getVerticesDataKinds()){if(null!==U&&void 0!==U&&U.includes(m)){if(m===sC.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const O=C.getVertexBuffer(m),X=O.getSize(),A=(0,w.v)(O.getData(),X,O.type,O.byteOffset,O.byteStride,O.normalized,C.getTotalVertices(),!0);K.push({kind:m,dracoName:qC(m),size:X,data:A})}return K}(C,null===U||void 0===U?void 0:U.excludedAttributes);return await this._encodeAsync(m,K,U)}}CU.DefaultConfiguration={wasmUrl:`${O.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${O.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${O.Tools._DefaultCdnUrl}/draco_encoder.js`},CU._Default=null;const UU="KHR_draco_mesh_compression";class KU{get wasUsed(){return this._wasUsed}constructor(C){this.name=UU,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===C.options.meshCompressionMethod&&CU.DefaultAvailable}dispose(){}postExportMeshPrimitive(C,U,K){if(!this.enabled)return;if(4!==C.mode&&5!==C.mode)return void h.d.Warn("Cannot compress primitive with mode "+C.mode+".");const m=[],O=[];let X=null;if(void 0!==C.indices){const A=K[C.indices],e=U.getBufferView(A);X=U.getData(e).slice(),m.push(e),O.push(A)}const A=[];for(const[j,p]of Object.entries(C.attributes)){const C=K[p],X=U.getBufferView(C),t=x(C.type),z=(0,w.v)(U.getData(X),t,C.componentType,C.byteOffset||0,X.byteStride||(0,w.n)(C.componentType)*t,C.normalized||!1,C.count,!0);A.push({kind:j,dracoName:(e=j,"POSITION"===e?"POSITION":"NORMAL"===e?"NORMAL":e.startsWith("COLOR")?"COLOR":e.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:x(C.type),data:z}),m.push(X),O.push(C)}var e;const t={method:C.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},z=CU.Default._encodeAsync(A,X,t).then((K=>{if(!K)return void h.d.Error("Draco encoding failed for primitive.");const X={bufferView:-1,attributes:K.attributeIds},A=U.createBufferView(K.data);U.setBufferView(X,A);for(const C of m)this._bufferViewsUsed.add(C);for(const C of O)this._accessorsUsed.add(C);C.extensions||(C.extensions={}),C.extensions[UU]=X})).catch((C=>{h.d.Error("Draco encoding failed for primitive: "+C)}));this._encodePromises.push(z),this._wasUsed=!0}async preGenerateBinaryAsync(C){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((U=>{C.getPropertiesWithBufferView(U).every((C=>this._accessorsUsed.has(C)))&&C.removeBufferView(U)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}LC.RegisterExtension(UU,(C=>new KU(C)));var mU=K(12418);const OU="KHR_lights_punctual",XU={name:"",color:[1,1,1],fe:1,range:Number.MAX_VALUE},AU={innerConeAngle:0,outerConeAngle:Math.PI/4},eU=m.bU.Backward();class tU{constructor(C){this.name=OU,this.enabled=!0,this.required=!1,this._exporter=C}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[OU]=this._lights}async postExportNodeAsync(C,U,K,O,X){return await new Promise((A=>{if(!(K instanceof FC.e))return void A(U);const e=K.getTypeID()==FC.e.LIGHTTYPEID_POINTLIGHT?"point":K.getTypeID()==FC.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":K.getTypeID()==FC.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!e||!(K instanceof mU.d))return h.d.Warn(`${C}: Light ${K.name} is not supported in ${OU}`),void A(U);if(K.falloffType!==FC.e.FALLOFF_GLTF&&h.d.Warn(`${C}: Light falloff for ${K.name} does not match the ${OU} specification!`),!K.position.equalsToFloats(0,0,0)){const C=m.TmpVectors.bU[0].m(K.position);X&&R(C),U.translation=C.Oe()}if("point"!==e){const C=K.direction.normalizeToRef(m.TmpVectors.bU[0]);X&&R(C);const O=m.Quaternion.FromUnitVectorsToRef(eU,C,m.TmpVectors.Quaternion[0]);m.Quaternion.IsIdentity(O)||(U.rotation=O.Oe())}const t={type:e,name:K.name,color:K.Fe.Oe(),fe:K.fe,range:K.range};if(mC(t,XU),"spot"===e){const C=K;t.spot={innerConeAngle:C.innerAngle/2,outerConeAngle:C.angle/2},mC(t.spot,AU)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(t);const z={nA:this._lights.lights.length-1},j=K.parent;if(j&&UC(K,j)){const C=O.get(j);if(C){const K=this._exporter._nodes[C];return CC(U,K),K.extensions||(K.extensions={}),K.extensions[OU]=z,void A(null)}}U.extensions||(U.extensions={}),U.extensions[OU]=z,A(U)}))}}LC.RegisterExtension(OU,(C=>new tU(C)));var zU=K(12342);const jU="KHR_materials_anisotropy";class pU{constructor(C){this.name=jU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,U,K){const m=[];return K instanceof zU.c&&K.anisotropy.isEnabled&&!K.anisotropy.legacy?(K.anisotropy.texture&&m.push(K.anisotropy.texture),m):[]}postExportMaterialAsync(C,U,K){return new Promise((C=>{if(K instanceof zU.c){if(!K.anisotropy.isEnabled||K.anisotropy.legacy)return void C(U);this._wasUsed=!0,U.extensions=U.extensions||{};const m=this._exporter._materialExporter.getTextureInfo(K.anisotropy.texture),O={anisotropyStrength:K.anisotropy.fe,anisotropyRotation:K.anisotropy.angle,anisotropyTexture:m??void 0};null!==O.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(K),U.extensions[jU]=O}C(U)}))}}LC.RegisterExtension(jU,(C=>new pU(C)));const EU="KHR_materials_clearcoat";class uU{constructor(C){this.name=EU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,U,K){const m=[];return K instanceof zU.c&&K.clearCoat.isEnabled?(K.clearCoat.texture&&m.push(K.clearCoat.texture),!K.clearCoat.useRoughnessFromMainTexture&&K.clearCoat.textureRoughness&&m.push(K.clearCoat.textureRoughness),K.clearCoat.bumpTexture&&m.push(K.clearCoat.bumpTexture),m):[]}postExportMaterialAsync(C,U,K){return new Promise((C=>{if(K instanceof zU.c){if(!K.clearCoat.isEnabled)return void C(U);this._wasUsed=!0,U.extensions=U.extensions||{};const m=this._exporter._materialExporter.getTextureInfo(K.clearCoat.texture);let X;X=K.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(K.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(K.clearCoat.textureRoughness),K.clearCoat.isTintEnabled&&O.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${K.name}`),K.clearCoat.remapF0OnInterfaceChange&&O.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${K.name}`);const A=this._exporter._materialExporter.getTextureInfo(K.clearCoat.bumpTexture),e={clearcoatFactor:K.clearCoat.fe,clearcoatTexture:m??void 0,clearcoatRoughnessFactor:K.clearCoat.roughness,clearcoatRoughnessTexture:X??void 0,clearcoatNormalTexture:A??void 0};null===e.clearcoatTexture&&null===e.clearcoatRoughnessTexture&&null===e.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(K),U.extensions[EU]=e}C(U)}))}}LC.RegisterExtension(EU,(C=>new uU(C)));const bU="KHR_materials_diffuse_transmission";function vU(C,U){const K=U.subSurface;let m=null;return K.translucencyIntensityTexture?m=K.translucencyIntensityTexture:K.thicknessTexture&&K.useMaskFromThicknessTexture&&(m=K.thicknessTexture),m&&!K.useGltfStyleTextures?(h.d.Warn(`${C}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${U.name}`,1),null):m}class QU{constructor(C){this.name=bU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,U,K){const m=[];if(K instanceof bC.e&&this._isExtensionEnabled(K)){const U=vU(C,K);return U&&m.push(U),K.subSurface.translucencyColorTexture&&m.push(K.subSurface.translucencyColorTexture),m}return m}_isExtensionEnabled(C){if(C.unlit)return!1;const U=C.subSurface;return!!U.isTranslucencyEnabled&&(!C.unlit&&!U.useAlbedoToTintTranslucency&&U.useGltfStyleTextures&&1===U.volumeIndexOfRefraction&&0===U.minimumThickness&&0===U.maximumThickness)}postExportMaterialAsync(C,U,K){return new Promise((m=>{if(K instanceof bC.e&&this._isExtensionEnabled(K)){this._wasUsed=!0;const m=K.subSurface,O=vU(C,K),X=0==m.translucencyIntensity?void 0:m.translucencyIntensity,A=this._exporter._materialExporter.getTextureInfo(O)??void 0,e=!m.translucencyColor||m.translucencyColor.equalsFloats(1,1,1)?void 0:m.translucencyColor.Oe(),t=this._exporter._materialExporter.getTextureInfo(m.translucencyColorTexture)??void 0,z={diffuseTransmissionFactor:X,diffuseTransmissionTexture:A,diffuseTransmissionColorFactor:e,diffuseTransmissionColorTexture:t};(A||t)&&this._exporter._materialNeedsUVsSet.add(K),U.extensions=U.extensions||{},U.extensions[bU]=z}m(U)}))}}LC.RegisterExtension(bU,(C=>new QU(C)));const VU="KHR_materials_dispersion";class fU{constructor(){this.name=VU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(C){if(C.unlit)return!1;const U=C.subSurface;return!(!U.isRefractionEnabled&&!U.isDispersionEnabled)}postExportMaterialAsync(C,U,K){return new Promise((C=>{if(K instanceof bC.e&&this._isExtensionEnabled(K)){this._wasUsed=!0;const C={dispersion:K.subSurface.dispersion};U.extensions=U.extensions||{},U.extensions[VU]=C}C(U)}))}}LC.RegisterExtension(VU,(()=>new fU));const FU="KHR_materials_emissive_strength";class ZU{constructor(){this.name=FU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(C,U,K){return await new Promise((C=>{if(!(K instanceof bC.e))return C(U);const m=K.emissiveColor.Oe(),O=Math.max(...m);if(O>1){this._wasUsed=!0,U.extensions||(U.extensions={});const C={emissiveStrength:O},m=K.emissiveColor.scale(1/C.emissiveStrength);U.emissiveFactor=m.Oe(),U.extensions[FU]=C}return C(U)}))}}LC.RegisterExtension(FU,(C=>new ZU));const PU="KHR_materials_ior";class HU{constructor(){this.name=PU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(C){return!C.unlit&&(void 0!=C.indexOfRefraction&&1.5!=C.indexOfRefraction)}postExportMaterialAsync(C,U,K){return new Promise((C=>{if(K instanceof bC.e&&this._isExtensionEnabled(K)){this._wasUsed=!0;const C={ior:K.indexOfRefraction};U.extensions=U.extensions||{},U.extensions[PU]=C}C(U)}))}}LC.RegisterExtension(PU,(C=>new HU));const dU="KHR_materials_iridescence";class TU{constructor(C){this.name=dU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,U,K){const m=[];return K instanceof zU.c&&K.iridescence.isEnabled?(K.iridescence.texture&&m.push(K.iridescence.texture),K.iridescence.thicknessTexture&&K.iridescence.thicknessTexture!==K.iridescence.texture&&m.push(K.iridescence.thicknessTexture),m):[]}postExportMaterialAsync(C,U,K){return new Promise((C=>{if(K instanceof zU.c){if(!K.iridescence.isEnabled)return void C(U);this._wasUsed=!0,U.extensions=U.extensions||{};const m=this._exporter._materialExporter.getTextureInfo(K.iridescence.texture),O=this._exporter._materialExporter.getTextureInfo(K.iridescence.thicknessTexture),X={iridescenceFactor:K.iridescence.fe,iridescenceIor:K.iridescence.indexOfRefraction,iridescenceThicknessMinimum:K.iridescence.minimumThickness,iridescenceThicknessMaximum:K.iridescence.maximumThickness,iridescenceTexture:m??void 0,iridescenceThicknessTexture:O??void 0};null===X.iridescenceTexture&&null===X.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(K),U.extensions[dU]=X}C(U)}))}}LC.RegisterExtension(dU,(C=>new TU(C)));const yU="KHR_materials_sheen";class aU{constructor(C){this.name=yU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,U,K){return K instanceof bC.e&&K.sheen.isEnabled&&K.sheen.texture?[K.sheen.texture]:[]}async postExportMaterialAsync(C,U,K){return await new Promise((C=>{if(K instanceof bC.e){if(!K.sheen.isEnabled)return void C(U);this._wasUsed=!0,null==U.extensions&&(U.extensions={});const m={sheenColorFactor:K.sheen.color.Oe(),sheenRoughnessFactor:K.sheen.roughness??0};null===m.sheenColorTexture&&null===m.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(K),K.sheen.texture&&(m.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(K.sheen.texture)??void 0),K.sheen.textureRoughness&&!K.sheen.useRoughnessFromMainTexture?m.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(K.sheen.textureRoughness)??void 0:K.sheen.texture&&K.sheen.useRoughnessFromMainTexture&&(m.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(K.sheen.texture)??void 0),U.extensions[yU]=m}C(U)}))}}LC.RegisterExtension(yU,(C=>new aU(C)));const rU="KHR_materials_specular";class iU{constructor(C){this.name=rU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,U,K){const m=[];return K instanceof bC.e&&this._isExtensionEnabled(K)?(K.metallicReflectanceTexture&&m.push(K.metallicReflectanceTexture),K.reflectanceTexture&&m.push(K.reflectanceTexture),m):m}_isExtensionEnabled(C){return!C.unlit&&(void 0!=C.metallicF0Factor&&1!=C.metallicF0Factor||void 0!=C.metallicReflectanceColor&&!C.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(C))}_hasTexturesExtension(C){return null!=C.metallicReflectanceTexture||null!=C.reflectanceTexture}postExportMaterialAsync(C,U,K){return new Promise((C=>{if(K instanceof bC.e&&this._isExtensionEnabled(K)){this._wasUsed=!0,U.extensions=U.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(K.metallicReflectanceTexture)??void 0,m=this._exporter._materialExporter.getTextureInfo(K.reflectanceTexture)??void 0,O={specularFactor:1==K.metallicF0Factor?void 0:K.metallicF0Factor,specularTexture:C,specularColorFactor:K.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:K.metallicReflectanceColor.Oe(),specularColorTexture:m};this._hasTexturesExtension(K)&&this._exporter._materialNeedsUVsSet.add(K),U.extensions[rU]=O}C(U)}))}}LC.RegisterExtension(rU,(C=>new iU(C)));const DU="KHR_materials_transmission";class lU{constructor(C){this.name=DU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,U,K){const m=[];return K instanceof bC.e&&this._isExtensionEnabled(K)?(K.subSurface.thicknessTexture&&m.push(K.subSurface.thicknessTexture),m):m}_isExtensionEnabled(C){if(C.unlit)return!1;const U=C.subSurface;return U.isRefractionEnabled&&void 0!=U.refractionIntensity&&0!=U.refractionIntensity||this._hasTexturesExtension(C)}_hasTexturesExtension(C){return null!=C.subSurface.refractionIntensityTexture}async postExportMaterialAsync(C,U,K){if(K instanceof bC.e&&this._isExtensionEnabled(K)){this._wasUsed=!0;const m=K.subSurface,O={transmissionFactor:0===m.refractionIntensity?void 0:m.refractionIntensity};if(this._hasTexturesExtension(K)&&this._exporter._materialNeedsUVsSet.add(K),m.refractionIntensityTexture)if(m.useGltfStyleTextures){const C=await this._exporter._materialExporter.exportTextureAsync(m.refractionIntensityTexture,"image/png");C&&(O.transmissionTexture=C)}else h.d.Warn(`${C}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);U.extensions||(U.extensions={}),U.extensions[DU]=O}return U}}LC.RegisterExtension(DU,(C=>new lU(C)));const GU="KHR_materials_unlit";class JU{constructor(){this.name=GU,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(C,U,K){return new Promise((C=>{let m=!1;K instanceof bC.e?m=K.unlit:K instanceof vC.VU&&(m=K.disableLighting),m&&(this._wasUsed=!0,null==U.extensions&&(U.extensions={}),U.extensions[GU]={}),C(U)}))}}LC.RegisterExtension(GU,(()=>new JU));const oU="KHR_materials_volume";class BU{constructor(C){this.name=oU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,U,K){const m=[];return K instanceof bC.e&&this._isExtensionEnabled(K)?(K.subSurface.thicknessTexture&&m.push(K.subSurface.thicknessTexture),m):m}_isExtensionEnabled(C){if(C.unlit)return!1;const U=C.subSurface;return!(!U.isRefractionEnabled&&!U.isTranslucencyEnabled)&&(void 0!=U.maximumThickness&&0!=U.maximumThickness||void 0!=U.tintColorAtDistance&&U.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=U.tintColor&&U.tintColor!=Q.fU.White()||this._hasTexturesExtension(C))}_hasTexturesExtension(C){return null!=C.subSurface.thicknessTexture}postExportMaterialAsync(C,U,K){return new Promise((C=>{if(K instanceof bC.e&&this._isExtensionEnabled(K)){this._wasUsed=!0;const C=K.subSurface,m={thicknessFactor:0==C.maximumThickness?void 0:C.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(C.thicknessTexture)??void 0,attenuationDistance:C.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:C.tintColorAtDistance,attenuationColor:C.tintColor.equalsFloats(1,1,1)?void 0:C.tintColor.Oe()};this._hasTexturesExtension(K)&&this._exporter._materialNeedsUVsSet.add(K),U.extensions=U.extensions||{},U.extensions[oU]=m}C(U)}))}}LC.RegisterExtension(oU,(C=>new BU(C)));const kU="EXT_materials_diffuse_roughness";class wU{constructor(C){this.name=kU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=C}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(C,U,K){const m=[];return K instanceof zU.c&&K._baseDiffuseRoughness?(K._baseDiffuseRoughnessTexture&&m.push(K._baseDiffuseRoughnessTexture),m):[]}postExportMaterialAsync(C,U,K){return new Promise((C=>{if(K instanceof zU.c){if(!K._baseDiffuseRoughness)return void C(U);this._wasUsed=!0,U.extensions=U.extensions||{};const m=this._exporter._materialExporter.getTextureInfo(K._baseDiffuseRoughnessTexture),O={diffuseRoughnessFactor:K._baseDiffuseRoughness,diffuseRoughnessTexture:m??void 0};null!==O.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(K),U.extensions[kU]=O}C(U)}))}}LC.RegisterExtension(kU,(C=>new wU(C)));const hU="KHR_texture_transform";class cU{constructor(){this.name=hU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(C,U,K){if(K.dC()||O.Tools.Warn(`${C}: /*@__KEY__*/"scene" is not defined for Babylon texture ${K.name}!`),(0!==K.uAng||0!==K.vAng)&&(O.Tools.Warn(`${C}: Texture ${K.name} with rotation in the u or v axis is not supported in glTF.`),0!==K.uRotationCenter||0!==K.vRotationCenter))return;const m={};let X=!1;if(0===K.uOffset&&0===K.vOffset||(m.offset=[K.uOffset,K.vOffset],X=!0),1===K.uScale&&1===K.vScale||(m.scale=[K.uScale,K.vScale],X=!0),0!==K.wAng){if(0!==K.uRotationCenter||0!==K.vRotationCenter){if(K.homogeneousRotationInUVTransform&&K.uScale!==K.vScale)return void O.Tools.Warn(`${C}: Texture ${K.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${hU}.`);O.Tools.Warn(`${C}: Texture ${K.name} with non-origin rotation center will be exported using an adjusted offset with ${hU}.`),m.offset=function(C){const{uOffset:U,vOffset:K,uRotationCenter:m,vRotationCenter:O,uScale:X,vScale:A,wAng:e}=C,t=Math.cos(e),z=Math.sin(e),j=m*X,p=O*A;return[U+(j*(1-t)+p*z),K+(p*(1-t)-j*z)]}(K)}m.rotation=-K.wAng,X=!0}0!==K.coordinatesIndex&&(m.texCoord=K.coordinatesIndex,X=!0),X&&(this._wasUsed=!0,U.extensions||(U.extensions={}),U.extensions[hU]=m)}}LC.RegisterExtension(hU,(()=>new cU));class NU{static CreateSTL(C){let U=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",O=arguments.length>3&&void 0!==arguments[3]&&arguments[3],X=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],A=arguments.length>5&&void 0!==arguments[5]&&arguments[5],e=arguments.length>6&&void 0!==arguments[6]&&arguments[6],t=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const z=function(C,U,K){const O=[3*C[K],3*C[K+1],3*C[K+2]],X=[new m.bU(U[O[0]],U[O[0]+2],U[O[0]+1]),new m.bU(U[O[1]],U[O[1]+2],U[O[1]+1]),new m.bU(U[O[2]],U[O[2]+2],U[O[2]+1])],A=X[0].vU(X[1]),e=X[2].vU(X[1]);return{v:X,n:m.bU.Cross(e,A).normalize()}},p=function(C,U,K,m){return U=E(C,U,K.x,m),U=E(C,U,K.y,m),E(C,U,K.z,m)},E=function(C,U,K,m){return C.setFloat32(U,K,m),U+4},b=function(C){if(e){let U=C;C instanceof u.d&&(U=C.sourceMesh);const K=U.getVerticesData(j.d.PositionKind,!0,!0);if(!K)return[];const O=m.bU.Zero();let X;for(X=0;X<K.length;X+=3)m.bU.TransformCoordinatesFromFloatsToRef(K[X],K[X+1],K[X+2],C.te(!0),O).toArray(K,X);return K}return C.getVerticesData(j.d.PositionKind)||[]};e&&(A=!0);let v="",Q=0,V=0;if(O){for(let K=0;K<C.length;K++){const U=C[K].je();Q+=U?U.length/3:0}const U=new ArrayBuffer(84+50*Q);v=new DataView(U),V+=80,v.setUint32(V,Q,X),V+=4}else t||(v="solid stlmesh\r\n");for(let m=0;m<C.length;m++){const U=C[m];!O&&t&&(v+="solid "+U.name+"\r\n"),!A&&U instanceof fC.b&&U.bakeCurrentTransformIntoVertices();const K=b(U),e=U.je()||[];for(let C=0;C<e.length;C+=3){const U=z(e,K,C);O?(V=p(v,V,U.n,X),V=p(v,V,U.v[0],X),V=p(v,V,U.v[1],X),V=p(v,V,U.v[2],X),V+=2):(v+="\tfacet normal "+U.n.x+" "+U.n.y+" "+U.n.z+"\r\n",v+="\t\touter loop\r\n",v+="\t\t\tvertex "+U.v[0].x+" "+U.v[0].y+" "+U.v[0].z+"\r\n",v+="\t\t\tvertex "+U.v[1].x+" "+U.v[1].y+" "+U.v[1].z+"\r\n",v+="\t\t\tvertex "+U.v[2].x+" "+U.v[2].y+" "+U.v[2].z+"\r\n",v+="\t\tendloop\r\n",v+="\tendfacet\r\n")}!O&&t&&(v+="endsolid "+name+"\r\n")}if(O||t||(v+="endsolid stlmesh"),U){const C=document.createElement("a"),U=new Blob([v],{type:"application/octet-stream"});C.href=window.URL.createObjectURL(U),C.download=K+".stl",C.click()}return v}}function gU(C,U){let K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const m=[];for(let O=0;O<C.length/K;O++){const X=C[O*K],A=C[O*K+1],e=C[O*K+2];m.push(`(${X.toPrecision(U.precision)}, ${A.toPrecision(U.precision)}, ${e.toPrecision(U.precision)})`)}return m.join(", ")}function MU(C,U){const K=[];for(let m=0;m<C.length/2;m++){const O=C[2*m],X=C[2*m+1];K.push(`(${O.toPrecision(U.precision)}, ${(1-X).toPrecision(U.precision)})`)}return K.join(", ")}function LU(C,U){const K=C.getVerticesData(j.d.PositionKind),m=C.getVerticesData(j.d.NormalKind);if(K&&m)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(C){var U;const K=null!==(U=C.je())&&void 0!==U&&U.length?C.getTotalIndices():C.getTotalVertices();return Array(K/3).fill(3).join(", ")}(C)}]\n\t\tint[] faceVertexIndices = [${function(C){const U=C.je(),K=[];if(null!==U)for(let m=0;m<U.length;m++)K.push(U[m]);else{const U=C.getTotalVertices();for(let C=0;C<U;C++)K.push(C)}return K.join(", ")}(C)}]\n\t\tnormal3f[] normals = [${gU(m,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${gU(K,U)}]\n        ${function(C,U){let K="";for(let O=0;O<4;O++){const m=O>0?O:"",X=C.getVerticesData(j.d.UVKind+(m?m+1:""));X&&(K+=`\n\t\ttexCoord2f[] primvars:st${m} = [${MU(X,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const m=C.getVerticesData(j.d.ColorKind);return m&&(K+=`\n\tcolor3f[] primvars:displayColor = [${gU(m,U,m.length/C.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),K}(C,U)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function YU(C,U){return`\n        def "Geometry"\n        {\n        ${LU(C,U)}\n        }\n        `}function WU(C){let U='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return U+=C,fflate.strToU8(U)}function xU(C){const U=C.m;return`( ${nU(U,0)}, ${nU(U,4)}, ${nU(U,8)}, ${nU(U,12)} )`}function nU(C,U){return`(${C[U+0]}, ${C[U+1]}, ${C[U+2]}, ${C[U+3]})`}function SU(C){const U="Object_"+C.uniqueId,K=function(C){const U=C.getWorldMatrix().clone(),K=C.dC().useRightHandedSystem;if(!K){let m=C.parent;for(;m;){if(AC(m,K)){U.multiplyToRef(m.getWorldMatrix().invert(),U);break}m=m.parent}}return U.determinant()<0&&O.Tools.Warn(`Exporting mesh ${C.name} with negative scale. Result may look incorrect in destination engine.`),U}(C),m=xU(K);return`def Xform "${U}" (\n\tprepend references = @./geometries/Geometry_${C.ze.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${m}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${C.material.uniqueId}>\n}\n\n`}function sU(C){switch(C){case d.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case d.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case d.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function RU(C){return`(${C.x}, ${C.y})`}function qU(C){return`(${C.r}, ${C.g}, ${C.b})`}function IU(C,U,K,O,X,A){const e=C.getInternalTexture().uniqueId+"_"+C.invertY;X[e]=C;const t=C.coordinatesIndex>0?"st"+C.coordinatesIndex:"st",z=new m.Vector2(C.uScale,C.vScale),j=new m.Vector2(C.uOffset,C.vOffset),p=C.wAng,E=Math.sin(p),u=Math.cos(p);return j.y=1-j.y-z.y,j.x+=E*z.x,j.y+=(1-u)*z.y,`\n    def Shader "PrimvarReader_${K}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${t}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${K}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${U.uniqueId}/PrimvarReader_${K}.outputs:result>\n        float inputs:rotation = ${(p*(180/Math.PI)).toFixed(A.precision)}\n        float2 inputs:scale = ${RU(z)}\n        float2 inputs:translation = ${RU(j)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${C.uniqueId}_${K}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${e}.png@\n        float2 inputs:st.connect = </Materials/Material_${U.uniqueId}/Transform2d_${K}.outputs:result>\n        ${O?"float4 inputs:scale = "+function(C){return`(${C.r}, ${C.g}, ${C.b}, 1.0)`}(O):""}\n        token inputs:sourceColorSpace = "${C.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${sU(C.wrapU)}"\n        token inputs:wrapT = "${sU(C.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${U.needAlphaBlending()?"float outputs:a":""}\n    }`}function CK(C,U,K){const m="\t\t\t",O=[],X=[],{diffuseMap:A,Fe:e,alphaCutOff:t,emissiveMap:z,emissive:j,normalMap:p,roughnessMap:E,roughnessChannel:u,roughness:b,metalnessMap:v,metalnessChannel:V,metalness:f,aoMap:F,aoMapChannel:Z,aoMapIntensity:P,alphaMap:H,ior:d,clearCoatEnabled:T,clearCoat:y,clearCoatMap:a,clearCoatRoughness:r,clearCoatRoughnessMap:i}=function(C){const U={diffuseMap:null,Fe:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return C instanceof vC.VU?{...U,diffuseMap:C.diffuseTexture,Fe:C.diffuseColor,alphaCutOff:C.alphaCutOff,emissiveMap:C.emissiveTexture,emissive:C.emissiveColor,roughness:1,alphaMap:C.opacityTexture}:C instanceof zU.c?{...U,diffuseMap:C._albedoTexture,Fe:C._albedoColor,alphaCutOff:C._alphaCutOff,emissiveMap:C._emissiveTexture,emissive:C._emissiveColor,normalMap:C._bumpTexture,roughnessMap:C._metallicTexture,roughnessChannel:C._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:C._roughness??1,metalnessMap:C._metallicTexture,metalnessChannel:C._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:C._metallic??0,aoMap:C._ambientTexture,aoMapChannel:C._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:C._ambientTextureStrength,alphaMap:C._opacityTexture,ior:C.subSurface.indexOfRefraction,clearCoatEnabled:C.clearCoat.isEnabled,clearCoat:C.clearCoat.fe,clearCoatMap:C.clearCoat.texture,clearCoatRoughness:C.clearCoat.roughness,clearCoatRoughnessMap:C.clearCoat.useRoughnessFromMainTexture?C.clearCoat.texture:C.clearCoat.textureRoughness}:U}(C);return null!==A?(O.push(`${m}color3f inputs:diffuseColor.connect = </Materials/Material_${C.uniqueId}/Texture_${A.uniqueId}_diffuse.outputs:rgb>`),C.needAlphaBlending()?O.push(`${m}float inputs:opacity.connect = </Materials/Material_${C.uniqueId}/Texture_${A.uniqueId}_diffuse.outputs:a>`):C.needAlphaTesting()&&(O.push(`${m}float inputs:opacity.connect = </Materials/Material_${C.uniqueId}/Texture_${A.uniqueId}_diffuse.outputs:a>`),O.push(`${m}float inputs:opacityThreshold = ${t}`)),X.push(IU(A,C,"diffuse",e,U,K))):O.push(`${m}color3f inputs:diffuseColor = ${qU(e||Q.fU.White())}`),null!==z?(O.push(`${m}color3f inputs:emissiveColor.connect = </Materials/Material_${C.uniqueId}/Texture_${z.uniqueId}_emissive.outputs:rgb>`),X.push(IU(z,C,"emissive",j,U,K))):j&&j.toLuminance()>0&&O.push(`${m}color3f inputs:emissiveColor = ${qU(j)}`),null!==p&&(O.push(`${m}normal3f inputs:normal.connect = </Materials/Material_${C.uniqueId}/Texture_${p.uniqueId}_normal.outputs:rgb>`),X.push(IU(p,C,"normal",null,U,K))),null!==F&&(O.push(`${m}float inputs:occlusion.connect = </Materials/Material_${C.uniqueId}/Texture_${F.uniqueId}_occlusion.outputs:${Z}>`),X.push(IU(F,C,"occlusion",new Q.fU(P,P,P),U,K))),null!==E?(O.push(`${m}float inputs:roughness.connect = </Materials/Material_${C.uniqueId}/Texture_${E.uniqueId}_roughness.outputs:${u}>`),X.push(IU(E,C,"roughness",new Q.fU(b,b,b),U,K))):O.push(`${m}float inputs:roughness = ${b}`),null!==v?(O.push(`${m}float inputs:metallic.connect = </Materials/Material_${C.uniqueId}/Texture_${v.uniqueId}_metallic.outputs:${V}>`),X.push(IU(v,C,"metallic",new Q.fU(f,f,f),U,K))):O.push(`${m}float inputs:metallic = ${f}`),null!==H?(O.push(`${m}float inputs:opacity.connect = </Materials/Material_${C.uniqueId}/Texture_${H.uniqueId}_opacity.outputs:r>`),O.push(`${m}float inputs:opacityThreshold = 0.0001`),X.push(IU(H,C,"opacity",null,U,K))):O.push(`${m}float inputs:opacity = ${C.alpha}`),T&&(null!==a?(O.push(`${m}float inputs:clearcoat.connect = </Materials/Material_${C.uniqueId}/Texture_${a.uniqueId}_clearcoat.outputs:r>`),X.push(IU(a,C,"clearcoat",new Q.fU(y,y,y),U,K))):O.push(`${m}float inputs:clearcoat = ${y}`),null!==i?(O.push(`${m}float inputs:clearcoatRoughness.connect = </Materials/Material_${C.uniqueId}/Texture_${i.uniqueId}_clearcoatRoughness.outputs:g>`),X.push(IU(i,C,"clearcoatRoughness",new Q.fU(r,r,r),U,K))):O.push(`${m}float inputs:clearcoatRoughness = ${r}`)),O.push(`${m}float inputs:ior = ${d}`),`\n\tdef Material "Material_${C.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${O.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${C.uniqueId}/PreviewSurface.outputs:surface>\n\n${X.join("\n")}\n\n\t}\n`}async function UK(C,U,K){const X={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...U};"undefined"===typeof fflate&&await O.Tools.LoadScriptAsync(X.fflateUrl);const A={};A[X.modelFileName]=null;let e='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';e+=function(C){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===C.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${C.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${C.planeAnchoringAlignment}"`:""}\n            `}(X);const t={};for(const m of C.meshes){if(0===m.getTotalVertices())continue;const C=m,U=C.ze,z=C.material;if(!z||!U||K&&!K(C))continue;if(-1!==["VU","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(z.getClassName())){const K="geometries/Geometry_"+U.uniqueId+".usda";if(!(K in A)){const C=YU(U,X);A[K]=WU(C)}z.uniqueId in t||(t[z.uniqueId]=z),e+=SU(C)}else O.Tools.Warn("USDZExportAsync does not support this material type: "+z.getClassName())}C.activeCamera&&X.exportCamera&&(e+=function(C,U){const K="Camera_"+C.uniqueId,O=xU(m.Matrix.RotationY(Math.PI).multiply(C.getWorldMatrix()));if(C.mode===d.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${K}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${O}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${C.Ae.toPrecision(U.precision)}, ${C.maxZ.toPrecision(U.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(C.orthoLeft||1)+Math.abs(C.orthoRight||1))).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(C.orthoTop||1)+Math.abs(C.orthoBottom||1))).toPrecision(U.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const m=C.getEngine().getAspectRatio(C),X=U.cameraSensorWidth||35;return`def Camera "${K}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${O}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${C.Ae.toPrecision(U.precision)}, ${C.maxZ.toPrecision(U.precision)})\n\t\t\tfloat focalLength = ${(X/(2*Math.tan(.5*C.fov))).toPrecision(U.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(X*m).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(X/m).toPrecision(U.precision)}            \n\t\t}\n\t\n\t`}}(C.activeCamera,X)),e+="\n            }\n        }\n    }";const z={};e+=function(C,U,K){const m=[];for(const O in C){const X=C[O];m.push(CK(X,U,K))}return`\n    def "Materials"\n{\n${m.join("")}\n}\n\n`}(t,z,X),A[X.modelFileName]=fflate.strToU8(e);for(const m in z){const C=z[m],U=C.getSize(),K=await C.readPixels();if(!K)throw new Error("Texture data is not available");const O=await T.DumpTools.DumpDataAsync(U.width,U.height,K,"image/png",void 0,!1,!0);A[`textures/Texture_${m}.png`]=new Uint8Array(O).slice()}let j=0;for(const m in A){const C=A[m];if(!C)continue;j+=34+m.length;const U=63&j;if(4!==U){const K=new Uint8Array(64-U);A[m]=[C,{extra:{12345:K}}]}j=C.length}return fflate.zipSync(A,{level:0})}}}]);