"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[26],{12780:(M,Z,P)=>{P.r(Z),P.d(Z,{EXT_materials_diffuse_roughness:()=>rZ,EXT_mesh_gpu_instancing:()=>iM,GLTF2Export:()=>YM,GLTFData:()=>K,KHR_draco_mesh_compression:()=>PZ,KHR_lights_punctual:()=>mP,KHR_materials_anisotropy:()=>OZ,KHR_materials_clearcoat:()=>jZ,KHR_materials_diffuse_transmission:()=>nZ,KHR_materials_dispersion:()=>uZ,KHR_materials_emissive_strength:()=>JZ,KHR_materials_ior:()=>FZ,KHR_materials_iridescence:()=>lZ,KHR_materials_sheen:()=>QZ,KHR_materials_specular:()=>sZ,KHR_materials_transmission:()=>RZ,KHR_materials_unlit:()=>kZ,KHR_materials_volume:()=>oZ,KHR_texture_transform:()=>eZ,OBJExport:()=>v,STLExport:()=>bZ,USDZExportAsync:()=>ZP,_ConvertToGLTFPBRMetallicRoughness:()=>W,_SolveMetallic:()=>R,__IGLTFExporterExtension:()=>G});var x=P(12373),c=P(12175),w=P(12680);class v{static OBJ(M,Z,P,v){const G=[];let mM=1,K=1;Z&&(P||(P="mat"),G.push("mtllib "+P+".mtl"));for(let d=0;d<M.length;d++){const P=M[d],O=P.name||`mesh${d}}`;G.push(`o ${O}`);let H=null;if(v){const M=P.Jc(!0);H=new x.Matrix,M.invertToRef(H),P.bakeTransformIntoVertices(M)}if(Z){const M=P.material;M&&G.push("usemtl "+M.id)}const j=P.tc;if(!j){c.Tools.Warn("No geometry is present on the mesh");continue}const B=j.getVerticesData("position"),U=j.getVerticesData("normal"),n=j.getVerticesData("uv"),L=j.Fc();let u=0,N=0;if(!B||!L){c.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const J=M[0].DM().useRightHandedSystem?1:-1;for(let M=0;M<B.length;M+=3)G.push("v "+B[M]*J+" "+B[M+1]+" "+B[M+2]),u++;if(null!=U)for(let M=0;M<U.length;M+=3)G.push("vn "+U[M]*J+" "+U[M+1]+" "+U[M+2]);if(null!=n)for(let M=0;M<n.length;M+=2)G.push("vt "+n[M]+" "+n[M+1]),N++;const t=["","",""],F=(P.material||P.DM().defaultMaterial)._getEffectiveOrientation(P),[D,l]=F===w.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let M=0;M<L.length;M+=3){const Z=[String(L[M]+mM),String(L[M+D]+mM),String(L[M+l]+mM)],P=[String(L[M]+K),String(L[M+D]+K),String(L[M+l]+K)],x=Z,c=null!=n?P:t,w=null!=U?Z:t;G.push("f "+x[0]+"/"+c[0]+"/"+w[0]+" "+x[1]+"/"+c[1]+"/"+w[1]+" "+x[2]+"/"+c[2]+"/"+w[2])}v&&H&&P.bakeTransformIntoVertices(H),mM+=u,K+=N}return G.join("\n")}static MTL(M){const Z=[],P=M.material;Z.push("newmtl mat1"),Z.push("  Ns "+P.specularPower.toFixed(4)),Z.push("  Ni 1.5000"),Z.push("  d "+P.alpha.toFixed(4)),Z.push("  Tr 0.0000"),Z.push("  Tf 1.0000 1.0000 1.0000"),Z.push("  illum 2"),Z.push("  Ka "+P.ambientColor.r.toFixed(4)+" "+P.ambientColor.g.toFixed(4)+" "+P.ambientColor.b.toFixed(4)),Z.push("  Kd "+P.diffuseColor.r.toFixed(4)+" "+P.diffuseColor.g.toFixed(4)+" "+P.diffuseColor.b.toFixed(4)),Z.push("  Ks "+P.specularColor.r.toFixed(4)+" "+P.specularColor.g.toFixed(4)+" "+P.specularColor.b.toFixed(4)),Z.push("  Ke "+P.emissiveColor.r.toFixed(4)+" "+P.emissiveColor.g.toFixed(4)+" "+P.emissiveColor.b.toFixed(4));P.ambientTexture&&Z.push("  map_Ka "+P.ambientTexture.name),P.diffuseTexture&&Z.push("  map_Kd "+P.diffuseTexture.name),P.specularTexture&&Z.push("  map_Ks "+P.specularTexture.name),P.bumpTexture&&Z.push("  map_bump -imfchan z "+P.bumpTexture.name),P.opacityTexture&&Z.push("  map_d "+P.opacityTexture.name);return Z.join("\n")}}var G=0,mM=P(12230);class K{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const M in this.files){const Z=this.files[M],P=new Blob([Z],{type:(0,mM.j)(M)});c.Tools.Download(P,M)}}}var d=P(12430),O=P(12784),H=P(12800),j=P(12821),B=P(12482),U=P(12225),n=P(12406),L=P(12387);const u=L.HighestCommonFactor,N={...L,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:u};var J=P(12581),t=P(12344),F=P(12841),D=P(12845),l=P(12579);const h=1e-6,Q=new n.uZ(.04,.04,.04),I=1024,s=n.uZ.White(),C=n.uZ.Black();function R(M,Z,P){if(Z<Q.r)return 0;const x=Q.r,c=M*P/(1-Q.r)+Z-2*Q.r,w=c*c-4*x*(Q.r-Z);return N.Clamp((-c+Math.sqrt(w))/(2*x),0,1)}function W(M){const Z=M.diffuseColor.toLinearSpace(M.DM().getEngine().useExactSrgbConversions).scale(.5),P=M.alpha,c=function(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new x.Vector2(0,1),P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new x.Vector2(0,.1),c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new x.Vector2(0,.1),w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new x.Vector2(1300,.1);return function(M,Z,P,x,c){return(1-M)*(1-M)*(1-M)*Z+3*(1-M)*(1-M)*M*P+3*(1-M)*M*M*x+M*M*M*c}(Math.pow(M/w.x,.333333),Z.y,P.y,c.y,w.y)}(N.Clamp(M.specularPower,0,I));return{baseColorFactor:[Z.r,Z.g,Z.b,P],metallicFactor:0,roughnessFactor:c}}function k(M,Z){Z.needAlphaBlending()?M.alphaMode="BLEND":Z.needAlphaTesting()&&(M.alphaMode="MASK",M.alphaCutoff=Z.alphaCutOff)}function A(M,Z,P){const x=new Uint8Array(M*Z*4);for(let c=0;c<x.length;c+=4)x[c]=x[c+1]=x[c+2]=x[c+3]=255;return F.e.CreateRGBATexture(x,M,Z,P)}function o(M){if(M instanceof Uint8Array){const Z=M.length,P=new Float32Array(M.length);for(let x=0;x<Z;++x)P[x]=M[x]/255;return P}if(M instanceof Float32Array)return M;throw new Error("Unsupported pixel format!")}class E{constructor(M){this._exporter=M,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(M){return M?this._textureMap.get(M)??null:null}async exportStandardMaterialAsync(M,Z,P){const x=W(M),w={name:M.name};if(null==M.Dc||M.Dc||(M.twoSidedLighting||c.Tools.Warn(M.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),w.doubleSided=!0),P){const P=[],c=M.diffuseTexture;c&&P.push(this.exportTextureAsync(c,Z).then((M=>{M&&(x.baseColorTexture=M)})));const v=M.bumpTexture;v&&P.push(this.exportTextureAsync(v,Z).then((M=>{M&&(w.normalTexture=M,1!==v.level&&(w.normalTexture.scale=v.level))})));const G=M.emissiveTexture;G&&(w.emissiveFactor=[1,1,1],P.push(this.exportTextureAsync(G,Z).then((M=>{M&&(w.emissiveTexture=M)}))));const mM=M.ambientTexture;mM&&P.push(this.exportTextureAsync(mM,Z).then((M=>{if(M){const Z={index:M.index};w.occlusionTexture=Z}}))),P.length>0&&(this._exporter._materialNeedsUVsSet.add(M),await Promise.all(P))}(M.alpha<1||M.opacityTexture)&&(M.alphaMode===D.d.ALPHA_COMBINE?w.alphaMode="BLEND":c.Tools.Warn(M.name+": glTF 2.0 does not support alpha mode: "+M.alphaMode.toString())),M.emissiveColor&&!M.emissiveColor.equalsWithEpsilon(C,h)&&(w.emissiveFactor=M.emissiveColor.nc()),w.pbrMetallicRoughness=x,k(w,M),await this._finishMaterialAsync(w,M,Z);const v=this._exporter._materials;return v.push(w),v.length-1}async _finishMaterialAsync(M,Z,P){const x=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",M,Z),c=[];for(const w of x)c.push(this.exportTextureAsync(w,P));await Promise.all(c),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",M,Z)}async _getImageDataAsync(M,Z,x,c){const w=D.d.TEXTURETYPE_UNSIGNED_BYTE,v=this._exporter._babylonScene,G=v.getEngine(),mM=G.createRawTexture(M,Z,x,D.d.TEXTUREFORMAT_RGBA,!1,!0,t.e.NEAREST_SAMPLINGMODE,null,w);G.isWebGPU?await P.e(51).then(P.bind(P,14873)):await P.e(52).then(P.bind(P,14881)),await J.l.ApplyPostProcess("pass",mM,v,w,D.d.TEXTURE_NEAREST_SAMPLINGMODE,D.d.TEXTUREFORMAT_RGBA);const K=await G._readTexturePixels(mM,Z,x);return await l.DumpTools.DumpDataAsync(Z,x,K,c,void 0,!0,!0)}_resizeTexturesToSameDimensions(M,Z,P){const x=M?M.getSize():{width:0,height:0},c=Z?Z.getSize():{width:0,height:0};let w,v;return x.width<c.width?(w=M&&M instanceof t.e?J.l.CreateResizedCopy(M,c.width,c.height,!0):A(c.width,c.height,P),v=Z):x.width>c.width?(v=Z&&Z instanceof t.e?J.l.CreateResizedCopy(Z,x.width,x.height,!0):A(x.width,x.height,P),w=M):(w=M,v=Z),{texture1:w,texture2:v}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(M,Z,P,x){const c=new Array;if(!M&&!Z)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const w=M?M.DM():Z?Z.DM():null;if(w){var v;const G=this._resizeTexturesToSameDimensions(M,Z,w),mM=null===(v=G.texture1)||void 0===v?void 0:v.getSize();let K,d;const O=mM.width,H=mM.height,j=await G.texture1.readPixels(),B=await G.texture2.readPixels();if(!j)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(K=o(j),!B)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");d=o(B);const U=d.byteLength,L=new Uint8Array(U),u=new Uint8Array(U),N=4,J=C;let t=0,F=0;for(let M=0;M<H;++M)for(let Z=0;Z<O;++Z){const x=(O*M+Z)*N,c={diffuseColor:new n.uZ(K[x],K[x+1],K[x+2]).toLinearSpace(w.getEngine().useExactSrgbConversions).multiply(P.diffuseColor),specularColor:new n.uZ(d[x],d[x+1],d[x+2]).toLinearSpace(w.getEngine().useExactSrgbConversions).multiply(P.specularColor),glossiness:d[x+3]*P.glossiness},v=this._convertSpecularGlossinessToMetallicRoughness(c);J.r=Math.max(J.r,v.baseColor.r),J.g=Math.max(J.g,v.baseColor.g),J.b=Math.max(J.b,v.baseColor.b),t=Math.max(t,v.metallic),F=Math.max(F,v.roughness),u[x]=255*v.baseColor.r,u[x+1]=255*v.baseColor.g,u[x+2]=255*v.baseColor.b,u[x+3]=G.texture1.Lc?255*K[x+3]:255,L[x]=0,L[x+1]=255*v.roughness,L[x+2]=255*v.metallic,L[x+3]=255}const D={baseColor:J,metallic:t,roughness:F};let l=!1,Q=!1;for(let M=0;M<H;++M)for(let Z=0;Z<O;++Z){const P=(O*M+Z)*N;u[P]/=D.baseColor.r>h?D.baseColor.r:1,u[P+1]/=D.baseColor.g>h?D.baseColor.g:1,u[P+2]/=D.baseColor.b>h?D.baseColor.b:1;const x=n.uZ.FromInts(u[P],u[P+1],u[P+2]).toGammaSpace(w.getEngine().useExactSrgbConversions);u[P]=255*x.r,u[P+1]=255*x.g,u[P+2]=255*x.b,x.equalsWithEpsilon(s,h)||(Q=!0),L[P+1]/=D.roughness>h?D.roughness:1,L[P+2]/=D.metallic>h?D.metallic:1;n.uZ.FromInts(255,L[P+1],L[P+2]).equalsWithEpsilon(s,h)||(l=!0)}return l&&c.push(this._getImageDataAsync(L,O,H,x).then((M=>{D.metallicRoughnessTextureData=M}))),Q&&c.push(this._getImageDataAsync(u,O,H,x).then((M=>{D.baseColorTextureData=M}))),await Promise.all(c).then((()=>D))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(M){const Z=this._getPerceivedBrightness(M.diffuseColor),P=this._getPerceivedBrightness(M.specularColor),x=1-this._getMaxComponent(M.specularColor),c=R(Z,P,x),w=M.diffuseColor.scale(x/(1-Q.r)/Math.max(1-c)),v=M.specularColor.UZ(Q.scale(1-c)).scale(1/Math.max(c));let G=n.uZ.Lerp(w,v,c*c);G=G.clampToRef(0,1,G);return{baseColor:G,metallic:c,roughness:1-M.glossiness}}_getPerceivedBrightness(M){return M?Math.sqrt(.299*M.r*M.r+.587*M.g*M.g+.114*M.b*M.b):0}_getMaxComponent(M){return M?Math.max(M.r,Math.max(M.g,M.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(M,Z,P,x){const c=[],w={baseColor:M._albedoColor,metallic:M._metallic,roughness:M._roughness};if(x){M._albedoTexture&&c.push(this.exportTextureAsync(M._albedoTexture,Z).then((M=>{M&&(P.baseColorTexture=M)})));const x=M._metallicTexture;x&&c.push(this.exportTextureAsync(x,Z).then((M=>{M&&(P.metallicRoughnessTexture=M)})))}return c.length>0&&(this._exporter._materialNeedsUVsSet.add(M),await Promise.all(c)),w}_getTextureSampler(M){const Z={};if(!M||!(M instanceof t.e))return Z;const P=this._getGLTFTextureWrapMode(M.wrapU);10497!==P&&(Z.wrapS=P);const x=this._getGLTFTextureWrapMode(M.wrapV);switch(10497!==x&&(Z.wrapT=x),M.samplingMode){case t.e.LINEAR_LINEAR:Z.magFilter=9729,Z.minFilter=9729;break;case t.e.LINEAR_NEAREST:Z.magFilter=9729,Z.minFilter=9728;break;case t.e.NEAREST_LINEAR:Z.magFilter=9728,Z.minFilter=9729;break;case t.e.NEAREST_LINEAR_MIPLINEAR:Z.magFilter=9728,Z.minFilter=9987;break;case t.e.NEAREST_NEAREST:Z.magFilter=9728,Z.minFilter=9728;break;case t.e.NEAREST_LINEAR_MIPNEAREST:Z.magFilter=9728,Z.minFilter=9985;break;case t.e.LINEAR_NEAREST_MIPNEAREST:Z.magFilter=9729,Z.minFilter=9984;break;case t.e.LINEAR_NEAREST_MIPLINEAR:Z.magFilter=9729,Z.minFilter=9986;break;case t.e.NEAREST_NEAREST_MIPLINEAR:Z.magFilter=9728,Z.minFilter=9986;break;case t.e.LINEAR_LINEAR_MIPLINEAR:Z.magFilter=9729,Z.minFilter=9987;break;case t.e.LINEAR_LINEAR_MIPNEAREST:Z.magFilter=9729,Z.minFilter=9985;break;case t.e.NEAREST_NEAREST_MIPNEAREST:Z.magFilter=9728,Z.minFilter=9984}return Z}_getGLTFTextureWrapMode(M){switch(M){case t.e.WRAP_ADDRESSMODE:return 10497;case t.e.CLAMP_ADDRESSMODE:return 33071;case t.e.MIRROR_ADDRESSMODE:return 33648;default:return c.Tools.Error(`Unsupported Texture Wrap Mode ${M}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(M,Z,P,x){const c={diffuseColor:M._albedoColor,specularColor:M._reflectivityColor,glossiness:M._microSurface},w=M._albedoTexture,v=M._reflectivityTexture,G=M._useMicroSurfaceFromReflectivityMapAlpha;if(v&&!G)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((w||v)&&x){this._exporter._materialNeedsUVsSet.add(M);const x=this._exportTextureSampler(w||v),G=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(w,v,c,Z),mM=this._exporter._textures;if(G.baseColorTextureData){const M=this._exportImage(`baseColor${mM.length}`,Z,G.baseColorTextureData);P.baseColorTexture=this._exportTextureInfo(M,x,null===w||void 0===w?void 0:w.coordinatesIndex)}if(G.metallicRoughnessTextureData){const M=this._exportImage(`metallicRoughness${mM.length}`,Z,G.metallicRoughnessTextureData);P.metallicRoughnessTexture=this._exportTextureInfo(M,x,null===v||void 0===v?void 0:v.coordinatesIndex)}return G}return this._convertSpecularGlossinessToMetallicRoughness(c)}async exportPBRMaterialAsync(M,Z,P){const x={},c={name:M.name},w=M.isMetallicWorkflow();if(w){const Z=M._albedoColor,P=M.alpha;Z&&(x.baseColorFactor=[Z.r,Z.g,Z.b,P])}const v=w?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(M,Z,x,P):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(M,Z,x,P);await this._setMetallicRoughnessPbrMaterialAsync(v,M,c,x,Z,P),await this._finishMaterialAsync(c,M,Z);const G=this._exporter._materials;return G.push(c),G.length-1}async _setMetallicRoughnessPbrMaterialAsync(M,Z,P,x,w,v){if(k(P,Z),M.baseColor.equalsWithEpsilon(s,h)&&N.WithinEpsilon(Z.alpha,1,h)||(x.baseColorFactor=[M.baseColor.r,M.baseColor.g,M.baseColor.b,Z.alpha]),null!=M.metallic&&1!==M.metallic&&(x.metallicFactor=M.metallic),null!=M.roughness&&1!==M.roughness&&(x.roughnessFactor=M.roughness),null==Z.Dc||Z.Dc||(Z._twoSidedLighting||c.Tools.Warn(Z.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),P.doubleSided=!0),v){const M=[],x=Z._bumpTexture;x&&M.push(this.exportTextureAsync(x,w).then((M=>{M&&(P.normalTexture=M,1!==x.level&&(P.normalTexture.scale=x.level))})));const c=Z._ambientTexture;c&&M.push(this.exportTextureAsync(c,w).then((M=>{if(M){const x={index:M.index,texCoord:M.texCoord,extensions:M.extensions};P.occlusionTexture=x;const c=Z._ambientTextureStrength;c&&(x.strength=c)}})));const v=Z._emissiveTexture;v&&M.push(this.exportTextureAsync(v,w).then((M=>{M&&(P.emissiveTexture=M)}))),M.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(M))}const G=Z._emissiveColor;G.equalsWithEpsilon(C,h)||(P.emissiveFactor=G.nc()),P.pbrMetallicRoughness=x}_getPixelsFromTextureAsync(M){return function(M){switch(M){case D.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case D.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case D.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case D.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case D.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case D.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case D.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case D.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case D.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case D.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case D.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case D.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(M.textureFormat)?(0,J.j)(M,M._texture.width,M._texture.height):(M.textureType,D.d.TEXTURETYPE_UNSIGNED_BYTE,M.readPixels())}async exportTextureAsync(M,Z){const P=this._exporter._extensionsPreExportTextureAsync("exporter",M,Z);return P?await P.then((async P=>P?await this._exportTextureInfoAsync(P,Z):await this._exportTextureInfoAsync(M,Z))):await this._exportTextureInfoAsync(M,Z)}async _exportTextureInfoAsync(M,Z){let P=this._textureMap.get(M);if(!P){const x=await this._getPixelsFromTextureAsync(M);if(!x)return null;const w=this._exportTextureSampler(M),v=M.mimeType;if(v)switch(v){case"image/jpeg":case"image/png":case"image/webp":Z=v;break;default:c.Tools.Warn(`Unsupported media type: ${v}. Exporting texture as PNG.`)}const G=this._internalTextureToImage,mM=M.getInternalTexture().uniqueId;G[mM]||(G[mM]={});let K=G[mM][Z];if(void 0===K){const P=M.getSize();K=(async()=>{const c=await this._getImageDataAsync(x,P.width,P.height,Z);return this._exportImage(M.name,Z,c)})(),G[mM][Z]=K}P=this._exportTextureInfo(await K,w,M.coordinatesIndex),this._textureMap.set(M,P),this._exporter._extensionsPostExportTextures("exporter",P,M)}return P}_exportImage(M,Z,P){const x=this._exporter._images;let w;if(this._exporter._shouldUseGlb){w={name:M,mimeType:Z,bufferView:void 0};const x=this._exporter._bufferManager.createBufferView(new Uint8Array(P));this._exporter._bufferManager.setBufferView(w,x)}else{const v=M.replace(/\.\/|\/|\.\\|\\/g,"_"),G=function(M){switch(M){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(Z);let mM=v+G;x.some((M=>M.uri===mM))&&(mM=`${v}_${c.Tools.RandomId()}${G}`),w={name:M,uri:mM},this._exporter._imageData[mM]={data:P,mimeType:Z}}return x.push(w),x.length-1}_exportTextureInfo(M,Z,P){const x=this._exporter._textures;let c=x.findIndex((P=>P.sampler==Z&&P.source===M));-1===c&&(c=x.length,x.push({source:M,sampler:Z}));const w={index:c};return P&&(w.texCoord=P),w}_exportTextureSampler(M){const Z=this._getTextureSampler(M),P=this._exporter._samplers,x=P.findIndex((M=>M.minFilter===Z.minFilter&&M.magFilter===Z.magFilter&&M.wrapS===Z.wrapS&&M.wrapT===Z.wrapT));return-1!==x?x:(P.push(Z),P.length-1)}}var r=P(12448),q=P(12199),e=P(12847),b=P(12377);const a=x.BZ.Zero(),y=x.Quaternion.Identity(),f=x.BZ.One(),Y=new x.BZ(-1,1,1);function z(M,Z){const{byteOffset:P,byteStride:x,type:c,normalized:w}=M,v=M.getSize(),G=Z.reduce(((M,Z)=>Z.getTotalVertices()>M?Z.getTotalVertices():M),-Number.MAX_VALUE);return{byteOffset:P,byteStride:x,componentCount:v,type:c,count:G*v,normalized:w,totalVertices:G,kind:M.getKind()}}function i(M){switch(M){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function T(M){switch(M){case d.g.PositionKind:case d.g.NormalKind:case d.g.TangentKind:case d.g.ColorKind:case d.g.MatricesIndicesKind:case d.g.MatricesIndicesExtraKind:case d.g.MatricesWeightsKind:case d.g.MatricesWeightsExtraKind:case d.g.UVKind:case d.g.UV2Kind:case d.g.UV3Kind:case d.g.UV4Kind:case d.g.UV5Kind:case d.g.UV6Kind:return!0}return!1}function p(M){switch(M){case w.d.TriangleFillMode:return 4;case w.d.TriangleStripDrawMode:return 5;case w.d.TriangleFanDrawMode:return 6;case w.d.PointListDrawMode:case w.d.PointFillMode:return 0;case w.d.LineLoopDrawMode:return 2;case w.d.LineListDrawMode:return 1;case w.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${M}`)}function S(M){const Z=Math.sqrt(M.x*M.x+M.y*M.y+M.z*M.z);Z>0&&(M.x/=Z,M.y/=Z,M.z/=Z)}function X(M){return M.x*=-1,M}function V(M){if(M.x*M.x+M.y*M.y>.5){const Z=Math.abs(M.x),P=Math.abs(M.y);if(Z>P){const P=Math.sign(M.x);M.x=Z,M.y*=-P,M.z*=-P,M.w*=P}else{const Z=Math.sign(M.y);M.x*=-Z,M.y=P,M.z*=Z,M.w*=-Z}}else{const Z=Math.abs(M.z),P=Math.abs(M.w);if(Z>P){const P=Math.sign(M.z);M.x*=-P,M.y*=P,M.z=Z,M.w*=-P}else{const Z=Math.sign(M.w);M.x*=Z,M.y*=-Z,M.z*=-Z,M.w=P}}return M}function g(M){M.lc(-M.z,M.w,M.x,-M.y)}function MM(M,Z){const P=x.BZ.FromArrayToRef(Z.translation||[0,0,0],0,x.TmpVectors.BZ[0]),c=x.Quaternion.FromArrayToRef(Z.rotation||[0,0,0,1],0,x.TmpVectors.Quaternion[0]),w=x.Matrix.ComposeToRef(f,c,P,x.TmpVectors.Matrix[0]),v=x.BZ.FromArrayToRef(M.translation||[0,0,0],0,x.TmpVectors.BZ[2]),G=x.Quaternion.FromArrayToRef(M.rotation||[0,0,0,1],0,x.TmpVectors.Quaternion[1]),mM=x.Matrix.ComposeToRef(f,G,v,x.TmpVectors.Matrix[1]);w.multiplyToRef(mM,mM),mM.decompose(void 0,c,P),P.equalsWithEpsilon(a,b.c)?delete Z.translation:Z.translation=P.nc(),c.equalsWithEpsilon(y,b.c)?delete Z.rotation:Z.rotation=c.nc(),Z.scale&&delete Z.scale}function ZM(M,Z){if(!(Z instanceof O.b))return!1;if(!(1===Z.getChildren().length&&0===M.getChildren().length&&M.parent===Z))return!1;const P=M.DM(),x=M instanceof e.b&&!P.useRightHandedSystem?Y:f;return!!Z.hc.equalsWithEpsilon(x,b.c)||(q.d.Warn(`Cannot collapse node ${M.name} into parent node ${Z.name} with modified scaling.`),!1)}function PM(M){if(M instanceof Array){const Z=new Float32Array(M);return new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength)}return ArrayBuffer.isView(M)?new Uint8Array(M.buffer,M.byteOffset,M.byteLength):new Uint8Array(M)}function xM(M,Z){for(const[P,x]of Object.entries(M)){const c=Z[P];(Array.isArray(x)&&Array.isArray(c)&&cM(x,c)||x===c)&&delete M[P]}return M}function cM(M,Z){return M.length===Z.length&&M.every(((M,P)=>M===Z[P]))}const wM=x.Matrix.Compose(new x.BZ(-1,1,1),x.Quaternion.Identity(),x.BZ.Zero());function vM(M,Z){if(!(M instanceof O.b))return!1;if(Z){if(!M.getWorldMatrix().equalsWithEpsilon(x.Matrix.IdentityReadOnly,b.c))return!1}else{if(!M.getWorldMatrix().multiplyToRef(wM,x.TmpVectors.Matrix[0]).equalsWithEpsilon(x.Matrix.IdentityReadOnly,b.c))return!1}return!(M instanceof H.b&&M.tc)}const GM=new Map([[Int8Array,(M,Z,P)=>M.setInt8(Z,P)],[Uint8Array,(M,Z,P)=>M.setUint8(Z,P)],[Uint8ClampedArray,(M,Z,P)=>M.setUint8(Z,P)],[Int16Array,(M,Z,P)=>M.setInt16(Z,P,!0)],[Uint16Array,(M,Z,P)=>M.setUint16(Z,P,!0)],[Int32Array,(M,Z,P)=>M.setInt32(Z,P,!0)],[Uint32Array,(M,Z,P)=>M.setUint32(Z,P,!0)],[Float32Array,(M,Z,P)=>M.setFloat32(Z,P,!0)],[Float64Array,(M,Z,P)=>M.setFloat64(Z,P,!0)]]);class mZ{writeTypedArray(M){this._checkGrowBuffer(M.byteLength);const Z=GM.get(M.constructor);for(let P=0;P<M.length;P++)Z(this._dataView,this._byteOffset,M[P]),this._byteOffset+=M.BYTES_PER_ELEMENT}constructor(M){this._data=new Uint8Array(M),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(M){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,M),this._byteOffset++}writeInt8(M){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,M),this._byteOffset++}writeInt16(M){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,M,!0),this._byteOffset+=2}writeUInt16(M){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,M,!0),this._byteOffset+=2}writeInt32(M){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,M,!0),this._byteOffset+=4}writeUInt32(M){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,M,!0),this._byteOffset+=4}writeFloat32(M){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,M,!0),this._byteOffset+=4}writeFloat64(M){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,M,!0),this._byteOffset+=8}_checkGrowBuffer(M){const Z=this.byteOffset+M;if(Z>this._data.byteLength){const M=new Uint8Array(2*Z);M.set(this._data),this._data=M,this._dataView=new DataView(this._data.buffer)}}}function KM(M){return M%4===0?4:M%2===0?2:1}class dM{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(M){let Z=0;this._bufferViewToData.forEach((M=>{Z+=M.byteLength}));const P=new mZ(Z),x=Array.from(this._bufferViewToData.keys()).sort(((M,Z)=>KM(Z.byteLength)-KM(M.byteLength)));for(const c of x){c.byteOffset=P.byteOffset,M.push(c);const Z=M.length-1,x=this.getPropertiesWithBufferView(c);for(const M of x)M.bufferView=Z;P.writeTypedArray(this._bufferViewToData.get(c)),this._bufferViewToData.delete(c)}return P.getOutputData()}createBufferView(M,Z){const P={buffer:0,byteOffset:void 0,byteLength:M.byteLength,byteStride:Z};return this._bufferViewToData.set(P,M),P}createAccessor(M,Z,P,x,c,w,v){this._verifyBufferView(M);const G={bufferView:void 0,componentType:P,count:x,type:Z,min:null===w||void 0===w?void 0:w.min,max:null===w||void 0===w?void 0:w.max,normalized:v,byteOffset:c};return this.setBufferView(G,M),this._accessorToBufferView.set(G,M),G}setBufferView(M,Z){this._verifyBufferView(Z);this.getPropertiesWithBufferView(Z).push(M)}removeBufferView(M){const Z=this.getPropertiesWithBufferView(M);for(const P of Z)void 0!==P.bufferView&&delete P.bufferView;this._bufferViewToData.delete(M),this._bufferViewToProperties.delete(M),this._accessorToBufferView.forEach(((Z,P)=>{Z===M&&(void 0!==P.byteOffset&&delete P.byteOffset,this._accessorToBufferView.delete(P))}))}getBufferView(M){const Z=this._accessorToBufferView.get(M);return this._verifyBufferView(Z),Z}getPropertiesWithBufferView(M){return this._verifyBufferView(M),this._bufferViewToProperties.set(M,this._bufferViewToProperties.get(M)??[]),this._bufferViewToProperties.get(M)}getData(M){return this._verifyBufferView(M),this._bufferViewToData.get(M)}_verifyBufferView(M){if(void 0===M||!this._bufferViewToData.has(M))throw new Error(`BufferView ${M} not found in BufferManager.`)}}var OM,HM=P(12828),jM=P(12839),BM=P(12856),UM=P(12743),nM=P(12890),LM=P(12899),uM=P(12825),NM=P(12902);!function(M){M[M.INTANGENT=0]="INTANGENT",M[M.OUTTANGENT=1]="OUTTANGENT"}(OM||(OM={}));class JM{static _IsTransformable(M){return M&&(M instanceof O.b||M instanceof HM.e||M instanceof NM.d)}static _CreateNodeAnimation(M,Z,P,x,w){if(this._IsTransformable(M)){const v=[],G=[],mM=Z.getKeys(),K=JM._CalculateMinMaxKeyFrames(mM),d=JM._DeduceInterpolation(mM,P,x),O=d.interpolationType,H=d.shouldBakeAnimation;if(H?JM._CreateBakedAnimation(M,Z,P,K.min,K.max,Z.framePerSecond,w,v,G,K,x):"LINEAR"===O||"STEP"===O?JM._CreateLinearOrStepAnimation(M,Z,P,v,G,x):"CUBICSPLINE"===O?JM._CreateCubicSplineAnimation(M,Z,P,v,G,x):JM._CreateBakedAnimation(M,Z,P,K.min,K.max,Z.framePerSecond,w,v,G,K,x),v.length&&G.length){return{inputs:v,outputs:G,samplerInterpolation:O,inputsMin:H?K.min:c.Tools.FloatRound(K.min/Z.framePerSecond),inputsMax:H?K.max:c.Tools.FloatRound(K.max/Z.framePerSecond)}}}return null}static _DeduceAnimationInfo(M){let Z=null,P="VEC3",x=!1;const w=M.targetProperty.split(".");switch(w[0]){case"hc":Z="scale";break;case"position":Z="translation";break;case"rotation":P="VEC4",Z="rotation";break;case"rotationQuaternion":P="VEC4",x=!0,Z="rotation";break;case"influence":P="SCALAR",Z="weights";break;default:c.Tools.Error(`Unsupported animatable property ${w[0]}`)}return Z?{animationChannelTargetPath:Z,dataAccessorType:P,useQuaternion:x}:(c.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(M,Z,P,x,c,w,v,G,mM,K,d){let O;if(JM._IsTransformable(M)&&M.animations)for(const H of M.animations){if(d&&!d(H))continue;const c=JM._DeduceAnimationInfo(H);c&&(O={name:H.name,samplers:[],channels:[]},JM._AddAnimation(`${H.name}`,H.hasRunningRuntimeAnimations?Z:O,M,H,c.dataAccessorType,c.animationChannelTargetPath,x,w,v,G,c.useQuaternion,mM,K),O.samplers.length&&O.channels.length&&P.push(O))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(M,Z,P,x,c,w,v,G,mM,K,d){let O;if(M instanceof uM.c){const c=M.morphTargetManager;if(c)for(let H=0;H<c.numTargets;++H){const j=c.getTarget(H);for(const B of j.animations){if(d&&!d(B))continue;const j=new nM.d(`${B.name}`,"influence",B.framePerSecond,B.dataType,B.loopMode,B.enableBlending),U=[],n=B.getKeys();for(let M=0;M<n.length;++M){const Z=n[M];for(let M=0;M<c.numTargets;++M)M==H?U.push(Z):U.push({frame:Z.frame,value:0})}j.setKeys(U);const L=JM._DeduceAnimationInfo(j);L&&(O={name:j.name,samplers:[],channels:[]},JM._AddAnimation(B.name,B.hasRunningRuntimeAnimations?Z:O,M,j,L.dataAccessorType,L.animationChannelTargetPath,x,w,v,G,L.useQuaternion,mM,K,c.numTargets),O.samplers.length&&O.channels.length&&P.push(O))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(M,Z,P,x,c,w,v,G,mM){let K;if(M.animationGroups){const O=M.animationGroups;for(const H of O){const O=new Map,j=new Map,B=new Set,U=H.to-H.from;K={name:H.name,channels:[],samplers:[]};for(let Z=0;Z<H.targetedAnimations.length;++Z){const U=H.targetedAnimations[Z],n=U.target,L=U.animation;if(mM&&!mM(L))continue;const u=G.has(n);if(this._IsTransformable(n)||1===n.length&&this._IsTransformable(n[0])){const M=JM._DeduceAnimationInfo(U.animation);if(M){const Z=this._IsTransformable(n)?n:this._IsTransformable(n[0])?n[0]:null;Z&&JM._AddAnimation(`${L.name}`,K,Z,L,M.dataAccessorType,M.animationChannelTargetPath,P,x,c,w,M.useQuaternion,v,u)}}else if(n instanceof LM.c||1===n.length&&n[0]instanceof LM.c){if(JM._DeduceAnimationInfo(U.animation)){const Z=n instanceof LM.c?n:n[0];if(Z){const P=M.morphTargetManagers.find((M=>{for(let P=0;P<M.numTargets;++P)if(M.getTarget(P)===Z)return!0;return!1}));if(P){const x=M.meshes.find((M=>M.morphTargetManager===P));var d;if(x)O.has(x)||O.set(x,new Map),null===(d=O.get(x))||void 0===d||d.set(Z,L),B.add(x),j.set(x,L)}}}}}B.forEach((M=>{const Z=M.morphTargetManager;let G=null;const mM=[],d=j.get(M).getKeys(),B=d.length;for(let P=0;P<B;++P)for(let x=0;x<Z.numTargets;++x){const c=Z.getTarget(x),w=O.get(M);if(w){const Z=w.get(c);Z?(G||(G=new nM.d(`${H.name}_${M.name}_MorphWeightAnimation`,"influence",Z.framePerSecond,nM.d.ANIMATIONTYPE_FLOAT,Z.loopMode,Z.enableBlending)),mM.push(Z.getKeys()[P])):mM.push({frame:H.from+U/B*P,value:c.influence,inTangent:d[0].inTangent?0:void 0,outTangent:d[0].outTangent?0:void 0})}}G.setKeys(mM);const n=JM._DeduceAnimationInfo(G);n&&JM._AddAnimation(`${H.name}_${M.name}_MorphWeightAnimation`,K,M,G,n.dataAccessorType,n.animationChannelTargetPath,P,x,c,w,n.useQuaternion,v,!1,null===Z||void 0===Z?void 0:Z.numTargets)})),K.channels.length&&K.samplers.length&&Z.push(K)}}}static _AddAnimation(M,Z,P,c,w,v,G,mM,K,d,O,H,j,B){const U=JM._CreateNodeAnimation(P,c,v,O,H);let n,L,u,N,J,t;if(U){if(B){let M=0,Z=0;const P=[];for(;U.inputs.length>0;)Z=U.inputs.shift(),M%B==0&&P.push(Z),M++;U.inputs=P}const M=G.get(P),c=new Float32Array(U.inputs);n=mM.createBufferView(c),L=mM.createAccessor(n,"SCALAR",5126,U.inputs.length,void 0,{min:[U.inputsMin],max:[U.inputsMax]}),d.push(L),u=d.length-1;const K=new x.Quaternion,O=new x.BZ,H=new x.BZ,F=P instanceof HM.e,D=i(w),l=new Float32Array(U.outputs.length*D);U.outputs.forEach((function(M,Z){let P=M;switch(v){case"translation":j&&(x.BZ.FromArrayToRef(M,0,H),X(H),H.toArray(P));break;case"rotation":4===M.length?x.Quaternion.FromArrayToRef(M,0,K):(P=new Array(4),x.BZ.FromArrayToRef(M,0,O),x.Quaternion.FromEulerVectorToRef(O,K)),j&&(V(K),F&&g(K)),K.toArray(P)}l.set(P,Z*D)})),n=mM.createBufferView(l),L=mM.createAccessor(n,w,5126,U.outputs.length),d.push(L),N=d.length-1,J={interpolation:U.samplerInterpolation,input:u,output:N},Z.samplers.push(J),t={sampler:Z.samplers.length-1,target:{node:M,path:v}},Z.channels.push(t)}}static _CreateBakedAnimation(M,Z,P,w,v,G,mM,K,d,O,H){let j;const B=x.Quaternion.Identity();let U,n=null,L=null,u=null,N=null,J=null,t=null;O.min=c.Tools.FloatRound(w/G);const F=Z.getKeys();for(let x=0,D=F.length;x<D;++x){if(t=null,u=F[x],x+1<D)if(N=F[x+1],u.value.equals&&u.value.equals(N.value)||u.value===N.value){if(0!==x)continue;t=u.frame}else t=N.frame;else{if(J=F[x-1],u.value.equals&&u.value.equals(J.value)||u.value===J.value)continue;t=v}if(t)for(let x=u.frame;x<=t;x+=mM){if(U=c.Tools.FloatRound(x/G),U===n)continue;n=U,L=U;const w={key:0,repeatCount:0,loopMode:Z.loopMode};j=Z._interpolate(x,w),JM._SetInterpolatedValue(M,j,U,Z,P,B,K,d,H)}}L&&(O.max=L)}static _ConvertFactorToVector3OrQuaternion(M,Z,P,w,v){const G=JM._GetBasePositionRotationOrScale(Z,w,v),mM=P.targetProperty.split("."),K=mM?mM[1]:"",d=v?x.Quaternion.NZ(G).normalize():x.BZ.NZ(G);switch(K){case"x":case"y":case"z":d[K]=M;break;case"w":d.w=M;break;default:c.Tools.Error(`glTFAnimation: Unsupported component name "${K}"!`)}return d}static _SetInterpolatedValue(M,Z,P,c,w,v,G,mM,K){let d;G.push(P),"weights"!==w?(c.dataType===nM.d.ANIMATIONTYPE_FLOAT&&(Z=this._ConvertFactorToVector3OrQuaternion(Z,M,c,w,K)),"rotation"===w?(K?v=Z:(d=Z,x.Quaternion.RotationYawPitchRollToRef(d.y,d.x,d.z,v)),mM.push(v.nc())):(d=Z,mM.push(d.nc()))):mM.push([Z])}static _CreateLinearOrStepAnimation(M,Z,P,x,c,w){for(const v of Z.getKeys())x.push(v.frame/Z.framePerSecond),JM._AddKeyframeValue(v,Z,c,P,M,w)}static _CreateCubicSplineAnimation(M,Z,P,x,c,w){Z.getKeys().forEach((function(v){x.push(v.frame/Z.framePerSecond),JM._AddSplineTangent(OM.INTANGENT,c,P,"CUBICSPLINE",v,w),JM._AddKeyframeValue(v,Z,c,P,M,w),JM._AddSplineTangent(OM.OUTTANGENT,c,P,"CUBICSPLINE",v,w)}))}static _GetBasePositionRotationOrScale(M,Z,P){let c;if("rotation"===Z)if(P){c=(M.rotationQuaternion??x.Quaternion.Identity()).nc()}else{c=(M.rotation??x.BZ.Zero()).nc()}else if("translation"===Z){c=(M.position??x.BZ.Zero()).nc()}else{c=(M.hc??x.BZ.One()).nc()}return c}static _AddKeyframeValue(M,Z,P,w,v,G){let mM;const K=Z.dataType;if(K===nM.d.ANIMATIONTYPE_VECTOR3){let Z=M.value.nc();if("rotation"===w){const M=x.BZ.NZ(Z);Z=x.Quaternion.RotationYawPitchRoll(M.y,M.x,M.z).nc()}P.push(Z)}else if(K===nM.d.ANIMATIONTYPE_FLOAT){if("weights"===w)P.push([M.value]);else if(mM=this._ConvertFactorToVector3OrQuaternion(M.value,v,Z,w,G),mM){if("rotation"===w){const M=G?mM:x.Quaternion.RotationYawPitchRoll(mM.y,mM.x,mM.z).normalize();P.push(M.nc())}P.push(mM.nc())}}else K===nM.d.ANIMATIONTYPE_QUATERNION?P.push(M.value.normalize().nc()):c.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(M,Z,P){let x,c,w=!1;if("rotation"===Z&&!P)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let v=0,G=M.length;v<G;++v)if(c=M[v],c.inTangent||c.outTangent)if(x){if("CUBICSPLINE"!==x){x="LINEAR",w=!0;break}}else x="CUBICSPLINE";else if(x){if("CUBICSPLINE"===x||c.interpolation&&1===c.interpolation&&"STEP"!==x){x="LINEAR",w=!0;break}}else x=c.interpolation&&1===c.interpolation?"STEP":"LINEAR";return x||(x="LINEAR"),{interpolationType:x,shouldBakeAnimation:w}}static _AddSplineTangent(M,Z,P,c,w,v){let G;const mM=M===OM.INTANGENT?w.inTangent:w.outTangent;if("CUBICSPLINE"===c){if("rotation"===P)if(mM)if(v)G=mM.nc();else{const M=mM;G=x.Quaternion.RotationYawPitchRoll(M.y,M.x,M.z).nc()}else G=[0,0,0,0];else G="weights"===P?mM?[mM]:[0]:mM?mM.nc():[0,0,0];Z.push(G)}}static _CalculateMinMaxKeyFrames(M){let Z=1/0,P=-1/0;return M.forEach((function(M){Z=Math.min(Z,M.frame),P=Math.max(P,M.frame)})),{min:Z,max:P}}}function tM(M,Z,P,w,v,G){const mM={attributes:{},influence:M.influence,name:M.name},K=Z.tc;if(!K)return c.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),mM;const O=G?-1:1,H=x.BZ.Zero();let j=0,B=0;if(M.hasPositions){const w=M.getPositions(),G=K.getVerticesData(d.g.PositionKind);if(G){const M=new Float32Array(G.length),Z=[1/0,1/0,1/0],c=[-1/0,-1/0,-1/0];B=G.length/3,j=0;for(let P=j;P<B;++P){const v=x.BZ.NZ(G,3*P);x.BZ.NZ(w,3*P).subtractToRef(v,H),H.x*=O,Z[0]=Math.min(Z[0],H.x),c[0]=Math.max(c[0],H.x),Z[1]=Math.min(Z[1],H.y),c[1]=Math.max(c[1],H.y),Z[2]=Math.min(Z[2],H.z),c[2]=Math.max(c[2],H.z),M[3*P]=H.x,M[3*P+1]=H.y,M[3*P+2]=H.z}const K=P.createBufferView(M,12),d=P.createAccessor(K,"VEC3",5126,w.length/3,0,{min:Z,max:c});v.push(d),mM.attributes.POSITION=v.length-1}else c.Tools.Warn(`Morph target positions for mesh ${Z.name} were not exported. Mesh does not have position vertex data`)}if(M.hasNormals){const w=M.getNormals(),G=K.getVerticesData(d.g.NormalKind);if(G){const M=new Float32Array(G.length);B=G.length/3,j=0;for(let P=j;P<B;++P){const Z=x.BZ.NZ(G,3*P).normalize();x.BZ.NZ(w,3*P).normalize().subtractToRef(Z,H),M[3*P]=H.x*O,M[3*P+1]=H.y,M[3*P+2]=H.z}const Z=P.createBufferView(M,12),c=P.createAccessor(Z,"VEC3",5126,w.length/3,0);v.push(c),mM.attributes.NORMAL=v.length-1}else c.Tools.Warn(`Morph target normals for mesh ${Z.name} were not exported. Mesh does not have normals vertex data`)}if(M.hasTangents){const w=M.getTangents(),G=K.getVerticesData(d.g.TangentKind);if(G){B=G.length/4;const M=new Float32Array(3*B);j=0;for(let P=j;P<B;++P){const Z=x.BZ.NZ(G,4*P);S(Z);const c=x.BZ.NZ(w,3*P);S(c),c.subtractToRef(Z,H),M[3*P]=H.x*O,M[3*P+1]=H.y,M[3*P+2]=H.z}const Z=P.createBufferView(M,12),c=P.createAccessor(Z,"VEC3",5126,B,0);v.push(c),mM.attributes.TANGENT=v.length-1}else c.Tools.Warn(`Morph target tangents for mesh ${Z.name} were not exported. Mesh does not have tangents vertex data`)}if(M.hasColors){const w=M.getColors(),G=K.getVerticesData(d.g.ColorKind),O=K.getVertexBuffer(d.g.ColorKind);if(G&&O){const M=O.getSize();B=G.length/M;const Z=new Float32Array(B*M);j=0;for(let P=j;P<B;++P)if(3===M){const c=x.BZ.NZ(G,P*M);x.BZ.NZ(w,P*M).subtractToRef(c,H),Z[3*P]=H.x,Z[3*P+1]=H.y,Z[3*P+2]=H.z}else if(4===M){const c=new x.Vector4,v=x.Vector4.NZ(G,P*M);x.Vector4.NZ(w,P*M).subtractToRef(v,c),Z[4*P]=c.x,Z[4*P+1]=c.y,Z[4*P+2]=c.z,Z[4*P+3]=c.w}else c.Tools.Warn(`Unsupported number of components for color attribute: ${M}`);const K=P.createBufferView(Z,4*M),d=P.createAccessor(K,3===M?"VEC3":"VEC4",5126,B,0);v.push(d),mM.attributes.COLOR_0=v.length-1}else c.Tools.Warn(`Morph target colors for mesh ${Z.name} were not exported. Mesh does not have colors vertex data`)}return mM}var FM=P(12909),DM=P(12775),lM=P(12759),hM=P(12317);class QM{}QM.DEFAULT_COLOR=n.uZ.White(),QM.DEFAULT_WIDTH_ATTENUATED=1,QM.DEFAULT_WIDTH=.1;var IM=P(12570),sM=P(12916);class CM{static ConvertPoints(M,Z){if(M.length&&Array.isArray(M)&&"number"===typeof M[0])return[M];if(M.length&&Array.isArray(M[0])&&"number"===typeof M[0][0])return M;if(M.length&&!Array.isArray(M[0])&&M[0]instanceof x.BZ){const Z=[];for(let P=0;P<M.length;P++){const x=M[P];Z.push(x.x,x.y,x.z)}return[Z]}if(M.length>0&&Array.isArray(M[0])&&M[0].length>0&&M[0][0]instanceof x.BZ){const Z=[],P=M;for(const M of P)Z.push(M.flatMap((M=>[M.x,M.y,M.z])));return Z}if(M instanceof Float32Array){if(null!==Z&&void 0!==Z&&Z.floatArrayStride){const P=[],x=3*Z.floatArrayStride;for(let Z=0;Z<M.length;Z+=x){const c=new Array(x);for(let P=0;P<x;P++)c[P]=M[Z+P];P.push(c)}return P}return[Array.from(M)]}if(M.length&&M[0]instanceof Float32Array){const Z=[];for(const P of M)Z.push(Array.from(P));return Z}return[]}static OmitZeroLengthPredicate(M,Z,P){const x=[];return Z.UZ(M).lengthSquared()>0&&x.push([M,Z]),P.UZ(Z).lengthSquared()>0&&x.push([Z,P]),M.UZ(P).lengthSquared()>0&&x.push([P,M]),0===x.length?null:x}static OmitDuplicatesPredicate(M,Z,P,x){const c=[];return CM._SearchInPoints(M,Z,x)||c.push([M,Z]),CM._SearchInPoints(Z,P,x)||c.push([Z,P]),CM._SearchInPoints(P,M,x)||c.push([P,M]),0===c.length?null:c}static _SearchInPoints(M,Z,P){for(const v of P)for(let P=0;P<v.length;P++){var x,c,w;if(null!==(x=v[P])&&void 0!==x&&x.equals(M))if(null!==(c=v[P+1])&&void 0!==c&&c.equals(Z)||null!==(w=v[P-1])&&void 0!==w&&w.equals(Z))return!0}return!1}static MeshesToLines(M,Z){const P=[];for(let c=0;c<M.length;c++){const w=M[c],v=w.getVerticesData(d.g.PositionKind),G=w.Fc();if(v&&G)for(let M=0,mM=0;M<G.length;M++){const K=3*G[mM++],d=3*G[mM++],O=3*G[mM++],H=new x.BZ(v[K],v[K+1],v[K+2]),j=new x.BZ(v[d],v[d+1],v[d+2]),B=new x.BZ(v[O],v[O+1],v[O+2]);if(Z){const x=Z(H,j,B,P,M,K,w,c,v,G);if(x)for(const M of x)P.push(M)}else P.push([H,j],[j,B],[B,H])}}return P}static ToVector3Array(M){if(Array.isArray(M[0])){const Z=[],P=M;for(const M of P){const P=[];for(let Z=0;Z<M.length;Z+=3)P.push(new x.BZ(M[Z],M[Z+1],M[Z+2]));Z.push(P)}return Z}const Z=M,P=[];for(let c=0;c<Z.length;c+=3)P.push(new x.BZ(Z[c],Z[c+1],Z[c+2]));return P}static ToNumberArray(M){return M.flatMap((M=>[M.x,M.y,M.z]))}static GetPointsCountInfo(M){const Z=new Array(M.length);let P=0;for(let x=M.length;x--;)Z[x]=M[x].length/3,P+=Z[x];return{total:P,counts:Z}}static GetLineLength(M){if(0===M.length)return 0;let Z;Z="number"===typeof M[0]?CM.ToVector3Array(M):M;const P=x.TmpVectors.BZ[0];let c=0;for(let x=0;x<Z.length-1;x++){const M=Z[x];c+=Z[x+1].subtractToRef(M,P).length()}return c}static GetLineLengthArray(M){const Z=new Float32Array(M.length/3);let P=0;for(let x=0,c=M.length/3-1;x<c;x++){let c=M[3*x+0],w=M[3*x+1],v=M[3*x+2];c-=M[3*x+3],w-=M[3*x+4],v-=M[3*x+5];P+=Math.sqrt(c*c+w*w+v*v),Z[x+1]=P}return Z}static SegmentizeSegmentByCount(M,Z,P){const c=[],w=Z.UZ(M),v=x.TmpVectors.BZ[0];v.Qc(P);const G=x.TmpVectors.BZ[1];w.divideToRef(v,G);let mM=M.clone();c.push(mM);for(let x=0;x<P;x++)mM=mM.clone(),c.push(mM.addInPlace(G));return c}static SegmentizeLineBySegmentLength(M,Z){const P=M[0]instanceof x.BZ?CM.GetLineSegments(M):"number"===typeof M[0]?CM.GetLineSegments(CM.ToVector3Array(M)):M,c=[];for(const x of P)if(x.length>Z){const M=CM.SegmentizeSegmentByCount(x.point1,x.point2,Math.ceil(x.length/Z));for(const Z of M)c.push(Z)}else c.push(x.point1),c.push(x.point2);return c}static SegmentizeLineBySegmentCount(M,Z){const P="number"===typeof M[0]?CM.ToVector3Array(M):M,x=CM.GetLineLength(P)/Z;return CM.SegmentizeLineBySegmentLength(P,x)}static GetLineSegments(M){const Z=[];for(let P=0;P<M.length-1;P++){const x=M[P],c=M[P+1],w=c.UZ(x).length();Z.push({point1:x,point2:c,length:w})}return Z}static GetMinMaxSegmentLength(M){const Z=CM.GetLineSegments(M).sort((M=>M.length));return{min:Z[0].length,max:Z[Z.length-1].length}}static GetPositionOnLineByVisibility(M,Z,P){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const w=Z*P;let v=0,G=0;const mM=M.length;for(let x=0;x<mM;x++){if(w<=v+M[x].length){G=x;break}v+=M[x].length}const K=(w-v)/M[G].length;return M[G].point2.subtractToRef(M[G].point1,x.TmpVectors.BZ[0]),x.TmpVectors.BZ[1]=x.TmpVectors.BZ[0].multiplyByFloats(K,K,K),c||x.TmpVectors.BZ[1].addInPlace(M[G].point1),x.TmpVectors.BZ[1].clone()}static GetCircleLinePoints(M,Z){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:M,w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/Z;const v=[];for(let G=0;G<=Z;G++)v.push(new x.BZ(Math.cos(G*w)*M,Math.sin(G*w)*c,P));return v}static GetBezierLinePoints(M,Z,P,x){return IM.e.CreateQuadraticBezier(M,Z,P,x).getPoints().flatMap((M=>[M.x,M.y,M.z]))}static GetArrowCap(M,Z,P,x,c){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,v=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[M.clone(),M.add(Z.multiplyByFloats(P,P,P))],widths:[x,c,w,v]}}static GetPointsFromText(M,Z,P,x){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,w=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const v=[],G=(0,sM.d)(M,Z,P,x);for(const mM of G){for(const M of mM.paths){const Z=[],P=M.getPoints();for(const M of P)Z.push(M.x,M.y,c);v.push(Z)}if(w)for(const M of mM.holes){const Z=[],P=M.getPoints();for(const M of P)Z.push(M.x,M.y,c);v.push(Z)}}return v}static Color3toRGBAUint8(M){const Z=new Uint8Array(4*M.length);for(let P=0,x=0;P<M.length;P++)Z[x++]=255*M[P].r,Z[x++]=255*M[P].g,Z[x++]=255*M[P].b,Z[x++]=255;return Z}static CreateColorsTexture(M,Z,P,x){const c=x.getEngine().getCaps().maxTextureSize??1,w=Z.length>c?c:Z.length,v=Math.ceil(Z.length/c);v>1&&(Z=[...Z,...Array(w*v-Z.length).fill(Z[0])]);const G=CM.Color3toRGBAUint8(Z),mM=new F.e(G,w,v,B.d.TEXTUREFORMAT_RGBA,x,!1,!0,P);return mM.name=M,mM}static PrepareEmptyColorsTexture(M){if(!QM.EmptyColorsTexture){const Z=new Uint8Array(4);QM.EmptyColorsTexture=new F.e(Z,1,1,B.d.TEXTUREFORMAT_RGBA,M,!1,!1,F.e.NEAREST_NEAREST),QM.EmptyColorsTexture.name="grlEmptyColorsTexture"}return QM.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var M;null===(M=QM.EmptyColorsTexture)||void 0===M||M.dispose(),QM.EmptyColorsTexture=null}static BooleanToNumber(M){return M?1:0}}class RM extends lM.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class WM extends DM.b{isCompatible(M){return!0}constructor(M,Z,P){var c;P=P||{color:QM.DEFAULT_COLOR};const w=new RM;w.GREASED_LINE_HAS_COLOR=!!P.color&&!P.useColors,w.GREASED_LINE_SIZE_ATTENUATION=P.sizeAttenuation??!1,w.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===P.colorDistributionType,w.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(Z??M.DM()).useRightHandedSystem,w.GREASED_LINE_CAMERA_FACING=P.cameraFacing??!0,super(M,WM.GREASED_LINE_MATERIAL_NAME,200,w,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(c=P)||void 0===c?void 0:c.forceGLSL)||WM.ForceGLSL,this._scene=Z??M.DM(),this._engine=this._scene.getEngine(),this._cameraFacing=P.cameraFacing??!0,this.visibility=P.visibility??1,this.useDash=P.useDash??!1,this.dashRatio=P.dashRatio??.5,this.dashOffset=P.dashOffset??0,this.width=P.width?P.width:P.sizeAttenuation?QM.DEFAULT_WIDTH_ATTENUATED:QM.DEFAULT_WIDTH,this._sizeAttenuation=P.sizeAttenuation??!1,this.colorMode=P.colorMode??0,this._color=P.color??null,this.useColors=P.useColors??!1,this._colorsDistributionType=P.colorDistributionType??0,this.colorsSampling=P.colorsSampling??F.e.NEAREST_NEAREST,this._colors=P.IM??null,this.dashCount=P.dashCount??1,this.resolution=P.resolution??new x.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),P.colorsTexture?this.colorsTexture=P.colorsTexture:this._colors?this.colorsTexture=CM.CreateColorsTexture(`${M.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??QM.DEFAULT_COLOR,CM.PrepareEmptyColorsTexture(this._scene)),this._engine.Gc.add((()=>{CM.DisposeEmptyColorsTexture()}))}getAttributes(M){M.push("grl_offsets"),M.push("grl_widths"),M.push("grl_colorPointers"),M.push("grl_counters"),this._cameraFacing?(M.push("grl_previousAndSide"),M.push("grl_nextAndCounters")):M.push("grl_slopes")}getSamplers(M){M.push("grl_colors")}getActiveTextures(M){this.colorsTexture&&M.push(this.colorsTexture)}getUniforms(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const Z=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&Z.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===M&&Z.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:Z,vertex:this._cameraFacing&&this._isGLSL(M)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(M)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(M){if(this._cameraFacing){M.Nc("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||M.Nc("viewProjection",this._scene.getTransformMatrix());const Z=x.TmpVectors.Vector4[0];Z.x=this._aspect,Z.y=this._resolution.x,Z.z=this._resolution.y,Z.w=this.width,M.updateVector4("grl_aspect_resolution_lineWidth",Z)}const Z=x.TmpVectors.Vector4[0];Z.x=CM.BooleanToNumber(this.useDash),Z.y=this._dashArray,Z.z=this.dashOffset,Z.w=this.dashRatio,M.updateVector4("grl_dashOptions",Z);const P=x.TmpVectors.Vector4[1];P.x=this.colorMode,P.y=this.visibility,P.z=this.colorsTexture?this.colorsTexture.getSize().width:0,P.w=CM.BooleanToNumber(this.useColors),M.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",P),this._color&&M.updateColor3("grl_singleColor",this._color);const c=this.colorsTexture??QM.EmptyColorsTexture;M.setTexture("grl_colors",c),M.updateFloat2("grl_textureSize",(null===c||void 0===c?void 0:c.getSize().width)??1,(null===c||void 0===c?void 0:c.getSize().height)??1)}prepareDefines(M,Z,P){M.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,M.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,M.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,M.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=Z.useRightHandedSystem,M.GREASED_LINE_CAMERA_FACING=this._cameraFacing,M.GREASED_LINE_USE_OFFSETS=!!P.offsets}getClassName(){return WM.GREASED_LINE_MATERIAL_NAME}getCustomCode(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(Z)?function(M,Z){if("vertex"===M){const M={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return Z&&(M["!gl_Position\\=viewProjection\\*worldPos;"]="//"),M}return"fragment"===M?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(M,this._cameraFacing):function(M,Z){if("vertex"===M){const M={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return Z&&(M["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),M}return"fragment"===M?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(M,this._cameraFacing)}dispose(){var M;null===(M=this.colorsTexture)||void 0===M||M.dispose(),super.dispose()}get IM(){return this._colors}set IM(M){this.setColors(M)}setColors(M){var Z;let P=arguments.length>1&&void 0!==arguments[1]&&arguments[1],x=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const c=(null===(Z=this._colors)||void 0===Z?void 0:Z.length)??0;var w;if(this._colors=M,null!==M&&0!==M.length){if(!P||x)if(this.colorsTexture&&c===M.length&&!x){const Z=CM.Color3toRGBAUint8(M);this.colorsTexture.update(Z)}else{var v;null===(v=this.colorsTexture)||void 0===v||v.dispose(),this.colorsTexture=CM.CreateColorsTexture(`${this._material.name}-colors-texture`,M,this.colorsSampling,this._scene)}}else null===(w=this.colorsTexture)||void 0===w||w.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(M){this._dashCount=M,this._dashArray=1/M}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(M){this._sizeAttenuation=M,this.markAllDefinesAsDirty()}get color(){return this._color}set color(M){this.setColor(M)}setColor(M){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==M||null!==this._color&&null===M?(this._color=M,Z||this.markAllDefinesAsDirty()):this._color=M}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(M){this._colorsDistributionType=M,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(M){this._aspect=M.x/M.y,this._resolution=M}serialize(){const M=super.serialize(),Z={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(Z.IM=this._colors),this._color&&(Z.color=this._color),M.greasedLineMaterialOptions=Z,M}parse(M,Z,P){var x;super.parse(M,Z,P);const c=M.greasedLineMaterialOptions;null===(x=this.colorsTexture)||void 0===x||x.dispose(),c.color&&this.setColor(c.color,!0),c.colorDistributionType&&(this.colorsDistributionType=c.colorDistributionType),c.IM&&(this.IM=c.IM),c.colorsSampling&&(this.colorsSampling=c.colorsSampling),c.colorMode&&(this.colorMode=c.colorMode),c.useColors&&(this.useColors=c.useColors),c.visibility&&(this.visibility=c.visibility),c.useDash&&(this.useDash=c.useDash),c.dashCount&&(this.dashCount=c.dashCount),c.dashRatio&&(this.dashRatio=c.dashRatio),c.dashOffset&&(this.dashOffset=c.dashOffset),c.width&&(this.width=c.width),c.sizeAttenuation&&(this.sizeAttenuation=c.sizeAttenuation),c.resolution&&(this.resolution=c.resolution),this.IM?this.colorsTexture=CM.CreateColorsTexture(`${this._material.name}-colors-texture`,this.IM,this.colorsSampling,Z):CM.PrepareEmptyColorsTexture(Z),this.markAllDefinesAsDirty()}copyTo(M){var Z;const P=M;null===(Z=P.colorsTexture)||void 0===Z||Z.dispose(),this._colors&&(P.colorsTexture=CM.CreateColorsTexture(`${P._material.name}-colors-texture`,this._colors,P.colorsSampling,this._scene)),P.setColor(this.color,!0),P.colorsDistributionType=this.colorsDistributionType,P.colorsSampling=this.colorsSampling,P.colorMode=this.colorMode,P.useColors=this.useColors,P.visibility=this.visibility,P.useDash=this.useDash,P.dashCount=this.dashCount,P.dashRatio=this.dashRatio,P.dashOffset=this.dashOffset,P.width=this.width,P.sizeAttenuation=this.sizeAttenuation,P.resolution=this.resolution,P.markAllDefinesAsDirty()}_isGLSL(M){return 0===M||this._forceGLSL}}WM.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",WM.ForceGLSL=!1,(0,hM.g)(`BABYLON.${WM.GREASED_LINE_MATERIAL_NAME}`,WM);var kM=P(12805),AM=P(12207),oM=P(12587),EM=P(12296);class rM extends oM.ShaderMaterial{constructor(M,Z,c){const w=Z.getEngine(),v=w.isWebGPU&&!(c.forceGLSL||rM.ForceGLSL),G=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];Z.useRightHandedSystem&&G.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const mM=["position","grl_widths","grl_offsets","grl_colorPointers"];c.cameraFacing?(G.push("GREASED_LINE_CAMERA_FACING"),mM.push("grl_previousAndSide","grl_nextAndCounters")):(mM.push("grl_slopes"),mM.push("grl_counters"));const K=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(v||K.push("world","viewProjection","view","projection"),super(M,Z,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:v?["Scene","Mesh"]:void 0,attributes:mM,uniforms:K,samplers:v?[]:["grlColors"],defines:G,extraInitializationsAsync:async()=>{v?await Promise.all([P.e(66).then(P.bind(P,15522)),P.e(75).then(P.bind(P,15524))]):await Promise.all([P.e(69).then(P.bind(P,15530)),P.e(76).then(P.bind(P,15536))])},shaderLanguage:v?1:0}),this._color=n.uZ.White(),this._colorsDistributionType=0,this._colorsTexture=null,c=c||{color:QM.DEFAULT_COLOR},this.visibility=c.visibility??1,this.useDash=c.useDash??!1,this.dashRatio=c.dashRatio??.5,this.dashOffset=c.dashOffset??0,this.dashCount=c.dashCount??1,this.width=c.width?c.width:c.sizeAttenuation&&c.cameraFacing?QM.DEFAULT_WIDTH_ATTENUATED:QM.DEFAULT_WIDTH,this.sizeAttenuation=c.sizeAttenuation??!1,this.color=c.color??n.uZ.White(),this.useColors=c.useColors??!1,this.colorsDistributionType=c.colorDistributionType??0,this.colorsSampling=c.colorsSampling??F.e.NEAREST_NEAREST,this.colorMode=c.colorMode??0,this._colors=c.IM??null,this._cameraFacing=c.cameraFacing??!0,this.resolution=c.resolution??new x.Vector2(w.getRenderWidth(),w.getRenderHeight()),c.colorsTexture?this.colorsTexture=c.colorsTexture:this._colors?this.colorsTexture=CM.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,Z):(this._color=this._color??QM.DEFAULT_COLOR,this.colorsTexture=CM.PrepareEmptyColorsTexture(Z)),v){const M=new EM.e;M.setParameters(),M.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",M)}w.Gc.add((()=>{CM.DisposeEmptyColorsTexture()}))}dispose(){var M;null===(M=this._colorsTexture)||void 0===M||M.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new x.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get IM(){return this._colors}set IM(M){this.setColors(M)}setColors(M){var Z;let P=arguments.length>1&&void 0!==arguments[1]&&arguments[1],x=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const c=(null===(Z=this._colors)||void 0===Z?void 0:Z.length)??0;var w;if(this._colors=M,null!==M&&0!==M.length){if(!P||x)if(this._colorsTexture&&c===M.length&&!x){const Z=CM.Color3toRGBAUint8(M);this._colorsTexture.update(Z)}else{var v;null===(v=this._colorsTexture)||void 0===v||v.dispose(),this.colorsTexture=CM.CreateColorsTexture(`${this.name}-colors-texture`,M,this.colorsSampling,this.DM())}}else null===(w=this._colorsTexture)||void 0===w||w.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(M){this._colorsTexture=M,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(M){this._width=M,this.setFloat("grlWidth",M)}get useColors(){return this._useColors}set useColors(M){this._useColors=M,this.setFloat("grlUseColors",CM.BooleanToNumber(M))}get colorsSampling(){return this._colorsSampling}set colorsSampling(M){this._colorsSampling=M}get visibility(){return this._visibility}set visibility(M){this._visibility=M,this.setFloat("grlVisibility",M)}get useDash(){return this._useDash}set useDash(M){this._useDash=M,this.setFloat("grlUseDash",CM.BooleanToNumber(M))}get dashOffset(){return this._dashOffset}set dashOffset(M){this._dashOffset=M,this.setFloat("grlDashOffset",M)}get dashRatio(){return this._dashRatio}set dashRatio(M){this._dashRatio=M,this.setFloat("grlDashRatio",M)}get dashCount(){return this._dashCount}set dashCount(M){this._dashCount=M,this._dashArray=1/M,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(M){this._sizeAttenuation=M,this.setFloat("grlSizeAttenuation",CM.BooleanToNumber(M))}get color(){return this._color}set color(M){this.setColor(M)}setColor(M){M=M??QM.DEFAULT_COLOR,this._color=M,this.setColor3("grlColor",M)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(M){this._colorsDistributionType=M,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(M){this._colorMode=M,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(M){this._resolution=M,this.setVector2("grlResolution",M),this.setFloat("grlAspect",M.x/M.y)}serialize(){const M=super.serialize(),Z={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(Z.IM=this._colors),M.greasedLineMaterialOptions=Z,M}parse(M,Z,P){var x;const c=M.greasedLineMaterialOptions;null===(x=this._colorsTexture)||void 0===x||x.dispose(),c.color&&(this.color=c.color),c.colorDistributionType&&(this.colorsDistributionType=c.colorDistributionType),c.colorsSampling&&(this.colorsSampling=c.colorsSampling),c.colorMode&&(this.colorMode=c.colorMode),c.useColors&&(this.useColors=c.useColors),c.visibility&&(this.visibility=c.visibility),c.useDash&&(this.useDash=c.useDash),c.dashCount&&(this.dashCount=c.dashCount),c.dashRatio&&(this.dashRatio=c.dashRatio),c.dashOffset&&(this.dashOffset=c.dashOffset),c.width&&(this.width=c.width),c.sizeAttenuation&&(this.sizeAttenuation=c.sizeAttenuation),c.resolution&&(this.resolution=c.resolution),c.IM?this.colorsTexture=CM.CreateColorsTexture(`${this.name}-colors-texture`,c.IM,this.colorsSampling,this.DM()):this.colorsTexture=CM.PrepareEmptyColorsTexture(Z),this._cameraFacing=c.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var qM,eM,bM;rM.ForceGLSL=!1,function(M){M[M.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",M[M.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(qM||(qM={})),function(M){M[M.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",M[M.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",M[M.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(eM||(eM={})),function(M){M[M.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",M[M.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",M[M.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",M[M.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",M[M.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(bM||(bM={}));class aM extends uM.c{constructor(M,Z,P){super(M,Z,null,null,!1,!1),this.name=M,this._options=P,this._lazy=!1,this._updatable=!1,this._engine=Z.getEngine(),this._lazy=P.lazy??!1,this._updatable=P.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=P.colorPointers??[],this._widths=P.widths??new Array(P.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(M){let Z=0;for(const x of this._points)Z+=x.length;const P=Z/3*2-this._widths.length;for(let x=0;x<P;x++)this._widths.push(M)}updateLazy(){var M,Z;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(M=this._options.ribbonOptions)||void 0===M?void 0:M.smoothShading),!this.WM&&this.refreshBoundingInfo(),null===(Z=this.greasedLineMaterial)||void 0===Z||Z.updateLazy()}addPoints(M,Z){for(const P of M)this._points.push(P);this._lazy||this.setPoints(this._points,Z)}dispose(M){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(M,Z)}isLazy(){return this._lazy}get sM(){return this._uvs}set sM(M){this._uvs=M instanceof Float32Array?M:new Float32Array(M),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(M){this.material instanceof rM&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===M||void 0===M?void 0:M.length)>0),this._offsets=M,this._offsetsBuffer?this._offsetsBuffer.update(M):this._createOffsetsBuffer(M)}get widths(){return this._widths}set widths(M){this._widths=M,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(M)}get colorPointers(){return this._colorPointers}set colorPointers(M){this._colorPointers=M,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(M)}get greasedLineMaterial(){var M,Z;if(this.material&&this.material instanceof rM)return this.material;const P=null===(M=this.material)||void 0===M||null===(Z=M.pluginManager)||void 0===Z?void 0:Z.getPlugin(WM.GREASED_LINE_MATERIAL_NAME);return P||void 0}get points(){const M=[];return AM.c.DeepCopy(this._points,M),M}setPoints(M,Z){this._points=CM.ConvertPoints(M,(null===Z||void 0===Z?void 0:Z.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==Z&&void 0!==Z&&Z.colorPointers||this._updateColorPointers(),this._setPoints(this._points,Z)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,sM:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(M){super.serialize(M),M.type=this.getClassName(),M.lineOptions=this._createLineOptions()}_createVertexBuffers(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Z=new kM.b;return Z.hM=this._vertexPositions,Z.indices=this._indices,Z.sM=this._uvs,M&&(Z.QM=[],kM.b.ComputeNormals(this._vertexPositions,this._indices,Z.QM)),Z.RM(this,this._options.updatable),Z}_createOffsetsBuffer(M){const Z=this._scene.getEngine(),P=new d.c(Z,M,this._updatable,3);this.setVerticesBuffer(P.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=P}}class yM{constructor(M,Z){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=M,this.wasAddedByNoopNode=Z}getIndicesAccessor(M,Z,P,x,c){var w,v,G,mM;return null===(w=this._indicesAccessorMap.get(M))||void 0===w||null===(v=w.get(Z))||void 0===v||null===(G=v.get(P))||void 0===G||null===(mM=G.get(x))||void 0===mM?void 0:mM.get(c)}setIndicesAccessor(M,Z,P,x,c,w){let v=this._indicesAccessorMap.get(M);v||(v=new Map,this._indicesAccessorMap.set(M,v));let G=v.get(Z);G||(G=new Map,v.set(Z,G));let mM=G.get(P);mM||(mM=new Map,G.set(P,mM));let K=mM.get(x);K||(K=new Map,mM.set(x,K)),K.set(c,w)}pushExportedNode(M){this._exportedNodes.has(M)||this._exportedNodes.add(M)}getNodesSet(){return this._exportedNodes}getVertexBufferView(M){return this._vertexBufferViewMap.get(M)}setVertexBufferView(M,Z){this._vertexBufferViewMap.set(M,Z)}setRemappedBufferView(M,Z,P){this._remappedBufferView.set(M,new Map),this._remappedBufferView.get(M).set(Z,P)}getRemappedBufferView(M,Z){var P;return null===(P=this._remappedBufferView.get(M))||void 0===P?void 0:P.get(Z)}getVertexAccessor(M,Z,P){var x,c;return null===(x=this._vertexAccessorMap.get(M))||void 0===x||null===(c=x.get(Z))||void 0===c?void 0:c.get(P)}setVertexAccessor(M,Z,P,x){let c=this._vertexAccessorMap.get(M);c||(c=new Map,this._vertexAccessorMap.set(M,c));let w=c.get(Z);w||(w=new Map,c.set(Z,w)),w.set(P,x)}hasVertexColorAlpha(M){return this._vertexMapColorAlpha.get(M)||!1}setHasVertexColorAlpha(M,Z){return this._vertexMapColorAlpha.set(M,Z)}getMesh(M){return this._meshMap.get(M)}setMesh(M,Z){this._meshMap.set(M,Z)}bindMorphDataToMesh(M,Z){const P=this._meshMorphTargetMap.get(M)||[];this._meshMorphTargetMap.set(M,P),-1===P.indexOf(Z)&&P.push(Z)}getMorphTargetsFromMesh(M){return this._meshMorphTargetMap.get(M)}}class fM{_ApplyExtension(M,Z,P,x){if(P>=Z.length)return Promise.resolve(M);const c=x(Z[P],M);return c?c.then((async M=>M?await this._ApplyExtension(M,Z,P+1,x):null)):this._ApplyExtension(M,Z,P+1,x)}_ApplyExtensions(M,Z){const P=[];for(const x of fM._ExtensionNames)P.push(this._extensions[x]);return this._ApplyExtension(M,P,0,Z)}_extensionsPreExportTextureAsync(M,Z,P){return this._ApplyExtensions(Z,((Z,x)=>Z.preExportTextureAsync&&Z.preExportTextureAsync(M,x,P)))}_extensionsPostExportNodeAsync(M,Z,P,x,c){return this._ApplyExtensions(Z,((Z,w)=>Z.postExportNodeAsync&&Z.postExportNodeAsync(M,w,P,x,c,this._bufferManager)))}_extensionsPostExportMaterialAsync(M,Z,P){return this._ApplyExtensions(Z,((Z,x)=>Z.postExportMaterialAsync&&Z.postExportMaterialAsync(M,x,P)))}_extensionsPostExportMaterialAdditionalTextures(M,Z,P){const x=[];for(const c of fM._ExtensionNames){const w=this._extensions[c];w.postExportMaterialAdditionalTextures&&x.push(...w.postExportMaterialAdditionalTextures(M,Z,P))}return x}_extensionsPostExportTextures(M,Z,P){for(const x of fM._ExtensionNames){const c=this._extensions[x];c.postExportTexture&&c.postExportTexture(M,Z,P)}}_extensionsPostExportMeshPrimitive(M){for(const Z of fM._ExtensionNames){const P=this._extensions[Z];P.postExportMeshPrimitive&&P.postExportMeshPrimitive(M,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const M of fM._ExtensionNames){const Z=this._extensions[M];Z.preGenerateBinaryAsync&&await Z.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(M){for(const Z of fM._ExtensionNames){const P=this._extensions[Z];P.enabled&&M(P)}}_extensionsOnExporting(){this._forEachExtensions((M=>{var Z,P,x;M.wasUsed&&((Z=this._glTF).extensionsUsed||(Z.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(M.name)&&this._glTF.extensionsUsed.push(M.name),M.required&&((P=this._glTF).extensionsRequired||(P.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(M.name)&&this._glTF.extensionsRequired.push(M.name)),(x=this._glTF).extensions||(x.extensions={}),M.onExporting&&M.onExporting())}))}_loadExtensions(){for(const M of fM._ExtensionNames){const Z=fM._ExtensionFactories[M](this);this._extensions[M]=Z}}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:U.b.LastCreatedScene,Z=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${B.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new E(this),this._extensions={},this._bufferManager=new dM,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!M)throw new Error("No scene available to export");this._babylonScene=M,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:M=>{var Z;return null===M||void 0===M||null===(Z=M.jc)||void 0===Z?void 0:Z.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...Z},this._loadExtensions()}dispose(){for(const M in this._extensions){this._extensions[M].dispose()}}get options(){return this._options}static RegisterExtension(M,Z){fM.UnregisterExtension(M)&&c.Tools.Warn(`Extension with the name ${M} already exists`),fM._ExtensionFactories[M]=Z,fM._ExtensionNames.push(M)}static UnregisterExtension(M){if(!fM._ExtensionFactories[M])return!1;delete fM._ExtensionFactories[M];const Z=fM._ExtensionNames.indexOf(M);return-1!==Z&&fM._ExtensionNames.splice(Z,1),!0}_generateJSON(M,Z,P){const x={byteLength:M};return x.byteLength&&(this._glTF.buffers=[x]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.nZ=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(x.uri=Z+".bin"),P?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(M){const Z=await this._generateBinaryAsync();this._extensionsOnExporting();const P=this._generateJSON(Z.byteLength,M,!0),x=new Blob([Z],{type:"application/octet-stream"}),c=M+".gltf",w=M+".bin",v=new K;if(v.files[c]=P,v.files[w]=x,this._imageData)for(const G in this._imageData)v.files[G]=new Blob([this._imageData[G].data],{type:this._imageData[G].mimeType});return v}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(M){const Z=M%4;return 0===Z?Z:4-Z}async generateGLBAsync(M){this._shouldUseGlb=!0;const Z=await this._generateBinaryAsync();this._extensionsOnExporting();const P=this._generateJSON(Z.byteLength),x=M+".glb";let c,w=P.length;if("undefined"!==typeof TextEncoder){c=(new TextEncoder).encode(P),w=c.length}const v=this._getPadding(w),G=this._getPadding(Z.byteLength),mM=28+w+v+Z.byteLength+G,d=new mZ(mM);if(d.writeUInt32(1179937895),d.writeUInt32(2),d.writeUInt32(mM),d.writeUInt32(w+v),d.writeUInt32(1313821514),c)d.writeTypedArray(c);else{const M="_".charCodeAt(0);for(let Z=0;Z<w;++Z){const x=P.charCodeAt(Z);x!=P.codePointAt(Z)?d.writeUInt8(M):d.writeUInt8(x)}}for(let K=0;K<v;++K)d.writeUInt8(32);d.writeUInt32(Z.byteLength+G),d.writeUInt32(5130562),d.writeTypedArray(Z);for(let K=0;K<G;++K)d.writeUInt8(0);const O=new K;return O.files[x]=new Blob([d.getOutputData()],{type:"application/octet-stream"}),O}_setNodeTransformation(M,Z,P){if(Z.getPivotPoint().equalsWithEpsilon(a,b.c)||c.Tools.Warn("Pivot points are not supported in the glTF serializer"),!Z.position.equalsWithEpsilon(a,b.c)){const c=x.TmpVectors.BZ[0].v(Z.position);P&&X(c),M.translation=c.nc()}Z.hc.equalsWithEpsilon(f,b.c)||(M.scale=Z.hc.nc());const w=Z.rotationQuaternion||x.Quaternion.FromEulerAngles(Z.rotation.x,Z.rotation.y,Z.rotation.z);w.equalsWithEpsilon(y,b.c)||(P&&V(w),M.rotation=w.normalize().nc())}_setCameraTransformation(M,Z,P){if(!Z.position.equalsWithEpsilon(a,b.c)){const c=x.TmpVectors.BZ[0].v(Z.position);P&&X(c),M.translation=c.nc()}const c=Z.rotationQuaternion||x.Quaternion.FromEulerAngles(Z.rotation.x,Z.rotation.y,Z.rotation.z);P&&V(c),this._babylonScene.useRightHandedSystem||g(c),c.equalsWithEpsilon(y,b.c)||(M.rotation=c.nc())}_listAvailableCameras(){for(const M of this._babylonScene.cameras){const Z={type:M.mode===HM.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(M.name&&(Z.name=M.name),"perspective"===Z.type)Z.perspective={aspectRatio:M.getEngine().getAspectRatio(M),yfov:M.fovMode===HM.e.FOVMODE_VERTICAL_FIXED?M.fov:M.fov*M.getEngine().getAspectRatio(M),znear:M.uc,zfar:M.maxZ};else if("orthographic"===Z.type){const P=M.orthoLeft&&M.orthoRight?.5*(M.orthoRight-M.orthoLeft):.5*M.getEngine().getRenderWidth(),x=M.orthoBottom&&M.orthoTop?.5*(M.orthoTop-M.orthoBottom):.5*M.getEngine().getRenderHeight();Z.orthographic={xmag:P,ymag:x,znear:M.uc,zfar:M.maxZ}}this._camerasMap.set(M,Z)}}_exportAndAssignCameras(){const M=Array.from(this._camerasMap.values());for(const Z of M){const M=this._nodesCameraMap.get(Z);if(void 0!==M){this._cameras.push(Z);for(const Z of M)Z.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const M of this._babylonScene.skeletons){if(M.bones.length<=0)continue;const Z={joints:[]};this._skinMap.set(M,Z)}}_exportAndAssignSkeletons(){for(const M of this._babylonScene.skeletons){if(M.bones.length<=0)continue;const Z=this._skinMap.get(M);if(void 0==Z)continue;const P={},x=[];let w=-1;for(let c=0;c<M.bones.length;++c){const Z=M.bones[c],x=Z.getIndex()??c;-1!==x&&(P[x]=Z,x>w&&(w=x))}for(let M=0;M<=w;++M){const w=P[M];x.push(w.getAbsoluteInverseBindMatrix());const v=w.getTransformNode();if(null!==v){const M=this._nodeMap.get(v);v&&null!==M&&void 0!==M?Z.joints.push(M):c.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else c.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const v=this._nodesSkinMap.get(Z);if(Z.joints.length>0&&void 0!==v){const M=64*x.length,P=new Float32Array(M/4);x.forEach(((M,Z)=>{P.set(M.m,16*Z)}));const c=this._bufferManager.createBufferView(P);this._accessors.push(this._bufferManager.createAccessor(c,"MAT4",5126,x.length)),Z.inverseBindMatrices=this._accessors.length-1,this._skins.push(Z);for(const Z of v)Z.skin=this._skins.length-1}}}async _exportSceneAsync(){const M={nodes:[]};if(this._babylonScene.metadata){const Z=this._options.metadataSelector(this._babylonScene.metadata);Z&&(M.extras=Z)}const Z=new Array,P=new Array,x=new Array;for(const G of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&vM(G,this._babylonScene.useRightHandedSystem)?x.push(...G.getChildren()):this._babylonScene.useRightHandedSystem?Z.push(G):P.push(G);this._listAvailableCameras(),this._listAvailableSkeletons();const c=new yM(!0,!1);M.nodes.push(...await this._exportNodesAsync(P,c));const w=new yM(!1,!1);M.nodes.push(...await this._exportNodesAsync(Z,w));const v=new yM(!1,!0);M.nodes.push(...await this._exportNodesAsync(x,v)),M.nodes.length&&this._scenes.push(M),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&JM._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,c.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(M){let Z=this._shouldExportNodeMap.get(M);return void 0===Z&&(Z=this._options.shouldExportNode(M),this._shouldExportNodeMap.set(M,Z)),Z}async _exportNodesAsync(M,Z){const P=new Array;this._exportBuffers(M,Z);for(const x of M)await this._exportNodeAsync(x,P,Z);return P}_collectBuffers(M,Z,P,x,c){if(this._shouldExportNode(M)&&M instanceof H.b&&M.tc){const w=M.tc.getVertexBuffers();if(w)for(const x in w){if(!T(x))continue;const v=w[x];c.setHasVertexColorAlpha(v,M.hasVertexAlpha);const G=v._buffer,mM=Z.get(G)||[];Z.set(G,mM),-1===mM.indexOf(v)&&mM.push(v);const K=P.get(v)||[];P.set(v,K),-1===K.indexOf(M)&&K.push(M)}const v=M.morphTargetManager;if(v)for(let Z=0;Z<v.numTargets;Z++){const P=v.getTarget(Z),c=x.get(P)||[];x.set(P,c),-1===c.indexOf(M)&&c.push(M)}}for(const w of M.getChildren())this._collectBuffers(w,Z,P,x,c)}_exportBuffers(M,Z){const P=new Map,x=new Map,c=new Map;for(const G of M)this._collectBuffers(G,P,x,c,Z);const w=Array.from(P.keys());for(const G of w){const M=G.getData();if(!M)throw new Error("Buffer data is not available");const c=P.get(G);if(!c)continue;const w=c[0].byteStride;if(c.some((M=>M.byteStride!==w)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const v=PM(M).slice();for(const Z of c){const M=x.get(Z),{byteOffset:P,byteStride:c,componentCount:w,type:G,count:mM,normalized:K,kind:O}=z(Z,M);switch(O){case d.g.NormalKind:case d.g.TangentKind:(0,r.l)(v,P,c,w,G,mM,K,(M=>{const Z=Math.sqrt(M[0]*M[0]+M[1]*M[1]+M[2]*M[2]);if(Z>0){const P=1/Z;M[0]*=P,M[1]*=P,M[2]*=P}}));break;case d.g.ColorKind:{const Z=M.filter((M=>M.material instanceof UM.LZ||null==M.material)).length;if(0==Z)break;if(Z!=M.length){q.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}G==d.g.UNSIGNED_BYTE&&q.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const x=new n.uZ,O=new n.Ic,H=this._babylonScene.getEngine().useExactSrgbConversions;(0,r.l)(v,P,c,w,G,mM,K,(M=>{3===M.length?(x.jP(M,0),x.toLinearSpaceToRef(x,H),x.toArray(M,0)):(O.jP(M,0),O.toLinearSpaceToRef(O,H),O.toArray(M,0))}))}}}if(Z.convertToRightHanded){for(const M of c){const Z=x.get(M),{byteOffset:P,byteStride:c,componentCount:w,type:G,count:mM,normalized:K,kind:O}=z(M,Z);switch(O){case d.g.PositionKind:case d.g.NormalKind:case d.g.TangentKind:(0,r.l)(v,P,c,w,G,mM,K,(M=>{M[0]=-M[0]}))}}Z.convertedToRightHandedBuffers.set(G,v)}const mM=this._bufferManager.createBufferView(v,w);Z.setVertexBufferView(G,mM);const K=new Map;for(const Z of c){const M=x.get(Z),{kind:P,totalVertices:c}=z(Z,M);switch(P){case d.g.MatricesIndicesKind:case d.g.MatricesIndicesExtraKind:if(Z.type==d.g.FLOAT){const M=Z.getFloatData(c);null!==M&&K.set(Z,M)}}}0!==K.size&&q.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const O=Array.from(K.keys());for(const P of O){const M=K.get(P);if(!M)continue;const x=M.some((M=>M>=256)),c=new(x?Uint16Array:Uint8Array)(M.length);for(let Z=0;Z<M.length;Z++)c[Z]=M[Z];const w=this._bufferManager.createBufferView(c,4*(x?2:1));Z.setRemappedBufferView(G,P,w)}}const v=Array.from(c.keys());for(const G of v){const M=c.get(G);if(!M)continue;const P=tM(G,M[0],this._bufferManager,this._bufferViews,this._accessors,Z.convertToRightHanded);for(const x of M)Z.bindMorphDataToMesh(x,P)}}async _exportNodeAsync(M,Z,P){let x=this._nodeMap.get(M);if(void 0!==x)return void(Z.includes(x)||Z.push(x));const c=await this._createNodeAsync(M,P);if(c){x=this._nodes.length,this._nodes.push(c),this._nodeMap.set(M,x),P.pushExportedNode(M),Z.push(x);const w={name:"runtime animations",channels:[],samplers:[]},v=[];this._babylonScene.animationGroups.length||(JM._CreateMorphTargetAnimationFromMorphTargetAnimations(M,w,v,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,P.convertToRightHanded,this._options.shouldExportAnimation),M.animations.length&&JM._CreateNodeAnimationFromNodeAnimations(M,w,v,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,P.convertToRightHanded,this._options.shouldExportAnimation)),w.channels.length&&w.samplers.length&&this._animations.push(w),v.forEach((M=>{M.channels.length&&M.samplers.length&&this._animations.push(M)}))}const w=c?[]:Z;for(const v of M.getChildren())await this._exportNodeAsync(v,w,P);c&&w.length&&(c.children=w)}async _createNodeAsync(M,Z){if(!this._shouldExportNode(M))return null;const P={};if(M.name&&(P.name=M.name),M.metadata){const Z=this._options.metadataSelector(M.metadata);Z&&(P.extras=Z)}if(M instanceof O.b&&(this._setNodeTransformation(P,M,Z.convertToRightHanded),M instanceof H.b)){const c=M instanceof j.b?M.sourceMesh:M;if(c.Uc&&c.Uc.length>0&&(P.mesh=await this._exportMeshAsync(c,Z)),M.skeleton){const Z=this._skinMap.get(M.skeleton);var x;if(void 0!==Z)void 0===this._nodesSkinMap.get(Z)&&this._nodesSkinMap.set(Z,[]),null===(x=this._nodesSkinMap.get(Z))||void 0===x||x.push(P)}}if(M instanceof e.b){const x=this._camerasMap.get(M);if(x){var c;void 0===this._nodesCameraMap.get(x)&&this._nodesCameraMap.set(x,[]),this._setCameraTransformation(P,M,Z.convertToRightHanded);const v=M.parent;if(null!==v&&ZM(M,v)){const M=this._nodeMap.get(v);if(void 0!==M){var w;const Z=this._nodes[M];return MM(P,Z),null===(w=this._nodesCameraMap.get(x))||void 0===w||w.push(Z),null}}null===(c=this._nodesCameraMap.get(x))||void 0===c||c.push(P)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",P,M,this._nodeMap,Z.convertToRightHanded)?P:(q.d.Warn(`Not exporting node ${M.name}`),null)}_exportIndices(M,Z,P,x,c,v,G,mM,K){let d=M;K.mode=p(v);const O=G!==w.d.CounterClockWiseSideOrientation,H=!mM.wasAddedByNoopNode&&O,j=function(M){switch(M){case w.d.TriangleFillMode:case w.d.TriangleStripDrawMode:case w.d.TriangleFanDrawMode:return!0}return!1}(v)&&H;if(j){if(v===w.d.TriangleStripDrawMode||v===w.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");K.mode=p(v);const G=Z?new Uint32Array(x):new Uint16Array(x);if(M)for(let Z=0;Z+2<x;Z+=3)G[Z]=M[P+Z]+c,G[Z+1]=M[P+Z+2]+c,G[Z+2]=M[P+Z+1]+c;else for(let M=0;M+2<x;M+=3)G[M]=M,G[M+1]=M+2,G[M+2]=M+1;d=G}else if(M&&0!==c){const w=Z?new Uint32Array(x):new Uint16Array(x);for(let Z=0;Z<x;Z++)w[Z]=M[P+Z]+c;d=w}if(d){let w=mM.getIndicesAccessor(M,P,x,c,j);if(void 0===w){const v=function(M,Z,P,x){if(M instanceof Uint16Array||M instanceof Uint32Array)return M;if(M instanceof Int32Array)return new Uint32Array(M.buffer,M.byteOffset,M.length);const c=M.slice(Z,Z+P);return x?new Uint32Array(c):new Uint16Array(c)}(d,0,x,Z),G=this._bufferManager.createBufferView(v),K=Z?5125:5123;this._accessors.push(this._bufferManager.createAccessor(G,"SCALAR",K,x,0)),w=this._accessors.length-1,mM.setIndicesAccessor(M,P,x,c,j,w)}K.indices=w}}_exportVertexBuffer(M,Z,P,x,c,w){const v=M.getKind();if(!T(v))return;if(v.startsWith("uv")&&!this._options.exportUnusedUVs&&(!Z||!this._materialNeedsUVsSet.has(Z)))return;let G=c.getVertexAccessor(M,P,x);if(void 0===G){const Z=c.convertedToRightHandedBuffers.get(M._buffer)||M._buffer.getData(),w=v===d.g.PositionKind?function(M,Z,P,x){const{byteOffset:c,byteStride:w,type:v,normalized:G}=Z,mM=Z.getSize(),K=new Array(mM).fill(1/0),d=new Array(mM).fill(-1/0);return(0,r.l)(M,c+P*w,w,mM,v,x*mM,G,(M=>{for(let Z=0;Z<mM;Z++)K[Z]=Math.min(K[Z],M[Z]),d[Z]=Math.max(d[Z],M[Z])})),{min:K,max:d}}(Z,M,P,x):void 0,mM=(v===d.g.MatricesIndicesKind||v===d.g.MatricesIndicesExtraKind)&&M.type===d.g.FLOAT,K=mM?d.g.UNSIGNED_BYTE:M.type,O=mM?void 0:M.normalized,H=mM?c.getRemappedBufferView(M._buffer,M):c.getVertexBufferView(M._buffer),j=M.byteOffset+P*M.byteStride;this._accessors.push(this._bufferManager.createAccessor(H,function(M,Z){if(M==d.g.ColorKind)return Z?"VEC4":"VEC3";switch(M){case d.g.PositionKind:case d.g.NormalKind:return"VEC3";case d.g.TangentKind:case d.g.MatricesIndicesKind:case d.g.MatricesIndicesExtraKind:case d.g.MatricesWeightsKind:case d.g.MatricesWeightsExtraKind:return"VEC4";case d.g.UVKind:case d.g.UV2Kind:case d.g.UV3Kind:case d.g.UV4Kind:case d.g.UV5Kind:case d.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${M}`)}(v,c.hasVertexColorAlpha(M)),K,x,j,w,O)),G=this._accessors.length-1,c.setVertexAccessor(M,P,x,G)}w.attributes[function(M){switch(M){case d.g.PositionKind:return"POSITION";case d.g.NormalKind:return"NORMAL";case d.g.TangentKind:return"TANGENT";case d.g.ColorKind:return"COLOR_0";case d.g.UVKind:return"TEXCOORD_0";case d.g.UV2Kind:return"TEXCOORD_1";case d.g.UV3Kind:return"TEXCOORD_2";case d.g.UV4Kind:return"TEXCOORD_3";case d.g.UV5Kind:return"TEXCOORD_4";case d.g.UV6Kind:return"TEXCOORD_5";case d.g.MatricesIndicesKind:return"JOINTS_0";case d.g.MatricesIndicesExtraKind:return"JOINTS_1";case d.g.MatricesWeightsKind:return"WEIGHTS_0";case d.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${M}`)}(v)]=G}async _exportMaterialAsync(M,Z,P,x){let c=this._materialMap.get(M);if(void 0===c){const x=Z&&Object.keys(Z).some((M=>M.startsWith("uv")));if((M=M instanceof jM.e?M.sc[P.materialIndex]:M)instanceof BM.d)c=await this._materialExporter.exportPBRMaterialAsync(M,"image/png",x);else{if(!(M instanceof UM.LZ))return void q.d.Warn(`Unsupported material '${M.name}' with type ${M.getClassName()}`);c=await this._materialExporter.exportStandardMaterialAsync(M,"image/png",x)}this._materialMap.set(M,c)}x.material=c}async _exportMeshAsync(M,Z){var P;let x=Z.getMesh(M);if(void 0!==x)return x;const c={primitives:[]};x=this._meshes.length,this._meshes.push(c),Z.setMesh(M,x);const v=M.isUnIndexed?null:M.Fc(),G=null===(P=M.tc)||void 0===P?void 0:P.getVertexBuffers(),mM=Z.getMorphTargetsFromMesh(M),K=M instanceof FM.d,d=M instanceof aM,O=M.Uc;if(G&&O&&O.length>0)for(const B of O){const P={attributes:{}},x=B.EM()||this._babylonScene.defaultMaterial;if(d){var H,j;const Z={name:x.name},c=M,w=n.uZ.White(),v=(null===(H=c.material)||void 0===H?void 0:H.alpha)??1,G=(null===(j=c.greasedLineMaterial)||void 0===j?void 0:j.color)??w;(!G.equalsWithEpsilon(w,b.c)||v<1)&&(Z.pbrMetallicRoughness={baseColorFactor:[...G.nc(),v]}),this._materials.push(Z),P.material=this._materials.length-1}else if(K){const Z={name:x.name},c=M;(!c.color.equalsWithEpsilon(n.uZ.White(),b.c)||c.alpha<1)&&(Z.pbrMetallicRoughness={baseColorFactor:[...c.color.nc(),c.alpha]}),this._materials.push(Z),P.material=this._materials.length-1}else await this._exportMaterialAsync(x,G,B,P);const O=K||d?w.d.LineListDrawMode:M.overrideRenderingFillMode??x.fillMode,U=x._getEffectiveOrientation(M);this._exportIndices(v,v?(0,r.e)(v,B.indexCount,B.indexStart,B.verticesStart):B.verticesCount>65535,v?B.indexStart:B.verticesStart,v?B.indexCount:B.verticesCount,-B.verticesStart,O,U,Z,P);for(const M of Object.values(G))this._exportVertexBuffer(M,x,B.verticesStart,B.verticesCount,Z,P);if(mM){P.targets=[];for(const M of mM)P.targets.push(M.attributes)}c.primitives.push(P),this._extensionsPostExportMeshPrimitive(P)}if(mM){c.weights=[],c.extras||(c.extras={}),c.extras.targetNames=[];for(const M of mM)c.weights.push(M.influence),c.extras.targetNames.push(M.name)}return x}}fM._ExtensionNames=new Array,fM._ExtensionFactories={};class YM{static async GLTFAsync(M,Z,P){P&&P.exportWithoutWaitingForScene||await M.whenReadyAsync();const x=new fM(M,P),c=await x.generateGLTFAsync(Z.replace(/\.[^/.]+$/,""));return x.dispose(),c}static async GLBAsync(M,Z,P){P&&P.exportWithoutWaitingForScene||await M.whenReadyAsync();const x=new fM(M,P),c=await x.generateGLBAsync(Z.replace(/\.[^/.]+$/,""));return x.dispose(),c}}P(12930);const zM="EXT_mesh_gpu_instancing";class iM{constructor(M){this.name=zM,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(M,Z,P,c,w,v){return await new Promise((M=>{if(Z&&P instanceof uM.c&&P.hasThinInstances&&this._exporter){this._wasUsed=!0;const M=x.BZ.Zero(),c=x.Quaternion.Identity(),G=x.BZ.One(),mM=P.thinInstanceGetWorldMatrices(),K=x.TmpVectors.BZ[2],d=x.TmpVectors.Quaternion[1],O=x.TmpVectors.BZ[3];let H=!1,j=!1,B=!1;const U=new Float32Array(3*P.Cc),n=new Float32Array(4*P.Cc),L=new Float32Array(3*P.Cc);let u=0;for(const Z of mM)Z.decompose(O,d,K),w&&(X(K),V(d)),U.set(K.nc(),3*u),n.set(d.normalize().nc(),4*u),L.set(O.nc(),3*u),H=H||!K.equalsWithEpsilon(M),j=j||!d.equalsWithEpsilon(c),B=B||!O.equalsWithEpsilon(G),u++;const N={attributes:{}};H&&(N.attributes.TRANSLATION=this._buildAccessor(U,"VEC3",P.Cc,v)),j&&(N.attributes.ROTATION=this._buildAccessor(n,"VEC4",P.Cc,v)),B&&(N.attributes.SCALE=this._buildAccessor(L,"VEC3",P.Cc,v)),Z.extensions=Z.extensions||{},Z.extensions[zM]=N}M(Z)}))}_buildAccessor(M,Z,P,x){const c=x.createBufferView(M),w=x.createAccessor(c,Z,5126,P);return this._exporter._accessors.push(w),this._exporter._accessors.length-1}}fM.RegisterExtension(zM,(M=>new iM(M)));var TM=P(12939),pM=P(12945),SM=P(12953),XM=P(12960);function VM(M){return M===SM.d.PositionKind?"POSITION":M===SM.d.NormalKind?"NORMAL":M===SM.d.ColorKind?"COLOR":M.startsWith(SM.d.UVKind)?"TEX_COORD":"GENERIC"}const gM={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class MZ extends TM.c{static get DefaultAvailable(){return(0,TM.h)(MZ.DefaultConfiguration)}static get Default(){return MZ._Default??(MZ._Default=new MZ),MZ._Default}static ResetDefault(M){MZ._Default&&(M||MZ._Default.dispose(),MZ._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(M,Z){return{module:await(Z||DracoEncoderModule)({wasmBinary:M})}}_getWorkerContent(){return`${pM.l}(${pM.p})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:MZ.DefaultConfiguration)}async _encodeAsync(M,Z,P){const x=P?(0,XM.d)(gM,P):gM;if(this._workerPoolPromise){const P=await this._workerPoolPromise;return await new Promise(((c,w)=>{P.push(((P,v)=>{const G=M=>{P.removeEventListener("error",G),P.removeEventListener("message",mM),w(M),v()},mM=M=>{"encodeMeshDone"===M.data.id&&(P.removeEventListener("error",G),P.removeEventListener("message",mM),c(M.data.encodedMeshData),v())};P.addEventListener("error",G),P.addEventListener("message",mM);const K=[];for(const Z of M)K.push(Z.data.buffer);Z&&K.push(Z.buffer),P.postMessage({id:"encodeMesh",attributes:M,indices:Z,options:x},K)}))}))}if(this._modulePromise){const P=await this._modulePromise;return(0,pM.l)(P.module,M,Z,x)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(M,Z){if(0==M.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");M instanceof uM.c&&M.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===Z||void 0===Z?void 0:Z.method)&&(q.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),Z.method="MESH_SEQUENTIAL_ENCODING");const P=function(M){let Z=M.Fc(void 0,!0);return!Z||Z instanceof Uint32Array||Z instanceof Uint16Array||(Z=((0,r.e)(Z,Z.length)?Uint32Array:Uint16Array).from(Z)),Z}(M),x=function(M,Z){const P=[];for(const x of M.getVerticesDataKinds()){if(null!==Z&&void 0!==Z&&Z.includes(x)){if(x===SM.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const c=M.getVertexBuffer(x),w=c.getSize(),v=(0,r.w)(c.getData(),w,c.type,c.byteOffset,c.byteStride,c.normalized,M.getTotalVertices(),!0);P.push({kind:x,dracoName:VM(x),size:w,data:v})}return P}(M,null===Z||void 0===Z?void 0:Z.excludedAttributes);return await this._encodeAsync(x,P,Z)}}MZ.DefaultConfiguration={wasmUrl:`${c.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${c.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${c.Tools._DefaultCdnUrl}/draco_encoder.js`},MZ._Default=null;const ZZ="KHR_draco_mesh_compression";class PZ{get wasUsed(){return this._wasUsed}constructor(M){this.name=ZZ,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===M.options.meshCompressionMethod&&MZ.DefaultAvailable}dispose(){}postExportMeshPrimitive(M,Z,P){if(!this.enabled)return;if(4!==M.mode&&5!==M.mode)return void q.d.Warn("Cannot compress primitive with mode "+M.mode+".");const x=[],c=[];let w=null;if(void 0!==M.indices){const v=P[M.indices],G=Z.getBufferView(v);w=Z.getData(G).slice(),x.push(G),c.push(v)}const v=[];for(const[d,O]of Object.entries(M.attributes)){const M=P[O],w=Z.getBufferView(M),mM=i(M.type),K=(0,r.w)(Z.getData(w),mM,M.componentType,M.byteOffset||0,w.byteStride||(0,r.q)(M.componentType)*mM,M.normalized||!1,M.count,!0);v.push({kind:d,dracoName:(G=d,"POSITION"===G?"POSITION":"NORMAL"===G?"NORMAL":G.startsWith("COLOR")?"COLOR":G.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:i(M.type),data:K}),x.push(w),c.push(M)}var G;const mM={method:M.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},K=MZ.Default._encodeAsync(v,w,mM).then((P=>{if(!P)return void q.d.Error("Draco encoding failed for primitive.");const w={bufferView:-1,attributes:P.attributeIds},v=Z.createBufferView(P.data);Z.setBufferView(w,v);for(const M of x)this._bufferViewsUsed.add(M);for(const M of c)this._accessorsUsed.add(M);M.extensions||(M.extensions={}),M.extensions[ZZ]=w})).catch((M=>{q.d.Error("Draco encoding failed for primitive: "+M)}));this._encodePromises.push(K),this._wasUsed=!0}async preGenerateBinaryAsync(M){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((Z=>{M.getPropertiesWithBufferView(Z).every((M=>this._accessorsUsed.has(M)))&&M.removeBufferView(Z)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}fM.RegisterExtension(ZZ,(M=>new PZ(M)));var xZ=P(12962);const cZ="KHR_lights_punctual",wZ={name:"",color:[1,1,1],Rc:1,range:Number.MAX_VALUE},vZ={innerConeAngle:0,outerConeAngle:Math.PI/4},GZ=x.BZ.Backward();class mP{constructor(M){this.name=cZ,this.enabled=!0,this.required=!1,this._exporter=M}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[cZ]=this._lights}async postExportNodeAsync(M,Z,P,c,w){return await new Promise((v=>{if(!(P instanceof NM.d))return void v(Z);const G=P.getTypeID()==NM.d.LIGHTTYPEID_POINTLIGHT?"point":P.getTypeID()==NM.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":P.getTypeID()==NM.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!G||!(P instanceof xZ.d))return q.d.Warn(`${M}: Light ${P.name} is not supported in ${cZ}`),void v(Z);if(P.falloffType!==NM.d.FALLOFF_GLTF&&q.d.Warn(`${M}: Light falloff for ${P.name} does not match the ${cZ} specification!`),!P.position.equalsToFloats(0,0,0)){const M=x.TmpVectors.BZ[0].v(P.position);w&&X(M),Z.translation=M.nc()}if("point"!==G){const M=P.direction.normalizeToRef(x.TmpVectors.BZ[0]);w&&X(M);const c=x.Quaternion.FromUnitVectorsToRef(GZ,M,x.TmpVectors.Quaternion[0]);x.Quaternion.IsIdentity(c)||(Z.rotation=c.nc())}const mM={type:G,name:P.name,color:P.Wc.nc(),Rc:P.Rc,range:P.range};if(xM(mM,wZ),"spot"===G){const M=P;mM.spot={innerConeAngle:M.innerAngle/2,outerConeAngle:M.angle/2},xM(mM.spot,vZ)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(mM);const K={Zc:this._lights.lights.length-1},d=P.parent;if(d&&ZM(P,d)){const M=c.get(d);if(M){const P=this._exporter._nodes[M];return MM(Z,P),P.extensions||(P.extensions={}),P.extensions[cZ]=K,void v(null)}}Z.extensions||(Z.extensions={}),Z.extensions[cZ]=K,v(Z)}))}}fM.RegisterExtension(cZ,(M=>new mP(M)));var KZ=P(12875);const dZ="KHR_materials_anisotropy";class OZ{constructor(M){this.name=dZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,Z,P){const x=[];return P instanceof KZ.b&&P.anisotropy.isEnabled&&!P.anisotropy.legacy?(P.anisotropy.texture&&x.push(P.anisotropy.texture),x):[]}postExportMaterialAsync(M,Z,P){return new Promise((M=>{if(P instanceof KZ.b){if(!P.anisotropy.isEnabled||P.anisotropy.legacy)return void M(Z);this._wasUsed=!0,Z.extensions=Z.extensions||{};const x=this._exporter._materialExporter.getTextureInfo(P.anisotropy.texture),c={anisotropyStrength:P.anisotropy.Rc,anisotropyRotation:P.anisotropy.angle,anisotropyTexture:x??void 0};null!==c.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(P),Z.extensions[dZ]=c}M(Z)}))}}fM.RegisterExtension(dZ,(M=>new OZ(M)));const HZ="KHR_materials_clearcoat";class jZ{constructor(M){this.name=HZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,Z,P){const x=[];return P instanceof KZ.b&&P.clearCoat.isEnabled?(P.clearCoat.texture&&x.push(P.clearCoat.texture),!P.clearCoat.useRoughnessFromMainTexture&&P.clearCoat.textureRoughness&&x.push(P.clearCoat.textureRoughness),P.clearCoat.bumpTexture&&x.push(P.clearCoat.bumpTexture),x):[]}postExportMaterialAsync(M,Z,P){return new Promise((M=>{if(P instanceof KZ.b){if(!P.clearCoat.isEnabled)return void M(Z);this._wasUsed=!0,Z.extensions=Z.extensions||{};const x=this._exporter._materialExporter.getTextureInfo(P.clearCoat.texture);let w;w=P.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(P.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(P.clearCoat.textureRoughness),P.clearCoat.isTintEnabled&&c.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${P.name}`),P.clearCoat.remapF0OnInterfaceChange&&c.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${P.name}`);const v=this._exporter._materialExporter.getTextureInfo(P.clearCoat.bumpTexture),G={clearcoatFactor:P.clearCoat.Rc,clearcoatTexture:x??void 0,clearcoatRoughnessFactor:P.clearCoat.roughness,clearcoatRoughnessTexture:w??void 0,clearcoatNormalTexture:v??void 0};null===G.clearcoatTexture&&null===G.clearcoatRoughnessTexture&&null===G.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(P),Z.extensions[HZ]=G}M(Z)}))}}fM.RegisterExtension(HZ,(M=>new jZ(M)));const BZ="KHR_materials_diffuse_transmission";function UZ(M,Z){const P=Z.subSurface;let x=null;return P.translucencyIntensityTexture?x=P.translucencyIntensityTexture:P.thicknessTexture&&P.useMaskFromThicknessTexture&&(x=P.thicknessTexture),x&&!P.useGltfStyleTextures?(q.d.Warn(`${M}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${Z.name}`,1),null):x}class nZ{constructor(M){this.name=BZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,Z,P){const x=[];if(P instanceof BM.d&&this._isExtensionEnabled(P)){const Z=UZ(M,P);return Z&&x.push(Z),P.subSurface.translucencyColorTexture&&x.push(P.subSurface.translucencyColorTexture),x}return x}_isExtensionEnabled(M){if(M.unlit)return!1;const Z=M.subSurface;return!!Z.isTranslucencyEnabled&&(!M.unlit&&!Z.useAlbedoToTintTranslucency&&Z.useGltfStyleTextures&&1===Z.volumeIndexOfRefraction&&0===Z.minimumThickness&&0===Z.maximumThickness)}postExportMaterialAsync(M,Z,P){return new Promise((x=>{if(P instanceof BM.d&&this._isExtensionEnabled(P)){this._wasUsed=!0;const x=P.subSurface,c=UZ(M,P),w=0==x.translucencyIntensity?void 0:x.translucencyIntensity,v=this._exporter._materialExporter.getTextureInfo(c)??void 0,G=!x.translucencyColor||x.translucencyColor.equalsFloats(1,1,1)?void 0:x.translucencyColor.nc(),mM=this._exporter._materialExporter.getTextureInfo(x.translucencyColorTexture)??void 0,K={diffuseTransmissionFactor:w,diffuseTransmissionTexture:v,diffuseTransmissionColorFactor:G,diffuseTransmissionColorTexture:mM};(v||mM)&&this._exporter._materialNeedsUVsSet.add(P),Z.extensions=Z.extensions||{},Z.extensions[BZ]=K}x(Z)}))}}fM.RegisterExtension(BZ,(M=>new nZ(M)));const LZ="KHR_materials_dispersion";class uZ{constructor(){this.name=LZ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(M){if(M.unlit)return!1;const Z=M.subSurface;return!(!Z.isRefractionEnabled&&!Z.isDispersionEnabled)}postExportMaterialAsync(M,Z,P){return new Promise((M=>{if(P instanceof BM.d&&this._isExtensionEnabled(P)){this._wasUsed=!0;const M={dispersion:P.subSurface.dispersion};Z.extensions=Z.extensions||{},Z.extensions[LZ]=M}M(Z)}))}}fM.RegisterExtension(LZ,(()=>new uZ));const NZ="KHR_materials_emissive_strength";class JZ{constructor(){this.name=NZ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(M,Z,P){return await new Promise((M=>{if(!(P instanceof BM.d))return M(Z);const x=P.emissiveColor.nc(),c=Math.max(...x);if(c>1){this._wasUsed=!0,Z.extensions||(Z.extensions={});const M={emissiveStrength:c},x=P.emissiveColor.scale(1/M.emissiveStrength);Z.emissiveFactor=x.nc(),Z.extensions[NZ]=M}return M(Z)}))}}fM.RegisterExtension(NZ,(M=>new JZ));const tZ="KHR_materials_ior";class FZ{constructor(){this.name=tZ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(M){return!M.unlit&&(void 0!=M.indexOfRefraction&&1.5!=M.indexOfRefraction)}postExportMaterialAsync(M,Z,P){return new Promise((M=>{if(P instanceof BM.d&&this._isExtensionEnabled(P)){this._wasUsed=!0;const M={ior:P.indexOfRefraction};Z.extensions=Z.extensions||{},Z.extensions[tZ]=M}M(Z)}))}}fM.RegisterExtension(tZ,(M=>new FZ));const DZ="KHR_materials_iridescence";class lZ{constructor(M){this.name=DZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,Z,P){const x=[];return P instanceof KZ.b&&P.iridescence.isEnabled?(P.iridescence.texture&&x.push(P.iridescence.texture),P.iridescence.thicknessTexture&&P.iridescence.thicknessTexture!==P.iridescence.texture&&x.push(P.iridescence.thicknessTexture),x):[]}postExportMaterialAsync(M,Z,P){return new Promise((M=>{if(P instanceof KZ.b){if(!P.iridescence.isEnabled)return void M(Z);this._wasUsed=!0,Z.extensions=Z.extensions||{};const x=this._exporter._materialExporter.getTextureInfo(P.iridescence.texture),c=this._exporter._materialExporter.getTextureInfo(P.iridescence.thicknessTexture),w={iridescenceFactor:P.iridescence.Rc,iridescenceIor:P.iridescence.indexOfRefraction,iridescenceThicknessMinimum:P.iridescence.minimumThickness,iridescenceThicknessMaximum:P.iridescence.maximumThickness,iridescenceTexture:x??void 0,iridescenceThicknessTexture:c??void 0};null===w.iridescenceTexture&&null===w.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(P),Z.extensions[DZ]=w}M(Z)}))}}fM.RegisterExtension(DZ,(M=>new lZ(M)));const hZ="KHR_materials_sheen";class QZ{constructor(M){this.name=hZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,Z,P){return P instanceof BM.d&&P.sheen.isEnabled&&P.sheen.texture?[P.sheen.texture]:[]}async postExportMaterialAsync(M,Z,P){return await new Promise((M=>{if(P instanceof BM.d){if(!P.sheen.isEnabled)return void M(Z);this._wasUsed=!0,null==Z.extensions&&(Z.extensions={});const x={sheenColorFactor:P.sheen.color.nc(),sheenRoughnessFactor:P.sheen.roughness??0};null===x.sheenColorTexture&&null===x.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(P),P.sheen.texture&&(x.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.texture)??void 0),P.sheen.textureRoughness&&!P.sheen.useRoughnessFromMainTexture?x.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.textureRoughness)??void 0:P.sheen.texture&&P.sheen.useRoughnessFromMainTexture&&(x.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.texture)??void 0),Z.extensions[hZ]=x}M(Z)}))}}fM.RegisterExtension(hZ,(M=>new QZ(M)));const IZ="KHR_materials_specular";class sZ{constructor(M){this.name=IZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,Z,P){const x=[];return P instanceof BM.d&&this._isExtensionEnabled(P)?(P.metallicReflectanceTexture&&x.push(P.metallicReflectanceTexture),P.reflectanceTexture&&x.push(P.reflectanceTexture),x):x}_isExtensionEnabled(M){return!M.unlit&&(void 0!=M.metallicF0Factor&&1!=M.metallicF0Factor||void 0!=M.metallicReflectanceColor&&!M.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(M))}_hasTexturesExtension(M){return null!=M.metallicReflectanceTexture||null!=M.reflectanceTexture}postExportMaterialAsync(M,Z,P){return new Promise((M=>{if(P instanceof BM.d&&this._isExtensionEnabled(P)){this._wasUsed=!0,Z.extensions=Z.extensions||{};const M=this._exporter._materialExporter.getTextureInfo(P.metallicReflectanceTexture)??void 0,x=this._exporter._materialExporter.getTextureInfo(P.reflectanceTexture)??void 0,c={specularFactor:1==P.metallicF0Factor?void 0:P.metallicF0Factor,specularTexture:M,specularColorFactor:P.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:P.metallicReflectanceColor.nc(),specularColorTexture:x};this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),Z.extensions[IZ]=c}M(Z)}))}}fM.RegisterExtension(IZ,(M=>new sZ(M)));const CZ="KHR_materials_transmission";class RZ{constructor(M){this.name=CZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,Z,P){const x=[];return P instanceof BM.d&&this._isExtensionEnabled(P)?(P.subSurface.thicknessTexture&&x.push(P.subSurface.thicknessTexture),x):x}_isExtensionEnabled(M){if(M.unlit)return!1;const Z=M.subSurface;return Z.isRefractionEnabled&&void 0!=Z.refractionIntensity&&0!=Z.refractionIntensity||this._hasTexturesExtension(M)}_hasTexturesExtension(M){return null!=M.subSurface.refractionIntensityTexture}async postExportMaterialAsync(M,Z,P){if(P instanceof BM.d&&this._isExtensionEnabled(P)){this._wasUsed=!0;const x=P.subSurface,c={transmissionFactor:0===x.refractionIntensity?void 0:x.refractionIntensity};if(this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),x.refractionIntensityTexture)if(x.useGltfStyleTextures){const M=await this._exporter._materialExporter.exportTextureAsync(x.refractionIntensityTexture,"image/png");M&&(c.transmissionTexture=M)}else q.d.Warn(`${M}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);Z.extensions||(Z.extensions={}),Z.extensions[CZ]=c}return Z}}fM.RegisterExtension(CZ,(M=>new RZ(M)));const WZ="KHR_materials_unlit";class kZ{constructor(){this.name=WZ,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(M,Z,P){return new Promise((M=>{let x=!1;P instanceof BM.d?x=P.unlit:P instanceof UM.LZ&&(x=P.disableLighting),x&&(this._wasUsed=!0,null==Z.extensions&&(Z.extensions={}),Z.extensions[WZ]={}),M(Z)}))}}fM.RegisterExtension(WZ,(()=>new kZ));const AZ="KHR_materials_volume";class oZ{constructor(M){this.name=AZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,Z,P){const x=[];return P instanceof BM.d&&this._isExtensionEnabled(P)?(P.subSurface.thicknessTexture&&x.push(P.subSurface.thicknessTexture),x):x}_isExtensionEnabled(M){if(M.unlit)return!1;const Z=M.subSurface;return!(!Z.isRefractionEnabled&&!Z.isTranslucencyEnabled)&&(void 0!=Z.maximumThickness&&0!=Z.maximumThickness||void 0!=Z.tintColorAtDistance&&Z.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=Z.tintColor&&Z.tintColor!=n.uZ.White()||this._hasTexturesExtension(M))}_hasTexturesExtension(M){return null!=M.subSurface.thicknessTexture}postExportMaterialAsync(M,Z,P){return new Promise((M=>{if(P instanceof BM.d&&this._isExtensionEnabled(P)){this._wasUsed=!0;const M=P.subSurface,x={thicknessFactor:0==M.maximumThickness?void 0:M.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(M.thicknessTexture)??void 0,attenuationDistance:M.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:M.tintColorAtDistance,attenuationColor:M.tintColor.equalsFloats(1,1,1)?void 0:M.tintColor.nc()};this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),Z.extensions=Z.extensions||{},Z.extensions[AZ]=x}M(Z)}))}}fM.RegisterExtension(AZ,(M=>new oZ(M)));const EZ="EXT_materials_diffuse_roughness";class rZ{constructor(M){this.name=EZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,Z,P){const x=[];return P instanceof KZ.b&&P._baseDiffuseRoughness?(P._baseDiffuseRoughnessTexture&&x.push(P._baseDiffuseRoughnessTexture),x):[]}postExportMaterialAsync(M,Z,P){return new Promise((M=>{if(P instanceof KZ.b){if(!P._baseDiffuseRoughness)return void M(Z);this._wasUsed=!0,Z.extensions=Z.extensions||{};const x=this._exporter._materialExporter.getTextureInfo(P._baseDiffuseRoughnessTexture),c={diffuseRoughnessFactor:P._baseDiffuseRoughness,diffuseRoughnessTexture:x??void 0};null!==c.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(P),Z.extensions[EZ]=c}M(Z)}))}}fM.RegisterExtension(EZ,(M=>new rZ(M)));const qZ="KHR_texture_transform";class eZ{constructor(){this.name=qZ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(M,Z,P){if(P.DM()||c.Tools.Warn(`${M}: /*@__KEY__*/"scene" is not defined for Babylon texture ${P.name}!`),(0!==P.uAng||0!==P.vAng)&&(c.Tools.Warn(`${M}: Texture ${P.name} with rotation in the u or v axis is not supported in glTF.`),0!==P.uRotationCenter||0!==P.vRotationCenter))return;const x={};let w=!1;if(0===P.uOffset&&0===P.vOffset||(x.offset=[P.uOffset,P.vOffset],w=!0),1===P.uScale&&1===P.vScale||(x.scale=[P.uScale,P.vScale],w=!0),0!==P.wAng){if(0!==P.uRotationCenter||0!==P.vRotationCenter){if(P.homogeneousRotationInUVTransform&&P.uScale!==P.vScale)return void c.Tools.Warn(`${M}: Texture ${P.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${qZ}.`);c.Tools.Warn(`${M}: Texture ${P.name} with non-origin rotation center will be exported using an adjusted offset with ${qZ}.`),x.offset=function(M){const{uOffset:Z,vOffset:P,uRotationCenter:x,vRotationCenter:c,uScale:w,vScale:v,wAng:G}=M,mM=Math.cos(G),K=Math.sin(G),d=x*w,O=c*v;return[Z+(d*(1-mM)+O*K),P+(O*(1-mM)-d*K)]}(P)}x.rotation=-P.wAng,w=!0}0!==P.coordinatesIndex&&(x.texCoord=P.coordinatesIndex,w=!0),w&&(this._wasUsed=!0,Z.extensions||(Z.extensions={}),Z.extensions[qZ]=x)}}fM.RegisterExtension(qZ,(()=>new eZ));class bZ{static CreateSTL(M){let Z=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",c=arguments.length>3&&void 0!==arguments[3]&&arguments[3],w=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],v=arguments.length>5&&void 0!==arguments[5]&&arguments[5],G=arguments.length>6&&void 0!==arguments[6]&&arguments[6],mM=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const K=function(M,Z,P){const c=[3*M[P],3*M[P+1],3*M[P+2]],w=[new x.BZ(Z[c[0]],Z[c[0]+2],Z[c[0]+1]),new x.BZ(Z[c[1]],Z[c[1]+2],Z[c[1]+1]),new x.BZ(Z[c[2]],Z[c[2]+2],Z[c[2]+1])],v=w[0].UZ(w[1]),G=w[2].UZ(w[1]);return{v:w,n:x.BZ.Cross(G,v).normalize()}},O=function(M,Z,P,x){return Z=H(M,Z,P.x,x),Z=H(M,Z,P.y,x),H(M,Z,P.z,x)},H=function(M,Z,P,x){return M.setFloat32(Z,P,x),Z+4},B=function(M){if(G){let Z=M;M instanceof j.b&&(Z=M.sourceMesh);const P=Z.getVerticesData(d.g.PositionKind,!0,!0);if(!P)return[];const c=x.BZ.Zero();let w;for(w=0;w<P.length;w+=3)x.BZ.TransformCoordinatesFromFloatsToRef(P[w],P[w+1],P[w+2],M.Jc(!0),c).toArray(P,w);return P}return M.getVerticesData(d.g.PositionKind)||[]};G&&(v=!0);let U="",n=0,L=0;if(c){for(let P=0;P<M.length;P++){const Z=M[P].Fc();n+=Z?Z.length/3:0}const Z=new ArrayBuffer(84+50*n);U=new DataView(Z),L+=80,U.setUint32(L,n,w),L+=4}else mM||(U="solid stlmesh\r\n");for(let x=0;x<M.length;x++){const Z=M[x];!c&&mM&&(U+="solid "+Z.name+"\r\n"),!v&&Z instanceof uM.c&&Z.bakeCurrentTransformIntoVertices();const P=B(Z),G=Z.Fc()||[];for(let M=0;M<G.length;M+=3){const Z=K(G,P,M);c?(L=O(U,L,Z.n,w),L=O(U,L,Z.v[0],w),L=O(U,L,Z.v[1],w),L=O(U,L,Z.v[2],w),L+=2):(U+="\tfacet normal "+Z.n.x+" "+Z.n.y+" "+Z.n.z+"\r\n",U+="\t\touter loop\r\n",U+="\t\t\tvertex "+Z.v[0].x+" "+Z.v[0].y+" "+Z.v[0].z+"\r\n",U+="\t\t\tvertex "+Z.v[1].x+" "+Z.v[1].y+" "+Z.v[1].z+"\r\n",U+="\t\t\tvertex "+Z.v[2].x+" "+Z.v[2].y+" "+Z.v[2].z+"\r\n",U+="\t\tendloop\r\n",U+="\tendfacet\r\n")}!c&&mM&&(U+="endsolid "+name+"\r\n")}if(c||mM||(U+="endsolid stlmesh"),Z){const M=document.createElement("a"),Z=new Blob([U],{type:"application/octet-stream"});M.href=window.URL.createObjectURL(Z),M.download=P+".stl",M.click()}return U}}function aZ(M,Z){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const x=[];for(let c=0;c<M.length/P;c++){const w=M[c*P],v=M[c*P+1],G=M[c*P+2];x.push(`(${w.toPrecision(Z.precision)}, ${v.toPrecision(Z.precision)}, ${G.toPrecision(Z.precision)})`)}return x.join(", ")}function yZ(M,Z){const P=[];for(let x=0;x<M.length/2;x++){const c=M[2*x],w=M[2*x+1];P.push(`(${c.toPrecision(Z.precision)}, ${(1-w).toPrecision(Z.precision)})`)}return P.join(", ")}function fZ(M,Z){const P=M.getVerticesData(d.g.PositionKind),x=M.getVerticesData(d.g.NormalKind);if(P&&x)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(M){var Z;const P=null!==(Z=M.Fc())&&void 0!==Z&&Z.length?M.getTotalIndices():M.getTotalVertices();return Array(P/3).fill(3).join(", ")}(M)}]\n\t\tint[] faceVertexIndices = [${function(M){const Z=M.Fc(),P=[];if(null!==Z)for(let x=0;x<Z.length;x++)P.push(Z[x]);else{const Z=M.getTotalVertices();for(let M=0;M<Z;M++)P.push(M)}return P.join(", ")}(M)}]\n\t\tnormal3f[] normals = [${aZ(x,Z)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${aZ(P,Z)}]\n        ${function(M,Z){let P="";for(let c=0;c<4;c++){const x=c>0?c:"",w=M.getVerticesData(d.g.UVKind+(x?x+1:""));w&&(P+=`\n\t\ttexCoord2f[] primvars:st${x} = [${yZ(w,Z)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const x=M.getVerticesData(d.g.ColorKind);return x&&(P+=`\n\tcolor3f[] primvars:displayColor = [${aZ(x,Z,x.length/M.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),P}(M,Z)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function YZ(M,Z){return`\n        def "Geometry"\n        {\n        ${fZ(M,Z)}\n        }\n        `}function zZ(M){let Z='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return Z+=M,fflate.strToU8(Z)}function iZ(M){const Z=M.m;return`( ${TZ(Z,0)}, ${TZ(Z,4)}, ${TZ(Z,8)}, ${TZ(Z,12)} )`}function TZ(M,Z){return`(${M[Z+0]}, ${M[Z+1]}, ${M[Z+2]}, ${M[Z+3]})`}function pZ(M){const Z="Object_"+M.uniqueId,P=function(M){const Z=M.getWorldMatrix().clone(),P=M.DM().useRightHandedSystem;if(!P){let x=M.parent;for(;x;){if(vM(x,P)){Z.multiplyToRef(x.getWorldMatrix().invert(),Z);break}x=x.parent}}return Z.determinant()<0&&c.Tools.Warn(`Exporting mesh ${M.name} with negative scale. Result may look incorrect in destination engine.`),Z}(M),x=iZ(P);return`def Xform "${Z}" (\n\tprepend references = @./geometries/Geometry_${M.tc.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${x}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${M.material.uniqueId}>\n}\n\n`}function SZ(M){switch(M){case D.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case D.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case D.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function XZ(M){return`(${M.x}, ${M.y})`}function VZ(M){return`(${M.r}, ${M.g}, ${M.b})`}function gZ(M,Z,P,c,w,v){const G=M.getInternalTexture().uniqueId+"_"+M.invertY;w[G]=M;const mM=M.coordinatesIndex>0?"st"+M.coordinatesIndex:"st",K=new x.Vector2(M.uScale,M.vScale),d=new x.Vector2(M.uOffset,M.vOffset),O=M.wAng,H=Math.sin(O),j=Math.cos(O);return d.y=1-d.y-K.y,d.x+=H*K.x,d.y+=(1-j)*K.y,`\n    def Shader "PrimvarReader_${P}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${mM}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${P}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${Z.uniqueId}/PrimvarReader_${P}.outputs:result>\n        float inputs:rotation = ${(O*(180/Math.PI)).toFixed(v.precision)}\n        float2 inputs:scale = ${XZ(K)}\n        float2 inputs:translation = ${XZ(d)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${M.uniqueId}_${P}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${G}.png@\n        float2 inputs:st.connect = </Materials/Material_${Z.uniqueId}/Transform2d_${P}.outputs:result>\n        ${c?"float4 inputs:scale = "+function(M){return`(${M.r}, ${M.g}, ${M.b}, 1.0)`}(c):""}\n        token inputs:sourceColorSpace = "${M.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${SZ(M.wrapU)}"\n        token inputs:wrapT = "${SZ(M.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${Z.needAlphaBlending()?"float outputs:a":""}\n    }`}function MP(M,Z,P){const x="\t\t\t",c=[],w=[],{diffuseMap:v,Wc:G,alphaCutOff:mM,emissiveMap:K,emissive:d,normalMap:O,roughnessMap:H,roughnessChannel:j,roughness:B,metalnessMap:U,metalnessChannel:L,metalness:u,aoMap:N,aoMapChannel:J,aoMapIntensity:t,alphaMap:F,ior:D,clearCoatEnabled:l,clearCoat:h,clearCoatMap:Q,clearCoatRoughness:I,clearCoatRoughnessMap:s}=function(M){const Z={diffuseMap:null,Wc:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return M instanceof UM.LZ?{...Z,diffuseMap:M.diffuseTexture,Wc:M.diffuseColor,alphaCutOff:M.alphaCutOff,emissiveMap:M.emissiveTexture,emissive:M.emissiveColor,roughness:1,alphaMap:M.opacityTexture}:M instanceof KZ.b?{...Z,diffuseMap:M._albedoTexture,Wc:M._albedoColor,alphaCutOff:M._alphaCutOff,emissiveMap:M._emissiveTexture,emissive:M._emissiveColor,normalMap:M._bumpTexture,roughnessMap:M._metallicTexture,roughnessChannel:M._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:M._roughness??1,metalnessMap:M._metallicTexture,metalnessChannel:M._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:M._metallic??0,aoMap:M._ambientTexture,aoMapChannel:M._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:M._ambientTextureStrength,alphaMap:M._opacityTexture,ior:M.subSurface.indexOfRefraction,clearCoatEnabled:M.clearCoat.isEnabled,clearCoat:M.clearCoat.Rc,clearCoatMap:M.clearCoat.texture,clearCoatRoughness:M.clearCoat.roughness,clearCoatRoughnessMap:M.clearCoat.useRoughnessFromMainTexture?M.clearCoat.texture:M.clearCoat.textureRoughness}:Z}(M);return null!==v?(c.push(`${x}color3f inputs:diffuseColor.connect = </Materials/Material_${M.uniqueId}/Texture_${v.uniqueId}_diffuse.outputs:rgb>`),M.needAlphaBlending()?c.push(`${x}float inputs:opacity.connect = </Materials/Material_${M.uniqueId}/Texture_${v.uniqueId}_diffuse.outputs:a>`):M.needAlphaTesting()&&(c.push(`${x}float inputs:opacity.connect = </Materials/Material_${M.uniqueId}/Texture_${v.uniqueId}_diffuse.outputs:a>`),c.push(`${x}float inputs:opacityThreshold = ${mM}`)),w.push(gZ(v,M,"diffuse",G,Z,P))):c.push(`${x}color3f inputs:diffuseColor = ${VZ(G||n.uZ.White())}`),null!==K?(c.push(`${x}color3f inputs:emissiveColor.connect = </Materials/Material_${M.uniqueId}/Texture_${K.uniqueId}_emissive.outputs:rgb>`),w.push(gZ(K,M,"emissive",d,Z,P))):d&&d.toLuminance()>0&&c.push(`${x}color3f inputs:emissiveColor = ${VZ(d)}`),null!==O&&(c.push(`${x}normal3f inputs:normal.connect = </Materials/Material_${M.uniqueId}/Texture_${O.uniqueId}_normal.outputs:rgb>`),w.push(gZ(O,M,"normal",null,Z,P))),null!==N&&(c.push(`${x}float inputs:occlusion.connect = </Materials/Material_${M.uniqueId}/Texture_${N.uniqueId}_occlusion.outputs:${J}>`),w.push(gZ(N,M,"occlusion",new n.uZ(t,t,t),Z,P))),null!==H?(c.push(`${x}float inputs:roughness.connect = </Materials/Material_${M.uniqueId}/Texture_${H.uniqueId}_roughness.outputs:${j}>`),w.push(gZ(H,M,"roughness",new n.uZ(B,B,B),Z,P))):c.push(`${x}float inputs:roughness = ${B}`),null!==U?(c.push(`${x}float inputs:metallic.connect = </Materials/Material_${M.uniqueId}/Texture_${U.uniqueId}_metallic.outputs:${L}>`),w.push(gZ(U,M,"metallic",new n.uZ(u,u,u),Z,P))):c.push(`${x}float inputs:metallic = ${u}`),null!==F?(c.push(`${x}float inputs:opacity.connect = </Materials/Material_${M.uniqueId}/Texture_${F.uniqueId}_opacity.outputs:r>`),c.push(`${x}float inputs:opacityThreshold = 0.0001`),w.push(gZ(F,M,"opacity",null,Z,P))):c.push(`${x}float inputs:opacity = ${M.alpha}`),l&&(null!==Q?(c.push(`${x}float inputs:clearcoat.connect = </Materials/Material_${M.uniqueId}/Texture_${Q.uniqueId}_clearcoat.outputs:r>`),w.push(gZ(Q,M,"clearcoat",new n.uZ(h,h,h),Z,P))):c.push(`${x}float inputs:clearcoat = ${h}`),null!==s?(c.push(`${x}float inputs:clearcoatRoughness.connect = </Materials/Material_${M.uniqueId}/Texture_${s.uniqueId}_clearcoatRoughness.outputs:g>`),w.push(gZ(s,M,"clearcoatRoughness",new n.uZ(I,I,I),Z,P))):c.push(`${x}float inputs:clearcoatRoughness = ${I}`)),c.push(`${x}float inputs:ior = ${D}`),`\n\tdef Material "Material_${M.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${c.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${M.uniqueId}/PreviewSurface.outputs:surface>\n\n${w.join("\n")}\n\n\t}\n`}async function ZP(M,Z,P){const w={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...Z};"undefined"===typeof fflate&&await c.Tools.LoadScriptAsync(w.fflateUrl);const v={};v[w.modelFileName]=null;let G='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';G+=function(M){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===M.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${M.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${M.planeAnchoringAlignment}"`:""}\n            `}(w);const mM={};for(const x of M.meshes){if(0===x.getTotalVertices())continue;const M=x,Z=M.tc,K=M.material;if(!K||!Z||P&&!P(M))continue;if(-1!==["LZ","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(K.getClassName())){const P="geometries/Geometry_"+Z.uniqueId+".usda";if(!(P in v)){const M=YZ(Z,w);v[P]=zZ(M)}K.uniqueId in mM||(mM[K.uniqueId]=K),G+=pZ(M)}else c.Tools.Warn("USDZExportAsync does not support this material type: "+K.getClassName())}M.activeCamera&&w.exportCamera&&(G+=function(M,Z){const P="Camera_"+M.uniqueId,c=iZ(x.Matrix.RotationY(Math.PI).multiply(M.getWorldMatrix()));if(M.mode===D.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${P}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${c}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${M.uc.toPrecision(Z.precision)}, ${M.maxZ.toPrecision(Z.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(M.orthoLeft||1)+Math.abs(M.orthoRight||1))).toPrecision(Z.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(M.orthoTop||1)+Math.abs(M.orthoBottom||1))).toPrecision(Z.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const x=M.getEngine().getAspectRatio(M),w=Z.cameraSensorWidth||35;return`def Camera "${P}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${c}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${M.uc.toPrecision(Z.precision)}, ${M.maxZ.toPrecision(Z.precision)})\n\t\t\tfloat focalLength = ${(w/(2*Math.tan(.5*M.fov))).toPrecision(Z.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(w*x).toPrecision(Z.precision)}\n\t\t\tfloat verticalAperture = ${(w/x).toPrecision(Z.precision)}            \n\t\t}\n\t\n\t`}}(M.activeCamera,w)),G+="\n            }\n        }\n    }";const K={};G+=function(M,Z,P){const x=[];for(const c in M){const w=M[c];x.push(MP(w,Z,P))}return`\n    def "Materials"\n{\n${x.join("")}\n}\n\n`}(mM,K,w),v[w.modelFileName]=fflate.strToU8(G);for(const x in K){const M=K[x],Z=M.getSize(),P=await M.readPixels();if(!P)throw new Error("Texture data is not available");const c=await l.DumpTools.DumpDataAsync(Z.width,Z.height,P,"image/png",void 0,!1,!0);v[`textures/Texture_${x}.png`]=new Uint8Array(c).slice()}let d=0;for(const x in v){const M=v[x];if(!M)continue;d+=34+x.length;const Z=63&d;if(4!==Z){const P=new Uint8Array(64-Z);v[x]=[M,{extra:{12345:P}}]}d=M.length}return fflate.zipSync(v,{level:0})}}}]);