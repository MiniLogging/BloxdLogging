"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[26],{13389:(I,x,L)=>{L.r(x),L.d(x,{EXT_materials_diffuse_roughness:()=>kx,EXT_mesh_gpu_instancing:()=>hI,GLTF2Export:()=>oI,GLTFData:()=>l,KHR_draco_mesh_compression:()=>Lx,KHR_lights_punctual:()=>Bx,KHR_materials_anisotropy:()=>Qx,KHR_materials_clearcoat:()=>gx,KHR_materials_diffuse_transmission:()=>Hx,KHR_materials_dispersion:()=>Ux,KHR_materials_emissive_strength:()=>yx,KHR_materials_ior:()=>Zx,KHR_materials_iridescence:()=>fx,KHR_materials_sheen:()=>nx,KHR_materials_specular:()=>dx,KHR_materials_transmission:()=>Kx,KHR_materials_unlit:()=>Ax,KHR_materials_volume:()=>Ox,KHR_texture_transform:()=>Dx,OBJExport:()=>Y,STLExport:()=>rx,USDZExportAsync:()=>xL,_ConvertToGLTFPBRMetallicRoughness:()=>u,_SolveMetallic:()=>K,__IGLTFExporterExtension:()=>p});var F=L(12983),X=L(12791),G=L(13299);class Y{static OBJ(I,x,L,Y){const p=[];let B=1,l=1;x&&(L||(L="mat"),p.push("mtllib "+L+".mtl"));for(let W=0;W<I.length;W++){const L=I[W],Q=L.name||`mesh${W}}`;p.push(`o ${Q}`);let e=null;if(Y){const I=L.LB(!0);e=new F.Matrix,I.invertToRef(e),L.bakeTransformIntoVertices(I)}if(x){const I=L.material;I&&p.push("usemtl "+I.id)}const g=L.FB;if(!g){X.Tools.Warn("No geometry is present on the mesh");continue}const v=g.getVerticesData("position"),z=g.getVerticesData("normal"),H=g.getVerticesData("uv"),s=g.XB();let U=0,q=0;if(!v||!s){X.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const y=I[0].tI().useRightHandedSystem?1:-1;for(let I=0;I<v.length;I+=3)p.push("v "+v[I]*y+" "+v[I+1]+" "+v[I+2]),U++;if(null!=z)for(let I=0;I<z.length;I+=3)p.push("vn "+z[I]*y+" "+z[I+1]+" "+z[I+2]);if(null!=H)for(let I=0;I<H.length;I+=2)p.push("vt "+H[I]+" "+H[I+1]),q++;const T=["","",""],Z=(L.material||L.tI().defaultMaterial)._getEffectiveOrientation(L),[t,f]=Z===G.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let I=0;I<s.length;I+=3){const x=[String(s[I]+B),String(s[I+t]+B),String(s[I+f]+B)],L=[String(s[I]+l),String(s[I+t]+l),String(s[I+f]+l)],F=x,X=null!=H?L:T,G=null!=z?x:T;p.push("f "+F[0]+"/"+X[0]+"/"+G[0]+" "+F[1]+"/"+X[1]+"/"+G[1]+" "+F[2]+"/"+X[2]+"/"+G[2])}Y&&e&&L.bakeTransformIntoVertices(e),B+=U,l+=q}return p.join("\n")}static MTL(I){const x=[],L=I.material;x.push("newmtl mat1"),x.push("  Ns "+L.specularPower.toFixed(4)),x.push("  Ni 1.5000"),x.push("  d "+L.alpha.toFixed(4)),x.push("  Tr 0.0000"),x.push("  Tf 1.0000 1.0000 1.0000"),x.push("  illum 2"),x.push("  Ka "+L.ambientColor.r.toFixed(4)+" "+L.ambientColor.g.toFixed(4)+" "+L.ambientColor.b.toFixed(4)),x.push("  Kd "+L.diffuseColor.r.toFixed(4)+" "+L.diffuseColor.g.toFixed(4)+" "+L.diffuseColor.b.toFixed(4)),x.push("  Ks "+L.specularColor.r.toFixed(4)+" "+L.specularColor.g.toFixed(4)+" "+L.specularColor.b.toFixed(4)),x.push("  Ke "+L.emissiveColor.r.toFixed(4)+" "+L.emissiveColor.g.toFixed(4)+" "+L.emissiveColor.b.toFixed(4));L.ambientTexture&&x.push("  map_Ka "+L.ambientTexture.name),L.diffuseTexture&&x.push("  map_Kd "+L.diffuseTexture.name),L.specularTexture&&x.push("  map_Ks "+L.specularTexture.name),L.bumpTexture&&x.push("  map_bump -imfchan z "+L.bumpTexture.name),L.opacityTexture&&x.push("  map_d "+L.opacityTexture.name);return x.join("\n")}}var p=0,B=L(12842);class l{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const I in this.files){const x=this.files[I],L=new Blob([x],{type:(0,B.i)(I)});X.Tools.Download(L,I)}}}var W=L(13048),Q=L(13398),e=L(13411),g=L(13423),v=L(13112),z=L(12840),H=L(13020),s=L(13001);const U=s.HighestCommonFactor,q={...s,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:U};var y=L(13209),T=L(12965),Z=L(13451),t=L(13456),f=L(13202);const R=1e-6,n=new H.Tx(.04,.04,.04),P=1024,d=H.Tx.White(),M=H.Tx.Black();function K(I,x,L){if(x<n.r)return 0;const F=n.r,X=I*L/(1-n.r)+x-2*n.r,G=X*X-4*F*(n.r-x);return q.Clamp((-X+Math.sqrt(G))/(2*F),0,1)}function u(I){const x=I.diffuseColor.toLinearSpace(I.tI().getEngine().useExactSrgbConversions).scale(.5),L=I.alpha,X=function(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new F.Vector2(0,1),L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new F.Vector2(0,.1),X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new F.Vector2(0,.1),G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new F.Vector2(1300,.1);return function(I,x,L,F,X){return(1-I)*(1-I)*(1-I)*x+3*(1-I)*(1-I)*I*L+3*(1-I)*I*I*F+I*I*I*X}(Math.pow(I/G.x,.333333),x.y,L.y,X.y,G.y)}(q.Clamp(I.specularPower,0,P));return{baseColorFactor:[x.r,x.g,x.b,L],metallicFactor:0,roughnessFactor:X}}function A(I,x){x.needAlphaBlending()?I.alphaMode="BLEND":x.needAlphaTesting()&&(I.alphaMode="MASK",I.alphaCutoff=x.alphaCutOff)}function mI(I,x,L){const F=new Uint8Array(I*x*4);for(let X=0;X<F.length;X+=4)F[X]=F[X+1]=F[X+2]=F[X+3]=255;return Z.c.CreateRGBATexture(F,I,x,L)}function O(I){if(I instanceof Uint8Array){const x=I.length,L=new Float32Array(I.length);for(let F=0;F<x;++F)L[F]=I[F]/255;return L}if(I instanceof Float32Array)return I;throw new Error("Unsupported pixel format!")}class w{constructor(I){this._exporter=I,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(I){return I?this._textureMap.get(I)??null:null}async exportStandardMaterialAsync(I,x,L){const F=u(I),G={name:I.name};if(null==I.GB||I.GB||(I.twoSidedLighting||X.Tools.Warn(I.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),G.doubleSided=!0),L){const L=[],X=I.diffuseTexture;X&&L.push(this.exportTextureAsync(X,x).then((I=>{I&&(F.baseColorTexture=I)})));const Y=I.bumpTexture;Y&&L.push(this.exportTextureAsync(Y,x).then((I=>{I&&(G.normalTexture=I,1!==Y.level&&(G.normalTexture.scale=Y.level))})));const p=I.emissiveTexture;p&&(G.emissiveFactor=[1,1,1],L.push(this.exportTextureAsync(p,x).then((I=>{I&&(G.emissiveTexture=I)}))));const B=I.ambientTexture;B&&L.push(this.exportTextureAsync(B,x).then((I=>{if(I){const x={index:I.index};G.occlusionTexture=x}}))),L.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(L))}(I.alpha<1||I.opacityTexture)&&(I.alphaMode===t.c.ALPHA_COMBINE?G.alphaMode="BLEND":X.Tools.Warn(I.name+": glTF 2.0 does not support alpha mode: "+I.alphaMode.toString())),I.emissiveColor&&!I.emissiveColor.equalsWithEpsilon(M,R)&&(G.emissiveFactor=I.emissiveColor.Cp()),G.pbrMetallicRoughness=F,A(G,I),await this._finishMaterialAsync(G,I,x);const Y=this._exporter._materials;return Y.push(G),Y.length-1}async _finishMaterialAsync(I,x,L){const F=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",I,x),X=[];for(const G of F)X.push(this.exportTextureAsync(G,L));await Promise.all(X),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",I,x)}async _getImageDataAsync(I,x,F,X){const G=t.c.TEXTURETYPE_UNSIGNED_BYTE,Y=this._exporter._babylonScene,p=Y.getEngine(),B=p.createRawTexture(I,x,F,t.c.TEXTUREFORMAT_RGBA,!1,!0,T.d.NEAREST_SAMPLINGMODE,null,G);p.isWebGPU?await L.e(51).then(L.bind(L,15367)):await L.e(52).then(L.bind(L,15376)),await y.i.ApplyPostProcess("pass",B,Y,G,t.c.TEXTURE_NEAREST_SAMPLINGMODE,t.c.TEXTUREFORMAT_RGBA);const l=await p._readTexturePixels(B,x,F);return await f.DumpTools.DumpDataAsync(x,F,l,X,void 0,!0,!0)}_resizeTexturesToSameDimensions(I,x,L){const F=I?I.getSize():{width:0,height:0},X=x?x.getSize():{width:0,height:0};let G,Y;return F.width<X.width?(G=I&&I instanceof T.d?y.i.CreateResizedCopy(I,X.width,X.height,!0):mI(X.width,X.height,L),Y=x):F.width>X.width?(Y=x&&x instanceof T.d?y.i.CreateResizedCopy(x,F.width,F.height,!0):mI(F.width,F.height,L),G=I):(G=I,Y=x),{texture1:G,texture2:Y}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(I,x,L,F){const X=new Array;if(!I&&!x)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const G=I?I.tI():x?x.tI():null;if(G){var Y;const p=this._resizeTexturesToSameDimensions(I,x,G),B=null===(Y=p.texture1)||void 0===Y?void 0:Y.getSize();let l,W;const Q=B.width,e=B.height,g=await p.texture1.readPixels(),v=await p.texture2.readPixels();if(!g)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(l=O(g),!v)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");W=O(v);const z=W.byteLength,s=new Uint8Array(z),U=new Uint8Array(z),q=4,y=M;let T=0,Z=0;for(let I=0;I<e;++I)for(let x=0;x<Q;++x){const F=(Q*I+x)*q,X={diffuseColor:new H.Tx(l[F],l[F+1],l[F+2]).toLinearSpace(G.getEngine().useExactSrgbConversions).multiply(L.diffuseColor),specularColor:new H.Tx(W[F],W[F+1],W[F+2]).toLinearSpace(G.getEngine().useExactSrgbConversions).multiply(L.specularColor),glossiness:W[F+3]*L.glossiness},Y=this._convertSpecularGlossinessToMetallicRoughness(X);y.r=Math.max(y.r,Y.baseColor.r),y.g=Math.max(y.g,Y.baseColor.g),y.b=Math.max(y.b,Y.baseColor.b),T=Math.max(T,Y.metallic),Z=Math.max(Z,Y.roughness),U[F]=255*Y.baseColor.r,U[F+1]=255*Y.baseColor.g,U[F+2]=255*Y.baseColor.b,U[F+3]=p.texture1.bp?255*l[F+3]:255,s[F]=0,s[F+1]=255*Y.roughness,s[F+2]=255*Y.metallic,s[F+3]=255}const t={baseColor:y,metallic:T,roughness:Z};let f=!1,n=!1;for(let I=0;I<e;++I)for(let x=0;x<Q;++x){const L=(Q*I+x)*q;U[L]/=t.baseColor.r>R?t.baseColor.r:1,U[L+1]/=t.baseColor.g>R?t.baseColor.g:1,U[L+2]/=t.baseColor.b>R?t.baseColor.b:1;const F=H.Tx.FromInts(U[L],U[L+1],U[L+2]).toGammaSpace(G.getEngine().useExactSrgbConversions);U[L]=255*F.r,U[L+1]=255*F.g,U[L+2]=255*F.b,F.equalsWithEpsilon(d,R)||(n=!0),s[L+1]/=t.roughness>R?t.roughness:1,s[L+2]/=t.metallic>R?t.metallic:1;H.Tx.FromInts(255,s[L+1],s[L+2]).equalsWithEpsilon(d,R)||(f=!0)}return f&&X.push(this._getImageDataAsync(s,Q,e,F).then((I=>{t.metallicRoughnessTextureData=I}))),n&&X.push(this._getImageDataAsync(U,Q,e,F).then((I=>{t.baseColorTextureData=I}))),await Promise.all(X).then((()=>t))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(I){const x=this._getPerceivedBrightness(I.diffuseColor),L=this._getPerceivedBrightness(I.specularColor),F=1-this._getMaxComponent(I.specularColor),X=K(x,L,F),G=I.diffuseColor.scale(F/(1-n.r)/Math.max(1-X)),Y=I.specularColor.Ux(n.scale(1-X)).scale(1/Math.max(X));let p=H.Tx.Lerp(G,Y,X*X);p=p.clampToRef(0,1,p);return{baseColor:p,metallic:X,roughness:1-I.glossiness}}_getPerceivedBrightness(I){return I?Math.sqrt(.299*I.r*I.r+.587*I.g*I.g+.114*I.b*I.b):0}_getMaxComponent(I){return I?Math.max(I.r,Math.max(I.g,I.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(I,x,L,F){const X=[],G={baseColor:I._albedoColor,metallic:I._metallic,roughness:I._roughness};if(F){I._albedoTexture&&X.push(this.exportTextureAsync(I._albedoTexture,x).then((I=>{I&&(L.baseColorTexture=I)})));const F=I._metallicTexture;F&&X.push(this.exportTextureAsync(F,x).then((I=>{I&&(L.metallicRoughnessTexture=I)})))}return X.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(X)),G}_getTextureSampler(I){const x={};if(!I||!(I instanceof T.d))return x;const L=this._getGLTFTextureWrapMode(I.wrapU);10497!==L&&(x.wrapS=L);const F=this._getGLTFTextureWrapMode(I.wrapV);switch(10497!==F&&(x.wrapT=F),I.samplingMode){case T.d.LINEAR_LINEAR:x.magFilter=9729,x.minFilter=9729;break;case T.d.LINEAR_NEAREST:x.magFilter=9729,x.minFilter=9728;break;case T.d.NEAREST_LINEAR:x.magFilter=9728,x.minFilter=9729;break;case T.d.NEAREST_LINEAR_MIPLINEAR:x.magFilter=9728,x.minFilter=9987;break;case T.d.NEAREST_NEAREST:x.magFilter=9728,x.minFilter=9728;break;case T.d.NEAREST_LINEAR_MIPNEAREST:x.magFilter=9728,x.minFilter=9985;break;case T.d.LINEAR_NEAREST_MIPNEAREST:x.magFilter=9729,x.minFilter=9984;break;case T.d.LINEAR_NEAREST_MIPLINEAR:x.magFilter=9729,x.minFilter=9986;break;case T.d.NEAREST_NEAREST_MIPLINEAR:x.magFilter=9728,x.minFilter=9986;break;case T.d.LINEAR_LINEAR_MIPLINEAR:x.magFilter=9729,x.minFilter=9987;break;case T.d.LINEAR_LINEAR_MIPNEAREST:x.magFilter=9729,x.minFilter=9985;break;case T.d.NEAREST_NEAREST_MIPNEAREST:x.magFilter=9728,x.minFilter=9984}return x}_getGLTFTextureWrapMode(I){switch(I){case T.d.WRAP_ADDRESSMODE:return 10497;case T.d.CLAMP_ADDRESSMODE:return 33071;case T.d.MIRROR_ADDRESSMODE:return 33648;default:return X.Tools.Error(`Unsupported Texture Wrap Mode ${I}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(I,x,L,F){const X={diffuseColor:I._albedoColor,specularColor:I._reflectivityColor,glossiness:I._microSurface},G=I._albedoTexture,Y=I._reflectivityTexture,p=I._useMicroSurfaceFromReflectivityMapAlpha;if(Y&&!p)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((G||Y)&&F){this._exporter._materialNeedsUVsSet.add(I);const F=this._exportTextureSampler(G||Y),p=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(G,Y,X,x),B=this._exporter._textures;if(p.baseColorTextureData){const I=this._exportImage(`baseColor${B.length}`,x,p.baseColorTextureData);L.baseColorTexture=this._exportTextureInfo(I,F,null===G||void 0===G?void 0:G.coordinatesIndex)}if(p.metallicRoughnessTextureData){const I=this._exportImage(`metallicRoughness${B.length}`,x,p.metallicRoughnessTextureData);L.metallicRoughnessTexture=this._exportTextureInfo(I,F,null===Y||void 0===Y?void 0:Y.coordinatesIndex)}return p}return this._convertSpecularGlossinessToMetallicRoughness(X)}async exportPBRMaterialAsync(I,x,L){const F={},X={name:I.name},G=I.isMetallicWorkflow();if(G){const x=I._albedoColor,L=I.alpha;x&&(F.baseColorFactor=[x.r,x.g,x.b,L])}const Y=G?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(I,x,F,L):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(I,x,F,L);await this._setMetallicRoughnessPbrMaterialAsync(Y,I,X,F,x,L),await this._finishMaterialAsync(X,I,x);const p=this._exporter._materials;return p.push(X),p.length-1}async _setMetallicRoughnessPbrMaterialAsync(I,x,L,F,G,Y){if(A(L,x),I.baseColor.equalsWithEpsilon(d,R)&&q.WithinEpsilon(x.alpha,1,R)||(F.baseColorFactor=[I.baseColor.r,I.baseColor.g,I.baseColor.b,x.alpha]),null!=I.metallic&&1!==I.metallic&&(F.metallicFactor=I.metallic),null!=I.roughness&&1!==I.roughness&&(F.roughnessFactor=I.roughness),null==x.GB||x.GB||(x._twoSidedLighting||X.Tools.Warn(x.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),L.doubleSided=!0),Y){const I=[],F=x._bumpTexture;F&&I.push(this.exportTextureAsync(F,G).then((I=>{I&&(L.normalTexture=I,1!==F.level&&(L.normalTexture.scale=F.level))})));const X=x._ambientTexture;X&&I.push(this.exportTextureAsync(X,G).then((I=>{if(I){const F={index:I.index,texCoord:I.texCoord,extensions:I.extensions};L.occlusionTexture=F;const X=x._ambientTextureStrength;X&&(F.strength=X)}})));const Y=x._emissiveTexture;Y&&I.push(this.exportTextureAsync(Y,G).then((I=>{I&&(L.emissiveTexture=I)}))),I.length>0&&(this._exporter._materialNeedsUVsSet.add(x),await Promise.all(I))}const p=x._emissiveColor;p.equalsWithEpsilon(M,R)||(L.emissiveFactor=p.Cp()),L.pbrMetallicRoughness=F}_getPixelsFromTextureAsync(I){return function(I){switch(I){case t.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case t.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case t.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case t.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case t.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case t.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case t.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case t.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case t.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case t.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case t.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case t.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(I.textureFormat)?(0,y.h)(I,I._texture.width,I._texture.height):(I.textureType,t.c.TEXTURETYPE_UNSIGNED_BYTE,I.readPixels())}async exportTextureAsync(I,x){const L=this._exporter._extensionsPreExportTextureAsync("exporter",I,x);return L?await L.then((async L=>L?await this._exportTextureInfoAsync(L,x):await this._exportTextureInfoAsync(I,x))):await this._exportTextureInfoAsync(I,x)}async _exportTextureInfoAsync(I,x){let L=this._textureMap.get(I);if(!L){const F=await this._getPixelsFromTextureAsync(I);if(!F)return null;const G=this._exportTextureSampler(I),Y=I.mimeType;if(Y)switch(Y){case"image/jpeg":case"image/png":case"image/webp":x=Y;break;default:X.Tools.Warn(`Unsupported media type: ${Y}. Exporting texture as PNG.`)}const p=this._internalTextureToImage,B=I.getInternalTexture().uniqueId;p[B]||(p[B]={});let l=p[B][x];if(void 0===l){const L=I.getSize();l=(async()=>{const X=await this._getImageDataAsync(F,L.width,L.height,x);return this._exportImage(I.name,x,X)})(),p[B][x]=l}L=this._exportTextureInfo(await l,G,I.coordinatesIndex),this._textureMap.set(I,L),this._exporter._extensionsPostExportTextures("exporter",L,I)}return L}_exportImage(I,x,L){const F=this._exporter._images;let G;if(this._exporter._shouldUseGlb){G={name:I,mimeType:x,bufferView:void 0};const F=this._exporter._bufferManager.createBufferView(new Uint8Array(L));this._exporter._bufferManager.setBufferView(G,F)}else{const Y=I.replace(/\.\/|\/|\.\\|\\/g,"_"),p=function(I){switch(I){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(x);let B=Y+p;F.some((I=>I.uri===B))&&(B=`${Y}_${X.Tools.RandomId()}${p}`),G={name:I,uri:B},this._exporter._imageData[B]={data:L,mimeType:x}}return F.push(G),F.length-1}_exportTextureInfo(I,x,L){const F=this._exporter._textures;let X=F.findIndex((L=>L.sampler==x&&L.source===I));-1===X&&(X=F.length,F.push({source:I,sampler:x}));const G={index:X};return L&&(G.texCoord=L),G}_exportTextureSampler(I){const x=this._getTextureSampler(I),L=this._exporter._samplers,F=L.findIndex((I=>I.minFilter===x.minFilter&&I.magFilter===x.magFilter&&I.wrapS===x.wrapS&&I.wrapT===x.wrapT));return-1!==F?F:(L.push(x),L.length-1)}}var k=L(13061),a=L(12809),D=L(13459),r=L(12989);const N=F.sx.Zero(),S=F.Quaternion.Identity(),c=F.sx.One(),o=new F.sx(-1,1,1);function J(I,x){const{byteOffset:L,byteStride:F,type:X,normalized:G}=I,Y=I.getSize(),p=x.reduce(((I,x)=>x.getTotalVertices()>I?x.getTotalVertices():I),-Number.MAX_VALUE);return{byteOffset:L,byteStride:F,componentCount:Y,type:X,count:p*Y,normalized:G,totalVertices:p,kind:I.getKind()}}function h(I){switch(I){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function E(I){switch(I){case W.g.PositionKind:case W.g.NormalKind:case W.g.TangentKind:case W.g.ColorKind:case W.g.MatricesIndicesKind:case W.g.MatricesIndicesExtraKind:case W.g.MatricesWeightsKind:case W.g.MatricesWeightsExtraKind:case W.g.UVKind:case W.g.UV2Kind:case W.g.UV3Kind:case W.g.UV4Kind:case W.g.UV5Kind:case W.g.UV6Kind:return!0}return!1}function i(I){switch(I){case G.e.TriangleFillMode:return 4;case G.e.TriangleStripDrawMode:return 5;case G.e.TriangleFanDrawMode:return 6;case G.e.PointListDrawMode:case G.e.PointFillMode:return 0;case G.e.LineLoopDrawMode:return 2;case G.e.LineListDrawMode:return 1;case G.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${I}`)}function V(I){const x=Math.sqrt(I.x*I.x+I.y*I.y+I.z*I.z);x>0&&(I.x/=x,I.y/=x,I.z/=x)}function j(I){return I.x*=-1,I}function C(I){if(I.x*I.x+I.y*I.y>.5){const x=Math.abs(I.x),L=Math.abs(I.y);if(x>L){const L=Math.sign(I.x);I.x=x,I.y*=-L,I.z*=-L,I.w*=L}else{const x=Math.sign(I.y);I.x*=-x,I.y=L,I.z*=x,I.w*=-x}}else{const x=Math.abs(I.z),L=Math.abs(I.w);if(x>L){const L=Math.sign(I.z);I.x*=-L,I.y*=L,I.z=x,I.w*=-L}else{const x=Math.sign(I.w);I.x*=x,I.y*=-x,I.z*=-x,I.w=L}}return I}function b(I){I.YB(-I.z,I.w,I.x,-I.y)}function II(I,x){const L=F.sx.FromArrayToRef(x.translation||[0,0,0],0,F.TmpVectors.sx[0]),X=F.Quaternion.FromArrayToRef(x.rotation||[0,0,0,1],0,F.TmpVectors.Quaternion[0]),G=F.Matrix.ComposeToRef(c,X,L,F.TmpVectors.Matrix[0]),Y=F.sx.FromArrayToRef(I.translation||[0,0,0],0,F.TmpVectors.sx[2]),p=F.Quaternion.FromArrayToRef(I.rotation||[0,0,0,1],0,F.TmpVectors.Quaternion[1]),B=F.Matrix.ComposeToRef(c,p,Y,F.TmpVectors.Matrix[1]);G.multiplyToRef(B,B),B.decompose(void 0,X,L),L.equalsWithEpsilon(N,r.e)?delete x.translation:x.translation=L.Cp(),X.equalsWithEpsilon(S,r.e)?delete x.rotation:x.rotation=X.Cp(),x.scale&&delete x.scale}function xI(I,x){if(!(x instanceof Q.c))return!1;if(!(1===x.getChildren().length&&0===I.getChildren().length&&I.parent===x))return!1;const L=I.tI(),F=I instanceof D.b&&!L.useRightHandedSystem?o:c;return!!x.pB.equalsWithEpsilon(F,r.e)||(a.c.Warn(`Cannot collapse node ${I.name} into parent node ${x.name} with modified scaling.`),!1)}function LI(I){if(I instanceof Array){const x=new Float32Array(I);return new Uint8Array(x.buffer,x.byteOffset,x.byteLength)}return ArrayBuffer.isView(I)?new Uint8Array(I.buffer,I.byteOffset,I.byteLength):new Uint8Array(I)}function FI(I,x){for(const[L,F]of Object.entries(I)){const X=x[L];(Array.isArray(F)&&Array.isArray(X)&&XI(F,X)||F===X)&&delete I[L]}return I}function XI(I,x){return I.length===x.length&&I.every(((I,L)=>I===x[L]))}const GI=F.Matrix.Compose(new F.sx(-1,1,1),F.Quaternion.Identity(),F.sx.Zero());function YI(I,x){if(!(I instanceof Q.c))return!1;if(x){if(!I.getWorldMatrix().equalsWithEpsilon(F.Matrix.IdentityReadOnly,r.e))return!1}else{if(!I.getWorldMatrix().multiplyToRef(GI,F.TmpVectors.Matrix[0]).equalsWithEpsilon(F.Matrix.IdentityReadOnly,r.e))return!1}return!(I instanceof e.b&&I.FB)}const pI=new Map([[Int8Array,(I,x,L)=>I.setInt8(x,L)],[Uint8Array,(I,x,L)=>I.setUint8(x,L)],[Uint8ClampedArray,(I,x,L)=>I.setUint8(x,L)],[Int16Array,(I,x,L)=>I.setInt16(x,L,!0)],[Uint16Array,(I,x,L)=>I.setUint16(x,L,!0)],[Int32Array,(I,x,L)=>I.setInt32(x,L,!0)],[Uint32Array,(I,x,L)=>I.setUint32(x,L,!0)],[Float32Array,(I,x,L)=>I.setFloat32(x,L,!0)],[Float64Array,(I,x,L)=>I.setFloat64(x,L,!0)]]);class BI{writeTypedArray(I){this._checkGrowBuffer(I.byteLength);const x=pI.get(I.constructor);for(let L=0;L<I.length;L++)x(this._dataView,this._byteOffset,I[L]),this._byteOffset+=I.BYTES_PER_ELEMENT}constructor(I){this._data=new Uint8Array(I),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(I){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,I),this._byteOffset++}writeInt8(I){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,I),this._byteOffset++}writeInt16(I){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,I,!0),this._byteOffset+=2}writeUInt16(I){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,I,!0),this._byteOffset+=2}writeInt32(I){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,I,!0),this._byteOffset+=4}writeUInt32(I){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,I,!0),this._byteOffset+=4}writeFloat32(I){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,I,!0),this._byteOffset+=4}writeFloat64(I){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,I,!0),this._byteOffset+=8}_checkGrowBuffer(I){const x=this.byteOffset+I;if(x>this._data.byteLength){const I=new Uint8Array(2*x);I.set(this._data),this._data=I,this._dataView=new DataView(this._data.buffer)}}}function lI(I){return I%4===0?4:I%2===0?2:1}class WI{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(I){let x=0;this._bufferViewToData.forEach((I=>{x+=I.byteLength}));const L=new BI(x),F=Array.from(this._bufferViewToData.keys()).sort(((I,x)=>lI(x.byteLength)-lI(I.byteLength)));for(const X of F){X.byteOffset=L.byteOffset,I.push(X);const x=I.length-1,F=this.getPropertiesWithBufferView(X);for(const I of F)I.bufferView=x;L.writeTypedArray(this._bufferViewToData.get(X)),this._bufferViewToData.delete(X)}return L.getOutputData()}createBufferView(I,x){const L={buffer:0,byteOffset:void 0,byteLength:I.byteLength,byteStride:x};return this._bufferViewToData.set(L,I),L}createAccessor(I,x,L,F,X,G,Y){this._verifyBufferView(I);const p={bufferView:void 0,componentType:L,count:F,type:x,min:null===G||void 0===G?void 0:G.min,max:null===G||void 0===G?void 0:G.max,normalized:Y,byteOffset:X};return this.setBufferView(p,I),this._accessorToBufferView.set(p,I),p}setBufferView(I,x){this._verifyBufferView(x);this.getPropertiesWithBufferView(x).push(I)}removeBufferView(I){const x=this.getPropertiesWithBufferView(I);for(const L of x)void 0!==L.bufferView&&delete L.bufferView;this._bufferViewToData.delete(I),this._bufferViewToProperties.delete(I),this._accessorToBufferView.forEach(((x,L)=>{x===I&&(void 0!==L.byteOffset&&delete L.byteOffset,this._accessorToBufferView.delete(L))}))}getBufferView(I){const x=this._accessorToBufferView.get(I);return this._verifyBufferView(x),x}getPropertiesWithBufferView(I){return this._verifyBufferView(I),this._bufferViewToProperties.set(I,this._bufferViewToProperties.get(I)??[]),this._bufferViewToProperties.get(I)}getData(I){return this._verifyBufferView(I),this._bufferViewToData.get(I)}_verifyBufferView(I){if(void 0===I||!this._bufferViewToData.has(I))throw new Error(`BufferView ${I} not found in BufferManager.`)}}var QI,eI=L(13434),gI=L(13448),vI=L(13466),zI=L(13349),HI=L(13490),sI=L(13499),UI=L(13426),qI=L(13507);!function(I){I[I.INTANGENT=0]="INTANGENT",I[I.OUTTANGENT=1]="OUTTANGENT"}(QI||(QI={}));class yI{static _IsTransformable(I){return I&&(I instanceof Q.c||I instanceof eI.b||I instanceof qI.c)}static _CreateNodeAnimation(I,x,L,F,G){if(this._IsTransformable(I)){const Y=[],p=[],B=x.getKeys(),l=yI._CalculateMinMaxKeyFrames(B),W=yI._DeduceInterpolation(B,L,F),Q=W.interpolationType,e=W.shouldBakeAnimation;if(e?yI._CreateBakedAnimation(I,x,L,l.min,l.max,x.framePerSecond,G,Y,p,l,F):"LINEAR"===Q||"STEP"===Q?yI._CreateLinearOrStepAnimation(I,x,L,Y,p,F):"CUBICSPLINE"===Q?yI._CreateCubicSplineAnimation(I,x,L,Y,p,F):yI._CreateBakedAnimation(I,x,L,l.min,l.max,x.framePerSecond,G,Y,p,l,F),Y.length&&p.length){return{inputs:Y,outputs:p,samplerInterpolation:Q,inputsMin:e?l.min:X.Tools.FloatRound(l.min/x.framePerSecond),inputsMax:e?l.max:X.Tools.FloatRound(l.max/x.framePerSecond)}}}return null}static _DeduceAnimationInfo(I){let x=null,L="VEC3",F=!1;const G=I.targetProperty.split(".");switch(G[0]){case"pB":x="scale";break;case"position":x="translation";break;case"rotation":L="VEC4",x="rotation";break;case"rotationQuaternion":L="VEC4",F=!0,x="rotation";break;case"influence":L="SCALAR",x="weights";break;default:X.Tools.Error(`Unsupported animatable property ${G[0]}`)}return x?{animationChannelTargetPath:x,dataAccessorType:L,useQuaternion:F}:(X.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(I,x,L,F,X,G,Y,p,B,l,W){let Q;if(yI._IsTransformable(I)&&I.animations)for(const e of I.animations){if(W&&!W(e))continue;const X=yI._DeduceAnimationInfo(e);X&&(Q={name:e.name,samplers:[],channels:[]},yI._AddAnimation(`${e.name}`,e.hasRunningRuntimeAnimations?x:Q,I,e,X.dataAccessorType,X.animationChannelTargetPath,F,G,Y,p,X.useQuaternion,B,l),Q.samplers.length&&Q.channels.length&&L.push(Q))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(I,x,L,F,X,G,Y,p,B,l,W){let Q;if(I instanceof UI.e){const X=I.morphTargetManager;if(X)for(let e=0;e<X.numTargets;++e){const g=X.getTarget(e);for(const v of g.animations){if(W&&!W(v))continue;const g=new HI.d(`${v.name}`,"influence",v.framePerSecond,v.dataType,v.loopMode,v.enableBlending),z=[],H=v.getKeys();for(let I=0;I<H.length;++I){const x=H[I];for(let I=0;I<X.numTargets;++I)I==e?z.push(x):z.push({frame:x.frame,value:0})}g.setKeys(z);const s=yI._DeduceAnimationInfo(g);s&&(Q={name:g.name,samplers:[],channels:[]},yI._AddAnimation(v.name,v.hasRunningRuntimeAnimations?x:Q,I,g,s.dataAccessorType,s.animationChannelTargetPath,F,G,Y,p,s.useQuaternion,B,l,X.numTargets),Q.samplers.length&&Q.channels.length&&L.push(Q))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(I,x,L,F,X,G,Y,p,B){let l;if(I.animationGroups){const Q=I.animationGroups;for(const e of Q){const Q=new Map,g=new Map,v=new Set,z=e.to-e.from;l={name:e.name,channels:[],samplers:[]};for(let x=0;x<e.targetedAnimations.length;++x){const z=e.targetedAnimations[x],H=z.target,s=z.animation;if(B&&!B(s))continue;const U=p.has(H);if(this._IsTransformable(H)||1===H.length&&this._IsTransformable(H[0])){const I=yI._DeduceAnimationInfo(z.animation);if(I){const x=this._IsTransformable(H)?H:this._IsTransformable(H[0])?H[0]:null;x&&yI._AddAnimation(`${s.name}`,l,x,s,I.dataAccessorType,I.animationChannelTargetPath,L,F,X,G,I.useQuaternion,Y,U)}}else if(H instanceof sI.e||1===H.length&&H[0]instanceof sI.e){if(yI._DeduceAnimationInfo(z.animation)){const x=H instanceof sI.e?H:H[0];if(x){const L=I.morphTargetManagers.find((I=>{for(let L=0;L<I.numTargets;++L)if(I.getTarget(L)===x)return!0;return!1}));if(L){const F=I.meshes.find((I=>I.morphTargetManager===L));var W;if(F)Q.has(F)||Q.set(F,new Map),null===(W=Q.get(F))||void 0===W||W.set(x,s),v.add(F),g.set(F,s)}}}}}v.forEach((I=>{const x=I.morphTargetManager;let p=null;const B=[],W=g.get(I).getKeys(),v=W.length;for(let L=0;L<v;++L)for(let F=0;F<x.numTargets;++F){const X=x.getTarget(F),G=Q.get(I);if(G){const x=G.get(X);x?(p||(p=new HI.d(`${e.name}_${I.name}_MorphWeightAnimation`,"influence",x.framePerSecond,HI.d.ANIMATIONTYPE_FLOAT,x.loopMode,x.enableBlending)),B.push(x.getKeys()[L])):B.push({frame:e.from+z/v*L,value:X.influence,inTangent:W[0].inTangent?0:void 0,outTangent:W[0].outTangent?0:void 0})}}p.setKeys(B);const H=yI._DeduceAnimationInfo(p);H&&yI._AddAnimation(`${e.name}_${I.name}_MorphWeightAnimation`,l,I,p,H.dataAccessorType,H.animationChannelTargetPath,L,F,X,G,H.useQuaternion,Y,!1,null===x||void 0===x?void 0:x.numTargets)})),l.channels.length&&l.samplers.length&&x.push(l)}}}static _AddAnimation(I,x,L,X,G,Y,p,B,l,W,Q,e,g,v){const z=yI._CreateNodeAnimation(L,X,Y,Q,e);let H,s,U,q,y,T;if(z){if(v){let I=0,x=0;const L=[];for(;z.inputs.length>0;)x=z.inputs.shift(),I%v==0&&L.push(x),I++;z.inputs=L}const I=p.get(L),X=new Float32Array(z.inputs);H=B.createBufferView(X),s=B.createAccessor(H,"SCALAR",5126,z.inputs.length,void 0,{min:[z.inputsMin],max:[z.inputsMax]}),W.push(s),U=W.length-1;const l=new F.Quaternion,Q=new F.sx,e=new F.sx,Z=L instanceof eI.b,t=h(G),f=new Float32Array(z.outputs.length*t);z.outputs.forEach((function(I,x){let L=I;switch(Y){case"translation":g&&(F.sx.FromArrayToRef(I,0,e),j(e),e.toArray(L));break;case"rotation":4===I.length?F.Quaternion.FromArrayToRef(I,0,l):(L=new Array(4),F.sx.FromArrayToRef(I,0,Q),F.Quaternion.FromEulerVectorToRef(Q,l)),g&&(C(l),Z&&b(l)),l.toArray(L)}f.set(L,x*t)})),H=B.createBufferView(f),s=B.createAccessor(H,G,5126,z.outputs.length),W.push(s),q=W.length-1,y={interpolation:z.samplerInterpolation,input:U,output:q},x.samplers.push(y),T={sampler:x.samplers.length-1,target:{node:I,path:Y}},x.channels.push(T)}}static _CreateBakedAnimation(I,x,L,G,Y,p,B,l,W,Q,e){let g;const v=F.Quaternion.Identity();let z,H=null,s=null,U=null,q=null,y=null,T=null;Q.min=X.Tools.FloatRound(G/p);const Z=x.getKeys();for(let F=0,t=Z.length;F<t;++F){if(T=null,U=Z[F],F+1<t)if(q=Z[F+1],U.value.equals&&U.value.equals(q.value)||U.value===q.value){if(0!==F)continue;T=U.frame}else T=q.frame;else{if(y=Z[F-1],U.value.equals&&U.value.equals(y.value)||U.value===y.value)continue;T=Y}if(T)for(let F=U.frame;F<=T;F+=B){if(z=X.Tools.FloatRound(F/p),z===H)continue;H=z,s=z;const G={key:0,repeatCount:0,loopMode:x.loopMode};g=x._interpolate(F,G),yI._SetInterpolatedValue(I,g,z,x,L,v,l,W,e)}}s&&(Q.max=s)}static _ConvertFactorToVector3OrQuaternion(I,x,L,G,Y){const p=yI._GetBasePositionRotationOrScale(x,G,Y),B=L.targetProperty.split("."),l=B?B[1]:"",W=Y?F.Quaternion.tx(p).normalize():F.sx.tx(p);switch(l){case"x":case"y":case"z":W[l]=I;break;case"w":W.w=I;break;default:X.Tools.Error(`glTFAnimation: Unsupported component name "${l}"!`)}return W}static _SetInterpolatedValue(I,x,L,X,G,Y,p,B,l){let W;p.push(L),"weights"!==G?(X.dataType===HI.d.ANIMATIONTYPE_FLOAT&&(x=this._ConvertFactorToVector3OrQuaternion(x,I,X,G,l)),"rotation"===G?(l?Y=x:(W=x,F.Quaternion.RotationYawPitchRollToRef(W.y,W.x,W.z,Y)),B.push(Y.Cp())):(W=x,B.push(W.Cp()))):B.push([x])}static _CreateLinearOrStepAnimation(I,x,L,F,X,G){for(const Y of x.getKeys())F.push(Y.frame/x.framePerSecond),yI._AddKeyframeValue(Y,x,X,L,I,G)}static _CreateCubicSplineAnimation(I,x,L,F,X,G){x.getKeys().forEach((function(Y){F.push(Y.frame/x.framePerSecond),yI._AddSplineTangent(QI.INTANGENT,X,L,"CUBICSPLINE",Y,G),yI._AddKeyframeValue(Y,x,X,L,I,G),yI._AddSplineTangent(QI.OUTTANGENT,X,L,"CUBICSPLINE",Y,G)}))}static _GetBasePositionRotationOrScale(I,x,L){let X;if("rotation"===x)if(L){X=(I.rotationQuaternion??F.Quaternion.Identity()).Cp()}else{X=(I.rotation??F.sx.Zero()).Cp()}else if("translation"===x){X=(I.position??F.sx.Zero()).Cp()}else{X=(I.pB??F.sx.One()).Cp()}return X}static _AddKeyframeValue(I,x,L,G,Y,p){let B;const l=x.dataType;if(l===HI.d.ANIMATIONTYPE_VECTOR3){let x=I.value.Cp();if("rotation"===G){const I=F.sx.tx(x);x=F.Quaternion.RotationYawPitchRoll(I.y,I.x,I.z).Cp()}L.push(x)}else if(l===HI.d.ANIMATIONTYPE_FLOAT){if("weights"===G)L.push([I.value]);else if(B=this._ConvertFactorToVector3OrQuaternion(I.value,Y,x,G,p),B){if("rotation"===G){const I=p?B:F.Quaternion.RotationYawPitchRoll(B.y,B.x,B.z).normalize();L.push(I.Cp())}L.push(B.Cp())}}else l===HI.d.ANIMATIONTYPE_QUATERNION?L.push(I.value.normalize().Cp()):X.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(I,x,L){let F,X,G=!1;if("rotation"===x&&!L)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let Y=0,p=I.length;Y<p;++Y)if(X=I[Y],X.inTangent||X.outTangent)if(F){if("CUBICSPLINE"!==F){F="LINEAR",G=!0;break}}else F="CUBICSPLINE";else if(F){if("CUBICSPLINE"===F||X.interpolation&&1===X.interpolation&&"STEP"!==F){F="LINEAR",G=!0;break}}else F=X.interpolation&&1===X.interpolation?"STEP":"LINEAR";return F||(F="LINEAR"),{interpolationType:F,shouldBakeAnimation:G}}static _AddSplineTangent(I,x,L,X,G,Y){let p;const B=I===QI.INTANGENT?G.inTangent:G.outTangent;if("CUBICSPLINE"===X){if("rotation"===L)if(B)if(Y)p=B.Cp();else{const I=B;p=F.Quaternion.RotationYawPitchRoll(I.y,I.x,I.z).Cp()}else p=[0,0,0,0];else p="weights"===L?B?[B]:[0]:B?B.Cp():[0,0,0];x.push(p)}}static _CalculateMinMaxKeyFrames(I){let x=1/0,L=-1/0;return I.forEach((function(I){x=Math.min(x,I.frame),L=Math.max(L,I.frame)})),{min:x,max:L}}}function TI(I,x,L,G,Y,p){const B={attributes:{},influence:I.influence,name:I.name},l=x.FB;if(!l)return X.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),B;const Q=p?-1:1,e=F.sx.Zero();let g=0,v=0;if(I.hasPositions){const G=I.getPositions(),p=l.getVerticesData(W.g.PositionKind);if(p){const I=new Float32Array(p.length),x=[1/0,1/0,1/0],X=[-1/0,-1/0,-1/0];v=p.length/3,g=0;for(let L=g;L<v;++L){const Y=F.sx.tx(p,3*L);F.sx.tx(G,3*L).subtractToRef(Y,e),e.x*=Q,x[0]=Math.min(x[0],e.x),X[0]=Math.max(X[0],e.x),x[1]=Math.min(x[1],e.y),X[1]=Math.max(X[1],e.y),x[2]=Math.min(x[2],e.z),X[2]=Math.max(X[2],e.z),I[3*L]=e.x,I[3*L+1]=e.y,I[3*L+2]=e.z}const l=L.createBufferView(I,12),W=L.createAccessor(l,"VEC3",5126,G.length/3,0,{min:x,max:X});Y.push(W),B.attributes.POSITION=Y.length-1}else X.Tools.Warn(`Morph target positions for mesh ${x.name} were not exported. Mesh does not have position vertex data`)}if(I.hasNormals){const G=I.getNormals(),p=l.getVerticesData(W.g.NormalKind);if(p){const I=new Float32Array(p.length);v=p.length/3,g=0;for(let L=g;L<v;++L){const x=F.sx.tx(p,3*L).normalize();F.sx.tx(G,3*L).normalize().subtractToRef(x,e),I[3*L]=e.x*Q,I[3*L+1]=e.y,I[3*L+2]=e.z}const x=L.createBufferView(I,12),X=L.createAccessor(x,"VEC3",5126,G.length/3,0);Y.push(X),B.attributes.NORMAL=Y.length-1}else X.Tools.Warn(`Morph target normals for mesh ${x.name} were not exported. Mesh does not have normals vertex data`)}if(I.hasTangents){const G=I.getTangents(),p=l.getVerticesData(W.g.TangentKind);if(p){v=p.length/4;const I=new Float32Array(3*v);g=0;for(let L=g;L<v;++L){const x=F.sx.tx(p,4*L);V(x);const X=F.sx.tx(G,3*L);V(X),X.subtractToRef(x,e),I[3*L]=e.x*Q,I[3*L+1]=e.y,I[3*L+2]=e.z}const x=L.createBufferView(I,12),X=L.createAccessor(x,"VEC3",5126,v,0);Y.push(X),B.attributes.TANGENT=Y.length-1}else X.Tools.Warn(`Morph target tangents for mesh ${x.name} were not exported. Mesh does not have tangents vertex data`)}if(I.hasColors){const G=I.getColors(),p=l.getVerticesData(W.g.ColorKind),Q=l.getVertexBuffer(W.g.ColorKind);if(p&&Q){const I=Q.getSize();v=p.length/I;const x=new Float32Array(v*I);g=0;for(let L=g;L<v;++L)if(3===I){const X=F.sx.tx(p,L*I);F.sx.tx(G,L*I).subtractToRef(X,e),x[3*L]=e.x,x[3*L+1]=e.y,x[3*L+2]=e.z}else if(4===I){const X=new F.Vector4,Y=F.Vector4.tx(p,L*I);F.Vector4.tx(G,L*I).subtractToRef(Y,X),x[4*L]=X.x,x[4*L+1]=X.y,x[4*L+2]=X.z,x[4*L+3]=X.w}else X.Tools.Warn(`Unsupported number of components for color attribute: ${I}`);const l=L.createBufferView(x,4*I),W=L.createAccessor(l,3===I?"VEC3":"VEC4",5126,v,0);Y.push(W),B.attributes.COLOR_0=Y.length-1}else X.Tools.Warn(`Morph target colors for mesh ${x.name} were not exported. Mesh does not have colors vertex data`)}return B}var ZI=L(13510),tI=L(13377),fI=L(13365),RI=L(12938);class nI{}nI.DEFAULT_COLOR=H.Tx.White(),nI.DEFAULT_WIDTH_ATTENUATED=1,nI.DEFAULT_WIDTH=.1;var PI=L(13194),dI=L(13517);class MI{static ConvertPoints(I,x){if(I.length&&Array.isArray(I)&&"number"===typeof I[0])return[I];if(I.length&&Array.isArray(I[0])&&"number"===typeof I[0][0])return I;if(I.length&&!Array.isArray(I[0])&&I[0]instanceof F.sx){const x=[];for(let L=0;L<I.length;L++){const F=I[L];x.push(F.x,F.y,F.z)}return[x]}if(I.length>0&&Array.isArray(I[0])&&I[0].length>0&&I[0][0]instanceof F.sx){const x=[],L=I;for(const I of L)x.push(I.flatMap((I=>[I.x,I.y,I.z])));return x}if(I instanceof Float32Array){if(null!==x&&void 0!==x&&x.floatArrayStride){const L=[],F=3*x.floatArrayStride;for(let x=0;x<I.length;x+=F){const X=new Array(F);for(let L=0;L<F;L++)X[L]=I[x+L];L.push(X)}return L}return[Array.from(I)]}if(I.length&&I[0]instanceof Float32Array){const x=[];for(const L of I)x.push(Array.from(L));return x}return[]}static OmitZeroLengthPredicate(I,x,L){const F=[];return x.Ux(I).lengthSquared()>0&&F.push([I,x]),L.Ux(x).lengthSquared()>0&&F.push([x,L]),I.Ux(L).lengthSquared()>0&&F.push([L,I]),0===F.length?null:F}static OmitDuplicatesPredicate(I,x,L,F){const X=[];return MI._SearchInPoints(I,x,F)||X.push([I,x]),MI._SearchInPoints(x,L,F)||X.push([x,L]),MI._SearchInPoints(L,I,F)||X.push([L,I]),0===X.length?null:X}static _SearchInPoints(I,x,L){for(const Y of L)for(let L=0;L<Y.length;L++){var F,X,G;if(null!==(F=Y[L])&&void 0!==F&&F.equals(I))if(null!==(X=Y[L+1])&&void 0!==X&&X.equals(x)||null!==(G=Y[L-1])&&void 0!==G&&G.equals(x))return!0}return!1}static MeshesToLines(I,x){const L=[];for(let X=0;X<I.length;X++){const G=I[X],Y=G.getVerticesData(W.g.PositionKind),p=G.XB();if(Y&&p)for(let I=0,B=0;I<p.length;I++){const l=3*p[B++],W=3*p[B++],Q=3*p[B++],e=new F.sx(Y[l],Y[l+1],Y[l+2]),g=new F.sx(Y[W],Y[W+1],Y[W+2]),v=new F.sx(Y[Q],Y[Q+1],Y[Q+2]);if(x){const F=x(e,g,v,L,I,l,G,X,Y,p);if(F)for(const I of F)L.push(I)}else L.push([e,g],[g,v],[v,e])}}return L}static ToVector3Array(I){if(Array.isArray(I[0])){const x=[],L=I;for(const I of L){const L=[];for(let x=0;x<I.length;x+=3)L.push(new F.sx(I[x],I[x+1],I[x+2]));x.push(L)}return x}const x=I,L=[];for(let X=0;X<x.length;X+=3)L.push(new F.sx(x[X],x[X+1],x[X+2]));return L}static ToNumberArray(I){return I.flatMap((I=>[I.x,I.y,I.z]))}static GetPointsCountInfo(I){const x=new Array(I.length);let L=0;for(let F=I.length;F--;)x[F]=I[F].length/3,L+=x[F];return{total:L,counts:x}}static GetLineLength(I){if(0===I.length)return 0;let x;x="number"===typeof I[0]?MI.ToVector3Array(I):I;const L=F.TmpVectors.sx[0];let X=0;for(let F=0;F<x.length-1;F++){const I=x[F];X+=x[F+1].subtractToRef(I,L).length()}return X}static GetLineLengthArray(I){const x=new Float32Array(I.length/3);let L=0;for(let F=0,X=I.length/3-1;F<X;F++){let X=I[3*F+0],G=I[3*F+1],Y=I[3*F+2];X-=I[3*F+3],G-=I[3*F+4],Y-=I[3*F+5];L+=Math.sqrt(X*X+G*G+Y*Y),x[F+1]=L}return x}static SegmentizeSegmentByCount(I,x,L){const X=[],G=x.Ux(I),Y=F.TmpVectors.sx[0];Y.BB(L);const p=F.TmpVectors.sx[1];G.divideToRef(Y,p);let B=I.clone();X.push(B);for(let F=0;F<L;F++)B=B.clone(),X.push(B.addInPlace(p));return X}static SegmentizeLineBySegmentLength(I,x){const L=I[0]instanceof F.sx?MI.GetLineSegments(I):"number"===typeof I[0]?MI.GetLineSegments(MI.ToVector3Array(I)):I,X=[];for(const F of L)if(F.length>x){const I=MI.SegmentizeSegmentByCount(F.point1,F.point2,Math.ceil(F.length/x));for(const x of I)X.push(x)}else X.push(F.point1),X.push(F.point2);return X}static SegmentizeLineBySegmentCount(I,x){const L="number"===typeof I[0]?MI.ToVector3Array(I):I,F=MI.GetLineLength(L)/x;return MI.SegmentizeLineBySegmentLength(L,F)}static GetLineSegments(I){const x=[];for(let L=0;L<I.length-1;L++){const F=I[L],X=I[L+1],G=X.Ux(F).length();x.push({point1:F,point2:X,length:G})}return x}static GetMinMaxSegmentLength(I){const x=MI.GetLineSegments(I).sort((I=>I.length));return{min:x[0].length,max:x[x.length-1].length}}static GetPositionOnLineByVisibility(I,x,L){let X=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const G=x*L;let Y=0,p=0;const B=I.length;for(let F=0;F<B;F++){if(G<=Y+I[F].length){p=F;break}Y+=I[F].length}const l=(G-Y)/I[p].length;return I[p].point2.subtractToRef(I[p].point1,F.TmpVectors.sx[0]),F.TmpVectors.sx[1]=F.TmpVectors.sx[0].multiplyByFloats(l,l,l),X||F.TmpVectors.sx[1].addInPlace(I[p].point1),F.TmpVectors.sx[1].clone()}static GetCircleLinePoints(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I,G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/x;const Y=[];for(let p=0;p<=x;p++)Y.push(new F.sx(Math.cos(p*G)*I,Math.sin(p*G)*X,L));return Y}static GetBezierLinePoints(I,x,L,F){return PI.i.CreateQuadraticBezier(I,x,L,F).getPoints().flatMap((I=>[I.x,I.y,I.z]))}static GetArrowCap(I,x,L,F,X){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[I.clone(),I.add(x.multiplyByFloats(L,L,L))],widths:[F,X,G,Y]}}static GetPointsFromText(I,x,L,F){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const Y=[],p=(0,dI.e)(I,x,L,F);for(const B of p){for(const I of B.paths){const x=[],L=I.getPoints();for(const I of L)x.push(I.x,I.y,X);Y.push(x)}if(G)for(const I of B.holes){const x=[],L=I.getPoints();for(const I of L)x.push(I.x,I.y,X);Y.push(x)}}return Y}static Color3toRGBAUint8(I){const x=new Uint8Array(4*I.length);for(let L=0,F=0;L<I.length;L++)x[F++]=255*I[L].r,x[F++]=255*I[L].g,x[F++]=255*I[L].b,x[F++]=255;return x}static CreateColorsTexture(I,x,L,F){const X=F.getEngine().getCaps().maxTextureSize??1,G=x.length>X?X:x.length,Y=Math.ceil(x.length/X);Y>1&&(x=[...x,...Array(G*Y-x.length).fill(x[0])]);const p=MI.Color3toRGBAUint8(x),B=new Z.c(p,G,Y,v.b.TEXTUREFORMAT_RGBA,F,!1,!0,L);return B.name=I,B}static PrepareEmptyColorsTexture(I){if(!nI.EmptyColorsTexture){const x=new Uint8Array(4);nI.EmptyColorsTexture=new Z.c(x,1,1,v.b.TEXTUREFORMAT_RGBA,I,!1,!1,Z.c.NEAREST_NEAREST),nI.EmptyColorsTexture.name="grlEmptyColorsTexture"}return nI.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var I;null===(I=nI.EmptyColorsTexture)||void 0===I||I.dispose(),nI.EmptyColorsTexture=null}static BooleanToNumber(I){return I?1:0}}class KI extends fI.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class uI extends tI.d{isCompatible(I){return!0}constructor(I,x,L){var X;L=L||{color:nI.DEFAULT_COLOR};const G=new KI;G.GREASED_LINE_HAS_COLOR=!!L.color&&!L.useColors,G.GREASED_LINE_SIZE_ATTENUATION=L.sizeAttenuation??!1,G.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===L.colorDistributionType,G.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(x??I.tI()).useRightHandedSystem,G.GREASED_LINE_CAMERA_FACING=L.cameraFacing??!0,super(I,uI.GREASED_LINE_MATERIAL_NAME,200,G,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(X=L)||void 0===X?void 0:X.forceGLSL)||uI.ForceGLSL,this._scene=x??I.tI(),this._engine=this._scene.getEngine(),this._cameraFacing=L.cameraFacing??!0,this.visibility=L.visibility??1,this.useDash=L.useDash??!1,this.dashRatio=L.dashRatio??.5,this.dashOffset=L.dashOffset??0,this.width=L.width?L.width:L.sizeAttenuation?nI.DEFAULT_WIDTH_ATTENUATED:nI.DEFAULT_WIDTH,this._sizeAttenuation=L.sizeAttenuation??!1,this.colorMode=L.colorMode??0,this._color=L.color??null,this.useColors=L.useColors??!1,this._colorsDistributionType=L.colorDistributionType??0,this.colorsSampling=L.colorsSampling??Z.c.NEAREST_NEAREST,this._colors=L.dI??null,this.dashCount=L.dashCount??1,this.resolution=L.resolution??new F.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),L.colorsTexture?this.colorsTexture=L.colorsTexture:this._colors?this.colorsTexture=MI.CreateColorsTexture(`${I.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??nI.DEFAULT_COLOR,MI.PrepareEmptyColorsTexture(this._scene)),this._engine.cp.add((()=>{MI.DisposeEmptyColorsTexture()}))}getAttributes(I){I.push("grl_offsets"),I.push("grl_widths"),I.push("grl_colorPointers"),I.push("grl_counters"),this._cameraFacing?(I.push("grl_previousAndSide"),I.push("grl_nextAndCounters")):I.push("grl_slopes")}getSamplers(I){I.push("grl_colors")}getActiveTextures(I){this.colorsTexture&&I.push(this.colorsTexture)}getUniforms(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const x=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&x.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===I&&x.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:x,vertex:this._cameraFacing&&this._isGLSL(I)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(I)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(I){if(this._cameraFacing){I.xB("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||I.xB("viewProjection",this._scene.getTransformMatrix());const x=F.TmpVectors.Vector4[0];x.x=this._aspect,x.y=this._resolution.x,x.z=this._resolution.y,x.w=this.width,I.updateVector4("grl_aspect_resolution_lineWidth",x)}const x=F.TmpVectors.Vector4[0];x.x=MI.BooleanToNumber(this.useDash),x.y=this._dashArray,x.z=this.dashOffset,x.w=this.dashRatio,I.updateVector4("grl_dashOptions",x);const L=F.TmpVectors.Vector4[1];L.x=this.colorMode,L.y=this.visibility,L.z=this.colorsTexture?this.colorsTexture.getSize().width:0,L.w=MI.BooleanToNumber(this.useColors),I.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",L),this._color&&I.updateColor3("grl_singleColor",this._color);const X=this.colorsTexture??nI.EmptyColorsTexture;I.setTexture("grl_colors",X),I.updateFloat2("grl_textureSize",(null===X||void 0===X?void 0:X.getSize().width)??1,(null===X||void 0===X?void 0:X.getSize().height)??1)}prepareDefines(I,x,L){I.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,I.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,I.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,I.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=x.useRightHandedSystem,I.GREASED_LINE_CAMERA_FACING=this._cameraFacing,I.GREASED_LINE_USE_OFFSETS=!!L.offsets}getClassName(){return uI.GREASED_LINE_MATERIAL_NAME}getCustomCode(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(x)?function(I,x){if("vertex"===I){const I={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return x&&(I["!gl_Position\\=viewProjection\\*worldPos;"]="//"),I}return"fragment"===I?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(I,this._cameraFacing):function(I,x){if("vertex"===I){const I={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return x&&(I["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),I}return"fragment"===I?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(I,this._cameraFacing)}dispose(){var I;null===(I=this.colorsTexture)||void 0===I||I.dispose(),super.dispose()}get dI(){return this._colors}set dI(I){this.setColors(I)}setColors(I){var x;let L=arguments.length>1&&void 0!==arguments[1]&&arguments[1],F=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const X=(null===(x=this._colors)||void 0===x?void 0:x.length)??0;var G;if(this._colors=I,null!==I&&0!==I.length){if(!L||F)if(this.colorsTexture&&X===I.length&&!F){const x=MI.Color3toRGBAUint8(I);this.colorsTexture.update(x)}else{var Y;null===(Y=this.colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=MI.CreateColorsTexture(`${this._material.name}-colors-texture`,I,this.colorsSampling,this._scene)}}else null===(G=this.colorsTexture)||void 0===G||G.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(I){this._dashCount=I,this._dashArray=1/I}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(I){this._sizeAttenuation=I,this.markAllDefinesAsDirty()}get color(){return this._color}set color(I){this.setColor(I)}setColor(I){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==I||null!==this._color&&null===I?(this._color=I,x||this.markAllDefinesAsDirty()):this._color=I}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(I){this._colorsDistributionType=I,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(I){this._aspect=I.x/I.y,this._resolution=I}serialize(){const I=super.serialize(),x={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(x.dI=this._colors),this._color&&(x.color=this._color),I.greasedLineMaterialOptions=x,I}parse(I,x,L){var F;super.parse(I,x,L);const X=I.greasedLineMaterialOptions;null===(F=this.colorsTexture)||void 0===F||F.dispose(),X.color&&this.setColor(X.color,!0),X.colorDistributionType&&(this.colorsDistributionType=X.colorDistributionType),X.dI&&(this.dI=X.dI),X.colorsSampling&&(this.colorsSampling=X.colorsSampling),X.colorMode&&(this.colorMode=X.colorMode),X.useColors&&(this.useColors=X.useColors),X.visibility&&(this.visibility=X.visibility),X.useDash&&(this.useDash=X.useDash),X.dashCount&&(this.dashCount=X.dashCount),X.dashRatio&&(this.dashRatio=X.dashRatio),X.dashOffset&&(this.dashOffset=X.dashOffset),X.width&&(this.width=X.width),X.sizeAttenuation&&(this.sizeAttenuation=X.sizeAttenuation),X.resolution&&(this.resolution=X.resolution),this.dI?this.colorsTexture=MI.CreateColorsTexture(`${this._material.name}-colors-texture`,this.dI,this.colorsSampling,x):MI.PrepareEmptyColorsTexture(x),this.markAllDefinesAsDirty()}copyTo(I){var x;const L=I;null===(x=L.colorsTexture)||void 0===x||x.dispose(),this._colors&&(L.colorsTexture=MI.CreateColorsTexture(`${L._material.name}-colors-texture`,this._colors,L.colorsSampling,this._scene)),L.setColor(this.color,!0),L.colorsDistributionType=this.colorsDistributionType,L.colorsSampling=this.colorsSampling,L.colorMode=this.colorMode,L.useColors=this.useColors,L.visibility=this.visibility,L.useDash=this.useDash,L.dashCount=this.dashCount,L.dashRatio=this.dashRatio,L.dashOffset=this.dashOffset,L.width=this.width,L.sizeAttenuation=this.sizeAttenuation,L.resolution=this.resolution,L.markAllDefinesAsDirty()}_isGLSL(I){return 0===I||this._forceGLSL}}uI.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",uI.ForceGLSL=!1,(0,RI.d)(`BABYLON.${uI.GREASED_LINE_MATERIAL_NAME}`,uI);var AI=L(13415),mx=L(12818),OI=L(13211),wI=L(12916);class kI extends OI.ShaderMaterial{constructor(I,x,X){const G=x.getEngine(),Y=G.isWebGPU&&!(X.forceGLSL||kI.ForceGLSL),p=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];x.useRightHandedSystem&&p.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const B=["position","grl_widths","grl_offsets","grl_colorPointers"];X.cameraFacing?(p.push("GREASED_LINE_CAMERA_FACING"),B.push("grl_previousAndSide","grl_nextAndCounters")):(B.push("grl_slopes"),B.push("grl_counters"));const l=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(Y||l.push("world","viewProjection","view","projection"),super(I,x,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:Y?["Scene","Mesh"]:void 0,attributes:B,uniforms:l,samplers:Y?[]:["grlColors"],defines:p,extraInitializationsAsync:async()=>{Y?await Promise.all([L.e(66).then(L.bind(L,16008)),L.e(75).then(L.bind(L,16010))]):await Promise.all([L.e(69).then(L.bind(L,16017)),L.e(76).then(L.bind(L,16020))])},shaderLanguage:Y?1:0}),this._color=H.Tx.White(),this._colorsDistributionType=0,this._colorsTexture=null,X=X||{color:nI.DEFAULT_COLOR},this.visibility=X.visibility??1,this.useDash=X.useDash??!1,this.dashRatio=X.dashRatio??.5,this.dashOffset=X.dashOffset??0,this.dashCount=X.dashCount??1,this.width=X.width?X.width:X.sizeAttenuation&&X.cameraFacing?nI.DEFAULT_WIDTH_ATTENUATED:nI.DEFAULT_WIDTH,this.sizeAttenuation=X.sizeAttenuation??!1,this.color=X.color??H.Tx.White(),this.useColors=X.useColors??!1,this.colorsDistributionType=X.colorDistributionType??0,this.colorsSampling=X.colorsSampling??Z.c.NEAREST_NEAREST,this.colorMode=X.colorMode??0,this._colors=X.dI??null,this._cameraFacing=X.cameraFacing??!0,this.resolution=X.resolution??new F.Vector2(G.getRenderWidth(),G.getRenderHeight()),X.colorsTexture?this.colorsTexture=X.colorsTexture:this._colors?this.colorsTexture=MI.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,x):(this._color=this._color??nI.DEFAULT_COLOR,this.colorsTexture=MI.PrepareEmptyColorsTexture(x)),Y){const I=new wI.c;I.setParameters(),I.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",I)}G.cp.add((()=>{MI.DisposeEmptyColorsTexture()}))}dispose(){var I;null===(I=this._colorsTexture)||void 0===I||I.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new F.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dI(){return this._colors}set dI(I){this.setColors(I)}setColors(I){var x;let L=arguments.length>1&&void 0!==arguments[1]&&arguments[1],F=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const X=(null===(x=this._colors)||void 0===x?void 0:x.length)??0;var G;if(this._colors=I,null!==I&&0!==I.length){if(!L||F)if(this._colorsTexture&&X===I.length&&!F){const x=MI.Color3toRGBAUint8(I);this._colorsTexture.update(x)}else{var Y;null===(Y=this._colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=MI.CreateColorsTexture(`${this.name}-colors-texture`,I,this.colorsSampling,this.tI())}}else null===(G=this._colorsTexture)||void 0===G||G.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(I){this._colorsTexture=I,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(I){this._width=I,this.setFloat("grlWidth",I)}get useColors(){return this._useColors}set useColors(I){this._useColors=I,this.setFloat("grlUseColors",MI.BooleanToNumber(I))}get colorsSampling(){return this._colorsSampling}set colorsSampling(I){this._colorsSampling=I}get visibility(){return this._visibility}set visibility(I){this._visibility=I,this.setFloat("grlVisibility",I)}get useDash(){return this._useDash}set useDash(I){this._useDash=I,this.setFloat("grlUseDash",MI.BooleanToNumber(I))}get dashOffset(){return this._dashOffset}set dashOffset(I){this._dashOffset=I,this.setFloat("grlDashOffset",I)}get dashRatio(){return this._dashRatio}set dashRatio(I){this._dashRatio=I,this.setFloat("grlDashRatio",I)}get dashCount(){return this._dashCount}set dashCount(I){this._dashCount=I,this._dashArray=1/I,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(I){this._sizeAttenuation=I,this.setFloat("grlSizeAttenuation",MI.BooleanToNumber(I))}get color(){return this._color}set color(I){this.setColor(I)}setColor(I){I=I??nI.DEFAULT_COLOR,this._color=I,this.setColor3("grlColor",I)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(I){this._colorsDistributionType=I,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(I){this._colorMode=I,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(I){this._resolution=I,this.setVector2("grlResolution",I),this.setFloat("grlAspect",I.x/I.y)}serialize(){const I=super.serialize(),x={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(x.dI=this._colors),I.greasedLineMaterialOptions=x,I}parse(I,x,L){var F;const X=I.greasedLineMaterialOptions;null===(F=this._colorsTexture)||void 0===F||F.dispose(),X.color&&(this.color=X.color),X.colorDistributionType&&(this.colorsDistributionType=X.colorDistributionType),X.colorsSampling&&(this.colorsSampling=X.colorsSampling),X.colorMode&&(this.colorMode=X.colorMode),X.useColors&&(this.useColors=X.useColors),X.visibility&&(this.visibility=X.visibility),X.useDash&&(this.useDash=X.useDash),X.dashCount&&(this.dashCount=X.dashCount),X.dashRatio&&(this.dashRatio=X.dashRatio),X.dashOffset&&(this.dashOffset=X.dashOffset),X.width&&(this.width=X.width),X.sizeAttenuation&&(this.sizeAttenuation=X.sizeAttenuation),X.resolution&&(this.resolution=X.resolution),X.dI?this.colorsTexture=MI.CreateColorsTexture(`${this.name}-colors-texture`,X.dI,this.colorsSampling,this.tI()):this.colorsTexture=MI.PrepareEmptyColorsTexture(x),this._cameraFacing=X.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var aI,DI,rI;kI.ForceGLSL=!1,function(I){I[I.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",I[I.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(aI||(aI={})),function(I){I[I.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",I[I.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",I[I.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(DI||(DI={})),function(I){I[I.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",I[I.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",I[I.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",I[I.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",I[I.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(rI||(rI={}));class NI extends UI.e{constructor(I,x,L){super(I,x,null,null,!1,!1),this.name=I,this._options=L,this._lazy=!1,this._updatable=!1,this._engine=x.getEngine(),this._lazy=L.lazy??!1,this._updatable=L.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=L.colorPointers??[],this._widths=L.widths??new Array(L.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(I){let x=0;for(const F of this._points)x+=F.length;const L=x/3*2-this._widths.length;for(let F=0;F<L;F++)this._widths.push(I)}updateLazy(){var I,x;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(I=this._options.ribbonOptions)||void 0===I?void 0:I.smoothShading),!this.AI&&this.refreshBoundingInfo(),null===(x=this.greasedLineMaterial)||void 0===x||x.updateLazy()}addPoints(I,x){for(const L of I)this._points.push(L);this._lazy||this.setPoints(this._points,x)}dispose(I){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(I,x)}isLazy(){return this._lazy}get MI(){return this._uvs}set MI(I){this._uvs=I instanceof Float32Array?I:new Float32Array(I),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(I){this.material instanceof kI&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===I||void 0===I?void 0:I.length)>0),this._offsets=I,this._offsetsBuffer?this._offsetsBuffer.update(I):this._createOffsetsBuffer(I)}get widths(){return this._widths}set widths(I){this._widths=I,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(I)}get colorPointers(){return this._colorPointers}set colorPointers(I){this._colorPointers=I,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(I)}get greasedLineMaterial(){var I,x;if(this.material&&this.material instanceof kI)return this.material;const L=null===(I=this.material)||void 0===I||null===(x=I.pluginManager)||void 0===x?void 0:x.getPlugin(uI.GREASED_LINE_MATERIAL_NAME);return L||void 0}get points(){const I=[];return mx.b.DeepCopy(this._points,I),I}setPoints(I,x){this._points=MI.ConvertPoints(I,(null===x||void 0===x?void 0:x.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==x&&void 0!==x&&x.colorPointers||this._updateColorPointers(),this._setPoints(this._points,x)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,MI:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(I){super.serialize(I),I.type=this.getClassName(),I.lineOptions=this._createLineOptions()}_createVertexBuffers(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new AI.d;return x.RI=this._vertexPositions,x.indices=this._indices,x.MI=this._uvs,I&&(x.nI=[],AI.d.ComputeNormals(this._vertexPositions,this._indices,x.nI)),x.uI(this,this._options.updatable),x}_createOffsetsBuffer(I){const x=this._scene.getEngine(),L=new W.e(x,I,this._updatable,3);this.setVerticesBuffer(L.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=L}}class SI{constructor(I,x){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=I,this.wasAddedByNoopNode=x}getIndicesAccessor(I,x,L,F,X){var G,Y,p,B;return null===(G=this._indicesAccessorMap.get(I))||void 0===G||null===(Y=G.get(x))||void 0===Y||null===(p=Y.get(L))||void 0===p||null===(B=p.get(F))||void 0===B?void 0:B.get(X)}setIndicesAccessor(I,x,L,F,X,G){let Y=this._indicesAccessorMap.get(I);Y||(Y=new Map,this._indicesAccessorMap.set(I,Y));let p=Y.get(x);p||(p=new Map,Y.set(x,p));let B=p.get(L);B||(B=new Map,p.set(L,B));let l=B.get(F);l||(l=new Map,B.set(F,l)),l.set(X,G)}pushExportedNode(I){this._exportedNodes.has(I)||this._exportedNodes.add(I)}getNodesSet(){return this._exportedNodes}getVertexBufferView(I){return this._vertexBufferViewMap.get(I)}setVertexBufferView(I,x){this._vertexBufferViewMap.set(I,x)}setRemappedBufferView(I,x,L){this._remappedBufferView.set(I,new Map),this._remappedBufferView.get(I).set(x,L)}getRemappedBufferView(I,x){var L;return null===(L=this._remappedBufferView.get(I))||void 0===L?void 0:L.get(x)}getVertexAccessor(I,x,L){var F,X;return null===(F=this._vertexAccessorMap.get(I))||void 0===F||null===(X=F.get(x))||void 0===X?void 0:X.get(L)}setVertexAccessor(I,x,L,F){let X=this._vertexAccessorMap.get(I);X||(X=new Map,this._vertexAccessorMap.set(I,X));let G=X.get(x);G||(G=new Map,X.set(x,G)),G.set(L,F)}hasVertexColorAlpha(I){return this._vertexMapColorAlpha.get(I)||!1}setHasVertexColorAlpha(I,x){return this._vertexMapColorAlpha.set(I,x)}getMesh(I){return this._meshMap.get(I)}setMesh(I,x){this._meshMap.set(I,x)}bindMorphDataToMesh(I,x){const L=this._meshMorphTargetMap.get(I)||[];this._meshMorphTargetMap.set(I,L),-1===L.indexOf(x)&&L.push(x)}getMorphTargetsFromMesh(I){return this._meshMorphTargetMap.get(I)}}class cI{_ApplyExtension(I,x,L,F){if(L>=x.length)return Promise.resolve(I);const X=F(x[L],I);return X?X.then((async I=>I?await this._ApplyExtension(I,x,L+1,F):null)):this._ApplyExtension(I,x,L+1,F)}_ApplyExtensions(I,x){const L=[];for(const F of cI._ExtensionNames)L.push(this._extensions[F]);return this._ApplyExtension(I,L,0,x)}_extensionsPreExportTextureAsync(I,x,L){return this._ApplyExtensions(x,((x,F)=>x.preExportTextureAsync&&x.preExportTextureAsync(I,F,L)))}_extensionsPostExportNodeAsync(I,x,L,F,X){return this._ApplyExtensions(x,((x,G)=>x.postExportNodeAsync&&x.postExportNodeAsync(I,G,L,F,X,this._bufferManager)))}_extensionsPostExportMaterialAsync(I,x,L){return this._ApplyExtensions(x,((x,F)=>x.postExportMaterialAsync&&x.postExportMaterialAsync(I,F,L)))}_extensionsPostExportMaterialAdditionalTextures(I,x,L){const F=[];for(const X of cI._ExtensionNames){const G=this._extensions[X];G.postExportMaterialAdditionalTextures&&F.push(...G.postExportMaterialAdditionalTextures(I,x,L))}return F}_extensionsPostExportTextures(I,x,L){for(const F of cI._ExtensionNames){const X=this._extensions[F];X.postExportTexture&&X.postExportTexture(I,x,L)}}_extensionsPostExportMeshPrimitive(I){for(const x of cI._ExtensionNames){const L=this._extensions[x];L.postExportMeshPrimitive&&L.postExportMeshPrimitive(I,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const I of cI._ExtensionNames){const x=this._extensions[I];x.preGenerateBinaryAsync&&await x.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(I){for(const x of cI._ExtensionNames){const L=this._extensions[x];L.enabled&&I(L)}}_extensionsOnExporting(){this._forEachExtensions((I=>{var x,L,F;I.wasUsed&&((x=this._glTF).extensionsUsed||(x.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(I.name)&&this._glTF.extensionsUsed.push(I.name),I.required&&((L=this._glTF).extensionsRequired||(L.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(I.name)&&this._glTF.extensionsRequired.push(I.name)),(F=this._glTF).extensions||(F.extensions={}),I.onExporting&&I.onExporting())}))}_loadExtensions(){for(const I of cI._ExtensionNames){const x=cI._ExtensionFactories[I](this);this._extensions[I]=x}}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:z.e.LastCreatedScene,x=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${v.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new w(this),this._extensions={},this._bufferManager=new WI,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!I)throw new Error("No scene available to export");this._babylonScene=I,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:I=>{var x;return null===I||void 0===I||null===(x=I.Ep)||void 0===x?void 0:x.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...x},this._loadExtensions()}dispose(){for(const I in this._extensions){this._extensions[I].dispose()}}get options(){return this._options}static RegisterExtension(I,x){cI.UnregisterExtension(I)&&X.Tools.Warn(`Extension with the name ${I} already exists`),cI._ExtensionFactories[I]=x,cI._ExtensionNames.push(I)}static UnregisterExtension(I){if(!cI._ExtensionFactories[I])return!1;delete cI._ExtensionFactories[I];const x=cI._ExtensionNames.indexOf(I);return-1!==x&&cI._ExtensionNames.splice(x,1),!0}_generateJSON(I,x,L){const F={byteLength:I};return F.byteLength&&(this._glTF.buffers=[F]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.qx=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(F.uri=x+".bin"),L?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(I){const x=await this._generateBinaryAsync();this._extensionsOnExporting();const L=this._generateJSON(x.byteLength,I,!0),F=new Blob([x],{type:"application/octet-stream"}),X=I+".gltf",G=I+".bin",Y=new l;if(Y.files[X]=L,Y.files[G]=F,this._imageData)for(const p in this._imageData)Y.files[p]=new Blob([this._imageData[p].data],{type:this._imageData[p].mimeType});return Y}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(I){const x=I%4;return 0===x?x:4-x}async generateGLBAsync(I){this._shouldUseGlb=!0;const x=await this._generateBinaryAsync();this._extensionsOnExporting();const L=this._generateJSON(x.byteLength),F=I+".glb";let X,G=L.length;if("undefined"!==typeof TextEncoder){X=(new TextEncoder).encode(L),G=X.length}const Y=this._getPadding(G),p=this._getPadding(x.byteLength),B=28+G+Y+x.byteLength+p,W=new BI(B);if(W.writeUInt32(1179937895),W.writeUInt32(2),W.writeUInt32(B),W.writeUInt32(G+Y),W.writeUInt32(1313821514),X)W.writeTypedArray(X);else{const I="_".charCodeAt(0);for(let x=0;x<G;++x){const F=L.charCodeAt(x);F!=L.codePointAt(x)?W.writeUInt8(I):W.writeUInt8(F)}}for(let l=0;l<Y;++l)W.writeUInt8(32);W.writeUInt32(x.byteLength+p),W.writeUInt32(5130562),W.writeTypedArray(x);for(let l=0;l<p;++l)W.writeUInt8(0);const Q=new l;return Q.files[F]=new Blob([W.getOutputData()],{type:"application/octet-stream"}),Q}_setNodeTransformation(I,x,L){if(x.getPivotPoint().equalsWithEpsilon(N,r.e)||X.Tools.Warn("Pivot points are not supported in the glTF serializer"),!x.position.equalsWithEpsilon(N,r.e)){const X=F.TmpVectors.sx[0].X(x.position);L&&j(X),I.translation=X.Cp()}x.pB.equalsWithEpsilon(c,r.e)||(I.scale=x.pB.Cp());const G=x.rotationQuaternion||F.Quaternion.FromEulerAngles(x.rotation.x,x.rotation.y,x.rotation.z);G.equalsWithEpsilon(S,r.e)||(L&&C(G),I.rotation=G.normalize().Cp())}_setCameraTransformation(I,x,L){if(!x.position.equalsWithEpsilon(N,r.e)){const X=F.TmpVectors.sx[0].X(x.position);L&&j(X),I.translation=X.Cp()}const X=x.rotationQuaternion||F.Quaternion.FromEulerAngles(x.rotation.x,x.rotation.y,x.rotation.z);L&&C(X),this._babylonScene.useRightHandedSystem||b(X),X.equalsWithEpsilon(S,r.e)||(I.rotation=X.Cp())}_listAvailableCameras(){for(const I of this._babylonScene.cameras){const x={type:I.mode===eI.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(I.name&&(x.name=I.name),"perspective"===x.type)x.perspective={aspectRatio:I.getEngine().getAspectRatio(I),yfov:I.fovMode===eI.b.FOVMODE_VERTICAL_FIXED?I.fov:I.fov*I.getEngine().getAspectRatio(I),znear:I.IB,zfar:I.maxZ};else if("orthographic"===x.type){const L=I.orthoLeft&&I.orthoRight?.5*(I.orthoRight-I.orthoLeft):.5*I.getEngine().getRenderWidth(),F=I.orthoBottom&&I.orthoTop?.5*(I.orthoTop-I.orthoBottom):.5*I.getEngine().getRenderHeight();x.orthographic={xmag:L,ymag:F,znear:I.IB,zfar:I.maxZ}}this._camerasMap.set(I,x)}}_exportAndAssignCameras(){const I=Array.from(this._camerasMap.values());for(const x of I){const I=this._nodesCameraMap.get(x);if(void 0!==I){this._cameras.push(x);for(const x of I)x.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const I of this._babylonScene.skeletons){if(I.bones.length<=0)continue;const x={joints:[]};this._skinMap.set(I,x)}}_exportAndAssignSkeletons(){for(const I of this._babylonScene.skeletons){if(I.bones.length<=0)continue;const x=this._skinMap.get(I);if(void 0==x)continue;const L={},F=[];let G=-1;for(let X=0;X<I.bones.length;++X){const x=I.bones[X],F=x.getIndex()??X;-1!==F&&(L[F]=x,F>G&&(G=F))}for(let I=0;I<=G;++I){const G=L[I];F.push(G.getAbsoluteInverseBindMatrix());const Y=G.getTransformNode();if(null!==Y){const I=this._nodeMap.get(Y);Y&&null!==I&&void 0!==I?x.joints.push(I):X.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else X.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const Y=this._nodesSkinMap.get(x);if(x.joints.length>0&&void 0!==Y){const I=64*F.length,L=new Float32Array(I/4);F.forEach(((I,x)=>{L.set(I.m,16*x)}));const X=this._bufferManager.createBufferView(L);this._accessors.push(this._bufferManager.createAccessor(X,"MAT4",5126,F.length)),x.inverseBindMatrices=this._accessors.length-1,this._skins.push(x);for(const x of Y)x.skin=this._skins.length-1}}}async _exportSceneAsync(){const I={nodes:[]};if(this._babylonScene.metadata){const x=this._options.metadataSelector(this._babylonScene.metadata);x&&(I.extras=x)}const x=new Array,L=new Array,F=new Array;for(const p of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&YI(p,this._babylonScene.useRightHandedSystem)?F.push(...p.getChildren()):this._babylonScene.useRightHandedSystem?x.push(p):L.push(p);this._listAvailableCameras(),this._listAvailableSkeletons();const X=new SI(!0,!1);I.nodes.push(...await this._exportNodesAsync(L,X));const G=new SI(!1,!1);I.nodes.push(...await this._exportNodesAsync(x,G));const Y=new SI(!1,!0);I.nodes.push(...await this._exportNodesAsync(F,Y)),I.nodes.length&&this._scenes.push(I),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&yI._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,X.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(I){let x=this._shouldExportNodeMap.get(I);return void 0===x&&(x=this._options.shouldExportNode(I),this._shouldExportNodeMap.set(I,x)),x}async _exportNodesAsync(I,x){const L=new Array;this._exportBuffers(I,x);for(const F of I)await this._exportNodeAsync(F,L,x);return L}_collectBuffers(I,x,L,F,X){if(this._shouldExportNode(I)&&I instanceof e.b&&I.FB){const G=I.FB.getVertexBuffers();if(G)for(const F in G){if(!E(F))continue;const Y=G[F];X.setHasVertexColorAlpha(Y,I.hasVertexAlpha);const p=Y._buffer,B=x.get(p)||[];x.set(p,B),-1===B.indexOf(Y)&&B.push(Y);const l=L.get(Y)||[];L.set(Y,l),-1===l.indexOf(I)&&l.push(I)}const Y=I.morphTargetManager;if(Y)for(let x=0;x<Y.numTargets;x++){const L=Y.getTarget(x),X=F.get(L)||[];F.set(L,X),-1===X.indexOf(I)&&X.push(I)}}for(const G of I.getChildren())this._collectBuffers(G,x,L,F,X)}_exportBuffers(I,x){const L=new Map,F=new Map,X=new Map;for(const p of I)this._collectBuffers(p,L,F,X,x);const G=Array.from(L.keys());for(const p of G){const I=p.getData();if(!I)throw new Error("Buffer data is not available");const X=L.get(p);if(!X)continue;const G=X[0].byteStride;if(X.some((I=>I.byteStride!==G)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const Y=LI(I).slice();for(const x of X){const I=F.get(x),{byteOffset:L,byteStride:X,componentCount:G,type:p,count:B,normalized:l,kind:Q}=J(x,I);switch(Q){case W.g.NormalKind:case W.g.TangentKind:(0,k.h)(Y,L,X,G,p,B,l,(I=>{const x=Math.sqrt(I[0]*I[0]+I[1]*I[1]+I[2]*I[2]);if(x>0){const L=1/x;I[0]*=L,I[1]*=L,I[2]*=L}}));break;case W.g.ColorKind:{const x=I.filter((I=>I.material instanceof zI.yx||null==I.material)).length;if(0==x)break;if(x!=I.length){a.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}p==W.g.UNSIGNED_BYTE&&a.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const F=new H.Tx,Q=new H.lB,e=this._babylonScene.getEngine().useExactSrgbConversions;(0,k.h)(Y,L,X,G,p,B,l,(I=>{3===I.length?(F.PL(I,0),F.toLinearSpaceToRef(F,e),F.toArray(I,0)):(Q.PL(I,0),Q.toLinearSpaceToRef(Q,e),Q.toArray(I,0))}))}}}if(x.convertToRightHanded){for(const I of X){const x=F.get(I),{byteOffset:L,byteStride:X,componentCount:G,type:p,count:B,normalized:l,kind:Q}=J(I,x);switch(Q){case W.g.PositionKind:case W.g.NormalKind:case W.g.TangentKind:(0,k.h)(Y,L,X,G,p,B,l,(I=>{I[0]=-I[0]}))}}x.convertedToRightHandedBuffers.set(p,Y)}const B=this._bufferManager.createBufferView(Y,G);x.setVertexBufferView(p,B);const l=new Map;for(const x of X){const I=F.get(x),{kind:L,totalVertices:X}=J(x,I);switch(L){case W.g.MatricesIndicesKind:case W.g.MatricesIndicesExtraKind:if(x.type==W.g.FLOAT){const I=x.getFloatData(X);null!==I&&l.set(x,I)}}}0!==l.size&&a.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const Q=Array.from(l.keys());for(const L of Q){const I=l.get(L);if(!I)continue;const F=I.some((I=>I>=256)),X=new(F?Uint16Array:Uint8Array)(I.length);for(let x=0;x<I.length;x++)X[x]=I[x];const G=this._bufferManager.createBufferView(X,4*(F?2:1));x.setRemappedBufferView(p,L,G)}}const Y=Array.from(X.keys());for(const p of Y){const I=X.get(p);if(!I)continue;const L=TI(p,I[0],this._bufferManager,this._bufferViews,this._accessors,x.convertToRightHanded);for(const F of I)x.bindMorphDataToMesh(F,L)}}async _exportNodeAsync(I,x,L){let F=this._nodeMap.get(I);if(void 0!==F)return void(x.includes(F)||x.push(F));const X=await this._createNodeAsync(I,L);if(X){F=this._nodes.length,this._nodes.push(X),this._nodeMap.set(I,F),L.pushExportedNode(I),x.push(F);const G={name:"runtime animations",channels:[],samplers:[]},Y=[];this._babylonScene.animationGroups.length||(yI._CreateMorphTargetAnimationFromMorphTargetAnimations(I,G,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,L.convertToRightHanded,this._options.shouldExportAnimation),I.animations.length&&yI._CreateNodeAnimationFromNodeAnimations(I,G,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,L.convertToRightHanded,this._options.shouldExportAnimation)),G.channels.length&&G.samplers.length&&this._animations.push(G),Y.forEach((I=>{I.channels.length&&I.samplers.length&&this._animations.push(I)}))}const G=X?[]:x;for(const Y of I.getChildren())await this._exportNodeAsync(Y,G,L);X&&G.length&&(X.children=G)}async _createNodeAsync(I,x){if(!this._shouldExportNode(I))return null;const L={};if(I.name&&(L.name=I.name),I.metadata){const x=this._options.metadataSelector(I.metadata);x&&(L.extras=x)}if(I instanceof Q.c&&(this._setNodeTransformation(L,I,x.convertToRightHanded),I instanceof e.b)){const X=I instanceof g.b?I.sourceMesh:I;if(X.jp&&X.jp.length>0&&(L.mesh=await this._exportMeshAsync(X,x)),I.skeleton){const x=this._skinMap.get(I.skeleton);var F;if(void 0!==x)void 0===this._nodesSkinMap.get(x)&&this._nodesSkinMap.set(x,[]),null===(F=this._nodesSkinMap.get(x))||void 0===F||F.push(L)}}if(I instanceof D.b){const F=this._camerasMap.get(I);if(F){var X;void 0===this._nodesCameraMap.get(F)&&this._nodesCameraMap.set(F,[]),this._setCameraTransformation(L,I,x.convertToRightHanded);const Y=I.parent;if(null!==Y&&xI(I,Y)){const I=this._nodeMap.get(Y);if(void 0!==I){var G;const x=this._nodes[I];return II(L,x),null===(G=this._nodesCameraMap.get(F))||void 0===G||G.push(x),null}}null===(X=this._nodesCameraMap.get(F))||void 0===X||X.push(L)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",L,I,this._nodeMap,x.convertToRightHanded)?L:(a.c.Warn(`Not exporting node ${I.name}`),null)}_exportIndices(I,x,L,F,X,Y,p,B,l){let W=I;l.mode=i(Y);const Q=p!==G.e.CounterClockWiseSideOrientation,e=!B.wasAddedByNoopNode&&Q,g=function(I){switch(I){case G.e.TriangleFillMode:case G.e.TriangleStripDrawMode:case G.e.TriangleFanDrawMode:return!0}return!1}(Y)&&e;if(g){if(Y===G.e.TriangleStripDrawMode||Y===G.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");l.mode=i(Y);const p=x?new Uint32Array(F):new Uint16Array(F);if(I)for(let x=0;x+2<F;x+=3)p[x]=I[L+x]+X,p[x+1]=I[L+x+2]+X,p[x+2]=I[L+x+1]+X;else for(let I=0;I+2<F;I+=3)p[I]=I,p[I+1]=I+2,p[I+2]=I+1;W=p}else if(I&&0!==X){const G=x?new Uint32Array(F):new Uint16Array(F);for(let x=0;x<F;x++)G[x]=I[L+x]+X;W=G}if(W){let G=B.getIndicesAccessor(I,L,F,X,g);if(void 0===G){const Y=function(I,x,L,F){if(I instanceof Uint16Array||I instanceof Uint32Array)return I;if(I instanceof Int32Array)return new Uint32Array(I.buffer,I.byteOffset,I.length);const X=I.slice(x,x+L);return F?new Uint32Array(X):new Uint16Array(X)}(W,0,F,x),p=this._bufferManager.createBufferView(Y),l=x?5125:5123;this._accessors.push(this._bufferManager.createAccessor(p,"SCALAR",l,F,0)),G=this._accessors.length-1,B.setIndicesAccessor(I,L,F,X,g,G)}l.indices=G}}_exportVertexBuffer(I,x,L,F,X,G){const Y=I.getKind();if(!E(Y))return;if(Y.startsWith("uv")&&!this._options.exportUnusedUVs&&(!x||!this._materialNeedsUVsSet.has(x)))return;let p=X.getVertexAccessor(I,L,F);if(void 0===p){const x=X.convertedToRightHandedBuffers.get(I._buffer)||I._buffer.getData(),G=Y===W.g.PositionKind?function(I,x,L,F){const{byteOffset:X,byteStride:G,type:Y,normalized:p}=x,B=x.getSize(),l=new Array(B).fill(1/0),W=new Array(B).fill(-1/0);return(0,k.h)(I,X+L*G,G,B,Y,F*B,p,(I=>{for(let x=0;x<B;x++)l[x]=Math.min(l[x],I[x]),W[x]=Math.max(W[x],I[x])})),{min:l,max:W}}(x,I,L,F):void 0,B=(Y===W.g.MatricesIndicesKind||Y===W.g.MatricesIndicesExtraKind)&&I.type===W.g.FLOAT,l=B?W.g.UNSIGNED_BYTE:I.type,Q=B?void 0:I.normalized,e=B?X.getRemappedBufferView(I._buffer,I):X.getVertexBufferView(I._buffer),g=I.byteOffset+L*I.byteStride;this._accessors.push(this._bufferManager.createAccessor(e,function(I,x){if(I==W.g.ColorKind)return x?"VEC4":"VEC3";switch(I){case W.g.PositionKind:case W.g.NormalKind:return"VEC3";case W.g.TangentKind:case W.g.MatricesIndicesKind:case W.g.MatricesIndicesExtraKind:case W.g.MatricesWeightsKind:case W.g.MatricesWeightsExtraKind:return"VEC4";case W.g.UVKind:case W.g.UV2Kind:case W.g.UV3Kind:case W.g.UV4Kind:case W.g.UV5Kind:case W.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${I}`)}(Y,X.hasVertexColorAlpha(I)),l,F,g,G,Q)),p=this._accessors.length-1,X.setVertexAccessor(I,L,F,p)}G.attributes[function(I){switch(I){case W.g.PositionKind:return"POSITION";case W.g.NormalKind:return"NORMAL";case W.g.TangentKind:return"TANGENT";case W.g.ColorKind:return"COLOR_0";case W.g.UVKind:return"TEXCOORD_0";case W.g.UV2Kind:return"TEXCOORD_1";case W.g.UV3Kind:return"TEXCOORD_2";case W.g.UV4Kind:return"TEXCOORD_3";case W.g.UV5Kind:return"TEXCOORD_4";case W.g.UV6Kind:return"TEXCOORD_5";case W.g.MatricesIndicesKind:return"JOINTS_0";case W.g.MatricesIndicesExtraKind:return"JOINTS_1";case W.g.MatricesWeightsKind:return"WEIGHTS_0";case W.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${I}`)}(Y)]=p}async _exportMaterialAsync(I,x,L,F){let X=this._materialMap.get(I);if(void 0===X){const F=x&&Object.keys(x).some((I=>I.startsWith("uv")));if((I=I instanceof gI.e?I.WB[L.materialIndex]:I)instanceof vI.b)X=await this._materialExporter.exportPBRMaterialAsync(I,"image/png",F);else{if(!(I instanceof zI.yx))return void a.c.Warn(`Unsupported material '${I.name}' with type ${I.getClassName()}`);X=await this._materialExporter.exportStandardMaterialAsync(I,"image/png",F)}this._materialMap.set(I,X)}F.material=X}async _exportMeshAsync(I,x){var L;let F=x.getMesh(I);if(void 0!==F)return F;const X={primitives:[]};F=this._meshes.length,this._meshes.push(X),x.setMesh(I,F);const Y=I.isUnIndexed?null:I.XB(),p=null===(L=I.FB)||void 0===L?void 0:L.getVertexBuffers(),B=x.getMorphTargetsFromMesh(I),l=I instanceof ZI.c,W=I instanceof NI,Q=I.jp;if(p&&Q&&Q.length>0)for(const v of Q){const L={attributes:{}},F=v.kI()||this._babylonScene.defaultMaterial;if(W){var e,g;const x={name:F.name},X=I,G=H.Tx.White(),Y=(null===(e=X.material)||void 0===e?void 0:e.alpha)??1,p=(null===(g=X.greasedLineMaterial)||void 0===g?void 0:g.color)??G;(!p.equalsWithEpsilon(G,r.e)||Y<1)&&(x.pbrMetallicRoughness={baseColorFactor:[...p.Cp(),Y]}),this._materials.push(x),L.material=this._materials.length-1}else if(l){const x={name:F.name},X=I;(!X.color.equalsWithEpsilon(H.Tx.White(),r.e)||X.alpha<1)&&(x.pbrMetallicRoughness={baseColorFactor:[...X.color.Cp(),X.alpha]}),this._materials.push(x),L.material=this._materials.length-1}else await this._exportMaterialAsync(F,p,v,L);const Q=l||W?G.e.LineListDrawMode:I.overrideRenderingFillMode??F.fillMode,z=F._getEffectiveOrientation(I);this._exportIndices(Y,Y?(0,k.d)(Y,v.indexCount,v.indexStart,v.verticesStart):v.verticesCount>65535,Y?v.indexStart:v.verticesStart,Y?v.indexCount:v.verticesCount,-v.verticesStart,Q,z,x,L);for(const I of Object.values(p))this._exportVertexBuffer(I,F,v.verticesStart,v.verticesCount,x,L);if(B){L.targets=[];for(const I of B)L.targets.push(I.attributes)}X.primitives.push(L),this._extensionsPostExportMeshPrimitive(L)}if(B){X.weights=[],X.extras||(X.extras={}),X.extras.targetNames=[];for(const I of B)X.weights.push(I.influence),X.extras.targetNames.push(I.name)}return F}}cI._ExtensionNames=new Array,cI._ExtensionFactories={};class oI{static async GLTFAsync(I,x,L){L&&L.exportWithoutWaitingForScene||await I.whenReadyAsync();const F=new cI(I,L),X=await F.generateGLTFAsync(x.replace(/\.[^/.]+$/,""));return F.dispose(),X}static async GLBAsync(I,x,L){L&&L.exportWithoutWaitingForScene||await I.whenReadyAsync();const F=new cI(I,L),X=await F.generateGLBAsync(x.replace(/\.[^/.]+$/,""));return F.dispose(),X}}L(13525);const JI="EXT_mesh_gpu_instancing";class hI{constructor(I){this.name=JI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(I,x,L,X,G,Y){return await new Promise((I=>{if(x&&L instanceof UI.e&&L.hasThinInstances&&this._exporter){this._wasUsed=!0;const I=F.sx.Zero(),X=F.Quaternion.Identity(),p=F.sx.One(),B=L.thinInstanceGetWorldMatrices(),l=F.TmpVectors.sx[2],W=F.TmpVectors.Quaternion[1],Q=F.TmpVectors.sx[3];let e=!1,g=!1,v=!1;const z=new Float32Array(3*L.QB),H=new Float32Array(4*L.QB),s=new Float32Array(3*L.QB);let U=0;for(const x of B)x.decompose(Q,W,l),G&&(j(l),C(W)),z.set(l.Cp(),3*U),H.set(W.normalize().Cp(),4*U),s.set(Q.Cp(),3*U),e=e||!l.equalsWithEpsilon(I),g=g||!W.equalsWithEpsilon(X),v=v||!Q.equalsWithEpsilon(p),U++;const q={attributes:{}};e&&(q.attributes.TRANSLATION=this._buildAccessor(z,"VEC3",L.QB,Y)),g&&(q.attributes.ROTATION=this._buildAccessor(H,"VEC4",L.QB,Y)),v&&(q.attributes.SCALE=this._buildAccessor(s,"VEC3",L.QB,Y)),x.extensions=x.extensions||{},x.extensions[JI]=q}I(x)}))}_buildAccessor(I,x,L,F){const X=F.createBufferView(I),G=F.createAccessor(X,x,5126,L);return this._exporter._accessors.push(G),this._exporter._accessors.length-1}}cI.RegisterExtension(JI,(I=>new hI(I)));var EI=L(13533),iI=L(13541),VI=L(13543),jI=L(13546);function CI(I){return I===VI.e.PositionKind?"POSITION":I===VI.e.NormalKind?"NORMAL":I===VI.e.ColorKind?"COLOR":I.startsWith(VI.e.UVKind)?"TEX_COORD":"GENERIC"}const bI={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Ix extends EI.e{static get DefaultAvailable(){return(0,EI.i)(Ix.DefaultConfiguration)}static get Default(){return Ix._Default??(Ix._Default=new Ix),Ix._Default}static ResetDefault(I){Ix._Default&&(I||Ix._Default.dispose(),Ix._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(I,x){return{module:await(x||DracoEncoderModule)({wasmBinary:I})}}_getWorkerContent(){return`${iI.l}(${iI.p})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ix.DefaultConfiguration)}async _encodeAsync(I,x,L){const F=L?(0,jI.b)(bI,L):bI;if(this._workerPoolPromise){const L=await this._workerPoolPromise;return await new Promise(((X,G)=>{L.push(((L,Y)=>{const p=I=>{L.removeEventListener("error",p),L.removeEventListener("message",B),G(I),Y()},B=I=>{"encodeMeshDone"===I.data.id&&(L.removeEventListener("error",p),L.removeEventListener("message",B),X(I.data.encodedMeshData),Y())};L.addEventListener("error",p),L.addEventListener("message",B);const l=[];for(const x of I)l.push(x.data.buffer);x&&l.push(x.buffer),L.postMessage({id:"encodeMesh",attributes:I,indices:x,options:F},l)}))}))}if(this._modulePromise){const L=await this._modulePromise;return(0,iI.l)(L.module,I,x,F)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(I,x){if(0==I.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");I instanceof UI.e&&I.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===x||void 0===x?void 0:x.method)&&(a.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),x.method="MESH_SEQUENTIAL_ENCODING");const L=function(I){let x=I.XB(void 0,!0);return!x||x instanceof Uint32Array||x instanceof Uint16Array||(x=((0,k.d)(x,x.length)?Uint32Array:Uint16Array).from(x)),x}(I),F=function(I,x){const L=[];for(const F of I.getVerticesDataKinds()){if(null!==x&&void 0!==x&&x.includes(F)){if(F===VI.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const X=I.getVertexBuffer(F),G=X.getSize(),Y=(0,k.r)(X.getData(),G,X.type,X.byteOffset,X.byteStride,X.normalized,I.getTotalVertices(),!0);L.push({kind:F,dracoName:CI(F),size:G,data:Y})}return L}(I,null===x||void 0===x?void 0:x.excludedAttributes);return await this._encodeAsync(F,L,x)}}Ix.DefaultConfiguration={wasmUrl:`${X.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${X.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${X.Tools._DefaultCdnUrl}/draco_encoder.js`},Ix._Default=null;const xx="KHR_draco_mesh_compression";class Lx{get wasUsed(){return this._wasUsed}constructor(I){this.name=xx,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===I.options.meshCompressionMethod&&Ix.DefaultAvailable}dispose(){}postExportMeshPrimitive(I,x,L){if(!this.enabled)return;if(4!==I.mode&&5!==I.mode)return void a.c.Warn("Cannot compress primitive with mode "+I.mode+".");const F=[],X=[];let G=null;if(void 0!==I.indices){const Y=L[I.indices],p=x.getBufferView(Y);G=x.getData(p).slice(),F.push(p),X.push(Y)}const Y=[];for(const[W,Q]of Object.entries(I.attributes)){const I=L[Q],G=x.getBufferView(I),B=h(I.type),l=(0,k.r)(x.getData(G),B,I.componentType,I.byteOffset||0,G.byteStride||(0,k.l)(I.componentType)*B,I.normalized||!1,I.count,!0);Y.push({kind:W,dracoName:(p=W,"POSITION"===p?"POSITION":"NORMAL"===p?"NORMAL":p.startsWith("COLOR")?"COLOR":p.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:h(I.type),data:l}),F.push(G),X.push(I)}var p;const B={method:I.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},l=Ix.Default._encodeAsync(Y,G,B).then((L=>{if(!L)return void a.c.Error("Draco encoding failed for primitive.");const G={bufferView:-1,attributes:L.attributeIds},Y=x.createBufferView(L.data);x.setBufferView(G,Y);for(const I of F)this._bufferViewsUsed.add(I);for(const I of X)this._accessorsUsed.add(I);I.extensions||(I.extensions={}),I.extensions[xx]=G})).catch((I=>{a.c.Error("Draco encoding failed for primitive: "+I)}));this._encodePromises.push(l),this._wasUsed=!0}async preGenerateBinaryAsync(I){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((x=>{I.getPropertiesWithBufferView(x).every((I=>this._accessorsUsed.has(I)))&&I.removeBufferView(x)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}cI.RegisterExtension(xx,(I=>new Lx(I)));var Fx=L(13553);const Xx="KHR_lights_punctual",Gx={name:"",color:[1,1,1],eB:1,range:Number.MAX_VALUE},Yx={innerConeAngle:0,outerConeAngle:Math.PI/4},px=F.sx.Backward();class Bx{constructor(I){this.name=Xx,this.enabled=!0,this.required=!1,this._exporter=I}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Xx]=this._lights}async postExportNodeAsync(I,x,L,X,G){return await new Promise((Y=>{if(!(L instanceof qI.c))return void Y(x);const p=L.getTypeID()==qI.c.LIGHTTYPEID_POINTLIGHT?"point":L.getTypeID()==qI.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":L.getTypeID()==qI.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!p||!(L instanceof Fx.d))return a.c.Warn(`${I}: Light ${L.name} is not supported in ${Xx}`),void Y(x);if(L.falloffType!==qI.c.FALLOFF_GLTF&&a.c.Warn(`${I}: Light falloff for ${L.name} does not match the ${Xx} specification!`),!L.position.equalsToFloats(0,0,0)){const I=F.TmpVectors.sx[0].X(L.position);G&&j(I),x.translation=I.Cp()}if("point"!==p){const I=L.direction.normalizeToRef(F.TmpVectors.sx[0]);G&&j(I);const X=F.Quaternion.FromUnitVectorsToRef(px,I,F.TmpVectors.Quaternion[0]);F.Quaternion.IsIdentity(X)||(x.rotation=X.Cp())}const B={type:p,name:L.name,color:L.gB.Cp(),eB:L.eB,range:L.range};if(FI(B,Gx),"spot"===p){const I=L;B.spot={innerConeAngle:I.innerAngle/2,outerConeAngle:I.angle/2},FI(B.spot,Yx)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(B);const l={Up:this._lights.lights.length-1},W=L.parent;if(W&&xI(L,W)){const I=X.get(W);if(I){const L=this._exporter._nodes[I];return II(x,L),L.extensions||(L.extensions={}),L.extensions[Xx]=l,void Y(null)}}x.extensions||(x.extensions={}),x.extensions[Xx]=l,Y(x)}))}}cI.RegisterExtension(Xx,(I=>new Bx(I)));var lx=L(13478);const Wx="KHR_materials_anisotropy";class Qx{constructor(I){this.name=Wx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,x,L){const F=[];return L instanceof lx.d&&L.anisotropy.isEnabled&&!L.anisotropy.legacy?(L.anisotropy.texture&&F.push(L.anisotropy.texture),F):[]}postExportMaterialAsync(I,x,L){return new Promise((I=>{if(L instanceof lx.d){if(!L.anisotropy.isEnabled||L.anisotropy.legacy)return void I(x);this._wasUsed=!0,x.extensions=x.extensions||{};const F=this._exporter._materialExporter.getTextureInfo(L.anisotropy.texture),X={anisotropyStrength:L.anisotropy.eB,anisotropyRotation:L.anisotropy.angle,anisotropyTexture:F??void 0};null!==X.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(L),x.extensions[Wx]=X}I(x)}))}}cI.RegisterExtension(Wx,(I=>new Qx(I)));const ex="KHR_materials_clearcoat";class gx{constructor(I){this.name=ex,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,x,L){const F=[];return L instanceof lx.d&&L.clearCoat.isEnabled?(L.clearCoat.texture&&F.push(L.clearCoat.texture),!L.clearCoat.useRoughnessFromMainTexture&&L.clearCoat.textureRoughness&&F.push(L.clearCoat.textureRoughness),L.clearCoat.bumpTexture&&F.push(L.clearCoat.bumpTexture),F):[]}postExportMaterialAsync(I,x,L){return new Promise((I=>{if(L instanceof lx.d){if(!L.clearCoat.isEnabled)return void I(x);this._wasUsed=!0,x.extensions=x.extensions||{};const F=this._exporter._materialExporter.getTextureInfo(L.clearCoat.texture);let G;G=L.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(L.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(L.clearCoat.textureRoughness),L.clearCoat.isTintEnabled&&X.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${L.name}`),L.clearCoat.remapF0OnInterfaceChange&&X.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${L.name}`);const Y=this._exporter._materialExporter.getTextureInfo(L.clearCoat.bumpTexture),p={clearcoatFactor:L.clearCoat.eB,clearcoatTexture:F??void 0,clearcoatRoughnessFactor:L.clearCoat.roughness,clearcoatRoughnessTexture:G??void 0,clearcoatNormalTexture:Y??void 0};null===p.clearcoatTexture&&null===p.clearcoatRoughnessTexture&&null===p.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(L),x.extensions[ex]=p}I(x)}))}}cI.RegisterExtension(ex,(I=>new gx(I)));const vx="KHR_materials_diffuse_transmission";function zx(I,x){const L=x.subSurface;let F=null;return L.translucencyIntensityTexture?F=L.translucencyIntensityTexture:L.thicknessTexture&&L.useMaskFromThicknessTexture&&(F=L.thicknessTexture),F&&!L.useGltfStyleTextures?(a.c.Warn(`${I}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${x.name}`,1),null):F}class Hx{constructor(I){this.name=vx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,x,L){const F=[];if(L instanceof vI.b&&this._isExtensionEnabled(L)){const x=zx(I,L);return x&&F.push(x),L.subSurface.translucencyColorTexture&&F.push(L.subSurface.translucencyColorTexture),F}return F}_isExtensionEnabled(I){if(I.unlit)return!1;const x=I.subSurface;return!!x.isTranslucencyEnabled&&(!I.unlit&&!x.useAlbedoToTintTranslucency&&x.useGltfStyleTextures&&1===x.volumeIndexOfRefraction&&0===x.minimumThickness&&0===x.maximumThickness)}postExportMaterialAsync(I,x,L){return new Promise((F=>{if(L instanceof vI.b&&this._isExtensionEnabled(L)){this._wasUsed=!0;const F=L.subSurface,X=zx(I,L),G=0==F.translucencyIntensity?void 0:F.translucencyIntensity,Y=this._exporter._materialExporter.getTextureInfo(X)??void 0,p=!F.translucencyColor||F.translucencyColor.equalsFloats(1,1,1)?void 0:F.translucencyColor.Cp(),B=this._exporter._materialExporter.getTextureInfo(F.translucencyColorTexture)??void 0,l={diffuseTransmissionFactor:G,diffuseTransmissionTexture:Y,diffuseTransmissionColorFactor:p,diffuseTransmissionColorTexture:B};(Y||B)&&this._exporter._materialNeedsUVsSet.add(L),x.extensions=x.extensions||{},x.extensions[vx]=l}F(x)}))}}cI.RegisterExtension(vx,(I=>new Hx(I)));const sx="KHR_materials_dispersion";class Ux{constructor(){this.name=sx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(I){if(I.unlit)return!1;const x=I.subSurface;return!(!x.isRefractionEnabled&&!x.isDispersionEnabled)}postExportMaterialAsync(I,x,L){return new Promise((I=>{if(L instanceof vI.b&&this._isExtensionEnabled(L)){this._wasUsed=!0;const I={dispersion:L.subSurface.dispersion};x.extensions=x.extensions||{},x.extensions[sx]=I}I(x)}))}}cI.RegisterExtension(sx,(()=>new Ux));const qx="KHR_materials_emissive_strength";class yx{constructor(){this.name=qx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(I,x,L){return await new Promise((I=>{if(!(L instanceof vI.b))return I(x);const F=L.emissiveColor.Cp(),X=Math.max(...F);if(X>1){this._wasUsed=!0,x.extensions||(x.extensions={});const I={emissiveStrength:X},F=L.emissiveColor.scale(1/I.emissiveStrength);x.emissiveFactor=F.Cp(),x.extensions[qx]=I}return I(x)}))}}cI.RegisterExtension(qx,(I=>new yx));const Tx="KHR_materials_ior";class Zx{constructor(){this.name=Tx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(I){return!I.unlit&&(void 0!=I.indexOfRefraction&&1.5!=I.indexOfRefraction)}postExportMaterialAsync(I,x,L){return new Promise((I=>{if(L instanceof vI.b&&this._isExtensionEnabled(L)){this._wasUsed=!0;const I={ior:L.indexOfRefraction};x.extensions=x.extensions||{},x.extensions[Tx]=I}I(x)}))}}cI.RegisterExtension(Tx,(I=>new Zx));const tx="KHR_materials_iridescence";class fx{constructor(I){this.name=tx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,x,L){const F=[];return L instanceof lx.d&&L.iridescence.isEnabled?(L.iridescence.texture&&F.push(L.iridescence.texture),L.iridescence.thicknessTexture&&L.iridescence.thicknessTexture!==L.iridescence.texture&&F.push(L.iridescence.thicknessTexture),F):[]}postExportMaterialAsync(I,x,L){return new Promise((I=>{if(L instanceof lx.d){if(!L.iridescence.isEnabled)return void I(x);this._wasUsed=!0,x.extensions=x.extensions||{};const F=this._exporter._materialExporter.getTextureInfo(L.iridescence.texture),X=this._exporter._materialExporter.getTextureInfo(L.iridescence.thicknessTexture),G={iridescenceFactor:L.iridescence.eB,iridescenceIor:L.iridescence.indexOfRefraction,iridescenceThicknessMinimum:L.iridescence.minimumThickness,iridescenceThicknessMaximum:L.iridescence.maximumThickness,iridescenceTexture:F??void 0,iridescenceThicknessTexture:X??void 0};null===G.iridescenceTexture&&null===G.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(L),x.extensions[tx]=G}I(x)}))}}cI.RegisterExtension(tx,(I=>new fx(I)));const Rx="KHR_materials_sheen";class nx{constructor(I){this.name=Rx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,x,L){return L instanceof vI.b&&L.sheen.isEnabled&&L.sheen.texture?[L.sheen.texture]:[]}async postExportMaterialAsync(I,x,L){return await new Promise((I=>{if(L instanceof vI.b){if(!L.sheen.isEnabled)return void I(x);this._wasUsed=!0,null==x.extensions&&(x.extensions={});const F={sheenColorFactor:L.sheen.color.Cp(),sheenRoughnessFactor:L.sheen.roughness??0};null===F.sheenColorTexture&&null===F.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(L),L.sheen.texture&&(F.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(L.sheen.texture)??void 0),L.sheen.textureRoughness&&!L.sheen.useRoughnessFromMainTexture?F.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(L.sheen.textureRoughness)??void 0:L.sheen.texture&&L.sheen.useRoughnessFromMainTexture&&(F.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(L.sheen.texture)??void 0),x.extensions[Rx]=F}I(x)}))}}cI.RegisterExtension(Rx,(I=>new nx(I)));const Px="KHR_materials_specular";class dx{constructor(I){this.name=Px,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,x,L){const F=[];return L instanceof vI.b&&this._isExtensionEnabled(L)?(L.metallicReflectanceTexture&&F.push(L.metallicReflectanceTexture),L.reflectanceTexture&&F.push(L.reflectanceTexture),F):F}_isExtensionEnabled(I){return!I.unlit&&(void 0!=I.metallicF0Factor&&1!=I.metallicF0Factor||void 0!=I.metallicReflectanceColor&&!I.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(I))}_hasTexturesExtension(I){return null!=I.metallicReflectanceTexture||null!=I.reflectanceTexture}postExportMaterialAsync(I,x,L){return new Promise((I=>{if(L instanceof vI.b&&this._isExtensionEnabled(L)){this._wasUsed=!0,x.extensions=x.extensions||{};const I=this._exporter._materialExporter.getTextureInfo(L.metallicReflectanceTexture)??void 0,F=this._exporter._materialExporter.getTextureInfo(L.reflectanceTexture)??void 0,X={specularFactor:1==L.metallicF0Factor?void 0:L.metallicF0Factor,specularTexture:I,specularColorFactor:L.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:L.metallicReflectanceColor.Cp(),specularColorTexture:F};this._hasTexturesExtension(L)&&this._exporter._materialNeedsUVsSet.add(L),x.extensions[Px]=X}I(x)}))}}cI.RegisterExtension(Px,(I=>new dx(I)));const Mx="KHR_materials_transmission";class Kx{constructor(I){this.name=Mx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,x,L){const F=[];return L instanceof vI.b&&this._isExtensionEnabled(L)?(L.subSurface.thicknessTexture&&F.push(L.subSurface.thicknessTexture),F):F}_isExtensionEnabled(I){if(I.unlit)return!1;const x=I.subSurface;return x.isRefractionEnabled&&void 0!=x.refractionIntensity&&0!=x.refractionIntensity||this._hasTexturesExtension(I)}_hasTexturesExtension(I){return null!=I.subSurface.refractionIntensityTexture}async postExportMaterialAsync(I,x,L){if(L instanceof vI.b&&this._isExtensionEnabled(L)){this._wasUsed=!0;const F=L.subSurface,X={transmissionFactor:0===F.refractionIntensity?void 0:F.refractionIntensity};if(this._hasTexturesExtension(L)&&this._exporter._materialNeedsUVsSet.add(L),F.refractionIntensityTexture)if(F.useGltfStyleTextures){const I=await this._exporter._materialExporter.exportTextureAsync(F.refractionIntensityTexture,"image/png");I&&(X.transmissionTexture=I)}else a.c.Warn(`${I}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);x.extensions||(x.extensions={}),x.extensions[Mx]=X}return x}}cI.RegisterExtension(Mx,(I=>new Kx(I)));const ux="KHR_materials_unlit";class Ax{constructor(){this.name=ux,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(I,x,L){return new Promise((I=>{let F=!1;L instanceof vI.b?F=L.unlit:L instanceof zI.yx&&(F=L.Zx),F&&(this._wasUsed=!0,null==x.extensions&&(x.extensions={}),x.extensions[ux]={}),I(x)}))}}cI.RegisterExtension(ux,(()=>new Ax));const mL="KHR_materials_volume";class Ox{constructor(I){this.name=mL,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,x,L){const F=[];return L instanceof vI.b&&this._isExtensionEnabled(L)?(L.subSurface.thicknessTexture&&F.push(L.subSurface.thicknessTexture),F):F}_isExtensionEnabled(I){if(I.unlit)return!1;const x=I.subSurface;return!(!x.isRefractionEnabled&&!x.isTranslucencyEnabled)&&(void 0!=x.maximumThickness&&0!=x.maximumThickness||void 0!=x.tintColorAtDistance&&x.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=x.tintColor&&x.tintColor!=H.Tx.White()||this._hasTexturesExtension(I))}_hasTexturesExtension(I){return null!=I.subSurface.thicknessTexture}postExportMaterialAsync(I,x,L){return new Promise((I=>{if(L instanceof vI.b&&this._isExtensionEnabled(L)){this._wasUsed=!0;const I=L.subSurface,F={thicknessFactor:0==I.maximumThickness?void 0:I.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(I.thicknessTexture)??void 0,attenuationDistance:I.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:I.tintColorAtDistance,attenuationColor:I.tintColor.equalsFloats(1,1,1)?void 0:I.tintColor.Cp()};this._hasTexturesExtension(L)&&this._exporter._materialNeedsUVsSet.add(L),x.extensions=x.extensions||{},x.extensions[mL]=F}I(x)}))}}cI.RegisterExtension(mL,(I=>new Ox(I)));const wx="EXT_materials_diffuse_roughness";class kx{constructor(I){this.name=wx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,x,L){const F=[];return L instanceof lx.d&&L._baseDiffuseRoughness?(L._baseDiffuseRoughnessTexture&&F.push(L._baseDiffuseRoughnessTexture),F):[]}postExportMaterialAsync(I,x,L){return new Promise((I=>{if(L instanceof lx.d){if(!L._baseDiffuseRoughness)return void I(x);this._wasUsed=!0,x.extensions=x.extensions||{};const F=this._exporter._materialExporter.getTextureInfo(L._baseDiffuseRoughnessTexture),X={diffuseRoughnessFactor:L._baseDiffuseRoughness,diffuseRoughnessTexture:F??void 0};null!==X.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(L),x.extensions[wx]=X}I(x)}))}}cI.RegisterExtension(wx,(I=>new kx(I)));const ax="KHR_texture_transform";class Dx{constructor(){this.name=ax,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(I,x,L){if(L.tI()||X.Tools.Warn(`${I}: /*@__KEY__*/"scene" is not defined for Babylon texture ${L.name}!`),(0!==L.uAng||0!==L.vAng)&&(X.Tools.Warn(`${I}: Texture ${L.name} with rotation in the u or v axis is not supported in glTF.`),0!==L.uRotationCenter||0!==L.vRotationCenter))return;const F={};let G=!1;if(0===L.uOffset&&0===L.vOffset||(F.offset=[L.uOffset,L.vOffset],G=!0),1===L.uScale&&1===L.vScale||(F.scale=[L.uScale,L.vScale],G=!0),0!==L.wAng){if(0!==L.uRotationCenter||0!==L.vRotationCenter){if(L.homogeneousRotationInUVTransform&&L.uScale!==L.vScale)return void X.Tools.Warn(`${I}: Texture ${L.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${ax}.`);X.Tools.Warn(`${I}: Texture ${L.name} with non-origin rotation center will be exported using an adjusted offset with ${ax}.`),F.offset=function(I){const{uOffset:x,vOffset:L,uRotationCenter:F,vRotationCenter:X,uScale:G,vScale:Y,wAng:p}=I,B=Math.cos(p),l=Math.sin(p),W=F*G,Q=X*Y;return[x+(W*(1-B)+Q*l),L+(Q*(1-B)-W*l)]}(L)}F.rotation=-L.wAng,G=!0}0!==L.coordinatesIndex&&(F.texCoord=L.coordinatesIndex,G=!0),G&&(this._wasUsed=!0,x.extensions||(x.extensions={}),x.extensions[ax]=F)}}cI.RegisterExtension(ax,(()=>new Dx));class rx{static CreateSTL(I){let x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",X=arguments.length>3&&void 0!==arguments[3]&&arguments[3],G=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],Y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],p=arguments.length>6&&void 0!==arguments[6]&&arguments[6],B=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const l=function(I,x,L){const X=[3*I[L],3*I[L+1],3*I[L+2]],G=[new F.sx(x[X[0]],x[X[0]+2],x[X[0]+1]),new F.sx(x[X[1]],x[X[1]+2],x[X[1]+1]),new F.sx(x[X[2]],x[X[2]+2],x[X[2]+1])],Y=G[0].Ux(G[1]),p=G[2].Ux(G[1]);return{v:G,n:F.sx.Cross(p,Y).normalize()}},Q=function(I,x,L,F){return x=e(I,x,L.x,F),x=e(I,x,L.y,F),e(I,x,L.z,F)},e=function(I,x,L,F){return I.setFloat32(x,L,F),x+4},v=function(I){if(p){let x=I;I instanceof g.b&&(x=I.sourceMesh);const L=x.getVerticesData(W.g.PositionKind,!0,!0);if(!L)return[];const X=F.sx.Zero();let G;for(G=0;G<L.length;G+=3)F.sx.TransformCoordinatesFromFloatsToRef(L[G],L[G+1],L[G+2],I.LB(!0),X).toArray(L,G);return L}return I.getVerticesData(W.g.PositionKind)||[]};p&&(Y=!0);let z="",H=0,s=0;if(X){for(let L=0;L<I.length;L++){const x=I[L].XB();H+=x?x.length/3:0}const x=new ArrayBuffer(84+50*H);z=new DataView(x),s+=80,z.setUint32(s,H,G),s+=4}else B||(z="solid stlmesh\r\n");for(let F=0;F<I.length;F++){const x=I[F];!X&&B&&(z+="solid "+x.name+"\r\n"),!Y&&x instanceof UI.e&&x.bakeCurrentTransformIntoVertices();const L=v(x),p=x.XB()||[];for(let I=0;I<p.length;I+=3){const x=l(p,L,I);X?(s=Q(z,s,x.n,G),s=Q(z,s,x.v[0],G),s=Q(z,s,x.v[1],G),s=Q(z,s,x.v[2],G),s+=2):(z+="\tfacet normal "+x.n.x+" "+x.n.y+" "+x.n.z+"\r\n",z+="\t\touter loop\r\n",z+="\t\t\tvertex "+x.v[0].x+" "+x.v[0].y+" "+x.v[0].z+"\r\n",z+="\t\t\tvertex "+x.v[1].x+" "+x.v[1].y+" "+x.v[1].z+"\r\n",z+="\t\t\tvertex "+x.v[2].x+" "+x.v[2].y+" "+x.v[2].z+"\r\n",z+="\t\tendloop\r\n",z+="\tendfacet\r\n")}!X&&B&&(z+="endsolid "+name+"\r\n")}if(X||B||(z+="endsolid stlmesh"),x){const I=document.createElement("a"),x=new Blob([z],{type:"application/octet-stream"});I.href=window.URL.createObjectURL(x),I.download=L+".stl",I.click()}return z}}function Nx(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const F=[];for(let X=0;X<I.length/L;X++){const G=I[X*L],Y=I[X*L+1],p=I[X*L+2];F.push(`(${G.toPrecision(x.precision)}, ${Y.toPrecision(x.precision)}, ${p.toPrecision(x.precision)})`)}return F.join(", ")}function Sx(I,x){const L=[];for(let F=0;F<I.length/2;F++){const X=I[2*F],G=I[2*F+1];L.push(`(${X.toPrecision(x.precision)}, ${(1-G).toPrecision(x.precision)})`)}return L.join(", ")}function cx(I,x){const L=I.getVerticesData(W.g.PositionKind),F=I.getVerticesData(W.g.NormalKind);if(L&&F)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(I){var x;const L=null!==(x=I.XB())&&void 0!==x&&x.length?I.getTotalIndices():I.getTotalVertices();return Array(L/3).fill(3).join(", ")}(I)}]\n\t\tint[] faceVertexIndices = [${function(I){const x=I.XB(),L=[];if(null!==x)for(let F=0;F<x.length;F++)L.push(x[F]);else{const x=I.getTotalVertices();for(let I=0;I<x;I++)L.push(I)}return L.join(", ")}(I)}]\n\t\tnormal3f[] normals = [${Nx(F,x)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Nx(L,x)}]\n        ${function(I,x){let L="";for(let X=0;X<4;X++){const F=X>0?X:"",G=I.getVerticesData(W.g.UVKind+(F?F+1:""));G&&(L+=`\n\t\ttexCoord2f[] primvars:st${F} = [${Sx(G,x)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const F=I.getVerticesData(W.g.ColorKind);return F&&(L+=`\n\tcolor3f[] primvars:displayColor = [${Nx(F,x,F.length/I.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),L}(I,x)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function ox(I,x){return`\n        def "Geometry"\n        {\n        ${cx(I,x)}\n        }\n        `}function Jx(I){let x='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return x+=I,fflate.strToU8(x)}function hx(I){const x=I.m;return`( ${Ex(x,0)}, ${Ex(x,4)}, ${Ex(x,8)}, ${Ex(x,12)} )`}function Ex(I,x){return`(${I[x+0]}, ${I[x+1]}, ${I[x+2]}, ${I[x+3]})`}function ix(I){const x="Object_"+I.uniqueId,L=function(I){const x=I.getWorldMatrix().clone(),L=I.tI().useRightHandedSystem;if(!L){let F=I.parent;for(;F;){if(YI(F,L)){x.multiplyToRef(F.getWorldMatrix().invert(),x);break}F=F.parent}}return x.determinant()<0&&X.Tools.Warn(`Exporting mesh ${I.name} with negative scale. Result may look incorrect in destination engine.`),x}(I),F=hx(L);return`def Xform "${x}" (\n\tprepend references = @./geometries/Geometry_${I.FB.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${F}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${I.material.uniqueId}>\n}\n\n`}function Vx(I){switch(I){case t.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case t.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case t.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function jx(I){return`(${I.x}, ${I.y})`}function Cx(I){return`(${I.r}, ${I.g}, ${I.b})`}function bx(I,x,L,X,G,Y){const p=I.getInternalTexture().uniqueId+"_"+I.invertY;G[p]=I;const B=I.coordinatesIndex>0?"st"+I.coordinatesIndex:"st",l=new F.Vector2(I.uScale,I.vScale),W=new F.Vector2(I.uOffset,I.vOffset),Q=I.wAng,e=Math.sin(Q),g=Math.cos(Q);return W.y=1-W.y-l.y,W.x+=e*l.x,W.y+=(1-g)*l.y,`\n    def Shader "PrimvarReader_${L}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${B}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${L}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${x.uniqueId}/PrimvarReader_${L}.outputs:result>\n        float inputs:rotation = ${(Q*(180/Math.PI)).toFixed(Y.precision)}\n        float2 inputs:scale = ${jx(l)}\n        float2 inputs:translation = ${jx(W)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${I.uniqueId}_${L}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${p}.png@\n        float2 inputs:st.connect = </Materials/Material_${x.uniqueId}/Transform2d_${L}.outputs:result>\n        ${X?"float4 inputs:scale = "+function(I){return`(${I.r}, ${I.g}, ${I.b}, 1.0)`}(X):""}\n        token inputs:sourceColorSpace = "${I.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Vx(I.wrapU)}"\n        token inputs:wrapT = "${Vx(I.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${x.needAlphaBlending()?"float outputs:a":""}\n    }`}function IL(I,x,L){const F="\t\t\t",X=[],G=[],{diffuseMap:Y,gB:p,alphaCutOff:B,emissiveMap:l,emissive:W,normalMap:Q,roughnessMap:e,roughnessChannel:g,roughness:v,metalnessMap:z,metalnessChannel:s,metalness:U,aoMap:q,aoMapChannel:y,aoMapIntensity:T,alphaMap:Z,ior:t,clearCoatEnabled:f,clearCoat:R,clearCoatMap:n,clearCoatRoughness:P,clearCoatRoughnessMap:d}=function(I){const x={diffuseMap:null,gB:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return I instanceof zI.yx?{...x,diffuseMap:I.diffuseTexture,gB:I.diffuseColor,alphaCutOff:I.alphaCutOff,emissiveMap:I.emissiveTexture,emissive:I.emissiveColor,roughness:1,alphaMap:I.opacityTexture}:I instanceof lx.d?{...x,diffuseMap:I._albedoTexture,gB:I._albedoColor,alphaCutOff:I._alphaCutOff,emissiveMap:I._emissiveTexture,emissive:I._emissiveColor,normalMap:I._bumpTexture,roughnessMap:I._metallicTexture,roughnessChannel:I._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:I._roughness??1,metalnessMap:I._metallicTexture,metalnessChannel:I._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:I._metallic??0,aoMap:I._ambientTexture,aoMapChannel:I._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:I._ambientTextureStrength,alphaMap:I._opacityTexture,ior:I.subSurface.indexOfRefraction,clearCoatEnabled:I.clearCoat.isEnabled,clearCoat:I.clearCoat.eB,clearCoatMap:I.clearCoat.texture,clearCoatRoughness:I.clearCoat.roughness,clearCoatRoughnessMap:I.clearCoat.useRoughnessFromMainTexture?I.clearCoat.texture:I.clearCoat.textureRoughness}:x}(I);return null!==Y?(X.push(`${F}color3f inputs:diffuseColor.connect = </Materials/Material_${I.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:rgb>`),I.needAlphaBlending()?X.push(`${F}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`):I.needAlphaTesting()&&(X.push(`${F}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`),X.push(`${F}float inputs:opacityThreshold = ${B}`)),G.push(bx(Y,I,"diffuse",p,x,L))):X.push(`${F}color3f inputs:diffuseColor = ${Cx(p||H.Tx.White())}`),null!==l?(X.push(`${F}color3f inputs:emissiveColor.connect = </Materials/Material_${I.uniqueId}/Texture_${l.uniqueId}_emissive.outputs:rgb>`),G.push(bx(l,I,"emissive",W,x,L))):W&&W.toLuminance()>0&&X.push(`${F}color3f inputs:emissiveColor = ${Cx(W)}`),null!==Q&&(X.push(`${F}normal3f inputs:normal.connect = </Materials/Material_${I.uniqueId}/Texture_${Q.uniqueId}_normal.outputs:rgb>`),G.push(bx(Q,I,"normal",null,x,L))),null!==q&&(X.push(`${F}float inputs:occlusion.connect = </Materials/Material_${I.uniqueId}/Texture_${q.uniqueId}_occlusion.outputs:${y}>`),G.push(bx(q,I,"occlusion",new H.Tx(T,T,T),x,L))),null!==e?(X.push(`${F}float inputs:roughness.connect = </Materials/Material_${I.uniqueId}/Texture_${e.uniqueId}_roughness.outputs:${g}>`),G.push(bx(e,I,"roughness",new H.Tx(v,v,v),x,L))):X.push(`${F}float inputs:roughness = ${v}`),null!==z?(X.push(`${F}float inputs:metallic.connect = </Materials/Material_${I.uniqueId}/Texture_${z.uniqueId}_metallic.outputs:${s}>`),G.push(bx(z,I,"metallic",new H.Tx(U,U,U),x,L))):X.push(`${F}float inputs:metallic = ${U}`),null!==Z?(X.push(`${F}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${Z.uniqueId}_opacity.outputs:r>`),X.push(`${F}float inputs:opacityThreshold = 0.0001`),G.push(bx(Z,I,"opacity",null,x,L))):X.push(`${F}float inputs:opacity = ${I.alpha}`),f&&(null!==n?(X.push(`${F}float inputs:clearcoat.connect = </Materials/Material_${I.uniqueId}/Texture_${n.uniqueId}_clearcoat.outputs:r>`),G.push(bx(n,I,"clearcoat",new H.Tx(R,R,R),x,L))):X.push(`${F}float inputs:clearcoat = ${R}`),null!==d?(X.push(`${F}float inputs:clearcoatRoughness.connect = </Materials/Material_${I.uniqueId}/Texture_${d.uniqueId}_clearcoatRoughness.outputs:g>`),G.push(bx(d,I,"clearcoatRoughness",new H.Tx(P,P,P),x,L))):X.push(`${F}float inputs:clearcoatRoughness = ${P}`)),X.push(`${F}float inputs:ior = ${t}`),`\n\tdef Material "Material_${I.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${X.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${I.uniqueId}/PreviewSurface.outputs:surface>\n\n${G.join("\n")}\n\n\t}\n`}async function xL(I,x,L){const G={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...x};"undefined"===typeof fflate&&await X.Tools.LoadScriptAsync(G.fflateUrl);const Y={};Y[G.modelFileName]=null;let p='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';p+=function(I){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===I.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${I.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${I.planeAnchoringAlignment}"`:""}\n            `}(G);const B={};for(const F of I.meshes){if(0===F.getTotalVertices())continue;const I=F,x=I.FB,l=I.material;if(!l||!x||L&&!L(I))continue;if(-1!==["yx","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(l.getClassName())){const L="geometries/Geometry_"+x.uniqueId+".usda";if(!(L in Y)){const I=ox(x,G);Y[L]=Jx(I)}l.uniqueId in B||(B[l.uniqueId]=l),p+=ix(I)}else X.Tools.Warn("USDZExportAsync does not support this material type: "+l.getClassName())}I.activeCamera&&G.exportCamera&&(p+=function(I,x){const L="Camera_"+I.uniqueId,X=hx(F.Matrix.RotationY(Math.PI).multiply(I.getWorldMatrix()));if(I.mode===t.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${L}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${X}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${I.IB.toPrecision(x.precision)}, ${I.maxZ.toPrecision(x.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(I.orthoLeft||1)+Math.abs(I.orthoRight||1))).toPrecision(x.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(I.orthoTop||1)+Math.abs(I.orthoBottom||1))).toPrecision(x.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const F=I.getEngine().getAspectRatio(I),G=x.cameraSensorWidth||35;return`def Camera "${L}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${X}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${I.IB.toPrecision(x.precision)}, ${I.maxZ.toPrecision(x.precision)})\n\t\t\tfloat focalLength = ${(G/(2*Math.tan(.5*I.fov))).toPrecision(x.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(G*F).toPrecision(x.precision)}\n\t\t\tfloat verticalAperture = ${(G/F).toPrecision(x.precision)}            \n\t\t}\n\t\n\t`}}(I.activeCamera,G)),p+="\n            }\n        }\n    }";const l={};p+=function(I,x,L){const F=[];for(const X in I){const G=I[X];F.push(IL(G,x,L))}return`\n    def "Materials"\n{\n${F.join("")}\n}\n\n`}(B,l,G),Y[G.modelFileName]=fflate.strToU8(p);for(const F in l){const I=l[F],x=I.getSize(),L=await I.readPixels();if(!L)throw new Error("Texture data is not available");const X=await f.DumpTools.DumpDataAsync(x.width,x.height,L,"image/png",void 0,!1,!0);Y[`textures/Texture_${F}.png`]=new Uint8Array(X).slice()}let W=0;for(const F in Y){const I=Y[F];if(!I)continue;W+=34+F.length;const x=63&W;if(4!==x){const L=new Uint8Array(64-x);Y[F]=[I,{extra:{12345:L}}]}W=I.length}return fflate.zipSync(Y,{level:0})}}}]);