"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[26],{13113:(K,A,T)=>{T.r(A),T.d(A,{EXT_materials_diffuse_roughness:()=>jA,EXT_mesh_gpu_instancing:()=>qK,GLTF2Export:()=>VK,GLTFData:()=>Q,KHR_draco_mesh_compression:()=>TA,KHR_lights_punctual:()=>CA,KHR_materials_anisotropy:()=>ZA,KHR_materials_clearcoat:()=>JA,KHR_materials_diffuse_transmission:()=>FA,KHR_materials_dispersion:()=>NA,KHR_materials_emissive_strength:()=>mT,KHR_materials_ior:()=>zA,KHR_materials_iridescence:()=>SA,KHR_materials_sheen:()=>uA,KHR_materials_specular:()=>nA,KHR_materials_transmission:()=>eA,KHR_materials_unlit:()=>rA,KHR_materials_volume:()=>kA,KHR_texture_transform:()=>vA,OBJExport:()=>f,STLExport:()=>IA,USDZExportAsync:()=>AT,_ConvertToGLTFPBRMetallicRoughness:()=>p,_SolveMetallic:()=>e,__IGLTFExporterExtension:()=>O});var G=T(12700),B=T(12526),L=T(13016);class f{static OBJ(K,A,T,f){const O=[];let C=1,Q=1;A&&(T||(T="mat"),O.push("mtllib "+T+".mtl"));for(let Y=0;Y<K.length;Y++){const T=K[Y],Z=T.name||`mesh${Y}}`;O.push(`o ${Z}`);let x=null;if(f){const K=T.wf(!0);x=new G.Matrix,K.invertToRef(x),T.bakeTransformIntoVertices(K)}if(A){const K=T.material;K&&O.push("usemtl "+K.id)}const J=T.Mf;if(!J){B.Tools.Warn("No geometry is present on the mesh");continue}const b=J.getVerticesData("position"),P=J.getVerticesData("normal"),F=J.getVerticesData("uv"),d=J.Ef();let N=0,D=0;if(!b||!d){B.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const mK=K[0].SK().useRightHandedSystem?1:-1;for(let K=0;K<b.length;K+=3)O.push("v "+b[K]*mK+" "+b[K+1]+" "+b[K+2]),N++;if(null!=P)for(let K=0;K<P.length;K+=3)O.push("vn "+P[K]*mK+" "+P[K+1]+" "+P[K+2]);if(null!=F)for(let K=0;K<F.length;K+=2)O.push("vt "+F[K]+" "+F[K+1]),D++;const U=["","",""],z=(T.material||T.SK().defaultMaterial)._getEffectiveOrientation(T),[g,S]=z===L.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let K=0;K<d.length;K+=3){const A=[String(d[K]+C),String(d[K+g]+C),String(d[K+S]+C)],T=[String(d[K]+Q),String(d[K+g]+Q),String(d[K+S]+Q)],G=A,B=null!=F?T:U,L=null!=P?A:U;O.push("f "+G[0]+"/"+B[0]+"/"+L[0]+" "+G[1]+"/"+B[1]+"/"+L[1]+" "+G[2]+"/"+B[2]+"/"+L[2])}f&&x&&T.bakeTransformIntoVertices(x),C+=N,Q+=D}return O.join("\n")}static MTL(K){const A=[],T=K.material;A.push("newmtl mat1"),A.push("  Ns "+T.specularPower.toFixed(4)),A.push("  Ni 1.5000"),A.push("  d "+T.alpha.toFixed(4)),A.push("  Tr 0.0000"),A.push("  Tf 1.0000 1.0000 1.0000"),A.push("  illum 2"),A.push("  Ka "+T.ambientColor.r.toFixed(4)+" "+T.ambientColor.g.toFixed(4)+" "+T.ambientColor.b.toFixed(4)),A.push("  Kd "+T.diffuseColor.r.toFixed(4)+" "+T.diffuseColor.g.toFixed(4)+" "+T.diffuseColor.b.toFixed(4)),A.push("  Ks "+T.specularColor.r.toFixed(4)+" "+T.specularColor.g.toFixed(4)+" "+T.specularColor.b.toFixed(4)),A.push("  Ke "+T.emissiveColor.r.toFixed(4)+" "+T.emissiveColor.g.toFixed(4)+" "+T.emissiveColor.b.toFixed(4));T.ambientTexture&&A.push("  map_Ka "+T.ambientTexture.name),T.diffuseTexture&&A.push("  map_Kd "+T.diffuseTexture.name),T.specularTexture&&A.push("  map_Ks "+T.specularTexture.name),T.bumpTexture&&A.push("  map_bump -imfchan z "+T.bumpTexture.name),T.opacityTexture&&A.push("  map_d "+T.opacityTexture.name);return A.join("\n")}}var O=0,C=T(12571);class Q{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const K in this.files){const A=this.files[K],T=new Blob([A],{type:(0,C.i)(K)});B.Tools.Download(T,K)}}}var Y=T(12768),Z=T(13118),x=T(13129),J=T(13142),b=T(12826),P=T(12565),F=T(12743),d=T(12716);const N=d.HighestCommonFactor,D={...d,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:N};var mK=T(12920),U=T(12674),z=T(13181),g=T(13186),S=T(12915);const l=1e-6,u=new F.DA(.04,.04,.04),c=1024,n=F.DA.White(),H=F.DA.Black();function e(K,A,T){if(A<u.r)return 0;const G=u.r,B=K*T/(1-u.r)+A-2*u.r,L=B*B-4*G*(u.r-A);return D.Clamp((-B+Math.sqrt(L))/(2*G),0,1)}function p(K){const A=K.diffuseColor.toLinearSpace(K.SK().getEngine().useExactSrgbConversions).scale(.5),T=K.alpha,B=function(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new G.Vector2(0,1),T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new G.Vector2(0,.1),B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new G.Vector2(0,.1),L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new G.Vector2(1300,.1);return function(K,A,T,G,B){return(1-K)*(1-K)*(1-K)*A+3*(1-K)*(1-K)*K*T+3*(1-K)*K*K*G+K*K*K*B}(Math.pow(K/L.x,.333333),A.y,T.y,B.y,L.y)}(D.Clamp(K.specularPower,0,c));return{baseColorFactor:[A.r,A.g,A.b,T],metallicFactor:0,roughnessFactor:B}}function r(K,A){A.needAlphaBlending()?K.alphaMode="BLEND":A.needAlphaTesting()&&(K.alphaMode="MASK",K.alphaCutoff=A.alphaCutOff)}function h(K,A,T){const G=new Uint8Array(K*A*4);for(let B=0;B<G.length;B+=4)G[B]=G[B+1]=G[B+2]=G[B+3]=255;return z.b.CreateRGBATexture(G,K,A,T)}function k(K){if(K instanceof Uint8Array){const A=K.length,T=new Float32Array(K.length);for(let G=0;G<A;++G)T[G]=K[G]/255;return T}if(K instanceof Float32Array)return K;throw new Error("Unsupported pixel format!")}class s{constructor(K){this._exporter=K,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(K){return K?this._textureMap.get(K)??null:null}async exportStandardMaterialAsync(K,A,T){const G=p(K),L={name:K.name};if(null==K.tf||K.tf||(K.twoSidedLighting||B.Tools.Warn(K.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),L.doubleSided=!0),T){const T=[],B=K.diffuseTexture;B&&T.push(this.exportTextureAsync(B,A).then((K=>{K&&(G.baseColorTexture=K)})));const f=K.bumpTexture;f&&T.push(this.exportTextureAsync(f,A).then((K=>{K&&(L.normalTexture=K,1!==f.level&&(L.normalTexture.scale=f.level))})));const O=K.emissiveTexture;O&&(L.emissiveFactor=[1,1,1],T.push(this.exportTextureAsync(O,A).then((K=>{K&&(L.emissiveTexture=K)}))));const C=K.ambientTexture;C&&T.push(this.exportTextureAsync(C,A).then((K=>{if(K){const A={index:K.index};L.occlusionTexture=A}}))),T.length>0&&(this._exporter._materialNeedsUVsSet.add(K),await Promise.all(T))}(K.alpha<1||K.opacityTexture)&&(K.alphaMode===g.d.ALPHA_COMBINE?L.alphaMode="BLEND":B.Tools.Warn(K.name+": glTF 2.0 does not support alpha mode: "+K.alphaMode.toString())),K.emissiveColor&&!K.emissiveColor.equalsWithEpsilon(H,l)&&(L.emissiveFactor=K.emissiveColor.kf()),L.pbrMetallicRoughness=G,r(L,K),await this._finishMaterialAsync(L,K,A);const f=this._exporter._materials;return f.push(L),f.length-1}async _finishMaterialAsync(K,A,T){const G=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",K,A),B=[];for(const L of G)B.push(this.exportTextureAsync(L,T));await Promise.all(B),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",K,A)}async _getImageDataAsync(K,A,G,B){const L=g.d.TEXTURETYPE_UNSIGNED_BYTE,f=this._exporter._babylonScene,O=f.getEngine(),C=O.createRawTexture(K,A,G,g.d.TEXTUREFORMAT_RGBA,!1,!0,U.c.NEAREST_SAMPLINGMODE,null,L);O.isWebGPU?await T.e(51).then(T.bind(T,15171)):await T.e(52).then(T.bind(T,15178)),await mK.i.ApplyPostProcess("pass",C,f,L,g.d.TEXTURE_NEAREST_SAMPLINGMODE,g.d.TEXTUREFORMAT_RGBA);const Q=await O._readTexturePixels(C,A,G);return await S.DumpTools.DumpDataAsync(A,G,Q,B,void 0,!0,!0)}_resizeTexturesToSameDimensions(K,A,T){const G=K?K.getSize():{width:0,height:0},B=A?A.getSize():{width:0,height:0};let L,f;return G.width<B.width?(L=K&&K instanceof U.c?mK.i.CreateResizedCopy(K,B.width,B.height,!0):h(B.width,B.height,T),f=A):G.width>B.width?(f=A&&A instanceof U.c?mK.i.CreateResizedCopy(A,G.width,G.height,!0):h(G.width,G.height,T),L=K):(L=K,f=A),{texture1:L,texture2:f}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(K,A,T,G){const B=new Array;if(!K&&!A)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const L=K?K.SK():A?A.SK():null;if(L){var f;const O=this._resizeTexturesToSameDimensions(K,A,L),C=null===(f=O.texture1)||void 0===f?void 0:f.getSize();let Q,Y;const Z=C.width,x=C.height,J=await O.texture1.readPixels(),b=await O.texture2.readPixels();if(!J)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(Q=k(J),!b)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");Y=k(b);const P=Y.byteLength,d=new Uint8Array(P),N=new Uint8Array(P),D=4,mK=H;let U=0,z=0;for(let K=0;K<x;++K)for(let A=0;A<Z;++A){const G=(Z*K+A)*D,B={diffuseColor:new F.DA(Q[G],Q[G+1],Q[G+2]).toLinearSpace(L.getEngine().useExactSrgbConversions).multiply(T.diffuseColor),specularColor:new F.DA(Y[G],Y[G+1],Y[G+2]).toLinearSpace(L.getEngine().useExactSrgbConversions).multiply(T.specularColor),glossiness:Y[G+3]*T.glossiness},f=this._convertSpecularGlossinessToMetallicRoughness(B);mK.r=Math.max(mK.r,f.baseColor.r),mK.g=Math.max(mK.g,f.baseColor.g),mK.b=Math.max(mK.b,f.baseColor.b),U=Math.max(U,f.metallic),z=Math.max(z,f.roughness),N[G]=255*f.baseColor.r,N[G+1]=255*f.baseColor.g,N[G+2]=255*f.baseColor.b,N[G+3]=O.texture1.sf?255*Q[G+3]:255,d[G]=0,d[G+1]=255*f.roughness,d[G+2]=255*f.metallic,d[G+3]=255}const g={baseColor:mK,metallic:U,roughness:z};let S=!1,u=!1;for(let K=0;K<x;++K)for(let A=0;A<Z;++A){const T=(Z*K+A)*D;N[T]/=g.baseColor.r>l?g.baseColor.r:1,N[T+1]/=g.baseColor.g>l?g.baseColor.g:1,N[T+2]/=g.baseColor.b>l?g.baseColor.b:1;const G=F.DA.FromInts(N[T],N[T+1],N[T+2]).toGammaSpace(L.getEngine().useExactSrgbConversions);N[T]=255*G.r,N[T+1]=255*G.g,N[T+2]=255*G.b,G.equalsWithEpsilon(n,l)||(u=!0),d[T+1]/=g.roughness>l?g.roughness:1,d[T+2]/=g.metallic>l?g.metallic:1;F.DA.FromInts(255,d[T+1],d[T+2]).equalsWithEpsilon(n,l)||(S=!0)}return S&&B.push(this._getImageDataAsync(d,Z,x,G).then((K=>{g.metallicRoughnessTextureData=K}))),u&&B.push(this._getImageDataAsync(N,Z,x,G).then((K=>{g.baseColorTextureData=K}))),await Promise.all(B).then((()=>g))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(K){const A=this._getPerceivedBrightness(K.diffuseColor),T=this._getPerceivedBrightness(K.specularColor),G=1-this._getMaxComponent(K.specularColor),B=e(A,T,G),L=K.diffuseColor.scale(G/(1-u.r)/Math.max(1-B)),f=K.specularColor.FA(u.scale(1-B)).scale(1/Math.max(B));let O=F.DA.Lerp(L,f,B*B);O=O.clampToRef(0,1,O);return{baseColor:O,metallic:B,roughness:1-K.glossiness}}_getPerceivedBrightness(K){return K?Math.sqrt(.299*K.r*K.r+.587*K.g*K.g+.114*K.b*K.b):0}_getMaxComponent(K){return K?Math.max(K.r,Math.max(K.g,K.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(K,A,T,G){const B=[],L={baseColor:K._albedoColor,metallic:K._metallic,roughness:K._roughness};if(G){K._albedoTexture&&B.push(this.exportTextureAsync(K._albedoTexture,A).then((K=>{K&&(T.baseColorTexture=K)})));const G=K._metallicTexture;G&&B.push(this.exportTextureAsync(G,A).then((K=>{K&&(T.metallicRoughnessTexture=K)})))}return B.length>0&&(this._exporter._materialNeedsUVsSet.add(K),await Promise.all(B)),L}_getTextureSampler(K){const A={};if(!K||!(K instanceof U.c))return A;const T=this._getGLTFTextureWrapMode(K.wrapU);10497!==T&&(A.wrapS=T);const G=this._getGLTFTextureWrapMode(K.wrapV);switch(10497!==G&&(A.wrapT=G),K.samplingMode){case U.c.LINEAR_LINEAR:A.magFilter=9729,A.minFilter=9729;break;case U.c.LINEAR_NEAREST:A.magFilter=9729,A.minFilter=9728;break;case U.c.NEAREST_LINEAR:A.magFilter=9728,A.minFilter=9729;break;case U.c.NEAREST_LINEAR_MIPLINEAR:A.magFilter=9728,A.minFilter=9987;break;case U.c.NEAREST_NEAREST:A.magFilter=9728,A.minFilter=9728;break;case U.c.NEAREST_LINEAR_MIPNEAREST:A.magFilter=9728,A.minFilter=9985;break;case U.c.LINEAR_NEAREST_MIPNEAREST:A.magFilter=9729,A.minFilter=9984;break;case U.c.LINEAR_NEAREST_MIPLINEAR:A.magFilter=9729,A.minFilter=9986;break;case U.c.NEAREST_NEAREST_MIPLINEAR:A.magFilter=9728,A.minFilter=9986;break;case U.c.LINEAR_LINEAR_MIPLINEAR:A.magFilter=9729,A.minFilter=9987;break;case U.c.LINEAR_LINEAR_MIPNEAREST:A.magFilter=9729,A.minFilter=9985;break;case U.c.NEAREST_NEAREST_MIPNEAREST:A.magFilter=9728,A.minFilter=9984}return A}_getGLTFTextureWrapMode(K){switch(K){case U.c.WRAP_ADDRESSMODE:return 10497;case U.c.CLAMP_ADDRESSMODE:return 33071;case U.c.MIRROR_ADDRESSMODE:return 33648;default:return B.Tools.Error(`Unsupported Texture Wrap Mode ${K}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(K,A,T,G){const B={diffuseColor:K._albedoColor,specularColor:K._reflectivityColor,glossiness:K._microSurface},L=K._albedoTexture,f=K._reflectivityTexture,O=K._useMicroSurfaceFromReflectivityMapAlpha;if(f&&!O)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((L||f)&&G){this._exporter._materialNeedsUVsSet.add(K);const G=this._exportTextureSampler(L||f),O=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(L,f,B,A),C=this._exporter._textures;if(O.baseColorTextureData){const K=this._exportImage(`baseColor${C.length}`,A,O.baseColorTextureData);T.baseColorTexture=this._exportTextureInfo(K,G,null===L||void 0===L?void 0:L.coordinatesIndex)}if(O.metallicRoughnessTextureData){const K=this._exportImage(`metallicRoughness${C.length}`,A,O.metallicRoughnessTextureData);T.metallicRoughnessTexture=this._exportTextureInfo(K,G,null===f||void 0===f?void 0:f.coordinatesIndex)}return O}return this._convertSpecularGlossinessToMetallicRoughness(B)}async exportPBRMaterialAsync(K,A,T){const G={},B={name:K.name},L=K.isMetallicWorkflow();if(L){const A=K._albedoColor,T=K.alpha;A&&(G.baseColorFactor=[A.r,A.g,A.b,T])}const f=L?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(K,A,G,T):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(K,A,G,T);await this._setMetallicRoughnessPbrMaterialAsync(f,K,B,G,A,T),await this._finishMaterialAsync(B,K,A);const O=this._exporter._materials;return O.push(B),O.length-1}async _setMetallicRoughnessPbrMaterialAsync(K,A,T,G,L,f){if(r(T,A),K.baseColor.equalsWithEpsilon(n,l)&&D.WithinEpsilon(A.alpha,1,l)||(G.baseColorFactor=[K.baseColor.r,K.baseColor.g,K.baseColor.b,A.alpha]),null!=K.metallic&&1!==K.metallic&&(G.metallicFactor=K.metallic),null!=K.roughness&&1!==K.roughness&&(G.roughnessFactor=K.roughness),null==A.tf||A.tf||(A._twoSidedLighting||B.Tools.Warn(A.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),T.doubleSided=!0),f){const K=[],G=A._bumpTexture;G&&K.push(this.exportTextureAsync(G,L).then((K=>{K&&(T.normalTexture=K,1!==G.level&&(T.normalTexture.scale=G.level))})));const B=A._ambientTexture;B&&K.push(this.exportTextureAsync(B,L).then((K=>{if(K){const G={index:K.index,texCoord:K.texCoord,extensions:K.extensions};T.occlusionTexture=G;const B=A._ambientTextureStrength;B&&(G.strength=B)}})));const f=A._emissiveTexture;f&&K.push(this.exportTextureAsync(f,L).then((K=>{K&&(T.emissiveTexture=K)}))),K.length>0&&(this._exporter._materialNeedsUVsSet.add(A),await Promise.all(K))}const O=A._emissiveColor;O.equalsWithEpsilon(H,l)||(T.emissiveFactor=O.kf()),T.pbrMetallicRoughness=G}_getPixelsFromTextureAsync(K){return function(K){switch(K){case g.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case g.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case g.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case g.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case g.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case g.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case g.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case g.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case g.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case g.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case g.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case g.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case g.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(K.textureFormat)?(0,mK.g)(K,K._texture.width,K._texture.height):(K.textureType,g.d.TEXTURETYPE_UNSIGNED_BYTE,K.readPixels())}async exportTextureAsync(K,A){const T=this._exporter._extensionsPreExportTextureAsync("exporter",K,A);return T?await T.then((async T=>T?await this._exportTextureInfoAsync(T,A):await this._exportTextureInfoAsync(K,A))):await this._exportTextureInfoAsync(K,A)}async _exportTextureInfoAsync(K,A){let T=this._textureMap.get(K);if(!T){const G=await this._getPixelsFromTextureAsync(K);if(!G)return null;const L=this._exportTextureSampler(K),f=K.mimeType;if(f)switch(f){case"image/jpeg":case"image/png":case"image/webp":A=f;break;default:B.Tools.Warn(`Unsupported media type: ${f}. Exporting texture as PNG.`)}const O=this._internalTextureToImage,C=K.getInternalTexture().uniqueId;O[C]||(O[C]={});let Q=O[C][A];if(void 0===Q){const T=K.getSize();Q=(async()=>{const B=await this._getImageDataAsync(G,T.width,T.height,A);return this._exportImage(K.name,A,B)})(),O[C][A]=Q}T=this._exportTextureInfo(await Q,L,K.coordinatesIndex),this._textureMap.set(K,T),this._exporter._extensionsPostExportTextures("exporter",T,K)}return T}_exportImage(K,A,T){const G=this._exporter._images;let L;if(this._exporter._shouldUseGlb){L={name:K,mimeType:A,bufferView:void 0};const G=this._exporter._bufferManager.createBufferView(new Uint8Array(T));this._exporter._bufferManager.setBufferView(L,G)}else{const f=K.replace(/\.\/|\/|\.\\|\\/g,"_"),O=function(K){switch(K){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(A);let C=f+O;G.some((K=>K.uri===C))&&(C=`${f}_${B.Tools.RandomId()}${O}`),L={name:K,uri:C},this._exporter._imageData[C]={data:T,mimeType:A}}return G.push(L),G.length-1}_exportTextureInfo(K,A,T){const G=this._exporter._textures;let B=G.findIndex((T=>T.sampler==A&&T.source===K));-1===B&&(B=G.length,G.push({source:K,sampler:A}));const L={index:B};return T&&(L.texCoord=T),L}_exportTextureSampler(K){const A=this._getTextureSampler(K),T=this._exporter._samplers,G=T.findIndex((K=>K.minFilter===A.minFilter&&K.magFilter===A.magFilter&&K.wrapS===A.wrapS&&K.wrapT===A.wrapT));return-1!==G?G:(T.push(A),T.length-1)}}var j=T(12779),R=T(12548),v=T(13192),I=T(12706);const o=G.PA.Zero(),W=G.Quaternion.Identity(),i=G.PA.One(),V=new G.PA(-1,1,1);function X(K,A){const{byteOffset:T,byteStride:G,type:B,normalized:L}=K,f=K.getSize(),O=A.reduce(((K,A)=>A.getTotalVertices()>K?A.getTotalVertices():K),-Number.MAX_VALUE);return{byteOffset:T,byteStride:G,componentCount:f,type:B,count:O*f,normalized:L,totalVertices:O,kind:K.getKind()}}function q(K){switch(K){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function y(K){switch(K){case Y.d.PositionKind:case Y.d.NormalKind:case Y.d.TangentKind:case Y.d.ColorKind:case Y.d.MatricesIndicesKind:case Y.d.MatricesIndicesExtraKind:case Y.d.MatricesWeightsKind:case Y.d.MatricesWeightsExtraKind:case Y.d.UVKind:case Y.d.UV2Kind:case Y.d.UV3Kind:case Y.d.UV4Kind:case Y.d.UV5Kind:case Y.d.UV6Kind:return!0}return!1}function w(K){switch(K){case L.e.TriangleFillMode:return 4;case L.e.TriangleStripDrawMode:return 5;case L.e.TriangleFanDrawMode:return 6;case L.e.PointListDrawMode:case L.e.PointFillMode:return 0;case L.e.LineLoopDrawMode:return 2;case L.e.LineListDrawMode:return 1;case L.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${K}`)}function a(K){const A=Math.sqrt(K.x*K.x+K.y*K.y+K.z*K.z);A>0&&(K.x/=A,K.y/=A,K.z/=A)}function M(K){return K.x*=-1,K}function E(K){if(K.x*K.x+K.y*K.y>.5){const A=Math.abs(K.x),T=Math.abs(K.y);if(A>T){const T=Math.sign(K.x);K.x=A,K.y*=-T,K.z*=-T,K.w*=T}else{const A=Math.sign(K.y);K.x*=-A,K.y=T,K.z*=A,K.w*=-A}}else{const A=Math.abs(K.z),T=Math.abs(K.w);if(A>T){const T=Math.sign(K.z);K.x*=-T,K.y*=T,K.z=A,K.w*=-T}else{const A=Math.sign(K.w);K.x*=A,K.y*=-A,K.z*=-A,K.w=T}}return K}function t(K){K.RO(-K.z,K.w,K.x,-K.y)}function KK(K,A){const T=G.PA.FromArrayToRef(A.translation||[0,0,0],0,G.TmpVectors.PA[0]),B=G.Quaternion.FromArrayToRef(A.rotation||[0,0,0,1],0,G.TmpVectors.Quaternion[0]),L=G.Matrix.ComposeToRef(i,B,T,G.TmpVectors.Matrix[0]),f=G.PA.FromArrayToRef(K.translation||[0,0,0],0,G.TmpVectors.PA[2]),O=G.Quaternion.FromArrayToRef(K.rotation||[0,0,0,1],0,G.TmpVectors.Quaternion[1]),C=G.Matrix.ComposeToRef(i,O,f,G.TmpVectors.Matrix[1]);L.multiplyToRef(C,C),C.decompose(void 0,B,T),T.equalsWithEpsilon(o,I.c)?delete A.translation:A.translation=T.kf(),B.equalsWithEpsilon(W,I.c)?delete A.rotation:A.rotation=B.kf(),A.scale&&delete A.scale}function AK(K,A){if(!(A instanceof Z.b))return!1;if(!(1===A.getChildren().length&&0===K.getChildren().length&&K.parent===A))return!1;const T=K.SK(),G=K instanceof v.d&&!T.useRightHandedSystem?V:i;return!!A.vO.equalsWithEpsilon(G,I.c)||(R.d.Warn(`Cannot collapse node ${K.name} into parent node ${A.name} with modified scaling.`),!1)}function TK(K){if(K instanceof Array){const A=new Float32Array(K);return new Uint8Array(A.buffer,A.byteOffset,A.byteLength)}return ArrayBuffer.isView(K)?new Uint8Array(K.buffer,K.byteOffset,K.byteLength):new Uint8Array(K)}function GK(K,A){for(const[T,G]of Object.entries(K)){const B=A[T];(Array.isArray(G)&&Array.isArray(B)&&BK(G,B)||G===B)&&delete K[T]}return K}function BK(K,A){return K.length===A.length&&K.every(((K,T)=>K===A[T]))}const LK=G.Matrix.Compose(new G.PA(-1,1,1),G.Quaternion.Identity(),G.PA.Zero());function fK(K,A){if(!(K instanceof Z.b))return!1;if(A){if(!K.getWorldMatrix().equalsWithEpsilon(G.Matrix.IdentityReadOnly,I.c))return!1}else{if(!K.getWorldMatrix().multiplyToRef(LK,G.TmpVectors.Matrix[0]).equalsWithEpsilon(G.Matrix.IdentityReadOnly,I.c))return!1}return!(K instanceof x.e&&K.Mf)}const OK=new Map([[Int8Array,(K,A,T)=>K.setInt8(A,T)],[Uint8Array,(K,A,T)=>K.setUint8(A,T)],[Uint8ClampedArray,(K,A,T)=>K.setUint8(A,T)],[Int16Array,(K,A,T)=>K.setInt16(A,T,!0)],[Uint16Array,(K,A,T)=>K.setUint16(A,T,!0)],[Int32Array,(K,A,T)=>K.setInt32(A,T,!0)],[Uint32Array,(K,A,T)=>K.setUint32(A,T,!0)],[Float32Array,(K,A,T)=>K.setFloat32(A,T,!0)],[Float64Array,(K,A,T)=>K.setFloat64(A,T,!0)]]);class CK{writeTypedArray(K){this._checkGrowBuffer(K.byteLength);const A=OK.get(K.constructor);for(let T=0;T<K.length;T++)A(this._dataView,this._byteOffset,K[T]),this._byteOffset+=K.BYTES_PER_ELEMENT}constructor(K){this._data=new Uint8Array(K),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(K){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,K),this._byteOffset++}writeInt8(K){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,K),this._byteOffset++}writeInt16(K){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,K,!0),this._byteOffset+=2}writeUInt16(K){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,K,!0),this._byteOffset+=2}writeInt32(K){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,K,!0),this._byteOffset+=4}writeUInt32(K){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,K,!0),this._byteOffset+=4}writeFloat32(K){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,K,!0),this._byteOffset+=4}writeFloat64(K){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,K,!0),this._byteOffset+=8}_checkGrowBuffer(K){const A=this.byteOffset+K;if(A>this._data.byteLength){const K=new Uint8Array(2*A);K.set(this._data),this._data=K,this._dataView=new DataView(this._data.buffer)}}}function QK(K){return K%4===0?4:K%2===0?2:1}class YK{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(K){let A=0;this._bufferViewToData.forEach((K=>{A+=K.byteLength}));const T=new CK(A),G=Array.from(this._bufferViewToData.keys()).sort(((K,A)=>QK(A.byteLength)-QK(K.byteLength)));for(const B of G){B.byteOffset=T.byteOffset,K.push(B);const A=K.length-1,G=this.getPropertiesWithBufferView(B);for(const K of G)K.bufferView=A;T.writeTypedArray(this._bufferViewToData.get(B)),this._bufferViewToData.delete(B)}return T.getOutputData()}createBufferView(K,A){const T={buffer:0,byteOffset:void 0,byteLength:K.byteLength,byteStride:A};return this._bufferViewToData.set(T,K),T}createAccessor(K,A,T,G,B,L,f){this._verifyBufferView(K);const O={bufferView:void 0,componentType:T,count:G,type:A,min:null===L||void 0===L?void 0:L.min,max:null===L||void 0===L?void 0:L.max,normalized:f,byteOffset:B};return this.setBufferView(O,K),this._accessorToBufferView.set(O,K),O}setBufferView(K,A){this._verifyBufferView(A);this.getPropertiesWithBufferView(A).push(K)}removeBufferView(K){const A=this.getPropertiesWithBufferView(K);for(const T of A)void 0!==T.bufferView&&delete T.bufferView;this._bufferViewToData.delete(K),this._bufferViewToProperties.delete(K),this._accessorToBufferView.forEach(((A,T)=>{A===K&&(void 0!==T.byteOffset&&delete T.byteOffset,this._accessorToBufferView.delete(T))}))}getBufferView(K){const A=this._accessorToBufferView.get(K);return this._verifyBufferView(A),A}getPropertiesWithBufferView(K){return this._verifyBufferView(K),this._bufferViewToProperties.set(K,this._bufferViewToProperties.get(K)??[]),this._bufferViewToProperties.get(K)}getData(K){return this._verifyBufferView(K),this._bufferViewToData.get(K)}_verifyBufferView(K){if(void 0===K||!this._bufferViewToData.has(K))throw new Error(`BufferView ${K} not found in BufferManager.`)}}var ZK,xK=T(13154),JK=T(13177),bK=T(13196),PK=T(13069),FK=T(13226),dK=T(13238),NK=T(13147),DK=T(13242);!function(K){K[K.INTANGENT=0]="INTANGENT",K[K.OUTTANGENT=1]="OUTTANGENT"}(ZK||(ZK={}));class mA{static _IsTransformable(K){return K&&(K instanceof Z.b||K instanceof xK.e||K instanceof DK.b)}static _CreateNodeAnimation(K,A,T,G,L){if(this._IsTransformable(K)){const f=[],O=[],C=A.getKeys(),Q=mA._CalculateMinMaxKeyFrames(C),Y=mA._DeduceInterpolation(C,T,G),Z=Y.interpolationType,x=Y.shouldBakeAnimation;if(x?mA._CreateBakedAnimation(K,A,T,Q.min,Q.max,A.framePerSecond,L,f,O,Q,G):"LINEAR"===Z||"STEP"===Z?mA._CreateLinearOrStepAnimation(K,A,T,f,O,G):"CUBICSPLINE"===Z?mA._CreateCubicSplineAnimation(K,A,T,f,O,G):mA._CreateBakedAnimation(K,A,T,Q.min,Q.max,A.framePerSecond,L,f,O,Q,G),f.length&&O.length){return{inputs:f,outputs:O,samplerInterpolation:Z,inputsMin:x?Q.min:B.Tools.FloatRound(Q.min/A.framePerSecond),inputsMax:x?Q.max:B.Tools.FloatRound(Q.max/A.framePerSecond)}}}return null}static _DeduceAnimationInfo(K){let A=null,T="VEC3",G=!1;const L=K.targetProperty.split(".");switch(L[0]){case"vO":A="scale";break;case"position":A="translation";break;case"rotation":T="VEC4",A="rotation";break;case"rotationQuaternion":T="VEC4",G=!0,A="rotation";break;case"influence":T="SCALAR",A="weights";break;default:B.Tools.Error(`Unsupported animatable property ${L[0]}`)}return A?{animationChannelTargetPath:A,dataAccessorType:T,useQuaternion:G}:(B.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(K,A,T,G,B,L,f,O,C,Q,Y){let Z;if(mA._IsTransformable(K)&&K.animations)for(const x of K.animations){if(Y&&!Y(x))continue;const B=mA._DeduceAnimationInfo(x);B&&(Z={name:x.name,samplers:[],channels:[]},mA._AddAnimation(`${x.name}`,x.hasRunningRuntimeAnimations?A:Z,K,x,B.dataAccessorType,B.animationChannelTargetPath,G,L,f,O,B.useQuaternion,C,Q),Z.samplers.length&&Z.channels.length&&T.push(Z))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(K,A,T,G,B,L,f,O,C,Q,Y){let Z;if(K instanceof NK.e){const B=K.morphTargetManager;if(B)for(let x=0;x<B.numTargets;++x){const J=B.getTarget(x);for(const b of J.animations){if(Y&&!Y(b))continue;const J=new FK.b(`${b.name}`,"influence",b.framePerSecond,b.dataType,b.loopMode,b.enableBlending),P=[],F=b.getKeys();for(let K=0;K<F.length;++K){const A=F[K];for(let K=0;K<B.numTargets;++K)K==x?P.push(A):P.push({frame:A.frame,value:0})}J.setKeys(P);const d=mA._DeduceAnimationInfo(J);d&&(Z={name:J.name,samplers:[],channels:[]},mA._AddAnimation(b.name,b.hasRunningRuntimeAnimations?A:Z,K,J,d.dataAccessorType,d.animationChannelTargetPath,G,L,f,O,d.useQuaternion,C,Q,B.numTargets),Z.samplers.length&&Z.channels.length&&T.push(Z))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(K,A,T,G,B,L,f,O,C){let Q;if(K.animationGroups){const Z=K.animationGroups;for(const x of Z){const Z=new Map,J=new Map,b=new Set,P=x.to-x.from;Q={name:x.name,channels:[],samplers:[]};for(let A=0;A<x.targetedAnimations.length;++A){const P=x.targetedAnimations[A],F=P.target,d=P.animation;if(C&&!C(d))continue;const N=O.has(F);if(this._IsTransformable(F)||1===F.length&&this._IsTransformable(F[0])){const K=mA._DeduceAnimationInfo(P.animation);if(K){const A=this._IsTransformable(F)?F:this._IsTransformable(F[0])?F[0]:null;A&&mA._AddAnimation(`${d.name}`,Q,A,d,K.dataAccessorType,K.animationChannelTargetPath,T,G,B,L,K.useQuaternion,f,N)}}else if(F instanceof dK.d||1===F.length&&F[0]instanceof dK.d){if(mA._DeduceAnimationInfo(P.animation)){const A=F instanceof dK.d?F:F[0];if(A){const T=K.morphTargetManagers.find((K=>{for(let T=0;T<K.numTargets;++T)if(K.getTarget(T)===A)return!0;return!1}));if(T){const G=K.meshes.find((K=>K.morphTargetManager===T));var Y;if(G)Z.has(G)||Z.set(G,new Map),null===(Y=Z.get(G))||void 0===Y||Y.set(A,d),b.add(G),J.set(G,d)}}}}}b.forEach((K=>{const A=K.morphTargetManager;let O=null;const C=[],Y=J.get(K).getKeys(),b=Y.length;for(let T=0;T<b;++T)for(let G=0;G<A.numTargets;++G){const B=A.getTarget(G),L=Z.get(K);if(L){const A=L.get(B);A?(O||(O=new FK.b(`${x.name}_${K.name}_MorphWeightAnimation`,"influence",A.framePerSecond,FK.b.ANIMATIONTYPE_FLOAT,A.loopMode,A.enableBlending)),C.push(A.getKeys()[T])):C.push({frame:x.from+P/b*T,value:B.influence,inTangent:Y[0].inTangent?0:void 0,outTangent:Y[0].outTangent?0:void 0})}}O.setKeys(C);const F=mA._DeduceAnimationInfo(O);F&&mA._AddAnimation(`${x.name}_${K.name}_MorphWeightAnimation`,Q,K,O,F.dataAccessorType,F.animationChannelTargetPath,T,G,B,L,F.useQuaternion,f,!1,null===A||void 0===A?void 0:A.numTargets)})),Q.channels.length&&Q.samplers.length&&A.push(Q)}}}static _AddAnimation(K,A,T,B,L,f,O,C,Q,Y,Z,x,J,b){const P=mA._CreateNodeAnimation(T,B,f,Z,x);let F,d,N,D,mK,U;if(P){if(b){let K=0,A=0;const T=[];for(;P.inputs.length>0;)A=P.inputs.shift(),K%b==0&&T.push(A),K++;P.inputs=T}const K=O.get(T),B=new Float32Array(P.inputs);F=C.createBufferView(B),d=C.createAccessor(F,"SCALAR",5126,P.inputs.length,void 0,{min:[P.inputsMin],max:[P.inputsMax]}),Y.push(d),N=Y.length-1;const Q=new G.Quaternion,Z=new G.PA,x=new G.PA,z=T instanceof xK.e,g=q(L),S=new Float32Array(P.outputs.length*g);P.outputs.forEach((function(K,A){let T=K;switch(f){case"translation":J&&(G.PA.FromArrayToRef(K,0,x),M(x),x.toArray(T));break;case"rotation":4===K.length?G.Quaternion.FromArrayToRef(K,0,Q):(T=new Array(4),G.PA.FromArrayToRef(K,0,Z),G.Quaternion.FromEulerVectorToRef(Z,Q)),J&&(E(Q),z&&t(Q)),Q.toArray(T)}S.set(T,A*g)})),F=C.createBufferView(S),d=C.createAccessor(F,L,5126,P.outputs.length),Y.push(d),D=Y.length-1,mK={interpolation:P.samplerInterpolation,input:N,output:D},A.samplers.push(mK),U={sampler:A.samplers.length-1,target:{node:K,path:f}},A.channels.push(U)}}static _CreateBakedAnimation(K,A,T,L,f,O,C,Q,Y,Z,x){let J;const b=G.Quaternion.Identity();let P,F=null,d=null,N=null,D=null,mK=null,U=null;Z.min=B.Tools.FloatRound(L/O);const z=A.getKeys();for(let G=0,g=z.length;G<g;++G){if(U=null,N=z[G],G+1<g)if(D=z[G+1],N.value.equals&&N.value.equals(D.value)||N.value===D.value){if(0!==G)continue;U=N.frame}else U=D.frame;else{if(mK=z[G-1],N.value.equals&&N.value.equals(mK.value)||N.value===mK.value)continue;U=f}if(U)for(let G=N.frame;G<=U;G+=C){if(P=B.Tools.FloatRound(G/O),P===F)continue;F=P,d=P;const L={key:0,repeatCount:0,loopMode:A.loopMode};J=A._interpolate(G,L),mA._SetInterpolatedValue(K,J,P,A,T,b,Q,Y,x)}}d&&(Z.max=d)}static _ConvertFactorToVector3OrQuaternion(K,A,T,L,f){const O=mA._GetBasePositionRotationOrScale(A,L,f),C=T.targetProperty.split("."),Q=C?C[1]:"",Y=f?G.Quaternion.mT(O).normalize():G.PA.mT(O);switch(Q){case"x":case"y":case"z":Y[Q]=K;break;case"w":Y.w=K;break;default:B.Tools.Error(`glTFAnimation: Unsupported component name "${Q}"!`)}return Y}static _SetInterpolatedValue(K,A,T,B,L,f,O,C,Q){let Y;O.push(T),"weights"!==L?(B.dataType===FK.b.ANIMATIONTYPE_FLOAT&&(A=this._ConvertFactorToVector3OrQuaternion(A,K,B,L,Q)),"rotation"===L?(Q?f=A:(Y=A,G.Quaternion.RotationYawPitchRollToRef(Y.y,Y.x,Y.z,f)),C.push(f.kf())):(Y=A,C.push(Y.kf()))):C.push([A])}static _CreateLinearOrStepAnimation(K,A,T,G,B,L){for(const f of A.getKeys())G.push(f.frame/A.framePerSecond),mA._AddKeyframeValue(f,A,B,T,K,L)}static _CreateCubicSplineAnimation(K,A,T,G,B,L){A.getKeys().forEach((function(f){G.push(f.frame/A.framePerSecond),mA._AddSplineTangent(ZK.INTANGENT,B,T,"CUBICSPLINE",f,L),mA._AddKeyframeValue(f,A,B,T,K,L),mA._AddSplineTangent(ZK.OUTTANGENT,B,T,"CUBICSPLINE",f,L)}))}static _GetBasePositionRotationOrScale(K,A,T){let B;if("rotation"===A)if(T){B=(K.rotationQuaternion??G.Quaternion.Identity()).kf()}else{B=(K.rotation??G.PA.Zero()).kf()}else if("translation"===A){B=(K.position??G.PA.Zero()).kf()}else{B=(K.vO??G.PA.One()).kf()}return B}static _AddKeyframeValue(K,A,T,L,f,O){let C;const Q=A.dataType;if(Q===FK.b.ANIMATIONTYPE_VECTOR3){let A=K.value.kf();if("rotation"===L){const K=G.PA.mT(A);A=G.Quaternion.RotationYawPitchRoll(K.y,K.x,K.z).kf()}T.push(A)}else if(Q===FK.b.ANIMATIONTYPE_FLOAT){if("weights"===L)T.push([K.value]);else if(C=this._ConvertFactorToVector3OrQuaternion(K.value,f,A,L,O),C){if("rotation"===L){const K=O?C:G.Quaternion.RotationYawPitchRoll(C.y,C.x,C.z).normalize();T.push(K.kf())}T.push(C.kf())}}else Q===FK.b.ANIMATIONTYPE_QUATERNION?T.push(K.value.normalize().kf()):B.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(K,A,T){let G,B,L=!1;if("rotation"===A&&!T)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let f=0,O=K.length;f<O;++f)if(B=K[f],B.inTangent||B.outTangent)if(G){if("CUBICSPLINE"!==G){G="LINEAR",L=!0;break}}else G="CUBICSPLINE";else if(G){if("CUBICSPLINE"===G||B.interpolation&&1===B.interpolation&&"STEP"!==G){G="LINEAR",L=!0;break}}else G=B.interpolation&&1===B.interpolation?"STEP":"LINEAR";return G||(G="LINEAR"),{interpolationType:G,shouldBakeAnimation:L}}static _AddSplineTangent(K,A,T,B,L,f){let O;const C=K===ZK.INTANGENT?L.inTangent:L.outTangent;if("CUBICSPLINE"===B){if("rotation"===T)if(C)if(f)O=C.kf();else{const K=C;O=G.Quaternion.RotationYawPitchRoll(K.y,K.x,K.z).kf()}else O=[0,0,0,0];else O="weights"===T?C?[C]:[0]:C?C.kf():[0,0,0];A.push(O)}}static _CalculateMinMaxKeyFrames(K){let A=1/0,T=-1/0;return K.forEach((function(K){A=Math.min(A,K.frame),T=Math.max(T,K.frame)})),{min:A,max:T}}}function UK(K,A,T,L,f,O){const C={attributes:{},influence:K.influence,name:K.name},Q=A.Mf;if(!Q)return B.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),C;const Z=O?-1:1,x=G.PA.Zero();let J=0,b=0;if(K.hasPositions){const L=K.getPositions(),O=Q.getVerticesData(Y.d.PositionKind);if(O){const K=new Float32Array(O.length),A=[1/0,1/0,1/0],B=[-1/0,-1/0,-1/0];b=O.length/3,J=0;for(let T=J;T<b;++T){const f=G.PA.mT(O,3*T);G.PA.mT(L,3*T).subtractToRef(f,x),x.x*=Z,A[0]=Math.min(A[0],x.x),B[0]=Math.max(B[0],x.x),A[1]=Math.min(A[1],x.y),B[1]=Math.max(B[1],x.y),A[2]=Math.min(A[2],x.z),B[2]=Math.max(B[2],x.z),K[3*T]=x.x,K[3*T+1]=x.y,K[3*T+2]=x.z}const Q=T.createBufferView(K,12),Y=T.createAccessor(Q,"VEC3",5126,L.length/3,0,{min:A,max:B});f.push(Y),C.attributes.POSITION=f.length-1}else B.Tools.Warn(`Morph target positions for mesh ${A.name} were not exported. Mesh does not have position vertex data`)}if(K.hasNormals){const L=K.getNormals(),O=Q.getVerticesData(Y.d.NormalKind);if(O){const K=new Float32Array(O.length);b=O.length/3,J=0;for(let T=J;T<b;++T){const A=G.PA.mT(O,3*T).normalize();G.PA.mT(L,3*T).normalize().subtractToRef(A,x),K[3*T]=x.x*Z,K[3*T+1]=x.y,K[3*T+2]=x.z}const A=T.createBufferView(K,12),B=T.createAccessor(A,"VEC3",5126,L.length/3,0);f.push(B),C.attributes.NORMAL=f.length-1}else B.Tools.Warn(`Morph target normals for mesh ${A.name} were not exported. Mesh does not have normals vertex data`)}if(K.hasTangents){const L=K.getTangents(),O=Q.getVerticesData(Y.d.TangentKind);if(O){b=O.length/4;const K=new Float32Array(3*b);J=0;for(let T=J;T<b;++T){const A=G.PA.mT(O,4*T);a(A);const B=G.PA.mT(L,3*T);a(B),B.subtractToRef(A,x),K[3*T]=x.x*Z,K[3*T+1]=x.y,K[3*T+2]=x.z}const A=T.createBufferView(K,12),B=T.createAccessor(A,"VEC3",5126,b,0);f.push(B),C.attributes.TANGENT=f.length-1}else B.Tools.Warn(`Morph target tangents for mesh ${A.name} were not exported. Mesh does not have tangents vertex data`)}if(K.hasColors){const L=K.getColors(),O=Q.getVerticesData(Y.d.ColorKind),Z=Q.getVertexBuffer(Y.d.ColorKind);if(O&&Z){const K=Z.getSize();b=O.length/K;const A=new Float32Array(b*K);J=0;for(let T=J;T<b;++T)if(3===K){const B=G.PA.mT(O,T*K);G.PA.mT(L,T*K).subtractToRef(B,x),A[3*T]=x.x,A[3*T+1]=x.y,A[3*T+2]=x.z}else if(4===K){const B=new G.Vector4,f=G.Vector4.mT(O,T*K);G.Vector4.mT(L,T*K).subtractToRef(f,B),A[4*T]=B.x,A[4*T+1]=B.y,A[4*T+2]=B.z,A[4*T+3]=B.w}else B.Tools.Warn(`Unsupported number of components for color attribute: ${K}`);const Q=T.createBufferView(A,4*K),Y=T.createAccessor(Q,3===K?"VEC3":"VEC4",5126,b,0);f.push(Y),C.attributes.COLOR_0=f.length-1}else B.Tools.Warn(`Morph target colors for mesh ${A.name} were not exported. Mesh does not have colors vertex data`)}return C}var zK=T(13247),gK=T(13101),SK=T(13081),lK=T(12651);class uK{}uK.DEFAULT_COLOR=F.DA.White(),uK.DEFAULT_WIDTH_ATTENUATED=1,uK.DEFAULT_WIDTH=.1;var cK=T(12907),nK=T(13253);class HK{static ConvertPoints(K,A){if(K.length&&Array.isArray(K)&&"number"===typeof K[0])return[K];if(K.length&&Array.isArray(K[0])&&"number"===typeof K[0][0])return K;if(K.length&&!Array.isArray(K[0])&&K[0]instanceof G.PA){const A=[];for(let T=0;T<K.length;T++){const G=K[T];A.push(G.x,G.y,G.z)}return[A]}if(K.length>0&&Array.isArray(K[0])&&K[0].length>0&&K[0][0]instanceof G.PA){const A=[],T=K;for(const K of T)A.push(K.flatMap((K=>[K.x,K.y,K.z])));return A}if(K instanceof Float32Array){if(null!==A&&void 0!==A&&A.floatArrayStride){const T=[],G=3*A.floatArrayStride;for(let A=0;A<K.length;A+=G){const B=new Array(G);for(let T=0;T<G;T++)B[T]=K[A+T];T.push(B)}return T}return[Array.from(K)]}if(K.length&&K[0]instanceof Float32Array){const A=[];for(const T of K)A.push(Array.from(T));return A}return[]}static OmitZeroLengthPredicate(K,A,T){const G=[];return A.FA(K).lengthSquared()>0&&G.push([K,A]),T.FA(A).lengthSquared()>0&&G.push([A,T]),K.FA(T).lengthSquared()>0&&G.push([T,K]),0===G.length?null:G}static OmitDuplicatesPredicate(K,A,T,G){const B=[];return HK._SearchInPoints(K,A,G)||B.push([K,A]),HK._SearchInPoints(A,T,G)||B.push([A,T]),HK._SearchInPoints(T,K,G)||B.push([T,K]),0===B.length?null:B}static _SearchInPoints(K,A,T){for(const f of T)for(let T=0;T<f.length;T++){var G,B,L;if(null!==(G=f[T])&&void 0!==G&&G.equals(K))if(null!==(B=f[T+1])&&void 0!==B&&B.equals(A)||null!==(L=f[T-1])&&void 0!==L&&L.equals(A))return!0}return!1}static MeshesToLines(K,A){const T=[];for(let B=0;B<K.length;B++){const L=K[B],f=L.getVerticesData(Y.d.PositionKind),O=L.Ef();if(f&&O)for(let K=0,C=0;K<O.length;K++){const Q=3*O[C++],Y=3*O[C++],Z=3*O[C++],x=new G.PA(f[Q],f[Q+1],f[Q+2]),J=new G.PA(f[Y],f[Y+1],f[Y+2]),b=new G.PA(f[Z],f[Z+1],f[Z+2]);if(A){const G=A(x,J,b,T,K,Q,L,B,f,O);if(G)for(const K of G)T.push(K)}else T.push([x,J],[J,b],[b,x])}}return T}static ToVector3Array(K){if(Array.isArray(K[0])){const A=[],T=K;for(const K of T){const T=[];for(let A=0;A<K.length;A+=3)T.push(new G.PA(K[A],K[A+1],K[A+2]));A.push(T)}return A}const A=K,T=[];for(let B=0;B<A.length;B+=3)T.push(new G.PA(A[B],A[B+1],A[B+2]));return T}static ToNumberArray(K){return K.flatMap((K=>[K.x,K.y,K.z]))}static GetPointsCountInfo(K){const A=new Array(K.length);let T=0;for(let G=K.length;G--;)A[G]=K[G].length/3,T+=A[G];return{total:T,counts:A}}static GetLineLength(K){if(0===K.length)return 0;let A;A="number"===typeof K[0]?HK.ToVector3Array(K):K;const T=G.TmpVectors.PA[0];let B=0;for(let G=0;G<A.length-1;G++){const K=A[G];B+=A[G+1].subtractToRef(K,T).length()}return B}static GetLineLengthArray(K){const A=new Float32Array(K.length/3);let T=0;for(let G=0,B=K.length/3-1;G<B;G++){let B=K[3*G+0],L=K[3*G+1],f=K[3*G+2];B-=K[3*G+3],L-=K[3*G+4],f-=K[3*G+5];T+=Math.sqrt(B*B+L*L+f*f),A[G+1]=T}return A}static SegmentizeSegmentByCount(K,A,T){const B=[],L=A.FA(K),f=G.TmpVectors.PA[0];f.IO(T);const O=G.TmpVectors.PA[1];L.divideToRef(f,O);let C=K.clone();B.push(C);for(let G=0;G<T;G++)C=C.clone(),B.push(C.addInPlace(O));return B}static SegmentizeLineBySegmentLength(K,A){const T=K[0]instanceof G.PA?HK.GetLineSegments(K):"number"===typeof K[0]?HK.GetLineSegments(HK.ToVector3Array(K)):K,B=[];for(const G of T)if(G.length>A){const K=HK.SegmentizeSegmentByCount(G.point1,G.point2,Math.ceil(G.length/A));for(const A of K)B.push(A)}else B.push(G.point1),B.push(G.point2);return B}static SegmentizeLineBySegmentCount(K,A){const T="number"===typeof K[0]?HK.ToVector3Array(K):K,G=HK.GetLineLength(T)/A;return HK.SegmentizeLineBySegmentLength(T,G)}static GetLineSegments(K){const A=[];for(let T=0;T<K.length-1;T++){const G=K[T],B=K[T+1],L=B.FA(G).length();A.push({point1:G,point2:B,length:L})}return A}static GetMinMaxSegmentLength(K){const A=HK.GetLineSegments(K).sort((K=>K.length));return{min:A[0].length,max:A[A.length-1].length}}static GetPositionOnLineByVisibility(K,A,T){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const L=A*T;let f=0,O=0;const C=K.length;for(let G=0;G<C;G++){if(L<=f+K[G].length){O=G;break}f+=K[G].length}const Q=(L-f)/K[O].length;return K[O].point2.subtractToRef(K[O].point1,G.TmpVectors.PA[0]),G.TmpVectors.PA[1]=G.TmpVectors.PA[0].multiplyByFloats(Q,Q,Q),B||G.TmpVectors.PA[1].addInPlace(K[O].point1),G.TmpVectors.PA[1].clone()}static GetCircleLinePoints(K,A){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:K,L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/A;const f=[];for(let O=0;O<=A;O++)f.push(new G.PA(Math.cos(O*L)*K,Math.sin(O*L)*B,T));return f}static GetBezierLinePoints(K,A,T,G){return cK.e.CreateQuadraticBezier(K,A,T,G).getPoints().flatMap((K=>[K.x,K.y,K.z]))}static GetArrowCap(K,A,T,G,B){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,f=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[K.clone(),K.add(A.multiplyByFloats(T,T,T))],widths:[G,B,L,f]}}static GetPointsFromText(K,A,T,G){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const f=[],O=(0,nK.b)(K,A,T,G);for(const C of O){for(const K of C.paths){const A=[],T=K.getPoints();for(const K of T)A.push(K.x,K.y,B);f.push(A)}if(L)for(const K of C.holes){const A=[],T=K.getPoints();for(const K of T)A.push(K.x,K.y,B);f.push(A)}}return f}static Color3toRGBAUint8(K){const A=new Uint8Array(4*K.length);for(let T=0,G=0;T<K.length;T++)A[G++]=255*K[T].r,A[G++]=255*K[T].g,A[G++]=255*K[T].b,A[G++]=255;return A}static CreateColorsTexture(K,A,T,G){const B=G.getEngine().getCaps().maxTextureSize??1,L=A.length>B?B:A.length,f=Math.ceil(A.length/B);f>1&&(A=[...A,...Array(L*f-A.length).fill(A[0])]);const O=HK.Color3toRGBAUint8(A),C=new z.b(O,L,f,b.c.TEXTUREFORMAT_RGBA,G,!1,!0,T);return C.name=K,C}static PrepareEmptyColorsTexture(K){if(!uK.EmptyColorsTexture){const A=new Uint8Array(4);uK.EmptyColorsTexture=new z.b(A,1,1,b.c.TEXTUREFORMAT_RGBA,K,!1,!1,z.b.NEAREST_NEAREST),uK.EmptyColorsTexture.name="grlEmptyColorsTexture"}return uK.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var K;null===(K=uK.EmptyColorsTexture)||void 0===K||K.dispose(),uK.EmptyColorsTexture=null}static BooleanToNumber(K){return K?1:0}}class eK extends SK.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class pK extends gK.b{isCompatible(K){return!0}constructor(K,A,T){var B;T=T||{color:uK.DEFAULT_COLOR};const L=new eK;L.GREASED_LINE_HAS_COLOR=!!T.color&&!T.useColors,L.GREASED_LINE_SIZE_ATTENUATION=T.sizeAttenuation??!1,L.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===T.colorDistributionType,L.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(A??K.SK()).useRightHandedSystem,L.GREASED_LINE_CAMERA_FACING=T.cameraFacing??!0,super(K,pK.GREASED_LINE_MATERIAL_NAME,200,L,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(B=T)||void 0===B?void 0:B.forceGLSL)||pK.ForceGLSL,this._scene=A??K.SK(),this._engine=this._scene.getEngine(),this._cameraFacing=T.cameraFacing??!0,this.visibility=T.visibility??1,this.useDash=T.useDash??!1,this.dashRatio=T.dashRatio??.5,this.dashOffset=T.dashOffset??0,this.width=T.width?T.width:T.sizeAttenuation?uK.DEFAULT_WIDTH_ATTENUATED:uK.DEFAULT_WIDTH,this._sizeAttenuation=T.sizeAttenuation??!1,this.colorMode=T.colorMode??0,this._color=T.color??null,this.useColors=T.useColors??!1,this._colorsDistributionType=T.colorDistributionType??0,this.colorsSampling=T.colorsSampling??z.b.NEAREST_NEAREST,this._colors=T.nK??null,this.dashCount=T.dashCount??1,this.resolution=T.resolution??new G.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),T.colorsTexture?this.colorsTexture=T.colorsTexture:this._colors?this.colorsTexture=HK.CreateColorsTexture(`${K.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??uK.DEFAULT_COLOR,HK.PrepareEmptyColorsTexture(this._scene)),this._engine.Ff.add((()=>{HK.DisposeEmptyColorsTexture()}))}getAttributes(K){K.push("grl_offsets"),K.push("grl_widths"),K.push("grl_colorPointers"),K.push("grl_counters"),this._cameraFacing?(K.push("grl_previousAndSide"),K.push("grl_nextAndCounters")):K.push("grl_slopes")}getSamplers(K){K.push("grl_colors")}getActiveTextures(K){this.colorsTexture&&K.push(this.colorsTexture)}getUniforms(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const A=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&A.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===K&&A.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:A,vertex:this._cameraFacing&&this._isGLSL(K)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(K)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(K){if(this._cameraFacing){K.Xf("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||K.Xf("viewProjection",this._scene.getTransformMatrix());const A=G.TmpVectors.Vector4[0];A.x=this._aspect,A.y=this._resolution.x,A.z=this._resolution.y,A.w=this.width,K.updateVector4("grl_aspect_resolution_lineWidth",A)}const A=G.TmpVectors.Vector4[0];A.x=HK.BooleanToNumber(this.useDash),A.y=this._dashArray,A.z=this.dashOffset,A.w=this.dashRatio,K.updateVector4("grl_dashOptions",A);const T=G.TmpVectors.Vector4[1];T.x=this.colorMode,T.y=this.visibility,T.z=this.colorsTexture?this.colorsTexture.getSize().width:0,T.w=HK.BooleanToNumber(this.useColors),K.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",T),this._color&&K.updateColor3("grl_singleColor",this._color);const B=this.colorsTexture??uK.EmptyColorsTexture;K.setTexture("grl_colors",B),K.updateFloat2("grl_textureSize",(null===B||void 0===B?void 0:B.getSize().width)??1,(null===B||void 0===B?void 0:B.getSize().height)??1)}prepareDefines(K,A,T){K.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,K.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,K.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,K.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=A.useRightHandedSystem,K.GREASED_LINE_CAMERA_FACING=this._cameraFacing,K.GREASED_LINE_USE_OFFSETS=!!T.offsets}getClassName(){return pK.GREASED_LINE_MATERIAL_NAME}getCustomCode(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(A)?function(K,A){if("vertex"===K){const K={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return A&&(K["!gl_Position\\=viewProjection\\*worldPos;"]="//"),K}return"fragment"===K?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(K,this._cameraFacing):function(K,A){if("vertex"===K){const K={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return A&&(K["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),K}return"fragment"===K?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(K,this._cameraFacing)}dispose(){var K;null===(K=this.colorsTexture)||void 0===K||K.dispose(),super.dispose()}get nK(){return this._colors}set nK(K){this.setColors(K)}setColors(K){var A;let T=arguments.length>1&&void 0!==arguments[1]&&arguments[1],G=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=(null===(A=this._colors)||void 0===A?void 0:A.length)??0;var L;if(this._colors=K,null!==K&&0!==K.length){if(!T||G)if(this.colorsTexture&&B===K.length&&!G){const A=HK.Color3toRGBAUint8(K);this.colorsTexture.update(A)}else{var f;null===(f=this.colorsTexture)||void 0===f||f.dispose(),this.colorsTexture=HK.CreateColorsTexture(`${this._material.name}-colors-texture`,K,this.colorsSampling,this._scene)}}else null===(L=this.colorsTexture)||void 0===L||L.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(K){this._dashCount=K,this._dashArray=1/K}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(K){this._sizeAttenuation=K,this.markAllDefinesAsDirty()}get color(){return this._color}set color(K){this.setColor(K)}setColor(K){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==K||null!==this._color&&null===K?(this._color=K,A||this.markAllDefinesAsDirty()):this._color=K}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(K){this._colorsDistributionType=K,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(K){this._aspect=K.x/K.y,this._resolution=K}serialize(){const K=super.serialize(),A={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(A.nK=this._colors),this._color&&(A.color=this._color),K.greasedLineMaterialOptions=A,K}parse(K,A,T){var G;super.parse(K,A,T);const B=K.greasedLineMaterialOptions;null===(G=this.colorsTexture)||void 0===G||G.dispose(),B.color&&this.setColor(B.color,!0),B.colorDistributionType&&(this.colorsDistributionType=B.colorDistributionType),B.nK&&(this.nK=B.nK),B.colorsSampling&&(this.colorsSampling=B.colorsSampling),B.colorMode&&(this.colorMode=B.colorMode),B.useColors&&(this.useColors=B.useColors),B.visibility&&(this.visibility=B.visibility),B.useDash&&(this.useDash=B.useDash),B.dashCount&&(this.dashCount=B.dashCount),B.dashRatio&&(this.dashRatio=B.dashRatio),B.dashOffset&&(this.dashOffset=B.dashOffset),B.width&&(this.width=B.width),B.sizeAttenuation&&(this.sizeAttenuation=B.sizeAttenuation),B.resolution&&(this.resolution=B.resolution),this.nK?this.colorsTexture=HK.CreateColorsTexture(`${this._material.name}-colors-texture`,this.nK,this.colorsSampling,A):HK.PrepareEmptyColorsTexture(A),this.markAllDefinesAsDirty()}copyTo(K){var A;const T=K;null===(A=T.colorsTexture)||void 0===A||A.dispose(),this._colors&&(T.colorsTexture=HK.CreateColorsTexture(`${T._material.name}-colors-texture`,this._colors,T.colorsSampling,this._scene)),T.setColor(this.color,!0),T.colorsDistributionType=this.colorsDistributionType,T.colorsSampling=this.colorsSampling,T.colorMode=this.colorMode,T.useColors=this.useColors,T.visibility=this.visibility,T.useDash=this.useDash,T.dashCount=this.dashCount,T.dashRatio=this.dashRatio,T.dashOffset=this.dashOffset,T.width=this.width,T.sizeAttenuation=this.sizeAttenuation,T.resolution=this.resolution,T.markAllDefinesAsDirty()}_isGLSL(K){return 0===K||this._forceGLSL}}pK.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",pK.ForceGLSL=!1,(0,lK.c)(`BABYLON.${pK.GREASED_LINE_MATERIAL_NAME}`,pK);var rK=T(13133),hK=T(12550),kK=T(12924),sK=T(12639);class jK extends kK.ShaderMaterial{constructor(K,A,B){const L=A.getEngine(),f=L.isWebGPU&&!(B.forceGLSL||jK.ForceGLSL),O=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];A.useRightHandedSystem&&O.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const C=["position","grl_widths","grl_offsets","grl_colorPointers"];B.cameraFacing?(O.push("GREASED_LINE_CAMERA_FACING"),C.push("grl_previousAndSide","grl_nextAndCounters")):(C.push("grl_slopes"),C.push("grl_counters"));const Q=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(f||Q.push("world","viewProjection","view","projection"),super(K,A,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:f?["Scene","Mesh"]:void 0,attributes:C,uniforms:Q,samplers:f?[]:["grlColors"],defines:O,extraInitializationsAsync:async()=>{f?await Promise.all([T.e(66).then(T.bind(T,15796)),T.e(75).then(T.bind(T,15803))]):await Promise.all([T.e(69).then(T.bind(T,15807)),T.e(76).then(T.bind(T,15815))])},shaderLanguage:f?1:0}),this._color=F.DA.White(),this._colorsDistributionType=0,this._colorsTexture=null,B=B||{color:uK.DEFAULT_COLOR},this.visibility=B.visibility??1,this.useDash=B.useDash??!1,this.dashRatio=B.dashRatio??.5,this.dashOffset=B.dashOffset??0,this.dashCount=B.dashCount??1,this.width=B.width?B.width:B.sizeAttenuation&&B.cameraFacing?uK.DEFAULT_WIDTH_ATTENUATED:uK.DEFAULT_WIDTH,this.sizeAttenuation=B.sizeAttenuation??!1,this.color=B.color??F.DA.White(),this.useColors=B.useColors??!1,this.colorsDistributionType=B.colorDistributionType??0,this.colorsSampling=B.colorsSampling??z.b.NEAREST_NEAREST,this.colorMode=B.colorMode??0,this._colors=B.nK??null,this._cameraFacing=B.cameraFacing??!0,this.resolution=B.resolution??new G.Vector2(L.getRenderWidth(),L.getRenderHeight()),B.colorsTexture?this.colorsTexture=B.colorsTexture:this._colors?this.colorsTexture=HK.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,A):(this._color=this._color??uK.DEFAULT_COLOR,this.colorsTexture=HK.PrepareEmptyColorsTexture(A)),f){const K=new sK.c;K.setParameters(),K.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",K)}L.Ff.add((()=>{HK.DisposeEmptyColorsTexture()}))}dispose(){var K;null===(K=this._colorsTexture)||void 0===K||K.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new G.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get nK(){return this._colors}set nK(K){this.setColors(K)}setColors(K){var A;let T=arguments.length>1&&void 0!==arguments[1]&&arguments[1],G=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=(null===(A=this._colors)||void 0===A?void 0:A.length)??0;var L;if(this._colors=K,null!==K&&0!==K.length){if(!T||G)if(this._colorsTexture&&B===K.length&&!G){const A=HK.Color3toRGBAUint8(K);this._colorsTexture.update(A)}else{var f;null===(f=this._colorsTexture)||void 0===f||f.dispose(),this.colorsTexture=HK.CreateColorsTexture(`${this.name}-colors-texture`,K,this.colorsSampling,this.SK())}}else null===(L=this._colorsTexture)||void 0===L||L.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(K){this._colorsTexture=K,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(K){this._width=K,this.setFloat("grlWidth",K)}get useColors(){return this._useColors}set useColors(K){this._useColors=K,this.setFloat("grlUseColors",HK.BooleanToNumber(K))}get colorsSampling(){return this._colorsSampling}set colorsSampling(K){this._colorsSampling=K}get visibility(){return this._visibility}set visibility(K){this._visibility=K,this.setFloat("grlVisibility",K)}get useDash(){return this._useDash}set useDash(K){this._useDash=K,this.setFloat("grlUseDash",HK.BooleanToNumber(K))}get dashOffset(){return this._dashOffset}set dashOffset(K){this._dashOffset=K,this.setFloat("grlDashOffset",K)}get dashRatio(){return this._dashRatio}set dashRatio(K){this._dashRatio=K,this.setFloat("grlDashRatio",K)}get dashCount(){return this._dashCount}set dashCount(K){this._dashCount=K,this._dashArray=1/K,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(K){this._sizeAttenuation=K,this.setFloat("grlSizeAttenuation",HK.BooleanToNumber(K))}get color(){return this._color}set color(K){this.setColor(K)}setColor(K){K=K??uK.DEFAULT_COLOR,this._color=K,this.setColor3("grlColor",K)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(K){this._colorsDistributionType=K,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(K){this._colorMode=K,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(K){this._resolution=K,this.setVector2("grlResolution",K),this.setFloat("grlAspect",K.x/K.y)}serialize(){const K=super.serialize(),A={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(A.nK=this._colors),K.greasedLineMaterialOptions=A,K}parse(K,A,T){var G;const B=K.greasedLineMaterialOptions;null===(G=this._colorsTexture)||void 0===G||G.dispose(),B.color&&(this.color=B.color),B.colorDistributionType&&(this.colorsDistributionType=B.colorDistributionType),B.colorsSampling&&(this.colorsSampling=B.colorsSampling),B.colorMode&&(this.colorMode=B.colorMode),B.useColors&&(this.useColors=B.useColors),B.visibility&&(this.visibility=B.visibility),B.useDash&&(this.useDash=B.useDash),B.dashCount&&(this.dashCount=B.dashCount),B.dashRatio&&(this.dashRatio=B.dashRatio),B.dashOffset&&(this.dashOffset=B.dashOffset),B.width&&(this.width=B.width),B.sizeAttenuation&&(this.sizeAttenuation=B.sizeAttenuation),B.resolution&&(this.resolution=B.resolution),B.nK?this.colorsTexture=HK.CreateColorsTexture(`${this.name}-colors-texture`,B.nK,this.colorsSampling,this.SK()):this.colorsTexture=HK.PrepareEmptyColorsTexture(A),this._cameraFacing=B.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var RK,vK,IK;jK.ForceGLSL=!1,function(K){K[K.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",K[K.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(RK||(RK={})),function(K){K[K.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",K[K.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",K[K.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(vK||(vK={})),function(K){K[K.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",K[K.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",K[K.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",K[K.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",K[K.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(IK||(IK={}));class oK extends NK.e{constructor(K,A,T){super(K,A,null,null,!1,!1),this.name=K,this._options=T,this._lazy=!1,this._updatable=!1,this._engine=A.getEngine(),this._lazy=T.lazy??!1,this._updatable=T.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=T.colorPointers??[],this._widths=T.widths??new Array(T.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(K){let A=0;for(const G of this._points)A+=G.length;const T=A/3*2-this._widths.length;for(let G=0;G<T;G++)this._widths.push(K)}updateLazy(){var K,A;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(K=this._options.ribbonOptions)||void 0===K?void 0:K.smoothShading),!this.rK&&this.refreshBoundingInfo(),null===(A=this.greasedLineMaterial)||void 0===A||A.updateLazy()}addPoints(K,A){for(const T of K)this._points.push(T);this._lazy||this.setPoints(this._points,A)}dispose(K){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(K,A)}isLazy(){return this._lazy}get HK(){return this._uvs}set HK(K){this._uvs=K instanceof Float32Array?K:new Float32Array(K),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(K){this.material instanceof jK&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===K||void 0===K?void 0:K.length)>0),this._offsets=K,this._offsetsBuffer?this._offsetsBuffer.update(K):this._createOffsetsBuffer(K)}get widths(){return this._widths}set widths(K){this._widths=K,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(K)}get colorPointers(){return this._colorPointers}set colorPointers(K){this._colorPointers=K,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(K)}get greasedLineMaterial(){var K,A;if(this.material&&this.material instanceof jK)return this.material;const T=null===(K=this.material)||void 0===K||null===(A=K.pluginManager)||void 0===A?void 0:A.getPlugin(pK.GREASED_LINE_MATERIAL_NAME);return T||void 0}get points(){const K=[];return hK.c.DeepCopy(this._points,K),K}setPoints(K,A){this._points=HK.ConvertPoints(K,(null===A||void 0===A?void 0:A.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==A&&void 0!==A&&A.colorPointers||this._updateColorPointers(),this._setPoints(this._points,A)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,HK:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(K){super.serialize(K),K.type=this.getClassName(),K.lineOptions=this._createLineOptions()}_createVertexBuffers(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new rK.d;return A.uK=this._vertexPositions,A.indices=this._indices,A.HK=this._uvs,K&&(A.cK=[],rK.d.ComputeNormals(this._vertexPositions,this._indices,A.cK)),A.pK(this,this._options.updatable),A}_createOffsetsBuffer(K){const A=this._scene.getEngine(),T=new Y.b(A,K,this._updatable,3);this.setVerticesBuffer(T.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=T}}class WK{constructor(K,A){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=K,this.wasAddedByNoopNode=A}getIndicesAccessor(K,A,T,G,B){var L,f,O,C;return null===(L=this._indicesAccessorMap.get(K))||void 0===L||null===(f=L.get(A))||void 0===f||null===(O=f.get(T))||void 0===O||null===(C=O.get(G))||void 0===C?void 0:C.get(B)}setIndicesAccessor(K,A,T,G,B,L){let f=this._indicesAccessorMap.get(K);f||(f=new Map,this._indicesAccessorMap.set(K,f));let O=f.get(A);O||(O=new Map,f.set(A,O));let C=O.get(T);C||(C=new Map,O.set(T,C));let Q=C.get(G);Q||(Q=new Map,C.set(G,Q)),Q.set(B,L)}pushExportedNode(K){this._exportedNodes.has(K)||this._exportedNodes.add(K)}getNodesSet(){return this._exportedNodes}getVertexBufferView(K){return this._vertexBufferViewMap.get(K)}setVertexBufferView(K,A){this._vertexBufferViewMap.set(K,A)}setRemappedBufferView(K,A,T){this._remappedBufferView.set(K,new Map),this._remappedBufferView.get(K).set(A,T)}getRemappedBufferView(K,A){var T;return null===(T=this._remappedBufferView.get(K))||void 0===T?void 0:T.get(A)}getVertexAccessor(K,A,T){var G,B;return null===(G=this._vertexAccessorMap.get(K))||void 0===G||null===(B=G.get(A))||void 0===B?void 0:B.get(T)}setVertexAccessor(K,A,T,G){let B=this._vertexAccessorMap.get(K);B||(B=new Map,this._vertexAccessorMap.set(K,B));let L=B.get(A);L||(L=new Map,B.set(A,L)),L.set(T,G)}hasVertexColorAlpha(K){return this._vertexMapColorAlpha.get(K)||!1}setHasVertexColorAlpha(K,A){return this._vertexMapColorAlpha.set(K,A)}getMesh(K){return this._meshMap.get(K)}setMesh(K,A){this._meshMap.set(K,A)}bindMorphDataToMesh(K,A){const T=this._meshMorphTargetMap.get(K)||[];this._meshMorphTargetMap.set(K,T),-1===T.indexOf(A)&&T.push(A)}getMorphTargetsFromMesh(K){return this._meshMorphTargetMap.get(K)}}class iK{_ApplyExtension(K,A,T,G){if(T>=A.length)return Promise.resolve(K);const B=G(A[T],K);return B?B.then((async K=>K?await this._ApplyExtension(K,A,T+1,G):null)):this._ApplyExtension(K,A,T+1,G)}_ApplyExtensions(K,A){const T=[];for(const G of iK._ExtensionNames)T.push(this._extensions[G]);return this._ApplyExtension(K,T,0,A)}_extensionsPreExportTextureAsync(K,A,T){return this._ApplyExtensions(A,((A,G)=>A.preExportTextureAsync&&A.preExportTextureAsync(K,G,T)))}_extensionsPostExportNodeAsync(K,A,T,G,B){return this._ApplyExtensions(A,((A,L)=>A.postExportNodeAsync&&A.postExportNodeAsync(K,L,T,G,B,this._bufferManager)))}_extensionsPostExportMaterialAsync(K,A,T){return this._ApplyExtensions(A,((A,G)=>A.postExportMaterialAsync&&A.postExportMaterialAsync(K,G,T)))}_extensionsPostExportMaterialAdditionalTextures(K,A,T){const G=[];for(const B of iK._ExtensionNames){const L=this._extensions[B];L.postExportMaterialAdditionalTextures&&G.push(...L.postExportMaterialAdditionalTextures(K,A,T))}return G}_extensionsPostExportTextures(K,A,T){for(const G of iK._ExtensionNames){const B=this._extensions[G];B.postExportTexture&&B.postExportTexture(K,A,T)}}_extensionsPostExportMeshPrimitive(K){for(const A of iK._ExtensionNames){const T=this._extensions[A];T.postExportMeshPrimitive&&T.postExportMeshPrimitive(K,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const K of iK._ExtensionNames){const A=this._extensions[K];A.preGenerateBinaryAsync&&await A.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(K){for(const A of iK._ExtensionNames){const T=this._extensions[A];T.enabled&&K(T)}}_extensionsOnExporting(){this._forEachExtensions((K=>{var A,T,G;K.wasUsed&&((A=this._glTF).extensionsUsed||(A.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(K.name)&&this._glTF.extensionsUsed.push(K.name),K.required&&((T=this._glTF).extensionsRequired||(T.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(K.name)&&this._glTF.extensionsRequired.push(K.name)),(G=this._glTF).extensions||(G.extensions={}),K.onExporting&&K.onExporting())}))}_loadExtensions(){for(const K of iK._ExtensionNames){const A=iK._ExtensionFactories[K](this);this._extensions[K]=A}}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:P.b.LastCreatedScene,A=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${b.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new s(this),this._extensions={},this._bufferManager=new YK,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!K)throw new Error("No scene available to export");this._babylonScene=K,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:K=>{var A;return null===K||void 0===K||null===(A=K.Sf)||void 0===A?void 0:A.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...A},this._loadExtensions()}dispose(){for(const K in this._extensions){this._extensions[K].dispose()}}get options(){return this._options}static RegisterExtension(K,A){iK.UnregisterExtension(K)&&B.Tools.Warn(`Extension with the name ${K} already exists`),iK._ExtensionFactories[K]=A,iK._ExtensionNames.push(K)}static UnregisterExtension(K){if(!iK._ExtensionFactories[K])return!1;delete iK._ExtensionFactories[K];const A=iK._ExtensionNames.indexOf(K);return-1!==A&&iK._ExtensionNames.splice(A,1),!0}_generateJSON(K,A,T){const G={byteLength:K};return G.byteLength&&(this._glTF.buffers=[G]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.dA=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(G.uri=A+".bin"),T?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(K){const A=await this._generateBinaryAsync();this._extensionsOnExporting();const T=this._generateJSON(A.byteLength,K,!0),G=new Blob([A],{type:"application/octet-stream"}),B=K+".gltf",L=K+".bin",f=new Q;if(f.files[B]=T,f.files[L]=G,this._imageData)for(const O in this._imageData)f.files[O]=new Blob([this._imageData[O].data],{type:this._imageData[O].mimeType});return f}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(K){const A=K%4;return 0===A?A:4-A}async generateGLBAsync(K){this._shouldUseGlb=!0;const A=await this._generateBinaryAsync();this._extensionsOnExporting();const T=this._generateJSON(A.byteLength),G=K+".glb";let B,L=T.length;if("undefined"!==typeof TextEncoder){B=(new TextEncoder).encode(T),L=B.length}const f=this._getPadding(L),O=this._getPadding(A.byteLength),C=28+L+f+A.byteLength+O,Y=new CK(C);if(Y.writeUInt32(1179937895),Y.writeUInt32(2),Y.writeUInt32(C),Y.writeUInt32(L+f),Y.writeUInt32(1313821514),B)Y.writeTypedArray(B);else{const K="_".charCodeAt(0);for(let A=0;A<L;++A){const G=T.charCodeAt(A);G!=T.codePointAt(A)?Y.writeUInt8(K):Y.writeUInt8(G)}}for(let Q=0;Q<f;++Q)Y.writeUInt8(32);Y.writeUInt32(A.byteLength+O),Y.writeUInt32(5130562),Y.writeTypedArray(A);for(let Q=0;Q<O;++Q)Y.writeUInt8(0);const Z=new Q;return Z.files[G]=new Blob([Y.getOutputData()],{type:"application/octet-stream"}),Z}_setNodeTransformation(K,A,T){if(A.getPivotPoint().equalsWithEpsilon(o,I.c)||B.Tools.Warn("Pivot points are not supported in the glTF serializer"),!A.position.equalsWithEpsilon(o,I.c)){const B=G.TmpVectors.PA[0].G(A.position);T&&M(B),K.translation=B.kf()}A.vO.equalsWithEpsilon(i,I.c)||(K.scale=A.vO.kf());const L=A.rotationQuaternion||G.Quaternion.FromEulerAngles(A.rotation.x,A.rotation.y,A.rotation.z);L.equalsWithEpsilon(W,I.c)||(T&&E(L),K.rotation=L.normalize().kf())}_setCameraTransformation(K,A,T){if(!A.position.equalsWithEpsilon(o,I.c)){const B=G.TmpVectors.PA[0].G(A.position);T&&M(B),K.translation=B.kf()}const B=A.rotationQuaternion||G.Quaternion.FromEulerAngles(A.rotation.x,A.rotation.y,A.rotation.z);T&&E(B),this._babylonScene.useRightHandedSystem||t(B),B.equalsWithEpsilon(W,I.c)||(K.rotation=B.kf())}_listAvailableCameras(){for(const K of this._babylonScene.cameras){const A={type:K.mode===xK.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(K.name&&(A.name=K.name),"perspective"===A.type)A.perspective={aspectRatio:K.getEngine().getAspectRatio(K),yfov:K.fovMode===xK.e.FOVMODE_VERTICAL_FIXED?K.fov:K.fov*K.getEngine().getAspectRatio(K),znear:K.If,zfar:K.maxZ};else if("orthographic"===A.type){const T=K.orthoLeft&&K.orthoRight?.5*(K.orthoRight-K.orthoLeft):.5*K.getEngine().getRenderWidth(),G=K.orthoBottom&&K.orthoTop?.5*(K.orthoTop-K.orthoBottom):.5*K.getEngine().getRenderHeight();A.orthographic={xmag:T,ymag:G,znear:K.If,zfar:K.maxZ}}this._camerasMap.set(K,A)}}_exportAndAssignCameras(){const K=Array.from(this._camerasMap.values());for(const A of K){const K=this._nodesCameraMap.get(A);if(void 0!==K){this._cameras.push(A);for(const A of K)A.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const K of this._babylonScene.skeletons){if(K.bones.length<=0)continue;const A={joints:[]};this._skinMap.set(K,A)}}_exportAndAssignSkeletons(){for(const K of this._babylonScene.skeletons){if(K.bones.length<=0)continue;const A=this._skinMap.get(K);if(void 0==A)continue;const T={},G=[];let L=-1;for(let B=0;B<K.bones.length;++B){const A=K.bones[B],G=A.getIndex()??B;-1!==G&&(T[G]=A,G>L&&(L=G))}for(let K=0;K<=L;++K){const L=T[K];G.push(L.getAbsoluteInverseBindMatrix());const f=L.getTransformNode();if(null!==f){const K=this._nodeMap.get(f);f&&null!==K&&void 0!==K?A.joints.push(K):B.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else B.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const f=this._nodesSkinMap.get(A);if(A.joints.length>0&&void 0!==f){const K=64*G.length,T=new Float32Array(K/4);G.forEach(((K,A)=>{T.set(K.m,16*A)}));const B=this._bufferManager.createBufferView(T);this._accessors.push(this._bufferManager.createAccessor(B,"MAT4",5126,G.length)),A.inverseBindMatrices=this._accessors.length-1,this._skins.push(A);for(const A of f)A.skin=this._skins.length-1}}}async _exportSceneAsync(){const K={nodes:[]};if(this._babylonScene.metadata){const A=this._options.metadataSelector(this._babylonScene.metadata);A&&(K.extras=A)}const A=new Array,T=new Array,G=new Array;for(const O of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&fK(O,this._babylonScene.useRightHandedSystem)?G.push(...O.getChildren()):this._babylonScene.useRightHandedSystem?A.push(O):T.push(O);this._listAvailableCameras(),this._listAvailableSkeletons();const B=new WK(!0,!1);K.nodes.push(...await this._exportNodesAsync(T,B));const L=new WK(!1,!1);K.nodes.push(...await this._exportNodesAsync(A,L));const f=new WK(!1,!0);K.nodes.push(...await this._exportNodesAsync(G,f)),K.nodes.length&&this._scenes.push(K),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&mA._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,B.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(K){let A=this._shouldExportNodeMap.get(K);return void 0===A&&(A=this._options.shouldExportNode(K),this._shouldExportNodeMap.set(K,A)),A}async _exportNodesAsync(K,A){const T=new Array;this._exportBuffers(K,A);for(const G of K)await this._exportNodeAsync(G,T,A);return T}_collectBuffers(K,A,T,G,B){if(this._shouldExportNode(K)&&K instanceof x.e&&K.Mf){const L=K.Mf.getVertexBuffers();if(L)for(const G in L){if(!y(G))continue;const f=L[G];B.setHasVertexColorAlpha(f,K.hasVertexAlpha);const O=f._buffer,C=A.get(O)||[];A.set(O,C),-1===C.indexOf(f)&&C.push(f);const Q=T.get(f)||[];T.set(f,Q),-1===Q.indexOf(K)&&Q.push(K)}const f=K.morphTargetManager;if(f)for(let A=0;A<f.numTargets;A++){const T=f.getTarget(A),B=G.get(T)||[];G.set(T,B),-1===B.indexOf(K)&&B.push(K)}}for(const L of K.getChildren())this._collectBuffers(L,A,T,G,B)}_exportBuffers(K,A){const T=new Map,G=new Map,B=new Map;for(const O of K)this._collectBuffers(O,T,G,B,A);const L=Array.from(T.keys());for(const O of L){const K=O.getData();if(!K)throw new Error("Buffer data is not available");const B=T.get(O);if(!B)continue;const L=B[0].byteStride;if(B.some((K=>K.byteStride!==L)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const f=TK(K).slice();for(const A of B){const K=G.get(A),{byteOffset:T,byteStride:B,componentCount:L,type:O,count:C,normalized:Q,kind:Z}=X(A,K);switch(Z){case Y.d.NormalKind:case Y.d.TangentKind:(0,j.k)(f,T,B,L,O,C,Q,(K=>{const A=Math.sqrt(K[0]*K[0]+K[1]*K[1]+K[2]*K[2]);if(A>0){const T=1/A;K[0]*=T,K[1]*=T,K[2]*=T}}));break;case Y.d.ColorKind:{const A=K.filter((K=>K.material instanceof PK.NA||null==K.material)).length;if(0==A)break;if(A!=K.length){R.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}O==Y.d.UNSIGNED_BYTE&&R.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const G=new F.DA,Z=new F.oO,x=this._babylonScene.getEngine().useExactSrgbConversions;(0,j.k)(f,T,B,L,O,C,Q,(K=>{3===K.length?(G.bT(K,0),G.toLinearSpaceToRef(G,x),G.toArray(K,0)):(Z.bT(K,0),Z.toLinearSpaceToRef(Z,x),Z.toArray(K,0))}))}}}if(A.convertToRightHanded){for(const K of B){const A=G.get(K),{byteOffset:T,byteStride:B,componentCount:L,type:O,count:C,normalized:Q,kind:Z}=X(K,A);switch(Z){case Y.d.PositionKind:case Y.d.NormalKind:case Y.d.TangentKind:(0,j.k)(f,T,B,L,O,C,Q,(K=>{K[0]=-K[0]}))}}A.convertedToRightHandedBuffers.set(O,f)}const C=this._bufferManager.createBufferView(f,L);A.setVertexBufferView(O,C);const Q=new Map;for(const A of B){const K=G.get(A),{kind:T,totalVertices:B}=X(A,K);switch(T){case Y.d.MatricesIndicesKind:case Y.d.MatricesIndicesExtraKind:if(A.type==Y.d.FLOAT){const K=A.getFloatData(B);null!==K&&Q.set(A,K)}}}0!==Q.size&&R.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const Z=Array.from(Q.keys());for(const T of Z){const K=Q.get(T);if(!K)continue;const G=K.some((K=>K>=256)),B=new(G?Uint16Array:Uint8Array)(K.length);for(let A=0;A<K.length;A++)B[A]=K[A];const L=this._bufferManager.createBufferView(B,4*(G?2:1));A.setRemappedBufferView(O,T,L)}}const f=Array.from(B.keys());for(const O of f){const K=B.get(O);if(!K)continue;const T=UK(O,K[0],this._bufferManager,this._bufferViews,this._accessors,A.convertToRightHanded);for(const G of K)A.bindMorphDataToMesh(G,T)}}async _exportNodeAsync(K,A,T){let G=this._nodeMap.get(K);if(void 0!==G)return void(A.includes(G)||A.push(G));const B=await this._createNodeAsync(K,T);if(B){G=this._nodes.length,this._nodes.push(B),this._nodeMap.set(K,G),T.pushExportedNode(K),A.push(G);const L={name:"runtime animations",channels:[],samplers:[]},f=[];this._babylonScene.animationGroups.length||(mA._CreateMorphTargetAnimationFromMorphTargetAnimations(K,L,f,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,T.convertToRightHanded,this._options.shouldExportAnimation),K.animations.length&&mA._CreateNodeAnimationFromNodeAnimations(K,L,f,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,T.convertToRightHanded,this._options.shouldExportAnimation)),L.channels.length&&L.samplers.length&&this._animations.push(L),f.forEach((K=>{K.channels.length&&K.samplers.length&&this._animations.push(K)}))}const L=B?[]:A;for(const f of K.getChildren())await this._exportNodeAsync(f,L,T);B&&L.length&&(B.children=L)}async _createNodeAsync(K,A){if(!this._shouldExportNode(K))return null;const T={};if(K.name&&(T.name=K.name),K.metadata){const A=this._options.metadataSelector(K.metadata);A&&(T.extras=A)}if(K instanceof Z.b&&(this._setNodeTransformation(T,K,A.convertToRightHanded),K instanceof x.e)){const B=K instanceof J.e?K.sourceMesh:K;if(B.hf&&B.hf.length>0&&(T.mesh=await this._exportMeshAsync(B,A)),K.skeleton){const A=this._skinMap.get(K.skeleton);var G;if(void 0!==A)void 0===this._nodesSkinMap.get(A)&&this._nodesSkinMap.set(A,[]),null===(G=this._nodesSkinMap.get(A))||void 0===G||G.push(T)}}if(K instanceof v.d){const G=this._camerasMap.get(K);if(G){var B;void 0===this._nodesCameraMap.get(G)&&this._nodesCameraMap.set(G,[]),this._setCameraTransformation(T,K,A.convertToRightHanded);const f=K.parent;if(null!==f&&AK(K,f)){const K=this._nodeMap.get(f);if(void 0!==K){var L;const A=this._nodes[K];return KK(T,A),null===(L=this._nodesCameraMap.get(G))||void 0===L||L.push(A),null}}null===(B=this._nodesCameraMap.get(G))||void 0===B||B.push(T)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",T,K,this._nodeMap,A.convertToRightHanded)?T:(R.d.Warn(`Not exporting node ${K.name}`),null)}_exportIndices(K,A,T,G,B,f,O,C,Q){let Y=K;Q.mode=w(f);const Z=O!==L.e.CounterClockWiseSideOrientation,x=!C.wasAddedByNoopNode&&Z,J=function(K){switch(K){case L.e.TriangleFillMode:case L.e.TriangleStripDrawMode:case L.e.TriangleFanDrawMode:return!0}return!1}(f)&&x;if(J){if(f===L.e.TriangleStripDrawMode||f===L.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");Q.mode=w(f);const O=A?new Uint32Array(G):new Uint16Array(G);if(K)for(let A=0;A+2<G;A+=3)O[A]=K[T+A]+B,O[A+1]=K[T+A+2]+B,O[A+2]=K[T+A+1]+B;else for(let K=0;K+2<G;K+=3)O[K]=K,O[K+1]=K+2,O[K+2]=K+1;Y=O}else if(K&&0!==B){const L=A?new Uint32Array(G):new Uint16Array(G);for(let A=0;A<G;A++)L[A]=K[T+A]+B;Y=L}if(Y){let L=C.getIndicesAccessor(K,T,G,B,J);if(void 0===L){const f=function(K,A,T,G){if(K instanceof Uint16Array||K instanceof Uint32Array)return K;if(K instanceof Int32Array)return new Uint32Array(K.buffer,K.byteOffset,K.length);const B=K.slice(A,A+T);return G?new Uint32Array(B):new Uint16Array(B)}(Y,0,G,A),O=this._bufferManager.createBufferView(f),Q=A?5125:5123;this._accessors.push(this._bufferManager.createAccessor(O,"SCALAR",Q,G,0)),L=this._accessors.length-1,C.setIndicesAccessor(K,T,G,B,J,L)}Q.indices=L}}_exportVertexBuffer(K,A,T,G,B,L){const f=K.getKind();if(!y(f))return;if(f.startsWith("uv")&&!this._options.exportUnusedUVs&&(!A||!this._materialNeedsUVsSet.has(A)))return;let O=B.getVertexAccessor(K,T,G);if(void 0===O){const A=B.convertedToRightHandedBuffers.get(K._buffer)||K._buffer.getData(),L=f===Y.d.PositionKind?function(K,A,T,G){const{byteOffset:B,byteStride:L,type:f,normalized:O}=A,C=A.getSize(),Q=new Array(C).fill(1/0),Y=new Array(C).fill(-1/0);return(0,j.k)(K,B+T*L,L,C,f,G*C,O,(K=>{for(let A=0;A<C;A++)Q[A]=Math.min(Q[A],K[A]),Y[A]=Math.max(Y[A],K[A])})),{min:Q,max:Y}}(A,K,T,G):void 0,C=(f===Y.d.MatricesIndicesKind||f===Y.d.MatricesIndicesExtraKind)&&K.type===Y.d.FLOAT,Q=C?Y.d.UNSIGNED_BYTE:K.type,Z=C?void 0:K.normalized,x=C?B.getRemappedBufferView(K._buffer,K):B.getVertexBufferView(K._buffer),J=K.byteOffset+T*K.byteStride;this._accessors.push(this._bufferManager.createAccessor(x,function(K,A){if(K==Y.d.ColorKind)return A?"VEC4":"VEC3";switch(K){case Y.d.PositionKind:case Y.d.NormalKind:return"VEC3";case Y.d.TangentKind:case Y.d.MatricesIndicesKind:case Y.d.MatricesIndicesExtraKind:case Y.d.MatricesWeightsKind:case Y.d.MatricesWeightsExtraKind:return"VEC4";case Y.d.UVKind:case Y.d.UV2Kind:case Y.d.UV3Kind:case Y.d.UV4Kind:case Y.d.UV5Kind:case Y.d.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${K}`)}(f,B.hasVertexColorAlpha(K)),Q,G,J,L,Z)),O=this._accessors.length-1,B.setVertexAccessor(K,T,G,O)}L.attributes[function(K){switch(K){case Y.d.PositionKind:return"POSITION";case Y.d.NormalKind:return"NORMAL";case Y.d.TangentKind:return"TANGENT";case Y.d.ColorKind:return"COLOR_0";case Y.d.UVKind:return"TEXCOORD_0";case Y.d.UV2Kind:return"TEXCOORD_1";case Y.d.UV3Kind:return"TEXCOORD_2";case Y.d.UV4Kind:return"TEXCOORD_3";case Y.d.UV5Kind:return"TEXCOORD_4";case Y.d.UV6Kind:return"TEXCOORD_5";case Y.d.MatricesIndicesKind:return"JOINTS_0";case Y.d.MatricesIndicesExtraKind:return"JOINTS_1";case Y.d.MatricesWeightsKind:return"WEIGHTS_0";case Y.d.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${K}`)}(f)]=O}async _exportMaterialAsync(K,A,T,G){let B=this._materialMap.get(K);if(void 0===B){const G=A&&Object.keys(A).some((K=>K.startsWith("uv")));if((K=K instanceof JK.d?K.WO[T.materialIndex]:K)instanceof bK.c)B=await this._materialExporter.exportPBRMaterialAsync(K,"image/png",G);else{if(!(K instanceof PK.NA))return void R.d.Warn(`Unsupported material '${K.name}' with type ${K.getClassName()}`);B=await this._materialExporter.exportStandardMaterialAsync(K,"image/png",G)}this._materialMap.set(K,B)}G.material=B}async _exportMeshAsync(K,A){var T;let G=A.getMesh(K);if(void 0!==G)return G;const B={primitives:[]};G=this._meshes.length,this._meshes.push(B),A.setMesh(K,G);const f=K.isUnIndexed?null:K.Ef(),O=null===(T=K.Mf)||void 0===T?void 0:T.getVertexBuffers(),C=A.getMorphTargetsFromMesh(K),Q=K instanceof zK.e,Y=K instanceof oK,Z=K.hf;if(O&&Z&&Z.length>0)for(const b of Z){const T={attributes:{}},G=b.jK()||this._babylonScene.defaultMaterial;if(Y){var x,J;const A={name:G.name},B=K,L=F.DA.White(),f=(null===(x=B.material)||void 0===x?void 0:x.alpha)??1,O=(null===(J=B.greasedLineMaterial)||void 0===J?void 0:J.color)??L;(!O.equalsWithEpsilon(L,I.c)||f<1)&&(A.pbrMetallicRoughness={baseColorFactor:[...O.kf(),f]}),this._materials.push(A),T.material=this._materials.length-1}else if(Q){const A={name:G.name},B=K;(!B.color.equalsWithEpsilon(F.DA.White(),I.c)||B.alpha<1)&&(A.pbrMetallicRoughness={baseColorFactor:[...B.color.kf(),B.alpha]}),this._materials.push(A),T.material=this._materials.length-1}else await this._exportMaterialAsync(G,O,b,T);const Z=Q||Y?L.e.LineListDrawMode:K.overrideRenderingFillMode??G.fillMode,P=G._getEffectiveOrientation(K);this._exportIndices(f,f?(0,j.d)(f,b.indexCount,b.indexStart,b.verticesStart):b.verticesCount>65535,f?b.indexStart:b.verticesStart,f?b.indexCount:b.verticesCount,-b.verticesStart,Z,P,A,T);for(const K of Object.values(O))this._exportVertexBuffer(K,G,b.verticesStart,b.verticesCount,A,T);if(C){T.targets=[];for(const K of C)T.targets.push(K.attributes)}B.primitives.push(T),this._extensionsPostExportMeshPrimitive(T)}if(C){B.weights=[],B.extras||(B.extras={}),B.extras.targetNames=[];for(const K of C)B.weights.push(K.influence),B.extras.targetNames.push(K.name)}return G}}iK._ExtensionNames=new Array,iK._ExtensionFactories={};class VK{static async GLTFAsync(K,A,T){T&&T.exportWithoutWaitingForScene||await K.whenReadyAsync();const G=new iK(K,T),B=await G.generateGLTFAsync(A.replace(/\.[^/.]+$/,""));return G.dispose(),B}static async GLBAsync(K,A,T){T&&T.exportWithoutWaitingForScene||await K.whenReadyAsync();const G=new iK(K,T),B=await G.generateGLBAsync(A.replace(/\.[^/.]+$/,""));return G.dispose(),B}}T(13266);const XK="EXT_mesh_gpu_instancing";class qK{constructor(K){this.name=XK,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(K,A,T,B,L,f){return await new Promise((K=>{if(A&&T instanceof NK.e&&T.hasThinInstances&&this._exporter){this._wasUsed=!0;const K=G.PA.Zero(),B=G.Quaternion.Identity(),O=G.PA.One(),C=T.thinInstanceGetWorldMatrices(),Q=G.TmpVectors.PA[2],Y=G.TmpVectors.Quaternion[1],Z=G.TmpVectors.PA[3];let x=!1,J=!1,b=!1;const P=new Float32Array(3*T.iO),F=new Float32Array(4*T.iO),d=new Float32Array(3*T.iO);let N=0;for(const A of C)A.decompose(Z,Y,Q),L&&(M(Q),E(Y)),P.set(Q.kf(),3*N),F.set(Y.normalize().kf(),4*N),d.set(Z.kf(),3*N),x=x||!Q.equalsWithEpsilon(K),J=J||!Y.equalsWithEpsilon(B),b=b||!Z.equalsWithEpsilon(O),N++;const D={attributes:{}};x&&(D.attributes.TRANSLATION=this._buildAccessor(P,"VEC3",T.iO,f)),J&&(D.attributes.ROTATION=this._buildAccessor(F,"VEC4",T.iO,f)),b&&(D.attributes.SCALE=this._buildAccessor(d,"VEC3",T.iO,f)),A.extensions=A.extensions||{},A.extensions[XK]=D}K(A)}))}_buildAccessor(K,A,T,G){const B=G.createBufferView(K),L=G.createAccessor(B,A,5126,T);return this._exporter._accessors.push(L),this._exporter._accessors.length-1}}iK.RegisterExtension(XK,(K=>new qK(K)));var yK=T(13272),wK=T(13283),aK=T(13286),MK=T(13288);function EK(K){return K===aK.c.PositionKind?"POSITION":K===aK.c.NormalKind?"NORMAL":K===aK.c.ColorKind?"COLOR":K.startsWith(aK.c.UVKind)?"TEX_COORD":"GENERIC"}const tK={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class KA extends yK.c{static get DefaultAvailable(){return(0,yK.f)(KA.DefaultConfiguration)}static get Default(){return KA._Default??(KA._Default=new KA),KA._Default}static ResetDefault(K){KA._Default&&(K||KA._Default.dispose(),KA._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(K,A){return{module:await(A||DracoEncoderModule)({wasmBinary:K})}}_getWorkerContent(){return`${wK.h}(${wK.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:KA.DefaultConfiguration)}async _encodeAsync(K,A,T){const G=T?(0,MK.e)(tK,T):tK;if(this._workerPoolPromise){const T=await this._workerPoolPromise;return await new Promise(((B,L)=>{T.push(((T,f)=>{const O=K=>{T.removeEventListener("error",O),T.removeEventListener("message",C),L(K),f()},C=K=>{"encodeMeshDone"===K.data.id&&(T.removeEventListener("error",O),T.removeEventListener("message",C),B(K.data.encodedMeshData),f())};T.addEventListener("error",O),T.addEventListener("message",C);const Q=[];for(const A of K)Q.push(A.data.buffer);A&&Q.push(A.buffer),T.postMessage({id:"encodeMesh",attributes:K,indices:A,options:G},Q)}))}))}if(this._modulePromise){const T=await this._modulePromise;return(0,wK.h)(T.module,K,A,G)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(K,A){if(0==K.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");K instanceof NK.e&&K.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===A||void 0===A?void 0:A.method)&&(R.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),A.method="MESH_SEQUENTIAL_ENCODING");const T=function(K){let A=K.Ef(void 0,!0);return!A||A instanceof Uint32Array||A instanceof Uint16Array||(A=((0,j.d)(A,A.length)?Uint32Array:Uint16Array).from(A)),A}(K),G=function(K,A){const T=[];for(const G of K.getVerticesDataKinds()){if(null!==A&&void 0!==A&&A.includes(G)){if(G===aK.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const B=K.getVertexBuffer(G),L=B.getSize(),f=(0,j.s)(B.getData(),L,B.type,B.byteOffset,B.byteStride,B.normalized,K.getTotalVertices(),!0);T.push({kind:G,dracoName:EK(G),size:L,data:f})}return T}(K,null===A||void 0===A?void 0:A.excludedAttributes);return await this._encodeAsync(G,T,A)}}KA.DefaultConfiguration={wasmUrl:`${B.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${B.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${B.Tools._DefaultCdnUrl}/draco_encoder.js`},KA._Default=null;const AA="KHR_draco_mesh_compression";class TA{get wasUsed(){return this._wasUsed}constructor(K){this.name=AA,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===K.options.meshCompressionMethod&&KA.DefaultAvailable}dispose(){}postExportMeshPrimitive(K,A,T){if(!this.enabled)return;if(4!==K.mode&&5!==K.mode)return void R.d.Warn("Cannot compress primitive with mode "+K.mode+".");const G=[],B=[];let L=null;if(void 0!==K.indices){const f=T[K.indices],O=A.getBufferView(f);L=A.getData(O).slice(),G.push(O),B.push(f)}const f=[];for(const[Y,Z]of Object.entries(K.attributes)){const K=T[Z],L=A.getBufferView(K),C=q(K.type),Q=(0,j.s)(A.getData(L),C,K.componentType,K.byteOffset||0,L.byteStride||(0,j.p)(K.componentType)*C,K.normalized||!1,K.count,!0);f.push({kind:Y,dracoName:(O=Y,"POSITION"===O?"POSITION":"NORMAL"===O?"NORMAL":O.startsWith("COLOR")?"COLOR":O.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:q(K.type),data:Q}),G.push(L),B.push(K)}var O;const C={method:K.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},Q=KA.Default._encodeAsync(f,L,C).then((T=>{if(!T)return void R.d.Error("Draco encoding failed for primitive.");const L={bufferView:-1,attributes:T.attributeIds},f=A.createBufferView(T.data);A.setBufferView(L,f);for(const K of G)this._bufferViewsUsed.add(K);for(const K of B)this._accessorsUsed.add(K);K.extensions||(K.extensions={}),K.extensions[AA]=L})).catch((K=>{R.d.Error("Draco encoding failed for primitive: "+K)}));this._encodePromises.push(Q),this._wasUsed=!0}async preGenerateBinaryAsync(K){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((A=>{K.getPropertiesWithBufferView(A).every((K=>this._accessorsUsed.has(K)))&&K.removeBufferView(A)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}iK.RegisterExtension(AA,(K=>new TA(K)));var GA=T(13290);const BA="KHR_lights_punctual",LA={name:"",color:[1,1,1],VO:1,range:Number.MAX_VALUE},fA={innerConeAngle:0,outerConeAngle:Math.PI/4},OA=G.PA.Backward();class CA{constructor(K){this.name=BA,this.enabled=!0,this.required=!1,this._exporter=K}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[BA]=this._lights}async postExportNodeAsync(K,A,T,B,L){return await new Promise((f=>{if(!(T instanceof DK.b))return void f(A);const O=T.getTypeID()==DK.b.LIGHTTYPEID_POINTLIGHT?"point":T.getTypeID()==DK.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":T.getTypeID()==DK.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!O||!(T instanceof GA.d))return R.d.Warn(`${K}: Light ${T.name} is not supported in ${BA}`),void f(A);if(T.falloffType!==DK.b.FALLOFF_GLTF&&R.d.Warn(`${K}: Light falloff for ${T.name} does not match the ${BA} specification!`),!T.position.equalsToFloats(0,0,0)){const K=G.TmpVectors.PA[0].G(T.position);L&&M(K),A.translation=K.kf()}if("point"!==O){const K=T.direction.normalizeToRef(G.TmpVectors.PA[0]);L&&M(K);const B=G.Quaternion.FromUnitVectorsToRef(OA,K,G.TmpVectors.Quaternion[0]);G.Quaternion.IsIdentity(B)||(A.rotation=B.kf())}const C={type:O,name:T.name,color:T.XO.kf(),VO:T.VO,range:T.range};if(GK(C,LA),"spot"===O){const K=T;C.spot={innerConeAngle:K.innerAngle/2,outerConeAngle:K.angle/2},GK(C.spot,fA)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(C);const Q={Cf:this._lights.lights.length-1},Y=T.parent;if(Y&&AK(T,Y)){const K=B.get(Y);if(K){const T=this._exporter._nodes[K];return KK(A,T),T.extensions||(T.extensions={}),T.extensions[BA]=Q,void f(null)}}A.extensions||(A.extensions={}),A.extensions[BA]=Q,f(A)}))}}iK.RegisterExtension(BA,(K=>new CA(K)));var QA=T(13210);const YA="KHR_materials_anisotropy";class ZA{constructor(K){this.name=YA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,A,T){const G=[];return T instanceof QA.b&&T.anisotropy.isEnabled&&!T.anisotropy.legacy?(T.anisotropy.texture&&G.push(T.anisotropy.texture),G):[]}postExportMaterialAsync(K,A,T){return new Promise((K=>{if(T instanceof QA.b){if(!T.anisotropy.isEnabled||T.anisotropy.legacy)return void K(A);this._wasUsed=!0,A.extensions=A.extensions||{};const G=this._exporter._materialExporter.getTextureInfo(T.anisotropy.texture),B={anisotropyStrength:T.anisotropy.VO,anisotropyRotation:T.anisotropy.angle,anisotropyTexture:G??void 0};null!==B.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(T),A.extensions[YA]=B}K(A)}))}}iK.RegisterExtension(YA,(K=>new ZA(K)));const xA="KHR_materials_clearcoat";class JA{constructor(K){this.name=xA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,A,T){const G=[];return T instanceof QA.b&&T.clearCoat.isEnabled?(T.clearCoat.texture&&G.push(T.clearCoat.texture),!T.clearCoat.useRoughnessFromMainTexture&&T.clearCoat.textureRoughness&&G.push(T.clearCoat.textureRoughness),T.clearCoat.bumpTexture&&G.push(T.clearCoat.bumpTexture),G):[]}postExportMaterialAsync(K,A,T){return new Promise((K=>{if(T instanceof QA.b){if(!T.clearCoat.isEnabled)return void K(A);this._wasUsed=!0,A.extensions=A.extensions||{};const G=this._exporter._materialExporter.getTextureInfo(T.clearCoat.texture);let L;L=T.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(T.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(T.clearCoat.textureRoughness),T.clearCoat.isTintEnabled&&B.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${T.name}`),T.clearCoat.remapF0OnInterfaceChange&&B.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${T.name}`);const f=this._exporter._materialExporter.getTextureInfo(T.clearCoat.bumpTexture),O={clearcoatFactor:T.clearCoat.VO,clearcoatTexture:G??void 0,clearcoatRoughnessFactor:T.clearCoat.roughness,clearcoatRoughnessTexture:L??void 0,clearcoatNormalTexture:f??void 0};null===O.clearcoatTexture&&null===O.clearcoatRoughnessTexture&&null===O.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(T),A.extensions[xA]=O}K(A)}))}}iK.RegisterExtension(xA,(K=>new JA(K)));const bA="KHR_materials_diffuse_transmission";function PA(K,A){const T=A.subSurface;let G=null;return T.translucencyIntensityTexture?G=T.translucencyIntensityTexture:T.thicknessTexture&&T.useMaskFromThicknessTexture&&(G=T.thicknessTexture),G&&!T.useGltfStyleTextures?(R.d.Warn(`${K}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${A.name}`,1),null):G}class FA{constructor(K){this.name=bA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,A,T){const G=[];if(T instanceof bK.c&&this._isExtensionEnabled(T)){const A=PA(K,T);return A&&G.push(A),T.subSurface.translucencyColorTexture&&G.push(T.subSurface.translucencyColorTexture),G}return G}_isExtensionEnabled(K){if(K.unlit)return!1;const A=K.subSurface;return!!A.isTranslucencyEnabled&&(!K.unlit&&!A.useAlbedoToTintTranslucency&&A.useGltfStyleTextures&&1===A.volumeIndexOfRefraction&&0===A.minimumThickness&&0===A.maximumThickness)}postExportMaterialAsync(K,A,T){return new Promise((G=>{if(T instanceof bK.c&&this._isExtensionEnabled(T)){this._wasUsed=!0;const G=T.subSurface,B=PA(K,T),L=0==G.translucencyIntensity?void 0:G.translucencyIntensity,f=this._exporter._materialExporter.getTextureInfo(B)??void 0,O=!G.translucencyColor||G.translucencyColor.equalsFloats(1,1,1)?void 0:G.translucencyColor.kf(),C=this._exporter._materialExporter.getTextureInfo(G.translucencyColorTexture)??void 0,Q={diffuseTransmissionFactor:L,diffuseTransmissionTexture:f,diffuseTransmissionColorFactor:O,diffuseTransmissionColorTexture:C};(f||C)&&this._exporter._materialNeedsUVsSet.add(T),A.extensions=A.extensions||{},A.extensions[bA]=Q}G(A)}))}}iK.RegisterExtension(bA,(K=>new FA(K)));const dA="KHR_materials_dispersion";class NA{constructor(){this.name=dA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(K){if(K.unlit)return!1;const A=K.subSurface;return!(!A.isRefractionEnabled&&!A.isDispersionEnabled)}postExportMaterialAsync(K,A,T){return new Promise((K=>{if(T instanceof bK.c&&this._isExtensionEnabled(T)){this._wasUsed=!0;const K={dispersion:T.subSurface.dispersion};A.extensions=A.extensions||{},A.extensions[dA]=K}K(A)}))}}iK.RegisterExtension(dA,(()=>new NA));const DA="KHR_materials_emissive_strength";class mT{constructor(){this.name=DA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(K,A,T){return await new Promise((K=>{if(!(T instanceof bK.c))return K(A);const G=T.emissiveColor.kf(),B=Math.max(...G);if(B>1){this._wasUsed=!0,A.extensions||(A.extensions={});const K={emissiveStrength:B},G=T.emissiveColor.scale(1/K.emissiveStrength);A.emissiveFactor=G.kf(),A.extensions[DA]=K}return K(A)}))}}iK.RegisterExtension(DA,(K=>new mT));const UA="KHR_materials_ior";class zA{constructor(){this.name=UA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(K){return!K.unlit&&(void 0!=K.indexOfRefraction&&1.5!=K.indexOfRefraction)}postExportMaterialAsync(K,A,T){return new Promise((K=>{if(T instanceof bK.c&&this._isExtensionEnabled(T)){this._wasUsed=!0;const K={ior:T.indexOfRefraction};A.extensions=A.extensions||{},A.extensions[UA]=K}K(A)}))}}iK.RegisterExtension(UA,(K=>new zA));const gA="KHR_materials_iridescence";class SA{constructor(K){this.name=gA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,A,T){const G=[];return T instanceof QA.b&&T.iridescence.isEnabled?(T.iridescence.texture&&G.push(T.iridescence.texture),T.iridescence.thicknessTexture&&T.iridescence.thicknessTexture!==T.iridescence.texture&&G.push(T.iridescence.thicknessTexture),G):[]}postExportMaterialAsync(K,A,T){return new Promise((K=>{if(T instanceof QA.b){if(!T.iridescence.isEnabled)return void K(A);this._wasUsed=!0,A.extensions=A.extensions||{};const G=this._exporter._materialExporter.getTextureInfo(T.iridescence.texture),B=this._exporter._materialExporter.getTextureInfo(T.iridescence.thicknessTexture),L={iridescenceFactor:T.iridescence.VO,iridescenceIor:T.iridescence.indexOfRefraction,iridescenceThicknessMinimum:T.iridescence.minimumThickness,iridescenceThicknessMaximum:T.iridescence.maximumThickness,iridescenceTexture:G??void 0,iridescenceThicknessTexture:B??void 0};null===L.iridescenceTexture&&null===L.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(T),A.extensions[gA]=L}K(A)}))}}iK.RegisterExtension(gA,(K=>new SA(K)));const lA="KHR_materials_sheen";class uA{constructor(K){this.name=lA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,A,T){return T instanceof bK.c&&T.sheen.isEnabled&&T.sheen.texture?[T.sheen.texture]:[]}async postExportMaterialAsync(K,A,T){return await new Promise((K=>{if(T instanceof bK.c){if(!T.sheen.isEnabled)return void K(A);this._wasUsed=!0,null==A.extensions&&(A.extensions={});const G={sheenColorFactor:T.sheen.color.kf(),sheenRoughnessFactor:T.sheen.roughness??0};null===G.sheenColorTexture&&null===G.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(T),T.sheen.texture&&(G.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(T.sheen.texture)??void 0),T.sheen.textureRoughness&&!T.sheen.useRoughnessFromMainTexture?G.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(T.sheen.textureRoughness)??void 0:T.sheen.texture&&T.sheen.useRoughnessFromMainTexture&&(G.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(T.sheen.texture)??void 0),A.extensions[lA]=G}K(A)}))}}iK.RegisterExtension(lA,(K=>new uA(K)));const cA="KHR_materials_specular";class nA{constructor(K){this.name=cA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,A,T){const G=[];return T instanceof bK.c&&this._isExtensionEnabled(T)?(T.metallicReflectanceTexture&&G.push(T.metallicReflectanceTexture),T.reflectanceTexture&&G.push(T.reflectanceTexture),G):G}_isExtensionEnabled(K){return!K.unlit&&(void 0!=K.metallicF0Factor&&1!=K.metallicF0Factor||void 0!=K.metallicReflectanceColor&&!K.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(K))}_hasTexturesExtension(K){return null!=K.metallicReflectanceTexture||null!=K.reflectanceTexture}postExportMaterialAsync(K,A,T){return new Promise((K=>{if(T instanceof bK.c&&this._isExtensionEnabled(T)){this._wasUsed=!0,A.extensions=A.extensions||{};const K=this._exporter._materialExporter.getTextureInfo(T.metallicReflectanceTexture)??void 0,G=this._exporter._materialExporter.getTextureInfo(T.reflectanceTexture)??void 0,B={specularFactor:1==T.metallicF0Factor?void 0:T.metallicF0Factor,specularTexture:K,specularColorFactor:T.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:T.metallicReflectanceColor.kf(),specularColorTexture:G};this._hasTexturesExtension(T)&&this._exporter._materialNeedsUVsSet.add(T),A.extensions[cA]=B}K(A)}))}}iK.RegisterExtension(cA,(K=>new nA(K)));const HA="KHR_materials_transmission";class eA{constructor(K){this.name=HA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,A,T){const G=[];return T instanceof bK.c&&this._isExtensionEnabled(T)?(T.subSurface.thicknessTexture&&G.push(T.subSurface.thicknessTexture),G):G}_isExtensionEnabled(K){if(K.unlit)return!1;const A=K.subSurface;return A.isRefractionEnabled&&void 0!=A.refractionIntensity&&0!=A.refractionIntensity||this._hasTexturesExtension(K)}_hasTexturesExtension(K){return null!=K.subSurface.refractionIntensityTexture}async postExportMaterialAsync(K,A,T){if(T instanceof bK.c&&this._isExtensionEnabled(T)){this._wasUsed=!0;const G=T.subSurface,B={transmissionFactor:0===G.refractionIntensity?void 0:G.refractionIntensity};if(this._hasTexturesExtension(T)&&this._exporter._materialNeedsUVsSet.add(T),G.refractionIntensityTexture)if(G.useGltfStyleTextures){const K=await this._exporter._materialExporter.exportTextureAsync(G.refractionIntensityTexture,"image/png");K&&(B.transmissionTexture=K)}else R.d.Warn(`${K}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);A.extensions||(A.extensions={}),A.extensions[HA]=B}return A}}iK.RegisterExtension(HA,(K=>new eA(K)));const pA="KHR_materials_unlit";class rA{constructor(){this.name=pA,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(K,A,T){return new Promise((K=>{let G=!1;T instanceof bK.c?G=T.unlit:T instanceof PK.NA&&(G=T.disableLighting),G&&(this._wasUsed=!0,null==A.extensions&&(A.extensions={}),A.extensions[pA]={}),K(A)}))}}iK.RegisterExtension(pA,(()=>new rA));const hA="KHR_materials_volume";class kA{constructor(K){this.name=hA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,A,T){const G=[];return T instanceof bK.c&&this._isExtensionEnabled(T)?(T.subSurface.thicknessTexture&&G.push(T.subSurface.thicknessTexture),G):G}_isExtensionEnabled(K){if(K.unlit)return!1;const A=K.subSurface;return!(!A.isRefractionEnabled&&!A.isTranslucencyEnabled)&&(void 0!=A.maximumThickness&&0!=A.maximumThickness||void 0!=A.tintColorAtDistance&&A.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=A.tintColor&&A.tintColor!=F.DA.White()||this._hasTexturesExtension(K))}_hasTexturesExtension(K){return null!=K.subSurface.thicknessTexture}postExportMaterialAsync(K,A,T){return new Promise((K=>{if(T instanceof bK.c&&this._isExtensionEnabled(T)){this._wasUsed=!0;const K=T.subSurface,G={thicknessFactor:0==K.maximumThickness?void 0:K.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(K.thicknessTexture)??void 0,attenuationDistance:K.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:K.tintColorAtDistance,attenuationColor:K.tintColor.equalsFloats(1,1,1)?void 0:K.tintColor.kf()};this._hasTexturesExtension(T)&&this._exporter._materialNeedsUVsSet.add(T),A.extensions=A.extensions||{},A.extensions[hA]=G}K(A)}))}}iK.RegisterExtension(hA,(K=>new kA(K)));const sA="EXT_materials_diffuse_roughness";class jA{constructor(K){this.name=sA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,A,T){const G=[];return T instanceof QA.b&&T._baseDiffuseRoughness?(T._baseDiffuseRoughnessTexture&&G.push(T._baseDiffuseRoughnessTexture),G):[]}postExportMaterialAsync(K,A,T){return new Promise((K=>{if(T instanceof QA.b){if(!T._baseDiffuseRoughness)return void K(A);this._wasUsed=!0,A.extensions=A.extensions||{};const G=this._exporter._materialExporter.getTextureInfo(T._baseDiffuseRoughnessTexture),B={diffuseRoughnessFactor:T._baseDiffuseRoughness,diffuseRoughnessTexture:G??void 0};null!==B.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(T),A.extensions[sA]=B}K(A)}))}}iK.RegisterExtension(sA,(K=>new jA(K)));const RA="KHR_texture_transform";class vA{constructor(){this.name=RA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(K,A,T){if(T.SK()||B.Tools.Warn(`${K}: /*@__KEY__*/"scene" is not defined for Babylon texture ${T.name}!`),(0!==T.uAng||0!==T.vAng)&&(B.Tools.Warn(`${K}: Texture ${T.name} with rotation in the u or v axis is not supported in glTF.`),0!==T.uRotationCenter||0!==T.vRotationCenter))return;const G={};let L=!1;if(0===T.uOffset&&0===T.vOffset||(G.offset=[T.uOffset,T.vOffset],L=!0),1===T.uScale&&1===T.vScale||(G.scale=[T.uScale,T.vScale],L=!0),0!==T.wAng){if(0!==T.uRotationCenter||0!==T.vRotationCenter){if(T.homogeneousRotationInUVTransform&&T.uScale!==T.vScale)return void B.Tools.Warn(`${K}: Texture ${T.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${RA}.`);B.Tools.Warn(`${K}: Texture ${T.name} with non-origin rotation center will be exported using an adjusted offset with ${RA}.`),G.offset=function(K){const{uOffset:A,vOffset:T,uRotationCenter:G,vRotationCenter:B,uScale:L,vScale:f,wAng:O}=K,C=Math.cos(O),Q=Math.sin(O),Y=G*L,Z=B*f;return[A+(Y*(1-C)+Z*Q),T+(Z*(1-C)-Y*Q)]}(T)}G.rotation=-T.wAng,L=!0}0!==T.coordinatesIndex&&(G.texCoord=T.coordinatesIndex,L=!0),L&&(this._wasUsed=!0,A.extensions||(A.extensions={}),A.extensions[RA]=G)}}iK.RegisterExtension(RA,(()=>new vA));class IA{static CreateSTL(K){let A=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",B=arguments.length>3&&void 0!==arguments[3]&&arguments[3],L=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],f=arguments.length>5&&void 0!==arguments[5]&&arguments[5],O=arguments.length>6&&void 0!==arguments[6]&&arguments[6],C=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const Q=function(K,A,T){const B=[3*K[T],3*K[T+1],3*K[T+2]],L=[new G.PA(A[B[0]],A[B[0]+2],A[B[0]+1]),new G.PA(A[B[1]],A[B[1]+2],A[B[1]+1]),new G.PA(A[B[2]],A[B[2]+2],A[B[2]+1])],f=L[0].FA(L[1]),O=L[2].FA(L[1]);return{v:L,n:G.PA.Cross(O,f).normalize()}},Z=function(K,A,T,G){return A=x(K,A,T.x,G),A=x(K,A,T.y,G),x(K,A,T.z,G)},x=function(K,A,T,G){return K.setFloat32(A,T,G),A+4},b=function(K){if(O){let A=K;K instanceof J.e&&(A=K.sourceMesh);const T=A.getVerticesData(Y.d.PositionKind,!0,!0);if(!T)return[];const B=G.PA.Zero();let L;for(L=0;L<T.length;L+=3)G.PA.TransformCoordinatesFromFloatsToRef(T[L],T[L+1],T[L+2],K.wf(!0),B).toArray(T,L);return T}return K.getVerticesData(Y.d.PositionKind)||[]};O&&(f=!0);let P="",F=0,d=0;if(B){for(let T=0;T<K.length;T++){const A=K[T].Ef();F+=A?A.length/3:0}const A=new ArrayBuffer(84+50*F);P=new DataView(A),d+=80,P.setUint32(d,F,L),d+=4}else C||(P="solid stlmesh\r\n");for(let G=0;G<K.length;G++){const A=K[G];!B&&C&&(P+="solid "+A.name+"\r\n"),!f&&A instanceof NK.e&&A.bakeCurrentTransformIntoVertices();const T=b(A),O=A.Ef()||[];for(let K=0;K<O.length;K+=3){const A=Q(O,T,K);B?(d=Z(P,d,A.n,L),d=Z(P,d,A.v[0],L),d=Z(P,d,A.v[1],L),d=Z(P,d,A.v[2],L),d+=2):(P+="\tfacet normal "+A.n.x+" "+A.n.y+" "+A.n.z+"\r\n",P+="\t\touter loop\r\n",P+="\t\t\tvertex "+A.v[0].x+" "+A.v[0].y+" "+A.v[0].z+"\r\n",P+="\t\t\tvertex "+A.v[1].x+" "+A.v[1].y+" "+A.v[1].z+"\r\n",P+="\t\t\tvertex "+A.v[2].x+" "+A.v[2].y+" "+A.v[2].z+"\r\n",P+="\t\tendloop\r\n",P+="\tendfacet\r\n")}!B&&C&&(P+="endsolid "+name+"\r\n")}if(B||C||(P+="endsolid stlmesh"),A){const K=document.createElement("a"),A=new Blob([P],{type:"application/octet-stream"});K.href=window.URL.createObjectURL(A),K.download=T+".stl",K.click()}return P}}function oA(K,A){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const G=[];for(let B=0;B<K.length/T;B++){const L=K[B*T],f=K[B*T+1],O=K[B*T+2];G.push(`(${L.toPrecision(A.precision)}, ${f.toPrecision(A.precision)}, ${O.toPrecision(A.precision)})`)}return G.join(", ")}function WA(K,A){const T=[];for(let G=0;G<K.length/2;G++){const B=K[2*G],L=K[2*G+1];T.push(`(${B.toPrecision(A.precision)}, ${(1-L).toPrecision(A.precision)})`)}return T.join(", ")}function iA(K,A){const T=K.getVerticesData(Y.d.PositionKind),G=K.getVerticesData(Y.d.NormalKind);if(T&&G)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(K){var A;const T=null!==(A=K.Ef())&&void 0!==A&&A.length?K.getTotalIndices():K.getTotalVertices();return Array(T/3).fill(3).join(", ")}(K)}]\n\t\tint[] faceVertexIndices = [${function(K){const A=K.Ef(),T=[];if(null!==A)for(let G=0;G<A.length;G++)T.push(A[G]);else{const A=K.getTotalVertices();for(let K=0;K<A;K++)T.push(K)}return T.join(", ")}(K)}]\n\t\tnormal3f[] normals = [${oA(G,A)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${oA(T,A)}]\n        ${function(K,A){let T="";for(let B=0;B<4;B++){const G=B>0?B:"",L=K.getVerticesData(Y.d.UVKind+(G?G+1:""));L&&(T+=`\n\t\ttexCoord2f[] primvars:st${G} = [${WA(L,A)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const G=K.getVerticesData(Y.d.ColorKind);return G&&(T+=`\n\tcolor3f[] primvars:displayColor = [${oA(G,A,G.length/K.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),T}(K,A)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function VA(K,A){return`\n        def "Geometry"\n        {\n        ${iA(K,A)}\n        }\n        `}function XA(K){let A='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return A+=K,fflate.strToU8(A)}function qA(K){const A=K.m;return`( ${yA(A,0)}, ${yA(A,4)}, ${yA(A,8)}, ${yA(A,12)} )`}function yA(K,A){return`(${K[A+0]}, ${K[A+1]}, ${K[A+2]}, ${K[A+3]})`}function wA(K){const A="Object_"+K.uniqueId,T=function(K){const A=K.getWorldMatrix().clone(),T=K.SK().useRightHandedSystem;if(!T){let G=K.parent;for(;G;){if(fK(G,T)){A.multiplyToRef(G.getWorldMatrix().invert(),A);break}G=G.parent}}return A.determinant()<0&&B.Tools.Warn(`Exporting mesh ${K.name} with negative scale. Result may look incorrect in destination engine.`),A}(K),G=qA(T);return`def Xform "${A}" (\n\tprepend references = @./geometries/Geometry_${K.Mf.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${G}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${K.material.uniqueId}>\n}\n\n`}function aA(K){switch(K){case g.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case g.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case g.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function MA(K){return`(${K.x}, ${K.y})`}function EA(K){return`(${K.r}, ${K.g}, ${K.b})`}function tA(K,A,T,B,L,f){const O=K.getInternalTexture().uniqueId+"_"+K.invertY;L[O]=K;const C=K.coordinatesIndex>0?"st"+K.coordinatesIndex:"st",Q=new G.Vector2(K.uScale,K.vScale),Y=new G.Vector2(K.uOffset,K.vOffset),Z=K.wAng,x=Math.sin(Z),J=Math.cos(Z);return Y.y=1-Y.y-Q.y,Y.x+=x*Q.x,Y.y+=(1-J)*Q.y,`\n    def Shader "PrimvarReader_${T}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${C}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${T}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${A.uniqueId}/PrimvarReader_${T}.outputs:result>\n        float inputs:rotation = ${(Z*(180/Math.PI)).toFixed(f.precision)}\n        float2 inputs:scale = ${MA(Q)}\n        float2 inputs:translation = ${MA(Y)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${K.uniqueId}_${T}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${O}.png@\n        float2 inputs:st.connect = </Materials/Material_${A.uniqueId}/Transform2d_${T}.outputs:result>\n        ${B?"float4 inputs:scale = "+function(K){return`(${K.r}, ${K.g}, ${K.b}, 1.0)`}(B):""}\n        token inputs:sourceColorSpace = "${K.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${aA(K.wrapU)}"\n        token inputs:wrapT = "${aA(K.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${A.needAlphaBlending()?"float outputs:a":""}\n    }`}function KT(K,A,T){const G="\t\t\t",B=[],L=[],{diffuseMap:f,XO:O,alphaCutOff:C,emissiveMap:Q,emissive:Y,normalMap:Z,roughnessMap:x,roughnessChannel:J,roughness:b,metalnessMap:P,metalnessChannel:d,metalness:N,aoMap:D,aoMapChannel:mK,aoMapIntensity:U,alphaMap:z,ior:g,clearCoatEnabled:S,clearCoat:l,clearCoatMap:u,clearCoatRoughness:c,clearCoatRoughnessMap:n}=function(K){const A={diffuseMap:null,XO:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return K instanceof PK.NA?{...A,diffuseMap:K.diffuseTexture,XO:K.diffuseColor,alphaCutOff:K.alphaCutOff,emissiveMap:K.emissiveTexture,emissive:K.emissiveColor,roughness:1,alphaMap:K.opacityTexture}:K instanceof QA.b?{...A,diffuseMap:K._albedoTexture,XO:K._albedoColor,alphaCutOff:K._alphaCutOff,emissiveMap:K._emissiveTexture,emissive:K._emissiveColor,normalMap:K._bumpTexture,roughnessMap:K._metallicTexture,roughnessChannel:K._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:K._roughness??1,metalnessMap:K._metallicTexture,metalnessChannel:K._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:K._metallic??0,aoMap:K._ambientTexture,aoMapChannel:K._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:K._ambientTextureStrength,alphaMap:K._opacityTexture,ior:K.subSurface.indexOfRefraction,clearCoatEnabled:K.clearCoat.isEnabled,clearCoat:K.clearCoat.VO,clearCoatMap:K.clearCoat.texture,clearCoatRoughness:K.clearCoat.roughness,clearCoatRoughnessMap:K.clearCoat.useRoughnessFromMainTexture?K.clearCoat.texture:K.clearCoat.textureRoughness}:A}(K);return null!==f?(B.push(`${G}color3f inputs:diffuseColor.connect = </Materials/Material_${K.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:rgb>`),K.needAlphaBlending()?B.push(`${G}float inputs:opacity.connect = </Materials/Material_${K.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:a>`):K.needAlphaTesting()&&(B.push(`${G}float inputs:opacity.connect = </Materials/Material_${K.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:a>`),B.push(`${G}float inputs:opacityThreshold = ${C}`)),L.push(tA(f,K,"diffuse",O,A,T))):B.push(`${G}color3f inputs:diffuseColor = ${EA(O||F.DA.White())}`),null!==Q?(B.push(`${G}color3f inputs:emissiveColor.connect = </Materials/Material_${K.uniqueId}/Texture_${Q.uniqueId}_emissive.outputs:rgb>`),L.push(tA(Q,K,"emissive",Y,A,T))):Y&&Y.toLuminance()>0&&B.push(`${G}color3f inputs:emissiveColor = ${EA(Y)}`),null!==Z&&(B.push(`${G}normal3f inputs:normal.connect = </Materials/Material_${K.uniqueId}/Texture_${Z.uniqueId}_normal.outputs:rgb>`),L.push(tA(Z,K,"normal",null,A,T))),null!==D&&(B.push(`${G}float inputs:occlusion.connect = </Materials/Material_${K.uniqueId}/Texture_${D.uniqueId}_occlusion.outputs:${mK}>`),L.push(tA(D,K,"occlusion",new F.DA(U,U,U),A,T))),null!==x?(B.push(`${G}float inputs:roughness.connect = </Materials/Material_${K.uniqueId}/Texture_${x.uniqueId}_roughness.outputs:${J}>`),L.push(tA(x,K,"roughness",new F.DA(b,b,b),A,T))):B.push(`${G}float inputs:roughness = ${b}`),null!==P?(B.push(`${G}float inputs:metallic.connect = </Materials/Material_${K.uniqueId}/Texture_${P.uniqueId}_metallic.outputs:${d}>`),L.push(tA(P,K,"metallic",new F.DA(N,N,N),A,T))):B.push(`${G}float inputs:metallic = ${N}`),null!==z?(B.push(`${G}float inputs:opacity.connect = </Materials/Material_${K.uniqueId}/Texture_${z.uniqueId}_opacity.outputs:r>`),B.push(`${G}float inputs:opacityThreshold = 0.0001`),L.push(tA(z,K,"opacity",null,A,T))):B.push(`${G}float inputs:opacity = ${K.alpha}`),S&&(null!==u?(B.push(`${G}float inputs:clearcoat.connect = </Materials/Material_${K.uniqueId}/Texture_${u.uniqueId}_clearcoat.outputs:r>`),L.push(tA(u,K,"clearcoat",new F.DA(l,l,l),A,T))):B.push(`${G}float inputs:clearcoat = ${l}`),null!==n?(B.push(`${G}float inputs:clearcoatRoughness.connect = </Materials/Material_${K.uniqueId}/Texture_${n.uniqueId}_clearcoatRoughness.outputs:g>`),L.push(tA(n,K,"clearcoatRoughness",new F.DA(c,c,c),A,T))):B.push(`${G}float inputs:clearcoatRoughness = ${c}`)),B.push(`${G}float inputs:ior = ${g}`),`\n\tdef Material "Material_${K.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${B.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${K.uniqueId}/PreviewSurface.outputs:surface>\n\n${L.join("\n")}\n\n\t}\n`}async function AT(K,A,T){const L={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...A};"undefined"===typeof fflate&&await B.Tools.LoadScriptAsync(L.fflateUrl);const f={};f[L.modelFileName]=null;let O='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';O+=function(K){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===K.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${K.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${K.planeAnchoringAlignment}"`:""}\n            `}(L);const C={};for(const G of K.meshes){if(0===G.getTotalVertices())continue;const K=G,A=K.Mf,Q=K.material;if(!Q||!A||T&&!T(K))continue;if(-1!==["NA","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(Q.getClassName())){const T="geometries/Geometry_"+A.uniqueId+".usda";if(!(T in f)){const K=VA(A,L);f[T]=XA(K)}Q.uniqueId in C||(C[Q.uniqueId]=Q),O+=wA(K)}else B.Tools.Warn("USDZExportAsync does not support this material type: "+Q.getClassName())}K.activeCamera&&L.exportCamera&&(O+=function(K,A){const T="Camera_"+K.uniqueId,B=qA(G.Matrix.RotationY(Math.PI).multiply(K.getWorldMatrix()));if(K.mode===g.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${T}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${B}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${K.If.toPrecision(A.precision)}, ${K.maxZ.toPrecision(A.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(K.orthoLeft||1)+Math.abs(K.orthoRight||1))).toPrecision(A.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(K.orthoTop||1)+Math.abs(K.orthoBottom||1))).toPrecision(A.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const G=K.getEngine().getAspectRatio(K),L=A.cameraSensorWidth||35;return`def Camera "${T}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${B}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${K.If.toPrecision(A.precision)}, ${K.maxZ.toPrecision(A.precision)})\n\t\t\tfloat focalLength = ${(L/(2*Math.tan(.5*K.fov))).toPrecision(A.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(L*G).toPrecision(A.precision)}\n\t\t\tfloat verticalAperture = ${(L/G).toPrecision(A.precision)}            \n\t\t}\n\t\n\t`}}(K.activeCamera,L)),O+="\n            }\n        }\n    }";const Q={};O+=function(K,A,T){const G=[];for(const B in K){const L=K[B];G.push(KT(L,A,T))}return`\n    def "Materials"\n{\n${G.join("")}\n}\n\n`}(C,Q,L),f[L.modelFileName]=fflate.strToU8(O);for(const G in Q){const K=Q[G],A=K.getSize(),T=await K.readPixels();if(!T)throw new Error("Texture data is not available");const B=await S.DumpTools.DumpDataAsync(A.width,A.height,T,"image/png",void 0,!1,!0);f[`textures/Texture_${G}.png`]=new Uint8Array(B).slice()}let Y=0;for(const G in f){const K=f[G];if(!K)continue;Y+=34+G.length;const A=63&Y;if(4!==A){const T=new Uint8Array(64-A);f[G]=[K,{extra:{12345:T}}]}Y=K.length}return fflate.zipSync(f,{level:0})}}}]);