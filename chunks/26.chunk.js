"use strict";(self.vb3rpbgyozo=self.vb3rpbgyozo||[]).push([[26],{13160:(q,I,l)=>{l.r(I),l.d(I,{EXT_materials_diffuse_roughness:()=>EI,EXT_mesh_gpu_instancing:()=>Nq,GLTF2Export:()=>yq,GLTFData:()=>s,KHR_draco_mesh_compression:()=>lI,KHR_lights_punctual:()=>FI,KHR_materials_anisotropy:()=>rI,KHR_materials_clearcoat:()=>oI,KHR_materials_diffuse_transmission:()=>VI,KHR_materials_dispersion:()=>BI,KHR_materials_emissive_strength:()=>kI,KHR_materials_ior:()=>RI,KHR_materials_iridescence:()=>eI,KHR_materials_sheen:()=>SI,KHR_materials_specular:()=>pI,KHR_materials_transmission:()=>KI,KHR_materials_unlit:()=>MI,KHR_materials_volume:()=>fI,KHR_texture_transform:()=>hI,OBJExport:()=>c,STLExport:()=>uI,USDZExportAsync:()=>Il,_ConvertToGLTFPBRMetallicRoughness:()=>D,_SolveMetallic:()=>K,__IGLTFExporterExtension:()=>a});var w=l(12747),t=l(12564),O=l(13074);class c{static OBJ(q,I,l,c){const a=[];let F=1,s=1;I&&(l||(l="mat"),a.push("mtllib "+l+".mtl"));for(let Z=0;Z<q.length;Z++){const l=q[Z],r=l.name||`mesh${Z}}`;a.push(`o ${r}`);let x=null;if(c){const q=l.Cc(!0);x=new w.Matrix,q.invertToRef(x),l.bakeTransformIntoVertices(q)}if(I){const q=l.material;q&&a.push("usemtl "+q.id)}const o=l.Wc;if(!o){t.Tools.Warn("No geometry is present on the mesh");continue}const d=o.getVerticesData("position"),T=o.getVerticesData("normal"),V=o.getVerticesData("uv"),U=o.ec();let B=0,v=0;if(!d||!U){t.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const k=q[0].Wq().useRightHandedSystem?1:-1;for(let q=0;q<d.length;q+=3)a.push("v "+d[q]*k+" "+d[q+1]+" "+d[q+2]),B++;if(null!=T)for(let q=0;q<T.length;q+=3)a.push("vn "+T[q]*k+" "+T[q+1]+" "+T[q+2]);if(null!=V)for(let q=0;q<V.length;q+=2)a.push("vt "+V[q]+" "+V[q+1]),v++;const C=["","",""],R=(l.material||l.Wq().defaultMaterial)._getEffectiveOrientation(l),[W,e]=R===O.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let q=0;q<U.length;q+=3){const I=[String(U[q]+F),String(U[q+W]+F),String(U[q+e]+F)],l=[String(U[q]+s),String(U[q+W]+s),String(U[q+e]+s)],w=I,t=null!=V?l:C,O=null!=T?I:C;a.push("f "+w[0]+"/"+t[0]+"/"+O[0]+" "+w[1]+"/"+t[1]+"/"+O[1]+" "+w[2]+"/"+t[2]+"/"+O[2])}c&&x&&l.bakeTransformIntoVertices(x),F+=B,s+=v}return a.join("\n")}static MTL(q){const I=[],l=q.material;I.push("newmtl mat1"),I.push("  Ns "+l.specularPower.toFixed(4)),I.push("  Ni 1.5000"),I.push("  d "+l.alpha.toFixed(4)),I.push("  Tr 0.0000"),I.push("  Tf 1.0000 1.0000 1.0000"),I.push("  illum 2"),I.push("  Ka "+l.ambientColor.r.toFixed(4)+" "+l.ambientColor.g.toFixed(4)+" "+l.ambientColor.b.toFixed(4)),I.push("  Kd "+l.diffuseColor.r.toFixed(4)+" "+l.diffuseColor.g.toFixed(4)+" "+l.diffuseColor.b.toFixed(4)),I.push("  Ks "+l.specularColor.r.toFixed(4)+" "+l.specularColor.g.toFixed(4)+" "+l.specularColor.b.toFixed(4)),I.push("  Ke "+l.emissiveColor.r.toFixed(4)+" "+l.emissiveColor.g.toFixed(4)+" "+l.emissiveColor.b.toFixed(4));l.ambientTexture&&I.push("  map_Ka "+l.ambientTexture.name),l.diffuseTexture&&I.push("  map_Kd "+l.diffuseTexture.name),l.specularTexture&&I.push("  map_Ks "+l.specularTexture.name),l.bumpTexture&&I.push("  map_bump -imfchan z "+l.bumpTexture.name),l.opacityTexture&&I.push("  map_d "+l.opacityTexture.name);return I.join("\n")}}var a=0,F=l(12615);class s{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const q in this.files){const I=this.files[q],l=new Blob([I],{type:(0,F.i)(q)});t.Tools.Download(l,q)}}}var Z=l(12821),r=l(13166),x=l(13173),o=l(13180),d=l(12875),T=l(12612),V=l(12789),U=l(12761);const B=U.HighestCommonFactor,v={...U,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:B};var k=l(12975),C=l(12733),R=l(13206),W=l(13208),e=l(12972);const i=1e-6,S=new V.BI(.04,.04,.04),g=1024,p=V.BI.White(),X=V.BI.Black();function K(q,I,l){if(I<S.r)return 0;const w=S.r,t=q*l/(1-S.r)+I-2*S.r,O=t*t-4*w*(S.r-I);return v.Clamp((-t+Math.sqrt(O))/(2*w),0,1)}function D(q){const I=q.diffuseColor.toLinearSpace(q.Wq().getEngine().useExactSrgbConversions).scale(.5),l=q.alpha,t=function(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new w.Vector2(0,1),l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new w.Vector2(0,.1),t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new w.Vector2(0,.1),O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new w.Vector2(1300,.1);return function(q,I,l,w,t){return(1-q)*(1-q)*(1-q)*I+3*(1-q)*(1-q)*q*l+3*(1-q)*q*q*w+q*q*q*t}(Math.pow(q/O.x,.333333),I.y,l.y,t.y,O.y)}(v.Clamp(q.specularPower,0,g));return{baseColorFactor:[I.r,I.g,I.b,l],metallicFactor:0,roughnessFactor:t}}function M(q,I){I.needAlphaBlending()?q.alphaMode="BLEND":I.needAlphaTesting()&&(q.alphaMode="MASK",q.alphaCutoff=I.alphaCutOff)}function n(q,I,l){const w=new Uint8Array(q*I*4);for(let t=0;t<w.length;t+=4)w[t]=w[t+1]=w[t+2]=w[t+3]=255;return R.d.CreateRGBATexture(w,q,I,l)}function f(q){if(q instanceof Uint8Array){const I=q.length,l=new Float32Array(q.length);for(let w=0;w<I;++w)l[w]=q[w]/255;return l}if(q instanceof Float32Array)return q;throw new Error("Unsupported pixel format!")}class L{constructor(q){this._exporter=q,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(q){return q?this._textureMap.get(q)??null:null}async exportStandardMaterialAsync(q,I,l){const w=D(q),O={name:q.name};if(null==q.Sc||q.Sc||(q.twoSidedLighting||t.Tools.Warn(q.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),O.doubleSided=!0),l){const l=[],t=q.diffuseTexture;t&&l.push(this.exportTextureAsync(t,I).then((q=>{q&&(w.baseColorTexture=q)})));const c=q.bumpTexture;c&&l.push(this.exportTextureAsync(c,I).then((q=>{q&&(O.normalTexture=q,1!==c.level&&(O.normalTexture.scale=c.level))})));const a=q.emissiveTexture;a&&(O.emissiveFactor=[1,1,1],l.push(this.exportTextureAsync(a,I).then((q=>{q&&(O.emissiveTexture=q)}))));const F=q.ambientTexture;F&&l.push(this.exportTextureAsync(F,I).then((q=>{if(q){const I={index:q.index};O.occlusionTexture=I}}))),l.length>0&&(this._exporter._materialNeedsUVsSet.add(q),await Promise.all(l))}(q.alpha<1||q.opacityTexture)&&(q.alphaMode===W.c.ALPHA_COMBINE?O.alphaMode="BLEND":t.Tools.Warn(q.name+": glTF 2.0 does not support alpha mode: "+q.alphaMode.toString())),q.emissiveColor&&!q.emissiveColor.equalsWithEpsilon(X,i)&&(O.emissiveFactor=q.emissiveColor.Uc()),O.pbrMetallicRoughness=w,M(O,q),await this._finishMaterialAsync(O,q,I);const c=this._exporter._materials;return c.push(O),c.length-1}async _finishMaterialAsync(q,I,l){const w=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",q,I),t=[];for(const O of w)t.push(this.exportTextureAsync(O,l));await Promise.all(t),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",q,I)}async _getImageDataAsync(q,I,w,t){const O=W.c.TEXTURETYPE_UNSIGNED_BYTE,c=this._exporter._babylonScene,a=c.getEngine(),F=a.createRawTexture(q,I,w,W.c.TEXTUREFORMAT_RGBA,!1,!0,C.d.NEAREST_SAMPLINGMODE,null,O);a.isWebGPU?await l.e(51).then(l.bind(l,15224)):await l.e(52).then(l.bind(l,15229)),await k.i.ApplyPostProcess("pass",F,c,O,W.c.TEXTURE_NEAREST_SAMPLINGMODE,W.c.TEXTUREFORMAT_RGBA);const s=await a._readTexturePixels(F,I,w);return await e.DumpTools.DumpDataAsync(I,w,s,t,void 0,!0,!0)}_resizeTexturesToSameDimensions(q,I,l){const w=q?q.getSize():{width:0,height:0},t=I?I.getSize():{width:0,height:0};let O,c;return w.width<t.width?(O=q&&q instanceof C.d?k.i.CreateResizedCopy(q,t.width,t.height,!0):n(t.width,t.height,l),c=I):w.width>t.width?(c=I&&I instanceof C.d?k.i.CreateResizedCopy(I,w.width,w.height,!0):n(w.width,w.height,l),O=q):(O=q,c=I),{texture1:O,texture2:c}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(q,I,l,w){const t=new Array;if(!q&&!I)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const O=q?q.Wq():I?I.Wq():null;if(O){var c;const a=this._resizeTexturesToSameDimensions(q,I,O),F=null===(c=a.texture1)||void 0===c?void 0:c.getSize();let s,Z;const r=F.width,x=F.height,o=await a.texture1.readPixels(),d=await a.texture2.readPixels();if(!o)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(s=f(o),!d)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");Z=f(d);const T=Z.byteLength,U=new Uint8Array(T),B=new Uint8Array(T),v=4,k=X;let C=0,R=0;for(let q=0;q<x;++q)for(let I=0;I<r;++I){const w=(r*q+I)*v,t={diffuseColor:new V.BI(s[w],s[w+1],s[w+2]).toLinearSpace(O.getEngine().useExactSrgbConversions).multiply(l.diffuseColor),specularColor:new V.BI(Z[w],Z[w+1],Z[w+2]).toLinearSpace(O.getEngine().useExactSrgbConversions).multiply(l.specularColor),glossiness:Z[w+3]*l.glossiness},c=this._convertSpecularGlossinessToMetallicRoughness(t);k.r=Math.max(k.r,c.baseColor.r),k.g=Math.max(k.g,c.baseColor.g),k.b=Math.max(k.b,c.baseColor.b),C=Math.max(C,c.metallic),R=Math.max(R,c.roughness),B[w]=255*c.baseColor.r,B[w+1]=255*c.baseColor.g,B[w+2]=255*c.baseColor.b,B[w+3]=a.texture1.Bc?255*s[w+3]:255,U[w]=0,U[w+1]=255*c.roughness,U[w+2]=255*c.metallic,U[w+3]=255}const W={baseColor:k,metallic:C,roughness:R};let e=!1,S=!1;for(let q=0;q<x;++q)for(let I=0;I<r;++I){const l=(r*q+I)*v;B[l]/=W.baseColor.r>i?W.baseColor.r:1,B[l+1]/=W.baseColor.g>i?W.baseColor.g:1,B[l+2]/=W.baseColor.b>i?W.baseColor.b:1;const w=V.BI.FromInts(B[l],B[l+1],B[l+2]).toGammaSpace(O.getEngine().useExactSrgbConversions);B[l]=255*w.r,B[l+1]=255*w.g,B[l+2]=255*w.b,w.equalsWithEpsilon(p,i)||(S=!0),U[l+1]/=W.roughness>i?W.roughness:1,U[l+2]/=W.metallic>i?W.metallic:1;V.BI.FromInts(255,U[l+1],U[l+2]).equalsWithEpsilon(p,i)||(e=!0)}return e&&t.push(this._getImageDataAsync(U,r,x,w).then((q=>{W.metallicRoughnessTextureData=q}))),S&&t.push(this._getImageDataAsync(B,r,x,w).then((q=>{W.baseColorTextureData=q}))),await Promise.all(t).then((()=>W))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(q){const I=this._getPerceivedBrightness(q.diffuseColor),l=this._getPerceivedBrightness(q.specularColor),w=1-this._getMaxComponent(q.specularColor),t=K(I,l,w),O=q.diffuseColor.scale(w/(1-S.r)/Math.max(1-t)),c=q.specularColor.TI(S.scale(1-t)).scale(1/Math.max(t));let a=V.BI.Lerp(O,c,t*t);a=a.clampToRef(0,1,a);return{baseColor:a,metallic:t,roughness:1-q.glossiness}}_getPerceivedBrightness(q){return q?Math.sqrt(.299*q.r*q.r+.587*q.g*q.g+.114*q.b*q.b):0}_getMaxComponent(q){return q?Math.max(q.r,Math.max(q.g,q.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(q,I,l,w){const t=[],O={baseColor:q._albedoColor,metallic:q._metallic,roughness:q._roughness};if(w){q._albedoTexture&&t.push(this.exportTextureAsync(q._albedoTexture,I).then((q=>{q&&(l.baseColorTexture=q)})));const w=q._metallicTexture;w&&t.push(this.exportTextureAsync(w,I).then((q=>{q&&(l.metallicRoughnessTexture=q)})))}return t.length>0&&(this._exporter._materialNeedsUVsSet.add(q),await Promise.all(t)),O}_getTextureSampler(q){const I={};if(!q||!(q instanceof C.d))return I;const l=this._getGLTFTextureWrapMode(q.wrapU);10497!==l&&(I.wrapS=l);const w=this._getGLTFTextureWrapMode(q.wrapV);switch(10497!==w&&(I.wrapT=w),q.samplingMode){case C.d.LINEAR_LINEAR:I.magFilter=9729,I.minFilter=9729;break;case C.d.LINEAR_NEAREST:I.magFilter=9729,I.minFilter=9728;break;case C.d.NEAREST_LINEAR:I.magFilter=9728,I.minFilter=9729;break;case C.d.NEAREST_LINEAR_MIPLINEAR:I.magFilter=9728,I.minFilter=9987;break;case C.d.NEAREST_NEAREST:I.magFilter=9728,I.minFilter=9728;break;case C.d.NEAREST_LINEAR_MIPNEAREST:I.magFilter=9728,I.minFilter=9985;break;case C.d.LINEAR_NEAREST_MIPNEAREST:I.magFilter=9729,I.minFilter=9984;break;case C.d.LINEAR_NEAREST_MIPLINEAR:I.magFilter=9729,I.minFilter=9986;break;case C.d.NEAREST_NEAREST_MIPLINEAR:I.magFilter=9728,I.minFilter=9986;break;case C.d.LINEAR_LINEAR_MIPLINEAR:I.magFilter=9729,I.minFilter=9987;break;case C.d.LINEAR_LINEAR_MIPNEAREST:I.magFilter=9729,I.minFilter=9985;break;case C.d.NEAREST_NEAREST_MIPNEAREST:I.magFilter=9728,I.minFilter=9984}return I}_getGLTFTextureWrapMode(q){switch(q){case C.d.WRAP_ADDRESSMODE:return 10497;case C.d.CLAMP_ADDRESSMODE:return 33071;case C.d.MIRROR_ADDRESSMODE:return 33648;default:return t.Tools.Error(`Unsupported Texture Wrap Mode ${q}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(q,I,l,w){const t={diffuseColor:q._albedoColor,specularColor:q._reflectivityColor,glossiness:q._microSurface},O=q._albedoTexture,c=q._reflectivityTexture,a=q._useMicroSurfaceFromReflectivityMapAlpha;if(c&&!a)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((O||c)&&w){this._exporter._materialNeedsUVsSet.add(q);const w=this._exportTextureSampler(O||c),a=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(O,c,t,I),F=this._exporter._textures;if(a.baseColorTextureData){const q=this._exportImage(`baseColor${F.length}`,I,a.baseColorTextureData);l.baseColorTexture=this._exportTextureInfo(q,w,null===O||void 0===O?void 0:O.coordinatesIndex)}if(a.metallicRoughnessTextureData){const q=this._exportImage(`metallicRoughness${F.length}`,I,a.metallicRoughnessTextureData);l.metallicRoughnessTexture=this._exportTextureInfo(q,w,null===c||void 0===c?void 0:c.coordinatesIndex)}return a}return this._convertSpecularGlossinessToMetallicRoughness(t)}async exportPBRMaterialAsync(q,I,l){const w={},t={name:q.name},O=q.isMetallicWorkflow();if(O){const I=q._albedoColor,l=q.alpha;I&&(w.baseColorFactor=[I.r,I.g,I.b,l])}const c=O?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(q,I,w,l):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(q,I,w,l);await this._setMetallicRoughnessPbrMaterialAsync(c,q,t,w,I,l),await this._finishMaterialAsync(t,q,I);const a=this._exporter._materials;return a.push(t),a.length-1}async _setMetallicRoughnessPbrMaterialAsync(q,I,l,w,O,c){if(M(l,I),q.baseColor.equalsWithEpsilon(p,i)&&v.WithinEpsilon(I.alpha,1,i)||(w.baseColorFactor=[q.baseColor.r,q.baseColor.g,q.baseColor.b,I.alpha]),null!=q.metallic&&1!==q.metallic&&(w.metallicFactor=q.metallic),null!=q.roughness&&1!==q.roughness&&(w.roughnessFactor=q.roughness),null==I.Sc||I.Sc||(I._twoSidedLighting||t.Tools.Warn(I.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),l.doubleSided=!0),c){const q=[],w=I._bumpTexture;w&&q.push(this.exportTextureAsync(w,O).then((q=>{q&&(l.normalTexture=q,1!==w.level&&(l.normalTexture.scale=w.level))})));const t=I._ambientTexture;t&&q.push(this.exportTextureAsync(t,O).then((q=>{if(q){const w={index:q.index,texCoord:q.texCoord,extensions:q.extensions};l.occlusionTexture=w;const t=I._ambientTextureStrength;t&&(w.strength=t)}})));const c=I._emissiveTexture;c&&q.push(this.exportTextureAsync(c,O).then((q=>{q&&(l.emissiveTexture=q)}))),q.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(q))}const a=I._emissiveColor;a.equalsWithEpsilon(X,i)||(l.emissiveFactor=a.Uc()),l.pbrMetallicRoughness=w}_getPixelsFromTextureAsync(q){return function(q){switch(q){case W.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case W.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case W.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case W.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case W.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case W.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case W.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case W.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case W.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case W.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case W.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case W.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case W.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case W.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case W.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case W.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case W.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case W.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case W.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case W.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case W.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(q.textureFormat)?(0,k.g)(q,q._texture.width,q._texture.height):(q.textureType,W.c.TEXTURETYPE_UNSIGNED_BYTE,q.readPixels())}async exportTextureAsync(q,I){const l=this._exporter._extensionsPreExportTextureAsync("exporter",q,I);return l?await l.then((async l=>l?await this._exportTextureInfoAsync(l,I):await this._exportTextureInfoAsync(q,I))):await this._exportTextureInfoAsync(q,I)}async _exportTextureInfoAsync(q,I){let l=this._textureMap.get(q);if(!l){const w=await this._getPixelsFromTextureAsync(q);if(!w)return null;const O=this._exportTextureSampler(q),c=q.mimeType;if(c)switch(c){case"image/jpeg":case"image/png":case"image/webp":I=c;break;default:t.Tools.Warn(`Unsupported media type: ${c}. Exporting texture as PNG.`)}const a=this._internalTextureToImage,F=q.getInternalTexture().uniqueId;a[F]||(a[F]={});let s=a[F][I];if(void 0===s){const l=q.getSize();s=(async()=>{const t=await this._getImageDataAsync(w,l.width,l.height,I);return this._exportImage(q.name,I,t)})(),a[F][I]=s}l=this._exportTextureInfo(await s,O,q.coordinatesIndex),this._textureMap.set(q,l),this._exporter._extensionsPostExportTextures("exporter",l,q)}return l}_exportImage(q,I,l){const w=this._exporter._images;let O;if(this._exporter._shouldUseGlb){O={name:q,mimeType:I,bufferView:void 0};const w=this._exporter._bufferManager.createBufferView(new Uint8Array(l));this._exporter._bufferManager.setBufferView(O,w)}else{const c=q.replace(/\.\/|\/|\.\\|\\/g,"_"),a=function(q){switch(q){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(I);let F=c+a;w.some((q=>q.uri===F))&&(F=`${c}_${t.Tools.RandomId()}${a}`),O={name:q,uri:F},this._exporter._imageData[F]={data:l,mimeType:I}}return w.push(O),w.length-1}_exportTextureInfo(q,I,l){const w=this._exporter._textures;let t=w.findIndex((l=>l.sampler==I&&l.source===q));-1===t&&(t=w.length,w.push({source:q,sampler:I}));const O={index:t};return l&&(O.texCoord=l),O}_exportTextureSampler(q){const I=this._getTextureSampler(q),l=this._exporter._samplers,w=l.findIndex((q=>q.minFilter===I.minFilter&&q.magFilter===I.magFilter&&q.wrapS===I.wrapS&&q.wrapT===I.wrapT));return-1!==w?w:(l.push(I),l.length-1)}}var E=l(12830),j=l(12591),h=l(13211),u=l(12752);const P=w.dI.Zero(),mq=w.Quaternion.Identity(),Y=w.dI.One(),y=new w.dI(-1,1,1);function G(q,I){const{byteOffset:l,byteStride:w,type:t,normalized:O}=q,c=q.getSize(),a=I.reduce(((q,I)=>I.getTotalVertices()>q?I.getTotalVertices():q),-Number.MAX_VALUE);return{byteOffset:l,byteStride:w,componentCount:c,type:t,count:a*c,normalized:O,totalVertices:a,kind:q.getKind()}}function N(q){switch(q){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function J(q){switch(q){case Z.c.PositionKind:case Z.c.NormalKind:case Z.c.TangentKind:case Z.c.ColorKind:case Z.c.MatricesIndicesKind:case Z.c.MatricesIndicesExtraKind:case Z.c.MatricesWeightsKind:case Z.c.MatricesWeightsExtraKind:case Z.c.UVKind:case Z.c.UV2Kind:case Z.c.UV3Kind:case Z.c.UV4Kind:case Z.c.UV5Kind:case Z.c.UV6Kind:return!0}return!1}function z(q){switch(q){case O.c.TriangleFillMode:return 4;case O.c.TriangleStripDrawMode:return 5;case O.c.TriangleFanDrawMode:return 6;case O.c.PointListDrawMode:case O.c.PointFillMode:return 0;case O.c.LineLoopDrawMode:return 2;case O.c.LineListDrawMode:return 1;case O.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${q}`)}function H(q){const I=Math.sqrt(q.x*q.x+q.y*q.y+q.z*q.z);I>0&&(q.x/=I,q.y/=I,q.z/=I)}function A(q){return q.x*=-1,q}function Q(q){if(q.x*q.x+q.y*q.y>.5){const I=Math.abs(q.x),l=Math.abs(q.y);if(I>l){const l=Math.sign(q.x);q.x=I,q.y*=-l,q.z*=-l,q.w*=l}else{const I=Math.sign(q.y);q.x*=-I,q.y=l,q.z*=I,q.w*=-I}}else{const I=Math.abs(q.z),l=Math.abs(q.w);if(I>l){const l=Math.sign(q.z);q.x*=-l,q.y*=l,q.z=I,q.w*=-l}else{const I=Math.sign(q.w);q.x*=I,q.y*=-I,q.z*=-I,q.w=l}}return q}function b(q){q.gc(-q.z,q.w,q.x,-q.y)}function qq(q,I){const l=w.dI.FromArrayToRef(I.translation||[0,0,0],0,w.TmpVectors.dI[0]),t=w.Quaternion.FromArrayToRef(I.rotation||[0,0,0,1],0,w.TmpVectors.Quaternion[0]),O=w.Matrix.ComposeToRef(Y,t,l,w.TmpVectors.Matrix[0]),c=w.dI.FromArrayToRef(q.translation||[0,0,0],0,w.TmpVectors.dI[2]),a=w.Quaternion.FromArrayToRef(q.rotation||[0,0,0,1],0,w.TmpVectors.Quaternion[1]),F=w.Matrix.ComposeToRef(Y,a,c,w.TmpVectors.Matrix[1]);O.multiplyToRef(F,F),F.decompose(void 0,t,l),l.equalsWithEpsilon(P,u.d)?delete I.translation:I.translation=l.Uc(),t.equalsWithEpsilon(mq,u.d)?delete I.rotation:I.rotation=t.Uc(),I.scale&&delete I.scale}function Iq(q,I){if(!(I instanceof r.d))return!1;if(!(1===I.getChildren().length&&0===q.getChildren().length&&q.parent===I))return!1;const l=q.Wq(),w=q instanceof h.c&&!l.useRightHandedSystem?y:Y;return!!I.Xc.equalsWithEpsilon(w,u.d)||(j.b.Warn(`Cannot collapse node ${q.name} into parent node ${I.name} with modified scaling.`),!1)}function lq(q){if(q instanceof Array){const I=new Float32Array(q);return new Uint8Array(I.buffer,I.byteOffset,I.byteLength)}return ArrayBuffer.isView(q)?new Uint8Array(q.buffer,q.byteOffset,q.byteLength):new Uint8Array(q)}function wq(q,I){for(const[l,w]of Object.entries(q)){const t=I[l];(Array.isArray(w)&&Array.isArray(t)&&tq(w,t)||w===t)&&delete q[l]}return q}function tq(q,I){return q.length===I.length&&q.every(((q,l)=>q===I[l]))}const Oq=w.Matrix.Compose(new w.dI(-1,1,1),w.Quaternion.Identity(),w.dI.Zero());function cq(q,I){if(!(q instanceof r.d))return!1;if(I){if(!q.getWorldMatrix().equalsWithEpsilon(w.Matrix.IdentityReadOnly,u.d))return!1}else{if(!q.getWorldMatrix().multiplyToRef(Oq,w.TmpVectors.Matrix[0]).equalsWithEpsilon(w.Matrix.IdentityReadOnly,u.d))return!1}return!(q instanceof x.b&&q.Wc)}const aq=new Map([[Int8Array,(q,I,l)=>q.setInt8(I,l)],[Uint8Array,(q,I,l)=>q.setUint8(I,l)],[Uint8ClampedArray,(q,I,l)=>q.setUint8(I,l)],[Int16Array,(q,I,l)=>q.setInt16(I,l,!0)],[Uint16Array,(q,I,l)=>q.setUint16(I,l,!0)],[Int32Array,(q,I,l)=>q.setInt32(I,l,!0)],[Uint32Array,(q,I,l)=>q.setUint32(I,l,!0)],[Float32Array,(q,I,l)=>q.setFloat32(I,l,!0)],[Float64Array,(q,I,l)=>q.setFloat64(I,l,!0)]]);class Fq{writeTypedArray(q){this._checkGrowBuffer(q.byteLength);const I=aq.get(q.constructor);for(let l=0;l<q.length;l++)I(this._dataView,this._byteOffset,q[l]),this._byteOffset+=q.BYTES_PER_ELEMENT}constructor(q){this._data=new Uint8Array(q),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(q){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,q),this._byteOffset++}writeInt8(q){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,q),this._byteOffset++}writeInt16(q){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,q,!0),this._byteOffset+=2}writeUInt16(q){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,q,!0),this._byteOffset+=2}writeInt32(q){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,q,!0),this._byteOffset+=4}writeUInt32(q){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,q,!0),this._byteOffset+=4}writeFloat32(q){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,q,!0),this._byteOffset+=4}writeFloat64(q){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,q,!0),this._byteOffset+=8}_checkGrowBuffer(q){const I=this.byteOffset+q;if(I>this._data.byteLength){const q=new Uint8Array(2*I);q.set(this._data),this._data=q,this._dataView=new DataView(this._data.buffer)}}}function sq(q){return q%4===0?4:q%2===0?2:1}class Zq{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(q){let I=0;this._bufferViewToData.forEach((q=>{I+=q.byteLength}));const l=new Fq(I),w=Array.from(this._bufferViewToData.keys()).sort(((q,I)=>sq(I.byteLength)-sq(q.byteLength)));for(const t of w){t.byteOffset=l.byteOffset,q.push(t);const I=q.length-1,w=this.getPropertiesWithBufferView(t);for(const q of w)q.bufferView=I;l.writeTypedArray(this._bufferViewToData.get(t)),this._bufferViewToData.delete(t)}return l.getOutputData()}createBufferView(q,I){const l={buffer:0,byteOffset:void 0,byteLength:q.byteLength,byteStride:I};return this._bufferViewToData.set(l,q),l}createAccessor(q,I,l,w,t,O,c){this._verifyBufferView(q);const a={bufferView:void 0,componentType:l,count:w,type:I,min:null===O||void 0===O?void 0:O.min,max:null===O||void 0===O?void 0:O.max,normalized:c,byteOffset:t};return this.setBufferView(a,q),this._accessorToBufferView.set(a,q),a}setBufferView(q,I){this._verifyBufferView(I);this.getPropertiesWithBufferView(I).push(q)}removeBufferView(q){const I=this.getPropertiesWithBufferView(q);for(const l of I)void 0!==l.bufferView&&delete l.bufferView;this._bufferViewToData.delete(q),this._bufferViewToProperties.delete(q),this._accessorToBufferView.forEach(((I,l)=>{I===q&&(void 0!==l.byteOffset&&delete l.byteOffset,this._accessorToBufferView.delete(l))}))}getBufferView(q){const I=this._accessorToBufferView.get(q);return this._verifyBufferView(I),I}getPropertiesWithBufferView(q){return this._verifyBufferView(q),this._bufferViewToProperties.set(q,this._bufferViewToProperties.get(q)??[]),this._bufferViewToProperties.get(q)}getData(q){return this._verifyBufferView(q),this._bufferViewToData.get(q)}_verifyBufferView(q){if(void 0===q||!this._bufferViewToData.has(q))throw new Error(`BufferView ${q} not found in BufferManager.`)}}var rq,xq=l(13186),oq=l(13203),dq=l(13216),Tq=l(13122),Vq=l(13247),Uq=l(13254),Bq=l(13184),vq=l(13257);!function(q){q[q.INTANGENT=0]="INTANGENT",q[q.OUTTANGENT=1]="OUTTANGENT"}(rq||(rq={}));class kq{static _IsTransformable(q){return q&&(q instanceof r.d||q instanceof xq.d||q instanceof vq.d)}static _CreateNodeAnimation(q,I,l,w,O){if(this._IsTransformable(q)){const c=[],a=[],F=I.getKeys(),s=kq._CalculateMinMaxKeyFrames(F),Z=kq._DeduceInterpolation(F,l,w),r=Z.interpolationType,x=Z.shouldBakeAnimation;if(x?kq._CreateBakedAnimation(q,I,l,s.min,s.max,I.framePerSecond,O,c,a,s,w):"LINEAR"===r||"STEP"===r?kq._CreateLinearOrStepAnimation(q,I,l,c,a,w):"CUBICSPLINE"===r?kq._CreateCubicSplineAnimation(q,I,l,c,a,w):kq._CreateBakedAnimation(q,I,l,s.min,s.max,I.framePerSecond,O,c,a,s,w),c.length&&a.length){return{inputs:c,outputs:a,samplerInterpolation:r,inputsMin:x?s.min:t.Tools.FloatRound(s.min/I.framePerSecond),inputsMax:x?s.max:t.Tools.FloatRound(s.max/I.framePerSecond)}}}return null}static _DeduceAnimationInfo(q){let I=null,l="VEC3",w=!1;const O=q.targetProperty.split(".");switch(O[0]){case"Xc":I="scale";break;case"position":I="translation";break;case"rotation":l="VEC4",I="rotation";break;case"rotationQuaternion":l="VEC4",w=!0,I="rotation";break;case"influence":l="SCALAR",I="weights";break;default:t.Tools.Error(`Unsupported animatable property ${O[0]}`)}return I?{animationChannelTargetPath:I,dataAccessorType:l,useQuaternion:w}:(t.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(q,I,l,w,t,O,c,a,F,s,Z){let r;if(kq._IsTransformable(q)&&q.animations)for(const x of q.animations){if(Z&&!Z(x))continue;const t=kq._DeduceAnimationInfo(x);t&&(r={name:x.name,samplers:[],channels:[]},kq._AddAnimation(`${x.name}`,x.hasRunningRuntimeAnimations?I:r,q,x,t.dataAccessorType,t.animationChannelTargetPath,w,O,c,a,t.useQuaternion,F,s),r.samplers.length&&r.channels.length&&l.push(r))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(q,I,l,w,t,O,c,a,F,s,Z){let r;if(q instanceof Bq.c){const t=q.morphTargetManager;if(t)for(let x=0;x<t.numTargets;++x){const o=t.getTarget(x);for(const d of o.animations){if(Z&&!Z(d))continue;const o=new Vq.d(`${d.name}`,"influence",d.framePerSecond,d.dataType,d.loopMode,d.enableBlending),T=[],V=d.getKeys();for(let q=0;q<V.length;++q){const I=V[q];for(let q=0;q<t.numTargets;++q)q==x?T.push(I):T.push({frame:I.frame,value:0})}o.setKeys(T);const U=kq._DeduceAnimationInfo(o);U&&(r={name:o.name,samplers:[],channels:[]},kq._AddAnimation(d.name,d.hasRunningRuntimeAnimations?I:r,q,o,U.dataAccessorType,U.animationChannelTargetPath,w,O,c,a,U.useQuaternion,F,s,t.numTargets),r.samplers.length&&r.channels.length&&l.push(r))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(q,I,l,w,t,O,c,a,F){let s;if(q.animationGroups){const r=q.animationGroups;for(const x of r){const r=new Map,o=new Map,d=new Set,T=x.to-x.from;s={name:x.name,channels:[],samplers:[]};for(let I=0;I<x.targetedAnimations.length;++I){const T=x.targetedAnimations[I],V=T.target,U=T.animation;if(F&&!F(U))continue;const B=a.has(V);if(this._IsTransformable(V)||1===V.length&&this._IsTransformable(V[0])){const q=kq._DeduceAnimationInfo(T.animation);if(q){const I=this._IsTransformable(V)?V:this._IsTransformable(V[0])?V[0]:null;I&&kq._AddAnimation(`${U.name}`,s,I,U,q.dataAccessorType,q.animationChannelTargetPath,l,w,t,O,q.useQuaternion,c,B)}}else if(V instanceof Uq.b||1===V.length&&V[0]instanceof Uq.b){if(kq._DeduceAnimationInfo(T.animation)){const I=V instanceof Uq.b?V:V[0];if(I){const l=q.morphTargetManagers.find((q=>{for(let l=0;l<q.numTargets;++l)if(q.getTarget(l)===I)return!0;return!1}));if(l){const w=q.meshes.find((q=>q.morphTargetManager===l));var Z;if(w)r.has(w)||r.set(w,new Map),null===(Z=r.get(w))||void 0===Z||Z.set(I,U),d.add(w),o.set(w,U)}}}}}d.forEach((q=>{const I=q.morphTargetManager;let a=null;const F=[],Z=o.get(q).getKeys(),d=Z.length;for(let l=0;l<d;++l)for(let w=0;w<I.numTargets;++w){const t=I.getTarget(w),O=r.get(q);if(O){const I=O.get(t);I?(a||(a=new Vq.d(`${x.name}_${q.name}_MorphWeightAnimation`,"influence",I.framePerSecond,Vq.d.ANIMATIONTYPE_FLOAT,I.loopMode,I.enableBlending)),F.push(I.getKeys()[l])):F.push({frame:x.from+T/d*l,value:t.influence,inTangent:Z[0].inTangent?0:void 0,outTangent:Z[0].outTangent?0:void 0})}}a.setKeys(F);const V=kq._DeduceAnimationInfo(a);V&&kq._AddAnimation(`${x.name}_${q.name}_MorphWeightAnimation`,s,q,a,V.dataAccessorType,V.animationChannelTargetPath,l,w,t,O,V.useQuaternion,c,!1,null===I||void 0===I?void 0:I.numTargets)})),s.channels.length&&s.samplers.length&&I.push(s)}}}static _AddAnimation(q,I,l,t,O,c,a,F,s,Z,r,x,o,d){const T=kq._CreateNodeAnimation(l,t,c,r,x);let V,U,B,v,k,C;if(T){if(d){let q=0,I=0;const l=[];for(;T.inputs.length>0;)I=T.inputs.shift(),q%d==0&&l.push(I),q++;T.inputs=l}const q=a.get(l),t=new Float32Array(T.inputs);V=F.createBufferView(t),U=F.createAccessor(V,"SCALAR",5126,T.inputs.length,void 0,{min:[T.inputsMin],max:[T.inputsMax]}),Z.push(U),B=Z.length-1;const s=new w.Quaternion,r=new w.dI,x=new w.dI,R=l instanceof xq.d,W=N(O),e=new Float32Array(T.outputs.length*W);T.outputs.forEach((function(q,I){let l=q;switch(c){case"translation":o&&(w.dI.FromArrayToRef(q,0,x),A(x),x.toArray(l));break;case"rotation":4===q.length?w.Quaternion.FromArrayToRef(q,0,s):(l=new Array(4),w.dI.FromArrayToRef(q,0,r),w.Quaternion.FromEulerVectorToRef(r,s)),o&&(Q(s),R&&b(s)),s.toArray(l)}e.set(l,I*W)})),V=F.createBufferView(e),U=F.createAccessor(V,O,5126,T.outputs.length),Z.push(U),v=Z.length-1,k={interpolation:T.samplerInterpolation,input:B,output:v},I.samplers.push(k),C={sampler:I.samplers.length-1,target:{node:q,path:c}},I.channels.push(C)}}static _CreateBakedAnimation(q,I,l,O,c,a,F,s,Z,r,x){let o;const d=w.Quaternion.Identity();let T,V=null,U=null,B=null,v=null,k=null,C=null;r.min=t.Tools.FloatRound(O/a);const R=I.getKeys();for(let w=0,W=R.length;w<W;++w){if(C=null,B=R[w],w+1<W)if(v=R[w+1],B.value.equals&&B.value.equals(v.value)||B.value===v.value){if(0!==w)continue;C=B.frame}else C=v.frame;else{if(k=R[w-1],B.value.equals&&B.value.equals(k.value)||B.value===k.value)continue;C=c}if(C)for(let w=B.frame;w<=C;w+=F){if(T=t.Tools.FloatRound(w/a),T===V)continue;V=T,U=T;const O={key:0,repeatCount:0,loopMode:I.loopMode};o=I._interpolate(w,O),kq._SetInterpolatedValue(q,o,T,I,l,d,s,Z,x)}}U&&(r.max=U)}static _ConvertFactorToVector3OrQuaternion(q,I,l,O,c){const a=kq._GetBasePositionRotationOrScale(I,O,c),F=l.targetProperty.split("."),s=F?F[1]:"",Z=c?w.Quaternion.vI(a).normalize():w.dI.vI(a);switch(s){case"x":case"y":case"z":Z[s]=q;break;case"w":Z.w=q;break;default:t.Tools.Error(`glTFAnimation: Unsupported component name "${s}"!`)}return Z}static _SetInterpolatedValue(q,I,l,t,O,c,a,F,s){let Z;a.push(l),"weights"!==O?(t.dataType===Vq.d.ANIMATIONTYPE_FLOAT&&(I=this._ConvertFactorToVector3OrQuaternion(I,q,t,O,s)),"rotation"===O?(s?c=I:(Z=I,w.Quaternion.RotationYawPitchRollToRef(Z.y,Z.x,Z.z,c)),F.push(c.Uc())):(Z=I,F.push(Z.Uc()))):F.push([I])}static _CreateLinearOrStepAnimation(q,I,l,w,t,O){for(const c of I.getKeys())w.push(c.frame/I.framePerSecond),kq._AddKeyframeValue(c,I,t,l,q,O)}static _CreateCubicSplineAnimation(q,I,l,w,t,O){I.getKeys().forEach((function(c){w.push(c.frame/I.framePerSecond),kq._AddSplineTangent(rq.INTANGENT,t,l,"CUBICSPLINE",c,O),kq._AddKeyframeValue(c,I,t,l,q,O),kq._AddSplineTangent(rq.OUTTANGENT,t,l,"CUBICSPLINE",c,O)}))}static _GetBasePositionRotationOrScale(q,I,l){let t;if("rotation"===I)if(l){t=(q.rotationQuaternion??w.Quaternion.Identity()).Uc()}else{t=(q.rotation??w.dI.Zero()).Uc()}else if("translation"===I){t=(q.position??w.dI.Zero()).Uc()}else{t=(q.Xc??w.dI.One()).Uc()}return t}static _AddKeyframeValue(q,I,l,O,c,a){let F;const s=I.dataType;if(s===Vq.d.ANIMATIONTYPE_VECTOR3){let I=q.value.Uc();if("rotation"===O){const q=w.dI.vI(I);I=w.Quaternion.RotationYawPitchRoll(q.y,q.x,q.z).Uc()}l.push(I)}else if(s===Vq.d.ANIMATIONTYPE_FLOAT){if("weights"===O)l.push([q.value]);else if(F=this._ConvertFactorToVector3OrQuaternion(q.value,c,I,O,a),F){if("rotation"===O){const q=a?F:w.Quaternion.RotationYawPitchRoll(F.y,F.x,F.z).normalize();l.push(q.Uc())}l.push(F.Uc())}}else s===Vq.d.ANIMATIONTYPE_QUATERNION?l.push(q.value.normalize().Uc()):t.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(q,I,l){let w,t,O=!1;if("rotation"===I&&!l)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let c=0,a=q.length;c<a;++c)if(t=q[c],t.inTangent||t.outTangent)if(w){if("CUBICSPLINE"!==w){w="LINEAR",O=!0;break}}else w="CUBICSPLINE";else if(w){if("CUBICSPLINE"===w||t.interpolation&&1===t.interpolation&&"STEP"!==w){w="LINEAR",O=!0;break}}else w=t.interpolation&&1===t.interpolation?"STEP":"LINEAR";return w||(w="LINEAR"),{interpolationType:w,shouldBakeAnimation:O}}static _AddSplineTangent(q,I,l,t,O,c){let a;const F=q===rq.INTANGENT?O.inTangent:O.outTangent;if("CUBICSPLINE"===t){if("rotation"===l)if(F)if(c)a=F.Uc();else{const q=F;a=w.Quaternion.RotationYawPitchRoll(q.y,q.x,q.z).Uc()}else a=[0,0,0,0];else a="weights"===l?F?[F]:[0]:F?F.Uc():[0,0,0];I.push(a)}}static _CalculateMinMaxKeyFrames(q){let I=1/0,l=-1/0;return q.forEach((function(q){I=Math.min(I,q.frame),l=Math.max(l,q.frame)})),{min:I,max:l}}}function Cq(q,I,l,O,c,a){const F={attributes:{},influence:q.influence,name:q.name},s=I.Wc;if(!s)return t.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),F;const r=a?-1:1,x=w.dI.Zero();let o=0,d=0;if(q.hasPositions){const O=q.getPositions(),a=s.getVerticesData(Z.c.PositionKind);if(a){const q=new Float32Array(a.length),I=[1/0,1/0,1/0],t=[-1/0,-1/0,-1/0];d=a.length/3,o=0;for(let l=o;l<d;++l){const c=w.dI.vI(a,3*l);w.dI.vI(O,3*l).subtractToRef(c,x),x.x*=r,I[0]=Math.min(I[0],x.x),t[0]=Math.max(t[0],x.x),I[1]=Math.min(I[1],x.y),t[1]=Math.max(t[1],x.y),I[2]=Math.min(I[2],x.z),t[2]=Math.max(t[2],x.z),q[3*l]=x.x,q[3*l+1]=x.y,q[3*l+2]=x.z}const s=l.createBufferView(q,12),Z=l.createAccessor(s,"VEC3",5126,O.length/3,0,{min:I,max:t});c.push(Z),F.attributes.POSITION=c.length-1}else t.Tools.Warn(`Morph target positions for mesh ${I.name} were not exported. Mesh does not have position vertex data`)}if(q.hasNormals){const O=q.getNormals(),a=s.getVerticesData(Z.c.NormalKind);if(a){const q=new Float32Array(a.length);d=a.length/3,o=0;for(let l=o;l<d;++l){const I=w.dI.vI(a,3*l).normalize();w.dI.vI(O,3*l).normalize().subtractToRef(I,x),q[3*l]=x.x*r,q[3*l+1]=x.y,q[3*l+2]=x.z}const I=l.createBufferView(q,12),t=l.createAccessor(I,"VEC3",5126,O.length/3,0);c.push(t),F.attributes.NORMAL=c.length-1}else t.Tools.Warn(`Morph target normals for mesh ${I.name} were not exported. Mesh does not have normals vertex data`)}if(q.hasTangents){const O=q.getTangents(),a=s.getVerticesData(Z.c.TangentKind);if(a){d=a.length/4;const q=new Float32Array(3*d);o=0;for(let l=o;l<d;++l){const I=w.dI.vI(a,4*l);H(I);const t=w.dI.vI(O,3*l);H(t),t.subtractToRef(I,x),q[3*l]=x.x*r,q[3*l+1]=x.y,q[3*l+2]=x.z}const I=l.createBufferView(q,12),t=l.createAccessor(I,"VEC3",5126,d,0);c.push(t),F.attributes.TANGENT=c.length-1}else t.Tools.Warn(`Morph target tangents for mesh ${I.name} were not exported. Mesh does not have tangents vertex data`)}if(q.hasColors){const O=q.getColors(),a=s.getVerticesData(Z.c.ColorKind),r=s.getVertexBuffer(Z.c.ColorKind);if(a&&r){const q=r.getSize();d=a.length/q;const I=new Float32Array(d*q);o=0;for(let l=o;l<d;++l)if(3===q){const t=w.dI.vI(a,l*q);w.dI.vI(O,l*q).subtractToRef(t,x),I[3*l]=x.x,I[3*l+1]=x.y,I[3*l+2]=x.z}else if(4===q){const t=new w.Vector4,c=w.Vector4.vI(a,l*q);w.Vector4.vI(O,l*q).subtractToRef(c,t),I[4*l]=t.x,I[4*l+1]=t.y,I[4*l+2]=t.z,I[4*l+3]=t.w}else t.Tools.Warn(`Unsupported number of components for color attribute: ${q}`);const s=l.createBufferView(I,4*q),Z=l.createAccessor(s,3===q?"VEC3":"VEC4",5126,d,0);c.push(Z),F.attributes.COLOR_0=c.length-1}else t.Tools.Warn(`Morph target colors for mesh ${I.name} were not exported. Mesh does not have colors vertex data`)}return F}var Rq=l(13263),Wq=l(13152),eq=l(13139),iq=l(12711);class Sq{}Sq.DEFAULT_COLOR=V.BI.White(),Sq.DEFAULT_WIDTH_ATTENUATED=1,Sq.DEFAULT_WIDTH=.1;var gq=l(12965),pq=l(13269);class Xq{static ConvertPoints(q,I){if(q.length&&Array.isArray(q)&&"number"===typeof q[0])return[q];if(q.length&&Array.isArray(q[0])&&"number"===typeof q[0][0])return q;if(q.length&&!Array.isArray(q[0])&&q[0]instanceof w.dI){const I=[];for(let l=0;l<q.length;l++){const w=q[l];I.push(w.x,w.y,w.z)}return[I]}if(q.length>0&&Array.isArray(q[0])&&q[0].length>0&&q[0][0]instanceof w.dI){const I=[],l=q;for(const q of l)I.push(q.flatMap((q=>[q.x,q.y,q.z])));return I}if(q instanceof Float32Array){if(null!==I&&void 0!==I&&I.floatArrayStride){const l=[],w=3*I.floatArrayStride;for(let I=0;I<q.length;I+=w){const t=new Array(w);for(let l=0;l<w;l++)t[l]=q[I+l];l.push(t)}return l}return[Array.from(q)]}if(q.length&&q[0]instanceof Float32Array){const I=[];for(const l of q)I.push(Array.from(l));return I}return[]}static OmitZeroLengthPredicate(q,I,l){const w=[];return I.TI(q).lengthSquared()>0&&w.push([q,I]),l.TI(I).lengthSquared()>0&&w.push([I,l]),q.TI(l).lengthSquared()>0&&w.push([l,q]),0===w.length?null:w}static OmitDuplicatesPredicate(q,I,l,w){const t=[];return Xq._SearchInPoints(q,I,w)||t.push([q,I]),Xq._SearchInPoints(I,l,w)||t.push([I,l]),Xq._SearchInPoints(l,q,w)||t.push([l,q]),0===t.length?null:t}static _SearchInPoints(q,I,l){for(const c of l)for(let l=0;l<c.length;l++){var w,t,O;if(null!==(w=c[l])&&void 0!==w&&w.equals(q))if(null!==(t=c[l+1])&&void 0!==t&&t.equals(I)||null!==(O=c[l-1])&&void 0!==O&&O.equals(I))return!0}return!1}static MeshesToLines(q,I){const l=[];for(let t=0;t<q.length;t++){const O=q[t],c=O.getVerticesData(Z.c.PositionKind),a=O.ec();if(c&&a)for(let q=0,F=0;q<a.length;q++){const s=3*a[F++],Z=3*a[F++],r=3*a[F++],x=new w.dI(c[s],c[s+1],c[s+2]),o=new w.dI(c[Z],c[Z+1],c[Z+2]),d=new w.dI(c[r],c[r+1],c[r+2]);if(I){const w=I(x,o,d,l,q,s,O,t,c,a);if(w)for(const q of w)l.push(q)}else l.push([x,o],[o,d],[d,x])}}return l}static ToVector3Array(q){if(Array.isArray(q[0])){const I=[],l=q;for(const q of l){const l=[];for(let I=0;I<q.length;I+=3)l.push(new w.dI(q[I],q[I+1],q[I+2]));I.push(l)}return I}const I=q,l=[];for(let t=0;t<I.length;t+=3)l.push(new w.dI(I[t],I[t+1],I[t+2]));return l}static ToNumberArray(q){return q.flatMap((q=>[q.x,q.y,q.z]))}static GetPointsCountInfo(q){const I=new Array(q.length);let l=0;for(let w=q.length;w--;)I[w]=q[w].length/3,l+=I[w];return{total:l,counts:I}}static GetLineLength(q){if(0===q.length)return 0;let I;I="number"===typeof q[0]?Xq.ToVector3Array(q):q;const l=w.TmpVectors.dI[0];let t=0;for(let w=0;w<I.length-1;w++){const q=I[w];t+=I[w+1].subtractToRef(q,l).length()}return t}static GetLineLengthArray(q){const I=new Float32Array(q.length/3);let l=0;for(let w=0,t=q.length/3-1;w<t;w++){let t=q[3*w+0],O=q[3*w+1],c=q[3*w+2];t-=q[3*w+3],O-=q[3*w+4],c-=q[3*w+5];l+=Math.sqrt(t*t+O*O+c*c),I[w+1]=l}return I}static SegmentizeSegmentByCount(q,I,l){const t=[],O=I.TI(q),c=w.TmpVectors.dI[0];c.Kc(l);const a=w.TmpVectors.dI[1];O.divideToRef(c,a);let F=q.clone();t.push(F);for(let w=0;w<l;w++)F=F.clone(),t.push(F.addInPlace(a));return t}static SegmentizeLineBySegmentLength(q,I){const l=q[0]instanceof w.dI?Xq.GetLineSegments(q):"number"===typeof q[0]?Xq.GetLineSegments(Xq.ToVector3Array(q)):q,t=[];for(const w of l)if(w.length>I){const q=Xq.SegmentizeSegmentByCount(w.point1,w.point2,Math.ceil(w.length/I));for(const I of q)t.push(I)}else t.push(w.point1),t.push(w.point2);return t}static SegmentizeLineBySegmentCount(q,I){const l="number"===typeof q[0]?Xq.ToVector3Array(q):q,w=Xq.GetLineLength(l)/I;return Xq.SegmentizeLineBySegmentLength(l,w)}static GetLineSegments(q){const I=[];for(let l=0;l<q.length-1;l++){const w=q[l],t=q[l+1],O=t.TI(w).length();I.push({point1:w,point2:t,length:O})}return I}static GetMinMaxSegmentLength(q){const I=Xq.GetLineSegments(q).sort((q=>q.length));return{min:I[0].length,max:I[I.length-1].length}}static GetPositionOnLineByVisibility(q,I,l){let t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const O=I*l;let c=0,a=0;const F=q.length;for(let w=0;w<F;w++){if(O<=c+q[w].length){a=w;break}c+=q[w].length}const s=(O-c)/q[a].length;return q[a].point2.subtractToRef(q[a].point1,w.TmpVectors.dI[0]),w.TmpVectors.dI[1]=w.TmpVectors.dI[0].multiplyByFloats(s,s,s),t||w.TmpVectors.dI[1].addInPlace(q[a].point1),w.TmpVectors.dI[1].clone()}static GetCircleLinePoints(q,I){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:q,O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/I;const c=[];for(let a=0;a<=I;a++)c.push(new w.dI(Math.cos(a*O)*q,Math.sin(a*O)*t,l));return c}static GetBezierLinePoints(q,I,l,w){return gq.c.CreateQuadraticBezier(q,I,l,w).getPoints().flatMap((q=>[q.x,q.y,q.z]))}static GetArrowCap(q,I,l,w,t){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[q.clone(),q.add(I.multiplyByFloats(l,l,l))],widths:[w,t,O,c]}}static GetPointsFromText(q,I,l,w){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const c=[],a=(0,pq.b)(q,I,l,w);for(const F of a){for(const q of F.paths){const I=[],l=q.getPoints();for(const q of l)I.push(q.x,q.y,t);c.push(I)}if(O)for(const q of F.holes){const I=[],l=q.getPoints();for(const q of l)I.push(q.x,q.y,t);c.push(I)}}return c}static Color3toRGBAUint8(q){const I=new Uint8Array(4*q.length);for(let l=0,w=0;l<q.length;l++)I[w++]=255*q[l].r,I[w++]=255*q[l].g,I[w++]=255*q[l].b,I[w++]=255;return I}static CreateColorsTexture(q,I,l,w){const t=w.getEngine().getCaps().maxTextureSize??1,O=I.length>t?t:I.length,c=Math.ceil(I.length/t);c>1&&(I=[...I,...Array(O*c-I.length).fill(I[0])]);const a=Xq.Color3toRGBAUint8(I),F=new R.d(a,O,c,d.d.TEXTUREFORMAT_RGBA,w,!1,!0,l);return F.name=q,F}static PrepareEmptyColorsTexture(q){if(!Sq.EmptyColorsTexture){const I=new Uint8Array(4);Sq.EmptyColorsTexture=new R.d(I,1,1,d.d.TEXTUREFORMAT_RGBA,q,!1,!1,R.d.NEAREST_NEAREST),Sq.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Sq.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var q;null===(q=Sq.EmptyColorsTexture)||void 0===q||q.dispose(),Sq.EmptyColorsTexture=null}static BooleanToNumber(q){return q?1:0}}class Kq extends eq.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Dq extends Wq.b{isCompatible(q){return!0}constructor(q,I,l){var t;l=l||{color:Sq.DEFAULT_COLOR};const O=new Kq;O.GREASED_LINE_HAS_COLOR=!!l.color&&!l.useColors,O.GREASED_LINE_SIZE_ATTENUATION=l.sizeAttenuation??!1,O.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===l.colorDistributionType,O.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(I??q.Wq()).useRightHandedSystem,O.GREASED_LINE_CAMERA_FACING=l.cameraFacing??!0,super(q,Dq.GREASED_LINE_MATERIAL_NAME,200,O,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(t=l)||void 0===t?void 0:t.forceGLSL)||Dq.ForceGLSL,this._scene=I??q.Wq(),this._engine=this._scene.getEngine(),this._cameraFacing=l.cameraFacing??!0,this.visibility=l.visibility??1,this.useDash=l.useDash??!1,this.dashRatio=l.dashRatio??.5,this.dashOffset=l.dashOffset??0,this.width=l.width?l.width:l.sizeAttenuation?Sq.DEFAULT_WIDTH_ATTENUATED:Sq.DEFAULT_WIDTH,this._sizeAttenuation=l.sizeAttenuation??!1,this.colorMode=l.colorMode??0,this._color=l.color??null,this.useColors=l.useColors??!1,this._colorsDistributionType=l.colorDistributionType??0,this.colorsSampling=l.colorsSampling??R.d.NEAREST_NEAREST,this._colors=l.gq??null,this.dashCount=l.dashCount??1,this.resolution=l.resolution??new w.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),l.colorsTexture?this.colorsTexture=l.colorsTexture:this._colors?this.colorsTexture=Xq.CreateColorsTexture(`${q.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Sq.DEFAULT_COLOR,Xq.PrepareEmptyColorsTexture(this._scene)),this._engine.tc.add((()=>{Xq.DisposeEmptyColorsTexture()}))}getAttributes(q){q.push("grl_offsets"),q.push("grl_widths"),q.push("grl_colorPointers"),q.push("grl_counters"),this._cameraFacing?(q.push("grl_previousAndSide"),q.push("grl_nextAndCounters")):q.push("grl_slopes")}getSamplers(q){q.push("grl_colors")}getActiveTextures(q){this.colorsTexture&&q.push(this.colorsTexture)}getUniforms(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const I=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&I.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===q&&I.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:I,vertex:this._cameraFacing&&this._isGLSL(q)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(q)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(q){if(this._cameraFacing){q.kc("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||q.kc("viewProjection",this._scene.getTransformMatrix());const I=w.TmpVectors.Vector4[0];I.x=this._aspect,I.y=this._resolution.x,I.z=this._resolution.y,I.w=this.width,q.updateVector4("grl_aspect_resolution_lineWidth",I)}const I=w.TmpVectors.Vector4[0];I.x=Xq.BooleanToNumber(this.useDash),I.y=this._dashArray,I.z=this.dashOffset,I.w=this.dashRatio,q.updateVector4("grl_dashOptions",I);const l=w.TmpVectors.Vector4[1];l.x=this.colorMode,l.y=this.visibility,l.z=this.colorsTexture?this.colorsTexture.getSize().width:0,l.w=Xq.BooleanToNumber(this.useColors),q.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",l),this._color&&q.updateColor3("grl_singleColor",this._color);const t=this.colorsTexture??Sq.EmptyColorsTexture;q.setTexture("grl_colors",t),q.updateFloat2("grl_textureSize",(null===t||void 0===t?void 0:t.getSize().width)??1,(null===t||void 0===t?void 0:t.getSize().height)??1)}prepareDefines(q,I,l){q.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,q.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,q.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,q.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=I.useRightHandedSystem,q.GREASED_LINE_CAMERA_FACING=this._cameraFacing,q.GREASED_LINE_USE_OFFSETS=!!l.offsets}getClassName(){return Dq.GREASED_LINE_MATERIAL_NAME}getCustomCode(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(I)?function(q,I){if("vertex"===q){const q={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return I&&(q["!gl_Position\\=viewProjection\\*worldPos;"]="//"),q}return"fragment"===q?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(q,this._cameraFacing):function(q,I){if("vertex"===q){const q={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return I&&(q["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),q}return"fragment"===q?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(q,this._cameraFacing)}dispose(){var q;null===(q=this.colorsTexture)||void 0===q||q.dispose(),super.dispose()}get gq(){return this._colors}set gq(q){this.setColors(q)}setColors(q){var I;let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1],w=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=(null===(I=this._colors)||void 0===I?void 0:I.length)??0;var O;if(this._colors=q,null!==q&&0!==q.length){if(!l||w)if(this.colorsTexture&&t===q.length&&!w){const I=Xq.Color3toRGBAUint8(q);this.colorsTexture.update(I)}else{var c;null===(c=this.colorsTexture)||void 0===c||c.dispose(),this.colorsTexture=Xq.CreateColorsTexture(`${this._material.name}-colors-texture`,q,this.colorsSampling,this._scene)}}else null===(O=this.colorsTexture)||void 0===O||O.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(q){this._dashCount=q,this._dashArray=1/q}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(q){this._sizeAttenuation=q,this.markAllDefinesAsDirty()}get color(){return this._color}set color(q){this.setColor(q)}setColor(q){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==q||null!==this._color&&null===q?(this._color=q,I||this.markAllDefinesAsDirty()):this._color=q}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(q){this._colorsDistributionType=q,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(q){this._aspect=q.x/q.y,this._resolution=q}serialize(){const q=super.serialize(),I={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(I.gq=this._colors),this._color&&(I.color=this._color),q.greasedLineMaterialOptions=I,q}parse(q,I,l){var w;super.parse(q,I,l);const t=q.greasedLineMaterialOptions;null===(w=this.colorsTexture)||void 0===w||w.dispose(),t.color&&this.setColor(t.color,!0),t.colorDistributionType&&(this.colorsDistributionType=t.colorDistributionType),t.gq&&(this.gq=t.gq),t.colorsSampling&&(this.colorsSampling=t.colorsSampling),t.colorMode&&(this.colorMode=t.colorMode),t.useColors&&(this.useColors=t.useColors),t.visibility&&(this.visibility=t.visibility),t.useDash&&(this.useDash=t.useDash),t.dashCount&&(this.dashCount=t.dashCount),t.dashRatio&&(this.dashRatio=t.dashRatio),t.dashOffset&&(this.dashOffset=t.dashOffset),t.width&&(this.width=t.width),t.sizeAttenuation&&(this.sizeAttenuation=t.sizeAttenuation),t.resolution&&(this.resolution=t.resolution),this.gq?this.colorsTexture=Xq.CreateColorsTexture(`${this._material.name}-colors-texture`,this.gq,this.colorsSampling,I):Xq.PrepareEmptyColorsTexture(I),this.markAllDefinesAsDirty()}copyTo(q){var I;const l=q;null===(I=l.colorsTexture)||void 0===I||I.dispose(),this._colors&&(l.colorsTexture=Xq.CreateColorsTexture(`${l._material.name}-colors-texture`,this._colors,l.colorsSampling,this._scene)),l.setColor(this.color,!0),l.colorsDistributionType=this.colorsDistributionType,l.colorsSampling=this.colorsSampling,l.colorMode=this.colorMode,l.useColors=this.useColors,l.visibility=this.visibility,l.useDash=this.useDash,l.dashCount=this.dashCount,l.dashRatio=this.dashRatio,l.dashOffset=this.dashOffset,l.width=this.width,l.sizeAttenuation=this.sizeAttenuation,l.resolution=this.resolution,l.markAllDefinesAsDirty()}_isGLSL(q){return 0===q||this._forceGLSL}}Dq.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Dq.ForceGLSL=!1,(0,iq.e)(`BABYLON.${Dq.GREASED_LINE_MATERIAL_NAME}`,Dq);var Mq=l(13175),nq=l(12599),fq=l(12983),Lq=l(12696);class Eq extends fq.ShaderMaterial{constructor(q,I,t){const O=I.getEngine(),c=O.isWebGPU&&!(t.forceGLSL||Eq.ForceGLSL),a=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];I.useRightHandedSystem&&a.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const F=["position","grl_widths","grl_offsets","grl_colorPointers"];t.cameraFacing?(a.push("GREASED_LINE_CAMERA_FACING"),F.push("grl_previousAndSide","grl_nextAndCounters")):(F.push("grl_slopes"),F.push("grl_counters"));const s=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(c||s.push("world","viewProjection","view","projection"),super(q,I,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:c?["Scene","Mesh"]:void 0,attributes:F,uniforms:s,samplers:c?[]:["grlColors"],defines:a,extraInitializationsAsync:async()=>{c?await Promise.all([l.e(66).then(l.bind(l,15893)),l.e(75).then(l.bind(l,15901))]):await Promise.all([l.e(69).then(l.bind(l,15910)),l.e(76).then(l.bind(l,15919))])},shaderLanguage:c?1:0}),this._color=V.BI.White(),this._colorsDistributionType=0,this._colorsTexture=null,t=t||{color:Sq.DEFAULT_COLOR},this.visibility=t.visibility??1,this.useDash=t.useDash??!1,this.dashRatio=t.dashRatio??.5,this.dashOffset=t.dashOffset??0,this.dashCount=t.dashCount??1,this.width=t.width?t.width:t.sizeAttenuation&&t.cameraFacing?Sq.DEFAULT_WIDTH_ATTENUATED:Sq.DEFAULT_WIDTH,this.sizeAttenuation=t.sizeAttenuation??!1,this.color=t.color??V.BI.White(),this.useColors=t.useColors??!1,this.colorsDistributionType=t.colorDistributionType??0,this.colorsSampling=t.colorsSampling??R.d.NEAREST_NEAREST,this.colorMode=t.colorMode??0,this._colors=t.gq??null,this._cameraFacing=t.cameraFacing??!0,this.resolution=t.resolution??new w.Vector2(O.getRenderWidth(),O.getRenderHeight()),t.colorsTexture?this.colorsTexture=t.colorsTexture:this._colors?this.colorsTexture=Xq.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,I):(this._color=this._color??Sq.DEFAULT_COLOR,this.colorsTexture=Xq.PrepareEmptyColorsTexture(I)),c){const q=new Lq.b;q.setParameters(),q.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",q)}O.tc.add((()=>{Xq.DisposeEmptyColorsTexture()}))}dispose(){var q;null===(q=this._colorsTexture)||void 0===q||q.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new w.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get gq(){return this._colors}set gq(q){this.setColors(q)}setColors(q){var I;let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1],w=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=(null===(I=this._colors)||void 0===I?void 0:I.length)??0;var O;if(this._colors=q,null!==q&&0!==q.length){if(!l||w)if(this._colorsTexture&&t===q.length&&!w){const I=Xq.Color3toRGBAUint8(q);this._colorsTexture.update(I)}else{var c;null===(c=this._colorsTexture)||void 0===c||c.dispose(),this.colorsTexture=Xq.CreateColorsTexture(`${this.name}-colors-texture`,q,this.colorsSampling,this.Wq())}}else null===(O=this._colorsTexture)||void 0===O||O.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(q){this._colorsTexture=q,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(q){this._width=q,this.setFloat("grlWidth",q)}get useColors(){return this._useColors}set useColors(q){this._useColors=q,this.setFloat("grlUseColors",Xq.BooleanToNumber(q))}get colorsSampling(){return this._colorsSampling}set colorsSampling(q){this._colorsSampling=q}get visibility(){return this._visibility}set visibility(q){this._visibility=q,this.setFloat("grlVisibility",q)}get useDash(){return this._useDash}set useDash(q){this._useDash=q,this.setFloat("grlUseDash",Xq.BooleanToNumber(q))}get dashOffset(){return this._dashOffset}set dashOffset(q){this._dashOffset=q,this.setFloat("grlDashOffset",q)}get dashRatio(){return this._dashRatio}set dashRatio(q){this._dashRatio=q,this.setFloat("grlDashRatio",q)}get dashCount(){return this._dashCount}set dashCount(q){this._dashCount=q,this._dashArray=1/q,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(q){this._sizeAttenuation=q,this.setFloat("grlSizeAttenuation",Xq.BooleanToNumber(q))}get color(){return this._color}set color(q){this.setColor(q)}setColor(q){q=q??Sq.DEFAULT_COLOR,this._color=q,this.setColor3("grlColor",q)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(q){this._colorsDistributionType=q,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(q){this._colorMode=q,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(q){this._resolution=q,this.setVector2("grlResolution",q),this.setFloat("grlAspect",q.x/q.y)}serialize(){const q=super.serialize(),I={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(I.gq=this._colors),q.greasedLineMaterialOptions=I,q}parse(q,I,l){var w;const t=q.greasedLineMaterialOptions;null===(w=this._colorsTexture)||void 0===w||w.dispose(),t.color&&(this.color=t.color),t.colorDistributionType&&(this.colorsDistributionType=t.colorDistributionType),t.colorsSampling&&(this.colorsSampling=t.colorsSampling),t.colorMode&&(this.colorMode=t.colorMode),t.useColors&&(this.useColors=t.useColors),t.visibility&&(this.visibility=t.visibility),t.useDash&&(this.useDash=t.useDash),t.dashCount&&(this.dashCount=t.dashCount),t.dashRatio&&(this.dashRatio=t.dashRatio),t.dashOffset&&(this.dashOffset=t.dashOffset),t.width&&(this.width=t.width),t.sizeAttenuation&&(this.sizeAttenuation=t.sizeAttenuation),t.resolution&&(this.resolution=t.resolution),t.gq?this.colorsTexture=Xq.CreateColorsTexture(`${this.name}-colors-texture`,t.gq,this.colorsSampling,this.Wq()):this.colorsTexture=Xq.PrepareEmptyColorsTexture(I),this._cameraFacing=t.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var jq,hq,uq;Eq.ForceGLSL=!1,function(q){q[q.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",q[q.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(jq||(jq={})),function(q){q[q.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",q[q.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",q[q.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(hq||(hq={})),function(q){q[q.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",q[q.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",q[q.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",q[q.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",q[q.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(uq||(uq={}));class Pq extends Bq.c{constructor(q,I,l){super(q,I,null,null,!1,!1),this.name=q,this._options=l,this._lazy=!1,this._updatable=!1,this._engine=I.getEngine(),this._lazy=l.lazy??!1,this._updatable=l.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=l.colorPointers??[],this._widths=l.widths??new Array(l.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(q){let I=0;for(const w of this._points)I+=w.length;const l=I/3*2-this._widths.length;for(let w=0;w<l;w++)this._widths.push(q)}updateLazy(){var q,I;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(q=this._options.ribbonOptions)||void 0===q?void 0:q.smoothShading),!this.Dq&&this.refreshBoundingInfo(),null===(I=this.greasedLineMaterial)||void 0===I||I.updateLazy()}addPoints(q,I){for(const l of q)this._points.push(l);this._lazy||this.setPoints(this._points,I)}dispose(q){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(q,I)}isLazy(){return this._lazy}get pq(){return this._uvs}set pq(q){this._uvs=q instanceof Float32Array?q:new Float32Array(q),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(q){this.material instanceof Eq&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===q||void 0===q?void 0:q.length)>0),this._offsets=q,this._offsetsBuffer?this._offsetsBuffer.update(q):this._createOffsetsBuffer(q)}get widths(){return this._widths}set widths(q){this._widths=q,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(q)}get colorPointers(){return this._colorPointers}set colorPointers(q){this._colorPointers=q,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(q)}get greasedLineMaterial(){var q,I;if(this.material&&this.material instanceof Eq)return this.material;const l=null===(q=this.material)||void 0===q||null===(I=q.pluginManager)||void 0===I?void 0:I.getPlugin(Dq.GREASED_LINE_MATERIAL_NAME);return l||void 0}get points(){const q=[];return nq.d.DeepCopy(this._points,q),q}setPoints(q,I){this._points=Xq.ConvertPoints(q,(null===I||void 0===I?void 0:I.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==I&&void 0!==I&&I.colorPointers||this._updateColorPointers(),this._setPoints(this._points,I)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,pq:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(q){super.serialize(q),q.type=this.getClassName(),q.lineOptions=this._createLineOptions()}_createVertexBuffers(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new Mq.e;return I.iq=this._vertexPositions,I.indices=this._indices,I.pq=this._uvs,q&&(I.Sq=[],Mq.e.ComputeNormals(this._vertexPositions,this._indices,I.Sq)),I.Kq(this,this._options.updatable),I}_createOffsetsBuffer(q){const I=this._scene.getEngine(),l=new Z.b(I,q,this._updatable,3);this.setVerticesBuffer(l.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=l}}class mI{constructor(q,I){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=q,this.wasAddedByNoopNode=I}getIndicesAccessor(q,I,l,w,t){var O,c,a,F;return null===(O=this._indicesAccessorMap.get(q))||void 0===O||null===(c=O.get(I))||void 0===c||null===(a=c.get(l))||void 0===a||null===(F=a.get(w))||void 0===F?void 0:F.get(t)}setIndicesAccessor(q,I,l,w,t,O){let c=this._indicesAccessorMap.get(q);c||(c=new Map,this._indicesAccessorMap.set(q,c));let a=c.get(I);a||(a=new Map,c.set(I,a));let F=a.get(l);F||(F=new Map,a.set(l,F));let s=F.get(w);s||(s=new Map,F.set(w,s)),s.set(t,O)}pushExportedNode(q){this._exportedNodes.has(q)||this._exportedNodes.add(q)}getNodesSet(){return this._exportedNodes}getVertexBufferView(q){return this._vertexBufferViewMap.get(q)}setVertexBufferView(q,I){this._vertexBufferViewMap.set(q,I)}setRemappedBufferView(q,I,l){this._remappedBufferView.set(q,new Map),this._remappedBufferView.get(q).set(I,l)}getRemappedBufferView(q,I){var l;return null===(l=this._remappedBufferView.get(q))||void 0===l?void 0:l.get(I)}getVertexAccessor(q,I,l){var w,t;return null===(w=this._vertexAccessorMap.get(q))||void 0===w||null===(t=w.get(I))||void 0===t?void 0:t.get(l)}setVertexAccessor(q,I,l,w){let t=this._vertexAccessorMap.get(q);t||(t=new Map,this._vertexAccessorMap.set(q,t));let O=t.get(I);O||(O=new Map,t.set(I,O)),O.set(l,w)}hasVertexColorAlpha(q){return this._vertexMapColorAlpha.get(q)||!1}setHasVertexColorAlpha(q,I){return this._vertexMapColorAlpha.set(q,I)}getMesh(q){return this._meshMap.get(q)}setMesh(q,I){this._meshMap.set(q,I)}bindMorphDataToMesh(q,I){const l=this._meshMorphTargetMap.get(q)||[];this._meshMorphTargetMap.set(q,l),-1===l.indexOf(I)&&l.push(I)}getMorphTargetsFromMesh(q){return this._meshMorphTargetMap.get(q)}}class Yq{_ApplyExtension(q,I,l,w){if(l>=I.length)return Promise.resolve(q);const t=w(I[l],q);return t?t.then((async q=>q?await this._ApplyExtension(q,I,l+1,w):null)):this._ApplyExtension(q,I,l+1,w)}_ApplyExtensions(q,I){const l=[];for(const w of Yq._ExtensionNames)l.push(this._extensions[w]);return this._ApplyExtension(q,l,0,I)}_extensionsPreExportTextureAsync(q,I,l){return this._ApplyExtensions(I,((I,w)=>I.preExportTextureAsync&&I.preExportTextureAsync(q,w,l)))}_extensionsPostExportNodeAsync(q,I,l,w,t){return this._ApplyExtensions(I,((I,O)=>I.postExportNodeAsync&&I.postExportNodeAsync(q,O,l,w,t,this._bufferManager)))}_extensionsPostExportMaterialAsync(q,I,l){return this._ApplyExtensions(I,((I,w)=>I.postExportMaterialAsync&&I.postExportMaterialAsync(q,w,l)))}_extensionsPostExportMaterialAdditionalTextures(q,I,l){const w=[];for(const t of Yq._ExtensionNames){const O=this._extensions[t];O.postExportMaterialAdditionalTextures&&w.push(...O.postExportMaterialAdditionalTextures(q,I,l))}return w}_extensionsPostExportTextures(q,I,l){for(const w of Yq._ExtensionNames){const t=this._extensions[w];t.postExportTexture&&t.postExportTexture(q,I,l)}}_extensionsPostExportMeshPrimitive(q){for(const I of Yq._ExtensionNames){const l=this._extensions[I];l.postExportMeshPrimitive&&l.postExportMeshPrimitive(q,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const q of Yq._ExtensionNames){const I=this._extensions[q];I.preGenerateBinaryAsync&&await I.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(q){for(const I of Yq._ExtensionNames){const l=this._extensions[I];l.enabled&&q(l)}}_extensionsOnExporting(){this._forEachExtensions((q=>{var I,l,w;q.wasUsed&&((I=this._glTF).extensionsUsed||(I.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(q.name)&&this._glTF.extensionsUsed.push(q.name),q.required&&((l=this._glTF).extensionsRequired||(l.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(q.name)&&this._glTF.extensionsRequired.push(q.name)),(w=this._glTF).extensions||(w.extensions={}),q.onExporting&&q.onExporting())}))}_loadExtensions(){for(const q of Yq._ExtensionNames){const I=Yq._ExtensionFactories[q](this);this._extensions[q]=I}}constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:T.e.LastCreatedScene,I=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${d.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new L(this),this._extensions={},this._bufferManager=new Zq,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!q)throw new Error("No scene available to export");this._babylonScene=q,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:q=>{var I;return null===q||void 0===q||null===(I=q.rc)||void 0===I?void 0:I.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...I},this._loadExtensions()}dispose(){for(const q in this._extensions){this._extensions[q].dispose()}}get options(){return this._options}static RegisterExtension(q,I){Yq.UnregisterExtension(q)&&t.Tools.Warn(`Extension with the name ${q} already exists`),Yq._ExtensionFactories[q]=I,Yq._ExtensionNames.push(q)}static UnregisterExtension(q){if(!Yq._ExtensionFactories[q])return!1;delete Yq._ExtensionFactories[q];const I=Yq._ExtensionNames.indexOf(q);return-1!==I&&Yq._ExtensionNames.splice(I,1),!0}_generateJSON(q,I,l){const w={byteLength:q};return w.byteLength&&(this._glTF.buffers=[w]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.VI=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(w.uri=I+".bin"),l?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(q){const I=await this._generateBinaryAsync();this._extensionsOnExporting();const l=this._generateJSON(I.byteLength,q,!0),w=new Blob([I],{type:"application/octet-stream"}),t=q+".gltf",O=q+".bin",c=new s;if(c.files[t]=l,c.files[O]=w,this._imageData)for(const a in this._imageData)c.files[a]=new Blob([this._imageData[a].data],{type:this._imageData[a].mimeType});return c}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(q){const I=q%4;return 0===I?I:4-I}async generateGLBAsync(q){this._shouldUseGlb=!0;const I=await this._generateBinaryAsync();this._extensionsOnExporting();const l=this._generateJSON(I.byteLength),w=q+".glb";let t,O=l.length;if("undefined"!==typeof TextEncoder){t=(new TextEncoder).encode(l),O=t.length}const c=this._getPadding(O),a=this._getPadding(I.byteLength),F=28+O+c+I.byteLength+a,Z=new Fq(F);if(Z.writeUInt32(1179937895),Z.writeUInt32(2),Z.writeUInt32(F),Z.writeUInt32(O+c),Z.writeUInt32(1313821514),t)Z.writeTypedArray(t);else{const q="_".charCodeAt(0);for(let I=0;I<O;++I){const w=l.charCodeAt(I);w!=l.codePointAt(I)?Z.writeUInt8(q):Z.writeUInt8(w)}}for(let s=0;s<c;++s)Z.writeUInt8(32);Z.writeUInt32(I.byteLength+a),Z.writeUInt32(5130562),Z.writeTypedArray(I);for(let s=0;s<a;++s)Z.writeUInt8(0);const r=new s;return r.files[w]=new Blob([Z.getOutputData()],{type:"application/octet-stream"}),r}_setNodeTransformation(q,I,l){if(I.getPivotPoint().equalsWithEpsilon(P,u.d)||t.Tools.Warn("Pivot points are not supported in the glTF serializer"),!I.position.equalsWithEpsilon(P,u.d)){const t=w.TmpVectors.dI[0].t(I.position);l&&A(t),q.translation=t.Uc()}I.Xc.equalsWithEpsilon(Y,u.d)||(q.scale=I.Xc.Uc());const O=I.rotationQuaternion||w.Quaternion.FromEulerAngles(I.rotation.x,I.rotation.y,I.rotation.z);O.equalsWithEpsilon(mq,u.d)||(l&&Q(O),q.rotation=O.normalize().Uc())}_setCameraTransformation(q,I,l){if(!I.position.equalsWithEpsilon(P,u.d)){const t=w.TmpVectors.dI[0].t(I.position);l&&A(t),q.translation=t.Uc()}const t=I.rotationQuaternion||w.Quaternion.FromEulerAngles(I.rotation.x,I.rotation.y,I.rotation.z);l&&Q(t),this._babylonScene.useRightHandedSystem||b(t),t.equalsWithEpsilon(mq,u.d)||(q.rotation=t.Uc())}_listAvailableCameras(){for(const q of this._babylonScene.cameras){const I={type:q.mode===xq.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(q.name&&(I.name=q.name),"perspective"===I.type)I.perspective={aspectRatio:q.getEngine().getAspectRatio(q),yfov:q.fovMode===xq.d.FOVMODE_VERTICAL_FIXED?q.fov:q.fov*q.getEngine().getAspectRatio(q),znear:q.vc,zfar:q.maxZ};else if("orthographic"===I.type){const l=q.orthoLeft&&q.orthoRight?.5*(q.orthoRight-q.orthoLeft):.5*q.getEngine().getRenderWidth(),w=q.orthoBottom&&q.orthoTop?.5*(q.orthoTop-q.orthoBottom):.5*q.getEngine().getRenderHeight();I.orthographic={xmag:l,ymag:w,znear:q.vc,zfar:q.maxZ}}this._camerasMap.set(q,I)}}_exportAndAssignCameras(){const q=Array.from(this._camerasMap.values());for(const I of q){const q=this._nodesCameraMap.get(I);if(void 0!==q){this._cameras.push(I);for(const I of q)I.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const q of this._babylonScene.skeletons){if(q.bones.length<=0)continue;const I={joints:[]};this._skinMap.set(q,I)}}_exportAndAssignSkeletons(){for(const q of this._babylonScene.skeletons){if(q.bones.length<=0)continue;const I=this._skinMap.get(q);if(void 0==I)continue;const l={},w=[];let O=-1;for(let t=0;t<q.bones.length;++t){const I=q.bones[t],w=I.getIndex()??t;-1!==w&&(l[w]=I,w>O&&(O=w))}for(let q=0;q<=O;++q){const O=l[q];w.push(O.getAbsoluteInverseBindMatrix());const c=O.getTransformNode();if(null!==c){const q=this._nodeMap.get(c);c&&null!==q&&void 0!==q?I.joints.push(q):t.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else t.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const c=this._nodesSkinMap.get(I);if(I.joints.length>0&&void 0!==c){const q=64*w.length,l=new Float32Array(q/4);w.forEach(((q,I)=>{l.set(q.m,16*I)}));const t=this._bufferManager.createBufferView(l);this._accessors.push(this._bufferManager.createAccessor(t,"MAT4",5126,w.length)),I.inverseBindMatrices=this._accessors.length-1,this._skins.push(I);for(const I of c)I.skin=this._skins.length-1}}}async _exportSceneAsync(){const q={nodes:[]};if(this._babylonScene.metadata){const I=this._options.metadataSelector(this._babylonScene.metadata);I&&(q.extras=I)}const I=new Array,l=new Array,w=new Array;for(const a of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&cq(a,this._babylonScene.useRightHandedSystem)?w.push(...a.getChildren()):this._babylonScene.useRightHandedSystem?I.push(a):l.push(a);this._listAvailableCameras(),this._listAvailableSkeletons();const t=new mI(!0,!1);q.nodes.push(...await this._exportNodesAsync(l,t));const O=new mI(!1,!1);q.nodes.push(...await this._exportNodesAsync(I,O));const c=new mI(!1,!0);q.nodes.push(...await this._exportNodesAsync(w,c)),q.nodes.length&&this._scenes.push(q),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&kq._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,t.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(q){let I=this._shouldExportNodeMap.get(q);return void 0===I&&(I=this._options.shouldExportNode(q),this._shouldExportNodeMap.set(q,I)),I}async _exportNodesAsync(q,I){const l=new Array;this._exportBuffers(q,I);for(const w of q)await this._exportNodeAsync(w,l,I);return l}_collectBuffers(q,I,l,w,t){if(this._shouldExportNode(q)&&q instanceof x.b&&q.Wc){const O=q.Wc.getVertexBuffers();if(O)for(const w in O){if(!J(w))continue;const c=O[w];t.setHasVertexColorAlpha(c,q.hasVertexAlpha);const a=c._buffer,F=I.get(a)||[];I.set(a,F),-1===F.indexOf(c)&&F.push(c);const s=l.get(c)||[];l.set(c,s),-1===s.indexOf(q)&&s.push(q)}const c=q.morphTargetManager;if(c)for(let I=0;I<c.numTargets;I++){const l=c.getTarget(I),t=w.get(l)||[];w.set(l,t),-1===t.indexOf(q)&&t.push(q)}}for(const O of q.getChildren())this._collectBuffers(O,I,l,w,t)}_exportBuffers(q,I){const l=new Map,w=new Map,t=new Map;for(const a of q)this._collectBuffers(a,l,w,t,I);const O=Array.from(l.keys());for(const a of O){const q=a.getData();if(!q)throw new Error("Buffer data is not available");const t=l.get(a);if(!t)continue;const O=t[0].byteStride;if(t.some((q=>q.byteStride!==O)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const c=lq(q).slice();for(const I of t){const q=w.get(I),{byteOffset:l,byteStride:t,componentCount:O,type:a,count:F,normalized:s,kind:r}=G(I,q);switch(r){case Z.c.NormalKind:case Z.c.TangentKind:(0,E.h)(c,l,t,O,a,F,s,(q=>{const I=Math.sqrt(q[0]*q[0]+q[1]*q[1]+q[2]*q[2]);if(I>0){const l=1/I;q[0]*=l,q[1]*=l,q[2]*=l}}));break;case Z.c.ColorKind:{const I=q.filter((q=>q.material instanceof Tq.UI||null==q.material)).length;if(0==I)break;if(I!=q.length){j.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}a==Z.c.UNSIGNED_BYTE&&j.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const w=new V.BI,r=new V.Dc,x=this._babylonScene.getEngine().useExactSrgbConversions;(0,E.h)(c,l,t,O,a,F,s,(q=>{3===q.length?(w.dl(q,0),w.toLinearSpaceToRef(w,x),w.toArray(q,0)):(r.dl(q,0),r.toLinearSpaceToRef(r,x),r.toArray(q,0))}))}}}if(I.convertToRightHanded){for(const q of t){const I=w.get(q),{byteOffset:l,byteStride:t,componentCount:O,type:a,count:F,normalized:s,kind:r}=G(q,I);switch(r){case Z.c.PositionKind:case Z.c.NormalKind:case Z.c.TangentKind:(0,E.h)(c,l,t,O,a,F,s,(q=>{q[0]=-q[0]}))}}I.convertedToRightHandedBuffers.set(a,c)}const F=this._bufferManager.createBufferView(c,O);I.setVertexBufferView(a,F);const s=new Map;for(const I of t){const q=w.get(I),{kind:l,totalVertices:t}=G(I,q);switch(l){case Z.c.MatricesIndicesKind:case Z.c.MatricesIndicesExtraKind:if(I.type==Z.c.FLOAT){const q=I.getFloatData(t);null!==q&&s.set(I,q)}}}0!==s.size&&j.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const r=Array.from(s.keys());for(const l of r){const q=s.get(l);if(!q)continue;const w=q.some((q=>q>=256)),t=new(w?Uint16Array:Uint8Array)(q.length);for(let I=0;I<q.length;I++)t[I]=q[I];const O=this._bufferManager.createBufferView(t,4*(w?2:1));I.setRemappedBufferView(a,l,O)}}const c=Array.from(t.keys());for(const a of c){const q=t.get(a);if(!q)continue;const l=Cq(a,q[0],this._bufferManager,this._bufferViews,this._accessors,I.convertToRightHanded);for(const w of q)I.bindMorphDataToMesh(w,l)}}async _exportNodeAsync(q,I,l){let w=this._nodeMap.get(q);if(void 0!==w)return void(I.includes(w)||I.push(w));const t=await this._createNodeAsync(q,l);if(t){w=this._nodes.length,this._nodes.push(t),this._nodeMap.set(q,w),l.pushExportedNode(q),I.push(w);const O={name:"runtime animations",channels:[],samplers:[]},c=[];this._babylonScene.animationGroups.length||(kq._CreateMorphTargetAnimationFromMorphTargetAnimations(q,O,c,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,l.convertToRightHanded,this._options.shouldExportAnimation),q.animations.length&&kq._CreateNodeAnimationFromNodeAnimations(q,O,c,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,l.convertToRightHanded,this._options.shouldExportAnimation)),O.channels.length&&O.samplers.length&&this._animations.push(O),c.forEach((q=>{q.channels.length&&q.samplers.length&&this._animations.push(q)}))}const O=t?[]:I;for(const c of q.getChildren())await this._exportNodeAsync(c,O,l);t&&O.length&&(t.children=O)}async _createNodeAsync(q,I){if(!this._shouldExportNode(q))return null;const l={};if(q.name&&(l.name=q.name),q.metadata){const I=this._options.metadataSelector(q.metadata);I&&(l.extras=I)}if(q instanceof r.d&&(this._setNodeTransformation(l,q,I.convertToRightHanded),q instanceof x.b)){const t=q instanceof o.e?q.sourceMesh:q;if(t.Tc&&t.Tc.length>0&&(l.mesh=await this._exportMeshAsync(t,I)),q.skeleton){const I=this._skinMap.get(q.skeleton);var w;if(void 0!==I)void 0===this._nodesSkinMap.get(I)&&this._nodesSkinMap.set(I,[]),null===(w=this._nodesSkinMap.get(I))||void 0===w||w.push(l)}}if(q instanceof h.c){const w=this._camerasMap.get(q);if(w){var t;void 0===this._nodesCameraMap.get(w)&&this._nodesCameraMap.set(w,[]),this._setCameraTransformation(l,q,I.convertToRightHanded);const c=q.parent;if(null!==c&&Iq(q,c)){const q=this._nodeMap.get(c);if(void 0!==q){var O;const I=this._nodes[q];return qq(l,I),null===(O=this._nodesCameraMap.get(w))||void 0===O||O.push(I),null}}null===(t=this._nodesCameraMap.get(w))||void 0===t||t.push(l)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",l,q,this._nodeMap,I.convertToRightHanded)?l:(j.b.Warn(`Not exporting node ${q.name}`),null)}_exportIndices(q,I,l,w,t,c,a,F,s){let Z=q;s.mode=z(c);const r=a!==O.c.CounterClockWiseSideOrientation,x=!F.wasAddedByNoopNode&&r,o=function(q){switch(q){case O.c.TriangleFillMode:case O.c.TriangleStripDrawMode:case O.c.TriangleFanDrawMode:return!0}return!1}(c)&&x;if(o){if(c===O.c.TriangleStripDrawMode||c===O.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");s.mode=z(c);const a=I?new Uint32Array(w):new Uint16Array(w);if(q)for(let I=0;I+2<w;I+=3)a[I]=q[l+I]+t,a[I+1]=q[l+I+2]+t,a[I+2]=q[l+I+1]+t;else for(let q=0;q+2<w;q+=3)a[q]=q,a[q+1]=q+2,a[q+2]=q+1;Z=a}else if(q&&0!==t){const O=I?new Uint32Array(w):new Uint16Array(w);for(let I=0;I<w;I++)O[I]=q[l+I]+t;Z=O}if(Z){let O=F.getIndicesAccessor(q,l,w,t,o);if(void 0===O){const c=function(q,I,l,w){if(q instanceof Uint16Array||q instanceof Uint32Array)return q;if(q instanceof Int32Array)return new Uint32Array(q.buffer,q.byteOffset,q.length);const t=q.slice(I,I+l);return w?new Uint32Array(t):new Uint16Array(t)}(Z,0,w,I),a=this._bufferManager.createBufferView(c),s=I?5125:5123;this._accessors.push(this._bufferManager.createAccessor(a,"SCALAR",s,w,0)),O=this._accessors.length-1,F.setIndicesAccessor(q,l,w,t,o,O)}s.indices=O}}_exportVertexBuffer(q,I,l,w,t,O){const c=q.getKind();if(!J(c))return;if(c.startsWith("uv")&&!this._options.exportUnusedUVs&&(!I||!this._materialNeedsUVsSet.has(I)))return;let a=t.getVertexAccessor(q,l,w);if(void 0===a){const I=t.convertedToRightHandedBuffers.get(q._buffer)||q._buffer.getData(),O=c===Z.c.PositionKind?function(q,I,l,w){const{byteOffset:t,byteStride:O,type:c,normalized:a}=I,F=I.getSize(),s=new Array(F).fill(1/0),Z=new Array(F).fill(-1/0);return(0,E.h)(q,t+l*O,O,F,c,w*F,a,(q=>{for(let I=0;I<F;I++)s[I]=Math.min(s[I],q[I]),Z[I]=Math.max(Z[I],q[I])})),{min:s,max:Z}}(I,q,l,w):void 0,F=(c===Z.c.MatricesIndicesKind||c===Z.c.MatricesIndicesExtraKind)&&q.type===Z.c.FLOAT,s=F?Z.c.UNSIGNED_BYTE:q.type,r=F?void 0:q.normalized,x=F?t.getRemappedBufferView(q._buffer,q):t.getVertexBufferView(q._buffer),o=q.byteOffset+l*q.byteStride;this._accessors.push(this._bufferManager.createAccessor(x,function(q,I){if(q==Z.c.ColorKind)return I?"VEC4":"VEC3";switch(q){case Z.c.PositionKind:case Z.c.NormalKind:return"VEC3";case Z.c.TangentKind:case Z.c.MatricesIndicesKind:case Z.c.MatricesIndicesExtraKind:case Z.c.MatricesWeightsKind:case Z.c.MatricesWeightsExtraKind:return"VEC4";case Z.c.UVKind:case Z.c.UV2Kind:case Z.c.UV3Kind:case Z.c.UV4Kind:case Z.c.UV5Kind:case Z.c.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${q}`)}(c,t.hasVertexColorAlpha(q)),s,w,o,O,r)),a=this._accessors.length-1,t.setVertexAccessor(q,l,w,a)}O.attributes[function(q){switch(q){case Z.c.PositionKind:return"POSITION";case Z.c.NormalKind:return"NORMAL";case Z.c.TangentKind:return"TANGENT";case Z.c.ColorKind:return"COLOR_0";case Z.c.UVKind:return"TEXCOORD_0";case Z.c.UV2Kind:return"TEXCOORD_1";case Z.c.UV3Kind:return"TEXCOORD_2";case Z.c.UV4Kind:return"TEXCOORD_3";case Z.c.UV5Kind:return"TEXCOORD_4";case Z.c.UV6Kind:return"TEXCOORD_5";case Z.c.MatricesIndicesKind:return"JOINTS_0";case Z.c.MatricesIndicesExtraKind:return"JOINTS_1";case Z.c.MatricesWeightsKind:return"WEIGHTS_0";case Z.c.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${q}`)}(c)]=a}async _exportMaterialAsync(q,I,l,w){let t=this._materialMap.get(q);if(void 0===t){const w=I&&Object.keys(I).some((q=>q.startsWith("uv")));if((q=q instanceof oq.b?q.Mc[l.materialIndex]:q)instanceof dq.c)t=await this._materialExporter.exportPBRMaterialAsync(q,"image/png",w);else{if(!(q instanceof Tq.UI))return void j.b.Warn(`Unsupported material '${q.name}' with type ${q.getClassName()}`);t=await this._materialExporter.exportStandardMaterialAsync(q,"image/png",w)}this._materialMap.set(q,t)}w.material=t}async _exportMeshAsync(q,I){var l;let w=I.getMesh(q);if(void 0!==w)return w;const t={primitives:[]};w=this._meshes.length,this._meshes.push(t),I.setMesh(q,w);const c=q.isUnIndexed?null:q.ec(),a=null===(l=q.Wc)||void 0===l?void 0:l.getVertexBuffers(),F=I.getMorphTargetsFromMesh(q),s=q instanceof Rq.d,Z=q instanceof Pq,r=q.Tc;if(a&&r&&r.length>0)for(const d of r){const l={attributes:{}},w=d.Lq()||this._babylonScene.defaultMaterial;if(Z){var x,o;const I={name:w.name},t=q,O=V.BI.White(),c=(null===(x=t.material)||void 0===x?void 0:x.alpha)??1,a=(null===(o=t.greasedLineMaterial)||void 0===o?void 0:o.color)??O;(!a.equalsWithEpsilon(O,u.d)||c<1)&&(I.pbrMetallicRoughness={baseColorFactor:[...a.Uc(),c]}),this._materials.push(I),l.material=this._materials.length-1}else if(s){const I={name:w.name},t=q;(!t.color.equalsWithEpsilon(V.BI.White(),u.d)||t.alpha<1)&&(I.pbrMetallicRoughness={baseColorFactor:[...t.color.Uc(),t.alpha]}),this._materials.push(I),l.material=this._materials.length-1}else await this._exportMaterialAsync(w,a,d,l);const r=s||Z?O.c.LineListDrawMode:q.overrideRenderingFillMode??w.fillMode,T=w._getEffectiveOrientation(q);this._exportIndices(c,c?(0,E.d)(c,d.indexCount,d.indexStart,d.verticesStart):d.verticesCount>65535,c?d.indexStart:d.verticesStart,c?d.indexCount:d.verticesCount,-d.verticesStart,r,T,I,l);for(const q of Object.values(a))this._exportVertexBuffer(q,w,d.verticesStart,d.verticesCount,I,l);if(F){l.targets=[];for(const q of F)l.targets.push(q.attributes)}t.primitives.push(l),this._extensionsPostExportMeshPrimitive(l)}if(F){t.weights=[],t.extras||(t.extras={}),t.extras.targetNames=[];for(const q of F)t.weights.push(q.influence),t.extras.targetNames.push(q.name)}return w}}Yq._ExtensionNames=new Array,Yq._ExtensionFactories={};class yq{static async GLTFAsync(q,I,l){l&&l.exportWithoutWaitingForScene||await q.whenReadyAsync();const w=new Yq(q,l),t=await w.generateGLTFAsync(I.replace(/\.[^/.]+$/,""));return w.dispose(),t}static async GLBAsync(q,I,l){l&&l.exportWithoutWaitingForScene||await q.whenReadyAsync();const w=new Yq(q,l),t=await w.generateGLBAsync(I.replace(/\.[^/.]+$/,""));return w.dispose(),t}}l(13279);const Gq="EXT_mesh_gpu_instancing";class Nq{constructor(q){this.name=Gq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(q,I,l,t,O,c){return await new Promise((q=>{if(I&&l instanceof Bq.c&&l.hasThinInstances&&this._exporter){this._wasUsed=!0;const q=w.dI.Zero(),t=w.Quaternion.Identity(),a=w.dI.One(),F=l.thinInstanceGetWorldMatrices(),s=w.TmpVectors.dI[2],Z=w.TmpVectors.Quaternion[1],r=w.TmpVectors.dI[3];let x=!1,o=!1,d=!1;const T=new Float32Array(3*l.nc),V=new Float32Array(4*l.nc),U=new Float32Array(3*l.nc);let B=0;for(const I of F)I.decompose(r,Z,s),O&&(A(s),Q(Z)),T.set(s.Uc(),3*B),V.set(Z.normalize().Uc(),4*B),U.set(r.Uc(),3*B),x=x||!s.equalsWithEpsilon(q),o=o||!Z.equalsWithEpsilon(t),d=d||!r.equalsWithEpsilon(a),B++;const v={attributes:{}};x&&(v.attributes.TRANSLATION=this._buildAccessor(T,"VEC3",l.nc,c)),o&&(v.attributes.ROTATION=this._buildAccessor(V,"VEC4",l.nc,c)),d&&(v.attributes.SCALE=this._buildAccessor(U,"VEC3",l.nc,c)),I.extensions=I.extensions||{},I.extensions[Gq]=v}q(I)}))}_buildAccessor(q,I,l,w){const t=w.createBufferView(q),O=w.createAccessor(t,I,5126,l);return this._exporter._accessors.push(O),this._exporter._accessors.length-1}}Yq.RegisterExtension(Gq,(q=>new Nq(q)));var Jq=l(13283),zq=l(13290),Hq=l(13293),Aq=l(13295);function Qq(q){return q===Hq.c.PositionKind?"POSITION":q===Hq.c.NormalKind?"NORMAL":q===Hq.c.ColorKind?"COLOR":q.startsWith(Hq.c.UVKind)?"TEX_COORD":"GENERIC"}const bq={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class qI extends Jq.b{static get DefaultAvailable(){return(0,Jq.g)(qI.DefaultConfiguration)}static get Default(){return qI._Default??(qI._Default=new qI),qI._Default}static ResetDefault(q){qI._Default&&(q||qI._Default.dispose(),qI._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(q,I){return{module:await(I||DracoEncoderModule)({wasmBinary:q})}}_getWorkerContent(){return`${zq.f}(${zq.g})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:qI.DefaultConfiguration)}async _encodeAsync(q,I,l){const w=l?(0,Aq.d)(bq,l):bq;if(this._workerPoolPromise){const l=await this._workerPoolPromise;return await new Promise(((t,O)=>{l.push(((l,c)=>{const a=q=>{l.removeEventListener("error",a),l.removeEventListener("message",F),O(q),c()},F=q=>{"encodeMeshDone"===q.data.id&&(l.removeEventListener("error",a),l.removeEventListener("message",F),t(q.data.encodedMeshData),c())};l.addEventListener("error",a),l.addEventListener("message",F);const s=[];for(const I of q)s.push(I.data.buffer);I&&s.push(I.buffer),l.postMessage({id:"encodeMesh",attributes:q,indices:I,options:w},s)}))}))}if(this._modulePromise){const l=await this._modulePromise;return(0,zq.f)(l.module,q,I,w)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(q,I){if(0==q.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");q instanceof Bq.c&&q.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===I||void 0===I?void 0:I.method)&&(j.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),I.method="MESH_SEQUENTIAL_ENCODING");const l=function(q){let I=q.ec(void 0,!0);return!I||I instanceof Uint32Array||I instanceof Uint16Array||(I=((0,E.d)(I,I.length)?Uint32Array:Uint16Array).from(I)),I}(q),w=function(q,I){const l=[];for(const w of q.getVerticesDataKinds()){if(null!==I&&void 0!==I&&I.includes(w)){if(w===Hq.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const t=q.getVertexBuffer(w),O=t.getSize(),c=(0,E.o)(t.getData(),O,t.type,t.byteOffset,t.byteStride,t.normalized,q.getTotalVertices(),!0);l.push({kind:w,dracoName:Qq(w),size:O,data:c})}return l}(q,null===I||void 0===I?void 0:I.excludedAttributes);return await this._encodeAsync(w,l,I)}}qI.DefaultConfiguration={wasmUrl:`${t.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${t.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${t.Tools._DefaultCdnUrl}/draco_encoder.js`},qI._Default=null;const II="KHR_draco_mesh_compression";class lI{get wasUsed(){return this._wasUsed}constructor(q){this.name=II,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===q.options.meshCompressionMethod&&qI.DefaultAvailable}dispose(){}postExportMeshPrimitive(q,I,l){if(!this.enabled)return;if(4!==q.mode&&5!==q.mode)return void j.b.Warn("Cannot compress primitive with mode "+q.mode+".");const w=[],t=[];let O=null;if(void 0!==q.indices){const c=l[q.indices],a=I.getBufferView(c);O=I.getData(a).slice(),w.push(a),t.push(c)}const c=[];for(const[Z,r]of Object.entries(q.attributes)){const q=l[r],O=I.getBufferView(q),F=N(q.type),s=(0,E.o)(I.getData(O),F,q.componentType,q.byteOffset||0,O.byteStride||(0,E.k)(q.componentType)*F,q.normalized||!1,q.count,!0);c.push({kind:Z,dracoName:(a=Z,"POSITION"===a?"POSITION":"NORMAL"===a?"NORMAL":a.startsWith("COLOR")?"COLOR":a.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:N(q.type),data:s}),w.push(O),t.push(q)}var a;const F={method:q.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},s=qI.Default._encodeAsync(c,O,F).then((l=>{if(!l)return void j.b.Error("Draco encoding failed for primitive.");const O={bufferView:-1,attributes:l.attributeIds},c=I.createBufferView(l.data);I.setBufferView(O,c);for(const q of w)this._bufferViewsUsed.add(q);for(const q of t)this._accessorsUsed.add(q);q.extensions||(q.extensions={}),q.extensions[II]=O})).catch((q=>{j.b.Error("Draco encoding failed for primitive: "+q)}));this._encodePromises.push(s),this._wasUsed=!0}async preGenerateBinaryAsync(q){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((I=>{q.getPropertiesWithBufferView(I).every((q=>this._accessorsUsed.has(q)))&&q.removeBufferView(I)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Yq.RegisterExtension(II,(q=>new lI(q)));var wI=l(13301);const tI="KHR_lights_punctual",OI={name:"",color:[1,1,1],Ec:1,range:Number.MAX_VALUE},cI={innerConeAngle:0,outerConeAngle:Math.PI/4},aI=w.dI.Backward();class FI{constructor(q){this.name=tI,this.enabled=!0,this.required=!1,this._exporter=q}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[tI]=this._lights}async postExportNodeAsync(q,I,l,t,O){return await new Promise((c=>{if(!(l instanceof vq.d))return void c(I);const a=l.getTypeID()==vq.d.LIGHTTYPEID_POINTLIGHT?"point":l.getTypeID()==vq.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":l.getTypeID()==vq.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!a||!(l instanceof wI.d))return j.b.Warn(`${q}: Light ${l.name} is not supported in ${tI}`),void c(I);if(l.falloffType!==vq.d.FALLOFF_GLTF&&j.b.Warn(`${q}: Light falloff for ${l.name} does not match the ${tI} specification!`),!l.position.equalsToFloats(0,0,0)){const q=w.TmpVectors.dI[0].t(l.position);O&&A(q),I.translation=q.Uc()}if("point"!==a){const q=l.direction.normalizeToRef(w.TmpVectors.dI[0]);O&&A(q);const t=w.Quaternion.FromUnitVectorsToRef(aI,q,w.TmpVectors.Quaternion[0]);w.Quaternion.IsIdentity(t)||(I.rotation=t.Uc())}const F={type:a,name:l.name,color:l.jc.Uc(),Ec:l.Ec,range:l.range};if(wq(F,OI),"spot"===a){const q=l;F.spot={innerConeAngle:q.innerAngle/2,outerConeAngle:q.angle/2},wq(F.spot,cI)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(F);const s={qc:this._lights.lights.length-1},Z=l.parent;if(Z&&Iq(l,Z)){const q=t.get(Z);if(q){const l=this._exporter._nodes[q];return qq(I,l),l.extensions||(l.extensions={}),l.extensions[tI]=s,void c(null)}}I.extensions||(I.extensions={}),I.extensions[tI]=s,c(I)}))}}Yq.RegisterExtension(tI,(q=>new FI(q)));var sI=l(13233);const ZI="KHR_materials_anisotropy";class rI{constructor(q){this.name=ZI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,I,l){const w=[];return l instanceof sI.d&&l.anisotropy.isEnabled&&!l.anisotropy.legacy?(l.anisotropy.texture&&w.push(l.anisotropy.texture),w):[]}postExportMaterialAsync(q,I,l){return new Promise((q=>{if(l instanceof sI.d){if(!l.anisotropy.isEnabled||l.anisotropy.legacy)return void q(I);this._wasUsed=!0,I.extensions=I.extensions||{};const w=this._exporter._materialExporter.getTextureInfo(l.anisotropy.texture),t={anisotropyStrength:l.anisotropy.Ec,anisotropyRotation:l.anisotropy.angle,anisotropyTexture:w??void 0};null!==t.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(l),I.extensions[ZI]=t}q(I)}))}}Yq.RegisterExtension(ZI,(q=>new rI(q)));const xI="KHR_materials_clearcoat";class oI{constructor(q){this.name=xI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,I,l){const w=[];return l instanceof sI.d&&l.clearCoat.isEnabled?(l.clearCoat.texture&&w.push(l.clearCoat.texture),!l.clearCoat.useRoughnessFromMainTexture&&l.clearCoat.textureRoughness&&w.push(l.clearCoat.textureRoughness),l.clearCoat.bumpTexture&&w.push(l.clearCoat.bumpTexture),w):[]}postExportMaterialAsync(q,I,l){return new Promise((q=>{if(l instanceof sI.d){if(!l.clearCoat.isEnabled)return void q(I);this._wasUsed=!0,I.extensions=I.extensions||{};const w=this._exporter._materialExporter.getTextureInfo(l.clearCoat.texture);let O;O=l.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(l.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(l.clearCoat.textureRoughness),l.clearCoat.isTintEnabled&&t.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${l.name}`),l.clearCoat.remapF0OnInterfaceChange&&t.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${l.name}`);const c=this._exporter._materialExporter.getTextureInfo(l.clearCoat.bumpTexture),a={clearcoatFactor:l.clearCoat.Ec,clearcoatTexture:w??void 0,clearcoatRoughnessFactor:l.clearCoat.roughness,clearcoatRoughnessTexture:O??void 0,clearcoatNormalTexture:c??void 0};null===a.clearcoatTexture&&null===a.clearcoatRoughnessTexture&&null===a.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(l),I.extensions[xI]=a}q(I)}))}}Yq.RegisterExtension(xI,(q=>new oI(q)));const dI="KHR_materials_diffuse_transmission";function TI(q,I){const l=I.subSurface;let w=null;return l.translucencyIntensityTexture?w=l.translucencyIntensityTexture:l.thicknessTexture&&l.useMaskFromThicknessTexture&&(w=l.thicknessTexture),w&&!l.useGltfStyleTextures?(j.b.Warn(`${q}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${I.name}`,1),null):w}class VI{constructor(q){this.name=dI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,I,l){const w=[];if(l instanceof dq.c&&this._isExtensionEnabled(l)){const I=TI(q,l);return I&&w.push(I),l.subSurface.translucencyColorTexture&&w.push(l.subSurface.translucencyColorTexture),w}return w}_isExtensionEnabled(q){if(q.unlit)return!1;const I=q.subSurface;return!!I.isTranslucencyEnabled&&(!q.unlit&&!I.useAlbedoToTintTranslucency&&I.useGltfStyleTextures&&1===I.volumeIndexOfRefraction&&0===I.minimumThickness&&0===I.maximumThickness)}postExportMaterialAsync(q,I,l){return new Promise((w=>{if(l instanceof dq.c&&this._isExtensionEnabled(l)){this._wasUsed=!0;const w=l.subSurface,t=TI(q,l),O=0==w.translucencyIntensity?void 0:w.translucencyIntensity,c=this._exporter._materialExporter.getTextureInfo(t)??void 0,a=!w.translucencyColor||w.translucencyColor.equalsFloats(1,1,1)?void 0:w.translucencyColor.Uc(),F=this._exporter._materialExporter.getTextureInfo(w.translucencyColorTexture)??void 0,s={diffuseTransmissionFactor:O,diffuseTransmissionTexture:c,diffuseTransmissionColorFactor:a,diffuseTransmissionColorTexture:F};(c||F)&&this._exporter._materialNeedsUVsSet.add(l),I.extensions=I.extensions||{},I.extensions[dI]=s}w(I)}))}}Yq.RegisterExtension(dI,(q=>new VI(q)));const UI="KHR_materials_dispersion";class BI{constructor(){this.name=UI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(q){if(q.unlit)return!1;const I=q.subSurface;return!(!I.isRefractionEnabled&&!I.isDispersionEnabled)}postExportMaterialAsync(q,I,l){return new Promise((q=>{if(l instanceof dq.c&&this._isExtensionEnabled(l)){this._wasUsed=!0;const q={dispersion:l.subSurface.dispersion};I.extensions=I.extensions||{},I.extensions[UI]=q}q(I)}))}}Yq.RegisterExtension(UI,(()=>new BI));const vI="KHR_materials_emissive_strength";class kI{constructor(){this.name=vI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(q,I,l){return await new Promise((q=>{if(!(l instanceof dq.c))return q(I);const w=l.emissiveColor.Uc(),t=Math.max(...w);if(t>1){this._wasUsed=!0,I.extensions||(I.extensions={});const q={emissiveStrength:t},w=l.emissiveColor.scale(1/q.emissiveStrength);I.emissiveFactor=w.Uc(),I.extensions[vI]=q}return q(I)}))}}Yq.RegisterExtension(vI,(q=>new kI));const CI="KHR_materials_ior";class RI{constructor(){this.name=CI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(q){return!q.unlit&&(void 0!=q.indexOfRefraction&&1.5!=q.indexOfRefraction)}postExportMaterialAsync(q,I,l){return new Promise((q=>{if(l instanceof dq.c&&this._isExtensionEnabled(l)){this._wasUsed=!0;const q={ior:l.indexOfRefraction};I.extensions=I.extensions||{},I.extensions[CI]=q}q(I)}))}}Yq.RegisterExtension(CI,(q=>new RI));const WI="KHR_materials_iridescence";class eI{constructor(q){this.name=WI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,I,l){const w=[];return l instanceof sI.d&&l.iridescence.isEnabled?(l.iridescence.texture&&w.push(l.iridescence.texture),l.iridescence.thicknessTexture&&l.iridescence.thicknessTexture!==l.iridescence.texture&&w.push(l.iridescence.thicknessTexture),w):[]}postExportMaterialAsync(q,I,l){return new Promise((q=>{if(l instanceof sI.d){if(!l.iridescence.isEnabled)return void q(I);this._wasUsed=!0,I.extensions=I.extensions||{};const w=this._exporter._materialExporter.getTextureInfo(l.iridescence.texture),t=this._exporter._materialExporter.getTextureInfo(l.iridescence.thicknessTexture),O={iridescenceFactor:l.iridescence.Ec,iridescenceIor:l.iridescence.indexOfRefraction,iridescenceThicknessMinimum:l.iridescence.minimumThickness,iridescenceThicknessMaximum:l.iridescence.maximumThickness,iridescenceTexture:w??void 0,iridescenceThicknessTexture:t??void 0};null===O.iridescenceTexture&&null===O.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(l),I.extensions[WI]=O}q(I)}))}}Yq.RegisterExtension(WI,(q=>new eI(q)));const iI="KHR_materials_sheen";class SI{constructor(q){this.name=iI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,I,l){return l instanceof dq.c&&l.sheen.isEnabled&&l.sheen.texture?[l.sheen.texture]:[]}async postExportMaterialAsync(q,I,l){return await new Promise((q=>{if(l instanceof dq.c){if(!l.sheen.isEnabled)return void q(I);this._wasUsed=!0,null==I.extensions&&(I.extensions={});const w={sheenColorFactor:l.sheen.color.Uc(),sheenRoughnessFactor:l.sheen.roughness??0};null===w.sheenColorTexture&&null===w.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(l),l.sheen.texture&&(w.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(l.sheen.texture)??void 0),l.sheen.textureRoughness&&!l.sheen.useRoughnessFromMainTexture?w.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(l.sheen.textureRoughness)??void 0:l.sheen.texture&&l.sheen.useRoughnessFromMainTexture&&(w.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(l.sheen.texture)??void 0),I.extensions[iI]=w}q(I)}))}}Yq.RegisterExtension(iI,(q=>new SI(q)));const gI="KHR_materials_specular";class pI{constructor(q){this.name=gI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,I,l){const w=[];return l instanceof dq.c&&this._isExtensionEnabled(l)?(l.metallicReflectanceTexture&&w.push(l.metallicReflectanceTexture),l.reflectanceTexture&&w.push(l.reflectanceTexture),w):w}_isExtensionEnabled(q){return!q.unlit&&(void 0!=q.metallicF0Factor&&1!=q.metallicF0Factor||void 0!=q.metallicReflectanceColor&&!q.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(q))}_hasTexturesExtension(q){return null!=q.metallicReflectanceTexture||null!=q.reflectanceTexture}postExportMaterialAsync(q,I,l){return new Promise((q=>{if(l instanceof dq.c&&this._isExtensionEnabled(l)){this._wasUsed=!0,I.extensions=I.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(l.metallicReflectanceTexture)??void 0,w=this._exporter._materialExporter.getTextureInfo(l.reflectanceTexture)??void 0,t={specularFactor:1==l.metallicF0Factor?void 0:l.metallicF0Factor,specularTexture:q,specularColorFactor:l.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:l.metallicReflectanceColor.Uc(),specularColorTexture:w};this._hasTexturesExtension(l)&&this._exporter._materialNeedsUVsSet.add(l),I.extensions[gI]=t}q(I)}))}}Yq.RegisterExtension(gI,(q=>new pI(q)));const XI="KHR_materials_transmission";class KI{constructor(q){this.name=XI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,I,l){const w=[];return l instanceof dq.c&&this._isExtensionEnabled(l)?(l.subSurface.thicknessTexture&&w.push(l.subSurface.thicknessTexture),w):w}_isExtensionEnabled(q){if(q.unlit)return!1;const I=q.subSurface;return I.isRefractionEnabled&&void 0!=I.refractionIntensity&&0!=I.refractionIntensity||this._hasTexturesExtension(q)}_hasTexturesExtension(q){return null!=q.subSurface.refractionIntensityTexture}async postExportMaterialAsync(q,I,l){if(l instanceof dq.c&&this._isExtensionEnabled(l)){this._wasUsed=!0;const w=l.subSurface,t={transmissionFactor:0===w.refractionIntensity?void 0:w.refractionIntensity};if(this._hasTexturesExtension(l)&&this._exporter._materialNeedsUVsSet.add(l),w.refractionIntensityTexture)if(w.useGltfStyleTextures){const q=await this._exporter._materialExporter.exportTextureAsync(w.refractionIntensityTexture,"image/png");q&&(t.transmissionTexture=q)}else j.b.Warn(`${q}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);I.extensions||(I.extensions={}),I.extensions[XI]=t}return I}}Yq.RegisterExtension(XI,(q=>new KI(q)));const DI="KHR_materials_unlit";class MI{constructor(){this.name=DI,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(q,I,l){return new Promise((q=>{let w=!1;l instanceof dq.c?w=l.unlit:l instanceof Tq.UI&&(w=l.disableLighting),w&&(this._wasUsed=!0,null==I.extensions&&(I.extensions={}),I.extensions[DI]={}),q(I)}))}}Yq.RegisterExtension(DI,(()=>new MI));const nI="KHR_materials_volume";class fI{constructor(q){this.name=nI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,I,l){const w=[];return l instanceof dq.c&&this._isExtensionEnabled(l)?(l.subSurface.thicknessTexture&&w.push(l.subSurface.thicknessTexture),w):w}_isExtensionEnabled(q){if(q.unlit)return!1;const I=q.subSurface;return!(!I.isRefractionEnabled&&!I.isTranslucencyEnabled)&&(void 0!=I.maximumThickness&&0!=I.maximumThickness||void 0!=I.tintColorAtDistance&&I.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=I.tintColor&&I.tintColor!=V.BI.White()||this._hasTexturesExtension(q))}_hasTexturesExtension(q){return null!=q.subSurface.thicknessTexture}postExportMaterialAsync(q,I,l){return new Promise((q=>{if(l instanceof dq.c&&this._isExtensionEnabled(l)){this._wasUsed=!0;const q=l.subSurface,w={thicknessFactor:0==q.maximumThickness?void 0:q.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(q.thicknessTexture)??void 0,attenuationDistance:q.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:q.tintColorAtDistance,attenuationColor:q.tintColor.equalsFloats(1,1,1)?void 0:q.tintColor.Uc()};this._hasTexturesExtension(l)&&this._exporter._materialNeedsUVsSet.add(l),I.extensions=I.extensions||{},I.extensions[nI]=w}q(I)}))}}Yq.RegisterExtension(nI,(q=>new fI(q)));const LI="EXT_materials_diffuse_roughness";class EI{constructor(q){this.name=LI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,I,l){const w=[];return l instanceof sI.d&&l._baseDiffuseRoughness?(l._baseDiffuseRoughnessTexture&&w.push(l._baseDiffuseRoughnessTexture),w):[]}postExportMaterialAsync(q,I,l){return new Promise((q=>{if(l instanceof sI.d){if(!l._baseDiffuseRoughness)return void q(I);this._wasUsed=!0,I.extensions=I.extensions||{};const w=this._exporter._materialExporter.getTextureInfo(l._baseDiffuseRoughnessTexture),t={diffuseRoughnessFactor:l._baseDiffuseRoughness,diffuseRoughnessTexture:w??void 0};null!==t.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(l),I.extensions[LI]=t}q(I)}))}}Yq.RegisterExtension(LI,(q=>new EI(q)));const jI="KHR_texture_transform";class hI{constructor(){this.name=jI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(q,I,l){if(l.Wq()||t.Tools.Warn(`${q}: /*@__KEY__*/"scene" is not defined for Babylon texture ${l.name}!`),(0!==l.uAng||0!==l.vAng)&&(t.Tools.Warn(`${q}: Texture ${l.name} with rotation in the u or v axis is not supported in glTF.`),0!==l.uRotationCenter||0!==l.vRotationCenter))return;const w={};let O=!1;if(0===l.uOffset&&0===l.vOffset||(w.offset=[l.uOffset,l.vOffset],O=!0),1===l.uScale&&1===l.vScale||(w.scale=[l.uScale,l.vScale],O=!0),0!==l.wAng){if(0!==l.uRotationCenter||0!==l.vRotationCenter){if(l.homogeneousRotationInUVTransform&&l.uScale!==l.vScale)return void t.Tools.Warn(`${q}: Texture ${l.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${jI}.`);t.Tools.Warn(`${q}: Texture ${l.name} with non-origin rotation center will be exported using an adjusted offset with ${jI}.`),w.offset=function(q){const{uOffset:I,vOffset:l,uRotationCenter:w,vRotationCenter:t,uScale:O,vScale:c,wAng:a}=q,F=Math.cos(a),s=Math.sin(a),Z=w*O,r=t*c;return[I+(Z*(1-F)+r*s),l+(r*(1-F)-Z*s)]}(l)}w.rotation=-l.wAng,O=!0}0!==l.coordinatesIndex&&(w.texCoord=l.coordinatesIndex,O=!0),O&&(this._wasUsed=!0,I.extensions||(I.extensions={}),I.extensions[jI]=w)}}Yq.RegisterExtension(jI,(()=>new hI));class uI{static CreateSTL(q){let I=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",t=arguments.length>3&&void 0!==arguments[3]&&arguments[3],O=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],c=arguments.length>5&&void 0!==arguments[5]&&arguments[5],a=arguments.length>6&&void 0!==arguments[6]&&arguments[6],F=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const s=function(q,I,l){const t=[3*q[l],3*q[l+1],3*q[l+2]],O=[new w.dI(I[t[0]],I[t[0]+2],I[t[0]+1]),new w.dI(I[t[1]],I[t[1]+2],I[t[1]+1]),new w.dI(I[t[2]],I[t[2]+2],I[t[2]+1])],c=O[0].TI(O[1]),a=O[2].TI(O[1]);return{v:O,n:w.dI.Cross(a,c).normalize()}},r=function(q,I,l,w){return I=x(q,I,l.x,w),I=x(q,I,l.y,w),x(q,I,l.z,w)},x=function(q,I,l,w){return q.setFloat32(I,l,w),I+4},d=function(q){if(a){let I=q;q instanceof o.e&&(I=q.sourceMesh);const l=I.getVerticesData(Z.c.PositionKind,!0,!0);if(!l)return[];const t=w.dI.Zero();let O;for(O=0;O<l.length;O+=3)w.dI.TransformCoordinatesFromFloatsToRef(l[O],l[O+1],l[O+2],q.Cc(!0),t).toArray(l,O);return l}return q.getVerticesData(Z.c.PositionKind)||[]};a&&(c=!0);let T="",V=0,U=0;if(t){for(let l=0;l<q.length;l++){const I=q[l].ec();V+=I?I.length/3:0}const I=new ArrayBuffer(84+50*V);T=new DataView(I),U+=80,T.setUint32(U,V,O),U+=4}else F||(T="solid stlmesh\r\n");for(let w=0;w<q.length;w++){const I=q[w];!t&&F&&(T+="solid "+I.name+"\r\n"),!c&&I instanceof Bq.c&&I.bakeCurrentTransformIntoVertices();const l=d(I),a=I.ec()||[];for(let q=0;q<a.length;q+=3){const I=s(a,l,q);t?(U=r(T,U,I.n,O),U=r(T,U,I.v[0],O),U=r(T,U,I.v[1],O),U=r(T,U,I.v[2],O),U+=2):(T+="\tfacet normal "+I.n.x+" "+I.n.y+" "+I.n.z+"\r\n",T+="\t\touter loop\r\n",T+="\t\t\tvertex "+I.v[0].x+" "+I.v[0].y+" "+I.v[0].z+"\r\n",T+="\t\t\tvertex "+I.v[1].x+" "+I.v[1].y+" "+I.v[1].z+"\r\n",T+="\t\t\tvertex "+I.v[2].x+" "+I.v[2].y+" "+I.v[2].z+"\r\n",T+="\t\tendloop\r\n",T+="\tendfacet\r\n")}!t&&F&&(T+="endsolid "+name+"\r\n")}if(t||F||(T+="endsolid stlmesh"),I){const q=document.createElement("a"),I=new Blob([T],{type:"application/octet-stream"});q.href=window.URL.createObjectURL(I),q.download=l+".stl",q.click()}return T}}function PI(q,I){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const w=[];for(let t=0;t<q.length/l;t++){const O=q[t*l],c=q[t*l+1],a=q[t*l+2];w.push(`(${O.toPrecision(I.precision)}, ${c.toPrecision(I.precision)}, ${a.toPrecision(I.precision)})`)}return w.join(", ")}function ml(q,I){const l=[];for(let w=0;w<q.length/2;w++){const t=q[2*w],O=q[2*w+1];l.push(`(${t.toPrecision(I.precision)}, ${(1-O).toPrecision(I.precision)})`)}return l.join(", ")}function YI(q,I){const l=q.getVerticesData(Z.c.PositionKind),w=q.getVerticesData(Z.c.NormalKind);if(l&&w)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(q){var I;const l=null!==(I=q.ec())&&void 0!==I&&I.length?q.getTotalIndices():q.getTotalVertices();return Array(l/3).fill(3).join(", ")}(q)}]\n\t\tint[] faceVertexIndices = [${function(q){const I=q.ec(),l=[];if(null!==I)for(let w=0;w<I.length;w++)l.push(I[w]);else{const I=q.getTotalVertices();for(let q=0;q<I;q++)l.push(q)}return l.join(", ")}(q)}]\n\t\tnormal3f[] normals = [${PI(w,I)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${PI(l,I)}]\n        ${function(q,I){let l="";for(let t=0;t<4;t++){const w=t>0?t:"",O=q.getVerticesData(Z.c.UVKind+(w?w+1:""));O&&(l+=`\n\t\ttexCoord2f[] primvars:st${w} = [${ml(O,I)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const w=q.getVerticesData(Z.c.ColorKind);return w&&(l+=`\n\tcolor3f[] primvars:displayColor = [${PI(w,I,w.length/q.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),l}(q,I)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function yI(q,I){return`\n        def "Geometry"\n        {\n        ${YI(q,I)}\n        }\n        `}function GI(q){let I='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return I+=q,fflate.strToU8(I)}function NI(q){const I=q.m;return`( ${JI(I,0)}, ${JI(I,4)}, ${JI(I,8)}, ${JI(I,12)} )`}function JI(q,I){return`(${q[I+0]}, ${q[I+1]}, ${q[I+2]}, ${q[I+3]})`}function zI(q){const I="Object_"+q.uniqueId,l=function(q){const I=q.getWorldMatrix().clone(),l=q.Wq().useRightHandedSystem;if(!l){let w=q.parent;for(;w;){if(cq(w,l)){I.multiplyToRef(w.getWorldMatrix().invert(),I);break}w=w.parent}}return I.determinant()<0&&t.Tools.Warn(`Exporting mesh ${q.name} with negative scale. Result may look incorrect in destination engine.`),I}(q),w=NI(l);return`def Xform "${I}" (\n\tprepend references = @./geometries/Geometry_${q.Wc.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${w}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${q.material.uniqueId}>\n}\n\n`}function HI(q){switch(q){case W.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case W.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case W.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function AI(q){return`(${q.x}, ${q.y})`}function QI(q){return`(${q.r}, ${q.g}, ${q.b})`}function bI(q,I,l,t,O,c){const a=q.getInternalTexture().uniqueId+"_"+q.invertY;O[a]=q;const F=q.coordinatesIndex>0?"st"+q.coordinatesIndex:"st",s=new w.Vector2(q.uScale,q.vScale),Z=new w.Vector2(q.uOffset,q.vOffset),r=q.wAng,x=Math.sin(r),o=Math.cos(r);return Z.y=1-Z.y-s.y,Z.x+=x*s.x,Z.y+=(1-o)*s.y,`\n    def Shader "PrimvarReader_${l}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${F}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${l}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${I.uniqueId}/PrimvarReader_${l}.outputs:result>\n        float inputs:rotation = ${(r*(180/Math.PI)).toFixed(c.precision)}\n        float2 inputs:scale = ${AI(s)}\n        float2 inputs:translation = ${AI(Z)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${q.uniqueId}_${l}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${a}.png@\n        float2 inputs:st.connect = </Materials/Material_${I.uniqueId}/Transform2d_${l}.outputs:result>\n        ${t?"float4 inputs:scale = "+function(q){return`(${q.r}, ${q.g}, ${q.b}, 1.0)`}(t):""}\n        token inputs:sourceColorSpace = "${q.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${HI(q.wrapU)}"\n        token inputs:wrapT = "${HI(q.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${I.needAlphaBlending()?"float outputs:a":""}\n    }`}function ql(q,I,l){const w="\t\t\t",t=[],O=[],{diffuseMap:c,jc:a,alphaCutOff:F,emissiveMap:s,emissive:Z,normalMap:r,roughnessMap:x,roughnessChannel:o,roughness:d,metalnessMap:T,metalnessChannel:U,metalness:B,aoMap:v,aoMapChannel:k,aoMapIntensity:C,alphaMap:R,ior:W,clearCoatEnabled:e,clearCoat:i,clearCoatMap:S,clearCoatRoughness:g,clearCoatRoughnessMap:p}=function(q){const I={diffuseMap:null,jc:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return q instanceof Tq.UI?{...I,diffuseMap:q.diffuseTexture,jc:q.diffuseColor,alphaCutOff:q.alphaCutOff,emissiveMap:q.emissiveTexture,emissive:q.emissiveColor,roughness:1,alphaMap:q.opacityTexture}:q instanceof sI.d?{...I,diffuseMap:q._albedoTexture,jc:q._albedoColor,alphaCutOff:q._alphaCutOff,emissiveMap:q._emissiveTexture,emissive:q._emissiveColor,normalMap:q._bumpTexture,roughnessMap:q._metallicTexture,roughnessChannel:q._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:q._roughness??1,metalnessMap:q._metallicTexture,metalnessChannel:q._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:q._metallic??0,aoMap:q._ambientTexture,aoMapChannel:q._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:q._ambientTextureStrength,alphaMap:q._opacityTexture,ior:q.subSurface.indexOfRefraction,clearCoatEnabled:q.clearCoat.isEnabled,clearCoat:q.clearCoat.Ec,clearCoatMap:q.clearCoat.texture,clearCoatRoughness:q.clearCoat.roughness,clearCoatRoughnessMap:q.clearCoat.useRoughnessFromMainTexture?q.clearCoat.texture:q.clearCoat.textureRoughness}:I}(q);return null!==c?(t.push(`${w}color3f inputs:diffuseColor.connect = </Materials/Material_${q.uniqueId}/Texture_${c.uniqueId}_diffuse.outputs:rgb>`),q.needAlphaBlending()?t.push(`${w}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${c.uniqueId}_diffuse.outputs:a>`):q.needAlphaTesting()&&(t.push(`${w}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${c.uniqueId}_diffuse.outputs:a>`),t.push(`${w}float inputs:opacityThreshold = ${F}`)),O.push(bI(c,q,"diffuse",a,I,l))):t.push(`${w}color3f inputs:diffuseColor = ${QI(a||V.BI.White())}`),null!==s?(t.push(`${w}color3f inputs:emissiveColor.connect = </Materials/Material_${q.uniqueId}/Texture_${s.uniqueId}_emissive.outputs:rgb>`),O.push(bI(s,q,"emissive",Z,I,l))):Z&&Z.toLuminance()>0&&t.push(`${w}color3f inputs:emissiveColor = ${QI(Z)}`),null!==r&&(t.push(`${w}normal3f inputs:normal.connect = </Materials/Material_${q.uniqueId}/Texture_${r.uniqueId}_normal.outputs:rgb>`),O.push(bI(r,q,"normal",null,I,l))),null!==v&&(t.push(`${w}float inputs:occlusion.connect = </Materials/Material_${q.uniqueId}/Texture_${v.uniqueId}_occlusion.outputs:${k}>`),O.push(bI(v,q,"occlusion",new V.BI(C,C,C),I,l))),null!==x?(t.push(`${w}float inputs:roughness.connect = </Materials/Material_${q.uniqueId}/Texture_${x.uniqueId}_roughness.outputs:${o}>`),O.push(bI(x,q,"roughness",new V.BI(d,d,d),I,l))):t.push(`${w}float inputs:roughness = ${d}`),null!==T?(t.push(`${w}float inputs:metallic.connect = </Materials/Material_${q.uniqueId}/Texture_${T.uniqueId}_metallic.outputs:${U}>`),O.push(bI(T,q,"metallic",new V.BI(B,B,B),I,l))):t.push(`${w}float inputs:metallic = ${B}`),null!==R?(t.push(`${w}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${R.uniqueId}_opacity.outputs:r>`),t.push(`${w}float inputs:opacityThreshold = 0.0001`),O.push(bI(R,q,"opacity",null,I,l))):t.push(`${w}float inputs:opacity = ${q.alpha}`),e&&(null!==S?(t.push(`${w}float inputs:clearcoat.connect = </Materials/Material_${q.uniqueId}/Texture_${S.uniqueId}_clearcoat.outputs:r>`),O.push(bI(S,q,"clearcoat",new V.BI(i,i,i),I,l))):t.push(`${w}float inputs:clearcoat = ${i}`),null!==p?(t.push(`${w}float inputs:clearcoatRoughness.connect = </Materials/Material_${q.uniqueId}/Texture_${p.uniqueId}_clearcoatRoughness.outputs:g>`),O.push(bI(p,q,"clearcoatRoughness",new V.BI(g,g,g),I,l))):t.push(`${w}float inputs:clearcoatRoughness = ${g}`)),t.push(`${w}float inputs:ior = ${W}`),`\n\tdef Material "Material_${q.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${t.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${q.uniqueId}/PreviewSurface.outputs:surface>\n\n${O.join("\n")}\n\n\t}\n`}async function Il(q,I,l){const O={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...I};"undefined"===typeof fflate&&await t.Tools.LoadScriptAsync(O.fflateUrl);const c={};c[O.modelFileName]=null;let a='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';a+=function(q){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===q.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${q.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${q.planeAnchoringAlignment}"`:""}\n            `}(O);const F={};for(const w of q.meshes){if(0===w.getTotalVertices())continue;const q=w,I=q.Wc,s=q.material;if(!s||!I||l&&!l(q))continue;if(-1!==["UI","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(s.getClassName())){const l="geometries/Geometry_"+I.uniqueId+".usda";if(!(l in c)){const q=yI(I,O);c[l]=GI(q)}s.uniqueId in F||(F[s.uniqueId]=s),a+=zI(q)}else t.Tools.Warn("USDZExportAsync does not support this material type: "+s.getClassName())}q.activeCamera&&O.exportCamera&&(a+=function(q,I){const l="Camera_"+q.uniqueId,t=NI(w.Matrix.RotationY(Math.PI).multiply(q.getWorldMatrix()));if(q.mode===W.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${l}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${t}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${q.vc.toPrecision(I.precision)}, ${q.maxZ.toPrecision(I.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(q.orthoLeft||1)+Math.abs(q.orthoRight||1))).toPrecision(I.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(q.orthoTop||1)+Math.abs(q.orthoBottom||1))).toPrecision(I.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const w=q.getEngine().getAspectRatio(q),O=I.cameraSensorWidth||35;return`def Camera "${l}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${t}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${q.vc.toPrecision(I.precision)}, ${q.maxZ.toPrecision(I.precision)})\n\t\t\tfloat focalLength = ${(O/(2*Math.tan(.5*q.fov))).toPrecision(I.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(O*w).toPrecision(I.precision)}\n\t\t\tfloat verticalAperture = ${(O/w).toPrecision(I.precision)}            \n\t\t}\n\t\n\t`}}(q.activeCamera,O)),a+="\n            }\n        }\n    }";const s={};a+=function(q,I,l){const w=[];for(const t in q){const O=q[t];w.push(ql(O,I,l))}return`\n    def "Materials"\n{\n${w.join("")}\n}\n\n`}(F,s,O),c[O.modelFileName]=fflate.strToU8(a);for(const w in s){const q=s[w],I=q.getSize(),l=await q.readPixels();if(!l)throw new Error("Texture data is not available");const t=await e.DumpTools.DumpDataAsync(I.width,I.height,l,"image/png",void 0,!1,!0);c[`textures/Texture_${w}.png`]=new Uint8Array(t).slice()}let Z=0;for(const w in c){const q=c[w];if(!q)continue;Z+=34+w.length;const I=63&Z;if(4!==I){const l=new Uint8Array(64-I);c[w]=[q,{extra:{12345:l}}]}Z=q.length}return fflate.zipSync(c,{level:0})}}}]);