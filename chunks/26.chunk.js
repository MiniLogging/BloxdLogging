"use strict";(self.fwuvyyymhp8=self.fwuvyyymhp8||[]).push([[26],{12758:(N,U,V)=>{V.r(U),V.d(U,{EXT_materials_diffuse_roughness:()=>oU,EXT_mesh_gpu_instancing:()=>PN,GLTF2Export:()=>jN,GLTFData:()=>S,KHR_draco_mesh_compression:()=>VU,KHR_lights_punctual:()=>zU,KHR_materials_anisotropy:()=>pU,KHR_materials_clearcoat:()=>BU,KHR_materials_diffuse_transmission:()=>JU,KHR_materials_dispersion:()=>rU,KHR_materials_emissive_strength:()=>hU,KHR_materials_ior:()=>HU,KHR_materials_iridescence:()=>WU,KHR_materials_sheen:()=>MU,KHR_materials_specular:()=>mV,KHR_materials_transmission:()=>XU,KHR_materials_unlit:()=>QU,KHR_materials_volume:()=>LU,KHR_texture_transform:()=>DU,OBJExport:()=>q,STLExport:()=>GU,USDZExportAsync:()=>UV,_ConvertToGLTFPBRMetallicRoughness:()=>e,_SolveMetallic:()=>X,__IGLTFExporterExtension:()=>i});var A=V(12383),t=V(12179),n=V(12672);class q{static OBJ(N,U,V,q){const i=[];let z=1,S=1;U&&(V||(V="mat"),i.push("mtllib "+V+".mtl"));for(let E=0;E<N.length;E++){const V=N[E],p=V.name||`mesh${E}}`;i.push(`o ${p}`);let k=null;if(q){const N=V.xi(!0);k=new A.Matrix,N.invertToRef(k),V.bakeTransformIntoVertices(N)}if(U){const N=V.material;N&&i.push("usemtl "+N.id)}const B=V.Ji;if(!B){t.Tools.Warn("No geometry is present on the mesh");continue}const C=B.getVerticesData("position"),x=B.getVerticesData("normal"),J=B.getVerticesData("uv"),d=B.di();let r=0,v=0;if(!C||!d){t.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const h=N[0].YN().useRightHandedSystem?1:-1;for(let N=0;N<C.length;N+=3)i.push("v "+C[N]*h+" "+C[N+1]+" "+C[N+2]),r++;if(null!=x)for(let N=0;N<x.length;N+=3)i.push("vn "+x[N]*h+" "+x[N+1]+" "+x[N+2]);if(null!=J)for(let N=0;N<J.length;N+=2)i.push("vt "+J[N]+" "+J[N+1]),v++;const c=["","",""],H=(V.material||V.YN().defaultMaterial)._getEffectiveOrientation(V),[Y,W]=H===n.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let N=0;N<d.length;N+=3){const U=[String(d[N]+z),String(d[N+Y]+z),String(d[N+W]+z)],V=[String(d[N]+S),String(d[N+Y]+S),String(d[N+W]+S)],A=U,t=null!=J?V:c,n=null!=x?U:c;i.push("f "+A[0]+"/"+t[0]+"/"+n[0]+" "+A[1]+"/"+t[1]+"/"+n[1]+" "+A[2]+"/"+t[2]+"/"+n[2])}q&&k&&V.bakeTransformIntoVertices(k),z+=r,S+=v}return i.join("\n")}static MTL(N){const U=[],V=N.material;U.push("newmtl mat1"),U.push("  Ns "+V.specularPower.toFixed(4)),U.push("  Ni 1.5000"),U.push("  d "+V.alpha.toFixed(4)),U.push("  Tr 0.0000"),U.push("  Tf 1.0000 1.0000 1.0000"),U.push("  illum 2"),U.push("  Ka "+V.ambientColor.r.toFixed(4)+" "+V.ambientColor.g.toFixed(4)+" "+V.ambientColor.b.toFixed(4)),U.push("  Kd "+V.diffuseColor.r.toFixed(4)+" "+V.diffuseColor.g.toFixed(4)+" "+V.diffuseColor.b.toFixed(4)),U.push("  Ks "+V.specularColor.r.toFixed(4)+" "+V.specularColor.g.toFixed(4)+" "+V.specularColor.b.toFixed(4)),U.push("  Ke "+V.emissiveColor.r.toFixed(4)+" "+V.emissiveColor.g.toFixed(4)+" "+V.emissiveColor.b.toFixed(4));V.ambientTexture&&U.push("  map_Ka "+V.ambientTexture.name),V.diffuseTexture&&U.push("  map_Kd "+V.diffuseTexture.name),V.specularTexture&&U.push("  map_Ks "+V.specularTexture.name),V.bumpTexture&&U.push("  map_bump -imfchan z "+V.bumpTexture.name),V.opacityTexture&&U.push("  map_d "+V.opacityTexture.name);return U.join("\n")}}var i=0,z=V(12232);class S{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const N in this.files){const U=this.files[N],V=new Blob([U],{type:(0,z.i)(N)});t.Tools.Download(V,N)}}}var E=V(12453),p=V(12762),k=V(12772),B=V(12793),C=V(12512),x=V(12223),J=V(12426),d=V(12395);const r=d.HighestCommonFactor,v={...d,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:r};var h=V(12593),c=V(12364),H=V(12828),Y=V(12834),W=V(12584);const s=1e-6,M=new J.rU(.04,.04,.04),a=1024,mN=J.rU.White(),w=J.rU.Black();function X(N,U,V){if(U<M.r)return 0;const A=M.r,t=N*V/(1-M.r)+U-2*M.r,n=t*t-4*A*(M.r-U);return v.Clamp((-t+Math.sqrt(n))/(2*A),0,1)}function e(N){const U=N.diffuseColor.toLinearSpace(N.YN().getEngine().useExactSrgbConversions).scale(.5),V=N.alpha,t=function(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new A.Vector2(0,1),V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new A.Vector2(0,.1),t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new A.Vector2(0,.1),n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new A.Vector2(1300,.1);return function(N,U,V,A,t){return(1-N)*(1-N)*(1-N)*U+3*(1-N)*(1-N)*N*V+3*(1-N)*N*N*A+N*N*N*t}(Math.pow(N/n.x,.333333),U.y,V.y,t.y,n.y)}(v.Clamp(N.specularPower,0,a));return{baseColorFactor:[U.r,U.g,U.b,V],metallicFactor:0,roughnessFactor:t}}function Q(N,U){U.needAlphaBlending()?N.alphaMode="BLEND":U.needAlphaTesting()&&(N.alphaMode="MASK",N.alphaCutoff=U.alphaCutOff)}function u(N,U,V){const A=new Uint8Array(N*U*4);for(let t=0;t<A.length;t+=4)A[t]=A[t+1]=A[t+2]=A[t+3]=255;return H.b.CreateRGBATexture(A,N,U,V)}function L(N){if(N instanceof Uint8Array){const U=N.length,V=new Float32Array(N.length);for(let A=0;A<U;++A)V[A]=N[A]/255;return V}if(N instanceof Float32Array)return N;throw new Error("Unsupported pixel format!")}class I{constructor(N){this._exporter=N,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(N){return N?this._textureMap.get(N)??null:null}async exportStandardMaterialAsync(N,U,V){const A=e(N),n={name:N.name};if(null==N.ri||N.ri||(N.twoSidedLighting||t.Tools.Warn(N.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),n.doubleSided=!0),V){const V=[],t=N.diffuseTexture;t&&V.push(this.exportTextureAsync(t,U).then((N=>{N&&(A.baseColorTexture=N)})));const q=N.bumpTexture;q&&V.push(this.exportTextureAsync(q,U).then((N=>{N&&(n.normalTexture=N,1!==q.level&&(n.normalTexture.scale=q.level))})));const i=N.emissiveTexture;i&&(n.emissiveFactor=[1,1,1],V.push(this.exportTextureAsync(i,U).then((N=>{N&&(n.emissiveTexture=N)}))));const z=N.ambientTexture;z&&V.push(this.exportTextureAsync(z,U).then((N=>{if(N){const U={index:N.index};n.occlusionTexture=U}}))),V.length>0&&(this._exporter._materialNeedsUVsSet.add(N),await Promise.all(V))}(N.alpha<1||N.opacityTexture)&&(N.alphaMode===Y.b.ALPHA_COMBINE?n.alphaMode="BLEND":t.Tools.Warn(N.name+": glTF 2.0 does not support alpha mode: "+N.alphaMode.toString())),N.emissiveColor&&!N.emissiveColor.equalsWithEpsilon(w,s)&&(n.emissiveFactor=N.emissiveColor.pi()),n.pbrMetallicRoughness=A,Q(n,N),await this._finishMaterialAsync(n,N,U);const q=this._exporter._materials;return q.push(n),q.length-1}async _finishMaterialAsync(N,U,V){const A=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",N,U),t=[];for(const n of A)t.push(this.exportTextureAsync(n,V));await Promise.all(t),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",N,U)}async _getImageDataAsync(N,U,A,t){const n=Y.b.TEXTURETYPE_UNSIGNED_BYTE,q=this._exporter._babylonScene,i=q.getEngine(),z=i.createRawTexture(N,U,A,Y.b.TEXTUREFORMAT_RGBA,!1,!0,c.e.NEAREST_SAMPLINGMODE,null,n);i.isWebGPU?await V.e(51).then(V.bind(V,14833)):await V.e(52).then(V.bind(V,14841)),await h.h.ApplyPostProcess("pass",z,q,n,Y.b.TEXTURE_NEAREST_SAMPLINGMODE,Y.b.TEXTUREFORMAT_RGBA);const S=await i._readTexturePixels(z,U,A);return await W.DumpTools.DumpDataAsync(U,A,S,t,void 0,!0,!0)}_resizeTexturesToSameDimensions(N,U,V){const A=N?N.getSize():{width:0,height:0},t=U?U.getSize():{width:0,height:0};let n,q;return A.width<t.width?(n=N&&N instanceof c.e?h.h.CreateResizedCopy(N,t.width,t.height,!0):u(t.width,t.height,V),q=U):A.width>t.width?(q=U&&U instanceof c.e?h.h.CreateResizedCopy(U,A.width,A.height,!0):u(A.width,A.height,V),n=N):(n=N,q=U),{texture1:n,texture2:q}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(N,U,V,A){const t=new Array;if(!N&&!U)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const n=N?N.YN():U?U.YN():null;if(n){var q;const i=this._resizeTexturesToSameDimensions(N,U,n),z=null===(q=i.texture1)||void 0===q?void 0:q.getSize();let S,E;const p=z.width,k=z.height,B=await i.texture1.readPixels(),C=await i.texture2.readPixels();if(!B)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(S=L(B),!C)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");E=L(C);const x=E.byteLength,d=new Uint8Array(x),r=new Uint8Array(x),v=4,h=w;let c=0,H=0;for(let N=0;N<k;++N)for(let U=0;U<p;++U){const A=(p*N+U)*v,t={diffuseColor:new J.rU(S[A],S[A+1],S[A+2]).toLinearSpace(n.getEngine().useExactSrgbConversions).multiply(V.diffuseColor),specularColor:new J.rU(E[A],E[A+1],E[A+2]).toLinearSpace(n.getEngine().useExactSrgbConversions).multiply(V.specularColor),glossiness:E[A+3]*V.glossiness},q=this._convertSpecularGlossinessToMetallicRoughness(t);h.r=Math.max(h.r,q.baseColor.r),h.g=Math.max(h.g,q.baseColor.g),h.b=Math.max(h.b,q.baseColor.b),c=Math.max(c,q.metallic),H=Math.max(H,q.roughness),r[A]=255*q.baseColor.r,r[A+1]=255*q.baseColor.g,r[A+2]=255*q.baseColor.b,r[A+3]=i.texture1.ki?255*S[A+3]:255,d[A]=0,d[A+1]=255*q.roughness,d[A+2]=255*q.metallic,d[A+3]=255}const Y={baseColor:h,metallic:c,roughness:H};let W=!1,M=!1;for(let N=0;N<k;++N)for(let U=0;U<p;++U){const V=(p*N+U)*v;r[V]/=Y.baseColor.r>s?Y.baseColor.r:1,r[V+1]/=Y.baseColor.g>s?Y.baseColor.g:1,r[V+2]/=Y.baseColor.b>s?Y.baseColor.b:1;const A=J.rU.FromInts(r[V],r[V+1],r[V+2]).toGammaSpace(n.getEngine().useExactSrgbConversions);r[V]=255*A.r,r[V+1]=255*A.g,r[V+2]=255*A.b,A.equalsWithEpsilon(mN,s)||(M=!0),d[V+1]/=Y.roughness>s?Y.roughness:1,d[V+2]/=Y.metallic>s?Y.metallic:1;J.rU.FromInts(255,d[V+1],d[V+2]).equalsWithEpsilon(mN,s)||(W=!0)}return W&&t.push(this._getImageDataAsync(d,p,k,A).then((N=>{Y.metallicRoughnessTextureData=N}))),M&&t.push(this._getImageDataAsync(r,p,k,A).then((N=>{Y.baseColorTextureData=N}))),await Promise.all(t).then((()=>Y))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(N){const U=this._getPerceivedBrightness(N.diffuseColor),V=this._getPerceivedBrightness(N.specularColor),A=1-this._getMaxComponent(N.specularColor),t=X(U,V,A),n=N.diffuseColor.scale(A/(1-M.r)/Math.max(1-t)),q=N.specularColor.xU(M.scale(1-t)).scale(1/Math.max(t));let i=J.rU.Lerp(n,q,t*t);i=i.clampToRef(0,1,i);return{baseColor:i,metallic:t,roughness:1-N.glossiness}}_getPerceivedBrightness(N){return N?Math.sqrt(.299*N.r*N.r+.587*N.g*N.g+.114*N.b*N.b):0}_getMaxComponent(N){return N?Math.max(N.r,Math.max(N.g,N.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(N,U,V,A){const t=[],n={baseColor:N._albedoColor,metallic:N._metallic,roughness:N._roughness};if(A){N._albedoTexture&&t.push(this.exportTextureAsync(N._albedoTexture,U).then((N=>{N&&(V.baseColorTexture=N)})));const A=N._metallicTexture;A&&t.push(this.exportTextureAsync(A,U).then((N=>{N&&(V.metallicRoughnessTexture=N)})))}return t.length>0&&(this._exporter._materialNeedsUVsSet.add(N),await Promise.all(t)),n}_getTextureSampler(N){const U={};if(!N||!(N instanceof c.e))return U;const V=this._getGLTFTextureWrapMode(N.wrapU);10497!==V&&(U.wrapS=V);const A=this._getGLTFTextureWrapMode(N.wrapV);switch(10497!==A&&(U.wrapT=A),N.samplingMode){case c.e.LINEAR_LINEAR:U.magFilter=9729,U.minFilter=9729;break;case c.e.LINEAR_NEAREST:U.magFilter=9729,U.minFilter=9728;break;case c.e.NEAREST_LINEAR:U.magFilter=9728,U.minFilter=9729;break;case c.e.NEAREST_LINEAR_MIPLINEAR:U.magFilter=9728,U.minFilter=9987;break;case c.e.NEAREST_NEAREST:U.magFilter=9728,U.minFilter=9728;break;case c.e.NEAREST_LINEAR_MIPNEAREST:U.magFilter=9728,U.minFilter=9985;break;case c.e.LINEAR_NEAREST_MIPNEAREST:U.magFilter=9729,U.minFilter=9984;break;case c.e.LINEAR_NEAREST_MIPLINEAR:U.magFilter=9729,U.minFilter=9986;break;case c.e.NEAREST_NEAREST_MIPLINEAR:U.magFilter=9728,U.minFilter=9986;break;case c.e.LINEAR_LINEAR_MIPLINEAR:U.magFilter=9729,U.minFilter=9987;break;case c.e.LINEAR_LINEAR_MIPNEAREST:U.magFilter=9729,U.minFilter=9985;break;case c.e.NEAREST_NEAREST_MIPNEAREST:U.magFilter=9728,U.minFilter=9984}return U}_getGLTFTextureWrapMode(N){switch(N){case c.e.WRAP_ADDRESSMODE:return 10497;case c.e.CLAMP_ADDRESSMODE:return 33071;case c.e.MIRROR_ADDRESSMODE:return 33648;default:return t.Tools.Error(`Unsupported Texture Wrap Mode ${N}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(N,U,V,A){const t={diffuseColor:N._albedoColor,specularColor:N._reflectivityColor,glossiness:N._microSurface},n=N._albedoTexture,q=N._reflectivityTexture,i=N._useMicroSurfaceFromReflectivityMapAlpha;if(q&&!i)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((n||q)&&A){this._exporter._materialNeedsUVsSet.add(N);const A=this._exportTextureSampler(n||q),i=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(n,q,t,U),z=this._exporter._textures;if(i.baseColorTextureData){const N=this._exportImage(`baseColor${z.length}`,U,i.baseColorTextureData);V.baseColorTexture=this._exportTextureInfo(N,A,null===n||void 0===n?void 0:n.coordinatesIndex)}if(i.metallicRoughnessTextureData){const N=this._exportImage(`metallicRoughness${z.length}`,U,i.metallicRoughnessTextureData);V.metallicRoughnessTexture=this._exportTextureInfo(N,A,null===q||void 0===q?void 0:q.coordinatesIndex)}return i}return this._convertSpecularGlossinessToMetallicRoughness(t)}async exportPBRMaterialAsync(N,U,V){const A={},t={name:N.name},n=N.isMetallicWorkflow();if(n){const U=N._albedoColor,V=N.alpha;U&&(A.baseColorFactor=[U.r,U.g,U.b,V])}const q=n?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(N,U,A,V):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(N,U,A,V);await this._setMetallicRoughnessPbrMaterialAsync(q,N,t,A,U,V),await this._finishMaterialAsync(t,N,U);const i=this._exporter._materials;return i.push(t),i.length-1}async _setMetallicRoughnessPbrMaterialAsync(N,U,V,A,n,q){if(Q(V,U),N.baseColor.equalsWithEpsilon(mN,s)&&v.WithinEpsilon(U.alpha,1,s)||(A.baseColorFactor=[N.baseColor.r,N.baseColor.g,N.baseColor.b,U.alpha]),null!=N.metallic&&1!==N.metallic&&(A.metallicFactor=N.metallic),null!=N.roughness&&1!==N.roughness&&(A.roughnessFactor=N.roughness),null==U.ri||U.ri||(U._twoSidedLighting||t.Tools.Warn(U.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),V.doubleSided=!0),q){const N=[],A=U._bumpTexture;A&&N.push(this.exportTextureAsync(A,n).then((N=>{N&&(V.normalTexture=N,1!==A.level&&(V.normalTexture.scale=A.level))})));const t=U._ambientTexture;t&&N.push(this.exportTextureAsync(t,n).then((N=>{if(N){const A={index:N.index,texCoord:N.texCoord,extensions:N.extensions};V.occlusionTexture=A;const t=U._ambientTextureStrength;t&&(A.strength=t)}})));const q=U._emissiveTexture;q&&N.push(this.exportTextureAsync(q,n).then((N=>{N&&(V.emissiveTexture=N)}))),N.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(N))}const i=U._emissiveColor;i.equalsWithEpsilon(w,s)||(V.emissiveFactor=i.pi()),V.pbrMetallicRoughness=A}_getPixelsFromTextureAsync(N){return function(N){switch(N){case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(N.textureFormat)?(0,h.e)(N,N._texture.width,N._texture.height):(N.textureType,Y.b.TEXTURETYPE_UNSIGNED_BYTE,N.readPixels())}async exportTextureAsync(N,U){const V=this._exporter._extensionsPreExportTextureAsync("exporter",N,U);return V?await V.then((async V=>V?await this._exportTextureInfoAsync(V,U):await this._exportTextureInfoAsync(N,U))):await this._exportTextureInfoAsync(N,U)}async _exportTextureInfoAsync(N,U){let V=this._textureMap.get(N);if(!V){const A=await this._getPixelsFromTextureAsync(N);if(!A)return null;const n=this._exportTextureSampler(N),q=N.mimeType;if(q)switch(q){case"image/jpeg":case"image/png":case"image/webp":U=q;break;default:t.Tools.Warn(`Unsupported media type: ${q}. Exporting texture as PNG.`)}const i=this._internalTextureToImage,z=N.getInternalTexture().uniqueId;i[z]||(i[z]={});let S=i[z][U];if(void 0===S){const V=N.getSize();S=(async()=>{const t=await this._getImageDataAsync(A,V.width,V.height,U);return this._exportImage(N.name,U,t)})(),i[z][U]=S}V=this._exportTextureInfo(await S,n,N.coordinatesIndex),this._textureMap.set(N,V),this._exporter._extensionsPostExportTextures("exporter",V,N)}return V}_exportImage(N,U,V){const A=this._exporter._images;let n;if(this._exporter._shouldUseGlb){n={name:N,mimeType:U,bufferView:void 0};const A=this._exporter._bufferManager.createBufferView(new Uint8Array(V));this._exporter._bufferManager.setBufferView(n,A)}else{const q=N.replace(/\.\/|\/|\.\\|\\/g,"_"),i=function(N){switch(N){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(U);let z=q+i;A.some((N=>N.uri===z))&&(z=`${q}_${t.Tools.RandomId()}${i}`),n={name:N,uri:z},this._exporter._imageData[z]={data:V,mimeType:U}}return A.push(n),A.length-1}_exportTextureInfo(N,U,V){const A=this._exporter._textures;let t=A.findIndex((V=>V.sampler==U&&V.source===N));-1===t&&(t=A.length,A.push({source:N,sampler:U}));const n={index:t};return V&&(n.texCoord=V),n}_exportTextureSampler(N){const U=this._getTextureSampler(N),V=this._exporter._samplers,A=V.findIndex((N=>N.minFilter===U.minFilter&&N.magFilter===U.magFilter&&N.wrapS===U.wrapS&&N.wrapT===U.wrapT));return-1!==A?A:(V.push(U),V.length-1)}}var o=V(12466),R=V(12193),D=V(12839),G=V(12389);const g=A.CU.Zero(),l=A.Quaternion.Identity(),K=A.CU.One(),j=new A.CU(-1,1,1);function F(N,U){const{byteOffset:V,byteStride:A,type:t,normalized:n}=N,q=N.getSize(),i=U.reduce(((N,U)=>U.getTotalVertices()>N?U.getTotalVertices():N),-Number.MAX_VALUE);return{byteOffset:V,byteStride:A,componentCount:q,type:t,count:i*q,normalized:n,totalVertices:i,kind:N.getKind()}}function P(N){switch(N){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function T(N){switch(N){case E.f.PositionKind:case E.f.NormalKind:case E.f.TangentKind:case E.f.ColorKind:case E.f.MatricesIndicesKind:case E.f.MatricesIndicesExtraKind:case E.f.MatricesWeightsKind:case E.f.MatricesWeightsExtraKind:case E.f.UVKind:case E.f.UV2Kind:case E.f.UV3Kind:case E.f.UV4Kind:case E.f.UV5Kind:case E.f.UV6Kind:return!0}return!1}function f(N){switch(N){case n.d.TriangleFillMode:return 4;case n.d.TriangleStripDrawMode:return 5;case n.d.TriangleFanDrawMode:return 6;case n.d.PointListDrawMode:case n.d.PointFillMode:return 0;case n.d.LineLoopDrawMode:return 2;case n.d.LineListDrawMode:return 1;case n.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${N}`)}function O(N){const U=Math.sqrt(N.x*N.x+N.y*N.y+N.z*N.z);U>0&&(N.x/=U,N.y/=U,N.z/=U)}function Z(N){return N.x*=-1,N}function b(N){if(N.x*N.x+N.y*N.y>.5){const U=Math.abs(N.x),V=Math.abs(N.y);if(U>V){const V=Math.sign(N.x);N.x=U,N.y*=-V,N.z*=-V,N.w*=V}else{const U=Math.sign(N.y);N.x*=-U,N.y=V,N.z*=U,N.w*=-U}}else{const U=Math.abs(N.z),V=Math.abs(N.w);if(U>V){const V=Math.sign(N.z);N.x*=-V,N.y*=V,N.z=U,N.w*=-V}else{const U=Math.sign(N.w);N.x*=U,N.y*=-U,N.z*=-U,N.w=V}}return N}function y(N){N.hi(-N.z,N.w,N.x,-N.y)}function NN(N,U){const V=A.CU.FromArrayToRef(U.translation||[0,0,0],0,A.TmpVectors.CU[0]),t=A.Quaternion.FromArrayToRef(U.rotation||[0,0,0,1],0,A.TmpVectors.Quaternion[0]),n=A.Matrix.ComposeToRef(K,t,V,A.TmpVectors.Matrix[0]),q=A.CU.FromArrayToRef(N.translation||[0,0,0],0,A.TmpVectors.CU[2]),i=A.Quaternion.FromArrayToRef(N.rotation||[0,0,0,1],0,A.TmpVectors.Quaternion[1]),z=A.Matrix.ComposeToRef(K,i,q,A.TmpVectors.Matrix[1]);n.multiplyToRef(z,z),z.decompose(void 0,t,V),V.equalsWithEpsilon(g,G.d)?delete U.translation:U.translation=V.pi(),t.equalsWithEpsilon(l,G.d)?delete U.rotation:U.rotation=t.pi(),U.scale&&delete U.scale}function UN(N,U){if(!(U instanceof p.b))return!1;if(!(1===U.getChildren().length&&0===N.getChildren().length&&N.parent===U))return!1;const V=N.YN(),A=N instanceof D.d&&!V.useRightHandedSystem?j:K;return!!U.ci.equalsWithEpsilon(A,G.d)||(R.b.Warn(`Cannot collapse node ${N.name} into parent node ${U.name} with modified scaling.`),!1)}function VN(N){if(N instanceof Array){const U=new Float32Array(N);return new Uint8Array(U.buffer,U.byteOffset,U.byteLength)}return ArrayBuffer.isView(N)?new Uint8Array(N.buffer,N.byteOffset,N.byteLength):new Uint8Array(N)}function AN(N,U){for(const[V,A]of Object.entries(N)){const t=U[V];(Array.isArray(A)&&Array.isArray(t)&&tN(A,t)||A===t)&&delete N[V]}return N}function tN(N,U){return N.length===U.length&&N.every(((N,V)=>N===U[V]))}const nN=A.Matrix.Compose(new A.CU(-1,1,1),A.Quaternion.Identity(),A.CU.Zero());function qN(N,U){if(!(N instanceof p.b))return!1;if(U){if(!N.getWorldMatrix().equalsWithEpsilon(A.Matrix.IdentityReadOnly,G.d))return!1}else{if(!N.getWorldMatrix().multiplyToRef(nN,A.TmpVectors.Matrix[0]).equalsWithEpsilon(A.Matrix.IdentityReadOnly,G.d))return!1}return!(N instanceof k.e&&N.Ji)}const iN=new Map([[Int8Array,(N,U,V)=>N.setInt8(U,V)],[Uint8Array,(N,U,V)=>N.setUint8(U,V)],[Uint8ClampedArray,(N,U,V)=>N.setUint8(U,V)],[Int16Array,(N,U,V)=>N.setInt16(U,V,!0)],[Uint16Array,(N,U,V)=>N.setUint16(U,V,!0)],[Int32Array,(N,U,V)=>N.setInt32(U,V,!0)],[Uint32Array,(N,U,V)=>N.setUint32(U,V,!0)],[Float32Array,(N,U,V)=>N.setFloat32(U,V,!0)],[Float64Array,(N,U,V)=>N.setFloat64(U,V,!0)]]);class zN{writeTypedArray(N){this._checkGrowBuffer(N.byteLength);const U=iN.get(N.constructor);for(let V=0;V<N.length;V++)U(this._dataView,this._byteOffset,N[V]),this._byteOffset+=N.BYTES_PER_ELEMENT}constructor(N){this._data=new Uint8Array(N),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(N){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,N),this._byteOffset++}writeInt8(N){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,N),this._byteOffset++}writeInt16(N){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,N,!0),this._byteOffset+=2}writeUInt16(N){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,N,!0),this._byteOffset+=2}writeInt32(N){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,N,!0),this._byteOffset+=4}writeUInt32(N){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,N,!0),this._byteOffset+=4}writeFloat32(N){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,N,!0),this._byteOffset+=4}writeFloat64(N){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,N,!0),this._byteOffset+=8}_checkGrowBuffer(N){const U=this.byteOffset+N;if(U>this._data.byteLength){const N=new Uint8Array(2*U);N.set(this._data),this._data=N,this._dataView=new DataView(this._data.buffer)}}}function SN(N){return N%4===0?4:N%2===0?2:1}class EN{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(N){let U=0;this._bufferViewToData.forEach((N=>{U+=N.byteLength}));const V=new zN(U),A=Array.from(this._bufferViewToData.keys()).sort(((N,U)=>SN(U.byteLength)-SN(N.byteLength)));for(const t of A){t.byteOffset=V.byteOffset,N.push(t);const U=N.length-1,A=this.getPropertiesWithBufferView(t);for(const N of A)N.bufferView=U;V.writeTypedArray(this._bufferViewToData.get(t)),this._bufferViewToData.delete(t)}return V.getOutputData()}createBufferView(N,U){const V={buffer:0,byteOffset:void 0,byteLength:N.byteLength,byteStride:U};return this._bufferViewToData.set(V,N),V}createAccessor(N,U,V,A,t,n,q){this._verifyBufferView(N);const i={bufferView:void 0,componentType:V,count:A,type:U,min:null===n||void 0===n?void 0:n.min,max:null===n||void 0===n?void 0:n.max,normalized:q,byteOffset:t};return this.setBufferView(i,N),this._accessorToBufferView.set(i,N),i}setBufferView(N,U){this._verifyBufferView(U);this.getPropertiesWithBufferView(U).push(N)}removeBufferView(N){const U=this.getPropertiesWithBufferView(N);for(const V of U)void 0!==V.bufferView&&delete V.bufferView;this._bufferViewToData.delete(N),this._bufferViewToProperties.delete(N),this._accessorToBufferView.forEach(((U,V)=>{U===N&&(void 0!==V.byteOffset&&delete V.byteOffset,this._accessorToBufferView.delete(V))}))}getBufferView(N){const U=this._accessorToBufferView.get(N);return this._verifyBufferView(U),U}getPropertiesWithBufferView(N){return this._verifyBufferView(N),this._bufferViewToProperties.set(N,this._bufferViewToProperties.get(N)??[]),this._bufferViewToProperties.get(N)}getData(N){return this._verifyBufferView(N),this._bufferViewToData.get(N)}_verifyBufferView(N){if(void 0===N||!this._bufferViewToData.has(N))throw new Error(`BufferView ${N} not found in BufferManager.`)}}var pN,kN=V(12803),BN=V(12823),CN=V(12844),xN=V(12725),JN=V(12876),dN=V(12886),rN=V(12799),vN=V(12895);!function(N){N[N.INTANGENT=0]="INTANGENT",N[N.OUTTANGENT=1]="OUTTANGENT"}(pN||(pN={}));class hN{static _IsTransformable(N){return N&&(N instanceof p.b||N instanceof kN.b||N instanceof vN.e)}static _CreateNodeAnimation(N,U,V,A,n){if(this._IsTransformable(N)){const q=[],i=[],z=U.getKeys(),S=hN._CalculateMinMaxKeyFrames(z),E=hN._DeduceInterpolation(z,V,A),p=E.interpolationType,k=E.shouldBakeAnimation;if(k?hN._CreateBakedAnimation(N,U,V,S.min,S.max,U.framePerSecond,n,q,i,S,A):"LINEAR"===p||"STEP"===p?hN._CreateLinearOrStepAnimation(N,U,V,q,i,A):"CUBICSPLINE"===p?hN._CreateCubicSplineAnimation(N,U,V,q,i,A):hN._CreateBakedAnimation(N,U,V,S.min,S.max,U.framePerSecond,n,q,i,S,A),q.length&&i.length){return{inputs:q,outputs:i,samplerInterpolation:p,inputsMin:k?S.min:t.Tools.FloatRound(S.min/U.framePerSecond),inputsMax:k?S.max:t.Tools.FloatRound(S.max/U.framePerSecond)}}}return null}static _DeduceAnimationInfo(N){let U=null,V="VEC3",A=!1;const n=N.targetProperty.split(".");switch(n[0]){case"ci":U="scale";break;case"position":U="translation";break;case"rotation":V="VEC4",U="rotation";break;case"rotationQuaternion":V="VEC4",A=!0,U="rotation";break;case"influence":V="SCALAR",U="weights";break;default:t.Tools.Error(`Unsupported animatable property ${n[0]}`)}return U?{animationChannelTargetPath:U,dataAccessorType:V,useQuaternion:A}:(t.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(N,U,V,A,t,n,q,i,z,S,E){let p;if(hN._IsTransformable(N)&&N.animations)for(const k of N.animations){if(E&&!E(k))continue;const t=hN._DeduceAnimationInfo(k);t&&(p={name:k.name,samplers:[],channels:[]},hN._AddAnimation(`${k.name}`,k.hasRunningRuntimeAnimations?U:p,N,k,t.dataAccessorType,t.animationChannelTargetPath,A,n,q,i,t.useQuaternion,z,S),p.samplers.length&&p.channels.length&&V.push(p))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(N,U,V,A,t,n,q,i,z,S,E){let p;if(N instanceof rN.b){const t=N.morphTargetManager;if(t)for(let k=0;k<t.numTargets;++k){const B=t.getTarget(k);for(const C of B.animations){if(E&&!E(C))continue;const B=new JN.e(`${C.name}`,"influence",C.framePerSecond,C.dataType,C.loopMode,C.enableBlending),x=[],J=C.getKeys();for(let N=0;N<J.length;++N){const U=J[N];for(let N=0;N<t.numTargets;++N)N==k?x.push(U):x.push({frame:U.frame,value:0})}B.setKeys(x);const d=hN._DeduceAnimationInfo(B);d&&(p={name:B.name,samplers:[],channels:[]},hN._AddAnimation(C.name,C.hasRunningRuntimeAnimations?U:p,N,B,d.dataAccessorType,d.animationChannelTargetPath,A,n,q,i,d.useQuaternion,z,S,t.numTargets),p.samplers.length&&p.channels.length&&V.push(p))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(N,U,V,A,t,n,q,i,z){let S;if(N.animationGroups){const p=N.animationGroups;for(const k of p){const p=new Map,B=new Map,C=new Set,x=k.to-k.from;S={name:k.name,channels:[],samplers:[]};for(let U=0;U<k.targetedAnimations.length;++U){const x=k.targetedAnimations[U],J=x.target,d=x.animation;if(z&&!z(d))continue;const r=i.has(J);if(this._IsTransformable(J)||1===J.length&&this._IsTransformable(J[0])){const N=hN._DeduceAnimationInfo(x.animation);if(N){const U=this._IsTransformable(J)?J:this._IsTransformable(J[0])?J[0]:null;U&&hN._AddAnimation(`${d.name}`,S,U,d,N.dataAccessorType,N.animationChannelTargetPath,V,A,t,n,N.useQuaternion,q,r)}}else if(J instanceof dN.b||1===J.length&&J[0]instanceof dN.b){if(hN._DeduceAnimationInfo(x.animation)){const U=J instanceof dN.b?J:J[0];if(U){const V=N.morphTargetManagers.find((N=>{for(let V=0;V<N.numTargets;++V)if(N.getTarget(V)===U)return!0;return!1}));if(V){const A=N.meshes.find((N=>N.morphTargetManager===V));var E;if(A)p.has(A)||p.set(A,new Map),null===(E=p.get(A))||void 0===E||E.set(U,d),C.add(A),B.set(A,d)}}}}}C.forEach((N=>{const U=N.morphTargetManager;let i=null;const z=[],E=B.get(N).getKeys(),C=E.length;for(let V=0;V<C;++V)for(let A=0;A<U.numTargets;++A){const t=U.getTarget(A),n=p.get(N);if(n){const U=n.get(t);U?(i||(i=new JN.e(`${k.name}_${N.name}_MorphWeightAnimation`,"influence",U.framePerSecond,JN.e.ANIMATIONTYPE_FLOAT,U.loopMode,U.enableBlending)),z.push(U.getKeys()[V])):z.push({frame:k.from+x/C*V,value:t.influence,inTangent:E[0].inTangent?0:void 0,outTangent:E[0].outTangent?0:void 0})}}i.setKeys(z);const J=hN._DeduceAnimationInfo(i);J&&hN._AddAnimation(`${k.name}_${N.name}_MorphWeightAnimation`,S,N,i,J.dataAccessorType,J.animationChannelTargetPath,V,A,t,n,J.useQuaternion,q,!1,null===U||void 0===U?void 0:U.numTargets)})),S.channels.length&&S.samplers.length&&U.push(S)}}}static _AddAnimation(N,U,V,t,n,q,i,z,S,E,p,k,B,C){const x=hN._CreateNodeAnimation(V,t,q,p,k);let J,d,r,v,h,c;if(x){if(C){let N=0,U=0;const V=[];for(;x.inputs.length>0;)U=x.inputs.shift(),N%C==0&&V.push(U),N++;x.inputs=V}const N=i.get(V),t=new Float32Array(x.inputs);J=z.createBufferView(t),d=z.createAccessor(J,"SCALAR",5126,x.inputs.length,void 0,{min:[x.inputsMin],max:[x.inputsMax]}),E.push(d),r=E.length-1;const S=new A.Quaternion,p=new A.CU,k=new A.CU,H=V instanceof kN.b,Y=P(n),W=new Float32Array(x.outputs.length*Y);x.outputs.forEach((function(N,U){let V=N;switch(q){case"translation":B&&(A.CU.FromArrayToRef(N,0,k),Z(k),k.toArray(V));break;case"rotation":4===N.length?A.Quaternion.FromArrayToRef(N,0,S):(V=new Array(4),A.CU.FromArrayToRef(N,0,p),A.Quaternion.FromEulerVectorToRef(p,S)),B&&(b(S),H&&y(S)),S.toArray(V)}W.set(V,U*Y)})),J=z.createBufferView(W),d=z.createAccessor(J,n,5126,x.outputs.length),E.push(d),v=E.length-1,h={interpolation:x.samplerInterpolation,input:r,output:v},U.samplers.push(h),c={sampler:U.samplers.length-1,target:{node:N,path:q}},U.channels.push(c)}}static _CreateBakedAnimation(N,U,V,n,q,i,z,S,E,p,k){let B;const C=A.Quaternion.Identity();let x,J=null,d=null,r=null,v=null,h=null,c=null;p.min=t.Tools.FloatRound(n/i);const H=U.getKeys();for(let A=0,Y=H.length;A<Y;++A){if(c=null,r=H[A],A+1<Y)if(v=H[A+1],r.value.equals&&r.value.equals(v.value)||r.value===v.value){if(0!==A)continue;c=r.frame}else c=v.frame;else{if(h=H[A-1],r.value.equals&&r.value.equals(h.value)||r.value===h.value)continue;c=q}if(c)for(let A=r.frame;A<=c;A+=z){if(x=t.Tools.FloatRound(A/i),x===J)continue;J=x,d=x;const n={key:0,repeatCount:0,loopMode:U.loopMode};B=U._interpolate(A,n),hN._SetInterpolatedValue(N,B,x,U,V,C,S,E,k)}}d&&(p.max=d)}static _ConvertFactorToVector3OrQuaternion(N,U,V,n,q){const i=hN._GetBasePositionRotationOrScale(U,n,q),z=V.targetProperty.split("."),S=z?z[1]:"",E=q?A.Quaternion.vU(i).normalize():A.CU.vU(i);switch(S){case"x":case"y":case"z":E[S]=N;break;case"w":E.w=N;break;default:t.Tools.Error(`glTFAnimation: Unsupported component name "${S}"!`)}return E}static _SetInterpolatedValue(N,U,V,t,n,q,i,z,S){let E;i.push(V),"weights"!==n?(t.dataType===JN.e.ANIMATIONTYPE_FLOAT&&(U=this._ConvertFactorToVector3OrQuaternion(U,N,t,n,S)),"rotation"===n?(S?q=U:(E=U,A.Quaternion.RotationYawPitchRollToRef(E.y,E.x,E.z,q)),z.push(q.pi())):(E=U,z.push(E.pi()))):z.push([U])}static _CreateLinearOrStepAnimation(N,U,V,A,t,n){for(const q of U.getKeys())A.push(q.frame/U.framePerSecond),hN._AddKeyframeValue(q,U,t,V,N,n)}static _CreateCubicSplineAnimation(N,U,V,A,t,n){U.getKeys().forEach((function(q){A.push(q.frame/U.framePerSecond),hN._AddSplineTangent(pN.INTANGENT,t,V,"CUBICSPLINE",q,n),hN._AddKeyframeValue(q,U,t,V,N,n),hN._AddSplineTangent(pN.OUTTANGENT,t,V,"CUBICSPLINE",q,n)}))}static _GetBasePositionRotationOrScale(N,U,V){let t;if("rotation"===U)if(V){t=(N.rotationQuaternion??A.Quaternion.Identity()).pi()}else{t=(N.rotation??A.CU.Zero()).pi()}else if("translation"===U){t=(N.position??A.CU.Zero()).pi()}else{t=(N.ci??A.CU.One()).pi()}return t}static _AddKeyframeValue(N,U,V,n,q,i){let z;const S=U.dataType;if(S===JN.e.ANIMATIONTYPE_VECTOR3){let U=N.value.pi();if("rotation"===n){const N=A.CU.vU(U);U=A.Quaternion.RotationYawPitchRoll(N.y,N.x,N.z).pi()}V.push(U)}else if(S===JN.e.ANIMATIONTYPE_FLOAT){if("weights"===n)V.push([N.value]);else if(z=this._ConvertFactorToVector3OrQuaternion(N.value,q,U,n,i),z){if("rotation"===n){const N=i?z:A.Quaternion.RotationYawPitchRoll(z.y,z.x,z.z).normalize();V.push(N.pi())}V.push(z.pi())}}else S===JN.e.ANIMATIONTYPE_QUATERNION?V.push(N.value.normalize().pi()):t.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(N,U,V){let A,t,n=!1;if("rotation"===U&&!V)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let q=0,i=N.length;q<i;++q)if(t=N[q],t.inTangent||t.outTangent)if(A){if("CUBICSPLINE"!==A){A="LINEAR",n=!0;break}}else A="CUBICSPLINE";else if(A){if("CUBICSPLINE"===A||t.interpolation&&1===t.interpolation&&"STEP"!==A){A="LINEAR",n=!0;break}}else A=t.interpolation&&1===t.interpolation?"STEP":"LINEAR";return A||(A="LINEAR"),{interpolationType:A,shouldBakeAnimation:n}}static _AddSplineTangent(N,U,V,t,n,q){let i;const z=N===pN.INTANGENT?n.inTangent:n.outTangent;if("CUBICSPLINE"===t){if("rotation"===V)if(z)if(q)i=z.pi();else{const N=z;i=A.Quaternion.RotationYawPitchRoll(N.y,N.x,N.z).pi()}else i=[0,0,0,0];else i="weights"===V?z?[z]:[0]:z?z.pi():[0,0,0];U.push(i)}}static _CalculateMinMaxKeyFrames(N){let U=1/0,V=-1/0;return N.forEach((function(N){U=Math.min(U,N.frame),V=Math.max(V,N.frame)})),{min:U,max:V}}}function cN(N,U,V,n,q,i){const z={attributes:{},influence:N.influence,name:N.name},S=U.Ji;if(!S)return t.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),z;const p=i?-1:1,k=A.CU.Zero();let B=0,C=0;if(N.hasPositions){const n=N.getPositions(),i=S.getVerticesData(E.f.PositionKind);if(i){const N=new Float32Array(i.length),U=[1/0,1/0,1/0],t=[-1/0,-1/0,-1/0];C=i.length/3,B=0;for(let V=B;V<C;++V){const q=A.CU.vU(i,3*V);A.CU.vU(n,3*V).subtractToRef(q,k),k.x*=p,U[0]=Math.min(U[0],k.x),t[0]=Math.max(t[0],k.x),U[1]=Math.min(U[1],k.y),t[1]=Math.max(t[1],k.y),U[2]=Math.min(U[2],k.z),t[2]=Math.max(t[2],k.z),N[3*V]=k.x,N[3*V+1]=k.y,N[3*V+2]=k.z}const S=V.createBufferView(N,12),E=V.createAccessor(S,"VEC3",5126,n.length/3,0,{min:U,max:t});q.push(E),z.attributes.POSITION=q.length-1}else t.Tools.Warn(`Morph target positions for mesh ${U.name} were not exported. Mesh does not have position vertex data`)}if(N.hasNormals){const n=N.getNormals(),i=S.getVerticesData(E.f.NormalKind);if(i){const N=new Float32Array(i.length);C=i.length/3,B=0;for(let V=B;V<C;++V){const U=A.CU.vU(i,3*V).normalize();A.CU.vU(n,3*V).normalize().subtractToRef(U,k),N[3*V]=k.x*p,N[3*V+1]=k.y,N[3*V+2]=k.z}const U=V.createBufferView(N,12),t=V.createAccessor(U,"VEC3",5126,n.length/3,0);q.push(t),z.attributes.NORMAL=q.length-1}else t.Tools.Warn(`Morph target normals for mesh ${U.name} were not exported. Mesh does not have normals vertex data`)}if(N.hasTangents){const n=N.getTangents(),i=S.getVerticesData(E.f.TangentKind);if(i){C=i.length/4;const N=new Float32Array(3*C);B=0;for(let V=B;V<C;++V){const U=A.CU.vU(i,4*V);O(U);const t=A.CU.vU(n,3*V);O(t),t.subtractToRef(U,k),N[3*V]=k.x*p,N[3*V+1]=k.y,N[3*V+2]=k.z}const U=V.createBufferView(N,12),t=V.createAccessor(U,"VEC3",5126,C,0);q.push(t),z.attributes.TANGENT=q.length-1}else t.Tools.Warn(`Morph target tangents for mesh ${U.name} were not exported. Mesh does not have tangents vertex data`)}if(N.hasColors){const n=N.getColors(),i=S.getVerticesData(E.f.ColorKind),p=S.getVertexBuffer(E.f.ColorKind);if(i&&p){const N=p.getSize();C=i.length/N;const U=new Float32Array(C*N);B=0;for(let V=B;V<C;++V)if(3===N){const t=A.CU.vU(i,V*N);A.CU.vU(n,V*N).subtractToRef(t,k),U[3*V]=k.x,U[3*V+1]=k.y,U[3*V+2]=k.z}else if(4===N){const t=new A.Vector4,q=A.Vector4.vU(i,V*N);A.Vector4.vU(n,V*N).subtractToRef(q,t),U[4*V]=t.x,U[4*V+1]=t.y,U[4*V+2]=t.z,U[4*V+3]=t.w}else t.Tools.Warn(`Unsupported number of components for color attribute: ${N}`);const S=V.createBufferView(U,4*N),E=V.createAccessor(S,3===N?"VEC3":"VEC4",5126,C,0);q.push(E),z.attributes.COLOR_0=q.length-1}else t.Tools.Warn(`Morph target colors for mesh ${U.name} were not exported. Mesh does not have colors vertex data`)}return z}var HN=V(12898),YN=V(12743),WN=V(12732),sN=V(12344);class MN{}MN.DEFAULT_COLOR=J.rU.White(),MN.DEFAULT_WIDTH_ATTENUATED=1,MN.DEFAULT_WIDTH=.1;var aN=V(12576),mU=V(12905);class wN{static ConvertPoints(N,U){if(N.length&&Array.isArray(N)&&"number"===typeof N[0])return[N];if(N.length&&Array.isArray(N[0])&&"number"===typeof N[0][0])return N;if(N.length&&!Array.isArray(N[0])&&N[0]instanceof A.CU){const U=[];for(let V=0;V<N.length;V++){const A=N[V];U.push(A.x,A.y,A.z)}return[U]}if(N.length>0&&Array.isArray(N[0])&&N[0].length>0&&N[0][0]instanceof A.CU){const U=[],V=N;for(const N of V)U.push(N.flatMap((N=>[N.x,N.y,N.z])));return U}if(N instanceof Float32Array){if(null!==U&&void 0!==U&&U.floatArrayStride){const V=[],A=3*U.floatArrayStride;for(let U=0;U<N.length;U+=A){const t=new Array(A);for(let V=0;V<A;V++)t[V]=N[U+V];V.push(t)}return V}return[Array.from(N)]}if(N.length&&N[0]instanceof Float32Array){const U=[];for(const V of N)U.push(Array.from(V));return U}return[]}static OmitZeroLengthPredicate(N,U,V){const A=[];return U.xU(N).lengthSquared()>0&&A.push([N,U]),V.xU(U).lengthSquared()>0&&A.push([U,V]),N.xU(V).lengthSquared()>0&&A.push([V,N]),0===A.length?null:A}static OmitDuplicatesPredicate(N,U,V,A){const t=[];return wN._SearchInPoints(N,U,A)||t.push([N,U]),wN._SearchInPoints(U,V,A)||t.push([U,V]),wN._SearchInPoints(V,N,A)||t.push([V,N]),0===t.length?null:t}static _SearchInPoints(N,U,V){for(const q of V)for(let V=0;V<q.length;V++){var A,t,n;if(null!==(A=q[V])&&void 0!==A&&A.equals(N))if(null!==(t=q[V+1])&&void 0!==t&&t.equals(U)||null!==(n=q[V-1])&&void 0!==n&&n.equals(U))return!0}return!1}static MeshesToLines(N,U){const V=[];for(let t=0;t<N.length;t++){const n=N[t],q=n.getVerticesData(E.f.PositionKind),i=n.di();if(q&&i)for(let N=0,z=0;N<i.length;N++){const S=3*i[z++],E=3*i[z++],p=3*i[z++],k=new A.CU(q[S],q[S+1],q[S+2]),B=new A.CU(q[E],q[E+1],q[E+2]),C=new A.CU(q[p],q[p+1],q[p+2]);if(U){const A=U(k,B,C,V,N,S,n,t,q,i);if(A)for(const N of A)V.push(N)}else V.push([k,B],[B,C],[C,k])}}return V}static ToVector3Array(N){if(Array.isArray(N[0])){const U=[],V=N;for(const N of V){const V=[];for(let U=0;U<N.length;U+=3)V.push(new A.CU(N[U],N[U+1],N[U+2]));U.push(V)}return U}const U=N,V=[];for(let t=0;t<U.length;t+=3)V.push(new A.CU(U[t],U[t+1],U[t+2]));return V}static ToNumberArray(N){return N.flatMap((N=>[N.x,N.y,N.z]))}static GetPointsCountInfo(N){const U=new Array(N.length);let V=0;for(let A=N.length;A--;)U[A]=N[A].length/3,V+=U[A];return{total:V,counts:U}}static GetLineLength(N){if(0===N.length)return 0;let U;U="number"===typeof N[0]?wN.ToVector3Array(N):N;const V=A.TmpVectors.CU[0];let t=0;for(let A=0;A<U.length-1;A++){const N=U[A];t+=U[A+1].subtractToRef(N,V).length()}return t}static GetLineLengthArray(N){const U=new Float32Array(N.length/3);let V=0;for(let A=0,t=N.length/3-1;A<t;A++){let t=N[3*A+0],n=N[3*A+1],q=N[3*A+2];t-=N[3*A+3],n-=N[3*A+4],q-=N[3*A+5];V+=Math.sqrt(t*t+n*n+q*q),U[A+1]=V}return U}static SegmentizeSegmentByCount(N,U,V){const t=[],n=U.xU(N),q=A.TmpVectors.CU[0];q.Hi(V);const i=A.TmpVectors.CU[1];n.divideToRef(q,i);let z=N.clone();t.push(z);for(let A=0;A<V;A++)z=z.clone(),t.push(z.addInPlace(i));return t}static SegmentizeLineBySegmentLength(N,U){const V=N[0]instanceof A.CU?wN.GetLineSegments(N):"number"===typeof N[0]?wN.GetLineSegments(wN.ToVector3Array(N)):N,t=[];for(const A of V)if(A.length>U){const N=wN.SegmentizeSegmentByCount(A.point1,A.point2,Math.ceil(A.length/U));for(const U of N)t.push(U)}else t.push(A.point1),t.push(A.point2);return t}static SegmentizeLineBySegmentCount(N,U){const V="number"===typeof N[0]?wN.ToVector3Array(N):N,A=wN.GetLineLength(V)/U;return wN.SegmentizeLineBySegmentLength(V,A)}static GetLineSegments(N){const U=[];for(let V=0;V<N.length-1;V++){const A=N[V],t=N[V+1],n=t.xU(A).length();U.push({point1:A,point2:t,length:n})}return U}static GetMinMaxSegmentLength(N){const U=wN.GetLineSegments(N).sort((N=>N.length));return{min:U[0].length,max:U[U.length-1].length}}static GetPositionOnLineByVisibility(N,U,V){let t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const n=U*V;let q=0,i=0;const z=N.length;for(let A=0;A<z;A++){if(n<=q+N[A].length){i=A;break}q+=N[A].length}const S=(n-q)/N[i].length;return N[i].point2.subtractToRef(N[i].point1,A.TmpVectors.CU[0]),A.TmpVectors.CU[1]=A.TmpVectors.CU[0].multiplyByFloats(S,S,S),t||A.TmpVectors.CU[1].addInPlace(N[i].point1),A.TmpVectors.CU[1].clone()}static GetCircleLinePoints(N,U){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/U;const q=[];for(let i=0;i<=U;i++)q.push(new A.CU(Math.cos(i*n)*N,Math.sin(i*n)*t,V));return q}static GetBezierLinePoints(N,U,V,A){return aN.h.CreateQuadraticBezier(N,U,V,A).getPoints().flatMap((N=>[N.x,N.y,N.z]))}static GetArrowCap(N,U,V,A,t){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[N.clone(),N.add(U.multiplyByFloats(V,V,V))],widths:[A,t,n,q]}}static GetPointsFromText(N,U,V,A){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const q=[],i=(0,mU.c)(N,U,V,A);for(const z of i){for(const N of z.paths){const U=[],V=N.getPoints();for(const N of V)U.push(N.x,N.y,t);q.push(U)}if(n)for(const N of z.holes){const U=[],V=N.getPoints();for(const N of V)U.push(N.x,N.y,t);q.push(U)}}return q}static Color3toRGBAUint8(N){const U=new Uint8Array(4*N.length);for(let V=0,A=0;V<N.length;V++)U[A++]=255*N[V].r,U[A++]=255*N[V].g,U[A++]=255*N[V].b,U[A++]=255;return U}static CreateColorsTexture(N,U,V,A){const t=A.getEngine().getCaps().maxTextureSize??1,n=U.length>t?t:U.length,q=Math.ceil(U.length/t);q>1&&(U=[...U,...Array(n*q-U.length).fill(U[0])]);const i=wN.Color3toRGBAUint8(U),z=new H.b(i,n,q,C.e.TEXTUREFORMAT_RGBA,A,!1,!0,V);return z.name=N,z}static PrepareEmptyColorsTexture(N){if(!MN.EmptyColorsTexture){const U=new Uint8Array(4);MN.EmptyColorsTexture=new H.b(U,1,1,C.e.TEXTUREFORMAT_RGBA,N,!1,!1,H.b.NEAREST_NEAREST),MN.EmptyColorsTexture.name="grlEmptyColorsTexture"}return MN.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var N;null===(N=MN.EmptyColorsTexture)||void 0===N||N.dispose(),MN.EmptyColorsTexture=null}static BooleanToNumber(N){return N?1:0}}class XN extends WN.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class eN extends YN.e{isCompatible(N){return!0}constructor(N,U,V){var t;V=V||{color:MN.DEFAULT_COLOR};const n=new XN;n.GREASED_LINE_HAS_COLOR=!!V.color&&!V.useColors,n.GREASED_LINE_SIZE_ATTENUATION=V.sizeAttenuation??!1,n.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===V.colorDistributionType,n.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(U??N.YN()).useRightHandedSystem,n.GREASED_LINE_CAMERA_FACING=V.cameraFacing??!0,super(N,eN.GREASED_LINE_MATERIAL_NAME,200,n,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(t=V)||void 0===t?void 0:t.forceGLSL)||eN.ForceGLSL,this._scene=U??N.YN(),this._engine=this._scene.getEngine(),this._cameraFacing=V.cameraFacing??!0,this.visibility=V.visibility??1,this.useDash=V.useDash??!1,this.dashRatio=V.dashRatio??.5,this.dashOffset=V.dashOffset??0,this.width=V.width?V.width:V.sizeAttenuation?MN.DEFAULT_WIDTH_ATTENUATED:MN.DEFAULT_WIDTH,this._sizeAttenuation=V.sizeAttenuation??!1,this.colorMode=V.colorMode??0,this._color=V.color??null,this.useColors=V.useColors??!1,this._colorsDistributionType=V.colorDistributionType??0,this.colorsSampling=V.colorsSampling??H.b.NEAREST_NEAREST,this._colors=V.aN??null,this.dashCount=V.dashCount??1,this.resolution=V.resolution??new A.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),V.colorsTexture?this.colorsTexture=V.colorsTexture:this._colors?this.colorsTexture=wN.CreateColorsTexture(`${N.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??MN.DEFAULT_COLOR,wN.PrepareEmptyColorsTexture(this._scene)),this._engine.Ai.add((()=>{wN.DisposeEmptyColorsTexture()}))}getAttributes(N){N.push("grl_offsets"),N.push("grl_widths"),N.push("grl_colorPointers"),N.push("grl_counters"),this._cameraFacing?(N.push("grl_previousAndSide"),N.push("grl_nextAndCounters")):N.push("grl_slopes")}getSamplers(N){N.push("grl_colors")}getActiveTextures(N){this.colorsTexture&&N.push(this.colorsTexture)}getUniforms(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const U=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&U.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===N&&U.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:U,vertex:this._cameraFacing&&this._isGLSL(N)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(N)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(N){if(this._cameraFacing){N.Ci("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||N.Ci("viewProjection",this._scene.getTransformMatrix());const U=A.TmpVectors.Vector4[0];U.x=this._aspect,U.y=this._resolution.x,U.z=this._resolution.y,U.w=this.width,N.updateVector4("grl_aspect_resolution_lineWidth",U)}const U=A.TmpVectors.Vector4[0];U.x=wN.BooleanToNumber(this.useDash),U.y=this._dashArray,U.z=this.dashOffset,U.w=this.dashRatio,N.updateVector4("grl_dashOptions",U);const V=A.TmpVectors.Vector4[1];V.x=this.colorMode,V.y=this.visibility,V.z=this.colorsTexture?this.colorsTexture.getSize().width:0,V.w=wN.BooleanToNumber(this.useColors),N.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",V),this._color&&N.updateColor3("grl_singleColor",this._color);const t=this.colorsTexture??MN.EmptyColorsTexture;N.setTexture("grl_colors",t),N.updateFloat2("grl_textureSize",(null===t||void 0===t?void 0:t.getSize().width)??1,(null===t||void 0===t?void 0:t.getSize().height)??1)}prepareDefines(N,U,V){N.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,N.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,N.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,N.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=U.useRightHandedSystem,N.GREASED_LINE_CAMERA_FACING=this._cameraFacing,N.GREASED_LINE_USE_OFFSETS=!!V.offsets}getClassName(){return eN.GREASED_LINE_MATERIAL_NAME}getCustomCode(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(U)?function(N,U){if("vertex"===N){const N={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return U&&(N["!gl_Position\\=viewProjection\\*worldPos;"]="//"),N}return"fragment"===N?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(N,this._cameraFacing):function(N,U){if("vertex"===N){const N={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return U&&(N["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),N}return"fragment"===N?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(N,this._cameraFacing)}dispose(){var N;null===(N=this.colorsTexture)||void 0===N||N.dispose(),super.dispose()}get aN(){return this._colors}set aN(N){this.setColors(N)}setColors(N){var U;let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var n;if(this._colors=N,null!==N&&0!==N.length){if(!V||A)if(this.colorsTexture&&t===N.length&&!A){const U=wN.Color3toRGBAUint8(N);this.colorsTexture.update(U)}else{var q;null===(q=this.colorsTexture)||void 0===q||q.dispose(),this.colorsTexture=wN.CreateColorsTexture(`${this._material.name}-colors-texture`,N,this.colorsSampling,this._scene)}}else null===(n=this.colorsTexture)||void 0===n||n.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(N){this._dashCount=N,this._dashArray=1/N}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(N){this._sizeAttenuation=N,this.markAllDefinesAsDirty()}get color(){return this._color}set color(N){this.setColor(N)}setColor(N){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==N||null!==this._color&&null===N?(this._color=N,U||this.markAllDefinesAsDirty()):this._color=N}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(N){this._colorsDistributionType=N,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(N){this._aspect=N.x/N.y,this._resolution=N}serialize(){const N=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(U.aN=this._colors),this._color&&(U.color=this._color),N.greasedLineMaterialOptions=U,N}parse(N,U,V){var A;super.parse(N,U,V);const t=N.greasedLineMaterialOptions;null===(A=this.colorsTexture)||void 0===A||A.dispose(),t.color&&this.setColor(t.color,!0),t.colorDistributionType&&(this.colorsDistributionType=t.colorDistributionType),t.aN&&(this.aN=t.aN),t.colorsSampling&&(this.colorsSampling=t.colorsSampling),t.colorMode&&(this.colorMode=t.colorMode),t.useColors&&(this.useColors=t.useColors),t.visibility&&(this.visibility=t.visibility),t.useDash&&(this.useDash=t.useDash),t.dashCount&&(this.dashCount=t.dashCount),t.dashRatio&&(this.dashRatio=t.dashRatio),t.dashOffset&&(this.dashOffset=t.dashOffset),t.width&&(this.width=t.width),t.sizeAttenuation&&(this.sizeAttenuation=t.sizeAttenuation),t.resolution&&(this.resolution=t.resolution),this.aN?this.colorsTexture=wN.CreateColorsTexture(`${this._material.name}-colors-texture`,this.aN,this.colorsSampling,U):wN.PrepareEmptyColorsTexture(U),this.markAllDefinesAsDirty()}copyTo(N){var U;const V=N;null===(U=V.colorsTexture)||void 0===U||U.dispose(),this._colors&&(V.colorsTexture=wN.CreateColorsTexture(`${V._material.name}-colors-texture`,this._colors,V.colorsSampling,this._scene)),V.setColor(this.color,!0),V.colorsDistributionType=this.colorsDistributionType,V.colorsSampling=this.colorsSampling,V.colorMode=this.colorMode,V.useColors=this.useColors,V.visibility=this.visibility,V.useDash=this.useDash,V.dashCount=this.dashCount,V.dashRatio=this.dashRatio,V.dashOffset=this.dashOffset,V.width=this.width,V.sizeAttenuation=this.sizeAttenuation,V.resolution=this.resolution,V.markAllDefinesAsDirty()}_isGLSL(N){return 0===N||this._forceGLSL}}eN.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",eN.ForceGLSL=!1,(0,sN.e)(`BABYLON.${eN.GREASED_LINE_MATERIAL_NAME}`,eN);var QN=V(12781),uN=V(12197),LN=V(12598),IN=V(12328);class oN extends LN.ShaderMaterial{constructor(N,U,t){const n=U.getEngine(),q=n.isWebGPU&&!(t.forceGLSL||oN.ForceGLSL),i=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];U.useRightHandedSystem&&i.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const z=["position","grl_widths","grl_offsets","grl_colorPointers"];t.cameraFacing?(i.push("GREASED_LINE_CAMERA_FACING"),z.push("grl_previousAndSide","grl_nextAndCounters")):(z.push("grl_slopes"),z.push("grl_counters"));const S=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(q||S.push("world","viewProjection","view","projection"),super(N,U,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:q?["Scene","Mesh"]:void 0,attributes:z,uniforms:S,samplers:q?[]:["grlColors"],defines:i,extraInitializationsAsync:async()=>{q?await Promise.all([V.e(66).then(V.bind(V,15499)),V.e(75).then(V.bind(V,15504))]):await Promise.all([V.e(69).then(V.bind(V,15506)),V.e(76).then(V.bind(V,15513))])},shaderLanguage:q?1:0}),this._color=J.rU.White(),this._colorsDistributionType=0,this._colorsTexture=null,t=t||{color:MN.DEFAULT_COLOR},this.visibility=t.visibility??1,this.useDash=t.useDash??!1,this.dashRatio=t.dashRatio??.5,this.dashOffset=t.dashOffset??0,this.dashCount=t.dashCount??1,this.width=t.width?t.width:t.sizeAttenuation&&t.cameraFacing?MN.DEFAULT_WIDTH_ATTENUATED:MN.DEFAULT_WIDTH,this.sizeAttenuation=t.sizeAttenuation??!1,this.color=t.color??J.rU.White(),this.useColors=t.useColors??!1,this.colorsDistributionType=t.colorDistributionType??0,this.colorsSampling=t.colorsSampling??H.b.NEAREST_NEAREST,this.colorMode=t.colorMode??0,this._colors=t.aN??null,this._cameraFacing=t.cameraFacing??!0,this.resolution=t.resolution??new A.Vector2(n.getRenderWidth(),n.getRenderHeight()),t.colorsTexture?this.colorsTexture=t.colorsTexture:this._colors?this.colorsTexture=wN.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,U):(this._color=this._color??MN.DEFAULT_COLOR,this.colorsTexture=wN.PrepareEmptyColorsTexture(U)),q){const N=new IN.e;N.setParameters(),N.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",N)}n.Ai.add((()=>{wN.DisposeEmptyColorsTexture()}))}dispose(){var N;null===(N=this._colorsTexture)||void 0===N||N.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new A.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get aN(){return this._colors}set aN(N){this.setColors(N)}setColors(N){var U;let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var n;if(this._colors=N,null!==N&&0!==N.length){if(!V||A)if(this._colorsTexture&&t===N.length&&!A){const U=wN.Color3toRGBAUint8(N);this._colorsTexture.update(U)}else{var q;null===(q=this._colorsTexture)||void 0===q||q.dispose(),this.colorsTexture=wN.CreateColorsTexture(`${this.name}-colors-texture`,N,this.colorsSampling,this.YN())}}else null===(n=this._colorsTexture)||void 0===n||n.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(N){this._colorsTexture=N,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(N){this._width=N,this.setFloat("grlWidth",N)}get useColors(){return this._useColors}set useColors(N){this._useColors=N,this.setFloat("grlUseColors",wN.BooleanToNumber(N))}get colorsSampling(){return this._colorsSampling}set colorsSampling(N){this._colorsSampling=N}get visibility(){return this._visibility}set visibility(N){this._visibility=N,this.setFloat("grlVisibility",N)}get useDash(){return this._useDash}set useDash(N){this._useDash=N,this.setFloat("grlUseDash",wN.BooleanToNumber(N))}get dashOffset(){return this._dashOffset}set dashOffset(N){this._dashOffset=N,this.setFloat("grlDashOffset",N)}get dashRatio(){return this._dashRatio}set dashRatio(N){this._dashRatio=N,this.setFloat("grlDashRatio",N)}get dashCount(){return this._dashCount}set dashCount(N){this._dashCount=N,this._dashArray=1/N,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(N){this._sizeAttenuation=N,this.setFloat("grlSizeAttenuation",wN.BooleanToNumber(N))}get color(){return this._color}set color(N){this.setColor(N)}setColor(N){N=N??MN.DEFAULT_COLOR,this._color=N,this.setColor3("grlColor",N)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(N){this._colorsDistributionType=N,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(N){this._colorMode=N,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(N){this._resolution=N,this.setVector2("grlResolution",N),this.setFloat("grlAspect",N.x/N.y)}serialize(){const N=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(U.aN=this._colors),N.greasedLineMaterialOptions=U,N}parse(N,U,V){var A;const t=N.greasedLineMaterialOptions;null===(A=this._colorsTexture)||void 0===A||A.dispose(),t.color&&(this.color=t.color),t.colorDistributionType&&(this.colorsDistributionType=t.colorDistributionType),t.colorsSampling&&(this.colorsSampling=t.colorsSampling),t.colorMode&&(this.colorMode=t.colorMode),t.useColors&&(this.useColors=t.useColors),t.visibility&&(this.visibility=t.visibility),t.useDash&&(this.useDash=t.useDash),t.dashCount&&(this.dashCount=t.dashCount),t.dashRatio&&(this.dashRatio=t.dashRatio),t.dashOffset&&(this.dashOffset=t.dashOffset),t.width&&(this.width=t.width),t.sizeAttenuation&&(this.sizeAttenuation=t.sizeAttenuation),t.resolution&&(this.resolution=t.resolution),t.aN?this.colorsTexture=wN.CreateColorsTexture(`${this.name}-colors-texture`,t.aN,this.colorsSampling,this.YN()):this.colorsTexture=wN.PrepareEmptyColorsTexture(U),this._cameraFacing=t.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var RN,DN,GN;oN.ForceGLSL=!1,function(N){N[N.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",N[N.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(RN||(RN={})),function(N){N[N.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",N[N.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",N[N.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(DN||(DN={})),function(N){N[N.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",N[N.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",N[N.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",N[N.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",N[N.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(GN||(GN={}));class gN extends rN.b{constructor(N,U,V){super(N,U,null,null,!1,!1),this.name=N,this._options=V,this._lazy=!1,this._updatable=!1,this._engine=U.getEngine(),this._lazy=V.lazy??!1,this._updatable=V.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=V.colorPointers??[],this._widths=V.widths??new Array(V.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(N){let U=0;for(const A of this._points)U+=A.length;const V=U/3*2-this._widths.length;for(let A=0;A<V;A++)this._widths.push(N)}updateLazy(){var N,U;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(N=this._options.ribbonOptions)||void 0===N?void 0:N.smoothShading),!this.eN&&this.refreshBoundingInfo(),null===(U=this.greasedLineMaterial)||void 0===U||U.updateLazy()}addPoints(N,U){for(const V of N)this._points.push(V);this._lazy||this.setPoints(this._points,U)}dispose(N){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(N,U)}isLazy(){return this._lazy}get mU(){return this._uvs}set mU(N){this._uvs=N instanceof Float32Array?N:new Float32Array(N),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(N){this.material instanceof oN&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===N||void 0===N?void 0:N.length)>0),this._offsets=N,this._offsetsBuffer?this._offsetsBuffer.update(N):this._createOffsetsBuffer(N)}get widths(){return this._widths}set widths(N){this._widths=N,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(N)}get colorPointers(){return this._colorPointers}set colorPointers(N){this._colorPointers=N,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(N)}get greasedLineMaterial(){var N,U;if(this.material&&this.material instanceof oN)return this.material;const V=null===(N=this.material)||void 0===N||null===(U=N.pluginManager)||void 0===U?void 0:U.getPlugin(eN.GREASED_LINE_MATERIAL_NAME);return V||void 0}get points(){const N=[];return uN.e.DeepCopy(this._points,N),N}setPoints(N,U){this._points=wN.ConvertPoints(N,(null===U||void 0===U?void 0:U.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==U&&void 0!==U&&U.colorPointers||this._updateColorPointers(),this._setPoints(this._points,U)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,mU:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(N){super.serialize(N),N.type=this.getClassName(),N.lineOptions=this._createLineOptions()}_createVertexBuffers(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new QN.c;return U.sN=this._vertexPositions,U.indices=this._indices,U.mU=this._uvs,N&&(U.MN=[],QN.c.ComputeNormals(this._vertexPositions,this._indices,U.MN)),U.XN(this,this._options.updatable),U}_createOffsetsBuffer(N){const U=this._scene.getEngine(),V=new E.d(U,N,this._updatable,3);this.setVerticesBuffer(V.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=V}}class lN{constructor(N,U){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=N,this.wasAddedByNoopNode=U}getIndicesAccessor(N,U,V,A,t){var n,q,i,z;return null===(n=this._indicesAccessorMap.get(N))||void 0===n||null===(q=n.get(U))||void 0===q||null===(i=q.get(V))||void 0===i||null===(z=i.get(A))||void 0===z?void 0:z.get(t)}setIndicesAccessor(N,U,V,A,t,n){let q=this._indicesAccessorMap.get(N);q||(q=new Map,this._indicesAccessorMap.set(N,q));let i=q.get(U);i||(i=new Map,q.set(U,i));let z=i.get(V);z||(z=new Map,i.set(V,z));let S=z.get(A);S||(S=new Map,z.set(A,S)),S.set(t,n)}pushExportedNode(N){this._exportedNodes.has(N)||this._exportedNodes.add(N)}getNodesSet(){return this._exportedNodes}getVertexBufferView(N){return this._vertexBufferViewMap.get(N)}setVertexBufferView(N,U){this._vertexBufferViewMap.set(N,U)}setRemappedBufferView(N,U,V){this._remappedBufferView.set(N,new Map),this._remappedBufferView.get(N).set(U,V)}getRemappedBufferView(N,U){var V;return null===(V=this._remappedBufferView.get(N))||void 0===V?void 0:V.get(U)}getVertexAccessor(N,U,V){var A,t;return null===(A=this._vertexAccessorMap.get(N))||void 0===A||null===(t=A.get(U))||void 0===t?void 0:t.get(V)}setVertexAccessor(N,U,V,A){let t=this._vertexAccessorMap.get(N);t||(t=new Map,this._vertexAccessorMap.set(N,t));let n=t.get(U);n||(n=new Map,t.set(U,n)),n.set(V,A)}hasVertexColorAlpha(N){return this._vertexMapColorAlpha.get(N)||!1}setHasVertexColorAlpha(N,U){return this._vertexMapColorAlpha.set(N,U)}getMesh(N){return this._meshMap.get(N)}setMesh(N,U){this._meshMap.set(N,U)}bindMorphDataToMesh(N,U){const V=this._meshMorphTargetMap.get(N)||[];this._meshMorphTargetMap.set(N,V),-1===V.indexOf(U)&&V.push(U)}getMorphTargetsFromMesh(N){return this._meshMorphTargetMap.get(N)}}class KN{_ApplyExtension(N,U,V,A){if(V>=U.length)return Promise.resolve(N);const t=A(U[V],N);return t?t.then((async N=>N?await this._ApplyExtension(N,U,V+1,A):null)):this._ApplyExtension(N,U,V+1,A)}_ApplyExtensions(N,U){const V=[];for(const A of KN._ExtensionNames)V.push(this._extensions[A]);return this._ApplyExtension(N,V,0,U)}_extensionsPreExportTextureAsync(N,U,V){return this._ApplyExtensions(U,((U,A)=>U.preExportTextureAsync&&U.preExportTextureAsync(N,A,V)))}_extensionsPostExportNodeAsync(N,U,V,A,t){return this._ApplyExtensions(U,((U,n)=>U.postExportNodeAsync&&U.postExportNodeAsync(N,n,V,A,t,this._bufferManager)))}_extensionsPostExportMaterialAsync(N,U,V){return this._ApplyExtensions(U,((U,A)=>U.postExportMaterialAsync&&U.postExportMaterialAsync(N,A,V)))}_extensionsPostExportMaterialAdditionalTextures(N,U,V){const A=[];for(const t of KN._ExtensionNames){const n=this._extensions[t];n.postExportMaterialAdditionalTextures&&A.push(...n.postExportMaterialAdditionalTextures(N,U,V))}return A}_extensionsPostExportTextures(N,U,V){for(const A of KN._ExtensionNames){const t=this._extensions[A];t.postExportTexture&&t.postExportTexture(N,U,V)}}_extensionsPostExportMeshPrimitive(N){for(const U of KN._ExtensionNames){const V=this._extensions[U];V.postExportMeshPrimitive&&V.postExportMeshPrimitive(N,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const N of KN._ExtensionNames){const U=this._extensions[N];U.preGenerateBinaryAsync&&await U.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(N){for(const U of KN._ExtensionNames){const V=this._extensions[U];V.enabled&&N(V)}}_extensionsOnExporting(){this._forEachExtensions((N=>{var U,V,A;N.wasUsed&&((U=this._glTF).extensionsUsed||(U.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(N.name)&&this._glTF.extensionsUsed.push(N.name),N.required&&((V=this._glTF).extensionsRequired||(V.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(N.name)&&this._glTF.extensionsRequired.push(N.name)),(A=this._glTF).extensions||(A.extensions={}),N.onExporting&&N.onExporting())}))}_loadExtensions(){for(const N of KN._ExtensionNames){const U=KN._ExtensionFactories[N](this);this._extensions[N]=U}}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:x.e.LastCreatedScene,U=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${C.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new I(this),this._extensions={},this._bufferManager=new EN,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!N)throw new Error("No scene available to export");this._babylonScene=N,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:N=>{var U;return null===N||void 0===N||null===(U=N.ii)||void 0===U?void 0:U.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...U},this._loadExtensions()}dispose(){for(const N in this._extensions){this._extensions[N].dispose()}}get options(){return this._options}static RegisterExtension(N,U){KN.UnregisterExtension(N)&&t.Tools.Warn(`Extension with the name ${N} already exists`),KN._ExtensionFactories[N]=U,KN._ExtensionNames.push(N)}static UnregisterExtension(N){if(!KN._ExtensionFactories[N])return!1;delete KN._ExtensionFactories[N];const U=KN._ExtensionNames.indexOf(N);return-1!==U&&KN._ExtensionNames.splice(U,1),!0}_generateJSON(N,U,V){const A={byteLength:N};return A.byteLength&&(this._glTF.buffers=[A]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.JU=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(A.uri=U+".bin"),V?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(N){const U=await this._generateBinaryAsync();this._extensionsOnExporting();const V=this._generateJSON(U.byteLength,N,!0),A=new Blob([U],{type:"application/octet-stream"}),t=N+".gltf",n=N+".bin",q=new S;if(q.files[t]=V,q.files[n]=A,this._imageData)for(const i in this._imageData)q.files[i]=new Blob([this._imageData[i].data],{type:this._imageData[i].mimeType});return q}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(N){const U=N%4;return 0===U?U:4-U}async generateGLBAsync(N){this._shouldUseGlb=!0;const U=await this._generateBinaryAsync();this._extensionsOnExporting();const V=this._generateJSON(U.byteLength),A=N+".glb";let t,n=V.length;if("undefined"!==typeof TextEncoder){t=(new TextEncoder).encode(V),n=t.length}const q=this._getPadding(n),i=this._getPadding(U.byteLength),z=28+n+q+U.byteLength+i,E=new zN(z);if(E.writeUInt32(1179937895),E.writeUInt32(2),E.writeUInt32(z),E.writeUInt32(n+q),E.writeUInt32(1313821514),t)E.writeTypedArray(t);else{const N="_".charCodeAt(0);for(let U=0;U<n;++U){const A=V.charCodeAt(U);A!=V.codePointAt(U)?E.writeUInt8(N):E.writeUInt8(A)}}for(let S=0;S<q;++S)E.writeUInt8(32);E.writeUInt32(U.byteLength+i),E.writeUInt32(5130562),E.writeTypedArray(U);for(let S=0;S<i;++S)E.writeUInt8(0);const p=new S;return p.files[A]=new Blob([E.getOutputData()],{type:"application/octet-stream"}),p}_setNodeTransformation(N,U,V){if(U.getPivotPoint().equalsWithEpsilon(g,G.d)||t.Tools.Warn("Pivot points are not supported in the glTF serializer"),!U.position.equalsWithEpsilon(g,G.d)){const t=A.TmpVectors.CU[0].A(U.position);V&&Z(t),N.translation=t.pi()}U.ci.equalsWithEpsilon(K,G.d)||(N.scale=U.ci.pi());const n=U.rotationQuaternion||A.Quaternion.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);n.equalsWithEpsilon(l,G.d)||(V&&b(n),N.rotation=n.normalize().pi())}_setCameraTransformation(N,U,V){if(!U.position.equalsWithEpsilon(g,G.d)){const t=A.TmpVectors.CU[0].A(U.position);V&&Z(t),N.translation=t.pi()}const t=U.rotationQuaternion||A.Quaternion.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);V&&b(t),this._babylonScene.useRightHandedSystem||y(t),t.equalsWithEpsilon(l,G.d)||(N.rotation=t.pi())}_listAvailableCameras(){for(const N of this._babylonScene.cameras){const U={type:N.mode===kN.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(N.name&&(U.name=N.name),"perspective"===U.type)U.perspective={aspectRatio:N.getEngine().getAspectRatio(N),yfov:N.fovMode===kN.b.FOVMODE_VERTICAL_FIXED?N.fov:N.fov*N.getEngine().getAspectRatio(N),znear:N.Bi,zfar:N.maxZ};else if("orthographic"===U.type){const V=N.orthoLeft&&N.orthoRight?.5*(N.orthoRight-N.orthoLeft):.5*N.getEngine().getRenderWidth(),A=N.orthoBottom&&N.orthoTop?.5*(N.orthoTop-N.orthoBottom):.5*N.getEngine().getRenderHeight();U.orthographic={xmag:V,ymag:A,znear:N.Bi,zfar:N.maxZ}}this._camerasMap.set(N,U)}}_exportAndAssignCameras(){const N=Array.from(this._camerasMap.values());for(const U of N){const N=this._nodesCameraMap.get(U);if(void 0!==N){this._cameras.push(U);for(const U of N)U.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const N of this._babylonScene.skeletons){if(N.bones.length<=0)continue;const U={joints:[]};this._skinMap.set(N,U)}}_exportAndAssignSkeletons(){for(const N of this._babylonScene.skeletons){if(N.bones.length<=0)continue;const U=this._skinMap.get(N);if(void 0==U)continue;const V={},A=[];let n=-1;for(let t=0;t<N.bones.length;++t){const U=N.bones[t],A=U.getIndex()??t;-1!==A&&(V[A]=U,A>n&&(n=A))}for(let N=0;N<=n;++N){const n=V[N];A.push(n.getAbsoluteInverseBindMatrix());const q=n.getTransformNode();if(null!==q){const N=this._nodeMap.get(q);q&&null!==N&&void 0!==N?U.joints.push(N):t.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else t.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const q=this._nodesSkinMap.get(U);if(U.joints.length>0&&void 0!==q){const N=64*A.length,V=new Float32Array(N/4);A.forEach(((N,U)=>{V.set(N.m,16*U)}));const t=this._bufferManager.createBufferView(V);this._accessors.push(this._bufferManager.createAccessor(t,"MAT4",5126,A.length)),U.inverseBindMatrices=this._accessors.length-1,this._skins.push(U);for(const U of q)U.skin=this._skins.length-1}}}async _exportSceneAsync(){const N={nodes:[]};if(this._babylonScene.metadata){const U=this._options.metadataSelector(this._babylonScene.metadata);U&&(N.extras=U)}const U=new Array,V=new Array,A=new Array;for(const i of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&qN(i,this._babylonScene.useRightHandedSystem)?A.push(...i.getChildren()):this._babylonScene.useRightHandedSystem?U.push(i):V.push(i);this._listAvailableCameras(),this._listAvailableSkeletons();const t=new lN(!0,!1);N.nodes.push(...await this._exportNodesAsync(V,t));const n=new lN(!1,!1);N.nodes.push(...await this._exportNodesAsync(U,n));const q=new lN(!1,!0);N.nodes.push(...await this._exportNodesAsync(A,q)),N.nodes.length&&this._scenes.push(N),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&hN._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,t.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(N){let U=this._shouldExportNodeMap.get(N);return void 0===U&&(U=this._options.shouldExportNode(N),this._shouldExportNodeMap.set(N,U)),U}async _exportNodesAsync(N,U){const V=new Array;this._exportBuffers(N,U);for(const A of N)await this._exportNodeAsync(A,V,U);return V}_collectBuffers(N,U,V,A,t){if(this._shouldExportNode(N)&&N instanceof k.e&&N.Ji){const n=N.Ji.getVertexBuffers();if(n)for(const A in n){if(!T(A))continue;const q=n[A];t.setHasVertexColorAlpha(q,N.hasVertexAlpha);const i=q._buffer,z=U.get(i)||[];U.set(i,z),-1===z.indexOf(q)&&z.push(q);const S=V.get(q)||[];V.set(q,S),-1===S.indexOf(N)&&S.push(N)}const q=N.morphTargetManager;if(q)for(let U=0;U<q.numTargets;U++){const V=q.getTarget(U),t=A.get(V)||[];A.set(V,t),-1===t.indexOf(N)&&t.push(N)}}for(const n of N.getChildren())this._collectBuffers(n,U,V,A,t)}_exportBuffers(N,U){const V=new Map,A=new Map,t=new Map;for(const i of N)this._collectBuffers(i,V,A,t,U);const n=Array.from(V.keys());for(const i of n){const N=i.getData();if(!N)throw new Error("Buffer data is not available");const t=V.get(i);if(!t)continue;const n=t[0].byteStride;if(t.some((N=>N.byteStride!==n)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const q=VN(N).slice();for(const U of t){const N=A.get(U),{byteOffset:V,byteStride:t,componentCount:n,type:i,count:z,normalized:S,kind:p}=F(U,N);switch(p){case E.f.NormalKind:case E.f.TangentKind:(0,o.f)(q,V,t,n,i,z,S,(N=>{const U=Math.sqrt(N[0]*N[0]+N[1]*N[1]+N[2]*N[2]);if(U>0){const V=1/U;N[0]*=V,N[1]*=V,N[2]*=V}}));break;case E.f.ColorKind:{const U=N.filter((N=>N.material instanceof xN.dU||null==N.material)).length;if(0==U)break;if(U!=N.length){R.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}i==E.f.UNSIGNED_BYTE&&R.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const A=new J.rU,p=new J.Yi,k=this._babylonScene.getEngine().useExactSrgbConversions;(0,o.f)(q,V,t,n,i,z,S,(N=>{3===N.length?(A.BV(N,0),A.toLinearSpaceToRef(A,k),A.toArray(N,0)):(p.BV(N,0),p.toLinearSpaceToRef(p,k),p.toArray(N,0))}))}}}if(U.convertToRightHanded){for(const N of t){const U=A.get(N),{byteOffset:V,byteStride:t,componentCount:n,type:i,count:z,normalized:S,kind:p}=F(N,U);switch(p){case E.f.PositionKind:case E.f.NormalKind:case E.f.TangentKind:(0,o.f)(q,V,t,n,i,z,S,(N=>{N[0]=-N[0]}))}}U.convertedToRightHandedBuffers.set(i,q)}const z=this._bufferManager.createBufferView(q,n);U.setVertexBufferView(i,z);const S=new Map;for(const U of t){const N=A.get(U),{kind:V,totalVertices:t}=F(U,N);switch(V){case E.f.MatricesIndicesKind:case E.f.MatricesIndicesExtraKind:if(U.type==E.f.FLOAT){const N=U.getFloatData(t);null!==N&&S.set(U,N)}}}0!==S.size&&R.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const p=Array.from(S.keys());for(const V of p){const N=S.get(V);if(!N)continue;const A=N.some((N=>N>=256)),t=new(A?Uint16Array:Uint8Array)(N.length);for(let U=0;U<N.length;U++)t[U]=N[U];const n=this._bufferManager.createBufferView(t,4*(A?2:1));U.setRemappedBufferView(i,V,n)}}const q=Array.from(t.keys());for(const i of q){const N=t.get(i);if(!N)continue;const V=cN(i,N[0],this._bufferManager,this._bufferViews,this._accessors,U.convertToRightHanded);for(const A of N)U.bindMorphDataToMesh(A,V)}}async _exportNodeAsync(N,U,V){let A=this._nodeMap.get(N);if(void 0!==A)return void(U.includes(A)||U.push(A));const t=await this._createNodeAsync(N,V);if(t){A=this._nodes.length,this._nodes.push(t),this._nodeMap.set(N,A),V.pushExportedNode(N),U.push(A);const n={name:"runtime animations",channels:[],samplers:[]},q=[];this._babylonScene.animationGroups.length||(hN._CreateMorphTargetAnimationFromMorphTargetAnimations(N,n,q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,V.convertToRightHanded,this._options.shouldExportAnimation),N.animations.length&&hN._CreateNodeAnimationFromNodeAnimations(N,n,q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,V.convertToRightHanded,this._options.shouldExportAnimation)),n.channels.length&&n.samplers.length&&this._animations.push(n),q.forEach((N=>{N.channels.length&&N.samplers.length&&this._animations.push(N)}))}const n=t?[]:U;for(const q of N.getChildren())await this._exportNodeAsync(q,n,V);t&&n.length&&(t.children=n)}async _createNodeAsync(N,U){if(!this._shouldExportNode(N))return null;const V={};if(N.name&&(V.name=N.name),N.metadata){const U=this._options.metadataSelector(N.metadata);U&&(V.extras=U)}if(N instanceof p.b&&(this._setNodeTransformation(V,N,U.convertToRightHanded),N instanceof k.e)){const t=N instanceof B.b?N.sourceMesh:N;if(t.Ei&&t.Ei.length>0&&(V.mesh=await this._exportMeshAsync(t,U)),N.skeleton){const U=this._skinMap.get(N.skeleton);var A;if(void 0!==U)void 0===this._nodesSkinMap.get(U)&&this._nodesSkinMap.set(U,[]),null===(A=this._nodesSkinMap.get(U))||void 0===A||A.push(V)}}if(N instanceof D.d){const A=this._camerasMap.get(N);if(A){var t;void 0===this._nodesCameraMap.get(A)&&this._nodesCameraMap.set(A,[]),this._setCameraTransformation(V,N,U.convertToRightHanded);const q=N.parent;if(null!==q&&UN(N,q)){const N=this._nodeMap.get(q);if(void 0!==N){var n;const U=this._nodes[N];return NN(V,U),null===(n=this._nodesCameraMap.get(A))||void 0===n||n.push(U),null}}null===(t=this._nodesCameraMap.get(A))||void 0===t||t.push(V)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",V,N,this._nodeMap,U.convertToRightHanded)?V:(R.b.Warn(`Not exporting node ${N.name}`),null)}_exportIndices(N,U,V,A,t,q,i,z,S){let E=N;S.mode=f(q);const p=i!==n.d.CounterClockWiseSideOrientation,k=!z.wasAddedByNoopNode&&p,B=function(N){switch(N){case n.d.TriangleFillMode:case n.d.TriangleStripDrawMode:case n.d.TriangleFanDrawMode:return!0}return!1}(q)&&k;if(B){if(q===n.d.TriangleStripDrawMode||q===n.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");S.mode=f(q);const i=U?new Uint32Array(A):new Uint16Array(A);if(N)for(let U=0;U+2<A;U+=3)i[U]=N[V+U]+t,i[U+1]=N[V+U+2]+t,i[U+2]=N[V+U+1]+t;else for(let N=0;N+2<A;N+=3)i[N]=N,i[N+1]=N+2,i[N+2]=N+1;E=i}else if(N&&0!==t){const n=U?new Uint32Array(A):new Uint16Array(A);for(let U=0;U<A;U++)n[U]=N[V+U]+t;E=n}if(E){let n=z.getIndicesAccessor(N,V,A,t,B);if(void 0===n){const q=function(N,U,V,A){if(N instanceof Uint16Array||N instanceof Uint32Array)return N;if(N instanceof Int32Array)return new Uint32Array(N.buffer,N.byteOffset,N.length);const t=N.slice(U,U+V);return A?new Uint32Array(t):new Uint16Array(t)}(E,0,A,U),i=this._bufferManager.createBufferView(q),S=U?5125:5123;this._accessors.push(this._bufferManager.createAccessor(i,"SCALAR",S,A,0)),n=this._accessors.length-1,z.setIndicesAccessor(N,V,A,t,B,n)}S.indices=n}}_exportVertexBuffer(N,U,V,A,t,n){const q=N.getKind();if(!T(q))return;if(q.startsWith("uv")&&!this._options.exportUnusedUVs&&(!U||!this._materialNeedsUVsSet.has(U)))return;let i=t.getVertexAccessor(N,V,A);if(void 0===i){const U=t.convertedToRightHandedBuffers.get(N._buffer)||N._buffer.getData(),n=q===E.f.PositionKind?function(N,U,V,A){const{byteOffset:t,byteStride:n,type:q,normalized:i}=U,z=U.getSize(),S=new Array(z).fill(1/0),E=new Array(z).fill(-1/0);return(0,o.f)(N,t+V*n,n,z,q,A*z,i,(N=>{for(let U=0;U<z;U++)S[U]=Math.min(S[U],N[U]),E[U]=Math.max(E[U],N[U])})),{min:S,max:E}}(U,N,V,A):void 0,z=(q===E.f.MatricesIndicesKind||q===E.f.MatricesIndicesExtraKind)&&N.type===E.f.FLOAT,S=z?E.f.UNSIGNED_BYTE:N.type,p=z?void 0:N.normalized,k=z?t.getRemappedBufferView(N._buffer,N):t.getVertexBufferView(N._buffer),B=N.byteOffset+V*N.byteStride;this._accessors.push(this._bufferManager.createAccessor(k,function(N,U){if(N==E.f.ColorKind)return U?"VEC4":"VEC3";switch(N){case E.f.PositionKind:case E.f.NormalKind:return"VEC3";case E.f.TangentKind:case E.f.MatricesIndicesKind:case E.f.MatricesIndicesExtraKind:case E.f.MatricesWeightsKind:case E.f.MatricesWeightsExtraKind:return"VEC4";case E.f.UVKind:case E.f.UV2Kind:case E.f.UV3Kind:case E.f.UV4Kind:case E.f.UV5Kind:case E.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${N}`)}(q,t.hasVertexColorAlpha(N)),S,A,B,n,p)),i=this._accessors.length-1,t.setVertexAccessor(N,V,A,i)}n.attributes[function(N){switch(N){case E.f.PositionKind:return"POSITION";case E.f.NormalKind:return"NORMAL";case E.f.TangentKind:return"TANGENT";case E.f.ColorKind:return"COLOR_0";case E.f.UVKind:return"TEXCOORD_0";case E.f.UV2Kind:return"TEXCOORD_1";case E.f.UV3Kind:return"TEXCOORD_2";case E.f.UV4Kind:return"TEXCOORD_3";case E.f.UV5Kind:return"TEXCOORD_4";case E.f.UV6Kind:return"TEXCOORD_5";case E.f.MatricesIndicesKind:return"JOINTS_0";case E.f.MatricesIndicesExtraKind:return"JOINTS_1";case E.f.MatricesWeightsKind:return"WEIGHTS_0";case E.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${N}`)}(q)]=i}async _exportMaterialAsync(N,U,V,A){let t=this._materialMap.get(N);if(void 0===t){const A=U&&Object.keys(U).some((N=>N.startsWith("uv")));if((N=N instanceof BN.d?N.Wi[V.materialIndex]:N)instanceof CN.b)t=await this._materialExporter.exportPBRMaterialAsync(N,"image/png",A);else{if(!(N instanceof xN.dU))return void R.b.Warn(`Unsupported material '${N.name}' with type ${N.getClassName()}`);t=await this._materialExporter.exportStandardMaterialAsync(N,"image/png",A)}this._materialMap.set(N,t)}A.material=t}async _exportMeshAsync(N,U){var V;let A=U.getMesh(N);if(void 0!==A)return A;const t={primitives:[]};A=this._meshes.length,this._meshes.push(t),U.setMesh(N,A);const q=N.isUnIndexed?null:N.di(),i=null===(V=N.Ji)||void 0===V?void 0:V.getVertexBuffers(),z=U.getMorphTargetsFromMesh(N),S=N instanceof HN.d,E=N instanceof gN,p=N.Ei;if(i&&p&&p.length>0)for(const C of p){const V={attributes:{}},A=C.IN()||this._babylonScene.defaultMaterial;if(E){var k,B;const U={name:A.name},t=N,n=J.rU.White(),q=(null===(k=t.material)||void 0===k?void 0:k.alpha)??1,i=(null===(B=t.greasedLineMaterial)||void 0===B?void 0:B.color)??n;(!i.equalsWithEpsilon(n,G.d)||q<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...i.pi(),q]}),this._materials.push(U),V.material=this._materials.length-1}else if(S){const U={name:A.name},t=N;(!t.color.equalsWithEpsilon(J.rU.White(),G.d)||t.alpha<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...t.color.pi(),t.alpha]}),this._materials.push(U),V.material=this._materials.length-1}else await this._exportMaterialAsync(A,i,C,V);const p=S||E?n.d.LineListDrawMode:N.overrideRenderingFillMode??A.fillMode,x=A._getEffectiveOrientation(N);this._exportIndices(q,q?(0,o.c)(q,C.indexCount,C.indexStart,C.verticesStart):C.verticesCount>65535,q?C.indexStart:C.verticesStart,q?C.indexCount:C.verticesCount,-C.verticesStart,p,x,U,V);for(const N of Object.values(i))this._exportVertexBuffer(N,A,C.verticesStart,C.verticesCount,U,V);if(z){V.targets=[];for(const N of z)V.targets.push(N.attributes)}t.primitives.push(V),this._extensionsPostExportMeshPrimitive(V)}if(z){t.weights=[],t.extras||(t.extras={}),t.extras.targetNames=[];for(const N of z)t.weights.push(N.influence),t.extras.targetNames.push(N.name)}return A}}KN._ExtensionNames=new Array,KN._ExtensionFactories={};class jN{static async GLTFAsync(N,U,V){V&&V.exportWithoutWaitingForScene||await N.whenReadyAsync();const A=new KN(N,V),t=await A.generateGLTFAsync(U.replace(/\.[^/.]+$/,""));return A.dispose(),t}static async GLBAsync(N,U,V){V&&V.exportWithoutWaitingForScene||await N.whenReadyAsync();const A=new KN(N,V),t=await A.generateGLBAsync(U.replace(/\.[^/.]+$/,""));return A.dispose(),t}}V(12914);const FN="EXT_mesh_gpu_instancing";class PN{constructor(N){this.name=FN,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(N,U,V,t,n,q){return await new Promise((N=>{if(U&&V instanceof rN.b&&V.hasThinInstances&&this._exporter){this._wasUsed=!0;const N=A.CU.Zero(),t=A.Quaternion.Identity(),i=A.CU.One(),z=V.thinInstanceGetWorldMatrices(),S=A.TmpVectors.CU[2],E=A.TmpVectors.Quaternion[1],p=A.TmpVectors.CU[3];let k=!1,B=!1,C=!1;const x=new Float32Array(3*V.si),J=new Float32Array(4*V.si),d=new Float32Array(3*V.si);let r=0;for(const U of z)U.decompose(p,E,S),n&&(Z(S),b(E)),x.set(S.pi(),3*r),J.set(E.normalize().pi(),4*r),d.set(p.pi(),3*r),k=k||!S.equalsWithEpsilon(N),B=B||!E.equalsWithEpsilon(t),C=C||!p.equalsWithEpsilon(i),r++;const v={attributes:{}};k&&(v.attributes.TRANSLATION=this._buildAccessor(x,"VEC3",V.si,q)),B&&(v.attributes.ROTATION=this._buildAccessor(J,"VEC4",V.si,q)),C&&(v.attributes.SCALE=this._buildAccessor(d,"VEC3",V.si,q)),U.extensions=U.extensions||{},U.extensions[FN]=v}N(U)}))}_buildAccessor(N,U,V,A){const t=A.createBufferView(N),n=A.createAccessor(t,U,5126,V);return this._exporter._accessors.push(n),this._exporter._accessors.length-1}}KN.RegisterExtension(FN,(N=>new PN(N)));var TN=V(12916),fN=V(12923),ON=V(12928),ZN=V(12933);function bN(N){return N===ON.b.PositionKind?"POSITION":N===ON.b.NormalKind?"NORMAL":N===ON.b.ColorKind?"COLOR":N.startsWith(ON.b.UVKind)?"TEX_COORD":"GENERIC"}const yN={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class NU extends TN.e{static get DefaultAvailable(){return(0,TN.m)(NU.DefaultConfiguration)}static get Default(){return NU._Default??(NU._Default=new NU),NU._Default}static ResetDefault(N){NU._Default&&(N||NU._Default.dispose(),NU._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(N,U){return{module:await(U||DracoEncoderModule)({wasmBinary:N})}}_getWorkerContent(){return`${fN.j}(${fN.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:NU.DefaultConfiguration)}async _encodeAsync(N,U,V){const A=V?(0,ZN.d)(yN,V):yN;if(this._workerPoolPromise){const V=await this._workerPoolPromise;return await new Promise(((t,n)=>{V.push(((V,q)=>{const i=N=>{V.removeEventListener("error",i),V.removeEventListener("message",z),n(N),q()},z=N=>{"encodeMeshDone"===N.data.id&&(V.removeEventListener("error",i),V.removeEventListener("message",z),t(N.data.encodedMeshData),q())};V.addEventListener("error",i),V.addEventListener("message",z);const S=[];for(const U of N)S.push(U.data.buffer);U&&S.push(U.buffer),V.postMessage({id:"encodeMesh",attributes:N,indices:U,options:A},S)}))}))}if(this._modulePromise){const V=await this._modulePromise;return(0,fN.j)(V.module,N,U,A)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(N,U){if(0==N.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");N instanceof rN.b&&N.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===U||void 0===U?void 0:U.method)&&(R.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),U.method="MESH_SEQUENTIAL_ENCODING");const V=function(N){let U=N.di(void 0,!0);return!U||U instanceof Uint32Array||U instanceof Uint16Array||(U=((0,o.c)(U,U.length)?Uint32Array:Uint16Array).from(U)),U}(N),A=function(N,U){const V=[];for(const A of N.getVerticesDataKinds()){if(null!==U&&void 0!==U&&U.includes(A)){if(A===ON.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const t=N.getVertexBuffer(A),n=t.getSize(),q=(0,o.q)(t.getData(),n,t.type,t.byteOffset,t.byteStride,t.normalized,N.getTotalVertices(),!0);V.push({kind:A,dracoName:bN(A),size:n,data:q})}return V}(N,null===U||void 0===U?void 0:U.excludedAttributes);return await this._encodeAsync(A,V,U)}}NU.DefaultConfiguration={wasmUrl:`${t.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${t.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${t.Tools._DefaultCdnUrl}/draco_encoder.js`},NU._Default=null;const UU="KHR_draco_mesh_compression";class VU{get wasUsed(){return this._wasUsed}constructor(N){this.name=UU,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===N.options.meshCompressionMethod&&NU.DefaultAvailable}dispose(){}postExportMeshPrimitive(N,U,V){if(!this.enabled)return;if(4!==N.mode&&5!==N.mode)return void R.b.Warn("Cannot compress primitive with mode "+N.mode+".");const A=[],t=[];let n=null;if(void 0!==N.indices){const q=V[N.indices],i=U.getBufferView(q);n=U.getData(i).slice(),A.push(i),t.push(q)}const q=[];for(const[E,p]of Object.entries(N.attributes)){const N=V[p],n=U.getBufferView(N),z=P(N.type),S=(0,o.q)(U.getData(n),z,N.componentType,N.byteOffset||0,n.byteStride||(0,o.m)(N.componentType)*z,N.normalized||!1,N.count,!0);q.push({kind:E,dracoName:(i=E,"POSITION"===i?"POSITION":"NORMAL"===i?"NORMAL":i.startsWith("COLOR")?"COLOR":i.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:P(N.type),data:S}),A.push(n),t.push(N)}var i;const z={method:N.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},S=NU.Default._encodeAsync(q,n,z).then((V=>{if(!V)return void R.b.Error("Draco encoding failed for primitive.");const n={bufferView:-1,attributes:V.attributeIds},q=U.createBufferView(V.data);U.setBufferView(n,q);for(const N of A)this._bufferViewsUsed.add(N);for(const N of t)this._accessorsUsed.add(N);N.extensions||(N.extensions={}),N.extensions[UU]=n})).catch((N=>{R.b.Error("Draco encoding failed for primitive: "+N)}));this._encodePromises.push(S),this._wasUsed=!0}async preGenerateBinaryAsync(N){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((U=>{N.getPropertiesWithBufferView(U).every((N=>this._accessorsUsed.has(N)))&&N.removeBufferView(U)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}KN.RegisterExtension(UU,(N=>new VU(N)));var AU=V(12942);const tU="KHR_lights_punctual",nU={name:"",color:[1,1,1],Mi:1,range:Number.MAX_VALUE},qU={innerConeAngle:0,outerConeAngle:Math.PI/4},iU=A.CU.Backward();class zU{constructor(N){this.name=tU,this.enabled=!0,this.required=!1,this._exporter=N}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[tU]=this._lights}async postExportNodeAsync(N,U,V,t,n){return await new Promise((q=>{if(!(V instanceof vN.e))return void q(U);const i=V.getTypeID()==vN.e.LIGHTTYPEID_POINTLIGHT?"point":V.getTypeID()==vN.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":V.getTypeID()==vN.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!i||!(V instanceof AU.e))return R.b.Warn(`${N}: Light ${V.name} is not supported in ${tU}`),void q(U);if(V.falloffType!==vN.e.FALLOFF_GLTF&&R.b.Warn(`${N}: Light falloff for ${V.name} does not match the ${tU} specification!`),!V.position.equalsToFloats(0,0,0)){const N=A.TmpVectors.CU[0].A(V.position);n&&Z(N),U.translation=N.pi()}if("point"!==i){const N=V.direction.normalizeToRef(A.TmpVectors.CU[0]);n&&Z(N);const t=A.Quaternion.FromUnitVectorsToRef(iU,N,A.TmpVectors.Quaternion[0]);A.Quaternion.IsIdentity(t)||(U.rotation=t.pi())}const z={type:i,name:V.name,color:V.ai.pi(),Mi:V.Mi,range:V.range};if(AN(z,nU),"spot"===i){const N=V;z.spot={innerConeAngle:N.innerAngle/2,outerConeAngle:N.angle/2},AN(z.spot,qU)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(z);const S={en:this._lights.lights.length-1},E=V.parent;if(E&&UN(V,E)){const N=t.get(E);if(N){const V=this._exporter._nodes[N];return NN(U,V),V.extensions||(V.extensions={}),V.extensions[tU]=S,void q(null)}}U.extensions||(U.extensions={}),U.extensions[tU]=S,q(U)}))}}KN.RegisterExtension(tU,(N=>new zU(N)));var SU=V(12857);const EU="KHR_materials_anisotropy";class pU{constructor(N){this.name=EU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,U,V){const A=[];return V instanceof SU.d&&V.anisotropy.isEnabled&&!V.anisotropy.legacy?(V.anisotropy.texture&&A.push(V.anisotropy.texture),A):[]}postExportMaterialAsync(N,U,V){return new Promise((N=>{if(V instanceof SU.d){if(!V.anisotropy.isEnabled||V.anisotropy.legacy)return void N(U);this._wasUsed=!0,U.extensions=U.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(V.anisotropy.texture),t={anisotropyStrength:V.anisotropy.Mi,anisotropyRotation:V.anisotropy.angle,anisotropyTexture:A??void 0};null!==t.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(V),U.extensions[EU]=t}N(U)}))}}KN.RegisterExtension(EU,(N=>new pU(N)));const kU="KHR_materials_clearcoat";class BU{constructor(N){this.name=kU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,U,V){const A=[];return V instanceof SU.d&&V.clearCoat.isEnabled?(V.clearCoat.texture&&A.push(V.clearCoat.texture),!V.clearCoat.useRoughnessFromMainTexture&&V.clearCoat.textureRoughness&&A.push(V.clearCoat.textureRoughness),V.clearCoat.bumpTexture&&A.push(V.clearCoat.bumpTexture),A):[]}postExportMaterialAsync(N,U,V){return new Promise((N=>{if(V instanceof SU.d){if(!V.clearCoat.isEnabled)return void N(U);this._wasUsed=!0,U.extensions=U.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(V.clearCoat.texture);let n;n=V.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(V.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(V.clearCoat.textureRoughness),V.clearCoat.isTintEnabled&&t.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${V.name}`),V.clearCoat.remapF0OnInterfaceChange&&t.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${V.name}`);const q=this._exporter._materialExporter.getTextureInfo(V.clearCoat.bumpTexture),i={clearcoatFactor:V.clearCoat.Mi,clearcoatTexture:A??void 0,clearcoatRoughnessFactor:V.clearCoat.roughness,clearcoatRoughnessTexture:n??void 0,clearcoatNormalTexture:q??void 0};null===i.clearcoatTexture&&null===i.clearcoatRoughnessTexture&&null===i.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(V),U.extensions[kU]=i}N(U)}))}}KN.RegisterExtension(kU,(N=>new BU(N)));const CU="KHR_materials_diffuse_transmission";function xU(N,U){const V=U.subSurface;let A=null;return V.translucencyIntensityTexture?A=V.translucencyIntensityTexture:V.thicknessTexture&&V.useMaskFromThicknessTexture&&(A=V.thicknessTexture),A&&!V.useGltfStyleTextures?(R.b.Warn(`${N}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${U.name}`,1),null):A}class JU{constructor(N){this.name=CU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,U,V){const A=[];if(V instanceof CN.b&&this._isExtensionEnabled(V)){const U=xU(N,V);return U&&A.push(U),V.subSurface.translucencyColorTexture&&A.push(V.subSurface.translucencyColorTexture),A}return A}_isExtensionEnabled(N){if(N.unlit)return!1;const U=N.subSurface;return!!U.isTranslucencyEnabled&&(!N.unlit&&!U.useAlbedoToTintTranslucency&&U.useGltfStyleTextures&&1===U.volumeIndexOfRefraction&&0===U.minimumThickness&&0===U.maximumThickness)}postExportMaterialAsync(N,U,V){return new Promise((A=>{if(V instanceof CN.b&&this._isExtensionEnabled(V)){this._wasUsed=!0;const A=V.subSurface,t=xU(N,V),n=0==A.translucencyIntensity?void 0:A.translucencyIntensity,q=this._exporter._materialExporter.getTextureInfo(t)??void 0,i=!A.translucencyColor||A.translucencyColor.equalsFloats(1,1,1)?void 0:A.translucencyColor.pi(),z=this._exporter._materialExporter.getTextureInfo(A.translucencyColorTexture)??void 0,S={diffuseTransmissionFactor:n,diffuseTransmissionTexture:q,diffuseTransmissionColorFactor:i,diffuseTransmissionColorTexture:z};(q||z)&&this._exporter._materialNeedsUVsSet.add(V),U.extensions=U.extensions||{},U.extensions[CU]=S}A(U)}))}}KN.RegisterExtension(CU,(N=>new JU(N)));const dU="KHR_materials_dispersion";class rU{constructor(){this.name=dU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(N){if(N.unlit)return!1;const U=N.subSurface;return!(!U.isRefractionEnabled&&!U.isDispersionEnabled)}postExportMaterialAsync(N,U,V){return new Promise((N=>{if(V instanceof CN.b&&this._isExtensionEnabled(V)){this._wasUsed=!0;const N={dispersion:V.subSurface.dispersion};U.extensions=U.extensions||{},U.extensions[dU]=N}N(U)}))}}KN.RegisterExtension(dU,(()=>new rU));const vU="KHR_materials_emissive_strength";class hU{constructor(){this.name=vU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(N,U,V){return await new Promise((N=>{if(!(V instanceof CN.b))return N(U);const A=V.emissiveColor.pi(),t=Math.max(...A);if(t>1){this._wasUsed=!0,U.extensions||(U.extensions={});const N={emissiveStrength:t},A=V.emissiveColor.scale(1/N.emissiveStrength);U.emissiveFactor=A.pi(),U.extensions[vU]=N}return N(U)}))}}KN.RegisterExtension(vU,(N=>new hU));const cU="KHR_materials_ior";class HU{constructor(){this.name=cU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(N){return!N.unlit&&(void 0!=N.indexOfRefraction&&1.5!=N.indexOfRefraction)}postExportMaterialAsync(N,U,V){return new Promise((N=>{if(V instanceof CN.b&&this._isExtensionEnabled(V)){this._wasUsed=!0;const N={ior:V.indexOfRefraction};U.extensions=U.extensions||{},U.extensions[cU]=N}N(U)}))}}KN.RegisterExtension(cU,(N=>new HU));const YU="KHR_materials_iridescence";class WU{constructor(N){this.name=YU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,U,V){const A=[];return V instanceof SU.d&&V.iridescence.isEnabled?(V.iridescence.texture&&A.push(V.iridescence.texture),V.iridescence.thicknessTexture&&V.iridescence.thicknessTexture!==V.iridescence.texture&&A.push(V.iridescence.thicknessTexture),A):[]}postExportMaterialAsync(N,U,V){return new Promise((N=>{if(V instanceof SU.d){if(!V.iridescence.isEnabled)return void N(U);this._wasUsed=!0,U.extensions=U.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(V.iridescence.texture),t=this._exporter._materialExporter.getTextureInfo(V.iridescence.thicknessTexture),n={iridescenceFactor:V.iridescence.Mi,iridescenceIor:V.iridescence.indexOfRefraction,iridescenceThicknessMinimum:V.iridescence.minimumThickness,iridescenceThicknessMaximum:V.iridescence.maximumThickness,iridescenceTexture:A??void 0,iridescenceThicknessTexture:t??void 0};null===n.iridescenceTexture&&null===n.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(V),U.extensions[YU]=n}N(U)}))}}KN.RegisterExtension(YU,(N=>new WU(N)));const sU="KHR_materials_sheen";class MU{constructor(N){this.name=sU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,U,V){return V instanceof CN.b&&V.sheen.isEnabled&&V.sheen.texture?[V.sheen.texture]:[]}async postExportMaterialAsync(N,U,V){return await new Promise((N=>{if(V instanceof CN.b){if(!V.sheen.isEnabled)return void N(U);this._wasUsed=!0,null==U.extensions&&(U.extensions={});const A={sheenColorFactor:V.sheen.color.pi(),sheenRoughnessFactor:V.sheen.roughness??0};null===A.sheenColorTexture&&null===A.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(V),V.sheen.texture&&(A.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(V.sheen.texture)??void 0),V.sheen.textureRoughness&&!V.sheen.useRoughnessFromMainTexture?A.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(V.sheen.textureRoughness)??void 0:V.sheen.texture&&V.sheen.useRoughnessFromMainTexture&&(A.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(V.sheen.texture)??void 0),U.extensions[sU]=A}N(U)}))}}KN.RegisterExtension(sU,(N=>new MU(N)));const aU="KHR_materials_specular";class mV{constructor(N){this.name=aU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,U,V){const A=[];return V instanceof CN.b&&this._isExtensionEnabled(V)?(V.metallicReflectanceTexture&&A.push(V.metallicReflectanceTexture),V.reflectanceTexture&&A.push(V.reflectanceTexture),A):A}_isExtensionEnabled(N){return!N.unlit&&(void 0!=N.metallicF0Factor&&1!=N.metallicF0Factor||void 0!=N.metallicReflectanceColor&&!N.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(N))}_hasTexturesExtension(N){return null!=N.metallicReflectanceTexture||null!=N.reflectanceTexture}postExportMaterialAsync(N,U,V){return new Promise((N=>{if(V instanceof CN.b&&this._isExtensionEnabled(V)){this._wasUsed=!0,U.extensions=U.extensions||{};const N=this._exporter._materialExporter.getTextureInfo(V.metallicReflectanceTexture)??void 0,A=this._exporter._materialExporter.getTextureInfo(V.reflectanceTexture)??void 0,t={specularFactor:1==V.metallicF0Factor?void 0:V.metallicF0Factor,specularTexture:N,specularColorFactor:V.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:V.metallicReflectanceColor.pi(),specularColorTexture:A};this._hasTexturesExtension(V)&&this._exporter._materialNeedsUVsSet.add(V),U.extensions[aU]=t}N(U)}))}}KN.RegisterExtension(aU,(N=>new mV(N)));const wU="KHR_materials_transmission";class XU{constructor(N){this.name=wU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,U,V){const A=[];return V instanceof CN.b&&this._isExtensionEnabled(V)?(V.subSurface.thicknessTexture&&A.push(V.subSurface.thicknessTexture),A):A}_isExtensionEnabled(N){if(N.unlit)return!1;const U=N.subSurface;return U.isRefractionEnabled&&void 0!=U.refractionIntensity&&0!=U.refractionIntensity||this._hasTexturesExtension(N)}_hasTexturesExtension(N){return null!=N.subSurface.refractionIntensityTexture}async postExportMaterialAsync(N,U,V){if(V instanceof CN.b&&this._isExtensionEnabled(V)){this._wasUsed=!0;const A=V.subSurface,t={transmissionFactor:0===A.refractionIntensity?void 0:A.refractionIntensity};if(this._hasTexturesExtension(V)&&this._exporter._materialNeedsUVsSet.add(V),A.refractionIntensityTexture)if(A.useGltfStyleTextures){const N=await this._exporter._materialExporter.exportTextureAsync(A.refractionIntensityTexture,"image/png");N&&(t.transmissionTexture=N)}else R.b.Warn(`${N}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);U.extensions||(U.extensions={}),U.extensions[wU]=t}return U}}KN.RegisterExtension(wU,(N=>new XU(N)));const eU="KHR_materials_unlit";class QU{constructor(){this.name=eU,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(N,U,V){return new Promise((N=>{let A=!1;V instanceof CN.b?A=V.unlit:V instanceof xN.dU&&(A=V.disableLighting),A&&(this._wasUsed=!0,null==U.extensions&&(U.extensions={}),U.extensions[eU]={}),N(U)}))}}KN.RegisterExtension(eU,(()=>new QU));const uU="KHR_materials_volume";class LU{constructor(N){this.name=uU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,U,V){const A=[];return V instanceof CN.b&&this._isExtensionEnabled(V)?(V.subSurface.thicknessTexture&&A.push(V.subSurface.thicknessTexture),A):A}_isExtensionEnabled(N){if(N.unlit)return!1;const U=N.subSurface;return!(!U.isRefractionEnabled&&!U.isTranslucencyEnabled)&&(void 0!=U.maximumThickness&&0!=U.maximumThickness||void 0!=U.tintColorAtDistance&&U.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=U.tintColor&&U.tintColor!=J.rU.White()||this._hasTexturesExtension(N))}_hasTexturesExtension(N){return null!=N.subSurface.thicknessTexture}postExportMaterialAsync(N,U,V){return new Promise((N=>{if(V instanceof CN.b&&this._isExtensionEnabled(V)){this._wasUsed=!0;const N=V.subSurface,A={thicknessFactor:0==N.maximumThickness?void 0:N.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(N.thicknessTexture)??void 0,attenuationDistance:N.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:N.tintColorAtDistance,attenuationColor:N.tintColor.equalsFloats(1,1,1)?void 0:N.tintColor.pi()};this._hasTexturesExtension(V)&&this._exporter._materialNeedsUVsSet.add(V),U.extensions=U.extensions||{},U.extensions[uU]=A}N(U)}))}}KN.RegisterExtension(uU,(N=>new LU(N)));const IU="EXT_materials_diffuse_roughness";class oU{constructor(N){this.name=IU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=N}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(N,U,V){const A=[];return V instanceof SU.d&&V._baseDiffuseRoughness?(V._baseDiffuseRoughnessTexture&&A.push(V._baseDiffuseRoughnessTexture),A):[]}postExportMaterialAsync(N,U,V){return new Promise((N=>{if(V instanceof SU.d){if(!V._baseDiffuseRoughness)return void N(U);this._wasUsed=!0,U.extensions=U.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(V._baseDiffuseRoughnessTexture),t={diffuseRoughnessFactor:V._baseDiffuseRoughness,diffuseRoughnessTexture:A??void 0};null!==t.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(V),U.extensions[IU]=t}N(U)}))}}KN.RegisterExtension(IU,(N=>new oU(N)));const RU="KHR_texture_transform";class DU{constructor(){this.name=RU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(N,U,V){if(V.YN()||t.Tools.Warn(`${N}: /*@__KEY__*/"scene" is not defined for Babylon texture ${V.name}!`),(0!==V.uAng||0!==V.vAng)&&(t.Tools.Warn(`${N}: Texture ${V.name} with rotation in the u or v axis is not supported in glTF.`),0!==V.uRotationCenter||0!==V.vRotationCenter))return;const A={};let n=!1;if(0===V.uOffset&&0===V.vOffset||(A.offset=[V.uOffset,V.vOffset],n=!0),1===V.uScale&&1===V.vScale||(A.scale=[V.uScale,V.vScale],n=!0),0!==V.wAng){if(0!==V.uRotationCenter||0!==V.vRotationCenter){if(V.homogeneousRotationInUVTransform&&V.uScale!==V.vScale)return void t.Tools.Warn(`${N}: Texture ${V.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${RU}.`);t.Tools.Warn(`${N}: Texture ${V.name} with non-origin rotation center will be exported using an adjusted offset with ${RU}.`),A.offset=function(N){const{uOffset:U,vOffset:V,uRotationCenter:A,vRotationCenter:t,uScale:n,vScale:q,wAng:i}=N,z=Math.cos(i),S=Math.sin(i),E=A*n,p=t*q;return[U+(E*(1-z)+p*S),V+(p*(1-z)-E*S)]}(V)}A.rotation=-V.wAng,n=!0}0!==V.coordinatesIndex&&(A.texCoord=V.coordinatesIndex,n=!0),n&&(this._wasUsed=!0,U.extensions||(U.extensions={}),U.extensions[RU]=A)}}KN.RegisterExtension(RU,(()=>new DU));class GU{static CreateSTL(N){let U=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",t=arguments.length>3&&void 0!==arguments[3]&&arguments[3],n=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],q=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],z=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const S=function(N,U,V){const t=[3*N[V],3*N[V+1],3*N[V+2]],n=[new A.CU(U[t[0]],U[t[0]+2],U[t[0]+1]),new A.CU(U[t[1]],U[t[1]+2],U[t[1]+1]),new A.CU(U[t[2]],U[t[2]+2],U[t[2]+1])],q=n[0].xU(n[1]),i=n[2].xU(n[1]);return{v:n,n:A.CU.Cross(i,q).normalize()}},p=function(N,U,V,A){return U=k(N,U,V.x,A),U=k(N,U,V.y,A),k(N,U,V.z,A)},k=function(N,U,V,A){return N.setFloat32(U,V,A),U+4},C=function(N){if(i){let U=N;N instanceof B.b&&(U=N.sourceMesh);const V=U.getVerticesData(E.f.PositionKind,!0,!0);if(!V)return[];const t=A.CU.Zero();let n;for(n=0;n<V.length;n+=3)A.CU.TransformCoordinatesFromFloatsToRef(V[n],V[n+1],V[n+2],N.xi(!0),t).toArray(V,n);return V}return N.getVerticesData(E.f.PositionKind)||[]};i&&(q=!0);let x="",J=0,d=0;if(t){for(let V=0;V<N.length;V++){const U=N[V].di();J+=U?U.length/3:0}const U=new ArrayBuffer(84+50*J);x=new DataView(U),d+=80,x.setUint32(d,J,n),d+=4}else z||(x="solid stlmesh\r\n");for(let A=0;A<N.length;A++){const U=N[A];!t&&z&&(x+="solid "+U.name+"\r\n"),!q&&U instanceof rN.b&&U.bakeCurrentTransformIntoVertices();const V=C(U),i=U.di()||[];for(let N=0;N<i.length;N+=3){const U=S(i,V,N);t?(d=p(x,d,U.n,n),d=p(x,d,U.v[0],n),d=p(x,d,U.v[1],n),d=p(x,d,U.v[2],n),d+=2):(x+="\tfacet normal "+U.n.x+" "+U.n.y+" "+U.n.z+"\r\n",x+="\t\touter loop\r\n",x+="\t\t\tvertex "+U.v[0].x+" "+U.v[0].y+" "+U.v[0].z+"\r\n",x+="\t\t\tvertex "+U.v[1].x+" "+U.v[1].y+" "+U.v[1].z+"\r\n",x+="\t\t\tvertex "+U.v[2].x+" "+U.v[2].y+" "+U.v[2].z+"\r\n",x+="\t\tendloop\r\n",x+="\tendfacet\r\n")}!t&&z&&(x+="endsolid "+name+"\r\n")}if(t||z||(x+="endsolid stlmesh"),U){const N=document.createElement("a"),U=new Blob([x],{type:"application/octet-stream"});N.href=window.URL.createObjectURL(U),N.download=V+".stl",N.click()}return x}}function gU(N,U){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const A=[];for(let t=0;t<N.length/V;t++){const n=N[t*V],q=N[t*V+1],i=N[t*V+2];A.push(`(${n.toPrecision(U.precision)}, ${q.toPrecision(U.precision)}, ${i.toPrecision(U.precision)})`)}return A.join(", ")}function lU(N,U){const V=[];for(let A=0;A<N.length/2;A++){const t=N[2*A],n=N[2*A+1];V.push(`(${t.toPrecision(U.precision)}, ${(1-n).toPrecision(U.precision)})`)}return V.join(", ")}function KU(N,U){const V=N.getVerticesData(E.f.PositionKind),A=N.getVerticesData(E.f.NormalKind);if(V&&A)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(N){var U;const V=null!==(U=N.di())&&void 0!==U&&U.length?N.getTotalIndices():N.getTotalVertices();return Array(V/3).fill(3).join(", ")}(N)}]\n\t\tint[] faceVertexIndices = [${function(N){const U=N.di(),V=[];if(null!==U)for(let A=0;A<U.length;A++)V.push(U[A]);else{const U=N.getTotalVertices();for(let N=0;N<U;N++)V.push(N)}return V.join(", ")}(N)}]\n\t\tnormal3f[] normals = [${gU(A,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${gU(V,U)}]\n        ${function(N,U){let V="";for(let t=0;t<4;t++){const A=t>0?t:"",n=N.getVerticesData(E.f.UVKind+(A?A+1:""));n&&(V+=`\n\t\ttexCoord2f[] primvars:st${A} = [${lU(n,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const A=N.getVerticesData(E.f.ColorKind);return A&&(V+=`\n\tcolor3f[] primvars:displayColor = [${gU(A,U,A.length/N.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),V}(N,U)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function jU(N,U){return`\n        def "Geometry"\n        {\n        ${KU(N,U)}\n        }\n        `}function FU(N){let U='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return U+=N,fflate.strToU8(U)}function PU(N){const U=N.m;return`( ${TU(U,0)}, ${TU(U,4)}, ${TU(U,8)}, ${TU(U,12)} )`}function TU(N,U){return`(${N[U+0]}, ${N[U+1]}, ${N[U+2]}, ${N[U+3]})`}function fU(N){const U="Object_"+N.uniqueId,V=function(N){const U=N.getWorldMatrix().clone(),V=N.YN().useRightHandedSystem;if(!V){let A=N.parent;for(;A;){if(qN(A,V)){U.multiplyToRef(A.getWorldMatrix().invert(),U);break}A=A.parent}}return U.determinant()<0&&t.Tools.Warn(`Exporting mesh ${N.name} with negative scale. Result may look incorrect in destination engine.`),U}(N),A=PU(V);return`def Xform "${U}" (\n\tprepend references = @./geometries/Geometry_${N.Ji.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${A}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${N.material.uniqueId}>\n}\n\n`}function OU(N){switch(N){case Y.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case Y.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case Y.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function ZU(N){return`(${N.x}, ${N.y})`}function bU(N){return`(${N.r}, ${N.g}, ${N.b})`}function yU(N,U,V,t,n,q){const i=N.getInternalTexture().uniqueId+"_"+N.invertY;n[i]=N;const z=N.coordinatesIndex>0?"st"+N.coordinatesIndex:"st",S=new A.Vector2(N.uScale,N.vScale),E=new A.Vector2(N.uOffset,N.vOffset),p=N.wAng,k=Math.sin(p),B=Math.cos(p);return E.y=1-E.y-S.y,E.x+=k*S.x,E.y+=(1-B)*S.y,`\n    def Shader "PrimvarReader_${V}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${z}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${V}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${U.uniqueId}/PrimvarReader_${V}.outputs:result>\n        float inputs:rotation = ${(p*(180/Math.PI)).toFixed(q.precision)}\n        float2 inputs:scale = ${ZU(S)}\n        float2 inputs:translation = ${ZU(E)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${N.uniqueId}_${V}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${i}.png@\n        float2 inputs:st.connect = </Materials/Material_${U.uniqueId}/Transform2d_${V}.outputs:result>\n        ${t?"float4 inputs:scale = "+function(N){return`(${N.r}, ${N.g}, ${N.b}, 1.0)`}(t):""}\n        token inputs:sourceColorSpace = "${N.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${OU(N.wrapU)}"\n        token inputs:wrapT = "${OU(N.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${U.needAlphaBlending()?"float outputs:a":""}\n    }`}function NV(N,U,V){const A="\t\t\t",t=[],n=[],{diffuseMap:q,ai:i,alphaCutOff:z,emissiveMap:S,emissive:E,normalMap:p,roughnessMap:k,roughnessChannel:B,roughness:C,metalnessMap:x,metalnessChannel:d,metalness:r,aoMap:v,aoMapChannel:h,aoMapIntensity:c,alphaMap:H,ior:Y,clearCoatEnabled:W,clearCoat:s,clearCoatMap:M,clearCoatRoughness:a,clearCoatRoughnessMap:mN}=function(N){const U={diffuseMap:null,ai:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return N instanceof xN.dU?{...U,diffuseMap:N.diffuseTexture,ai:N.diffuseColor,alphaCutOff:N.alphaCutOff,emissiveMap:N.emissiveTexture,emissive:N.emissiveColor,roughness:1,alphaMap:N.opacityTexture}:N instanceof SU.d?{...U,diffuseMap:N._albedoTexture,ai:N._albedoColor,alphaCutOff:N._alphaCutOff,emissiveMap:N._emissiveTexture,emissive:N._emissiveColor,normalMap:N._bumpTexture,roughnessMap:N._metallicTexture,roughnessChannel:N._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:N._roughness??1,metalnessMap:N._metallicTexture,metalnessChannel:N._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:N._metallic??0,aoMap:N._ambientTexture,aoMapChannel:N._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:N._ambientTextureStrength,alphaMap:N._opacityTexture,ior:N.subSurface.indexOfRefraction,clearCoatEnabled:N.clearCoat.isEnabled,clearCoat:N.clearCoat.Mi,clearCoatMap:N.clearCoat.texture,clearCoatRoughness:N.clearCoat.roughness,clearCoatRoughnessMap:N.clearCoat.useRoughnessFromMainTexture?N.clearCoat.texture:N.clearCoat.textureRoughness}:U}(N);return null!==q?(t.push(`${A}color3f inputs:diffuseColor.connect = </Materials/Material_${N.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:rgb>`),N.needAlphaBlending()?t.push(`${A}float inputs:opacity.connect = </Materials/Material_${N.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:a>`):N.needAlphaTesting()&&(t.push(`${A}float inputs:opacity.connect = </Materials/Material_${N.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:a>`),t.push(`${A}float inputs:opacityThreshold = ${z}`)),n.push(yU(q,N,"diffuse",i,U,V))):t.push(`${A}color3f inputs:diffuseColor = ${bU(i||J.rU.White())}`),null!==S?(t.push(`${A}color3f inputs:emissiveColor.connect = </Materials/Material_${N.uniqueId}/Texture_${S.uniqueId}_emissive.outputs:rgb>`),n.push(yU(S,N,"emissive",E,U,V))):E&&E.toLuminance()>0&&t.push(`${A}color3f inputs:emissiveColor = ${bU(E)}`),null!==p&&(t.push(`${A}normal3f inputs:normal.connect = </Materials/Material_${N.uniqueId}/Texture_${p.uniqueId}_normal.outputs:rgb>`),n.push(yU(p,N,"normal",null,U,V))),null!==v&&(t.push(`${A}float inputs:occlusion.connect = </Materials/Material_${N.uniqueId}/Texture_${v.uniqueId}_occlusion.outputs:${h}>`),n.push(yU(v,N,"occlusion",new J.rU(c,c,c),U,V))),null!==k?(t.push(`${A}float inputs:roughness.connect = </Materials/Material_${N.uniqueId}/Texture_${k.uniqueId}_roughness.outputs:${B}>`),n.push(yU(k,N,"roughness",new J.rU(C,C,C),U,V))):t.push(`${A}float inputs:roughness = ${C}`),null!==x?(t.push(`${A}float inputs:metallic.connect = </Materials/Material_${N.uniqueId}/Texture_${x.uniqueId}_metallic.outputs:${d}>`),n.push(yU(x,N,"metallic",new J.rU(r,r,r),U,V))):t.push(`${A}float inputs:metallic = ${r}`),null!==H?(t.push(`${A}float inputs:opacity.connect = </Materials/Material_${N.uniqueId}/Texture_${H.uniqueId}_opacity.outputs:r>`),t.push(`${A}float inputs:opacityThreshold = 0.0001`),n.push(yU(H,N,"opacity",null,U,V))):t.push(`${A}float inputs:opacity = ${N.alpha}`),W&&(null!==M?(t.push(`${A}float inputs:clearcoat.connect = </Materials/Material_${N.uniqueId}/Texture_${M.uniqueId}_clearcoat.outputs:r>`),n.push(yU(M,N,"clearcoat",new J.rU(s,s,s),U,V))):t.push(`${A}float inputs:clearcoat = ${s}`),null!==mN?(t.push(`${A}float inputs:clearcoatRoughness.connect = </Materials/Material_${N.uniqueId}/Texture_${mN.uniqueId}_clearcoatRoughness.outputs:g>`),n.push(yU(mN,N,"clearcoatRoughness",new J.rU(a,a,a),U,V))):t.push(`${A}float inputs:clearcoatRoughness = ${a}`)),t.push(`${A}float inputs:ior = ${Y}`),`\n\tdef Material "Material_${N.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${t.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${N.uniqueId}/PreviewSurface.outputs:surface>\n\n${n.join("\n")}\n\n\t}\n`}async function UV(N,U,V){const n={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...U};"undefined"===typeof fflate&&await t.Tools.LoadScriptAsync(n.fflateUrl);const q={};q[n.modelFileName]=null;let i='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';i+=function(N){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===N.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${N.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${N.planeAnchoringAlignment}"`:""}\n            `}(n);const z={};for(const A of N.meshes){if(0===A.getTotalVertices())continue;const N=A,U=N.Ji,S=N.material;if(!S||!U||V&&!V(N))continue;if(-1!==["dU","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(S.getClassName())){const V="geometries/Geometry_"+U.uniqueId+".usda";if(!(V in q)){const N=jU(U,n);q[V]=FU(N)}S.uniqueId in z||(z[S.uniqueId]=S),i+=fU(N)}else t.Tools.Warn("USDZExportAsync does not support this material type: "+S.getClassName())}N.activeCamera&&n.exportCamera&&(i+=function(N,U){const V="Camera_"+N.uniqueId,t=PU(A.Matrix.RotationY(Math.PI).multiply(N.getWorldMatrix()));if(N.mode===Y.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${V}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${t}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${N.Bi.toPrecision(U.precision)}, ${N.maxZ.toPrecision(U.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(N.orthoLeft||1)+Math.abs(N.orthoRight||1))).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(N.orthoTop||1)+Math.abs(N.orthoBottom||1))).toPrecision(U.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const A=N.getEngine().getAspectRatio(N),n=U.cameraSensorWidth||35;return`def Camera "${V}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${t}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${N.Bi.toPrecision(U.precision)}, ${N.maxZ.toPrecision(U.precision)})\n\t\t\tfloat focalLength = ${(n/(2*Math.tan(.5*N.fov))).toPrecision(U.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(n*A).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(n/A).toPrecision(U.precision)}            \n\t\t}\n\t\n\t`}}(N.activeCamera,n)),i+="\n            }\n        }\n    }";const S={};i+=function(N,U,V){const A=[];for(const t in N){const n=N[t];A.push(NV(n,U,V))}return`\n    def "Materials"\n{\n${A.join("")}\n}\n\n`}(z,S,n),q[n.modelFileName]=fflate.strToU8(i);for(const A in S){const N=S[A],U=N.getSize(),V=await N.readPixels();if(!V)throw new Error("Texture data is not available");const t=await W.DumpTools.DumpDataAsync(U.width,U.height,V,"image/png",void 0,!1,!0);q[`textures/Texture_${A}.png`]=new Uint8Array(t).slice()}let E=0;for(const A in q){const N=q[A];if(!N)continue;E+=34+A.length;const U=63&E;if(4!==U){const V=new Uint8Array(64-U);q[A]=[N,{extra:{12345:V}}]}E=N.length}return fflate.zipSync(q,{level:0})}}}]);