"use strict";(self.nyfa010khv=self.nyfa010khv||[]).push([[26],{12537:(L,r,p)=>{p.r(r),p.d(r,{EXT_materials_diffuse_roughness:()=>Tr,EXT_mesh_gpu_instancing:()=>RL,GLTF2Export:()=>oL,GLTFData:()=>C,KHR_draco_mesh_compression:()=>pr,KHR_lights_punctual:()=>Gr,KHR_materials_anisotropy:()=>Er,KHR_materials_clearcoat:()=>wr,KHR_materials_diffuse_transmission:()=>cr,KHR_materials_dispersion:()=>Or,KHR_materials_emissive_strength:()=>Ur,KHR_materials_ior:()=>Br,KHR_materials_iridescence:()=>Qr,KHR_materials_sheen:()=>vr,KHR_materials_specular:()=>Ar,KHR_materials_transmission:()=>ar,KHR_materials_unlit:()=>Zr,KHR_materials_volume:()=>Dr,KHR_texture_transform:()=>Mr,OBJExport:()=>j,STLExport:()=>fr,USDZExportAsync:()=>rp,_ConvertToGLTFPBRMetallicRoughness:()=>q,_SolveMetallic:()=>a,__IGLTFExporterExtension:()=>z});var J=p(12136),i=p(11957),n=p(12446);class j{static OBJ(L,r,p,j){const z=[];let G=1,C=1;r&&(p||(p="mat"),z.push("mtllib "+p+".mtl"));for(let t=0;t<L.length;t++){const p=L[t],E=p.name||`mesh${t}}`;z.push(`o ${E}`);let x=null;if(j){const L=p.cz(!0);x=new J.Matrix,L.invertToRef(x),p.bakeTransformIntoVertices(L)}if(r){const L=p.material;L&&z.push("usemtl "+L.id)}const w=p.Pz;if(!w){i.Tools.Warn("No geometry is present on the mesh");continue}const g=w.getVerticesData("position"),b=w.getVerticesData("normal"),c=w.getVerticesData("uv"),P=w.Oz();let O=0,h=0;if(!g||!P){i.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const U=L[0].FL().useRightHandedSystem?1:-1;for(let L=0;L<g.length;L+=3)z.push("v "+g[L]*U+" "+g[L+1]+" "+g[L+2]),O++;if(null!=b)for(let L=0;L<b.length;L+=3)z.push("vn "+b[L]*U+" "+b[L+1]+" "+b[L+2]);if(null!=c)for(let L=0;L<c.length;L+=2)z.push("vt "+c[L]+" "+c[L+1]),h++;const W=["","",""],B=(p.material||p.FL().defaultMaterial)._getEffectiveOrientation(p),[F,Q]=B===n.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let L=0;L<P.length;L+=3){const r=[String(P[L]+G),String(P[L+F]+G),String(P[L+Q]+G)],p=[String(P[L]+C),String(P[L+F]+C),String(P[L+Q]+C)],J=r,i=null!=c?p:W,n=null!=b?r:W;z.push("f "+J[0]+"/"+i[0]+"/"+n[0]+" "+J[1]+"/"+i[1]+"/"+n[1]+" "+J[2]+"/"+i[2]+"/"+n[2])}j&&x&&p.bakeTransformIntoVertices(x),G+=O,C+=h}return z.join("\n")}static MTL(L){const r=[],p=L.material;r.push("newmtl mat1"),r.push("  Ns "+p.specularPower.toFixed(4)),r.push("  Ni 1.5000"),r.push("  d "+p.alpha.toFixed(4)),r.push("  Tr 0.0000"),r.push("  Tf 1.0000 1.0000 1.0000"),r.push("  illum 2"),r.push("  Ka "+p.ambientColor.r.toFixed(4)+" "+p.ambientColor.g.toFixed(4)+" "+p.ambientColor.b.toFixed(4)),r.push("  Kd "+p.diffuseColor.r.toFixed(4)+" "+p.diffuseColor.g.toFixed(4)+" "+p.diffuseColor.b.toFixed(4)),r.push("  Ks "+p.specularColor.r.toFixed(4)+" "+p.specularColor.g.toFixed(4)+" "+p.specularColor.b.toFixed(4)),r.push("  Ke "+p.emissiveColor.r.toFixed(4)+" "+p.emissiveColor.g.toFixed(4)+" "+p.emissiveColor.b.toFixed(4));p.ambientTexture&&r.push("  map_Ka "+p.ambientTexture.name),p.diffuseTexture&&r.push("  map_Kd "+p.diffuseTexture.name),p.specularTexture&&r.push("  map_Ks "+p.specularTexture.name),p.bumpTexture&&r.push("  map_bump -imfchan z "+p.bumpTexture.name),p.opacityTexture&&r.push("  map_d "+p.opacityTexture.name);return r.join("\n")}}var z=0,G=p(12014);class C{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const L in this.files){const r=this.files[L],p=new Blob([r],{type:(0,G.i)(L)});i.Tools.Download(p,L)}}}var t=p(12208),E=p(12541),x=p(12547),w=p(12567),g=p(12253),b=p(12009),c=p(12170),P=p(12154);const O=P.HighestCommonFactor,h={...P,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:O};var U=p(12343),W=p(12111),B=p(12600),F=p(12605),Q=p(12336);const e=1e-6,v=new c.Wr(.04,.04,.04),y=1024,A=c.Wr.White(),u=c.Wr.Black();function a(L,r,p){if(r<v.r)return 0;const J=v.r,i=L*p/(1-v.r)+r-2*v.r,n=i*i-4*J*(v.r-r);return h.Clamp((-i+Math.sqrt(n))/(2*J),0,1)}function q(L){const r=L.diffuseColor.toLinearSpace(L.FL().getEngine().useExactSrgbConversions).scale(.5),p=L.alpha,i=function(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new J.Vector2(0,1),p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new J.Vector2(0,.1),i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new J.Vector2(0,.1),n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new J.Vector2(1300,.1);return function(L,r,p,J,i){return(1-L)*(1-L)*(1-L)*r+3*(1-L)*(1-L)*L*p+3*(1-L)*L*L*J+L*L*L*i}(Math.pow(L/n.x,.333333),r.y,p.y,i.y,n.y)}(h.Clamp(L.specularPower,0,y));return{baseColorFactor:[r.r,r.g,r.b,p],metallicFactor:0,roughnessFactor:i}}function Z(L,r){r.needAlphaBlending()?L.alphaMode="BLEND":r.needAlphaTesting()&&(L.alphaMode="MASK",L.alphaCutoff=r.alphaCutOff)}function X(L,r,p){const J=new Uint8Array(L*r*4);for(let i=0;i<J.length;i+=4)J[i]=J[i+1]=J[i+2]=J[i+3]=255;return B.e.CreateRGBATexture(J,L,r,p)}function D(L){if(L instanceof Uint8Array){const r=L.length,p=new Float32Array(L.length);for(let J=0;J<r;++J)p[J]=L[J]/255;return p}if(L instanceof Float32Array)return L;throw new Error("Unsupported pixel format!")}class l{constructor(L){this._exporter=L,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(L){return L?this._textureMap.get(L)??null:null}async exportStandardMaterialAsync(L,r,p){const J=q(L),n={name:L.name};if(null==L.hz||L.hz||(L.twoSidedLighting||i.Tools.Warn(L.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),n.doubleSided=!0),p){const p=[],i=L.diffuseTexture;i&&p.push(this.exportTextureAsync(i,r).then((L=>{L&&(J.baseColorTexture=L)})));const j=L.bumpTexture;j&&p.push(this.exportTextureAsync(j,r).then((L=>{L&&(n.normalTexture=L,1!==j.level&&(n.normalTexture.scale=j.level))})));const z=L.emissiveTexture;z&&(n.emissiveFactor=[1,1,1],p.push(this.exportTextureAsync(z,r).then((L=>{L&&(n.emissiveTexture=L)}))));const G=L.ambientTexture;G&&p.push(this.exportTextureAsync(G,r).then((L=>{if(L){const r={index:L.index};n.occlusionTexture=r}}))),p.length>0&&(this._exporter._materialNeedsUVsSet.add(L),await Promise.all(p))}(L.alpha<1||L.opacityTexture)&&(L.alphaMode===F.b.ALPHA_COMBINE?n.alphaMode="BLEND":i.Tools.Warn(L.name+": glTF 2.0 does not support alpha mode: "+L.alphaMode.toString())),L.emissiveColor&&!L.emissiveColor.equalsWithEpsilon(u,e)&&(n.emissiveFactor=L.emissiveColor.mz()),n.pbrMetallicRoughness=J,Z(n,L),await this._finishMaterialAsync(n,L,r);const j=this._exporter._materials;return j.push(n),j.length-1}async _finishMaterialAsync(L,r,p){const J=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",L,r),i=[];for(const n of J)i.push(this.exportTextureAsync(n,p));await Promise.all(i),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",L,r)}async _getImageDataAsync(L,r,J,i){const n=F.b.TEXTURETYPE_UNSIGNED_BYTE,j=this._exporter._babylonScene,z=j.getEngine(),G=z.createRawTexture(L,r,J,F.b.TEXTUREFORMAT_RGBA,!1,!0,W.c.NEAREST_SAMPLINGMODE,null,n);z.isWebGPU?await p.e(51).then(p.bind(p,14632)):await p.e(52).then(p.bind(p,14636)),await U.l.ApplyPostProcess("pass",G,j,n,F.b.TEXTURE_NEAREST_SAMPLINGMODE,F.b.TEXTUREFORMAT_RGBA);const C=await z._readTexturePixels(G,r,J);return await Q.DumpTools.DumpDataAsync(r,J,C,i,void 0,!0,!0)}_resizeTexturesToSameDimensions(L,r,p){const J=L?L.getSize():{width:0,height:0},i=r?r.getSize():{width:0,height:0};let n,j;return J.width<i.width?(n=L&&L instanceof W.c?U.l.CreateResizedCopy(L,i.width,i.height,!0):X(i.width,i.height,p),j=r):J.width>i.width?(j=r&&r instanceof W.c?U.l.CreateResizedCopy(r,J.width,J.height,!0):X(J.width,J.height,p),n=L):(n=L,j=r),{texture1:n,texture2:j}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(L,r,p,J){const i=new Array;if(!L&&!r)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const n=L?L.FL():r?r.FL():null;if(n){var j;const z=this._resizeTexturesToSameDimensions(L,r,n),G=null===(j=z.texture1)||void 0===j?void 0:j.getSize();let C,t;const E=G.width,x=G.height,w=await z.texture1.readPixels(),g=await z.texture2.readPixels();if(!w)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(C=D(w),!g)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");t=D(g);const b=t.byteLength,P=new Uint8Array(b),O=new Uint8Array(b),h=4,U=u;let W=0,B=0;for(let L=0;L<x;++L)for(let r=0;r<E;++r){const J=(E*L+r)*h,i={diffuseColor:new c.Wr(C[J],C[J+1],C[J+2]).toLinearSpace(n.getEngine().useExactSrgbConversions).multiply(p.diffuseColor),specularColor:new c.Wr(t[J],t[J+1],t[J+2]).toLinearSpace(n.getEngine().useExactSrgbConversions).multiply(p.specularColor),glossiness:t[J+3]*p.glossiness},j=this._convertSpecularGlossinessToMetallicRoughness(i);U.r=Math.max(U.r,j.baseColor.r),U.g=Math.max(U.g,j.baseColor.g),U.b=Math.max(U.b,j.baseColor.b),W=Math.max(W,j.metallic),B=Math.max(B,j.roughness),O[J]=255*j.baseColor.r,O[J+1]=255*j.baseColor.g,O[J+2]=255*j.baseColor.b,O[J+3]=z.texture1.pz?255*C[J+3]:255,P[J]=0,P[J+1]=255*j.roughness,P[J+2]=255*j.metallic,P[J+3]=255}const F={baseColor:U,metallic:W,roughness:B};let Q=!1,v=!1;for(let L=0;L<x;++L)for(let r=0;r<E;++r){const p=(E*L+r)*h;O[p]/=F.baseColor.r>e?F.baseColor.r:1,O[p+1]/=F.baseColor.g>e?F.baseColor.g:1,O[p+2]/=F.baseColor.b>e?F.baseColor.b:1;const J=c.Wr.FromInts(O[p],O[p+1],O[p+2]).toGammaSpace(n.getEngine().useExactSrgbConversions);O[p]=255*J.r,O[p+1]=255*J.g,O[p+2]=255*J.b,J.equalsWithEpsilon(A,e)||(v=!0),P[p+1]/=F.roughness>e?F.roughness:1,P[p+2]/=F.metallic>e?F.metallic:1;c.Wr.FromInts(255,P[p+1],P[p+2]).equalsWithEpsilon(A,e)||(Q=!0)}return Q&&i.push(this._getImageDataAsync(P,E,x,J).then((L=>{F.metallicRoughnessTextureData=L}))),v&&i.push(this._getImageDataAsync(O,E,x,J).then((L=>{F.baseColorTextureData=L}))),await Promise.all(i).then((()=>F))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(L){const r=this._getPerceivedBrightness(L.diffuseColor),p=this._getPerceivedBrightness(L.specularColor),J=1-this._getMaxComponent(L.specularColor),i=a(r,p,J),n=L.diffuseColor.scale(J/(1-v.r)/Math.max(1-i)),j=L.specularColor.Pr(v.scale(1-i)).scale(1/Math.max(i));let z=c.Wr.Lerp(n,j,i*i);z=z.clampToRef(0,1,z);return{baseColor:z,metallic:i,roughness:1-L.glossiness}}_getPerceivedBrightness(L){return L?Math.sqrt(.299*L.r*L.r+.587*L.g*L.g+.114*L.b*L.b):0}_getMaxComponent(L){return L?Math.max(L.r,Math.max(L.g,L.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(L,r,p,J){const i=[],n={baseColor:L._albedoColor,metallic:L._metallic,roughness:L._roughness};if(J){L._albedoTexture&&i.push(this.exportTextureAsync(L._albedoTexture,r).then((L=>{L&&(p.baseColorTexture=L)})));const J=L._metallicTexture;J&&i.push(this.exportTextureAsync(J,r).then((L=>{L&&(p.metallicRoughnessTexture=L)})))}return i.length>0&&(this._exporter._materialNeedsUVsSet.add(L),await Promise.all(i)),n}_getTextureSampler(L){const r={};if(!L||!(L instanceof W.c))return r;const p=this._getGLTFTextureWrapMode(L.wrapU);10497!==p&&(r.wrapS=p);const J=this._getGLTFTextureWrapMode(L.wrapV);switch(10497!==J&&(r.wrapT=J),L.samplingMode){case W.c.LINEAR_LINEAR:r.magFilter=9729,r.minFilter=9729;break;case W.c.LINEAR_NEAREST:r.magFilter=9729,r.minFilter=9728;break;case W.c.NEAREST_LINEAR:r.magFilter=9728,r.minFilter=9729;break;case W.c.NEAREST_LINEAR_MIPLINEAR:r.magFilter=9728,r.minFilter=9987;break;case W.c.NEAREST_NEAREST:r.magFilter=9728,r.minFilter=9728;break;case W.c.NEAREST_LINEAR_MIPNEAREST:r.magFilter=9728,r.minFilter=9985;break;case W.c.LINEAR_NEAREST_MIPNEAREST:r.magFilter=9729,r.minFilter=9984;break;case W.c.LINEAR_NEAREST_MIPLINEAR:r.magFilter=9729,r.minFilter=9986;break;case W.c.NEAREST_NEAREST_MIPLINEAR:r.magFilter=9728,r.minFilter=9986;break;case W.c.LINEAR_LINEAR_MIPLINEAR:r.magFilter=9729,r.minFilter=9987;break;case W.c.LINEAR_LINEAR_MIPNEAREST:r.magFilter=9729,r.minFilter=9985;break;case W.c.NEAREST_NEAREST_MIPNEAREST:r.magFilter=9728,r.minFilter=9984}return r}_getGLTFTextureWrapMode(L){switch(L){case W.c.WRAP_ADDRESSMODE:return 10497;case W.c.CLAMP_ADDRESSMODE:return 33071;case W.c.MIRROR_ADDRESSMODE:return 33648;default:return i.Tools.Error(`Unsupported Texture Wrap Mode ${L}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(L,r,p,J){const i={diffuseColor:L._albedoColor,specularColor:L._reflectivityColor,glossiness:L._microSurface},n=L._albedoTexture,j=L._reflectivityTexture,z=L._useMicroSurfaceFromReflectivityMapAlpha;if(j&&!z)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((n||j)&&J){this._exporter._materialNeedsUVsSet.add(L);const J=this._exportTextureSampler(n||j),z=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(n,j,i,r),G=this._exporter._textures;if(z.baseColorTextureData){const L=this._exportImage(`baseColor${G.length}`,r,z.baseColorTextureData);p.baseColorTexture=this._exportTextureInfo(L,J,null===n||void 0===n?void 0:n.coordinatesIndex)}if(z.metallicRoughnessTextureData){const L=this._exportImage(`metallicRoughness${G.length}`,r,z.metallicRoughnessTextureData);p.metallicRoughnessTexture=this._exportTextureInfo(L,J,null===j||void 0===j?void 0:j.coordinatesIndex)}return z}return this._convertSpecularGlossinessToMetallicRoughness(i)}async exportPBRMaterialAsync(L,r,p){const J={},i={name:L.name},n=L.isMetallicWorkflow();if(n){const r=L._albedoColor,p=L.alpha;r&&(J.baseColorFactor=[r.r,r.g,r.b,p])}const j=n?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(L,r,J,p):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(L,r,J,p);await this._setMetallicRoughnessPbrMaterialAsync(j,L,i,J,r,p),await this._finishMaterialAsync(i,L,r);const z=this._exporter._materials;return z.push(i),z.length-1}async _setMetallicRoughnessPbrMaterialAsync(L,r,p,J,n,j){if(Z(p,r),L.baseColor.equalsWithEpsilon(A,e)&&h.WithinEpsilon(r.alpha,1,e)||(J.baseColorFactor=[L.baseColor.r,L.baseColor.g,L.baseColor.b,r.alpha]),null!=L.metallic&&1!==L.metallic&&(J.metallicFactor=L.metallic),null!=L.roughness&&1!==L.roughness&&(J.roughnessFactor=L.roughness),null==r.hz||r.hz||(r._twoSidedLighting||i.Tools.Warn(r.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),p.doubleSided=!0),j){const L=[],J=r._bumpTexture;J&&L.push(this.exportTextureAsync(J,n).then((L=>{L&&(p.normalTexture=L,1!==J.level&&(p.normalTexture.scale=J.level))})));const i=r._ambientTexture;i&&L.push(this.exportTextureAsync(i,n).then((L=>{if(L){const J={index:L.index,texCoord:L.texCoord,extensions:L.extensions};p.occlusionTexture=J;const i=r._ambientTextureStrength;i&&(J.strength=i)}})));const j=r._emissiveTexture;j&&L.push(this.exportTextureAsync(j,n).then((L=>{L&&(p.emissiveTexture=L)}))),L.length>0&&(this._exporter._materialNeedsUVsSet.add(r),await Promise.all(L))}const z=r._emissiveColor;z.equalsWithEpsilon(u,e)||(p.emissiveFactor=z.mz()),p.pbrMetallicRoughness=J}_getPixelsFromTextureAsync(L){return function(L){switch(L){case F.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case F.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case F.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case F.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case F.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case F.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case F.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case F.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case F.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case F.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case F.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case F.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case F.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case F.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case F.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case F.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case F.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case F.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case F.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case F.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case F.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(L.textureFormat)?(0,U.i)(L,L._texture.width,L._texture.height):(L.textureType,F.b.TEXTURETYPE_UNSIGNED_BYTE,L.readPixels())}async exportTextureAsync(L,r){const p=this._exporter._extensionsPreExportTextureAsync("exporter",L,r);return p?await p.then((async p=>p?await this._exportTextureInfoAsync(p,r):await this._exportTextureInfoAsync(L,r))):await this._exportTextureInfoAsync(L,r)}async _exportTextureInfoAsync(L,r){let p=this._textureMap.get(L);if(!p){const J=await this._getPixelsFromTextureAsync(L);if(!J)return null;const n=this._exportTextureSampler(L),j=L.mimeType;if(j)switch(j){case"image/jpeg":case"image/png":case"image/webp":r=j;break;default:i.Tools.Warn(`Unsupported media type: ${j}. Exporting texture as PNG.`)}const z=this._internalTextureToImage,G=L.getInternalTexture().uniqueId;z[G]||(z[G]={});let C=z[G][r];if(void 0===C){const p=L.getSize();C=(async()=>{const i=await this._getImageDataAsync(J,p.width,p.height,r);return this._exportImage(L.name,r,i)})(),z[G][r]=C}p=this._exportTextureInfo(await C,n,L.coordinatesIndex),this._textureMap.set(L,p),this._exporter._extensionsPostExportTextures("exporter",p,L)}return p}_exportImage(L,r,p){const J=this._exporter._images;let n;if(this._exporter._shouldUseGlb){n={name:L,mimeType:r,bufferView:void 0};const J=this._exporter._bufferManager.createBufferView(new Uint8Array(p));this._exporter._bufferManager.setBufferView(n,J)}else{const j=L.replace(/\.\/|\/|\.\\|\\/g,"_"),z=function(L){switch(L){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(r);let G=j+z;J.some((L=>L.uri===G))&&(G=`${j}_${i.Tools.RandomId()}${z}`),n={name:L,uri:G},this._exporter._imageData[G]={data:p,mimeType:r}}return J.push(n),J.length-1}_exportTextureInfo(L,r,p){const J=this._exporter._textures;let i=J.findIndex((p=>p.sampler==r&&p.source===L));-1===i&&(i=J.length,J.push({source:L,sampler:r}));const n={index:i};return p&&(n.texCoord=p),n}_exportTextureSampler(L){const r=this._getTextureSampler(L),p=this._exporter._samplers,J=p.findIndex((L=>L.minFilter===r.minFilter&&L.magFilter===r.magFilter&&L.wrapS===r.wrapS&&L.wrapT===r.wrapT));return-1!==J?J:(p.push(r),p.length-1)}}var T=p(12215),Y=p(11975),M=p(12609),f=p(12140);const d=J.cr.Zero(),s=J.Quaternion.Identity(),H=J.cr.One(),o=new J.cr(-1,1,1);function k(L,r){const{byteOffset:p,byteStride:J,type:i,normalized:n}=L,j=L.getSize(),z=r.reduce(((L,r)=>r.getTotalVertices()>L?r.getTotalVertices():L),-Number.MAX_VALUE);return{byteOffset:p,byteStride:J,componentCount:j,type:i,count:z*j,normalized:n,totalVertices:z,kind:L.getKind()}}function R(L){switch(L){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function I(L){switch(L){case t.e.PositionKind:case t.e.NormalKind:case t.e.TangentKind:case t.e.ColorKind:case t.e.MatricesIndicesKind:case t.e.MatricesIndicesExtraKind:case t.e.MatricesWeightsKind:case t.e.MatricesWeightsExtraKind:case t.e.UVKind:case t.e.UV2Kind:case t.e.UV3Kind:case t.e.UV4Kind:case t.e.UV5Kind:case t.e.UV6Kind:return!0}return!1}function N(L){switch(L){case n.d.TriangleFillMode:return 4;case n.d.TriangleStripDrawMode:return 5;case n.d.TriangleFanDrawMode:return 6;case n.d.PointListDrawMode:case n.d.PointFillMode:return 0;case n.d.LineLoopDrawMode:return 2;case n.d.LineListDrawMode:return 1;case n.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${L}`)}function K(L){const r=Math.sqrt(L.x*L.x+L.y*L.y+L.z*L.z);r>0&&(L.x/=r,L.y/=r,L.z/=r)}function mL(L){return L.x*=-1,L}function V(L){if(L.x*L.x+L.y*L.y>.5){const r=Math.abs(L.x),p=Math.abs(L.y);if(r>p){const p=Math.sign(L.x);L.x=r,L.y*=-p,L.z*=-p,L.w*=p}else{const r=Math.sign(L.y);L.x*=-r,L.y=p,L.z*=r,L.w*=-r}}else{const r=Math.abs(L.z),p=Math.abs(L.w);if(r>p){const p=Math.sign(L.z);L.x*=-p,L.y*=p,L.z=r,L.w*=-p}else{const r=Math.sign(L.w);L.x*=r,L.y*=-r,L.z*=-r,L.w=p}}return L}function S(L){L.Uz(-L.z,L.w,L.x,-L.y)}function LL(L,r){const p=J.cr.FromArrayToRef(r.translation||[0,0,0],0,J.TmpVectors.cr[0]),i=J.Quaternion.FromArrayToRef(r.rotation||[0,0,0,1],0,J.TmpVectors.Quaternion[0]),n=J.Matrix.ComposeToRef(H,i,p,J.TmpVectors.Matrix[0]),j=J.cr.FromArrayToRef(L.translation||[0,0,0],0,J.TmpVectors.cr[2]),z=J.Quaternion.FromArrayToRef(L.rotation||[0,0,0,1],0,J.TmpVectors.Quaternion[1]),G=J.Matrix.ComposeToRef(H,z,j,J.TmpVectors.Matrix[1]);n.multiplyToRef(G,G),G.decompose(void 0,i,p),p.equalsWithEpsilon(d,f.d)?delete r.translation:r.translation=p.mz(),i.equalsWithEpsilon(s,f.d)?delete r.rotation:r.rotation=i.mz(),r.scale&&delete r.scale}function rL(L,r){if(!(r instanceof E.e))return!1;if(!(1===r.getChildren().length&&0===L.getChildren().length&&L.parent===r))return!1;const p=L.FL(),J=L instanceof M.e&&!p.useRightHandedSystem?o:H;return!!r.Wz.equalsWithEpsilon(J,f.d)||(Y.d.Warn(`Cannot collapse node ${L.name} into parent node ${r.name} with modified scaling.`),!1)}function pL(L){if(L instanceof Array){const r=new Float32Array(L);return new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}return ArrayBuffer.isView(L)?new Uint8Array(L.buffer,L.byteOffset,L.byteLength):new Uint8Array(L)}function JL(L,r){for(const[p,J]of Object.entries(L)){const i=r[p];(Array.isArray(J)&&Array.isArray(i)&&iL(J,i)||J===i)&&delete L[p]}return L}function iL(L,r){return L.length===r.length&&L.every(((L,p)=>L===r[p]))}const nL=J.Matrix.Compose(new J.cr(-1,1,1),J.Quaternion.Identity(),J.cr.Zero());function jL(L,r){if(!(L instanceof E.e))return!1;if(r){if(!L.getWorldMatrix().equalsWithEpsilon(J.Matrix.IdentityReadOnly,f.d))return!1}else{if(!L.getWorldMatrix().multiplyToRef(nL,J.TmpVectors.Matrix[0]).equalsWithEpsilon(J.Matrix.IdentityReadOnly,f.d))return!1}return!(L instanceof x.c&&L.Pz)}const zL=new Map([[Int8Array,(L,r,p)=>L.setInt8(r,p)],[Uint8Array,(L,r,p)=>L.setUint8(r,p)],[Uint8ClampedArray,(L,r,p)=>L.setUint8(r,p)],[Int16Array,(L,r,p)=>L.setInt16(r,p,!0)],[Uint16Array,(L,r,p)=>L.setUint16(r,p,!0)],[Int32Array,(L,r,p)=>L.setInt32(r,p,!0)],[Uint32Array,(L,r,p)=>L.setUint32(r,p,!0)],[Float32Array,(L,r,p)=>L.setFloat32(r,p,!0)],[Float64Array,(L,r,p)=>L.setFloat64(r,p,!0)]]);class GL{writeTypedArray(L){this._checkGrowBuffer(L.byteLength);const r=zL.get(L.constructor);for(let p=0;p<L.length;p++)r(this._dataView,this._byteOffset,L[p]),this._byteOffset+=L.BYTES_PER_ELEMENT}constructor(L){this._data=new Uint8Array(L),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(L){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,L),this._byteOffset++}writeInt8(L){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,L),this._byteOffset++}writeInt16(L){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,L,!0),this._byteOffset+=2}writeUInt16(L){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,L,!0),this._byteOffset+=2}writeInt32(L){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,L,!0),this._byteOffset+=4}writeUInt32(L){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,L,!0),this._byteOffset+=4}writeFloat32(L){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,L,!0),this._byteOffset+=4}writeFloat64(L){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,L,!0),this._byteOffset+=8}_checkGrowBuffer(L){const r=this.byteOffset+L;if(r>this._data.byteLength){const L=new Uint8Array(2*r);L.set(this._data),this._data=L,this._dataView=new DataView(this._data.buffer)}}}function CL(L){return L%4===0?4:L%2===0?2:1}class tL{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(L){let r=0;this._bufferViewToData.forEach((L=>{r+=L.byteLength}));const p=new GL(r),J=Array.from(this._bufferViewToData.keys()).sort(((L,r)=>CL(r.byteLength)-CL(L.byteLength)));for(const i of J){i.byteOffset=p.byteOffset,L.push(i);const r=L.length-1,J=this.getPropertiesWithBufferView(i);for(const L of J)L.bufferView=r;p.writeTypedArray(this._bufferViewToData.get(i)),this._bufferViewToData.delete(i)}return p.getOutputData()}createBufferView(L,r){const p={buffer:0,byteOffset:void 0,byteLength:L.byteLength,byteStride:r};return this._bufferViewToData.set(p,L),p}createAccessor(L,r,p,J,i,n,j){this._verifyBufferView(L);const z={bufferView:void 0,componentType:p,count:J,type:r,min:null===n||void 0===n?void 0:n.min,max:null===n||void 0===n?void 0:n.max,normalized:j,byteOffset:i};return this.setBufferView(z,L),this._accessorToBufferView.set(z,L),z}setBufferView(L,r){this._verifyBufferView(r);this.getPropertiesWithBufferView(r).push(L)}removeBufferView(L){const r=this.getPropertiesWithBufferView(L);for(const p of r)void 0!==p.bufferView&&delete p.bufferView;this._bufferViewToData.delete(L),this._bufferViewToProperties.delete(L),this._accessorToBufferView.forEach(((r,p)=>{r===L&&(void 0!==p.byteOffset&&delete p.byteOffset,this._accessorToBufferView.delete(p))}))}getBufferView(L){const r=this._accessorToBufferView.get(L);return this._verifyBufferView(r),r}getPropertiesWithBufferView(L){return this._verifyBufferView(L),this._bufferViewToProperties.set(L,this._bufferViewToProperties.get(L)??[]),this._bufferViewToProperties.get(L)}getData(L){return this._verifyBufferView(L),this._bufferViewToData.get(L)}_verifyBufferView(L){if(void 0===L||!this._bufferViewToData.has(L))throw new Error(`BufferView ${L} not found in BufferManager.`)}}var EL,xL=p(12579),wL=p(12598),gL=p(12617),bL=p(12506),cL=p(12642),PL=p(12647),OL=p(12575),hL=p(12654);!function(L){L[L.INTANGENT=0]="INTANGENT",L[L.OUTTANGENT=1]="OUTTANGENT"}(EL||(EL={}));class UL{static _IsTransformable(L){return L&&(L instanceof E.e||L instanceof xL.b||L instanceof hL.e)}static _CreateNodeAnimation(L,r,p,J,n){if(this._IsTransformable(L)){const j=[],z=[],G=r.getKeys(),C=UL._CalculateMinMaxKeyFrames(G),t=UL._DeduceInterpolation(G,p,J),E=t.interpolationType,x=t.shouldBakeAnimation;if(x?UL._CreateBakedAnimation(L,r,p,C.min,C.max,r.framePerSecond,n,j,z,C,J):"LINEAR"===E||"STEP"===E?UL._CreateLinearOrStepAnimation(L,r,p,j,z,J):"CUBICSPLINE"===E?UL._CreateCubicSplineAnimation(L,r,p,j,z,J):UL._CreateBakedAnimation(L,r,p,C.min,C.max,r.framePerSecond,n,j,z,C,J),j.length&&z.length){return{inputs:j,outputs:z,samplerInterpolation:E,inputsMin:x?C.min:i.Tools.FloatRound(C.min/r.framePerSecond),inputsMax:x?C.max:i.Tools.FloatRound(C.max/r.framePerSecond)}}}return null}static _DeduceAnimationInfo(L){let r=null,p="VEC3",J=!1;const n=L.targetProperty.split(".");switch(n[0]){case"Wz":r="scale";break;case"position":r="translation";break;case"rotation":p="VEC4",r="rotation";break;case"rotationQuaternion":p="VEC4",J=!0,r="rotation";break;case"influence":p="SCALAR",r="weights";break;default:i.Tools.Error(`Unsupported animatable property ${n[0]}`)}return r?{animationChannelTargetPath:r,dataAccessorType:p,useQuaternion:J}:(i.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(L,r,p,J,i,n,j,z,G,C,t){let E;if(UL._IsTransformable(L)&&L.animations)for(const x of L.animations){if(t&&!t(x))continue;const i=UL._DeduceAnimationInfo(x);i&&(E={name:x.name,samplers:[],channels:[]},UL._AddAnimation(`${x.name}`,x.hasRunningRuntimeAnimations?r:E,L,x,i.dataAccessorType,i.animationChannelTargetPath,J,n,j,z,i.useQuaternion,G,C),E.samplers.length&&E.channels.length&&p.push(E))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(L,r,p,J,i,n,j,z,G,C,t){let E;if(L instanceof OL.c){const i=L.morphTargetManager;if(i)for(let x=0;x<i.numTargets;++x){const w=i.getTarget(x);for(const g of w.animations){if(t&&!t(g))continue;const w=new cL.c(`${g.name}`,"influence",g.framePerSecond,g.dataType,g.loopMode,g.enableBlending),b=[],c=g.getKeys();for(let L=0;L<c.length;++L){const r=c[L];for(let L=0;L<i.numTargets;++L)L==x?b.push(r):b.push({frame:r.frame,value:0})}w.setKeys(b);const P=UL._DeduceAnimationInfo(w);P&&(E={name:w.name,samplers:[],channels:[]},UL._AddAnimation(g.name,g.hasRunningRuntimeAnimations?r:E,L,w,P.dataAccessorType,P.animationChannelTargetPath,J,n,j,z,P.useQuaternion,G,C,i.numTargets),E.samplers.length&&E.channels.length&&p.push(E))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(L,r,p,J,i,n,j,z,G){let C;if(L.animationGroups){const E=L.animationGroups;for(const x of E){const E=new Map,w=new Map,g=new Set,b=x.to-x.from;C={name:x.name,channels:[],samplers:[]};for(let r=0;r<x.targetedAnimations.length;++r){const b=x.targetedAnimations[r],c=b.target,P=b.animation;if(G&&!G(P))continue;const O=z.has(c);if(this._IsTransformable(c)||1===c.length&&this._IsTransformable(c[0])){const L=UL._DeduceAnimationInfo(b.animation);if(L){const r=this._IsTransformable(c)?c:this._IsTransformable(c[0])?c[0]:null;r&&UL._AddAnimation(`${P.name}`,C,r,P,L.dataAccessorType,L.animationChannelTargetPath,p,J,i,n,L.useQuaternion,j,O)}}else if(c instanceof PL.e||1===c.length&&c[0]instanceof PL.e){if(UL._DeduceAnimationInfo(b.animation)){const r=c instanceof PL.e?c:c[0];if(r){const p=L.morphTargetManagers.find((L=>{for(let p=0;p<L.numTargets;++p)if(L.getTarget(p)===r)return!0;return!1}));if(p){const J=L.meshes.find((L=>L.morphTargetManager===p));var t;if(J)E.has(J)||E.set(J,new Map),null===(t=E.get(J))||void 0===t||t.set(r,P),g.add(J),w.set(J,P)}}}}}g.forEach((L=>{const r=L.morphTargetManager;let z=null;const G=[],t=w.get(L).getKeys(),g=t.length;for(let p=0;p<g;++p)for(let J=0;J<r.numTargets;++J){const i=r.getTarget(J),n=E.get(L);if(n){const r=n.get(i);r?(z||(z=new cL.c(`${x.name}_${L.name}_MorphWeightAnimation`,"influence",r.framePerSecond,cL.c.ANIMATIONTYPE_FLOAT,r.loopMode,r.enableBlending)),G.push(r.getKeys()[p])):G.push({frame:x.from+b/g*p,value:i.influence,inTangent:t[0].inTangent?0:void 0,outTangent:t[0].outTangent?0:void 0})}}z.setKeys(G);const c=UL._DeduceAnimationInfo(z);c&&UL._AddAnimation(`${x.name}_${L.name}_MorphWeightAnimation`,C,L,z,c.dataAccessorType,c.animationChannelTargetPath,p,J,i,n,c.useQuaternion,j,!1,null===r||void 0===r?void 0:r.numTargets)})),C.channels.length&&C.samplers.length&&r.push(C)}}}static _AddAnimation(L,r,p,i,n,j,z,G,C,t,E,x,w,g){const b=UL._CreateNodeAnimation(p,i,j,E,x);let c,P,O,h,U,W;if(b){if(g){let L=0,r=0;const p=[];for(;b.inputs.length>0;)r=b.inputs.shift(),L%g==0&&p.push(r),L++;b.inputs=p}const L=z.get(p),i=new Float32Array(b.inputs);c=G.createBufferView(i),P=G.createAccessor(c,"SCALAR",5126,b.inputs.length,void 0,{min:[b.inputsMin],max:[b.inputsMax]}),t.push(P),O=t.length-1;const C=new J.Quaternion,E=new J.cr,x=new J.cr,B=p instanceof xL.b,F=R(n),Q=new Float32Array(b.outputs.length*F);b.outputs.forEach((function(L,r){let p=L;switch(j){case"translation":w&&(J.cr.FromArrayToRef(L,0,x),mL(x),x.toArray(p));break;case"rotation":4===L.length?J.Quaternion.FromArrayToRef(L,0,C):(p=new Array(4),J.cr.FromArrayToRef(L,0,E),J.Quaternion.FromEulerVectorToRef(E,C)),w&&(V(C),B&&S(C)),C.toArray(p)}Q.set(p,r*F)})),c=G.createBufferView(Q),P=G.createAccessor(c,n,5126,b.outputs.length),t.push(P),h=t.length-1,U={interpolation:b.samplerInterpolation,input:O,output:h},r.samplers.push(U),W={sampler:r.samplers.length-1,target:{node:L,path:j}},r.channels.push(W)}}static _CreateBakedAnimation(L,r,p,n,j,z,G,C,t,E,x){let w;const g=J.Quaternion.Identity();let b,c=null,P=null,O=null,h=null,U=null,W=null;E.min=i.Tools.FloatRound(n/z);const B=r.getKeys();for(let J=0,F=B.length;J<F;++J){if(W=null,O=B[J],J+1<F)if(h=B[J+1],O.value.equals&&O.value.equals(h.value)||O.value===h.value){if(0!==J)continue;W=O.frame}else W=h.frame;else{if(U=B[J-1],O.value.equals&&O.value.equals(U.value)||O.value===U.value)continue;W=j}if(W)for(let J=O.frame;J<=W;J+=G){if(b=i.Tools.FloatRound(J/z),b===c)continue;c=b,P=b;const n={key:0,repeatCount:0,loopMode:r.loopMode};w=r._interpolate(J,n),UL._SetInterpolatedValue(L,w,b,r,p,g,C,t,x)}}P&&(E.max=P)}static _ConvertFactorToVector3OrQuaternion(L,r,p,n,j){const z=UL._GetBasePositionRotationOrScale(r,n,j),G=p.targetProperty.split("."),C=G?G[1]:"",t=j?J.Quaternion.Br(z).normalize():J.cr.Br(z);switch(C){case"x":case"y":case"z":t[C]=L;break;case"w":t.w=L;break;default:i.Tools.Error(`glTFAnimation: Unsupported component name "${C}"!`)}return t}static _SetInterpolatedValue(L,r,p,i,n,j,z,G,C){let t;z.push(p),"weights"!==n?(i.dataType===cL.c.ANIMATIONTYPE_FLOAT&&(r=this._ConvertFactorToVector3OrQuaternion(r,L,i,n,C)),"rotation"===n?(C?j=r:(t=r,J.Quaternion.RotationYawPitchRollToRef(t.y,t.x,t.z,j)),G.push(j.mz())):(t=r,G.push(t.mz()))):G.push([r])}static _CreateLinearOrStepAnimation(L,r,p,J,i,n){for(const j of r.getKeys())J.push(j.frame/r.framePerSecond),UL._AddKeyframeValue(j,r,i,p,L,n)}static _CreateCubicSplineAnimation(L,r,p,J,i,n){r.getKeys().forEach((function(j){J.push(j.frame/r.framePerSecond),UL._AddSplineTangent(EL.INTANGENT,i,p,"CUBICSPLINE",j,n),UL._AddKeyframeValue(j,r,i,p,L,n),UL._AddSplineTangent(EL.OUTTANGENT,i,p,"CUBICSPLINE",j,n)}))}static _GetBasePositionRotationOrScale(L,r,p){let i;if("rotation"===r)if(p){i=(L.rotationQuaternion??J.Quaternion.Identity()).mz()}else{i=(L.rotation??J.cr.Zero()).mz()}else if("translation"===r){i=(L.position??J.cr.Zero()).mz()}else{i=(L.Wz??J.cr.One()).mz()}return i}static _AddKeyframeValue(L,r,p,n,j,z){let G;const C=r.dataType;if(C===cL.c.ANIMATIONTYPE_VECTOR3){let r=L.value.mz();if("rotation"===n){const L=J.cr.Br(r);r=J.Quaternion.RotationYawPitchRoll(L.y,L.x,L.z).mz()}p.push(r)}else if(C===cL.c.ANIMATIONTYPE_FLOAT){if("weights"===n)p.push([L.value]);else if(G=this._ConvertFactorToVector3OrQuaternion(L.value,j,r,n,z),G){if("rotation"===n){const L=z?G:J.Quaternion.RotationYawPitchRoll(G.y,G.x,G.z).normalize();p.push(L.mz())}p.push(G.mz())}}else C===cL.c.ANIMATIONTYPE_QUATERNION?p.push(L.value.normalize().mz()):i.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(L,r,p){let J,i,n=!1;if("rotation"===r&&!p)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let j=0,z=L.length;j<z;++j)if(i=L[j],i.inTangent||i.outTangent)if(J){if("CUBICSPLINE"!==J){J="LINEAR",n=!0;break}}else J="CUBICSPLINE";else if(J){if("CUBICSPLINE"===J||i.interpolation&&1===i.interpolation&&"STEP"!==J){J="LINEAR",n=!0;break}}else J=i.interpolation&&1===i.interpolation?"STEP":"LINEAR";return J||(J="LINEAR"),{interpolationType:J,shouldBakeAnimation:n}}static _AddSplineTangent(L,r,p,i,n,j){let z;const G=L===EL.INTANGENT?n.inTangent:n.outTangent;if("CUBICSPLINE"===i){if("rotation"===p)if(G)if(j)z=G.mz();else{const L=G;z=J.Quaternion.RotationYawPitchRoll(L.y,L.x,L.z).mz()}else z=[0,0,0,0];else z="weights"===p?G?[G]:[0]:G?G.mz():[0,0,0];r.push(z)}}static _CalculateMinMaxKeyFrames(L){let r=1/0,p=-1/0;return L.forEach((function(L){r=Math.min(r,L.frame),p=Math.max(p,L.frame)})),{min:r,max:p}}}function WL(L,r,p,n,j,z){const G={attributes:{},influence:L.influence,name:L.name},C=r.Pz;if(!C)return i.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),G;const E=z?-1:1,x=J.cr.Zero();let w=0,g=0;if(L.hasPositions){const n=L.getPositions(),z=C.getVerticesData(t.e.PositionKind);if(z){const L=new Float32Array(z.length),r=[1/0,1/0,1/0],i=[-1/0,-1/0,-1/0];g=z.length/3,w=0;for(let p=w;p<g;++p){const j=J.cr.Br(z,3*p);J.cr.Br(n,3*p).subtractToRef(j,x),x.x*=E,r[0]=Math.min(r[0],x.x),i[0]=Math.max(i[0],x.x),r[1]=Math.min(r[1],x.y),i[1]=Math.max(i[1],x.y),r[2]=Math.min(r[2],x.z),i[2]=Math.max(i[2],x.z),L[3*p]=x.x,L[3*p+1]=x.y,L[3*p+2]=x.z}const C=p.createBufferView(L,12),t=p.createAccessor(C,"VEC3",5126,n.length/3,0,{min:r,max:i});j.push(t),G.attributes.POSITION=j.length-1}else i.Tools.Warn(`Morph target positions for mesh ${r.name} were not exported. Mesh does not have position vertex data`)}if(L.hasNormals){const n=L.getNormals(),z=C.getVerticesData(t.e.NormalKind);if(z){const L=new Float32Array(z.length);g=z.length/3,w=0;for(let p=w;p<g;++p){const r=J.cr.Br(z,3*p).normalize();J.cr.Br(n,3*p).normalize().subtractToRef(r,x),L[3*p]=x.x*E,L[3*p+1]=x.y,L[3*p+2]=x.z}const r=p.createBufferView(L,12),i=p.createAccessor(r,"VEC3",5126,n.length/3,0);j.push(i),G.attributes.NORMAL=j.length-1}else i.Tools.Warn(`Morph target normals for mesh ${r.name} were not exported. Mesh does not have normals vertex data`)}if(L.hasTangents){const n=L.getTangents(),z=C.getVerticesData(t.e.TangentKind);if(z){g=z.length/4;const L=new Float32Array(3*g);w=0;for(let p=w;p<g;++p){const r=J.cr.Br(z,4*p);K(r);const i=J.cr.Br(n,3*p);K(i),i.subtractToRef(r,x),L[3*p]=x.x*E,L[3*p+1]=x.y,L[3*p+2]=x.z}const r=p.createBufferView(L,12),i=p.createAccessor(r,"VEC3",5126,g,0);j.push(i),G.attributes.TANGENT=j.length-1}else i.Tools.Warn(`Morph target tangents for mesh ${r.name} were not exported. Mesh does not have tangents vertex data`)}if(L.hasColors){const n=L.getColors(),z=C.getVerticesData(t.e.ColorKind),E=C.getVertexBuffer(t.e.ColorKind);if(z&&E){const L=E.getSize();g=z.length/L;const r=new Float32Array(g*L);w=0;for(let p=w;p<g;++p)if(3===L){const i=J.cr.Br(z,p*L);J.cr.Br(n,p*L).subtractToRef(i,x),r[3*p]=x.x,r[3*p+1]=x.y,r[3*p+2]=x.z}else if(4===L){const i=new J.Vector4,j=J.Vector4.Br(z,p*L);J.Vector4.Br(n,p*L).subtractToRef(j,i),r[4*p]=i.x,r[4*p+1]=i.y,r[4*p+2]=i.z,r[4*p+3]=i.w}else i.Tools.Warn(`Unsupported number of components for color attribute: ${L}`);const C=p.createBufferView(r,4*L),t=p.createAccessor(C,3===L?"VEC3":"VEC4",5126,g,0);j.push(t),G.attributes.COLOR_0=j.length-1}else i.Tools.Warn(`Morph target colors for mesh ${r.name} were not exported. Mesh does not have colors vertex data`)}return G}var BL=p(12656),FL=p(12529),QL=p(12514),eL=p(12087);class vL{}vL.DEFAULT_COLOR=c.Wr.White(),vL.DEFAULT_WIDTH_ATTENUATED=1,vL.DEFAULT_WIDTH=.1;var yL=p(12319),AL=p(12662);class uL{static ConvertPoints(L,r){if(L.length&&Array.isArray(L)&&"number"===typeof L[0])return[L];if(L.length&&Array.isArray(L[0])&&"number"===typeof L[0][0])return L;if(L.length&&!Array.isArray(L[0])&&L[0]instanceof J.cr){const r=[];for(let p=0;p<L.length;p++){const J=L[p];r.push(J.x,J.y,J.z)}return[r]}if(L.length>0&&Array.isArray(L[0])&&L[0].length>0&&L[0][0]instanceof J.cr){const r=[],p=L;for(const L of p)r.push(L.flatMap((L=>[L.x,L.y,L.z])));return r}if(L instanceof Float32Array){if(null!==r&&void 0!==r&&r.floatArrayStride){const p=[],J=3*r.floatArrayStride;for(let r=0;r<L.length;r+=J){const i=new Array(J);for(let p=0;p<J;p++)i[p]=L[r+p];p.push(i)}return p}return[Array.from(L)]}if(L.length&&L[0]instanceof Float32Array){const r=[];for(const p of L)r.push(Array.from(p));return r}return[]}static OmitZeroLengthPredicate(L,r,p){const J=[];return r.Pr(L).lengthSquared()>0&&J.push([L,r]),p.Pr(r).lengthSquared()>0&&J.push([r,p]),L.Pr(p).lengthSquared()>0&&J.push([p,L]),0===J.length?null:J}static OmitDuplicatesPredicate(L,r,p,J){const i=[];return uL._SearchInPoints(L,r,J)||i.push([L,r]),uL._SearchInPoints(r,p,J)||i.push([r,p]),uL._SearchInPoints(p,L,J)||i.push([p,L]),0===i.length?null:i}static _SearchInPoints(L,r,p){for(const j of p)for(let p=0;p<j.length;p++){var J,i,n;if(null!==(J=j[p])&&void 0!==J&&J.equals(L))if(null!==(i=j[p+1])&&void 0!==i&&i.equals(r)||null!==(n=j[p-1])&&void 0!==n&&n.equals(r))return!0}return!1}static MeshesToLines(L,r){const p=[];for(let i=0;i<L.length;i++){const n=L[i],j=n.getVerticesData(t.e.PositionKind),z=n.Oz();if(j&&z)for(let L=0,G=0;L<z.length;L++){const C=3*z[G++],t=3*z[G++],E=3*z[G++],x=new J.cr(j[C],j[C+1],j[C+2]),w=new J.cr(j[t],j[t+1],j[t+2]),g=new J.cr(j[E],j[E+1],j[E+2]);if(r){const J=r(x,w,g,p,L,C,n,i,j,z);if(J)for(const L of J)p.push(L)}else p.push([x,w],[w,g],[g,x])}}return p}static ToVector3Array(L){if(Array.isArray(L[0])){const r=[],p=L;for(const L of p){const p=[];for(let r=0;r<L.length;r+=3)p.push(new J.cr(L[r],L[r+1],L[r+2]));r.push(p)}return r}const r=L,p=[];for(let i=0;i<r.length;i+=3)p.push(new J.cr(r[i],r[i+1],r[i+2]));return p}static ToNumberArray(L){return L.flatMap((L=>[L.x,L.y,L.z]))}static GetPointsCountInfo(L){const r=new Array(L.length);let p=0;for(let J=L.length;J--;)r[J]=L[J].length/3,p+=r[J];return{total:p,counts:r}}static GetLineLength(L){if(0===L.length)return 0;let r;r="number"===typeof L[0]?uL.ToVector3Array(L):L;const p=J.TmpVectors.cr[0];let i=0;for(let J=0;J<r.length-1;J++){const L=r[J];i+=r[J+1].subtractToRef(L,p).length()}return i}static GetLineLengthArray(L){const r=new Float32Array(L.length/3);let p=0;for(let J=0,i=L.length/3-1;J<i;J++){let i=L[3*J+0],n=L[3*J+1],j=L[3*J+2];i-=L[3*J+3],n-=L[3*J+4],j-=L[3*J+5];p+=Math.sqrt(i*i+n*n+j*j),r[J+1]=p}return r}static SegmentizeSegmentByCount(L,r,p){const i=[],n=r.Pr(L),j=J.TmpVectors.cr[0];j.Bz(p);const z=J.TmpVectors.cr[1];n.divideToRef(j,z);let G=L.clone();i.push(G);for(let J=0;J<p;J++)G=G.clone(),i.push(G.addInPlace(z));return i}static SegmentizeLineBySegmentLength(L,r){const p=L[0]instanceof J.cr?uL.GetLineSegments(L):"number"===typeof L[0]?uL.GetLineSegments(uL.ToVector3Array(L)):L,i=[];for(const J of p)if(J.length>r){const L=uL.SegmentizeSegmentByCount(J.point1,J.point2,Math.ceil(J.length/r));for(const r of L)i.push(r)}else i.push(J.point1),i.push(J.point2);return i}static SegmentizeLineBySegmentCount(L,r){const p="number"===typeof L[0]?uL.ToVector3Array(L):L,J=uL.GetLineLength(p)/r;return uL.SegmentizeLineBySegmentLength(p,J)}static GetLineSegments(L){const r=[];for(let p=0;p<L.length-1;p++){const J=L[p],i=L[p+1],n=i.Pr(J).length();r.push({point1:J,point2:i,length:n})}return r}static GetMinMaxSegmentLength(L){const r=uL.GetLineSegments(L).sort((L=>L.length));return{min:r[0].length,max:r[r.length-1].length}}static GetPositionOnLineByVisibility(L,r,p){let i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const n=r*p;let j=0,z=0;const G=L.length;for(let J=0;J<G;J++){if(n<=j+L[J].length){z=J;break}j+=L[J].length}const C=(n-j)/L[z].length;return L[z].point2.subtractToRef(L[z].point1,J.TmpVectors.cr[0]),J.TmpVectors.cr[1]=J.TmpVectors.cr[0].multiplyByFloats(C,C,C),i||J.TmpVectors.cr[1].addInPlace(L[z].point1),J.TmpVectors.cr[1].clone()}static GetCircleLinePoints(L,r){let p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/r;const j=[];for(let z=0;z<=r;z++)j.push(new J.cr(Math.cos(z*n)*L,Math.sin(z*n)*i,p));return j}static GetBezierLinePoints(L,r,p,J){return yL.e.CreateQuadraticBezier(L,r,p,J).getPoints().flatMap((L=>[L.x,L.y,L.z]))}static GetArrowCap(L,r,p,J,i){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,j=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[L.clone(),L.add(r.multiplyByFloats(p,p,p))],widths:[J,i,n,j]}}static GetPointsFromText(L,r,p,J){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const j=[],z=(0,AL.b)(L,r,p,J);for(const G of z){for(const L of G.paths){const r=[],p=L.getPoints();for(const L of p)r.push(L.x,L.y,i);j.push(r)}if(n)for(const L of G.holes){const r=[],p=L.getPoints();for(const L of p)r.push(L.x,L.y,i);j.push(r)}}return j}static Color3toRGBAUint8(L){const r=new Uint8Array(4*L.length);for(let p=0,J=0;p<L.length;p++)r[J++]=255*L[p].r,r[J++]=255*L[p].g,r[J++]=255*L[p].b,r[J++]=255;return r}static CreateColorsTexture(L,r,p,J){const i=J.getEngine().getCaps().maxTextureSize??1,n=r.length>i?i:r.length,j=Math.ceil(r.length/i);j>1&&(r=[...r,...Array(n*j-r.length).fill(r[0])]);const z=uL.Color3toRGBAUint8(r),G=new B.e(z,n,j,g.b.TEXTUREFORMAT_RGBA,J,!1,!0,p);return G.name=L,G}static PrepareEmptyColorsTexture(L){if(!vL.EmptyColorsTexture){const r=new Uint8Array(4);vL.EmptyColorsTexture=new B.e(r,1,1,g.b.TEXTUREFORMAT_RGBA,L,!1,!1,B.e.NEAREST_NEAREST),vL.EmptyColorsTexture.name="grlEmptyColorsTexture"}return vL.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var L;null===(L=vL.EmptyColorsTexture)||void 0===L||L.dispose(),vL.EmptyColorsTexture=null}static BooleanToNumber(L){return L?1:0}}class aL extends QL.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class qL extends FL.c{isCompatible(L){return!0}constructor(L,r,p){var i;p=p||{color:vL.DEFAULT_COLOR};const n=new aL;n.GREASED_LINE_HAS_COLOR=!!p.color&&!p.useColors,n.GREASED_LINE_SIZE_ATTENUATION=p.sizeAttenuation??!1,n.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===p.colorDistributionType,n.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(r??L.FL()).useRightHandedSystem,n.GREASED_LINE_CAMERA_FACING=p.cameraFacing??!0,super(L,qL.GREASED_LINE_MATERIAL_NAME,200,n,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(i=p)||void 0===i?void 0:i.forceGLSL)||qL.ForceGLSL,this._scene=r??L.FL(),this._engine=this._scene.getEngine(),this._cameraFacing=p.cameraFacing??!0,this.visibility=p.visibility??1,this.useDash=p.useDash??!1,this.dashRatio=p.dashRatio??.5,this.dashOffset=p.dashOffset??0,this.width=p.width?p.width:p.sizeAttenuation?vL.DEFAULT_WIDTH_ATTENUATED:vL.DEFAULT_WIDTH,this._sizeAttenuation=p.sizeAttenuation??!1,this.colorMode=p.colorMode??0,this._color=p.color??null,this.useColors=p.useColors??!1,this._colorsDistributionType=p.colorDistributionType??0,this.colorsSampling=p.colorsSampling??B.e.NEAREST_NEAREST,this._colors=p.yL??null,this.dashCount=p.dashCount??1,this.resolution=p.resolution??new J.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),p.colorsTexture?this.colorsTexture=p.colorsTexture:this._colors?this.colorsTexture=uL.CreateColorsTexture(`${L.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??vL.DEFAULT_COLOR,uL.PrepareEmptyColorsTexture(this._scene)),this._engine.ji.add((()=>{uL.DisposeEmptyColorsTexture()}))}getAttributes(L){L.push("grl_offsets"),L.push("grl_widths"),L.push("grl_colorPointers"),L.push("grl_counters"),this._cameraFacing?(L.push("grl_previousAndSide"),L.push("grl_nextAndCounters")):L.push("grl_slopes")}getSamplers(L){L.push("grl_colors")}getActiveTextures(L){this.colorsTexture&&L.push(this.colorsTexture)}getUniforms(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const r=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&r.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===L&&r.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:r,vertex:this._cameraFacing&&this._isGLSL(L)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(L)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(L){if(this._cameraFacing){L.tz("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||L.tz("viewProjection",this._scene.getTransformMatrix());const r=J.TmpVectors.Vector4[0];r.x=this._aspect,r.y=this._resolution.x,r.z=this._resolution.y,r.w=this.width,L.updateVector4("grl_aspect_resolution_lineWidth",r)}const r=J.TmpVectors.Vector4[0];r.x=uL.BooleanToNumber(this.useDash),r.y=this._dashArray,r.z=this.dashOffset,r.w=this.dashRatio,L.updateVector4("grl_dashOptions",r);const p=J.TmpVectors.Vector4[1];p.x=this.colorMode,p.y=this.visibility,p.z=this.colorsTexture?this.colorsTexture.getSize().width:0,p.w=uL.BooleanToNumber(this.useColors),L.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",p),this._color&&L.updateColor3("grl_singleColor",this._color);const i=this.colorsTexture??vL.EmptyColorsTexture;L.setTexture("grl_colors",i),L.updateFloat2("grl_textureSize",(null===i||void 0===i?void 0:i.getSize().width)??1,(null===i||void 0===i?void 0:i.getSize().height)??1)}prepareDefines(L,r,p){L.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,L.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,L.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,L.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=r.useRightHandedSystem,L.GREASED_LINE_CAMERA_FACING=this._cameraFacing,L.GREASED_LINE_USE_OFFSETS=!!p.offsets}getClassName(){return qL.GREASED_LINE_MATERIAL_NAME}getCustomCode(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(r)?function(L,r){if("vertex"===L){const L={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return r&&(L["!gl_Position\\=viewProjection\\*worldPos;"]="//"),L}return"fragment"===L?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(L,this._cameraFacing):function(L,r){if("vertex"===L){const L={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return r&&(L["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),L}return"fragment"===L?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(L,this._cameraFacing)}dispose(){var L;null===(L=this.colorsTexture)||void 0===L||L.dispose(),super.dispose()}get yL(){return this._colors}set yL(L){this.setColors(L)}setColors(L){var r;let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1],J=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=(null===(r=this._colors)||void 0===r?void 0:r.length)??0;var n;if(this._colors=L,null!==L&&0!==L.length){if(!p||J)if(this.colorsTexture&&i===L.length&&!J){const r=uL.Color3toRGBAUint8(L);this.colorsTexture.update(r)}else{var j;null===(j=this.colorsTexture)||void 0===j||j.dispose(),this.colorsTexture=uL.CreateColorsTexture(`${this._material.name}-colors-texture`,L,this.colorsSampling,this._scene)}}else null===(n=this.colorsTexture)||void 0===n||n.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(L){this._dashCount=L,this._dashArray=1/L}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(L){this._sizeAttenuation=L,this.markAllDefinesAsDirty()}get color(){return this._color}set color(L){this.setColor(L)}setColor(L){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==L||null!==this._color&&null===L?(this._color=L,r||this.markAllDefinesAsDirty()):this._color=L}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(L){this._colorsDistributionType=L,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(L){this._aspect=L.x/L.y,this._resolution=L}serialize(){const L=super.serialize(),r={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(r.yL=this._colors),this._color&&(r.color=this._color),L.greasedLineMaterialOptions=r,L}parse(L,r,p){var J;super.parse(L,r,p);const i=L.greasedLineMaterialOptions;null===(J=this.colorsTexture)||void 0===J||J.dispose(),i.color&&this.setColor(i.color,!0),i.colorDistributionType&&(this.colorsDistributionType=i.colorDistributionType),i.yL&&(this.yL=i.yL),i.colorsSampling&&(this.colorsSampling=i.colorsSampling),i.colorMode&&(this.colorMode=i.colorMode),i.useColors&&(this.useColors=i.useColors),i.visibility&&(this.visibility=i.visibility),i.useDash&&(this.useDash=i.useDash),i.dashCount&&(this.dashCount=i.dashCount),i.dashRatio&&(this.dashRatio=i.dashRatio),i.dashOffset&&(this.dashOffset=i.dashOffset),i.width&&(this.width=i.width),i.sizeAttenuation&&(this.sizeAttenuation=i.sizeAttenuation),i.resolution&&(this.resolution=i.resolution),this.yL?this.colorsTexture=uL.CreateColorsTexture(`${this._material.name}-colors-texture`,this.yL,this.colorsSampling,r):uL.PrepareEmptyColorsTexture(r),this.markAllDefinesAsDirty()}copyTo(L){var r;const p=L;null===(r=p.colorsTexture)||void 0===r||r.dispose(),this._colors&&(p.colorsTexture=uL.CreateColorsTexture(`${p._material.name}-colors-texture`,this._colors,p.colorsSampling,this._scene)),p.setColor(this.color,!0),p.colorsDistributionType=this.colorsDistributionType,p.colorsSampling=this.colorsSampling,p.colorMode=this.colorMode,p.useColors=this.useColors,p.visibility=this.visibility,p.useDash=this.useDash,p.dashCount=this.dashCount,p.dashRatio=this.dashRatio,p.dashOffset=this.dashOffset,p.width=this.width,p.sizeAttenuation=this.sizeAttenuation,p.resolution=this.resolution,p.markAllDefinesAsDirty()}_isGLSL(L){return 0===L||this._forceGLSL}}qL.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",qL.ForceGLSL=!1,(0,eL.e)(`BABYLON.${qL.GREASED_LINE_MATERIAL_NAME}`,qL);var ZL=p(12555),XL=p(11979),DL=p(12350),lL=p(12068);class TL extends DL.ShaderMaterial{constructor(L,r,i){const n=r.getEngine(),j=n.isWebGPU&&!(i.forceGLSL||TL.ForceGLSL),z=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];r.useRightHandedSystem&&z.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const G=["position","grl_widths","grl_offsets","grl_colorPointers"];i.cameraFacing?(z.push("GREASED_LINE_CAMERA_FACING"),G.push("grl_previousAndSide","grl_nextAndCounters")):(G.push("grl_slopes"),G.push("grl_counters"));const C=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(j||C.push("world","viewProjection","view","projection"),super(L,r,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:j?["Scene","Mesh"]:void 0,attributes:G,uniforms:C,samplers:j?[]:["grlColors"],defines:z,extraInitializationsAsync:async()=>{j?await Promise.all([p.e(66).then(p.bind(p,15247)),p.e(75).then(p.bind(p,15256))]):await Promise.all([p.e(69).then(p.bind(p,15259)),p.e(76).then(p.bind(p,15261))])},shaderLanguage:j?1:0}),this._color=c.Wr.White(),this._colorsDistributionType=0,this._colorsTexture=null,i=i||{color:vL.DEFAULT_COLOR},this.visibility=i.visibility??1,this.useDash=i.useDash??!1,this.dashRatio=i.dashRatio??.5,this.dashOffset=i.dashOffset??0,this.dashCount=i.dashCount??1,this.width=i.width?i.width:i.sizeAttenuation&&i.cameraFacing?vL.DEFAULT_WIDTH_ATTENUATED:vL.DEFAULT_WIDTH,this.sizeAttenuation=i.sizeAttenuation??!1,this.color=i.color??c.Wr.White(),this.useColors=i.useColors??!1,this.colorsDistributionType=i.colorDistributionType??0,this.colorsSampling=i.colorsSampling??B.e.NEAREST_NEAREST,this.colorMode=i.colorMode??0,this._colors=i.yL??null,this._cameraFacing=i.cameraFacing??!0,this.resolution=i.resolution??new J.Vector2(n.getRenderWidth(),n.getRenderHeight()),i.colorsTexture?this.colorsTexture=i.colorsTexture:this._colors?this.colorsTexture=uL.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,r):(this._color=this._color??vL.DEFAULT_COLOR,this.colorsTexture=uL.PrepareEmptyColorsTexture(r)),j){const L=new lL.d;L.setParameters(),L.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",L)}n.ji.add((()=>{uL.DisposeEmptyColorsTexture()}))}dispose(){var L;null===(L=this._colorsTexture)||void 0===L||L.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new J.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get yL(){return this._colors}set yL(L){this.setColors(L)}setColors(L){var r;let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1],J=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=(null===(r=this._colors)||void 0===r?void 0:r.length)??0;var n;if(this._colors=L,null!==L&&0!==L.length){if(!p||J)if(this._colorsTexture&&i===L.length&&!J){const r=uL.Color3toRGBAUint8(L);this._colorsTexture.update(r)}else{var j;null===(j=this._colorsTexture)||void 0===j||j.dispose(),this.colorsTexture=uL.CreateColorsTexture(`${this.name}-colors-texture`,L,this.colorsSampling,this.FL())}}else null===(n=this._colorsTexture)||void 0===n||n.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(L){this._colorsTexture=L,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(L){this._width=L,this.setFloat("grlWidth",L)}get useColors(){return this._useColors}set useColors(L){this._useColors=L,this.setFloat("grlUseColors",uL.BooleanToNumber(L))}get colorsSampling(){return this._colorsSampling}set colorsSampling(L){this._colorsSampling=L}get visibility(){return this._visibility}set visibility(L){this._visibility=L,this.setFloat("grlVisibility",L)}get useDash(){return this._useDash}set useDash(L){this._useDash=L,this.setFloat("grlUseDash",uL.BooleanToNumber(L))}get dashOffset(){return this._dashOffset}set dashOffset(L){this._dashOffset=L,this.setFloat("grlDashOffset",L)}get dashRatio(){return this._dashRatio}set dashRatio(L){this._dashRatio=L,this.setFloat("grlDashRatio",L)}get dashCount(){return this._dashCount}set dashCount(L){this._dashCount=L,this._dashArray=1/L,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(L){this._sizeAttenuation=L,this.setFloat("grlSizeAttenuation",uL.BooleanToNumber(L))}get color(){return this._color}set color(L){this.setColor(L)}setColor(L){L=L??vL.DEFAULT_COLOR,this._color=L,this.setColor3("grlColor",L)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(L){this._colorsDistributionType=L,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(L){this._colorMode=L,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(L){this._resolution=L,this.setVector2("grlResolution",L),this.setFloat("grlAspect",L.x/L.y)}serialize(){const L=super.serialize(),r={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(r.yL=this._colors),L.greasedLineMaterialOptions=r,L}parse(L,r,p){var J;const i=L.greasedLineMaterialOptions;null===(J=this._colorsTexture)||void 0===J||J.dispose(),i.color&&(this.color=i.color),i.colorDistributionType&&(this.colorsDistributionType=i.colorDistributionType),i.colorsSampling&&(this.colorsSampling=i.colorsSampling),i.colorMode&&(this.colorMode=i.colorMode),i.useColors&&(this.useColors=i.useColors),i.visibility&&(this.visibility=i.visibility),i.useDash&&(this.useDash=i.useDash),i.dashCount&&(this.dashCount=i.dashCount),i.dashRatio&&(this.dashRatio=i.dashRatio),i.dashOffset&&(this.dashOffset=i.dashOffset),i.width&&(this.width=i.width),i.sizeAttenuation&&(this.sizeAttenuation=i.sizeAttenuation),i.resolution&&(this.resolution=i.resolution),i.yL?this.colorsTexture=uL.CreateColorsTexture(`${this.name}-colors-texture`,i.yL,this.colorsSampling,this.FL()):this.colorsTexture=uL.PrepareEmptyColorsTexture(r),this._cameraFacing=i.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var YL,ML,fL;TL.ForceGLSL=!1,function(L){L[L.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",L[L.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(YL||(YL={})),function(L){L[L.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",L[L.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",L[L.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(ML||(ML={})),function(L){L[L.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",L[L.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",L[L.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",L[L.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",L[L.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(fL||(fL={}));class dL extends OL.c{constructor(L,r,p){super(L,r,null,null,!1,!1),this.name=L,this._options=p,this._lazy=!1,this._updatable=!1,this._engine=r.getEngine(),this._lazy=p.lazy??!1,this._updatable=p.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=p.colorPointers??[],this._widths=p.widths??new Array(p.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(L){let r=0;for(const J of this._points)r+=J.length;const p=r/3*2-this._widths.length;for(let J=0;J<p;J++)this._widths.push(L)}updateLazy(){var L,r;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(L=this._options.ribbonOptions)||void 0===L?void 0:L.smoothShading),!this.qL&&this.refreshBoundingInfo(),null===(r=this.greasedLineMaterial)||void 0===r||r.updateLazy()}addPoints(L,r){for(const p of L)this._points.push(p);this._lazy||this.setPoints(this._points,r)}dispose(L){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(L,r)}isLazy(){return this._lazy}get AL(){return this._uvs}set AL(L){this._uvs=L instanceof Float32Array?L:new Float32Array(L),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(L){this.material instanceof TL&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===L||void 0===L?void 0:L.length)>0),this._offsets=L,this._offsetsBuffer?this._offsetsBuffer.update(L):this._createOffsetsBuffer(L)}get widths(){return this._widths}set widths(L){this._widths=L,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(L)}get colorPointers(){return this._colorPointers}set colorPointers(L){this._colorPointers=L,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(L)}get greasedLineMaterial(){var L,r;if(this.material&&this.material instanceof TL)return this.material;const p=null===(L=this.material)||void 0===L||null===(r=L.pluginManager)||void 0===r?void 0:r.getPlugin(qL.GREASED_LINE_MATERIAL_NAME);return p||void 0}get points(){const L=[];return XL.b.DeepCopy(this._points,L),L}setPoints(L,r){this._points=uL.ConvertPoints(L,(null===r||void 0===r?void 0:r.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==r&&void 0!==r&&r.colorPointers||this._updateColorPointers(),this._setPoints(this._points,r)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,AL:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(L){super.serialize(L),L.type=this.getClassName(),L.lineOptions=this._createLineOptions()}_createVertexBuffers(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=new ZL.d;return r.eL=this._vertexPositions,r.indices=this._indices,r.AL=this._uvs,L&&(r.vL=[],ZL.d.ComputeNormals(this._vertexPositions,this._indices,r.vL)),r.aL(this,this._options.updatable),r}_createOffsetsBuffer(L){const r=this._scene.getEngine(),p=new t.b(r,L,this._updatable,3);this.setVerticesBuffer(p.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=p}}class sL{constructor(L,r){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=L,this.wasAddedByNoopNode=r}getIndicesAccessor(L,r,p,J,i){var n,j,z,G;return null===(n=this._indicesAccessorMap.get(L))||void 0===n||null===(j=n.get(r))||void 0===j||null===(z=j.get(p))||void 0===z||null===(G=z.get(J))||void 0===G?void 0:G.get(i)}setIndicesAccessor(L,r,p,J,i,n){let j=this._indicesAccessorMap.get(L);j||(j=new Map,this._indicesAccessorMap.set(L,j));let z=j.get(r);z||(z=new Map,j.set(r,z));let G=z.get(p);G||(G=new Map,z.set(p,G));let C=G.get(J);C||(C=new Map,G.set(J,C)),C.set(i,n)}pushExportedNode(L){this._exportedNodes.has(L)||this._exportedNodes.add(L)}getNodesSet(){return this._exportedNodes}getVertexBufferView(L){return this._vertexBufferViewMap.get(L)}setVertexBufferView(L,r){this._vertexBufferViewMap.set(L,r)}setRemappedBufferView(L,r,p){this._remappedBufferView.set(L,new Map),this._remappedBufferView.get(L).set(r,p)}getRemappedBufferView(L,r){var p;return null===(p=this._remappedBufferView.get(L))||void 0===p?void 0:p.get(r)}getVertexAccessor(L,r,p){var J,i;return null===(J=this._vertexAccessorMap.get(L))||void 0===J||null===(i=J.get(r))||void 0===i?void 0:i.get(p)}setVertexAccessor(L,r,p,J){let i=this._vertexAccessorMap.get(L);i||(i=new Map,this._vertexAccessorMap.set(L,i));let n=i.get(r);n||(n=new Map,i.set(r,n)),n.set(p,J)}hasVertexColorAlpha(L){return this._vertexMapColorAlpha.get(L)||!1}setHasVertexColorAlpha(L,r){return this._vertexMapColorAlpha.set(L,r)}getMesh(L){return this._meshMap.get(L)}setMesh(L,r){this._meshMap.set(L,r)}bindMorphDataToMesh(L,r){const p=this._meshMorphTargetMap.get(L)||[];this._meshMorphTargetMap.set(L,p),-1===p.indexOf(r)&&p.push(r)}getMorphTargetsFromMesh(L){return this._meshMorphTargetMap.get(L)}}class HL{_ApplyExtension(L,r,p,J){if(p>=r.length)return Promise.resolve(L);const i=J(r[p],L);return i?i.then((async L=>L?await this._ApplyExtension(L,r,p+1,J):null)):this._ApplyExtension(L,r,p+1,J)}_ApplyExtensions(L,r){const p=[];for(const J of HL._ExtensionNames)p.push(this._extensions[J]);return this._ApplyExtension(L,p,0,r)}_extensionsPreExportTextureAsync(L,r,p){return this._ApplyExtensions(r,((r,J)=>r.preExportTextureAsync&&r.preExportTextureAsync(L,J,p)))}_extensionsPostExportNodeAsync(L,r,p,J,i){return this._ApplyExtensions(r,((r,n)=>r.postExportNodeAsync&&r.postExportNodeAsync(L,n,p,J,i,this._bufferManager)))}_extensionsPostExportMaterialAsync(L,r,p){return this._ApplyExtensions(r,((r,J)=>r.postExportMaterialAsync&&r.postExportMaterialAsync(L,J,p)))}_extensionsPostExportMaterialAdditionalTextures(L,r,p){const J=[];for(const i of HL._ExtensionNames){const n=this._extensions[i];n.postExportMaterialAdditionalTextures&&J.push(...n.postExportMaterialAdditionalTextures(L,r,p))}return J}_extensionsPostExportTextures(L,r,p){for(const J of HL._ExtensionNames){const i=this._extensions[J];i.postExportTexture&&i.postExportTexture(L,r,p)}}_extensionsPostExportMeshPrimitive(L){for(const r of HL._ExtensionNames){const p=this._extensions[r];p.postExportMeshPrimitive&&p.postExportMeshPrimitive(L,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const L of HL._ExtensionNames){const r=this._extensions[L];r.preGenerateBinaryAsync&&await r.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(L){for(const r of HL._ExtensionNames){const p=this._extensions[r];p.enabled&&L(p)}}_extensionsOnExporting(){this._forEachExtensions((L=>{var r,p,J;L.wasUsed&&((r=this._glTF).extensionsUsed||(r.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(L.name)&&this._glTF.extensionsUsed.push(L.name),L.required&&((p=this._glTF).extensionsRequired||(p.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(L.name)&&this._glTF.extensionsRequired.push(L.name)),(J=this._glTF).extensions||(J.extensions={}),L.onExporting&&L.onExporting())}))}_loadExtensions(){for(const L of HL._ExtensionNames){const r=HL._ExtensionFactories[L](this);this._extensions[L]=r}}constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:b.c.LastCreatedScene,r=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${g.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new l(this),this._extensions={},this._bufferManager=new tL,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!L)throw new Error("No scene available to export");this._babylonScene=L,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:L=>{var r;return null===L||void 0===L||null===(r=L.di)||void 0===r?void 0:r.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...r},this._loadExtensions()}dispose(){for(const L in this._extensions){this._extensions[L].dispose()}}get options(){return this._options}static RegisterExtension(L,r){HL.UnregisterExtension(L)&&i.Tools.Warn(`Extension with the name ${L} already exists`),HL._ExtensionFactories[L]=r,HL._ExtensionNames.push(L)}static UnregisterExtension(L){if(!HL._ExtensionFactories[L])return!1;delete HL._ExtensionFactories[L];const r=HL._ExtensionNames.indexOf(L);return-1!==r&&HL._ExtensionNames.splice(r,1),!0}_generateJSON(L,r,p){const J={byteLength:L};return J.byteLength&&(this._glTF.buffers=[J]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Or=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(J.uri=r+".bin"),p?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(L){const r=await this._generateBinaryAsync();this._extensionsOnExporting();const p=this._generateJSON(r.byteLength,L,!0),J=new Blob([r],{type:"application/octet-stream"}),i=L+".gltf",n=L+".bin",j=new C;if(j.files[i]=p,j.files[n]=J,this._imageData)for(const z in this._imageData)j.files[z]=new Blob([this._imageData[z].data],{type:this._imageData[z].mimeType});return j}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(L){const r=L%4;return 0===r?r:4-r}async generateGLBAsync(L){this._shouldUseGlb=!0;const r=await this._generateBinaryAsync();this._extensionsOnExporting();const p=this._generateJSON(r.byteLength),J=L+".glb";let i,n=p.length;if("undefined"!==typeof TextEncoder){i=(new TextEncoder).encode(p),n=i.length}const j=this._getPadding(n),z=this._getPadding(r.byteLength),G=28+n+j+r.byteLength+z,t=new GL(G);if(t.writeUInt32(1179937895),t.writeUInt32(2),t.writeUInt32(G),t.writeUInt32(n+j),t.writeUInt32(1313821514),i)t.writeTypedArray(i);else{const L="_".charCodeAt(0);for(let r=0;r<n;++r){const J=p.charCodeAt(r);J!=p.codePointAt(r)?t.writeUInt8(L):t.writeUInt8(J)}}for(let C=0;C<j;++C)t.writeUInt8(32);t.writeUInt32(r.byteLength+z),t.writeUInt32(5130562),t.writeTypedArray(r);for(let C=0;C<z;++C)t.writeUInt8(0);const E=new C;return E.files[J]=new Blob([t.getOutputData()],{type:"application/octet-stream"}),E}_setNodeTransformation(L,r,p){if(r.getPivotPoint().equalsWithEpsilon(d,f.d)||i.Tools.Warn("Pivot points are not supported in the glTF serializer"),!r.position.equalsWithEpsilon(d,f.d)){const i=J.TmpVectors.cr[0].G(r.position);p&&mL(i),L.translation=i.mz()}r.Wz.equalsWithEpsilon(H,f.d)||(L.scale=r.Wz.mz());const n=r.rotationQuaternion||J.Quaternion.FromEulerAngles(r.rotation.x,r.rotation.y,r.rotation.z);n.equalsWithEpsilon(s,f.d)||(p&&V(n),L.rotation=n.normalize().mz())}_setCameraTransformation(L,r,p){if(!r.position.equalsWithEpsilon(d,f.d)){const i=J.TmpVectors.cr[0].G(r.position);p&&mL(i),L.translation=i.mz()}const i=r.rotationQuaternion||J.Quaternion.FromEulerAngles(r.rotation.x,r.rotation.y,r.rotation.z);p&&V(i),this._babylonScene.useRightHandedSystem||S(i),i.equalsWithEpsilon(s,f.d)||(L.rotation=i.mz())}_listAvailableCameras(){for(const L of this._babylonScene.cameras){const r={type:L.mode===xL.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(L.name&&(r.name=L.name),"perspective"===r.type)r.perspective={aspectRatio:L.getEngine().getAspectRatio(L),yfov:L.fovMode===xL.b.FOVMODE_VERTICAL_FIXED?L.fov:L.fov*L.getEngine().getAspectRatio(L),znear:L.nz,zfar:L.maxZ};else if("orthographic"===r.type){const p=L.orthoLeft&&L.orthoRight?.5*(L.orthoRight-L.orthoLeft):.5*L.getEngine().getRenderWidth(),J=L.orthoBottom&&L.orthoTop?.5*(L.orthoTop-L.orthoBottom):.5*L.getEngine().getRenderHeight();r.orthographic={xmag:p,ymag:J,znear:L.nz,zfar:L.maxZ}}this._camerasMap.set(L,r)}}_exportAndAssignCameras(){const L=Array.from(this._camerasMap.values());for(const r of L){const L=this._nodesCameraMap.get(r);if(void 0!==L){this._cameras.push(r);for(const r of L)r.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const L of this._babylonScene.skeletons){if(L.bones.length<=0)continue;const r={joints:[]};this._skinMap.set(L,r)}}_exportAndAssignSkeletons(){for(const L of this._babylonScene.skeletons){if(L.bones.length<=0)continue;const r=this._skinMap.get(L);if(void 0==r)continue;const p={},J=[];let n=-1;for(let i=0;i<L.bones.length;++i){const r=L.bones[i],J=r.getIndex()??i;-1!==J&&(p[J]=r,J>n&&(n=J))}for(let L=0;L<=n;++L){const n=p[L];J.push(n.getAbsoluteInverseBindMatrix());const j=n.getTransformNode();if(null!==j){const L=this._nodeMap.get(j);j&&null!==L&&void 0!==L?r.joints.push(L):i.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else i.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const j=this._nodesSkinMap.get(r);if(r.joints.length>0&&void 0!==j){const L=64*J.length,p=new Float32Array(L/4);J.forEach(((L,r)=>{p.set(L.m,16*r)}));const i=this._bufferManager.createBufferView(p);this._accessors.push(this._bufferManager.createAccessor(i,"MAT4",5126,J.length)),r.inverseBindMatrices=this._accessors.length-1,this._skins.push(r);for(const r of j)r.skin=this._skins.length-1}}}async _exportSceneAsync(){const L={nodes:[]};if(this._babylonScene.metadata){const r=this._options.metadataSelector(this._babylonScene.metadata);r&&(L.extras=r)}const r=new Array,p=new Array,J=new Array;for(const z of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&jL(z,this._babylonScene.useRightHandedSystem)?J.push(...z.getChildren()):this._babylonScene.useRightHandedSystem?r.push(z):p.push(z);this._listAvailableCameras(),this._listAvailableSkeletons();const i=new sL(!0,!1);L.nodes.push(...await this._exportNodesAsync(p,i));const n=new sL(!1,!1);L.nodes.push(...await this._exportNodesAsync(r,n));const j=new sL(!1,!0);L.nodes.push(...await this._exportNodesAsync(J,j)),L.nodes.length&&this._scenes.push(L),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&UL._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,i.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(L){let r=this._shouldExportNodeMap.get(L);return void 0===r&&(r=this._options.shouldExportNode(L),this._shouldExportNodeMap.set(L,r)),r}async _exportNodesAsync(L,r){const p=new Array;this._exportBuffers(L,r);for(const J of L)await this._exportNodeAsync(J,p,r);return p}_collectBuffers(L,r,p,J,i){if(this._shouldExportNode(L)&&L instanceof x.c&&L.Pz){const n=L.Pz.getVertexBuffers();if(n)for(const J in n){if(!I(J))continue;const j=n[J];i.setHasVertexColorAlpha(j,L.hasVertexAlpha);const z=j._buffer,G=r.get(z)||[];r.set(z,G),-1===G.indexOf(j)&&G.push(j);const C=p.get(j)||[];p.set(j,C),-1===C.indexOf(L)&&C.push(L)}const j=L.morphTargetManager;if(j)for(let r=0;r<j.numTargets;r++){const p=j.getTarget(r),i=J.get(p)||[];J.set(p,i),-1===i.indexOf(L)&&i.push(L)}}for(const n of L.getChildren())this._collectBuffers(n,r,p,J,i)}_exportBuffers(L,r){const p=new Map,J=new Map,i=new Map;for(const z of L)this._collectBuffers(z,p,J,i,r);const n=Array.from(p.keys());for(const z of n){const L=z.getData();if(!L)throw new Error("Buffer data is not available");const i=p.get(z);if(!i)continue;const n=i[0].byteStride;if(i.some((L=>L.byteStride!==n)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const j=pL(L).slice();for(const r of i){const L=J.get(r),{byteOffset:p,byteStride:i,componentCount:n,type:z,count:G,normalized:C,kind:E}=k(r,L);switch(E){case t.e.NormalKind:case t.e.TangentKind:(0,T.i)(j,p,i,n,z,G,C,(L=>{const r=Math.sqrt(L[0]*L[0]+L[1]*L[1]+L[2]*L[2]);if(r>0){const p=1/r;L[0]*=p,L[1]*=p,L[2]*=p}}));break;case t.e.ColorKind:{const r=L.filter((L=>L.material instanceof bL.Ur||null==L.material)).length;if(0==r)break;if(r!=L.length){Y.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}z==t.e.UNSIGNED_BYTE&&Y.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const J=new c.Wr,E=new c.Fz,x=this._babylonScene.getEngine().useExactSrgbConversions;(0,T.i)(j,p,i,n,z,G,C,(L=>{3===L.length?(J.hp(L,0),J.toLinearSpaceToRef(J,x),J.toArray(L,0)):(E.hp(L,0),E.toLinearSpaceToRef(E,x),E.toArray(L,0))}))}}}if(r.convertToRightHanded){for(const L of i){const r=J.get(L),{byteOffset:p,byteStride:i,componentCount:n,type:z,count:G,normalized:C,kind:E}=k(L,r);switch(E){case t.e.PositionKind:case t.e.NormalKind:case t.e.TangentKind:(0,T.i)(j,p,i,n,z,G,C,(L=>{L[0]=-L[0]}))}}r.convertedToRightHandedBuffers.set(z,j)}const G=this._bufferManager.createBufferView(j,n);r.setVertexBufferView(z,G);const C=new Map;for(const r of i){const L=J.get(r),{kind:p,totalVertices:i}=k(r,L);switch(p){case t.e.MatricesIndicesKind:case t.e.MatricesIndicesExtraKind:if(r.type==t.e.FLOAT){const L=r.getFloatData(i);null!==L&&C.set(r,L)}}}0!==C.size&&Y.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const E=Array.from(C.keys());for(const p of E){const L=C.get(p);if(!L)continue;const J=L.some((L=>L>=256)),i=new(J?Uint16Array:Uint8Array)(L.length);for(let r=0;r<L.length;r++)i[r]=L[r];const n=this._bufferManager.createBufferView(i,4*(J?2:1));r.setRemappedBufferView(z,p,n)}}const j=Array.from(i.keys());for(const z of j){const L=i.get(z);if(!L)continue;const p=WL(z,L[0],this._bufferManager,this._bufferViews,this._accessors,r.convertToRightHanded);for(const J of L)r.bindMorphDataToMesh(J,p)}}async _exportNodeAsync(L,r,p){let J=this._nodeMap.get(L);if(void 0!==J)return void(r.includes(J)||r.push(J));const i=await this._createNodeAsync(L,p);if(i){J=this._nodes.length,this._nodes.push(i),this._nodeMap.set(L,J),p.pushExportedNode(L),r.push(J);const n={name:"runtime animations",channels:[],samplers:[]},j=[];this._babylonScene.animationGroups.length||(UL._CreateMorphTargetAnimationFromMorphTargetAnimations(L,n,j,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,p.convertToRightHanded,this._options.shouldExportAnimation),L.animations.length&&UL._CreateNodeAnimationFromNodeAnimations(L,n,j,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,p.convertToRightHanded,this._options.shouldExportAnimation)),n.channels.length&&n.samplers.length&&this._animations.push(n),j.forEach((L=>{L.channels.length&&L.samplers.length&&this._animations.push(L)}))}const n=i?[]:r;for(const j of L.getChildren())await this._exportNodeAsync(j,n,p);i&&n.length&&(i.children=n)}async _createNodeAsync(L,r){if(!this._shouldExportNode(L))return null;const p={};if(L.name&&(p.name=L.name),L.metadata){const r=this._options.metadataSelector(L.metadata);r&&(p.extras=r)}if(L instanceof E.e&&(this._setNodeTransformation(p,L,r.convertToRightHanded),L instanceof x.c)){const i=L instanceof w.c?L.sourceMesh:L;if(i.ln&&i.ln.length>0&&(p.mesh=await this._exportMeshAsync(i,r)),L.skeleton){const r=this._skinMap.get(L.skeleton);var J;if(void 0!==r)void 0===this._nodesSkinMap.get(r)&&this._nodesSkinMap.set(r,[]),null===(J=this._nodesSkinMap.get(r))||void 0===J||J.push(p)}}if(L instanceof M.e){const J=this._camerasMap.get(L);if(J){var i;void 0===this._nodesCameraMap.get(J)&&this._nodesCameraMap.set(J,[]),this._setCameraTransformation(p,L,r.convertToRightHanded);const j=L.parent;if(null!==j&&rL(L,j)){const L=this._nodeMap.get(j);if(void 0!==L){var n;const r=this._nodes[L];return LL(p,r),null===(n=this._nodesCameraMap.get(J))||void 0===n||n.push(r),null}}null===(i=this._nodesCameraMap.get(J))||void 0===i||i.push(p)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",p,L,this._nodeMap,r.convertToRightHanded)?p:(Y.d.Warn(`Not exporting node ${L.name}`),null)}_exportIndices(L,r,p,J,i,j,z,G,C){let t=L;C.mode=N(j);const E=z!==n.d.CounterClockWiseSideOrientation,x=!G.wasAddedByNoopNode&&E,w=function(L){switch(L){case n.d.TriangleFillMode:case n.d.TriangleStripDrawMode:case n.d.TriangleFanDrawMode:return!0}return!1}(j)&&x;if(w){if(j===n.d.TriangleStripDrawMode||j===n.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");C.mode=N(j);const z=r?new Uint32Array(J):new Uint16Array(J);if(L)for(let r=0;r+2<J;r+=3)z[r]=L[p+r]+i,z[r+1]=L[p+r+2]+i,z[r+2]=L[p+r+1]+i;else for(let L=0;L+2<J;L+=3)z[L]=L,z[L+1]=L+2,z[L+2]=L+1;t=z}else if(L&&0!==i){const n=r?new Uint32Array(J):new Uint16Array(J);for(let r=0;r<J;r++)n[r]=L[p+r]+i;t=n}if(t){let n=G.getIndicesAccessor(L,p,J,i,w);if(void 0===n){const j=function(L,r,p,J){if(L instanceof Uint16Array||L instanceof Uint32Array)return L;if(L instanceof Int32Array)return new Uint32Array(L.buffer,L.byteOffset,L.length);const i=L.slice(r,r+p);return J?new Uint32Array(i):new Uint16Array(i)}(t,0,J,r),z=this._bufferManager.createBufferView(j),C=r?5125:5123;this._accessors.push(this._bufferManager.createAccessor(z,"SCALAR",C,J,0)),n=this._accessors.length-1,G.setIndicesAccessor(L,p,J,i,w,n)}C.indices=n}}_exportVertexBuffer(L,r,p,J,i,n){const j=L.getKind();if(!I(j))return;if(j.startsWith("uv")&&!this._options.exportUnusedUVs&&(!r||!this._materialNeedsUVsSet.has(r)))return;let z=i.getVertexAccessor(L,p,J);if(void 0===z){const r=i.convertedToRightHandedBuffers.get(L._buffer)||L._buffer.getData(),n=j===t.e.PositionKind?function(L,r,p,J){const{byteOffset:i,byteStride:n,type:j,normalized:z}=r,G=r.getSize(),C=new Array(G).fill(1/0),t=new Array(G).fill(-1/0);return(0,T.i)(L,i+p*n,n,G,j,J*G,z,(L=>{for(let r=0;r<G;r++)C[r]=Math.min(C[r],L[r]),t[r]=Math.max(t[r],L[r])})),{min:C,max:t}}(r,L,p,J):void 0,G=(j===t.e.MatricesIndicesKind||j===t.e.MatricesIndicesExtraKind)&&L.type===t.e.FLOAT,C=G?t.e.UNSIGNED_BYTE:L.type,E=G?void 0:L.normalized,x=G?i.getRemappedBufferView(L._buffer,L):i.getVertexBufferView(L._buffer),w=L.byteOffset+p*L.byteStride;this._accessors.push(this._bufferManager.createAccessor(x,function(L,r){if(L==t.e.ColorKind)return r?"VEC4":"VEC3";switch(L){case t.e.PositionKind:case t.e.NormalKind:return"VEC3";case t.e.TangentKind:case t.e.MatricesIndicesKind:case t.e.MatricesIndicesExtraKind:case t.e.MatricesWeightsKind:case t.e.MatricesWeightsExtraKind:return"VEC4";case t.e.UVKind:case t.e.UV2Kind:case t.e.UV3Kind:case t.e.UV4Kind:case t.e.UV5Kind:case t.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${L}`)}(j,i.hasVertexColorAlpha(L)),C,J,w,n,E)),z=this._accessors.length-1,i.setVertexAccessor(L,p,J,z)}n.attributes[function(L){switch(L){case t.e.PositionKind:return"POSITION";case t.e.NormalKind:return"NORMAL";case t.e.TangentKind:return"TANGENT";case t.e.ColorKind:return"COLOR_0";case t.e.UVKind:return"TEXCOORD_0";case t.e.UV2Kind:return"TEXCOORD_1";case t.e.UV3Kind:return"TEXCOORD_2";case t.e.UV4Kind:return"TEXCOORD_3";case t.e.UV5Kind:return"TEXCOORD_4";case t.e.UV6Kind:return"TEXCOORD_5";case t.e.MatricesIndicesKind:return"JOINTS_0";case t.e.MatricesIndicesExtraKind:return"JOINTS_1";case t.e.MatricesWeightsKind:return"WEIGHTS_0";case t.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${L}`)}(j)]=z}async _exportMaterialAsync(L,r,p,J){let i=this._materialMap.get(L);if(void 0===i){const J=r&&Object.keys(r).some((L=>L.startsWith("uv")));if((L=L instanceof wL.b?L.Qz[p.materialIndex]:L)instanceof gL.b)i=await this._materialExporter.exportPBRMaterialAsync(L,"image/png",J);else{if(!(L instanceof bL.Ur))return void Y.d.Warn(`Unsupported material '${L.name}' with type ${L.getClassName()}`);i=await this._materialExporter.exportStandardMaterialAsync(L,"image/png",J)}this._materialMap.set(L,i)}J.material=i}async _exportMeshAsync(L,r){var p;let J=r.getMesh(L);if(void 0!==J)return J;const i={primitives:[]};J=this._meshes.length,this._meshes.push(i),r.setMesh(L,J);const j=L.isUnIndexed?null:L.Oz(),z=null===(p=L.Pz)||void 0===p?void 0:p.getVertexBuffers(),G=r.getMorphTargetsFromMesh(L),C=L instanceof BL.e,t=L instanceof dL,E=L.ln;if(z&&E&&E.length>0)for(const g of E){const p={attributes:{}},J=g.lL()||this._babylonScene.defaultMaterial;if(t){var x,w;const r={name:J.name},i=L,n=c.Wr.White(),j=(null===(x=i.material)||void 0===x?void 0:x.alpha)??1,z=(null===(w=i.greasedLineMaterial)||void 0===w?void 0:w.color)??n;(!z.equalsWithEpsilon(n,f.d)||j<1)&&(r.pbrMetallicRoughness={baseColorFactor:[...z.mz(),j]}),this._materials.push(r),p.material=this._materials.length-1}else if(C){const r={name:J.name},i=L;(!i.color.equalsWithEpsilon(c.Wr.White(),f.d)||i.alpha<1)&&(r.pbrMetallicRoughness={baseColorFactor:[...i.color.mz(),i.alpha]}),this._materials.push(r),p.material=this._materials.length-1}else await this._exportMaterialAsync(J,z,g,p);const E=C||t?n.d.LineListDrawMode:L.overrideRenderingFillMode??J.fillMode,b=J._getEffectiveOrientation(L);this._exportIndices(j,j?(0,T.b)(j,g.indexCount,g.indexStart,g.verticesStart):g.verticesCount>65535,j?g.indexStart:g.verticesStart,j?g.indexCount:g.verticesCount,-g.verticesStart,E,b,r,p);for(const L of Object.values(z))this._exportVertexBuffer(L,J,g.verticesStart,g.verticesCount,r,p);if(G){p.targets=[];for(const L of G)p.targets.push(L.attributes)}i.primitives.push(p),this._extensionsPostExportMeshPrimitive(p)}if(G){i.weights=[],i.extras||(i.extras={}),i.extras.targetNames=[];for(const L of G)i.weights.push(L.influence),i.extras.targetNames.push(L.name)}return J}}HL._ExtensionNames=new Array,HL._ExtensionFactories={};class oL{static async GLTFAsync(L,r,p){p&&p.exportWithoutWaitingForScene||await L.whenReadyAsync();const J=new HL(L,p),i=await J.generateGLTFAsync(r.replace(/\.[^/.]+$/,""));return J.dispose(),i}static async GLBAsync(L,r,p){p&&p.exportWithoutWaitingForScene||await L.whenReadyAsync();const J=new HL(L,p),i=await J.generateGLBAsync(r.replace(/\.[^/.]+$/,""));return J.dispose(),i}}p(12677);const kL="EXT_mesh_gpu_instancing";class RL{constructor(L){this.name=kL,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(L,r,p,i,n,j){return await new Promise((L=>{if(r&&p instanceof OL.c&&p.hasThinInstances&&this._exporter){this._wasUsed=!0;const L=J.cr.Zero(),i=J.Quaternion.Identity(),z=J.cr.One(),G=p.thinInstanceGetWorldMatrices(),C=J.TmpVectors.cr[2],t=J.TmpVectors.Quaternion[1],E=J.TmpVectors.cr[3];let x=!1,w=!1,g=!1;const b=new Float32Array(3*p.ez),c=new Float32Array(4*p.ez),P=new Float32Array(3*p.ez);let O=0;for(const r of G)r.decompose(E,t,C),n&&(mL(C),V(t)),b.set(C.mz(),3*O),c.set(t.normalize().mz(),4*O),P.set(E.mz(),3*O),x=x||!C.equalsWithEpsilon(L),w=w||!t.equalsWithEpsilon(i),g=g||!E.equalsWithEpsilon(z),O++;const h={attributes:{}};x&&(h.attributes.TRANSLATION=this._buildAccessor(b,"VEC3",p.ez,j)),w&&(h.attributes.ROTATION=this._buildAccessor(c,"VEC4",p.ez,j)),g&&(h.attributes.SCALE=this._buildAccessor(P,"VEC3",p.ez,j)),r.extensions=r.extensions||{},r.extensions[kL]=h}L(r)}))}_buildAccessor(L,r,p,J){const i=J.createBufferView(L),n=J.createAccessor(i,r,5126,p);return this._exporter._accessors.push(n),this._exporter._accessors.length-1}}HL.RegisterExtension(kL,(L=>new RL(L)));var IL=p(12684),NL=p(12697),KL=p(12706),mr=p(12714);function VL(L){return L===KL.e.PositionKind?"POSITION":L===KL.e.NormalKind?"NORMAL":L===KL.e.ColorKind?"COLOR":L.startsWith(KL.e.UVKind)?"TEX_COORD":"GENERIC"}const SL={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Lr extends IL.b{static get DefaultAvailable(){return(0,IL.e)(Lr.DefaultConfiguration)}static get Default(){return Lr._Default??(Lr._Default=new Lr),Lr._Default}static ResetDefault(L){Lr._Default&&(L||Lr._Default.dispose(),Lr._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(L,r){return{module:await(r||DracoEncoderModule)({wasmBinary:L})}}_getWorkerContent(){return`${NL.l}(${NL.p})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Lr.DefaultConfiguration)}async _encodeAsync(L,r,p){const J=p?(0,mr.d)(SL,p):SL;if(this._workerPoolPromise){const p=await this._workerPoolPromise;return await new Promise(((i,n)=>{p.push(((p,j)=>{const z=L=>{p.removeEventListener("error",z),p.removeEventListener("message",G),n(L),j()},G=L=>{"encodeMeshDone"===L.data.id&&(p.removeEventListener("error",z),p.removeEventListener("message",G),i(L.data.encodedMeshData),j())};p.addEventListener("error",z),p.addEventListener("message",G);const C=[];for(const r of L)C.push(r.data.buffer);r&&C.push(r.buffer),p.postMessage({id:"encodeMesh",attributes:L,indices:r,options:J},C)}))}))}if(this._modulePromise){const p=await this._modulePromise;return(0,NL.l)(p.module,L,r,J)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(L,r){if(0==L.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");L instanceof OL.c&&L.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===r||void 0===r?void 0:r.method)&&(Y.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),r.method="MESH_SEQUENTIAL_ENCODING");const p=function(L){let r=L.Oz(void 0,!0);return!r||r instanceof Uint32Array||r instanceof Uint16Array||(r=((0,T.b)(r,r.length)?Uint32Array:Uint16Array).from(r)),r}(L),J=function(L,r){const p=[];for(const J of L.getVerticesDataKinds()){if(null!==r&&void 0!==r&&r.includes(J)){if(J===KL.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const i=L.getVertexBuffer(J),n=i.getSize(),j=(0,T.w)(i.getData(),n,i.type,i.byteOffset,i.byteStride,i.normalized,L.getTotalVertices(),!0);p.push({kind:J,dracoName:VL(J),size:n,data:j})}return p}(L,null===r||void 0===r?void 0:r.excludedAttributes);return await this._encodeAsync(J,p,r)}}Lr.DefaultConfiguration={wasmUrl:`${i.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${i.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${i.Tools._DefaultCdnUrl}/draco_encoder.js`},Lr._Default=null;const rr="KHR_draco_mesh_compression";class pr{get wasUsed(){return this._wasUsed}constructor(L){this.name=rr,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===L.options.meshCompressionMethod&&Lr.DefaultAvailable}dispose(){}postExportMeshPrimitive(L,r,p){if(!this.enabled)return;if(4!==L.mode&&5!==L.mode)return void Y.d.Warn("Cannot compress primitive with mode "+L.mode+".");const J=[],i=[];let n=null;if(void 0!==L.indices){const j=p[L.indices],z=r.getBufferView(j);n=r.getData(z).slice(),J.push(z),i.push(j)}const j=[];for(const[t,E]of Object.entries(L.attributes)){const L=p[E],n=r.getBufferView(L),G=R(L.type),C=(0,T.w)(r.getData(n),G,L.componentType,L.byteOffset||0,n.byteStride||(0,T.p)(L.componentType)*G,L.normalized||!1,L.count,!0);j.push({kind:t,dracoName:(z=t,"POSITION"===z?"POSITION":"NORMAL"===z?"NORMAL":z.startsWith("COLOR")?"COLOR":z.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:R(L.type),data:C}),J.push(n),i.push(L)}var z;const G={method:L.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},C=Lr.Default._encodeAsync(j,n,G).then((p=>{if(!p)return void Y.d.Error("Draco encoding failed for primitive.");const n={bufferView:-1,attributes:p.attributeIds},j=r.createBufferView(p.data);r.setBufferView(n,j);for(const L of J)this._bufferViewsUsed.add(L);for(const L of i)this._accessorsUsed.add(L);L.extensions||(L.extensions={}),L.extensions[rr]=n})).catch((L=>{Y.d.Error("Draco encoding failed for primitive: "+L)}));this._encodePromises.push(C),this._wasUsed=!0}async preGenerateBinaryAsync(L){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((r=>{L.getPropertiesWithBufferView(r).every((L=>this._accessorsUsed.has(L)))&&L.removeBufferView(r)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}HL.RegisterExtension(rr,(L=>new pr(L)));var Jr=p(12721);const ir="KHR_lights_punctual",nr={name:"",color:[1,1,1],vz:1,range:Number.MAX_VALUE},jr={innerConeAngle:0,outerConeAngle:Math.PI/4},zr=J.cr.Backward();class Gr{constructor(L){this.name=ir,this.enabled=!0,this.required=!1,this._exporter=L}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[ir]=this._lights}async postExportNodeAsync(L,r,p,i,n){return await new Promise((j=>{if(!(p instanceof hL.e))return void j(r);const z=p.getTypeID()==hL.e.LIGHTTYPEID_POINTLIGHT?"point":p.getTypeID()==hL.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":p.getTypeID()==hL.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!z||!(p instanceof Jr.e))return Y.d.Warn(`${L}: Light ${p.name} is not supported in ${ir}`),void j(r);if(p.falloffType!==hL.e.FALLOFF_GLTF&&Y.d.Warn(`${L}: Light falloff for ${p.name} does not match the ${ir} specification!`),!p.position.equalsToFloats(0,0,0)){const L=J.TmpVectors.cr[0].G(p.position);n&&mL(L),r.translation=L.mz()}if("point"!==z){const L=p.direction.normalizeToRef(J.TmpVectors.cr[0]);n&&mL(L);const i=J.Quaternion.FromUnitVectorsToRef(zr,L,J.TmpVectors.Quaternion[0]);J.Quaternion.IsIdentity(i)||(r.rotation=i.mz())}const G={type:z,name:p.name,color:p.yz.mz(),vz:p.vz,range:p.range};if(JL(G,nr),"spot"===z){const L=p;G.spot={innerConeAngle:L.innerAngle/2,outerConeAngle:L.angle/2},JL(G.spot,jr)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(G);const C={Up:this._lights.lights.length-1},t=p.parent;if(t&&rL(p,t)){const L=i.get(t);if(L){const p=this._exporter._nodes[L];return LL(r,p),p.extensions||(p.extensions={}),p.extensions[ir]=C,void j(null)}}r.extensions||(r.extensions={}),r.extensions[ir]=C,j(r)}))}}HL.RegisterExtension(ir,(L=>new Gr(L)));var Cr=p(12630);const tr="KHR_materials_anisotropy";class Er{constructor(L){this.name=tr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,r,p){const J=[];return p instanceof Cr.b&&p.anisotropy.isEnabled&&!p.anisotropy.legacy?(p.anisotropy.texture&&J.push(p.anisotropy.texture),J):[]}postExportMaterialAsync(L,r,p){return new Promise((L=>{if(p instanceof Cr.b){if(!p.anisotropy.isEnabled||p.anisotropy.legacy)return void L(r);this._wasUsed=!0,r.extensions=r.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(p.anisotropy.texture),i={anisotropyStrength:p.anisotropy.vz,anisotropyRotation:p.anisotropy.angle,anisotropyTexture:J??void 0};null!==i.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(p),r.extensions[tr]=i}L(r)}))}}HL.RegisterExtension(tr,(L=>new Er(L)));const xr="KHR_materials_clearcoat";class wr{constructor(L){this.name=xr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,r,p){const J=[];return p instanceof Cr.b&&p.clearCoat.isEnabled?(p.clearCoat.texture&&J.push(p.clearCoat.texture),!p.clearCoat.useRoughnessFromMainTexture&&p.clearCoat.textureRoughness&&J.push(p.clearCoat.textureRoughness),p.clearCoat.bumpTexture&&J.push(p.clearCoat.bumpTexture),J):[]}postExportMaterialAsync(L,r,p){return new Promise((L=>{if(p instanceof Cr.b){if(!p.clearCoat.isEnabled)return void L(r);this._wasUsed=!0,r.extensions=r.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(p.clearCoat.texture);let n;n=p.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(p.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(p.clearCoat.textureRoughness),p.clearCoat.isTintEnabled&&i.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${p.name}`),p.clearCoat.remapF0OnInterfaceChange&&i.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${p.name}`);const j=this._exporter._materialExporter.getTextureInfo(p.clearCoat.bumpTexture),z={clearcoatFactor:p.clearCoat.vz,clearcoatTexture:J??void 0,clearcoatRoughnessFactor:p.clearCoat.roughness,clearcoatRoughnessTexture:n??void 0,clearcoatNormalTexture:j??void 0};null===z.clearcoatTexture&&null===z.clearcoatRoughnessTexture&&null===z.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(p),r.extensions[xr]=z}L(r)}))}}HL.RegisterExtension(xr,(L=>new wr(L)));const gr="KHR_materials_diffuse_transmission";function br(L,r){const p=r.subSurface;let J=null;return p.translucencyIntensityTexture?J=p.translucencyIntensityTexture:p.thicknessTexture&&p.useMaskFromThicknessTexture&&(J=p.thicknessTexture),J&&!p.useGltfStyleTextures?(Y.d.Warn(`${L}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${r.name}`,1),null):J}class cr{constructor(L){this.name=gr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,r,p){const J=[];if(p instanceof gL.b&&this._isExtensionEnabled(p)){const r=br(L,p);return r&&J.push(r),p.subSurface.translucencyColorTexture&&J.push(p.subSurface.translucencyColorTexture),J}return J}_isExtensionEnabled(L){if(L.unlit)return!1;const r=L.subSurface;return!!r.isTranslucencyEnabled&&(!L.unlit&&!r.useAlbedoToTintTranslucency&&r.useGltfStyleTextures&&1===r.volumeIndexOfRefraction&&0===r.minimumThickness&&0===r.maximumThickness)}postExportMaterialAsync(L,r,p){return new Promise((J=>{if(p instanceof gL.b&&this._isExtensionEnabled(p)){this._wasUsed=!0;const J=p.subSurface,i=br(L,p),n=0==J.translucencyIntensity?void 0:J.translucencyIntensity,j=this._exporter._materialExporter.getTextureInfo(i)??void 0,z=!J.translucencyColor||J.translucencyColor.equalsFloats(1,1,1)?void 0:J.translucencyColor.mz(),G=this._exporter._materialExporter.getTextureInfo(J.translucencyColorTexture)??void 0,C={diffuseTransmissionFactor:n,diffuseTransmissionTexture:j,diffuseTransmissionColorFactor:z,diffuseTransmissionColorTexture:G};(j||G)&&this._exporter._materialNeedsUVsSet.add(p),r.extensions=r.extensions||{},r.extensions[gr]=C}J(r)}))}}HL.RegisterExtension(gr,(L=>new cr(L)));const Pr="KHR_materials_dispersion";class Or{constructor(){this.name=Pr,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(L){if(L.unlit)return!1;const r=L.subSurface;return!(!r.isRefractionEnabled&&!r.isDispersionEnabled)}postExportMaterialAsync(L,r,p){return new Promise((L=>{if(p instanceof gL.b&&this._isExtensionEnabled(p)){this._wasUsed=!0;const L={dispersion:p.subSurface.dispersion};r.extensions=r.extensions||{},r.extensions[Pr]=L}L(r)}))}}HL.RegisterExtension(Pr,(()=>new Or));const hr="KHR_materials_emissive_strength";class Ur{constructor(){this.name=hr,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(L,r,p){return await new Promise((L=>{if(!(p instanceof gL.b))return L(r);const J=p.emissiveColor.mz(),i=Math.max(...J);if(i>1){this._wasUsed=!0,r.extensions||(r.extensions={});const L={emissiveStrength:i},J=p.emissiveColor.scale(1/L.emissiveStrength);r.emissiveFactor=J.mz(),r.extensions[hr]=L}return L(r)}))}}HL.RegisterExtension(hr,(L=>new Ur));const Wr="KHR_materials_ior";class Br{constructor(){this.name=Wr,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(L){return!L.unlit&&(void 0!=L.indexOfRefraction&&1.5!=L.indexOfRefraction)}postExportMaterialAsync(L,r,p){return new Promise((L=>{if(p instanceof gL.b&&this._isExtensionEnabled(p)){this._wasUsed=!0;const L={ior:p.indexOfRefraction};r.extensions=r.extensions||{},r.extensions[Wr]=L}L(r)}))}}HL.RegisterExtension(Wr,(L=>new Br));const Fr="KHR_materials_iridescence";class Qr{constructor(L){this.name=Fr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,r,p){const J=[];return p instanceof Cr.b&&p.iridescence.isEnabled?(p.iridescence.texture&&J.push(p.iridescence.texture),p.iridescence.thicknessTexture&&p.iridescence.thicknessTexture!==p.iridescence.texture&&J.push(p.iridescence.thicknessTexture),J):[]}postExportMaterialAsync(L,r,p){return new Promise((L=>{if(p instanceof Cr.b){if(!p.iridescence.isEnabled)return void L(r);this._wasUsed=!0,r.extensions=r.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(p.iridescence.texture),i=this._exporter._materialExporter.getTextureInfo(p.iridescence.thicknessTexture),n={iridescenceFactor:p.iridescence.vz,iridescenceIor:p.iridescence.indexOfRefraction,iridescenceThicknessMinimum:p.iridescence.minimumThickness,iridescenceThicknessMaximum:p.iridescence.maximumThickness,iridescenceTexture:J??void 0,iridescenceThicknessTexture:i??void 0};null===n.iridescenceTexture&&null===n.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(p),r.extensions[Fr]=n}L(r)}))}}HL.RegisterExtension(Fr,(L=>new Qr(L)));const er="KHR_materials_sheen";class vr{constructor(L){this.name=er,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,r,p){return p instanceof gL.b&&p.sheen.isEnabled&&p.sheen.texture?[p.sheen.texture]:[]}async postExportMaterialAsync(L,r,p){return await new Promise((L=>{if(p instanceof gL.b){if(!p.sheen.isEnabled)return void L(r);this._wasUsed=!0,null==r.extensions&&(r.extensions={});const J={sheenColorFactor:p.sheen.color.mz(),sheenRoughnessFactor:p.sheen.roughness??0};null===J.sheenColorTexture&&null===J.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(p),p.sheen.texture&&(J.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(p.sheen.texture)??void 0),p.sheen.textureRoughness&&!p.sheen.useRoughnessFromMainTexture?J.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(p.sheen.textureRoughness)??void 0:p.sheen.texture&&p.sheen.useRoughnessFromMainTexture&&(J.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(p.sheen.texture)??void 0),r.extensions[er]=J}L(r)}))}}HL.RegisterExtension(er,(L=>new vr(L)));const yr="KHR_materials_specular";class Ar{constructor(L){this.name=yr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,r,p){const J=[];return p instanceof gL.b&&this._isExtensionEnabled(p)?(p.metallicReflectanceTexture&&J.push(p.metallicReflectanceTexture),p.reflectanceTexture&&J.push(p.reflectanceTexture),J):J}_isExtensionEnabled(L){return!L.unlit&&(void 0!=L.metallicF0Factor&&1!=L.metallicF0Factor||void 0!=L.metallicReflectanceColor&&!L.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(L))}_hasTexturesExtension(L){return null!=L.metallicReflectanceTexture||null!=L.reflectanceTexture}postExportMaterialAsync(L,r,p){return new Promise((L=>{if(p instanceof gL.b&&this._isExtensionEnabled(p)){this._wasUsed=!0,r.extensions=r.extensions||{};const L=this._exporter._materialExporter.getTextureInfo(p.metallicReflectanceTexture)??void 0,J=this._exporter._materialExporter.getTextureInfo(p.reflectanceTexture)??void 0,i={specularFactor:1==p.metallicF0Factor?void 0:p.metallicF0Factor,specularTexture:L,specularColorFactor:p.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:p.metallicReflectanceColor.mz(),specularColorTexture:J};this._hasTexturesExtension(p)&&this._exporter._materialNeedsUVsSet.add(p),r.extensions[yr]=i}L(r)}))}}HL.RegisterExtension(yr,(L=>new Ar(L)));const ur="KHR_materials_transmission";class ar{constructor(L){this.name=ur,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,r,p){const J=[];return p instanceof gL.b&&this._isExtensionEnabled(p)?(p.subSurface.thicknessTexture&&J.push(p.subSurface.thicknessTexture),J):J}_isExtensionEnabled(L){if(L.unlit)return!1;const r=L.subSurface;return r.isRefractionEnabled&&void 0!=r.refractionIntensity&&0!=r.refractionIntensity||this._hasTexturesExtension(L)}_hasTexturesExtension(L){return null!=L.subSurface.refractionIntensityTexture}async postExportMaterialAsync(L,r,p){if(p instanceof gL.b&&this._isExtensionEnabled(p)){this._wasUsed=!0;const J=p.subSurface,i={transmissionFactor:0===J.refractionIntensity?void 0:J.refractionIntensity};if(this._hasTexturesExtension(p)&&this._exporter._materialNeedsUVsSet.add(p),J.refractionIntensityTexture)if(J.useGltfStyleTextures){const L=await this._exporter._materialExporter.exportTextureAsync(J.refractionIntensityTexture,"image/png");L&&(i.transmissionTexture=L)}else Y.d.Warn(`${L}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);r.extensions||(r.extensions={}),r.extensions[ur]=i}return r}}HL.RegisterExtension(ur,(L=>new ar(L)));const qr="KHR_materials_unlit";class Zr{constructor(){this.name=qr,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(L,r,p){return new Promise((L=>{let J=!1;p instanceof gL.b?J=p.unlit:p instanceof bL.Ur&&(J=p.disableLighting),J&&(this._wasUsed=!0,null==r.extensions&&(r.extensions={}),r.extensions[qr]={}),L(r)}))}}HL.RegisterExtension(qr,(()=>new Zr));const Xr="KHR_materials_volume";class Dr{constructor(L){this.name=Xr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,r,p){const J=[];return p instanceof gL.b&&this._isExtensionEnabled(p)?(p.subSurface.thicknessTexture&&J.push(p.subSurface.thicknessTexture),J):J}_isExtensionEnabled(L){if(L.unlit)return!1;const r=L.subSurface;return!(!r.isRefractionEnabled&&!r.isTranslucencyEnabled)&&(void 0!=r.maximumThickness&&0!=r.maximumThickness||void 0!=r.tintColorAtDistance&&r.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=r.tintColor&&r.tintColor!=c.Wr.White()||this._hasTexturesExtension(L))}_hasTexturesExtension(L){return null!=L.subSurface.thicknessTexture}postExportMaterialAsync(L,r,p){return new Promise((L=>{if(p instanceof gL.b&&this._isExtensionEnabled(p)){this._wasUsed=!0;const L=p.subSurface,J={thicknessFactor:0==L.maximumThickness?void 0:L.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(L.thicknessTexture)??void 0,attenuationDistance:L.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:L.tintColorAtDistance,attenuationColor:L.tintColor.equalsFloats(1,1,1)?void 0:L.tintColor.mz()};this._hasTexturesExtension(p)&&this._exporter._materialNeedsUVsSet.add(p),r.extensions=r.extensions||{},r.extensions[Xr]=J}L(r)}))}}HL.RegisterExtension(Xr,(L=>new Dr(L)));const lr="EXT_materials_diffuse_roughness";class Tr{constructor(L){this.name=lr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,r,p){const J=[];return p instanceof Cr.b&&p._baseDiffuseRoughness?(p._baseDiffuseRoughnessTexture&&J.push(p._baseDiffuseRoughnessTexture),J):[]}postExportMaterialAsync(L,r,p){return new Promise((L=>{if(p instanceof Cr.b){if(!p._baseDiffuseRoughness)return void L(r);this._wasUsed=!0,r.extensions=r.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(p._baseDiffuseRoughnessTexture),i={diffuseRoughnessFactor:p._baseDiffuseRoughness,diffuseRoughnessTexture:J??void 0};null!==i.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(p),r.extensions[lr]=i}L(r)}))}}HL.RegisterExtension(lr,(L=>new Tr(L)));const Yr="KHR_texture_transform";class Mr{constructor(){this.name=Yr,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(L,r,p){if(p.FL()||i.Tools.Warn(`${L}: /*@__KEY__*/"scene" is not defined for Babylon texture ${p.name}!`),(0!==p.uAng||0!==p.vAng)&&(i.Tools.Warn(`${L}: Texture ${p.name} with rotation in the u or v axis is not supported in glTF.`),0!==p.uRotationCenter||0!==p.vRotationCenter))return;const J={};let n=!1;if(0===p.uOffset&&0===p.vOffset||(J.offset=[p.uOffset,p.vOffset],n=!0),1===p.uScale&&1===p.vScale||(J.scale=[p.uScale,p.vScale],n=!0),0!==p.wAng){if(0!==p.uRotationCenter||0!==p.vRotationCenter){if(p.homogeneousRotationInUVTransform&&p.uScale!==p.vScale)return void i.Tools.Warn(`${L}: Texture ${p.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Yr}.`);i.Tools.Warn(`${L}: Texture ${p.name} with non-origin rotation center will be exported using an adjusted offset with ${Yr}.`),J.offset=function(L){const{uOffset:r,vOffset:p,uRotationCenter:J,vRotationCenter:i,uScale:n,vScale:j,wAng:z}=L,G=Math.cos(z),C=Math.sin(z),t=J*n,E=i*j;return[r+(t*(1-G)+E*C),p+(E*(1-G)-t*C)]}(p)}J.rotation=-p.wAng,n=!0}0!==p.coordinatesIndex&&(J.texCoord=p.coordinatesIndex,n=!0),n&&(this._wasUsed=!0,r.extensions||(r.extensions={}),r.extensions[Yr]=J)}}HL.RegisterExtension(Yr,(()=>new Mr));class fr{static CreateSTL(L){let r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",i=arguments.length>3&&void 0!==arguments[3]&&arguments[3],n=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],j=arguments.length>5&&void 0!==arguments[5]&&arguments[5],z=arguments.length>6&&void 0!==arguments[6]&&arguments[6],G=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const C=function(L,r,p){const i=[3*L[p],3*L[p+1],3*L[p+2]],n=[new J.cr(r[i[0]],r[i[0]+2],r[i[0]+1]),new J.cr(r[i[1]],r[i[1]+2],r[i[1]+1]),new J.cr(r[i[2]],r[i[2]+2],r[i[2]+1])],j=n[0].Pr(n[1]),z=n[2].Pr(n[1]);return{v:n,n:J.cr.Cross(z,j).normalize()}},E=function(L,r,p,J){return r=x(L,r,p.x,J),r=x(L,r,p.y,J),x(L,r,p.z,J)},x=function(L,r,p,J){return L.setFloat32(r,p,J),r+4},g=function(L){if(z){let r=L;L instanceof w.c&&(r=L.sourceMesh);const p=r.getVerticesData(t.e.PositionKind,!0,!0);if(!p)return[];const i=J.cr.Zero();let n;for(n=0;n<p.length;n+=3)J.cr.TransformCoordinatesFromFloatsToRef(p[n],p[n+1],p[n+2],L.cz(!0),i).toArray(p,n);return p}return L.getVerticesData(t.e.PositionKind)||[]};z&&(j=!0);let b="",c=0,P=0;if(i){for(let p=0;p<L.length;p++){const r=L[p].Oz();c+=r?r.length/3:0}const r=new ArrayBuffer(84+50*c);b=new DataView(r),P+=80,b.setUint32(P,c,n),P+=4}else G||(b="solid stlmesh\r\n");for(let J=0;J<L.length;J++){const r=L[J];!i&&G&&(b+="solid "+r.name+"\r\n"),!j&&r instanceof OL.c&&r.bakeCurrentTransformIntoVertices();const p=g(r),z=r.Oz()||[];for(let L=0;L<z.length;L+=3){const r=C(z,p,L);i?(P=E(b,P,r.n,n),P=E(b,P,r.v[0],n),P=E(b,P,r.v[1],n),P=E(b,P,r.v[2],n),P+=2):(b+="\tfacet normal "+r.n.x+" "+r.n.y+" "+r.n.z+"\r\n",b+="\t\touter loop\r\n",b+="\t\t\tvertex "+r.v[0].x+" "+r.v[0].y+" "+r.v[0].z+"\r\n",b+="\t\t\tvertex "+r.v[1].x+" "+r.v[1].y+" "+r.v[1].z+"\r\n",b+="\t\t\tvertex "+r.v[2].x+" "+r.v[2].y+" "+r.v[2].z+"\r\n",b+="\t\tendloop\r\n",b+="\tendfacet\r\n")}!i&&G&&(b+="endsolid "+name+"\r\n")}if(i||G||(b+="endsolid stlmesh"),r){const L=document.createElement("a"),r=new Blob([b],{type:"application/octet-stream"});L.href=window.URL.createObjectURL(r),L.download=p+".stl",L.click()}return b}}function dr(L,r){let p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const J=[];for(let i=0;i<L.length/p;i++){const n=L[i*p],j=L[i*p+1],z=L[i*p+2];J.push(`(${n.toPrecision(r.precision)}, ${j.toPrecision(r.precision)}, ${z.toPrecision(r.precision)})`)}return J.join(", ")}function sr(L,r){const p=[];for(let J=0;J<L.length/2;J++){const i=L[2*J],n=L[2*J+1];p.push(`(${i.toPrecision(r.precision)}, ${(1-n).toPrecision(r.precision)})`)}return p.join(", ")}function Hr(L,r){const p=L.getVerticesData(t.e.PositionKind),J=L.getVerticesData(t.e.NormalKind);if(p&&J)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(L){var r;const p=null!==(r=L.Oz())&&void 0!==r&&r.length?L.getTotalIndices():L.getTotalVertices();return Array(p/3).fill(3).join(", ")}(L)}]\n\t\tint[] faceVertexIndices = [${function(L){const r=L.Oz(),p=[];if(null!==r)for(let J=0;J<r.length;J++)p.push(r[J]);else{const r=L.getTotalVertices();for(let L=0;L<r;L++)p.push(L)}return p.join(", ")}(L)}]\n\t\tnormal3f[] normals = [${dr(J,r)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${dr(p,r)}]\n        ${function(L,r){let p="";for(let i=0;i<4;i++){const J=i>0?i:"",n=L.getVerticesData(t.e.UVKind+(J?J+1:""));n&&(p+=`\n\t\ttexCoord2f[] primvars:st${J} = [${sr(n,r)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const J=L.getVerticesData(t.e.ColorKind);return J&&(p+=`\n\tcolor3f[] primvars:displayColor = [${dr(J,r,J.length/L.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),p}(L,r)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function or(L,r){return`\n        def "Geometry"\n        {\n        ${Hr(L,r)}\n        }\n        `}function kr(L){let r='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return r+=L,fflate.strToU8(r)}function Rr(L){const r=L.m;return`( ${Ir(r,0)}, ${Ir(r,4)}, ${Ir(r,8)}, ${Ir(r,12)} )`}function Ir(L,r){return`(${L[r+0]}, ${L[r+1]}, ${L[r+2]}, ${L[r+3]})`}function Nr(L){const r="Object_"+L.uniqueId,p=function(L){const r=L.getWorldMatrix().clone(),p=L.FL().useRightHandedSystem;if(!p){let J=L.parent;for(;J;){if(jL(J,p)){r.multiplyToRef(J.getWorldMatrix().invert(),r);break}J=J.parent}}return r.determinant()<0&&i.Tools.Warn(`Exporting mesh ${L.name} with negative scale. Result may look incorrect in destination engine.`),r}(L),J=Rr(p);return`def Xform "${r}" (\n\tprepend references = @./geometries/Geometry_${L.Pz.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${J}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${L.material.uniqueId}>\n}\n\n`}function Kr(L){switch(L){case F.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case F.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case F.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function mp(L){return`(${L.x}, ${L.y})`}function Vr(L){return`(${L.r}, ${L.g}, ${L.b})`}function Sr(L,r,p,i,n,j){const z=L.getInternalTexture().uniqueId+"_"+L.invertY;n[z]=L;const G=L.coordinatesIndex>0?"st"+L.coordinatesIndex:"st",C=new J.Vector2(L.uScale,L.vScale),t=new J.Vector2(L.uOffset,L.vOffset),E=L.wAng,x=Math.sin(E),w=Math.cos(E);return t.y=1-t.y-C.y,t.x+=x*C.x,t.y+=(1-w)*C.y,`\n    def Shader "PrimvarReader_${p}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${G}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${p}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${r.uniqueId}/PrimvarReader_${p}.outputs:result>\n        float inputs:rotation = ${(E*(180/Math.PI)).toFixed(j.precision)}\n        float2 inputs:scale = ${mp(C)}\n        float2 inputs:translation = ${mp(t)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${L.uniqueId}_${p}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${z}.png@\n        float2 inputs:st.connect = </Materials/Material_${r.uniqueId}/Transform2d_${p}.outputs:result>\n        ${i?"float4 inputs:scale = "+function(L){return`(${L.r}, ${L.g}, ${L.b}, 1.0)`}(i):""}\n        token inputs:sourceColorSpace = "${L.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Kr(L.wrapU)}"\n        token inputs:wrapT = "${Kr(L.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${r.needAlphaBlending()?"float outputs:a":""}\n    }`}function Lp(L,r,p){const J="\t\t\t",i=[],n=[],{diffuseMap:j,yz:z,alphaCutOff:G,emissiveMap:C,emissive:t,normalMap:E,roughnessMap:x,roughnessChannel:w,roughness:g,metalnessMap:b,metalnessChannel:P,metalness:O,aoMap:h,aoMapChannel:U,aoMapIntensity:W,alphaMap:B,ior:F,clearCoatEnabled:Q,clearCoat:e,clearCoatMap:v,clearCoatRoughness:y,clearCoatRoughnessMap:A}=function(L){const r={diffuseMap:null,yz:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return L instanceof bL.Ur?{...r,diffuseMap:L.diffuseTexture,yz:L.diffuseColor,alphaCutOff:L.alphaCutOff,emissiveMap:L.emissiveTexture,emissive:L.emissiveColor,roughness:1,alphaMap:L.opacityTexture}:L instanceof Cr.b?{...r,diffuseMap:L._albedoTexture,yz:L._albedoColor,alphaCutOff:L._alphaCutOff,emissiveMap:L._emissiveTexture,emissive:L._emissiveColor,normalMap:L._bumpTexture,roughnessMap:L._metallicTexture,roughnessChannel:L._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:L._roughness??1,metalnessMap:L._metallicTexture,metalnessChannel:L._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:L._metallic??0,aoMap:L._ambientTexture,aoMapChannel:L._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:L._ambientTextureStrength,alphaMap:L._opacityTexture,ior:L.subSurface.indexOfRefraction,clearCoatEnabled:L.clearCoat.isEnabled,clearCoat:L.clearCoat.vz,clearCoatMap:L.clearCoat.texture,clearCoatRoughness:L.clearCoat.roughness,clearCoatRoughnessMap:L.clearCoat.useRoughnessFromMainTexture?L.clearCoat.texture:L.clearCoat.textureRoughness}:r}(L);return null!==j?(i.push(`${J}color3f inputs:diffuseColor.connect = </Materials/Material_${L.uniqueId}/Texture_${j.uniqueId}_diffuse.outputs:rgb>`),L.needAlphaBlending()?i.push(`${J}float inputs:opacity.connect = </Materials/Material_${L.uniqueId}/Texture_${j.uniqueId}_diffuse.outputs:a>`):L.needAlphaTesting()&&(i.push(`${J}float inputs:opacity.connect = </Materials/Material_${L.uniqueId}/Texture_${j.uniqueId}_diffuse.outputs:a>`),i.push(`${J}float inputs:opacityThreshold = ${G}`)),n.push(Sr(j,L,"diffuse",z,r,p))):i.push(`${J}color3f inputs:diffuseColor = ${Vr(z||c.Wr.White())}`),null!==C?(i.push(`${J}color3f inputs:emissiveColor.connect = </Materials/Material_${L.uniqueId}/Texture_${C.uniqueId}_emissive.outputs:rgb>`),n.push(Sr(C,L,"emissive",t,r,p))):t&&t.toLuminance()>0&&i.push(`${J}color3f inputs:emissiveColor = ${Vr(t)}`),null!==E&&(i.push(`${J}normal3f inputs:normal.connect = </Materials/Material_${L.uniqueId}/Texture_${E.uniqueId}_normal.outputs:rgb>`),n.push(Sr(E,L,"normal",null,r,p))),null!==h&&(i.push(`${J}float inputs:occlusion.connect = </Materials/Material_${L.uniqueId}/Texture_${h.uniqueId}_occlusion.outputs:${U}>`),n.push(Sr(h,L,"occlusion",new c.Wr(W,W,W),r,p))),null!==x?(i.push(`${J}float inputs:roughness.connect = </Materials/Material_${L.uniqueId}/Texture_${x.uniqueId}_roughness.outputs:${w}>`),n.push(Sr(x,L,"roughness",new c.Wr(g,g,g),r,p))):i.push(`${J}float inputs:roughness = ${g}`),null!==b?(i.push(`${J}float inputs:metallic.connect = </Materials/Material_${L.uniqueId}/Texture_${b.uniqueId}_metallic.outputs:${P}>`),n.push(Sr(b,L,"metallic",new c.Wr(O,O,O),r,p))):i.push(`${J}float inputs:metallic = ${O}`),null!==B?(i.push(`${J}float inputs:opacity.connect = </Materials/Material_${L.uniqueId}/Texture_${B.uniqueId}_opacity.outputs:r>`),i.push(`${J}float inputs:opacityThreshold = 0.0001`),n.push(Sr(B,L,"opacity",null,r,p))):i.push(`${J}float inputs:opacity = ${L.alpha}`),Q&&(null!==v?(i.push(`${J}float inputs:clearcoat.connect = </Materials/Material_${L.uniqueId}/Texture_${v.uniqueId}_clearcoat.outputs:r>`),n.push(Sr(v,L,"clearcoat",new c.Wr(e,e,e),r,p))):i.push(`${J}float inputs:clearcoat = ${e}`),null!==A?(i.push(`${J}float inputs:clearcoatRoughness.connect = </Materials/Material_${L.uniqueId}/Texture_${A.uniqueId}_clearcoatRoughness.outputs:g>`),n.push(Sr(A,L,"clearcoatRoughness",new c.Wr(y,y,y),r,p))):i.push(`${J}float inputs:clearcoatRoughness = ${y}`)),i.push(`${J}float inputs:ior = ${F}`),`\n\tdef Material "Material_${L.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${i.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${L.uniqueId}/PreviewSurface.outputs:surface>\n\n${n.join("\n")}\n\n\t}\n`}async function rp(L,r,p){const n={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...r};"undefined"===typeof fflate&&await i.Tools.LoadScriptAsync(n.fflateUrl);const j={};j[n.modelFileName]=null;let z='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';z+=function(L){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===L.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${L.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${L.planeAnchoringAlignment}"`:""}\n            `}(n);const G={};for(const J of L.meshes){if(0===J.getTotalVertices())continue;const L=J,r=L.Pz,C=L.material;if(!C||!r||p&&!p(L))continue;if(-1!==["Ur","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(C.getClassName())){const p="geometries/Geometry_"+r.uniqueId+".usda";if(!(p in j)){const L=or(r,n);j[p]=kr(L)}C.uniqueId in G||(G[C.uniqueId]=C),z+=Nr(L)}else i.Tools.Warn("USDZExportAsync does not support this material type: "+C.getClassName())}L.activeCamera&&n.exportCamera&&(z+=function(L,r){const p="Camera_"+L.uniqueId,i=Rr(J.Matrix.RotationY(Math.PI).multiply(L.getWorldMatrix()));if(L.mode===F.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${p}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${i}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${L.nz.toPrecision(r.precision)}, ${L.maxZ.toPrecision(r.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(L.orthoLeft||1)+Math.abs(L.orthoRight||1))).toPrecision(r.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(L.orthoTop||1)+Math.abs(L.orthoBottom||1))).toPrecision(r.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const J=L.getEngine().getAspectRatio(L),n=r.cameraSensorWidth||35;return`def Camera "${p}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${i}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${L.nz.toPrecision(r.precision)}, ${L.maxZ.toPrecision(r.precision)})\n\t\t\tfloat focalLength = ${(n/(2*Math.tan(.5*L.fov))).toPrecision(r.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(n*J).toPrecision(r.precision)}\n\t\t\tfloat verticalAperture = ${(n/J).toPrecision(r.precision)}            \n\t\t}\n\t\n\t`}}(L.activeCamera,n)),z+="\n            }\n        }\n    }";const C={};z+=function(L,r,p){const J=[];for(const i in L){const n=L[i];J.push(Lp(n,r,p))}return`\n    def "Materials"\n{\n${J.join("")}\n}\n\n`}(G,C,n),j[n.modelFileName]=fflate.strToU8(z);for(const J in C){const L=C[J],r=L.getSize(),p=await L.readPixels();if(!p)throw new Error("Texture data is not available");const i=await Q.DumpTools.DumpDataAsync(r.width,r.height,p,"image/png",void 0,!1,!0);j[`textures/Texture_${J}.png`]=new Uint8Array(i).slice()}let t=0;for(const J in j){const L=j[J];if(!L)continue;t+=34+J.length;const r=63&t;if(4!==r){const p=new Uint8Array(64-r);j[J]=[L,{extra:{12345:p}}]}t=L.length}return fflate.zipSync(j,{level:0})}}}]);