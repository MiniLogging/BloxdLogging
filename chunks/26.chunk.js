"use strict";(self.uw9p3pwwsje=self.uw9p3pwwsje||[]).push([[26],{13248:(D,h,o)=>{o.r(h),o.d(h,{EXT_materials_diffuse_roughness:()=>Ih,EXT_mesh_gpu_instancing:()=>fD,GLTF2Export:()=>CD,GLTFData:()=>S,KHR_draco_mesh_compression:()=>oh,KHR_lights_punctual:()=>th,KHR_materials_anisotropy:()=>Kh,KHR_materials_clearcoat:()=>vh,KHR_materials_diffuse_transmission:()=>sh,KHR_materials_dispersion:()=>qh,KHR_materials_emissive_strength:()=>yh,KHR_materials_ior:()=>ih,KHR_materials_iridescence:()=>Nh,KHR_materials_sheen:()=>Oh,KHR_materials_specular:()=>Lh,KHR_materials_transmission:()=>Zh,KHR_materials_unlit:()=>ph,KHR_materials_volume:()=>ah,KHR_texture_transform:()=>nh,OBJExport:()=>M,STLExport:()=>Fh,USDZExportAsync:()=>ho,_ConvertToGLTFPBRMetallicRoughness:()=>e,_SolveMetallic:()=>Z,__IGLTFExporterExtension:()=>R});var H=o(12831),g=o(12642),j=o(13151);class M{static OBJ(D,h,o,M){const R=[];let t=1,S=1;h&&(o||(o="mat"),R.push("mtllib "+o+".mtl"));for(let k=0;k<D.length;k++){const o=D[k],K=o.name||`mesh${k}}`;R.push(`o ${K}`);let Q=null;if(M){const D=o.xh(!0);Q=new H.Matrix,D.invertToRef(Q),o.bakeTransformIntoVertices(D)}if(h){const D=o.material;D&&R.push("usemtl "+D.id)}const v=o.mg;if(!v){g.Tools.Warn("No geometry is present on the mesh");continue}const r=v.getVerticesData("position"),B=v.getVerticesData("normal"),s=v.getVerticesData("uv"),U=v.jg();let q=0,c=0;if(!r||!U){g.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const y=D[0].GD().useRightHandedSystem?1:-1;for(let D=0;D<r.length;D+=3)R.push("v "+r[D]*y+" "+r[D+1]+" "+r[D+2]),q++;if(null!=B)for(let D=0;D<B.length;D+=3)R.push("vn "+B[D]*y+" "+B[D+1]+" "+B[D+2]);if(null!=s)for(let D=0;D<s.length;D+=2)R.push("vt "+s[D]+" "+s[D+1]),c++;const b=["","",""],i=(o.material||o.GD().defaultMaterial)._getEffectiveOrientation(o),[G,N]=i===j.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let D=0;D<U.length;D+=3){const h=[String(U[D]+t),String(U[D+G]+t),String(U[D+N]+t)],o=[String(U[D]+S),String(U[D+G]+S),String(U[D+N]+S)],H=h,g=null!=s?o:b,j=null!=B?h:b;R.push("f "+H[0]+"/"+g[0]+"/"+j[0]+" "+H[1]+"/"+g[1]+"/"+j[1]+" "+H[2]+"/"+g[2]+"/"+j[2])}M&&Q&&o.bakeTransformIntoVertices(Q),t+=q,S+=c}return R.join("\n")}static MTL(D){const h=[],o=D.material;h.push("newmtl mat1"),h.push("  Ns "+o.specularPower.toFixed(4)),h.push("  Ni 1.5000"),h.push("  d "+o.alpha.toFixed(4)),h.push("  Tr 0.0000"),h.push("  Tf 1.0000 1.0000 1.0000"),h.push("  illum 2"),h.push("  Ka "+o.ambientColor.r.toFixed(4)+" "+o.ambientColor.g.toFixed(4)+" "+o.ambientColor.b.toFixed(4)),h.push("  Kd "+o.diffuseColor.r.toFixed(4)+" "+o.diffuseColor.g.toFixed(4)+" "+o.diffuseColor.b.toFixed(4)),h.push("  Ks "+o.specularColor.r.toFixed(4)+" "+o.specularColor.g.toFixed(4)+" "+o.specularColor.b.toFixed(4)),h.push("  Ke "+o.emissiveColor.r.toFixed(4)+" "+o.emissiveColor.g.toFixed(4)+" "+o.emissiveColor.b.toFixed(4));o.ambientTexture&&h.push("  map_Ka "+o.ambientTexture.name),o.diffuseTexture&&h.push("  map_Kd "+o.diffuseTexture.name),o.specularTexture&&h.push("  map_Ks "+o.specularTexture.name),o.bumpTexture&&h.push("  map_bump -imfchan z "+o.bumpTexture.name),o.opacityTexture&&h.push("  map_d "+o.opacityTexture.name);return h.join("\n")}}var R=0,t=o(12691);class S{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const D in this.files){const h=this.files[D],o=new Blob([h],{type:(0,t.k)(D)});g.Tools.Download(o,D)}}}var k=o(12894),K=o(13255),Q=o(13266),v=o(13286),r=o(12954),B=o(12683),s=o(12870),U=o(12842);const q=U.HighestCommonFactor,c={...U,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:q};var y=o(13053),b=o(12807),i=o(13316),G=o(13325),N=o(13046);const J=1e-6,O=new s.mo(.04,.04,.04),E=1024,L=s.mo.White(),T=s.mo.Black();function Z(D,h,o){if(h<O.r)return 0;const H=O.r,g=D*o/(1-O.r)+h-2*O.r,j=g*g-4*H*(O.r-h);return c.Clamp((-g+Math.sqrt(j))/(2*H),0,1)}function e(D){const h=D.diffuseColor.toLinearSpace(D.GD().getEngine().useExactSrgbConversions).scale(.5),o=D.alpha,g=function(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new H.Vector2(0,1),o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new H.Vector2(0,.1),g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new H.Vector2(0,.1),j=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new H.Vector2(1300,.1);return function(D,h,o,H,g){return(1-D)*(1-D)*(1-D)*h+3*(1-D)*(1-D)*D*o+3*(1-D)*D*D*H+D*D*D*g}(Math.pow(D/j.x,.333333),h.y,o.y,g.y,j.y)}(c.Clamp(D.specularPower,0,E));return{baseColorFactor:[h.r,h.g,h.b,o],metallicFactor:0,roughnessFactor:g}}function p(D,h){h.needAlphaBlending()?D.alphaMode="BLEND":h.needAlphaTesting()&&(D.alphaMode="MASK",D.alphaCutoff=h.alphaCutOff)}function mD(D,h,o){const H=new Uint8Array(D*h*4);for(let g=0;g<H.length;g+=4)H[g]=H[g+1]=H[g+2]=H[g+3]=255;return i.c.CreateRGBATexture(H,D,h,o)}function a(D){if(D instanceof Uint8Array){const h=D.length,o=new Float32Array(D.length);for(let H=0;H<h;++H)o[H]=D[H]/255;return o}if(D instanceof Float32Array)return D;throw new Error("Unsupported pixel format!")}class u{constructor(D){this._exporter=D,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(D){return D?this._textureMap.get(D)??null:null}async exportStandardMaterialAsync(D,h,o){const H=e(D),j={name:D.name};if(null==D.Mg||D.Mg||(D.twoSidedLighting||g.Tools.Warn(D.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),j.doubleSided=!0),o){const o=[],g=D.diffuseTexture;g&&o.push(this.exportTextureAsync(g,h).then((D=>{D&&(H.baseColorTexture=D)})));const M=D.bumpTexture;M&&o.push(this.exportTextureAsync(M,h).then((D=>{D&&(j.normalTexture=D,1!==M.level&&(j.normalTexture.scale=M.level))})));const R=D.emissiveTexture;R&&(j.emissiveFactor=[1,1,1],o.push(this.exportTextureAsync(R,h).then((D=>{D&&(j.emissiveTexture=D)}))));const t=D.ambientTexture;t&&o.push(this.exportTextureAsync(t,h).then((D=>{if(D){const h={index:D.index};j.occlusionTexture=h}}))),o.length>0&&(this._exporter._materialNeedsUVsSet.add(D),await Promise.all(o))}(D.alpha<1||D.opacityTexture)&&(D.alphaMode===G.d.ALPHA_COMBINE?j.alphaMode="BLEND":g.Tools.Warn(D.name+": glTF 2.0 does not support alpha mode: "+D.alphaMode.toString())),D.emissiveColor&&!D.emissiveColor.equalsWithEpsilon(T,J)&&(j.emissiveFactor=D.emissiveColor.Fh()),j.pbrMetallicRoughness=H,p(j,D),await this._finishMaterialAsync(j,D,h);const M=this._exporter._materials;return M.push(j),M.length-1}async _finishMaterialAsync(D,h,o){const H=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",D,h),g=[];for(const j of H)g.push(this.exportTextureAsync(j,o));await Promise.all(g),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",D,h)}async _getImageDataAsync(D,h,H,g){const j=G.d.TEXTURETYPE_UNSIGNED_BYTE,M=this._exporter._babylonScene,R=M.getEngine(),t=R.createRawTexture(D,h,H,G.d.TEXTUREFORMAT_RGBA,!1,!0,b.b.NEAREST_SAMPLINGMODE,null,j);R.isWebGPU?await o.e(51).then(o.bind(o,15188)):await o.e(52).then(o.bind(o,15193)),await y.m.ApplyPostProcess("pass",t,M,j,G.d.TEXTURE_NEAREST_SAMPLINGMODE,G.d.TEXTUREFORMAT_RGBA);const S=await R._readTexturePixels(t,h,H);return await N.DumpTools.DumpDataAsync(h,H,S,g,void 0,!0,!0)}_resizeTexturesToSameDimensions(D,h,o){const H=D?D.getSize():{width:0,height:0},g=h?h.getSize():{width:0,height:0};let j,M;return H.width<g.width?(j=D&&D instanceof b.b?y.m.CreateResizedCopy(D,g.width,g.height,!0):mD(g.width,g.height,o),M=h):H.width>g.width?(M=h&&h instanceof b.b?y.m.CreateResizedCopy(h,H.width,H.height,!0):mD(H.width,H.height,o),j=D):(j=D,M=h),{texture1:j,texture2:M}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(D,h,o,H){const g=new Array;if(!D&&!h)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const j=D?D.GD():h?h.GD():null;if(j){var M;const R=this._resizeTexturesToSameDimensions(D,h,j),t=null===(M=R.texture1)||void 0===M?void 0:M.getSize();let S,k;const K=t.width,Q=t.height,v=await R.texture1.readPixels(),r=await R.texture2.readPixels();if(!v)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(S=a(v),!r)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");k=a(r);const B=k.byteLength,U=new Uint8Array(B),q=new Uint8Array(B),c=4,y=T;let b=0,i=0;for(let D=0;D<Q;++D)for(let h=0;h<K;++h){const H=(K*D+h)*c,g={diffuseColor:new s.mo(S[H],S[H+1],S[H+2]).toLinearSpace(j.getEngine().useExactSrgbConversions).multiply(o.diffuseColor),specularColor:new s.mo(k[H],k[H+1],k[H+2]).toLinearSpace(j.getEngine().useExactSrgbConversions).multiply(o.specularColor),glossiness:k[H+3]*o.glossiness},M=this._convertSpecularGlossinessToMetallicRoughness(g);y.r=Math.max(y.r,M.baseColor.r),y.g=Math.max(y.g,M.baseColor.g),y.b=Math.max(y.b,M.baseColor.b),b=Math.max(b,M.metallic),i=Math.max(i,M.roughness),q[H]=255*M.baseColor.r,q[H+1]=255*M.baseColor.g,q[H+2]=255*M.baseColor.b,q[H+3]=R.texture1.Yh?255*S[H+3]:255,U[H]=0,U[H+1]=255*M.roughness,U[H+2]=255*M.metallic,U[H+3]=255}const G={baseColor:y,metallic:b,roughness:i};let N=!1,O=!1;for(let D=0;D<Q;++D)for(let h=0;h<K;++h){const o=(K*D+h)*c;q[o]/=G.baseColor.r>J?G.baseColor.r:1,q[o+1]/=G.baseColor.g>J?G.baseColor.g:1,q[o+2]/=G.baseColor.b>J?G.baseColor.b:1;const H=s.mo.FromInts(q[o],q[o+1],q[o+2]).toGammaSpace(j.getEngine().useExactSrgbConversions);q[o]=255*H.r,q[o+1]=255*H.g,q[o+2]=255*H.b,H.equalsWithEpsilon(L,J)||(O=!0),U[o+1]/=G.roughness>J?G.roughness:1,U[o+2]/=G.metallic>J?G.metallic:1;s.mo.FromInts(255,U[o+1],U[o+2]).equalsWithEpsilon(L,J)||(N=!0)}return N&&g.push(this._getImageDataAsync(U,K,Q,H).then((D=>{G.metallicRoughnessTextureData=D}))),O&&g.push(this._getImageDataAsync(q,K,Q,H).then((D=>{G.baseColorTextureData=D}))),await Promise.all(g).then((()=>G))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(D){const h=this._getPerceivedBrightness(D.diffuseColor),o=this._getPerceivedBrightness(D.specularColor),H=1-this._getMaxComponent(D.specularColor),g=Z(h,o,H),j=D.diffuseColor.scale(H/(1-O.r)/Math.max(1-g)),M=D.specularColor.Nh(O.scale(1-g)).scale(1/Math.max(g));let R=s.mo.Lerp(j,M,g*g);R=R.clampToRef(0,1,R);return{baseColor:R,metallic:g,roughness:1-D.glossiness}}_getPerceivedBrightness(D){return D?Math.sqrt(.299*D.r*D.r+.587*D.g*D.g+.114*D.b*D.b):0}_getMaxComponent(D){return D?Math.max(D.r,Math.max(D.g,D.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(D,h,o,H){const g=[],j={baseColor:D._albedoColor,metallic:D._metallic,roughness:D._roughness};if(H){D._albedoTexture&&g.push(this.exportTextureAsync(D._albedoTexture,h).then((D=>{D&&(o.baseColorTexture=D)})));const H=D._metallicTexture;H&&g.push(this.exportTextureAsync(H,h).then((D=>{D&&(o.metallicRoughnessTexture=D)})))}return g.length>0&&(this._exporter._materialNeedsUVsSet.add(D),await Promise.all(g)),j}_getTextureSampler(D){const h={};if(!D||!(D instanceof b.b))return h;const o=this._getGLTFTextureWrapMode(D.wrapU);10497!==o&&(h.wrapS=o);const H=this._getGLTFTextureWrapMode(D.wrapV);switch(10497!==H&&(h.wrapT=H),D.samplingMode){case b.b.LINEAR_LINEAR:h.magFilter=9729,h.minFilter=9729;break;case b.b.LINEAR_NEAREST:h.magFilter=9729,h.minFilter=9728;break;case b.b.NEAREST_LINEAR:h.magFilter=9728,h.minFilter=9729;break;case b.b.NEAREST_LINEAR_MIPLINEAR:h.magFilter=9728,h.minFilter=9987;break;case b.b.NEAREST_NEAREST:h.magFilter=9728,h.minFilter=9728;break;case b.b.NEAREST_LINEAR_MIPNEAREST:h.magFilter=9728,h.minFilter=9985;break;case b.b.LINEAR_NEAREST_MIPNEAREST:h.magFilter=9729,h.minFilter=9984;break;case b.b.LINEAR_NEAREST_MIPLINEAR:h.magFilter=9729,h.minFilter=9986;break;case b.b.NEAREST_NEAREST_MIPLINEAR:h.magFilter=9728,h.minFilter=9986;break;case b.b.LINEAR_LINEAR_MIPLINEAR:h.magFilter=9729,h.minFilter=9987;break;case b.b.LINEAR_LINEAR_MIPNEAREST:h.magFilter=9729,h.minFilter=9985;break;case b.b.NEAREST_NEAREST_MIPNEAREST:h.magFilter=9728,h.minFilter=9984}return h}_getGLTFTextureWrapMode(D){switch(D){case b.b.WRAP_ADDRESSMODE:return 10497;case b.b.CLAMP_ADDRESSMODE:return 33071;case b.b.MIRROR_ADDRESSMODE:return 33648;default:return g.Tools.Error(`Unsupported Texture Wrap Mode ${D}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(D,h,o,H){const g={diffuseColor:D._albedoColor,specularColor:D._reflectivityColor,glossiness:D._microSurface},j=D._albedoTexture,M=D._reflectivityTexture,R=D._useMicroSurfaceFromReflectivityMapAlpha;if(M&&!R)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((j||M)&&H){this._exporter._materialNeedsUVsSet.add(D);const H=this._exportTextureSampler(j||M),R=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(j,M,g,h),t=this._exporter._textures;if(R.baseColorTextureData){const D=this._exportImage(`baseColor${t.length}`,h,R.baseColorTextureData);o.baseColorTexture=this._exportTextureInfo(D,H,null===j||void 0===j?void 0:j.coordinatesIndex)}if(R.metallicRoughnessTextureData){const D=this._exportImage(`metallicRoughness${t.length}`,h,R.metallicRoughnessTextureData);o.metallicRoughnessTexture=this._exportTextureInfo(D,H,null===M||void 0===M?void 0:M.coordinatesIndex)}return R}return this._convertSpecularGlossinessToMetallicRoughness(g)}async exportPBRMaterialAsync(D,h,o){const H={},g={name:D.name},j=D.isMetallicWorkflow();if(j){const h=D._albedoColor,o=D.alpha;h&&(H.baseColorFactor=[h.r,h.g,h.b,o])}const M=j?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(D,h,H,o):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(D,h,H,o);await this._setMetallicRoughnessPbrMaterialAsync(M,D,g,H,h,o),await this._finishMaterialAsync(g,D,h);const R=this._exporter._materials;return R.push(g),R.length-1}async _setMetallicRoughnessPbrMaterialAsync(D,h,o,H,j,M){if(p(o,h),D.baseColor.equalsWithEpsilon(L,J)&&c.WithinEpsilon(h.alpha,1,J)||(H.baseColorFactor=[D.baseColor.r,D.baseColor.g,D.baseColor.b,h.alpha]),null!=D.metallic&&1!==D.metallic&&(H.metallicFactor=D.metallic),null!=D.roughness&&1!==D.roughness&&(H.roughnessFactor=D.roughness),null==h.Mg||h.Mg||(h._twoSidedLighting||g.Tools.Warn(h.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),o.doubleSided=!0),M){const D=[],H=h._bumpTexture;H&&D.push(this.exportTextureAsync(H,j).then((D=>{D&&(o.normalTexture=D,1!==H.level&&(o.normalTexture.scale=H.level))})));const g=h._ambientTexture;g&&D.push(this.exportTextureAsync(g,j).then((D=>{if(D){const H={index:D.index,texCoord:D.texCoord,extensions:D.extensions};o.occlusionTexture=H;const g=h._ambientTextureStrength;g&&(H.strength=g)}})));const M=h._emissiveTexture;M&&D.push(this.exportTextureAsync(M,j).then((D=>{D&&(o.emissiveTexture=D)}))),D.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(D))}const R=h._emissiveColor;R.equalsWithEpsilon(T,J)||(o.emissiveFactor=R.Fh()),o.pbrMetallicRoughness=H}_getPixelsFromTextureAsync(D){return function(D){switch(D){case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case G.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(D.textureFormat)?(0,y.k)(D,D._texture.width,D._texture.height):(D.textureType,G.d.TEXTURETYPE_UNSIGNED_BYTE,D.readPixels())}async exportTextureAsync(D,h){const o=this._exporter._extensionsPreExportTextureAsync("exporter",D,h);return o?await o.then((async o=>o?await this._exportTextureInfoAsync(o,h):await this._exportTextureInfoAsync(D,h))):await this._exportTextureInfoAsync(D,h)}async _exportTextureInfoAsync(D,h){let o=this._textureMap.get(D);if(!o){const H=await this._getPixelsFromTextureAsync(D);if(!H)return null;const j=this._exportTextureSampler(D),M=D.mimeType;if(M)switch(M){case"image/jpeg":case"image/png":case"image/webp":h=M;break;default:g.Tools.Warn(`Unsupported media type: ${M}. Exporting texture as PNG.`)}const R=this._internalTextureToImage,t=D.getInternalTexture().uniqueId;R[t]||(R[t]={});let S=R[t][h];if(void 0===S){const o=D.getSize();S=(async()=>{const g=await this._getImageDataAsync(H,o.width,o.height,h);return this._exportImage(D.name,h,g)})(),R[t][h]=S}o=this._exportTextureInfo(await S,j,D.coordinatesIndex),this._textureMap.set(D,o),this._exporter._extensionsPostExportTextures("exporter",o,D)}return o}_exportImage(D,h,o){const H=this._exporter._images;let j;if(this._exporter._shouldUseGlb){j={name:D,mimeType:h,bufferView:void 0};const H=this._exporter._bufferManager.createBufferView(new Uint8Array(o));this._exporter._bufferManager.setBufferView(j,H)}else{const M=D.replace(/\.\/|\/|\.\\|\\/g,"_"),R=function(D){switch(D){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(h);let t=M+R;H.some((D=>D.uri===t))&&(t=`${M}_${g.Tools.RandomId()}${R}`),j={name:D,uri:t},this._exporter._imageData[t]={data:o,mimeType:h}}return H.push(j),H.length-1}_exportTextureInfo(D,h,o){const H=this._exporter._textures;let g=H.findIndex((o=>o.sampler==h&&o.source===D));-1===g&&(g=H.length,H.push({source:D,sampler:h}));const j={index:g};return o&&(j.texCoord=o),j}_exportTextureSampler(D){const h=this._getTextureSampler(D),o=this._exporter._samplers,H=o.findIndex((D=>D.minFilter===h.minFilter&&D.magFilter===h.magFilter&&D.wrapS===h.wrapS&&D.wrapT===h.wrapT));return-1!==H?H:(o.push(h),o.length-1)}}var I=o(12901),P=o(12658),n=o(13332),F=o(12833);const w=H.Gh.Zero(),Y=H.Quaternion.Identity(),l=H.Gh.One(),C=new H.Gh(-1,1,1);function z(D,h){const{byteOffset:o,byteStride:H,type:g,normalized:j}=D,M=D.getSize(),R=h.reduce(((D,h)=>h.getTotalVertices()>D?h.getTotalVertices():D),-Number.MAX_VALUE);return{byteOffset:o,byteStride:H,componentCount:M,type:g,count:R*M,normalized:j,totalVertices:R,kind:D.getKind()}}function f(D){switch(D){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function V(D){switch(D){case k.f.PositionKind:case k.f.NormalKind:case k.f.TangentKind:case k.f.ColorKind:case k.f.MatricesIndicesKind:case k.f.MatricesIndicesExtraKind:case k.f.MatricesWeightsKind:case k.f.MatricesWeightsExtraKind:case k.f.UVKind:case k.f.UV2Kind:case k.f.UV3Kind:case k.f.UV4Kind:case k.f.UV5Kind:case k.f.UV6Kind:return!0}return!1}function d(D){switch(D){case j.c.TriangleFillMode:return 4;case j.c.TriangleStripDrawMode:return 5;case j.c.TriangleFanDrawMode:return 6;case j.c.PointListDrawMode:case j.c.PointFillMode:return 0;case j.c.LineLoopDrawMode:return 2;case j.c.LineListDrawMode:return 1;case j.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${D}`)}function X(D){const h=Math.sqrt(D.x*D.x+D.y*D.y+D.z*D.z);h>0&&(D.x/=h,D.y/=h,D.z/=h)}function A(D){return D.x*=-1,D}function W(D){if(D.x*D.x+D.y*D.y>.5){const h=Math.abs(D.x),o=Math.abs(D.y);if(h>o){const o=Math.sign(D.x);D.x=h,D.y*=-o,D.z*=-o,D.w*=o}else{const h=Math.sign(D.y);D.x*=-h,D.y=o,D.z*=h,D.w*=-h}}else{const h=Math.abs(D.z),o=Math.abs(D.w);if(h>o){const o=Math.sign(D.z);D.x*=-o,D.y*=o,D.z=h,D.w*=-o}else{const h=Math.sign(D.w);D.x*=h,D.y*=-h,D.z*=-h,D.w=o}}return D}function x(D){D.Qg(-D.z,D.w,D.x,-D.y)}function DD(D,h){const o=H.Gh.FromArrayToRef(h.translation||[0,0,0],0,H.TmpVectors.Gh[0]),g=H.Quaternion.FromArrayToRef(h.rotation||[0,0,0,1],0,H.TmpVectors.Quaternion[0]),j=H.Matrix.ComposeToRef(l,g,o,H.TmpVectors.Matrix[0]),M=H.Gh.FromArrayToRef(D.translation||[0,0,0],0,H.TmpVectors.Gh[2]),R=H.Quaternion.FromArrayToRef(D.rotation||[0,0,0,1],0,H.TmpVectors.Quaternion[1]),t=H.Matrix.ComposeToRef(l,R,M,H.TmpVectors.Matrix[1]);j.multiplyToRef(t,t),t.decompose(void 0,g,o),o.equalsWithEpsilon(w,F.d)?delete h.translation:h.translation=o.Fh(),g.equalsWithEpsilon(Y,F.d)?delete h.rotation:h.rotation=g.Fh(),h.scale&&delete h.scale}function hD(D,h){if(!(h instanceof K.c))return!1;if(!(1===h.getChildren().length&&0===D.getChildren().length&&D.parent===h))return!1;const o=D.GD(),H=D instanceof n.b&&!o.useRightHandedSystem?C:l;return!!h.Ug.equalsWithEpsilon(H,F.d)||(P.d.Warn(`Cannot collapse node ${D.name} into parent node ${h.name} with modified scaling.`),!1)}function oD(D){if(D instanceof Array){const h=new Float32Array(D);return new Uint8Array(h.buffer,h.byteOffset,h.byteLength)}return ArrayBuffer.isView(D)?new Uint8Array(D.buffer,D.byteOffset,D.byteLength):new Uint8Array(D)}function HD(D,h){for(const[o,H]of Object.entries(D)){const g=h[o];(Array.isArray(H)&&Array.isArray(g)&&gD(H,g)||H===g)&&delete D[o]}return D}function gD(D,h){return D.length===h.length&&D.every(((D,o)=>D===h[o]))}const jD=H.Matrix.Compose(new H.Gh(-1,1,1),H.Quaternion.Identity(),H.Gh.Zero());function MD(D,h){if(!(D instanceof K.c))return!1;if(h){if(!D.getWorldMatrix().equalsWithEpsilon(H.Matrix.IdentityReadOnly,F.d))return!1}else{if(!D.getWorldMatrix().multiplyToRef(jD,H.TmpVectors.Matrix[0]).equalsWithEpsilon(H.Matrix.IdentityReadOnly,F.d))return!1}return!(D instanceof Q.e&&D.mg)}const RD=new Map([[Int8Array,(D,h,o)=>D.setInt8(h,o)],[Uint8Array,(D,h,o)=>D.setUint8(h,o)],[Uint8ClampedArray,(D,h,o)=>D.setUint8(h,o)],[Int16Array,(D,h,o)=>D.setInt16(h,o,!0)],[Uint16Array,(D,h,o)=>D.setUint16(h,o,!0)],[Int32Array,(D,h,o)=>D.setInt32(h,o,!0)],[Uint32Array,(D,h,o)=>D.setUint32(h,o,!0)],[Float32Array,(D,h,o)=>D.setFloat32(h,o,!0)],[Float64Array,(D,h,o)=>D.setFloat64(h,o,!0)]]);class tD{writeTypedArray(D){this._checkGrowBuffer(D.byteLength);const h=RD.get(D.constructor);for(let o=0;o<D.length;o++)h(this._dataView,this._byteOffset,D[o]),this._byteOffset+=D.BYTES_PER_ELEMENT}constructor(D){this._data=new Uint8Array(D),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(D){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,D),this._byteOffset++}writeInt8(D){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,D),this._byteOffset++}writeInt16(D){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,D,!0),this._byteOffset+=2}writeUInt16(D){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,D,!0),this._byteOffset+=2}writeInt32(D){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,D,!0),this._byteOffset+=4}writeUInt32(D){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,D,!0),this._byteOffset+=4}writeFloat32(D){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,D,!0),this._byteOffset+=4}writeFloat64(D){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,D,!0),this._byteOffset+=8}_checkGrowBuffer(D){const h=this.byteOffset+D;if(h>this._data.byteLength){const D=new Uint8Array(2*h);D.set(this._data),this._data=D,this._dataView=new DataView(this._data.buffer)}}}function SD(D){return D%4===0?4:D%2===0?2:1}class kD{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(D){let h=0;this._bufferViewToData.forEach((D=>{h+=D.byteLength}));const o=new tD(h),H=Array.from(this._bufferViewToData.keys()).sort(((D,h)=>SD(h.byteLength)-SD(D.byteLength)));for(const g of H){g.byteOffset=o.byteOffset,D.push(g);const h=D.length-1,H=this.getPropertiesWithBufferView(g);for(const D of H)D.bufferView=h;o.writeTypedArray(this._bufferViewToData.get(g)),this._bufferViewToData.delete(g)}return o.getOutputData()}createBufferView(D,h){const o={buffer:0,byteOffset:void 0,byteLength:D.byteLength,byteStride:h};return this._bufferViewToData.set(o,D),o}createAccessor(D,h,o,H,g,j,M){this._verifyBufferView(D);const R={bufferView:void 0,componentType:o,count:H,type:h,min:null===j||void 0===j?void 0:j.min,max:null===j||void 0===j?void 0:j.max,normalized:M,byteOffset:g};return this.setBufferView(R,D),this._accessorToBufferView.set(R,D),R}setBufferView(D,h){this._verifyBufferView(h);this.getPropertiesWithBufferView(h).push(D)}removeBufferView(D){const h=this.getPropertiesWithBufferView(D);for(const o of h)void 0!==o.bufferView&&delete o.bufferView;this._bufferViewToData.delete(D),this._bufferViewToProperties.delete(D),this._accessorToBufferView.forEach(((h,o)=>{h===D&&(void 0!==o.byteOffset&&delete o.byteOffset,this._accessorToBufferView.delete(o))}))}getBufferView(D){const h=this._accessorToBufferView.get(D);return this._verifyBufferView(h),h}getPropertiesWithBufferView(D){return this._verifyBufferView(D),this._bufferViewToProperties.set(D,this._bufferViewToProperties.get(D)??[]),this._bufferViewToProperties.get(D)}getData(D){return this._verifyBufferView(D),this._bufferViewToData.get(D)}_verifyBufferView(D){if(void 0===D||!this._bufferViewToData.has(D))throw new Error(`BufferView ${D} not found in BufferManager.`)}}var KD,QD=o(13296),vD=o(13312),rD=o(13337),BD=o(13205),sD=o(13377),UD=o(13389),qD=o(13288),cD=o(13392);!function(D){D[D.INTANGENT=0]="INTANGENT",D[D.OUTTANGENT=1]="OUTTANGENT"}(KD||(KD={}));class yD{static _IsTransformable(D){return D&&(D instanceof K.c||D instanceof QD.b||D instanceof cD.c)}static _CreateNodeAnimation(D,h,o,H,j){if(this._IsTransformable(D)){const M=[],R=[],t=h.getKeys(),S=yD._CalculateMinMaxKeyFrames(t),k=yD._DeduceInterpolation(t,o,H),K=k.interpolationType,Q=k.shouldBakeAnimation;if(Q?yD._CreateBakedAnimation(D,h,o,S.min,S.max,h.framePerSecond,j,M,R,S,H):"LINEAR"===K||"STEP"===K?yD._CreateLinearOrStepAnimation(D,h,o,M,R,H):"CUBICSPLINE"===K?yD._CreateCubicSplineAnimation(D,h,o,M,R,H):yD._CreateBakedAnimation(D,h,o,S.min,S.max,h.framePerSecond,j,M,R,S,H),M.length&&R.length){return{inputs:M,outputs:R,samplerInterpolation:K,inputsMin:Q?S.min:g.Tools.FloatRound(S.min/h.framePerSecond),inputsMax:Q?S.max:g.Tools.FloatRound(S.max/h.framePerSecond)}}}return null}static _DeduceAnimationInfo(D){let h=null,o="VEC3",H=!1;const j=D.targetProperty.split(".");switch(j[0]){case"Ug":h="scale";break;case"position":h="translation";break;case"rotation":o="VEC4",h="rotation";break;case"rotationQuaternion":o="VEC4",H=!0,h="rotation";break;case"influence":o="SCALAR",h="weights";break;default:g.Tools.Error(`Unsupported animatable property ${j[0]}`)}return h?{animationChannelTargetPath:h,dataAccessorType:o,useQuaternion:H}:(g.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(D,h,o,H,g,j,M,R,t,S,k){let K;if(yD._IsTransformable(D)&&D.animations)for(const Q of D.animations){if(k&&!k(Q))continue;const g=yD._DeduceAnimationInfo(Q);g&&(K={name:Q.name,samplers:[],channels:[]},yD._AddAnimation(`${Q.name}`,Q.hasRunningRuntimeAnimations?h:K,D,Q,g.dataAccessorType,g.animationChannelTargetPath,H,j,M,R,g.useQuaternion,t,S),K.samplers.length&&K.channels.length&&o.push(K))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(D,h,o,H,g,j,M,R,t,S,k){let K;if(D instanceof qD.d){const g=D.morphTargetManager;if(g)for(let Q=0;Q<g.numTargets;++Q){const v=g.getTarget(Q);for(const r of v.animations){if(k&&!k(r))continue;const v=new sD.e(`${r.name}`,"influence",r.framePerSecond,r.dataType,r.loopMode,r.enableBlending),B=[],s=r.getKeys();for(let D=0;D<s.length;++D){const h=s[D];for(let D=0;D<g.numTargets;++D)D==Q?B.push(h):B.push({frame:h.frame,value:0})}v.setKeys(B);const U=yD._DeduceAnimationInfo(v);U&&(K={name:v.name,samplers:[],channels:[]},yD._AddAnimation(r.name,r.hasRunningRuntimeAnimations?h:K,D,v,U.dataAccessorType,U.animationChannelTargetPath,H,j,M,R,U.useQuaternion,t,S,g.numTargets),K.samplers.length&&K.channels.length&&o.push(K))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(D,h,o,H,g,j,M,R,t){let S;if(D.animationGroups){const K=D.animationGroups;for(const Q of K){const K=new Map,v=new Map,r=new Set,B=Q.to-Q.from;S={name:Q.name,channels:[],samplers:[]};for(let h=0;h<Q.targetedAnimations.length;++h){const B=Q.targetedAnimations[h],s=B.target,U=B.animation;if(t&&!t(U))continue;const q=R.has(s);if(this._IsTransformable(s)||1===s.length&&this._IsTransformable(s[0])){const D=yD._DeduceAnimationInfo(B.animation);if(D){const h=this._IsTransformable(s)?s:this._IsTransformable(s[0])?s[0]:null;h&&yD._AddAnimation(`${U.name}`,S,h,U,D.dataAccessorType,D.animationChannelTargetPath,o,H,g,j,D.useQuaternion,M,q)}}else if(s instanceof UD.c||1===s.length&&s[0]instanceof UD.c){if(yD._DeduceAnimationInfo(B.animation)){const h=s instanceof UD.c?s:s[0];if(h){const o=D.morphTargetManagers.find((D=>{for(let o=0;o<D.numTargets;++o)if(D.getTarget(o)===h)return!0;return!1}));if(o){const H=D.meshes.find((D=>D.morphTargetManager===o));var k;if(H)K.has(H)||K.set(H,new Map),null===(k=K.get(H))||void 0===k||k.set(h,U),r.add(H),v.set(H,U)}}}}}r.forEach((D=>{const h=D.morphTargetManager;let R=null;const t=[],k=v.get(D).getKeys(),r=k.length;for(let o=0;o<r;++o)for(let H=0;H<h.numTargets;++H){const g=h.getTarget(H),j=K.get(D);if(j){const h=j.get(g);h?(R||(R=new sD.e(`${Q.name}_${D.name}_MorphWeightAnimation`,"influence",h.framePerSecond,sD.e.ANIMATIONTYPE_FLOAT,h.loopMode,h.enableBlending)),t.push(h.getKeys()[o])):t.push({frame:Q.from+B/r*o,value:g.influence,inTangent:k[0].inTangent?0:void 0,outTangent:k[0].outTangent?0:void 0})}}R.setKeys(t);const s=yD._DeduceAnimationInfo(R);s&&yD._AddAnimation(`${Q.name}_${D.name}_MorphWeightAnimation`,S,D,R,s.dataAccessorType,s.animationChannelTargetPath,o,H,g,j,s.useQuaternion,M,!1,null===h||void 0===h?void 0:h.numTargets)})),S.channels.length&&S.samplers.length&&h.push(S)}}}static _AddAnimation(D,h,o,g,j,M,R,t,S,k,K,Q,v,r){const B=yD._CreateNodeAnimation(o,g,M,K,Q);let s,U,q,c,y,b;if(B){if(r){let D=0,h=0;const o=[];for(;B.inputs.length>0;)h=B.inputs.shift(),D%r==0&&o.push(h),D++;B.inputs=o}const D=R.get(o),g=new Float32Array(B.inputs);s=t.createBufferView(g),U=t.createAccessor(s,"SCALAR",5126,B.inputs.length,void 0,{min:[B.inputsMin],max:[B.inputsMax]}),k.push(U),q=k.length-1;const S=new H.Quaternion,K=new H.Gh,Q=new H.Gh,i=o instanceof QD.b,G=f(j),N=new Float32Array(B.outputs.length*G);B.outputs.forEach((function(D,h){let o=D;switch(M){case"translation":v&&(H.Gh.FromArrayToRef(D,0,Q),A(Q),Q.toArray(o));break;case"rotation":4===D.length?H.Quaternion.FromArrayToRef(D,0,S):(o=new Array(4),H.Gh.FromArrayToRef(D,0,K),H.Quaternion.FromEulerVectorToRef(K,S)),v&&(W(S),i&&x(S)),S.toArray(o)}N.set(o,h*G)})),s=t.createBufferView(N),U=t.createAccessor(s,j,5126,B.outputs.length),k.push(U),c=k.length-1,y={interpolation:B.samplerInterpolation,input:q,output:c},h.samplers.push(y),b={sampler:h.samplers.length-1,target:{node:D,path:M}},h.channels.push(b)}}static _CreateBakedAnimation(D,h,o,j,M,R,t,S,k,K,Q){let v;const r=H.Quaternion.Identity();let B,s=null,U=null,q=null,c=null,y=null,b=null;K.min=g.Tools.FloatRound(j/R);const i=h.getKeys();for(let H=0,G=i.length;H<G;++H){if(b=null,q=i[H],H+1<G)if(c=i[H+1],q.value.equals&&q.value.equals(c.value)||q.value===c.value){if(0!==H)continue;b=q.frame}else b=c.frame;else{if(y=i[H-1],q.value.equals&&q.value.equals(y.value)||q.value===y.value)continue;b=M}if(b)for(let H=q.frame;H<=b;H+=t){if(B=g.Tools.FloatRound(H/R),B===s)continue;s=B,U=B;const j={key:0,repeatCount:0,loopMode:h.loopMode};v=h._interpolate(H,j),yD._SetInterpolatedValue(D,v,B,h,o,r,S,k,Q)}}U&&(K.max=U)}static _ConvertFactorToVector3OrQuaternion(D,h,o,j,M){const R=yD._GetBasePositionRotationOrScale(h,j,M),t=o.targetProperty.split("."),S=t?t[1]:"",k=M?H.Quaternion.Ih(R).normalize():H.Gh.Ih(R);switch(S){case"x":case"y":case"z":k[S]=D;break;case"w":k.w=D;break;default:g.Tools.Error(`glTFAnimation: Unsupported component name "${S}"!`)}return k}static _SetInterpolatedValue(D,h,o,g,j,M,R,t,S){let k;R.push(o),"weights"!==j?(g.dataType===sD.e.ANIMATIONTYPE_FLOAT&&(h=this._ConvertFactorToVector3OrQuaternion(h,D,g,j,S)),"rotation"===j?(S?M=h:(k=h,H.Quaternion.RotationYawPitchRollToRef(k.y,k.x,k.z,M)),t.push(M.Fh())):(k=h,t.push(k.Fh()))):t.push([h])}static _CreateLinearOrStepAnimation(D,h,o,H,g,j){for(const M of h.getKeys())H.push(M.frame/h.framePerSecond),yD._AddKeyframeValue(M,h,g,o,D,j)}static _CreateCubicSplineAnimation(D,h,o,H,g,j){h.getKeys().forEach((function(M){H.push(M.frame/h.framePerSecond),yD._AddSplineTangent(KD.INTANGENT,g,o,"CUBICSPLINE",M,j),yD._AddKeyframeValue(M,h,g,o,D,j),yD._AddSplineTangent(KD.OUTTANGENT,g,o,"CUBICSPLINE",M,j)}))}static _GetBasePositionRotationOrScale(D,h,o){let g;if("rotation"===h)if(o){g=(D.rotationQuaternion??H.Quaternion.Identity()).Fh()}else{g=(D.rotation??H.Gh.Zero()).Fh()}else if("translation"===h){g=(D.position??H.Gh.Zero()).Fh()}else{g=(D.Ug??H.Gh.One()).Fh()}return g}static _AddKeyframeValue(D,h,o,j,M,R){let t;const S=h.dataType;if(S===sD.e.ANIMATIONTYPE_VECTOR3){let h=D.value.Fh();if("rotation"===j){const D=H.Gh.Ih(h);h=H.Quaternion.RotationYawPitchRoll(D.y,D.x,D.z).Fh()}o.push(h)}else if(S===sD.e.ANIMATIONTYPE_FLOAT){if("weights"===j)o.push([D.value]);else if(t=this._ConvertFactorToVector3OrQuaternion(D.value,M,h,j,R),t){if("rotation"===j){const D=R?t:H.Quaternion.RotationYawPitchRoll(t.y,t.x,t.z).normalize();o.push(D.Fh())}o.push(t.Fh())}}else S===sD.e.ANIMATIONTYPE_QUATERNION?o.push(D.value.normalize().Fh()):g.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(D,h,o){let H,g,j=!1;if("rotation"===h&&!o)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let M=0,R=D.length;M<R;++M)if(g=D[M],g.inTangent||g.outTangent)if(H){if("CUBICSPLINE"!==H){H="LINEAR",j=!0;break}}else H="CUBICSPLINE";else if(H){if("CUBICSPLINE"===H||g.interpolation&&1===g.interpolation&&"STEP"!==H){H="LINEAR",j=!0;break}}else H=g.interpolation&&1===g.interpolation?"STEP":"LINEAR";return H||(H="LINEAR"),{interpolationType:H,shouldBakeAnimation:j}}static _AddSplineTangent(D,h,o,g,j,M){let R;const t=D===KD.INTANGENT?j.inTangent:j.outTangent;if("CUBICSPLINE"===g){if("rotation"===o)if(t)if(M)R=t.Fh();else{const D=t;R=H.Quaternion.RotationYawPitchRoll(D.y,D.x,D.z).Fh()}else R=[0,0,0,0];else R="weights"===o?t?[t]:[0]:t?t.Fh():[0,0,0];h.push(R)}}static _CalculateMinMaxKeyFrames(D){let h=1/0,o=-1/0;return D.forEach((function(D){h=Math.min(h,D.frame),o=Math.max(o,D.frame)})),{min:h,max:o}}}function bD(D,h,o,j,M,R){const t={attributes:{},influence:D.influence,name:D.name},S=h.mg;if(!S)return g.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),t;const K=R?-1:1,Q=H.Gh.Zero();let v=0,r=0;if(D.hasPositions){const j=D.getPositions(),R=S.getVerticesData(k.f.PositionKind);if(R){const D=new Float32Array(R.length),h=[1/0,1/0,1/0],g=[-1/0,-1/0,-1/0];r=R.length/3,v=0;for(let o=v;o<r;++o){const M=H.Gh.Ih(R,3*o);H.Gh.Ih(j,3*o).subtractToRef(M,Q),Q.x*=K,h[0]=Math.min(h[0],Q.x),g[0]=Math.max(g[0],Q.x),h[1]=Math.min(h[1],Q.y),g[1]=Math.max(g[1],Q.y),h[2]=Math.min(h[2],Q.z),g[2]=Math.max(g[2],Q.z),D[3*o]=Q.x,D[3*o+1]=Q.y,D[3*o+2]=Q.z}const S=o.createBufferView(D,12),k=o.createAccessor(S,"VEC3",5126,j.length/3,0,{min:h,max:g});M.push(k),t.attributes.POSITION=M.length-1}else g.Tools.Warn(`Morph target positions for mesh ${h.name} were not exported. Mesh does not have position vertex data`)}if(D.hasNormals){const j=D.getNormals(),R=S.getVerticesData(k.f.NormalKind);if(R){const D=new Float32Array(R.length);r=R.length/3,v=0;for(let o=v;o<r;++o){const h=H.Gh.Ih(R,3*o).normalize();H.Gh.Ih(j,3*o).normalize().subtractToRef(h,Q),D[3*o]=Q.x*K,D[3*o+1]=Q.y,D[3*o+2]=Q.z}const h=o.createBufferView(D,12),g=o.createAccessor(h,"VEC3",5126,j.length/3,0);M.push(g),t.attributes.NORMAL=M.length-1}else g.Tools.Warn(`Morph target normals for mesh ${h.name} were not exported. Mesh does not have normals vertex data`)}if(D.hasTangents){const j=D.getTangents(),R=S.getVerticesData(k.f.TangentKind);if(R){r=R.length/4;const D=new Float32Array(3*r);v=0;for(let o=v;o<r;++o){const h=H.Gh.Ih(R,4*o);X(h);const g=H.Gh.Ih(j,3*o);X(g),g.subtractToRef(h,Q),D[3*o]=Q.x*K,D[3*o+1]=Q.y,D[3*o+2]=Q.z}const h=o.createBufferView(D,12),g=o.createAccessor(h,"VEC3",5126,r,0);M.push(g),t.attributes.TANGENT=M.length-1}else g.Tools.Warn(`Morph target tangents for mesh ${h.name} were not exported. Mesh does not have tangents vertex data`)}if(D.hasColors){const j=D.getColors(),R=S.getVerticesData(k.f.ColorKind),K=S.getVertexBuffer(k.f.ColorKind);if(R&&K){const D=K.getSize();r=R.length/D;const h=new Float32Array(r*D);v=0;for(let o=v;o<r;++o)if(3===D){const g=H.Gh.Ih(R,o*D);H.Gh.Ih(j,o*D).subtractToRef(g,Q),h[3*o]=Q.x,h[3*o+1]=Q.y,h[3*o+2]=Q.z}else if(4===D){const g=new H.Vector4,M=H.Vector4.Ih(R,o*D);H.Vector4.Ih(j,o*D).subtractToRef(M,g),h[4*o]=g.x,h[4*o+1]=g.y,h[4*o+2]=g.z,h[4*o+3]=g.w}else g.Tools.Warn(`Unsupported number of components for color attribute: ${D}`);const S=o.createBufferView(h,4*D),k=o.createAccessor(S,3===D?"VEC3":"VEC4",5126,r,0);M.push(k),t.attributes.COLOR_0=M.length-1}else g.Tools.Warn(`Morph target colors for mesh ${h.name} were not exported. Mesh does not have colors vertex data`)}return t}var iD=o(13396),GD=o(13233),ND=o(13213),JD=o(12793);class OD{}OD.DEFAULT_COLOR=s.mo.White(),OD.DEFAULT_WIDTH_ATTENUATED=1,OD.DEFAULT_WIDTH=.1;var ED=o(13038),LD=o(13399);class TD{static ConvertPoints(D,h){if(D.length&&Array.isArray(D)&&"number"===typeof D[0])return[D];if(D.length&&Array.isArray(D[0])&&"number"===typeof D[0][0])return D;if(D.length&&!Array.isArray(D[0])&&D[0]instanceof H.Gh){const h=[];for(let o=0;o<D.length;o++){const H=D[o];h.push(H.x,H.y,H.z)}return[h]}if(D.length>0&&Array.isArray(D[0])&&D[0].length>0&&D[0][0]instanceof H.Gh){const h=[],o=D;for(const D of o)h.push(D.flatMap((D=>[D.x,D.y,D.z])));return h}if(D instanceof Float32Array){if(null!==h&&void 0!==h&&h.floatArrayStride){const o=[],H=3*h.floatArrayStride;for(let h=0;h<D.length;h+=H){const g=new Array(H);for(let o=0;o<H;o++)g[o]=D[h+o];o.push(g)}return o}return[Array.from(D)]}if(D.length&&D[0]instanceof Float32Array){const h=[];for(const o of D)h.push(Array.from(o));return h}return[]}static OmitZeroLengthPredicate(D,h,o){const H=[];return h.Nh(D).lengthSquared()>0&&H.push([D,h]),o.Nh(h).lengthSquared()>0&&H.push([h,o]),D.Nh(o).lengthSquared()>0&&H.push([o,D]),0===H.length?null:H}static OmitDuplicatesPredicate(D,h,o,H){const g=[];return TD._SearchInPoints(D,h,H)||g.push([D,h]),TD._SearchInPoints(h,o,H)||g.push([h,o]),TD._SearchInPoints(o,D,H)||g.push([o,D]),0===g.length?null:g}static _SearchInPoints(D,h,o){for(const M of o)for(let o=0;o<M.length;o++){var H,g,j;if(null!==(H=M[o])&&void 0!==H&&H.equals(D))if(null!==(g=M[o+1])&&void 0!==g&&g.equals(h)||null!==(j=M[o-1])&&void 0!==j&&j.equals(h))return!0}return!1}static MeshesToLines(D,h){const o=[];for(let g=0;g<D.length;g++){const j=D[g],M=j.getVerticesData(k.f.PositionKind),R=j.jg();if(M&&R)for(let D=0,t=0;D<R.length;D++){const S=3*R[t++],k=3*R[t++],K=3*R[t++],Q=new H.Gh(M[S],M[S+1],M[S+2]),v=new H.Gh(M[k],M[k+1],M[k+2]),r=new H.Gh(M[K],M[K+1],M[K+2]);if(h){const H=h(Q,v,r,o,D,S,j,g,M,R);if(H)for(const D of H)o.push(D)}else o.push([Q,v],[v,r],[r,Q])}}return o}static ToVector3Array(D){if(Array.isArray(D[0])){const h=[],o=D;for(const D of o){const o=[];for(let h=0;h<D.length;h+=3)o.push(new H.Gh(D[h],D[h+1],D[h+2]));h.push(o)}return h}const h=D,o=[];for(let g=0;g<h.length;g+=3)o.push(new H.Gh(h[g],h[g+1],h[g+2]));return o}static ToNumberArray(D){return D.flatMap((D=>[D.x,D.y,D.z]))}static GetPointsCountInfo(D){const h=new Array(D.length);let o=0;for(let H=D.length;H--;)h[H]=D[H].length/3,o+=h[H];return{total:o,counts:h}}static GetLineLength(D){if(0===D.length)return 0;let h;h="number"===typeof D[0]?TD.ToVector3Array(D):D;const o=H.TmpVectors.Gh[0];let g=0;for(let H=0;H<h.length-1;H++){const D=h[H];g+=h[H+1].subtractToRef(D,o).length()}return g}static GetLineLengthArray(D){const h=new Float32Array(D.length/3);let o=0;for(let H=0,g=D.length/3-1;H<g;H++){let g=D[3*H+0],j=D[3*H+1],M=D[3*H+2];g-=D[3*H+3],j-=D[3*H+4],M-=D[3*H+5];o+=Math.sqrt(g*g+j*j+M*M),h[H+1]=o}return h}static SegmentizeSegmentByCount(D,h,o){const g=[],j=h.Nh(D),M=H.TmpVectors.Gh[0];M.qg(o);const R=H.TmpVectors.Gh[1];j.divideToRef(M,R);let t=D.clone();g.push(t);for(let H=0;H<o;H++)t=t.clone(),g.push(t.addInPlace(R));return g}static SegmentizeLineBySegmentLength(D,h){const o=D[0]instanceof H.Gh?TD.GetLineSegments(D):"number"===typeof D[0]?TD.GetLineSegments(TD.ToVector3Array(D)):D,g=[];for(const H of o)if(H.length>h){const D=TD.SegmentizeSegmentByCount(H.point1,H.point2,Math.ceil(H.length/h));for(const h of D)g.push(h)}else g.push(H.point1),g.push(H.point2);return g}static SegmentizeLineBySegmentCount(D,h){const o="number"===typeof D[0]?TD.ToVector3Array(D):D,H=TD.GetLineLength(o)/h;return TD.SegmentizeLineBySegmentLength(o,H)}static GetLineSegments(D){const h=[];for(let o=0;o<D.length-1;o++){const H=D[o],g=D[o+1],j=g.Nh(H).length();h.push({point1:H,point2:g,length:j})}return h}static GetMinMaxSegmentLength(D){const h=TD.GetLineSegments(D).sort((D=>D.length));return{min:h[0].length,max:h[h.length-1].length}}static GetPositionOnLineByVisibility(D,h,o){let g=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const j=h*o;let M=0,R=0;const t=D.length;for(let H=0;H<t;H++){if(j<=M+D[H].length){R=H;break}M+=D[H].length}const S=(j-M)/D[R].length;return D[R].point2.subtractToRef(D[R].point1,H.TmpVectors.Gh[0]),H.TmpVectors.Gh[1]=H.TmpVectors.Gh[0].multiplyByFloats(S,S,S),g||H.TmpVectors.Gh[1].addInPlace(D[R].point1),H.TmpVectors.Gh[1].clone()}static GetCircleLinePoints(D,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:D,j=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/h;const M=[];for(let R=0;R<=h;R++)M.push(new H.Gh(Math.cos(R*j)*D,Math.sin(R*j)*g,o));return M}static GetBezierLinePoints(D,h,o,H){return ED.e.CreateQuadraticBezier(D,h,o,H).getPoints().flatMap((D=>[D.x,D.y,D.z]))}static GetArrowCap(D,h,o,H,g){let j=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,M=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[D.clone(),D.add(h.multiplyByFloats(o,o,o))],widths:[H,g,j,M]}}static GetPointsFromText(D,h,o,H){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,j=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const M=[],R=(0,LD.d)(D,h,o,H);for(const t of R){for(const D of t.paths){const h=[],o=D.getPoints();for(const D of o)h.push(D.x,D.y,g);M.push(h)}if(j)for(const D of t.holes){const h=[],o=D.getPoints();for(const D of o)h.push(D.x,D.y,g);M.push(h)}}return M}static Color3toRGBAUint8(D){const h=new Uint8Array(4*D.length);for(let o=0,H=0;o<D.length;o++)h[H++]=255*D[o].r,h[H++]=255*D[o].g,h[H++]=255*D[o].b,h[H++]=255;return h}static CreateColorsTexture(D,h,o,H){const g=H.getEngine().getCaps().maxTextureSize??1,j=h.length>g?g:h.length,M=Math.ceil(h.length/g);M>1&&(h=[...h,...Array(j*M-h.length).fill(h[0])]);const R=TD.Color3toRGBAUint8(h),t=new i.c(R,j,M,r.d.TEXTUREFORMAT_RGBA,H,!1,!0,o);return t.name=D,t}static PrepareEmptyColorsTexture(D){if(!OD.EmptyColorsTexture){const h=new Uint8Array(4);OD.EmptyColorsTexture=new i.c(h,1,1,r.d.TEXTUREFORMAT_RGBA,D,!1,!1,i.c.NEAREST_NEAREST),OD.EmptyColorsTexture.name="grlEmptyColorsTexture"}return OD.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var D;null===(D=OD.EmptyColorsTexture)||void 0===D||D.dispose(),OD.EmptyColorsTexture=null}static BooleanToNumber(D){return D?1:0}}class ZD extends ND.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class eD extends GD.c{isCompatible(D){return!0}constructor(D,h,o){var g;o=o||{color:OD.DEFAULT_COLOR};const j=new ZD;j.GREASED_LINE_HAS_COLOR=!!o.color&&!o.useColors,j.GREASED_LINE_SIZE_ATTENUATION=o.sizeAttenuation??!1,j.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===o.colorDistributionType,j.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(h??D.GD()).useRightHandedSystem,j.GREASED_LINE_CAMERA_FACING=o.cameraFacing??!0,super(D,eD.GREASED_LINE_MATERIAL_NAME,200,j,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(g=o)||void 0===g?void 0:g.forceGLSL)||eD.ForceGLSL,this._scene=h??D.GD(),this._engine=this._scene.getEngine(),this._cameraFacing=o.cameraFacing??!0,this.visibility=o.visibility??1,this.useDash=o.useDash??!1,this.dashRatio=o.dashRatio??.5,this.dashOffset=o.dashOffset??0,this.width=o.width?o.width:o.sizeAttenuation?OD.DEFAULT_WIDTH_ATTENUATED:OD.DEFAULT_WIDTH,this._sizeAttenuation=o.sizeAttenuation??!1,this.colorMode=o.colorMode??0,this._color=o.color??null,this.useColors=o.useColors??!1,this._colorsDistributionType=o.colorDistributionType??0,this.colorsSampling=o.colorsSampling??i.c.NEAREST_NEAREST,this._colors=o.ED??null,this.dashCount=o.dashCount??1,this.resolution=o.resolution??new H.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),o.colorsTexture?this.colorsTexture=o.colorsTexture:this._colors?this.colorsTexture=TD.CreateColorsTexture(`${D.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??OD.DEFAULT_COLOR,TD.PrepareEmptyColorsTexture(this._scene)),this._engine.Jh.add((()=>{TD.DisposeEmptyColorsTexture()}))}getAttributes(D){D.push("grl_offsets"),D.push("grl_widths"),D.push("grl_colorPointers"),D.push("grl_counters"),this._cameraFacing?(D.push("grl_previousAndSide"),D.push("grl_nextAndCounters")):D.push("grl_slopes")}getSamplers(D){D.push("grl_colors")}getActiveTextures(D){this.colorsTexture&&D.push(this.colorsTexture)}getUniforms(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const h=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&h.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===D&&h.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:h,vertex:this._cameraFacing&&this._isGLSL(D)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(D)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(D){if(this._cameraFacing){D.Wh("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||D.Wh("viewProjection",this._scene.getTransformMatrix());const h=H.TmpVectors.Vector4[0];h.x=this._aspect,h.y=this._resolution.x,h.z=this._resolution.y,h.w=this.width,D.updateVector4("grl_aspect_resolution_lineWidth",h)}const h=H.TmpVectors.Vector4[0];h.x=TD.BooleanToNumber(this.useDash),h.y=this._dashArray,h.z=this.dashOffset,h.w=this.dashRatio,D.updateVector4("grl_dashOptions",h);const o=H.TmpVectors.Vector4[1];o.x=this.colorMode,o.y=this.visibility,o.z=this.colorsTexture?this.colorsTexture.getSize().width:0,o.w=TD.BooleanToNumber(this.useColors),D.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",o),this._color&&D.updateColor3("grl_singleColor",this._color);const g=this.colorsTexture??OD.EmptyColorsTexture;D.setTexture("grl_colors",g),D.updateFloat2("grl_textureSize",(null===g||void 0===g?void 0:g.getSize().width)??1,(null===g||void 0===g?void 0:g.getSize().height)??1)}prepareDefines(D,h,o){D.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,D.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,D.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,D.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=h.useRightHandedSystem,D.GREASED_LINE_CAMERA_FACING=this._cameraFacing,D.GREASED_LINE_USE_OFFSETS=!!o.offsets}getClassName(){return eD.GREASED_LINE_MATERIAL_NAME}getCustomCode(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(h)?function(D,h){if("vertex"===D){const D={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return h&&(D["!gl_Position\\=viewProjection\\*worldPos;"]="//"),D}return"fragment"===D?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(D,this._cameraFacing):function(D,h){if("vertex"===D){const D={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return h&&(D["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),D}return"fragment"===D?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(D,this._cameraFacing)}dispose(){var D;null===(D=this.colorsTexture)||void 0===D||D.dispose(),super.dispose()}get ED(){return this._colors}set ED(D){this.setColors(D)}setColors(D){var h;let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const g=(null===(h=this._colors)||void 0===h?void 0:h.length)??0;var j;if(this._colors=D,null!==D&&0!==D.length){if(!o||H)if(this.colorsTexture&&g===D.length&&!H){const h=TD.Color3toRGBAUint8(D);this.colorsTexture.update(h)}else{var M;null===(M=this.colorsTexture)||void 0===M||M.dispose(),this.colorsTexture=TD.CreateColorsTexture(`${this._material.name}-colors-texture`,D,this.colorsSampling,this._scene)}}else null===(j=this.colorsTexture)||void 0===j||j.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(D){this._dashCount=D,this._dashArray=1/D}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(D){this._sizeAttenuation=D,this.markAllDefinesAsDirty()}get color(){return this._color}set color(D){this.setColor(D)}setColor(D){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==D||null!==this._color&&null===D?(this._color=D,h||this.markAllDefinesAsDirty()):this._color=D}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(D){this._colorsDistributionType=D,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(D){this._aspect=D.x/D.y,this._resolution=D}serialize(){const D=super.serialize(),h={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(h.ED=this._colors),this._color&&(h.color=this._color),D.greasedLineMaterialOptions=h,D}parse(D,h,o){var H;super.parse(D,h,o);const g=D.greasedLineMaterialOptions;null===(H=this.colorsTexture)||void 0===H||H.dispose(),g.color&&this.setColor(g.color,!0),g.colorDistributionType&&(this.colorsDistributionType=g.colorDistributionType),g.ED&&(this.ED=g.ED),g.colorsSampling&&(this.colorsSampling=g.colorsSampling),g.colorMode&&(this.colorMode=g.colorMode),g.useColors&&(this.useColors=g.useColors),g.visibility&&(this.visibility=g.visibility),g.useDash&&(this.useDash=g.useDash),g.dashCount&&(this.dashCount=g.dashCount),g.dashRatio&&(this.dashRatio=g.dashRatio),g.dashOffset&&(this.dashOffset=g.dashOffset),g.width&&(this.width=g.width),g.sizeAttenuation&&(this.sizeAttenuation=g.sizeAttenuation),g.resolution&&(this.resolution=g.resolution),this.ED?this.colorsTexture=TD.CreateColorsTexture(`${this._material.name}-colors-texture`,this.ED,this.colorsSampling,h):TD.PrepareEmptyColorsTexture(h),this.markAllDefinesAsDirty()}copyTo(D){var h;const o=D;null===(h=o.colorsTexture)||void 0===h||h.dispose(),this._colors&&(o.colorsTexture=TD.CreateColorsTexture(`${o._material.name}-colors-texture`,this._colors,o.colorsSampling,this._scene)),o.setColor(this.color,!0),o.colorsDistributionType=this.colorsDistributionType,o.colorsSampling=this.colorsSampling,o.colorMode=this.colorMode,o.useColors=this.useColors,o.visibility=this.visibility,o.useDash=this.useDash,o.dashCount=this.dashCount,o.dashRatio=this.dashRatio,o.dashOffset=this.dashOffset,o.width=this.width,o.sizeAttenuation=this.sizeAttenuation,o.resolution=this.resolution,o.markAllDefinesAsDirty()}_isGLSL(D){return 0===D||this._forceGLSL}}eD.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",eD.ForceGLSL=!1,(0,JD.g)(`BABYLON.${eD.GREASED_LINE_MATERIAL_NAME}`,eD);var pD=o(13273),mh=o(12664),aD=o(13056),uD=o(12778);class ID extends aD.ShaderMaterial{constructor(D,h,g){const j=h.getEngine(),M=j.isWebGPU&&!(g.forceGLSL||ID.ForceGLSL),R=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];h.useRightHandedSystem&&R.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const t=["position","grl_widths","grl_offsets","grl_colorPointers"];g.cameraFacing?(R.push("GREASED_LINE_CAMERA_FACING"),t.push("grl_previousAndSide","grl_nextAndCounters")):(t.push("grl_slopes"),t.push("grl_counters"));const S=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(M||S.push("world","viewProjection","view","projection"),super(D,h,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:M?["Scene","Mesh"]:void 0,attributes:t,uniforms:S,samplers:M?[]:["grlColors"],defines:R,extraInitializationsAsync:async()=>{M?await Promise.all([o.e(66).then(o.bind(o,15810)),o.e(75).then(o.bind(o,15813))]):await Promise.all([o.e(69).then(o.bind(o,15819)),o.e(76).then(o.bind(o,15826))])},shaderLanguage:M?1:0}),this._color=s.mo.White(),this._colorsDistributionType=0,this._colorsTexture=null,g=g||{color:OD.DEFAULT_COLOR},this.visibility=g.visibility??1,this.useDash=g.useDash??!1,this.dashRatio=g.dashRatio??.5,this.dashOffset=g.dashOffset??0,this.dashCount=g.dashCount??1,this.width=g.width?g.width:g.sizeAttenuation&&g.cameraFacing?OD.DEFAULT_WIDTH_ATTENUATED:OD.DEFAULT_WIDTH,this.sizeAttenuation=g.sizeAttenuation??!1,this.color=g.color??s.mo.White(),this.useColors=g.useColors??!1,this.colorsDistributionType=g.colorDistributionType??0,this.colorsSampling=g.colorsSampling??i.c.NEAREST_NEAREST,this.colorMode=g.colorMode??0,this._colors=g.ED??null,this._cameraFacing=g.cameraFacing??!0,this.resolution=g.resolution??new H.Vector2(j.getRenderWidth(),j.getRenderHeight()),g.colorsTexture?this.colorsTexture=g.colorsTexture:this._colors?this.colorsTexture=TD.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,h):(this._color=this._color??OD.DEFAULT_COLOR,this.colorsTexture=TD.PrepareEmptyColorsTexture(h)),M){const D=new uD.e;D.setParameters(),D.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",D)}j.Jh.add((()=>{TD.DisposeEmptyColorsTexture()}))}dispose(){var D;null===(D=this._colorsTexture)||void 0===D||D.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new H.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get ED(){return this._colors}set ED(D){this.setColors(D)}setColors(D){var h;let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const g=(null===(h=this._colors)||void 0===h?void 0:h.length)??0;var j;if(this._colors=D,null!==D&&0!==D.length){if(!o||H)if(this._colorsTexture&&g===D.length&&!H){const h=TD.Color3toRGBAUint8(D);this._colorsTexture.update(h)}else{var M;null===(M=this._colorsTexture)||void 0===M||M.dispose(),this.colorsTexture=TD.CreateColorsTexture(`${this.name}-colors-texture`,D,this.colorsSampling,this.GD())}}else null===(j=this._colorsTexture)||void 0===j||j.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(D){this._colorsTexture=D,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(D){this._width=D,this.setFloat("grlWidth",D)}get useColors(){return this._useColors}set useColors(D){this._useColors=D,this.setFloat("grlUseColors",TD.BooleanToNumber(D))}get colorsSampling(){return this._colorsSampling}set colorsSampling(D){this._colorsSampling=D}get visibility(){return this._visibility}set visibility(D){this._visibility=D,this.setFloat("grlVisibility",D)}get useDash(){return this._useDash}set useDash(D){this._useDash=D,this.setFloat("grlUseDash",TD.BooleanToNumber(D))}get dashOffset(){return this._dashOffset}set dashOffset(D){this._dashOffset=D,this.setFloat("grlDashOffset",D)}get dashRatio(){return this._dashRatio}set dashRatio(D){this._dashRatio=D,this.setFloat("grlDashRatio",D)}get dashCount(){return this._dashCount}set dashCount(D){this._dashCount=D,this._dashArray=1/D,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(D){this._sizeAttenuation=D,this.setFloat("grlSizeAttenuation",TD.BooleanToNumber(D))}get color(){return this._color}set color(D){this.setColor(D)}setColor(D){D=D??OD.DEFAULT_COLOR,this._color=D,this.setColor3("grlColor",D)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(D){this._colorsDistributionType=D,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(D){this._colorMode=D,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(D){this._resolution=D,this.setVector2("grlResolution",D),this.setFloat("grlAspect",D.x/D.y)}serialize(){const D=super.serialize(),h={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(h.ED=this._colors),D.greasedLineMaterialOptions=h,D}parse(D,h,o){var H;const g=D.greasedLineMaterialOptions;null===(H=this._colorsTexture)||void 0===H||H.dispose(),g.color&&(this.color=g.color),g.colorDistributionType&&(this.colorsDistributionType=g.colorDistributionType),g.colorsSampling&&(this.colorsSampling=g.colorsSampling),g.colorMode&&(this.colorMode=g.colorMode),g.useColors&&(this.useColors=g.useColors),g.visibility&&(this.visibility=g.visibility),g.useDash&&(this.useDash=g.useDash),g.dashCount&&(this.dashCount=g.dashCount),g.dashRatio&&(this.dashRatio=g.dashRatio),g.dashOffset&&(this.dashOffset=g.dashOffset),g.width&&(this.width=g.width),g.sizeAttenuation&&(this.sizeAttenuation=g.sizeAttenuation),g.resolution&&(this.resolution=g.resolution),g.ED?this.colorsTexture=TD.CreateColorsTexture(`${this.name}-colors-texture`,g.ED,this.colorsSampling,this.GD()):this.colorsTexture=TD.PrepareEmptyColorsTexture(h),this._cameraFacing=g.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var PD,nD,FD;ID.ForceGLSL=!1,function(D){D[D.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",D[D.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(PD||(PD={})),function(D){D[D.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",D[D.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",D[D.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(nD||(nD={})),function(D){D[D.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",D[D.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",D[D.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",D[D.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",D[D.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(FD||(FD={}));class wD extends qD.d{constructor(D,h,o){super(D,h,null,null,!1,!1),this.name=D,this._options=o,this._lazy=!1,this._updatable=!1,this._engine=h.getEngine(),this._lazy=o.lazy??!1,this._updatable=o.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=o.colorPointers??[],this._widths=o.widths??new Array(o.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(D){let h=0;for(const H of this._points)h+=H.length;const o=h/3*2-this._widths.length;for(let H=0;H<o;H++)this._widths.push(D)}updateLazy(){var D,h;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(D=this._options.ribbonOptions)||void 0===D?void 0:D.smoothShading),!this.eD&&this.refreshBoundingInfo(),null===(h=this.greasedLineMaterial)||void 0===h||h.updateLazy()}addPoints(D,h){for(const o of D)this._points.push(o);this._lazy||this.setPoints(this._points,h)}dispose(D){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(D,h)}isLazy(){return this._lazy}get LD(){return this._uvs}set LD(D){this._uvs=D instanceof Float32Array?D:new Float32Array(D),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(D){this.material instanceof ID&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===D||void 0===D?void 0:D.length)>0),this._offsets=D,this._offsetsBuffer?this._offsetsBuffer.update(D):this._createOffsetsBuffer(D)}get widths(){return this._widths}set widths(D){this._widths=D,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(D)}get colorPointers(){return this._colorPointers}set colorPointers(D){this._colorPointers=D,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(D)}get greasedLineMaterial(){var D,h;if(this.material&&this.material instanceof ID)return this.material;const o=null===(D=this.material)||void 0===D||null===(h=D.pluginManager)||void 0===h?void 0:h.getPlugin(eD.GREASED_LINE_MATERIAL_NAME);return o||void 0}get points(){const D=[];return mh.d.DeepCopy(this._points,D),D}setPoints(D,h){this._points=TD.ConvertPoints(D,(null===h||void 0===h?void 0:h.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==h&&void 0!==h&&h.colorPointers||this._updateColorPointers(),this._setPoints(this._points,h)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,LD:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(D){super.serialize(D),D.type=this.getClassName(),D.lineOptions=this._createLineOptions()}_createVertexBuffers(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new pD.d;return h.JD=this._vertexPositions,h.indices=this._indices,h.LD=this._uvs,D&&(h.OD=[],pD.d.ComputeNormals(this._vertexPositions,this._indices,h.OD)),h.ZD(this,this._options.updatable),h}_createOffsetsBuffer(D){const h=this._scene.getEngine(),o=new k.d(h,D,this._updatable,3);this.setVerticesBuffer(o.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=o}}class YD{constructor(D,h){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=D,this.wasAddedByNoopNode=h}getIndicesAccessor(D,h,o,H,g){var j,M,R,t;return null===(j=this._indicesAccessorMap.get(D))||void 0===j||null===(M=j.get(h))||void 0===M||null===(R=M.get(o))||void 0===R||null===(t=R.get(H))||void 0===t?void 0:t.get(g)}setIndicesAccessor(D,h,o,H,g,j){let M=this._indicesAccessorMap.get(D);M||(M=new Map,this._indicesAccessorMap.set(D,M));let R=M.get(h);R||(R=new Map,M.set(h,R));let t=R.get(o);t||(t=new Map,R.set(o,t));let S=t.get(H);S||(S=new Map,t.set(H,S)),S.set(g,j)}pushExportedNode(D){this._exportedNodes.has(D)||this._exportedNodes.add(D)}getNodesSet(){return this._exportedNodes}getVertexBufferView(D){return this._vertexBufferViewMap.get(D)}setVertexBufferView(D,h){this._vertexBufferViewMap.set(D,h)}setRemappedBufferView(D,h,o){this._remappedBufferView.set(D,new Map),this._remappedBufferView.get(D).set(h,o)}getRemappedBufferView(D,h){var o;return null===(o=this._remappedBufferView.get(D))||void 0===o?void 0:o.get(h)}getVertexAccessor(D,h,o){var H,g;return null===(H=this._vertexAccessorMap.get(D))||void 0===H||null===(g=H.get(h))||void 0===g?void 0:g.get(o)}setVertexAccessor(D,h,o,H){let g=this._vertexAccessorMap.get(D);g||(g=new Map,this._vertexAccessorMap.set(D,g));let j=g.get(h);j||(j=new Map,g.set(h,j)),j.set(o,H)}hasVertexColorAlpha(D){return this._vertexMapColorAlpha.get(D)||!1}setHasVertexColorAlpha(D,h){return this._vertexMapColorAlpha.set(D,h)}getMesh(D){return this._meshMap.get(D)}setMesh(D,h){this._meshMap.set(D,h)}bindMorphDataToMesh(D,h){const o=this._meshMorphTargetMap.get(D)||[];this._meshMorphTargetMap.set(D,o),-1===o.indexOf(h)&&o.push(h)}getMorphTargetsFromMesh(D){return this._meshMorphTargetMap.get(D)}}class lD{_ApplyExtension(D,h,o,H){if(o>=h.length)return Promise.resolve(D);const g=H(h[o],D);return g?g.then((async D=>D?await this._ApplyExtension(D,h,o+1,H):null)):this._ApplyExtension(D,h,o+1,H)}_ApplyExtensions(D,h){const o=[];for(const H of lD._ExtensionNames)o.push(this._extensions[H]);return this._ApplyExtension(D,o,0,h)}_extensionsPreExportTextureAsync(D,h,o){return this._ApplyExtensions(h,((h,H)=>h.preExportTextureAsync&&h.preExportTextureAsync(D,H,o)))}_extensionsPostExportNodeAsync(D,h,o,H,g){return this._ApplyExtensions(h,((h,j)=>h.postExportNodeAsync&&h.postExportNodeAsync(D,j,o,H,g,this._bufferManager)))}_extensionsPostExportMaterialAsync(D,h,o){return this._ApplyExtensions(h,((h,H)=>h.postExportMaterialAsync&&h.postExportMaterialAsync(D,H,o)))}_extensionsPostExportMaterialAdditionalTextures(D,h,o){const H=[];for(const g of lD._ExtensionNames){const j=this._extensions[g];j.postExportMaterialAdditionalTextures&&H.push(...j.postExportMaterialAdditionalTextures(D,h,o))}return H}_extensionsPostExportTextures(D,h,o){for(const H of lD._ExtensionNames){const g=this._extensions[H];g.postExportTexture&&g.postExportTexture(D,h,o)}}_extensionsPostExportMeshPrimitive(D){for(const h of lD._ExtensionNames){const o=this._extensions[h];o.postExportMeshPrimitive&&o.postExportMeshPrimitive(D,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const D of lD._ExtensionNames){const h=this._extensions[D];h.preGenerateBinaryAsync&&await h.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(D){for(const h of lD._ExtensionNames){const o=this._extensions[h];o.enabled&&D(o)}}_extensionsOnExporting(){this._forEachExtensions((D=>{var h,o,H;D.wasUsed&&((h=this._glTF).extensionsUsed||(h.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(D.name)&&this._glTF.extensionsUsed.push(D.name),D.required&&((o=this._glTF).extensionsRequired||(o.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(D.name)&&this._glTF.extensionsRequired.push(D.name)),(H=this._glTF).extensions||(H.extensions={}),D.onExporting&&D.onExporting())}))}_loadExtensions(){for(const D of lD._ExtensionNames){const h=lD._ExtensionFactories[D](this);this._extensions[D]=h}}constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:B.d.LastCreatedScene,h=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${r.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new u(this),this._extensions={},this._bufferManager=new kD,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!D)throw new Error("No scene available to export");this._babylonScene=D,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:D=>{var h;return null===D||void 0===D||null===(h=D.eh)||void 0===h?void 0:h.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...h},this._loadExtensions()}dispose(){for(const D in this._extensions){this._extensions[D].dispose()}}get options(){return this._options}static RegisterExtension(D,h){lD.UnregisterExtension(D)&&g.Tools.Warn(`Extension with the name ${D} already exists`),lD._ExtensionFactories[D]=h,lD._ExtensionNames.push(D)}static UnregisterExtension(D){if(!lD._ExtensionFactories[D])return!1;delete lD._ExtensionFactories[D];const h=lD._ExtensionNames.indexOf(D);return-1!==h&&lD._ExtensionNames.splice(h,1),!0}_generateJSON(D,h,o){const H={byteLength:D};return H.byteLength&&(this._glTF.buffers=[H]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Th=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(H.uri=h+".bin"),o?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(D){const h=await this._generateBinaryAsync();this._extensionsOnExporting();const o=this._generateJSON(h.byteLength,D,!0),H=new Blob([h],{type:"application/octet-stream"}),g=D+".gltf",j=D+".bin",M=new S;if(M.files[g]=o,M.files[j]=H,this._imageData)for(const R in this._imageData)M.files[R]=new Blob([this._imageData[R].data],{type:this._imageData[R].mimeType});return M}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(D){const h=D%4;return 0===h?h:4-h}async generateGLBAsync(D){this._shouldUseGlb=!0;const h=await this._generateBinaryAsync();this._extensionsOnExporting();const o=this._generateJSON(h.byteLength),H=D+".glb";let g,j=o.length;if("undefined"!==typeof TextEncoder){g=(new TextEncoder).encode(o),j=g.length}const M=this._getPadding(j),R=this._getPadding(h.byteLength),t=28+j+M+h.byteLength+R,k=new tD(t);if(k.writeUInt32(1179937895),k.writeUInt32(2),k.writeUInt32(t),k.writeUInt32(j+M),k.writeUInt32(1313821514),g)k.writeTypedArray(g);else{const D="_".charCodeAt(0);for(let h=0;h<j;++h){const H=o.charCodeAt(h);H!=o.codePointAt(h)?k.writeUInt8(D):k.writeUInt8(H)}}for(let S=0;S<M;++S)k.writeUInt8(32);k.writeUInt32(h.byteLength+R),k.writeUInt32(5130562),k.writeTypedArray(h);for(let S=0;S<R;++S)k.writeUInt8(0);const K=new S;return K.files[H]=new Blob([k.getOutputData()],{type:"application/octet-stream"}),K}_setNodeTransformation(D,h,o){if(h.getPivotPoint().equalsWithEpsilon(w,F.d)||g.Tools.Warn("Pivot points are not supported in the glTF serializer"),!h.position.equalsWithEpsilon(w,F.d)){const g=H.TmpVectors.Gh[0].M(h.position);o&&A(g),D.translation=g.Fh()}h.Ug.equalsWithEpsilon(l,F.d)||(D.scale=h.Ug.Fh());const j=h.rotationQuaternion||H.Quaternion.FromEulerAngles(h.rotation.x,h.rotation.y,h.rotation.z);j.equalsWithEpsilon(Y,F.d)||(o&&W(j),D.rotation=j.normalize().Fh())}_setCameraTransformation(D,h,o){if(!h.position.equalsWithEpsilon(w,F.d)){const g=H.TmpVectors.Gh[0].M(h.position);o&&A(g),D.translation=g.Fh()}const g=h.rotationQuaternion||H.Quaternion.FromEulerAngles(h.rotation.x,h.rotation.y,h.rotation.z);o&&W(g),this._babylonScene.useRightHandedSystem||x(g),g.equalsWithEpsilon(Y,F.d)||(D.rotation=g.Fh())}_listAvailableCameras(){for(const D of this._babylonScene.cameras){const h={type:D.mode===QD.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(D.name&&(h.name=D.name),"perspective"===h.type)h.perspective={aspectRatio:D.getEngine().getAspectRatio(D),yfov:D.fovMode===QD.b.FOVMODE_VERTICAL_FIXED?D.fov:D.fov*D.getEngine().getAspectRatio(D),znear:D.Xh,zfar:D.maxZ};else if("orthographic"===h.type){const o=D.orthoLeft&&D.orthoRight?.5*(D.orthoRight-D.orthoLeft):.5*D.getEngine().getRenderWidth(),H=D.orthoBottom&&D.orthoTop?.5*(D.orthoTop-D.orthoBottom):.5*D.getEngine().getRenderHeight();h.orthographic={xmag:o,ymag:H,znear:D.Xh,zfar:D.maxZ}}this._camerasMap.set(D,h)}}_exportAndAssignCameras(){const D=Array.from(this._camerasMap.values());for(const h of D){const D=this._nodesCameraMap.get(h);if(void 0!==D){this._cameras.push(h);for(const h of D)h.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const D of this._babylonScene.skeletons){if(D.bones.length<=0)continue;const h={joints:[]};this._skinMap.set(D,h)}}_exportAndAssignSkeletons(){for(const D of this._babylonScene.skeletons){if(D.bones.length<=0)continue;const h=this._skinMap.get(D);if(void 0==h)continue;const o={},H=[];let j=-1;for(let g=0;g<D.bones.length;++g){const h=D.bones[g],H=h.getIndex()??g;-1!==H&&(o[H]=h,H>j&&(j=H))}for(let D=0;D<=j;++D){const j=o[D];H.push(j.getAbsoluteInverseBindMatrix());const M=j.getTransformNode();if(null!==M){const D=this._nodeMap.get(M);M&&null!==D&&void 0!==D?h.joints.push(D):g.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else g.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const M=this._nodesSkinMap.get(h);if(h.joints.length>0&&void 0!==M){const D=64*H.length,o=new Float32Array(D/4);H.forEach(((D,h)=>{o.set(D.m,16*h)}));const g=this._bufferManager.createBufferView(o);this._accessors.push(this._bufferManager.createAccessor(g,"MAT4",5126,H.length)),h.inverseBindMatrices=this._accessors.length-1,this._skins.push(h);for(const h of M)h.skin=this._skins.length-1}}}async _exportSceneAsync(){const D={nodes:[]};if(this._babylonScene.metadata){const h=this._options.metadataSelector(this._babylonScene.metadata);h&&(D.extras=h)}const h=new Array,o=new Array,H=new Array;for(const R of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&MD(R,this._babylonScene.useRightHandedSystem)?H.push(...R.getChildren()):this._babylonScene.useRightHandedSystem?h.push(R):o.push(R);this._listAvailableCameras(),this._listAvailableSkeletons();const g=new YD(!0,!1);D.nodes.push(...await this._exportNodesAsync(o,g));const j=new YD(!1,!1);D.nodes.push(...await this._exportNodesAsync(h,j));const M=new YD(!1,!0);D.nodes.push(...await this._exportNodesAsync(H,M)),D.nodes.length&&this._scenes.push(D),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&yD._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,g.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(D){let h=this._shouldExportNodeMap.get(D);return void 0===h&&(h=this._options.shouldExportNode(D),this._shouldExportNodeMap.set(D,h)),h}async _exportNodesAsync(D,h){const o=new Array;this._exportBuffers(D,h);for(const H of D)await this._exportNodeAsync(H,o,h);return o}_collectBuffers(D,h,o,H,g){if(this._shouldExportNode(D)&&D instanceof Q.e&&D.mg){const j=D.mg.getVertexBuffers();if(j)for(const H in j){if(!V(H))continue;const M=j[H];g.setHasVertexColorAlpha(M,D.hasVertexAlpha);const R=M._buffer,t=h.get(R)||[];h.set(R,t),-1===t.indexOf(M)&&t.push(M);const S=o.get(M)||[];o.set(M,S),-1===S.indexOf(D)&&S.push(D)}const M=D.morphTargetManager;if(M)for(let h=0;h<M.numTargets;h++){const o=M.getTarget(h),g=H.get(o)||[];H.set(o,g),-1===g.indexOf(D)&&g.push(D)}}for(const j of D.getChildren())this._collectBuffers(j,h,o,H,g)}_exportBuffers(D,h){const o=new Map,H=new Map,g=new Map;for(const R of D)this._collectBuffers(R,o,H,g,h);const j=Array.from(o.keys());for(const R of j){const D=R.getData();if(!D)throw new Error("Buffer data is not available");const g=o.get(R);if(!g)continue;const j=g[0].byteStride;if(g.some((D=>D.byteStride!==j)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const M=oD(D).slice();for(const h of g){const D=H.get(h),{byteOffset:o,byteStride:g,componentCount:j,type:R,count:t,normalized:S,kind:K}=z(h,D);switch(K){case k.f.NormalKind:case k.f.TangentKind:(0,I.j)(M,o,g,j,R,t,S,(D=>{const h=Math.sqrt(D[0]*D[0]+D[1]*D[1]+D[2]*D[2]);if(h>0){const o=1/h;D[0]*=o,D[1]*=o,D[2]*=o}}));break;case k.f.ColorKind:{const h=D.filter((D=>D.material instanceof BD.Zh||null==D.material)).length;if(0==h)break;if(h!=D.length){P.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}R==k.f.UNSIGNED_BYTE&&P.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const H=new s.mo,K=new s.yg,Q=this._babylonScene.getEngine().useExactSrgbConversions;(0,I.j)(M,o,g,j,R,t,S,(D=>{3===D.length?(H.lo(D,0),H.toLinearSpaceToRef(H,Q),H.toArray(D,0)):(K.lo(D,0),K.toLinearSpaceToRef(K,Q),K.toArray(D,0))}))}}}if(h.convertToRightHanded){for(const D of g){const h=H.get(D),{byteOffset:o,byteStride:g,componentCount:j,type:R,count:t,normalized:S,kind:K}=z(D,h);switch(K){case k.f.PositionKind:case k.f.NormalKind:case k.f.TangentKind:(0,I.j)(M,o,g,j,R,t,S,(D=>{D[0]=-D[0]}))}}h.convertedToRightHandedBuffers.set(R,M)}const t=this._bufferManager.createBufferView(M,j);h.setVertexBufferView(R,t);const S=new Map;for(const h of g){const D=H.get(h),{kind:o,totalVertices:g}=z(h,D);switch(o){case k.f.MatricesIndicesKind:case k.f.MatricesIndicesExtraKind:if(h.type==k.f.FLOAT){const D=h.getFloatData(g);null!==D&&S.set(h,D)}}}0!==S.size&&P.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const K=Array.from(S.keys());for(const o of K){const D=S.get(o);if(!D)continue;const H=D.some((D=>D>=256)),g=new(H?Uint16Array:Uint8Array)(D.length);for(let h=0;h<D.length;h++)g[h]=D[h];const j=this._bufferManager.createBufferView(g,4*(H?2:1));h.setRemappedBufferView(R,o,j)}}const M=Array.from(g.keys());for(const R of M){const D=g.get(R);if(!D)continue;const o=bD(R,D[0],this._bufferManager,this._bufferViews,this._accessors,h.convertToRightHanded);for(const H of D)h.bindMorphDataToMesh(H,o)}}async _exportNodeAsync(D,h,o){let H=this._nodeMap.get(D);if(void 0!==H)return void(h.includes(H)||h.push(H));const g=await this._createNodeAsync(D,o);if(g){H=this._nodes.length,this._nodes.push(g),this._nodeMap.set(D,H),o.pushExportedNode(D),h.push(H);const j={name:"runtime animations",channels:[],samplers:[]},M=[];this._babylonScene.animationGroups.length||(yD._CreateMorphTargetAnimationFromMorphTargetAnimations(D,j,M,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,o.convertToRightHanded,this._options.shouldExportAnimation),D.animations.length&&yD._CreateNodeAnimationFromNodeAnimations(D,j,M,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,o.convertToRightHanded,this._options.shouldExportAnimation)),j.channels.length&&j.samplers.length&&this._animations.push(j),M.forEach((D=>{D.channels.length&&D.samplers.length&&this._animations.push(D)}))}const j=g?[]:h;for(const M of D.getChildren())await this._exportNodeAsync(M,j,o);g&&j.length&&(g.children=j)}async _createNodeAsync(D,h){if(!this._shouldExportNode(D))return null;const o={};if(D.name&&(o.name=D.name),D.metadata){const h=this._options.metadataSelector(D.metadata);h&&(o.extras=h)}if(D instanceof K.c&&(this._setNodeTransformation(o,D,h.convertToRightHanded),D instanceof Q.e)){const g=D instanceof v.e?D.sourceMesh:D;if(g.nh&&g.nh.length>0&&(o.mesh=await this._exportMeshAsync(g,h)),D.skeleton){const h=this._skinMap.get(D.skeleton);var H;if(void 0!==h)void 0===this._nodesSkinMap.get(h)&&this._nodesSkinMap.set(h,[]),null===(H=this._nodesSkinMap.get(h))||void 0===H||H.push(o)}}if(D instanceof n.b){const H=this._camerasMap.get(D);if(H){var g;void 0===this._nodesCameraMap.get(H)&&this._nodesCameraMap.set(H,[]),this._setCameraTransformation(o,D,h.convertToRightHanded);const M=D.parent;if(null!==M&&hD(D,M)){const D=this._nodeMap.get(M);if(void 0!==D){var j;const h=this._nodes[D];return DD(o,h),null===(j=this._nodesCameraMap.get(H))||void 0===j||j.push(h),null}}null===(g=this._nodesCameraMap.get(H))||void 0===g||g.push(o)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",o,D,this._nodeMap,h.convertToRightHanded)?o:(P.d.Warn(`Not exporting node ${D.name}`),null)}_exportIndices(D,h,o,H,g,M,R,t,S){let k=D;S.mode=d(M);const K=R!==j.c.CounterClockWiseSideOrientation,Q=!t.wasAddedByNoopNode&&K,v=function(D){switch(D){case j.c.TriangleFillMode:case j.c.TriangleStripDrawMode:case j.c.TriangleFanDrawMode:return!0}return!1}(M)&&Q;if(v){if(M===j.c.TriangleStripDrawMode||M===j.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");S.mode=d(M);const R=h?new Uint32Array(H):new Uint16Array(H);if(D)for(let h=0;h+2<H;h+=3)R[h]=D[o+h]+g,R[h+1]=D[o+h+2]+g,R[h+2]=D[o+h+1]+g;else for(let D=0;D+2<H;D+=3)R[D]=D,R[D+1]=D+2,R[D+2]=D+1;k=R}else if(D&&0!==g){const j=h?new Uint32Array(H):new Uint16Array(H);for(let h=0;h<H;h++)j[h]=D[o+h]+g;k=j}if(k){let j=t.getIndicesAccessor(D,o,H,g,v);if(void 0===j){const M=function(D,h,o,H){if(D instanceof Uint16Array||D instanceof Uint32Array)return D;if(D instanceof Int32Array)return new Uint32Array(D.buffer,D.byteOffset,D.length);const g=D.slice(h,h+o);return H?new Uint32Array(g):new Uint16Array(g)}(k,0,H,h),R=this._bufferManager.createBufferView(M),S=h?5125:5123;this._accessors.push(this._bufferManager.createAccessor(R,"SCALAR",S,H,0)),j=this._accessors.length-1,t.setIndicesAccessor(D,o,H,g,v,j)}S.indices=j}}_exportVertexBuffer(D,h,o,H,g,j){const M=D.getKind();if(!V(M))return;if(M.startsWith("uv")&&!this._options.exportUnusedUVs&&(!h||!this._materialNeedsUVsSet.has(h)))return;let R=g.getVertexAccessor(D,o,H);if(void 0===R){const h=g.convertedToRightHandedBuffers.get(D._buffer)||D._buffer.getData(),j=M===k.f.PositionKind?function(D,h,o,H){const{byteOffset:g,byteStride:j,type:M,normalized:R}=h,t=h.getSize(),S=new Array(t).fill(1/0),k=new Array(t).fill(-1/0);return(0,I.j)(D,g+o*j,j,t,M,H*t,R,(D=>{for(let h=0;h<t;h++)S[h]=Math.min(S[h],D[h]),k[h]=Math.max(k[h],D[h])})),{min:S,max:k}}(h,D,o,H):void 0,t=(M===k.f.MatricesIndicesKind||M===k.f.MatricesIndicesExtraKind)&&D.type===k.f.FLOAT,S=t?k.f.UNSIGNED_BYTE:D.type,K=t?void 0:D.normalized,Q=t?g.getRemappedBufferView(D._buffer,D):g.getVertexBufferView(D._buffer),v=D.byteOffset+o*D.byteStride;this._accessors.push(this._bufferManager.createAccessor(Q,function(D,h){if(D==k.f.ColorKind)return h?"VEC4":"VEC3";switch(D){case k.f.PositionKind:case k.f.NormalKind:return"VEC3";case k.f.TangentKind:case k.f.MatricesIndicesKind:case k.f.MatricesIndicesExtraKind:case k.f.MatricesWeightsKind:case k.f.MatricesWeightsExtraKind:return"VEC4";case k.f.UVKind:case k.f.UV2Kind:case k.f.UV3Kind:case k.f.UV4Kind:case k.f.UV5Kind:case k.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${D}`)}(M,g.hasVertexColorAlpha(D)),S,H,v,j,K)),R=this._accessors.length-1,g.setVertexAccessor(D,o,H,R)}j.attributes[function(D){switch(D){case k.f.PositionKind:return"POSITION";case k.f.NormalKind:return"NORMAL";case k.f.TangentKind:return"TANGENT";case k.f.ColorKind:return"COLOR_0";case k.f.UVKind:return"TEXCOORD_0";case k.f.UV2Kind:return"TEXCOORD_1";case k.f.UV3Kind:return"TEXCOORD_2";case k.f.UV4Kind:return"TEXCOORD_3";case k.f.UV5Kind:return"TEXCOORD_4";case k.f.UV6Kind:return"TEXCOORD_5";case k.f.MatricesIndicesKind:return"JOINTS_0";case k.f.MatricesIndicesExtraKind:return"JOINTS_1";case k.f.MatricesWeightsKind:return"WEIGHTS_0";case k.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${D}`)}(M)]=R}async _exportMaterialAsync(D,h,o,H){let g=this._materialMap.get(D);if(void 0===g){const H=h&&Object.keys(h).some((D=>D.startsWith("uv")));if((D=D instanceof vD.c?D.bg[o.materialIndex]:D)instanceof rD.b)g=await this._materialExporter.exportPBRMaterialAsync(D,"image/png",H);else{if(!(D instanceof BD.Zh))return void P.d.Warn(`Unsupported material '${D.name}' with type ${D.getClassName()}`);g=await this._materialExporter.exportStandardMaterialAsync(D,"image/png",H)}this._materialMap.set(D,g)}H.material=g}async _exportMeshAsync(D,h){var o;let H=h.getMesh(D);if(void 0!==H)return H;const g={primitives:[]};H=this._meshes.length,this._meshes.push(g),h.setMesh(D,H);const M=D.isUnIndexed?null:D.jg(),R=null===(o=D.mg)||void 0===o?void 0:o.getVertexBuffers(),t=h.getMorphTargetsFromMesh(D),S=D instanceof iD.c,k=D instanceof wD,K=D.nh;if(R&&K&&K.length>0)for(const r of K){const o={attributes:{}},H=r.uD()||this._babylonScene.defaultMaterial;if(k){var Q,v;const h={name:H.name},g=D,j=s.mo.White(),M=(null===(Q=g.material)||void 0===Q?void 0:Q.alpha)??1,R=(null===(v=g.greasedLineMaterial)||void 0===v?void 0:v.color)??j;(!R.equalsWithEpsilon(j,F.d)||M<1)&&(h.pbrMetallicRoughness={baseColorFactor:[...R.Fh(),M]}),this._materials.push(h),o.material=this._materials.length-1}else if(S){const h={name:H.name},g=D;(!g.color.equalsWithEpsilon(s.mo.White(),F.d)||g.alpha<1)&&(h.pbrMetallicRoughness={baseColorFactor:[...g.color.Fh(),g.alpha]}),this._materials.push(h),o.material=this._materials.length-1}else await this._exportMaterialAsync(H,R,r,o);const K=S||k?j.c.LineListDrawMode:D.overrideRenderingFillMode??H.fillMode,B=H._getEffectiveOrientation(D);this._exportIndices(M,M?(0,I.b)(M,r.indexCount,r.indexStart,r.verticesStart):r.verticesCount>65535,M?r.indexStart:r.verticesStart,M?r.indexCount:r.verticesCount,-r.verticesStart,K,B,h,o);for(const D of Object.values(R))this._exportVertexBuffer(D,H,r.verticesStart,r.verticesCount,h,o);if(t){o.targets=[];for(const D of t)o.targets.push(D.attributes)}g.primitives.push(o),this._extensionsPostExportMeshPrimitive(o)}if(t){g.weights=[],g.extras||(g.extras={}),g.extras.targetNames=[];for(const D of t)g.weights.push(D.influence),g.extras.targetNames.push(D.name)}return H}}lD._ExtensionNames=new Array,lD._ExtensionFactories={};class CD{static async GLTFAsync(D,h,o){o&&o.exportWithoutWaitingForScene||await D.whenReadyAsync();const H=new lD(D,o),g=await H.generateGLTFAsync(h.replace(/\.[^/.]+$/,""));return H.dispose(),g}static async GLBAsync(D,h,o){o&&o.exportWithoutWaitingForScene||await D.whenReadyAsync();const H=new lD(D,o),g=await H.generateGLBAsync(h.replace(/\.[^/.]+$/,""));return H.dispose(),g}}o(13406);const zD="EXT_mesh_gpu_instancing";class fD{constructor(D){this.name=zD,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(D,h,o,g,j,M){return await new Promise((D=>{if(h&&o instanceof qD.d&&o.hasThinInstances&&this._exporter){this._wasUsed=!0;const D=H.Gh.Zero(),g=H.Quaternion.Identity(),R=H.Gh.One(),t=o.thinInstanceGetWorldMatrices(),S=H.TmpVectors.Gh[2],k=H.TmpVectors.Quaternion[1],K=H.TmpVectors.Gh[3];let Q=!1,v=!1,r=!1;const B=new Float32Array(3*o.ig),s=new Float32Array(4*o.ig),U=new Float32Array(3*o.ig);let q=0;for(const h of t)h.decompose(K,k,S),j&&(A(S),W(k)),B.set(S.Fh(),3*q),s.set(k.normalize().Fh(),4*q),U.set(K.Fh(),3*q),Q=Q||!S.equalsWithEpsilon(D),v=v||!k.equalsWithEpsilon(g),r=r||!K.equalsWithEpsilon(R),q++;const c={attributes:{}};Q&&(c.attributes.TRANSLATION=this._buildAccessor(B,"VEC3",o.ig,M)),v&&(c.attributes.ROTATION=this._buildAccessor(s,"VEC4",o.ig,M)),r&&(c.attributes.SCALE=this._buildAccessor(U,"VEC3",o.ig,M)),h.extensions=h.extensions||{},h.extensions[zD]=c}D(h)}))}_buildAccessor(D,h,o,H){const g=H.createBufferView(D),j=H.createAccessor(g,h,5126,o);return this._exporter._accessors.push(j),this._exporter._accessors.length-1}}lD.RegisterExtension(zD,(D=>new fD(D)));var VD=o(13409),dD=o(13423),XD=o(13426),AD=o(13431);function WD(D){return D===XD.e.PositionKind?"POSITION":D===XD.e.NormalKind?"NORMAL":D===XD.e.ColorKind?"COLOR":D.startsWith(XD.e.UVKind)?"TEX_COORD":"GENERIC"}const xD={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Dh extends VD.d{static get DefaultAvailable(){return(0,VD.i)(Dh.DefaultConfiguration)}static get Default(){return Dh._Default??(Dh._Default=new Dh),Dh._Default}static ResetDefault(D){Dh._Default&&(D||Dh._Default.dispose(),Dh._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(D,h){return{module:await(h||DracoEncoderModule)({wasmBinary:D})}}_getWorkerContent(){return`${dD.i}(${dD.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Dh.DefaultConfiguration)}async _encodeAsync(D,h,o){const H=o?(0,AD.c)(xD,o):xD;if(this._workerPoolPromise){const o=await this._workerPoolPromise;return await new Promise(((g,j)=>{o.push(((o,M)=>{const R=D=>{o.removeEventListener("error",R),o.removeEventListener("message",t),j(D),M()},t=D=>{"encodeMeshDone"===D.data.id&&(o.removeEventListener("error",R),o.removeEventListener("message",t),g(D.data.encodedMeshData),M())};o.addEventListener("error",R),o.addEventListener("message",t);const S=[];for(const h of D)S.push(h.data.buffer);h&&S.push(h.buffer),o.postMessage({id:"encodeMesh",attributes:D,indices:h,options:H},S)}))}))}if(this._modulePromise){const o=await this._modulePromise;return(0,dD.i)(o.module,D,h,H)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(D,h){if(0==D.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");D instanceof qD.d&&D.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===h||void 0===h?void 0:h.method)&&(P.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),h.method="MESH_SEQUENTIAL_ENCODING");const o=function(D){let h=D.jg(void 0,!0);return!h||h instanceof Uint32Array||h instanceof Uint16Array||(h=((0,I.b)(h,h.length)?Uint32Array:Uint16Array).from(h)),h}(D),H=function(D,h){const o=[];for(const H of D.getVerticesDataKinds()){if(null!==h&&void 0!==h&&h.includes(H)){if(H===XD.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const g=D.getVertexBuffer(H),j=g.getSize(),M=(0,I.r)(g.getData(),j,g.type,g.byteOffset,g.byteStride,g.normalized,D.getTotalVertices(),!0);o.push({kind:H,dracoName:WD(H),size:j,data:M})}return o}(D,null===h||void 0===h?void 0:h.excludedAttributes);return await this._encodeAsync(H,o,h)}}Dh.DefaultConfiguration={wasmUrl:`${g.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${g.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${g.Tools._DefaultCdnUrl}/draco_encoder.js`},Dh._Default=null;const hh="KHR_draco_mesh_compression";class oh{get wasUsed(){return this._wasUsed}constructor(D){this.name=hh,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===D.options.meshCompressionMethod&&Dh.DefaultAvailable}dispose(){}postExportMeshPrimitive(D,h,o){if(!this.enabled)return;if(4!==D.mode&&5!==D.mode)return void P.d.Warn("Cannot compress primitive with mode "+D.mode+".");const H=[],g=[];let j=null;if(void 0!==D.indices){const M=o[D.indices],R=h.getBufferView(M);j=h.getData(R).slice(),H.push(R),g.push(M)}const M=[];for(const[k,K]of Object.entries(D.attributes)){const D=o[K],j=h.getBufferView(D),t=f(D.type),S=(0,I.r)(h.getData(j),t,D.componentType,D.byteOffset||0,j.byteStride||(0,I.o)(D.componentType)*t,D.normalized||!1,D.count,!0);M.push({kind:k,dracoName:(R=k,"POSITION"===R?"POSITION":"NORMAL"===R?"NORMAL":R.startsWith("COLOR")?"COLOR":R.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:f(D.type),data:S}),H.push(j),g.push(D)}var R;const t={method:D.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},S=Dh.Default._encodeAsync(M,j,t).then((o=>{if(!o)return void P.d.Error("Draco encoding failed for primitive.");const j={bufferView:-1,attributes:o.attributeIds},M=h.createBufferView(o.data);h.setBufferView(j,M);for(const D of H)this._bufferViewsUsed.add(D);for(const D of g)this._accessorsUsed.add(D);D.extensions||(D.extensions={}),D.extensions[hh]=j})).catch((D=>{P.d.Error("Draco encoding failed for primitive: "+D)}));this._encodePromises.push(S),this._wasUsed=!0}async preGenerateBinaryAsync(D){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((h=>{D.getPropertiesWithBufferView(h).every((D=>this._accessorsUsed.has(D)))&&D.removeBufferView(h)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}lD.RegisterExtension(hh,(D=>new oh(D)));var Hh=o(13439);const gh="KHR_lights_punctual",jh={name:"",color:[1,1,1],Jg:1,range:Number.MAX_VALUE},Mh={innerConeAngle:0,outerConeAngle:Math.PI/4},Rh=H.Gh.Backward();class th{constructor(D){this.name=gh,this.enabled=!0,this.required=!1,this._exporter=D}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[gh]=this._lights}async postExportNodeAsync(D,h,o,g,j){return await new Promise((M=>{if(!(o instanceof cD.c))return void M(h);const R=o.getTypeID()==cD.c.LIGHTTYPEID_POINTLIGHT?"point":o.getTypeID()==cD.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":o.getTypeID()==cD.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!R||!(o instanceof Hh.e))return P.d.Warn(`${D}: Light ${o.name} is not supported in ${gh}`),void M(h);if(o.falloffType!==cD.c.FALLOFF_GLTF&&P.d.Warn(`${D}: Light falloff for ${o.name} does not match the ${gh} specification!`),!o.position.equalsToFloats(0,0,0)){const D=H.TmpVectors.Gh[0].M(o.position);j&&A(D),h.translation=D.Fh()}if("point"!==R){const D=o.direction.normalizeToRef(H.TmpVectors.Gh[0]);j&&A(D);const g=H.Quaternion.FromUnitVectorsToRef(Rh,D,H.TmpVectors.Quaternion[0]);H.Quaternion.IsIdentity(g)||(h.rotation=g.Fh())}const t={type:R,name:o.name,color:o.Og.Fh(),Jg:o.Jg,range:o.range};if(HD(t,jh),"spot"===R){const D=o;t.spot={innerConeAngle:D.innerAngle/2,outerConeAngle:D.angle/2},HD(t.spot,Mh)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(t);const S={Kh:this._lights.lights.length-1},k=o.parent;if(k&&hD(o,k)){const D=g.get(k);if(D){const o=this._exporter._nodes[D];return DD(h,o),o.extensions||(o.extensions={}),o.extensions[gh]=S,void M(null)}}h.extensions||(h.extensions={}),h.extensions[gh]=S,M(h)}))}}lD.RegisterExtension(gh,(D=>new th(D)));var Sh=o(13356);const kh="KHR_materials_anisotropy";class Kh{constructor(D){this.name=kh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,h,o){const H=[];return o instanceof Sh.c&&o.anisotropy.isEnabled&&!o.anisotropy.legacy?(o.anisotropy.texture&&H.push(o.anisotropy.texture),H):[]}postExportMaterialAsync(D,h,o){return new Promise((D=>{if(o instanceof Sh.c){if(!o.anisotropy.isEnabled||o.anisotropy.legacy)return void D(h);this._wasUsed=!0,h.extensions=h.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(o.anisotropy.texture),g={anisotropyStrength:o.anisotropy.Jg,anisotropyRotation:o.anisotropy.angle,anisotropyTexture:H??void 0};null!==g.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(o),h.extensions[kh]=g}D(h)}))}}lD.RegisterExtension(kh,(D=>new Kh(D)));const Qh="KHR_materials_clearcoat";class vh{constructor(D){this.name=Qh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,h,o){const H=[];return o instanceof Sh.c&&o.clearCoat.isEnabled?(o.clearCoat.texture&&H.push(o.clearCoat.texture),!o.clearCoat.useRoughnessFromMainTexture&&o.clearCoat.textureRoughness&&H.push(o.clearCoat.textureRoughness),o.clearCoat.bumpTexture&&H.push(o.clearCoat.bumpTexture),H):[]}postExportMaterialAsync(D,h,o){return new Promise((D=>{if(o instanceof Sh.c){if(!o.clearCoat.isEnabled)return void D(h);this._wasUsed=!0,h.extensions=h.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(o.clearCoat.texture);let j;j=o.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(o.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(o.clearCoat.textureRoughness),o.clearCoat.isTintEnabled&&g.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${o.name}`),o.clearCoat.remapF0OnInterfaceChange&&g.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${o.name}`);const M=this._exporter._materialExporter.getTextureInfo(o.clearCoat.bumpTexture),R={clearcoatFactor:o.clearCoat.Jg,clearcoatTexture:H??void 0,clearcoatRoughnessFactor:o.clearCoat.roughness,clearcoatRoughnessTexture:j??void 0,clearcoatNormalTexture:M??void 0};null===R.clearcoatTexture&&null===R.clearcoatRoughnessTexture&&null===R.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(o),h.extensions[Qh]=R}D(h)}))}}lD.RegisterExtension(Qh,(D=>new vh(D)));const rh="KHR_materials_diffuse_transmission";function Bh(D,h){const o=h.subSurface;let H=null;return o.translucencyIntensityTexture?H=o.translucencyIntensityTexture:o.thicknessTexture&&o.useMaskFromThicknessTexture&&(H=o.thicknessTexture),H&&!o.useGltfStyleTextures?(P.d.Warn(`${D}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${h.name}`,1),null):H}class sh{constructor(D){this.name=rh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,h,o){const H=[];if(o instanceof rD.b&&this._isExtensionEnabled(o)){const h=Bh(D,o);return h&&H.push(h),o.subSurface.translucencyColorTexture&&H.push(o.subSurface.translucencyColorTexture),H}return H}_isExtensionEnabled(D){if(D.unlit)return!1;const h=D.subSurface;return!!h.isTranslucencyEnabled&&(!D.unlit&&!h.useAlbedoToTintTranslucency&&h.useGltfStyleTextures&&1===h.volumeIndexOfRefraction&&0===h.minimumThickness&&0===h.maximumThickness)}postExportMaterialAsync(D,h,o){return new Promise((H=>{if(o instanceof rD.b&&this._isExtensionEnabled(o)){this._wasUsed=!0;const H=o.subSurface,g=Bh(D,o),j=0==H.translucencyIntensity?void 0:H.translucencyIntensity,M=this._exporter._materialExporter.getTextureInfo(g)??void 0,R=!H.translucencyColor||H.translucencyColor.equalsFloats(1,1,1)?void 0:H.translucencyColor.Fh(),t=this._exporter._materialExporter.getTextureInfo(H.translucencyColorTexture)??void 0,S={diffuseTransmissionFactor:j,diffuseTransmissionTexture:M,diffuseTransmissionColorFactor:R,diffuseTransmissionColorTexture:t};(M||t)&&this._exporter._materialNeedsUVsSet.add(o),h.extensions=h.extensions||{},h.extensions[rh]=S}H(h)}))}}lD.RegisterExtension(rh,(D=>new sh(D)));const Uh="KHR_materials_dispersion";class qh{constructor(){this.name=Uh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(D){if(D.unlit)return!1;const h=D.subSurface;return!(!h.isRefractionEnabled&&!h.isDispersionEnabled)}postExportMaterialAsync(D,h,o){return new Promise((D=>{if(o instanceof rD.b&&this._isExtensionEnabled(o)){this._wasUsed=!0;const D={dispersion:o.subSurface.dispersion};h.extensions=h.extensions||{},h.extensions[Uh]=D}D(h)}))}}lD.RegisterExtension(Uh,(()=>new qh));const ch="KHR_materials_emissive_strength";class yh{constructor(){this.name=ch,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(D,h,o){return await new Promise((D=>{if(!(o instanceof rD.b))return D(h);const H=o.emissiveColor.Fh(),g=Math.max(...H);if(g>1){this._wasUsed=!0,h.extensions||(h.extensions={});const D={emissiveStrength:g},H=o.emissiveColor.scale(1/D.emissiveStrength);h.emissiveFactor=H.Fh(),h.extensions[ch]=D}return D(h)}))}}lD.RegisterExtension(ch,(D=>new yh));const bh="KHR_materials_ior";class ih{constructor(){this.name=bh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(D){return!D.unlit&&(void 0!=D.indexOfRefraction&&1.5!=D.indexOfRefraction)}postExportMaterialAsync(D,h,o){return new Promise((D=>{if(o instanceof rD.b&&this._isExtensionEnabled(o)){this._wasUsed=!0;const D={ior:o.indexOfRefraction};h.extensions=h.extensions||{},h.extensions[bh]=D}D(h)}))}}lD.RegisterExtension(bh,(D=>new ih));const Gh="KHR_materials_iridescence";class Nh{constructor(D){this.name=Gh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,h,o){const H=[];return o instanceof Sh.c&&o.iridescence.isEnabled?(o.iridescence.texture&&H.push(o.iridescence.texture),o.iridescence.thicknessTexture&&o.iridescence.thicknessTexture!==o.iridescence.texture&&H.push(o.iridescence.thicknessTexture),H):[]}postExportMaterialAsync(D,h,o){return new Promise((D=>{if(o instanceof Sh.c){if(!o.iridescence.isEnabled)return void D(h);this._wasUsed=!0,h.extensions=h.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(o.iridescence.texture),g=this._exporter._materialExporter.getTextureInfo(o.iridescence.thicknessTexture),j={iridescenceFactor:o.iridescence.Jg,iridescenceIor:o.iridescence.indexOfRefraction,iridescenceThicknessMinimum:o.iridescence.minimumThickness,iridescenceThicknessMaximum:o.iridescence.maximumThickness,iridescenceTexture:H??void 0,iridescenceThicknessTexture:g??void 0};null===j.iridescenceTexture&&null===j.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(o),h.extensions[Gh]=j}D(h)}))}}lD.RegisterExtension(Gh,(D=>new Nh(D)));const Jh="KHR_materials_sheen";class Oh{constructor(D){this.name=Jh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,h,o){return o instanceof rD.b&&o.sheen.isEnabled&&o.sheen.texture?[o.sheen.texture]:[]}async postExportMaterialAsync(D,h,o){return await new Promise((D=>{if(o instanceof rD.b){if(!o.sheen.isEnabled)return void D(h);this._wasUsed=!0,null==h.extensions&&(h.extensions={});const H={sheenColorFactor:o.sheen.color.Fh(),sheenRoughnessFactor:o.sheen.roughness??0};null===H.sheenColorTexture&&null===H.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(o),o.sheen.texture&&(H.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.texture)??void 0),o.sheen.textureRoughness&&!o.sheen.useRoughnessFromMainTexture?H.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.textureRoughness)??void 0:o.sheen.texture&&o.sheen.useRoughnessFromMainTexture&&(H.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.texture)??void 0),h.extensions[Jh]=H}D(h)}))}}lD.RegisterExtension(Jh,(D=>new Oh(D)));const Eh="KHR_materials_specular";class Lh{constructor(D){this.name=Eh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,h,o){const H=[];return o instanceof rD.b&&this._isExtensionEnabled(o)?(o.metallicReflectanceTexture&&H.push(o.metallicReflectanceTexture),o.reflectanceTexture&&H.push(o.reflectanceTexture),H):H}_isExtensionEnabled(D){return!D.unlit&&(void 0!=D.metallicF0Factor&&1!=D.metallicF0Factor||void 0!=D.metallicReflectanceColor&&!D.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(D))}_hasTexturesExtension(D){return null!=D.metallicReflectanceTexture||null!=D.reflectanceTexture}postExportMaterialAsync(D,h,o){return new Promise((D=>{if(o instanceof rD.b&&this._isExtensionEnabled(o)){this._wasUsed=!0,h.extensions=h.extensions||{};const D=this._exporter._materialExporter.getTextureInfo(o.metallicReflectanceTexture)??void 0,H=this._exporter._materialExporter.getTextureInfo(o.reflectanceTexture)??void 0,g={specularFactor:1==o.metallicF0Factor?void 0:o.metallicF0Factor,specularTexture:D,specularColorFactor:o.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:o.metallicReflectanceColor.Fh(),specularColorTexture:H};this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),h.extensions[Eh]=g}D(h)}))}}lD.RegisterExtension(Eh,(D=>new Lh(D)));const Th="KHR_materials_transmission";class Zh{constructor(D){this.name=Th,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,h,o){const H=[];return o instanceof rD.b&&this._isExtensionEnabled(o)?(o.subSurface.thicknessTexture&&H.push(o.subSurface.thicknessTexture),H):H}_isExtensionEnabled(D){if(D.unlit)return!1;const h=D.subSurface;return h.isRefractionEnabled&&void 0!=h.refractionIntensity&&0!=h.refractionIntensity||this._hasTexturesExtension(D)}_hasTexturesExtension(D){return null!=D.subSurface.refractionIntensityTexture}async postExportMaterialAsync(D,h,o){if(o instanceof rD.b&&this._isExtensionEnabled(o)){this._wasUsed=!0;const H=o.subSurface,g={transmissionFactor:0===H.refractionIntensity?void 0:H.refractionIntensity};if(this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),H.refractionIntensityTexture)if(H.useGltfStyleTextures){const D=await this._exporter._materialExporter.exportTextureAsync(H.refractionIntensityTexture,"image/png");D&&(g.transmissionTexture=D)}else P.d.Warn(`${D}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);h.extensions||(h.extensions={}),h.extensions[Th]=g}return h}}lD.RegisterExtension(Th,(D=>new Zh(D)));const eh="KHR_materials_unlit";class ph{constructor(){this.name=eh,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(D,h,o){return new Promise((D=>{let H=!1;o instanceof rD.b?H=o.unlit:o instanceof BD.Zh&&(H=o.uh),H&&(this._wasUsed=!0,null==h.extensions&&(h.extensions={}),h.extensions[eh]={}),D(h)}))}}lD.RegisterExtension(eh,(()=>new ph));const mo="KHR_materials_volume";class ah{constructor(D){this.name=mo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,h,o){const H=[];return o instanceof rD.b&&this._isExtensionEnabled(o)?(o.subSurface.thicknessTexture&&H.push(o.subSurface.thicknessTexture),H):H}_isExtensionEnabled(D){if(D.unlit)return!1;const h=D.subSurface;return!(!h.isRefractionEnabled&&!h.isTranslucencyEnabled)&&(void 0!=h.maximumThickness&&0!=h.maximumThickness||void 0!=h.tintColorAtDistance&&h.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=h.tintColor&&h.tintColor!=s.mo.White()||this._hasTexturesExtension(D))}_hasTexturesExtension(D){return null!=D.subSurface.thicknessTexture}postExportMaterialAsync(D,h,o){return new Promise((D=>{if(o instanceof rD.b&&this._isExtensionEnabled(o)){this._wasUsed=!0;const D=o.subSurface,H={thicknessFactor:0==D.maximumThickness?void 0:D.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(D.thicknessTexture)??void 0,attenuationDistance:D.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:D.tintColorAtDistance,attenuationColor:D.tintColor.equalsFloats(1,1,1)?void 0:D.tintColor.Fh()};this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),h.extensions=h.extensions||{},h.extensions[mo]=H}D(h)}))}}lD.RegisterExtension(mo,(D=>new ah(D)));const uh="EXT_materials_diffuse_roughness";class Ih{constructor(D){this.name=uh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,h,o){const H=[];return o instanceof Sh.c&&o._baseDiffuseRoughness?(o._baseDiffuseRoughnessTexture&&H.push(o._baseDiffuseRoughnessTexture),H):[]}postExportMaterialAsync(D,h,o){return new Promise((D=>{if(o instanceof Sh.c){if(!o._baseDiffuseRoughness)return void D(h);this._wasUsed=!0,h.extensions=h.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(o._baseDiffuseRoughnessTexture),g={diffuseRoughnessFactor:o._baseDiffuseRoughness,diffuseRoughnessTexture:H??void 0};null!==g.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(o),h.extensions[uh]=g}D(h)}))}}lD.RegisterExtension(uh,(D=>new Ih(D)));const Ph="KHR_texture_transform";class nh{constructor(){this.name=Ph,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(D,h,o){if(o.GD()||g.Tools.Warn(`${D}: /*@__KEY__*/"scene" is not defined for Babylon texture ${o.name}!`),(0!==o.uAng||0!==o.vAng)&&(g.Tools.Warn(`${D}: Texture ${o.name} with rotation in the u or v axis is not supported in glTF.`),0!==o.uRotationCenter||0!==o.vRotationCenter))return;const H={};let j=!1;if(0===o.uOffset&&0===o.vOffset||(H.offset=[o.uOffset,o.vOffset],j=!0),1===o.uScale&&1===o.vScale||(H.scale=[o.uScale,o.vScale],j=!0),0!==o.wAng){if(0!==o.uRotationCenter||0!==o.vRotationCenter){if(o.homogeneousRotationInUVTransform&&o.uScale!==o.vScale)return void g.Tools.Warn(`${D}: Texture ${o.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Ph}.`);g.Tools.Warn(`${D}: Texture ${o.name} with non-origin rotation center will be exported using an adjusted offset with ${Ph}.`),H.offset=function(D){const{uOffset:h,vOffset:o,uRotationCenter:H,vRotationCenter:g,uScale:j,vScale:M,wAng:R}=D,t=Math.cos(R),S=Math.sin(R),k=H*j,K=g*M;return[h+(k*(1-t)+K*S),o+(K*(1-t)-k*S)]}(o)}H.rotation=-o.wAng,j=!0}0!==o.coordinatesIndex&&(H.texCoord=o.coordinatesIndex,j=!0),j&&(this._wasUsed=!0,h.extensions||(h.extensions={}),h.extensions[Ph]=H)}}lD.RegisterExtension(Ph,(()=>new nh));class Fh{static CreateSTL(D){let h=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",g=arguments.length>3&&void 0!==arguments[3]&&arguments[3],j=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],M=arguments.length>5&&void 0!==arguments[5]&&arguments[5],R=arguments.length>6&&void 0!==arguments[6]&&arguments[6],t=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const S=function(D,h,o){const g=[3*D[o],3*D[o+1],3*D[o+2]],j=[new H.Gh(h[g[0]],h[g[0]+2],h[g[0]+1]),new H.Gh(h[g[1]],h[g[1]+2],h[g[1]+1]),new H.Gh(h[g[2]],h[g[2]+2],h[g[2]+1])],M=j[0].Nh(j[1]),R=j[2].Nh(j[1]);return{v:j,n:H.Gh.Cross(R,M).normalize()}},K=function(D,h,o,H){return h=Q(D,h,o.x,H),h=Q(D,h,o.y,H),Q(D,h,o.z,H)},Q=function(D,h,o,H){return D.setFloat32(h,o,H),h+4},r=function(D){if(R){let h=D;D instanceof v.e&&(h=D.sourceMesh);const o=h.getVerticesData(k.f.PositionKind,!0,!0);if(!o)return[];const g=H.Gh.Zero();let j;for(j=0;j<o.length;j+=3)H.Gh.TransformCoordinatesFromFloatsToRef(o[j],o[j+1],o[j+2],D.xh(!0),g).toArray(o,j);return o}return D.getVerticesData(k.f.PositionKind)||[]};R&&(M=!0);let B="",s=0,U=0;if(g){for(let o=0;o<D.length;o++){const h=D[o].jg();s+=h?h.length/3:0}const h=new ArrayBuffer(84+50*s);B=new DataView(h),U+=80,B.setUint32(U,s,j),U+=4}else t||(B="solid stlmesh\r\n");for(let H=0;H<D.length;H++){const h=D[H];!g&&t&&(B+="solid "+h.name+"\r\n"),!M&&h instanceof qD.d&&h.bakeCurrentTransformIntoVertices();const o=r(h),R=h.jg()||[];for(let D=0;D<R.length;D+=3){const h=S(R,o,D);g?(U=K(B,U,h.n,j),U=K(B,U,h.v[0],j),U=K(B,U,h.v[1],j),U=K(B,U,h.v[2],j),U+=2):(B+="\tfacet normal "+h.n.x+" "+h.n.y+" "+h.n.z+"\r\n",B+="\t\touter loop\r\n",B+="\t\t\tvertex "+h.v[0].x+" "+h.v[0].y+" "+h.v[0].z+"\r\n",B+="\t\t\tvertex "+h.v[1].x+" "+h.v[1].y+" "+h.v[1].z+"\r\n",B+="\t\t\tvertex "+h.v[2].x+" "+h.v[2].y+" "+h.v[2].z+"\r\n",B+="\t\tendloop\r\n",B+="\tendfacet\r\n")}!g&&t&&(B+="endsolid "+name+"\r\n")}if(g||t||(B+="endsolid stlmesh"),h){const D=document.createElement("a"),h=new Blob([B],{type:"application/octet-stream"});D.href=window.URL.createObjectURL(h),D.download=o+".stl",D.click()}return B}}function wh(D,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const H=[];for(let g=0;g<D.length/o;g++){const j=D[g*o],M=D[g*o+1],R=D[g*o+2];H.push(`(${j.toPrecision(h.precision)}, ${M.toPrecision(h.precision)}, ${R.toPrecision(h.precision)})`)}return H.join(", ")}function Yh(D,h){const o=[];for(let H=0;H<D.length/2;H++){const g=D[2*H],j=D[2*H+1];o.push(`(${g.toPrecision(h.precision)}, ${(1-j).toPrecision(h.precision)})`)}return o.join(", ")}function lh(D,h){const o=D.getVerticesData(k.f.PositionKind),H=D.getVerticesData(k.f.NormalKind);if(o&&H)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(D){var h;const o=null!==(h=D.jg())&&void 0!==h&&h.length?D.getTotalIndices():D.getTotalVertices();return Array(o/3).fill(3).join(", ")}(D)}]\n\t\tint[] faceVertexIndices = [${function(D){const h=D.jg(),o=[];if(null!==h)for(let H=0;H<h.length;H++)o.push(h[H]);else{const h=D.getTotalVertices();for(let D=0;D<h;D++)o.push(D)}return o.join(", ")}(D)}]\n\t\tnormal3f[] normals = [${wh(H,h)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${wh(o,h)}]\n        ${function(D,h){let o="";for(let g=0;g<4;g++){const H=g>0?g:"",j=D.getVerticesData(k.f.UVKind+(H?H+1:""));j&&(o+=`\n\t\ttexCoord2f[] primvars:st${H} = [${Yh(j,h)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const H=D.getVerticesData(k.f.ColorKind);return H&&(o+=`\n\tcolor3f[] primvars:displayColor = [${wh(H,h,H.length/D.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),o}(D,h)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Ch(D,h){return`\n        def "Geometry"\n        {\n        ${lh(D,h)}\n        }\n        `}function zh(D){let h='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return h+=D,fflate.strToU8(h)}function fh(D){const h=D.m;return`( ${Vh(h,0)}, ${Vh(h,4)}, ${Vh(h,8)}, ${Vh(h,12)} )`}function Vh(D,h){return`(${D[h+0]}, ${D[h+1]}, ${D[h+2]}, ${D[h+3]})`}function dh(D){const h="Object_"+D.uniqueId,o=function(D){const h=D.getWorldMatrix().clone(),o=D.GD().useRightHandedSystem;if(!o){let H=D.parent;for(;H;){if(MD(H,o)){h.multiplyToRef(H.getWorldMatrix().invert(),h);break}H=H.parent}}return h.determinant()<0&&g.Tools.Warn(`Exporting mesh ${D.name} with negative scale. Result may look incorrect in destination engine.`),h}(D),H=fh(o);return`def Xform "${h}" (\n\tprepend references = @./geometries/Geometry_${D.mg.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${H}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${D.material.uniqueId}>\n}\n\n`}function Xh(D){switch(D){case G.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case G.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case G.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Ah(D){return`(${D.x}, ${D.y})`}function Wh(D){return`(${D.r}, ${D.g}, ${D.b})`}function xh(D,h,o,g,j,M){const R=D.getInternalTexture().uniqueId+"_"+D.invertY;j[R]=D;const t=D.coordinatesIndex>0?"st"+D.coordinatesIndex:"st",S=new H.Vector2(D.uScale,D.vScale),k=new H.Vector2(D.uOffset,D.vOffset),K=D.wAng,Q=Math.sin(K),v=Math.cos(K);return k.y=1-k.y-S.y,k.x+=Q*S.x,k.y+=(1-v)*S.y,`\n    def Shader "PrimvarReader_${o}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${t}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${o}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${h.uniqueId}/PrimvarReader_${o}.outputs:result>\n        float inputs:rotation = ${(K*(180/Math.PI)).toFixed(M.precision)}\n        float2 inputs:scale = ${Ah(S)}\n        float2 inputs:translation = ${Ah(k)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${D.uniqueId}_${o}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${R}.png@\n        float2 inputs:st.connect = </Materials/Material_${h.uniqueId}/Transform2d_${o}.outputs:result>\n        ${g?"float4 inputs:scale = "+function(D){return`(${D.r}, ${D.g}, ${D.b}, 1.0)`}(g):""}\n        token inputs:sourceColorSpace = "${D.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Xh(D.wrapU)}"\n        token inputs:wrapT = "${Xh(D.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${h.needAlphaBlending()?"float outputs:a":""}\n    }`}function Do(D,h,o){const H="\t\t\t",g=[],j=[],{diffuseMap:M,Og:R,alphaCutOff:t,emissiveMap:S,emissive:k,normalMap:K,roughnessMap:Q,roughnessChannel:v,roughness:r,metalnessMap:B,metalnessChannel:U,metalness:q,aoMap:c,aoMapChannel:y,aoMapIntensity:b,alphaMap:i,ior:G,clearCoatEnabled:N,clearCoat:J,clearCoatMap:O,clearCoatRoughness:E,clearCoatRoughnessMap:L}=function(D){const h={diffuseMap:null,Og:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return D instanceof BD.Zh?{...h,diffuseMap:D.diffuseTexture,Og:D.diffuseColor,alphaCutOff:D.alphaCutOff,emissiveMap:D.emissiveTexture,emissive:D.emissiveColor,roughness:1,alphaMap:D.opacityTexture}:D instanceof Sh.c?{...h,diffuseMap:D._albedoTexture,Og:D._albedoColor,alphaCutOff:D._alphaCutOff,emissiveMap:D._emissiveTexture,emissive:D._emissiveColor,normalMap:D._bumpTexture,roughnessMap:D._metallicTexture,roughnessChannel:D._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:D._roughness??1,metalnessMap:D._metallicTexture,metalnessChannel:D._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:D._metallic??0,aoMap:D._ambientTexture,aoMapChannel:D._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:D._ambientTextureStrength,alphaMap:D._opacityTexture,ior:D.subSurface.indexOfRefraction,clearCoatEnabled:D.clearCoat.isEnabled,clearCoat:D.clearCoat.Jg,clearCoatMap:D.clearCoat.texture,clearCoatRoughness:D.clearCoat.roughness,clearCoatRoughnessMap:D.clearCoat.useRoughnessFromMainTexture?D.clearCoat.texture:D.clearCoat.textureRoughness}:h}(D);return null!==M?(g.push(`${H}color3f inputs:diffuseColor.connect = </Materials/Material_${D.uniqueId}/Texture_${M.uniqueId}_diffuse.outputs:rgb>`),D.needAlphaBlending()?g.push(`${H}float inputs:opacity.connect = </Materials/Material_${D.uniqueId}/Texture_${M.uniqueId}_diffuse.outputs:a>`):D.needAlphaTesting()&&(g.push(`${H}float inputs:opacity.connect = </Materials/Material_${D.uniqueId}/Texture_${M.uniqueId}_diffuse.outputs:a>`),g.push(`${H}float inputs:opacityThreshold = ${t}`)),j.push(xh(M,D,"diffuse",R,h,o))):g.push(`${H}color3f inputs:diffuseColor = ${Wh(R||s.mo.White())}`),null!==S?(g.push(`${H}color3f inputs:emissiveColor.connect = </Materials/Material_${D.uniqueId}/Texture_${S.uniqueId}_emissive.outputs:rgb>`),j.push(xh(S,D,"emissive",k,h,o))):k&&k.toLuminance()>0&&g.push(`${H}color3f inputs:emissiveColor = ${Wh(k)}`),null!==K&&(g.push(`${H}normal3f inputs:normal.connect = </Materials/Material_${D.uniqueId}/Texture_${K.uniqueId}_normal.outputs:rgb>`),j.push(xh(K,D,"normal",null,h,o))),null!==c&&(g.push(`${H}float inputs:occlusion.connect = </Materials/Material_${D.uniqueId}/Texture_${c.uniqueId}_occlusion.outputs:${y}>`),j.push(xh(c,D,"occlusion",new s.mo(b,b,b),h,o))),null!==Q?(g.push(`${H}float inputs:roughness.connect = </Materials/Material_${D.uniqueId}/Texture_${Q.uniqueId}_roughness.outputs:${v}>`),j.push(xh(Q,D,"roughness",new s.mo(r,r,r),h,o))):g.push(`${H}float inputs:roughness = ${r}`),null!==B?(g.push(`${H}float inputs:metallic.connect = </Materials/Material_${D.uniqueId}/Texture_${B.uniqueId}_metallic.outputs:${U}>`),j.push(xh(B,D,"metallic",new s.mo(q,q,q),h,o))):g.push(`${H}float inputs:metallic = ${q}`),null!==i?(g.push(`${H}float inputs:opacity.connect = </Materials/Material_${D.uniqueId}/Texture_${i.uniqueId}_opacity.outputs:r>`),g.push(`${H}float inputs:opacityThreshold = 0.0001`),j.push(xh(i,D,"opacity",null,h,o))):g.push(`${H}float inputs:opacity = ${D.alpha}`),N&&(null!==O?(g.push(`${H}float inputs:clearcoat.connect = </Materials/Material_${D.uniqueId}/Texture_${O.uniqueId}_clearcoat.outputs:r>`),j.push(xh(O,D,"clearcoat",new s.mo(J,J,J),h,o))):g.push(`${H}float inputs:clearcoat = ${J}`),null!==L?(g.push(`${H}float inputs:clearcoatRoughness.connect = </Materials/Material_${D.uniqueId}/Texture_${L.uniqueId}_clearcoatRoughness.outputs:g>`),j.push(xh(L,D,"clearcoatRoughness",new s.mo(E,E,E),h,o))):g.push(`${H}float inputs:clearcoatRoughness = ${E}`)),g.push(`${H}float inputs:ior = ${G}`),`\n\tdef Material "Material_${D.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${g.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${D.uniqueId}/PreviewSurface.outputs:surface>\n\n${j.join("\n")}\n\n\t}\n`}async function ho(D,h,o){const j={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...h};"undefined"===typeof fflate&&await g.Tools.LoadScriptAsync(j.fflateUrl);const M={};M[j.modelFileName]=null;let R='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';R+=function(D){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===D.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${D.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${D.planeAnchoringAlignment}"`:""}\n            `}(j);const t={};for(const H of D.meshes){if(0===H.getTotalVertices())continue;const D=H,h=D.mg,S=D.material;if(!S||!h||o&&!o(D))continue;if(-1!==["Zh","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(S.getClassName())){const o="geometries/Geometry_"+h.uniqueId+".usda";if(!(o in M)){const D=Ch(h,j);M[o]=zh(D)}S.uniqueId in t||(t[S.uniqueId]=S),R+=dh(D)}else g.Tools.Warn("USDZExportAsync does not support this material type: "+S.getClassName())}D.activeCamera&&j.exportCamera&&(R+=function(D,h){const o="Camera_"+D.uniqueId,g=fh(H.Matrix.RotationY(Math.PI).multiply(D.getWorldMatrix()));if(D.mode===G.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${o}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${g}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${D.Xh.toPrecision(h.precision)}, ${D.maxZ.toPrecision(h.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(D.orthoLeft||1)+Math.abs(D.orthoRight||1))).toPrecision(h.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(D.orthoTop||1)+Math.abs(D.orthoBottom||1))).toPrecision(h.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const H=D.getEngine().getAspectRatio(D),j=h.cameraSensorWidth||35;return`def Camera "${o}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${g}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${D.Xh.toPrecision(h.precision)}, ${D.maxZ.toPrecision(h.precision)})\n\t\t\tfloat focalLength = ${(j/(2*Math.tan(.5*D.fov))).toPrecision(h.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(j*H).toPrecision(h.precision)}\n\t\t\tfloat verticalAperture = ${(j/H).toPrecision(h.precision)}            \n\t\t}\n\t\n\t`}}(D.activeCamera,j)),R+="\n            }\n        }\n    }";const S={};R+=function(D,h,o){const H=[];for(const g in D){const j=D[g];H.push(Do(j,h,o))}return`\n    def "Materials"\n{\n${H.join("")}\n}\n\n`}(t,S,j),M[j.modelFileName]=fflate.strToU8(R);for(const H in S){const D=S[H],h=D.getSize(),o=await D.readPixels();if(!o)throw new Error("Texture data is not available");const g=await N.DumpTools.DumpDataAsync(h.width,h.height,o,"image/png",void 0,!1,!0);M[`textures/Texture_${H}.png`]=new Uint8Array(g).slice()}let k=0;for(const H in M){const D=M[H];if(!D)continue;k+=34+H.length;const h=63&k;if(4!==h){const o=new Uint8Array(64-h);M[H]=[D,{extra:{12345:o}}]}k=D.length}return fflate.zipSync(M,{level:0})}}}]);