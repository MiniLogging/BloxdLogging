"use strict";(self["5dou0t7wntc"]=self["5dou0t7wntc"]||[]).push([[26],{12147:(K,O,F)=>{F.r(O),F.d(O,{EXT_materials_diffuse_roughness:()=>VO,EXT_mesh_gpu_instancing:()=>bK,GLTF2Export:()=>DK,GLTFData:()=>E,KHR_draco_mesh_compression:()=>FO,KHR_lights_punctual:()=>cO,KHR_materials_anisotropy:()=>tO,KHR_materials_clearcoat:()=>XO,KHR_materials_diffuse_transmission:()=>oO,KHR_materials_dispersion:()=>NO,KHR_materials_emissive_strength:()=>LO,KHR_materials_ior:()=>aO,KHR_materials_iridescence:()=>HO,KHR_materials_sheen:()=>WO,KHR_materials_specular:()=>yO,KHR_materials_transmission:()=>QO,KHR_materials_unlit:()=>GO,KHR_materials_volume:()=>mO,KHR_texture_transform:()=>YO,OBJExport:()=>q,STLExport:()=>BO,USDZExportAsync:()=>OF,_ConvertToGLTFPBRMetallicRoughness:()=>R,_SolveMetallic:()=>Q,__IGLTFExporterExtension:()=>J});var f=F(11713),r=F(11517),l=F(12053);class q{static OBJ(K,O,F,q){const J=[];let c=1,E=1;O&&(F||(F="mat"),J.push("mtllib "+F+".mtl"));for(let M=0;M<K.length;M++){const F=K[M],t=F.name||`mesh${M}}`;J.push(`o ${t}`);let j=null;if(q){const K=F.Pf(!0);j=new f.Matrix,K.invertToRef(j),F.bakeTransformIntoVertices(K)}if(O){const K=F.material;K&&J.push("usemtl "+K.id)}const X=F.hr;if(!X){r.Tools.Warn("No geometry is present on the mesh");continue}const u=X.getVerticesData("position"),T=X.getVerticesData("normal"),o=X.getVerticesData("uv"),k=X.br();let N=0,Z=0;if(!u||!k){r.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const L=K[0].HK().useRightHandedSystem?1:-1;for(let K=0;K<u.length;K+=3)J.push("v "+u[K]*L+" "+u[K+1]+" "+u[K+2]),N++;if(null!=T)for(let K=0;K<T.length;K+=3)J.push("vn "+T[K]*L+" "+T[K+1]+" "+T[K+2]);if(null!=o)for(let K=0;K<o.length;K+=2)J.push("vt "+o[K]+" "+o[K+1]),Z++;const d=["","",""],a=(F.material||F.HK().defaultMaterial)._getEffectiveOrientation(F),[g,H]=a===l.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let K=0;K<k.length;K+=3){const O=[String(k[K]+c),String(k[K+g]+c),String(k[K+H]+c)],F=[String(k[K]+E),String(k[K+g]+E),String(k[K+H]+E)],f=O,r=null!=o?F:d,l=null!=T?O:d;J.push("f "+f[0]+"/"+r[0]+"/"+l[0]+" "+f[1]+"/"+r[1]+"/"+l[1]+" "+f[2]+"/"+r[2]+"/"+l[2])}q&&j&&F.bakeTransformIntoVertices(j),c+=N,E+=Z}return J.join("\n")}static MTL(K){const O=[],F=K.material;O.push("newmtl mat1"),O.push("  Ns "+F.specularPower.toFixed(4)),O.push("  Ni 1.5000"),O.push("  d "+F.alpha.toFixed(4)),O.push("  Tr 0.0000"),O.push("  Tf 1.0000 1.0000 1.0000"),O.push("  illum 2"),O.push("  Ka "+F.ambientColor.r.toFixed(4)+" "+F.ambientColor.g.toFixed(4)+" "+F.ambientColor.b.toFixed(4)),O.push("  Kd "+F.diffuseColor.r.toFixed(4)+" "+F.diffuseColor.g.toFixed(4)+" "+F.diffuseColor.b.toFixed(4)),O.push("  Ks "+F.specularColor.r.toFixed(4)+" "+F.specularColor.g.toFixed(4)+" "+F.specularColor.b.toFixed(4)),O.push("  Ke "+F.emissiveColor.r.toFixed(4)+" "+F.emissiveColor.g.toFixed(4)+" "+F.emissiveColor.b.toFixed(4));F.ambientTexture&&O.push("  map_Ka "+F.ambientTexture.name),F.diffuseTexture&&O.push("  map_Kd "+F.diffuseTexture.name),F.specularTexture&&O.push("  map_Ks "+F.specularTexture.name),F.bumpTexture&&O.push("  map_bump -imfchan z "+F.bumpTexture.name),F.opacityTexture&&O.push("  map_d "+F.opacityTexture.name);return O.join("\n")}}var J=0,c=F(11565);class E{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const K in this.files){const O=this.files[K],F=new Blob([O],{type:(0,c.m)(K)});r.Tools.Download(F,K)}}}var M=F(11793),t=F(12153),j=F(12164),X=F(12184),u=F(11859),T=F(11559),o=F(11764),k=F(11734);const N=k.HighestCommonFactor,Z={...k,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:N};var L=F(11959),d=F(11688),a=F(12221),g=F(12228),H=F(11951);const e=1e-6,W=new o.ZO(.04,.04,.04),p=1024,y=o.ZO.White(),A=o.ZO.Black();function Q(K,O,F){if(O<W.r)return 0;const f=W.r,r=K*F/(1-W.r)+O-2*W.r,l=r*r-4*f*(W.r-O);return Z.Clamp((-r+Math.sqrt(l))/(2*f),0,1)}function R(K){const O=K.diffuseColor.toLinearSpace(K.HK().getEngine().useExactSrgbConversions).scale(.5),F=K.alpha,r=function(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new f.Vector2(0,1),F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new f.Vector2(0,.1),r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new f.Vector2(0,.1),l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new f.Vector2(1300,.1);return function(K,O,F,f,r){return(1-K)*(1-K)*(1-K)*O+3*(1-K)*(1-K)*K*F+3*(1-K)*K*K*f+K*K*K*r}(Math.pow(K/l.x,.333333),O.y,F.y,r.y,l.y)}(Z.Clamp(K.specularPower,0,p));return{baseColorFactor:[O.r,O.g,O.b,F],metallicFactor:0,roughnessFactor:r}}function G(K,O){O.needAlphaBlending()?K.alphaMode="BLEND":O.needAlphaTesting()&&(K.alphaMode="MASK",K.alphaCutoff=O.alphaCutOff)}function z(K,O,F){const f=new Uint8Array(K*O*4);for(let r=0;r<f.length;r+=4)f[r]=f[r+1]=f[r+2]=f[r+3]=255;return a.e.CreateRGBATexture(f,K,O,F)}function m(K){if(K instanceof Uint8Array){const O=K.length,F=new Float32Array(K.length);for(let f=0;f<O;++f)F[f]=K[f]/255;return F}if(K instanceof Float32Array)return K;throw new Error("Unsupported pixel format!")}class x{constructor(K){this._exporter=K,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(K){return K?this._textureMap.get(K)??null:null}async exportStandardMaterialAsync(K,O,F){const f=R(K),l={name:K.name};if(null==K.qq||K.qq||(K.twoSidedLighting||r.Tools.Warn(K.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),l.doubleSided=!0),F){const F=[],r=K.diffuseTexture;r&&F.push(this.exportTextureAsync(r,O).then((K=>{K&&(f.baseColorTexture=K)})));const q=K.bumpTexture;q&&F.push(this.exportTextureAsync(q,O).then((K=>{K&&(l.normalTexture=K,1!==q.level&&(l.normalTexture.scale=q.level))})));const J=K.emissiveTexture;J&&(l.emissiveFactor=[1,1,1],F.push(this.exportTextureAsync(J,O).then((K=>{K&&(l.emissiveTexture=K)}))));const c=K.ambientTexture;c&&F.push(this.exportTextureAsync(c,O).then((K=>{if(K){const O={index:K.index};l.occlusionTexture=O}}))),F.length>0&&(this._exporter._materialNeedsUVsSet.add(K),await Promise.all(F))}(K.alpha<1||K.opacityTexture)&&(K.alphaMode===g.c.ALPHA_COMBINE?l.alphaMode="BLEND":r.Tools.Warn(K.name+": glTF 2.0 does not support alpha mode: "+K.alphaMode.toString())),K.emissiveColor&&!K.emissiveColor.equalsWithEpsilon(A,e)&&(l.emissiveFactor=K.emissiveColor.hf()),l.pbrMetallicRoughness=f,G(l,K),await this._finishMaterialAsync(l,K,O);const q=this._exporter._materials;return q.push(l),q.length-1}async _finishMaterialAsync(K,O,F){const f=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",K,O),r=[];for(const l of f)r.push(this.exportTextureAsync(l,F));await Promise.all(r),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",K,O)}async _getImageDataAsync(K,O,f,r){const l=g.c.TEXTURETYPE_UNSIGNED_BYTE,q=this._exporter._babylonScene,J=q.getEngine(),c=J.createRawTexture(K,O,f,g.c.TEXTUREFORMAT_RGBA,!1,!0,d.b.NEAREST_SAMPLINGMODE,null,l);J.isWebGPU?await F.e(51).then(F.bind(F,14207)):await F.e(52).then(F.bind(F,14215)),await L.j.ApplyPostProcess("pass",c,q,l,g.c.TEXTURE_NEAREST_SAMPLINGMODE,g.c.TEXTUREFORMAT_RGBA);const E=await J._readTexturePixels(c,O,f);return await H.DumpTools.DumpDataAsync(O,f,E,r,void 0,!0,!0)}_resizeTexturesToSameDimensions(K,O,F){const f=K?K.getSize():{width:0,height:0},r=O?O.getSize():{width:0,height:0};let l,q;return f.width<r.width?(l=K&&K instanceof d.b?L.j.CreateResizedCopy(K,r.width,r.height,!0):z(r.width,r.height,F),q=O):f.width>r.width?(q=O&&O instanceof d.b?L.j.CreateResizedCopy(O,f.width,f.height,!0):z(f.width,f.height,F),l=K):(l=K,q=O),{texture1:l,texture2:q}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(K,O,F,f){const r=new Array;if(!K&&!O)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const l=K?K.HK():O?O.HK():null;if(l){var q;const J=this._resizeTexturesToSameDimensions(K,O,l),c=null===(q=J.texture1)||void 0===q?void 0:q.getSize();let E,M;const t=c.width,j=c.height,X=await J.texture1.readPixels(),u=await J.texture2.readPixels();if(!X)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(E=m(X),!u)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");M=m(u);const T=M.byteLength,k=new Uint8Array(T),N=new Uint8Array(T),Z=4,L=A;let d=0,a=0;for(let K=0;K<j;++K)for(let O=0;O<t;++O){const f=(t*K+O)*Z,r={diffuseColor:new o.ZO(E[f],E[f+1],E[f+2]).toLinearSpace(l.getEngine().useExactSrgbConversions).multiply(F.diffuseColor),specularColor:new o.ZO(M[f],M[f+1],M[f+2]).toLinearSpace(l.getEngine().useExactSrgbConversions).multiply(F.specularColor),glossiness:M[f+3]*F.glossiness},q=this._convertSpecularGlossinessToMetallicRoughness(r);L.r=Math.max(L.r,q.baseColor.r),L.g=Math.max(L.g,q.baseColor.g),L.b=Math.max(L.b,q.baseColor.b),d=Math.max(d,q.metallic),a=Math.max(a,q.roughness),N[f]=255*q.baseColor.r,N[f+1]=255*q.baseColor.g,N[f+2]=255*q.baseColor.b,N[f+3]=J.texture1.bf?255*E[f+3]:255,k[f]=0,k[f+1]=255*q.roughness,k[f+2]=255*q.metallic,k[f+3]=255}const g={baseColor:L,metallic:d,roughness:a};let H=!1,W=!1;for(let K=0;K<j;++K)for(let O=0;O<t;++O){const F=(t*K+O)*Z;N[F]/=g.baseColor.r>e?g.baseColor.r:1,N[F+1]/=g.baseColor.g>e?g.baseColor.g:1,N[F+2]/=g.baseColor.b>e?g.baseColor.b:1;const f=o.ZO.FromInts(N[F],N[F+1],N[F+2]).toGammaSpace(l.getEngine().useExactSrgbConversions);N[F]=255*f.r,N[F+1]=255*f.g,N[F+2]=255*f.b,f.equalsWithEpsilon(y,e)||(W=!0),k[F+1]/=g.roughness>e?g.roughness:1,k[F+2]/=g.metallic>e?g.metallic:1;o.ZO.FromInts(255,k[F+1],k[F+2]).equalsWithEpsilon(y,e)||(H=!0)}return H&&r.push(this._getImageDataAsync(k,t,j,f).then((K=>{g.metallicRoughnessTextureData=K}))),W&&r.push(this._getImageDataAsync(N,t,j,f).then((K=>{g.baseColorTextureData=K}))),await Promise.all(r).then((()=>g))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(K){const O=this._getPerceivedBrightness(K.diffuseColor),F=this._getPerceivedBrightness(K.specularColor),f=1-this._getMaxComponent(K.specularColor),r=Q(O,F,f),l=K.diffuseColor.scale(f/(1-W.r)/Math.max(1-r)),q=K.specularColor.oO(W.scale(1-r)).scale(1/Math.max(r));let J=o.ZO.Lerp(l,q,r*r);J=J.clampToRef(0,1,J);return{baseColor:J,metallic:r,roughness:1-K.glossiness}}_getPerceivedBrightness(K){return K?Math.sqrt(.299*K.r*K.r+.587*K.g*K.g+.114*K.b*K.b):0}_getMaxComponent(K){return K?Math.max(K.r,Math.max(K.g,K.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(K,O,F,f){const r=[],l={baseColor:K._albedoColor,metallic:K._metallic,roughness:K._roughness};if(f){K._albedoTexture&&r.push(this.exportTextureAsync(K._albedoTexture,O).then((K=>{K&&(F.baseColorTexture=K)})));const f=K._metallicTexture;f&&r.push(this.exportTextureAsync(f,O).then((K=>{K&&(F.metallicRoughnessTexture=K)})))}return r.length>0&&(this._exporter._materialNeedsUVsSet.add(K),await Promise.all(r)),l}_getTextureSampler(K){const O={};if(!K||!(K instanceof d.b))return O;const F=this._getGLTFTextureWrapMode(K.wrapU);10497!==F&&(O.wrapS=F);const f=this._getGLTFTextureWrapMode(K.wrapV);switch(10497!==f&&(O.wrapT=f),K.samplingMode){case d.b.LINEAR_LINEAR:O.magFilter=9729,O.minFilter=9729;break;case d.b.LINEAR_NEAREST:O.magFilter=9729,O.minFilter=9728;break;case d.b.NEAREST_LINEAR:O.magFilter=9728,O.minFilter=9729;break;case d.b.NEAREST_LINEAR_MIPLINEAR:O.magFilter=9728,O.minFilter=9987;break;case d.b.NEAREST_NEAREST:O.magFilter=9728,O.minFilter=9728;break;case d.b.NEAREST_LINEAR_MIPNEAREST:O.magFilter=9728,O.minFilter=9985;break;case d.b.LINEAR_NEAREST_MIPNEAREST:O.magFilter=9729,O.minFilter=9984;break;case d.b.LINEAR_NEAREST_MIPLINEAR:O.magFilter=9729,O.minFilter=9986;break;case d.b.NEAREST_NEAREST_MIPLINEAR:O.magFilter=9728,O.minFilter=9986;break;case d.b.LINEAR_LINEAR_MIPLINEAR:O.magFilter=9729,O.minFilter=9987;break;case d.b.LINEAR_LINEAR_MIPNEAREST:O.magFilter=9729,O.minFilter=9985;break;case d.b.NEAREST_NEAREST_MIPNEAREST:O.magFilter=9728,O.minFilter=9984}return O}_getGLTFTextureWrapMode(K){switch(K){case d.b.WRAP_ADDRESSMODE:return 10497;case d.b.CLAMP_ADDRESSMODE:return 33071;case d.b.MIRROR_ADDRESSMODE:return 33648;default:return r.Tools.Error(`Unsupported Texture Wrap Mode ${K}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(K,O,F,f){const r={diffuseColor:K._albedoColor,specularColor:K._reflectivityColor,glossiness:K._microSurface},l=K._albedoTexture,q=K._reflectivityTexture,J=K._useMicroSurfaceFromReflectivityMapAlpha;if(q&&!J)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((l||q)&&f){this._exporter._materialNeedsUVsSet.add(K);const f=this._exportTextureSampler(l||q),J=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(l,q,r,O),c=this._exporter._textures;if(J.baseColorTextureData){const K=this._exportImage(`baseColor${c.length}`,O,J.baseColorTextureData);F.baseColorTexture=this._exportTextureInfo(K,f,null===l||void 0===l?void 0:l.coordinatesIndex)}if(J.metallicRoughnessTextureData){const K=this._exportImage(`metallicRoughness${c.length}`,O,J.metallicRoughnessTextureData);F.metallicRoughnessTexture=this._exportTextureInfo(K,f,null===q||void 0===q?void 0:q.coordinatesIndex)}return J}return this._convertSpecularGlossinessToMetallicRoughness(r)}async exportPBRMaterialAsync(K,O,F){const f={},r={name:K.name},l=K.isMetallicWorkflow();if(l){const O=K._albedoColor,F=K.alpha;O&&(f.baseColorFactor=[O.r,O.g,O.b,F])}const q=l?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(K,O,f,F):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(K,O,f,F);await this._setMetallicRoughnessPbrMaterialAsync(q,K,r,f,O,F),await this._finishMaterialAsync(r,K,O);const J=this._exporter._materials;return J.push(r),J.length-1}async _setMetallicRoughnessPbrMaterialAsync(K,O,F,f,l,q){if(G(F,O),K.baseColor.equalsWithEpsilon(y,e)&&Z.WithinEpsilon(O.alpha,1,e)||(f.baseColorFactor=[K.baseColor.r,K.baseColor.g,K.baseColor.b,O.alpha]),null!=K.metallic&&1!==K.metallic&&(f.metallicFactor=K.metallic),null!=K.roughness&&1!==K.roughness&&(f.roughnessFactor=K.roughness),null==O.qq||O.qq||(O._twoSidedLighting||r.Tools.Warn(O.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),F.doubleSided=!0),q){const K=[],f=O._bumpTexture;f&&K.push(this.exportTextureAsync(f,l).then((K=>{K&&(F.normalTexture=K,1!==f.level&&(F.normalTexture.scale=f.level))})));const r=O._ambientTexture;r&&K.push(this.exportTextureAsync(r,l).then((K=>{if(K){const f={index:K.index,texCoord:K.texCoord,extensions:K.extensions};F.occlusionTexture=f;const r=O._ambientTextureStrength;r&&(f.strength=r)}})));const q=O._emissiveTexture;q&&K.push(this.exportTextureAsync(q,l).then((K=>{K&&(F.emissiveTexture=K)}))),K.length>0&&(this._exporter._materialNeedsUVsSet.add(O),await Promise.all(K))}const J=O._emissiveColor;J.equalsWithEpsilon(A,e)||(F.emissiveFactor=J.hf()),F.pbrMetallicRoughness=f}_getPixelsFromTextureAsync(K){return function(K){switch(K){case g.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case g.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case g.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case g.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case g.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case g.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case g.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case g.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case g.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case g.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case g.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case g.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case g.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case g.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case g.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case g.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case g.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case g.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case g.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case g.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case g.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(K.textureFormat)?(0,L.h)(K,K._texture.width,K._texture.height):(K.textureType,g.c.TEXTURETYPE_UNSIGNED_BYTE,K.readPixels())}async exportTextureAsync(K,O){const F=this._exporter._extensionsPreExportTextureAsync("exporter",K,O);return F?await F.then((async F=>F?await this._exportTextureInfoAsync(F,O):await this._exportTextureInfoAsync(K,O))):await this._exportTextureInfoAsync(K,O)}async _exportTextureInfoAsync(K,O){let F=this._textureMap.get(K);if(!F){const f=await this._getPixelsFromTextureAsync(K);if(!f)return null;const l=this._exportTextureSampler(K),q=K.mimeType;if(q)switch(q){case"image/jpeg":case"image/png":case"image/webp":O=q;break;default:r.Tools.Warn(`Unsupported media type: ${q}. Exporting texture as PNG.`)}const J=this._internalTextureToImage,c=K.getInternalTexture().uniqueId;J[c]||(J[c]={});let E=J[c][O];if(void 0===E){const F=K.getSize();E=(async()=>{const r=await this._getImageDataAsync(f,F.width,F.height,O);return this._exportImage(K.name,O,r)})(),J[c][O]=E}F=this._exportTextureInfo(await E,l,K.coordinatesIndex),this._textureMap.set(K,F),this._exporter._extensionsPostExportTextures("exporter",F,K)}return F}_exportImage(K,O,F){const f=this._exporter._images;let l;if(this._exporter._shouldUseGlb){l={name:K,mimeType:O,bufferView:void 0};const f=this._exporter._bufferManager.createBufferView(new Uint8Array(F));this._exporter._bufferManager.setBufferView(l,f)}else{const q=K.replace(/\.\/|\/|\.\\|\\/g,"_"),J=function(K){switch(K){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(O);let c=q+J;f.some((K=>K.uri===c))&&(c=`${q}_${r.Tools.RandomId()}${J}`),l={name:K,uri:c},this._exporter._imageData[c]={data:F,mimeType:O}}return f.push(l),f.length-1}_exportTextureInfo(K,O,F){const f=this._exporter._textures;let r=f.findIndex((F=>F.sampler==O&&F.source===K));-1===r&&(r=f.length,f.push({source:K,sampler:O}));const l={index:r};return F&&(l.texCoord=F),l}_exportTextureSampler(K){const O=this._getTextureSampler(K),F=this._exporter._samplers,f=F.findIndex((K=>K.minFilter===O.minFilter&&K.magFilter===O.magFilter&&K.wrapS===O.wrapS&&K.wrapT===O.wrapT));return-1!==f?f:(F.push(O),F.length-1)}}var V=F(11805),v=F(11534),Y=F(12232),B=F(11721);const n=f.TO.Zero(),C=f.Quaternion.Identity(),I=f.TO.One(),D=new f.TO(-1,1,1);function h(K,O){const{byteOffset:F,byteStride:f,type:r,normalized:l}=K,q=K.getSize(),J=O.reduce(((K,O)=>O.getTotalVertices()>K?O.getTotalVertices():K),-Number.MAX_VALUE);return{byteOffset:F,byteStride:f,componentCount:q,type:r,count:J*q,normalized:l,totalVertices:J,kind:K.getKind()}}function b(K){switch(K){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function i(K){switch(K){case M.d.PositionKind:case M.d.NormalKind:case M.d.TangentKind:case M.d.ColorKind:case M.d.MatricesIndicesKind:case M.d.MatricesIndicesExtraKind:case M.d.MatricesWeightsKind:case M.d.MatricesWeightsExtraKind:case M.d.UVKind:case M.d.UV2Kind:case M.d.UV3Kind:case M.d.UV4Kind:case M.d.UV5Kind:case M.d.UV6Kind:return!0}return!1}function w(K){switch(K){case l.e.TriangleFillMode:return 4;case l.e.TriangleStripDrawMode:return 5;case l.e.TriangleFanDrawMode:return 6;case l.e.PointListDrawMode:case l.e.PointFillMode:return 0;case l.e.LineLoopDrawMode:return 2;case l.e.LineListDrawMode:return 1;case l.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${K}`)}function s(K){const O=Math.sqrt(K.x*K.x+K.y*K.y+K.z*K.z);O>0&&(K.x/=O,K.y/=O,K.z/=O)}function U(K){return K.x*=-1,K}function P(K){if(K.x*K.x+K.y*K.y>.5){const O=Math.abs(K.x),F=Math.abs(K.y);if(O>F){const F=Math.sign(K.x);K.x=O,K.y*=-F,K.z*=-F,K.w*=F}else{const O=Math.sign(K.y);K.x*=-O,K.y=F,K.z*=O,K.w*=-O}}else{const O=Math.abs(K.z),F=Math.abs(K.w);if(O>F){const F=Math.sign(K.z);K.x*=-F,K.y*=F,K.z=O,K.w*=-F}else{const O=Math.sign(K.w);K.x*=O,K.y*=-O,K.z*=-O,K.w=F}}return K}function S(K){K.eq(-K.z,K.w,K.x,-K.y)}function KK(K,O){const F=f.TO.FromArrayToRef(O.translation||[0,0,0],0,f.TmpVectors.TO[0]),r=f.Quaternion.FromArrayToRef(O.rotation||[0,0,0,1],0,f.TmpVectors.Quaternion[0]),l=f.Matrix.ComposeToRef(I,r,F,f.TmpVectors.Matrix[0]),q=f.TO.FromArrayToRef(K.translation||[0,0,0],0,f.TmpVectors.TO[2]),J=f.Quaternion.FromArrayToRef(K.rotation||[0,0,0,1],0,f.TmpVectors.Quaternion[1]),c=f.Matrix.ComposeToRef(I,J,q,f.TmpVectors.Matrix[1]);l.multiplyToRef(c,c),c.decompose(void 0,r,F),F.equalsWithEpsilon(n,B.e)?delete O.translation:O.translation=F.hf(),r.equalsWithEpsilon(C,B.e)?delete O.rotation:O.rotation=r.hf(),O.scale&&delete O.scale}function OK(K,O){if(!(O instanceof t.b))return!1;if(!(1===O.getChildren().length&&0===K.getChildren().length&&K.parent===O))return!1;const F=K.HK(),f=K instanceof Y.d&&!F.useRightHandedSystem?D:I;return!!O.TJ.equalsWithEpsilon(f,B.e)||(v.c.Warn(`Cannot collapse node ${K.name} into parent node ${O.name} with modified scaling.`),!1)}function FK(K){if(K instanceof Array){const O=new Float32Array(K);return new Uint8Array(O.buffer,O.byteOffset,O.byteLength)}return ArrayBuffer.isView(K)?new Uint8Array(K.buffer,K.byteOffset,K.byteLength):new Uint8Array(K)}function fK(K,O){for(const[F,f]of Object.entries(K)){const r=O[F];(Array.isArray(f)&&Array.isArray(r)&&rK(f,r)||f===r)&&delete K[F]}return K}function rK(K,O){return K.length===O.length&&K.every(((K,F)=>K===O[F]))}const lK=f.Matrix.Compose(new f.TO(-1,1,1),f.Quaternion.Identity(),f.TO.Zero());function qK(K,O){if(!(K instanceof t.b))return!1;if(O){if(!K.getWorldMatrix().equalsWithEpsilon(f.Matrix.IdentityReadOnly,B.e))return!1}else{if(!K.getWorldMatrix().multiplyToRef(lK,f.TmpVectors.Matrix[0]).equalsWithEpsilon(f.Matrix.IdentityReadOnly,B.e))return!1}return!(K instanceof j.e&&K.hr)}const JK=new Map([[Int8Array,(K,O,F)=>K.setInt8(O,F)],[Uint8Array,(K,O,F)=>K.setUint8(O,F)],[Uint8ClampedArray,(K,O,F)=>K.setUint8(O,F)],[Int16Array,(K,O,F)=>K.setInt16(O,F,!0)],[Uint16Array,(K,O,F)=>K.setUint16(O,F,!0)],[Int32Array,(K,O,F)=>K.setInt32(O,F,!0)],[Uint32Array,(K,O,F)=>K.setUint32(O,F,!0)],[Float32Array,(K,O,F)=>K.setFloat32(O,F,!0)],[Float64Array,(K,O,F)=>K.setFloat64(O,F,!0)]]);class cK{writeTypedArray(K){this._checkGrowBuffer(K.byteLength);const O=JK.get(K.constructor);for(let F=0;F<K.length;F++)O(this._dataView,this._byteOffset,K[F]),this._byteOffset+=K.BYTES_PER_ELEMENT}constructor(K){this._data=new Uint8Array(K),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(K){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,K),this._byteOffset++}writeInt8(K){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,K),this._byteOffset++}writeInt16(K){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,K,!0),this._byteOffset+=2}writeUInt16(K){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,K,!0),this._byteOffset+=2}writeInt32(K){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,K,!0),this._byteOffset+=4}writeUInt32(K){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,K,!0),this._byteOffset+=4}writeFloat32(K){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,K,!0),this._byteOffset+=4}writeFloat64(K){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,K,!0),this._byteOffset+=8}_checkGrowBuffer(K){const O=this.byteOffset+K;if(O>this._data.byteLength){const K=new Uint8Array(2*O);K.set(this._data),this._data=K,this._dataView=new DataView(this._data.buffer)}}}function EK(K){return K%4===0?4:K%2===0?2:1}class MK{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(K){let O=0;this._bufferViewToData.forEach((K=>{O+=K.byteLength}));const F=new cK(O),f=Array.from(this._bufferViewToData.keys()).sort(((K,O)=>EK(O.byteLength)-EK(K.byteLength)));for(const r of f){r.byteOffset=F.byteOffset,K.push(r);const O=K.length-1,f=this.getPropertiesWithBufferView(r);for(const K of f)K.bufferView=O;F.writeTypedArray(this._bufferViewToData.get(r)),this._bufferViewToData.delete(r)}return F.getOutputData()}createBufferView(K,O){const F={buffer:0,byteOffset:void 0,byteLength:K.byteLength,byteStride:O};return this._bufferViewToData.set(F,K),F}createAccessor(K,O,F,f,r,l,q){this._verifyBufferView(K);const J={bufferView:void 0,componentType:F,count:f,type:O,min:null===l||void 0===l?void 0:l.min,max:null===l||void 0===l?void 0:l.max,normalized:q,byteOffset:r};return this.setBufferView(J,K),this._accessorToBufferView.set(J,K),J}setBufferView(K,O){this._verifyBufferView(O);this.getPropertiesWithBufferView(O).push(K)}removeBufferView(K){const O=this.getPropertiesWithBufferView(K);for(const F of O)void 0!==F.bufferView&&delete F.bufferView;this._bufferViewToData.delete(K),this._bufferViewToProperties.delete(K),this._accessorToBufferView.forEach(((O,F)=>{O===K&&(void 0!==F.byteOffset&&delete F.byteOffset,this._accessorToBufferView.delete(F))}))}getBufferView(K){const O=this._accessorToBufferView.get(K);return this._verifyBufferView(O),O}getPropertiesWithBufferView(K){return this._verifyBufferView(K),this._bufferViewToProperties.set(K,this._bufferViewToProperties.get(K)??[]),this._bufferViewToProperties.get(K)}getData(K){return this._verifyBufferView(K),this._bufferViewToData.get(K)}_verifyBufferView(K){if(void 0===K||!this._bufferViewToData.has(K))throw new Error(`BufferView ${K} not found in BufferManager.`)}}var tK,jK=F(12201),XK=F(12215),uK=F(12236),TK=F(12106),oK=F(12266),kK=F(12273),NK=F(12193),ZK=F(12281);!function(K){K[K.INTANGENT=0]="INTANGENT",K[K.OUTTANGENT=1]="OUTTANGENT"}(tK||(tK={}));class LK{static _IsTransformable(K){return K&&(K instanceof t.b||K instanceof jK.e||K instanceof ZK.d)}static _CreateNodeAnimation(K,O,F,f,l){if(this._IsTransformable(K)){const q=[],J=[],c=O.getKeys(),E=LK._CalculateMinMaxKeyFrames(c),M=LK._DeduceInterpolation(c,F,f),t=M.interpolationType,j=M.shouldBakeAnimation;if(j?LK._CreateBakedAnimation(K,O,F,E.min,E.max,O.framePerSecond,l,q,J,E,f):"LINEAR"===t||"STEP"===t?LK._CreateLinearOrStepAnimation(K,O,F,q,J,f):"CUBICSPLINE"===t?LK._CreateCubicSplineAnimation(K,O,F,q,J,f):LK._CreateBakedAnimation(K,O,F,E.min,E.max,O.framePerSecond,l,q,J,E,f),q.length&&J.length){return{inputs:q,outputs:J,samplerInterpolation:t,inputsMin:j?E.min:r.Tools.FloatRound(E.min/O.framePerSecond),inputsMax:j?E.max:r.Tools.FloatRound(E.max/O.framePerSecond)}}}return null}static _DeduceAnimationInfo(K){let O=null,F="VEC3",f=!1;const l=K.targetProperty.split(".");switch(l[0]){case"TJ":O="scale";break;case"position":O="translation";break;case"rotation":F="VEC4",O="rotation";break;case"rotationQuaternion":F="VEC4",f=!0,O="rotation";break;case"influence":F="SCALAR",O="weights";break;default:r.Tools.Error(`Unsupported animatable property ${l[0]}`)}return O?{animationChannelTargetPath:O,dataAccessorType:F,useQuaternion:f}:(r.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(K,O,F,f,r,l,q,J,c,E,M){let t;if(LK._IsTransformable(K)&&K.animations)for(const j of K.animations){if(M&&!M(j))continue;const r=LK._DeduceAnimationInfo(j);r&&(t={name:j.name,samplers:[],channels:[]},LK._AddAnimation(`${j.name}`,j.hasRunningRuntimeAnimations?O:t,K,j,r.dataAccessorType,r.animationChannelTargetPath,f,l,q,J,r.useQuaternion,c,E),t.samplers.length&&t.channels.length&&F.push(t))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(K,O,F,f,r,l,q,J,c,E,M){let t;if(K instanceof NK.b){const r=K.morphTargetManager;if(r)for(let j=0;j<r.numTargets;++j){const X=r.getTarget(j);for(const u of X.animations){if(M&&!M(u))continue;const X=new oK.d(`${u.name}`,"influence",u.framePerSecond,u.dataType,u.loopMode,u.enableBlending),T=[],o=u.getKeys();for(let K=0;K<o.length;++K){const O=o[K];for(let K=0;K<r.numTargets;++K)K==j?T.push(O):T.push({frame:O.frame,value:0})}X.setKeys(T);const k=LK._DeduceAnimationInfo(X);k&&(t={name:X.name,samplers:[],channels:[]},LK._AddAnimation(u.name,u.hasRunningRuntimeAnimations?O:t,K,X,k.dataAccessorType,k.animationChannelTargetPath,f,l,q,J,k.useQuaternion,c,E,r.numTargets),t.samplers.length&&t.channels.length&&F.push(t))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(K,O,F,f,r,l,q,J,c){let E;if(K.animationGroups){const t=K.animationGroups;for(const j of t){const t=new Map,X=new Map,u=new Set,T=j.to-j.from;E={name:j.name,channels:[],samplers:[]};for(let O=0;O<j.targetedAnimations.length;++O){const T=j.targetedAnimations[O],o=T.target,k=T.animation;if(c&&!c(k))continue;const N=J.has(o);if(this._IsTransformable(o)||1===o.length&&this._IsTransformable(o[0])){const K=LK._DeduceAnimationInfo(T.animation);if(K){const O=this._IsTransformable(o)?o:this._IsTransformable(o[0])?o[0]:null;O&&LK._AddAnimation(`${k.name}`,E,O,k,K.dataAccessorType,K.animationChannelTargetPath,F,f,r,l,K.useQuaternion,q,N)}}else if(o instanceof kK.d||1===o.length&&o[0]instanceof kK.d){if(LK._DeduceAnimationInfo(T.animation)){const O=o instanceof kK.d?o:o[0];if(O){const F=K.morphTargetManagers.find((K=>{for(let F=0;F<K.numTargets;++F)if(K.getTarget(F)===O)return!0;return!1}));if(F){const f=K.meshes.find((K=>K.morphTargetManager===F));var M;if(f)t.has(f)||t.set(f,new Map),null===(M=t.get(f))||void 0===M||M.set(O,k),u.add(f),X.set(f,k)}}}}}u.forEach((K=>{const O=K.morphTargetManager;let J=null;const c=[],M=X.get(K).getKeys(),u=M.length;for(let F=0;F<u;++F)for(let f=0;f<O.numTargets;++f){const r=O.getTarget(f),l=t.get(K);if(l){const O=l.get(r);O?(J||(J=new oK.d(`${j.name}_${K.name}_MorphWeightAnimation`,"influence",O.framePerSecond,oK.d.ANIMATIONTYPE_FLOAT,O.loopMode,O.enableBlending)),c.push(O.getKeys()[F])):c.push({frame:j.from+T/u*F,value:r.influence,inTangent:M[0].inTangent?0:void 0,outTangent:M[0].outTangent?0:void 0})}}J.setKeys(c);const o=LK._DeduceAnimationInfo(J);o&&LK._AddAnimation(`${j.name}_${K.name}_MorphWeightAnimation`,E,K,J,o.dataAccessorType,o.animationChannelTargetPath,F,f,r,l,o.useQuaternion,q,!1,null===O||void 0===O?void 0:O.numTargets)})),E.channels.length&&E.samplers.length&&O.push(E)}}}static _AddAnimation(K,O,F,r,l,q,J,c,E,M,t,j,X,u){const T=LK._CreateNodeAnimation(F,r,q,t,j);let o,k,N,Z,L,d;if(T){if(u){let K=0,O=0;const F=[];for(;T.inputs.length>0;)O=T.inputs.shift(),K%u==0&&F.push(O),K++;T.inputs=F}const K=J.get(F),r=new Float32Array(T.inputs);o=c.createBufferView(r),k=c.createAccessor(o,"SCALAR",5126,T.inputs.length,void 0,{min:[T.inputsMin],max:[T.inputsMax]}),M.push(k),N=M.length-1;const E=new f.Quaternion,t=new f.TO,j=new f.TO,a=F instanceof jK.e,g=b(l),H=new Float32Array(T.outputs.length*g);T.outputs.forEach((function(K,O){let F=K;switch(q){case"translation":X&&(f.TO.FromArrayToRef(K,0,j),U(j),j.toArray(F));break;case"rotation":4===K.length?f.Quaternion.FromArrayToRef(K,0,E):(F=new Array(4),f.TO.FromArrayToRef(K,0,t),f.Quaternion.FromEulerVectorToRef(t,E)),X&&(P(E),a&&S(E)),E.toArray(F)}H.set(F,O*g)})),o=c.createBufferView(H),k=c.createAccessor(o,l,5126,T.outputs.length),M.push(k),Z=M.length-1,L={interpolation:T.samplerInterpolation,input:N,output:Z},O.samplers.push(L),d={sampler:O.samplers.length-1,target:{node:K,path:q}},O.channels.push(d)}}static _CreateBakedAnimation(K,O,F,l,q,J,c,E,M,t,j){let X;const u=f.Quaternion.Identity();let T,o=null,k=null,N=null,Z=null,L=null,d=null;t.min=r.Tools.FloatRound(l/J);const a=O.getKeys();for(let f=0,g=a.length;f<g;++f){if(d=null,N=a[f],f+1<g)if(Z=a[f+1],N.value.equals&&N.value.equals(Z.value)||N.value===Z.value){if(0!==f)continue;d=N.frame}else d=Z.frame;else{if(L=a[f-1],N.value.equals&&N.value.equals(L.value)||N.value===L.value)continue;d=q}if(d)for(let f=N.frame;f<=d;f+=c){if(T=r.Tools.FloatRound(f/J),T===o)continue;o=T,k=T;const l={key:0,repeatCount:0,loopMode:O.loopMode};X=O._interpolate(f,l),LK._SetInterpolatedValue(K,X,T,O,F,u,E,M,j)}}k&&(t.max=k)}static _ConvertFactorToVector3OrQuaternion(K,O,F,l,q){const J=LK._GetBasePositionRotationOrScale(O,l,q),c=F.targetProperty.split("."),E=c?c[1]:"",M=q?f.Quaternion.LO(J).normalize():f.TO.LO(J);switch(E){case"x":case"y":case"z":M[E]=K;break;case"w":M.w=K;break;default:r.Tools.Error(`glTFAnimation: Unsupported component name "${E}"!`)}return M}static _SetInterpolatedValue(K,O,F,r,l,q,J,c,E){let M;J.push(F),"weights"!==l?(r.dataType===oK.d.ANIMATIONTYPE_FLOAT&&(O=this._ConvertFactorToVector3OrQuaternion(O,K,r,l,E)),"rotation"===l?(E?q=O:(M=O,f.Quaternion.RotationYawPitchRollToRef(M.y,M.x,M.z,q)),c.push(q.hf())):(M=O,c.push(M.hf()))):c.push([O])}static _CreateLinearOrStepAnimation(K,O,F,f,r,l){for(const q of O.getKeys())f.push(q.frame/O.framePerSecond),LK._AddKeyframeValue(q,O,r,F,K,l)}static _CreateCubicSplineAnimation(K,O,F,f,r,l){O.getKeys().forEach((function(q){f.push(q.frame/O.framePerSecond),LK._AddSplineTangent(tK.INTANGENT,r,F,"CUBICSPLINE",q,l),LK._AddKeyframeValue(q,O,r,F,K,l),LK._AddSplineTangent(tK.OUTTANGENT,r,F,"CUBICSPLINE",q,l)}))}static _GetBasePositionRotationOrScale(K,O,F){let r;if("rotation"===O)if(F){r=(K.rotationQuaternion??f.Quaternion.Identity()).hf()}else{r=(K.rotation??f.TO.Zero()).hf()}else if("translation"===O){r=(K.position??f.TO.Zero()).hf()}else{r=(K.TJ??f.TO.One()).hf()}return r}static _AddKeyframeValue(K,O,F,l,q,J){let c;const E=O.dataType;if(E===oK.d.ANIMATIONTYPE_VECTOR3){let O=K.value.hf();if("rotation"===l){const K=f.TO.LO(O);O=f.Quaternion.RotationYawPitchRoll(K.y,K.x,K.z).hf()}F.push(O)}else if(E===oK.d.ANIMATIONTYPE_FLOAT){if("weights"===l)F.push([K.value]);else if(c=this._ConvertFactorToVector3OrQuaternion(K.value,q,O,l,J),c){if("rotation"===l){const K=J?c:f.Quaternion.RotationYawPitchRoll(c.y,c.x,c.z).normalize();F.push(K.hf())}F.push(c.hf())}}else E===oK.d.ANIMATIONTYPE_QUATERNION?F.push(K.value.normalize().hf()):r.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(K,O,F){let f,r,l=!1;if("rotation"===O&&!F)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let q=0,J=K.length;q<J;++q)if(r=K[q],r.inTangent||r.outTangent)if(f){if("CUBICSPLINE"!==f){f="LINEAR",l=!0;break}}else f="CUBICSPLINE";else if(f){if("CUBICSPLINE"===f||r.interpolation&&1===r.interpolation&&"STEP"!==f){f="LINEAR",l=!0;break}}else f=r.interpolation&&1===r.interpolation?"STEP":"LINEAR";return f||(f="LINEAR"),{interpolationType:f,shouldBakeAnimation:l}}static _AddSplineTangent(K,O,F,r,l,q){let J;const c=K===tK.INTANGENT?l.inTangent:l.outTangent;if("CUBICSPLINE"===r){if("rotation"===F)if(c)if(q)J=c.hf();else{const K=c;J=f.Quaternion.RotationYawPitchRoll(K.y,K.x,K.z).hf()}else J=[0,0,0,0];else J="weights"===F?c?[c]:[0]:c?c.hf():[0,0,0];O.push(J)}}static _CalculateMinMaxKeyFrames(K){let O=1/0,F=-1/0;return K.forEach((function(K){O=Math.min(O,K.frame),F=Math.max(F,K.frame)})),{min:O,max:F}}}function dK(K,O,F,l,q,J){const c={attributes:{},influence:K.influence,name:K.name},E=O.hr;if(!E)return r.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),c;const t=J?-1:1,j=f.TO.Zero();let X=0,u=0;if(K.hasPositions){const l=K.getPositions(),J=E.getVerticesData(M.d.PositionKind);if(J){const K=new Float32Array(J.length),O=[1/0,1/0,1/0],r=[-1/0,-1/0,-1/0];u=J.length/3,X=0;for(let F=X;F<u;++F){const q=f.TO.LO(J,3*F);f.TO.LO(l,3*F).subtractToRef(q,j),j.x*=t,O[0]=Math.min(O[0],j.x),r[0]=Math.max(r[0],j.x),O[1]=Math.min(O[1],j.y),r[1]=Math.max(r[1],j.y),O[2]=Math.min(O[2],j.z),r[2]=Math.max(r[2],j.z),K[3*F]=j.x,K[3*F+1]=j.y,K[3*F+2]=j.z}const E=F.createBufferView(K,12),M=F.createAccessor(E,"VEC3",5126,l.length/3,0,{min:O,max:r});q.push(M),c.attributes.POSITION=q.length-1}else r.Tools.Warn(`Morph target positions for mesh ${O.name} were not exported. Mesh does not have position vertex data`)}if(K.hasNormals){const l=K.getNormals(),J=E.getVerticesData(M.d.NormalKind);if(J){const K=new Float32Array(J.length);u=J.length/3,X=0;for(let F=X;F<u;++F){const O=f.TO.LO(J,3*F).normalize();f.TO.LO(l,3*F).normalize().subtractToRef(O,j),K[3*F]=j.x*t,K[3*F+1]=j.y,K[3*F+2]=j.z}const O=F.createBufferView(K,12),r=F.createAccessor(O,"VEC3",5126,l.length/3,0);q.push(r),c.attributes.NORMAL=q.length-1}else r.Tools.Warn(`Morph target normals for mesh ${O.name} were not exported. Mesh does not have normals vertex data`)}if(K.hasTangents){const l=K.getTangents(),J=E.getVerticesData(M.d.TangentKind);if(J){u=J.length/4;const K=new Float32Array(3*u);X=0;for(let F=X;F<u;++F){const O=f.TO.LO(J,4*F);s(O);const r=f.TO.LO(l,3*F);s(r),r.subtractToRef(O,j),K[3*F]=j.x*t,K[3*F+1]=j.y,K[3*F+2]=j.z}const O=F.createBufferView(K,12),r=F.createAccessor(O,"VEC3",5126,u,0);q.push(r),c.attributes.TANGENT=q.length-1}else r.Tools.Warn(`Morph target tangents for mesh ${O.name} were not exported. Mesh does not have tangents vertex data`)}if(K.hasColors){const l=K.getColors(),J=E.getVerticesData(M.d.ColorKind),t=E.getVertexBuffer(M.d.ColorKind);if(J&&t){const K=t.getSize();u=J.length/K;const O=new Float32Array(u*K);X=0;for(let F=X;F<u;++F)if(3===K){const r=f.TO.LO(J,F*K);f.TO.LO(l,F*K).subtractToRef(r,j),O[3*F]=j.x,O[3*F+1]=j.y,O[3*F+2]=j.z}else if(4===K){const r=new f.Vector4,q=f.Vector4.LO(J,F*K);f.Vector4.LO(l,F*K).subtractToRef(q,r),O[4*F]=r.x,O[4*F+1]=r.y,O[4*F+2]=r.z,O[4*F+3]=r.w}else r.Tools.Warn(`Unsupported number of components for color attribute: ${K}`);const E=F.createBufferView(O,4*K),M=F.createAccessor(E,3===K?"VEC3":"VEC4",5126,u,0);q.push(M),c.attributes.COLOR_0=q.length-1}else r.Tools.Warn(`Morph target colors for mesh ${O.name} were not exported. Mesh does not have colors vertex data`)}return c}var aK=F(12286),gK=F(12133),HK=F(12117),eK=F(11661);class WK{}WK.DEFAULT_COLOR=o.ZO.White(),WK.DEFAULT_WIDTH_ATTENUATED=1,WK.DEFAULT_WIDTH=.1;var pK=F(11939),yK=F(12291);class AK{static ConvertPoints(K,O){if(K.length&&Array.isArray(K)&&"number"===typeof K[0])return[K];if(K.length&&Array.isArray(K[0])&&"number"===typeof K[0][0])return K;if(K.length&&!Array.isArray(K[0])&&K[0]instanceof f.TO){const O=[];for(let F=0;F<K.length;F++){const f=K[F];O.push(f.x,f.y,f.z)}return[O]}if(K.length>0&&Array.isArray(K[0])&&K[0].length>0&&K[0][0]instanceof f.TO){const O=[],F=K;for(const K of F)O.push(K.flatMap((K=>[K.x,K.y,K.z])));return O}if(K instanceof Float32Array){if(null!==O&&void 0!==O&&O.floatArrayStride){const F=[],f=3*O.floatArrayStride;for(let O=0;O<K.length;O+=f){const r=new Array(f);for(let F=0;F<f;F++)r[F]=K[O+F];F.push(r)}return F}return[Array.from(K)]}if(K.length&&K[0]instanceof Float32Array){const O=[];for(const F of K)O.push(Array.from(F));return O}return[]}static OmitZeroLengthPredicate(K,O,F){const f=[];return O.oO(K).lengthSquared()>0&&f.push([K,O]),F.oO(O).lengthSquared()>0&&f.push([O,F]),K.oO(F).lengthSquared()>0&&f.push([F,K]),0===f.length?null:f}static OmitDuplicatesPredicate(K,O,F,f){const r=[];return AK._SearchInPoints(K,O,f)||r.push([K,O]),AK._SearchInPoints(O,F,f)||r.push([O,F]),AK._SearchInPoints(F,K,f)||r.push([F,K]),0===r.length?null:r}static _SearchInPoints(K,O,F){for(const q of F)for(let F=0;F<q.length;F++){var f,r,l;if(null!==(f=q[F])&&void 0!==f&&f.equals(K))if(null!==(r=q[F+1])&&void 0!==r&&r.equals(O)||null!==(l=q[F-1])&&void 0!==l&&l.equals(O))return!0}return!1}static MeshesToLines(K,O){const F=[];for(let r=0;r<K.length;r++){const l=K[r],q=l.getVerticesData(M.d.PositionKind),J=l.br();if(q&&J)for(let K=0,c=0;K<J.length;K++){const E=3*J[c++],M=3*J[c++],t=3*J[c++],j=new f.TO(q[E],q[E+1],q[E+2]),X=new f.TO(q[M],q[M+1],q[M+2]),u=new f.TO(q[t],q[t+1],q[t+2]);if(O){const f=O(j,X,u,F,K,E,l,r,q,J);if(f)for(const K of f)F.push(K)}else F.push([j,X],[X,u],[u,j])}}return F}static ToVector3Array(K){if(Array.isArray(K[0])){const O=[],F=K;for(const K of F){const F=[];for(let O=0;O<K.length;O+=3)F.push(new f.TO(K[O],K[O+1],K[O+2]));O.push(F)}return O}const O=K,F=[];for(let r=0;r<O.length;r+=3)F.push(new f.TO(O[r],O[r+1],O[r+2]));return F}static ToNumberArray(K){return K.flatMap((K=>[K.x,K.y,K.z]))}static GetPointsCountInfo(K){const O=new Array(K.length);let F=0;for(let f=K.length;f--;)O[f]=K[f].length/3,F+=O[f];return{total:F,counts:O}}static GetLineLength(K){if(0===K.length)return 0;let O;O="number"===typeof K[0]?AK.ToVector3Array(K):K;const F=f.TmpVectors.TO[0];let r=0;for(let f=0;f<O.length-1;f++){const K=O[f];r+=O[f+1].subtractToRef(K,F).length()}return r}static GetLineLengthArray(K){const O=new Float32Array(K.length/3);let F=0;for(let f=0,r=K.length/3-1;f<r;f++){let r=K[3*f+0],l=K[3*f+1],q=K[3*f+2];r-=K[3*f+3],l-=K[3*f+4],q-=K[3*f+5];F+=Math.sqrt(r*r+l*l+q*q),O[f+1]=F}return O}static SegmentizeSegmentByCount(K,O,F){const r=[],l=O.oO(K),q=f.TmpVectors.TO[0];q.oJ(F);const J=f.TmpVectors.TO[1];l.divideToRef(q,J);let c=K.clone();r.push(c);for(let f=0;f<F;f++)c=c.clone(),r.push(c.addInPlace(J));return r}static SegmentizeLineBySegmentLength(K,O){const F=K[0]instanceof f.TO?AK.GetLineSegments(K):"number"===typeof K[0]?AK.GetLineSegments(AK.ToVector3Array(K)):K,r=[];for(const f of F)if(f.length>O){const K=AK.SegmentizeSegmentByCount(f.point1,f.point2,Math.ceil(f.length/O));for(const O of K)r.push(O)}else r.push(f.point1),r.push(f.point2);return r}static SegmentizeLineBySegmentCount(K,O){const F="number"===typeof K[0]?AK.ToVector3Array(K):K,f=AK.GetLineLength(F)/O;return AK.SegmentizeLineBySegmentLength(F,f)}static GetLineSegments(K){const O=[];for(let F=0;F<K.length-1;F++){const f=K[F],r=K[F+1],l=r.oO(f).length();O.push({point1:f,point2:r,length:l})}return O}static GetMinMaxSegmentLength(K){const O=AK.GetLineSegments(K).sort((K=>K.length));return{min:O[0].length,max:O[O.length-1].length}}static GetPositionOnLineByVisibility(K,O,F){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const l=O*F;let q=0,J=0;const c=K.length;for(let f=0;f<c;f++){if(l<=q+K[f].length){J=f;break}q+=K[f].length}const E=(l-q)/K[J].length;return K[J].point2.subtractToRef(K[J].point1,f.TmpVectors.TO[0]),f.TmpVectors.TO[1]=f.TmpVectors.TO[0].multiplyByFloats(E,E,E),r||f.TmpVectors.TO[1].addInPlace(K[J].point1),f.TmpVectors.TO[1].clone()}static GetCircleLinePoints(K,O){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:K,l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/O;const q=[];for(let J=0;J<=O;J++)q.push(new f.TO(Math.cos(J*l)*K,Math.sin(J*l)*r,F));return q}static GetBezierLinePoints(K,O,F,f){return pK.c.CreateQuadraticBezier(K,O,F,f).getPoints().flatMap((K=>[K.x,K.y,K.z]))}static GetArrowCap(K,O,F,f,r){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[K.clone(),K.add(O.multiplyByFloats(F,F,F))],widths:[f,r,l,q]}}static GetPointsFromText(K,O,F,f){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const q=[],J=(0,yK.c)(K,O,F,f);for(const c of J){for(const K of c.paths){const O=[],F=K.getPoints();for(const K of F)O.push(K.x,K.y,r);q.push(O)}if(l)for(const K of c.holes){const O=[],F=K.getPoints();for(const K of F)O.push(K.x,K.y,r);q.push(O)}}return q}static Color3toRGBAUint8(K){const O=new Uint8Array(4*K.length);for(let F=0,f=0;F<K.length;F++)O[f++]=255*K[F].r,O[f++]=255*K[F].g,O[f++]=255*K[F].b,O[f++]=255;return O}static CreateColorsTexture(K,O,F,f){const r=f.getEngine().getCaps().maxTextureSize??1,l=O.length>r?r:O.length,q=Math.ceil(O.length/r);q>1&&(O=[...O,...Array(l*q-O.length).fill(O[0])]);const J=AK.Color3toRGBAUint8(O),c=new a.e(J,l,q,u.b.TEXTUREFORMAT_RGBA,f,!1,!0,F);return c.name=K,c}static PrepareEmptyColorsTexture(K){if(!WK.EmptyColorsTexture){const O=new Uint8Array(4);WK.EmptyColorsTexture=new a.e(O,1,1,u.b.TEXTUREFORMAT_RGBA,K,!1,!1,a.e.NEAREST_NEAREST),WK.EmptyColorsTexture.name="grlEmptyColorsTexture"}return WK.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var K;null===(K=WK.EmptyColorsTexture)||void 0===K||K.dispose(),WK.EmptyColorsTexture=null}static BooleanToNumber(K){return K?1:0}}class QK extends HK.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class RK extends gK.c{isCompatible(K){return!0}constructor(K,O,F){var r;F=F||{color:WK.DEFAULT_COLOR};const l=new QK;l.GREASED_LINE_HAS_COLOR=!!F.color&&!F.useColors,l.GREASED_LINE_SIZE_ATTENUATION=F.sizeAttenuation??!1,l.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===F.colorDistributionType,l.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(O??K.HK()).useRightHandedSystem,l.GREASED_LINE_CAMERA_FACING=F.cameraFacing??!0,super(K,RK.GREASED_LINE_MATERIAL_NAME,200,l,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(r=F)||void 0===r?void 0:r.forceGLSL)||RK.ForceGLSL,this._scene=O??K.HK(),this._engine=this._scene.getEngine(),this._cameraFacing=F.cameraFacing??!0,this.visibility=F.visibility??1,this.useDash=F.useDash??!1,this.dashRatio=F.dashRatio??.5,this.dashOffset=F.dashOffset??0,this.width=F.width?F.width:F.sizeAttenuation?WK.DEFAULT_WIDTH_ATTENUATED:WK.DEFAULT_WIDTH,this._sizeAttenuation=F.sizeAttenuation??!1,this.colorMode=F.colorMode??0,this._color=F.color??null,this.useColors=F.useColors??!1,this._colorsDistributionType=F.colorDistributionType??0,this.colorsSampling=F.colorsSampling??a.e.NEAREST_NEAREST,this._colors=F.yK??null,this.dashCount=F.dashCount??1,this.resolution=F.resolution??new f.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),F.colorsTexture?this.colorsTexture=F.colorsTexture:this._colors?this.colorsTexture=AK.CreateColorsTexture(`${K.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??WK.DEFAULT_COLOR,AK.PrepareEmptyColorsTexture(this._scene)),this._engine.Wf.add((()=>{AK.DisposeEmptyColorsTexture()}))}getAttributes(K){K.push("grl_offsets"),K.push("grl_widths"),K.push("grl_colorPointers"),K.push("grl_counters"),this._cameraFacing?(K.push("grl_previousAndSide"),K.push("grl_nextAndCounters")):K.push("grl_slopes")}getSamplers(K){K.push("grl_colors")}getActiveTextures(K){this.colorsTexture&&K.push(this.colorsTexture)}getUniforms(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const O=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&O.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===K&&O.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:O,vertex:this._cameraFacing&&this._isGLSL(K)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(K)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(K){if(this._cameraFacing){K.sf("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||K.sf("viewProjection",this._scene.getTransformMatrix());const O=f.TmpVectors.Vector4[0];O.x=this._aspect,O.y=this._resolution.x,O.z=this._resolution.y,O.w=this.width,K.updateVector4("grl_aspect_resolution_lineWidth",O)}const O=f.TmpVectors.Vector4[0];O.x=AK.BooleanToNumber(this.useDash),O.y=this._dashArray,O.z=this.dashOffset,O.w=this.dashRatio,K.updateVector4("grl_dashOptions",O);const F=f.TmpVectors.Vector4[1];F.x=this.colorMode,F.y=this.visibility,F.z=this.colorsTexture?this.colorsTexture.getSize().width:0,F.w=AK.BooleanToNumber(this.useColors),K.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",F),this._color&&K.updateColor3("grl_singleColor",this._color);const r=this.colorsTexture??WK.EmptyColorsTexture;K.setTexture("grl_colors",r),K.updateFloat2("grl_textureSize",(null===r||void 0===r?void 0:r.getSize().width)??1,(null===r||void 0===r?void 0:r.getSize().height)??1)}prepareDefines(K,O,F){K.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,K.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,K.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,K.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=O.useRightHandedSystem,K.GREASED_LINE_CAMERA_FACING=this._cameraFacing,K.GREASED_LINE_USE_OFFSETS=!!F.offsets}getClassName(){return RK.GREASED_LINE_MATERIAL_NAME}getCustomCode(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(O)?function(K,O){if("vertex"===K){const K={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return O&&(K["!gl_Position\\=viewProjection\\*worldPos;"]="//"),K}return"fragment"===K?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(K,this._cameraFacing):function(K,O){if("vertex"===K){const K={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return O&&(K["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),K}return"fragment"===K?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(K,this._cameraFacing)}dispose(){var K;null===(K=this.colorsTexture)||void 0===K||K.dispose(),super.dispose()}get yK(){return this._colors}set yK(K){this.setColors(K)}setColors(K){var O;let F=arguments.length>1&&void 0!==arguments[1]&&arguments[1],f=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var l;if(this._colors=K,null!==K&&0!==K.length){if(!F||f)if(this.colorsTexture&&r===K.length&&!f){const O=AK.Color3toRGBAUint8(K);this.colorsTexture.update(O)}else{var q;null===(q=this.colorsTexture)||void 0===q||q.dispose(),this.colorsTexture=AK.CreateColorsTexture(`${this._material.name}-colors-texture`,K,this.colorsSampling,this._scene)}}else null===(l=this.colorsTexture)||void 0===l||l.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(K){this._dashCount=K,this._dashArray=1/K}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(K){this._sizeAttenuation=K,this.markAllDefinesAsDirty()}get color(){return this._color}set color(K){this.setColor(K)}setColor(K){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==K||null!==this._color&&null===K?(this._color=K,O||this.markAllDefinesAsDirty()):this._color=K}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(K){this._colorsDistributionType=K,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(K){this._aspect=K.x/K.y,this._resolution=K}serialize(){const K=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(O.yK=this._colors),this._color&&(O.color=this._color),K.greasedLineMaterialOptions=O,K}parse(K,O,F){var f;super.parse(K,O,F);const r=K.greasedLineMaterialOptions;null===(f=this.colorsTexture)||void 0===f||f.dispose(),r.color&&this.setColor(r.color,!0),r.colorDistributionType&&(this.colorsDistributionType=r.colorDistributionType),r.yK&&(this.yK=r.yK),r.colorsSampling&&(this.colorsSampling=r.colorsSampling),r.colorMode&&(this.colorMode=r.colorMode),r.useColors&&(this.useColors=r.useColors),r.visibility&&(this.visibility=r.visibility),r.useDash&&(this.useDash=r.useDash),r.dashCount&&(this.dashCount=r.dashCount),r.dashRatio&&(this.dashRatio=r.dashRatio),r.dashOffset&&(this.dashOffset=r.dashOffset),r.width&&(this.width=r.width),r.sizeAttenuation&&(this.sizeAttenuation=r.sizeAttenuation),r.resolution&&(this.resolution=r.resolution),this.yK?this.colorsTexture=AK.CreateColorsTexture(`${this._material.name}-colors-texture`,this.yK,this.colorsSampling,O):AK.PrepareEmptyColorsTexture(O),this.markAllDefinesAsDirty()}copyTo(K){var O;const F=K;null===(O=F.colorsTexture)||void 0===O||O.dispose(),this._colors&&(F.colorsTexture=AK.CreateColorsTexture(`${F._material.name}-colors-texture`,this._colors,F.colorsSampling,this._scene)),F.setColor(this.color,!0),F.colorsDistributionType=this.colorsDistributionType,F.colorsSampling=this.colorsSampling,F.colorMode=this.colorMode,F.useColors=this.useColors,F.visibility=this.visibility,F.useDash=this.useDash,F.dashCount=this.dashCount,F.dashRatio=this.dashRatio,F.dashOffset=this.dashOffset,F.width=this.width,F.sizeAttenuation=this.sizeAttenuation,F.resolution=this.resolution,F.markAllDefinesAsDirty()}_isGLSL(K){return 0===K||this._forceGLSL}}RK.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",RK.ForceGLSL=!1,(0,eK.g)(`BABYLON.${RK.GREASED_LINE_MATERIAL_NAME}`,RK);var GK=F(12171),zK=F(11539),mK=F(11962),xK=F(11643);class VK extends mK.ShaderMaterial{constructor(K,O,r){const l=O.getEngine(),q=l.isWebGPU&&!(r.forceGLSL||VK.ForceGLSL),J=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];O.useRightHandedSystem&&J.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const c=["position","grl_widths","grl_offsets","grl_colorPointers"];r.cameraFacing?(J.push("GREASED_LINE_CAMERA_FACING"),c.push("grl_previousAndSide","grl_nextAndCounters")):(c.push("grl_slopes"),c.push("grl_counters"));const E=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(q||E.push("world","viewProjection","view","projection"),super(K,O,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:q?["Scene","Mesh"]:void 0,attributes:c,uniforms:E,samplers:q?[]:["grlColors"],defines:J,extraInitializationsAsync:async()=>{q?await Promise.all([F.e(66).then(F.bind(F,14872)),F.e(75).then(F.bind(F,14874))]):await Promise.all([F.e(69).then(F.bind(F,14881)),F.e(76).then(F.bind(F,14889))])},shaderLanguage:q?1:0}),this._color=o.ZO.White(),this._colorsDistributionType=0,this._colorsTexture=null,r=r||{color:WK.DEFAULT_COLOR},this.visibility=r.visibility??1,this.useDash=r.useDash??!1,this.dashRatio=r.dashRatio??.5,this.dashOffset=r.dashOffset??0,this.dashCount=r.dashCount??1,this.width=r.width?r.width:r.sizeAttenuation&&r.cameraFacing?WK.DEFAULT_WIDTH_ATTENUATED:WK.DEFAULT_WIDTH,this.sizeAttenuation=r.sizeAttenuation??!1,this.color=r.color??o.ZO.White(),this.useColors=r.useColors??!1,this.colorsDistributionType=r.colorDistributionType??0,this.colorsSampling=r.colorsSampling??a.e.NEAREST_NEAREST,this.colorMode=r.colorMode??0,this._colors=r.yK??null,this._cameraFacing=r.cameraFacing??!0,this.resolution=r.resolution??new f.Vector2(l.getRenderWidth(),l.getRenderHeight()),r.colorsTexture?this.colorsTexture=r.colorsTexture:this._colors?this.colorsTexture=AK.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,O):(this._color=this._color??WK.DEFAULT_COLOR,this.colorsTexture=AK.PrepareEmptyColorsTexture(O)),q){const K=new xK.d;K.setParameters(),K.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",K)}l.Wf.add((()=>{AK.DisposeEmptyColorsTexture()}))}dispose(){var K;null===(K=this._colorsTexture)||void 0===K||K.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new f.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get yK(){return this._colors}set yK(K){this.setColors(K)}setColors(K){var O;let F=arguments.length>1&&void 0!==arguments[1]&&arguments[1],f=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var l;if(this._colors=K,null!==K&&0!==K.length){if(!F||f)if(this._colorsTexture&&r===K.length&&!f){const O=AK.Color3toRGBAUint8(K);this._colorsTexture.update(O)}else{var q;null===(q=this._colorsTexture)||void 0===q||q.dispose(),this.colorsTexture=AK.CreateColorsTexture(`${this.name}-colors-texture`,K,this.colorsSampling,this.HK())}}else null===(l=this._colorsTexture)||void 0===l||l.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(K){this._colorsTexture=K,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(K){this._width=K,this.setFloat("grlWidth",K)}get useColors(){return this._useColors}set useColors(K){this._useColors=K,this.setFloat("grlUseColors",AK.BooleanToNumber(K))}get colorsSampling(){return this._colorsSampling}set colorsSampling(K){this._colorsSampling=K}get visibility(){return this._visibility}set visibility(K){this._visibility=K,this.setFloat("grlVisibility",K)}get useDash(){return this._useDash}set useDash(K){this._useDash=K,this.setFloat("grlUseDash",AK.BooleanToNumber(K))}get dashOffset(){return this._dashOffset}set dashOffset(K){this._dashOffset=K,this.setFloat("grlDashOffset",K)}get dashRatio(){return this._dashRatio}set dashRatio(K){this._dashRatio=K,this.setFloat("grlDashRatio",K)}get dashCount(){return this._dashCount}set dashCount(K){this._dashCount=K,this._dashArray=1/K,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(K){this._sizeAttenuation=K,this.setFloat("grlSizeAttenuation",AK.BooleanToNumber(K))}get color(){return this._color}set color(K){this.setColor(K)}setColor(K){K=K??WK.DEFAULT_COLOR,this._color=K,this.setColor3("grlColor",K)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(K){this._colorsDistributionType=K,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(K){this._colorMode=K,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(K){this._resolution=K,this.setVector2("grlResolution",K),this.setFloat("grlAspect",K.x/K.y)}serialize(){const K=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(O.yK=this._colors),K.greasedLineMaterialOptions=O,K}parse(K,O,F){var f;const r=K.greasedLineMaterialOptions;null===(f=this._colorsTexture)||void 0===f||f.dispose(),r.color&&(this.color=r.color),r.colorDistributionType&&(this.colorsDistributionType=r.colorDistributionType),r.colorsSampling&&(this.colorsSampling=r.colorsSampling),r.colorMode&&(this.colorMode=r.colorMode),r.useColors&&(this.useColors=r.useColors),r.visibility&&(this.visibility=r.visibility),r.useDash&&(this.useDash=r.useDash),r.dashCount&&(this.dashCount=r.dashCount),r.dashRatio&&(this.dashRatio=r.dashRatio),r.dashOffset&&(this.dashOffset=r.dashOffset),r.width&&(this.width=r.width),r.sizeAttenuation&&(this.sizeAttenuation=r.sizeAttenuation),r.resolution&&(this.resolution=r.resolution),r.yK?this.colorsTexture=AK.CreateColorsTexture(`${this.name}-colors-texture`,r.yK,this.colorsSampling,this.HK()):this.colorsTexture=AK.PrepareEmptyColorsTexture(O),this._cameraFacing=r.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var vK,YK,BK;VK.ForceGLSL=!1,function(K){K[K.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",K[K.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(vK||(vK={})),function(K){K[K.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",K[K.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",K[K.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(YK||(YK={})),function(K){K[K.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",K[K.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",K[K.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",K[K.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",K[K.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(BK||(BK={}));class nK extends NK.b{constructor(K,O,F){super(K,O,null,null,!1,!1),this.name=K,this._options=F,this._lazy=!1,this._updatable=!1,this._engine=O.getEngine(),this._lazy=F.lazy??!1,this._updatable=F.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=F.colorPointers??[],this._widths=F.widths??new Array(F.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(K){let O=0;for(const f of this._points)O+=f.length;const F=O/3*2-this._widths.length;for(let f=0;f<F;f++)this._widths.push(K)}updateLazy(){var K,O;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(K=this._options.ribbonOptions)||void 0===K?void 0:K.smoothShading),!this.GK&&this.refreshBoundingInfo(),null===(O=this.greasedLineMaterial)||void 0===O||O.updateLazy()}addPoints(K,O){for(const F of K)this._points.push(F);this._lazy||this.setPoints(this._points,O)}dispose(K){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(K,O)}isLazy(){return this._lazy}get AK(){return this._uvs}set AK(K){this._uvs=K instanceof Float32Array?K:new Float32Array(K),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(K){this.material instanceof VK&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===K||void 0===K?void 0:K.length)>0),this._offsets=K,this._offsetsBuffer?this._offsetsBuffer.update(K):this._createOffsetsBuffer(K)}get widths(){return this._widths}set widths(K){this._widths=K,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(K)}get colorPointers(){return this._colorPointers}set colorPointers(K){this._colorPointers=K,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(K)}get greasedLineMaterial(){var K,O;if(this.material&&this.material instanceof VK)return this.material;const F=null===(K=this.material)||void 0===K||null===(O=K.pluginManager)||void 0===O?void 0:O.getPlugin(RK.GREASED_LINE_MATERIAL_NAME);return F||void 0}get points(){const K=[];return zK.c.DeepCopy(this._points,K),K}setPoints(K,O){this._points=AK.ConvertPoints(K,(null===O||void 0===O?void 0:O.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==O&&void 0!==O&&O.colorPointers||this._updateColorPointers(),this._setPoints(this._points,O)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,AK:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(K){super.serialize(K),K.type=this.getClassName(),K.lineOptions=this._createLineOptions()}_createVertexBuffers(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new GK.b;return O.WK=this._vertexPositions,O.indices=this._indices,O.AK=this._uvs,K&&(O.pK=[],GK.b.ComputeNormals(this._vertexPositions,this._indices,O.pK)),O.RK(this,this._options.updatable),O}_createOffsetsBuffer(K){const O=this._scene.getEngine(),F=new M.b(O,K,this._updatable,3);this.setVerticesBuffer(F.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=F}}class CK{constructor(K,O){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=K,this.wasAddedByNoopNode=O}getIndicesAccessor(K,O,F,f,r){var l,q,J,c;return null===(l=this._indicesAccessorMap.get(K))||void 0===l||null===(q=l.get(O))||void 0===q||null===(J=q.get(F))||void 0===J||null===(c=J.get(f))||void 0===c?void 0:c.get(r)}setIndicesAccessor(K,O,F,f,r,l){let q=this._indicesAccessorMap.get(K);q||(q=new Map,this._indicesAccessorMap.set(K,q));let J=q.get(O);J||(J=new Map,q.set(O,J));let c=J.get(F);c||(c=new Map,J.set(F,c));let E=c.get(f);E||(E=new Map,c.set(f,E)),E.set(r,l)}pushExportedNode(K){this._exportedNodes.has(K)||this._exportedNodes.add(K)}getNodesSet(){return this._exportedNodes}getVertexBufferView(K){return this._vertexBufferViewMap.get(K)}setVertexBufferView(K,O){this._vertexBufferViewMap.set(K,O)}setRemappedBufferView(K,O,F){this._remappedBufferView.set(K,new Map),this._remappedBufferView.get(K).set(O,F)}getRemappedBufferView(K,O){var F;return null===(F=this._remappedBufferView.get(K))||void 0===F?void 0:F.get(O)}getVertexAccessor(K,O,F){var f,r;return null===(f=this._vertexAccessorMap.get(K))||void 0===f||null===(r=f.get(O))||void 0===r?void 0:r.get(F)}setVertexAccessor(K,O,F,f){let r=this._vertexAccessorMap.get(K);r||(r=new Map,this._vertexAccessorMap.set(K,r));let l=r.get(O);l||(l=new Map,r.set(O,l)),l.set(F,f)}hasVertexColorAlpha(K){return this._vertexMapColorAlpha.get(K)||!1}setHasVertexColorAlpha(K,O){return this._vertexMapColorAlpha.set(K,O)}getMesh(K){return this._meshMap.get(K)}setMesh(K,O){this._meshMap.set(K,O)}bindMorphDataToMesh(K,O){const F=this._meshMorphTargetMap.get(K)||[];this._meshMorphTargetMap.set(K,F),-1===F.indexOf(O)&&F.push(O)}getMorphTargetsFromMesh(K){return this._meshMorphTargetMap.get(K)}}class IK{_ApplyExtension(K,O,F,f){if(F>=O.length)return Promise.resolve(K);const r=f(O[F],K);return r?r.then((async K=>K?await this._ApplyExtension(K,O,F+1,f):null)):this._ApplyExtension(K,O,F+1,f)}_ApplyExtensions(K,O){const F=[];for(const f of IK._ExtensionNames)F.push(this._extensions[f]);return this._ApplyExtension(K,F,0,O)}_extensionsPreExportTextureAsync(K,O,F){return this._ApplyExtensions(O,((O,f)=>O.preExportTextureAsync&&O.preExportTextureAsync(K,f,F)))}_extensionsPostExportNodeAsync(K,O,F,f,r){return this._ApplyExtensions(O,((O,l)=>O.postExportNodeAsync&&O.postExportNodeAsync(K,l,F,f,r,this._bufferManager)))}_extensionsPostExportMaterialAsync(K,O,F){return this._ApplyExtensions(O,((O,f)=>O.postExportMaterialAsync&&O.postExportMaterialAsync(K,f,F)))}_extensionsPostExportMaterialAdditionalTextures(K,O,F){const f=[];for(const r of IK._ExtensionNames){const l=this._extensions[r];l.postExportMaterialAdditionalTextures&&f.push(...l.postExportMaterialAdditionalTextures(K,O,F))}return f}_extensionsPostExportTextures(K,O,F){for(const f of IK._ExtensionNames){const r=this._extensions[f];r.postExportTexture&&r.postExportTexture(K,O,F)}}_extensionsPostExportMeshPrimitive(K){for(const O of IK._ExtensionNames){const F=this._extensions[O];F.postExportMeshPrimitive&&F.postExportMeshPrimitive(K,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const K of IK._ExtensionNames){const O=this._extensions[K];O.preGenerateBinaryAsync&&await O.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(K){for(const O of IK._ExtensionNames){const F=this._extensions[O];F.enabled&&K(F)}}_extensionsOnExporting(){this._forEachExtensions((K=>{var O,F,f;K.wasUsed&&((O=this._glTF).extensionsUsed||(O.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(K.name)&&this._glTF.extensionsUsed.push(K.name),K.required&&((F=this._glTF).extensionsRequired||(F.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(K.name)&&this._glTF.extensionsRequired.push(K.name)),(f=this._glTF).extensions||(f.extensions={}),K.onExporting&&K.onExporting())}))}_loadExtensions(){for(const K of IK._ExtensionNames){const O=IK._ExtensionFactories[K](this);this._extensions[K]=O}}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:T.e.LastCreatedScene,O=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${u.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new x(this),this._extensions={},this._bufferManager=new MK,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!K)throw new Error("No scene available to export");this._babylonScene=K,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:K=>{var O;return null===K||void 0===K||null===(O=K.zf)||void 0===O?void 0:O.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...O},this._loadExtensions()}dispose(){for(const K in this._extensions){this._extensions[K].dispose()}}get options(){return this._options}static RegisterExtension(K,O){IK.UnregisterExtension(K)&&r.Tools.Warn(`Extension with the name ${K} already exists`),IK._ExtensionFactories[K]=O,IK._ExtensionNames.push(K)}static UnregisterExtension(K){if(!IK._ExtensionFactories[K])return!1;delete IK._ExtensionFactories[K];const O=IK._ExtensionNames.indexOf(K);return-1!==O&&IK._ExtensionNames.splice(O,1),!0}_generateJSON(K,O,F){const f={byteLength:K};return f.byteLength&&(this._glTF.buffers=[f]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.kO=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(f.uri=O+".bin"),F?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(K){const O=await this._generateBinaryAsync();this._extensionsOnExporting();const F=this._generateJSON(O.byteLength,K,!0),f=new Blob([O],{type:"application/octet-stream"}),r=K+".gltf",l=K+".bin",q=new E;if(q.files[r]=F,q.files[l]=f,this._imageData)for(const J in this._imageData)q.files[J]=new Blob([this._imageData[J].data],{type:this._imageData[J].mimeType});return q}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(K){const O=K%4;return 0===O?O:4-O}async generateGLBAsync(K){this._shouldUseGlb=!0;const O=await this._generateBinaryAsync();this._extensionsOnExporting();const F=this._generateJSON(O.byteLength),f=K+".glb";let r,l=F.length;if("undefined"!==typeof TextEncoder){r=(new TextEncoder).encode(F),l=r.length}const q=this._getPadding(l),J=this._getPadding(O.byteLength),c=28+l+q+O.byteLength+J,M=new cK(c);if(M.writeUInt32(1179937895),M.writeUInt32(2),M.writeUInt32(c),M.writeUInt32(l+q),M.writeUInt32(1313821514),r)M.writeTypedArray(r);else{const K="_".charCodeAt(0);for(let O=0;O<l;++O){const f=F.charCodeAt(O);f!=F.codePointAt(O)?M.writeUInt8(K):M.writeUInt8(f)}}for(let E=0;E<q;++E)M.writeUInt8(32);M.writeUInt32(O.byteLength+J),M.writeUInt32(5130562),M.writeTypedArray(O);for(let E=0;E<J;++E)M.writeUInt8(0);const t=new E;return t.files[f]=new Blob([M.getOutputData()],{type:"application/octet-stream"}),t}_setNodeTransformation(K,O,F){if(O.getPivotPoint().equalsWithEpsilon(n,B.e)||r.Tools.Warn("Pivot points are not supported in the glTF serializer"),!O.position.equalsWithEpsilon(n,B.e)){const r=f.TmpVectors.TO[0].l(O.position);F&&U(r),K.translation=r.hf()}O.TJ.equalsWithEpsilon(I,B.e)||(K.scale=O.TJ.hf());const l=O.rotationQuaternion||f.Quaternion.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);l.equalsWithEpsilon(C,B.e)||(F&&P(l),K.rotation=l.normalize().hf())}_setCameraTransformation(K,O,F){if(!O.position.equalsWithEpsilon(n,B.e)){const r=f.TmpVectors.TO[0].l(O.position);F&&U(r),K.translation=r.hf()}const r=O.rotationQuaternion||f.Quaternion.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);F&&P(r),this._babylonScene.useRightHandedSystem||S(r),r.equalsWithEpsilon(C,B.e)||(K.rotation=r.hf())}_listAvailableCameras(){for(const K of this._babylonScene.cameras){const O={type:K.mode===jK.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(K.name&&(O.name=K.name),"perspective"===O.type)O.perspective={aspectRatio:K.getEngine().getAspectRatio(K),yfov:K.fovMode===jK.e.FOVMODE_VERTICAL_FIXED?K.fov:K.fov*K.getEngine().getAspectRatio(K),znear:K.if,zfar:K.maxZ};else if("orthographic"===O.type){const F=K.orthoLeft&&K.orthoRight?.5*(K.orthoRight-K.orthoLeft):.5*K.getEngine().getRenderWidth(),f=K.orthoBottom&&K.orthoTop?.5*(K.orthoTop-K.orthoBottom):.5*K.getEngine().getRenderHeight();O.orthographic={xmag:F,ymag:f,znear:K.if,zfar:K.maxZ}}this._camerasMap.set(K,O)}}_exportAndAssignCameras(){const K=Array.from(this._camerasMap.values());for(const O of K){const K=this._nodesCameraMap.get(O);if(void 0!==K){this._cameras.push(O);for(const O of K)O.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const K of this._babylonScene.skeletons){if(K.bones.length<=0)continue;const O={joints:[]};this._skinMap.set(K,O)}}_exportAndAssignSkeletons(){for(const K of this._babylonScene.skeletons){if(K.bones.length<=0)continue;const O=this._skinMap.get(K);if(void 0==O)continue;const F={},f=[];let l=-1;for(let r=0;r<K.bones.length;++r){const O=K.bones[r],f=O.getIndex()??r;-1!==f&&(F[f]=O,f>l&&(l=f))}for(let K=0;K<=l;++K){const l=F[K];f.push(l.getAbsoluteInverseBindMatrix());const q=l.getTransformNode();if(null!==q){const K=this._nodeMap.get(q);q&&null!==K&&void 0!==K?O.joints.push(K):r.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else r.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const q=this._nodesSkinMap.get(O);if(O.joints.length>0&&void 0!==q){const K=64*f.length,F=new Float32Array(K/4);f.forEach(((K,O)=>{F.set(K.m,16*O)}));const r=this._bufferManager.createBufferView(F);this._accessors.push(this._bufferManager.createAccessor(r,"MAT4",5126,f.length)),O.inverseBindMatrices=this._accessors.length-1,this._skins.push(O);for(const O of q)O.skin=this._skins.length-1}}}async _exportSceneAsync(){const K={nodes:[]};if(this._babylonScene.metadata){const O=this._options.metadataSelector(this._babylonScene.metadata);O&&(K.extras=O)}const O=new Array,F=new Array,f=new Array;for(const J of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&qK(J,this._babylonScene.useRightHandedSystem)?f.push(...J.getChildren()):this._babylonScene.useRightHandedSystem?O.push(J):F.push(J);this._listAvailableCameras(),this._listAvailableSkeletons();const r=new CK(!0,!1);K.nodes.push(...await this._exportNodesAsync(F,r));const l=new CK(!1,!1);K.nodes.push(...await this._exportNodesAsync(O,l));const q=new CK(!1,!0);K.nodes.push(...await this._exportNodesAsync(f,q)),K.nodes.length&&this._scenes.push(K),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&LK._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,r.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(K){let O=this._shouldExportNodeMap.get(K);return void 0===O&&(O=this._options.shouldExportNode(K),this._shouldExportNodeMap.set(K,O)),O}async _exportNodesAsync(K,O){const F=new Array;this._exportBuffers(K,O);for(const f of K)await this._exportNodeAsync(f,F,O);return F}_collectBuffers(K,O,F,f,r){if(this._shouldExportNode(K)&&K instanceof j.e&&K.hr){const l=K.hr.getVertexBuffers();if(l)for(const f in l){if(!i(f))continue;const q=l[f];r.setHasVertexColorAlpha(q,K.hasVertexAlpha);const J=q._buffer,c=O.get(J)||[];O.set(J,c),-1===c.indexOf(q)&&c.push(q);const E=F.get(q)||[];F.set(q,E),-1===E.indexOf(K)&&E.push(K)}const q=K.morphTargetManager;if(q)for(let O=0;O<q.numTargets;O++){const F=q.getTarget(O),r=f.get(F)||[];f.set(F,r),-1===r.indexOf(K)&&r.push(K)}}for(const l of K.getChildren())this._collectBuffers(l,O,F,f,r)}_exportBuffers(K,O){const F=new Map,f=new Map,r=new Map;for(const J of K)this._collectBuffers(J,F,f,r,O);const l=Array.from(F.keys());for(const J of l){const K=J.getData();if(!K)throw new Error("Buffer data is not available");const r=F.get(J);if(!r)continue;const l=r[0].byteStride;if(r.some((K=>K.byteStride!==l)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const q=FK(K).slice();for(const O of r){const K=f.get(O),{byteOffset:F,byteStride:r,componentCount:l,type:J,count:c,normalized:E,kind:t}=h(O,K);switch(t){case M.d.NormalKind:case M.d.TangentKind:(0,V.k)(q,F,r,l,J,c,E,(K=>{const O=Math.sqrt(K[0]*K[0]+K[1]*K[1]+K[2]*K[2]);if(O>0){const F=1/O;K[0]*=F,K[1]*=F,K[2]*=F}}));break;case M.d.ColorKind:{const O=K.filter((K=>K.material instanceof TK.NO||null==K.material)).length;if(0==O)break;if(O!=K.length){v.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}J==M.d.UNSIGNED_BYTE&&v.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const f=new o.ZO,t=new o.kJ,j=this._babylonScene.getEngine().useExactSrgbConversions;(0,V.k)(q,F,r,l,J,c,E,(K=>{3===K.length?(f.uF(K,0),f.toLinearSpaceToRef(f,j),f.toArray(K,0)):(t.uF(K,0),t.toLinearSpaceToRef(t,j),t.toArray(K,0))}))}}}if(O.convertToRightHanded){for(const K of r){const O=f.get(K),{byteOffset:F,byteStride:r,componentCount:l,type:J,count:c,normalized:E,kind:t}=h(K,O);switch(t){case M.d.PositionKind:case M.d.NormalKind:case M.d.TangentKind:(0,V.k)(q,F,r,l,J,c,E,(K=>{K[0]=-K[0]}))}}O.convertedToRightHandedBuffers.set(J,q)}const c=this._bufferManager.createBufferView(q,l);O.setVertexBufferView(J,c);const E=new Map;for(const O of r){const K=f.get(O),{kind:F,totalVertices:r}=h(O,K);switch(F){case M.d.MatricesIndicesKind:case M.d.MatricesIndicesExtraKind:if(O.type==M.d.FLOAT){const K=O.getFloatData(r);null!==K&&E.set(O,K)}}}0!==E.size&&v.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const t=Array.from(E.keys());for(const F of t){const K=E.get(F);if(!K)continue;const f=K.some((K=>K>=256)),r=new(f?Uint16Array:Uint8Array)(K.length);for(let O=0;O<K.length;O++)r[O]=K[O];const l=this._bufferManager.createBufferView(r,4*(f?2:1));O.setRemappedBufferView(J,F,l)}}const q=Array.from(r.keys());for(const J of q){const K=r.get(J);if(!K)continue;const F=dK(J,K[0],this._bufferManager,this._bufferViews,this._accessors,O.convertToRightHanded);for(const f of K)O.bindMorphDataToMesh(f,F)}}async _exportNodeAsync(K,O,F){let f=this._nodeMap.get(K);if(void 0!==f)return void(O.includes(f)||O.push(f));const r=await this._createNodeAsync(K,F);if(r){f=this._nodes.length,this._nodes.push(r),this._nodeMap.set(K,f),F.pushExportedNode(K),O.push(f);const l={name:"runtime animations",channels:[],samplers:[]},q=[];this._babylonScene.animationGroups.length||(LK._CreateMorphTargetAnimationFromMorphTargetAnimations(K,l,q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,F.convertToRightHanded,this._options.shouldExportAnimation),K.animations.length&&LK._CreateNodeAnimationFromNodeAnimations(K,l,q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,F.convertToRightHanded,this._options.shouldExportAnimation)),l.channels.length&&l.samplers.length&&this._animations.push(l),q.forEach((K=>{K.channels.length&&K.samplers.length&&this._animations.push(K)}))}const l=r?[]:O;for(const q of K.getChildren())await this._exportNodeAsync(q,l,F);r&&l.length&&(r.children=l)}async _createNodeAsync(K,O){if(!this._shouldExportNode(K))return null;const F={};if(K.name&&(F.name=K.name),K.metadata){const O=this._options.metadataSelector(K.metadata);O&&(F.extras=O)}if(K instanceof t.b&&(this._setNodeTransformation(F,K,O.convertToRightHanded),K instanceof j.e)){const r=K instanceof X.d?K.sourceMesh:K;if(r.Df&&r.Df.length>0&&(F.mesh=await this._exportMeshAsync(r,O)),K.skeleton){const O=this._skinMap.get(K.skeleton);var f;if(void 0!==O)void 0===this._nodesSkinMap.get(O)&&this._nodesSkinMap.set(O,[]),null===(f=this._nodesSkinMap.get(O))||void 0===f||f.push(F)}}if(K instanceof Y.d){const f=this._camerasMap.get(K);if(f){var r;void 0===this._nodesCameraMap.get(f)&&this._nodesCameraMap.set(f,[]),this._setCameraTransformation(F,K,O.convertToRightHanded);const q=K.parent;if(null!==q&&OK(K,q)){const K=this._nodeMap.get(q);if(void 0!==K){var l;const O=this._nodes[K];return KK(F,O),null===(l=this._nodesCameraMap.get(f))||void 0===l||l.push(O),null}}null===(r=this._nodesCameraMap.get(f))||void 0===r||r.push(F)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",F,K,this._nodeMap,O.convertToRightHanded)?F:(v.c.Warn(`Not exporting node ${K.name}`),null)}_exportIndices(K,O,F,f,r,q,J,c,E){let M=K;E.mode=w(q);const t=J!==l.e.CounterClockWiseSideOrientation,j=!c.wasAddedByNoopNode&&t,X=function(K){switch(K){case l.e.TriangleFillMode:case l.e.TriangleStripDrawMode:case l.e.TriangleFanDrawMode:return!0}return!1}(q)&&j;if(X){if(q===l.e.TriangleStripDrawMode||q===l.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");E.mode=w(q);const J=O?new Uint32Array(f):new Uint16Array(f);if(K)for(let O=0;O+2<f;O+=3)J[O]=K[F+O]+r,J[O+1]=K[F+O+2]+r,J[O+2]=K[F+O+1]+r;else for(let K=0;K+2<f;K+=3)J[K]=K,J[K+1]=K+2,J[K+2]=K+1;M=J}else if(K&&0!==r){const l=O?new Uint32Array(f):new Uint16Array(f);for(let O=0;O<f;O++)l[O]=K[F+O]+r;M=l}if(M){let l=c.getIndicesAccessor(K,F,f,r,X);if(void 0===l){const q=function(K,O,F,f){if(K instanceof Uint16Array||K instanceof Uint32Array)return K;if(K instanceof Int32Array)return new Uint32Array(K.buffer,K.byteOffset,K.length);const r=K.slice(O,O+F);return f?new Uint32Array(r):new Uint16Array(r)}(M,0,f,O),J=this._bufferManager.createBufferView(q),E=O?5125:5123;this._accessors.push(this._bufferManager.createAccessor(J,"SCALAR",E,f,0)),l=this._accessors.length-1,c.setIndicesAccessor(K,F,f,r,X,l)}E.indices=l}}_exportVertexBuffer(K,O,F,f,r,l){const q=K.getKind();if(!i(q))return;if(q.startsWith("uv")&&!this._options.exportUnusedUVs&&(!O||!this._materialNeedsUVsSet.has(O)))return;let J=r.getVertexAccessor(K,F,f);if(void 0===J){const O=r.convertedToRightHandedBuffers.get(K._buffer)||K._buffer.getData(),l=q===M.d.PositionKind?function(K,O,F,f){const{byteOffset:r,byteStride:l,type:q,normalized:J}=O,c=O.getSize(),E=new Array(c).fill(1/0),M=new Array(c).fill(-1/0);return(0,V.k)(K,r+F*l,l,c,q,f*c,J,(K=>{for(let O=0;O<c;O++)E[O]=Math.min(E[O],K[O]),M[O]=Math.max(M[O],K[O])})),{min:E,max:M}}(O,K,F,f):void 0,c=(q===M.d.MatricesIndicesKind||q===M.d.MatricesIndicesExtraKind)&&K.type===M.d.FLOAT,E=c?M.d.UNSIGNED_BYTE:K.type,t=c?void 0:K.normalized,j=c?r.getRemappedBufferView(K._buffer,K):r.getVertexBufferView(K._buffer),X=K.byteOffset+F*K.byteStride;this._accessors.push(this._bufferManager.createAccessor(j,function(K,O){if(K==M.d.ColorKind)return O?"VEC4":"VEC3";switch(K){case M.d.PositionKind:case M.d.NormalKind:return"VEC3";case M.d.TangentKind:case M.d.MatricesIndicesKind:case M.d.MatricesIndicesExtraKind:case M.d.MatricesWeightsKind:case M.d.MatricesWeightsExtraKind:return"VEC4";case M.d.UVKind:case M.d.UV2Kind:case M.d.UV3Kind:case M.d.UV4Kind:case M.d.UV5Kind:case M.d.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${K}`)}(q,r.hasVertexColorAlpha(K)),E,f,X,l,t)),J=this._accessors.length-1,r.setVertexAccessor(K,F,f,J)}l.attributes[function(K){switch(K){case M.d.PositionKind:return"POSITION";case M.d.NormalKind:return"NORMAL";case M.d.TangentKind:return"TANGENT";case M.d.ColorKind:return"COLOR_0";case M.d.UVKind:return"TEXCOORD_0";case M.d.UV2Kind:return"TEXCOORD_1";case M.d.UV3Kind:return"TEXCOORD_2";case M.d.UV4Kind:return"TEXCOORD_3";case M.d.UV5Kind:return"TEXCOORD_4";case M.d.UV6Kind:return"TEXCOORD_5";case M.d.MatricesIndicesKind:return"JOINTS_0";case M.d.MatricesIndicesExtraKind:return"JOINTS_1";case M.d.MatricesWeightsKind:return"WEIGHTS_0";case M.d.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${K}`)}(q)]=J}async _exportMaterialAsync(K,O,F,f){let r=this._materialMap.get(K);if(void 0===r){const f=O&&Object.keys(O).some((K=>K.startsWith("uv")));if((K=K instanceof XK.b?K.NJ[F.materialIndex]:K)instanceof uK.c)r=await this._materialExporter.exportPBRMaterialAsync(K,"image/png",f);else{if(!(K instanceof TK.NO))return void v.c.Warn(`Unsupported material '${K.name}' with type ${K.getClassName()}`);r=await this._materialExporter.exportStandardMaterialAsync(K,"image/png",f)}this._materialMap.set(K,r)}f.material=r}async _exportMeshAsync(K,O){var F;let f=O.getMesh(K);if(void 0!==f)return f;const r={primitives:[]};f=this._meshes.length,this._meshes.push(r),O.setMesh(K,f);const q=K.isUnIndexed?null:K.br(),J=null===(F=K.hr)||void 0===F?void 0:F.getVertexBuffers(),c=O.getMorphTargetsFromMesh(K),E=K instanceof aK.b,M=K instanceof nK,t=K.Df;if(J&&t&&t.length>0)for(const u of t){const F={attributes:{}},f=u.VK()||this._babylonScene.defaultMaterial;if(M){var j,X;const O={name:f.name},r=K,l=o.ZO.White(),q=(null===(j=r.material)||void 0===j?void 0:j.alpha)??1,J=(null===(X=r.greasedLineMaterial)||void 0===X?void 0:X.color)??l;(!J.equalsWithEpsilon(l,B.e)||q<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...J.hf(),q]}),this._materials.push(O),F.material=this._materials.length-1}else if(E){const O={name:f.name},r=K;(!r.color.equalsWithEpsilon(o.ZO.White(),B.e)||r.alpha<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...r.color.hf(),r.alpha]}),this._materials.push(O),F.material=this._materials.length-1}else await this._exportMaterialAsync(f,J,u,F);const t=E||M?l.e.LineListDrawMode:K.overrideRenderingFillMode??f.fillMode,T=f._getEffectiveOrientation(K);this._exportIndices(q,q?(0,V.d)(q,u.indexCount,u.indexStart,u.verticesStart):u.verticesCount>65535,q?u.indexStart:u.verticesStart,q?u.indexCount:u.verticesCount,-u.verticesStart,t,T,O,F);for(const K of Object.values(J))this._exportVertexBuffer(K,f,u.verticesStart,u.verticesCount,O,F);if(c){F.targets=[];for(const K of c)F.targets.push(K.attributes)}r.primitives.push(F),this._extensionsPostExportMeshPrimitive(F)}if(c){r.weights=[],r.extras||(r.extras={}),r.extras.targetNames=[];for(const K of c)r.weights.push(K.influence),r.extras.targetNames.push(K.name)}return f}}IK._ExtensionNames=new Array,IK._ExtensionFactories={};class DK{static async GLTFAsync(K,O,F){F&&F.exportWithoutWaitingForScene||await K.whenReadyAsync();const f=new IK(K,F),r=await f.generateGLTFAsync(O.replace(/\.[^/.]+$/,""));return f.dispose(),r}static async GLBAsync(K,O,F){F&&F.exportWithoutWaitingForScene||await K.whenReadyAsync();const f=new IK(K,F),r=await f.generateGLBAsync(O.replace(/\.[^/.]+$/,""));return f.dispose(),r}}F(12301);const hK="EXT_mesh_gpu_instancing";class bK{constructor(K){this.name=hK,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(K,O,F,r,l,q){return await new Promise((K=>{if(O&&F instanceof NK.b&&F.hasThinInstances&&this._exporter){this._wasUsed=!0;const K=f.TO.Zero(),r=f.Quaternion.Identity(),J=f.TO.One(),c=F.thinInstanceGetWorldMatrices(),E=f.TmpVectors.TO[2],M=f.TmpVectors.Quaternion[1],t=f.TmpVectors.TO[3];let j=!1,X=!1,u=!1;const T=new Float32Array(3*F.ZJ),o=new Float32Array(4*F.ZJ),k=new Float32Array(3*F.ZJ);let N=0;for(const O of c)O.decompose(t,M,E),l&&(U(E),P(M)),T.set(E.hf(),3*N),o.set(M.normalize().hf(),4*N),k.set(t.hf(),3*N),j=j||!E.equalsWithEpsilon(K),X=X||!M.equalsWithEpsilon(r),u=u||!t.equalsWithEpsilon(J),N++;const Z={attributes:{}};j&&(Z.attributes.TRANSLATION=this._buildAccessor(T,"VEC3",F.ZJ,q)),X&&(Z.attributes.ROTATION=this._buildAccessor(o,"VEC4",F.ZJ,q)),u&&(Z.attributes.SCALE=this._buildAccessor(k,"VEC3",F.ZJ,q)),O.extensions=O.extensions||{},O.extensions[hK]=Z}K(O)}))}_buildAccessor(K,O,F,f){const r=f.createBufferView(K),l=f.createAccessor(r,O,5126,F);return this._exporter._accessors.push(l),this._exporter._accessors.length-1}}IK.RegisterExtension(hK,(K=>new bK(K)));var iK=F(12310),wK=F(12318),sK=F(12325),UK=F(12332);function PK(K){return K===sK.d.PositionKind?"POSITION":K===sK.d.NormalKind?"NORMAL":K===sK.d.ColorKind?"COLOR":K.startsWith(sK.d.UVKind)?"TEX_COORD":"GENERIC"}const SK={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class KO extends iK.c{static get DefaultAvailable(){return(0,iK.h)(KO.DefaultConfiguration)}static get Default(){return KO._Default??(KO._Default=new KO),KO._Default}static ResetDefault(K){KO._Default&&(K||KO._Default.dispose(),KO._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(K,O){return{module:await(O||DracoEncoderModule)({wasmBinary:K})}}_getWorkerContent(){return`${wK.f}(${wK.g})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:KO.DefaultConfiguration)}async _encodeAsync(K,O,F){const f=F?(0,UK.e)(SK,F):SK;if(this._workerPoolPromise){const F=await this._workerPoolPromise;return await new Promise(((r,l)=>{F.push(((F,q)=>{const J=K=>{F.removeEventListener("error",J),F.removeEventListener("message",c),l(K),q()},c=K=>{"encodeMeshDone"===K.data.id&&(F.removeEventListener("error",J),F.removeEventListener("message",c),r(K.data.encodedMeshData),q())};F.addEventListener("error",J),F.addEventListener("message",c);const E=[];for(const O of K)E.push(O.data.buffer);O&&E.push(O.buffer),F.postMessage({id:"encodeMesh",attributes:K,indices:O,options:f},E)}))}))}if(this._modulePromise){const F=await this._modulePromise;return(0,wK.f)(F.module,K,O,f)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(K,O){if(0==K.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");K instanceof NK.b&&K.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===O||void 0===O?void 0:O.method)&&(v.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),O.method="MESH_SEQUENTIAL_ENCODING");const F=function(K){let O=K.br(void 0,!0);return!O||O instanceof Uint32Array||O instanceof Uint16Array||(O=((0,V.d)(O,O.length)?Uint32Array:Uint16Array).from(O)),O}(K),f=function(K,O){const F=[];for(const f of K.getVerticesDataKinds()){if(null!==O&&void 0!==O&&O.includes(f)){if(f===sK.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const r=K.getVertexBuffer(f),l=r.getSize(),q=(0,V.t)(r.getData(),l,r.type,r.byteOffset,r.byteStride,r.normalized,K.getTotalVertices(),!0);F.push({kind:f,dracoName:PK(f),size:l,data:q})}return F}(K,null===O||void 0===O?void 0:O.excludedAttributes);return await this._encodeAsync(f,F,O)}}KO.DefaultConfiguration={wasmUrl:`${r.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${r.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${r.Tools._DefaultCdnUrl}/draco_encoder.js`},KO._Default=null;const OO="KHR_draco_mesh_compression";class FO{get wasUsed(){return this._wasUsed}constructor(K){this.name=OO,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===K.options.meshCompressionMethod&&KO.DefaultAvailable}dispose(){}postExportMeshPrimitive(K,O,F){if(!this.enabled)return;if(4!==K.mode&&5!==K.mode)return void v.c.Warn("Cannot compress primitive with mode "+K.mode+".");const f=[],r=[];let l=null;if(void 0!==K.indices){const q=F[K.indices],J=O.getBufferView(q);l=O.getData(J).slice(),f.push(J),r.push(q)}const q=[];for(const[M,t]of Object.entries(K.attributes)){const K=F[t],l=O.getBufferView(K),c=b(K.type),E=(0,V.t)(O.getData(l),c,K.componentType,K.byteOffset||0,l.byteStride||(0,V.q)(K.componentType)*c,K.normalized||!1,K.count,!0);q.push({kind:M,dracoName:(J=M,"POSITION"===J?"POSITION":"NORMAL"===J?"NORMAL":J.startsWith("COLOR")?"COLOR":J.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:b(K.type),data:E}),f.push(l),r.push(K)}var J;const c={method:K.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},E=KO.Default._encodeAsync(q,l,c).then((F=>{if(!F)return void v.c.Error("Draco encoding failed for primitive.");const l={bufferView:-1,attributes:F.attributeIds},q=O.createBufferView(F.data);O.setBufferView(l,q);for(const K of f)this._bufferViewsUsed.add(K);for(const K of r)this._accessorsUsed.add(K);K.extensions||(K.extensions={}),K.extensions[OO]=l})).catch((K=>{v.c.Error("Draco encoding failed for primitive: "+K)}));this._encodePromises.push(E),this._wasUsed=!0}async preGenerateBinaryAsync(K){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((O=>{K.getPropertiesWithBufferView(O).every((K=>this._accessorsUsed.has(K)))&&K.removeBufferView(O)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}IK.RegisterExtension(OO,(K=>new FO(K)));var fO=F(12341);const rO="KHR_lights_punctual",lO={name:"",color:[1,1,1],LJ:1,range:Number.MAX_VALUE},qO={innerConeAngle:0,outerConeAngle:Math.PI/4},JO=f.TO.Backward();class cO{constructor(K){this.name=rO,this.enabled=!0,this.required=!1,this._exporter=K}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[rO]=this._lights}async postExportNodeAsync(K,O,F,r,l){return await new Promise((q=>{if(!(F instanceof ZK.d))return void q(O);const J=F.getTypeID()==ZK.d.LIGHTTYPEID_POINTLIGHT?"point":F.getTypeID()==ZK.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":F.getTypeID()==ZK.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!J||!(F instanceof fO.e))return v.c.Warn(`${K}: Light ${F.name} is not supported in ${rO}`),void q(O);if(F.falloffType!==ZK.d.FALLOFF_GLTF&&v.c.Warn(`${K}: Light falloff for ${F.name} does not match the ${rO} specification!`),!F.position.equalsToFloats(0,0,0)){const K=f.TmpVectors.TO[0].l(F.position);l&&U(K),O.translation=K.hf()}if("point"!==J){const K=F.direction.normalizeToRef(f.TmpVectors.TO[0]);l&&U(K);const r=f.Quaternion.FromUnitVectorsToRef(JO,K,f.TmpVectors.Quaternion[0]);f.Quaternion.IsIdentity(r)||(O.rotation=r.hf())}const c={type:J,name:F.name,color:F.dJ.hf(),LJ:F.LJ,range:F.range};if(fK(c,lO),"spot"===J){const K=F;c.spot={innerConeAngle:K.innerAngle/2,outerConeAngle:K.angle/2},fK(c.spot,qO)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(c);const E={Lf:this._lights.lights.length-1},M=F.parent;if(M&&OK(F,M)){const K=r.get(M);if(K){const F=this._exporter._nodes[K];return KK(O,F),F.extensions||(F.extensions={}),F.extensions[rO]=E,void q(null)}}O.extensions||(O.extensions={}),O.extensions[rO]=E,q(O)}))}}IK.RegisterExtension(rO,(K=>new cO(K)));var EO=F(12248);const MO="KHR_materials_anisotropy";class tO{constructor(K){this.name=MO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,O,F){const f=[];return F instanceof EO.d&&F.anisotropy.isEnabled&&!F.anisotropy.legacy?(F.anisotropy.texture&&f.push(F.anisotropy.texture),f):[]}postExportMaterialAsync(K,O,F){return new Promise((K=>{if(F instanceof EO.d){if(!F.anisotropy.isEnabled||F.anisotropy.legacy)return void K(O);this._wasUsed=!0,O.extensions=O.extensions||{};const f=this._exporter._materialExporter.getTextureInfo(F.anisotropy.texture),r={anisotropyStrength:F.anisotropy.LJ,anisotropyRotation:F.anisotropy.angle,anisotropyTexture:f??void 0};null!==r.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(F),O.extensions[MO]=r}K(O)}))}}IK.RegisterExtension(MO,(K=>new tO(K)));const jO="KHR_materials_clearcoat";class XO{constructor(K){this.name=jO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,O,F){const f=[];return F instanceof EO.d&&F.clearCoat.isEnabled?(F.clearCoat.texture&&f.push(F.clearCoat.texture),!F.clearCoat.useRoughnessFromMainTexture&&F.clearCoat.textureRoughness&&f.push(F.clearCoat.textureRoughness),F.clearCoat.bumpTexture&&f.push(F.clearCoat.bumpTexture),f):[]}postExportMaterialAsync(K,O,F){return new Promise((K=>{if(F instanceof EO.d){if(!F.clearCoat.isEnabled)return void K(O);this._wasUsed=!0,O.extensions=O.extensions||{};const f=this._exporter._materialExporter.getTextureInfo(F.clearCoat.texture);let l;l=F.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(F.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(F.clearCoat.textureRoughness),F.clearCoat.isTintEnabled&&r.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${F.name}`),F.clearCoat.remapF0OnInterfaceChange&&r.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${F.name}`);const q=this._exporter._materialExporter.getTextureInfo(F.clearCoat.bumpTexture),J={clearcoatFactor:F.clearCoat.LJ,clearcoatTexture:f??void 0,clearcoatRoughnessFactor:F.clearCoat.roughness,clearcoatRoughnessTexture:l??void 0,clearcoatNormalTexture:q??void 0};null===J.clearcoatTexture&&null===J.clearcoatRoughnessTexture&&null===J.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(F),O.extensions[jO]=J}K(O)}))}}IK.RegisterExtension(jO,(K=>new XO(K)));const uO="KHR_materials_diffuse_transmission";function TO(K,O){const F=O.subSurface;let f=null;return F.translucencyIntensityTexture?f=F.translucencyIntensityTexture:F.thicknessTexture&&F.useMaskFromThicknessTexture&&(f=F.thicknessTexture),f&&!F.useGltfStyleTextures?(v.c.Warn(`${K}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${O.name}`,1),null):f}class oO{constructor(K){this.name=uO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,O,F){const f=[];if(F instanceof uK.c&&this._isExtensionEnabled(F)){const O=TO(K,F);return O&&f.push(O),F.subSurface.translucencyColorTexture&&f.push(F.subSurface.translucencyColorTexture),f}return f}_isExtensionEnabled(K){if(K.unlit)return!1;const O=K.subSurface;return!!O.isTranslucencyEnabled&&(!K.unlit&&!O.useAlbedoToTintTranslucency&&O.useGltfStyleTextures&&1===O.volumeIndexOfRefraction&&0===O.minimumThickness&&0===O.maximumThickness)}postExportMaterialAsync(K,O,F){return new Promise((f=>{if(F instanceof uK.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const f=F.subSurface,r=TO(K,F),l=0==f.translucencyIntensity?void 0:f.translucencyIntensity,q=this._exporter._materialExporter.getTextureInfo(r)??void 0,J=!f.translucencyColor||f.translucencyColor.equalsFloats(1,1,1)?void 0:f.translucencyColor.hf(),c=this._exporter._materialExporter.getTextureInfo(f.translucencyColorTexture)??void 0,E={diffuseTransmissionFactor:l,diffuseTransmissionTexture:q,diffuseTransmissionColorFactor:J,diffuseTransmissionColorTexture:c};(q||c)&&this._exporter._materialNeedsUVsSet.add(F),O.extensions=O.extensions||{},O.extensions[uO]=E}f(O)}))}}IK.RegisterExtension(uO,(K=>new oO(K)));const kO="KHR_materials_dispersion";class NO{constructor(){this.name=kO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(K){if(K.unlit)return!1;const O=K.subSurface;return!(!O.isRefractionEnabled&&!O.isDispersionEnabled)}postExportMaterialAsync(K,O,F){return new Promise((K=>{if(F instanceof uK.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const K={dispersion:F.subSurface.dispersion};O.extensions=O.extensions||{},O.extensions[kO]=K}K(O)}))}}IK.RegisterExtension(kO,(()=>new NO));const ZO="KHR_materials_emissive_strength";class LO{constructor(){this.name=ZO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(K,O,F){return await new Promise((K=>{if(!(F instanceof uK.c))return K(O);const f=F.emissiveColor.hf(),r=Math.max(...f);if(r>1){this._wasUsed=!0,O.extensions||(O.extensions={});const K={emissiveStrength:r},f=F.emissiveColor.scale(1/K.emissiveStrength);O.emissiveFactor=f.hf(),O.extensions[ZO]=K}return K(O)}))}}IK.RegisterExtension(ZO,(K=>new LO));const dO="KHR_materials_ior";class aO{constructor(){this.name=dO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(K){return!K.unlit&&(void 0!=K.indexOfRefraction&&1.5!=K.indexOfRefraction)}postExportMaterialAsync(K,O,F){return new Promise((K=>{if(F instanceof uK.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const K={ior:F.indexOfRefraction};O.extensions=O.extensions||{},O.extensions[dO]=K}K(O)}))}}IK.RegisterExtension(dO,(K=>new aO));const gO="KHR_materials_iridescence";class HO{constructor(K){this.name=gO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,O,F){const f=[];return F instanceof EO.d&&F.iridescence.isEnabled?(F.iridescence.texture&&f.push(F.iridescence.texture),F.iridescence.thicknessTexture&&F.iridescence.thicknessTexture!==F.iridescence.texture&&f.push(F.iridescence.thicknessTexture),f):[]}postExportMaterialAsync(K,O,F){return new Promise((K=>{if(F instanceof EO.d){if(!F.iridescence.isEnabled)return void K(O);this._wasUsed=!0,O.extensions=O.extensions||{};const f=this._exporter._materialExporter.getTextureInfo(F.iridescence.texture),r=this._exporter._materialExporter.getTextureInfo(F.iridescence.thicknessTexture),l={iridescenceFactor:F.iridescence.LJ,iridescenceIor:F.iridescence.indexOfRefraction,iridescenceThicknessMinimum:F.iridescence.minimumThickness,iridescenceThicknessMaximum:F.iridescence.maximumThickness,iridescenceTexture:f??void 0,iridescenceThicknessTexture:r??void 0};null===l.iridescenceTexture&&null===l.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(F),O.extensions[gO]=l}K(O)}))}}IK.RegisterExtension(gO,(K=>new HO(K)));const eO="KHR_materials_sheen";class WO{constructor(K){this.name=eO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,O,F){return F instanceof uK.c&&F.sheen.isEnabled&&F.sheen.texture?[F.sheen.texture]:[]}async postExportMaterialAsync(K,O,F){return await new Promise((K=>{if(F instanceof uK.c){if(!F.sheen.isEnabled)return void K(O);this._wasUsed=!0,null==O.extensions&&(O.extensions={});const f={sheenColorFactor:F.sheen.color.hf(),sheenRoughnessFactor:F.sheen.roughness??0};null===f.sheenColorTexture&&null===f.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(F),F.sheen.texture&&(f.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(F.sheen.texture)??void 0),F.sheen.textureRoughness&&!F.sheen.useRoughnessFromMainTexture?f.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(F.sheen.textureRoughness)??void 0:F.sheen.texture&&F.sheen.useRoughnessFromMainTexture&&(f.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(F.sheen.texture)??void 0),O.extensions[eO]=f}K(O)}))}}IK.RegisterExtension(eO,(K=>new WO(K)));const pO="KHR_materials_specular";class yO{constructor(K){this.name=pO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,O,F){const f=[];return F instanceof uK.c&&this._isExtensionEnabled(F)?(F.metallicReflectanceTexture&&f.push(F.metallicReflectanceTexture),F.reflectanceTexture&&f.push(F.reflectanceTexture),f):f}_isExtensionEnabled(K){return!K.unlit&&(void 0!=K.metallicF0Factor&&1!=K.metallicF0Factor||void 0!=K.metallicReflectanceColor&&!K.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(K))}_hasTexturesExtension(K){return null!=K.metallicReflectanceTexture||null!=K.reflectanceTexture}postExportMaterialAsync(K,O,F){return new Promise((K=>{if(F instanceof uK.c&&this._isExtensionEnabled(F)){this._wasUsed=!0,O.extensions=O.extensions||{};const K=this._exporter._materialExporter.getTextureInfo(F.metallicReflectanceTexture)??void 0,f=this._exporter._materialExporter.getTextureInfo(F.reflectanceTexture)??void 0,r={specularFactor:1==F.metallicF0Factor?void 0:F.metallicF0Factor,specularTexture:K,specularColorFactor:F.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:F.metallicReflectanceColor.hf(),specularColorTexture:f};this._hasTexturesExtension(F)&&this._exporter._materialNeedsUVsSet.add(F),O.extensions[pO]=r}K(O)}))}}IK.RegisterExtension(pO,(K=>new yO(K)));const AO="KHR_materials_transmission";class QO{constructor(K){this.name=AO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,O,F){const f=[];return F instanceof uK.c&&this._isExtensionEnabled(F)?(F.subSurface.thicknessTexture&&f.push(F.subSurface.thicknessTexture),f):f}_isExtensionEnabled(K){if(K.unlit)return!1;const O=K.subSurface;return O.isRefractionEnabled&&void 0!=O.refractionIntensity&&0!=O.refractionIntensity||this._hasTexturesExtension(K)}_hasTexturesExtension(K){return null!=K.subSurface.refractionIntensityTexture}async postExportMaterialAsync(K,O,F){if(F instanceof uK.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const f=F.subSurface,r={transmissionFactor:0===f.refractionIntensity?void 0:f.refractionIntensity};if(this._hasTexturesExtension(F)&&this._exporter._materialNeedsUVsSet.add(F),f.refractionIntensityTexture)if(f.useGltfStyleTextures){const K=await this._exporter._materialExporter.exportTextureAsync(f.refractionIntensityTexture,"image/png");K&&(r.transmissionTexture=K)}else v.c.Warn(`${K}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);O.extensions||(O.extensions={}),O.extensions[AO]=r}return O}}IK.RegisterExtension(AO,(K=>new QO(K)));const RO="KHR_materials_unlit";class GO{constructor(){this.name=RO,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(K,O,F){return new Promise((K=>{let f=!1;F instanceof uK.c?f=F.unlit:F instanceof TK.NO&&(f=F.disableLighting),f&&(this._wasUsed=!0,null==O.extensions&&(O.extensions={}),O.extensions[RO]={}),K(O)}))}}IK.RegisterExtension(RO,(()=>new GO));const zO="KHR_materials_volume";class mO{constructor(K){this.name=zO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,O,F){const f=[];return F instanceof uK.c&&this._isExtensionEnabled(F)?(F.subSurface.thicknessTexture&&f.push(F.subSurface.thicknessTexture),f):f}_isExtensionEnabled(K){if(K.unlit)return!1;const O=K.subSurface;return!(!O.isRefractionEnabled&&!O.isTranslucencyEnabled)&&(void 0!=O.maximumThickness&&0!=O.maximumThickness||void 0!=O.tintColorAtDistance&&O.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=O.tintColor&&O.tintColor!=o.ZO.White()||this._hasTexturesExtension(K))}_hasTexturesExtension(K){return null!=K.subSurface.thicknessTexture}postExportMaterialAsync(K,O,F){return new Promise((K=>{if(F instanceof uK.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const K=F.subSurface,f={thicknessFactor:0==K.maximumThickness?void 0:K.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(K.thicknessTexture)??void 0,attenuationDistance:K.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:K.tintColorAtDistance,attenuationColor:K.tintColor.equalsFloats(1,1,1)?void 0:K.tintColor.hf()};this._hasTexturesExtension(F)&&this._exporter._materialNeedsUVsSet.add(F),O.extensions=O.extensions||{},O.extensions[zO]=f}K(O)}))}}IK.RegisterExtension(zO,(K=>new mO(K)));const xO="EXT_materials_diffuse_roughness";class VO{constructor(K){this.name=xO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=K}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(K,O,F){const f=[];return F instanceof EO.d&&F._baseDiffuseRoughness?(F._baseDiffuseRoughnessTexture&&f.push(F._baseDiffuseRoughnessTexture),f):[]}postExportMaterialAsync(K,O,F){return new Promise((K=>{if(F instanceof EO.d){if(!F._baseDiffuseRoughness)return void K(O);this._wasUsed=!0,O.extensions=O.extensions||{};const f=this._exporter._materialExporter.getTextureInfo(F._baseDiffuseRoughnessTexture),r={diffuseRoughnessFactor:F._baseDiffuseRoughness,diffuseRoughnessTexture:f??void 0};null!==r.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(F),O.extensions[xO]=r}K(O)}))}}IK.RegisterExtension(xO,(K=>new VO(K)));const vO="KHR_texture_transform";class YO{constructor(){this.name=vO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(K,O,F){if(F.HK()||r.Tools.Warn(`${K}: /*@__KEY__*/"scene" is not defined for Babylon texture ${F.name}!`),(0!==F.uAng||0!==F.vAng)&&(r.Tools.Warn(`${K}: Texture ${F.name} with rotation in the u or v axis is not supported in glTF.`),0!==F.uRotationCenter||0!==F.vRotationCenter))return;const f={};let l=!1;if(0===F.uOffset&&0===F.vOffset||(f.offset=[F.uOffset,F.vOffset],l=!0),1===F.uScale&&1===F.vScale||(f.scale=[F.uScale,F.vScale],l=!0),0!==F.wAng){if(0!==F.uRotationCenter||0!==F.vRotationCenter){if(F.homogeneousRotationInUVTransform&&F.uScale!==F.vScale)return void r.Tools.Warn(`${K}: Texture ${F.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${vO}.`);r.Tools.Warn(`${K}: Texture ${F.name} with non-origin rotation center will be exported using an adjusted offset with ${vO}.`),f.offset=function(K){const{uOffset:O,vOffset:F,uRotationCenter:f,vRotationCenter:r,uScale:l,vScale:q,wAng:J}=K,c=Math.cos(J),E=Math.sin(J),M=f*l,t=r*q;return[O+(M*(1-c)+t*E),F+(t*(1-c)-M*E)]}(F)}f.rotation=-F.wAng,l=!0}0!==F.coordinatesIndex&&(f.texCoord=F.coordinatesIndex,l=!0),l&&(this._wasUsed=!0,O.extensions||(O.extensions={}),O.extensions[vO]=f)}}IK.RegisterExtension(vO,(()=>new YO));class BO{static CreateSTL(K){let O=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],l=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],q=arguments.length>5&&void 0!==arguments[5]&&arguments[5],J=arguments.length>6&&void 0!==arguments[6]&&arguments[6],c=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const E=function(K,O,F){const r=[3*K[F],3*K[F+1],3*K[F+2]],l=[new f.TO(O[r[0]],O[r[0]+2],O[r[0]+1]),new f.TO(O[r[1]],O[r[1]+2],O[r[1]+1]),new f.TO(O[r[2]],O[r[2]+2],O[r[2]+1])],q=l[0].oO(l[1]),J=l[2].oO(l[1]);return{v:l,n:f.TO.Cross(J,q).normalize()}},t=function(K,O,F,f){return O=j(K,O,F.x,f),O=j(K,O,F.y,f),j(K,O,F.z,f)},j=function(K,O,F,f){return K.setFloat32(O,F,f),O+4},u=function(K){if(J){let O=K;K instanceof X.d&&(O=K.sourceMesh);const F=O.getVerticesData(M.d.PositionKind,!0,!0);if(!F)return[];const r=f.TO.Zero();let l;for(l=0;l<F.length;l+=3)f.TO.TransformCoordinatesFromFloatsToRef(F[l],F[l+1],F[l+2],K.Pf(!0),r).toArray(F,l);return F}return K.getVerticesData(M.d.PositionKind)||[]};J&&(q=!0);let T="",o=0,k=0;if(r){for(let F=0;F<K.length;F++){const O=K[F].br();o+=O?O.length/3:0}const O=new ArrayBuffer(84+50*o);T=new DataView(O),k+=80,T.setUint32(k,o,l),k+=4}else c||(T="solid stlmesh\r\n");for(let f=0;f<K.length;f++){const O=K[f];!r&&c&&(T+="solid "+O.name+"\r\n"),!q&&O instanceof NK.b&&O.bakeCurrentTransformIntoVertices();const F=u(O),J=O.br()||[];for(let K=0;K<J.length;K+=3){const O=E(J,F,K);r?(k=t(T,k,O.n,l),k=t(T,k,O.v[0],l),k=t(T,k,O.v[1],l),k=t(T,k,O.v[2],l),k+=2):(T+="\tfacet normal "+O.n.x+" "+O.n.y+" "+O.n.z+"\r\n",T+="\t\touter loop\r\n",T+="\t\t\tvertex "+O.v[0].x+" "+O.v[0].y+" "+O.v[0].z+"\r\n",T+="\t\t\tvertex "+O.v[1].x+" "+O.v[1].y+" "+O.v[1].z+"\r\n",T+="\t\t\tvertex "+O.v[2].x+" "+O.v[2].y+" "+O.v[2].z+"\r\n",T+="\t\tendloop\r\n",T+="\tendfacet\r\n")}!r&&c&&(T+="endsolid "+name+"\r\n")}if(r||c||(T+="endsolid stlmesh"),O){const K=document.createElement("a"),O=new Blob([T],{type:"application/octet-stream"});K.href=window.URL.createObjectURL(O),K.download=F+".stl",K.click()}return T}}function nO(K,O){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const f=[];for(let r=0;r<K.length/F;r++){const l=K[r*F],q=K[r*F+1],J=K[r*F+2];f.push(`(${l.toPrecision(O.precision)}, ${q.toPrecision(O.precision)}, ${J.toPrecision(O.precision)})`)}return f.join(", ")}function CO(K,O){const F=[];for(let f=0;f<K.length/2;f++){const r=K[2*f],l=K[2*f+1];F.push(`(${r.toPrecision(O.precision)}, ${(1-l).toPrecision(O.precision)})`)}return F.join(", ")}function IO(K,O){const F=K.getVerticesData(M.d.PositionKind),f=K.getVerticesData(M.d.NormalKind);if(F&&f)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(K){var O;const F=null!==(O=K.br())&&void 0!==O&&O.length?K.getTotalIndices():K.getTotalVertices();return Array(F/3).fill(3).join(", ")}(K)}]\n\t\tint[] faceVertexIndices = [${function(K){const O=K.br(),F=[];if(null!==O)for(let f=0;f<O.length;f++)F.push(O[f]);else{const O=K.getTotalVertices();for(let K=0;K<O;K++)F.push(K)}return F.join(", ")}(K)}]\n\t\tnormal3f[] normals = [${nO(f,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${nO(F,O)}]\n        ${function(K,O){let F="";for(let r=0;r<4;r++){const f=r>0?r:"",l=K.getVerticesData(M.d.UVKind+(f?f+1:""));l&&(F+=`\n\t\ttexCoord2f[] primvars:st${f} = [${CO(l,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const f=K.getVerticesData(M.d.ColorKind);return f&&(F+=`\n\tcolor3f[] primvars:displayColor = [${nO(f,O,f.length/K.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),F}(K,O)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function DO(K,O){return`\n        def "Geometry"\n        {\n        ${IO(K,O)}\n        }\n        `}function hO(K){let O='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return O+=K,fflate.strToU8(O)}function bO(K){const O=K.m;return`( ${iO(O,0)}, ${iO(O,4)}, ${iO(O,8)}, ${iO(O,12)} )`}function iO(K,O){return`(${K[O+0]}, ${K[O+1]}, ${K[O+2]}, ${K[O+3]})`}function wO(K){const O="Object_"+K.uniqueId,F=function(K){const O=K.getWorldMatrix().clone(),F=K.HK().useRightHandedSystem;if(!F){let f=K.parent;for(;f;){if(qK(f,F)){O.multiplyToRef(f.getWorldMatrix().invert(),O);break}f=f.parent}}return O.determinant()<0&&r.Tools.Warn(`Exporting mesh ${K.name} with negative scale. Result may look incorrect in destination engine.`),O}(K),f=bO(F);return`def Xform "${O}" (\n\tprepend references = @./geometries/Geometry_${K.hr.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${f}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${K.material.uniqueId}>\n}\n\n`}function sO(K){switch(K){case g.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case g.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case g.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function UO(K){return`(${K.x}, ${K.y})`}function PO(K){return`(${K.r}, ${K.g}, ${K.b})`}function SO(K,O,F,r,l,q){const J=K.getInternalTexture().uniqueId+"_"+K.invertY;l[J]=K;const c=K.coordinatesIndex>0?"st"+K.coordinatesIndex:"st",E=new f.Vector2(K.uScale,K.vScale),M=new f.Vector2(K.uOffset,K.vOffset),t=K.wAng,j=Math.sin(t),X=Math.cos(t);return M.y=1-M.y-E.y,M.x+=j*E.x,M.y+=(1-X)*E.y,`\n    def Shader "PrimvarReader_${F}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${c}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${F}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${O.uniqueId}/PrimvarReader_${F}.outputs:result>\n        float inputs:rotation = ${(t*(180/Math.PI)).toFixed(q.precision)}\n        float2 inputs:scale = ${UO(E)}\n        float2 inputs:translation = ${UO(M)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${K.uniqueId}_${F}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${J}.png@\n        float2 inputs:st.connect = </Materials/Material_${O.uniqueId}/Transform2d_${F}.outputs:result>\n        ${r?"float4 inputs:scale = "+function(K){return`(${K.r}, ${K.g}, ${K.b}, 1.0)`}(r):""}\n        token inputs:sourceColorSpace = "${K.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${sO(K.wrapU)}"\n        token inputs:wrapT = "${sO(K.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${O.needAlphaBlending()?"float outputs:a":""}\n    }`}function KF(K,O,F){const f="\t\t\t",r=[],l=[],{diffuseMap:q,dJ:J,alphaCutOff:c,emissiveMap:E,emissive:M,normalMap:t,roughnessMap:j,roughnessChannel:X,roughness:u,metalnessMap:T,metalnessChannel:k,metalness:N,aoMap:Z,aoMapChannel:L,aoMapIntensity:d,alphaMap:a,ior:g,clearCoatEnabled:H,clearCoat:e,clearCoatMap:W,clearCoatRoughness:p,clearCoatRoughnessMap:y}=function(K){const O={diffuseMap:null,dJ:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return K instanceof TK.NO?{...O,diffuseMap:K.diffuseTexture,dJ:K.diffuseColor,alphaCutOff:K.alphaCutOff,emissiveMap:K.emissiveTexture,emissive:K.emissiveColor,roughness:1,alphaMap:K.opacityTexture}:K instanceof EO.d?{...O,diffuseMap:K._albedoTexture,dJ:K._albedoColor,alphaCutOff:K._alphaCutOff,emissiveMap:K._emissiveTexture,emissive:K._emissiveColor,normalMap:K._bumpTexture,roughnessMap:K._metallicTexture,roughnessChannel:K._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:K._roughness??1,metalnessMap:K._metallicTexture,metalnessChannel:K._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:K._metallic??0,aoMap:K._ambientTexture,aoMapChannel:K._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:K._ambientTextureStrength,alphaMap:K._opacityTexture,ior:K.subSurface.indexOfRefraction,clearCoatEnabled:K.clearCoat.isEnabled,clearCoat:K.clearCoat.LJ,clearCoatMap:K.clearCoat.texture,clearCoatRoughness:K.clearCoat.roughness,clearCoatRoughnessMap:K.clearCoat.useRoughnessFromMainTexture?K.clearCoat.texture:K.clearCoat.textureRoughness}:O}(K);return null!==q?(r.push(`${f}color3f inputs:diffuseColor.connect = </Materials/Material_${K.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:rgb>`),K.needAlphaBlending()?r.push(`${f}float inputs:opacity.connect = </Materials/Material_${K.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:a>`):K.needAlphaTesting()&&(r.push(`${f}float inputs:opacity.connect = </Materials/Material_${K.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:a>`),r.push(`${f}float inputs:opacityThreshold = ${c}`)),l.push(SO(q,K,"diffuse",J,O,F))):r.push(`${f}color3f inputs:diffuseColor = ${PO(J||o.ZO.White())}`),null!==E?(r.push(`${f}color3f inputs:emissiveColor.connect = </Materials/Material_${K.uniqueId}/Texture_${E.uniqueId}_emissive.outputs:rgb>`),l.push(SO(E,K,"emissive",M,O,F))):M&&M.toLuminance()>0&&r.push(`${f}color3f inputs:emissiveColor = ${PO(M)}`),null!==t&&(r.push(`${f}normal3f inputs:normal.connect = </Materials/Material_${K.uniqueId}/Texture_${t.uniqueId}_normal.outputs:rgb>`),l.push(SO(t,K,"normal",null,O,F))),null!==Z&&(r.push(`${f}float inputs:occlusion.connect = </Materials/Material_${K.uniqueId}/Texture_${Z.uniqueId}_occlusion.outputs:${L}>`),l.push(SO(Z,K,"occlusion",new o.ZO(d,d,d),O,F))),null!==j?(r.push(`${f}float inputs:roughness.connect = </Materials/Material_${K.uniqueId}/Texture_${j.uniqueId}_roughness.outputs:${X}>`),l.push(SO(j,K,"roughness",new o.ZO(u,u,u),O,F))):r.push(`${f}float inputs:roughness = ${u}`),null!==T?(r.push(`${f}float inputs:metallic.connect = </Materials/Material_${K.uniqueId}/Texture_${T.uniqueId}_metallic.outputs:${k}>`),l.push(SO(T,K,"metallic",new o.ZO(N,N,N),O,F))):r.push(`${f}float inputs:metallic = ${N}`),null!==a?(r.push(`${f}float inputs:opacity.connect = </Materials/Material_${K.uniqueId}/Texture_${a.uniqueId}_opacity.outputs:r>`),r.push(`${f}float inputs:opacityThreshold = 0.0001`),l.push(SO(a,K,"opacity",null,O,F))):r.push(`${f}float inputs:opacity = ${K.alpha}`),H&&(null!==W?(r.push(`${f}float inputs:clearcoat.connect = </Materials/Material_${K.uniqueId}/Texture_${W.uniqueId}_clearcoat.outputs:r>`),l.push(SO(W,K,"clearcoat",new o.ZO(e,e,e),O,F))):r.push(`${f}float inputs:clearcoat = ${e}`),null!==y?(r.push(`${f}float inputs:clearcoatRoughness.connect = </Materials/Material_${K.uniqueId}/Texture_${y.uniqueId}_clearcoatRoughness.outputs:g>`),l.push(SO(y,K,"clearcoatRoughness",new o.ZO(p,p,p),O,F))):r.push(`${f}float inputs:clearcoatRoughness = ${p}`)),r.push(`${f}float inputs:ior = ${g}`),`\n\tdef Material "Material_${K.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${r.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${K.uniqueId}/PreviewSurface.outputs:surface>\n\n${l.join("\n")}\n\n\t}\n`}async function OF(K,O,F){const l={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...O};"undefined"===typeof fflate&&await r.Tools.LoadScriptAsync(l.fflateUrl);const q={};q[l.modelFileName]=null;let J='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';J+=function(K){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===K.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${K.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${K.planeAnchoringAlignment}"`:""}\n            `}(l);const c={};for(const f of K.meshes){if(0===f.getTotalVertices())continue;const K=f,O=K.hr,E=K.material;if(!E||!O||F&&!F(K))continue;if(-1!==["NO","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(E.getClassName())){const F="geometries/Geometry_"+O.uniqueId+".usda";if(!(F in q)){const K=DO(O,l);q[F]=hO(K)}E.uniqueId in c||(c[E.uniqueId]=E),J+=wO(K)}else r.Tools.Warn("USDZExportAsync does not support this material type: "+E.getClassName())}K.activeCamera&&l.exportCamera&&(J+=function(K,O){const F="Camera_"+K.uniqueId,r=bO(f.Matrix.RotationY(Math.PI).multiply(K.getWorldMatrix()));if(K.mode===g.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${F}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${r}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${K.if.toPrecision(O.precision)}, ${K.maxZ.toPrecision(O.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(K.orthoLeft||1)+Math.abs(K.orthoRight||1))).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(K.orthoTop||1)+Math.abs(K.orthoBottom||1))).toPrecision(O.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const f=K.getEngine().getAspectRatio(K),l=O.cameraSensorWidth||35;return`def Camera "${F}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${r}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${K.if.toPrecision(O.precision)}, ${K.maxZ.toPrecision(O.precision)})\n\t\t\tfloat focalLength = ${(l/(2*Math.tan(.5*K.fov))).toPrecision(O.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(l*f).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(l/f).toPrecision(O.precision)}            \n\t\t}\n\t\n\t`}}(K.activeCamera,l)),J+="\n            }\n        }\n    }";const E={};J+=function(K,O,F){const f=[];for(const r in K){const l=K[r];f.push(KF(l,O,F))}return`\n    def "Materials"\n{\n${f.join("")}\n}\n\n`}(c,E,l),q[l.modelFileName]=fflate.strToU8(J);for(const f in E){const K=E[f],O=K.getSize(),F=await K.readPixels();if(!F)throw new Error("Texture data is not available");const r=await H.DumpTools.DumpDataAsync(O.width,O.height,F,"image/png",void 0,!1,!0);q[`textures/Texture_${f}.png`]=new Uint8Array(r).slice()}let M=0;for(const f in q){const K=q[f];if(!K)continue;M+=34+f.length;const O=63&M;if(4!==O){const F=new Uint8Array(64-O);q[f]=[K,{extra:{12345:F}}]}M=K.length}return fflate.zipSync(q,{level:0})}}}]);