"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[26],{12020:(F,P,f)=>{f.r(P),f.d(P,{EXT_materials_diffuse_roughness:()=>UP,EXT_mesh_gpu_instancing:()=>mF,GLTF2Export:()=>sF,GLTFData:()=>j,KHR_draco_mesh_compression:()=>fP,KHR_lights_punctual:()=>oP,KHR_materials_anisotropy:()=>uP,KHR_materials_clearcoat:()=>YP,KHR_materials_diffuse_transmission:()=>LP,KHR_materials_dispersion:()=>BP,KHR_materials_emissive_strength:()=>ZP,KHR_materials_ior:()=>yP,KHR_materials_iridescence:()=>dP,KHR_materials_sheen:()=>VP,KHR_materials_specular:()=>KP,KHR_materials_transmission:()=>kP,KHR_materials_unlit:()=>EP,KHR_materials_volume:()=>nP,KHR_texture_transform:()=>DP,OBJExport:()=>H,STLExport:()=>lP,USDZExportAsync:()=>Pf,_ConvertToGLTFPBRMetallicRoughness:()=>I,_SolveMetallic:()=>k,__IGLTFExporterExtension:()=>A});var c=f(11639),N=f(11462),q=f(11937);class H{static OBJ(F,P,f,H){const A=[];let o=1,j=1;P&&(f||(f="mat"),A.push("mtllib "+f+".mtl"));for(let i=0;i<F.length;i++){const f=F[i],u=f.name||`mesh${i}}`;A.push(`o ${u}`);let T=null;if(H){const F=f.gf(!0);T=new c.Matrix,F.invertToRef(T),f.bakeTransformIntoVertices(F)}if(P){const F=f.material;F&&A.push("usemtl "+F.id)}const Y=f.Sf;if(!Y){N.Tools.Warn("No geometry is present on the mesh");continue}const t=Y.getVerticesData("position"),C=Y.getVerticesData("normal"),L=Y.getVerticesData("uv"),J=Y.Fc();let B=0,z=0;if(!t||!J){N.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const Z=F[0].OF().useRightHandedSystem?1:-1;for(let F=0;F<t.length;F+=3)A.push("v "+t[F]*Z+" "+t[F+1]+" "+t[F+2]),B++;if(null!=C)for(let F=0;F<C.length;F+=3)A.push("vn "+C[F]*Z+" "+C[F+1]+" "+C[F+2]);if(null!=L)for(let F=0;F<L.length;F+=2)A.push("vt "+L[F]+" "+L[F+1]),z++;const R=["","",""],y=(f.material||f.OF().defaultMaterial)._getEffectiveOrientation(f),[O,d]=y===q.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let F=0;F<J.length;F+=3){const P=[String(J[F]+o),String(J[F+O]+o),String(J[F+d]+o)],f=[String(J[F]+j),String(J[F+O]+j),String(J[F+d]+j)],c=P,N=null!=L?f:R,q=null!=C?P:R;A.push("f "+c[0]+"/"+N[0]+"/"+q[0]+" "+c[1]+"/"+N[1]+"/"+q[1]+" "+c[2]+"/"+N[2]+"/"+q[2])}H&&T&&f.bakeTransformIntoVertices(T),o+=B,j+=z}return A.join("\n")}static MTL(F){const P=[],f=F.material;P.push("newmtl mat1"),P.push("  Ns "+f.specularPower.toFixed(4)),P.push("  Ni 1.5000"),P.push("  d "+f.alpha.toFixed(4)),P.push("  Tr 0.0000"),P.push("  Tf 1.0000 1.0000 1.0000"),P.push("  illum 2"),P.push("  Ka "+f.ambientColor.r.toFixed(4)+" "+f.ambientColor.g.toFixed(4)+" "+f.ambientColor.b.toFixed(4)),P.push("  Kd "+f.diffuseColor.r.toFixed(4)+" "+f.diffuseColor.g.toFixed(4)+" "+f.diffuseColor.b.toFixed(4)),P.push("  Ks "+f.specularColor.r.toFixed(4)+" "+f.specularColor.g.toFixed(4)+" "+f.specularColor.b.toFixed(4)),P.push("  Ke "+f.emissiveColor.r.toFixed(4)+" "+f.emissiveColor.g.toFixed(4)+" "+f.emissiveColor.b.toFixed(4));f.ambientTexture&&P.push("  map_Ka "+f.ambientTexture.name),f.diffuseTexture&&P.push("  map_Kd "+f.diffuseTexture.name),f.specularTexture&&P.push("  map_Ks "+f.specularTexture.name),f.bumpTexture&&P.push("  map_bump -imfchan z "+f.bumpTexture.name),f.opacityTexture&&P.push("  map_d "+f.opacityTexture.name);return P.join("\n")}}var A=0,o=f(11510);class j{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const F in this.files){const P=this.files[F],f=new Blob([P],{type:(0,o.f)(F)});N.Tools.Download(f,F)}}}var i=f(11706),u=f(12028),T=f(12042),Y=f(12061),t=f(11743),C=f(11501),L=f(11690),J=f(11664);const B=J.HighestCommonFactor,z={...J,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:B};var Z=f(11841),R=f(11612),y=f(12099),O=f(12106),d=f(11835);const M=1e-6,V=new L.BP(.04,.04,.04),Q=1024,K=L.BP.White(),x=L.BP.Black();function k(F,P,f){if(P<V.r)return 0;const c=V.r,N=F*f/(1-V.r)+P-2*V.r,q=N*N-4*c*(V.r-P);return z.Clamp((-N+Math.sqrt(q))/(2*c),0,1)}function I(F){const P=F.diffuseColor.toLinearSpace(F.OF().getEngine().useExactSrgbConversions).scale(.5),f=F.alpha,N=function(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new c.Vector2(0,1),f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new c.Vector2(0,.1),N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new c.Vector2(0,.1),q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new c.Vector2(1300,.1);return function(F,P,f,c,N){return(1-F)*(1-F)*(1-F)*P+3*(1-F)*(1-F)*F*f+3*(1-F)*F*F*c+F*F*F*N}(Math.pow(F/q.x,.333333),P.y,f.y,N.y,q.y)}(z.Clamp(F.specularPower,0,Q));return{baseColorFactor:[P.r,P.g,P.b,f],metallicFactor:0,roughnessFactor:N}}function E(F,P){P.needAlphaBlending()?F.alphaMode="BLEND":P.needAlphaTesting()&&(F.alphaMode="MASK",F.alphaCutoff=P.alphaCutOff)}function r(F,P,f){const c=new Uint8Array(F*P*4);for(let N=0;N<c.length;N+=4)c[N]=c[N+1]=c[N+2]=c[N+3]=255;return y.e.CreateRGBATexture(c,F,P,f)}function n(F){if(F instanceof Uint8Array){const P=F.length,f=new Float32Array(F.length);for(let c=0;c<P;++c)f[c]=F[c]/255;return f}if(F instanceof Float32Array)return F;throw new Error("Unsupported pixel format!")}class p{constructor(F){this._exporter=F,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(F){return F?this._textureMap.get(F)??null:null}async exportStandardMaterialAsync(F,P,f){const c=I(F),q={name:F.name};if(null==F.Pc||F.Pc||(F.twoSidedLighting||N.Tools.Warn(F.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),q.doubleSided=!0),f){const f=[],N=F.diffuseTexture;N&&f.push(this.exportTextureAsync(N,P).then((F=>{F&&(c.baseColorTexture=F)})));const H=F.bumpTexture;H&&f.push(this.exportTextureAsync(H,P).then((F=>{F&&(q.normalTexture=F,1!==H.level&&(q.normalTexture.scale=H.level))})));const A=F.emissiveTexture;A&&(q.emissiveFactor=[1,1,1],f.push(this.exportTextureAsync(A,P).then((F=>{F&&(q.emissiveTexture=F)}))));const o=F.ambientTexture;o&&f.push(this.exportTextureAsync(o,P).then((F=>{if(F){const P={index:F.index};q.occlusionTexture=P}}))),f.length>0&&(this._exporter._materialNeedsUVsSet.add(F),await Promise.all(f))}(F.alpha<1||F.opacityTexture)&&(F.alphaMode===O.b.ALPHA_COMBINE?q.alphaMode="BLEND":N.Tools.Warn(F.name+": glTF 2.0 does not support alpha mode: "+F.alphaMode.toString())),F.emissiveColor&&!F.emissiveColor.equalsWithEpsilon(x,M)&&(q.emissiveFactor=F.emissiveColor.pf()),q.pbrMetallicRoughness=c,E(q,F),await this._finishMaterialAsync(q,F,P);const H=this._exporter._materials;return H.push(q),H.length-1}async _finishMaterialAsync(F,P,f){const c=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",F,P),N=[];for(const q of c)N.push(this.exportTextureAsync(q,f));await Promise.all(N),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",F,P)}async _getImageDataAsync(F,P,c,N){const q=O.b.TEXTURETYPE_UNSIGNED_BYTE,H=this._exporter._babylonScene,A=H.getEngine(),o=A.createRawTexture(F,P,c,O.b.TEXTUREFORMAT_RGBA,!1,!0,R.e.NEAREST_SAMPLINGMODE,null,q);A.isWebGPU?await f.e(51).then(f.bind(f,14079)):await f.e(52).then(f.bind(f,14082)),await Z.j.ApplyPostProcess("pass",o,H,q,O.b.TEXTURE_NEAREST_SAMPLINGMODE,O.b.TEXTUREFORMAT_RGBA);const j=await A._readTexturePixels(o,P,c);return await d.DumpTools.DumpDataAsync(P,c,j,N,void 0,!0,!0)}_resizeTexturesToSameDimensions(F,P,f){const c=F?F.getSize():{width:0,height:0},N=P?P.getSize():{width:0,height:0};let q,H;return c.width<N.width?(q=F&&F instanceof R.e?Z.j.CreateResizedCopy(F,N.width,N.height,!0):r(N.width,N.height,f),H=P):c.width>N.width?(H=P&&P instanceof R.e?Z.j.CreateResizedCopy(P,c.width,c.height,!0):r(c.width,c.height,f),q=F):(q=F,H=P),{texture1:q,texture2:H}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(F,P,f,c){const N=new Array;if(!F&&!P)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const q=F?F.OF():P?P.OF():null;if(q){var H;const A=this._resizeTexturesToSameDimensions(F,P,q),o=null===(H=A.texture1)||void 0===H?void 0:H.getSize();let j,i;const u=o.width,T=o.height,Y=await A.texture1.readPixels(),t=await A.texture2.readPixels();if(!Y)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(j=n(Y),!t)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");i=n(t);const C=i.byteLength,J=new Uint8Array(C),B=new Uint8Array(C),z=4,Z=x;let R=0,y=0;for(let F=0;F<T;++F)for(let P=0;P<u;++P){const c=(u*F+P)*z,N={diffuseColor:new L.BP(j[c],j[c+1],j[c+2]).toLinearSpace(q.getEngine().useExactSrgbConversions).multiply(f.diffuseColor),specularColor:new L.BP(i[c],i[c+1],i[c+2]).toLinearSpace(q.getEngine().useExactSrgbConversions).multiply(f.specularColor),glossiness:i[c+3]*f.glossiness},H=this._convertSpecularGlossinessToMetallicRoughness(N);Z.r=Math.max(Z.r,H.baseColor.r),Z.g=Math.max(Z.g,H.baseColor.g),Z.b=Math.max(Z.b,H.baseColor.b),R=Math.max(R,H.metallic),y=Math.max(y,H.roughness),B[c]=255*H.baseColor.r,B[c+1]=255*H.baseColor.g,B[c+2]=255*H.baseColor.b,B[c+3]=A.texture1.ef?255*j[c+3]:255,J[c]=0,J[c+1]=255*H.roughness,J[c+2]=255*H.metallic,J[c+3]=255}const O={baseColor:Z,metallic:R,roughness:y};let d=!1,V=!1;for(let F=0;F<T;++F)for(let P=0;P<u;++P){const f=(u*F+P)*z;B[f]/=O.baseColor.r>M?O.baseColor.r:1,B[f+1]/=O.baseColor.g>M?O.baseColor.g:1,B[f+2]/=O.baseColor.b>M?O.baseColor.b:1;const c=L.BP.FromInts(B[f],B[f+1],B[f+2]).toGammaSpace(q.getEngine().useExactSrgbConversions);B[f]=255*c.r,B[f+1]=255*c.g,B[f+2]=255*c.b,c.equalsWithEpsilon(K,M)||(V=!0),J[f+1]/=O.roughness>M?O.roughness:1,J[f+2]/=O.metallic>M?O.metallic:1;L.BP.FromInts(255,J[f+1],J[f+2]).equalsWithEpsilon(K,M)||(d=!0)}return d&&N.push(this._getImageDataAsync(J,u,T,c).then((F=>{O.metallicRoughnessTextureData=F}))),V&&N.push(this._getImageDataAsync(B,u,T,c).then((F=>{O.baseColorTextureData=F}))),await Promise.all(N).then((()=>O))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(F){const P=this._getPerceivedBrightness(F.diffuseColor),f=this._getPerceivedBrightness(F.specularColor),c=1-this._getMaxComponent(F.specularColor),N=k(P,f,c),q=F.diffuseColor.scale(c/(1-V.r)/Math.max(1-N)),H=F.specularColor.CP(V.scale(1-N)).scale(1/Math.max(N));let A=L.BP.Lerp(q,H,N*N);A=A.clampToRef(0,1,A);return{baseColor:A,metallic:N,roughness:1-F.glossiness}}_getPerceivedBrightness(F){return F?Math.sqrt(.299*F.r*F.r+.587*F.g*F.g+.114*F.b*F.b):0}_getMaxComponent(F){return F?Math.max(F.r,Math.max(F.g,F.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(F,P,f,c){const N=[],q={baseColor:F._albedoColor,metallic:F._metallic,roughness:F._roughness};if(c){F._albedoTexture&&N.push(this.exportTextureAsync(F._albedoTexture,P).then((F=>{F&&(f.baseColorTexture=F)})));const c=F._metallicTexture;c&&N.push(this.exportTextureAsync(c,P).then((F=>{F&&(f.metallicRoughnessTexture=F)})))}return N.length>0&&(this._exporter._materialNeedsUVsSet.add(F),await Promise.all(N)),q}_getTextureSampler(F){const P={};if(!F||!(F instanceof R.e))return P;const f=this._getGLTFTextureWrapMode(F.wrapU);10497!==f&&(P.wrapS=f);const c=this._getGLTFTextureWrapMode(F.wrapV);switch(10497!==c&&(P.wrapT=c),F.samplingMode){case R.e.LINEAR_LINEAR:P.magFilter=9729,P.minFilter=9729;break;case R.e.LINEAR_NEAREST:P.magFilter=9729,P.minFilter=9728;break;case R.e.NEAREST_LINEAR:P.magFilter=9728,P.minFilter=9729;break;case R.e.NEAREST_LINEAR_MIPLINEAR:P.magFilter=9728,P.minFilter=9987;break;case R.e.NEAREST_NEAREST:P.magFilter=9728,P.minFilter=9728;break;case R.e.NEAREST_LINEAR_MIPNEAREST:P.magFilter=9728,P.minFilter=9985;break;case R.e.LINEAR_NEAREST_MIPNEAREST:P.magFilter=9729,P.minFilter=9984;break;case R.e.LINEAR_NEAREST_MIPLINEAR:P.magFilter=9729,P.minFilter=9986;break;case R.e.NEAREST_NEAREST_MIPLINEAR:P.magFilter=9728,P.minFilter=9986;break;case R.e.LINEAR_LINEAR_MIPLINEAR:P.magFilter=9729,P.minFilter=9987;break;case R.e.LINEAR_LINEAR_MIPNEAREST:P.magFilter=9729,P.minFilter=9985;break;case R.e.NEAREST_NEAREST_MIPNEAREST:P.magFilter=9728,P.minFilter=9984}return P}_getGLTFTextureWrapMode(F){switch(F){case R.e.WRAP_ADDRESSMODE:return 10497;case R.e.CLAMP_ADDRESSMODE:return 33071;case R.e.MIRROR_ADDRESSMODE:return 33648;default:return N.Tools.Error(`Unsupported Texture Wrap Mode ${F}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(F,P,f,c){const N={diffuseColor:F._albedoColor,specularColor:F._reflectivityColor,glossiness:F._microSurface},q=F._albedoTexture,H=F._reflectivityTexture,A=F._useMicroSurfaceFromReflectivityMapAlpha;if(H&&!A)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((q||H)&&c){this._exporter._materialNeedsUVsSet.add(F);const c=this._exportTextureSampler(q||H),A=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(q,H,N,P),o=this._exporter._textures;if(A.baseColorTextureData){const F=this._exportImage(`baseColor${o.length}`,P,A.baseColorTextureData);f.baseColorTexture=this._exportTextureInfo(F,c,null===q||void 0===q?void 0:q.coordinatesIndex)}if(A.metallicRoughnessTextureData){const F=this._exportImage(`metallicRoughness${o.length}`,P,A.metallicRoughnessTextureData);f.metallicRoughnessTexture=this._exportTextureInfo(F,c,null===H||void 0===H?void 0:H.coordinatesIndex)}return A}return this._convertSpecularGlossinessToMetallicRoughness(N)}async exportPBRMaterialAsync(F,P,f){const c={},N={name:F.name},q=F.isMetallicWorkflow();if(q){const P=F._albedoColor,f=F.alpha;P&&(c.baseColorFactor=[P.r,P.g,P.b,f])}const H=q?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(F,P,c,f):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(F,P,c,f);await this._setMetallicRoughnessPbrMaterialAsync(H,F,N,c,P,f),await this._finishMaterialAsync(N,F,P);const A=this._exporter._materials;return A.push(N),A.length-1}async _setMetallicRoughnessPbrMaterialAsync(F,P,f,c,q,H){if(E(f,P),F.baseColor.equalsWithEpsilon(K,M)&&z.WithinEpsilon(P.alpha,1,M)||(c.baseColorFactor=[F.baseColor.r,F.baseColor.g,F.baseColor.b,P.alpha]),null!=F.metallic&&1!==F.metallic&&(c.metallicFactor=F.metallic),null!=F.roughness&&1!==F.roughness&&(c.roughnessFactor=F.roughness),null==P.Pc||P.Pc||(P._twoSidedLighting||N.Tools.Warn(P.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),f.doubleSided=!0),H){const F=[],c=P._bumpTexture;c&&F.push(this.exportTextureAsync(c,q).then((F=>{F&&(f.normalTexture=F,1!==c.level&&(f.normalTexture.scale=c.level))})));const N=P._ambientTexture;N&&F.push(this.exportTextureAsync(N,q).then((F=>{if(F){const c={index:F.index,texCoord:F.texCoord,extensions:F.extensions};f.occlusionTexture=c;const N=P._ambientTextureStrength;N&&(c.strength=N)}})));const H=P._emissiveTexture;H&&F.push(this.exportTextureAsync(H,q).then((F=>{F&&(f.emissiveTexture=F)}))),F.length>0&&(this._exporter._materialNeedsUVsSet.add(P),await Promise.all(F))}const A=P._emissiveColor;A.equalsWithEpsilon(x,M)||(f.emissiveFactor=A.pf()),f.pbrMetallicRoughness=c}_getPixelsFromTextureAsync(F){return function(F){switch(F){case O.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case O.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case O.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case O.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case O.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case O.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case O.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case O.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case O.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case O.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case O.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case O.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case O.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case O.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case O.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case O.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case O.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case O.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case O.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case O.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case O.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(F.textureFormat)?(0,Z.h)(F,F._texture.width,F._texture.height):(F.textureType,O.b.TEXTURETYPE_UNSIGNED_BYTE,F.readPixels())}async exportTextureAsync(F,P){const f=this._exporter._extensionsPreExportTextureAsync("exporter",F,P);return f?await f.then((async f=>f?await this._exportTextureInfoAsync(f,P):await this._exportTextureInfoAsync(F,P))):await this._exportTextureInfoAsync(F,P)}async _exportTextureInfoAsync(F,P){let f=this._textureMap.get(F);if(!f){const c=await this._getPixelsFromTextureAsync(F);if(!c)return null;const q=this._exportTextureSampler(F),H=F.mimeType;if(H)switch(H){case"image/jpeg":case"image/png":case"image/webp":P=H;break;default:N.Tools.Warn(`Unsupported media type: ${H}. Exporting texture as PNG.`)}const A=this._internalTextureToImage,o=F.getInternalTexture().uniqueId;A[o]||(A[o]={});let j=A[o][P];if(void 0===j){const f=F.getSize();j=(async()=>{const N=await this._getImageDataAsync(c,f.width,f.height,P);return this._exportImage(F.name,P,N)})(),A[o][P]=j}f=this._exportTextureInfo(await j,q,F.coordinatesIndex),this._textureMap.set(F,f),this._exporter._extensionsPostExportTextures("exporter",f,F)}return f}_exportImage(F,P,f){const c=this._exporter._images;let q;if(this._exporter._shouldUseGlb){q={name:F,mimeType:P,bufferView:void 0};const c=this._exporter._bufferManager.createBufferView(new Uint8Array(f));this._exporter._bufferManager.setBufferView(q,c)}else{const H=F.replace(/\.\/|\/|\.\\|\\/g,"_"),A=function(F){switch(F){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(P);let o=H+A;c.some((F=>F.uri===o))&&(o=`${H}_${N.Tools.RandomId()}${A}`),q={name:F,uri:o},this._exporter._imageData[o]={data:f,mimeType:P}}return c.push(q),c.length-1}_exportTextureInfo(F,P,f){const c=this._exporter._textures;let N=c.findIndex((f=>f.sampler==P&&f.source===F));-1===N&&(N=c.length,c.push({source:F,sampler:P}));const q={index:N};return f&&(q.texCoord=f),q}_exportTextureSampler(F){const P=this._getTextureSampler(F),f=this._exporter._samplers,c=f.findIndex((F=>F.minFilter===P.minFilter&&F.magFilter===P.magFilter&&F.wrapS===P.wrapS&&F.wrapT===P.wrapT));return-1!==c?c:(f.push(P),f.length-1)}}var U=f(11713),e=f(11474),D=f(12108),l=f(11648);const W=c.tP.Zero(),b=c.Quaternion.Identity(),v=c.tP.One(),s=new c.tP(-1,1,1);function X(F,P){const{byteOffset:f,byteStride:c,type:N,normalized:q}=F,H=F.getSize(),A=P.reduce(((F,P)=>P.getTotalVertices()>F?P.getTotalVertices():F),-Number.MAX_VALUE);return{byteOffset:f,byteStride:c,componentCount:H,type:N,count:A*H,normalized:q,totalVertices:A,kind:F.getKind()}}function m(F){switch(F){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function a(F){switch(F){case i.f.PositionKind:case i.f.NormalKind:case i.f.TangentKind:case i.f.ColorKind:case i.f.MatricesIndicesKind:case i.f.MatricesIndicesExtraKind:case i.f.MatricesWeightsKind:case i.f.MatricesWeightsExtraKind:case i.f.UVKind:case i.f.UV2Kind:case i.f.UV3Kind:case i.f.UV4Kind:case i.f.UV5Kind:case i.f.UV6Kind:return!0}return!1}function w(F){switch(F){case q.d.TriangleFillMode:return 4;case q.d.TriangleStripDrawMode:return 5;case q.d.TriangleFanDrawMode:return 6;case q.d.PointListDrawMode:case q.d.PointFillMode:return 0;case q.d.LineLoopDrawMode:return 2;case q.d.LineListDrawMode:return 1;case q.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${F}`)}function g(F){const P=Math.sqrt(F.x*F.x+F.y*F.y+F.z*F.z);P>0&&(F.x/=P,F.y/=P,F.z/=P)}function G(F){return F.x*=-1,F}function h(F){if(F.x*F.x+F.y*F.y>.5){const P=Math.abs(F.x),f=Math.abs(F.y);if(P>f){const f=Math.sign(F.x);F.x=P,F.y*=-f,F.z*=-f,F.w*=f}else{const P=Math.sign(F.y);F.x*=-P,F.y=f,F.z*=P,F.w*=-P}}else{const P=Math.abs(F.z),f=Math.abs(F.w);if(P>f){const f=Math.sign(F.z);F.x*=-f,F.y*=f,F.z=P,F.w*=-f}else{const P=Math.sign(F.w);F.x*=P,F.y*=-P,F.z*=-P,F.w=f}}return F}function S(F){F.fc(-F.z,F.w,F.x,-F.y)}function FF(F,P){const f=c.tP.FromArrayToRef(P.translation||[0,0,0],0,c.TmpVectors.tP[0]),N=c.Quaternion.FromArrayToRef(P.rotation||[0,0,0,1],0,c.TmpVectors.Quaternion[0]),q=c.Matrix.ComposeToRef(v,N,f,c.TmpVectors.Matrix[0]),H=c.tP.FromArrayToRef(F.translation||[0,0,0],0,c.TmpVectors.tP[2]),A=c.Quaternion.FromArrayToRef(F.rotation||[0,0,0,1],0,c.TmpVectors.Quaternion[1]),o=c.Matrix.ComposeToRef(v,A,H,c.TmpVectors.Matrix[1]);q.multiplyToRef(o,o),o.decompose(void 0,N,f),f.equalsWithEpsilon(W,l.e)?delete P.translation:P.translation=f.pf(),N.equalsWithEpsilon(b,l.e)?delete P.rotation:P.rotation=N.pf(),P.scale&&delete P.scale}function PF(F,P){if(!(P instanceof u.e))return!1;if(!(1===P.getChildren().length&&0===F.getChildren().length&&F.parent===P))return!1;const f=F.OF(),c=F instanceof D.b&&!f.useRightHandedSystem?s:v;return!!P.cc.equalsWithEpsilon(c,l.e)||(e.d.Warn(`Cannot collapse node ${F.name} into parent node ${P.name} with modified scaling.`),!1)}function fF(F){if(F instanceof Array){const P=new Float32Array(F);return new Uint8Array(P.buffer,P.byteOffset,P.byteLength)}return ArrayBuffer.isView(F)?new Uint8Array(F.buffer,F.byteOffset,F.byteLength):new Uint8Array(F)}function cF(F,P){for(const[f,c]of Object.entries(F)){const N=P[f];(Array.isArray(c)&&Array.isArray(N)&&NF(c,N)||c===N)&&delete F[f]}return F}function NF(F,P){return F.length===P.length&&F.every(((F,f)=>F===P[f]))}const qF=c.Matrix.Compose(new c.tP(-1,1,1),c.Quaternion.Identity(),c.tP.Zero());function HF(F,P){if(!(F instanceof u.e))return!1;if(P){if(!F.getWorldMatrix().equalsWithEpsilon(c.Matrix.IdentityReadOnly,l.e))return!1}else{if(!F.getWorldMatrix().multiplyToRef(qF,c.TmpVectors.Matrix[0]).equalsWithEpsilon(c.Matrix.IdentityReadOnly,l.e))return!1}return!(F instanceof T.b&&F.Sf)}const AF=new Map([[Int8Array,(F,P,f)=>F.setInt8(P,f)],[Uint8Array,(F,P,f)=>F.setUint8(P,f)],[Uint8ClampedArray,(F,P,f)=>F.setUint8(P,f)],[Int16Array,(F,P,f)=>F.setInt16(P,f,!0)],[Uint16Array,(F,P,f)=>F.setUint16(P,f,!0)],[Int32Array,(F,P,f)=>F.setInt32(P,f,!0)],[Uint32Array,(F,P,f)=>F.setUint32(P,f,!0)],[Float32Array,(F,P,f)=>F.setFloat32(P,f,!0)],[Float64Array,(F,P,f)=>F.setFloat64(P,f,!0)]]);class oF{writeTypedArray(F){this._checkGrowBuffer(F.byteLength);const P=AF.get(F.constructor);for(let f=0;f<F.length;f++)P(this._dataView,this._byteOffset,F[f]),this._byteOffset+=F.BYTES_PER_ELEMENT}constructor(F){this._data=new Uint8Array(F),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(F){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,F),this._byteOffset++}writeInt8(F){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,F),this._byteOffset++}writeInt16(F){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,F,!0),this._byteOffset+=2}writeUInt16(F){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,F,!0),this._byteOffset+=2}writeInt32(F){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,F,!0),this._byteOffset+=4}writeUInt32(F){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,F,!0),this._byteOffset+=4}writeFloat32(F){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,F,!0),this._byteOffset+=4}writeFloat64(F){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,F,!0),this._byteOffset+=8}_checkGrowBuffer(F){const P=this.byteOffset+F;if(P>this._data.byteLength){const F=new Uint8Array(2*P);F.set(this._data),this._data=F,this._dataView=new DataView(this._data.buffer)}}}function jF(F){return F%4===0?4:F%2===0?2:1}class iF{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(F){let P=0;this._bufferViewToData.forEach((F=>{P+=F.byteLength}));const f=new oF(P),c=Array.from(this._bufferViewToData.keys()).sort(((F,P)=>jF(P.byteLength)-jF(F.byteLength)));for(const N of c){N.byteOffset=f.byteOffset,F.push(N);const P=F.length-1,c=this.getPropertiesWithBufferView(N);for(const F of c)F.bufferView=P;f.writeTypedArray(this._bufferViewToData.get(N)),this._bufferViewToData.delete(N)}return f.getOutputData()}createBufferView(F,P){const f={buffer:0,byteOffset:void 0,byteLength:F.byteLength,byteStride:P};return this._bufferViewToData.set(f,F),f}createAccessor(F,P,f,c,N,q,H){this._verifyBufferView(F);const A={bufferView:void 0,componentType:f,count:c,type:P,min:null===q||void 0===q?void 0:q.min,max:null===q||void 0===q?void 0:q.max,normalized:H,byteOffset:N};return this.setBufferView(A,F),this._accessorToBufferView.set(A,F),A}setBufferView(F,P){this._verifyBufferView(P);this.getPropertiesWithBufferView(P).push(F)}removeBufferView(F){const P=this.getPropertiesWithBufferView(F);for(const f of P)void 0!==f.bufferView&&delete f.bufferView;this._bufferViewToData.delete(F),this._bufferViewToProperties.delete(F),this._accessorToBufferView.forEach(((P,f)=>{P===F&&(void 0!==f.byteOffset&&delete f.byteOffset,this._accessorToBufferView.delete(f))}))}getBufferView(F){const P=this._accessorToBufferView.get(F);return this._verifyBufferView(P),P}getPropertiesWithBufferView(F){return this._verifyBufferView(F),this._bufferViewToProperties.set(F,this._bufferViewToProperties.get(F)??[]),this._bufferViewToProperties.get(F)}getData(F){return this._verifyBufferView(F),this._bufferViewToData.get(F)}_verifyBufferView(F){if(void 0===F||!this._bufferViewToData.has(F))throw new Error(`BufferView ${F} not found in BufferManager.`)}}var uF,TF=f(12070),YF=f(12090),tF=f(12117),CF=f(11980),LF=f(12150),JF=f(12158),BF=f(12063),zF=f(12165);!function(F){F[F.INTANGENT=0]="INTANGENT",F[F.OUTTANGENT=1]="OUTTANGENT"}(uF||(uF={}));class ZF{static _IsTransformable(F){return F&&(F instanceof u.e||F instanceof TF.e||F instanceof zF.e)}static _CreateNodeAnimation(F,P,f,c,q){if(this._IsTransformable(F)){const H=[],A=[],o=P.getKeys(),j=ZF._CalculateMinMaxKeyFrames(o),i=ZF._DeduceInterpolation(o,f,c),u=i.interpolationType,T=i.shouldBakeAnimation;if(T?ZF._CreateBakedAnimation(F,P,f,j.min,j.max,P.framePerSecond,q,H,A,j,c):"LINEAR"===u||"STEP"===u?ZF._CreateLinearOrStepAnimation(F,P,f,H,A,c):"CUBICSPLINE"===u?ZF._CreateCubicSplineAnimation(F,P,f,H,A,c):ZF._CreateBakedAnimation(F,P,f,j.min,j.max,P.framePerSecond,q,H,A,j,c),H.length&&A.length){return{inputs:H,outputs:A,samplerInterpolation:u,inputsMin:T?j.min:N.Tools.FloatRound(j.min/P.framePerSecond),inputsMax:T?j.max:N.Tools.FloatRound(j.max/P.framePerSecond)}}}return null}static _DeduceAnimationInfo(F){let P=null,f="VEC3",c=!1;const q=F.targetProperty.split(".");switch(q[0]){case"cc":P="scale";break;case"position":P="translation";break;case"rotation":f="VEC4",P="rotation";break;case"rotationQuaternion":f="VEC4",c=!0,P="rotation";break;case"influence":f="SCALAR",P="weights";break;default:N.Tools.Error(`Unsupported animatable property ${q[0]}`)}return P?{animationChannelTargetPath:P,dataAccessorType:f,useQuaternion:c}:(N.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(F,P,f,c,N,q,H,A,o,j,i){let u;if(ZF._IsTransformable(F)&&F.animations)for(const T of F.animations){if(i&&!i(T))continue;const N=ZF._DeduceAnimationInfo(T);N&&(u={name:T.name,samplers:[],channels:[]},ZF._AddAnimation(`${T.name}`,T.hasRunningRuntimeAnimations?P:u,F,T,N.dataAccessorType,N.animationChannelTargetPath,c,q,H,A,N.useQuaternion,o,j),u.samplers.length&&u.channels.length&&f.push(u))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(F,P,f,c,N,q,H,A,o,j,i){let u;if(F instanceof BF.d){const N=F.morphTargetManager;if(N)for(let T=0;T<N.numTargets;++T){const Y=N.getTarget(T);for(const t of Y.animations){if(i&&!i(t))continue;const Y=new LF.d(`${t.name}`,"influence",t.framePerSecond,t.dataType,t.loopMode,t.enableBlending),C=[],L=t.getKeys();for(let F=0;F<L.length;++F){const P=L[F];for(let F=0;F<N.numTargets;++F)F==T?C.push(P):C.push({frame:P.frame,value:0})}Y.setKeys(C);const J=ZF._DeduceAnimationInfo(Y);J&&(u={name:Y.name,samplers:[],channels:[]},ZF._AddAnimation(t.name,t.hasRunningRuntimeAnimations?P:u,F,Y,J.dataAccessorType,J.animationChannelTargetPath,c,q,H,A,J.useQuaternion,o,j,N.numTargets),u.samplers.length&&u.channels.length&&f.push(u))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(F,P,f,c,N,q,H,A,o){let j;if(F.animationGroups){const u=F.animationGroups;for(const T of u){const u=new Map,Y=new Map,t=new Set,C=T.to-T.from;j={name:T.name,channels:[],samplers:[]};for(let P=0;P<T.targetedAnimations.length;++P){const C=T.targetedAnimations[P],L=C.target,J=C.animation;if(o&&!o(J))continue;const B=A.has(L);if(this._IsTransformable(L)||1===L.length&&this._IsTransformable(L[0])){const F=ZF._DeduceAnimationInfo(C.animation);if(F){const P=this._IsTransformable(L)?L:this._IsTransformable(L[0])?L[0]:null;P&&ZF._AddAnimation(`${J.name}`,j,P,J,F.dataAccessorType,F.animationChannelTargetPath,f,c,N,q,F.useQuaternion,H,B)}}else if(L instanceof JF.c||1===L.length&&L[0]instanceof JF.c){if(ZF._DeduceAnimationInfo(C.animation)){const P=L instanceof JF.c?L:L[0];if(P){const f=F.morphTargetManagers.find((F=>{for(let f=0;f<F.numTargets;++f)if(F.getTarget(f)===P)return!0;return!1}));if(f){const c=F.meshes.find((F=>F.morphTargetManager===f));var i;if(c)u.has(c)||u.set(c,new Map),null===(i=u.get(c))||void 0===i||i.set(P,J),t.add(c),Y.set(c,J)}}}}}t.forEach((F=>{const P=F.morphTargetManager;let A=null;const o=[],i=Y.get(F).getKeys(),t=i.length;for(let f=0;f<t;++f)for(let c=0;c<P.numTargets;++c){const N=P.getTarget(c),q=u.get(F);if(q){const P=q.get(N);P?(A||(A=new LF.d(`${T.name}_${F.name}_MorphWeightAnimation`,"influence",P.framePerSecond,LF.d.ANIMATIONTYPE_FLOAT,P.loopMode,P.enableBlending)),o.push(P.getKeys()[f])):o.push({frame:T.from+C/t*f,value:N.influence,inTangent:i[0].inTangent?0:void 0,outTangent:i[0].outTangent?0:void 0})}}A.setKeys(o);const L=ZF._DeduceAnimationInfo(A);L&&ZF._AddAnimation(`${T.name}_${F.name}_MorphWeightAnimation`,j,F,A,L.dataAccessorType,L.animationChannelTargetPath,f,c,N,q,L.useQuaternion,H,!1,null===P||void 0===P?void 0:P.numTargets)})),j.channels.length&&j.samplers.length&&P.push(j)}}}static _AddAnimation(F,P,f,N,q,H,A,o,j,i,u,T,Y,t){const C=ZF._CreateNodeAnimation(f,N,H,u,T);let L,J,B,z,Z,R;if(C){if(t){let F=0,P=0;const f=[];for(;C.inputs.length>0;)P=C.inputs.shift(),F%t==0&&f.push(P),F++;C.inputs=f}const F=A.get(f),N=new Float32Array(C.inputs);L=o.createBufferView(N),J=o.createAccessor(L,"SCALAR",5126,C.inputs.length,void 0,{min:[C.inputsMin],max:[C.inputsMax]}),i.push(J),B=i.length-1;const j=new c.Quaternion,u=new c.tP,T=new c.tP,y=f instanceof TF.e,O=m(q),d=new Float32Array(C.outputs.length*O);C.outputs.forEach((function(F,P){let f=F;switch(H){case"translation":Y&&(c.tP.FromArrayToRef(F,0,T),G(T),T.toArray(f));break;case"rotation":4===F.length?c.Quaternion.FromArrayToRef(F,0,j):(f=new Array(4),c.tP.FromArrayToRef(F,0,u),c.Quaternion.FromEulerVectorToRef(u,j)),Y&&(h(j),y&&S(j)),j.toArray(f)}d.set(f,P*O)})),L=o.createBufferView(d),J=o.createAccessor(L,q,5126,C.outputs.length),i.push(J),z=i.length-1,Z={interpolation:C.samplerInterpolation,input:B,output:z},P.samplers.push(Z),R={sampler:P.samplers.length-1,target:{node:F,path:H}},P.channels.push(R)}}static _CreateBakedAnimation(F,P,f,q,H,A,o,j,i,u,T){let Y;const t=c.Quaternion.Identity();let C,L=null,J=null,B=null,z=null,Z=null,R=null;u.min=N.Tools.FloatRound(q/A);const y=P.getKeys();for(let c=0,O=y.length;c<O;++c){if(R=null,B=y[c],c+1<O)if(z=y[c+1],B.value.equals&&B.value.equals(z.value)||B.value===z.value){if(0!==c)continue;R=B.frame}else R=z.frame;else{if(Z=y[c-1],B.value.equals&&B.value.equals(Z.value)||B.value===Z.value)continue;R=H}if(R)for(let c=B.frame;c<=R;c+=o){if(C=N.Tools.FloatRound(c/A),C===L)continue;L=C,J=C;const q={key:0,repeatCount:0,loopMode:P.loopMode};Y=P._interpolate(c,q),ZF._SetInterpolatedValue(F,Y,C,P,f,t,j,i,T)}}J&&(u.max=J)}static _ConvertFactorToVector3OrQuaternion(F,P,f,q,H){const A=ZF._GetBasePositionRotationOrScale(P,q,H),o=f.targetProperty.split("."),j=o?o[1]:"",i=H?c.Quaternion.zP(A).normalize():c.tP.zP(A);switch(j){case"x":case"y":case"z":i[j]=F;break;case"w":i.w=F;break;default:N.Tools.Error(`glTFAnimation: Unsupported component name "${j}"!`)}return i}static _SetInterpolatedValue(F,P,f,N,q,H,A,o,j){let i;A.push(f),"weights"!==q?(N.dataType===LF.d.ANIMATIONTYPE_FLOAT&&(P=this._ConvertFactorToVector3OrQuaternion(P,F,N,q,j)),"rotation"===q?(j?H=P:(i=P,c.Quaternion.RotationYawPitchRollToRef(i.y,i.x,i.z,H)),o.push(H.pf())):(i=P,o.push(i.pf()))):o.push([P])}static _CreateLinearOrStepAnimation(F,P,f,c,N,q){for(const H of P.getKeys())c.push(H.frame/P.framePerSecond),ZF._AddKeyframeValue(H,P,N,f,F,q)}static _CreateCubicSplineAnimation(F,P,f,c,N,q){P.getKeys().forEach((function(H){c.push(H.frame/P.framePerSecond),ZF._AddSplineTangent(uF.INTANGENT,N,f,"CUBICSPLINE",H,q),ZF._AddKeyframeValue(H,P,N,f,F,q),ZF._AddSplineTangent(uF.OUTTANGENT,N,f,"CUBICSPLINE",H,q)}))}static _GetBasePositionRotationOrScale(F,P,f){let N;if("rotation"===P)if(f){N=(F.rotationQuaternion??c.Quaternion.Identity()).pf()}else{N=(F.rotation??c.tP.Zero()).pf()}else if("translation"===P){N=(F.position??c.tP.Zero()).pf()}else{N=(F.cc??c.tP.One()).pf()}return N}static _AddKeyframeValue(F,P,f,q,H,A){let o;const j=P.dataType;if(j===LF.d.ANIMATIONTYPE_VECTOR3){let P=F.value.pf();if("rotation"===q){const F=c.tP.zP(P);P=c.Quaternion.RotationYawPitchRoll(F.y,F.x,F.z).pf()}f.push(P)}else if(j===LF.d.ANIMATIONTYPE_FLOAT){if("weights"===q)f.push([F.value]);else if(o=this._ConvertFactorToVector3OrQuaternion(F.value,H,P,q,A),o){if("rotation"===q){const F=A?o:c.Quaternion.RotationYawPitchRoll(o.y,o.x,o.z).normalize();f.push(F.pf())}f.push(o.pf())}}else j===LF.d.ANIMATIONTYPE_QUATERNION?f.push(F.value.normalize().pf()):N.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(F,P,f){let c,N,q=!1;if("rotation"===P&&!f)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let H=0,A=F.length;H<A;++H)if(N=F[H],N.inTangent||N.outTangent)if(c){if("CUBICSPLINE"!==c){c="LINEAR",q=!0;break}}else c="CUBICSPLINE";else if(c){if("CUBICSPLINE"===c||N.interpolation&&1===N.interpolation&&"STEP"!==c){c="LINEAR",q=!0;break}}else c=N.interpolation&&1===N.interpolation?"STEP":"LINEAR";return c||(c="LINEAR"),{interpolationType:c,shouldBakeAnimation:q}}static _AddSplineTangent(F,P,f,N,q,H){let A;const o=F===uF.INTANGENT?q.inTangent:q.outTangent;if("CUBICSPLINE"===N){if("rotation"===f)if(o)if(H)A=o.pf();else{const F=o;A=c.Quaternion.RotationYawPitchRoll(F.y,F.x,F.z).pf()}else A=[0,0,0,0];else A="weights"===f?o?[o]:[0]:o?o.pf():[0,0,0];P.push(A)}}static _CalculateMinMaxKeyFrames(F){let P=1/0,f=-1/0;return F.forEach((function(F){P=Math.min(P,F.frame),f=Math.max(f,F.frame)})),{min:P,max:f}}}function RF(F,P,f,q,H,A){const o={attributes:{},influence:F.influence,name:F.name},j=P.Sf;if(!j)return N.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),o;const u=A?-1:1,T=c.tP.Zero();let Y=0,t=0;if(F.hasPositions){const q=F.getPositions(),A=j.getVerticesData(i.f.PositionKind);if(A){const F=new Float32Array(A.length),P=[1/0,1/0,1/0],N=[-1/0,-1/0,-1/0];t=A.length/3,Y=0;for(let f=Y;f<t;++f){const H=c.tP.zP(A,3*f);c.tP.zP(q,3*f).subtractToRef(H,T),T.x*=u,P[0]=Math.min(P[0],T.x),N[0]=Math.max(N[0],T.x),P[1]=Math.min(P[1],T.y),N[1]=Math.max(N[1],T.y),P[2]=Math.min(P[2],T.z),N[2]=Math.max(N[2],T.z),F[3*f]=T.x,F[3*f+1]=T.y,F[3*f+2]=T.z}const j=f.createBufferView(F,12),i=f.createAccessor(j,"VEC3",5126,q.length/3,0,{min:P,max:N});H.push(i),o.attributes.POSITION=H.length-1}else N.Tools.Warn(`Morph target positions for mesh ${P.name} were not exported. Mesh does not have position vertex data`)}if(F.hasNormals){const q=F.getNormals(),A=j.getVerticesData(i.f.NormalKind);if(A){const F=new Float32Array(A.length);t=A.length/3,Y=0;for(let f=Y;f<t;++f){const P=c.tP.zP(A,3*f).normalize();c.tP.zP(q,3*f).normalize().subtractToRef(P,T),F[3*f]=T.x*u,F[3*f+1]=T.y,F[3*f+2]=T.z}const P=f.createBufferView(F,12),N=f.createAccessor(P,"VEC3",5126,q.length/3,0);H.push(N),o.attributes.NORMAL=H.length-1}else N.Tools.Warn(`Morph target normals for mesh ${P.name} were not exported. Mesh does not have normals vertex data`)}if(F.hasTangents){const q=F.getTangents(),A=j.getVerticesData(i.f.TangentKind);if(A){t=A.length/4;const F=new Float32Array(3*t);Y=0;for(let f=Y;f<t;++f){const P=c.tP.zP(A,4*f);g(P);const N=c.tP.zP(q,3*f);g(N),N.subtractToRef(P,T),F[3*f]=T.x*u,F[3*f+1]=T.y,F[3*f+2]=T.z}const P=f.createBufferView(F,12),N=f.createAccessor(P,"VEC3",5126,t,0);H.push(N),o.attributes.TANGENT=H.length-1}else N.Tools.Warn(`Morph target tangents for mesh ${P.name} were not exported. Mesh does not have tangents vertex data`)}if(F.hasColors){const q=F.getColors(),A=j.getVerticesData(i.f.ColorKind),u=j.getVertexBuffer(i.f.ColorKind);if(A&&u){const F=u.getSize();t=A.length/F;const P=new Float32Array(t*F);Y=0;for(let f=Y;f<t;++f)if(3===F){const N=c.tP.zP(A,f*F);c.tP.zP(q,f*F).subtractToRef(N,T),P[3*f]=T.x,P[3*f+1]=T.y,P[3*f+2]=T.z}else if(4===F){const N=new c.Vector4,H=c.Vector4.zP(A,f*F);c.Vector4.zP(q,f*F).subtractToRef(H,N),P[4*f]=N.x,P[4*f+1]=N.y,P[4*f+2]=N.z,P[4*f+3]=N.w}else N.Tools.Warn(`Unsupported number of components for color attribute: ${F}`);const j=f.createBufferView(P,4*F),i=f.createAccessor(j,3===F?"VEC3":"VEC4",5126,t,0);H.push(i),o.attributes.COLOR_0=H.length-1}else N.Tools.Warn(`Morph target colors for mesh ${P.name} were not exported. Mesh does not have colors vertex data`)}return o}var yF=f(12172),OF=f(12011),dF=f(11994),MF=f(11587);class VF{}VF.DEFAULT_COLOR=L.BP.White(),VF.DEFAULT_WIDTH_ATTENUATED=1,VF.DEFAULT_WIDTH=.1;var QF=f(11826),KF=f(12177);class xF{static ConvertPoints(F,P){if(F.length&&Array.isArray(F)&&"number"===typeof F[0])return[F];if(F.length&&Array.isArray(F[0])&&"number"===typeof F[0][0])return F;if(F.length&&!Array.isArray(F[0])&&F[0]instanceof c.tP){const P=[];for(let f=0;f<F.length;f++){const c=F[f];P.push(c.x,c.y,c.z)}return[P]}if(F.length>0&&Array.isArray(F[0])&&F[0].length>0&&F[0][0]instanceof c.tP){const P=[],f=F;for(const F of f)P.push(F.flatMap((F=>[F.x,F.y,F.z])));return P}if(F instanceof Float32Array){if(null!==P&&void 0!==P&&P.floatArrayStride){const f=[],c=3*P.floatArrayStride;for(let P=0;P<F.length;P+=c){const N=new Array(c);for(let f=0;f<c;f++)N[f]=F[P+f];f.push(N)}return f}return[Array.from(F)]}if(F.length&&F[0]instanceof Float32Array){const P=[];for(const f of F)P.push(Array.from(f));return P}return[]}static OmitZeroLengthPredicate(F,P,f){const c=[];return P.CP(F).lengthSquared()>0&&c.push([F,P]),f.CP(P).lengthSquared()>0&&c.push([P,f]),F.CP(f).lengthSquared()>0&&c.push([f,F]),0===c.length?null:c}static OmitDuplicatesPredicate(F,P,f,c){const N=[];return xF._SearchInPoints(F,P,c)||N.push([F,P]),xF._SearchInPoints(P,f,c)||N.push([P,f]),xF._SearchInPoints(f,F,c)||N.push([f,F]),0===N.length?null:N}static _SearchInPoints(F,P,f){for(const H of f)for(let f=0;f<H.length;f++){var c,N,q;if(null!==(c=H[f])&&void 0!==c&&c.equals(F))if(null!==(N=H[f+1])&&void 0!==N&&N.equals(P)||null!==(q=H[f-1])&&void 0!==q&&q.equals(P))return!0}return!1}static MeshesToLines(F,P){const f=[];for(let N=0;N<F.length;N++){const q=F[N],H=q.getVerticesData(i.f.PositionKind),A=q.Fc();if(H&&A)for(let F=0,o=0;F<A.length;F++){const j=3*A[o++],i=3*A[o++],u=3*A[o++],T=new c.tP(H[j],H[j+1],H[j+2]),Y=new c.tP(H[i],H[i+1],H[i+2]),t=new c.tP(H[u],H[u+1],H[u+2]);if(P){const c=P(T,Y,t,f,F,j,q,N,H,A);if(c)for(const F of c)f.push(F)}else f.push([T,Y],[Y,t],[t,T])}}return f}static ToVector3Array(F){if(Array.isArray(F[0])){const P=[],f=F;for(const F of f){const f=[];for(let P=0;P<F.length;P+=3)f.push(new c.tP(F[P],F[P+1],F[P+2]));P.push(f)}return P}const P=F,f=[];for(let N=0;N<P.length;N+=3)f.push(new c.tP(P[N],P[N+1],P[N+2]));return f}static ToNumberArray(F){return F.flatMap((F=>[F.x,F.y,F.z]))}static GetPointsCountInfo(F){const P=new Array(F.length);let f=0;for(let c=F.length;c--;)P[c]=F[c].length/3,f+=P[c];return{total:f,counts:P}}static GetLineLength(F){if(0===F.length)return 0;let P;P="number"===typeof F[0]?xF.ToVector3Array(F):F;const f=c.TmpVectors.tP[0];let N=0;for(let c=0;c<P.length-1;c++){const F=P[c];N+=P[c+1].subtractToRef(F,f).length()}return N}static GetLineLengthArray(F){const P=new Float32Array(F.length/3);let f=0;for(let c=0,N=F.length/3-1;c<N;c++){let N=F[3*c+0],q=F[3*c+1],H=F[3*c+2];N-=F[3*c+3],q-=F[3*c+4],H-=F[3*c+5];f+=Math.sqrt(N*N+q*q+H*H),P[c+1]=f}return P}static SegmentizeSegmentByCount(F,P,f){const N=[],q=P.CP(F),H=c.TmpVectors.tP[0];H.Nc(f);const A=c.TmpVectors.tP[1];q.divideToRef(H,A);let o=F.clone();N.push(o);for(let c=0;c<f;c++)o=o.clone(),N.push(o.addInPlace(A));return N}static SegmentizeLineBySegmentLength(F,P){const f=F[0]instanceof c.tP?xF.GetLineSegments(F):"number"===typeof F[0]?xF.GetLineSegments(xF.ToVector3Array(F)):F,N=[];for(const c of f)if(c.length>P){const F=xF.SegmentizeSegmentByCount(c.point1,c.point2,Math.ceil(c.length/P));for(const P of F)N.push(P)}else N.push(c.point1),N.push(c.point2);return N}static SegmentizeLineBySegmentCount(F,P){const f="number"===typeof F[0]?xF.ToVector3Array(F):F,c=xF.GetLineLength(f)/P;return xF.SegmentizeLineBySegmentLength(f,c)}static GetLineSegments(F){const P=[];for(let f=0;f<F.length-1;f++){const c=F[f],N=F[f+1],q=N.CP(c).length();P.push({point1:c,point2:N,length:q})}return P}static GetMinMaxSegmentLength(F){const P=xF.GetLineSegments(F).sort((F=>F.length));return{min:P[0].length,max:P[P.length-1].length}}static GetPositionOnLineByVisibility(F,P,f){let N=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const q=P*f;let H=0,A=0;const o=F.length;for(let c=0;c<o;c++){if(q<=H+F[c].length){A=c;break}H+=F[c].length}const j=(q-H)/F[A].length;return F[A].point2.subtractToRef(F[A].point1,c.TmpVectors.tP[0]),c.TmpVectors.tP[1]=c.TmpVectors.tP[0].multiplyByFloats(j,j,j),N||c.TmpVectors.tP[1].addInPlace(F[A].point1),c.TmpVectors.tP[1].clone()}static GetCircleLinePoints(F,P){let f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:F,q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/P;const H=[];for(let A=0;A<=P;A++)H.push(new c.tP(Math.cos(A*q)*F,Math.sin(A*q)*N,f));return H}static GetBezierLinePoints(F,P,f,c){return QF.c.CreateQuadraticBezier(F,P,f,c).getPoints().flatMap((F=>[F.x,F.y,F.z]))}static GetArrowCap(F,P,f,c,N){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,H=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[F.clone(),F.add(P.multiplyByFloats(f,f,f))],widths:[c,N,q,H]}}static GetPointsFromText(F,P,f,c){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const H=[],A=(0,KF.c)(F,P,f,c);for(const o of A){for(const F of o.paths){const P=[],f=F.getPoints();for(const F of f)P.push(F.x,F.y,N);H.push(P)}if(q)for(const F of o.holes){const P=[],f=F.getPoints();for(const F of f)P.push(F.x,F.y,N);H.push(P)}}return H}static Color3toRGBAUint8(F){const P=new Uint8Array(4*F.length);for(let f=0,c=0;f<F.length;f++)P[c++]=255*F[f].r,P[c++]=255*F[f].g,P[c++]=255*F[f].b,P[c++]=255;return P}static CreateColorsTexture(F,P,f,c){const N=c.getEngine().getCaps().maxTextureSize??1,q=P.length>N?N:P.length,H=Math.ceil(P.length/N);H>1&&(P=[...P,...Array(q*H-P.length).fill(P[0])]);const A=xF.Color3toRGBAUint8(P),o=new y.e(A,q,H,t.d.TEXTUREFORMAT_RGBA,c,!1,!0,f);return o.name=F,o}static PrepareEmptyColorsTexture(F){if(!VF.EmptyColorsTexture){const P=new Uint8Array(4);VF.EmptyColorsTexture=new y.e(P,1,1,t.d.TEXTUREFORMAT_RGBA,F,!1,!1,y.e.NEAREST_NEAREST),VF.EmptyColorsTexture.name="grlEmptyColorsTexture"}return VF.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var F;null===(F=VF.EmptyColorsTexture)||void 0===F||F.dispose(),VF.EmptyColorsTexture=null}static BooleanToNumber(F){return F?1:0}}class kF extends dF.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class IF extends OF.b{isCompatible(F){return!0}constructor(F,P,f){var N;f=f||{color:VF.DEFAULT_COLOR};const q=new kF;q.GREASED_LINE_HAS_COLOR=!!f.color&&!f.useColors,q.GREASED_LINE_SIZE_ATTENUATION=f.sizeAttenuation??!1,q.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===f.colorDistributionType,q.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(P??F.OF()).useRightHandedSystem,q.GREASED_LINE_CAMERA_FACING=f.cameraFacing??!0,super(F,IF.GREASED_LINE_MATERIAL_NAME,200,q,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(N=f)||void 0===N?void 0:N.forceGLSL)||IF.ForceGLSL,this._scene=P??F.OF(),this._engine=this._scene.getEngine(),this._cameraFacing=f.cameraFacing??!0,this.visibility=f.visibility??1,this.useDash=f.useDash??!1,this.dashRatio=f.dashRatio??.5,this.dashOffset=f.dashOffset??0,this.width=f.width?f.width:f.sizeAttenuation?VF.DEFAULT_WIDTH_ATTENUATED:VF.DEFAULT_WIDTH,this._sizeAttenuation=f.sizeAttenuation??!1,this.colorMode=f.colorMode??0,this._color=f.color??null,this.useColors=f.useColors??!1,this._colorsDistributionType=f.colorDistributionType??0,this.colorsSampling=f.colorsSampling??y.e.NEAREST_NEAREST,this._colors=f.QF??null,this.dashCount=f.dashCount??1,this.resolution=f.resolution??new c.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),f.colorsTexture?this.colorsTexture=f.colorsTexture:this._colors?this.colorsTexture=xF.CreateColorsTexture(`${F.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??VF.DEFAULT_COLOR,xF.PrepareEmptyColorsTexture(this._scene)),this._engine.Mf.add((()=>{xF.DisposeEmptyColorsTexture()}))}getAttributes(F){F.push("grl_offsets"),F.push("grl_widths"),F.push("grl_colorPointers"),F.push("grl_counters"),this._cameraFacing?(F.push("grl_previousAndSide"),F.push("grl_nextAndCounters")):F.push("grl_slopes")}getSamplers(F){F.push("grl_colors")}getActiveTextures(F){this.colorsTexture&&F.push(this.colorsTexture)}getUniforms(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const P=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&P.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===F&&P.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:P,vertex:this._cameraFacing&&this._isGLSL(F)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(F)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(F){if(this._cameraFacing){F.sf("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||F.sf("viewProjection",this._scene.getTransformMatrix());const P=c.TmpVectors.Vector4[0];P.x=this._aspect,P.y=this._resolution.x,P.z=this._resolution.y,P.w=this.width,F.updateVector4("grl_aspect_resolution_lineWidth",P)}const P=c.TmpVectors.Vector4[0];P.x=xF.BooleanToNumber(this.useDash),P.y=this._dashArray,P.z=this.dashOffset,P.w=this.dashRatio,F.updateVector4("grl_dashOptions",P);const f=c.TmpVectors.Vector4[1];f.x=this.colorMode,f.y=this.visibility,f.z=this.colorsTexture?this.colorsTexture.getSize().width:0,f.w=xF.BooleanToNumber(this.useColors),F.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",f),this._color&&F.updateColor3("grl_singleColor",this._color);const N=this.colorsTexture??VF.EmptyColorsTexture;F.setTexture("grl_colors",N),F.updateFloat2("grl_textureSize",(null===N||void 0===N?void 0:N.getSize().width)??1,(null===N||void 0===N?void 0:N.getSize().height)??1)}prepareDefines(F,P,f){F.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,F.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,F.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,F.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=P.useRightHandedSystem,F.GREASED_LINE_CAMERA_FACING=this._cameraFacing,F.GREASED_LINE_USE_OFFSETS=!!f.offsets}getClassName(){return IF.GREASED_LINE_MATERIAL_NAME}getCustomCode(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(P)?function(F,P){if("vertex"===F){const F={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return P&&(F["!gl_Position\\=viewProjection\\*worldPos;"]="//"),F}return"fragment"===F?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(F,this._cameraFacing):function(F,P){if("vertex"===F){const F={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return P&&(F["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),F}return"fragment"===F?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(F,this._cameraFacing)}dispose(){var F;null===(F=this.colorsTexture)||void 0===F||F.dispose(),super.dispose()}get QF(){return this._colors}set QF(F){this.setColors(F)}setColors(F){var P;let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1],c=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const N=(null===(P=this._colors)||void 0===P?void 0:P.length)??0;var q;if(this._colors=F,null!==F&&0!==F.length){if(!f||c)if(this.colorsTexture&&N===F.length&&!c){const P=xF.Color3toRGBAUint8(F);this.colorsTexture.update(P)}else{var H;null===(H=this.colorsTexture)||void 0===H||H.dispose(),this.colorsTexture=xF.CreateColorsTexture(`${this._material.name}-colors-texture`,F,this.colorsSampling,this._scene)}}else null===(q=this.colorsTexture)||void 0===q||q.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(F){this._dashCount=F,this._dashArray=1/F}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(F){this._sizeAttenuation=F,this.markAllDefinesAsDirty()}get color(){return this._color}set color(F){this.setColor(F)}setColor(F){let P=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==F||null!==this._color&&null===F?(this._color=F,P||this.markAllDefinesAsDirty()):this._color=F}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(F){this._colorsDistributionType=F,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(F){this._aspect=F.x/F.y,this._resolution=F}serialize(){const F=super.serialize(),P={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(P.QF=this._colors),this._color&&(P.color=this._color),F.greasedLineMaterialOptions=P,F}parse(F,P,f){var c;super.parse(F,P,f);const N=F.greasedLineMaterialOptions;null===(c=this.colorsTexture)||void 0===c||c.dispose(),N.color&&this.setColor(N.color,!0),N.colorDistributionType&&(this.colorsDistributionType=N.colorDistributionType),N.QF&&(this.QF=N.QF),N.colorsSampling&&(this.colorsSampling=N.colorsSampling),N.colorMode&&(this.colorMode=N.colorMode),N.useColors&&(this.useColors=N.useColors),N.visibility&&(this.visibility=N.visibility),N.useDash&&(this.useDash=N.useDash),N.dashCount&&(this.dashCount=N.dashCount),N.dashRatio&&(this.dashRatio=N.dashRatio),N.dashOffset&&(this.dashOffset=N.dashOffset),N.width&&(this.width=N.width),N.sizeAttenuation&&(this.sizeAttenuation=N.sizeAttenuation),N.resolution&&(this.resolution=N.resolution),this.QF?this.colorsTexture=xF.CreateColorsTexture(`${this._material.name}-colors-texture`,this.QF,this.colorsSampling,P):xF.PrepareEmptyColorsTexture(P),this.markAllDefinesAsDirty()}copyTo(F){var P;const f=F;null===(P=f.colorsTexture)||void 0===P||P.dispose(),this._colors&&(f.colorsTexture=xF.CreateColorsTexture(`${f._material.name}-colors-texture`,this._colors,f.colorsSampling,this._scene)),f.setColor(this.color,!0),f.colorsDistributionType=this.colorsDistributionType,f.colorsSampling=this.colorsSampling,f.colorMode=this.colorMode,f.useColors=this.useColors,f.visibility=this.visibility,f.useDash=this.useDash,f.dashCount=this.dashCount,f.dashRatio=this.dashRatio,f.dashOffset=this.dashOffset,f.width=this.width,f.sizeAttenuation=this.sizeAttenuation,f.resolution=this.resolution,f.markAllDefinesAsDirty()}_isGLSL(F){return 0===F||this._forceGLSL}}IF.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",IF.ForceGLSL=!1,(0,MF.f)(`BABYLON.${IF.GREASED_LINE_MATERIAL_NAME}`,IF);var EF=f(12050),rF=f(11476),nF=f(11843),pF=f(11574);class UF extends nF.ShaderMaterial{constructor(F,P,N){const q=P.getEngine(),H=q.isWebGPU&&!(N.forceGLSL||UF.ForceGLSL),A=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];P.useRightHandedSystem&&A.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const o=["position","grl_widths","grl_offsets","grl_colorPointers"];N.cameraFacing?(A.push("GREASED_LINE_CAMERA_FACING"),o.push("grl_previousAndSide","grl_nextAndCounters")):(o.push("grl_slopes"),o.push("grl_counters"));const j=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(H||j.push("world","viewProjection","view","projection"),super(F,P,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:H?["Scene","Mesh"]:void 0,attributes:o,uniforms:j,samplers:H?[]:["grlColors"],defines:A,extraInitializationsAsync:async()=>{H?await Promise.all([f.e(66).then(f.bind(f,14755)),f.e(75).then(f.bind(f,14760))]):await Promise.all([f.e(69).then(f.bind(f,14768)),f.e(76).then(f.bind(f,14777))])},shaderLanguage:H?1:0}),this._color=L.BP.White(),this._colorsDistributionType=0,this._colorsTexture=null,N=N||{color:VF.DEFAULT_COLOR},this.visibility=N.visibility??1,this.useDash=N.useDash??!1,this.dashRatio=N.dashRatio??.5,this.dashOffset=N.dashOffset??0,this.dashCount=N.dashCount??1,this.width=N.width?N.width:N.sizeAttenuation&&N.cameraFacing?VF.DEFAULT_WIDTH_ATTENUATED:VF.DEFAULT_WIDTH,this.sizeAttenuation=N.sizeAttenuation??!1,this.color=N.color??L.BP.White(),this.useColors=N.useColors??!1,this.colorsDistributionType=N.colorDistributionType??0,this.colorsSampling=N.colorsSampling??y.e.NEAREST_NEAREST,this.colorMode=N.colorMode??0,this._colors=N.QF??null,this._cameraFacing=N.cameraFacing??!0,this.resolution=N.resolution??new c.Vector2(q.getRenderWidth(),q.getRenderHeight()),N.colorsTexture?this.colorsTexture=N.colorsTexture:this._colors?this.colorsTexture=xF.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,P):(this._color=this._color??VF.DEFAULT_COLOR,this.colorsTexture=xF.PrepareEmptyColorsTexture(P)),H){const F=new pF.e;F.setParameters(),F.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",F)}q.Mf.add((()=>{xF.DisposeEmptyColorsTexture()}))}dispose(){var F;null===(F=this._colorsTexture)||void 0===F||F.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new c.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get QF(){return this._colors}set QF(F){this.setColors(F)}setColors(F){var P;let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1],c=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const N=(null===(P=this._colors)||void 0===P?void 0:P.length)??0;var q;if(this._colors=F,null!==F&&0!==F.length){if(!f||c)if(this._colorsTexture&&N===F.length&&!c){const P=xF.Color3toRGBAUint8(F);this._colorsTexture.update(P)}else{var H;null===(H=this._colorsTexture)||void 0===H||H.dispose(),this.colorsTexture=xF.CreateColorsTexture(`${this.name}-colors-texture`,F,this.colorsSampling,this.OF())}}else null===(q=this._colorsTexture)||void 0===q||q.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(F){this._colorsTexture=F,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(F){this._width=F,this.setFloat("grlWidth",F)}get useColors(){return this._useColors}set useColors(F){this._useColors=F,this.setFloat("grlUseColors",xF.BooleanToNumber(F))}get colorsSampling(){return this._colorsSampling}set colorsSampling(F){this._colorsSampling=F}get visibility(){return this._visibility}set visibility(F){this._visibility=F,this.setFloat("grlVisibility",F)}get useDash(){return this._useDash}set useDash(F){this._useDash=F,this.setFloat("grlUseDash",xF.BooleanToNumber(F))}get dashOffset(){return this._dashOffset}set dashOffset(F){this._dashOffset=F,this.setFloat("grlDashOffset",F)}get dashRatio(){return this._dashRatio}set dashRatio(F){this._dashRatio=F,this.setFloat("grlDashRatio",F)}get dashCount(){return this._dashCount}set dashCount(F){this._dashCount=F,this._dashArray=1/F,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(F){this._sizeAttenuation=F,this.setFloat("grlSizeAttenuation",xF.BooleanToNumber(F))}get color(){return this._color}set color(F){this.setColor(F)}setColor(F){F=F??VF.DEFAULT_COLOR,this._color=F,this.setColor3("grlColor",F)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(F){this._colorsDistributionType=F,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(F){this._colorMode=F,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(F){this._resolution=F,this.setVector2("grlResolution",F),this.setFloat("grlAspect",F.x/F.y)}serialize(){const F=super.serialize(),P={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(P.QF=this._colors),F.greasedLineMaterialOptions=P,F}parse(F,P,f){var c;const N=F.greasedLineMaterialOptions;null===(c=this._colorsTexture)||void 0===c||c.dispose(),N.color&&(this.color=N.color),N.colorDistributionType&&(this.colorsDistributionType=N.colorDistributionType),N.colorsSampling&&(this.colorsSampling=N.colorsSampling),N.colorMode&&(this.colorMode=N.colorMode),N.useColors&&(this.useColors=N.useColors),N.visibility&&(this.visibility=N.visibility),N.useDash&&(this.useDash=N.useDash),N.dashCount&&(this.dashCount=N.dashCount),N.dashRatio&&(this.dashRatio=N.dashRatio),N.dashOffset&&(this.dashOffset=N.dashOffset),N.width&&(this.width=N.width),N.sizeAttenuation&&(this.sizeAttenuation=N.sizeAttenuation),N.resolution&&(this.resolution=N.resolution),N.QF?this.colorsTexture=xF.CreateColorsTexture(`${this.name}-colors-texture`,N.QF,this.colorsSampling,this.OF()):this.colorsTexture=xF.PrepareEmptyColorsTexture(P),this._cameraFacing=N.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var eF,DF,lF;UF.ForceGLSL=!1,function(F){F[F.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",F[F.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(eF||(eF={})),function(F){F[F.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",F[F.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",F[F.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(DF||(DF={})),function(F){F[F.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",F[F.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",F[F.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",F[F.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",F[F.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(lF||(lF={}));class WF extends BF.d{constructor(F,P,f){super(F,P,null,null,!1,!1),this.name=F,this._options=f,this._lazy=!1,this._updatable=!1,this._engine=P.getEngine(),this._lazy=f.lazy??!1,this._updatable=f.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=f.colorPointers??[],this._widths=f.widths??new Array(f.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(F){let P=0;for(const c of this._points)P+=c.length;const f=P/3*2-this._widths.length;for(let c=0;c<f;c++)this._widths.push(F)}updateLazy(){var F,P;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(F=this._options.ribbonOptions)||void 0===F?void 0:F.smoothShading),!this.IF&&this.refreshBoundingInfo(),null===(P=this.greasedLineMaterial)||void 0===P||P.updateLazy()}addPoints(F,P){for(const f of F)this._points.push(f);this._lazy||this.setPoints(this._points,P)}dispose(F){let P=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(F,P)}isLazy(){return this._lazy}get KF(){return this._uvs}set KF(F){this._uvs=F instanceof Float32Array?F:new Float32Array(F),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(F){this.material instanceof UF&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===F||void 0===F?void 0:F.length)>0),this._offsets=F,this._offsetsBuffer?this._offsetsBuffer.update(F):this._createOffsetsBuffer(F)}get widths(){return this._widths}set widths(F){this._widths=F,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(F)}get colorPointers(){return this._colorPointers}set colorPointers(F){this._colorPointers=F,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(F)}get greasedLineMaterial(){var F,P;if(this.material&&this.material instanceof UF)return this.material;const f=null===(F=this.material)||void 0===F||null===(P=F.pluginManager)||void 0===P?void 0:P.getPlugin(IF.GREASED_LINE_MATERIAL_NAME);return f||void 0}get points(){const F=[];return rF.c.DeepCopy(this._points,F),F}setPoints(F,P){this._points=xF.ConvertPoints(F,(null===P||void 0===P?void 0:P.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==P&&void 0!==P&&P.colorPointers||this._updateColorPointers(),this._setPoints(this._points,P)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,KF:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(F){super.serialize(F),F.type=this.getClassName(),F.lineOptions=this._createLineOptions()}_createVertexBuffers(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const P=new EF.e;return P.MF=this._vertexPositions,P.indices=this._indices,P.KF=this._uvs,F&&(P.VF=[],EF.e.ComputeNormals(this._vertexPositions,this._indices,P.VF)),P.kF(this,this._options.updatable),P}_createOffsetsBuffer(F){const P=this._scene.getEngine(),f=new i.e(P,F,this._updatable,3);this.setVerticesBuffer(f.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=f}}class bF{constructor(F,P){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=F,this.wasAddedByNoopNode=P}getIndicesAccessor(F,P,f,c,N){var q,H,A,o;return null===(q=this._indicesAccessorMap.get(F))||void 0===q||null===(H=q.get(P))||void 0===H||null===(A=H.get(f))||void 0===A||null===(o=A.get(c))||void 0===o?void 0:o.get(N)}setIndicesAccessor(F,P,f,c,N,q){let H=this._indicesAccessorMap.get(F);H||(H=new Map,this._indicesAccessorMap.set(F,H));let A=H.get(P);A||(A=new Map,H.set(P,A));let o=A.get(f);o||(o=new Map,A.set(f,o));let j=o.get(c);j||(j=new Map,o.set(c,j)),j.set(N,q)}pushExportedNode(F){this._exportedNodes.has(F)||this._exportedNodes.add(F)}getNodesSet(){return this._exportedNodes}getVertexBufferView(F){return this._vertexBufferViewMap.get(F)}setVertexBufferView(F,P){this._vertexBufferViewMap.set(F,P)}setRemappedBufferView(F,P,f){this._remappedBufferView.set(F,new Map),this._remappedBufferView.get(F).set(P,f)}getRemappedBufferView(F,P){var f;return null===(f=this._remappedBufferView.get(F))||void 0===f?void 0:f.get(P)}getVertexAccessor(F,P,f){var c,N;return null===(c=this._vertexAccessorMap.get(F))||void 0===c||null===(N=c.get(P))||void 0===N?void 0:N.get(f)}setVertexAccessor(F,P,f,c){let N=this._vertexAccessorMap.get(F);N||(N=new Map,this._vertexAccessorMap.set(F,N));let q=N.get(P);q||(q=new Map,N.set(P,q)),q.set(f,c)}hasVertexColorAlpha(F){return this._vertexMapColorAlpha.get(F)||!1}setHasVertexColorAlpha(F,P){return this._vertexMapColorAlpha.set(F,P)}getMesh(F){return this._meshMap.get(F)}setMesh(F,P){this._meshMap.set(F,P)}bindMorphDataToMesh(F,P){const f=this._meshMorphTargetMap.get(F)||[];this._meshMorphTargetMap.set(F,f),-1===f.indexOf(P)&&f.push(P)}getMorphTargetsFromMesh(F){return this._meshMorphTargetMap.get(F)}}class vF{_ApplyExtension(F,P,f,c){if(f>=P.length)return Promise.resolve(F);const N=c(P[f],F);return N?N.then((async F=>F?await this._ApplyExtension(F,P,f+1,c):null)):this._ApplyExtension(F,P,f+1,c)}_ApplyExtensions(F,P){const f=[];for(const c of vF._ExtensionNames)f.push(this._extensions[c]);return this._ApplyExtension(F,f,0,P)}_extensionsPreExportTextureAsync(F,P,f){return this._ApplyExtensions(P,((P,c)=>P.preExportTextureAsync&&P.preExportTextureAsync(F,c,f)))}_extensionsPostExportNodeAsync(F,P,f,c,N){return this._ApplyExtensions(P,((P,q)=>P.postExportNodeAsync&&P.postExportNodeAsync(F,q,f,c,N,this._bufferManager)))}_extensionsPostExportMaterialAsync(F,P,f){return this._ApplyExtensions(P,((P,c)=>P.postExportMaterialAsync&&P.postExportMaterialAsync(F,c,f)))}_extensionsPostExportMaterialAdditionalTextures(F,P,f){const c=[];for(const N of vF._ExtensionNames){const q=this._extensions[N];q.postExportMaterialAdditionalTextures&&c.push(...q.postExportMaterialAdditionalTextures(F,P,f))}return c}_extensionsPostExportTextures(F,P,f){for(const c of vF._ExtensionNames){const N=this._extensions[c];N.postExportTexture&&N.postExportTexture(F,P,f)}}_extensionsPostExportMeshPrimitive(F){for(const P of vF._ExtensionNames){const f=this._extensions[P];f.postExportMeshPrimitive&&f.postExportMeshPrimitive(F,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const F of vF._ExtensionNames){const P=this._extensions[F];P.preGenerateBinaryAsync&&await P.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(F){for(const P of vF._ExtensionNames){const f=this._extensions[P];f.enabled&&F(f)}}_extensionsOnExporting(){this._forEachExtensions((F=>{var P,f,c;F.wasUsed&&((P=this._glTF).extensionsUsed||(P.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(F.name)&&this._glTF.extensionsUsed.push(F.name),F.required&&((f=this._glTF).extensionsRequired||(f.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(F.name)&&this._glTF.extensionsRequired.push(F.name)),(c=this._glTF).extensions||(c.extensions={}),F.onExporting&&F.onExporting())}))}_loadExtensions(){for(const F of vF._ExtensionNames){const P=vF._ExtensionFactories[F](this);this._extensions[F]=P}}constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:C.b.LastCreatedScene,P=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${t.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new p(this),this._extensions={},this._bufferManager=new iF,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!F)throw new Error("No scene available to export");this._babylonScene=F,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:F=>{var P;return null===F||void 0===F||null===(P=F.kf)||void 0===P?void 0:P.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...P},this._loadExtensions()}dispose(){for(const F in this._extensions){this._extensions[F].dispose()}}get options(){return this._options}static RegisterExtension(F,P){vF.UnregisterExtension(F)&&N.Tools.Warn(`Extension with the name ${F} already exists`),vF._ExtensionFactories[F]=P,vF._ExtensionNames.push(F)}static UnregisterExtension(F){if(!vF._ExtensionFactories[F])return!1;delete vF._ExtensionFactories[F];const P=vF._ExtensionNames.indexOf(F);return-1!==P&&vF._ExtensionNames.splice(P,1),!0}_generateJSON(F,P,f){const c={byteLength:F};return c.byteLength&&(this._glTF.buffers=[c]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.LP=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(c.uri=P+".bin"),f?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(F){const P=await this._generateBinaryAsync();this._extensionsOnExporting();const f=this._generateJSON(P.byteLength,F,!0),c=new Blob([P],{type:"application/octet-stream"}),N=F+".gltf",q=F+".bin",H=new j;if(H.files[N]=f,H.files[q]=c,this._imageData)for(const A in this._imageData)H.files[A]=new Blob([this._imageData[A].data],{type:this._imageData[A].mimeType});return H}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(F){const P=F%4;return 0===P?P:4-P}async generateGLBAsync(F){this._shouldUseGlb=!0;const P=await this._generateBinaryAsync();this._extensionsOnExporting();const f=this._generateJSON(P.byteLength),c=F+".glb";let N,q=f.length;if("undefined"!==typeof TextEncoder){N=(new TextEncoder).encode(f),q=N.length}const H=this._getPadding(q),A=this._getPadding(P.byteLength),o=28+q+H+P.byteLength+A,i=new oF(o);if(i.writeUInt32(1179937895),i.writeUInt32(2),i.writeUInt32(o),i.writeUInt32(q+H),i.writeUInt32(1313821514),N)i.writeTypedArray(N);else{const F="_".charCodeAt(0);for(let P=0;P<q;++P){const c=f.charCodeAt(P);c!=f.codePointAt(P)?i.writeUInt8(F):i.writeUInt8(c)}}for(let j=0;j<H;++j)i.writeUInt8(32);i.writeUInt32(P.byteLength+A),i.writeUInt32(5130562),i.writeTypedArray(P);for(let j=0;j<A;++j)i.writeUInt8(0);const u=new j;return u.files[c]=new Blob([i.getOutputData()],{type:"application/octet-stream"}),u}_setNodeTransformation(F,P,f){if(P.getPivotPoint().equalsWithEpsilon(W,l.e)||N.Tools.Warn("Pivot points are not supported in the glTF serializer"),!P.position.equalsWithEpsilon(W,l.e)){const N=c.TmpVectors.tP[0].q(P.position);f&&G(N),F.translation=N.pf()}P.cc.equalsWithEpsilon(v,l.e)||(F.scale=P.cc.pf());const q=P.rotationQuaternion||c.Quaternion.FromEulerAngles(P.rotation.x,P.rotation.y,P.rotation.z);q.equalsWithEpsilon(b,l.e)||(f&&h(q),F.rotation=q.normalize().pf())}_setCameraTransformation(F,P,f){if(!P.position.equalsWithEpsilon(W,l.e)){const N=c.TmpVectors.tP[0].q(P.position);f&&G(N),F.translation=N.pf()}const N=P.rotationQuaternion||c.Quaternion.FromEulerAngles(P.rotation.x,P.rotation.y,P.rotation.z);f&&h(N),this._babylonScene.useRightHandedSystem||S(N),N.equalsWithEpsilon(b,l.e)||(F.rotation=N.pf())}_listAvailableCameras(){for(const F of this._babylonScene.cameras){const P={type:F.mode===TF.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(F.name&&(P.name=F.name),"perspective"===P.type)P.perspective={aspectRatio:F.getEngine().getAspectRatio(F),yfov:F.fovMode===TF.e.FOVMODE_VERTICAL_FIXED?F.fov:F.fov*F.getEngine().getAspectRatio(F),znear:F.Wf,zfar:F.maxZ};else if("orthographic"===P.type){const f=F.orthoLeft&&F.orthoRight?.5*(F.orthoRight-F.orthoLeft):.5*F.getEngine().getRenderWidth(),c=F.orthoBottom&&F.orthoTop?.5*(F.orthoTop-F.orthoBottom):.5*F.getEngine().getRenderHeight();P.orthographic={xmag:f,ymag:c,znear:F.Wf,zfar:F.maxZ}}this._camerasMap.set(F,P)}}_exportAndAssignCameras(){const F=Array.from(this._camerasMap.values());for(const P of F){const F=this._nodesCameraMap.get(P);if(void 0!==F){this._cameras.push(P);for(const P of F)P.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const F of this._babylonScene.skeletons){if(F.bones.length<=0)continue;const P={joints:[]};this._skinMap.set(F,P)}}_exportAndAssignSkeletons(){for(const F of this._babylonScene.skeletons){if(F.bones.length<=0)continue;const P=this._skinMap.get(F);if(void 0==P)continue;const f={},c=[];let q=-1;for(let N=0;N<F.bones.length;++N){const P=F.bones[N],c=P.getIndex()??N;-1!==c&&(f[c]=P,c>q&&(q=c))}for(let F=0;F<=q;++F){const q=f[F];c.push(q.getAbsoluteInverseBindMatrix());const H=q.getTransformNode();if(null!==H){const F=this._nodeMap.get(H);H&&null!==F&&void 0!==F?P.joints.push(F):N.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else N.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const H=this._nodesSkinMap.get(P);if(P.joints.length>0&&void 0!==H){const F=64*c.length,f=new Float32Array(F/4);c.forEach(((F,P)=>{f.set(F.m,16*P)}));const N=this._bufferManager.createBufferView(f);this._accessors.push(this._bufferManager.createAccessor(N,"MAT4",5126,c.length)),P.inverseBindMatrices=this._accessors.length-1,this._skins.push(P);for(const P of H)P.skin=this._skins.length-1}}}async _exportSceneAsync(){const F={nodes:[]};if(this._babylonScene.metadata){const P=this._options.metadataSelector(this._babylonScene.metadata);P&&(F.extras=P)}const P=new Array,f=new Array,c=new Array;for(const A of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&HF(A,this._babylonScene.useRightHandedSystem)?c.push(...A.getChildren()):this._babylonScene.useRightHandedSystem?P.push(A):f.push(A);this._listAvailableCameras(),this._listAvailableSkeletons();const N=new bF(!0,!1);F.nodes.push(...await this._exportNodesAsync(f,N));const q=new bF(!1,!1);F.nodes.push(...await this._exportNodesAsync(P,q));const H=new bF(!1,!0);F.nodes.push(...await this._exportNodesAsync(c,H)),F.nodes.length&&this._scenes.push(F),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&ZF._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,N.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(F){let P=this._shouldExportNodeMap.get(F);return void 0===P&&(P=this._options.shouldExportNode(F),this._shouldExportNodeMap.set(F,P)),P}async _exportNodesAsync(F,P){const f=new Array;this._exportBuffers(F,P);for(const c of F)await this._exportNodeAsync(c,f,P);return f}_collectBuffers(F,P,f,c,N){if(this._shouldExportNode(F)&&F instanceof T.b&&F.Sf){const q=F.Sf.getVertexBuffers();if(q)for(const c in q){if(!a(c))continue;const H=q[c];N.setHasVertexColorAlpha(H,F.hasVertexAlpha);const A=H._buffer,o=P.get(A)||[];P.set(A,o),-1===o.indexOf(H)&&o.push(H);const j=f.get(H)||[];f.set(H,j),-1===j.indexOf(F)&&j.push(F)}const H=F.morphTargetManager;if(H)for(let P=0;P<H.numTargets;P++){const f=H.getTarget(P),N=c.get(f)||[];c.set(f,N),-1===N.indexOf(F)&&N.push(F)}}for(const q of F.getChildren())this._collectBuffers(q,P,f,c,N)}_exportBuffers(F,P){const f=new Map,c=new Map,N=new Map;for(const A of F)this._collectBuffers(A,f,c,N,P);const q=Array.from(f.keys());for(const A of q){const F=A.getData();if(!F)throw new Error("Buffer data is not available");const N=f.get(A);if(!N)continue;const q=N[0].byteStride;if(N.some((F=>F.byteStride!==q)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const H=fF(F).slice();for(const P of N){const F=c.get(P),{byteOffset:f,byteStride:N,componentCount:q,type:A,count:o,normalized:j,kind:u}=X(P,F);switch(u){case i.f.NormalKind:case i.f.TangentKind:(0,U.j)(H,f,N,q,A,o,j,(F=>{const P=Math.sqrt(F[0]*F[0]+F[1]*F[1]+F[2]*F[2]);if(P>0){const f=1/P;F[0]*=f,F[1]*=f,F[2]*=f}}));break;case i.f.ColorKind:{const P=F.filter((F=>F.material instanceof CF.JP||null==F.material)).length;if(0==P)break;if(P!=F.length){e.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}A==i.f.UNSIGNED_BYTE&&e.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const c=new L.BP,u=new L.qc,T=this._babylonScene.getEngine().useExactSrgbConversions;(0,U.j)(H,f,N,q,A,o,j,(F=>{3===F.length?(c.Zf(F,0),c.toLinearSpaceToRef(c,T),c.toArray(F,0)):(u.Zf(F,0),u.toLinearSpaceToRef(u,T),u.toArray(F,0))}))}}}if(P.convertToRightHanded){for(const F of N){const P=c.get(F),{byteOffset:f,byteStride:N,componentCount:q,type:A,count:o,normalized:j,kind:u}=X(F,P);switch(u){case i.f.PositionKind:case i.f.NormalKind:case i.f.TangentKind:(0,U.j)(H,f,N,q,A,o,j,(F=>{F[0]=-F[0]}))}}P.convertedToRightHandedBuffers.set(A,H)}const o=this._bufferManager.createBufferView(H,q);P.setVertexBufferView(A,o);const j=new Map;for(const P of N){const F=c.get(P),{kind:f,totalVertices:N}=X(P,F);switch(f){case i.f.MatricesIndicesKind:case i.f.MatricesIndicesExtraKind:if(P.type==i.f.FLOAT){const F=P.getFloatData(N);null!==F&&j.set(P,F)}}}0!==j.size&&e.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const u=Array.from(j.keys());for(const f of u){const F=j.get(f);if(!F)continue;const c=F.some((F=>F>=256)),N=new(c?Uint16Array:Uint8Array)(F.length);for(let P=0;P<F.length;P++)N[P]=F[P];const q=this._bufferManager.createBufferView(N,4*(c?2:1));P.setRemappedBufferView(A,f,q)}}const H=Array.from(N.keys());for(const A of H){const F=N.get(A);if(!F)continue;const f=RF(A,F[0],this._bufferManager,this._bufferViews,this._accessors,P.convertToRightHanded);for(const c of F)P.bindMorphDataToMesh(c,f)}}async _exportNodeAsync(F,P,f){let c=this._nodeMap.get(F);if(void 0!==c)return void(P.includes(c)||P.push(c));const N=await this._createNodeAsync(F,f);if(N){c=this._nodes.length,this._nodes.push(N),this._nodeMap.set(F,c),f.pushExportedNode(F),P.push(c);const q={name:"runtime animations",channels:[],samplers:[]},H=[];this._babylonScene.animationGroups.length||(ZF._CreateMorphTargetAnimationFromMorphTargetAnimations(F,q,H,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,f.convertToRightHanded,this._options.shouldExportAnimation),F.animations.length&&ZF._CreateNodeAnimationFromNodeAnimations(F,q,H,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,f.convertToRightHanded,this._options.shouldExportAnimation)),q.channels.length&&q.samplers.length&&this._animations.push(q),H.forEach((F=>{F.channels.length&&F.samplers.length&&this._animations.push(F)}))}const q=N?[]:P;for(const H of F.getChildren())await this._exportNodeAsync(H,q,f);N&&q.length&&(N.children=q)}async _createNodeAsync(F,P){if(!this._shouldExportNode(F))return null;const f={};if(F.name&&(f.name=F.name),F.metadata){const P=this._options.metadataSelector(F.metadata);P&&(f.extras=P)}if(F instanceof u.e&&(this._setNodeTransformation(f,F,P.convertToRightHanded),F instanceof T.b)){const N=F instanceof Y.c?F.sourceMesh:F;if(N.nf&&N.nf.length>0&&(f.mesh=await this._exportMeshAsync(N,P)),F.skeleton){const P=this._skinMap.get(F.skeleton);var c;if(void 0!==P)void 0===this._nodesSkinMap.get(P)&&this._nodesSkinMap.set(P,[]),null===(c=this._nodesSkinMap.get(P))||void 0===c||c.push(f)}}if(F instanceof D.b){const c=this._camerasMap.get(F);if(c){var N;void 0===this._nodesCameraMap.get(c)&&this._nodesCameraMap.set(c,[]),this._setCameraTransformation(f,F,P.convertToRightHanded);const H=F.parent;if(null!==H&&PF(F,H)){const F=this._nodeMap.get(H);if(void 0!==F){var q;const P=this._nodes[F];return FF(f,P),null===(q=this._nodesCameraMap.get(c))||void 0===q||q.push(P),null}}null===(N=this._nodesCameraMap.get(c))||void 0===N||N.push(f)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",f,F,this._nodeMap,P.convertToRightHanded)?f:(e.d.Warn(`Not exporting node ${F.name}`),null)}_exportIndices(F,P,f,c,N,H,A,o,j){let i=F;j.mode=w(H);const u=A!==q.d.CounterClockWiseSideOrientation,T=!o.wasAddedByNoopNode&&u,Y=function(F){switch(F){case q.d.TriangleFillMode:case q.d.TriangleStripDrawMode:case q.d.TriangleFanDrawMode:return!0}return!1}(H)&&T;if(Y){if(H===q.d.TriangleStripDrawMode||H===q.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");j.mode=w(H);const A=P?new Uint32Array(c):new Uint16Array(c);if(F)for(let P=0;P+2<c;P+=3)A[P]=F[f+P]+N,A[P+1]=F[f+P+2]+N,A[P+2]=F[f+P+1]+N;else for(let F=0;F+2<c;F+=3)A[F]=F,A[F+1]=F+2,A[F+2]=F+1;i=A}else if(F&&0!==N){const q=P?new Uint32Array(c):new Uint16Array(c);for(let P=0;P<c;P++)q[P]=F[f+P]+N;i=q}if(i){let q=o.getIndicesAccessor(F,f,c,N,Y);if(void 0===q){const H=function(F,P,f,c){if(F instanceof Uint16Array||F instanceof Uint32Array)return F;if(F instanceof Int32Array)return new Uint32Array(F.buffer,F.byteOffset,F.length);const N=F.slice(P,P+f);return c?new Uint32Array(N):new Uint16Array(N)}(i,0,c,P),A=this._bufferManager.createBufferView(H),j=P?5125:5123;this._accessors.push(this._bufferManager.createAccessor(A,"SCALAR",j,c,0)),q=this._accessors.length-1,o.setIndicesAccessor(F,f,c,N,Y,q)}j.indices=q}}_exportVertexBuffer(F,P,f,c,N,q){const H=F.getKind();if(!a(H))return;if(H.startsWith("uv")&&!this._options.exportUnusedUVs&&(!P||!this._materialNeedsUVsSet.has(P)))return;let A=N.getVertexAccessor(F,f,c);if(void 0===A){const P=N.convertedToRightHandedBuffers.get(F._buffer)||F._buffer.getData(),q=H===i.f.PositionKind?function(F,P,f,c){const{byteOffset:N,byteStride:q,type:H,normalized:A}=P,o=P.getSize(),j=new Array(o).fill(1/0),i=new Array(o).fill(-1/0);return(0,U.j)(F,N+f*q,q,o,H,c*o,A,(F=>{for(let P=0;P<o;P++)j[P]=Math.min(j[P],F[P]),i[P]=Math.max(i[P],F[P])})),{min:j,max:i}}(P,F,f,c):void 0,o=(H===i.f.MatricesIndicesKind||H===i.f.MatricesIndicesExtraKind)&&F.type===i.f.FLOAT,j=o?i.f.UNSIGNED_BYTE:F.type,u=o?void 0:F.normalized,T=o?N.getRemappedBufferView(F._buffer,F):N.getVertexBufferView(F._buffer),Y=F.byteOffset+f*F.byteStride;this._accessors.push(this._bufferManager.createAccessor(T,function(F,P){if(F==i.f.ColorKind)return P?"VEC4":"VEC3";switch(F){case i.f.PositionKind:case i.f.NormalKind:return"VEC3";case i.f.TangentKind:case i.f.MatricesIndicesKind:case i.f.MatricesIndicesExtraKind:case i.f.MatricesWeightsKind:case i.f.MatricesWeightsExtraKind:return"VEC4";case i.f.UVKind:case i.f.UV2Kind:case i.f.UV3Kind:case i.f.UV4Kind:case i.f.UV5Kind:case i.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${F}`)}(H,N.hasVertexColorAlpha(F)),j,c,Y,q,u)),A=this._accessors.length-1,N.setVertexAccessor(F,f,c,A)}q.attributes[function(F){switch(F){case i.f.PositionKind:return"POSITION";case i.f.NormalKind:return"NORMAL";case i.f.TangentKind:return"TANGENT";case i.f.ColorKind:return"COLOR_0";case i.f.UVKind:return"TEXCOORD_0";case i.f.UV2Kind:return"TEXCOORD_1";case i.f.UV3Kind:return"TEXCOORD_2";case i.f.UV4Kind:return"TEXCOORD_3";case i.f.UV5Kind:return"TEXCOORD_4";case i.f.UV6Kind:return"TEXCOORD_5";case i.f.MatricesIndicesKind:return"JOINTS_0";case i.f.MatricesIndicesExtraKind:return"JOINTS_1";case i.f.MatricesWeightsKind:return"WEIGHTS_0";case i.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${F}`)}(H)]=A}async _exportMaterialAsync(F,P,f,c){let N=this._materialMap.get(F);if(void 0===N){const c=P&&Object.keys(P).some((F=>F.startsWith("uv")));if((F=F instanceof YF.c?F.Hc[f.materialIndex]:F)instanceof tF.c)N=await this._materialExporter.exportPBRMaterialAsync(F,"image/png",c);else{if(!(F instanceof CF.JP))return void e.d.Warn(`Unsupported material '${F.name}' with type ${F.getClassName()}`);N=await this._materialExporter.exportStandardMaterialAsync(F,"image/png",c)}this._materialMap.set(F,N)}c.material=N}async _exportMeshAsync(F,P){var f;let c=P.getMesh(F);if(void 0!==c)return c;const N={primitives:[]};c=this._meshes.length,this._meshes.push(N),P.setMesh(F,c);const H=F.isUnIndexed?null:F.Fc(),A=null===(f=F.Sf)||void 0===f?void 0:f.getVertexBuffers(),o=P.getMorphTargetsFromMesh(F),j=F instanceof yF.e,i=F instanceof WF,u=F.nf;if(A&&u&&u.length>0)for(const t of u){const f={attributes:{}},c=t.pF()||this._babylonScene.defaultMaterial;if(i){var T,Y;const P={name:c.name},N=F,q=L.BP.White(),H=(null===(T=N.material)||void 0===T?void 0:T.alpha)??1,A=(null===(Y=N.greasedLineMaterial)||void 0===Y?void 0:Y.color)??q;(!A.equalsWithEpsilon(q,l.e)||H<1)&&(P.pbrMetallicRoughness={baseColorFactor:[...A.pf(),H]}),this._materials.push(P),f.material=this._materials.length-1}else if(j){const P={name:c.name},N=F;(!N.color.equalsWithEpsilon(L.BP.White(),l.e)||N.alpha<1)&&(P.pbrMetallicRoughness={baseColorFactor:[...N.color.pf(),N.alpha]}),this._materials.push(P),f.material=this._materials.length-1}else await this._exportMaterialAsync(c,A,t,f);const u=j||i?q.d.LineListDrawMode:F.overrideRenderingFillMode??c.fillMode,C=c._getEffectiveOrientation(F);this._exportIndices(H,H?(0,U.d)(H,t.indexCount,t.indexStart,t.verticesStart):t.verticesCount>65535,H?t.indexStart:t.verticesStart,H?t.indexCount:t.verticesCount,-t.verticesStart,u,C,P,f);for(const F of Object.values(A))this._exportVertexBuffer(F,c,t.verticesStart,t.verticesCount,P,f);if(o){f.targets=[];for(const F of o)f.targets.push(F.attributes)}N.primitives.push(f),this._extensionsPostExportMeshPrimitive(f)}if(o){N.weights=[],N.extras||(N.extras={}),N.extras.targetNames=[];for(const F of o)N.weights.push(F.influence),N.extras.targetNames.push(F.name)}return c}}vF._ExtensionNames=new Array,vF._ExtensionFactories={};class sF{static async GLTFAsync(F,P,f){f&&f.exportWithoutWaitingForScene||await F.whenReadyAsync();const c=new vF(F,f),N=await c.generateGLTFAsync(P.replace(/\.[^/.]+$/,""));return c.dispose(),N}static async GLBAsync(F,P,f){f&&f.exportWithoutWaitingForScene||await F.whenReadyAsync();const c=new vF(F,f),N=await c.generateGLBAsync(P.replace(/\.[^/.]+$/,""));return c.dispose(),N}}f(12188);const XF="EXT_mesh_gpu_instancing";class mF{constructor(F){this.name=XF,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(F,P,f,N,q,H){return await new Promise((F=>{if(P&&f instanceof BF.d&&f.hasThinInstances&&this._exporter){this._wasUsed=!0;const F=c.tP.Zero(),N=c.Quaternion.Identity(),A=c.tP.One(),o=f.thinInstanceGetWorldMatrices(),j=c.TmpVectors.tP[2],i=c.TmpVectors.Quaternion[1],u=c.TmpVectors.tP[3];let T=!1,Y=!1,t=!1;const C=new Float32Array(3*f.Ac),L=new Float32Array(4*f.Ac),J=new Float32Array(3*f.Ac);let B=0;for(const P of o)P.decompose(u,i,j),q&&(G(j),h(i)),C.set(j.pf(),3*B),L.set(i.normalize().pf(),4*B),J.set(u.pf(),3*B),T=T||!j.equalsWithEpsilon(F),Y=Y||!i.equalsWithEpsilon(N),t=t||!u.equalsWithEpsilon(A),B++;const z={attributes:{}};T&&(z.attributes.TRANSLATION=this._buildAccessor(C,"VEC3",f.Ac,H)),Y&&(z.attributes.ROTATION=this._buildAccessor(L,"VEC4",f.Ac,H)),t&&(z.attributes.SCALE=this._buildAccessor(J,"VEC3",f.Ac,H)),P.extensions=P.extensions||{},P.extensions[XF]=z}F(P)}))}_buildAccessor(F,P,f,c){const N=c.createBufferView(F),q=c.createAccessor(N,P,5126,f);return this._exporter._accessors.push(q),this._exporter._accessors.length-1}}vF.RegisterExtension(XF,(F=>new mF(F)));var aF=f(12193),wF=f(12202),gF=f(12210),GF=f(12212);function hF(F){return F===gF.c.PositionKind?"POSITION":F===gF.c.NormalKind?"NORMAL":F===gF.c.ColorKind?"COLOR":F.startsWith(gF.c.UVKind)?"TEX_COORD":"GENERIC"}const SF={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class FP extends aF.b{static get DefaultAvailable(){return(0,aF.g)(FP.DefaultConfiguration)}static get Default(){return FP._Default??(FP._Default=new FP),FP._Default}static ResetDefault(F){FP._Default&&(F||FP._Default.dispose(),FP._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(F,P){return{module:await(P||DracoEncoderModule)({wasmBinary:F})}}_getWorkerContent(){return`${wF.i}(${wF.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:FP.DefaultConfiguration)}async _encodeAsync(F,P,f){const c=f?(0,GF.c)(SF,f):SF;if(this._workerPoolPromise){const f=await this._workerPoolPromise;return await new Promise(((N,q)=>{f.push(((f,H)=>{const A=F=>{f.removeEventListener("error",A),f.removeEventListener("message",o),q(F),H()},o=F=>{"encodeMeshDone"===F.data.id&&(f.removeEventListener("error",A),f.removeEventListener("message",o),N(F.data.encodedMeshData),H())};f.addEventListener("error",A),f.addEventListener("message",o);const j=[];for(const P of F)j.push(P.data.buffer);P&&j.push(P.buffer),f.postMessage({id:"encodeMesh",attributes:F,indices:P,options:c},j)}))}))}if(this._modulePromise){const f=await this._modulePromise;return(0,wF.i)(f.module,F,P,c)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(F,P){if(0==F.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");F instanceof BF.d&&F.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===P||void 0===P?void 0:P.method)&&(e.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),P.method="MESH_SEQUENTIAL_ENCODING");const f=function(F){let P=F.Fc(void 0,!0);return!P||P instanceof Uint32Array||P instanceof Uint16Array||(P=((0,U.d)(P,P.length)?Uint32Array:Uint16Array).from(P)),P}(F),c=function(F,P){const f=[];for(const c of F.getVerticesDataKinds()){if(null!==P&&void 0!==P&&P.includes(c)){if(c===gF.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const N=F.getVertexBuffer(c),q=N.getSize(),H=(0,U.x)(N.getData(),q,N.type,N.byteOffset,N.byteStride,N.normalized,F.getTotalVertices(),!0);f.push({kind:c,dracoName:hF(c),size:q,data:H})}return f}(F,null===P||void 0===P?void 0:P.excludedAttributes);return await this._encodeAsync(c,f,P)}}FP.DefaultConfiguration={wasmUrl:`${N.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${N.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${N.Tools._DefaultCdnUrl}/draco_encoder.js`},FP._Default=null;const PP="KHR_draco_mesh_compression";class fP{get wasUsed(){return this._wasUsed}constructor(F){this.name=PP,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===F.options.meshCompressionMethod&&FP.DefaultAvailable}dispose(){}postExportMeshPrimitive(F,P,f){if(!this.enabled)return;if(4!==F.mode&&5!==F.mode)return void e.d.Warn("Cannot compress primitive with mode "+F.mode+".");const c=[],N=[];let q=null;if(void 0!==F.indices){const H=f[F.indices],A=P.getBufferView(H);q=P.getData(A).slice(),c.push(A),N.push(H)}const H=[];for(const[i,u]of Object.entries(F.attributes)){const F=f[u],q=P.getBufferView(F),o=m(F.type),j=(0,U.x)(P.getData(q),o,F.componentType,F.byteOffset||0,q.byteStride||(0,U.r)(F.componentType)*o,F.normalized||!1,F.count,!0);H.push({kind:i,dracoName:(A=i,"POSITION"===A?"POSITION":"NORMAL"===A?"NORMAL":A.startsWith("COLOR")?"COLOR":A.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:m(F.type),data:j}),c.push(q),N.push(F)}var A;const o={method:F.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},j=FP.Default._encodeAsync(H,q,o).then((f=>{if(!f)return void e.d.Error("Draco encoding failed for primitive.");const q={bufferView:-1,attributes:f.attributeIds},H=P.createBufferView(f.data);P.setBufferView(q,H);for(const F of c)this._bufferViewsUsed.add(F);for(const F of N)this._accessorsUsed.add(F);F.extensions||(F.extensions={}),F.extensions[PP]=q})).catch((F=>{e.d.Error("Draco encoding failed for primitive: "+F)}));this._encodePromises.push(j),this._wasUsed=!0}async preGenerateBinaryAsync(F){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((P=>{F.getPropertiesWithBufferView(P).every((F=>this._accessorsUsed.has(F)))&&F.removeBufferView(P)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}vF.RegisterExtension(PP,(F=>new fP(F)));var cP=f(12217);const NP="KHR_lights_punctual",qP={name:"",color:[1,1,1],jc:1,range:Number.MAX_VALUE},HP={innerConeAngle:0,outerConeAngle:Math.PI/4},AP=c.tP.Backward();class oP{constructor(F){this.name=NP,this.enabled=!0,this.required=!1,this._exporter=F}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[NP]=this._lights}async postExportNodeAsync(F,P,f,N,q){return await new Promise((H=>{if(!(f instanceof zF.e))return void H(P);const A=f.getTypeID()==zF.e.LIGHTTYPEID_POINTLIGHT?"point":f.getTypeID()==zF.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":f.getTypeID()==zF.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!A||!(f instanceof cP.b))return e.d.Warn(`${F}: Light ${f.name} is not supported in ${NP}`),void H(P);if(f.falloffType!==zF.e.FALLOFF_GLTF&&e.d.Warn(`${F}: Light falloff for ${f.name} does not match the ${NP} specification!`),!f.position.equalsToFloats(0,0,0)){const F=c.TmpVectors.tP[0].q(f.position);q&&G(F),P.translation=F.pf()}if("point"!==A){const F=f.direction.normalizeToRef(c.TmpVectors.tP[0]);q&&G(F);const N=c.Quaternion.FromUnitVectorsToRef(AP,F,c.TmpVectors.Quaternion[0]);c.Quaternion.IsIdentity(N)||(P.rotation=N.pf())}const o={type:A,name:f.name,color:f.uc.pf(),jc:f.jc,range:f.range};if(cF(o,qP),"spot"===A){const F=f;o.spot={innerConeAngle:F.innerAngle/2,outerConeAngle:F.angle/2},cF(o.spot,HP)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(o);const j={if:this._lights.lights.length-1},i=f.parent;if(i&&PF(f,i)){const F=N.get(i);if(F){const f=this._exporter._nodes[F];return FF(P,f),f.extensions||(f.extensions={}),f.extensions[NP]=j,void H(null)}}P.extensions||(P.extensions={}),P.extensions[NP]=j,H(P)}))}}vF.RegisterExtension(NP,(F=>new oP(F)));var jP=f(12136);const iP="KHR_materials_anisotropy";class uP{constructor(F){this.name=iP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,P,f){const c=[];return f instanceof jP.d&&f.anisotropy.isEnabled&&!f.anisotropy.legacy?(f.anisotropy.texture&&c.push(f.anisotropy.texture),c):[]}postExportMaterialAsync(F,P,f){return new Promise((F=>{if(f instanceof jP.d){if(!f.anisotropy.isEnabled||f.anisotropy.legacy)return void F(P);this._wasUsed=!0,P.extensions=P.extensions||{};const c=this._exporter._materialExporter.getTextureInfo(f.anisotropy.texture),N={anisotropyStrength:f.anisotropy.jc,anisotropyRotation:f.anisotropy.angle,anisotropyTexture:c??void 0};null!==N.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(f),P.extensions[iP]=N}F(P)}))}}vF.RegisterExtension(iP,(F=>new uP(F)));const TP="KHR_materials_clearcoat";class YP{constructor(F){this.name=TP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,P,f){const c=[];return f instanceof jP.d&&f.clearCoat.isEnabled?(f.clearCoat.texture&&c.push(f.clearCoat.texture),!f.clearCoat.useRoughnessFromMainTexture&&f.clearCoat.textureRoughness&&c.push(f.clearCoat.textureRoughness),f.clearCoat.bumpTexture&&c.push(f.clearCoat.bumpTexture),c):[]}postExportMaterialAsync(F,P,f){return new Promise((F=>{if(f instanceof jP.d){if(!f.clearCoat.isEnabled)return void F(P);this._wasUsed=!0,P.extensions=P.extensions||{};const c=this._exporter._materialExporter.getTextureInfo(f.clearCoat.texture);let q;q=f.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(f.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(f.clearCoat.textureRoughness),f.clearCoat.isTintEnabled&&N.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${f.name}`),f.clearCoat.remapF0OnInterfaceChange&&N.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${f.name}`);const H=this._exporter._materialExporter.getTextureInfo(f.clearCoat.bumpTexture),A={clearcoatFactor:f.clearCoat.jc,clearcoatTexture:c??void 0,clearcoatRoughnessFactor:f.clearCoat.roughness,clearcoatRoughnessTexture:q??void 0,clearcoatNormalTexture:H??void 0};null===A.clearcoatTexture&&null===A.clearcoatRoughnessTexture&&null===A.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(f),P.extensions[TP]=A}F(P)}))}}vF.RegisterExtension(TP,(F=>new YP(F)));const tP="KHR_materials_diffuse_transmission";function CP(F,P){const f=P.subSurface;let c=null;return f.translucencyIntensityTexture?c=f.translucencyIntensityTexture:f.thicknessTexture&&f.useMaskFromThicknessTexture&&(c=f.thicknessTexture),c&&!f.useGltfStyleTextures?(e.d.Warn(`${F}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${P.name}`,1),null):c}class LP{constructor(F){this.name=tP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,P,f){const c=[];if(f instanceof tF.c&&this._isExtensionEnabled(f)){const P=CP(F,f);return P&&c.push(P),f.subSurface.translucencyColorTexture&&c.push(f.subSurface.translucencyColorTexture),c}return c}_isExtensionEnabled(F){if(F.unlit)return!1;const P=F.subSurface;return!!P.isTranslucencyEnabled&&(!F.unlit&&!P.useAlbedoToTintTranslucency&&P.useGltfStyleTextures&&1===P.volumeIndexOfRefraction&&0===P.minimumThickness&&0===P.maximumThickness)}postExportMaterialAsync(F,P,f){return new Promise((c=>{if(f instanceof tF.c&&this._isExtensionEnabled(f)){this._wasUsed=!0;const c=f.subSurface,N=CP(F,f),q=0==c.translucencyIntensity?void 0:c.translucencyIntensity,H=this._exporter._materialExporter.getTextureInfo(N)??void 0,A=!c.translucencyColor||c.translucencyColor.equalsFloats(1,1,1)?void 0:c.translucencyColor.pf(),o=this._exporter._materialExporter.getTextureInfo(c.translucencyColorTexture)??void 0,j={diffuseTransmissionFactor:q,diffuseTransmissionTexture:H,diffuseTransmissionColorFactor:A,diffuseTransmissionColorTexture:o};(H||o)&&this._exporter._materialNeedsUVsSet.add(f),P.extensions=P.extensions||{},P.extensions[tP]=j}c(P)}))}}vF.RegisterExtension(tP,(F=>new LP(F)));const JP="KHR_materials_dispersion";class BP{constructor(){this.name=JP,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(F){if(F.unlit)return!1;const P=F.subSurface;return!(!P.isRefractionEnabled&&!P.isDispersionEnabled)}postExportMaterialAsync(F,P,f){return new Promise((F=>{if(f instanceof tF.c&&this._isExtensionEnabled(f)){this._wasUsed=!0;const F={dispersion:f.subSurface.dispersion};P.extensions=P.extensions||{},P.extensions[JP]=F}F(P)}))}}vF.RegisterExtension(JP,(()=>new BP));const zP="KHR_materials_emissive_strength";class ZP{constructor(){this.name=zP,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(F,P,f){return await new Promise((F=>{if(!(f instanceof tF.c))return F(P);const c=f.emissiveColor.pf(),N=Math.max(...c);if(N>1){this._wasUsed=!0,P.extensions||(P.extensions={});const F={emissiveStrength:N},c=f.emissiveColor.scale(1/F.emissiveStrength);P.emissiveFactor=c.pf(),P.extensions[zP]=F}return F(P)}))}}vF.RegisterExtension(zP,(F=>new ZP));const RP="KHR_materials_ior";class yP{constructor(){this.name=RP,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(F){return!F.unlit&&(void 0!=F.indexOfRefraction&&1.5!=F.indexOfRefraction)}postExportMaterialAsync(F,P,f){return new Promise((F=>{if(f instanceof tF.c&&this._isExtensionEnabled(f)){this._wasUsed=!0;const F={ior:f.indexOfRefraction};P.extensions=P.extensions||{},P.extensions[RP]=F}F(P)}))}}vF.RegisterExtension(RP,(F=>new yP));const OP="KHR_materials_iridescence";class dP{constructor(F){this.name=OP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,P,f){const c=[];return f instanceof jP.d&&f.iridescence.isEnabled?(f.iridescence.texture&&c.push(f.iridescence.texture),f.iridescence.thicknessTexture&&f.iridescence.thicknessTexture!==f.iridescence.texture&&c.push(f.iridescence.thicknessTexture),c):[]}postExportMaterialAsync(F,P,f){return new Promise((F=>{if(f instanceof jP.d){if(!f.iridescence.isEnabled)return void F(P);this._wasUsed=!0,P.extensions=P.extensions||{};const c=this._exporter._materialExporter.getTextureInfo(f.iridescence.texture),N=this._exporter._materialExporter.getTextureInfo(f.iridescence.thicknessTexture),q={iridescenceFactor:f.iridescence.jc,iridescenceIor:f.iridescence.indexOfRefraction,iridescenceThicknessMinimum:f.iridescence.minimumThickness,iridescenceThicknessMaximum:f.iridescence.maximumThickness,iridescenceTexture:c??void 0,iridescenceThicknessTexture:N??void 0};null===q.iridescenceTexture&&null===q.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(f),P.extensions[OP]=q}F(P)}))}}vF.RegisterExtension(OP,(F=>new dP(F)));const MP="KHR_materials_sheen";class VP{constructor(F){this.name=MP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,P,f){return f instanceof tF.c&&f.sheen.isEnabled&&f.sheen.texture?[f.sheen.texture]:[]}async postExportMaterialAsync(F,P,f){return await new Promise((F=>{if(f instanceof tF.c){if(!f.sheen.isEnabled)return void F(P);this._wasUsed=!0,null==P.extensions&&(P.extensions={});const c={sheenColorFactor:f.sheen.color.pf(),sheenRoughnessFactor:f.sheen.roughness??0};null===c.sheenColorTexture&&null===c.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(f),f.sheen.texture&&(c.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(f.sheen.texture)??void 0),f.sheen.textureRoughness&&!f.sheen.useRoughnessFromMainTexture?c.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(f.sheen.textureRoughness)??void 0:f.sheen.texture&&f.sheen.useRoughnessFromMainTexture&&(c.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(f.sheen.texture)??void 0),P.extensions[MP]=c}F(P)}))}}vF.RegisterExtension(MP,(F=>new VP(F)));const QP="KHR_materials_specular";class KP{constructor(F){this.name=QP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,P,f){const c=[];return f instanceof tF.c&&this._isExtensionEnabled(f)?(f.metallicReflectanceTexture&&c.push(f.metallicReflectanceTexture),f.reflectanceTexture&&c.push(f.reflectanceTexture),c):c}_isExtensionEnabled(F){return!F.unlit&&(void 0!=F.metallicF0Factor&&1!=F.metallicF0Factor||void 0!=F.metallicReflectanceColor&&!F.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(F))}_hasTexturesExtension(F){return null!=F.metallicReflectanceTexture||null!=F.reflectanceTexture}postExportMaterialAsync(F,P,f){return new Promise((F=>{if(f instanceof tF.c&&this._isExtensionEnabled(f)){this._wasUsed=!0,P.extensions=P.extensions||{};const F=this._exporter._materialExporter.getTextureInfo(f.metallicReflectanceTexture)??void 0,c=this._exporter._materialExporter.getTextureInfo(f.reflectanceTexture)??void 0,N={specularFactor:1==f.metallicF0Factor?void 0:f.metallicF0Factor,specularTexture:F,specularColorFactor:f.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:f.metallicReflectanceColor.pf(),specularColorTexture:c};this._hasTexturesExtension(f)&&this._exporter._materialNeedsUVsSet.add(f),P.extensions[QP]=N}F(P)}))}}vF.RegisterExtension(QP,(F=>new KP(F)));const xP="KHR_materials_transmission";class kP{constructor(F){this.name=xP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,P,f){const c=[];return f instanceof tF.c&&this._isExtensionEnabled(f)?(f.subSurface.thicknessTexture&&c.push(f.subSurface.thicknessTexture),c):c}_isExtensionEnabled(F){if(F.unlit)return!1;const P=F.subSurface;return P.isRefractionEnabled&&void 0!=P.refractionIntensity&&0!=P.refractionIntensity||this._hasTexturesExtension(F)}_hasTexturesExtension(F){return null!=F.subSurface.refractionIntensityTexture}async postExportMaterialAsync(F,P,f){if(f instanceof tF.c&&this._isExtensionEnabled(f)){this._wasUsed=!0;const c=f.subSurface,N={transmissionFactor:0===c.refractionIntensity?void 0:c.refractionIntensity};if(this._hasTexturesExtension(f)&&this._exporter._materialNeedsUVsSet.add(f),c.refractionIntensityTexture)if(c.useGltfStyleTextures){const F=await this._exporter._materialExporter.exportTextureAsync(c.refractionIntensityTexture,"image/png");F&&(N.transmissionTexture=F)}else e.d.Warn(`${F}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);P.extensions||(P.extensions={}),P.extensions[xP]=N}return P}}vF.RegisterExtension(xP,(F=>new kP(F)));const IP="KHR_materials_unlit";class EP{constructor(){this.name=IP,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(F,P,f){return new Promise((F=>{let c=!1;f instanceof tF.c?c=f.unlit:f instanceof CF.JP&&(c=f.disableLighting),c&&(this._wasUsed=!0,null==P.extensions&&(P.extensions={}),P.extensions[IP]={}),F(P)}))}}vF.RegisterExtension(IP,(()=>new EP));const rP="KHR_materials_volume";class nP{constructor(F){this.name=rP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,P,f){const c=[];return f instanceof tF.c&&this._isExtensionEnabled(f)?(f.subSurface.thicknessTexture&&c.push(f.subSurface.thicknessTexture),c):c}_isExtensionEnabled(F){if(F.unlit)return!1;const P=F.subSurface;return!(!P.isRefractionEnabled&&!P.isTranslucencyEnabled)&&(void 0!=P.maximumThickness&&0!=P.maximumThickness||void 0!=P.tintColorAtDistance&&P.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=P.tintColor&&P.tintColor!=L.BP.White()||this._hasTexturesExtension(F))}_hasTexturesExtension(F){return null!=F.subSurface.thicknessTexture}postExportMaterialAsync(F,P,f){return new Promise((F=>{if(f instanceof tF.c&&this._isExtensionEnabled(f)){this._wasUsed=!0;const F=f.subSurface,c={thicknessFactor:0==F.maximumThickness?void 0:F.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(F.thicknessTexture)??void 0,attenuationDistance:F.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:F.tintColorAtDistance,attenuationColor:F.tintColor.equalsFloats(1,1,1)?void 0:F.tintColor.pf()};this._hasTexturesExtension(f)&&this._exporter._materialNeedsUVsSet.add(f),P.extensions=P.extensions||{},P.extensions[rP]=c}F(P)}))}}vF.RegisterExtension(rP,(F=>new nP(F)));const pP="EXT_materials_diffuse_roughness";class UP{constructor(F){this.name=pP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=F}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(F,P,f){const c=[];return f instanceof jP.d&&f._baseDiffuseRoughness?(f._baseDiffuseRoughnessTexture&&c.push(f._baseDiffuseRoughnessTexture),c):[]}postExportMaterialAsync(F,P,f){return new Promise((F=>{if(f instanceof jP.d){if(!f._baseDiffuseRoughness)return void F(P);this._wasUsed=!0,P.extensions=P.extensions||{};const c=this._exporter._materialExporter.getTextureInfo(f._baseDiffuseRoughnessTexture),N={diffuseRoughnessFactor:f._baseDiffuseRoughness,diffuseRoughnessTexture:c??void 0};null!==N.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(f),P.extensions[pP]=N}F(P)}))}}vF.RegisterExtension(pP,(F=>new UP(F)));const eP="KHR_texture_transform";class DP{constructor(){this.name=eP,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(F,P,f){if(f.OF()||N.Tools.Warn(`${F}: /*@__KEY__*/"scene" is not defined for Babylon texture ${f.name}!`),(0!==f.uAng||0!==f.vAng)&&(N.Tools.Warn(`${F}: Texture ${f.name} with rotation in the u or v axis is not supported in glTF.`),0!==f.uRotationCenter||0!==f.vRotationCenter))return;const c={};let q=!1;if(0===f.uOffset&&0===f.vOffset||(c.offset=[f.uOffset,f.vOffset],q=!0),1===f.uScale&&1===f.vScale||(c.scale=[f.uScale,f.vScale],q=!0),0!==f.wAng){if(0!==f.uRotationCenter||0!==f.vRotationCenter){if(f.homogeneousRotationInUVTransform&&f.uScale!==f.vScale)return void N.Tools.Warn(`${F}: Texture ${f.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${eP}.`);N.Tools.Warn(`${F}: Texture ${f.name} with non-origin rotation center will be exported using an adjusted offset with ${eP}.`),c.offset=function(F){const{uOffset:P,vOffset:f,uRotationCenter:c,vRotationCenter:N,uScale:q,vScale:H,wAng:A}=F,o=Math.cos(A),j=Math.sin(A),i=c*q,u=N*H;return[P+(i*(1-o)+u*j),f+(u*(1-o)-i*j)]}(f)}c.rotation=-f.wAng,q=!0}0!==f.coordinatesIndex&&(c.texCoord=f.coordinatesIndex,q=!0),q&&(this._wasUsed=!0,P.extensions||(P.extensions={}),P.extensions[eP]=c)}}vF.RegisterExtension(eP,(()=>new DP));class lP{static CreateSTL(F){let P=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",N=arguments.length>3&&void 0!==arguments[3]&&arguments[3],q=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],H=arguments.length>5&&void 0!==arguments[5]&&arguments[5],A=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const j=function(F,P,f){const N=[3*F[f],3*F[f+1],3*F[f+2]],q=[new c.tP(P[N[0]],P[N[0]+2],P[N[0]+1]),new c.tP(P[N[1]],P[N[1]+2],P[N[1]+1]),new c.tP(P[N[2]],P[N[2]+2],P[N[2]+1])],H=q[0].CP(q[1]),A=q[2].CP(q[1]);return{v:q,n:c.tP.Cross(A,H).normalize()}},u=function(F,P,f,c){return P=T(F,P,f.x,c),P=T(F,P,f.y,c),T(F,P,f.z,c)},T=function(F,P,f,c){return F.setFloat32(P,f,c),P+4},t=function(F){if(A){let P=F;F instanceof Y.c&&(P=F.sourceMesh);const f=P.getVerticesData(i.f.PositionKind,!0,!0);if(!f)return[];const N=c.tP.Zero();let q;for(q=0;q<f.length;q+=3)c.tP.TransformCoordinatesFromFloatsToRef(f[q],f[q+1],f[q+2],F.gf(!0),N).toArray(f,q);return f}return F.getVerticesData(i.f.PositionKind)||[]};A&&(H=!0);let C="",L=0,J=0;if(N){for(let f=0;f<F.length;f++){const P=F[f].Fc();L+=P?P.length/3:0}const P=new ArrayBuffer(84+50*L);C=new DataView(P),J+=80,C.setUint32(J,L,q),J+=4}else o||(C="solid stlmesh\r\n");for(let c=0;c<F.length;c++){const P=F[c];!N&&o&&(C+="solid "+P.name+"\r\n"),!H&&P instanceof BF.d&&P.bakeCurrentTransformIntoVertices();const f=t(P),A=P.Fc()||[];for(let F=0;F<A.length;F+=3){const P=j(A,f,F);N?(J=u(C,J,P.n,q),J=u(C,J,P.v[0],q),J=u(C,J,P.v[1],q),J=u(C,J,P.v[2],q),J+=2):(C+="\tfacet normal "+P.n.x+" "+P.n.y+" "+P.n.z+"\r\n",C+="\t\touter loop\r\n",C+="\t\t\tvertex "+P.v[0].x+" "+P.v[0].y+" "+P.v[0].z+"\r\n",C+="\t\t\tvertex "+P.v[1].x+" "+P.v[1].y+" "+P.v[1].z+"\r\n",C+="\t\t\tvertex "+P.v[2].x+" "+P.v[2].y+" "+P.v[2].z+"\r\n",C+="\t\tendloop\r\n",C+="\tendfacet\r\n")}!N&&o&&(C+="endsolid "+name+"\r\n")}if(N||o||(C+="endsolid stlmesh"),P){const F=document.createElement("a"),P=new Blob([C],{type:"application/octet-stream"});F.href=window.URL.createObjectURL(P),F.download=f+".stl",F.click()}return C}}function WP(F,P){let f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const c=[];for(let N=0;N<F.length/f;N++){const q=F[N*f],H=F[N*f+1],A=F[N*f+2];c.push(`(${q.toPrecision(P.precision)}, ${H.toPrecision(P.precision)}, ${A.toPrecision(P.precision)})`)}return c.join(", ")}function bP(F,P){const f=[];for(let c=0;c<F.length/2;c++){const N=F[2*c],q=F[2*c+1];f.push(`(${N.toPrecision(P.precision)}, ${(1-q).toPrecision(P.precision)})`)}return f.join(", ")}function vP(F,P){const f=F.getVerticesData(i.f.PositionKind),c=F.getVerticesData(i.f.NormalKind);if(f&&c)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(F){var P;const f=null!==(P=F.Fc())&&void 0!==P&&P.length?F.getTotalIndices():F.getTotalVertices();return Array(f/3).fill(3).join(", ")}(F)}]\n\t\tint[] faceVertexIndices = [${function(F){const P=F.Fc(),f=[];if(null!==P)for(let c=0;c<P.length;c++)f.push(P[c]);else{const P=F.getTotalVertices();for(let F=0;F<P;F++)f.push(F)}return f.join(", ")}(F)}]\n\t\tnormal3f[] normals = [${WP(c,P)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${WP(f,P)}]\n        ${function(F,P){let f="";for(let N=0;N<4;N++){const c=N>0?N:"",q=F.getVerticesData(i.f.UVKind+(c?c+1:""));q&&(f+=`\n\t\ttexCoord2f[] primvars:st${c} = [${bP(q,P)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const c=F.getVerticesData(i.f.ColorKind);return c&&(f+=`\n\tcolor3f[] primvars:displayColor = [${WP(c,P,c.length/F.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),f}(F,P)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function sP(F,P){return`\n        def "Geometry"\n        {\n        ${vP(F,P)}\n        }\n        `}function XP(F){let P='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return P+=F,fflate.strToU8(P)}function mP(F){const P=F.m;return`( ${aP(P,0)}, ${aP(P,4)}, ${aP(P,8)}, ${aP(P,12)} )`}function aP(F,P){return`(${F[P+0]}, ${F[P+1]}, ${F[P+2]}, ${F[P+3]})`}function wP(F){const P="Object_"+F.uniqueId,f=function(F){const P=F.getWorldMatrix().clone(),f=F.OF().useRightHandedSystem;if(!f){let c=F.parent;for(;c;){if(HF(c,f)){P.multiplyToRef(c.getWorldMatrix().invert(),P);break}c=c.parent}}return P.determinant()<0&&N.Tools.Warn(`Exporting mesh ${F.name} with negative scale. Result may look incorrect in destination engine.`),P}(F),c=mP(f);return`def Xform "${P}" (\n\tprepend references = @./geometries/Geometry_${F.Sf.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${c}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${F.material.uniqueId}>\n}\n\n`}function gP(F){switch(F){case O.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case O.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case O.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function GP(F){return`(${F.x}, ${F.y})`}function hP(F){return`(${F.r}, ${F.g}, ${F.b})`}function SP(F,P,f,N,q,H){const A=F.getInternalTexture().uniqueId+"_"+F.invertY;q[A]=F;const o=F.coordinatesIndex>0?"st"+F.coordinatesIndex:"st",j=new c.Vector2(F.uScale,F.vScale),i=new c.Vector2(F.uOffset,F.vOffset),u=F.wAng,T=Math.sin(u),Y=Math.cos(u);return i.y=1-i.y-j.y,i.x+=T*j.x,i.y+=(1-Y)*j.y,`\n    def Shader "PrimvarReader_${f}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${o}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${f}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${P.uniqueId}/PrimvarReader_${f}.outputs:result>\n        float inputs:rotation = ${(u*(180/Math.PI)).toFixed(H.precision)}\n        float2 inputs:scale = ${GP(j)}\n        float2 inputs:translation = ${GP(i)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${F.uniqueId}_${f}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${A}.png@\n        float2 inputs:st.connect = </Materials/Material_${P.uniqueId}/Transform2d_${f}.outputs:result>\n        ${N?"float4 inputs:scale = "+function(F){return`(${F.r}, ${F.g}, ${F.b}, 1.0)`}(N):""}\n        token inputs:sourceColorSpace = "${F.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${gP(F.wrapU)}"\n        token inputs:wrapT = "${gP(F.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${P.needAlphaBlending()?"float outputs:a":""}\n    }`}function Ff(F,P,f){const c="\t\t\t",N=[],q=[],{diffuseMap:H,uc:A,alphaCutOff:o,emissiveMap:j,emissive:i,normalMap:u,roughnessMap:T,roughnessChannel:Y,roughness:t,metalnessMap:C,metalnessChannel:J,metalness:B,aoMap:z,aoMapChannel:Z,aoMapIntensity:R,alphaMap:y,ior:O,clearCoatEnabled:d,clearCoat:M,clearCoatMap:V,clearCoatRoughness:Q,clearCoatRoughnessMap:K}=function(F){const P={diffuseMap:null,uc:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return F instanceof CF.JP?{...P,diffuseMap:F.diffuseTexture,uc:F.diffuseColor,alphaCutOff:F.alphaCutOff,emissiveMap:F.emissiveTexture,emissive:F.emissiveColor,roughness:1,alphaMap:F.opacityTexture}:F instanceof jP.d?{...P,diffuseMap:F._albedoTexture,uc:F._albedoColor,alphaCutOff:F._alphaCutOff,emissiveMap:F._emissiveTexture,emissive:F._emissiveColor,normalMap:F._bumpTexture,roughnessMap:F._metallicTexture,roughnessChannel:F._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:F._roughness??1,metalnessMap:F._metallicTexture,metalnessChannel:F._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:F._metallic??0,aoMap:F._ambientTexture,aoMapChannel:F._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:F._ambientTextureStrength,alphaMap:F._opacityTexture,ior:F.subSurface.indexOfRefraction,clearCoatEnabled:F.clearCoat.isEnabled,clearCoat:F.clearCoat.jc,clearCoatMap:F.clearCoat.texture,clearCoatRoughness:F.clearCoat.roughness,clearCoatRoughnessMap:F.clearCoat.useRoughnessFromMainTexture?F.clearCoat.texture:F.clearCoat.textureRoughness}:P}(F);return null!==H?(N.push(`${c}color3f inputs:diffuseColor.connect = </Materials/Material_${F.uniqueId}/Texture_${H.uniqueId}_diffuse.outputs:rgb>`),F.needAlphaBlending()?N.push(`${c}float inputs:opacity.connect = </Materials/Material_${F.uniqueId}/Texture_${H.uniqueId}_diffuse.outputs:a>`):F.needAlphaTesting()&&(N.push(`${c}float inputs:opacity.connect = </Materials/Material_${F.uniqueId}/Texture_${H.uniqueId}_diffuse.outputs:a>`),N.push(`${c}float inputs:opacityThreshold = ${o}`)),q.push(SP(H,F,"diffuse",A,P,f))):N.push(`${c}color3f inputs:diffuseColor = ${hP(A||L.BP.White())}`),null!==j?(N.push(`${c}color3f inputs:emissiveColor.connect = </Materials/Material_${F.uniqueId}/Texture_${j.uniqueId}_emissive.outputs:rgb>`),q.push(SP(j,F,"emissive",i,P,f))):i&&i.toLuminance()>0&&N.push(`${c}color3f inputs:emissiveColor = ${hP(i)}`),null!==u&&(N.push(`${c}normal3f inputs:normal.connect = </Materials/Material_${F.uniqueId}/Texture_${u.uniqueId}_normal.outputs:rgb>`),q.push(SP(u,F,"normal",null,P,f))),null!==z&&(N.push(`${c}float inputs:occlusion.connect = </Materials/Material_${F.uniqueId}/Texture_${z.uniqueId}_occlusion.outputs:${Z}>`),q.push(SP(z,F,"occlusion",new L.BP(R,R,R),P,f))),null!==T?(N.push(`${c}float inputs:roughness.connect = </Materials/Material_${F.uniqueId}/Texture_${T.uniqueId}_roughness.outputs:${Y}>`),q.push(SP(T,F,"roughness",new L.BP(t,t,t),P,f))):N.push(`${c}float inputs:roughness = ${t}`),null!==C?(N.push(`${c}float inputs:metallic.connect = </Materials/Material_${F.uniqueId}/Texture_${C.uniqueId}_metallic.outputs:${J}>`),q.push(SP(C,F,"metallic",new L.BP(B,B,B),P,f))):N.push(`${c}float inputs:metallic = ${B}`),null!==y?(N.push(`${c}float inputs:opacity.connect = </Materials/Material_${F.uniqueId}/Texture_${y.uniqueId}_opacity.outputs:r>`),N.push(`${c}float inputs:opacityThreshold = 0.0001`),q.push(SP(y,F,"opacity",null,P,f))):N.push(`${c}float inputs:opacity = ${F.alpha}`),d&&(null!==V?(N.push(`${c}float inputs:clearcoat.connect = </Materials/Material_${F.uniqueId}/Texture_${V.uniqueId}_clearcoat.outputs:r>`),q.push(SP(V,F,"clearcoat",new L.BP(M,M,M),P,f))):N.push(`${c}float inputs:clearcoat = ${M}`),null!==K?(N.push(`${c}float inputs:clearcoatRoughness.connect = </Materials/Material_${F.uniqueId}/Texture_${K.uniqueId}_clearcoatRoughness.outputs:g>`),q.push(SP(K,F,"clearcoatRoughness",new L.BP(Q,Q,Q),P,f))):N.push(`${c}float inputs:clearcoatRoughness = ${Q}`)),N.push(`${c}float inputs:ior = ${O}`),`\n\tdef Material "Material_${F.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${N.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${F.uniqueId}/PreviewSurface.outputs:surface>\n\n${q.join("\n")}\n\n\t}\n`}async function Pf(F,P,f){const q={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...P};"undefined"===typeof fflate&&await N.Tools.LoadScriptAsync(q.fflateUrl);const H={};H[q.modelFileName]=null;let A='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';A+=function(F){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===F.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${F.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${F.planeAnchoringAlignment}"`:""}\n            `}(q);const o={};for(const c of F.meshes){if(0===c.getTotalVertices())continue;const F=c,P=F.Sf,j=F.material;if(!j||!P||f&&!f(F))continue;if(-1!==["JP","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(j.getClassName())){const f="geometries/Geometry_"+P.uniqueId+".usda";if(!(f in H)){const F=sP(P,q);H[f]=XP(F)}j.uniqueId in o||(o[j.uniqueId]=j),A+=wP(F)}else N.Tools.Warn("USDZExportAsync does not support this material type: "+j.getClassName())}F.activeCamera&&q.exportCamera&&(A+=function(F,P){const f="Camera_"+F.uniqueId,N=mP(c.Matrix.RotationY(Math.PI).multiply(F.getWorldMatrix()));if(F.mode===O.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${f}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${N}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${F.Wf.toPrecision(P.precision)}, ${F.maxZ.toPrecision(P.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(F.orthoLeft||1)+Math.abs(F.orthoRight||1))).toPrecision(P.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(F.orthoTop||1)+Math.abs(F.orthoBottom||1))).toPrecision(P.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const c=F.getEngine().getAspectRatio(F),q=P.cameraSensorWidth||35;return`def Camera "${f}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${N}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${F.Wf.toPrecision(P.precision)}, ${F.maxZ.toPrecision(P.precision)})\n\t\t\tfloat focalLength = ${(q/(2*Math.tan(.5*F.fov))).toPrecision(P.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(q*c).toPrecision(P.precision)}\n\t\t\tfloat verticalAperture = ${(q/c).toPrecision(P.precision)}            \n\t\t}\n\t\n\t`}}(F.activeCamera,q)),A+="\n            }\n        }\n    }";const j={};A+=function(F,P,f){const c=[];for(const N in F){const q=F[N];c.push(Ff(q,P,f))}return`\n    def "Materials"\n{\n${c.join("")}\n}\n\n`}(o,j,q),H[q.modelFileName]=fflate.strToU8(A);for(const c in j){const F=j[c],P=F.getSize(),f=await F.readPixels();if(!f)throw new Error("Texture data is not available");const N=await d.DumpTools.DumpDataAsync(P.width,P.height,f,"image/png",void 0,!1,!0);H[`textures/Texture_${c}.png`]=new Uint8Array(N).slice()}let i=0;for(const c in H){const F=H[c];if(!F)continue;i+=34+c.length;const P=63&i;if(4!==P){const f=new Uint8Array(64-P);H[c]=[F,{extra:{12345:f}}]}i=F.length}return fflate.zipSync(H,{level:0})}}}]);