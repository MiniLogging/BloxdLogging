"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[26],{11616:(o,H,n)=>{n.r(H),n.d(H,{EXT_materials_diffuse_roughness:()=>CH,EXT_mesh_gpu_instancing:()=>ro,GLTF2Export:()=>vo,GLTFData:()=>S,KHR_draco_mesh_compression:()=>EH,KHR_lights_punctual:()=>SH,KHR_materials_anisotropy:()=>AH,KHR_materials_clearcoat:()=>xH,KHR_materials_diffuse_transmission:()=>JH,KHR_materials_dispersion:()=>hH,KHR_materials_emissive_strength:()=>pH,KHR_materials_ior:()=>mH,KHR_materials_iridescence:()=>bH,KHR_materials_sheen:()=>ZH,KHR_materials_specular:()=>KH,KHR_materials_transmission:()=>BH,KHR_materials_unlit:()=>DH,KHR_materials_volume:()=>aH,KHR_texture_transform:()=>XH,OBJExport:()=>O,STLExport:()=>sH,USDZExportAsync:()=>nn,_ConvertToGLTFPBRMetallicRoughness:()=>B,_SolveMetallic:()=>f,__IGLTFExporterExtension:()=>Y});var E=n(11189),k=n(11024),g=n(11529);class O{static OBJ(o,H,n,O){const Y=[];let y=1,S=1;H&&(n||(n="mat"),Y.push("mtllib "+n+".mtl"));for(let G=0;G<o.length;G++){const n=o[G],c=n.name||`mesh${G}}`;Y.push(`o ${c}`);let A=null;if(O){const o=n.Ig(!0);A=new E.Matrix,o.invertToRef(A),n.bakeTransformIntoVertices(o)}if(H){const o=n.material;o&&Y.push("usemtl "+o.id)}const l=n.wg;if(!l){k.Tools.Warn("No geometry is present on the mesh");continue}const x=l.getVerticesData("position"),z=l.getVerticesData("normal"),V=l.getVerticesData("uv"),J=l.dg();let N=0,h=0;if(!x||!J){k.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const Q=o[0].bo().useRightHandedSystem?1:-1;for(let o=0;o<x.length;o+=3)Y.push("v "+x[o]*Q+" "+x[o+1]+" "+x[o+2]),N++;if(null!=z)for(let o=0;o<z.length;o+=3)Y.push("vn "+z[o]*Q+" "+z[o+1]+" "+z[o+2]);if(null!=V)for(let o=0;o<V.length;o+=2)Y.push("vt "+V[o]+" "+V[o+1]),h++;const p=["","",""],j=(n.material||n.bo().defaultMaterial)._getEffectiveOrientation(n),[m,P]=j===g.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let o=0;o<J.length;o+=3){const H=[String(J[o]+y),String(J[o+m]+y),String(J[o+P]+y)],n=[String(J[o]+S),String(J[o+m]+S),String(J[o+P]+S)],E=H,k=null!=V?n:p,g=null!=z?H:p;Y.push("f "+E[0]+"/"+k[0]+"/"+g[0]+" "+E[1]+"/"+k[1]+"/"+g[1]+" "+E[2]+"/"+k[2]+"/"+g[2])}O&&A&&n.bakeTransformIntoVertices(A),y+=N,S+=h}return Y.join("\n")}static MTL(o){const H=[],n=o.material;H.push("newmtl mat1"),H.push("  Ns "+n.specularPower.toFixed(4)),H.push("  Ni 1.5000"),H.push("  d "+n.alpha.toFixed(4)),H.push("  Tr 0.0000"),H.push("  Tf 1.0000 1.0000 1.0000"),H.push("  illum 2"),H.push("  Ka "+n.ambientColor.r.toFixed(4)+" "+n.ambientColor.g.toFixed(4)+" "+n.ambientColor.b.toFixed(4)),H.push("  Kd "+n.diffuseColor.r.toFixed(4)+" "+n.diffuseColor.g.toFixed(4)+" "+n.diffuseColor.b.toFixed(4)),H.push("  Ks "+n.specularColor.r.toFixed(4)+" "+n.specularColor.g.toFixed(4)+" "+n.specularColor.b.toFixed(4)),H.push("  Ke "+n.emissiveColor.r.toFixed(4)+" "+n.emissiveColor.g.toFixed(4)+" "+n.emissiveColor.b.toFixed(4));n.ambientTexture&&H.push("  map_Ka "+n.ambientTexture.name),n.diffuseTexture&&H.push("  map_Kd "+n.diffuseTexture.name),n.specularTexture&&H.push("  map_Ks "+n.specularTexture.name),n.bumpTexture&&H.push("  map_bump -imfchan z "+n.bumpTexture.name),n.opacityTexture&&H.push("  map_d "+n.opacityTexture.name);return H.join("\n")}}var Y=0,y=n(11066);class S{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const o in this.files){const H=this.files[o],n=new Blob([H],{type:(0,y.f)(o)});k.Tools.Download(n,o)}}}var G=n(11259),c=n(11620),A=n(11626),l=n(11647),x=n(11321),z=n(11060),V=n(11238),J=n(11205);const N=J.HighestCommonFactor,h={...J,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:N};var Q=n(11422),p=n(11168),j=n(11680),m=n(11683),P=n(11420);const b=1e-6,e=new V.NH(.04,.04,.04),Z=1024,M=V.NH.White(),K=V.NH.Black();function f(o,H,n){if(H<e.r)return 0;const E=e.r,k=o*n/(1-e.r)+H-2*e.r,g=k*k-4*E*(e.r-H);return h.Clamp((-k+Math.sqrt(g))/(2*E),0,1)}function B(o){const H=o.diffuseColor.toLinearSpace(o.bo().getEngine().useExactSrgbConversions).scale(.5),n=o.alpha,k=function(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new E.Vector2(0,1),n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new E.Vector2(0,.1),k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new E.Vector2(0,.1),g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new E.Vector2(1300,.1);return function(o,H,n,E,k){return(1-o)*(1-o)*(1-o)*H+3*(1-o)*(1-o)*o*n+3*(1-o)*o*o*E+o*o*o*k}(Math.pow(o/g.x,.333333),H.y,n.y,k.y,g.y)}(h.Clamp(o.specularPower,0,Z));return{baseColorFactor:[H.r,H.g,H.b,n],metallicFactor:0,roughnessFactor:k}}function q(o,H){H.needAlphaBlending()?o.alphaMode="BLEND":H.needAlphaTesting()&&(o.alphaMode="MASK",o.alphaCutoff=H.alphaCutOff)}function D(o,H,n){const E=new Uint8Array(o*H*4);for(let k=0;k<E.length;k+=4)E[k]=E[k+1]=E[k+2]=E[k+3]=255;return j.b.CreateRGBATexture(E,o,H,n)}function T(o){if(o instanceof Uint8Array){const H=o.length,n=new Float32Array(o.length);for(let E=0;E<H;++E)n[E]=o[E]/255;return n}if(o instanceof Float32Array)return o;throw new Error("Unsupported pixel format!")}class a{constructor(o){this._exporter=o,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(o){return o?this._textureMap.get(o)??null:null}async exportStandardMaterialAsync(o,H,n){const E=B(o),g={name:o.name};if(null==o.Rg||o.Rg||(o.twoSidedLighting||k.Tools.Warn(o.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),g.doubleSided=!0),n){const n=[],k=o.diffuseTexture;k&&n.push(this.exportTextureAsync(k,H).then((o=>{o&&(E.baseColorTexture=o)})));const O=o.bumpTexture;O&&n.push(this.exportTextureAsync(O,H).then((o=>{o&&(g.normalTexture=o,1!==O.level&&(g.normalTexture.scale=O.level))})));const Y=o.emissiveTexture;Y&&(g.emissiveFactor=[1,1,1],n.push(this.exportTextureAsync(Y,H).then((o=>{o&&(g.emissiveTexture=o)}))));const y=o.ambientTexture;y&&n.push(this.exportTextureAsync(y,H).then((o=>{if(o){const H={index:o.index};g.occlusionTexture=H}}))),n.length>0&&(this._exporter._materialNeedsUVsSet.add(o),await Promise.all(n))}(o.alpha<1||o.opacityTexture)&&(o.alphaMode===m.b.ALPHA_COMBINE?g.alphaMode="BLEND":k.Tools.Warn(o.name+": glTF 2.0 does not support alpha mode: "+o.alphaMode.toString())),o.emissiveColor&&!o.emissiveColor.equalsWithEpsilon(K,b)&&(g.emissiveFactor=o.emissiveColor.bg()),g.pbrMetallicRoughness=E,q(g,o),await this._finishMaterialAsync(g,o,H);const O=this._exporter._materials;return O.push(g),O.length-1}async _finishMaterialAsync(o,H,n){const E=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",o,H),k=[];for(const g of E)k.push(this.exportTextureAsync(g,n));await Promise.all(k),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",o,H)}async _getImageDataAsync(o,H,E,k){const g=m.b.TEXTURETYPE_UNSIGNED_BYTE,O=this._exporter._babylonScene,Y=O.getEngine(),y=Y.createRawTexture(o,H,E,m.b.TEXTUREFORMAT_RGBA,!1,!0,p.c.NEAREST_SAMPLINGMODE,null,g);Y.isWebGPU?await n.e(51).then(n.bind(n,13717)):await n.e(52).then(n.bind(n,13724)),await Q.j.ApplyPostProcess("pass",y,O,g,m.b.TEXTURE_NEAREST_SAMPLINGMODE,m.b.TEXTUREFORMAT_RGBA);const S=await Y._readTexturePixels(y,H,E);return await P.DumpTools.DumpDataAsync(H,E,S,k,void 0,!0,!0)}_resizeTexturesToSameDimensions(o,H,n){const E=o?o.getSize():{width:0,height:0},k=H?H.getSize():{width:0,height:0};let g,O;return E.width<k.width?(g=o&&o instanceof p.c?Q.j.CreateResizedCopy(o,k.width,k.height,!0):D(k.width,k.height,n),O=H):E.width>k.width?(O=H&&H instanceof p.c?Q.j.CreateResizedCopy(H,E.width,E.height,!0):D(E.width,E.height,n),g=o):(g=o,O=H),{texture1:g,texture2:O}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(o,H,n,E){const k=new Array;if(!o&&!H)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const g=o?o.bo():H?H.bo():null;if(g){var O;const Y=this._resizeTexturesToSameDimensions(o,H,g),y=null===(O=Y.texture1)||void 0===O?void 0:O.getSize();let S,G;const c=y.width,A=y.height,l=await Y.texture1.readPixels(),x=await Y.texture2.readPixels();if(!l)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(S=T(l),!x)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");G=T(x);const z=G.byteLength,J=new Uint8Array(z),N=new Uint8Array(z),h=4,Q=K;let p=0,j=0;for(let o=0;o<A;++o)for(let H=0;H<c;++H){const E=(c*o+H)*h,k={diffuseColor:new V.NH(S[E],S[E+1],S[E+2]).toLinearSpace(g.getEngine().useExactSrgbConversions).multiply(n.diffuseColor),specularColor:new V.NH(G[E],G[E+1],G[E+2]).toLinearSpace(g.getEngine().useExactSrgbConversions).multiply(n.specularColor),glossiness:G[E+3]*n.glossiness},O=this._convertSpecularGlossinessToMetallicRoughness(k);Q.r=Math.max(Q.r,O.baseColor.r),Q.g=Math.max(Q.g,O.baseColor.g),Q.b=Math.max(Q.b,O.baseColor.b),p=Math.max(p,O.metallic),j=Math.max(j,O.roughness),N[E]=255*O.baseColor.r,N[E+1]=255*O.baseColor.g,N[E+2]=255*O.baseColor.b,N[E+3]=Y.texture1.fg?255*S[E+3]:255,J[E]=0,J[E+1]=255*O.roughness,J[E+2]=255*O.metallic,J[E+3]=255}const m={baseColor:Q,metallic:p,roughness:j};let P=!1,e=!1;for(let o=0;o<A;++o)for(let H=0;H<c;++H){const n=(c*o+H)*h;N[n]/=m.baseColor.r>b?m.baseColor.r:1,N[n+1]/=m.baseColor.g>b?m.baseColor.g:1,N[n+2]/=m.baseColor.b>b?m.baseColor.b:1;const E=V.NH.FromInts(N[n],N[n+1],N[n+2]).toGammaSpace(g.getEngine().useExactSrgbConversions);N[n]=255*E.r,N[n+1]=255*E.g,N[n+2]=255*E.b,E.equalsWithEpsilon(M,b)||(e=!0),J[n+1]/=m.roughness>b?m.roughness:1,J[n+2]/=m.metallic>b?m.metallic:1;V.NH.FromInts(255,J[n+1],J[n+2]).equalsWithEpsilon(M,b)||(P=!0)}return P&&k.push(this._getImageDataAsync(J,c,A,E).then((o=>{m.metallicRoughnessTextureData=o}))),e&&k.push(this._getImageDataAsync(N,c,A,E).then((o=>{m.baseColorTextureData=o}))),await Promise.all(k).then((()=>m))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(o){const H=this._getPerceivedBrightness(o.diffuseColor),n=this._getPerceivedBrightness(o.specularColor),E=1-this._getMaxComponent(o.specularColor),k=f(H,n,E),g=o.diffuseColor.scale(E/(1-e.r)/Math.max(1-k)),O=o.specularColor.zH(e.scale(1-k)).scale(1/Math.max(k));let Y=V.NH.Lerp(g,O,k*k);Y=Y.clampToRef(0,1,Y);return{baseColor:Y,metallic:k,roughness:1-o.glossiness}}_getPerceivedBrightness(o){return o?Math.sqrt(.299*o.r*o.r+.587*o.g*o.g+.114*o.b*o.b):0}_getMaxComponent(o){return o?Math.max(o.r,Math.max(o.g,o.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(o,H,n,E){const k=[],g={baseColor:o._albedoColor,metallic:o._metallic,roughness:o._roughness};if(E){o._albedoTexture&&k.push(this.exportTextureAsync(o._albedoTexture,H).then((o=>{o&&(n.baseColorTexture=o)})));const E=o._metallicTexture;E&&k.push(this.exportTextureAsync(E,H).then((o=>{o&&(n.metallicRoughnessTexture=o)})))}return k.length>0&&(this._exporter._materialNeedsUVsSet.add(o),await Promise.all(k)),g}_getTextureSampler(o){const H={};if(!o||!(o instanceof p.c))return H;const n=this._getGLTFTextureWrapMode(o.wrapU);10497!==n&&(H.wrapS=n);const E=this._getGLTFTextureWrapMode(o.wrapV);switch(10497!==E&&(H.wrapT=E),o.samplingMode){case p.c.LINEAR_LINEAR:H.magFilter=9729,H.minFilter=9729;break;case p.c.LINEAR_NEAREST:H.magFilter=9729,H.minFilter=9728;break;case p.c.NEAREST_LINEAR:H.magFilter=9728,H.minFilter=9729;break;case p.c.NEAREST_LINEAR_MIPLINEAR:H.magFilter=9728,H.minFilter=9987;break;case p.c.NEAREST_NEAREST:H.magFilter=9728,H.minFilter=9728;break;case p.c.NEAREST_LINEAR_MIPNEAREST:H.magFilter=9728,H.minFilter=9985;break;case p.c.LINEAR_NEAREST_MIPNEAREST:H.magFilter=9729,H.minFilter=9984;break;case p.c.LINEAR_NEAREST_MIPLINEAR:H.magFilter=9729,H.minFilter=9986;break;case p.c.NEAREST_NEAREST_MIPLINEAR:H.magFilter=9728,H.minFilter=9986;break;case p.c.LINEAR_LINEAR_MIPLINEAR:H.magFilter=9729,H.minFilter=9987;break;case p.c.LINEAR_LINEAR_MIPNEAREST:H.magFilter=9729,H.minFilter=9985;break;case p.c.NEAREST_NEAREST_MIPNEAREST:H.magFilter=9728,H.minFilter=9984}return H}_getGLTFTextureWrapMode(o){switch(o){case p.c.WRAP_ADDRESSMODE:return 10497;case p.c.CLAMP_ADDRESSMODE:return 33071;case p.c.MIRROR_ADDRESSMODE:return 33648;default:return k.Tools.Error(`Unsupported Texture Wrap Mode ${o}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(o,H,n,E){const k={diffuseColor:o._albedoColor,specularColor:o._reflectivityColor,glossiness:o._microSurface},g=o._albedoTexture,O=o._reflectivityTexture,Y=o._useMicroSurfaceFromReflectivityMapAlpha;if(O&&!Y)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((g||O)&&E){this._exporter._materialNeedsUVsSet.add(o);const E=this._exportTextureSampler(g||O),Y=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(g,O,k,H),y=this._exporter._textures;if(Y.baseColorTextureData){const o=this._exportImage(`baseColor${y.length}`,H,Y.baseColorTextureData);n.baseColorTexture=this._exportTextureInfo(o,E,null===g||void 0===g?void 0:g.coordinatesIndex)}if(Y.metallicRoughnessTextureData){const o=this._exportImage(`metallicRoughness${y.length}`,H,Y.metallicRoughnessTextureData);n.metallicRoughnessTexture=this._exportTextureInfo(o,E,null===O||void 0===O?void 0:O.coordinatesIndex)}return Y}return this._convertSpecularGlossinessToMetallicRoughness(k)}async exportPBRMaterialAsync(o,H,n){const E={},k={name:o.name},g=o.isMetallicWorkflow();if(g){const H=o._albedoColor,n=o.alpha;H&&(E.baseColorFactor=[H.r,H.g,H.b,n])}const O=g?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(o,H,E,n):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(o,H,E,n);await this._setMetallicRoughnessPbrMaterialAsync(O,o,k,E,H,n),await this._finishMaterialAsync(k,o,H);const Y=this._exporter._materials;return Y.push(k),Y.length-1}async _setMetallicRoughnessPbrMaterialAsync(o,H,n,E,g,O){if(q(n,H),o.baseColor.equalsWithEpsilon(M,b)&&h.WithinEpsilon(H.alpha,1,b)||(E.baseColorFactor=[o.baseColor.r,o.baseColor.g,o.baseColor.b,H.alpha]),null!=o.metallic&&1!==o.metallic&&(E.metallicFactor=o.metallic),null!=o.roughness&&1!==o.roughness&&(E.roughnessFactor=o.roughness),null==H.Rg||H.Rg||(H._twoSidedLighting||k.Tools.Warn(H.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),n.doubleSided=!0),O){const o=[],E=H._bumpTexture;E&&o.push(this.exportTextureAsync(E,g).then((o=>{o&&(n.normalTexture=o,1!==E.level&&(n.normalTexture.scale=E.level))})));const k=H._ambientTexture;k&&o.push(this.exportTextureAsync(k,g).then((o=>{if(o){const E={index:o.index,texCoord:o.texCoord,extensions:o.extensions};n.occlusionTexture=E;const k=H._ambientTextureStrength;k&&(E.strength=k)}})));const O=H._emissiveTexture;O&&o.push(this.exportTextureAsync(O,g).then((o=>{o&&(n.emissiveTexture=o)}))),o.length>0&&(this._exporter._materialNeedsUVsSet.add(H),await Promise.all(o))}const Y=H._emissiveColor;Y.equalsWithEpsilon(K,b)||(n.emissiveFactor=Y.bg()),n.pbrMetallicRoughness=E}_getPixelsFromTextureAsync(o){return function(o){switch(o){case m.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case m.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case m.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case m.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case m.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case m.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case m.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case m.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case m.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case m.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case m.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case m.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case m.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case m.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case m.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case m.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case m.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case m.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case m.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case m.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case m.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(o.textureFormat)?(0,Q.h)(o,o._texture.width,o._texture.height):(o.textureType,m.b.TEXTURETYPE_UNSIGNED_BYTE,o.readPixels())}async exportTextureAsync(o,H){const n=this._exporter._extensionsPreExportTextureAsync("exporter",o,H);return n?await n.then((async n=>n?await this._exportTextureInfoAsync(n,H):await this._exportTextureInfoAsync(o,H))):await this._exportTextureInfoAsync(o,H)}async _exportTextureInfoAsync(o,H){let n=this._textureMap.get(o);if(!n){const E=await this._getPixelsFromTextureAsync(o);if(!E)return null;const g=this._exportTextureSampler(o),O=o.mimeType;if(O)switch(O){case"image/jpeg":case"image/png":case"image/webp":H=O;break;default:k.Tools.Warn(`Unsupported media type: ${O}. Exporting texture as PNG.`)}const Y=this._internalTextureToImage,y=o.getInternalTexture().uniqueId;Y[y]||(Y[y]={});let S=Y[y][H];if(void 0===S){const n=o.getSize();S=(async()=>{const k=await this._getImageDataAsync(E,n.width,n.height,H);return this._exportImage(o.name,H,k)})(),Y[y][H]=S}n=this._exportTextureInfo(await S,g,o.coordinatesIndex),this._textureMap.set(o,n),this._exporter._extensionsPostExportTextures("exporter",n,o)}return n}_exportImage(o,H,n){const E=this._exporter._images;let g;if(this._exporter._shouldUseGlb){g={name:o,mimeType:H,bufferView:void 0};const E=this._exporter._bufferManager.createBufferView(new Uint8Array(n));this._exporter._bufferManager.setBufferView(g,E)}else{const O=o.replace(/\.\/|\/|\.\\|\\/g,"_"),Y=function(o){switch(o){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(H);let y=O+Y;E.some((o=>o.uri===y))&&(y=`${O}_${k.Tools.RandomId()}${Y}`),g={name:o,uri:y},this._exporter._imageData[y]={data:n,mimeType:H}}return E.push(g),E.length-1}_exportTextureInfo(o,H,n){const E=this._exporter._textures;let k=E.findIndex((n=>n.sampler==H&&n.source===o));-1===k&&(k=E.length,E.push({source:o,sampler:H}));const g={index:k};return n&&(g.texCoord=n),g}_exportTextureSampler(o){const H=this._getTextureSampler(o),n=this._exporter._samplers,E=n.findIndex((o=>o.minFilter===H.minFilter&&o.magFilter===H.magFilter&&o.wrapS===H.wrapS&&o.wrapT===H.wrapT));return-1!==E?E:(n.push(H),n.length-1)}}var F=n(11276),C=n(11038),t=n(11686),X=n(11196);const s=E.xH.Zero(),U=E.Quaternion.Identity(),I=E.xH.One(),v=new E.xH(-1,1,1);function w(o,H){const{byteOffset:n,byteStride:E,type:k,normalized:g}=o,O=o.getSize(),Y=H.reduce(((o,H)=>H.getTotalVertices()>o?H.getTotalVertices():o),-Number.MAX_VALUE);return{byteOffset:n,byteStride:E,componentCount:O,type:k,count:Y*O,normalized:g,totalVertices:Y,kind:o.getKind()}}function r(o){switch(o){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function u(o){switch(o){case G.d.PositionKind:case G.d.NormalKind:case G.d.TangentKind:case G.d.ColorKind:case G.d.MatricesIndicesKind:case G.d.MatricesIndicesExtraKind:case G.d.MatricesWeightsKind:case G.d.MatricesWeightsExtraKind:case G.d.UVKind:case G.d.UV2Kind:case G.d.UV3Kind:case G.d.UV4Kind:case G.d.UV5Kind:case G.d.UV6Kind:return!0}return!1}function d(o){switch(o){case g.e.TriangleFillMode:return 4;case g.e.TriangleStripDrawMode:return 5;case g.e.TriangleFanDrawMode:return 6;case g.e.PointListDrawMode:case g.e.PointFillMode:return 0;case g.e.LineLoopDrawMode:return 2;case g.e.LineListDrawMode:return 1;case g.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${o}`)}function R(o){const H=Math.sqrt(o.x*o.x+o.y*o.y+o.z*o.z);H>0&&(o.x/=H,o.y/=H,o.z/=H)}function W(o){return o.x*=-1,o}function i(o){if(o.x*o.x+o.y*o.y>.5){const H=Math.abs(o.x),n=Math.abs(o.y);if(H>n){const n=Math.sign(o.x);o.x=H,o.y*=-n,o.z*=-n,o.w*=n}else{const H=Math.sign(o.y);o.x*=-H,o.y=n,o.z*=H,o.w*=-H}}else{const H=Math.abs(o.z),n=Math.abs(o.w);if(H>n){const n=Math.sign(o.z);o.x*=-n,o.y*=n,o.z=H,o.w*=-n}else{const H=Math.sign(o.w);o.x*=H,o.y*=-H,o.z*=-H,o.w=n}}return o}function L(o){o.Wg(-o.z,o.w,o.x,-o.y)}function oo(o,H){const n=E.xH.FromArrayToRef(H.translation||[0,0,0],0,E.TmpVectors.xH[0]),k=E.Quaternion.FromArrayToRef(H.rotation||[0,0,0,1],0,E.TmpVectors.Quaternion[0]),g=E.Matrix.ComposeToRef(I,k,n,E.TmpVectors.Matrix[0]),O=E.xH.FromArrayToRef(o.translation||[0,0,0],0,E.TmpVectors.xH[2]),Y=E.Quaternion.FromArrayToRef(o.rotation||[0,0,0,1],0,E.TmpVectors.Quaternion[1]),y=E.Matrix.ComposeToRef(I,Y,O,E.TmpVectors.Matrix[1]);g.multiplyToRef(y,y),y.decompose(void 0,k,n),n.equalsWithEpsilon(s,X.e)?delete H.translation:H.translation=n.bg(),k.equalsWithEpsilon(U,X.e)?delete H.rotation:H.rotation=k.bg(),H.scale&&delete H.scale}function Ho(o,H){if(!(H instanceof c.b))return!1;if(!(1===H.getChildren().length&&0===o.getChildren().length&&o.parent===H))return!1;const n=o.bo(),E=o instanceof t.b&&!n.useRightHandedSystem?v:I;return!!H.cY.equalsWithEpsilon(E,X.e)||(C.d.Warn(`Cannot collapse node ${o.name} into parent node ${H.name} with modified scaling.`),!1)}function no(o){if(o instanceof Array){const H=new Float32Array(o);return new Uint8Array(H.buffer,H.byteOffset,H.byteLength)}return ArrayBuffer.isView(o)?new Uint8Array(o.buffer,o.byteOffset,o.byteLength):new Uint8Array(o)}function Eo(o,H){for(const[n,E]of Object.entries(o)){const k=H[n];(Array.isArray(E)&&Array.isArray(k)&&ko(E,k)||E===k)&&delete o[n]}return o}function ko(o,H){return o.length===H.length&&o.every(((o,n)=>o===H[n]))}const go=E.Matrix.Compose(new E.xH(-1,1,1),E.Quaternion.Identity(),E.xH.Zero());function Oo(o,H){if(!(o instanceof c.b))return!1;if(H){if(!o.getWorldMatrix().equalsWithEpsilon(E.Matrix.IdentityReadOnly,X.e))return!1}else{if(!o.getWorldMatrix().multiplyToRef(go,E.TmpVectors.Matrix[0]).equalsWithEpsilon(E.Matrix.IdentityReadOnly,X.e))return!1}return!(o instanceof A.e&&o.wg)}const Yo=new Map([[Int8Array,(o,H,n)=>o.setInt8(H,n)],[Uint8Array,(o,H,n)=>o.setUint8(H,n)],[Uint8ClampedArray,(o,H,n)=>o.setUint8(H,n)],[Int16Array,(o,H,n)=>o.setInt16(H,n,!0)],[Uint16Array,(o,H,n)=>o.setUint16(H,n,!0)],[Int32Array,(o,H,n)=>o.setInt32(H,n,!0)],[Uint32Array,(o,H,n)=>o.setUint32(H,n,!0)],[Float32Array,(o,H,n)=>o.setFloat32(H,n,!0)],[Float64Array,(o,H,n)=>o.setFloat64(H,n,!0)]]);class yo{writeTypedArray(o){this._checkGrowBuffer(o.byteLength);const H=Yo.get(o.constructor);for(let n=0;n<o.length;n++)H(this._dataView,this._byteOffset,o[n]),this._byteOffset+=o.BYTES_PER_ELEMENT}constructor(o){this._data=new Uint8Array(o),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(o){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,o),this._byteOffset++}writeInt8(o){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,o),this._byteOffset++}writeInt16(o){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,o,!0),this._byteOffset+=2}writeUInt16(o){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,o,!0),this._byteOffset+=2}writeInt32(o){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,o,!0),this._byteOffset+=4}writeUInt32(o){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,o,!0),this._byteOffset+=4}writeFloat32(o){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,o,!0),this._byteOffset+=4}writeFloat64(o){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,o,!0),this._byteOffset+=8}_checkGrowBuffer(o){const H=this.byteOffset+o;if(H>this._data.byteLength){const o=new Uint8Array(2*H);o.set(this._data),this._data=o,this._dataView=new DataView(this._data.buffer)}}}function So(o){return o%4===0?4:o%2===0?2:1}class Go{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(o){let H=0;this._bufferViewToData.forEach((o=>{H+=o.byteLength}));const n=new yo(H),E=Array.from(this._bufferViewToData.keys()).sort(((o,H)=>So(H.byteLength)-So(o.byteLength)));for(const k of E){k.byteOffset=n.byteOffset,o.push(k);const H=o.length-1,E=this.getPropertiesWithBufferView(k);for(const o of E)o.bufferView=H;n.writeTypedArray(this._bufferViewToData.get(k)),this._bufferViewToData.delete(k)}return n.getOutputData()}createBufferView(o,H){const n={buffer:0,byteOffset:void 0,byteLength:o.byteLength,byteStride:H};return this._bufferViewToData.set(n,o),n}createAccessor(o,H,n,E,k,g,O){this._verifyBufferView(o);const Y={bufferView:void 0,componentType:n,count:E,type:H,min:null===g||void 0===g?void 0:g.min,max:null===g||void 0===g?void 0:g.max,normalized:O,byteOffset:k};return this.setBufferView(Y,o),this._accessorToBufferView.set(Y,o),Y}setBufferView(o,H){this._verifyBufferView(H);this.getPropertiesWithBufferView(H).push(o)}removeBufferView(o){const H=this.getPropertiesWithBufferView(o);for(const n of H)void 0!==n.bufferView&&delete n.bufferView;this._bufferViewToData.delete(o),this._bufferViewToProperties.delete(o),this._accessorToBufferView.forEach(((H,n)=>{H===o&&(void 0!==n.byteOffset&&delete n.byteOffset,this._accessorToBufferView.delete(n))}))}getBufferView(o){const H=this._accessorToBufferView.get(o);return this._verifyBufferView(H),H}getPropertiesWithBufferView(o){return this._verifyBufferView(o),this._bufferViewToProperties.set(o,this._bufferViewToProperties.get(o)??[]),this._bufferViewToProperties.get(o)}getData(o){return this._verifyBufferView(o),this._bufferViewToData.get(o)}_verifyBufferView(o){if(void 0===o||!this._bufferViewToData.has(o))throw new Error(`BufferView ${o} not found in BufferManager.`)}}var co,Ao=n(11659),lo=n(11676),xo=n(11688),zo=n(11568),Vo=n(11717),Jo=n(11730),No=n(11652),ho=n(11738);!function(o){o[o.INTANGENT=0]="INTANGENT",o[o.OUTTANGENT=1]="OUTTANGENT"}(co||(co={}));class Qo{static _IsTransformable(o){return o&&(o instanceof c.b||o instanceof Ao.b||o instanceof ho.e)}static _CreateNodeAnimation(o,H,n,E,g){if(this._IsTransformable(o)){const O=[],Y=[],y=H.getKeys(),S=Qo._CalculateMinMaxKeyFrames(y),G=Qo._DeduceInterpolation(y,n,E),c=G.interpolationType,A=G.shouldBakeAnimation;if(A?Qo._CreateBakedAnimation(o,H,n,S.min,S.max,H.framePerSecond,g,O,Y,S,E):"LINEAR"===c||"STEP"===c?Qo._CreateLinearOrStepAnimation(o,H,n,O,Y,E):"CUBICSPLINE"===c?Qo._CreateCubicSplineAnimation(o,H,n,O,Y,E):Qo._CreateBakedAnimation(o,H,n,S.min,S.max,H.framePerSecond,g,O,Y,S,E),O.length&&Y.length){return{inputs:O,outputs:Y,samplerInterpolation:c,inputsMin:A?S.min:k.Tools.FloatRound(S.min/H.framePerSecond),inputsMax:A?S.max:k.Tools.FloatRound(S.max/H.framePerSecond)}}}return null}static _DeduceAnimationInfo(o){let H=null,n="VEC3",E=!1;const g=o.targetProperty.split(".");switch(g[0]){case"cY":H="scale";break;case"position":H="translation";break;case"rotation":n="VEC4",H="rotation";break;case"rotationQuaternion":n="VEC4",E=!0,H="rotation";break;case"influence":n="SCALAR",H="weights";break;default:k.Tools.Error(`Unsupported animatable property ${g[0]}`)}return H?{animationChannelTargetPath:H,dataAccessorType:n,useQuaternion:E}:(k.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(o,H,n,E,k,g,O,Y,y,S,G){let c;if(Qo._IsTransformable(o)&&o.animations)for(const A of o.animations){if(G&&!G(A))continue;const k=Qo._DeduceAnimationInfo(A);k&&(c={name:A.name,samplers:[],channels:[]},Qo._AddAnimation(`${A.name}`,A.hasRunningRuntimeAnimations?H:c,o,A,k.dataAccessorType,k.animationChannelTargetPath,E,g,O,Y,k.useQuaternion,y,S),c.samplers.length&&c.channels.length&&n.push(c))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(o,H,n,E,k,g,O,Y,y,S,G){let c;if(o instanceof No.b){const k=o.morphTargetManager;if(k)for(let A=0;A<k.numTargets;++A){const l=k.getTarget(A);for(const x of l.animations){if(G&&!G(x))continue;const l=new Vo.b(`${x.name}`,"influence",x.framePerSecond,x.dataType,x.loopMode,x.enableBlending),z=[],V=x.getKeys();for(let o=0;o<V.length;++o){const H=V[o];for(let o=0;o<k.numTargets;++o)o==A?z.push(H):z.push({frame:H.frame,value:0})}l.setKeys(z);const J=Qo._DeduceAnimationInfo(l);J&&(c={name:l.name,samplers:[],channels:[]},Qo._AddAnimation(x.name,x.hasRunningRuntimeAnimations?H:c,o,l,J.dataAccessorType,J.animationChannelTargetPath,E,g,O,Y,J.useQuaternion,y,S,k.numTargets),c.samplers.length&&c.channels.length&&n.push(c))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(o,H,n,E,k,g,O,Y,y){let S;if(o.animationGroups){const c=o.animationGroups;for(const A of c){const c=new Map,l=new Map,x=new Set,z=A.to-A.from;S={name:A.name,channels:[],samplers:[]};for(let H=0;H<A.targetedAnimations.length;++H){const z=A.targetedAnimations[H],V=z.target,J=z.animation;if(y&&!y(J))continue;const N=Y.has(V);if(this._IsTransformable(V)||1===V.length&&this._IsTransformable(V[0])){const o=Qo._DeduceAnimationInfo(z.animation);if(o){const H=this._IsTransformable(V)?V:this._IsTransformable(V[0])?V[0]:null;H&&Qo._AddAnimation(`${J.name}`,S,H,J,o.dataAccessorType,o.animationChannelTargetPath,n,E,k,g,o.useQuaternion,O,N)}}else if(V instanceof Jo.d||1===V.length&&V[0]instanceof Jo.d){if(Qo._DeduceAnimationInfo(z.animation)){const H=V instanceof Jo.d?V:V[0];if(H){const n=o.morphTargetManagers.find((o=>{for(let n=0;n<o.numTargets;++n)if(o.getTarget(n)===H)return!0;return!1}));if(n){const E=o.meshes.find((o=>o.morphTargetManager===n));var G;if(E)c.has(E)||c.set(E,new Map),null===(G=c.get(E))||void 0===G||G.set(H,J),x.add(E),l.set(E,J)}}}}}x.forEach((o=>{const H=o.morphTargetManager;let Y=null;const y=[],G=l.get(o).getKeys(),x=G.length;for(let n=0;n<x;++n)for(let E=0;E<H.numTargets;++E){const k=H.getTarget(E),g=c.get(o);if(g){const H=g.get(k);H?(Y||(Y=new Vo.b(`${A.name}_${o.name}_MorphWeightAnimation`,"influence",H.framePerSecond,Vo.b.ANIMATIONTYPE_FLOAT,H.loopMode,H.enableBlending)),y.push(H.getKeys()[n])):y.push({frame:A.from+z/x*n,value:k.influence,inTangent:G[0].inTangent?0:void 0,outTangent:G[0].outTangent?0:void 0})}}Y.setKeys(y);const V=Qo._DeduceAnimationInfo(Y);V&&Qo._AddAnimation(`${A.name}_${o.name}_MorphWeightAnimation`,S,o,Y,V.dataAccessorType,V.animationChannelTargetPath,n,E,k,g,V.useQuaternion,O,!1,null===H||void 0===H?void 0:H.numTargets)})),S.channels.length&&S.samplers.length&&H.push(S)}}}static _AddAnimation(o,H,n,k,g,O,Y,y,S,G,c,A,l,x){const z=Qo._CreateNodeAnimation(n,k,O,c,A);let V,J,N,h,Q,p;if(z){if(x){let o=0,H=0;const n=[];for(;z.inputs.length>0;)H=z.inputs.shift(),o%x==0&&n.push(H),o++;z.inputs=n}const o=Y.get(n),k=new Float32Array(z.inputs);V=y.createBufferView(k),J=y.createAccessor(V,"SCALAR",5126,z.inputs.length,void 0,{min:[z.inputsMin],max:[z.inputsMax]}),G.push(J),N=G.length-1;const S=new E.Quaternion,c=new E.xH,A=new E.xH,j=n instanceof Ao.b,m=r(g),P=new Float32Array(z.outputs.length*m);z.outputs.forEach((function(o,H){let n=o;switch(O){case"translation":l&&(E.xH.FromArrayToRef(o,0,A),W(A),A.toArray(n));break;case"rotation":4===o.length?E.Quaternion.FromArrayToRef(o,0,S):(n=new Array(4),E.xH.FromArrayToRef(o,0,c),E.Quaternion.FromEulerVectorToRef(c,S)),l&&(i(S),j&&L(S)),S.toArray(n)}P.set(n,H*m)})),V=y.createBufferView(P),J=y.createAccessor(V,g,5126,z.outputs.length),G.push(J),h=G.length-1,Q={interpolation:z.samplerInterpolation,input:N,output:h},H.samplers.push(Q),p={sampler:H.samplers.length-1,target:{node:o,path:O}},H.channels.push(p)}}static _CreateBakedAnimation(o,H,n,g,O,Y,y,S,G,c,A){let l;const x=E.Quaternion.Identity();let z,V=null,J=null,N=null,h=null,Q=null,p=null;c.min=k.Tools.FloatRound(g/Y);const j=H.getKeys();for(let E=0,m=j.length;E<m;++E){if(p=null,N=j[E],E+1<m)if(h=j[E+1],N.value.equals&&N.value.equals(h.value)||N.value===h.value){if(0!==E)continue;p=N.frame}else p=h.frame;else{if(Q=j[E-1],N.value.equals&&N.value.equals(Q.value)||N.value===Q.value)continue;p=O}if(p)for(let E=N.frame;E<=p;E+=y){if(z=k.Tools.FloatRound(E/Y),z===V)continue;V=z,J=z;const g={key:0,repeatCount:0,loopMode:H.loopMode};l=H._interpolate(E,g),Qo._SetInterpolatedValue(o,l,z,H,n,x,S,G,A)}}J&&(c.max=J)}static _ConvertFactorToVector3OrQuaternion(o,H,n,g,O){const Y=Qo._GetBasePositionRotationOrScale(H,g,O),y=n.targetProperty.split("."),S=y?y[1]:"",G=O?E.Quaternion.Mg(Y).normalize():E.xH.Mg(Y);switch(S){case"x":case"y":case"z":G[S]=o;break;case"w":G.w=o;break;default:k.Tools.Error(`glTFAnimation: Unsupported component name "${S}"!`)}return G}static _SetInterpolatedValue(o,H,n,k,g,O,Y,y,S){let G;Y.push(n),"weights"!==g?(k.dataType===Vo.b.ANIMATIONTYPE_FLOAT&&(H=this._ConvertFactorToVector3OrQuaternion(H,o,k,g,S)),"rotation"===g?(S?O=H:(G=H,E.Quaternion.RotationYawPitchRollToRef(G.y,G.x,G.z,O)),y.push(O.bg())):(G=H,y.push(G.bg()))):y.push([H])}static _CreateLinearOrStepAnimation(o,H,n,E,k,g){for(const O of H.getKeys())E.push(O.frame/H.framePerSecond),Qo._AddKeyframeValue(O,H,k,n,o,g)}static _CreateCubicSplineAnimation(o,H,n,E,k,g){H.getKeys().forEach((function(O){E.push(O.frame/H.framePerSecond),Qo._AddSplineTangent(co.INTANGENT,k,n,"CUBICSPLINE",O,g),Qo._AddKeyframeValue(O,H,k,n,o,g),Qo._AddSplineTangent(co.OUTTANGENT,k,n,"CUBICSPLINE",O,g)}))}static _GetBasePositionRotationOrScale(o,H,n){let k;if("rotation"===H)if(n){k=(o.rotationQuaternion??E.Quaternion.Identity()).bg()}else{k=(o.rotation??E.xH.Zero()).bg()}else if("translation"===H){k=(o.position??E.xH.Zero()).bg()}else{k=(o.cY??E.xH.One()).bg()}return k}static _AddKeyframeValue(o,H,n,g,O,Y){let y;const S=H.dataType;if(S===Vo.b.ANIMATIONTYPE_VECTOR3){let H=o.value.bg();if("rotation"===g){const o=E.xH.Mg(H);H=E.Quaternion.RotationYawPitchRoll(o.y,o.x,o.z).bg()}n.push(H)}else if(S===Vo.b.ANIMATIONTYPE_FLOAT){if("weights"===g)n.push([o.value]);else if(y=this._ConvertFactorToVector3OrQuaternion(o.value,O,H,g,Y),y){if("rotation"===g){const o=Y?y:E.Quaternion.RotationYawPitchRoll(y.y,y.x,y.z).normalize();n.push(o.bg())}n.push(y.bg())}}else S===Vo.b.ANIMATIONTYPE_QUATERNION?n.push(o.value.normalize().bg()):k.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(o,H,n){let E,k,g=!1;if("rotation"===H&&!n)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let O=0,Y=o.length;O<Y;++O)if(k=o[O],k.inTangent||k.outTangent)if(E){if("CUBICSPLINE"!==E){E="LINEAR",g=!0;break}}else E="CUBICSPLINE";else if(E){if("CUBICSPLINE"===E||k.interpolation&&1===k.interpolation&&"STEP"!==E){E="LINEAR",g=!0;break}}else E=k.interpolation&&1===k.interpolation?"STEP":"LINEAR";return E||(E="LINEAR"),{interpolationType:E,shouldBakeAnimation:g}}static _AddSplineTangent(o,H,n,k,g,O){let Y;const y=o===co.INTANGENT?g.inTangent:g.outTangent;if("CUBICSPLINE"===k){if("rotation"===n)if(y)if(O)Y=y.bg();else{const o=y;Y=E.Quaternion.RotationYawPitchRoll(o.y,o.x,o.z).bg()}else Y=[0,0,0,0];else Y="weights"===n?y?[y]:[0]:y?y.bg():[0,0,0];H.push(Y)}}static _CalculateMinMaxKeyFrames(o){let H=1/0,n=-1/0;return o.forEach((function(o){H=Math.min(H,o.frame),n=Math.max(n,o.frame)})),{min:H,max:n}}}function po(o,H,n,g,O,Y){const y={attributes:{},influence:o.influence,name:o.name},S=H.wg;if(!S)return k.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),y;const c=Y?-1:1,A=E.xH.Zero();let l=0,x=0;if(o.hasPositions){const g=o.getPositions(),Y=S.getVerticesData(G.d.PositionKind);if(Y){const o=new Float32Array(Y.length),H=[1/0,1/0,1/0],k=[-1/0,-1/0,-1/0];x=Y.length/3,l=0;for(let n=l;n<x;++n){const O=E.xH.Mg(Y,3*n);E.xH.Mg(g,3*n).subtractToRef(O,A),A.x*=c,H[0]=Math.min(H[0],A.x),k[0]=Math.max(k[0],A.x),H[1]=Math.min(H[1],A.y),k[1]=Math.max(k[1],A.y),H[2]=Math.min(H[2],A.z),k[2]=Math.max(k[2],A.z),o[3*n]=A.x,o[3*n+1]=A.y,o[3*n+2]=A.z}const S=n.createBufferView(o,12),G=n.createAccessor(S,"VEC3",5126,g.length/3,0,{min:H,max:k});O.push(G),y.attributes.POSITION=O.length-1}else k.Tools.Warn(`Morph target positions for mesh ${H.name} were not exported. Mesh does not have position vertex data`)}if(o.hasNormals){const g=o.getNormals(),Y=S.getVerticesData(G.d.NormalKind);if(Y){const o=new Float32Array(Y.length);x=Y.length/3,l=0;for(let n=l;n<x;++n){const H=E.xH.Mg(Y,3*n).normalize();E.xH.Mg(g,3*n).normalize().subtractToRef(H,A),o[3*n]=A.x*c,o[3*n+1]=A.y,o[3*n+2]=A.z}const H=n.createBufferView(o,12),k=n.createAccessor(H,"VEC3",5126,g.length/3,0);O.push(k),y.attributes.NORMAL=O.length-1}else k.Tools.Warn(`Morph target normals for mesh ${H.name} were not exported. Mesh does not have normals vertex data`)}if(o.hasTangents){const g=o.getTangents(),Y=S.getVerticesData(G.d.TangentKind);if(Y){x=Y.length/4;const o=new Float32Array(3*x);l=0;for(let n=l;n<x;++n){const H=E.xH.Mg(Y,4*n);R(H);const k=E.xH.Mg(g,3*n);R(k),k.subtractToRef(H,A),o[3*n]=A.x*c,o[3*n+1]=A.y,o[3*n+2]=A.z}const H=n.createBufferView(o,12),k=n.createAccessor(H,"VEC3",5126,x,0);O.push(k),y.attributes.TANGENT=O.length-1}else k.Tools.Warn(`Morph target tangents for mesh ${H.name} were not exported. Mesh does not have tangents vertex data`)}if(o.hasColors){const g=o.getColors(),Y=S.getVerticesData(G.d.ColorKind),c=S.getVertexBuffer(G.d.ColorKind);if(Y&&c){const o=c.getSize();x=Y.length/o;const H=new Float32Array(x*o);l=0;for(let n=l;n<x;++n)if(3===o){const k=E.xH.Mg(Y,n*o);E.xH.Mg(g,n*o).subtractToRef(k,A),H[3*n]=A.x,H[3*n+1]=A.y,H[3*n+2]=A.z}else if(4===o){const k=new E.Vector4,O=E.Vector4.Mg(Y,n*o);E.Vector4.Mg(g,n*o).subtractToRef(O,k),H[4*n]=k.x,H[4*n+1]=k.y,H[4*n+2]=k.z,H[4*n+3]=k.w}else k.Tools.Warn(`Unsupported number of components for color attribute: ${o}`);const S=n.createBufferView(H,4*o),G=n.createAccessor(S,3===o?"VEC3":"VEC4",5126,x,0);O.push(G),y.attributes.COLOR_0=O.length-1}else k.Tools.Warn(`Morph target colors for mesh ${H.name} were not exported. Mesh does not have colors vertex data`)}return y}var jo=n(11741),mo=n(11603),Po=n(11580),bo=n(11140);class eo{}eo.DEFAULT_COLOR=V.NH.White(),eo.DEFAULT_WIDTH_ATTENUATED=1,eo.DEFAULT_WIDTH=.1;var Zo=n(11410),Mo=n(11748);class Ko{static ConvertPoints(o,H){if(o.length&&Array.isArray(o)&&"number"===typeof o[0])return[o];if(o.length&&Array.isArray(o[0])&&"number"===typeof o[0][0])return o;if(o.length&&!Array.isArray(o[0])&&o[0]instanceof E.xH){const H=[];for(let n=0;n<o.length;n++){const E=o[n];H.push(E.x,E.y,E.z)}return[H]}if(o.length>0&&Array.isArray(o[0])&&o[0].length>0&&o[0][0]instanceof E.xH){const H=[],n=o;for(const o of n)H.push(o.flatMap((o=>[o.x,o.y,o.z])));return H}if(o instanceof Float32Array){if(null!==H&&void 0!==H&&H.floatArrayStride){const n=[],E=3*H.floatArrayStride;for(let H=0;H<o.length;H+=E){const k=new Array(E);for(let n=0;n<E;n++)k[n]=o[H+n];n.push(k)}return n}return[Array.from(o)]}if(o.length&&o[0]instanceof Float32Array){const H=[];for(const n of o)H.push(Array.from(n));return H}return[]}static OmitZeroLengthPredicate(o,H,n){const E=[];return H.zH(o).lengthSquared()>0&&E.push([o,H]),n.zH(H).lengthSquared()>0&&E.push([H,n]),o.zH(n).lengthSquared()>0&&E.push([n,o]),0===E.length?null:E}static OmitDuplicatesPredicate(o,H,n,E){const k=[];return Ko._SearchInPoints(o,H,E)||k.push([o,H]),Ko._SearchInPoints(H,n,E)||k.push([H,n]),Ko._SearchInPoints(n,o,E)||k.push([n,o]),0===k.length?null:k}static _SearchInPoints(o,H,n){for(const O of n)for(let n=0;n<O.length;n++){var E,k,g;if(null!==(E=O[n])&&void 0!==E&&E.equals(o))if(null!==(k=O[n+1])&&void 0!==k&&k.equals(H)||null!==(g=O[n-1])&&void 0!==g&&g.equals(H))return!0}return!1}static MeshesToLines(o,H){const n=[];for(let k=0;k<o.length;k++){const g=o[k],O=g.getVerticesData(G.d.PositionKind),Y=g.dg();if(O&&Y)for(let o=0,y=0;o<Y.length;o++){const S=3*Y[y++],G=3*Y[y++],c=3*Y[y++],A=new E.xH(O[S],O[S+1],O[S+2]),l=new E.xH(O[G],O[G+1],O[G+2]),x=new E.xH(O[c],O[c+1],O[c+2]);if(H){const E=H(A,l,x,n,o,S,g,k,O,Y);if(E)for(const o of E)n.push(o)}else n.push([A,l],[l,x],[x,A])}}return n}static ToVector3Array(o){if(Array.isArray(o[0])){const H=[],n=o;for(const o of n){const n=[];for(let H=0;H<o.length;H+=3)n.push(new E.xH(o[H],o[H+1],o[H+2]));H.push(n)}return H}const H=o,n=[];for(let k=0;k<H.length;k+=3)n.push(new E.xH(H[k],H[k+1],H[k+2]));return n}static ToNumberArray(o){return o.flatMap((o=>[o.x,o.y,o.z]))}static GetPointsCountInfo(o){const H=new Array(o.length);let n=0;for(let E=o.length;E--;)H[E]=o[E].length/3,n+=H[E];return{total:n,counts:H}}static GetLineLength(o){if(0===o.length)return 0;let H;H="number"===typeof o[0]?Ko.ToVector3Array(o):o;const n=E.TmpVectors.xH[0];let k=0;for(let E=0;E<H.length-1;E++){const o=H[E];k+=H[E+1].subtractToRef(o,n).length()}return k}static GetLineLengthArray(o){const H=new Float32Array(o.length/3);let n=0;for(let E=0,k=o.length/3-1;E<k;E++){let k=o[3*E+0],g=o[3*E+1],O=o[3*E+2];k-=o[3*E+3],g-=o[3*E+4],O-=o[3*E+5];n+=Math.sqrt(k*k+g*g+O*O),H[E+1]=n}return H}static SegmentizeSegmentByCount(o,H,n){const k=[],g=H.zH(o),O=E.TmpVectors.xH[0];O.AY(n);const Y=E.TmpVectors.xH[1];g.divideToRef(O,Y);let y=o.clone();k.push(y);for(let E=0;E<n;E++)y=y.clone(),k.push(y.addInPlace(Y));return k}static SegmentizeLineBySegmentLength(o,H){const n=o[0]instanceof E.xH?Ko.GetLineSegments(o):"number"===typeof o[0]?Ko.GetLineSegments(Ko.ToVector3Array(o)):o,k=[];for(const E of n)if(E.length>H){const o=Ko.SegmentizeSegmentByCount(E.point1,E.point2,Math.ceil(E.length/H));for(const H of o)k.push(H)}else k.push(E.point1),k.push(E.point2);return k}static SegmentizeLineBySegmentCount(o,H){const n="number"===typeof o[0]?Ko.ToVector3Array(o):o,E=Ko.GetLineLength(n)/H;return Ko.SegmentizeLineBySegmentLength(n,E)}static GetLineSegments(o){const H=[];for(let n=0;n<o.length-1;n++){const E=o[n],k=o[n+1],g=k.zH(E).length();H.push({point1:E,point2:k,length:g})}return H}static GetMinMaxSegmentLength(o){const H=Ko.GetLineSegments(o).sort((o=>o.length));return{min:H[0].length,max:H[H.length-1].length}}static GetPositionOnLineByVisibility(o,H,n){let k=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const g=H*n;let O=0,Y=0;const y=o.length;for(let E=0;E<y;E++){if(g<=O+o[E].length){Y=E;break}O+=o[E].length}const S=(g-O)/o[Y].length;return o[Y].point2.subtractToRef(o[Y].point1,E.TmpVectors.xH[0]),E.TmpVectors.xH[1]=E.TmpVectors.xH[0].multiplyByFloats(S,S,S),k||E.TmpVectors.xH[1].addInPlace(o[Y].point1),E.TmpVectors.xH[1].clone()}static GetCircleLinePoints(o,H){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:o,g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/H;const O=[];for(let Y=0;Y<=H;Y++)O.push(new E.xH(Math.cos(Y*g)*o,Math.sin(Y*g)*k,n));return O}static GetBezierLinePoints(o,H,n,E){return Zo.g.CreateQuadraticBezier(o,H,n,E).getPoints().flatMap((o=>[o.x,o.y,o.z]))}static GetArrowCap(o,H,n,E,k){let g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,O=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[o.clone(),o.add(H.multiplyByFloats(n,n,n))],widths:[E,k,g,O]}}static GetPointsFromText(o,H,n,E){let k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,g=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const O=[],Y=(0,Mo.e)(o,H,n,E);for(const y of Y){for(const o of y.paths){const H=[],n=o.getPoints();for(const o of n)H.push(o.x,o.y,k);O.push(H)}if(g)for(const o of y.holes){const H=[],n=o.getPoints();for(const o of n)H.push(o.x,o.y,k);O.push(H)}}return O}static Color3toRGBAUint8(o){const H=new Uint8Array(4*o.length);for(let n=0,E=0;n<o.length;n++)H[E++]=255*o[n].r,H[E++]=255*o[n].g,H[E++]=255*o[n].b,H[E++]=255;return H}static CreateColorsTexture(o,H,n,E){const k=E.getEngine().getCaps().maxTextureSize??1,g=H.length>k?k:H.length,O=Math.ceil(H.length/k);O>1&&(H=[...H,...Array(g*O-H.length).fill(H[0])]);const Y=Ko.Color3toRGBAUint8(H),y=new j.b(Y,g,O,x.e.TEXTUREFORMAT_RGBA,E,!1,!0,n);return y.name=o,y}static PrepareEmptyColorsTexture(o){if(!eo.EmptyColorsTexture){const H=new Uint8Array(4);eo.EmptyColorsTexture=new j.b(H,1,1,x.e.TEXTUREFORMAT_RGBA,o,!1,!1,j.b.NEAREST_NEAREST),eo.EmptyColorsTexture.name="grlEmptyColorsTexture"}return eo.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var o;null===(o=eo.EmptyColorsTexture)||void 0===o||o.dispose(),eo.EmptyColorsTexture=null}static BooleanToNumber(o){return o?1:0}}class fo extends Po.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Bo extends mo.e{isCompatible(o){return!0}constructor(o,H,n){var k;n=n||{color:eo.DEFAULT_COLOR};const g=new fo;g.GREASED_LINE_HAS_COLOR=!!n.color&&!n.useColors,g.GREASED_LINE_SIZE_ATTENUATION=n.sizeAttenuation??!1,g.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===n.colorDistributionType,g.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(H??o.bo()).useRightHandedSystem,g.GREASED_LINE_CAMERA_FACING=n.cameraFacing??!0,super(o,Bo.GREASED_LINE_MATERIAL_NAME,200,g,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(k=n)||void 0===k?void 0:k.forceGLSL)||Bo.ForceGLSL,this._scene=H??o.bo(),this._engine=this._scene.getEngine(),this._cameraFacing=n.cameraFacing??!0,this.visibility=n.visibility??1,this.useDash=n.useDash??!1,this.dashRatio=n.dashRatio??.5,this.dashOffset=n.dashOffset??0,this.width=n.width?n.width:n.sizeAttenuation?eo.DEFAULT_WIDTH_ATTENUATED:eo.DEFAULT_WIDTH,this._sizeAttenuation=n.sizeAttenuation??!1,this.colorMode=n.colorMode??0,this._color=n.color??null,this.useColors=n.useColors??!1,this._colorsDistributionType=n.colorDistributionType??0,this.colorsSampling=n.colorsSampling??j.b.NEAREST_NEAREST,this._colors=n.Ko??null,this.dashCount=n.dashCount??1,this.resolution=n.resolution??new E.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),n.colorsTexture?this.colorsTexture=n.colorsTexture:this._colors?this.colorsTexture=Ko.CreateColorsTexture(`${o.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??eo.DEFAULT_COLOR,Ko.PrepareEmptyColorsTexture(this._scene)),this._engine.yg.add((()=>{Ko.DisposeEmptyColorsTexture()}))}getAttributes(o){o.push("grl_offsets"),o.push("grl_widths"),o.push("grl_colorPointers"),o.push("grl_counters"),this._cameraFacing?(o.push("grl_previousAndSide"),o.push("grl_nextAndCounters")):o.push("grl_slopes")}getSamplers(o){o.push("grl_colors")}getActiveTextures(o){this.colorsTexture&&o.push(this.colorsTexture)}getUniforms(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const H=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&H.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===o&&H.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:H,vertex:this._cameraFacing&&this._isGLSL(o)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(o)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(o){if(this._cameraFacing){o.sg("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||o.sg("viewProjection",this._scene.getTransformMatrix());const H=E.TmpVectors.Vector4[0];H.x=this._aspect,H.y=this._resolution.x,H.z=this._resolution.y,H.w=this.width,o.updateVector4("grl_aspect_resolution_lineWidth",H)}const H=E.TmpVectors.Vector4[0];H.x=Ko.BooleanToNumber(this.useDash),H.y=this._dashArray,H.z=this.dashOffset,H.w=this.dashRatio,o.updateVector4("grl_dashOptions",H);const n=E.TmpVectors.Vector4[1];n.x=this.colorMode,n.y=this.visibility,n.z=this.colorsTexture?this.colorsTexture.getSize().width:0,n.w=Ko.BooleanToNumber(this.useColors),o.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",n),this._color&&o.updateColor3("grl_singleColor",this._color);const k=this.colorsTexture??eo.EmptyColorsTexture;o.setTexture("grl_colors",k),o.updateFloat2("grl_textureSize",(null===k||void 0===k?void 0:k.getSize().width)??1,(null===k||void 0===k?void 0:k.getSize().height)??1)}prepareDefines(o,H,n){o.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,o.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,o.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,o.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=H.useRightHandedSystem,o.GREASED_LINE_CAMERA_FACING=this._cameraFacing,o.GREASED_LINE_USE_OFFSETS=!!n.offsets}getClassName(){return Bo.GREASED_LINE_MATERIAL_NAME}getCustomCode(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(H)?function(o,H){if("vertex"===o){const o={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return H&&(o["!gl_Position\\=viewProjection\\*worldPos;"]="//"),o}return"fragment"===o?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(o,this._cameraFacing):function(o,H){if("vertex"===o){const o={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return H&&(o["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),o}return"fragment"===o?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(o,this._cameraFacing)}dispose(){var o;null===(o=this.colorsTexture)||void 0===o||o.dispose(),super.dispose()}get Ko(){return this._colors}set Ko(o){this.setColors(o)}setColors(o){var H;let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],E=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const k=(null===(H=this._colors)||void 0===H?void 0:H.length)??0;var g;if(this._colors=o,null!==o&&0!==o.length){if(!n||E)if(this.colorsTexture&&k===o.length&&!E){const H=Ko.Color3toRGBAUint8(o);this.colorsTexture.update(H)}else{var O;null===(O=this.colorsTexture)||void 0===O||O.dispose(),this.colorsTexture=Ko.CreateColorsTexture(`${this._material.name}-colors-texture`,o,this.colorsSampling,this._scene)}}else null===(g=this.colorsTexture)||void 0===g||g.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(o){this._dashCount=o,this._dashArray=1/o}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(o){this._sizeAttenuation=o,this.markAllDefinesAsDirty()}get color(){return this._color}set color(o){this.setColor(o)}setColor(o){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==o||null!==this._color&&null===o?(this._color=o,H||this.markAllDefinesAsDirty()):this._color=o}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(o){this._colorsDistributionType=o,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(o){this._aspect=o.x/o.y,this._resolution=o}serialize(){const o=super.serialize(),H={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(H.Ko=this._colors),this._color&&(H.color=this._color),o.greasedLineMaterialOptions=H,o}parse(o,H,n){var E;super.parse(o,H,n);const k=o.greasedLineMaterialOptions;null===(E=this.colorsTexture)||void 0===E||E.dispose(),k.color&&this.setColor(k.color,!0),k.colorDistributionType&&(this.colorsDistributionType=k.colorDistributionType),k.Ko&&(this.Ko=k.Ko),k.colorsSampling&&(this.colorsSampling=k.colorsSampling),k.colorMode&&(this.colorMode=k.colorMode),k.useColors&&(this.useColors=k.useColors),k.visibility&&(this.visibility=k.visibility),k.useDash&&(this.useDash=k.useDash),k.dashCount&&(this.dashCount=k.dashCount),k.dashRatio&&(this.dashRatio=k.dashRatio),k.dashOffset&&(this.dashOffset=k.dashOffset),k.width&&(this.width=k.width),k.sizeAttenuation&&(this.sizeAttenuation=k.sizeAttenuation),k.resolution&&(this.resolution=k.resolution),this.Ko?this.colorsTexture=Ko.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Ko,this.colorsSampling,H):Ko.PrepareEmptyColorsTexture(H),this.markAllDefinesAsDirty()}copyTo(o){var H;const n=o;null===(H=n.colorsTexture)||void 0===H||H.dispose(),this._colors&&(n.colorsTexture=Ko.CreateColorsTexture(`${n._material.name}-colors-texture`,this._colors,n.colorsSampling,this._scene)),n.setColor(this.color,!0),n.colorsDistributionType=this.colorsDistributionType,n.colorsSampling=this.colorsSampling,n.colorMode=this.colorMode,n.useColors=this.useColors,n.visibility=this.visibility,n.useDash=this.useDash,n.dashCount=this.dashCount,n.dashRatio=this.dashRatio,n.dashOffset=this.dashOffset,n.width=this.width,n.sizeAttenuation=this.sizeAttenuation,n.resolution=this.resolution,n.markAllDefinesAsDirty()}_isGLSL(o){return 0===o||this._forceGLSL}}Bo.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Bo.ForceGLSL=!1,(0,bo.e)(`BABYLON.${Bo.GREASED_LINE_MATERIAL_NAME}`,Bo);var qo=n(11629),Do=n(11040),To=n(11431),ao=n(11128);class Fo extends To.ShaderMaterial{constructor(o,H,k){const g=H.getEngine(),O=g.isWebGPU&&!(k.forceGLSL||Fo.ForceGLSL),Y=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];H.useRightHandedSystem&&Y.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const y=["position","grl_widths","grl_offsets","grl_colorPointers"];k.cameraFacing?(Y.push("GREASED_LINE_CAMERA_FACING"),y.push("grl_previousAndSide","grl_nextAndCounters")):(y.push("grl_slopes"),y.push("grl_counters"));const S=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(O||S.push("world","viewProjection","view","projection"),super(o,H,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:O?["Scene","Mesh"]:void 0,attributes:y,uniforms:S,samplers:O?[]:["grlColors"],defines:Y,extraInitializationsAsync:async()=>{O?await Promise.all([n.e(66).then(n.bind(n,14383)),n.e(75).then(n.bind(n,14388))]):await Promise.all([n.e(69).then(n.bind(n,14391)),n.e(76).then(n.bind(n,14400))])},shaderLanguage:O?1:0}),this._color=V.NH.White(),this._colorsDistributionType=0,this._colorsTexture=null,k=k||{color:eo.DEFAULT_COLOR},this.visibility=k.visibility??1,this.useDash=k.useDash??!1,this.dashRatio=k.dashRatio??.5,this.dashOffset=k.dashOffset??0,this.dashCount=k.dashCount??1,this.width=k.width?k.width:k.sizeAttenuation&&k.cameraFacing?eo.DEFAULT_WIDTH_ATTENUATED:eo.DEFAULT_WIDTH,this.sizeAttenuation=k.sizeAttenuation??!1,this.color=k.color??V.NH.White(),this.useColors=k.useColors??!1,this.colorsDistributionType=k.colorDistributionType??0,this.colorsSampling=k.colorsSampling??j.b.NEAREST_NEAREST,this.colorMode=k.colorMode??0,this._colors=k.Ko??null,this._cameraFacing=k.cameraFacing??!0,this.resolution=k.resolution??new E.Vector2(g.getRenderWidth(),g.getRenderHeight()),k.colorsTexture?this.colorsTexture=k.colorsTexture:this._colors?this.colorsTexture=Ko.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,H):(this._color=this._color??eo.DEFAULT_COLOR,this.colorsTexture=Ko.PrepareEmptyColorsTexture(H)),O){const o=new ao.d;o.setParameters(),o.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",o)}g.yg.add((()=>{Ko.DisposeEmptyColorsTexture()}))}dispose(){var o;null===(o=this._colorsTexture)||void 0===o||o.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new E.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Ko(){return this._colors}set Ko(o){this.setColors(o)}setColors(o){var H;let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],E=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const k=(null===(H=this._colors)||void 0===H?void 0:H.length)??0;var g;if(this._colors=o,null!==o&&0!==o.length){if(!n||E)if(this._colorsTexture&&k===o.length&&!E){const H=Ko.Color3toRGBAUint8(o);this._colorsTexture.update(H)}else{var O;null===(O=this._colorsTexture)||void 0===O||O.dispose(),this.colorsTexture=Ko.CreateColorsTexture(`${this.name}-colors-texture`,o,this.colorsSampling,this.bo())}}else null===(g=this._colorsTexture)||void 0===g||g.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(o){this._colorsTexture=o,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(o){this._width=o,this.setFloat("grlWidth",o)}get useColors(){return this._useColors}set useColors(o){this._useColors=o,this.setFloat("grlUseColors",Ko.BooleanToNumber(o))}get colorsSampling(){return this._colorsSampling}set colorsSampling(o){this._colorsSampling=o}get visibility(){return this._visibility}set visibility(o){this._visibility=o,this.setFloat("grlVisibility",o)}get useDash(){return this._useDash}set useDash(o){this._useDash=o,this.setFloat("grlUseDash",Ko.BooleanToNumber(o))}get dashOffset(){return this._dashOffset}set dashOffset(o){this._dashOffset=o,this.setFloat("grlDashOffset",o)}get dashRatio(){return this._dashRatio}set dashRatio(o){this._dashRatio=o,this.setFloat("grlDashRatio",o)}get dashCount(){return this._dashCount}set dashCount(o){this._dashCount=o,this._dashArray=1/o,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(o){this._sizeAttenuation=o,this.setFloat("grlSizeAttenuation",Ko.BooleanToNumber(o))}get color(){return this._color}set color(o){this.setColor(o)}setColor(o){o=o??eo.DEFAULT_COLOR,this._color=o,this.setColor3("grlColor",o)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(o){this._colorsDistributionType=o,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(o){this._colorMode=o,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(o){this._resolution=o,this.setVector2("grlResolution",o),this.setFloat("grlAspect",o.x/o.y)}serialize(){const o=super.serialize(),H={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(H.Ko=this._colors),o.greasedLineMaterialOptions=H,o}parse(o,H,n){var E;const k=o.greasedLineMaterialOptions;null===(E=this._colorsTexture)||void 0===E||E.dispose(),k.color&&(this.color=k.color),k.colorDistributionType&&(this.colorsDistributionType=k.colorDistributionType),k.colorsSampling&&(this.colorsSampling=k.colorsSampling),k.colorMode&&(this.colorMode=k.colorMode),k.useColors&&(this.useColors=k.useColors),k.visibility&&(this.visibility=k.visibility),k.useDash&&(this.useDash=k.useDash),k.dashCount&&(this.dashCount=k.dashCount),k.dashRatio&&(this.dashRatio=k.dashRatio),k.dashOffset&&(this.dashOffset=k.dashOffset),k.width&&(this.width=k.width),k.sizeAttenuation&&(this.sizeAttenuation=k.sizeAttenuation),k.resolution&&(this.resolution=k.resolution),k.Ko?this.colorsTexture=Ko.CreateColorsTexture(`${this.name}-colors-texture`,k.Ko,this.colorsSampling,this.bo()):this.colorsTexture=Ko.PrepareEmptyColorsTexture(H),this._cameraFacing=k.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Co,to,Xo;Fo.ForceGLSL=!1,function(o){o[o.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",o[o.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Co||(Co={})),function(o){o[o.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",o[o.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",o[o.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(to||(to={})),function(o){o[o.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",o[o.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",o[o.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",o[o.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",o[o.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Xo||(Xo={}));class so extends No.b{constructor(o,H,n){super(o,H,null,null,!1,!1),this.name=o,this._options=n,this._lazy=!1,this._updatable=!1,this._engine=H.getEngine(),this._lazy=n.lazy??!1,this._updatable=n.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=n.colorPointers??[],this._widths=n.widths??new Array(n.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(o){let H=0;for(const E of this._points)H+=E.length;const n=H/3*2-this._widths.length;for(let E=0;E<n;E++)this._widths.push(o)}updateLazy(){var o,H;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(o=this._options.ribbonOptions)||void 0===o?void 0:o.smoothShading),!this.Do&&this.refreshBoundingInfo(),null===(H=this.greasedLineMaterial)||void 0===H||H.updateLazy()}addPoints(o,H){for(const n of o)this._points.push(n);this._lazy||this.setPoints(this._points,H)}dispose(o){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(o,H)}isLazy(){return this._lazy}get fo(){return this._uvs}set fo(o){this._uvs=o instanceof Float32Array?o:new Float32Array(o),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(o){this.material instanceof Fo&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===o||void 0===o?void 0:o.length)>0),this._offsets=o,this._offsetsBuffer?this._offsetsBuffer.update(o):this._createOffsetsBuffer(o)}get widths(){return this._widths}set widths(o){this._widths=o,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(o)}get colorPointers(){return this._colorPointers}set colorPointers(o){this._colorPointers=o,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(o)}get greasedLineMaterial(){var o,H;if(this.material&&this.material instanceof Fo)return this.material;const n=null===(o=this.material)||void 0===o||null===(H=o.pluginManager)||void 0===H?void 0:H.getPlugin(Bo.GREASED_LINE_MATERIAL_NAME);return n||void 0}get points(){const o=[];return Do.b.DeepCopy(this._points,o),o}setPoints(o,H){this._points=Ko.ConvertPoints(o,(null===H||void 0===H?void 0:H.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==H&&void 0!==H&&H.colorPointers||this._updateColorPointers(),this._setPoints(this._points,H)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,fo:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(o){super.serialize(o),o.type=this.getClassName(),o.lineOptions=this._createLineOptions()}_createVertexBuffers(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=new qo.c;return H.Zo=this._vertexPositions,H.indices=this._indices,H.fo=this._uvs,o&&(H.Mo=[],qo.c.ComputeNormals(this._vertexPositions,this._indices,H.Mo)),H.qo(this,this._options.updatable),H}_createOffsetsBuffer(o){const H=this._scene.getEngine(),n=new G.c(H,o,this._updatable,3);this.setVerticesBuffer(n.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=n}}class Uo{constructor(o,H){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=o,this.wasAddedByNoopNode=H}getIndicesAccessor(o,H,n,E,k){var g,O,Y,y;return null===(g=this._indicesAccessorMap.get(o))||void 0===g||null===(O=g.get(H))||void 0===O||null===(Y=O.get(n))||void 0===Y||null===(y=Y.get(E))||void 0===y?void 0:y.get(k)}setIndicesAccessor(o,H,n,E,k,g){let O=this._indicesAccessorMap.get(o);O||(O=new Map,this._indicesAccessorMap.set(o,O));let Y=O.get(H);Y||(Y=new Map,O.set(H,Y));let y=Y.get(n);y||(y=new Map,Y.set(n,y));let S=y.get(E);S||(S=new Map,y.set(E,S)),S.set(k,g)}pushExportedNode(o){this._exportedNodes.has(o)||this._exportedNodes.add(o)}getNodesSet(){return this._exportedNodes}getVertexBufferView(o){return this._vertexBufferViewMap.get(o)}setVertexBufferView(o,H){this._vertexBufferViewMap.set(o,H)}setRemappedBufferView(o,H,n){this._remappedBufferView.set(o,new Map),this._remappedBufferView.get(o).set(H,n)}getRemappedBufferView(o,H){var n;return null===(n=this._remappedBufferView.get(o))||void 0===n?void 0:n.get(H)}getVertexAccessor(o,H,n){var E,k;return null===(E=this._vertexAccessorMap.get(o))||void 0===E||null===(k=E.get(H))||void 0===k?void 0:k.get(n)}setVertexAccessor(o,H,n,E){let k=this._vertexAccessorMap.get(o);k||(k=new Map,this._vertexAccessorMap.set(o,k));let g=k.get(H);g||(g=new Map,k.set(H,g)),g.set(n,E)}hasVertexColorAlpha(o){return this._vertexMapColorAlpha.get(o)||!1}setHasVertexColorAlpha(o,H){return this._vertexMapColorAlpha.set(o,H)}getMesh(o){return this._meshMap.get(o)}setMesh(o,H){this._meshMap.set(o,H)}bindMorphDataToMesh(o,H){const n=this._meshMorphTargetMap.get(o)||[];this._meshMorphTargetMap.set(o,n),-1===n.indexOf(H)&&n.push(H)}getMorphTargetsFromMesh(o){return this._meshMorphTargetMap.get(o)}}class Io{_ApplyExtension(o,H,n,E){if(n>=H.length)return Promise.resolve(o);const k=E(H[n],o);return k?k.then((async o=>o?await this._ApplyExtension(o,H,n+1,E):null)):this._ApplyExtension(o,H,n+1,E)}_ApplyExtensions(o,H){const n=[];for(const E of Io._ExtensionNames)n.push(this._extensions[E]);return this._ApplyExtension(o,n,0,H)}_extensionsPreExportTextureAsync(o,H,n){return this._ApplyExtensions(H,((H,E)=>H.preExportTextureAsync&&H.preExportTextureAsync(o,E,n)))}_extensionsPostExportNodeAsync(o,H,n,E,k){return this._ApplyExtensions(H,((H,g)=>H.postExportNodeAsync&&H.postExportNodeAsync(o,g,n,E,k,this._bufferManager)))}_extensionsPostExportMaterialAsync(o,H,n){return this._ApplyExtensions(H,((H,E)=>H.postExportMaterialAsync&&H.postExportMaterialAsync(o,E,n)))}_extensionsPostExportMaterialAdditionalTextures(o,H,n){const E=[];for(const k of Io._ExtensionNames){const g=this._extensions[k];g.postExportMaterialAdditionalTextures&&E.push(...g.postExportMaterialAdditionalTextures(o,H,n))}return E}_extensionsPostExportTextures(o,H,n){for(const E of Io._ExtensionNames){const k=this._extensions[E];k.postExportTexture&&k.postExportTexture(o,H,n)}}_extensionsPostExportMeshPrimitive(o){for(const H of Io._ExtensionNames){const n=this._extensions[H];n.postExportMeshPrimitive&&n.postExportMeshPrimitive(o,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const o of Io._ExtensionNames){const H=this._extensions[o];H.preGenerateBinaryAsync&&await H.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(o){for(const H of Io._ExtensionNames){const n=this._extensions[H];n.enabled&&o(n)}}_extensionsOnExporting(){this._forEachExtensions((o=>{var H,n,E;o.wasUsed&&((H=this._glTF).extensionsUsed||(H.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(o.name)&&this._glTF.extensionsUsed.push(o.name),o.required&&((n=this._glTF).extensionsRequired||(n.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(o.name)&&this._glTF.extensionsRequired.push(o.name)),(E=this._glTF).extensions||(E.extensions={}),o.onExporting&&o.onExporting())}))}_loadExtensions(){for(const o of Io._ExtensionNames){const H=Io._ExtensionFactories[o](this);this._extensions[o]=H}}constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:z.e.LastCreatedScene,H=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${x.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new a(this),this._extensions={},this._bufferManager=new Go,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!o)throw new Error("No scene available to export");this._babylonScene=o,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:o=>{var H;return null===o||void 0===o||null===(H=o.Ag)||void 0===H?void 0:H.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...H},this._loadExtensions()}dispose(){for(const o in this._extensions){this._extensions[o].dispose()}}get options(){return this._options}static RegisterExtension(o,H){Io.UnregisterExtension(o)&&k.Tools.Warn(`Extension with the name ${o} already exists`),Io._ExtensionFactories[o]=H,Io._ExtensionNames.push(o)}static UnregisterExtension(o){if(!Io._ExtensionFactories[o])return!1;delete Io._ExtensionFactories[o];const H=Io._ExtensionNames.indexOf(o);return-1!==H&&Io._ExtensionNames.splice(H,1),!0}_generateJSON(o,H,n){const E={byteLength:o};return E.byteLength&&(this._glTF.buffers=[E]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.VH=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(E.uri=H+".bin"),n?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(o){const H=await this._generateBinaryAsync();this._extensionsOnExporting();const n=this._generateJSON(H.byteLength,o,!0),E=new Blob([H],{type:"application/octet-stream"}),k=o+".gltf",g=o+".bin",O=new S;if(O.files[k]=n,O.files[g]=E,this._imageData)for(const Y in this._imageData)O.files[Y]=new Blob([this._imageData[Y].data],{type:this._imageData[Y].mimeType});return O}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(o){const H=o%4;return 0===H?H:4-H}async generateGLBAsync(o){this._shouldUseGlb=!0;const H=await this._generateBinaryAsync();this._extensionsOnExporting();const n=this._generateJSON(H.byteLength),E=o+".glb";let k,g=n.length;if("undefined"!==typeof TextEncoder){k=(new TextEncoder).encode(n),g=k.length}const O=this._getPadding(g),Y=this._getPadding(H.byteLength),y=28+g+O+H.byteLength+Y,G=new yo(y);if(G.writeUInt32(1179937895),G.writeUInt32(2),G.writeUInt32(y),G.writeUInt32(g+O),G.writeUInt32(1313821514),k)G.writeTypedArray(k);else{const o="_".charCodeAt(0);for(let H=0;H<g;++H){const E=n.charCodeAt(H);E!=n.codePointAt(H)?G.writeUInt8(o):G.writeUInt8(E)}}for(let S=0;S<O;++S)G.writeUInt8(32);G.writeUInt32(H.byteLength+Y),G.writeUInt32(5130562),G.writeTypedArray(H);for(let S=0;S<Y;++S)G.writeUInt8(0);const c=new S;return c.files[E]=new Blob([G.getOutputData()],{type:"application/octet-stream"}),c}_setNodeTransformation(o,H,n){if(H.getPivotPoint().equalsWithEpsilon(s,X.e)||k.Tools.Warn("Pivot points are not supported in the glTF serializer"),!H.position.equalsWithEpsilon(s,X.e)){const k=E.TmpVectors.xH[0].S(H.position);n&&W(k),o.translation=k.bg()}H.cY.equalsWithEpsilon(I,X.e)||(o.scale=H.cY.bg());const g=H.rotationQuaternion||E.Quaternion.FromEulerAngles(H.rotation.x,H.rotation.y,H.rotation.z);g.equalsWithEpsilon(U,X.e)||(n&&i(g),o.rotation=g.normalize().bg())}_setCameraTransformation(o,H,n){if(!H.position.equalsWithEpsilon(s,X.e)){const k=E.TmpVectors.xH[0].S(H.position);n&&W(k),o.translation=k.bg()}const k=H.rotationQuaternion||E.Quaternion.FromEulerAngles(H.rotation.x,H.rotation.y,H.rotation.z);n&&i(k),this._babylonScene.useRightHandedSystem||L(k),k.equalsWithEpsilon(U,X.e)||(o.rotation=k.bg())}_listAvailableCameras(){for(const o of this._babylonScene.cameras){const H={type:o.mode===Ao.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(o.name&&(H.name=o.name),"perspective"===H.type)H.perspective={aspectRatio:o.getEngine().getAspectRatio(o),yfov:o.fovMode===Ao.b.FOVMODE_VERTICAL_FIXED?o.fov:o.fov*o.getEngine().getAspectRatio(o),znear:o.Cg,zfar:o.maxZ};else if("orthographic"===H.type){const n=o.orthoLeft&&o.orthoRight?.5*(o.orthoRight-o.orthoLeft):.5*o.getEngine().getRenderWidth(),E=o.orthoBottom&&o.orthoTop?.5*(o.orthoTop-o.orthoBottom):.5*o.getEngine().getRenderHeight();H.orthographic={xmag:n,ymag:E,znear:o.Cg,zfar:o.maxZ}}this._camerasMap.set(o,H)}}_exportAndAssignCameras(){const o=Array.from(this._camerasMap.values());for(const H of o){const o=this._nodesCameraMap.get(H);if(void 0!==o){this._cameras.push(H);for(const H of o)H.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const o of this._babylonScene.skeletons){if(o.bones.length<=0)continue;const H={joints:[]};this._skinMap.set(o,H)}}_exportAndAssignSkeletons(){for(const o of this._babylonScene.skeletons){if(o.bones.length<=0)continue;const H=this._skinMap.get(o);if(void 0==H)continue;const n={},E=[];let g=-1;for(let k=0;k<o.bones.length;++k){const H=o.bones[k],E=H.getIndex()??k;-1!==E&&(n[E]=H,E>g&&(g=E))}for(let o=0;o<=g;++o){const g=n[o];E.push(g.getAbsoluteInverseBindMatrix());const O=g.getTransformNode();if(null!==O){const o=this._nodeMap.get(O);O&&null!==o&&void 0!==o?H.joints.push(o):k.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else k.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const O=this._nodesSkinMap.get(H);if(H.joints.length>0&&void 0!==O){const o=64*E.length,n=new Float32Array(o/4);E.forEach(((o,H)=>{n.set(o.m,16*H)}));const k=this._bufferManager.createBufferView(n);this._accessors.push(this._bufferManager.createAccessor(k,"MAT4",5126,E.length)),H.inverseBindMatrices=this._accessors.length-1,this._skins.push(H);for(const H of O)H.skin=this._skins.length-1}}}async _exportSceneAsync(){const o={nodes:[]};if(this._babylonScene.metadata){const H=this._options.metadataSelector(this._babylonScene.metadata);H&&(o.extras=H)}const H=new Array,n=new Array,E=new Array;for(const Y of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Oo(Y,this._babylonScene.useRightHandedSystem)?E.push(...Y.getChildren()):this._babylonScene.useRightHandedSystem?H.push(Y):n.push(Y);this._listAvailableCameras(),this._listAvailableSkeletons();const k=new Uo(!0,!1);o.nodes.push(...await this._exportNodesAsync(n,k));const g=new Uo(!1,!1);o.nodes.push(...await this._exportNodesAsync(H,g));const O=new Uo(!1,!0);o.nodes.push(...await this._exportNodesAsync(E,O)),o.nodes.length&&this._scenes.push(o),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Qo._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,k.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(o){let H=this._shouldExportNodeMap.get(o);return void 0===H&&(H=this._options.shouldExportNode(o),this._shouldExportNodeMap.set(o,H)),H}async _exportNodesAsync(o,H){const n=new Array;this._exportBuffers(o,H);for(const E of o)await this._exportNodeAsync(E,n,H);return n}_collectBuffers(o,H,n,E,k){if(this._shouldExportNode(o)&&o instanceof A.e&&o.wg){const g=o.wg.getVertexBuffers();if(g)for(const E in g){if(!u(E))continue;const O=g[E];k.setHasVertexColorAlpha(O,o.hasVertexAlpha);const Y=O._buffer,y=H.get(Y)||[];H.set(Y,y),-1===y.indexOf(O)&&y.push(O);const S=n.get(O)||[];n.set(O,S),-1===S.indexOf(o)&&S.push(o)}const O=o.morphTargetManager;if(O)for(let H=0;H<O.numTargets;H++){const n=O.getTarget(H),k=E.get(n)||[];E.set(n,k),-1===k.indexOf(o)&&k.push(o)}}for(const g of o.getChildren())this._collectBuffers(g,H,n,E,k)}_exportBuffers(o,H){const n=new Map,E=new Map,k=new Map;for(const Y of o)this._collectBuffers(Y,n,E,k,H);const g=Array.from(n.keys());for(const Y of g){const o=Y.getData();if(!o)throw new Error("Buffer data is not available");const k=n.get(Y);if(!k)continue;const g=k[0].byteStride;if(k.some((o=>o.byteStride!==g)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const O=no(o).slice();for(const H of k){const o=E.get(H),{byteOffset:n,byteStride:k,componentCount:g,type:Y,count:y,normalized:S,kind:c}=w(H,o);switch(c){case G.d.NormalKind:case G.d.TangentKind:(0,F.e)(O,n,k,g,Y,y,S,(o=>{const H=Math.sqrt(o[0]*o[0]+o[1]*o[1]+o[2]*o[2]);if(H>0){const n=1/H;o[0]*=n,o[1]*=n,o[2]*=n}}));break;case G.d.ColorKind:{const H=o.filter((o=>o.material instanceof zo.JH||null==o.material)).length;if(0==H)break;if(H!=o.length){C.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}Y==G.d.UNSIGNED_BYTE&&C.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const E=new V.NH,c=new V.d,A=this._babylonScene.getEngine().useExactSrgbConversions;(0,F.e)(O,n,k,g,Y,y,S,(o=>{3===o.length?(E.An(o,0),E.toLinearSpaceToRef(E,A),E.toArray(o,0)):(c.An(o,0),c.toLinearSpaceToRef(c,A),c.toArray(o,0))}))}}}if(H.convertToRightHanded){for(const o of k){const H=E.get(o),{byteOffset:n,byteStride:k,componentCount:g,type:Y,count:y,normalized:S,kind:c}=w(o,H);switch(c){case G.d.PositionKind:case G.d.NormalKind:case G.d.TangentKind:(0,F.e)(O,n,k,g,Y,y,S,(o=>{o[0]=-o[0]}))}}H.convertedToRightHandedBuffers.set(Y,O)}const y=this._bufferManager.createBufferView(O,g);H.setVertexBufferView(Y,y);const S=new Map;for(const H of k){const o=E.get(H),{kind:n,totalVertices:k}=w(H,o);switch(n){case G.d.MatricesIndicesKind:case G.d.MatricesIndicesExtraKind:if(H.type==G.d.FLOAT){const o=H.getFloatData(k);null!==o&&S.set(H,o)}}}0!==S.size&&C.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const c=Array.from(S.keys());for(const n of c){const o=S.get(n);if(!o)continue;const E=o.some((o=>o>=256)),k=new(E?Uint16Array:Uint8Array)(o.length);for(let H=0;H<o.length;H++)k[H]=o[H];const g=this._bufferManager.createBufferView(k,4*(E?2:1));H.setRemappedBufferView(Y,n,g)}}const O=Array.from(k.keys());for(const Y of O){const o=k.get(Y);if(!o)continue;const n=po(Y,o[0],this._bufferManager,this._bufferViews,this._accessors,H.convertToRightHanded);for(const E of o)H.bindMorphDataToMesh(E,n)}}async _exportNodeAsync(o,H,n){let E=this._nodeMap.get(o);if(void 0!==E)return void(H.includes(E)||H.push(E));const k=await this._createNodeAsync(o,n);if(k){E=this._nodes.length,this._nodes.push(k),this._nodeMap.set(o,E),n.pushExportedNode(o),H.push(E);const g={name:"runtime animations",channels:[],samplers:[]},O=[];this._babylonScene.animationGroups.length||(Qo._CreateMorphTargetAnimationFromMorphTargetAnimations(o,g,O,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,n.convertToRightHanded,this._options.shouldExportAnimation),o.animations.length&&Qo._CreateNodeAnimationFromNodeAnimations(o,g,O,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,n.convertToRightHanded,this._options.shouldExportAnimation)),g.channels.length&&g.samplers.length&&this._animations.push(g),O.forEach((o=>{o.channels.length&&o.samplers.length&&this._animations.push(o)}))}const g=k?[]:H;for(const O of o.getChildren())await this._exportNodeAsync(O,g,n);k&&g.length&&(k.children=g)}async _createNodeAsync(o,H){if(!this._shouldExportNode(o))return null;const n={};if(o.name&&(n.name=o.name),o.metadata){const H=this._options.metadataSelector(o.metadata);H&&(n.extras=H)}if(o instanceof c.b&&(this._setNodeTransformation(n,o,H.convertToRightHanded),o instanceof A.e)){const k=o instanceof l.e?o.sourceMesh:o;if(k.jg&&k.jg.length>0&&(n.mesh=await this._exportMeshAsync(k,H)),o.skeleton){const H=this._skinMap.get(o.skeleton);var E;if(void 0!==H)void 0===this._nodesSkinMap.get(H)&&this._nodesSkinMap.set(H,[]),null===(E=this._nodesSkinMap.get(H))||void 0===E||E.push(n)}}if(o instanceof t.b){const E=this._camerasMap.get(o);if(E){var k;void 0===this._nodesCameraMap.get(E)&&this._nodesCameraMap.set(E,[]),this._setCameraTransformation(n,o,H.convertToRightHanded);const O=o.parent;if(null!==O&&Ho(o,O)){const o=this._nodeMap.get(O);if(void 0!==o){var g;const H=this._nodes[o];return oo(n,H),null===(g=this._nodesCameraMap.get(E))||void 0===g||g.push(H),null}}null===(k=this._nodesCameraMap.get(E))||void 0===k||k.push(n)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",n,o,this._nodeMap,H.convertToRightHanded)?n:(C.d.Warn(`Not exporting node ${o.name}`),null)}_exportIndices(o,H,n,E,k,O,Y,y,S){let G=o;S.mode=d(O);const c=Y!==g.e.CounterClockWiseSideOrientation,A=!y.wasAddedByNoopNode&&c,l=function(o){switch(o){case g.e.TriangleFillMode:case g.e.TriangleStripDrawMode:case g.e.TriangleFanDrawMode:return!0}return!1}(O)&&A;if(l){if(O===g.e.TriangleStripDrawMode||O===g.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");S.mode=d(O);const Y=H?new Uint32Array(E):new Uint16Array(E);if(o)for(let H=0;H+2<E;H+=3)Y[H]=o[n+H]+k,Y[H+1]=o[n+H+2]+k,Y[H+2]=o[n+H+1]+k;else for(let o=0;o+2<E;o+=3)Y[o]=o,Y[o+1]=o+2,Y[o+2]=o+1;G=Y}else if(o&&0!==k){const g=H?new Uint32Array(E):new Uint16Array(E);for(let H=0;H<E;H++)g[H]=o[n+H]+k;G=g}if(G){let g=y.getIndicesAccessor(o,n,E,k,l);if(void 0===g){const O=function(o,H,n,E){if(o instanceof Uint16Array||o instanceof Uint32Array)return o;if(o instanceof Int32Array)return new Uint32Array(o.buffer,o.byteOffset,o.length);const k=o.slice(H,H+n);return E?new Uint32Array(k):new Uint16Array(k)}(G,0,E,H),Y=this._bufferManager.createBufferView(O),S=H?5125:5123;this._accessors.push(this._bufferManager.createAccessor(Y,"SCALAR",S,E,0)),g=this._accessors.length-1,y.setIndicesAccessor(o,n,E,k,l,g)}S.indices=g}}_exportVertexBuffer(o,H,n,E,k,g){const O=o.getKind();if(!u(O))return;if(O.startsWith("uv")&&!this._options.exportUnusedUVs&&(!H||!this._materialNeedsUVsSet.has(H)))return;let Y=k.getVertexAccessor(o,n,E);if(void 0===Y){const H=k.convertedToRightHandedBuffers.get(o._buffer)||o._buffer.getData(),g=O===G.d.PositionKind?function(o,H,n,E){const{byteOffset:k,byteStride:g,type:O,normalized:Y}=H,y=H.getSize(),S=new Array(y).fill(1/0),G=new Array(y).fill(-1/0);return(0,F.e)(o,k+n*g,g,y,O,E*y,Y,(o=>{for(let H=0;H<y;H++)S[H]=Math.min(S[H],o[H]),G[H]=Math.max(G[H],o[H])})),{min:S,max:G}}(H,o,n,E):void 0,y=(O===G.d.MatricesIndicesKind||O===G.d.MatricesIndicesExtraKind)&&o.type===G.d.FLOAT,S=y?G.d.UNSIGNED_BYTE:o.type,c=y?void 0:o.normalized,A=y?k.getRemappedBufferView(o._buffer,o):k.getVertexBufferView(o._buffer),l=o.byteOffset+n*o.byteStride;this._accessors.push(this._bufferManager.createAccessor(A,function(o,H){if(o==G.d.ColorKind)return H?"VEC4":"VEC3";switch(o){case G.d.PositionKind:case G.d.NormalKind:return"VEC3";case G.d.TangentKind:case G.d.MatricesIndicesKind:case G.d.MatricesIndicesExtraKind:case G.d.MatricesWeightsKind:case G.d.MatricesWeightsExtraKind:return"VEC4";case G.d.UVKind:case G.d.UV2Kind:case G.d.UV3Kind:case G.d.UV4Kind:case G.d.UV5Kind:case G.d.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${o}`)}(O,k.hasVertexColorAlpha(o)),S,E,l,g,c)),Y=this._accessors.length-1,k.setVertexAccessor(o,n,E,Y)}g.attributes[function(o){switch(o){case G.d.PositionKind:return"POSITION";case G.d.NormalKind:return"NORMAL";case G.d.TangentKind:return"TANGENT";case G.d.ColorKind:return"COLOR_0";case G.d.UVKind:return"TEXCOORD_0";case G.d.UV2Kind:return"TEXCOORD_1";case G.d.UV3Kind:return"TEXCOORD_2";case G.d.UV4Kind:return"TEXCOORD_3";case G.d.UV5Kind:return"TEXCOORD_4";case G.d.UV6Kind:return"TEXCOORD_5";case G.d.MatricesIndicesKind:return"JOINTS_0";case G.d.MatricesIndicesExtraKind:return"JOINTS_1";case G.d.MatricesWeightsKind:return"WEIGHTS_0";case G.d.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${o}`)}(O)]=Y}async _exportMaterialAsync(o,H,n,E){let k=this._materialMap.get(o);if(void 0===k){const E=H&&Object.keys(H).some((o=>o.startsWith("uv")));if((o=o instanceof lo.b?o.lY[n.materialIndex]:o)instanceof xo.c)k=await this._materialExporter.exportPBRMaterialAsync(o,"image/png",E);else{if(!(o instanceof zo.JH))return void C.d.Warn(`Unsupported material '${o.name}' with type ${o.getClassName()}`);k=await this._materialExporter.exportStandardMaterialAsync(o,"image/png",E)}this._materialMap.set(o,k)}E.material=k}async _exportMeshAsync(o,H){var n;let E=H.getMesh(o);if(void 0!==E)return E;const k={primitives:[]};E=this._meshes.length,this._meshes.push(k),H.setMesh(o,E);const O=o.isUnIndexed?null:o.dg(),Y=null===(n=o.wg)||void 0===n?void 0:n.getVertexBuffers(),y=H.getMorphTargetsFromMesh(o),S=o instanceof jo.d,G=o instanceof so,c=o.jg;if(Y&&c&&c.length>0)for(const x of c){const n={attributes:{}},E=x.Co()||this._babylonScene.defaultMaterial;if(G){var A,l;const H={name:E.name},k=o,g=V.NH.White(),O=(null===(A=k.material)||void 0===A?void 0:A.alpha)??1,Y=(null===(l=k.greasedLineMaterial)||void 0===l?void 0:l.color)??g;(!Y.equalsWithEpsilon(g,X.e)||O<1)&&(H.pbrMetallicRoughness={baseColorFactor:[...Y.bg(),O]}),this._materials.push(H),n.material=this._materials.length-1}else if(S){const H={name:E.name},k=o;(!k.color.equalsWithEpsilon(V.NH.White(),X.e)||k.alpha<1)&&(H.pbrMetallicRoughness={baseColorFactor:[...k.color.bg(),k.alpha]}),this._materials.push(H),n.material=this._materials.length-1}else await this._exportMaterialAsync(E,Y,x,n);const c=S||G?g.e.LineListDrawMode:o.overrideRenderingFillMode??E.fillMode,z=E._getEffectiveOrientation(o);this._exportIndices(O,O?(0,F.c)(O,x.indexCount,x.indexStart,x.verticesStart):x.verticesCount>65535,O?x.indexStart:x.verticesStart,O?x.indexCount:x.verticesCount,-x.verticesStart,c,z,H,n);for(const o of Object.values(Y))this._exportVertexBuffer(o,E,x.verticesStart,x.verticesCount,H,n);if(y){n.targets=[];for(const o of y)n.targets.push(o.attributes)}k.primitives.push(n),this._extensionsPostExportMeshPrimitive(n)}if(y){k.weights=[],k.extras||(k.extras={}),k.extras.targetNames=[];for(const o of y)k.weights.push(o.influence),k.extras.targetNames.push(o.name)}return E}}Io._ExtensionNames=new Array,Io._ExtensionFactories={};class vo{static async GLTFAsync(o,H,n){n&&n.exportWithoutWaitingForScene||await o.whenReadyAsync();const E=new Io(o,n),k=await E.generateGLTFAsync(H.replace(/\.[^/.]+$/,""));return E.dispose(),k}static async GLBAsync(o,H,n){n&&n.exportWithoutWaitingForScene||await o.whenReadyAsync();const E=new Io(o,n),k=await E.generateGLBAsync(H.replace(/\.[^/.]+$/,""));return E.dispose(),k}}n(11757);const wo="EXT_mesh_gpu_instancing";class ro{constructor(o){this.name=wo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(o,H,n,k,g,O){return await new Promise((o=>{if(H&&n instanceof No.b&&n.hasThinInstances&&this._exporter){this._wasUsed=!0;const o=E.xH.Zero(),k=E.Quaternion.Identity(),Y=E.xH.One(),y=n.thinInstanceGetWorldMatrices(),S=E.TmpVectors.xH[2],G=E.TmpVectors.Quaternion[1],c=E.TmpVectors.xH[3];let A=!1,l=!1,x=!1;const z=new Float32Array(3*n.xY),V=new Float32Array(4*n.xY),J=new Float32Array(3*n.xY);let N=0;for(const H of y)H.decompose(c,G,S),g&&(W(S),i(G)),z.set(S.bg(),3*N),V.set(G.normalize().bg(),4*N),J.set(c.bg(),3*N),A=A||!S.equalsWithEpsilon(o),l=l||!G.equalsWithEpsilon(k),x=x||!c.equalsWithEpsilon(Y),N++;const h={attributes:{}};A&&(h.attributes.TRANSLATION=this._buildAccessor(z,"VEC3",n.xY,O)),l&&(h.attributes.ROTATION=this._buildAccessor(V,"VEC4",n.xY,O)),x&&(h.attributes.SCALE=this._buildAccessor(J,"VEC3",n.xY,O)),H.extensions=H.extensions||{},H.extensions[wo]=h}o(H)}))}_buildAccessor(o,H,n,E){const k=E.createBufferView(o),g=E.createAccessor(k,H,5126,n);return this._exporter._accessors.push(g),this._exporter._accessors.length-1}}Io.RegisterExtension(wo,(o=>new ro(o)));var uo=n(11765),Ro=n(11776),Wo=n(11784),io=n(11793);function Lo(o){return o===Wo.c.PositionKind?"POSITION":o===Wo.c.NormalKind?"NORMAL":o===Wo.c.ColorKind?"COLOR":o.startsWith(Wo.c.UVKind)?"TEX_COORD":"GENERIC"}const oH={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class HH extends uo.c{static get DefaultAvailable(){return(0,uo.f)(HH.DefaultConfiguration)}static get Default(){return HH._Default??(HH._Default=new HH),HH._Default}static ResetDefault(o){HH._Default&&(o||HH._Default.dispose(),HH._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(o,H){return{module:await(H||DracoEncoderModule)({wasmBinary:o})}}_getWorkerContent(){return`${Ro.g}(${Ro.h})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:HH.DefaultConfiguration)}async _encodeAsync(o,H,n){const E=n?(0,io.b)(oH,n):oH;if(this._workerPoolPromise){const n=await this._workerPoolPromise;return await new Promise(((k,g)=>{n.push(((n,O)=>{const Y=o=>{n.removeEventListener("error",Y),n.removeEventListener("message",y),g(o),O()},y=o=>{"encodeMeshDone"===o.data.id&&(n.removeEventListener("error",Y),n.removeEventListener("message",y),k(o.data.encodedMeshData),O())};n.addEventListener("error",Y),n.addEventListener("message",y);const S=[];for(const H of o)S.push(H.data.buffer);H&&S.push(H.buffer),n.postMessage({id:"encodeMesh",attributes:o,indices:H,options:E},S)}))}))}if(this._modulePromise){const n=await this._modulePromise;return(0,Ro.g)(n.module,o,H,E)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(o,H){if(0==o.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");o instanceof No.b&&o.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===H||void 0===H?void 0:H.method)&&(C.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),H.method="MESH_SEQUENTIAL_ENCODING");const n=function(o){let H=o.dg(void 0,!0);return!H||H instanceof Uint32Array||H instanceof Uint16Array||(H=((0,F.c)(H,H.length)?Uint32Array:Uint16Array).from(H)),H}(o),E=function(o,H){const n=[];for(const E of o.getVerticesDataKinds()){if(null!==H&&void 0!==H&&H.includes(E)){if(E===Wo.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const k=o.getVertexBuffer(E),g=k.getSize(),O=(0,F.q)(k.getData(),g,k.type,k.byteOffset,k.byteStride,k.normalized,o.getTotalVertices(),!0);n.push({kind:E,dracoName:Lo(E),size:g,data:O})}return n}(o,null===H||void 0===H?void 0:H.excludedAttributes);return await this._encodeAsync(E,n,H)}}HH.DefaultConfiguration={wasmUrl:`${k.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${k.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${k.Tools._DefaultCdnUrl}/draco_encoder.js`},HH._Default=null;const nH="KHR_draco_mesh_compression";class EH{get wasUsed(){return this._wasUsed}constructor(o){this.name=nH,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===o.options.meshCompressionMethod&&HH.DefaultAvailable}dispose(){}postExportMeshPrimitive(o,H,n){if(!this.enabled)return;if(4!==o.mode&&5!==o.mode)return void C.d.Warn("Cannot compress primitive with mode "+o.mode+".");const E=[],k=[];let g=null;if(void 0!==o.indices){const O=n[o.indices],Y=H.getBufferView(O);g=H.getData(Y).slice(),E.push(Y),k.push(O)}const O=[];for(const[G,c]of Object.entries(o.attributes)){const o=n[c],g=H.getBufferView(o),y=r(o.type),S=(0,F.q)(H.getData(g),y,o.componentType,o.byteOffset||0,g.byteStride||(0,F.k)(o.componentType)*y,o.normalized||!1,o.count,!0);O.push({kind:G,dracoName:(Y=G,"POSITION"===Y?"POSITION":"NORMAL"===Y?"NORMAL":Y.startsWith("COLOR")?"COLOR":Y.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:r(o.type),data:S}),E.push(g),k.push(o)}var Y;const y={method:o.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},S=HH.Default._encodeAsync(O,g,y).then((n=>{if(!n)return void C.d.Error("Draco encoding failed for primitive.");const g={bufferView:-1,attributes:n.attributeIds},O=H.createBufferView(n.data);H.setBufferView(g,O);for(const o of E)this._bufferViewsUsed.add(o);for(const o of k)this._accessorsUsed.add(o);o.extensions||(o.extensions={}),o.extensions[nH]=g})).catch((o=>{C.d.Error("Draco encoding failed for primitive: "+o)}));this._encodePromises.push(S),this._wasUsed=!0}async preGenerateBinaryAsync(o){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((H=>{o.getPropertiesWithBufferView(H).every((o=>this._accessorsUsed.has(o)))&&o.removeBufferView(H)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Io.RegisterExtension(nH,(o=>new EH(o)));var kH=n(11797);const gH="KHR_lights_punctual",OH={name:"",color:[1,1,1],zY:1,range:Number.MAX_VALUE},YH={innerConeAngle:0,outerConeAngle:Math.PI/4},yH=E.xH.Backward();class SH{constructor(o){this.name=gH,this.enabled=!0,this.required=!1,this._exporter=o}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[gH]=this._lights}async postExportNodeAsync(o,H,n,k,g){return await new Promise((O=>{if(!(n instanceof ho.e))return void O(H);const Y=n.getTypeID()==ho.e.LIGHTTYPEID_POINTLIGHT?"point":n.getTypeID()==ho.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":n.getTypeID()==ho.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!Y||!(n instanceof kH.e))return C.d.Warn(`${o}: Light ${n.name} is not supported in ${gH}`),void O(H);if(n.falloffType!==ho.e.FALLOFF_GLTF&&C.d.Warn(`${o}: Light falloff for ${n.name} does not match the ${gH} specification!`),!n.position.equalsToFloats(0,0,0)){const o=E.TmpVectors.xH[0].S(n.position);g&&W(o),H.translation=o.bg()}if("point"!==Y){const o=n.direction.normalizeToRef(E.TmpVectors.xH[0]);g&&W(o);const k=E.Quaternion.FromUnitVectorsToRef(yH,o,E.TmpVectors.Quaternion[0]);E.Quaternion.IsIdentity(k)||(H.rotation=k.bg())}const y={type:Y,name:n.name,color:n.VY.bg(),zY:n.zY,range:n.range};if(Eo(y,OH),"spot"===Y){const o=n;y.spot={innerConeAngle:o.innerAngle/2,outerConeAngle:o.angle/2},Eo(y.spot,YH)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(y);const S={ng:this._lights.lights.length-1},G=n.parent;if(G&&Ho(n,G)){const o=k.get(G);if(o){const n=this._exporter._nodes[o];return oo(H,n),n.extensions||(n.extensions={}),n.extensions[gH]=S,void O(null)}}H.extensions||(H.extensions={}),H.extensions[gH]=S,O(H)}))}}Io.RegisterExtension(gH,(o=>new SH(o)));var GH=n(11702);const cH="KHR_materials_anisotropy";class AH{constructor(o){this.name=cH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,H,n){const E=[];return n instanceof GH.b&&n.anisotropy.isEnabled&&!n.anisotropy.legacy?(n.anisotropy.texture&&E.push(n.anisotropy.texture),E):[]}postExportMaterialAsync(o,H,n){return new Promise((o=>{if(n instanceof GH.b){if(!n.anisotropy.isEnabled||n.anisotropy.legacy)return void o(H);this._wasUsed=!0,H.extensions=H.extensions||{};const E=this._exporter._materialExporter.getTextureInfo(n.anisotropy.texture),k={anisotropyStrength:n.anisotropy.zY,anisotropyRotation:n.anisotropy.angle,anisotropyTexture:E??void 0};null!==k.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(n),H.extensions[cH]=k}o(H)}))}}Io.RegisterExtension(cH,(o=>new AH(o)));const lH="KHR_materials_clearcoat";class xH{constructor(o){this.name=lH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,H,n){const E=[];return n instanceof GH.b&&n.clearCoat.isEnabled?(n.clearCoat.texture&&E.push(n.clearCoat.texture),!n.clearCoat.useRoughnessFromMainTexture&&n.clearCoat.textureRoughness&&E.push(n.clearCoat.textureRoughness),n.clearCoat.bumpTexture&&E.push(n.clearCoat.bumpTexture),E):[]}postExportMaterialAsync(o,H,n){return new Promise((o=>{if(n instanceof GH.b){if(!n.clearCoat.isEnabled)return void o(H);this._wasUsed=!0,H.extensions=H.extensions||{};const E=this._exporter._materialExporter.getTextureInfo(n.clearCoat.texture);let g;g=n.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(n.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(n.clearCoat.textureRoughness),n.clearCoat.isTintEnabled&&k.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${n.name}`),n.clearCoat.remapF0OnInterfaceChange&&k.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${n.name}`);const O=this._exporter._materialExporter.getTextureInfo(n.clearCoat.bumpTexture),Y={clearcoatFactor:n.clearCoat.zY,clearcoatTexture:E??void 0,clearcoatRoughnessFactor:n.clearCoat.roughness,clearcoatRoughnessTexture:g??void 0,clearcoatNormalTexture:O??void 0};null===Y.clearcoatTexture&&null===Y.clearcoatRoughnessTexture&&null===Y.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(n),H.extensions[lH]=Y}o(H)}))}}Io.RegisterExtension(lH,(o=>new xH(o)));const zH="KHR_materials_diffuse_transmission";function VH(o,H){const n=H.subSurface;let E=null;return n.translucencyIntensityTexture?E=n.translucencyIntensityTexture:n.thicknessTexture&&n.useMaskFromThicknessTexture&&(E=n.thicknessTexture),E&&!n.useGltfStyleTextures?(C.d.Warn(`${o}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${H.name}`,1),null):E}class JH{constructor(o){this.name=zH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,H,n){const E=[];if(n instanceof xo.c&&this._isExtensionEnabled(n)){const H=VH(o,n);return H&&E.push(H),n.subSurface.translucencyColorTexture&&E.push(n.subSurface.translucencyColorTexture),E}return E}_isExtensionEnabled(o){if(o.unlit)return!1;const H=o.subSurface;return!!H.isTranslucencyEnabled&&(!o.unlit&&!H.useAlbedoToTintTranslucency&&H.useGltfStyleTextures&&1===H.volumeIndexOfRefraction&&0===H.minimumThickness&&0===H.maximumThickness)}postExportMaterialAsync(o,H,n){return new Promise((E=>{if(n instanceof xo.c&&this._isExtensionEnabled(n)){this._wasUsed=!0;const E=n.subSurface,k=VH(o,n),g=0==E.translucencyIntensity?void 0:E.translucencyIntensity,O=this._exporter._materialExporter.getTextureInfo(k)??void 0,Y=!E.translucencyColor||E.translucencyColor.equalsFloats(1,1,1)?void 0:E.translucencyColor.bg(),y=this._exporter._materialExporter.getTextureInfo(E.translucencyColorTexture)??void 0,S={diffuseTransmissionFactor:g,diffuseTransmissionTexture:O,diffuseTransmissionColorFactor:Y,diffuseTransmissionColorTexture:y};(O||y)&&this._exporter._materialNeedsUVsSet.add(n),H.extensions=H.extensions||{},H.extensions[zH]=S}E(H)}))}}Io.RegisterExtension(zH,(o=>new JH(o)));const NH="KHR_materials_dispersion";class hH{constructor(){this.name=NH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(o){if(o.unlit)return!1;const H=o.subSurface;return!(!H.isRefractionEnabled&&!H.isDispersionEnabled)}postExportMaterialAsync(o,H,n){return new Promise((o=>{if(n instanceof xo.c&&this._isExtensionEnabled(n)){this._wasUsed=!0;const o={dispersion:n.subSurface.dispersion};H.extensions=H.extensions||{},H.extensions[NH]=o}o(H)}))}}Io.RegisterExtension(NH,(()=>new hH));const QH="KHR_materials_emissive_strength";class pH{constructor(){this.name=QH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(o,H,n){return await new Promise((o=>{if(!(n instanceof xo.c))return o(H);const E=n.emissiveColor.bg(),k=Math.max(...E);if(k>1){this._wasUsed=!0,H.extensions||(H.extensions={});const o={emissiveStrength:k},E=n.emissiveColor.scale(1/o.emissiveStrength);H.emissiveFactor=E.bg(),H.extensions[QH]=o}return o(H)}))}}Io.RegisterExtension(QH,(o=>new pH));const jH="KHR_materials_ior";class mH{constructor(){this.name=jH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(o){return!o.unlit&&(void 0!=o.indexOfRefraction&&1.5!=o.indexOfRefraction)}postExportMaterialAsync(o,H,n){return new Promise((o=>{if(n instanceof xo.c&&this._isExtensionEnabled(n)){this._wasUsed=!0;const o={ior:n.indexOfRefraction};H.extensions=H.extensions||{},H.extensions[jH]=o}o(H)}))}}Io.RegisterExtension(jH,(o=>new mH));const PH="KHR_materials_iridescence";class bH{constructor(o){this.name=PH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,H,n){const E=[];return n instanceof GH.b&&n.iridescence.isEnabled?(n.iridescence.texture&&E.push(n.iridescence.texture),n.iridescence.thicknessTexture&&n.iridescence.thicknessTexture!==n.iridescence.texture&&E.push(n.iridescence.thicknessTexture),E):[]}postExportMaterialAsync(o,H,n){return new Promise((o=>{if(n instanceof GH.b){if(!n.iridescence.isEnabled)return void o(H);this._wasUsed=!0,H.extensions=H.extensions||{};const E=this._exporter._materialExporter.getTextureInfo(n.iridescence.texture),k=this._exporter._materialExporter.getTextureInfo(n.iridescence.thicknessTexture),g={iridescenceFactor:n.iridescence.zY,iridescenceIor:n.iridescence.indexOfRefraction,iridescenceThicknessMinimum:n.iridescence.minimumThickness,iridescenceThicknessMaximum:n.iridescence.maximumThickness,iridescenceTexture:E??void 0,iridescenceThicknessTexture:k??void 0};null===g.iridescenceTexture&&null===g.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(n),H.extensions[PH]=g}o(H)}))}}Io.RegisterExtension(PH,(o=>new bH(o)));const eH="KHR_materials_sheen";class ZH{constructor(o){this.name=eH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,H,n){return n instanceof xo.c&&n.sheen.isEnabled&&n.sheen.texture?[n.sheen.texture]:[]}async postExportMaterialAsync(o,H,n){return await new Promise((o=>{if(n instanceof xo.c){if(!n.sheen.isEnabled)return void o(H);this._wasUsed=!0,null==H.extensions&&(H.extensions={});const E={sheenColorFactor:n.sheen.color.bg(),sheenRoughnessFactor:n.sheen.roughness??0};null===E.sheenColorTexture&&null===E.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(n),n.sheen.texture&&(E.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(n.sheen.texture)??void 0),n.sheen.textureRoughness&&!n.sheen.useRoughnessFromMainTexture?E.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(n.sheen.textureRoughness)??void 0:n.sheen.texture&&n.sheen.useRoughnessFromMainTexture&&(E.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(n.sheen.texture)??void 0),H.extensions[eH]=E}o(H)}))}}Io.RegisterExtension(eH,(o=>new ZH(o)));const MH="KHR_materials_specular";class KH{constructor(o){this.name=MH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,H,n){const E=[];return n instanceof xo.c&&this._isExtensionEnabled(n)?(n.metallicReflectanceTexture&&E.push(n.metallicReflectanceTexture),n.reflectanceTexture&&E.push(n.reflectanceTexture),E):E}_isExtensionEnabled(o){return!o.unlit&&(void 0!=o.metallicF0Factor&&1!=o.metallicF0Factor||void 0!=o.metallicReflectanceColor&&!o.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(o))}_hasTexturesExtension(o){return null!=o.metallicReflectanceTexture||null!=o.reflectanceTexture}postExportMaterialAsync(o,H,n){return new Promise((o=>{if(n instanceof xo.c&&this._isExtensionEnabled(n)){this._wasUsed=!0,H.extensions=H.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(n.metallicReflectanceTexture)??void 0,E=this._exporter._materialExporter.getTextureInfo(n.reflectanceTexture)??void 0,k={specularFactor:1==n.metallicF0Factor?void 0:n.metallicF0Factor,specularTexture:o,specularColorFactor:n.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:n.metallicReflectanceColor.bg(),specularColorTexture:E};this._hasTexturesExtension(n)&&this._exporter._materialNeedsUVsSet.add(n),H.extensions[MH]=k}o(H)}))}}Io.RegisterExtension(MH,(o=>new KH(o)));const fH="KHR_materials_transmission";class BH{constructor(o){this.name=fH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,H,n){const E=[];return n instanceof xo.c&&this._isExtensionEnabled(n)?(n.subSurface.thicknessTexture&&E.push(n.subSurface.thicknessTexture),E):E}_isExtensionEnabled(o){if(o.unlit)return!1;const H=o.subSurface;return H.isRefractionEnabled&&void 0!=H.refractionIntensity&&0!=H.refractionIntensity||this._hasTexturesExtension(o)}_hasTexturesExtension(o){return null!=o.subSurface.refractionIntensityTexture}async postExportMaterialAsync(o,H,n){if(n instanceof xo.c&&this._isExtensionEnabled(n)){this._wasUsed=!0;const E=n.subSurface,k={transmissionFactor:0===E.refractionIntensity?void 0:E.refractionIntensity};if(this._hasTexturesExtension(n)&&this._exporter._materialNeedsUVsSet.add(n),E.refractionIntensityTexture)if(E.useGltfStyleTextures){const o=await this._exporter._materialExporter.exportTextureAsync(E.refractionIntensityTexture,"image/png");o&&(k.transmissionTexture=o)}else C.d.Warn(`${o}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);H.extensions||(H.extensions={}),H.extensions[fH]=k}return H}}Io.RegisterExtension(fH,(o=>new BH(o)));const qH="KHR_materials_unlit";class DH{constructor(){this.name=qH,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(o,H,n){return new Promise((o=>{let E=!1;n instanceof xo.c?E=n.unlit:n instanceof zo.JH&&(E=n.disableLighting),E&&(this._wasUsed=!0,null==H.extensions&&(H.extensions={}),H.extensions[qH]={}),o(H)}))}}Io.RegisterExtension(qH,(()=>new DH));const TH="KHR_materials_volume";class aH{constructor(o){this.name=TH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,H,n){const E=[];return n instanceof xo.c&&this._isExtensionEnabled(n)?(n.subSurface.thicknessTexture&&E.push(n.subSurface.thicknessTexture),E):E}_isExtensionEnabled(o){if(o.unlit)return!1;const H=o.subSurface;return!(!H.isRefractionEnabled&&!H.isTranslucencyEnabled)&&(void 0!=H.maximumThickness&&0!=H.maximumThickness||void 0!=H.tintColorAtDistance&&H.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=H.tintColor&&H.tintColor!=V.NH.White()||this._hasTexturesExtension(o))}_hasTexturesExtension(o){return null!=o.subSurface.thicknessTexture}postExportMaterialAsync(o,H,n){return new Promise((o=>{if(n instanceof xo.c&&this._isExtensionEnabled(n)){this._wasUsed=!0;const o=n.subSurface,E={thicknessFactor:0==o.maximumThickness?void 0:o.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(o.thicknessTexture)??void 0,attenuationDistance:o.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:o.tintColorAtDistance,attenuationColor:o.tintColor.equalsFloats(1,1,1)?void 0:o.tintColor.bg()};this._hasTexturesExtension(n)&&this._exporter._materialNeedsUVsSet.add(n),H.extensions=H.extensions||{},H.extensions[TH]=E}o(H)}))}}Io.RegisterExtension(TH,(o=>new aH(o)));const FH="EXT_materials_diffuse_roughness";class CH{constructor(o){this.name=FH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,H,n){const E=[];return n instanceof GH.b&&n._baseDiffuseRoughness?(n._baseDiffuseRoughnessTexture&&E.push(n._baseDiffuseRoughnessTexture),E):[]}postExportMaterialAsync(o,H,n){return new Promise((o=>{if(n instanceof GH.b){if(!n._baseDiffuseRoughness)return void o(H);this._wasUsed=!0,H.extensions=H.extensions||{};const E=this._exporter._materialExporter.getTextureInfo(n._baseDiffuseRoughnessTexture),k={diffuseRoughnessFactor:n._baseDiffuseRoughness,diffuseRoughnessTexture:E??void 0};null!==k.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(n),H.extensions[FH]=k}o(H)}))}}Io.RegisterExtension(FH,(o=>new CH(o)));const tH="KHR_texture_transform";class XH{constructor(){this.name=tH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(o,H,n){if(n.bo()||k.Tools.Warn(`${o}: /*@__KEY__*/"scene" is not defined for Babylon texture ${n.name}!`),(0!==n.uAng||0!==n.vAng)&&(k.Tools.Warn(`${o}: Texture ${n.name} with rotation in the u or v axis is not supported in glTF.`),0!==n.uRotationCenter||0!==n.vRotationCenter))return;const E={};let g=!1;if(0===n.uOffset&&0===n.vOffset||(E.offset=[n.uOffset,n.vOffset],g=!0),1===n.uScale&&1===n.vScale||(E.scale=[n.uScale,n.vScale],g=!0),0!==n.wAng){if(0!==n.uRotationCenter||0!==n.vRotationCenter){if(n.homogeneousRotationInUVTransform&&n.uScale!==n.vScale)return void k.Tools.Warn(`${o}: Texture ${n.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${tH}.`);k.Tools.Warn(`${o}: Texture ${n.name} with non-origin rotation center will be exported using an adjusted offset with ${tH}.`),E.offset=function(o){const{uOffset:H,vOffset:n,uRotationCenter:E,vRotationCenter:k,uScale:g,vScale:O,wAng:Y}=o,y=Math.cos(Y),S=Math.sin(Y),G=E*g,c=k*O;return[H+(G*(1-y)+c*S),n+(c*(1-y)-G*S)]}(n)}E.rotation=-n.wAng,g=!0}0!==n.coordinatesIndex&&(E.texCoord=n.coordinatesIndex,g=!0),g&&(this._wasUsed=!0,H.extensions||(H.extensions={}),H.extensions[tH]=E)}}Io.RegisterExtension(tH,(()=>new XH));class sH{static CreateSTL(o){let H=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",k=arguments.length>3&&void 0!==arguments[3]&&arguments[3],g=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],O=arguments.length>5&&void 0!==arguments[5]&&arguments[5],Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6],y=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const S=function(o,H,n){const k=[3*o[n],3*o[n+1],3*o[n+2]],g=[new E.xH(H[k[0]],H[k[0]+2],H[k[0]+1]),new E.xH(H[k[1]],H[k[1]+2],H[k[1]+1]),new E.xH(H[k[2]],H[k[2]+2],H[k[2]+1])],O=g[0].zH(g[1]),Y=g[2].zH(g[1]);return{v:g,n:E.xH.Cross(Y,O).normalize()}},c=function(o,H,n,E){return H=A(o,H,n.x,E),H=A(o,H,n.y,E),A(o,H,n.z,E)},A=function(o,H,n,E){return o.setFloat32(H,n,E),H+4},x=function(o){if(Y){let H=o;o instanceof l.e&&(H=o.sourceMesh);const n=H.getVerticesData(G.d.PositionKind,!0,!0);if(!n)return[];const k=E.xH.Zero();let g;for(g=0;g<n.length;g+=3)E.xH.TransformCoordinatesFromFloatsToRef(n[g],n[g+1],n[g+2],o.Ig(!0),k).toArray(n,g);return n}return o.getVerticesData(G.d.PositionKind)||[]};Y&&(O=!0);let z="",V=0,J=0;if(k){for(let n=0;n<o.length;n++){const H=o[n].dg();V+=H?H.length/3:0}const H=new ArrayBuffer(84+50*V);z=new DataView(H),J+=80,z.setUint32(J,V,g),J+=4}else y||(z="solid stlmesh\r\n");for(let E=0;E<o.length;E++){const H=o[E];!k&&y&&(z+="solid "+H.name+"\r\n"),!O&&H instanceof No.b&&H.bakeCurrentTransformIntoVertices();const n=x(H),Y=H.dg()||[];for(let o=0;o<Y.length;o+=3){const H=S(Y,n,o);k?(J=c(z,J,H.n,g),J=c(z,J,H.v[0],g),J=c(z,J,H.v[1],g),J=c(z,J,H.v[2],g),J+=2):(z+="\tfacet normal "+H.n.x+" "+H.n.y+" "+H.n.z+"\r\n",z+="\t\touter loop\r\n",z+="\t\t\tvertex "+H.v[0].x+" "+H.v[0].y+" "+H.v[0].z+"\r\n",z+="\t\t\tvertex "+H.v[1].x+" "+H.v[1].y+" "+H.v[1].z+"\r\n",z+="\t\t\tvertex "+H.v[2].x+" "+H.v[2].y+" "+H.v[2].z+"\r\n",z+="\t\tendloop\r\n",z+="\tendfacet\r\n")}!k&&y&&(z+="endsolid "+name+"\r\n")}if(k||y||(z+="endsolid stlmesh"),H){const o=document.createElement("a"),H=new Blob([z],{type:"application/octet-stream"});o.href=window.URL.createObjectURL(H),o.download=n+".stl",o.click()}return z}}function UH(o,H){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const E=[];for(let k=0;k<o.length/n;k++){const g=o[k*n],O=o[k*n+1],Y=o[k*n+2];E.push(`(${g.toPrecision(H.precision)}, ${O.toPrecision(H.precision)}, ${Y.toPrecision(H.precision)})`)}return E.join(", ")}function IH(o,H){const n=[];for(let E=0;E<o.length/2;E++){const k=o[2*E],g=o[2*E+1];n.push(`(${k.toPrecision(H.precision)}, ${(1-g).toPrecision(H.precision)})`)}return n.join(", ")}function vH(o,H){const n=o.getVerticesData(G.d.PositionKind),E=o.getVerticesData(G.d.NormalKind);if(n&&E)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(o){var H;const n=null!==(H=o.dg())&&void 0!==H&&H.length?o.getTotalIndices():o.getTotalVertices();return Array(n/3).fill(3).join(", ")}(o)}]\n\t\tint[] faceVertexIndices = [${function(o){const H=o.dg(),n=[];if(null!==H)for(let E=0;E<H.length;E++)n.push(H[E]);else{const H=o.getTotalVertices();for(let o=0;o<H;o++)n.push(o)}return n.join(", ")}(o)}]\n\t\tnormal3f[] normals = [${UH(E,H)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${UH(n,H)}]\n        ${function(o,H){let n="";for(let k=0;k<4;k++){const E=k>0?k:"",g=o.getVerticesData(G.d.UVKind+(E?E+1:""));g&&(n+=`\n\t\ttexCoord2f[] primvars:st${E} = [${IH(g,H)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const E=o.getVerticesData(G.d.ColorKind);return E&&(n+=`\n\tcolor3f[] primvars:displayColor = [${UH(E,H,E.length/o.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),n}(o,H)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function wH(o,H){return`\n        def "Geometry"\n        {\n        ${vH(o,H)}\n        }\n        `}function rH(o){let H='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return H+=o,fflate.strToU8(H)}function uH(o){const H=o.m;return`( ${dH(H,0)}, ${dH(H,4)}, ${dH(H,8)}, ${dH(H,12)} )`}function dH(o,H){return`(${o[H+0]}, ${o[H+1]}, ${o[H+2]}, ${o[H+3]})`}function RH(o){const H="Object_"+o.uniqueId,n=function(o){const H=o.getWorldMatrix().clone(),n=o.bo().useRightHandedSystem;if(!n){let E=o.parent;for(;E;){if(Oo(E,n)){H.multiplyToRef(E.getWorldMatrix().invert(),H);break}E=E.parent}}return H.determinant()<0&&k.Tools.Warn(`Exporting mesh ${o.name} with negative scale. Result may look incorrect in destination engine.`),H}(o),E=uH(n);return`def Xform "${H}" (\n\tprepend references = @./geometries/Geometry_${o.wg.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${E}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${o.material.uniqueId}>\n}\n\n`}function WH(o){switch(o){case m.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case m.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case m.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function iH(o){return`(${o.x}, ${o.y})`}function LH(o){return`(${o.r}, ${o.g}, ${o.b})`}function on(o,H,n,k,g,O){const Y=o.getInternalTexture().uniqueId+"_"+o.invertY;g[Y]=o;const y=o.coordinatesIndex>0?"st"+o.coordinatesIndex:"st",S=new E.Vector2(o.uScale,o.vScale),G=new E.Vector2(o.uOffset,o.vOffset),c=o.wAng,A=Math.sin(c),l=Math.cos(c);return G.y=1-G.y-S.y,G.x+=A*S.x,G.y+=(1-l)*S.y,`\n    def Shader "PrimvarReader_${n}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${y}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${n}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${H.uniqueId}/PrimvarReader_${n}.outputs:result>\n        float inputs:rotation = ${(c*(180/Math.PI)).toFixed(O.precision)}\n        float2 inputs:scale = ${iH(S)}\n        float2 inputs:translation = ${iH(G)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${o.uniqueId}_${n}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${Y}.png@\n        float2 inputs:st.connect = </Materials/Material_${H.uniqueId}/Transform2d_${n}.outputs:result>\n        ${k?"float4 inputs:scale = "+function(o){return`(${o.r}, ${o.g}, ${o.b}, 1.0)`}(k):""}\n        token inputs:sourceColorSpace = "${o.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${WH(o.wrapU)}"\n        token inputs:wrapT = "${WH(o.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${H.needAlphaBlending()?"float outputs:a":""}\n    }`}function Hn(o,H,n){const E="\t\t\t",k=[],g=[],{diffuseMap:O,VY:Y,alphaCutOff:y,emissiveMap:S,emissive:G,normalMap:c,roughnessMap:A,roughnessChannel:l,roughness:x,metalnessMap:z,metalnessChannel:J,metalness:N,aoMap:h,aoMapChannel:Q,aoMapIntensity:p,alphaMap:j,ior:m,clearCoatEnabled:P,clearCoat:b,clearCoatMap:e,clearCoatRoughness:Z,clearCoatRoughnessMap:M}=function(o){const H={diffuseMap:null,VY:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return o instanceof zo.JH?{...H,diffuseMap:o.diffuseTexture,VY:o.diffuseColor,alphaCutOff:o.alphaCutOff,emissiveMap:o.emissiveTexture,emissive:o.emissiveColor,roughness:1,alphaMap:o.opacityTexture}:o instanceof GH.b?{...H,diffuseMap:o._albedoTexture,VY:o._albedoColor,alphaCutOff:o._alphaCutOff,emissiveMap:o._emissiveTexture,emissive:o._emissiveColor,normalMap:o._bumpTexture,roughnessMap:o._metallicTexture,roughnessChannel:o._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:o._roughness??1,metalnessMap:o._metallicTexture,metalnessChannel:o._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:o._metallic??0,aoMap:o._ambientTexture,aoMapChannel:o._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:o._ambientTextureStrength,alphaMap:o._opacityTexture,ior:o.subSurface.indexOfRefraction,clearCoatEnabled:o.clearCoat.isEnabled,clearCoat:o.clearCoat.zY,clearCoatMap:o.clearCoat.texture,clearCoatRoughness:o.clearCoat.roughness,clearCoatRoughnessMap:o.clearCoat.useRoughnessFromMainTexture?o.clearCoat.texture:o.clearCoat.textureRoughness}:H}(o);return null!==O?(k.push(`${E}color3f inputs:diffuseColor.connect = </Materials/Material_${o.uniqueId}/Texture_${O.uniqueId}_diffuse.outputs:rgb>`),o.needAlphaBlending()?k.push(`${E}float inputs:opacity.connect = </Materials/Material_${o.uniqueId}/Texture_${O.uniqueId}_diffuse.outputs:a>`):o.needAlphaTesting()&&(k.push(`${E}float inputs:opacity.connect = </Materials/Material_${o.uniqueId}/Texture_${O.uniqueId}_diffuse.outputs:a>`),k.push(`${E}float inputs:opacityThreshold = ${y}`)),g.push(on(O,o,"diffuse",Y,H,n))):k.push(`${E}color3f inputs:diffuseColor = ${LH(Y||V.NH.White())}`),null!==S?(k.push(`${E}color3f inputs:emissiveColor.connect = </Materials/Material_${o.uniqueId}/Texture_${S.uniqueId}_emissive.outputs:rgb>`),g.push(on(S,o,"emissive",G,H,n))):G&&G.toLuminance()>0&&k.push(`${E}color3f inputs:emissiveColor = ${LH(G)}`),null!==c&&(k.push(`${E}normal3f inputs:normal.connect = </Materials/Material_${o.uniqueId}/Texture_${c.uniqueId}_normal.outputs:rgb>`),g.push(on(c,o,"normal",null,H,n))),null!==h&&(k.push(`${E}float inputs:occlusion.connect = </Materials/Material_${o.uniqueId}/Texture_${h.uniqueId}_occlusion.outputs:${Q}>`),g.push(on(h,o,"occlusion",new V.NH(p,p,p),H,n))),null!==A?(k.push(`${E}float inputs:roughness.connect = </Materials/Material_${o.uniqueId}/Texture_${A.uniqueId}_roughness.outputs:${l}>`),g.push(on(A,o,"roughness",new V.NH(x,x,x),H,n))):k.push(`${E}float inputs:roughness = ${x}`),null!==z?(k.push(`${E}float inputs:metallic.connect = </Materials/Material_${o.uniqueId}/Texture_${z.uniqueId}_metallic.outputs:${J}>`),g.push(on(z,o,"metallic",new V.NH(N,N,N),H,n))):k.push(`${E}float inputs:metallic = ${N}`),null!==j?(k.push(`${E}float inputs:opacity.connect = </Materials/Material_${o.uniqueId}/Texture_${j.uniqueId}_opacity.outputs:r>`),k.push(`${E}float inputs:opacityThreshold = 0.0001`),g.push(on(j,o,"opacity",null,H,n))):k.push(`${E}float inputs:opacity = ${o.alpha}`),P&&(null!==e?(k.push(`${E}float inputs:clearcoat.connect = </Materials/Material_${o.uniqueId}/Texture_${e.uniqueId}_clearcoat.outputs:r>`),g.push(on(e,o,"clearcoat",new V.NH(b,b,b),H,n))):k.push(`${E}float inputs:clearcoat = ${b}`),null!==M?(k.push(`${E}float inputs:clearcoatRoughness.connect = </Materials/Material_${o.uniqueId}/Texture_${M.uniqueId}_clearcoatRoughness.outputs:g>`),g.push(on(M,o,"clearcoatRoughness",new V.NH(Z,Z,Z),H,n))):k.push(`${E}float inputs:clearcoatRoughness = ${Z}`)),k.push(`${E}float inputs:ior = ${m}`),`\n\tdef Material "Material_${o.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${k.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${o.uniqueId}/PreviewSurface.outputs:surface>\n\n${g.join("\n")}\n\n\t}\n`}async function nn(o,H,n){const g={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...H};"undefined"===typeof fflate&&await k.Tools.LoadScriptAsync(g.fflateUrl);const O={};O[g.modelFileName]=null;let Y='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';Y+=function(o){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===o.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${o.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${o.planeAnchoringAlignment}"`:""}\n            `}(g);const y={};for(const E of o.meshes){if(0===E.getTotalVertices())continue;const o=E,H=o.wg,S=o.material;if(!S||!H||n&&!n(o))continue;if(-1!==["JH","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(S.getClassName())){const n="geometries/Geometry_"+H.uniqueId+".usda";if(!(n in O)){const o=wH(H,g);O[n]=rH(o)}S.uniqueId in y||(y[S.uniqueId]=S),Y+=RH(o)}else k.Tools.Warn("USDZExportAsync does not support this material type: "+S.getClassName())}o.activeCamera&&g.exportCamera&&(Y+=function(o,H){const n="Camera_"+o.uniqueId,k=uH(E.Matrix.RotationY(Math.PI).multiply(o.getWorldMatrix()));if(o.mode===m.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${k}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${o.Cg.toPrecision(H.precision)}, ${o.maxZ.toPrecision(H.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(o.orthoLeft||1)+Math.abs(o.orthoRight||1))).toPrecision(H.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(o.orthoTop||1)+Math.abs(o.orthoBottom||1))).toPrecision(H.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const E=o.getEngine().getAspectRatio(o),g=H.cameraSensorWidth||35;return`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${k}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${o.Cg.toPrecision(H.precision)}, ${o.maxZ.toPrecision(H.precision)})\n\t\t\tfloat focalLength = ${(g/(2*Math.tan(.5*o.fov))).toPrecision(H.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(g*E).toPrecision(H.precision)}\n\t\t\tfloat verticalAperture = ${(g/E).toPrecision(H.precision)}            \n\t\t}\n\t\n\t`}}(o.activeCamera,g)),Y+="\n            }\n        }\n    }";const S={};Y+=function(o,H,n){const E=[];for(const k in o){const g=o[k];E.push(Hn(g,H,n))}return`\n    def "Materials"\n{\n${E.join("")}\n}\n\n`}(y,S,g),O[g.modelFileName]=fflate.strToU8(Y);for(const E in S){const o=S[E],H=o.getSize(),n=await o.readPixels();if(!n)throw new Error("Texture data is not available");const k=await P.DumpTools.DumpDataAsync(H.width,H.height,n,"image/png",void 0,!1,!0);O[`textures/Texture_${E}.png`]=new Uint8Array(k).slice()}let G=0;for(const E in O){const o=O[E];if(!o)continue;G+=34+E.length;const H=63&G;if(4!==H){const n=new Uint8Array(64-H);O[E]=[o,{extra:{12345:n}}]}G=o.length}return fflate.zipSync(O,{level:0})}}}]);