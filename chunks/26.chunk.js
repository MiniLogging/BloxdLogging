"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[26],{12743:(E,U,g)=>{g.r(U),g.d(U,{EXT_materials_diffuse_roughness:()=>JU,EXT_mesh_gpu_instancing:()=>kE,GLTF2Export:()=>RE,GLTFData:()=>C,KHR_draco_mesh_compression:()=>gU,KHR_lights_punctual:()=>sU,KHR_materials_anisotropy:()=>PU,KHR_materials_clearcoat:()=>fU,KHR_materials_diffuse_transmission:()=>yU,KHR_materials_dispersion:()=>VU,KHR_materials_emissive_strength:()=>xU,KHR_materials_ior:()=>YU,KHR_materials_iridescence:()=>GU,KHR_materials_sheen:()=>TU,KHR_materials_specular:()=>oU,KHR_materials_transmission:()=>rU,KHR_materials_unlit:()=>ZU,KHR_materials_volume:()=>wU,KHR_texture_transform:()=>MU,OBJExport:()=>S,STLExport:()=>mg,USDZExportAsync:()=>Ug,_ConvertToGLTFPBRMetallicRoughness:()=>j,_SolveMetallic:()=>r,__IGLTFExporterExtension:()=>u});var N=g(12334),L=g(12165),D=g(12656);class S{static OBJ(E,U,g,S){const u=[];let s=1,C=1;U&&(g||(g="mat"),u.push("mtllib "+g+".mtl"));for(let B=0;B<E.length;B++){const g=E[B],P=g.name||`mesh${B}}`;u.push(`o ${P}`);let F=null;if(S){const E=g.pg(!0);F=new N.Matrix,E.invertToRef(F),g.bakeTransformIntoVertices(E)}if(U){const E=g.material;E&&u.push("usemtl "+E.id)}const f=g.XL;if(!f){L.Tools.Warn("No geometry is present on the mesh");continue}const d=f.getVerticesData("position"),I=f.getVerticesData("normal"),y=f.getVerticesData("uv"),h=f.CD();let V=0,e=0;if(!d||!h){L.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const x=E[0].tE().useRightHandedSystem?1:-1;for(let E=0;E<d.length;E+=3)u.push("v "+d[E]*x+" "+d[E+1]+" "+d[E+2]),V++;if(null!=I)for(let E=0;E<I.length;E+=3)u.push("vn "+I[E]*x+" "+I[E+1]+" "+I[E+2]);if(null!=y)for(let E=0;E<y.length;E+=2)u.push("vt "+y[E]+" "+y[E+1]),e++;const l=["","",""],Y=(g.material||g.tE().defaultMaterial)._getEffectiveOrientation(g),[t,G]=Y===D.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let E=0;E<h.length;E+=3){const U=[String(h[E]+s),String(h[E+t]+s),String(h[E+G]+s)],g=[String(h[E]+C),String(h[E+t]+C),String(h[E+G]+C)],N=U,L=null!=y?g:l,D=null!=I?U:l;u.push("f "+N[0]+"/"+L[0]+"/"+D[0]+" "+N[1]+"/"+L[1]+"/"+D[1]+" "+N[2]+"/"+L[2]+"/"+D[2])}S&&F&&g.bakeTransformIntoVertices(F),s+=V,C+=e}return u.join("\n")}static MTL(E){const U=[],g=E.material;U.push("newmtl mat1"),U.push("  Ns "+g.specularPower.toFixed(4)),U.push("  Ni 1.5000"),U.push("  d "+g.alpha.toFixed(4)),U.push("  Tr 0.0000"),U.push("  Tf 1.0000 1.0000 1.0000"),U.push("  illum 2"),U.push("  Ka "+g.ambientColor.r.toFixed(4)+" "+g.ambientColor.g.toFixed(4)+" "+g.ambientColor.b.toFixed(4)),U.push("  Kd "+g.diffuseColor.r.toFixed(4)+" "+g.diffuseColor.g.toFixed(4)+" "+g.diffuseColor.b.toFixed(4)),U.push("  Ks "+g.specularColor.r.toFixed(4)+" "+g.specularColor.g.toFixed(4)+" "+g.specularColor.b.toFixed(4)),U.push("  Ke "+g.emissiveColor.r.toFixed(4)+" "+g.emissiveColor.g.toFixed(4)+" "+g.emissiveColor.b.toFixed(4));g.ambientTexture&&U.push("  map_Ka "+g.ambientTexture.name),g.diffuseTexture&&U.push("  map_Kd "+g.diffuseTexture.name),g.specularTexture&&U.push("  map_Ks "+g.specularTexture.name),g.bumpTexture&&U.push("  map_bump -imfchan z "+g.bumpTexture.name),g.opacityTexture&&U.push("  map_d "+g.opacityTexture.name);return U.join("\n")}}var u=0,s=g(12210);class C{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const E in this.files){const U=this.files[E],g=new Blob([U],{type:(0,s.e)(E)});L.Tools.Download(g,E)}}}var B=g(12407),P=g(12750),F=g(12760),f=g(12771),d=g(12462),I=g(12205),y=g(12379),h=g(12353);const V=h.HighestCommonFactor,e={...h,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:V};var x=g(12557),l=g(12311),Y=g(12811),t=g(12815),G=g(12554);const b=1e-6,T=new y.VU(.04,.04,.04),v=1024,o=y.VU.White(),c=y.VU.Black();function r(E,U,g){if(U<T.r)return 0;const N=T.r,L=E*g/(1-T.r)+U-2*T.r,D=L*L-4*N*(T.r-U);return e.Clamp((-L+Math.sqrt(D))/(2*N),0,1)}function j(E){const U=E.diffuseColor.toLinearSpace(E.tE().getEngine().useExactSrgbConversions).scale(.5),g=E.alpha,L=function(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new N.Vector2(0,1),g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new N.Vector2(0,.1),L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new N.Vector2(0,.1),D=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new N.Vector2(1300,.1);return function(E,U,g,N,L){return(1-E)*(1-E)*(1-E)*U+3*(1-E)*(1-E)*E*g+3*(1-E)*E*E*N+E*E*E*L}(Math.pow(E/D.x,.333333),U.y,g.y,L.y,D.y)}(e.Clamp(E.specularPower,0,v));return{baseColorFactor:[U.r,U.g,U.b,g],metallicFactor:0,roughnessFactor:L}}function Z(E,U){U.needAlphaBlending()?E.alphaMode="BLEND":U.needAlphaTesting()&&(E.alphaMode="MASK",E.alphaCutoff=U.alphaCutOff)}function A(E,U,g){const N=new Uint8Array(E*U*4);for(let L=0;L<N.length;L+=4)N[L]=N[L+1]=N[L+2]=N[L+3]=255;return Y.e.CreateRGBATexture(N,E,U,g)}function w(E){if(E instanceof Uint8Array){const U=E.length,g=new Float32Array(E.length);for(let N=0;N<U;++N)g[N]=E[N]/255;return g}if(E instanceof Float32Array)return E;throw new Error("Unsupported pixel format!")}class a{constructor(E){this._exporter=E,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(E){return E?this._textureMap.get(E)??null:null}async exportStandardMaterialAsync(E,U,g){const N=j(E),D={name:E.name};if(null==E.fu||E.fu||(E.twoSidedLighting||L.Tools.Warn(E.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),D.doubleSided=!0),g){const g=[],L=E.diffuseTexture;L&&g.push(this.exportTextureAsync(L,U).then((E=>{E&&(N.baseColorTexture=E)})));const S=E.bumpTexture;S&&g.push(this.exportTextureAsync(S,U).then((E=>{E&&(D.normalTexture=E,1!==S.level&&(D.normalTexture.scale=S.level))})));const u=E.emissiveTexture;u&&(D.emissiveFactor=[1,1,1],g.push(this.exportTextureAsync(u,U).then((E=>{E&&(D.emissiveTexture=E)}))));const s=E.ambientTexture;s&&g.push(this.exportTextureAsync(s,U).then((E=>{if(E){const U={index:E.index};D.occlusionTexture=U}}))),g.length>0&&(this._exporter._materialNeedsUVsSet.add(E),await Promise.all(g))}(E.alpha<1||E.opacityTexture)&&(E.alphaMode===t.c.ALPHA_COMBINE?D.alphaMode="BLEND":L.Tools.Warn(E.name+": glTF 2.0 does not support alpha mode: "+E.alphaMode.toString())),E.emissiveColor&&!E.emissiveColor.equalsWithEpsilon(c,b)&&(D.emissiveFactor=E.emissiveColor.Og()),D.pbrMetallicRoughness=N,Z(D,E),await this._finishMaterialAsync(D,E,U);const S=this._exporter._materials;return S.push(D),S.length-1}async _finishMaterialAsync(E,U,g){const N=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",E,U),L=[];for(const D of N)L.push(this.exportTextureAsync(D,g));await Promise.all(L),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",E,U)}async _getImageDataAsync(E,U,N,L){const D=t.c.TEXTURETYPE_UNSIGNED_BYTE,S=this._exporter._babylonScene,u=S.getEngine(),s=u.createRawTexture(E,U,N,t.c.TEXTUREFORMAT_RGBA,!1,!0,l.c.NEAREST_SAMPLINGMODE,null,D);u.isWebGPU?await g.e(51).then(g.bind(g,14858)):await g.e(52).then(g.bind(g,14865)),await x.i.ApplyPostProcess("pass",s,S,D,t.c.TEXTURE_NEAREST_SAMPLINGMODE,t.c.TEXTUREFORMAT_RGBA);const C=await u._readTexturePixels(s,U,N);return await G.DumpTools.DumpDataAsync(U,N,C,L,void 0,!0,!0)}_resizeTexturesToSameDimensions(E,U,g){const N=E?E.getSize():{width:0,height:0},L=U?U.getSize():{width:0,height:0};let D,S;return N.width<L.width?(D=E&&E instanceof l.c?x.i.CreateResizedCopy(E,L.width,L.height,!0):A(L.width,L.height,g),S=U):N.width>L.width?(S=U&&U instanceof l.c?x.i.CreateResizedCopy(U,N.width,N.height,!0):A(N.width,N.height,g),D=E):(D=E,S=U),{texture1:D,texture2:S}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(E,U,g,N){const L=new Array;if(!E&&!U)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const D=E?E.tE():U?U.tE():null;if(D){var S;const u=this._resizeTexturesToSameDimensions(E,U,D),s=null===(S=u.texture1)||void 0===S?void 0:S.getSize();let C,B;const P=s.width,F=s.height,f=await u.texture1.readPixels(),d=await u.texture2.readPixels();if(!f)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(C=w(f),!d)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");B=w(d);const I=B.byteLength,h=new Uint8Array(I),V=new Uint8Array(I),e=4,x=c;let l=0,Y=0;for(let E=0;E<F;++E)for(let U=0;U<P;++U){const N=(P*E+U)*e,L={diffuseColor:new y.VU(C[N],C[N+1],C[N+2]).toLinearSpace(D.getEngine().useExactSrgbConversions).multiply(g.diffuseColor),specularColor:new y.VU(B[N],B[N+1],B[N+2]).toLinearSpace(D.getEngine().useExactSrgbConversions).multiply(g.specularColor),glossiness:B[N+3]*g.glossiness},S=this._convertSpecularGlossinessToMetallicRoughness(L);x.r=Math.max(x.r,S.baseColor.r),x.g=Math.max(x.g,S.baseColor.g),x.b=Math.max(x.b,S.baseColor.b),l=Math.max(l,S.metallic),Y=Math.max(Y,S.roughness),V[N]=255*S.baseColor.r,V[N+1]=255*S.baseColor.g,V[N+2]=255*S.baseColor.b,V[N+3]=u.texture1.Qg?255*C[N+3]:255,h[N]=0,h[N+1]=255*S.roughness,h[N+2]=255*S.metallic,h[N+3]=255}const t={baseColor:x,metallic:l,roughness:Y};let G=!1,T=!1;for(let E=0;E<F;++E)for(let U=0;U<P;++U){const g=(P*E+U)*e;V[g]/=t.baseColor.r>b?t.baseColor.r:1,V[g+1]/=t.baseColor.g>b?t.baseColor.g:1,V[g+2]/=t.baseColor.b>b?t.baseColor.b:1;const N=y.VU.FromInts(V[g],V[g+1],V[g+2]).toGammaSpace(D.getEngine().useExactSrgbConversions);V[g]=255*N.r,V[g+1]=255*N.g,V[g+2]=255*N.b,N.equalsWithEpsilon(o,b)||(T=!0),h[g+1]/=t.roughness>b?t.roughness:1,h[g+2]/=t.metallic>b?t.metallic:1;y.VU.FromInts(255,h[g+1],h[g+2]).equalsWithEpsilon(o,b)||(G=!0)}return G&&L.push(this._getImageDataAsync(h,P,F,N).then((E=>{t.metallicRoughnessTextureData=E}))),T&&L.push(this._getImageDataAsync(V,P,F,N).then((E=>{t.baseColorTextureData=E}))),await Promise.all(L).then((()=>t))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(E){const U=this._getPerceivedBrightness(E.diffuseColor),g=this._getPerceivedBrightness(E.specularColor),N=1-this._getMaxComponent(E.specularColor),L=r(U,g,N),D=E.diffuseColor.scale(N/(1-T.r)/Math.max(1-L)),S=E.specularColor.IU(T.scale(1-L)).scale(1/Math.max(L));let u=y.VU.Lerp(D,S,L*L);u=u.clampToRef(0,1,u);return{baseColor:u,metallic:L,roughness:1-E.glossiness}}_getPerceivedBrightness(E){return E?Math.sqrt(.299*E.r*E.r+.587*E.g*E.g+.114*E.b*E.b):0}_getMaxComponent(E){return E?Math.max(E.r,Math.max(E.g,E.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(E,U,g,N){const L=[],D={baseColor:E._albedoColor,metallic:E._metallic,roughness:E._roughness};if(N){E._albedoTexture&&L.push(this.exportTextureAsync(E._albedoTexture,U).then((E=>{E&&(g.baseColorTexture=E)})));const N=E._metallicTexture;N&&L.push(this.exportTextureAsync(N,U).then((E=>{E&&(g.metallicRoughnessTexture=E)})))}return L.length>0&&(this._exporter._materialNeedsUVsSet.add(E),await Promise.all(L)),D}_getTextureSampler(E){const U={};if(!E||!(E instanceof l.c))return U;const g=this._getGLTFTextureWrapMode(E.wrapU);10497!==g&&(U.wrapS=g);const N=this._getGLTFTextureWrapMode(E.wrapV);switch(10497!==N&&(U.wrapT=N),E.samplingMode){case l.c.LINEAR_LINEAR:U.magFilter=9729,U.minFilter=9729;break;case l.c.LINEAR_NEAREST:U.magFilter=9729,U.minFilter=9728;break;case l.c.NEAREST_LINEAR:U.magFilter=9728,U.minFilter=9729;break;case l.c.NEAREST_LINEAR_MIPLINEAR:U.magFilter=9728,U.minFilter=9987;break;case l.c.NEAREST_NEAREST:U.magFilter=9728,U.minFilter=9728;break;case l.c.NEAREST_LINEAR_MIPNEAREST:U.magFilter=9728,U.minFilter=9985;break;case l.c.LINEAR_NEAREST_MIPNEAREST:U.magFilter=9729,U.minFilter=9984;break;case l.c.LINEAR_NEAREST_MIPLINEAR:U.magFilter=9729,U.minFilter=9986;break;case l.c.NEAREST_NEAREST_MIPLINEAR:U.magFilter=9728,U.minFilter=9986;break;case l.c.LINEAR_LINEAR_MIPLINEAR:U.magFilter=9729,U.minFilter=9987;break;case l.c.LINEAR_LINEAR_MIPNEAREST:U.magFilter=9729,U.minFilter=9985;break;case l.c.NEAREST_NEAREST_MIPNEAREST:U.magFilter=9728,U.minFilter=9984}return U}_getGLTFTextureWrapMode(E){switch(E){case l.c.WRAP_ADDRESSMODE:return 10497;case l.c.CLAMP_ADDRESSMODE:return 33071;case l.c.MIRROR_ADDRESSMODE:return 33648;default:return L.Tools.Error(`Unsupported Texture Wrap Mode ${E}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(E,U,g,N){const L={diffuseColor:E._albedoColor,specularColor:E._reflectivityColor,glossiness:E._microSurface},D=E._albedoTexture,S=E._reflectivityTexture,u=E._useMicroSurfaceFromReflectivityMapAlpha;if(S&&!u)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((D||S)&&N){this._exporter._materialNeedsUVsSet.add(E);const N=this._exportTextureSampler(D||S),u=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(D,S,L,U),s=this._exporter._textures;if(u.baseColorTextureData){const E=this._exportImage(`baseColor${s.length}`,U,u.baseColorTextureData);g.baseColorTexture=this._exportTextureInfo(E,N,null===D||void 0===D?void 0:D.coordinatesIndex)}if(u.metallicRoughnessTextureData){const E=this._exportImage(`metallicRoughness${s.length}`,U,u.metallicRoughnessTextureData);g.metallicRoughnessTexture=this._exportTextureInfo(E,N,null===S||void 0===S?void 0:S.coordinatesIndex)}return u}return this._convertSpecularGlossinessToMetallicRoughness(L)}async exportPBRMaterialAsync(E,U,g){const N={},L={name:E.name},D=E.isMetallicWorkflow();if(D){const U=E._albedoColor,g=E.alpha;U&&(N.baseColorFactor=[U.r,U.g,U.b,g])}const S=D?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(E,U,N,g):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(E,U,N,g);await this._setMetallicRoughnessPbrMaterialAsync(S,E,L,N,U,g),await this._finishMaterialAsync(L,E,U);const u=this._exporter._materials;return u.push(L),u.length-1}async _setMetallicRoughnessPbrMaterialAsync(E,U,g,N,D,S){if(Z(g,U),E.baseColor.equalsWithEpsilon(o,b)&&e.WithinEpsilon(U.alpha,1,b)||(N.baseColorFactor=[E.baseColor.r,E.baseColor.g,E.baseColor.b,U.alpha]),null!=E.metallic&&1!==E.metallic&&(N.metallicFactor=E.metallic),null!=E.roughness&&1!==E.roughness&&(N.roughnessFactor=E.roughness),null==U.fu||U.fu||(U._twoSidedLighting||L.Tools.Warn(U.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),g.doubleSided=!0),S){const E=[],N=U._bumpTexture;N&&E.push(this.exportTextureAsync(N,D).then((E=>{E&&(g.normalTexture=E,1!==N.level&&(g.normalTexture.scale=N.level))})));const L=U._ambientTexture;L&&E.push(this.exportTextureAsync(L,D).then((E=>{if(E){const N={index:E.index,texCoord:E.texCoord,extensions:E.extensions};g.occlusionTexture=N;const L=U._ambientTextureStrength;L&&(N.strength=L)}})));const S=U._emissiveTexture;S&&E.push(this.exportTextureAsync(S,D).then((E=>{E&&(g.emissiveTexture=E)}))),E.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(E))}const u=U._emissiveColor;u.equalsWithEpsilon(c,b)||(g.emissiveFactor=u.Og()),g.pbrMetallicRoughness=N}_getPixelsFromTextureAsync(E){return function(E){switch(E){case t.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case t.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case t.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case t.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case t.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case t.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case t.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case t.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case t.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case t.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case t.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case t.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case t.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(E.textureFormat)?(0,x.f)(E,E._texture.width,E._texture.height):(E.textureType,t.c.TEXTURETYPE_UNSIGNED_BYTE,E.readPixels())}async exportTextureAsync(E,U){const g=this._exporter._extensionsPreExportTextureAsync("exporter",E,U);return g?await g.then((async g=>g?await this._exportTextureInfoAsync(g,U):await this._exportTextureInfoAsync(E,U))):await this._exportTextureInfoAsync(E,U)}async _exportTextureInfoAsync(E,U){let g=this._textureMap.get(E);if(!g){const N=await this._getPixelsFromTextureAsync(E);if(!N)return null;const D=this._exportTextureSampler(E),S=E.mimeType;if(S)switch(S){case"image/jpeg":case"image/png":case"image/webp":U=S;break;default:L.Tools.Warn(`Unsupported media type: ${S}. Exporting texture as PNG.`)}const u=this._internalTextureToImage,s=E.getInternalTexture().uniqueId;u[s]||(u[s]={});let C=u[s][U];if(void 0===C){const g=E.getSize();C=(async()=>{const L=await this._getImageDataAsync(N,g.width,g.height,U);return this._exportImage(E.name,U,L)})(),u[s][U]=C}g=this._exportTextureInfo(await C,D,E.coordinatesIndex),this._textureMap.set(E,g),this._exporter._extensionsPostExportTextures("exporter",g,E)}return g}_exportImage(E,U,g){const N=this._exporter._images;let D;if(this._exporter._shouldUseGlb){D={name:E,mimeType:U,bufferView:void 0};const N=this._exporter._bufferManager.createBufferView(new Uint8Array(g));this._exporter._bufferManager.setBufferView(D,N)}else{const S=E.replace(/\.\/|\/|\.\\|\\/g,"_"),u=function(E){switch(E){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(U);let s=S+u;N.some((E=>E.uri===s))&&(s=`${S}_${L.Tools.RandomId()}${u}`),D={name:E,uri:s},this._exporter._imageData[s]={data:g,mimeType:U}}return N.push(D),N.length-1}_exportTextureInfo(E,U,g){const N=this._exporter._textures;let L=N.findIndex((g=>g.sampler==U&&g.source===E));-1===L&&(L=N.length,N.push({source:E,sampler:U}));const D={index:L};return g&&(D.texCoord=g),D}_exportTextureSampler(E){const U=this._getTextureSampler(E),g=this._exporter._samplers,N=g.findIndex((E=>E.minFilter===U.minFilter&&E.magFilter===U.magFilter&&E.wrapS===U.wrapS&&E.wrapT===U.wrapT));return-1!==N?N:(g.push(U),g.length-1)}}var J=g(12418),q=g(12186),M=g(12822),mE=g(12336);const W=N.dU.Zero(),O=N.Quaternion.Identity(),Q=N.dU.One(),R=new N.dU(-1,1,1);function n(E,U){const{byteOffset:g,byteStride:N,type:L,normalized:D}=E,S=E.getSize(),u=U.reduce(((E,U)=>U.getTotalVertices()>E?U.getTotalVertices():E),-Number.MAX_VALUE);return{byteOffset:g,byteStride:N,componentCount:S,type:L,count:u*S,normalized:D,totalVertices:u,kind:E.getKind()}}function k(E){switch(E){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function z(E){switch(E){case B.f.PositionKind:case B.f.NormalKind:case B.f.TangentKind:case B.f.ColorKind:case B.f.MatricesIndicesKind:case B.f.MatricesIndicesExtraKind:case B.f.MatricesWeightsKind:case B.f.MatricesWeightsExtraKind:case B.f.UVKind:case B.f.UV2Kind:case B.f.UV3Kind:case B.f.UV4Kind:case B.f.UV5Kind:case B.f.UV6Kind:return!0}return!1}function i(E){switch(E){case D.b.TriangleFillMode:return 4;case D.b.TriangleStripDrawMode:return 5;case D.b.TriangleFanDrawMode:return 6;case D.b.PointListDrawMode:case D.b.PointFillMode:return 0;case D.b.LineLoopDrawMode:return 2;case D.b.LineListDrawMode:return 1;case D.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${E}`)}function p(E){const U=Math.sqrt(E.x*E.x+E.y*E.y+E.z*E.z);U>0&&(E.x/=U,E.y/=U,E.z/=U)}function H(E){return E.x*=-1,E}function K(E){if(E.x*E.x+E.y*E.y>.5){const U=Math.abs(E.x),g=Math.abs(E.y);if(U>g){const g=Math.sign(E.x);E.x=U,E.y*=-g,E.z*=-g,E.w*=g}else{const U=Math.sign(E.y);E.x*=-U,E.y=g,E.z*=U,E.w*=-U}}else{const U=Math.abs(E.z),g=Math.abs(E.w);if(U>g){const g=Math.sign(E.z);E.x*=-g,E.y*=g,E.z=U,E.w*=-g}else{const U=Math.sign(E.w);E.x*=U,E.y*=-U,E.z*=-U,E.w=g}}return E}function X(E){E.du(-E.z,E.w,E.x,-E.y)}function EE(E,U){const g=N.dU.FromArrayToRef(U.translation||[0,0,0],0,N.TmpVectors.dU[0]),L=N.Quaternion.FromArrayToRef(U.rotation||[0,0,0,1],0,N.TmpVectors.Quaternion[0]),D=N.Matrix.ComposeToRef(Q,L,g,N.TmpVectors.Matrix[0]),S=N.dU.FromArrayToRef(E.translation||[0,0,0],0,N.TmpVectors.dU[2]),u=N.Quaternion.FromArrayToRef(E.rotation||[0,0,0,1],0,N.TmpVectors.Quaternion[1]),s=N.Matrix.ComposeToRef(Q,u,S,N.TmpVectors.Matrix[1]);D.multiplyToRef(s,s),s.decompose(void 0,L,g),g.equalsWithEpsilon(W,mE.c)?delete U.translation:U.translation=g.Og(),L.equalsWithEpsilon(O,mE.c)?delete U.rotation:U.rotation=L.Og(),U.scale&&delete U.scale}function UE(E,U){if(!(U instanceof P.c))return!1;if(!(1===U.getChildren().length&&0===E.getChildren().length&&E.parent===U))return!1;const g=E.tE(),N=E instanceof M.d&&!g.useRightHandedSystem?R:Q;return!!U.Iu.equalsWithEpsilon(N,mE.c)||(q.d.Warn(`Cannot collapse node ${E.name} into parent node ${U.name} with modified scaling.`),!1)}function gE(E){if(E instanceof Array){const U=new Float32Array(E);return new Uint8Array(U.buffer,U.byteOffset,U.byteLength)}return ArrayBuffer.isView(E)?new Uint8Array(E.buffer,E.byteOffset,E.byteLength):new Uint8Array(E)}function NE(E,U){for(const[g,N]of Object.entries(E)){const L=U[g];(Array.isArray(N)&&Array.isArray(L)&&LE(N,L)||N===L)&&delete E[g]}return E}function LE(E,U){return E.length===U.length&&E.every(((E,g)=>E===U[g]))}const DE=N.Matrix.Compose(new N.dU(-1,1,1),N.Quaternion.Identity(),N.dU.Zero());function SE(E,U){if(!(E instanceof P.c))return!1;if(U){if(!E.getWorldMatrix().equalsWithEpsilon(N.Matrix.IdentityReadOnly,mE.c))return!1}else{if(!E.getWorldMatrix().multiplyToRef(DE,N.TmpVectors.Matrix[0]).equalsWithEpsilon(N.Matrix.IdentityReadOnly,mE.c))return!1}return!(E instanceof F.b&&E.XL)}const uE=new Map([[Int8Array,(E,U,g)=>E.setInt8(U,g)],[Uint8Array,(E,U,g)=>E.setUint8(U,g)],[Uint8ClampedArray,(E,U,g)=>E.setUint8(U,g)],[Int16Array,(E,U,g)=>E.setInt16(U,g,!0)],[Uint16Array,(E,U,g)=>E.setUint16(U,g,!0)],[Int32Array,(E,U,g)=>E.setInt32(U,g,!0)],[Uint32Array,(E,U,g)=>E.setUint32(U,g,!0)],[Float32Array,(E,U,g)=>E.setFloat32(U,g,!0)],[Float64Array,(E,U,g)=>E.setFloat64(U,g,!0)]]);class sE{writeTypedArray(E){this._checkGrowBuffer(E.byteLength);const U=uE.get(E.constructor);for(let g=0;g<E.length;g++)U(this._dataView,this._byteOffset,E[g]),this._byteOffset+=E.BYTES_PER_ELEMENT}constructor(E){this._data=new Uint8Array(E),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(E){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,E),this._byteOffset++}writeInt8(E){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,E),this._byteOffset++}writeInt16(E){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,E,!0),this._byteOffset+=2}writeUInt16(E){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,E,!0),this._byteOffset+=2}writeInt32(E){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,E,!0),this._byteOffset+=4}writeUInt32(E){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,E,!0),this._byteOffset+=4}writeFloat32(E){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,E,!0),this._byteOffset+=4}writeFloat64(E){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,E,!0),this._byteOffset+=8}_checkGrowBuffer(E){const U=this.byteOffset+E;if(U>this._data.byteLength){const E=new Uint8Array(2*U);E.set(this._data),this._data=E,this._dataView=new DataView(this._data.buffer)}}}function CE(E){return E%4===0?4:E%2===0?2:1}class BE{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(E){let U=0;this._bufferViewToData.forEach((E=>{U+=E.byteLength}));const g=new sE(U),N=Array.from(this._bufferViewToData.keys()).sort(((E,U)=>CE(U.byteLength)-CE(E.byteLength)));for(const L of N){L.byteOffset=g.byteOffset,E.push(L);const U=E.length-1,N=this.getPropertiesWithBufferView(L);for(const E of N)E.bufferView=U;g.writeTypedArray(this._bufferViewToData.get(L)),this._bufferViewToData.delete(L)}return g.getOutputData()}createBufferView(E,U){const g={buffer:0,byteOffset:void 0,byteLength:E.byteLength,byteStride:U};return this._bufferViewToData.set(g,E),g}createAccessor(E,U,g,N,L,D,S){this._verifyBufferView(E);const u={bufferView:void 0,componentType:g,count:N,type:U,min:null===D||void 0===D?void 0:D.min,max:null===D||void 0===D?void 0:D.max,normalized:S,byteOffset:L};return this.setBufferView(u,E),this._accessorToBufferView.set(u,E),u}setBufferView(E,U){this._verifyBufferView(U);this.getPropertiesWithBufferView(U).push(E)}removeBufferView(E){const U=this.getPropertiesWithBufferView(E);for(const g of U)void 0!==g.bufferView&&delete g.bufferView;this._bufferViewToData.delete(E),this._bufferViewToProperties.delete(E),this._accessorToBufferView.forEach(((U,g)=>{U===E&&(void 0!==g.byteOffset&&delete g.byteOffset,this._accessorToBufferView.delete(g))}))}getBufferView(E){const U=this._accessorToBufferView.get(E);return this._verifyBufferView(U),U}getPropertiesWithBufferView(E){return this._verifyBufferView(E),this._bufferViewToProperties.set(E,this._bufferViewToProperties.get(E)??[]),this._bufferViewToProperties.get(E)}getData(E){return this._verifyBufferView(E),this._bufferViewToData.get(E)}_verifyBufferView(E){if(void 0===E||!this._bufferViewToData.has(E))throw new Error(`BufferView ${E} not found in BufferManager.`)}}var PE,FE=g(12781),fE=g(12802),dE=g(12829),IE=g(12707),yE=g(12853),hE=g(12866),VE=g(12774),eE=g(12874);!function(E){E[E.INTANGENT=0]="INTANGENT",E[E.OUTTANGENT=1]="OUTTANGENT"}(PE||(PE={}));class xE{static _IsTransformable(E){return E&&(E instanceof P.c||E instanceof FE.d||E instanceof eE.c)}static _CreateNodeAnimation(E,U,g,N,D){if(this._IsTransformable(E)){const S=[],u=[],s=U.getKeys(),C=xE._CalculateMinMaxKeyFrames(s),B=xE._DeduceInterpolation(s,g,N),P=B.interpolationType,F=B.shouldBakeAnimation;if(F?xE._CreateBakedAnimation(E,U,g,C.min,C.max,U.framePerSecond,D,S,u,C,N):"LINEAR"===P||"STEP"===P?xE._CreateLinearOrStepAnimation(E,U,g,S,u,N):"CUBICSPLINE"===P?xE._CreateCubicSplineAnimation(E,U,g,S,u,N):xE._CreateBakedAnimation(E,U,g,C.min,C.max,U.framePerSecond,D,S,u,C,N),S.length&&u.length){return{inputs:S,outputs:u,samplerInterpolation:P,inputsMin:F?C.min:L.Tools.FloatRound(C.min/U.framePerSecond),inputsMax:F?C.max:L.Tools.FloatRound(C.max/U.framePerSecond)}}}return null}static _DeduceAnimationInfo(E){let U=null,g="VEC3",N=!1;const D=E.targetProperty.split(".");switch(D[0]){case"Iu":U="scale";break;case"position":U="translation";break;case"rotation":g="VEC4",U="rotation";break;case"rotationQuaternion":g="VEC4",N=!0,U="rotation";break;case"influence":g="SCALAR",U="weights";break;default:L.Tools.Error(`Unsupported animatable property ${D[0]}`)}return U?{animationChannelTargetPath:U,dataAccessorType:g,useQuaternion:N}:(L.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(E,U,g,N,L,D,S,u,s,C,B){let P;if(xE._IsTransformable(E)&&E.animations)for(const F of E.animations){if(B&&!B(F))continue;const L=xE._DeduceAnimationInfo(F);L&&(P={name:F.name,samplers:[],channels:[]},xE._AddAnimation(`${F.name}`,F.hasRunningRuntimeAnimations?U:P,E,F,L.dataAccessorType,L.animationChannelTargetPath,N,D,S,u,L.useQuaternion,s,C),P.samplers.length&&P.channels.length&&g.push(P))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(E,U,g,N,L,D,S,u,s,C,B){let P;if(E instanceof VE.e){const L=E.morphTargetManager;if(L)for(let F=0;F<L.numTargets;++F){const f=L.getTarget(F);for(const d of f.animations){if(B&&!B(d))continue;const f=new yE.c(`${d.name}`,"influence",d.framePerSecond,d.dataType,d.loopMode,d.enableBlending),I=[],y=d.getKeys();for(let E=0;E<y.length;++E){const U=y[E];for(let E=0;E<L.numTargets;++E)E==F?I.push(U):I.push({frame:U.frame,value:0})}f.setKeys(I);const h=xE._DeduceAnimationInfo(f);h&&(P={name:f.name,samplers:[],channels:[]},xE._AddAnimation(d.name,d.hasRunningRuntimeAnimations?U:P,E,f,h.dataAccessorType,h.animationChannelTargetPath,N,D,S,u,h.useQuaternion,s,C,L.numTargets),P.samplers.length&&P.channels.length&&g.push(P))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(E,U,g,N,L,D,S,u,s){let C;if(E.animationGroups){const P=E.animationGroups;for(const F of P){const P=new Map,f=new Map,d=new Set,I=F.to-F.from;C={name:F.name,channels:[],samplers:[]};for(let U=0;U<F.targetedAnimations.length;++U){const I=F.targetedAnimations[U],y=I.target,h=I.animation;if(s&&!s(h))continue;const V=u.has(y);if(this._IsTransformable(y)||1===y.length&&this._IsTransformable(y[0])){const E=xE._DeduceAnimationInfo(I.animation);if(E){const U=this._IsTransformable(y)?y:this._IsTransformable(y[0])?y[0]:null;U&&xE._AddAnimation(`${h.name}`,C,U,h,E.dataAccessorType,E.animationChannelTargetPath,g,N,L,D,E.useQuaternion,S,V)}}else if(y instanceof hE.c||1===y.length&&y[0]instanceof hE.c){if(xE._DeduceAnimationInfo(I.animation)){const U=y instanceof hE.c?y:y[0];if(U){const g=E.morphTargetManagers.find((E=>{for(let g=0;g<E.numTargets;++g)if(E.getTarget(g)===U)return!0;return!1}));if(g){const N=E.meshes.find((E=>E.morphTargetManager===g));var B;if(N)P.has(N)||P.set(N,new Map),null===(B=P.get(N))||void 0===B||B.set(U,h),d.add(N),f.set(N,h)}}}}}d.forEach((E=>{const U=E.morphTargetManager;let u=null;const s=[],B=f.get(E).getKeys(),d=B.length;for(let g=0;g<d;++g)for(let N=0;N<U.numTargets;++N){const L=U.getTarget(N),D=P.get(E);if(D){const U=D.get(L);U?(u||(u=new yE.c(`${F.name}_${E.name}_MorphWeightAnimation`,"influence",U.framePerSecond,yE.c.ANIMATIONTYPE_FLOAT,U.loopMode,U.enableBlending)),s.push(U.getKeys()[g])):s.push({frame:F.from+I/d*g,value:L.influence,inTangent:B[0].inTangent?0:void 0,outTangent:B[0].outTangent?0:void 0})}}u.setKeys(s);const y=xE._DeduceAnimationInfo(u);y&&xE._AddAnimation(`${F.name}_${E.name}_MorphWeightAnimation`,C,E,u,y.dataAccessorType,y.animationChannelTargetPath,g,N,L,D,y.useQuaternion,S,!1,null===U||void 0===U?void 0:U.numTargets)})),C.channels.length&&C.samplers.length&&U.push(C)}}}static _AddAnimation(E,U,g,L,D,S,u,s,C,B,P,F,f,d){const I=xE._CreateNodeAnimation(g,L,S,P,F);let y,h,V,e,x,l;if(I){if(d){let E=0,U=0;const g=[];for(;I.inputs.length>0;)U=I.inputs.shift(),E%d==0&&g.push(U),E++;I.inputs=g}const E=u.get(g),L=new Float32Array(I.inputs);y=s.createBufferView(L),h=s.createAccessor(y,"SCALAR",5126,I.inputs.length,void 0,{min:[I.inputsMin],max:[I.inputsMax]}),B.push(h),V=B.length-1;const C=new N.Quaternion,P=new N.dU,F=new N.dU,Y=g instanceof FE.d,t=k(D),G=new Float32Array(I.outputs.length*t);I.outputs.forEach((function(E,U){let g=E;switch(S){case"translation":f&&(N.dU.FromArrayToRef(E,0,F),H(F),F.toArray(g));break;case"rotation":4===E.length?N.Quaternion.FromArrayToRef(E,0,C):(g=new Array(4),N.dU.FromArrayToRef(E,0,P),N.Quaternion.FromEulerVectorToRef(P,C)),f&&(K(C),Y&&X(C)),C.toArray(g)}G.set(g,U*t)})),y=s.createBufferView(G),h=s.createAccessor(y,D,5126,I.outputs.length),B.push(h),e=B.length-1,x={interpolation:I.samplerInterpolation,input:V,output:e},U.samplers.push(x),l={sampler:U.samplers.length-1,target:{node:E,path:S}},U.channels.push(l)}}static _CreateBakedAnimation(E,U,g,D,S,u,s,C,B,P,F){let f;const d=N.Quaternion.Identity();let I,y=null,h=null,V=null,e=null,x=null,l=null;P.min=L.Tools.FloatRound(D/u);const Y=U.getKeys();for(let N=0,t=Y.length;N<t;++N){if(l=null,V=Y[N],N+1<t)if(e=Y[N+1],V.value.equals&&V.value.equals(e.value)||V.value===e.value){if(0!==N)continue;l=V.frame}else l=e.frame;else{if(x=Y[N-1],V.value.equals&&V.value.equals(x.value)||V.value===x.value)continue;l=S}if(l)for(let N=V.frame;N<=l;N+=s){if(I=L.Tools.FloatRound(N/u),I===y)continue;y=I,h=I;const D={key:0,repeatCount:0,loopMode:U.loopMode};f=U._interpolate(N,D),xE._SetInterpolatedValue(E,f,I,U,g,d,C,B,F)}}h&&(P.max=h)}static _ConvertFactorToVector3OrQuaternion(E,U,g,D,S){const u=xE._GetBasePositionRotationOrScale(U,D,S),s=g.targetProperty.split("."),C=s?s[1]:"",B=S?N.Quaternion.eU(u).normalize():N.dU.eU(u);switch(C){case"x":case"y":case"z":B[C]=E;break;case"w":B.w=E;break;default:L.Tools.Error(`glTFAnimation: Unsupported component name "${C}"!`)}return B}static _SetInterpolatedValue(E,U,g,L,D,S,u,s,C){let B;u.push(g),"weights"!==D?(L.dataType===yE.c.ANIMATIONTYPE_FLOAT&&(U=this._ConvertFactorToVector3OrQuaternion(U,E,L,D,C)),"rotation"===D?(C?S=U:(B=U,N.Quaternion.RotationYawPitchRollToRef(B.y,B.x,B.z,S)),s.push(S.Og())):(B=U,s.push(B.Og()))):s.push([U])}static _CreateLinearOrStepAnimation(E,U,g,N,L,D){for(const S of U.getKeys())N.push(S.frame/U.framePerSecond),xE._AddKeyframeValue(S,U,L,g,E,D)}static _CreateCubicSplineAnimation(E,U,g,N,L,D){U.getKeys().forEach((function(S){N.push(S.frame/U.framePerSecond),xE._AddSplineTangent(PE.INTANGENT,L,g,"CUBICSPLINE",S,D),xE._AddKeyframeValue(S,U,L,g,E,D),xE._AddSplineTangent(PE.OUTTANGENT,L,g,"CUBICSPLINE",S,D)}))}static _GetBasePositionRotationOrScale(E,U,g){let L;if("rotation"===U)if(g){L=(E.rotationQuaternion??N.Quaternion.Identity()).Og()}else{L=(E.rotation??N.dU.Zero()).Og()}else if("translation"===U){L=(E.position??N.dU.Zero()).Og()}else{L=(E.Iu??N.dU.One()).Og()}return L}static _AddKeyframeValue(E,U,g,D,S,u){let s;const C=U.dataType;if(C===yE.c.ANIMATIONTYPE_VECTOR3){let U=E.value.Og();if("rotation"===D){const E=N.dU.eU(U);U=N.Quaternion.RotationYawPitchRoll(E.y,E.x,E.z).Og()}g.push(U)}else if(C===yE.c.ANIMATIONTYPE_FLOAT){if("weights"===D)g.push([E.value]);else if(s=this._ConvertFactorToVector3OrQuaternion(E.value,S,U,D,u),s){if("rotation"===D){const E=u?s:N.Quaternion.RotationYawPitchRoll(s.y,s.x,s.z).normalize();g.push(E.Og())}g.push(s.Og())}}else C===yE.c.ANIMATIONTYPE_QUATERNION?g.push(E.value.normalize().Og()):L.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(E,U,g){let N,L,D=!1;if("rotation"===U&&!g)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let S=0,u=E.length;S<u;++S)if(L=E[S],L.inTangent||L.outTangent)if(N){if("CUBICSPLINE"!==N){N="LINEAR",D=!0;break}}else N="CUBICSPLINE";else if(N){if("CUBICSPLINE"===N||L.interpolation&&1===L.interpolation&&"STEP"!==N){N="LINEAR",D=!0;break}}else N=L.interpolation&&1===L.interpolation?"STEP":"LINEAR";return N||(N="LINEAR"),{interpolationType:N,shouldBakeAnimation:D}}static _AddSplineTangent(E,U,g,L,D,S){let u;const s=E===PE.INTANGENT?D.inTangent:D.outTangent;if("CUBICSPLINE"===L){if("rotation"===g)if(s)if(S)u=s.Og();else{const E=s;u=N.Quaternion.RotationYawPitchRoll(E.y,E.x,E.z).Og()}else u=[0,0,0,0];else u="weights"===g?s?[s]:[0]:s?s.Og():[0,0,0];U.push(u)}}static _CalculateMinMaxKeyFrames(E){let U=1/0,g=-1/0;return E.forEach((function(E){U=Math.min(U,E.frame),g=Math.max(g,E.frame)})),{min:U,max:g}}}function lE(E,U,g,D,S,u){const s={attributes:{},influence:E.influence,name:E.name},C=U.XL;if(!C)return L.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),s;const P=u?-1:1,F=N.dU.Zero();let f=0,d=0;if(E.hasPositions){const D=E.getPositions(),u=C.getVerticesData(B.f.PositionKind);if(u){const E=new Float32Array(u.length),U=[1/0,1/0,1/0],L=[-1/0,-1/0,-1/0];d=u.length/3,f=0;for(let g=f;g<d;++g){const S=N.dU.eU(u,3*g);N.dU.eU(D,3*g).subtractToRef(S,F),F.x*=P,U[0]=Math.min(U[0],F.x),L[0]=Math.max(L[0],F.x),U[1]=Math.min(U[1],F.y),L[1]=Math.max(L[1],F.y),U[2]=Math.min(U[2],F.z),L[2]=Math.max(L[2],F.z),E[3*g]=F.x,E[3*g+1]=F.y,E[3*g+2]=F.z}const C=g.createBufferView(E,12),B=g.createAccessor(C,"VEC3",5126,D.length/3,0,{min:U,max:L});S.push(B),s.attributes.POSITION=S.length-1}else L.Tools.Warn(`Morph target positions for mesh ${U.name} were not exported. Mesh does not have position vertex data`)}if(E.hasNormals){const D=E.getNormals(),u=C.getVerticesData(B.f.NormalKind);if(u){const E=new Float32Array(u.length);d=u.length/3,f=0;for(let g=f;g<d;++g){const U=N.dU.eU(u,3*g).normalize();N.dU.eU(D,3*g).normalize().subtractToRef(U,F),E[3*g]=F.x*P,E[3*g+1]=F.y,E[3*g+2]=F.z}const U=g.createBufferView(E,12),L=g.createAccessor(U,"VEC3",5126,D.length/3,0);S.push(L),s.attributes.NORMAL=S.length-1}else L.Tools.Warn(`Morph target normals for mesh ${U.name} were not exported. Mesh does not have normals vertex data`)}if(E.hasTangents){const D=E.getTangents(),u=C.getVerticesData(B.f.TangentKind);if(u){d=u.length/4;const E=new Float32Array(3*d);f=0;for(let g=f;g<d;++g){const U=N.dU.eU(u,4*g);p(U);const L=N.dU.eU(D,3*g);p(L),L.subtractToRef(U,F),E[3*g]=F.x*P,E[3*g+1]=F.y,E[3*g+2]=F.z}const U=g.createBufferView(E,12),L=g.createAccessor(U,"VEC3",5126,d,0);S.push(L),s.attributes.TANGENT=S.length-1}else L.Tools.Warn(`Morph target tangents for mesh ${U.name} were not exported. Mesh does not have tangents vertex data`)}if(E.hasColors){const D=E.getColors(),u=C.getVerticesData(B.f.ColorKind),P=C.getVertexBuffer(B.f.ColorKind);if(u&&P){const E=P.getSize();d=u.length/E;const U=new Float32Array(d*E);f=0;for(let g=f;g<d;++g)if(3===E){const L=N.dU.eU(u,g*E);N.dU.eU(D,g*E).subtractToRef(L,F),U[3*g]=F.x,U[3*g+1]=F.y,U[3*g+2]=F.z}else if(4===E){const L=new N.Vector4,S=N.Vector4.eU(u,g*E);N.Vector4.eU(D,g*E).subtractToRef(S,L),U[4*g]=L.x,U[4*g+1]=L.y,U[4*g+2]=L.z,U[4*g+3]=L.w}else L.Tools.Warn(`Unsupported number of components for color attribute: ${E}`);const C=g.createBufferView(U,4*E),B=g.createAccessor(C,3===E?"VEC3":"VEC4",5126,d,0);S.push(B),s.attributes.COLOR_0=S.length-1}else L.Tools.Warn(`Morph target colors for mesh ${U.name} were not exported. Mesh does not have colors vertex data`)}return s}var YE=g(12877),tE=g(12733),GE=g(12721),bE=g(12292);class TE{}TE.DEFAULT_COLOR=y.VU.White(),TE.DEFAULT_WIDTH_ATTENUATED=1,TE.DEFAULT_WIDTH=.1;var vE=g(12542),oE=g(12879);class cE{static ConvertPoints(E,U){if(E.length&&Array.isArray(E)&&"number"===typeof E[0])return[E];if(E.length&&Array.isArray(E[0])&&"number"===typeof E[0][0])return E;if(E.length&&!Array.isArray(E[0])&&E[0]instanceof N.dU){const U=[];for(let g=0;g<E.length;g++){const N=E[g];U.push(N.x,N.y,N.z)}return[U]}if(E.length>0&&Array.isArray(E[0])&&E[0].length>0&&E[0][0]instanceof N.dU){const U=[],g=E;for(const E of g)U.push(E.flatMap((E=>[E.x,E.y,E.z])));return U}if(E instanceof Float32Array){if(null!==U&&void 0!==U&&U.floatArrayStride){const g=[],N=3*U.floatArrayStride;for(let U=0;U<E.length;U+=N){const L=new Array(N);for(let g=0;g<N;g++)L[g]=E[U+g];g.push(L)}return g}return[Array.from(E)]}if(E.length&&E[0]instanceof Float32Array){const U=[];for(const g of E)U.push(Array.from(g));return U}return[]}static OmitZeroLengthPredicate(E,U,g){const N=[];return U.IU(E).lengthSquared()>0&&N.push([E,U]),g.IU(U).lengthSquared()>0&&N.push([U,g]),E.IU(g).lengthSquared()>0&&N.push([g,E]),0===N.length?null:N}static OmitDuplicatesPredicate(E,U,g,N){const L=[];return cE._SearchInPoints(E,U,N)||L.push([E,U]),cE._SearchInPoints(U,g,N)||L.push([U,g]),cE._SearchInPoints(g,E,N)||L.push([g,E]),0===L.length?null:L}static _SearchInPoints(E,U,g){for(const S of g)for(let g=0;g<S.length;g++){var N,L,D;if(null!==(N=S[g])&&void 0!==N&&N.equals(E))if(null!==(L=S[g+1])&&void 0!==L&&L.equals(U)||null!==(D=S[g-1])&&void 0!==D&&D.equals(U))return!0}return!1}static MeshesToLines(E,U){const g=[];for(let L=0;L<E.length;L++){const D=E[L],S=D.getVerticesData(B.f.PositionKind),u=D.CD();if(S&&u)for(let E=0,s=0;E<u.length;E++){const C=3*u[s++],B=3*u[s++],P=3*u[s++],F=new N.dU(S[C],S[C+1],S[C+2]),f=new N.dU(S[B],S[B+1],S[B+2]),d=new N.dU(S[P],S[P+1],S[P+2]);if(U){const N=U(F,f,d,g,E,C,D,L,S,u);if(N)for(const E of N)g.push(E)}else g.push([F,f],[f,d],[d,F])}}return g}static ToVector3Array(E){if(Array.isArray(E[0])){const U=[],g=E;for(const E of g){const g=[];for(let U=0;U<E.length;U+=3)g.push(new N.dU(E[U],E[U+1],E[U+2]));U.push(g)}return U}const U=E,g=[];for(let L=0;L<U.length;L+=3)g.push(new N.dU(U[L],U[L+1],U[L+2]));return g}static ToNumberArray(E){return E.flatMap((E=>[E.x,E.y,E.z]))}static GetPointsCountInfo(E){const U=new Array(E.length);let g=0;for(let N=E.length;N--;)U[N]=E[N].length/3,g+=U[N];return{total:g,counts:U}}static GetLineLength(E){if(0===E.length)return 0;let U;U="number"===typeof E[0]?cE.ToVector3Array(E):E;const g=N.TmpVectors.dU[0];let L=0;for(let N=0;N<U.length-1;N++){const E=U[N];L+=U[N+1].subtractToRef(E,g).length()}return L}static GetLineLengthArray(E){const U=new Float32Array(E.length/3);let g=0;for(let N=0,L=E.length/3-1;N<L;N++){let L=E[3*N+0],D=E[3*N+1],S=E[3*N+2];L-=E[3*N+3],D-=E[3*N+4],S-=E[3*N+5];g+=Math.sqrt(L*L+D*D+S*S),U[N+1]=g}return U}static SegmentizeSegmentByCount(E,U,g){const L=[],D=U.IU(E),S=N.TmpVectors.dU[0];S.yu(g);const u=N.TmpVectors.dU[1];D.divideToRef(S,u);let s=E.clone();L.push(s);for(let N=0;N<g;N++)s=s.clone(),L.push(s.addInPlace(u));return L}static SegmentizeLineBySegmentLength(E,U){const g=E[0]instanceof N.dU?cE.GetLineSegments(E):"number"===typeof E[0]?cE.GetLineSegments(cE.ToVector3Array(E)):E,L=[];for(const N of g)if(N.length>U){const E=cE.SegmentizeSegmentByCount(N.point1,N.point2,Math.ceil(N.length/U));for(const U of E)L.push(U)}else L.push(N.point1),L.push(N.point2);return L}static SegmentizeLineBySegmentCount(E,U){const g="number"===typeof E[0]?cE.ToVector3Array(E):E,N=cE.GetLineLength(g)/U;return cE.SegmentizeLineBySegmentLength(g,N)}static GetLineSegments(E){const U=[];for(let g=0;g<E.length-1;g++){const N=E[g],L=E[g+1],D=L.IU(N).length();U.push({point1:N,point2:L,length:D})}return U}static GetMinMaxSegmentLength(E){const U=cE.GetLineSegments(E).sort((E=>E.length));return{min:U[0].length,max:U[U.length-1].length}}static GetPositionOnLineByVisibility(E,U,g){let L=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const D=U*g;let S=0,u=0;const s=E.length;for(let N=0;N<s;N++){if(D<=S+E[N].length){u=N;break}S+=E[N].length}const C=(D-S)/E[u].length;return E[u].point2.subtractToRef(E[u].point1,N.TmpVectors.dU[0]),N.TmpVectors.dU[1]=N.TmpVectors.dU[0].multiplyByFloats(C,C,C),L||N.TmpVectors.dU[1].addInPlace(E[u].point1),N.TmpVectors.dU[1].clone()}static GetCircleLinePoints(E,U){let g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:E,D=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/U;const S=[];for(let u=0;u<=U;u++)S.push(new N.dU(Math.cos(u*D)*E,Math.sin(u*D)*L,g));return S}static GetBezierLinePoints(E,U,g,N){return vE.f.CreateQuadraticBezier(E,U,g,N).getPoints().flatMap((E=>[E.x,E.y,E.z]))}static GetArrowCap(E,U,g,N,L){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,S=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[E.clone(),E.add(U.multiplyByFloats(g,g,g))],widths:[N,L,D,S]}}static GetPointsFromText(E,U,g,N){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,D=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const S=[],u=(0,oE.d)(E,U,g,N);for(const s of u){for(const E of s.paths){const U=[],g=E.getPoints();for(const E of g)U.push(E.x,E.y,L);S.push(U)}if(D)for(const E of s.holes){const U=[],g=E.getPoints();for(const E of g)U.push(E.x,E.y,L);S.push(U)}}return S}static Color3toRGBAUint8(E){const U=new Uint8Array(4*E.length);for(let g=0,N=0;g<E.length;g++)U[N++]=255*E[g].r,U[N++]=255*E[g].g,U[N++]=255*E[g].b,U[N++]=255;return U}static CreateColorsTexture(E,U,g,N){const L=N.getEngine().getCaps().maxTextureSize??1,D=U.length>L?L:U.length,S=Math.ceil(U.length/L);S>1&&(U=[...U,...Array(D*S-U.length).fill(U[0])]);const u=cE.Color3toRGBAUint8(U),s=new Y.e(u,D,S,d.c.TEXTUREFORMAT_RGBA,N,!1,!0,g);return s.name=E,s}static PrepareEmptyColorsTexture(E){if(!TE.EmptyColorsTexture){const U=new Uint8Array(4);TE.EmptyColorsTexture=new Y.e(U,1,1,d.c.TEXTUREFORMAT_RGBA,E,!1,!1,Y.e.NEAREST_NEAREST),TE.EmptyColorsTexture.name="grlEmptyColorsTexture"}return TE.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var E;null===(E=TE.EmptyColorsTexture)||void 0===E||E.dispose(),TE.EmptyColorsTexture=null}static BooleanToNumber(E){return E?1:0}}class rE extends GE.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class jE extends tE.d{isCompatible(E){return!0}constructor(E,U,g){var L;g=g||{color:TE.DEFAULT_COLOR};const D=new rE;D.GREASED_LINE_HAS_COLOR=!!g.color&&!g.useColors,D.GREASED_LINE_SIZE_ATTENUATION=g.sizeAttenuation??!1,D.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===g.colorDistributionType,D.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(U??E.tE()).useRightHandedSystem,D.GREASED_LINE_CAMERA_FACING=g.cameraFacing??!0,super(E,jE.GREASED_LINE_MATERIAL_NAME,200,D,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(L=g)||void 0===L?void 0:L.forceGLSL)||jE.ForceGLSL,this._scene=U??E.tE(),this._engine=this._scene.getEngine(),this._cameraFacing=g.cameraFacing??!0,this.visibility=g.visibility??1,this.useDash=g.useDash??!1,this.dashRatio=g.dashRatio??.5,this.dashOffset=g.dashOffset??0,this.width=g.width?g.width:g.sizeAttenuation?TE.DEFAULT_WIDTH_ATTENUATED:TE.DEFAULT_WIDTH,this._sizeAttenuation=g.sizeAttenuation??!1,this.colorMode=g.colorMode??0,this._color=g.color??null,this.useColors=g.useColors??!1,this._colorsDistributionType=g.colorDistributionType??0,this.colorsSampling=g.colorsSampling??Y.e.NEAREST_NEAREST,this._colors=g.vE??null,this.dashCount=g.dashCount??1,this.resolution=g.resolution??new N.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),g.colorsTexture?this.colorsTexture=g.colorsTexture:this._colors?this.colorsTexture=cE.CreateColorsTexture(`${E.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??TE.DEFAULT_COLOR,cE.PrepareEmptyColorsTexture(this._scene)),this._engine.hg.add((()=>{cE.DisposeEmptyColorsTexture()}))}getAttributes(E){E.push("grl_offsets"),E.push("grl_widths"),E.push("grl_colorPointers"),E.push("grl_counters"),this._cameraFacing?(E.push("grl_previousAndSide"),E.push("grl_nextAndCounters")):E.push("grl_slopes")}getSamplers(E){E.push("grl_colors")}getActiveTextures(E){this.colorsTexture&&E.push(this.colorsTexture)}getUniforms(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const U=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&U.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===E&&U.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:U,vertex:this._cameraFacing&&this._isGLSL(E)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(E)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(E){if(this._cameraFacing){E.zg("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||E.zg("viewProjection",this._scene.getTransformMatrix());const U=N.TmpVectors.Vector4[0];U.x=this._aspect,U.y=this._resolution.x,U.z=this._resolution.y,U.w=this.width,E.updateVector4("grl_aspect_resolution_lineWidth",U)}const U=N.TmpVectors.Vector4[0];U.x=cE.BooleanToNumber(this.useDash),U.y=this._dashArray,U.z=this.dashOffset,U.w=this.dashRatio,E.updateVector4("grl_dashOptions",U);const g=N.TmpVectors.Vector4[1];g.x=this.colorMode,g.y=this.visibility,g.z=this.colorsTexture?this.colorsTexture.getSize().width:0,g.w=cE.BooleanToNumber(this.useColors),E.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",g),this._color&&E.updateColor3("grl_singleColor",this._color);const L=this.colorsTexture??TE.EmptyColorsTexture;E.setTexture("grl_colors",L),E.updateFloat2("grl_textureSize",(null===L||void 0===L?void 0:L.getSize().width)??1,(null===L||void 0===L?void 0:L.getSize().height)??1)}prepareDefines(E,U,g){E.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,E.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,E.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,E.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=U.useRightHandedSystem,E.GREASED_LINE_CAMERA_FACING=this._cameraFacing,E.GREASED_LINE_USE_OFFSETS=!!g.offsets}getClassName(){return jE.GREASED_LINE_MATERIAL_NAME}getCustomCode(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(U)?function(E,U){if("vertex"===E){const E={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return U&&(E["!gl_Position\\=viewProjection\\*worldPos;"]="//"),E}return"fragment"===E?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(E,this._cameraFacing):function(E,U){if("vertex"===E){const E={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return U&&(E["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),E}return"fragment"===E?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(E,this._cameraFacing)}dispose(){var E;null===(E=this.colorsTexture)||void 0===E||E.dispose(),super.dispose()}get vE(){return this._colors}set vE(E){this.setColors(E)}setColors(E){var U;let g=arguments.length>1&&void 0!==arguments[1]&&arguments[1],N=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const L=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var D;if(this._colors=E,null!==E&&0!==E.length){if(!g||N)if(this.colorsTexture&&L===E.length&&!N){const U=cE.Color3toRGBAUint8(E);this.colorsTexture.update(U)}else{var S;null===(S=this.colorsTexture)||void 0===S||S.dispose(),this.colorsTexture=cE.CreateColorsTexture(`${this._material.name}-colors-texture`,E,this.colorsSampling,this._scene)}}else null===(D=this.colorsTexture)||void 0===D||D.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(E){this._dashCount=E,this._dashArray=1/E}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(E){this._sizeAttenuation=E,this.markAllDefinesAsDirty()}get color(){return this._color}set color(E){this.setColor(E)}setColor(E){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==E||null!==this._color&&null===E?(this._color=E,U||this.markAllDefinesAsDirty()):this._color=E}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(E){this._colorsDistributionType=E,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(E){this._aspect=E.x/E.y,this._resolution=E}serialize(){const E=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(U.vE=this._colors),this._color&&(U.color=this._color),E.greasedLineMaterialOptions=U,E}parse(E,U,g){var N;super.parse(E,U,g);const L=E.greasedLineMaterialOptions;null===(N=this.colorsTexture)||void 0===N||N.dispose(),L.color&&this.setColor(L.color,!0),L.colorDistributionType&&(this.colorsDistributionType=L.colorDistributionType),L.vE&&(this.vE=L.vE),L.colorsSampling&&(this.colorsSampling=L.colorsSampling),L.colorMode&&(this.colorMode=L.colorMode),L.useColors&&(this.useColors=L.useColors),L.visibility&&(this.visibility=L.visibility),L.useDash&&(this.useDash=L.useDash),L.dashCount&&(this.dashCount=L.dashCount),L.dashRatio&&(this.dashRatio=L.dashRatio),L.dashOffset&&(this.dashOffset=L.dashOffset),L.width&&(this.width=L.width),L.sizeAttenuation&&(this.sizeAttenuation=L.sizeAttenuation),L.resolution&&(this.resolution=L.resolution),this.vE?this.colorsTexture=cE.CreateColorsTexture(`${this._material.name}-colors-texture`,this.vE,this.colorsSampling,U):cE.PrepareEmptyColorsTexture(U),this.markAllDefinesAsDirty()}copyTo(E){var U;const g=E;null===(U=g.colorsTexture)||void 0===U||U.dispose(),this._colors&&(g.colorsTexture=cE.CreateColorsTexture(`${g._material.name}-colors-texture`,this._colors,g.colorsSampling,this._scene)),g.setColor(this.color,!0),g.colorsDistributionType=this.colorsDistributionType,g.colorsSampling=this.colorsSampling,g.colorMode=this.colorMode,g.useColors=this.useColors,g.visibility=this.visibility,g.useDash=this.useDash,g.dashCount=this.dashCount,g.dashRatio=this.dashRatio,g.dashOffset=this.dashOffset,g.width=this.width,g.sizeAttenuation=this.sizeAttenuation,g.resolution=this.resolution,g.markAllDefinesAsDirty()}_isGLSL(E){return 0===E||this._forceGLSL}}jE.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",jE.ForceGLSL=!1,(0,bE.f)(`BABYLON.${jE.GREASED_LINE_MATERIAL_NAME}`,jE);var ZE=g(12764),AE=g(12188),wE=g(12565),aE=g(12280);class JE extends wE.ShaderMaterial{constructor(E,U,L){const D=U.getEngine(),S=D.isWebGPU&&!(L.forceGLSL||JE.ForceGLSL),u=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];U.useRightHandedSystem&&u.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const s=["position","grl_widths","grl_offsets","grl_colorPointers"];L.cameraFacing?(u.push("GREASED_LINE_CAMERA_FACING"),s.push("grl_previousAndSide","grl_nextAndCounters")):(s.push("grl_slopes"),s.push("grl_counters"));const C=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(S||C.push("world","viewProjection","view","projection"),super(E,U,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:S?["Scene","Mesh"]:void 0,attributes:s,uniforms:C,samplers:S?[]:["grlColors"],defines:u,extraInitializationsAsync:async()=>{S?await Promise.all([g.e(66).then(g.bind(g,15509)),g.e(75).then(g.bind(g,15517))]):await Promise.all([g.e(69).then(g.bind(g,15519)),g.e(76).then(g.bind(g,15524))])},shaderLanguage:S?1:0}),this._color=y.VU.White(),this._colorsDistributionType=0,this._colorsTexture=null,L=L||{color:TE.DEFAULT_COLOR},this.visibility=L.visibility??1,this.useDash=L.useDash??!1,this.dashRatio=L.dashRatio??.5,this.dashOffset=L.dashOffset??0,this.dashCount=L.dashCount??1,this.width=L.width?L.width:L.sizeAttenuation&&L.cameraFacing?TE.DEFAULT_WIDTH_ATTENUATED:TE.DEFAULT_WIDTH,this.sizeAttenuation=L.sizeAttenuation??!1,this.color=L.color??y.VU.White(),this.useColors=L.useColors??!1,this.colorsDistributionType=L.colorDistributionType??0,this.colorsSampling=L.colorsSampling??Y.e.NEAREST_NEAREST,this.colorMode=L.colorMode??0,this._colors=L.vE??null,this._cameraFacing=L.cameraFacing??!0,this.resolution=L.resolution??new N.Vector2(D.getRenderWidth(),D.getRenderHeight()),L.colorsTexture?this.colorsTexture=L.colorsTexture:this._colors?this.colorsTexture=cE.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,U):(this._color=this._color??TE.DEFAULT_COLOR,this.colorsTexture=cE.PrepareEmptyColorsTexture(U)),S){const E=new aE.c;E.setParameters(),E.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",E)}D.hg.add((()=>{cE.DisposeEmptyColorsTexture()}))}dispose(){var E;null===(E=this._colorsTexture)||void 0===E||E.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new N.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get vE(){return this._colors}set vE(E){this.setColors(E)}setColors(E){var U;let g=arguments.length>1&&void 0!==arguments[1]&&arguments[1],N=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const L=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var D;if(this._colors=E,null!==E&&0!==E.length){if(!g||N)if(this._colorsTexture&&L===E.length&&!N){const U=cE.Color3toRGBAUint8(E);this._colorsTexture.update(U)}else{var S;null===(S=this._colorsTexture)||void 0===S||S.dispose(),this.colorsTexture=cE.CreateColorsTexture(`${this.name}-colors-texture`,E,this.colorsSampling,this.tE())}}else null===(D=this._colorsTexture)||void 0===D||D.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(E){this._colorsTexture=E,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(E){this._width=E,this.setFloat("grlWidth",E)}get useColors(){return this._useColors}set useColors(E){this._useColors=E,this.setFloat("grlUseColors",cE.BooleanToNumber(E))}get colorsSampling(){return this._colorsSampling}set colorsSampling(E){this._colorsSampling=E}get visibility(){return this._visibility}set visibility(E){this._visibility=E,this.setFloat("grlVisibility",E)}get useDash(){return this._useDash}set useDash(E){this._useDash=E,this.setFloat("grlUseDash",cE.BooleanToNumber(E))}get dashOffset(){return this._dashOffset}set dashOffset(E){this._dashOffset=E,this.setFloat("grlDashOffset",E)}get dashRatio(){return this._dashRatio}set dashRatio(E){this._dashRatio=E,this.setFloat("grlDashRatio",E)}get dashCount(){return this._dashCount}set dashCount(E){this._dashCount=E,this._dashArray=1/E,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(E){this._sizeAttenuation=E,this.setFloat("grlSizeAttenuation",cE.BooleanToNumber(E))}get color(){return this._color}set color(E){this.setColor(E)}setColor(E){E=E??TE.DEFAULT_COLOR,this._color=E,this.setColor3("grlColor",E)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(E){this._colorsDistributionType=E,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(E){this._colorMode=E,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(E){this._resolution=E,this.setVector2("grlResolution",E),this.setFloat("grlAspect",E.x/E.y)}serialize(){const E=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(U.vE=this._colors),E.greasedLineMaterialOptions=U,E}parse(E,U,g){var N;const L=E.greasedLineMaterialOptions;null===(N=this._colorsTexture)||void 0===N||N.dispose(),L.color&&(this.color=L.color),L.colorDistributionType&&(this.colorsDistributionType=L.colorDistributionType),L.colorsSampling&&(this.colorsSampling=L.colorsSampling),L.colorMode&&(this.colorMode=L.colorMode),L.useColors&&(this.useColors=L.useColors),L.visibility&&(this.visibility=L.visibility),L.useDash&&(this.useDash=L.useDash),L.dashCount&&(this.dashCount=L.dashCount),L.dashRatio&&(this.dashRatio=L.dashRatio),L.dashOffset&&(this.dashOffset=L.dashOffset),L.width&&(this.width=L.width),L.sizeAttenuation&&(this.sizeAttenuation=L.sizeAttenuation),L.resolution&&(this.resolution=L.resolution),L.vE?this.colorsTexture=cE.CreateColorsTexture(`${this.name}-colors-texture`,L.vE,this.colorsSampling,this.tE()):this.colorsTexture=cE.PrepareEmptyColorsTexture(U),this._cameraFacing=L.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var qE,ME,mU;JE.ForceGLSL=!1,function(E){E[E.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",E[E.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(qE||(qE={})),function(E){E[E.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",E[E.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",E[E.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(ME||(ME={})),function(E){E[E.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",E[E.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",E[E.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",E[E.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",E[E.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(mU||(mU={}));class WE extends VE.e{constructor(E,U,g){super(E,U,null,null,!1,!1),this.name=E,this._options=g,this._lazy=!1,this._updatable=!1,this._engine=U.getEngine(),this._lazy=g.lazy??!1,this._updatable=g.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=g.colorPointers??[],this._widths=g.widths??new Array(g.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(E){let U=0;for(const N of this._points)U+=N.length;const g=U/3*2-this._widths.length;for(let N=0;N<g;N++)this._widths.push(E)}updateLazy(){var E,U;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(E=this._options.ribbonOptions)||void 0===E?void 0:E.smoothShading),!this.jE&&this.refreshBoundingInfo(),null===(U=this.greasedLineMaterial)||void 0===U||U.updateLazy()}addPoints(E,U){for(const g of E)this._points.push(g);this._lazy||this.setPoints(this._points,U)}dispose(E){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(E,U)}isLazy(){return this._lazy}get oE(){return this._uvs}set oE(E){this._uvs=E instanceof Float32Array?E:new Float32Array(E),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(E){this.material instanceof JE&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===E||void 0===E?void 0:E.length)>0),this._offsets=E,this._offsetsBuffer?this._offsetsBuffer.update(E):this._createOffsetsBuffer(E)}get widths(){return this._widths}set widths(E){this._widths=E,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(E)}get colorPointers(){return this._colorPointers}set colorPointers(E){this._colorPointers=E,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(E)}get greasedLineMaterial(){var E,U;if(this.material&&this.material instanceof JE)return this.material;const g=null===(E=this.material)||void 0===E||null===(U=E.pluginManager)||void 0===U?void 0:U.getPlugin(jE.GREASED_LINE_MATERIAL_NAME);return g||void 0}get points(){const E=[];return AE.b.DeepCopy(this._points,E),E}setPoints(E,U){this._points=cE.ConvertPoints(E,(null===U||void 0===U?void 0:U.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==U&&void 0!==U&&U.colorPointers||this._updateColorPointers(),this._setPoints(this._points,U)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,oE:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(E){super.serialize(E),E.type=this.getClassName(),E.lineOptions=this._createLineOptions()}_createVertexBuffers(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new ZE.e;return U.bE=this._vertexPositions,U.indices=this._indices,U.oE=this._uvs,E&&(U.TE=[],ZE.e.ComputeNormals(this._vertexPositions,this._indices,U.TE)),U.rE(this,this._options.updatable),U}_createOffsetsBuffer(E){const U=this._scene.getEngine(),g=new B.d(U,E,this._updatable,3);this.setVerticesBuffer(g.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=g}}class OE{constructor(E,U){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=E,this.wasAddedByNoopNode=U}getIndicesAccessor(E,U,g,N,L){var D,S,u,s;return null===(D=this._indicesAccessorMap.get(E))||void 0===D||null===(S=D.get(U))||void 0===S||null===(u=S.get(g))||void 0===u||null===(s=u.get(N))||void 0===s?void 0:s.get(L)}setIndicesAccessor(E,U,g,N,L,D){let S=this._indicesAccessorMap.get(E);S||(S=new Map,this._indicesAccessorMap.set(E,S));let u=S.get(U);u||(u=new Map,S.set(U,u));let s=u.get(g);s||(s=new Map,u.set(g,s));let C=s.get(N);C||(C=new Map,s.set(N,C)),C.set(L,D)}pushExportedNode(E){this._exportedNodes.has(E)||this._exportedNodes.add(E)}getNodesSet(){return this._exportedNodes}getVertexBufferView(E){return this._vertexBufferViewMap.get(E)}setVertexBufferView(E,U){this._vertexBufferViewMap.set(E,U)}setRemappedBufferView(E,U,g){this._remappedBufferView.set(E,new Map),this._remappedBufferView.get(E).set(U,g)}getRemappedBufferView(E,U){var g;return null===(g=this._remappedBufferView.get(E))||void 0===g?void 0:g.get(U)}getVertexAccessor(E,U,g){var N,L;return null===(N=this._vertexAccessorMap.get(E))||void 0===N||null===(L=N.get(U))||void 0===L?void 0:L.get(g)}setVertexAccessor(E,U,g,N){let L=this._vertexAccessorMap.get(E);L||(L=new Map,this._vertexAccessorMap.set(E,L));let D=L.get(U);D||(D=new Map,L.set(U,D)),D.set(g,N)}hasVertexColorAlpha(E){return this._vertexMapColorAlpha.get(E)||!1}setHasVertexColorAlpha(E,U){return this._vertexMapColorAlpha.set(E,U)}getMesh(E){return this._meshMap.get(E)}setMesh(E,U){this._meshMap.set(E,U)}bindMorphDataToMesh(E,U){const g=this._meshMorphTargetMap.get(E)||[];this._meshMorphTargetMap.set(E,g),-1===g.indexOf(U)&&g.push(U)}getMorphTargetsFromMesh(E){return this._meshMorphTargetMap.get(E)}}class QE{_ApplyExtension(E,U,g,N){if(g>=U.length)return Promise.resolve(E);const L=N(U[g],E);return L?L.then((async E=>E?await this._ApplyExtension(E,U,g+1,N):null)):this._ApplyExtension(E,U,g+1,N)}_ApplyExtensions(E,U){const g=[];for(const N of QE._ExtensionNames)g.push(this._extensions[N]);return this._ApplyExtension(E,g,0,U)}_extensionsPreExportTextureAsync(E,U,g){return this._ApplyExtensions(U,((U,N)=>U.preExportTextureAsync&&U.preExportTextureAsync(E,N,g)))}_extensionsPostExportNodeAsync(E,U,g,N,L){return this._ApplyExtensions(U,((U,D)=>U.postExportNodeAsync&&U.postExportNodeAsync(E,D,g,N,L,this._bufferManager)))}_extensionsPostExportMaterialAsync(E,U,g){return this._ApplyExtensions(U,((U,N)=>U.postExportMaterialAsync&&U.postExportMaterialAsync(E,N,g)))}_extensionsPostExportMaterialAdditionalTextures(E,U,g){const N=[];for(const L of QE._ExtensionNames){const D=this._extensions[L];D.postExportMaterialAdditionalTextures&&N.push(...D.postExportMaterialAdditionalTextures(E,U,g))}return N}_extensionsPostExportTextures(E,U,g){for(const N of QE._ExtensionNames){const L=this._extensions[N];L.postExportTexture&&L.postExportTexture(E,U,g)}}_extensionsPostExportMeshPrimitive(E){for(const U of QE._ExtensionNames){const g=this._extensions[U];g.postExportMeshPrimitive&&g.postExportMeshPrimitive(E,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const E of QE._ExtensionNames){const U=this._extensions[E];U.preGenerateBinaryAsync&&await U.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(E){for(const U of QE._ExtensionNames){const g=this._extensions[U];g.enabled&&E(g)}}_extensionsOnExporting(){this._forEachExtensions((E=>{var U,g,N;E.wasUsed&&((U=this._glTF).extensionsUsed||(U.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(E.name)&&this._glTF.extensionsUsed.push(E.name),E.required&&((g=this._glTF).extensionsRequired||(g.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(E.name)&&this._glTF.extensionsRequired.push(E.name)),(N=this._glTF).extensions||(N.extensions={}),E.onExporting&&E.onExporting())}))}_loadExtensions(){for(const E of QE._ExtensionNames){const U=QE._ExtensionFactories[E](this);this._extensions[E]=U}}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:I.b.LastCreatedScene,U=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${d.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new a(this),this._extensions={},this._bufferManager=new BE,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!E)throw new Error("No scene available to export");this._babylonScene=E,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:E=>{var U;return null===E||void 0===E||null===(U=E.Zg)||void 0===U?void 0:U.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...U},this._loadExtensions()}dispose(){for(const E in this._extensions){this._extensions[E].dispose()}}get options(){return this._options}static RegisterExtension(E,U){QE.UnregisterExtension(E)&&L.Tools.Warn(`Extension with the name ${E} already exists`),QE._ExtensionFactories[E]=U,QE._ExtensionNames.push(E)}static UnregisterExtension(E){if(!QE._ExtensionFactories[E])return!1;delete QE._ExtensionFactories[E];const U=QE._ExtensionNames.indexOf(E);return-1!==U&&QE._ExtensionNames.splice(U,1),!0}_generateJSON(E,U,g){const N={byteLength:E};return N.byteLength&&(this._glTF.buffers=[N]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.yU=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(N.uri=U+".bin"),g?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(E){const U=await this._generateBinaryAsync();this._extensionsOnExporting();const g=this._generateJSON(U.byteLength,E,!0),N=new Blob([U],{type:"application/octet-stream"}),L=E+".gltf",D=E+".bin",S=new C;if(S.files[L]=g,S.files[D]=N,this._imageData)for(const u in this._imageData)S.files[u]=new Blob([this._imageData[u].data],{type:this._imageData[u].mimeType});return S}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(E){const U=E%4;return 0===U?U:4-U}async generateGLBAsync(E){this._shouldUseGlb=!0;const U=await this._generateBinaryAsync();this._extensionsOnExporting();const g=this._generateJSON(U.byteLength),N=E+".glb";let L,D=g.length;if("undefined"!==typeof TextEncoder){L=(new TextEncoder).encode(g),D=L.length}const S=this._getPadding(D),u=this._getPadding(U.byteLength),s=28+D+S+U.byteLength+u,B=new sE(s);if(B.writeUInt32(1179937895),B.writeUInt32(2),B.writeUInt32(s),B.writeUInt32(D+S),B.writeUInt32(1313821514),L)B.writeTypedArray(L);else{const E="_".charCodeAt(0);for(let U=0;U<D;++U){const N=g.charCodeAt(U);N!=g.codePointAt(U)?B.writeUInt8(E):B.writeUInt8(N)}}for(let C=0;C<S;++C)B.writeUInt8(32);B.writeUInt32(U.byteLength+u),B.writeUInt32(5130562),B.writeTypedArray(U);for(let C=0;C<u;++C)B.writeUInt8(0);const P=new C;return P.files[N]=new Blob([B.getOutputData()],{type:"application/octet-stream"}),P}_setNodeTransformation(E,U,g){if(U.getPivotPoint().equalsWithEpsilon(W,mE.c)||L.Tools.Warn("Pivot points are not supported in the glTF serializer"),!U.position.equalsWithEpsilon(W,mE.c)){const L=N.TmpVectors.dU[0].D(U.position);g&&H(L),E.translation=L.Og()}U.Iu.equalsWithEpsilon(Q,mE.c)||(E.scale=U.Iu.Og());const D=U.rotationQuaternion||N.Quaternion.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);D.equalsWithEpsilon(O,mE.c)||(g&&K(D),E.rotation=D.normalize().Og())}_setCameraTransformation(E,U,g){if(!U.position.equalsWithEpsilon(W,mE.c)){const L=N.TmpVectors.dU[0].D(U.position);g&&H(L),E.translation=L.Og()}const L=U.rotationQuaternion||N.Quaternion.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);g&&K(L),this._babylonScene.useRightHandedSystem||X(L),L.equalsWithEpsilon(O,mE.c)||(E.rotation=L.Og())}_listAvailableCameras(){for(const E of this._babylonScene.cameras){const U={type:E.mode===FE.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(E.name&&(U.name=E.name),"perspective"===U.type)U.perspective={aspectRatio:E.getEngine().getAspectRatio(E),yfov:E.fovMode===FE.d.FOVMODE_VERTICAL_FIXED?E.fov:E.fov*E.getEngine().getAspectRatio(E),znear:E.kg,zfar:E.maxZ};else if("orthographic"===U.type){const g=E.orthoLeft&&E.orthoRight?.5*(E.orthoRight-E.orthoLeft):.5*E.getEngine().getRenderWidth(),N=E.orthoBottom&&E.orthoTop?.5*(E.orthoTop-E.orthoBottom):.5*E.getEngine().getRenderHeight();U.orthographic={xmag:g,ymag:N,znear:E.kg,zfar:E.maxZ}}this._camerasMap.set(E,U)}}_exportAndAssignCameras(){const E=Array.from(this._camerasMap.values());for(const U of E){const E=this._nodesCameraMap.get(U);if(void 0!==E){this._cameras.push(U);for(const U of E)U.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const E of this._babylonScene.skeletons){if(E.bones.length<=0)continue;const U={joints:[]};this._skinMap.set(E,U)}}_exportAndAssignSkeletons(){for(const E of this._babylonScene.skeletons){if(E.bones.length<=0)continue;const U=this._skinMap.get(E);if(void 0==U)continue;const g={},N=[];let D=-1;for(let L=0;L<E.bones.length;++L){const U=E.bones[L],N=U.getIndex()??L;-1!==N&&(g[N]=U,N>D&&(D=N))}for(let E=0;E<=D;++E){const D=g[E];N.push(D.getAbsoluteInverseBindMatrix());const S=D.getTransformNode();if(null!==S){const E=this._nodeMap.get(S);S&&null!==E&&void 0!==E?U.joints.push(E):L.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else L.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const S=this._nodesSkinMap.get(U);if(U.joints.length>0&&void 0!==S){const E=64*N.length,g=new Float32Array(E/4);N.forEach(((E,U)=>{g.set(E.m,16*U)}));const L=this._bufferManager.createBufferView(g);this._accessors.push(this._bufferManager.createAccessor(L,"MAT4",5126,N.length)),U.inverseBindMatrices=this._accessors.length-1,this._skins.push(U);for(const U of S)U.skin=this._skins.length-1}}}async _exportSceneAsync(){const E={nodes:[]};if(this._babylonScene.metadata){const U=this._options.metadataSelector(this._babylonScene.metadata);U&&(E.extras=U)}const U=new Array,g=new Array,N=new Array;for(const u of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&SE(u,this._babylonScene.useRightHandedSystem)?N.push(...u.getChildren()):this._babylonScene.useRightHandedSystem?U.push(u):g.push(u);this._listAvailableCameras(),this._listAvailableSkeletons();const L=new OE(!0,!1);E.nodes.push(...await this._exportNodesAsync(g,L));const D=new OE(!1,!1);E.nodes.push(...await this._exportNodesAsync(U,D));const S=new OE(!1,!0);E.nodes.push(...await this._exportNodesAsync(N,S)),E.nodes.length&&this._scenes.push(E),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&xE._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,L.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(E){let U=this._shouldExportNodeMap.get(E);return void 0===U&&(U=this._options.shouldExportNode(E),this._shouldExportNodeMap.set(E,U)),U}async _exportNodesAsync(E,U){const g=new Array;this._exportBuffers(E,U);for(const N of E)await this._exportNodeAsync(N,g,U);return g}_collectBuffers(E,U,g,N,L){if(this._shouldExportNode(E)&&E instanceof F.b&&E.XL){const D=E.XL.getVertexBuffers();if(D)for(const N in D){if(!z(N))continue;const S=D[N];L.setHasVertexColorAlpha(S,E.hasVertexAlpha);const u=S._buffer,s=U.get(u)||[];U.set(u,s),-1===s.indexOf(S)&&s.push(S);const C=g.get(S)||[];g.set(S,C),-1===C.indexOf(E)&&C.push(E)}const S=E.morphTargetManager;if(S)for(let U=0;U<S.numTargets;U++){const g=S.getTarget(U),L=N.get(g)||[];N.set(g,L),-1===L.indexOf(E)&&L.push(E)}}for(const D of E.getChildren())this._collectBuffers(D,U,g,N,L)}_exportBuffers(E,U){const g=new Map,N=new Map,L=new Map;for(const u of E)this._collectBuffers(u,g,N,L,U);const D=Array.from(g.keys());for(const u of D){const E=u.getData();if(!E)throw new Error("Buffer data is not available");const L=g.get(u);if(!L)continue;const D=L[0].byteStride;if(L.some((E=>E.byteStride!==D)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const S=gE(E).slice();for(const U of L){const E=N.get(U),{byteOffset:g,byteStride:L,componentCount:D,type:u,count:s,normalized:C,kind:P}=n(U,E);switch(P){case B.f.NormalKind:case B.f.TangentKind:(0,J.d)(S,g,L,D,u,s,C,(E=>{const U=Math.sqrt(E[0]*E[0]+E[1]*E[1]+E[2]*E[2]);if(U>0){const g=1/U;E[0]*=g,E[1]*=g,E[2]*=g}}));break;case B.f.ColorKind:{const U=E.filter((E=>E.material instanceof IE.hU||null==E.material)).length;if(0==U)break;if(U!=E.length){q.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}u==B.f.UNSIGNED_BYTE&&q.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const N=new y.VU,P=new y.hu,F=this._babylonScene.getEngine().useExactSrgbConversions;(0,J.d)(S,g,L,D,u,s,C,(E=>{3===E.length?(N.Yg(E,0),N.toLinearSpaceToRef(N,F),N.toArray(E,0)):(P.Yg(E,0),P.toLinearSpaceToRef(P,F),P.toArray(E,0))}))}}}if(U.convertToRightHanded){for(const E of L){const U=N.get(E),{byteOffset:g,byteStride:L,componentCount:D,type:u,count:s,normalized:C,kind:P}=n(E,U);switch(P){case B.f.PositionKind:case B.f.NormalKind:case B.f.TangentKind:(0,J.d)(S,g,L,D,u,s,C,(E=>{E[0]=-E[0]}))}}U.convertedToRightHandedBuffers.set(u,S)}const s=this._bufferManager.createBufferView(S,D);U.setVertexBufferView(u,s);const C=new Map;for(const U of L){const E=N.get(U),{kind:g,totalVertices:L}=n(U,E);switch(g){case B.f.MatricesIndicesKind:case B.f.MatricesIndicesExtraKind:if(U.type==B.f.FLOAT){const E=U.getFloatData(L);null!==E&&C.set(U,E)}}}0!==C.size&&q.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const P=Array.from(C.keys());for(const g of P){const E=C.get(g);if(!E)continue;const N=E.some((E=>E>=256)),L=new(N?Uint16Array:Uint8Array)(E.length);for(let U=0;U<E.length;U++)L[U]=E[U];const D=this._bufferManager.createBufferView(L,4*(N?2:1));U.setRemappedBufferView(u,g,D)}}const S=Array.from(L.keys());for(const u of S){const E=L.get(u);if(!E)continue;const g=lE(u,E[0],this._bufferManager,this._bufferViews,this._accessors,U.convertToRightHanded);for(const N of E)U.bindMorphDataToMesh(N,g)}}async _exportNodeAsync(E,U,g){let N=this._nodeMap.get(E);if(void 0!==N)return void(U.includes(N)||U.push(N));const L=await this._createNodeAsync(E,g);if(L){N=this._nodes.length,this._nodes.push(L),this._nodeMap.set(E,N),g.pushExportedNode(E),U.push(N);const D={name:"runtime animations",channels:[],samplers:[]},S=[];this._babylonScene.animationGroups.length||(xE._CreateMorphTargetAnimationFromMorphTargetAnimations(E,D,S,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,g.convertToRightHanded,this._options.shouldExportAnimation),E.animations.length&&xE._CreateNodeAnimationFromNodeAnimations(E,D,S,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,g.convertToRightHanded,this._options.shouldExportAnimation)),D.channels.length&&D.samplers.length&&this._animations.push(D),S.forEach((E=>{E.channels.length&&E.samplers.length&&this._animations.push(E)}))}const D=L?[]:U;for(const S of E.getChildren())await this._exportNodeAsync(S,D,g);L&&D.length&&(L.children=D)}async _createNodeAsync(E,U){if(!this._shouldExportNode(E))return null;const g={};if(E.name&&(g.name=E.name),E.metadata){const U=this._options.metadataSelector(E.metadata);U&&(g.extras=U)}if(E instanceof P.c&&(this._setNodeTransformation(g,E,U.convertToRightHanded),E instanceof F.b)){const L=E instanceof f.b?E.sourceMesh:E;if(L.Wg&&L.Wg.length>0&&(g.mesh=await this._exportMeshAsync(L,U)),E.skeleton){const U=this._skinMap.get(E.skeleton);var N;if(void 0!==U)void 0===this._nodesSkinMap.get(U)&&this._nodesSkinMap.set(U,[]),null===(N=this._nodesSkinMap.get(U))||void 0===N||N.push(g)}}if(E instanceof M.d){const N=this._camerasMap.get(E);if(N){var L;void 0===this._nodesCameraMap.get(N)&&this._nodesCameraMap.set(N,[]),this._setCameraTransformation(g,E,U.convertToRightHanded);const S=E.parent;if(null!==S&&UE(E,S)){const E=this._nodeMap.get(S);if(void 0!==E){var D;const U=this._nodes[E];return EE(g,U),null===(D=this._nodesCameraMap.get(N))||void 0===D||D.push(U),null}}null===(L=this._nodesCameraMap.get(N))||void 0===L||L.push(g)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",g,E,this._nodeMap,U.convertToRightHanded)?g:(q.d.Warn(`Not exporting node ${E.name}`),null)}_exportIndices(E,U,g,N,L,S,u,s,C){let B=E;C.mode=i(S);const P=u!==D.b.CounterClockWiseSideOrientation,F=!s.wasAddedByNoopNode&&P,f=function(E){switch(E){case D.b.TriangleFillMode:case D.b.TriangleStripDrawMode:case D.b.TriangleFanDrawMode:return!0}return!1}(S)&&F;if(f){if(S===D.b.TriangleStripDrawMode||S===D.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");C.mode=i(S);const u=U?new Uint32Array(N):new Uint16Array(N);if(E)for(let U=0;U+2<N;U+=3)u[U]=E[g+U]+L,u[U+1]=E[g+U+2]+L,u[U+2]=E[g+U+1]+L;else for(let E=0;E+2<N;E+=3)u[E]=E,u[E+1]=E+2,u[E+2]=E+1;B=u}else if(E&&0!==L){const D=U?new Uint32Array(N):new Uint16Array(N);for(let U=0;U<N;U++)D[U]=E[g+U]+L;B=D}if(B){let D=s.getIndicesAccessor(E,g,N,L,f);if(void 0===D){const S=function(E,U,g,N){if(E instanceof Uint16Array||E instanceof Uint32Array)return E;if(E instanceof Int32Array)return new Uint32Array(E.buffer,E.byteOffset,E.length);const L=E.slice(U,U+g);return N?new Uint32Array(L):new Uint16Array(L)}(B,0,N,U),u=this._bufferManager.createBufferView(S),C=U?5125:5123;this._accessors.push(this._bufferManager.createAccessor(u,"SCALAR",C,N,0)),D=this._accessors.length-1,s.setIndicesAccessor(E,g,N,L,f,D)}C.indices=D}}_exportVertexBuffer(E,U,g,N,L,D){const S=E.getKind();if(!z(S))return;if(S.startsWith("uv")&&!this._options.exportUnusedUVs&&(!U||!this._materialNeedsUVsSet.has(U)))return;let u=L.getVertexAccessor(E,g,N);if(void 0===u){const U=L.convertedToRightHandedBuffers.get(E._buffer)||E._buffer.getData(),D=S===B.f.PositionKind?function(E,U,g,N){const{byteOffset:L,byteStride:D,type:S,normalized:u}=U,s=U.getSize(),C=new Array(s).fill(1/0),B=new Array(s).fill(-1/0);return(0,J.d)(E,L+g*D,D,s,S,N*s,u,(E=>{for(let U=0;U<s;U++)C[U]=Math.min(C[U],E[U]),B[U]=Math.max(B[U],E[U])})),{min:C,max:B}}(U,E,g,N):void 0,s=(S===B.f.MatricesIndicesKind||S===B.f.MatricesIndicesExtraKind)&&E.type===B.f.FLOAT,C=s?B.f.UNSIGNED_BYTE:E.type,P=s?void 0:E.normalized,F=s?L.getRemappedBufferView(E._buffer,E):L.getVertexBufferView(E._buffer),f=E.byteOffset+g*E.byteStride;this._accessors.push(this._bufferManager.createAccessor(F,function(E,U){if(E==B.f.ColorKind)return U?"VEC4":"VEC3";switch(E){case B.f.PositionKind:case B.f.NormalKind:return"VEC3";case B.f.TangentKind:case B.f.MatricesIndicesKind:case B.f.MatricesIndicesExtraKind:case B.f.MatricesWeightsKind:case B.f.MatricesWeightsExtraKind:return"VEC4";case B.f.UVKind:case B.f.UV2Kind:case B.f.UV3Kind:case B.f.UV4Kind:case B.f.UV5Kind:case B.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${E}`)}(S,L.hasVertexColorAlpha(E)),C,N,f,D,P)),u=this._accessors.length-1,L.setVertexAccessor(E,g,N,u)}D.attributes[function(E){switch(E){case B.f.PositionKind:return"POSITION";case B.f.NormalKind:return"NORMAL";case B.f.TangentKind:return"TANGENT";case B.f.ColorKind:return"COLOR_0";case B.f.UVKind:return"TEXCOORD_0";case B.f.UV2Kind:return"TEXCOORD_1";case B.f.UV3Kind:return"TEXCOORD_2";case B.f.UV4Kind:return"TEXCOORD_3";case B.f.UV5Kind:return"TEXCOORD_4";case B.f.UV6Kind:return"TEXCOORD_5";case B.f.MatricesIndicesKind:return"JOINTS_0";case B.f.MatricesIndicesExtraKind:return"JOINTS_1";case B.f.MatricesWeightsKind:return"WEIGHTS_0";case B.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${E}`)}(S)]=u}async _exportMaterialAsync(E,U,g,N){let L=this._materialMap.get(E);if(void 0===L){const N=U&&Object.keys(U).some((E=>E.startsWith("uv")));if((E=E instanceof fE.c?E.Vu[g.materialIndex]:E)instanceof dE.b)L=await this._materialExporter.exportPBRMaterialAsync(E,"image/png",N);else{if(!(E instanceof IE.hU))return void q.d.Warn(`Unsupported material '${E.name}' with type ${E.getClassName()}`);L=await this._materialExporter.exportStandardMaterialAsync(E,"image/png",N)}this._materialMap.set(E,L)}N.material=L}async _exportMeshAsync(E,U){var g;let N=U.getMesh(E);if(void 0!==N)return N;const L={primitives:[]};N=this._meshes.length,this._meshes.push(L),U.setMesh(E,N);const S=E.isUnIndexed?null:E.CD(),u=null===(g=E.XL)||void 0===g?void 0:g.getVertexBuffers(),s=U.getMorphTargetsFromMesh(E),C=E instanceof YE.e,B=E instanceof WE,P=E.Wg;if(u&&P&&P.length>0)for(const d of P){const g={attributes:{}},N=d.aE()||this._babylonScene.defaultMaterial;if(B){var F,f;const U={name:N.name},L=E,D=y.VU.White(),S=(null===(F=L.material)||void 0===F?void 0:F.alpha)??1,u=(null===(f=L.greasedLineMaterial)||void 0===f?void 0:f.color)??D;(!u.equalsWithEpsilon(D,mE.c)||S<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...u.Og(),S]}),this._materials.push(U),g.material=this._materials.length-1}else if(C){const U={name:N.name},L=E;(!L.color.equalsWithEpsilon(y.VU.White(),mE.c)||L.alpha<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...L.color.Og(),L.alpha]}),this._materials.push(U),g.material=this._materials.length-1}else await this._exportMaterialAsync(N,u,d,g);const P=C||B?D.b.LineListDrawMode:E.overrideRenderingFillMode??N.fillMode,I=N._getEffectiveOrientation(E);this._exportIndices(S,S?(0,J.b)(S,d.indexCount,d.indexStart,d.verticesStart):d.verticesCount>65535,S?d.indexStart:d.verticesStart,S?d.indexCount:d.verticesCount,-d.verticesStart,P,I,U,g);for(const E of Object.values(u))this._exportVertexBuffer(E,N,d.verticesStart,d.verticesCount,U,g);if(s){g.targets=[];for(const E of s)g.targets.push(E.attributes)}L.primitives.push(g),this._extensionsPostExportMeshPrimitive(g)}if(s){L.weights=[],L.extras||(L.extras={}),L.extras.targetNames=[];for(const E of s)L.weights.push(E.influence),L.extras.targetNames.push(E.name)}return N}}QE._ExtensionNames=new Array,QE._ExtensionFactories={};class RE{static async GLTFAsync(E,U,g){g&&g.exportWithoutWaitingForScene||await E.whenReadyAsync();const N=new QE(E,g),L=await N.generateGLTFAsync(U.replace(/\.[^/.]+$/,""));return N.dispose(),L}static async GLBAsync(E,U,g){g&&g.exportWithoutWaitingForScene||await E.whenReadyAsync();const N=new QE(E,g),L=await N.generateGLBAsync(U.replace(/\.[^/.]+$/,""));return N.dispose(),L}}g(12885);const nE="EXT_mesh_gpu_instancing";class kE{constructor(E){this.name=nE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(E,U,g,L,D,S){return await new Promise((E=>{if(U&&g instanceof VE.e&&g.hasThinInstances&&this._exporter){this._wasUsed=!0;const E=N.dU.Zero(),L=N.Quaternion.Identity(),u=N.dU.One(),s=g.thinInstanceGetWorldMatrices(),C=N.TmpVectors.dU[2],B=N.TmpVectors.Quaternion[1],P=N.TmpVectors.dU[3];let F=!1,f=!1,d=!1;const I=new Float32Array(3*g.eu),y=new Float32Array(4*g.eu),h=new Float32Array(3*g.eu);let V=0;for(const U of s)U.decompose(P,B,C),D&&(H(C),K(B)),I.set(C.Og(),3*V),y.set(B.normalize().Og(),4*V),h.set(P.Og(),3*V),F=F||!C.equalsWithEpsilon(E),f=f||!B.equalsWithEpsilon(L),d=d||!P.equalsWithEpsilon(u),V++;const e={attributes:{}};F&&(e.attributes.TRANSLATION=this._buildAccessor(I,"VEC3",g.eu,S)),f&&(e.attributes.ROTATION=this._buildAccessor(y,"VEC4",g.eu,S)),d&&(e.attributes.SCALE=this._buildAccessor(h,"VEC3",g.eu,S)),U.extensions=U.extensions||{},U.extensions[nE]=e}E(U)}))}_buildAccessor(E,U,g,N){const L=N.createBufferView(E),D=N.createAccessor(L,U,5126,g);return this._exporter._accessors.push(D),this._exporter._accessors.length-1}}QE.RegisterExtension(nE,(E=>new kE(E)));var zE=g(12889),iE=g(12905),pE=g(12907),HE=g(12914);function KE(E){return E===pE.e.PositionKind?"POSITION":E===pE.e.NormalKind?"NORMAL":E===pE.e.ColorKind?"COLOR":E.startsWith(pE.e.UVKind)?"TEX_COORD":"GENERIC"}const XE={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class EU extends zE.b{static get DefaultAvailable(){return(0,zE.f)(EU.DefaultConfiguration)}static get Default(){return EU._Default??(EU._Default=new EU),EU._Default}static ResetDefault(E){EU._Default&&(E||EU._Default.dispose(),EU._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(E,U){return{module:await(U||DracoEncoderModule)({wasmBinary:E})}}_getWorkerContent(){return`${iE.f}(${iE.i})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:EU.DefaultConfiguration)}async _encodeAsync(E,U,g){const N=g?(0,HE.d)(XE,g):XE;if(this._workerPoolPromise){const g=await this._workerPoolPromise;return await new Promise(((L,D)=>{g.push(((g,S)=>{const u=E=>{g.removeEventListener("error",u),g.removeEventListener("message",s),D(E),S()},s=E=>{"encodeMeshDone"===E.data.id&&(g.removeEventListener("error",u),g.removeEventListener("message",s),L(E.data.encodedMeshData),S())};g.addEventListener("error",u),g.addEventListener("message",s);const C=[];for(const U of E)C.push(U.data.buffer);U&&C.push(U.buffer),g.postMessage({id:"encodeMesh",attributes:E,indices:U,options:N},C)}))}))}if(this._modulePromise){const g=await this._modulePromise;return(0,iE.f)(g.module,E,U,N)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(E,U){if(0==E.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");E instanceof VE.e&&E.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===U||void 0===U?void 0:U.method)&&(q.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),U.method="MESH_SEQUENTIAL_ENCODING");const g=function(E){let U=E.CD(void 0,!0);return!U||U instanceof Uint32Array||U instanceof Uint16Array||(U=((0,J.b)(U,U.length)?Uint32Array:Uint16Array).from(U)),U}(E),N=function(E,U){const g=[];for(const N of E.getVerticesDataKinds()){if(null!==U&&void 0!==U&&U.includes(N)){if(N===pE.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const L=E.getVertexBuffer(N),D=L.getSize(),S=(0,J.r)(L.getData(),D,L.type,L.byteOffset,L.byteStride,L.normalized,E.getTotalVertices(),!0);g.push({kind:N,dracoName:KE(N),size:D,data:S})}return g}(E,null===U||void 0===U?void 0:U.excludedAttributes);return await this._encodeAsync(N,g,U)}}EU.DefaultConfiguration={wasmUrl:`${L.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${L.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${L.Tools._DefaultCdnUrl}/draco_encoder.js`},EU._Default=null;const UU="KHR_draco_mesh_compression";class gU{get wasUsed(){return this._wasUsed}constructor(E){this.name=UU,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===E.options.meshCompressionMethod&&EU.DefaultAvailable}dispose(){}postExportMeshPrimitive(E,U,g){if(!this.enabled)return;if(4!==E.mode&&5!==E.mode)return void q.d.Warn("Cannot compress primitive with mode "+E.mode+".");const N=[],L=[];let D=null;if(void 0!==E.indices){const S=g[E.indices],u=U.getBufferView(S);D=U.getData(u).slice(),N.push(u),L.push(S)}const S=[];for(const[B,P]of Object.entries(E.attributes)){const E=g[P],D=U.getBufferView(E),s=k(E.type),C=(0,J.r)(U.getData(D),s,E.componentType,E.byteOffset||0,D.byteStride||(0,J.k)(E.componentType)*s,E.normalized||!1,E.count,!0);S.push({kind:B,dracoName:(u=B,"POSITION"===u?"POSITION":"NORMAL"===u?"NORMAL":u.startsWith("COLOR")?"COLOR":u.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:k(E.type),data:C}),N.push(D),L.push(E)}var u;const s={method:E.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},C=EU.Default._encodeAsync(S,D,s).then((g=>{if(!g)return void q.d.Error("Draco encoding failed for primitive.");const D={bufferView:-1,attributes:g.attributeIds},S=U.createBufferView(g.data);U.setBufferView(D,S);for(const E of N)this._bufferViewsUsed.add(E);for(const E of L)this._accessorsUsed.add(E);E.extensions||(E.extensions={}),E.extensions[UU]=D})).catch((E=>{q.d.Error("Draco encoding failed for primitive: "+E)}));this._encodePromises.push(C),this._wasUsed=!0}async preGenerateBinaryAsync(E){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((U=>{E.getPropertiesWithBufferView(U).every((E=>this._accessorsUsed.has(E)))&&E.removeBufferView(U)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}QE.RegisterExtension(UU,(E=>new gU(E)));var NU=g(12917);const LU="KHR_lights_punctual",DU={name:"",color:[1,1,1],xu:1,range:Number.MAX_VALUE},SU={innerConeAngle:0,outerConeAngle:Math.PI/4},uU=N.dU.Backward();class sU{constructor(E){this.name=LU,this.enabled=!0,this.required=!1,this._exporter=E}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[LU]=this._lights}async postExportNodeAsync(E,U,g,L,D){return await new Promise((S=>{if(!(g instanceof eE.c))return void S(U);const u=g.getTypeID()==eE.c.LIGHTTYPEID_POINTLIGHT?"point":g.getTypeID()==eE.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":g.getTypeID()==eE.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!u||!(g instanceof NU.e))return q.d.Warn(`${E}: Light ${g.name} is not supported in ${LU}`),void S(U);if(g.falloffType!==eE.c.FALLOFF_GLTF&&q.d.Warn(`${E}: Light falloff for ${g.name} does not match the ${LU} specification!`),!g.position.equalsToFloats(0,0,0)){const E=N.TmpVectors.dU[0].D(g.position);D&&H(E),U.translation=E.Og()}if("point"!==u){const E=g.direction.normalizeToRef(N.TmpVectors.dU[0]);D&&H(E);const L=N.Quaternion.FromUnitVectorsToRef(uU,E,N.TmpVectors.Quaternion[0]);N.Quaternion.IsIdentity(L)||(U.rotation=L.Og())}const s={type:u,name:g.name,color:g.lu.Og(),xu:g.xu,range:g.range};if(NE(s,DU),"spot"===u){const E=g;s.spot={innerConeAngle:E.innerAngle/2,outerConeAngle:E.angle/2},NE(s.spot,SU)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(s);const C={Cg:this._lights.lights.length-1},B=g.parent;if(B&&UE(g,B)){const E=L.get(B);if(E){const g=this._exporter._nodes[E];return EE(U,g),g.extensions||(g.extensions={}),g.extensions[LU]=C,void S(null)}}U.extensions||(U.extensions={}),U.extensions[LU]=C,S(U)}))}}QE.RegisterExtension(LU,(E=>new sU(E)));var CU=g(12838);const BU="KHR_materials_anisotropy";class PU{constructor(E){this.name=BU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,U,g){const N=[];return g instanceof CU.b&&g.anisotropy.isEnabled&&!g.anisotropy.legacy?(g.anisotropy.texture&&N.push(g.anisotropy.texture),N):[]}postExportMaterialAsync(E,U,g){return new Promise((E=>{if(g instanceof CU.b){if(!g.anisotropy.isEnabled||g.anisotropy.legacy)return void E(U);this._wasUsed=!0,U.extensions=U.extensions||{};const N=this._exporter._materialExporter.getTextureInfo(g.anisotropy.texture),L={anisotropyStrength:g.anisotropy.xu,anisotropyRotation:g.anisotropy.angle,anisotropyTexture:N??void 0};null!==L.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(g),U.extensions[BU]=L}E(U)}))}}QE.RegisterExtension(BU,(E=>new PU(E)));const FU="KHR_materials_clearcoat";class fU{constructor(E){this.name=FU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,U,g){const N=[];return g instanceof CU.b&&g.clearCoat.isEnabled?(g.clearCoat.texture&&N.push(g.clearCoat.texture),!g.clearCoat.useRoughnessFromMainTexture&&g.clearCoat.textureRoughness&&N.push(g.clearCoat.textureRoughness),g.clearCoat.bumpTexture&&N.push(g.clearCoat.bumpTexture),N):[]}postExportMaterialAsync(E,U,g){return new Promise((E=>{if(g instanceof CU.b){if(!g.clearCoat.isEnabled)return void E(U);this._wasUsed=!0,U.extensions=U.extensions||{};const N=this._exporter._materialExporter.getTextureInfo(g.clearCoat.texture);let D;D=g.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(g.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(g.clearCoat.textureRoughness),g.clearCoat.isTintEnabled&&L.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${g.name}`),g.clearCoat.remapF0OnInterfaceChange&&L.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${g.name}`);const S=this._exporter._materialExporter.getTextureInfo(g.clearCoat.bumpTexture),u={clearcoatFactor:g.clearCoat.xu,clearcoatTexture:N??void 0,clearcoatRoughnessFactor:g.clearCoat.roughness,clearcoatRoughnessTexture:D??void 0,clearcoatNormalTexture:S??void 0};null===u.clearcoatTexture&&null===u.clearcoatRoughnessTexture&&null===u.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(g),U.extensions[FU]=u}E(U)}))}}QE.RegisterExtension(FU,(E=>new fU(E)));const dU="KHR_materials_diffuse_transmission";function IU(E,U){const g=U.subSurface;let N=null;return g.translucencyIntensityTexture?N=g.translucencyIntensityTexture:g.thicknessTexture&&g.useMaskFromThicknessTexture&&(N=g.thicknessTexture),N&&!g.useGltfStyleTextures?(q.d.Warn(`${E}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${U.name}`,1),null):N}class yU{constructor(E){this.name=dU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,U,g){const N=[];if(g instanceof dE.b&&this._isExtensionEnabled(g)){const U=IU(E,g);return U&&N.push(U),g.subSurface.translucencyColorTexture&&N.push(g.subSurface.translucencyColorTexture),N}return N}_isExtensionEnabled(E){if(E.unlit)return!1;const U=E.subSurface;return!!U.isTranslucencyEnabled&&(!E.unlit&&!U.useAlbedoToTintTranslucency&&U.useGltfStyleTextures&&1===U.volumeIndexOfRefraction&&0===U.minimumThickness&&0===U.maximumThickness)}postExportMaterialAsync(E,U,g){return new Promise((N=>{if(g instanceof dE.b&&this._isExtensionEnabled(g)){this._wasUsed=!0;const N=g.subSurface,L=IU(E,g),D=0==N.translucencyIntensity?void 0:N.translucencyIntensity,S=this._exporter._materialExporter.getTextureInfo(L)??void 0,u=!N.translucencyColor||N.translucencyColor.equalsFloats(1,1,1)?void 0:N.translucencyColor.Og(),s=this._exporter._materialExporter.getTextureInfo(N.translucencyColorTexture)??void 0,C={diffuseTransmissionFactor:D,diffuseTransmissionTexture:S,diffuseTransmissionColorFactor:u,diffuseTransmissionColorTexture:s};(S||s)&&this._exporter._materialNeedsUVsSet.add(g),U.extensions=U.extensions||{},U.extensions[dU]=C}N(U)}))}}QE.RegisterExtension(dU,(E=>new yU(E)));const hU="KHR_materials_dispersion";class VU{constructor(){this.name=hU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(E){if(E.unlit)return!1;const U=E.subSurface;return!(!U.isRefractionEnabled&&!U.isDispersionEnabled)}postExportMaterialAsync(E,U,g){return new Promise((E=>{if(g instanceof dE.b&&this._isExtensionEnabled(g)){this._wasUsed=!0;const E={dispersion:g.subSurface.dispersion};U.extensions=U.extensions||{},U.extensions[hU]=E}E(U)}))}}QE.RegisterExtension(hU,(()=>new VU));const eU="KHR_materials_emissive_strength";class xU{constructor(){this.name=eU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(E,U,g){return await new Promise((E=>{if(!(g instanceof dE.b))return E(U);const N=g.emissiveColor.Og(),L=Math.max(...N);if(L>1){this._wasUsed=!0,U.extensions||(U.extensions={});const E={emissiveStrength:L},N=g.emissiveColor.scale(1/E.emissiveStrength);U.emissiveFactor=N.Og(),U.extensions[eU]=E}return E(U)}))}}QE.RegisterExtension(eU,(E=>new xU));const lU="KHR_materials_ior";class YU{constructor(){this.name=lU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(E){return!E.unlit&&(void 0!=E.indexOfRefraction&&1.5!=E.indexOfRefraction)}postExportMaterialAsync(E,U,g){return new Promise((E=>{if(g instanceof dE.b&&this._isExtensionEnabled(g)){this._wasUsed=!0;const E={ior:g.indexOfRefraction};U.extensions=U.extensions||{},U.extensions[lU]=E}E(U)}))}}QE.RegisterExtension(lU,(E=>new YU));const tU="KHR_materials_iridescence";class GU{constructor(E){this.name=tU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,U,g){const N=[];return g instanceof CU.b&&g.iridescence.isEnabled?(g.iridescence.texture&&N.push(g.iridescence.texture),g.iridescence.thicknessTexture&&g.iridescence.thicknessTexture!==g.iridescence.texture&&N.push(g.iridescence.thicknessTexture),N):[]}postExportMaterialAsync(E,U,g){return new Promise((E=>{if(g instanceof CU.b){if(!g.iridescence.isEnabled)return void E(U);this._wasUsed=!0,U.extensions=U.extensions||{};const N=this._exporter._materialExporter.getTextureInfo(g.iridescence.texture),L=this._exporter._materialExporter.getTextureInfo(g.iridescence.thicknessTexture),D={iridescenceFactor:g.iridescence.xu,iridescenceIor:g.iridescence.indexOfRefraction,iridescenceThicknessMinimum:g.iridescence.minimumThickness,iridescenceThicknessMaximum:g.iridescence.maximumThickness,iridescenceTexture:N??void 0,iridescenceThicknessTexture:L??void 0};null===D.iridescenceTexture&&null===D.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(g),U.extensions[tU]=D}E(U)}))}}QE.RegisterExtension(tU,(E=>new GU(E)));const bU="KHR_materials_sheen";class TU{constructor(E){this.name=bU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,U,g){return g instanceof dE.b&&g.sheen.isEnabled&&g.sheen.texture?[g.sheen.texture]:[]}async postExportMaterialAsync(E,U,g){return await new Promise((E=>{if(g instanceof dE.b){if(!g.sheen.isEnabled)return void E(U);this._wasUsed=!0,null==U.extensions&&(U.extensions={});const N={sheenColorFactor:g.sheen.color.Og(),sheenRoughnessFactor:g.sheen.roughness??0};null===N.sheenColorTexture&&null===N.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(g),g.sheen.texture&&(N.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(g.sheen.texture)??void 0),g.sheen.textureRoughness&&!g.sheen.useRoughnessFromMainTexture?N.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(g.sheen.textureRoughness)??void 0:g.sheen.texture&&g.sheen.useRoughnessFromMainTexture&&(N.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(g.sheen.texture)??void 0),U.extensions[bU]=N}E(U)}))}}QE.RegisterExtension(bU,(E=>new TU(E)));const vU="KHR_materials_specular";class oU{constructor(E){this.name=vU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,U,g){const N=[];return g instanceof dE.b&&this._isExtensionEnabled(g)?(g.metallicReflectanceTexture&&N.push(g.metallicReflectanceTexture),g.reflectanceTexture&&N.push(g.reflectanceTexture),N):N}_isExtensionEnabled(E){return!E.unlit&&(void 0!=E.metallicF0Factor&&1!=E.metallicF0Factor||void 0!=E.metallicReflectanceColor&&!E.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(E))}_hasTexturesExtension(E){return null!=E.metallicReflectanceTexture||null!=E.reflectanceTexture}postExportMaterialAsync(E,U,g){return new Promise((E=>{if(g instanceof dE.b&&this._isExtensionEnabled(g)){this._wasUsed=!0,U.extensions=U.extensions||{};const E=this._exporter._materialExporter.getTextureInfo(g.metallicReflectanceTexture)??void 0,N=this._exporter._materialExporter.getTextureInfo(g.reflectanceTexture)??void 0,L={specularFactor:1==g.metallicF0Factor?void 0:g.metallicF0Factor,specularTexture:E,specularColorFactor:g.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:g.metallicReflectanceColor.Og(),specularColorTexture:N};this._hasTexturesExtension(g)&&this._exporter._materialNeedsUVsSet.add(g),U.extensions[vU]=L}E(U)}))}}QE.RegisterExtension(vU,(E=>new oU(E)));const cU="KHR_materials_transmission";class rU{constructor(E){this.name=cU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,U,g){const N=[];return g instanceof dE.b&&this._isExtensionEnabled(g)?(g.subSurface.thicknessTexture&&N.push(g.subSurface.thicknessTexture),N):N}_isExtensionEnabled(E){if(E.unlit)return!1;const U=E.subSurface;return U.isRefractionEnabled&&void 0!=U.refractionIntensity&&0!=U.refractionIntensity||this._hasTexturesExtension(E)}_hasTexturesExtension(E){return null!=E.subSurface.refractionIntensityTexture}async postExportMaterialAsync(E,U,g){if(g instanceof dE.b&&this._isExtensionEnabled(g)){this._wasUsed=!0;const N=g.subSurface,L={transmissionFactor:0===N.refractionIntensity?void 0:N.refractionIntensity};if(this._hasTexturesExtension(g)&&this._exporter._materialNeedsUVsSet.add(g),N.refractionIntensityTexture)if(N.useGltfStyleTextures){const E=await this._exporter._materialExporter.exportTextureAsync(N.refractionIntensityTexture,"image/png");E&&(L.transmissionTexture=E)}else q.d.Warn(`${E}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);U.extensions||(U.extensions={}),U.extensions[cU]=L}return U}}QE.RegisterExtension(cU,(E=>new rU(E)));const jU="KHR_materials_unlit";class ZU{constructor(){this.name=jU,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(E,U,g){return new Promise((E=>{let N=!1;g instanceof dE.b?N=g.unlit:g instanceof IE.hU&&(N=g.disableLighting),N&&(this._wasUsed=!0,null==U.extensions&&(U.extensions={}),U.extensions[jU]={}),E(U)}))}}QE.RegisterExtension(jU,(()=>new ZU));const AU="KHR_materials_volume";class wU{constructor(E){this.name=AU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,U,g){const N=[];return g instanceof dE.b&&this._isExtensionEnabled(g)?(g.subSurface.thicknessTexture&&N.push(g.subSurface.thicknessTexture),N):N}_isExtensionEnabled(E){if(E.unlit)return!1;const U=E.subSurface;return!(!U.isRefractionEnabled&&!U.isTranslucencyEnabled)&&(void 0!=U.maximumThickness&&0!=U.maximumThickness||void 0!=U.tintColorAtDistance&&U.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=U.tintColor&&U.tintColor!=y.VU.White()||this._hasTexturesExtension(E))}_hasTexturesExtension(E){return null!=E.subSurface.thicknessTexture}postExportMaterialAsync(E,U,g){return new Promise((E=>{if(g instanceof dE.b&&this._isExtensionEnabled(g)){this._wasUsed=!0;const E=g.subSurface,N={thicknessFactor:0==E.maximumThickness?void 0:E.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(E.thicknessTexture)??void 0,attenuationDistance:E.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:E.tintColorAtDistance,attenuationColor:E.tintColor.equalsFloats(1,1,1)?void 0:E.tintColor.Og()};this._hasTexturesExtension(g)&&this._exporter._materialNeedsUVsSet.add(g),U.extensions=U.extensions||{},U.extensions[AU]=N}E(U)}))}}QE.RegisterExtension(AU,(E=>new wU(E)));const aU="EXT_materials_diffuse_roughness";class JU{constructor(E){this.name=aU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,U,g){const N=[];return g instanceof CU.b&&g._baseDiffuseRoughness?(g._baseDiffuseRoughnessTexture&&N.push(g._baseDiffuseRoughnessTexture),N):[]}postExportMaterialAsync(E,U,g){return new Promise((E=>{if(g instanceof CU.b){if(!g._baseDiffuseRoughness)return void E(U);this._wasUsed=!0,U.extensions=U.extensions||{};const N=this._exporter._materialExporter.getTextureInfo(g._baseDiffuseRoughnessTexture),L={diffuseRoughnessFactor:g._baseDiffuseRoughness,diffuseRoughnessTexture:N??void 0};null!==L.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(g),U.extensions[aU]=L}E(U)}))}}QE.RegisterExtension(aU,(E=>new JU(E)));const qU="KHR_texture_transform";class MU{constructor(){this.name=qU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(E,U,g){if(g.tE()||L.Tools.Warn(`${E}: /*@__KEY__*/"scene" is not defined for Babylon texture ${g.name}!`),(0!==g.uAng||0!==g.vAng)&&(L.Tools.Warn(`${E}: Texture ${g.name} with rotation in the u or v axis is not supported in glTF.`),0!==g.uRotationCenter||0!==g.vRotationCenter))return;const N={};let D=!1;if(0===g.uOffset&&0===g.vOffset||(N.offset=[g.uOffset,g.vOffset],D=!0),1===g.uScale&&1===g.vScale||(N.scale=[g.uScale,g.vScale],D=!0),0!==g.wAng){if(0!==g.uRotationCenter||0!==g.vRotationCenter){if(g.homogeneousRotationInUVTransform&&g.uScale!==g.vScale)return void L.Tools.Warn(`${E}: Texture ${g.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${qU}.`);L.Tools.Warn(`${E}: Texture ${g.name} with non-origin rotation center will be exported using an adjusted offset with ${qU}.`),N.offset=function(E){const{uOffset:U,vOffset:g,uRotationCenter:N,vRotationCenter:L,uScale:D,vScale:S,wAng:u}=E,s=Math.cos(u),C=Math.sin(u),B=N*D,P=L*S;return[U+(B*(1-s)+P*C),g+(P*(1-s)-B*C)]}(g)}N.rotation=-g.wAng,D=!0}0!==g.coordinatesIndex&&(N.texCoord=g.coordinatesIndex,D=!0),D&&(this._wasUsed=!0,U.extensions||(U.extensions={}),U.extensions[qU]=N)}}QE.RegisterExtension(qU,(()=>new MU));class mg{static CreateSTL(E){let U=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",L=arguments.length>3&&void 0!==arguments[3]&&arguments[3],D=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],S=arguments.length>5&&void 0!==arguments[5]&&arguments[5],u=arguments.length>6&&void 0!==arguments[6]&&arguments[6],s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const C=function(E,U,g){const L=[3*E[g],3*E[g+1],3*E[g+2]],D=[new N.dU(U[L[0]],U[L[0]+2],U[L[0]+1]),new N.dU(U[L[1]],U[L[1]+2],U[L[1]+1]),new N.dU(U[L[2]],U[L[2]+2],U[L[2]+1])],S=D[0].IU(D[1]),u=D[2].IU(D[1]);return{v:D,n:N.dU.Cross(u,S).normalize()}},P=function(E,U,g,N){return U=F(E,U,g.x,N),U=F(E,U,g.y,N),F(E,U,g.z,N)},F=function(E,U,g,N){return E.setFloat32(U,g,N),U+4},d=function(E){if(u){let U=E;E instanceof f.b&&(U=E.sourceMesh);const g=U.getVerticesData(B.f.PositionKind,!0,!0);if(!g)return[];const L=N.dU.Zero();let D;for(D=0;D<g.length;D+=3)N.dU.TransformCoordinatesFromFloatsToRef(g[D],g[D+1],g[D+2],E.pg(!0),L).toArray(g,D);return g}return E.getVerticesData(B.f.PositionKind)||[]};u&&(S=!0);let I="",y=0,h=0;if(L){for(let g=0;g<E.length;g++){const U=E[g].CD();y+=U?U.length/3:0}const U=new ArrayBuffer(84+50*y);I=new DataView(U),h+=80,I.setUint32(h,y,D),h+=4}else s||(I="solid stlmesh\r\n");for(let N=0;N<E.length;N++){const U=E[N];!L&&s&&(I+="solid "+U.name+"\r\n"),!S&&U instanceof VE.e&&U.bakeCurrentTransformIntoVertices();const g=d(U),u=U.CD()||[];for(let E=0;E<u.length;E+=3){const U=C(u,g,E);L?(h=P(I,h,U.n,D),h=P(I,h,U.v[0],D),h=P(I,h,U.v[1],D),h=P(I,h,U.v[2],D),h+=2):(I+="\tfacet normal "+U.n.x+" "+U.n.y+" "+U.n.z+"\r\n",I+="\t\touter loop\r\n",I+="\t\t\tvertex "+U.v[0].x+" "+U.v[0].y+" "+U.v[0].z+"\r\n",I+="\t\t\tvertex "+U.v[1].x+" "+U.v[1].y+" "+U.v[1].z+"\r\n",I+="\t\t\tvertex "+U.v[2].x+" "+U.v[2].y+" "+U.v[2].z+"\r\n",I+="\t\tendloop\r\n",I+="\tendfacet\r\n")}!L&&s&&(I+="endsolid "+name+"\r\n")}if(L||s||(I+="endsolid stlmesh"),U){const E=document.createElement("a"),U=new Blob([I],{type:"application/octet-stream"});E.href=window.URL.createObjectURL(U),E.download=g+".stl",E.click()}return I}}function WU(E,U){let g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const N=[];for(let L=0;L<E.length/g;L++){const D=E[L*g],S=E[L*g+1],u=E[L*g+2];N.push(`(${D.toPrecision(U.precision)}, ${S.toPrecision(U.precision)}, ${u.toPrecision(U.precision)})`)}return N.join(", ")}function OU(E,U){const g=[];for(let N=0;N<E.length/2;N++){const L=E[2*N],D=E[2*N+1];g.push(`(${L.toPrecision(U.precision)}, ${(1-D).toPrecision(U.precision)})`)}return g.join(", ")}function QU(E,U){const g=E.getVerticesData(B.f.PositionKind),N=E.getVerticesData(B.f.NormalKind);if(g&&N)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(E){var U;const g=null!==(U=E.CD())&&void 0!==U&&U.length?E.getTotalIndices():E.getTotalVertices();return Array(g/3).fill(3).join(", ")}(E)}]\n\t\tint[] faceVertexIndices = [${function(E){const U=E.CD(),g=[];if(null!==U)for(let N=0;N<U.length;N++)g.push(U[N]);else{const U=E.getTotalVertices();for(let E=0;E<U;E++)g.push(E)}return g.join(", ")}(E)}]\n\t\tnormal3f[] normals = [${WU(N,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${WU(g,U)}]\n        ${function(E,U){let g="";for(let L=0;L<4;L++){const N=L>0?L:"",D=E.getVerticesData(B.f.UVKind+(N?N+1:""));D&&(g+=`\n\t\ttexCoord2f[] primvars:st${N} = [${OU(D,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const N=E.getVerticesData(B.f.ColorKind);return N&&(g+=`\n\tcolor3f[] primvars:displayColor = [${WU(N,U,N.length/E.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),g}(E,U)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function RU(E,U){return`\n        def "Geometry"\n        {\n        ${QU(E,U)}\n        }\n        `}function nU(E){let U='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return U+=E,fflate.strToU8(U)}function kU(E){const U=E.m;return`( ${zU(U,0)}, ${zU(U,4)}, ${zU(U,8)}, ${zU(U,12)} )`}function zU(E,U){return`(${E[U+0]}, ${E[U+1]}, ${E[U+2]}, ${E[U+3]})`}function iU(E){const U="Object_"+E.uniqueId,g=function(E){const U=E.getWorldMatrix().clone(),g=E.tE().useRightHandedSystem;if(!g){let N=E.parent;for(;N;){if(SE(N,g)){U.multiplyToRef(N.getWorldMatrix().invert(),U);break}N=N.parent}}return U.determinant()<0&&L.Tools.Warn(`Exporting mesh ${E.name} with negative scale. Result may look incorrect in destination engine.`),U}(E),N=kU(g);return`def Xform "${U}" (\n\tprepend references = @./geometries/Geometry_${E.XL.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${N}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${E.material.uniqueId}>\n}\n\n`}function pU(E){switch(E){case t.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case t.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case t.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function HU(E){return`(${E.x}, ${E.y})`}function KU(E){return`(${E.r}, ${E.g}, ${E.b})`}function XU(E,U,g,L,D,S){const u=E.getInternalTexture().uniqueId+"_"+E.invertY;D[u]=E;const s=E.coordinatesIndex>0?"st"+E.coordinatesIndex:"st",C=new N.Vector2(E.uScale,E.vScale),B=new N.Vector2(E.uOffset,E.vOffset),P=E.wAng,F=Math.sin(P),f=Math.cos(P);return B.y=1-B.y-C.y,B.x+=F*C.x,B.y+=(1-f)*C.y,`\n    def Shader "PrimvarReader_${g}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${s}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${g}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${U.uniqueId}/PrimvarReader_${g}.outputs:result>\n        float inputs:rotation = ${(P*(180/Math.PI)).toFixed(S.precision)}\n        float2 inputs:scale = ${HU(C)}\n        float2 inputs:translation = ${HU(B)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${E.uniqueId}_${g}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${u}.png@\n        float2 inputs:st.connect = </Materials/Material_${U.uniqueId}/Transform2d_${g}.outputs:result>\n        ${L?"float4 inputs:scale = "+function(E){return`(${E.r}, ${E.g}, ${E.b}, 1.0)`}(L):""}\n        token inputs:sourceColorSpace = "${E.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${pU(E.wrapU)}"\n        token inputs:wrapT = "${pU(E.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${U.needAlphaBlending()?"float outputs:a":""}\n    }`}function Eg(E,U,g){const N="\t\t\t",L=[],D=[],{diffuseMap:S,lu:u,alphaCutOff:s,emissiveMap:C,emissive:B,normalMap:P,roughnessMap:F,roughnessChannel:f,roughness:d,metalnessMap:I,metalnessChannel:h,metalness:V,aoMap:e,aoMapChannel:x,aoMapIntensity:l,alphaMap:Y,ior:t,clearCoatEnabled:G,clearCoat:b,clearCoatMap:T,clearCoatRoughness:v,clearCoatRoughnessMap:o}=function(E){const U={diffuseMap:null,lu:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return E instanceof IE.hU?{...U,diffuseMap:E.diffuseTexture,lu:E.diffuseColor,alphaCutOff:E.alphaCutOff,emissiveMap:E.emissiveTexture,emissive:E.emissiveColor,roughness:1,alphaMap:E.opacityTexture}:E instanceof CU.b?{...U,diffuseMap:E._albedoTexture,lu:E._albedoColor,alphaCutOff:E._alphaCutOff,emissiveMap:E._emissiveTexture,emissive:E._emissiveColor,normalMap:E._bumpTexture,roughnessMap:E._metallicTexture,roughnessChannel:E._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:E._roughness??1,metalnessMap:E._metallicTexture,metalnessChannel:E._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:E._metallic??0,aoMap:E._ambientTexture,aoMapChannel:E._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:E._ambientTextureStrength,alphaMap:E._opacityTexture,ior:E.subSurface.indexOfRefraction,clearCoatEnabled:E.clearCoat.isEnabled,clearCoat:E.clearCoat.xu,clearCoatMap:E.clearCoat.texture,clearCoatRoughness:E.clearCoat.roughness,clearCoatRoughnessMap:E.clearCoat.useRoughnessFromMainTexture?E.clearCoat.texture:E.clearCoat.textureRoughness}:U}(E);return null!==S?(L.push(`${N}color3f inputs:diffuseColor.connect = </Materials/Material_${E.uniqueId}/Texture_${S.uniqueId}_diffuse.outputs:rgb>`),E.needAlphaBlending()?L.push(`${N}float inputs:opacity.connect = </Materials/Material_${E.uniqueId}/Texture_${S.uniqueId}_diffuse.outputs:a>`):E.needAlphaTesting()&&(L.push(`${N}float inputs:opacity.connect = </Materials/Material_${E.uniqueId}/Texture_${S.uniqueId}_diffuse.outputs:a>`),L.push(`${N}float inputs:opacityThreshold = ${s}`)),D.push(XU(S,E,"diffuse",u,U,g))):L.push(`${N}color3f inputs:diffuseColor = ${KU(u||y.VU.White())}`),null!==C?(L.push(`${N}color3f inputs:emissiveColor.connect = </Materials/Material_${E.uniqueId}/Texture_${C.uniqueId}_emissive.outputs:rgb>`),D.push(XU(C,E,"emissive",B,U,g))):B&&B.toLuminance()>0&&L.push(`${N}color3f inputs:emissiveColor = ${KU(B)}`),null!==P&&(L.push(`${N}normal3f inputs:normal.connect = </Materials/Material_${E.uniqueId}/Texture_${P.uniqueId}_normal.outputs:rgb>`),D.push(XU(P,E,"normal",null,U,g))),null!==e&&(L.push(`${N}float inputs:occlusion.connect = </Materials/Material_${E.uniqueId}/Texture_${e.uniqueId}_occlusion.outputs:${x}>`),D.push(XU(e,E,"occlusion",new y.VU(l,l,l),U,g))),null!==F?(L.push(`${N}float inputs:roughness.connect = </Materials/Material_${E.uniqueId}/Texture_${F.uniqueId}_roughness.outputs:${f}>`),D.push(XU(F,E,"roughness",new y.VU(d,d,d),U,g))):L.push(`${N}float inputs:roughness = ${d}`),null!==I?(L.push(`${N}float inputs:metallic.connect = </Materials/Material_${E.uniqueId}/Texture_${I.uniqueId}_metallic.outputs:${h}>`),D.push(XU(I,E,"metallic",new y.VU(V,V,V),U,g))):L.push(`${N}float inputs:metallic = ${V}`),null!==Y?(L.push(`${N}float inputs:opacity.connect = </Materials/Material_${E.uniqueId}/Texture_${Y.uniqueId}_opacity.outputs:r>`),L.push(`${N}float inputs:opacityThreshold = 0.0001`),D.push(XU(Y,E,"opacity",null,U,g))):L.push(`${N}float inputs:opacity = ${E.alpha}`),G&&(null!==T?(L.push(`${N}float inputs:clearcoat.connect = </Materials/Material_${E.uniqueId}/Texture_${T.uniqueId}_clearcoat.outputs:r>`),D.push(XU(T,E,"clearcoat",new y.VU(b,b,b),U,g))):L.push(`${N}float inputs:clearcoat = ${b}`),null!==o?(L.push(`${N}float inputs:clearcoatRoughness.connect = </Materials/Material_${E.uniqueId}/Texture_${o.uniqueId}_clearcoatRoughness.outputs:g>`),D.push(XU(o,E,"clearcoatRoughness",new y.VU(v,v,v),U,g))):L.push(`${N}float inputs:clearcoatRoughness = ${v}`)),L.push(`${N}float inputs:ior = ${t}`),`\n\tdef Material "Material_${E.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${L.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${E.uniqueId}/PreviewSurface.outputs:surface>\n\n${D.join("\n")}\n\n\t}\n`}async function Ug(E,U,g){const D={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...U};"undefined"===typeof fflate&&await L.Tools.LoadScriptAsync(D.fflateUrl);const S={};S[D.modelFileName]=null;let u='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';u+=function(E){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===E.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${E.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${E.planeAnchoringAlignment}"`:""}\n            `}(D);const s={};for(const N of E.meshes){if(0===N.getTotalVertices())continue;const E=N,U=E.XL,C=E.material;if(!C||!U||g&&!g(E))continue;if(-1!==["hU","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(C.getClassName())){const g="geometries/Geometry_"+U.uniqueId+".usda";if(!(g in S)){const E=RU(U,D);S[g]=nU(E)}C.uniqueId in s||(s[C.uniqueId]=C),u+=iU(E)}else L.Tools.Warn("USDZExportAsync does not support this material type: "+C.getClassName())}E.activeCamera&&D.exportCamera&&(u+=function(E,U){const g="Camera_"+E.uniqueId,L=kU(N.Matrix.RotationY(Math.PI).multiply(E.getWorldMatrix()));if(E.mode===t.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${g}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${L}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${E.kg.toPrecision(U.precision)}, ${E.maxZ.toPrecision(U.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(E.orthoLeft||1)+Math.abs(E.orthoRight||1))).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(E.orthoTop||1)+Math.abs(E.orthoBottom||1))).toPrecision(U.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const N=E.getEngine().getAspectRatio(E),D=U.cameraSensorWidth||35;return`def Camera "${g}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${L}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${E.kg.toPrecision(U.precision)}, ${E.maxZ.toPrecision(U.precision)})\n\t\t\tfloat focalLength = ${(D/(2*Math.tan(.5*E.fov))).toPrecision(U.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(D*N).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(D/N).toPrecision(U.precision)}            \n\t\t}\n\t\n\t`}}(E.activeCamera,D)),u+="\n            }\n        }\n    }";const C={};u+=function(E,U,g){const N=[];for(const L in E){const D=E[L];N.push(Eg(D,U,g))}return`\n    def "Materials"\n{\n${N.join("")}\n}\n\n`}(s,C,D),S[D.modelFileName]=fflate.strToU8(u);for(const N in C){const E=C[N],U=E.getSize(),g=await E.readPixels();if(!g)throw new Error("Texture data is not available");const L=await G.DumpTools.DumpDataAsync(U.width,U.height,g,"image/png",void 0,!1,!0);S[`textures/Texture_${N}.png`]=new Uint8Array(L).slice()}let B=0;for(const N in S){const E=S[N];if(!E)continue;B+=34+N.length;const U=63&B;if(4!==U){const g=new Uint8Array(64-U);S[N]=[E,{extra:{12345:g}}]}B=E.length}return fflate.zipSync(S,{level:0})}}}]);