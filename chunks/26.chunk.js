"use strict";(self["9d4d30r2sf"]=self["9d4d30r2sf"]||[]).push([[26],{12919:(o,v,V)=>{V.r(v),V.d(v,{EXT_materials_diffuse_roughness:()=>zv,EXT_mesh_gpu_instancing:()=>Bo,GLTF2Export:()=>Xo,GLTFData:()=>O,KHR_draco_mesh_compression:()=>gv,KHR_lights_punctual:()=>Ov,KHR_materials_anisotropy:()=>fv,KHR_materials_clearcoat:()=>Sv,KHR_materials_diffuse_transmission:()=>Rv,KHR_materials_dispersion:()=>tv,KHR_materials_emissive_strength:()=>Lv,KHR_materials_ior:()=>uv,KHR_materials_iridescence:()=>av,KHR_materials_sheen:()=>iv,KHR_materials_specular:()=>dv,KHR_materials_transmission:()=>Yv,KHR_materials_unlit:()=>Pv,KHR_materials_volume:()=>Wv,KHR_texture_transform:()=>Hv,OBJExport:()=>Q,STLExport:()=>ev,USDZExportAsync:()=>VV,_ConvertToGLTFPBRMetallicRoughness:()=>Y,_SolveMetallic:()=>N,__IGLTFExporterExtension:()=>U});var g=V(12488),E=V(12291),I=V(12829);class Q{static OBJ(o,v,V,Q){const U=[];let n=1,O=1;v&&(V||(V="mat"),U.push("mtllib "+V+".mtl"));for(let h=0;h<o.length;h++){const V=o[h],x=V.name||`mesh${h}}`;U.push(`o ${x}`);let f=null;if(Q){const o=V.Ag(!0);f=new g.Matrix,o.invertToRef(f),V.bakeTransformIntoVertices(o)}if(v){const o=V.material;o&&U.push("usemtl "+o.id)}const l=V.kg;if(!l){E.Tools.Warn("No geometry is present on the mesh");continue}const S=l.getVerticesData("position"),T=l.getVerticesData("normal"),c=l.getVerticesData("uv"),R=l.QQ();let j=0,t=0;if(!S||!R){E.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const s=o[0].Fo().useRightHandedSystem?1:-1;for(let o=0;o<S.length;o+=3)U.push("v "+S[o]*s+" "+S[o+1]+" "+S[o+2]),j++;if(null!=T)for(let o=0;o<T.length;o+=3)U.push("vn "+T[o]*s+" "+T[o+1]+" "+T[o+2]);if(null!=c)for(let o=0;o<c.length;o+=2)U.push("vt "+c[o]+" "+c[o+1]),t++;const L=["","",""],b=(V.material||V.Fo().defaultMaterial)._getEffectiveOrientation(V),[u,mo]=b===I.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let o=0;o<R.length;o+=3){const v=[String(R[o]+n),String(R[o+u]+n),String(R[o+mo]+n)],V=[String(R[o]+O),String(R[o+u]+O),String(R[o+mo]+O)],g=v,E=null!=c?V:L,I=null!=T?v:L;U.push("f "+g[0]+"/"+E[0]+"/"+I[0]+" "+g[1]+"/"+E[1]+"/"+I[1]+" "+g[2]+"/"+E[2]+"/"+I[2])}Q&&f&&V.bakeTransformIntoVertices(f),n+=j,O+=t}return U.join("\n")}static MTL(o){const v=[],V=o.material;v.push("newmtl mat1"),v.push("  Ns "+V.specularPower.toFixed(4)),v.push("  Ni 1.5000"),v.push("  d "+V.alpha.toFixed(4)),v.push("  Tr 0.0000"),v.push("  Tf 1.0000 1.0000 1.0000"),v.push("  illum 2"),v.push("  Ka "+V.ambientColor.r.toFixed(4)+" "+V.ambientColor.g.toFixed(4)+" "+V.ambientColor.b.toFixed(4)),v.push("  Kd "+V.diffuseColor.r.toFixed(4)+" "+V.diffuseColor.g.toFixed(4)+" "+V.diffuseColor.b.toFixed(4)),v.push("  Ks "+V.specularColor.r.toFixed(4)+" "+V.specularColor.g.toFixed(4)+" "+V.specularColor.b.toFixed(4)),v.push("  Ke "+V.emissiveColor.r.toFixed(4)+" "+V.emissiveColor.g.toFixed(4)+" "+V.emissiveColor.b.toFixed(4));V.ambientTexture&&v.push("  map_Ka "+V.ambientTexture.name),V.diffuseTexture&&v.push("  map_Kd "+V.diffuseTexture.name),V.specularTexture&&v.push("  map_Ks "+V.specularTexture.name),V.bumpTexture&&v.push("  map_bump -imfchan z "+V.bumpTexture.name),V.opacityTexture&&v.push("  map_d "+V.opacityTexture.name);return v.join("\n")}}var U=0,n=V(12347);class O{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const o in this.files){const v=this.files[o],V=new Blob([v],{type:(0,n.g)(o)});E.Tools.Download(V,o)}}}var h=V(12577),x=V(12928),f=V(12936),l=V(12954),S=V(12623),T=V(12339),c=V(12547),R=V(12511);const j=R.HighestCommonFactor,t={...R,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:j};var s=V(12737),L=V(12471),b=V(12989),u=V(12996),mo=V(12728);const a=1e-6,F=new c.Lv(.04,.04,.04),i=1024,J=c.Lv.White(),d=c.Lv.Black();function N(o,v,V){if(v<F.r)return 0;const g=F.r,E=o*V/(1-F.r)+v-2*F.r,I=E*E-4*g*(F.r-v);return t.Clamp((-E+Math.sqrt(I))/(2*g),0,1)}function Y(o){const v=o.diffuseColor.toLinearSpace(o.Fo().getEngine().useExactSrgbConversions).scale(.5),V=o.alpha,E=function(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new g.Vector2(0,1),V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new g.Vector2(0,.1),E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new g.Vector2(0,.1),I=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new g.Vector2(1300,.1);return function(o,v,V,g,E){return(1-o)*(1-o)*(1-o)*v+3*(1-o)*(1-o)*o*V+3*(1-o)*o*o*g+o*o*o*E}(Math.pow(o/I.x,.333333),v.y,V.y,E.y,I.y)}(t.Clamp(o.specularPower,0,i));return{baseColorFactor:[v.r,v.g,v.b,V],metallicFactor:0,roughnessFactor:E}}function q(o,v){v.needAlphaBlending()?o.alphaMode="BLEND":v.needAlphaTesting()&&(o.alphaMode="MASK",o.alphaCutoff=v.alphaCutOff)}function P(o,v,V){const g=new Uint8Array(o*v*4);for(let E=0;E<g.length;E+=4)g[E]=g[E+1]=g[E+2]=g[E+3]=255;return b.e.CreateRGBATexture(g,o,v,V)}function M(o){if(o instanceof Uint8Array){const v=o.length,V=new Float32Array(o.length);for(let g=0;g<v;++g)V[g]=o[g]/255;return V}if(o instanceof Float32Array)return o;throw new Error("Unsupported pixel format!")}class W{constructor(o){this._exporter=o,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(o){return o?this._textureMap.get(o)??null:null}async exportStandardMaterialAsync(o,v,V){const g=Y(o),I={name:o.name};if(null==o.cU||o.cU||(o.twoSidedLighting||E.Tools.Warn(o.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),I.doubleSided=!0),V){const V=[],E=o.diffuseTexture;E&&V.push(this.exportTextureAsync(E,v).then((o=>{o&&(g.baseColorTexture=o)})));const Q=o.bumpTexture;Q&&V.push(this.exportTextureAsync(Q,v).then((o=>{o&&(I.normalTexture=o,1!==Q.level&&(I.normalTexture.scale=Q.level))})));const U=o.emissiveTexture;U&&(I.emissiveFactor=[1,1,1],V.push(this.exportTextureAsync(U,v).then((o=>{o&&(I.emissiveTexture=o)}))));const n=o.ambientTexture;n&&V.push(this.exportTextureAsync(n,v).then((o=>{if(o){const v={index:o.index};I.occlusionTexture=v}}))),V.length>0&&(this._exporter._materialNeedsUVsSet.add(o),await Promise.all(V))}(o.alpha<1||o.opacityTexture)&&(o.alphaMode===u.c.ALPHA_COMBINE?I.alphaMode="BLEND":E.Tools.Warn(o.name+": glTF 2.0 does not support alpha mode: "+o.alphaMode.toString())),o.emissiveColor&&!o.emissiveColor.equalsWithEpsilon(d,a)&&(I.emissiveFactor=o.emissiveColor.Dg()),I.pbrMetallicRoughness=g,q(I,o),await this._finishMaterialAsync(I,o,v);const Q=this._exporter._materials;return Q.push(I),Q.length-1}async _finishMaterialAsync(o,v,V){const g=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",o,v),E=[];for(const I of g)E.push(this.exportTextureAsync(I,V));await Promise.all(E),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",o,v)}async _getImageDataAsync(o,v,g,E){const I=u.c.TEXTURETYPE_UNSIGNED_BYTE,Q=this._exporter._babylonScene,U=Q.getEngine(),n=U.createRawTexture(o,v,g,u.c.TEXTUREFORMAT_RGBA,!1,!0,L.e.NEAREST_SAMPLINGMODE,null,I);U.isWebGPU?await V.e(51).then(V.bind(V,15010)):await V.e(52).then(V.bind(V,15012)),await s.m.ApplyPostProcess("pass",n,Q,I,u.c.TEXTURE_NEAREST_SAMPLINGMODE,u.c.TEXTUREFORMAT_RGBA);const O=await U._readTexturePixels(n,v,g);return await mo.DumpTools.DumpDataAsync(v,g,O,E,void 0,!0,!0)}_resizeTexturesToSameDimensions(o,v,V){const g=o?o.getSize():{width:0,height:0},E=v?v.getSize():{width:0,height:0};let I,Q;return g.width<E.width?(I=o&&o instanceof L.e?s.m.CreateResizedCopy(o,E.width,E.height,!0):P(E.width,E.height,V),Q=v):g.width>E.width?(Q=v&&v instanceof L.e?s.m.CreateResizedCopy(v,g.width,g.height,!0):P(g.width,g.height,V),I=o):(I=o,Q=v),{texture1:I,texture2:Q}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(o,v,V,g){const E=new Array;if(!o&&!v)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const I=o?o.Fo():v?v.Fo():null;if(I){var Q;const U=this._resizeTexturesToSameDimensions(o,v,I),n=null===(Q=U.texture1)||void 0===Q?void 0:Q.getSize();let O,h;const x=n.width,f=n.height,l=await U.texture1.readPixels(),S=await U.texture2.readPixels();if(!l)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(O=M(l),!S)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");h=M(S);const T=h.byteLength,R=new Uint8Array(T),j=new Uint8Array(T),t=4,s=d;let L=0,b=0;for(let o=0;o<f;++o)for(let v=0;v<x;++v){const g=(x*o+v)*t,E={diffuseColor:new c.Lv(O[g],O[g+1],O[g+2]).toLinearSpace(I.getEngine().useExactSrgbConversions).multiply(V.diffuseColor),specularColor:new c.Lv(h[g],h[g+1],h[g+2]).toLinearSpace(I.getEngine().useExactSrgbConversions).multiply(V.specularColor),glossiness:h[g+3]*V.glossiness},Q=this._convertSpecularGlossinessToMetallicRoughness(E);s.r=Math.max(s.r,Q.baseColor.r),s.g=Math.max(s.g,Q.baseColor.g),s.b=Math.max(s.b,Q.baseColor.b),L=Math.max(L,Q.metallic),b=Math.max(b,Q.roughness),j[g]=255*Q.baseColor.r,j[g+1]=255*Q.baseColor.g,j[g+2]=255*Q.baseColor.b,j[g+3]=U.texture1.Kg?255*O[g+3]:255,R[g]=0,R[g+1]=255*Q.roughness,R[g+2]=255*Q.metallic,R[g+3]=255}const u={baseColor:s,metallic:L,roughness:b};let mo=!1,F=!1;for(let o=0;o<f;++o)for(let v=0;v<x;++v){const V=(x*o+v)*t;j[V]/=u.baseColor.r>a?u.baseColor.r:1,j[V+1]/=u.baseColor.g>a?u.baseColor.g:1,j[V+2]/=u.baseColor.b>a?u.baseColor.b:1;const g=c.Lv.FromInts(j[V],j[V+1],j[V+2]).toGammaSpace(I.getEngine().useExactSrgbConversions);j[V]=255*g.r,j[V+1]=255*g.g,j[V+2]=255*g.b,g.equalsWithEpsilon(J,a)||(F=!0),R[V+1]/=u.roughness>a?u.roughness:1,R[V+2]/=u.metallic>a?u.metallic:1;c.Lv.FromInts(255,R[V+1],R[V+2]).equalsWithEpsilon(J,a)||(mo=!0)}return mo&&E.push(this._getImageDataAsync(R,x,f,g).then((o=>{u.metallicRoughnessTextureData=o}))),F&&E.push(this._getImageDataAsync(j,x,f,g).then((o=>{u.baseColorTextureData=o}))),await Promise.all(E).then((()=>u))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(o){const v=this._getPerceivedBrightness(o.diffuseColor),V=this._getPerceivedBrightness(o.specularColor),g=1-this._getMaxComponent(o.specularColor),E=N(v,V,g),I=o.diffuseColor.scale(g/(1-F.r)/Math.max(1-E)),Q=o.specularColor.Rv(F.scale(1-E)).scale(1/Math.max(E));let U=c.Lv.Lerp(I,Q,E*E);U=U.clampToRef(0,1,U);return{baseColor:U,metallic:E,roughness:1-o.glossiness}}_getPerceivedBrightness(o){return o?Math.sqrt(.299*o.r*o.r+.587*o.g*o.g+.114*o.b*o.b):0}_getMaxComponent(o){return o?Math.max(o.r,Math.max(o.g,o.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(o,v,V,g){const E=[],I={baseColor:o._albedoColor,metallic:o._metallic,roughness:o._roughness};if(g){o._albedoTexture&&E.push(this.exportTextureAsync(o._albedoTexture,v).then((o=>{o&&(V.baseColorTexture=o)})));const g=o._metallicTexture;g&&E.push(this.exportTextureAsync(g,v).then((o=>{o&&(V.metallicRoughnessTexture=o)})))}return E.length>0&&(this._exporter._materialNeedsUVsSet.add(o),await Promise.all(E)),I}_getTextureSampler(o){const v={};if(!o||!(o instanceof L.e))return v;const V=this._getGLTFTextureWrapMode(o.wrapU);10497!==V&&(v.wrapS=V);const g=this._getGLTFTextureWrapMode(o.wrapV);switch(10497!==g&&(v.wrapT=g),o.samplingMode){case L.e.LINEAR_LINEAR:v.magFilter=9729,v.minFilter=9729;break;case L.e.LINEAR_NEAREST:v.magFilter=9729,v.minFilter=9728;break;case L.e.NEAREST_LINEAR:v.magFilter=9728,v.minFilter=9729;break;case L.e.NEAREST_LINEAR_MIPLINEAR:v.magFilter=9728,v.minFilter=9987;break;case L.e.NEAREST_NEAREST:v.magFilter=9728,v.minFilter=9728;break;case L.e.NEAREST_LINEAR_MIPNEAREST:v.magFilter=9728,v.minFilter=9985;break;case L.e.LINEAR_NEAREST_MIPNEAREST:v.magFilter=9729,v.minFilter=9984;break;case L.e.LINEAR_NEAREST_MIPLINEAR:v.magFilter=9729,v.minFilter=9986;break;case L.e.NEAREST_NEAREST_MIPLINEAR:v.magFilter=9728,v.minFilter=9986;break;case L.e.LINEAR_LINEAR_MIPLINEAR:v.magFilter=9729,v.minFilter=9987;break;case L.e.LINEAR_LINEAR_MIPNEAREST:v.magFilter=9729,v.minFilter=9985;break;case L.e.NEAREST_NEAREST_MIPNEAREST:v.magFilter=9728,v.minFilter=9984}return v}_getGLTFTextureWrapMode(o){switch(o){case L.e.WRAP_ADDRESSMODE:return 10497;case L.e.CLAMP_ADDRESSMODE:return 33071;case L.e.MIRROR_ADDRESSMODE:return 33648;default:return E.Tools.Error(`Unsupported Texture Wrap Mode ${o}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(o,v,V,g){const E={diffuseColor:o._albedoColor,specularColor:o._reflectivityColor,glossiness:o._microSurface},I=o._albedoTexture,Q=o._reflectivityTexture,U=o._useMicroSurfaceFromReflectivityMapAlpha;if(Q&&!U)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((I||Q)&&g){this._exporter._materialNeedsUVsSet.add(o);const g=this._exportTextureSampler(I||Q),U=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(I,Q,E,v),n=this._exporter._textures;if(U.baseColorTextureData){const o=this._exportImage(`baseColor${n.length}`,v,U.baseColorTextureData);V.baseColorTexture=this._exportTextureInfo(o,g,null===I||void 0===I?void 0:I.coordinatesIndex)}if(U.metallicRoughnessTextureData){const o=this._exportImage(`metallicRoughness${n.length}`,v,U.metallicRoughnessTextureData);V.metallicRoughnessTexture=this._exportTextureInfo(o,g,null===Q||void 0===Q?void 0:Q.coordinatesIndex)}return U}return this._convertSpecularGlossinessToMetallicRoughness(E)}async exportPBRMaterialAsync(o,v,V){const g={},E={name:o.name},I=o.isMetallicWorkflow();if(I){const v=o._albedoColor,V=o.alpha;v&&(g.baseColorFactor=[v.r,v.g,v.b,V])}const Q=I?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(o,v,g,V):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(o,v,g,V);await this._setMetallicRoughnessPbrMaterialAsync(Q,o,E,g,v,V),await this._finishMaterialAsync(E,o,v);const U=this._exporter._materials;return U.push(E),U.length-1}async _setMetallicRoughnessPbrMaterialAsync(o,v,V,g,I,Q){if(q(V,v),o.baseColor.equalsWithEpsilon(J,a)&&t.WithinEpsilon(v.alpha,1,a)||(g.baseColorFactor=[o.baseColor.r,o.baseColor.g,o.baseColor.b,v.alpha]),null!=o.metallic&&1!==o.metallic&&(g.metallicFactor=o.metallic),null!=o.roughness&&1!==o.roughness&&(g.roughnessFactor=o.roughness),null==v.cU||v.cU||(v._twoSidedLighting||E.Tools.Warn(v.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),V.doubleSided=!0),Q){const o=[],g=v._bumpTexture;g&&o.push(this.exportTextureAsync(g,I).then((o=>{o&&(V.normalTexture=o,1!==g.level&&(V.normalTexture.scale=g.level))})));const E=v._ambientTexture;E&&o.push(this.exportTextureAsync(E,I).then((o=>{if(o){const g={index:o.index,texCoord:o.texCoord,extensions:o.extensions};V.occlusionTexture=g;const E=v._ambientTextureStrength;E&&(g.strength=E)}})));const Q=v._emissiveTexture;Q&&o.push(this.exportTextureAsync(Q,I).then((o=>{o&&(V.emissiveTexture=o)}))),o.length>0&&(this._exporter._materialNeedsUVsSet.add(v),await Promise.all(o))}const U=v._emissiveColor;U.equalsWithEpsilon(d,a)||(V.emissiveFactor=U.Dg()),V.pbrMetallicRoughness=g}_getPixelsFromTextureAsync(o){return function(o){switch(o){case u.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case u.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case u.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case u.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case u.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case u.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case u.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case u.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case u.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case u.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case u.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case u.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case u.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case u.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case u.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case u.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case u.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case u.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case u.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case u.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case u.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(o.textureFormat)?(0,s.j)(o,o._texture.width,o._texture.height):(o.textureType,u.c.TEXTURETYPE_UNSIGNED_BYTE,o.readPixels())}async exportTextureAsync(o,v){const V=this._exporter._extensionsPreExportTextureAsync("exporter",o,v);return V?await V.then((async V=>V?await this._exportTextureInfoAsync(V,v):await this._exportTextureInfoAsync(o,v))):await this._exportTextureInfoAsync(o,v)}async _exportTextureInfoAsync(o,v){let V=this._textureMap.get(o);if(!V){const g=await this._getPixelsFromTextureAsync(o);if(!g)return null;const I=this._exportTextureSampler(o),Q=o.mimeType;if(Q)switch(Q){case"image/jpeg":case"image/png":case"image/webp":v=Q;break;default:E.Tools.Warn(`Unsupported media type: ${Q}. Exporting texture as PNG.`)}const U=this._internalTextureToImage,n=o.getInternalTexture().uniqueId;U[n]||(U[n]={});let O=U[n][v];if(void 0===O){const V=o.getSize();O=(async()=>{const E=await this._getImageDataAsync(g,V.width,V.height,v);return this._exportImage(o.name,v,E)})(),U[n][v]=O}V=this._exportTextureInfo(await O,I,o.coordinatesIndex),this._textureMap.set(o,V),this._exporter._extensionsPostExportTextures("exporter",V,o)}return V}_exportImage(o,v,V){const g=this._exporter._images;let I;if(this._exporter._shouldUseGlb){I={name:o,mimeType:v,bufferView:void 0};const g=this._exporter._bufferManager.createBufferView(new Uint8Array(V));this._exporter._bufferManager.setBufferView(I,g)}else{const Q=o.replace(/\.\/|\/|\.\\|\\/g,"_"),U=function(o){switch(o){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(v);let n=Q+U;g.some((o=>o.uri===n))&&(n=`${Q}_${E.Tools.RandomId()}${U}`),I={name:o,uri:n},this._exporter._imageData[n]={data:V,mimeType:v}}return g.push(I),g.length-1}_exportTextureInfo(o,v,V){const g=this._exporter._textures;let E=g.findIndex((V=>V.sampler==v&&V.source===o));-1===E&&(E=g.length,g.push({source:o,sampler:v}));const I={index:E};return V&&(I.texCoord=V),I}_exportTextureSampler(o){const v=this._getTextureSampler(o),V=this._exporter._samplers,g=V.findIndex((o=>o.minFilter===v.minFilter&&o.magFilter===v.magFilter&&o.wrapS===v.wrapS&&o.wrapT===v.wrapT));return-1!==g?g:(V.push(v),V.length-1)}}var w=V(12585),z=V(12308),y=V(13005),H=V(12497);const e=g.cv.Zero(),D=g.Quaternion.Identity(),Z=g.cv.One(),K=new g.cv(-1,1,1);function X(o,v){const{byteOffset:V,byteStride:g,type:E,normalized:I}=o,Q=o.getSize(),U=v.reduce(((o,v)=>v.getTotalVertices()>o?v.getTotalVertices():o),-Number.MAX_VALUE);return{byteOffset:V,byteStride:g,componentCount:Q,type:E,count:U*Q,normalized:I,totalVertices:U,kind:o.getKind()}}function r(o){switch(o){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function B(o){switch(o){case h.e.PositionKind:case h.e.NormalKind:case h.e.TangentKind:case h.e.ColorKind:case h.e.MatricesIndicesKind:case h.e.MatricesIndicesExtraKind:case h.e.MatricesWeightsKind:case h.e.MatricesWeightsExtraKind:case h.e.UVKind:case h.e.UV2Kind:case h.e.UV3Kind:case h.e.UV4Kind:case h.e.UV5Kind:case h.e.UV6Kind:return!0}return!1}function A(o){switch(o){case I.e.TriangleFillMode:return 4;case I.e.TriangleStripDrawMode:return 5;case I.e.TriangleFanDrawMode:return 6;case I.e.PointListDrawMode:case I.e.PointFillMode:return 0;case I.e.LineLoopDrawMode:return 2;case I.e.LineListDrawMode:return 1;case I.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${o}`)}function C(o){const v=Math.sqrt(o.x*o.x+o.y*o.y+o.z*o.z);v>0&&(o.x/=v,o.y/=v,o.z/=v)}function p(o){return o.x*=-1,o}function G(o){if(o.x*o.x+o.y*o.y>.5){const v=Math.abs(o.x),V=Math.abs(o.y);if(v>V){const V=Math.sign(o.x);o.x=v,o.y*=-V,o.z*=-V,o.w*=V}else{const v=Math.sign(o.y);o.x*=-v,o.y=V,o.z*=v,o.w*=-v}}else{const v=Math.abs(o.z),V=Math.abs(o.w);if(v>V){const V=Math.sign(o.z);o.x*=-V,o.y*=V,o.z=v,o.w*=-V}else{const v=Math.sign(o.w);o.x*=v,o.y*=-v,o.z*=-v,o.w=V}}return o}function k(o){o.RU(-o.z,o.w,o.x,-o.y)}function oo(o,v){const V=g.cv.FromArrayToRef(v.translation||[0,0,0],0,g.TmpVectors.cv[0]),E=g.Quaternion.FromArrayToRef(v.rotation||[0,0,0,1],0,g.TmpVectors.Quaternion[0]),I=g.Matrix.ComposeToRef(Z,E,V,g.TmpVectors.Matrix[0]),Q=g.cv.FromArrayToRef(o.translation||[0,0,0],0,g.TmpVectors.cv[2]),U=g.Quaternion.FromArrayToRef(o.rotation||[0,0,0,1],0,g.TmpVectors.Quaternion[1]),n=g.Matrix.ComposeToRef(Z,U,Q,g.TmpVectors.Matrix[1]);I.multiplyToRef(n,n),n.decompose(void 0,E,V),V.equalsWithEpsilon(e,H.d)?delete v.translation:v.translation=V.Dg(),E.equalsWithEpsilon(D,H.d)?delete v.rotation:v.rotation=E.Dg(),v.scale&&delete v.scale}function vo(o,v){if(!(v instanceof x.b))return!1;if(!(1===v.getChildren().length&&0===o.getChildren().length&&o.parent===v))return!1;const V=o.Fo(),g=o instanceof y.c&&!V.useRightHandedSystem?K:Z;return!!v.jU.equalsWithEpsilon(g,H.d)||(z.b.Warn(`Cannot collapse node ${o.name} into parent node ${v.name} with modified scaling.`),!1)}function Vo(o){if(o instanceof Array){const v=new Float32Array(o);return new Uint8Array(v.buffer,v.byteOffset,v.byteLength)}return ArrayBuffer.isView(o)?new Uint8Array(o.buffer,o.byteOffset,o.byteLength):new Uint8Array(o)}function go(o,v){for(const[V,g]of Object.entries(o)){const E=v[V];(Array.isArray(g)&&Array.isArray(E)&&Eo(g,E)||g===E)&&delete o[V]}return o}function Eo(o,v){return o.length===v.length&&o.every(((o,V)=>o===v[V]))}const Io=g.Matrix.Compose(new g.cv(-1,1,1),g.Quaternion.Identity(),g.cv.Zero());function Qo(o,v){if(!(o instanceof x.b))return!1;if(v){if(!o.getWorldMatrix().equalsWithEpsilon(g.Matrix.IdentityReadOnly,H.d))return!1}else{if(!o.getWorldMatrix().multiplyToRef(Io,g.TmpVectors.Matrix[0]).equalsWithEpsilon(g.Matrix.IdentityReadOnly,H.d))return!1}return!(o instanceof f.d&&o.kg)}const Uo=new Map([[Int8Array,(o,v,V)=>o.setInt8(v,V)],[Uint8Array,(o,v,V)=>o.setUint8(v,V)],[Uint8ClampedArray,(o,v,V)=>o.setUint8(v,V)],[Int16Array,(o,v,V)=>o.setInt16(v,V,!0)],[Uint16Array,(o,v,V)=>o.setUint16(v,V,!0)],[Int32Array,(o,v,V)=>o.setInt32(v,V,!0)],[Uint32Array,(o,v,V)=>o.setUint32(v,V,!0)],[Float32Array,(o,v,V)=>o.setFloat32(v,V,!0)],[Float64Array,(o,v,V)=>o.setFloat64(v,V,!0)]]);class no{writeTypedArray(o){this._checkGrowBuffer(o.byteLength);const v=Uo.get(o.constructor);for(let V=0;V<o.length;V++)v(this._dataView,this._byteOffset,o[V]),this._byteOffset+=o.BYTES_PER_ELEMENT}constructor(o){this._data=new Uint8Array(o),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(o){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,o),this._byteOffset++}writeInt8(o){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,o),this._byteOffset++}writeInt16(o){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,o,!0),this._byteOffset+=2}writeUInt16(o){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,o,!0),this._byteOffset+=2}writeInt32(o){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,o,!0),this._byteOffset+=4}writeUInt32(o){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,o,!0),this._byteOffset+=4}writeFloat32(o){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,o,!0),this._byteOffset+=4}writeFloat64(o){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,o,!0),this._byteOffset+=8}_checkGrowBuffer(o){const v=this.byteOffset+o;if(v>this._data.byteLength){const o=new Uint8Array(2*v);o.set(this._data),this._data=o,this._dataView=new DataView(this._data.buffer)}}}function Oo(o){return o%4===0?4:o%2===0?2:1}class ho{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(o){let v=0;this._bufferViewToData.forEach((o=>{v+=o.byteLength}));const V=new no(v),g=Array.from(this._bufferViewToData.keys()).sort(((o,v)=>Oo(v.byteLength)-Oo(o.byteLength)));for(const E of g){E.byteOffset=V.byteOffset,o.push(E);const v=o.length-1,g=this.getPropertiesWithBufferView(E);for(const o of g)o.bufferView=v;V.writeTypedArray(this._bufferViewToData.get(E)),this._bufferViewToData.delete(E)}return V.getOutputData()}createBufferView(o,v){const V={buffer:0,byteOffset:void 0,byteLength:o.byteLength,byteStride:v};return this._bufferViewToData.set(V,o),V}createAccessor(o,v,V,g,E,I,Q){this._verifyBufferView(o);const U={bufferView:void 0,componentType:V,count:g,type:v,min:null===I||void 0===I?void 0:I.min,max:null===I||void 0===I?void 0:I.max,normalized:Q,byteOffset:E};return this.setBufferView(U,o),this._accessorToBufferView.set(U,o),U}setBufferView(o,v){this._verifyBufferView(v);this.getPropertiesWithBufferView(v).push(o)}removeBufferView(o){const v=this.getPropertiesWithBufferView(o);for(const V of v)void 0!==V.bufferView&&delete V.bufferView;this._bufferViewToData.delete(o),this._bufferViewToProperties.delete(o),this._accessorToBufferView.forEach(((v,V)=>{v===o&&(void 0!==V.byteOffset&&delete V.byteOffset,this._accessorToBufferView.delete(V))}))}getBufferView(o){const v=this._accessorToBufferView.get(o);return this._verifyBufferView(v),v}getPropertiesWithBufferView(o){return this._verifyBufferView(o),this._bufferViewToProperties.set(o,this._bufferViewToProperties.get(o)??[]),this._bufferViewToProperties.get(o)}getData(o){return this._verifyBufferView(o),this._bufferViewToData.get(o)}_verifyBufferView(o){if(void 0===o||!this._bufferViewToData.has(o))throw new Error(`BufferView ${o} not found in BufferManager.`)}}var xo,fo=V(12967),lo=V(12981),So=V(13011),To=V(12888),co=V(13035),Ro=V(13047),jo=V(12958),to=V(13049);!function(o){o[o.INTANGENT=0]="INTANGENT",o[o.OUTTANGENT=1]="OUTTANGENT"}(xo||(xo={}));class so{static _IsTransformable(o){return o&&(o instanceof x.b||o instanceof fo.e||o instanceof to.c)}static _CreateNodeAnimation(o,v,V,g,I){if(this._IsTransformable(o)){const Q=[],U=[],n=v.getKeys(),O=so._CalculateMinMaxKeyFrames(n),h=so._DeduceInterpolation(n,V,g),x=h.interpolationType,f=h.shouldBakeAnimation;if(f?so._CreateBakedAnimation(o,v,V,O.min,O.max,v.framePerSecond,I,Q,U,O,g):"LINEAR"===x||"STEP"===x?so._CreateLinearOrStepAnimation(o,v,V,Q,U,g):"CUBICSPLINE"===x?so._CreateCubicSplineAnimation(o,v,V,Q,U,g):so._CreateBakedAnimation(o,v,V,O.min,O.max,v.framePerSecond,I,Q,U,O,g),Q.length&&U.length){return{inputs:Q,outputs:U,samplerInterpolation:x,inputsMin:f?O.min:E.Tools.FloatRound(O.min/v.framePerSecond),inputsMax:f?O.max:E.Tools.FloatRound(O.max/v.framePerSecond)}}}return null}static _DeduceAnimationInfo(o){let v=null,V="VEC3",g=!1;const I=o.targetProperty.split(".");switch(I[0]){case"jU":v="scale";break;case"position":v="translation";break;case"rotation":V="VEC4",v="rotation";break;case"rotationQuaternion":V="VEC4",g=!0,v="rotation";break;case"influence":V="SCALAR",v="weights";break;default:E.Tools.Error(`Unsupported animatable property ${I[0]}`)}return v?{animationChannelTargetPath:v,dataAccessorType:V,useQuaternion:g}:(E.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(o,v,V,g,E,I,Q,U,n,O,h){let x;if(so._IsTransformable(o)&&o.animations)for(const f of o.animations){if(h&&!h(f))continue;const E=so._DeduceAnimationInfo(f);E&&(x={name:f.name,samplers:[],channels:[]},so._AddAnimation(`${f.name}`,f.hasRunningRuntimeAnimations?v:x,o,f,E.dataAccessorType,E.animationChannelTargetPath,g,I,Q,U,E.useQuaternion,n,O),x.samplers.length&&x.channels.length&&V.push(x))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(o,v,V,g,E,I,Q,U,n,O,h){let x;if(o instanceof jo.e){const E=o.morphTargetManager;if(E)for(let f=0;f<E.numTargets;++f){const l=E.getTarget(f);for(const S of l.animations){if(h&&!h(S))continue;const l=new co.b(`${S.name}`,"influence",S.framePerSecond,S.dataType,S.loopMode,S.enableBlending),T=[],c=S.getKeys();for(let o=0;o<c.length;++o){const v=c[o];for(let o=0;o<E.numTargets;++o)o==f?T.push(v):T.push({frame:v.frame,value:0})}l.setKeys(T);const R=so._DeduceAnimationInfo(l);R&&(x={name:l.name,samplers:[],channels:[]},so._AddAnimation(S.name,S.hasRunningRuntimeAnimations?v:x,o,l,R.dataAccessorType,R.animationChannelTargetPath,g,I,Q,U,R.useQuaternion,n,O,E.numTargets),x.samplers.length&&x.channels.length&&V.push(x))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(o,v,V,g,E,I,Q,U,n){let O;if(o.animationGroups){const x=o.animationGroups;for(const f of x){const x=new Map,l=new Map,S=new Set,T=f.to-f.from;O={name:f.name,channels:[],samplers:[]};for(let v=0;v<f.targetedAnimations.length;++v){const T=f.targetedAnimations[v],c=T.target,R=T.animation;if(n&&!n(R))continue;const j=U.has(c);if(this._IsTransformable(c)||1===c.length&&this._IsTransformable(c[0])){const o=so._DeduceAnimationInfo(T.animation);if(o){const v=this._IsTransformable(c)?c:this._IsTransformable(c[0])?c[0]:null;v&&so._AddAnimation(`${R.name}`,O,v,R,o.dataAccessorType,o.animationChannelTargetPath,V,g,E,I,o.useQuaternion,Q,j)}}else if(c instanceof Ro.d||1===c.length&&c[0]instanceof Ro.d){if(so._DeduceAnimationInfo(T.animation)){const v=c instanceof Ro.d?c:c[0];if(v){const V=o.morphTargetManagers.find((o=>{for(let V=0;V<o.numTargets;++V)if(o.getTarget(V)===v)return!0;return!1}));if(V){const g=o.meshes.find((o=>o.morphTargetManager===V));var h;if(g)x.has(g)||x.set(g,new Map),null===(h=x.get(g))||void 0===h||h.set(v,R),S.add(g),l.set(g,R)}}}}}S.forEach((o=>{const v=o.morphTargetManager;let U=null;const n=[],h=l.get(o).getKeys(),S=h.length;for(let V=0;V<S;++V)for(let g=0;g<v.numTargets;++g){const E=v.getTarget(g),I=x.get(o);if(I){const v=I.get(E);v?(U||(U=new co.b(`${f.name}_${o.name}_MorphWeightAnimation`,"influence",v.framePerSecond,co.b.ANIMATIONTYPE_FLOAT,v.loopMode,v.enableBlending)),n.push(v.getKeys()[V])):n.push({frame:f.from+T/S*V,value:E.influence,inTangent:h[0].inTangent?0:void 0,outTangent:h[0].outTangent?0:void 0})}}U.setKeys(n);const c=so._DeduceAnimationInfo(U);c&&so._AddAnimation(`${f.name}_${o.name}_MorphWeightAnimation`,O,o,U,c.dataAccessorType,c.animationChannelTargetPath,V,g,E,I,c.useQuaternion,Q,!1,null===v||void 0===v?void 0:v.numTargets)})),O.channels.length&&O.samplers.length&&v.push(O)}}}static _AddAnimation(o,v,V,E,I,Q,U,n,O,h,x,f,l,S){const T=so._CreateNodeAnimation(V,E,Q,x,f);let c,R,j,t,s,L;if(T){if(S){let o=0,v=0;const V=[];for(;T.inputs.length>0;)v=T.inputs.shift(),o%S==0&&V.push(v),o++;T.inputs=V}const o=U.get(V),E=new Float32Array(T.inputs);c=n.createBufferView(E),R=n.createAccessor(c,"SCALAR",5126,T.inputs.length,void 0,{min:[T.inputsMin],max:[T.inputsMax]}),h.push(R),j=h.length-1;const O=new g.Quaternion,x=new g.cv,f=new g.cv,b=V instanceof fo.e,u=r(I),mo=new Float32Array(T.outputs.length*u);T.outputs.forEach((function(o,v){let V=o;switch(Q){case"translation":l&&(g.cv.FromArrayToRef(o,0,f),p(f),f.toArray(V));break;case"rotation":4===o.length?g.Quaternion.FromArrayToRef(o,0,O):(V=new Array(4),g.cv.FromArrayToRef(o,0,x),g.Quaternion.FromEulerVectorToRef(x,O)),l&&(G(O),b&&k(O)),O.toArray(V)}mo.set(V,v*u)})),c=n.createBufferView(mo),R=n.createAccessor(c,I,5126,T.outputs.length),h.push(R),t=h.length-1,s={interpolation:T.samplerInterpolation,input:j,output:t},v.samplers.push(s),L={sampler:v.samplers.length-1,target:{node:o,path:Q}},v.channels.push(L)}}static _CreateBakedAnimation(o,v,V,I,Q,U,n,O,h,x,f){let l;const S=g.Quaternion.Identity();let T,c=null,R=null,j=null,t=null,s=null,L=null;x.min=E.Tools.FloatRound(I/U);const b=v.getKeys();for(let g=0,u=b.length;g<u;++g){if(L=null,j=b[g],g+1<u)if(t=b[g+1],j.value.equals&&j.value.equals(t.value)||j.value===t.value){if(0!==g)continue;L=j.frame}else L=t.frame;else{if(s=b[g-1],j.value.equals&&j.value.equals(s.value)||j.value===s.value)continue;L=Q}if(L)for(let g=j.frame;g<=L;g+=n){if(T=E.Tools.FloatRound(g/U),T===c)continue;c=T,R=T;const I={key:0,repeatCount:0,loopMode:v.loopMode};l=v._interpolate(g,I),so._SetInterpolatedValue(o,l,T,v,V,S,O,h,f)}}R&&(x.max=R)}static _ConvertFactorToVector3OrQuaternion(o,v,V,I,Q){const U=so._GetBasePositionRotationOrScale(v,I,Q),n=V.targetProperty.split("."),O=n?n[1]:"",h=Q?g.Quaternion.bv(U).normalize():g.cv.bv(U);switch(O){case"x":case"y":case"z":h[O]=o;break;case"w":h.w=o;break;default:E.Tools.Error(`glTFAnimation: Unsupported component name "${O}"!`)}return h}static _SetInterpolatedValue(o,v,V,E,I,Q,U,n,O){let h;U.push(V),"weights"!==I?(E.dataType===co.b.ANIMATIONTYPE_FLOAT&&(v=this._ConvertFactorToVector3OrQuaternion(v,o,E,I,O)),"rotation"===I?(O?Q=v:(h=v,g.Quaternion.RotationYawPitchRollToRef(h.y,h.x,h.z,Q)),n.push(Q.Dg())):(h=v,n.push(h.Dg()))):n.push([v])}static _CreateLinearOrStepAnimation(o,v,V,g,E,I){for(const Q of v.getKeys())g.push(Q.frame/v.framePerSecond),so._AddKeyframeValue(Q,v,E,V,o,I)}static _CreateCubicSplineAnimation(o,v,V,g,E,I){v.getKeys().forEach((function(Q){g.push(Q.frame/v.framePerSecond),so._AddSplineTangent(xo.INTANGENT,E,V,"CUBICSPLINE",Q,I),so._AddKeyframeValue(Q,v,E,V,o,I),so._AddSplineTangent(xo.OUTTANGENT,E,V,"CUBICSPLINE",Q,I)}))}static _GetBasePositionRotationOrScale(o,v,V){let E;if("rotation"===v)if(V){E=(o.rotationQuaternion??g.Quaternion.Identity()).Dg()}else{E=(o.rotation??g.cv.Zero()).Dg()}else if("translation"===v){E=(o.position??g.cv.Zero()).Dg()}else{E=(o.jU??g.cv.One()).Dg()}return E}static _AddKeyframeValue(o,v,V,I,Q,U){let n;const O=v.dataType;if(O===co.b.ANIMATIONTYPE_VECTOR3){let v=o.value.Dg();if("rotation"===I){const o=g.cv.bv(v);v=g.Quaternion.RotationYawPitchRoll(o.y,o.x,o.z).Dg()}V.push(v)}else if(O===co.b.ANIMATIONTYPE_FLOAT){if("weights"===I)V.push([o.value]);else if(n=this._ConvertFactorToVector3OrQuaternion(o.value,Q,v,I,U),n){if("rotation"===I){const o=U?n:g.Quaternion.RotationYawPitchRoll(n.y,n.x,n.z).normalize();V.push(o.Dg())}V.push(n.Dg())}}else O===co.b.ANIMATIONTYPE_QUATERNION?V.push(o.value.normalize().Dg()):E.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(o,v,V){let g,E,I=!1;if("rotation"===v&&!V)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let Q=0,U=o.length;Q<U;++Q)if(E=o[Q],E.inTangent||E.outTangent)if(g){if("CUBICSPLINE"!==g){g="LINEAR",I=!0;break}}else g="CUBICSPLINE";else if(g){if("CUBICSPLINE"===g||E.interpolation&&1===E.interpolation&&"STEP"!==g){g="LINEAR",I=!0;break}}else g=E.interpolation&&1===E.interpolation?"STEP":"LINEAR";return g||(g="LINEAR"),{interpolationType:g,shouldBakeAnimation:I}}static _AddSplineTangent(o,v,V,E,I,Q){let U;const n=o===xo.INTANGENT?I.inTangent:I.outTangent;if("CUBICSPLINE"===E){if("rotation"===V)if(n)if(Q)U=n.Dg();else{const o=n;U=g.Quaternion.RotationYawPitchRoll(o.y,o.x,o.z).Dg()}else U=[0,0,0,0];else U="weights"===V?n?[n]:[0]:n?n.Dg():[0,0,0];v.push(U)}}static _CalculateMinMaxKeyFrames(o){let v=1/0,V=-1/0;return o.forEach((function(o){v=Math.min(v,o.frame),V=Math.max(V,o.frame)})),{min:v,max:V}}}function Lo(o,v,V,I,Q,U){const n={attributes:{},influence:o.influence,name:o.name},O=v.kg;if(!O)return E.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),n;const x=U?-1:1,f=g.cv.Zero();let l=0,S=0;if(o.hasPositions){const I=o.getPositions(),U=O.getVerticesData(h.e.PositionKind);if(U){const o=new Float32Array(U.length),v=[1/0,1/0,1/0],E=[-1/0,-1/0,-1/0];S=U.length/3,l=0;for(let V=l;V<S;++V){const Q=g.cv.bv(U,3*V);g.cv.bv(I,3*V).subtractToRef(Q,f),f.x*=x,v[0]=Math.min(v[0],f.x),E[0]=Math.max(E[0],f.x),v[1]=Math.min(v[1],f.y),E[1]=Math.max(E[1],f.y),v[2]=Math.min(v[2],f.z),E[2]=Math.max(E[2],f.z),o[3*V]=f.x,o[3*V+1]=f.y,o[3*V+2]=f.z}const O=V.createBufferView(o,12),h=V.createAccessor(O,"VEC3",5126,I.length/3,0,{min:v,max:E});Q.push(h),n.attributes.POSITION=Q.length-1}else E.Tools.Warn(`Morph target positions for mesh ${v.name} were not exported. Mesh does not have position vertex data`)}if(o.hasNormals){const I=o.getNormals(),U=O.getVerticesData(h.e.NormalKind);if(U){const o=new Float32Array(U.length);S=U.length/3,l=0;for(let V=l;V<S;++V){const v=g.cv.bv(U,3*V).normalize();g.cv.bv(I,3*V).normalize().subtractToRef(v,f),o[3*V]=f.x*x,o[3*V+1]=f.y,o[3*V+2]=f.z}const v=V.createBufferView(o,12),E=V.createAccessor(v,"VEC3",5126,I.length/3,0);Q.push(E),n.attributes.NORMAL=Q.length-1}else E.Tools.Warn(`Morph target normals for mesh ${v.name} were not exported. Mesh does not have normals vertex data`)}if(o.hasTangents){const I=o.getTangents(),U=O.getVerticesData(h.e.TangentKind);if(U){S=U.length/4;const o=new Float32Array(3*S);l=0;for(let V=l;V<S;++V){const v=g.cv.bv(U,4*V);C(v);const E=g.cv.bv(I,3*V);C(E),E.subtractToRef(v,f),o[3*V]=f.x*x,o[3*V+1]=f.y,o[3*V+2]=f.z}const v=V.createBufferView(o,12),E=V.createAccessor(v,"VEC3",5126,S,0);Q.push(E),n.attributes.TANGENT=Q.length-1}else E.Tools.Warn(`Morph target tangents for mesh ${v.name} were not exported. Mesh does not have tangents vertex data`)}if(o.hasColors){const I=o.getColors(),U=O.getVerticesData(h.e.ColorKind),x=O.getVertexBuffer(h.e.ColorKind);if(U&&x){const o=x.getSize();S=U.length/o;const v=new Float32Array(S*o);l=0;for(let V=l;V<S;++V)if(3===o){const E=g.cv.bv(U,V*o);g.cv.bv(I,V*o).subtractToRef(E,f),v[3*V]=f.x,v[3*V+1]=f.y,v[3*V+2]=f.z}else if(4===o){const E=new g.Vector4,Q=g.Vector4.bv(U,V*o);g.Vector4.bv(I,V*o).subtractToRef(Q,E),v[4*V]=E.x,v[4*V+1]=E.y,v[4*V+2]=E.z,v[4*V+3]=E.w}else E.Tools.Warn(`Unsupported number of components for color attribute: ${o}`);const O=V.createBufferView(v,4*o),h=V.createAccessor(O,3===o?"VEC3":"VEC4",5126,S,0);Q.push(h),n.attributes.COLOR_0=Q.length-1}else E.Tools.Warn(`Morph target colors for mesh ${v.name} were not exported. Mesh does not have colors vertex data`)}return n}var bo=V(13052),uo=V(12910),mv=V(12892),ao=V(12449);class Fo{}Fo.DEFAULT_COLOR=c.Lv.White(),Fo.DEFAULT_WIDTH_ATTENUATED=1,Fo.DEFAULT_WIDTH=.1;var io=V(12719),Jo=V(13058);class No{static ConvertPoints(o,v){if(o.length&&Array.isArray(o)&&"number"===typeof o[0])return[o];if(o.length&&Array.isArray(o[0])&&"number"===typeof o[0][0])return o;if(o.length&&!Array.isArray(o[0])&&o[0]instanceof g.cv){const v=[];for(let V=0;V<o.length;V++){const g=o[V];v.push(g.x,g.y,g.z)}return[v]}if(o.length>0&&Array.isArray(o[0])&&o[0].length>0&&o[0][0]instanceof g.cv){const v=[],V=o;for(const o of V)v.push(o.flatMap((o=>[o.x,o.y,o.z])));return v}if(o instanceof Float32Array){if(null!==v&&void 0!==v&&v.floatArrayStride){const V=[],g=3*v.floatArrayStride;for(let v=0;v<o.length;v+=g){const E=new Array(g);for(let V=0;V<g;V++)E[V]=o[v+V];V.push(E)}return V}return[Array.from(o)]}if(o.length&&o[0]instanceof Float32Array){const v=[];for(const V of o)v.push(Array.from(V));return v}return[]}static OmitZeroLengthPredicate(o,v,V){const g=[];return v.Rv(o).lengthSquared()>0&&g.push([o,v]),V.Rv(v).lengthSquared()>0&&g.push([v,V]),o.Rv(V).lengthSquared()>0&&g.push([V,o]),0===g.length?null:g}static OmitDuplicatesPredicate(o,v,V,g){const E=[];return No._SearchInPoints(o,v,g)||E.push([o,v]),No._SearchInPoints(v,V,g)||E.push([v,V]),No._SearchInPoints(V,o,g)||E.push([V,o]),0===E.length?null:E}static _SearchInPoints(o,v,V){for(const Q of V)for(let V=0;V<Q.length;V++){var g,E,I;if(null!==(g=Q[V])&&void 0!==g&&g.equals(o))if(null!==(E=Q[V+1])&&void 0!==E&&E.equals(v)||null!==(I=Q[V-1])&&void 0!==I&&I.equals(v))return!0}return!1}static MeshesToLines(o,v){const V=[];for(let E=0;E<o.length;E++){const I=o[E],Q=I.getVerticesData(h.e.PositionKind),U=I.QQ();if(Q&&U)for(let o=0,n=0;o<U.length;o++){const O=3*U[n++],h=3*U[n++],x=3*U[n++],f=new g.cv(Q[O],Q[O+1],Q[O+2]),l=new g.cv(Q[h],Q[h+1],Q[h+2]),S=new g.cv(Q[x],Q[x+1],Q[x+2]);if(v){const g=v(f,l,S,V,o,O,I,E,Q,U);if(g)for(const o of g)V.push(o)}else V.push([f,l],[l,S],[S,f])}}return V}static ToVector3Array(o){if(Array.isArray(o[0])){const v=[],V=o;for(const o of V){const V=[];for(let v=0;v<o.length;v+=3)V.push(new g.cv(o[v],o[v+1],o[v+2]));v.push(V)}return v}const v=o,V=[];for(let E=0;E<v.length;E+=3)V.push(new g.cv(v[E],v[E+1],v[E+2]));return V}static ToNumberArray(o){return o.flatMap((o=>[o.x,o.y,o.z]))}static GetPointsCountInfo(o){const v=new Array(o.length);let V=0;for(let g=o.length;g--;)v[g]=o[g].length/3,V+=v[g];return{total:V,counts:v}}static GetLineLength(o){if(0===o.length)return 0;let v;v="number"===typeof o[0]?No.ToVector3Array(o):o;const V=g.TmpVectors.cv[0];let E=0;for(let g=0;g<v.length-1;g++){const o=v[g];E+=v[g+1].subtractToRef(o,V).length()}return E}static GetLineLengthArray(o){const v=new Float32Array(o.length/3);let V=0;for(let g=0,E=o.length/3-1;g<E;g++){let E=o[3*g+0],I=o[3*g+1],Q=o[3*g+2];E-=o[3*g+3],I-=o[3*g+4],Q-=o[3*g+5];V+=Math.sqrt(E*E+I*I+Q*Q),v[g+1]=V}return v}static SegmentizeSegmentByCount(o,v,V){const E=[],I=v.Rv(o),Q=g.TmpVectors.cv[0];Q.tU(V);const U=g.TmpVectors.cv[1];I.divideToRef(Q,U);let n=o.clone();E.push(n);for(let g=0;g<V;g++)n=n.clone(),E.push(n.addInPlace(U));return E}static SegmentizeLineBySegmentLength(o,v){const V=o[0]instanceof g.cv?No.GetLineSegments(o):"number"===typeof o[0]?No.GetLineSegments(No.ToVector3Array(o)):o,E=[];for(const g of V)if(g.length>v){const o=No.SegmentizeSegmentByCount(g.point1,g.point2,Math.ceil(g.length/v));for(const v of o)E.push(v)}else E.push(g.point1),E.push(g.point2);return E}static SegmentizeLineBySegmentCount(o,v){const V="number"===typeof o[0]?No.ToVector3Array(o):o,g=No.GetLineLength(V)/v;return No.SegmentizeLineBySegmentLength(V,g)}static GetLineSegments(o){const v=[];for(let V=0;V<o.length-1;V++){const g=o[V],E=o[V+1],I=E.Rv(g).length();v.push({point1:g,point2:E,length:I})}return v}static GetMinMaxSegmentLength(o){const v=No.GetLineSegments(o).sort((o=>o.length));return{min:v[0].length,max:v[v.length-1].length}}static GetPositionOnLineByVisibility(o,v,V){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const I=v*V;let Q=0,U=0;const n=o.length;for(let g=0;g<n;g++){if(I<=Q+o[g].length){U=g;break}Q+=o[g].length}const O=(I-Q)/o[U].length;return o[U].point2.subtractToRef(o[U].point1,g.TmpVectors.cv[0]),g.TmpVectors.cv[1]=g.TmpVectors.cv[0].multiplyByFloats(O,O,O),E||g.TmpVectors.cv[1].addInPlace(o[U].point1),g.TmpVectors.cv[1].clone()}static GetCircleLinePoints(o,v){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:o,I=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/v;const Q=[];for(let U=0;U<=v;U++)Q.push(new g.cv(Math.cos(U*I)*o,Math.sin(U*I)*E,V));return Q}static GetBezierLinePoints(o,v,V,g){return io.h.CreateQuadraticBezier(o,v,V,g).getPoints().flatMap((o=>[o.x,o.y,o.z]))}static GetArrowCap(o,v,V,g,E){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[o.clone(),o.add(v.multiplyByFloats(V,V,V))],widths:[g,E,I,Q]}}static GetPointsFromText(o,v,V,g){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,I=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const Q=[],U=(0,Jo.c)(o,v,V,g);for(const n of U){for(const o of n.paths){const v=[],V=o.getPoints();for(const o of V)v.push(o.x,o.y,E);Q.push(v)}if(I)for(const o of n.holes){const v=[],V=o.getPoints();for(const o of V)v.push(o.x,o.y,E);Q.push(v)}}return Q}static Color3toRGBAUint8(o){const v=new Uint8Array(4*o.length);for(let V=0,g=0;V<o.length;V++)v[g++]=255*o[V].r,v[g++]=255*o[V].g,v[g++]=255*o[V].b,v[g++]=255;return v}static CreateColorsTexture(o,v,V,g){const E=g.getEngine().getCaps().maxTextureSize??1,I=v.length>E?E:v.length,Q=Math.ceil(v.length/E);Q>1&&(v=[...v,...Array(I*Q-v.length).fill(v[0])]);const U=No.Color3toRGBAUint8(v),n=new b.e(U,I,Q,S.c.TEXTUREFORMAT_RGBA,g,!1,!0,V);return n.name=o,n}static PrepareEmptyColorsTexture(o){if(!Fo.EmptyColorsTexture){const v=new Uint8Array(4);Fo.EmptyColorsTexture=new b.e(v,1,1,S.c.TEXTUREFORMAT_RGBA,o,!1,!1,b.e.NEAREST_NEAREST),Fo.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Fo.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var o;null===(o=Fo.EmptyColorsTexture)||void 0===o||o.dispose(),Fo.EmptyColorsTexture=null}static BooleanToNumber(o){return o?1:0}}class Yo extends mv.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class qo extends uo.c{isCompatible(o){return!0}constructor(o,v,V){var E;V=V||{color:Fo.DEFAULT_COLOR};const I=new Yo;I.GREASED_LINE_HAS_COLOR=!!V.color&&!V.useColors,I.GREASED_LINE_SIZE_ATTENUATION=V.sizeAttenuation??!1,I.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===V.colorDistributionType,I.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(v??o.Fo()).useRightHandedSystem,I.GREASED_LINE_CAMERA_FACING=V.cameraFacing??!0,super(o,qo.GREASED_LINE_MATERIAL_NAME,200,I,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(E=V)||void 0===E?void 0:E.forceGLSL)||qo.ForceGLSL,this._scene=v??o.Fo(),this._engine=this._scene.getEngine(),this._cameraFacing=V.cameraFacing??!0,this.visibility=V.visibility??1,this.useDash=V.useDash??!1,this.dashRatio=V.dashRatio??.5,this.dashOffset=V.dashOffset??0,this.width=V.width?V.width:V.sizeAttenuation?Fo.DEFAULT_WIDTH_ATTENUATED:Fo.DEFAULT_WIDTH,this._sizeAttenuation=V.sizeAttenuation??!1,this.colorMode=V.colorMode??0,this._color=V.color??null,this.useColors=V.useColors??!1,this._colorsDistributionType=V.colorDistributionType??0,this.colorsSampling=V.colorsSampling??b.e.NEAREST_NEAREST,this._colors=V.No??null,this.dashCount=V.dashCount??1,this.resolution=V.resolution??new g.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),V.colorsTexture?this.colorsTexture=V.colorsTexture:this._colors?this.colorsTexture=No.CreateColorsTexture(`${o.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Fo.DEFAULT_COLOR,No.PrepareEmptyColorsTexture(this._scene)),this._engine.Tg.add((()=>{No.DisposeEmptyColorsTexture()}))}getAttributes(o){o.push("grl_offsets"),o.push("grl_widths"),o.push("grl_colorPointers"),o.push("grl_counters"),this._cameraFacing?(o.push("grl_previousAndSide"),o.push("grl_nextAndCounters")):o.push("grl_slopes")}getSamplers(o){o.push("grl_colors")}getActiveTextures(o){this.colorsTexture&&o.push(this.colorsTexture)}getUniforms(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const v=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&v.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===o&&v.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:v,vertex:this._cameraFacing&&this._isGLSL(o)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(o)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(o){if(this._cameraFacing){o.Bg("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||o.Bg("viewProjection",this._scene.getTransformMatrix());const v=g.TmpVectors.Vector4[0];v.x=this._aspect,v.y=this._resolution.x,v.z=this._resolution.y,v.w=this.width,o.updateVector4("grl_aspect_resolution_lineWidth",v)}const v=g.TmpVectors.Vector4[0];v.x=No.BooleanToNumber(this.useDash),v.y=this._dashArray,v.z=this.dashOffset,v.w=this.dashRatio,o.updateVector4("grl_dashOptions",v);const V=g.TmpVectors.Vector4[1];V.x=this.colorMode,V.y=this.visibility,V.z=this.colorsTexture?this.colorsTexture.getSize().width:0,V.w=No.BooleanToNumber(this.useColors),o.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",V),this._color&&o.updateColor3("grl_singleColor",this._color);const E=this.colorsTexture??Fo.EmptyColorsTexture;o.setTexture("grl_colors",E),o.updateFloat2("grl_textureSize",(null===E||void 0===E?void 0:E.getSize().width)??1,(null===E||void 0===E?void 0:E.getSize().height)??1)}prepareDefines(o,v,V){o.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,o.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,o.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,o.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=v.useRightHandedSystem,o.GREASED_LINE_CAMERA_FACING=this._cameraFacing,o.GREASED_LINE_USE_OFFSETS=!!V.offsets}getClassName(){return qo.GREASED_LINE_MATERIAL_NAME}getCustomCode(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(v)?function(o,v){if("vertex"===o){const o={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return v&&(o["!gl_Position\\=viewProjection\\*worldPos;"]="//"),o}return"fragment"===o?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(o,this._cameraFacing):function(o,v){if("vertex"===o){const o={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return v&&(o["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),o}return"fragment"===o?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(o,this._cameraFacing)}dispose(){var o;null===(o=this.colorsTexture)||void 0===o||o.dispose(),super.dispose()}get No(){return this._colors}set No(o){this.setColors(o)}setColors(o){var v;let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1],g=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(v=this._colors)||void 0===v?void 0:v.length)??0;var I;if(this._colors=o,null!==o&&0!==o.length){if(!V||g)if(this.colorsTexture&&E===o.length&&!g){const v=No.Color3toRGBAUint8(o);this.colorsTexture.update(v)}else{var Q;null===(Q=this.colorsTexture)||void 0===Q||Q.dispose(),this.colorsTexture=No.CreateColorsTexture(`${this._material.name}-colors-texture`,o,this.colorsSampling,this._scene)}}else null===(I=this.colorsTexture)||void 0===I||I.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(o){this._dashCount=o,this._dashArray=1/o}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(o){this._sizeAttenuation=o,this.markAllDefinesAsDirty()}get color(){return this._color}set color(o){this.setColor(o)}setColor(o){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==o||null!==this._color&&null===o?(this._color=o,v||this.markAllDefinesAsDirty()):this._color=o}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(o){this._colorsDistributionType=o,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(o){this._aspect=o.x/o.y,this._resolution=o}serialize(){const o=super.serialize(),v={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(v.No=this._colors),this._color&&(v.color=this._color),o.greasedLineMaterialOptions=v,o}parse(o,v,V){var g;super.parse(o,v,V);const E=o.greasedLineMaterialOptions;null===(g=this.colorsTexture)||void 0===g||g.dispose(),E.color&&this.setColor(E.color,!0),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.No&&(this.No=E.No),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),this.No?this.colorsTexture=No.CreateColorsTexture(`${this._material.name}-colors-texture`,this.No,this.colorsSampling,v):No.PrepareEmptyColorsTexture(v),this.markAllDefinesAsDirty()}copyTo(o){var v;const V=o;null===(v=V.colorsTexture)||void 0===v||v.dispose(),this._colors&&(V.colorsTexture=No.CreateColorsTexture(`${V._material.name}-colors-texture`,this._colors,V.colorsSampling,this._scene)),V.setColor(this.color,!0),V.colorsDistributionType=this.colorsDistributionType,V.colorsSampling=this.colorsSampling,V.colorMode=this.colorMode,V.useColors=this.useColors,V.visibility=this.visibility,V.useDash=this.useDash,V.dashCount=this.dashCount,V.dashRatio=this.dashRatio,V.dashOffset=this.dashOffset,V.width=this.width,V.sizeAttenuation=this.sizeAttenuation,V.resolution=this.resolution,V.markAllDefinesAsDirty()}_isGLSL(o){return 0===o||this._forceGLSL}}qo.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",qo.ForceGLSL=!1,(0,ao.h)(`BABYLON.${qo.GREASED_LINE_MATERIAL_NAME}`,qo);var Po=V(12944),Mo=V(12313),Wo=V(12745),wo=V(12427);class zo extends Wo.ShaderMaterial{constructor(o,v,E){const I=v.getEngine(),Q=I.isWebGPU&&!(E.forceGLSL||zo.ForceGLSL),U=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];v.useRightHandedSystem&&U.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const n=["position","grl_widths","grl_offsets","grl_colorPointers"];E.cameraFacing?(U.push("GREASED_LINE_CAMERA_FACING"),n.push("grl_previousAndSide","grl_nextAndCounters")):(n.push("grl_slopes"),n.push("grl_counters"));const O=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(Q||O.push("world","viewProjection","view","projection"),super(o,v,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:Q?["Scene","Mesh"]:void 0,attributes:n,uniforms:O,samplers:Q?[]:["grlColors"],defines:U,extraInitializationsAsync:async()=>{Q?await Promise.all([V.e(66).then(V.bind(V,15650)),V.e(75).then(V.bind(V,15654))]):await Promise.all([V.e(69).then(V.bind(V,15658)),V.e(76).then(V.bind(V,15660))])},shaderLanguage:Q?1:0}),this._color=c.Lv.White(),this._colorsDistributionType=0,this._colorsTexture=null,E=E||{color:Fo.DEFAULT_COLOR},this.visibility=E.visibility??1,this.useDash=E.useDash??!1,this.dashRatio=E.dashRatio??.5,this.dashOffset=E.dashOffset??0,this.dashCount=E.dashCount??1,this.width=E.width?E.width:E.sizeAttenuation&&E.cameraFacing?Fo.DEFAULT_WIDTH_ATTENUATED:Fo.DEFAULT_WIDTH,this.sizeAttenuation=E.sizeAttenuation??!1,this.color=E.color??c.Lv.White(),this.useColors=E.useColors??!1,this.colorsDistributionType=E.colorDistributionType??0,this.colorsSampling=E.colorsSampling??b.e.NEAREST_NEAREST,this.colorMode=E.colorMode??0,this._colors=E.No??null,this._cameraFacing=E.cameraFacing??!0,this.resolution=E.resolution??new g.Vector2(I.getRenderWidth(),I.getRenderHeight()),E.colorsTexture?this.colorsTexture=E.colorsTexture:this._colors?this.colorsTexture=No.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,v):(this._color=this._color??Fo.DEFAULT_COLOR,this.colorsTexture=No.PrepareEmptyColorsTexture(v)),Q){const o=new wo.c;o.setParameters(),o.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",o)}I.Tg.add((()=>{No.DisposeEmptyColorsTexture()}))}dispose(){var o;null===(o=this._colorsTexture)||void 0===o||o.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new g.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get No(){return this._colors}set No(o){this.setColors(o)}setColors(o){var v;let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1],g=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(v=this._colors)||void 0===v?void 0:v.length)??0;var I;if(this._colors=o,null!==o&&0!==o.length){if(!V||g)if(this._colorsTexture&&E===o.length&&!g){const v=No.Color3toRGBAUint8(o);this._colorsTexture.update(v)}else{var Q;null===(Q=this._colorsTexture)||void 0===Q||Q.dispose(),this.colorsTexture=No.CreateColorsTexture(`${this.name}-colors-texture`,o,this.colorsSampling,this.Fo())}}else null===(I=this._colorsTexture)||void 0===I||I.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(o){this._colorsTexture=o,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(o){this._width=o,this.setFloat("grlWidth",o)}get useColors(){return this._useColors}set useColors(o){this._useColors=o,this.setFloat("grlUseColors",No.BooleanToNumber(o))}get colorsSampling(){return this._colorsSampling}set colorsSampling(o){this._colorsSampling=o}get visibility(){return this._visibility}set visibility(o){this._visibility=o,this.setFloat("grlVisibility",o)}get useDash(){return this._useDash}set useDash(o){this._useDash=o,this.setFloat("grlUseDash",No.BooleanToNumber(o))}get dashOffset(){return this._dashOffset}set dashOffset(o){this._dashOffset=o,this.setFloat("grlDashOffset",o)}get dashRatio(){return this._dashRatio}set dashRatio(o){this._dashRatio=o,this.setFloat("grlDashRatio",o)}get dashCount(){return this._dashCount}set dashCount(o){this._dashCount=o,this._dashArray=1/o,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(o){this._sizeAttenuation=o,this.setFloat("grlSizeAttenuation",No.BooleanToNumber(o))}get color(){return this._color}set color(o){this.setColor(o)}setColor(o){o=o??Fo.DEFAULT_COLOR,this._color=o,this.setColor3("grlColor",o)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(o){this._colorsDistributionType=o,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(o){this._colorMode=o,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(o){this._resolution=o,this.setVector2("grlResolution",o),this.setFloat("grlAspect",o.x/o.y)}serialize(){const o=super.serialize(),v={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(v.No=this._colors),o.greasedLineMaterialOptions=v,o}parse(o,v,V){var g;const E=o.greasedLineMaterialOptions;null===(g=this._colorsTexture)||void 0===g||g.dispose(),E.color&&(this.color=E.color),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),E.No?this.colorsTexture=No.CreateColorsTexture(`${this.name}-colors-texture`,E.No,this.colorsSampling,this.Fo()):this.colorsTexture=No.PrepareEmptyColorsTexture(v),this._cameraFacing=E.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var yo,Ho,eo;zo.ForceGLSL=!1,function(o){o[o.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",o[o.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(yo||(yo={})),function(o){o[o.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",o[o.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",o[o.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Ho||(Ho={})),function(o){o[o.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",o[o.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",o[o.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",o[o.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",o[o.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(eo||(eo={}));class Do extends jo.e{constructor(o,v,V){super(o,v,null,null,!1,!1),this.name=o,this._options=V,this._lazy=!1,this._updatable=!1,this._engine=v.getEngine(),this._lazy=V.lazy??!1,this._updatable=V.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=V.colorPointers??[],this._widths=V.widths??new Array(V.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(o){let v=0;for(const g of this._points)v+=g.length;const V=v/3*2-this._widths.length;for(let g=0;g<V;g++)this._widths.push(o)}updateLazy(){var o,v;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(o=this._options.ribbonOptions)||void 0===o?void 0:o.smoothShading),!this.Mo&&this.refreshBoundingInfo(),null===(v=this.greasedLineMaterial)||void 0===v||v.updateLazy()}addPoints(o,v){for(const V of o)this._points.push(V);this._lazy||this.setPoints(this._points,v)}dispose(o){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(o,v)}isLazy(){return this._lazy}get Yo(){return this._uvs}set Yo(o){this._uvs=o instanceof Float32Array?o:new Float32Array(o),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(o){this.material instanceof zo&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===o||void 0===o?void 0:o.length)>0),this._offsets=o,this._offsetsBuffer?this._offsetsBuffer.update(o):this._createOffsetsBuffer(o)}get widths(){return this._widths}set widths(o){this._widths=o,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(o)}get colorPointers(){return this._colorPointers}set colorPointers(o){this._colorPointers=o,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(o)}get greasedLineMaterial(){var o,v;if(this.material&&this.material instanceof zo)return this.material;const V=null===(o=this.material)||void 0===o||null===(v=o.pluginManager)||void 0===v?void 0:v.getPlugin(qo.GREASED_LINE_MATERIAL_NAME);return V||void 0}get points(){const o=[];return Mo.b.DeepCopy(this._points,o),o}setPoints(o,v){this._points=No.ConvertPoints(o,(null===v||void 0===v?void 0:v.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==v&&void 0!==v&&v.colorPointers||this._updateColorPointers(),this._setPoints(this._points,v)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Yo:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(o){super.serialize(o),o.type=this.getClassName(),o.lineOptions=this._createLineOptions()}_createVertexBuffers(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new Po.d;return v.Jo=this._vertexPositions,v.indices=this._indices,v.Yo=this._uvs,o&&(v.do=[],Po.d.ComputeNormals(this._vertexPositions,this._indices,v.do)),v.Po(this,this._options.updatable),v}_createOffsetsBuffer(o){const v=this._scene.getEngine(),V=new h.b(v,o,this._updatable,3);this.setVerticesBuffer(V.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=V}}class Zo{constructor(o,v){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=o,this.wasAddedByNoopNode=v}getIndicesAccessor(o,v,V,g,E){var I,Q,U,n;return null===(I=this._indicesAccessorMap.get(o))||void 0===I||null===(Q=I.get(v))||void 0===Q||null===(U=Q.get(V))||void 0===U||null===(n=U.get(g))||void 0===n?void 0:n.get(E)}setIndicesAccessor(o,v,V,g,E,I){let Q=this._indicesAccessorMap.get(o);Q||(Q=new Map,this._indicesAccessorMap.set(o,Q));let U=Q.get(v);U||(U=new Map,Q.set(v,U));let n=U.get(V);n||(n=new Map,U.set(V,n));let O=n.get(g);O||(O=new Map,n.set(g,O)),O.set(E,I)}pushExportedNode(o){this._exportedNodes.has(o)||this._exportedNodes.add(o)}getNodesSet(){return this._exportedNodes}getVertexBufferView(o){return this._vertexBufferViewMap.get(o)}setVertexBufferView(o,v){this._vertexBufferViewMap.set(o,v)}setRemappedBufferView(o,v,V){this._remappedBufferView.set(o,new Map),this._remappedBufferView.get(o).set(v,V)}getRemappedBufferView(o,v){var V;return null===(V=this._remappedBufferView.get(o))||void 0===V?void 0:V.get(v)}getVertexAccessor(o,v,V){var g,E;return null===(g=this._vertexAccessorMap.get(o))||void 0===g||null===(E=g.get(v))||void 0===E?void 0:E.get(V)}setVertexAccessor(o,v,V,g){let E=this._vertexAccessorMap.get(o);E||(E=new Map,this._vertexAccessorMap.set(o,E));let I=E.get(v);I||(I=new Map,E.set(v,I)),I.set(V,g)}hasVertexColorAlpha(o){return this._vertexMapColorAlpha.get(o)||!1}setHasVertexColorAlpha(o,v){return this._vertexMapColorAlpha.set(o,v)}getMesh(o){return this._meshMap.get(o)}setMesh(o,v){this._meshMap.set(o,v)}bindMorphDataToMesh(o,v){const V=this._meshMorphTargetMap.get(o)||[];this._meshMorphTargetMap.set(o,V),-1===V.indexOf(v)&&V.push(v)}getMorphTargetsFromMesh(o){return this._meshMorphTargetMap.get(o)}}class Ko{_ApplyExtension(o,v,V,g){if(V>=v.length)return Promise.resolve(o);const E=g(v[V],o);return E?E.then((async o=>o?await this._ApplyExtension(o,v,V+1,g):null)):this._ApplyExtension(o,v,V+1,g)}_ApplyExtensions(o,v){const V=[];for(const g of Ko._ExtensionNames)V.push(this._extensions[g]);return this._ApplyExtension(o,V,0,v)}_extensionsPreExportTextureAsync(o,v,V){return this._ApplyExtensions(v,((v,g)=>v.preExportTextureAsync&&v.preExportTextureAsync(o,g,V)))}_extensionsPostExportNodeAsync(o,v,V,g,E){return this._ApplyExtensions(v,((v,I)=>v.postExportNodeAsync&&v.postExportNodeAsync(o,I,V,g,E,this._bufferManager)))}_extensionsPostExportMaterialAsync(o,v,V){return this._ApplyExtensions(v,((v,g)=>v.postExportMaterialAsync&&v.postExportMaterialAsync(o,g,V)))}_extensionsPostExportMaterialAdditionalTextures(o,v,V){const g=[];for(const E of Ko._ExtensionNames){const I=this._extensions[E];I.postExportMaterialAdditionalTextures&&g.push(...I.postExportMaterialAdditionalTextures(o,v,V))}return g}_extensionsPostExportTextures(o,v,V){for(const g of Ko._ExtensionNames){const E=this._extensions[g];E.postExportTexture&&E.postExportTexture(o,v,V)}}_extensionsPostExportMeshPrimitive(o){for(const v of Ko._ExtensionNames){const V=this._extensions[v];V.postExportMeshPrimitive&&V.postExportMeshPrimitive(o,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const o of Ko._ExtensionNames){const v=this._extensions[o];v.preGenerateBinaryAsync&&await v.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(o){for(const v of Ko._ExtensionNames){const V=this._extensions[v];V.enabled&&o(V)}}_extensionsOnExporting(){this._forEachExtensions((o=>{var v,V,g;o.wasUsed&&((v=this._glTF).extensionsUsed||(v.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(o.name)&&this._glTF.extensionsUsed.push(o.name),o.required&&((V=this._glTF).extensionsRequired||(V.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(o.name)&&this._glTF.extensionsRequired.push(o.name)),(g=this._glTF).extensions||(g.extensions={}),o.onExporting&&o.onExporting())}))}_loadExtensions(){for(const o of Ko._ExtensionNames){const v=Ko._ExtensionFactories[o](this);this._extensions[o]=v}}constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:T.d.LastCreatedScene,v=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${S.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new W(this),this._extensions={},this._bufferManager=new ho,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!o)throw new Error("No scene available to export");this._babylonScene=o,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:o=>{var v;return null===o||void 0===o||null===(v=o.Ng)||void 0===v?void 0:v.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...v},this._loadExtensions()}dispose(){for(const o in this._extensions){this._extensions[o].dispose()}}get options(){return this._options}static RegisterExtension(o,v){Ko.UnregisterExtension(o)&&E.Tools.Warn(`Extension with the name ${o} already exists`),Ko._ExtensionFactories[o]=v,Ko._ExtensionNames.push(o)}static UnregisterExtension(o){if(!Ko._ExtensionFactories[o])return!1;delete Ko._ExtensionFactories[o];const v=Ko._ExtensionNames.indexOf(o);return-1!==v&&Ko._ExtensionNames.splice(v,1),!0}_generateJSON(o,v,V){const g={byteLength:o};return g.byteLength&&(this._glTF.buffers=[g]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.jv=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(g.uri=v+".bin"),V?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(o){const v=await this._generateBinaryAsync();this._extensionsOnExporting();const V=this._generateJSON(v.byteLength,o,!0),g=new Blob([v],{type:"application/octet-stream"}),E=o+".gltf",I=o+".bin",Q=new O;if(Q.files[E]=V,Q.files[I]=g,this._imageData)for(const U in this._imageData)Q.files[U]=new Blob([this._imageData[U].data],{type:this._imageData[U].mimeType});return Q}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(o){const v=o%4;return 0===v?v:4-v}async generateGLBAsync(o){this._shouldUseGlb=!0;const v=await this._generateBinaryAsync();this._extensionsOnExporting();const V=this._generateJSON(v.byteLength),g=o+".glb";let E,I=V.length;if("undefined"!==typeof TextEncoder){E=(new TextEncoder).encode(V),I=E.length}const Q=this._getPadding(I),U=this._getPadding(v.byteLength),n=28+I+Q+v.byteLength+U,h=new no(n);if(h.writeUInt32(1179937895),h.writeUInt32(2),h.writeUInt32(n),h.writeUInt32(I+Q),h.writeUInt32(1313821514),E)h.writeTypedArray(E);else{const o="_".charCodeAt(0);for(let v=0;v<I;++v){const g=V.charCodeAt(v);g!=V.codePointAt(v)?h.writeUInt8(o):h.writeUInt8(g)}}for(let O=0;O<Q;++O)h.writeUInt8(32);h.writeUInt32(v.byteLength+U),h.writeUInt32(5130562),h.writeTypedArray(v);for(let O=0;O<U;++O)h.writeUInt8(0);const x=new O;return x.files[g]=new Blob([h.getOutputData()],{type:"application/octet-stream"}),x}_setNodeTransformation(o,v,V){if(v.getPivotPoint().equalsWithEpsilon(e,H.d)||E.Tools.Warn("Pivot points are not supported in the glTF serializer"),!v.position.equalsWithEpsilon(e,H.d)){const E=g.TmpVectors.cv[0].U(v.position);V&&p(E),o.translation=E.Dg()}v.jU.equalsWithEpsilon(Z,H.d)||(o.scale=v.jU.Dg());const I=v.rotationQuaternion||g.Quaternion.FromEulerAngles(v.rotation.x,v.rotation.y,v.rotation.z);I.equalsWithEpsilon(D,H.d)||(V&&G(I),o.rotation=I.normalize().Dg())}_setCameraTransformation(o,v,V){if(!v.position.equalsWithEpsilon(e,H.d)){const E=g.TmpVectors.cv[0].U(v.position);V&&p(E),o.translation=E.Dg()}const E=v.rotationQuaternion||g.Quaternion.FromEulerAngles(v.rotation.x,v.rotation.y,v.rotation.z);V&&G(E),this._babylonScene.useRightHandedSystem||k(E),E.equalsWithEpsilon(D,H.d)||(o.rotation=E.Dg())}_listAvailableCameras(){for(const o of this._babylonScene.cameras){const v={type:o.mode===fo.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(o.name&&(v.name=o.name),"perspective"===v.type)v.perspective={aspectRatio:o.getEngine().getAspectRatio(o),yfov:o.fovMode===fo.e.FOVMODE_VERTICAL_FIXED?o.fov:o.fov*o.getEngine().getAspectRatio(o),znear:o.Xg,zfar:o.maxZ};else if("orthographic"===v.type){const V=o.orthoLeft&&o.orthoRight?.5*(o.orthoRight-o.orthoLeft):.5*o.getEngine().getRenderWidth(),g=o.orthoBottom&&o.orthoTop?.5*(o.orthoTop-o.orthoBottom):.5*o.getEngine().getRenderHeight();v.orthographic={xmag:V,ymag:g,znear:o.Xg,zfar:o.maxZ}}this._camerasMap.set(o,v)}}_exportAndAssignCameras(){const o=Array.from(this._camerasMap.values());for(const v of o){const o=this._nodesCameraMap.get(v);if(void 0!==o){this._cameras.push(v);for(const v of o)v.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const o of this._babylonScene.skeletons){if(o.bones.length<=0)continue;const v={joints:[]};this._skinMap.set(o,v)}}_exportAndAssignSkeletons(){for(const o of this._babylonScene.skeletons){if(o.bones.length<=0)continue;const v=this._skinMap.get(o);if(void 0==v)continue;const V={},g=[];let I=-1;for(let E=0;E<o.bones.length;++E){const v=o.bones[E],g=v.getIndex()??E;-1!==g&&(V[g]=v,g>I&&(I=g))}for(let o=0;o<=I;++o){const I=V[o];g.push(I.getAbsoluteInverseBindMatrix());const Q=I.getTransformNode();if(null!==Q){const o=this._nodeMap.get(Q);Q&&null!==o&&void 0!==o?v.joints.push(o):E.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else E.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const Q=this._nodesSkinMap.get(v);if(v.joints.length>0&&void 0!==Q){const o=64*g.length,V=new Float32Array(o/4);g.forEach(((o,v)=>{V.set(o.m,16*v)}));const E=this._bufferManager.createBufferView(V);this._accessors.push(this._bufferManager.createAccessor(E,"MAT4",5126,g.length)),v.inverseBindMatrices=this._accessors.length-1,this._skins.push(v);for(const v of Q)v.skin=this._skins.length-1}}}async _exportSceneAsync(){const o={nodes:[]};if(this._babylonScene.metadata){const v=this._options.metadataSelector(this._babylonScene.metadata);v&&(o.extras=v)}const v=new Array,V=new Array,g=new Array;for(const U of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Qo(U,this._babylonScene.useRightHandedSystem)?g.push(...U.getChildren()):this._babylonScene.useRightHandedSystem?v.push(U):V.push(U);this._listAvailableCameras(),this._listAvailableSkeletons();const E=new Zo(!0,!1);o.nodes.push(...await this._exportNodesAsync(V,E));const I=new Zo(!1,!1);o.nodes.push(...await this._exportNodesAsync(v,I));const Q=new Zo(!1,!0);o.nodes.push(...await this._exportNodesAsync(g,Q)),o.nodes.length&&this._scenes.push(o),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&so._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,E.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(o){let v=this._shouldExportNodeMap.get(o);return void 0===v&&(v=this._options.shouldExportNode(o),this._shouldExportNodeMap.set(o,v)),v}async _exportNodesAsync(o,v){const V=new Array;this._exportBuffers(o,v);for(const g of o)await this._exportNodeAsync(g,V,v);return V}_collectBuffers(o,v,V,g,E){if(this._shouldExportNode(o)&&o instanceof f.d&&o.kg){const I=o.kg.getVertexBuffers();if(I)for(const g in I){if(!B(g))continue;const Q=I[g];E.setHasVertexColorAlpha(Q,o.hasVertexAlpha);const U=Q._buffer,n=v.get(U)||[];v.set(U,n),-1===n.indexOf(Q)&&n.push(Q);const O=V.get(Q)||[];V.set(Q,O),-1===O.indexOf(o)&&O.push(o)}const Q=o.morphTargetManager;if(Q)for(let v=0;v<Q.numTargets;v++){const V=Q.getTarget(v),E=g.get(V)||[];g.set(V,E),-1===E.indexOf(o)&&E.push(o)}}for(const I of o.getChildren())this._collectBuffers(I,v,V,g,E)}_exportBuffers(o,v){const V=new Map,g=new Map,E=new Map;for(const U of o)this._collectBuffers(U,V,g,E,v);const I=Array.from(V.keys());for(const U of I){const o=U.getData();if(!o)throw new Error("Buffer data is not available");const E=V.get(U);if(!E)continue;const I=E[0].byteStride;if(E.some((o=>o.byteStride!==I)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const Q=Vo(o).slice();for(const v of E){const o=g.get(v),{byteOffset:V,byteStride:E,componentCount:I,type:U,count:n,normalized:O,kind:x}=X(v,o);switch(x){case h.e.NormalKind:case h.e.TangentKind:(0,w.g)(Q,V,E,I,U,n,O,(o=>{const v=Math.sqrt(o[0]*o[0]+o[1]*o[1]+o[2]*o[2]);if(v>0){const V=1/v;o[0]*=V,o[1]*=V,o[2]*=V}}));break;case h.e.ColorKind:{const v=o.filter((o=>o.material instanceof To.sv||null==o.material)).length;if(0==v)break;if(v!=o.length){z.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}U==h.e.UNSIGNED_BYTE&&z.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const g=new c.Lv,x=new c.sU,f=this._babylonScene.getEngine().useExactSrgbConversions;(0,w.g)(Q,V,E,I,U,n,O,(o=>{3===o.length?(g.RV(o,0),g.toLinearSpaceToRef(g,f),g.toArray(o,0)):(x.RV(o,0),x.toLinearSpaceToRef(x,f),x.toArray(o,0))}))}}}if(v.convertToRightHanded){for(const o of E){const v=g.get(o),{byteOffset:V,byteStride:E,componentCount:I,type:U,count:n,normalized:O,kind:x}=X(o,v);switch(x){case h.e.PositionKind:case h.e.NormalKind:case h.e.TangentKind:(0,w.g)(Q,V,E,I,U,n,O,(o=>{o[0]=-o[0]}))}}v.convertedToRightHandedBuffers.set(U,Q)}const n=this._bufferManager.createBufferView(Q,I);v.setVertexBufferView(U,n);const O=new Map;for(const v of E){const o=g.get(v),{kind:V,totalVertices:E}=X(v,o);switch(V){case h.e.MatricesIndicesKind:case h.e.MatricesIndicesExtraKind:if(v.type==h.e.FLOAT){const o=v.getFloatData(E);null!==o&&O.set(v,o)}}}0!==O.size&&z.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const x=Array.from(O.keys());for(const V of x){const o=O.get(V);if(!o)continue;const g=o.some((o=>o>=256)),E=new(g?Uint16Array:Uint8Array)(o.length);for(let v=0;v<o.length;v++)E[v]=o[v];const I=this._bufferManager.createBufferView(E,4*(g?2:1));v.setRemappedBufferView(U,V,I)}}const Q=Array.from(E.keys());for(const U of Q){const o=E.get(U);if(!o)continue;const V=Lo(U,o[0],this._bufferManager,this._bufferViews,this._accessors,v.convertToRightHanded);for(const g of o)v.bindMorphDataToMesh(g,V)}}async _exportNodeAsync(o,v,V){let g=this._nodeMap.get(o);if(void 0!==g)return void(v.includes(g)||v.push(g));const E=await this._createNodeAsync(o,V);if(E){g=this._nodes.length,this._nodes.push(E),this._nodeMap.set(o,g),V.pushExportedNode(o),v.push(g);const I={name:"runtime animations",channels:[],samplers:[]},Q=[];this._babylonScene.animationGroups.length||(so._CreateMorphTargetAnimationFromMorphTargetAnimations(o,I,Q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,V.convertToRightHanded,this._options.shouldExportAnimation),o.animations.length&&so._CreateNodeAnimationFromNodeAnimations(o,I,Q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,V.convertToRightHanded,this._options.shouldExportAnimation)),I.channels.length&&I.samplers.length&&this._animations.push(I),Q.forEach((o=>{o.channels.length&&o.samplers.length&&this._animations.push(o)}))}const I=E?[]:v;for(const Q of o.getChildren())await this._exportNodeAsync(Q,I,V);E&&I.length&&(E.children=I)}async _createNodeAsync(o,v){if(!this._shouldExportNode(o))return null;const V={};if(o.name&&(V.name=o.name),o.metadata){const v=this._options.metadataSelector(o.metadata);v&&(V.extras=v)}if(o instanceof x.b&&(this._setNodeTransformation(V,o,v.convertToRightHanded),o instanceof f.d)){const E=o instanceof l.e?o.sourceMesh:o;if(E.wg&&E.wg.length>0&&(V.mesh=await this._exportMeshAsync(E,v)),o.skeleton){const v=this._skinMap.get(o.skeleton);var g;if(void 0!==v)void 0===this._nodesSkinMap.get(v)&&this._nodesSkinMap.set(v,[]),null===(g=this._nodesSkinMap.get(v))||void 0===g||g.push(V)}}if(o instanceof y.c){const g=this._camerasMap.get(o);if(g){var E;void 0===this._nodesCameraMap.get(g)&&this._nodesCameraMap.set(g,[]),this._setCameraTransformation(V,o,v.convertToRightHanded);const Q=o.parent;if(null!==Q&&vo(o,Q)){const o=this._nodeMap.get(Q);if(void 0!==o){var I;const v=this._nodes[o];return oo(V,v),null===(I=this._nodesCameraMap.get(g))||void 0===I||I.push(v),null}}null===(E=this._nodesCameraMap.get(g))||void 0===E||E.push(V)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",V,o,this._nodeMap,v.convertToRightHanded)?V:(z.b.Warn(`Not exporting node ${o.name}`),null)}_exportIndices(o,v,V,g,E,Q,U,n,O){let h=o;O.mode=A(Q);const x=U!==I.e.CounterClockWiseSideOrientation,f=!n.wasAddedByNoopNode&&x,l=function(o){switch(o){case I.e.TriangleFillMode:case I.e.TriangleStripDrawMode:case I.e.TriangleFanDrawMode:return!0}return!1}(Q)&&f;if(l){if(Q===I.e.TriangleStripDrawMode||Q===I.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");O.mode=A(Q);const U=v?new Uint32Array(g):new Uint16Array(g);if(o)for(let v=0;v+2<g;v+=3)U[v]=o[V+v]+E,U[v+1]=o[V+v+2]+E,U[v+2]=o[V+v+1]+E;else for(let o=0;o+2<g;o+=3)U[o]=o,U[o+1]=o+2,U[o+2]=o+1;h=U}else if(o&&0!==E){const I=v?new Uint32Array(g):new Uint16Array(g);for(let v=0;v<g;v++)I[v]=o[V+v]+E;h=I}if(h){let I=n.getIndicesAccessor(o,V,g,E,l);if(void 0===I){const Q=function(o,v,V,g){if(o instanceof Uint16Array||o instanceof Uint32Array)return o;if(o instanceof Int32Array)return new Uint32Array(o.buffer,o.byteOffset,o.length);const E=o.slice(v,v+V);return g?new Uint32Array(E):new Uint16Array(E)}(h,0,g,v),U=this._bufferManager.createBufferView(Q),O=v?5125:5123;this._accessors.push(this._bufferManager.createAccessor(U,"SCALAR",O,g,0)),I=this._accessors.length-1,n.setIndicesAccessor(o,V,g,E,l,I)}O.indices=I}}_exportVertexBuffer(o,v,V,g,E,I){const Q=o.getKind();if(!B(Q))return;if(Q.startsWith("uv")&&!this._options.exportUnusedUVs&&(!v||!this._materialNeedsUVsSet.has(v)))return;let U=E.getVertexAccessor(o,V,g);if(void 0===U){const v=E.convertedToRightHandedBuffers.get(o._buffer)||o._buffer.getData(),I=Q===h.e.PositionKind?function(o,v,V,g){const{byteOffset:E,byteStride:I,type:Q,normalized:U}=v,n=v.getSize(),O=new Array(n).fill(1/0),h=new Array(n).fill(-1/0);return(0,w.g)(o,E+V*I,I,n,Q,g*n,U,(o=>{for(let v=0;v<n;v++)O[v]=Math.min(O[v],o[v]),h[v]=Math.max(h[v],o[v])})),{min:O,max:h}}(v,o,V,g):void 0,n=(Q===h.e.MatricesIndicesKind||Q===h.e.MatricesIndicesExtraKind)&&o.type===h.e.FLOAT,O=n?h.e.UNSIGNED_BYTE:o.type,x=n?void 0:o.normalized,f=n?E.getRemappedBufferView(o._buffer,o):E.getVertexBufferView(o._buffer),l=o.byteOffset+V*o.byteStride;this._accessors.push(this._bufferManager.createAccessor(f,function(o,v){if(o==h.e.ColorKind)return v?"VEC4":"VEC3";switch(o){case h.e.PositionKind:case h.e.NormalKind:return"VEC3";case h.e.TangentKind:case h.e.MatricesIndicesKind:case h.e.MatricesIndicesExtraKind:case h.e.MatricesWeightsKind:case h.e.MatricesWeightsExtraKind:return"VEC4";case h.e.UVKind:case h.e.UV2Kind:case h.e.UV3Kind:case h.e.UV4Kind:case h.e.UV5Kind:case h.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${o}`)}(Q,E.hasVertexColorAlpha(o)),O,g,l,I,x)),U=this._accessors.length-1,E.setVertexAccessor(o,V,g,U)}I.attributes[function(o){switch(o){case h.e.PositionKind:return"POSITION";case h.e.NormalKind:return"NORMAL";case h.e.TangentKind:return"TANGENT";case h.e.ColorKind:return"COLOR_0";case h.e.UVKind:return"TEXCOORD_0";case h.e.UV2Kind:return"TEXCOORD_1";case h.e.UV3Kind:return"TEXCOORD_2";case h.e.UV4Kind:return"TEXCOORD_3";case h.e.UV5Kind:return"TEXCOORD_4";case h.e.UV6Kind:return"TEXCOORD_5";case h.e.MatricesIndicesKind:return"JOINTS_0";case h.e.MatricesIndicesExtraKind:return"JOINTS_1";case h.e.MatricesWeightsKind:return"WEIGHTS_0";case h.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${o}`)}(Q)]=U}async _exportMaterialAsync(o,v,V,g){let E=this._materialMap.get(o);if(void 0===E){const g=v&&Object.keys(v).some((o=>o.startsWith("uv")));if((o=o instanceof lo.e?o.LU[V.materialIndex]:o)instanceof So.d)E=await this._materialExporter.exportPBRMaterialAsync(o,"image/png",g);else{if(!(o instanceof To.sv))return void z.b.Warn(`Unsupported material '${o.name}' with type ${o.getClassName()}`);E=await this._materialExporter.exportStandardMaterialAsync(o,"image/png",g)}this._materialMap.set(o,E)}g.material=E}async _exportMeshAsync(o,v){var V;let g=v.getMesh(o);if(void 0!==g)return g;const E={primitives:[]};g=this._meshes.length,this._meshes.push(E),v.setMesh(o,g);const Q=o.isUnIndexed?null:o.QQ(),U=null===(V=o.kg)||void 0===V?void 0:V.getVertexBuffers(),n=v.getMorphTargetsFromMesh(o),O=o instanceof bo.d,h=o instanceof Do,x=o.wg;if(U&&x&&x.length>0)for(const S of x){const V={attributes:{}},g=S.yo()||this._babylonScene.defaultMaterial;if(h){var f,l;const v={name:g.name},E=o,I=c.Lv.White(),Q=(null===(f=E.material)||void 0===f?void 0:f.alpha)??1,U=(null===(l=E.greasedLineMaterial)||void 0===l?void 0:l.color)??I;(!U.equalsWithEpsilon(I,H.d)||Q<1)&&(v.pbrMetallicRoughness={baseColorFactor:[...U.Dg(),Q]}),this._materials.push(v),V.material=this._materials.length-1}else if(O){const v={name:g.name},E=o;(!E.color.equalsWithEpsilon(c.Lv.White(),H.d)||E.alpha<1)&&(v.pbrMetallicRoughness={baseColorFactor:[...E.color.Dg(),E.alpha]}),this._materials.push(v),V.material=this._materials.length-1}else await this._exportMaterialAsync(g,U,S,V);const x=O||h?I.e.LineListDrawMode:o.overrideRenderingFillMode??g.fillMode,T=g._getEffectiveOrientation(o);this._exportIndices(Q,Q?(0,w.d)(Q,S.indexCount,S.indexStart,S.verticesStart):S.verticesCount>65535,Q?S.indexStart:S.verticesStart,Q?S.indexCount:S.verticesCount,-S.verticesStart,x,T,v,V);for(const o of Object.values(U))this._exportVertexBuffer(o,g,S.verticesStart,S.verticesCount,v,V);if(n){V.targets=[];for(const o of n)V.targets.push(o.attributes)}E.primitives.push(V),this._extensionsPostExportMeshPrimitive(V)}if(n){E.weights=[],E.extras||(E.extras={}),E.extras.targetNames=[];for(const o of n)E.weights.push(o.influence),E.extras.targetNames.push(o.name)}return g}}Ko._ExtensionNames=new Array,Ko._ExtensionFactories={};class Xo{static async GLTFAsync(o,v,V){V&&V.exportWithoutWaitingForScene||await o.whenReadyAsync();const g=new Ko(o,V),E=await g.generateGLTFAsync(v.replace(/\.[^/.]+$/,""));return g.dispose(),E}static async GLBAsync(o,v,V){V&&V.exportWithoutWaitingForScene||await o.whenReadyAsync();const g=new Ko(o,V),E=await g.generateGLBAsync(v.replace(/\.[^/.]+$/,""));return g.dispose(),E}}V(13074);const ro="EXT_mesh_gpu_instancing";class Bo{constructor(o){this.name=ro,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(o,v,V,E,I,Q){return await new Promise((o=>{if(v&&V instanceof jo.e&&V.hasThinInstances&&this._exporter){this._wasUsed=!0;const o=g.cv.Zero(),E=g.Quaternion.Identity(),U=g.cv.One(),n=V.thinInstanceGetWorldMatrices(),O=g.TmpVectors.cv[2],h=g.TmpVectors.Quaternion[1],x=g.TmpVectors.cv[3];let f=!1,l=!1,S=!1;const T=new Float32Array(3*V.bU),c=new Float32Array(4*V.bU),R=new Float32Array(3*V.bU);let j=0;for(const v of n)v.decompose(x,h,O),I&&(p(O),G(h)),T.set(O.Dg(),3*j),c.set(h.normalize().Dg(),4*j),R.set(x.Dg(),3*j),f=f||!O.equalsWithEpsilon(o),l=l||!h.equalsWithEpsilon(E),S=S||!x.equalsWithEpsilon(U),j++;const t={attributes:{}};f&&(t.attributes.TRANSLATION=this._buildAccessor(T,"VEC3",V.bU,Q)),l&&(t.attributes.ROTATION=this._buildAccessor(c,"VEC4",V.bU,Q)),S&&(t.attributes.SCALE=this._buildAccessor(R,"VEC3",V.bU,Q)),v.extensions=v.extensions||{},v.extensions[ro]=t}o(v)}))}_buildAccessor(o,v,V,g){const E=g.createBufferView(o),I=g.createAccessor(E,v,5126,V);return this._exporter._accessors.push(I),this._exporter._accessors.length-1}}Ko.RegisterExtension(ro,(o=>new Bo(o)));var Ao=V(13077),Co=V(13091),po=V(13093),Go=V(13096);function ko(o){return o===po.c.PositionKind?"POSITION":o===po.c.NormalKind?"NORMAL":o===po.c.ColorKind?"COLOR":o.startsWith(po.c.UVKind)?"TEX_COORD":"GENERIC"}const ov={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class vv extends Ao.b{static get DefaultAvailable(){return(0,Ao.f)(vv.DefaultConfiguration)}static get Default(){return vv._Default??(vv._Default=new vv),vv._Default}static ResetDefault(o){vv._Default&&(o||vv._Default.dispose(),vv._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(o,v){return{module:await(v||DracoEncoderModule)({wasmBinary:o})}}_getWorkerContent(){return`${Co.g}(${Co.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:vv.DefaultConfiguration)}async _encodeAsync(o,v,V){const g=V?(0,Go.c)(ov,V):ov;if(this._workerPoolPromise){const V=await this._workerPoolPromise;return await new Promise(((E,I)=>{V.push(((V,Q)=>{const U=o=>{V.removeEventListener("error",U),V.removeEventListener("message",n),I(o),Q()},n=o=>{"encodeMeshDone"===o.data.id&&(V.removeEventListener("error",U),V.removeEventListener("message",n),E(o.data.encodedMeshData),Q())};V.addEventListener("error",U),V.addEventListener("message",n);const O=[];for(const v of o)O.push(v.data.buffer);v&&O.push(v.buffer),V.postMessage({id:"encodeMesh",attributes:o,indices:v,options:g},O)}))}))}if(this._modulePromise){const V=await this._modulePromise;return(0,Co.g)(V.module,o,v,g)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(o,v){if(0==o.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");o instanceof jo.e&&o.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===v||void 0===v?void 0:v.method)&&(z.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),v.method="MESH_SEQUENTIAL_ENCODING");const V=function(o){let v=o.QQ(void 0,!0);return!v||v instanceof Uint32Array||v instanceof Uint16Array||(v=((0,w.d)(v,v.length)?Uint32Array:Uint16Array).from(v)),v}(o),g=function(o,v){const V=[];for(const g of o.getVerticesDataKinds()){if(null!==v&&void 0!==v&&v.includes(g)){if(g===po.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const E=o.getVertexBuffer(g),I=E.getSize(),Q=(0,w.t)(E.getData(),I,E.type,E.byteOffset,E.byteStride,E.normalized,o.getTotalVertices(),!0);V.push({kind:g,dracoName:ko(g),size:I,data:Q})}return V}(o,null===v||void 0===v?void 0:v.excludedAttributes);return await this._encodeAsync(g,V,v)}}vv.DefaultConfiguration={wasmUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder.js`},vv._Default=null;const Vv="KHR_draco_mesh_compression";class gv{get wasUsed(){return this._wasUsed}constructor(o){this.name=Vv,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===o.options.meshCompressionMethod&&vv.DefaultAvailable}dispose(){}postExportMeshPrimitive(o,v,V){if(!this.enabled)return;if(4!==o.mode&&5!==o.mode)return void z.b.Warn("Cannot compress primitive with mode "+o.mode+".");const g=[],E=[];let I=null;if(void 0!==o.indices){const Q=V[o.indices],U=v.getBufferView(Q);I=v.getData(U).slice(),g.push(U),E.push(Q)}const Q=[];for(const[h,x]of Object.entries(o.attributes)){const o=V[x],I=v.getBufferView(o),n=r(o.type),O=(0,w.t)(v.getData(I),n,o.componentType,o.byteOffset||0,I.byteStride||(0,w.m)(o.componentType)*n,o.normalized||!1,o.count,!0);Q.push({kind:h,dracoName:(U=h,"POSITION"===U?"POSITION":"NORMAL"===U?"NORMAL":U.startsWith("COLOR")?"COLOR":U.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:r(o.type),data:O}),g.push(I),E.push(o)}var U;const n={method:o.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},O=vv.Default._encodeAsync(Q,I,n).then((V=>{if(!V)return void z.b.Error("Draco encoding failed for primitive.");const I={bufferView:-1,attributes:V.attributeIds},Q=v.createBufferView(V.data);v.setBufferView(I,Q);for(const o of g)this._bufferViewsUsed.add(o);for(const o of E)this._accessorsUsed.add(o);o.extensions||(o.extensions={}),o.extensions[Vv]=I})).catch((o=>{z.b.Error("Draco encoding failed for primitive: "+o)}));this._encodePromises.push(O),this._wasUsed=!0}async preGenerateBinaryAsync(o){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((v=>{o.getPropertiesWithBufferView(v).every((o=>this._accessorsUsed.has(o)))&&o.removeBufferView(v)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Ko.RegisterExtension(Vv,(o=>new gv(o)));var Ev=V(13099);const Iv="KHR_lights_punctual",Qv={name:"",color:[1,1,1],uU:1,range:Number.MAX_VALUE},Uv={innerConeAngle:0,outerConeAngle:Math.PI/4},nv=g.cv.Backward();class Ov{constructor(o){this.name=Iv,this.enabled=!0,this.required=!1,this._exporter=o}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Iv]=this._lights}async postExportNodeAsync(o,v,V,E,I){return await new Promise((Q=>{if(!(V instanceof to.c))return void Q(v);const U=V.getTypeID()==to.c.LIGHTTYPEID_POINTLIGHT?"point":V.getTypeID()==to.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":V.getTypeID()==to.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!U||!(V instanceof Ev.e))return z.b.Warn(`${o}: Light ${V.name} is not supported in ${Iv}`),void Q(v);if(V.falloffType!==to.c.FALLOFF_GLTF&&z.b.Warn(`${o}: Light falloff for ${V.name} does not match the ${Iv} specification!`),!V.position.equalsToFloats(0,0,0)){const o=g.TmpVectors.cv[0].U(V.position);I&&p(o),v.translation=o.Dg()}if("point"!==U){const o=V.direction.normalizeToRef(g.TmpVectors.cv[0]);I&&p(o);const E=g.Quaternion.FromUnitVectorsToRef(nv,o,g.TmpVectors.Quaternion[0]);g.Quaternion.IsIdentity(E)||(v.rotation=E.Dg())}const n={type:U,name:V.name,color:V.mn.Dg(),uU:V.uU,range:V.range};if(go(n,Qv),"spot"===U){const o=V;n.spot={innerConeAngle:o.innerAngle/2,outerConeAngle:o.angle/2},go(n.spot,Uv)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(n);const O={Eg:this._lights.lights.length-1},h=V.parent;if(h&&vo(V,h)){const o=E.get(h);if(o){const V=this._exporter._nodes[o];return oo(v,V),V.extensions||(V.extensions={}),V.extensions[Iv]=O,void Q(null)}}v.extensions||(v.extensions={}),v.extensions[Iv]=O,Q(v)}))}}Ko.RegisterExtension(Iv,(o=>new Ov(o)));var hv=V(13020);const xv="KHR_materials_anisotropy";class fv{constructor(o){this.name=xv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,v,V){const g=[];return V instanceof hv.c&&V.anisotropy.isEnabled&&!V.anisotropy.legacy?(V.anisotropy.texture&&g.push(V.anisotropy.texture),g):[]}postExportMaterialAsync(o,v,V){return new Promise((o=>{if(V instanceof hv.c){if(!V.anisotropy.isEnabled||V.anisotropy.legacy)return void o(v);this._wasUsed=!0,v.extensions=v.extensions||{};const g=this._exporter._materialExporter.getTextureInfo(V.anisotropy.texture),E={anisotropyStrength:V.anisotropy.uU,anisotropyRotation:V.anisotropy.angle,anisotropyTexture:g??void 0};null!==E.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(V),v.extensions[xv]=E}o(v)}))}}Ko.RegisterExtension(xv,(o=>new fv(o)));const lv="KHR_materials_clearcoat";class Sv{constructor(o){this.name=lv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,v,V){const g=[];return V instanceof hv.c&&V.clearCoat.isEnabled?(V.clearCoat.texture&&g.push(V.clearCoat.texture),!V.clearCoat.useRoughnessFromMainTexture&&V.clearCoat.textureRoughness&&g.push(V.clearCoat.textureRoughness),V.clearCoat.bumpTexture&&g.push(V.clearCoat.bumpTexture),g):[]}postExportMaterialAsync(o,v,V){return new Promise((o=>{if(V instanceof hv.c){if(!V.clearCoat.isEnabled)return void o(v);this._wasUsed=!0,v.extensions=v.extensions||{};const g=this._exporter._materialExporter.getTextureInfo(V.clearCoat.texture);let I;I=V.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(V.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(V.clearCoat.textureRoughness),V.clearCoat.isTintEnabled&&E.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${V.name}`),V.clearCoat.remapF0OnInterfaceChange&&E.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${V.name}`);const Q=this._exporter._materialExporter.getTextureInfo(V.clearCoat.bumpTexture),U={clearcoatFactor:V.clearCoat.uU,clearcoatTexture:g??void 0,clearcoatRoughnessFactor:V.clearCoat.roughness,clearcoatRoughnessTexture:I??void 0,clearcoatNormalTexture:Q??void 0};null===U.clearcoatTexture&&null===U.clearcoatRoughnessTexture&&null===U.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(V),v.extensions[lv]=U}o(v)}))}}Ko.RegisterExtension(lv,(o=>new Sv(o)));const Tv="KHR_materials_diffuse_transmission";function cv(o,v){const V=v.subSurface;let g=null;return V.translucencyIntensityTexture?g=V.translucencyIntensityTexture:V.thicknessTexture&&V.useMaskFromThicknessTexture&&(g=V.thicknessTexture),g&&!V.useGltfStyleTextures?(z.b.Warn(`${o}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${v.name}`,1),null):g}class Rv{constructor(o){this.name=Tv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,v,V){const g=[];if(V instanceof So.d&&this._isExtensionEnabled(V)){const v=cv(o,V);return v&&g.push(v),V.subSurface.translucencyColorTexture&&g.push(V.subSurface.translucencyColorTexture),g}return g}_isExtensionEnabled(o){if(o.unlit)return!1;const v=o.subSurface;return!!v.isTranslucencyEnabled&&(!o.unlit&&!v.useAlbedoToTintTranslucency&&v.useGltfStyleTextures&&1===v.volumeIndexOfRefraction&&0===v.minimumThickness&&0===v.maximumThickness)}postExportMaterialAsync(o,v,V){return new Promise((g=>{if(V instanceof So.d&&this._isExtensionEnabled(V)){this._wasUsed=!0;const g=V.subSurface,E=cv(o,V),I=0==g.translucencyIntensity?void 0:g.translucencyIntensity,Q=this._exporter._materialExporter.getTextureInfo(E)??void 0,U=!g.translucencyColor||g.translucencyColor.equalsFloats(1,1,1)?void 0:g.translucencyColor.Dg(),n=this._exporter._materialExporter.getTextureInfo(g.translucencyColorTexture)??void 0,O={diffuseTransmissionFactor:I,diffuseTransmissionTexture:Q,diffuseTransmissionColorFactor:U,diffuseTransmissionColorTexture:n};(Q||n)&&this._exporter._materialNeedsUVsSet.add(V),v.extensions=v.extensions||{},v.extensions[Tv]=O}g(v)}))}}Ko.RegisterExtension(Tv,(o=>new Rv(o)));const jv="KHR_materials_dispersion";class tv{constructor(){this.name=jv,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(o){if(o.unlit)return!1;const v=o.subSurface;return!(!v.isRefractionEnabled&&!v.isDispersionEnabled)}postExportMaterialAsync(o,v,V){return new Promise((o=>{if(V instanceof So.d&&this._isExtensionEnabled(V)){this._wasUsed=!0;const o={dispersion:V.subSurface.dispersion};v.extensions=v.extensions||{},v.extensions[jv]=o}o(v)}))}}Ko.RegisterExtension(jv,(()=>new tv));const sv="KHR_materials_emissive_strength";class Lv{constructor(){this.name=sv,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(o,v,V){return await new Promise((o=>{if(!(V instanceof So.d))return o(v);const g=V.emissiveColor.Dg(),E=Math.max(...g);if(E>1){this._wasUsed=!0,v.extensions||(v.extensions={});const o={emissiveStrength:E},g=V.emissiveColor.scale(1/o.emissiveStrength);v.emissiveFactor=g.Dg(),v.extensions[sv]=o}return o(v)}))}}Ko.RegisterExtension(sv,(o=>new Lv));const bv="KHR_materials_ior";class uv{constructor(){this.name=bv,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(o){return!o.unlit&&(void 0!=o.indexOfRefraction&&1.5!=o.indexOfRefraction)}postExportMaterialAsync(o,v,V){return new Promise((o=>{if(V instanceof So.d&&this._isExtensionEnabled(V)){this._wasUsed=!0;const o={ior:V.indexOfRefraction};v.extensions=v.extensions||{},v.extensions[bv]=o}o(v)}))}}Ko.RegisterExtension(bv,(o=>new uv));const mV="KHR_materials_iridescence";class av{constructor(o){this.name=mV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,v,V){const g=[];return V instanceof hv.c&&V.iridescence.isEnabled?(V.iridescence.texture&&g.push(V.iridescence.texture),V.iridescence.thicknessTexture&&V.iridescence.thicknessTexture!==V.iridescence.texture&&g.push(V.iridescence.thicknessTexture),g):[]}postExportMaterialAsync(o,v,V){return new Promise((o=>{if(V instanceof hv.c){if(!V.iridescence.isEnabled)return void o(v);this._wasUsed=!0,v.extensions=v.extensions||{};const g=this._exporter._materialExporter.getTextureInfo(V.iridescence.texture),E=this._exporter._materialExporter.getTextureInfo(V.iridescence.thicknessTexture),I={iridescenceFactor:V.iridescence.uU,iridescenceIor:V.iridescence.indexOfRefraction,iridescenceThicknessMinimum:V.iridescence.minimumThickness,iridescenceThicknessMaximum:V.iridescence.maximumThickness,iridescenceTexture:g??void 0,iridescenceThicknessTexture:E??void 0};null===I.iridescenceTexture&&null===I.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(V),v.extensions[mV]=I}o(v)}))}}Ko.RegisterExtension(mV,(o=>new av(o)));const Fv="KHR_materials_sheen";class iv{constructor(o){this.name=Fv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,v,V){return V instanceof So.d&&V.sheen.isEnabled&&V.sheen.texture?[V.sheen.texture]:[]}async postExportMaterialAsync(o,v,V){return await new Promise((o=>{if(V instanceof So.d){if(!V.sheen.isEnabled)return void o(v);this._wasUsed=!0,null==v.extensions&&(v.extensions={});const g={sheenColorFactor:V.sheen.color.Dg(),sheenRoughnessFactor:V.sheen.roughness??0};null===g.sheenColorTexture&&null===g.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(V),V.sheen.texture&&(g.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(V.sheen.texture)??void 0),V.sheen.textureRoughness&&!V.sheen.useRoughnessFromMainTexture?g.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(V.sheen.textureRoughness)??void 0:V.sheen.texture&&V.sheen.useRoughnessFromMainTexture&&(g.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(V.sheen.texture)??void 0),v.extensions[Fv]=g}o(v)}))}}Ko.RegisterExtension(Fv,(o=>new iv(o)));const Jv="KHR_materials_specular";class dv{constructor(o){this.name=Jv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,v,V){const g=[];return V instanceof So.d&&this._isExtensionEnabled(V)?(V.metallicReflectanceTexture&&g.push(V.metallicReflectanceTexture),V.reflectanceTexture&&g.push(V.reflectanceTexture),g):g}_isExtensionEnabled(o){return!o.unlit&&(void 0!=o.metallicF0Factor&&1!=o.metallicF0Factor||void 0!=o.metallicReflectanceColor&&!o.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(o))}_hasTexturesExtension(o){return null!=o.metallicReflectanceTexture||null!=o.reflectanceTexture}postExportMaterialAsync(o,v,V){return new Promise((o=>{if(V instanceof So.d&&this._isExtensionEnabled(V)){this._wasUsed=!0,v.extensions=v.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(V.metallicReflectanceTexture)??void 0,g=this._exporter._materialExporter.getTextureInfo(V.reflectanceTexture)??void 0,E={specularFactor:1==V.metallicF0Factor?void 0:V.metallicF0Factor,specularTexture:o,specularColorFactor:V.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:V.metallicReflectanceColor.Dg(),specularColorTexture:g};this._hasTexturesExtension(V)&&this._exporter._materialNeedsUVsSet.add(V),v.extensions[Jv]=E}o(v)}))}}Ko.RegisterExtension(Jv,(o=>new dv(o)));const Nv="KHR_materials_transmission";class Yv{constructor(o){this.name=Nv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,v,V){const g=[];return V instanceof So.d&&this._isExtensionEnabled(V)?(V.subSurface.thicknessTexture&&g.push(V.subSurface.thicknessTexture),g):g}_isExtensionEnabled(o){if(o.unlit)return!1;const v=o.subSurface;return v.isRefractionEnabled&&void 0!=v.refractionIntensity&&0!=v.refractionIntensity||this._hasTexturesExtension(o)}_hasTexturesExtension(o){return null!=o.subSurface.refractionIntensityTexture}async postExportMaterialAsync(o,v,V){if(V instanceof So.d&&this._isExtensionEnabled(V)){this._wasUsed=!0;const g=V.subSurface,E={transmissionFactor:0===g.refractionIntensity?void 0:g.refractionIntensity};if(this._hasTexturesExtension(V)&&this._exporter._materialNeedsUVsSet.add(V),g.refractionIntensityTexture)if(g.useGltfStyleTextures){const o=await this._exporter._materialExporter.exportTextureAsync(g.refractionIntensityTexture,"image/png");o&&(E.transmissionTexture=o)}else z.b.Warn(`${o}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);v.extensions||(v.extensions={}),v.extensions[Nv]=E}return v}}Ko.RegisterExtension(Nv,(o=>new Yv(o)));const qv="KHR_materials_unlit";class Pv{constructor(){this.name=qv,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(o,v,V){return new Promise((o=>{let g=!1;V instanceof So.d?g=V.unlit:V instanceof To.sv&&(g=V.disableLighting),g&&(this._wasUsed=!0,null==v.extensions&&(v.extensions={}),v.extensions[qv]={}),o(v)}))}}Ko.RegisterExtension(qv,(()=>new Pv));const Mv="KHR_materials_volume";class Wv{constructor(o){this.name=Mv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,v,V){const g=[];return V instanceof So.d&&this._isExtensionEnabled(V)?(V.subSurface.thicknessTexture&&g.push(V.subSurface.thicknessTexture),g):g}_isExtensionEnabled(o){if(o.unlit)return!1;const v=o.subSurface;return!(!v.isRefractionEnabled&&!v.isTranslucencyEnabled)&&(void 0!=v.maximumThickness&&0!=v.maximumThickness||void 0!=v.tintColorAtDistance&&v.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=v.tintColor&&v.tintColor!=c.Lv.White()||this._hasTexturesExtension(o))}_hasTexturesExtension(o){return null!=o.subSurface.thicknessTexture}postExportMaterialAsync(o,v,V){return new Promise((o=>{if(V instanceof So.d&&this._isExtensionEnabled(V)){this._wasUsed=!0;const o=V.subSurface,g={thicknessFactor:0==o.maximumThickness?void 0:o.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(o.thicknessTexture)??void 0,attenuationDistance:o.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:o.tintColorAtDistance,attenuationColor:o.tintColor.equalsFloats(1,1,1)?void 0:o.tintColor.Dg()};this._hasTexturesExtension(V)&&this._exporter._materialNeedsUVsSet.add(V),v.extensions=v.extensions||{},v.extensions[Mv]=g}o(v)}))}}Ko.RegisterExtension(Mv,(o=>new Wv(o)));const wv="EXT_materials_diffuse_roughness";class zv{constructor(o){this.name=wv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=o}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(o,v,V){const g=[];return V instanceof hv.c&&V._baseDiffuseRoughness?(V._baseDiffuseRoughnessTexture&&g.push(V._baseDiffuseRoughnessTexture),g):[]}postExportMaterialAsync(o,v,V){return new Promise((o=>{if(V instanceof hv.c){if(!V._baseDiffuseRoughness)return void o(v);this._wasUsed=!0,v.extensions=v.extensions||{};const g=this._exporter._materialExporter.getTextureInfo(V._baseDiffuseRoughnessTexture),E={diffuseRoughnessFactor:V._baseDiffuseRoughness,diffuseRoughnessTexture:g??void 0};null!==E.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(V),v.extensions[wv]=E}o(v)}))}}Ko.RegisterExtension(wv,(o=>new zv(o)));const yv="KHR_texture_transform";class Hv{constructor(){this.name=yv,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(o,v,V){if(V.Fo()||E.Tools.Warn(`${o}: /*@__KEY__*/"scene" is not defined for Babylon texture ${V.name}!`),(0!==V.uAng||0!==V.vAng)&&(E.Tools.Warn(`${o}: Texture ${V.name} with rotation in the u or v axis is not supported in glTF.`),0!==V.uRotationCenter||0!==V.vRotationCenter))return;const g={};let I=!1;if(0===V.uOffset&&0===V.vOffset||(g.offset=[V.uOffset,V.vOffset],I=!0),1===V.uScale&&1===V.vScale||(g.scale=[V.uScale,V.vScale],I=!0),0!==V.wAng){if(0!==V.uRotationCenter||0!==V.vRotationCenter){if(V.homogeneousRotationInUVTransform&&V.uScale!==V.vScale)return void E.Tools.Warn(`${o}: Texture ${V.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${yv}.`);E.Tools.Warn(`${o}: Texture ${V.name} with non-origin rotation center will be exported using an adjusted offset with ${yv}.`),g.offset=function(o){const{uOffset:v,vOffset:V,uRotationCenter:g,vRotationCenter:E,uScale:I,vScale:Q,wAng:U}=o,n=Math.cos(U),O=Math.sin(U),h=g*I,x=E*Q;return[v+(h*(1-n)+x*O),V+(x*(1-n)-h*O)]}(V)}g.rotation=-V.wAng,I=!0}0!==V.coordinatesIndex&&(g.texCoord=V.coordinatesIndex,I=!0),I&&(this._wasUsed=!0,v.extensions||(v.extensions={}),v.extensions[yv]=g)}}Ko.RegisterExtension(yv,(()=>new Hv));class ev{static CreateSTL(o){let v=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],I=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],Q=arguments.length>5&&void 0!==arguments[5]&&arguments[5],U=arguments.length>6&&void 0!==arguments[6]&&arguments[6],n=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const O=function(o,v,V){const E=[3*o[V],3*o[V+1],3*o[V+2]],I=[new g.cv(v[E[0]],v[E[0]+2],v[E[0]+1]),new g.cv(v[E[1]],v[E[1]+2],v[E[1]+1]),new g.cv(v[E[2]],v[E[2]+2],v[E[2]+1])],Q=I[0].Rv(I[1]),U=I[2].Rv(I[1]);return{v:I,n:g.cv.Cross(U,Q).normalize()}},x=function(o,v,V,g){return v=f(o,v,V.x,g),v=f(o,v,V.y,g),f(o,v,V.z,g)},f=function(o,v,V,g){return o.setFloat32(v,V,g),v+4},S=function(o){if(U){let v=o;o instanceof l.e&&(v=o.sourceMesh);const V=v.getVerticesData(h.e.PositionKind,!0,!0);if(!V)return[];const E=g.cv.Zero();let I;for(I=0;I<V.length;I+=3)g.cv.TransformCoordinatesFromFloatsToRef(V[I],V[I+1],V[I+2],o.Ag(!0),E).toArray(V,I);return V}return o.getVerticesData(h.e.PositionKind)||[]};U&&(Q=!0);let T="",c=0,R=0;if(E){for(let V=0;V<o.length;V++){const v=o[V].QQ();c+=v?v.length/3:0}const v=new ArrayBuffer(84+50*c);T=new DataView(v),R+=80,T.setUint32(R,c,I),R+=4}else n||(T="solid stlmesh\r\n");for(let g=0;g<o.length;g++){const v=o[g];!E&&n&&(T+="solid "+v.name+"\r\n"),!Q&&v instanceof jo.e&&v.bakeCurrentTransformIntoVertices();const V=S(v),U=v.QQ()||[];for(let o=0;o<U.length;o+=3){const v=O(U,V,o);E?(R=x(T,R,v.n,I),R=x(T,R,v.v[0],I),R=x(T,R,v.v[1],I),R=x(T,R,v.v[2],I),R+=2):(T+="\tfacet normal "+v.n.x+" "+v.n.y+" "+v.n.z+"\r\n",T+="\t\touter loop\r\n",T+="\t\t\tvertex "+v.v[0].x+" "+v.v[0].y+" "+v.v[0].z+"\r\n",T+="\t\t\tvertex "+v.v[1].x+" "+v.v[1].y+" "+v.v[1].z+"\r\n",T+="\t\t\tvertex "+v.v[2].x+" "+v.v[2].y+" "+v.v[2].z+"\r\n",T+="\t\tendloop\r\n",T+="\tendfacet\r\n")}!E&&n&&(T+="endsolid "+name+"\r\n")}if(E||n||(T+="endsolid stlmesh"),v){const o=document.createElement("a"),v=new Blob([T],{type:"application/octet-stream"});o.href=window.URL.createObjectURL(v),o.download=V+".stl",o.click()}return T}}function Dv(o,v){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const g=[];for(let E=0;E<o.length/V;E++){const I=o[E*V],Q=o[E*V+1],U=o[E*V+2];g.push(`(${I.toPrecision(v.precision)}, ${Q.toPrecision(v.precision)}, ${U.toPrecision(v.precision)})`)}return g.join(", ")}function Zv(o,v){const V=[];for(let g=0;g<o.length/2;g++){const E=o[2*g],I=o[2*g+1];V.push(`(${E.toPrecision(v.precision)}, ${(1-I).toPrecision(v.precision)})`)}return V.join(", ")}function Kv(o,v){const V=o.getVerticesData(h.e.PositionKind),g=o.getVerticesData(h.e.NormalKind);if(V&&g)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(o){var v;const V=null!==(v=o.QQ())&&void 0!==v&&v.length?o.getTotalIndices():o.getTotalVertices();return Array(V/3).fill(3).join(", ")}(o)}]\n\t\tint[] faceVertexIndices = [${function(o){const v=o.QQ(),V=[];if(null!==v)for(let g=0;g<v.length;g++)V.push(v[g]);else{const v=o.getTotalVertices();for(let o=0;o<v;o++)V.push(o)}return V.join(", ")}(o)}]\n\t\tnormal3f[] normals = [${Dv(g,v)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Dv(V,v)}]\n        ${function(o,v){let V="";for(let E=0;E<4;E++){const g=E>0?E:"",I=o.getVerticesData(h.e.UVKind+(g?g+1:""));I&&(V+=`\n\t\ttexCoord2f[] primvars:st${g} = [${Zv(I,v)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const g=o.getVerticesData(h.e.ColorKind);return g&&(V+=`\n\tcolor3f[] primvars:displayColor = [${Dv(g,v,g.length/o.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),V}(o,v)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Xv(o,v){return`\n        def "Geometry"\n        {\n        ${Kv(o,v)}\n        }\n        `}function rv(o){let v='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return v+=o,fflate.strToU8(v)}function Bv(o){const v=o.m;return`( ${Av(v,0)}, ${Av(v,4)}, ${Av(v,8)}, ${Av(v,12)} )`}function Av(o,v){return`(${o[v+0]}, ${o[v+1]}, ${o[v+2]}, ${o[v+3]})`}function Cv(o){const v="Object_"+o.uniqueId,V=function(o){const v=o.getWorldMatrix().clone(),V=o.Fo().useRightHandedSystem;if(!V){let g=o.parent;for(;g;){if(Qo(g,V)){v.multiplyToRef(g.getWorldMatrix().invert(),v);break}g=g.parent}}return v.determinant()<0&&E.Tools.Warn(`Exporting mesh ${o.name} with negative scale. Result may look incorrect in destination engine.`),v}(o),g=Bv(V);return`def Xform "${v}" (\n\tprepend references = @./geometries/Geometry_${o.kg.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${g}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${o.material.uniqueId}>\n}\n\n`}function pv(o){switch(o){case u.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case u.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case u.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Gv(o){return`(${o.x}, ${o.y})`}function kv(o){return`(${o.r}, ${o.g}, ${o.b})`}function oV(o,v,V,E,I,Q){const U=o.getInternalTexture().uniqueId+"_"+o.invertY;I[U]=o;const n=o.coordinatesIndex>0?"st"+o.coordinatesIndex:"st",O=new g.Vector2(o.uScale,o.vScale),h=new g.Vector2(o.uOffset,o.vOffset),x=o.wAng,f=Math.sin(x),l=Math.cos(x);return h.y=1-h.y-O.y,h.x+=f*O.x,h.y+=(1-l)*O.y,`\n    def Shader "PrimvarReader_${V}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${n}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${V}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${v.uniqueId}/PrimvarReader_${V}.outputs:result>\n        float inputs:rotation = ${(x*(180/Math.PI)).toFixed(Q.precision)}\n        float2 inputs:scale = ${Gv(O)}\n        float2 inputs:translation = ${Gv(h)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${o.uniqueId}_${V}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${U}.png@\n        float2 inputs:st.connect = </Materials/Material_${v.uniqueId}/Transform2d_${V}.outputs:result>\n        ${E?"float4 inputs:scale = "+function(o){return`(${o.r}, ${o.g}, ${o.b}, 1.0)`}(E):""}\n        token inputs:sourceColorSpace = "${o.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${pv(o.wrapU)}"\n        token inputs:wrapT = "${pv(o.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${v.needAlphaBlending()?"float outputs:a":""}\n    }`}function vV(o,v,V){const g="\t\t\t",E=[],I=[],{diffuseMap:Q,mn:U,alphaCutOff:n,emissiveMap:O,emissive:h,normalMap:x,roughnessMap:f,roughnessChannel:l,roughness:S,metalnessMap:T,metalnessChannel:R,metalness:j,aoMap:t,aoMapChannel:s,aoMapIntensity:L,alphaMap:b,ior:u,clearCoatEnabled:mo,clearCoat:a,clearCoatMap:F,clearCoatRoughness:i,clearCoatRoughnessMap:J}=function(o){const v={diffuseMap:null,mn:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return o instanceof To.sv?{...v,diffuseMap:o.diffuseTexture,mn:o.diffuseColor,alphaCutOff:o.alphaCutOff,emissiveMap:o.emissiveTexture,emissive:o.emissiveColor,roughness:1,alphaMap:o.opacityTexture}:o instanceof hv.c?{...v,diffuseMap:o._albedoTexture,mn:o._albedoColor,alphaCutOff:o._alphaCutOff,emissiveMap:o._emissiveTexture,emissive:o._emissiveColor,normalMap:o._bumpTexture,roughnessMap:o._metallicTexture,roughnessChannel:o._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:o._roughness??1,metalnessMap:o._metallicTexture,metalnessChannel:o._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:o._metallic??0,aoMap:o._ambientTexture,aoMapChannel:o._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:o._ambientTextureStrength,alphaMap:o._opacityTexture,ior:o.subSurface.indexOfRefraction,clearCoatEnabled:o.clearCoat.isEnabled,clearCoat:o.clearCoat.uU,clearCoatMap:o.clearCoat.texture,clearCoatRoughness:o.clearCoat.roughness,clearCoatRoughnessMap:o.clearCoat.useRoughnessFromMainTexture?o.clearCoat.texture:o.clearCoat.textureRoughness}:v}(o);return null!==Q?(E.push(`${g}color3f inputs:diffuseColor.connect = </Materials/Material_${o.uniqueId}/Texture_${Q.uniqueId}_diffuse.outputs:rgb>`),o.needAlphaBlending()?E.push(`${g}float inputs:opacity.connect = </Materials/Material_${o.uniqueId}/Texture_${Q.uniqueId}_diffuse.outputs:a>`):o.needAlphaTesting()&&(E.push(`${g}float inputs:opacity.connect = </Materials/Material_${o.uniqueId}/Texture_${Q.uniqueId}_diffuse.outputs:a>`),E.push(`${g}float inputs:opacityThreshold = ${n}`)),I.push(oV(Q,o,"diffuse",U,v,V))):E.push(`${g}color3f inputs:diffuseColor = ${kv(U||c.Lv.White())}`),null!==O?(E.push(`${g}color3f inputs:emissiveColor.connect = </Materials/Material_${o.uniqueId}/Texture_${O.uniqueId}_emissive.outputs:rgb>`),I.push(oV(O,o,"emissive",h,v,V))):h&&h.toLuminance()>0&&E.push(`${g}color3f inputs:emissiveColor = ${kv(h)}`),null!==x&&(E.push(`${g}normal3f inputs:normal.connect = </Materials/Material_${o.uniqueId}/Texture_${x.uniqueId}_normal.outputs:rgb>`),I.push(oV(x,o,"normal",null,v,V))),null!==t&&(E.push(`${g}float inputs:occlusion.connect = </Materials/Material_${o.uniqueId}/Texture_${t.uniqueId}_occlusion.outputs:${s}>`),I.push(oV(t,o,"occlusion",new c.Lv(L,L,L),v,V))),null!==f?(E.push(`${g}float inputs:roughness.connect = </Materials/Material_${o.uniqueId}/Texture_${f.uniqueId}_roughness.outputs:${l}>`),I.push(oV(f,o,"roughness",new c.Lv(S,S,S),v,V))):E.push(`${g}float inputs:roughness = ${S}`),null!==T?(E.push(`${g}float inputs:metallic.connect = </Materials/Material_${o.uniqueId}/Texture_${T.uniqueId}_metallic.outputs:${R}>`),I.push(oV(T,o,"metallic",new c.Lv(j,j,j),v,V))):E.push(`${g}float inputs:metallic = ${j}`),null!==b?(E.push(`${g}float inputs:opacity.connect = </Materials/Material_${o.uniqueId}/Texture_${b.uniqueId}_opacity.outputs:r>`),E.push(`${g}float inputs:opacityThreshold = 0.0001`),I.push(oV(b,o,"opacity",null,v,V))):E.push(`${g}float inputs:opacity = ${o.alpha}`),mo&&(null!==F?(E.push(`${g}float inputs:clearcoat.connect = </Materials/Material_${o.uniqueId}/Texture_${F.uniqueId}_clearcoat.outputs:r>`),I.push(oV(F,o,"clearcoat",new c.Lv(a,a,a),v,V))):E.push(`${g}float inputs:clearcoat = ${a}`),null!==J?(E.push(`${g}float inputs:clearcoatRoughness.connect = </Materials/Material_${o.uniqueId}/Texture_${J.uniqueId}_clearcoatRoughness.outputs:g>`),I.push(oV(J,o,"clearcoatRoughness",new c.Lv(i,i,i),v,V))):E.push(`${g}float inputs:clearcoatRoughness = ${i}`)),E.push(`${g}float inputs:ior = ${u}`),`\n\tdef Material "Material_${o.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${E.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${o.uniqueId}/PreviewSurface.outputs:surface>\n\n${I.join("\n")}\n\n\t}\n`}async function VV(o,v,V){const I={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...v};"undefined"===typeof fflate&&await E.Tools.LoadScriptAsync(I.fflateUrl);const Q={};Q[I.modelFileName]=null;let U='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';U+=function(o){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===o.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${o.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${o.planeAnchoringAlignment}"`:""}\n            `}(I);const n={};for(const g of o.meshes){if(0===g.getTotalVertices())continue;const o=g,v=o.kg,O=o.material;if(!O||!v||V&&!V(o))continue;if(-1!==["sv","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(O.getClassName())){const V="geometries/Geometry_"+v.uniqueId+".usda";if(!(V in Q)){const o=Xv(v,I);Q[V]=rv(o)}O.uniqueId in n||(n[O.uniqueId]=O),U+=Cv(o)}else E.Tools.Warn("USDZExportAsync does not support this material type: "+O.getClassName())}o.activeCamera&&I.exportCamera&&(U+=function(o,v){const V="Camera_"+o.uniqueId,E=Bv(g.Matrix.RotationY(Math.PI).multiply(o.getWorldMatrix()));if(o.mode===u.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${V}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${o.Xg.toPrecision(v.precision)}, ${o.maxZ.toPrecision(v.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(o.orthoLeft||1)+Math.abs(o.orthoRight||1))).toPrecision(v.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(o.orthoTop||1)+Math.abs(o.orthoBottom||1))).toPrecision(v.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const g=o.getEngine().getAspectRatio(o),I=v.cameraSensorWidth||35;return`def Camera "${V}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${o.Xg.toPrecision(v.precision)}, ${o.maxZ.toPrecision(v.precision)})\n\t\t\tfloat focalLength = ${(I/(2*Math.tan(.5*o.fov))).toPrecision(v.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(I*g).toPrecision(v.precision)}\n\t\t\tfloat verticalAperture = ${(I/g).toPrecision(v.precision)}            \n\t\t}\n\t\n\t`}}(o.activeCamera,I)),U+="\n            }\n        }\n    }";const O={};U+=function(o,v,V){const g=[];for(const E in o){const I=o[E];g.push(vV(I,v,V))}return`\n    def "Materials"\n{\n${g.join("")}\n}\n\n`}(n,O,I),Q[I.modelFileName]=fflate.strToU8(U);for(const g in O){const o=O[g],v=o.getSize(),V=await o.readPixels();if(!V)throw new Error("Texture data is not available");const E=await mo.DumpTools.DumpDataAsync(v.width,v.height,V,"image/png",void 0,!1,!0);Q[`textures/Texture_${g}.png`]=new Uint8Array(E).slice()}let h=0;for(const g in Q){const o=Q[g];if(!o)continue;h+=34+g.length;const v=63&h;if(4!==v){const V=new Uint8Array(64-v);Q[g]=[o,{extra:{12345:V}}]}h=o.length}return fflate.zipSync(Q,{level:0})}}}]);