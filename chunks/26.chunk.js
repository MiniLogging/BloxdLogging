"use strict";(self.ipz2em9uj1g=self.ipz2em9uj1g||[]).push([[26],{12958:(r,O,W)=>{W.r(O),W.d(O,{EXT_materials_diffuse_roughness:()=>aO,EXT_mesh_gpu_instancing:()=>Fr,GLTF2Export:()=>nr,GLTFData:()=>mr,KHR_draco_mesh_compression:()=>WO,KHR_lights_punctual:()=>JO,KHR_materials_anisotropy:()=>vO,KHR_materials_clearcoat:()=>KO,KHR_materials_diffuse_transmission:()=>bO,KHR_materials_dispersion:()=>YO,KHR_materials_emissive_strength:()=>XO,KHR_materials_ior:()=>oO,KHR_materials_iridescence:()=>DO,KHR_materials_sheen:()=>zO,KHR_materials_specular:()=>MO,KHR_materials_transmission:()=>sO,KHR_materials_unlit:()=>ZO,KHR_materials_volume:()=>RO,KHR_texture_transform:()=>iO,OBJExport:()=>T,STLExport:()=>lO,USDZExportAsync:()=>OW,_ConvertToGLTFPBRMetallicRoughness:()=>B,_SolveMetallic:()=>s,__IGLTFExporterExtension:()=>h});var q=W(12591),Q=W(12428),C=W(12878);class T{static OBJ(r,O,W,T){const h=[];let J=1,mr=1;O&&(W||(W="mat"),h.push("mtllib "+W+".mtl"));for(let d=0;d<r.length;d++){const W=r[d],v=W.name||`mesh${d}}`;h.push(`o ${v}`);let g=null;if(T){const r=W.oh(!0);g=new q.Matrix,r.invertToRef(g),W.bakeTransformIntoVertices(r)}if(O){const r=W.material;r&&h.push("usemtl "+r.id)}const K=W.Nh;if(!K){Q.Tools.Warn("No geometry is present on the mesh");continue}const U=K.getVerticesData("position"),P=K.getVerticesData("normal"),b=K.getVerticesData("uv"),e=K.Dh();let Y=0,G=0;if(!U||!e){Q.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const X=r[0].Dr().useRightHandedSystem?1:-1;for(let r=0;r<U.length;r+=3)h.push("v "+U[r]*X+" "+U[r+1]+" "+U[r+2]),Y++;if(null!=P)for(let r=0;r<P.length;r+=3)h.push("vn "+P[r]*X+" "+P[r+1]+" "+P[r+2]);if(null!=b)for(let r=0;r<b.length;r+=2)h.push("vt "+b[r]+" "+b[r+1]),G++;const S=["","",""],o=(W.material||W.Dr().defaultMaterial)._getEffectiveOrientation(W),[N,D]=o===C.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let r=0;r<e.length;r+=3){const O=[String(e[r]+J),String(e[r+N]+J),String(e[r+D]+J)],W=[String(e[r]+mr),String(e[r+N]+mr),String(e[r+D]+mr)],q=O,Q=null!=b?W:S,C=null!=P?O:S;h.push("f "+q[0]+"/"+Q[0]+"/"+C[0]+" "+q[1]+"/"+Q[1]+"/"+C[1]+" "+q[2]+"/"+Q[2]+"/"+C[2])}T&&g&&W.bakeTransformIntoVertices(g),J+=Y,mr+=G}return h.join("\n")}static MTL(r){const O=[],W=r.material;O.push("newmtl mat1"),O.push("  Ns "+W.specularPower.toFixed(4)),O.push("  Ni 1.5000"),O.push("  d "+W.alpha.toFixed(4)),O.push("  Tr 0.0000"),O.push("  Tf 1.0000 1.0000 1.0000"),O.push("  illum 2"),O.push("  Ka "+W.ambientColor.r.toFixed(4)+" "+W.ambientColor.g.toFixed(4)+" "+W.ambientColor.b.toFixed(4)),O.push("  Kd "+W.diffuseColor.r.toFixed(4)+" "+W.diffuseColor.g.toFixed(4)+" "+W.diffuseColor.b.toFixed(4)),O.push("  Ks "+W.specularColor.r.toFixed(4)+" "+W.specularColor.g.toFixed(4)+" "+W.specularColor.b.toFixed(4)),O.push("  Ke "+W.emissiveColor.r.toFixed(4)+" "+W.emissiveColor.g.toFixed(4)+" "+W.emissiveColor.b.toFixed(4));W.ambientTexture&&O.push("  map_Ka "+W.ambientTexture.name),W.diffuseTexture&&O.push("  map_Kd "+W.diffuseTexture.name),W.specularTexture&&O.push("  map_Ks "+W.specularTexture.name),W.bumpTexture&&O.push("  map_bump -imfchan z "+W.bumpTexture.name),W.opacityTexture&&O.push("  map_d "+W.opacityTexture.name);return O.join("\n")}}var h=0,J=W(12486);class mr{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const r in this.files){const O=this.files[r],W=new Blob([O],{type:(0,J.f)(r)});Q.Tools.Download(W,r)}}}var d=W(12660),v=W(12967),g=W(12977),K=W(12990),U=W(12715),P=W(12484),b=W(12631),e=W(12602);const Y=e.HighestCommonFactor,G={...e,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:Y};var X=W(12796),S=W(12575),o=W(13014),N=W(13021),D=W(12791);const p=1e-6,z=new b.SO(.04,.04,.04),L=1024,M=b.SO.White(),k=b.SO.Black();function s(r,O,W){if(O<z.r)return 0;const q=z.r,Q=r*W/(1-z.r)+O-2*z.r,C=Q*Q-4*q*(z.r-O);return G.Clamp((-Q+Math.sqrt(C))/(2*q),0,1)}function B(r){const O=r.diffuseColor.toLinearSpace(r.Dr().getEngine().useExactSrgbConversions).scale(.5),W=r.alpha,Q=function(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new q.Vector2(0,1),W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new q.Vector2(0,.1),Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new q.Vector2(0,.1),C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new q.Vector2(1300,.1);return function(r,O,W,q,Q){return(1-r)*(1-r)*(1-r)*O+3*(1-r)*(1-r)*r*W+3*(1-r)*r*r*q+r*r*r*Q}(Math.pow(r/C.x,.333333),O.y,W.y,Q.y,C.y)}(G.Clamp(r.specularPower,0,L));return{baseColorFactor:[O.r,O.g,O.b,W],metallicFactor:0,roughnessFactor:Q}}function Z(r,O){O.needAlphaBlending()?r.alphaMode="BLEND":O.needAlphaTesting()&&(r.alphaMode="MASK",r.alphaCutoff=O.alphaCutOff)}function E(r,O,W){const q=new Uint8Array(r*O*4);for(let Q=0;Q<q.length;Q+=4)q[Q]=q[Q+1]=q[Q+2]=q[Q+3]=255;return o.b.CreateRGBATexture(q,r,O,W)}function R(r){if(r instanceof Uint8Array){const O=r.length,W=new Float32Array(r.length);for(let q=0;q<O;++q)W[q]=r[q]/255;return W}if(r instanceof Float32Array)return r;throw new Error("Unsupported pixel format!")}class V{constructor(r){this._exporter=r,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(r){return r?this._textureMap.get(r)??null:null}async exportStandardMaterialAsync(r,O,W){const q=B(r),C={name:r.name};if(null==r.ph||r.ph||(r.twoSidedLighting||Q.Tools.Warn(r.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),C.doubleSided=!0),W){const W=[],Q=r.diffuseTexture;Q&&W.push(this.exportTextureAsync(Q,O).then((r=>{r&&(q.baseColorTexture=r)})));const T=r.bumpTexture;T&&W.push(this.exportTextureAsync(T,O).then((r=>{r&&(C.normalTexture=r,1!==T.level&&(C.normalTexture.scale=T.level))})));const h=r.emissiveTexture;h&&(C.emissiveFactor=[1,1,1],W.push(this.exportTextureAsync(h,O).then((r=>{r&&(C.emissiveTexture=r)}))));const J=r.ambientTexture;J&&W.push(this.exportTextureAsync(J,O).then((r=>{if(r){const O={index:r.index};C.occlusionTexture=O}}))),W.length>0&&(this._exporter._materialNeedsUVsSet.add(r),await Promise.all(W))}(r.alpha<1||r.opacityTexture)&&(r.alphaMode===N.e.ALPHA_COMBINE?C.alphaMode="BLEND":Q.Tools.Warn(r.name+": glTF 2.0 does not support alpha mode: "+r.alphaMode.toString())),r.emissiveColor&&!r.emissiveColor.equalsWithEpsilon(k,p)&&(C.emissiveFactor=r.emissiveColor.Yh()),C.pbrMetallicRoughness=q,Z(C,r),await this._finishMaterialAsync(C,r,O);const T=this._exporter._materials;return T.push(C),T.length-1}async _finishMaterialAsync(r,O,W){const q=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",r,O),Q=[];for(const C of q)Q.push(this.exportTextureAsync(C,W));await Promise.all(Q),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",r,O)}async _getImageDataAsync(r,O,q,Q){const C=N.e.TEXTURETYPE_UNSIGNED_BYTE,T=this._exporter._babylonScene,h=T.getEngine(),J=h.createRawTexture(r,O,q,N.e.TEXTUREFORMAT_RGBA,!1,!0,S.e.NEAREST_SAMPLINGMODE,null,C);h.isWebGPU?await W.e(51).then(W.bind(W,15098)):await W.e(52).then(W.bind(W,15104)),await X.h.ApplyPostProcess("pass",J,T,C,N.e.TEXTURE_NEAREST_SAMPLINGMODE,N.e.TEXTUREFORMAT_RGBA);const mr=await h._readTexturePixels(J,O,q);return await D.DumpTools.DumpDataAsync(O,q,mr,Q,void 0,!0,!0)}_resizeTexturesToSameDimensions(r,O,W){const q=r?r.getSize():{width:0,height:0},Q=O?O.getSize():{width:0,height:0};let C,T;return q.width<Q.width?(C=r&&r instanceof S.e?X.h.CreateResizedCopy(r,Q.width,Q.height,!0):E(Q.width,Q.height,W),T=O):q.width>Q.width?(T=O&&O instanceof S.e?X.h.CreateResizedCopy(O,q.width,q.height,!0):E(q.width,q.height,W),C=r):(C=r,T=O),{texture1:C,texture2:T}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(r,O,W,q){const Q=new Array;if(!r&&!O)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const C=r?r.Dr():O?O.Dr():null;if(C){var T;const h=this._resizeTexturesToSameDimensions(r,O,C),J=null===(T=h.texture1)||void 0===T?void 0:T.getSize();let mr,d;const v=J.width,g=J.height,K=await h.texture1.readPixels(),U=await h.texture2.readPixels();if(!K)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(mr=R(K),!U)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");d=R(U);const P=d.byteLength,e=new Uint8Array(P),Y=new Uint8Array(P),G=4,X=k;let S=0,o=0;for(let r=0;r<g;++r)for(let O=0;O<v;++O){const q=(v*r+O)*G,Q={diffuseColor:new b.SO(mr[q],mr[q+1],mr[q+2]).toLinearSpace(C.getEngine().useExactSrgbConversions).multiply(W.diffuseColor),specularColor:new b.SO(d[q],d[q+1],d[q+2]).toLinearSpace(C.getEngine().useExactSrgbConversions).multiply(W.specularColor),glossiness:d[q+3]*W.glossiness},T=this._convertSpecularGlossinessToMetallicRoughness(Q);X.r=Math.max(X.r,T.baseColor.r),X.g=Math.max(X.g,T.baseColor.g),X.b=Math.max(X.b,T.baseColor.b),S=Math.max(S,T.metallic),o=Math.max(o,T.roughness),Y[q]=255*T.baseColor.r,Y[q+1]=255*T.baseColor.g,Y[q+2]=255*T.baseColor.b,Y[q+3]=h.texture1.Gh?255*mr[q+3]:255,e[q]=0,e[q+1]=255*T.roughness,e[q+2]=255*T.metallic,e[q+3]=255}const N={baseColor:X,metallic:S,roughness:o};let D=!1,z=!1;for(let r=0;r<g;++r)for(let O=0;O<v;++O){const W=(v*r+O)*G;Y[W]/=N.baseColor.r>p?N.baseColor.r:1,Y[W+1]/=N.baseColor.g>p?N.baseColor.g:1,Y[W+2]/=N.baseColor.b>p?N.baseColor.b:1;const q=b.SO.FromInts(Y[W],Y[W+1],Y[W+2]).toGammaSpace(C.getEngine().useExactSrgbConversions);Y[W]=255*q.r,Y[W+1]=255*q.g,Y[W+2]=255*q.b,q.equalsWithEpsilon(M,p)||(z=!0),e[W+1]/=N.roughness>p?N.roughness:1,e[W+2]/=N.metallic>p?N.metallic:1;b.SO.FromInts(255,e[W+1],e[W+2]).equalsWithEpsilon(M,p)||(D=!0)}return D&&Q.push(this._getImageDataAsync(e,v,g,q).then((r=>{N.metallicRoughnessTextureData=r}))),z&&Q.push(this._getImageDataAsync(Y,v,g,q).then((r=>{N.baseColorTextureData=r}))),await Promise.all(Q).then((()=>N))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(r){const O=this._getPerceivedBrightness(r.diffuseColor),W=this._getPerceivedBrightness(r.specularColor),q=1-this._getMaxComponent(r.specularColor),Q=s(O,W,q),C=r.diffuseColor.scale(q/(1-z.r)/Math.max(1-Q)),T=r.specularColor.YO(z.scale(1-Q)).scale(1/Math.max(Q));let h=b.SO.Lerp(C,T,Q*Q);h=h.clampToRef(0,1,h);return{baseColor:h,metallic:Q,roughness:1-r.glossiness}}_getPerceivedBrightness(r){return r?Math.sqrt(.299*r.r*r.r+.587*r.g*r.g+.114*r.b*r.b):0}_getMaxComponent(r){return r?Math.max(r.r,Math.max(r.g,r.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(r,O,W,q){const Q=[],C={baseColor:r._albedoColor,metallic:r._metallic,roughness:r._roughness};if(q){r._albedoTexture&&Q.push(this.exportTextureAsync(r._albedoTexture,O).then((r=>{r&&(W.baseColorTexture=r)})));const q=r._metallicTexture;q&&Q.push(this.exportTextureAsync(q,O).then((r=>{r&&(W.metallicRoughnessTexture=r)})))}return Q.length>0&&(this._exporter._materialNeedsUVsSet.add(r),await Promise.all(Q)),C}_getTextureSampler(r){const O={};if(!r||!(r instanceof S.e))return O;const W=this._getGLTFTextureWrapMode(r.wrapU);10497!==W&&(O.wrapS=W);const q=this._getGLTFTextureWrapMode(r.wrapV);switch(10497!==q&&(O.wrapT=q),r.samplingMode){case S.e.LINEAR_LINEAR:O.magFilter=9729,O.minFilter=9729;break;case S.e.LINEAR_NEAREST:O.magFilter=9729,O.minFilter=9728;break;case S.e.NEAREST_LINEAR:O.magFilter=9728,O.minFilter=9729;break;case S.e.NEAREST_LINEAR_MIPLINEAR:O.magFilter=9728,O.minFilter=9987;break;case S.e.NEAREST_NEAREST:O.magFilter=9728,O.minFilter=9728;break;case S.e.NEAREST_LINEAR_MIPNEAREST:O.magFilter=9728,O.minFilter=9985;break;case S.e.LINEAR_NEAREST_MIPNEAREST:O.magFilter=9729,O.minFilter=9984;break;case S.e.LINEAR_NEAREST_MIPLINEAR:O.magFilter=9729,O.minFilter=9986;break;case S.e.NEAREST_NEAREST_MIPLINEAR:O.magFilter=9728,O.minFilter=9986;break;case S.e.LINEAR_LINEAR_MIPLINEAR:O.magFilter=9729,O.minFilter=9987;break;case S.e.LINEAR_LINEAR_MIPNEAREST:O.magFilter=9729,O.minFilter=9985;break;case S.e.NEAREST_NEAREST_MIPNEAREST:O.magFilter=9728,O.minFilter=9984}return O}_getGLTFTextureWrapMode(r){switch(r){case S.e.WRAP_ADDRESSMODE:return 10497;case S.e.CLAMP_ADDRESSMODE:return 33071;case S.e.MIRROR_ADDRESSMODE:return 33648;default:return Q.Tools.Error(`Unsupported Texture Wrap Mode ${r}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(r,O,W,q){const Q={diffuseColor:r._albedoColor,specularColor:r._reflectivityColor,glossiness:r._microSurface},C=r._albedoTexture,T=r._reflectivityTexture,h=r._useMicroSurfaceFromReflectivityMapAlpha;if(T&&!h)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((C||T)&&q){this._exporter._materialNeedsUVsSet.add(r);const q=this._exportTextureSampler(C||T),h=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(C,T,Q,O),J=this._exporter._textures;if(h.baseColorTextureData){const r=this._exportImage(`baseColor${J.length}`,O,h.baseColorTextureData);W.baseColorTexture=this._exportTextureInfo(r,q,null===C||void 0===C?void 0:C.coordinatesIndex)}if(h.metallicRoughnessTextureData){const r=this._exportImage(`metallicRoughness${J.length}`,O,h.metallicRoughnessTextureData);W.metallicRoughnessTexture=this._exportTextureInfo(r,q,null===T||void 0===T?void 0:T.coordinatesIndex)}return h}return this._convertSpecularGlossinessToMetallicRoughness(Q)}async exportPBRMaterialAsync(r,O,W){const q={},Q={name:r.name},C=r.isMetallicWorkflow();if(C){const O=r._albedoColor,W=r.alpha;O&&(q.baseColorFactor=[O.r,O.g,O.b,W])}const T=C?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(r,O,q,W):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(r,O,q,W);await this._setMetallicRoughnessPbrMaterialAsync(T,r,Q,q,O,W),await this._finishMaterialAsync(Q,r,O);const h=this._exporter._materials;return h.push(Q),h.length-1}async _setMetallicRoughnessPbrMaterialAsync(r,O,W,q,C,T){if(Z(W,O),r.baseColor.equalsWithEpsilon(M,p)&&G.WithinEpsilon(O.alpha,1,p)||(q.baseColorFactor=[r.baseColor.r,r.baseColor.g,r.baseColor.b,O.alpha]),null!=r.metallic&&1!==r.metallic&&(q.metallicFactor=r.metallic),null!=r.roughness&&1!==r.roughness&&(q.roughnessFactor=r.roughness),null==O.ph||O.ph||(O._twoSidedLighting||Q.Tools.Warn(O.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),W.doubleSided=!0),T){const r=[],q=O._bumpTexture;q&&r.push(this.exportTextureAsync(q,C).then((r=>{r&&(W.normalTexture=r,1!==q.level&&(W.normalTexture.scale=q.level))})));const Q=O._ambientTexture;Q&&r.push(this.exportTextureAsync(Q,C).then((r=>{if(r){const q={index:r.index,texCoord:r.texCoord,extensions:r.extensions};W.occlusionTexture=q;const Q=O._ambientTextureStrength;Q&&(q.strength=Q)}})));const T=O._emissiveTexture;T&&r.push(this.exportTextureAsync(T,C).then((r=>{r&&(W.emissiveTexture=r)}))),r.length>0&&(this._exporter._materialNeedsUVsSet.add(O),await Promise.all(r))}const h=O._emissiveColor;h.equalsWithEpsilon(k,p)||(W.emissiveFactor=h.Yh()),W.pbrMetallicRoughness=q}_getPixelsFromTextureAsync(r){return function(r){switch(r){case N.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case N.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case N.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case N.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case N.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case N.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case N.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case N.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case N.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case N.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case N.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case N.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case N.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case N.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case N.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case N.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case N.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case N.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case N.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case N.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case N.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(r.textureFormat)?(0,X.e)(r,r._texture.width,r._texture.height):(r.textureType,N.e.TEXTURETYPE_UNSIGNED_BYTE,r.readPixels())}async exportTextureAsync(r,O){const W=this._exporter._extensionsPreExportTextureAsync("exporter",r,O);return W?await W.then((async W=>W?await this._exportTextureInfoAsync(W,O):await this._exportTextureInfoAsync(r,O))):await this._exportTextureInfoAsync(r,O)}async _exportTextureInfoAsync(r,O){let W=this._textureMap.get(r);if(!W){const q=await this._getPixelsFromTextureAsync(r);if(!q)return null;const C=this._exportTextureSampler(r),T=r.mimeType;if(T)switch(T){case"image/jpeg":case"image/png":case"image/webp":O=T;break;default:Q.Tools.Warn(`Unsupported media type: ${T}. Exporting texture as PNG.`)}const h=this._internalTextureToImage,J=r.getInternalTexture().uniqueId;h[J]||(h[J]={});let mr=h[J][O];if(void 0===mr){const W=r.getSize();mr=(async()=>{const Q=await this._getImageDataAsync(q,W.width,W.height,O);return this._exportImage(r.name,O,Q)})(),h[J][O]=mr}W=this._exportTextureInfo(await mr,C,r.coordinatesIndex),this._textureMap.set(r,W),this._exporter._extensionsPostExportTextures("exporter",W,r)}return W}_exportImage(r,O,W){const q=this._exporter._images;let C;if(this._exporter._shouldUseGlb){C={name:r,mimeType:O,bufferView:void 0};const q=this._exporter._bufferManager.createBufferView(new Uint8Array(W));this._exporter._bufferManager.setBufferView(C,q)}else{const T=r.replace(/\.\/|\/|\.\\|\\/g,"_"),h=function(r){switch(r){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(O);let J=T+h;q.some((r=>r.uri===J))&&(J=`${T}_${Q.Tools.RandomId()}${h}`),C={name:r,uri:J},this._exporter._imageData[J]={data:W,mimeType:O}}return q.push(C),q.length-1}_exportTextureInfo(r,O,W){const q=this._exporter._textures;let Q=q.findIndex((W=>W.sampler==O&&W.source===r));-1===Q&&(Q=q.length,q.push({source:r,sampler:O}));const C={index:Q};return W&&(C.texCoord=W),C}_exportTextureSampler(r){const O=this._getTextureSampler(r),W=this._exporter._samplers,q=W.findIndex((r=>r.minFilter===O.minFilter&&r.magFilter===O.magFilter&&r.wrapS===O.wrapS&&r.wrapT===O.wrapT));return-1!==q?q:(W.push(O),W.length-1)}}var a=W(12672),t=W(12453),i=W(13025),l=W(12595);const y=q.eO.Zero(),w=q.Quaternion.Identity(),u=q.eO.One(),n=new q.eO(-1,1,1);function f(r,O){const{byteOffset:W,byteStride:q,type:Q,normalized:C}=r,T=r.getSize(),h=O.reduce(((r,O)=>O.getTotalVertices()>r?O.getTotalVertices():r),-Number.MAX_VALUE);return{byteOffset:W,byteStride:q,componentCount:T,type:Q,count:h*T,normalized:C,totalVertices:h,kind:r.getKind()}}function F(r){switch(r){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function j(r){switch(r){case d.i.PositionKind:case d.i.NormalKind:case d.i.TangentKind:case d.i.ColorKind:case d.i.MatricesIndicesKind:case d.i.MatricesIndicesExtraKind:case d.i.MatricesWeightsKind:case d.i.MatricesWeightsExtraKind:case d.i.UVKind:case d.i.UV2Kind:case d.i.UV3Kind:case d.i.UV4Kind:case d.i.UV5Kind:case d.i.UV6Kind:return!0}return!1}function H(r){switch(r){case C.d.TriangleFillMode:return 4;case C.d.TriangleStripDrawMode:return 5;case C.d.TriangleFanDrawMode:return 6;case C.d.PointListDrawMode:case C.d.PointFillMode:return 0;case C.d.LineLoopDrawMode:return 2;case C.d.LineListDrawMode:return 1;case C.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${r}`)}function A(r){const O=Math.sqrt(r.x*r.x+r.y*r.y+r.z*r.z);O>0&&(r.x/=O,r.y/=O,r.z/=O)}function x(r){return r.x*=-1,r}function I(r){if(r.x*r.x+r.y*r.y>.5){const O=Math.abs(r.x),W=Math.abs(r.y);if(O>W){const W=Math.sign(r.x);r.x=O,r.y*=-W,r.z*=-W,r.w*=W}else{const O=Math.sign(r.y);r.x*=-O,r.y=W,r.z*=O,r.w*=-O}}else{const O=Math.abs(r.z),W=Math.abs(r.w);if(O>W){const W=Math.sign(r.z);r.x*=-W,r.y*=W,r.z=O,r.w*=-W}else{const O=Math.sign(r.w);r.x*=O,r.y*=-O,r.z*=-O,r.w=W}}return r}function c(r){r.zh(-r.z,r.w,r.x,-r.y)}function rr(r,O){const W=q.eO.FromArrayToRef(O.translation||[0,0,0],0,q.TmpVectors.eO[0]),Q=q.Quaternion.FromArrayToRef(O.rotation||[0,0,0,1],0,q.TmpVectors.Quaternion[0]),C=q.Matrix.ComposeToRef(u,Q,W,q.TmpVectors.Matrix[0]),T=q.eO.FromArrayToRef(r.translation||[0,0,0],0,q.TmpVectors.eO[2]),h=q.Quaternion.FromArrayToRef(r.rotation||[0,0,0,1],0,q.TmpVectors.Quaternion[1]),J=q.Matrix.ComposeToRef(u,h,T,q.TmpVectors.Matrix[1]);C.multiplyToRef(J,J),J.decompose(void 0,Q,W),W.equalsWithEpsilon(y,l.c)?delete O.translation:O.translation=W.Yh(),Q.equalsWithEpsilon(w,l.c)?delete O.rotation:O.rotation=Q.Yh(),O.scale&&delete O.scale}function Or(r,O){if(!(O instanceof v.b))return!1;if(!(1===O.getChildren().length&&0===r.getChildren().length&&r.parent===O))return!1;const W=r.Dr(),q=r instanceof i.e&&!W.useRightHandedSystem?n:u;return!!O.Lh.equalsWithEpsilon(q,l.c)||(t.b.Warn(`Cannot collapse node ${r.name} into parent node ${O.name} with modified scaling.`),!1)}function Wr(r){if(r instanceof Array){const O=new Float32Array(r);return new Uint8Array(O.buffer,O.byteOffset,O.byteLength)}return ArrayBuffer.isView(r)?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):new Uint8Array(r)}function qr(r,O){for(const[W,q]of Object.entries(r)){const Q=O[W];(Array.isArray(q)&&Array.isArray(Q)&&Qr(q,Q)||q===Q)&&delete r[W]}return r}function Qr(r,O){return r.length===O.length&&r.every(((r,W)=>r===O[W]))}const Cr=q.Matrix.Compose(new q.eO(-1,1,1),q.Quaternion.Identity(),q.eO.Zero());function Tr(r,O){if(!(r instanceof v.b))return!1;if(O){if(!r.getWorldMatrix().equalsWithEpsilon(q.Matrix.IdentityReadOnly,l.c))return!1}else{if(!r.getWorldMatrix().multiplyToRef(Cr,q.TmpVectors.Matrix[0]).equalsWithEpsilon(q.Matrix.IdentityReadOnly,l.c))return!1}return!(r instanceof g.c&&r.Nh)}const hr=new Map([[Int8Array,(r,O,W)=>r.setInt8(O,W)],[Uint8Array,(r,O,W)=>r.setUint8(O,W)],[Uint8ClampedArray,(r,O,W)=>r.setUint8(O,W)],[Int16Array,(r,O,W)=>r.setInt16(O,W,!0)],[Uint16Array,(r,O,W)=>r.setUint16(O,W,!0)],[Int32Array,(r,O,W)=>r.setInt32(O,W,!0)],[Uint32Array,(r,O,W)=>r.setUint32(O,W,!0)],[Float32Array,(r,O,W)=>r.setFloat32(O,W,!0)],[Float64Array,(r,O,W)=>r.setFloat64(O,W,!0)]]);class Jr{writeTypedArray(r){this._checkGrowBuffer(r.byteLength);const O=hr.get(r.constructor);for(let W=0;W<r.length;W++)O(this._dataView,this._byteOffset,r[W]),this._byteOffset+=r.BYTES_PER_ELEMENT}constructor(r){this._data=new Uint8Array(r),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(r){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,r),this._byteOffset++}writeInt8(r){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,r),this._byteOffset++}writeInt16(r){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,r,!0),this._byteOffset+=2}writeUInt16(r){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,r,!0),this._byteOffset+=2}writeInt32(r){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,r,!0),this._byteOffset+=4}writeUInt32(r){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,r,!0),this._byteOffset+=4}writeFloat32(r){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,r,!0),this._byteOffset+=4}writeFloat64(r){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,r,!0),this._byteOffset+=8}_checkGrowBuffer(r){const O=this.byteOffset+r;if(O>this._data.byteLength){const r=new Uint8Array(2*O);r.set(this._data),this._data=r,this._dataView=new DataView(this._data.buffer)}}}function mO(r){return r%4===0?4:r%2===0?2:1}class dr{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(r){let O=0;this._bufferViewToData.forEach((r=>{O+=r.byteLength}));const W=new Jr(O),q=Array.from(this._bufferViewToData.keys()).sort(((r,O)=>mO(O.byteLength)-mO(r.byteLength)));for(const Q of q){Q.byteOffset=W.byteOffset,r.push(Q);const O=r.length-1,q=this.getPropertiesWithBufferView(Q);for(const r of q)r.bufferView=O;W.writeTypedArray(this._bufferViewToData.get(Q)),this._bufferViewToData.delete(Q)}return W.getOutputData()}createBufferView(r,O){const W={buffer:0,byteOffset:void 0,byteLength:r.byteLength,byteStride:O};return this._bufferViewToData.set(W,r),W}createAccessor(r,O,W,q,Q,C,T){this._verifyBufferView(r);const h={bufferView:void 0,componentType:W,count:q,type:O,min:null===C||void 0===C?void 0:C.min,max:null===C||void 0===C?void 0:C.max,normalized:T,byteOffset:Q};return this.setBufferView(h,r),this._accessorToBufferView.set(h,r),h}setBufferView(r,O){this._verifyBufferView(O);this.getPropertiesWithBufferView(O).push(r)}removeBufferView(r){const O=this.getPropertiesWithBufferView(r);for(const W of O)void 0!==W.bufferView&&delete W.bufferView;this._bufferViewToData.delete(r),this._bufferViewToProperties.delete(r),this._accessorToBufferView.forEach(((O,W)=>{O===r&&(void 0!==W.byteOffset&&delete W.byteOffset,this._accessorToBufferView.delete(W))}))}getBufferView(r){const O=this._accessorToBufferView.get(r);return this._verifyBufferView(O),O}getPropertiesWithBufferView(r){return this._verifyBufferView(r),this._bufferViewToProperties.set(r,this._bufferViewToProperties.get(r)??[]),this._bufferViewToProperties.get(r)}getData(r){return this._verifyBufferView(r),this._bufferViewToData.get(r)}_verifyBufferView(r){if(void 0===r||!this._bufferViewToData.has(r))throw new Error(`BufferView ${r} not found in BufferManager.`)}}var vr,gr=W(12999),Kr=W(13011),Ur=W(13027),Pr=W(12919),br=W(13058),er=W(13075),Yr=W(12996),Gr=W(13079);!function(r){r[r.INTANGENT=0]="INTANGENT",r[r.OUTTANGENT=1]="OUTTANGENT"}(vr||(vr={}));class Xr{static _IsTransformable(r){return r&&(r instanceof v.b||r instanceof gr.b||r instanceof Gr.e)}static _CreateNodeAnimation(r,O,W,q,C){if(this._IsTransformable(r)){const T=[],h=[],J=O.getKeys(),mr=Xr._CalculateMinMaxKeyFrames(J),d=Xr._DeduceInterpolation(J,W,q),v=d.interpolationType,g=d.shouldBakeAnimation;if(g?Xr._CreateBakedAnimation(r,O,W,mr.min,mr.max,O.framePerSecond,C,T,h,mr,q):"LINEAR"===v||"STEP"===v?Xr._CreateLinearOrStepAnimation(r,O,W,T,h,q):"CUBICSPLINE"===v?Xr._CreateCubicSplineAnimation(r,O,W,T,h,q):Xr._CreateBakedAnimation(r,O,W,mr.min,mr.max,O.framePerSecond,C,T,h,mr,q),T.length&&h.length){return{inputs:T,outputs:h,samplerInterpolation:v,inputsMin:g?mr.min:Q.Tools.FloatRound(mr.min/O.framePerSecond),inputsMax:g?mr.max:Q.Tools.FloatRound(mr.max/O.framePerSecond)}}}return null}static _DeduceAnimationInfo(r){let O=null,W="VEC3",q=!1;const C=r.targetProperty.split(".");switch(C[0]){case"Lh":O="scale";break;case"position":O="translation";break;case"rotation":W="VEC4",O="rotation";break;case"rotationQuaternion":W="VEC4",q=!0,O="rotation";break;case"influence":W="SCALAR",O="weights";break;default:Q.Tools.Error(`Unsupported animatable property ${C[0]}`)}return O?{animationChannelTargetPath:O,dataAccessorType:W,useQuaternion:q}:(Q.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(r,O,W,q,Q,C,T,h,J,mr,d){let v;if(Xr._IsTransformable(r)&&r.animations)for(const g of r.animations){if(d&&!d(g))continue;const Q=Xr._DeduceAnimationInfo(g);Q&&(v={name:g.name,samplers:[],channels:[]},Xr._AddAnimation(`${g.name}`,g.hasRunningRuntimeAnimations?O:v,r,g,Q.dataAccessorType,Q.animationChannelTargetPath,q,C,T,h,Q.useQuaternion,J,mr),v.samplers.length&&v.channels.length&&W.push(v))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(r,O,W,q,Q,C,T,h,J,mr,d){let v;if(r instanceof Yr.e){const Q=r.morphTargetManager;if(Q)for(let g=0;g<Q.numTargets;++g){const K=Q.getTarget(g);for(const U of K.animations){if(d&&!d(U))continue;const K=new br.b(`${U.name}`,"influence",U.framePerSecond,U.dataType,U.loopMode,U.enableBlending),P=[],b=U.getKeys();for(let r=0;r<b.length;++r){const O=b[r];for(let r=0;r<Q.numTargets;++r)r==g?P.push(O):P.push({frame:O.frame,value:0})}K.setKeys(P);const e=Xr._DeduceAnimationInfo(K);e&&(v={name:K.name,samplers:[],channels:[]},Xr._AddAnimation(U.name,U.hasRunningRuntimeAnimations?O:v,r,K,e.dataAccessorType,e.animationChannelTargetPath,q,C,T,h,e.useQuaternion,J,mr,Q.numTargets),v.samplers.length&&v.channels.length&&W.push(v))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(r,O,W,q,Q,C,T,h,J){let mr;if(r.animationGroups){const v=r.animationGroups;for(const g of v){const v=new Map,K=new Map,U=new Set,P=g.to-g.from;mr={name:g.name,channels:[],samplers:[]};for(let O=0;O<g.targetedAnimations.length;++O){const P=g.targetedAnimations[O],b=P.target,e=P.animation;if(J&&!J(e))continue;const Y=h.has(b);if(this._IsTransformable(b)||1===b.length&&this._IsTransformable(b[0])){const r=Xr._DeduceAnimationInfo(P.animation);if(r){const O=this._IsTransformable(b)?b:this._IsTransformable(b[0])?b[0]:null;O&&Xr._AddAnimation(`${e.name}`,mr,O,e,r.dataAccessorType,r.animationChannelTargetPath,W,q,Q,C,r.useQuaternion,T,Y)}}else if(b instanceof er.b||1===b.length&&b[0]instanceof er.b){if(Xr._DeduceAnimationInfo(P.animation)){const O=b instanceof er.b?b:b[0];if(O){const W=r.morphTargetManagers.find((r=>{for(let W=0;W<r.numTargets;++W)if(r.getTarget(W)===O)return!0;return!1}));if(W){const q=r.meshes.find((r=>r.morphTargetManager===W));var d;if(q)v.has(q)||v.set(q,new Map),null===(d=v.get(q))||void 0===d||d.set(O,e),U.add(q),K.set(q,e)}}}}}U.forEach((r=>{const O=r.morphTargetManager;let h=null;const J=[],d=K.get(r).getKeys(),U=d.length;for(let W=0;W<U;++W)for(let q=0;q<O.numTargets;++q){const Q=O.getTarget(q),C=v.get(r);if(C){const O=C.get(Q);O?(h||(h=new br.b(`${g.name}_${r.name}_MorphWeightAnimation`,"influence",O.framePerSecond,br.b.ANIMATIONTYPE_FLOAT,O.loopMode,O.enableBlending)),J.push(O.getKeys()[W])):J.push({frame:g.from+P/U*W,value:Q.influence,inTangent:d[0].inTangent?0:void 0,outTangent:d[0].outTangent?0:void 0})}}h.setKeys(J);const b=Xr._DeduceAnimationInfo(h);b&&Xr._AddAnimation(`${g.name}_${r.name}_MorphWeightAnimation`,mr,r,h,b.dataAccessorType,b.animationChannelTargetPath,W,q,Q,C,b.useQuaternion,T,!1,null===O||void 0===O?void 0:O.numTargets)})),mr.channels.length&&mr.samplers.length&&O.push(mr)}}}static _AddAnimation(r,O,W,Q,C,T,h,J,mr,d,v,g,K,U){const P=Xr._CreateNodeAnimation(W,Q,T,v,g);let b,e,Y,G,X,S;if(P){if(U){let r=0,O=0;const W=[];for(;P.inputs.length>0;)O=P.inputs.shift(),r%U==0&&W.push(O),r++;P.inputs=W}const r=h.get(W),Q=new Float32Array(P.inputs);b=J.createBufferView(Q),e=J.createAccessor(b,"SCALAR",5126,P.inputs.length,void 0,{min:[P.inputsMin],max:[P.inputsMax]}),d.push(e),Y=d.length-1;const mr=new q.Quaternion,v=new q.eO,g=new q.eO,o=W instanceof gr.b,N=F(C),D=new Float32Array(P.outputs.length*N);P.outputs.forEach((function(r,O){let W=r;switch(T){case"translation":K&&(q.eO.FromArrayToRef(r,0,g),x(g),g.toArray(W));break;case"rotation":4===r.length?q.Quaternion.FromArrayToRef(r,0,mr):(W=new Array(4),q.eO.FromArrayToRef(r,0,v),q.Quaternion.FromEulerVectorToRef(v,mr)),K&&(I(mr),o&&c(mr)),mr.toArray(W)}D.set(W,O*N)})),b=J.createBufferView(D),e=J.createAccessor(b,C,5126,P.outputs.length),d.push(e),G=d.length-1,X={interpolation:P.samplerInterpolation,input:Y,output:G},O.samplers.push(X),S={sampler:O.samplers.length-1,target:{node:r,path:T}},O.channels.push(S)}}static _CreateBakedAnimation(r,O,W,C,T,h,J,mr,d,v,g){let K;const U=q.Quaternion.Identity();let P,b=null,e=null,Y=null,G=null,X=null,S=null;v.min=Q.Tools.FloatRound(C/h);const o=O.getKeys();for(let q=0,N=o.length;q<N;++q){if(S=null,Y=o[q],q+1<N)if(G=o[q+1],Y.value.equals&&Y.value.equals(G.value)||Y.value===G.value){if(0!==q)continue;S=Y.frame}else S=G.frame;else{if(X=o[q-1],Y.value.equals&&Y.value.equals(X.value)||Y.value===X.value)continue;S=T}if(S)for(let q=Y.frame;q<=S;q+=J){if(P=Q.Tools.FloatRound(q/h),P===b)continue;b=P,e=P;const C={key:0,repeatCount:0,loopMode:O.loopMode};K=O._interpolate(q,C),Xr._SetInterpolatedValue(r,K,P,O,W,U,mr,d,g)}}e&&(v.max=e)}static _ConvertFactorToVector3OrQuaternion(r,O,W,C,T){const h=Xr._GetBasePositionRotationOrScale(O,C,T),J=W.targetProperty.split("."),mr=J?J[1]:"",d=T?q.Quaternion.oO(h).normalize():q.eO.oO(h);switch(mr){case"x":case"y":case"z":d[mr]=r;break;case"w":d.w=r;break;default:Q.Tools.Error(`glTFAnimation: Unsupported component name "${mr}"!`)}return d}static _SetInterpolatedValue(r,O,W,Q,C,T,h,J,mr){let d;h.push(W),"weights"!==C?(Q.dataType===br.b.ANIMATIONTYPE_FLOAT&&(O=this._ConvertFactorToVector3OrQuaternion(O,r,Q,C,mr)),"rotation"===C?(mr?T=O:(d=O,q.Quaternion.RotationYawPitchRollToRef(d.y,d.x,d.z,T)),J.push(T.Yh())):(d=O,J.push(d.Yh()))):J.push([O])}static _CreateLinearOrStepAnimation(r,O,W,q,Q,C){for(const T of O.getKeys())q.push(T.frame/O.framePerSecond),Xr._AddKeyframeValue(T,O,Q,W,r,C)}static _CreateCubicSplineAnimation(r,O,W,q,Q,C){O.getKeys().forEach((function(T){q.push(T.frame/O.framePerSecond),Xr._AddSplineTangent(vr.INTANGENT,Q,W,"CUBICSPLINE",T,C),Xr._AddKeyframeValue(T,O,Q,W,r,C),Xr._AddSplineTangent(vr.OUTTANGENT,Q,W,"CUBICSPLINE",T,C)}))}static _GetBasePositionRotationOrScale(r,O,W){let Q;if("rotation"===O)if(W){Q=(r.rotationQuaternion??q.Quaternion.Identity()).Yh()}else{Q=(r.rotation??q.eO.Zero()).Yh()}else if("translation"===O){Q=(r.position??q.eO.Zero()).Yh()}else{Q=(r.Lh??q.eO.One()).Yh()}return Q}static _AddKeyframeValue(r,O,W,C,T,h){let J;const mr=O.dataType;if(mr===br.b.ANIMATIONTYPE_VECTOR3){let O=r.value.Yh();if("rotation"===C){const r=q.eO.oO(O);O=q.Quaternion.RotationYawPitchRoll(r.y,r.x,r.z).Yh()}W.push(O)}else if(mr===br.b.ANIMATIONTYPE_FLOAT){if("weights"===C)W.push([r.value]);else if(J=this._ConvertFactorToVector3OrQuaternion(r.value,T,O,C,h),J){if("rotation"===C){const r=h?J:q.Quaternion.RotationYawPitchRoll(J.y,J.x,J.z).normalize();W.push(r.Yh())}W.push(J.Yh())}}else mr===br.b.ANIMATIONTYPE_QUATERNION?W.push(r.value.normalize().Yh()):Q.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(r,O,W){let q,Q,C=!1;if("rotation"===O&&!W)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let T=0,h=r.length;T<h;++T)if(Q=r[T],Q.inTangent||Q.outTangent)if(q){if("CUBICSPLINE"!==q){q="LINEAR",C=!0;break}}else q="CUBICSPLINE";else if(q){if("CUBICSPLINE"===q||Q.interpolation&&1===Q.interpolation&&"STEP"!==q){q="LINEAR",C=!0;break}}else q=Q.interpolation&&1===Q.interpolation?"STEP":"LINEAR";return q||(q="LINEAR"),{interpolationType:q,shouldBakeAnimation:C}}static _AddSplineTangent(r,O,W,Q,C,T){let h;const J=r===vr.INTANGENT?C.inTangent:C.outTangent;if("CUBICSPLINE"===Q){if("rotation"===W)if(J)if(T)h=J.Yh();else{const r=J;h=q.Quaternion.RotationYawPitchRoll(r.y,r.x,r.z).Yh()}else h=[0,0,0,0];else h="weights"===W?J?[J]:[0]:J?J.Yh():[0,0,0];O.push(h)}}static _CalculateMinMaxKeyFrames(r){let O=1/0,W=-1/0;return r.forEach((function(r){O=Math.min(O,r.frame),W=Math.max(W,r.frame)})),{min:O,max:W}}}function Sr(r,O,W,C,T,h){const J={attributes:{},influence:r.influence,name:r.name},mr=O.Nh;if(!mr)return Q.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),J;const v=h?-1:1,g=q.eO.Zero();let K=0,U=0;if(r.hasPositions){const C=r.getPositions(),h=mr.getVerticesData(d.i.PositionKind);if(h){const r=new Float32Array(h.length),O=[1/0,1/0,1/0],Q=[-1/0,-1/0,-1/0];U=h.length/3,K=0;for(let W=K;W<U;++W){const T=q.eO.oO(h,3*W);q.eO.oO(C,3*W).subtractToRef(T,g),g.x*=v,O[0]=Math.min(O[0],g.x),Q[0]=Math.max(Q[0],g.x),O[1]=Math.min(O[1],g.y),Q[1]=Math.max(Q[1],g.y),O[2]=Math.min(O[2],g.z),Q[2]=Math.max(Q[2],g.z),r[3*W]=g.x,r[3*W+1]=g.y,r[3*W+2]=g.z}const mr=W.createBufferView(r,12),d=W.createAccessor(mr,"VEC3",5126,C.length/3,0,{min:O,max:Q});T.push(d),J.attributes.POSITION=T.length-1}else Q.Tools.Warn(`Morph target positions for mesh ${O.name} were not exported. Mesh does not have position vertex data`)}if(r.hasNormals){const C=r.getNormals(),h=mr.getVerticesData(d.i.NormalKind);if(h){const r=new Float32Array(h.length);U=h.length/3,K=0;for(let W=K;W<U;++W){const O=q.eO.oO(h,3*W).normalize();q.eO.oO(C,3*W).normalize().subtractToRef(O,g),r[3*W]=g.x*v,r[3*W+1]=g.y,r[3*W+2]=g.z}const O=W.createBufferView(r,12),Q=W.createAccessor(O,"VEC3",5126,C.length/3,0);T.push(Q),J.attributes.NORMAL=T.length-1}else Q.Tools.Warn(`Morph target normals for mesh ${O.name} were not exported. Mesh does not have normals vertex data`)}if(r.hasTangents){const C=r.getTangents(),h=mr.getVerticesData(d.i.TangentKind);if(h){U=h.length/4;const r=new Float32Array(3*U);K=0;for(let W=K;W<U;++W){const O=q.eO.oO(h,4*W);A(O);const Q=q.eO.oO(C,3*W);A(Q),Q.subtractToRef(O,g),r[3*W]=g.x*v,r[3*W+1]=g.y,r[3*W+2]=g.z}const O=W.createBufferView(r,12),Q=W.createAccessor(O,"VEC3",5126,U,0);T.push(Q),J.attributes.TANGENT=T.length-1}else Q.Tools.Warn(`Morph target tangents for mesh ${O.name} were not exported. Mesh does not have tangents vertex data`)}if(r.hasColors){const C=r.getColors(),h=mr.getVerticesData(d.i.ColorKind),v=mr.getVertexBuffer(d.i.ColorKind);if(h&&v){const r=v.getSize();U=h.length/r;const O=new Float32Array(U*r);K=0;for(let W=K;W<U;++W)if(3===r){const Q=q.eO.oO(h,W*r);q.eO.oO(C,W*r).subtractToRef(Q,g),O[3*W]=g.x,O[3*W+1]=g.y,O[3*W+2]=g.z}else if(4===r){const Q=new q.Vector4,T=q.Vector4.oO(h,W*r);q.Vector4.oO(C,W*r).subtractToRef(T,Q),O[4*W]=Q.x,O[4*W+1]=Q.y,O[4*W+2]=Q.z,O[4*W+3]=Q.w}else Q.Tools.Warn(`Unsupported number of components for color attribute: ${r}`);const mr=W.createBufferView(O,4*r),d=W.createAccessor(mr,3===r?"VEC3":"VEC4",5126,U,0);T.push(d),J.attributes.COLOR_0=T.length-1}else Q.Tools.Warn(`Morph target colors for mesh ${O.name} were not exported. Mesh does not have colors vertex data`)}return J}var or=W(13086),Nr=W(12943),Dr=W(12925),pr=W(12560);class zr{}zr.DEFAULT_COLOR=b.SO.White(),zr.DEFAULT_WIDTH_ATTENUATED=1,zr.DEFAULT_WIDTH=.1;var Lr=W(12785),Mr=W(13094);class kr{static ConvertPoints(r,O){if(r.length&&Array.isArray(r)&&"number"===typeof r[0])return[r];if(r.length&&Array.isArray(r[0])&&"number"===typeof r[0][0])return r;if(r.length&&!Array.isArray(r[0])&&r[0]instanceof q.eO){const O=[];for(let W=0;W<r.length;W++){const q=r[W];O.push(q.x,q.y,q.z)}return[O]}if(r.length>0&&Array.isArray(r[0])&&r[0].length>0&&r[0][0]instanceof q.eO){const O=[],W=r;for(const r of W)O.push(r.flatMap((r=>[r.x,r.y,r.z])));return O}if(r instanceof Float32Array){if(null!==O&&void 0!==O&&O.floatArrayStride){const W=[],q=3*O.floatArrayStride;for(let O=0;O<r.length;O+=q){const Q=new Array(q);for(let W=0;W<q;W++)Q[W]=r[O+W];W.push(Q)}return W}return[Array.from(r)]}if(r.length&&r[0]instanceof Float32Array){const O=[];for(const W of r)O.push(Array.from(W));return O}return[]}static OmitZeroLengthPredicate(r,O,W){const q=[];return O.YO(r).lengthSquared()>0&&q.push([r,O]),W.YO(O).lengthSquared()>0&&q.push([O,W]),r.YO(W).lengthSquared()>0&&q.push([W,r]),0===q.length?null:q}static OmitDuplicatesPredicate(r,O,W,q){const Q=[];return kr._SearchInPoints(r,O,q)||Q.push([r,O]),kr._SearchInPoints(O,W,q)||Q.push([O,W]),kr._SearchInPoints(W,r,q)||Q.push([W,r]),0===Q.length?null:Q}static _SearchInPoints(r,O,W){for(const T of W)for(let W=0;W<T.length;W++){var q,Q,C;if(null!==(q=T[W])&&void 0!==q&&q.equals(r))if(null!==(Q=T[W+1])&&void 0!==Q&&Q.equals(O)||null!==(C=T[W-1])&&void 0!==C&&C.equals(O))return!0}return!1}static MeshesToLines(r,O){const W=[];for(let Q=0;Q<r.length;Q++){const C=r[Q],T=C.getVerticesData(d.i.PositionKind),h=C.Dh();if(T&&h)for(let r=0,J=0;r<h.length;r++){const mr=3*h[J++],d=3*h[J++],v=3*h[J++],g=new q.eO(T[mr],T[mr+1],T[mr+2]),K=new q.eO(T[d],T[d+1],T[d+2]),U=new q.eO(T[v],T[v+1],T[v+2]);if(O){const q=O(g,K,U,W,r,mr,C,Q,T,h);if(q)for(const r of q)W.push(r)}else W.push([g,K],[K,U],[U,g])}}return W}static ToVector3Array(r){if(Array.isArray(r[0])){const O=[],W=r;for(const r of W){const W=[];for(let O=0;O<r.length;O+=3)W.push(new q.eO(r[O],r[O+1],r[O+2]));O.push(W)}return O}const O=r,W=[];for(let Q=0;Q<O.length;Q+=3)W.push(new q.eO(O[Q],O[Q+1],O[Q+2]));return W}static ToNumberArray(r){return r.flatMap((r=>[r.x,r.y,r.z]))}static GetPointsCountInfo(r){const O=new Array(r.length);let W=0;for(let q=r.length;q--;)O[q]=r[q].length/3,W+=O[q];return{total:W,counts:O}}static GetLineLength(r){if(0===r.length)return 0;let O;O="number"===typeof r[0]?kr.ToVector3Array(r):r;const W=q.TmpVectors.eO[0];let Q=0;for(let q=0;q<O.length-1;q++){const r=O[q];Q+=O[q+1].subtractToRef(r,W).length()}return Q}static GetLineLengthArray(r){const O=new Float32Array(r.length/3);let W=0;for(let q=0,Q=r.length/3-1;q<Q;q++){let Q=r[3*q+0],C=r[3*q+1],T=r[3*q+2];Q-=r[3*q+3],C-=r[3*q+4],T-=r[3*q+5];W+=Math.sqrt(Q*Q+C*C+T*T),O[q+1]=W}return O}static SegmentizeSegmentByCount(r,O,W){const Q=[],C=O.YO(r),T=q.TmpVectors.eO[0];T.Mh(W);const h=q.TmpVectors.eO[1];C.divideToRef(T,h);let J=r.clone();Q.push(J);for(let q=0;q<W;q++)J=J.clone(),Q.push(J.addInPlace(h));return Q}static SegmentizeLineBySegmentLength(r,O){const W=r[0]instanceof q.eO?kr.GetLineSegments(r):"number"===typeof r[0]?kr.GetLineSegments(kr.ToVector3Array(r)):r,Q=[];for(const q of W)if(q.length>O){const r=kr.SegmentizeSegmentByCount(q.point1,q.point2,Math.ceil(q.length/O));for(const O of r)Q.push(O)}else Q.push(q.point1),Q.push(q.point2);return Q}static SegmentizeLineBySegmentCount(r,O){const W="number"===typeof r[0]?kr.ToVector3Array(r):r,q=kr.GetLineLength(W)/O;return kr.SegmentizeLineBySegmentLength(W,q)}static GetLineSegments(r){const O=[];for(let W=0;W<r.length-1;W++){const q=r[W],Q=r[W+1],C=Q.YO(q).length();O.push({point1:q,point2:Q,length:C})}return O}static GetMinMaxSegmentLength(r){const O=kr.GetLineSegments(r).sort((r=>r.length));return{min:O[0].length,max:O[O.length-1].length}}static GetPositionOnLineByVisibility(r,O,W){let Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const C=O*W;let T=0,h=0;const J=r.length;for(let q=0;q<J;q++){if(C<=T+r[q].length){h=q;break}T+=r[q].length}const mr=(C-T)/r[h].length;return r[h].point2.subtractToRef(r[h].point1,q.TmpVectors.eO[0]),q.TmpVectors.eO[1]=q.TmpVectors.eO[0].multiplyByFloats(mr,mr,mr),Q||q.TmpVectors.eO[1].addInPlace(r[h].point1),q.TmpVectors.eO[1].clone()}static GetCircleLinePoints(r,O){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:r,C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/O;const T=[];for(let h=0;h<=O;h++)T.push(new q.eO(Math.cos(h*C)*r,Math.sin(h*C)*Q,W));return T}static GetBezierLinePoints(r,O,W,q){return Lr.h.CreateQuadraticBezier(r,O,W,q).getPoints().flatMap((r=>[r.x,r.y,r.z]))}static GetArrowCap(r,O,W,q,Q){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,T=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[r.clone(),r.add(O.multiplyByFloats(W,W,W))],widths:[q,Q,C,T]}}static GetPointsFromText(r,O,W,q){let Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const T=[],h=(0,Mr.b)(r,O,W,q);for(const J of h){for(const r of J.paths){const O=[],W=r.getPoints();for(const r of W)O.push(r.x,r.y,Q);T.push(O)}if(C)for(const r of J.holes){const O=[],W=r.getPoints();for(const r of W)O.push(r.x,r.y,Q);T.push(O)}}return T}static Color3toRGBAUint8(r){const O=new Uint8Array(4*r.length);for(let W=0,q=0;W<r.length;W++)O[q++]=255*r[W].r,O[q++]=255*r[W].g,O[q++]=255*r[W].b,O[q++]=255;return O}static CreateColorsTexture(r,O,W,q){const Q=q.getEngine().getCaps().maxTextureSize??1,C=O.length>Q?Q:O.length,T=Math.ceil(O.length/Q);T>1&&(O=[...O,...Array(C*T-O.length).fill(O[0])]);const h=kr.Color3toRGBAUint8(O),J=new o.b(h,C,T,U.b.TEXTUREFORMAT_RGBA,q,!1,!0,W);return J.name=r,J}static PrepareEmptyColorsTexture(r){if(!zr.EmptyColorsTexture){const O=new Uint8Array(4);zr.EmptyColorsTexture=new o.b(O,1,1,U.b.TEXTUREFORMAT_RGBA,r,!1,!1,o.b.NEAREST_NEAREST),zr.EmptyColorsTexture.name="grlEmptyColorsTexture"}return zr.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var r;null===(r=zr.EmptyColorsTexture)||void 0===r||r.dispose(),zr.EmptyColorsTexture=null}static BooleanToNumber(r){return r?1:0}}class sr extends Dr.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Br extends Nr.e{isCompatible(r){return!0}constructor(r,O,W){var Q;W=W||{color:zr.DEFAULT_COLOR};const C=new sr;C.GREASED_LINE_HAS_COLOR=!!W.color&&!W.useColors,C.GREASED_LINE_SIZE_ATTENUATION=W.sizeAttenuation??!1,C.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===W.colorDistributionType,C.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(O??r.Dr()).useRightHandedSystem,C.GREASED_LINE_CAMERA_FACING=W.cameraFacing??!0,super(r,Br.GREASED_LINE_MATERIAL_NAME,200,C,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(Q=W)||void 0===Q?void 0:Q.forceGLSL)||Br.ForceGLSL,this._scene=O??r.Dr(),this._engine=this._scene.getEngine(),this._cameraFacing=W.cameraFacing??!0,this.visibility=W.visibility??1,this.useDash=W.useDash??!1,this.dashRatio=W.dashRatio??.5,this.dashOffset=W.dashOffset??0,this.width=W.width?W.width:W.sizeAttenuation?zr.DEFAULT_WIDTH_ATTENUATED:zr.DEFAULT_WIDTH,this._sizeAttenuation=W.sizeAttenuation??!1,this.colorMode=W.colorMode??0,this._color=W.color??null,this.useColors=W.useColors??!1,this._colorsDistributionType=W.colorDistributionType??0,this.colorsSampling=W.colorsSampling??o.b.NEAREST_NEAREST,this._colors=W.Mr??null,this.dashCount=W.dashCount??1,this.resolution=W.resolution??new q.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),W.colorsTexture?this.colorsTexture=W.colorsTexture:this._colors?this.colorsTexture=kr.CreateColorsTexture(`${r.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??zr.DEFAULT_COLOR,kr.PrepareEmptyColorsTexture(this._scene)),this._engine.mJ.add((()=>{kr.DisposeEmptyColorsTexture()}))}getAttributes(r){r.push("grl_offsets"),r.push("grl_widths"),r.push("grl_colorPointers"),r.push("grl_counters"),this._cameraFacing?(r.push("grl_previousAndSide"),r.push("grl_nextAndCounters")):r.push("grl_slopes")}getSamplers(r){r.push("grl_colors")}getActiveTextures(r){this.colorsTexture&&r.push(this.colorsTexture)}getUniforms(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const O=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&O.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===r&&O.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:O,vertex:this._cameraFacing&&this._isGLSL(r)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(r)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(r){if(this._cameraFacing){r.Sh("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||r.Sh("viewProjection",this._scene.getTransformMatrix());const O=q.TmpVectors.Vector4[0];O.x=this._aspect,O.y=this._resolution.x,O.z=this._resolution.y,O.w=this.width,r.updateVector4("grl_aspect_resolution_lineWidth",O)}const O=q.TmpVectors.Vector4[0];O.x=kr.BooleanToNumber(this.useDash),O.y=this._dashArray,O.z=this.dashOffset,O.w=this.dashRatio,r.updateVector4("grl_dashOptions",O);const W=q.TmpVectors.Vector4[1];W.x=this.colorMode,W.y=this.visibility,W.z=this.colorsTexture?this.colorsTexture.getSize().width:0,W.w=kr.BooleanToNumber(this.useColors),r.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",W),this._color&&r.updateColor3("grl_singleColor",this._color);const Q=this.colorsTexture??zr.EmptyColorsTexture;r.setTexture("grl_colors",Q),r.updateFloat2("grl_textureSize",(null===Q||void 0===Q?void 0:Q.getSize().width)??1,(null===Q||void 0===Q?void 0:Q.getSize().height)??1)}prepareDefines(r,O,W){r.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,r.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,r.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,r.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=O.useRightHandedSystem,r.GREASED_LINE_CAMERA_FACING=this._cameraFacing,r.GREASED_LINE_USE_OFFSETS=!!W.offsets}getClassName(){return Br.GREASED_LINE_MATERIAL_NAME}getCustomCode(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(O)?function(r,O){if("vertex"===r){const r={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return O&&(r["!gl_Position\\=viewProjection\\*worldPos;"]="//"),r}return"fragment"===r?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(r,this._cameraFacing):function(r,O){if("vertex"===r){const r={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return O&&(r["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),r}return"fragment"===r?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(r,this._cameraFacing)}dispose(){var r;null===(r=this.colorsTexture)||void 0===r||r.dispose(),super.dispose()}get Mr(){return this._colors}set Mr(r){this.setColors(r)}setColors(r){var O;let W=arguments.length>1&&void 0!==arguments[1]&&arguments[1],q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var C;if(this._colors=r,null!==r&&0!==r.length){if(!W||q)if(this.colorsTexture&&Q===r.length&&!q){const O=kr.Color3toRGBAUint8(r);this.colorsTexture.update(O)}else{var T;null===(T=this.colorsTexture)||void 0===T||T.dispose(),this.colorsTexture=kr.CreateColorsTexture(`${this._material.name}-colors-texture`,r,this.colorsSampling,this._scene)}}else null===(C=this.colorsTexture)||void 0===C||C.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(r){this._dashCount=r,this._dashArray=1/r}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(r){this._sizeAttenuation=r,this.markAllDefinesAsDirty()}get color(){return this._color}set color(r){this.setColor(r)}setColor(r){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==r||null!==this._color&&null===r?(this._color=r,O||this.markAllDefinesAsDirty()):this._color=r}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(r){this._colorsDistributionType=r,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(r){this._aspect=r.x/r.y,this._resolution=r}serialize(){const r=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(O.Mr=this._colors),this._color&&(O.color=this._color),r.greasedLineMaterialOptions=O,r}parse(r,O,W){var q;super.parse(r,O,W);const Q=r.greasedLineMaterialOptions;null===(q=this.colorsTexture)||void 0===q||q.dispose(),Q.color&&this.setColor(Q.color,!0),Q.colorDistributionType&&(this.colorsDistributionType=Q.colorDistributionType),Q.Mr&&(this.Mr=Q.Mr),Q.colorsSampling&&(this.colorsSampling=Q.colorsSampling),Q.colorMode&&(this.colorMode=Q.colorMode),Q.useColors&&(this.useColors=Q.useColors),Q.visibility&&(this.visibility=Q.visibility),Q.useDash&&(this.useDash=Q.useDash),Q.dashCount&&(this.dashCount=Q.dashCount),Q.dashRatio&&(this.dashRatio=Q.dashRatio),Q.dashOffset&&(this.dashOffset=Q.dashOffset),Q.width&&(this.width=Q.width),Q.sizeAttenuation&&(this.sizeAttenuation=Q.sizeAttenuation),Q.resolution&&(this.resolution=Q.resolution),this.Mr?this.colorsTexture=kr.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Mr,this.colorsSampling,O):kr.PrepareEmptyColorsTexture(O),this.markAllDefinesAsDirty()}copyTo(r){var O;const W=r;null===(O=W.colorsTexture)||void 0===O||O.dispose(),this._colors&&(W.colorsTexture=kr.CreateColorsTexture(`${W._material.name}-colors-texture`,this._colors,W.colorsSampling,this._scene)),W.setColor(this.color,!0),W.colorsDistributionType=this.colorsDistributionType,W.colorsSampling=this.colorsSampling,W.colorMode=this.colorMode,W.useColors=this.useColors,W.visibility=this.visibility,W.useDash=this.useDash,W.dashCount=this.dashCount,W.dashRatio=this.dashRatio,W.dashOffset=this.dashOffset,W.width=this.width,W.sizeAttenuation=this.sizeAttenuation,W.resolution=this.resolution,W.markAllDefinesAsDirty()}_isGLSL(r){return 0===r||this._forceGLSL}}Br.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Br.ForceGLSL=!1,(0,pr.e)(`BABYLON.${Br.GREASED_LINE_MATERIAL_NAME}`,Br);var Zr=W(12983),Er=W(12460),Rr=W(12799),Vr=W(12543);class ar extends Rr.ShaderMaterial{constructor(r,O,Q){const C=O.getEngine(),T=C.isWebGPU&&!(Q.forceGLSL||ar.ForceGLSL),h=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];O.useRightHandedSystem&&h.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const J=["position","grl_widths","grl_offsets","grl_colorPointers"];Q.cameraFacing?(h.push("GREASED_LINE_CAMERA_FACING"),J.push("grl_previousAndSide","grl_nextAndCounters")):(J.push("grl_slopes"),J.push("grl_counters"));const mr=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(T||mr.push("world","viewProjection","view","projection"),super(r,O,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:T?["Scene","Mesh"]:void 0,attributes:J,uniforms:mr,samplers:T?[]:["grlColors"],defines:h,extraInitializationsAsync:async()=>{T?await Promise.all([W.e(66).then(W.bind(W,15771)),W.e(75).then(W.bind(W,15780))]):await Promise.all([W.e(69).then(W.bind(W,15788)),W.e(76).then(W.bind(W,15792))])},shaderLanguage:T?1:0}),this._color=b.SO.White(),this._colorsDistributionType=0,this._colorsTexture=null,Q=Q||{color:zr.DEFAULT_COLOR},this.visibility=Q.visibility??1,this.useDash=Q.useDash??!1,this.dashRatio=Q.dashRatio??.5,this.dashOffset=Q.dashOffset??0,this.dashCount=Q.dashCount??1,this.width=Q.width?Q.width:Q.sizeAttenuation&&Q.cameraFacing?zr.DEFAULT_WIDTH_ATTENUATED:zr.DEFAULT_WIDTH,this.sizeAttenuation=Q.sizeAttenuation??!1,this.color=Q.color??b.SO.White(),this.useColors=Q.useColors??!1,this.colorsDistributionType=Q.colorDistributionType??0,this.colorsSampling=Q.colorsSampling??o.b.NEAREST_NEAREST,this.colorMode=Q.colorMode??0,this._colors=Q.Mr??null,this._cameraFacing=Q.cameraFacing??!0,this.resolution=Q.resolution??new q.Vector2(C.getRenderWidth(),C.getRenderHeight()),Q.colorsTexture?this.colorsTexture=Q.colorsTexture:this._colors?this.colorsTexture=kr.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,O):(this._color=this._color??zr.DEFAULT_COLOR,this.colorsTexture=kr.PrepareEmptyColorsTexture(O)),T){const r=new Vr.d;r.setParameters(),r.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",r)}C.mJ.add((()=>{kr.DisposeEmptyColorsTexture()}))}dispose(){var r;null===(r=this._colorsTexture)||void 0===r||r.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new q.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Mr(){return this._colors}set Mr(r){this.setColors(r)}setColors(r){var O;let W=arguments.length>1&&void 0!==arguments[1]&&arguments[1],q=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var C;if(this._colors=r,null!==r&&0!==r.length){if(!W||q)if(this._colorsTexture&&Q===r.length&&!q){const O=kr.Color3toRGBAUint8(r);this._colorsTexture.update(O)}else{var T;null===(T=this._colorsTexture)||void 0===T||T.dispose(),this.colorsTexture=kr.CreateColorsTexture(`${this.name}-colors-texture`,r,this.colorsSampling,this.Dr())}}else null===(C=this._colorsTexture)||void 0===C||C.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(r){this._colorsTexture=r,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(r){this._width=r,this.setFloat("grlWidth",r)}get useColors(){return this._useColors}set useColors(r){this._useColors=r,this.setFloat("grlUseColors",kr.BooleanToNumber(r))}get colorsSampling(){return this._colorsSampling}set colorsSampling(r){this._colorsSampling=r}get visibility(){return this._visibility}set visibility(r){this._visibility=r,this.setFloat("grlVisibility",r)}get useDash(){return this._useDash}set useDash(r){this._useDash=r,this.setFloat("grlUseDash",kr.BooleanToNumber(r))}get dashOffset(){return this._dashOffset}set dashOffset(r){this._dashOffset=r,this.setFloat("grlDashOffset",r)}get dashRatio(){return this._dashRatio}set dashRatio(r){this._dashRatio=r,this.setFloat("grlDashRatio",r)}get dashCount(){return this._dashCount}set dashCount(r){this._dashCount=r,this._dashArray=1/r,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(r){this._sizeAttenuation=r,this.setFloat("grlSizeAttenuation",kr.BooleanToNumber(r))}get color(){return this._color}set color(r){this.setColor(r)}setColor(r){r=r??zr.DEFAULT_COLOR,this._color=r,this.setColor3("grlColor",r)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(r){this._colorsDistributionType=r,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(r){this._colorMode=r,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(r){this._resolution=r,this.setVector2("grlResolution",r),this.setFloat("grlAspect",r.x/r.y)}serialize(){const r=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(O.Mr=this._colors),r.greasedLineMaterialOptions=O,r}parse(r,O,W){var q;const Q=r.greasedLineMaterialOptions;null===(q=this._colorsTexture)||void 0===q||q.dispose(),Q.color&&(this.color=Q.color),Q.colorDistributionType&&(this.colorsDistributionType=Q.colorDistributionType),Q.colorsSampling&&(this.colorsSampling=Q.colorsSampling),Q.colorMode&&(this.colorMode=Q.colorMode),Q.useColors&&(this.useColors=Q.useColors),Q.visibility&&(this.visibility=Q.visibility),Q.useDash&&(this.useDash=Q.useDash),Q.dashCount&&(this.dashCount=Q.dashCount),Q.dashRatio&&(this.dashRatio=Q.dashRatio),Q.dashOffset&&(this.dashOffset=Q.dashOffset),Q.width&&(this.width=Q.width),Q.sizeAttenuation&&(this.sizeAttenuation=Q.sizeAttenuation),Q.resolution&&(this.resolution=Q.resolution),Q.Mr?this.colorsTexture=kr.CreateColorsTexture(`${this.name}-colors-texture`,Q.Mr,this.colorsSampling,this.Dr()):this.colorsTexture=kr.PrepareEmptyColorsTexture(O),this._cameraFacing=Q.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var tr,ir,lr;ar.ForceGLSL=!1,function(r){r[r.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",r[r.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(tr||(tr={})),function(r){r[r.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",r[r.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",r[r.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(ir||(ir={})),function(r){r[r.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",r[r.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",r[r.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",r[r.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",r[r.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(lr||(lr={}));class yr extends Yr.e{constructor(r,O,W){super(r,O,null,null,!1,!1),this.name=r,this._options=W,this._lazy=!1,this._updatable=!1,this._engine=O.getEngine(),this._lazy=W.lazy??!1,this._updatable=W.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=W.colorPointers??[],this._widths=W.widths??new Array(W.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(r){let O=0;for(const q of this._points)O+=q.length;const W=O/3*2-this._widths.length;for(let q=0;q<W;q++)this._widths.push(r)}updateLazy(){var r,O;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(r=this._options.ribbonOptions)||void 0===r?void 0:r.smoothShading),!this.Zr&&this.refreshBoundingInfo(),null===(O=this.greasedLineMaterial)||void 0===O||O.updateLazy()}addPoints(r,O){for(const W of r)this._points.push(W);this._lazy||this.setPoints(this._points,O)}dispose(r){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(r,O)}isLazy(){return this._lazy}get kr(){return this._uvs}set kr(r){this._uvs=r instanceof Float32Array?r:new Float32Array(r),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(r){this.material instanceof ar&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===r||void 0===r?void 0:r.length)>0),this._offsets=r,this._offsetsBuffer?this._offsetsBuffer.update(r):this._createOffsetsBuffer(r)}get widths(){return this._widths}set widths(r){this._widths=r,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(r)}get colorPointers(){return this._colorPointers}set colorPointers(r){this._colorPointers=r,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(r)}get greasedLineMaterial(){var r,O;if(this.material&&this.material instanceof ar)return this.material;const W=null===(r=this.material)||void 0===r||null===(O=r.pluginManager)||void 0===O?void 0:O.getPlugin(Br.GREASED_LINE_MATERIAL_NAME);return W||void 0}get points(){const r=[];return Er.d.DeepCopy(this._points,r),r}setPoints(r,O){this._points=kr.ConvertPoints(r,(null===O||void 0===O?void 0:O.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==O&&void 0!==O&&O.colorPointers||this._updateColorPointers(),this._setPoints(this._points,O)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,kr:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(r){super.serialize(r),r.type=this.getClassName(),r.lineOptions=this._createLineOptions()}_createVertexBuffers(){let r=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new Zr.c;return O.zr=this._vertexPositions,O.indices=this._indices,O.kr=this._uvs,r&&(O.Lr=[],Zr.c.ComputeNormals(this._vertexPositions,this._indices,O.Lr)),O.Br(this,this._options.updatable),O}_createOffsetsBuffer(r){const O=this._scene.getEngine(),W=new d.e(O,r,this._updatable,3);this.setVerticesBuffer(W.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=W}}class wr{constructor(r,O){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=r,this.wasAddedByNoopNode=O}getIndicesAccessor(r,O,W,q,Q){var C,T,h,J;return null===(C=this._indicesAccessorMap.get(r))||void 0===C||null===(T=C.get(O))||void 0===T||null===(h=T.get(W))||void 0===h||null===(J=h.get(q))||void 0===J?void 0:J.get(Q)}setIndicesAccessor(r,O,W,q,Q,C){let T=this._indicesAccessorMap.get(r);T||(T=new Map,this._indicesAccessorMap.set(r,T));let h=T.get(O);h||(h=new Map,T.set(O,h));let J=h.get(W);J||(J=new Map,h.set(W,J));let mr=J.get(q);mr||(mr=new Map,J.set(q,mr)),mr.set(Q,C)}pushExportedNode(r){this._exportedNodes.has(r)||this._exportedNodes.add(r)}getNodesSet(){return this._exportedNodes}getVertexBufferView(r){return this._vertexBufferViewMap.get(r)}setVertexBufferView(r,O){this._vertexBufferViewMap.set(r,O)}setRemappedBufferView(r,O,W){this._remappedBufferView.set(r,new Map),this._remappedBufferView.get(r).set(O,W)}getRemappedBufferView(r,O){var W;return null===(W=this._remappedBufferView.get(r))||void 0===W?void 0:W.get(O)}getVertexAccessor(r,O,W){var q,Q;return null===(q=this._vertexAccessorMap.get(r))||void 0===q||null===(Q=q.get(O))||void 0===Q?void 0:Q.get(W)}setVertexAccessor(r,O,W,q){let Q=this._vertexAccessorMap.get(r);Q||(Q=new Map,this._vertexAccessorMap.set(r,Q));let C=Q.get(O);C||(C=new Map,Q.set(O,C)),C.set(W,q)}hasVertexColorAlpha(r){return this._vertexMapColorAlpha.get(r)||!1}setHasVertexColorAlpha(r,O){return this._vertexMapColorAlpha.set(r,O)}getMesh(r){return this._meshMap.get(r)}setMesh(r,O){this._meshMap.set(r,O)}bindMorphDataToMesh(r,O){const W=this._meshMorphTargetMap.get(r)||[];this._meshMorphTargetMap.set(r,W),-1===W.indexOf(O)&&W.push(O)}getMorphTargetsFromMesh(r){return this._meshMorphTargetMap.get(r)}}class ur{_ApplyExtension(r,O,W,q){if(W>=O.length)return Promise.resolve(r);const Q=q(O[W],r);return Q?Q.then((async r=>r?await this._ApplyExtension(r,O,W+1,q):null)):this._ApplyExtension(r,O,W+1,q)}_ApplyExtensions(r,O){const W=[];for(const q of ur._ExtensionNames)W.push(this._extensions[q]);return this._ApplyExtension(r,W,0,O)}_extensionsPreExportTextureAsync(r,O,W){return this._ApplyExtensions(O,((O,q)=>O.preExportTextureAsync&&O.preExportTextureAsync(r,q,W)))}_extensionsPostExportNodeAsync(r,O,W,q,Q){return this._ApplyExtensions(O,((O,C)=>O.postExportNodeAsync&&O.postExportNodeAsync(r,C,W,q,Q,this._bufferManager)))}_extensionsPostExportMaterialAsync(r,O,W){return this._ApplyExtensions(O,((O,q)=>O.postExportMaterialAsync&&O.postExportMaterialAsync(r,q,W)))}_extensionsPostExportMaterialAdditionalTextures(r,O,W){const q=[];for(const Q of ur._ExtensionNames){const C=this._extensions[Q];C.postExportMaterialAdditionalTextures&&q.push(...C.postExportMaterialAdditionalTextures(r,O,W))}return q}_extensionsPostExportTextures(r,O,W){for(const q of ur._ExtensionNames){const Q=this._extensions[q];Q.postExportTexture&&Q.postExportTexture(r,O,W)}}_extensionsPostExportMeshPrimitive(r){for(const O of ur._ExtensionNames){const W=this._extensions[O];W.postExportMeshPrimitive&&W.postExportMeshPrimitive(r,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const r of ur._ExtensionNames){const O=this._extensions[r];O.preGenerateBinaryAsync&&await O.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(r){for(const O of ur._ExtensionNames){const W=this._extensions[O];W.enabled&&r(W)}}_extensionsOnExporting(){this._forEachExtensions((r=>{var O,W,q;r.wasUsed&&((O=this._glTF).extensionsUsed||(O.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(r.name)&&this._glTF.extensionsUsed.push(r.name),r.required&&((W=this._glTF).extensionsRequired||(W.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(r.name)&&this._glTF.extensionsRequired.push(r.name)),(q=this._glTF).extensions||(q.extensions={}),r.onExporting&&r.onExporting())}))}_loadExtensions(){for(const r of ur._ExtensionNames){const O=ur._ExtensionFactories[r](this);this._extensions[r]=O}}constructor(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:P.d.LastCreatedScene,O=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${U.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new V(this),this._extensions={},this._bufferManager=new dr,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!r)throw new Error("No scene available to export");this._babylonScene=r,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:r=>{var O;return null===r||void 0===r||null===(O=r.Uh)||void 0===O?void 0:O.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...O},this._loadExtensions()}dispose(){for(const r in this._extensions){this._extensions[r].dispose()}}get options(){return this._options}static RegisterExtension(r,O){ur.UnregisterExtension(r)&&Q.Tools.Warn(`Extension with the name ${r} already exists`),ur._ExtensionFactories[r]=O,ur._ExtensionNames.push(r)}static UnregisterExtension(r){if(!ur._ExtensionFactories[r])return!1;delete ur._ExtensionFactories[r];const O=ur._ExtensionNames.indexOf(r);return-1!==O&&ur._ExtensionNames.splice(O,1),!0}_generateJSON(r,O,W){const q={byteLength:r};return q.byteLength&&(this._glTF.buffers=[q]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.GO=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(q.uri=O+".bin"),W?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(r){const O=await this._generateBinaryAsync();this._extensionsOnExporting();const W=this._generateJSON(O.byteLength,r,!0),q=new Blob([O],{type:"application/octet-stream"}),Q=r+".gltf",C=r+".bin",T=new mr;if(T.files[Q]=W,T.files[C]=q,this._imageData)for(const h in this._imageData)T.files[h]=new Blob([this._imageData[h].data],{type:this._imageData[h].mimeType});return T}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(r){const O=r%4;return 0===O?O:4-O}async generateGLBAsync(r){this._shouldUseGlb=!0;const O=await this._generateBinaryAsync();this._extensionsOnExporting();const W=this._generateJSON(O.byteLength),q=r+".glb";let Q,C=W.length;if("undefined"!==typeof TextEncoder){Q=(new TextEncoder).encode(W),C=Q.length}const T=this._getPadding(C),h=this._getPadding(O.byteLength),J=28+C+T+O.byteLength+h,d=new Jr(J);if(d.writeUInt32(1179937895),d.writeUInt32(2),d.writeUInt32(J),d.writeUInt32(C+T),d.writeUInt32(1313821514),Q)d.writeTypedArray(Q);else{const r="_".charCodeAt(0);for(let O=0;O<C;++O){const q=W.charCodeAt(O);q!=W.codePointAt(O)?d.writeUInt8(r):d.writeUInt8(q)}}for(let mr=0;mr<T;++mr)d.writeUInt8(32);d.writeUInt32(O.byteLength+h),d.writeUInt32(5130562),d.writeTypedArray(O);for(let mr=0;mr<h;++mr)d.writeUInt8(0);const v=new mr;return v.files[q]=new Blob([d.getOutputData()],{type:"application/octet-stream"}),v}_setNodeTransformation(r,O,W){if(O.getPivotPoint().equalsWithEpsilon(y,l.c)||Q.Tools.Warn("Pivot points are not supported in the glTF serializer"),!O.position.equalsWithEpsilon(y,l.c)){const Q=q.TmpVectors.eO[0].C(O.position);W&&x(Q),r.translation=Q.Yh()}O.Lh.equalsWithEpsilon(u,l.c)||(r.scale=O.Lh.Yh());const C=O.rotationQuaternion||q.Quaternion.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);C.equalsWithEpsilon(w,l.c)||(W&&I(C),r.rotation=C.normalize().Yh())}_setCameraTransformation(r,O,W){if(!O.position.equalsWithEpsilon(y,l.c)){const Q=q.TmpVectors.eO[0].C(O.position);W&&x(Q),r.translation=Q.Yh()}const Q=O.rotationQuaternion||q.Quaternion.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);W&&I(Q),this._babylonScene.useRightHandedSystem||c(Q),Q.equalsWithEpsilon(w,l.c)||(r.rotation=Q.Yh())}_listAvailableCameras(){for(const r of this._babylonScene.cameras){const O={type:r.mode===gr.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(r.name&&(O.name=r.name),"perspective"===O.type)O.perspective={aspectRatio:r.getEngine().getAspectRatio(r),yfov:r.fovMode===gr.b.FOVMODE_VERTICAL_FIXED?r.fov:r.fov*r.getEngine().getAspectRatio(r),znear:r.Xh,zfar:r.maxZ};else if("orthographic"===O.type){const W=r.orthoLeft&&r.orthoRight?.5*(r.orthoRight-r.orthoLeft):.5*r.getEngine().getRenderWidth(),q=r.orthoBottom&&r.orthoTop?.5*(r.orthoTop-r.orthoBottom):.5*r.getEngine().getRenderHeight();O.orthographic={xmag:W,ymag:q,znear:r.Xh,zfar:r.maxZ}}this._camerasMap.set(r,O)}}_exportAndAssignCameras(){const r=Array.from(this._camerasMap.values());for(const O of r){const r=this._nodesCameraMap.get(O);if(void 0!==r){this._cameras.push(O);for(const O of r)O.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const r of this._babylonScene.skeletons){if(r.bones.length<=0)continue;const O={joints:[]};this._skinMap.set(r,O)}}_exportAndAssignSkeletons(){for(const r of this._babylonScene.skeletons){if(r.bones.length<=0)continue;const O=this._skinMap.get(r);if(void 0==O)continue;const W={},q=[];let C=-1;for(let Q=0;Q<r.bones.length;++Q){const O=r.bones[Q],q=O.getIndex()??Q;-1!==q&&(W[q]=O,q>C&&(C=q))}for(let r=0;r<=C;++r){const C=W[r];q.push(C.getAbsoluteInverseBindMatrix());const T=C.getTransformNode();if(null!==T){const r=this._nodeMap.get(T);T&&null!==r&&void 0!==r?O.joints.push(r):Q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else Q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const T=this._nodesSkinMap.get(O);if(O.joints.length>0&&void 0!==T){const r=64*q.length,W=new Float32Array(r/4);q.forEach(((r,O)=>{W.set(r.m,16*O)}));const Q=this._bufferManager.createBufferView(W);this._accessors.push(this._bufferManager.createAccessor(Q,"MAT4",5126,q.length)),O.inverseBindMatrices=this._accessors.length-1,this._skins.push(O);for(const O of T)O.skin=this._skins.length-1}}}async _exportSceneAsync(){const r={nodes:[]};if(this._babylonScene.metadata){const O=this._options.metadataSelector(this._babylonScene.metadata);O&&(r.extras=O)}const O=new Array,W=new Array,q=new Array;for(const h of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Tr(h,this._babylonScene.useRightHandedSystem)?q.push(...h.getChildren()):this._babylonScene.useRightHandedSystem?O.push(h):W.push(h);this._listAvailableCameras(),this._listAvailableSkeletons();const Q=new wr(!0,!1);r.nodes.push(...await this._exportNodesAsync(W,Q));const C=new wr(!1,!1);r.nodes.push(...await this._exportNodesAsync(O,C));const T=new wr(!1,!0);r.nodes.push(...await this._exportNodesAsync(q,T)),r.nodes.length&&this._scenes.push(r),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Xr._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Q.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(r){let O=this._shouldExportNodeMap.get(r);return void 0===O&&(O=this._options.shouldExportNode(r),this._shouldExportNodeMap.set(r,O)),O}async _exportNodesAsync(r,O){const W=new Array;this._exportBuffers(r,O);for(const q of r)await this._exportNodeAsync(q,W,O);return W}_collectBuffers(r,O,W,q,Q){if(this._shouldExportNode(r)&&r instanceof g.c&&r.Nh){const C=r.Nh.getVertexBuffers();if(C)for(const q in C){if(!j(q))continue;const T=C[q];Q.setHasVertexColorAlpha(T,r.hasVertexAlpha);const h=T._buffer,J=O.get(h)||[];O.set(h,J),-1===J.indexOf(T)&&J.push(T);const mr=W.get(T)||[];W.set(T,mr),-1===mr.indexOf(r)&&mr.push(r)}const T=r.morphTargetManager;if(T)for(let O=0;O<T.numTargets;O++){const W=T.getTarget(O),Q=q.get(W)||[];q.set(W,Q),-1===Q.indexOf(r)&&Q.push(r)}}for(const C of r.getChildren())this._collectBuffers(C,O,W,q,Q)}_exportBuffers(r,O){const W=new Map,q=new Map,Q=new Map;for(const h of r)this._collectBuffers(h,W,q,Q,O);const C=Array.from(W.keys());for(const h of C){const r=h.getData();if(!r)throw new Error("Buffer data is not available");const Q=W.get(h);if(!Q)continue;const C=Q[0].byteStride;if(Q.some((r=>r.byteStride!==C)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const T=Wr(r).slice();for(const O of Q){const r=q.get(O),{byteOffset:W,byteStride:Q,componentCount:C,type:h,count:J,normalized:mr,kind:v}=f(O,r);switch(v){case d.i.NormalKind:case d.i.TangentKind:(0,a.k)(T,W,Q,C,h,J,mr,(r=>{const O=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);if(O>0){const W=1/O;r[0]*=W,r[1]*=W,r[2]*=W}}));break;case d.i.ColorKind:{const O=r.filter((r=>r.material instanceof Pr.XO||null==r.material)).length;if(0==O)break;if(O!=r.length){t.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}h==d.i.UNSIGNED_BYTE&&t.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const q=new b.SO,v=new b.kh,g=this._babylonScene.getEngine().useExactSrgbConversions;(0,a.k)(T,W,Q,C,h,J,mr,(r=>{3===r.length?(q.eW(r,0),q.toLinearSpaceToRef(q,g),q.toArray(r,0)):(v.eW(r,0),v.toLinearSpaceToRef(v,g),v.toArray(r,0))}))}}}if(O.convertToRightHanded){for(const r of Q){const O=q.get(r),{byteOffset:W,byteStride:Q,componentCount:C,type:h,count:J,normalized:mr,kind:v}=f(r,O);switch(v){case d.i.PositionKind:case d.i.NormalKind:case d.i.TangentKind:(0,a.k)(T,W,Q,C,h,J,mr,(r=>{r[0]=-r[0]}))}}O.convertedToRightHandedBuffers.set(h,T)}const J=this._bufferManager.createBufferView(T,C);O.setVertexBufferView(h,J);const mr=new Map;for(const O of Q){const r=q.get(O),{kind:W,totalVertices:Q}=f(O,r);switch(W){case d.i.MatricesIndicesKind:case d.i.MatricesIndicesExtraKind:if(O.type==d.i.FLOAT){const r=O.getFloatData(Q);null!==r&&mr.set(O,r)}}}0!==mr.size&&t.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const v=Array.from(mr.keys());for(const W of v){const r=mr.get(W);if(!r)continue;const q=r.some((r=>r>=256)),Q=new(q?Uint16Array:Uint8Array)(r.length);for(let O=0;O<r.length;O++)Q[O]=r[O];const C=this._bufferManager.createBufferView(Q,4*(q?2:1));O.setRemappedBufferView(h,W,C)}}const T=Array.from(Q.keys());for(const h of T){const r=Q.get(h);if(!r)continue;const W=Sr(h,r[0],this._bufferManager,this._bufferViews,this._accessors,O.convertToRightHanded);for(const q of r)O.bindMorphDataToMesh(q,W)}}async _exportNodeAsync(r,O,W){let q=this._nodeMap.get(r);if(void 0!==q)return void(O.includes(q)||O.push(q));const Q=await this._createNodeAsync(r,W);if(Q){q=this._nodes.length,this._nodes.push(Q),this._nodeMap.set(r,q),W.pushExportedNode(r),O.push(q);const C={name:"runtime animations",channels:[],samplers:[]},T=[];this._babylonScene.animationGroups.length||(Xr._CreateMorphTargetAnimationFromMorphTargetAnimations(r,C,T,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,W.convertToRightHanded,this._options.shouldExportAnimation),r.animations.length&&Xr._CreateNodeAnimationFromNodeAnimations(r,C,T,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,W.convertToRightHanded,this._options.shouldExportAnimation)),C.channels.length&&C.samplers.length&&this._animations.push(C),T.forEach((r=>{r.channels.length&&r.samplers.length&&this._animations.push(r)}))}const C=Q?[]:O;for(const T of r.getChildren())await this._exportNodeAsync(T,C,W);Q&&C.length&&(Q.children=C)}async _createNodeAsync(r,O){if(!this._shouldExportNode(r))return null;const W={};if(r.name&&(W.name=r.name),r.metadata){const O=this._options.metadataSelector(r.metadata);O&&(W.extras=O)}if(r instanceof v.b&&(this._setNodeTransformation(W,r,O.convertToRightHanded),r instanceof g.c)){const Q=r instanceof K.d?r.sourceMesh:r;if(Q.eh&&Q.eh.length>0&&(W.mesh=await this._exportMeshAsync(Q,O)),r.skeleton){const O=this._skinMap.get(r.skeleton);var q;if(void 0!==O)void 0===this._nodesSkinMap.get(O)&&this._nodesSkinMap.set(O,[]),null===(q=this._nodesSkinMap.get(O))||void 0===q||q.push(W)}}if(r instanceof i.e){const q=this._camerasMap.get(r);if(q){var Q;void 0===this._nodesCameraMap.get(q)&&this._nodesCameraMap.set(q,[]),this._setCameraTransformation(W,r,O.convertToRightHanded);const T=r.parent;if(null!==T&&Or(r,T)){const r=this._nodeMap.get(T);if(void 0!==r){var C;const O=this._nodes[r];return rr(W,O),null===(C=this._nodesCameraMap.get(q))||void 0===C||C.push(O),null}}null===(Q=this._nodesCameraMap.get(q))||void 0===Q||Q.push(W)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",W,r,this._nodeMap,O.convertToRightHanded)?W:(t.b.Warn(`Not exporting node ${r.name}`),null)}_exportIndices(r,O,W,q,Q,T,h,J,mr){let d=r;mr.mode=H(T);const v=h!==C.d.CounterClockWiseSideOrientation,g=!J.wasAddedByNoopNode&&v,K=function(r){switch(r){case C.d.TriangleFillMode:case C.d.TriangleStripDrawMode:case C.d.TriangleFanDrawMode:return!0}return!1}(T)&&g;if(K){if(T===C.d.TriangleStripDrawMode||T===C.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");mr.mode=H(T);const h=O?new Uint32Array(q):new Uint16Array(q);if(r)for(let O=0;O+2<q;O+=3)h[O]=r[W+O]+Q,h[O+1]=r[W+O+2]+Q,h[O+2]=r[W+O+1]+Q;else for(let r=0;r+2<q;r+=3)h[r]=r,h[r+1]=r+2,h[r+2]=r+1;d=h}else if(r&&0!==Q){const C=O?new Uint32Array(q):new Uint16Array(q);for(let O=0;O<q;O++)C[O]=r[W+O]+Q;d=C}if(d){let C=J.getIndicesAccessor(r,W,q,Q,K);if(void 0===C){const T=function(r,O,W,q){if(r instanceof Uint16Array||r instanceof Uint32Array)return r;if(r instanceof Int32Array)return new Uint32Array(r.buffer,r.byteOffset,r.length);const Q=r.slice(O,O+W);return q?new Uint32Array(Q):new Uint16Array(Q)}(d,0,q,O),h=this._bufferManager.createBufferView(T),mr=O?5125:5123;this._accessors.push(this._bufferManager.createAccessor(h,"SCALAR",mr,q,0)),C=this._accessors.length-1,J.setIndicesAccessor(r,W,q,Q,K,C)}mr.indices=C}}_exportVertexBuffer(r,O,W,q,Q,C){const T=r.getKind();if(!j(T))return;if(T.startsWith("uv")&&!this._options.exportUnusedUVs&&(!O||!this._materialNeedsUVsSet.has(O)))return;let h=Q.getVertexAccessor(r,W,q);if(void 0===h){const O=Q.convertedToRightHandedBuffers.get(r._buffer)||r._buffer.getData(),C=T===d.i.PositionKind?function(r,O,W,q){const{byteOffset:Q,byteStride:C,type:T,normalized:h}=O,J=O.getSize(),mr=new Array(J).fill(1/0),d=new Array(J).fill(-1/0);return(0,a.k)(r,Q+W*C,C,J,T,q*J,h,(r=>{for(let O=0;O<J;O++)mr[O]=Math.min(mr[O],r[O]),d[O]=Math.max(d[O],r[O])})),{min:mr,max:d}}(O,r,W,q):void 0,J=(T===d.i.MatricesIndicesKind||T===d.i.MatricesIndicesExtraKind)&&r.type===d.i.FLOAT,mr=J?d.i.UNSIGNED_BYTE:r.type,v=J?void 0:r.normalized,g=J?Q.getRemappedBufferView(r._buffer,r):Q.getVertexBufferView(r._buffer),K=r.byteOffset+W*r.byteStride;this._accessors.push(this._bufferManager.createAccessor(g,function(r,O){if(r==d.i.ColorKind)return O?"VEC4":"VEC3";switch(r){case d.i.PositionKind:case d.i.NormalKind:return"VEC3";case d.i.TangentKind:case d.i.MatricesIndicesKind:case d.i.MatricesIndicesExtraKind:case d.i.MatricesWeightsKind:case d.i.MatricesWeightsExtraKind:return"VEC4";case d.i.UVKind:case d.i.UV2Kind:case d.i.UV3Kind:case d.i.UV4Kind:case d.i.UV5Kind:case d.i.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${r}`)}(T,Q.hasVertexColorAlpha(r)),mr,q,K,C,v)),h=this._accessors.length-1,Q.setVertexAccessor(r,W,q,h)}C.attributes[function(r){switch(r){case d.i.PositionKind:return"POSITION";case d.i.NormalKind:return"NORMAL";case d.i.TangentKind:return"TANGENT";case d.i.ColorKind:return"COLOR_0";case d.i.UVKind:return"TEXCOORD_0";case d.i.UV2Kind:return"TEXCOORD_1";case d.i.UV3Kind:return"TEXCOORD_2";case d.i.UV4Kind:return"TEXCOORD_3";case d.i.UV5Kind:return"TEXCOORD_4";case d.i.UV6Kind:return"TEXCOORD_5";case d.i.MatricesIndicesKind:return"JOINTS_0";case d.i.MatricesIndicesExtraKind:return"JOINTS_1";case d.i.MatricesWeightsKind:return"WEIGHTS_0";case d.i.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${r}`)}(T)]=h}async _exportMaterialAsync(r,O,W,q){let Q=this._materialMap.get(r);if(void 0===Q){const q=O&&Object.keys(O).some((r=>r.startsWith("uv")));if((r=r instanceof Kr.e?r.sh[W.materialIndex]:r)instanceof Ur.d)Q=await this._materialExporter.exportPBRMaterialAsync(r,"image/png",q);else{if(!(r instanceof Pr.XO))return void t.b.Warn(`Unsupported material '${r.name}' with type ${r.getClassName()}`);Q=await this._materialExporter.exportStandardMaterialAsync(r,"image/png",q)}this._materialMap.set(r,Q)}q.material=Q}async _exportMeshAsync(r,O){var W;let q=O.getMesh(r);if(void 0!==q)return q;const Q={primitives:[]};q=this._meshes.length,this._meshes.push(Q),O.setMesh(r,q);const T=r.isUnIndexed?null:r.Dh(),h=null===(W=r.Nh)||void 0===W?void 0:W.getVertexBuffers(),J=O.getMorphTargetsFromMesh(r),mr=r instanceof or.e,d=r instanceof yr,v=r.eh;if(h&&v&&v.length>0)for(const U of v){const W={attributes:{}},q=U.ar()||this._babylonScene.defaultMaterial;if(d){var g,K;const O={name:q.name},Q=r,C=b.SO.White(),T=(null===(g=Q.material)||void 0===g?void 0:g.alpha)??1,h=(null===(K=Q.greasedLineMaterial)||void 0===K?void 0:K.color)??C;(!h.equalsWithEpsilon(C,l.c)||T<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...h.Yh(),T]}),this._materials.push(O),W.material=this._materials.length-1}else if(mr){const O={name:q.name},Q=r;(!Q.color.equalsWithEpsilon(b.SO.White(),l.c)||Q.alpha<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...Q.color.Yh(),Q.alpha]}),this._materials.push(O),W.material=this._materials.length-1}else await this._exportMaterialAsync(q,h,U,W);const v=mr||d?C.d.LineListDrawMode:r.overrideRenderingFillMode??q.fillMode,P=q._getEffectiveOrientation(r);this._exportIndices(T,T?(0,a.d)(T,U.indexCount,U.indexStart,U.verticesStart):U.verticesCount>65535,T?U.indexStart:U.verticesStart,T?U.indexCount:U.verticesCount,-U.verticesStart,v,P,O,W);for(const r of Object.values(h))this._exportVertexBuffer(r,q,U.verticesStart,U.verticesCount,O,W);if(J){W.targets=[];for(const r of J)W.targets.push(r.attributes)}Q.primitives.push(W),this._extensionsPostExportMeshPrimitive(W)}if(J){Q.weights=[],Q.extras||(Q.extras={}),Q.extras.targetNames=[];for(const r of J)Q.weights.push(r.influence),Q.extras.targetNames.push(r.name)}return q}}ur._ExtensionNames=new Array,ur._ExtensionFactories={};class nr{static async GLTFAsync(r,O,W){W&&W.exportWithoutWaitingForScene||await r.whenReadyAsync();const q=new ur(r,W),Q=await q.generateGLTFAsync(O.replace(/\.[^/.]+$/,""));return q.dispose(),Q}static async GLBAsync(r,O,W){W&&W.exportWithoutWaitingForScene||await r.whenReadyAsync();const q=new ur(r,W),Q=await q.generateGLBAsync(O.replace(/\.[^/.]+$/,""));return q.dispose(),Q}}W(13106);const fr="EXT_mesh_gpu_instancing";class Fr{constructor(r){this.name=fr,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=r}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(r,O,W,Q,C,T){return await new Promise((r=>{if(O&&W instanceof Yr.e&&W.hasThinInstances&&this._exporter){this._wasUsed=!0;const r=q.eO.Zero(),Q=q.Quaternion.Identity(),h=q.eO.One(),J=W.thinInstanceGetWorldMatrices(),mr=q.TmpVectors.eO[2],d=q.TmpVectors.Quaternion[1],v=q.TmpVectors.eO[3];let g=!1,K=!1,U=!1;const P=new Float32Array(3*W.Bh),b=new Float32Array(4*W.Bh),e=new Float32Array(3*W.Bh);let Y=0;for(const O of J)O.decompose(v,d,mr),C&&(x(mr),I(d)),P.set(mr.Yh(),3*Y),b.set(d.normalize().Yh(),4*Y),e.set(v.Yh(),3*Y),g=g||!mr.equalsWithEpsilon(r),K=K||!d.equalsWithEpsilon(Q),U=U||!v.equalsWithEpsilon(h),Y++;const G={attributes:{}};g&&(G.attributes.TRANSLATION=this._buildAccessor(P,"VEC3",W.Bh,T)),K&&(G.attributes.ROTATION=this._buildAccessor(b,"VEC4",W.Bh,T)),U&&(G.attributes.SCALE=this._buildAccessor(e,"VEC3",W.Bh,T)),O.extensions=O.extensions||{},O.extensions[fr]=G}r(O)}))}_buildAccessor(r,O,W,q){const Q=q.createBufferView(r),C=q.createAccessor(Q,O,5126,W);return this._exporter._accessors.push(C),this._exporter._accessors.length-1}}ur.RegisterExtension(fr,(r=>new Fr(r)));var jr=W(13111),Hr=W(13126),Ar=W(13129),xr=W(13135);function Ir(r){return r===Ar.b.PositionKind?"POSITION":r===Ar.b.NormalKind?"NORMAL":r===Ar.b.ColorKind?"COLOR":r.startsWith(Ar.b.UVKind)?"TEX_COORD":"GENERIC"}const cr={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class rO extends jr.c{static get DefaultAvailable(){return(0,jr.h)(rO.DefaultConfiguration)}static get Default(){return rO._Default??(rO._Default=new rO),rO._Default}static ResetDefault(r){rO._Default&&(r||rO._Default.dispose(),rO._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(r,O){return{module:await(O||DracoEncoderModule)({wasmBinary:r})}}_getWorkerContent(){return`${Hr.j}(${Hr.m})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:rO.DefaultConfiguration)}async _encodeAsync(r,O,W){const q=W?(0,xr.e)(cr,W):cr;if(this._workerPoolPromise){const W=await this._workerPoolPromise;return await new Promise(((Q,C)=>{W.push(((W,T)=>{const h=r=>{W.removeEventListener("error",h),W.removeEventListener("message",J),C(r),T()},J=r=>{"encodeMeshDone"===r.data.id&&(W.removeEventListener("error",h),W.removeEventListener("message",J),Q(r.data.encodedMeshData),T())};W.addEventListener("error",h),W.addEventListener("message",J);const mr=[];for(const O of r)mr.push(O.data.buffer);O&&mr.push(O.buffer),W.postMessage({id:"encodeMesh",attributes:r,indices:O,options:q},mr)}))}))}if(this._modulePromise){const W=await this._modulePromise;return(0,Hr.j)(W.module,r,O,q)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(r,O){if(0==r.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");r instanceof Yr.e&&r.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===O||void 0===O?void 0:O.method)&&(t.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),O.method="MESH_SEQUENTIAL_ENCODING");const W=function(r){let O=r.Dh(void 0,!0);return!O||O instanceof Uint32Array||O instanceof Uint16Array||(O=((0,a.d)(O,O.length)?Uint32Array:Uint16Array).from(O)),O}(r),q=function(r,O){const W=[];for(const q of r.getVerticesDataKinds()){if(null!==O&&void 0!==O&&O.includes(q)){if(q===Ar.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const Q=r.getVertexBuffer(q),C=Q.getSize(),T=(0,a.s)(Q.getData(),C,Q.type,Q.byteOffset,Q.byteStride,Q.normalized,r.getTotalVertices(),!0);W.push({kind:q,dracoName:Ir(q),size:C,data:T})}return W}(r,null===O||void 0===O?void 0:O.excludedAttributes);return await this._encodeAsync(q,W,O)}}rO.DefaultConfiguration={wasmUrl:`${Q.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${Q.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${Q.Tools._DefaultCdnUrl}/draco_encoder.js`},rO._Default=null;const OO="KHR_draco_mesh_compression";class WO{get wasUsed(){return this._wasUsed}constructor(r){this.name=OO,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===r.options.meshCompressionMethod&&rO.DefaultAvailable}dispose(){}postExportMeshPrimitive(r,O,W){if(!this.enabled)return;if(4!==r.mode&&5!==r.mode)return void t.b.Warn("Cannot compress primitive with mode "+r.mode+".");const q=[],Q=[];let C=null;if(void 0!==r.indices){const T=W[r.indices],h=O.getBufferView(T);C=O.getData(h).slice(),q.push(h),Q.push(T)}const T=[];for(const[d,v]of Object.entries(r.attributes)){const r=W[v],C=O.getBufferView(r),J=F(r.type),mr=(0,a.s)(O.getData(C),J,r.componentType,r.byteOffset||0,C.byteStride||(0,a.n)(r.componentType)*J,r.normalized||!1,r.count,!0);T.push({kind:d,dracoName:(h=d,"POSITION"===h?"POSITION":"NORMAL"===h?"NORMAL":h.startsWith("COLOR")?"COLOR":h.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:F(r.type),data:mr}),q.push(C),Q.push(r)}var h;const J={method:r.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},mr=rO.Default._encodeAsync(T,C,J).then((W=>{if(!W)return void t.b.Error("Draco encoding failed for primitive.");const C={bufferView:-1,attributes:W.attributeIds},T=O.createBufferView(W.data);O.setBufferView(C,T);for(const r of q)this._bufferViewsUsed.add(r);for(const r of Q)this._accessorsUsed.add(r);r.extensions||(r.extensions={}),r.extensions[OO]=C})).catch((r=>{t.b.Error("Draco encoding failed for primitive: "+r)}));this._encodePromises.push(mr),this._wasUsed=!0}async preGenerateBinaryAsync(r){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((O=>{r.getPropertiesWithBufferView(O).every((r=>this._accessorsUsed.has(r)))&&r.removeBufferView(O)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}ur.RegisterExtension(OO,(r=>new WO(r)));var qO=W(13139);const QO="KHR_lights_punctual",CO={name:"",color:[1,1,1],Zh:1,range:Number.MAX_VALUE},TO={innerConeAngle:0,outerConeAngle:Math.PI/4},hO=q.eO.Backward();class JO{constructor(r){this.name=QO,this.enabled=!0,this.required=!1,this._exporter=r}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[QO]=this._lights}async postExportNodeAsync(r,O,W,Q,C){return await new Promise((T=>{if(!(W instanceof Gr.e))return void T(O);const h=W.getTypeID()==Gr.e.LIGHTTYPEID_POINTLIGHT?"point":W.getTypeID()==Gr.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":W.getTypeID()==Gr.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!h||!(W instanceof qO.b))return t.b.Warn(`${r}: Light ${W.name} is not supported in ${QO}`),void T(O);if(W.falloffType!==Gr.e.FALLOFF_GLTF&&t.b.Warn(`${r}: Light falloff for ${W.name} does not match the ${QO} specification!`),!W.position.equalsToFloats(0,0,0)){const r=q.TmpVectors.eO[0].C(W.position);C&&x(r),O.translation=r.Yh()}if("point"!==h){const r=W.direction.normalizeToRef(q.TmpVectors.eO[0]);C&&x(r);const Q=q.Quaternion.FromUnitVectorsToRef(hO,r,q.TmpVectors.Quaternion[0]);q.Quaternion.IsIdentity(Q)||(O.rotation=Q.Yh())}const J={type:h,name:W.name,color:W.Eh.Yh(),Zh:W.Zh,range:W.range};if(qr(J,CO),"spot"===h){const r=W;J.spot={innerConeAngle:r.innerAngle/2,outerConeAngle:r.angle/2},qr(J.spot,TO)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(J);const mr={XC:this._lights.lights.length-1},d=W.parent;if(d&&Or(W,d)){const r=Q.get(d);if(r){const W=this._exporter._nodes[r];return rr(O,W),W.extensions||(W.extensions={}),W.extensions[QO]=mr,void T(null)}}O.extensions||(O.extensions={}),O.extensions[QO]=mr,T(O)}))}}ur.RegisterExtension(QO,(r=>new JO(r)));var mW=W(13044);const dO="KHR_materials_anisotropy";class vO{constructor(r){this.name=dO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=r}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(r,O,W){const q=[];return W instanceof mW.c&&W.anisotropy.isEnabled&&!W.anisotropy.legacy?(W.anisotropy.texture&&q.push(W.anisotropy.texture),q):[]}postExportMaterialAsync(r,O,W){return new Promise((r=>{if(W instanceof mW.c){if(!W.anisotropy.isEnabled||W.anisotropy.legacy)return void r(O);this._wasUsed=!0,O.extensions=O.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(W.anisotropy.texture),Q={anisotropyStrength:W.anisotropy.Zh,anisotropyRotation:W.anisotropy.angle,anisotropyTexture:q??void 0};null!==Q.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(W),O.extensions[dO]=Q}r(O)}))}}ur.RegisterExtension(dO,(r=>new vO(r)));const gO="KHR_materials_clearcoat";class KO{constructor(r){this.name=gO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=r}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(r,O,W){const q=[];return W instanceof mW.c&&W.clearCoat.isEnabled?(W.clearCoat.texture&&q.push(W.clearCoat.texture),!W.clearCoat.useRoughnessFromMainTexture&&W.clearCoat.textureRoughness&&q.push(W.clearCoat.textureRoughness),W.clearCoat.bumpTexture&&q.push(W.clearCoat.bumpTexture),q):[]}postExportMaterialAsync(r,O,W){return new Promise((r=>{if(W instanceof mW.c){if(!W.clearCoat.isEnabled)return void r(O);this._wasUsed=!0,O.extensions=O.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(W.clearCoat.texture);let C;C=W.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(W.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(W.clearCoat.textureRoughness),W.clearCoat.isTintEnabled&&Q.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${W.name}`),W.clearCoat.remapF0OnInterfaceChange&&Q.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${W.name}`);const T=this._exporter._materialExporter.getTextureInfo(W.clearCoat.bumpTexture),h={clearcoatFactor:W.clearCoat.Zh,clearcoatTexture:q??void 0,clearcoatRoughnessFactor:W.clearCoat.roughness,clearcoatRoughnessTexture:C??void 0,clearcoatNormalTexture:T??void 0};null===h.clearcoatTexture&&null===h.clearcoatRoughnessTexture&&null===h.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(W),O.extensions[gO]=h}r(O)}))}}ur.RegisterExtension(gO,(r=>new KO(r)));const UO="KHR_materials_diffuse_transmission";function PO(r,O){const W=O.subSurface;let q=null;return W.translucencyIntensityTexture?q=W.translucencyIntensityTexture:W.thicknessTexture&&W.useMaskFromThicknessTexture&&(q=W.thicknessTexture),q&&!W.useGltfStyleTextures?(t.b.Warn(`${r}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${O.name}`,1),null):q}class bO{constructor(r){this.name=UO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=r}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(r,O,W){const q=[];if(W instanceof Ur.d&&this._isExtensionEnabled(W)){const O=PO(r,W);return O&&q.push(O),W.subSurface.translucencyColorTexture&&q.push(W.subSurface.translucencyColorTexture),q}return q}_isExtensionEnabled(r){if(r.unlit)return!1;const O=r.subSurface;return!!O.isTranslucencyEnabled&&(!r.unlit&&!O.useAlbedoToTintTranslucency&&O.useGltfStyleTextures&&1===O.volumeIndexOfRefraction&&0===O.minimumThickness&&0===O.maximumThickness)}postExportMaterialAsync(r,O,W){return new Promise((q=>{if(W instanceof Ur.d&&this._isExtensionEnabled(W)){this._wasUsed=!0;const q=W.subSurface,Q=PO(r,W),C=0==q.translucencyIntensity?void 0:q.translucencyIntensity,T=this._exporter._materialExporter.getTextureInfo(Q)??void 0,h=!q.translucencyColor||q.translucencyColor.equalsFloats(1,1,1)?void 0:q.translucencyColor.Yh(),J=this._exporter._materialExporter.getTextureInfo(q.translucencyColorTexture)??void 0,mr={diffuseTransmissionFactor:C,diffuseTransmissionTexture:T,diffuseTransmissionColorFactor:h,diffuseTransmissionColorTexture:J};(T||J)&&this._exporter._materialNeedsUVsSet.add(W),O.extensions=O.extensions||{},O.extensions[UO]=mr}q(O)}))}}ur.RegisterExtension(UO,(r=>new bO(r)));const eO="KHR_materials_dispersion";class YO{constructor(){this.name=eO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(r){if(r.unlit)return!1;const O=r.subSurface;return!(!O.isRefractionEnabled&&!O.isDispersionEnabled)}postExportMaterialAsync(r,O,W){return new Promise((r=>{if(W instanceof Ur.d&&this._isExtensionEnabled(W)){this._wasUsed=!0;const r={dispersion:W.subSurface.dispersion};O.extensions=O.extensions||{},O.extensions[eO]=r}r(O)}))}}ur.RegisterExtension(eO,(()=>new YO));const GO="KHR_materials_emissive_strength";class XO{constructor(){this.name=GO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(r,O,W){return await new Promise((r=>{if(!(W instanceof Ur.d))return r(O);const q=W.emissiveColor.Yh(),Q=Math.max(...q);if(Q>1){this._wasUsed=!0,O.extensions||(O.extensions={});const r={emissiveStrength:Q},q=W.emissiveColor.scale(1/r.emissiveStrength);O.emissiveFactor=q.Yh(),O.extensions[GO]=r}return r(O)}))}}ur.RegisterExtension(GO,(r=>new XO));const SO="KHR_materials_ior";class oO{constructor(){this.name=SO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(r){return!r.unlit&&(void 0!=r.indexOfRefraction&&1.5!=r.indexOfRefraction)}postExportMaterialAsync(r,O,W){return new Promise((r=>{if(W instanceof Ur.d&&this._isExtensionEnabled(W)){this._wasUsed=!0;const r={ior:W.indexOfRefraction};O.extensions=O.extensions||{},O.extensions[SO]=r}r(O)}))}}ur.RegisterExtension(SO,(r=>new oO));const NO="KHR_materials_iridescence";class DO{constructor(r){this.name=NO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=r}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(r,O,W){const q=[];return W instanceof mW.c&&W.iridescence.isEnabled?(W.iridescence.texture&&q.push(W.iridescence.texture),W.iridescence.thicknessTexture&&W.iridescence.thicknessTexture!==W.iridescence.texture&&q.push(W.iridescence.thicknessTexture),q):[]}postExportMaterialAsync(r,O,W){return new Promise((r=>{if(W instanceof mW.c){if(!W.iridescence.isEnabled)return void r(O);this._wasUsed=!0,O.extensions=O.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(W.iridescence.texture),Q=this._exporter._materialExporter.getTextureInfo(W.iridescence.thicknessTexture),C={iridescenceFactor:W.iridescence.Zh,iridescenceIor:W.iridescence.indexOfRefraction,iridescenceThicknessMinimum:W.iridescence.minimumThickness,iridescenceThicknessMaximum:W.iridescence.maximumThickness,iridescenceTexture:q??void 0,iridescenceThicknessTexture:Q??void 0};null===C.iridescenceTexture&&null===C.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(W),O.extensions[NO]=C}r(O)}))}}ur.RegisterExtension(NO,(r=>new DO(r)));const pO="KHR_materials_sheen";class zO{constructor(r){this.name=pO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=r}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(r,O,W){return W instanceof Ur.d&&W.sheen.isEnabled&&W.sheen.texture?[W.sheen.texture]:[]}async postExportMaterialAsync(r,O,W){return await new Promise((r=>{if(W instanceof Ur.d){if(!W.sheen.isEnabled)return void r(O);this._wasUsed=!0,null==O.extensions&&(O.extensions={});const q={sheenColorFactor:W.sheen.color.Yh(),sheenRoughnessFactor:W.sheen.roughness??0};null===q.sheenColorTexture&&null===q.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(W),W.sheen.texture&&(q.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(W.sheen.texture)??void 0),W.sheen.textureRoughness&&!W.sheen.useRoughnessFromMainTexture?q.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(W.sheen.textureRoughness)??void 0:W.sheen.texture&&W.sheen.useRoughnessFromMainTexture&&(q.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(W.sheen.texture)??void 0),O.extensions[pO]=q}r(O)}))}}ur.RegisterExtension(pO,(r=>new zO(r)));const LO="KHR_materials_specular";class MO{constructor(r){this.name=LO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=r}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(r,O,W){const q=[];return W instanceof Ur.d&&this._isExtensionEnabled(W)?(W.metallicReflectanceTexture&&q.push(W.metallicReflectanceTexture),W.reflectanceTexture&&q.push(W.reflectanceTexture),q):q}_isExtensionEnabled(r){return!r.unlit&&(void 0!=r.metallicF0Factor&&1!=r.metallicF0Factor||void 0!=r.metallicReflectanceColor&&!r.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(r))}_hasTexturesExtension(r){return null!=r.metallicReflectanceTexture||null!=r.reflectanceTexture}postExportMaterialAsync(r,O,W){return new Promise((r=>{if(W instanceof Ur.d&&this._isExtensionEnabled(W)){this._wasUsed=!0,O.extensions=O.extensions||{};const r=this._exporter._materialExporter.getTextureInfo(W.metallicReflectanceTexture)??void 0,q=this._exporter._materialExporter.getTextureInfo(W.reflectanceTexture)??void 0,Q={specularFactor:1==W.metallicF0Factor?void 0:W.metallicF0Factor,specularTexture:r,specularColorFactor:W.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:W.metallicReflectanceColor.Yh(),specularColorTexture:q};this._hasTexturesExtension(W)&&this._exporter._materialNeedsUVsSet.add(W),O.extensions[LO]=Q}r(O)}))}}ur.RegisterExtension(LO,(r=>new MO(r)));const kO="KHR_materials_transmission";class sO{constructor(r){this.name=kO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=r}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(r,O,W){const q=[];return W instanceof Ur.d&&this._isExtensionEnabled(W)?(W.subSurface.thicknessTexture&&q.push(W.subSurface.thicknessTexture),q):q}_isExtensionEnabled(r){if(r.unlit)return!1;const O=r.subSurface;return O.isRefractionEnabled&&void 0!=O.refractionIntensity&&0!=O.refractionIntensity||this._hasTexturesExtension(r)}_hasTexturesExtension(r){return null!=r.subSurface.refractionIntensityTexture}async postExportMaterialAsync(r,O,W){if(W instanceof Ur.d&&this._isExtensionEnabled(W)){this._wasUsed=!0;const q=W.subSurface,Q={transmissionFactor:0===q.refractionIntensity?void 0:q.refractionIntensity};if(this._hasTexturesExtension(W)&&this._exporter._materialNeedsUVsSet.add(W),q.refractionIntensityTexture)if(q.useGltfStyleTextures){const r=await this._exporter._materialExporter.exportTextureAsync(q.refractionIntensityTexture,"image/png");r&&(Q.transmissionTexture=r)}else t.b.Warn(`${r}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);O.extensions||(O.extensions={}),O.extensions[kO]=Q}return O}}ur.RegisterExtension(kO,(r=>new sO(r)));const BO="KHR_materials_unlit";class ZO{constructor(){this.name=BO,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(r,O,W){return new Promise((r=>{let q=!1;W instanceof Ur.d?q=W.unlit:W instanceof Pr.XO&&(q=W.disableLighting),q&&(this._wasUsed=!0,null==O.extensions&&(O.extensions={}),O.extensions[BO]={}),r(O)}))}}ur.RegisterExtension(BO,(()=>new ZO));const EO="KHR_materials_volume";class RO{constructor(r){this.name=EO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=r}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(r,O,W){const q=[];return W instanceof Ur.d&&this._isExtensionEnabled(W)?(W.subSurface.thicknessTexture&&q.push(W.subSurface.thicknessTexture),q):q}_isExtensionEnabled(r){if(r.unlit)return!1;const O=r.subSurface;return!(!O.isRefractionEnabled&&!O.isTranslucencyEnabled)&&(void 0!=O.maximumThickness&&0!=O.maximumThickness||void 0!=O.tintColorAtDistance&&O.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=O.tintColor&&O.tintColor!=b.SO.White()||this._hasTexturesExtension(r))}_hasTexturesExtension(r){return null!=r.subSurface.thicknessTexture}postExportMaterialAsync(r,O,W){return new Promise((r=>{if(W instanceof Ur.d&&this._isExtensionEnabled(W)){this._wasUsed=!0;const r=W.subSurface,q={thicknessFactor:0==r.maximumThickness?void 0:r.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(r.thicknessTexture)??void 0,attenuationDistance:r.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:r.tintColorAtDistance,attenuationColor:r.tintColor.equalsFloats(1,1,1)?void 0:r.tintColor.Yh()};this._hasTexturesExtension(W)&&this._exporter._materialNeedsUVsSet.add(W),O.extensions=O.extensions||{},O.extensions[EO]=q}r(O)}))}}ur.RegisterExtension(EO,(r=>new RO(r)));const VO="EXT_materials_diffuse_roughness";class aO{constructor(r){this.name=VO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=r}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(r,O,W){const q=[];return W instanceof mW.c&&W._baseDiffuseRoughness?(W._baseDiffuseRoughnessTexture&&q.push(W._baseDiffuseRoughnessTexture),q):[]}postExportMaterialAsync(r,O,W){return new Promise((r=>{if(W instanceof mW.c){if(!W._baseDiffuseRoughness)return void r(O);this._wasUsed=!0,O.extensions=O.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(W._baseDiffuseRoughnessTexture),Q={diffuseRoughnessFactor:W._baseDiffuseRoughness,diffuseRoughnessTexture:q??void 0};null!==Q.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(W),O.extensions[VO]=Q}r(O)}))}}ur.RegisterExtension(VO,(r=>new aO(r)));const tO="KHR_texture_transform";class iO{constructor(){this.name=tO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(r,O,W){if(W.Dr()||Q.Tools.Warn(`${r}: /*@__KEY__*/"scene" is not defined for Babylon texture ${W.name}!`),(0!==W.uAng||0!==W.vAng)&&(Q.Tools.Warn(`${r}: Texture ${W.name} with rotation in the u or v axis is not supported in glTF.`),0!==W.uRotationCenter||0!==W.vRotationCenter))return;const q={};let C=!1;if(0===W.uOffset&&0===W.vOffset||(q.offset=[W.uOffset,W.vOffset],C=!0),1===W.uScale&&1===W.vScale||(q.scale=[W.uScale,W.vScale],C=!0),0!==W.wAng){if(0!==W.uRotationCenter||0!==W.vRotationCenter){if(W.homogeneousRotationInUVTransform&&W.uScale!==W.vScale)return void Q.Tools.Warn(`${r}: Texture ${W.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${tO}.`);Q.Tools.Warn(`${r}: Texture ${W.name} with non-origin rotation center will be exported using an adjusted offset with ${tO}.`),q.offset=function(r){const{uOffset:O,vOffset:W,uRotationCenter:q,vRotationCenter:Q,uScale:C,vScale:T,wAng:h}=r,J=Math.cos(h),mr=Math.sin(h),d=q*C,v=Q*T;return[O+(d*(1-J)+v*mr),W+(v*(1-J)-d*mr)]}(W)}q.rotation=-W.wAng,C=!0}0!==W.coordinatesIndex&&(q.texCoord=W.coordinatesIndex,C=!0),C&&(this._wasUsed=!0,O.extensions||(O.extensions={}),O.extensions[tO]=q)}}ur.RegisterExtension(tO,(()=>new iO));class lO{static CreateSTL(r){let O=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],C=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],T=arguments.length>5&&void 0!==arguments[5]&&arguments[5],h=arguments.length>6&&void 0!==arguments[6]&&arguments[6],J=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const mr=function(r,O,W){const Q=[3*r[W],3*r[W+1],3*r[W+2]],C=[new q.eO(O[Q[0]],O[Q[0]+2],O[Q[0]+1]),new q.eO(O[Q[1]],O[Q[1]+2],O[Q[1]+1]),new q.eO(O[Q[2]],O[Q[2]+2],O[Q[2]+1])],T=C[0].YO(C[1]),h=C[2].YO(C[1]);return{v:C,n:q.eO.Cross(h,T).normalize()}},v=function(r,O,W,q){return O=g(r,O,W.x,q),O=g(r,O,W.y,q),g(r,O,W.z,q)},g=function(r,O,W,q){return r.setFloat32(O,W,q),O+4},U=function(r){if(h){let O=r;r instanceof K.d&&(O=r.sourceMesh);const W=O.getVerticesData(d.i.PositionKind,!0,!0);if(!W)return[];const Q=q.eO.Zero();let C;for(C=0;C<W.length;C+=3)q.eO.TransformCoordinatesFromFloatsToRef(W[C],W[C+1],W[C+2],r.oh(!0),Q).toArray(W,C);return W}return r.getVerticesData(d.i.PositionKind)||[]};h&&(T=!0);let P="",b=0,e=0;if(Q){for(let W=0;W<r.length;W++){const O=r[W].Dh();b+=O?O.length/3:0}const O=new ArrayBuffer(84+50*b);P=new DataView(O),e+=80,P.setUint32(e,b,C),e+=4}else J||(P="solid stlmesh\r\n");for(let q=0;q<r.length;q++){const O=r[q];!Q&&J&&(P+="solid "+O.name+"\r\n"),!T&&O instanceof Yr.e&&O.bakeCurrentTransformIntoVertices();const W=U(O),h=O.Dh()||[];for(let r=0;r<h.length;r+=3){const O=mr(h,W,r);Q?(e=v(P,e,O.n,C),e=v(P,e,O.v[0],C),e=v(P,e,O.v[1],C),e=v(P,e,O.v[2],C),e+=2):(P+="\tfacet normal "+O.n.x+" "+O.n.y+" "+O.n.z+"\r\n",P+="\t\touter loop\r\n",P+="\t\t\tvertex "+O.v[0].x+" "+O.v[0].y+" "+O.v[0].z+"\r\n",P+="\t\t\tvertex "+O.v[1].x+" "+O.v[1].y+" "+O.v[1].z+"\r\n",P+="\t\t\tvertex "+O.v[2].x+" "+O.v[2].y+" "+O.v[2].z+"\r\n",P+="\t\tendloop\r\n",P+="\tendfacet\r\n")}!Q&&J&&(P+="endsolid "+name+"\r\n")}if(Q||J||(P+="endsolid stlmesh"),O){const r=document.createElement("a"),O=new Blob([P],{type:"application/octet-stream"});r.href=window.URL.createObjectURL(O),r.download=W+".stl",r.click()}return P}}function yO(r,O){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const q=[];for(let Q=0;Q<r.length/W;Q++){const C=r[Q*W],T=r[Q*W+1],h=r[Q*W+2];q.push(`(${C.toPrecision(O.precision)}, ${T.toPrecision(O.precision)}, ${h.toPrecision(O.precision)})`)}return q.join(", ")}function wO(r,O){const W=[];for(let q=0;q<r.length/2;q++){const Q=r[2*q],C=r[2*q+1];W.push(`(${Q.toPrecision(O.precision)}, ${(1-C).toPrecision(O.precision)})`)}return W.join(", ")}function uO(r,O){const W=r.getVerticesData(d.i.PositionKind),q=r.getVerticesData(d.i.NormalKind);if(W&&q)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(r){var O;const W=null!==(O=r.Dh())&&void 0!==O&&O.length?r.getTotalIndices():r.getTotalVertices();return Array(W/3).fill(3).join(", ")}(r)}]\n\t\tint[] faceVertexIndices = [${function(r){const O=r.Dh(),W=[];if(null!==O)for(let q=0;q<O.length;q++)W.push(O[q]);else{const O=r.getTotalVertices();for(let r=0;r<O;r++)W.push(r)}return W.join(", ")}(r)}]\n\t\tnormal3f[] normals = [${yO(q,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${yO(W,O)}]\n        ${function(r,O){let W="";for(let Q=0;Q<4;Q++){const q=Q>0?Q:"",C=r.getVerticesData(d.i.UVKind+(q?q+1:""));C&&(W+=`\n\t\ttexCoord2f[] primvars:st${q} = [${wO(C,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const q=r.getVerticesData(d.i.ColorKind);return q&&(W+=`\n\tcolor3f[] primvars:displayColor = [${yO(q,O,q.length/r.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),W}(r,O)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function nO(r,O){return`\n        def "Geometry"\n        {\n        ${uO(r,O)}\n        }\n        `}function fO(r){let O='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return O+=r,fflate.strToU8(O)}function FO(r){const O=r.m;return`( ${jO(O,0)}, ${jO(O,4)}, ${jO(O,8)}, ${jO(O,12)} )`}function jO(r,O){return`(${r[O+0]}, ${r[O+1]}, ${r[O+2]}, ${r[O+3]})`}function HO(r){const O="Object_"+r.uniqueId,W=function(r){const O=r.getWorldMatrix().clone(),W=r.Dr().useRightHandedSystem;if(!W){let q=r.parent;for(;q;){if(Tr(q,W)){O.multiplyToRef(q.getWorldMatrix().invert(),O);break}q=q.parent}}return O.determinant()<0&&Q.Tools.Warn(`Exporting mesh ${r.name} with negative scale. Result may look incorrect in destination engine.`),O}(r),q=FO(W);return`def Xform "${O}" (\n\tprepend references = @./geometries/Geometry_${r.Nh.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${q}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${r.material.uniqueId}>\n}\n\n`}function AO(r){switch(r){case N.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case N.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case N.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function xO(r){return`(${r.x}, ${r.y})`}function IO(r){return`(${r.r}, ${r.g}, ${r.b})`}function cO(r,O,W,Q,C,T){const h=r.getInternalTexture().uniqueId+"_"+r.invertY;C[h]=r;const J=r.coordinatesIndex>0?"st"+r.coordinatesIndex:"st",mr=new q.Vector2(r.uScale,r.vScale),d=new q.Vector2(r.uOffset,r.vOffset),v=r.wAng,g=Math.sin(v),K=Math.cos(v);return d.y=1-d.y-mr.y,d.x+=g*mr.x,d.y+=(1-K)*mr.y,`\n    def Shader "PrimvarReader_${W}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${J}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${W}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${O.uniqueId}/PrimvarReader_${W}.outputs:result>\n        float inputs:rotation = ${(v*(180/Math.PI)).toFixed(T.precision)}\n        float2 inputs:scale = ${xO(mr)}\n        float2 inputs:translation = ${xO(d)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${r.uniqueId}_${W}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${h}.png@\n        float2 inputs:st.connect = </Materials/Material_${O.uniqueId}/Transform2d_${W}.outputs:result>\n        ${Q?"float4 inputs:scale = "+function(r){return`(${r.r}, ${r.g}, ${r.b}, 1.0)`}(Q):""}\n        token inputs:sourceColorSpace = "${r.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${AO(r.wrapU)}"\n        token inputs:wrapT = "${AO(r.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${O.needAlphaBlending()?"float outputs:a":""}\n    }`}function rW(r,O,W){const q="\t\t\t",Q=[],C=[],{diffuseMap:T,Eh:h,alphaCutOff:J,emissiveMap:mr,emissive:d,normalMap:v,roughnessMap:g,roughnessChannel:K,roughness:U,metalnessMap:P,metalnessChannel:e,metalness:Y,aoMap:G,aoMapChannel:X,aoMapIntensity:S,alphaMap:o,ior:N,clearCoatEnabled:D,clearCoat:p,clearCoatMap:z,clearCoatRoughness:L,clearCoatRoughnessMap:M}=function(r){const O={diffuseMap:null,Eh:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return r instanceof Pr.XO?{...O,diffuseMap:r.diffuseTexture,Eh:r.diffuseColor,alphaCutOff:r.alphaCutOff,emissiveMap:r.emissiveTexture,emissive:r.emissiveColor,roughness:1,alphaMap:r.opacityTexture}:r instanceof mW.c?{...O,diffuseMap:r._albedoTexture,Eh:r._albedoColor,alphaCutOff:r._alphaCutOff,emissiveMap:r._emissiveTexture,emissive:r._emissiveColor,normalMap:r._bumpTexture,roughnessMap:r._metallicTexture,roughnessChannel:r._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:r._roughness??1,metalnessMap:r._metallicTexture,metalnessChannel:r._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:r._metallic??0,aoMap:r._ambientTexture,aoMapChannel:r._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:r._ambientTextureStrength,alphaMap:r._opacityTexture,ior:r.subSurface.indexOfRefraction,clearCoatEnabled:r.clearCoat.isEnabled,clearCoat:r.clearCoat.Zh,clearCoatMap:r.clearCoat.texture,clearCoatRoughness:r.clearCoat.roughness,clearCoatRoughnessMap:r.clearCoat.useRoughnessFromMainTexture?r.clearCoat.texture:r.clearCoat.textureRoughness}:O}(r);return null!==T?(Q.push(`${q}color3f inputs:diffuseColor.connect = </Materials/Material_${r.uniqueId}/Texture_${T.uniqueId}_diffuse.outputs:rgb>`),r.needAlphaBlending()?Q.push(`${q}float inputs:opacity.connect = </Materials/Material_${r.uniqueId}/Texture_${T.uniqueId}_diffuse.outputs:a>`):r.needAlphaTesting()&&(Q.push(`${q}float inputs:opacity.connect = </Materials/Material_${r.uniqueId}/Texture_${T.uniqueId}_diffuse.outputs:a>`),Q.push(`${q}float inputs:opacityThreshold = ${J}`)),C.push(cO(T,r,"diffuse",h,O,W))):Q.push(`${q}color3f inputs:diffuseColor = ${IO(h||b.SO.White())}`),null!==mr?(Q.push(`${q}color3f inputs:emissiveColor.connect = </Materials/Material_${r.uniqueId}/Texture_${mr.uniqueId}_emissive.outputs:rgb>`),C.push(cO(mr,r,"emissive",d,O,W))):d&&d.toLuminance()>0&&Q.push(`${q}color3f inputs:emissiveColor = ${IO(d)}`),null!==v&&(Q.push(`${q}normal3f inputs:normal.connect = </Materials/Material_${r.uniqueId}/Texture_${v.uniqueId}_normal.outputs:rgb>`),C.push(cO(v,r,"normal",null,O,W))),null!==G&&(Q.push(`${q}float inputs:occlusion.connect = </Materials/Material_${r.uniqueId}/Texture_${G.uniqueId}_occlusion.outputs:${X}>`),C.push(cO(G,r,"occlusion",new b.SO(S,S,S),O,W))),null!==g?(Q.push(`${q}float inputs:roughness.connect = </Materials/Material_${r.uniqueId}/Texture_${g.uniqueId}_roughness.outputs:${K}>`),C.push(cO(g,r,"roughness",new b.SO(U,U,U),O,W))):Q.push(`${q}float inputs:roughness = ${U}`),null!==P?(Q.push(`${q}float inputs:metallic.connect = </Materials/Material_${r.uniqueId}/Texture_${P.uniqueId}_metallic.outputs:${e}>`),C.push(cO(P,r,"metallic",new b.SO(Y,Y,Y),O,W))):Q.push(`${q}float inputs:metallic = ${Y}`),null!==o?(Q.push(`${q}float inputs:opacity.connect = </Materials/Material_${r.uniqueId}/Texture_${o.uniqueId}_opacity.outputs:r>`),Q.push(`${q}float inputs:opacityThreshold = 0.0001`),C.push(cO(o,r,"opacity",null,O,W))):Q.push(`${q}float inputs:opacity = ${r.alpha}`),D&&(null!==z?(Q.push(`${q}float inputs:clearcoat.connect = </Materials/Material_${r.uniqueId}/Texture_${z.uniqueId}_clearcoat.outputs:r>`),C.push(cO(z,r,"clearcoat",new b.SO(p,p,p),O,W))):Q.push(`${q}float inputs:clearcoat = ${p}`),null!==M?(Q.push(`${q}float inputs:clearcoatRoughness.connect = </Materials/Material_${r.uniqueId}/Texture_${M.uniqueId}_clearcoatRoughness.outputs:g>`),C.push(cO(M,r,"clearcoatRoughness",new b.SO(L,L,L),O,W))):Q.push(`${q}float inputs:clearcoatRoughness = ${L}`)),Q.push(`${q}float inputs:ior = ${N}`),`\n\tdef Material "Material_${r.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${Q.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${r.uniqueId}/PreviewSurface.outputs:surface>\n\n${C.join("\n")}\n\n\t}\n`}async function OW(r,O,W){const C={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...O};"undefined"===typeof fflate&&await Q.Tools.LoadScriptAsync(C.fflateUrl);const T={};T[C.modelFileName]=null;let h='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';h+=function(r){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===r.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${r.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${r.planeAnchoringAlignment}"`:""}\n            `}(C);const J={};for(const q of r.meshes){if(0===q.getTotalVertices())continue;const r=q,O=r.Nh,mr=r.material;if(!mr||!O||W&&!W(r))continue;if(-1!==["XO","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(mr.getClassName())){const W="geometries/Geometry_"+O.uniqueId+".usda";if(!(W in T)){const r=nO(O,C);T[W]=fO(r)}mr.uniqueId in J||(J[mr.uniqueId]=mr),h+=HO(r)}else Q.Tools.Warn("USDZExportAsync does not support this material type: "+mr.getClassName())}r.activeCamera&&C.exportCamera&&(h+=function(r,O){const W="Camera_"+r.uniqueId,Q=FO(q.Matrix.RotationY(Math.PI).multiply(r.getWorldMatrix()));if(r.mode===N.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${W}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${Q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${r.Xh.toPrecision(O.precision)}, ${r.maxZ.toPrecision(O.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(r.orthoLeft||1)+Math.abs(r.orthoRight||1))).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(r.orthoTop||1)+Math.abs(r.orthoBottom||1))).toPrecision(O.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const q=r.getEngine().getAspectRatio(r),C=O.cameraSensorWidth||35;return`def Camera "${W}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${Q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${r.Xh.toPrecision(O.precision)}, ${r.maxZ.toPrecision(O.precision)})\n\t\t\tfloat focalLength = ${(C/(2*Math.tan(.5*r.fov))).toPrecision(O.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(C*q).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(C/q).toPrecision(O.precision)}            \n\t\t}\n\t\n\t`}}(r.activeCamera,C)),h+="\n            }\n        }\n    }";const mr={};h+=function(r,O,W){const q=[];for(const Q in r){const C=r[Q];q.push(rW(C,O,W))}return`\n    def "Materials"\n{\n${q.join("")}\n}\n\n`}(J,mr,C),T[C.modelFileName]=fflate.strToU8(h);for(const q in mr){const r=mr[q],O=r.getSize(),W=await r.readPixels();if(!W)throw new Error("Texture data is not available");const Q=await D.DumpTools.DumpDataAsync(O.width,O.height,W,"image/png",void 0,!1,!0);T[`textures/Texture_${q}.png`]=new Uint8Array(Q).slice()}let d=0;for(const q in T){const r=T[q];if(!r)continue;d+=34+q.length;const O=63&d;if(4!==O){const W=new Uint8Array(64-O);T[q]=[r,{extra:{12345:W}}]}d=r.length}return fflate.zipSync(T,{level:0})}}}]);