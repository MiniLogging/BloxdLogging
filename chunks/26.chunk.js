"use strict";(self.n4ygn1cq9vg=self.n4ygn1cq9vg||[]).push([[26],{12820:(e,d,v)=>{v.r(d),v.d(d,{EXT_materials_diffuse_roughness:()=>ud,EXT_mesh_gpu_instancing:()=>be,GLTF2Export:()=>Ie,GLTFData:()=>W,KHR_draco_mesh_compression:()=>vd,KHR_lights_punctual:()=>zd,KHR_materials_anisotropy:()=>kd,KHR_materials_clearcoat:()=>Fd,KHR_materials_diffuse_transmission:()=>Ud,KHR_materials_dispersion:()=>Cd,KHR_materials_emissive_strength:()=>hd,KHR_materials_ior:()=>nd,KHR_materials_iridescence:()=>xd,KHR_materials_sheen:()=>mv,KHR_materials_specular:()=>Zd,KHR_materials_transmission:()=>Td,KHR_materials_unlit:()=>od,KHR_materials_volume:()=>Qd,KHR_texture_transform:()=>Rd,OBJExport:()=>B,STLExport:()=>Yd,USDZExportAsync:()=>dv,_ConvertToGLTFPBRMetallicRoughness:()=>S,_SolveMetallic:()=>T,__IGLTFExporterExtension:()=>X});var P=v(12420),p=v(12240),L=v(12734);class B{static OBJ(e,d,v,B){const X=[];let z=1,W=1;d&&(v||(v="mat"),X.push("mtllib "+v+".mtl"));for(let V=0;V<e.length;V++){const v=e[V],k=v.name||`mesh${V}}`;X.push(`o ${k}`);let g=null;if(B){const e=v.Md(!0);g=new P.Matrix,e.invertToRef(g),v.bakeTransformIntoVertices(e)}if(d){const e=v.material;e&&X.push("usemtl "+e.id)}const F=v.sd;if(!F){p.Tools.Warn("No geometry is present on the mesh");continue}const w=F.getVerticesData("position"),G=F.getVerticesData("normal"),U=F.getVerticesData("uv"),D=F.yd();let C=0,q=0;if(!w||!D){p.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const h=e[0].Ae().useRightHandedSystem?1:-1;for(let e=0;e<w.length;e+=3)X.push("v "+w[e]*h+" "+w[e+1]+" "+w[e+2]),C++;if(null!=G)for(let e=0;e<G.length;e+=3)X.push("vn "+G[e]*h+" "+G[e+1]+" "+G[e+2]);if(null!=U)for(let e=0;e<U.length;e+=2)X.push("vt "+U[e]+" "+U[e+1]),q++;const l=["","",""],n=(v.material||v.Ae().defaultMaterial)._getEffectiveOrientation(v),[A,x]=n===L.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let e=0;e<D.length;e+=3){const d=[String(D[e]+z),String(D[e+A]+z),String(D[e+x]+z)],v=[String(D[e]+W),String(D[e+A]+W),String(D[e+x]+W)],P=d,p=null!=U?v:l,L=null!=G?d:l;X.push("f "+P[0]+"/"+p[0]+"/"+L[0]+" "+P[1]+"/"+p[1]+"/"+L[1]+" "+P[2]+"/"+p[2]+"/"+L[2])}B&&g&&v.bakeTransformIntoVertices(g),z+=C,W+=q}return X.join("\n")}static MTL(e){const d=[],v=e.material;d.push("newmtl mat1"),d.push("  Ns "+v.specularPower.toFixed(4)),d.push("  Ni 1.5000"),d.push("  d "+v.alpha.toFixed(4)),d.push("  Tr 0.0000"),d.push("  Tf 1.0000 1.0000 1.0000"),d.push("  illum 2"),d.push("  Ka "+v.ambientColor.r.toFixed(4)+" "+v.ambientColor.g.toFixed(4)+" "+v.ambientColor.b.toFixed(4)),d.push("  Kd "+v.diffuseColor.r.toFixed(4)+" "+v.diffuseColor.g.toFixed(4)+" "+v.diffuseColor.b.toFixed(4)),d.push("  Ks "+v.specularColor.r.toFixed(4)+" "+v.specularColor.g.toFixed(4)+" "+v.specularColor.b.toFixed(4)),d.push("  Ke "+v.emissiveColor.r.toFixed(4)+" "+v.emissiveColor.g.toFixed(4)+" "+v.emissiveColor.b.toFixed(4));v.ambientTexture&&d.push("  map_Ka "+v.ambientTexture.name),v.diffuseTexture&&d.push("  map_Kd "+v.diffuseTexture.name),v.specularTexture&&d.push("  map_Ks "+v.specularTexture.name),v.bumpTexture&&d.push("  map_bump -imfchan z "+v.bumpTexture.name),v.opacityTexture&&d.push("  map_d "+v.opacityTexture.name);return d.join("\n")}}var X=0,z=v(12283);class W{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const e in this.files){const d=this.files[e],v=new Blob([d],{type:(0,z.f)(e)});p.Tools.Download(v,e)}}}var V=v(12490),k=v(12829),g=v(12839),F=v(12860),w=v(12550),G=v(12281),U=v(12463),D=v(12440);const C=D.HighestCommonFactor,q={...D,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:C};var h=v(12643),l=v(12399),n=v(12893),A=v(12897),x=v(12639);const i=1e-6,me=new U.Kd(.04,.04,.04),r=1024,Z=U.Kd.White(),f=U.Kd.Black();function T(e,d,v){if(d<me.r)return 0;const P=me.r,p=e*v/(1-me.r)+d-2*me.r,L=p*p-4*P*(me.r-d);return q.Clamp((-p+Math.sqrt(L))/(2*P),0,1)}function S(e){const d=e.diffuseColor.toLinearSpace(e.Ae().getEngine().useExactSrgbConversions).scale(.5),v=e.alpha,p=function(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new P.Vector2(0,1),v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new P.Vector2(0,.1),p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new P.Vector2(0,.1),L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new P.Vector2(1300,.1);return function(e,d,v,P,p){return(1-e)*(1-e)*(1-e)*d+3*(1-e)*(1-e)*e*v+3*(1-e)*e*e*P+e*e*e*p}(Math.pow(e/L.x,.333333),d.y,v.y,p.y,L.y)}(q.Clamp(e.specularPower,0,r));return{baseColorFactor:[d.r,d.g,d.b,v],metallicFactor:0,roughnessFactor:p}}function o(e,d){d.needAlphaBlending()?e.alphaMode="BLEND":d.needAlphaTesting()&&(e.alphaMode="MASK",e.alphaCutoff=d.alphaCutOff)}function K(e,d,v){const P=new Uint8Array(e*d*4);for(let p=0;p<P.length;p+=4)P[p]=P[p+1]=P[p+2]=P[p+3]=255;return n.b.CreateRGBATexture(P,e,d,v)}function Q(e){if(e instanceof Uint8Array){const d=e.length,v=new Float32Array(e.length);for(let P=0;P<d;++P)v[P]=e[P]/255;return v}if(e instanceof Float32Array)return e;throw new Error("Unsupported pixel format!")}class N{constructor(e){this._exporter=e,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(e){return e?this._textureMap.get(e)??null:null}async exportStandardMaterialAsync(e,d,v){const P=S(e),L={name:e.name};if(null==e.Jd||e.Jd||(e.twoSidedLighting||p.Tools.Warn(e.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),L.doubleSided=!0),v){const v=[],p=e.diffuseTexture;p&&v.push(this.exportTextureAsync(p,d).then((e=>{e&&(P.baseColorTexture=e)})));const B=e.bumpTexture;B&&v.push(this.exportTextureAsync(B,d).then((e=>{e&&(L.normalTexture=e,1!==B.level&&(L.normalTexture.scale=B.level))})));const X=e.emissiveTexture;X&&(L.emissiveFactor=[1,1,1],v.push(this.exportTextureAsync(X,d).then((e=>{e&&(L.emissiveTexture=e)}))));const z=e.ambientTexture;z&&v.push(this.exportTextureAsync(z,d).then((e=>{if(e){const d={index:e.index};L.occlusionTexture=d}}))),v.length>0&&(this._exporter._materialNeedsUVsSet.add(e),await Promise.all(v))}(e.alpha<1||e.opacityTexture)&&(e.alphaMode===A.b.ALPHA_COMBINE?L.alphaMode="BLEND":p.Tools.Warn(e.name+": glTF 2.0 does not support alpha mode: "+e.alphaMode.toString())),e.emissiveColor&&!e.emissiveColor.equalsWithEpsilon(f,i)&&(L.emissiveFactor=e.emissiveColor.Yd()),L.pbrMetallicRoughness=P,o(L,e),await this._finishMaterialAsync(L,e,d);const B=this._exporter._materials;return B.push(L),B.length-1}async _finishMaterialAsync(e,d,v){const P=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",e,d),p=[];for(const L of P)p.push(this.exportTextureAsync(L,v));await Promise.all(p),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",e,d)}async _getImageDataAsync(e,d,P,p){const L=A.b.TEXTURETYPE_UNSIGNED_BYTE,B=this._exporter._babylonScene,X=B.getEngine(),z=X.createRawTexture(e,d,P,A.b.TEXTUREFORMAT_RGBA,!1,!0,l.e.NEAREST_SAMPLINGMODE,null,L);X.isWebGPU?await v.e(51).then(v.bind(v,14921)):await v.e(52).then(v.bind(v,14925)),await h.h.ApplyPostProcess("pass",z,B,L,A.b.TEXTURE_NEAREST_SAMPLINGMODE,A.b.TEXTUREFORMAT_RGBA);const W=await X._readTexturePixels(z,d,P);return await x.DumpTools.DumpDataAsync(d,P,W,p,void 0,!0,!0)}_resizeTexturesToSameDimensions(e,d,v){const P=e?e.getSize():{width:0,height:0},p=d?d.getSize():{width:0,height:0};let L,B;return P.width<p.width?(L=e&&e instanceof l.e?h.h.CreateResizedCopy(e,p.width,p.height,!0):K(p.width,p.height,v),B=d):P.width>p.width?(B=d&&d instanceof l.e?h.h.CreateResizedCopy(d,P.width,P.height,!0):K(P.width,P.height,v),L=e):(L=e,B=d),{texture1:L,texture2:B}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(e,d,v,P){const p=new Array;if(!e&&!d)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const L=e?e.Ae():d?d.Ae():null;if(L){var B;const X=this._resizeTexturesToSameDimensions(e,d,L),z=null===(B=X.texture1)||void 0===B?void 0:B.getSize();let W,V;const k=z.width,g=z.height,F=await X.texture1.readPixels(),w=await X.texture2.readPixels();if(!F)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(W=Q(F),!w)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");V=Q(w);const G=V.byteLength,D=new Uint8Array(G),C=new Uint8Array(G),q=4,h=f;let l=0,n=0;for(let e=0;e<g;++e)for(let d=0;d<k;++d){const P=(k*e+d)*q,p={diffuseColor:new U.Kd(W[P],W[P+1],W[P+2]).toLinearSpace(L.getEngine().useExactSrgbConversions).multiply(v.diffuseColor),specularColor:new U.Kd(V[P],V[P+1],V[P+2]).toLinearSpace(L.getEngine().useExactSrgbConversions).multiply(v.specularColor),glossiness:V[P+3]*v.glossiness},B=this._convertSpecularGlossinessToMetallicRoughness(p);h.r=Math.max(h.r,B.baseColor.r),h.g=Math.max(h.g,B.baseColor.g),h.b=Math.max(h.b,B.baseColor.b),l=Math.max(l,B.metallic),n=Math.max(n,B.roughness),C[P]=255*B.baseColor.r,C[P+1]=255*B.baseColor.g,C[P+2]=255*B.baseColor.b,C[P+3]=X.texture1.Hd?255*W[P+3]:255,D[P]=0,D[P+1]=255*B.roughness,D[P+2]=255*B.metallic,D[P+3]=255}const A={baseColor:h,metallic:l,roughness:n};let x=!1,me=!1;for(let e=0;e<g;++e)for(let d=0;d<k;++d){const v=(k*e+d)*q;C[v]/=A.baseColor.r>i?A.baseColor.r:1,C[v+1]/=A.baseColor.g>i?A.baseColor.g:1,C[v+2]/=A.baseColor.b>i?A.baseColor.b:1;const P=U.Kd.FromInts(C[v],C[v+1],C[v+2]).toGammaSpace(L.getEngine().useExactSrgbConversions);C[v]=255*P.r,C[v+1]=255*P.g,C[v+2]=255*P.b,P.equalsWithEpsilon(Z,i)||(me=!0),D[v+1]/=A.roughness>i?A.roughness:1,D[v+2]/=A.metallic>i?A.metallic:1;U.Kd.FromInts(255,D[v+1],D[v+2]).equalsWithEpsilon(Z,i)||(x=!0)}return x&&p.push(this._getImageDataAsync(D,k,g,P).then((e=>{A.metallicRoughnessTextureData=e}))),me&&p.push(this._getImageDataAsync(C,k,g,P).then((e=>{A.baseColorTextureData=e}))),await Promise.all(p).then((()=>A))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(e){const d=this._getPerceivedBrightness(e.diffuseColor),v=this._getPerceivedBrightness(e.specularColor),P=1-this._getMaxComponent(e.specularColor),p=T(d,v,P),L=e.diffuseColor.scale(P/(1-me.r)/Math.max(1-p)),B=e.specularColor.Zd(me.scale(1-p)).scale(1/Math.max(p));let X=U.Kd.Lerp(L,B,p*p);X=X.clampToRef(0,1,X);return{baseColor:X,metallic:p,roughness:1-e.glossiness}}_getPerceivedBrightness(e){return e?Math.sqrt(.299*e.r*e.r+.587*e.g*e.g+.114*e.b*e.b):0}_getMaxComponent(e){return e?Math.max(e.r,Math.max(e.g,e.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(e,d,v,P){const p=[],L={baseColor:e._albedoColor,metallic:e._metallic,roughness:e._roughness};if(P){e._albedoTexture&&p.push(this.exportTextureAsync(e._albedoTexture,d).then((e=>{e&&(v.baseColorTexture=e)})));const P=e._metallicTexture;P&&p.push(this.exportTextureAsync(P,d).then((e=>{e&&(v.metallicRoughnessTexture=e)})))}return p.length>0&&(this._exporter._materialNeedsUVsSet.add(e),await Promise.all(p)),L}_getTextureSampler(e){const d={};if(!e||!(e instanceof l.e))return d;const v=this._getGLTFTextureWrapMode(e.wrapU);10497!==v&&(d.wrapS=v);const P=this._getGLTFTextureWrapMode(e.wrapV);switch(10497!==P&&(d.wrapT=P),e.samplingMode){case l.e.LINEAR_LINEAR:d.magFilter=9729,d.minFilter=9729;break;case l.e.LINEAR_NEAREST:d.magFilter=9729,d.minFilter=9728;break;case l.e.NEAREST_LINEAR:d.magFilter=9728,d.minFilter=9729;break;case l.e.NEAREST_LINEAR_MIPLINEAR:d.magFilter=9728,d.minFilter=9987;break;case l.e.NEAREST_NEAREST:d.magFilter=9728,d.minFilter=9728;break;case l.e.NEAREST_LINEAR_MIPNEAREST:d.magFilter=9728,d.minFilter=9985;break;case l.e.LINEAR_NEAREST_MIPNEAREST:d.magFilter=9729,d.minFilter=9984;break;case l.e.LINEAR_NEAREST_MIPLINEAR:d.magFilter=9729,d.minFilter=9986;break;case l.e.NEAREST_NEAREST_MIPLINEAR:d.magFilter=9728,d.minFilter=9986;break;case l.e.LINEAR_LINEAR_MIPLINEAR:d.magFilter=9729,d.minFilter=9987;break;case l.e.LINEAR_LINEAR_MIPNEAREST:d.magFilter=9729,d.minFilter=9985;break;case l.e.NEAREST_NEAREST_MIPNEAREST:d.magFilter=9728,d.minFilter=9984}return d}_getGLTFTextureWrapMode(e){switch(e){case l.e.WRAP_ADDRESSMODE:return 10497;case l.e.CLAMP_ADDRESSMODE:return 33071;case l.e.MIRROR_ADDRESSMODE:return 33648;default:return p.Tools.Error(`Unsupported Texture Wrap Mode ${e}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(e,d,v,P){const p={diffuseColor:e._albedoColor,specularColor:e._reflectivityColor,glossiness:e._microSurface},L=e._albedoTexture,B=e._reflectivityTexture,X=e._useMicroSurfaceFromReflectivityMapAlpha;if(B&&!X)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((L||B)&&P){this._exporter._materialNeedsUVsSet.add(e);const P=this._exportTextureSampler(L||B),X=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(L,B,p,d),z=this._exporter._textures;if(X.baseColorTextureData){const e=this._exportImage(`baseColor${z.length}`,d,X.baseColorTextureData);v.baseColorTexture=this._exportTextureInfo(e,P,null===L||void 0===L?void 0:L.coordinatesIndex)}if(X.metallicRoughnessTextureData){const e=this._exportImage(`metallicRoughness${z.length}`,d,X.metallicRoughnessTextureData);v.metallicRoughnessTexture=this._exportTextureInfo(e,P,null===B||void 0===B?void 0:B.coordinatesIndex)}return X}return this._convertSpecularGlossinessToMetallicRoughness(p)}async exportPBRMaterialAsync(e,d,v){const P={},p={name:e.name},L=e.isMetallicWorkflow();if(L){const d=e._albedoColor,v=e.alpha;d&&(P.baseColorFactor=[d.r,d.g,d.b,v])}const B=L?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(e,d,P,v):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(e,d,P,v);await this._setMetallicRoughnessPbrMaterialAsync(B,e,p,P,d,v),await this._finishMaterialAsync(p,e,d);const X=this._exporter._materials;return X.push(p),X.length-1}async _setMetallicRoughnessPbrMaterialAsync(e,d,v,P,L,B){if(o(v,d),e.baseColor.equalsWithEpsilon(Z,i)&&q.WithinEpsilon(d.alpha,1,i)||(P.baseColorFactor=[e.baseColor.r,e.baseColor.g,e.baseColor.b,d.alpha]),null!=e.metallic&&1!==e.metallic&&(P.metallicFactor=e.metallic),null!=e.roughness&&1!==e.roughness&&(P.roughnessFactor=e.roughness),null==d.Jd||d.Jd||(d._twoSidedLighting||p.Tools.Warn(d.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),v.doubleSided=!0),B){const e=[],P=d._bumpTexture;P&&e.push(this.exportTextureAsync(P,L).then((e=>{e&&(v.normalTexture=e,1!==P.level&&(v.normalTexture.scale=P.level))})));const p=d._ambientTexture;p&&e.push(this.exportTextureAsync(p,L).then((e=>{if(e){const P={index:e.index,texCoord:e.texCoord,extensions:e.extensions};v.occlusionTexture=P;const p=d._ambientTextureStrength;p&&(P.strength=p)}})));const B=d._emissiveTexture;B&&e.push(this.exportTextureAsync(B,L).then((e=>{e&&(v.emissiveTexture=e)}))),e.length>0&&(this._exporter._materialNeedsUVsSet.add(d),await Promise.all(e))}const X=d._emissiveColor;X.equalsWithEpsilon(f,i)||(v.emissiveFactor=X.Yd()),v.pbrMetallicRoughness=P}_getPixelsFromTextureAsync(e){return function(e){switch(e){case A.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case A.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case A.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case A.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case A.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case A.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case A.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case A.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case A.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case A.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case A.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case A.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case A.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case A.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case A.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case A.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case A.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case A.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case A.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case A.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case A.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(e.textureFormat)?(0,h.g)(e,e._texture.width,e._texture.height):(e.textureType,A.b.TEXTURETYPE_UNSIGNED_BYTE,e.readPixels())}async exportTextureAsync(e,d){const v=this._exporter._extensionsPreExportTextureAsync("exporter",e,d);return v?await v.then((async v=>v?await this._exportTextureInfoAsync(v,d):await this._exportTextureInfoAsync(e,d))):await this._exportTextureInfoAsync(e,d)}async _exportTextureInfoAsync(e,d){let v=this._textureMap.get(e);if(!v){const P=await this._getPixelsFromTextureAsync(e);if(!P)return null;const L=this._exportTextureSampler(e),B=e.mimeType;if(B)switch(B){case"image/jpeg":case"image/png":case"image/webp":d=B;break;default:p.Tools.Warn(`Unsupported media type: ${B}. Exporting texture as PNG.`)}const X=this._internalTextureToImage,z=e.getInternalTexture().uniqueId;X[z]||(X[z]={});let W=X[z][d];if(void 0===W){const v=e.getSize();W=(async()=>{const p=await this._getImageDataAsync(P,v.width,v.height,d);return this._exportImage(e.name,d,p)})(),X[z][d]=W}v=this._exportTextureInfo(await W,L,e.coordinatesIndex),this._textureMap.set(e,v),this._exporter._extensionsPostExportTextures("exporter",v,e)}return v}_exportImage(e,d,v){const P=this._exporter._images;let L;if(this._exporter._shouldUseGlb){L={name:e,mimeType:d,bufferView:void 0};const P=this._exporter._bufferManager.createBufferView(new Uint8Array(v));this._exporter._bufferManager.setBufferView(L,P)}else{const B=e.replace(/\.\/|\/|\.\\|\\/g,"_"),X=function(e){switch(e){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(d);let z=B+X;P.some((e=>e.uri===z))&&(z=`${B}_${p.Tools.RandomId()}${X}`),L={name:e,uri:z},this._exporter._imageData[z]={data:v,mimeType:d}}return P.push(L),P.length-1}_exportTextureInfo(e,d,v){const P=this._exporter._textures;let p=P.findIndex((v=>v.sampler==d&&v.source===e));-1===p&&(p=P.length,P.push({source:e,sampler:d}));const L={index:p};return v&&(L.texCoord=v),L}_exportTextureSampler(e){const d=this._getTextureSampler(e),v=this._exporter._samplers,P=v.findIndex((e=>e.minFilter===d.minFilter&&e.magFilter===d.magFilter&&e.wrapS===d.wrapS&&e.wrapT===d.wrapT));return-1!==P?P:(v.push(d),v.length-1)}}var u=v(12499),O=v(12253),R=v(12905),Y=v(12429);const H=P.mv.Zero(),a=P.Quaternion.Identity(),t=P.mv.One(),I=new P.mv(-1,1,1);function c(e,d){const{byteOffset:v,byteStride:P,type:p,normalized:L}=e,B=e.getSize(),X=d.reduce(((e,d)=>d.getTotalVertices()>e?d.getTotalVertices():e),-Number.MAX_VALUE);return{byteOffset:v,byteStride:P,componentCount:B,type:p,count:X*B,normalized:L,totalVertices:X,kind:e.getKind()}}function b(e){switch(e){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function M(e){switch(e){case V.i.PositionKind:case V.i.NormalKind:case V.i.TangentKind:case V.i.ColorKind:case V.i.MatricesIndicesKind:case V.i.MatricesIndicesExtraKind:case V.i.MatricesWeightsKind:case V.i.MatricesWeightsExtraKind:case V.i.UVKind:case V.i.UV2Kind:case V.i.UV3Kind:case V.i.UV4Kind:case V.i.UV5Kind:case V.i.UV6Kind:return!0}return!1}function s(e){switch(e){case L.b.TriangleFillMode:return 4;case L.b.TriangleStripDrawMode:return 5;case L.b.TriangleFanDrawMode:return 6;case L.b.PointListDrawMode:case L.b.PointFillMode:return 0;case L.b.LineLoopDrawMode:return 2;case L.b.LineListDrawMode:return 1;case L.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${e}`)}function y(e){const d=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z);d>0&&(e.x/=d,e.y/=d,e.z/=d)}function j(e){return e.x*=-1,e}function J(e){if(e.x*e.x+e.y*e.y>.5){const d=Math.abs(e.x),v=Math.abs(e.y);if(d>v){const v=Math.sign(e.x);e.x=d,e.y*=-v,e.z*=-v,e.w*=v}else{const d=Math.sign(e.y);e.x*=-d,e.y=v,e.z*=d,e.w*=-d}}else{const d=Math.abs(e.z),v=Math.abs(e.w);if(d>v){const v=Math.sign(e.z);e.x*=-v,e.y*=v,e.z=d,e.w*=-v}else{const d=Math.sign(e.w);e.x*=d,e.y*=-d,e.z*=-d,e.w=v}}return e}function E(e){e.Ed(-e.z,e.w,e.x,-e.y)}function ee(e,d){const v=P.mv.FromArrayToRef(d.translation||[0,0,0],0,P.TmpVectors.mv[0]),p=P.Quaternion.FromArrayToRef(d.rotation||[0,0,0,1],0,P.TmpVectors.Quaternion[0]),L=P.Matrix.ComposeToRef(t,p,v,P.TmpVectors.Matrix[0]),B=P.mv.FromArrayToRef(e.translation||[0,0,0],0,P.TmpVectors.mv[2]),X=P.Quaternion.FromArrayToRef(e.rotation||[0,0,0,1],0,P.TmpVectors.Quaternion[1]),z=P.Matrix.ComposeToRef(t,X,B,P.TmpVectors.Matrix[1]);L.multiplyToRef(z,z),z.decompose(void 0,p,v),v.equalsWithEpsilon(H,Y.e)?delete d.translation:d.translation=v.Yd(),p.equalsWithEpsilon(a,Y.e)?delete d.rotation:d.rotation=p.Yd(),d.scale&&delete d.scale}function de(e,d){if(!(d instanceof k.c))return!1;if(!(1===d.getChildren().length&&0===e.getChildren().length&&e.parent===d))return!1;const v=e.Ae(),P=e instanceof R.c&&!v.useRightHandedSystem?I:t;return!!d.tv.equalsWithEpsilon(P,Y.e)||(O.c.Warn(`Cannot collapse node ${e.name} into parent node ${d.name} with modified scaling.`),!1)}function ve(e){if(e instanceof Array){const d=new Float32Array(e);return new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}return ArrayBuffer.isView(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):new Uint8Array(e)}function Pe(e,d){for(const[v,P]of Object.entries(e)){const p=d[v];(Array.isArray(P)&&Array.isArray(p)&&pe(P,p)||P===p)&&delete e[v]}return e}function pe(e,d){return e.length===d.length&&e.every(((e,v)=>e===d[v]))}const Le=P.Matrix.Compose(new P.mv(-1,1,1),P.Quaternion.Identity(),P.mv.Zero());function Be(e,d){if(!(e instanceof k.c))return!1;if(d){if(!e.getWorldMatrix().equalsWithEpsilon(P.Matrix.IdentityReadOnly,Y.e))return!1}else{if(!e.getWorldMatrix().multiplyToRef(Le,P.TmpVectors.Matrix[0]).equalsWithEpsilon(P.Matrix.IdentityReadOnly,Y.e))return!1}return!(e instanceof g.d&&e.sd)}const Xe=new Map([[Int8Array,(e,d,v)=>e.setInt8(d,v)],[Uint8Array,(e,d,v)=>e.setUint8(d,v)],[Uint8ClampedArray,(e,d,v)=>e.setUint8(d,v)],[Int16Array,(e,d,v)=>e.setInt16(d,v,!0)],[Uint16Array,(e,d,v)=>e.setUint16(d,v,!0)],[Int32Array,(e,d,v)=>e.setInt32(d,v,!0)],[Uint32Array,(e,d,v)=>e.setUint32(d,v,!0)],[Float32Array,(e,d,v)=>e.setFloat32(d,v,!0)],[Float64Array,(e,d,v)=>e.setFloat64(d,v,!0)]]);class ze{writeTypedArray(e){this._checkGrowBuffer(e.byteLength);const d=Xe.get(e.constructor);for(let v=0;v<e.length;v++)d(this._dataView,this._byteOffset,e[v]),this._byteOffset+=e.BYTES_PER_ELEMENT}constructor(e){this._data=new Uint8Array(e),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(e){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,e),this._byteOffset++}writeInt8(e){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,e),this._byteOffset++}writeInt16(e){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,e,!0),this._byteOffset+=2}writeUInt16(e){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,e,!0),this._byteOffset+=2}writeInt32(e){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,e,!0),this._byteOffset+=4}writeUInt32(e){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,e,!0),this._byteOffset+=4}writeFloat32(e){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,e,!0),this._byteOffset+=4}writeFloat64(e){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,e,!0),this._byteOffset+=8}_checkGrowBuffer(e){const d=this.byteOffset+e;if(d>this._data.byteLength){const e=new Uint8Array(2*d);e.set(this._data),this._data=e,this._dataView=new DataView(this._data.buffer)}}}function We(e){return e%4===0?4:e%2===0?2:1}class Ve{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(e){let d=0;this._bufferViewToData.forEach((e=>{d+=e.byteLength}));const v=new ze(d),P=Array.from(this._bufferViewToData.keys()).sort(((e,d)=>We(d.byteLength)-We(e.byteLength)));for(const p of P){p.byteOffset=v.byteOffset,e.push(p);const d=e.length-1,P=this.getPropertiesWithBufferView(p);for(const e of P)e.bufferView=d;v.writeTypedArray(this._bufferViewToData.get(p)),this._bufferViewToData.delete(p)}return v.getOutputData()}createBufferView(e,d){const v={buffer:0,byteOffset:void 0,byteLength:e.byteLength,byteStride:d};return this._bufferViewToData.set(v,e),v}createAccessor(e,d,v,P,p,L,B){this._verifyBufferView(e);const X={bufferView:void 0,componentType:v,count:P,type:d,min:null===L||void 0===L?void 0:L.min,max:null===L||void 0===L?void 0:L.max,normalized:B,byteOffset:p};return this.setBufferView(X,e),this._accessorToBufferView.set(X,e),X}setBufferView(e,d){this._verifyBufferView(d);this.getPropertiesWithBufferView(d).push(e)}removeBufferView(e){const d=this.getPropertiesWithBufferView(e);for(const v of d)void 0!==v.bufferView&&delete v.bufferView;this._bufferViewToData.delete(e),this._bufferViewToProperties.delete(e),this._accessorToBufferView.forEach(((d,v)=>{d===e&&(void 0!==v.byteOffset&&delete v.byteOffset,this._accessorToBufferView.delete(v))}))}getBufferView(e){const d=this._accessorToBufferView.get(e);return this._verifyBufferView(d),d}getPropertiesWithBufferView(e){return this._verifyBufferView(e),this._bufferViewToProperties.set(e,this._bufferViewToProperties.get(e)??[]),this._bufferViewToProperties.get(e)}getData(e){return this._verifyBufferView(e),this._bufferViewToData.get(e)}_verifyBufferView(e){if(void 0===e||!this._bufferViewToData.has(e))throw new Error(`BufferView ${e} not found in BufferManager.`)}}var ke,ge=v(12872),Fe=v(12888),we=v(12911),Ge=v(12782),Ue=v(12948),De=v(12955),Ce=v(12864),qe=v(12962);!function(e){e[e.INTANGENT=0]="INTANGENT",e[e.OUTTANGENT=1]="OUTTANGENT"}(ke||(ke={}));class he{static _IsTransformable(e){return e&&(e instanceof k.c||e instanceof ge.c||e instanceof qe.e)}static _CreateNodeAnimation(e,d,v,P,L){if(this._IsTransformable(e)){const B=[],X=[],z=d.getKeys(),W=he._CalculateMinMaxKeyFrames(z),V=he._DeduceInterpolation(z,v,P),k=V.interpolationType,g=V.shouldBakeAnimation;if(g?he._CreateBakedAnimation(e,d,v,W.min,W.max,d.framePerSecond,L,B,X,W,P):"LINEAR"===k||"STEP"===k?he._CreateLinearOrStepAnimation(e,d,v,B,X,P):"CUBICSPLINE"===k?he._CreateCubicSplineAnimation(e,d,v,B,X,P):he._CreateBakedAnimation(e,d,v,W.min,W.max,d.framePerSecond,L,B,X,W,P),B.length&&X.length){return{inputs:B,outputs:X,samplerInterpolation:k,inputsMin:g?W.min:p.Tools.FloatRound(W.min/d.framePerSecond),inputsMax:g?W.max:p.Tools.FloatRound(W.max/d.framePerSecond)}}}return null}static _DeduceAnimationInfo(e){let d=null,v="VEC3",P=!1;const L=e.targetProperty.split(".");switch(L[0]){case"tv":d="scale";break;case"position":d="translation";break;case"rotation":v="VEC4",d="rotation";break;case"rotationQuaternion":v="VEC4",P=!0,d="rotation";break;case"influence":v="SCALAR",d="weights";break;default:p.Tools.Error(`Unsupported animatable property ${L[0]}`)}return d?{animationChannelTargetPath:d,dataAccessorType:v,useQuaternion:P}:(p.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(e,d,v,P,p,L,B,X,z,W,V){let k;if(he._IsTransformable(e)&&e.animations)for(const g of e.animations){if(V&&!V(g))continue;const p=he._DeduceAnimationInfo(g);p&&(k={name:g.name,samplers:[],channels:[]},he._AddAnimation(`${g.name}`,g.hasRunningRuntimeAnimations?d:k,e,g,p.dataAccessorType,p.animationChannelTargetPath,P,L,B,X,p.useQuaternion,z,W),k.samplers.length&&k.channels.length&&v.push(k))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(e,d,v,P,p,L,B,X,z,W,V){let k;if(e instanceof Ce.b){const p=e.morphTargetManager;if(p)for(let g=0;g<p.numTargets;++g){const F=p.getTarget(g);for(const w of F.animations){if(V&&!V(w))continue;const F=new Ue.e(`${w.name}`,"influence",w.framePerSecond,w.dataType,w.loopMode,w.enableBlending),G=[],U=w.getKeys();for(let e=0;e<U.length;++e){const d=U[e];for(let e=0;e<p.numTargets;++e)e==g?G.push(d):G.push({frame:d.frame,value:0})}F.setKeys(G);const D=he._DeduceAnimationInfo(F);D&&(k={name:F.name,samplers:[],channels:[]},he._AddAnimation(w.name,w.hasRunningRuntimeAnimations?d:k,e,F,D.dataAccessorType,D.animationChannelTargetPath,P,L,B,X,D.useQuaternion,z,W,p.numTargets),k.samplers.length&&k.channels.length&&v.push(k))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(e,d,v,P,p,L,B,X,z){let W;if(e.animationGroups){const k=e.animationGroups;for(const g of k){const k=new Map,F=new Map,w=new Set,G=g.to-g.from;W={name:g.name,channels:[],samplers:[]};for(let d=0;d<g.targetedAnimations.length;++d){const G=g.targetedAnimations[d],U=G.target,D=G.animation;if(z&&!z(D))continue;const C=X.has(U);if(this._IsTransformable(U)||1===U.length&&this._IsTransformable(U[0])){const e=he._DeduceAnimationInfo(G.animation);if(e){const d=this._IsTransformable(U)?U:this._IsTransformable(U[0])?U[0]:null;d&&he._AddAnimation(`${D.name}`,W,d,D,e.dataAccessorType,e.animationChannelTargetPath,v,P,p,L,e.useQuaternion,B,C)}}else if(U instanceof De.e||1===U.length&&U[0]instanceof De.e){if(he._DeduceAnimationInfo(G.animation)){const d=U instanceof De.e?U:U[0];if(d){const v=e.morphTargetManagers.find((e=>{for(let v=0;v<e.numTargets;++v)if(e.getTarget(v)===d)return!0;return!1}));if(v){const P=e.meshes.find((e=>e.morphTargetManager===v));var V;if(P)k.has(P)||k.set(P,new Map),null===(V=k.get(P))||void 0===V||V.set(d,D),w.add(P),F.set(P,D)}}}}}w.forEach((e=>{const d=e.morphTargetManager;let X=null;const z=[],V=F.get(e).getKeys(),w=V.length;for(let v=0;v<w;++v)for(let P=0;P<d.numTargets;++P){const p=d.getTarget(P),L=k.get(e);if(L){const d=L.get(p);d?(X||(X=new Ue.e(`${g.name}_${e.name}_MorphWeightAnimation`,"influence",d.framePerSecond,Ue.e.ANIMATIONTYPE_FLOAT,d.loopMode,d.enableBlending)),z.push(d.getKeys()[v])):z.push({frame:g.from+G/w*v,value:p.influence,inTangent:V[0].inTangent?0:void 0,outTangent:V[0].outTangent?0:void 0})}}X.setKeys(z);const U=he._DeduceAnimationInfo(X);U&&he._AddAnimation(`${g.name}_${e.name}_MorphWeightAnimation`,W,e,X,U.dataAccessorType,U.animationChannelTargetPath,v,P,p,L,U.useQuaternion,B,!1,null===d||void 0===d?void 0:d.numTargets)})),W.channels.length&&W.samplers.length&&d.push(W)}}}static _AddAnimation(e,d,v,p,L,B,X,z,W,V,k,g,F,w){const G=he._CreateNodeAnimation(v,p,B,k,g);let U,D,C,q,h,l;if(G){if(w){let e=0,d=0;const v=[];for(;G.inputs.length>0;)d=G.inputs.shift(),e%w==0&&v.push(d),e++;G.inputs=v}const e=X.get(v),p=new Float32Array(G.inputs);U=z.createBufferView(p),D=z.createAccessor(U,"SCALAR",5126,G.inputs.length,void 0,{min:[G.inputsMin],max:[G.inputsMax]}),V.push(D),C=V.length-1;const W=new P.Quaternion,k=new P.mv,g=new P.mv,n=v instanceof ge.c,A=b(L),x=new Float32Array(G.outputs.length*A);G.outputs.forEach((function(e,d){let v=e;switch(B){case"translation":F&&(P.mv.FromArrayToRef(e,0,g),j(g),g.toArray(v));break;case"rotation":4===e.length?P.Quaternion.FromArrayToRef(e,0,W):(v=new Array(4),P.mv.FromArrayToRef(e,0,k),P.Quaternion.FromEulerVectorToRef(k,W)),F&&(J(W),n&&E(W)),W.toArray(v)}x.set(v,d*A)})),U=z.createBufferView(x),D=z.createAccessor(U,L,5126,G.outputs.length),V.push(D),q=V.length-1,h={interpolation:G.samplerInterpolation,input:C,output:q},d.samplers.push(h),l={sampler:d.samplers.length-1,target:{node:e,path:B}},d.channels.push(l)}}static _CreateBakedAnimation(e,d,v,L,B,X,z,W,V,k,g){let F;const w=P.Quaternion.Identity();let G,U=null,D=null,C=null,q=null,h=null,l=null;k.min=p.Tools.FloatRound(L/X);const n=d.getKeys();for(let P=0,A=n.length;P<A;++P){if(l=null,C=n[P],P+1<A)if(q=n[P+1],C.value.equals&&C.value.equals(q.value)||C.value===q.value){if(0!==P)continue;l=C.frame}else l=q.frame;else{if(h=n[P-1],C.value.equals&&C.value.equals(h.value)||C.value===h.value)continue;l=B}if(l)for(let P=C.frame;P<=l;P+=z){if(G=p.Tools.FloatRound(P/X),G===U)continue;U=G,D=G;const L={key:0,repeatCount:0,loopMode:d.loopMode};F=d._interpolate(P,L),he._SetInterpolatedValue(e,F,G,d,v,w,W,V,g)}}D&&(k.max=D)}static _ConvertFactorToVector3OrQuaternion(e,d,v,L,B){const X=he._GetBasePositionRotationOrScale(d,L,B),z=v.targetProperty.split("."),W=z?z[1]:"",V=B?P.Quaternion.Nd(X).normalize():P.mv.Nd(X);switch(W){case"x":case"y":case"z":V[W]=e;break;case"w":V.w=e;break;default:p.Tools.Error(`glTFAnimation: Unsupported component name "${W}"!`)}return V}static _SetInterpolatedValue(e,d,v,p,L,B,X,z,W){let V;X.push(v),"weights"!==L?(p.dataType===Ue.e.ANIMATIONTYPE_FLOAT&&(d=this._ConvertFactorToVector3OrQuaternion(d,e,p,L,W)),"rotation"===L?(W?B=d:(V=d,P.Quaternion.RotationYawPitchRollToRef(V.y,V.x,V.z,B)),z.push(B.Yd())):(V=d,z.push(V.Yd()))):z.push([d])}static _CreateLinearOrStepAnimation(e,d,v,P,p,L){for(const B of d.getKeys())P.push(B.frame/d.framePerSecond),he._AddKeyframeValue(B,d,p,v,e,L)}static _CreateCubicSplineAnimation(e,d,v,P,p,L){d.getKeys().forEach((function(B){P.push(B.frame/d.framePerSecond),he._AddSplineTangent(ke.INTANGENT,p,v,"CUBICSPLINE",B,L),he._AddKeyframeValue(B,d,p,v,e,L),he._AddSplineTangent(ke.OUTTANGENT,p,v,"CUBICSPLINE",B,L)}))}static _GetBasePositionRotationOrScale(e,d,v){let p;if("rotation"===d)if(v){p=(e.rotationQuaternion??P.Quaternion.Identity()).Yd()}else{p=(e.rotation??P.mv.Zero()).Yd()}else if("translation"===d){p=(e.position??P.mv.Zero()).Yd()}else{p=(e.tv??P.mv.One()).Yd()}return p}static _AddKeyframeValue(e,d,v,L,B,X){let z;const W=d.dataType;if(W===Ue.e.ANIMATIONTYPE_VECTOR3){let d=e.value.Yd();if("rotation"===L){const e=P.mv.Nd(d);d=P.Quaternion.RotationYawPitchRoll(e.y,e.x,e.z).Yd()}v.push(d)}else if(W===Ue.e.ANIMATIONTYPE_FLOAT){if("weights"===L)v.push([e.value]);else if(z=this._ConvertFactorToVector3OrQuaternion(e.value,B,d,L,X),z){if("rotation"===L){const e=X?z:P.Quaternion.RotationYawPitchRoll(z.y,z.x,z.z).normalize();v.push(e.Yd())}v.push(z.Yd())}}else W===Ue.e.ANIMATIONTYPE_QUATERNION?v.push(e.value.normalize().Yd()):p.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(e,d,v){let P,p,L=!1;if("rotation"===d&&!v)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let B=0,X=e.length;B<X;++B)if(p=e[B],p.inTangent||p.outTangent)if(P){if("CUBICSPLINE"!==P){P="LINEAR",L=!0;break}}else P="CUBICSPLINE";else if(P){if("CUBICSPLINE"===P||p.interpolation&&1===p.interpolation&&"STEP"!==P){P="LINEAR",L=!0;break}}else P=p.interpolation&&1===p.interpolation?"STEP":"LINEAR";return P||(P="LINEAR"),{interpolationType:P,shouldBakeAnimation:L}}static _AddSplineTangent(e,d,v,p,L,B){let X;const z=e===ke.INTANGENT?L.inTangent:L.outTangent;if("CUBICSPLINE"===p){if("rotation"===v)if(z)if(B)X=z.Yd();else{const e=z;X=P.Quaternion.RotationYawPitchRoll(e.y,e.x,e.z).Yd()}else X=[0,0,0,0];else X="weights"===v?z?[z]:[0]:z?z.Yd():[0,0,0];d.push(X)}}static _CalculateMinMaxKeyFrames(e){let d=1/0,v=-1/0;return e.forEach((function(e){d=Math.min(d,e.frame),v=Math.max(v,e.frame)})),{min:d,max:v}}}function le(e,d,v,L,B,X){const z={attributes:{},influence:e.influence,name:e.name},W=d.sd;if(!W)return p.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),z;const k=X?-1:1,g=P.mv.Zero();let F=0,w=0;if(e.hasPositions){const L=e.getPositions(),X=W.getVerticesData(V.i.PositionKind);if(X){const e=new Float32Array(X.length),d=[1/0,1/0,1/0],p=[-1/0,-1/0,-1/0];w=X.length/3,F=0;for(let v=F;v<w;++v){const B=P.mv.Nd(X,3*v);P.mv.Nd(L,3*v).subtractToRef(B,g),g.x*=k,d[0]=Math.min(d[0],g.x),p[0]=Math.max(p[0],g.x),d[1]=Math.min(d[1],g.y),p[1]=Math.max(p[1],g.y),d[2]=Math.min(d[2],g.z),p[2]=Math.max(p[2],g.z),e[3*v]=g.x,e[3*v+1]=g.y,e[3*v+2]=g.z}const W=v.createBufferView(e,12),V=v.createAccessor(W,"VEC3",5126,L.length/3,0,{min:d,max:p});B.push(V),z.attributes.POSITION=B.length-1}else p.Tools.Warn(`Morph target positions for mesh ${d.name} were not exported. Mesh does not have position vertex data`)}if(e.hasNormals){const L=e.getNormals(),X=W.getVerticesData(V.i.NormalKind);if(X){const e=new Float32Array(X.length);w=X.length/3,F=0;for(let v=F;v<w;++v){const d=P.mv.Nd(X,3*v).normalize();P.mv.Nd(L,3*v).normalize().subtractToRef(d,g),e[3*v]=g.x*k,e[3*v+1]=g.y,e[3*v+2]=g.z}const d=v.createBufferView(e,12),p=v.createAccessor(d,"VEC3",5126,L.length/3,0);B.push(p),z.attributes.NORMAL=B.length-1}else p.Tools.Warn(`Morph target normals for mesh ${d.name} were not exported. Mesh does not have normals vertex data`)}if(e.hasTangents){const L=e.getTangents(),X=W.getVerticesData(V.i.TangentKind);if(X){w=X.length/4;const e=new Float32Array(3*w);F=0;for(let v=F;v<w;++v){const d=P.mv.Nd(X,4*v);y(d);const p=P.mv.Nd(L,3*v);y(p),p.subtractToRef(d,g),e[3*v]=g.x*k,e[3*v+1]=g.y,e[3*v+2]=g.z}const d=v.createBufferView(e,12),p=v.createAccessor(d,"VEC3",5126,w,0);B.push(p),z.attributes.TANGENT=B.length-1}else p.Tools.Warn(`Morph target tangents for mesh ${d.name} were not exported. Mesh does not have tangents vertex data`)}if(e.hasColors){const L=e.getColors(),X=W.getVerticesData(V.i.ColorKind),k=W.getVertexBuffer(V.i.ColorKind);if(X&&k){const e=k.getSize();w=X.length/e;const d=new Float32Array(w*e);F=0;for(let v=F;v<w;++v)if(3===e){const p=P.mv.Nd(X,v*e);P.mv.Nd(L,v*e).subtractToRef(p,g),d[3*v]=g.x,d[3*v+1]=g.y,d[3*v+2]=g.z}else if(4===e){const p=new P.Vector4,B=P.Vector4.Nd(X,v*e);P.Vector4.Nd(L,v*e).subtractToRef(B,p),d[4*v]=p.x,d[4*v+1]=p.y,d[4*v+2]=p.z,d[4*v+3]=p.w}else p.Tools.Warn(`Unsupported number of components for color attribute: ${e}`);const W=v.createBufferView(d,4*e),V=v.createAccessor(W,3===e?"VEC3":"VEC4",5126,w,0);B.push(V),z.attributes.COLOR_0=B.length-1}else p.Tools.Warn(`Morph target colors for mesh ${d.name} were not exported. Mesh does not have colors vertex data`)}return z}var ne=v(12964),Ae=v(12811),xe=v(12795),ie=v(12381);class md{}md.DEFAULT_COLOR=U.Kd.White(),md.DEFAULT_WIDTH_ATTENUATED=1,md.DEFAULT_WIDTH=.1;var re=v(12627),Ze=v(12970);class fe{static ConvertPoints(e,d){if(e.length&&Array.isArray(e)&&"number"===typeof e[0])return[e];if(e.length&&Array.isArray(e[0])&&"number"===typeof e[0][0])return e;if(e.length&&!Array.isArray(e[0])&&e[0]instanceof P.mv){const d=[];for(let v=0;v<e.length;v++){const P=e[v];d.push(P.x,P.y,P.z)}return[d]}if(e.length>0&&Array.isArray(e[0])&&e[0].length>0&&e[0][0]instanceof P.mv){const d=[],v=e;for(const e of v)d.push(e.flatMap((e=>[e.x,e.y,e.z])));return d}if(e instanceof Float32Array){if(null!==d&&void 0!==d&&d.floatArrayStride){const v=[],P=3*d.floatArrayStride;for(let d=0;d<e.length;d+=P){const p=new Array(P);for(let v=0;v<P;v++)p[v]=e[d+v];v.push(p)}return v}return[Array.from(e)]}if(e.length&&e[0]instanceof Float32Array){const d=[];for(const v of e)d.push(Array.from(v));return d}return[]}static OmitZeroLengthPredicate(e,d,v){const P=[];return d.Zd(e).lengthSquared()>0&&P.push([e,d]),v.Zd(d).lengthSquared()>0&&P.push([d,v]),e.Zd(v).lengthSquared()>0&&P.push([v,e]),0===P.length?null:P}static OmitDuplicatesPredicate(e,d,v,P){const p=[];return fe._SearchInPoints(e,d,P)||p.push([e,d]),fe._SearchInPoints(d,v,P)||p.push([d,v]),fe._SearchInPoints(v,e,P)||p.push([v,e]),0===p.length?null:p}static _SearchInPoints(e,d,v){for(const B of v)for(let v=0;v<B.length;v++){var P,p,L;if(null!==(P=B[v])&&void 0!==P&&P.equals(e))if(null!==(p=B[v+1])&&void 0!==p&&p.equals(d)||null!==(L=B[v-1])&&void 0!==L&&L.equals(d))return!0}return!1}static MeshesToLines(e,d){const v=[];for(let p=0;p<e.length;p++){const L=e[p],B=L.getVerticesData(V.i.PositionKind),X=L.yd();if(B&&X)for(let e=0,z=0;e<X.length;e++){const W=3*X[z++],V=3*X[z++],k=3*X[z++],g=new P.mv(B[W],B[W+1],B[W+2]),F=new P.mv(B[V],B[V+1],B[V+2]),w=new P.mv(B[k],B[k+1],B[k+2]);if(d){const P=d(g,F,w,v,e,W,L,p,B,X);if(P)for(const e of P)v.push(e)}else v.push([g,F],[F,w],[w,g])}}return v}static ToVector3Array(e){if(Array.isArray(e[0])){const d=[],v=e;for(const e of v){const v=[];for(let d=0;d<e.length;d+=3)v.push(new P.mv(e[d],e[d+1],e[d+2]));d.push(v)}return d}const d=e,v=[];for(let p=0;p<d.length;p+=3)v.push(new P.mv(d[p],d[p+1],d[p+2]));return v}static ToNumberArray(e){return e.flatMap((e=>[e.x,e.y,e.z]))}static GetPointsCountInfo(e){const d=new Array(e.length);let v=0;for(let P=e.length;P--;)d[P]=e[P].length/3,v+=d[P];return{total:v,counts:d}}static GetLineLength(e){if(0===e.length)return 0;let d;d="number"===typeof e[0]?fe.ToVector3Array(e):e;const v=P.TmpVectors.mv[0];let p=0;for(let P=0;P<d.length-1;P++){const e=d[P];p+=d[P+1].subtractToRef(e,v).length()}return p}static GetLineLengthArray(e){const d=new Float32Array(e.length/3);let v=0;for(let P=0,p=e.length/3-1;P<p;P++){let p=e[3*P+0],L=e[3*P+1],B=e[3*P+2];p-=e[3*P+3],L-=e[3*P+4],B-=e[3*P+5];v+=Math.sqrt(p*p+L*L+B*B),d[P+1]=v}return d}static SegmentizeSegmentByCount(e,d,v){const p=[],L=d.Zd(e),B=P.TmpVectors.mv[0];B.dp(v);const X=P.TmpVectors.mv[1];L.divideToRef(B,X);let z=e.clone();p.push(z);for(let P=0;P<v;P++)z=z.clone(),p.push(z.addInPlace(X));return p}static SegmentizeLineBySegmentLength(e,d){const v=e[0]instanceof P.mv?fe.GetLineSegments(e):"number"===typeof e[0]?fe.GetLineSegments(fe.ToVector3Array(e)):e,p=[];for(const P of v)if(P.length>d){const e=fe.SegmentizeSegmentByCount(P.point1,P.point2,Math.ceil(P.length/d));for(const d of e)p.push(d)}else p.push(P.point1),p.push(P.point2);return p}static SegmentizeLineBySegmentCount(e,d){const v="number"===typeof e[0]?fe.ToVector3Array(e):e,P=fe.GetLineLength(v)/d;return fe.SegmentizeLineBySegmentLength(v,P)}static GetLineSegments(e){const d=[];for(let v=0;v<e.length-1;v++){const P=e[v],p=e[v+1],L=p.Zd(P).length();d.push({point1:P,point2:p,length:L})}return d}static GetMinMaxSegmentLength(e){const d=fe.GetLineSegments(e).sort((e=>e.length));return{min:d[0].length,max:d[d.length-1].length}}static GetPositionOnLineByVisibility(e,d,v){let p=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const L=d*v;let B=0,X=0;const z=e.length;for(let P=0;P<z;P++){if(L<=B+e[P].length){X=P;break}B+=e[P].length}const W=(L-B)/e[X].length;return e[X].point2.subtractToRef(e[X].point1,P.TmpVectors.mv[0]),P.TmpVectors.mv[1]=P.TmpVectors.mv[0].multiplyByFloats(W,W,W),p||P.TmpVectors.mv[1].addInPlace(e[X].point1),P.TmpVectors.mv[1].clone()}static GetCircleLinePoints(e,d){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e,L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/d;const B=[];for(let X=0;X<=d;X++)B.push(new P.mv(Math.cos(X*L)*e,Math.sin(X*L)*p,v));return B}static GetBezierLinePoints(e,d,v,P){return re.e.CreateQuadraticBezier(e,d,v,P).getPoints().flatMap((e=>[e.x,e.y,e.z]))}static GetArrowCap(e,d,v,P,p){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,B=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[e.clone(),e.add(d.multiplyByFloats(v,v,v))],widths:[P,p,L,B]}}static GetPointsFromText(e,d,v,P){let p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const B=[],X=(0,Ze.b)(e,d,v,P);for(const z of X){for(const e of z.paths){const d=[],v=e.getPoints();for(const e of v)d.push(e.x,e.y,p);B.push(d)}if(L)for(const e of z.holes){const d=[],v=e.getPoints();for(const e of v)d.push(e.x,e.y,p);B.push(d)}}return B}static Color3toRGBAUint8(e){const d=new Uint8Array(4*e.length);for(let v=0,P=0;v<e.length;v++)d[P++]=255*e[v].r,d[P++]=255*e[v].g,d[P++]=255*e[v].b,d[P++]=255;return d}static CreateColorsTexture(e,d,v,P){const p=P.getEngine().getCaps().maxTextureSize??1,L=d.length>p?p:d.length,B=Math.ceil(d.length/p);B>1&&(d=[...d,...Array(L*B-d.length).fill(d[0])]);const X=fe.Color3toRGBAUint8(d),z=new n.b(X,L,B,w.b.TEXTUREFORMAT_RGBA,P,!1,!0,v);return z.name=e,z}static PrepareEmptyColorsTexture(e){if(!md.EmptyColorsTexture){const d=new Uint8Array(4);md.EmptyColorsTexture=new n.b(d,1,1,w.b.TEXTUREFORMAT_RGBA,e,!1,!1,n.b.NEAREST_NEAREST),md.EmptyColorsTexture.name="grlEmptyColorsTexture"}return md.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var e;null===(e=md.EmptyColorsTexture)||void 0===e||e.dispose(),md.EmptyColorsTexture=null}static BooleanToNumber(e){return e?1:0}}class Te extends xe.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Se extends Ae.e{isCompatible(e){return!0}constructor(e,d,v){var p;v=v||{color:md.DEFAULT_COLOR};const L=new Te;L.GREASED_LINE_HAS_COLOR=!!v.color&&!v.useColors,L.GREASED_LINE_SIZE_ATTENUATION=v.sizeAttenuation??!1,L.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===v.colorDistributionType,L.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(d??e.Ae()).useRightHandedSystem,L.GREASED_LINE_CAMERA_FACING=v.cameraFacing??!0,super(e,Se.GREASED_LINE_MATERIAL_NAME,200,L,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(p=v)||void 0===p?void 0:p.forceGLSL)||Se.ForceGLSL,this._scene=d??e.Ae(),this._engine=this._scene.getEngine(),this._cameraFacing=v.cameraFacing??!0,this.visibility=v.visibility??1,this.useDash=v.useDash??!1,this.dashRatio=v.dashRatio??.5,this.dashOffset=v.dashOffset??0,this.width=v.width?v.width:v.sizeAttenuation?md.DEFAULT_WIDTH_ATTENUATED:md.DEFAULT_WIDTH,this._sizeAttenuation=v.sizeAttenuation??!1,this.colorMode=v.colorMode??0,this._color=v.color??null,this.useColors=v.useColors??!1,this._colorsDistributionType=v.colorDistributionType??0,this.colorsSampling=v.colorsSampling??n.b.NEAREST_NEAREST,this._colors=v.re??null,this.dashCount=v.dashCount??1,this.resolution=v.resolution??new P.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),v.colorsTexture?this.colorsTexture=v.colorsTexture:this._colors?this.colorsTexture=fe.CreateColorsTexture(`${e.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??md.DEFAULT_COLOR,fe.PrepareEmptyColorsTexture(this._scene)),this._engine.Fd.add((()=>{fe.DisposeEmptyColorsTexture()}))}getAttributes(e){e.push("grl_offsets"),e.push("grl_widths"),e.push("grl_colorPointers"),e.push("grl_counters"),this._cameraFacing?(e.push("grl_previousAndSide"),e.push("grl_nextAndCounters")):e.push("grl_slopes")}getSamplers(e){e.push("grl_colors")}getActiveTextures(e){this.colorsTexture&&e.push(this.colorsTexture)}getUniforms(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const d=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&d.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===e&&d.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:d,vertex:this._cameraFacing&&this._isGLSL(e)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(e)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(e){if(this._cameraFacing){e.bd("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||e.bd("viewProjection",this._scene.getTransformMatrix());const d=P.TmpVectors.Vector4[0];d.x=this._aspect,d.y=this._resolution.x,d.z=this._resolution.y,d.w=this.width,e.updateVector4("grl_aspect_resolution_lineWidth",d)}const d=P.TmpVectors.Vector4[0];d.x=fe.BooleanToNumber(this.useDash),d.y=this._dashArray,d.z=this.dashOffset,d.w=this.dashRatio,e.updateVector4("grl_dashOptions",d);const v=P.TmpVectors.Vector4[1];v.x=this.colorMode,v.y=this.visibility,v.z=this.colorsTexture?this.colorsTexture.getSize().width:0,v.w=fe.BooleanToNumber(this.useColors),e.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",v),this._color&&e.updateColor3("grl_singleColor",this._color);const p=this.colorsTexture??md.EmptyColorsTexture;e.setTexture("grl_colors",p),e.updateFloat2("grl_textureSize",(null===p||void 0===p?void 0:p.getSize().width)??1,(null===p||void 0===p?void 0:p.getSize().height)??1)}prepareDefines(e,d,v){e.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,e.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,e.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,e.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=d.useRightHandedSystem,e.GREASED_LINE_CAMERA_FACING=this._cameraFacing,e.GREASED_LINE_USE_OFFSETS=!!v.offsets}getClassName(){return Se.GREASED_LINE_MATERIAL_NAME}getCustomCode(e){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(d)?function(e,d){if("vertex"===e){const e={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return d&&(e["!gl_Position\\=viewProjection\\*worldPos;"]="//"),e}return"fragment"===e?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(e,this._cameraFacing):function(e,d){if("vertex"===e){const e={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return d&&(e["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),e}return"fragment"===e?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(e,this._cameraFacing)}dispose(){var e;null===(e=this.colorsTexture)||void 0===e||e.dispose(),super.dispose()}get re(){return this._colors}set re(e){this.setColors(e)}setColors(e){var d;let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const p=(null===(d=this._colors)||void 0===d?void 0:d.length)??0;var L;if(this._colors=e,null!==e&&0!==e.length){if(!v||P)if(this.colorsTexture&&p===e.length&&!P){const d=fe.Color3toRGBAUint8(e);this.colorsTexture.update(d)}else{var B;null===(B=this.colorsTexture)||void 0===B||B.dispose(),this.colorsTexture=fe.CreateColorsTexture(`${this._material.name}-colors-texture`,e,this.colorsSampling,this._scene)}}else null===(L=this.colorsTexture)||void 0===L||L.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(e){this._dashCount=e,this._dashArray=1/e}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(e){this._sizeAttenuation=e,this.markAllDefinesAsDirty()}get color(){return this._color}set color(e){this.setColor(e)}setColor(e){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==e||null!==this._color&&null===e?(this._color=e,d||this.markAllDefinesAsDirty()):this._color=e}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(e){this._colorsDistributionType=e,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(e){this._aspect=e.x/e.y,this._resolution=e}serialize(){const e=super.serialize(),d={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(d.re=this._colors),this._color&&(d.color=this._color),e.greasedLineMaterialOptions=d,e}parse(e,d,v){var P;super.parse(e,d,v);const p=e.greasedLineMaterialOptions;null===(P=this.colorsTexture)||void 0===P||P.dispose(),p.color&&this.setColor(p.color,!0),p.colorDistributionType&&(this.colorsDistributionType=p.colorDistributionType),p.re&&(this.re=p.re),p.colorsSampling&&(this.colorsSampling=p.colorsSampling),p.colorMode&&(this.colorMode=p.colorMode),p.useColors&&(this.useColors=p.useColors),p.visibility&&(this.visibility=p.visibility),p.useDash&&(this.useDash=p.useDash),p.dashCount&&(this.dashCount=p.dashCount),p.dashRatio&&(this.dashRatio=p.dashRatio),p.dashOffset&&(this.dashOffset=p.dashOffset),p.width&&(this.width=p.width),p.sizeAttenuation&&(this.sizeAttenuation=p.sizeAttenuation),p.resolution&&(this.resolution=p.resolution),this.re?this.colorsTexture=fe.CreateColorsTexture(`${this._material.name}-colors-texture`,this.re,this.colorsSampling,d):fe.PrepareEmptyColorsTexture(d),this.markAllDefinesAsDirty()}copyTo(e){var d;const v=e;null===(d=v.colorsTexture)||void 0===d||d.dispose(),this._colors&&(v.colorsTexture=fe.CreateColorsTexture(`${v._material.name}-colors-texture`,this._colors,v.colorsSampling,this._scene)),v.setColor(this.color,!0),v.colorsDistributionType=this.colorsDistributionType,v.colorsSampling=this.colorsSampling,v.colorMode=this.colorMode,v.useColors=this.useColors,v.visibility=this.visibility,v.useDash=this.useDash,v.dashCount=this.dashCount,v.dashRatio=this.dashRatio,v.dashOffset=this.dashOffset,v.width=this.width,v.sizeAttenuation=this.sizeAttenuation,v.resolution=this.resolution,v.markAllDefinesAsDirty()}_isGLSL(e){return 0===e||this._forceGLSL}}Se.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Se.ForceGLSL=!1,(0,ie.h)(`BABYLON.${Se.GREASED_LINE_MATERIAL_NAME}`,Se);var oe=v(12847),Ke=v(12262),Qe=v(12646),Ne=v(12359);class ue extends Qe.ShaderMaterial{constructor(e,d,p){const L=d.getEngine(),B=L.isWebGPU&&!(p.forceGLSL||ue.ForceGLSL),X=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];d.useRightHandedSystem&&X.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const z=["position","grl_widths","grl_offsets","grl_colorPointers"];p.cameraFacing?(X.push("GREASED_LINE_CAMERA_FACING"),z.push("grl_previousAndSide","grl_nextAndCounters")):(z.push("grl_slopes"),z.push("grl_counters"));const W=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(B||W.push("world","viewProjection","view","projection"),super(e,d,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:B?["Scene","Mesh"]:void 0,attributes:z,uniforms:W,samplers:B?[]:["grlColors"],defines:X,extraInitializationsAsync:async()=>{B?await Promise.all([v.e(66).then(v.bind(v,15574)),v.e(75).then(v.bind(v,15580))]):await Promise.all([v.e(69).then(v.bind(v,15584)),v.e(76).then(v.bind(v,15588))])},shaderLanguage:B?1:0}),this._color=U.Kd.White(),this._colorsDistributionType=0,this._colorsTexture=null,p=p||{color:md.DEFAULT_COLOR},this.visibility=p.visibility??1,this.useDash=p.useDash??!1,this.dashRatio=p.dashRatio??.5,this.dashOffset=p.dashOffset??0,this.dashCount=p.dashCount??1,this.width=p.width?p.width:p.sizeAttenuation&&p.cameraFacing?md.DEFAULT_WIDTH_ATTENUATED:md.DEFAULT_WIDTH,this.sizeAttenuation=p.sizeAttenuation??!1,this.color=p.color??U.Kd.White(),this.useColors=p.useColors??!1,this.colorsDistributionType=p.colorDistributionType??0,this.colorsSampling=p.colorsSampling??n.b.NEAREST_NEAREST,this.colorMode=p.colorMode??0,this._colors=p.re??null,this._cameraFacing=p.cameraFacing??!0,this.resolution=p.resolution??new P.Vector2(L.getRenderWidth(),L.getRenderHeight()),p.colorsTexture?this.colorsTexture=p.colorsTexture:this._colors?this.colorsTexture=fe.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,d):(this._color=this._color??md.DEFAULT_COLOR,this.colorsTexture=fe.PrepareEmptyColorsTexture(d)),B){const e=new Ne.b;e.setParameters(),e.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",e)}L.Fd.add((()=>{fe.DisposeEmptyColorsTexture()}))}dispose(){var e;null===(e=this._colorsTexture)||void 0===e||e.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new P.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get re(){return this._colors}set re(e){this.setColors(e)}setColors(e){var d;let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const p=(null===(d=this._colors)||void 0===d?void 0:d.length)??0;var L;if(this._colors=e,null!==e&&0!==e.length){if(!v||P)if(this._colorsTexture&&p===e.length&&!P){const d=fe.Color3toRGBAUint8(e);this._colorsTexture.update(d)}else{var B;null===(B=this._colorsTexture)||void 0===B||B.dispose(),this.colorsTexture=fe.CreateColorsTexture(`${this.name}-colors-texture`,e,this.colorsSampling,this.Ae())}}else null===(L=this._colorsTexture)||void 0===L||L.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(e){this._colorsTexture=e,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(e){this._width=e,this.setFloat("grlWidth",e)}get useColors(){return this._useColors}set useColors(e){this._useColors=e,this.setFloat("grlUseColors",fe.BooleanToNumber(e))}get colorsSampling(){return this._colorsSampling}set colorsSampling(e){this._colorsSampling=e}get visibility(){return this._visibility}set visibility(e){this._visibility=e,this.setFloat("grlVisibility",e)}get useDash(){return this._useDash}set useDash(e){this._useDash=e,this.setFloat("grlUseDash",fe.BooleanToNumber(e))}get dashOffset(){return this._dashOffset}set dashOffset(e){this._dashOffset=e,this.setFloat("grlDashOffset",e)}get dashRatio(){return this._dashRatio}set dashRatio(e){this._dashRatio=e,this.setFloat("grlDashRatio",e)}get dashCount(){return this._dashCount}set dashCount(e){this._dashCount=e,this._dashArray=1/e,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(e){this._sizeAttenuation=e,this.setFloat("grlSizeAttenuation",fe.BooleanToNumber(e))}get color(){return this._color}set color(e){this.setColor(e)}setColor(e){e=e??md.DEFAULT_COLOR,this._color=e,this.setColor3("grlColor",e)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(e){this._colorsDistributionType=e,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(e){this._colorMode=e,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(e){this._resolution=e,this.setVector2("grlResolution",e),this.setFloat("grlAspect",e.x/e.y)}serialize(){const e=super.serialize(),d={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(d.re=this._colors),e.greasedLineMaterialOptions=d,e}parse(e,d,v){var P;const p=e.greasedLineMaterialOptions;null===(P=this._colorsTexture)||void 0===P||P.dispose(),p.color&&(this.color=p.color),p.colorDistributionType&&(this.colorsDistributionType=p.colorDistributionType),p.colorsSampling&&(this.colorsSampling=p.colorsSampling),p.colorMode&&(this.colorMode=p.colorMode),p.useColors&&(this.useColors=p.useColors),p.visibility&&(this.visibility=p.visibility),p.useDash&&(this.useDash=p.useDash),p.dashCount&&(this.dashCount=p.dashCount),p.dashRatio&&(this.dashRatio=p.dashRatio),p.dashOffset&&(this.dashOffset=p.dashOffset),p.width&&(this.width=p.width),p.sizeAttenuation&&(this.sizeAttenuation=p.sizeAttenuation),p.resolution&&(this.resolution=p.resolution),p.re?this.colorsTexture=fe.CreateColorsTexture(`${this.name}-colors-texture`,p.re,this.colorsSampling,this.Ae()):this.colorsTexture=fe.PrepareEmptyColorsTexture(d),this._cameraFacing=p.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Oe,Re,Ye;ue.ForceGLSL=!1,function(e){e[e.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",e[e.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Oe||(Oe={})),function(e){e[e.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",e[e.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",e[e.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Re||(Re={})),function(e){e[e.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",e[e.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",e[e.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",e[e.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",e[e.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Ye||(Ye={}));class He extends Ce.b{constructor(e,d,v){super(e,d,null,null,!1,!1),this.name=e,this._options=v,this._lazy=!1,this._updatable=!1,this._engine=d.getEngine(),this._lazy=v.lazy??!1,this._updatable=v.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=v.colorPointers??[],this._widths=v.widths??new Array(v.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(e){let d=0;for(const P of this._points)d+=P.length;const v=d/3*2-this._widths.length;for(let P=0;P<v;P++)this._widths.push(e)}updateLazy(){var e,d;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(e=this._options.ribbonOptions)||void 0===e?void 0:e.smoothShading),!this.Se&&this.refreshBoundingInfo(),null===(d=this.greasedLineMaterial)||void 0===d||d.updateLazy()}addPoints(e,d){for(const v of e)this._points.push(v);this._lazy||this.setPoints(this._points,d)}dispose(e){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(e,d)}isLazy(){return this._lazy}get Ze(){return this._uvs}set Ze(e){this._uvs=e instanceof Float32Array?e:new Float32Array(e),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(e){this.material instanceof ue&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===e||void 0===e?void 0:e.length)>0),this._offsets=e,this._offsetsBuffer?this._offsetsBuffer.update(e):this._createOffsetsBuffer(e)}get widths(){return this._widths}set widths(e){this._widths=e,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(e)}get colorPointers(){return this._colorPointers}set colorPointers(e){this._colorPointers=e,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(e)}get greasedLineMaterial(){var e,d;if(this.material&&this.material instanceof ue)return this.material;const v=null===(e=this.material)||void 0===e||null===(d=e.pluginManager)||void 0===d?void 0:d.getPlugin(Se.GREASED_LINE_MATERIAL_NAME);return v||void 0}get points(){const e=[];return Ke.e.DeepCopy(this._points,e),e}setPoints(e,d){this._points=fe.ConvertPoints(e,(null===d||void 0===d?void 0:d.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==d&&void 0!==d&&d.colorPointers||this._updateColorPointers(),this._setPoints(this._points,d)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Ze:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(e){super.serialize(e),e.type=this.getClassName(),e.lineOptions=this._createLineOptions()}_createVertexBuffers(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new oe.d;return d.ie=this._vertexPositions,d.indices=this._indices,d.Ze=this._uvs,e&&(d.md=[],oe.d.ComputeNormals(this._vertexPositions,this._indices,d.md)),d.Te(this,this._options.updatable),d}_createOffsetsBuffer(e){const d=this._scene.getEngine(),v=new V.e(d,e,this._updatable,3);this.setVerticesBuffer(v.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=v}}class ae{constructor(e,d){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=e,this.wasAddedByNoopNode=d}getIndicesAccessor(e,d,v,P,p){var L,B,X,z;return null===(L=this._indicesAccessorMap.get(e))||void 0===L||null===(B=L.get(d))||void 0===B||null===(X=B.get(v))||void 0===X||null===(z=X.get(P))||void 0===z?void 0:z.get(p)}setIndicesAccessor(e,d,v,P,p,L){let B=this._indicesAccessorMap.get(e);B||(B=new Map,this._indicesAccessorMap.set(e,B));let X=B.get(d);X||(X=new Map,B.set(d,X));let z=X.get(v);z||(z=new Map,X.set(v,z));let W=z.get(P);W||(W=new Map,z.set(P,W)),W.set(p,L)}pushExportedNode(e){this._exportedNodes.has(e)||this._exportedNodes.add(e)}getNodesSet(){return this._exportedNodes}getVertexBufferView(e){return this._vertexBufferViewMap.get(e)}setVertexBufferView(e,d){this._vertexBufferViewMap.set(e,d)}setRemappedBufferView(e,d,v){this._remappedBufferView.set(e,new Map),this._remappedBufferView.get(e).set(d,v)}getRemappedBufferView(e,d){var v;return null===(v=this._remappedBufferView.get(e))||void 0===v?void 0:v.get(d)}getVertexAccessor(e,d,v){var P,p;return null===(P=this._vertexAccessorMap.get(e))||void 0===P||null===(p=P.get(d))||void 0===p?void 0:p.get(v)}setVertexAccessor(e,d,v,P){let p=this._vertexAccessorMap.get(e);p||(p=new Map,this._vertexAccessorMap.set(e,p));let L=p.get(d);L||(L=new Map,p.set(d,L)),L.set(v,P)}hasVertexColorAlpha(e){return this._vertexMapColorAlpha.get(e)||!1}setHasVertexColorAlpha(e,d){return this._vertexMapColorAlpha.set(e,d)}getMesh(e){return this._meshMap.get(e)}setMesh(e,d){this._meshMap.set(e,d)}bindMorphDataToMesh(e,d){const v=this._meshMorphTargetMap.get(e)||[];this._meshMorphTargetMap.set(e,v),-1===v.indexOf(d)&&v.push(d)}getMorphTargetsFromMesh(e){return this._meshMorphTargetMap.get(e)}}class te{_ApplyExtension(e,d,v,P){if(v>=d.length)return Promise.resolve(e);const p=P(d[v],e);return p?p.then((async e=>e?await this._ApplyExtension(e,d,v+1,P):null)):this._ApplyExtension(e,d,v+1,P)}_ApplyExtensions(e,d){const v=[];for(const P of te._ExtensionNames)v.push(this._extensions[P]);return this._ApplyExtension(e,v,0,d)}_extensionsPreExportTextureAsync(e,d,v){return this._ApplyExtensions(d,((d,P)=>d.preExportTextureAsync&&d.preExportTextureAsync(e,P,v)))}_extensionsPostExportNodeAsync(e,d,v,P,p){return this._ApplyExtensions(d,((d,L)=>d.postExportNodeAsync&&d.postExportNodeAsync(e,L,v,P,p,this._bufferManager)))}_extensionsPostExportMaterialAsync(e,d,v){return this._ApplyExtensions(d,((d,P)=>d.postExportMaterialAsync&&d.postExportMaterialAsync(e,P,v)))}_extensionsPostExportMaterialAdditionalTextures(e,d,v){const P=[];for(const p of te._ExtensionNames){const L=this._extensions[p];L.postExportMaterialAdditionalTextures&&P.push(...L.postExportMaterialAdditionalTextures(e,d,v))}return P}_extensionsPostExportTextures(e,d,v){for(const P of te._ExtensionNames){const p=this._extensions[P];p.postExportTexture&&p.postExportTexture(e,d,v)}}_extensionsPostExportMeshPrimitive(e){for(const d of te._ExtensionNames){const v=this._extensions[d];v.postExportMeshPrimitive&&v.postExportMeshPrimitive(e,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const e of te._ExtensionNames){const d=this._extensions[e];d.preGenerateBinaryAsync&&await d.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(e){for(const d of te._ExtensionNames){const v=this._extensions[d];v.enabled&&e(v)}}_extensionsOnExporting(){this._forEachExtensions((e=>{var d,v,P;e.wasUsed&&((d=this._glTF).extensionsUsed||(d.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(e.name)&&this._glTF.extensionsUsed.push(e.name),e.required&&((v=this._glTF).extensionsRequired||(v.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(e.name)&&this._glTF.extensionsRequired.push(e.name)),(P=this._glTF).extensions||(P.extensions={}),e.onExporting&&e.onExporting())}))}_loadExtensions(){for(const e of te._ExtensionNames){const d=te._ExtensionFactories[e](this);this._extensions[e]=d}}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:G.c.LastCreatedScene,d=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${w.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new N(this),this._extensions={},this._bufferManager=new Ve,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!e)throw new Error("No scene available to export");this._babylonScene=e,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:e=>{var d;return null===e||void 0===e||null===(d=e.rd)||void 0===d?void 0:d.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...d},this._loadExtensions()}dispose(){for(const e in this._extensions){this._extensions[e].dispose()}}get options(){return this._options}static RegisterExtension(e,d){te.UnregisterExtension(e)&&p.Tools.Warn(`Extension with the name ${e} already exists`),te._ExtensionFactories[e]=d,te._ExtensionNames.push(e)}static UnregisterExtension(e){if(!te._ExtensionFactories[e])return!1;delete te._ExtensionFactories[e];const d=te._ExtensionNames.indexOf(e);return-1!==d&&te._ExtensionNames.splice(d,1),!0}_generateJSON(e,d,v){const P={byteLength:e};return P.byteLength&&(this._glTF.buffers=[P]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.fd=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(P.uri=d+".bin"),v?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(e){const d=await this._generateBinaryAsync();this._extensionsOnExporting();const v=this._generateJSON(d.byteLength,e,!0),P=new Blob([d],{type:"application/octet-stream"}),p=e+".gltf",L=e+".bin",B=new W;if(B.files[p]=v,B.files[L]=P,this._imageData)for(const X in this._imageData)B.files[X]=new Blob([this._imageData[X].data],{type:this._imageData[X].mimeType});return B}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(e){const d=e%4;return 0===d?d:4-d}async generateGLBAsync(e){this._shouldUseGlb=!0;const d=await this._generateBinaryAsync();this._extensionsOnExporting();const v=this._generateJSON(d.byteLength),P=e+".glb";let p,L=v.length;if("undefined"!==typeof TextEncoder){p=(new TextEncoder).encode(v),L=p.length}const B=this._getPadding(L),X=this._getPadding(d.byteLength),z=28+L+B+d.byteLength+X,V=new ze(z);if(V.writeUInt32(1179937895),V.writeUInt32(2),V.writeUInt32(z),V.writeUInt32(L+B),V.writeUInt32(1313821514),p)V.writeTypedArray(p);else{const e="_".charCodeAt(0);for(let d=0;d<L;++d){const P=v.charCodeAt(d);P!=v.codePointAt(d)?V.writeUInt8(e):V.writeUInt8(P)}}for(let W=0;W<B;++W)V.writeUInt8(32);V.writeUInt32(d.byteLength+X),V.writeUInt32(5130562),V.writeTypedArray(d);for(let W=0;W<X;++W)V.writeUInt8(0);const k=new W;return k.files[P]=new Blob([V.getOutputData()],{type:"application/octet-stream"}),k}_setNodeTransformation(e,d,v){if(d.getPivotPoint().equalsWithEpsilon(H,Y.e)||p.Tools.Warn("Pivot points are not supported in the glTF serializer"),!d.position.equalsWithEpsilon(H,Y.e)){const p=P.TmpVectors.mv[0].L(d.position);v&&j(p),e.translation=p.Yd()}d.tv.equalsWithEpsilon(t,Y.e)||(e.scale=d.tv.Yd());const L=d.rotationQuaternion||P.Quaternion.FromEulerAngles(d.rotation.x,d.rotation.y,d.rotation.z);L.equalsWithEpsilon(a,Y.e)||(v&&J(L),e.rotation=L.normalize().Yd())}_setCameraTransformation(e,d,v){if(!d.position.equalsWithEpsilon(H,Y.e)){const p=P.TmpVectors.mv[0].L(d.position);v&&j(p),e.translation=p.Yd()}const p=d.rotationQuaternion||P.Quaternion.FromEulerAngles(d.rotation.x,d.rotation.y,d.rotation.z);v&&J(p),this._babylonScene.useRightHandedSystem||E(p),p.equalsWithEpsilon(a,Y.e)||(e.rotation=p.Yd())}_listAvailableCameras(){for(const e of this._babylonScene.cameras){const d={type:e.mode===ge.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(e.name&&(d.name=e.name),"perspective"===d.type)d.perspective={aspectRatio:e.getEngine().getAspectRatio(e),yfov:e.fovMode===ge.c.FOVMODE_VERTICAL_FIXED?e.fov:e.fov*e.getEngine().getAspectRatio(e),znear:e.td,zfar:e.maxZ};else if("orthographic"===d.type){const v=e.orthoLeft&&e.orthoRight?.5*(e.orthoRight-e.orthoLeft):.5*e.getEngine().getRenderWidth(),P=e.orthoBottom&&e.orthoTop?.5*(e.orthoTop-e.orthoBottom):.5*e.getEngine().getRenderHeight();d.orthographic={xmag:v,ymag:P,znear:e.td,zfar:e.maxZ}}this._camerasMap.set(e,d)}}_exportAndAssignCameras(){const e=Array.from(this._camerasMap.values());for(const d of e){const e=this._nodesCameraMap.get(d);if(void 0!==e){this._cameras.push(d);for(const d of e)d.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const e of this._babylonScene.skeletons){if(e.bones.length<=0)continue;const d={joints:[]};this._skinMap.set(e,d)}}_exportAndAssignSkeletons(){for(const e of this._babylonScene.skeletons){if(e.bones.length<=0)continue;const d=this._skinMap.get(e);if(void 0==d)continue;const v={},P=[];let L=-1;for(let p=0;p<e.bones.length;++p){const d=e.bones[p],P=d.getIndex()??p;-1!==P&&(v[P]=d,P>L&&(L=P))}for(let e=0;e<=L;++e){const L=v[e];P.push(L.getAbsoluteInverseBindMatrix());const B=L.getTransformNode();if(null!==B){const e=this._nodeMap.get(B);B&&null!==e&&void 0!==e?d.joints.push(e):p.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else p.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const B=this._nodesSkinMap.get(d);if(d.joints.length>0&&void 0!==B){const e=64*P.length,v=new Float32Array(e/4);P.forEach(((e,d)=>{v.set(e.m,16*d)}));const p=this._bufferManager.createBufferView(v);this._accessors.push(this._bufferManager.createAccessor(p,"MAT4",5126,P.length)),d.inverseBindMatrices=this._accessors.length-1,this._skins.push(d);for(const d of B)d.skin=this._skins.length-1}}}async _exportSceneAsync(){const e={nodes:[]};if(this._babylonScene.metadata){const d=this._options.metadataSelector(this._babylonScene.metadata);d&&(e.extras=d)}const d=new Array,v=new Array,P=new Array;for(const X of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Be(X,this._babylonScene.useRightHandedSystem)?P.push(...X.getChildren()):this._babylonScene.useRightHandedSystem?d.push(X):v.push(X);this._listAvailableCameras(),this._listAvailableSkeletons();const p=new ae(!0,!1);e.nodes.push(...await this._exportNodesAsync(v,p));const L=new ae(!1,!1);e.nodes.push(...await this._exportNodesAsync(d,L));const B=new ae(!1,!0);e.nodes.push(...await this._exportNodesAsync(P,B)),e.nodes.length&&this._scenes.push(e),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&he._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,p.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(e){let d=this._shouldExportNodeMap.get(e);return void 0===d&&(d=this._options.shouldExportNode(e),this._shouldExportNodeMap.set(e,d)),d}async _exportNodesAsync(e,d){const v=new Array;this._exportBuffers(e,d);for(const P of e)await this._exportNodeAsync(P,v,d);return v}_collectBuffers(e,d,v,P,p){if(this._shouldExportNode(e)&&e instanceof g.d&&e.sd){const L=e.sd.getVertexBuffers();if(L)for(const P in L){if(!M(P))continue;const B=L[P];p.setHasVertexColorAlpha(B,e.hasVertexAlpha);const X=B._buffer,z=d.get(X)||[];d.set(X,z),-1===z.indexOf(B)&&z.push(B);const W=v.get(B)||[];v.set(B,W),-1===W.indexOf(e)&&W.push(e)}const B=e.morphTargetManager;if(B)for(let d=0;d<B.numTargets;d++){const v=B.getTarget(d),p=P.get(v)||[];P.set(v,p),-1===p.indexOf(e)&&p.push(e)}}for(const L of e.getChildren())this._collectBuffers(L,d,v,P,p)}_exportBuffers(e,d){const v=new Map,P=new Map,p=new Map;for(const X of e)this._collectBuffers(X,v,P,p,d);const L=Array.from(v.keys());for(const X of L){const e=X.getData();if(!e)throw new Error("Buffer data is not available");const p=v.get(X);if(!p)continue;const L=p[0].byteStride;if(p.some((e=>e.byteStride!==L)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const B=ve(e).slice();for(const d of p){const e=P.get(d),{byteOffset:v,byteStride:p,componentCount:L,type:X,count:z,normalized:W,kind:k}=c(d,e);switch(k){case V.i.NormalKind:case V.i.TangentKind:(0,u.j)(B,v,p,L,X,z,W,(e=>{const d=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);if(d>0){const v=1/d;e[0]*=v,e[1]*=v,e[2]*=v}}));break;case V.i.ColorKind:{const d=e.filter((e=>e.material instanceof Ge.Sd||null==e.material)).length;if(0==d)break;if(d!=e.length){O.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}X==V.i.UNSIGNED_BYTE&&O.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const P=new U.Kd,k=new U.Up,g=this._babylonScene.getEngine().useExactSrgbConversions;(0,u.j)(B,v,p,L,X,z,W,(e=>{3===e.length?(P.Yv(e,0),P.toLinearSpaceToRef(P,g),P.toArray(e,0)):(k.Yv(e,0),k.toLinearSpaceToRef(k,g),k.toArray(e,0))}))}}}if(d.convertToRightHanded){for(const e of p){const d=P.get(e),{byteOffset:v,byteStride:p,componentCount:L,type:X,count:z,normalized:W,kind:k}=c(e,d);switch(k){case V.i.PositionKind:case V.i.NormalKind:case V.i.TangentKind:(0,u.j)(B,v,p,L,X,z,W,(e=>{e[0]=-e[0]}))}}d.convertedToRightHandedBuffers.set(X,B)}const z=this._bufferManager.createBufferView(B,L);d.setVertexBufferView(X,z);const W=new Map;for(const d of p){const e=P.get(d),{kind:v,totalVertices:p}=c(d,e);switch(v){case V.i.MatricesIndicesKind:case V.i.MatricesIndicesExtraKind:if(d.type==V.i.FLOAT){const e=d.getFloatData(p);null!==e&&W.set(d,e)}}}0!==W.size&&O.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const k=Array.from(W.keys());for(const v of k){const e=W.get(v);if(!e)continue;const P=e.some((e=>e>=256)),p=new(P?Uint16Array:Uint8Array)(e.length);for(let d=0;d<e.length;d++)p[d]=e[d];const L=this._bufferManager.createBufferView(p,4*(P?2:1));d.setRemappedBufferView(X,v,L)}}const B=Array.from(p.keys());for(const X of B){const e=p.get(X);if(!e)continue;const v=le(X,e[0],this._bufferManager,this._bufferViews,this._accessors,d.convertToRightHanded);for(const P of e)d.bindMorphDataToMesh(P,v)}}async _exportNodeAsync(e,d,v){let P=this._nodeMap.get(e);if(void 0!==P)return void(d.includes(P)||d.push(P));const p=await this._createNodeAsync(e,v);if(p){P=this._nodes.length,this._nodes.push(p),this._nodeMap.set(e,P),v.pushExportedNode(e),d.push(P);const L={name:"runtime animations",channels:[],samplers:[]},B=[];this._babylonScene.animationGroups.length||(he._CreateMorphTargetAnimationFromMorphTargetAnimations(e,L,B,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,v.convertToRightHanded,this._options.shouldExportAnimation),e.animations.length&&he._CreateNodeAnimationFromNodeAnimations(e,L,B,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,v.convertToRightHanded,this._options.shouldExportAnimation)),L.channels.length&&L.samplers.length&&this._animations.push(L),B.forEach((e=>{e.channels.length&&e.samplers.length&&this._animations.push(e)}))}const L=p?[]:d;for(const B of e.getChildren())await this._exportNodeAsync(B,L,v);p&&L.length&&(p.children=L)}async _createNodeAsync(e,d){if(!this._shouldExportNode(e))return null;const v={};if(e.name&&(v.name=e.name),e.metadata){const d=this._options.metadataSelector(e.metadata);d&&(v.extras=d)}if(e instanceof k.c&&(this._setNodeTransformation(v,e,d.convertToRightHanded),e instanceof g.d)){const p=e instanceof F.e?e.sourceMesh:e;if(p.Qd&&p.Qd.length>0&&(v.mesh=await this._exportMeshAsync(p,d)),e.skeleton){const d=this._skinMap.get(e.skeleton);var P;if(void 0!==d)void 0===this._nodesSkinMap.get(d)&&this._nodesSkinMap.set(d,[]),null===(P=this._nodesSkinMap.get(d))||void 0===P||P.push(v)}}if(e instanceof R.c){const P=this._camerasMap.get(e);if(P){var p;void 0===this._nodesCameraMap.get(P)&&this._nodesCameraMap.set(P,[]),this._setCameraTransformation(v,e,d.convertToRightHanded);const B=e.parent;if(null!==B&&de(e,B)){const e=this._nodeMap.get(B);if(void 0!==e){var L;const d=this._nodes[e];return ee(v,d),null===(L=this._nodesCameraMap.get(P))||void 0===L||L.push(d),null}}null===(p=this._nodesCameraMap.get(P))||void 0===p||p.push(v)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",v,e,this._nodeMap,d.convertToRightHanded)?v:(O.c.Warn(`Not exporting node ${e.name}`),null)}_exportIndices(e,d,v,P,p,B,X,z,W){let V=e;W.mode=s(B);const k=X!==L.b.CounterClockWiseSideOrientation,g=!z.wasAddedByNoopNode&&k,F=function(e){switch(e){case L.b.TriangleFillMode:case L.b.TriangleStripDrawMode:case L.b.TriangleFanDrawMode:return!0}return!1}(B)&&g;if(F){if(B===L.b.TriangleStripDrawMode||B===L.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");W.mode=s(B);const X=d?new Uint32Array(P):new Uint16Array(P);if(e)for(let d=0;d+2<P;d+=3)X[d]=e[v+d]+p,X[d+1]=e[v+d+2]+p,X[d+2]=e[v+d+1]+p;else for(let e=0;e+2<P;e+=3)X[e]=e,X[e+1]=e+2,X[e+2]=e+1;V=X}else if(e&&0!==p){const L=d?new Uint32Array(P):new Uint16Array(P);for(let d=0;d<P;d++)L[d]=e[v+d]+p;V=L}if(V){let L=z.getIndicesAccessor(e,v,P,p,F);if(void 0===L){const B=function(e,d,v,P){if(e instanceof Uint16Array||e instanceof Uint32Array)return e;if(e instanceof Int32Array)return new Uint32Array(e.buffer,e.byteOffset,e.length);const p=e.slice(d,d+v);return P?new Uint32Array(p):new Uint16Array(p)}(V,0,P,d),X=this._bufferManager.createBufferView(B),W=d?5125:5123;this._accessors.push(this._bufferManager.createAccessor(X,"SCALAR",W,P,0)),L=this._accessors.length-1,z.setIndicesAccessor(e,v,P,p,F,L)}W.indices=L}}_exportVertexBuffer(e,d,v,P,p,L){const B=e.getKind();if(!M(B))return;if(B.startsWith("uv")&&!this._options.exportUnusedUVs&&(!d||!this._materialNeedsUVsSet.has(d)))return;let X=p.getVertexAccessor(e,v,P);if(void 0===X){const d=p.convertedToRightHandedBuffers.get(e._buffer)||e._buffer.getData(),L=B===V.i.PositionKind?function(e,d,v,P){const{byteOffset:p,byteStride:L,type:B,normalized:X}=d,z=d.getSize(),W=new Array(z).fill(1/0),V=new Array(z).fill(-1/0);return(0,u.j)(e,p+v*L,L,z,B,P*z,X,(e=>{for(let d=0;d<z;d++)W[d]=Math.min(W[d],e[d]),V[d]=Math.max(V[d],e[d])})),{min:W,max:V}}(d,e,v,P):void 0,z=(B===V.i.MatricesIndicesKind||B===V.i.MatricesIndicesExtraKind)&&e.type===V.i.FLOAT,W=z?V.i.UNSIGNED_BYTE:e.type,k=z?void 0:e.normalized,g=z?p.getRemappedBufferView(e._buffer,e):p.getVertexBufferView(e._buffer),F=e.byteOffset+v*e.byteStride;this._accessors.push(this._bufferManager.createAccessor(g,function(e,d){if(e==V.i.ColorKind)return d?"VEC4":"VEC3";switch(e){case V.i.PositionKind:case V.i.NormalKind:return"VEC3";case V.i.TangentKind:case V.i.MatricesIndicesKind:case V.i.MatricesIndicesExtraKind:case V.i.MatricesWeightsKind:case V.i.MatricesWeightsExtraKind:return"VEC4";case V.i.UVKind:case V.i.UV2Kind:case V.i.UV3Kind:case V.i.UV4Kind:case V.i.UV5Kind:case V.i.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${e}`)}(B,p.hasVertexColorAlpha(e)),W,P,F,L,k)),X=this._accessors.length-1,p.setVertexAccessor(e,v,P,X)}L.attributes[function(e){switch(e){case V.i.PositionKind:return"POSITION";case V.i.NormalKind:return"NORMAL";case V.i.TangentKind:return"TANGENT";case V.i.ColorKind:return"COLOR_0";case V.i.UVKind:return"TEXCOORD_0";case V.i.UV2Kind:return"TEXCOORD_1";case V.i.UV3Kind:return"TEXCOORD_2";case V.i.UV4Kind:return"TEXCOORD_3";case V.i.UV5Kind:return"TEXCOORD_4";case V.i.UV6Kind:return"TEXCOORD_5";case V.i.MatricesIndicesKind:return"JOINTS_0";case V.i.MatricesIndicesExtraKind:return"JOINTS_1";case V.i.MatricesWeightsKind:return"WEIGHTS_0";case V.i.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${e}`)}(B)]=X}async _exportMaterialAsync(e,d,v,P){let p=this._materialMap.get(e);if(void 0===p){const P=d&&Object.keys(d).some((e=>e.startsWith("uv")));if((e=e instanceof Fe.d?e.ip[v.materialIndex]:e)instanceof we.e)p=await this._materialExporter.exportPBRMaterialAsync(e,"image/png",P);else{if(!(e instanceof Ge.Sd))return void O.c.Warn(`Unsupported material '${e.name}' with type ${e.getClassName()}`);p=await this._materialExporter.exportStandardMaterialAsync(e,"image/png",P)}this._materialMap.set(e,p)}P.material=p}async _exportMeshAsync(e,d){var v;let P=d.getMesh(e);if(void 0!==P)return P;const p={primitives:[]};P=this._meshes.length,this._meshes.push(p),d.setMesh(e,P);const B=e.isUnIndexed?null:e.yd(),X=null===(v=e.sd)||void 0===v?void 0:v.getVertexBuffers(),z=d.getMorphTargetsFromMesh(e),W=e instanceof ne.c,V=e instanceof He,k=e.Qd;if(X&&k&&k.length>0)for(const w of k){const v={attributes:{}},P=w.Ne()||this._babylonScene.defaultMaterial;if(V){var g,F;const d={name:P.name},p=e,L=U.Kd.White(),B=(null===(g=p.material)||void 0===g?void 0:g.alpha)??1,X=(null===(F=p.greasedLineMaterial)||void 0===F?void 0:F.color)??L;(!X.equalsWithEpsilon(L,Y.e)||B<1)&&(d.pbrMetallicRoughness={baseColorFactor:[...X.Yd(),B]}),this._materials.push(d),v.material=this._materials.length-1}else if(W){const d={name:P.name},p=e;(!p.color.equalsWithEpsilon(U.Kd.White(),Y.e)||p.alpha<1)&&(d.pbrMetallicRoughness={baseColorFactor:[...p.color.Yd(),p.alpha]}),this._materials.push(d),v.material=this._materials.length-1}else await this._exportMaterialAsync(P,X,w,v);const k=W||V?L.b.LineListDrawMode:e.overrideRenderingFillMode??P.fillMode,G=P._getEffectiveOrientation(e);this._exportIndices(B,B?(0,u.d)(B,w.indexCount,w.indexStart,w.verticesStart):w.verticesCount>65535,B?w.indexStart:w.verticesStart,B?w.indexCount:w.verticesCount,-w.verticesStart,k,G,d,v);for(const e of Object.values(X))this._exportVertexBuffer(e,P,w.verticesStart,w.verticesCount,d,v);if(z){v.targets=[];for(const e of z)v.targets.push(e.attributes)}p.primitives.push(v),this._extensionsPostExportMeshPrimitive(v)}if(z){p.weights=[],p.extras||(p.extras={}),p.extras.targetNames=[];for(const e of z)p.weights.push(e.influence),p.extras.targetNames.push(e.name)}return P}}te._ExtensionNames=new Array,te._ExtensionFactories={};class Ie{static async GLTFAsync(e,d,v){v&&v.exportWithoutWaitingForScene||await e.whenReadyAsync();const P=new te(e,v),p=await P.generateGLTFAsync(d.replace(/\.[^/.]+$/,""));return P.dispose(),p}static async GLBAsync(e,d,v){v&&v.exportWithoutWaitingForScene||await e.whenReadyAsync();const P=new te(e,v),p=await P.generateGLBAsync(d.replace(/\.[^/.]+$/,""));return P.dispose(),p}}v(12980);const ce="EXT_mesh_gpu_instancing";class be{constructor(e){this.name=ce,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(e,d,v,p,L,B){return await new Promise((e=>{if(d&&v instanceof Ce.b&&v.hasThinInstances&&this._exporter){this._wasUsed=!0;const e=P.mv.Zero(),p=P.Quaternion.Identity(),X=P.mv.One(),z=v.thinInstanceGetWorldMatrices(),W=P.TmpVectors.mv[2],V=P.TmpVectors.Quaternion[1],k=P.TmpVectors.mv[3];let g=!1,F=!1,w=!1;const G=new Float32Array(3*v.XL),U=new Float32Array(4*v.XL),D=new Float32Array(3*v.XL);let C=0;for(const d of z)d.decompose(k,V,W),L&&(j(W),J(V)),G.set(W.Yd(),3*C),U.set(V.normalize().Yd(),4*C),D.set(k.Yd(),3*C),g=g||!W.equalsWithEpsilon(e),F=F||!V.equalsWithEpsilon(p),w=w||!k.equalsWithEpsilon(X),C++;const q={attributes:{}};g&&(q.attributes.TRANSLATION=this._buildAccessor(G,"VEC3",v.XL,B)),F&&(q.attributes.ROTATION=this._buildAccessor(U,"VEC4",v.XL,B)),w&&(q.attributes.SCALE=this._buildAccessor(D,"VEC3",v.XL,B)),d.extensions=d.extensions||{},d.extensions[ce]=q}e(d)}))}_buildAccessor(e,d,v,P){const p=P.createBufferView(e),L=P.createAccessor(p,d,5126,v);return this._exporter._accessors.push(L),this._exporter._accessors.length-1}}te.RegisterExtension(ce,(e=>new be(e)));var Me=v(12987),se=v(12996),ye=v(13e3),je=v(13007);function Je(e){return e===ye.b.PositionKind?"POSITION":e===ye.b.NormalKind?"NORMAL":e===ye.b.ColorKind?"COLOR":e.startsWith(ye.b.UVKind)?"TEX_COORD":"GENERIC"}const Ee={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class ed extends Me.e{static get DefaultAvailable(){return(0,Me.j)(ed.DefaultConfiguration)}static get Default(){return ed._Default??(ed._Default=new ed),ed._Default}static ResetDefault(e){ed._Default&&(e||ed._Default.dispose(),ed._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(e,d){return{module:await(d||DracoEncoderModule)({wasmBinary:e})}}_getWorkerContent(){return`${se.h}(${se.i})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:ed.DefaultConfiguration)}async _encodeAsync(e,d,v){const P=v?(0,je.c)(Ee,v):Ee;if(this._workerPoolPromise){const v=await this._workerPoolPromise;return await new Promise(((p,L)=>{v.push(((v,B)=>{const X=e=>{v.removeEventListener("error",X),v.removeEventListener("message",z),L(e),B()},z=e=>{"encodeMeshDone"===e.data.id&&(v.removeEventListener("error",X),v.removeEventListener("message",z),p(e.data.encodedMeshData),B())};v.addEventListener("error",X),v.addEventListener("message",z);const W=[];for(const d of e)W.push(d.data.buffer);d&&W.push(d.buffer),v.postMessage({id:"encodeMesh",attributes:e,indices:d,options:P},W)}))}))}if(this._modulePromise){const v=await this._modulePromise;return(0,se.h)(v.module,e,d,P)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(e,d){if(0==e.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");e instanceof Ce.b&&e.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===d||void 0===d?void 0:d.method)&&(O.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),d.method="MESH_SEQUENTIAL_ENCODING");const v=function(e){let d=e.yd(void 0,!0);return!d||d instanceof Uint32Array||d instanceof Uint16Array||(d=((0,u.d)(d,d.length)?Uint32Array:Uint16Array).from(d)),d}(e),P=function(e,d){const v=[];for(const P of e.getVerticesDataKinds()){if(null!==d&&void 0!==d&&d.includes(P)){if(P===ye.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const p=e.getVertexBuffer(P),L=p.getSize(),B=(0,u.s)(p.getData(),L,p.type,p.byteOffset,p.byteStride,p.normalized,e.getTotalVertices(),!0);v.push({kind:P,dracoName:Je(P),size:L,data:B})}return v}(e,null===d||void 0===d?void 0:d.excludedAttributes);return await this._encodeAsync(P,v,d)}}ed.DefaultConfiguration={wasmUrl:`${p.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${p.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${p.Tools._DefaultCdnUrl}/draco_encoder.js`},ed._Default=null;const dd="KHR_draco_mesh_compression";class vd{get wasUsed(){return this._wasUsed}constructor(e){this.name=dd,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===e.options.meshCompressionMethod&&ed.DefaultAvailable}dispose(){}postExportMeshPrimitive(e,d,v){if(!this.enabled)return;if(4!==e.mode&&5!==e.mode)return void O.c.Warn("Cannot compress primitive with mode "+e.mode+".");const P=[],p=[];let L=null;if(void 0!==e.indices){const B=v[e.indices],X=d.getBufferView(B);L=d.getData(X).slice(),P.push(X),p.push(B)}const B=[];for(const[V,k]of Object.entries(e.attributes)){const e=v[k],L=d.getBufferView(e),z=b(e.type),W=(0,u.s)(d.getData(L),z,e.componentType,e.byteOffset||0,L.byteStride||(0,u.l)(e.componentType)*z,e.normalized||!1,e.count,!0);B.push({kind:V,dracoName:(X=V,"POSITION"===X?"POSITION":"NORMAL"===X?"NORMAL":X.startsWith("COLOR")?"COLOR":X.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:b(e.type),data:W}),P.push(L),p.push(e)}var X;const z={method:e.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},W=ed.Default._encodeAsync(B,L,z).then((v=>{if(!v)return void O.c.Error("Draco encoding failed for primitive.");const L={bufferView:-1,attributes:v.attributeIds},B=d.createBufferView(v.data);d.setBufferView(L,B);for(const e of P)this._bufferViewsUsed.add(e);for(const e of p)this._accessorsUsed.add(e);e.extensions||(e.extensions={}),e.extensions[dd]=L})).catch((e=>{O.c.Error("Draco encoding failed for primitive: "+e)}));this._encodePromises.push(W),this._wasUsed=!0}async preGenerateBinaryAsync(e){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((d=>{e.getPropertiesWithBufferView(d).every((e=>this._accessorsUsed.has(e)))&&e.removeBufferView(d)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}te.RegisterExtension(dd,(e=>new vd(e)));var Pd=v(13013);const pd="KHR_lights_punctual",Ld={name:"",color:[1,1,1],nX:1,range:Number.MAX_VALUE},Bd={innerConeAngle:0,outerConeAngle:Math.PI/4},Xd=P.mv.Backward();class zd{constructor(e){this.name=pd,this.enabled=!0,this.required=!1,this._exporter=e}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[pd]=this._lights}async postExportNodeAsync(e,d,v,p,L){return await new Promise((B=>{if(!(v instanceof qe.e))return void B(d);const X=v.getTypeID()==qe.e.LIGHTTYPEID_POINTLIGHT?"point":v.getTypeID()==qe.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":v.getTypeID()==qe.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!X||!(v instanceof Pd.e))return O.c.Warn(`${e}: Light ${v.name} is not supported in ${pd}`),void B(d);if(v.falloffType!==qe.e.FALLOFF_GLTF&&O.c.Warn(`${e}: Light falloff for ${v.name} does not match the ${pd} specification!`),!v.position.equalsToFloats(0,0,0)){const e=P.TmpVectors.mv[0].L(v.position);L&&j(e),d.translation=e.Yd()}if("point"!==X){const e=v.direction.normalizeToRef(P.TmpVectors.mv[0]);L&&j(e);const p=P.Quaternion.FromUnitVectorsToRef(Xd,e,P.TmpVectors.Quaternion[0]);P.Quaternion.IsIdentity(p)||(d.rotation=p.Yd())}const z={type:X,name:v.name,color:v.AX.Yd(),nX:v.nX,range:v.range};if(Pe(z,Ld),"spot"===X){const e=v;z.spot={innerConeAngle:e.innerAngle/2,outerConeAngle:e.angle/2},Pe(z.spot,Bd)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(z);const W={zd:this._lights.lights.length-1},V=v.parent;if(V&&de(v,V)){const e=p.get(V);if(e){const v=this._exporter._nodes[e];return ee(d,v),v.extensions||(v.extensions={}),v.extensions[pd]=W,void B(null)}}d.extensions||(d.extensions={}),d.extensions[pd]=W,B(d)}))}}te.RegisterExtension(pd,(e=>new zd(e)));var Wd=v(12927);const Vd="KHR_materials_anisotropy";class kd{constructor(e){this.name=Vd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,d,v){const P=[];return v instanceof Wd.e&&v.anisotropy.isEnabled&&!v.anisotropy.legacy?(v.anisotropy.texture&&P.push(v.anisotropy.texture),P):[]}postExportMaterialAsync(e,d,v){return new Promise((e=>{if(v instanceof Wd.e){if(!v.anisotropy.isEnabled||v.anisotropy.legacy)return void e(d);this._wasUsed=!0,d.extensions=d.extensions||{};const P=this._exporter._materialExporter.getTextureInfo(v.anisotropy.texture),p={anisotropyStrength:v.anisotropy.nX,anisotropyRotation:v.anisotropy.angle,anisotropyTexture:P??void 0};null!==p.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(v),d.extensions[Vd]=p}e(d)}))}}te.RegisterExtension(Vd,(e=>new kd(e)));const gd="KHR_materials_clearcoat";class Fd{constructor(e){this.name=gd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,d,v){const P=[];return v instanceof Wd.e&&v.clearCoat.isEnabled?(v.clearCoat.texture&&P.push(v.clearCoat.texture),!v.clearCoat.useRoughnessFromMainTexture&&v.clearCoat.textureRoughness&&P.push(v.clearCoat.textureRoughness),v.clearCoat.bumpTexture&&P.push(v.clearCoat.bumpTexture),P):[]}postExportMaterialAsync(e,d,v){return new Promise((e=>{if(v instanceof Wd.e){if(!v.clearCoat.isEnabled)return void e(d);this._wasUsed=!0,d.extensions=d.extensions||{};const P=this._exporter._materialExporter.getTextureInfo(v.clearCoat.texture);let L;L=v.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(v.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(v.clearCoat.textureRoughness),v.clearCoat.isTintEnabled&&p.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${v.name}`),v.clearCoat.remapF0OnInterfaceChange&&p.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${v.name}`);const B=this._exporter._materialExporter.getTextureInfo(v.clearCoat.bumpTexture),X={clearcoatFactor:v.clearCoat.nX,clearcoatTexture:P??void 0,clearcoatRoughnessFactor:v.clearCoat.roughness,clearcoatRoughnessTexture:L??void 0,clearcoatNormalTexture:B??void 0};null===X.clearcoatTexture&&null===X.clearcoatRoughnessTexture&&null===X.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(v),d.extensions[gd]=X}e(d)}))}}te.RegisterExtension(gd,(e=>new Fd(e)));const wd="KHR_materials_diffuse_transmission";function Gd(e,d){const v=d.subSurface;let P=null;return v.translucencyIntensityTexture?P=v.translucencyIntensityTexture:v.thicknessTexture&&v.useMaskFromThicknessTexture&&(P=v.thicknessTexture),P&&!v.useGltfStyleTextures?(O.c.Warn(`${e}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${d.name}`,1),null):P}class Ud{constructor(e){this.name=wd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,d,v){const P=[];if(v instanceof we.e&&this._isExtensionEnabled(v)){const d=Gd(e,v);return d&&P.push(d),v.subSurface.translucencyColorTexture&&P.push(v.subSurface.translucencyColorTexture),P}return P}_isExtensionEnabled(e){if(e.unlit)return!1;const d=e.subSurface;return!!d.isTranslucencyEnabled&&(!e.unlit&&!d.useAlbedoToTintTranslucency&&d.useGltfStyleTextures&&1===d.volumeIndexOfRefraction&&0===d.minimumThickness&&0===d.maximumThickness)}postExportMaterialAsync(e,d,v){return new Promise((P=>{if(v instanceof we.e&&this._isExtensionEnabled(v)){this._wasUsed=!0;const P=v.subSurface,p=Gd(e,v),L=0==P.translucencyIntensity?void 0:P.translucencyIntensity,B=this._exporter._materialExporter.getTextureInfo(p)??void 0,X=!P.translucencyColor||P.translucencyColor.equalsFloats(1,1,1)?void 0:P.translucencyColor.Yd(),z=this._exporter._materialExporter.getTextureInfo(P.translucencyColorTexture)??void 0,W={diffuseTransmissionFactor:L,diffuseTransmissionTexture:B,diffuseTransmissionColorFactor:X,diffuseTransmissionColorTexture:z};(B||z)&&this._exporter._materialNeedsUVsSet.add(v),d.extensions=d.extensions||{},d.extensions[wd]=W}P(d)}))}}te.RegisterExtension(wd,(e=>new Ud(e)));const Dd="KHR_materials_dispersion";class Cd{constructor(){this.name=Dd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(e){if(e.unlit)return!1;const d=e.subSurface;return!(!d.isRefractionEnabled&&!d.isDispersionEnabled)}postExportMaterialAsync(e,d,v){return new Promise((e=>{if(v instanceof we.e&&this._isExtensionEnabled(v)){this._wasUsed=!0;const e={dispersion:v.subSurface.dispersion};d.extensions=d.extensions||{},d.extensions[Dd]=e}e(d)}))}}te.RegisterExtension(Dd,(()=>new Cd));const qd="KHR_materials_emissive_strength";class hd{constructor(){this.name=qd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(e,d,v){return await new Promise((e=>{if(!(v instanceof we.e))return e(d);const P=v.emissiveColor.Yd(),p=Math.max(...P);if(p>1){this._wasUsed=!0,d.extensions||(d.extensions={});const e={emissiveStrength:p},P=v.emissiveColor.scale(1/e.emissiveStrength);d.emissiveFactor=P.Yd(),d.extensions[qd]=e}return e(d)}))}}te.RegisterExtension(qd,(e=>new hd));const ld="KHR_materials_ior";class nd{constructor(){this.name=ld,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(e){return!e.unlit&&(void 0!=e.indexOfRefraction&&1.5!=e.indexOfRefraction)}postExportMaterialAsync(e,d,v){return new Promise((e=>{if(v instanceof we.e&&this._isExtensionEnabled(v)){this._wasUsed=!0;const e={ior:v.indexOfRefraction};d.extensions=d.extensions||{},d.extensions[ld]=e}e(d)}))}}te.RegisterExtension(ld,(e=>new nd));const Ad="KHR_materials_iridescence";class xd{constructor(e){this.name=Ad,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,d,v){const P=[];return v instanceof Wd.e&&v.iridescence.isEnabled?(v.iridescence.texture&&P.push(v.iridescence.texture),v.iridescence.thicknessTexture&&v.iridescence.thicknessTexture!==v.iridescence.texture&&P.push(v.iridescence.thicknessTexture),P):[]}postExportMaterialAsync(e,d,v){return new Promise((e=>{if(v instanceof Wd.e){if(!v.iridescence.isEnabled)return void e(d);this._wasUsed=!0,d.extensions=d.extensions||{};const P=this._exporter._materialExporter.getTextureInfo(v.iridescence.texture),p=this._exporter._materialExporter.getTextureInfo(v.iridescence.thicknessTexture),L={iridescenceFactor:v.iridescence.nX,iridescenceIor:v.iridescence.indexOfRefraction,iridescenceThicknessMinimum:v.iridescence.minimumThickness,iridescenceThicknessMaximum:v.iridescence.maximumThickness,iridescenceTexture:P??void 0,iridescenceThicknessTexture:p??void 0};null===L.iridescenceTexture&&null===L.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(v),d.extensions[Ad]=L}e(d)}))}}te.RegisterExtension(Ad,(e=>new xd(e)));const id="KHR_materials_sheen";class mv{constructor(e){this.name=id,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,d,v){return v instanceof we.e&&v.sheen.isEnabled&&v.sheen.texture?[v.sheen.texture]:[]}async postExportMaterialAsync(e,d,v){return await new Promise((e=>{if(v instanceof we.e){if(!v.sheen.isEnabled)return void e(d);this._wasUsed=!0,null==d.extensions&&(d.extensions={});const P={sheenColorFactor:v.sheen.color.Yd(),sheenRoughnessFactor:v.sheen.roughness??0};null===P.sheenColorTexture&&null===P.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(v),v.sheen.texture&&(P.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(v.sheen.texture)??void 0),v.sheen.textureRoughness&&!v.sheen.useRoughnessFromMainTexture?P.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(v.sheen.textureRoughness)??void 0:v.sheen.texture&&v.sheen.useRoughnessFromMainTexture&&(P.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(v.sheen.texture)??void 0),d.extensions[id]=P}e(d)}))}}te.RegisterExtension(id,(e=>new mv(e)));const rd="KHR_materials_specular";class Zd{constructor(e){this.name=rd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,d,v){const P=[];return v instanceof we.e&&this._isExtensionEnabled(v)?(v.metallicReflectanceTexture&&P.push(v.metallicReflectanceTexture),v.reflectanceTexture&&P.push(v.reflectanceTexture),P):P}_isExtensionEnabled(e){return!e.unlit&&(void 0!=e.metallicF0Factor&&1!=e.metallicF0Factor||void 0!=e.metallicReflectanceColor&&!e.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(e))}_hasTexturesExtension(e){return null!=e.metallicReflectanceTexture||null!=e.reflectanceTexture}postExportMaterialAsync(e,d,v){return new Promise((e=>{if(v instanceof we.e&&this._isExtensionEnabled(v)){this._wasUsed=!0,d.extensions=d.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(v.metallicReflectanceTexture)??void 0,P=this._exporter._materialExporter.getTextureInfo(v.reflectanceTexture)??void 0,p={specularFactor:1==v.metallicF0Factor?void 0:v.metallicF0Factor,specularTexture:e,specularColorFactor:v.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:v.metallicReflectanceColor.Yd(),specularColorTexture:P};this._hasTexturesExtension(v)&&this._exporter._materialNeedsUVsSet.add(v),d.extensions[rd]=p}e(d)}))}}te.RegisterExtension(rd,(e=>new Zd(e)));const fd="KHR_materials_transmission";class Td{constructor(e){this.name=fd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,d,v){const P=[];return v instanceof we.e&&this._isExtensionEnabled(v)?(v.subSurface.thicknessTexture&&P.push(v.subSurface.thicknessTexture),P):P}_isExtensionEnabled(e){if(e.unlit)return!1;const d=e.subSurface;return d.isRefractionEnabled&&void 0!=d.refractionIntensity&&0!=d.refractionIntensity||this._hasTexturesExtension(e)}_hasTexturesExtension(e){return null!=e.subSurface.refractionIntensityTexture}async postExportMaterialAsync(e,d,v){if(v instanceof we.e&&this._isExtensionEnabled(v)){this._wasUsed=!0;const P=v.subSurface,p={transmissionFactor:0===P.refractionIntensity?void 0:P.refractionIntensity};if(this._hasTexturesExtension(v)&&this._exporter._materialNeedsUVsSet.add(v),P.refractionIntensityTexture)if(P.useGltfStyleTextures){const e=await this._exporter._materialExporter.exportTextureAsync(P.refractionIntensityTexture,"image/png");e&&(p.transmissionTexture=e)}else O.c.Warn(`${e}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);d.extensions||(d.extensions={}),d.extensions[fd]=p}return d}}te.RegisterExtension(fd,(e=>new Td(e)));const Sd="KHR_materials_unlit";class od{constructor(){this.name=Sd,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(e,d,v){return new Promise((e=>{let P=!1;v instanceof we.e?P=v.unlit:v instanceof Ge.Sd&&(P=v.disableLighting),P&&(this._wasUsed=!0,null==d.extensions&&(d.extensions={}),d.extensions[Sd]={}),e(d)}))}}te.RegisterExtension(Sd,(()=>new od));const Kd="KHR_materials_volume";class Qd{constructor(e){this.name=Kd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,d,v){const P=[];return v instanceof we.e&&this._isExtensionEnabled(v)?(v.subSurface.thicknessTexture&&P.push(v.subSurface.thicknessTexture),P):P}_isExtensionEnabled(e){if(e.unlit)return!1;const d=e.subSurface;return!(!d.isRefractionEnabled&&!d.isTranslucencyEnabled)&&(void 0!=d.maximumThickness&&0!=d.maximumThickness||void 0!=d.tintColorAtDistance&&d.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=d.tintColor&&d.tintColor!=U.Kd.White()||this._hasTexturesExtension(e))}_hasTexturesExtension(e){return null!=e.subSurface.thicknessTexture}postExportMaterialAsync(e,d,v){return new Promise((e=>{if(v instanceof we.e&&this._isExtensionEnabled(v)){this._wasUsed=!0;const e=v.subSurface,P={thicknessFactor:0==e.maximumThickness?void 0:e.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(e.thicknessTexture)??void 0,attenuationDistance:e.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:e.tintColorAtDistance,attenuationColor:e.tintColor.equalsFloats(1,1,1)?void 0:e.tintColor.Yd()};this._hasTexturesExtension(v)&&this._exporter._materialNeedsUVsSet.add(v),d.extensions=d.extensions||{},d.extensions[Kd]=P}e(d)}))}}te.RegisterExtension(Kd,(e=>new Qd(e)));const Nd="EXT_materials_diffuse_roughness";class ud{constructor(e){this.name=Nd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,d,v){const P=[];return v instanceof Wd.e&&v._baseDiffuseRoughness?(v._baseDiffuseRoughnessTexture&&P.push(v._baseDiffuseRoughnessTexture),P):[]}postExportMaterialAsync(e,d,v){return new Promise((e=>{if(v instanceof Wd.e){if(!v._baseDiffuseRoughness)return void e(d);this._wasUsed=!0,d.extensions=d.extensions||{};const P=this._exporter._materialExporter.getTextureInfo(v._baseDiffuseRoughnessTexture),p={diffuseRoughnessFactor:v._baseDiffuseRoughness,diffuseRoughnessTexture:P??void 0};null!==p.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(v),d.extensions[Nd]=p}e(d)}))}}te.RegisterExtension(Nd,(e=>new ud(e)));const Od="KHR_texture_transform";class Rd{constructor(){this.name=Od,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(e,d,v){if(v.Ae()||p.Tools.Warn(`${e}: /*@__KEY__*/"scene" is not defined for Babylon texture ${v.name}!`),(0!==v.uAng||0!==v.vAng)&&(p.Tools.Warn(`${e}: Texture ${v.name} with rotation in the u or v axis is not supported in glTF.`),0!==v.uRotationCenter||0!==v.vRotationCenter))return;const P={};let L=!1;if(0===v.uOffset&&0===v.vOffset||(P.offset=[v.uOffset,v.vOffset],L=!0),1===v.uScale&&1===v.vScale||(P.scale=[v.uScale,v.vScale],L=!0),0!==v.wAng){if(0!==v.uRotationCenter||0!==v.vRotationCenter){if(v.homogeneousRotationInUVTransform&&v.uScale!==v.vScale)return void p.Tools.Warn(`${e}: Texture ${v.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Od}.`);p.Tools.Warn(`${e}: Texture ${v.name} with non-origin rotation center will be exported using an adjusted offset with ${Od}.`),P.offset=function(e){const{uOffset:d,vOffset:v,uRotationCenter:P,vRotationCenter:p,uScale:L,vScale:B,wAng:X}=e,z=Math.cos(X),W=Math.sin(X),V=P*L,k=p*B;return[d+(V*(1-z)+k*W),v+(k*(1-z)-V*W)]}(v)}P.rotation=-v.wAng,L=!0}0!==v.coordinatesIndex&&(P.texCoord=v.coordinatesIndex,L=!0),L&&(this._wasUsed=!0,d.extensions||(d.extensions={}),d.extensions[Od]=P)}}te.RegisterExtension(Od,(()=>new Rd));class Yd{static CreateSTL(e){let d=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",p=arguments.length>3&&void 0!==arguments[3]&&arguments[3],L=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],B=arguments.length>5&&void 0!==arguments[5]&&arguments[5],X=arguments.length>6&&void 0!==arguments[6]&&arguments[6],z=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const W=function(e,d,v){const p=[3*e[v],3*e[v+1],3*e[v+2]],L=[new P.mv(d[p[0]],d[p[0]+2],d[p[0]+1]),new P.mv(d[p[1]],d[p[1]+2],d[p[1]+1]),new P.mv(d[p[2]],d[p[2]+2],d[p[2]+1])],B=L[0].Zd(L[1]),X=L[2].Zd(L[1]);return{v:L,n:P.mv.Cross(X,B).normalize()}},k=function(e,d,v,P){return d=g(e,d,v.x,P),d=g(e,d,v.y,P),g(e,d,v.z,P)},g=function(e,d,v,P){return e.setFloat32(d,v,P),d+4},w=function(e){if(X){let d=e;e instanceof F.e&&(d=e.sourceMesh);const v=d.getVerticesData(V.i.PositionKind,!0,!0);if(!v)return[];const p=P.mv.Zero();let L;for(L=0;L<v.length;L+=3)P.mv.TransformCoordinatesFromFloatsToRef(v[L],v[L+1],v[L+2],e.Md(!0),p).toArray(v,L);return v}return e.getVerticesData(V.i.PositionKind)||[]};X&&(B=!0);let G="",U=0,D=0;if(p){for(let v=0;v<e.length;v++){const d=e[v].yd();U+=d?d.length/3:0}const d=new ArrayBuffer(84+50*U);G=new DataView(d),D+=80,G.setUint32(D,U,L),D+=4}else z||(G="solid stlmesh\r\n");for(let P=0;P<e.length;P++){const d=e[P];!p&&z&&(G+="solid "+d.name+"\r\n"),!B&&d instanceof Ce.b&&d.bakeCurrentTransformIntoVertices();const v=w(d),X=d.yd()||[];for(let e=0;e<X.length;e+=3){const d=W(X,v,e);p?(D=k(G,D,d.n,L),D=k(G,D,d.v[0],L),D=k(G,D,d.v[1],L),D=k(G,D,d.v[2],L),D+=2):(G+="\tfacet normal "+d.n.x+" "+d.n.y+" "+d.n.z+"\r\n",G+="\t\touter loop\r\n",G+="\t\t\tvertex "+d.v[0].x+" "+d.v[0].y+" "+d.v[0].z+"\r\n",G+="\t\t\tvertex "+d.v[1].x+" "+d.v[1].y+" "+d.v[1].z+"\r\n",G+="\t\t\tvertex "+d.v[2].x+" "+d.v[2].y+" "+d.v[2].z+"\r\n",G+="\t\tendloop\r\n",G+="\tendfacet\r\n")}!p&&z&&(G+="endsolid "+name+"\r\n")}if(p||z||(G+="endsolid stlmesh"),d){const e=document.createElement("a"),d=new Blob([G],{type:"application/octet-stream"});e.href=window.URL.createObjectURL(d),e.download=v+".stl",e.click()}return G}}function Hd(e,d){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const P=[];for(let p=0;p<e.length/v;p++){const L=e[p*v],B=e[p*v+1],X=e[p*v+2];P.push(`(${L.toPrecision(d.precision)}, ${B.toPrecision(d.precision)}, ${X.toPrecision(d.precision)})`)}return P.join(", ")}function ad(e,d){const v=[];for(let P=0;P<e.length/2;P++){const p=e[2*P],L=e[2*P+1];v.push(`(${p.toPrecision(d.precision)}, ${(1-L).toPrecision(d.precision)})`)}return v.join(", ")}function td(e,d){const v=e.getVerticesData(V.i.PositionKind),P=e.getVerticesData(V.i.NormalKind);if(v&&P)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(e){var d;const v=null!==(d=e.yd())&&void 0!==d&&d.length?e.getTotalIndices():e.getTotalVertices();return Array(v/3).fill(3).join(", ")}(e)}]\n\t\tint[] faceVertexIndices = [${function(e){const d=e.yd(),v=[];if(null!==d)for(let P=0;P<d.length;P++)v.push(d[P]);else{const d=e.getTotalVertices();for(let e=0;e<d;e++)v.push(e)}return v.join(", ")}(e)}]\n\t\tnormal3f[] normals = [${Hd(P,d)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Hd(v,d)}]\n        ${function(e,d){let v="";for(let p=0;p<4;p++){const P=p>0?p:"",L=e.getVerticesData(V.i.UVKind+(P?P+1:""));L&&(v+=`\n\t\ttexCoord2f[] primvars:st${P} = [${ad(L,d)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const P=e.getVerticesData(V.i.ColorKind);return P&&(v+=`\n\tcolor3f[] primvars:displayColor = [${Hd(P,d,P.length/e.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),v}(e,d)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Id(e,d){return`\n        def "Geometry"\n        {\n        ${td(e,d)}\n        }\n        `}function cd(e){let d='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return d+=e,fflate.strToU8(d)}function bd(e){const d=e.m;return`( ${Md(d,0)}, ${Md(d,4)}, ${Md(d,8)}, ${Md(d,12)} )`}function Md(e,d){return`(${e[d+0]}, ${e[d+1]}, ${e[d+2]}, ${e[d+3]})`}function sd(e){const d="Object_"+e.uniqueId,v=function(e){const d=e.getWorldMatrix().clone(),v=e.Ae().useRightHandedSystem;if(!v){let P=e.parent;for(;P;){if(Be(P,v)){d.multiplyToRef(P.getWorldMatrix().invert(),d);break}P=P.parent}}return d.determinant()<0&&p.Tools.Warn(`Exporting mesh ${e.name} with negative scale. Result may look incorrect in destination engine.`),d}(e),P=bd(v);return`def Xform "${d}" (\n\tprepend references = @./geometries/Geometry_${e.sd.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${P}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${e.material.uniqueId}>\n}\n\n`}function yd(e){switch(e){case A.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case A.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case A.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function jd(e){return`(${e.x}, ${e.y})`}function Jd(e){return`(${e.r}, ${e.g}, ${e.b})`}function Ed(e,d,v,p,L,B){const X=e.getInternalTexture().uniqueId+"_"+e.invertY;L[X]=e;const z=e.coordinatesIndex>0?"st"+e.coordinatesIndex:"st",W=new P.Vector2(e.uScale,e.vScale),V=new P.Vector2(e.uOffset,e.vOffset),k=e.wAng,g=Math.sin(k),F=Math.cos(k);return V.y=1-V.y-W.y,V.x+=g*W.x,V.y+=(1-F)*W.y,`\n    def Shader "PrimvarReader_${v}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${z}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${v}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${d.uniqueId}/PrimvarReader_${v}.outputs:result>\n        float inputs:rotation = ${(k*(180/Math.PI)).toFixed(B.precision)}\n        float2 inputs:scale = ${jd(W)}\n        float2 inputs:translation = ${jd(V)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${e.uniqueId}_${v}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${X}.png@\n        float2 inputs:st.connect = </Materials/Material_${d.uniqueId}/Transform2d_${v}.outputs:result>\n        ${p?"float4 inputs:scale = "+function(e){return`(${e.r}, ${e.g}, ${e.b}, 1.0)`}(p):""}\n        token inputs:sourceColorSpace = "${e.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${yd(e.wrapU)}"\n        token inputs:wrapT = "${yd(e.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${d.needAlphaBlending()?"float outputs:a":""}\n    }`}function ev(e,d,v){const P="\t\t\t",p=[],L=[],{diffuseMap:B,AX:X,alphaCutOff:z,emissiveMap:W,emissive:V,normalMap:k,roughnessMap:g,roughnessChannel:F,roughness:w,metalnessMap:G,metalnessChannel:D,metalness:C,aoMap:q,aoMapChannel:h,aoMapIntensity:l,alphaMap:n,ior:A,clearCoatEnabled:x,clearCoat:i,clearCoatMap:me,clearCoatRoughness:r,clearCoatRoughnessMap:Z}=function(e){const d={diffuseMap:null,AX:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return e instanceof Ge.Sd?{...d,diffuseMap:e.diffuseTexture,AX:e.diffuseColor,alphaCutOff:e.alphaCutOff,emissiveMap:e.emissiveTexture,emissive:e.emissiveColor,roughness:1,alphaMap:e.opacityTexture}:e instanceof Wd.e?{...d,diffuseMap:e._albedoTexture,AX:e._albedoColor,alphaCutOff:e._alphaCutOff,emissiveMap:e._emissiveTexture,emissive:e._emissiveColor,normalMap:e._bumpTexture,roughnessMap:e._metallicTexture,roughnessChannel:e._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:e._roughness??1,metalnessMap:e._metallicTexture,metalnessChannel:e._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:e._metallic??0,aoMap:e._ambientTexture,aoMapChannel:e._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:e._ambientTextureStrength,alphaMap:e._opacityTexture,ior:e.subSurface.indexOfRefraction,clearCoatEnabled:e.clearCoat.isEnabled,clearCoat:e.clearCoat.nX,clearCoatMap:e.clearCoat.texture,clearCoatRoughness:e.clearCoat.roughness,clearCoatRoughnessMap:e.clearCoat.useRoughnessFromMainTexture?e.clearCoat.texture:e.clearCoat.textureRoughness}:d}(e);return null!==B?(p.push(`${P}color3f inputs:diffuseColor.connect = </Materials/Material_${e.uniqueId}/Texture_${B.uniqueId}_diffuse.outputs:rgb>`),e.needAlphaBlending()?p.push(`${P}float inputs:opacity.connect = </Materials/Material_${e.uniqueId}/Texture_${B.uniqueId}_diffuse.outputs:a>`):e.needAlphaTesting()&&(p.push(`${P}float inputs:opacity.connect = </Materials/Material_${e.uniqueId}/Texture_${B.uniqueId}_diffuse.outputs:a>`),p.push(`${P}float inputs:opacityThreshold = ${z}`)),L.push(Ed(B,e,"diffuse",X,d,v))):p.push(`${P}color3f inputs:diffuseColor = ${Jd(X||U.Kd.White())}`),null!==W?(p.push(`${P}color3f inputs:emissiveColor.connect = </Materials/Material_${e.uniqueId}/Texture_${W.uniqueId}_emissive.outputs:rgb>`),L.push(Ed(W,e,"emissive",V,d,v))):V&&V.toLuminance()>0&&p.push(`${P}color3f inputs:emissiveColor = ${Jd(V)}`),null!==k&&(p.push(`${P}normal3f inputs:normal.connect = </Materials/Material_${e.uniqueId}/Texture_${k.uniqueId}_normal.outputs:rgb>`),L.push(Ed(k,e,"normal",null,d,v))),null!==q&&(p.push(`${P}float inputs:occlusion.connect = </Materials/Material_${e.uniqueId}/Texture_${q.uniqueId}_occlusion.outputs:${h}>`),L.push(Ed(q,e,"occlusion",new U.Kd(l,l,l),d,v))),null!==g?(p.push(`${P}float inputs:roughness.connect = </Materials/Material_${e.uniqueId}/Texture_${g.uniqueId}_roughness.outputs:${F}>`),L.push(Ed(g,e,"roughness",new U.Kd(w,w,w),d,v))):p.push(`${P}float inputs:roughness = ${w}`),null!==G?(p.push(`${P}float inputs:metallic.connect = </Materials/Material_${e.uniqueId}/Texture_${G.uniqueId}_metallic.outputs:${D}>`),L.push(Ed(G,e,"metallic",new U.Kd(C,C,C),d,v))):p.push(`${P}float inputs:metallic = ${C}`),null!==n?(p.push(`${P}float inputs:opacity.connect = </Materials/Material_${e.uniqueId}/Texture_${n.uniqueId}_opacity.outputs:r>`),p.push(`${P}float inputs:opacityThreshold = 0.0001`),L.push(Ed(n,e,"opacity",null,d,v))):p.push(`${P}float inputs:opacity = ${e.alpha}`),x&&(null!==me?(p.push(`${P}float inputs:clearcoat.connect = </Materials/Material_${e.uniqueId}/Texture_${me.uniqueId}_clearcoat.outputs:r>`),L.push(Ed(me,e,"clearcoat",new U.Kd(i,i,i),d,v))):p.push(`${P}float inputs:clearcoat = ${i}`),null!==Z?(p.push(`${P}float inputs:clearcoatRoughness.connect = </Materials/Material_${e.uniqueId}/Texture_${Z.uniqueId}_clearcoatRoughness.outputs:g>`),L.push(Ed(Z,e,"clearcoatRoughness",new U.Kd(r,r,r),d,v))):p.push(`${P}float inputs:clearcoatRoughness = ${r}`)),p.push(`${P}float inputs:ior = ${A}`),`\n\tdef Material "Material_${e.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${p.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${e.uniqueId}/PreviewSurface.outputs:surface>\n\n${L.join("\n")}\n\n\t}\n`}async function dv(e,d,v){const L={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...d};"undefined"===typeof fflate&&await p.Tools.LoadScriptAsync(L.fflateUrl);const B={};B[L.modelFileName]=null;let X='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';X+=function(e){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===e.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${e.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${e.planeAnchoringAlignment}"`:""}\n            `}(L);const z={};for(const P of e.meshes){if(0===P.getTotalVertices())continue;const e=P,d=e.sd,W=e.material;if(!W||!d||v&&!v(e))continue;if(-1!==["Sd","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(W.getClassName())){const v="geometries/Geometry_"+d.uniqueId+".usda";if(!(v in B)){const e=Id(d,L);B[v]=cd(e)}W.uniqueId in z||(z[W.uniqueId]=W),X+=sd(e)}else p.Tools.Warn("USDZExportAsync does not support this material type: "+W.getClassName())}e.activeCamera&&L.exportCamera&&(X+=function(e,d){const v="Camera_"+e.uniqueId,p=bd(P.Matrix.RotationY(Math.PI).multiply(e.getWorldMatrix()));if(e.mode===A.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${v}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${p}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${e.td.toPrecision(d.precision)}, ${e.maxZ.toPrecision(d.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(e.orthoLeft||1)+Math.abs(e.orthoRight||1))).toPrecision(d.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(e.orthoTop||1)+Math.abs(e.orthoBottom||1))).toPrecision(d.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const P=e.getEngine().getAspectRatio(e),L=d.cameraSensorWidth||35;return`def Camera "${v}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${p}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${e.td.toPrecision(d.precision)}, ${e.maxZ.toPrecision(d.precision)})\n\t\t\tfloat focalLength = ${(L/(2*Math.tan(.5*e.fov))).toPrecision(d.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(L*P).toPrecision(d.precision)}\n\t\t\tfloat verticalAperture = ${(L/P).toPrecision(d.precision)}            \n\t\t}\n\t\n\t`}}(e.activeCamera,L)),X+="\n            }\n        }\n    }";const W={};X+=function(e,d,v){const P=[];for(const p in e){const L=e[p];P.push(ev(L,d,v))}return`\n    def "Materials"\n{\n${P.join("")}\n}\n\n`}(z,W,L),B[L.modelFileName]=fflate.strToU8(X);for(const P in W){const e=W[P],d=e.getSize(),v=await e.readPixels();if(!v)throw new Error("Texture data is not available");const p=await x.DumpTools.DumpDataAsync(d.width,d.height,v,"image/png",void 0,!1,!0);B[`textures/Texture_${P}.png`]=new Uint8Array(p).slice()}let V=0;for(const P in B){const e=B[P];if(!e)continue;V+=34+P.length;const d=63&V;if(4!==d){const v=new Uint8Array(64-d);B[P]=[e,{extra:{12345:v}}]}V=e.length}return fflate.zipSync(B,{level:0})}}}]);