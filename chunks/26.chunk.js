"use strict";(self.xeuzlpp225k=self.xeuzlpp225k||[]).push([[26],{11695:(k,Q,i)=>{i.r(Q),i.d(Q,{EXT_materials_diffuse_roughness:()=>DQ,EXT_mesh_gpu_instancing:()=>Pk,GLTF2Export:()=>Sk,GLTFData:()=>O,KHR_draco_mesh_compression:()=>iQ,KHR_lights_punctual:()=>mQ,KHR_materials_anisotropy:()=>GQ,KHR_materials_clearcoat:()=>eQ,KHR_materials_diffuse_transmission:()=>EQ,KHR_materials_dispersion:()=>hQ,KHR_materials_emissive_strength:()=>fQ,KHR_materials_ior:()=>yQ,KHR_materials_iridescence:()=>sQ,KHR_materials_sheen:()=>aQ,KHR_materials_specular:()=>TQ,KHR_materials_transmission:()=>vQ,KHR_materials_unlit:()=>XQ,KHR_materials_volume:()=>dQ,KHR_texture_transform:()=>WQ,OBJExport:()=>B,STLExport:()=>AQ,USDZExportAsync:()=>Qi,_ConvertToGLTFPBRMetallicRoughness:()=>N,_SolveMetallic:()=>v,__IGLTFExporterExtension:()=>o});var Z=i(11298),U=i(11119),C=i(11615);class B{static OBJ(k,Q,i,B){const o=[];let m=1,O=1;Q&&(i||(i="mat"),o.push("mtllib "+i+".mtl"));for(let J=0;J<k.length;J++){const i=k[J],G=i.name||`mesh${J}}`;o.push(`o ${G}`);let H=null;if(B){const k=i.oo(!0);H=new Z.Matrix,k.invertToRef(H),i.bakeTransformIntoVertices(k)}if(Q){const k=i.material;k&&o.push("usemtl "+k.id)}const e=i.mo;if(!e){U.Tools.Warn("No geometry is present on the mesh");continue}const F=e.getVerticesData("position"),z=e.getVerticesData("normal"),E=e.getVerticesData("uv"),l=e.Oo();let h=0,c=0;if(!F||!l){U.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const f=k[0].sk().useRightHandedSystem?1:-1;for(let k=0;k<F.length;k+=3)o.push("v "+F[k]*f+" "+F[k+1]+" "+F[k+2]),h++;if(null!=z)for(let k=0;k<z.length;k+=3)o.push("vn "+z[k]*f+" "+z[k+1]+" "+z[k+2]);if(null!=E)for(let k=0;k<E.length;k+=2)o.push("vt "+E[k]+" "+E[k+1]),c++;const Y=["","",""],y=(i.material||i.sk().defaultMaterial)._getEffectiveOrientation(i),[L,s]=y===C.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let k=0;k<l.length;k+=3){const Q=[String(l[k]+m),String(l[k+L]+m),String(l[k+s]+m)],i=[String(l[k]+O),String(l[k+L]+O),String(l[k+s]+O)],Z=Q,U=null!=E?i:Y,C=null!=z?Q:Y;o.push("f "+Z[0]+"/"+U[0]+"/"+C[0]+" "+Z[1]+"/"+U[1]+"/"+C[1]+" "+Z[2]+"/"+U[2]+"/"+C[2])}B&&H&&i.bakeTransformIntoVertices(H),m+=h,O+=c}return o.join("\n")}static MTL(k){const Q=[],i=k.material;Q.push("newmtl mat1"),Q.push("  Ns "+i.specularPower.toFixed(4)),Q.push("  Ni 1.5000"),Q.push("  d "+i.alpha.toFixed(4)),Q.push("  Tr 0.0000"),Q.push("  Tf 1.0000 1.0000 1.0000"),Q.push("  illum 2"),Q.push("  Ka "+i.ambientColor.r.toFixed(4)+" "+i.ambientColor.g.toFixed(4)+" "+i.ambientColor.b.toFixed(4)),Q.push("  Kd "+i.diffuseColor.r.toFixed(4)+" "+i.diffuseColor.g.toFixed(4)+" "+i.diffuseColor.b.toFixed(4)),Q.push("  Ks "+i.specularColor.r.toFixed(4)+" "+i.specularColor.g.toFixed(4)+" "+i.specularColor.b.toFixed(4)),Q.push("  Ke "+i.emissiveColor.r.toFixed(4)+" "+i.emissiveColor.g.toFixed(4)+" "+i.emissiveColor.b.toFixed(4));i.ambientTexture&&Q.push("  map_Ka "+i.ambientTexture.name),i.diffuseTexture&&Q.push("  map_Kd "+i.diffuseTexture.name),i.specularTexture&&Q.push("  map_Ks "+i.specularTexture.name),i.bumpTexture&&Q.push("  map_bump -imfchan z "+i.bumpTexture.name),i.opacityTexture&&Q.push("  map_d "+i.opacityTexture.name);return Q.join("\n")}}var o=0,m=i(11163);class O{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const k in this.files){const Q=this.files[k],i=new Blob([Q],{type:(0,m.j)(k)});U.Tools.Download(i,k)}}}var J=i(11378),G=i(11702),H=i(11712),e=i(11732),F=i(11428),z=i(11157),E=i(11348),l=i(11311);const h=l.HighestCommonFactor,c={...l,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:h};var f=i(11529),Y=i(11273),y=i(11759),L=i(11761),s=i(11522);const u=1e-6,a=new E.cQ(.04,.04,.04),j=1024,T=E.cQ.White(),K=E.cQ.Black();function v(k,Q,i){if(Q<a.r)return 0;const Z=a.r,U=k*i/(1-a.r)+Q-2*a.r,C=U*U-4*Z*(a.r-Q);return c.Clamp((-U+Math.sqrt(C))/(2*Z),0,1)}function N(k){const Q=k.diffuseColor.toLinearSpace(k.sk().getEngine().useExactSrgbConversions).scale(.5),i=k.alpha,U=function(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Z.Vector2(0,1),i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Z.Vector2(0,.1),U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Z.Vector2(0,.1),C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new Z.Vector2(1300,.1);return function(k,Q,i,Z,U){return(1-k)*(1-k)*(1-k)*Q+3*(1-k)*(1-k)*k*i+3*(1-k)*k*k*Z+k*k*k*U}(Math.pow(k/C.x,.333333),Q.y,i.y,U.y,C.y)}(c.Clamp(k.specularPower,0,j));return{baseColorFactor:[Q.r,Q.g,Q.b,i],metallicFactor:0,roughnessFactor:U}}function X(k,Q){Q.needAlphaBlending()?k.alphaMode="BLEND":Q.needAlphaTesting()&&(k.alphaMode="MASK",k.alphaCutoff=Q.alphaCutOff)}function p(k,Q,i){const Z=new Uint8Array(k*Q*4);for(let U=0;U<Z.length;U+=4)Z[U]=Z[U+1]=Z[U+2]=Z[U+3]=255;return y.c.CreateRGBATexture(Z,k,Q,i)}function d(k){if(k instanceof Uint8Array){const Q=k.length,i=new Float32Array(k.length);for(let Z=0;Z<Q;++Z)i[Z]=k[Z]/255;return i}if(k instanceof Float32Array)return k;throw new Error("Unsupported pixel format!")}class b{constructor(k){this._exporter=k,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(k){return k?this._textureMap.get(k)??null:null}async exportStandardMaterialAsync(k,Q,i){const Z=N(k),C={name:k.name};if(null==k.Jo||k.Jo||(k.twoSidedLighting||U.Tools.Warn(k.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),C.doubleSided=!0),i){const i=[],U=k.diffuseTexture;U&&i.push(this.exportTextureAsync(U,Q).then((k=>{k&&(Z.baseColorTexture=k)})));const B=k.bumpTexture;B&&i.push(this.exportTextureAsync(B,Q).then((k=>{k&&(C.normalTexture=k,1!==B.level&&(C.normalTexture.scale=B.level))})));const o=k.emissiveTexture;o&&(C.emissiveFactor=[1,1,1],i.push(this.exportTextureAsync(o,Q).then((k=>{k&&(C.emissiveTexture=k)}))));const m=k.ambientTexture;m&&i.push(this.exportTextureAsync(m,Q).then((k=>{if(k){const Q={index:k.index};C.occlusionTexture=Q}}))),i.length>0&&(this._exporter._materialNeedsUVsSet.add(k),await Promise.all(i))}(k.alpha<1||k.opacityTexture)&&(k.alphaMode===L.c.ALPHA_COMBINE?C.alphaMode="BLEND":U.Tools.Warn(k.name+": glTF 2.0 does not support alpha mode: "+k.alphaMode.toString())),k.emissiveColor&&!k.emissiveColor.equalsWithEpsilon(K,u)&&(C.emissiveFactor=k.emissiveColor.Zo()),C.pbrMetallicRoughness=Z,X(C,k),await this._finishMaterialAsync(C,k,Q);const B=this._exporter._materials;return B.push(C),B.length-1}async _finishMaterialAsync(k,Q,i){const Z=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",k,Q),U=[];for(const C of Z)U.push(this.exportTextureAsync(C,i));await Promise.all(U),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",k,Q)}async _getImageDataAsync(k,Q,Z,U){const C=L.c.TEXTURETYPE_UNSIGNED_BYTE,B=this._exporter._babylonScene,o=B.getEngine(),m=o.createRawTexture(k,Q,Z,L.c.TEXTUREFORMAT_RGBA,!1,!0,Y.c.NEAREST_SAMPLINGMODE,null,C);o.isWebGPU?await i.e(51).then(i.bind(i,13845)):await i.e(52).then(i.bind(i,13852)),await f.m.ApplyPostProcess("pass",m,B,C,L.c.TEXTURE_NEAREST_SAMPLINGMODE,L.c.TEXTUREFORMAT_RGBA);const O=await o._readTexturePixels(m,Q,Z);return await s.DumpTools.DumpDataAsync(Q,Z,O,U,void 0,!0,!0)}_resizeTexturesToSameDimensions(k,Q,i){const Z=k?k.getSize():{width:0,height:0},U=Q?Q.getSize():{width:0,height:0};let C,B;return Z.width<U.width?(C=k&&k instanceof Y.c?f.m.CreateResizedCopy(k,U.width,U.height,!0):p(U.width,U.height,i),B=Q):Z.width>U.width?(B=Q&&Q instanceof Y.c?f.m.CreateResizedCopy(Q,Z.width,Z.height,!0):p(Z.width,Z.height,i),C=k):(C=k,B=Q),{texture1:C,texture2:B}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(k,Q,i,Z){const U=new Array;if(!k&&!Q)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const C=k?k.sk():Q?Q.sk():null;if(C){var B;const o=this._resizeTexturesToSameDimensions(k,Q,C),m=null===(B=o.texture1)||void 0===B?void 0:B.getSize();let O,J;const G=m.width,H=m.height,e=await o.texture1.readPixels(),F=await o.texture2.readPixels();if(!e)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(O=d(e),!F)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");J=d(F);const z=J.byteLength,l=new Uint8Array(z),h=new Uint8Array(z),c=4,f=K;let Y=0,y=0;for(let k=0;k<H;++k)for(let Q=0;Q<G;++Q){const Z=(G*k+Q)*c,U={diffuseColor:new E.cQ(O[Z],O[Z+1],O[Z+2]).toLinearSpace(C.getEngine().useExactSrgbConversions).multiply(i.diffuseColor),specularColor:new E.cQ(J[Z],J[Z+1],J[Z+2]).toLinearSpace(C.getEngine().useExactSrgbConversions).multiply(i.specularColor),glossiness:J[Z+3]*i.glossiness},B=this._convertSpecularGlossinessToMetallicRoughness(U);f.r=Math.max(f.r,B.baseColor.r),f.g=Math.max(f.g,B.baseColor.g),f.b=Math.max(f.b,B.baseColor.b),Y=Math.max(Y,B.metallic),y=Math.max(y,B.roughness),h[Z]=255*B.baseColor.r,h[Z+1]=255*B.baseColor.g,h[Z+2]=255*B.baseColor.b,h[Z+3]=o.texture1.Uo?255*O[Z+3]:255,l[Z]=0,l[Z+1]=255*B.roughness,l[Z+2]=255*B.metallic,l[Z+3]=255}const L={baseColor:f,metallic:Y,roughness:y};let s=!1,a=!1;for(let k=0;k<H;++k)for(let Q=0;Q<G;++Q){const i=(G*k+Q)*c;h[i]/=L.baseColor.r>u?L.baseColor.r:1,h[i+1]/=L.baseColor.g>u?L.baseColor.g:1,h[i+2]/=L.baseColor.b>u?L.baseColor.b:1;const Z=E.cQ.FromInts(h[i],h[i+1],h[i+2]).toGammaSpace(C.getEngine().useExactSrgbConversions);h[i]=255*Z.r,h[i+1]=255*Z.g,h[i+2]=255*Z.b,Z.equalsWithEpsilon(T,u)||(a=!0),l[i+1]/=L.roughness>u?L.roughness:1,l[i+2]/=L.metallic>u?L.metallic:1;E.cQ.FromInts(255,l[i+1],l[i+2]).equalsWithEpsilon(T,u)||(s=!0)}return s&&U.push(this._getImageDataAsync(l,G,H,Z).then((k=>{L.metallicRoughnessTextureData=k}))),a&&U.push(this._getImageDataAsync(h,G,H,Z).then((k=>{L.baseColorTextureData=k}))),await Promise.all(U).then((()=>L))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(k){const Q=this._getPerceivedBrightness(k.diffuseColor),i=this._getPerceivedBrightness(k.specularColor),Z=1-this._getMaxComponent(k.specularColor),U=v(Q,i,Z),C=k.diffuseColor.scale(Z/(1-a.r)/Math.max(1-U)),B=k.specularColor.EQ(a.scale(1-U)).scale(1/Math.max(U));let o=E.cQ.Lerp(C,B,U*U);o=o.clampToRef(0,1,o);return{baseColor:o,metallic:U,roughness:1-k.glossiness}}_getPerceivedBrightness(k){return k?Math.sqrt(.299*k.r*k.r+.587*k.g*k.g+.114*k.b*k.b):0}_getMaxComponent(k){return k?Math.max(k.r,Math.max(k.g,k.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(k,Q,i,Z){const U=[],C={baseColor:k._albedoColor,metallic:k._metallic,roughness:k._roughness};if(Z){k._albedoTexture&&U.push(this.exportTextureAsync(k._albedoTexture,Q).then((k=>{k&&(i.baseColorTexture=k)})));const Z=k._metallicTexture;Z&&U.push(this.exportTextureAsync(Z,Q).then((k=>{k&&(i.metallicRoughnessTexture=k)})))}return U.length>0&&(this._exporter._materialNeedsUVsSet.add(k),await Promise.all(U)),C}_getTextureSampler(k){const Q={};if(!k||!(k instanceof Y.c))return Q;const i=this._getGLTFTextureWrapMode(k.wrapU);10497!==i&&(Q.wrapS=i);const Z=this._getGLTFTextureWrapMode(k.wrapV);switch(10497!==Z&&(Q.wrapT=Z),k.samplingMode){case Y.c.LINEAR_LINEAR:Q.magFilter=9729,Q.minFilter=9729;break;case Y.c.LINEAR_NEAREST:Q.magFilter=9729,Q.minFilter=9728;break;case Y.c.NEAREST_LINEAR:Q.magFilter=9728,Q.minFilter=9729;break;case Y.c.NEAREST_LINEAR_MIPLINEAR:Q.magFilter=9728,Q.minFilter=9987;break;case Y.c.NEAREST_NEAREST:Q.magFilter=9728,Q.minFilter=9728;break;case Y.c.NEAREST_LINEAR_MIPNEAREST:Q.magFilter=9728,Q.minFilter=9985;break;case Y.c.LINEAR_NEAREST_MIPNEAREST:Q.magFilter=9729,Q.minFilter=9984;break;case Y.c.LINEAR_NEAREST_MIPLINEAR:Q.magFilter=9729,Q.minFilter=9986;break;case Y.c.NEAREST_NEAREST_MIPLINEAR:Q.magFilter=9728,Q.minFilter=9986;break;case Y.c.LINEAR_LINEAR_MIPLINEAR:Q.magFilter=9729,Q.minFilter=9987;break;case Y.c.LINEAR_LINEAR_MIPNEAREST:Q.magFilter=9729,Q.minFilter=9985;break;case Y.c.NEAREST_NEAREST_MIPNEAREST:Q.magFilter=9728,Q.minFilter=9984}return Q}_getGLTFTextureWrapMode(k){switch(k){case Y.c.WRAP_ADDRESSMODE:return 10497;case Y.c.CLAMP_ADDRESSMODE:return 33071;case Y.c.MIRROR_ADDRESSMODE:return 33648;default:return U.Tools.Error(`Unsupported Texture Wrap Mode ${k}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(k,Q,i,Z){const U={diffuseColor:k._albedoColor,specularColor:k._reflectivityColor,glossiness:k._microSurface},C=k._albedoTexture,B=k._reflectivityTexture,o=k._useMicroSurfaceFromReflectivityMapAlpha;if(B&&!o)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((C||B)&&Z){this._exporter._materialNeedsUVsSet.add(k);const Z=this._exportTextureSampler(C||B),o=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(C,B,U,Q),m=this._exporter._textures;if(o.baseColorTextureData){const k=this._exportImage(`baseColor${m.length}`,Q,o.baseColorTextureData);i.baseColorTexture=this._exportTextureInfo(k,Z,null===C||void 0===C?void 0:C.coordinatesIndex)}if(o.metallicRoughnessTextureData){const k=this._exportImage(`metallicRoughness${m.length}`,Q,o.metallicRoughnessTextureData);i.metallicRoughnessTexture=this._exportTextureInfo(k,Z,null===B||void 0===B?void 0:B.coordinatesIndex)}return o}return this._convertSpecularGlossinessToMetallicRoughness(U)}async exportPBRMaterialAsync(k,Q,i){const Z={},U={name:k.name},C=k.isMetallicWorkflow();if(C){const Q=k._albedoColor,i=k.alpha;Q&&(Z.baseColorFactor=[Q.r,Q.g,Q.b,i])}const B=C?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(k,Q,Z,i):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(k,Q,Z,i);await this._setMetallicRoughnessPbrMaterialAsync(B,k,U,Z,Q,i),await this._finishMaterialAsync(U,k,Q);const o=this._exporter._materials;return o.push(U),o.length-1}async _setMetallicRoughnessPbrMaterialAsync(k,Q,i,Z,C,B){if(X(i,Q),k.baseColor.equalsWithEpsilon(T,u)&&c.WithinEpsilon(Q.alpha,1,u)||(Z.baseColorFactor=[k.baseColor.r,k.baseColor.g,k.baseColor.b,Q.alpha]),null!=k.metallic&&1!==k.metallic&&(Z.metallicFactor=k.metallic),null!=k.roughness&&1!==k.roughness&&(Z.roughnessFactor=k.roughness),null==Q.Jo||Q.Jo||(Q._twoSidedLighting||U.Tools.Warn(Q.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),i.doubleSided=!0),B){const k=[],Z=Q._bumpTexture;Z&&k.push(this.exportTextureAsync(Z,C).then((k=>{k&&(i.normalTexture=k,1!==Z.level&&(i.normalTexture.scale=Z.level))})));const U=Q._ambientTexture;U&&k.push(this.exportTextureAsync(U,C).then((k=>{if(k){const Z={index:k.index,texCoord:k.texCoord,extensions:k.extensions};i.occlusionTexture=Z;const U=Q._ambientTextureStrength;U&&(Z.strength=U)}})));const B=Q._emissiveTexture;B&&k.push(this.exportTextureAsync(B,C).then((k=>{k&&(i.emissiveTexture=k)}))),k.length>0&&(this._exporter._materialNeedsUVsSet.add(Q),await Promise.all(k))}const o=Q._emissiveColor;o.equalsWithEpsilon(K,u)||(i.emissiveFactor=o.Zo()),i.pbrMetallicRoughness=Z}_getPixelsFromTextureAsync(k){return function(k){switch(k){case L.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case L.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case L.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case L.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case L.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case L.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case L.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case L.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case L.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case L.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case L.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case L.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case L.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case L.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case L.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case L.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case L.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case L.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case L.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case L.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case L.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(k.textureFormat)?(0,f.k)(k,k._texture.width,k._texture.height):(k.textureType,L.c.TEXTURETYPE_UNSIGNED_BYTE,k.readPixels())}async exportTextureAsync(k,Q){const i=this._exporter._extensionsPreExportTextureAsync("exporter",k,Q);return i?await i.then((async i=>i?await this._exportTextureInfoAsync(i,Q):await this._exportTextureInfoAsync(k,Q))):await this._exportTextureInfoAsync(k,Q)}async _exportTextureInfoAsync(k,Q){let i=this._textureMap.get(k);if(!i){const Z=await this._getPixelsFromTextureAsync(k);if(!Z)return null;const C=this._exportTextureSampler(k),B=k.mimeType;if(B)switch(B){case"image/jpeg":case"image/png":case"image/webp":Q=B;break;default:U.Tools.Warn(`Unsupported media type: ${B}. Exporting texture as PNG.`)}const o=this._internalTextureToImage,m=k.getInternalTexture().uniqueId;o[m]||(o[m]={});let O=o[m][Q];if(void 0===O){const i=k.getSize();O=(async()=>{const U=await this._getImageDataAsync(Z,i.width,i.height,Q);return this._exportImage(k.name,Q,U)})(),o[m][Q]=O}i=this._exportTextureInfo(await O,C,k.coordinatesIndex),this._textureMap.set(k,i),this._exporter._extensionsPostExportTextures("exporter",i,k)}return i}_exportImage(k,Q,i){const Z=this._exporter._images;let C;if(this._exporter._shouldUseGlb){C={name:k,mimeType:Q,bufferView:void 0};const Z=this._exporter._bufferManager.createBufferView(new Uint8Array(i));this._exporter._bufferManager.setBufferView(C,Z)}else{const B=k.replace(/\.\/|\/|\.\\|\\/g,"_"),o=function(k){switch(k){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(Q);let m=B+o;Z.some((k=>k.uri===m))&&(m=`${B}_${U.Tools.RandomId()}${o}`),C={name:k,uri:m},this._exporter._imageData[m]={data:i,mimeType:Q}}return Z.push(C),Z.length-1}_exportTextureInfo(k,Q,i){const Z=this._exporter._textures;let U=Z.findIndex((i=>i.sampler==Q&&i.source===k));-1===U&&(U=Z.length,Z.push({source:k,sampler:Q}));const C={index:U};return i&&(C.texCoord=i),C}_exportTextureSampler(k){const Q=this._getTextureSampler(k),i=this._exporter._samplers,Z=i.findIndex((k=>k.minFilter===Q.minFilter&&k.magFilter===Q.magFilter&&k.wrapS===Q.wrapS&&k.wrapT===Q.wrapT));return-1!==Z?Z:(i.push(Q),i.length-1)}}var D=i(11387),M=i(11134),W=i(11766),A=i(11304);const g=Z.zQ.Zero(),R=Z.Quaternion.Identity(),w=Z.zQ.One(),S=new Z.zQ(-1,1,1);function q(k,Q){const{byteOffset:i,byteStride:Z,type:U,normalized:C}=k,B=k.getSize(),o=Q.reduce(((k,Q)=>Q.getTotalVertices()>k?Q.getTotalVertices():k),-Number.MAX_VALUE);return{byteOffset:i,byteStride:Z,componentCount:B,type:U,count:o*B,normalized:C,totalVertices:o,kind:k.getKind()}}function P(k){switch(k){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function t(k){switch(k){case J.h.PositionKind:case J.h.NormalKind:case J.h.TangentKind:case J.h.ColorKind:case J.h.MatricesIndicesKind:case J.h.MatricesIndicesExtraKind:case J.h.MatricesWeightsKind:case J.h.MatricesWeightsExtraKind:case J.h.UVKind:case J.h.UV2Kind:case J.h.UV3Kind:case J.h.UV4Kind:case J.h.UV5Kind:case J.h.UV6Kind:return!0}return!1}function I(k){switch(k){case C.c.TriangleFillMode:return 4;case C.c.TriangleStripDrawMode:return 5;case C.c.TriangleFanDrawMode:return 6;case C.c.PointListDrawMode:case C.c.PointFillMode:return 0;case C.c.LineLoopDrawMode:return 2;case C.c.LineListDrawMode:return 1;case C.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${k}`)}function r(k){const Q=Math.sqrt(k.x*k.x+k.y*k.y+k.z*k.z);Q>0&&(k.x/=Q,k.y/=Q,k.z/=Q)}function n(k){return k.x*=-1,k}function x(k){if(k.x*k.x+k.y*k.y>.5){const Q=Math.abs(k.x),i=Math.abs(k.y);if(Q>i){const i=Math.sign(k.x);k.x=Q,k.y*=-i,k.z*=-i,k.w*=i}else{const Q=Math.sign(k.y);k.x*=-Q,k.y=i,k.z*=Q,k.w*=-Q}}else{const Q=Math.abs(k.z),i=Math.abs(k.w);if(Q>i){const i=Math.sign(k.z);k.x*=-i,k.y*=i,k.z=Q,k.w*=-i}else{const Q=Math.sign(k.w);k.x*=Q,k.y*=-Q,k.z*=-Q,k.w=i}}return k}function V(k){k.Go(-k.z,k.w,k.x,-k.y)}function kk(k,Q){const i=Z.zQ.FromArrayToRef(Q.translation||[0,0,0],0,Z.TmpVectors.zQ[0]),U=Z.Quaternion.FromArrayToRef(Q.rotation||[0,0,0,1],0,Z.TmpVectors.Quaternion[0]),C=Z.Matrix.ComposeToRef(w,U,i,Z.TmpVectors.Matrix[0]),B=Z.zQ.FromArrayToRef(k.translation||[0,0,0],0,Z.TmpVectors.zQ[2]),o=Z.Quaternion.FromArrayToRef(k.rotation||[0,0,0,1],0,Z.TmpVectors.Quaternion[1]),m=Z.Matrix.ComposeToRef(w,o,B,Z.TmpVectors.Matrix[1]);C.multiplyToRef(m,m),m.decompose(void 0,U,i),i.equalsWithEpsilon(g,A.e)?delete Q.translation:Q.translation=i.Zo(),U.equalsWithEpsilon(R,A.e)?delete Q.rotation:Q.rotation=U.Zo(),Q.scale&&delete Q.scale}function Qk(k,Q){if(!(Q instanceof G.d))return!1;if(!(1===Q.getChildren().length&&0===k.getChildren().length&&k.parent===Q))return!1;const i=k.sk(),Z=k instanceof W.c&&!i.useRightHandedSystem?S:w;return!!Q.Ho.equalsWithEpsilon(Z,A.e)||(M.c.Warn(`Cannot collapse node ${k.name} into parent node ${Q.name} with modified scaling.`),!1)}function ik(k){if(k instanceof Array){const Q=new Float32Array(k);return new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength)}return ArrayBuffer.isView(k)?new Uint8Array(k.buffer,k.byteOffset,k.byteLength):new Uint8Array(k)}function Zk(k,Q){for(const[i,Z]of Object.entries(k)){const U=Q[i];(Array.isArray(Z)&&Array.isArray(U)&&Uk(Z,U)||Z===U)&&delete k[i]}return k}function Uk(k,Q){return k.length===Q.length&&k.every(((k,i)=>k===Q[i]))}const Ck=Z.Matrix.Compose(new Z.zQ(-1,1,1),Z.Quaternion.Identity(),Z.zQ.Zero());function Bk(k,Q){if(!(k instanceof G.d))return!1;if(Q){if(!k.getWorldMatrix().equalsWithEpsilon(Z.Matrix.IdentityReadOnly,A.e))return!1}else{if(!k.getWorldMatrix().multiplyToRef(Ck,Z.TmpVectors.Matrix[0]).equalsWithEpsilon(Z.Matrix.IdentityReadOnly,A.e))return!1}return!(k instanceof H.d&&k.mo)}const ok=new Map([[Int8Array,(k,Q,i)=>k.setInt8(Q,i)],[Uint8Array,(k,Q,i)=>k.setUint8(Q,i)],[Uint8ClampedArray,(k,Q,i)=>k.setUint8(Q,i)],[Int16Array,(k,Q,i)=>k.setInt16(Q,i,!0)],[Uint16Array,(k,Q,i)=>k.setUint16(Q,i,!0)],[Int32Array,(k,Q,i)=>k.setInt32(Q,i,!0)],[Uint32Array,(k,Q,i)=>k.setUint32(Q,i,!0)],[Float32Array,(k,Q,i)=>k.setFloat32(Q,i,!0)],[Float64Array,(k,Q,i)=>k.setFloat64(Q,i,!0)]]);class mk{writeTypedArray(k){this._checkGrowBuffer(k.byteLength);const Q=ok.get(k.constructor);for(let i=0;i<k.length;i++)Q(this._dataView,this._byteOffset,k[i]),this._byteOffset+=k.BYTES_PER_ELEMENT}constructor(k){this._data=new Uint8Array(k),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(k){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,k),this._byteOffset++}writeInt8(k){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,k),this._byteOffset++}writeInt16(k){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,k,!0),this._byteOffset+=2}writeUInt16(k){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,k,!0),this._byteOffset+=2}writeInt32(k){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,k,!0),this._byteOffset+=4}writeUInt32(k){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,k,!0),this._byteOffset+=4}writeFloat32(k){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,k,!0),this._byteOffset+=4}writeFloat64(k){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,k,!0),this._byteOffset+=8}_checkGrowBuffer(k){const Q=this.byteOffset+k;if(Q>this._data.byteLength){const k=new Uint8Array(2*Q);k.set(this._data),this._data=k,this._dataView=new DataView(this._data.buffer)}}}function Ok(k){return k%4===0?4:k%2===0?2:1}class Jk{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(k){let Q=0;this._bufferViewToData.forEach((k=>{Q+=k.byteLength}));const i=new mk(Q),Z=Array.from(this._bufferViewToData.keys()).sort(((k,Q)=>Ok(Q.byteLength)-Ok(k.byteLength)));for(const U of Z){U.byteOffset=i.byteOffset,k.push(U);const Q=k.length-1,Z=this.getPropertiesWithBufferView(U);for(const k of Z)k.bufferView=Q;i.writeTypedArray(this._bufferViewToData.get(U)),this._bufferViewToData.delete(U)}return i.getOutputData()}createBufferView(k,Q){const i={buffer:0,byteOffset:void 0,byteLength:k.byteLength,byteStride:Q};return this._bufferViewToData.set(i,k),i}createAccessor(k,Q,i,Z,U,C,B){this._verifyBufferView(k);const o={bufferView:void 0,componentType:i,count:Z,type:Q,min:null===C||void 0===C?void 0:C.min,max:null===C||void 0===C?void 0:C.max,normalized:B,byteOffset:U};return this.setBufferView(o,k),this._accessorToBufferView.set(o,k),o}setBufferView(k,Q){this._verifyBufferView(Q);this.getPropertiesWithBufferView(Q).push(k)}removeBufferView(k){const Q=this.getPropertiesWithBufferView(k);for(const i of Q)void 0!==i.bufferView&&delete i.bufferView;this._bufferViewToData.delete(k),this._bufferViewToProperties.delete(k),this._accessorToBufferView.forEach(((Q,i)=>{Q===k&&(void 0!==i.byteOffset&&delete i.byteOffset,this._accessorToBufferView.delete(i))}))}getBufferView(k){const Q=this._accessorToBufferView.get(k);return this._verifyBufferView(Q),Q}getPropertiesWithBufferView(k){return this._verifyBufferView(k),this._bufferViewToProperties.set(k,this._bufferViewToProperties.get(k)??[]),this._bufferViewToProperties.get(k)}getData(k){return this._verifyBufferView(k),this._bufferViewToData.get(k)}_verifyBufferView(k){if(void 0===k||!this._bufferViewToData.has(k))throw new Error(`BufferView ${k} not found in BufferManager.`)}}var Gk,Hk=i(11740),ek=i(11754),Fk=i(11774),zk=i(11659),Ek=i(11805),lk=i(11820),hk=i(11734),ck=i(11826);!function(k){k[k.INTANGENT=0]="INTANGENT",k[k.OUTTANGENT=1]="OUTTANGENT"}(Gk||(Gk={}));class fk{static _IsTransformable(k){return k&&(k instanceof G.d||k instanceof Hk.e||k instanceof ck.e)}static _CreateNodeAnimation(k,Q,i,Z,C){if(this._IsTransformable(k)){const B=[],o=[],m=Q.getKeys(),O=fk._CalculateMinMaxKeyFrames(m),J=fk._DeduceInterpolation(m,i,Z),G=J.interpolationType,H=J.shouldBakeAnimation;if(H?fk._CreateBakedAnimation(k,Q,i,O.min,O.max,Q.framePerSecond,C,B,o,O,Z):"LINEAR"===G||"STEP"===G?fk._CreateLinearOrStepAnimation(k,Q,i,B,o,Z):"CUBICSPLINE"===G?fk._CreateCubicSplineAnimation(k,Q,i,B,o,Z):fk._CreateBakedAnimation(k,Q,i,O.min,O.max,Q.framePerSecond,C,B,o,O,Z),B.length&&o.length){return{inputs:B,outputs:o,samplerInterpolation:G,inputsMin:H?O.min:U.Tools.FloatRound(O.min/Q.framePerSecond),inputsMax:H?O.max:U.Tools.FloatRound(O.max/Q.framePerSecond)}}}return null}static _DeduceAnimationInfo(k){let Q=null,i="VEC3",Z=!1;const C=k.targetProperty.split(".");switch(C[0]){case"Ho":Q="scale";break;case"position":Q="translation";break;case"rotation":i="VEC4",Q="rotation";break;case"rotationQuaternion":i="VEC4",Z=!0,Q="rotation";break;case"influence":i="SCALAR",Q="weights";break;default:U.Tools.Error(`Unsupported animatable property ${C[0]}`)}return Q?{animationChannelTargetPath:Q,dataAccessorType:i,useQuaternion:Z}:(U.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(k,Q,i,Z,U,C,B,o,m,O,J){let G;if(fk._IsTransformable(k)&&k.animations)for(const H of k.animations){if(J&&!J(H))continue;const U=fk._DeduceAnimationInfo(H);U&&(G={name:H.name,samplers:[],channels:[]},fk._AddAnimation(`${H.name}`,H.hasRunningRuntimeAnimations?Q:G,k,H,U.dataAccessorType,U.animationChannelTargetPath,Z,C,B,o,U.useQuaternion,m,O),G.samplers.length&&G.channels.length&&i.push(G))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(k,Q,i,Z,U,C,B,o,m,O,J){let G;if(k instanceof hk.d){const U=k.morphTargetManager;if(U)for(let H=0;H<U.numTargets;++H){const e=U.getTarget(H);for(const F of e.animations){if(J&&!J(F))continue;const e=new Ek.c(`${F.name}`,"influence",F.framePerSecond,F.dataType,F.loopMode,F.enableBlending),z=[],E=F.getKeys();for(let k=0;k<E.length;++k){const Q=E[k];for(let k=0;k<U.numTargets;++k)k==H?z.push(Q):z.push({frame:Q.frame,value:0})}e.setKeys(z);const l=fk._DeduceAnimationInfo(e);l&&(G={name:e.name,samplers:[],channels:[]},fk._AddAnimation(F.name,F.hasRunningRuntimeAnimations?Q:G,k,e,l.dataAccessorType,l.animationChannelTargetPath,Z,C,B,o,l.useQuaternion,m,O,U.numTargets),G.samplers.length&&G.channels.length&&i.push(G))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(k,Q,i,Z,U,C,B,o,m){let O;if(k.animationGroups){const G=k.animationGroups;for(const H of G){const G=new Map,e=new Map,F=new Set,z=H.to-H.from;O={name:H.name,channels:[],samplers:[]};for(let Q=0;Q<H.targetedAnimations.length;++Q){const z=H.targetedAnimations[Q],E=z.target,l=z.animation;if(m&&!m(l))continue;const h=o.has(E);if(this._IsTransformable(E)||1===E.length&&this._IsTransformable(E[0])){const k=fk._DeduceAnimationInfo(z.animation);if(k){const Q=this._IsTransformable(E)?E:this._IsTransformable(E[0])?E[0]:null;Q&&fk._AddAnimation(`${l.name}`,O,Q,l,k.dataAccessorType,k.animationChannelTargetPath,i,Z,U,C,k.useQuaternion,B,h)}}else if(E instanceof lk.e||1===E.length&&E[0]instanceof lk.e){if(fk._DeduceAnimationInfo(z.animation)){const Q=E instanceof lk.e?E:E[0];if(Q){const i=k.morphTargetManagers.find((k=>{for(let i=0;i<k.numTargets;++i)if(k.getTarget(i)===Q)return!0;return!1}));if(i){const Z=k.meshes.find((k=>k.morphTargetManager===i));var J;if(Z)G.has(Z)||G.set(Z,new Map),null===(J=G.get(Z))||void 0===J||J.set(Q,l),F.add(Z),e.set(Z,l)}}}}}F.forEach((k=>{const Q=k.morphTargetManager;let o=null;const m=[],J=e.get(k).getKeys(),F=J.length;for(let i=0;i<F;++i)for(let Z=0;Z<Q.numTargets;++Z){const U=Q.getTarget(Z),C=G.get(k);if(C){const Q=C.get(U);Q?(o||(o=new Ek.c(`${H.name}_${k.name}_MorphWeightAnimation`,"influence",Q.framePerSecond,Ek.c.ANIMATIONTYPE_FLOAT,Q.loopMode,Q.enableBlending)),m.push(Q.getKeys()[i])):m.push({frame:H.from+z/F*i,value:U.influence,inTangent:J[0].inTangent?0:void 0,outTangent:J[0].outTangent?0:void 0})}}o.setKeys(m);const E=fk._DeduceAnimationInfo(o);E&&fk._AddAnimation(`${H.name}_${k.name}_MorphWeightAnimation`,O,k,o,E.dataAccessorType,E.animationChannelTargetPath,i,Z,U,C,E.useQuaternion,B,!1,null===Q||void 0===Q?void 0:Q.numTargets)})),O.channels.length&&O.samplers.length&&Q.push(O)}}}static _AddAnimation(k,Q,i,U,C,B,o,m,O,J,G,H,e,F){const z=fk._CreateNodeAnimation(i,U,B,G,H);let E,l,h,c,f,Y;if(z){if(F){let k=0,Q=0;const i=[];for(;z.inputs.length>0;)Q=z.inputs.shift(),k%F==0&&i.push(Q),k++;z.inputs=i}const k=o.get(i),U=new Float32Array(z.inputs);E=m.createBufferView(U),l=m.createAccessor(E,"SCALAR",5126,z.inputs.length,void 0,{min:[z.inputsMin],max:[z.inputsMax]}),J.push(l),h=J.length-1;const O=new Z.Quaternion,G=new Z.zQ,H=new Z.zQ,y=i instanceof Hk.e,L=P(C),s=new Float32Array(z.outputs.length*L);z.outputs.forEach((function(k,Q){let i=k;switch(B){case"translation":e&&(Z.zQ.FromArrayToRef(k,0,H),n(H),H.toArray(i));break;case"rotation":4===k.length?Z.Quaternion.FromArrayToRef(k,0,O):(i=new Array(4),Z.zQ.FromArrayToRef(k,0,G),Z.Quaternion.FromEulerVectorToRef(G,O)),e&&(x(O),y&&V(O)),O.toArray(i)}s.set(i,Q*L)})),E=m.createBufferView(s),l=m.createAccessor(E,C,5126,z.outputs.length),J.push(l),c=J.length-1,f={interpolation:z.samplerInterpolation,input:h,output:c},Q.samplers.push(f),Y={sampler:Q.samplers.length-1,target:{node:k,path:B}},Q.channels.push(Y)}}static _CreateBakedAnimation(k,Q,i,C,B,o,m,O,J,G,H){let e;const F=Z.Quaternion.Identity();let z,E=null,l=null,h=null,c=null,f=null,Y=null;G.min=U.Tools.FloatRound(C/o);const y=Q.getKeys();for(let Z=0,L=y.length;Z<L;++Z){if(Y=null,h=y[Z],Z+1<L)if(c=y[Z+1],h.value.equals&&h.value.equals(c.value)||h.value===c.value){if(0!==Z)continue;Y=h.frame}else Y=c.frame;else{if(f=y[Z-1],h.value.equals&&h.value.equals(f.value)||h.value===f.value)continue;Y=B}if(Y)for(let Z=h.frame;Z<=Y;Z+=m){if(z=U.Tools.FloatRound(Z/o),z===E)continue;E=z,l=z;const C={key:0,repeatCount:0,loopMode:Q.loopMode};e=Q._interpolate(Z,C),fk._SetInterpolatedValue(k,e,z,Q,i,F,O,J,H)}}l&&(G.max=l)}static _ConvertFactorToVector3OrQuaternion(k,Q,i,C,B){const o=fk._GetBasePositionRotationOrScale(Q,C,B),m=i.targetProperty.split("."),O=m?m[1]:"",J=B?Z.Quaternion.fQ(o).normalize():Z.zQ.fQ(o);switch(O){case"x":case"y":case"z":J[O]=k;break;case"w":J.w=k;break;default:U.Tools.Error(`glTFAnimation: Unsupported component name "${O}"!`)}return J}static _SetInterpolatedValue(k,Q,i,U,C,B,o,m,O){let J;o.push(i),"weights"!==C?(U.dataType===Ek.c.ANIMATIONTYPE_FLOAT&&(Q=this._ConvertFactorToVector3OrQuaternion(Q,k,U,C,O)),"rotation"===C?(O?B=Q:(J=Q,Z.Quaternion.RotationYawPitchRollToRef(J.y,J.x,J.z,B)),m.push(B.Zo())):(J=Q,m.push(J.Zo()))):m.push([Q])}static _CreateLinearOrStepAnimation(k,Q,i,Z,U,C){for(const B of Q.getKeys())Z.push(B.frame/Q.framePerSecond),fk._AddKeyframeValue(B,Q,U,i,k,C)}static _CreateCubicSplineAnimation(k,Q,i,Z,U,C){Q.getKeys().forEach((function(B){Z.push(B.frame/Q.framePerSecond),fk._AddSplineTangent(Gk.INTANGENT,U,i,"CUBICSPLINE",B,C),fk._AddKeyframeValue(B,Q,U,i,k,C),fk._AddSplineTangent(Gk.OUTTANGENT,U,i,"CUBICSPLINE",B,C)}))}static _GetBasePositionRotationOrScale(k,Q,i){let U;if("rotation"===Q)if(i){U=(k.rotationQuaternion??Z.Quaternion.Identity()).Zo()}else{U=(k.rotation??Z.zQ.Zero()).Zo()}else if("translation"===Q){U=(k.position??Z.zQ.Zero()).Zo()}else{U=(k.Ho??Z.zQ.One()).Zo()}return U}static _AddKeyframeValue(k,Q,i,C,B,o){let m;const O=Q.dataType;if(O===Ek.c.ANIMATIONTYPE_VECTOR3){let Q=k.value.Zo();if("rotation"===C){const k=Z.zQ.fQ(Q);Q=Z.Quaternion.RotationYawPitchRoll(k.y,k.x,k.z).Zo()}i.push(Q)}else if(O===Ek.c.ANIMATIONTYPE_FLOAT){if("weights"===C)i.push([k.value]);else if(m=this._ConvertFactorToVector3OrQuaternion(k.value,B,Q,C,o),m){if("rotation"===C){const k=o?m:Z.Quaternion.RotationYawPitchRoll(m.y,m.x,m.z).normalize();i.push(k.Zo())}i.push(m.Zo())}}else O===Ek.c.ANIMATIONTYPE_QUATERNION?i.push(k.value.normalize().Zo()):U.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(k,Q,i){let Z,U,C=!1;if("rotation"===Q&&!i)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let B=0,o=k.length;B<o;++B)if(U=k[B],U.inTangent||U.outTangent)if(Z){if("CUBICSPLINE"!==Z){Z="LINEAR",C=!0;break}}else Z="CUBICSPLINE";else if(Z){if("CUBICSPLINE"===Z||U.interpolation&&1===U.interpolation&&"STEP"!==Z){Z="LINEAR",C=!0;break}}else Z=U.interpolation&&1===U.interpolation?"STEP":"LINEAR";return Z||(Z="LINEAR"),{interpolationType:Z,shouldBakeAnimation:C}}static _AddSplineTangent(k,Q,i,U,C,B){let o;const m=k===Gk.INTANGENT?C.inTangent:C.outTangent;if("CUBICSPLINE"===U){if("rotation"===i)if(m)if(B)o=m.Zo();else{const k=m;o=Z.Quaternion.RotationYawPitchRoll(k.y,k.x,k.z).Zo()}else o=[0,0,0,0];else o="weights"===i?m?[m]:[0]:m?m.Zo():[0,0,0];Q.push(o)}}static _CalculateMinMaxKeyFrames(k){let Q=1/0,i=-1/0;return k.forEach((function(k){Q=Math.min(Q,k.frame),i=Math.max(i,k.frame)})),{min:Q,max:i}}}function Yk(k,Q,i,C,B,o){const m={attributes:{},influence:k.influence,name:k.name},O=Q.mo;if(!O)return U.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),m;const G=o?-1:1,H=Z.zQ.Zero();let e=0,F=0;if(k.hasPositions){const C=k.getPositions(),o=O.getVerticesData(J.h.PositionKind);if(o){const k=new Float32Array(o.length),Q=[1/0,1/0,1/0],U=[-1/0,-1/0,-1/0];F=o.length/3,e=0;for(let i=e;i<F;++i){const B=Z.zQ.fQ(o,3*i);Z.zQ.fQ(C,3*i).subtractToRef(B,H),H.x*=G,Q[0]=Math.min(Q[0],H.x),U[0]=Math.max(U[0],H.x),Q[1]=Math.min(Q[1],H.y),U[1]=Math.max(U[1],H.y),Q[2]=Math.min(Q[2],H.z),U[2]=Math.max(U[2],H.z),k[3*i]=H.x,k[3*i+1]=H.y,k[3*i+2]=H.z}const O=i.createBufferView(k,12),J=i.createAccessor(O,"VEC3",5126,C.length/3,0,{min:Q,max:U});B.push(J),m.attributes.POSITION=B.length-1}else U.Tools.Warn(`Morph target positions for mesh ${Q.name} were not exported. Mesh does not have position vertex data`)}if(k.hasNormals){const C=k.getNormals(),o=O.getVerticesData(J.h.NormalKind);if(o){const k=new Float32Array(o.length);F=o.length/3,e=0;for(let i=e;i<F;++i){const Q=Z.zQ.fQ(o,3*i).normalize();Z.zQ.fQ(C,3*i).normalize().subtractToRef(Q,H),k[3*i]=H.x*G,k[3*i+1]=H.y,k[3*i+2]=H.z}const Q=i.createBufferView(k,12),U=i.createAccessor(Q,"VEC3",5126,C.length/3,0);B.push(U),m.attributes.NORMAL=B.length-1}else U.Tools.Warn(`Morph target normals for mesh ${Q.name} were not exported. Mesh does not have normals vertex data`)}if(k.hasTangents){const C=k.getTangents(),o=O.getVerticesData(J.h.TangentKind);if(o){F=o.length/4;const k=new Float32Array(3*F);e=0;for(let i=e;i<F;++i){const Q=Z.zQ.fQ(o,4*i);r(Q);const U=Z.zQ.fQ(C,3*i);r(U),U.subtractToRef(Q,H),k[3*i]=H.x*G,k[3*i+1]=H.y,k[3*i+2]=H.z}const Q=i.createBufferView(k,12),U=i.createAccessor(Q,"VEC3",5126,F,0);B.push(U),m.attributes.TANGENT=B.length-1}else U.Tools.Warn(`Morph target tangents for mesh ${Q.name} were not exported. Mesh does not have tangents vertex data`)}if(k.hasColors){const C=k.getColors(),o=O.getVerticesData(J.h.ColorKind),G=O.getVertexBuffer(J.h.ColorKind);if(o&&G){const k=G.getSize();F=o.length/k;const Q=new Float32Array(F*k);e=0;for(let i=e;i<F;++i)if(3===k){const U=Z.zQ.fQ(o,i*k);Z.zQ.fQ(C,i*k).subtractToRef(U,H),Q[3*i]=H.x,Q[3*i+1]=H.y,Q[3*i+2]=H.z}else if(4===k){const U=new Z.Vector4,B=Z.Vector4.fQ(o,i*k);Z.Vector4.fQ(C,i*k).subtractToRef(B,U),Q[4*i]=U.x,Q[4*i+1]=U.y,Q[4*i+2]=U.z,Q[4*i+3]=U.w}else U.Tools.Warn(`Unsupported number of components for color attribute: ${k}`);const O=i.createBufferView(Q,4*k),J=i.createAccessor(O,3===k?"VEC3":"VEC4",5126,F,0);B.push(J),m.attributes.COLOR_0=B.length-1}else U.Tools.Warn(`Morph target colors for mesh ${Q.name} were not exported. Mesh does not have colors vertex data`)}return m}var yk=i(11833),Lk=i(11678),sk=i(11666),uk=i(11253);class ak{}ak.DEFAULT_COLOR=E.cQ.White(),ak.DEFAULT_WIDTH_ATTENUATED=1,ak.DEFAULT_WIDTH=.1;var jk=i(11505),Tk=i(11836);class Kk{static ConvertPoints(k,Q){if(k.length&&Array.isArray(k)&&"number"===typeof k[0])return[k];if(k.length&&Array.isArray(k[0])&&"number"===typeof k[0][0])return k;if(k.length&&!Array.isArray(k[0])&&k[0]instanceof Z.zQ){const Q=[];for(let i=0;i<k.length;i++){const Z=k[i];Q.push(Z.x,Z.y,Z.z)}return[Q]}if(k.length>0&&Array.isArray(k[0])&&k[0].length>0&&k[0][0]instanceof Z.zQ){const Q=[],i=k;for(const k of i)Q.push(k.flatMap((k=>[k.x,k.y,k.z])));return Q}if(k instanceof Float32Array){if(null!==Q&&void 0!==Q&&Q.floatArrayStride){const i=[],Z=3*Q.floatArrayStride;for(let Q=0;Q<k.length;Q+=Z){const U=new Array(Z);for(let i=0;i<Z;i++)U[i]=k[Q+i];i.push(U)}return i}return[Array.from(k)]}if(k.length&&k[0]instanceof Float32Array){const Q=[];for(const i of k)Q.push(Array.from(i));return Q}return[]}static OmitZeroLengthPredicate(k,Q,i){const Z=[];return Q.EQ(k).lengthSquared()>0&&Z.push([k,Q]),i.EQ(Q).lengthSquared()>0&&Z.push([Q,i]),k.EQ(i).lengthSquared()>0&&Z.push([i,k]),0===Z.length?null:Z}static OmitDuplicatesPredicate(k,Q,i,Z){const U=[];return Kk._SearchInPoints(k,Q,Z)||U.push([k,Q]),Kk._SearchInPoints(Q,i,Z)||U.push([Q,i]),Kk._SearchInPoints(i,k,Z)||U.push([i,k]),0===U.length?null:U}static _SearchInPoints(k,Q,i){for(const B of i)for(let i=0;i<B.length;i++){var Z,U,C;if(null!==(Z=B[i])&&void 0!==Z&&Z.equals(k))if(null!==(U=B[i+1])&&void 0!==U&&U.equals(Q)||null!==(C=B[i-1])&&void 0!==C&&C.equals(Q))return!0}return!1}static MeshesToLines(k,Q){const i=[];for(let U=0;U<k.length;U++){const C=k[U],B=C.getVerticesData(J.h.PositionKind),o=C.Oo();if(B&&o)for(let k=0,m=0;k<o.length;k++){const O=3*o[m++],J=3*o[m++],G=3*o[m++],H=new Z.zQ(B[O],B[O+1],B[O+2]),e=new Z.zQ(B[J],B[J+1],B[J+2]),F=new Z.zQ(B[G],B[G+1],B[G+2]);if(Q){const Z=Q(H,e,F,i,k,O,C,U,B,o);if(Z)for(const k of Z)i.push(k)}else i.push([H,e],[e,F],[F,H])}}return i}static ToVector3Array(k){if(Array.isArray(k[0])){const Q=[],i=k;for(const k of i){const i=[];for(let Q=0;Q<k.length;Q+=3)i.push(new Z.zQ(k[Q],k[Q+1],k[Q+2]));Q.push(i)}return Q}const Q=k,i=[];for(let U=0;U<Q.length;U+=3)i.push(new Z.zQ(Q[U],Q[U+1],Q[U+2]));return i}static ToNumberArray(k){return k.flatMap((k=>[k.x,k.y,k.z]))}static GetPointsCountInfo(k){const Q=new Array(k.length);let i=0;for(let Z=k.length;Z--;)Q[Z]=k[Z].length/3,i+=Q[Z];return{total:i,counts:Q}}static GetLineLength(k){if(0===k.length)return 0;let Q;Q="number"===typeof k[0]?Kk.ToVector3Array(k):k;const i=Z.TmpVectors.zQ[0];let U=0;for(let Z=0;Z<Q.length-1;Z++){const k=Q[Z];U+=Q[Z+1].subtractToRef(k,i).length()}return U}static GetLineLengthArray(k){const Q=new Float32Array(k.length/3);let i=0;for(let Z=0,U=k.length/3-1;Z<U;Z++){let U=k[3*Z+0],C=k[3*Z+1],B=k[3*Z+2];U-=k[3*Z+3],C-=k[3*Z+4],B-=k[3*Z+5];i+=Math.sqrt(U*U+C*C+B*B),Q[Z+1]=i}return Q}static SegmentizeSegmentByCount(k,Q,i){const U=[],C=Q.EQ(k),B=Z.TmpVectors.zQ[0];B.eo(i);const o=Z.TmpVectors.zQ[1];C.divideToRef(B,o);let m=k.clone();U.push(m);for(let Z=0;Z<i;Z++)m=m.clone(),U.push(m.addInPlace(o));return U}static SegmentizeLineBySegmentLength(k,Q){const i=k[0]instanceof Z.zQ?Kk.GetLineSegments(k):"number"===typeof k[0]?Kk.GetLineSegments(Kk.ToVector3Array(k)):k,U=[];for(const Z of i)if(Z.length>Q){const k=Kk.SegmentizeSegmentByCount(Z.point1,Z.point2,Math.ceil(Z.length/Q));for(const Q of k)U.push(Q)}else U.push(Z.point1),U.push(Z.point2);return U}static SegmentizeLineBySegmentCount(k,Q){const i="number"===typeof k[0]?Kk.ToVector3Array(k):k,Z=Kk.GetLineLength(i)/Q;return Kk.SegmentizeLineBySegmentLength(i,Z)}static GetLineSegments(k){const Q=[];for(let i=0;i<k.length-1;i++){const Z=k[i],U=k[i+1],C=U.EQ(Z).length();Q.push({point1:Z,point2:U,length:C})}return Q}static GetMinMaxSegmentLength(k){const Q=Kk.GetLineSegments(k).sort((k=>k.length));return{min:Q[0].length,max:Q[Q.length-1].length}}static GetPositionOnLineByVisibility(k,Q,i){let U=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const C=Q*i;let B=0,o=0;const m=k.length;for(let Z=0;Z<m;Z++){if(C<=B+k[Z].length){o=Z;break}B+=k[Z].length}const O=(C-B)/k[o].length;return k[o].point2.subtractToRef(k[o].point1,Z.TmpVectors.zQ[0]),Z.TmpVectors.zQ[1]=Z.TmpVectors.zQ[0].multiplyByFloats(O,O,O),U||Z.TmpVectors.zQ[1].addInPlace(k[o].point1),Z.TmpVectors.zQ[1].clone()}static GetCircleLinePoints(k,Q){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k,C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/Q;const B=[];for(let o=0;o<=Q;o++)B.push(new Z.zQ(Math.cos(o*C)*k,Math.sin(o*C)*U,i));return B}static GetBezierLinePoints(k,Q,i,Z){return jk.f.CreateQuadraticBezier(k,Q,i,Z).getPoints().flatMap((k=>[k.x,k.y,k.z]))}static GetArrowCap(k,Q,i,Z,U){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,B=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[k.clone(),k.add(Q.multiplyByFloats(i,i,i))],widths:[Z,U,C,B]}}static GetPointsFromText(k,Q,i,Z){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const B=[],o=(0,Tk.c)(k,Q,i,Z);for(const m of o){for(const k of m.paths){const Q=[],i=k.getPoints();for(const k of i)Q.push(k.x,k.y,U);B.push(Q)}if(C)for(const k of m.holes){const Q=[],i=k.getPoints();for(const k of i)Q.push(k.x,k.y,U);B.push(Q)}}return B}static Color3toRGBAUint8(k){const Q=new Uint8Array(4*k.length);for(let i=0,Z=0;i<k.length;i++)Q[Z++]=255*k[i].r,Q[Z++]=255*k[i].g,Q[Z++]=255*k[i].b,Q[Z++]=255;return Q}static CreateColorsTexture(k,Q,i,Z){const U=Z.getEngine().getCaps().maxTextureSize??1,C=Q.length>U?U:Q.length,B=Math.ceil(Q.length/U);B>1&&(Q=[...Q,...Array(C*B-Q.length).fill(Q[0])]);const o=Kk.Color3toRGBAUint8(Q),m=new y.c(o,C,B,F.b.TEXTUREFORMAT_RGBA,Z,!1,!0,i);return m.name=k,m}static PrepareEmptyColorsTexture(k){if(!ak.EmptyColorsTexture){const Q=new Uint8Array(4);ak.EmptyColorsTexture=new y.c(Q,1,1,F.b.TEXTUREFORMAT_RGBA,k,!1,!1,y.c.NEAREST_NEAREST),ak.EmptyColorsTexture.name="grlEmptyColorsTexture"}return ak.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var k;null===(k=ak.EmptyColorsTexture)||void 0===k||k.dispose(),ak.EmptyColorsTexture=null}static BooleanToNumber(k){return k?1:0}}class vk extends sk.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Nk extends Lk.d{isCompatible(k){return!0}constructor(k,Q,i){var U;i=i||{color:ak.DEFAULT_COLOR};const C=new vk;C.GREASED_LINE_HAS_COLOR=!!i.color&&!i.useColors,C.GREASED_LINE_SIZE_ATTENUATION=i.sizeAttenuation??!1,C.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===i.colorDistributionType,C.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(Q??k.sk()).useRightHandedSystem,C.GREASED_LINE_CAMERA_FACING=i.cameraFacing??!0,super(k,Nk.GREASED_LINE_MATERIAL_NAME,200,C,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(U=i)||void 0===U?void 0:U.forceGLSL)||Nk.ForceGLSL,this._scene=Q??k.sk(),this._engine=this._scene.getEngine(),this._cameraFacing=i.cameraFacing??!0,this.visibility=i.visibility??1,this.useDash=i.useDash??!1,this.dashRatio=i.dashRatio??.5,this.dashOffset=i.dashOffset??0,this.width=i.width?i.width:i.sizeAttenuation?ak.DEFAULT_WIDTH_ATTENUATED:ak.DEFAULT_WIDTH,this._sizeAttenuation=i.sizeAttenuation??!1,this.colorMode=i.colorMode??0,this._color=i.color??null,this.useColors=i.useColors??!1,this._colorsDistributionType=i.colorDistributionType??0,this.colorsSampling=i.colorsSampling??y.c.NEAREST_NEAREST,this._colors=i.Tk??null,this.dashCount=i.dashCount??1,this.resolution=i.resolution??new Z.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),i.colorsTexture?this.colorsTexture=i.colorsTexture:this._colors?this.colorsTexture=Kk.CreateColorsTexture(`${k.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??ak.DEFAULT_COLOR,Kk.PrepareEmptyColorsTexture(this._scene)),this._engine.gi.add((()=>{Kk.DisposeEmptyColorsTexture()}))}getAttributes(k){k.push("grl_offsets"),k.push("grl_widths"),k.push("grl_colorPointers"),k.push("grl_counters"),this._cameraFacing?(k.push("grl_previousAndSide"),k.push("grl_nextAndCounters")):k.push("grl_slopes")}getSamplers(k){k.push("grl_colors")}getActiveTextures(k){this.colorsTexture&&k.push(this.colorsTexture)}getUniforms(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const Q=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&Q.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===k&&Q.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:Q,vertex:this._cameraFacing&&this._isGLSL(k)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(k)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(k){if(this._cameraFacing){k.Bo("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||k.Bo("viewProjection",this._scene.getTransformMatrix());const Q=Z.TmpVectors.Vector4[0];Q.x=this._aspect,Q.y=this._resolution.x,Q.z=this._resolution.y,Q.w=this.width,k.updateVector4("grl_aspect_resolution_lineWidth",Q)}const Q=Z.TmpVectors.Vector4[0];Q.x=Kk.BooleanToNumber(this.useDash),Q.y=this._dashArray,Q.z=this.dashOffset,Q.w=this.dashRatio,k.updateVector4("grl_dashOptions",Q);const i=Z.TmpVectors.Vector4[1];i.x=this.colorMode,i.y=this.visibility,i.z=this.colorsTexture?this.colorsTexture.getSize().width:0,i.w=Kk.BooleanToNumber(this.useColors),k.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",i),this._color&&k.updateColor3("grl_singleColor",this._color);const U=this.colorsTexture??ak.EmptyColorsTexture;k.setTexture("grl_colors",U),k.updateFloat2("grl_textureSize",(null===U||void 0===U?void 0:U.getSize().width)??1,(null===U||void 0===U?void 0:U.getSize().height)??1)}prepareDefines(k,Q,i){k.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,k.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,k.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,k.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=Q.useRightHandedSystem,k.GREASED_LINE_CAMERA_FACING=this._cameraFacing,k.GREASED_LINE_USE_OFFSETS=!!i.offsets}getClassName(){return Nk.GREASED_LINE_MATERIAL_NAME}getCustomCode(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(Q)?function(k,Q){if("vertex"===k){const k={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return Q&&(k["!gl_Position\\=viewProjection\\*worldPos;"]="//"),k}return"fragment"===k?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(k,this._cameraFacing):function(k,Q){if("vertex"===k){const k={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return Q&&(k["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),k}return"fragment"===k?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(k,this._cameraFacing)}dispose(){var k;null===(k=this.colorsTexture)||void 0===k||k.dispose(),super.dispose()}get Tk(){return this._colors}set Tk(k){this.setColors(k)}setColors(k){var Q;let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const U=(null===(Q=this._colors)||void 0===Q?void 0:Q.length)??0;var C;if(this._colors=k,null!==k&&0!==k.length){if(!i||Z)if(this.colorsTexture&&U===k.length&&!Z){const Q=Kk.Color3toRGBAUint8(k);this.colorsTexture.update(Q)}else{var B;null===(B=this.colorsTexture)||void 0===B||B.dispose(),this.colorsTexture=Kk.CreateColorsTexture(`${this._material.name}-colors-texture`,k,this.colorsSampling,this._scene)}}else null===(C=this.colorsTexture)||void 0===C||C.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(k){this._dashCount=k,this._dashArray=1/k}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(k){this._sizeAttenuation=k,this.markAllDefinesAsDirty()}get color(){return this._color}set color(k){this.setColor(k)}setColor(k){let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==k||null!==this._color&&null===k?(this._color=k,Q||this.markAllDefinesAsDirty()):this._color=k}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(k){this._colorsDistributionType=k,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(k){this._aspect=k.x/k.y,this._resolution=k}serialize(){const k=super.serialize(),Q={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(Q.Tk=this._colors),this._color&&(Q.color=this._color),k.greasedLineMaterialOptions=Q,k}parse(k,Q,i){var Z;super.parse(k,Q,i);const U=k.greasedLineMaterialOptions;null===(Z=this.colorsTexture)||void 0===Z||Z.dispose(),U.color&&this.setColor(U.color,!0),U.colorDistributionType&&(this.colorsDistributionType=U.colorDistributionType),U.Tk&&(this.Tk=U.Tk),U.colorsSampling&&(this.colorsSampling=U.colorsSampling),U.colorMode&&(this.colorMode=U.colorMode),U.useColors&&(this.useColors=U.useColors),U.visibility&&(this.visibility=U.visibility),U.useDash&&(this.useDash=U.useDash),U.dashCount&&(this.dashCount=U.dashCount),U.dashRatio&&(this.dashRatio=U.dashRatio),U.dashOffset&&(this.dashOffset=U.dashOffset),U.width&&(this.width=U.width),U.sizeAttenuation&&(this.sizeAttenuation=U.sizeAttenuation),U.resolution&&(this.resolution=U.resolution),this.Tk?this.colorsTexture=Kk.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Tk,this.colorsSampling,Q):Kk.PrepareEmptyColorsTexture(Q),this.markAllDefinesAsDirty()}copyTo(k){var Q;const i=k;null===(Q=i.colorsTexture)||void 0===Q||Q.dispose(),this._colors&&(i.colorsTexture=Kk.CreateColorsTexture(`${i._material.name}-colors-texture`,this._colors,i.colorsSampling,this._scene)),i.setColor(this.color,!0),i.colorsDistributionType=this.colorsDistributionType,i.colorsSampling=this.colorsSampling,i.colorMode=this.colorMode,i.useColors=this.useColors,i.visibility=this.visibility,i.useDash=this.useDash,i.dashCount=this.dashCount,i.dashRatio=this.dashRatio,i.dashOffset=this.dashOffset,i.width=this.width,i.sizeAttenuation=this.sizeAttenuation,i.resolution=this.resolution,i.markAllDefinesAsDirty()}_isGLSL(k){return 0===k||this._forceGLSL}}Nk.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Nk.ForceGLSL=!1,(0,uk.e)(`BABYLON.${Nk.GREASED_LINE_MATERIAL_NAME}`,Nk);var Xk=i(11715),pk=i(11142),dk=i(11535),bk=i(11242);class Dk extends dk.ShaderMaterial{constructor(k,Q,U){const C=Q.getEngine(),B=C.isWebGPU&&!(U.forceGLSL||Dk.ForceGLSL),o=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];Q.useRightHandedSystem&&o.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const m=["position","grl_widths","grl_offsets","grl_colorPointers"];U.cameraFacing?(o.push("GREASED_LINE_CAMERA_FACING"),m.push("grl_previousAndSide","grl_nextAndCounters")):(m.push("grl_slopes"),m.push("grl_counters"));const O=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(B||O.push("world","viewProjection","view","projection"),super(k,Q,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:B?["Scene","Mesh"]:void 0,attributes:m,uniforms:O,samplers:B?[]:["grlColors"],defines:o,extraInitializationsAsync:async()=>{B?await Promise.all([i.e(66).then(i.bind(i,14458)),i.e(75).then(i.bind(i,14462))]):await Promise.all([i.e(69).then(i.bind(i,14470)),i.e(76).then(i.bind(i,14473))])},shaderLanguage:B?1:0}),this._color=E.cQ.White(),this._colorsDistributionType=0,this._colorsTexture=null,U=U||{color:ak.DEFAULT_COLOR},this.visibility=U.visibility??1,this.useDash=U.useDash??!1,this.dashRatio=U.dashRatio??.5,this.dashOffset=U.dashOffset??0,this.dashCount=U.dashCount??1,this.width=U.width?U.width:U.sizeAttenuation&&U.cameraFacing?ak.DEFAULT_WIDTH_ATTENUATED:ak.DEFAULT_WIDTH,this.sizeAttenuation=U.sizeAttenuation??!1,this.color=U.color??E.cQ.White(),this.useColors=U.useColors??!1,this.colorsDistributionType=U.colorDistributionType??0,this.colorsSampling=U.colorsSampling??y.c.NEAREST_NEAREST,this.colorMode=U.colorMode??0,this._colors=U.Tk??null,this._cameraFacing=U.cameraFacing??!0,this.resolution=U.resolution??new Z.Vector2(C.getRenderWidth(),C.getRenderHeight()),U.colorsTexture?this.colorsTexture=U.colorsTexture:this._colors?this.colorsTexture=Kk.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,Q):(this._color=this._color??ak.DEFAULT_COLOR,this.colorsTexture=Kk.PrepareEmptyColorsTexture(Q)),B){const k=new bk.d;k.setParameters(),k.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",k)}C.gi.add((()=>{Kk.DisposeEmptyColorsTexture()}))}dispose(){var k;null===(k=this._colorsTexture)||void 0===k||k.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new Z.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Tk(){return this._colors}set Tk(k){this.setColors(k)}setColors(k){var Q;let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const U=(null===(Q=this._colors)||void 0===Q?void 0:Q.length)??0;var C;if(this._colors=k,null!==k&&0!==k.length){if(!i||Z)if(this._colorsTexture&&U===k.length&&!Z){const Q=Kk.Color3toRGBAUint8(k);this._colorsTexture.update(Q)}else{var B;null===(B=this._colorsTexture)||void 0===B||B.dispose(),this.colorsTexture=Kk.CreateColorsTexture(`${this.name}-colors-texture`,k,this.colorsSampling,this.sk())}}else null===(C=this._colorsTexture)||void 0===C||C.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(k){this._colorsTexture=k,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(k){this._width=k,this.setFloat("grlWidth",k)}get useColors(){return this._useColors}set useColors(k){this._useColors=k,this.setFloat("grlUseColors",Kk.BooleanToNumber(k))}get colorsSampling(){return this._colorsSampling}set colorsSampling(k){this._colorsSampling=k}get visibility(){return this._visibility}set visibility(k){this._visibility=k,this.setFloat("grlVisibility",k)}get useDash(){return this._useDash}set useDash(k){this._useDash=k,this.setFloat("grlUseDash",Kk.BooleanToNumber(k))}get dashOffset(){return this._dashOffset}set dashOffset(k){this._dashOffset=k,this.setFloat("grlDashOffset",k)}get dashRatio(){return this._dashRatio}set dashRatio(k){this._dashRatio=k,this.setFloat("grlDashRatio",k)}get dashCount(){return this._dashCount}set dashCount(k){this._dashCount=k,this._dashArray=1/k,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(k){this._sizeAttenuation=k,this.setFloat("grlSizeAttenuation",Kk.BooleanToNumber(k))}get color(){return this._color}set color(k){this.setColor(k)}setColor(k){k=k??ak.DEFAULT_COLOR,this._color=k,this.setColor3("grlColor",k)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(k){this._colorsDistributionType=k,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(k){this._colorMode=k,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(k){this._resolution=k,this.setVector2("grlResolution",k),this.setFloat("grlAspect",k.x/k.y)}serialize(){const k=super.serialize(),Q={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(Q.Tk=this._colors),k.greasedLineMaterialOptions=Q,k}parse(k,Q,i){var Z;const U=k.greasedLineMaterialOptions;null===(Z=this._colorsTexture)||void 0===Z||Z.dispose(),U.color&&(this.color=U.color),U.colorDistributionType&&(this.colorsDistributionType=U.colorDistributionType),U.colorsSampling&&(this.colorsSampling=U.colorsSampling),U.colorMode&&(this.colorMode=U.colorMode),U.useColors&&(this.useColors=U.useColors),U.visibility&&(this.visibility=U.visibility),U.useDash&&(this.useDash=U.useDash),U.dashCount&&(this.dashCount=U.dashCount),U.dashRatio&&(this.dashRatio=U.dashRatio),U.dashOffset&&(this.dashOffset=U.dashOffset),U.width&&(this.width=U.width),U.sizeAttenuation&&(this.sizeAttenuation=U.sizeAttenuation),U.resolution&&(this.resolution=U.resolution),U.Tk?this.colorsTexture=Kk.CreateColorsTexture(`${this.name}-colors-texture`,U.Tk,this.colorsSampling,this.sk()):this.colorsTexture=Kk.PrepareEmptyColorsTexture(Q),this._cameraFacing=U.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Mk,Wk,Ak;Dk.ForceGLSL=!1,function(k){k[k.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",k[k.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Mk||(Mk={})),function(k){k[k.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",k[k.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",k[k.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Wk||(Wk={})),function(k){k[k.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",k[k.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",k[k.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",k[k.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",k[k.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Ak||(Ak={}));class gk extends hk.d{constructor(k,Q,i){super(k,Q,null,null,!1,!1),this.name=k,this._options=i,this._lazy=!1,this._updatable=!1,this._engine=Q.getEngine(),this._lazy=i.lazy??!1,this._updatable=i.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=i.colorPointers??[],this._widths=i.widths??new Array(i.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(k){let Q=0;for(const Z of this._points)Q+=Z.length;const i=Q/3*2-this._widths.length;for(let Z=0;Z<i;Z++)this._widths.push(k)}updateLazy(){var k,Q;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(k=this._options.ribbonOptions)||void 0===k?void 0:k.smoothShading),!this.Xk&&this.refreshBoundingInfo(),null===(Q=this.greasedLineMaterial)||void 0===Q||Q.updateLazy()}addPoints(k,Q){for(const i of k)this._points.push(i);this._lazy||this.setPoints(this._points,Q)}dispose(k){let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(k,Q)}isLazy(){return this._lazy}get Kk(){return this._uvs}set Kk(k){this._uvs=k instanceof Float32Array?k:new Float32Array(k),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(k){this.material instanceof Dk&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===k||void 0===k?void 0:k.length)>0),this._offsets=k,this._offsetsBuffer?this._offsetsBuffer.update(k):this._createOffsetsBuffer(k)}get widths(){return this._widths}set widths(k){this._widths=k,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(k)}get colorPointers(){return this._colorPointers}set colorPointers(k){this._colorPointers=k,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(k)}get greasedLineMaterial(){var k,Q;if(this.material&&this.material instanceof Dk)return this.material;const i=null===(k=this.material)||void 0===k||null===(Q=k.pluginManager)||void 0===Q?void 0:Q.getPlugin(Nk.GREASED_LINE_MATERIAL_NAME);return i||void 0}get points(){const k=[];return pk.b.DeepCopy(this._points,k),k}setPoints(k,Q){this._points=Kk.ConvertPoints(k,(null===Q||void 0===Q?void 0:Q.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==Q&&void 0!==Q&&Q.colorPointers||this._updateColorPointers(),this._setPoints(this._points,Q)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Kk:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(k){super.serialize(k),k.type=this.getClassName(),k.lineOptions=this._createLineOptions()}_createVertexBuffers(){let k=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Q=new Xk.d;return Q.ak=this._vertexPositions,Q.indices=this._indices,Q.Kk=this._uvs,k&&(Q.jk=[],Xk.d.ComputeNormals(this._vertexPositions,this._indices,Q.jk)),Q.Nk(this,this._options.updatable),Q}_createOffsetsBuffer(k){const Q=this._scene.getEngine(),i=new J.d(Q,k,this._updatable,3);this.setVerticesBuffer(i.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=i}}class Rk{constructor(k,Q){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=k,this.wasAddedByNoopNode=Q}getIndicesAccessor(k,Q,i,Z,U){var C,B,o,m;return null===(C=this._indicesAccessorMap.get(k))||void 0===C||null===(B=C.get(Q))||void 0===B||null===(o=B.get(i))||void 0===o||null===(m=o.get(Z))||void 0===m?void 0:m.get(U)}setIndicesAccessor(k,Q,i,Z,U,C){let B=this._indicesAccessorMap.get(k);B||(B=new Map,this._indicesAccessorMap.set(k,B));let o=B.get(Q);o||(o=new Map,B.set(Q,o));let m=o.get(i);m||(m=new Map,o.set(i,m));let O=m.get(Z);O||(O=new Map,m.set(Z,O)),O.set(U,C)}pushExportedNode(k){this._exportedNodes.has(k)||this._exportedNodes.add(k)}getNodesSet(){return this._exportedNodes}getVertexBufferView(k){return this._vertexBufferViewMap.get(k)}setVertexBufferView(k,Q){this._vertexBufferViewMap.set(k,Q)}setRemappedBufferView(k,Q,i){this._remappedBufferView.set(k,new Map),this._remappedBufferView.get(k).set(Q,i)}getRemappedBufferView(k,Q){var i;return null===(i=this._remappedBufferView.get(k))||void 0===i?void 0:i.get(Q)}getVertexAccessor(k,Q,i){var Z,U;return null===(Z=this._vertexAccessorMap.get(k))||void 0===Z||null===(U=Z.get(Q))||void 0===U?void 0:U.get(i)}setVertexAccessor(k,Q,i,Z){let U=this._vertexAccessorMap.get(k);U||(U=new Map,this._vertexAccessorMap.set(k,U));let C=U.get(Q);C||(C=new Map,U.set(Q,C)),C.set(i,Z)}hasVertexColorAlpha(k){return this._vertexMapColorAlpha.get(k)||!1}setHasVertexColorAlpha(k,Q){return this._vertexMapColorAlpha.set(k,Q)}getMesh(k){return this._meshMap.get(k)}setMesh(k,Q){this._meshMap.set(k,Q)}bindMorphDataToMesh(k,Q){const i=this._meshMorphTargetMap.get(k)||[];this._meshMorphTargetMap.set(k,i),-1===i.indexOf(Q)&&i.push(Q)}getMorphTargetsFromMesh(k){return this._meshMorphTargetMap.get(k)}}class wk{_ApplyExtension(k,Q,i,Z){if(i>=Q.length)return Promise.resolve(k);const U=Z(Q[i],k);return U?U.then((async k=>k?await this._ApplyExtension(k,Q,i+1,Z):null)):this._ApplyExtension(k,Q,i+1,Z)}_ApplyExtensions(k,Q){const i=[];for(const Z of wk._ExtensionNames)i.push(this._extensions[Z]);return this._ApplyExtension(k,i,0,Q)}_extensionsPreExportTextureAsync(k,Q,i){return this._ApplyExtensions(Q,((Q,Z)=>Q.preExportTextureAsync&&Q.preExportTextureAsync(k,Z,i)))}_extensionsPostExportNodeAsync(k,Q,i,Z,U){return this._ApplyExtensions(Q,((Q,C)=>Q.postExportNodeAsync&&Q.postExportNodeAsync(k,C,i,Z,U,this._bufferManager)))}_extensionsPostExportMaterialAsync(k,Q,i){return this._ApplyExtensions(Q,((Q,Z)=>Q.postExportMaterialAsync&&Q.postExportMaterialAsync(k,Z,i)))}_extensionsPostExportMaterialAdditionalTextures(k,Q,i){const Z=[];for(const U of wk._ExtensionNames){const C=this._extensions[U];C.postExportMaterialAdditionalTextures&&Z.push(...C.postExportMaterialAdditionalTextures(k,Q,i))}return Z}_extensionsPostExportTextures(k,Q,i){for(const Z of wk._ExtensionNames){const U=this._extensions[Z];U.postExportTexture&&U.postExportTexture(k,Q,i)}}_extensionsPostExportMeshPrimitive(k){for(const Q of wk._ExtensionNames){const i=this._extensions[Q];i.postExportMeshPrimitive&&i.postExportMeshPrimitive(k,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const k of wk._ExtensionNames){const Q=this._extensions[k];Q.preGenerateBinaryAsync&&await Q.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(k){for(const Q of wk._ExtensionNames){const i=this._extensions[Q];i.enabled&&k(i)}}_extensionsOnExporting(){this._forEachExtensions((k=>{var Q,i,Z;k.wasUsed&&((Q=this._glTF).extensionsUsed||(Q.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(k.name)&&this._glTF.extensionsUsed.push(k.name),k.required&&((i=this._glTF).extensionsRequired||(i.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(k.name)&&this._glTF.extensionsRequired.push(k.name)),(Z=this._glTF).extensions||(Z.extensions={}),k.onExporting&&k.onExporting())}))}_loadExtensions(){for(const k of wk._ExtensionNames){const Q=wk._ExtensionFactories[k](this);this._extensions[k]=Q}}constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:z.b.LastCreatedScene,Q=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${F.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new b(this),this._extensions={},this._bufferManager=new Jk,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!k)throw new Error("No scene available to export");this._babylonScene=k,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:k=>{var Q;return null===k||void 0===k||null===(Q=k.XC)||void 0===Q?void 0:Q.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...Q},this._loadExtensions()}dispose(){for(const k in this._extensions){this._extensions[k].dispose()}}get options(){return this._options}static RegisterExtension(k,Q){wk.UnregisterExtension(k)&&U.Tools.Warn(`Extension with the name ${k} already exists`),wk._ExtensionFactories[k]=Q,wk._ExtensionNames.push(k)}static UnregisterExtension(k){if(!wk._ExtensionFactories[k])return!1;delete wk._ExtensionFactories[k];const Q=wk._ExtensionNames.indexOf(k);return-1!==Q&&wk._ExtensionNames.splice(Q,1),!0}_generateJSON(k,Q,i){const Z={byteLength:k};return Z.byteLength&&(this._glTF.buffers=[Z]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.lQ=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(Z.uri=Q+".bin"),i?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(k){const Q=await this._generateBinaryAsync();this._extensionsOnExporting();const i=this._generateJSON(Q.byteLength,k,!0),Z=new Blob([Q],{type:"application/octet-stream"}),U=k+".gltf",C=k+".bin",B=new O;if(B.files[U]=i,B.files[C]=Z,this._imageData)for(const o in this._imageData)B.files[o]=new Blob([this._imageData[o].data],{type:this._imageData[o].mimeType});return B}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(k){const Q=k%4;return 0===Q?Q:4-Q}async generateGLBAsync(k){this._shouldUseGlb=!0;const Q=await this._generateBinaryAsync();this._extensionsOnExporting();const i=this._generateJSON(Q.byteLength),Z=k+".glb";let U,C=i.length;if("undefined"!==typeof TextEncoder){U=(new TextEncoder).encode(i),C=U.length}const B=this._getPadding(C),o=this._getPadding(Q.byteLength),m=28+C+B+Q.byteLength+o,J=new mk(m);if(J.writeUInt32(1179937895),J.writeUInt32(2),J.writeUInt32(m),J.writeUInt32(C+B),J.writeUInt32(1313821514),U)J.writeTypedArray(U);else{const k="_".charCodeAt(0);for(let Q=0;Q<C;++Q){const Z=i.charCodeAt(Q);Z!=i.codePointAt(Q)?J.writeUInt8(k):J.writeUInt8(Z)}}for(let O=0;O<B;++O)J.writeUInt8(32);J.writeUInt32(Q.byteLength+o),J.writeUInt32(5130562),J.writeTypedArray(Q);for(let O=0;O<o;++O)J.writeUInt8(0);const G=new O;return G.files[Z]=new Blob([J.getOutputData()],{type:"application/octet-stream"}),G}_setNodeTransformation(k,Q,i){if(Q.getPivotPoint().equalsWithEpsilon(g,A.e)||U.Tools.Warn("Pivot points are not supported in the glTF serializer"),!Q.position.equalsWithEpsilon(g,A.e)){const U=Z.TmpVectors.zQ[0].B(Q.position);i&&n(U),k.translation=U.Zo()}Q.Ho.equalsWithEpsilon(w,A.e)||(k.scale=Q.Ho.Zo());const C=Q.rotationQuaternion||Z.Quaternion.FromEulerAngles(Q.rotation.x,Q.rotation.y,Q.rotation.z);C.equalsWithEpsilon(R,A.e)||(i&&x(C),k.rotation=C.normalize().Zo())}_setCameraTransformation(k,Q,i){if(!Q.position.equalsWithEpsilon(g,A.e)){const U=Z.TmpVectors.zQ[0].B(Q.position);i&&n(U),k.translation=U.Zo()}const U=Q.rotationQuaternion||Z.Quaternion.FromEulerAngles(Q.rotation.x,Q.rotation.y,Q.rotation.z);i&&x(U),this._babylonScene.useRightHandedSystem||V(U),U.equalsWithEpsilon(R,A.e)||(k.rotation=U.Zo())}_listAvailableCameras(){for(const k of this._babylonScene.cameras){const Q={type:k.mode===Hk.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(k.name&&(Q.name=k.name),"perspective"===Q.type)Q.perspective={aspectRatio:k.getEngine().getAspectRatio(k),yfov:k.fovMode===Hk.e.FOVMODE_VERTICAL_FIXED?k.fov:k.fov*k.getEngine().getAspectRatio(k),znear:k.Co,zfar:k.maxZ};else if("orthographic"===Q.type){const i=k.orthoLeft&&k.orthoRight?.5*(k.orthoRight-k.orthoLeft):.5*k.getEngine().getRenderWidth(),Z=k.orthoBottom&&k.orthoTop?.5*(k.orthoTop-k.orthoBottom):.5*k.getEngine().getRenderHeight();Q.orthographic={xmag:i,ymag:Z,znear:k.Co,zfar:k.maxZ}}this._camerasMap.set(k,Q)}}_exportAndAssignCameras(){const k=Array.from(this._camerasMap.values());for(const Q of k){const k=this._nodesCameraMap.get(Q);if(void 0!==k){this._cameras.push(Q);for(const Q of k)Q.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const k of this._babylonScene.skeletons){if(k.bones.length<=0)continue;const Q={joints:[]};this._skinMap.set(k,Q)}}_exportAndAssignSkeletons(){for(const k of this._babylonScene.skeletons){if(k.bones.length<=0)continue;const Q=this._skinMap.get(k);if(void 0==Q)continue;const i={},Z=[];let C=-1;for(let U=0;U<k.bones.length;++U){const Q=k.bones[U],Z=Q.getIndex()??U;-1!==Z&&(i[Z]=Q,Z>C&&(C=Z))}for(let k=0;k<=C;++k){const C=i[k];Z.push(C.getAbsoluteInverseBindMatrix());const B=C.getTransformNode();if(null!==B){const k=this._nodeMap.get(B);B&&null!==k&&void 0!==k?Q.joints.push(k):U.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else U.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const B=this._nodesSkinMap.get(Q);if(Q.joints.length>0&&void 0!==B){const k=64*Z.length,i=new Float32Array(k/4);Z.forEach(((k,Q)=>{i.set(k.m,16*Q)}));const U=this._bufferManager.createBufferView(i);this._accessors.push(this._bufferManager.createAccessor(U,"MAT4",5126,Z.length)),Q.inverseBindMatrices=this._accessors.length-1,this._skins.push(Q);for(const Q of B)Q.skin=this._skins.length-1}}}async _exportSceneAsync(){const k={nodes:[]};if(this._babylonScene.metadata){const Q=this._options.metadataSelector(this._babylonScene.metadata);Q&&(k.extras=Q)}const Q=new Array,i=new Array,Z=new Array;for(const o of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Bk(o,this._babylonScene.useRightHandedSystem)?Z.push(...o.getChildren()):this._babylonScene.useRightHandedSystem?Q.push(o):i.push(o);this._listAvailableCameras(),this._listAvailableSkeletons();const U=new Rk(!0,!1);k.nodes.push(...await this._exportNodesAsync(i,U));const C=new Rk(!1,!1);k.nodes.push(...await this._exportNodesAsync(Q,C));const B=new Rk(!1,!0);k.nodes.push(...await this._exportNodesAsync(Z,B)),k.nodes.length&&this._scenes.push(k),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&fk._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,U.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(k){let Q=this._shouldExportNodeMap.get(k);return void 0===Q&&(Q=this._options.shouldExportNode(k),this._shouldExportNodeMap.set(k,Q)),Q}async _exportNodesAsync(k,Q){const i=new Array;this._exportBuffers(k,Q);for(const Z of k)await this._exportNodeAsync(Z,i,Q);return i}_collectBuffers(k,Q,i,Z,U){if(this._shouldExportNode(k)&&k instanceof H.d&&k.mo){const C=k.mo.getVertexBuffers();if(C)for(const Z in C){if(!t(Z))continue;const B=C[Z];U.setHasVertexColorAlpha(B,k.hasVertexAlpha);const o=B._buffer,m=Q.get(o)||[];Q.set(o,m),-1===m.indexOf(B)&&m.push(B);const O=i.get(B)||[];i.set(B,O),-1===O.indexOf(k)&&O.push(k)}const B=k.morphTargetManager;if(B)for(let Q=0;Q<B.numTargets;Q++){const i=B.getTarget(Q),U=Z.get(i)||[];Z.set(i,U),-1===U.indexOf(k)&&U.push(k)}}for(const C of k.getChildren())this._collectBuffers(C,Q,i,Z,U)}_exportBuffers(k,Q){const i=new Map,Z=new Map,U=new Map;for(const o of k)this._collectBuffers(o,i,Z,U,Q);const C=Array.from(i.keys());for(const o of C){const k=o.getData();if(!k)throw new Error("Buffer data is not available");const U=i.get(o);if(!U)continue;const C=U[0].byteStride;if(U.some((k=>k.byteStride!==C)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const B=ik(k).slice();for(const Q of U){const k=Z.get(Q),{byteOffset:i,byteStride:U,componentCount:C,type:o,count:m,normalized:O,kind:G}=q(Q,k);switch(G){case J.h.NormalKind:case J.h.TangentKind:(0,D.i)(B,i,U,C,o,m,O,(k=>{const Q=Math.sqrt(k[0]*k[0]+k[1]*k[1]+k[2]*k[2]);if(Q>0){const i=1/Q;k[0]*=i,k[1]*=i,k[2]*=i}}));break;case J.h.ColorKind:{const Q=k.filter((k=>k.material instanceof zk.hQ||null==k.material)).length;if(0==Q)break;if(Q!=k.length){M.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}o==J.h.UNSIGNED_BYTE&&M.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const Z=new E.cQ,G=new E.Fo,H=this._babylonScene.getEngine().useExactSrgbConversions;(0,D.i)(B,i,U,C,o,m,O,(k=>{3===k.length?(Z.Ei(k,0),Z.toLinearSpaceToRef(Z,H),Z.toArray(k,0)):(G.Ei(k,0),G.toLinearSpaceToRef(G,H),G.toArray(k,0))}))}}}if(Q.convertToRightHanded){for(const k of U){const Q=Z.get(k),{byteOffset:i,byteStride:U,componentCount:C,type:o,count:m,normalized:O,kind:G}=q(k,Q);switch(G){case J.h.PositionKind:case J.h.NormalKind:case J.h.TangentKind:(0,D.i)(B,i,U,C,o,m,O,(k=>{k[0]=-k[0]}))}}Q.convertedToRightHandedBuffers.set(o,B)}const m=this._bufferManager.createBufferView(B,C);Q.setVertexBufferView(o,m);const O=new Map;for(const Q of U){const k=Z.get(Q),{kind:i,totalVertices:U}=q(Q,k);switch(i){case J.h.MatricesIndicesKind:case J.h.MatricesIndicesExtraKind:if(Q.type==J.h.FLOAT){const k=Q.getFloatData(U);null!==k&&O.set(Q,k)}}}0!==O.size&&M.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const G=Array.from(O.keys());for(const i of G){const k=O.get(i);if(!k)continue;const Z=k.some((k=>k>=256)),U=new(Z?Uint16Array:Uint8Array)(k.length);for(let Q=0;Q<k.length;Q++)U[Q]=k[Q];const C=this._bufferManager.createBufferView(U,4*(Z?2:1));Q.setRemappedBufferView(o,i,C)}}const B=Array.from(U.keys());for(const o of B){const k=U.get(o);if(!k)continue;const i=Yk(o,k[0],this._bufferManager,this._bufferViews,this._accessors,Q.convertToRightHanded);for(const Z of k)Q.bindMorphDataToMesh(Z,i)}}async _exportNodeAsync(k,Q,i){let Z=this._nodeMap.get(k);if(void 0!==Z)return void(Q.includes(Z)||Q.push(Z));const U=await this._createNodeAsync(k,i);if(U){Z=this._nodes.length,this._nodes.push(U),this._nodeMap.set(k,Z),i.pushExportedNode(k),Q.push(Z);const C={name:"runtime animations",channels:[],samplers:[]},B=[];this._babylonScene.animationGroups.length||(fk._CreateMorphTargetAnimationFromMorphTargetAnimations(k,C,B,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,i.convertToRightHanded,this._options.shouldExportAnimation),k.animations.length&&fk._CreateNodeAnimationFromNodeAnimations(k,C,B,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,i.convertToRightHanded,this._options.shouldExportAnimation)),C.channels.length&&C.samplers.length&&this._animations.push(C),B.forEach((k=>{k.channels.length&&k.samplers.length&&this._animations.push(k)}))}const C=U?[]:Q;for(const B of k.getChildren())await this._exportNodeAsync(B,C,i);U&&C.length&&(U.children=C)}async _createNodeAsync(k,Q){if(!this._shouldExportNode(k))return null;const i={};if(k.name&&(i.name=k.name),k.metadata){const Q=this._options.metadataSelector(k.metadata);Q&&(i.extras=Q)}if(k instanceof G.d&&(this._setNodeTransformation(i,k,Q.convertToRightHanded),k instanceof H.d)){const U=k instanceof e.d?k.sourceMesh:k;if(U.io&&U.io.length>0&&(i.mesh=await this._exportMeshAsync(U,Q)),k.skeleton){const Q=this._skinMap.get(k.skeleton);var Z;if(void 0!==Q)void 0===this._nodesSkinMap.get(Q)&&this._nodesSkinMap.set(Q,[]),null===(Z=this._nodesSkinMap.get(Q))||void 0===Z||Z.push(i)}}if(k instanceof W.c){const Z=this._camerasMap.get(k);if(Z){var U;void 0===this._nodesCameraMap.get(Z)&&this._nodesCameraMap.set(Z,[]),this._setCameraTransformation(i,k,Q.convertToRightHanded);const B=k.parent;if(null!==B&&Qk(k,B)){const k=this._nodeMap.get(B);if(void 0!==k){var C;const Q=this._nodes[k];return kk(i,Q),null===(C=this._nodesCameraMap.get(Z))||void 0===C||C.push(Q),null}}null===(U=this._nodesCameraMap.get(Z))||void 0===U||U.push(i)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",i,k,this._nodeMap,Q.convertToRightHanded)?i:(M.c.Warn(`Not exporting node ${k.name}`),null)}_exportIndices(k,Q,i,Z,U,B,o,m,O){let J=k;O.mode=I(B);const G=o!==C.c.CounterClockWiseSideOrientation,H=!m.wasAddedByNoopNode&&G,e=function(k){switch(k){case C.c.TriangleFillMode:case C.c.TriangleStripDrawMode:case C.c.TriangleFanDrawMode:return!0}return!1}(B)&&H;if(e){if(B===C.c.TriangleStripDrawMode||B===C.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");O.mode=I(B);const o=Q?new Uint32Array(Z):new Uint16Array(Z);if(k)for(let Q=0;Q+2<Z;Q+=3)o[Q]=k[i+Q]+U,o[Q+1]=k[i+Q+2]+U,o[Q+2]=k[i+Q+1]+U;else for(let k=0;k+2<Z;k+=3)o[k]=k,o[k+1]=k+2,o[k+2]=k+1;J=o}else if(k&&0!==U){const C=Q?new Uint32Array(Z):new Uint16Array(Z);for(let Q=0;Q<Z;Q++)C[Q]=k[i+Q]+U;J=C}if(J){let C=m.getIndicesAccessor(k,i,Z,U,e);if(void 0===C){const B=function(k,Q,i,Z){if(k instanceof Uint16Array||k instanceof Uint32Array)return k;if(k instanceof Int32Array)return new Uint32Array(k.buffer,k.byteOffset,k.length);const U=k.slice(Q,Q+i);return Z?new Uint32Array(U):new Uint16Array(U)}(J,0,Z,Q),o=this._bufferManager.createBufferView(B),O=Q?5125:5123;this._accessors.push(this._bufferManager.createAccessor(o,"SCALAR",O,Z,0)),C=this._accessors.length-1,m.setIndicesAccessor(k,i,Z,U,e,C)}O.indices=C}}_exportVertexBuffer(k,Q,i,Z,U,C){const B=k.getKind();if(!t(B))return;if(B.startsWith("uv")&&!this._options.exportUnusedUVs&&(!Q||!this._materialNeedsUVsSet.has(Q)))return;let o=U.getVertexAccessor(k,i,Z);if(void 0===o){const Q=U.convertedToRightHandedBuffers.get(k._buffer)||k._buffer.getData(),C=B===J.h.PositionKind?function(k,Q,i,Z){const{byteOffset:U,byteStride:C,type:B,normalized:o}=Q,m=Q.getSize(),O=new Array(m).fill(1/0),J=new Array(m).fill(-1/0);return(0,D.i)(k,U+i*C,C,m,B,Z*m,o,(k=>{for(let Q=0;Q<m;Q++)O[Q]=Math.min(O[Q],k[Q]),J[Q]=Math.max(J[Q],k[Q])})),{min:O,max:J}}(Q,k,i,Z):void 0,m=(B===J.h.MatricesIndicesKind||B===J.h.MatricesIndicesExtraKind)&&k.type===J.h.FLOAT,O=m?J.h.UNSIGNED_BYTE:k.type,G=m?void 0:k.normalized,H=m?U.getRemappedBufferView(k._buffer,k):U.getVertexBufferView(k._buffer),e=k.byteOffset+i*k.byteStride;this._accessors.push(this._bufferManager.createAccessor(H,function(k,Q){if(k==J.h.ColorKind)return Q?"VEC4":"VEC3";switch(k){case J.h.PositionKind:case J.h.NormalKind:return"VEC3";case J.h.TangentKind:case J.h.MatricesIndicesKind:case J.h.MatricesIndicesExtraKind:case J.h.MatricesWeightsKind:case J.h.MatricesWeightsExtraKind:return"VEC4";case J.h.UVKind:case J.h.UV2Kind:case J.h.UV3Kind:case J.h.UV4Kind:case J.h.UV5Kind:case J.h.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${k}`)}(B,U.hasVertexColorAlpha(k)),O,Z,e,C,G)),o=this._accessors.length-1,U.setVertexAccessor(k,i,Z,o)}C.attributes[function(k){switch(k){case J.h.PositionKind:return"POSITION";case J.h.NormalKind:return"NORMAL";case J.h.TangentKind:return"TANGENT";case J.h.ColorKind:return"COLOR_0";case J.h.UVKind:return"TEXCOORD_0";case J.h.UV2Kind:return"TEXCOORD_1";case J.h.UV3Kind:return"TEXCOORD_2";case J.h.UV4Kind:return"TEXCOORD_3";case J.h.UV5Kind:return"TEXCOORD_4";case J.h.UV6Kind:return"TEXCOORD_5";case J.h.MatricesIndicesKind:return"JOINTS_0";case J.h.MatricesIndicesExtraKind:return"JOINTS_1";case J.h.MatricesWeightsKind:return"WEIGHTS_0";case J.h.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${k}`)}(B)]=o}async _exportMaterialAsync(k,Q,i,Z){let U=this._materialMap.get(k);if(void 0===U){const Z=Q&&Object.keys(Q).some((k=>k.startsWith("uv")));if((k=k instanceof ek.c?k.zo[i.materialIndex]:k)instanceof Fk.c)U=await this._materialExporter.exportPBRMaterialAsync(k,"image/png",Z);else{if(!(k instanceof zk.hQ))return void M.c.Warn(`Unsupported material '${k.name}' with type ${k.getClassName()}`);U=await this._materialExporter.exportStandardMaterialAsync(k,"image/png",Z)}this._materialMap.set(k,U)}Z.material=U}async _exportMeshAsync(k,Q){var i;let Z=Q.getMesh(k);if(void 0!==Z)return Z;const U={primitives:[]};Z=this._meshes.length,this._meshes.push(U),Q.setMesh(k,Z);const B=k.isUnIndexed?null:k.Oo(),o=null===(i=k.mo)||void 0===i?void 0:i.getVertexBuffers(),m=Q.getMorphTargetsFromMesh(k),O=k instanceof yk.d,J=k instanceof gk,G=k.io;if(o&&G&&G.length>0)for(const F of G){const i={attributes:{}},Z=F.Dk()||this._babylonScene.defaultMaterial;if(J){var H,e;const Q={name:Z.name},U=k,C=E.cQ.White(),B=(null===(H=U.material)||void 0===H?void 0:H.alpha)??1,o=(null===(e=U.greasedLineMaterial)||void 0===e?void 0:e.color)??C;(!o.equalsWithEpsilon(C,A.e)||B<1)&&(Q.pbrMetallicRoughness={baseColorFactor:[...o.Zo(),B]}),this._materials.push(Q),i.material=this._materials.length-1}else if(O){const Q={name:Z.name},U=k;(!U.color.equalsWithEpsilon(E.cQ.White(),A.e)||U.alpha<1)&&(Q.pbrMetallicRoughness={baseColorFactor:[...U.color.Zo(),U.alpha]}),this._materials.push(Q),i.material=this._materials.length-1}else await this._exportMaterialAsync(Z,o,F,i);const G=O||J?C.c.LineListDrawMode:k.overrideRenderingFillMode??Z.fillMode,z=Z._getEffectiveOrientation(k);this._exportIndices(B,B?(0,D.c)(B,F.indexCount,F.indexStart,F.verticesStart):F.verticesCount>65535,B?F.indexStart:F.verticesStart,B?F.indexCount:F.verticesCount,-F.verticesStart,G,z,Q,i);for(const k of Object.values(o))this._exportVertexBuffer(k,Z,F.verticesStart,F.verticesCount,Q,i);if(m){i.targets=[];for(const k of m)i.targets.push(k.attributes)}U.primitives.push(i),this._extensionsPostExportMeshPrimitive(i)}if(m){U.weights=[],U.extras||(U.extras={}),U.extras.targetNames=[];for(const k of m)U.weights.push(k.influence),U.extras.targetNames.push(k.name)}return Z}}wk._ExtensionNames=new Array,wk._ExtensionFactories={};class Sk{static async GLTFAsync(k,Q,i){i&&i.exportWithoutWaitingForScene||await k.whenReadyAsync();const Z=new wk(k,i),U=await Z.generateGLTFAsync(Q.replace(/\.[^/.]+$/,""));return Z.dispose(),U}static async GLBAsync(k,Q,i){i&&i.exportWithoutWaitingForScene||await k.whenReadyAsync();const Z=new wk(k,i),U=await Z.generateGLBAsync(Q.replace(/\.[^/.]+$/,""));return Z.dispose(),U}}i(11852);const qk="EXT_mesh_gpu_instancing";class Pk{constructor(k){this.name=qk,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(k,Q,i,U,C,B){return await new Promise((k=>{if(Q&&i instanceof hk.d&&i.hasThinInstances&&this._exporter){this._wasUsed=!0;const k=Z.zQ.Zero(),U=Z.Quaternion.Identity(),o=Z.zQ.One(),m=i.thinInstanceGetWorldMatrices(),O=Z.TmpVectors.zQ[2],J=Z.TmpVectors.Quaternion[1],G=Z.TmpVectors.zQ[3];let H=!1,e=!1,F=!1;const z=new Float32Array(3*i.Eo),E=new Float32Array(4*i.Eo),l=new Float32Array(3*i.Eo);let h=0;for(const Q of m)Q.decompose(G,J,O),C&&(n(O),x(J)),z.set(O.Zo(),3*h),E.set(J.normalize().Zo(),4*h),l.set(G.Zo(),3*h),H=H||!O.equalsWithEpsilon(k),e=e||!J.equalsWithEpsilon(U),F=F||!G.equalsWithEpsilon(o),h++;const c={attributes:{}};H&&(c.attributes.TRANSLATION=this._buildAccessor(z,"VEC3",i.Eo,B)),e&&(c.attributes.ROTATION=this._buildAccessor(E,"VEC4",i.Eo,B)),F&&(c.attributes.SCALE=this._buildAccessor(l,"VEC3",i.Eo,B)),Q.extensions=Q.extensions||{},Q.extensions[qk]=c}k(Q)}))}_buildAccessor(k,Q,i,Z){const U=Z.createBufferView(k),C=Z.createAccessor(U,Q,5126,i);return this._exporter._accessors.push(C),this._exporter._accessors.length-1}}wk.RegisterExtension(qk,(k=>new Pk(k)));var tk=i(11854),Ik=i(11860),rk=i(11867),nk=i(11876);function xk(k){return k===rk.e.PositionKind?"POSITION":k===rk.e.NormalKind?"NORMAL":k===rk.e.ColorKind?"COLOR":k.startsWith(rk.e.UVKind)?"TEX_COORD":"GENERIC"}const Vk={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class kQ extends tk.e{static get DefaultAvailable(){return(0,tk.l)(kQ.DefaultConfiguration)}static get Default(){return kQ._Default??(kQ._Default=new kQ),kQ._Default}static ResetDefault(k){kQ._Default&&(k||kQ._Default.dispose(),kQ._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(k,Q){return{module:await(Q||DracoEncoderModule)({wasmBinary:k})}}_getWorkerContent(){return`${Ik.j}(${Ik.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:kQ.DefaultConfiguration)}async _encodeAsync(k,Q,i){const Z=i?(0,nk.b)(Vk,i):Vk;if(this._workerPoolPromise){const i=await this._workerPoolPromise;return await new Promise(((U,C)=>{i.push(((i,B)=>{const o=k=>{i.removeEventListener("error",o),i.removeEventListener("message",m),C(k),B()},m=k=>{"encodeMeshDone"===k.data.id&&(i.removeEventListener("error",o),i.removeEventListener("message",m),U(k.data.encodedMeshData),B())};i.addEventListener("error",o),i.addEventListener("message",m);const O=[];for(const Q of k)O.push(Q.data.buffer);Q&&O.push(Q.buffer),i.postMessage({id:"encodeMesh",attributes:k,indices:Q,options:Z},O)}))}))}if(this._modulePromise){const i=await this._modulePromise;return(0,Ik.j)(i.module,k,Q,Z)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(k,Q){if(0==k.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");k instanceof hk.d&&k.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===Q||void 0===Q?void 0:Q.method)&&(M.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),Q.method="MESH_SEQUENTIAL_ENCODING");const i=function(k){let Q=k.Oo(void 0,!0);return!Q||Q instanceof Uint32Array||Q instanceof Uint16Array||(Q=((0,D.c)(Q,Q.length)?Uint32Array:Uint16Array).from(Q)),Q}(k),Z=function(k,Q){const i=[];for(const Z of k.getVerticesDataKinds()){if(null!==Q&&void 0!==Q&&Q.includes(Z)){if(Z===rk.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const U=k.getVertexBuffer(Z),C=U.getSize(),B=(0,D.x)(U.getData(),C,U.type,U.byteOffset,U.byteStride,U.normalized,k.getTotalVertices(),!0);i.push({kind:Z,dracoName:xk(Z),size:C,data:B})}return i}(k,null===Q||void 0===Q?void 0:Q.excludedAttributes);return await this._encodeAsync(Z,i,Q)}}kQ.DefaultConfiguration={wasmUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${U.Tools._DefaultCdnUrl}/draco_encoder.js`},kQ._Default=null;const QQ="KHR_draco_mesh_compression";class iQ{get wasUsed(){return this._wasUsed}constructor(k){this.name=QQ,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===k.options.meshCompressionMethod&&kQ.DefaultAvailable}dispose(){}postExportMeshPrimitive(k,Q,i){if(!this.enabled)return;if(4!==k.mode&&5!==k.mode)return void M.c.Warn("Cannot compress primitive with mode "+k.mode+".");const Z=[],U=[];let C=null;if(void 0!==k.indices){const B=i[k.indices],o=Q.getBufferView(B);C=Q.getData(o).slice(),Z.push(o),U.push(B)}const B=[];for(const[J,G]of Object.entries(k.attributes)){const k=i[G],C=Q.getBufferView(k),m=P(k.type),O=(0,D.x)(Q.getData(C),m,k.componentType,k.byteOffset||0,C.byteStride||(0,D.p)(k.componentType)*m,k.normalized||!1,k.count,!0);B.push({kind:J,dracoName:(o=J,"POSITION"===o?"POSITION":"NORMAL"===o?"NORMAL":o.startsWith("COLOR")?"COLOR":o.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:P(k.type),data:O}),Z.push(C),U.push(k)}var o;const m={method:k.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},O=kQ.Default._encodeAsync(B,C,m).then((i=>{if(!i)return void M.c.Error("Draco encoding failed for primitive.");const C={bufferView:-1,attributes:i.attributeIds},B=Q.createBufferView(i.data);Q.setBufferView(C,B);for(const k of Z)this._bufferViewsUsed.add(k);for(const k of U)this._accessorsUsed.add(k);k.extensions||(k.extensions={}),k.extensions[QQ]=C})).catch((k=>{M.c.Error("Draco encoding failed for primitive: "+k)}));this._encodePromises.push(O),this._wasUsed=!0}async preGenerateBinaryAsync(k){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((Q=>{k.getPropertiesWithBufferView(Q).every((k=>this._accessorsUsed.has(k)))&&k.removeBufferView(Q)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}wk.RegisterExtension(QQ,(k=>new iQ(k)));var ZQ=i(11884);const UQ="KHR_lights_punctual",CQ={name:"",color:[1,1,1],lo:1,range:Number.MAX_VALUE},BQ={innerConeAngle:0,outerConeAngle:Math.PI/4},oQ=Z.zQ.Backward();class mQ{constructor(k){this.name=UQ,this.enabled=!0,this.required=!1,this._exporter=k}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[UQ]=this._lights}async postExportNodeAsync(k,Q,i,U,C){return await new Promise((B=>{if(!(i instanceof ck.e))return void B(Q);const o=i.getTypeID()==ck.e.LIGHTTYPEID_POINTLIGHT?"point":i.getTypeID()==ck.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":i.getTypeID()==ck.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!o||!(i instanceof ZQ.b))return M.c.Warn(`${k}: Light ${i.name} is not supported in ${UQ}`),void B(Q);if(i.falloffType!==ck.e.FALLOFF_GLTF&&M.c.Warn(`${k}: Light falloff for ${i.name} does not match the ${UQ} specification!`),!i.position.equalsToFloats(0,0,0)){const k=Z.TmpVectors.zQ[0].B(i.position);C&&n(k),Q.translation=k.Zo()}if("point"!==o){const k=i.direction.normalizeToRef(Z.TmpVectors.zQ[0]);C&&n(k);const U=Z.Quaternion.FromUnitVectorsToRef(oQ,k,Z.TmpVectors.Quaternion[0]);Z.Quaternion.IsIdentity(U)||(Q.rotation=U.Zo())}const m={type:o,name:i.name,color:i.ho.Zo(),lo:i.lo,range:i.range};if(Zk(m,CQ),"spot"===o){const k=i;m.spot={innerConeAngle:k.innerAngle/2,outerConeAngle:k.angle/2},Zk(m.spot,BQ)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(m);const O={ui:this._lights.lights.length-1},J=i.parent;if(J&&Qk(i,J)){const k=U.get(J);if(k){const i=this._exporter._nodes[k];return kk(Q,i),i.extensions||(i.extensions={}),i.extensions[UQ]=O,void B(null)}}Q.extensions||(Q.extensions={}),Q.extensions[UQ]=O,B(Q)}))}}wk.RegisterExtension(UQ,(k=>new mQ(k)));var OQ=i(11785);const JQ="KHR_materials_anisotropy";class GQ{constructor(k){this.name=JQ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,Q,i){const Z=[];return i instanceof OQ.c&&i.anisotropy.isEnabled&&!i.anisotropy.legacy?(i.anisotropy.texture&&Z.push(i.anisotropy.texture),Z):[]}postExportMaterialAsync(k,Q,i){return new Promise((k=>{if(i instanceof OQ.c){if(!i.anisotropy.isEnabled||i.anisotropy.legacy)return void k(Q);this._wasUsed=!0,Q.extensions=Q.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(i.anisotropy.texture),U={anisotropyStrength:i.anisotropy.lo,anisotropyRotation:i.anisotropy.angle,anisotropyTexture:Z??void 0};null!==U.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(i),Q.extensions[JQ]=U}k(Q)}))}}wk.RegisterExtension(JQ,(k=>new GQ(k)));const HQ="KHR_materials_clearcoat";class eQ{constructor(k){this.name=HQ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,Q,i){const Z=[];return i instanceof OQ.c&&i.clearCoat.isEnabled?(i.clearCoat.texture&&Z.push(i.clearCoat.texture),!i.clearCoat.useRoughnessFromMainTexture&&i.clearCoat.textureRoughness&&Z.push(i.clearCoat.textureRoughness),i.clearCoat.bumpTexture&&Z.push(i.clearCoat.bumpTexture),Z):[]}postExportMaterialAsync(k,Q,i){return new Promise((k=>{if(i instanceof OQ.c){if(!i.clearCoat.isEnabled)return void k(Q);this._wasUsed=!0,Q.extensions=Q.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(i.clearCoat.texture);let C;C=i.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(i.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(i.clearCoat.textureRoughness),i.clearCoat.isTintEnabled&&U.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${i.name}`),i.clearCoat.remapF0OnInterfaceChange&&U.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${i.name}`);const B=this._exporter._materialExporter.getTextureInfo(i.clearCoat.bumpTexture),o={clearcoatFactor:i.clearCoat.lo,clearcoatTexture:Z??void 0,clearcoatRoughnessFactor:i.clearCoat.roughness,clearcoatRoughnessTexture:C??void 0,clearcoatNormalTexture:B??void 0};null===o.clearcoatTexture&&null===o.clearcoatRoughnessTexture&&null===o.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(i),Q.extensions[HQ]=o}k(Q)}))}}wk.RegisterExtension(HQ,(k=>new eQ(k)));const FQ="KHR_materials_diffuse_transmission";function zQ(k,Q){const i=Q.subSurface;let Z=null;return i.translucencyIntensityTexture?Z=i.translucencyIntensityTexture:i.thicknessTexture&&i.useMaskFromThicknessTexture&&(Z=i.thicknessTexture),Z&&!i.useGltfStyleTextures?(M.c.Warn(`${k}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${Q.name}`,1),null):Z}class EQ{constructor(k){this.name=FQ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,Q,i){const Z=[];if(i instanceof Fk.c&&this._isExtensionEnabled(i)){const Q=zQ(k,i);return Q&&Z.push(Q),i.subSurface.translucencyColorTexture&&Z.push(i.subSurface.translucencyColorTexture),Z}return Z}_isExtensionEnabled(k){if(k.unlit)return!1;const Q=k.subSurface;return!!Q.isTranslucencyEnabled&&(!k.unlit&&!Q.useAlbedoToTintTranslucency&&Q.useGltfStyleTextures&&1===Q.volumeIndexOfRefraction&&0===Q.minimumThickness&&0===Q.maximumThickness)}postExportMaterialAsync(k,Q,i){return new Promise((Z=>{if(i instanceof Fk.c&&this._isExtensionEnabled(i)){this._wasUsed=!0;const Z=i.subSurface,U=zQ(k,i),C=0==Z.translucencyIntensity?void 0:Z.translucencyIntensity,B=this._exporter._materialExporter.getTextureInfo(U)??void 0,o=!Z.translucencyColor||Z.translucencyColor.equalsFloats(1,1,1)?void 0:Z.translucencyColor.Zo(),m=this._exporter._materialExporter.getTextureInfo(Z.translucencyColorTexture)??void 0,O={diffuseTransmissionFactor:C,diffuseTransmissionTexture:B,diffuseTransmissionColorFactor:o,diffuseTransmissionColorTexture:m};(B||m)&&this._exporter._materialNeedsUVsSet.add(i),Q.extensions=Q.extensions||{},Q.extensions[FQ]=O}Z(Q)}))}}wk.RegisterExtension(FQ,(k=>new EQ(k)));const lQ="KHR_materials_dispersion";class hQ{constructor(){this.name=lQ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(k){if(k.unlit)return!1;const Q=k.subSurface;return!(!Q.isRefractionEnabled&&!Q.isDispersionEnabled)}postExportMaterialAsync(k,Q,i){return new Promise((k=>{if(i instanceof Fk.c&&this._isExtensionEnabled(i)){this._wasUsed=!0;const k={dispersion:i.subSurface.dispersion};Q.extensions=Q.extensions||{},Q.extensions[lQ]=k}k(Q)}))}}wk.RegisterExtension(lQ,(()=>new hQ));const cQ="KHR_materials_emissive_strength";class fQ{constructor(){this.name=cQ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(k,Q,i){return await new Promise((k=>{if(!(i instanceof Fk.c))return k(Q);const Z=i.emissiveColor.Zo(),U=Math.max(...Z);if(U>1){this._wasUsed=!0,Q.extensions||(Q.extensions={});const k={emissiveStrength:U},Z=i.emissiveColor.scale(1/k.emissiveStrength);Q.emissiveFactor=Z.Zo(),Q.extensions[cQ]=k}return k(Q)}))}}wk.RegisterExtension(cQ,(k=>new fQ));const YQ="KHR_materials_ior";class yQ{constructor(){this.name=YQ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(k){return!k.unlit&&(void 0!=k.indexOfRefraction&&1.5!=k.indexOfRefraction)}postExportMaterialAsync(k,Q,i){return new Promise((k=>{if(i instanceof Fk.c&&this._isExtensionEnabled(i)){this._wasUsed=!0;const k={ior:i.indexOfRefraction};Q.extensions=Q.extensions||{},Q.extensions[YQ]=k}k(Q)}))}}wk.RegisterExtension(YQ,(k=>new yQ));const LQ="KHR_materials_iridescence";class sQ{constructor(k){this.name=LQ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,Q,i){const Z=[];return i instanceof OQ.c&&i.iridescence.isEnabled?(i.iridescence.texture&&Z.push(i.iridescence.texture),i.iridescence.thicknessTexture&&i.iridescence.thicknessTexture!==i.iridescence.texture&&Z.push(i.iridescence.thicknessTexture),Z):[]}postExportMaterialAsync(k,Q,i){return new Promise((k=>{if(i instanceof OQ.c){if(!i.iridescence.isEnabled)return void k(Q);this._wasUsed=!0,Q.extensions=Q.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(i.iridescence.texture),U=this._exporter._materialExporter.getTextureInfo(i.iridescence.thicknessTexture),C={iridescenceFactor:i.iridescence.lo,iridescenceIor:i.iridescence.indexOfRefraction,iridescenceThicknessMinimum:i.iridescence.minimumThickness,iridescenceThicknessMaximum:i.iridescence.maximumThickness,iridescenceTexture:Z??void 0,iridescenceThicknessTexture:U??void 0};null===C.iridescenceTexture&&null===C.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(i),Q.extensions[LQ]=C}k(Q)}))}}wk.RegisterExtension(LQ,(k=>new sQ(k)));const uQ="KHR_materials_sheen";class aQ{constructor(k){this.name=uQ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,Q,i){return i instanceof Fk.c&&i.sheen.isEnabled&&i.sheen.texture?[i.sheen.texture]:[]}async postExportMaterialAsync(k,Q,i){return await new Promise((k=>{if(i instanceof Fk.c){if(!i.sheen.isEnabled)return void k(Q);this._wasUsed=!0,null==Q.extensions&&(Q.extensions={});const Z={sheenColorFactor:i.sheen.color.Zo(),sheenRoughnessFactor:i.sheen.roughness??0};null===Z.sheenColorTexture&&null===Z.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(i),i.sheen.texture&&(Z.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.texture)??void 0),i.sheen.textureRoughness&&!i.sheen.useRoughnessFromMainTexture?Z.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.textureRoughness)??void 0:i.sheen.texture&&i.sheen.useRoughnessFromMainTexture&&(Z.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.texture)??void 0),Q.extensions[uQ]=Z}k(Q)}))}}wk.RegisterExtension(uQ,(k=>new aQ(k)));const jQ="KHR_materials_specular";class TQ{constructor(k){this.name=jQ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,Q,i){const Z=[];return i instanceof Fk.c&&this._isExtensionEnabled(i)?(i.metallicReflectanceTexture&&Z.push(i.metallicReflectanceTexture),i.reflectanceTexture&&Z.push(i.reflectanceTexture),Z):Z}_isExtensionEnabled(k){return!k.unlit&&(void 0!=k.metallicF0Factor&&1!=k.metallicF0Factor||void 0!=k.metallicReflectanceColor&&!k.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(k))}_hasTexturesExtension(k){return null!=k.metallicReflectanceTexture||null!=k.reflectanceTexture}postExportMaterialAsync(k,Q,i){return new Promise((k=>{if(i instanceof Fk.c&&this._isExtensionEnabled(i)){this._wasUsed=!0,Q.extensions=Q.extensions||{};const k=this._exporter._materialExporter.getTextureInfo(i.metallicReflectanceTexture)??void 0,Z=this._exporter._materialExporter.getTextureInfo(i.reflectanceTexture)??void 0,U={specularFactor:1==i.metallicF0Factor?void 0:i.metallicF0Factor,specularTexture:k,specularColorFactor:i.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:i.metallicReflectanceColor.Zo(),specularColorTexture:Z};this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),Q.extensions[jQ]=U}k(Q)}))}}wk.RegisterExtension(jQ,(k=>new TQ(k)));const KQ="KHR_materials_transmission";class vQ{constructor(k){this.name=KQ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,Q,i){const Z=[];return i instanceof Fk.c&&this._isExtensionEnabled(i)?(i.subSurface.thicknessTexture&&Z.push(i.subSurface.thicknessTexture),Z):Z}_isExtensionEnabled(k){if(k.unlit)return!1;const Q=k.subSurface;return Q.isRefractionEnabled&&void 0!=Q.refractionIntensity&&0!=Q.refractionIntensity||this._hasTexturesExtension(k)}_hasTexturesExtension(k){return null!=k.subSurface.refractionIntensityTexture}async postExportMaterialAsync(k,Q,i){if(i instanceof Fk.c&&this._isExtensionEnabled(i)){this._wasUsed=!0;const Z=i.subSurface,U={transmissionFactor:0===Z.refractionIntensity?void 0:Z.refractionIntensity};if(this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),Z.refractionIntensityTexture)if(Z.useGltfStyleTextures){const k=await this._exporter._materialExporter.exportTextureAsync(Z.refractionIntensityTexture,"image/png");k&&(U.transmissionTexture=k)}else M.c.Warn(`${k}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);Q.extensions||(Q.extensions={}),Q.extensions[KQ]=U}return Q}}wk.RegisterExtension(KQ,(k=>new vQ(k)));const NQ="KHR_materials_unlit";class XQ{constructor(){this.name=NQ,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(k,Q,i){return new Promise((k=>{let Z=!1;i instanceof Fk.c?Z=i.unlit:i instanceof zk.hQ&&(Z=i.disableLighting),Z&&(this._wasUsed=!0,null==Q.extensions&&(Q.extensions={}),Q.extensions[NQ]={}),k(Q)}))}}wk.RegisterExtension(NQ,(()=>new XQ));const pQ="KHR_materials_volume";class dQ{constructor(k){this.name=pQ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,Q,i){const Z=[];return i instanceof Fk.c&&this._isExtensionEnabled(i)?(i.subSurface.thicknessTexture&&Z.push(i.subSurface.thicknessTexture),Z):Z}_isExtensionEnabled(k){if(k.unlit)return!1;const Q=k.subSurface;return!(!Q.isRefractionEnabled&&!Q.isTranslucencyEnabled)&&(void 0!=Q.maximumThickness&&0!=Q.maximumThickness||void 0!=Q.tintColorAtDistance&&Q.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=Q.tintColor&&Q.tintColor!=E.cQ.White()||this._hasTexturesExtension(k))}_hasTexturesExtension(k){return null!=k.subSurface.thicknessTexture}postExportMaterialAsync(k,Q,i){return new Promise((k=>{if(i instanceof Fk.c&&this._isExtensionEnabled(i)){this._wasUsed=!0;const k=i.subSurface,Z={thicknessFactor:0==k.maximumThickness?void 0:k.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(k.thicknessTexture)??void 0,attenuationDistance:k.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:k.tintColorAtDistance,attenuationColor:k.tintColor.equalsFloats(1,1,1)?void 0:k.tintColor.Zo()};this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),Q.extensions=Q.extensions||{},Q.extensions[pQ]=Z}k(Q)}))}}wk.RegisterExtension(pQ,(k=>new dQ(k)));const bQ="EXT_materials_diffuse_roughness";class DQ{constructor(k){this.name=bQ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=k}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(k,Q,i){const Z=[];return i instanceof OQ.c&&i._baseDiffuseRoughness?(i._baseDiffuseRoughnessTexture&&Z.push(i._baseDiffuseRoughnessTexture),Z):[]}postExportMaterialAsync(k,Q,i){return new Promise((k=>{if(i instanceof OQ.c){if(!i._baseDiffuseRoughness)return void k(Q);this._wasUsed=!0,Q.extensions=Q.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(i._baseDiffuseRoughnessTexture),U={diffuseRoughnessFactor:i._baseDiffuseRoughness,diffuseRoughnessTexture:Z??void 0};null!==U.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(i),Q.extensions[bQ]=U}k(Q)}))}}wk.RegisterExtension(bQ,(k=>new DQ(k)));const MQ="KHR_texture_transform";class WQ{constructor(){this.name=MQ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(k,Q,i){if(i.sk()||U.Tools.Warn(`${k}: /*@__KEY__*/"scene" is not defined for Babylon texture ${i.name}!`),(0!==i.uAng||0!==i.vAng)&&(U.Tools.Warn(`${k}: Texture ${i.name} with rotation in the u or v axis is not supported in glTF.`),0!==i.uRotationCenter||0!==i.vRotationCenter))return;const Z={};let C=!1;if(0===i.uOffset&&0===i.vOffset||(Z.offset=[i.uOffset,i.vOffset],C=!0),1===i.uScale&&1===i.vScale||(Z.scale=[i.uScale,i.vScale],C=!0),0!==i.wAng){if(0!==i.uRotationCenter||0!==i.vRotationCenter){if(i.homogeneousRotationInUVTransform&&i.uScale!==i.vScale)return void U.Tools.Warn(`${k}: Texture ${i.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${MQ}.`);U.Tools.Warn(`${k}: Texture ${i.name} with non-origin rotation center will be exported using an adjusted offset with ${MQ}.`),Z.offset=function(k){const{uOffset:Q,vOffset:i,uRotationCenter:Z,vRotationCenter:U,uScale:C,vScale:B,wAng:o}=k,m=Math.cos(o),O=Math.sin(o),J=Z*C,G=U*B;return[Q+(J*(1-m)+G*O),i+(G*(1-m)-J*O)]}(i)}Z.rotation=-i.wAng,C=!0}0!==i.coordinatesIndex&&(Z.texCoord=i.coordinatesIndex,C=!0),C&&(this._wasUsed=!0,Q.extensions||(Q.extensions={}),Q.extensions[MQ]=Z)}}wk.RegisterExtension(MQ,(()=>new WQ));class AQ{static CreateSTL(k){let Q=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",U=arguments.length>3&&void 0!==arguments[3]&&arguments[3],C=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],B=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],m=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const O=function(k,Q,i){const U=[3*k[i],3*k[i+1],3*k[i+2]],C=[new Z.zQ(Q[U[0]],Q[U[0]+2],Q[U[0]+1]),new Z.zQ(Q[U[1]],Q[U[1]+2],Q[U[1]+1]),new Z.zQ(Q[U[2]],Q[U[2]+2],Q[U[2]+1])],B=C[0].EQ(C[1]),o=C[2].EQ(C[1]);return{v:C,n:Z.zQ.Cross(o,B).normalize()}},G=function(k,Q,i,Z){return Q=H(k,Q,i.x,Z),Q=H(k,Q,i.y,Z),H(k,Q,i.z,Z)},H=function(k,Q,i,Z){return k.setFloat32(Q,i,Z),Q+4},F=function(k){if(o){let Q=k;k instanceof e.d&&(Q=k.sourceMesh);const i=Q.getVerticesData(J.h.PositionKind,!0,!0);if(!i)return[];const U=Z.zQ.Zero();let C;for(C=0;C<i.length;C+=3)Z.zQ.TransformCoordinatesFromFloatsToRef(i[C],i[C+1],i[C+2],k.oo(!0),U).toArray(i,C);return i}return k.getVerticesData(J.h.PositionKind)||[]};o&&(B=!0);let z="",E=0,l=0;if(U){for(let i=0;i<k.length;i++){const Q=k[i].Oo();E+=Q?Q.length/3:0}const Q=new ArrayBuffer(84+50*E);z=new DataView(Q),l+=80,z.setUint32(l,E,C),l+=4}else m||(z="solid stlmesh\r\n");for(let Z=0;Z<k.length;Z++){const Q=k[Z];!U&&m&&(z+="solid "+Q.name+"\r\n"),!B&&Q instanceof hk.d&&Q.bakeCurrentTransformIntoVertices();const i=F(Q),o=Q.Oo()||[];for(let k=0;k<o.length;k+=3){const Q=O(o,i,k);U?(l=G(z,l,Q.n,C),l=G(z,l,Q.v[0],C),l=G(z,l,Q.v[1],C),l=G(z,l,Q.v[2],C),l+=2):(z+="\tfacet normal "+Q.n.x+" "+Q.n.y+" "+Q.n.z+"\r\n",z+="\t\touter loop\r\n",z+="\t\t\tvertex "+Q.v[0].x+" "+Q.v[0].y+" "+Q.v[0].z+"\r\n",z+="\t\t\tvertex "+Q.v[1].x+" "+Q.v[1].y+" "+Q.v[1].z+"\r\n",z+="\t\t\tvertex "+Q.v[2].x+" "+Q.v[2].y+" "+Q.v[2].z+"\r\n",z+="\t\tendloop\r\n",z+="\tendfacet\r\n")}!U&&m&&(z+="endsolid "+name+"\r\n")}if(U||m||(z+="endsolid stlmesh"),Q){const k=document.createElement("a"),Q=new Blob([z],{type:"application/octet-stream"});k.href=window.URL.createObjectURL(Q),k.download=i+".stl",k.click()}return z}}function gQ(k,Q){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const Z=[];for(let U=0;U<k.length/i;U++){const C=k[U*i],B=k[U*i+1],o=k[U*i+2];Z.push(`(${C.toPrecision(Q.precision)}, ${B.toPrecision(Q.precision)}, ${o.toPrecision(Q.precision)})`)}return Z.join(", ")}function RQ(k,Q){const i=[];for(let Z=0;Z<k.length/2;Z++){const U=k[2*Z],C=k[2*Z+1];i.push(`(${U.toPrecision(Q.precision)}, ${(1-C).toPrecision(Q.precision)})`)}return i.join(", ")}function wQ(k,Q){const i=k.getVerticesData(J.h.PositionKind),Z=k.getVerticesData(J.h.NormalKind);if(i&&Z)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(k){var Q;const i=null!==(Q=k.Oo())&&void 0!==Q&&Q.length?k.getTotalIndices():k.getTotalVertices();return Array(i/3).fill(3).join(", ")}(k)}]\n\t\tint[] faceVertexIndices = [${function(k){const Q=k.Oo(),i=[];if(null!==Q)for(let Z=0;Z<Q.length;Z++)i.push(Q[Z]);else{const Q=k.getTotalVertices();for(let k=0;k<Q;k++)i.push(k)}return i.join(", ")}(k)}]\n\t\tnormal3f[] normals = [${gQ(Z,Q)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${gQ(i,Q)}]\n        ${function(k,Q){let i="";for(let U=0;U<4;U++){const Z=U>0?U:"",C=k.getVerticesData(J.h.UVKind+(Z?Z+1:""));C&&(i+=`\n\t\ttexCoord2f[] primvars:st${Z} = [${RQ(C,Q)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const Z=k.getVerticesData(J.h.ColorKind);return Z&&(i+=`\n\tcolor3f[] primvars:displayColor = [${gQ(Z,Q,Z.length/k.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),i}(k,Q)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function SQ(k,Q){return`\n        def "Geometry"\n        {\n        ${wQ(k,Q)}\n        }\n        `}function qQ(k){let Q='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return Q+=k,fflate.strToU8(Q)}function PQ(k){const Q=k.m;return`( ${tQ(Q,0)}, ${tQ(Q,4)}, ${tQ(Q,8)}, ${tQ(Q,12)} )`}function tQ(k,Q){return`(${k[Q+0]}, ${k[Q+1]}, ${k[Q+2]}, ${k[Q+3]})`}function IQ(k){const Q="Object_"+k.uniqueId,i=function(k){const Q=k.getWorldMatrix().clone(),i=k.sk().useRightHandedSystem;if(!i){let Z=k.parent;for(;Z;){if(Bk(Z,i)){Q.multiplyToRef(Z.getWorldMatrix().invert(),Q);break}Z=Z.parent}}return Q.determinant()<0&&U.Tools.Warn(`Exporting mesh ${k.name} with negative scale. Result may look incorrect in destination engine.`),Q}(k),Z=PQ(i);return`def Xform "${Q}" (\n\tprepend references = @./geometries/Geometry_${k.mo.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${Z}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${k.material.uniqueId}>\n}\n\n`}function rQ(k){switch(k){case L.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case L.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case L.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function nQ(k){return`(${k.x}, ${k.y})`}function xQ(k){return`(${k.r}, ${k.g}, ${k.b})`}function VQ(k,Q,i,U,C,B){const o=k.getInternalTexture().uniqueId+"_"+k.invertY;C[o]=k;const m=k.coordinatesIndex>0?"st"+k.coordinatesIndex:"st",O=new Z.Vector2(k.uScale,k.vScale),J=new Z.Vector2(k.uOffset,k.vOffset),G=k.wAng,H=Math.sin(G),e=Math.cos(G);return J.y=1-J.y-O.y,J.x+=H*O.x,J.y+=(1-e)*O.y,`\n    def Shader "PrimvarReader_${i}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${m}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${i}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${Q.uniqueId}/PrimvarReader_${i}.outputs:result>\n        float inputs:rotation = ${(G*(180/Math.PI)).toFixed(B.precision)}\n        float2 inputs:scale = ${nQ(O)}\n        float2 inputs:translation = ${nQ(J)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${k.uniqueId}_${i}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${o}.png@\n        float2 inputs:st.connect = </Materials/Material_${Q.uniqueId}/Transform2d_${i}.outputs:result>\n        ${U?"float4 inputs:scale = "+function(k){return`(${k.r}, ${k.g}, ${k.b}, 1.0)`}(U):""}\n        token inputs:sourceColorSpace = "${k.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${rQ(k.wrapU)}"\n        token inputs:wrapT = "${rQ(k.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${Q.needAlphaBlending()?"float outputs:a":""}\n    }`}function ki(k,Q,i){const Z="\t\t\t",U=[],C=[],{diffuseMap:B,ho:o,alphaCutOff:m,emissiveMap:O,emissive:J,normalMap:G,roughnessMap:H,roughnessChannel:e,roughness:F,metalnessMap:z,metalnessChannel:l,metalness:h,aoMap:c,aoMapChannel:f,aoMapIntensity:Y,alphaMap:y,ior:L,clearCoatEnabled:s,clearCoat:u,clearCoatMap:a,clearCoatRoughness:j,clearCoatRoughnessMap:T}=function(k){const Q={diffuseMap:null,ho:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return k instanceof zk.hQ?{...Q,diffuseMap:k.diffuseTexture,ho:k.diffuseColor,alphaCutOff:k.alphaCutOff,emissiveMap:k.emissiveTexture,emissive:k.emissiveColor,roughness:1,alphaMap:k.opacityTexture}:k instanceof OQ.c?{...Q,diffuseMap:k._albedoTexture,ho:k._albedoColor,alphaCutOff:k._alphaCutOff,emissiveMap:k._emissiveTexture,emissive:k._emissiveColor,normalMap:k._bumpTexture,roughnessMap:k._metallicTexture,roughnessChannel:k._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:k._roughness??1,metalnessMap:k._metallicTexture,metalnessChannel:k._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:k._metallic??0,aoMap:k._ambientTexture,aoMapChannel:k._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:k._ambientTextureStrength,alphaMap:k._opacityTexture,ior:k.subSurface.indexOfRefraction,clearCoatEnabled:k.clearCoat.isEnabled,clearCoat:k.clearCoat.lo,clearCoatMap:k.clearCoat.texture,clearCoatRoughness:k.clearCoat.roughness,clearCoatRoughnessMap:k.clearCoat.useRoughnessFromMainTexture?k.clearCoat.texture:k.clearCoat.textureRoughness}:Q}(k);return null!==B?(U.push(`${Z}color3f inputs:diffuseColor.connect = </Materials/Material_${k.uniqueId}/Texture_${B.uniqueId}_diffuse.outputs:rgb>`),k.needAlphaBlending()?U.push(`${Z}float inputs:opacity.connect = </Materials/Material_${k.uniqueId}/Texture_${B.uniqueId}_diffuse.outputs:a>`):k.needAlphaTesting()&&(U.push(`${Z}float inputs:opacity.connect = </Materials/Material_${k.uniqueId}/Texture_${B.uniqueId}_diffuse.outputs:a>`),U.push(`${Z}float inputs:opacityThreshold = ${m}`)),C.push(VQ(B,k,"diffuse",o,Q,i))):U.push(`${Z}color3f inputs:diffuseColor = ${xQ(o||E.cQ.White())}`),null!==O?(U.push(`${Z}color3f inputs:emissiveColor.connect = </Materials/Material_${k.uniqueId}/Texture_${O.uniqueId}_emissive.outputs:rgb>`),C.push(VQ(O,k,"emissive",J,Q,i))):J&&J.toLuminance()>0&&U.push(`${Z}color3f inputs:emissiveColor = ${xQ(J)}`),null!==G&&(U.push(`${Z}normal3f inputs:normal.connect = </Materials/Material_${k.uniqueId}/Texture_${G.uniqueId}_normal.outputs:rgb>`),C.push(VQ(G,k,"normal",null,Q,i))),null!==c&&(U.push(`${Z}float inputs:occlusion.connect = </Materials/Material_${k.uniqueId}/Texture_${c.uniqueId}_occlusion.outputs:${f}>`),C.push(VQ(c,k,"occlusion",new E.cQ(Y,Y,Y),Q,i))),null!==H?(U.push(`${Z}float inputs:roughness.connect = </Materials/Material_${k.uniqueId}/Texture_${H.uniqueId}_roughness.outputs:${e}>`),C.push(VQ(H,k,"roughness",new E.cQ(F,F,F),Q,i))):U.push(`${Z}float inputs:roughness = ${F}`),null!==z?(U.push(`${Z}float inputs:metallic.connect = </Materials/Material_${k.uniqueId}/Texture_${z.uniqueId}_metallic.outputs:${l}>`),C.push(VQ(z,k,"metallic",new E.cQ(h,h,h),Q,i))):U.push(`${Z}float inputs:metallic = ${h}`),null!==y?(U.push(`${Z}float inputs:opacity.connect = </Materials/Material_${k.uniqueId}/Texture_${y.uniqueId}_opacity.outputs:r>`),U.push(`${Z}float inputs:opacityThreshold = 0.0001`),C.push(VQ(y,k,"opacity",null,Q,i))):U.push(`${Z}float inputs:opacity = ${k.alpha}`),s&&(null!==a?(U.push(`${Z}float inputs:clearcoat.connect = </Materials/Material_${k.uniqueId}/Texture_${a.uniqueId}_clearcoat.outputs:r>`),C.push(VQ(a,k,"clearcoat",new E.cQ(u,u,u),Q,i))):U.push(`${Z}float inputs:clearcoat = ${u}`),null!==T?(U.push(`${Z}float inputs:clearcoatRoughness.connect = </Materials/Material_${k.uniqueId}/Texture_${T.uniqueId}_clearcoatRoughness.outputs:g>`),C.push(VQ(T,k,"clearcoatRoughness",new E.cQ(j,j,j),Q,i))):U.push(`${Z}float inputs:clearcoatRoughness = ${j}`)),U.push(`${Z}float inputs:ior = ${L}`),`\n\tdef Material "Material_${k.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${U.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${k.uniqueId}/PreviewSurface.outputs:surface>\n\n${C.join("\n")}\n\n\t}\n`}async function Qi(k,Q,i){const C={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...Q};"undefined"===typeof fflate&&await U.Tools.LoadScriptAsync(C.fflateUrl);const B={};B[C.modelFileName]=null;let o='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';o+=function(k){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===k.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${k.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${k.planeAnchoringAlignment}"`:""}\n            `}(C);const m={};for(const Z of k.meshes){if(0===Z.getTotalVertices())continue;const k=Z,Q=k.mo,O=k.material;if(!O||!Q||i&&!i(k))continue;if(-1!==["hQ","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(O.getClassName())){const i="geometries/Geometry_"+Q.uniqueId+".usda";if(!(i in B)){const k=SQ(Q,C);B[i]=qQ(k)}O.uniqueId in m||(m[O.uniqueId]=O),o+=IQ(k)}else U.Tools.Warn("USDZExportAsync does not support this material type: "+O.getClassName())}k.activeCamera&&C.exportCamera&&(o+=function(k,Q){const i="Camera_"+k.uniqueId,U=PQ(Z.Matrix.RotationY(Math.PI).multiply(k.getWorldMatrix()));if(k.mode===L.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${i}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${U}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${k.Co.toPrecision(Q.precision)}, ${k.maxZ.toPrecision(Q.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(k.orthoLeft||1)+Math.abs(k.orthoRight||1))).toPrecision(Q.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(k.orthoTop||1)+Math.abs(k.orthoBottom||1))).toPrecision(Q.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const Z=k.getEngine().getAspectRatio(k),C=Q.cameraSensorWidth||35;return`def Camera "${i}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${U}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${k.Co.toPrecision(Q.precision)}, ${k.maxZ.toPrecision(Q.precision)})\n\t\t\tfloat focalLength = ${(C/(2*Math.tan(.5*k.fov))).toPrecision(Q.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(C*Z).toPrecision(Q.precision)}\n\t\t\tfloat verticalAperture = ${(C/Z).toPrecision(Q.precision)}            \n\t\t}\n\t\n\t`}}(k.activeCamera,C)),o+="\n            }\n        }\n    }";const O={};o+=function(k,Q,i){const Z=[];for(const U in k){const C=k[U];Z.push(ki(C,Q,i))}return`\n    def "Materials"\n{\n${Z.join("")}\n}\n\n`}(m,O,C),B[C.modelFileName]=fflate.strToU8(o);for(const Z in O){const k=O[Z],Q=k.getSize(),i=await k.readPixels();if(!i)throw new Error("Texture data is not available");const U=await s.DumpTools.DumpDataAsync(Q.width,Q.height,i,"image/png",void 0,!1,!0);B[`textures/Texture_${Z}.png`]=new Uint8Array(U).slice()}let J=0;for(const Z in B){const k=B[Z];if(!k)continue;J+=34+Z.length;const Q=63&J;if(4!==Q){const i=new Uint8Array(64-Q);B[Z]=[k,{extra:{12345:i}}]}J=k.length}return fflate.zipSync(B,{level:0})}}}]);