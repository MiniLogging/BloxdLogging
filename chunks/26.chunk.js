"use strict";(self.hwpa2z1pqte=self.hwpa2z1pqte||[]).push([[26],{13277:(h,R,l)=>{l.r(R),l.d(R,{EXT_materials_diffuse_roughness:()=>WR,EXT_mesh_gpu_instancing:()=>Mh,GLTF2Export:()=>Sh,GLTFData:()=>mh,KHR_draco_mesh_compression:()=>lR,KHR_lights_punctual:()=>wR,KHR_materials_anisotropy:()=>cR,KHR_materials_clearcoat:()=>qR,KHR_materials_diffuse_transmission:()=>sR,KHR_materials_dispersion:()=>fR,KHR_materials_emissive_strength:()=>ER,KHR_materials_ior:()=>GR,KHR_materials_iridescence:()=>OR,KHR_materials_sheen:()=>vR,KHR_materials_specular:()=>IR,KHR_materials_transmission:()=>nR,KHR_materials_unlit:()=>PR,KHR_materials_volume:()=>oR,KHR_texture_transform:()=>HR,OBJExport:()=>U,STLExport:()=>kR,USDZExportAsync:()=>Rl,_ConvertToGLTFPBRMetallicRoughness:()=>r,_SolveMetallic:()=>n,__IGLTFExporterExtension:()=>F});var j=l(12900),a=l(12689),D=l(13179);class U{static OBJ(h,R,l,U){const F=[];let w=1,mh=1;R&&(l||(l="mat"),F.push("mtllib "+l+".mtl"));for(let u=0;u<h.length;u++){const l=h[u],c=l.name||`mesh${u}}`;F.push(`o ${c}`);let J=null;if(U){const h=l.EF(!0);J=new j.Matrix,h.invertToRef(J),l.bakeTransformIntoVertices(h)}if(R){const h=l.material;h&&F.push("usemtl "+h.id)}const q=l.xF;if(!q){a.Tools.Warn("No geometry is present on the mesh");continue}const Q=q.getVerticesData("position"),Y=q.getVerticesData("normal"),s=q.getVerticesData("uv"),t=q.GF();let f=0,T=0;if(!Q||!t){a.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const E=h[0].yh().useRightHandedSystem?1:-1;for(let h=0;h<Q.length;h+=3)F.push("v "+Q[h]*E+" "+Q[h+1]+" "+Q[h+2]),f++;if(null!=Y)for(let h=0;h<Y.length;h+=3)F.push("vn "+Y[h]*E+" "+Y[h+1]+" "+Y[h+2]);if(null!=s)for(let h=0;h<s.length;h+=2)F.push("vt "+s[h]+" "+s[h+1]),T++;const x=["","",""],G=(l.material||l.yh().defaultMaterial)._getEffectiveOrientation(l),[p,O]=G===D.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let h=0;h<t.length;h+=3){const R=[String(t[h]+w),String(t[h+p]+w),String(t[h+O]+w)],l=[String(t[h]+mh),String(t[h+p]+mh),String(t[h+O]+mh)],j=R,a=null!=s?l:x,D=null!=Y?R:x;F.push("f "+j[0]+"/"+a[0]+"/"+D[0]+" "+j[1]+"/"+a[1]+"/"+D[1]+" "+j[2]+"/"+a[2]+"/"+D[2])}U&&J&&l.bakeTransformIntoVertices(J),w+=f,mh+=T}return F.join("\n")}static MTL(h){const R=[],l=h.material;R.push("newmtl mat1"),R.push("  Ns "+l.specularPower.toFixed(4)),R.push("  Ni 1.5000"),R.push("  d "+l.alpha.toFixed(4)),R.push("  Tr 0.0000"),R.push("  Tf 1.0000 1.0000 1.0000"),R.push("  illum 2"),R.push("  Ka "+l.ambientColor.r.toFixed(4)+" "+l.ambientColor.g.toFixed(4)+" "+l.ambientColor.b.toFixed(4)),R.push("  Kd "+l.diffuseColor.r.toFixed(4)+" "+l.diffuseColor.g.toFixed(4)+" "+l.diffuseColor.b.toFixed(4)),R.push("  Ks "+l.specularColor.r.toFixed(4)+" "+l.specularColor.g.toFixed(4)+" "+l.specularColor.b.toFixed(4)),R.push("  Ke "+l.emissiveColor.r.toFixed(4)+" "+l.emissiveColor.g.toFixed(4)+" "+l.emissiveColor.b.toFixed(4));l.ambientTexture&&R.push("  map_Ka "+l.ambientTexture.name),l.diffuseTexture&&R.push("  map_Kd "+l.diffuseTexture.name),l.specularTexture&&R.push("  map_Ks "+l.specularTexture.name),l.bumpTexture&&R.push("  map_bump -imfchan z "+l.bumpTexture.name),l.opacityTexture&&R.push("  map_d "+l.opacityTexture.name);return R.join("\n")}}var F=0,w=l(12758);class mh{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const h in this.files){const R=this.files[h],l=new Blob([R],{type:(0,w.h)(h)});a.Tools.Download(l,h)}}}var u=l(12984),c=l(13284),J=l(13293),q=l(13307),Q=l(13022),Y=l(12749),s=l(12952),t=l(12917);const f=t.HighestCommonFactor,T={...t,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:f};var E=l(13112),x=l(12874),G=l(13341),p=l(13350),O=l(13110);const y=1e-6,v=new s.xR(.04,.04,.04),b=1024,I=s.xR.White(),L=s.xR.Black();function n(h,R,l){if(R<v.r)return 0;const j=v.r,a=h*l/(1-v.r)+R-2*v.r,D=a*a-4*j*(v.r-R);return T.Clamp((-a+Math.sqrt(D))/(2*j),0,1)}function r(h){const R=h.diffuseColor.toLinearSpace(h.yh().getEngine().useExactSrgbConversions).scale(.5),l=h.alpha,a=function(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new j.Vector2(0,1),l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new j.Vector2(0,.1),a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new j.Vector2(0,.1),D=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new j.Vector2(1300,.1);return function(h,R,l,j,a){return(1-h)*(1-h)*(1-h)*R+3*(1-h)*(1-h)*h*l+3*(1-h)*h*h*j+h*h*h*a}(Math.pow(h/D.x,.333333),R.y,l.y,a.y,D.y)}(T.Clamp(h.specularPower,0,b));return{baseColorFactor:[R.r,R.g,R.b,l],metallicFactor:0,roughnessFactor:a}}function P(h,R){R.needAlphaBlending()?h.alphaMode="BLEND":R.needAlphaTesting()&&(h.alphaMode="MASK",h.alphaCutoff=R.alphaCutOff)}function z(h,R,l){const j=new Uint8Array(h*R*4);for(let a=0;a<j.length;a+=4)j[a]=j[a+1]=j[a+2]=j[a+3]=255;return G.e.CreateRGBATexture(j,h,R,l)}function o(h){if(h instanceof Uint8Array){const R=h.length,l=new Float32Array(h.length);for(let j=0;j<R;++j)l[j]=h[j]/255;return l}if(h instanceof Float32Array)return h;throw new Error("Unsupported pixel format!")}class K{constructor(h){this._exporter=h,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(h){return h?this._textureMap.get(h)??null:null}async exportStandardMaterialAsync(h,R,l){const j=r(h),D={name:h.name};if(null==h.pF||h.pF||(h.twoSidedLighting||a.Tools.Warn(h.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),D.doubleSided=!0),l){const l=[],a=h.diffuseTexture;a&&l.push(this.exportTextureAsync(a,R).then((h=>{h&&(j.baseColorTexture=h)})));const U=h.bumpTexture;U&&l.push(this.exportTextureAsync(U,R).then((h=>{h&&(D.normalTexture=h,1!==U.level&&(D.normalTexture.scale=U.level))})));const F=h.emissiveTexture;F&&(D.emissiveFactor=[1,1,1],l.push(this.exportTextureAsync(F,R).then((h=>{h&&(D.emissiveTexture=h)}))));const w=h.ambientTexture;w&&l.push(this.exportTextureAsync(w,R).then((h=>{if(h){const R={index:h.index};D.occlusionTexture=R}}))),l.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(l))}(h.alpha<1||h.opacityTexture)&&(h.alphaMode===p.c.ALPHA_COMBINE?D.alphaMode="BLEND":a.Tools.Warn(h.name+": glTF 2.0 does not support alpha mode: "+h.alphaMode.toString())),h.emissiveColor&&!h.emissiveColor.equalsWithEpsilon(L,y)&&(D.emissiveFactor=h.emissiveColor.sF()),D.pbrMetallicRoughness=j,P(D,h),await this._finishMaterialAsync(D,h,R);const U=this._exporter._materials;return U.push(D),U.length-1}async _finishMaterialAsync(h,R,l){const j=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",h,R),a=[];for(const D of j)a.push(this.exportTextureAsync(D,l));await Promise.all(a),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",h,R)}async _getImageDataAsync(h,R,j,a){const D=p.c.TEXTURETYPE_UNSIGNED_BYTE,U=this._exporter._babylonScene,F=U.getEngine(),w=F.createRawTexture(h,R,j,p.c.TEXTUREFORMAT_RGBA,!1,!0,x.b.NEAREST_SAMPLINGMODE,null,D);F.isWebGPU?await l.e(51).then(l.bind(l,15406)):await l.e(52).then(l.bind(l,15412)),await E.g.ApplyPostProcess("pass",w,U,D,p.c.TEXTURE_NEAREST_SAMPLINGMODE,p.c.TEXTUREFORMAT_RGBA);const mh=await F._readTexturePixels(w,R,j);return await O.DumpTools.DumpDataAsync(R,j,mh,a,void 0,!0,!0)}_resizeTexturesToSameDimensions(h,R,l){const j=h?h.getSize():{width:0,height:0},a=R?R.getSize():{width:0,height:0};let D,U;return j.width<a.width?(D=h&&h instanceof x.b?E.g.CreateResizedCopy(h,a.width,a.height,!0):z(a.width,a.height,l),U=R):j.width>a.width?(U=R&&R instanceof x.b?E.g.CreateResizedCopy(R,j.width,j.height,!0):z(j.width,j.height,l),D=h):(D=h,U=R),{texture1:D,texture2:U}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(h,R,l,j){const a=new Array;if(!h&&!R)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const D=h?h.yh():R?R.yh():null;if(D){var U;const F=this._resizeTexturesToSameDimensions(h,R,D),w=null===(U=F.texture1)||void 0===U?void 0:U.getSize();let mh,u;const c=w.width,J=w.height,q=await F.texture1.readPixels(),Q=await F.texture2.readPixels();if(!q)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(mh=o(q),!Q)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");u=o(Q);const Y=u.byteLength,t=new Uint8Array(Y),f=new Uint8Array(Y),T=4,E=L;let x=0,G=0;for(let h=0;h<J;++h)for(let R=0;R<c;++R){const j=(c*h+R)*T,a={diffuseColor:new s.xR(mh[j],mh[j+1],mh[j+2]).toLinearSpace(D.getEngine().useExactSrgbConversions).multiply(l.diffuseColor),specularColor:new s.xR(u[j],u[j+1],u[j+2]).toLinearSpace(D.getEngine().useExactSrgbConversions).multiply(l.specularColor),glossiness:u[j+3]*l.glossiness},U=this._convertSpecularGlossinessToMetallicRoughness(a);E.r=Math.max(E.r,U.baseColor.r),E.g=Math.max(E.g,U.baseColor.g),E.b=Math.max(E.b,U.baseColor.b),x=Math.max(x,U.metallic),G=Math.max(G,U.roughness),f[j]=255*U.baseColor.r,f[j+1]=255*U.baseColor.g,f[j+2]=255*U.baseColor.b,f[j+3]=F.texture1.tF?255*mh[j+3]:255,t[j]=0,t[j+1]=255*U.roughness,t[j+2]=255*U.metallic,t[j+3]=255}const p={baseColor:E,metallic:x,roughness:G};let O=!1,v=!1;for(let h=0;h<J;++h)for(let R=0;R<c;++R){const l=(c*h+R)*T;f[l]/=p.baseColor.r>y?p.baseColor.r:1,f[l+1]/=p.baseColor.g>y?p.baseColor.g:1,f[l+2]/=p.baseColor.b>y?p.baseColor.b:1;const j=s.xR.FromInts(f[l],f[l+1],f[l+2]).toGammaSpace(D.getEngine().useExactSrgbConversions);f[l]=255*j.r,f[l+1]=255*j.g,f[l+2]=255*j.b,j.equalsWithEpsilon(I,y)||(v=!0),t[l+1]/=p.roughness>y?p.roughness:1,t[l+2]/=p.metallic>y?p.metallic:1;s.xR.FromInts(255,t[l+1],t[l+2]).equalsWithEpsilon(I,y)||(O=!0)}return O&&a.push(this._getImageDataAsync(t,c,J,j).then((h=>{p.metallicRoughnessTextureData=h}))),v&&a.push(this._getImageDataAsync(f,c,J,j).then((h=>{p.baseColorTextureData=h}))),await Promise.all(a).then((()=>p))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(h){const R=this._getPerceivedBrightness(h.diffuseColor),l=this._getPerceivedBrightness(h.specularColor),j=1-this._getMaxComponent(h.specularColor),a=n(R,l,j),D=h.diffuseColor.scale(j/(1-v.r)/Math.max(1-a)),U=h.specularColor.fR(v.scale(1-a)).scale(1/Math.max(a));let F=s.xR.Lerp(D,U,a*a);F=F.clampToRef(0,1,F);return{baseColor:F,metallic:a,roughness:1-h.glossiness}}_getPerceivedBrightness(h){return h?Math.sqrt(.299*h.r*h.r+.587*h.g*h.g+.114*h.b*h.b):0}_getMaxComponent(h){return h?Math.max(h.r,Math.max(h.g,h.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(h,R,l,j){const a=[],D={baseColor:h._albedoColor,metallic:h._metallic,roughness:h._roughness};if(j){h._albedoTexture&&a.push(this.exportTextureAsync(h._albedoTexture,R).then((h=>{h&&(l.baseColorTexture=h)})));const j=h._metallicTexture;j&&a.push(this.exportTextureAsync(j,R).then((h=>{h&&(l.metallicRoughnessTexture=h)})))}return a.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(a)),D}_getTextureSampler(h){const R={};if(!h||!(h instanceof x.b))return R;const l=this._getGLTFTextureWrapMode(h.wrapU);10497!==l&&(R.wrapS=l);const j=this._getGLTFTextureWrapMode(h.wrapV);switch(10497!==j&&(R.wrapT=j),h.samplingMode){case x.b.LINEAR_LINEAR:R.magFilter=9729,R.minFilter=9729;break;case x.b.LINEAR_NEAREST:R.magFilter=9729,R.minFilter=9728;break;case x.b.NEAREST_LINEAR:R.magFilter=9728,R.minFilter=9729;break;case x.b.NEAREST_LINEAR_MIPLINEAR:R.magFilter=9728,R.minFilter=9987;break;case x.b.NEAREST_NEAREST:R.magFilter=9728,R.minFilter=9728;break;case x.b.NEAREST_LINEAR_MIPNEAREST:R.magFilter=9728,R.minFilter=9985;break;case x.b.LINEAR_NEAREST_MIPNEAREST:R.magFilter=9729,R.minFilter=9984;break;case x.b.LINEAR_NEAREST_MIPLINEAR:R.magFilter=9729,R.minFilter=9986;break;case x.b.NEAREST_NEAREST_MIPLINEAR:R.magFilter=9728,R.minFilter=9986;break;case x.b.LINEAR_LINEAR_MIPLINEAR:R.magFilter=9729,R.minFilter=9987;break;case x.b.LINEAR_LINEAR_MIPNEAREST:R.magFilter=9729,R.minFilter=9985;break;case x.b.NEAREST_NEAREST_MIPNEAREST:R.magFilter=9728,R.minFilter=9984}return R}_getGLTFTextureWrapMode(h){switch(h){case x.b.WRAP_ADDRESSMODE:return 10497;case x.b.CLAMP_ADDRESSMODE:return 33071;case x.b.MIRROR_ADDRESSMODE:return 33648;default:return a.Tools.Error(`Unsupported Texture Wrap Mode ${h}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(h,R,l,j){const a={diffuseColor:h._albedoColor,specularColor:h._reflectivityColor,glossiness:h._microSurface},D=h._albedoTexture,U=h._reflectivityTexture,F=h._useMicroSurfaceFromReflectivityMapAlpha;if(U&&!F)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((D||U)&&j){this._exporter._materialNeedsUVsSet.add(h);const j=this._exportTextureSampler(D||U),F=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(D,U,a,R),w=this._exporter._textures;if(F.baseColorTextureData){const h=this._exportImage(`baseColor${w.length}`,R,F.baseColorTextureData);l.baseColorTexture=this._exportTextureInfo(h,j,null===D||void 0===D?void 0:D.coordinatesIndex)}if(F.metallicRoughnessTextureData){const h=this._exportImage(`metallicRoughness${w.length}`,R,F.metallicRoughnessTextureData);l.metallicRoughnessTexture=this._exportTextureInfo(h,j,null===U||void 0===U?void 0:U.coordinatesIndex)}return F}return this._convertSpecularGlossinessToMetallicRoughness(a)}async exportPBRMaterialAsync(h,R,l){const j={},a={name:h.name},D=h.isMetallicWorkflow();if(D){const R=h._albedoColor,l=h.alpha;R&&(j.baseColorFactor=[R.r,R.g,R.b,l])}const U=D?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(h,R,j,l):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(h,R,j,l);await this._setMetallicRoughnessPbrMaterialAsync(U,h,a,j,R,l),await this._finishMaterialAsync(a,h,R);const F=this._exporter._materials;return F.push(a),F.length-1}async _setMetallicRoughnessPbrMaterialAsync(h,R,l,j,D,U){if(P(l,R),h.baseColor.equalsWithEpsilon(I,y)&&T.WithinEpsilon(R.alpha,1,y)||(j.baseColorFactor=[h.baseColor.r,h.baseColor.g,h.baseColor.b,R.alpha]),null!=h.metallic&&1!==h.metallic&&(j.metallicFactor=h.metallic),null!=h.roughness&&1!==h.roughness&&(j.roughnessFactor=h.roughness),null==R.pF||R.pF||(R._twoSidedLighting||a.Tools.Warn(R.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),l.doubleSided=!0),U){const h=[],j=R._bumpTexture;j&&h.push(this.exportTextureAsync(j,D).then((h=>{h&&(l.normalTexture=h,1!==j.level&&(l.normalTexture.scale=j.level))})));const a=R._ambientTexture;a&&h.push(this.exportTextureAsync(a,D).then((h=>{if(h){const j={index:h.index,texCoord:h.texCoord,extensions:h.extensions};l.occlusionTexture=j;const a=R._ambientTextureStrength;a&&(j.strength=a)}})));const U=R._emissiveTexture;U&&h.push(this.exportTextureAsync(U,D).then((h=>{h&&(l.emissiveTexture=h)}))),h.length>0&&(this._exporter._materialNeedsUVsSet.add(R),await Promise.all(h))}const F=R._emissiveColor;F.equalsWithEpsilon(L,y)||(l.emissiveFactor=F.sF()),l.pbrMetallicRoughness=j}_getPixelsFromTextureAsync(h){return function(h){switch(h){case p.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case p.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case p.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case p.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case p.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case p.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case p.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case p.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case p.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case p.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case p.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case p.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case p.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case p.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case p.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case p.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case p.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case p.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case p.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case p.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case p.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(h.textureFormat)?(0,E.f)(h,h._texture.width,h._texture.height):(h.textureType,p.c.TEXTURETYPE_UNSIGNED_BYTE,h.readPixels())}async exportTextureAsync(h,R){const l=this._exporter._extensionsPreExportTextureAsync("exporter",h,R);return l?await l.then((async l=>l?await this._exportTextureInfoAsync(l,R):await this._exportTextureInfoAsync(h,R))):await this._exportTextureInfoAsync(h,R)}async _exportTextureInfoAsync(h,R){let l=this._textureMap.get(h);if(!l){const j=await this._getPixelsFromTextureAsync(h);if(!j)return null;const D=this._exportTextureSampler(h),U=h.mimeType;if(U)switch(U){case"image/jpeg":case"image/png":case"image/webp":R=U;break;default:a.Tools.Warn(`Unsupported media type: ${U}. Exporting texture as PNG.`)}const F=this._internalTextureToImage,w=h.getInternalTexture().uniqueId;F[w]||(F[w]={});let mh=F[w][R];if(void 0===mh){const l=h.getSize();mh=(async()=>{const a=await this._getImageDataAsync(j,l.width,l.height,R);return this._exportImage(h.name,R,a)})(),F[w][R]=mh}l=this._exportTextureInfo(await mh,D,h.coordinatesIndex),this._textureMap.set(h,l),this._exporter._extensionsPostExportTextures("exporter",l,h)}return l}_exportImage(h,R,l){const j=this._exporter._images;let D;if(this._exporter._shouldUseGlb){D={name:h,mimeType:R,bufferView:void 0};const j=this._exporter._bufferManager.createBufferView(new Uint8Array(l));this._exporter._bufferManager.setBufferView(D,j)}else{const U=h.replace(/\.\/|\/|\.\\|\\/g,"_"),F=function(h){switch(h){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(R);let w=U+F;j.some((h=>h.uri===w))&&(w=`${U}_${a.Tools.RandomId()}${F}`),D={name:h,uri:w},this._exporter._imageData[w]={data:l,mimeType:R}}return j.push(D),j.length-1}_exportTextureInfo(h,R,l){const j=this._exporter._textures;let a=j.findIndex((l=>l.sampler==R&&l.source===h));-1===a&&(a=j.length,j.push({source:h,sampler:R}));const D={index:a};return l&&(D.texCoord=l),D}_exportTextureSampler(h){const R=this._getTextureSampler(h),l=this._exporter._samplers,j=l.findIndex((h=>h.minFilter===R.minFilter&&h.magFilter===R.magFilter&&h.wrapS===R.wrapS&&h.wrapT===R.wrapT));return-1!==j?j:(l.push(R),l.length-1)}}var W=l(12990),g=l(12711),H=l(13359),k=l(12902);const C=j.tR.Zero(),A=j.Quaternion.Identity(),e=j.tR.One(),S=new j.tR(-1,1,1);function Z(h,R){const{byteOffset:l,byteStride:j,type:a,normalized:D}=h,U=h.getSize(),F=R.reduce(((h,R)=>R.getTotalVertices()>h?R.getTotalVertices():h),-Number.MAX_VALUE);return{byteOffset:l,byteStride:j,componentCount:U,type:a,count:F*U,normalized:D,totalVertices:F,kind:h.getKind()}}function M(h){switch(h){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function i(h){switch(h){case u.g.PositionKind:case u.g.NormalKind:case u.g.TangentKind:case u.g.ColorKind:case u.g.MatricesIndicesKind:case u.g.MatricesIndicesExtraKind:case u.g.MatricesWeightsKind:case u.g.MatricesWeightsExtraKind:case u.g.UVKind:case u.g.UV2Kind:case u.g.UV3Kind:case u.g.UV4Kind:case u.g.UV5Kind:case u.g.UV6Kind:return!0}return!1}function d(h){switch(h){case D.e.TriangleFillMode:return 4;case D.e.TriangleStripDrawMode:return 5;case D.e.TriangleFanDrawMode:return 6;case D.e.PointListDrawMode:case D.e.PointFillMode:return 0;case D.e.LineLoopDrawMode:return 2;case D.e.LineListDrawMode:return 1;case D.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${h}`)}function X(h){const R=Math.sqrt(h.x*h.x+h.y*h.y+h.z*h.z);R>0&&(h.x/=R,h.y/=R,h.z/=R)}function V(h){return h.x*=-1,h}function B(h){if(h.x*h.x+h.y*h.y>.5){const R=Math.abs(h.x),l=Math.abs(h.y);if(R>l){const l=Math.sign(h.x);h.x=R,h.y*=-l,h.z*=-l,h.w*=l}else{const R=Math.sign(h.y);h.x*=-R,h.y=l,h.z*=R,h.w*=-R}}else{const R=Math.abs(h.z),l=Math.abs(h.w);if(R>l){const l=Math.sign(h.z);h.x*=-l,h.y*=l,h.z=R,h.w*=-l}else{const R=Math.sign(h.w);h.x*=R,h.y*=-R,h.z*=-R,h.w=l}}return h}function N(h){h.OF(-h.z,h.w,h.x,-h.y)}function hh(h,R){const l=j.tR.FromArrayToRef(R.translation||[0,0,0],0,j.TmpVectors.tR[0]),a=j.Quaternion.FromArrayToRef(R.rotation||[0,0,0,1],0,j.TmpVectors.Quaternion[0]),D=j.Matrix.ComposeToRef(e,a,l,j.TmpVectors.Matrix[0]),U=j.tR.FromArrayToRef(h.translation||[0,0,0],0,j.TmpVectors.tR[2]),F=j.Quaternion.FromArrayToRef(h.rotation||[0,0,0,1],0,j.TmpVectors.Quaternion[1]),w=j.Matrix.ComposeToRef(e,F,U,j.TmpVectors.Matrix[1]);D.multiplyToRef(w,w),w.decompose(void 0,a,l),l.equalsWithEpsilon(C,k.d)?delete R.translation:R.translation=l.sF(),a.equalsWithEpsilon(A,k.d)?delete R.rotation:R.rotation=a.sF(),R.scale&&delete R.scale}function Rh(h,R){if(!(R instanceof c.d))return!1;if(!(1===R.getChildren().length&&0===h.getChildren().length&&h.parent===R))return!1;const l=h.yh(),j=h instanceof H.c&&!l.useRightHandedSystem?S:e;return!!R.yF.equalsWithEpsilon(j,k.d)||(g.c.Warn(`Cannot collapse node ${h.name} into parent node ${R.name} with modified scaling.`),!1)}function lh(h){if(h instanceof Array){const R=new Float32Array(h);return new Uint8Array(R.buffer,R.byteOffset,R.byteLength)}return ArrayBuffer.isView(h)?new Uint8Array(h.buffer,h.byteOffset,h.byteLength):new Uint8Array(h)}function jh(h,R){for(const[l,j]of Object.entries(h)){const a=R[l];(Array.isArray(j)&&Array.isArray(a)&&ah(j,a)||j===a)&&delete h[l]}return h}function ah(h,R){return h.length===R.length&&h.every(((h,l)=>h===R[l]))}const Dh=j.Matrix.Compose(new j.tR(-1,1,1),j.Quaternion.Identity(),j.tR.Zero());function Uh(h,R){if(!(h instanceof c.d))return!1;if(R){if(!h.getWorldMatrix().equalsWithEpsilon(j.Matrix.IdentityReadOnly,k.d))return!1}else{if(!h.getWorldMatrix().multiplyToRef(Dh,j.TmpVectors.Matrix[0]).equalsWithEpsilon(j.Matrix.IdentityReadOnly,k.d))return!1}return!(h instanceof J.c&&h.xF)}const Fh=new Map([[Int8Array,(h,R,l)=>h.setInt8(R,l)],[Uint8Array,(h,R,l)=>h.setUint8(R,l)],[Uint8ClampedArray,(h,R,l)=>h.setUint8(R,l)],[Int16Array,(h,R,l)=>h.setInt16(R,l,!0)],[Uint16Array,(h,R,l)=>h.setUint16(R,l,!0)],[Int32Array,(h,R,l)=>h.setInt32(R,l,!0)],[Uint32Array,(h,R,l)=>h.setUint32(R,l,!0)],[Float32Array,(h,R,l)=>h.setFloat32(R,l,!0)],[Float64Array,(h,R,l)=>h.setFloat64(R,l,!0)]]);class wh{writeTypedArray(h){this._checkGrowBuffer(h.byteLength);const R=Fh.get(h.constructor);for(let l=0;l<h.length;l++)R(this._dataView,this._byteOffset,h[l]),this._byteOffset+=h.BYTES_PER_ELEMENT}constructor(h){this._data=new Uint8Array(h),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(h){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,h),this._byteOffset++}writeInt8(h){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,h),this._byteOffset++}writeInt16(h){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,h,!0),this._byteOffset+=2}writeUInt16(h){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,h,!0),this._byteOffset+=2}writeInt32(h){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,h,!0),this._byteOffset+=4}writeUInt32(h){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,h,!0),this._byteOffset+=4}writeFloat32(h){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,h,!0),this._byteOffset+=4}writeFloat64(h){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,h,!0),this._byteOffset+=8}_checkGrowBuffer(h){const R=this.byteOffset+h;if(R>this._data.byteLength){const h=new Uint8Array(2*R);h.set(this._data),this._data=h,this._dataView=new DataView(this._data.buffer)}}}function mR(h){return h%4===0?4:h%2===0?2:1}class uh{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(h){let R=0;this._bufferViewToData.forEach((h=>{R+=h.byteLength}));const l=new wh(R),j=Array.from(this._bufferViewToData.keys()).sort(((h,R)=>mR(R.byteLength)-mR(h.byteLength)));for(const a of j){a.byteOffset=l.byteOffset,h.push(a);const R=h.length-1,j=this.getPropertiesWithBufferView(a);for(const h of j)h.bufferView=R;l.writeTypedArray(this._bufferViewToData.get(a)),this._bufferViewToData.delete(a)}return l.getOutputData()}createBufferView(h,R){const l={buffer:0,byteOffset:void 0,byteLength:h.byteLength,byteStride:R};return this._bufferViewToData.set(l,h),l}createAccessor(h,R,l,j,a,D,U){this._verifyBufferView(h);const F={bufferView:void 0,componentType:l,count:j,type:R,min:null===D||void 0===D?void 0:D.min,max:null===D||void 0===D?void 0:D.max,normalized:U,byteOffset:a};return this.setBufferView(F,h),this._accessorToBufferView.set(F,h),F}setBufferView(h,R){this._verifyBufferView(R);this.getPropertiesWithBufferView(R).push(h)}removeBufferView(h){const R=this.getPropertiesWithBufferView(h);for(const l of R)void 0!==l.bufferView&&delete l.bufferView;this._bufferViewToData.delete(h),this._bufferViewToProperties.delete(h),this._accessorToBufferView.forEach(((R,l)=>{R===h&&(void 0!==l.byteOffset&&delete l.byteOffset,this._accessorToBufferView.delete(l))}))}getBufferView(h){const R=this._accessorToBufferView.get(h);return this._verifyBufferView(R),R}getPropertiesWithBufferView(h){return this._verifyBufferView(h),this._bufferViewToProperties.set(h,this._bufferViewToProperties.get(h)??[]),this._bufferViewToProperties.get(h)}getData(h){return this._verifyBufferView(h),this._bufferViewToData.get(h)}_verifyBufferView(h){if(void 0===h||!this._bufferViewToData.has(h))throw new Error(`BufferView ${h} not found in BufferManager.`)}}var ch,Jh=l(13313),qh=l(13332),Qh=l(13366),Yh=l(13235),sh=l(13399),th=l(13408),fh=l(13310),Th=l(13417);!function(h){h[h.INTANGENT=0]="INTANGENT",h[h.OUTTANGENT=1]="OUTTANGENT"}(ch||(ch={}));class Eh{static _IsTransformable(h){return h&&(h instanceof c.d||h instanceof Jh.e||h instanceof Th.e)}static _CreateNodeAnimation(h,R,l,j,D){if(this._IsTransformable(h)){const U=[],F=[],w=R.getKeys(),mh=Eh._CalculateMinMaxKeyFrames(w),u=Eh._DeduceInterpolation(w,l,j),c=u.interpolationType,J=u.shouldBakeAnimation;if(J?Eh._CreateBakedAnimation(h,R,l,mh.min,mh.max,R.framePerSecond,D,U,F,mh,j):"LINEAR"===c||"STEP"===c?Eh._CreateLinearOrStepAnimation(h,R,l,U,F,j):"CUBICSPLINE"===c?Eh._CreateCubicSplineAnimation(h,R,l,U,F,j):Eh._CreateBakedAnimation(h,R,l,mh.min,mh.max,R.framePerSecond,D,U,F,mh,j),U.length&&F.length){return{inputs:U,outputs:F,samplerInterpolation:c,inputsMin:J?mh.min:a.Tools.FloatRound(mh.min/R.framePerSecond),inputsMax:J?mh.max:a.Tools.FloatRound(mh.max/R.framePerSecond)}}}return null}static _DeduceAnimationInfo(h){let R=null,l="VEC3",j=!1;const D=h.targetProperty.split(".");switch(D[0]){case"yF":R="scale";break;case"position":R="translation";break;case"rotation":l="VEC4",R="rotation";break;case"rotationQuaternion":l="VEC4",j=!0,R="rotation";break;case"influence":l="SCALAR",R="weights";break;default:a.Tools.Error(`Unsupported animatable property ${D[0]}`)}return R?{animationChannelTargetPath:R,dataAccessorType:l,useQuaternion:j}:(a.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(h,R,l,j,a,D,U,F,w,mh,u){let c;if(Eh._IsTransformable(h)&&h.animations)for(const J of h.animations){if(u&&!u(J))continue;const a=Eh._DeduceAnimationInfo(J);a&&(c={name:J.name,samplers:[],channels:[]},Eh._AddAnimation(`${J.name}`,J.hasRunningRuntimeAnimations?R:c,h,J,a.dataAccessorType,a.animationChannelTargetPath,j,D,U,F,a.useQuaternion,w,mh),c.samplers.length&&c.channels.length&&l.push(c))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(h,R,l,j,a,D,U,F,w,mh,u){let c;if(h instanceof fh.b){const a=h.morphTargetManager;if(a)for(let J=0;J<a.numTargets;++J){const q=a.getTarget(J);for(const Q of q.animations){if(u&&!u(Q))continue;const q=new sh.b(`${Q.name}`,"influence",Q.framePerSecond,Q.dataType,Q.loopMode,Q.enableBlending),Y=[],s=Q.getKeys();for(let h=0;h<s.length;++h){const R=s[h];for(let h=0;h<a.numTargets;++h)h==J?Y.push(R):Y.push({frame:R.frame,value:0})}q.setKeys(Y);const t=Eh._DeduceAnimationInfo(q);t&&(c={name:q.name,samplers:[],channels:[]},Eh._AddAnimation(Q.name,Q.hasRunningRuntimeAnimations?R:c,h,q,t.dataAccessorType,t.animationChannelTargetPath,j,D,U,F,t.useQuaternion,w,mh,a.numTargets),c.samplers.length&&c.channels.length&&l.push(c))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(h,R,l,j,a,D,U,F,w){let mh;if(h.animationGroups){const c=h.animationGroups;for(const J of c){const c=new Map,q=new Map,Q=new Set,Y=J.to-J.from;mh={name:J.name,channels:[],samplers:[]};for(let R=0;R<J.targetedAnimations.length;++R){const Y=J.targetedAnimations[R],s=Y.target,t=Y.animation;if(w&&!w(t))continue;const f=F.has(s);if(this._IsTransformable(s)||1===s.length&&this._IsTransformable(s[0])){const h=Eh._DeduceAnimationInfo(Y.animation);if(h){const R=this._IsTransformable(s)?s:this._IsTransformable(s[0])?s[0]:null;R&&Eh._AddAnimation(`${t.name}`,mh,R,t,h.dataAccessorType,h.animationChannelTargetPath,l,j,a,D,h.useQuaternion,U,f)}}else if(s instanceof th.b||1===s.length&&s[0]instanceof th.b){if(Eh._DeduceAnimationInfo(Y.animation)){const R=s instanceof th.b?s:s[0];if(R){const l=h.morphTargetManagers.find((h=>{for(let l=0;l<h.numTargets;++l)if(h.getTarget(l)===R)return!0;return!1}));if(l){const j=h.meshes.find((h=>h.morphTargetManager===l));var u;if(j)c.has(j)||c.set(j,new Map),null===(u=c.get(j))||void 0===u||u.set(R,t),Q.add(j),q.set(j,t)}}}}}Q.forEach((h=>{const R=h.morphTargetManager;let F=null;const w=[],u=q.get(h).getKeys(),Q=u.length;for(let l=0;l<Q;++l)for(let j=0;j<R.numTargets;++j){const a=R.getTarget(j),D=c.get(h);if(D){const R=D.get(a);R?(F||(F=new sh.b(`${J.name}_${h.name}_MorphWeightAnimation`,"influence",R.framePerSecond,sh.b.ANIMATIONTYPE_FLOAT,R.loopMode,R.enableBlending)),w.push(R.getKeys()[l])):w.push({frame:J.from+Y/Q*l,value:a.influence,inTangent:u[0].inTangent?0:void 0,outTangent:u[0].outTangent?0:void 0})}}F.setKeys(w);const s=Eh._DeduceAnimationInfo(F);s&&Eh._AddAnimation(`${J.name}_${h.name}_MorphWeightAnimation`,mh,h,F,s.dataAccessorType,s.animationChannelTargetPath,l,j,a,D,s.useQuaternion,U,!1,null===R||void 0===R?void 0:R.numTargets)})),mh.channels.length&&mh.samplers.length&&R.push(mh)}}}static _AddAnimation(h,R,l,a,D,U,F,w,mh,u,c,J,q,Q){const Y=Eh._CreateNodeAnimation(l,a,U,c,J);let s,t,f,T,E,x;if(Y){if(Q){let h=0,R=0;const l=[];for(;Y.inputs.length>0;)R=Y.inputs.shift(),h%Q==0&&l.push(R),h++;Y.inputs=l}const h=F.get(l),a=new Float32Array(Y.inputs);s=w.createBufferView(a),t=w.createAccessor(s,"SCALAR",5126,Y.inputs.length,void 0,{min:[Y.inputsMin],max:[Y.inputsMax]}),u.push(t),f=u.length-1;const mh=new j.Quaternion,c=new j.tR,J=new j.tR,G=l instanceof Jh.e,p=M(D),O=new Float32Array(Y.outputs.length*p);Y.outputs.forEach((function(h,R){let l=h;switch(U){case"translation":q&&(j.tR.FromArrayToRef(h,0,J),V(J),J.toArray(l));break;case"rotation":4===h.length?j.Quaternion.FromArrayToRef(h,0,mh):(l=new Array(4),j.tR.FromArrayToRef(h,0,c),j.Quaternion.FromEulerVectorToRef(c,mh)),q&&(B(mh),G&&N(mh)),mh.toArray(l)}O.set(l,R*p)})),s=w.createBufferView(O),t=w.createAccessor(s,D,5126,Y.outputs.length),u.push(t),T=u.length-1,E={interpolation:Y.samplerInterpolation,input:f,output:T},R.samplers.push(E),x={sampler:R.samplers.length-1,target:{node:h,path:U}},R.channels.push(x)}}static _CreateBakedAnimation(h,R,l,D,U,F,w,mh,u,c,J){let q;const Q=j.Quaternion.Identity();let Y,s=null,t=null,f=null,T=null,E=null,x=null;c.min=a.Tools.FloatRound(D/F);const G=R.getKeys();for(let j=0,p=G.length;j<p;++j){if(x=null,f=G[j],j+1<p)if(T=G[j+1],f.value.equals&&f.value.equals(T.value)||f.value===T.value){if(0!==j)continue;x=f.frame}else x=T.frame;else{if(E=G[j-1],f.value.equals&&f.value.equals(E.value)||f.value===E.value)continue;x=U}if(x)for(let j=f.frame;j<=x;j+=w){if(Y=a.Tools.FloatRound(j/F),Y===s)continue;s=Y,t=Y;const D={key:0,repeatCount:0,loopMode:R.loopMode};q=R._interpolate(j,D),Eh._SetInterpolatedValue(h,q,Y,R,l,Q,mh,u,J)}}t&&(c.max=t)}static _ConvertFactorToVector3OrQuaternion(h,R,l,D,U){const F=Eh._GetBasePositionRotationOrScale(R,D,U),w=l.targetProperty.split("."),mh=w?w[1]:"",u=U?j.Quaternion.GR(F).normalize():j.tR.GR(F);switch(mh){case"x":case"y":case"z":u[mh]=h;break;case"w":u.w=h;break;default:a.Tools.Error(`glTFAnimation: Unsupported component name "${mh}"!`)}return u}static _SetInterpolatedValue(h,R,l,a,D,U,F,w,mh){let u;F.push(l),"weights"!==D?(a.dataType===sh.b.ANIMATIONTYPE_FLOAT&&(R=this._ConvertFactorToVector3OrQuaternion(R,h,a,D,mh)),"rotation"===D?(mh?U=R:(u=R,j.Quaternion.RotationYawPitchRollToRef(u.y,u.x,u.z,U)),w.push(U.sF())):(u=R,w.push(u.sF()))):w.push([R])}static _CreateLinearOrStepAnimation(h,R,l,j,a,D){for(const U of R.getKeys())j.push(U.frame/R.framePerSecond),Eh._AddKeyframeValue(U,R,a,l,h,D)}static _CreateCubicSplineAnimation(h,R,l,j,a,D){R.getKeys().forEach((function(U){j.push(U.frame/R.framePerSecond),Eh._AddSplineTangent(ch.INTANGENT,a,l,"CUBICSPLINE",U,D),Eh._AddKeyframeValue(U,R,a,l,h,D),Eh._AddSplineTangent(ch.OUTTANGENT,a,l,"CUBICSPLINE",U,D)}))}static _GetBasePositionRotationOrScale(h,R,l){let a;if("rotation"===R)if(l){a=(h.rotationQuaternion??j.Quaternion.Identity()).sF()}else{a=(h.rotation??j.tR.Zero()).sF()}else if("translation"===R){a=(h.position??j.tR.Zero()).sF()}else{a=(h.yF??j.tR.One()).sF()}return a}static _AddKeyframeValue(h,R,l,D,U,F){let w;const mh=R.dataType;if(mh===sh.b.ANIMATIONTYPE_VECTOR3){let R=h.value.sF();if("rotation"===D){const h=j.tR.GR(R);R=j.Quaternion.RotationYawPitchRoll(h.y,h.x,h.z).sF()}l.push(R)}else if(mh===sh.b.ANIMATIONTYPE_FLOAT){if("weights"===D)l.push([h.value]);else if(w=this._ConvertFactorToVector3OrQuaternion(h.value,U,R,D,F),w){if("rotation"===D){const h=F?w:j.Quaternion.RotationYawPitchRoll(w.y,w.x,w.z).normalize();l.push(h.sF())}l.push(w.sF())}}else mh===sh.b.ANIMATIONTYPE_QUATERNION?l.push(h.value.normalize().sF()):a.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(h,R,l){let j,a,D=!1;if("rotation"===R&&!l)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let U=0,F=h.length;U<F;++U)if(a=h[U],a.inTangent||a.outTangent)if(j){if("CUBICSPLINE"!==j){j="LINEAR",D=!0;break}}else j="CUBICSPLINE";else if(j){if("CUBICSPLINE"===j||a.interpolation&&1===a.interpolation&&"STEP"!==j){j="LINEAR",D=!0;break}}else j=a.interpolation&&1===a.interpolation?"STEP":"LINEAR";return j||(j="LINEAR"),{interpolationType:j,shouldBakeAnimation:D}}static _AddSplineTangent(h,R,l,a,D,U){let F;const w=h===ch.INTANGENT?D.inTangent:D.outTangent;if("CUBICSPLINE"===a){if("rotation"===l)if(w)if(U)F=w.sF();else{const h=w;F=j.Quaternion.RotationYawPitchRoll(h.y,h.x,h.z).sF()}else F=[0,0,0,0];else F="weights"===l?w?[w]:[0]:w?w.sF():[0,0,0];R.push(F)}}static _CalculateMinMaxKeyFrames(h){let R=1/0,l=-1/0;return h.forEach((function(h){R=Math.min(R,h.frame),l=Math.max(l,h.frame)})),{min:R,max:l}}}function xh(h,R,l,D,U,F){const w={attributes:{},influence:h.influence,name:h.name},mh=R.xF;if(!mh)return a.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),w;const c=F?-1:1,J=j.tR.Zero();let q=0,Q=0;if(h.hasPositions){const D=h.getPositions(),F=mh.getVerticesData(u.g.PositionKind);if(F){const h=new Float32Array(F.length),R=[1/0,1/0,1/0],a=[-1/0,-1/0,-1/0];Q=F.length/3,q=0;for(let l=q;l<Q;++l){const U=j.tR.GR(F,3*l);j.tR.GR(D,3*l).subtractToRef(U,J),J.x*=c,R[0]=Math.min(R[0],J.x),a[0]=Math.max(a[0],J.x),R[1]=Math.min(R[1],J.y),a[1]=Math.max(a[1],J.y),R[2]=Math.min(R[2],J.z),a[2]=Math.max(a[2],J.z),h[3*l]=J.x,h[3*l+1]=J.y,h[3*l+2]=J.z}const mh=l.createBufferView(h,12),u=l.createAccessor(mh,"VEC3",5126,D.length/3,0,{min:R,max:a});U.push(u),w.attributes.POSITION=U.length-1}else a.Tools.Warn(`Morph target positions for mesh ${R.name} were not exported. Mesh does not have position vertex data`)}if(h.hasNormals){const D=h.getNormals(),F=mh.getVerticesData(u.g.NormalKind);if(F){const h=new Float32Array(F.length);Q=F.length/3,q=0;for(let l=q;l<Q;++l){const R=j.tR.GR(F,3*l).normalize();j.tR.GR(D,3*l).normalize().subtractToRef(R,J),h[3*l]=J.x*c,h[3*l+1]=J.y,h[3*l+2]=J.z}const R=l.createBufferView(h,12),a=l.createAccessor(R,"VEC3",5126,D.length/3,0);U.push(a),w.attributes.NORMAL=U.length-1}else a.Tools.Warn(`Morph target normals for mesh ${R.name} were not exported. Mesh does not have normals vertex data`)}if(h.hasTangents){const D=h.getTangents(),F=mh.getVerticesData(u.g.TangentKind);if(F){Q=F.length/4;const h=new Float32Array(3*Q);q=0;for(let l=q;l<Q;++l){const R=j.tR.GR(F,4*l);X(R);const a=j.tR.GR(D,3*l);X(a),a.subtractToRef(R,J),h[3*l]=J.x*c,h[3*l+1]=J.y,h[3*l+2]=J.z}const R=l.createBufferView(h,12),a=l.createAccessor(R,"VEC3",5126,Q,0);U.push(a),w.attributes.TANGENT=U.length-1}else a.Tools.Warn(`Morph target tangents for mesh ${R.name} were not exported. Mesh does not have tangents vertex data`)}if(h.hasColors){const D=h.getColors(),F=mh.getVerticesData(u.g.ColorKind),c=mh.getVertexBuffer(u.g.ColorKind);if(F&&c){const h=c.getSize();Q=F.length/h;const R=new Float32Array(Q*h);q=0;for(let l=q;l<Q;++l)if(3===h){const a=j.tR.GR(F,l*h);j.tR.GR(D,l*h).subtractToRef(a,J),R[3*l]=J.x,R[3*l+1]=J.y,R[3*l+2]=J.z}else if(4===h){const a=new j.Vector4,U=j.Vector4.GR(F,l*h);j.Vector4.GR(D,l*h).subtractToRef(U,a),R[4*l]=a.x,R[4*l+1]=a.y,R[4*l+2]=a.z,R[4*l+3]=a.w}else a.Tools.Warn(`Unsupported number of components for color attribute: ${h}`);const mh=l.createBufferView(R,4*h),u=l.createAccessor(mh,3===h?"VEC3":"VEC4",5126,Q,0);U.push(u),w.attributes.COLOR_0=U.length-1}else a.Tools.Warn(`Morph target colors for mesh ${R.name} were not exported. Mesh does not have colors vertex data`)}return w}var Gh=l(13419),ph=l(13266),Oh=l(13247),yh=l(12852);class vh{}vh.DEFAULT_COLOR=s.xR.White(),vh.DEFAULT_WIDTH_ATTENUATED=1,vh.DEFAULT_WIDTH=.1;var bh=l(13100),Ih=l(13423);class Lh{static ConvertPoints(h,R){if(h.length&&Array.isArray(h)&&"number"===typeof h[0])return[h];if(h.length&&Array.isArray(h[0])&&"number"===typeof h[0][0])return h;if(h.length&&!Array.isArray(h[0])&&h[0]instanceof j.tR){const R=[];for(let l=0;l<h.length;l++){const j=h[l];R.push(j.x,j.y,j.z)}return[R]}if(h.length>0&&Array.isArray(h[0])&&h[0].length>0&&h[0][0]instanceof j.tR){const R=[],l=h;for(const h of l)R.push(h.flatMap((h=>[h.x,h.y,h.z])));return R}if(h instanceof Float32Array){if(null!==R&&void 0!==R&&R.floatArrayStride){const l=[],j=3*R.floatArrayStride;for(let R=0;R<h.length;R+=j){const a=new Array(j);for(let l=0;l<j;l++)a[l]=h[R+l];l.push(a)}return l}return[Array.from(h)]}if(h.length&&h[0]instanceof Float32Array){const R=[];for(const l of h)R.push(Array.from(l));return R}return[]}static OmitZeroLengthPredicate(h,R,l){const j=[];return R.fR(h).lengthSquared()>0&&j.push([h,R]),l.fR(R).lengthSquared()>0&&j.push([R,l]),h.fR(l).lengthSquared()>0&&j.push([l,h]),0===j.length?null:j}static OmitDuplicatesPredicate(h,R,l,j){const a=[];return Lh._SearchInPoints(h,R,j)||a.push([h,R]),Lh._SearchInPoints(R,l,j)||a.push([R,l]),Lh._SearchInPoints(l,h,j)||a.push([l,h]),0===a.length?null:a}static _SearchInPoints(h,R,l){for(const U of l)for(let l=0;l<U.length;l++){var j,a,D;if(null!==(j=U[l])&&void 0!==j&&j.equals(h))if(null!==(a=U[l+1])&&void 0!==a&&a.equals(R)||null!==(D=U[l-1])&&void 0!==D&&D.equals(R))return!0}return!1}static MeshesToLines(h,R){const l=[];for(let a=0;a<h.length;a++){const D=h[a],U=D.getVerticesData(u.g.PositionKind),F=D.GF();if(U&&F)for(let h=0,w=0;h<F.length;h++){const mh=3*F[w++],u=3*F[w++],c=3*F[w++],J=new j.tR(U[mh],U[mh+1],U[mh+2]),q=new j.tR(U[u],U[u+1],U[u+2]),Q=new j.tR(U[c],U[c+1],U[c+2]);if(R){const j=R(J,q,Q,l,h,mh,D,a,U,F);if(j)for(const h of j)l.push(h)}else l.push([J,q],[q,Q],[Q,J])}}return l}static ToVector3Array(h){if(Array.isArray(h[0])){const R=[],l=h;for(const h of l){const l=[];for(let R=0;R<h.length;R+=3)l.push(new j.tR(h[R],h[R+1],h[R+2]));R.push(l)}return R}const R=h,l=[];for(let a=0;a<R.length;a+=3)l.push(new j.tR(R[a],R[a+1],R[a+2]));return l}static ToNumberArray(h){return h.flatMap((h=>[h.x,h.y,h.z]))}static GetPointsCountInfo(h){const R=new Array(h.length);let l=0;for(let j=h.length;j--;)R[j]=h[j].length/3,l+=R[j];return{total:l,counts:R}}static GetLineLength(h){if(0===h.length)return 0;let R;R="number"===typeof h[0]?Lh.ToVector3Array(h):h;const l=j.TmpVectors.tR[0];let a=0;for(let j=0;j<R.length-1;j++){const h=R[j];a+=R[j+1].subtractToRef(h,l).length()}return a}static GetLineLengthArray(h){const R=new Float32Array(h.length/3);let l=0;for(let j=0,a=h.length/3-1;j<a;j++){let a=h[3*j+0],D=h[3*j+1],U=h[3*j+2];a-=h[3*j+3],D-=h[3*j+4],U-=h[3*j+5];l+=Math.sqrt(a*a+D*D+U*U),R[j+1]=l}return R}static SegmentizeSegmentByCount(h,R,l){const a=[],D=R.fR(h),U=j.TmpVectors.tR[0];U.vF(l);const F=j.TmpVectors.tR[1];D.divideToRef(U,F);let w=h.clone();a.push(w);for(let j=0;j<l;j++)w=w.clone(),a.push(w.addInPlace(F));return a}static SegmentizeLineBySegmentLength(h,R){const l=h[0]instanceof j.tR?Lh.GetLineSegments(h):"number"===typeof h[0]?Lh.GetLineSegments(Lh.ToVector3Array(h)):h,a=[];for(const j of l)if(j.length>R){const h=Lh.SegmentizeSegmentByCount(j.point1,j.point2,Math.ceil(j.length/R));for(const R of h)a.push(R)}else a.push(j.point1),a.push(j.point2);return a}static SegmentizeLineBySegmentCount(h,R){const l="number"===typeof h[0]?Lh.ToVector3Array(h):h,j=Lh.GetLineLength(l)/R;return Lh.SegmentizeLineBySegmentLength(l,j)}static GetLineSegments(h){const R=[];for(let l=0;l<h.length-1;l++){const j=h[l],a=h[l+1],D=a.fR(j).length();R.push({point1:j,point2:a,length:D})}return R}static GetMinMaxSegmentLength(h){const R=Lh.GetLineSegments(h).sort((h=>h.length));return{min:R[0].length,max:R[R.length-1].length}}static GetPositionOnLineByVisibility(h,R,l){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const D=R*l;let U=0,F=0;const w=h.length;for(let j=0;j<w;j++){if(D<=U+h[j].length){F=j;break}U+=h[j].length}const mh=(D-U)/h[F].length;return h[F].point2.subtractToRef(h[F].point1,j.TmpVectors.tR[0]),j.TmpVectors.tR[1]=j.TmpVectors.tR[0].multiplyByFloats(mh,mh,mh),a||j.TmpVectors.tR[1].addInPlace(h[F].point1),j.TmpVectors.tR[1].clone()}static GetCircleLinePoints(h,R){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:h,D=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/R;const U=[];for(let F=0;F<=R;F++)U.push(new j.tR(Math.cos(F*D)*h,Math.sin(F*D)*a,l));return U}static GetBezierLinePoints(h,R,l,j){return bh.d.CreateQuadraticBezier(h,R,l,j).getPoints().flatMap((h=>[h.x,h.y,h.z]))}static GetArrowCap(h,R,l,j,a){let D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[h.clone(),h.add(R.multiplyByFloats(l,l,l))],widths:[j,a,D,U]}}static GetPointsFromText(h,R,l,j){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,D=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const U=[],F=(0,Ih.e)(h,R,l,j);for(const w of F){for(const h of w.paths){const R=[],l=h.getPoints();for(const h of l)R.push(h.x,h.y,a);U.push(R)}if(D)for(const h of w.holes){const R=[],l=h.getPoints();for(const h of l)R.push(h.x,h.y,a);U.push(R)}}return U}static Color3toRGBAUint8(h){const R=new Uint8Array(4*h.length);for(let l=0,j=0;l<h.length;l++)R[j++]=255*h[l].r,R[j++]=255*h[l].g,R[j++]=255*h[l].b,R[j++]=255;return R}static CreateColorsTexture(h,R,l,j){const a=j.getEngine().getCaps().maxTextureSize??1,D=R.length>a?a:R.length,U=Math.ceil(R.length/a);U>1&&(R=[...R,...Array(D*U-R.length).fill(R[0])]);const F=Lh.Color3toRGBAUint8(R),w=new G.e(F,D,U,Q.c.TEXTUREFORMAT_RGBA,j,!1,!0,l);return w.name=h,w}static PrepareEmptyColorsTexture(h){if(!vh.EmptyColorsTexture){const R=new Uint8Array(4);vh.EmptyColorsTexture=new G.e(R,1,1,Q.c.TEXTUREFORMAT_RGBA,h,!1,!1,G.e.NEAREST_NEAREST),vh.EmptyColorsTexture.name="grlEmptyColorsTexture"}return vh.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var h;null===(h=vh.EmptyColorsTexture)||void 0===h||h.dispose(),vh.EmptyColorsTexture=null}static BooleanToNumber(h){return h?1:0}}class nh extends Oh.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class rh extends ph.b{isCompatible(h){return!0}constructor(h,R,l){var a;l=l||{color:vh.DEFAULT_COLOR};const D=new nh;D.GREASED_LINE_HAS_COLOR=!!l.color&&!l.useColors,D.GREASED_LINE_SIZE_ATTENUATION=l.sizeAttenuation??!1,D.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===l.colorDistributionType,D.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(R??h.yh()).useRightHandedSystem,D.GREASED_LINE_CAMERA_FACING=l.cameraFacing??!0,super(h,rh.GREASED_LINE_MATERIAL_NAME,200,D,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(a=l)||void 0===a?void 0:a.forceGLSL)||rh.ForceGLSL,this._scene=R??h.yh(),this._engine=this._scene.getEngine(),this._cameraFacing=l.cameraFacing??!0,this.visibility=l.visibility??1,this.useDash=l.useDash??!1,this.dashRatio=l.dashRatio??.5,this.dashOffset=l.dashOffset??0,this.width=l.width?l.width:l.sizeAttenuation?vh.DEFAULT_WIDTH_ATTENUATED:vh.DEFAULT_WIDTH,this._sizeAttenuation=l.sizeAttenuation??!1,this.colorMode=l.colorMode??0,this._color=l.color??null,this.useColors=l.useColors??!1,this._colorsDistributionType=l.colorDistributionType??0,this.colorsSampling=l.colorsSampling??G.e.NEAREST_NEAREST,this._colors=l.nh??null,this.dashCount=l.dashCount??1,this.resolution=l.resolution??new j.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),l.colorsTexture?this.colorsTexture=l.colorsTexture:this._colors?this.colorsTexture=Lh.CreateColorsTexture(`${h.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??vh.DEFAULT_COLOR,Lh.PrepareEmptyColorsTexture(this._scene)),this._engine.mw.add((()=>{Lh.DisposeEmptyColorsTexture()}))}getAttributes(h){h.push("grl_offsets"),h.push("grl_widths"),h.push("grl_colorPointers"),h.push("grl_counters"),this._cameraFacing?(h.push("grl_previousAndSide"),h.push("grl_nextAndCounters")):h.push("grl_slopes")}getSamplers(h){h.push("grl_colors")}getActiveTextures(h){this.colorsTexture&&h.push(this.colorsTexture)}getUniforms(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const R=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&R.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===h&&R.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:R,vertex:this._cameraFacing&&this._isGLSL(h)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(h)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(h){if(this._cameraFacing){h.TF("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||h.TF("viewProjection",this._scene.getTransformMatrix());const R=j.TmpVectors.Vector4[0];R.x=this._aspect,R.y=this._resolution.x,R.z=this._resolution.y,R.w=this.width,h.updateVector4("grl_aspect_resolution_lineWidth",R)}const R=j.TmpVectors.Vector4[0];R.x=Lh.BooleanToNumber(this.useDash),R.y=this._dashArray,R.z=this.dashOffset,R.w=this.dashRatio,h.updateVector4("grl_dashOptions",R);const l=j.TmpVectors.Vector4[1];l.x=this.colorMode,l.y=this.visibility,l.z=this.colorsTexture?this.colorsTexture.getSize().width:0,l.w=Lh.BooleanToNumber(this.useColors),h.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",l),this._color&&h.updateColor3("grl_singleColor",this._color);const a=this.colorsTexture??vh.EmptyColorsTexture;h.setTexture("grl_colors",a),h.updateFloat2("grl_textureSize",(null===a||void 0===a?void 0:a.getSize().width)??1,(null===a||void 0===a?void 0:a.getSize().height)??1)}prepareDefines(h,R,l){h.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,h.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,h.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,h.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=R.useRightHandedSystem,h.GREASED_LINE_CAMERA_FACING=this._cameraFacing,h.GREASED_LINE_USE_OFFSETS=!!l.offsets}getClassName(){return rh.GREASED_LINE_MATERIAL_NAME}getCustomCode(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(R)?function(h,R){if("vertex"===h){const h={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return R&&(h["!gl_Position\\=viewProjection\\*worldPos;"]="//"),h}return"fragment"===h?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(h,this._cameraFacing):function(h,R){if("vertex"===h){const h={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return R&&(h["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),h}return"fragment"===h?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(h,this._cameraFacing)}dispose(){var h;null===(h=this.colorsTexture)||void 0===h||h.dispose(),super.dispose()}get nh(){return this._colors}set nh(h){this.setColors(h)}setColors(h){var R;let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1],j=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=(null===(R=this._colors)||void 0===R?void 0:R.length)??0;var D;if(this._colors=h,null!==h&&0!==h.length){if(!l||j)if(this.colorsTexture&&a===h.length&&!j){const R=Lh.Color3toRGBAUint8(h);this.colorsTexture.update(R)}else{var U;null===(U=this.colorsTexture)||void 0===U||U.dispose(),this.colorsTexture=Lh.CreateColorsTexture(`${this._material.name}-colors-texture`,h,this.colorsSampling,this._scene)}}else null===(D=this.colorsTexture)||void 0===D||D.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(h){this._dashCount=h,this._dashArray=1/h}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(h){this._sizeAttenuation=h,this.markAllDefinesAsDirty()}get color(){return this._color}set color(h){this.setColor(h)}setColor(h){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==h||null!==this._color&&null===h?(this._color=h,R||this.markAllDefinesAsDirty()):this._color=h}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(h){this._colorsDistributionType=h,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(h){this._aspect=h.x/h.y,this._resolution=h}serialize(){const h=super.serialize(),R={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(R.nh=this._colors),this._color&&(R.color=this._color),h.greasedLineMaterialOptions=R,h}parse(h,R,l){var j;super.parse(h,R,l);const a=h.greasedLineMaterialOptions;null===(j=this.colorsTexture)||void 0===j||j.dispose(),a.color&&this.setColor(a.color,!0),a.colorDistributionType&&(this.colorsDistributionType=a.colorDistributionType),a.nh&&(this.nh=a.nh),a.colorsSampling&&(this.colorsSampling=a.colorsSampling),a.colorMode&&(this.colorMode=a.colorMode),a.useColors&&(this.useColors=a.useColors),a.visibility&&(this.visibility=a.visibility),a.useDash&&(this.useDash=a.useDash),a.dashCount&&(this.dashCount=a.dashCount),a.dashRatio&&(this.dashRatio=a.dashRatio),a.dashOffset&&(this.dashOffset=a.dashOffset),a.width&&(this.width=a.width),a.sizeAttenuation&&(this.sizeAttenuation=a.sizeAttenuation),a.resolution&&(this.resolution=a.resolution),this.nh?this.colorsTexture=Lh.CreateColorsTexture(`${this._material.name}-colors-texture`,this.nh,this.colorsSampling,R):Lh.PrepareEmptyColorsTexture(R),this.markAllDefinesAsDirty()}copyTo(h){var R;const l=h;null===(R=l.colorsTexture)||void 0===R||R.dispose(),this._colors&&(l.colorsTexture=Lh.CreateColorsTexture(`${l._material.name}-colors-texture`,this._colors,l.colorsSampling,this._scene)),l.setColor(this.color,!0),l.colorsDistributionType=this.colorsDistributionType,l.colorsSampling=this.colorsSampling,l.colorMode=this.colorMode,l.useColors=this.useColors,l.visibility=this.visibility,l.useDash=this.useDash,l.dashCount=this.dashCount,l.dashRatio=this.dashRatio,l.dashOffset=this.dashOffset,l.width=this.width,l.sizeAttenuation=this.sizeAttenuation,l.resolution=this.resolution,l.markAllDefinesAsDirty()}_isGLSL(h){return 0===h||this._forceGLSL}}rh.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",rh.ForceGLSL=!1,(0,yh.f)(`BABYLON.${rh.GREASED_LINE_MATERIAL_NAME}`,rh);var Ph=l(13298),zh=l(12718),oh=l(13120),Kh=l(12837);class Wh extends oh.ShaderMaterial{constructor(h,R,a){const D=R.getEngine(),U=D.isWebGPU&&!(a.forceGLSL||Wh.ForceGLSL),F=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];R.useRightHandedSystem&&F.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const w=["position","grl_widths","grl_offsets","grl_colorPointers"];a.cameraFacing?(F.push("GREASED_LINE_CAMERA_FACING"),w.push("grl_previousAndSide","grl_nextAndCounters")):(w.push("grl_slopes"),w.push("grl_counters"));const mh=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(U||mh.push("world","viewProjection","view","projection"),super(h,R,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:U?["Scene","Mesh"]:void 0,attributes:w,uniforms:mh,samplers:U?[]:["grlColors"],defines:F,extraInitializationsAsync:async()=>{U?await Promise.all([l.e(66).then(l.bind(l,16066)),l.e(75).then(l.bind(l,16070))]):await Promise.all([l.e(69).then(l.bind(l,16079)),l.e(76).then(l.bind(l,16086))])},shaderLanguage:U?1:0}),this._color=s.xR.White(),this._colorsDistributionType=0,this._colorsTexture=null,a=a||{color:vh.DEFAULT_COLOR},this.visibility=a.visibility??1,this.useDash=a.useDash??!1,this.dashRatio=a.dashRatio??.5,this.dashOffset=a.dashOffset??0,this.dashCount=a.dashCount??1,this.width=a.width?a.width:a.sizeAttenuation&&a.cameraFacing?vh.DEFAULT_WIDTH_ATTENUATED:vh.DEFAULT_WIDTH,this.sizeAttenuation=a.sizeAttenuation??!1,this.color=a.color??s.xR.White(),this.useColors=a.useColors??!1,this.colorsDistributionType=a.colorDistributionType??0,this.colorsSampling=a.colorsSampling??G.e.NEAREST_NEAREST,this.colorMode=a.colorMode??0,this._colors=a.nh??null,this._cameraFacing=a.cameraFacing??!0,this.resolution=a.resolution??new j.Vector2(D.getRenderWidth(),D.getRenderHeight()),a.colorsTexture?this.colorsTexture=a.colorsTexture:this._colors?this.colorsTexture=Lh.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,R):(this._color=this._color??vh.DEFAULT_COLOR,this.colorsTexture=Lh.PrepareEmptyColorsTexture(R)),U){const h=new Kh.d;h.setParameters(),h.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",h)}D.mw.add((()=>{Lh.DisposeEmptyColorsTexture()}))}dispose(){var h;null===(h=this._colorsTexture)||void 0===h||h.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new j.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get nh(){return this._colors}set nh(h){this.setColors(h)}setColors(h){var R;let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1],j=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=(null===(R=this._colors)||void 0===R?void 0:R.length)??0;var D;if(this._colors=h,null!==h&&0!==h.length){if(!l||j)if(this._colorsTexture&&a===h.length&&!j){const R=Lh.Color3toRGBAUint8(h);this._colorsTexture.update(R)}else{var U;null===(U=this._colorsTexture)||void 0===U||U.dispose(),this.colorsTexture=Lh.CreateColorsTexture(`${this.name}-colors-texture`,h,this.colorsSampling,this.yh())}}else null===(D=this._colorsTexture)||void 0===D||D.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(h){this._colorsTexture=h,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(h){this._width=h,this.setFloat("grlWidth",h)}get useColors(){return this._useColors}set useColors(h){this._useColors=h,this.setFloat("grlUseColors",Lh.BooleanToNumber(h))}get colorsSampling(){return this._colorsSampling}set colorsSampling(h){this._colorsSampling=h}get visibility(){return this._visibility}set visibility(h){this._visibility=h,this.setFloat("grlVisibility",h)}get useDash(){return this._useDash}set useDash(h){this._useDash=h,this.setFloat("grlUseDash",Lh.BooleanToNumber(h))}get dashOffset(){return this._dashOffset}set dashOffset(h){this._dashOffset=h,this.setFloat("grlDashOffset",h)}get dashRatio(){return this._dashRatio}set dashRatio(h){this._dashRatio=h,this.setFloat("grlDashRatio",h)}get dashCount(){return this._dashCount}set dashCount(h){this._dashCount=h,this._dashArray=1/h,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(h){this._sizeAttenuation=h,this.setFloat("grlSizeAttenuation",Lh.BooleanToNumber(h))}get color(){return this._color}set color(h){this.setColor(h)}setColor(h){h=h??vh.DEFAULT_COLOR,this._color=h,this.setColor3("grlColor",h)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(h){this._colorsDistributionType=h,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(h){this._colorMode=h,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(h){this._resolution=h,this.setVector2("grlResolution",h),this.setFloat("grlAspect",h.x/h.y)}serialize(){const h=super.serialize(),R={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(R.nh=this._colors),h.greasedLineMaterialOptions=R,h}parse(h,R,l){var j;const a=h.greasedLineMaterialOptions;null===(j=this._colorsTexture)||void 0===j||j.dispose(),a.color&&(this.color=a.color),a.colorDistributionType&&(this.colorsDistributionType=a.colorDistributionType),a.colorsSampling&&(this.colorsSampling=a.colorsSampling),a.colorMode&&(this.colorMode=a.colorMode),a.useColors&&(this.useColors=a.useColors),a.visibility&&(this.visibility=a.visibility),a.useDash&&(this.useDash=a.useDash),a.dashCount&&(this.dashCount=a.dashCount),a.dashRatio&&(this.dashRatio=a.dashRatio),a.dashOffset&&(this.dashOffset=a.dashOffset),a.width&&(this.width=a.width),a.sizeAttenuation&&(this.sizeAttenuation=a.sizeAttenuation),a.resolution&&(this.resolution=a.resolution),a.nh?this.colorsTexture=Lh.CreateColorsTexture(`${this.name}-colors-texture`,a.nh,this.colorsSampling,this.yh()):this.colorsTexture=Lh.PrepareEmptyColorsTexture(R),this._cameraFacing=a.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var gh,Hh,kh;Wh.ForceGLSL=!1,function(h){h[h.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",h[h.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(gh||(gh={})),function(h){h[h.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",h[h.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",h[h.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Hh||(Hh={})),function(h){h[h.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",h[h.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",h[h.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",h[h.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",h[h.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(kh||(kh={}));class Ch extends fh.b{constructor(h,R,l){super(h,R,null,null,!1,!1),this.name=h,this._options=l,this._lazy=!1,this._updatable=!1,this._engine=R.getEngine(),this._lazy=l.lazy??!1,this._updatable=l.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=l.colorPointers??[],this._widths=l.widths??new Array(l.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(h){let R=0;for(const j of this._points)R+=j.length;const l=R/3*2-this._widths.length;for(let j=0;j<l;j++)this._widths.push(h)}updateLazy(){var h,R;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(h=this._options.ribbonOptions)||void 0===h?void 0:h.smoothShading),!this.oh&&this.refreshBoundingInfo(),null===(R=this.greasedLineMaterial)||void 0===R||R.updateLazy()}addPoints(h,R){for(const l of h)this._points.push(l);this._lazy||this.setPoints(this._points,R)}dispose(h){let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(h,R)}isLazy(){return this._lazy}get rh(){return this._uvs}set rh(h){this._uvs=h instanceof Float32Array?h:new Float32Array(h),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(h){this.material instanceof Wh&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===h||void 0===h?void 0:h.length)>0),this._offsets=h,this._offsetsBuffer?this._offsetsBuffer.update(h):this._createOffsetsBuffer(h)}get widths(){return this._widths}set widths(h){this._widths=h,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(h)}get colorPointers(){return this._colorPointers}set colorPointers(h){this._colorPointers=h,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(h)}get greasedLineMaterial(){var h,R;if(this.material&&this.material instanceof Wh)return this.material;const l=null===(h=this.material)||void 0===h||null===(R=h.pluginManager)||void 0===R?void 0:R.getPlugin(rh.GREASED_LINE_MATERIAL_NAME);return l||void 0}get points(){const h=[];return zh.e.DeepCopy(this._points,h),h}setPoints(h,R){this._points=Lh.ConvertPoints(h,(null===R||void 0===R?void 0:R.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==R&&void 0!==R&&R.colorPointers||this._updateColorPointers(),this._setPoints(this._points,R)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,rh:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(h){super.serialize(h),h.type=this.getClassName(),h.lineOptions=this._createLineOptions()}_createVertexBuffers(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const R=new Ph.b;return R.Ih=this._vertexPositions,R.indices=this._indices,R.rh=this._uvs,h&&(R.Lh=[],Ph.b.ComputeNormals(this._vertexPositions,this._indices,R.Lh)),R.zh(this,this._options.updatable),R}_createOffsetsBuffer(h){const R=this._scene.getEngine(),l=new u.e(R,h,this._updatable,3);this.setVerticesBuffer(l.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=l}}class Ah{constructor(h,R){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=h,this.wasAddedByNoopNode=R}getIndicesAccessor(h,R,l,j,a){var D,U,F,w;return null===(D=this._indicesAccessorMap.get(h))||void 0===D||null===(U=D.get(R))||void 0===U||null===(F=U.get(l))||void 0===F||null===(w=F.get(j))||void 0===w?void 0:w.get(a)}setIndicesAccessor(h,R,l,j,a,D){let U=this._indicesAccessorMap.get(h);U||(U=new Map,this._indicesAccessorMap.set(h,U));let F=U.get(R);F||(F=new Map,U.set(R,F));let w=F.get(l);w||(w=new Map,F.set(l,w));let mh=w.get(j);mh||(mh=new Map,w.set(j,mh)),mh.set(a,D)}pushExportedNode(h){this._exportedNodes.has(h)||this._exportedNodes.add(h)}getNodesSet(){return this._exportedNodes}getVertexBufferView(h){return this._vertexBufferViewMap.get(h)}setVertexBufferView(h,R){this._vertexBufferViewMap.set(h,R)}setRemappedBufferView(h,R,l){this._remappedBufferView.set(h,new Map),this._remappedBufferView.get(h).set(R,l)}getRemappedBufferView(h,R){var l;return null===(l=this._remappedBufferView.get(h))||void 0===l?void 0:l.get(R)}getVertexAccessor(h,R,l){var j,a;return null===(j=this._vertexAccessorMap.get(h))||void 0===j||null===(a=j.get(R))||void 0===a?void 0:a.get(l)}setVertexAccessor(h,R,l,j){let a=this._vertexAccessorMap.get(h);a||(a=new Map,this._vertexAccessorMap.set(h,a));let D=a.get(R);D||(D=new Map,a.set(R,D)),D.set(l,j)}hasVertexColorAlpha(h){return this._vertexMapColorAlpha.get(h)||!1}setHasVertexColorAlpha(h,R){return this._vertexMapColorAlpha.set(h,R)}getMesh(h){return this._meshMap.get(h)}setMesh(h,R){this._meshMap.set(h,R)}bindMorphDataToMesh(h,R){const l=this._meshMorphTargetMap.get(h)||[];this._meshMorphTargetMap.set(h,l),-1===l.indexOf(R)&&l.push(R)}getMorphTargetsFromMesh(h){return this._meshMorphTargetMap.get(h)}}class eh{_ApplyExtension(h,R,l,j){if(l>=R.length)return Promise.resolve(h);const a=j(R[l],h);return a?a.then((async h=>h?await this._ApplyExtension(h,R,l+1,j):null)):this._ApplyExtension(h,R,l+1,j)}_ApplyExtensions(h,R){const l=[];for(const j of eh._ExtensionNames)l.push(this._extensions[j]);return this._ApplyExtension(h,l,0,R)}_extensionsPreExportTextureAsync(h,R,l){return this._ApplyExtensions(R,((R,j)=>R.preExportTextureAsync&&R.preExportTextureAsync(h,j,l)))}_extensionsPostExportNodeAsync(h,R,l,j,a){return this._ApplyExtensions(R,((R,D)=>R.postExportNodeAsync&&R.postExportNodeAsync(h,D,l,j,a,this._bufferManager)))}_extensionsPostExportMaterialAsync(h,R,l){return this._ApplyExtensions(R,((R,j)=>R.postExportMaterialAsync&&R.postExportMaterialAsync(h,j,l)))}_extensionsPostExportMaterialAdditionalTextures(h,R,l){const j=[];for(const a of eh._ExtensionNames){const D=this._extensions[a];D.postExportMaterialAdditionalTextures&&j.push(...D.postExportMaterialAdditionalTextures(h,R,l))}return j}_extensionsPostExportTextures(h,R,l){for(const j of eh._ExtensionNames){const a=this._extensions[j];a.postExportTexture&&a.postExportTexture(h,R,l)}}_extensionsPostExportMeshPrimitive(h){for(const R of eh._ExtensionNames){const l=this._extensions[R];l.postExportMeshPrimitive&&l.postExportMeshPrimitive(h,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const h of eh._ExtensionNames){const R=this._extensions[h];R.preGenerateBinaryAsync&&await R.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(h){for(const R of eh._ExtensionNames){const l=this._extensions[R];l.enabled&&h(l)}}_extensionsOnExporting(){this._forEachExtensions((h=>{var R,l,j;h.wasUsed&&((R=this._glTF).extensionsUsed||(R.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(h.name)&&this._glTF.extensionsUsed.push(h.name),h.required&&((l=this._glTF).extensionsRequired||(l.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(h.name)&&this._glTF.extensionsRequired.push(h.name)),(j=this._glTF).extensions||(j.extensions={}),h.onExporting&&h.onExporting())}))}_loadExtensions(){for(const h of eh._ExtensionNames){const R=eh._ExtensionFactories[h](this);this._extensions[h]=R}}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Y.b.LastCreatedScene,R=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${Q.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new K(this),this._extensions={},this._bufferManager=new uh,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!h)throw new Error("No scene available to export");this._babylonScene=h,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:h=>{var R;return null===h||void 0===h||null===(R=h.qF)||void 0===R?void 0:R.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...R},this._loadExtensions()}dispose(){for(const h in this._extensions){this._extensions[h].dispose()}}get options(){return this._options}static RegisterExtension(h,R){eh.UnregisterExtension(h)&&a.Tools.Warn(`Extension with the name ${h} already exists`),eh._ExtensionFactories[h]=R,eh._ExtensionNames.push(h)}static UnregisterExtension(h){if(!eh._ExtensionFactories[h])return!1;delete eh._ExtensionFactories[h];const R=eh._ExtensionNames.indexOf(h);return-1!==R&&eh._ExtensionNames.splice(R,1),!0}_generateJSON(h,R,l){const j={byteLength:h};return j.byteLength&&(this._glTF.buffers=[j]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.TR=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(j.uri=R+".bin"),l?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(h){const R=await this._generateBinaryAsync();this._extensionsOnExporting();const l=this._generateJSON(R.byteLength,h,!0),j=new Blob([R],{type:"application/octet-stream"}),a=h+".gltf",D=h+".bin",U=new mh;if(U.files[a]=l,U.files[D]=j,this._imageData)for(const F in this._imageData)U.files[F]=new Blob([this._imageData[F].data],{type:this._imageData[F].mimeType});return U}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(h){const R=h%4;return 0===R?R:4-R}async generateGLBAsync(h){this._shouldUseGlb=!0;const R=await this._generateBinaryAsync();this._extensionsOnExporting();const l=this._generateJSON(R.byteLength),j=h+".glb";let a,D=l.length;if("undefined"!==typeof TextEncoder){a=(new TextEncoder).encode(l),D=a.length}const U=this._getPadding(D),F=this._getPadding(R.byteLength),w=28+D+U+R.byteLength+F,u=new wh(w);if(u.writeUInt32(1179937895),u.writeUInt32(2),u.writeUInt32(w),u.writeUInt32(D+U),u.writeUInt32(1313821514),a)u.writeTypedArray(a);else{const h="_".charCodeAt(0);for(let R=0;R<D;++R){const j=l.charCodeAt(R);j!=l.codePointAt(R)?u.writeUInt8(h):u.writeUInt8(j)}}for(let mh=0;mh<U;++mh)u.writeUInt8(32);u.writeUInt32(R.byteLength+F),u.writeUInt32(5130562),u.writeTypedArray(R);for(let mh=0;mh<F;++mh)u.writeUInt8(0);const c=new mh;return c.files[j]=new Blob([u.getOutputData()],{type:"application/octet-stream"}),c}_setNodeTransformation(h,R,l){if(R.getPivotPoint().equalsWithEpsilon(C,k.d)||a.Tools.Warn("Pivot points are not supported in the glTF serializer"),!R.position.equalsWithEpsilon(C,k.d)){const a=j.TmpVectors.tR[0].D(R.position);l&&V(a),h.translation=a.sF()}R.yF.equalsWithEpsilon(e,k.d)||(h.scale=R.yF.sF());const D=R.rotationQuaternion||j.Quaternion.FromEulerAngles(R.rotation.x,R.rotation.y,R.rotation.z);D.equalsWithEpsilon(A,k.d)||(l&&B(D),h.rotation=D.normalize().sF())}_setCameraTransformation(h,R,l){if(!R.position.equalsWithEpsilon(C,k.d)){const a=j.TmpVectors.tR[0].D(R.position);l&&V(a),h.translation=a.sF()}const a=R.rotationQuaternion||j.Quaternion.FromEulerAngles(R.rotation.x,R.rotation.y,R.rotation.z);l&&B(a),this._babylonScene.useRightHandedSystem||N(a),a.equalsWithEpsilon(A,k.d)||(h.rotation=a.sF())}_listAvailableCameras(){for(const h of this._babylonScene.cameras){const R={type:h.mode===Jh.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(h.name&&(R.name=h.name),"perspective"===R.type)R.perspective={aspectRatio:h.getEngine().getAspectRatio(h),yfov:h.fovMode===Jh.e.FOVMODE_VERTICAL_FIXED?h.fov:h.fov*h.getEngine().getAspectRatio(h),znear:h.fF,zfar:h.maxZ};else if("orthographic"===R.type){const l=h.orthoLeft&&h.orthoRight?.5*(h.orthoRight-h.orthoLeft):.5*h.getEngine().getRenderWidth(),j=h.orthoBottom&&h.orthoTop?.5*(h.orthoTop-h.orthoBottom):.5*h.getEngine().getRenderHeight();R.orthographic={xmag:l,ymag:j,znear:h.fF,zfar:h.maxZ}}this._camerasMap.set(h,R)}}_exportAndAssignCameras(){const h=Array.from(this._camerasMap.values());for(const R of h){const h=this._nodesCameraMap.get(R);if(void 0!==h){this._cameras.push(R);for(const R of h)R.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const h of this._babylonScene.skeletons){if(h.bones.length<=0)continue;const R={joints:[]};this._skinMap.set(h,R)}}_exportAndAssignSkeletons(){for(const h of this._babylonScene.skeletons){if(h.bones.length<=0)continue;const R=this._skinMap.get(h);if(void 0==R)continue;const l={},j=[];let D=-1;for(let a=0;a<h.bones.length;++a){const R=h.bones[a],j=R.getIndex()??a;-1!==j&&(l[j]=R,j>D&&(D=j))}for(let h=0;h<=D;++h){const D=l[h];j.push(D.getAbsoluteInverseBindMatrix());const U=D.getTransformNode();if(null!==U){const h=this._nodeMap.get(U);U&&null!==h&&void 0!==h?R.joints.push(h):a.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else a.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const U=this._nodesSkinMap.get(R);if(R.joints.length>0&&void 0!==U){const h=64*j.length,l=new Float32Array(h/4);j.forEach(((h,R)=>{l.set(h.m,16*R)}));const a=this._bufferManager.createBufferView(l);this._accessors.push(this._bufferManager.createAccessor(a,"MAT4",5126,j.length)),R.inverseBindMatrices=this._accessors.length-1,this._skins.push(R);for(const R of U)R.skin=this._skins.length-1}}}async _exportSceneAsync(){const h={nodes:[]};if(this._babylonScene.metadata){const R=this._options.metadataSelector(this._babylonScene.metadata);R&&(h.extras=R)}const R=new Array,l=new Array,j=new Array;for(const F of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Uh(F,this._babylonScene.useRightHandedSystem)?j.push(...F.getChildren()):this._babylonScene.useRightHandedSystem?R.push(F):l.push(F);this._listAvailableCameras(),this._listAvailableSkeletons();const a=new Ah(!0,!1);h.nodes.push(...await this._exportNodesAsync(l,a));const D=new Ah(!1,!1);h.nodes.push(...await this._exportNodesAsync(R,D));const U=new Ah(!1,!0);h.nodes.push(...await this._exportNodesAsync(j,U)),h.nodes.length&&this._scenes.push(h),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Eh._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,a.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(h){let R=this._shouldExportNodeMap.get(h);return void 0===R&&(R=this._options.shouldExportNode(h),this._shouldExportNodeMap.set(h,R)),R}async _exportNodesAsync(h,R){const l=new Array;this._exportBuffers(h,R);for(const j of h)await this._exportNodeAsync(j,l,R);return l}_collectBuffers(h,R,l,j,a){if(this._shouldExportNode(h)&&h instanceof J.c&&h.xF){const D=h.xF.getVertexBuffers();if(D)for(const j in D){if(!i(j))continue;const U=D[j];a.setHasVertexColorAlpha(U,h.hasVertexAlpha);const F=U._buffer,w=R.get(F)||[];R.set(F,w),-1===w.indexOf(U)&&w.push(U);const mh=l.get(U)||[];l.set(U,mh),-1===mh.indexOf(h)&&mh.push(h)}const U=h.morphTargetManager;if(U)for(let R=0;R<U.numTargets;R++){const l=U.getTarget(R),a=j.get(l)||[];j.set(l,a),-1===a.indexOf(h)&&a.push(h)}}for(const D of h.getChildren())this._collectBuffers(D,R,l,j,a)}_exportBuffers(h,R){const l=new Map,j=new Map,a=new Map;for(const F of h)this._collectBuffers(F,l,j,a,R);const D=Array.from(l.keys());for(const F of D){const h=F.getData();if(!h)throw new Error("Buffer data is not available");const a=l.get(F);if(!a)continue;const D=a[0].byteStride;if(a.some((h=>h.byteStride!==D)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const U=lh(h).slice();for(const R of a){const h=j.get(R),{byteOffset:l,byteStride:a,componentCount:D,type:F,count:w,normalized:mh,kind:c}=Z(R,h);switch(c){case u.g.NormalKind:case u.g.TangentKind:(0,W.i)(U,l,a,D,F,w,mh,(h=>{const R=Math.sqrt(h[0]*h[0]+h[1]*h[1]+h[2]*h[2]);if(R>0){const l=1/R;h[0]*=l,h[1]*=l,h[2]*=l}}));break;case u.g.ColorKind:{const R=h.filter((h=>h.material instanceof Yh.ER||null==h.material)).length;if(0==R)break;if(R!=h.length){g.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}F==u.g.UNSIGNED_BYTE&&g.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const j=new s.xR,c=new s.bF,J=this._babylonScene.getEngine().useExactSrgbConversions;(0,W.i)(U,l,a,D,F,w,mh,(h=>{3===h.length?(j.Yl(h,0),j.toLinearSpaceToRef(j,J),j.toArray(h,0)):(c.Yl(h,0),c.toLinearSpaceToRef(c,J),c.toArray(h,0))}))}}}if(R.convertToRightHanded){for(const h of a){const R=j.get(h),{byteOffset:l,byteStride:a,componentCount:D,type:F,count:w,normalized:mh,kind:c}=Z(h,R);switch(c){case u.g.PositionKind:case u.g.NormalKind:case u.g.TangentKind:(0,W.i)(U,l,a,D,F,w,mh,(h=>{h[0]=-h[0]}))}}R.convertedToRightHandedBuffers.set(F,U)}const w=this._bufferManager.createBufferView(U,D);R.setVertexBufferView(F,w);const mh=new Map;for(const R of a){const h=j.get(R),{kind:l,totalVertices:a}=Z(R,h);switch(l){case u.g.MatricesIndicesKind:case u.g.MatricesIndicesExtraKind:if(R.type==u.g.FLOAT){const h=R.getFloatData(a);null!==h&&mh.set(R,h)}}}0!==mh.size&&g.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const c=Array.from(mh.keys());for(const l of c){const h=mh.get(l);if(!h)continue;const j=h.some((h=>h>=256)),a=new(j?Uint16Array:Uint8Array)(h.length);for(let R=0;R<h.length;R++)a[R]=h[R];const D=this._bufferManager.createBufferView(a,4*(j?2:1));R.setRemappedBufferView(F,l,D)}}const U=Array.from(a.keys());for(const F of U){const h=a.get(F);if(!h)continue;const l=xh(F,h[0],this._bufferManager,this._bufferViews,this._accessors,R.convertToRightHanded);for(const j of h)R.bindMorphDataToMesh(j,l)}}async _exportNodeAsync(h,R,l){let j=this._nodeMap.get(h);if(void 0!==j)return void(R.includes(j)||R.push(j));const a=await this._createNodeAsync(h,l);if(a){j=this._nodes.length,this._nodes.push(a),this._nodeMap.set(h,j),l.pushExportedNode(h),R.push(j);const D={name:"runtime animations",channels:[],samplers:[]},U=[];this._babylonScene.animationGroups.length||(Eh._CreateMorphTargetAnimationFromMorphTargetAnimations(h,D,U,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,l.convertToRightHanded,this._options.shouldExportAnimation),h.animations.length&&Eh._CreateNodeAnimationFromNodeAnimations(h,D,U,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,l.convertToRightHanded,this._options.shouldExportAnimation)),D.channels.length&&D.samplers.length&&this._animations.push(D),U.forEach((h=>{h.channels.length&&h.samplers.length&&this._animations.push(h)}))}const D=a?[]:R;for(const U of h.getChildren())await this._exportNodeAsync(U,D,l);a&&D.length&&(a.children=D)}async _createNodeAsync(h,R){if(!this._shouldExportNode(h))return null;const l={};if(h.name&&(l.name=h.name),h.metadata){const R=this._options.metadataSelector(h.metadata);R&&(l.extras=R)}if(h instanceof c.d&&(this._setNodeTransformation(l,h,R.convertToRightHanded),h instanceof J.c)){const a=h instanceof q.e?h.sourceMesh:h;if(a.YF&&a.YF.length>0&&(l.mesh=await this._exportMeshAsync(a,R)),h.skeleton){const R=this._skinMap.get(h.skeleton);var j;if(void 0!==R)void 0===this._nodesSkinMap.get(R)&&this._nodesSkinMap.set(R,[]),null===(j=this._nodesSkinMap.get(R))||void 0===j||j.push(l)}}if(h instanceof H.c){const j=this._camerasMap.get(h);if(j){var a;void 0===this._nodesCameraMap.get(j)&&this._nodesCameraMap.set(j,[]),this._setCameraTransformation(l,h,R.convertToRightHanded);const U=h.parent;if(null!==U&&Rh(h,U)){const h=this._nodeMap.get(U);if(void 0!==h){var D;const R=this._nodes[h];return hh(l,R),null===(D=this._nodesCameraMap.get(j))||void 0===D||D.push(R),null}}null===(a=this._nodesCameraMap.get(j))||void 0===a||a.push(l)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",l,h,this._nodeMap,R.convertToRightHanded)?l:(g.c.Warn(`Not exporting node ${h.name}`),null)}_exportIndices(h,R,l,j,a,U,F,w,mh){let u=h;mh.mode=d(U);const c=F!==D.e.CounterClockWiseSideOrientation,J=!w.wasAddedByNoopNode&&c,q=function(h){switch(h){case D.e.TriangleFillMode:case D.e.TriangleStripDrawMode:case D.e.TriangleFanDrawMode:return!0}return!1}(U)&&J;if(q){if(U===D.e.TriangleStripDrawMode||U===D.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");mh.mode=d(U);const F=R?new Uint32Array(j):new Uint16Array(j);if(h)for(let R=0;R+2<j;R+=3)F[R]=h[l+R]+a,F[R+1]=h[l+R+2]+a,F[R+2]=h[l+R+1]+a;else for(let h=0;h+2<j;h+=3)F[h]=h,F[h+1]=h+2,F[h+2]=h+1;u=F}else if(h&&0!==a){const D=R?new Uint32Array(j):new Uint16Array(j);for(let R=0;R<j;R++)D[R]=h[l+R]+a;u=D}if(u){let D=w.getIndicesAccessor(h,l,j,a,q);if(void 0===D){const U=function(h,R,l,j){if(h instanceof Uint16Array||h instanceof Uint32Array)return h;if(h instanceof Int32Array)return new Uint32Array(h.buffer,h.byteOffset,h.length);const a=h.slice(R,R+l);return j?new Uint32Array(a):new Uint16Array(a)}(u,0,j,R),F=this._bufferManager.createBufferView(U),mh=R?5125:5123;this._accessors.push(this._bufferManager.createAccessor(F,"SCALAR",mh,j,0)),D=this._accessors.length-1,w.setIndicesAccessor(h,l,j,a,q,D)}mh.indices=D}}_exportVertexBuffer(h,R,l,j,a,D){const U=h.getKind();if(!i(U))return;if(U.startsWith("uv")&&!this._options.exportUnusedUVs&&(!R||!this._materialNeedsUVsSet.has(R)))return;let F=a.getVertexAccessor(h,l,j);if(void 0===F){const R=a.convertedToRightHandedBuffers.get(h._buffer)||h._buffer.getData(),D=U===u.g.PositionKind?function(h,R,l,j){const{byteOffset:a,byteStride:D,type:U,normalized:F}=R,w=R.getSize(),mh=new Array(w).fill(1/0),u=new Array(w).fill(-1/0);return(0,W.i)(h,a+l*D,D,w,U,j*w,F,(h=>{for(let R=0;R<w;R++)mh[R]=Math.min(mh[R],h[R]),u[R]=Math.max(u[R],h[R])})),{min:mh,max:u}}(R,h,l,j):void 0,w=(U===u.g.MatricesIndicesKind||U===u.g.MatricesIndicesExtraKind)&&h.type===u.g.FLOAT,mh=w?u.g.UNSIGNED_BYTE:h.type,c=w?void 0:h.normalized,J=w?a.getRemappedBufferView(h._buffer,h):a.getVertexBufferView(h._buffer),q=h.byteOffset+l*h.byteStride;this._accessors.push(this._bufferManager.createAccessor(J,function(h,R){if(h==u.g.ColorKind)return R?"VEC4":"VEC3";switch(h){case u.g.PositionKind:case u.g.NormalKind:return"VEC3";case u.g.TangentKind:case u.g.MatricesIndicesKind:case u.g.MatricesIndicesExtraKind:case u.g.MatricesWeightsKind:case u.g.MatricesWeightsExtraKind:return"VEC4";case u.g.UVKind:case u.g.UV2Kind:case u.g.UV3Kind:case u.g.UV4Kind:case u.g.UV5Kind:case u.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${h}`)}(U,a.hasVertexColorAlpha(h)),mh,j,q,D,c)),F=this._accessors.length-1,a.setVertexAccessor(h,l,j,F)}D.attributes[function(h){switch(h){case u.g.PositionKind:return"POSITION";case u.g.NormalKind:return"NORMAL";case u.g.TangentKind:return"TANGENT";case u.g.ColorKind:return"COLOR_0";case u.g.UVKind:return"TEXCOORD_0";case u.g.UV2Kind:return"TEXCOORD_1";case u.g.UV3Kind:return"TEXCOORD_2";case u.g.UV4Kind:return"TEXCOORD_3";case u.g.UV5Kind:return"TEXCOORD_4";case u.g.UV6Kind:return"TEXCOORD_5";case u.g.MatricesIndicesKind:return"JOINTS_0";case u.g.MatricesIndicesExtraKind:return"JOINTS_1";case u.g.MatricesWeightsKind:return"WEIGHTS_0";case u.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${h}`)}(U)]=F}async _exportMaterialAsync(h,R,l,j){let a=this._materialMap.get(h);if(void 0===a){const j=R&&Object.keys(R).some((h=>h.startsWith("uv")));if((h=h instanceof qh.e?h.IF[l.materialIndex]:h)instanceof Qh.b)a=await this._materialExporter.exportPBRMaterialAsync(h,"image/png",j);else{if(!(h instanceof Yh.ER))return void g.c.Warn(`Unsupported material '${h.name}' with type ${h.getClassName()}`);a=await this._materialExporter.exportStandardMaterialAsync(h,"image/png",j)}this._materialMap.set(h,a)}j.material=a}async _exportMeshAsync(h,R){var l;let j=R.getMesh(h);if(void 0!==j)return j;const a={primitives:[]};j=this._meshes.length,this._meshes.push(a),R.setMesh(h,j);const U=h.isUnIndexed?null:h.GF(),F=null===(l=h.xF)||void 0===l?void 0:l.getVertexBuffers(),w=R.getMorphTargetsFromMesh(h),mh=h instanceof Gh.c,u=h instanceof Ch,c=h.YF;if(F&&c&&c.length>0)for(const Q of c){const l={attributes:{}},j=Q.Hh()||this._babylonScene.defaultMaterial;if(u){var J,q;const R={name:j.name},a=h,D=s.xR.White(),U=(null===(J=a.material)||void 0===J?void 0:J.alpha)??1,F=(null===(q=a.greasedLineMaterial)||void 0===q?void 0:q.color)??D;(!F.equalsWithEpsilon(D,k.d)||U<1)&&(R.pbrMetallicRoughness={baseColorFactor:[...F.sF(),U]}),this._materials.push(R),l.material=this._materials.length-1}else if(mh){const R={name:j.name},a=h;(!a.color.equalsWithEpsilon(s.xR.White(),k.d)||a.alpha<1)&&(R.pbrMetallicRoughness={baseColorFactor:[...a.color.sF(),a.alpha]}),this._materials.push(R),l.material=this._materials.length-1}else await this._exportMaterialAsync(j,F,Q,l);const c=mh||u?D.e.LineListDrawMode:h.overrideRenderingFillMode??j.fillMode,Y=j._getEffectiveOrientation(h);this._exportIndices(U,U?(0,W.d)(U,Q.indexCount,Q.indexStart,Q.verticesStart):Q.verticesCount>65535,U?Q.indexStart:Q.verticesStart,U?Q.indexCount:Q.verticesCount,-Q.verticesStart,c,Y,R,l);for(const h of Object.values(F))this._exportVertexBuffer(h,j,Q.verticesStart,Q.verticesCount,R,l);if(w){l.targets=[];for(const h of w)l.targets.push(h.attributes)}a.primitives.push(l),this._extensionsPostExportMeshPrimitive(l)}if(w){a.weights=[],a.extras||(a.extras={}),a.extras.targetNames=[];for(const h of w)a.weights.push(h.influence),a.extras.targetNames.push(h.name)}return j}}eh._ExtensionNames=new Array,eh._ExtensionFactories={};class Sh{static async GLTFAsync(h,R,l){l&&l.exportWithoutWaitingForScene||await h.whenReadyAsync();const j=new eh(h,l),a=await j.generateGLTFAsync(R.replace(/\.[^/.]+$/,""));return j.dispose(),a}static async GLBAsync(h,R,l){l&&l.exportWithoutWaitingForScene||await h.whenReadyAsync();const j=new eh(h,l),a=await j.generateGLBAsync(R.replace(/\.[^/.]+$/,""));return j.dispose(),a}}l(13430);const Zh="EXT_mesh_gpu_instancing";class Mh{constructor(h){this.name=Zh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(h,R,l,a,D,U){return await new Promise((h=>{if(R&&l instanceof fh.b&&l.hasThinInstances&&this._exporter){this._wasUsed=!0;const h=j.tR.Zero(),a=j.Quaternion.Identity(),F=j.tR.One(),w=l.thinInstanceGetWorldMatrices(),mh=j.TmpVectors.tR[2],u=j.TmpVectors.Quaternion[1],c=j.TmpVectors.tR[3];let J=!1,q=!1,Q=!1;const Y=new Float32Array(3*l.LF),s=new Float32Array(4*l.LF),t=new Float32Array(3*l.LF);let f=0;for(const R of w)R.decompose(c,u,mh),D&&(V(mh),B(u)),Y.set(mh.sF(),3*f),s.set(u.normalize().sF(),4*f),t.set(c.sF(),3*f),J=J||!mh.equalsWithEpsilon(h),q=q||!u.equalsWithEpsilon(a),Q=Q||!c.equalsWithEpsilon(F),f++;const T={attributes:{}};J&&(T.attributes.TRANSLATION=this._buildAccessor(Y,"VEC3",l.LF,U)),q&&(T.attributes.ROTATION=this._buildAccessor(s,"VEC4",l.LF,U)),Q&&(T.attributes.SCALE=this._buildAccessor(t,"VEC3",l.LF,U)),R.extensions=R.extensions||{},R.extensions[Zh]=T}h(R)}))}_buildAccessor(h,R,l,j){const a=j.createBufferView(h),D=j.createAccessor(a,R,5126,l);return this._exporter._accessors.push(D),this._exporter._accessors.length-1}}eh.RegisterExtension(Zh,(h=>new Mh(h)));var ih=l(13436),dh=l(13446),Xh=l(13455),Vh=l(13460);function Bh(h){return h===Xh.c.PositionKind?"POSITION":h===Xh.c.NormalKind?"NORMAL":h===Xh.c.ColorKind?"COLOR":h.startsWith(Xh.c.UVKind)?"TEX_COORD":"GENERIC"}const Nh={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class hR extends ih.d{static get DefaultAvailable(){return(0,ih.l)(hR.DefaultConfiguration)}static get Default(){return hR._Default??(hR._Default=new hR),hR._Default}static ResetDefault(h){hR._Default&&(h||hR._Default.dispose(),hR._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(h,R){return{module:await(R||DracoEncoderModule)({wasmBinary:h})}}_getWorkerContent(){return`${dh.g}(${dh.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:hR.DefaultConfiguration)}async _encodeAsync(h,R,l){const j=l?(0,Vh.e)(Nh,l):Nh;if(this._workerPoolPromise){const l=await this._workerPoolPromise;return await new Promise(((a,D)=>{l.push(((l,U)=>{const F=h=>{l.removeEventListener("error",F),l.removeEventListener("message",w),D(h),U()},w=h=>{"encodeMeshDone"===h.data.id&&(l.removeEventListener("error",F),l.removeEventListener("message",w),a(h.data.encodedMeshData),U())};l.addEventListener("error",F),l.addEventListener("message",w);const mh=[];for(const R of h)mh.push(R.data.buffer);R&&mh.push(R.buffer),l.postMessage({id:"encodeMesh",attributes:h,indices:R,options:j},mh)}))}))}if(this._modulePromise){const l=await this._modulePromise;return(0,dh.g)(l.module,h,R,j)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(h,R){if(0==h.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");h instanceof fh.b&&h.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===R||void 0===R?void 0:R.method)&&(g.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),R.method="MESH_SEQUENTIAL_ENCODING");const l=function(h){let R=h.GF(void 0,!0);return!R||R instanceof Uint32Array||R instanceof Uint16Array||(R=((0,W.d)(R,R.length)?Uint32Array:Uint16Array).from(R)),R}(h),j=function(h,R){const l=[];for(const j of h.getVerticesDataKinds()){if(null!==R&&void 0!==R&&R.includes(j)){if(j===Xh.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const a=h.getVertexBuffer(j),D=a.getSize(),U=(0,W.r)(a.getData(),D,a.type,a.byteOffset,a.byteStride,a.normalized,h.getTotalVertices(),!0);l.push({kind:j,dracoName:Bh(j),size:D,data:U})}return l}(h,null===R||void 0===R?void 0:R.excludedAttributes);return await this._encodeAsync(j,l,R)}}hR.DefaultConfiguration={wasmUrl:`${a.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${a.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${a.Tools._DefaultCdnUrl}/draco_encoder.js`},hR._Default=null;const RR="KHR_draco_mesh_compression";class lR{get wasUsed(){return this._wasUsed}constructor(h){this.name=RR,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===h.options.meshCompressionMethod&&hR.DefaultAvailable}dispose(){}postExportMeshPrimitive(h,R,l){if(!this.enabled)return;if(4!==h.mode&&5!==h.mode)return void g.c.Warn("Cannot compress primitive with mode "+h.mode+".");const j=[],a=[];let D=null;if(void 0!==h.indices){const U=l[h.indices],F=R.getBufferView(U);D=R.getData(F).slice(),j.push(F),a.push(U)}const U=[];for(const[u,c]of Object.entries(h.attributes)){const h=l[c],D=R.getBufferView(h),w=M(h.type),mh=(0,W.r)(R.getData(D),w,h.componentType,h.byteOffset||0,D.byteStride||(0,W.m)(h.componentType)*w,h.normalized||!1,h.count,!0);U.push({kind:u,dracoName:(F=u,"POSITION"===F?"POSITION":"NORMAL"===F?"NORMAL":F.startsWith("COLOR")?"COLOR":F.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:M(h.type),data:mh}),j.push(D),a.push(h)}var F;const w={method:h.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},mh=hR.Default._encodeAsync(U,D,w).then((l=>{if(!l)return void g.c.Error("Draco encoding failed for primitive.");const D={bufferView:-1,attributes:l.attributeIds},U=R.createBufferView(l.data);R.setBufferView(D,U);for(const h of j)this._bufferViewsUsed.add(h);for(const h of a)this._accessorsUsed.add(h);h.extensions||(h.extensions={}),h.extensions[RR]=D})).catch((h=>{g.c.Error("Draco encoding failed for primitive: "+h)}));this._encodePromises.push(mh),this._wasUsed=!0}async preGenerateBinaryAsync(h){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((R=>{h.getPropertiesWithBufferView(R).every((h=>this._accessorsUsed.has(h)))&&h.removeBufferView(R)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}eh.RegisterExtension(RR,(h=>new lR(h)));var jR=l(13463);const aR="KHR_lights_punctual",DR={name:"",color:[1,1,1],nF:1,range:Number.MAX_VALUE},UR={innerConeAngle:0,outerConeAngle:Math.PI/4},FR=j.tR.Backward();class wR{constructor(h){this.name=aR,this.enabled=!0,this.required=!1,this._exporter=h}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[aR]=this._lights}async postExportNodeAsync(h,R,l,a,D){return await new Promise((U=>{if(!(l instanceof Th.e))return void U(R);const F=l.getTypeID()==Th.e.LIGHTTYPEID_POINTLIGHT?"point":l.getTypeID()==Th.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":l.getTypeID()==Th.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!F||!(l instanceof jR.b))return g.c.Warn(`${h}: Light ${l.name} is not supported in ${aR}`),void U(R);if(l.falloffType!==Th.e.FALLOFF_GLTF&&g.c.Warn(`${h}: Light falloff for ${l.name} does not match the ${aR} specification!`),!l.position.equalsToFloats(0,0,0)){const h=j.TmpVectors.tR[0].D(l.position);D&&V(h),R.translation=h.sF()}if("point"!==F){const h=l.direction.normalizeToRef(j.TmpVectors.tR[0]);D&&V(h);const a=j.Quaternion.FromUnitVectorsToRef(FR,h,j.TmpVectors.Quaternion[0]);j.Quaternion.IsIdentity(a)||(R.rotation=a.sF())}const w={type:F,name:l.name,color:l.rF.sF(),nF:l.nF,range:l.range};if(jh(w,DR),"spot"===F){const h=l;w.spot={innerConeAngle:h.innerAngle/2,outerConeAngle:h.angle/2},jh(w.spot,UR)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(w);const mh={aF:this._lights.lights.length-1},u=l.parent;if(u&&Rh(l,u)){const h=a.get(u);if(h){const l=this._exporter._nodes[h];return hh(R,l),l.extensions||(l.extensions={}),l.extensions[aR]=mh,void U(null)}}R.extensions||(R.extensions={}),R.extensions[aR]=mh,U(R)}))}}eh.RegisterExtension(aR,(h=>new wR(h)));var ml=l(13380);const uR="KHR_materials_anisotropy";class cR{constructor(h){this.name=uR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,R,l){const j=[];return l instanceof ml.e&&l.anisotropy.isEnabled&&!l.anisotropy.legacy?(l.anisotropy.texture&&j.push(l.anisotropy.texture),j):[]}postExportMaterialAsync(h,R,l){return new Promise((h=>{if(l instanceof ml.e){if(!l.anisotropy.isEnabled||l.anisotropy.legacy)return void h(R);this._wasUsed=!0,R.extensions=R.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(l.anisotropy.texture),a={anisotropyStrength:l.anisotropy.nF,anisotropyRotation:l.anisotropy.angle,anisotropyTexture:j??void 0};null!==a.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(l),R.extensions[uR]=a}h(R)}))}}eh.RegisterExtension(uR,(h=>new cR(h)));const JR="KHR_materials_clearcoat";class qR{constructor(h){this.name=JR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,R,l){const j=[];return l instanceof ml.e&&l.clearCoat.isEnabled?(l.clearCoat.texture&&j.push(l.clearCoat.texture),!l.clearCoat.useRoughnessFromMainTexture&&l.clearCoat.textureRoughness&&j.push(l.clearCoat.textureRoughness),l.clearCoat.bumpTexture&&j.push(l.clearCoat.bumpTexture),j):[]}postExportMaterialAsync(h,R,l){return new Promise((h=>{if(l instanceof ml.e){if(!l.clearCoat.isEnabled)return void h(R);this._wasUsed=!0,R.extensions=R.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(l.clearCoat.texture);let D;D=l.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(l.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(l.clearCoat.textureRoughness),l.clearCoat.isTintEnabled&&a.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${l.name}`),l.clearCoat.remapF0OnInterfaceChange&&a.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${l.name}`);const U=this._exporter._materialExporter.getTextureInfo(l.clearCoat.bumpTexture),F={clearcoatFactor:l.clearCoat.nF,clearcoatTexture:j??void 0,clearcoatRoughnessFactor:l.clearCoat.roughness,clearcoatRoughnessTexture:D??void 0,clearcoatNormalTexture:U??void 0};null===F.clearcoatTexture&&null===F.clearcoatRoughnessTexture&&null===F.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(l),R.extensions[JR]=F}h(R)}))}}eh.RegisterExtension(JR,(h=>new qR(h)));const QR="KHR_materials_diffuse_transmission";function YR(h,R){const l=R.subSurface;let j=null;return l.translucencyIntensityTexture?j=l.translucencyIntensityTexture:l.thicknessTexture&&l.useMaskFromThicknessTexture&&(j=l.thicknessTexture),j&&!l.useGltfStyleTextures?(g.c.Warn(`${h}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${R.name}`,1),null):j}class sR{constructor(h){this.name=QR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,R,l){const j=[];if(l instanceof Qh.b&&this._isExtensionEnabled(l)){const R=YR(h,l);return R&&j.push(R),l.subSurface.translucencyColorTexture&&j.push(l.subSurface.translucencyColorTexture),j}return j}_isExtensionEnabled(h){if(h.unlit)return!1;const R=h.subSurface;return!!R.isTranslucencyEnabled&&(!h.unlit&&!R.useAlbedoToTintTranslucency&&R.useGltfStyleTextures&&1===R.volumeIndexOfRefraction&&0===R.minimumThickness&&0===R.maximumThickness)}postExportMaterialAsync(h,R,l){return new Promise((j=>{if(l instanceof Qh.b&&this._isExtensionEnabled(l)){this._wasUsed=!0;const j=l.subSurface,a=YR(h,l),D=0==j.translucencyIntensity?void 0:j.translucencyIntensity,U=this._exporter._materialExporter.getTextureInfo(a)??void 0,F=!j.translucencyColor||j.translucencyColor.equalsFloats(1,1,1)?void 0:j.translucencyColor.sF(),w=this._exporter._materialExporter.getTextureInfo(j.translucencyColorTexture)??void 0,mh={diffuseTransmissionFactor:D,diffuseTransmissionTexture:U,diffuseTransmissionColorFactor:F,diffuseTransmissionColorTexture:w};(U||w)&&this._exporter._materialNeedsUVsSet.add(l),R.extensions=R.extensions||{},R.extensions[QR]=mh}j(R)}))}}eh.RegisterExtension(QR,(h=>new sR(h)));const tR="KHR_materials_dispersion";class fR{constructor(){this.name=tR,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(h){if(h.unlit)return!1;const R=h.subSurface;return!(!R.isRefractionEnabled&&!R.isDispersionEnabled)}postExportMaterialAsync(h,R,l){return new Promise((h=>{if(l instanceof Qh.b&&this._isExtensionEnabled(l)){this._wasUsed=!0;const h={dispersion:l.subSurface.dispersion};R.extensions=R.extensions||{},R.extensions[tR]=h}h(R)}))}}eh.RegisterExtension(tR,(()=>new fR));const TR="KHR_materials_emissive_strength";class ER{constructor(){this.name=TR,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(h,R,l){return await new Promise((h=>{if(!(l instanceof Qh.b))return h(R);const j=l.emissiveColor.sF(),a=Math.max(...j);if(a>1){this._wasUsed=!0,R.extensions||(R.extensions={});const h={emissiveStrength:a},j=l.emissiveColor.scale(1/h.emissiveStrength);R.emissiveFactor=j.sF(),R.extensions[TR]=h}return h(R)}))}}eh.RegisterExtension(TR,(h=>new ER));const xR="KHR_materials_ior";class GR{constructor(){this.name=xR,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(h){return!h.unlit&&(void 0!=h.indexOfRefraction&&1.5!=h.indexOfRefraction)}postExportMaterialAsync(h,R,l){return new Promise((h=>{if(l instanceof Qh.b&&this._isExtensionEnabled(l)){this._wasUsed=!0;const h={ior:l.indexOfRefraction};R.extensions=R.extensions||{},R.extensions[xR]=h}h(R)}))}}eh.RegisterExtension(xR,(h=>new GR));const pR="KHR_materials_iridescence";class OR{constructor(h){this.name=pR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,R,l){const j=[];return l instanceof ml.e&&l.iridescence.isEnabled?(l.iridescence.texture&&j.push(l.iridescence.texture),l.iridescence.thicknessTexture&&l.iridescence.thicknessTexture!==l.iridescence.texture&&j.push(l.iridescence.thicknessTexture),j):[]}postExportMaterialAsync(h,R,l){return new Promise((h=>{if(l instanceof ml.e){if(!l.iridescence.isEnabled)return void h(R);this._wasUsed=!0,R.extensions=R.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(l.iridescence.texture),a=this._exporter._materialExporter.getTextureInfo(l.iridescence.thicknessTexture),D={iridescenceFactor:l.iridescence.nF,iridescenceIor:l.iridescence.indexOfRefraction,iridescenceThicknessMinimum:l.iridescence.minimumThickness,iridescenceThicknessMaximum:l.iridescence.maximumThickness,iridescenceTexture:j??void 0,iridescenceThicknessTexture:a??void 0};null===D.iridescenceTexture&&null===D.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(l),R.extensions[pR]=D}h(R)}))}}eh.RegisterExtension(pR,(h=>new OR(h)));const yR="KHR_materials_sheen";class vR{constructor(h){this.name=yR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,R,l){return l instanceof Qh.b&&l.sheen.isEnabled&&l.sheen.texture?[l.sheen.texture]:[]}async postExportMaterialAsync(h,R,l){return await new Promise((h=>{if(l instanceof Qh.b){if(!l.sheen.isEnabled)return void h(R);this._wasUsed=!0,null==R.extensions&&(R.extensions={});const j={sheenColorFactor:l.sheen.color.sF(),sheenRoughnessFactor:l.sheen.roughness??0};null===j.sheenColorTexture&&null===j.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(l),l.sheen.texture&&(j.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(l.sheen.texture)??void 0),l.sheen.textureRoughness&&!l.sheen.useRoughnessFromMainTexture?j.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(l.sheen.textureRoughness)??void 0:l.sheen.texture&&l.sheen.useRoughnessFromMainTexture&&(j.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(l.sheen.texture)??void 0),R.extensions[yR]=j}h(R)}))}}eh.RegisterExtension(yR,(h=>new vR(h)));const bR="KHR_materials_specular";class IR{constructor(h){this.name=bR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,R,l){const j=[];return l instanceof Qh.b&&this._isExtensionEnabled(l)?(l.metallicReflectanceTexture&&j.push(l.metallicReflectanceTexture),l.reflectanceTexture&&j.push(l.reflectanceTexture),j):j}_isExtensionEnabled(h){return!h.unlit&&(void 0!=h.metallicF0Factor&&1!=h.metallicF0Factor||void 0!=h.metallicReflectanceColor&&!h.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(h))}_hasTexturesExtension(h){return null!=h.metallicReflectanceTexture||null!=h.reflectanceTexture}postExportMaterialAsync(h,R,l){return new Promise((h=>{if(l instanceof Qh.b&&this._isExtensionEnabled(l)){this._wasUsed=!0,R.extensions=R.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(l.metallicReflectanceTexture)??void 0,j=this._exporter._materialExporter.getTextureInfo(l.reflectanceTexture)??void 0,a={specularFactor:1==l.metallicF0Factor?void 0:l.metallicF0Factor,specularTexture:h,specularColorFactor:l.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:l.metallicReflectanceColor.sF(),specularColorTexture:j};this._hasTexturesExtension(l)&&this._exporter._materialNeedsUVsSet.add(l),R.extensions[bR]=a}h(R)}))}}eh.RegisterExtension(bR,(h=>new IR(h)));const LR="KHR_materials_transmission";class nR{constructor(h){this.name=LR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,R,l){const j=[];return l instanceof Qh.b&&this._isExtensionEnabled(l)?(l.subSurface.thicknessTexture&&j.push(l.subSurface.thicknessTexture),j):j}_isExtensionEnabled(h){if(h.unlit)return!1;const R=h.subSurface;return R.isRefractionEnabled&&void 0!=R.refractionIntensity&&0!=R.refractionIntensity||this._hasTexturesExtension(h)}_hasTexturesExtension(h){return null!=h.subSurface.refractionIntensityTexture}async postExportMaterialAsync(h,R,l){if(l instanceof Qh.b&&this._isExtensionEnabled(l)){this._wasUsed=!0;const j=l.subSurface,a={transmissionFactor:0===j.refractionIntensity?void 0:j.refractionIntensity};if(this._hasTexturesExtension(l)&&this._exporter._materialNeedsUVsSet.add(l),j.refractionIntensityTexture)if(j.useGltfStyleTextures){const h=await this._exporter._materialExporter.exportTextureAsync(j.refractionIntensityTexture,"image/png");h&&(a.transmissionTexture=h)}else g.c.Warn(`${h}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);R.extensions||(R.extensions={}),R.extensions[LR]=a}return R}}eh.RegisterExtension(LR,(h=>new nR(h)));const rR="KHR_materials_unlit";class PR{constructor(){this.name=rR,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(h,R,l){return new Promise((h=>{let j=!1;l instanceof Qh.b?j=l.unlit:l instanceof Yh.ER&&(j=l.disableLighting),j&&(this._wasUsed=!0,null==R.extensions&&(R.extensions={}),R.extensions[rR]={}),h(R)}))}}eh.RegisterExtension(rR,(()=>new PR));const zR="KHR_materials_volume";class oR{constructor(h){this.name=zR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,R,l){const j=[];return l instanceof Qh.b&&this._isExtensionEnabled(l)?(l.subSurface.thicknessTexture&&j.push(l.subSurface.thicknessTexture),j):j}_isExtensionEnabled(h){if(h.unlit)return!1;const R=h.subSurface;return!(!R.isRefractionEnabled&&!R.isTranslucencyEnabled)&&(void 0!=R.maximumThickness&&0!=R.maximumThickness||void 0!=R.tintColorAtDistance&&R.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=R.tintColor&&R.tintColor!=s.xR.White()||this._hasTexturesExtension(h))}_hasTexturesExtension(h){return null!=h.subSurface.thicknessTexture}postExportMaterialAsync(h,R,l){return new Promise((h=>{if(l instanceof Qh.b&&this._isExtensionEnabled(l)){this._wasUsed=!0;const h=l.subSurface,j={thicknessFactor:0==h.maximumThickness?void 0:h.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(h.thicknessTexture)??void 0,attenuationDistance:h.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:h.tintColorAtDistance,attenuationColor:h.tintColor.equalsFloats(1,1,1)?void 0:h.tintColor.sF()};this._hasTexturesExtension(l)&&this._exporter._materialNeedsUVsSet.add(l),R.extensions=R.extensions||{},R.extensions[zR]=j}h(R)}))}}eh.RegisterExtension(zR,(h=>new oR(h)));const KR="EXT_materials_diffuse_roughness";class WR{constructor(h){this.name=KR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,R,l){const j=[];return l instanceof ml.e&&l._baseDiffuseRoughness?(l._baseDiffuseRoughnessTexture&&j.push(l._baseDiffuseRoughnessTexture),j):[]}postExportMaterialAsync(h,R,l){return new Promise((h=>{if(l instanceof ml.e){if(!l._baseDiffuseRoughness)return void h(R);this._wasUsed=!0,R.extensions=R.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(l._baseDiffuseRoughnessTexture),a={diffuseRoughnessFactor:l._baseDiffuseRoughness,diffuseRoughnessTexture:j??void 0};null!==a.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(l),R.extensions[KR]=a}h(R)}))}}eh.RegisterExtension(KR,(h=>new WR(h)));const gR="KHR_texture_transform";class HR{constructor(){this.name=gR,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(h,R,l){if(l.yh()||a.Tools.Warn(`${h}: /*@__KEY__*/"scene" is not defined for Babylon texture ${l.name}!`),(0!==l.uAng||0!==l.vAng)&&(a.Tools.Warn(`${h}: Texture ${l.name} with rotation in the u or v axis is not supported in glTF.`),0!==l.uRotationCenter||0!==l.vRotationCenter))return;const j={};let D=!1;if(0===l.uOffset&&0===l.vOffset||(j.offset=[l.uOffset,l.vOffset],D=!0),1===l.uScale&&1===l.vScale||(j.scale=[l.uScale,l.vScale],D=!0),0!==l.wAng){if(0!==l.uRotationCenter||0!==l.vRotationCenter){if(l.homogeneousRotationInUVTransform&&l.uScale!==l.vScale)return void a.Tools.Warn(`${h}: Texture ${l.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${gR}.`);a.Tools.Warn(`${h}: Texture ${l.name} with non-origin rotation center will be exported using an adjusted offset with ${gR}.`),j.offset=function(h){const{uOffset:R,vOffset:l,uRotationCenter:j,vRotationCenter:a,uScale:D,vScale:U,wAng:F}=h,w=Math.cos(F),mh=Math.sin(F),u=j*D,c=a*U;return[R+(u*(1-w)+c*mh),l+(c*(1-w)-u*mh)]}(l)}j.rotation=-l.wAng,D=!0}0!==l.coordinatesIndex&&(j.texCoord=l.coordinatesIndex,D=!0),D&&(this._wasUsed=!0,R.extensions||(R.extensions={}),R.extensions[gR]=j)}}eh.RegisterExtension(gR,(()=>new HR));class kR{static CreateSTL(h){let R=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],D=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],U=arguments.length>5&&void 0!==arguments[5]&&arguments[5],F=arguments.length>6&&void 0!==arguments[6]&&arguments[6],w=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const mh=function(h,R,l){const a=[3*h[l],3*h[l+1],3*h[l+2]],D=[new j.tR(R[a[0]],R[a[0]+2],R[a[0]+1]),new j.tR(R[a[1]],R[a[1]+2],R[a[1]+1]),new j.tR(R[a[2]],R[a[2]+2],R[a[2]+1])],U=D[0].fR(D[1]),F=D[2].fR(D[1]);return{v:D,n:j.tR.Cross(F,U).normalize()}},c=function(h,R,l,j){return R=J(h,R,l.x,j),R=J(h,R,l.y,j),J(h,R,l.z,j)},J=function(h,R,l,j){return h.setFloat32(R,l,j),R+4},Q=function(h){if(F){let R=h;h instanceof q.e&&(R=h.sourceMesh);const l=R.getVerticesData(u.g.PositionKind,!0,!0);if(!l)return[];const a=j.tR.Zero();let D;for(D=0;D<l.length;D+=3)j.tR.TransformCoordinatesFromFloatsToRef(l[D],l[D+1],l[D+2],h.EF(!0),a).toArray(l,D);return l}return h.getVerticesData(u.g.PositionKind)||[]};F&&(U=!0);let Y="",s=0,t=0;if(a){for(let l=0;l<h.length;l++){const R=h[l].GF();s+=R?R.length/3:0}const R=new ArrayBuffer(84+50*s);Y=new DataView(R),t+=80,Y.setUint32(t,s,D),t+=4}else w||(Y="solid stlmesh\r\n");for(let j=0;j<h.length;j++){const R=h[j];!a&&w&&(Y+="solid "+R.name+"\r\n"),!U&&R instanceof fh.b&&R.bakeCurrentTransformIntoVertices();const l=Q(R),F=R.GF()||[];for(let h=0;h<F.length;h+=3){const R=mh(F,l,h);a?(t=c(Y,t,R.n,D),t=c(Y,t,R.v[0],D),t=c(Y,t,R.v[1],D),t=c(Y,t,R.v[2],D),t+=2):(Y+="\tfacet normal "+R.n.x+" "+R.n.y+" "+R.n.z+"\r\n",Y+="\t\touter loop\r\n",Y+="\t\t\tvertex "+R.v[0].x+" "+R.v[0].y+" "+R.v[0].z+"\r\n",Y+="\t\t\tvertex "+R.v[1].x+" "+R.v[1].y+" "+R.v[1].z+"\r\n",Y+="\t\t\tvertex "+R.v[2].x+" "+R.v[2].y+" "+R.v[2].z+"\r\n",Y+="\t\tendloop\r\n",Y+="\tendfacet\r\n")}!a&&w&&(Y+="endsolid "+name+"\r\n")}if(a||w||(Y+="endsolid stlmesh"),R){const h=document.createElement("a"),R=new Blob([Y],{type:"application/octet-stream"});h.href=window.URL.createObjectURL(R),h.download=l+".stl",h.click()}return Y}}function CR(h,R){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const j=[];for(let a=0;a<h.length/l;a++){const D=h[a*l],U=h[a*l+1],F=h[a*l+2];j.push(`(${D.toPrecision(R.precision)}, ${U.toPrecision(R.precision)}, ${F.toPrecision(R.precision)})`)}return j.join(", ")}function AR(h,R){const l=[];for(let j=0;j<h.length/2;j++){const a=h[2*j],D=h[2*j+1];l.push(`(${a.toPrecision(R.precision)}, ${(1-D).toPrecision(R.precision)})`)}return l.join(", ")}function eR(h,R){const l=h.getVerticesData(u.g.PositionKind),j=h.getVerticesData(u.g.NormalKind);if(l&&j)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(h){var R;const l=null!==(R=h.GF())&&void 0!==R&&R.length?h.getTotalIndices():h.getTotalVertices();return Array(l/3).fill(3).join(", ")}(h)}]\n\t\tint[] faceVertexIndices = [${function(h){const R=h.GF(),l=[];if(null!==R)for(let j=0;j<R.length;j++)l.push(R[j]);else{const R=h.getTotalVertices();for(let h=0;h<R;h++)l.push(h)}return l.join(", ")}(h)}]\n\t\tnormal3f[] normals = [${CR(j,R)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${CR(l,R)}]\n        ${function(h,R){let l="";for(let a=0;a<4;a++){const j=a>0?a:"",D=h.getVerticesData(u.g.UVKind+(j?j+1:""));D&&(l+=`\n\t\ttexCoord2f[] primvars:st${j} = [${AR(D,R)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const j=h.getVerticesData(u.g.ColorKind);return j&&(l+=`\n\tcolor3f[] primvars:displayColor = [${CR(j,R,j.length/h.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),l}(h,R)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function SR(h,R){return`\n        def "Geometry"\n        {\n        ${eR(h,R)}\n        }\n        `}function ZR(h){let R='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return R+=h,fflate.strToU8(R)}function MR(h){const R=h.m;return`( ${iR(R,0)}, ${iR(R,4)}, ${iR(R,8)}, ${iR(R,12)} )`}function iR(h,R){return`(${h[R+0]}, ${h[R+1]}, ${h[R+2]}, ${h[R+3]})`}function dR(h){const R="Object_"+h.uniqueId,l=function(h){const R=h.getWorldMatrix().clone(),l=h.yh().useRightHandedSystem;if(!l){let j=h.parent;for(;j;){if(Uh(j,l)){R.multiplyToRef(j.getWorldMatrix().invert(),R);break}j=j.parent}}return R.determinant()<0&&a.Tools.Warn(`Exporting mesh ${h.name} with negative scale. Result may look incorrect in destination engine.`),R}(h),j=MR(l);return`def Xform "${R}" (\n\tprepend references = @./geometries/Geometry_${h.xF.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${j}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${h.material.uniqueId}>\n}\n\n`}function XR(h){switch(h){case p.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case p.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case p.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function VR(h){return`(${h.x}, ${h.y})`}function BR(h){return`(${h.r}, ${h.g}, ${h.b})`}function NR(h,R,l,a,D,U){const F=h.getInternalTexture().uniqueId+"_"+h.invertY;D[F]=h;const w=h.coordinatesIndex>0?"st"+h.coordinatesIndex:"st",mh=new j.Vector2(h.uScale,h.vScale),u=new j.Vector2(h.uOffset,h.vOffset),c=h.wAng,J=Math.sin(c),q=Math.cos(c);return u.y=1-u.y-mh.y,u.x+=J*mh.x,u.y+=(1-q)*mh.y,`\n    def Shader "PrimvarReader_${l}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${w}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${l}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${R.uniqueId}/PrimvarReader_${l}.outputs:result>\n        float inputs:rotation = ${(c*(180/Math.PI)).toFixed(U.precision)}\n        float2 inputs:scale = ${VR(mh)}\n        float2 inputs:translation = ${VR(u)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${h.uniqueId}_${l}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${F}.png@\n        float2 inputs:st.connect = </Materials/Material_${R.uniqueId}/Transform2d_${l}.outputs:result>\n        ${a?"float4 inputs:scale = "+function(h){return`(${h.r}, ${h.g}, ${h.b}, 1.0)`}(a):""}\n        token inputs:sourceColorSpace = "${h.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${XR(h.wrapU)}"\n        token inputs:wrapT = "${XR(h.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${R.needAlphaBlending()?"float outputs:a":""}\n    }`}function hl(h,R,l){const j="\t\t\t",a=[],D=[],{diffuseMap:U,rF:F,alphaCutOff:w,emissiveMap:mh,emissive:u,normalMap:c,roughnessMap:J,roughnessChannel:q,roughness:Q,metalnessMap:Y,metalnessChannel:t,metalness:f,aoMap:T,aoMapChannel:E,aoMapIntensity:x,alphaMap:G,ior:p,clearCoatEnabled:O,clearCoat:y,clearCoatMap:v,clearCoatRoughness:b,clearCoatRoughnessMap:I}=function(h){const R={diffuseMap:null,rF:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return h instanceof Yh.ER?{...R,diffuseMap:h.diffuseTexture,rF:h.diffuseColor,alphaCutOff:h.alphaCutOff,emissiveMap:h.emissiveTexture,emissive:h.emissiveColor,roughness:1,alphaMap:h.opacityTexture}:h instanceof ml.e?{...R,diffuseMap:h._albedoTexture,rF:h._albedoColor,alphaCutOff:h._alphaCutOff,emissiveMap:h._emissiveTexture,emissive:h._emissiveColor,normalMap:h._bumpTexture,roughnessMap:h._metallicTexture,roughnessChannel:h._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:h._roughness??1,metalnessMap:h._metallicTexture,metalnessChannel:h._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:h._metallic??0,aoMap:h._ambientTexture,aoMapChannel:h._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:h._ambientTextureStrength,alphaMap:h._opacityTexture,ior:h.subSurface.indexOfRefraction,clearCoatEnabled:h.clearCoat.isEnabled,clearCoat:h.clearCoat.nF,clearCoatMap:h.clearCoat.texture,clearCoatRoughness:h.clearCoat.roughness,clearCoatRoughnessMap:h.clearCoat.useRoughnessFromMainTexture?h.clearCoat.texture:h.clearCoat.textureRoughness}:R}(h);return null!==U?(a.push(`${j}color3f inputs:diffuseColor.connect = </Materials/Material_${h.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:rgb>`),h.needAlphaBlending()?a.push(`${j}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:a>`):h.needAlphaTesting()&&(a.push(`${j}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:a>`),a.push(`${j}float inputs:opacityThreshold = ${w}`)),D.push(NR(U,h,"diffuse",F,R,l))):a.push(`${j}color3f inputs:diffuseColor = ${BR(F||s.xR.White())}`),null!==mh?(a.push(`${j}color3f inputs:emissiveColor.connect = </Materials/Material_${h.uniqueId}/Texture_${mh.uniqueId}_emissive.outputs:rgb>`),D.push(NR(mh,h,"emissive",u,R,l))):u&&u.toLuminance()>0&&a.push(`${j}color3f inputs:emissiveColor = ${BR(u)}`),null!==c&&(a.push(`${j}normal3f inputs:normal.connect = </Materials/Material_${h.uniqueId}/Texture_${c.uniqueId}_normal.outputs:rgb>`),D.push(NR(c,h,"normal",null,R,l))),null!==T&&(a.push(`${j}float inputs:occlusion.connect = </Materials/Material_${h.uniqueId}/Texture_${T.uniqueId}_occlusion.outputs:${E}>`),D.push(NR(T,h,"occlusion",new s.xR(x,x,x),R,l))),null!==J?(a.push(`${j}float inputs:roughness.connect = </Materials/Material_${h.uniqueId}/Texture_${J.uniqueId}_roughness.outputs:${q}>`),D.push(NR(J,h,"roughness",new s.xR(Q,Q,Q),R,l))):a.push(`${j}float inputs:roughness = ${Q}`),null!==Y?(a.push(`${j}float inputs:metallic.connect = </Materials/Material_${h.uniqueId}/Texture_${Y.uniqueId}_metallic.outputs:${t}>`),D.push(NR(Y,h,"metallic",new s.xR(f,f,f),R,l))):a.push(`${j}float inputs:metallic = ${f}`),null!==G?(a.push(`${j}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${G.uniqueId}_opacity.outputs:r>`),a.push(`${j}float inputs:opacityThreshold = 0.0001`),D.push(NR(G,h,"opacity",null,R,l))):a.push(`${j}float inputs:opacity = ${h.alpha}`),O&&(null!==v?(a.push(`${j}float inputs:clearcoat.connect = </Materials/Material_${h.uniqueId}/Texture_${v.uniqueId}_clearcoat.outputs:r>`),D.push(NR(v,h,"clearcoat",new s.xR(y,y,y),R,l))):a.push(`${j}float inputs:clearcoat = ${y}`),null!==I?(a.push(`${j}float inputs:clearcoatRoughness.connect = </Materials/Material_${h.uniqueId}/Texture_${I.uniqueId}_clearcoatRoughness.outputs:g>`),D.push(NR(I,h,"clearcoatRoughness",new s.xR(b,b,b),R,l))):a.push(`${j}float inputs:clearcoatRoughness = ${b}`)),a.push(`${j}float inputs:ior = ${p}`),`\n\tdef Material "Material_${h.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${a.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${h.uniqueId}/PreviewSurface.outputs:surface>\n\n${D.join("\n")}\n\n\t}\n`}async function Rl(h,R,l){const D={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...R};"undefined"===typeof fflate&&await a.Tools.LoadScriptAsync(D.fflateUrl);const U={};U[D.modelFileName]=null;let F='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';F+=function(h){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===h.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${h.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${h.planeAnchoringAlignment}"`:""}\n            `}(D);const w={};for(const j of h.meshes){if(0===j.getTotalVertices())continue;const h=j,R=h.xF,mh=h.material;if(!mh||!R||l&&!l(h))continue;if(-1!==["ER","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(mh.getClassName())){const l="geometries/Geometry_"+R.uniqueId+".usda";if(!(l in U)){const h=SR(R,D);U[l]=ZR(h)}mh.uniqueId in w||(w[mh.uniqueId]=mh),F+=dR(h)}else a.Tools.Warn("USDZExportAsync does not support this material type: "+mh.getClassName())}h.activeCamera&&D.exportCamera&&(F+=function(h,R){const l="Camera_"+h.uniqueId,a=MR(j.Matrix.RotationY(Math.PI).multiply(h.getWorldMatrix()));if(h.mode===p.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${l}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${a}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${h.fF.toPrecision(R.precision)}, ${h.maxZ.toPrecision(R.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(h.orthoLeft||1)+Math.abs(h.orthoRight||1))).toPrecision(R.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(h.orthoTop||1)+Math.abs(h.orthoBottom||1))).toPrecision(R.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const j=h.getEngine().getAspectRatio(h),D=R.cameraSensorWidth||35;return`def Camera "${l}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${a}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${h.fF.toPrecision(R.precision)}, ${h.maxZ.toPrecision(R.precision)})\n\t\t\tfloat focalLength = ${(D/(2*Math.tan(.5*h.fov))).toPrecision(R.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(D*j).toPrecision(R.precision)}\n\t\t\tfloat verticalAperture = ${(D/j).toPrecision(R.precision)}            \n\t\t}\n\t\n\t`}}(h.activeCamera,D)),F+="\n            }\n        }\n    }";const mh={};F+=function(h,R,l){const j=[];for(const a in h){const D=h[a];j.push(hl(D,R,l))}return`\n    def "Materials"\n{\n${j.join("")}\n}\n\n`}(w,mh,D),U[D.modelFileName]=fflate.strToU8(F);for(const j in mh){const h=mh[j],R=h.getSize(),l=await h.readPixels();if(!l)throw new Error("Texture data is not available");const a=await O.DumpTools.DumpDataAsync(R.width,R.height,l,"image/png",void 0,!1,!0);U[`textures/Texture_${j}.png`]=new Uint8Array(a).slice()}let u=0;for(const j in U){const h=U[j];if(!h)continue;u+=34+j.length;const R=63&u;if(4!==R){const l=new Uint8Array(64-R);U[j]=[h,{extra:{12345:l}}]}u=h.length}return fflate.zipSync(U,{level:0})}}}]);