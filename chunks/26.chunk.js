"use strict";(self.ynu1yiqvs98=self.ynu1yiqvs98||[]).push([[26],{11523:(I,E,j)=>{j.r(E),j.d(E,{EXT_materials_diffuse_roughness:()=>TE,EXT_mesh_gpu_instancing:()=>BI,GLTF2Export:()=>fI,GLTFData:()=>R,KHR_draco_mesh_compression:()=>jE,KHR_lights_punctual:()=>UE,KHR_materials_anisotropy:()=>oE,KHR_materials_clearcoat:()=>cE,KHR_materials_diffuse_transmission:()=>FE,KHR_materials_dispersion:()=>XE,KHR_materials_emissive_strength:()=>xE,KHR_materials_ior:()=>bE,KHR_materials_iridescence:()=>GE,KHR_materials_sheen:()=>dE,KHR_materials_specular:()=>lE,KHR_materials_transmission:()=>rE,KHR_materials_unlit:()=>HE,KHR_materials_volume:()=>YE,KHR_texture_transform:()=>WE,OBJExport:()=>h,STLExport:()=>OE,USDZExportAsync:()=>Ej,_ConvertToGLTFPBRMetallicRoughness:()=>n,_SolveMetallic:()=>r,__IGLTFExporterExtension:()=>t});var e=j(11117),w=j(10953),z=j(11436);class h{static OBJ(I,E,j,h){const t=[];let U=1,R=1;E&&(j||(j="mat"),t.push("mtllib "+j+".mtl"));for(let P=0;P<I.length;P++){const j=I[P],o=j.name||`mesh${P}}`;t.push(`o ${o}`);let Z=null;if(h){const I=j.Be(!0);Z=new e.Matrix,I.invertToRef(Z),j.bakeTransformIntoVertices(I)}if(E){const I=j.material;I&&t.push("usemtl "+I.id)}const c=j.Je;if(!c){w.Tools.Warn("No geometry is present on the mesh");continue}const K=c.getVerticesData("position"),L=c.getVerticesData("normal"),F=c.getVerticesData("uv"),C=c.me();let X=0,q=0;if(!K||!C){w.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const x=I[0].GI().useRightHandedSystem?1:-1;for(let I=0;I<K.length;I+=3)t.push("v "+K[I]*x+" "+K[I+1]+" "+K[I+2]),X++;if(null!=L)for(let I=0;I<L.length;I+=3)t.push("vn "+L[I]*x+" "+L[I+1]+" "+L[I+2]);if(null!=F)for(let I=0;I<F.length;I+=2)t.push("vt "+F[I]+" "+F[I+1]),q++;const u=["","",""],b=(j.material||j.GI().defaultMaterial)._getEffectiveOrientation(j),[Q,G]=b===z.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let I=0;I<C.length;I+=3){const E=[String(C[I]+U),String(C[I+Q]+U),String(C[I+G]+U)],j=[String(C[I]+R),String(C[I+Q]+R),String(C[I+G]+R)],e=E,w=null!=F?j:u,z=null!=L?E:u;t.push("f "+e[0]+"/"+w[0]+"/"+z[0]+" "+e[1]+"/"+w[1]+"/"+z[1]+" "+e[2]+"/"+w[2]+"/"+z[2])}h&&Z&&j.bakeTransformIntoVertices(Z),U+=X,R+=q}return t.join("\n")}static MTL(I){const E=[],j=I.material;E.push("newmtl mat1"),E.push("  Ns "+j.specularPower.toFixed(4)),E.push("  Ni 1.5000"),E.push("  d "+j.alpha.toFixed(4)),E.push("  Tr 0.0000"),E.push("  Tf 1.0000 1.0000 1.0000"),E.push("  illum 2"),E.push("  Ka "+j.ambientColor.r.toFixed(4)+" "+j.ambientColor.g.toFixed(4)+" "+j.ambientColor.b.toFixed(4)),E.push("  Kd "+j.diffuseColor.r.toFixed(4)+" "+j.diffuseColor.g.toFixed(4)+" "+j.diffuseColor.b.toFixed(4)),E.push("  Ks "+j.specularColor.r.toFixed(4)+" "+j.specularColor.g.toFixed(4)+" "+j.specularColor.b.toFixed(4)),E.push("  Ke "+j.emissiveColor.r.toFixed(4)+" "+j.emissiveColor.g.toFixed(4)+" "+j.emissiveColor.b.toFixed(4));j.ambientTexture&&E.push("  map_Ka "+j.ambientTexture.name),j.diffuseTexture&&E.push("  map_Kd "+j.diffuseTexture.name),j.specularTexture&&E.push("  map_Ks "+j.specularTexture.name),j.bumpTexture&&E.push("  map_bump -imfchan z "+j.bumpTexture.name),j.opacityTexture&&E.push("  map_d "+j.opacityTexture.name);return E.join("\n")}}var t=0,U=j(11e3);class R{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const I in this.files){const E=this.files[I],j=new Blob([E],{type:(0,U.e)(I)});w.Tools.Download(j,I)}}}var P=j(11197),o=j(11530),Z=j(11535),c=j(11556),K=j(11252),L=j(10993),F=j(11165),C=j(11136);const X=C.HighestCommonFactor,q={...C,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:X};var x=j(11348),u=j(11097),b=j(11587),Q=j(11595),G=j(11345);const y=1e-6,d=new F.qE(.04,.04,.04),a=1024,l=F.qE.White(),i=F.qE.Black();function r(I,E,j){if(E<d.r)return 0;const e=d.r,w=I*j/(1-d.r)+E-2*d.r,z=w*w-4*e*(d.r-E);return q.Clamp((-w+Math.sqrt(z))/(2*e),0,1)}function n(I){const E=I.diffuseColor.toLinearSpace(I.GI().getEngine().useExactSrgbConversions).scale(.5),j=I.alpha,w=function(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new e.Vector2(0,1),j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new e.Vector2(0,.1),w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new e.Vector2(0,.1),z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new e.Vector2(1300,.1);return function(I,E,j,e,w){return(1-I)*(1-I)*(1-I)*E+3*(1-I)*(1-I)*I*j+3*(1-I)*I*I*e+I*I*I*w}(Math.pow(I/z.x,.333333),E.y,j.y,w.y,z.y)}(q.Clamp(I.specularPower,0,a));return{baseColorFactor:[E.r,E.g,E.b,j],metallicFactor:0,roughnessFactor:w}}function H(I,E){E.needAlphaBlending()?I.alphaMode="BLEND":E.needAlphaTesting()&&(I.alphaMode="MASK",I.alphaCutoff=E.alphaCutOff)}function g(I,E,j){const e=new Uint8Array(I*E*4);for(let w=0;w<e.length;w+=4)e[w]=e[w+1]=e[w+2]=e[w+3]=255;return b.c.CreateRGBATexture(e,I,E,j)}function Y(I){if(I instanceof Uint8Array){const E=I.length,j=new Float32Array(I.length);for(let e=0;e<E;++e)j[e]=I[e]/255;return j}if(I instanceof Float32Array)return I;throw new Error("Unsupported pixel format!")}class A{constructor(I){this._exporter=I,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(I){return I?this._textureMap.get(I)??null:null}async exportStandardMaterialAsync(I,E,j){const e=n(I),z={name:I.name};if(null==I.tz||I.tz||(I.twoSidedLighting||w.Tools.Warn(I.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),z.doubleSided=!0),j){const j=[],w=I.diffuseTexture;w&&j.push(this.exportTextureAsync(w,E).then((I=>{I&&(e.baseColorTexture=I)})));const h=I.bumpTexture;h&&j.push(this.exportTextureAsync(h,E).then((I=>{I&&(z.normalTexture=I,1!==h.level&&(z.normalTexture.scale=h.level))})));const t=I.emissiveTexture;t&&(z.emissiveFactor=[1,1,1],j.push(this.exportTextureAsync(t,E).then((I=>{I&&(z.emissiveTexture=I)}))));const U=I.ambientTexture;U&&j.push(this.exportTextureAsync(U,E).then((I=>{if(I){const E={index:I.index};z.occlusionTexture=E}}))),j.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(j))}(I.alpha<1||I.opacityTexture)&&(I.alphaMode===Q.b.ALPHA_COMBINE?z.alphaMode="BLEND":w.Tools.Warn(I.name+": glTF 2.0 does not support alpha mode: "+I.alphaMode.toString())),I.emissiveColor&&!I.emissiveColor.equalsWithEpsilon(i,y)&&(z.emissiveFactor=I.emissiveColor.re()),z.pbrMetallicRoughness=e,H(z,I),await this._finishMaterialAsync(z,I,E);const h=this._exporter._materials;return h.push(z),h.length-1}async _finishMaterialAsync(I,E,j){const e=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",I,E),w=[];for(const z of e)w.push(this.exportTextureAsync(z,j));await Promise.all(w),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",I,E)}async _getImageDataAsync(I,E,e,w){const z=Q.b.TEXTURETYPE_UNSIGNED_BYTE,h=this._exporter._babylonScene,t=h.getEngine(),U=t.createRawTexture(I,E,e,Q.b.TEXTUREFORMAT_RGBA,!1,!0,u.d.NEAREST_SAMPLINGMODE,null,z);t.isWebGPU?await j.e(51).then(j.bind(j,13597)):await j.e(52).then(j.bind(j,13603)),await x.l.ApplyPostProcess("pass",U,h,z,Q.b.TEXTURE_NEAREST_SAMPLINGMODE,Q.b.TEXTUREFORMAT_RGBA);const R=await t._readTexturePixels(U,E,e);return await G.DumpTools.DumpDataAsync(E,e,R,w,void 0,!0,!0)}_resizeTexturesToSameDimensions(I,E,j){const e=I?I.getSize():{width:0,height:0},w=E?E.getSize():{width:0,height:0};let z,h;return e.width<w.width?(z=I&&I instanceof u.d?x.l.CreateResizedCopy(I,w.width,w.height,!0):g(w.width,w.height,j),h=E):e.width>w.width?(h=E&&E instanceof u.d?x.l.CreateResizedCopy(E,e.width,e.height,!0):g(e.width,e.height,j),z=I):(z=I,h=E),{texture1:z,texture2:h}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(I,E,j,e){const w=new Array;if(!I&&!E)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const z=I?I.GI():E?E.GI():null;if(z){var h;const t=this._resizeTexturesToSameDimensions(I,E,z),U=null===(h=t.texture1)||void 0===h?void 0:h.getSize();let R,P;const o=U.width,Z=U.height,c=await t.texture1.readPixels(),K=await t.texture2.readPixels();if(!c)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(R=Y(c),!K)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");P=Y(K);const L=P.byteLength,C=new Uint8Array(L),X=new Uint8Array(L),q=4,x=i;let u=0,b=0;for(let I=0;I<Z;++I)for(let E=0;E<o;++E){const e=(o*I+E)*q,w={diffuseColor:new F.qE(R[e],R[e+1],R[e+2]).toLinearSpace(z.getEngine().useExactSrgbConversions).multiply(j.diffuseColor),specularColor:new F.qE(P[e],P[e+1],P[e+2]).toLinearSpace(z.getEngine().useExactSrgbConversions).multiply(j.specularColor),glossiness:P[e+3]*j.glossiness},h=this._convertSpecularGlossinessToMetallicRoughness(w);x.r=Math.max(x.r,h.baseColor.r),x.g=Math.max(x.g,h.baseColor.g),x.b=Math.max(x.b,h.baseColor.b),u=Math.max(u,h.metallic),b=Math.max(b,h.roughness),X[e]=255*h.baseColor.r,X[e+1]=255*h.baseColor.g,X[e+2]=255*h.baseColor.b,X[e+3]=t.texture1.ne?255*R[e+3]:255,C[e]=0,C[e+1]=255*h.roughness,C[e+2]=255*h.metallic,C[e+3]=255}const Q={baseColor:x,metallic:u,roughness:b};let G=!1,d=!1;for(let I=0;I<Z;++I)for(let E=0;E<o;++E){const j=(o*I+E)*q;X[j]/=Q.baseColor.r>y?Q.baseColor.r:1,X[j+1]/=Q.baseColor.g>y?Q.baseColor.g:1,X[j+2]/=Q.baseColor.b>y?Q.baseColor.b:1;const e=F.qE.FromInts(X[j],X[j+1],X[j+2]).toGammaSpace(z.getEngine().useExactSrgbConversions);X[j]=255*e.r,X[j+1]=255*e.g,X[j+2]=255*e.b,e.equalsWithEpsilon(l,y)||(d=!0),C[j+1]/=Q.roughness>y?Q.roughness:1,C[j+2]/=Q.metallic>y?Q.metallic:1;F.qE.FromInts(255,C[j+1],C[j+2]).equalsWithEpsilon(l,y)||(G=!0)}return G&&w.push(this._getImageDataAsync(C,o,Z,e).then((I=>{Q.metallicRoughnessTextureData=I}))),d&&w.push(this._getImageDataAsync(X,o,Z,e).then((I=>{Q.baseColorTextureData=I}))),await Promise.all(w).then((()=>Q))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(I){const E=this._getPerceivedBrightness(I.diffuseColor),j=this._getPerceivedBrightness(I.specularColor),e=1-this._getMaxComponent(I.specularColor),w=r(E,j,e),z=I.diffuseColor.scale(e/(1-d.r)/Math.max(1-w)),h=I.specularColor.FE(d.scale(1-w)).scale(1/Math.max(w));let t=F.qE.Lerp(z,h,w*w);t=t.clampToRef(0,1,t);return{baseColor:t,metallic:w,roughness:1-I.glossiness}}_getPerceivedBrightness(I){return I?Math.sqrt(.299*I.r*I.r+.587*I.g*I.g+.114*I.b*I.b):0}_getMaxComponent(I){return I?Math.max(I.r,Math.max(I.g,I.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(I,E,j,e){const w=[],z={baseColor:I._albedoColor,metallic:I._metallic,roughness:I._roughness};if(e){I._albedoTexture&&w.push(this.exportTextureAsync(I._albedoTexture,E).then((I=>{I&&(j.baseColorTexture=I)})));const e=I._metallicTexture;e&&w.push(this.exportTextureAsync(e,E).then((I=>{I&&(j.metallicRoughnessTexture=I)})))}return w.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(w)),z}_getTextureSampler(I){const E={};if(!I||!(I instanceof u.d))return E;const j=this._getGLTFTextureWrapMode(I.wrapU);10497!==j&&(E.wrapS=j);const e=this._getGLTFTextureWrapMode(I.wrapV);switch(10497!==e&&(E.wrapT=e),I.samplingMode){case u.d.LINEAR_LINEAR:E.magFilter=9729,E.minFilter=9729;break;case u.d.LINEAR_NEAREST:E.magFilter=9729,E.minFilter=9728;break;case u.d.NEAREST_LINEAR:E.magFilter=9728,E.minFilter=9729;break;case u.d.NEAREST_LINEAR_MIPLINEAR:E.magFilter=9728,E.minFilter=9987;break;case u.d.NEAREST_NEAREST:E.magFilter=9728,E.minFilter=9728;break;case u.d.NEAREST_LINEAR_MIPNEAREST:E.magFilter=9728,E.minFilter=9985;break;case u.d.LINEAR_NEAREST_MIPNEAREST:E.magFilter=9729,E.minFilter=9984;break;case u.d.LINEAR_NEAREST_MIPLINEAR:E.magFilter=9729,E.minFilter=9986;break;case u.d.NEAREST_NEAREST_MIPLINEAR:E.magFilter=9728,E.minFilter=9986;break;case u.d.LINEAR_LINEAR_MIPLINEAR:E.magFilter=9729,E.minFilter=9987;break;case u.d.LINEAR_LINEAR_MIPNEAREST:E.magFilter=9729,E.minFilter=9985;break;case u.d.NEAREST_NEAREST_MIPNEAREST:E.magFilter=9728,E.minFilter=9984}return E}_getGLTFTextureWrapMode(I){switch(I){case u.d.WRAP_ADDRESSMODE:return 10497;case u.d.CLAMP_ADDRESSMODE:return 33071;case u.d.MIRROR_ADDRESSMODE:return 33648;default:return w.Tools.Error(`Unsupported Texture Wrap Mode ${I}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(I,E,j,e){const w={diffuseColor:I._albedoColor,specularColor:I._reflectivityColor,glossiness:I._microSurface},z=I._albedoTexture,h=I._reflectivityTexture,t=I._useMicroSurfaceFromReflectivityMapAlpha;if(h&&!t)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((z||h)&&e){this._exporter._materialNeedsUVsSet.add(I);const e=this._exportTextureSampler(z||h),t=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(z,h,w,E),U=this._exporter._textures;if(t.baseColorTextureData){const I=this._exportImage(`baseColor${U.length}`,E,t.baseColorTextureData);j.baseColorTexture=this._exportTextureInfo(I,e,null===z||void 0===z?void 0:z.coordinatesIndex)}if(t.metallicRoughnessTextureData){const I=this._exportImage(`metallicRoughness${U.length}`,E,t.metallicRoughnessTextureData);j.metallicRoughnessTexture=this._exportTextureInfo(I,e,null===h||void 0===h?void 0:h.coordinatesIndex)}return t}return this._convertSpecularGlossinessToMetallicRoughness(w)}async exportPBRMaterialAsync(I,E,j){const e={},w={name:I.name},z=I.isMetallicWorkflow();if(z){const E=I._albedoColor,j=I.alpha;E&&(e.baseColorFactor=[E.r,E.g,E.b,j])}const h=z?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(I,E,e,j):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(I,E,e,j);await this._setMetallicRoughnessPbrMaterialAsync(h,I,w,e,E,j),await this._finishMaterialAsync(w,I,E);const t=this._exporter._materials;return t.push(w),t.length-1}async _setMetallicRoughnessPbrMaterialAsync(I,E,j,e,z,h){if(H(j,E),I.baseColor.equalsWithEpsilon(l,y)&&q.WithinEpsilon(E.alpha,1,y)||(e.baseColorFactor=[I.baseColor.r,I.baseColor.g,I.baseColor.b,E.alpha]),null!=I.metallic&&1!==I.metallic&&(e.metallicFactor=I.metallic),null!=I.roughness&&1!==I.roughness&&(e.roughnessFactor=I.roughness),null==E.tz||E.tz||(E._twoSidedLighting||w.Tools.Warn(E.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),j.doubleSided=!0),h){const I=[],e=E._bumpTexture;e&&I.push(this.exportTextureAsync(e,z).then((I=>{I&&(j.normalTexture=I,1!==e.level&&(j.normalTexture.scale=e.level))})));const w=E._ambientTexture;w&&I.push(this.exportTextureAsync(w,z).then((I=>{if(I){const e={index:I.index,texCoord:I.texCoord,extensions:I.extensions};j.occlusionTexture=e;const w=E._ambientTextureStrength;w&&(e.strength=w)}})));const h=E._emissiveTexture;h&&I.push(this.exportTextureAsync(h,z).then((I=>{I&&(j.emissiveTexture=I)}))),I.length>0&&(this._exporter._materialNeedsUVsSet.add(E),await Promise.all(I))}const t=E._emissiveColor;t.equalsWithEpsilon(i,y)||(j.emissiveFactor=t.re()),j.pbrMetallicRoughness=e}_getPixelsFromTextureAsync(I){return function(I){switch(I){case Q.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case Q.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case Q.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case Q.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case Q.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case Q.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case Q.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case Q.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case Q.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case Q.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case Q.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case Q.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case Q.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case Q.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case Q.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case Q.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case Q.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case Q.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Q.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Q.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case Q.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(I.textureFormat)?(0,x.k)(I,I._texture.width,I._texture.height):(I.textureType,Q.b.TEXTURETYPE_UNSIGNED_BYTE,I.readPixels())}async exportTextureAsync(I,E){const j=this._exporter._extensionsPreExportTextureAsync("exporter",I,E);return j?await j.then((async j=>j?await this._exportTextureInfoAsync(j,E):await this._exportTextureInfoAsync(I,E))):await this._exportTextureInfoAsync(I,E)}async _exportTextureInfoAsync(I,E){let j=this._textureMap.get(I);if(!j){const e=await this._getPixelsFromTextureAsync(I);if(!e)return null;const z=this._exportTextureSampler(I),h=I.mimeType;if(h)switch(h){case"image/jpeg":case"image/png":case"image/webp":E=h;break;default:w.Tools.Warn(`Unsupported media type: ${h}. Exporting texture as PNG.`)}const t=this._internalTextureToImage,U=I.getInternalTexture().uniqueId;t[U]||(t[U]={});let R=t[U][E];if(void 0===R){const j=I.getSize();R=(async()=>{const w=await this._getImageDataAsync(e,j.width,j.height,E);return this._exportImage(I.name,E,w)})(),t[U][E]=R}j=this._exportTextureInfo(await R,z,I.coordinatesIndex),this._textureMap.set(I,j),this._exporter._extensionsPostExportTextures("exporter",j,I)}return j}_exportImage(I,E,j){const e=this._exporter._images;let z;if(this._exporter._shouldUseGlb){z={name:I,mimeType:E,bufferView:void 0};const e=this._exporter._bufferManager.createBufferView(new Uint8Array(j));this._exporter._bufferManager.setBufferView(z,e)}else{const h=I.replace(/\.\/|\/|\.\\|\\/g,"_"),t=function(I){switch(I){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(E);let U=h+t;e.some((I=>I.uri===U))&&(U=`${h}_${w.Tools.RandomId()}${t}`),z={name:I,uri:U},this._exporter._imageData[U]={data:j,mimeType:E}}return e.push(z),e.length-1}_exportTextureInfo(I,E,j){const e=this._exporter._textures;let w=e.findIndex((j=>j.sampler==E&&j.source===I));-1===w&&(w=e.length,e.push({source:I,sampler:E}));const z={index:w};return j&&(z.texCoord=j),z}_exportTextureSampler(I){const E=this._getTextureSampler(I),j=this._exporter._samplers,e=j.findIndex((I=>I.minFilter===E.minFilter&&I.magFilter===E.magFilter&&I.wrapS===E.wrapS&&I.wrapT===E.wrapT));return-1!==e?e:(j.push(E),j.length-1)}}var T=j(11210),M=j(10974),W=j(11598),O=j(11120);const s=e.LE.Zero(),v=e.Quaternion.Identity(),V=e.LE.One(),f=new e.LE(-1,1,1);function S(I,E){const{byteOffset:j,byteStride:e,type:w,normalized:z}=I,h=I.getSize(),t=E.reduce(((I,E)=>E.getTotalVertices()>I?E.getTotalVertices():I),-Number.MAX_VALUE);return{byteOffset:j,byteStride:e,componentCount:h,type:w,count:t*h,normalized:z,totalVertices:t,kind:I.getKind()}}function B(I){switch(I){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function p(I){switch(I){case P.e.PositionKind:case P.e.NormalKind:case P.e.TangentKind:case P.e.ColorKind:case P.e.MatricesIndicesKind:case P.e.MatricesIndicesExtraKind:case P.e.MatricesWeightsKind:case P.e.MatricesWeightsExtraKind:case P.e.UVKind:case P.e.UV2Kind:case P.e.UV3Kind:case P.e.UV4Kind:case P.e.UV5Kind:case P.e.UV6Kind:return!0}return!1}function D(I){switch(I){case z.c.TriangleFillMode:return 4;case z.c.TriangleStripDrawMode:return 5;case z.c.TriangleFanDrawMode:return 6;case z.c.PointListDrawMode:case z.c.PointFillMode:return 0;case z.c.LineLoopDrawMode:return 2;case z.c.LineListDrawMode:return 1;case z.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${I}`)}function k(I){const E=Math.sqrt(I.x*I.x+I.y*I.y+I.z*I.z);E>0&&(I.x/=E,I.y/=E,I.z/=E)}function J(I){return I.x*=-1,I}function N(I){if(I.x*I.x+I.y*I.y>.5){const E=Math.abs(I.x),j=Math.abs(I.y);if(E>j){const j=Math.sign(I.x);I.x=E,I.y*=-j,I.z*=-j,I.w*=j}else{const E=Math.sign(I.y);I.x*=-E,I.y=j,I.z*=E,I.w*=-E}}else{const E=Math.abs(I.z),j=Math.abs(I.w);if(E>j){const j=Math.sign(I.z);I.x*=-j,I.y*=j,I.z=E,I.w*=-j}else{const E=Math.sign(I.w);I.x*=E,I.y*=-E,I.z*=-E,I.w=j}}return I}function m(I){I.nz(-I.z,I.w,I.x,-I.y)}function II(I,E){const j=e.LE.FromArrayToRef(E.translation||[0,0,0],0,e.TmpVectors.LE[0]),w=e.Quaternion.FromArrayToRef(E.rotation||[0,0,0,1],0,e.TmpVectors.Quaternion[0]),z=e.Matrix.ComposeToRef(V,w,j,e.TmpVectors.Matrix[0]),h=e.LE.FromArrayToRef(I.translation||[0,0,0],0,e.TmpVectors.LE[2]),t=e.Quaternion.FromArrayToRef(I.rotation||[0,0,0,1],0,e.TmpVectors.Quaternion[1]),U=e.Matrix.ComposeToRef(V,t,h,e.TmpVectors.Matrix[1]);z.multiplyToRef(U,U),U.decompose(void 0,w,j),j.equalsWithEpsilon(s,O.b)?delete E.translation:E.translation=j.re(),w.equalsWithEpsilon(v,O.b)?delete E.rotation:E.rotation=w.re(),E.scale&&delete E.scale}function EI(I,E){if(!(E instanceof o.b))return!1;if(!(1===E.getChildren().length&&0===I.getChildren().length&&I.parent===E))return!1;const j=I.GI(),e=I instanceof W.c&&!j.useRightHandedSystem?f:V;return!!E.pz.equalsWithEpsilon(e,O.b)||(M.b.Warn(`Cannot collapse node ${I.name} into parent node ${E.name} with modified scaling.`),!1)}function jI(I){if(I instanceof Array){const E=new Float32Array(I);return new Uint8Array(E.buffer,E.byteOffset,E.byteLength)}return ArrayBuffer.isView(I)?new Uint8Array(I.buffer,I.byteOffset,I.byteLength):new Uint8Array(I)}function eI(I,E){for(const[j,e]of Object.entries(I)){const w=E[j];(Array.isArray(e)&&Array.isArray(w)&&wI(e,w)||e===w)&&delete I[j]}return I}function wI(I,E){return I.length===E.length&&I.every(((I,j)=>I===E[j]))}const zI=e.Matrix.Compose(new e.LE(-1,1,1),e.Quaternion.Identity(),e.LE.Zero());function hI(I,E){if(!(I instanceof o.b))return!1;if(E){if(!I.getWorldMatrix().equalsWithEpsilon(e.Matrix.IdentityReadOnly,O.b))return!1}else{if(!I.getWorldMatrix().multiplyToRef(zI,e.TmpVectors.Matrix[0]).equalsWithEpsilon(e.Matrix.IdentityReadOnly,O.b))return!1}return!(I instanceof Z.c&&I.Je)}const tI=new Map([[Int8Array,(I,E,j)=>I.setInt8(E,j)],[Uint8Array,(I,E,j)=>I.setUint8(E,j)],[Uint8ClampedArray,(I,E,j)=>I.setUint8(E,j)],[Int16Array,(I,E,j)=>I.setInt16(E,j,!0)],[Uint16Array,(I,E,j)=>I.setUint16(E,j,!0)],[Int32Array,(I,E,j)=>I.setInt32(E,j,!0)],[Uint32Array,(I,E,j)=>I.setUint32(E,j,!0)],[Float32Array,(I,E,j)=>I.setFloat32(E,j,!0)],[Float64Array,(I,E,j)=>I.setFloat64(E,j,!0)]]);class UI{writeTypedArray(I){this._checkGrowBuffer(I.byteLength);const E=tI.get(I.constructor);for(let j=0;j<I.length;j++)E(this._dataView,this._byteOffset,I[j]),this._byteOffset+=I.BYTES_PER_ELEMENT}constructor(I){this._data=new Uint8Array(I),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(I){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,I),this._byteOffset++}writeInt8(I){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,I),this._byteOffset++}writeInt16(I){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,I,!0),this._byteOffset+=2}writeUInt16(I){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,I,!0),this._byteOffset+=2}writeInt32(I){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,I,!0),this._byteOffset+=4}writeUInt32(I){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,I,!0),this._byteOffset+=4}writeFloat32(I){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,I,!0),this._byteOffset+=4}writeFloat64(I){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,I,!0),this._byteOffset+=8}_checkGrowBuffer(I){const E=this.byteOffset+I;if(E>this._data.byteLength){const I=new Uint8Array(2*E);I.set(this._data),this._data=I,this._dataView=new DataView(this._data.buffer)}}}function RI(I){return I%4===0?4:I%2===0?2:1}class PI{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(I){let E=0;this._bufferViewToData.forEach((I=>{E+=I.byteLength}));const j=new UI(E),e=Array.from(this._bufferViewToData.keys()).sort(((I,E)=>RI(E.byteLength)-RI(I.byteLength)));for(const w of e){w.byteOffset=j.byteOffset,I.push(w);const E=I.length-1,e=this.getPropertiesWithBufferView(w);for(const I of e)I.bufferView=E;j.writeTypedArray(this._bufferViewToData.get(w)),this._bufferViewToData.delete(w)}return j.getOutputData()}createBufferView(I,E){const j={buffer:0,byteOffset:void 0,byteLength:I.byteLength,byteStride:E};return this._bufferViewToData.set(j,I),j}createAccessor(I,E,j,e,w,z,h){this._verifyBufferView(I);const t={bufferView:void 0,componentType:j,count:e,type:E,min:null===z||void 0===z?void 0:z.min,max:null===z||void 0===z?void 0:z.max,normalized:h,byteOffset:w};return this.setBufferView(t,I),this._accessorToBufferView.set(t,I),t}setBufferView(I,E){this._verifyBufferView(E);this.getPropertiesWithBufferView(E).push(I)}removeBufferView(I){const E=this.getPropertiesWithBufferView(I);for(const j of E)void 0!==j.bufferView&&delete j.bufferView;this._bufferViewToData.delete(I),this._bufferViewToProperties.delete(I),this._accessorToBufferView.forEach(((E,j)=>{E===I&&(void 0!==j.byteOffset&&delete j.byteOffset,this._accessorToBufferView.delete(j))}))}getBufferView(I){const E=this._accessorToBufferView.get(I);return this._verifyBufferView(E),E}getPropertiesWithBufferView(I){return this._verifyBufferView(I),this._bufferViewToProperties.set(I,this._bufferViewToProperties.get(I)??[]),this._bufferViewToProperties.get(I)}getData(I){return this._verifyBufferView(I),this._bufferViewToData.get(I)}_verifyBufferView(I){if(void 0===I||!this._bufferViewToData.has(I))throw new Error(`BufferView ${I} not found in BufferManager.`)}}var oI,ZI=j(11564),cI=j(11585),KI=j(11600),LI=j(11480),FI=j(11637),CI=j(11648),XI=j(11562),qI=j(11652);!function(I){I[I.INTANGENT=0]="INTANGENT",I[I.OUTTANGENT=1]="OUTTANGENT"}(oI||(oI={}));class xI{static _IsTransformable(I){return I&&(I instanceof o.b||I instanceof ZI.e||I instanceof qI.c)}static _CreateNodeAnimation(I,E,j,e,z){if(this._IsTransformable(I)){const h=[],t=[],U=E.getKeys(),R=xI._CalculateMinMaxKeyFrames(U),P=xI._DeduceInterpolation(U,j,e),o=P.interpolationType,Z=P.shouldBakeAnimation;if(Z?xI._CreateBakedAnimation(I,E,j,R.min,R.max,E.framePerSecond,z,h,t,R,e):"LINEAR"===o||"STEP"===o?xI._CreateLinearOrStepAnimation(I,E,j,h,t,e):"CUBICSPLINE"===o?xI._CreateCubicSplineAnimation(I,E,j,h,t,e):xI._CreateBakedAnimation(I,E,j,R.min,R.max,E.framePerSecond,z,h,t,R,e),h.length&&t.length){return{inputs:h,outputs:t,samplerInterpolation:o,inputsMin:Z?R.min:w.Tools.FloatRound(R.min/E.framePerSecond),inputsMax:Z?R.max:w.Tools.FloatRound(R.max/E.framePerSecond)}}}return null}static _DeduceAnimationInfo(I){let E=null,j="VEC3",e=!1;const z=I.targetProperty.split(".");switch(z[0]){case"pz":E="scale";break;case"position":E="translation";break;case"rotation":j="VEC4",E="rotation";break;case"rotationQuaternion":j="VEC4",e=!0,E="rotation";break;case"influence":j="SCALAR",E="weights";break;default:w.Tools.Error(`Unsupported animatable property ${z[0]}`)}return E?{animationChannelTargetPath:E,dataAccessorType:j,useQuaternion:e}:(w.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(I,E,j,e,w,z,h,t,U,R,P){let o;if(xI._IsTransformable(I)&&I.animations)for(const Z of I.animations){if(P&&!P(Z))continue;const w=xI._DeduceAnimationInfo(Z);w&&(o={name:Z.name,samplers:[],channels:[]},xI._AddAnimation(`${Z.name}`,Z.hasRunningRuntimeAnimations?E:o,I,Z,w.dataAccessorType,w.animationChannelTargetPath,e,z,h,t,w.useQuaternion,U,R),o.samplers.length&&o.channels.length&&j.push(o))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(I,E,j,e,w,z,h,t,U,R,P){let o;if(I instanceof XI.d){const w=I.morphTargetManager;if(w)for(let Z=0;Z<w.numTargets;++Z){const c=w.getTarget(Z);for(const K of c.animations){if(P&&!P(K))continue;const c=new FI.c(`${K.name}`,"influence",K.framePerSecond,K.dataType,K.loopMode,K.enableBlending),L=[],F=K.getKeys();for(let I=0;I<F.length;++I){const E=F[I];for(let I=0;I<w.numTargets;++I)I==Z?L.push(E):L.push({frame:E.frame,value:0})}c.setKeys(L);const C=xI._DeduceAnimationInfo(c);C&&(o={name:c.name,samplers:[],channels:[]},xI._AddAnimation(K.name,K.hasRunningRuntimeAnimations?E:o,I,c,C.dataAccessorType,C.animationChannelTargetPath,e,z,h,t,C.useQuaternion,U,R,w.numTargets),o.samplers.length&&o.channels.length&&j.push(o))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(I,E,j,e,w,z,h,t,U){let R;if(I.animationGroups){const o=I.animationGroups;for(const Z of o){const o=new Map,c=new Map,K=new Set,L=Z.to-Z.from;R={name:Z.name,channels:[],samplers:[]};for(let E=0;E<Z.targetedAnimations.length;++E){const L=Z.targetedAnimations[E],F=L.target,C=L.animation;if(U&&!U(C))continue;const X=t.has(F);if(this._IsTransformable(F)||1===F.length&&this._IsTransformable(F[0])){const I=xI._DeduceAnimationInfo(L.animation);if(I){const E=this._IsTransformable(F)?F:this._IsTransformable(F[0])?F[0]:null;E&&xI._AddAnimation(`${C.name}`,R,E,C,I.dataAccessorType,I.animationChannelTargetPath,j,e,w,z,I.useQuaternion,h,X)}}else if(F instanceof CI.c||1===F.length&&F[0]instanceof CI.c){if(xI._DeduceAnimationInfo(L.animation)){const E=F instanceof CI.c?F:F[0];if(E){const j=I.morphTargetManagers.find((I=>{for(let j=0;j<I.numTargets;++j)if(I.getTarget(j)===E)return!0;return!1}));if(j){const e=I.meshes.find((I=>I.morphTargetManager===j));var P;if(e)o.has(e)||o.set(e,new Map),null===(P=o.get(e))||void 0===P||P.set(E,C),K.add(e),c.set(e,C)}}}}}K.forEach((I=>{const E=I.morphTargetManager;let t=null;const U=[],P=c.get(I).getKeys(),K=P.length;for(let j=0;j<K;++j)for(let e=0;e<E.numTargets;++e){const w=E.getTarget(e),z=o.get(I);if(z){const E=z.get(w);E?(t||(t=new FI.c(`${Z.name}_${I.name}_MorphWeightAnimation`,"influence",E.framePerSecond,FI.c.ANIMATIONTYPE_FLOAT,E.loopMode,E.enableBlending)),U.push(E.getKeys()[j])):U.push({frame:Z.from+L/K*j,value:w.influence,inTangent:P[0].inTangent?0:void 0,outTangent:P[0].outTangent?0:void 0})}}t.setKeys(U);const F=xI._DeduceAnimationInfo(t);F&&xI._AddAnimation(`${Z.name}_${I.name}_MorphWeightAnimation`,R,I,t,F.dataAccessorType,F.animationChannelTargetPath,j,e,w,z,F.useQuaternion,h,!1,null===E||void 0===E?void 0:E.numTargets)})),R.channels.length&&R.samplers.length&&E.push(R)}}}static _AddAnimation(I,E,j,w,z,h,t,U,R,P,o,Z,c,K){const L=xI._CreateNodeAnimation(j,w,h,o,Z);let F,C,X,q,x,u;if(L){if(K){let I=0,E=0;const j=[];for(;L.inputs.length>0;)E=L.inputs.shift(),I%K==0&&j.push(E),I++;L.inputs=j}const I=t.get(j),w=new Float32Array(L.inputs);F=U.createBufferView(w),C=U.createAccessor(F,"SCALAR",5126,L.inputs.length,void 0,{min:[L.inputsMin],max:[L.inputsMax]}),P.push(C),X=P.length-1;const R=new e.Quaternion,o=new e.LE,Z=new e.LE,b=j instanceof ZI.e,Q=B(z),G=new Float32Array(L.outputs.length*Q);L.outputs.forEach((function(I,E){let j=I;switch(h){case"translation":c&&(e.LE.FromArrayToRef(I,0,Z),J(Z),Z.toArray(j));break;case"rotation":4===I.length?e.Quaternion.FromArrayToRef(I,0,R):(j=new Array(4),e.LE.FromArrayToRef(I,0,o),e.Quaternion.FromEulerVectorToRef(o,R)),c&&(N(R),b&&m(R)),R.toArray(j)}G.set(j,E*Q)})),F=U.createBufferView(G),C=U.createAccessor(F,z,5126,L.outputs.length),P.push(C),q=P.length-1,x={interpolation:L.samplerInterpolation,input:X,output:q},E.samplers.push(x),u={sampler:E.samplers.length-1,target:{node:I,path:h}},E.channels.push(u)}}static _CreateBakedAnimation(I,E,j,z,h,t,U,R,P,o,Z){let c;const K=e.Quaternion.Identity();let L,F=null,C=null,X=null,q=null,x=null,u=null;o.min=w.Tools.FloatRound(z/t);const b=E.getKeys();for(let e=0,Q=b.length;e<Q;++e){if(u=null,X=b[e],e+1<Q)if(q=b[e+1],X.value.equals&&X.value.equals(q.value)||X.value===q.value){if(0!==e)continue;u=X.frame}else u=q.frame;else{if(x=b[e-1],X.value.equals&&X.value.equals(x.value)||X.value===x.value)continue;u=h}if(u)for(let e=X.frame;e<=u;e+=U){if(L=w.Tools.FloatRound(e/t),L===F)continue;F=L,C=L;const z={key:0,repeatCount:0,loopMode:E.loopMode};c=E._interpolate(e,z),xI._SetInterpolatedValue(I,c,L,E,j,K,R,P,Z)}}C&&(o.max=C)}static _ConvertFactorToVector3OrQuaternion(I,E,j,z,h){const t=xI._GetBasePositionRotationOrScale(E,z,h),U=j.targetProperty.split("."),R=U?U[1]:"",P=h?e.Quaternion.xE(t).normalize():e.LE.xE(t);switch(R){case"x":case"y":case"z":P[R]=I;break;case"w":P.w=I;break;default:w.Tools.Error(`glTFAnimation: Unsupported component name "${R}"!`)}return P}static _SetInterpolatedValue(I,E,j,w,z,h,t,U,R){let P;t.push(j),"weights"!==z?(w.dataType===FI.c.ANIMATIONTYPE_FLOAT&&(E=this._ConvertFactorToVector3OrQuaternion(E,I,w,z,R)),"rotation"===z?(R?h=E:(P=E,e.Quaternion.RotationYawPitchRollToRef(P.y,P.x,P.z,h)),U.push(h.re())):(P=E,U.push(P.re()))):U.push([E])}static _CreateLinearOrStepAnimation(I,E,j,e,w,z){for(const h of E.getKeys())e.push(h.frame/E.framePerSecond),xI._AddKeyframeValue(h,E,w,j,I,z)}static _CreateCubicSplineAnimation(I,E,j,e,w,z){E.getKeys().forEach((function(h){e.push(h.frame/E.framePerSecond),xI._AddSplineTangent(oI.INTANGENT,w,j,"CUBICSPLINE",h,z),xI._AddKeyframeValue(h,E,w,j,I,z),xI._AddSplineTangent(oI.OUTTANGENT,w,j,"CUBICSPLINE",h,z)}))}static _GetBasePositionRotationOrScale(I,E,j){let w;if("rotation"===E)if(j){w=(I.rotationQuaternion??e.Quaternion.Identity()).re()}else{w=(I.rotation??e.LE.Zero()).re()}else if("translation"===E){w=(I.position??e.LE.Zero()).re()}else{w=(I.pz??e.LE.One()).re()}return w}static _AddKeyframeValue(I,E,j,z,h,t){let U;const R=E.dataType;if(R===FI.c.ANIMATIONTYPE_VECTOR3){let E=I.value.re();if("rotation"===z){const I=e.LE.xE(E);E=e.Quaternion.RotationYawPitchRoll(I.y,I.x,I.z).re()}j.push(E)}else if(R===FI.c.ANIMATIONTYPE_FLOAT){if("weights"===z)j.push([I.value]);else if(U=this._ConvertFactorToVector3OrQuaternion(I.value,h,E,z,t),U){if("rotation"===z){const I=t?U:e.Quaternion.RotationYawPitchRoll(U.y,U.x,U.z).normalize();j.push(I.re())}j.push(U.re())}}else R===FI.c.ANIMATIONTYPE_QUATERNION?j.push(I.value.normalize().re()):w.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(I,E,j){let e,w,z=!1;if("rotation"===E&&!j)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let h=0,t=I.length;h<t;++h)if(w=I[h],w.inTangent||w.outTangent)if(e){if("CUBICSPLINE"!==e){e="LINEAR",z=!0;break}}else e="CUBICSPLINE";else if(e){if("CUBICSPLINE"===e||w.interpolation&&1===w.interpolation&&"STEP"!==e){e="LINEAR",z=!0;break}}else e=w.interpolation&&1===w.interpolation?"STEP":"LINEAR";return e||(e="LINEAR"),{interpolationType:e,shouldBakeAnimation:z}}static _AddSplineTangent(I,E,j,w,z,h){let t;const U=I===oI.INTANGENT?z.inTangent:z.outTangent;if("CUBICSPLINE"===w){if("rotation"===j)if(U)if(h)t=U.re();else{const I=U;t=e.Quaternion.RotationYawPitchRoll(I.y,I.x,I.z).re()}else t=[0,0,0,0];else t="weights"===j?U?[U]:[0]:U?U.re():[0,0,0];E.push(t)}}static _CalculateMinMaxKeyFrames(I){let E=1/0,j=-1/0;return I.forEach((function(I){E=Math.min(E,I.frame),j=Math.max(j,I.frame)})),{min:E,max:j}}}function uI(I,E,j,z,h,t){const U={attributes:{},influence:I.influence,name:I.name},R=E.Je;if(!R)return w.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),U;const o=t?-1:1,Z=e.LE.Zero();let c=0,K=0;if(I.hasPositions){const z=I.getPositions(),t=R.getVerticesData(P.e.PositionKind);if(t){const I=new Float32Array(t.length),E=[1/0,1/0,1/0],w=[-1/0,-1/0,-1/0];K=t.length/3,c=0;for(let j=c;j<K;++j){const h=e.LE.xE(t,3*j);e.LE.xE(z,3*j).subtractToRef(h,Z),Z.x*=o,E[0]=Math.min(E[0],Z.x),w[0]=Math.max(w[0],Z.x),E[1]=Math.min(E[1],Z.y),w[1]=Math.max(w[1],Z.y),E[2]=Math.min(E[2],Z.z),w[2]=Math.max(w[2],Z.z),I[3*j]=Z.x,I[3*j+1]=Z.y,I[3*j+2]=Z.z}const R=j.createBufferView(I,12),P=j.createAccessor(R,"VEC3",5126,z.length/3,0,{min:E,max:w});h.push(P),U.attributes.POSITION=h.length-1}else w.Tools.Warn(`Morph target positions for mesh ${E.name} were not exported. Mesh does not have position vertex data`)}if(I.hasNormals){const z=I.getNormals(),t=R.getVerticesData(P.e.NormalKind);if(t){const I=new Float32Array(t.length);K=t.length/3,c=0;for(let j=c;j<K;++j){const E=e.LE.xE(t,3*j).normalize();e.LE.xE(z,3*j).normalize().subtractToRef(E,Z),I[3*j]=Z.x*o,I[3*j+1]=Z.y,I[3*j+2]=Z.z}const E=j.createBufferView(I,12),w=j.createAccessor(E,"VEC3",5126,z.length/3,0);h.push(w),U.attributes.NORMAL=h.length-1}else w.Tools.Warn(`Morph target normals for mesh ${E.name} were not exported. Mesh does not have normals vertex data`)}if(I.hasTangents){const z=I.getTangents(),t=R.getVerticesData(P.e.TangentKind);if(t){K=t.length/4;const I=new Float32Array(3*K);c=0;for(let j=c;j<K;++j){const E=e.LE.xE(t,4*j);k(E);const w=e.LE.xE(z,3*j);k(w),w.subtractToRef(E,Z),I[3*j]=Z.x*o,I[3*j+1]=Z.y,I[3*j+2]=Z.z}const E=j.createBufferView(I,12),w=j.createAccessor(E,"VEC3",5126,K,0);h.push(w),U.attributes.TANGENT=h.length-1}else w.Tools.Warn(`Morph target tangents for mesh ${E.name} were not exported. Mesh does not have tangents vertex data`)}if(I.hasColors){const z=I.getColors(),t=R.getVerticesData(P.e.ColorKind),o=R.getVertexBuffer(P.e.ColorKind);if(t&&o){const I=o.getSize();K=t.length/I;const E=new Float32Array(K*I);c=0;for(let j=c;j<K;++j)if(3===I){const w=e.LE.xE(t,j*I);e.LE.xE(z,j*I).subtractToRef(w,Z),E[3*j]=Z.x,E[3*j+1]=Z.y,E[3*j+2]=Z.z}else if(4===I){const w=new e.Vector4,h=e.Vector4.xE(t,j*I);e.Vector4.xE(z,j*I).subtractToRef(h,w),E[4*j]=w.x,E[4*j+1]=w.y,E[4*j+2]=w.z,E[4*j+3]=w.w}else w.Tools.Warn(`Unsupported number of components for color attribute: ${I}`);const R=j.createBufferView(E,4*I),P=j.createAccessor(R,3===I?"VEC3":"VEC4",5126,K,0);h.push(P),U.attributes.COLOR_0=h.length-1}else w.Tools.Warn(`Morph target colors for mesh ${E.name} were not exported. Mesh does not have colors vertex data`)}return U}var bI=j(11654),QI=j(11508),GI=j(11491),yI=j(11073);class dI{}dI.DEFAULT_COLOR=F.qE.White(),dI.DEFAULT_WIDTH_ATTENUATED=1,dI.DEFAULT_WIDTH=.1;var aI=j(11337),lI=j(11656);class iI{static ConvertPoints(I,E){if(I.length&&Array.isArray(I)&&"number"===typeof I[0])return[I];if(I.length&&Array.isArray(I[0])&&"number"===typeof I[0][0])return I;if(I.length&&!Array.isArray(I[0])&&I[0]instanceof e.LE){const E=[];for(let j=0;j<I.length;j++){const e=I[j];E.push(e.x,e.y,e.z)}return[E]}if(I.length>0&&Array.isArray(I[0])&&I[0].length>0&&I[0][0]instanceof e.LE){const E=[],j=I;for(const I of j)E.push(I.flatMap((I=>[I.x,I.y,I.z])));return E}if(I instanceof Float32Array){if(null!==E&&void 0!==E&&E.floatArrayStride){const j=[],e=3*E.floatArrayStride;for(let E=0;E<I.length;E+=e){const w=new Array(e);for(let j=0;j<e;j++)w[j]=I[E+j];j.push(w)}return j}return[Array.from(I)]}if(I.length&&I[0]instanceof Float32Array){const E=[];for(const j of I)E.push(Array.from(j));return E}return[]}static OmitZeroLengthPredicate(I,E,j){const e=[];return E.FE(I).lengthSquared()>0&&e.push([I,E]),j.FE(E).lengthSquared()>0&&e.push([E,j]),I.FE(j).lengthSquared()>0&&e.push([j,I]),0===e.length?null:e}static OmitDuplicatesPredicate(I,E,j,e){const w=[];return iI._SearchInPoints(I,E,e)||w.push([I,E]),iI._SearchInPoints(E,j,e)||w.push([E,j]),iI._SearchInPoints(j,I,e)||w.push([j,I]),0===w.length?null:w}static _SearchInPoints(I,E,j){for(const h of j)for(let j=0;j<h.length;j++){var e,w,z;if(null!==(e=h[j])&&void 0!==e&&e.equals(I))if(null!==(w=h[j+1])&&void 0!==w&&w.equals(E)||null!==(z=h[j-1])&&void 0!==z&&z.equals(E))return!0}return!1}static MeshesToLines(I,E){const j=[];for(let w=0;w<I.length;w++){const z=I[w],h=z.getVerticesData(P.e.PositionKind),t=z.me();if(h&&t)for(let I=0,U=0;I<t.length;I++){const R=3*t[U++],P=3*t[U++],o=3*t[U++],Z=new e.LE(h[R],h[R+1],h[R+2]),c=new e.LE(h[P],h[P+1],h[P+2]),K=new e.LE(h[o],h[o+1],h[o+2]);if(E){const e=E(Z,c,K,j,I,R,z,w,h,t);if(e)for(const I of e)j.push(I)}else j.push([Z,c],[c,K],[K,Z])}}return j}static ToVector3Array(I){if(Array.isArray(I[0])){const E=[],j=I;for(const I of j){const j=[];for(let E=0;E<I.length;E+=3)j.push(new e.LE(I[E],I[E+1],I[E+2]));E.push(j)}return E}const E=I,j=[];for(let w=0;w<E.length;w+=3)j.push(new e.LE(E[w],E[w+1],E[w+2]));return j}static ToNumberArray(I){return I.flatMap((I=>[I.x,I.y,I.z]))}static GetPointsCountInfo(I){const E=new Array(I.length);let j=0;for(let e=I.length;e--;)E[e]=I[e].length/3,j+=E[e];return{total:j,counts:E}}static GetLineLength(I){if(0===I.length)return 0;let E;E="number"===typeof I[0]?iI.ToVector3Array(I):I;const j=e.TmpVectors.LE[0];let w=0;for(let e=0;e<E.length-1;e++){const I=E[e];w+=E[e+1].subtractToRef(I,j).length()}return w}static GetLineLengthArray(I){const E=new Float32Array(I.length/3);let j=0;for(let e=0,w=I.length/3-1;e<w;e++){let w=I[3*e+0],z=I[3*e+1],h=I[3*e+2];w-=I[3*e+3],z-=I[3*e+4],h-=I[3*e+5];j+=Math.sqrt(w*w+z*z+h*h),E[e+1]=j}return E}static SegmentizeSegmentByCount(I,E,j){const w=[],z=E.FE(I),h=e.TmpVectors.LE[0];h.mz(j);const t=e.TmpVectors.LE[1];z.divideToRef(h,t);let U=I.clone();w.push(U);for(let e=0;e<j;e++)U=U.clone(),w.push(U.addInPlace(t));return w}static SegmentizeLineBySegmentLength(I,E){const j=I[0]instanceof e.LE?iI.GetLineSegments(I):"number"===typeof I[0]?iI.GetLineSegments(iI.ToVector3Array(I)):I,w=[];for(const e of j)if(e.length>E){const I=iI.SegmentizeSegmentByCount(e.point1,e.point2,Math.ceil(e.length/E));for(const E of I)w.push(E)}else w.push(e.point1),w.push(e.point2);return w}static SegmentizeLineBySegmentCount(I,E){const j="number"===typeof I[0]?iI.ToVector3Array(I):I,e=iI.GetLineLength(j)/E;return iI.SegmentizeLineBySegmentLength(j,e)}static GetLineSegments(I){const E=[];for(let j=0;j<I.length-1;j++){const e=I[j],w=I[j+1],z=w.FE(e).length();E.push({point1:e,point2:w,length:z})}return E}static GetMinMaxSegmentLength(I){const E=iI.GetLineSegments(I).sort((I=>I.length));return{min:E[0].length,max:E[E.length-1].length}}static GetPositionOnLineByVisibility(I,E,j){let w=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const z=E*j;let h=0,t=0;const U=I.length;for(let e=0;e<U;e++){if(z<=h+I[e].length){t=e;break}h+=I[e].length}const R=(z-h)/I[t].length;return I[t].point2.subtractToRef(I[t].point1,e.TmpVectors.LE[0]),e.TmpVectors.LE[1]=e.TmpVectors.LE[0].multiplyByFloats(R,R,R),w||e.TmpVectors.LE[1].addInPlace(I[t].point1),e.TmpVectors.LE[1].clone()}static GetCircleLinePoints(I,E){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I,z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/E;const h=[];for(let t=0;t<=E;t++)h.push(new e.LE(Math.cos(t*z)*I,Math.sin(t*z)*w,j));return h}static GetBezierLinePoints(I,E,j,e){return aI.h.CreateQuadraticBezier(I,E,j,e).getPoints().flatMap((I=>[I.x,I.y,I.z]))}static GetArrowCap(I,E,j,e,w){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,h=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[I.clone(),I.add(E.multiplyByFloats(j,j,j))],widths:[e,w,z,h]}}static GetPointsFromText(I,E,j,e){let w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const h=[],t=(0,lI.d)(I,E,j,e);for(const U of t){for(const I of U.paths){const E=[],j=I.getPoints();for(const I of j)E.push(I.x,I.y,w);h.push(E)}if(z)for(const I of U.holes){const E=[],j=I.getPoints();for(const I of j)E.push(I.x,I.y,w);h.push(E)}}return h}static Color3toRGBAUint8(I){const E=new Uint8Array(4*I.length);for(let j=0,e=0;j<I.length;j++)E[e++]=255*I[j].r,E[e++]=255*I[j].g,E[e++]=255*I[j].b,E[e++]=255;return E}static CreateColorsTexture(I,E,j,e){const w=e.getEngine().getCaps().maxTextureSize??1,z=E.length>w?w:E.length,h=Math.ceil(E.length/w);h>1&&(E=[...E,...Array(z*h-E.length).fill(E[0])]);const t=iI.Color3toRGBAUint8(E),U=new b.c(t,z,h,K.d.TEXTUREFORMAT_RGBA,e,!1,!0,j);return U.name=I,U}static PrepareEmptyColorsTexture(I){if(!dI.EmptyColorsTexture){const E=new Uint8Array(4);dI.EmptyColorsTexture=new b.c(E,1,1,K.d.TEXTUREFORMAT_RGBA,I,!1,!1,b.c.NEAREST_NEAREST),dI.EmptyColorsTexture.name="grlEmptyColorsTexture"}return dI.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var I;null===(I=dI.EmptyColorsTexture)||void 0===I||I.dispose(),dI.EmptyColorsTexture=null}static BooleanToNumber(I){return I?1:0}}class rI extends GI.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class nI extends QI.c{isCompatible(I){return!0}constructor(I,E,j){var w;j=j||{color:dI.DEFAULT_COLOR};const z=new rI;z.GREASED_LINE_HAS_COLOR=!!j.color&&!j.useColors,z.GREASED_LINE_SIZE_ATTENUATION=j.sizeAttenuation??!1,z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===j.colorDistributionType,z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(E??I.GI()).useRightHandedSystem,z.GREASED_LINE_CAMERA_FACING=j.cameraFacing??!0,super(I,nI.GREASED_LINE_MATERIAL_NAME,200,z,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(w=j)||void 0===w?void 0:w.forceGLSL)||nI.ForceGLSL,this._scene=E??I.GI(),this._engine=this._scene.getEngine(),this._cameraFacing=j.cameraFacing??!0,this.visibility=j.visibility??1,this.useDash=j.useDash??!1,this.dashRatio=j.dashRatio??.5,this.dashOffset=j.dashOffset??0,this.width=j.width?j.width:j.sizeAttenuation?dI.DEFAULT_WIDTH_ATTENUATED:dI.DEFAULT_WIDTH,this._sizeAttenuation=j.sizeAttenuation??!1,this.colorMode=j.colorMode??0,this._color=j.color??null,this.useColors=j.useColors??!1,this._colorsDistributionType=j.colorDistributionType??0,this.colorsSampling=j.colorsSampling??b.c.NEAREST_NEAREST,this._colors=j.lI??null,this.dashCount=j.dashCount??1,this.resolution=j.resolution??new e.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),j.colorsTexture?this.colorsTexture=j.colorsTexture:this._colors?this.colorsTexture=iI.CreateColorsTexture(`${I.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??dI.DEFAULT_COLOR,iI.PrepareEmptyColorsTexture(this._scene)),this._engine.Le.add((()=>{iI.DisposeEmptyColorsTexture()}))}getAttributes(I){I.push("grl_offsets"),I.push("grl_widths"),I.push("grl_colorPointers"),I.push("grl_counters"),this._cameraFacing?(I.push("grl_previousAndSide"),I.push("grl_nextAndCounters")):I.push("grl_slopes")}getSamplers(I){I.push("grl_colors")}getActiveTextures(I){this.colorsTexture&&I.push(this.colorsTexture)}getUniforms(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const E=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&E.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===I&&E.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:E,vertex:this._cameraFacing&&this._isGLSL(I)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(I)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(I){if(this._cameraFacing){I.ve("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||I.ve("viewProjection",this._scene.getTransformMatrix());const E=e.TmpVectors.Vector4[0];E.x=this._aspect,E.y=this._resolution.x,E.z=this._resolution.y,E.w=this.width,I.updateVector4("grl_aspect_resolution_lineWidth",E)}const E=e.TmpVectors.Vector4[0];E.x=iI.BooleanToNumber(this.useDash),E.y=this._dashArray,E.z=this.dashOffset,E.w=this.dashRatio,I.updateVector4("grl_dashOptions",E);const j=e.TmpVectors.Vector4[1];j.x=this.colorMode,j.y=this.visibility,j.z=this.colorsTexture?this.colorsTexture.getSize().width:0,j.w=iI.BooleanToNumber(this.useColors),I.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",j),this._color&&I.updateColor3("grl_singleColor",this._color);const w=this.colorsTexture??dI.EmptyColorsTexture;I.setTexture("grl_colors",w),I.updateFloat2("grl_textureSize",(null===w||void 0===w?void 0:w.getSize().width)??1,(null===w||void 0===w?void 0:w.getSize().height)??1)}prepareDefines(I,E,j){I.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,I.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,I.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,I.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=E.useRightHandedSystem,I.GREASED_LINE_CAMERA_FACING=this._cameraFacing,I.GREASED_LINE_USE_OFFSETS=!!j.offsets}getClassName(){return nI.GREASED_LINE_MATERIAL_NAME}getCustomCode(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(E)?function(I,E){if("vertex"===I){const I={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return E&&(I["!gl_Position\\=viewProjection\\*worldPos;"]="//"),I}return"fragment"===I?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(I,this._cameraFacing):function(I,E){if("vertex"===I){const I={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return E&&(I["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),I}return"fragment"===I?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(I,this._cameraFacing)}dispose(){var I;null===(I=this.colorsTexture)||void 0===I||I.dispose(),super.dispose()}get lI(){return this._colors}set lI(I){this.setColors(I)}setColors(I){var E;let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const w=(null===(E=this._colors)||void 0===E?void 0:E.length)??0;var z;if(this._colors=I,null!==I&&0!==I.length){if(!j||e)if(this.colorsTexture&&w===I.length&&!e){const E=iI.Color3toRGBAUint8(I);this.colorsTexture.update(E)}else{var h;null===(h=this.colorsTexture)||void 0===h||h.dispose(),this.colorsTexture=iI.CreateColorsTexture(`${this._material.name}-colors-texture`,I,this.colorsSampling,this._scene)}}else null===(z=this.colorsTexture)||void 0===z||z.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(I){this._dashCount=I,this._dashArray=1/I}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(I){this._sizeAttenuation=I,this.markAllDefinesAsDirty()}get color(){return this._color}set color(I){this.setColor(I)}setColor(I){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==I||null!==this._color&&null===I?(this._color=I,E||this.markAllDefinesAsDirty()):this._color=I}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(I){this._colorsDistributionType=I,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(I){this._aspect=I.x/I.y,this._resolution=I}serialize(){const I=super.serialize(),E={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(E.lI=this._colors),this._color&&(E.color=this._color),I.greasedLineMaterialOptions=E,I}parse(I,E,j){var e;super.parse(I,E,j);const w=I.greasedLineMaterialOptions;null===(e=this.colorsTexture)||void 0===e||e.dispose(),w.color&&this.setColor(w.color,!0),w.colorDistributionType&&(this.colorsDistributionType=w.colorDistributionType),w.lI&&(this.lI=w.lI),w.colorsSampling&&(this.colorsSampling=w.colorsSampling),w.colorMode&&(this.colorMode=w.colorMode),w.useColors&&(this.useColors=w.useColors),w.visibility&&(this.visibility=w.visibility),w.useDash&&(this.useDash=w.useDash),w.dashCount&&(this.dashCount=w.dashCount),w.dashRatio&&(this.dashRatio=w.dashRatio),w.dashOffset&&(this.dashOffset=w.dashOffset),w.width&&(this.width=w.width),w.sizeAttenuation&&(this.sizeAttenuation=w.sizeAttenuation),w.resolution&&(this.resolution=w.resolution),this.lI?this.colorsTexture=iI.CreateColorsTexture(`${this._material.name}-colors-texture`,this.lI,this.colorsSampling,E):iI.PrepareEmptyColorsTexture(E),this.markAllDefinesAsDirty()}copyTo(I){var E;const j=I;null===(E=j.colorsTexture)||void 0===E||E.dispose(),this._colors&&(j.colorsTexture=iI.CreateColorsTexture(`${j._material.name}-colors-texture`,this._colors,j.colorsSampling,this._scene)),j.setColor(this.color,!0),j.colorsDistributionType=this.colorsDistributionType,j.colorsSampling=this.colorsSampling,j.colorMode=this.colorMode,j.useColors=this.useColors,j.visibility=this.visibility,j.useDash=this.useDash,j.dashCount=this.dashCount,j.dashRatio=this.dashRatio,j.dashOffset=this.dashOffset,j.width=this.width,j.sizeAttenuation=this.sizeAttenuation,j.resolution=this.resolution,j.markAllDefinesAsDirty()}_isGLSL(I){return 0===I||this._forceGLSL}}nI.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",nI.ForceGLSL=!1,(0,yI.h)(`BABYLON.${nI.GREASED_LINE_MATERIAL_NAME}`,nI);var HI=j(11542),gI=j(10978),YI=j(11356),AI=j(11060);class TI extends YI.ShaderMaterial{constructor(I,E,w){const z=E.getEngine(),h=z.isWebGPU&&!(w.forceGLSL||TI.ForceGLSL),t=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];E.useRightHandedSystem&&t.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const U=["position","grl_widths","grl_offsets","grl_colorPointers"];w.cameraFacing?(t.push("GREASED_LINE_CAMERA_FACING"),U.push("grl_previousAndSide","grl_nextAndCounters")):(U.push("grl_slopes"),U.push("grl_counters"));const R=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(h||R.push("world","viewProjection","view","projection"),super(I,E,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:h?["Scene","Mesh"]:void 0,attributes:U,uniforms:R,samplers:h?[]:["grlColors"],defines:t,extraInitializationsAsync:async()=>{h?await Promise.all([j.e(66).then(j.bind(j,14260)),j.e(75).then(j.bind(j,14265))]):await Promise.all([j.e(69).then(j.bind(j,14267)),j.e(76).then(j.bind(j,14276))])},shaderLanguage:h?1:0}),this._color=F.qE.White(),this._colorsDistributionType=0,this._colorsTexture=null,w=w||{color:dI.DEFAULT_COLOR},this.visibility=w.visibility??1,this.useDash=w.useDash??!1,this.dashRatio=w.dashRatio??.5,this.dashOffset=w.dashOffset??0,this.dashCount=w.dashCount??1,this.width=w.width?w.width:w.sizeAttenuation&&w.cameraFacing?dI.DEFAULT_WIDTH_ATTENUATED:dI.DEFAULT_WIDTH,this.sizeAttenuation=w.sizeAttenuation??!1,this.color=w.color??F.qE.White(),this.useColors=w.useColors??!1,this.colorsDistributionType=w.colorDistributionType??0,this.colorsSampling=w.colorsSampling??b.c.NEAREST_NEAREST,this.colorMode=w.colorMode??0,this._colors=w.lI??null,this._cameraFacing=w.cameraFacing??!0,this.resolution=w.resolution??new e.Vector2(z.getRenderWidth(),z.getRenderHeight()),w.colorsTexture?this.colorsTexture=w.colorsTexture:this._colors?this.colorsTexture=iI.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,E):(this._color=this._color??dI.DEFAULT_COLOR,this.colorsTexture=iI.PrepareEmptyColorsTexture(E)),h){const I=new AI.d;I.setParameters(),I.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",I)}z.Le.add((()=>{iI.DisposeEmptyColorsTexture()}))}dispose(){var I;null===(I=this._colorsTexture)||void 0===I||I.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new e.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get lI(){return this._colors}set lI(I){this.setColors(I)}setColors(I){var E;let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const w=(null===(E=this._colors)||void 0===E?void 0:E.length)??0;var z;if(this._colors=I,null!==I&&0!==I.length){if(!j||e)if(this._colorsTexture&&w===I.length&&!e){const E=iI.Color3toRGBAUint8(I);this._colorsTexture.update(E)}else{var h;null===(h=this._colorsTexture)||void 0===h||h.dispose(),this.colorsTexture=iI.CreateColorsTexture(`${this.name}-colors-texture`,I,this.colorsSampling,this.GI())}}else null===(z=this._colorsTexture)||void 0===z||z.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(I){this._colorsTexture=I,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(I){this._width=I,this.setFloat("grlWidth",I)}get useColors(){return this._useColors}set useColors(I){this._useColors=I,this.setFloat("grlUseColors",iI.BooleanToNumber(I))}get colorsSampling(){return this._colorsSampling}set colorsSampling(I){this._colorsSampling=I}get visibility(){return this._visibility}set visibility(I){this._visibility=I,this.setFloat("grlVisibility",I)}get useDash(){return this._useDash}set useDash(I){this._useDash=I,this.setFloat("grlUseDash",iI.BooleanToNumber(I))}get dashOffset(){return this._dashOffset}set dashOffset(I){this._dashOffset=I,this.setFloat("grlDashOffset",I)}get dashRatio(){return this._dashRatio}set dashRatio(I){this._dashRatio=I,this.setFloat("grlDashRatio",I)}get dashCount(){return this._dashCount}set dashCount(I){this._dashCount=I,this._dashArray=1/I,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(I){this._sizeAttenuation=I,this.setFloat("grlSizeAttenuation",iI.BooleanToNumber(I))}get color(){return this._color}set color(I){this.setColor(I)}setColor(I){I=I??dI.DEFAULT_COLOR,this._color=I,this.setColor3("grlColor",I)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(I){this._colorsDistributionType=I,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(I){this._colorMode=I,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(I){this._resolution=I,this.setVector2("grlResolution",I),this.setFloat("grlAspect",I.x/I.y)}serialize(){const I=super.serialize(),E={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(E.lI=this._colors),I.greasedLineMaterialOptions=E,I}parse(I,E,j){var e;const w=I.greasedLineMaterialOptions;null===(e=this._colorsTexture)||void 0===e||e.dispose(),w.color&&(this.color=w.color),w.colorDistributionType&&(this.colorsDistributionType=w.colorDistributionType),w.colorsSampling&&(this.colorsSampling=w.colorsSampling),w.colorMode&&(this.colorMode=w.colorMode),w.useColors&&(this.useColors=w.useColors),w.visibility&&(this.visibility=w.visibility),w.useDash&&(this.useDash=w.useDash),w.dashCount&&(this.dashCount=w.dashCount),w.dashRatio&&(this.dashRatio=w.dashRatio),w.dashOffset&&(this.dashOffset=w.dashOffset),w.width&&(this.width=w.width),w.sizeAttenuation&&(this.sizeAttenuation=w.sizeAttenuation),w.resolution&&(this.resolution=w.resolution),w.lI?this.colorsTexture=iI.CreateColorsTexture(`${this.name}-colors-texture`,w.lI,this.colorsSampling,this.GI()):this.colorsTexture=iI.PrepareEmptyColorsTexture(E),this._cameraFacing=w.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var MI,WI,OI;TI.ForceGLSL=!1,function(I){I[I.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",I[I.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(MI||(MI={})),function(I){I[I.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",I[I.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",I[I.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(WI||(WI={})),function(I){I[I.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",I[I.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",I[I.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",I[I.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",I[I.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(OI||(OI={}));class sI extends XI.d{constructor(I,E,j){super(I,E,null,null,!1,!1),this.name=I,this._options=j,this._lazy=!1,this._updatable=!1,this._engine=E.getEngine(),this._lazy=j.lazy??!1,this._updatable=j.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=j.colorPointers??[],this._widths=j.widths??new Array(j.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(I){let E=0;for(const e of this._points)E+=e.length;const j=E/3*2-this._widths.length;for(let e=0;e<j;e++)this._widths.push(I)}updateLazy(){var I,E;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(I=this._options.ribbonOptions)||void 0===I?void 0:I.smoothShading),!this.HI&&this.refreshBoundingInfo(),null===(E=this.greasedLineMaterial)||void 0===E||E.updateLazy()}addPoints(I,E){for(const j of I)this._points.push(j);this._lazy||this.setPoints(this._points,E)}dispose(I){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(I,E)}isLazy(){return this._lazy}get iI(){return this._uvs}set iI(I){this._uvs=I instanceof Float32Array?I:new Float32Array(I),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(I){this.material instanceof TI&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===I||void 0===I?void 0:I.length)>0),this._offsets=I,this._offsetsBuffer?this._offsetsBuffer.update(I):this._createOffsetsBuffer(I)}get widths(){return this._widths}set widths(I){this._widths=I,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(I)}get colorPointers(){return this._colorPointers}set colorPointers(I){this._colorPointers=I,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(I)}get greasedLineMaterial(){var I,E;if(this.material&&this.material instanceof TI)return this.material;const j=null===(I=this.material)||void 0===I||null===(E=I.pluginManager)||void 0===E?void 0:E.getPlugin(nI.GREASED_LINE_MATERIAL_NAME);return j||void 0}get points(){const I=[];return gI.e.DeepCopy(this._points,I),I}setPoints(I,E){this._points=iI.ConvertPoints(I,(null===E||void 0===E?void 0:E.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==E&&void 0!==E&&E.colorPointers||this._updateColorPointers(),this._setPoints(this._points,E)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,iI:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(I){super.serialize(I),I.type=this.getClassName(),I.lineOptions=this._createLineOptions()}_createVertexBuffers(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new HI.b;return E.dI=this._vertexPositions,E.indices=this._indices,E.iI=this._uvs,I&&(E.aI=[],HI.b.ComputeNormals(this._vertexPositions,this._indices,E.aI)),E.nI(this,this._options.updatable),E}_createOffsetsBuffer(I){const E=this._scene.getEngine(),j=new P.c(E,I,this._updatable,3);this.setVerticesBuffer(j.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=j}}class vI{constructor(I,E){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=I,this.wasAddedByNoopNode=E}getIndicesAccessor(I,E,j,e,w){var z,h,t,U;return null===(z=this._indicesAccessorMap.get(I))||void 0===z||null===(h=z.get(E))||void 0===h||null===(t=h.get(j))||void 0===t||null===(U=t.get(e))||void 0===U?void 0:U.get(w)}setIndicesAccessor(I,E,j,e,w,z){let h=this._indicesAccessorMap.get(I);h||(h=new Map,this._indicesAccessorMap.set(I,h));let t=h.get(E);t||(t=new Map,h.set(E,t));let U=t.get(j);U||(U=new Map,t.set(j,U));let R=U.get(e);R||(R=new Map,U.set(e,R)),R.set(w,z)}pushExportedNode(I){this._exportedNodes.has(I)||this._exportedNodes.add(I)}getNodesSet(){return this._exportedNodes}getVertexBufferView(I){return this._vertexBufferViewMap.get(I)}setVertexBufferView(I,E){this._vertexBufferViewMap.set(I,E)}setRemappedBufferView(I,E,j){this._remappedBufferView.set(I,new Map),this._remappedBufferView.get(I).set(E,j)}getRemappedBufferView(I,E){var j;return null===(j=this._remappedBufferView.get(I))||void 0===j?void 0:j.get(E)}getVertexAccessor(I,E,j){var e,w;return null===(e=this._vertexAccessorMap.get(I))||void 0===e||null===(w=e.get(E))||void 0===w?void 0:w.get(j)}setVertexAccessor(I,E,j,e){let w=this._vertexAccessorMap.get(I);w||(w=new Map,this._vertexAccessorMap.set(I,w));let z=w.get(E);z||(z=new Map,w.set(E,z)),z.set(j,e)}hasVertexColorAlpha(I){return this._vertexMapColorAlpha.get(I)||!1}setHasVertexColorAlpha(I,E){return this._vertexMapColorAlpha.set(I,E)}getMesh(I){return this._meshMap.get(I)}setMesh(I,E){this._meshMap.set(I,E)}bindMorphDataToMesh(I,E){const j=this._meshMorphTargetMap.get(I)||[];this._meshMorphTargetMap.set(I,j),-1===j.indexOf(E)&&j.push(E)}getMorphTargetsFromMesh(I){return this._meshMorphTargetMap.get(I)}}class VI{_ApplyExtension(I,E,j,e){if(j>=E.length)return Promise.resolve(I);const w=e(E[j],I);return w?w.then((async I=>I?await this._ApplyExtension(I,E,j+1,e):null)):this._ApplyExtension(I,E,j+1,e)}_ApplyExtensions(I,E){const j=[];for(const e of VI._ExtensionNames)j.push(this._extensions[e]);return this._ApplyExtension(I,j,0,E)}_extensionsPreExportTextureAsync(I,E,j){return this._ApplyExtensions(E,((E,e)=>E.preExportTextureAsync&&E.preExportTextureAsync(I,e,j)))}_extensionsPostExportNodeAsync(I,E,j,e,w){return this._ApplyExtensions(E,((E,z)=>E.postExportNodeAsync&&E.postExportNodeAsync(I,z,j,e,w,this._bufferManager)))}_extensionsPostExportMaterialAsync(I,E,j){return this._ApplyExtensions(E,((E,e)=>E.postExportMaterialAsync&&E.postExportMaterialAsync(I,e,j)))}_extensionsPostExportMaterialAdditionalTextures(I,E,j){const e=[];for(const w of VI._ExtensionNames){const z=this._extensions[w];z.postExportMaterialAdditionalTextures&&e.push(...z.postExportMaterialAdditionalTextures(I,E,j))}return e}_extensionsPostExportTextures(I,E,j){for(const e of VI._ExtensionNames){const w=this._extensions[e];w.postExportTexture&&w.postExportTexture(I,E,j)}}_extensionsPostExportMeshPrimitive(I){for(const E of VI._ExtensionNames){const j=this._extensions[E];j.postExportMeshPrimitive&&j.postExportMeshPrimitive(I,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const I of VI._ExtensionNames){const E=this._extensions[I];E.preGenerateBinaryAsync&&await E.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(I){for(const E of VI._ExtensionNames){const j=this._extensions[E];j.enabled&&I(j)}}_extensionsOnExporting(){this._forEachExtensions((I=>{var E,j,e;I.wasUsed&&((E=this._glTF).extensionsUsed||(E.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(I.name)&&this._glTF.extensionsUsed.push(I.name),I.required&&((j=this._glTF).extensionsRequired||(j.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(I.name)&&this._glTF.extensionsRequired.push(I.name)),(e=this._glTF).extensions||(e.extensions={}),I.onExporting&&I.onExporting())}))}_loadExtensions(){for(const I of VI._ExtensionNames){const E=VI._ExtensionFactories[I](this);this._extensions[I]=E}}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:L.d.LastCreatedScene,E=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${K.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new A(this),this._extensions={},this._bufferManager=new PI,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!I)throw new Error("No scene available to export");this._babylonScene=I,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:I=>{var E;return null===I||void 0===I||null===(E=I.de)||void 0===E?void 0:E.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...E},this._loadExtensions()}dispose(){for(const I in this._extensions){this._extensions[I].dispose()}}get options(){return this._options}static RegisterExtension(I,E){VI.UnregisterExtension(I)&&w.Tools.Warn(`Extension with the name ${I} already exists`),VI._ExtensionFactories[I]=E,VI._ExtensionNames.push(I)}static UnregisterExtension(I){if(!VI._ExtensionFactories[I])return!1;delete VI._ExtensionFactories[I];const E=VI._ExtensionNames.indexOf(I);return-1!==E&&VI._ExtensionNames.splice(E,1),!0}_generateJSON(I,E,j){const e={byteLength:I};return e.byteLength&&(this._glTF.buffers=[e]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.CE=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(e.uri=E+".bin"),j?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(I){const E=await this._generateBinaryAsync();this._extensionsOnExporting();const j=this._generateJSON(E.byteLength,I,!0),e=new Blob([E],{type:"application/octet-stream"}),w=I+".gltf",z=I+".bin",h=new R;if(h.files[w]=j,h.files[z]=e,this._imageData)for(const t in this._imageData)h.files[t]=new Blob([this._imageData[t].data],{type:this._imageData[t].mimeType});return h}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(I){const E=I%4;return 0===E?E:4-E}async generateGLBAsync(I){this._shouldUseGlb=!0;const E=await this._generateBinaryAsync();this._extensionsOnExporting();const j=this._generateJSON(E.byteLength),e=I+".glb";let w,z=j.length;if("undefined"!==typeof TextEncoder){w=(new TextEncoder).encode(j),z=w.length}const h=this._getPadding(z),t=this._getPadding(E.byteLength),U=28+z+h+E.byteLength+t,P=new UI(U);if(P.writeUInt32(1179937895),P.writeUInt32(2),P.writeUInt32(U),P.writeUInt32(z+h),P.writeUInt32(1313821514),w)P.writeTypedArray(w);else{const I="_".charCodeAt(0);for(let E=0;E<z;++E){const e=j.charCodeAt(E);e!=j.codePointAt(E)?P.writeUInt8(I):P.writeUInt8(e)}}for(let R=0;R<h;++R)P.writeUInt8(32);P.writeUInt32(E.byteLength+t),P.writeUInt32(5130562),P.writeTypedArray(E);for(let R=0;R<t;++R)P.writeUInt8(0);const o=new R;return o.files[e]=new Blob([P.getOutputData()],{type:"application/octet-stream"}),o}_setNodeTransformation(I,E,j){if(E.getPivotPoint().equalsWithEpsilon(s,O.b)||w.Tools.Warn("Pivot points are not supported in the glTF serializer"),!E.position.equalsWithEpsilon(s,O.b)){const w=e.TmpVectors.LE[0].U(E.position);j&&J(w),I.translation=w.re()}E.pz.equalsWithEpsilon(V,O.b)||(I.scale=E.pz.re());const z=E.rotationQuaternion||e.Quaternion.FromEulerAngles(E.rotation.x,E.rotation.y,E.rotation.z);z.equalsWithEpsilon(v,O.b)||(j&&N(z),I.rotation=z.normalize().re())}_setCameraTransformation(I,E,j){if(!E.position.equalsWithEpsilon(s,O.b)){const w=e.TmpVectors.LE[0].U(E.position);j&&J(w),I.translation=w.re()}const w=E.rotationQuaternion||e.Quaternion.FromEulerAngles(E.rotation.x,E.rotation.y,E.rotation.z);j&&N(w),this._babylonScene.useRightHandedSystem||m(w),w.equalsWithEpsilon(v,O.b)||(I.rotation=w.re())}_listAvailableCameras(){for(const I of this._babylonScene.cameras){const E={type:I.mode===ZI.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(I.name&&(E.name=I.name),"perspective"===E.type)E.perspective={aspectRatio:I.getEngine().getAspectRatio(I),yfov:I.fovMode===ZI.e.FOVMODE_VERTICAL_FIXED?I.fov:I.fov*I.getEngine().getAspectRatio(I),znear:I.Te,zfar:I.maxZ};else if("orthographic"===E.type){const j=I.orthoLeft&&I.orthoRight?.5*(I.orthoRight-I.orthoLeft):.5*I.getEngine().getRenderWidth(),e=I.orthoBottom&&I.orthoTop?.5*(I.orthoTop-I.orthoBottom):.5*I.getEngine().getRenderHeight();E.orthographic={xmag:j,ymag:e,znear:I.Te,zfar:I.maxZ}}this._camerasMap.set(I,E)}}_exportAndAssignCameras(){const I=Array.from(this._camerasMap.values());for(const E of I){const I=this._nodesCameraMap.get(E);if(void 0!==I){this._cameras.push(E);for(const E of I)E.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const I of this._babylonScene.skeletons){if(I.bones.length<=0)continue;const E={joints:[]};this._skinMap.set(I,E)}}_exportAndAssignSkeletons(){for(const I of this._babylonScene.skeletons){if(I.bones.length<=0)continue;const E=this._skinMap.get(I);if(void 0==E)continue;const j={},e=[];let z=-1;for(let w=0;w<I.bones.length;++w){const E=I.bones[w],e=E.getIndex()??w;-1!==e&&(j[e]=E,e>z&&(z=e))}for(let I=0;I<=z;++I){const z=j[I];e.push(z.getAbsoluteInverseBindMatrix());const h=z.getTransformNode();if(null!==h){const I=this._nodeMap.get(h);h&&null!==I&&void 0!==I?E.joints.push(I):w.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else w.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const h=this._nodesSkinMap.get(E);if(E.joints.length>0&&void 0!==h){const I=64*e.length,j=new Float32Array(I/4);e.forEach(((I,E)=>{j.set(I.m,16*E)}));const w=this._bufferManager.createBufferView(j);this._accessors.push(this._bufferManager.createAccessor(w,"MAT4",5126,e.length)),E.inverseBindMatrices=this._accessors.length-1,this._skins.push(E);for(const E of h)E.skin=this._skins.length-1}}}async _exportSceneAsync(){const I={nodes:[]};if(this._babylonScene.metadata){const E=this._options.metadataSelector(this._babylonScene.metadata);E&&(I.extras=E)}const E=new Array,j=new Array,e=new Array;for(const t of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&hI(t,this._babylonScene.useRightHandedSystem)?e.push(...t.getChildren()):this._babylonScene.useRightHandedSystem?E.push(t):j.push(t);this._listAvailableCameras(),this._listAvailableSkeletons();const w=new vI(!0,!1);I.nodes.push(...await this._exportNodesAsync(j,w));const z=new vI(!1,!1);I.nodes.push(...await this._exportNodesAsync(E,z));const h=new vI(!1,!0);I.nodes.push(...await this._exportNodesAsync(e,h)),I.nodes.length&&this._scenes.push(I),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&xI._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,w.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(I){let E=this._shouldExportNodeMap.get(I);return void 0===E&&(E=this._options.shouldExportNode(I),this._shouldExportNodeMap.set(I,E)),E}async _exportNodesAsync(I,E){const j=new Array;this._exportBuffers(I,E);for(const e of I)await this._exportNodeAsync(e,j,E);return j}_collectBuffers(I,E,j,e,w){if(this._shouldExportNode(I)&&I instanceof Z.c&&I.Je){const z=I.Je.getVertexBuffers();if(z)for(const e in z){if(!p(e))continue;const h=z[e];w.setHasVertexColorAlpha(h,I.hasVertexAlpha);const t=h._buffer,U=E.get(t)||[];E.set(t,U),-1===U.indexOf(h)&&U.push(h);const R=j.get(h)||[];j.set(h,R),-1===R.indexOf(I)&&R.push(I)}const h=I.morphTargetManager;if(h)for(let E=0;E<h.numTargets;E++){const j=h.getTarget(E),w=e.get(j)||[];e.set(j,w),-1===w.indexOf(I)&&w.push(I)}}for(const z of I.getChildren())this._collectBuffers(z,E,j,e,w)}_exportBuffers(I,E){const j=new Map,e=new Map,w=new Map;for(const t of I)this._collectBuffers(t,j,e,w,E);const z=Array.from(j.keys());for(const t of z){const I=t.getData();if(!I)throw new Error("Buffer data is not available");const w=j.get(t);if(!w)continue;const z=w[0].byteStride;if(w.some((I=>I.byteStride!==z)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const h=jI(I).slice();for(const E of w){const I=e.get(E),{byteOffset:j,byteStride:w,componentCount:z,type:t,count:U,normalized:R,kind:o}=S(E,I);switch(o){case P.e.NormalKind:case P.e.TangentKind:(0,T.g)(h,j,w,z,t,U,R,(I=>{const E=Math.sqrt(I[0]*I[0]+I[1]*I[1]+I[2]*I[2]);if(E>0){const j=1/E;I[0]*=j,I[1]*=j,I[2]*=j}}));break;case P.e.ColorKind:{const E=I.filter((I=>I.material instanceof LI.XE||null==I.material)).length;if(0==E)break;if(E!=I.length){M.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}t==P.e.UNSIGNED_BYTE&&M.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const e=new F.qE,o=new F.hh,Z=this._babylonScene.getEngine().useExactSrgbConversions;(0,T.g)(h,j,w,z,t,U,R,(I=>{3===I.length?(e.Kj(I,0),e.toLinearSpaceToRef(e,Z),e.toArray(I,0)):(o.Kj(I,0),o.toLinearSpaceToRef(o,Z),o.toArray(I,0))}))}}}if(E.convertToRightHanded){for(const I of w){const E=e.get(I),{byteOffset:j,byteStride:w,componentCount:z,type:t,count:U,normalized:R,kind:o}=S(I,E);switch(o){case P.e.PositionKind:case P.e.NormalKind:case P.e.TangentKind:(0,T.g)(h,j,w,z,t,U,R,(I=>{I[0]=-I[0]}))}}E.convertedToRightHandedBuffers.set(t,h)}const U=this._bufferManager.createBufferView(h,z);E.setVertexBufferView(t,U);const R=new Map;for(const E of w){const I=e.get(E),{kind:j,totalVertices:w}=S(E,I);switch(j){case P.e.MatricesIndicesKind:case P.e.MatricesIndicesExtraKind:if(E.type==P.e.FLOAT){const I=E.getFloatData(w);null!==I&&R.set(E,I)}}}0!==R.size&&M.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const o=Array.from(R.keys());for(const j of o){const I=R.get(j);if(!I)continue;const e=I.some((I=>I>=256)),w=new(e?Uint16Array:Uint8Array)(I.length);for(let E=0;E<I.length;E++)w[E]=I[E];const z=this._bufferManager.createBufferView(w,4*(e?2:1));E.setRemappedBufferView(t,j,z)}}const h=Array.from(w.keys());for(const t of h){const I=w.get(t);if(!I)continue;const j=uI(t,I[0],this._bufferManager,this._bufferViews,this._accessors,E.convertToRightHanded);for(const e of I)E.bindMorphDataToMesh(e,j)}}async _exportNodeAsync(I,E,j){let e=this._nodeMap.get(I);if(void 0!==e)return void(E.includes(e)||E.push(e));const w=await this._createNodeAsync(I,j);if(w){e=this._nodes.length,this._nodes.push(w),this._nodeMap.set(I,e),j.pushExportedNode(I),E.push(e);const z={name:"runtime animations",channels:[],samplers:[]},h=[];this._babylonScene.animationGroups.length||(xI._CreateMorphTargetAnimationFromMorphTargetAnimations(I,z,h,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,j.convertToRightHanded,this._options.shouldExportAnimation),I.animations.length&&xI._CreateNodeAnimationFromNodeAnimations(I,z,h,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,j.convertToRightHanded,this._options.shouldExportAnimation)),z.channels.length&&z.samplers.length&&this._animations.push(z),h.forEach((I=>{I.channels.length&&I.samplers.length&&this._animations.push(I)}))}const z=w?[]:E;for(const h of I.getChildren())await this._exportNodeAsync(h,z,j);w&&z.length&&(w.children=z)}async _createNodeAsync(I,E){if(!this._shouldExportNode(I))return null;const j={};if(I.name&&(j.name=I.name),I.metadata){const E=this._options.metadataSelector(I.metadata);E&&(j.extras=E)}if(I instanceof o.b&&(this._setNodeTransformation(j,I,E.convertToRightHanded),I instanceof Z.c)){const w=I instanceof c.d?I.sourceMesh:I;if(w.ie&&w.ie.length>0&&(j.mesh=await this._exportMeshAsync(w,E)),I.skeleton){const E=this._skinMap.get(I.skeleton);var e;if(void 0!==E)void 0===this._nodesSkinMap.get(E)&&this._nodesSkinMap.set(E,[]),null===(e=this._nodesSkinMap.get(E))||void 0===e||e.push(j)}}if(I instanceof W.c){const e=this._camerasMap.get(I);if(e){var w;void 0===this._nodesCameraMap.get(e)&&this._nodesCameraMap.set(e,[]),this._setCameraTransformation(j,I,E.convertToRightHanded);const h=I.parent;if(null!==h&&EI(I,h)){const I=this._nodeMap.get(h);if(void 0!==I){var z;const E=this._nodes[I];return II(j,E),null===(z=this._nodesCameraMap.get(e))||void 0===z||z.push(E),null}}null===(w=this._nodesCameraMap.get(e))||void 0===w||w.push(j)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",j,I,this._nodeMap,E.convertToRightHanded)?j:(M.b.Warn(`Not exporting node ${I.name}`),null)}_exportIndices(I,E,j,e,w,h,t,U,R){let P=I;R.mode=D(h);const o=t!==z.c.CounterClockWiseSideOrientation,Z=!U.wasAddedByNoopNode&&o,c=function(I){switch(I){case z.c.TriangleFillMode:case z.c.TriangleStripDrawMode:case z.c.TriangleFanDrawMode:return!0}return!1}(h)&&Z;if(c){if(h===z.c.TriangleStripDrawMode||h===z.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");R.mode=D(h);const t=E?new Uint32Array(e):new Uint16Array(e);if(I)for(let E=0;E+2<e;E+=3)t[E]=I[j+E]+w,t[E+1]=I[j+E+2]+w,t[E+2]=I[j+E+1]+w;else for(let I=0;I+2<e;I+=3)t[I]=I,t[I+1]=I+2,t[I+2]=I+1;P=t}else if(I&&0!==w){const z=E?new Uint32Array(e):new Uint16Array(e);for(let E=0;E<e;E++)z[E]=I[j+E]+w;P=z}if(P){let z=U.getIndicesAccessor(I,j,e,w,c);if(void 0===z){const h=function(I,E,j,e){if(I instanceof Uint16Array||I instanceof Uint32Array)return I;if(I instanceof Int32Array)return new Uint32Array(I.buffer,I.byteOffset,I.length);const w=I.slice(E,E+j);return e?new Uint32Array(w):new Uint16Array(w)}(P,0,e,E),t=this._bufferManager.createBufferView(h),R=E?5125:5123;this._accessors.push(this._bufferManager.createAccessor(t,"SCALAR",R,e,0)),z=this._accessors.length-1,U.setIndicesAccessor(I,j,e,w,c,z)}R.indices=z}}_exportVertexBuffer(I,E,j,e,w,z){const h=I.getKind();if(!p(h))return;if(h.startsWith("uv")&&!this._options.exportUnusedUVs&&(!E||!this._materialNeedsUVsSet.has(E)))return;let t=w.getVertexAccessor(I,j,e);if(void 0===t){const E=w.convertedToRightHandedBuffers.get(I._buffer)||I._buffer.getData(),z=h===P.e.PositionKind?function(I,E,j,e){const{byteOffset:w,byteStride:z,type:h,normalized:t}=E,U=E.getSize(),R=new Array(U).fill(1/0),P=new Array(U).fill(-1/0);return(0,T.g)(I,w+j*z,z,U,h,e*U,t,(I=>{for(let E=0;E<U;E++)R[E]=Math.min(R[E],I[E]),P[E]=Math.max(P[E],I[E])})),{min:R,max:P}}(E,I,j,e):void 0,U=(h===P.e.MatricesIndicesKind||h===P.e.MatricesIndicesExtraKind)&&I.type===P.e.FLOAT,R=U?P.e.UNSIGNED_BYTE:I.type,o=U?void 0:I.normalized,Z=U?w.getRemappedBufferView(I._buffer,I):w.getVertexBufferView(I._buffer),c=I.byteOffset+j*I.byteStride;this._accessors.push(this._bufferManager.createAccessor(Z,function(I,E){if(I==P.e.ColorKind)return E?"VEC4":"VEC3";switch(I){case P.e.PositionKind:case P.e.NormalKind:return"VEC3";case P.e.TangentKind:case P.e.MatricesIndicesKind:case P.e.MatricesIndicesExtraKind:case P.e.MatricesWeightsKind:case P.e.MatricesWeightsExtraKind:return"VEC4";case P.e.UVKind:case P.e.UV2Kind:case P.e.UV3Kind:case P.e.UV4Kind:case P.e.UV5Kind:case P.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${I}`)}(h,w.hasVertexColorAlpha(I)),R,e,c,z,o)),t=this._accessors.length-1,w.setVertexAccessor(I,j,e,t)}z.attributes[function(I){switch(I){case P.e.PositionKind:return"POSITION";case P.e.NormalKind:return"NORMAL";case P.e.TangentKind:return"TANGENT";case P.e.ColorKind:return"COLOR_0";case P.e.UVKind:return"TEXCOORD_0";case P.e.UV2Kind:return"TEXCOORD_1";case P.e.UV3Kind:return"TEXCOORD_2";case P.e.UV4Kind:return"TEXCOORD_3";case P.e.UV5Kind:return"TEXCOORD_4";case P.e.UV6Kind:return"TEXCOORD_5";case P.e.MatricesIndicesKind:return"JOINTS_0";case P.e.MatricesIndicesExtraKind:return"JOINTS_1";case P.e.MatricesWeightsKind:return"WEIGHTS_0";case P.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${I}`)}(h)]=t}async _exportMaterialAsync(I,E,j,e){let w=this._materialMap.get(I);if(void 0===w){const e=E&&Object.keys(E).some((I=>I.startsWith("uv")));if((I=I instanceof cI.d?I.th[j.materialIndex]:I)instanceof KI.d)w=await this._materialExporter.exportPBRMaterialAsync(I,"image/png",e);else{if(!(I instanceof LI.XE))return void M.b.Warn(`Unsupported material '${I.name}' with type ${I.getClassName()}`);w=await this._materialExporter.exportStandardMaterialAsync(I,"image/png",e)}this._materialMap.set(I,w)}e.material=w}async _exportMeshAsync(I,E){var j;let e=E.getMesh(I);if(void 0!==e)return e;const w={primitives:[]};e=this._meshes.length,this._meshes.push(w),E.setMesh(I,e);const h=I.isUnIndexed?null:I.me(),t=null===(j=I.Je)||void 0===j?void 0:j.getVertexBuffers(),U=E.getMorphTargetsFromMesh(I),R=I instanceof bI.d,P=I instanceof sI,o=I.ie;if(t&&o&&o.length>0)for(const K of o){const j={attributes:{}},e=K.TI()||this._babylonScene.defaultMaterial;if(P){var Z,c;const E={name:e.name},w=I,z=F.qE.White(),h=(null===(Z=w.material)||void 0===Z?void 0:Z.alpha)??1,t=(null===(c=w.greasedLineMaterial)||void 0===c?void 0:c.color)??z;(!t.equalsWithEpsilon(z,O.b)||h<1)&&(E.pbrMetallicRoughness={baseColorFactor:[...t.re(),h]}),this._materials.push(E),j.material=this._materials.length-1}else if(R){const E={name:e.name},w=I;(!w.color.equalsWithEpsilon(F.qE.White(),O.b)||w.alpha<1)&&(E.pbrMetallicRoughness={baseColorFactor:[...w.color.re(),w.alpha]}),this._materials.push(E),j.material=this._materials.length-1}else await this._exportMaterialAsync(e,t,K,j);const o=R||P?z.c.LineListDrawMode:I.overrideRenderingFillMode??e.fillMode,L=e._getEffectiveOrientation(I);this._exportIndices(h,h?(0,T.c)(h,K.indexCount,K.indexStart,K.verticesStart):K.verticesCount>65535,h?K.indexStart:K.verticesStart,h?K.indexCount:K.verticesCount,-K.verticesStart,o,L,E,j);for(const I of Object.values(t))this._exportVertexBuffer(I,e,K.verticesStart,K.verticesCount,E,j);if(U){j.targets=[];for(const I of U)j.targets.push(I.attributes)}w.primitives.push(j),this._extensionsPostExportMeshPrimitive(j)}if(U){w.weights=[],w.extras||(w.extras={}),w.extras.targetNames=[];for(const I of U)w.weights.push(I.influence),w.extras.targetNames.push(I.name)}return e}}VI._ExtensionNames=new Array,VI._ExtensionFactories={};class fI{static async GLTFAsync(I,E,j){j&&j.exportWithoutWaitingForScene||await I.whenReadyAsync();const e=new VI(I,j),w=await e.generateGLTFAsync(E.replace(/\.[^/.]+$/,""));return e.dispose(),w}static async GLBAsync(I,E,j){j&&j.exportWithoutWaitingForScene||await I.whenReadyAsync();const e=new VI(I,j),w=await e.generateGLBAsync(E.replace(/\.[^/.]+$/,""));return e.dispose(),w}}j(11666);const SI="EXT_mesh_gpu_instancing";class BI{constructor(I){this.name=SI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(I,E,j,w,z,h){return await new Promise((I=>{if(E&&j instanceof XI.d&&j.hasThinInstances&&this._exporter){this._wasUsed=!0;const I=e.LE.Zero(),w=e.Quaternion.Identity(),t=e.LE.One(),U=j.thinInstanceGetWorldMatrices(),R=e.TmpVectors.LE[2],P=e.TmpVectors.Quaternion[1],o=e.TmpVectors.LE[3];let Z=!1,c=!1,K=!1;const L=new Float32Array(3*j.Rh),F=new Float32Array(4*j.Rh),C=new Float32Array(3*j.Rh);let X=0;for(const E of U)E.decompose(o,P,R),z&&(J(R),N(P)),L.set(R.re(),3*X),F.set(P.normalize().re(),4*X),C.set(o.re(),3*X),Z=Z||!R.equalsWithEpsilon(I),c=c||!P.equalsWithEpsilon(w),K=K||!o.equalsWithEpsilon(t),X++;const q={attributes:{}};Z&&(q.attributes.TRANSLATION=this._buildAccessor(L,"VEC3",j.Rh,h)),c&&(q.attributes.ROTATION=this._buildAccessor(F,"VEC4",j.Rh,h)),K&&(q.attributes.SCALE=this._buildAccessor(C,"VEC3",j.Rh,h)),E.extensions=E.extensions||{},E.extensions[SI]=q}I(E)}))}_buildAccessor(I,E,j,e){const w=e.createBufferView(I),z=e.createAccessor(w,E,5126,j);return this._exporter._accessors.push(z),this._exporter._accessors.length-1}}VI.RegisterExtension(SI,(I=>new BI(I)));var pI=j(11675),DI=j(11686),kI=j(11689),JI=j(11696);function NI(I){return I===kI.c.PositionKind?"POSITION":I===kI.c.NormalKind?"NORMAL":I===kI.c.ColorKind?"COLOR":I.startsWith(kI.c.UVKind)?"TEX_COORD":"GENERIC"}const mI={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class IE extends pI.d{static get DefaultAvailable(){return(0,pI.h)(IE.DefaultConfiguration)}static get Default(){return IE._Default??(IE._Default=new IE),IE._Default}static ResetDefault(I){IE._Default&&(I||IE._Default.dispose(),IE._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(I,E){return{module:await(E||DracoEncoderModule)({wasmBinary:I})}}_getWorkerContent(){return`${DI.h}(${DI.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:IE.DefaultConfiguration)}async _encodeAsync(I,E,j){const e=j?(0,JI.b)(mI,j):mI;if(this._workerPoolPromise){const j=await this._workerPoolPromise;return await new Promise(((w,z)=>{j.push(((j,h)=>{const t=I=>{j.removeEventListener("error",t),j.removeEventListener("message",U),z(I),h()},U=I=>{"encodeMeshDone"===I.data.id&&(j.removeEventListener("error",t),j.removeEventListener("message",U),w(I.data.encodedMeshData),h())};j.addEventListener("error",t),j.addEventListener("message",U);const R=[];for(const E of I)R.push(E.data.buffer);E&&R.push(E.buffer),j.postMessage({id:"encodeMesh",attributes:I,indices:E,options:e},R)}))}))}if(this._modulePromise){const j=await this._modulePromise;return(0,DI.h)(j.module,I,E,e)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(I,E){if(0==I.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");I instanceof XI.d&&I.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===E||void 0===E?void 0:E.method)&&(M.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),E.method="MESH_SEQUENTIAL_ENCODING");const j=function(I){let E=I.me(void 0,!0);return!E||E instanceof Uint32Array||E instanceof Uint16Array||(E=((0,T.c)(E,E.length)?Uint32Array:Uint16Array).from(E)),E}(I),e=function(I,E){const j=[];for(const e of I.getVerticesDataKinds()){if(null!==E&&void 0!==E&&E.includes(e)){if(e===kI.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const w=I.getVertexBuffer(e),z=w.getSize(),h=(0,T.s)(w.getData(),z,w.type,w.byteOffset,w.byteStride,w.normalized,I.getTotalVertices(),!0);j.push({kind:e,dracoName:NI(e),size:z,data:h})}return j}(I,null===E||void 0===E?void 0:E.excludedAttributes);return await this._encodeAsync(e,j,E)}}IE.DefaultConfiguration={wasmUrl:`${w.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${w.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${w.Tools._DefaultCdnUrl}/draco_encoder.js`},IE._Default=null;const EE="KHR_draco_mesh_compression";class jE{get wasUsed(){return this._wasUsed}constructor(I){this.name=EE,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===I.options.meshCompressionMethod&&IE.DefaultAvailable}dispose(){}postExportMeshPrimitive(I,E,j){if(!this.enabled)return;if(4!==I.mode&&5!==I.mode)return void M.b.Warn("Cannot compress primitive with mode "+I.mode+".");const e=[],w=[];let z=null;if(void 0!==I.indices){const h=j[I.indices],t=E.getBufferView(h);z=E.getData(t).slice(),e.push(t),w.push(h)}const h=[];for(const[P,o]of Object.entries(I.attributes)){const I=j[o],z=E.getBufferView(I),U=B(I.type),R=(0,T.s)(E.getData(z),U,I.componentType,I.byteOffset||0,z.byteStride||(0,T.l)(I.componentType)*U,I.normalized||!1,I.count,!0);h.push({kind:P,dracoName:(t=P,"POSITION"===t?"POSITION":"NORMAL"===t?"NORMAL":t.startsWith("COLOR")?"COLOR":t.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:B(I.type),data:R}),e.push(z),w.push(I)}var t;const U={method:I.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},R=IE.Default._encodeAsync(h,z,U).then((j=>{if(!j)return void M.b.Error("Draco encoding failed for primitive.");const z={bufferView:-1,attributes:j.attributeIds},h=E.createBufferView(j.data);E.setBufferView(z,h);for(const I of e)this._bufferViewsUsed.add(I);for(const I of w)this._accessorsUsed.add(I);I.extensions||(I.extensions={}),I.extensions[EE]=z})).catch((I=>{M.b.Error("Draco encoding failed for primitive: "+I)}));this._encodePromises.push(R),this._wasUsed=!0}async preGenerateBinaryAsync(I){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((E=>{I.getPropertiesWithBufferView(E).every((I=>this._accessorsUsed.has(I)))&&I.removeBufferView(E)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}VI.RegisterExtension(EE,(I=>new jE(I)));var eE=j(11705);const wE="KHR_lights_punctual",zE={name:"",color:[1,1,1],Ch:1,range:Number.MAX_VALUE},hE={innerConeAngle:0,outerConeAngle:Math.PI/4},tE=e.LE.Backward();class UE{constructor(I){this.name=wE,this.enabled=!0,this.required=!1,this._exporter=I}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[wE]=this._lights}async postExportNodeAsync(I,E,j,w,z){return await new Promise((h=>{if(!(j instanceof qI.c))return void h(E);const t=j.getTypeID()==qI.c.LIGHTTYPEID_POINTLIGHT?"point":j.getTypeID()==qI.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":j.getTypeID()==qI.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!t||!(j instanceof eE.c))return M.b.Warn(`${I}: Light ${j.name} is not supported in ${wE}`),void h(E);if(j.falloffType!==qI.c.FALLOFF_GLTF&&M.b.Warn(`${I}: Light falloff for ${j.name} does not match the ${wE} specification!`),!j.position.equalsToFloats(0,0,0)){const I=e.TmpVectors.LE[0].U(j.position);z&&J(I),E.translation=I.re()}if("point"!==t){const I=j.direction.normalizeToRef(e.TmpVectors.LE[0]);z&&J(I);const w=e.Quaternion.FromUnitVectorsToRef(tE,I,e.TmpVectors.Quaternion[0]);e.Quaternion.IsIdentity(w)||(E.rotation=w.re())}const U={type:t,name:j.name,color:j.xh.re(),Ch:j.Ch,range:j.range};if(eI(U,zE),"spot"===t){const I=j;U.spot={innerConeAngle:I.innerAngle/2,outerConeAngle:I.angle/2},eI(U.spot,hE)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(U);const R={te:this._lights.lights.length-1},P=j.parent;if(P&&EI(j,P)){const I=w.get(P);if(I){const j=this._exporter._nodes[I];return II(E,j),j.extensions||(j.extensions={}),j.extensions[wE]=R,void h(null)}}E.extensions||(E.extensions={}),E.extensions[wE]=R,h(E)}))}}VI.RegisterExtension(wE,(I=>new UE(I)));var RE=j(11621);const PE="KHR_materials_anisotropy";class oE{constructor(I){this.name=PE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,E,j){const e=[];return j instanceof RE.c&&j.anisotropy.isEnabled&&!j.anisotropy.legacy?(j.anisotropy.texture&&e.push(j.anisotropy.texture),e):[]}postExportMaterialAsync(I,E,j){return new Promise((I=>{if(j instanceof RE.c){if(!j.anisotropy.isEnabled||j.anisotropy.legacy)return void I(E);this._wasUsed=!0,E.extensions=E.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(j.anisotropy.texture),w={anisotropyStrength:j.anisotropy.Ch,anisotropyRotation:j.anisotropy.angle,anisotropyTexture:e??void 0};null!==w.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(j),E.extensions[PE]=w}I(E)}))}}VI.RegisterExtension(PE,(I=>new oE(I)));const ZE="KHR_materials_clearcoat";class cE{constructor(I){this.name=ZE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,E,j){const e=[];return j instanceof RE.c&&j.clearCoat.isEnabled?(j.clearCoat.texture&&e.push(j.clearCoat.texture),!j.clearCoat.useRoughnessFromMainTexture&&j.clearCoat.textureRoughness&&e.push(j.clearCoat.textureRoughness),j.clearCoat.bumpTexture&&e.push(j.clearCoat.bumpTexture),e):[]}postExportMaterialAsync(I,E,j){return new Promise((I=>{if(j instanceof RE.c){if(!j.clearCoat.isEnabled)return void I(E);this._wasUsed=!0,E.extensions=E.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(j.clearCoat.texture);let z;z=j.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(j.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(j.clearCoat.textureRoughness),j.clearCoat.isTintEnabled&&w.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${j.name}`),j.clearCoat.remapF0OnInterfaceChange&&w.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${j.name}`);const h=this._exporter._materialExporter.getTextureInfo(j.clearCoat.bumpTexture),t={clearcoatFactor:j.clearCoat.Ch,clearcoatTexture:e??void 0,clearcoatRoughnessFactor:j.clearCoat.roughness,clearcoatRoughnessTexture:z??void 0,clearcoatNormalTexture:h??void 0};null===t.clearcoatTexture&&null===t.clearcoatRoughnessTexture&&null===t.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(j),E.extensions[ZE]=t}I(E)}))}}VI.RegisterExtension(ZE,(I=>new cE(I)));const KE="KHR_materials_diffuse_transmission";function LE(I,E){const j=E.subSurface;let e=null;return j.translucencyIntensityTexture?e=j.translucencyIntensityTexture:j.thicknessTexture&&j.useMaskFromThicknessTexture&&(e=j.thicknessTexture),e&&!j.useGltfStyleTextures?(M.b.Warn(`${I}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${E.name}`,1),null):e}class FE{constructor(I){this.name=KE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,E,j){const e=[];if(j instanceof KI.d&&this._isExtensionEnabled(j)){const E=LE(I,j);return E&&e.push(E),j.subSurface.translucencyColorTexture&&e.push(j.subSurface.translucencyColorTexture),e}return e}_isExtensionEnabled(I){if(I.unlit)return!1;const E=I.subSurface;return!!E.isTranslucencyEnabled&&(!I.unlit&&!E.useAlbedoToTintTranslucency&&E.useGltfStyleTextures&&1===E.volumeIndexOfRefraction&&0===E.minimumThickness&&0===E.maximumThickness)}postExportMaterialAsync(I,E,j){return new Promise((e=>{if(j instanceof KI.d&&this._isExtensionEnabled(j)){this._wasUsed=!0;const e=j.subSurface,w=LE(I,j),z=0==e.translucencyIntensity?void 0:e.translucencyIntensity,h=this._exporter._materialExporter.getTextureInfo(w)??void 0,t=!e.translucencyColor||e.translucencyColor.equalsFloats(1,1,1)?void 0:e.translucencyColor.re(),U=this._exporter._materialExporter.getTextureInfo(e.translucencyColorTexture)??void 0,R={diffuseTransmissionFactor:z,diffuseTransmissionTexture:h,diffuseTransmissionColorFactor:t,diffuseTransmissionColorTexture:U};(h||U)&&this._exporter._materialNeedsUVsSet.add(j),E.extensions=E.extensions||{},E.extensions[KE]=R}e(E)}))}}VI.RegisterExtension(KE,(I=>new FE(I)));const CE="KHR_materials_dispersion";class XE{constructor(){this.name=CE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(I){if(I.unlit)return!1;const E=I.subSurface;return!(!E.isRefractionEnabled&&!E.isDispersionEnabled)}postExportMaterialAsync(I,E,j){return new Promise((I=>{if(j instanceof KI.d&&this._isExtensionEnabled(j)){this._wasUsed=!0;const I={dispersion:j.subSurface.dispersion};E.extensions=E.extensions||{},E.extensions[CE]=I}I(E)}))}}VI.RegisterExtension(CE,(()=>new XE));const qE="KHR_materials_emissive_strength";class xE{constructor(){this.name=qE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(I,E,j){return await new Promise((I=>{if(!(j instanceof KI.d))return I(E);const e=j.emissiveColor.re(),w=Math.max(...e);if(w>1){this._wasUsed=!0,E.extensions||(E.extensions={});const I={emissiveStrength:w},e=j.emissiveColor.scale(1/I.emissiveStrength);E.emissiveFactor=e.re(),E.extensions[qE]=I}return I(E)}))}}VI.RegisterExtension(qE,(I=>new xE));const uE="KHR_materials_ior";class bE{constructor(){this.name=uE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(I){return!I.unlit&&(void 0!=I.indexOfRefraction&&1.5!=I.indexOfRefraction)}postExportMaterialAsync(I,E,j){return new Promise((I=>{if(j instanceof KI.d&&this._isExtensionEnabled(j)){this._wasUsed=!0;const I={ior:j.indexOfRefraction};E.extensions=E.extensions||{},E.extensions[uE]=I}I(E)}))}}VI.RegisterExtension(uE,(I=>new bE));const QE="KHR_materials_iridescence";class GE{constructor(I){this.name=QE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,E,j){const e=[];return j instanceof RE.c&&j.iridescence.isEnabled?(j.iridescence.texture&&e.push(j.iridescence.texture),j.iridescence.thicknessTexture&&j.iridescence.thicknessTexture!==j.iridescence.texture&&e.push(j.iridescence.thicknessTexture),e):[]}postExportMaterialAsync(I,E,j){return new Promise((I=>{if(j instanceof RE.c){if(!j.iridescence.isEnabled)return void I(E);this._wasUsed=!0,E.extensions=E.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(j.iridescence.texture),w=this._exporter._materialExporter.getTextureInfo(j.iridescence.thicknessTexture),z={iridescenceFactor:j.iridescence.Ch,iridescenceIor:j.iridescence.indexOfRefraction,iridescenceThicknessMinimum:j.iridescence.minimumThickness,iridescenceThicknessMaximum:j.iridescence.maximumThickness,iridescenceTexture:e??void 0,iridescenceThicknessTexture:w??void 0};null===z.iridescenceTexture&&null===z.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(j),E.extensions[QE]=z}I(E)}))}}VI.RegisterExtension(QE,(I=>new GE(I)));const yE="KHR_materials_sheen";class dE{constructor(I){this.name=yE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,E,j){return j instanceof KI.d&&j.sheen.isEnabled&&j.sheen.texture?[j.sheen.texture]:[]}async postExportMaterialAsync(I,E,j){return await new Promise((I=>{if(j instanceof KI.d){if(!j.sheen.isEnabled)return void I(E);this._wasUsed=!0,null==E.extensions&&(E.extensions={});const e={sheenColorFactor:j.sheen.color.re(),sheenRoughnessFactor:j.sheen.roughness??0};null===e.sheenColorTexture&&null===e.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(j),j.sheen.texture&&(e.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(j.sheen.texture)??void 0),j.sheen.textureRoughness&&!j.sheen.useRoughnessFromMainTexture?e.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(j.sheen.textureRoughness)??void 0:j.sheen.texture&&j.sheen.useRoughnessFromMainTexture&&(e.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(j.sheen.texture)??void 0),E.extensions[yE]=e}I(E)}))}}VI.RegisterExtension(yE,(I=>new dE(I)));const aE="KHR_materials_specular";class lE{constructor(I){this.name=aE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,E,j){const e=[];return j instanceof KI.d&&this._isExtensionEnabled(j)?(j.metallicReflectanceTexture&&e.push(j.metallicReflectanceTexture),j.reflectanceTexture&&e.push(j.reflectanceTexture),e):e}_isExtensionEnabled(I){return!I.unlit&&(void 0!=I.metallicF0Factor&&1!=I.metallicF0Factor||void 0!=I.metallicReflectanceColor&&!I.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(I))}_hasTexturesExtension(I){return null!=I.metallicReflectanceTexture||null!=I.reflectanceTexture}postExportMaterialAsync(I,E,j){return new Promise((I=>{if(j instanceof KI.d&&this._isExtensionEnabled(j)){this._wasUsed=!0,E.extensions=E.extensions||{};const I=this._exporter._materialExporter.getTextureInfo(j.metallicReflectanceTexture)??void 0,e=this._exporter._materialExporter.getTextureInfo(j.reflectanceTexture)??void 0,w={specularFactor:1==j.metallicF0Factor?void 0:j.metallicF0Factor,specularTexture:I,specularColorFactor:j.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:j.metallicReflectanceColor.re(),specularColorTexture:e};this._hasTexturesExtension(j)&&this._exporter._materialNeedsUVsSet.add(j),E.extensions[aE]=w}I(E)}))}}VI.RegisterExtension(aE,(I=>new lE(I)));const iE="KHR_materials_transmission";class rE{constructor(I){this.name=iE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,E,j){const e=[];return j instanceof KI.d&&this._isExtensionEnabled(j)?(j.subSurface.thicknessTexture&&e.push(j.subSurface.thicknessTexture),e):e}_isExtensionEnabled(I){if(I.unlit)return!1;const E=I.subSurface;return E.isRefractionEnabled&&void 0!=E.refractionIntensity&&0!=E.refractionIntensity||this._hasTexturesExtension(I)}_hasTexturesExtension(I){return null!=I.subSurface.refractionIntensityTexture}async postExportMaterialAsync(I,E,j){if(j instanceof KI.d&&this._isExtensionEnabled(j)){this._wasUsed=!0;const e=j.subSurface,w={transmissionFactor:0===e.refractionIntensity?void 0:e.refractionIntensity};if(this._hasTexturesExtension(j)&&this._exporter._materialNeedsUVsSet.add(j),e.refractionIntensityTexture)if(e.useGltfStyleTextures){const I=await this._exporter._materialExporter.exportTextureAsync(e.refractionIntensityTexture,"image/png");I&&(w.transmissionTexture=I)}else M.b.Warn(`${I}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);E.extensions||(E.extensions={}),E.extensions[iE]=w}return E}}VI.RegisterExtension(iE,(I=>new rE(I)));const nE="KHR_materials_unlit";class HE{constructor(){this.name=nE,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(I,E,j){return new Promise((I=>{let e=!1;j instanceof KI.d?e=j.unlit:j instanceof LI.XE&&(e=j.disableLighting),e&&(this._wasUsed=!0,null==E.extensions&&(E.extensions={}),E.extensions[nE]={}),I(E)}))}}VI.RegisterExtension(nE,(()=>new HE));const gE="KHR_materials_volume";class YE{constructor(I){this.name=gE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,E,j){const e=[];return j instanceof KI.d&&this._isExtensionEnabled(j)?(j.subSurface.thicknessTexture&&e.push(j.subSurface.thicknessTexture),e):e}_isExtensionEnabled(I){if(I.unlit)return!1;const E=I.subSurface;return!(!E.isRefractionEnabled&&!E.isTranslucencyEnabled)&&(void 0!=E.maximumThickness&&0!=E.maximumThickness||void 0!=E.tintColorAtDistance&&E.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=E.tintColor&&E.tintColor!=F.qE.White()||this._hasTexturesExtension(I))}_hasTexturesExtension(I){return null!=I.subSurface.thicknessTexture}postExportMaterialAsync(I,E,j){return new Promise((I=>{if(j instanceof KI.d&&this._isExtensionEnabled(j)){this._wasUsed=!0;const I=j.subSurface,e={thicknessFactor:0==I.maximumThickness?void 0:I.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(I.thicknessTexture)??void 0,attenuationDistance:I.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:I.tintColorAtDistance,attenuationColor:I.tintColor.equalsFloats(1,1,1)?void 0:I.tintColor.re()};this._hasTexturesExtension(j)&&this._exporter._materialNeedsUVsSet.add(j),E.extensions=E.extensions||{},E.extensions[gE]=e}I(E)}))}}VI.RegisterExtension(gE,(I=>new YE(I)));const AE="EXT_materials_diffuse_roughness";class TE{constructor(I){this.name=AE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,E,j){const e=[];return j instanceof RE.c&&j._baseDiffuseRoughness?(j._baseDiffuseRoughnessTexture&&e.push(j._baseDiffuseRoughnessTexture),e):[]}postExportMaterialAsync(I,E,j){return new Promise((I=>{if(j instanceof RE.c){if(!j._baseDiffuseRoughness)return void I(E);this._wasUsed=!0,E.extensions=E.extensions||{};const e=this._exporter._materialExporter.getTextureInfo(j._baseDiffuseRoughnessTexture),w={diffuseRoughnessFactor:j._baseDiffuseRoughness,diffuseRoughnessTexture:e??void 0};null!==w.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(j),E.extensions[AE]=w}I(E)}))}}VI.RegisterExtension(AE,(I=>new TE(I)));const ME="KHR_texture_transform";class WE{constructor(){this.name=ME,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(I,E,j){if(j.GI()||w.Tools.Warn(`${I}: /*@__KEY__*/"scene" is not defined for Babylon texture ${j.name}!`),(0!==j.uAng||0!==j.vAng)&&(w.Tools.Warn(`${I}: Texture ${j.name} with rotation in the u or v axis is not supported in glTF.`),0!==j.uRotationCenter||0!==j.vRotationCenter))return;const e={};let z=!1;if(0===j.uOffset&&0===j.vOffset||(e.offset=[j.uOffset,j.vOffset],z=!0),1===j.uScale&&1===j.vScale||(e.scale=[j.uScale,j.vScale],z=!0),0!==j.wAng){if(0!==j.uRotationCenter||0!==j.vRotationCenter){if(j.homogeneousRotationInUVTransform&&j.uScale!==j.vScale)return void w.Tools.Warn(`${I}: Texture ${j.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${ME}.`);w.Tools.Warn(`${I}: Texture ${j.name} with non-origin rotation center will be exported using an adjusted offset with ${ME}.`),e.offset=function(I){const{uOffset:E,vOffset:j,uRotationCenter:e,vRotationCenter:w,uScale:z,vScale:h,wAng:t}=I,U=Math.cos(t),R=Math.sin(t),P=e*z,o=w*h;return[E+(P*(1-U)+o*R),j+(o*(1-U)-P*R)]}(j)}e.rotation=-j.wAng,z=!0}0!==j.coordinatesIndex&&(e.texCoord=j.coordinatesIndex,z=!0),z&&(this._wasUsed=!0,E.extensions||(E.extensions={}),E.extensions[ME]=e)}}VI.RegisterExtension(ME,(()=>new WE));class OE{static CreateSTL(I){let E=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",w=arguments.length>3&&void 0!==arguments[3]&&arguments[3],z=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],h=arguments.length>5&&void 0!==arguments[5]&&arguments[5],t=arguments.length>6&&void 0!==arguments[6]&&arguments[6],U=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const R=function(I,E,j){const w=[3*I[j],3*I[j+1],3*I[j+2]],z=[new e.LE(E[w[0]],E[w[0]+2],E[w[0]+1]),new e.LE(E[w[1]],E[w[1]+2],E[w[1]+1]),new e.LE(E[w[2]],E[w[2]+2],E[w[2]+1])],h=z[0].FE(z[1]),t=z[2].FE(z[1]);return{v:z,n:e.LE.Cross(t,h).normalize()}},o=function(I,E,j,e){return E=Z(I,E,j.x,e),E=Z(I,E,j.y,e),Z(I,E,j.z,e)},Z=function(I,E,j,e){return I.setFloat32(E,j,e),E+4},K=function(I){if(t){let E=I;I instanceof c.d&&(E=I.sourceMesh);const j=E.getVerticesData(P.e.PositionKind,!0,!0);if(!j)return[];const w=e.LE.Zero();let z;for(z=0;z<j.length;z+=3)e.LE.TransformCoordinatesFromFloatsToRef(j[z],j[z+1],j[z+2],I.Be(!0),w).toArray(j,z);return j}return I.getVerticesData(P.e.PositionKind)||[]};t&&(h=!0);let L="",F=0,C=0;if(w){for(let j=0;j<I.length;j++){const E=I[j].me();F+=E?E.length/3:0}const E=new ArrayBuffer(84+50*F);L=new DataView(E),C+=80,L.setUint32(C,F,z),C+=4}else U||(L="solid stlmesh\r\n");for(let e=0;e<I.length;e++){const E=I[e];!w&&U&&(L+="solid "+E.name+"\r\n"),!h&&E instanceof XI.d&&E.bakeCurrentTransformIntoVertices();const j=K(E),t=E.me()||[];for(let I=0;I<t.length;I+=3){const E=R(t,j,I);w?(C=o(L,C,E.n,z),C=o(L,C,E.v[0],z),C=o(L,C,E.v[1],z),C=o(L,C,E.v[2],z),C+=2):(L+="\tfacet normal "+E.n.x+" "+E.n.y+" "+E.n.z+"\r\n",L+="\t\touter loop\r\n",L+="\t\t\tvertex "+E.v[0].x+" "+E.v[0].y+" "+E.v[0].z+"\r\n",L+="\t\t\tvertex "+E.v[1].x+" "+E.v[1].y+" "+E.v[1].z+"\r\n",L+="\t\t\tvertex "+E.v[2].x+" "+E.v[2].y+" "+E.v[2].z+"\r\n",L+="\t\tendloop\r\n",L+="\tendfacet\r\n")}!w&&U&&(L+="endsolid "+name+"\r\n")}if(w||U||(L+="endsolid stlmesh"),E){const I=document.createElement("a"),E=new Blob([L],{type:"application/octet-stream"});I.href=window.URL.createObjectURL(E),I.download=j+".stl",I.click()}return L}}function sE(I,E){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const e=[];for(let w=0;w<I.length/j;w++){const z=I[w*j],h=I[w*j+1],t=I[w*j+2];e.push(`(${z.toPrecision(E.precision)}, ${h.toPrecision(E.precision)}, ${t.toPrecision(E.precision)})`)}return e.join(", ")}function vE(I,E){const j=[];for(let e=0;e<I.length/2;e++){const w=I[2*e],z=I[2*e+1];j.push(`(${w.toPrecision(E.precision)}, ${(1-z).toPrecision(E.precision)})`)}return j.join(", ")}function VE(I,E){const j=I.getVerticesData(P.e.PositionKind),e=I.getVerticesData(P.e.NormalKind);if(j&&e)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(I){var E;const j=null!==(E=I.me())&&void 0!==E&&E.length?I.getTotalIndices():I.getTotalVertices();return Array(j/3).fill(3).join(", ")}(I)}]\n\t\tint[] faceVertexIndices = [${function(I){const E=I.me(),j=[];if(null!==E)for(let e=0;e<E.length;e++)j.push(E[e]);else{const E=I.getTotalVertices();for(let I=0;I<E;I++)j.push(I)}return j.join(", ")}(I)}]\n\t\tnormal3f[] normals = [${sE(e,E)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${sE(j,E)}]\n        ${function(I,E){let j="";for(let w=0;w<4;w++){const e=w>0?w:"",z=I.getVerticesData(P.e.UVKind+(e?e+1:""));z&&(j+=`\n\t\ttexCoord2f[] primvars:st${e} = [${vE(z,E)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const e=I.getVerticesData(P.e.ColorKind);return e&&(j+=`\n\tcolor3f[] primvars:displayColor = [${sE(e,E,e.length/I.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),j}(I,E)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function fE(I,E){return`\n        def "Geometry"\n        {\n        ${VE(I,E)}\n        }\n        `}function SE(I){let E='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return E+=I,fflate.strToU8(E)}function BE(I){const E=I.m;return`( ${pE(E,0)}, ${pE(E,4)}, ${pE(E,8)}, ${pE(E,12)} )`}function pE(I,E){return`(${I[E+0]}, ${I[E+1]}, ${I[E+2]}, ${I[E+3]})`}function DE(I){const E="Object_"+I.uniqueId,j=function(I){const E=I.getWorldMatrix().clone(),j=I.GI().useRightHandedSystem;if(!j){let e=I.parent;for(;e;){if(hI(e,j)){E.multiplyToRef(e.getWorldMatrix().invert(),E);break}e=e.parent}}return E.determinant()<0&&w.Tools.Warn(`Exporting mesh ${I.name} with negative scale. Result may look incorrect in destination engine.`),E}(I),e=BE(j);return`def Xform "${E}" (\n\tprepend references = @./geometries/Geometry_${I.Je.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${e}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${I.material.uniqueId}>\n}\n\n`}function kE(I){switch(I){case Q.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case Q.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case Q.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function JE(I){return`(${I.x}, ${I.y})`}function NE(I){return`(${I.r}, ${I.g}, ${I.b})`}function mE(I,E,j,w,z,h){const t=I.getInternalTexture().uniqueId+"_"+I.invertY;z[t]=I;const U=I.coordinatesIndex>0?"st"+I.coordinatesIndex:"st",R=new e.Vector2(I.uScale,I.vScale),P=new e.Vector2(I.uOffset,I.vOffset),o=I.wAng,Z=Math.sin(o),c=Math.cos(o);return P.y=1-P.y-R.y,P.x+=Z*R.x,P.y+=(1-c)*R.y,`\n    def Shader "PrimvarReader_${j}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${U}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${j}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${E.uniqueId}/PrimvarReader_${j}.outputs:result>\n        float inputs:rotation = ${(o*(180/Math.PI)).toFixed(h.precision)}\n        float2 inputs:scale = ${JE(R)}\n        float2 inputs:translation = ${JE(P)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${I.uniqueId}_${j}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${t}.png@\n        float2 inputs:st.connect = </Materials/Material_${E.uniqueId}/Transform2d_${j}.outputs:result>\n        ${w?"float4 inputs:scale = "+function(I){return`(${I.r}, ${I.g}, ${I.b}, 1.0)`}(w):""}\n        token inputs:sourceColorSpace = "${I.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${kE(I.wrapU)}"\n        token inputs:wrapT = "${kE(I.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${E.needAlphaBlending()?"float outputs:a":""}\n    }`}function Ij(I,E,j){const e="\t\t\t",w=[],z=[],{diffuseMap:h,xh:t,alphaCutOff:U,emissiveMap:R,emissive:P,normalMap:o,roughnessMap:Z,roughnessChannel:c,roughness:K,metalnessMap:L,metalnessChannel:C,metalness:X,aoMap:q,aoMapChannel:x,aoMapIntensity:u,alphaMap:b,ior:Q,clearCoatEnabled:G,clearCoat:y,clearCoatMap:d,clearCoatRoughness:a,clearCoatRoughnessMap:l}=function(I){const E={diffuseMap:null,xh:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return I instanceof LI.XE?{...E,diffuseMap:I.diffuseTexture,xh:I.diffuseColor,alphaCutOff:I.alphaCutOff,emissiveMap:I.emissiveTexture,emissive:I.emissiveColor,roughness:1,alphaMap:I.opacityTexture}:I instanceof RE.c?{...E,diffuseMap:I._albedoTexture,xh:I._albedoColor,alphaCutOff:I._alphaCutOff,emissiveMap:I._emissiveTexture,emissive:I._emissiveColor,normalMap:I._bumpTexture,roughnessMap:I._metallicTexture,roughnessChannel:I._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:I._roughness??1,metalnessMap:I._metallicTexture,metalnessChannel:I._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:I._metallic??0,aoMap:I._ambientTexture,aoMapChannel:I._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:I._ambientTextureStrength,alphaMap:I._opacityTexture,ior:I.subSurface.indexOfRefraction,clearCoatEnabled:I.clearCoat.isEnabled,clearCoat:I.clearCoat.Ch,clearCoatMap:I.clearCoat.texture,clearCoatRoughness:I.clearCoat.roughness,clearCoatRoughnessMap:I.clearCoat.useRoughnessFromMainTexture?I.clearCoat.texture:I.clearCoat.textureRoughness}:E}(I);return null!==h?(w.push(`${e}color3f inputs:diffuseColor.connect = </Materials/Material_${I.uniqueId}/Texture_${h.uniqueId}_diffuse.outputs:rgb>`),I.needAlphaBlending()?w.push(`${e}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${h.uniqueId}_diffuse.outputs:a>`):I.needAlphaTesting()&&(w.push(`${e}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${h.uniqueId}_diffuse.outputs:a>`),w.push(`${e}float inputs:opacityThreshold = ${U}`)),z.push(mE(h,I,"diffuse",t,E,j))):w.push(`${e}color3f inputs:diffuseColor = ${NE(t||F.qE.White())}`),null!==R?(w.push(`${e}color3f inputs:emissiveColor.connect = </Materials/Material_${I.uniqueId}/Texture_${R.uniqueId}_emissive.outputs:rgb>`),z.push(mE(R,I,"emissive",P,E,j))):P&&P.toLuminance()>0&&w.push(`${e}color3f inputs:emissiveColor = ${NE(P)}`),null!==o&&(w.push(`${e}normal3f inputs:normal.connect = </Materials/Material_${I.uniqueId}/Texture_${o.uniqueId}_normal.outputs:rgb>`),z.push(mE(o,I,"normal",null,E,j))),null!==q&&(w.push(`${e}float inputs:occlusion.connect = </Materials/Material_${I.uniqueId}/Texture_${q.uniqueId}_occlusion.outputs:${x}>`),z.push(mE(q,I,"occlusion",new F.qE(u,u,u),E,j))),null!==Z?(w.push(`${e}float inputs:roughness.connect = </Materials/Material_${I.uniqueId}/Texture_${Z.uniqueId}_roughness.outputs:${c}>`),z.push(mE(Z,I,"roughness",new F.qE(K,K,K),E,j))):w.push(`${e}float inputs:roughness = ${K}`),null!==L?(w.push(`${e}float inputs:metallic.connect = </Materials/Material_${I.uniqueId}/Texture_${L.uniqueId}_metallic.outputs:${C}>`),z.push(mE(L,I,"metallic",new F.qE(X,X,X),E,j))):w.push(`${e}float inputs:metallic = ${X}`),null!==b?(w.push(`${e}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${b.uniqueId}_opacity.outputs:r>`),w.push(`${e}float inputs:opacityThreshold = 0.0001`),z.push(mE(b,I,"opacity",null,E,j))):w.push(`${e}float inputs:opacity = ${I.alpha}`),G&&(null!==d?(w.push(`${e}float inputs:clearcoat.connect = </Materials/Material_${I.uniqueId}/Texture_${d.uniqueId}_clearcoat.outputs:r>`),z.push(mE(d,I,"clearcoat",new F.qE(y,y,y),E,j))):w.push(`${e}float inputs:clearcoat = ${y}`),null!==l?(w.push(`${e}float inputs:clearcoatRoughness.connect = </Materials/Material_${I.uniqueId}/Texture_${l.uniqueId}_clearcoatRoughness.outputs:g>`),z.push(mE(l,I,"clearcoatRoughness",new F.qE(a,a,a),E,j))):w.push(`${e}float inputs:clearcoatRoughness = ${a}`)),w.push(`${e}float inputs:ior = ${Q}`),`\n\tdef Material "Material_${I.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${w.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${I.uniqueId}/PreviewSurface.outputs:surface>\n\n${z.join("\n")}\n\n\t}\n`}async function Ej(I,E,j){const z={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...E};"undefined"===typeof fflate&&await w.Tools.LoadScriptAsync(z.fflateUrl);const h={};h[z.modelFileName]=null;let t='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';t+=function(I){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===I.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${I.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${I.planeAnchoringAlignment}"`:""}\n            `}(z);const U={};for(const e of I.meshes){if(0===e.getTotalVertices())continue;const I=e,E=I.Je,R=I.material;if(!R||!E||j&&!j(I))continue;if(-1!==["XE","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(R.getClassName())){const j="geometries/Geometry_"+E.uniqueId+".usda";if(!(j in h)){const I=fE(E,z);h[j]=SE(I)}R.uniqueId in U||(U[R.uniqueId]=R),t+=DE(I)}else w.Tools.Warn("USDZExportAsync does not support this material type: "+R.getClassName())}I.activeCamera&&z.exportCamera&&(t+=function(I,E){const j="Camera_"+I.uniqueId,w=BE(e.Matrix.RotationY(Math.PI).multiply(I.getWorldMatrix()));if(I.mode===Q.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${j}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${w}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${I.Te.toPrecision(E.precision)}, ${I.maxZ.toPrecision(E.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(I.orthoLeft||1)+Math.abs(I.orthoRight||1))).toPrecision(E.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(I.orthoTop||1)+Math.abs(I.orthoBottom||1))).toPrecision(E.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const e=I.getEngine().getAspectRatio(I),z=E.cameraSensorWidth||35;return`def Camera "${j}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${w}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${I.Te.toPrecision(E.precision)}, ${I.maxZ.toPrecision(E.precision)})\n\t\t\tfloat focalLength = ${(z/(2*Math.tan(.5*I.fov))).toPrecision(E.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(z*e).toPrecision(E.precision)}\n\t\t\tfloat verticalAperture = ${(z/e).toPrecision(E.precision)}            \n\t\t}\n\t\n\t`}}(I.activeCamera,z)),t+="\n            }\n        }\n    }";const R={};t+=function(I,E,j){const e=[];for(const w in I){const z=I[w];e.push(Ij(z,E,j))}return`\n    def "Materials"\n{\n${e.join("")}\n}\n\n`}(U,R,z),h[z.modelFileName]=fflate.strToU8(t);for(const e in R){const I=R[e],E=I.getSize(),j=await I.readPixels();if(!j)throw new Error("Texture data is not available");const w=await G.DumpTools.DumpDataAsync(E.width,E.height,j,"image/png",void 0,!1,!0);h[`textures/Texture_${e}.png`]=new Uint8Array(w).slice()}let P=0;for(const e in h){const I=h[e];if(!I)continue;P+=34+e.length;const E=63&P;if(4!==E){const j=new Uint8Array(64-E);h[e]=[I,{extra:{12345:j}}]}P=I.length}return fflate.zipSync(h,{level:0})}}}]);