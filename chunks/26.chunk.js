"use strict";(self["6xhfpmwgjr5"]=self["6xhfpmwgjr5"]||[]).push([[26],{12802:(P,a,R)=>{R.r(a),R.d(a,{EXT_materials_diffuse_roughness:()=>oa,EXT_mesh_gpu_instancing:()=>iP,GLTF2Export:()=>TP,GLTFData:()=>Q,KHR_draco_mesh_compression:()=>Ra,KHR_lights_punctual:()=>Ua,KHR_materials_anisotropy:()=>la,KHR_materials_clearcoat:()=>fa,KHR_materials_diffuse_transmission:()=>ya,KHR_materials_dispersion:()=>Wa,KHR_materials_emissive_strength:()=>xa,KHR_materials_ior:()=>da,KHR_materials_iridescence:()=>Ha,KHR_materials_sheen:()=>Na,KHR_materials_specular:()=>La,KHR_materials_transmission:()=>ua,KHR_materials_unlit:()=>Ja,KHR_materials_volume:()=>ba,KHR_texture_transform:()=>va,OBJExport:()=>p,STLExport:()=>Ma,USDZExportAsync:()=>aR,_ConvertToGLTFPBRMetallicRoughness:()=>Y,_SolveMetallic:()=>u,__IGLTFExporterExtension:()=>j});var S=R(12415),A=R(12225),Z=R(12726);class p{static OBJ(P,a,R,p){const j=[];let U=1,Q=1;a&&(R||(R="mat"),j.push("mtllib "+R+".mtl"));for(let h=0;h<P.length;h++){const R=P[h],l=R.name||`mesh${h}}`;j.push(`o ${l}`);let V=null;if(p){const P=R.hj(!0);V=new S.Matrix,P.invertToRef(V),R.bakeTransformIntoVertices(P)}if(a){const P=R.material;P&&j.push("usemtl "+P.id)}const f=R.lj;if(!f){A.Tools.Warn("No geometry is present on the mesh");continue}const O=f.getVerticesData("position"),q=f.getVerticesData("normal"),y=f.getVerticesData("uv"),t=f.Vj();let W=0,k=0;if(!O||!t){A.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const x=P[0].GP().useRightHandedSystem?1:-1;for(let P=0;P<O.length;P+=3)j.push("v "+O[P]*x+" "+O[P+1]+" "+O[P+2]),W++;if(null!=q)for(let P=0;P<q.length;P+=3)j.push("vn "+q[P]*x+" "+q[P+1]+" "+q[P+2]);if(null!=y)for(let P=0;P<y.length;P+=2)j.push("vt "+y[P]+" "+y[P+1]),k++;const s=["","",""],d=(R.material||R.GP().defaultMaterial)._getEffectiveOrientation(R),[G,H]=d===Z.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let P=0;P<t.length;P+=3){const a=[String(t[P]+U),String(t[P+G]+U),String(t[P+H]+U)],R=[String(t[P]+Q),String(t[P+G]+Q),String(t[P+H]+Q)],S=a,A=null!=y?R:s,Z=null!=q?a:s;j.push("f "+S[0]+"/"+A[0]+"/"+Z[0]+" "+S[1]+"/"+A[1]+"/"+Z[1]+" "+S[2]+"/"+A[2]+"/"+Z[2])}p&&V&&R.bakeTransformIntoVertices(V),U+=W,Q+=k}return j.join("\n")}static MTL(P){const a=[],R=P.material;a.push("newmtl mat1"),a.push("  Ns "+R.specularPower.toFixed(4)),a.push("  Ni 1.5000"),a.push("  d "+R.alpha.toFixed(4)),a.push("  Tr 0.0000"),a.push("  Tf 1.0000 1.0000 1.0000"),a.push("  illum 2"),a.push("  Ka "+R.ambientColor.r.toFixed(4)+" "+R.ambientColor.g.toFixed(4)+" "+R.ambientColor.b.toFixed(4)),a.push("  Kd "+R.diffuseColor.r.toFixed(4)+" "+R.diffuseColor.g.toFixed(4)+" "+R.diffuseColor.b.toFixed(4)),a.push("  Ks "+R.specularColor.r.toFixed(4)+" "+R.specularColor.g.toFixed(4)+" "+R.specularColor.b.toFixed(4)),a.push("  Ke "+R.emissiveColor.r.toFixed(4)+" "+R.emissiveColor.g.toFixed(4)+" "+R.emissiveColor.b.toFixed(4));R.ambientTexture&&a.push("  map_Ka "+R.ambientTexture.name),R.diffuseTexture&&a.push("  map_Kd "+R.diffuseTexture.name),R.specularTexture&&a.push("  map_Ks "+R.specularTexture.name),R.bumpTexture&&a.push("  map_bump -imfchan z "+R.bumpTexture.name),R.opacityTexture&&a.push("  map_d "+R.opacityTexture.name);return a.join("\n")}}var j=0,U=R(12285);class Q{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const P in this.files){const a=this.files[P],R=new Blob([a],{type:(0,U.j)(P)});A.Tools.Download(R,P)}}}var h=R(12489),l=R(12805),V=R(12809),f=R(12823),O=R(12551),q=R(12277),y=R(12456),t=R(12430);const W=t.HighestCommonFactor,k={...t,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:W};var x=R(12626),s=R(12399),d=R(12844),G=R(12851),H=R(12621);const mP=1e-6,N=new y.Wa(.04,.04,.04),D=1024,L=y.Wa.White(),c=y.Wa.Black();function u(P,a,R){if(a<N.r)return 0;const S=N.r,A=P*R/(1-N.r)+a-2*N.r,Z=A*A-4*S*(N.r-a);return k.Clamp((-A+Math.sqrt(Z))/(2*S),0,1)}function Y(P){const a=P.diffuseColor.toLinearSpace(P.GP().getEngine().useExactSrgbConversions).scale(.5),R=P.alpha,A=function(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new S.Vector2(0,1),R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new S.Vector2(0,.1),A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new S.Vector2(0,.1),Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new S.Vector2(1300,.1);return function(P,a,R,S,A){return(1-P)*(1-P)*(1-P)*a+3*(1-P)*(1-P)*P*R+3*(1-P)*P*P*S+P*P*P*A}(Math.pow(P/Z.x,.333333),a.y,R.y,A.y,Z.y)}(k.Clamp(P.specularPower,0,D));return{baseColorFactor:[a.r,a.g,a.b,R],metallicFactor:0,roughnessFactor:A}}function J(P,a){a.needAlphaBlending()?P.alphaMode="BLEND":a.needAlphaTesting()&&(P.alphaMode="MASK",P.alphaCutoff=a.alphaCutOff)}function n(P,a,R){const S=new Uint8Array(P*a*4);for(let A=0;A<S.length;A+=4)S[A]=S[A+1]=S[A+2]=S[A+3]=255;return d.b.CreateRGBATexture(S,P,a,R)}function b(P){if(P instanceof Uint8Array){const a=P.length,R=new Float32Array(P.length);for(let S=0;S<a;++S)R[S]=P[S]/255;return R}if(P instanceof Float32Array)return P;throw new Error("Unsupported pixel format!")}class B{constructor(P){this._exporter=P,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(P){return P?this._textureMap.get(P)??null:null}async exportStandardMaterialAsync(P,a,R){const S=Y(P),Z={name:P.name};if(null==P.fj||P.fj||(P.twoSidedLighting||A.Tools.Warn(P.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Z.doubleSided=!0),R){const R=[],A=P.diffuseTexture;A&&R.push(this.exportTextureAsync(A,a).then((P=>{P&&(S.baseColorTexture=P)})));const p=P.bumpTexture;p&&R.push(this.exportTextureAsync(p,a).then((P=>{P&&(Z.normalTexture=P,1!==p.level&&(Z.normalTexture.scale=p.level))})));const j=P.emissiveTexture;j&&(Z.emissiveFactor=[1,1,1],R.push(this.exportTextureAsync(j,a).then((P=>{P&&(Z.emissiveTexture=P)}))));const U=P.ambientTexture;U&&R.push(this.exportTextureAsync(U,a).then((P=>{if(P){const a={index:P.index};Z.occlusionTexture=a}}))),R.length>0&&(this._exporter._materialNeedsUVsSet.add(P),await Promise.all(R))}(P.alpha<1||P.opacityTexture)&&(P.alphaMode===G.d.ALPHA_COMBINE?Z.alphaMode="BLEND":A.Tools.Warn(P.name+": glTF 2.0 does not support alpha mode: "+P.alphaMode.toString())),P.emissiveColor&&!P.emissiveColor.equalsWithEpsilon(c,mP)&&(Z.emissiveFactor=P.emissiveColor.pj()),Z.pbrMetallicRoughness=S,J(Z,P),await this._finishMaterialAsync(Z,P,a);const p=this._exporter._materials;return p.push(Z),p.length-1}async _finishMaterialAsync(P,a,R){const S=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",P,a),A=[];for(const Z of S)A.push(this.exportTextureAsync(Z,R));await Promise.all(A),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",P,a)}async _getImageDataAsync(P,a,S,A){const Z=G.d.TEXTURETYPE_UNSIGNED_BYTE,p=this._exporter._babylonScene,j=p.getEngine(),U=j.createRawTexture(P,a,S,G.d.TEXTUREFORMAT_RGBA,!1,!0,s.e.NEAREST_SAMPLINGMODE,null,Z);j.isWebGPU?await R.e(51).then(R.bind(R,15746)):await R.e(52).then(R.bind(R,15748)),await x.k.ApplyPostProcess("pass",U,p,Z,G.d.TEXTURE_NEAREST_SAMPLINGMODE,G.d.TEXTUREFORMAT_RGBA);const Q=await j._readTexturePixels(U,a,S);return await H.DumpTools.DumpDataAsync(a,S,Q,A,void 0,!0,!0)}_resizeTexturesToSameDimensions(P,a,R){const S=P?P.getSize():{width:0,height:0},A=a?a.getSize():{width:0,height:0};let Z,p;return S.width<A.width?(Z=P&&P instanceof s.e?x.k.CreateResizedCopy(P,A.width,A.height,!0):n(A.width,A.height,R),p=a):S.width>A.width?(p=a&&a instanceof s.e?x.k.CreateResizedCopy(a,S.width,S.height,!0):n(S.width,S.height,R),Z=P):(Z=P,p=a),{texture1:Z,texture2:p}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(P,a,R,S){const A=new Array;if(!P&&!a)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const Z=P?P.GP():a?a.GP():null;if(Z){var p;const j=this._resizeTexturesToSameDimensions(P,a,Z),U=null===(p=j.texture1)||void 0===p?void 0:p.getSize();let Q,h;const l=U.width,V=U.height,f=await j.texture1.readPixels(),O=await j.texture2.readPixels();if(!f)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(Q=b(f),!O)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");h=b(O);const q=h.byteLength,t=new Uint8Array(q),W=new Uint8Array(q),k=4,x=c;let s=0,d=0;for(let P=0;P<V;++P)for(let a=0;a<l;++a){const S=(l*P+a)*k,A={diffuseColor:new y.Wa(Q[S],Q[S+1],Q[S+2]).toLinearSpace(Z.getEngine().useExactSrgbConversions).multiply(R.diffuseColor),specularColor:new y.Wa(h[S],h[S+1],h[S+2]).toLinearSpace(Z.getEngine().useExactSrgbConversions).multiply(R.specularColor),glossiness:h[S+3]*R.glossiness},p=this._convertSpecularGlossinessToMetallicRoughness(A);x.r=Math.max(x.r,p.baseColor.r),x.g=Math.max(x.g,p.baseColor.g),x.b=Math.max(x.b,p.baseColor.b),s=Math.max(s,p.metallic),d=Math.max(d,p.roughness),W[S]=255*p.baseColor.r,W[S+1]=255*p.baseColor.g,W[S+2]=255*p.baseColor.b,W[S+3]=j.texture1.jj?255*Q[S+3]:255,t[S]=0,t[S+1]=255*p.roughness,t[S+2]=255*p.metallic,t[S+3]=255}const G={baseColor:x,metallic:s,roughness:d};let H=!1,N=!1;for(let P=0;P<V;++P)for(let a=0;a<l;++a){const R=(l*P+a)*k;W[R]/=G.baseColor.r>mP?G.baseColor.r:1,W[R+1]/=G.baseColor.g>mP?G.baseColor.g:1,W[R+2]/=G.baseColor.b>mP?G.baseColor.b:1;const S=y.Wa.FromInts(W[R],W[R+1],W[R+2]).toGammaSpace(Z.getEngine().useExactSrgbConversions);W[R]=255*S.r,W[R+1]=255*S.g,W[R+2]=255*S.b,S.equalsWithEpsilon(L,mP)||(N=!0),t[R+1]/=G.roughness>mP?G.roughness:1,t[R+2]/=G.metallic>mP?G.metallic:1;y.Wa.FromInts(255,t[R+1],t[R+2]).equalsWithEpsilon(L,mP)||(H=!0)}return H&&A.push(this._getImageDataAsync(t,l,V,S).then((P=>{G.metallicRoughnessTextureData=P}))),N&&A.push(this._getImageDataAsync(W,l,V,S).then((P=>{G.baseColorTextureData=P}))),await Promise.all(A).then((()=>G))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(P){const a=this._getPerceivedBrightness(P.diffuseColor),R=this._getPerceivedBrightness(P.specularColor),S=1-this._getMaxComponent(P.specularColor),A=u(a,R,S),Z=P.diffuseColor.scale(S/(1-N.r)/Math.max(1-A)),p=P.specularColor.qa(N.scale(1-A)).scale(1/Math.max(A));let j=y.Wa.Lerp(Z,p,A*A);j=j.clampToRef(0,1,j);return{baseColor:j,metallic:A,roughness:1-P.glossiness}}_getPerceivedBrightness(P){return P?Math.sqrt(.299*P.r*P.r+.587*P.g*P.g+.114*P.b*P.b):0}_getMaxComponent(P){return P?Math.max(P.r,Math.max(P.g,P.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(P,a,R,S){const A=[],Z={baseColor:P._albedoColor,metallic:P._metallic,roughness:P._roughness};if(S){P._albedoTexture&&A.push(this.exportTextureAsync(P._albedoTexture,a).then((P=>{P&&(R.baseColorTexture=P)})));const S=P._metallicTexture;S&&A.push(this.exportTextureAsync(S,a).then((P=>{P&&(R.metallicRoughnessTexture=P)})))}return A.length>0&&(this._exporter._materialNeedsUVsSet.add(P),await Promise.all(A)),Z}_getTextureSampler(P){const a={};if(!P||!(P instanceof s.e))return a;const R=this._getGLTFTextureWrapMode(P.wrapU);10497!==R&&(a.wrapS=R);const S=this._getGLTFTextureWrapMode(P.wrapV);switch(10497!==S&&(a.wrapT=S),P.samplingMode){case s.e.LINEAR_LINEAR:a.magFilter=9729,a.minFilter=9729;break;case s.e.LINEAR_NEAREST:a.magFilter=9729,a.minFilter=9728;break;case s.e.NEAREST_LINEAR:a.magFilter=9728,a.minFilter=9729;break;case s.e.NEAREST_LINEAR_MIPLINEAR:a.magFilter=9728,a.minFilter=9987;break;case s.e.NEAREST_NEAREST:a.magFilter=9728,a.minFilter=9728;break;case s.e.NEAREST_LINEAR_MIPNEAREST:a.magFilter=9728,a.minFilter=9985;break;case s.e.LINEAR_NEAREST_MIPNEAREST:a.magFilter=9729,a.minFilter=9984;break;case s.e.LINEAR_NEAREST_MIPLINEAR:a.magFilter=9729,a.minFilter=9986;break;case s.e.NEAREST_NEAREST_MIPLINEAR:a.magFilter=9728,a.minFilter=9986;break;case s.e.LINEAR_LINEAR_MIPLINEAR:a.magFilter=9729,a.minFilter=9987;break;case s.e.LINEAR_LINEAR_MIPNEAREST:a.magFilter=9729,a.minFilter=9985;break;case s.e.NEAREST_NEAREST_MIPNEAREST:a.magFilter=9728,a.minFilter=9984}return a}_getGLTFTextureWrapMode(P){switch(P){case s.e.WRAP_ADDRESSMODE:return 10497;case s.e.CLAMP_ADDRESSMODE:return 33071;case s.e.MIRROR_ADDRESSMODE:return 33648;default:return A.Tools.Error(`Unsupported Texture Wrap Mode ${P}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(P,a,R,S){const A={diffuseColor:P._albedoColor,specularColor:P._reflectivityColor,glossiness:P._microSurface},Z=P._albedoTexture,p=P._reflectivityTexture,j=P._useMicroSurfaceFromReflectivityMapAlpha;if(p&&!j)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((Z||p)&&S){this._exporter._materialNeedsUVsSet.add(P);const S=this._exportTextureSampler(Z||p),j=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Z,p,A,a),U=this._exporter._textures;if(j.baseColorTextureData){const P=this._exportImage(`baseColor${U.length}`,a,j.baseColorTextureData);R.baseColorTexture=this._exportTextureInfo(P,S,null===Z||void 0===Z?void 0:Z.coordinatesIndex)}if(j.metallicRoughnessTextureData){const P=this._exportImage(`metallicRoughness${U.length}`,a,j.metallicRoughnessTextureData);R.metallicRoughnessTexture=this._exportTextureInfo(P,S,null===p||void 0===p?void 0:p.coordinatesIndex)}return j}return this._convertSpecularGlossinessToMetallicRoughness(A)}async exportPBRMaterialAsync(P,a,R){const S={},A={name:P.name},Z=P.isMetallicWorkflow();if(Z){const a=P._albedoColor,R=P.alpha;a&&(S.baseColorFactor=[a.r,a.g,a.b,R])}const p=Z?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(P,a,S,R):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(P,a,S,R);await this._setMetallicRoughnessPbrMaterialAsync(p,P,A,S,a,R),await this._finishMaterialAsync(A,P,a);const j=this._exporter._materials;return j.push(A),j.length-1}async _setMetallicRoughnessPbrMaterialAsync(P,a,R,S,Z,p){if(J(R,a),P.baseColor.equalsWithEpsilon(L,mP)&&k.WithinEpsilon(a.alpha,1,mP)||(S.baseColorFactor=[P.baseColor.r,P.baseColor.g,P.baseColor.b,a.alpha]),null!=P.metallic&&1!==P.metallic&&(S.metallicFactor=P.metallic),null!=P.roughness&&1!==P.roughness&&(S.roughnessFactor=P.roughness),null==a.fj||a.fj||(a._twoSidedLighting||A.Tools.Warn(a.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),R.doubleSided=!0),p){const P=[],S=a._bumpTexture;S&&P.push(this.exportTextureAsync(S,Z).then((P=>{P&&(R.normalTexture=P,1!==S.level&&(R.normalTexture.scale=S.level))})));const A=a._ambientTexture;A&&P.push(this.exportTextureAsync(A,Z).then((P=>{if(P){const S={index:P.index,texCoord:P.texCoord,extensions:P.extensions};R.occlusionTexture=S;const A=a._ambientTextureStrength;A&&(S.strength=A)}})));const p=a._emissiveTexture;p&&P.push(this.exportTextureAsync(p,Z).then((P=>{P&&(R.emissiveTexture=P)}))),P.length>0&&(this._exporter._materialNeedsUVsSet.add(a),await Promise.all(P))}const j=a._emissiveColor;j.equalsWithEpsilon(c,mP)||(R.emissiveFactor=j.pj()),R.pbrMetallicRoughness=S}_getPixelsFromTextureAsync(P){return function(P){switch(P){case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case G.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(P.textureFormat)?(0,x.i)(P,P._texture.width,P._texture.height):(P.textureType,G.d.TEXTURETYPE_UNSIGNED_BYTE,P.readPixels())}async exportTextureAsync(P,a){const R=this._exporter._extensionsPreExportTextureAsync("exporter",P,a);return R?await R.then((async R=>R?await this._exportTextureInfoAsync(R,a):await this._exportTextureInfoAsync(P,a))):await this._exportTextureInfoAsync(P,a)}async _exportTextureInfoAsync(P,a){let R=this._textureMap.get(P);if(!R){const S=await this._getPixelsFromTextureAsync(P);if(!S)return null;const Z=this._exportTextureSampler(P),p=P.mimeType;if(p)switch(p){case"image/jpeg":case"image/png":case"image/webp":a=p;break;default:A.Tools.Warn(`Unsupported media type: ${p}. Exporting texture as PNG.`)}const j=this._internalTextureToImage,U=P.getInternalTexture().uniqueId;j[U]||(j[U]={});let Q=j[U][a];if(void 0===Q){const R=P.getSize();Q=(async()=>{const A=await this._getImageDataAsync(S,R.width,R.height,a);return this._exportImage(P.name,a,A)})(),j[U][a]=Q}R=this._exportTextureInfo(await Q,Z,P.coordinatesIndex),this._textureMap.set(P,R),this._exporter._extensionsPostExportTextures("exporter",R,P)}return R}_exportImage(P,a,R){const S=this._exporter._images;let Z;if(this._exporter._shouldUseGlb){Z={name:P,mimeType:a,bufferView:void 0};const S=this._exporter._bufferManager.createBufferView(new Uint8Array(R));this._exporter._bufferManager.setBufferView(Z,S)}else{const p=P.replace(/\.\/|\/|\.\\|\\/g,"_"),j=function(P){switch(P){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(a);let U=p+j;S.some((P=>P.uri===U))&&(U=`${p}_${A.Tools.RandomId()}${j}`),Z={name:P,uri:U},this._exporter._imageData[U]={data:R,mimeType:a}}return S.push(Z),S.length-1}_exportTextureInfo(P,a,R){const S=this._exporter._textures;let A=S.findIndex((R=>R.sampler==a&&R.source===P));-1===A&&(A=S.length,S.push({source:P,sampler:a}));const Z={index:A};return R&&(Z.texCoord=R),Z}_exportTextureSampler(P){const a=this._getTextureSampler(P),R=this._exporter._samplers,S=R.findIndex((P=>P.minFilter===a.minFilter&&P.magFilter===a.magFilter&&P.wrapS===a.wrapS&&P.wrapT===a.wrapT));return-1!==S?S:(R.push(a),R.length-1)}}var o=R(12500),r=R(12248),v=R(12860),M=R(12418);const E=S.Oa.Zero(),e=S.Quaternion.Identity(),w=S.Oa.One(),T=new S.Oa(-1,1,1);function I(P,a){const{byteOffset:R,byteStride:S,type:A,normalized:Z}=P,p=P.getSize(),j=a.reduce(((P,a)=>a.getTotalVertices()>P?a.getTotalVertices():P),-Number.MAX_VALUE);return{byteOffset:R,byteStride:S,componentCount:p,type:A,count:j*p,normalized:Z,totalVertices:j,kind:P.getKind()}}function i(P){switch(P){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function X(P){switch(P){case h.i.PositionKind:case h.i.NormalKind:case h.i.TangentKind:case h.i.ColorKind:case h.i.MatricesIndicesKind:case h.i.MatricesIndicesExtraKind:case h.i.MatricesWeightsKind:case h.i.MatricesWeightsExtraKind:case h.i.UVKind:case h.i.UV2Kind:case h.i.UV3Kind:case h.i.UV4Kind:case h.i.UV5Kind:case h.i.UV6Kind:return!0}return!1}function C(P){switch(P){case Z.e.TriangleFillMode:return 4;case Z.e.TriangleStripDrawMode:return 5;case Z.e.TriangleFanDrawMode:return 6;case Z.e.PointListDrawMode:case Z.e.PointFillMode:return 0;case Z.e.LineLoopDrawMode:return 2;case Z.e.LineListDrawMode:return 1;case Z.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${P}`)}function z(P){const a=Math.sqrt(P.x*P.x+P.y*P.y+P.z*P.z);a>0&&(P.x/=a,P.y/=a,P.z/=a)}function K(P){return P.x*=-1,P}function F(P){if(P.x*P.x+P.y*P.y>.5){const a=Math.abs(P.x),R=Math.abs(P.y);if(a>R){const R=Math.sign(P.x);P.x=a,P.y*=-R,P.z*=-R,P.w*=R}else{const a=Math.sign(P.y);P.x*=-a,P.y=R,P.z*=a,P.w*=-a}}else{const a=Math.abs(P.z),R=Math.abs(P.w);if(a>R){const R=Math.sign(P.z);P.x*=-R,P.y*=R,P.z=a,P.w*=-R}else{const a=Math.sign(P.w);P.x*=a,P.y*=-a,P.z*=-a,P.w=R}}return P}function g(P){P.Oj(-P.z,P.w,P.x,-P.y)}function PP(P,a){const R=S.Oa.FromArrayToRef(a.translation||[0,0,0],0,S.TmpVectors.Oa[0]),A=S.Quaternion.FromArrayToRef(a.rotation||[0,0,0,1],0,S.TmpVectors.Quaternion[0]),Z=S.Matrix.ComposeToRef(w,A,R,S.TmpVectors.Matrix[0]),p=S.Oa.FromArrayToRef(P.translation||[0,0,0],0,S.TmpVectors.Oa[2]),j=S.Quaternion.FromArrayToRef(P.rotation||[0,0,0,1],0,S.TmpVectors.Quaternion[1]),U=S.Matrix.ComposeToRef(w,j,p,S.TmpVectors.Matrix[1]);Z.multiplyToRef(U,U),U.decompose(void 0,A,R),R.equalsWithEpsilon(E,M.c)?delete a.translation:a.translation=R.pj(),A.equalsWithEpsilon(e,M.c)?delete a.rotation:a.rotation=A.pj(),a.scale&&delete a.scale}function aP(P,a){if(!(a instanceof l.c))return!1;if(!(1===a.getChildren().length&&0===P.getChildren().length&&P.parent===a))return!1;const R=P.GP(),S=P instanceof v.d&&!R.useRightHandedSystem?T:w;return!!a.qj.equalsWithEpsilon(S,M.c)||(r.c.Warn(`Cannot collapse node ${P.name} into parent node ${a.name} with modified scaling.`),!1)}function RP(P){if(P instanceof Array){const a=new Float32Array(P);return new Uint8Array(a.buffer,a.byteOffset,a.byteLength)}return ArrayBuffer.isView(P)?new Uint8Array(P.buffer,P.byteOffset,P.byteLength):new Uint8Array(P)}function SP(P,a){for(const[R,S]of Object.entries(P)){const A=a[R];(Array.isArray(S)&&Array.isArray(A)&&AP(S,A)||S===A)&&delete P[R]}return P}function AP(P,a){return P.length===a.length&&P.every(((P,R)=>P===a[R]))}const ZP=S.Matrix.Compose(new S.Oa(-1,1,1),S.Quaternion.Identity(),S.Oa.Zero());function pP(P,a){if(!(P instanceof l.c))return!1;if(a){if(!P.getWorldMatrix().equalsWithEpsilon(S.Matrix.IdentityReadOnly,M.c))return!1}else{if(!P.getWorldMatrix().multiplyToRef(ZP,S.TmpVectors.Matrix[0]).equalsWithEpsilon(S.Matrix.IdentityReadOnly,M.c))return!1}return!(P instanceof V.b&&P.lj)}const jP=new Map([[Int8Array,(P,a,R)=>P.setInt8(a,R)],[Uint8Array,(P,a,R)=>P.setUint8(a,R)],[Uint8ClampedArray,(P,a,R)=>P.setUint8(a,R)],[Int16Array,(P,a,R)=>P.setInt16(a,R,!0)],[Uint16Array,(P,a,R)=>P.setUint16(a,R,!0)],[Int32Array,(P,a,R)=>P.setInt32(a,R,!0)],[Uint32Array,(P,a,R)=>P.setUint32(a,R,!0)],[Float32Array,(P,a,R)=>P.setFloat32(a,R,!0)],[Float64Array,(P,a,R)=>P.setFloat64(a,R,!0)]]);class UP{writeTypedArray(P){this._checkGrowBuffer(P.byteLength);const a=jP.get(P.constructor);for(let R=0;R<P.length;R++)a(this._dataView,this._byteOffset,P[R]),this._byteOffset+=P.BYTES_PER_ELEMENT}constructor(P){this._data=new Uint8Array(P),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(P){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,P),this._byteOffset++}writeInt8(P){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,P),this._byteOffset++}writeInt16(P){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,P,!0),this._byteOffset+=2}writeUInt16(P){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,P,!0),this._byteOffset+=2}writeInt32(P){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,P,!0),this._byteOffset+=4}writeUInt32(P){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,P,!0),this._byteOffset+=4}writeFloat32(P){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,P,!0),this._byteOffset+=4}writeFloat64(P){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,P,!0),this._byteOffset+=8}_checkGrowBuffer(P){const a=this.byteOffset+P;if(a>this._data.byteLength){const P=new Uint8Array(2*a);P.set(this._data),this._data=P,this._dataView=new DataView(this._data.buffer)}}}function QP(P){return P%4===0?4:P%2===0?2:1}class hP{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(P){let a=0;this._bufferViewToData.forEach((P=>{a+=P.byteLength}));const R=new UP(a),S=Array.from(this._bufferViewToData.keys()).sort(((P,a)=>QP(a.byteLength)-QP(P.byteLength)));for(const A of S){A.byteOffset=R.byteOffset,P.push(A);const a=P.length-1,S=this.getPropertiesWithBufferView(A);for(const P of S)P.bufferView=a;R.writeTypedArray(this._bufferViewToData.get(A)),this._bufferViewToData.delete(A)}return R.getOutputData()}createBufferView(P,a){const R={buffer:0,byteOffset:void 0,byteLength:P.byteLength,byteStride:a};return this._bufferViewToData.set(R,P),R}createAccessor(P,a,R,S,A,Z,p){this._verifyBufferView(P);const j={bufferView:void 0,componentType:R,count:S,type:a,min:null===Z||void 0===Z?void 0:Z.min,max:null===Z||void 0===Z?void 0:Z.max,normalized:p,byteOffset:A};return this.setBufferView(j,P),this._accessorToBufferView.set(j,P),j}setBufferView(P,a){this._verifyBufferView(a);this.getPropertiesWithBufferView(a).push(P)}removeBufferView(P){const a=this.getPropertiesWithBufferView(P);for(const R of a)void 0!==R.bufferView&&delete R.bufferView;this._bufferViewToData.delete(P),this._bufferViewToProperties.delete(P),this._accessorToBufferView.forEach(((a,R)=>{a===P&&(void 0!==R.byteOffset&&delete R.byteOffset,this._accessorToBufferView.delete(R))}))}getBufferView(P){const a=this._accessorToBufferView.get(P);return this._verifyBufferView(a),a}getPropertiesWithBufferView(P){return this._verifyBufferView(P),this._bufferViewToProperties.set(P,this._bufferViewToProperties.get(P)??[]),this._bufferViewToProperties.get(P)}getData(P){return this._verifyBufferView(P),this._bufferViewToData.get(P)}_verifyBufferView(P){if(void 0===P||!this._bufferViewToData.has(P))throw new Error(`BufferView ${P} not found in BufferManager.`)}}var lP,VP=R(12828),fP=R(12840),OP=R(12865),qP=R(12764),yP=R(12909),tP=R(12926),WP=R(12826),kP=R(12932);!function(P){P[P.INTANGENT=0]="INTANGENT",P[P.OUTTANGENT=1]="OUTTANGENT"}(lP||(lP={}));class xP{static _IsTransformable(P){return P&&(P instanceof l.c||P instanceof VP.d||P instanceof kP.d)}static _CreateNodeAnimation(P,a,R,S,Z){if(this._IsTransformable(P)){const p=[],j=[],U=a.getKeys(),Q=xP._CalculateMinMaxKeyFrames(U),h=xP._DeduceInterpolation(U,R,S),l=h.interpolationType,V=h.shouldBakeAnimation;if(V?xP._CreateBakedAnimation(P,a,R,Q.min,Q.max,a.framePerSecond,Z,p,j,Q,S):"LINEAR"===l||"STEP"===l?xP._CreateLinearOrStepAnimation(P,a,R,p,j,S):"CUBICSPLINE"===l?xP._CreateCubicSplineAnimation(P,a,R,p,j,S):xP._CreateBakedAnimation(P,a,R,Q.min,Q.max,a.framePerSecond,Z,p,j,Q,S),p.length&&j.length){return{inputs:p,outputs:j,samplerInterpolation:l,inputsMin:V?Q.min:A.Tools.FloatRound(Q.min/a.framePerSecond),inputsMax:V?Q.max:A.Tools.FloatRound(Q.max/a.framePerSecond)}}}return null}static _DeduceAnimationInfo(P){let a=null,R="VEC3",S=!1;const Z=P.targetProperty.split(".");switch(Z[0]){case"qj":a="scale";break;case"position":a="translation";break;case"rotation":R="VEC4",a="rotation";break;case"rotationQuaternion":R="VEC4",S=!0,a="rotation";break;case"influence":R="SCALAR",a="weights";break;default:A.Tools.Error(`Unsupported animatable property ${Z[0]}`)}return a?{animationChannelTargetPath:a,dataAccessorType:R,useQuaternion:S}:(A.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(P,a,R,S,A,Z,p,j,U,Q,h){let l;if(xP._IsTransformable(P)&&P.animations)for(const V of P.animations){if(h&&!h(V))continue;const A=xP._DeduceAnimationInfo(V);A&&(l={name:V.name,samplers:[],channels:[]},xP._AddAnimation(`${V.name}`,V.hasRunningRuntimeAnimations?a:l,P,V,A.dataAccessorType,A.animationChannelTargetPath,S,Z,p,j,A.useQuaternion,U,Q),l.samplers.length&&l.channels.length&&R.push(l))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(P,a,R,S,A,Z,p,j,U,Q,h){let l;if(P instanceof WP.c){const A=P.morphTargetManager;if(A)for(let V=0;V<A.numTargets;++V){const f=A.getTarget(V);for(const O of f.animations){if(h&&!h(O))continue;const f=new yP.e(`${O.name}`,"influence",O.framePerSecond,O.dataType,O.loopMode,O.enableBlending),q=[],y=O.getKeys();for(let P=0;P<y.length;++P){const a=y[P];for(let P=0;P<A.numTargets;++P)P==V?q.push(a):q.push({frame:a.frame,value:0})}f.setKeys(q);const t=xP._DeduceAnimationInfo(f);t&&(l={name:f.name,samplers:[],channels:[]},xP._AddAnimation(O.name,O.hasRunningRuntimeAnimations?a:l,P,f,t.dataAccessorType,t.animationChannelTargetPath,S,Z,p,j,t.useQuaternion,U,Q,A.numTargets),l.samplers.length&&l.channels.length&&R.push(l))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(P,a,R,S,A,Z,p,j,U){let Q;if(P.animationGroups){const l=P.animationGroups;for(const V of l){const l=new Map,f=new Map,O=new Set,q=V.to-V.from;Q={name:V.name,channels:[],samplers:[]};for(let a=0;a<V.targetedAnimations.length;++a){const q=V.targetedAnimations[a],y=q.target,t=q.animation;if(U&&!U(t))continue;const W=j.has(y);if(this._IsTransformable(y)||1===y.length&&this._IsTransformable(y[0])){const P=xP._DeduceAnimationInfo(q.animation);if(P){const a=this._IsTransformable(y)?y:this._IsTransformable(y[0])?y[0]:null;a&&xP._AddAnimation(`${t.name}`,Q,a,t,P.dataAccessorType,P.animationChannelTargetPath,R,S,A,Z,P.useQuaternion,p,W)}}else if(y instanceof tP.e||1===y.length&&y[0]instanceof tP.e){if(xP._DeduceAnimationInfo(q.animation)){const a=y instanceof tP.e?y:y[0];if(a){const R=P.morphTargetManagers.find((P=>{for(let R=0;R<P.numTargets;++R)if(P.getTarget(R)===a)return!0;return!1}));if(R){const S=P.meshes.find((P=>P.morphTargetManager===R));var h;if(S)l.has(S)||l.set(S,new Map),null===(h=l.get(S))||void 0===h||h.set(a,t),O.add(S),f.set(S,t)}}}}}O.forEach((P=>{const a=P.morphTargetManager;let j=null;const U=[],h=f.get(P).getKeys(),O=h.length;for(let R=0;R<O;++R)for(let S=0;S<a.numTargets;++S){const A=a.getTarget(S),Z=l.get(P);if(Z){const a=Z.get(A);a?(j||(j=new yP.e(`${V.name}_${P.name}_MorphWeightAnimation`,"influence",a.framePerSecond,yP.e.ANIMATIONTYPE_FLOAT,a.loopMode,a.enableBlending)),U.push(a.getKeys()[R])):U.push({frame:V.from+q/O*R,value:A.influence,inTangent:h[0].inTangent?0:void 0,outTangent:h[0].outTangent?0:void 0})}}j.setKeys(U);const y=xP._DeduceAnimationInfo(j);y&&xP._AddAnimation(`${V.name}_${P.name}_MorphWeightAnimation`,Q,P,j,y.dataAccessorType,y.animationChannelTargetPath,R,S,A,Z,y.useQuaternion,p,!1,null===a||void 0===a?void 0:a.numTargets)})),Q.channels.length&&Q.samplers.length&&a.push(Q)}}}static _AddAnimation(P,a,R,A,Z,p,j,U,Q,h,l,V,f,O){const q=xP._CreateNodeAnimation(R,A,p,l,V);let y,t,W,k,x,s;if(q){if(O){let P=0,a=0;const R=[];for(;q.inputs.length>0;)a=q.inputs.shift(),P%O==0&&R.push(a),P++;q.inputs=R}const P=j.get(R),A=new Float32Array(q.inputs);y=U.createBufferView(A),t=U.createAccessor(y,"SCALAR",5126,q.inputs.length,void 0,{min:[q.inputsMin],max:[q.inputsMax]}),h.push(t),W=h.length-1;const Q=new S.Quaternion,l=new S.Oa,V=new S.Oa,d=R instanceof VP.d,G=i(Z),H=new Float32Array(q.outputs.length*G);q.outputs.forEach((function(P,a){let R=P;switch(p){case"translation":f&&(S.Oa.FromArrayToRef(P,0,V),K(V),V.toArray(R));break;case"rotation":4===P.length?S.Quaternion.FromArrayToRef(P,0,Q):(R=new Array(4),S.Oa.FromArrayToRef(P,0,l),S.Quaternion.FromEulerVectorToRef(l,Q)),f&&(F(Q),d&&g(Q)),Q.toArray(R)}H.set(R,a*G)})),y=U.createBufferView(H),t=U.createAccessor(y,Z,5126,q.outputs.length),h.push(t),k=h.length-1,x={interpolation:q.samplerInterpolation,input:W,output:k},a.samplers.push(x),s={sampler:a.samplers.length-1,target:{node:P,path:p}},a.channels.push(s)}}static _CreateBakedAnimation(P,a,R,Z,p,j,U,Q,h,l,V){let f;const O=S.Quaternion.Identity();let q,y=null,t=null,W=null,k=null,x=null,s=null;l.min=A.Tools.FloatRound(Z/j);const d=a.getKeys();for(let S=0,G=d.length;S<G;++S){if(s=null,W=d[S],S+1<G)if(k=d[S+1],W.value.equals&&W.value.equals(k.value)||W.value===k.value){if(0!==S)continue;s=W.frame}else s=k.frame;else{if(x=d[S-1],W.value.equals&&W.value.equals(x.value)||W.value===x.value)continue;s=p}if(s)for(let S=W.frame;S<=s;S+=U){if(q=A.Tools.FloatRound(S/j),q===y)continue;y=q,t=q;const Z={key:0,repeatCount:0,loopMode:a.loopMode};f=a._interpolate(S,Z),xP._SetInterpolatedValue(P,f,q,a,R,O,Q,h,V)}}t&&(l.max=t)}static _ConvertFactorToVector3OrQuaternion(P,a,R,Z,p){const j=xP._GetBasePositionRotationOrScale(a,Z,p),U=R.targetProperty.split("."),Q=U?U[1]:"",h=p?S.Quaternion.ka(j).normalize():S.Oa.ka(j);switch(Q){case"x":case"y":case"z":h[Q]=P;break;case"w":h.w=P;break;default:A.Tools.Error(`glTFAnimation: Unsupported component name "${Q}"!`)}return h}static _SetInterpolatedValue(P,a,R,A,Z,p,j,U,Q){let h;j.push(R),"weights"!==Z?(A.dataType===yP.e.ANIMATIONTYPE_FLOAT&&(a=this._ConvertFactorToVector3OrQuaternion(a,P,A,Z,Q)),"rotation"===Z?(Q?p=a:(h=a,S.Quaternion.RotationYawPitchRollToRef(h.y,h.x,h.z,p)),U.push(p.pj())):(h=a,U.push(h.pj()))):U.push([a])}static _CreateLinearOrStepAnimation(P,a,R,S,A,Z){for(const p of a.getKeys())S.push(p.frame/a.framePerSecond),xP._AddKeyframeValue(p,a,A,R,P,Z)}static _CreateCubicSplineAnimation(P,a,R,S,A,Z){a.getKeys().forEach((function(p){S.push(p.frame/a.framePerSecond),xP._AddSplineTangent(lP.INTANGENT,A,R,"CUBICSPLINE",p,Z),xP._AddKeyframeValue(p,a,A,R,P,Z),xP._AddSplineTangent(lP.OUTTANGENT,A,R,"CUBICSPLINE",p,Z)}))}static _GetBasePositionRotationOrScale(P,a,R){let A;if("rotation"===a)if(R){A=(P.rotationQuaternion??S.Quaternion.Identity()).pj()}else{A=(P.rotation??S.Oa.Zero()).pj()}else if("translation"===a){A=(P.position??S.Oa.Zero()).pj()}else{A=(P.qj??S.Oa.One()).pj()}return A}static _AddKeyframeValue(P,a,R,Z,p,j){let U;const Q=a.dataType;if(Q===yP.e.ANIMATIONTYPE_VECTOR3){let a=P.value.pj();if("rotation"===Z){const P=S.Oa.ka(a);a=S.Quaternion.RotationYawPitchRoll(P.y,P.x,P.z).pj()}R.push(a)}else if(Q===yP.e.ANIMATIONTYPE_FLOAT){if("weights"===Z)R.push([P.value]);else if(U=this._ConvertFactorToVector3OrQuaternion(P.value,p,a,Z,j),U){if("rotation"===Z){const P=j?U:S.Quaternion.RotationYawPitchRoll(U.y,U.x,U.z).normalize();R.push(P.pj())}R.push(U.pj())}}else Q===yP.e.ANIMATIONTYPE_QUATERNION?R.push(P.value.normalize().pj()):A.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(P,a,R){let S,A,Z=!1;if("rotation"===a&&!R)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let p=0,j=P.length;p<j;++p)if(A=P[p],A.inTangent||A.outTangent)if(S){if("CUBICSPLINE"!==S){S="LINEAR",Z=!0;break}}else S="CUBICSPLINE";else if(S){if("CUBICSPLINE"===S||A.interpolation&&1===A.interpolation&&"STEP"!==S){S="LINEAR",Z=!0;break}}else S=A.interpolation&&1===A.interpolation?"STEP":"LINEAR";return S||(S="LINEAR"),{interpolationType:S,shouldBakeAnimation:Z}}static _AddSplineTangent(P,a,R,A,Z,p){let j;const U=P===lP.INTANGENT?Z.inTangent:Z.outTangent;if("CUBICSPLINE"===A){if("rotation"===R)if(U)if(p)j=U.pj();else{const P=U;j=S.Quaternion.RotationYawPitchRoll(P.y,P.x,P.z).pj()}else j=[0,0,0,0];else j="weights"===R?U?[U]:[0]:U?U.pj():[0,0,0];a.push(j)}}static _CalculateMinMaxKeyFrames(P){let a=1/0,R=-1/0;return P.forEach((function(P){a=Math.min(a,P.frame),R=Math.max(R,P.frame)})),{min:a,max:R}}}function sP(P,a,R,Z,p,j){const U={attributes:{},influence:P.influence,name:P.name},Q=a.lj;if(!Q)return A.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),U;const l=j?-1:1,V=S.Oa.Zero();let f=0,O=0;if(P.hasPositions){const Z=P.getPositions(),j=Q.getVerticesData(h.i.PositionKind);if(j){const P=new Float32Array(j.length),a=[1/0,1/0,1/0],A=[-1/0,-1/0,-1/0];O=j.length/3,f=0;for(let R=f;R<O;++R){const p=S.Oa.ka(j,3*R);S.Oa.ka(Z,3*R).subtractToRef(p,V),V.x*=l,a[0]=Math.min(a[0],V.x),A[0]=Math.max(A[0],V.x),a[1]=Math.min(a[1],V.y),A[1]=Math.max(A[1],V.y),a[2]=Math.min(a[2],V.z),A[2]=Math.max(A[2],V.z),P[3*R]=V.x,P[3*R+1]=V.y,P[3*R+2]=V.z}const Q=R.createBufferView(P,12),h=R.createAccessor(Q,"VEC3",5126,Z.length/3,0,{min:a,max:A});p.push(h),U.attributes.POSITION=p.length-1}else A.Tools.Warn(`Morph target positions for mesh ${a.name} were not exported. Mesh does not have position vertex data`)}if(P.hasNormals){const Z=P.getNormals(),j=Q.getVerticesData(h.i.NormalKind);if(j){const P=new Float32Array(j.length);O=j.length/3,f=0;for(let R=f;R<O;++R){const a=S.Oa.ka(j,3*R).normalize();S.Oa.ka(Z,3*R).normalize().subtractToRef(a,V),P[3*R]=V.x*l,P[3*R+1]=V.y,P[3*R+2]=V.z}const a=R.createBufferView(P,12),A=R.createAccessor(a,"VEC3",5126,Z.length/3,0);p.push(A),U.attributes.NORMAL=p.length-1}else A.Tools.Warn(`Morph target normals for mesh ${a.name} were not exported. Mesh does not have normals vertex data`)}if(P.hasTangents){const Z=P.getTangents(),j=Q.getVerticesData(h.i.TangentKind);if(j){O=j.length/4;const P=new Float32Array(3*O);f=0;for(let R=f;R<O;++R){const a=S.Oa.ka(j,4*R);z(a);const A=S.Oa.ka(Z,3*R);z(A),A.subtractToRef(a,V),P[3*R]=V.x*l,P[3*R+1]=V.y,P[3*R+2]=V.z}const a=R.createBufferView(P,12),A=R.createAccessor(a,"VEC3",5126,O,0);p.push(A),U.attributes.TANGENT=p.length-1}else A.Tools.Warn(`Morph target tangents for mesh ${a.name} were not exported. Mesh does not have tangents vertex data`)}if(P.hasColors){const Z=P.getColors(),j=Q.getVerticesData(h.i.ColorKind),l=Q.getVertexBuffer(h.i.ColorKind);if(j&&l){const P=l.getSize();O=j.length/P;const a=new Float32Array(O*P);f=0;for(let R=f;R<O;++R)if(3===P){const A=S.Oa.ka(j,R*P);S.Oa.ka(Z,R*P).subtractToRef(A,V),a[3*R]=V.x,a[3*R+1]=V.y,a[3*R+2]=V.z}else if(4===P){const A=new S.Vector4,p=S.Vector4.ka(j,R*P);S.Vector4.ka(Z,R*P).subtractToRef(p,A),a[4*R]=A.x,a[4*R+1]=A.y,a[4*R+2]=A.z,a[4*R+3]=A.w}else A.Tools.Warn(`Unsupported number of components for color attribute: ${P}`);const Q=R.createBufferView(a,4*P),h=R.createAccessor(Q,3===P?"VEC3":"VEC4",5126,O,0);p.push(h),U.attributes.COLOR_0=p.length-1}else A.Tools.Warn(`Morph target colors for mesh ${a.name} were not exported. Mesh does not have colors vertex data`)}return U}var dP=R(12938),GP=R(12798),HP=R(12778),ma=R(12376);class NP{}NP.DEFAULT_COLOR=y.Wa.White(),NP.DEFAULT_WIDTH_ATTENUATED=1,NP.DEFAULT_WIDTH=.1;var DP=R(12610),LP=R(12942);class cP{static ConvertPoints(P,a){if(P.length&&Array.isArray(P)&&"number"===typeof P[0])return[P];if(P.length&&Array.isArray(P[0])&&"number"===typeof P[0][0])return P;if(P.length&&!Array.isArray(P[0])&&P[0]instanceof S.Oa){const a=[];for(let R=0;R<P.length;R++){const S=P[R];a.push(S.x,S.y,S.z)}return[a]}if(P.length>0&&Array.isArray(P[0])&&P[0].length>0&&P[0][0]instanceof S.Oa){const a=[],R=P;for(const P of R)a.push(P.flatMap((P=>[P.x,P.y,P.z])));return a}if(P instanceof Float32Array){if(null!==a&&void 0!==a&&a.floatArrayStride){const R=[],S=3*a.floatArrayStride;for(let a=0;a<P.length;a+=S){const A=new Array(S);for(let R=0;R<S;R++)A[R]=P[a+R];R.push(A)}return R}return[Array.from(P)]}if(P.length&&P[0]instanceof Float32Array){const a=[];for(const R of P)a.push(Array.from(R));return a}return[]}static OmitZeroLengthPredicate(P,a,R){const S=[];return a.qa(P).lengthSquared()>0&&S.push([P,a]),R.qa(a).lengthSquared()>0&&S.push([a,R]),P.qa(R).lengthSquared()>0&&S.push([R,P]),0===S.length?null:S}static OmitDuplicatesPredicate(P,a,R,S){const A=[];return cP._SearchInPoints(P,a,S)||A.push([P,a]),cP._SearchInPoints(a,R,S)||A.push([a,R]),cP._SearchInPoints(R,P,S)||A.push([R,P]),0===A.length?null:A}static _SearchInPoints(P,a,R){for(const p of R)for(let R=0;R<p.length;R++){var S,A,Z;if(null!==(S=p[R])&&void 0!==S&&S.equals(P))if(null!==(A=p[R+1])&&void 0!==A&&A.equals(a)||null!==(Z=p[R-1])&&void 0!==Z&&Z.equals(a))return!0}return!1}static MeshesToLines(P,a){const R=[];for(let A=0;A<P.length;A++){const Z=P[A],p=Z.getVerticesData(h.i.PositionKind),j=Z.Vj();if(p&&j)for(let P=0,U=0;P<j.length;P++){const Q=3*j[U++],h=3*j[U++],l=3*j[U++],V=new S.Oa(p[Q],p[Q+1],p[Q+2]),f=new S.Oa(p[h],p[h+1],p[h+2]),O=new S.Oa(p[l],p[l+1],p[l+2]);if(a){const S=a(V,f,O,R,P,Q,Z,A,p,j);if(S)for(const P of S)R.push(P)}else R.push([V,f],[f,O],[O,V])}}return R}static ToVector3Array(P){if(Array.isArray(P[0])){const a=[],R=P;for(const P of R){const R=[];for(let a=0;a<P.length;a+=3)R.push(new S.Oa(P[a],P[a+1],P[a+2]));a.push(R)}return a}const a=P,R=[];for(let A=0;A<a.length;A+=3)R.push(new S.Oa(a[A],a[A+1],a[A+2]));return R}static ToNumberArray(P){return P.flatMap((P=>[P.x,P.y,P.z]))}static GetPointsCountInfo(P){const a=new Array(P.length);let R=0;for(let S=P.length;S--;)a[S]=P[S].length/3,R+=a[S];return{total:R,counts:a}}static GetLineLength(P){if(0===P.length)return 0;let a;a="number"===typeof P[0]?cP.ToVector3Array(P):P;const R=S.TmpVectors.Oa[0];let A=0;for(let S=0;S<a.length-1;S++){const P=a[S];A+=a[S+1].subtractToRef(P,R).length()}return A}static GetLineLengthArray(P){const a=new Float32Array(P.length/3);let R=0;for(let S=0,A=P.length/3-1;S<A;S++){let A=P[3*S+0],Z=P[3*S+1],p=P[3*S+2];A-=P[3*S+3],Z-=P[3*S+4],p-=P[3*S+5];R+=Math.sqrt(A*A+Z*Z+p*p),a[S+1]=R}return a}static SegmentizeSegmentByCount(P,a,R){const A=[],Z=a.qa(P),p=S.TmpVectors.Oa[0];p.yj(R);const j=S.TmpVectors.Oa[1];Z.divideToRef(p,j);let U=P.clone();A.push(U);for(let S=0;S<R;S++)U=U.clone(),A.push(U.addInPlace(j));return A}static SegmentizeLineBySegmentLength(P,a){const R=P[0]instanceof S.Oa?cP.GetLineSegments(P):"number"===typeof P[0]?cP.GetLineSegments(cP.ToVector3Array(P)):P,A=[];for(const S of R)if(S.length>a){const P=cP.SegmentizeSegmentByCount(S.point1,S.point2,Math.ceil(S.length/a));for(const a of P)A.push(a)}else A.push(S.point1),A.push(S.point2);return A}static SegmentizeLineBySegmentCount(P,a){const R="number"===typeof P[0]?cP.ToVector3Array(P):P,S=cP.GetLineLength(R)/a;return cP.SegmentizeLineBySegmentLength(R,S)}static GetLineSegments(P){const a=[];for(let R=0;R<P.length-1;R++){const S=P[R],A=P[R+1],Z=A.qa(S).length();a.push({point1:S,point2:A,length:Z})}return a}static GetMinMaxSegmentLength(P){const a=cP.GetLineSegments(P).sort((P=>P.length));return{min:a[0].length,max:a[a.length-1].length}}static GetPositionOnLineByVisibility(P,a,R){let A=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const Z=a*R;let p=0,j=0;const U=P.length;for(let S=0;S<U;S++){if(Z<=p+P[S].length){j=S;break}p+=P[S].length}const Q=(Z-p)/P[j].length;return P[j].point2.subtractToRef(P[j].point1,S.TmpVectors.Oa[0]),S.TmpVectors.Oa[1]=S.TmpVectors.Oa[0].multiplyByFloats(Q,Q,Q),A||S.TmpVectors.Oa[1].addInPlace(P[j].point1),S.TmpVectors.Oa[1].clone()}static GetCircleLinePoints(P,a){let R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P,Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/a;const p=[];for(let j=0;j<=a;j++)p.push(new S.Oa(Math.cos(j*Z)*P,Math.sin(j*Z)*A,R));return p}static GetBezierLinePoints(P,a,R,S){return DP.g.CreateQuadraticBezier(P,a,R,S).getPoints().flatMap((P=>[P.x,P.y,P.z]))}static GetArrowCap(P,a,R,S,A){let Z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,p=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[P.clone(),P.add(a.multiplyByFloats(R,R,R))],widths:[S,A,Z,p]}}static GetPointsFromText(P,a,R,S){let A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,Z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const p=[],j=(0,LP.b)(P,a,R,S);for(const U of j){for(const P of U.paths){const a=[],R=P.getPoints();for(const P of R)a.push(P.x,P.y,A);p.push(a)}if(Z)for(const P of U.holes){const a=[],R=P.getPoints();for(const P of R)a.push(P.x,P.y,A);p.push(a)}}return p}static Color3toRGBAUint8(P){const a=new Uint8Array(4*P.length);for(let R=0,S=0;R<P.length;R++)a[S++]=255*P[R].r,a[S++]=255*P[R].g,a[S++]=255*P[R].b,a[S++]=255;return a}static CreateColorsTexture(P,a,R,S){const A=S.getEngine().getCaps().maxTextureSize??1,Z=a.length>A?A:a.length,p=Math.ceil(a.length/A);p>1&&(a=[...a,...Array(Z*p-a.length).fill(a[0])]);const j=cP.Color3toRGBAUint8(a),U=new d.b(j,Z,p,O.d.TEXTUREFORMAT_RGBA,S,!1,!0,R);return U.name=P,U}static PrepareEmptyColorsTexture(P){if(!NP.EmptyColorsTexture){const a=new Uint8Array(4);NP.EmptyColorsTexture=new d.b(a,1,1,O.d.TEXTUREFORMAT_RGBA,P,!1,!1,d.b.NEAREST_NEAREST),NP.EmptyColorsTexture.name="grlEmptyColorsTexture"}return NP.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var P;null===(P=NP.EmptyColorsTexture)||void 0===P||P.dispose(),NP.EmptyColorsTexture=null}static BooleanToNumber(P){return P?1:0}}class uP extends HP.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class YP extends GP.d{isCompatible(P){return!0}constructor(P,a,R){var A;R=R||{color:NP.DEFAULT_COLOR};const Z=new uP;Z.GREASED_LINE_HAS_COLOR=!!R.color&&!R.useColors,Z.GREASED_LINE_SIZE_ATTENUATION=R.sizeAttenuation??!1,Z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===R.colorDistributionType,Z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(a??P.GP()).useRightHandedSystem,Z.GREASED_LINE_CAMERA_FACING=R.cameraFacing??!0,super(P,YP.GREASED_LINE_MATERIAL_NAME,200,Z,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(A=R)||void 0===A?void 0:A.forceGLSL)||YP.ForceGLSL,this._scene=a??P.GP(),this._engine=this._scene.getEngine(),this._cameraFacing=R.cameraFacing??!0,this.visibility=R.visibility??1,this.useDash=R.useDash??!1,this.dashRatio=R.dashRatio??.5,this.dashOffset=R.dashOffset??0,this.width=R.width?R.width:R.sizeAttenuation?NP.DEFAULT_WIDTH_ATTENUATED:NP.DEFAULT_WIDTH,this._sizeAttenuation=R.sizeAttenuation??!1,this.colorMode=R.colorMode??0,this._color=R.color??null,this.useColors=R.useColors??!1,this._colorsDistributionType=R.colorDistributionType??0,this.colorsSampling=R.colorsSampling??d.b.NEAREST_NEAREST,this._colors=R.DP??null,this.dashCount=R.dashCount??1,this.resolution=R.resolution??new S.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),R.colorsTexture?this.colorsTexture=R.colorsTexture:this._colors?this.colorsTexture=cP.CreateColorsTexture(`${P.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??NP.DEFAULT_COLOR,cP.PrepareEmptyColorsTexture(this._scene)),this._engine.Fp.add((()=>{cP.DisposeEmptyColorsTexture()}))}getAttributes(P){P.push("grl_offsets"),P.push("grl_widths"),P.push("grl_colorPointers"),P.push("grl_counters"),this._cameraFacing?(P.push("grl_previousAndSide"),P.push("grl_nextAndCounters")):P.push("grl_slopes")}getSamplers(P){P.push("grl_colors")}getActiveTextures(P){this.colorsTexture&&P.push(this.colorsTexture)}getUniforms(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const a=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&a.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===P&&a.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:a,vertex:this._cameraFacing&&this._isGLSL(P)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(P)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(P){if(this._cameraFacing){P.Qj("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||P.Qj("viewProjection",this._scene.getTransformMatrix());const a=S.TmpVectors.Vector4[0];a.x=this._aspect,a.y=this._resolution.x,a.z=this._resolution.y,a.w=this.width,P.updateVector4("grl_aspect_resolution_lineWidth",a)}const a=S.TmpVectors.Vector4[0];a.x=cP.BooleanToNumber(this.useDash),a.y=this._dashArray,a.z=this.dashOffset,a.w=this.dashRatio,P.updateVector4("grl_dashOptions",a);const R=S.TmpVectors.Vector4[1];R.x=this.colorMode,R.y=this.visibility,R.z=this.colorsTexture?this.colorsTexture.getSize().width:0,R.w=cP.BooleanToNumber(this.useColors),P.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",R),this._color&&P.updateColor3("grl_singleColor",this._color);const A=this.colorsTexture??NP.EmptyColorsTexture;P.setTexture("grl_colors",A),P.updateFloat2("grl_textureSize",(null===A||void 0===A?void 0:A.getSize().width)??1,(null===A||void 0===A?void 0:A.getSize().height)??1)}prepareDefines(P,a,R){P.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,P.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,P.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,P.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=a.useRightHandedSystem,P.GREASED_LINE_CAMERA_FACING=this._cameraFacing,P.GREASED_LINE_USE_OFFSETS=!!R.offsets}getClassName(){return YP.GREASED_LINE_MATERIAL_NAME}getCustomCode(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(a)?function(P,a){if("vertex"===P){const P={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return a&&(P["!gl_Position\\=viewProjection\\*worldPos;"]="//"),P}return"fragment"===P?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(P,this._cameraFacing):function(P,a){if("vertex"===P){const P={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return a&&(P["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),P}return"fragment"===P?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(P,this._cameraFacing)}dispose(){var P;null===(P=this.colorsTexture)||void 0===P||P.dispose(),super.dispose()}get DP(){return this._colors}set DP(P){this.setColors(P)}setColors(P){var a;let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1],S=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const A=(null===(a=this._colors)||void 0===a?void 0:a.length)??0;var Z;if(this._colors=P,null!==P&&0!==P.length){if(!R||S)if(this.colorsTexture&&A===P.length&&!S){const a=cP.Color3toRGBAUint8(P);this.colorsTexture.update(a)}else{var p;null===(p=this.colorsTexture)||void 0===p||p.dispose(),this.colorsTexture=cP.CreateColorsTexture(`${this._material.name}-colors-texture`,P,this.colorsSampling,this._scene)}}else null===(Z=this.colorsTexture)||void 0===Z||Z.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(P){this._dashCount=P,this._dashArray=1/P}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(P){this._sizeAttenuation=P,this.markAllDefinesAsDirty()}get color(){return this._color}set color(P){this.setColor(P)}setColor(P){let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==P||null!==this._color&&null===P?(this._color=P,a||this.markAllDefinesAsDirty()):this._color=P}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(P){this._colorsDistributionType=P,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(P){this._aspect=P.x/P.y,this._resolution=P}serialize(){const P=super.serialize(),a={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(a.DP=this._colors),this._color&&(a.color=this._color),P.greasedLineMaterialOptions=a,P}parse(P,a,R){var S;super.parse(P,a,R);const A=P.greasedLineMaterialOptions;null===(S=this.colorsTexture)||void 0===S||S.dispose(),A.color&&this.setColor(A.color,!0),A.colorDistributionType&&(this.colorsDistributionType=A.colorDistributionType),A.DP&&(this.DP=A.DP),A.colorsSampling&&(this.colorsSampling=A.colorsSampling),A.colorMode&&(this.colorMode=A.colorMode),A.useColors&&(this.useColors=A.useColors),A.visibility&&(this.visibility=A.visibility),A.useDash&&(this.useDash=A.useDash),A.dashCount&&(this.dashCount=A.dashCount),A.dashRatio&&(this.dashRatio=A.dashRatio),A.dashOffset&&(this.dashOffset=A.dashOffset),A.width&&(this.width=A.width),A.sizeAttenuation&&(this.sizeAttenuation=A.sizeAttenuation),A.resolution&&(this.resolution=A.resolution),this.DP?this.colorsTexture=cP.CreateColorsTexture(`${this._material.name}-colors-texture`,this.DP,this.colorsSampling,a):cP.PrepareEmptyColorsTexture(a),this.markAllDefinesAsDirty()}copyTo(P){var a;const R=P;null===(a=R.colorsTexture)||void 0===a||a.dispose(),this._colors&&(R.colorsTexture=cP.CreateColorsTexture(`${R._material.name}-colors-texture`,this._colors,R.colorsSampling,this._scene)),R.setColor(this.color,!0),R.colorsDistributionType=this.colorsDistributionType,R.colorsSampling=this.colorsSampling,R.colorMode=this.colorMode,R.useColors=this.useColors,R.visibility=this.visibility,R.useDash=this.useDash,R.dashCount=this.dashCount,R.dashRatio=this.dashRatio,R.dashOffset=this.dashOffset,R.width=this.width,R.sizeAttenuation=this.sizeAttenuation,R.resolution=this.resolution,R.markAllDefinesAsDirty()}_isGLSL(P){return 0===P||this._forceGLSL}}YP.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",YP.ForceGLSL=!1,(0,ma.d)(`BABYLON.${YP.GREASED_LINE_MATERIAL_NAME}`,YP);var JP=R(12814),nP=R(12252),bP=R(12628),BP=R(12365);class oP extends bP.ShaderMaterial{constructor(P,a,A){const Z=a.getEngine(),p=Z.isWebGPU&&!(A.forceGLSL||oP.ForceGLSL),j=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];a.useRightHandedSystem&&j.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const U=["position","grl_widths","grl_offsets","grl_colorPointers"];A.cameraFacing?(j.push("GREASED_LINE_CAMERA_FACING"),U.push("grl_previousAndSide","grl_nextAndCounters")):(U.push("grl_slopes"),U.push("grl_counters"));const Q=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(p||Q.push("world","viewProjection","view","projection"),super(P,a,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:p?["Scene","Mesh"]:void 0,attributes:U,uniforms:Q,samplers:p?[]:["grlColors"],defines:j,extraInitializationsAsync:async()=>{p?await Promise.all([R.e(66).then(R.bind(R,16380)),R.e(75).then(R.bind(R,16386))]):await Promise.all([R.e(69).then(R.bind(R,16388)),R.e(76).then(R.bind(R,16390))])},shaderLanguage:p?1:0}),this._color=y.Wa.White(),this._colorsDistributionType=0,this._colorsTexture=null,A=A||{color:NP.DEFAULT_COLOR},this.visibility=A.visibility??1,this.useDash=A.useDash??!1,this.dashRatio=A.dashRatio??.5,this.dashOffset=A.dashOffset??0,this.dashCount=A.dashCount??1,this.width=A.width?A.width:A.sizeAttenuation&&A.cameraFacing?NP.DEFAULT_WIDTH_ATTENUATED:NP.DEFAULT_WIDTH,this.sizeAttenuation=A.sizeAttenuation??!1,this.color=A.color??y.Wa.White(),this.useColors=A.useColors??!1,this.colorsDistributionType=A.colorDistributionType??0,this.colorsSampling=A.colorsSampling??d.b.NEAREST_NEAREST,this.colorMode=A.colorMode??0,this._colors=A.DP??null,this._cameraFacing=A.cameraFacing??!0,this.resolution=A.resolution??new S.Vector2(Z.getRenderWidth(),Z.getRenderHeight()),A.colorsTexture?this.colorsTexture=A.colorsTexture:this._colors?this.colorsTexture=cP.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,a):(this._color=this._color??NP.DEFAULT_COLOR,this.colorsTexture=cP.PrepareEmptyColorsTexture(a)),p){const P=new BP.b;P.setParameters(),P.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",P)}Z.Fp.add((()=>{cP.DisposeEmptyColorsTexture()}))}dispose(){var P;null===(P=this._colorsTexture)||void 0===P||P.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new S.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get DP(){return this._colors}set DP(P){this.setColors(P)}setColors(P){var a;let R=arguments.length>1&&void 0!==arguments[1]&&arguments[1],S=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const A=(null===(a=this._colors)||void 0===a?void 0:a.length)??0;var Z;if(this._colors=P,null!==P&&0!==P.length){if(!R||S)if(this._colorsTexture&&A===P.length&&!S){const a=cP.Color3toRGBAUint8(P);this._colorsTexture.update(a)}else{var p;null===(p=this._colorsTexture)||void 0===p||p.dispose(),this.colorsTexture=cP.CreateColorsTexture(`${this.name}-colors-texture`,P,this.colorsSampling,this.GP())}}else null===(Z=this._colorsTexture)||void 0===Z||Z.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(P){this._colorsTexture=P,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(P){this._width=P,this.setFloat("grlWidth",P)}get useColors(){return this._useColors}set useColors(P){this._useColors=P,this.setFloat("grlUseColors",cP.BooleanToNumber(P))}get colorsSampling(){return this._colorsSampling}set colorsSampling(P){this._colorsSampling=P}get visibility(){return this._visibility}set visibility(P){this._visibility=P,this.setFloat("grlVisibility",P)}get useDash(){return this._useDash}set useDash(P){this._useDash=P,this.setFloat("grlUseDash",cP.BooleanToNumber(P))}get dashOffset(){return this._dashOffset}set dashOffset(P){this._dashOffset=P,this.setFloat("grlDashOffset",P)}get dashRatio(){return this._dashRatio}set dashRatio(P){this._dashRatio=P,this.setFloat("grlDashRatio",P)}get dashCount(){return this._dashCount}set dashCount(P){this._dashCount=P,this._dashArray=1/P,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(P){this._sizeAttenuation=P,this.setFloat("grlSizeAttenuation",cP.BooleanToNumber(P))}get color(){return this._color}set color(P){this.setColor(P)}setColor(P){P=P??NP.DEFAULT_COLOR,this._color=P,this.setColor3("grlColor",P)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(P){this._colorsDistributionType=P,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(P){this._colorMode=P,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(P){this._resolution=P,this.setVector2("grlResolution",P),this.setFloat("grlAspect",P.x/P.y)}serialize(){const P=super.serialize(),a={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(a.DP=this._colors),P.greasedLineMaterialOptions=a,P}parse(P,a,R){var S;const A=P.greasedLineMaterialOptions;null===(S=this._colorsTexture)||void 0===S||S.dispose(),A.color&&(this.color=A.color),A.colorDistributionType&&(this.colorsDistributionType=A.colorDistributionType),A.colorsSampling&&(this.colorsSampling=A.colorsSampling),A.colorMode&&(this.colorMode=A.colorMode),A.useColors&&(this.useColors=A.useColors),A.visibility&&(this.visibility=A.visibility),A.useDash&&(this.useDash=A.useDash),A.dashCount&&(this.dashCount=A.dashCount),A.dashRatio&&(this.dashRatio=A.dashRatio),A.dashOffset&&(this.dashOffset=A.dashOffset),A.width&&(this.width=A.width),A.sizeAttenuation&&(this.sizeAttenuation=A.sizeAttenuation),A.resolution&&(this.resolution=A.resolution),A.DP?this.colorsTexture=cP.CreateColorsTexture(`${this.name}-colors-texture`,A.DP,this.colorsSampling,this.GP()):this.colorsTexture=cP.PrepareEmptyColorsTexture(a),this._cameraFacing=A.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var rP,vP,MP;oP.ForceGLSL=!1,function(P){P[P.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",P[P.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(rP||(rP={})),function(P){P[P.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",P[P.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",P[P.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(vP||(vP={})),function(P){P[P.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",P[P.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",P[P.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",P[P.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",P[P.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(MP||(MP={}));class EP extends WP.c{constructor(P,a,R){super(P,a,null,null,!1,!1),this.name=P,this._options=R,this._lazy=!1,this._updatable=!1,this._engine=a.getEngine(),this._lazy=R.lazy??!1,this._updatable=R.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=R.colorPointers??[],this._widths=R.widths??new Array(R.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(P){let a=0;for(const S of this._points)a+=S.length;const R=a/3*2-this._widths.length;for(let S=0;S<R;S++)this._widths.push(P)}updateLazy(){var P,a;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(P=this._options.ribbonOptions)||void 0===P?void 0:P.smoothShading),!this.YP&&this.refreshBoundingInfo(),null===(a=this.greasedLineMaterial)||void 0===a||a.updateLazy()}addPoints(P,a){for(const R of P)this._points.push(R);this._lazy||this.setPoints(this._points,a)}dispose(P){let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(P,a)}isLazy(){return this._lazy}get LP(){return this._uvs}set LP(P){this._uvs=P instanceof Float32Array?P:new Float32Array(P),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(P){this.material instanceof oP&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===P||void 0===P?void 0:P.length)>0),this._offsets=P,this._offsetsBuffer?this._offsetsBuffer.update(P):this._createOffsetsBuffer(P)}get widths(){return this._widths}set widths(P){this._widths=P,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(P)}get colorPointers(){return this._colorPointers}set colorPointers(P){this._colorPointers=P,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(P)}get greasedLineMaterial(){var P,a;if(this.material&&this.material instanceof oP)return this.material;const R=null===(P=this.material)||void 0===P||null===(a=P.pluginManager)||void 0===a?void 0:a.getPlugin(YP.GREASED_LINE_MATERIAL_NAME);return R||void 0}get points(){const P=[];return nP.c.DeepCopy(this._points,P),P}setPoints(P,a){this._points=cP.ConvertPoints(P,(null===a||void 0===a?void 0:a.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==a&&void 0!==a&&a.colorPointers||this._updateColorPointers(),this._setPoints(this._points,a)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,LP:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(P){super.serialize(P),P.type=this.getClassName(),P.lineOptions=this._createLineOptions()}_createVertexBuffers(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=new JP.c;return a.ma=this._vertexPositions,a.indices=this._indices,a.LP=this._uvs,P&&(a.NP=[],JP.c.ComputeNormals(this._vertexPositions,this._indices,a.NP)),a.uP(this,this._options.updatable),a}_createOffsetsBuffer(P){const a=this._scene.getEngine(),R=new h.e(a,P,this._updatable,3);this.setVerticesBuffer(R.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=R}}class eP{constructor(P,a){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=P,this.wasAddedByNoopNode=a}getIndicesAccessor(P,a,R,S,A){var Z,p,j,U;return null===(Z=this._indicesAccessorMap.get(P))||void 0===Z||null===(p=Z.get(a))||void 0===p||null===(j=p.get(R))||void 0===j||null===(U=j.get(S))||void 0===U?void 0:U.get(A)}setIndicesAccessor(P,a,R,S,A,Z){let p=this._indicesAccessorMap.get(P);p||(p=new Map,this._indicesAccessorMap.set(P,p));let j=p.get(a);j||(j=new Map,p.set(a,j));let U=j.get(R);U||(U=new Map,j.set(R,U));let Q=U.get(S);Q||(Q=new Map,U.set(S,Q)),Q.set(A,Z)}pushExportedNode(P){this._exportedNodes.has(P)||this._exportedNodes.add(P)}getNodesSet(){return this._exportedNodes}getVertexBufferView(P){return this._vertexBufferViewMap.get(P)}setVertexBufferView(P,a){this._vertexBufferViewMap.set(P,a)}setRemappedBufferView(P,a,R){this._remappedBufferView.set(P,new Map),this._remappedBufferView.get(P).set(a,R)}getRemappedBufferView(P,a){var R;return null===(R=this._remappedBufferView.get(P))||void 0===R?void 0:R.get(a)}getVertexAccessor(P,a,R){var S,A;return null===(S=this._vertexAccessorMap.get(P))||void 0===S||null===(A=S.get(a))||void 0===A?void 0:A.get(R)}setVertexAccessor(P,a,R,S){let A=this._vertexAccessorMap.get(P);A||(A=new Map,this._vertexAccessorMap.set(P,A));let Z=A.get(a);Z||(Z=new Map,A.set(a,Z)),Z.set(R,S)}hasVertexColorAlpha(P){return this._vertexMapColorAlpha.get(P)||!1}setHasVertexColorAlpha(P,a){return this._vertexMapColorAlpha.set(P,a)}getMesh(P){return this._meshMap.get(P)}setMesh(P,a){this._meshMap.set(P,a)}bindMorphDataToMesh(P,a){const R=this._meshMorphTargetMap.get(P)||[];this._meshMorphTargetMap.set(P,R),-1===R.indexOf(a)&&R.push(a)}getMorphTargetsFromMesh(P){return this._meshMorphTargetMap.get(P)}}class wP{_ApplyExtension(P,a,R,S){if(R>=a.length)return Promise.resolve(P);const A=S(a[R],P);return A?A.then((async P=>P?await this._ApplyExtension(P,a,R+1,S):null)):this._ApplyExtension(P,a,R+1,S)}_ApplyExtensions(P,a){const R=[];for(const S of wP._ExtensionNames)R.push(this._extensions[S]);return this._ApplyExtension(P,R,0,a)}_extensionsPreExportTextureAsync(P,a,R){return this._ApplyExtensions(a,((a,S)=>a.preExportTextureAsync&&a.preExportTextureAsync(P,S,R)))}_extensionsPostExportNodeAsync(P,a,R,S,A){return this._ApplyExtensions(a,((a,Z)=>a.postExportNodeAsync&&a.postExportNodeAsync(P,Z,R,S,A,this._bufferManager)))}_extensionsPostExportMaterialAsync(P,a,R){return this._ApplyExtensions(a,((a,S)=>a.postExportMaterialAsync&&a.postExportMaterialAsync(P,S,R)))}_extensionsPostExportMaterialAdditionalTextures(P,a,R){const S=[];for(const A of wP._ExtensionNames){const Z=this._extensions[A];Z.postExportMaterialAdditionalTextures&&S.push(...Z.postExportMaterialAdditionalTextures(P,a,R))}return S}_extensionsPostExportTextures(P,a,R){for(const S of wP._ExtensionNames){const A=this._extensions[S];A.postExportTexture&&A.postExportTexture(P,a,R)}}_extensionsPostExportMeshPrimitive(P){for(const a of wP._ExtensionNames){const R=this._extensions[a];R.postExportMeshPrimitive&&R.postExportMeshPrimitive(P,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const P of wP._ExtensionNames){const a=this._extensions[P];a.preGenerateBinaryAsync&&await a.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(P){for(const a of wP._ExtensionNames){const R=this._extensions[a];R.enabled&&P(R)}}_extensionsOnExporting(){this._forEachExtensions((P=>{var a,R,S;P.wasUsed&&((a=this._glTF).extensionsUsed||(a.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(P.name)&&this._glTF.extensionsUsed.push(P.name),P.required&&((R=this._glTF).extensionsRequired||(R.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(P.name)&&this._glTF.extensionsRequired.push(P.name)),(S=this._glTF).extensions||(S.extensions={}),P.onExporting&&P.onExporting())}))}_loadExtensions(){for(const P of wP._ExtensionNames){const a=wP._ExtensionFactories[P](this);this._extensions[P]=a}}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:q.e.LastCreatedScene,a=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${O.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new B(this),this._extensions={},this._bufferManager=new hP,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!P)throw new Error("No scene available to export");this._babylonScene=P,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:P=>{var a;return null===P||void 0===P||null===(a=P.Rj)||void 0===a?void 0:a.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...a},this._loadExtensions()}dispose(){for(const P in this._extensions){this._extensions[P].dispose()}}get options(){return this._options}static RegisterExtension(P,a){wP.UnregisterExtension(P)&&A.Tools.Warn(`Extension with the name ${P} already exists`),wP._ExtensionFactories[P]=a,wP._ExtensionNames.push(P)}static UnregisterExtension(P){if(!wP._ExtensionFactories[P])return!1;delete wP._ExtensionFactories[P];const a=wP._ExtensionNames.indexOf(P);return-1!==a&&wP._ExtensionNames.splice(a,1),!0}_generateJSON(P,a,R){const S={byteLength:P};return S.byteLength&&(this._glTF.buffers=[S]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.ya=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(S.uri=a+".bin"),R?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(P){const a=await this._generateBinaryAsync();this._extensionsOnExporting();const R=this._generateJSON(a.byteLength,P,!0),S=new Blob([a],{type:"application/octet-stream"}),A=P+".gltf",Z=P+".bin",p=new Q;if(p.files[A]=R,p.files[Z]=S,this._imageData)for(const j in this._imageData)p.files[j]=new Blob([this._imageData[j].data],{type:this._imageData[j].mimeType});return p}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(P){const a=P%4;return 0===a?a:4-a}async generateGLBAsync(P){this._shouldUseGlb=!0;const a=await this._generateBinaryAsync();this._extensionsOnExporting();const R=this._generateJSON(a.byteLength),S=P+".glb";let A,Z=R.length;if("undefined"!==typeof TextEncoder){A=(new TextEncoder).encode(R),Z=A.length}const p=this._getPadding(Z),j=this._getPadding(a.byteLength),U=28+Z+p+a.byteLength+j,h=new UP(U);if(h.writeUInt32(1179937895),h.writeUInt32(2),h.writeUInt32(U),h.writeUInt32(Z+p),h.writeUInt32(1313821514),A)h.writeTypedArray(A);else{const P="_".charCodeAt(0);for(let a=0;a<Z;++a){const S=R.charCodeAt(a);S!=R.codePointAt(a)?h.writeUInt8(P):h.writeUInt8(S)}}for(let Q=0;Q<p;++Q)h.writeUInt8(32);h.writeUInt32(a.byteLength+j),h.writeUInt32(5130562),h.writeTypedArray(a);for(let Q=0;Q<j;++Q)h.writeUInt8(0);const l=new Q;return l.files[S]=new Blob([h.getOutputData()],{type:"application/octet-stream"}),l}_setNodeTransformation(P,a,R){if(a.getPivotPoint().equalsWithEpsilon(E,M.c)||A.Tools.Warn("Pivot points are not supported in the glTF serializer"),!a.position.equalsWithEpsilon(E,M.c)){const A=S.TmpVectors.Oa[0].A(a.position);R&&K(A),P.translation=A.pj()}a.qj.equalsWithEpsilon(w,M.c)||(P.scale=a.qj.pj());const Z=a.rotationQuaternion||S.Quaternion.FromEulerAngles(a.rotation.x,a.rotation.y,a.rotation.z);Z.equalsWithEpsilon(e,M.c)||(R&&F(Z),P.rotation=Z.normalize().pj())}_setCameraTransformation(P,a,R){if(!a.position.equalsWithEpsilon(E,M.c)){const A=S.TmpVectors.Oa[0].A(a.position);R&&K(A),P.translation=A.pj()}const A=a.rotationQuaternion||S.Quaternion.FromEulerAngles(a.rotation.x,a.rotation.y,a.rotation.z);R&&F(A),this._babylonScene.useRightHandedSystem||g(A),A.equalsWithEpsilon(e,M.c)||(P.rotation=A.pj())}_listAvailableCameras(){for(const P of this._babylonScene.cameras){const a={type:P.mode===VP.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(P.name&&(a.name=P.name),"perspective"===a.type)a.perspective={aspectRatio:P.getEngine().getAspectRatio(P),yfov:P.fovMode===VP.d.FOVMODE_VERTICAL_FIXED?P.fov:P.fov*P.getEngine().getAspectRatio(P),znear:P.Uj,zfar:P.maxZ};else if("orthographic"===a.type){const R=P.orthoLeft&&P.orthoRight?.5*(P.orthoRight-P.orthoLeft):.5*P.getEngine().getRenderWidth(),S=P.orthoBottom&&P.orthoTop?.5*(P.orthoTop-P.orthoBottom):.5*P.getEngine().getRenderHeight();a.orthographic={xmag:R,ymag:S,znear:P.Uj,zfar:P.maxZ}}this._camerasMap.set(P,a)}}_exportAndAssignCameras(){const P=Array.from(this._camerasMap.values());for(const a of P){const P=this._nodesCameraMap.get(a);if(void 0!==P){this._cameras.push(a);for(const a of P)a.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const P of this._babylonScene.skeletons){if(P.bones.length<=0)continue;const a={joints:[]};this._skinMap.set(P,a)}}_exportAndAssignSkeletons(){for(const P of this._babylonScene.skeletons){if(P.bones.length<=0)continue;const a=this._skinMap.get(P);if(void 0==a)continue;const R={},S=[];let Z=-1;for(let A=0;A<P.bones.length;++A){const a=P.bones[A],S=a.getIndex()??A;-1!==S&&(R[S]=a,S>Z&&(Z=S))}for(let P=0;P<=Z;++P){const Z=R[P];S.push(Z.getAbsoluteInverseBindMatrix());const p=Z.getTransformNode();if(null!==p){const P=this._nodeMap.get(p);p&&null!==P&&void 0!==P?a.joints.push(P):A.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else A.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const p=this._nodesSkinMap.get(a);if(a.joints.length>0&&void 0!==p){const P=64*S.length,R=new Float32Array(P/4);S.forEach(((P,a)=>{R.set(P.m,16*a)}));const A=this._bufferManager.createBufferView(R);this._accessors.push(this._bufferManager.createAccessor(A,"MAT4",5126,S.length)),a.inverseBindMatrices=this._accessors.length-1,this._skins.push(a);for(const a of p)a.skin=this._skins.length-1}}}async _exportSceneAsync(){const P={nodes:[]};if(this._babylonScene.metadata){const a=this._options.metadataSelector(this._babylonScene.metadata);a&&(P.extras=a)}const a=new Array,R=new Array,S=new Array;for(const j of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&pP(j,this._babylonScene.useRightHandedSystem)?S.push(...j.getChildren()):this._babylonScene.useRightHandedSystem?a.push(j):R.push(j);this._listAvailableCameras(),this._listAvailableSkeletons();const A=new eP(!0,!1);P.nodes.push(...await this._exportNodesAsync(R,A));const Z=new eP(!1,!1);P.nodes.push(...await this._exportNodesAsync(a,Z));const p=new eP(!1,!0);P.nodes.push(...await this._exportNodesAsync(S,p)),P.nodes.length&&this._scenes.push(P),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&xP._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,A.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(P){let a=this._shouldExportNodeMap.get(P);return void 0===a&&(a=this._options.shouldExportNode(P),this._shouldExportNodeMap.set(P,a)),a}async _exportNodesAsync(P,a){const R=new Array;this._exportBuffers(P,a);for(const S of P)await this._exportNodeAsync(S,R,a);return R}_collectBuffers(P,a,R,S,A){if(this._shouldExportNode(P)&&P instanceof V.b&&P.lj){const Z=P.lj.getVertexBuffers();if(Z)for(const S in Z){if(!X(S))continue;const p=Z[S];A.setHasVertexColorAlpha(p,P.hasVertexAlpha);const j=p._buffer,U=a.get(j)||[];a.set(j,U),-1===U.indexOf(p)&&U.push(p);const Q=R.get(p)||[];R.set(p,Q),-1===Q.indexOf(P)&&Q.push(P)}const p=P.morphTargetManager;if(p)for(let a=0;a<p.numTargets;a++){const R=p.getTarget(a),A=S.get(R)||[];S.set(R,A),-1===A.indexOf(P)&&A.push(P)}}for(const Z of P.getChildren())this._collectBuffers(Z,a,R,S,A)}_exportBuffers(P,a){const R=new Map,S=new Map,A=new Map;for(const j of P)this._collectBuffers(j,R,S,A,a);const Z=Array.from(R.keys());for(const j of Z){const P=j.getData();if(!P)throw new Error("Buffer data is not available");const A=R.get(j);if(!A)continue;const Z=A[0].byteStride;if(A.some((P=>P.byteStride!==Z)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const p=RP(P).slice();for(const a of A){const P=S.get(a),{byteOffset:R,byteStride:A,componentCount:Z,type:j,count:U,normalized:Q,kind:l}=I(a,P);switch(l){case h.i.NormalKind:case h.i.TangentKind:(0,o.k)(p,R,A,Z,j,U,Q,(P=>{const a=Math.sqrt(P[0]*P[0]+P[1]*P[1]+P[2]*P[2]);if(a>0){const R=1/a;P[0]*=R,P[1]*=R,P[2]*=R}}));break;case h.i.ColorKind:{const a=P.filter((P=>P.material instanceof qP.ta||null==P.material)).length;if(0==a)break;if(a!=P.length){r.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}j==h.i.UNSIGNED_BYTE&&r.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const S=new y.Wa,l=new y.tj,V=this._babylonScene.getEngine().useExactSrgbConversions;(0,o.k)(p,R,A,Z,j,U,Q,(P=>{3===P.length?(S.fR(P,0),S.toLinearSpaceToRef(S,V),S.toArray(P,0)):(l.fR(P,0),l.toLinearSpaceToRef(l,V),l.toArray(P,0))}))}}}if(a.convertToRightHanded){for(const P of A){const a=S.get(P),{byteOffset:R,byteStride:A,componentCount:Z,type:j,count:U,normalized:Q,kind:l}=I(P,a);switch(l){case h.i.PositionKind:case h.i.NormalKind:case h.i.TangentKind:(0,o.k)(p,R,A,Z,j,U,Q,(P=>{P[0]=-P[0]}))}}a.convertedToRightHandedBuffers.set(j,p)}const U=this._bufferManager.createBufferView(p,Z);a.setVertexBufferView(j,U);const Q=new Map;for(const a of A){const P=S.get(a),{kind:R,totalVertices:A}=I(a,P);switch(R){case h.i.MatricesIndicesKind:case h.i.MatricesIndicesExtraKind:if(a.type==h.i.FLOAT){const P=a.getFloatData(A);null!==P&&Q.set(a,P)}}}0!==Q.size&&r.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const l=Array.from(Q.keys());for(const R of l){const P=Q.get(R);if(!P)continue;const S=P.some((P=>P>=256)),A=new(S?Uint16Array:Uint8Array)(P.length);for(let a=0;a<P.length;a++)A[a]=P[a];const Z=this._bufferManager.createBufferView(A,4*(S?2:1));a.setRemappedBufferView(j,R,Z)}}const p=Array.from(A.keys());for(const j of p){const P=A.get(j);if(!P)continue;const R=sP(j,P[0],this._bufferManager,this._bufferViews,this._accessors,a.convertToRightHanded);for(const S of P)a.bindMorphDataToMesh(S,R)}}async _exportNodeAsync(P,a,R){let S=this._nodeMap.get(P);if(void 0!==S)return void(a.includes(S)||a.push(S));const A=await this._createNodeAsync(P,R);if(A){S=this._nodes.length,this._nodes.push(A),this._nodeMap.set(P,S),R.pushExportedNode(P),a.push(S);const Z={name:"runtime animations",channels:[],samplers:[]},p=[];this._babylonScene.animationGroups.length||(xP._CreateMorphTargetAnimationFromMorphTargetAnimations(P,Z,p,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,R.convertToRightHanded,this._options.shouldExportAnimation),P.animations.length&&xP._CreateNodeAnimationFromNodeAnimations(P,Z,p,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,R.convertToRightHanded,this._options.shouldExportAnimation)),Z.channels.length&&Z.samplers.length&&this._animations.push(Z),p.forEach((P=>{P.channels.length&&P.samplers.length&&this._animations.push(P)}))}const Z=A?[]:a;for(const p of P.getChildren())await this._exportNodeAsync(p,Z,R);A&&Z.length&&(A.children=Z)}async _createNodeAsync(P,a){if(!this._shouldExportNode(P))return null;const R={};if(P.name&&(R.name=P.name),P.metadata){const a=this._options.metadataSelector(P.metadata);a&&(R.extras=a)}if(P instanceof l.c&&(this._setNodeTransformation(R,P,a.convertToRightHanded),P instanceof V.b)){const A=P instanceof f.e?P.sourceMesh:P;if(A.Zj&&A.Zj.length>0&&(R.mesh=await this._exportMeshAsync(A,a)),P.skeleton){const a=this._skinMap.get(P.skeleton);var S;if(void 0!==a)void 0===this._nodesSkinMap.get(a)&&this._nodesSkinMap.set(a,[]),null===(S=this._nodesSkinMap.get(a))||void 0===S||S.push(R)}}if(P instanceof v.d){const S=this._camerasMap.get(P);if(S){var A;void 0===this._nodesCameraMap.get(S)&&this._nodesCameraMap.set(S,[]),this._setCameraTransformation(R,P,a.convertToRightHanded);const p=P.parent;if(null!==p&&aP(P,p)){const P=this._nodeMap.get(p);if(void 0!==P){var Z;const a=this._nodes[P];return PP(R,a),null===(Z=this._nodesCameraMap.get(S))||void 0===Z||Z.push(a),null}}null===(A=this._nodesCameraMap.get(S))||void 0===A||A.push(R)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",R,P,this._nodeMap,a.convertToRightHanded)?R:(r.c.Warn(`Not exporting node ${P.name}`),null)}_exportIndices(P,a,R,S,A,p,j,U,Q){let h=P;Q.mode=C(p);const l=j!==Z.e.CounterClockWiseSideOrientation,V=!U.wasAddedByNoopNode&&l,f=function(P){switch(P){case Z.e.TriangleFillMode:case Z.e.TriangleStripDrawMode:case Z.e.TriangleFanDrawMode:return!0}return!1}(p)&&V;if(f){if(p===Z.e.TriangleStripDrawMode||p===Z.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");Q.mode=C(p);const j=a?new Uint32Array(S):new Uint16Array(S);if(P)for(let a=0;a+2<S;a+=3)j[a]=P[R+a]+A,j[a+1]=P[R+a+2]+A,j[a+2]=P[R+a+1]+A;else for(let P=0;P+2<S;P+=3)j[P]=P,j[P+1]=P+2,j[P+2]=P+1;h=j}else if(P&&0!==A){const Z=a?new Uint32Array(S):new Uint16Array(S);for(let a=0;a<S;a++)Z[a]=P[R+a]+A;h=Z}if(h){let Z=U.getIndicesAccessor(P,R,S,A,f);if(void 0===Z){const p=function(P,a,R,S){if(P instanceof Uint16Array||P instanceof Uint32Array)return P;if(P instanceof Int32Array)return new Uint32Array(P.buffer,P.byteOffset,P.length);const A=P.slice(a,a+R);return S?new Uint32Array(A):new Uint16Array(A)}(h,0,S,a),j=this._bufferManager.createBufferView(p),Q=a?5125:5123;this._accessors.push(this._bufferManager.createAccessor(j,"SCALAR",Q,S,0)),Z=this._accessors.length-1,U.setIndicesAccessor(P,R,S,A,f,Z)}Q.indices=Z}}_exportVertexBuffer(P,a,R,S,A,Z){const p=P.getKind();if(!X(p))return;if(p.startsWith("uv")&&!this._options.exportUnusedUVs&&(!a||!this._materialNeedsUVsSet.has(a)))return;let j=A.getVertexAccessor(P,R,S);if(void 0===j){const a=A.convertedToRightHandedBuffers.get(P._buffer)||P._buffer.getData(),Z=p===h.i.PositionKind?function(P,a,R,S){const{byteOffset:A,byteStride:Z,type:p,normalized:j}=a,U=a.getSize(),Q=new Array(U).fill(1/0),h=new Array(U).fill(-1/0);return(0,o.k)(P,A+R*Z,Z,U,p,S*U,j,(P=>{for(let a=0;a<U;a++)Q[a]=Math.min(Q[a],P[a]),h[a]=Math.max(h[a],P[a])})),{min:Q,max:h}}(a,P,R,S):void 0,U=(p===h.i.MatricesIndicesKind||p===h.i.MatricesIndicesExtraKind)&&P.type===h.i.FLOAT,Q=U?h.i.UNSIGNED_BYTE:P.type,l=U?void 0:P.normalized,V=U?A.getRemappedBufferView(P._buffer,P):A.getVertexBufferView(P._buffer),f=P.byteOffset+R*P.byteStride;this._accessors.push(this._bufferManager.createAccessor(V,function(P,a){if(P==h.i.ColorKind)return a?"VEC4":"VEC3";switch(P){case h.i.PositionKind:case h.i.NormalKind:return"VEC3";case h.i.TangentKind:case h.i.MatricesIndicesKind:case h.i.MatricesIndicesExtraKind:case h.i.MatricesWeightsKind:case h.i.MatricesWeightsExtraKind:return"VEC4";case h.i.UVKind:case h.i.UV2Kind:case h.i.UV3Kind:case h.i.UV4Kind:case h.i.UV5Kind:case h.i.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${P}`)}(p,A.hasVertexColorAlpha(P)),Q,S,f,Z,l)),j=this._accessors.length-1,A.setVertexAccessor(P,R,S,j)}Z.attributes[function(P){switch(P){case h.i.PositionKind:return"POSITION";case h.i.NormalKind:return"NORMAL";case h.i.TangentKind:return"TANGENT";case h.i.ColorKind:return"COLOR_0";case h.i.UVKind:return"TEXCOORD_0";case h.i.UV2Kind:return"TEXCOORD_1";case h.i.UV3Kind:return"TEXCOORD_2";case h.i.UV4Kind:return"TEXCOORD_3";case h.i.UV5Kind:return"TEXCOORD_4";case h.i.UV6Kind:return"TEXCOORD_5";case h.i.MatricesIndicesKind:return"JOINTS_0";case h.i.MatricesIndicesExtraKind:return"JOINTS_1";case h.i.MatricesWeightsKind:return"WEIGHTS_0";case h.i.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${P}`)}(p)]=j}async _exportMaterialAsync(P,a,R,S){let A=this._materialMap.get(P);if(void 0===A){const S=a&&Object.keys(a).some((P=>P.startsWith("uv")));if((P=P instanceof fP.c?P.Wj[R.materialIndex]:P)instanceof OP.b)A=await this._materialExporter.exportPBRMaterialAsync(P,"image/png",S);else{if(!(P instanceof qP.ta))return void r.c.Warn(`Unsupported material '${P.name}' with type ${P.getClassName()}`);A=await this._materialExporter.exportStandardMaterialAsync(P,"image/png",S)}this._materialMap.set(P,A)}S.material=A}async _exportMeshAsync(P,a){var R;let S=a.getMesh(P);if(void 0!==S)return S;const A={primitives:[]};S=this._meshes.length,this._meshes.push(A),a.setMesh(P,S);const p=P.isUnIndexed?null:P.Vj(),j=null===(R=P.lj)||void 0===R?void 0:R.getVertexBuffers(),U=a.getMorphTargetsFromMesh(P),Q=P instanceof dP.e,h=P instanceof EP,l=P.Zj;if(j&&l&&l.length>0)for(const O of l){const R={attributes:{}},S=O.BP()||this._babylonScene.defaultMaterial;if(h){var V,f;const a={name:S.name},A=P,Z=y.Wa.White(),p=(null===(V=A.material)||void 0===V?void 0:V.alpha)??1,j=(null===(f=A.greasedLineMaterial)||void 0===f?void 0:f.color)??Z;(!j.equalsWithEpsilon(Z,M.c)||p<1)&&(a.pbrMetallicRoughness={baseColorFactor:[...j.pj(),p]}),this._materials.push(a),R.material=this._materials.length-1}else if(Q){const a={name:S.name},A=P;(!A.color.equalsWithEpsilon(y.Wa.White(),M.c)||A.alpha<1)&&(a.pbrMetallicRoughness={baseColorFactor:[...A.color.pj(),A.alpha]}),this._materials.push(a),R.material=this._materials.length-1}else await this._exportMaterialAsync(S,j,O,R);const l=Q||h?Z.e.LineListDrawMode:P.overrideRenderingFillMode??S.fillMode,q=S._getEffectiveOrientation(P);this._exportIndices(p,p?(0,o.d)(p,O.indexCount,O.indexStart,O.verticesStart):O.verticesCount>65535,p?O.indexStart:O.verticesStart,p?O.indexCount:O.verticesCount,-O.verticesStart,l,q,a,R);for(const P of Object.values(j))this._exportVertexBuffer(P,S,O.verticesStart,O.verticesCount,a,R);if(U){R.targets=[];for(const P of U)R.targets.push(P.attributes)}A.primitives.push(R),this._extensionsPostExportMeshPrimitive(R)}if(U){A.weights=[],A.extras||(A.extras={}),A.extras.targetNames=[];for(const P of U)A.weights.push(P.influence),A.extras.targetNames.push(P.name)}return S}}wP._ExtensionNames=new Array,wP._ExtensionFactories={};class TP{static async GLTFAsync(P,a,R){R&&R.exportWithoutWaitingForScene||await P.whenReadyAsync();const S=new wP(P,R),A=await S.generateGLTFAsync(a.replace(/\.[^/.]+$/,""));return S.dispose(),A}static async GLBAsync(P,a,R){R&&R.exportWithoutWaitingForScene||await P.whenReadyAsync();const S=new wP(P,R),A=await S.generateGLBAsync(a.replace(/\.[^/.]+$/,""));return S.dispose(),A}}R(12959);const IP="EXT_mesh_gpu_instancing";class iP{constructor(P){this.name=IP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(P,a,R,A,Z,p){return await new Promise((P=>{if(a&&R instanceof WP.c&&R.hasThinInstances&&this._exporter){this._wasUsed=!0;const P=S.Oa.Zero(),A=S.Quaternion.Identity(),j=S.Oa.One(),U=R.thinInstanceGetWorldMatrices(),Q=S.TmpVectors.Oa[2],h=S.TmpVectors.Quaternion[1],l=S.TmpVectors.Oa[3];let V=!1,f=!1,O=!1;const q=new Float32Array(3*R.kj),y=new Float32Array(4*R.kj),t=new Float32Array(3*R.kj);let W=0;for(const a of U)a.decompose(l,h,Q),Z&&(K(Q),F(h)),q.set(Q.pj(),3*W),y.set(h.normalize().pj(),4*W),t.set(l.pj(),3*W),V=V||!Q.equalsWithEpsilon(P),f=f||!h.equalsWithEpsilon(A),O=O||!l.equalsWithEpsilon(j),W++;const k={attributes:{}};V&&(k.attributes.TRANSLATION=this._buildAccessor(q,"VEC3",R.kj,p)),f&&(k.attributes.ROTATION=this._buildAccessor(y,"VEC4",R.kj,p)),O&&(k.attributes.SCALE=this._buildAccessor(t,"VEC3",R.kj,p)),a.extensions=a.extensions||{},a.extensions[IP]=k}P(a)}))}_buildAccessor(P,a,R,S){const A=S.createBufferView(P),Z=S.createAccessor(A,a,5126,R);return this._exporter._accessors.push(Z),this._exporter._accessors.length-1}}wP.RegisterExtension(IP,(P=>new iP(P)));var XP=R(12961),CP=R(12970),zP=R(12974),KP=R(12978);function FP(P){return P===zP.c.PositionKind?"POSITION":P===zP.c.NormalKind?"NORMAL":P===zP.c.ColorKind?"COLOR":P.startsWith(zP.c.UVKind)?"TEX_COORD":"GENERIC"}const gP={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Pa extends XP.c{static get DefaultAvailable(){return(0,XP.h)(Pa.DefaultConfiguration)}static get Default(){return Pa._Default??(Pa._Default=new Pa),Pa._Default}static ResetDefault(P){Pa._Default&&(P||Pa._Default.dispose(),Pa._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(P,a){return{module:await(a||DracoEncoderModule)({wasmBinary:P})}}_getWorkerContent(){return`${CP.h}(${CP.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Pa.DefaultConfiguration)}async _encodeAsync(P,a,R){const S=R?(0,KP.e)(gP,R):gP;if(this._workerPoolPromise){const R=await this._workerPoolPromise;return await new Promise(((A,Z)=>{R.push(((R,p)=>{const j=P=>{R.removeEventListener("error",j),R.removeEventListener("message",U),Z(P),p()},U=P=>{"encodeMeshDone"===P.data.id&&(R.removeEventListener("error",j),R.removeEventListener("message",U),A(P.data.encodedMeshData),p())};R.addEventListener("error",j),R.addEventListener("message",U);const Q=[];for(const a of P)Q.push(a.data.buffer);a&&Q.push(a.buffer),R.postMessage({id:"encodeMesh",attributes:P,indices:a,options:S},Q)}))}))}if(this._modulePromise){const R=await this._modulePromise;return(0,CP.h)(R.module,P,a,S)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(P,a){if(0==P.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");P instanceof WP.c&&P.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===a||void 0===a?void 0:a.method)&&(r.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),a.method="MESH_SEQUENTIAL_ENCODING");const R=function(P){let a=P.Vj(void 0,!0);return!a||a instanceof Uint32Array||a instanceof Uint16Array||(a=((0,o.d)(a,a.length)?Uint32Array:Uint16Array).from(a)),a}(P),S=function(P,a){const R=[];for(const S of P.getVerticesDataKinds()){if(null!==a&&void 0!==a&&a.includes(S)){if(S===zP.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const A=P.getVertexBuffer(S),Z=A.getSize(),p=(0,o.p)(A.getData(),Z,A.type,A.byteOffset,A.byteStride,A.normalized,P.getTotalVertices(),!0);R.push({kind:S,dracoName:FP(S),size:Z,data:p})}return R}(P,null===a||void 0===a?void 0:a.excludedAttributes);return await this._encodeAsync(S,R,a)}}Pa.DefaultConfiguration={wasmUrl:`${A.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${A.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${A.Tools._DefaultCdnUrl}/draco_encoder.js`},Pa._Default=null;const aa="KHR_draco_mesh_compression";class Ra{get wasUsed(){return this._wasUsed}constructor(P){this.name=aa,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===P.options.meshCompressionMethod&&Pa.DefaultAvailable}dispose(){}postExportMeshPrimitive(P,a,R){if(!this.enabled)return;if(4!==P.mode&&5!==P.mode)return void r.c.Warn("Cannot compress primitive with mode "+P.mode+".");const S=[],A=[];let Z=null;if(void 0!==P.indices){const p=R[P.indices],j=a.getBufferView(p);Z=a.getData(j).slice(),S.push(j),A.push(p)}const p=[];for(const[h,l]of Object.entries(P.attributes)){const P=R[l],Z=a.getBufferView(P),U=i(P.type),Q=(0,o.p)(a.getData(Z),U,P.componentType,P.byteOffset||0,Z.byteStride||(0,o.n)(P.componentType)*U,P.normalized||!1,P.count,!0);p.push({kind:h,dracoName:(j=h,"POSITION"===j?"POSITION":"NORMAL"===j?"NORMAL":j.startsWith("COLOR")?"COLOR":j.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:i(P.type),data:Q}),S.push(Z),A.push(P)}var j;const U={method:P.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},Q=Pa.Default._encodeAsync(p,Z,U).then((R=>{if(!R)return void r.c.Error("Draco encoding failed for primitive.");const Z={bufferView:-1,attributes:R.attributeIds},p=a.createBufferView(R.data);a.setBufferView(Z,p);for(const P of S)this._bufferViewsUsed.add(P);for(const P of A)this._accessorsUsed.add(P);P.extensions||(P.extensions={}),P.extensions[aa]=Z})).catch((P=>{r.c.Error("Draco encoding failed for primitive: "+P)}));this._encodePromises.push(Q),this._wasUsed=!0}async preGenerateBinaryAsync(P){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((a=>{P.getPropertiesWithBufferView(a).every((P=>this._accessorsUsed.has(P)))&&P.removeBufferView(a)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}wP.RegisterExtension(aa,(P=>new Ra(P)));var Sa=R(12987);const Aa="KHR_lights_punctual",Za={name:"",color:[1,1,1],xj:1,range:Number.MAX_VALUE},pa={innerConeAngle:0,outerConeAngle:Math.PI/4},ja=S.Oa.Backward();class Ua{constructor(P){this.name=Aa,this.enabled=!0,this.required=!1,this._exporter=P}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Aa]=this._lights}async postExportNodeAsync(P,a,R,A,Z){return await new Promise((p=>{if(!(R instanceof kP.d))return void p(a);const j=R.getTypeID()==kP.d.LIGHTTYPEID_POINTLIGHT?"point":R.getTypeID()==kP.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":R.getTypeID()==kP.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!j||!(R instanceof Sa.b))return r.c.Warn(`${P}: Light ${R.name} is not supported in ${Aa}`),void p(a);if(R.falloffType!==kP.d.FALLOFF_GLTF&&r.c.Warn(`${P}: Light falloff for ${R.name} does not match the ${Aa} specification!`),!R.position.equalsToFloats(0,0,0)){const P=S.TmpVectors.Oa[0].A(R.position);Z&&K(P),a.translation=P.pj()}if("point"!==j){const P=R.direction.normalizeToRef(S.TmpVectors.Oa[0]);Z&&K(P);const A=S.Quaternion.FromUnitVectorsToRef(ja,P,S.TmpVectors.Quaternion[0]);S.Quaternion.IsIdentity(A)||(a.rotation=A.pj())}const U={type:j,name:R.name,color:R.sj.pj(),xj:R.xj,range:R.range};if(SP(U,Za),"spot"===j){const P=R;U.spot={innerConeAngle:P.innerAngle/2,outerConeAngle:P.angle/2},SP(U.spot,pa)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(U);const Q={Xp:this._lights.lights.length-1},h=R.parent;if(h&&aP(R,h)){const P=A.get(h);if(P){const R=this._exporter._nodes[P];return PP(a,R),R.extensions||(R.extensions={}),R.extensions[Aa]=Q,void p(null)}}a.extensions||(a.extensions={}),a.extensions[Aa]=Q,p(a)}))}}wP.RegisterExtension(Aa,(P=>new Ua(P)));var Qa=R(12885);const ha="KHR_materials_anisotropy";class la{constructor(P){this.name=ha,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,a,R){const S=[];return R instanceof Qa.d&&R.anisotropy.isEnabled&&!R.anisotropy.legacy?(R.anisotropy.texture&&S.push(R.anisotropy.texture),S):[]}postExportMaterialAsync(P,a,R){return new Promise((P=>{if(R instanceof Qa.d){if(!R.anisotropy.isEnabled||R.anisotropy.legacy)return void P(a);this._wasUsed=!0,a.extensions=a.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(R.anisotropy.texture),A={anisotropyStrength:R.anisotropy.xj,anisotropyRotation:R.anisotropy.angle,anisotropyTexture:S??void 0};null!==A.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(R),a.extensions[ha]=A}P(a)}))}}wP.RegisterExtension(ha,(P=>new la(P)));const Va="KHR_materials_clearcoat";class fa{constructor(P){this.name=Va,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,a,R){const S=[];return R instanceof Qa.d&&R.clearCoat.isEnabled?(R.clearCoat.texture&&S.push(R.clearCoat.texture),!R.clearCoat.useRoughnessFromMainTexture&&R.clearCoat.textureRoughness&&S.push(R.clearCoat.textureRoughness),R.clearCoat.bumpTexture&&S.push(R.clearCoat.bumpTexture),S):[]}postExportMaterialAsync(P,a,R){return new Promise((P=>{if(R instanceof Qa.d){if(!R.clearCoat.isEnabled)return void P(a);this._wasUsed=!0,a.extensions=a.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(R.clearCoat.texture);let Z;Z=R.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(R.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(R.clearCoat.textureRoughness),R.clearCoat.isTintEnabled&&A.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${R.name}`),R.clearCoat.remapF0OnInterfaceChange&&A.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${R.name}`);const p=this._exporter._materialExporter.getTextureInfo(R.clearCoat.bumpTexture),j={clearcoatFactor:R.clearCoat.xj,clearcoatTexture:S??void 0,clearcoatRoughnessFactor:R.clearCoat.roughness,clearcoatRoughnessTexture:Z??void 0,clearcoatNormalTexture:p??void 0};null===j.clearcoatTexture&&null===j.clearcoatRoughnessTexture&&null===j.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(R),a.extensions[Va]=j}P(a)}))}}wP.RegisterExtension(Va,(P=>new fa(P)));const Oa="KHR_materials_diffuse_transmission";function qa(P,a){const R=a.subSurface;let S=null;return R.translucencyIntensityTexture?S=R.translucencyIntensityTexture:R.thicknessTexture&&R.useMaskFromThicknessTexture&&(S=R.thicknessTexture),S&&!R.useGltfStyleTextures?(r.c.Warn(`${P}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${a.name}`,1),null):S}class ya{constructor(P){this.name=Oa,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,a,R){const S=[];if(R instanceof OP.b&&this._isExtensionEnabled(R)){const a=qa(P,R);return a&&S.push(a),R.subSurface.translucencyColorTexture&&S.push(R.subSurface.translucencyColorTexture),S}return S}_isExtensionEnabled(P){if(P.unlit)return!1;const a=P.subSurface;return!!a.isTranslucencyEnabled&&(!P.unlit&&!a.useAlbedoToTintTranslucency&&a.useGltfStyleTextures&&1===a.volumeIndexOfRefraction&&0===a.minimumThickness&&0===a.maximumThickness)}postExportMaterialAsync(P,a,R){return new Promise((S=>{if(R instanceof OP.b&&this._isExtensionEnabled(R)){this._wasUsed=!0;const S=R.subSurface,A=qa(P,R),Z=0==S.translucencyIntensity?void 0:S.translucencyIntensity,p=this._exporter._materialExporter.getTextureInfo(A)??void 0,j=!S.translucencyColor||S.translucencyColor.equalsFloats(1,1,1)?void 0:S.translucencyColor.pj(),U=this._exporter._materialExporter.getTextureInfo(S.translucencyColorTexture)??void 0,Q={diffuseTransmissionFactor:Z,diffuseTransmissionTexture:p,diffuseTransmissionColorFactor:j,diffuseTransmissionColorTexture:U};(p||U)&&this._exporter._materialNeedsUVsSet.add(R),a.extensions=a.extensions||{},a.extensions[Oa]=Q}S(a)}))}}wP.RegisterExtension(Oa,(P=>new ya(P)));const ta="KHR_materials_dispersion";class Wa{constructor(){this.name=ta,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(P){if(P.unlit)return!1;const a=P.subSurface;return!(!a.isRefractionEnabled&&!a.isDispersionEnabled)}postExportMaterialAsync(P,a,R){return new Promise((P=>{if(R instanceof OP.b&&this._isExtensionEnabled(R)){this._wasUsed=!0;const P={dispersion:R.subSurface.dispersion};a.extensions=a.extensions||{},a.extensions[ta]=P}P(a)}))}}wP.RegisterExtension(ta,(()=>new Wa));const ka="KHR_materials_emissive_strength";class xa{constructor(){this.name=ka,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(P,a,R){return await new Promise((P=>{if(!(R instanceof OP.b))return P(a);const S=R.emissiveColor.pj(),A=Math.max(...S);if(A>1){this._wasUsed=!0,a.extensions||(a.extensions={});const P={emissiveStrength:A},S=R.emissiveColor.scale(1/P.emissiveStrength);a.emissiveFactor=S.pj(),a.extensions[ka]=P}return P(a)}))}}wP.RegisterExtension(ka,(P=>new xa));const sa="KHR_materials_ior";class da{constructor(){this.name=sa,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(P){return!P.unlit&&(void 0!=P.indexOfRefraction&&1.5!=P.indexOfRefraction)}postExportMaterialAsync(P,a,R){return new Promise((P=>{if(R instanceof OP.b&&this._isExtensionEnabled(R)){this._wasUsed=!0;const P={ior:R.indexOfRefraction};a.extensions=a.extensions||{},a.extensions[sa]=P}P(a)}))}}wP.RegisterExtension(sa,(P=>new da));const Ga="KHR_materials_iridescence";class Ha{constructor(P){this.name=Ga,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,a,R){const S=[];return R instanceof Qa.d&&R.iridescence.isEnabled?(R.iridescence.texture&&S.push(R.iridescence.texture),R.iridescence.thicknessTexture&&R.iridescence.thicknessTexture!==R.iridescence.texture&&S.push(R.iridescence.thicknessTexture),S):[]}postExportMaterialAsync(P,a,R){return new Promise((P=>{if(R instanceof Qa.d){if(!R.iridescence.isEnabled)return void P(a);this._wasUsed=!0,a.extensions=a.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(R.iridescence.texture),A=this._exporter._materialExporter.getTextureInfo(R.iridescence.thicknessTexture),Z={iridescenceFactor:R.iridescence.xj,iridescenceIor:R.iridescence.indexOfRefraction,iridescenceThicknessMinimum:R.iridescence.minimumThickness,iridescenceThicknessMaximum:R.iridescence.maximumThickness,iridescenceTexture:S??void 0,iridescenceThicknessTexture:A??void 0};null===Z.iridescenceTexture&&null===Z.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(R),a.extensions[Ga]=Z}P(a)}))}}wP.RegisterExtension(Ga,(P=>new Ha(P)));const mR="KHR_materials_sheen";class Na{constructor(P){this.name=mR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,a,R){return R instanceof OP.b&&R.sheen.isEnabled&&R.sheen.texture?[R.sheen.texture]:[]}async postExportMaterialAsync(P,a,R){return await new Promise((P=>{if(R instanceof OP.b){if(!R.sheen.isEnabled)return void P(a);this._wasUsed=!0,null==a.extensions&&(a.extensions={});const S={sheenColorFactor:R.sheen.color.pj(),sheenRoughnessFactor:R.sheen.roughness??0};null===S.sheenColorTexture&&null===S.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(R),R.sheen.texture&&(S.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(R.sheen.texture)??void 0),R.sheen.textureRoughness&&!R.sheen.useRoughnessFromMainTexture?S.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(R.sheen.textureRoughness)??void 0:R.sheen.texture&&R.sheen.useRoughnessFromMainTexture&&(S.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(R.sheen.texture)??void 0),a.extensions[mR]=S}P(a)}))}}wP.RegisterExtension(mR,(P=>new Na(P)));const Da="KHR_materials_specular";class La{constructor(P){this.name=Da,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,a,R){const S=[];return R instanceof OP.b&&this._isExtensionEnabled(R)?(R.metallicReflectanceTexture&&S.push(R.metallicReflectanceTexture),R.reflectanceTexture&&S.push(R.reflectanceTexture),S):S}_isExtensionEnabled(P){return!P.unlit&&(void 0!=P.metallicF0Factor&&1!=P.metallicF0Factor||void 0!=P.metallicReflectanceColor&&!P.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(P))}_hasTexturesExtension(P){return null!=P.metallicReflectanceTexture||null!=P.reflectanceTexture}postExportMaterialAsync(P,a,R){return new Promise((P=>{if(R instanceof OP.b&&this._isExtensionEnabled(R)){this._wasUsed=!0,a.extensions=a.extensions||{};const P=this._exporter._materialExporter.getTextureInfo(R.metallicReflectanceTexture)??void 0,S=this._exporter._materialExporter.getTextureInfo(R.reflectanceTexture)??void 0,A={specularFactor:1==R.metallicF0Factor?void 0:R.metallicF0Factor,specularTexture:P,specularColorFactor:R.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:R.metallicReflectanceColor.pj(),specularColorTexture:S};this._hasTexturesExtension(R)&&this._exporter._materialNeedsUVsSet.add(R),a.extensions[Da]=A}P(a)}))}}wP.RegisterExtension(Da,(P=>new La(P)));const ca="KHR_materials_transmission";class ua{constructor(P){this.name=ca,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,a,R){const S=[];return R instanceof OP.b&&this._isExtensionEnabled(R)?(R.subSurface.thicknessTexture&&S.push(R.subSurface.thicknessTexture),S):S}_isExtensionEnabled(P){if(P.unlit)return!1;const a=P.subSurface;return a.isRefractionEnabled&&void 0!=a.refractionIntensity&&0!=a.refractionIntensity||this._hasTexturesExtension(P)}_hasTexturesExtension(P){return null!=P.subSurface.refractionIntensityTexture}async postExportMaterialAsync(P,a,R){if(R instanceof OP.b&&this._isExtensionEnabled(R)){this._wasUsed=!0;const S=R.subSurface,A={transmissionFactor:0===S.refractionIntensity?void 0:S.refractionIntensity};if(this._hasTexturesExtension(R)&&this._exporter._materialNeedsUVsSet.add(R),S.refractionIntensityTexture)if(S.useGltfStyleTextures){const P=await this._exporter._materialExporter.exportTextureAsync(S.refractionIntensityTexture,"image/png");P&&(A.transmissionTexture=P)}else r.c.Warn(`${P}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);a.extensions||(a.extensions={}),a.extensions[ca]=A}return a}}wP.RegisterExtension(ca,(P=>new ua(P)));const Ya="KHR_materials_unlit";class Ja{constructor(){this.name=Ya,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(P,a,R){return new Promise((P=>{let S=!1;R instanceof OP.b?S=R.unlit:R instanceof qP.ta&&(S=R.disableLighting),S&&(this._wasUsed=!0,null==a.extensions&&(a.extensions={}),a.extensions[Ya]={}),P(a)}))}}wP.RegisterExtension(Ya,(()=>new Ja));const na="KHR_materials_volume";class ba{constructor(P){this.name=na,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,a,R){const S=[];return R instanceof OP.b&&this._isExtensionEnabled(R)?(R.subSurface.thicknessTexture&&S.push(R.subSurface.thicknessTexture),S):S}_isExtensionEnabled(P){if(P.unlit)return!1;const a=P.subSurface;return!(!a.isRefractionEnabled&&!a.isTranslucencyEnabled)&&(void 0!=a.maximumThickness&&0!=a.maximumThickness||void 0!=a.tintColorAtDistance&&a.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=a.tintColor&&a.tintColor!=y.Wa.White()||this._hasTexturesExtension(P))}_hasTexturesExtension(P){return null!=P.subSurface.thicknessTexture}postExportMaterialAsync(P,a,R){return new Promise((P=>{if(R instanceof OP.b&&this._isExtensionEnabled(R)){this._wasUsed=!0;const P=R.subSurface,S={thicknessFactor:0==P.maximumThickness?void 0:P.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(P.thicknessTexture)??void 0,attenuationDistance:P.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:P.tintColorAtDistance,attenuationColor:P.tintColor.equalsFloats(1,1,1)?void 0:P.tintColor.pj()};this._hasTexturesExtension(R)&&this._exporter._materialNeedsUVsSet.add(R),a.extensions=a.extensions||{},a.extensions[na]=S}P(a)}))}}wP.RegisterExtension(na,(P=>new ba(P)));const Ba="EXT_materials_diffuse_roughness";class oa{constructor(P){this.name=Ba,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,a,R){const S=[];return R instanceof Qa.d&&R._baseDiffuseRoughness?(R._baseDiffuseRoughnessTexture&&S.push(R._baseDiffuseRoughnessTexture),S):[]}postExportMaterialAsync(P,a,R){return new Promise((P=>{if(R instanceof Qa.d){if(!R._baseDiffuseRoughness)return void P(a);this._wasUsed=!0,a.extensions=a.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(R._baseDiffuseRoughnessTexture),A={diffuseRoughnessFactor:R._baseDiffuseRoughness,diffuseRoughnessTexture:S??void 0};null!==A.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(R),a.extensions[Ba]=A}P(a)}))}}wP.RegisterExtension(Ba,(P=>new oa(P)));const ra="KHR_texture_transform";class va{constructor(){this.name=ra,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(P,a,R){if(R.GP()||A.Tools.Warn(`${P}: /*@__KEY__*/"scene" is not defined for Babylon texture ${R.name}!`),(0!==R.uAng||0!==R.vAng)&&(A.Tools.Warn(`${P}: Texture ${R.name} with rotation in the u or v axis is not supported in glTF.`),0!==R.uRotationCenter||0!==R.vRotationCenter))return;const S={};let Z=!1;if(0===R.uOffset&&0===R.vOffset||(S.offset=[R.uOffset,R.vOffset],Z=!0),1===R.uScale&&1===R.vScale||(S.scale=[R.uScale,R.vScale],Z=!0),0!==R.wAng){if(0!==R.uRotationCenter||0!==R.vRotationCenter){if(R.homogeneousRotationInUVTransform&&R.uScale!==R.vScale)return void A.Tools.Warn(`${P}: Texture ${R.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${ra}.`);A.Tools.Warn(`${P}: Texture ${R.name} with non-origin rotation center will be exported using an adjusted offset with ${ra}.`),S.offset=function(P){const{uOffset:a,vOffset:R,uRotationCenter:S,vRotationCenter:A,uScale:Z,vScale:p,wAng:j}=P,U=Math.cos(j),Q=Math.sin(j),h=S*Z,l=A*p;return[a+(h*(1-U)+l*Q),R+(l*(1-U)-h*Q)]}(R)}S.rotation=-R.wAng,Z=!0}0!==R.coordinatesIndex&&(S.texCoord=R.coordinatesIndex,Z=!0),Z&&(this._wasUsed=!0,a.extensions||(a.extensions={}),a.extensions[ra]=S)}}wP.RegisterExtension(ra,(()=>new va));class Ma{static CreateSTL(P){let a=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",A=arguments.length>3&&void 0!==arguments[3]&&arguments[3],Z=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],p=arguments.length>5&&void 0!==arguments[5]&&arguments[5],j=arguments.length>6&&void 0!==arguments[6]&&arguments[6],U=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const Q=function(P,a,R){const A=[3*P[R],3*P[R+1],3*P[R+2]],Z=[new S.Oa(a[A[0]],a[A[0]+2],a[A[0]+1]),new S.Oa(a[A[1]],a[A[1]+2],a[A[1]+1]),new S.Oa(a[A[2]],a[A[2]+2],a[A[2]+1])],p=Z[0].qa(Z[1]),j=Z[2].qa(Z[1]);return{v:Z,n:S.Oa.Cross(j,p).normalize()}},l=function(P,a,R,S){return a=V(P,a,R.x,S),a=V(P,a,R.y,S),V(P,a,R.z,S)},V=function(P,a,R,S){return P.setFloat32(a,R,S),a+4},O=function(P){if(j){let a=P;P instanceof f.e&&(a=P.sourceMesh);const R=a.getVerticesData(h.i.PositionKind,!0,!0);if(!R)return[];const A=S.Oa.Zero();let Z;for(Z=0;Z<R.length;Z+=3)S.Oa.TransformCoordinatesFromFloatsToRef(R[Z],R[Z+1],R[Z+2],P.hj(!0),A).toArray(R,Z);return R}return P.getVerticesData(h.i.PositionKind)||[]};j&&(p=!0);let q="",y=0,t=0;if(A){for(let R=0;R<P.length;R++){const a=P[R].Vj();y+=a?a.length/3:0}const a=new ArrayBuffer(84+50*y);q=new DataView(a),t+=80,q.setUint32(t,y,Z),t+=4}else U||(q="solid stlmesh\r\n");for(let S=0;S<P.length;S++){const a=P[S];!A&&U&&(q+="solid "+a.name+"\r\n"),!p&&a instanceof WP.c&&a.bakeCurrentTransformIntoVertices();const R=O(a),j=a.Vj()||[];for(let P=0;P<j.length;P+=3){const a=Q(j,R,P);A?(t=l(q,t,a.n,Z),t=l(q,t,a.v[0],Z),t=l(q,t,a.v[1],Z),t=l(q,t,a.v[2],Z),t+=2):(q+="\tfacet normal "+a.n.x+" "+a.n.y+" "+a.n.z+"\r\n",q+="\t\touter loop\r\n",q+="\t\t\tvertex "+a.v[0].x+" "+a.v[0].y+" "+a.v[0].z+"\r\n",q+="\t\t\tvertex "+a.v[1].x+" "+a.v[1].y+" "+a.v[1].z+"\r\n",q+="\t\t\tvertex "+a.v[2].x+" "+a.v[2].y+" "+a.v[2].z+"\r\n",q+="\t\tendloop\r\n",q+="\tendfacet\r\n")}!A&&U&&(q+="endsolid "+name+"\r\n")}if(A||U||(q+="endsolid stlmesh"),a){const P=document.createElement("a"),a=new Blob([q],{type:"application/octet-stream"});P.href=window.URL.createObjectURL(a),P.download=R+".stl",P.click()}return q}}function Ea(P,a){let R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const S=[];for(let A=0;A<P.length/R;A++){const Z=P[A*R],p=P[A*R+1],j=P[A*R+2];S.push(`(${Z.toPrecision(a.precision)}, ${p.toPrecision(a.precision)}, ${j.toPrecision(a.precision)})`)}return S.join(", ")}function ea(P,a){const R=[];for(let S=0;S<P.length/2;S++){const A=P[2*S],Z=P[2*S+1];R.push(`(${A.toPrecision(a.precision)}, ${(1-Z).toPrecision(a.precision)})`)}return R.join(", ")}function wa(P,a){const R=P.getVerticesData(h.i.PositionKind),S=P.getVerticesData(h.i.NormalKind);if(R&&S)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(P){var a;const R=null!==(a=P.Vj())&&void 0!==a&&a.length?P.getTotalIndices():P.getTotalVertices();return Array(R/3).fill(3).join(", ")}(P)}]\n\t\tint[] faceVertexIndices = [${function(P){const a=P.Vj(),R=[];if(null!==a)for(let S=0;S<a.length;S++)R.push(a[S]);else{const a=P.getTotalVertices();for(let P=0;P<a;P++)R.push(P)}return R.join(", ")}(P)}]\n\t\tnormal3f[] normals = [${Ea(S,a)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Ea(R,a)}]\n        ${function(P,a){let R="";for(let A=0;A<4;A++){const S=A>0?A:"",Z=P.getVerticesData(h.i.UVKind+(S?S+1:""));Z&&(R+=`\n\t\ttexCoord2f[] primvars:st${S} = [${ea(Z,a)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const S=P.getVerticesData(h.i.ColorKind);return S&&(R+=`\n\tcolor3f[] primvars:displayColor = [${Ea(S,a,S.length/P.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),R}(P,a)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Ta(P,a){return`\n        def "Geometry"\n        {\n        ${wa(P,a)}\n        }\n        `}function Ia(P){let a='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return a+=P,fflate.strToU8(a)}function ia(P){const a=P.m;return`( ${Xa(a,0)}, ${Xa(a,4)}, ${Xa(a,8)}, ${Xa(a,12)} )`}function Xa(P,a){return`(${P[a+0]}, ${P[a+1]}, ${P[a+2]}, ${P[a+3]})`}function Ca(P){const a="Object_"+P.uniqueId,R=function(P){const a=P.getWorldMatrix().clone(),R=P.GP().useRightHandedSystem;if(!R){let S=P.parent;for(;S;){if(pP(S,R)){a.multiplyToRef(S.getWorldMatrix().invert(),a);break}S=S.parent}}return a.determinant()<0&&A.Tools.Warn(`Exporting mesh ${P.name} with negative scale. Result may look incorrect in destination engine.`),a}(P),S=ia(R);return`def Xform "${a}" (\n\tprepend references = @./geometries/Geometry_${P.lj.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${S}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${P.material.uniqueId}>\n}\n\n`}function za(P){switch(P){case G.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case G.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case G.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Ka(P){return`(${P.x}, ${P.y})`}function Fa(P){return`(${P.r}, ${P.g}, ${P.b})`}function ga(P,a,R,A,Z,p){const j=P.getInternalTexture().uniqueId+"_"+P.invertY;Z[j]=P;const U=P.coordinatesIndex>0?"st"+P.coordinatesIndex:"st",Q=new S.Vector2(P.uScale,P.vScale),h=new S.Vector2(P.uOffset,P.vOffset),l=P.wAng,V=Math.sin(l),f=Math.cos(l);return h.y=1-h.y-Q.y,h.x+=V*Q.x,h.y+=(1-f)*Q.y,`\n    def Shader "PrimvarReader_${R}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${U}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${R}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${a.uniqueId}/PrimvarReader_${R}.outputs:result>\n        float inputs:rotation = ${(l*(180/Math.PI)).toFixed(p.precision)}\n        float2 inputs:scale = ${Ka(Q)}\n        float2 inputs:translation = ${Ka(h)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${P.uniqueId}_${R}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${j}.png@\n        float2 inputs:st.connect = </Materials/Material_${a.uniqueId}/Transform2d_${R}.outputs:result>\n        ${A?"float4 inputs:scale = "+function(P){return`(${P.r}, ${P.g}, ${P.b}, 1.0)`}(A):""}\n        token inputs:sourceColorSpace = "${P.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${za(P.wrapU)}"\n        token inputs:wrapT = "${za(P.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${a.needAlphaBlending()?"float outputs:a":""}\n    }`}function PR(P,a,R){const S="\t\t\t",A=[],Z=[],{diffuseMap:p,sj:j,alphaCutOff:U,emissiveMap:Q,emissive:h,normalMap:l,roughnessMap:V,roughnessChannel:f,roughness:O,metalnessMap:q,metalnessChannel:t,metalness:W,aoMap:k,aoMapChannel:x,aoMapIntensity:s,alphaMap:d,ior:G,clearCoatEnabled:H,clearCoat:mP,clearCoatMap:N,clearCoatRoughness:D,clearCoatRoughnessMap:L}=function(P){const a={diffuseMap:null,sj:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return P instanceof qP.ta?{...a,diffuseMap:P.diffuseTexture,sj:P.diffuseColor,alphaCutOff:P.alphaCutOff,emissiveMap:P.emissiveTexture,emissive:P.emissiveColor,roughness:1,alphaMap:P.opacityTexture}:P instanceof Qa.d?{...a,diffuseMap:P._albedoTexture,sj:P._albedoColor,alphaCutOff:P._alphaCutOff,emissiveMap:P._emissiveTexture,emissive:P._emissiveColor,normalMap:P._bumpTexture,roughnessMap:P._metallicTexture,roughnessChannel:P._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:P._roughness??1,metalnessMap:P._metallicTexture,metalnessChannel:P._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:P._metallic??0,aoMap:P._ambientTexture,aoMapChannel:P._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:P._ambientTextureStrength,alphaMap:P._opacityTexture,ior:P.subSurface.indexOfRefraction,clearCoatEnabled:P.clearCoat.isEnabled,clearCoat:P.clearCoat.xj,clearCoatMap:P.clearCoat.texture,clearCoatRoughness:P.clearCoat.roughness,clearCoatRoughnessMap:P.clearCoat.useRoughnessFromMainTexture?P.clearCoat.texture:P.clearCoat.textureRoughness}:a}(P);return null!==p?(A.push(`${S}color3f inputs:diffuseColor.connect = </Materials/Material_${P.uniqueId}/Texture_${p.uniqueId}_diffuse.outputs:rgb>`),P.needAlphaBlending()?A.push(`${S}float inputs:opacity.connect = </Materials/Material_${P.uniqueId}/Texture_${p.uniqueId}_diffuse.outputs:a>`):P.needAlphaTesting()&&(A.push(`${S}float inputs:opacity.connect = </Materials/Material_${P.uniqueId}/Texture_${p.uniqueId}_diffuse.outputs:a>`),A.push(`${S}float inputs:opacityThreshold = ${U}`)),Z.push(ga(p,P,"diffuse",j,a,R))):A.push(`${S}color3f inputs:diffuseColor = ${Fa(j||y.Wa.White())}`),null!==Q?(A.push(`${S}color3f inputs:emissiveColor.connect = </Materials/Material_${P.uniqueId}/Texture_${Q.uniqueId}_emissive.outputs:rgb>`),Z.push(ga(Q,P,"emissive",h,a,R))):h&&h.toLuminance()>0&&A.push(`${S}color3f inputs:emissiveColor = ${Fa(h)}`),null!==l&&(A.push(`${S}normal3f inputs:normal.connect = </Materials/Material_${P.uniqueId}/Texture_${l.uniqueId}_normal.outputs:rgb>`),Z.push(ga(l,P,"normal",null,a,R))),null!==k&&(A.push(`${S}float inputs:occlusion.connect = </Materials/Material_${P.uniqueId}/Texture_${k.uniqueId}_occlusion.outputs:${x}>`),Z.push(ga(k,P,"occlusion",new y.Wa(s,s,s),a,R))),null!==V?(A.push(`${S}float inputs:roughness.connect = </Materials/Material_${P.uniqueId}/Texture_${V.uniqueId}_roughness.outputs:${f}>`),Z.push(ga(V,P,"roughness",new y.Wa(O,O,O),a,R))):A.push(`${S}float inputs:roughness = ${O}`),null!==q?(A.push(`${S}float inputs:metallic.connect = </Materials/Material_${P.uniqueId}/Texture_${q.uniqueId}_metallic.outputs:${t}>`),Z.push(ga(q,P,"metallic",new y.Wa(W,W,W),a,R))):A.push(`${S}float inputs:metallic = ${W}`),null!==d?(A.push(`${S}float inputs:opacity.connect = </Materials/Material_${P.uniqueId}/Texture_${d.uniqueId}_opacity.outputs:r>`),A.push(`${S}float inputs:opacityThreshold = 0.0001`),Z.push(ga(d,P,"opacity",null,a,R))):A.push(`${S}float inputs:opacity = ${P.alpha}`),H&&(null!==N?(A.push(`${S}float inputs:clearcoat.connect = </Materials/Material_${P.uniqueId}/Texture_${N.uniqueId}_clearcoat.outputs:r>`),Z.push(ga(N,P,"clearcoat",new y.Wa(mP,mP,mP),a,R))):A.push(`${S}float inputs:clearcoat = ${mP}`),null!==L?(A.push(`${S}float inputs:clearcoatRoughness.connect = </Materials/Material_${P.uniqueId}/Texture_${L.uniqueId}_clearcoatRoughness.outputs:g>`),Z.push(ga(L,P,"clearcoatRoughness",new y.Wa(D,D,D),a,R))):A.push(`${S}float inputs:clearcoatRoughness = ${D}`)),A.push(`${S}float inputs:ior = ${G}`),`\n\tdef Material "Material_${P.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${A.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${P.uniqueId}/PreviewSurface.outputs:surface>\n\n${Z.join("\n")}\n\n\t}\n`}async function aR(P,a,R){const Z={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...a};"undefined"===typeof fflate&&await A.Tools.LoadScriptAsync(Z.fflateUrl);const p={};p[Z.modelFileName]=null;let j='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';j+=function(P){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===P.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${P.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${P.planeAnchoringAlignment}"`:""}\n            `}(Z);const U={};for(const S of P.meshes){if(0===S.getTotalVertices())continue;const P=S,a=P.lj,Q=P.material;if(!Q||!a||R&&!R(P))continue;if(-1!==["ta","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(Q.getClassName())){const R="geometries/Geometry_"+a.uniqueId+".usda";if(!(R in p)){const P=Ta(a,Z);p[R]=Ia(P)}Q.uniqueId in U||(U[Q.uniqueId]=Q),j+=Ca(P)}else A.Tools.Warn("USDZExportAsync does not support this material type: "+Q.getClassName())}P.activeCamera&&Z.exportCamera&&(j+=function(P,a){const R="Camera_"+P.uniqueId,A=ia(S.Matrix.RotationY(Math.PI).multiply(P.getWorldMatrix()));if(P.mode===G.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${R}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${A}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${P.Uj.toPrecision(a.precision)}, ${P.maxZ.toPrecision(a.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(P.orthoLeft||1)+Math.abs(P.orthoRight||1))).toPrecision(a.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(P.orthoTop||1)+Math.abs(P.orthoBottom||1))).toPrecision(a.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const S=P.getEngine().getAspectRatio(P),Z=a.cameraSensorWidth||35;return`def Camera "${R}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${A}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${P.Uj.toPrecision(a.precision)}, ${P.maxZ.toPrecision(a.precision)})\n\t\t\tfloat focalLength = ${(Z/(2*Math.tan(.5*P.fov))).toPrecision(a.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(Z*S).toPrecision(a.precision)}\n\t\t\tfloat verticalAperture = ${(Z/S).toPrecision(a.precision)}            \n\t\t}\n\t\n\t`}}(P.activeCamera,Z)),j+="\n            }\n        }\n    }";const Q={};j+=function(P,a,R){const S=[];for(const A in P){const Z=P[A];S.push(PR(Z,a,R))}return`\n    def "Materials"\n{\n${S.join("")}\n}\n\n`}(U,Q,Z),p[Z.modelFileName]=fflate.strToU8(j);for(const S in Q){const P=Q[S],a=P.getSize(),R=await P.readPixels();if(!R)throw new Error("Texture data is not available");const A=await H.DumpTools.DumpDataAsync(a.width,a.height,R,"image/png",void 0,!1,!0);p[`textures/Texture_${S}.png`]=new Uint8Array(A).slice()}let h=0;for(const S in p){const P=p[S];if(!P)continue;h+=34+S.length;const a=63&h;if(4!==a){const R=new Uint8Array(64-a);p[S]=[P,{extra:{12345:R}}]}h=P.length}return fflate.zipSync(p,{level:0})}}}]);