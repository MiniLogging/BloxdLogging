"use strict";(self["269hv5nclphh"]=self["269hv5nclphh"]||[]).push([[26],{12804:(E,H,d)=>{d.r(H),d.d(H,{EXT_materials_diffuse_roughness:()=>OH,EXT_mesh_gpu_instancing:()=>KE,GLTF2Export:()=>vE,GLTFData:()=>t,KHR_draco_mesh_compression:()=>dH,KHR_lights_punctual:()=>rH,KHR_materials_anisotropy:()=>MH,KHR_materials_clearcoat:()=>CH,KHR_materials_diffuse_transmission:()=>QH,KHR_materials_dispersion:()=>DH,KHR_materials_emissive_strength:()=>sH,KHR_materials_ior:()=>pH,KHR_materials_iridescence:()=>PH,KHR_materials_sheen:()=>XH,KHR_materials_specular:()=>UH,KHR_materials_transmission:()=>cH,KHR_materials_unlit:()=>oH,KHR_materials_volume:()=>aH,KHR_texture_transform:()=>xH,OBJExport:()=>g,STLExport:()=>qH,USDZExportAsync:()=>Hd,_ConvertToGLTFPBRMetallicRoughness:()=>u,_SolveMetallic:()=>c,__IGLTFExporterExtension:()=>l});var n=d(12384),Z=d(12228),I=d(12729);class g{static OBJ(E,H,d,g){const l=[];let r=1,t=1;H&&(d||(d="mat"),l.push("mtllib "+d+".mtl"));for(let S=0;S<E.length;S++){const d=E[S],M=d.name||`mesh${S}}`;l.push(`o ${M}`);let V=null;if(g){const E=d.yd(!0);V=new n.Matrix,E.invertToRef(V),d.bakeTransformIntoVertices(E)}if(H){const E=d.material;E&&l.push("usemtl "+E.id)}const C=d.Kd;if(!C){Z.Tools.Warn("No geometry is present on the mesh");continue}const w=C.getVerticesData("position"),R=C.getVerticesData("normal"),Q=C.getVerticesData("uv"),L=C.Nd();let D=0,e=0;if(!w||!L){Z.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const s=E[0].fE().useRightHandedSystem?1:-1;for(let E=0;E<w.length;E+=3)l.push("v "+w[E]*s+" "+w[E+1]+" "+w[E+2]),D++;if(null!=R)for(let E=0;E<R.length;E+=3)l.push("vn "+R[E]*s+" "+R[E+1]+" "+R[E+2]);if(null!=Q)for(let E=0;E<Q.length;E+=2)l.push("vt "+Q[E]+" "+Q[E+1]),e++;const i=["","",""],p=(d.material||d.fE().defaultMaterial)._getEffectiveOrientation(d),[f,P]=p===I.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let E=0;E<L.length;E+=3){const H=[String(L[E]+r),String(L[E+f]+r),String(L[E+P]+r)],d=[String(L[E]+t),String(L[E+f]+t),String(L[E+P]+t)],n=H,Z=null!=Q?d:i,I=null!=R?H:i;l.push("f "+n[0]+"/"+Z[0]+"/"+I[0]+" "+n[1]+"/"+Z[1]+"/"+I[1]+" "+n[2]+"/"+Z[2]+"/"+I[2])}g&&V&&d.bakeTransformIntoVertices(V),r+=D,t+=e}return l.join("\n")}static MTL(E){const H=[],d=E.material;H.push("newmtl mat1"),H.push("  Ns "+d.specularPower.toFixed(4)),H.push("  Ni 1.5000"),H.push("  d "+d.alpha.toFixed(4)),H.push("  Tr 0.0000"),H.push("  Tf 1.0000 1.0000 1.0000"),H.push("  illum 2"),H.push("  Ka "+d.ambientColor.r.toFixed(4)+" "+d.ambientColor.g.toFixed(4)+" "+d.ambientColor.b.toFixed(4)),H.push("  Kd "+d.diffuseColor.r.toFixed(4)+" "+d.diffuseColor.g.toFixed(4)+" "+d.diffuseColor.b.toFixed(4)),H.push("  Ks "+d.specularColor.r.toFixed(4)+" "+d.specularColor.g.toFixed(4)+" "+d.specularColor.b.toFixed(4)),H.push("  Ke "+d.emissiveColor.r.toFixed(4)+" "+d.emissiveColor.g.toFixed(4)+" "+d.emissiveColor.b.toFixed(4));d.ambientTexture&&H.push("  map_Ka "+d.ambientTexture.name),d.diffuseTexture&&H.push("  map_Kd "+d.diffuseTexture.name),d.specularTexture&&H.push("  map_Ks "+d.specularTexture.name),d.bumpTexture&&H.push("  map_bump -imfchan z "+d.bumpTexture.name),d.opacityTexture&&H.push("  map_d "+d.opacityTexture.name);return H.join("\n")}}var l=0,r=d(12271);class t{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const E in this.files){const H=this.files[E],d=new Blob([H],{type:(0,r.g)(E)});Z.Tools.Download(d,E)}}}var S=d(12463),M=d(12809),V=d(12817),C=d(12832),w=d(12522),R=d(12268),Q=d(12437),L=d(12406);const D=L.HighestCommonFactor,e={...L,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:D};var s=d(12622),i=d(12366),p=d(12860),f=d(12866),P=d(12614);const j=1e-6,X=new Q.DH(.04,.04,.04),W=1024,U=Q.DH.White(),Y=Q.DH.Black();function c(E,H,d){if(H<X.r)return 0;const n=X.r,Z=E*d/(1-X.r)+H-2*X.r,I=Z*Z-4*n*(X.r-H);return e.Clamp((-Z+Math.sqrt(I))/(2*n),0,1)}function u(E){const H=E.diffuseColor.toLinearSpace(E.fE().getEngine().useExactSrgbConversions).scale(.5),d=E.alpha,Z=function(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new n.Vector2(0,1),d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new n.Vector2(0,.1),Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new n.Vector2(0,.1),I=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new n.Vector2(1300,.1);return function(E,H,d,n,Z){return(1-E)*(1-E)*(1-E)*H+3*(1-E)*(1-E)*E*d+3*(1-E)*E*E*n+E*E*E*Z}(Math.pow(E/I.x,.333333),H.y,d.y,Z.y,I.y)}(e.Clamp(E.specularPower,0,W));return{baseColorFactor:[H.r,H.g,H.b,d],metallicFactor:0,roughnessFactor:Z}}function o(E,H){H.needAlphaBlending()?E.alphaMode="BLEND":H.needAlphaTesting()&&(E.alphaMode="MASK",E.alphaCutoff=H.alphaCutOff)}function F(E,H,d){const n=new Uint8Array(E*H*4);for(let Z=0;Z<n.length;Z+=4)n[Z]=n[Z+1]=n[Z+2]=n[Z+3]=255;return p.b.CreateRGBATexture(n,E,H,d)}function a(E){if(E instanceof Uint8Array){const H=E.length,d=new Float32Array(E.length);for(let n=0;n<H;++n)d[n]=E[n]/255;return d}if(E instanceof Float32Array)return E;throw new Error("Unsupported pixel format!")}class k{constructor(E){this._exporter=E,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(E){return E?this._textureMap.get(E)??null:null}async exportStandardMaterialAsync(E,H,d){const n=u(E),I={name:E.name};if(null==E.ln||E.ln||(E.twoSidedLighting||Z.Tools.Warn(E.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),I.doubleSided=!0),d){const d=[],Z=E.diffuseTexture;Z&&d.push(this.exportTextureAsync(Z,H).then((E=>{E&&(n.baseColorTexture=E)})));const g=E.bumpTexture;g&&d.push(this.exportTextureAsync(g,H).then((E=>{E&&(I.normalTexture=E,1!==g.level&&(I.normalTexture.scale=g.level))})));const l=E.emissiveTexture;l&&(I.emissiveFactor=[1,1,1],d.push(this.exportTextureAsync(l,H).then((E=>{E&&(I.emissiveTexture=E)}))));const r=E.ambientTexture;r&&d.push(this.exportTextureAsync(r,H).then((E=>{if(E){const H={index:E.index};I.occlusionTexture=H}}))),d.length>0&&(this._exporter._materialNeedsUVsSet.add(E),await Promise.all(d))}(E.alpha<1||E.opacityTexture)&&(E.alphaMode===f.e.ALPHA_COMBINE?I.alphaMode="BLEND":Z.Tools.Warn(E.name+": glTF 2.0 does not support alpha mode: "+E.alphaMode.toString())),E.emissiveColor&&!E.emissiveColor.equalsWithEpsilon(Y,j)&&(I.emissiveFactor=E.emissiveColor.kd()),I.pbrMetallicRoughness=n,o(I,E),await this._finishMaterialAsync(I,E,H);const g=this._exporter._materials;return g.push(I),g.length-1}async _finishMaterialAsync(E,H,d){const n=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",E,H),Z=[];for(const I of n)Z.push(this.exportTextureAsync(I,d));await Promise.all(Z),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",E,H)}async _getImageDataAsync(E,H,n,Z){const I=f.e.TEXTURETYPE_UNSIGNED_BYTE,g=this._exporter._babylonScene,l=g.getEngine(),r=l.createRawTexture(E,H,n,f.e.TEXTUREFORMAT_RGBA,!1,!0,i.c.NEAREST_SAMPLINGMODE,null,I);l.isWebGPU?await d.e(51).then(d.bind(d,14880)):await d.e(52).then(d.bind(d,14888)),await s.n.ApplyPostProcess("pass",r,g,I,f.e.TEXTURE_NEAREST_SAMPLINGMODE,f.e.TEXTUREFORMAT_RGBA);const t=await l._readTexturePixels(r,H,n);return await P.DumpTools.DumpDataAsync(H,n,t,Z,void 0,!0,!0)}_resizeTexturesToSameDimensions(E,H,d){const n=E?E.getSize():{width:0,height:0},Z=H?H.getSize():{width:0,height:0};let I,g;return n.width<Z.width?(I=E&&E instanceof i.c?s.n.CreateResizedCopy(E,Z.width,Z.height,!0):F(Z.width,Z.height,d),g=H):n.width>Z.width?(g=H&&H instanceof i.c?s.n.CreateResizedCopy(H,n.width,n.height,!0):F(n.width,n.height,d),I=E):(I=E,g=H),{texture1:I,texture2:g}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(E,H,d,n){const Z=new Array;if(!E&&!H)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const I=E?E.fE():H?H.fE():null;if(I){var g;const l=this._resizeTexturesToSameDimensions(E,H,I),r=null===(g=l.texture1)||void 0===g?void 0:g.getSize();let t,S;const M=r.width,V=r.height,C=await l.texture1.readPixels(),w=await l.texture2.readPixels();if(!C)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(t=a(C),!w)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");S=a(w);const R=S.byteLength,L=new Uint8Array(R),D=new Uint8Array(R),e=4,s=Y;let i=0,p=0;for(let E=0;E<V;++E)for(let H=0;H<M;++H){const n=(M*E+H)*e,Z={diffuseColor:new Q.DH(t[n],t[n+1],t[n+2]).toLinearSpace(I.getEngine().useExactSrgbConversions).multiply(d.diffuseColor),specularColor:new Q.DH(S[n],S[n+1],S[n+2]).toLinearSpace(I.getEngine().useExactSrgbConversions).multiply(d.specularColor),glossiness:S[n+3]*d.glossiness},g=this._convertSpecularGlossinessToMetallicRoughness(Z);s.r=Math.max(s.r,g.baseColor.r),s.g=Math.max(s.g,g.baseColor.g),s.b=Math.max(s.b,g.baseColor.b),i=Math.max(i,g.metallic),p=Math.max(p,g.roughness),D[n]=255*g.baseColor.r,D[n+1]=255*g.baseColor.g,D[n+2]=255*g.baseColor.b,D[n+3]=l.texture1.Od?255*t[n+3]:255,L[n]=0,L[n+1]=255*g.roughness,L[n+2]=255*g.metallic,L[n+3]=255}const f={baseColor:s,metallic:i,roughness:p};let P=!1,X=!1;for(let E=0;E<V;++E)for(let H=0;H<M;++H){const d=(M*E+H)*e;D[d]/=f.baseColor.r>j?f.baseColor.r:1,D[d+1]/=f.baseColor.g>j?f.baseColor.g:1,D[d+2]/=f.baseColor.b>j?f.baseColor.b:1;const n=Q.DH.FromInts(D[d],D[d+1],D[d+2]).toGammaSpace(I.getEngine().useExactSrgbConversions);D[d]=255*n.r,D[d+1]=255*n.g,D[d+2]=255*n.b,n.equalsWithEpsilon(U,j)||(X=!0),L[d+1]/=f.roughness>j?f.roughness:1,L[d+2]/=f.metallic>j?f.metallic:1;Q.DH.FromInts(255,L[d+1],L[d+2]).equalsWithEpsilon(U,j)||(P=!0)}return P&&Z.push(this._getImageDataAsync(L,M,V,n).then((E=>{f.metallicRoughnessTextureData=E}))),X&&Z.push(this._getImageDataAsync(D,M,V,n).then((E=>{f.baseColorTextureData=E}))),await Promise.all(Z).then((()=>f))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(E){const H=this._getPerceivedBrightness(E.diffuseColor),d=this._getPerceivedBrightness(E.specularColor),n=1-this._getMaxComponent(E.specularColor),Z=c(H,d,n),I=E.diffuseColor.scale(n/(1-X.r)/Math.max(1-Z)),g=E.specularColor.RH(X.scale(1-Z)).scale(1/Math.max(Z));let l=Q.DH.Lerp(I,g,Z*Z);l=l.clampToRef(0,1,l);return{baseColor:l,metallic:Z,roughness:1-E.glossiness}}_getPerceivedBrightness(E){return E?Math.sqrt(.299*E.r*E.r+.587*E.g*E.g+.114*E.b*E.b):0}_getMaxComponent(E){return E?Math.max(E.r,Math.max(E.g,E.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(E,H,d,n){const Z=[],I={baseColor:E._albedoColor,metallic:E._metallic,roughness:E._roughness};if(n){E._albedoTexture&&Z.push(this.exportTextureAsync(E._albedoTexture,H).then((E=>{E&&(d.baseColorTexture=E)})));const n=E._metallicTexture;n&&Z.push(this.exportTextureAsync(n,H).then((E=>{E&&(d.metallicRoughnessTexture=E)})))}return Z.length>0&&(this._exporter._materialNeedsUVsSet.add(E),await Promise.all(Z)),I}_getTextureSampler(E){const H={};if(!E||!(E instanceof i.c))return H;const d=this._getGLTFTextureWrapMode(E.wrapU);10497!==d&&(H.wrapS=d);const n=this._getGLTFTextureWrapMode(E.wrapV);switch(10497!==n&&(H.wrapT=n),E.samplingMode){case i.c.LINEAR_LINEAR:H.magFilter=9729,H.minFilter=9729;break;case i.c.LINEAR_NEAREST:H.magFilter=9729,H.minFilter=9728;break;case i.c.NEAREST_LINEAR:H.magFilter=9728,H.minFilter=9729;break;case i.c.NEAREST_LINEAR_MIPLINEAR:H.magFilter=9728,H.minFilter=9987;break;case i.c.NEAREST_NEAREST:H.magFilter=9728,H.minFilter=9728;break;case i.c.NEAREST_LINEAR_MIPNEAREST:H.magFilter=9728,H.minFilter=9985;break;case i.c.LINEAR_NEAREST_MIPNEAREST:H.magFilter=9729,H.minFilter=9984;break;case i.c.LINEAR_NEAREST_MIPLINEAR:H.magFilter=9729,H.minFilter=9986;break;case i.c.NEAREST_NEAREST_MIPLINEAR:H.magFilter=9728,H.minFilter=9986;break;case i.c.LINEAR_LINEAR_MIPLINEAR:H.magFilter=9729,H.minFilter=9987;break;case i.c.LINEAR_LINEAR_MIPNEAREST:H.magFilter=9729,H.minFilter=9985;break;case i.c.NEAREST_NEAREST_MIPNEAREST:H.magFilter=9728,H.minFilter=9984}return H}_getGLTFTextureWrapMode(E){switch(E){case i.c.WRAP_ADDRESSMODE:return 10497;case i.c.CLAMP_ADDRESSMODE:return 33071;case i.c.MIRROR_ADDRESSMODE:return 33648;default:return Z.Tools.Error(`Unsupported Texture Wrap Mode ${E}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(E,H,d,n){const Z={diffuseColor:E._albedoColor,specularColor:E._reflectivityColor,glossiness:E._microSurface},I=E._albedoTexture,g=E._reflectivityTexture,l=E._useMicroSurfaceFromReflectivityMapAlpha;if(g&&!l)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((I||g)&&n){this._exporter._materialNeedsUVsSet.add(E);const n=this._exportTextureSampler(I||g),l=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(I,g,Z,H),r=this._exporter._textures;if(l.baseColorTextureData){const E=this._exportImage(`baseColor${r.length}`,H,l.baseColorTextureData);d.baseColorTexture=this._exportTextureInfo(E,n,null===I||void 0===I?void 0:I.coordinatesIndex)}if(l.metallicRoughnessTextureData){const E=this._exportImage(`metallicRoughness${r.length}`,H,l.metallicRoughnessTextureData);d.metallicRoughnessTexture=this._exportTextureInfo(E,n,null===g||void 0===g?void 0:g.coordinatesIndex)}return l}return this._convertSpecularGlossinessToMetallicRoughness(Z)}async exportPBRMaterialAsync(E,H,d){const n={},Z={name:E.name},I=E.isMetallicWorkflow();if(I){const H=E._albedoColor,d=E.alpha;H&&(n.baseColorFactor=[H.r,H.g,H.b,d])}const g=I?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(E,H,n,d):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(E,H,n,d);await this._setMetallicRoughnessPbrMaterialAsync(g,E,Z,n,H,d),await this._finishMaterialAsync(Z,E,H);const l=this._exporter._materials;return l.push(Z),l.length-1}async _setMetallicRoughnessPbrMaterialAsync(E,H,d,n,I,g){if(o(d,H),E.baseColor.equalsWithEpsilon(U,j)&&e.WithinEpsilon(H.alpha,1,j)||(n.baseColorFactor=[E.baseColor.r,E.baseColor.g,E.baseColor.b,H.alpha]),null!=E.metallic&&1!==E.metallic&&(n.metallicFactor=E.metallic),null!=E.roughness&&1!==E.roughness&&(n.roughnessFactor=E.roughness),null==H.ln||H.ln||(H._twoSidedLighting||Z.Tools.Warn(H.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),d.doubleSided=!0),g){const E=[],n=H._bumpTexture;n&&E.push(this.exportTextureAsync(n,I).then((E=>{E&&(d.normalTexture=E,1!==n.level&&(d.normalTexture.scale=n.level))})));const Z=H._ambientTexture;Z&&E.push(this.exportTextureAsync(Z,I).then((E=>{if(E){const n={index:E.index,texCoord:E.texCoord,extensions:E.extensions};d.occlusionTexture=n;const Z=H._ambientTextureStrength;Z&&(n.strength=Z)}})));const g=H._emissiveTexture;g&&E.push(this.exportTextureAsync(g,I).then((E=>{E&&(d.emissiveTexture=E)}))),E.length>0&&(this._exporter._materialNeedsUVsSet.add(H),await Promise.all(E))}const l=H._emissiveColor;l.equalsWithEpsilon(Y,j)||(d.emissiveFactor=l.kd()),d.pbrMetallicRoughness=n}_getPixelsFromTextureAsync(E){return function(E){switch(E){case f.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case f.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case f.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case f.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case f.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case f.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case f.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case f.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case f.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case f.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case f.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case f.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(E.textureFormat)?(0,s.l)(E,E._texture.width,E._texture.height):(E.textureType,f.e.TEXTURETYPE_UNSIGNED_BYTE,E.readPixels())}async exportTextureAsync(E,H){const d=this._exporter._extensionsPreExportTextureAsync("exporter",E,H);return d?await d.then((async d=>d?await this._exportTextureInfoAsync(d,H):await this._exportTextureInfoAsync(E,H))):await this._exportTextureInfoAsync(E,H)}async _exportTextureInfoAsync(E,H){let d=this._textureMap.get(E);if(!d){const n=await this._getPixelsFromTextureAsync(E);if(!n)return null;const I=this._exportTextureSampler(E),g=E.mimeType;if(g)switch(g){case"image/jpeg":case"image/png":case"image/webp":H=g;break;default:Z.Tools.Warn(`Unsupported media type: ${g}. Exporting texture as PNG.`)}const l=this._internalTextureToImage,r=E.getInternalTexture().uniqueId;l[r]||(l[r]={});let t=l[r][H];if(void 0===t){const d=E.getSize();t=(async()=>{const Z=await this._getImageDataAsync(n,d.width,d.height,H);return this._exportImage(E.name,H,Z)})(),l[r][H]=t}d=this._exportTextureInfo(await t,I,E.coordinatesIndex),this._textureMap.set(E,d),this._exporter._extensionsPostExportTextures("exporter",d,E)}return d}_exportImage(E,H,d){const n=this._exporter._images;let I;if(this._exporter._shouldUseGlb){I={name:E,mimeType:H,bufferView:void 0};const n=this._exporter._bufferManager.createBufferView(new Uint8Array(d));this._exporter._bufferManager.setBufferView(I,n)}else{const g=E.replace(/\.\/|\/|\.\\|\\/g,"_"),l=function(E){switch(E){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(H);let r=g+l;n.some((E=>E.uri===r))&&(r=`${g}_${Z.Tools.RandomId()}${l}`),I={name:E,uri:r},this._exporter._imageData[r]={data:d,mimeType:H}}return n.push(I),n.length-1}_exportTextureInfo(E,H,d){const n=this._exporter._textures;let Z=n.findIndex((d=>d.sampler==H&&d.source===E));-1===Z&&(Z=n.length,n.push({source:E,sampler:H}));const I={index:Z};return d&&(I.texCoord=d),I}_exportTextureSampler(E){const H=this._getTextureSampler(E),d=this._exporter._samplers,n=d.findIndex((E=>E.minFilter===H.minFilter&&E.magFilter===H.magFilter&&E.wrapS===H.wrapS&&E.wrapT===H.wrapT));return-1!==n?n:(d.push(H),d.length-1)}}var O=d(12480),G=d(12237),x=d(12871),q=d(12391);const b=n.wH.Zero(),h=n.Quaternion.Identity(),y=n.wH.One(),v=new n.wH(-1,1,1);function z(E,H){const{byteOffset:d,byteStride:n,type:Z,normalized:I}=E,g=E.getSize(),l=H.reduce(((E,H)=>H.getTotalVertices()>E?H.getTotalVertices():E),-Number.MAX_VALUE);return{byteOffset:d,byteStride:n,componentCount:g,type:Z,count:l*g,normalized:I,totalVertices:l,kind:E.getKind()}}function K(E){switch(E){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function N(E){switch(E){case S.g.PositionKind:case S.g.NormalKind:case S.g.TangentKind:case S.g.ColorKind:case S.g.MatricesIndicesKind:case S.g.MatricesIndicesExtraKind:case S.g.MatricesWeightsKind:case S.g.MatricesWeightsExtraKind:case S.g.UVKind:case S.g.UV2Kind:case S.g.UV3Kind:case S.g.UV4Kind:case S.g.UV5Kind:case S.g.UV6Kind:return!0}return!1}function mE(E){switch(E){case I.b.TriangleFillMode:return 4;case I.b.TriangleStripDrawMode:return 5;case I.b.TriangleFanDrawMode:return 6;case I.b.PointListDrawMode:case I.b.PointFillMode:return 0;case I.b.LineLoopDrawMode:return 2;case I.b.LineListDrawMode:return 1;case I.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${E}`)}function T(E){const H=Math.sqrt(E.x*E.x+E.y*E.y+E.z*E.z);H>0&&(E.x/=H,E.y/=H,E.z/=H)}function A(E){return E.x*=-1,E}function B(E){if(E.x*E.x+E.y*E.y>.5){const H=Math.abs(E.x),d=Math.abs(E.y);if(H>d){const d=Math.sign(E.x);E.x=H,E.y*=-d,E.z*=-d,E.w*=d}else{const H=Math.sign(E.y);E.x*=-H,E.y=d,E.z*=H,E.w*=-H}}else{const H=Math.abs(E.z),d=Math.abs(E.w);if(H>d){const d=Math.sign(E.z);E.x*=-d,E.y*=d,E.z=H,E.w*=-d}else{const H=Math.sign(E.w);E.x*=H,E.y*=-H,E.z*=-H,E.w=d}}return E}function J(E){E.en(-E.z,E.w,E.x,-E.y)}function EE(E,H){const d=n.wH.FromArrayToRef(H.translation||[0,0,0],0,n.TmpVectors.wH[0]),Z=n.Quaternion.FromArrayToRef(H.rotation||[0,0,0,1],0,n.TmpVectors.Quaternion[0]),I=n.Matrix.ComposeToRef(y,Z,d,n.TmpVectors.Matrix[0]),g=n.wH.FromArrayToRef(E.translation||[0,0,0],0,n.TmpVectors.wH[2]),l=n.Quaternion.FromArrayToRef(E.rotation||[0,0,0,1],0,n.TmpVectors.Quaternion[1]),r=n.Matrix.ComposeToRef(y,l,g,n.TmpVectors.Matrix[1]);I.multiplyToRef(r,r),r.decompose(void 0,Z,d),d.equalsWithEpsilon(b,q.c)?delete H.translation:H.translation=d.kd(),Z.equalsWithEpsilon(h,q.c)?delete H.rotation:H.rotation=Z.kd(),H.scale&&delete H.scale}function HE(E,H){if(!(H instanceof M.e))return!1;if(!(1===H.getChildren().length&&0===E.getChildren().length&&E.parent===H))return!1;const d=E.fE(),n=E instanceof x.d&&!d.useRightHandedSystem?v:y;return!!H.mg.equalsWithEpsilon(n,q.c)||(G.b.Warn(`Cannot collapse node ${E.name} into parent node ${H.name} with modified scaling.`),!1)}function dE(E){if(E instanceof Array){const H=new Float32Array(E);return new Uint8Array(H.buffer,H.byteOffset,H.byteLength)}return ArrayBuffer.isView(E)?new Uint8Array(E.buffer,E.byteOffset,E.byteLength):new Uint8Array(E)}function nE(E,H){for(const[d,n]of Object.entries(E)){const Z=H[d];(Array.isArray(n)&&Array.isArray(Z)&&ZE(n,Z)||n===Z)&&delete E[d]}return E}function ZE(E,H){return E.length===H.length&&E.every(((E,d)=>E===H[d]))}const IE=n.Matrix.Compose(new n.wH(-1,1,1),n.Quaternion.Identity(),n.wH.Zero());function gE(E,H){if(!(E instanceof M.e))return!1;if(H){if(!E.getWorldMatrix().equalsWithEpsilon(n.Matrix.IdentityReadOnly,q.c))return!1}else{if(!E.getWorldMatrix().multiplyToRef(IE,n.TmpVectors.Matrix[0]).equalsWithEpsilon(n.Matrix.IdentityReadOnly,q.c))return!1}return!(E instanceof V.b&&E.Kd)}const lE=new Map([[Int8Array,(E,H,d)=>E.setInt8(H,d)],[Uint8Array,(E,H,d)=>E.setUint8(H,d)],[Uint8ClampedArray,(E,H,d)=>E.setUint8(H,d)],[Int16Array,(E,H,d)=>E.setInt16(H,d,!0)],[Uint16Array,(E,H,d)=>E.setUint16(H,d,!0)],[Int32Array,(E,H,d)=>E.setInt32(H,d,!0)],[Uint32Array,(E,H,d)=>E.setUint32(H,d,!0)],[Float32Array,(E,H,d)=>E.setFloat32(H,d,!0)],[Float64Array,(E,H,d)=>E.setFloat64(H,d,!0)]]);class rE{writeTypedArray(E){this._checkGrowBuffer(E.byteLength);const H=lE.get(E.constructor);for(let d=0;d<E.length;d++)H(this._dataView,this._byteOffset,E[d]),this._byteOffset+=E.BYTES_PER_ELEMENT}constructor(E){this._data=new Uint8Array(E),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(E){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,E),this._byteOffset++}writeInt8(E){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,E),this._byteOffset++}writeInt16(E){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,E,!0),this._byteOffset+=2}writeUInt16(E){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,E,!0),this._byteOffset+=2}writeInt32(E){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,E,!0),this._byteOffset+=4}writeUInt32(E){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,E,!0),this._byteOffset+=4}writeFloat32(E){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,E,!0),this._byteOffset+=4}writeFloat64(E){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,E,!0),this._byteOffset+=8}_checkGrowBuffer(E){const H=this.byteOffset+E;if(H>this._data.byteLength){const E=new Uint8Array(2*H);E.set(this._data),this._data=E,this._dataView=new DataView(this._data.buffer)}}}function tE(E){return E%4===0?4:E%2===0?2:1}class SE{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(E){let H=0;this._bufferViewToData.forEach((E=>{H+=E.byteLength}));const d=new rE(H),n=Array.from(this._bufferViewToData.keys()).sort(((E,H)=>tE(H.byteLength)-tE(E.byteLength)));for(const Z of n){Z.byteOffset=d.byteOffset,E.push(Z);const H=E.length-1,n=this.getPropertiesWithBufferView(Z);for(const E of n)E.bufferView=H;d.writeTypedArray(this._bufferViewToData.get(Z)),this._bufferViewToData.delete(Z)}return d.getOutputData()}createBufferView(E,H){const d={buffer:0,byteOffset:void 0,byteLength:E.byteLength,byteStride:H};return this._bufferViewToData.set(d,E),d}createAccessor(E,H,d,n,Z,I,g){this._verifyBufferView(E);const l={bufferView:void 0,componentType:d,count:n,type:H,min:null===I||void 0===I?void 0:I.min,max:null===I||void 0===I?void 0:I.max,normalized:g,byteOffset:Z};return this.setBufferView(l,E),this._accessorToBufferView.set(l,E),l}setBufferView(E,H){this._verifyBufferView(H);this.getPropertiesWithBufferView(H).push(E)}removeBufferView(E){const H=this.getPropertiesWithBufferView(E);for(const d of H)void 0!==d.bufferView&&delete d.bufferView;this._bufferViewToData.delete(E),this._bufferViewToProperties.delete(E),this._accessorToBufferView.forEach(((H,d)=>{H===E&&(void 0!==d.byteOffset&&delete d.byteOffset,this._accessorToBufferView.delete(d))}))}getBufferView(E){const H=this._accessorToBufferView.get(E);return this._verifyBufferView(H),H}getPropertiesWithBufferView(E){return this._verifyBufferView(E),this._bufferViewToProperties.set(E,this._bufferViewToProperties.get(E)??[]),this._bufferViewToProperties.get(E)}getData(E){return this._verifyBufferView(E),this._bufferViewToData.get(E)}_verifyBufferView(E){if(void 0===E||!this._bufferViewToData.has(E))throw new Error(`BufferView ${E} not found in BufferManager.`)}}var ME,VE=d(12845),CE=d(12854),wE=d(12873),RE=d(12770),QE=d(12910),LE=d(12916),DE=d(12840),eE=d(12919);!function(E){E[E.INTANGENT=0]="INTANGENT",E[E.OUTTANGENT=1]="OUTTANGENT"}(ME||(ME={}));class sE{static _IsTransformable(E){return E&&(E instanceof M.e||E instanceof VE.b||E instanceof eE.e)}static _CreateNodeAnimation(E,H,d,n,I){if(this._IsTransformable(E)){const g=[],l=[],r=H.getKeys(),t=sE._CalculateMinMaxKeyFrames(r),S=sE._DeduceInterpolation(r,d,n),M=S.interpolationType,V=S.shouldBakeAnimation;if(V?sE._CreateBakedAnimation(E,H,d,t.min,t.max,H.framePerSecond,I,g,l,t,n):"LINEAR"===M||"STEP"===M?sE._CreateLinearOrStepAnimation(E,H,d,g,l,n):"CUBICSPLINE"===M?sE._CreateCubicSplineAnimation(E,H,d,g,l,n):sE._CreateBakedAnimation(E,H,d,t.min,t.max,H.framePerSecond,I,g,l,t,n),g.length&&l.length){return{inputs:g,outputs:l,samplerInterpolation:M,inputsMin:V?t.min:Z.Tools.FloatRound(t.min/H.framePerSecond),inputsMax:V?t.max:Z.Tools.FloatRound(t.max/H.framePerSecond)}}}return null}static _DeduceAnimationInfo(E){let H=null,d="VEC3",n=!1;const I=E.targetProperty.split(".");switch(I[0]){case"mg":H="scale";break;case"position":H="translation";break;case"rotation":d="VEC4",H="rotation";break;case"rotationQuaternion":d="VEC4",n=!0,H="rotation";break;case"influence":d="SCALAR",H="weights";break;default:Z.Tools.Error(`Unsupported animatable property ${I[0]}`)}return H?{animationChannelTargetPath:H,dataAccessorType:d,useQuaternion:n}:(Z.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(E,H,d,n,Z,I,g,l,r,t,S){let M;if(sE._IsTransformable(E)&&E.animations)for(const V of E.animations){if(S&&!S(V))continue;const Z=sE._DeduceAnimationInfo(V);Z&&(M={name:V.name,samplers:[],channels:[]},sE._AddAnimation(`${V.name}`,V.hasRunningRuntimeAnimations?H:M,E,V,Z.dataAccessorType,Z.animationChannelTargetPath,n,I,g,l,Z.useQuaternion,r,t),M.samplers.length&&M.channels.length&&d.push(M))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(E,H,d,n,Z,I,g,l,r,t,S){let M;if(E instanceof DE.e){const Z=E.morphTargetManager;if(Z)for(let V=0;V<Z.numTargets;++V){const C=Z.getTarget(V);for(const w of C.animations){if(S&&!S(w))continue;const C=new QE.b(`${w.name}`,"influence",w.framePerSecond,w.dataType,w.loopMode,w.enableBlending),R=[],Q=w.getKeys();for(let E=0;E<Q.length;++E){const H=Q[E];for(let E=0;E<Z.numTargets;++E)E==V?R.push(H):R.push({frame:H.frame,value:0})}C.setKeys(R);const L=sE._DeduceAnimationInfo(C);L&&(M={name:C.name,samplers:[],channels:[]},sE._AddAnimation(w.name,w.hasRunningRuntimeAnimations?H:M,E,C,L.dataAccessorType,L.animationChannelTargetPath,n,I,g,l,L.useQuaternion,r,t,Z.numTargets),M.samplers.length&&M.channels.length&&d.push(M))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(E,H,d,n,Z,I,g,l,r){let t;if(E.animationGroups){const M=E.animationGroups;for(const V of M){const M=new Map,C=new Map,w=new Set,R=V.to-V.from;t={name:V.name,channels:[],samplers:[]};for(let H=0;H<V.targetedAnimations.length;++H){const R=V.targetedAnimations[H],Q=R.target,L=R.animation;if(r&&!r(L))continue;const D=l.has(Q);if(this._IsTransformable(Q)||1===Q.length&&this._IsTransformable(Q[0])){const E=sE._DeduceAnimationInfo(R.animation);if(E){const H=this._IsTransformable(Q)?Q:this._IsTransformable(Q[0])?Q[0]:null;H&&sE._AddAnimation(`${L.name}`,t,H,L,E.dataAccessorType,E.animationChannelTargetPath,d,n,Z,I,E.useQuaternion,g,D)}}else if(Q instanceof LE.e||1===Q.length&&Q[0]instanceof LE.e){if(sE._DeduceAnimationInfo(R.animation)){const H=Q instanceof LE.e?Q:Q[0];if(H){const d=E.morphTargetManagers.find((E=>{for(let d=0;d<E.numTargets;++d)if(E.getTarget(d)===H)return!0;return!1}));if(d){const n=E.meshes.find((E=>E.morphTargetManager===d));var S;if(n)M.has(n)||M.set(n,new Map),null===(S=M.get(n))||void 0===S||S.set(H,L),w.add(n),C.set(n,L)}}}}}w.forEach((E=>{const H=E.morphTargetManager;let l=null;const r=[],S=C.get(E).getKeys(),w=S.length;for(let d=0;d<w;++d)for(let n=0;n<H.numTargets;++n){const Z=H.getTarget(n),I=M.get(E);if(I){const H=I.get(Z);H?(l||(l=new QE.b(`${V.name}_${E.name}_MorphWeightAnimation`,"influence",H.framePerSecond,QE.b.ANIMATIONTYPE_FLOAT,H.loopMode,H.enableBlending)),r.push(H.getKeys()[d])):r.push({frame:V.from+R/w*d,value:Z.influence,inTangent:S[0].inTangent?0:void 0,outTangent:S[0].outTangent?0:void 0})}}l.setKeys(r);const Q=sE._DeduceAnimationInfo(l);Q&&sE._AddAnimation(`${V.name}_${E.name}_MorphWeightAnimation`,t,E,l,Q.dataAccessorType,Q.animationChannelTargetPath,d,n,Z,I,Q.useQuaternion,g,!1,null===H||void 0===H?void 0:H.numTargets)})),t.channels.length&&t.samplers.length&&H.push(t)}}}static _AddAnimation(E,H,d,Z,I,g,l,r,t,S,M,V,C,w){const R=sE._CreateNodeAnimation(d,Z,g,M,V);let Q,L,D,e,s,i;if(R){if(w){let E=0,H=0;const d=[];for(;R.inputs.length>0;)H=R.inputs.shift(),E%w==0&&d.push(H),E++;R.inputs=d}const E=l.get(d),Z=new Float32Array(R.inputs);Q=r.createBufferView(Z),L=r.createAccessor(Q,"SCALAR",5126,R.inputs.length,void 0,{min:[R.inputsMin],max:[R.inputsMax]}),S.push(L),D=S.length-1;const t=new n.Quaternion,M=new n.wH,V=new n.wH,p=d instanceof VE.b,f=K(I),P=new Float32Array(R.outputs.length*f);R.outputs.forEach((function(E,H){let d=E;switch(g){case"translation":C&&(n.wH.FromArrayToRef(E,0,V),A(V),V.toArray(d));break;case"rotation":4===E.length?n.Quaternion.FromArrayToRef(E,0,t):(d=new Array(4),n.wH.FromArrayToRef(E,0,M),n.Quaternion.FromEulerVectorToRef(M,t)),C&&(B(t),p&&J(t)),t.toArray(d)}P.set(d,H*f)})),Q=r.createBufferView(P),L=r.createAccessor(Q,I,5126,R.outputs.length),S.push(L),e=S.length-1,s={interpolation:R.samplerInterpolation,input:D,output:e},H.samplers.push(s),i={sampler:H.samplers.length-1,target:{node:E,path:g}},H.channels.push(i)}}static _CreateBakedAnimation(E,H,d,I,g,l,r,t,S,M,V){let C;const w=n.Quaternion.Identity();let R,Q=null,L=null,D=null,e=null,s=null,i=null;M.min=Z.Tools.FloatRound(I/l);const p=H.getKeys();for(let n=0,f=p.length;n<f;++n){if(i=null,D=p[n],n+1<f)if(e=p[n+1],D.value.equals&&D.value.equals(e.value)||D.value===e.value){if(0!==n)continue;i=D.frame}else i=e.frame;else{if(s=p[n-1],D.value.equals&&D.value.equals(s.value)||D.value===s.value)continue;i=g}if(i)for(let n=D.frame;n<=i;n+=r){if(R=Z.Tools.FloatRound(n/l),R===Q)continue;Q=R,L=R;const I={key:0,repeatCount:0,loopMode:H.loopMode};C=H._interpolate(n,I),sE._SetInterpolatedValue(E,C,R,H,d,w,t,S,V)}}L&&(M.max=L)}static _ConvertFactorToVector3OrQuaternion(E,H,d,I,g){const l=sE._GetBasePositionRotationOrScale(H,I,g),r=d.targetProperty.split("."),t=r?r[1]:"",S=g?n.Quaternion.eH(l).normalize():n.wH.eH(l);switch(t){case"x":case"y":case"z":S[t]=E;break;case"w":S.w=E;break;default:Z.Tools.Error(`glTFAnimation: Unsupported component name "${t}"!`)}return S}static _SetInterpolatedValue(E,H,d,Z,I,g,l,r,t){let S;l.push(d),"weights"!==I?(Z.dataType===QE.b.ANIMATIONTYPE_FLOAT&&(H=this._ConvertFactorToVector3OrQuaternion(H,E,Z,I,t)),"rotation"===I?(t?g=H:(S=H,n.Quaternion.RotationYawPitchRollToRef(S.y,S.x,S.z,g)),r.push(g.kd())):(S=H,r.push(S.kd()))):r.push([H])}static _CreateLinearOrStepAnimation(E,H,d,n,Z,I){for(const g of H.getKeys())n.push(g.frame/H.framePerSecond),sE._AddKeyframeValue(g,H,Z,d,E,I)}static _CreateCubicSplineAnimation(E,H,d,n,Z,I){H.getKeys().forEach((function(g){n.push(g.frame/H.framePerSecond),sE._AddSplineTangent(ME.INTANGENT,Z,d,"CUBICSPLINE",g,I),sE._AddKeyframeValue(g,H,Z,d,E,I),sE._AddSplineTangent(ME.OUTTANGENT,Z,d,"CUBICSPLINE",g,I)}))}static _GetBasePositionRotationOrScale(E,H,d){let Z;if("rotation"===H)if(d){Z=(E.rotationQuaternion??n.Quaternion.Identity()).kd()}else{Z=(E.rotation??n.wH.Zero()).kd()}else if("translation"===H){Z=(E.position??n.wH.Zero()).kd()}else{Z=(E.mg??n.wH.One()).kd()}return Z}static _AddKeyframeValue(E,H,d,I,g,l){let r;const t=H.dataType;if(t===QE.b.ANIMATIONTYPE_VECTOR3){let H=E.value.kd();if("rotation"===I){const E=n.wH.eH(H);H=n.Quaternion.RotationYawPitchRoll(E.y,E.x,E.z).kd()}d.push(H)}else if(t===QE.b.ANIMATIONTYPE_FLOAT){if("weights"===I)d.push([E.value]);else if(r=this._ConvertFactorToVector3OrQuaternion(E.value,g,H,I,l),r){if("rotation"===I){const E=l?r:n.Quaternion.RotationYawPitchRoll(r.y,r.x,r.z).normalize();d.push(E.kd())}d.push(r.kd())}}else t===QE.b.ANIMATIONTYPE_QUATERNION?d.push(E.value.normalize().kd()):Z.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(E,H,d){let n,Z,I=!1;if("rotation"===H&&!d)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let g=0,l=E.length;g<l;++g)if(Z=E[g],Z.inTangent||Z.outTangent)if(n){if("CUBICSPLINE"!==n){n="LINEAR",I=!0;break}}else n="CUBICSPLINE";else if(n){if("CUBICSPLINE"===n||Z.interpolation&&1===Z.interpolation&&"STEP"!==n){n="LINEAR",I=!0;break}}else n=Z.interpolation&&1===Z.interpolation?"STEP":"LINEAR";return n||(n="LINEAR"),{interpolationType:n,shouldBakeAnimation:I}}static _AddSplineTangent(E,H,d,Z,I,g){let l;const r=E===ME.INTANGENT?I.inTangent:I.outTangent;if("CUBICSPLINE"===Z){if("rotation"===d)if(r)if(g)l=r.kd();else{const E=r;l=n.Quaternion.RotationYawPitchRoll(E.y,E.x,E.z).kd()}else l=[0,0,0,0];else l="weights"===d?r?[r]:[0]:r?r.kd():[0,0,0];H.push(l)}}static _CalculateMinMaxKeyFrames(E){let H=1/0,d=-1/0;return E.forEach((function(E){H=Math.min(H,E.frame),d=Math.max(d,E.frame)})),{min:H,max:d}}}function iE(E,H,d,I,g,l){const r={attributes:{},influence:E.influence,name:E.name},t=H.Kd;if(!t)return Z.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),r;const M=l?-1:1,V=n.wH.Zero();let C=0,w=0;if(E.hasPositions){const I=E.getPositions(),l=t.getVerticesData(S.g.PositionKind);if(l){const E=new Float32Array(l.length),H=[1/0,1/0,1/0],Z=[-1/0,-1/0,-1/0];w=l.length/3,C=0;for(let d=C;d<w;++d){const g=n.wH.eH(l,3*d);n.wH.eH(I,3*d).subtractToRef(g,V),V.x*=M,H[0]=Math.min(H[0],V.x),Z[0]=Math.max(Z[0],V.x),H[1]=Math.min(H[1],V.y),Z[1]=Math.max(Z[1],V.y),H[2]=Math.min(H[2],V.z),Z[2]=Math.max(Z[2],V.z),E[3*d]=V.x,E[3*d+1]=V.y,E[3*d+2]=V.z}const t=d.createBufferView(E,12),S=d.createAccessor(t,"VEC3",5126,I.length/3,0,{min:H,max:Z});g.push(S),r.attributes.POSITION=g.length-1}else Z.Tools.Warn(`Morph target positions for mesh ${H.name} were not exported. Mesh does not have position vertex data`)}if(E.hasNormals){const I=E.getNormals(),l=t.getVerticesData(S.g.NormalKind);if(l){const E=new Float32Array(l.length);w=l.length/3,C=0;for(let d=C;d<w;++d){const H=n.wH.eH(l,3*d).normalize();n.wH.eH(I,3*d).normalize().subtractToRef(H,V),E[3*d]=V.x*M,E[3*d+1]=V.y,E[3*d+2]=V.z}const H=d.createBufferView(E,12),Z=d.createAccessor(H,"VEC3",5126,I.length/3,0);g.push(Z),r.attributes.NORMAL=g.length-1}else Z.Tools.Warn(`Morph target normals for mesh ${H.name} were not exported. Mesh does not have normals vertex data`)}if(E.hasTangents){const I=E.getTangents(),l=t.getVerticesData(S.g.TangentKind);if(l){w=l.length/4;const E=new Float32Array(3*w);C=0;for(let d=C;d<w;++d){const H=n.wH.eH(l,4*d);T(H);const Z=n.wH.eH(I,3*d);T(Z),Z.subtractToRef(H,V),E[3*d]=V.x*M,E[3*d+1]=V.y,E[3*d+2]=V.z}const H=d.createBufferView(E,12),Z=d.createAccessor(H,"VEC3",5126,w,0);g.push(Z),r.attributes.TANGENT=g.length-1}else Z.Tools.Warn(`Morph target tangents for mesh ${H.name} were not exported. Mesh does not have tangents vertex data`)}if(E.hasColors){const I=E.getColors(),l=t.getVerticesData(S.g.ColorKind),M=t.getVertexBuffer(S.g.ColorKind);if(l&&M){const E=M.getSize();w=l.length/E;const H=new Float32Array(w*E);C=0;for(let d=C;d<w;++d)if(3===E){const Z=n.wH.eH(l,d*E);n.wH.eH(I,d*E).subtractToRef(Z,V),H[3*d]=V.x,H[3*d+1]=V.y,H[3*d+2]=V.z}else if(4===E){const Z=new n.Vector4,g=n.Vector4.eH(l,d*E);n.Vector4.eH(I,d*E).subtractToRef(g,Z),H[4*d]=Z.x,H[4*d+1]=Z.y,H[4*d+2]=Z.z,H[4*d+3]=Z.w}else Z.Tools.Warn(`Unsupported number of components for color attribute: ${E}`);const t=d.createBufferView(H,4*E),S=d.createAccessor(t,3===E?"VEC3":"VEC4",5126,w,0);g.push(S),r.attributes.COLOR_0=g.length-1}else Z.Tools.Warn(`Morph target colors for mesh ${H.name} were not exported. Mesh does not have colors vertex data`)}return r}var pE=d(12927),fE=d(12795),PE=d(12781),jE=d(12344);class XE{}XE.DEFAULT_COLOR=Q.DH.White(),XE.DEFAULT_WIDTH_ATTENUATED=1,XE.DEFAULT_WIDTH=.1;var WE=d(12608),UE=d(12933);class YE{static ConvertPoints(E,H){if(E.length&&Array.isArray(E)&&"number"===typeof E[0])return[E];if(E.length&&Array.isArray(E[0])&&"number"===typeof E[0][0])return E;if(E.length&&!Array.isArray(E[0])&&E[0]instanceof n.wH){const H=[];for(let d=0;d<E.length;d++){const n=E[d];H.push(n.x,n.y,n.z)}return[H]}if(E.length>0&&Array.isArray(E[0])&&E[0].length>0&&E[0][0]instanceof n.wH){const H=[],d=E;for(const E of d)H.push(E.flatMap((E=>[E.x,E.y,E.z])));return H}if(E instanceof Float32Array){if(null!==H&&void 0!==H&&H.floatArrayStride){const d=[],n=3*H.floatArrayStride;for(let H=0;H<E.length;H+=n){const Z=new Array(n);for(let d=0;d<n;d++)Z[d]=E[H+d];d.push(Z)}return d}return[Array.from(E)]}if(E.length&&E[0]instanceof Float32Array){const H=[];for(const d of E)H.push(Array.from(d));return H}return[]}static OmitZeroLengthPredicate(E,H,d){const n=[];return H.RH(E).lengthSquared()>0&&n.push([E,H]),d.RH(H).lengthSquared()>0&&n.push([H,d]),E.RH(d).lengthSquared()>0&&n.push([d,E]),0===n.length?null:n}static OmitDuplicatesPredicate(E,H,d,n){const Z=[];return YE._SearchInPoints(E,H,n)||Z.push([E,H]),YE._SearchInPoints(H,d,n)||Z.push([H,d]),YE._SearchInPoints(d,E,n)||Z.push([d,E]),0===Z.length?null:Z}static _SearchInPoints(E,H,d){for(const g of d)for(let d=0;d<g.length;d++){var n,Z,I;if(null!==(n=g[d])&&void 0!==n&&n.equals(E))if(null!==(Z=g[d+1])&&void 0!==Z&&Z.equals(H)||null!==(I=g[d-1])&&void 0!==I&&I.equals(H))return!0}return!1}static MeshesToLines(E,H){const d=[];for(let Z=0;Z<E.length;Z++){const I=E[Z],g=I.getVerticesData(S.g.PositionKind),l=I.Nd();if(g&&l)for(let E=0,r=0;E<l.length;E++){const t=3*l[r++],S=3*l[r++],M=3*l[r++],V=new n.wH(g[t],g[t+1],g[t+2]),C=new n.wH(g[S],g[S+1],g[S+2]),w=new n.wH(g[M],g[M+1],g[M+2]);if(H){const n=H(V,C,w,d,E,t,I,Z,g,l);if(n)for(const E of n)d.push(E)}else d.push([V,C],[C,w],[w,V])}}return d}static ToVector3Array(E){if(Array.isArray(E[0])){const H=[],d=E;for(const E of d){const d=[];for(let H=0;H<E.length;H+=3)d.push(new n.wH(E[H],E[H+1],E[H+2]));H.push(d)}return H}const H=E,d=[];for(let Z=0;Z<H.length;Z+=3)d.push(new n.wH(H[Z],H[Z+1],H[Z+2]));return d}static ToNumberArray(E){return E.flatMap((E=>[E.x,E.y,E.z]))}static GetPointsCountInfo(E){const H=new Array(E.length);let d=0;for(let n=E.length;n--;)H[n]=E[n].length/3,d+=H[n];return{total:d,counts:H}}static GetLineLength(E){if(0===E.length)return 0;let H;H="number"===typeof E[0]?YE.ToVector3Array(E):E;const d=n.TmpVectors.wH[0];let Z=0;for(let n=0;n<H.length-1;n++){const E=H[n];Z+=H[n+1].subtractToRef(E,d).length()}return Z}static GetLineLengthArray(E){const H=new Float32Array(E.length/3);let d=0;for(let n=0,Z=E.length/3-1;n<Z;n++){let Z=E[3*n+0],I=E[3*n+1],g=E[3*n+2];Z-=E[3*n+3],I-=E[3*n+4],g-=E[3*n+5];d+=Math.sqrt(Z*Z+I*I+g*g),H[n+1]=d}return H}static SegmentizeSegmentByCount(E,H,d){const Z=[],I=H.RH(E),g=n.TmpVectors.wH[0];g.ng(d);const l=n.TmpVectors.wH[1];I.divideToRef(g,l);let r=E.clone();Z.push(r);for(let n=0;n<d;n++)r=r.clone(),Z.push(r.addInPlace(l));return Z}static SegmentizeLineBySegmentLength(E,H){const d=E[0]instanceof n.wH?YE.GetLineSegments(E):"number"===typeof E[0]?YE.GetLineSegments(YE.ToVector3Array(E)):E,Z=[];for(const n of d)if(n.length>H){const E=YE.SegmentizeSegmentByCount(n.point1,n.point2,Math.ceil(n.length/H));for(const H of E)Z.push(H)}else Z.push(n.point1),Z.push(n.point2);return Z}static SegmentizeLineBySegmentCount(E,H){const d="number"===typeof E[0]?YE.ToVector3Array(E):E,n=YE.GetLineLength(d)/H;return YE.SegmentizeLineBySegmentLength(d,n)}static GetLineSegments(E){const H=[];for(let d=0;d<E.length-1;d++){const n=E[d],Z=E[d+1],I=Z.RH(n).length();H.push({point1:n,point2:Z,length:I})}return H}static GetMinMaxSegmentLength(E){const H=YE.GetLineSegments(E).sort((E=>E.length));return{min:H[0].length,max:H[H.length-1].length}}static GetPositionOnLineByVisibility(E,H,d){let Z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const I=H*d;let g=0,l=0;const r=E.length;for(let n=0;n<r;n++){if(I<=g+E[n].length){l=n;break}g+=E[n].length}const t=(I-g)/E[l].length;return E[l].point2.subtractToRef(E[l].point1,n.TmpVectors.wH[0]),n.TmpVectors.wH[1]=n.TmpVectors.wH[0].multiplyByFloats(t,t,t),Z||n.TmpVectors.wH[1].addInPlace(E[l].point1),n.TmpVectors.wH[1].clone()}static GetCircleLinePoints(E,H){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:E,I=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/H;const g=[];for(let l=0;l<=H;l++)g.push(new n.wH(Math.cos(l*I)*E,Math.sin(l*I)*Z,d));return g}static GetBezierLinePoints(E,H,d,n){return WE.e.CreateQuadraticBezier(E,H,d,n).getPoints().flatMap((E=>[E.x,E.y,E.z]))}static GetArrowCap(E,H,d,n,Z){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[E.clone(),E.add(H.multiplyByFloats(d,d,d))],widths:[n,Z,I,g]}}static GetPointsFromText(E,H,d,n){let Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,I=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const g=[],l=(0,UE.d)(E,H,d,n);for(const r of l){for(const E of r.paths){const H=[],d=E.getPoints();for(const E of d)H.push(E.x,E.y,Z);g.push(H)}if(I)for(const E of r.holes){const H=[],d=E.getPoints();for(const E of d)H.push(E.x,E.y,Z);g.push(H)}}return g}static Color3toRGBAUint8(E){const H=new Uint8Array(4*E.length);for(let d=0,n=0;d<E.length;d++)H[n++]=255*E[d].r,H[n++]=255*E[d].g,H[n++]=255*E[d].b,H[n++]=255;return H}static CreateColorsTexture(E,H,d,n){const Z=n.getEngine().getCaps().maxTextureSize??1,I=H.length>Z?Z:H.length,g=Math.ceil(H.length/Z);g>1&&(H=[...H,...Array(I*g-H.length).fill(H[0])]);const l=YE.Color3toRGBAUint8(H),r=new p.b(l,I,g,w.b.TEXTUREFORMAT_RGBA,n,!1,!0,d);return r.name=E,r}static PrepareEmptyColorsTexture(E){if(!XE.EmptyColorsTexture){const H=new Uint8Array(4);XE.EmptyColorsTexture=new p.b(H,1,1,w.b.TEXTUREFORMAT_RGBA,E,!1,!1,p.b.NEAREST_NEAREST),XE.EmptyColorsTexture.name="grlEmptyColorsTexture"}return XE.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var E;null===(E=XE.EmptyColorsTexture)||void 0===E||E.dispose(),XE.EmptyColorsTexture=null}static BooleanToNumber(E){return E?1:0}}class cE extends PE.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class uE extends fE.c{isCompatible(E){return!0}constructor(E,H,d){var Z;d=d||{color:XE.DEFAULT_COLOR};const I=new cE;I.GREASED_LINE_HAS_COLOR=!!d.color&&!d.useColors,I.GREASED_LINE_SIZE_ATTENUATION=d.sizeAttenuation??!1,I.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===d.colorDistributionType,I.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(H??E.fE()).useRightHandedSystem,I.GREASED_LINE_CAMERA_FACING=d.cameraFacing??!0,super(E,uE.GREASED_LINE_MATERIAL_NAME,200,I,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(Z=d)||void 0===Z?void 0:Z.forceGLSL)||uE.ForceGLSL,this._scene=H??E.fE(),this._engine=this._scene.getEngine(),this._cameraFacing=d.cameraFacing??!0,this.visibility=d.visibility??1,this.useDash=d.useDash??!1,this.dashRatio=d.dashRatio??.5,this.dashOffset=d.dashOffset??0,this.width=d.width?d.width:d.sizeAttenuation?XE.DEFAULT_WIDTH_ATTENUATED:XE.DEFAULT_WIDTH,this._sizeAttenuation=d.sizeAttenuation??!1,this.colorMode=d.colorMode??0,this._color=d.color??null,this.useColors=d.useColors??!1,this._colorsDistributionType=d.colorDistributionType??0,this.colorsSampling=d.colorsSampling??p.b.NEAREST_NEAREST,this._colors=d.WE??null,this.dashCount=d.dashCount??1,this.resolution=d.resolution??new n.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),d.colorsTexture?this.colorsTexture=d.colorsTexture:this._colors?this.colorsTexture=YE.CreateColorsTexture(`${E.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??XE.DEFAULT_COLOR,YE.PrepareEmptyColorsTexture(this._scene)),this._engine.Qd.add((()=>{YE.DisposeEmptyColorsTexture()}))}getAttributes(E){E.push("grl_offsets"),E.push("grl_widths"),E.push("grl_colorPointers"),E.push("grl_counters"),this._cameraFacing?(E.push("grl_previousAndSide"),E.push("grl_nextAndCounters")):E.push("grl_slopes")}getSamplers(E){E.push("grl_colors")}getActiveTextures(E){this.colorsTexture&&E.push(this.colorsTexture)}getUniforms(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const H=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&H.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===E&&H.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:H,vertex:this._cameraFacing&&this._isGLSL(E)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(E)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(E){if(this._cameraFacing){E.bd("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||E.bd("viewProjection",this._scene.getTransformMatrix());const H=n.TmpVectors.Vector4[0];H.x=this._aspect,H.y=this._resolution.x,H.z=this._resolution.y,H.w=this.width,E.updateVector4("grl_aspect_resolution_lineWidth",H)}const H=n.TmpVectors.Vector4[0];H.x=YE.BooleanToNumber(this.useDash),H.y=this._dashArray,H.z=this.dashOffset,H.w=this.dashRatio,E.updateVector4("grl_dashOptions",H);const d=n.TmpVectors.Vector4[1];d.x=this.colorMode,d.y=this.visibility,d.z=this.colorsTexture?this.colorsTexture.getSize().width:0,d.w=YE.BooleanToNumber(this.useColors),E.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",d),this._color&&E.updateColor3("grl_singleColor",this._color);const Z=this.colorsTexture??XE.EmptyColorsTexture;E.setTexture("grl_colors",Z),E.updateFloat2("grl_textureSize",(null===Z||void 0===Z?void 0:Z.getSize().width)??1,(null===Z||void 0===Z?void 0:Z.getSize().height)??1)}prepareDefines(E,H,d){E.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,E.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,E.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,E.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=H.useRightHandedSystem,E.GREASED_LINE_CAMERA_FACING=this._cameraFacing,E.GREASED_LINE_USE_OFFSETS=!!d.offsets}getClassName(){return uE.GREASED_LINE_MATERIAL_NAME}getCustomCode(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(H)?function(E,H){if("vertex"===E){const E={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return H&&(E["!gl_Position\\=viewProjection\\*worldPos;"]="//"),E}return"fragment"===E?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(E,this._cameraFacing):function(E,H){if("vertex"===E){const E={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return H&&(E["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),E}return"fragment"===E?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(E,this._cameraFacing)}dispose(){var E;null===(E=this.colorsTexture)||void 0===E||E.dispose(),super.dispose()}get WE(){return this._colors}set WE(E){this.setColors(E)}setColors(E){var H;let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Z=(null===(H=this._colors)||void 0===H?void 0:H.length)??0;var I;if(this._colors=E,null!==E&&0!==E.length){if(!d||n)if(this.colorsTexture&&Z===E.length&&!n){const H=YE.Color3toRGBAUint8(E);this.colorsTexture.update(H)}else{var g;null===(g=this.colorsTexture)||void 0===g||g.dispose(),this.colorsTexture=YE.CreateColorsTexture(`${this._material.name}-colors-texture`,E,this.colorsSampling,this._scene)}}else null===(I=this.colorsTexture)||void 0===I||I.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(E){this._dashCount=E,this._dashArray=1/E}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(E){this._sizeAttenuation=E,this.markAllDefinesAsDirty()}get color(){return this._color}set color(E){this.setColor(E)}setColor(E){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==E||null!==this._color&&null===E?(this._color=E,H||this.markAllDefinesAsDirty()):this._color=E}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(E){this._colorsDistributionType=E,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(E){this._aspect=E.x/E.y,this._resolution=E}serialize(){const E=super.serialize(),H={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(H.WE=this._colors),this._color&&(H.color=this._color),E.greasedLineMaterialOptions=H,E}parse(E,H,d){var n;super.parse(E,H,d);const Z=E.greasedLineMaterialOptions;null===(n=this.colorsTexture)||void 0===n||n.dispose(),Z.color&&this.setColor(Z.color,!0),Z.colorDistributionType&&(this.colorsDistributionType=Z.colorDistributionType),Z.WE&&(this.WE=Z.WE),Z.colorsSampling&&(this.colorsSampling=Z.colorsSampling),Z.colorMode&&(this.colorMode=Z.colorMode),Z.useColors&&(this.useColors=Z.useColors),Z.visibility&&(this.visibility=Z.visibility),Z.useDash&&(this.useDash=Z.useDash),Z.dashCount&&(this.dashCount=Z.dashCount),Z.dashRatio&&(this.dashRatio=Z.dashRatio),Z.dashOffset&&(this.dashOffset=Z.dashOffset),Z.width&&(this.width=Z.width),Z.sizeAttenuation&&(this.sizeAttenuation=Z.sizeAttenuation),Z.resolution&&(this.resolution=Z.resolution),this.WE?this.colorsTexture=YE.CreateColorsTexture(`${this._material.name}-colors-texture`,this.WE,this.colorsSampling,H):YE.PrepareEmptyColorsTexture(H),this.markAllDefinesAsDirty()}copyTo(E){var H;const d=E;null===(H=d.colorsTexture)||void 0===H||H.dispose(),this._colors&&(d.colorsTexture=YE.CreateColorsTexture(`${d._material.name}-colors-texture`,this._colors,d.colorsSampling,this._scene)),d.setColor(this.color,!0),d.colorsDistributionType=this.colorsDistributionType,d.colorsSampling=this.colorsSampling,d.colorMode=this.colorMode,d.useColors=this.useColors,d.visibility=this.visibility,d.useDash=this.useDash,d.dashCount=this.dashCount,d.dashRatio=this.dashRatio,d.dashOffset=this.dashOffset,d.width=this.width,d.sizeAttenuation=this.sizeAttenuation,d.resolution=this.resolution,d.markAllDefinesAsDirty()}_isGLSL(E){return 0===E||this._forceGLSL}}uE.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",uE.ForceGLSL=!1,(0,jE.e)(`BABYLON.${uE.GREASED_LINE_MATERIAL_NAME}`,uE);var oE=d(12825),FE=d(12244),aE=d(12627),kE=d(12325);class OE extends aE.ShaderMaterial{constructor(E,H,Z){const I=H.getEngine(),g=I.isWebGPU&&!(Z.forceGLSL||OE.ForceGLSL),l=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];H.useRightHandedSystem&&l.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const r=["position","grl_widths","grl_offsets","grl_colorPointers"];Z.cameraFacing?(l.push("GREASED_LINE_CAMERA_FACING"),r.push("grl_previousAndSide","grl_nextAndCounters")):(r.push("grl_slopes"),r.push("grl_counters"));const t=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(g||t.push("world","viewProjection","view","projection"),super(E,H,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:g?["Scene","Mesh"]:void 0,attributes:r,uniforms:t,samplers:g?[]:["grlColors"],defines:l,extraInitializationsAsync:async()=>{g?await Promise.all([d.e(66).then(d.bind(d,15533)),d.e(75).then(d.bind(d,15535))]):await Promise.all([d.e(69).then(d.bind(d,15537)),d.e(76).then(d.bind(d,15539))])},shaderLanguage:g?1:0}),this._color=Q.DH.White(),this._colorsDistributionType=0,this._colorsTexture=null,Z=Z||{color:XE.DEFAULT_COLOR},this.visibility=Z.visibility??1,this.useDash=Z.useDash??!1,this.dashRatio=Z.dashRatio??.5,this.dashOffset=Z.dashOffset??0,this.dashCount=Z.dashCount??1,this.width=Z.width?Z.width:Z.sizeAttenuation&&Z.cameraFacing?XE.DEFAULT_WIDTH_ATTENUATED:XE.DEFAULT_WIDTH,this.sizeAttenuation=Z.sizeAttenuation??!1,this.color=Z.color??Q.DH.White(),this.useColors=Z.useColors??!1,this.colorsDistributionType=Z.colorDistributionType??0,this.colorsSampling=Z.colorsSampling??p.b.NEAREST_NEAREST,this.colorMode=Z.colorMode??0,this._colors=Z.WE??null,this._cameraFacing=Z.cameraFacing??!0,this.resolution=Z.resolution??new n.Vector2(I.getRenderWidth(),I.getRenderHeight()),Z.colorsTexture?this.colorsTexture=Z.colorsTexture:this._colors?this.colorsTexture=YE.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,H):(this._color=this._color??XE.DEFAULT_COLOR,this.colorsTexture=YE.PrepareEmptyColorsTexture(H)),g){const E=new kE.b;E.setParameters(),E.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",E)}I.Qd.add((()=>{YE.DisposeEmptyColorsTexture()}))}dispose(){var E;null===(E=this._colorsTexture)||void 0===E||E.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new n.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get WE(){return this._colors}set WE(E){this.setColors(E)}setColors(E){var H;let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Z=(null===(H=this._colors)||void 0===H?void 0:H.length)??0;var I;if(this._colors=E,null!==E&&0!==E.length){if(!d||n)if(this._colorsTexture&&Z===E.length&&!n){const H=YE.Color3toRGBAUint8(E);this._colorsTexture.update(H)}else{var g;null===(g=this._colorsTexture)||void 0===g||g.dispose(),this.colorsTexture=YE.CreateColorsTexture(`${this.name}-colors-texture`,E,this.colorsSampling,this.fE())}}else null===(I=this._colorsTexture)||void 0===I||I.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(E){this._colorsTexture=E,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(E){this._width=E,this.setFloat("grlWidth",E)}get useColors(){return this._useColors}set useColors(E){this._useColors=E,this.setFloat("grlUseColors",YE.BooleanToNumber(E))}get colorsSampling(){return this._colorsSampling}set colorsSampling(E){this._colorsSampling=E}get visibility(){return this._visibility}set visibility(E){this._visibility=E,this.setFloat("grlVisibility",E)}get useDash(){return this._useDash}set useDash(E){this._useDash=E,this.setFloat("grlUseDash",YE.BooleanToNumber(E))}get dashOffset(){return this._dashOffset}set dashOffset(E){this._dashOffset=E,this.setFloat("grlDashOffset",E)}get dashRatio(){return this._dashRatio}set dashRatio(E){this._dashRatio=E,this.setFloat("grlDashRatio",E)}get dashCount(){return this._dashCount}set dashCount(E){this._dashCount=E,this._dashArray=1/E,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(E){this._sizeAttenuation=E,this.setFloat("grlSizeAttenuation",YE.BooleanToNumber(E))}get color(){return this._color}set color(E){this.setColor(E)}setColor(E){E=E??XE.DEFAULT_COLOR,this._color=E,this.setColor3("grlColor",E)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(E){this._colorsDistributionType=E,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(E){this._colorMode=E,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(E){this._resolution=E,this.setVector2("grlResolution",E),this.setFloat("grlAspect",E.x/E.y)}serialize(){const E=super.serialize(),H={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(H.WE=this._colors),E.greasedLineMaterialOptions=H,E}parse(E,H,d){var n;const Z=E.greasedLineMaterialOptions;null===(n=this._colorsTexture)||void 0===n||n.dispose(),Z.color&&(this.color=Z.color),Z.colorDistributionType&&(this.colorsDistributionType=Z.colorDistributionType),Z.colorsSampling&&(this.colorsSampling=Z.colorsSampling),Z.colorMode&&(this.colorMode=Z.colorMode),Z.useColors&&(this.useColors=Z.useColors),Z.visibility&&(this.visibility=Z.visibility),Z.useDash&&(this.useDash=Z.useDash),Z.dashCount&&(this.dashCount=Z.dashCount),Z.dashRatio&&(this.dashRatio=Z.dashRatio),Z.dashOffset&&(this.dashOffset=Z.dashOffset),Z.width&&(this.width=Z.width),Z.sizeAttenuation&&(this.sizeAttenuation=Z.sizeAttenuation),Z.resolution&&(this.resolution=Z.resolution),Z.WE?this.colorsTexture=YE.CreateColorsTexture(`${this.name}-colors-texture`,Z.WE,this.colorsSampling,this.fE()):this.colorsTexture=YE.PrepareEmptyColorsTexture(H),this._cameraFacing=Z.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var GE,xE,qE;OE.ForceGLSL=!1,function(E){E[E.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",E[E.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(GE||(GE={})),function(E){E[E.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",E[E.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",E[E.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(xE||(xE={})),function(E){E[E.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",E[E.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",E[E.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",E[E.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",E[E.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(qE||(qE={}));class bE extends DE.e{constructor(E,H,d){super(E,H,null,null,!1,!1),this.name=E,this._options=d,this._lazy=!1,this._updatable=!1,this._engine=H.getEngine(),this._lazy=d.lazy??!1,this._updatable=d.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=d.colorPointers??[],this._widths=d.widths??new Array(d.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(E){let H=0;for(const n of this._points)H+=n.length;const d=H/3*2-this._widths.length;for(let n=0;n<d;n++)this._widths.push(E)}updateLazy(){var E,H;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(E=this._options.ribbonOptions)||void 0===E?void 0:E.smoothShading),!this.uE&&this.refreshBoundingInfo(),null===(H=this.greasedLineMaterial)||void 0===H||H.updateLazy()}addPoints(E,H){for(const d of E)this._points.push(d);this._lazy||this.setPoints(this._points,H)}dispose(E){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(E,H)}isLazy(){return this._lazy}get UE(){return this._uvs}set UE(E){this._uvs=E instanceof Float32Array?E:new Float32Array(E),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(E){this.material instanceof OE&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===E||void 0===E?void 0:E.length)>0),this._offsets=E,this._offsetsBuffer?this._offsetsBuffer.update(E):this._createOffsetsBuffer(E)}get widths(){return this._widths}set widths(E){this._widths=E,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(E)}get colorPointers(){return this._colorPointers}set colorPointers(E){this._colorPointers=E,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(E)}get greasedLineMaterial(){var E,H;if(this.material&&this.material instanceof OE)return this.material;const d=null===(E=this.material)||void 0===E||null===(H=E.pluginManager)||void 0===H?void 0:H.getPlugin(uE.GREASED_LINE_MATERIAL_NAME);return d||void 0}get points(){const E=[];return FE.b.DeepCopy(this._points,E),E}setPoints(E,H){this._points=YE.ConvertPoints(E,(null===H||void 0===H?void 0:H.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==H&&void 0!==H&&H.colorPointers||this._updateColorPointers(),this._setPoints(this._points,H)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,UE:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(E){super.serialize(E),E.type=this.getClassName(),E.lineOptions=this._createLineOptions()}_createVertexBuffers(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=new oE.c;return H.jE=this._vertexPositions,H.indices=this._indices,H.UE=this._uvs,E&&(H.XE=[],oE.c.ComputeNormals(this._vertexPositions,this._indices,H.XE)),H.cE(this,this._options.updatable),H}_createOffsetsBuffer(E){const H=this._scene.getEngine(),d=new S.e(H,E,this._updatable,3);this.setVerticesBuffer(d.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=d}}class hE{constructor(E,H){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=E,this.wasAddedByNoopNode=H}getIndicesAccessor(E,H,d,n,Z){var I,g,l,r;return null===(I=this._indicesAccessorMap.get(E))||void 0===I||null===(g=I.get(H))||void 0===g||null===(l=g.get(d))||void 0===l||null===(r=l.get(n))||void 0===r?void 0:r.get(Z)}setIndicesAccessor(E,H,d,n,Z,I){let g=this._indicesAccessorMap.get(E);g||(g=new Map,this._indicesAccessorMap.set(E,g));let l=g.get(H);l||(l=new Map,g.set(H,l));let r=l.get(d);r||(r=new Map,l.set(d,r));let t=r.get(n);t||(t=new Map,r.set(n,t)),t.set(Z,I)}pushExportedNode(E){this._exportedNodes.has(E)||this._exportedNodes.add(E)}getNodesSet(){return this._exportedNodes}getVertexBufferView(E){return this._vertexBufferViewMap.get(E)}setVertexBufferView(E,H){this._vertexBufferViewMap.set(E,H)}setRemappedBufferView(E,H,d){this._remappedBufferView.set(E,new Map),this._remappedBufferView.get(E).set(H,d)}getRemappedBufferView(E,H){var d;return null===(d=this._remappedBufferView.get(E))||void 0===d?void 0:d.get(H)}getVertexAccessor(E,H,d){var n,Z;return null===(n=this._vertexAccessorMap.get(E))||void 0===n||null===(Z=n.get(H))||void 0===Z?void 0:Z.get(d)}setVertexAccessor(E,H,d,n){let Z=this._vertexAccessorMap.get(E);Z||(Z=new Map,this._vertexAccessorMap.set(E,Z));let I=Z.get(H);I||(I=new Map,Z.set(H,I)),I.set(d,n)}hasVertexColorAlpha(E){return this._vertexMapColorAlpha.get(E)||!1}setHasVertexColorAlpha(E,H){return this._vertexMapColorAlpha.set(E,H)}getMesh(E){return this._meshMap.get(E)}setMesh(E,H){this._meshMap.set(E,H)}bindMorphDataToMesh(E,H){const d=this._meshMorphTargetMap.get(E)||[];this._meshMorphTargetMap.set(E,d),-1===d.indexOf(H)&&d.push(H)}getMorphTargetsFromMesh(E){return this._meshMorphTargetMap.get(E)}}class yE{_ApplyExtension(E,H,d,n){if(d>=H.length)return Promise.resolve(E);const Z=n(H[d],E);return Z?Z.then((async E=>E?await this._ApplyExtension(E,H,d+1,n):null)):this._ApplyExtension(E,H,d+1,n)}_ApplyExtensions(E,H){const d=[];for(const n of yE._ExtensionNames)d.push(this._extensions[n]);return this._ApplyExtension(E,d,0,H)}_extensionsPreExportTextureAsync(E,H,d){return this._ApplyExtensions(H,((H,n)=>H.preExportTextureAsync&&H.preExportTextureAsync(E,n,d)))}_extensionsPostExportNodeAsync(E,H,d,n,Z){return this._ApplyExtensions(H,((H,I)=>H.postExportNodeAsync&&H.postExportNodeAsync(E,I,d,n,Z,this._bufferManager)))}_extensionsPostExportMaterialAsync(E,H,d){return this._ApplyExtensions(H,((H,n)=>H.postExportMaterialAsync&&H.postExportMaterialAsync(E,n,d)))}_extensionsPostExportMaterialAdditionalTextures(E,H,d){const n=[];for(const Z of yE._ExtensionNames){const I=this._extensions[Z];I.postExportMaterialAdditionalTextures&&n.push(...I.postExportMaterialAdditionalTextures(E,H,d))}return n}_extensionsPostExportTextures(E,H,d){for(const n of yE._ExtensionNames){const Z=this._extensions[n];Z.postExportTexture&&Z.postExportTexture(E,H,d)}}_extensionsPostExportMeshPrimitive(E){for(const H of yE._ExtensionNames){const d=this._extensions[H];d.postExportMeshPrimitive&&d.postExportMeshPrimitive(E,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const E of yE._ExtensionNames){const H=this._extensions[E];H.preGenerateBinaryAsync&&await H.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(E){for(const H of yE._ExtensionNames){const d=this._extensions[H];d.enabled&&E(d)}}_extensionsOnExporting(){this._forEachExtensions((E=>{var H,d,n;E.wasUsed&&((H=this._glTF).extensionsUsed||(H.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(E.name)&&this._glTF.extensionsUsed.push(E.name),E.required&&((d=this._glTF).extensionsRequired||(d.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(E.name)&&this._glTF.extensionsRequired.push(E.name)),(n=this._glTF).extensions||(n.extensions={}),E.onExporting&&E.onExporting())}))}_loadExtensions(){for(const E of yE._ExtensionNames){const H=yE._ExtensionFactories[E](this);this._extensions[E]=H}}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:R.b.LastCreatedScene,H=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${w.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new k(this),this._extensions={},this._bufferManager=new SE,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!E)throw new Error("No scene available to export");this._babylonScene=E,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:E=>{var H;return null===E||void 0===E||null===(H=E.jd)||void 0===H?void 0:H.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...H},this._loadExtensions()}dispose(){for(const E in this._extensions){this._extensions[E].dispose()}}get options(){return this._options}static RegisterExtension(E,H){yE.UnregisterExtension(E)&&Z.Tools.Warn(`Extension with the name ${E} already exists`),yE._ExtensionFactories[E]=H,yE._ExtensionNames.push(E)}static UnregisterExtension(E){if(!yE._ExtensionFactories[E])return!1;delete yE._ExtensionFactories[E];const H=yE._ExtensionNames.indexOf(E);return-1!==H&&yE._ExtensionNames.splice(H,1),!0}_generateJSON(E,H,d){const n={byteLength:E};return n.byteLength&&(this._glTF.buffers=[n]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.QH=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(n.uri=H+".bin"),d?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(E){const H=await this._generateBinaryAsync();this._extensionsOnExporting();const d=this._generateJSON(H.byteLength,E,!0),n=new Blob([H],{type:"application/octet-stream"}),Z=E+".gltf",I=E+".bin",g=new t;if(g.files[Z]=d,g.files[I]=n,this._imageData)for(const l in this._imageData)g.files[l]=new Blob([this._imageData[l].data],{type:this._imageData[l].mimeType});return g}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(E){const H=E%4;return 0===H?H:4-H}async generateGLBAsync(E){this._shouldUseGlb=!0;const H=await this._generateBinaryAsync();this._extensionsOnExporting();const d=this._generateJSON(H.byteLength),n=E+".glb";let Z,I=d.length;if("undefined"!==typeof TextEncoder){Z=(new TextEncoder).encode(d),I=Z.length}const g=this._getPadding(I),l=this._getPadding(H.byteLength),r=28+I+g+H.byteLength+l,S=new rE(r);if(S.writeUInt32(1179937895),S.writeUInt32(2),S.writeUInt32(r),S.writeUInt32(I+g),S.writeUInt32(1313821514),Z)S.writeTypedArray(Z);else{const E="_".charCodeAt(0);for(let H=0;H<I;++H){const n=d.charCodeAt(H);n!=d.codePointAt(H)?S.writeUInt8(E):S.writeUInt8(n)}}for(let t=0;t<g;++t)S.writeUInt8(32);S.writeUInt32(H.byteLength+l),S.writeUInt32(5130562),S.writeTypedArray(H);for(let t=0;t<l;++t)S.writeUInt8(0);const M=new t;return M.files[n]=new Blob([S.getOutputData()],{type:"application/octet-stream"}),M}_setNodeTransformation(E,H,d){if(H.getPivotPoint().equalsWithEpsilon(b,q.c)||Z.Tools.Warn("Pivot points are not supported in the glTF serializer"),!H.position.equalsWithEpsilon(b,q.c)){const Z=n.TmpVectors.wH[0].l(H.position);d&&A(Z),E.translation=Z.kd()}H.mg.equalsWithEpsilon(y,q.c)||(E.scale=H.mg.kd());const I=H.rotationQuaternion||n.Quaternion.FromEulerAngles(H.rotation.x,H.rotation.y,H.rotation.z);I.equalsWithEpsilon(h,q.c)||(d&&B(I),E.rotation=I.normalize().kd())}_setCameraTransformation(E,H,d){if(!H.position.equalsWithEpsilon(b,q.c)){const Z=n.TmpVectors.wH[0].l(H.position);d&&A(Z),E.translation=Z.kd()}const Z=H.rotationQuaternion||n.Quaternion.FromEulerAngles(H.rotation.x,H.rotation.y,H.rotation.z);d&&B(Z),this._babylonScene.useRightHandedSystem||J(Z),Z.equalsWithEpsilon(h,q.c)||(E.rotation=Z.kd())}_listAvailableCameras(){for(const E of this._babylonScene.cameras){const H={type:E.mode===VE.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(E.name&&(H.name=E.name),"perspective"===H.type)H.perspective={aspectRatio:E.getEngine().getAspectRatio(E),yfov:E.fovMode===VE.b.FOVMODE_VERTICAL_FIXED?E.fov:E.fov*E.getEngine().getAspectRatio(E),znear:E.Gd,zfar:E.maxZ};else if("orthographic"===H.type){const d=E.orthoLeft&&E.orthoRight?.5*(E.orthoRight-E.orthoLeft):.5*E.getEngine().getRenderWidth(),n=E.orthoBottom&&E.orthoTop?.5*(E.orthoTop-E.orthoBottom):.5*E.getEngine().getRenderHeight();H.orthographic={xmag:d,ymag:n,znear:E.Gd,zfar:E.maxZ}}this._camerasMap.set(E,H)}}_exportAndAssignCameras(){const E=Array.from(this._camerasMap.values());for(const H of E){const E=this._nodesCameraMap.get(H);if(void 0!==E){this._cameras.push(H);for(const H of E)H.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const E of this._babylonScene.skeletons){if(E.bones.length<=0)continue;const H={joints:[]};this._skinMap.set(E,H)}}_exportAndAssignSkeletons(){for(const E of this._babylonScene.skeletons){if(E.bones.length<=0)continue;const H=this._skinMap.get(E);if(void 0==H)continue;const d={},n=[];let I=-1;for(let Z=0;Z<E.bones.length;++Z){const H=E.bones[Z],n=H.getIndex()??Z;-1!==n&&(d[n]=H,n>I&&(I=n))}for(let E=0;E<=I;++E){const I=d[E];n.push(I.getAbsoluteInverseBindMatrix());const g=I.getTransformNode();if(null!==g){const E=this._nodeMap.get(g);g&&null!==E&&void 0!==E?H.joints.push(E):Z.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else Z.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const g=this._nodesSkinMap.get(H);if(H.joints.length>0&&void 0!==g){const E=64*n.length,d=new Float32Array(E/4);n.forEach(((E,H)=>{d.set(E.m,16*H)}));const Z=this._bufferManager.createBufferView(d);this._accessors.push(this._bufferManager.createAccessor(Z,"MAT4",5126,n.length)),H.inverseBindMatrices=this._accessors.length-1,this._skins.push(H);for(const H of g)H.skin=this._skins.length-1}}}async _exportSceneAsync(){const E={nodes:[]};if(this._babylonScene.metadata){const H=this._options.metadataSelector(this._babylonScene.metadata);H&&(E.extras=H)}const H=new Array,d=new Array,n=new Array;for(const l of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&gE(l,this._babylonScene.useRightHandedSystem)?n.push(...l.getChildren()):this._babylonScene.useRightHandedSystem?H.push(l):d.push(l);this._listAvailableCameras(),this._listAvailableSkeletons();const Z=new hE(!0,!1);E.nodes.push(...await this._exportNodesAsync(d,Z));const I=new hE(!1,!1);E.nodes.push(...await this._exportNodesAsync(H,I));const g=new hE(!1,!0);E.nodes.push(...await this._exportNodesAsync(n,g)),E.nodes.length&&this._scenes.push(E),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&sE._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Z.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(E){let H=this._shouldExportNodeMap.get(E);return void 0===H&&(H=this._options.shouldExportNode(E),this._shouldExportNodeMap.set(E,H)),H}async _exportNodesAsync(E,H){const d=new Array;this._exportBuffers(E,H);for(const n of E)await this._exportNodeAsync(n,d,H);return d}_collectBuffers(E,H,d,n,Z){if(this._shouldExportNode(E)&&E instanceof V.b&&E.Kd){const I=E.Kd.getVertexBuffers();if(I)for(const n in I){if(!N(n))continue;const g=I[n];Z.setHasVertexColorAlpha(g,E.hasVertexAlpha);const l=g._buffer,r=H.get(l)||[];H.set(l,r),-1===r.indexOf(g)&&r.push(g);const t=d.get(g)||[];d.set(g,t),-1===t.indexOf(E)&&t.push(E)}const g=E.morphTargetManager;if(g)for(let H=0;H<g.numTargets;H++){const d=g.getTarget(H),Z=n.get(d)||[];n.set(d,Z),-1===Z.indexOf(E)&&Z.push(E)}}for(const I of E.getChildren())this._collectBuffers(I,H,d,n,Z)}_exportBuffers(E,H){const d=new Map,n=new Map,Z=new Map;for(const l of E)this._collectBuffers(l,d,n,Z,H);const I=Array.from(d.keys());for(const l of I){const E=l.getData();if(!E)throw new Error("Buffer data is not available");const Z=d.get(l);if(!Z)continue;const I=Z[0].byteStride;if(Z.some((E=>E.byteStride!==I)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const g=dE(E).slice();for(const H of Z){const E=n.get(H),{byteOffset:d,byteStride:Z,componentCount:I,type:l,count:r,normalized:t,kind:M}=z(H,E);switch(M){case S.g.NormalKind:case S.g.TangentKind:(0,O.j)(g,d,Z,I,l,r,t,(E=>{const H=Math.sqrt(E[0]*E[0]+E[1]*E[1]+E[2]*E[2]);if(H>0){const d=1/H;E[0]*=d,E[1]*=d,E[2]*=d}}));break;case S.g.ColorKind:{const H=E.filter((E=>E.material instanceof RE.LH||null==E.material)).length;if(0==H)break;if(H!=E.length){G.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}l==S.g.UNSIGNED_BYTE&&G.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const n=new Q.DH,M=new Q.gg,V=this._babylonScene.getEngine().useExactSrgbConversions;(0,O.j)(g,d,Z,I,l,r,t,(E=>{3===E.length?(n.Xd(E,0),n.toLinearSpaceToRef(n,V),n.toArray(E,0)):(M.Xd(E,0),M.toLinearSpaceToRef(M,V),M.toArray(E,0))}))}}}if(H.convertToRightHanded){for(const E of Z){const H=n.get(E),{byteOffset:d,byteStride:Z,componentCount:I,type:l,count:r,normalized:t,kind:M}=z(E,H);switch(M){case S.g.PositionKind:case S.g.NormalKind:case S.g.TangentKind:(0,O.j)(g,d,Z,I,l,r,t,(E=>{E[0]=-E[0]}))}}H.convertedToRightHandedBuffers.set(l,g)}const r=this._bufferManager.createBufferView(g,I);H.setVertexBufferView(l,r);const t=new Map;for(const H of Z){const E=n.get(H),{kind:d,totalVertices:Z}=z(H,E);switch(d){case S.g.MatricesIndicesKind:case S.g.MatricesIndicesExtraKind:if(H.type==S.g.FLOAT){const E=H.getFloatData(Z);null!==E&&t.set(H,E)}}}0!==t.size&&G.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const M=Array.from(t.keys());for(const d of M){const E=t.get(d);if(!E)continue;const n=E.some((E=>E>=256)),Z=new(n?Uint16Array:Uint8Array)(E.length);for(let H=0;H<E.length;H++)Z[H]=E[H];const I=this._bufferManager.createBufferView(Z,4*(n?2:1));H.setRemappedBufferView(l,d,I)}}const g=Array.from(Z.keys());for(const l of g){const E=Z.get(l);if(!E)continue;const d=iE(l,E[0],this._bufferManager,this._bufferViews,this._accessors,H.convertToRightHanded);for(const n of E)H.bindMorphDataToMesh(n,d)}}async _exportNodeAsync(E,H,d){let n=this._nodeMap.get(E);if(void 0!==n)return void(H.includes(n)||H.push(n));const Z=await this._createNodeAsync(E,d);if(Z){n=this._nodes.length,this._nodes.push(Z),this._nodeMap.set(E,n),d.pushExportedNode(E),H.push(n);const I={name:"runtime animations",channels:[],samplers:[]},g=[];this._babylonScene.animationGroups.length||(sE._CreateMorphTargetAnimationFromMorphTargetAnimations(E,I,g,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,d.convertToRightHanded,this._options.shouldExportAnimation),E.animations.length&&sE._CreateNodeAnimationFromNodeAnimations(E,I,g,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,d.convertToRightHanded,this._options.shouldExportAnimation)),I.channels.length&&I.samplers.length&&this._animations.push(I),g.forEach((E=>{E.channels.length&&E.samplers.length&&this._animations.push(E)}))}const I=Z?[]:H;for(const g of E.getChildren())await this._exportNodeAsync(g,I,d);Z&&I.length&&(Z.children=I)}async _createNodeAsync(E,H){if(!this._shouldExportNode(E))return null;const d={};if(E.name&&(d.name=E.name),E.metadata){const H=this._options.metadataSelector(E.metadata);H&&(d.extras=H)}if(E instanceof M.e&&(this._setNodeTransformation(d,E,H.convertToRightHanded),E instanceof V.b)){const Z=E instanceof C.c?E.sourceMesh:E;if(Z.od&&Z.od.length>0&&(d.mesh=await this._exportMeshAsync(Z,H)),E.skeleton){const H=this._skinMap.get(E.skeleton);var n;if(void 0!==H)void 0===this._nodesSkinMap.get(H)&&this._nodesSkinMap.set(H,[]),null===(n=this._nodesSkinMap.get(H))||void 0===n||n.push(d)}}if(E instanceof x.d){const n=this._camerasMap.get(E);if(n){var Z;void 0===this._nodesCameraMap.get(n)&&this._nodesCameraMap.set(n,[]),this._setCameraTransformation(d,E,H.convertToRightHanded);const g=E.parent;if(null!==g&&HE(E,g)){const E=this._nodeMap.get(g);if(void 0!==E){var I;const H=this._nodes[E];return EE(d,H),null===(I=this._nodesCameraMap.get(n))||void 0===I||I.push(H),null}}null===(Z=this._nodesCameraMap.get(n))||void 0===Z||Z.push(d)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",d,E,this._nodeMap,H.convertToRightHanded)?d:(G.b.Warn(`Not exporting node ${E.name}`),null)}_exportIndices(E,H,d,n,Z,g,l,r,t){let S=E;t.mode=mE(g);const M=l!==I.b.CounterClockWiseSideOrientation,V=!r.wasAddedByNoopNode&&M,C=function(E){switch(E){case I.b.TriangleFillMode:case I.b.TriangleStripDrawMode:case I.b.TriangleFanDrawMode:return!0}return!1}(g)&&V;if(C){if(g===I.b.TriangleStripDrawMode||g===I.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");t.mode=mE(g);const l=H?new Uint32Array(n):new Uint16Array(n);if(E)for(let H=0;H+2<n;H+=3)l[H]=E[d+H]+Z,l[H+1]=E[d+H+2]+Z,l[H+2]=E[d+H+1]+Z;else for(let E=0;E+2<n;E+=3)l[E]=E,l[E+1]=E+2,l[E+2]=E+1;S=l}else if(E&&0!==Z){const I=H?new Uint32Array(n):new Uint16Array(n);for(let H=0;H<n;H++)I[H]=E[d+H]+Z;S=I}if(S){let I=r.getIndicesAccessor(E,d,n,Z,C);if(void 0===I){const g=function(E,H,d,n){if(E instanceof Uint16Array||E instanceof Uint32Array)return E;if(E instanceof Int32Array)return new Uint32Array(E.buffer,E.byteOffset,E.length);const Z=E.slice(H,H+d);return n?new Uint32Array(Z):new Uint16Array(Z)}(S,0,n,H),l=this._bufferManager.createBufferView(g),t=H?5125:5123;this._accessors.push(this._bufferManager.createAccessor(l,"SCALAR",t,n,0)),I=this._accessors.length-1,r.setIndicesAccessor(E,d,n,Z,C,I)}t.indices=I}}_exportVertexBuffer(E,H,d,n,Z,I){const g=E.getKind();if(!N(g))return;if(g.startsWith("uv")&&!this._options.exportUnusedUVs&&(!H||!this._materialNeedsUVsSet.has(H)))return;let l=Z.getVertexAccessor(E,d,n);if(void 0===l){const H=Z.convertedToRightHandedBuffers.get(E._buffer)||E._buffer.getData(),I=g===S.g.PositionKind?function(E,H,d,n){const{byteOffset:Z,byteStride:I,type:g,normalized:l}=H,r=H.getSize(),t=new Array(r).fill(1/0),S=new Array(r).fill(-1/0);return(0,O.j)(E,Z+d*I,I,r,g,n*r,l,(E=>{for(let H=0;H<r;H++)t[H]=Math.min(t[H],E[H]),S[H]=Math.max(S[H],E[H])})),{min:t,max:S}}(H,E,d,n):void 0,r=(g===S.g.MatricesIndicesKind||g===S.g.MatricesIndicesExtraKind)&&E.type===S.g.FLOAT,t=r?S.g.UNSIGNED_BYTE:E.type,M=r?void 0:E.normalized,V=r?Z.getRemappedBufferView(E._buffer,E):Z.getVertexBufferView(E._buffer),C=E.byteOffset+d*E.byteStride;this._accessors.push(this._bufferManager.createAccessor(V,function(E,H){if(E==S.g.ColorKind)return H?"VEC4":"VEC3";switch(E){case S.g.PositionKind:case S.g.NormalKind:return"VEC3";case S.g.TangentKind:case S.g.MatricesIndicesKind:case S.g.MatricesIndicesExtraKind:case S.g.MatricesWeightsKind:case S.g.MatricesWeightsExtraKind:return"VEC4";case S.g.UVKind:case S.g.UV2Kind:case S.g.UV3Kind:case S.g.UV4Kind:case S.g.UV5Kind:case S.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${E}`)}(g,Z.hasVertexColorAlpha(E)),t,n,C,I,M)),l=this._accessors.length-1,Z.setVertexAccessor(E,d,n,l)}I.attributes[function(E){switch(E){case S.g.PositionKind:return"POSITION";case S.g.NormalKind:return"NORMAL";case S.g.TangentKind:return"TANGENT";case S.g.ColorKind:return"COLOR_0";case S.g.UVKind:return"TEXCOORD_0";case S.g.UV2Kind:return"TEXCOORD_1";case S.g.UV3Kind:return"TEXCOORD_2";case S.g.UV4Kind:return"TEXCOORD_3";case S.g.UV5Kind:return"TEXCOORD_4";case S.g.UV6Kind:return"TEXCOORD_5";case S.g.MatricesIndicesKind:return"JOINTS_0";case S.g.MatricesIndicesExtraKind:return"JOINTS_1";case S.g.MatricesWeightsKind:return"WEIGHTS_0";case S.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${E}`)}(g)]=l}async _exportMaterialAsync(E,H,d,n){let Z=this._materialMap.get(E);if(void 0===Z){const n=H&&Object.keys(H).some((E=>E.startsWith("uv")));if((E=E instanceof CE.c?E.wg[d.materialIndex]:E)instanceof wE.c)Z=await this._materialExporter.exportPBRMaterialAsync(E,"image/png",n);else{if(!(E instanceof RE.LH))return void G.b.Warn(`Unsupported material '${E.name}' with type ${E.getClassName()}`);Z=await this._materialExporter.exportStandardMaterialAsync(E,"image/png",n)}this._materialMap.set(E,Z)}n.material=Z}async _exportMeshAsync(E,H){var d;let n=H.getMesh(E);if(void 0!==n)return n;const Z={primitives:[]};n=this._meshes.length,this._meshes.push(Z),H.setMesh(E,n);const g=E.isUnIndexed?null:E.Nd(),l=null===(d=E.Kd)||void 0===d?void 0:d.getVertexBuffers(),r=H.getMorphTargetsFromMesh(E),t=E instanceof pE.c,S=E instanceof bE,M=E.od;if(l&&M&&M.length>0)for(const w of M){const d={attributes:{}},n=w.kE()||this._babylonScene.defaultMaterial;if(S){var V,C;const H={name:n.name},Z=E,I=Q.DH.White(),g=(null===(V=Z.material)||void 0===V?void 0:V.alpha)??1,l=(null===(C=Z.greasedLineMaterial)||void 0===C?void 0:C.color)??I;(!l.equalsWithEpsilon(I,q.c)||g<1)&&(H.pbrMetallicRoughness={baseColorFactor:[...l.kd(),g]}),this._materials.push(H),d.material=this._materials.length-1}else if(t){const H={name:n.name},Z=E;(!Z.color.equalsWithEpsilon(Q.DH.White(),q.c)||Z.alpha<1)&&(H.pbrMetallicRoughness={baseColorFactor:[...Z.color.kd(),Z.alpha]}),this._materials.push(H),d.material=this._materials.length-1}else await this._exportMaterialAsync(n,l,w,d);const M=t||S?I.b.LineListDrawMode:E.overrideRenderingFillMode??n.fillMode,R=n._getEffectiveOrientation(E);this._exportIndices(g,g?(0,O.e)(g,w.indexCount,w.indexStart,w.verticesStart):w.verticesCount>65535,g?w.indexStart:w.verticesStart,g?w.indexCount:w.verticesCount,-w.verticesStart,M,R,H,d);for(const E of Object.values(l))this._exportVertexBuffer(E,n,w.verticesStart,w.verticesCount,H,d);if(r){d.targets=[];for(const E of r)d.targets.push(E.attributes)}Z.primitives.push(d),this._extensionsPostExportMeshPrimitive(d)}if(r){Z.weights=[],Z.extras||(Z.extras={}),Z.extras.targetNames=[];for(const E of r)Z.weights.push(E.influence),Z.extras.targetNames.push(E.name)}return n}}yE._ExtensionNames=new Array,yE._ExtensionFactories={};class vE{static async GLTFAsync(E,H,d){d&&d.exportWithoutWaitingForScene||await E.whenReadyAsync();const n=new yE(E,d),Z=await n.generateGLTFAsync(H.replace(/\.[^/.]+$/,""));return n.dispose(),Z}static async GLBAsync(E,H,d){d&&d.exportWithoutWaitingForScene||await E.whenReadyAsync();const n=new yE(E,d),Z=await n.generateGLBAsync(H.replace(/\.[^/.]+$/,""));return n.dispose(),Z}}d(12944);const zE="EXT_mesh_gpu_instancing";class KE{constructor(E){this.name=zE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(E,H,d,Z,I,g){return await new Promise((E=>{if(H&&d instanceof DE.e&&d.hasThinInstances&&this._exporter){this._wasUsed=!0;const E=n.wH.Zero(),Z=n.Quaternion.Identity(),l=n.wH.One(),r=d.thinInstanceGetWorldMatrices(),t=n.TmpVectors.wH[2],S=n.TmpVectors.Quaternion[1],M=n.TmpVectors.wH[3];let V=!1,C=!1,w=!1;const R=new Float32Array(3*d.Rg),Q=new Float32Array(4*d.Rg),L=new Float32Array(3*d.Rg);let D=0;for(const H of r)H.decompose(M,S,t),I&&(A(t),B(S)),R.set(t.kd(),3*D),Q.set(S.normalize().kd(),4*D),L.set(M.kd(),3*D),V=V||!t.equalsWithEpsilon(E),C=C||!S.equalsWithEpsilon(Z),w=w||!M.equalsWithEpsilon(l),D++;const e={attributes:{}};V&&(e.attributes.TRANSLATION=this._buildAccessor(R,"VEC3",d.Rg,g)),C&&(e.attributes.ROTATION=this._buildAccessor(Q,"VEC4",d.Rg,g)),w&&(e.attributes.SCALE=this._buildAccessor(L,"VEC3",d.Rg,g)),H.extensions=H.extensions||{},H.extensions[zE]=e}E(H)}))}_buildAccessor(E,H,d,n){const Z=n.createBufferView(E),I=n.createAccessor(Z,H,5126,d);return this._exporter._accessors.push(I),this._exporter._accessors.length-1}}yE.RegisterExtension(zE,(E=>new KE(E)));var NE=d(12949),mH=d(12964),TE=d(12968),AE=d(12974);function BE(E){return E===TE.c.PositionKind?"POSITION":E===TE.c.NormalKind?"NORMAL":E===TE.c.ColorKind?"COLOR":E.startsWith(TE.c.UVKind)?"TEX_COORD":"GENERIC"}const JE={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class EH extends NE.e{static get DefaultAvailable(){return(0,NE.i)(EH.DefaultConfiguration)}static get Default(){return EH._Default??(EH._Default=new EH),EH._Default}static ResetDefault(E){EH._Default&&(E||EH._Default.dispose(),EH._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(E,H){return{module:await(H||DracoEncoderModule)({wasmBinary:E})}}_getWorkerContent(){return`${mH.k}(${mH.o})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:EH.DefaultConfiguration)}async _encodeAsync(E,H,d){const n=d?(0,AE.d)(JE,d):JE;if(this._workerPoolPromise){const d=await this._workerPoolPromise;return await new Promise(((Z,I)=>{d.push(((d,g)=>{const l=E=>{d.removeEventListener("error",l),d.removeEventListener("message",r),I(E),g()},r=E=>{"encodeMeshDone"===E.data.id&&(d.removeEventListener("error",l),d.removeEventListener("message",r),Z(E.data.encodedMeshData),g())};d.addEventListener("error",l),d.addEventListener("message",r);const t=[];for(const H of E)t.push(H.data.buffer);H&&t.push(H.buffer),d.postMessage({id:"encodeMesh",attributes:E,indices:H,options:n},t)}))}))}if(this._modulePromise){const d=await this._modulePromise;return(0,mH.k)(d.module,E,H,n)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(E,H){if(0==E.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");E instanceof DE.e&&E.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===H||void 0===H?void 0:H.method)&&(G.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),H.method="MESH_SEQUENTIAL_ENCODING");const d=function(E){let H=E.Nd(void 0,!0);return!H||H instanceof Uint32Array||H instanceof Uint16Array||(H=((0,O.e)(H,H.length)?Uint32Array:Uint16Array).from(H)),H}(E),n=function(E,H){const d=[];for(const n of E.getVerticesDataKinds()){if(null!==H&&void 0!==H&&H.includes(n)){if(n===TE.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const Z=E.getVertexBuffer(n),I=Z.getSize(),g=(0,O.v)(Z.getData(),I,Z.type,Z.byteOffset,Z.byteStride,Z.normalized,E.getTotalVertices(),!0);d.push({kind:n,dracoName:BE(n),size:I,data:g})}return d}(E,null===H||void 0===H?void 0:H.excludedAttributes);return await this._encodeAsync(n,d,H)}}EH.DefaultConfiguration={wasmUrl:`${Z.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${Z.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${Z.Tools._DefaultCdnUrl}/draco_encoder.js`},EH._Default=null;const HH="KHR_draco_mesh_compression";class dH{get wasUsed(){return this._wasUsed}constructor(E){this.name=HH,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===E.options.meshCompressionMethod&&EH.DefaultAvailable}dispose(){}postExportMeshPrimitive(E,H,d){if(!this.enabled)return;if(4!==E.mode&&5!==E.mode)return void G.b.Warn("Cannot compress primitive with mode "+E.mode+".");const n=[],Z=[];let I=null;if(void 0!==E.indices){const g=d[E.indices],l=H.getBufferView(g);I=H.getData(l).slice(),n.push(l),Z.push(g)}const g=[];for(const[S,M]of Object.entries(E.attributes)){const E=d[M],I=H.getBufferView(E),r=K(E.type),t=(0,O.v)(H.getData(I),r,E.componentType,E.byteOffset||0,I.byteStride||(0,O.o)(E.componentType)*r,E.normalized||!1,E.count,!0);g.push({kind:S,dracoName:(l=S,"POSITION"===l?"POSITION":"NORMAL"===l?"NORMAL":l.startsWith("COLOR")?"COLOR":l.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:K(E.type),data:t}),n.push(I),Z.push(E)}var l;const r={method:E.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},t=EH.Default._encodeAsync(g,I,r).then((d=>{if(!d)return void G.b.Error("Draco encoding failed for primitive.");const I={bufferView:-1,attributes:d.attributeIds},g=H.createBufferView(d.data);H.setBufferView(I,g);for(const E of n)this._bufferViewsUsed.add(E);for(const E of Z)this._accessorsUsed.add(E);E.extensions||(E.extensions={}),E.extensions[HH]=I})).catch((E=>{G.b.Error("Draco encoding failed for primitive: "+E)}));this._encodePromises.push(t),this._wasUsed=!0}async preGenerateBinaryAsync(E){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((H=>{E.getPropertiesWithBufferView(H).every((E=>this._accessorsUsed.has(E)))&&E.removeBufferView(H)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}yE.RegisterExtension(HH,(E=>new dH(E)));var nH=d(12976);const ZH="KHR_lights_punctual",IH={name:"",color:[1,1,1],Lg:1,range:Number.MAX_VALUE},gH={innerConeAngle:0,outerConeAngle:Math.PI/4},lH=n.wH.Backward();class rH{constructor(E){this.name=ZH,this.enabled=!0,this.required=!1,this._exporter=E}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[ZH]=this._lights}async postExportNodeAsync(E,H,d,Z,I){return await new Promise((g=>{if(!(d instanceof eE.e))return void g(H);const l=d.getTypeID()==eE.e.LIGHTTYPEID_POINTLIGHT?"point":d.getTypeID()==eE.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":d.getTypeID()==eE.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!l||!(d instanceof nH.e))return G.b.Warn(`${E}: Light ${d.name} is not supported in ${ZH}`),void g(H);if(d.falloffType!==eE.e.FALLOFF_GLTF&&G.b.Warn(`${E}: Light falloff for ${d.name} does not match the ${ZH} specification!`),!d.position.equalsToFloats(0,0,0)){const E=n.TmpVectors.wH[0].l(d.position);I&&A(E),H.translation=E.kd()}if("point"!==l){const E=d.direction.normalizeToRef(n.TmpVectors.wH[0]);I&&A(E);const Z=n.Quaternion.FromUnitVectorsToRef(lH,E,n.TmpVectors.Quaternion[0]);n.Quaternion.IsIdentity(Z)||(H.rotation=Z.kd())}const r={type:l,name:d.name,color:d.eg.kd(),Lg:d.Lg,range:d.range};if(nE(r,IH),"spot"===l){const E=d;r.spot={innerConeAngle:E.innerAngle/2,outerConeAngle:E.angle/2},nE(r.spot,gH)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(r);const t={rd:this._lights.lights.length-1},S=d.parent;if(S&&HE(d,S)){const E=Z.get(S);if(E){const d=this._exporter._nodes[E];return EE(H,d),d.extensions||(d.extensions={}),d.extensions[ZH]=t,void g(null)}}H.extensions||(H.extensions={}),H.extensions[ZH]=t,g(H)}))}}yE.RegisterExtension(ZH,(E=>new rH(E)));var tH=d(12890);const SH="KHR_materials_anisotropy";class MH{constructor(E){this.name=SH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,H,d){const n=[];return d instanceof tH.c&&d.anisotropy.isEnabled&&!d.anisotropy.legacy?(d.anisotropy.texture&&n.push(d.anisotropy.texture),n):[]}postExportMaterialAsync(E,H,d){return new Promise((E=>{if(d instanceof tH.c){if(!d.anisotropy.isEnabled||d.anisotropy.legacy)return void E(H);this._wasUsed=!0,H.extensions=H.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(d.anisotropy.texture),Z={anisotropyStrength:d.anisotropy.Lg,anisotropyRotation:d.anisotropy.angle,anisotropyTexture:n??void 0};null!==Z.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(d),H.extensions[SH]=Z}E(H)}))}}yE.RegisterExtension(SH,(E=>new MH(E)));const VH="KHR_materials_clearcoat";class CH{constructor(E){this.name=VH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,H,d){const n=[];return d instanceof tH.c&&d.clearCoat.isEnabled?(d.clearCoat.texture&&n.push(d.clearCoat.texture),!d.clearCoat.useRoughnessFromMainTexture&&d.clearCoat.textureRoughness&&n.push(d.clearCoat.textureRoughness),d.clearCoat.bumpTexture&&n.push(d.clearCoat.bumpTexture),n):[]}postExportMaterialAsync(E,H,d){return new Promise((E=>{if(d instanceof tH.c){if(!d.clearCoat.isEnabled)return void E(H);this._wasUsed=!0,H.extensions=H.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(d.clearCoat.texture);let I;I=d.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(d.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(d.clearCoat.textureRoughness),d.clearCoat.isTintEnabled&&Z.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${d.name}`),d.clearCoat.remapF0OnInterfaceChange&&Z.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${d.name}`);const g=this._exporter._materialExporter.getTextureInfo(d.clearCoat.bumpTexture),l={clearcoatFactor:d.clearCoat.Lg,clearcoatTexture:n??void 0,clearcoatRoughnessFactor:d.clearCoat.roughness,clearcoatRoughnessTexture:I??void 0,clearcoatNormalTexture:g??void 0};null===l.clearcoatTexture&&null===l.clearcoatRoughnessTexture&&null===l.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(d),H.extensions[VH]=l}E(H)}))}}yE.RegisterExtension(VH,(E=>new CH(E)));const wH="KHR_materials_diffuse_transmission";function RH(E,H){const d=H.subSurface;let n=null;return d.translucencyIntensityTexture?n=d.translucencyIntensityTexture:d.thicknessTexture&&d.useMaskFromThicknessTexture&&(n=d.thicknessTexture),n&&!d.useGltfStyleTextures?(G.b.Warn(`${E}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${H.name}`,1),null):n}class QH{constructor(E){this.name=wH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,H,d){const n=[];if(d instanceof wE.c&&this._isExtensionEnabled(d)){const H=RH(E,d);return H&&n.push(H),d.subSurface.translucencyColorTexture&&n.push(d.subSurface.translucencyColorTexture),n}return n}_isExtensionEnabled(E){if(E.unlit)return!1;const H=E.subSurface;return!!H.isTranslucencyEnabled&&(!E.unlit&&!H.useAlbedoToTintTranslucency&&H.useGltfStyleTextures&&1===H.volumeIndexOfRefraction&&0===H.minimumThickness&&0===H.maximumThickness)}postExportMaterialAsync(E,H,d){return new Promise((n=>{if(d instanceof wE.c&&this._isExtensionEnabled(d)){this._wasUsed=!0;const n=d.subSurface,Z=RH(E,d),I=0==n.translucencyIntensity?void 0:n.translucencyIntensity,g=this._exporter._materialExporter.getTextureInfo(Z)??void 0,l=!n.translucencyColor||n.translucencyColor.equalsFloats(1,1,1)?void 0:n.translucencyColor.kd(),r=this._exporter._materialExporter.getTextureInfo(n.translucencyColorTexture)??void 0,t={diffuseTransmissionFactor:I,diffuseTransmissionTexture:g,diffuseTransmissionColorFactor:l,diffuseTransmissionColorTexture:r};(g||r)&&this._exporter._materialNeedsUVsSet.add(d),H.extensions=H.extensions||{},H.extensions[wH]=t}n(H)}))}}yE.RegisterExtension(wH,(E=>new QH(E)));const LH="KHR_materials_dispersion";class DH{constructor(){this.name=LH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(E){if(E.unlit)return!1;const H=E.subSurface;return!(!H.isRefractionEnabled&&!H.isDispersionEnabled)}postExportMaterialAsync(E,H,d){return new Promise((E=>{if(d instanceof wE.c&&this._isExtensionEnabled(d)){this._wasUsed=!0;const E={dispersion:d.subSurface.dispersion};H.extensions=H.extensions||{},H.extensions[LH]=E}E(H)}))}}yE.RegisterExtension(LH,(()=>new DH));const eH="KHR_materials_emissive_strength";class sH{constructor(){this.name=eH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(E,H,d){return await new Promise((E=>{if(!(d instanceof wE.c))return E(H);const n=d.emissiveColor.kd(),Z=Math.max(...n);if(Z>1){this._wasUsed=!0,H.extensions||(H.extensions={});const E={emissiveStrength:Z},n=d.emissiveColor.scale(1/E.emissiveStrength);H.emissiveFactor=n.kd(),H.extensions[eH]=E}return E(H)}))}}yE.RegisterExtension(eH,(E=>new sH));const iH="KHR_materials_ior";class pH{constructor(){this.name=iH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(E){return!E.unlit&&(void 0!=E.indexOfRefraction&&1.5!=E.indexOfRefraction)}postExportMaterialAsync(E,H,d){return new Promise((E=>{if(d instanceof wE.c&&this._isExtensionEnabled(d)){this._wasUsed=!0;const E={ior:d.indexOfRefraction};H.extensions=H.extensions||{},H.extensions[iH]=E}E(H)}))}}yE.RegisterExtension(iH,(E=>new pH));const fH="KHR_materials_iridescence";class PH{constructor(E){this.name=fH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,H,d){const n=[];return d instanceof tH.c&&d.iridescence.isEnabled?(d.iridescence.texture&&n.push(d.iridescence.texture),d.iridescence.thicknessTexture&&d.iridescence.thicknessTexture!==d.iridescence.texture&&n.push(d.iridescence.thicknessTexture),n):[]}postExportMaterialAsync(E,H,d){return new Promise((E=>{if(d instanceof tH.c){if(!d.iridescence.isEnabled)return void E(H);this._wasUsed=!0,H.extensions=H.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(d.iridescence.texture),Z=this._exporter._materialExporter.getTextureInfo(d.iridescence.thicknessTexture),I={iridescenceFactor:d.iridescence.Lg,iridescenceIor:d.iridescence.indexOfRefraction,iridescenceThicknessMinimum:d.iridescence.minimumThickness,iridescenceThicknessMaximum:d.iridescence.maximumThickness,iridescenceTexture:n??void 0,iridescenceThicknessTexture:Z??void 0};null===I.iridescenceTexture&&null===I.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(d),H.extensions[fH]=I}E(H)}))}}yE.RegisterExtension(fH,(E=>new PH(E)));const jH="KHR_materials_sheen";class XH{constructor(E){this.name=jH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,H,d){return d instanceof wE.c&&d.sheen.isEnabled&&d.sheen.texture?[d.sheen.texture]:[]}async postExportMaterialAsync(E,H,d){return await new Promise((E=>{if(d instanceof wE.c){if(!d.sheen.isEnabled)return void E(H);this._wasUsed=!0,null==H.extensions&&(H.extensions={});const n={sheenColorFactor:d.sheen.color.kd(),sheenRoughnessFactor:d.sheen.roughness??0};null===n.sheenColorTexture&&null===n.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(d),d.sheen.texture&&(n.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(d.sheen.texture)??void 0),d.sheen.textureRoughness&&!d.sheen.useRoughnessFromMainTexture?n.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(d.sheen.textureRoughness)??void 0:d.sheen.texture&&d.sheen.useRoughnessFromMainTexture&&(n.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(d.sheen.texture)??void 0),H.extensions[jH]=n}E(H)}))}}yE.RegisterExtension(jH,(E=>new XH(E)));const WH="KHR_materials_specular";class UH{constructor(E){this.name=WH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,H,d){const n=[];return d instanceof wE.c&&this._isExtensionEnabled(d)?(d.metallicReflectanceTexture&&n.push(d.metallicReflectanceTexture),d.reflectanceTexture&&n.push(d.reflectanceTexture),n):n}_isExtensionEnabled(E){return!E.unlit&&(void 0!=E.metallicF0Factor&&1!=E.metallicF0Factor||void 0!=E.metallicReflectanceColor&&!E.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(E))}_hasTexturesExtension(E){return null!=E.metallicReflectanceTexture||null!=E.reflectanceTexture}postExportMaterialAsync(E,H,d){return new Promise((E=>{if(d instanceof wE.c&&this._isExtensionEnabled(d)){this._wasUsed=!0,H.extensions=H.extensions||{};const E=this._exporter._materialExporter.getTextureInfo(d.metallicReflectanceTexture)??void 0,n=this._exporter._materialExporter.getTextureInfo(d.reflectanceTexture)??void 0,Z={specularFactor:1==d.metallicF0Factor?void 0:d.metallicF0Factor,specularTexture:E,specularColorFactor:d.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:d.metallicReflectanceColor.kd(),specularColorTexture:n};this._hasTexturesExtension(d)&&this._exporter._materialNeedsUVsSet.add(d),H.extensions[WH]=Z}E(H)}))}}yE.RegisterExtension(WH,(E=>new UH(E)));const YH="KHR_materials_transmission";class cH{constructor(E){this.name=YH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,H,d){const n=[];return d instanceof wE.c&&this._isExtensionEnabled(d)?(d.subSurface.thicknessTexture&&n.push(d.subSurface.thicknessTexture),n):n}_isExtensionEnabled(E){if(E.unlit)return!1;const H=E.subSurface;return H.isRefractionEnabled&&void 0!=H.refractionIntensity&&0!=H.refractionIntensity||this._hasTexturesExtension(E)}_hasTexturesExtension(E){return null!=E.subSurface.refractionIntensityTexture}async postExportMaterialAsync(E,H,d){if(d instanceof wE.c&&this._isExtensionEnabled(d)){this._wasUsed=!0;const n=d.subSurface,Z={transmissionFactor:0===n.refractionIntensity?void 0:n.refractionIntensity};if(this._hasTexturesExtension(d)&&this._exporter._materialNeedsUVsSet.add(d),n.refractionIntensityTexture)if(n.useGltfStyleTextures){const E=await this._exporter._materialExporter.exportTextureAsync(n.refractionIntensityTexture,"image/png");E&&(Z.transmissionTexture=E)}else G.b.Warn(`${E}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);H.extensions||(H.extensions={}),H.extensions[YH]=Z}return H}}yE.RegisterExtension(YH,(E=>new cH(E)));const uH="KHR_materials_unlit";class oH{constructor(){this.name=uH,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(E,H,d){return new Promise((E=>{let n=!1;d instanceof wE.c?n=d.unlit:d instanceof RE.LH&&(n=d.disableLighting),n&&(this._wasUsed=!0,null==H.extensions&&(H.extensions={}),H.extensions[uH]={}),E(H)}))}}yE.RegisterExtension(uH,(()=>new oH));const FH="KHR_materials_volume";class aH{constructor(E){this.name=FH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,H,d){const n=[];return d instanceof wE.c&&this._isExtensionEnabled(d)?(d.subSurface.thicknessTexture&&n.push(d.subSurface.thicknessTexture),n):n}_isExtensionEnabled(E){if(E.unlit)return!1;const H=E.subSurface;return!(!H.isRefractionEnabled&&!H.isTranslucencyEnabled)&&(void 0!=H.maximumThickness&&0!=H.maximumThickness||void 0!=H.tintColorAtDistance&&H.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=H.tintColor&&H.tintColor!=Q.DH.White()||this._hasTexturesExtension(E))}_hasTexturesExtension(E){return null!=E.subSurface.thicknessTexture}postExportMaterialAsync(E,H,d){return new Promise((E=>{if(d instanceof wE.c&&this._isExtensionEnabled(d)){this._wasUsed=!0;const E=d.subSurface,n={thicknessFactor:0==E.maximumThickness?void 0:E.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(E.thicknessTexture)??void 0,attenuationDistance:E.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:E.tintColorAtDistance,attenuationColor:E.tintColor.equalsFloats(1,1,1)?void 0:E.tintColor.kd()};this._hasTexturesExtension(d)&&this._exporter._materialNeedsUVsSet.add(d),H.extensions=H.extensions||{},H.extensions[FH]=n}E(H)}))}}yE.RegisterExtension(FH,(E=>new aH(E)));const kH="EXT_materials_diffuse_roughness";class OH{constructor(E){this.name=kH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,H,d){const n=[];return d instanceof tH.c&&d._baseDiffuseRoughness?(d._baseDiffuseRoughnessTexture&&n.push(d._baseDiffuseRoughnessTexture),n):[]}postExportMaterialAsync(E,H,d){return new Promise((E=>{if(d instanceof tH.c){if(!d._baseDiffuseRoughness)return void E(H);this._wasUsed=!0,H.extensions=H.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(d._baseDiffuseRoughnessTexture),Z={diffuseRoughnessFactor:d._baseDiffuseRoughness,diffuseRoughnessTexture:n??void 0};null!==Z.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(d),H.extensions[kH]=Z}E(H)}))}}yE.RegisterExtension(kH,(E=>new OH(E)));const GH="KHR_texture_transform";class xH{constructor(){this.name=GH,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(E,H,d){if(d.fE()||Z.Tools.Warn(`${E}: /*@__KEY__*/"scene" is not defined for Babylon texture ${d.name}!`),(0!==d.uAng||0!==d.vAng)&&(Z.Tools.Warn(`${E}: Texture ${d.name} with rotation in the u or v axis is not supported in glTF.`),0!==d.uRotationCenter||0!==d.vRotationCenter))return;const n={};let I=!1;if(0===d.uOffset&&0===d.vOffset||(n.offset=[d.uOffset,d.vOffset],I=!0),1===d.uScale&&1===d.vScale||(n.scale=[d.uScale,d.vScale],I=!0),0!==d.wAng){if(0!==d.uRotationCenter||0!==d.vRotationCenter){if(d.homogeneousRotationInUVTransform&&d.uScale!==d.vScale)return void Z.Tools.Warn(`${E}: Texture ${d.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${GH}.`);Z.Tools.Warn(`${E}: Texture ${d.name} with non-origin rotation center will be exported using an adjusted offset with ${GH}.`),n.offset=function(E){const{uOffset:H,vOffset:d,uRotationCenter:n,vRotationCenter:Z,uScale:I,vScale:g,wAng:l}=E,r=Math.cos(l),t=Math.sin(l),S=n*I,M=Z*g;return[H+(S*(1-r)+M*t),d+(M*(1-r)-S*t)]}(d)}n.rotation=-d.wAng,I=!0}0!==d.coordinatesIndex&&(n.texCoord=d.coordinatesIndex,I=!0),I&&(this._wasUsed=!0,H.extensions||(H.extensions={}),H.extensions[GH]=n)}}yE.RegisterExtension(GH,(()=>new xH));class qH{static CreateSTL(E){let H=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",Z=arguments.length>3&&void 0!==arguments[3]&&arguments[3],I=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],g=arguments.length>5&&void 0!==arguments[5]&&arguments[5],l=arguments.length>6&&void 0!==arguments[6]&&arguments[6],r=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const t=function(E,H,d){const Z=[3*E[d],3*E[d+1],3*E[d+2]],I=[new n.wH(H[Z[0]],H[Z[0]+2],H[Z[0]+1]),new n.wH(H[Z[1]],H[Z[1]+2],H[Z[1]+1]),new n.wH(H[Z[2]],H[Z[2]+2],H[Z[2]+1])],g=I[0].RH(I[1]),l=I[2].RH(I[1]);return{v:I,n:n.wH.Cross(l,g).normalize()}},M=function(E,H,d,n){return H=V(E,H,d.x,n),H=V(E,H,d.y,n),V(E,H,d.z,n)},V=function(E,H,d,n){return E.setFloat32(H,d,n),H+4},w=function(E){if(l){let H=E;E instanceof C.c&&(H=E.sourceMesh);const d=H.getVerticesData(S.g.PositionKind,!0,!0);if(!d)return[];const Z=n.wH.Zero();let I;for(I=0;I<d.length;I+=3)n.wH.TransformCoordinatesFromFloatsToRef(d[I],d[I+1],d[I+2],E.yd(!0),Z).toArray(d,I);return d}return E.getVerticesData(S.g.PositionKind)||[]};l&&(g=!0);let R="",Q=0,L=0;if(Z){for(let d=0;d<E.length;d++){const H=E[d].Nd();Q+=H?H.length/3:0}const H=new ArrayBuffer(84+50*Q);R=new DataView(H),L+=80,R.setUint32(L,Q,I),L+=4}else r||(R="solid stlmesh\r\n");for(let n=0;n<E.length;n++){const H=E[n];!Z&&r&&(R+="solid "+H.name+"\r\n"),!g&&H instanceof DE.e&&H.bakeCurrentTransformIntoVertices();const d=w(H),l=H.Nd()||[];for(let E=0;E<l.length;E+=3){const H=t(l,d,E);Z?(L=M(R,L,H.n,I),L=M(R,L,H.v[0],I),L=M(R,L,H.v[1],I),L=M(R,L,H.v[2],I),L+=2):(R+="\tfacet normal "+H.n.x+" "+H.n.y+" "+H.n.z+"\r\n",R+="\t\touter loop\r\n",R+="\t\t\tvertex "+H.v[0].x+" "+H.v[0].y+" "+H.v[0].z+"\r\n",R+="\t\t\tvertex "+H.v[1].x+" "+H.v[1].y+" "+H.v[1].z+"\r\n",R+="\t\t\tvertex "+H.v[2].x+" "+H.v[2].y+" "+H.v[2].z+"\r\n",R+="\t\tendloop\r\n",R+="\tendfacet\r\n")}!Z&&r&&(R+="endsolid "+name+"\r\n")}if(Z||r||(R+="endsolid stlmesh"),H){const E=document.createElement("a"),H=new Blob([R],{type:"application/octet-stream"});E.href=window.URL.createObjectURL(H),E.download=d+".stl",E.click()}return R}}function bH(E,H){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const n=[];for(let Z=0;Z<E.length/d;Z++){const I=E[Z*d],g=E[Z*d+1],l=E[Z*d+2];n.push(`(${I.toPrecision(H.precision)}, ${g.toPrecision(H.precision)}, ${l.toPrecision(H.precision)})`)}return n.join(", ")}function hH(E,H){const d=[];for(let n=0;n<E.length/2;n++){const Z=E[2*n],I=E[2*n+1];d.push(`(${Z.toPrecision(H.precision)}, ${(1-I).toPrecision(H.precision)})`)}return d.join(", ")}function yH(E,H){const d=E.getVerticesData(S.g.PositionKind),n=E.getVerticesData(S.g.NormalKind);if(d&&n)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(E){var H;const d=null!==(H=E.Nd())&&void 0!==H&&H.length?E.getTotalIndices():E.getTotalVertices();return Array(d/3).fill(3).join(", ")}(E)}]\n\t\tint[] faceVertexIndices = [${function(E){const H=E.Nd(),d=[];if(null!==H)for(let n=0;n<H.length;n++)d.push(H[n]);else{const H=E.getTotalVertices();for(let E=0;E<H;E++)d.push(E)}return d.join(", ")}(E)}]\n\t\tnormal3f[] normals = [${bH(n,H)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${bH(d,H)}]\n        ${function(E,H){let d="";for(let Z=0;Z<4;Z++){const n=Z>0?Z:"",I=E.getVerticesData(S.g.UVKind+(n?n+1:""));I&&(d+=`\n\t\ttexCoord2f[] primvars:st${n} = [${hH(I,H)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const n=E.getVerticesData(S.g.ColorKind);return n&&(d+=`\n\tcolor3f[] primvars:displayColor = [${bH(n,H,n.length/E.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),d}(E,H)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function vH(E,H){return`\n        def "Geometry"\n        {\n        ${yH(E,H)}\n        }\n        `}function zH(E){let H='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return H+=E,fflate.strToU8(H)}function KH(E){const H=E.m;return`( ${NH(H,0)}, ${NH(H,4)}, ${NH(H,8)}, ${NH(H,12)} )`}function NH(E,H){return`(${E[H+0]}, ${E[H+1]}, ${E[H+2]}, ${E[H+3]})`}function md(E){const H="Object_"+E.uniqueId,d=function(E){const H=E.getWorldMatrix().clone(),d=E.fE().useRightHandedSystem;if(!d){let n=E.parent;for(;n;){if(gE(n,d)){H.multiplyToRef(n.getWorldMatrix().invert(),H);break}n=n.parent}}return H.determinant()<0&&Z.Tools.Warn(`Exporting mesh ${E.name} with negative scale. Result may look incorrect in destination engine.`),H}(E),n=KH(d);return`def Xform "${H}" (\n\tprepend references = @./geometries/Geometry_${E.Kd.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${n}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${E.material.uniqueId}>\n}\n\n`}function TH(E){switch(E){case f.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case f.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case f.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function AH(E){return`(${E.x}, ${E.y})`}function BH(E){return`(${E.r}, ${E.g}, ${E.b})`}function JH(E,H,d,Z,I,g){const l=E.getInternalTexture().uniqueId+"_"+E.invertY;I[l]=E;const r=E.coordinatesIndex>0?"st"+E.coordinatesIndex:"st",t=new n.Vector2(E.uScale,E.vScale),S=new n.Vector2(E.uOffset,E.vOffset),M=E.wAng,V=Math.sin(M),C=Math.cos(M);return S.y=1-S.y-t.y,S.x+=V*t.x,S.y+=(1-C)*t.y,`\n    def Shader "PrimvarReader_${d}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${r}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${d}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${H.uniqueId}/PrimvarReader_${d}.outputs:result>\n        float inputs:rotation = ${(M*(180/Math.PI)).toFixed(g.precision)}\n        float2 inputs:scale = ${AH(t)}\n        float2 inputs:translation = ${AH(S)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${E.uniqueId}_${d}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${l}.png@\n        float2 inputs:st.connect = </Materials/Material_${H.uniqueId}/Transform2d_${d}.outputs:result>\n        ${Z?"float4 inputs:scale = "+function(E){return`(${E.r}, ${E.g}, ${E.b}, 1.0)`}(Z):""}\n        token inputs:sourceColorSpace = "${E.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${TH(E.wrapU)}"\n        token inputs:wrapT = "${TH(E.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${H.needAlphaBlending()?"float outputs:a":""}\n    }`}function Ed(E,H,d){const n="\t\t\t",Z=[],I=[],{diffuseMap:g,eg:l,alphaCutOff:r,emissiveMap:t,emissive:S,normalMap:M,roughnessMap:V,roughnessChannel:C,roughness:w,metalnessMap:R,metalnessChannel:L,metalness:D,aoMap:e,aoMapChannel:s,aoMapIntensity:i,alphaMap:p,ior:f,clearCoatEnabled:P,clearCoat:j,clearCoatMap:X,clearCoatRoughness:W,clearCoatRoughnessMap:U}=function(E){const H={diffuseMap:null,eg:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return E instanceof RE.LH?{...H,diffuseMap:E.diffuseTexture,eg:E.diffuseColor,alphaCutOff:E.alphaCutOff,emissiveMap:E.emissiveTexture,emissive:E.emissiveColor,roughness:1,alphaMap:E.opacityTexture}:E instanceof tH.c?{...H,diffuseMap:E._albedoTexture,eg:E._albedoColor,alphaCutOff:E._alphaCutOff,emissiveMap:E._emissiveTexture,emissive:E._emissiveColor,normalMap:E._bumpTexture,roughnessMap:E._metallicTexture,roughnessChannel:E._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:E._roughness??1,metalnessMap:E._metallicTexture,metalnessChannel:E._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:E._metallic??0,aoMap:E._ambientTexture,aoMapChannel:E._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:E._ambientTextureStrength,alphaMap:E._opacityTexture,ior:E.subSurface.indexOfRefraction,clearCoatEnabled:E.clearCoat.isEnabled,clearCoat:E.clearCoat.Lg,clearCoatMap:E.clearCoat.texture,clearCoatRoughness:E.clearCoat.roughness,clearCoatRoughnessMap:E.clearCoat.useRoughnessFromMainTexture?E.clearCoat.texture:E.clearCoat.textureRoughness}:H}(E);return null!==g?(Z.push(`${n}color3f inputs:diffuseColor.connect = </Materials/Material_${E.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:rgb>`),E.needAlphaBlending()?Z.push(`${n}float inputs:opacity.connect = </Materials/Material_${E.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:a>`):E.needAlphaTesting()&&(Z.push(`${n}float inputs:opacity.connect = </Materials/Material_${E.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:a>`),Z.push(`${n}float inputs:opacityThreshold = ${r}`)),I.push(JH(g,E,"diffuse",l,H,d))):Z.push(`${n}color3f inputs:diffuseColor = ${BH(l||Q.DH.White())}`),null!==t?(Z.push(`${n}color3f inputs:emissiveColor.connect = </Materials/Material_${E.uniqueId}/Texture_${t.uniqueId}_emissive.outputs:rgb>`),I.push(JH(t,E,"emissive",S,H,d))):S&&S.toLuminance()>0&&Z.push(`${n}color3f inputs:emissiveColor = ${BH(S)}`),null!==M&&(Z.push(`${n}normal3f inputs:normal.connect = </Materials/Material_${E.uniqueId}/Texture_${M.uniqueId}_normal.outputs:rgb>`),I.push(JH(M,E,"normal",null,H,d))),null!==e&&(Z.push(`${n}float inputs:occlusion.connect = </Materials/Material_${E.uniqueId}/Texture_${e.uniqueId}_occlusion.outputs:${s}>`),I.push(JH(e,E,"occlusion",new Q.DH(i,i,i),H,d))),null!==V?(Z.push(`${n}float inputs:roughness.connect = </Materials/Material_${E.uniqueId}/Texture_${V.uniqueId}_roughness.outputs:${C}>`),I.push(JH(V,E,"roughness",new Q.DH(w,w,w),H,d))):Z.push(`${n}float inputs:roughness = ${w}`),null!==R?(Z.push(`${n}float inputs:metallic.connect = </Materials/Material_${E.uniqueId}/Texture_${R.uniqueId}_metallic.outputs:${L}>`),I.push(JH(R,E,"metallic",new Q.DH(D,D,D),H,d))):Z.push(`${n}float inputs:metallic = ${D}`),null!==p?(Z.push(`${n}float inputs:opacity.connect = </Materials/Material_${E.uniqueId}/Texture_${p.uniqueId}_opacity.outputs:r>`),Z.push(`${n}float inputs:opacityThreshold = 0.0001`),I.push(JH(p,E,"opacity",null,H,d))):Z.push(`${n}float inputs:opacity = ${E.alpha}`),P&&(null!==X?(Z.push(`${n}float inputs:clearcoat.connect = </Materials/Material_${E.uniqueId}/Texture_${X.uniqueId}_clearcoat.outputs:r>`),I.push(JH(X,E,"clearcoat",new Q.DH(j,j,j),H,d))):Z.push(`${n}float inputs:clearcoat = ${j}`),null!==U?(Z.push(`${n}float inputs:clearcoatRoughness.connect = </Materials/Material_${E.uniqueId}/Texture_${U.uniqueId}_clearcoatRoughness.outputs:g>`),I.push(JH(U,E,"clearcoatRoughness",new Q.DH(W,W,W),H,d))):Z.push(`${n}float inputs:clearcoatRoughness = ${W}`)),Z.push(`${n}float inputs:ior = ${f}`),`\n\tdef Material "Material_${E.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${Z.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${E.uniqueId}/PreviewSurface.outputs:surface>\n\n${I.join("\n")}\n\n\t}\n`}async function Hd(E,H,d){const I={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...H};"undefined"===typeof fflate&&await Z.Tools.LoadScriptAsync(I.fflateUrl);const g={};g[I.modelFileName]=null;let l='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';l+=function(E){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===E.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${E.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${E.planeAnchoringAlignment}"`:""}\n            `}(I);const r={};for(const n of E.meshes){if(0===n.getTotalVertices())continue;const E=n,H=E.Kd,t=E.material;if(!t||!H||d&&!d(E))continue;if(-1!==["LH","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(t.getClassName())){const d="geometries/Geometry_"+H.uniqueId+".usda";if(!(d in g)){const E=vH(H,I);g[d]=zH(E)}t.uniqueId in r||(r[t.uniqueId]=t),l+=md(E)}else Z.Tools.Warn("USDZExportAsync does not support this material type: "+t.getClassName())}E.activeCamera&&I.exportCamera&&(l+=function(E,H){const d="Camera_"+E.uniqueId,Z=KH(n.Matrix.RotationY(Math.PI).multiply(E.getWorldMatrix()));if(E.mode===f.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${d}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${Z}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${E.Gd.toPrecision(H.precision)}, ${E.maxZ.toPrecision(H.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(E.orthoLeft||1)+Math.abs(E.orthoRight||1))).toPrecision(H.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(E.orthoTop||1)+Math.abs(E.orthoBottom||1))).toPrecision(H.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const n=E.getEngine().getAspectRatio(E),I=H.cameraSensorWidth||35;return`def Camera "${d}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${Z}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${E.Gd.toPrecision(H.precision)}, ${E.maxZ.toPrecision(H.precision)})\n\t\t\tfloat focalLength = ${(I/(2*Math.tan(.5*E.fov))).toPrecision(H.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(I*n).toPrecision(H.precision)}\n\t\t\tfloat verticalAperture = ${(I/n).toPrecision(H.precision)}            \n\t\t}\n\t\n\t`}}(E.activeCamera,I)),l+="\n            }\n        }\n    }";const t={};l+=function(E,H,d){const n=[];for(const Z in E){const I=E[Z];n.push(Ed(I,H,d))}return`\n    def "Materials"\n{\n${n.join("")}\n}\n\n`}(r,t,I),g[I.modelFileName]=fflate.strToU8(l);for(const n in t){const E=t[n],H=E.getSize(),d=await E.readPixels();if(!d)throw new Error("Texture data is not available");const Z=await P.DumpTools.DumpDataAsync(H.width,H.height,d,"image/png",void 0,!1,!0);g[`textures/Texture_${n}.png`]=new Uint8Array(Z).slice()}let S=0;for(const n in g){const E=g[n];if(!E)continue;S+=34+n.length;const H=63&S;if(4!==H){const d=new Uint8Array(64-H);g[n]=[E,{extra:{12345:d}}]}S=E.length}return fflate.zipSync(g,{level:0})}}}]);