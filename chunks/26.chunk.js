"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[26],{13261:(U,G,C)=>{C.r(G),C.d(G,{EXT_materials_diffuse_roughness:()=>BG,EXT_mesh_gpu_instancing:()=>cU,GLTF2Export:()=>eU,GLTFData:()=>P,KHR_draco_mesh_compression:()=>LG,KHR_lights_punctual:()=>PG,KHR_materials_anisotropy:()=>DG,KHR_materials_clearcoat:()=>VG,KHR_materials_diffuse_transmission:()=>HG,KHR_materials_dispersion:()=>hG,KHR_materials_emissive_strength:()=>bG,KHR_materials_ior:()=>wG,KHR_materials_iridescence:()=>vG,KHR_materials_sheen:()=>dG,KHR_materials_specular:()=>ZG,KHR_materials_transmission:()=>qG,KHR_materials_unlit:()=>kG,KHR_materials_volume:()=>QG,KHR_texture_transform:()=>zG,OBJExport:()=>t,STLExport:()=>sG,USDZExportAsync:()=>CC,_ConvertToGLTFPBRMetallicRoughness:()=>a,_SolveMetallic:()=>q,__IGLTFExporterExtension:()=>E});var L=C(12896),X=C(12718),l=C(13178);class t{static OBJ(U,G,C,t){const E=[];let K=1,P=1;G&&(C||(C="mat"),E.push("mtllib "+C+".mtl"));for(let O=0;O<U.length;O++){const C=U[O],T=C.name||"mesh".concat(O,"}");E.push("o ".concat(T));let D=null;if(t){const U=C.eE(!0);D=new L.Matrix,U.invertToRef(D),C.bakeTransformIntoVertices(U)}if(G){const U=C.material;U&&E.push("usemtl "+U.id)}const y=C.iE;if(!y){X.Tools.Warn("No geometry is present on the mesh");continue}const V=y.getVerticesData("position"),p=y.getVerticesData("normal"),I=y.getVerticesData("uv"),H=y.cE();let x=0,h=0;if(!V||!H){X.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const N=U[0].wU().useRightHandedSystem?1:-1;for(let U=0;U<V.length;U+=3)E.push("v "+V[U]*N+" "+V[U+1]+" "+V[U+2]),x++;if(null!=p)for(let U=0;U<p.length;U+=3)E.push("vn "+p[U]*N+" "+p[U+1]+" "+p[U+2]);if(null!=I)for(let U=0;U<I.length;U+=2)E.push("vt "+I[U]+" "+I[U+1]),h++;const b=["","",""],o=(C.material||C.wU().defaultMaterial)._getEffectiveOrientation(C),[w,S]=o===l.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let U=0;U<H.length;U+=3){const G=[String(H[U]+K),String(H[U+w]+K),String(H[U+S]+K)],C=[String(H[U]+P),String(H[U+w]+P),String(H[U+S]+P)],L=G,X=null!=I?C:b,l=null!=p?G:b;E.push("f "+L[0]+"/"+X[0]+"/"+l[0]+" "+L[1]+"/"+X[1]+"/"+l[1]+" "+L[2]+"/"+X[2]+"/"+l[2])}t&&D&&C.bakeTransformIntoVertices(D),K+=x,P+=h}return E.join("\n")}static MTL(U){const G=[],C=U.material;G.push("newmtl mat1"),G.push("  Ns "+C.specularPower.toFixed(4)),G.push("  Ni 1.5000"),G.push("  d "+C.alpha.toFixed(4)),G.push("  Tr 0.0000"),G.push("  Tf 1.0000 1.0000 1.0000"),G.push("  illum 2"),G.push("  Ka "+C.ambientColor.r.toFixed(4)+" "+C.ambientColor.g.toFixed(4)+" "+C.ambientColor.b.toFixed(4)),G.push("  Kd "+C.diffuseColor.r.toFixed(4)+" "+C.diffuseColor.g.toFixed(4)+" "+C.diffuseColor.b.toFixed(4)),G.push("  Ks "+C.specularColor.r.toFixed(4)+" "+C.specularColor.g.toFixed(4)+" "+C.specularColor.b.toFixed(4)),G.push("  Ke "+C.emissiveColor.r.toFixed(4)+" "+C.emissiveColor.g.toFixed(4)+" "+C.emissiveColor.b.toFixed(4));C.ambientTexture&&G.push("  map_Ka "+C.ambientTexture.name),C.diffuseTexture&&G.push("  map_Kd "+C.diffuseTexture.name),C.specularTexture&&G.push("  map_Ks "+C.specularTexture.name),C.bumpTexture&&G.push("  map_bump -imfchan z "+C.bumpTexture.name),C.opacityTexture&&G.push("  map_d "+C.opacityTexture.name);return G.join("\n")}}var E=0,K=C(12772);class P{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const U in this.files){const G=this.files[U],C=new Blob([G],{type:(0,K.g)(U)});X.Tools.Download(C,U)}}}var O=C(26),T=C(12957),D=C(13267),y=C(13280),V=C(13297),p=C(13014),I=C(12763),H=C(12934),x=C(12911);const h=x.HighestCommonFactor,N=(0,O.b)((0,O.b)({},x),{},{TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:h});var b=C(13092),o=C(12873),w=C(13339),S=C(13347),v=C(13089);const u=1e-6,d=new H.hG(.04,.04,.04),g=1024,Z=H.hG.White(),F=H.hG.Black();function q(U,G,C){if(G<d.r)return 0;const L=d.r,X=U*C/(1-d.r)+G-2*d.r,l=X*X-4*L*(d.r-G);return N.Clamp((-X+Math.sqrt(l))/(2*L),0,1)}function a(U){const G=U.diffuseColor.toLinearSpace(U.wU().getEngine().useExactSrgbConversions).scale(.5),C=U.alpha,X=function(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new L.Vector2(0,1),C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new L.Vector2(0,.1),X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new L.Vector2(0,.1),l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new L.Vector2(1300,.1);return function(U,G,C,L,X){return(1-U)*(1-U)*(1-U)*G+3*(1-U)*(1-U)*U*C+3*(1-U)*U*U*L+U*U*U*X}(Math.pow(U/l.x,.333333),G.y,C.y,X.y,l.y)}(N.Clamp(U.specularPower,0,g));return{baseColorFactor:[G.r,G.g,G.b,C],metallicFactor:0,roughnessFactor:X}}function k(U,G){G.needAlphaBlending()?U.alphaMode="BLEND":G.needAlphaTesting()&&(U.alphaMode="MASK",U.alphaCutoff=G.alphaCutOff)}function n(U,G,C){const L=new Uint8Array(U*G*4);for(let X=0;X<L.length;X+=4)L[X]=L[X+1]=L[X+2]=L[X+3]=255;return w.b.CreateRGBATexture(L,U,G,C)}function Q(U){if(U instanceof Uint8Array){const G=U.length,C=new Float32Array(U.length);for(let L=0;L<G;++L)C[L]=U[L]/255;return C}if(U instanceof Float32Array)return U;throw new Error("Unsupported pixel format!")}class mU{constructor(U){this._exporter=U,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(U){var G;return U&&null!==(G=this._textureMap.get(U))&&void 0!==G?G:null}async exportStandardMaterialAsync(U,G,C){const L=a(U),l={name:U.name};if(null==U.RE||U.RE||(U.twoSidedLighting||X.Tools.Warn(U.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),l.doubleSided=!0),C){const C=[],X=U.diffuseTexture;X&&C.push(this.exportTextureAsync(X,G).then((U=>{U&&(L.baseColorTexture=U)})));const t=U.bumpTexture;t&&C.push(this.exportTextureAsync(t,G).then((U=>{U&&(l.normalTexture=U,1!==t.level&&(l.normalTexture.scale=t.level))})));const E=U.emissiveTexture;E&&(l.emissiveFactor=[1,1,1],C.push(this.exportTextureAsync(E,G).then((U=>{U&&(l.emissiveTexture=U)}))));const K=U.ambientTexture;K&&C.push(this.exportTextureAsync(K,G).then((U=>{if(U){const G={index:U.index};l.occlusionTexture=G}}))),C.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(C))}(U.alpha<1||U.opacityTexture)&&(U.alphaMode===S.e.ALPHA_COMBINE?l.alphaMode="BLEND":X.Tools.Warn(U.name+": glTF 2.0 does not support alpha mode: "+U.alphaMode.toString())),U.emissiveColor&&!U.emissiveColor.equalsWithEpsilon(F,u)&&(l.emissiveFactor=U.emissiveColor.sE()),l.pbrMetallicRoughness=L,k(l,U),await this._finishMaterialAsync(l,U,G);const t=this._exporter._materials;return t.push(l),t.length-1}async _finishMaterialAsync(U,G,C){const L=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",U,G),X=[];for(const l of L)X.push(this.exportTextureAsync(l,C));await Promise.all(X),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",U,G)}async _getImageDataAsync(U,G,L,X){const l=S.e.TEXTURETYPE_UNSIGNED_BYTE,t=this._exporter._babylonScene,E=t.getEngine(),K=E.createRawTexture(U,G,L,S.e.TEXTUREFORMAT_RGBA,!1,!0,o.c.NEAREST_SAMPLINGMODE,null,l);E.isWebGPU?await C.e(51).then(C.bind(C,14943)):await C.e(52).then(C.bind(C,14949)),await b.g.ApplyPostProcess("pass",K,t,l,S.e.TEXTURE_NEAREST_SAMPLINGMODE,S.e.TEXTUREFORMAT_RGBA);const P=await E._readTexturePixels(K,G,L);return await v.DumpTools.DumpDataAsync(G,L,P,X,void 0,!0,!0)}_resizeTexturesToSameDimensions(U,G,C){const L=U?U.getSize():{width:0,height:0},X=G?G.getSize():{width:0,height:0};let l,t;return L.width<X.width?(l=U&&U instanceof o.c?b.g.CreateResizedCopy(U,X.width,X.height,!0):n(X.width,X.height,C),t=G):L.width>X.width?(t=G&&G instanceof o.c?b.g.CreateResizedCopy(G,L.width,L.height,!0):n(L.width,L.height,C),l=U):(l=U,t=G),{texture1:l,texture2:t}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(U,G,C,L){const X=new Array;if(!U&&!G)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const l=U?U.wU():G?G.wU():null;if(l){var t;const E=this._resizeTexturesToSameDimensions(U,G,l),K=null===(t=E.texture1)||void 0===t?void 0:t.getSize();let P,O;const T=K.width,D=K.height,y=await E.texture1.readPixels(),V=await E.texture2.readPixels();if(!y)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(P=Q(y),!V)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");O=Q(V);const p=O.byteLength,I=new Uint8Array(p),x=new Uint8Array(p),h=4,N=F;let b=0,o=0;for(let U=0;U<D;++U)for(let G=0;G<T;++G){const L=(T*U+G)*h,X={diffuseColor:new H.hG(P[L],P[L+1],P[L+2]).toLinearSpace(l.getEngine().useExactSrgbConversions).multiply(C.diffuseColor),specularColor:new H.hG(O[L],O[L+1],O[L+2]).toLinearSpace(l.getEngine().useExactSrgbConversions).multiply(C.specularColor),glossiness:O[L+3]*C.glossiness},t=this._convertSpecularGlossinessToMetallicRoughness(X);N.r=Math.max(N.r,t.baseColor.r),N.g=Math.max(N.g,t.baseColor.g),N.b=Math.max(N.b,t.baseColor.b),b=Math.max(b,t.metallic),o=Math.max(o,t.roughness),x[L]=255*t.baseColor.r,x[L+1]=255*t.baseColor.g,x[L+2]=255*t.baseColor.b,x[L+3]=E.texture1.jE?255*P[L+3]:255,I[L]=0,I[L+1]=255*t.roughness,I[L+2]=255*t.metallic,I[L+3]=255}const w={baseColor:N,metallic:b,roughness:o};let S=!1,v=!1;for(let U=0;U<D;++U)for(let G=0;G<T;++G){const C=(T*U+G)*h;x[C]/=w.baseColor.r>u?w.baseColor.r:1,x[C+1]/=w.baseColor.g>u?w.baseColor.g:1,x[C+2]/=w.baseColor.b>u?w.baseColor.b:1;const L=H.hG.FromInts(x[C],x[C+1],x[C+2]).toGammaSpace(l.getEngine().useExactSrgbConversions);x[C]=255*L.r,x[C+1]=255*L.g,x[C+2]=255*L.b,L.equalsWithEpsilon(Z,u)||(v=!0),I[C+1]/=w.roughness>u?w.roughness:1,I[C+2]/=w.metallic>u?w.metallic:1;H.hG.FromInts(255,I[C+1],I[C+2]).equalsWithEpsilon(Z,u)||(S=!0)}return S&&X.push(this._getImageDataAsync(I,T,D,L).then((U=>{w.metallicRoughnessTextureData=U}))),v&&X.push(this._getImageDataAsync(x,T,D,L).then((U=>{w.baseColorTextureData=U}))),await Promise.all(X).then((()=>w))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(U){const G=this._getPerceivedBrightness(U.diffuseColor),C=this._getPerceivedBrightness(U.specularColor),L=1-this._getMaxComponent(U.specularColor),X=q(G,C,L),l=U.diffuseColor.scale(L/(1-d.r)/Math.max(1-X)),t=U.specularColor.IG(d.scale(1-X)).scale(1/Math.max(X));let E=H.hG.Lerp(l,t,X*X);E=E.clampToRef(0,1,E);return{baseColor:E,metallic:X,roughness:1-U.glossiness}}_getPerceivedBrightness(U){return U?Math.sqrt(.299*U.r*U.r+.587*U.g*U.g+.114*U.b*U.b):0}_getMaxComponent(U){return U?Math.max(U.r,Math.max(U.g,U.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(U,G,C,L){const X=[],l={baseColor:U._albedoColor,metallic:U._metallic,roughness:U._roughness};if(L){U._albedoTexture&&X.push(this.exportTextureAsync(U._albedoTexture,G).then((U=>{U&&(C.baseColorTexture=U)})));const L=U._metallicTexture;L&&X.push(this.exportTextureAsync(L,G).then((U=>{U&&(C.metallicRoughnessTexture=U)})))}return X.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(X)),l}_getTextureSampler(U){const G={};if(!U||!(U instanceof o.c))return G;const C=this._getGLTFTextureWrapMode(U.wrapU);10497!==C&&(G.wrapS=C);const L=this._getGLTFTextureWrapMode(U.wrapV);switch(10497!==L&&(G.wrapT=L),U.samplingMode){case o.c.LINEAR_LINEAR:G.magFilter=9729,G.minFilter=9729;break;case o.c.LINEAR_NEAREST:G.magFilter=9729,G.minFilter=9728;break;case o.c.NEAREST_LINEAR:G.magFilter=9728,G.minFilter=9729;break;case o.c.NEAREST_LINEAR_MIPLINEAR:G.magFilter=9728,G.minFilter=9987;break;case o.c.NEAREST_NEAREST:G.magFilter=9728,G.minFilter=9728;break;case o.c.NEAREST_LINEAR_MIPNEAREST:G.magFilter=9728,G.minFilter=9985;break;case o.c.LINEAR_NEAREST_MIPNEAREST:G.magFilter=9729,G.minFilter=9984;break;case o.c.LINEAR_NEAREST_MIPLINEAR:G.magFilter=9729,G.minFilter=9986;break;case o.c.NEAREST_NEAREST_MIPLINEAR:G.magFilter=9728,G.minFilter=9986;break;case o.c.LINEAR_LINEAR_MIPLINEAR:G.magFilter=9729,G.minFilter=9987;break;case o.c.LINEAR_LINEAR_MIPNEAREST:G.magFilter=9729,G.minFilter=9985;break;case o.c.NEAREST_NEAREST_MIPNEAREST:G.magFilter=9728,G.minFilter=9984}return G}_getGLTFTextureWrapMode(U){switch(U){case o.c.WRAP_ADDRESSMODE:return 10497;case o.c.CLAMP_ADDRESSMODE:return 33071;case o.c.MIRROR_ADDRESSMODE:return 33648;default:return X.Tools.Error("Unsupported Texture Wrap Mode ".concat(U,"!")),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(U,G,C,L){const X={diffuseColor:U._albedoColor,specularColor:U._reflectivityColor,glossiness:U._microSurface},l=U._albedoTexture,t=U._reflectivityTexture,E=U._useMicroSurfaceFromReflectivityMapAlpha;if(t&&!E)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((l||t)&&L){this._exporter._materialNeedsUVsSet.add(U);const L=this._exportTextureSampler(l||t),E=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(l,t,X,G),K=this._exporter._textures;if(E.baseColorTextureData){const U=this._exportImage("baseColor".concat(K.length),G,E.baseColorTextureData);C.baseColorTexture=this._exportTextureInfo(U,L,null===l||void 0===l?void 0:l.coordinatesIndex)}if(E.metallicRoughnessTextureData){const U=this._exportImage("metallicRoughness".concat(K.length),G,E.metallicRoughnessTextureData);C.metallicRoughnessTexture=this._exportTextureInfo(U,L,null===t||void 0===t?void 0:t.coordinatesIndex)}return E}return this._convertSpecularGlossinessToMetallicRoughness(X)}async exportPBRMaterialAsync(U,G,C){const L={},X={name:U.name},l=U.isMetallicWorkflow();if(l){const G=U._albedoColor,C=U.alpha;G&&(L.baseColorFactor=[G.r,G.g,G.b,C])}const t=l?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(U,G,L,C):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(U,G,L,C);await this._setMetallicRoughnessPbrMaterialAsync(t,U,X,L,G,C),await this._finishMaterialAsync(X,U,G);const E=this._exporter._materials;return E.push(X),E.length-1}async _setMetallicRoughnessPbrMaterialAsync(U,G,C,L,l,t){if(k(C,G),U.baseColor.equalsWithEpsilon(Z,u)&&N.WithinEpsilon(G.alpha,1,u)||(L.baseColorFactor=[U.baseColor.r,U.baseColor.g,U.baseColor.b,G.alpha]),null!=U.metallic&&1!==U.metallic&&(L.metallicFactor=U.metallic),null!=U.roughness&&1!==U.roughness&&(L.roughnessFactor=U.roughness),null==G.RE||G.RE||(G._twoSidedLighting||X.Tools.Warn(G.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),C.doubleSided=!0),t){const U=[],L=G._bumpTexture;L&&U.push(this.exportTextureAsync(L,l).then((U=>{U&&(C.normalTexture=U,1!==L.level&&(C.normalTexture.scale=L.level))})));const X=G._ambientTexture;X&&U.push(this.exportTextureAsync(X,l).then((U=>{if(U){const L={index:U.index,texCoord:U.texCoord,extensions:U.extensions};C.occlusionTexture=L;const X=G._ambientTextureStrength;X&&(L.strength=X)}})));const t=G._emissiveTexture;t&&U.push(this.exportTextureAsync(t,l).then((U=>{U&&(C.emissiveTexture=U)}))),U.length>0&&(this._exporter._materialNeedsUVsSet.add(G),await Promise.all(U))}const E=G._emissiveColor;E.equalsWithEpsilon(F,u)||(C.emissiveFactor=E.sE()),C.pbrMetallicRoughness=L}_getPixelsFromTextureAsync(U){return function(U){switch(U){case S.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case S.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case S.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case S.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case S.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case S.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case S.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case S.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case S.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case S.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case S.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case S.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case S.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case S.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case S.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case S.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case S.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case S.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case S.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case S.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case S.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(U.textureFormat)?(0,b.f)(U,U._texture.width,U._texture.height):(U.textureType,S.e.TEXTURETYPE_UNSIGNED_BYTE,U.readPixels())}async exportTextureAsync(U,G){const C=this._exporter._extensionsPreExportTextureAsync("exporter",U,G);return C?await C.then((async C=>C?await this._exportTextureInfoAsync(C,G):await this._exportTextureInfoAsync(U,G))):await this._exportTextureInfoAsync(U,G)}async _exportTextureInfoAsync(U,G){let C=this._textureMap.get(U);if(!C){const L=await this._getPixelsFromTextureAsync(U);if(!L)return null;const l=this._exportTextureSampler(U),t=U.mimeType;if(t)switch(t){case"image/jpeg":case"image/png":case"image/webp":G=t;break;default:X.Tools.Warn("Unsupported media type: ".concat(t,". Exporting texture as PNG."))}const E=this._internalTextureToImage,K=U.getInternalTexture().uniqueId;E[K]||(E[K]={});let P=E[K][G];if(void 0===P){const C=U.getSize();P=(async()=>{const X=await this._getImageDataAsync(L,C.width,C.height,G);return this._exportImage(U.name,G,X)})(),E[K][G]=P}C=this._exportTextureInfo(await P,l,U.coordinatesIndex),this._textureMap.set(U,C),this._exporter._extensionsPostExportTextures("exporter",C,U)}return C}_exportImage(U,G,C){const L=this._exporter._images;let l;if(this._exporter._shouldUseGlb){l={name:U,mimeType:G,bufferView:void 0};const L=this._exporter._bufferManager.createBufferView(new Uint8Array(C));this._exporter._bufferManager.setBufferView(l,L)}else{const t=U.replace(/\.\/|\/|\.\\|\\/g,"_"),E=function(U){switch(U){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(G);let K=t+E;L.some((U=>U.uri===K))&&(K="".concat(t,"_").concat(X.Tools.RandomId()).concat(E)),l={name:U,uri:K},this._exporter._imageData[K]={data:C,mimeType:G}}return L.push(l),L.length-1}_exportTextureInfo(U,G,C){const L=this._exporter._textures;let X=L.findIndex((C=>C.sampler==G&&C.source===U));-1===X&&(X=L.length,L.push({source:U,sampler:G}));const l={index:X};return C&&(l.texCoord=C),l}_exportTextureSampler(U){const G=this._getTextureSampler(U),C=this._exporter._samplers,L=C.findIndex((U=>U.minFilter===G.minFilter&&U.magFilter===G.magFilter&&U.wrapS===G.wrapS&&U.wrapT===G.wrapT));return-1!==L?L:(C.push(G),C.length-1)}}var B=C(12969),M=C(12731),z=C(13349),s=C(12898);const j=L.pG.Zero(),A=L.Quaternion.Identity(),Y=L.pG.One(),e=new L.pG(-1,1,1);function i(U,G){const{byteOffset:C,byteStride:L,type:X,normalized:l}=U,t=U.getSize(),E=G.reduce(((U,G)=>G.getTotalVertices()>U?G.getTotalVertices():U),-Number.MAX_VALUE);return{byteOffset:C,byteStride:L,componentCount:t,type:X,count:E*t,normalized:l,totalVertices:E,kind:U.getKind()}}function c(U){switch(U){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function R(U){switch(U){case T.e.PositionKind:case T.e.NormalKind:case T.e.TangentKind:case T.e.ColorKind:case T.e.MatricesIndicesKind:case T.e.MatricesIndicesExtraKind:case T.e.MatricesWeightsKind:case T.e.MatricesWeightsExtraKind:case T.e.UVKind:case T.e.UV2Kind:case T.e.UV3Kind:case T.e.UV4Kind:case T.e.UV5Kind:case T.e.UV6Kind:return!0}return!1}function W(U){switch(U){case l.c.TriangleFillMode:return 4;case l.c.TriangleStripDrawMode:return 5;case l.c.TriangleFanDrawMode:return 6;case l.c.PointListDrawMode:case l.c.PointFillMode:return 0;case l.c.LineLoopDrawMode:return 2;case l.c.LineListDrawMode:return 1;case l.c.LineStripDrawMode:return 3}throw new Error("Unknown fill mode: ".concat(U))}function f(U){const G=Math.sqrt(U.x*U.x+U.y*U.y+U.z*U.z);G>0&&(U.x/=G,U.y/=G,U.z/=G)}function r(U){return U.x*=-1,U}function J(U){if(U.x*U.x+U.y*U.y>.5){const G=Math.abs(U.x),C=Math.abs(U.y);if(G>C){const C=Math.sign(U.x);U.x=G,U.y*=-C,U.z*=-C,U.w*=C}else{const G=Math.sign(U.y);U.x*=-G,U.y=C,U.z*=G,U.w*=-G}}else{const G=Math.abs(U.z),C=Math.abs(U.w);if(G>C){const C=Math.sign(U.z);U.x*=-C,U.y*=C,U.z=G,U.w*=-C}else{const G=Math.sign(U.w);U.x*=G,U.y*=-G,U.z*=-G,U.w=C}}return U}function UU(U){U.WE(-U.z,U.w,U.x,-U.y)}function GU(U,G){const C=L.pG.FromArrayToRef(G.translation||[0,0,0],0,L.TmpVectors.pG[0]),X=L.Quaternion.FromArrayToRef(G.rotation||[0,0,0,1],0,L.TmpVectors.Quaternion[0]),l=L.Matrix.ComposeToRef(Y,X,C,L.TmpVectors.Matrix[0]),t=L.pG.FromArrayToRef(U.translation||[0,0,0],0,L.TmpVectors.pG[2]),E=L.Quaternion.FromArrayToRef(U.rotation||[0,0,0,1],0,L.TmpVectors.Quaternion[1]),K=L.Matrix.ComposeToRef(Y,E,t,L.TmpVectors.Matrix[1]);l.multiplyToRef(K,K),K.decompose(void 0,X,C),C.equalsWithEpsilon(j,s.d)?delete G.translation:G.translation=C.sE(),X.equalsWithEpsilon(A,s.d)?delete G.rotation:G.rotation=X.sE(),G.scale&&delete G.scale}function CU(U,G){if(!(G instanceof D.b))return!1;if(!(1===G.getChildren().length&&0===U.getChildren().length&&U.parent===G))return!1;const C=U.wU(),L=U instanceof z.b&&!C.useRightHandedSystem?e:Y;return!!G.fE.equalsWithEpsilon(L,s.d)||(M.d.Warn("Cannot collapse node ".concat(U.name," into parent node ").concat(G.name," with modified scaling.")),!1)}function LU(U){if(U instanceof Array){const G=new Float32Array(U);return new Uint8Array(G.buffer,G.byteOffset,G.byteLength)}return ArrayBuffer.isView(U)?new Uint8Array(U.buffer,U.byteOffset,U.byteLength):new Uint8Array(U)}function XU(U,G){for(const[C,L]of Object.entries(U)){const X=G[C];(Array.isArray(L)&&Array.isArray(X)&&lU(L,X)||L===X)&&delete U[C]}return U}function lU(U,G){return U.length===G.length&&U.every(((U,C)=>U===G[C]))}const tU=L.Matrix.Compose(new L.pG(-1,1,1),L.Quaternion.Identity(),L.pG.Zero());function EU(U,G){if(!(U instanceof D.b))return!1;if(G){if(!U.getWorldMatrix().equalsWithEpsilon(L.Matrix.IdentityReadOnly,s.d))return!1}else{if(!U.getWorldMatrix().multiplyToRef(tU,L.TmpVectors.Matrix[0]).equalsWithEpsilon(L.Matrix.IdentityReadOnly,s.d))return!1}return!(U instanceof y.c&&U.iE)}const KU=new Map([[Int8Array,(U,G,C)=>U.setInt8(G,C)],[Uint8Array,(U,G,C)=>U.setUint8(G,C)],[Uint8ClampedArray,(U,G,C)=>U.setUint8(G,C)],[Int16Array,(U,G,C)=>U.setInt16(G,C,!0)],[Uint16Array,(U,G,C)=>U.setUint16(G,C,!0)],[Int32Array,(U,G,C)=>U.setInt32(G,C,!0)],[Uint32Array,(U,G,C)=>U.setUint32(G,C,!0)],[Float32Array,(U,G,C)=>U.setFloat32(G,C,!0)],[Float64Array,(U,G,C)=>U.setFloat64(G,C,!0)]]);class PU{writeTypedArray(U){this._checkGrowBuffer(U.byteLength);const G=KU.get(U.constructor);for(let C=0;C<U.length;C++)G(this._dataView,this._byteOffset,U[C]),this._byteOffset+=U.BYTES_PER_ELEMENT}constructor(U){this._data=new Uint8Array(U),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(U){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,U),this._byteOffset++}writeInt8(U){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,U),this._byteOffset++}writeInt16(U){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,U,!0),this._byteOffset+=2}writeUInt16(U){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,U,!0),this._byteOffset+=2}writeInt32(U){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,U,!0),this._byteOffset+=4}writeUInt32(U){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,U,!0),this._byteOffset+=4}writeFloat32(U){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,U,!0),this._byteOffset+=4}writeFloat64(U){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,U,!0),this._byteOffset+=8}_checkGrowBuffer(U){const G=this.byteOffset+U;if(G>this._data.byteLength){const U=new Uint8Array(2*G);U.set(this._data),this._data=U,this._dataView=new DataView(this._data.buffer)}}}function OU(U){return U%4===0?4:U%2===0?2:1}class TU{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(U){let G=0;this._bufferViewToData.forEach((U=>{G+=U.byteLength}));const C=new PU(G),L=Array.from(this._bufferViewToData.keys()).sort(((U,G)=>OU(G.byteLength)-OU(U.byteLength)));for(const X of L){X.byteOffset=C.byteOffset,U.push(X);const G=U.length-1,L=this.getPropertiesWithBufferView(X);for(const U of L)U.bufferView=G;C.writeTypedArray(this._bufferViewToData.get(X)),this._bufferViewToData.delete(X)}return C.getOutputData()}createBufferView(U,G){const C={buffer:0,byteOffset:void 0,byteLength:U.byteLength,byteStride:G};return this._bufferViewToData.set(C,U),C}createAccessor(U,G,C,L,X,l,t){this._verifyBufferView(U);const E={bufferView:void 0,componentType:C,count:L,type:G,min:null===l||void 0===l?void 0:l.min,max:null===l||void 0===l?void 0:l.max,normalized:t,byteOffset:X};return this.setBufferView(E,U),this._accessorToBufferView.set(E,U),E}setBufferView(U,G){this._verifyBufferView(G);this.getPropertiesWithBufferView(G).push(U)}removeBufferView(U){const G=this.getPropertiesWithBufferView(U);for(const C of G)void 0!==C.bufferView&&delete C.bufferView;this._bufferViewToData.delete(U),this._bufferViewToProperties.delete(U),this._accessorToBufferView.forEach(((G,C)=>{G===U&&(void 0!==C.byteOffset&&delete C.byteOffset,this._accessorToBufferView.delete(C))}))}getBufferView(U){const G=this._accessorToBufferView.get(U);return this._verifyBufferView(G),G}getPropertiesWithBufferView(U){var G;return this._verifyBufferView(U),this._bufferViewToProperties.set(U,null!==(G=this._bufferViewToProperties.get(U))&&void 0!==G?G:[]),this._bufferViewToProperties.get(U)}getData(U){return this._verifyBufferView(U),this._bufferViewToData.get(U)}_verifyBufferView(U){if(void 0===U||!this._bufferViewToData.has(U))throw new Error("BufferView ".concat(U," not found in BufferManager."))}}var DU,yU=C(13310),VU=C(13331),pU=C(13354),IU=C(13228),HU=C(13392),xU=C(13403),hU=C(13306),NU=C(13412);!function(U){U[U.INTANGENT=0]="INTANGENT",U[U.OUTTANGENT=1]="OUTTANGENT"}(DU||(DU={}));class bU{static _IsTransformable(U){return U&&(U instanceof D.b||U instanceof yU.d||U instanceof NU.c)}static _CreateNodeAnimation(U,G,C,L,l){if(this._IsTransformable(U)){const t=[],E=[],K=G.getKeys(),P=bU._CalculateMinMaxKeyFrames(K),O=bU._DeduceInterpolation(K,C,L),T=O.interpolationType,D=O.shouldBakeAnimation;if(D?bU._CreateBakedAnimation(U,G,C,P.min,P.max,G.framePerSecond,l,t,E,P,L):"LINEAR"===T||"STEP"===T?bU._CreateLinearOrStepAnimation(U,G,C,t,E,L):"CUBICSPLINE"===T?bU._CreateCubicSplineAnimation(U,G,C,t,E,L):bU._CreateBakedAnimation(U,G,C,P.min,P.max,G.framePerSecond,l,t,E,P,L),t.length&&E.length){return{inputs:t,outputs:E,samplerInterpolation:T,inputsMin:D?P.min:X.Tools.FloatRound(P.min/G.framePerSecond),inputsMax:D?P.max:X.Tools.FloatRound(P.max/G.framePerSecond)}}}return null}static _DeduceAnimationInfo(U){let G=null,C="VEC3",L=!1;const l=U.targetProperty.split(".");switch(l[0]){case"fE":G="scale";break;case"position":G="translation";break;case"rotation":C="VEC4",G="rotation";break;case"rotationQuaternion":C="VEC4",L=!0,G="rotation";break;case"influence":C="SCALAR",G="weights";break;default:X.Tools.Error("Unsupported animatable property ".concat(l[0]))}return G?{animationChannelTargetPath:G,dataAccessorType:C,useQuaternion:L}:(X.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(U,G,C,L,X,l,t,E,K,P,O){let T;if(bU._IsTransformable(U)&&U.animations)for(const D of U.animations){if(O&&!O(D))continue;const X=bU._DeduceAnimationInfo(D);X&&(T={name:D.name,samplers:[],channels:[]},bU._AddAnimation("".concat(D.name),D.hasRunningRuntimeAnimations?G:T,U,D,X.dataAccessorType,X.animationChannelTargetPath,L,l,t,E,X.useQuaternion,K,P),T.samplers.length&&T.channels.length&&C.push(T))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(U,G,C,L,X,l,t,E,K,P,O){let T;if(U instanceof hU.d){const X=U.morphTargetManager;if(X)for(let D=0;D<X.numTargets;++D){const y=X.getTarget(D);for(const V of y.animations){if(O&&!O(V))continue;const y=new HU.d("".concat(V.name),"influence",V.framePerSecond,V.dataType,V.loopMode,V.enableBlending),p=[],I=V.getKeys();for(let U=0;U<I.length;++U){const G=I[U];for(let U=0;U<X.numTargets;++U)U==D?p.push(G):p.push({frame:G.frame,value:0})}y.setKeys(p);const H=bU._DeduceAnimationInfo(y);H&&(T={name:y.name,samplers:[],channels:[]},bU._AddAnimation(V.name,V.hasRunningRuntimeAnimations?G:T,U,y,H.dataAccessorType,H.animationChannelTargetPath,L,l,t,E,H.useQuaternion,K,P,X.numTargets),T.samplers.length&&T.channels.length&&C.push(T))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(U,G,C,L,X,l,t,E,K){let P;if(U.animationGroups){const T=U.animationGroups;for(const D of T){const T=new Map,y=new Map,V=new Set,p=D.to-D.from;P={name:D.name,channels:[],samplers:[]};for(let G=0;G<D.targetedAnimations.length;++G){const p=D.targetedAnimations[G],I=p.target,H=p.animation;if(K&&!K(H))continue;const x=E.has(I);if(this._IsTransformable(I)||1===I.length&&this._IsTransformable(I[0])){const U=bU._DeduceAnimationInfo(p.animation);if(U){const G=this._IsTransformable(I)?I:this._IsTransformable(I[0])?I[0]:null;G&&bU._AddAnimation("".concat(H.name),P,G,H,U.dataAccessorType,U.animationChannelTargetPath,C,L,X,l,U.useQuaternion,t,x)}}else if(I instanceof xU.b||1===I.length&&I[0]instanceof xU.b){if(bU._DeduceAnimationInfo(p.animation)){const G=I instanceof xU.b?I:I[0];if(G){const C=U.morphTargetManagers.find((U=>{for(let C=0;C<U.numTargets;++C)if(U.getTarget(C)===G)return!0;return!1}));if(C){const L=U.meshes.find((U=>U.morphTargetManager===C));var O;if(L)T.has(L)||T.set(L,new Map),null===(O=T.get(L))||void 0===O||O.set(G,H),V.add(L),y.set(L,H)}}}}}V.forEach((U=>{const G=U.morphTargetManager;let E=null;const K=[],O=y.get(U).getKeys(),V=O.length;for(let C=0;C<V;++C)for(let L=0;L<G.numTargets;++L){const X=G.getTarget(L),l=T.get(U);if(l){const G=l.get(X);G?(E||(E=new HU.d("".concat(D.name,"_").concat(U.name,"_MorphWeightAnimation"),"influence",G.framePerSecond,HU.d.ANIMATIONTYPE_FLOAT,G.loopMode,G.enableBlending)),K.push(G.getKeys()[C])):K.push({frame:D.from+p/V*C,value:X.influence,inTangent:O[0].inTangent?0:void 0,outTangent:O[0].outTangent?0:void 0})}}E.setKeys(K);const I=bU._DeduceAnimationInfo(E);I&&bU._AddAnimation("".concat(D.name,"_").concat(U.name,"_MorphWeightAnimation"),P,U,E,I.dataAccessorType,I.animationChannelTargetPath,C,L,X,l,I.useQuaternion,t,!1,null===G||void 0===G?void 0:G.numTargets)})),P.channels.length&&P.samplers.length&&G.push(P)}}}static _AddAnimation(U,G,C,X,l,t,E,K,P,O,T,D,y,V){const p=bU._CreateNodeAnimation(C,X,t,T,D);let I,H,x,h,N,b;if(p){if(V){let U=0,G=0;const C=[];for(;p.inputs.length>0;)G=p.inputs.shift(),U%V==0&&C.push(G),U++;p.inputs=C}const U=E.get(C),X=new Float32Array(p.inputs);I=K.createBufferView(X),H=K.createAccessor(I,"SCALAR",5126,p.inputs.length,void 0,{min:[p.inputsMin],max:[p.inputsMax]}),O.push(H),x=O.length-1;const P=new L.Quaternion,T=new L.pG,D=new L.pG,o=C instanceof yU.d,w=c(l),S=new Float32Array(p.outputs.length*w);p.outputs.forEach((function(U,G){let C=U;switch(t){case"translation":y&&(L.pG.FromArrayToRef(U,0,D),r(D),D.toArray(C));break;case"rotation":4===U.length?L.Quaternion.FromArrayToRef(U,0,P):(C=new Array(4),L.pG.FromArrayToRef(U,0,T),L.Quaternion.FromEulerVectorToRef(T,P)),y&&(J(P),o&&UU(P)),P.toArray(C)}S.set(C,G*w)})),I=K.createBufferView(S),H=K.createAccessor(I,l,5126,p.outputs.length),O.push(H),h=O.length-1,N={interpolation:p.samplerInterpolation,input:x,output:h},G.samplers.push(N),b={sampler:G.samplers.length-1,target:{node:U,path:t}},G.channels.push(b)}}static _CreateBakedAnimation(U,G,C,l,t,E,K,P,O,T,D){let y;const V=L.Quaternion.Identity();let p,I=null,H=null,x=null,h=null,N=null,b=null;T.min=X.Tools.FloatRound(l/E);const o=G.getKeys();for(let L=0,w=o.length;L<w;++L){if(b=null,x=o[L],L+1<w)if(h=o[L+1],x.value.equals&&x.value.equals(h.value)||x.value===h.value){if(0!==L)continue;b=x.frame}else b=h.frame;else{if(N=o[L-1],x.value.equals&&x.value.equals(N.value)||x.value===N.value)continue;b=t}if(b)for(let L=x.frame;L<=b;L+=K){if(p=X.Tools.FloatRound(L/E),p===I)continue;I=p,H=p;const l={key:0,repeatCount:0,loopMode:G.loopMode};y=G._interpolate(L,l),bU._SetInterpolatedValue(U,y,p,G,C,V,P,O,D)}}H&&(T.max=H)}static _ConvertFactorToVector3OrQuaternion(U,G,C,l,t){const E=bU._GetBasePositionRotationOrScale(G,l,t),K=C.targetProperty.split("."),P=K?K[1]:"",O=t?L.Quaternion.NG(E).normalize():L.pG.NG(E);switch(P){case"x":case"y":case"z":O[P]=U;break;case"w":O.w=U;break;default:X.Tools.Error('glTFAnimation: Unsupported component name "'.concat(P,'"!'))}return O}static _SetInterpolatedValue(U,G,C,X,l,t,E,K,P){let O;E.push(C),"weights"!==l?(X.dataType===HU.d.ANIMATIONTYPE_FLOAT&&(G=this._ConvertFactorToVector3OrQuaternion(G,U,X,l,P)),"rotation"===l?(P?t=G:(O=G,L.Quaternion.RotationYawPitchRollToRef(O.y,O.x,O.z,t)),K.push(t.sE())):(O=G,K.push(O.sE()))):K.push([G])}static _CreateLinearOrStepAnimation(U,G,C,L,X,l){for(const t of G.getKeys())L.push(t.frame/G.framePerSecond),bU._AddKeyframeValue(t,G,X,C,U,l)}static _CreateCubicSplineAnimation(U,G,C,L,X,l){G.getKeys().forEach((function(t){L.push(t.frame/G.framePerSecond),bU._AddSplineTangent(DU.INTANGENT,X,C,"CUBICSPLINE",t,l),bU._AddKeyframeValue(t,G,X,C,U,l),bU._AddSplineTangent(DU.OUTTANGENT,X,C,"CUBICSPLINE",t,l)}))}static _GetBasePositionRotationOrScale(U,G,C){let X;if("rotation"===G)if(C){const G=U.rotationQuaternion;X=(null!==G&&void 0!==G?G:L.Quaternion.Identity()).sE()}else{const G=U.rotation;X=(null!==G&&void 0!==G?G:L.pG.Zero()).sE()}else if("translation"===G){const G=U.position;X=(null!==G&&void 0!==G?G:L.pG.Zero()).sE()}else{const G=U.fE;X=(null!==G&&void 0!==G?G:L.pG.One()).sE()}return X}static _AddKeyframeValue(U,G,C,l,t,E){let K;const P=G.dataType;if(P===HU.d.ANIMATIONTYPE_VECTOR3){let G=U.value.sE();if("rotation"===l){const U=L.pG.NG(G);G=L.Quaternion.RotationYawPitchRoll(U.y,U.x,U.z).sE()}C.push(G)}else if(P===HU.d.ANIMATIONTYPE_FLOAT){if("weights"===l)C.push([U.value]);else if(K=this._ConvertFactorToVector3OrQuaternion(U.value,t,G,l,E),K){if("rotation"===l){const U=E?K:L.Quaternion.RotationYawPitchRoll(K.y,K.x,K.z).normalize();C.push(U.sE())}C.push(K.sE())}}else P===HU.d.ANIMATIONTYPE_QUATERNION?C.push(U.value.normalize().sE()):X.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(U,G,C){let L,X,l=!1;if("rotation"===G&&!C)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let t=0,E=U.length;t<E;++t)if(X=U[t],X.inTangent||X.outTangent)if(L){if("CUBICSPLINE"!==L){L="LINEAR",l=!0;break}}else L="CUBICSPLINE";else if(L){if("CUBICSPLINE"===L||X.interpolation&&1===X.interpolation&&"STEP"!==L){L="LINEAR",l=!0;break}}else L=X.interpolation&&1===X.interpolation?"STEP":"LINEAR";return L||(L="LINEAR"),{interpolationType:L,shouldBakeAnimation:l}}static _AddSplineTangent(U,G,C,X,l,t){let E;const K=U===DU.INTANGENT?l.inTangent:l.outTangent;if("CUBICSPLINE"===X){if("rotation"===C)if(K)if(t)E=K.sE();else{const U=K;E=L.Quaternion.RotationYawPitchRoll(U.y,U.x,U.z).sE()}else E=[0,0,0,0];else E="weights"===C?K?[K]:[0]:K?K.sE():[0,0,0];G.push(E)}}static _CalculateMinMaxKeyFrames(U){let G=1/0,C=-1/0;return U.forEach((function(U){G=Math.min(G,U.frame),C=Math.max(C,U.frame)})),{min:G,max:C}}}function oU(U,G,C,l,t,E){const K={attributes:{},influence:U.influence,name:U.name},P=G.iE;if(!P)return X.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),K;const O=E?-1:1,D=L.pG.Zero();let y=0,V=0;if(U.hasPositions){const l=U.getPositions(),E=P.getVerticesData(T.e.PositionKind);if(E){const U=new Float32Array(E.length),G=[1/0,1/0,1/0],X=[-1/0,-1/0,-1/0];V=E.length/3,y=0;for(let C=y;C<V;++C){const t=L.pG.NG(E,3*C);L.pG.NG(l,3*C).subtractToRef(t,D),D.x*=O,G[0]=Math.min(G[0],D.x),X[0]=Math.max(X[0],D.x),G[1]=Math.min(G[1],D.y),X[1]=Math.max(X[1],D.y),G[2]=Math.min(G[2],D.z),X[2]=Math.max(X[2],D.z),U[3*C]=D.x,U[3*C+1]=D.y,U[3*C+2]=D.z}const P=C.createBufferView(U,12),T=C.createAccessor(P,"VEC3",5126,l.length/3,0,{min:G,max:X});t.push(T),K.attributes.POSITION=t.length-1}else X.Tools.Warn("Morph target positions for mesh ".concat(G.name," were not exported. Mesh does not have position vertex data"))}if(U.hasNormals){const l=U.getNormals(),E=P.getVerticesData(T.e.NormalKind);if(E){const U=new Float32Array(E.length);V=E.length/3,y=0;for(let C=y;C<V;++C){const G=L.pG.NG(E,3*C).normalize();L.pG.NG(l,3*C).normalize().subtractToRef(G,D),U[3*C]=D.x*O,U[3*C+1]=D.y,U[3*C+2]=D.z}const G=C.createBufferView(U,12),X=C.createAccessor(G,"VEC3",5126,l.length/3,0);t.push(X),K.attributes.NORMAL=t.length-1}else X.Tools.Warn("Morph target normals for mesh ".concat(G.name," were not exported. Mesh does not have normals vertex data"))}if(U.hasTangents){const l=U.getTangents(),E=P.getVerticesData(T.e.TangentKind);if(E){V=E.length/4;const U=new Float32Array(3*V);y=0;for(let C=y;C<V;++C){const G=L.pG.NG(E,4*C);f(G);const X=L.pG.NG(l,3*C);f(X),X.subtractToRef(G,D),U[3*C]=D.x*O,U[3*C+1]=D.y,U[3*C+2]=D.z}const G=C.createBufferView(U,12),X=C.createAccessor(G,"VEC3",5126,V,0);t.push(X),K.attributes.TANGENT=t.length-1}else X.Tools.Warn("Morph target tangents for mesh ".concat(G.name," were not exported. Mesh does not have tangents vertex data"))}if(U.hasColors){const l=U.getColors(),E=P.getVerticesData(T.e.ColorKind),O=P.getVertexBuffer(T.e.ColorKind);if(E&&O){const U=O.getSize();V=E.length/U;const G=new Float32Array(V*U);y=0;for(let C=y;C<V;++C)if(3===U){const X=L.pG.NG(E,C*U);L.pG.NG(l,C*U).subtractToRef(X,D),G[3*C]=D.x,G[3*C+1]=D.y,G[3*C+2]=D.z}else if(4===U){const X=new L.Vector4,t=L.Vector4.NG(E,C*U);L.Vector4.NG(l,C*U).subtractToRef(t,X),G[4*C]=X.x,G[4*C+1]=X.y,G[4*C+2]=X.z,G[4*C+3]=X.w}else X.Tools.Warn("Unsupported number of components for color attribute: ".concat(U));const P=C.createBufferView(G,4*U),T=C.createAccessor(P,3===U?"VEC3":"VEC4",5126,V,0);t.push(T),K.attributes.COLOR_0=t.length-1}else X.Tools.Warn("Morph target colors for mesh ".concat(G.name," were not exported. Mesh does not have colors vertex data"))}return K}var wU=C(13421),SU=C(13252),vU=C(13238),uU=C(12850);class dU{}dU.DEFAULT_COLOR=H.hG.White(),dU.DEFAULT_WIDTH_ATTENUATED=1,dU.DEFAULT_WIDTH=.1;var gU=C(13084),ZU=C(13428);class FU{static ConvertPoints(U,G){if(U.length&&Array.isArray(U)&&"number"===typeof U[0])return[U];if(U.length&&Array.isArray(U[0])&&"number"===typeof U[0][0])return U;if(U.length&&!Array.isArray(U[0])&&U[0]instanceof L.pG){const G=[];for(let C=0;C<U.length;C++){const L=U[C];G.push(L.x,L.y,L.z)}return[G]}if(U.length>0&&Array.isArray(U[0])&&U[0].length>0&&U[0][0]instanceof L.pG){const G=[],C=U;for(const U of C)G.push(U.flatMap((U=>[U.x,U.y,U.z])));return G}if(U instanceof Float32Array){if(null!==G&&void 0!==G&&G.floatArrayStride){const C=[],L=3*G.floatArrayStride;for(let G=0;G<U.length;G+=L){const X=new Array(L);for(let C=0;C<L;C++)X[C]=U[G+C];C.push(X)}return C}return[Array.from(U)]}if(U.length&&U[0]instanceof Float32Array){const G=[];for(const C of U)G.push(Array.from(C));return G}return[]}static OmitZeroLengthPredicate(U,G,C){const L=[];return G.IG(U).lengthSquared()>0&&L.push([U,G]),C.IG(G).lengthSquared()>0&&L.push([G,C]),U.IG(C).lengthSquared()>0&&L.push([C,U]),0===L.length?null:L}static OmitDuplicatesPredicate(U,G,C,L){const X=[];return FU._SearchInPoints(U,G,L)||X.push([U,G]),FU._SearchInPoints(G,C,L)||X.push([G,C]),FU._SearchInPoints(C,U,L)||X.push([C,U]),0===X.length?null:X}static _SearchInPoints(U,G,C){for(const t of C)for(let C=0;C<t.length;C++){var L,X,l;if(null!==(L=t[C])&&void 0!==L&&L.equals(U))if(null!==(X=t[C+1])&&void 0!==X&&X.equals(G)||null!==(l=t[C-1])&&void 0!==l&&l.equals(G))return!0}return!1}static MeshesToLines(U,G){const C=[];for(let X=0;X<U.length;X++){const l=U[X],t=l.getVerticesData(T.e.PositionKind),E=l.cE();if(t&&E)for(let U=0,K=0;U<E.length;U++){const P=3*E[K++],O=3*E[K++],T=3*E[K++],D=new L.pG(t[P],t[P+1],t[P+2]),y=new L.pG(t[O],t[O+1],t[O+2]),V=new L.pG(t[T],t[T+1],t[T+2]);if(G){const L=G(D,y,V,C,U,P,l,X,t,E);if(L)for(const U of L)C.push(U)}else C.push([D,y],[y,V],[V,D])}}return C}static ToVector3Array(U){if(Array.isArray(U[0])){const G=[],C=U;for(const U of C){const C=[];for(let G=0;G<U.length;G+=3)C.push(new L.pG(U[G],U[G+1],U[G+2]));G.push(C)}return G}const G=U,C=[];for(let X=0;X<G.length;X+=3)C.push(new L.pG(G[X],G[X+1],G[X+2]));return C}static ToNumberArray(U){return U.flatMap((U=>[U.x,U.y,U.z]))}static GetPointsCountInfo(U){const G=new Array(U.length);let C=0;for(let L=U.length;L--;)G[L]=U[L].length/3,C+=G[L];return{total:C,counts:G}}static GetLineLength(U){if(0===U.length)return 0;let G;G="number"===typeof U[0]?FU.ToVector3Array(U):U;const C=L.TmpVectors.pG[0];let X=0;for(let L=0;L<G.length-1;L++){const U=G[L];X+=G[L+1].subtractToRef(U,C).length()}return X}static GetLineLengthArray(U){const G=new Float32Array(U.length/3);let C=0;for(let L=0,X=U.length/3-1;L<X;L++){let X=U[3*L+0],l=U[3*L+1],t=U[3*L+2];X-=U[3*L+3],l-=U[3*L+4],t-=U[3*L+5];C+=Math.sqrt(X*X+l*l+t*t),G[L+1]=C}return G}static SegmentizeSegmentByCount(U,G,C){const X=[],l=G.IG(U),t=L.TmpVectors.pG[0];t.rE(C);const E=L.TmpVectors.pG[1];l.divideToRef(t,E);let K=U.clone();X.push(K);for(let L=0;L<C;L++)K=K.clone(),X.push(K.addInPlace(E));return X}static SegmentizeLineBySegmentLength(U,G){const C=U[0]instanceof L.pG?FU.GetLineSegments(U):"number"===typeof U[0]?FU.GetLineSegments(FU.ToVector3Array(U)):U,X=[];for(const L of C)if(L.length>G){const U=FU.SegmentizeSegmentByCount(L.point1,L.point2,Math.ceil(L.length/G));for(const G of U)X.push(G)}else X.push(L.point1),X.push(L.point2);return X}static SegmentizeLineBySegmentCount(U,G){const C="number"===typeof U[0]?FU.ToVector3Array(U):U,L=FU.GetLineLength(C)/G;return FU.SegmentizeLineBySegmentLength(C,L)}static GetLineSegments(U){const G=[];for(let C=0;C<U.length-1;C++){const L=U[C],X=U[C+1],l=X.IG(L).length();G.push({point1:L,point2:X,length:l})}return G}static GetMinMaxSegmentLength(U){const G=FU.GetLineSegments(U).sort((U=>U.length));return{min:G[0].length,max:G[G.length-1].length}}static GetPositionOnLineByVisibility(U,G,C){let X=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const l=G*C;let t=0,E=0;const K=U.length;for(let L=0;L<K;L++){if(l<=t+U[L].length){E=L;break}t+=U[L].length}const P=(l-t)/U[E].length;return U[E].point2.subtractToRef(U[E].point1,L.TmpVectors.pG[0]),L.TmpVectors.pG[1]=L.TmpVectors.pG[0].multiplyByFloats(P,P,P),X||L.TmpVectors.pG[1].addInPlace(U[E].point1),L.TmpVectors.pG[1].clone()}static GetCircleLinePoints(U,G){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:U,l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/G;const t=[];for(let E=0;E<=G;E++)t.push(new L.pG(Math.cos(E*l)*U,Math.sin(E*l)*X,C));return t}static GetBezierLinePoints(U,G,C,L){return gU.h.CreateQuadraticBezier(U,G,C,L).getPoints().flatMap((U=>[U.x,U.y,U.z]))}static GetArrowCap(U,G,C,L,X){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,t=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[U.clone(),U.add(G.multiplyByFloats(C,C,C))],widths:[L,X,l,t]}}static GetPointsFromText(U,G,C,L){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const t=[],E=(0,ZU.b)(U,G,C,L);for(const K of E){for(const U of K.paths){const G=[],C=U.getPoints();for(const U of C)G.push(U.x,U.y,X);t.push(G)}if(l)for(const U of K.holes){const G=[],C=U.getPoints();for(const U of C)G.push(U.x,U.y,X);t.push(G)}}return t}static Color3toRGBAUint8(U){const G=new Uint8Array(4*U.length);for(let C=0,L=0;C<U.length;C++)G[L++]=255*U[C].r,G[L++]=255*U[C].g,G[L++]=255*U[C].b,G[L++]=255;return G}static CreateColorsTexture(U,G,C,L){var X;const l=null!==(X=L.getEngine().getCaps().maxTextureSize)&&void 0!==X?X:1,t=G.length>l?l:G.length,E=Math.ceil(G.length/l);E>1&&(G=[...G,...Array(t*E-G.length).fill(G[0])]);const K=FU.Color3toRGBAUint8(G),P=new w.b(K,t,E,p.d.TEXTUREFORMAT_RGBA,L,!1,!0,C);return P.name=U,P}static PrepareEmptyColorsTexture(U){if(!dU.EmptyColorsTexture){const G=new Uint8Array(4);dU.EmptyColorsTexture=new w.b(G,1,1,p.d.TEXTUREFORMAT_RGBA,U,!1,!1,w.b.NEAREST_NEAREST),dU.EmptyColorsTexture.name="grlEmptyColorsTexture"}return dU.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var U;null===(U=dU.EmptyColorsTexture)||void 0===U||U.dispose(),dU.EmptyColorsTexture=null}static BooleanToNumber(U){return U?1:0}}class qU extends vU.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class aU extends SU.e{isCompatible(U){return!0}constructor(U,G,C){var X,l,t,E,K,P,O,T,D,y,V,p,I,H,x,h,N;C=C||{color:dU.DEFAULT_COLOR};const b=new qU;var o;(b.GREASED_LINE_HAS_COLOR=!!C.color&&!C.useColors,b.GREASED_LINE_SIZE_ATTENUATION=null!==(X=C.sizeAttenuation)&&void 0!==X&&X,b.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===C.colorDistributionType,b.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(null!==G&&void 0!==G?G:U.wU()).useRightHandedSystem,b.GREASED_LINE_CAMERA_FACING=null===(l=C.cameraFacing)||void 0===l||l,super(U,aU.GREASED_LINE_MATERIAL_NAME,200,b,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(t=C)||void 0===t?void 0:t.forceGLSL)||aU.ForceGLSL,this._scene=null!==G&&void 0!==G?G:U.wU(),this._engine=this._scene.getEngine(),this._cameraFacing=null===(E=C.cameraFacing)||void 0===E||E,this.visibility=null!==(K=C.visibility)&&void 0!==K?K:1,this.useDash=null!==(P=C.useDash)&&void 0!==P&&P,this.dashRatio=null!==(O=C.dashRatio)&&void 0!==O?O:.5,this.dashOffset=null!==(T=C.dashOffset)&&void 0!==T?T:0,this.width=C.width?C.width:C.sizeAttenuation?dU.DEFAULT_WIDTH_ATTENUATED:dU.DEFAULT_WIDTH,this._sizeAttenuation=null!==(D=C.sizeAttenuation)&&void 0!==D&&D,this.colorMode=null!==(y=C.colorMode)&&void 0!==y?y:0,this._color=null!==(V=C.color)&&void 0!==V?V:null,this.useColors=null!==(p=C.useColors)&&void 0!==p&&p,this._colorsDistributionType=null!==(I=C.colorDistributionType)&&void 0!==I?I:0,this.colorsSampling=null!==(H=C.colorsSampling)&&void 0!==H?H:w.b.NEAREST_NEAREST,this._colors=null!==(x=C.dU)&&void 0!==x?x:null,this.dashCount=null!==(h=C.dashCount)&&void 0!==h?h:1,this.resolution=null!==(N=C.resolution)&&void 0!==N?N:new L.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),C.colorsTexture)?this.colorsTexture=C.colorsTexture:this._colors?this.colorsTexture=FU.CreateColorsTexture("".concat(U.name,"-colors-texture"),this._colors,this.colorsSampling,this._scene):(this._color=null!==(o=this._color)&&void 0!==o?o:dU.DEFAULT_COLOR,FU.PrepareEmptyColorsTexture(this._scene));this._engine.aE.add((()=>{FU.DisposeEmptyColorsTexture()}))}getAttributes(U){U.push("grl_offsets"),U.push("grl_widths"),U.push("grl_colorPointers"),U.push("grl_counters"),this._cameraFacing?(U.push("grl_previousAndSide"),U.push("grl_nextAndCounters")):U.push("grl_slopes")}getSamplers(U){U.push("grl_colors")}getActiveTextures(U){this.colorsTexture&&U.push(this.colorsTexture)}getUniforms(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const G=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&G.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===U&&G.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:G,vertex:this._cameraFacing&&this._isGLSL(U)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(U)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(U){var G,C,X;if(this._cameraFacing){U.YE("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||U.YE("viewProjection",this._scene.getTransformMatrix());const G=L.TmpVectors.Vector4[0];G.x=this._aspect,G.y=this._resolution.x,G.z=this._resolution.y,G.w=this.width,U.updateVector4("grl_aspect_resolution_lineWidth",G)}const l=L.TmpVectors.Vector4[0];l.x=FU.BooleanToNumber(this.useDash),l.y=this._dashArray,l.z=this.dashOffset,l.w=this.dashRatio,U.updateVector4("grl_dashOptions",l);const t=L.TmpVectors.Vector4[1];t.x=this.colorMode,t.y=this.visibility,t.z=this.colorsTexture?this.colorsTexture.getSize().width:0,t.w=FU.BooleanToNumber(this.useColors),U.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",t),this._color&&U.updateColor3("grl_singleColor",this._color);const E=null!==(G=this.colorsTexture)&&void 0!==G?G:dU.EmptyColorsTexture;U.setTexture("grl_colors",E),U.updateFloat2("grl_textureSize",null!==(C=null===E||void 0===E?void 0:E.getSize().width)&&void 0!==C?C:1,null!==(X=null===E||void 0===E?void 0:E.getSize().height)&&void 0!==X?X:1)}prepareDefines(U,G,C){U.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,U.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,U.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,U.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=G.useRightHandedSystem,U.GREASED_LINE_CAMERA_FACING=this._cameraFacing,U.GREASED_LINE_USE_OFFSETS=!!C.offsets}getClassName(){return aU.GREASED_LINE_MATERIAL_NAME}getCustomCode(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(G)?function(U,G){if("vertex"===U){const U={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return G&&(U["!gl_Position\\=viewProjection\\*worldPos;"]="//"),U}return"fragment"===U?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ".concat(0,".) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == ",1,".) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == ",2,".) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == ",0,".) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ",1,".) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ",2,".) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                ")}:null}(U,this._cameraFacing):function(U,G){if("vertex"===U){const U={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return G&&(U["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),U}return"fragment"===U?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ".concat(0,".) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ",1,".) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ",2,".) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == ",0,".) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ",1,".) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ",2,".) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                ")}:null}(U,this._cameraFacing)}dispose(){var U;null===(U=this.colorsTexture)||void 0===U||U.dispose(),super.dispose()}get dU(){return this._colors}set dU(U){this.setColors(U)}setColors(U){var G,C;let L=arguments.length>1&&void 0!==arguments[1]&&arguments[1],X=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const l=null!==(G=null===(C=this._colors)||void 0===C?void 0:C.length)&&void 0!==G?G:0;var t;if(this._colors=U,null!==U&&0!==U.length){if(!L||X)if(this.colorsTexture&&l===U.length&&!X){const G=FU.Color3toRGBAUint8(U);this.colorsTexture.update(G)}else{var E;null===(E=this.colorsTexture)||void 0===E||E.dispose(),this.colorsTexture=FU.CreateColorsTexture("".concat(this._material.name,"-colors-texture"),U,this.colorsSampling,this._scene)}}else null===(t=this.colorsTexture)||void 0===t||t.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(U){this._dashCount=U,this._dashArray=1/U}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(U){this._sizeAttenuation=U,this.markAllDefinesAsDirty()}get color(){return this._color}set color(U){this.setColor(U)}setColor(U){let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==U||null!==this._color&&null===U?(this._color=U,G||this.markAllDefinesAsDirty()):this._color=U}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(U){this._colorsDistributionType=U,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(U){this._aspect=U.x/U.y,this._resolution=U}serialize(){const U=super.serialize(),G={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(G.dU=this._colors),this._color&&(G.color=this._color),U.greasedLineMaterialOptions=G,U}parse(U,G,C){var L;super.parse(U,G,C);const X=U.greasedLineMaterialOptions;null===(L=this.colorsTexture)||void 0===L||L.dispose(),X.color&&this.setColor(X.color,!0),X.colorDistributionType&&(this.colorsDistributionType=X.colorDistributionType),X.dU&&(this.dU=X.dU),X.colorsSampling&&(this.colorsSampling=X.colorsSampling),X.colorMode&&(this.colorMode=X.colorMode),X.useColors&&(this.useColors=X.useColors),X.visibility&&(this.visibility=X.visibility),X.useDash&&(this.useDash=X.useDash),X.dashCount&&(this.dashCount=X.dashCount),X.dashRatio&&(this.dashRatio=X.dashRatio),X.dashOffset&&(this.dashOffset=X.dashOffset),X.width&&(this.width=X.width),X.sizeAttenuation&&(this.sizeAttenuation=X.sizeAttenuation),X.resolution&&(this.resolution=X.resolution),this.dU?this.colorsTexture=FU.CreateColorsTexture("".concat(this._material.name,"-colors-texture"),this.dU,this.colorsSampling,G):FU.PrepareEmptyColorsTexture(G),this.markAllDefinesAsDirty()}copyTo(U){var G;const C=U;null===(G=C.colorsTexture)||void 0===G||G.dispose(),this._colors&&(C.colorsTexture=FU.CreateColorsTexture("".concat(C._material.name,"-colors-texture"),this._colors,C.colorsSampling,this._scene)),C.setColor(this.color,!0),C.colorsDistributionType=this.colorsDistributionType,C.colorsSampling=this.colorsSampling,C.colorMode=this.colorMode,C.useColors=this.useColors,C.visibility=this.visibility,C.useDash=this.useDash,C.dashCount=this.dashCount,C.dashRatio=this.dashRatio,C.dashOffset=this.dashOffset,C.width=this.width,C.sizeAttenuation=this.sizeAttenuation,C.resolution=this.resolution,C.markAllDefinesAsDirty()}_isGLSL(U){return 0===U||this._forceGLSL}}aU.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",aU.ForceGLSL=!1,(0,uU.e)("BABYLON.".concat(aU.GREASED_LINE_MATERIAL_NAME),aU);var kU=C(13285),nU=C(12737),QU=C(13095),mG=C(12831);class BU extends QU.ShaderMaterial{constructor(U,G,X){var l,t,E,K,P,O,T,D,y,V,p,I,x,h;const N=G.getEngine(),b=N.isWebGPU&&!(X.forceGLSL||BU.ForceGLSL),o=["COLOR_DISTRIBUTION_TYPE_LINE ".concat(1,"."),"COLOR_DISTRIBUTION_TYPE_SEGMENT ".concat(0,"."),"COLOR_MODE_SET ".concat(0,"."),"COLOR_MODE_ADD ".concat(1,"."),"COLOR_MODE_MULTIPLY ".concat(2,".")];G.useRightHandedSystem&&o.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const S=["position","grl_widths","grl_offsets","grl_colorPointers"];X.cameraFacing?(o.push("GREASED_LINE_CAMERA_FACING"),S.push("grl_previousAndSide","grl_nextAndCounters")):(S.push("grl_slopes"),S.push("grl_counters"));const v=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];var u;(b||v.push("world","viewProjection","view","projection"),super(U,G,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:b?["Scene","Mesh"]:void 0,attributes:S,uniforms:v,samplers:b?[]:["grlColors"],defines:o,extraInitializationsAsync:async()=>{b?await Promise.all([C.e(66).then(C.bind(C,15578)),C.e(75).then(C.bind(C,15583))]):await Promise.all([C.e(69).then(C.bind(C,15589)),C.e(76).then(C.bind(C,15596))])},shaderLanguage:b?1:0}),this._color=H.hG.White(),this._colorsDistributionType=0,this._colorsTexture=null,X=X||{color:dU.DEFAULT_COLOR},this.visibility=null!==(l=X.visibility)&&void 0!==l?l:1,this.useDash=null!==(t=X.useDash)&&void 0!==t&&t,this.dashRatio=null!==(E=X.dashRatio)&&void 0!==E?E:.5,this.dashOffset=null!==(K=X.dashOffset)&&void 0!==K?K:0,this.dashCount=null!==(P=X.dashCount)&&void 0!==P?P:1,this.width=X.width?X.width:X.sizeAttenuation&&X.cameraFacing?dU.DEFAULT_WIDTH_ATTENUATED:dU.DEFAULT_WIDTH,this.sizeAttenuation=null!==(O=X.sizeAttenuation)&&void 0!==O&&O,this.color=null!==(T=X.color)&&void 0!==T?T:H.hG.White(),this.useColors=null!==(D=X.useColors)&&void 0!==D&&D,this.colorsDistributionType=null!==(y=X.colorDistributionType)&&void 0!==y?y:0,this.colorsSampling=null!==(V=X.colorsSampling)&&void 0!==V?V:w.b.NEAREST_NEAREST,this.colorMode=null!==(p=X.colorMode)&&void 0!==p?p:0,this._colors=null!==(I=X.dU)&&void 0!==I?I:null,this._cameraFacing=null===(x=X.cameraFacing)||void 0===x||x,this.resolution=null!==(h=X.resolution)&&void 0!==h?h:new L.Vector2(N.getRenderWidth(),N.getRenderHeight()),X.colorsTexture)?this.colorsTexture=X.colorsTexture:this._colors?this.colorsTexture=FU.CreateColorsTexture("".concat(this.name,"-colors-texture"),this._colors,this.colorsSampling,G):(this._color=null!==(u=this._color)&&void 0!==u?u:dU.DEFAULT_COLOR,this.colorsTexture=FU.PrepareEmptyColorsTexture(G));if(b){const U=new mG.e;U.setParameters(),U.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",U)}N.aE.add((()=>{FU.DisposeEmptyColorsTexture()}))}dispose(){var U;null===(U=this._colorsTexture)||void 0===U||U.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new L.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dU(){return this._colors}set dU(U){this.setColors(U)}setColors(U){var G,C;let L=arguments.length>1&&void 0!==arguments[1]&&arguments[1],X=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const l=null!==(G=null===(C=this._colors)||void 0===C?void 0:C.length)&&void 0!==G?G:0;var t;if(this._colors=U,null!==U&&0!==U.length){if(!L||X)if(this._colorsTexture&&l===U.length&&!X){const G=FU.Color3toRGBAUint8(U);this._colorsTexture.update(G)}else{var E;null===(E=this._colorsTexture)||void 0===E||E.dispose(),this.colorsTexture=FU.CreateColorsTexture("".concat(this.name,"-colors-texture"),U,this.colorsSampling,this.wU())}}else null===(t=this._colorsTexture)||void 0===t||t.dispose()}get colorsTexture(){var U;return null!==(U=this._colorsTexture)&&void 0!==U?U:null}set colorsTexture(U){this._colorsTexture=U,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(U){this._width=U,this.setFloat("grlWidth",U)}get useColors(){return this._useColors}set useColors(U){this._useColors=U,this.setFloat("grlUseColors",FU.BooleanToNumber(U))}get colorsSampling(){return this._colorsSampling}set colorsSampling(U){this._colorsSampling=U}get visibility(){return this._visibility}set visibility(U){this._visibility=U,this.setFloat("grlVisibility",U)}get useDash(){return this._useDash}set useDash(U){this._useDash=U,this.setFloat("grlUseDash",FU.BooleanToNumber(U))}get dashOffset(){return this._dashOffset}set dashOffset(U){this._dashOffset=U,this.setFloat("grlDashOffset",U)}get dashRatio(){return this._dashRatio}set dashRatio(U){this._dashRatio=U,this.setFloat("grlDashRatio",U)}get dashCount(){return this._dashCount}set dashCount(U){this._dashCount=U,this._dashArray=1/U,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(U){this._sizeAttenuation=U,this.setFloat("grlSizeAttenuation",FU.BooleanToNumber(U))}get color(){return this._color}set color(U){this.setColor(U)}setColor(U){var G;U=null!==(G=U)&&void 0!==G?G:dU.DEFAULT_COLOR,this._color=U,this.setColor3("grlColor",U)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(U){this._colorsDistributionType=U,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(U){this._colorMode=U,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(U){this._resolution=U,this.setVector2("grlResolution",U),this.setFloat("grlAspect",U.x/U.y)}serialize(){const U=super.serialize(),G={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(G.dU=this._colors),U.greasedLineMaterialOptions=G,U}parse(U,G,C){var L,X;const l=U.greasedLineMaterialOptions;null===(L=this._colorsTexture)||void 0===L||L.dispose(),l.color&&(this.color=l.color),l.colorDistributionType&&(this.colorsDistributionType=l.colorDistributionType),l.colorsSampling&&(this.colorsSampling=l.colorsSampling),l.colorMode&&(this.colorMode=l.colorMode),l.useColors&&(this.useColors=l.useColors),l.visibility&&(this.visibility=l.visibility),l.useDash&&(this.useDash=l.useDash),l.dashCount&&(this.dashCount=l.dashCount),l.dashRatio&&(this.dashRatio=l.dashRatio),l.dashOffset&&(this.dashOffset=l.dashOffset),l.width&&(this.width=l.width),l.sizeAttenuation&&(this.sizeAttenuation=l.sizeAttenuation),l.resolution&&(this.resolution=l.resolution),l.dU?this.colorsTexture=FU.CreateColorsTexture("".concat(this.name,"-colors-texture"),l.dU,this.colorsSampling,this.wU()):this.colorsTexture=FU.PrepareEmptyColorsTexture(G),this._cameraFacing=null===(X=l.cameraFacing)||void 0===X||X,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var MU,zU,sU;BU.ForceGLSL=!1,function(U){U[U.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",U[U.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(MU||(MU={})),function(U){U[U.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",U[U.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",U[U.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(zU||(zU={})),function(U){U[U.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",U[U.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",U[U.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",U[U.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",U[U.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(sU||(sU={}));class jU extends hU.d{constructor(U,G,C){var L,X,l,t;super(U,G,null,null,!1,!1),this.name=U,this._options=C,this._lazy=!1,this._updatable=!1,this._engine=G.getEngine(),this._lazy=null!==(L=C.lazy)&&void 0!==L&&L,this._updatable=null!==(X=C.updatable)&&void 0!==X&&X,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=null!==(l=C.colorPointers)&&void 0!==l?l:[],this._widths=null!==(t=C.widths)&&void 0!==t?t:new Array(C.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(U){let G=0;for(const L of this._points)G+=L.length;const C=G/3*2-this._widths.length;for(let L=0;L<C;L++)this._widths.push(U)}updateLazy(){var U,G;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(U=this._options.ribbonOptions)||void 0===U?void 0:U.smoothShading),!this.qU&&this.refreshBoundingInfo(),null===(G=this.greasedLineMaterial)||void 0===G||G.updateLazy()}addPoints(U,G){for(const C of U)this._points.push(C);this._lazy||this.setPoints(this._points,G)}dispose(U){let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(U,G)}isLazy(){return this._lazy}get gU(){return this._uvs}set gU(U){this._uvs=U instanceof Float32Array?U:new Float32Array(U),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(U){this.material instanceof BU&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===U||void 0===U?void 0:U.length)>0),this._offsets=U,this._offsetsBuffer?this._offsetsBuffer.update(U):this._createOffsetsBuffer(U)}get widths(){return this._widths}set widths(U){this._widths=U,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(U)}get colorPointers(){return this._colorPointers}set colorPointers(U){this._colorPointers=U,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(U)}get greasedLineMaterial(){var U,G;if(this.material&&this.material instanceof BU)return this.material;const C=null===(U=this.material)||void 0===U||null===(G=U.pluginManager)||void 0===G?void 0:G.getPlugin(aU.GREASED_LINE_MATERIAL_NAME);return C||void 0}get points(){const U=[];return nU.b.DeepCopy(this._points,U),U}setPoints(U,G){var C;this._points=FU.ConvertPoints(U,null!==(C=null===G||void 0===G?void 0:G.pointsOptions)&&void 0!==C?C:this._options.pointsOptions),this._updateWidths(),null!==G&&void 0!==G&&G.colorPointers||this._updateColorPointers(),this._setPoints(this._points,G)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,gU:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(U){super.serialize(U),U.type=this.getClassName(),U.lineOptions=this._createLineOptions()}_createVertexBuffers(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const G=new kU.e;return G.vU=this._vertexPositions,G.indices=this._indices,G.gU=this._uvs,U&&(G.uU=[],kU.e.ComputeNormals(this._vertexPositions,this._indices,G.uU)),G.FU(this,this._options.updatable),G}_createOffsetsBuffer(U){const G=this._scene.getEngine(),C=new T.d(G,U,this._updatable,3);this.setVerticesBuffer(C.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=C}}class AU{constructor(U,G){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=U,this.wasAddedByNoopNode=G}getIndicesAccessor(U,G,C,L,X){var l,t,E,K;return null===(l=this._indicesAccessorMap.get(U))||void 0===l||null===(t=l.get(G))||void 0===t||null===(E=t.get(C))||void 0===E||null===(K=E.get(L))||void 0===K?void 0:K.get(X)}setIndicesAccessor(U,G,C,L,X,l){let t=this._indicesAccessorMap.get(U);t||(t=new Map,this._indicesAccessorMap.set(U,t));let E=t.get(G);E||(E=new Map,t.set(G,E));let K=E.get(C);K||(K=new Map,E.set(C,K));let P=K.get(L);P||(P=new Map,K.set(L,P)),P.set(X,l)}pushExportedNode(U){this._exportedNodes.has(U)||this._exportedNodes.add(U)}getNodesSet(){return this._exportedNodes}getVertexBufferView(U){return this._vertexBufferViewMap.get(U)}setVertexBufferView(U,G){this._vertexBufferViewMap.set(U,G)}setRemappedBufferView(U,G,C){this._remappedBufferView.set(U,new Map),this._remappedBufferView.get(U).set(G,C)}getRemappedBufferView(U,G){var C;return null===(C=this._remappedBufferView.get(U))||void 0===C?void 0:C.get(G)}getVertexAccessor(U,G,C){var L,X;return null===(L=this._vertexAccessorMap.get(U))||void 0===L||null===(X=L.get(G))||void 0===X?void 0:X.get(C)}setVertexAccessor(U,G,C,L){let X=this._vertexAccessorMap.get(U);X||(X=new Map,this._vertexAccessorMap.set(U,X));let l=X.get(G);l||(l=new Map,X.set(G,l)),l.set(C,L)}hasVertexColorAlpha(U){return this._vertexMapColorAlpha.get(U)||!1}setHasVertexColorAlpha(U,G){return this._vertexMapColorAlpha.set(U,G)}getMesh(U){return this._meshMap.get(U)}setMesh(U,G){this._meshMap.set(U,G)}bindMorphDataToMesh(U,G){const C=this._meshMorphTargetMap.get(U)||[];this._meshMorphTargetMap.set(U,C),-1===C.indexOf(G)&&C.push(G)}getMorphTargetsFromMesh(U){return this._meshMorphTargetMap.get(U)}}class YU{_ApplyExtension(U,G,C,L){if(C>=G.length)return Promise.resolve(U);const X=L(G[C],U);return X?X.then((async U=>U?await this._ApplyExtension(U,G,C+1,L):null)):this._ApplyExtension(U,G,C+1,L)}_ApplyExtensions(U,G){const C=[];for(const L of YU._ExtensionNames)C.push(this._extensions[L]);return this._ApplyExtension(U,C,0,G)}_extensionsPreExportTextureAsync(U,G,C){return this._ApplyExtensions(G,((G,L)=>G.preExportTextureAsync&&G.preExportTextureAsync(U,L,C)))}_extensionsPostExportNodeAsync(U,G,C,L,X){return this._ApplyExtensions(G,((G,l)=>G.postExportNodeAsync&&G.postExportNodeAsync(U,l,C,L,X,this._bufferManager)))}_extensionsPostExportMaterialAsync(U,G,C){return this._ApplyExtensions(G,((G,L)=>G.postExportMaterialAsync&&G.postExportMaterialAsync(U,L,C)))}_extensionsPostExportMaterialAdditionalTextures(U,G,C){const L=[];for(const X of YU._ExtensionNames){const l=this._extensions[X];l.postExportMaterialAdditionalTextures&&L.push(...l.postExportMaterialAdditionalTextures(U,G,C))}return L}_extensionsPostExportTextures(U,G,C){for(const L of YU._ExtensionNames){const X=this._extensions[L];X.postExportTexture&&X.postExportTexture(U,G,C)}}_extensionsPostExportMeshPrimitive(U){for(const G of YU._ExtensionNames){const C=this._extensions[G];C.postExportMeshPrimitive&&C.postExportMeshPrimitive(U,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const U of YU._ExtensionNames){const G=this._extensions[U];G.preGenerateBinaryAsync&&await G.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(U){for(const G of YU._ExtensionNames){const C=this._extensions[G];C.enabled&&U(C)}}_extensionsOnExporting(){this._forEachExtensions((U=>{var G,C,L;U.wasUsed&&((G=this._glTF).extensionsUsed||(G.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(U.name)&&this._glTF.extensionsUsed.push(U.name),U.required&&((C=this._glTF).extensionsRequired||(C.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(U.name)&&this._glTF.extensionsRequired.push(U.name)),(L=this._glTF).extensions||(L.extensions={}),U.onExporting&&U.onExporting())}))}_loadExtensions(){for(const U of YU._ExtensionNames){const G=YU._ExtensionFactories[U](this);this._extensions[U]=G}}constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:I.d.LastCreatedScene,G=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:"Babylon.js v".concat(p.d.Version),version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new mU(this),this._extensions={},this._bufferManager=new TU,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!U)throw new Error("No scene available to export");this._babylonScene=U,this._options=(0,O.b)({shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:U=>{var G;return null===U||void 0===U||null===(G=U.mK)||void 0===G?void 0:G.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None"},G),this._loadExtensions()}dispose(){for(const U in this._extensions){this._extensions[U].dispose()}}get options(){return this._options}static RegisterExtension(U,G){YU.UnregisterExtension(U)&&X.Tools.Warn("Extension with the name ".concat(U," already exists")),YU._ExtensionFactories[U]=G,YU._ExtensionNames.push(U)}static UnregisterExtension(U){if(!YU._ExtensionFactories[U])return!1;delete YU._ExtensionFactories[U];const G=YU._ExtensionNames.indexOf(U);return-1!==G&&YU._ExtensionNames.splice(G,1),!0}_generateJSON(U,G,C){const L={byteLength:U};return L.byteLength&&(this._glTF.buffers=[L]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.HG=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(L.uri=G+".bin"),C?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(U){const G=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(G.byteLength,U,!0),L=new Blob([G],{type:"application/octet-stream"}),X=U+".gltf",l=U+".bin",t=new P;if(t.files[X]=C,t.files[l]=L,this._imageData)for(const E in this._imageData)t.files[E]=new Blob([this._imageData[E].data],{type:this._imageData[E].mimeType});return t}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(U){const G=U%4;return 0===G?G:4-G}async generateGLBAsync(U){this._shouldUseGlb=!0;const G=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(G.byteLength),L=U+".glb";let X,l=C.length;if("undefined"!==typeof TextEncoder){X=(new TextEncoder).encode(C),l=X.length}const t=this._getPadding(l),E=this._getPadding(G.byteLength),K=28+l+t+G.byteLength+E,O=new PU(K);if(O.writeUInt32(1179937895),O.writeUInt32(2),O.writeUInt32(K),O.writeUInt32(l+t),O.writeUInt32(1313821514),X)O.writeTypedArray(X);else{const U="_".charCodeAt(0);for(let G=0;G<l;++G){const L=C.charCodeAt(G);L!=C.codePointAt(G)?O.writeUInt8(U):O.writeUInt8(L)}}for(let P=0;P<t;++P)O.writeUInt8(32);O.writeUInt32(G.byteLength+E),O.writeUInt32(5130562),O.writeTypedArray(G);for(let P=0;P<E;++P)O.writeUInt8(0);const T=new P;return T.files[L]=new Blob([O.getOutputData()],{type:"application/octet-stream"}),T}_setNodeTransformation(U,G,C){if(G.getPivotPoint().equalsWithEpsilon(j,s.d)||X.Tools.Warn("Pivot points are not supported in the glTF serializer"),!G.position.equalsWithEpsilon(j,s.d)){const X=L.TmpVectors.pG[0].L(G.position);C&&r(X),U.translation=X.sE()}G.fE.equalsWithEpsilon(Y,s.d)||(U.scale=G.fE.sE());const l=G.rotationQuaternion||L.Quaternion.FromEulerAngles(G.rotation.x,G.rotation.y,G.rotation.z);l.equalsWithEpsilon(A,s.d)||(C&&J(l),U.rotation=l.normalize().sE())}_setCameraTransformation(U,G,C){if(!G.position.equalsWithEpsilon(j,s.d)){const X=L.TmpVectors.pG[0].L(G.position);C&&r(X),U.translation=X.sE()}const X=G.rotationQuaternion||L.Quaternion.FromEulerAngles(G.rotation.x,G.rotation.y,G.rotation.z);C&&J(X),this._babylonScene.useRightHandedSystem||UU(X),X.equalsWithEpsilon(A,s.d)||(U.rotation=X.sE())}_listAvailableCameras(){for(const U of this._babylonScene.cameras){const G={type:U.mode===yU.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(U.name&&(G.name=U.name),"perspective"===G.type)G.perspective={aspectRatio:U.getEngine().getAspectRatio(U),yfov:U.fovMode===yU.d.FOVMODE_VERTICAL_FIXED?U.fov:U.fov*U.getEngine().getAspectRatio(U),znear:U.AE,zfar:U.maxZ};else if("orthographic"===G.type){const C=U.orthoLeft&&U.orthoRight?.5*(U.orthoRight-U.orthoLeft):.5*U.getEngine().getRenderWidth(),L=U.orthoBottom&&U.orthoTop?.5*(U.orthoTop-U.orthoBottom):.5*U.getEngine().getRenderHeight();G.orthographic={xmag:C,ymag:L,znear:U.AE,zfar:U.maxZ}}this._camerasMap.set(U,G)}}_exportAndAssignCameras(){const U=Array.from(this._camerasMap.values());for(const G of U){const U=this._nodesCameraMap.get(G);if(void 0!==U){this._cameras.push(G);for(const G of U)G.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const U of this._babylonScene.skeletons){if(U.bones.length<=0)continue;const G={joints:[]};this._skinMap.set(U,G)}}_exportAndAssignSkeletons(){for(const G of this._babylonScene.skeletons){if(G.bones.length<=0)continue;const C=this._skinMap.get(G);if(void 0==C)continue;const L={},l=[];let t=-1;for(let X=0;X<G.bones.length;++X){var U;const C=G.bones[X],l=null!==(U=C.getIndex())&&void 0!==U?U:X;-1!==l&&(L[l]=C,l>t&&(t=l))}for(let U=0;U<=t;++U){const G=L[U];l.push(G.getAbsoluteInverseBindMatrix());const t=G.getTransformNode();if(null!==t){const U=this._nodeMap.get(t);t&&null!==U&&void 0!==U?C.joints.push(U):X.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else X.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const E=this._nodesSkinMap.get(C);if(C.joints.length>0&&void 0!==E){const U=64*l.length,G=new Float32Array(U/4);l.forEach(((U,C)=>{G.set(U.m,16*C)}));const L=this._bufferManager.createBufferView(G);this._accessors.push(this._bufferManager.createAccessor(L,"MAT4",5126,l.length)),C.inverseBindMatrices=this._accessors.length-1,this._skins.push(C);for(const C of E)C.skin=this._skins.length-1}}}async _exportSceneAsync(){const U={nodes:[]};if(this._babylonScene.metadata){const G=this._options.metadataSelector(this._babylonScene.metadata);G&&(U.extras=G)}const G=new Array,C=new Array,L=new Array;for(const E of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&EU(E,this._babylonScene.useRightHandedSystem)?L.push(...E.getChildren()):this._babylonScene.useRightHandedSystem?G.push(E):C.push(E);this._listAvailableCameras(),this._listAvailableSkeletons();const X=new AU(!0,!1);U.nodes.push(...await this._exportNodesAsync(C,X));const l=new AU(!1,!1);U.nodes.push(...await this._exportNodesAsync(G,l));const t=new AU(!1,!0);U.nodes.push(...await this._exportNodesAsync(L,t)),U.nodes.length&&this._scenes.push(U),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&bU._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,X.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(U){let G=this._shouldExportNodeMap.get(U);return void 0===G&&(G=this._options.shouldExportNode(U),this._shouldExportNodeMap.set(U,G)),G}async _exportNodesAsync(U,G){const C=new Array;this._exportBuffers(U,G);for(const L of U)await this._exportNodeAsync(L,C,G);return C}_collectBuffers(U,G,C,L,X){if(this._shouldExportNode(U)&&U instanceof y.c&&U.iE){const l=U.iE.getVertexBuffers();if(l)for(const L in l){if(!R(L))continue;const t=l[L];X.setHasVertexColorAlpha(t,U.hasVertexAlpha);const E=t._buffer,K=G.get(E)||[];G.set(E,K),-1===K.indexOf(t)&&K.push(t);const P=C.get(t)||[];C.set(t,P),-1===P.indexOf(U)&&P.push(U)}const t=U.morphTargetManager;if(t)for(let G=0;G<t.numTargets;G++){const C=t.getTarget(G),X=L.get(C)||[];L.set(C,X),-1===X.indexOf(U)&&X.push(U)}}for(const l of U.getChildren())this._collectBuffers(l,G,C,L,X)}_exportBuffers(U,G){const C=new Map,L=new Map,X=new Map;for(const E of U)this._collectBuffers(E,C,L,X,G);const l=Array.from(C.keys());for(const E of l){const U=E.getData();if(!U)throw new Error("Buffer data is not available");const X=C.get(E);if(!X)continue;const l=X[0].byteStride;if(X.some((U=>U.byteStride!==l)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const t=LU(U).slice();for(const G of X){const U=L.get(G),{byteOffset:C,byteStride:X,componentCount:l,type:E,count:K,normalized:P,kind:O}=i(G,U);switch(O){case T.e.NormalKind:case T.e.TangentKind:(0,B.h)(t,C,X,l,E,K,P,(U=>{const G=Math.sqrt(U[0]*U[0]+U[1]*U[1]+U[2]*U[2]);if(G>0){const C=1/G;U[0]*=C,U[1]*=C,U[2]*=C}}));break;case T.e.ColorKind:{const G=U.filter((U=>U.material instanceof IU.xG||null==U.material)).length;if(0==G)break;if(G!=U.length){M.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}E==T.e.UNSIGNED_BYTE&&M.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const L=new H.hG,O=new H.JE,D=this._babylonScene.getEngine().useExactSrgbConversions;(0,B.h)(t,C,X,l,E,K,P,(U=>{3===U.length?(L.xC(U,0),L.toLinearSpaceToRef(L,D),L.toArray(U,0)):(O.xC(U,0),O.toLinearSpaceToRef(O,D),O.toArray(U,0))}))}}}if(G.convertToRightHanded){for(const U of X){const G=L.get(U),{byteOffset:C,byteStride:X,componentCount:l,type:E,count:K,normalized:P,kind:O}=i(U,G);switch(O){case T.e.PositionKind:case T.e.NormalKind:case T.e.TangentKind:(0,B.h)(t,C,X,l,E,K,P,(U=>{U[0]=-U[0]}))}}G.convertedToRightHandedBuffers.set(E,t)}const K=this._bufferManager.createBufferView(t,l);G.setVertexBufferView(E,K);const P=new Map;for(const G of X){const U=L.get(G),{kind:C,totalVertices:X}=i(G,U);switch(C){case T.e.MatricesIndicesKind:case T.e.MatricesIndicesExtraKind:if(G.type==T.e.FLOAT){const U=G.getFloatData(X);null!==U&&P.set(G,U)}}}0!==P.size&&M.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const O=Array.from(P.keys());for(const C of O){const U=P.get(C);if(!U)continue;const L=U.some((U=>U>=256)),X=new(L?Uint16Array:Uint8Array)(U.length);for(let G=0;G<U.length;G++)X[G]=U[G];const l=this._bufferManager.createBufferView(X,4*(L?2:1));G.setRemappedBufferView(E,C,l)}}const t=Array.from(X.keys());for(const E of t){const U=X.get(E);if(!U)continue;const C=oU(E,U[0],this._bufferManager,this._bufferViews,this._accessors,G.convertToRightHanded);for(const L of U)G.bindMorphDataToMesh(L,C)}}async _exportNodeAsync(U,G,C){let L=this._nodeMap.get(U);if(void 0!==L)return void(G.includes(L)||G.push(L));const X=await this._createNodeAsync(U,C);if(X){L=this._nodes.length,this._nodes.push(X),this._nodeMap.set(U,L),C.pushExportedNode(U),G.push(L);const l={name:"runtime animations",channels:[],samplers:[]},t=[];this._babylonScene.animationGroups.length||(bU._CreateMorphTargetAnimationFromMorphTargetAnimations(U,l,t,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation),U.animations.length&&bU._CreateNodeAnimationFromNodeAnimations(U,l,t,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation)),l.channels.length&&l.samplers.length&&this._animations.push(l),t.forEach((U=>{U.channels.length&&U.samplers.length&&this._animations.push(U)}))}const l=X?[]:G;for(const t of U.getChildren())await this._exportNodeAsync(t,l,C);X&&l.length&&(X.children=l)}async _createNodeAsync(U,G){if(!this._shouldExportNode(U))return null;const C={};if(U.name&&(C.name=U.name),U.metadata){const G=this._options.metadataSelector(U.metadata);G&&(C.extras=G)}if(U instanceof D.b&&(this._setNodeTransformation(C,U,G.convertToRightHanded),U instanceof y.c)){const X=U instanceof V.c?U.sourceMesh:U;if(X.zE&&X.zE.length>0&&(C.mesh=await this._exportMeshAsync(X,G)),U.skeleton){const G=this._skinMap.get(U.skeleton);var L;if(void 0!==G)void 0===this._nodesSkinMap.get(G)&&this._nodesSkinMap.set(G,[]),null===(L=this._nodesSkinMap.get(G))||void 0===L||L.push(C)}}if(U instanceof z.b){const L=this._camerasMap.get(U);if(L){var X;void 0===this._nodesCameraMap.get(L)&&this._nodesCameraMap.set(L,[]),this._setCameraTransformation(C,U,G.convertToRightHanded);const t=U.parent;if(null!==t&&CU(U,t)){const U=this._nodeMap.get(t);if(void 0!==U){var l;const G=this._nodes[U];return GU(C,G),null===(l=this._nodesCameraMap.get(L))||void 0===l||l.push(G),null}}null===(X=this._nodesCameraMap.get(L))||void 0===X||X.push(C)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",C,U,this._nodeMap,G.convertToRightHanded)?C:(M.d.Warn("Not exporting node ".concat(U.name)),null)}_exportIndices(U,G,C,L,X,t,E,K,P){let O=U;P.mode=W(t);const T=E!==l.c.CounterClockWiseSideOrientation,D=!K.wasAddedByNoopNode&&T,y=function(U){switch(U){case l.c.TriangleFillMode:case l.c.TriangleStripDrawMode:case l.c.TriangleFanDrawMode:return!0}return!1}(t)&&D;if(y){if(t===l.c.TriangleStripDrawMode||t===l.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");P.mode=W(t);const E=G?new Uint32Array(L):new Uint16Array(L);if(U)for(let G=0;G+2<L;G+=3)E[G]=U[C+G]+X,E[G+1]=U[C+G+2]+X,E[G+2]=U[C+G+1]+X;else for(let U=0;U+2<L;U+=3)E[U]=U,E[U+1]=U+2,E[U+2]=U+1;O=E}else if(U&&0!==X){const l=G?new Uint32Array(L):new Uint16Array(L);for(let G=0;G<L;G++)l[G]=U[C+G]+X;O=l}if(O){let l=K.getIndicesAccessor(U,C,L,X,y);if(void 0===l){const t=function(U,G,C,L){if(U instanceof Uint16Array||U instanceof Uint32Array)return U;if(U instanceof Int32Array)return new Uint32Array(U.buffer,U.byteOffset,U.length);const X=U.slice(G,G+C);return L?new Uint32Array(X):new Uint16Array(X)}(O,0,L,G),E=this._bufferManager.createBufferView(t),P=G?5125:5123;this._accessors.push(this._bufferManager.createAccessor(E,"SCALAR",P,L,0)),l=this._accessors.length-1,K.setIndicesAccessor(U,C,L,X,y,l)}P.indices=l}}_exportVertexBuffer(U,G,C,L,X,l){const t=U.getKind();if(!R(t))return;if(t.startsWith("uv")&&!this._options.exportUnusedUVs&&(!G||!this._materialNeedsUVsSet.has(G)))return;let E=X.getVertexAccessor(U,C,L);if(void 0===E){const G=X.convertedToRightHandedBuffers.get(U._buffer)||U._buffer.getData(),l=t===T.e.PositionKind?function(U,G,C,L){const{byteOffset:X,byteStride:l,type:t,normalized:E}=G,K=G.getSize(),P=new Array(K).fill(1/0),O=new Array(K).fill(-1/0);return(0,B.h)(U,X+C*l,l,K,t,L*K,E,(U=>{for(let G=0;G<K;G++)P[G]=Math.min(P[G],U[G]),O[G]=Math.max(O[G],U[G])})),{min:P,max:O}}(G,U,C,L):void 0,K=(t===T.e.MatricesIndicesKind||t===T.e.MatricesIndicesExtraKind)&&U.type===T.e.FLOAT,P=K?T.e.UNSIGNED_BYTE:U.type,O=K?void 0:U.normalized,D=K?X.getRemappedBufferView(U._buffer,U):X.getVertexBufferView(U._buffer),y=U.byteOffset+C*U.byteStride;this._accessors.push(this._bufferManager.createAccessor(D,function(U,G){if(U==T.e.ColorKind)return G?"VEC4":"VEC3";switch(U){case T.e.PositionKind:case T.e.NormalKind:return"VEC3";case T.e.TangentKind:case T.e.MatricesIndicesKind:case T.e.MatricesIndicesExtraKind:case T.e.MatricesWeightsKind:case T.e.MatricesWeightsExtraKind:return"VEC4";case T.e.UVKind:case T.e.UV2Kind:case T.e.UV3Kind:case T.e.UV4Kind:case T.e.UV5Kind:case T.e.UV6Kind:return"VEC2"}throw new Error("Unknown kind ".concat(U))}(t,X.hasVertexColorAlpha(U)),P,L,y,l,O)),E=this._accessors.length-1,X.setVertexAccessor(U,C,L,E)}l.attributes[function(U){switch(U){case T.e.PositionKind:return"POSITION";case T.e.NormalKind:return"NORMAL";case T.e.TangentKind:return"TANGENT";case T.e.ColorKind:return"COLOR_0";case T.e.UVKind:return"TEXCOORD_0";case T.e.UV2Kind:return"TEXCOORD_1";case T.e.UV3Kind:return"TEXCOORD_2";case T.e.UV4Kind:return"TEXCOORD_3";case T.e.UV5Kind:return"TEXCOORD_4";case T.e.UV6Kind:return"TEXCOORD_5";case T.e.MatricesIndicesKind:return"JOINTS_0";case T.e.MatricesIndicesExtraKind:return"JOINTS_1";case T.e.MatricesWeightsKind:return"WEIGHTS_0";case T.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error("Unknown kind: ".concat(U))}(t)]=E}async _exportMaterialAsync(U,G,C,L){let X=this._materialMap.get(U);if(void 0===X){const L=G&&Object.keys(G).some((U=>U.startsWith("uv")));if((U=U instanceof VU.e?U.UK[C.materialIndex]:U)instanceof pU.c)X=await this._materialExporter.exportPBRMaterialAsync(U,"image/png",L);else{if(!(U instanceof IU.xG))return void M.d.Warn("Unsupported material '".concat(U.name,"' with type ").concat(U.getClassName()));X=await this._materialExporter.exportStandardMaterialAsync(U,"image/png",L)}this._materialMap.set(U,X)}L.material=X}async _exportMeshAsync(U,G){var C;let L=G.getMesh(U);if(void 0!==L)return L;const X={primitives:[]};L=this._meshes.length,this._meshes.push(X),G.setMesh(U,L);const t=U.isUnIndexed?null:U.cE(),E=null===(C=U.iE)||void 0===C?void 0:C.getVertexBuffers(),K=G.getMorphTargetsFromMesh(U),P=U instanceof wU.b,O=U instanceof jU,T=U.zE;if(E&&T&&T.length>0)for(const x of T){var D;const C={attributes:{}},L=x.QU()||this._babylonScene.defaultMaterial;if(O){var y,V,p,I;const G={name:L.name},X=U,l=H.hG.White(),t=null!==(y=null===(V=X.material)||void 0===V?void 0:V.alpha)&&void 0!==y?y:1,E=null!==(p=null===(I=X.greasedLineMaterial)||void 0===I?void 0:I.color)&&void 0!==p?p:l;(!E.equalsWithEpsilon(l,s.d)||t<1)&&(G.pbrMetallicRoughness={baseColorFactor:[...E.sE(),t]}),this._materials.push(G),C.material=this._materials.length-1}else if(P){const G={name:L.name},X=U;(!X.color.equalsWithEpsilon(H.hG.White(),s.d)||X.alpha<1)&&(G.pbrMetallicRoughness={baseColorFactor:[...X.color.sE(),X.alpha]}),this._materials.push(G),C.material=this._materials.length-1}else await this._exportMaterialAsync(L,E,x,C);const T=P||O?l.c.LineListDrawMode:null!==(D=U.overrideRenderingFillMode)&&void 0!==D?D:L.fillMode,h=L._getEffectiveOrientation(U);this._exportIndices(t,t?(0,B.b)(t,x.indexCount,x.indexStart,x.verticesStart):x.verticesCount>65535,t?x.indexStart:x.verticesStart,t?x.indexCount:x.verticesCount,-x.verticesStart,T,h,G,C);for(const U of Object.values(E))this._exportVertexBuffer(U,L,x.verticesStart,x.verticesCount,G,C);if(K){C.targets=[];for(const U of K)C.targets.push(U.attributes)}X.primitives.push(C),this._extensionsPostExportMeshPrimitive(C)}if(K){X.weights=[],X.extras||(X.extras={}),X.extras.targetNames=[];for(const U of K)X.weights.push(U.influence),X.extras.targetNames.push(U.name)}return L}}YU._ExtensionNames=new Array,YU._ExtensionFactories={};class eU{static async GLTFAsync(U,G,C){C&&C.exportWithoutWaitingForScene||await U.whenReadyAsync();const L=new YU(U,C),X=await L.generateGLTFAsync(G.replace(/\.[^/.]+$/,""));return L.dispose(),X}static async GLBAsync(U,G,C){C&&C.exportWithoutWaitingForScene||await U.whenReadyAsync();const L=new YU(U,C),X=await L.generateGLBAsync(G.replace(/\.[^/.]+$/,""));return L.dispose(),X}}C(13439);const iU="EXT_mesh_gpu_instancing";class cU{constructor(U){this.name=iU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(U,G,C,X,l,t){return await new Promise((U=>{if(G&&C instanceof hU.d&&C.hasThinInstances&&this._exporter){this._wasUsed=!0;const U=L.pG.Zero(),X=L.Quaternion.Identity(),E=L.pG.One(),K=C.thinInstanceGetWorldMatrices(),P=L.TmpVectors.pG[2],O=L.TmpVectors.Quaternion[1],T=L.TmpVectors.pG[3];let D=!1,y=!1,V=!1;const p=new Float32Array(3*C.GK),I=new Float32Array(4*C.GK),H=new Float32Array(3*C.GK);let x=0;for(const G of K)G.decompose(T,O,P),l&&(r(P),J(O)),p.set(P.sE(),3*x),I.set(O.normalize().sE(),4*x),H.set(T.sE(),3*x),D=D||!P.equalsWithEpsilon(U),y=y||!O.equalsWithEpsilon(X),V=V||!T.equalsWithEpsilon(E),x++;const h={attributes:{}};D&&(h.attributes.TRANSLATION=this._buildAccessor(p,"VEC3",C.GK,t)),y&&(h.attributes.ROTATION=this._buildAccessor(I,"VEC4",C.GK,t)),V&&(h.attributes.SCALE=this._buildAccessor(H,"VEC3",C.GK,t)),G.extensions=G.extensions||{},G.extensions[iU]=h}U(G)}))}_buildAccessor(U,G,C,L){const X=L.createBufferView(U),l=L.createAccessor(X,G,5126,C);return this._exporter._accessors.push(l),this._exporter._accessors.length-1}}YU.RegisterExtension(iU,(U=>new cU(U)));var RU=C(13445),WU=C(13456),fU=C(13462),rU=C(13465);function JU(U){return U===fU.d.PositionKind?"POSITION":U===fU.d.NormalKind?"NORMAL":U===fU.d.ColorKind?"COLOR":U.startsWith(fU.d.UVKind)?"TEX_COORD":"GENERIC"}const UG={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class GG extends RU.b{static get DefaultAvailable(){return(0,RU.g)(GG.DefaultConfiguration)}static get Default(){var U;return null!==(U=GG._Default)&&void 0!==U||(GG._Default=new GG),GG._Default}static ResetDefault(U){GG._Default&&(U||GG._Default.dispose(),GG._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(U,G){return{module:await(G||DracoEncoderModule)({wasmBinary:U})}}_getWorkerContent(){return"".concat(WU.k,"(").concat(WU.n,")()")}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:GG.DefaultConfiguration)}async _encodeAsync(U,G,C){const L=C?(0,rU.b)(UG,C):UG;if(this._workerPoolPromise){const C=await this._workerPoolPromise;return await new Promise(((X,l)=>{C.push(((C,t)=>{const E=U=>{C.removeEventListener("error",E),C.removeEventListener("message",K),l(U),t()},K=U=>{"encodeMeshDone"===U.data.id&&(C.removeEventListener("error",E),C.removeEventListener("message",K),X(U.data.encodedMeshData),t())};C.addEventListener("error",E),C.addEventListener("message",K);const P=[];for(const G of U)P.push(G.data.buffer);G&&P.push(G.buffer),C.postMessage({id:"encodeMesh",attributes:U,indices:G,options:L},P)}))}))}if(this._modulePromise){const C=await this._modulePromise;return(0,WU.k)(C.module,U,G,L)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(U,G){if(0==U.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");U instanceof hU.d&&U.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===G||void 0===G?void 0:G.method)&&(M.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),G.method="MESH_SEQUENTIAL_ENCODING");const C=function(U){let G=U.cE(void 0,!0);return!G||G instanceof Uint32Array||G instanceof Uint16Array||(G=((0,B.b)(G,G.length)?Uint32Array:Uint16Array).from(G)),G}(U),L=function(U,G){const C=[];for(const L of U.getVerticesDataKinds()){if(null!==G&&void 0!==G&&G.includes(L)){if(L===fU.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const X=U.getVertexBuffer(L),l=X.getSize(),t=(0,B.q)(X.getData(),l,X.type,X.byteOffset,X.byteStride,X.normalized,U.getTotalVertices(),!0);C.push({kind:L,dracoName:JU(L),size:l,data:t})}return C}(U,null===G||void 0===G?void 0:G.excludedAttributes);return await this._encodeAsync(L,C,G)}}GG.DefaultConfiguration={wasmUrl:"".concat(X.Tools._DefaultCdnUrl,"/draco_encoder_wasm_wrapper.js"),wasmBinaryUrl:"".concat(X.Tools._DefaultCdnUrl,"/draco_encoder.wasm"),fallbackUrl:"".concat(X.Tools._DefaultCdnUrl,"/draco_encoder.js")},GG._Default=null;const CG="KHR_draco_mesh_compression";class LG{get wasUsed(){return this._wasUsed}constructor(U){this.name=CG,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===U.options.meshCompressionMethod&&GG.DefaultAvailable}dispose(){}postExportMeshPrimitive(U,G,C){if(!this.enabled)return;if(4!==U.mode&&5!==U.mode)return void M.d.Warn("Cannot compress primitive with mode "+U.mode+".");const L=[],X=[];let l=null;if(void 0!==U.indices){const t=C[U.indices],E=G.getBufferView(t);l=G.getData(E).slice(),L.push(E),X.push(t)}const t=[];for(const[O,T]of Object.entries(U.attributes)){const U=C[T],l=G.getBufferView(U),K=c(U.type),P=(0,B.q)(G.getData(l),K,U.componentType,U.byteOffset||0,l.byteStride||(0,B.m)(U.componentType)*K,U.normalized||!1,U.count,!0);t.push({kind:O,dracoName:(E=O,"POSITION"===E?"POSITION":"NORMAL"===E?"NORMAL":E.startsWith("COLOR")?"COLOR":E.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:c(U.type),data:P}),L.push(l),X.push(U)}var E;const K={method:U.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},P=GG.Default._encodeAsync(t,l,K).then((C=>{if(!C)return void M.d.Error("Draco encoding failed for primitive.");const l={bufferView:-1,attributes:C.attributeIds},t=G.createBufferView(C.data);G.setBufferView(l,t);for(const U of L)this._bufferViewsUsed.add(U);for(const U of X)this._accessorsUsed.add(U);U.extensions||(U.extensions={}),U.extensions[CG]=l})).catch((U=>{M.d.Error("Draco encoding failed for primitive: "+U)}));this._encodePromises.push(P),this._wasUsed=!0}async preGenerateBinaryAsync(U){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((G=>{U.getPropertiesWithBufferView(G).every((U=>this._accessorsUsed.has(U)))&&U.removeBufferView(G)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}YU.RegisterExtension(CG,(U=>new LG(U)));var XG=C(13472);const lG="KHR_lights_punctual",tG={name:"",color:[1,1,1],CK:1,range:Number.MAX_VALUE},EG={innerConeAngle:0,outerConeAngle:Math.PI/4},KG=L.pG.Backward();class PG{constructor(U){this.name=lG,this.enabled=!0,this.required=!1,this._exporter=U}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[lG]=this._lights}async postExportNodeAsync(U,G,C,X,l){return await new Promise((t=>{if(!(C instanceof NU.c))return void t(G);const E=C.getTypeID()==NU.c.LIGHTTYPEID_POINTLIGHT?"point":C.getTypeID()==NU.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":C.getTypeID()==NU.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!E||!(C instanceof XG.d))return M.d.Warn("".concat(U,": Light ").concat(C.name," is not supported in ").concat(lG)),void t(G);if(C.falloffType!==NU.c.FALLOFF_GLTF&&M.d.Warn("".concat(U,": Light falloff for ").concat(C.name," does not match the ").concat(lG," specification!")),!C.position.equalsToFloats(0,0,0)){const U=L.TmpVectors.pG[0].L(C.position);l&&r(U),G.translation=U.sE()}if("point"!==E){const U=C.direction.normalizeToRef(L.TmpVectors.pG[0]);l&&r(U);const X=L.Quaternion.FromUnitVectorsToRef(KG,U,L.TmpVectors.Quaternion[0]);L.Quaternion.IsIdentity(X)||(G.rotation=X.sE())}const K={type:E,name:C.name,color:C.LK.sE(),CK:C.CK,range:C.range};if(XU(K,tG),"spot"===E){const U=C;K.spot={innerConeAngle:U.innerAngle/2,outerConeAngle:U.angle/2},XU(K.spot,EG)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(K);const P={lt:this._lights.lights.length-1},O=C.parent;if(O&&CU(C,O)){const U=X.get(O);if(U){const C=this._exporter._nodes[U];return GU(G,C),C.extensions||(C.extensions={}),C.extensions[lG]=P,void t(null)}}G.extensions||(G.extensions={}),G.extensions[lG]=P,t(G)}))}}YU.RegisterExtension(lG,(U=>new PG(U)));var OG=C(13375);const TG="KHR_materials_anisotropy";class DG{constructor(U){this.name=TG,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,G,C){const L=[];return C instanceof OG.c&&C.anisotropy.isEnabled&&!C.anisotropy.legacy?(C.anisotropy.texture&&L.push(C.anisotropy.texture),L):[]}postExportMaterialAsync(U,G,C){return new Promise((U=>{if(C instanceof OG.c){if(!C.anisotropy.isEnabled||C.anisotropy.legacy)return void U(G);this._wasUsed=!0,G.extensions=G.extensions||{};const L=this._exporter._materialExporter.getTextureInfo(C.anisotropy.texture),X={anisotropyStrength:C.anisotropy.CK,anisotropyRotation:C.anisotropy.angle,anisotropyTexture:null!==L&&void 0!==L?L:void 0};null!==X.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(C),G.extensions[TG]=X}U(G)}))}}YU.RegisterExtension(TG,(U=>new DG(U)));const yG="KHR_materials_clearcoat";class VG{constructor(U){this.name=yG,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,G,C){const L=[];return C instanceof OG.c&&C.clearCoat.isEnabled?(C.clearCoat.texture&&L.push(C.clearCoat.texture),!C.clearCoat.useRoughnessFromMainTexture&&C.clearCoat.textureRoughness&&L.push(C.clearCoat.textureRoughness),C.clearCoat.bumpTexture&&L.push(C.clearCoat.bumpTexture),L):[]}postExportMaterialAsync(U,G,C){return new Promise((U=>{if(C instanceof OG.c){var L;if(!C.clearCoat.isEnabled)return void U(G);this._wasUsed=!0,G.extensions=G.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture);let t;t=C.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(C.clearCoat.textureRoughness),C.clearCoat.isTintEnabled&&X.Tools.Warn("Clear Color tint is not supported for glTF export. Ignoring for: ".concat(C.name)),C.clearCoat.remapF0OnInterfaceChange&&X.Tools.Warn("Clear Color F0 remapping is not supported for glTF export. Ignoring for: ".concat(C.name));const E=this._exporter._materialExporter.getTextureInfo(C.clearCoat.bumpTexture),K={clearcoatFactor:C.clearCoat.CK,clearcoatTexture:null!==l&&void 0!==l?l:void 0,clearcoatRoughnessFactor:C.clearCoat.roughness,clearcoatRoughnessTexture:null!==(L=t)&&void 0!==L?L:void 0,clearcoatNormalTexture:null!==E&&void 0!==E?E:void 0};null===K.clearcoatTexture&&null===K.clearcoatRoughnessTexture&&null===K.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),G.extensions[yG]=K}U(G)}))}}YU.RegisterExtension(yG,(U=>new VG(U)));const pG="KHR_materials_diffuse_transmission";function IG(U,G){const C=G.subSurface;let L=null;return C.translucencyIntensityTexture?L=C.translucencyIntensityTexture:C.thicknessTexture&&C.useMaskFromThicknessTexture&&(L=C.thicknessTexture),L&&!C.useGltfStyleTextures?(M.d.Warn("".concat(U,": Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ").concat(G.name),1),null):L}class HG{constructor(U){this.name=pG,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,G,C){const L=[];if(C instanceof pU.c&&this._isExtensionEnabled(C)){const G=IG(U,C);return G&&L.push(G),C.subSurface.translucencyColorTexture&&L.push(C.subSurface.translucencyColorTexture),L}return L}_isExtensionEnabled(U){if(U.unlit)return!1;const G=U.subSurface;return!!G.isTranslucencyEnabled&&(!U.unlit&&!G.useAlbedoToTintTranslucency&&G.useGltfStyleTextures&&1===G.volumeIndexOfRefraction&&0===G.minimumThickness&&0===G.maximumThickness)}postExportMaterialAsync(U,G,C){return new Promise((L=>{if(C instanceof pU.c&&this._isExtensionEnabled(C)){var X,l;this._wasUsed=!0;const L=C.subSurface,t=IG(U,C),E=0==L.translucencyIntensity?void 0:L.translucencyIntensity,K=null!==(X=this._exporter._materialExporter.getTextureInfo(t))&&void 0!==X?X:void 0,P=!L.translucencyColor||L.translucencyColor.equalsFloats(1,1,1)?void 0:L.translucencyColor.sE(),O=null!==(l=this._exporter._materialExporter.getTextureInfo(L.translucencyColorTexture))&&void 0!==l?l:void 0,T={diffuseTransmissionFactor:E,diffuseTransmissionTexture:K,diffuseTransmissionColorFactor:P,diffuseTransmissionColorTexture:O};(K||O)&&this._exporter._materialNeedsUVsSet.add(C),G.extensions=G.extensions||{},G.extensions[pG]=T}L(G)}))}}YU.RegisterExtension(pG,(U=>new HG(U)));const xG="KHR_materials_dispersion";class hG{constructor(){this.name=xG,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(U){if(U.unlit)return!1;const G=U.subSurface;return!(!G.isRefractionEnabled&&!G.isDispersionEnabled)}postExportMaterialAsync(U,G,C){return new Promise((U=>{if(C instanceof pU.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const U={dispersion:C.subSurface.dispersion};G.extensions=G.extensions||{},G.extensions[xG]=U}U(G)}))}}YU.RegisterExtension(xG,(()=>new hG));const NG="KHR_materials_emissive_strength";class bG{constructor(){this.name=NG,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(U,G,C){return await new Promise((U=>{if(!(C instanceof pU.c))return U(G);const L=C.emissiveColor.sE(),X=Math.max(...L);if(X>1){this._wasUsed=!0,G.extensions||(G.extensions={});const U={emissiveStrength:X},L=C.emissiveColor.scale(1/U.emissiveStrength);G.emissiveFactor=L.sE(),G.extensions[NG]=U}return U(G)}))}}YU.RegisterExtension(NG,(U=>new bG));const oG="KHR_materials_ior";class wG{constructor(){this.name=oG,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(U){return!U.unlit&&(void 0!=U.indexOfRefraction&&1.5!=U.indexOfRefraction)}postExportMaterialAsync(U,G,C){return new Promise((U=>{if(C instanceof pU.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const U={ior:C.indexOfRefraction};G.extensions=G.extensions||{},G.extensions[oG]=U}U(G)}))}}YU.RegisterExtension(oG,(U=>new wG));const SG="KHR_materials_iridescence";class vG{constructor(U){this.name=SG,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,G,C){const L=[];return C instanceof OG.c&&C.iridescence.isEnabled?(C.iridescence.texture&&L.push(C.iridescence.texture),C.iridescence.thicknessTexture&&C.iridescence.thicknessTexture!==C.iridescence.texture&&L.push(C.iridescence.thicknessTexture),L):[]}postExportMaterialAsync(U,G,C){return new Promise((U=>{if(C instanceof OG.c){if(!C.iridescence.isEnabled)return void U(G);this._wasUsed=!0,G.extensions=G.extensions||{};const L=this._exporter._materialExporter.getTextureInfo(C.iridescence.texture),X=this._exporter._materialExporter.getTextureInfo(C.iridescence.thicknessTexture),l={iridescenceFactor:C.iridescence.CK,iridescenceIor:C.iridescence.indexOfRefraction,iridescenceThicknessMinimum:C.iridescence.minimumThickness,iridescenceThicknessMaximum:C.iridescence.maximumThickness,iridescenceTexture:null!==L&&void 0!==L?L:void 0,iridescenceThicknessTexture:null!==X&&void 0!==X?X:void 0};null===l.iridescenceTexture&&null===l.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(C),G.extensions[SG]=l}U(G)}))}}YU.RegisterExtension(SG,(U=>new vG(U)));const uG="KHR_materials_sheen";class dG{constructor(U){this.name=uG,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,G,C){return C instanceof pU.c&&C.sheen.isEnabled&&C.sheen.texture?[C.sheen.texture]:[]}async postExportMaterialAsync(U,G,C){return await new Promise((U=>{if(C instanceof pU.c){var L;if(!C.sheen.isEnabled)return void U(G);this._wasUsed=!0,null==G.extensions&&(G.extensions={});const E={sheenColorFactor:C.sheen.color.sE(),sheenRoughnessFactor:null!==(L=C.sheen.roughness)&&void 0!==L?L:0};var X,l;if(null===E.sheenColorTexture&&null===E.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),C.sheen.texture)E.sheenColorTexture=null!==(X=this._exporter._materialExporter.getTextureInfo(C.sheen.texture))&&void 0!==X?X:void 0;if(C.sheen.textureRoughness&&!C.sheen.useRoughnessFromMainTexture)E.sheenRoughnessTexture=null!==(l=this._exporter._materialExporter.getTextureInfo(C.sheen.textureRoughness))&&void 0!==l?l:void 0;else if(C.sheen.texture&&C.sheen.useRoughnessFromMainTexture){var t;E.sheenRoughnessTexture=null!==(t=this._exporter._materialExporter.getTextureInfo(C.sheen.texture))&&void 0!==t?t:void 0}G.extensions[uG]=E}U(G)}))}}YU.RegisterExtension(uG,(U=>new dG(U)));const gG="KHR_materials_specular";class ZG{constructor(U){this.name=gG,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,G,C){const L=[];return C instanceof pU.c&&this._isExtensionEnabled(C)?(C.metallicReflectanceTexture&&L.push(C.metallicReflectanceTexture),C.reflectanceTexture&&L.push(C.reflectanceTexture),L):L}_isExtensionEnabled(U){return!U.unlit&&(void 0!=U.metallicF0Factor&&1!=U.metallicF0Factor||void 0!=U.metallicReflectanceColor&&!U.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(U))}_hasTexturesExtension(U){return null!=U.metallicReflectanceTexture||null!=U.reflectanceTexture}postExportMaterialAsync(U,G,C){return new Promise((U=>{if(C instanceof pU.c&&this._isExtensionEnabled(C)){var L,X;this._wasUsed=!0,G.extensions=G.extensions||{};const U=null!==(L=this._exporter._materialExporter.getTextureInfo(C.metallicReflectanceTexture))&&void 0!==L?L:void 0,l=null!==(X=this._exporter._materialExporter.getTextureInfo(C.reflectanceTexture))&&void 0!==X?X:void 0,t={specularFactor:1==C.metallicF0Factor?void 0:C.metallicF0Factor,specularTexture:U,specularColorFactor:C.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:C.metallicReflectanceColor.sE(),specularColorTexture:l};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),G.extensions[gG]=t}U(G)}))}}YU.RegisterExtension(gG,(U=>new ZG(U)));const FG="KHR_materials_transmission";class qG{constructor(U){this.name=FG,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,G,C){const L=[];return C instanceof pU.c&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&L.push(C.subSurface.thicknessTexture),L):L}_isExtensionEnabled(U){if(U.unlit)return!1;const G=U.subSurface;return G.isRefractionEnabled&&void 0!=G.refractionIntensity&&0!=G.refractionIntensity||this._hasTexturesExtension(U)}_hasTexturesExtension(U){return null!=U.subSurface.refractionIntensityTexture}async postExportMaterialAsync(U,G,C){if(C instanceof pU.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const L=C.subSurface,X={transmissionFactor:0===L.refractionIntensity?void 0:L.refractionIntensity};if(this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),L.refractionIntensityTexture)if(L.useGltfStyleTextures){const U=await this._exporter._materialExporter.exportTextureAsync(L.refractionIntensityTexture,"image/png");U&&(X.transmissionTexture=U)}else M.d.Warn("".concat(U,": Exporting a subsurface refraction intensity texture without `useGltfStyleTextures` is not supported"));G.extensions||(G.extensions={}),G.extensions[FG]=X}return G}}YU.RegisterExtension(FG,(U=>new qG(U)));const aG="KHR_materials_unlit";class kG{constructor(){this.name=aG,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(U,G,C){return new Promise((U=>{let L=!1;C instanceof pU.c?L=C.unlit:C instanceof IU.xG&&(L=C.disableLighting),L&&(this._wasUsed=!0,null==G.extensions&&(G.extensions={}),G.extensions[aG]={}),U(G)}))}}YU.RegisterExtension(aG,(()=>new kG));const nG="KHR_materials_volume";class QG{constructor(U){this.name=nG,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,G,C){const L=[];return C instanceof pU.c&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&L.push(C.subSurface.thicknessTexture),L):L}_isExtensionEnabled(U){if(U.unlit)return!1;const G=U.subSurface;return!(!G.isRefractionEnabled&&!G.isTranslucencyEnabled)&&(void 0!=G.maximumThickness&&0!=G.maximumThickness||void 0!=G.tintColorAtDistance&&G.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=G.tintColor&&G.tintColor!=H.hG.White()||this._hasTexturesExtension(U))}_hasTexturesExtension(U){return null!=U.subSurface.thicknessTexture}postExportMaterialAsync(U,G,C){return new Promise((U=>{if(C instanceof pU.c&&this._isExtensionEnabled(C)){var L;this._wasUsed=!0;const U=C.subSurface,X={thicknessFactor:0==U.maximumThickness?void 0:U.maximumThickness,thicknessTexture:null!==(L=this._exporter._materialExporter.getTextureInfo(U.thicknessTexture))&&void 0!==L?L:void 0,attenuationDistance:U.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:U.tintColorAtDistance,attenuationColor:U.tintColor.equalsFloats(1,1,1)?void 0:U.tintColor.sE()};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),G.extensions=G.extensions||{},G.extensions[nG]=X}U(G)}))}}YU.RegisterExtension(nG,(U=>new QG(U)));const mC="EXT_materials_diffuse_roughness";class BG{constructor(U){this.name=mC,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,G,C){const L=[];return C instanceof OG.c&&C._baseDiffuseRoughness?(C._baseDiffuseRoughnessTexture&&L.push(C._baseDiffuseRoughnessTexture),L):[]}postExportMaterialAsync(U,G,C){return new Promise((U=>{if(C instanceof OG.c){if(!C._baseDiffuseRoughness)return void U(G);this._wasUsed=!0,G.extensions=G.extensions||{};const L=this._exporter._materialExporter.getTextureInfo(C._baseDiffuseRoughnessTexture),X={diffuseRoughnessFactor:C._baseDiffuseRoughness,diffuseRoughnessTexture:null!==L&&void 0!==L?L:void 0};null!==X.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(C),G.extensions[mC]=X}U(G)}))}}YU.RegisterExtension(mC,(U=>new BG(U)));const MG="KHR_texture_transform";class zG{constructor(){this.name=MG,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(U,G,C){if(C.wU()||X.Tools.Warn("".concat(U,': "scene" is not defined for Babylon texture ').concat(C.name,"!")),(0!==C.uAng||0!==C.vAng)&&(X.Tools.Warn("".concat(U,": Texture ").concat(C.name," with rotation in the u or v axis is not supported in glTF.")),0!==C.uRotationCenter||0!==C.vRotationCenter))return;const L={};let l=!1;if(0===C.uOffset&&0===C.vOffset||(L.offset=[C.uOffset,C.vOffset],l=!0),1===C.uScale&&1===C.vScale||(L.scale=[C.uScale,C.vScale],l=!0),0!==C.wAng){if(0!==C.uRotationCenter||0!==C.vRotationCenter){if(C.homogeneousRotationInUVTransform&&C.uScale!==C.vScale)return void X.Tools.Warn("".concat(U,": Texture ").concat(C.name," with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ").concat(MG,"."));X.Tools.Warn("".concat(U,": Texture ").concat(C.name," with non-origin rotation center will be exported using an adjusted offset with ").concat(MG,".")),L.offset=function(U){const{uOffset:G,vOffset:C,uRotationCenter:L,vRotationCenter:X,uScale:l,vScale:t,wAng:E}=U,K=Math.cos(E),P=Math.sin(E),O=L*l,T=X*t;return[G+(O*(1-K)+T*P),C+(T*(1-K)-O*P)]}(C)}L.rotation=-C.wAng,l=!0}0!==C.coordinatesIndex&&(L.texCoord=C.coordinatesIndex,l=!0),l&&(this._wasUsed=!0,G.extensions||(G.extensions={}),G.extensions[MG]=L)}}YU.RegisterExtension(MG,(()=>new zG));class sG{static CreateSTL(U){let G=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",X=arguments.length>3&&void 0!==arguments[3]&&arguments[3],l=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],t=arguments.length>5&&void 0!==arguments[5]&&arguments[5],E=arguments.length>6&&void 0!==arguments[6]&&arguments[6],K=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const P=function(U,G,C){const X=[3*U[C],3*U[C+1],3*U[C+2]],l=[new L.pG(G[X[0]],G[X[0]+2],G[X[0]+1]),new L.pG(G[X[1]],G[X[1]+2],G[X[1]+1]),new L.pG(G[X[2]],G[X[2]+2],G[X[2]+1])],t=l[0].IG(l[1]),E=l[2].IG(l[1]);return{v:l,n:L.pG.Cross(E,t).normalize()}},O=function(U,G,C,L){return G=D(U,G,C.x,L),G=D(U,G,C.y,L),D(U,G,C.z,L)},D=function(U,G,C,L){return U.setFloat32(G,C,L),G+4},y=function(U){if(E){let G=U;U instanceof V.c&&(G=U.sourceMesh);const C=G.getVerticesData(T.e.PositionKind,!0,!0);if(!C)return[];const X=L.pG.Zero();let l;for(l=0;l<C.length;l+=3)L.pG.TransformCoordinatesFromFloatsToRef(C[l],C[l+1],C[l+2],U.eE(!0),X).toArray(C,l);return C}return U.getVerticesData(T.e.PositionKind)||[]};E&&(t=!0);let p="",I=0,H=0;if(X){for(let C=0;C<U.length;C++){const G=U[C].cE();I+=G?G.length/3:0}const G=new ArrayBuffer(84+50*I);p=new DataView(G),H+=80,p.setUint32(H,I,l),H+=4}else K||(p="solid stlmesh\r\n");for(let L=0;L<U.length;L++){const G=U[L];!X&&K&&(p+="solid "+G.name+"\r\n"),!t&&G instanceof hU.d&&G.bakeCurrentTransformIntoVertices();const C=y(G),E=G.cE()||[];for(let U=0;U<E.length;U+=3){const G=P(E,C,U);X?(H=O(p,H,G.n,l),H=O(p,H,G.v[0],l),H=O(p,H,G.v[1],l),H=O(p,H,G.v[2],l),H+=2):(p+="\tfacet normal "+G.n.x+" "+G.n.y+" "+G.n.z+"\r\n",p+="\t\touter loop\r\n",p+="\t\t\tvertex "+G.v[0].x+" "+G.v[0].y+" "+G.v[0].z+"\r\n",p+="\t\t\tvertex "+G.v[1].x+" "+G.v[1].y+" "+G.v[1].z+"\r\n",p+="\t\t\tvertex "+G.v[2].x+" "+G.v[2].y+" "+G.v[2].z+"\r\n",p+="\t\tendloop\r\n",p+="\tendfacet\r\n")}!X&&K&&(p+="endsolid "+name+"\r\n")}if(X||K||(p+="endsolid stlmesh"),G){const U=document.createElement("a"),G=new Blob([p],{type:"application/octet-stream"});U.href=window.URL.createObjectURL(G),U.download=C+".stl",U.click()}return p}}function jG(U,G){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const L=[];for(let X=0;X<U.length/C;X++){const l=U[X*C],t=U[X*C+1],E=U[X*C+2];L.push("(".concat(l.toPrecision(G.precision),", ").concat(t.toPrecision(G.precision),", ").concat(E.toPrecision(G.precision),")"))}return L.join(", ")}function AG(U,G){const C=[];for(let L=0;L<U.length/2;L++){const X=U[2*L],l=U[2*L+1];C.push("(".concat(X.toPrecision(G.precision),", ").concat((1-l).toPrecision(G.precision),")"))}return C.join(", ")}function YG(U,G){const C=U.getVerticesData(T.e.PositionKind),L=U.getVerticesData(T.e.NormalKind);if(C&&L)return'\n\tdef Mesh "'.concat("Geometry",'"\n\t{\n\t\tint[] faceVertexCounts = [').concat(function(U){var G;const C=null!==(G=U.cE())&&void 0!==G&&G.length?U.getTotalIndices():U.getTotalVertices();return Array(C/3).fill(3).join(", ")}(U),"]\n\t\tint[] faceVertexIndices = [").concat(function(U){const G=U.cE(),C=[];if(null!==G)for(let L=0;L<G.length;L++)C.push(G[L]);else{const G=U.getTotalVertices();for(let U=0;U<G;U++)C.push(U)}return C.join(", ")}(U),"]\n\t\tnormal3f[] normals = [").concat(jG(L,G),'] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [').concat(jG(C,G),"]\n        ").concat(function(U,G){let C="";for(let X=0;X<4;X++){const L=X>0?X:"",l=U.getVerticesData(T.e.UVKind+(L?L+1:""));l&&(C+="\n\t\ttexCoord2f[] primvars:st".concat(L," = [").concat(AG(l,G),'] (\n\t\t\tinterpolation = "vertex"\n\t\t)'))}const L=U.getVerticesData(T.e.ColorKind);return L&&(C+="\n\tcolor3f[] primvars:displayColor = [".concat(jG(L,G,L.length/U.getTotalVertices()),'] (\n\t\tinterpolation = "vertex"\n\t\t)')),C}(U,G),'\n\t\tuniform token subdivisionScheme = "none"\n\t}\n')}function eG(U,G){const C=YG(U,G);return'\n        def "Geometry"\n        {\n        '.concat(C,"\n        }\n        ")}function iG(U){let G='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return G+=U,fflate.strToU8(G)}function cG(U){const G=U.m;return"( ".concat(RG(G,0),", ").concat(RG(G,4),", ").concat(RG(G,8),", ").concat(RG(G,12)," )")}function RG(U,G){return"(".concat(U[G+0],", ").concat(U[G+1],", ").concat(U[G+2],", ").concat(U[G+3],")")}function WG(U){const G="Object_"+U.uniqueId,C=function(U){const G=U.getWorldMatrix().clone(),C=U.wU().useRightHandedSystem;if(!C){let L=U.parent;for(;L;){if(EU(L,C)){G.multiplyToRef(L.getWorldMatrix().invert(),G);break}L=L.parent}}return G.determinant()<0&&X.Tools.Warn("Exporting mesh ".concat(U.name," with negative scale. Result may look incorrect in destination engine.")),G}(U),L=cG(C);return'def Xform "'.concat(G,'" (\n\tprepend references = @./geometries/Geometry_').concat(U.iE.uniqueId,'.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ').concat(L,'\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_').concat(U.material.uniqueId,">\n}\n\n")}function fG(U){switch(U){case S.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case S.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case S.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function rG(U){return"(".concat(U.x,", ").concat(U.y,")")}function JG(U){return"(".concat(U.r,", ").concat(U.g,", ").concat(U.b,")")}function UC(U,G,C,X,l,t){const E=U.getInternalTexture().uniqueId+"_"+U.invertY;l[E]=U;const K=U.coordinatesIndex>0?"st"+U.coordinatesIndex:"st",P=new L.Vector2(U.uScale,U.vScale),O=new L.Vector2(U.uOffset,U.vOffset),T=U.wAng,D=Math.sin(T),y=Math.cos(T);return O.y=1-O.y-P.y,O.x+=D*P.x,O.y+=(1-y)*P.y,'\n    def Shader "PrimvarReader_'.concat(C,'"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "').concat(K,'"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_').concat(C,'"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_').concat(G.uniqueId,"/PrimvarReader_").concat(C,".outputs:result>\n        float inputs:rotation = ").concat((T*(180/Math.PI)).toFixed(t.precision),"\n        float2 inputs:scale = ").concat(rG(P),"\n        float2 inputs:translation = ").concat(rG(O),'\n        float2 outputs:result\n    }\n\n    def Shader "Texture_').concat(U.uniqueId,"_").concat(C,'"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_').concat(E,".png@\n        float2 inputs:st.connect = </Materials/Material_").concat(G.uniqueId,"/Transform2d_").concat(C,".outputs:result>\n        ").concat(X?"float4 inputs:scale = "+function(U){return"(".concat(U.r,", ").concat(U.g,", ").concat(U.b,", 1.0)")}(X):"",'\n        token inputs:sourceColorSpace = "').concat(U.gammaSpace?"raw":"sRGB",'"\n        token inputs:wrapS = "').concat(fG(U.wrapU),'"\n        token inputs:wrapT = "').concat(fG(U.wrapV),'"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ').concat(G.needAlphaBlending()?"float outputs:a":"","\n    }")}function GC(U,G,C){const L="\t\t\t",X=[],l=[],{diffuseMap:t,LK:E,alphaCutOff:K,emissiveMap:P,emissive:T,normalMap:D,roughnessMap:y,roughnessChannel:V,roughness:p,metalnessMap:I,metalnessChannel:x,metalness:h,aoMap:N,aoMapChannel:b,aoMapIntensity:o,alphaMap:w,ior:S,clearCoatEnabled:v,clearCoat:u,clearCoatMap:d,clearCoatRoughness:g,clearCoatRoughnessMap:Z}=function(U){const G={diffuseMap:null,LK:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return U instanceof IU.xG?(0,O.b)((0,O.b)({},G),{},{diffuseMap:U.diffuseTexture,LK:U.diffuseColor,alphaCutOff:U.alphaCutOff,emissiveMap:U.emissiveTexture,emissive:U.emissiveColor,roughness:1,alphaMap:U.opacityTexture}):U instanceof OG.c?(0,O.b)((0,O.b)({},G),{},{diffuseMap:U._albedoTexture,LK:U._albedoColor,alphaCutOff:U._alphaCutOff,emissiveMap:U._emissiveTexture,emissive:U._emissiveColor,normalMap:U._bumpTexture,roughnessMap:U._metallicTexture,roughnessChannel:U._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:null!==(C=U._roughness)&&void 0!==C?C:1,metalnessMap:U._metallicTexture,metalnessChannel:U._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:null!==(L=U._metallic)&&void 0!==L?L:0,aoMap:U._ambientTexture,aoMapChannel:U._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:U._ambientTextureStrength,alphaMap:U._opacityTexture,ior:U.subSurface.indexOfRefraction,clearCoatEnabled:U.clearCoat.isEnabled,clearCoat:U.clearCoat.CK,clearCoatMap:U.clearCoat.texture,clearCoatRoughness:U.clearCoat.roughness,clearCoatRoughnessMap:U.clearCoat.useRoughnessFromMainTexture?U.clearCoat.texture:U.clearCoat.textureRoughness}):G;var C,L}(U);return null!==t?(X.push("".concat(L,"color3f inputs:diffuseColor.connect = </Materials/Material_").concat(U.uniqueId,"/Texture_").concat(t.uniqueId,"_diffuse.outputs:rgb>")),U.needAlphaBlending()?X.push("".concat(L,"float inputs:opacity.connect = </Materials/Material_").concat(U.uniqueId,"/Texture_").concat(t.uniqueId,"_diffuse.outputs:a>")):U.needAlphaTesting()&&(X.push("".concat(L,"float inputs:opacity.connect = </Materials/Material_").concat(U.uniqueId,"/Texture_").concat(t.uniqueId,"_diffuse.outputs:a>")),X.push("".concat(L,"float inputs:opacityThreshold = ").concat(K))),l.push(UC(t,U,"diffuse",E,G,C))):X.push("".concat(L,"color3f inputs:diffuseColor = ").concat(JG(E||H.hG.White()))),null!==P?(X.push("".concat(L,"color3f inputs:emissiveColor.connect = </Materials/Material_").concat(U.uniqueId,"/Texture_").concat(P.uniqueId,"_emissive.outputs:rgb>")),l.push(UC(P,U,"emissive",T,G,C))):T&&T.toLuminance()>0&&X.push("".concat(L,"color3f inputs:emissiveColor = ").concat(JG(T))),null!==D&&(X.push("".concat(L,"normal3f inputs:normal.connect = </Materials/Material_").concat(U.uniqueId,"/Texture_").concat(D.uniqueId,"_normal.outputs:rgb>")),l.push(UC(D,U,"normal",null,G,C))),null!==N&&(X.push("".concat(L,"float inputs:occlusion.connect = </Materials/Material_").concat(U.uniqueId,"/Texture_").concat(N.uniqueId,"_occlusion.outputs:").concat(b,">")),l.push(UC(N,U,"occlusion",new H.hG(o,o,o),G,C))),null!==y?(X.push("".concat(L,"float inputs:roughness.connect = </Materials/Material_").concat(U.uniqueId,"/Texture_").concat(y.uniqueId,"_roughness.outputs:").concat(V,">")),l.push(UC(y,U,"roughness",new H.hG(p,p,p),G,C))):X.push("".concat(L,"float inputs:roughness = ").concat(p)),null!==I?(X.push("".concat(L,"float inputs:metallic.connect = </Materials/Material_").concat(U.uniqueId,"/Texture_").concat(I.uniqueId,"_metallic.outputs:").concat(x,">")),l.push(UC(I,U,"metallic",new H.hG(h,h,h),G,C))):X.push("".concat(L,"float inputs:metallic = ").concat(h)),null!==w?(X.push("".concat(L,"float inputs:opacity.connect = </Materials/Material_").concat(U.uniqueId,"/Texture_").concat(w.uniqueId,"_opacity.outputs:r>")),X.push("".concat(L,"float inputs:opacityThreshold = 0.0001")),l.push(UC(w,U,"opacity",null,G,C))):X.push("".concat(L,"float inputs:opacity = ").concat(U.alpha)),v&&(null!==d?(X.push("".concat(L,"float inputs:clearcoat.connect = </Materials/Material_").concat(U.uniqueId,"/Texture_").concat(d.uniqueId,"_clearcoat.outputs:r>")),l.push(UC(d,U,"clearcoat",new H.hG(u,u,u),G,C))):X.push("".concat(L,"float inputs:clearcoat = ").concat(u)),null!==Z?(X.push("".concat(L,"float inputs:clearcoatRoughness.connect = </Materials/Material_").concat(U.uniqueId,"/Texture_").concat(Z.uniqueId,"_clearcoatRoughness.outputs:g>")),l.push(UC(Z,U,"clearcoatRoughness",new H.hG(g,g,g),G,C))):X.push("".concat(L,"float inputs:clearcoatRoughness = ").concat(g))),X.push("".concat(L,"float inputs:ior = ").concat(S)),'\n\tdef Material "Material_'.concat(U.uniqueId,'"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n').concat(X.join("\n"),"\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_").concat(U.uniqueId,"/PreviewSurface.outputs:surface>\n\n").concat(l.join("\n"),"\n\n\t}\n")}async function CC(U,G,C){const l=(0,O.b)({fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35},G);"undefined"===typeof fflate&&await X.Tools.LoadScriptAsync(l.fflateUrl);const t={};t[l.modelFileName]=null;let E='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';E+=function(U){const G=!0===U.includeAnchoringProperties?'\n\t\ttoken preliminary:anchoring:type = "'.concat(U.anchoringType,'"\n\t\ttoken preliminary:planeAnchoring:alignment = "').concat(U.planeAnchoringAlignment,'"'):"";return'def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {'.concat(G,"\n            ")}(l);const K={};for(const L of U.meshes){if(0===L.getTotalVertices())continue;const U=L,G=U.iE,P=U.material;if(!P||!G||C&&!C(U))continue;if(-1!==["xG","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(P.getClassName())){const C="geometries/Geometry_"+G.uniqueId+".usda";if(!(C in t)){const U=eG(G,l);t[C]=iG(U)}P.uniqueId in K||(K[P.uniqueId]=P),E+=WG(U)}else X.Tools.Warn("USDZExportAsync does not support this material type: "+P.getClassName())}U.activeCamera&&l.exportCamera&&(E+=function(U,G){const C="Camera_"+U.uniqueId,X=cG(L.Matrix.RotationY(Math.PI).multiply(U.getWorldMatrix()));if(U.mode===S.e.ORTHOGRAPHIC_CAMERA)return'def Camera "'.concat(C,'"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ').concat(X,'\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (').concat(U.AE.toPrecision(G.precision),", ").concat(U.maxZ.toPrecision(G.precision),")\n\t\t\tfloat horizontalAperture = ").concat((10*(Math.abs(U.orthoLeft||1)+Math.abs(U.orthoRight||1))).toPrecision(G.precision),"\n\t\t\tfloat verticalAperture = ").concat((10*(Math.abs(U.orthoTop||1)+Math.abs(U.orthoBottom||1))).toPrecision(G.precision),'\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t');{const L=U.getEngine().getAspectRatio(U),l=G.cameraSensorWidth||35;return'def Camera "'.concat(C,'"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ').concat(X,'\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (').concat(U.AE.toPrecision(G.precision),", ").concat(U.maxZ.toPrecision(G.precision),")\n\t\t\tfloat focalLength = ").concat((l/(2*Math.tan(.5*U.fov))).toPrecision(G.precision),'\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ').concat((l*L).toPrecision(G.precision),"\n\t\t\tfloat verticalAperture = ").concat((l/L).toPrecision(G.precision),"            \n\t\t}\n\t\n\t")}}(U.activeCamera,l)),E+="\n            }\n        }\n    }";const P={};E+=function(U,G,C){const L=[];for(const X in U){const l=U[X];L.push(GC(l,G,C))}return'\n    def "Materials"\n{\n'.concat(L.join(""),"\n}\n\n")}(K,P,l),t[l.modelFileName]=fflate.strToU8(E);for(const L in P){const U=P[L],G=U.getSize(),C=await U.readPixels();if(!C)throw new Error("Texture data is not available");const X=await v.DumpTools.DumpDataAsync(G.width,G.height,C,"image/png",void 0,!1,!0);t["textures/Texture_".concat(L,".png")]=new Uint8Array(X).slice()}let T=0;for(const L in t){const U=t[L];if(!U)continue;T+=34+L.length;const G=63&T;if(4!==G){const C=new Uint8Array(64-G);t[L]=[U,{extra:{12345:C}}]}T=U.length}return fflate.zipSync(t,{level:0})}}}]);