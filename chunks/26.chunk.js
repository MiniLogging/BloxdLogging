"use strict";(self.wy695la1oic=self.wy695la1oic||[]).push([[26],{11789:(S,v,D)=>{D.r(v),D.d(v,{EXT_materials_diffuse_roughness:()=>Jv,EXT_mesh_gpu_instancing:()=>fS,GLTF2Export:()=>US,GLTFData:()=>E,KHR_draco_mesh_compression:()=>Dv,KHR_lights_punctual:()=>gv,KHR_materials_anisotropy:()=>Av,KHR_materials_clearcoat:()=>nv,KHR_materials_diffuse_transmission:()=>Iv,KHR_materials_dispersion:()=>qv,KHR_materials_emissive_strength:()=>sv,KHR_materials_ior:()=>dv,KHR_materials_iridescence:()=>Wv,KHR_materials_sheen:()=>bv,KHR_materials_specular:()=>Zv,KHR_materials_transmission:()=>tv,KHR_materials_unlit:()=>av,KHR_materials_volume:()=>Mv,KHR_texture_transform:()=>Tv,OBJExport:()=>m,STLExport:()=>Gv,USDZExportAsync:()=>vD,_ConvertToGLTFPBRMetallicRoughness:()=>X,_SolveMetallic:()=>t,__IGLTFExporterExtension:()=>B});var z=D(11371),e=D(11175),N=D(11699);class m{static OBJ(S,v,D,m){const B=[];let g=1,E=1;v&&(D||(D="mat"),B.push("mtllib "+D+".mtl"));for(let h=0;h<S.length;h++){const D=S[h],A=D.name||`mesh${h}}`;B.push(`o ${A}`);let w=null;if(m){const S=D.ke(!0);w=new z.Matrix,S.invertToRef(w),D.bakeTransformIntoVertices(S)}if(v){const S=D.material;S&&B.push("usemtl "+S.id)}const n=D.ie;if(!n){e.Tools.Warn("No geometry is present on the mesh");continue}const R=n.getVerticesData("position"),O=n.getVerticesData("normal"),I=n.getVerticesData("uv"),K=n.te();let q=0,u=0;if(!R||!K){e.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const s=S[0].xS().useRightHandedSystem?1:-1;for(let S=0;S<R.length;S+=3)B.push("v "+R[S]*s+" "+R[S+1]+" "+R[S+2]),q++;if(null!=O)for(let S=0;S<O.length;S+=3)B.push("vn "+O[S]*s+" "+O[S+1]+" "+O[S+2]);if(null!=I)for(let S=0;S<I.length;S+=2)B.push("vt "+I[S]+" "+I[S+1]),u++;const r=["","",""],d=(D.material||D.xS().defaultMaterial)._getEffectiveOrientation(D),[x,W]=d===N.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let S=0;S<K.length;S+=3){const v=[String(K[S]+g),String(K[S+x]+g),String(K[S+W]+g)],D=[String(K[S]+E),String(K[S+x]+E),String(K[S+W]+E)],z=v,e=null!=I?D:r,N=null!=O?v:r;B.push("f "+z[0]+"/"+e[0]+"/"+N[0]+" "+z[1]+"/"+e[1]+"/"+N[1]+" "+z[2]+"/"+e[2]+"/"+N[2])}m&&w&&D.bakeTransformIntoVertices(w),g+=q,E+=u}return B.join("\n")}static MTL(S){const v=[],D=S.material;v.push("newmtl mat1"),v.push("  Ns "+D.specularPower.toFixed(4)),v.push("  Ni 1.5000"),v.push("  d "+D.alpha.toFixed(4)),v.push("  Tr 0.0000"),v.push("  Tf 1.0000 1.0000 1.0000"),v.push("  illum 2"),v.push("  Ka "+D.ambientColor.r.toFixed(4)+" "+D.ambientColor.g.toFixed(4)+" "+D.ambientColor.b.toFixed(4)),v.push("  Kd "+D.diffuseColor.r.toFixed(4)+" "+D.diffuseColor.g.toFixed(4)+" "+D.diffuseColor.b.toFixed(4)),v.push("  Ks "+D.specularColor.r.toFixed(4)+" "+D.specularColor.g.toFixed(4)+" "+D.specularColor.b.toFixed(4)),v.push("  Ke "+D.emissiveColor.r.toFixed(4)+" "+D.emissiveColor.g.toFixed(4)+" "+D.emissiveColor.b.toFixed(4));D.ambientTexture&&v.push("  map_Ka "+D.ambientTexture.name),D.diffuseTexture&&v.push("  map_Kd "+D.diffuseTexture.name),D.specularTexture&&v.push("  map_Ks "+D.specularTexture.name),D.bumpTexture&&v.push("  map_bump -imfchan z "+D.bumpTexture.name),D.opacityTexture&&v.push("  map_d "+D.opacityTexture.name);return v.join("\n")}}var B=0,g=D(11229);class E{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const S in this.files){const v=this.files[S],D=new Blob([v],{type:(0,g.h)(S)});e.Tools.Download(D,S)}}}var h=D(11452),A=D(11791),w=D(11802),n=D(11811),R=D(11505),O=D(11222),I=D(11425),K=D(11393);const q=K.HighestCommonFactor,u={...K,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:q};var s=D(11607),r=D(11350),d=D(11841),x=D(11845),W=D(11605);const p=1e-6,b=new I.qv(.04,.04,.04),k=1024,Z=I.qv.White(),i=I.qv.Black();function t(S,v,D){if(v<b.r)return 0;const z=b.r,e=S*D/(1-b.r)+v-2*b.r,N=e*e-4*z*(b.r-v);return u.Clamp((-e+Math.sqrt(N))/(2*z),0,1)}function X(S){const v=S.diffuseColor.toLinearSpace(S.xS().getEngine().useExactSrgbConversions).scale(.5),D=S.alpha,e=function(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new z.Vector2(0,1),D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new z.Vector2(0,.1),e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new z.Vector2(0,.1),N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new z.Vector2(1300,.1);return function(S,v,D,z,e){return(1-S)*(1-S)*(1-S)*v+3*(1-S)*(1-S)*S*D+3*(1-S)*S*S*z+S*S*S*e}(Math.pow(S/N.x,.333333),v.y,D.y,e.y,N.y)}(u.Clamp(S.specularPower,0,k));return{baseColorFactor:[v.r,v.g,v.b,D],metallicFactor:0,roughnessFactor:e}}function a(S,v){v.needAlphaBlending()?S.alphaMode="BLEND":v.needAlphaTesting()&&(S.alphaMode="MASK",S.alphaCutoff=v.alphaCutOff)}function o(S,v,D){const z=new Uint8Array(S*v*4);for(let e=0;e<z.length;e+=4)z[e]=z[e+1]=z[e+2]=z[e+3]=255;return d.e.CreateRGBATexture(z,S,v,D)}function M(S){if(S instanceof Uint8Array){const v=S.length,D=new Float32Array(S.length);for(let z=0;z<v;++z)D[z]=S[z]/255;return D}if(S instanceof Float32Array)return S;throw new Error("Unsupported pixel format!")}class c{constructor(S){this._exporter=S,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(S){return S?this._textureMap.get(S)??null:null}async exportStandardMaterialAsync(S,v,D){const z=X(S),N={name:S.name};if(null==S.Xe||S.Xe||(S.twoSidedLighting||e.Tools.Warn(S.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),N.doubleSided=!0),D){const D=[],e=S.diffuseTexture;e&&D.push(this.exportTextureAsync(e,v).then((S=>{S&&(z.baseColorTexture=S)})));const m=S.bumpTexture;m&&D.push(this.exportTextureAsync(m,v).then((S=>{S&&(N.normalTexture=S,1!==m.level&&(N.normalTexture.scale=m.level))})));const B=S.emissiveTexture;B&&(N.emissiveFactor=[1,1,1],D.push(this.exportTextureAsync(B,v).then((S=>{S&&(N.emissiveTexture=S)}))));const g=S.ambientTexture;g&&D.push(this.exportTextureAsync(g,v).then((S=>{if(S){const v={index:S.index};N.occlusionTexture=v}}))),D.length>0&&(this._exporter._materialNeedsUVsSet.add(S),await Promise.all(D))}(S.alpha<1||S.opacityTexture)&&(S.alphaMode===x.e.ALPHA_COMBINE?N.alphaMode="BLEND":e.Tools.Warn(S.name+": glTF 2.0 does not support alpha mode: "+S.alphaMode.toString())),S.emissiveColor&&!S.emissiveColor.equalsWithEpsilon(i,p)&&(N.emissiveFactor=S.emissiveColor.Oe()),N.pbrMetallicRoughness=z,a(N,S),await this._finishMaterialAsync(N,S,v);const m=this._exporter._materials;return m.push(N),m.length-1}async _finishMaterialAsync(S,v,D){const z=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",S,v),e=[];for(const N of z)e.push(this.exportTextureAsync(N,D));await Promise.all(e),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",S,v)}async _getImageDataAsync(S,v,z,e){const N=x.e.TEXTURETYPE_UNSIGNED_BYTE,m=this._exporter._babylonScene,B=m.getEngine(),g=B.createRawTexture(S,v,z,x.e.TEXTUREFORMAT_RGBA,!1,!0,r.d.NEAREST_SAMPLINGMODE,null,N);B.isWebGPU?await D.e(51).then(D.bind(D,13885)):await D.e(52).then(D.bind(D,13893)),await s.m.ApplyPostProcess("pass",g,m,N,x.e.TEXTURE_NEAREST_SAMPLINGMODE,x.e.TEXTUREFORMAT_RGBA);const E=await B._readTexturePixels(g,v,z);return await W.DumpTools.DumpDataAsync(v,z,E,e,void 0,!0,!0)}_resizeTexturesToSameDimensions(S,v,D){const z=S?S.getSize():{width:0,height:0},e=v?v.getSize():{width:0,height:0};let N,m;return z.width<e.width?(N=S&&S instanceof r.d?s.m.CreateResizedCopy(S,e.width,e.height,!0):o(e.width,e.height,D),m=v):z.width>e.width?(m=v&&v instanceof r.d?s.m.CreateResizedCopy(v,z.width,z.height,!0):o(z.width,z.height,D),N=S):(N=S,m=v),{texture1:N,texture2:m}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(S,v,D,z){const e=new Array;if(!S&&!v)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const N=S?S.xS():v?v.xS():null;if(N){var m;const B=this._resizeTexturesToSameDimensions(S,v,N),g=null===(m=B.texture1)||void 0===m?void 0:m.getSize();let E,h;const A=g.width,w=g.height,n=await B.texture1.readPixels(),R=await B.texture2.readPixels();if(!n)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(E=M(n),!R)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");h=M(R);const O=h.byteLength,K=new Uint8Array(O),q=new Uint8Array(O),u=4,s=i;let r=0,d=0;for(let S=0;S<w;++S)for(let v=0;v<A;++v){const z=(A*S+v)*u,e={diffuseColor:new I.qv(E[z],E[z+1],E[z+2]).toLinearSpace(N.getEngine().useExactSrgbConversions).multiply(D.diffuseColor),specularColor:new I.qv(h[z],h[z+1],h[z+2]).toLinearSpace(N.getEngine().useExactSrgbConversions).multiply(D.specularColor),glossiness:h[z+3]*D.glossiness},m=this._convertSpecularGlossinessToMetallicRoughness(e);s.r=Math.max(s.r,m.baseColor.r),s.g=Math.max(s.g,m.baseColor.g),s.b=Math.max(s.b,m.baseColor.b),r=Math.max(r,m.metallic),d=Math.max(d,m.roughness),q[z]=255*m.baseColor.r,q[z+1]=255*m.baseColor.g,q[z+2]=255*m.baseColor.b,q[z+3]=B.texture1.de?255*E[z+3]:255,K[z]=0,K[z+1]=255*m.roughness,K[z+2]=255*m.metallic,K[z+3]=255}const x={baseColor:s,metallic:r,roughness:d};let W=!1,b=!1;for(let S=0;S<w;++S)for(let v=0;v<A;++v){const D=(A*S+v)*u;q[D]/=x.baseColor.r>p?x.baseColor.r:1,q[D+1]/=x.baseColor.g>p?x.baseColor.g:1,q[D+2]/=x.baseColor.b>p?x.baseColor.b:1;const z=I.qv.FromInts(q[D],q[D+1],q[D+2]).toGammaSpace(N.getEngine().useExactSrgbConversions);q[D]=255*z.r,q[D+1]=255*z.g,q[D+2]=255*z.b,z.equalsWithEpsilon(Z,p)||(b=!0),K[D+1]/=x.roughness>p?x.roughness:1,K[D+2]/=x.metallic>p?x.metallic:1;I.qv.FromInts(255,K[D+1],K[D+2]).equalsWithEpsilon(Z,p)||(W=!0)}return W&&e.push(this._getImageDataAsync(K,A,w,z).then((S=>{x.metallicRoughnessTextureData=S}))),b&&e.push(this._getImageDataAsync(q,A,w,z).then((S=>{x.baseColorTextureData=S}))),await Promise.all(e).then((()=>x))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(S){const v=this._getPerceivedBrightness(S.diffuseColor),D=this._getPerceivedBrightness(S.specularColor),z=1-this._getMaxComponent(S.specularColor),e=t(v,D,z),N=S.diffuseColor.scale(z/(1-b.r)/Math.max(1-e)),m=S.specularColor.Ov(b.scale(1-e)).scale(1/Math.max(e));let B=I.qv.Lerp(N,m,e*e);B=B.clampToRef(0,1,B);return{baseColor:B,metallic:e,roughness:1-S.glossiness}}_getPerceivedBrightness(S){return S?Math.sqrt(.299*S.r*S.r+.587*S.g*S.g+.114*S.b*S.b):0}_getMaxComponent(S){return S?Math.max(S.r,Math.max(S.g,S.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(S,v,D,z){const e=[],N={baseColor:S._albedoColor,metallic:S._metallic,roughness:S._roughness};if(z){S._albedoTexture&&e.push(this.exportTextureAsync(S._albedoTexture,v).then((S=>{S&&(D.baseColorTexture=S)})));const z=S._metallicTexture;z&&e.push(this.exportTextureAsync(z,v).then((S=>{S&&(D.metallicRoughnessTexture=S)})))}return e.length>0&&(this._exporter._materialNeedsUVsSet.add(S),await Promise.all(e)),N}_getTextureSampler(S){const v={};if(!S||!(S instanceof r.d))return v;const D=this._getGLTFTextureWrapMode(S.wrapU);10497!==D&&(v.wrapS=D);const z=this._getGLTFTextureWrapMode(S.wrapV);switch(10497!==z&&(v.wrapT=z),S.samplingMode){case r.d.LINEAR_LINEAR:v.magFilter=9729,v.minFilter=9729;break;case r.d.LINEAR_NEAREST:v.magFilter=9729,v.minFilter=9728;break;case r.d.NEAREST_LINEAR:v.magFilter=9728,v.minFilter=9729;break;case r.d.NEAREST_LINEAR_MIPLINEAR:v.magFilter=9728,v.minFilter=9987;break;case r.d.NEAREST_NEAREST:v.magFilter=9728,v.minFilter=9728;break;case r.d.NEAREST_LINEAR_MIPNEAREST:v.magFilter=9728,v.minFilter=9985;break;case r.d.LINEAR_NEAREST_MIPNEAREST:v.magFilter=9729,v.minFilter=9984;break;case r.d.LINEAR_NEAREST_MIPLINEAR:v.magFilter=9729,v.minFilter=9986;break;case r.d.NEAREST_NEAREST_MIPLINEAR:v.magFilter=9728,v.minFilter=9986;break;case r.d.LINEAR_LINEAR_MIPLINEAR:v.magFilter=9729,v.minFilter=9987;break;case r.d.LINEAR_LINEAR_MIPNEAREST:v.magFilter=9729,v.minFilter=9985;break;case r.d.NEAREST_NEAREST_MIPNEAREST:v.magFilter=9728,v.minFilter=9984}return v}_getGLTFTextureWrapMode(S){switch(S){case r.d.WRAP_ADDRESSMODE:return 10497;case r.d.CLAMP_ADDRESSMODE:return 33071;case r.d.MIRROR_ADDRESSMODE:return 33648;default:return e.Tools.Error(`Unsupported Texture Wrap Mode ${S}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(S,v,D,z){const e={diffuseColor:S._albedoColor,specularColor:S._reflectivityColor,glossiness:S._microSurface},N=S._albedoTexture,m=S._reflectivityTexture,B=S._useMicroSurfaceFromReflectivityMapAlpha;if(m&&!B)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((N||m)&&z){this._exporter._materialNeedsUVsSet.add(S);const z=this._exportTextureSampler(N||m),B=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(N,m,e,v),g=this._exporter._textures;if(B.baseColorTextureData){const S=this._exportImage(`baseColor${g.length}`,v,B.baseColorTextureData);D.baseColorTexture=this._exportTextureInfo(S,z,null===N||void 0===N?void 0:N.coordinatesIndex)}if(B.metallicRoughnessTextureData){const S=this._exportImage(`metallicRoughness${g.length}`,v,B.metallicRoughnessTextureData);D.metallicRoughnessTexture=this._exportTextureInfo(S,z,null===m||void 0===m?void 0:m.coordinatesIndex)}return B}return this._convertSpecularGlossinessToMetallicRoughness(e)}async exportPBRMaterialAsync(S,v,D){const z={},e={name:S.name},N=S.isMetallicWorkflow();if(N){const v=S._albedoColor,D=S.alpha;v&&(z.baseColorFactor=[v.r,v.g,v.b,D])}const m=N?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(S,v,z,D):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(S,v,z,D);await this._setMetallicRoughnessPbrMaterialAsync(m,S,e,z,v,D),await this._finishMaterialAsync(e,S,v);const B=this._exporter._materials;return B.push(e),B.length-1}async _setMetallicRoughnessPbrMaterialAsync(S,v,D,z,N,m){if(a(D,v),S.baseColor.equalsWithEpsilon(Z,p)&&u.WithinEpsilon(v.alpha,1,p)||(z.baseColorFactor=[S.baseColor.r,S.baseColor.g,S.baseColor.b,v.alpha]),null!=S.metallic&&1!==S.metallic&&(z.metallicFactor=S.metallic),null!=S.roughness&&1!==S.roughness&&(z.roughnessFactor=S.roughness),null==v.Xe||v.Xe||(v._twoSidedLighting||e.Tools.Warn(v.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),D.doubleSided=!0),m){const S=[],z=v._bumpTexture;z&&S.push(this.exportTextureAsync(z,N).then((S=>{S&&(D.normalTexture=S,1!==z.level&&(D.normalTexture.scale=z.level))})));const e=v._ambientTexture;e&&S.push(this.exportTextureAsync(e,N).then((S=>{if(S){const z={index:S.index,texCoord:S.texCoord,extensions:S.extensions};D.occlusionTexture=z;const e=v._ambientTextureStrength;e&&(z.strength=e)}})));const m=v._emissiveTexture;m&&S.push(this.exportTextureAsync(m,N).then((S=>{S&&(D.emissiveTexture=S)}))),S.length>0&&(this._exporter._materialNeedsUVsSet.add(v),await Promise.all(S))}const B=v._emissiveColor;B.equalsWithEpsilon(i,p)||(D.emissiveFactor=B.Oe()),D.pbrMetallicRoughness=z}_getPixelsFromTextureAsync(S){return function(S){switch(S){case x.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case x.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case x.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case x.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case x.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case x.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case x.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case x.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case x.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case x.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case x.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case x.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case x.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case x.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case x.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case x.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case x.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case x.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case x.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case x.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case x.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(S.textureFormat)?(0,s.i)(S,S._texture.width,S._texture.height):(S.textureType,x.e.TEXTURETYPE_UNSIGNED_BYTE,S.readPixels())}async exportTextureAsync(S,v){const D=this._exporter._extensionsPreExportTextureAsync("exporter",S,v);return D?await D.then((async D=>D?await this._exportTextureInfoAsync(D,v):await this._exportTextureInfoAsync(S,v))):await this._exportTextureInfoAsync(S,v)}async _exportTextureInfoAsync(S,v){let D=this._textureMap.get(S);if(!D){const z=await this._getPixelsFromTextureAsync(S);if(!z)return null;const N=this._exportTextureSampler(S),m=S.mimeType;if(m)switch(m){case"image/jpeg":case"image/png":case"image/webp":v=m;break;default:e.Tools.Warn(`Unsupported media type: ${m}. Exporting texture as PNG.`)}const B=this._internalTextureToImage,g=S.getInternalTexture().uniqueId;B[g]||(B[g]={});let E=B[g][v];if(void 0===E){const D=S.getSize();E=(async()=>{const e=await this._getImageDataAsync(z,D.width,D.height,v);return this._exportImage(S.name,v,e)})(),B[g][v]=E}D=this._exportTextureInfo(await E,N,S.coordinatesIndex),this._textureMap.set(S,D),this._exporter._extensionsPostExportTextures("exporter",D,S)}return D}_exportImage(S,v,D){const z=this._exporter._images;let N;if(this._exporter._shouldUseGlb){N={name:S,mimeType:v,bufferView:void 0};const z=this._exporter._bufferManager.createBufferView(new Uint8Array(D));this._exporter._bufferManager.setBufferView(N,z)}else{const m=S.replace(/\.\/|\/|\.\\|\\/g,"_"),B=function(S){switch(S){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(v);let g=m+B;z.some((S=>S.uri===g))&&(g=`${m}_${e.Tools.RandomId()}${B}`),N={name:S,uri:g},this._exporter._imageData[g]={data:D,mimeType:v}}return z.push(N),z.length-1}_exportTextureInfo(S,v,D){const z=this._exporter._textures;let e=z.findIndex((D=>D.sampler==v&&D.source===S));-1===e&&(e=z.length,z.push({source:S,sampler:v}));const N={index:e};return D&&(N.texCoord=D),N}_exportTextureSampler(S){const v=this._getTextureSampler(S),D=this._exporter._samplers,z=D.findIndex((S=>S.minFilter===v.minFilter&&S.magFilter===v.magFilter&&S.wrapS===v.wrapS&&S.wrapT===v.wrapT));return-1!==z?z:(D.push(v),D.length-1)}}var J=D(11469),H=D(11190),T=D(11852),G=D(11377);const Y=z.Rv.Zero(),j=z.Quaternion.Identity(),V=z.Rv.One(),U=new z.Rv(-1,1,1);function y(S,v){const{byteOffset:D,byteStride:z,type:e,normalized:N}=S,m=S.getSize(),B=v.reduce(((S,v)=>v.getTotalVertices()>S?v.getTotalVertices():S),-Number.MAX_VALUE);return{byteOffset:D,byteStride:z,componentCount:m,type:e,count:B*m,normalized:N,totalVertices:B,kind:S.getKind()}}function f(S){switch(S){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function C(S){switch(S){case h.d.PositionKind:case h.d.NormalKind:case h.d.TangentKind:case h.d.ColorKind:case h.d.MatricesIndicesKind:case h.d.MatricesIndicesExtraKind:case h.d.MatricesWeightsKind:case h.d.MatricesWeightsExtraKind:case h.d.UVKind:case h.d.UV2Kind:case h.d.UV3Kind:case h.d.UV4Kind:case h.d.UV5Kind:case h.d.UV6Kind:return!0}return!1}function F(S){switch(S){case N.d.TriangleFillMode:return 4;case N.d.TriangleStripDrawMode:return 5;case N.d.TriangleFanDrawMode:return 6;case N.d.PointListDrawMode:case N.d.PointFillMode:return 0;case N.d.LineLoopDrawMode:return 2;case N.d.LineListDrawMode:return 1;case N.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${S}`)}function l(S){const v=Math.sqrt(S.x*S.x+S.y*S.y+S.z*S.z);v>0&&(S.x/=v,S.y/=v,S.z/=v)}function P(S){return S.x*=-1,S}function Q(S){if(S.x*S.x+S.y*S.y>.5){const v=Math.abs(S.x),D=Math.abs(S.y);if(v>D){const D=Math.sign(S.x);S.x=v,S.y*=-D,S.z*=-D,S.w*=D}else{const v=Math.sign(S.y);S.x*=-v,S.y=D,S.z*=v,S.w*=-v}}else{const v=Math.abs(S.z),D=Math.abs(S.w);if(v>D){const D=Math.sign(S.z);S.x*=-D,S.y*=D,S.z=v,S.w*=-D}else{const v=Math.sign(S.w);S.x*=v,S.y*=-v,S.z*=-v,S.w=D}}return S}function L(S){S.oe(-S.z,S.w,S.x,-S.y)}function SS(S,v){const D=z.Rv.FromArrayToRef(v.translation||[0,0,0],0,z.TmpVectors.Rv[0]),e=z.Quaternion.FromArrayToRef(v.rotation||[0,0,0,1],0,z.TmpVectors.Quaternion[0]),N=z.Matrix.ComposeToRef(V,e,D,z.TmpVectors.Matrix[0]),m=z.Rv.FromArrayToRef(S.translation||[0,0,0],0,z.TmpVectors.Rv[2]),B=z.Quaternion.FromArrayToRef(S.rotation||[0,0,0,1],0,z.TmpVectors.Quaternion[1]),g=z.Matrix.ComposeToRef(V,B,m,z.TmpVectors.Matrix[1]);N.multiplyToRef(g,g),g.decompose(void 0,e,D),D.equalsWithEpsilon(Y,G.e)?delete v.translation:v.translation=D.Oe(),e.equalsWithEpsilon(j,G.e)?delete v.rotation:v.rotation=e.Oe(),v.scale&&delete v.scale}function vS(S,v){if(!(v instanceof A.b))return!1;if(!(1===v.getChildren().length&&0===S.getChildren().length&&S.parent===v))return!1;const D=S.xS(),z=S instanceof T.d&&!D.useRightHandedSystem?U:V;return!!v.Me.equalsWithEpsilon(z,G.e)||(H.b.Warn(`Cannot collapse node ${S.name} into parent node ${v.name} with modified scaling.`),!1)}function DS(S){if(S instanceof Array){const v=new Float32Array(S);return new Uint8Array(v.buffer,v.byteOffset,v.byteLength)}return ArrayBuffer.isView(S)?new Uint8Array(S.buffer,S.byteOffset,S.byteLength):new Uint8Array(S)}function zS(S,v){for(const[D,z]of Object.entries(S)){const e=v[D];(Array.isArray(z)&&Array.isArray(e)&&eS(z,e)||z===e)&&delete S[D]}return S}function eS(S,v){return S.length===v.length&&S.every(((S,D)=>S===v[D]))}const NS=z.Matrix.Compose(new z.Rv(-1,1,1),z.Quaternion.Identity(),z.Rv.Zero());function mS(S,v){if(!(S instanceof A.b))return!1;if(v){if(!S.getWorldMatrix().equalsWithEpsilon(z.Matrix.IdentityReadOnly,G.e))return!1}else{if(!S.getWorldMatrix().multiplyToRef(NS,z.TmpVectors.Matrix[0]).equalsWithEpsilon(z.Matrix.IdentityReadOnly,G.e))return!1}return!(S instanceof w.e&&S.ie)}const BS=new Map([[Int8Array,(S,v,D)=>S.setInt8(v,D)],[Uint8Array,(S,v,D)=>S.setUint8(v,D)],[Uint8ClampedArray,(S,v,D)=>S.setUint8(v,D)],[Int16Array,(S,v,D)=>S.setInt16(v,D,!0)],[Uint16Array,(S,v,D)=>S.setUint16(v,D,!0)],[Int32Array,(S,v,D)=>S.setInt32(v,D,!0)],[Uint32Array,(S,v,D)=>S.setUint32(v,D,!0)],[Float32Array,(S,v,D)=>S.setFloat32(v,D,!0)],[Float64Array,(S,v,D)=>S.setFloat64(v,D,!0)]]);class gS{writeTypedArray(S){this._checkGrowBuffer(S.byteLength);const v=BS.get(S.constructor);for(let D=0;D<S.length;D++)v(this._dataView,this._byteOffset,S[D]),this._byteOffset+=S.BYTES_PER_ELEMENT}constructor(S){this._data=new Uint8Array(S),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(S){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,S),this._byteOffset++}writeInt8(S){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,S),this._byteOffset++}writeInt16(S){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,S,!0),this._byteOffset+=2}writeUInt16(S){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,S,!0),this._byteOffset+=2}writeInt32(S){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,S,!0),this._byteOffset+=4}writeUInt32(S){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,S,!0),this._byteOffset+=4}writeFloat32(S){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,S,!0),this._byteOffset+=4}writeFloat64(S){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,S,!0),this._byteOffset+=8}_checkGrowBuffer(S){const v=this.byteOffset+S;if(v>this._data.byteLength){const S=new Uint8Array(2*v);S.set(this._data),this._data=S,this._dataView=new DataView(this._data.buffer)}}}function ES(S){return S%4===0?4:S%2===0?2:1}class hS{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(S){let v=0;this._bufferViewToData.forEach((S=>{v+=S.byteLength}));const D=new gS(v),z=Array.from(this._bufferViewToData.keys()).sort(((S,v)=>ES(v.byteLength)-ES(S.byteLength)));for(const e of z){e.byteOffset=D.byteOffset,S.push(e);const v=S.length-1,z=this.getPropertiesWithBufferView(e);for(const S of z)S.bufferView=v;D.writeTypedArray(this._bufferViewToData.get(e)),this._bufferViewToData.delete(e)}return D.getOutputData()}createBufferView(S,v){const D={buffer:0,byteOffset:void 0,byteLength:S.byteLength,byteStride:v};return this._bufferViewToData.set(D,S),D}createAccessor(S,v,D,z,e,N,m){this._verifyBufferView(S);const B={bufferView:void 0,componentType:D,count:z,type:v,min:null===N||void 0===N?void 0:N.min,max:null===N||void 0===N?void 0:N.max,normalized:m,byteOffset:e};return this.setBufferView(B,S),this._accessorToBufferView.set(B,S),B}setBufferView(S,v){this._verifyBufferView(v);this.getPropertiesWithBufferView(v).push(S)}removeBufferView(S){const v=this.getPropertiesWithBufferView(S);for(const D of v)void 0!==D.bufferView&&delete D.bufferView;this._bufferViewToData.delete(S),this._bufferViewToProperties.delete(S),this._accessorToBufferView.forEach(((v,D)=>{v===S&&(void 0!==D.byteOffset&&delete D.byteOffset,this._accessorToBufferView.delete(D))}))}getBufferView(S){const v=this._accessorToBufferView.get(S);return this._verifyBufferView(v),v}getPropertiesWithBufferView(S){return this._verifyBufferView(S),this._bufferViewToProperties.set(S,this._bufferViewToProperties.get(S)??[]),this._bufferViewToProperties.get(S)}getData(S){return this._verifyBufferView(S),this._bufferViewToData.get(S)}_verifyBufferView(S){if(void 0===S||!this._bufferViewToData.has(S))throw new Error(`BufferView ${S} not found in BufferManager.`)}}var AS,wS=D(11827),nS=D(11836),RS=D(11854),OS=D(11746),IS=D(11884),KS=D(11895),qS=D(11819),uS=D(11901);!function(S){S[S.INTANGENT=0]="INTANGENT",S[S.OUTTANGENT=1]="OUTTANGENT"}(AS||(AS={}));class sS{static _IsTransformable(S){return S&&(S instanceof A.b||S instanceof wS.b||S instanceof uS.b)}static _CreateNodeAnimation(S,v,D,z,N){if(this._IsTransformable(S)){const m=[],B=[],g=v.getKeys(),E=sS._CalculateMinMaxKeyFrames(g),h=sS._DeduceInterpolation(g,D,z),A=h.interpolationType,w=h.shouldBakeAnimation;if(w?sS._CreateBakedAnimation(S,v,D,E.min,E.max,v.framePerSecond,N,m,B,E,z):"LINEAR"===A||"STEP"===A?sS._CreateLinearOrStepAnimation(S,v,D,m,B,z):"CUBICSPLINE"===A?sS._CreateCubicSplineAnimation(S,v,D,m,B,z):sS._CreateBakedAnimation(S,v,D,E.min,E.max,v.framePerSecond,N,m,B,E,z),m.length&&B.length){return{inputs:m,outputs:B,samplerInterpolation:A,inputsMin:w?E.min:e.Tools.FloatRound(E.min/v.framePerSecond),inputsMax:w?E.max:e.Tools.FloatRound(E.max/v.framePerSecond)}}}return null}static _DeduceAnimationInfo(S){let v=null,D="VEC3",z=!1;const N=S.targetProperty.split(".");switch(N[0]){case"Me":v="scale";break;case"position":v="translation";break;case"rotation":D="VEC4",v="rotation";break;case"rotationQuaternion":D="VEC4",z=!0,v="rotation";break;case"influence":D="SCALAR",v="weights";break;default:e.Tools.Error(`Unsupported animatable property ${N[0]}`)}return v?{animationChannelTargetPath:v,dataAccessorType:D,useQuaternion:z}:(e.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(S,v,D,z,e,N,m,B,g,E,h){let A;if(sS._IsTransformable(S)&&S.animations)for(const w of S.animations){if(h&&!h(w))continue;const e=sS._DeduceAnimationInfo(w);e&&(A={name:w.name,samplers:[],channels:[]},sS._AddAnimation(`${w.name}`,w.hasRunningRuntimeAnimations?v:A,S,w,e.dataAccessorType,e.animationChannelTargetPath,z,N,m,B,e.useQuaternion,g,E),A.samplers.length&&A.channels.length&&D.push(A))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(S,v,D,z,e,N,m,B,g,E,h){let A;if(S instanceof qS.e){const e=S.morphTargetManager;if(e)for(let w=0;w<e.numTargets;++w){const n=e.getTarget(w);for(const R of n.animations){if(h&&!h(R))continue;const n=new IS.b(`${R.name}`,"influence",R.framePerSecond,R.dataType,R.loopMode,R.enableBlending),O=[],I=R.getKeys();for(let S=0;S<I.length;++S){const v=I[S];for(let S=0;S<e.numTargets;++S)S==w?O.push(v):O.push({frame:v.frame,value:0})}n.setKeys(O);const K=sS._DeduceAnimationInfo(n);K&&(A={name:n.name,samplers:[],channels:[]},sS._AddAnimation(R.name,R.hasRunningRuntimeAnimations?v:A,S,n,K.dataAccessorType,K.animationChannelTargetPath,z,N,m,B,K.useQuaternion,g,E,e.numTargets),A.samplers.length&&A.channels.length&&D.push(A))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(S,v,D,z,e,N,m,B,g){let E;if(S.animationGroups){const A=S.animationGroups;for(const w of A){const A=new Map,n=new Map,R=new Set,O=w.to-w.from;E={name:w.name,channels:[],samplers:[]};for(let v=0;v<w.targetedAnimations.length;++v){const O=w.targetedAnimations[v],I=O.target,K=O.animation;if(g&&!g(K))continue;const q=B.has(I);if(this._IsTransformable(I)||1===I.length&&this._IsTransformable(I[0])){const S=sS._DeduceAnimationInfo(O.animation);if(S){const v=this._IsTransformable(I)?I:this._IsTransformable(I[0])?I[0]:null;v&&sS._AddAnimation(`${K.name}`,E,v,K,S.dataAccessorType,S.animationChannelTargetPath,D,z,e,N,S.useQuaternion,m,q)}}else if(I instanceof KS.e||1===I.length&&I[0]instanceof KS.e){if(sS._DeduceAnimationInfo(O.animation)){const v=I instanceof KS.e?I:I[0];if(v){const D=S.morphTargetManagers.find((S=>{for(let D=0;D<S.numTargets;++D)if(S.getTarget(D)===v)return!0;return!1}));if(D){const z=S.meshes.find((S=>S.morphTargetManager===D));var h;if(z)A.has(z)||A.set(z,new Map),null===(h=A.get(z))||void 0===h||h.set(v,K),R.add(z),n.set(z,K)}}}}}R.forEach((S=>{const v=S.morphTargetManager;let B=null;const g=[],h=n.get(S).getKeys(),R=h.length;for(let D=0;D<R;++D)for(let z=0;z<v.numTargets;++z){const e=v.getTarget(z),N=A.get(S);if(N){const v=N.get(e);v?(B||(B=new IS.b(`${w.name}_${S.name}_MorphWeightAnimation`,"influence",v.framePerSecond,IS.b.ANIMATIONTYPE_FLOAT,v.loopMode,v.enableBlending)),g.push(v.getKeys()[D])):g.push({frame:w.from+O/R*D,value:e.influence,inTangent:h[0].inTangent?0:void 0,outTangent:h[0].outTangent?0:void 0})}}B.setKeys(g);const I=sS._DeduceAnimationInfo(B);I&&sS._AddAnimation(`${w.name}_${S.name}_MorphWeightAnimation`,E,S,B,I.dataAccessorType,I.animationChannelTargetPath,D,z,e,N,I.useQuaternion,m,!1,null===v||void 0===v?void 0:v.numTargets)})),E.channels.length&&E.samplers.length&&v.push(E)}}}static _AddAnimation(S,v,D,e,N,m,B,g,E,h,A,w,n,R){const O=sS._CreateNodeAnimation(D,e,m,A,w);let I,K,q,u,s,r;if(O){if(R){let S=0,v=0;const D=[];for(;O.inputs.length>0;)v=O.inputs.shift(),S%R==0&&D.push(v),S++;O.inputs=D}const S=B.get(D),e=new Float32Array(O.inputs);I=g.createBufferView(e),K=g.createAccessor(I,"SCALAR",5126,O.inputs.length,void 0,{min:[O.inputsMin],max:[O.inputsMax]}),h.push(K),q=h.length-1;const E=new z.Quaternion,A=new z.Rv,w=new z.Rv,d=D instanceof wS.b,x=f(N),W=new Float32Array(O.outputs.length*x);O.outputs.forEach((function(S,v){let D=S;switch(m){case"translation":n&&(z.Rv.FromArrayToRef(S,0,w),P(w),w.toArray(D));break;case"rotation":4===S.length?z.Quaternion.FromArrayToRef(S,0,E):(D=new Array(4),z.Rv.FromArrayToRef(S,0,A),z.Quaternion.FromEulerVectorToRef(A,E)),n&&(Q(E),d&&L(E)),E.toArray(D)}W.set(D,v*x)})),I=g.createBufferView(W),K=g.createAccessor(I,N,5126,O.outputs.length),h.push(K),u=h.length-1,s={interpolation:O.samplerInterpolation,input:q,output:u},v.samplers.push(s),r={sampler:v.samplers.length-1,target:{node:S,path:m}},v.channels.push(r)}}static _CreateBakedAnimation(S,v,D,N,m,B,g,E,h,A,w){let n;const R=z.Quaternion.Identity();let O,I=null,K=null,q=null,u=null,s=null,r=null;A.min=e.Tools.FloatRound(N/B);const d=v.getKeys();for(let z=0,x=d.length;z<x;++z){if(r=null,q=d[z],z+1<x)if(u=d[z+1],q.value.equals&&q.value.equals(u.value)||q.value===u.value){if(0!==z)continue;r=q.frame}else r=u.frame;else{if(s=d[z-1],q.value.equals&&q.value.equals(s.value)||q.value===s.value)continue;r=m}if(r)for(let z=q.frame;z<=r;z+=g){if(O=e.Tools.FloatRound(z/B),O===I)continue;I=O,K=O;const N={key:0,repeatCount:0,loopMode:v.loopMode};n=v._interpolate(z,N),sS._SetInterpolatedValue(S,n,O,v,D,R,E,h,w)}}K&&(A.max=K)}static _ConvertFactorToVector3OrQuaternion(S,v,D,N,m){const B=sS._GetBasePositionRotationOrScale(v,N,m),g=D.targetProperty.split("."),E=g?g[1]:"",h=m?z.Quaternion.uv(B).normalize():z.Rv.uv(B);switch(E){case"x":case"y":case"z":h[E]=S;break;case"w":h.w=S;break;default:e.Tools.Error(`glTFAnimation: Unsupported component name "${E}"!`)}return h}static _SetInterpolatedValue(S,v,D,e,N,m,B,g,E){let h;B.push(D),"weights"!==N?(e.dataType===IS.b.ANIMATIONTYPE_FLOAT&&(v=this._ConvertFactorToVector3OrQuaternion(v,S,e,N,E)),"rotation"===N?(E?m=v:(h=v,z.Quaternion.RotationYawPitchRollToRef(h.y,h.x,h.z,m)),g.push(m.Oe())):(h=v,g.push(h.Oe()))):g.push([v])}static _CreateLinearOrStepAnimation(S,v,D,z,e,N){for(const m of v.getKeys())z.push(m.frame/v.framePerSecond),sS._AddKeyframeValue(m,v,e,D,S,N)}static _CreateCubicSplineAnimation(S,v,D,z,e,N){v.getKeys().forEach((function(m){z.push(m.frame/v.framePerSecond),sS._AddSplineTangent(AS.INTANGENT,e,D,"CUBICSPLINE",m,N),sS._AddKeyframeValue(m,v,e,D,S,N),sS._AddSplineTangent(AS.OUTTANGENT,e,D,"CUBICSPLINE",m,N)}))}static _GetBasePositionRotationOrScale(S,v,D){let e;if("rotation"===v)if(D){e=(S.rotationQuaternion??z.Quaternion.Identity()).Oe()}else{e=(S.rotation??z.Rv.Zero()).Oe()}else if("translation"===v){e=(S.position??z.Rv.Zero()).Oe()}else{e=(S.Me??z.Rv.One()).Oe()}return e}static _AddKeyframeValue(S,v,D,N,m,B){let g;const E=v.dataType;if(E===IS.b.ANIMATIONTYPE_VECTOR3){let v=S.value.Oe();if("rotation"===N){const S=z.Rv.uv(v);v=z.Quaternion.RotationYawPitchRoll(S.y,S.x,S.z).Oe()}D.push(v)}else if(E===IS.b.ANIMATIONTYPE_FLOAT){if("weights"===N)D.push([S.value]);else if(g=this._ConvertFactorToVector3OrQuaternion(S.value,m,v,N,B),g){if("rotation"===N){const S=B?g:z.Quaternion.RotationYawPitchRoll(g.y,g.x,g.z).normalize();D.push(S.Oe())}D.push(g.Oe())}}else E===IS.b.ANIMATIONTYPE_QUATERNION?D.push(S.value.normalize().Oe()):e.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(S,v,D){let z,e,N=!1;if("rotation"===v&&!D)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let m=0,B=S.length;m<B;++m)if(e=S[m],e.inTangent||e.outTangent)if(z){if("CUBICSPLINE"!==z){z="LINEAR",N=!0;break}}else z="CUBICSPLINE";else if(z){if("CUBICSPLINE"===z||e.interpolation&&1===e.interpolation&&"STEP"!==z){z="LINEAR",N=!0;break}}else z=e.interpolation&&1===e.interpolation?"STEP":"LINEAR";return z||(z="LINEAR"),{interpolationType:z,shouldBakeAnimation:N}}static _AddSplineTangent(S,v,D,e,N,m){let B;const g=S===AS.INTANGENT?N.inTangent:N.outTangent;if("CUBICSPLINE"===e){if("rotation"===D)if(g)if(m)B=g.Oe();else{const S=g;B=z.Quaternion.RotationYawPitchRoll(S.y,S.x,S.z).Oe()}else B=[0,0,0,0];else B="weights"===D?g?[g]:[0]:g?g.Oe():[0,0,0];v.push(B)}}static _CalculateMinMaxKeyFrames(S){let v=1/0,D=-1/0;return S.forEach((function(S){v=Math.min(v,S.frame),D=Math.max(D,S.frame)})),{min:v,max:D}}}function rS(S,v,D,N,m,B){const g={attributes:{},influence:S.influence,name:S.name},E=v.ie;if(!E)return e.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),g;const A=B?-1:1,w=z.Rv.Zero();let n=0,R=0;if(S.hasPositions){const N=S.getPositions(),B=E.getVerticesData(h.d.PositionKind);if(B){const S=new Float32Array(B.length),v=[1/0,1/0,1/0],e=[-1/0,-1/0,-1/0];R=B.length/3,n=0;for(let D=n;D<R;++D){const m=z.Rv.uv(B,3*D);z.Rv.uv(N,3*D).subtractToRef(m,w),w.x*=A,v[0]=Math.min(v[0],w.x),e[0]=Math.max(e[0],w.x),v[1]=Math.min(v[1],w.y),e[1]=Math.max(e[1],w.y),v[2]=Math.min(v[2],w.z),e[2]=Math.max(e[2],w.z),S[3*D]=w.x,S[3*D+1]=w.y,S[3*D+2]=w.z}const E=D.createBufferView(S,12),h=D.createAccessor(E,"VEC3",5126,N.length/3,0,{min:v,max:e});m.push(h),g.attributes.POSITION=m.length-1}else e.Tools.Warn(`Morph target positions for mesh ${v.name} were not exported. Mesh does not have position vertex data`)}if(S.hasNormals){const N=S.getNormals(),B=E.getVerticesData(h.d.NormalKind);if(B){const S=new Float32Array(B.length);R=B.length/3,n=0;for(let D=n;D<R;++D){const v=z.Rv.uv(B,3*D).normalize();z.Rv.uv(N,3*D).normalize().subtractToRef(v,w),S[3*D]=w.x*A,S[3*D+1]=w.y,S[3*D+2]=w.z}const v=D.createBufferView(S,12),e=D.createAccessor(v,"VEC3",5126,N.length/3,0);m.push(e),g.attributes.NORMAL=m.length-1}else e.Tools.Warn(`Morph target normals for mesh ${v.name} were not exported. Mesh does not have normals vertex data`)}if(S.hasTangents){const N=S.getTangents(),B=E.getVerticesData(h.d.TangentKind);if(B){R=B.length/4;const S=new Float32Array(3*R);n=0;for(let D=n;D<R;++D){const v=z.Rv.uv(B,4*D);l(v);const e=z.Rv.uv(N,3*D);l(e),e.subtractToRef(v,w),S[3*D]=w.x*A,S[3*D+1]=w.y,S[3*D+2]=w.z}const v=D.createBufferView(S,12),e=D.createAccessor(v,"VEC3",5126,R,0);m.push(e),g.attributes.TANGENT=m.length-1}else e.Tools.Warn(`Morph target tangents for mesh ${v.name} were not exported. Mesh does not have tangents vertex data`)}if(S.hasColors){const N=S.getColors(),B=E.getVerticesData(h.d.ColorKind),A=E.getVertexBuffer(h.d.ColorKind);if(B&&A){const S=A.getSize();R=B.length/S;const v=new Float32Array(R*S);n=0;for(let D=n;D<R;++D)if(3===S){const e=z.Rv.uv(B,D*S);z.Rv.uv(N,D*S).subtractToRef(e,w),v[3*D]=w.x,v[3*D+1]=w.y,v[3*D+2]=w.z}else if(4===S){const e=new z.Vector4,m=z.Vector4.uv(B,D*S);z.Vector4.uv(N,D*S).subtractToRef(m,e),v[4*D]=e.x,v[4*D+1]=e.y,v[4*D+2]=e.z,v[4*D+3]=e.w}else e.Tools.Warn(`Unsupported number of components for color attribute: ${S}`);const E=D.createBufferView(v,4*S),h=D.createAccessor(E,3===S?"VEC3":"VEC4",5126,R,0);m.push(h),g.attributes.COLOR_0=m.length-1}else e.Tools.Warn(`Morph target colors for mesh ${v.name} were not exported. Mesh does not have colors vertex data`)}return g}var dS=D(11904),xS=D(11776),WS=D(11757),pS=D(11329);class bS{}bS.DEFAULT_COLOR=I.qv.White(),bS.DEFAULT_WIDTH_ATTENUATED=1,bS.DEFAULT_WIDTH=.1;var kS=D(11595),ZS=D(11906);class iS{static ConvertPoints(S,v){if(S.length&&Array.isArray(S)&&"number"===typeof S[0])return[S];if(S.length&&Array.isArray(S[0])&&"number"===typeof S[0][0])return S;if(S.length&&!Array.isArray(S[0])&&S[0]instanceof z.Rv){const v=[];for(let D=0;D<S.length;D++){const z=S[D];v.push(z.x,z.y,z.z)}return[v]}if(S.length>0&&Array.isArray(S[0])&&S[0].length>0&&S[0][0]instanceof z.Rv){const v=[],D=S;for(const S of D)v.push(S.flatMap((S=>[S.x,S.y,S.z])));return v}if(S instanceof Float32Array){if(null!==v&&void 0!==v&&v.floatArrayStride){const D=[],z=3*v.floatArrayStride;for(let v=0;v<S.length;v+=z){const e=new Array(z);for(let D=0;D<z;D++)e[D]=S[v+D];D.push(e)}return D}return[Array.from(S)]}if(S.length&&S[0]instanceof Float32Array){const v=[];for(const D of S)v.push(Array.from(D));return v}return[]}static OmitZeroLengthPredicate(S,v,D){const z=[];return v.Ov(S).lengthSquared()>0&&z.push([S,v]),D.Ov(v).lengthSquared()>0&&z.push([v,D]),S.Ov(D).lengthSquared()>0&&z.push([D,S]),0===z.length?null:z}static OmitDuplicatesPredicate(S,v,D,z){const e=[];return iS._SearchInPoints(S,v,z)||e.push([S,v]),iS._SearchInPoints(v,D,z)||e.push([v,D]),iS._SearchInPoints(D,S,z)||e.push([D,S]),0===e.length?null:e}static _SearchInPoints(S,v,D){for(const m of D)for(let D=0;D<m.length;D++){var z,e,N;if(null!==(z=m[D])&&void 0!==z&&z.equals(S))if(null!==(e=m[D+1])&&void 0!==e&&e.equals(v)||null!==(N=m[D-1])&&void 0!==N&&N.equals(v))return!0}return!1}static MeshesToLines(S,v){const D=[];for(let e=0;e<S.length;e++){const N=S[e],m=N.getVerticesData(h.d.PositionKind),B=N.te();if(m&&B)for(let S=0,g=0;S<B.length;S++){const E=3*B[g++],h=3*B[g++],A=3*B[g++],w=new z.Rv(m[E],m[E+1],m[E+2]),n=new z.Rv(m[h],m[h+1],m[h+2]),R=new z.Rv(m[A],m[A+1],m[A+2]);if(v){const z=v(w,n,R,D,S,E,N,e,m,B);if(z)for(const S of z)D.push(S)}else D.push([w,n],[n,R],[R,w])}}return D}static ToVector3Array(S){if(Array.isArray(S[0])){const v=[],D=S;for(const S of D){const D=[];for(let v=0;v<S.length;v+=3)D.push(new z.Rv(S[v],S[v+1],S[v+2]));v.push(D)}return v}const v=S,D=[];for(let e=0;e<v.length;e+=3)D.push(new z.Rv(v[e],v[e+1],v[e+2]));return D}static ToNumberArray(S){return S.flatMap((S=>[S.x,S.y,S.z]))}static GetPointsCountInfo(S){const v=new Array(S.length);let D=0;for(let z=S.length;z--;)v[z]=S[z].length/3,D+=v[z];return{total:D,counts:v}}static GetLineLength(S){if(0===S.length)return 0;let v;v="number"===typeof S[0]?iS.ToVector3Array(S):S;const D=z.TmpVectors.Rv[0];let e=0;for(let z=0;z<v.length-1;z++){const S=v[z];e+=v[z+1].subtractToRef(S,D).length()}return e}static GetLineLengthArray(S){const v=new Float32Array(S.length/3);let D=0;for(let z=0,e=S.length/3-1;z<e;z++){let e=S[3*z+0],N=S[3*z+1],m=S[3*z+2];e-=S[3*z+3],N-=S[3*z+4],m-=S[3*z+5];D+=Math.sqrt(e*e+N*N+m*m),v[z+1]=D}return v}static SegmentizeSegmentByCount(S,v,D){const e=[],N=v.Ov(S),m=z.TmpVectors.Rv[0];m.Je(D);const B=z.TmpVectors.Rv[1];N.divideToRef(m,B);let g=S.clone();e.push(g);for(let z=0;z<D;z++)g=g.clone(),e.push(g.addInPlace(B));return e}static SegmentizeLineBySegmentLength(S,v){const D=S[0]instanceof z.Rv?iS.GetLineSegments(S):"number"===typeof S[0]?iS.GetLineSegments(iS.ToVector3Array(S)):S,e=[];for(const z of D)if(z.length>v){const S=iS.SegmentizeSegmentByCount(z.point1,z.point2,Math.ceil(z.length/v));for(const v of S)e.push(v)}else e.push(z.point1),e.push(z.point2);return e}static SegmentizeLineBySegmentCount(S,v){const D="number"===typeof S[0]?iS.ToVector3Array(S):S,z=iS.GetLineLength(D)/v;return iS.SegmentizeLineBySegmentLength(D,z)}static GetLineSegments(S){const v=[];for(let D=0;D<S.length-1;D++){const z=S[D],e=S[D+1],N=e.Ov(z).length();v.push({point1:z,point2:e,length:N})}return v}static GetMinMaxSegmentLength(S){const v=iS.GetLineSegments(S).sort((S=>S.length));return{min:v[0].length,max:v[v.length-1].length}}static GetPositionOnLineByVisibility(S,v,D){let e=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const N=v*D;let m=0,B=0;const g=S.length;for(let z=0;z<g;z++){if(N<=m+S[z].length){B=z;break}m+=S[z].length}const E=(N-m)/S[B].length;return S[B].point2.subtractToRef(S[B].point1,z.TmpVectors.Rv[0]),z.TmpVectors.Rv[1]=z.TmpVectors.Rv[0].multiplyByFloats(E,E,E),e||z.TmpVectors.Rv[1].addInPlace(S[B].point1),z.TmpVectors.Rv[1].clone()}static GetCircleLinePoints(S,v){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:S,N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/v;const m=[];for(let B=0;B<=v;B++)m.push(new z.Rv(Math.cos(B*N)*S,Math.sin(B*N)*e,D));return m}static GetBezierLinePoints(S,v,D,z){return kS.h.CreateQuadraticBezier(S,v,D,z).getPoints().flatMap((S=>[S.x,S.y,S.z]))}static GetArrowCap(S,v,D,z,e){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,m=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[S.clone(),S.add(v.multiplyByFloats(D,D,D))],widths:[z,e,N,m]}}static GetPointsFromText(S,v,D,z){let e=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const m=[],B=(0,ZS.d)(S,v,D,z);for(const g of B){for(const S of g.paths){const v=[],D=S.getPoints();for(const S of D)v.push(S.x,S.y,e);m.push(v)}if(N)for(const S of g.holes){const v=[],D=S.getPoints();for(const S of D)v.push(S.x,S.y,e);m.push(v)}}return m}static Color3toRGBAUint8(S){const v=new Uint8Array(4*S.length);for(let D=0,z=0;D<S.length;D++)v[z++]=255*S[D].r,v[z++]=255*S[D].g,v[z++]=255*S[D].b,v[z++]=255;return v}static CreateColorsTexture(S,v,D,z){const e=z.getEngine().getCaps().maxTextureSize??1,N=v.length>e?e:v.length,m=Math.ceil(v.length/e);m>1&&(v=[...v,...Array(N*m-v.length).fill(v[0])]);const B=iS.Color3toRGBAUint8(v),g=new d.e(B,N,m,R.e.TEXTUREFORMAT_RGBA,z,!1,!0,D);return g.name=S,g}static PrepareEmptyColorsTexture(S){if(!bS.EmptyColorsTexture){const v=new Uint8Array(4);bS.EmptyColorsTexture=new d.e(v,1,1,R.e.TEXTUREFORMAT_RGBA,S,!1,!1,d.e.NEAREST_NEAREST),bS.EmptyColorsTexture.name="grlEmptyColorsTexture"}return bS.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var S;null===(S=bS.EmptyColorsTexture)||void 0===S||S.dispose(),bS.EmptyColorsTexture=null}static BooleanToNumber(S){return S?1:0}}class tS extends WS.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class XS extends xS.b{isCompatible(S){return!0}constructor(S,v,D){var e;D=D||{color:bS.DEFAULT_COLOR};const N=new tS;N.GREASED_LINE_HAS_COLOR=!!D.color&&!D.useColors,N.GREASED_LINE_SIZE_ATTENUATION=D.sizeAttenuation??!1,N.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===D.colorDistributionType,N.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(v??S.xS()).useRightHandedSystem,N.GREASED_LINE_CAMERA_FACING=D.cameraFacing??!0,super(S,XS.GREASED_LINE_MATERIAL_NAME,200,N,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(e=D)||void 0===e?void 0:e.forceGLSL)||XS.ForceGLSL,this._scene=v??S.xS(),this._engine=this._scene.getEngine(),this._cameraFacing=D.cameraFacing??!0,this.visibility=D.visibility??1,this.useDash=D.useDash??!1,this.dashRatio=D.dashRatio??.5,this.dashOffset=D.dashOffset??0,this.width=D.width?D.width:D.sizeAttenuation?bS.DEFAULT_WIDTH_ATTENUATED:bS.DEFAULT_WIDTH,this._sizeAttenuation=D.sizeAttenuation??!1,this.colorMode=D.colorMode??0,this._color=D.color??null,this.useColors=D.useColors??!1,this._colorsDistributionType=D.colorDistributionType??0,this.colorsSampling=D.colorsSampling??d.e.NEAREST_NEAREST,this._colors=D.kS??null,this.dashCount=D.dashCount??1,this.resolution=D.resolution??new z.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),D.colorsTexture?this.colorsTexture=D.colorsTexture:this._colors?this.colorsTexture=iS.CreateColorsTexture(`${S.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??bS.DEFAULT_COLOR,iS.PrepareEmptyColorsTexture(this._scene)),this._engine.Se.add((()=>{iS.DisposeEmptyColorsTexture()}))}getAttributes(S){S.push("grl_offsets"),S.push("grl_widths"),S.push("grl_colorPointers"),S.push("grl_counters"),this._cameraFacing?(S.push("grl_previousAndSide"),S.push("grl_nextAndCounters")):S.push("grl_slopes")}getSamplers(S){S.push("grl_colors")}getActiveTextures(S){this.colorsTexture&&S.push(this.colorsTexture)}getUniforms(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const v=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&v.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===S&&v.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:v,vertex:this._cameraFacing&&this._isGLSL(S)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(S)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(S){if(this._cameraFacing){S.pe("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||S.pe("viewProjection",this._scene.getTransformMatrix());const v=z.TmpVectors.Vector4[0];v.x=this._aspect,v.y=this._resolution.x,v.z=this._resolution.y,v.w=this.width,S.updateVector4("grl_aspect_resolution_lineWidth",v)}const v=z.TmpVectors.Vector4[0];v.x=iS.BooleanToNumber(this.useDash),v.y=this._dashArray,v.z=this.dashOffset,v.w=this.dashRatio,S.updateVector4("grl_dashOptions",v);const D=z.TmpVectors.Vector4[1];D.x=this.colorMode,D.y=this.visibility,D.z=this.colorsTexture?this.colorsTexture.getSize().width:0,D.w=iS.BooleanToNumber(this.useColors),S.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",D),this._color&&S.updateColor3("grl_singleColor",this._color);const e=this.colorsTexture??bS.EmptyColorsTexture;S.setTexture("grl_colors",e),S.updateFloat2("grl_textureSize",(null===e||void 0===e?void 0:e.getSize().width)??1,(null===e||void 0===e?void 0:e.getSize().height)??1)}prepareDefines(S,v,D){S.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,S.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,S.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,S.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=v.useRightHandedSystem,S.GREASED_LINE_CAMERA_FACING=this._cameraFacing,S.GREASED_LINE_USE_OFFSETS=!!D.offsets}getClassName(){return XS.GREASED_LINE_MATERIAL_NAME}getCustomCode(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(v)?function(S,v){if("vertex"===S){const S={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return v&&(S["!gl_Position\\=viewProjection\\*worldPos;"]="//"),S}return"fragment"===S?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(S,this._cameraFacing):function(S,v){if("vertex"===S){const S={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return v&&(S["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),S}return"fragment"===S?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(S,this._cameraFacing)}dispose(){var S;null===(S=this.colorsTexture)||void 0===S||S.dispose(),super.dispose()}get kS(){return this._colors}set kS(S){this.setColors(S)}setColors(S){var v;let D=arguments.length>1&&void 0!==arguments[1]&&arguments[1],z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const e=(null===(v=this._colors)||void 0===v?void 0:v.length)??0;var N;if(this._colors=S,null!==S&&0!==S.length){if(!D||z)if(this.colorsTexture&&e===S.length&&!z){const v=iS.Color3toRGBAUint8(S);this.colorsTexture.update(v)}else{var m;null===(m=this.colorsTexture)||void 0===m||m.dispose(),this.colorsTexture=iS.CreateColorsTexture(`${this._material.name}-colors-texture`,S,this.colorsSampling,this._scene)}}else null===(N=this.colorsTexture)||void 0===N||N.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(S){this._dashCount=S,this._dashArray=1/S}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(S){this._sizeAttenuation=S,this.markAllDefinesAsDirty()}get color(){return this._color}set color(S){this.setColor(S)}setColor(S){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==S||null!==this._color&&null===S?(this._color=S,v||this.markAllDefinesAsDirty()):this._color=S}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(S){this._colorsDistributionType=S,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(S){this._aspect=S.x/S.y,this._resolution=S}serialize(){const S=super.serialize(),v={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(v.kS=this._colors),this._color&&(v.color=this._color),S.greasedLineMaterialOptions=v,S}parse(S,v,D){var z;super.parse(S,v,D);const e=S.greasedLineMaterialOptions;null===(z=this.colorsTexture)||void 0===z||z.dispose(),e.color&&this.setColor(e.color,!0),e.colorDistributionType&&(this.colorsDistributionType=e.colorDistributionType),e.kS&&(this.kS=e.kS),e.colorsSampling&&(this.colorsSampling=e.colorsSampling),e.colorMode&&(this.colorMode=e.colorMode),e.useColors&&(this.useColors=e.useColors),e.visibility&&(this.visibility=e.visibility),e.useDash&&(this.useDash=e.useDash),e.dashCount&&(this.dashCount=e.dashCount),e.dashRatio&&(this.dashRatio=e.dashRatio),e.dashOffset&&(this.dashOffset=e.dashOffset),e.width&&(this.width=e.width),e.sizeAttenuation&&(this.sizeAttenuation=e.sizeAttenuation),e.resolution&&(this.resolution=e.resolution),this.kS?this.colorsTexture=iS.CreateColorsTexture(`${this._material.name}-colors-texture`,this.kS,this.colorsSampling,v):iS.PrepareEmptyColorsTexture(v),this.markAllDefinesAsDirty()}copyTo(S){var v;const D=S;null===(v=D.colorsTexture)||void 0===v||v.dispose(),this._colors&&(D.colorsTexture=iS.CreateColorsTexture(`${D._material.name}-colors-texture`,this._colors,D.colorsSampling,this._scene)),D.setColor(this.color,!0),D.colorsDistributionType=this.colorsDistributionType,D.colorsSampling=this.colorsSampling,D.colorMode=this.colorMode,D.useColors=this.useColors,D.visibility=this.visibility,D.useDash=this.useDash,D.dashCount=this.dashCount,D.dashRatio=this.dashRatio,D.dashOffset=this.dashOffset,D.width=this.width,D.sizeAttenuation=this.sizeAttenuation,D.resolution=this.resolution,D.markAllDefinesAsDirty()}_isGLSL(S){return 0===S||this._forceGLSL}}XS.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",XS.ForceGLSL=!1,(0,pS.f)(`BABYLON.${XS.GREASED_LINE_MATERIAL_NAME}`,XS);var aS=D(11806),oS=D(11193),MS=D(11616),cS=D(11309);class JS extends MS.ShaderMaterial{constructor(S,v,e){const N=v.getEngine(),m=N.isWebGPU&&!(e.forceGLSL||JS.ForceGLSL),B=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];v.useRightHandedSystem&&B.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const g=["position","grl_widths","grl_offsets","grl_colorPointers"];e.cameraFacing?(B.push("GREASED_LINE_CAMERA_FACING"),g.push("grl_previousAndSide","grl_nextAndCounters")):(g.push("grl_slopes"),g.push("grl_counters"));const E=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(m||E.push("world","viewProjection","view","projection"),super(S,v,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:m?["Scene","Mesh"]:void 0,attributes:g,uniforms:E,samplers:m?[]:["grlColors"],defines:B,extraInitializationsAsync:async()=>{m?await Promise.all([D.e(66).then(D.bind(D,14545)),D.e(75).then(D.bind(D,14548))]):await Promise.all([D.e(69).then(D.bind(D,14553)),D.e(76).then(D.bind(D,14562))])},shaderLanguage:m?1:0}),this._color=I.qv.White(),this._colorsDistributionType=0,this._colorsTexture=null,e=e||{color:bS.DEFAULT_COLOR},this.visibility=e.visibility??1,this.useDash=e.useDash??!1,this.dashRatio=e.dashRatio??.5,this.dashOffset=e.dashOffset??0,this.dashCount=e.dashCount??1,this.width=e.width?e.width:e.sizeAttenuation&&e.cameraFacing?bS.DEFAULT_WIDTH_ATTENUATED:bS.DEFAULT_WIDTH,this.sizeAttenuation=e.sizeAttenuation??!1,this.color=e.color??I.qv.White(),this.useColors=e.useColors??!1,this.colorsDistributionType=e.colorDistributionType??0,this.colorsSampling=e.colorsSampling??d.e.NEAREST_NEAREST,this.colorMode=e.colorMode??0,this._colors=e.kS??null,this._cameraFacing=e.cameraFacing??!0,this.resolution=e.resolution??new z.Vector2(N.getRenderWidth(),N.getRenderHeight()),e.colorsTexture?this.colorsTexture=e.colorsTexture:this._colors?this.colorsTexture=iS.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,v):(this._color=this._color??bS.DEFAULT_COLOR,this.colorsTexture=iS.PrepareEmptyColorsTexture(v)),m){const S=new cS.b;S.setParameters(),S.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",S)}N.Se.add((()=>{iS.DisposeEmptyColorsTexture()}))}dispose(){var S;null===(S=this._colorsTexture)||void 0===S||S.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new z.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get kS(){return this._colors}set kS(S){this.setColors(S)}setColors(S){var v;let D=arguments.length>1&&void 0!==arguments[1]&&arguments[1],z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const e=(null===(v=this._colors)||void 0===v?void 0:v.length)??0;var N;if(this._colors=S,null!==S&&0!==S.length){if(!D||z)if(this._colorsTexture&&e===S.length&&!z){const v=iS.Color3toRGBAUint8(S);this._colorsTexture.update(v)}else{var m;null===(m=this._colorsTexture)||void 0===m||m.dispose(),this.colorsTexture=iS.CreateColorsTexture(`${this.name}-colors-texture`,S,this.colorsSampling,this.xS())}}else null===(N=this._colorsTexture)||void 0===N||N.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(S){this._colorsTexture=S,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(S){this._width=S,this.setFloat("grlWidth",S)}get useColors(){return this._useColors}set useColors(S){this._useColors=S,this.setFloat("grlUseColors",iS.BooleanToNumber(S))}get colorsSampling(){return this._colorsSampling}set colorsSampling(S){this._colorsSampling=S}get visibility(){return this._visibility}set visibility(S){this._visibility=S,this.setFloat("grlVisibility",S)}get useDash(){return this._useDash}set useDash(S){this._useDash=S,this.setFloat("grlUseDash",iS.BooleanToNumber(S))}get dashOffset(){return this._dashOffset}set dashOffset(S){this._dashOffset=S,this.setFloat("grlDashOffset",S)}get dashRatio(){return this._dashRatio}set dashRatio(S){this._dashRatio=S,this.setFloat("grlDashRatio",S)}get dashCount(){return this._dashCount}set dashCount(S){this._dashCount=S,this._dashArray=1/S,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(S){this._sizeAttenuation=S,this.setFloat("grlSizeAttenuation",iS.BooleanToNumber(S))}get color(){return this._color}set color(S){this.setColor(S)}setColor(S){S=S??bS.DEFAULT_COLOR,this._color=S,this.setColor3("grlColor",S)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(S){this._colorsDistributionType=S,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(S){this._colorMode=S,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(S){this._resolution=S,this.setVector2("grlResolution",S),this.setFloat("grlAspect",S.x/S.y)}serialize(){const S=super.serialize(),v={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(v.kS=this._colors),S.greasedLineMaterialOptions=v,S}parse(S,v,D){var z;const e=S.greasedLineMaterialOptions;null===(z=this._colorsTexture)||void 0===z||z.dispose(),e.color&&(this.color=e.color),e.colorDistributionType&&(this.colorsDistributionType=e.colorDistributionType),e.colorsSampling&&(this.colorsSampling=e.colorsSampling),e.colorMode&&(this.colorMode=e.colorMode),e.useColors&&(this.useColors=e.useColors),e.visibility&&(this.visibility=e.visibility),e.useDash&&(this.useDash=e.useDash),e.dashCount&&(this.dashCount=e.dashCount),e.dashRatio&&(this.dashRatio=e.dashRatio),e.dashOffset&&(this.dashOffset=e.dashOffset),e.width&&(this.width=e.width),e.sizeAttenuation&&(this.sizeAttenuation=e.sizeAttenuation),e.resolution&&(this.resolution=e.resolution),e.kS?this.colorsTexture=iS.CreateColorsTexture(`${this.name}-colors-texture`,e.kS,this.colorsSampling,this.xS()):this.colorsTexture=iS.PrepareEmptyColorsTexture(v),this._cameraFacing=e.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var HS,TS,GS;JS.ForceGLSL=!1,function(S){S[S.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",S[S.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(HS||(HS={})),function(S){S[S.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",S[S.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",S[S.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(TS||(TS={})),function(S){S[S.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",S[S.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",S[S.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",S[S.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",S[S.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(GS||(GS={}));class YS extends qS.e{constructor(S,v,D){super(S,v,null,null,!1,!1),this.name=S,this._options=D,this._lazy=!1,this._updatable=!1,this._engine=v.getEngine(),this._lazy=D.lazy??!1,this._updatable=D.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=D.colorPointers??[],this._widths=D.widths??new Array(D.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(S){let v=0;for(const z of this._points)v+=z.length;const D=v/3*2-this._widths.length;for(let z=0;z<D;z++)this._widths.push(S)}updateLazy(){var S,v;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(S=this._options.ribbonOptions)||void 0===S?void 0:S.smoothShading),!this.XS&&this.refreshBoundingInfo(),null===(v=this.greasedLineMaterial)||void 0===v||v.updateLazy()}addPoints(S,v){for(const D of S)this._points.push(D);this._lazy||this.setPoints(this._points,v)}dispose(S){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(S,v)}isLazy(){return this._lazy}get ZS(){return this._uvs}set ZS(S){this._uvs=S instanceof Float32Array?S:new Float32Array(S),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(S){this.material instanceof JS&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===S||void 0===S?void 0:S.length)>0),this._offsets=S,this._offsetsBuffer?this._offsetsBuffer.update(S):this._createOffsetsBuffer(S)}get widths(){return this._widths}set widths(S){this._widths=S,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(S)}get colorPointers(){return this._colorPointers}set colorPointers(S){this._colorPointers=S,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(S)}get greasedLineMaterial(){var S,v;if(this.material&&this.material instanceof JS)return this.material;const D=null===(S=this.material)||void 0===S||null===(v=S.pluginManager)||void 0===v?void 0:v.getPlugin(XS.GREASED_LINE_MATERIAL_NAME);return D||void 0}get points(){const S=[];return oS.e.DeepCopy(this._points,S),S}setPoints(S,v){this._points=iS.ConvertPoints(S,(null===v||void 0===v?void 0:v.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==v&&void 0!==v&&v.colorPointers||this._updateColorPointers(),this._setPoints(this._points,v)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,ZS:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(S){super.serialize(S),S.type=this.getClassName(),S.lineOptions=this._createLineOptions()}_createVertexBuffers(){let S=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new aS.e;return v.pS=this._vertexPositions,v.indices=this._indices,v.ZS=this._uvs,S&&(v.bS=[],aS.e.ComputeNormals(this._vertexPositions,this._indices,v.bS)),v.tS(this,this._options.updatable),v}_createOffsetsBuffer(S){const v=this._scene.getEngine(),D=new h.b(v,S,this._updatable,3);this.setVerticesBuffer(D.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=D}}class jS{constructor(S,v){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=S,this.wasAddedByNoopNode=v}getIndicesAccessor(S,v,D,z,e){var N,m,B,g;return null===(N=this._indicesAccessorMap.get(S))||void 0===N||null===(m=N.get(v))||void 0===m||null===(B=m.get(D))||void 0===B||null===(g=B.get(z))||void 0===g?void 0:g.get(e)}setIndicesAccessor(S,v,D,z,e,N){let m=this._indicesAccessorMap.get(S);m||(m=new Map,this._indicesAccessorMap.set(S,m));let B=m.get(v);B||(B=new Map,m.set(v,B));let g=B.get(D);g||(g=new Map,B.set(D,g));let E=g.get(z);E||(E=new Map,g.set(z,E)),E.set(e,N)}pushExportedNode(S){this._exportedNodes.has(S)||this._exportedNodes.add(S)}getNodesSet(){return this._exportedNodes}getVertexBufferView(S){return this._vertexBufferViewMap.get(S)}setVertexBufferView(S,v){this._vertexBufferViewMap.set(S,v)}setRemappedBufferView(S,v,D){this._remappedBufferView.set(S,new Map),this._remappedBufferView.get(S).set(v,D)}getRemappedBufferView(S,v){var D;return null===(D=this._remappedBufferView.get(S))||void 0===D?void 0:D.get(v)}getVertexAccessor(S,v,D){var z,e;return null===(z=this._vertexAccessorMap.get(S))||void 0===z||null===(e=z.get(v))||void 0===e?void 0:e.get(D)}setVertexAccessor(S,v,D,z){let e=this._vertexAccessorMap.get(S);e||(e=new Map,this._vertexAccessorMap.set(S,e));let N=e.get(v);N||(N=new Map,e.set(v,N)),N.set(D,z)}hasVertexColorAlpha(S){return this._vertexMapColorAlpha.get(S)||!1}setHasVertexColorAlpha(S,v){return this._vertexMapColorAlpha.set(S,v)}getMesh(S){return this._meshMap.get(S)}setMesh(S,v){this._meshMap.set(S,v)}bindMorphDataToMesh(S,v){const D=this._meshMorphTargetMap.get(S)||[];this._meshMorphTargetMap.set(S,D),-1===D.indexOf(v)&&D.push(v)}getMorphTargetsFromMesh(S){return this._meshMorphTargetMap.get(S)}}class VS{_ApplyExtension(S,v,D,z){if(D>=v.length)return Promise.resolve(S);const e=z(v[D],S);return e?e.then((async S=>S?await this._ApplyExtension(S,v,D+1,z):null)):this._ApplyExtension(S,v,D+1,z)}_ApplyExtensions(S,v){const D=[];for(const z of VS._ExtensionNames)D.push(this._extensions[z]);return this._ApplyExtension(S,D,0,v)}_extensionsPreExportTextureAsync(S,v,D){return this._ApplyExtensions(v,((v,z)=>v.preExportTextureAsync&&v.preExportTextureAsync(S,z,D)))}_extensionsPostExportNodeAsync(S,v,D,z,e){return this._ApplyExtensions(v,((v,N)=>v.postExportNodeAsync&&v.postExportNodeAsync(S,N,D,z,e,this._bufferManager)))}_extensionsPostExportMaterialAsync(S,v,D){return this._ApplyExtensions(v,((v,z)=>v.postExportMaterialAsync&&v.postExportMaterialAsync(S,z,D)))}_extensionsPostExportMaterialAdditionalTextures(S,v,D){const z=[];for(const e of VS._ExtensionNames){const N=this._extensions[e];N.postExportMaterialAdditionalTextures&&z.push(...N.postExportMaterialAdditionalTextures(S,v,D))}return z}_extensionsPostExportTextures(S,v,D){for(const z of VS._ExtensionNames){const e=this._extensions[z];e.postExportTexture&&e.postExportTexture(S,v,D)}}_extensionsPostExportMeshPrimitive(S){for(const v of VS._ExtensionNames){const D=this._extensions[v];D.postExportMeshPrimitive&&D.postExportMeshPrimitive(S,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const S of VS._ExtensionNames){const v=this._extensions[S];v.preGenerateBinaryAsync&&await v.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(S){for(const v of VS._ExtensionNames){const D=this._extensions[v];D.enabled&&S(D)}}_extensionsOnExporting(){this._forEachExtensions((S=>{var v,D,z;S.wasUsed&&((v=this._glTF).extensionsUsed||(v.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(S.name)&&this._glTF.extensionsUsed.push(S.name),S.required&&((D=this._glTF).extensionsRequired||(D.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(S.name)&&this._glTF.extensionsRequired.push(S.name)),(z=this._glTF).extensions||(z.extensions={}),S.onExporting&&S.onExporting())}))}_loadExtensions(){for(const S of VS._ExtensionNames){const v=VS._ExtensionFactories[S](this);this._extensions[S]=v}}constructor(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:O.c.LastCreatedScene,v=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${R.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new c(this),this._extensions={},this._bufferManager=new hS,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!S)throw new Error("No scene available to export");this._babylonScene=S,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:S=>{var v;return null===S||void 0===S||null===(v=S.me)||void 0===v?void 0:v.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...v},this._loadExtensions()}dispose(){for(const S in this._extensions){this._extensions[S].dispose()}}get options(){return this._options}static RegisterExtension(S,v){VS.UnregisterExtension(S)&&e.Tools.Warn(`Extension with the name ${S} already exists`),VS._ExtensionFactories[S]=v,VS._ExtensionNames.push(S)}static UnregisterExtension(S){if(!VS._ExtensionFactories[S])return!1;delete VS._ExtensionFactories[S];const v=VS._ExtensionNames.indexOf(S);return-1!==v&&VS._ExtensionNames.splice(v,1),!0}_generateJSON(S,v,D){const z={byteLength:S};return z.byteLength&&(this._glTF.buffers=[z]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Iv=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(z.uri=v+".bin"),D?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(S){const v=await this._generateBinaryAsync();this._extensionsOnExporting();const D=this._generateJSON(v.byteLength,S,!0),z=new Blob([v],{type:"application/octet-stream"}),e=S+".gltf",N=S+".bin",m=new E;if(m.files[e]=D,m.files[N]=z,this._imageData)for(const B in this._imageData)m.files[B]=new Blob([this._imageData[B].data],{type:this._imageData[B].mimeType});return m}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(S){const v=S%4;return 0===v?v:4-v}async generateGLBAsync(S){this._shouldUseGlb=!0;const v=await this._generateBinaryAsync();this._extensionsOnExporting();const D=this._generateJSON(v.byteLength),z=S+".glb";let e,N=D.length;if("undefined"!==typeof TextEncoder){e=(new TextEncoder).encode(D),N=e.length}const m=this._getPadding(N),B=this._getPadding(v.byteLength),g=28+N+m+v.byteLength+B,h=new gS(g);if(h.writeUInt32(1179937895),h.writeUInt32(2),h.writeUInt32(g),h.writeUInt32(N+m),h.writeUInt32(1313821514),e)h.writeTypedArray(e);else{const S="_".charCodeAt(0);for(let v=0;v<N;++v){const z=D.charCodeAt(v);z!=D.codePointAt(v)?h.writeUInt8(S):h.writeUInt8(z)}}for(let E=0;E<m;++E)h.writeUInt8(32);h.writeUInt32(v.byteLength+B),h.writeUInt32(5130562),h.writeTypedArray(v);for(let E=0;E<B;++E)h.writeUInt8(0);const A=new E;return A.files[z]=new Blob([h.getOutputData()],{type:"application/octet-stream"}),A}_setNodeTransformation(S,v,D){if(v.getPivotPoint().equalsWithEpsilon(Y,G.e)||e.Tools.Warn("Pivot points are not supported in the glTF serializer"),!v.position.equalsWithEpsilon(Y,G.e)){const e=z.TmpVectors.Rv[0].N(v.position);D&&P(e),S.translation=e.Oe()}v.Me.equalsWithEpsilon(V,G.e)||(S.scale=v.Me.Oe());const N=v.rotationQuaternion||z.Quaternion.FromEulerAngles(v.rotation.x,v.rotation.y,v.rotation.z);N.equalsWithEpsilon(j,G.e)||(D&&Q(N),S.rotation=N.normalize().Oe())}_setCameraTransformation(S,v,D){if(!v.position.equalsWithEpsilon(Y,G.e)){const e=z.TmpVectors.Rv[0].N(v.position);D&&P(e),S.translation=e.Oe()}const e=v.rotationQuaternion||z.Quaternion.FromEulerAngles(v.rotation.x,v.rotation.y,v.rotation.z);D&&Q(e),this._babylonScene.useRightHandedSystem||L(e),e.equalsWithEpsilon(j,G.e)||(S.rotation=e.Oe())}_listAvailableCameras(){for(const S of this._babylonScene.cameras){const v={type:S.mode===wS.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(S.name&&(v.name=S.name),"perspective"===v.type)v.perspective={aspectRatio:S.getEngine().getAspectRatio(S),yfov:S.fovMode===wS.b.FOVMODE_VERTICAL_FIXED?S.fov:S.fov*S.getEngine().getAspectRatio(S),znear:S.xe,zfar:S.maxZ};else if("orthographic"===v.type){const D=S.orthoLeft&&S.orthoRight?.5*(S.orthoRight-S.orthoLeft):.5*S.getEngine().getRenderWidth(),z=S.orthoBottom&&S.orthoTop?.5*(S.orthoTop-S.orthoBottom):.5*S.getEngine().getRenderHeight();v.orthographic={xmag:D,ymag:z,znear:S.xe,zfar:S.maxZ}}this._camerasMap.set(S,v)}}_exportAndAssignCameras(){const S=Array.from(this._camerasMap.values());for(const v of S){const S=this._nodesCameraMap.get(v);if(void 0!==S){this._cameras.push(v);for(const v of S)v.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const S of this._babylonScene.skeletons){if(S.bones.length<=0)continue;const v={joints:[]};this._skinMap.set(S,v)}}_exportAndAssignSkeletons(){for(const S of this._babylonScene.skeletons){if(S.bones.length<=0)continue;const v=this._skinMap.get(S);if(void 0==v)continue;const D={},z=[];let N=-1;for(let e=0;e<S.bones.length;++e){const v=S.bones[e],z=v.getIndex()??e;-1!==z&&(D[z]=v,z>N&&(N=z))}for(let S=0;S<=N;++S){const N=D[S];z.push(N.getAbsoluteInverseBindMatrix());const m=N.getTransformNode();if(null!==m){const S=this._nodeMap.get(m);m&&null!==S&&void 0!==S?v.joints.push(S):e.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else e.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const m=this._nodesSkinMap.get(v);if(v.joints.length>0&&void 0!==m){const S=64*z.length,D=new Float32Array(S/4);z.forEach(((S,v)=>{D.set(S.m,16*v)}));const e=this._bufferManager.createBufferView(D);this._accessors.push(this._bufferManager.createAccessor(e,"MAT4",5126,z.length)),v.inverseBindMatrices=this._accessors.length-1,this._skins.push(v);for(const v of m)v.skin=this._skins.length-1}}}async _exportSceneAsync(){const S={nodes:[]};if(this._babylonScene.metadata){const v=this._options.metadataSelector(this._babylonScene.metadata);v&&(S.extras=v)}const v=new Array,D=new Array,z=new Array;for(const B of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&mS(B,this._babylonScene.useRightHandedSystem)?z.push(...B.getChildren()):this._babylonScene.useRightHandedSystem?v.push(B):D.push(B);this._listAvailableCameras(),this._listAvailableSkeletons();const e=new jS(!0,!1);S.nodes.push(...await this._exportNodesAsync(D,e));const N=new jS(!1,!1);S.nodes.push(...await this._exportNodesAsync(v,N));const m=new jS(!1,!0);S.nodes.push(...await this._exportNodesAsync(z,m)),S.nodes.length&&this._scenes.push(S),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&sS._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,e.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(S){let v=this._shouldExportNodeMap.get(S);return void 0===v&&(v=this._options.shouldExportNode(S),this._shouldExportNodeMap.set(S,v)),v}async _exportNodesAsync(S,v){const D=new Array;this._exportBuffers(S,v);for(const z of S)await this._exportNodeAsync(z,D,v);return D}_collectBuffers(S,v,D,z,e){if(this._shouldExportNode(S)&&S instanceof w.e&&S.ie){const N=S.ie.getVertexBuffers();if(N)for(const z in N){if(!C(z))continue;const m=N[z];e.setHasVertexColorAlpha(m,S.hasVertexAlpha);const B=m._buffer,g=v.get(B)||[];v.set(B,g),-1===g.indexOf(m)&&g.push(m);const E=D.get(m)||[];D.set(m,E),-1===E.indexOf(S)&&E.push(S)}const m=S.morphTargetManager;if(m)for(let v=0;v<m.numTargets;v++){const D=m.getTarget(v),e=z.get(D)||[];z.set(D,e),-1===e.indexOf(S)&&e.push(S)}}for(const N of S.getChildren())this._collectBuffers(N,v,D,z,e)}_exportBuffers(S,v){const D=new Map,z=new Map,e=new Map;for(const B of S)this._collectBuffers(B,D,z,e,v);const N=Array.from(D.keys());for(const B of N){const S=B.getData();if(!S)throw new Error("Buffer data is not available");const e=D.get(B);if(!e)continue;const N=e[0].byteStride;if(e.some((S=>S.byteStride!==N)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const m=DS(S).slice();for(const v of e){const S=z.get(v),{byteOffset:D,byteStride:e,componentCount:N,type:B,count:g,normalized:E,kind:A}=y(v,S);switch(A){case h.d.NormalKind:case h.d.TangentKind:(0,J.h)(m,D,e,N,B,g,E,(S=>{const v=Math.sqrt(S[0]*S[0]+S[1]*S[1]+S[2]*S[2]);if(v>0){const D=1/v;S[0]*=D,S[1]*=D,S[2]*=D}}));break;case h.d.ColorKind:{const v=S.filter((S=>S.material instanceof OS.Kv||null==S.material)).length;if(0==v)break;if(v!=S.length){H.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}B==h.d.UNSIGNED_BYTE&&H.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const z=new I.qv,A=new I.Ge,w=this._babylonScene.getEngine().useExactSrgbConversions;(0,J.h)(m,D,e,N,B,g,E,(S=>{3===S.length?(z.RD(S,0),z.toLinearSpaceToRef(z,w),z.toArray(S,0)):(A.RD(S,0),A.toLinearSpaceToRef(A,w),A.toArray(S,0))}))}}}if(v.convertToRightHanded){for(const S of e){const v=z.get(S),{byteOffset:D,byteStride:e,componentCount:N,type:B,count:g,normalized:E,kind:A}=y(S,v);switch(A){case h.d.PositionKind:case h.d.NormalKind:case h.d.TangentKind:(0,J.h)(m,D,e,N,B,g,E,(S=>{S[0]=-S[0]}))}}v.convertedToRightHandedBuffers.set(B,m)}const g=this._bufferManager.createBufferView(m,N);v.setVertexBufferView(B,g);const E=new Map;for(const v of e){const S=z.get(v),{kind:D,totalVertices:e}=y(v,S);switch(D){case h.d.MatricesIndicesKind:case h.d.MatricesIndicesExtraKind:if(v.type==h.d.FLOAT){const S=v.getFloatData(e);null!==S&&E.set(v,S)}}}0!==E.size&&H.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const A=Array.from(E.keys());for(const D of A){const S=E.get(D);if(!S)continue;const z=S.some((S=>S>=256)),e=new(z?Uint16Array:Uint8Array)(S.length);for(let v=0;v<S.length;v++)e[v]=S[v];const N=this._bufferManager.createBufferView(e,4*(z?2:1));v.setRemappedBufferView(B,D,N)}}const m=Array.from(e.keys());for(const B of m){const S=e.get(B);if(!S)continue;const D=rS(B,S[0],this._bufferManager,this._bufferViews,this._accessors,v.convertToRightHanded);for(const z of S)v.bindMorphDataToMesh(z,D)}}async _exportNodeAsync(S,v,D){let z=this._nodeMap.get(S);if(void 0!==z)return void(v.includes(z)||v.push(z));const e=await this._createNodeAsync(S,D);if(e){z=this._nodes.length,this._nodes.push(e),this._nodeMap.set(S,z),D.pushExportedNode(S),v.push(z);const N={name:"runtime animations",channels:[],samplers:[]},m=[];this._babylonScene.animationGroups.length||(sS._CreateMorphTargetAnimationFromMorphTargetAnimations(S,N,m,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,D.convertToRightHanded,this._options.shouldExportAnimation),S.animations.length&&sS._CreateNodeAnimationFromNodeAnimations(S,N,m,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,D.convertToRightHanded,this._options.shouldExportAnimation)),N.channels.length&&N.samplers.length&&this._animations.push(N),m.forEach((S=>{S.channels.length&&S.samplers.length&&this._animations.push(S)}))}const N=e?[]:v;for(const m of S.getChildren())await this._exportNodeAsync(m,N,D);e&&N.length&&(e.children=N)}async _createNodeAsync(S,v){if(!this._shouldExportNode(S))return null;const D={};if(S.name&&(D.name=S.name),S.metadata){const v=this._options.metadataSelector(S.metadata);v&&(D.extras=v)}if(S instanceof A.b&&(this._setNodeTransformation(D,S,v.convertToRightHanded),S instanceof w.e)){const e=S instanceof n.c?S.sourceMesh:S;if(e.he&&e.he.length>0&&(D.mesh=await this._exportMeshAsync(e,v)),S.skeleton){const v=this._skinMap.get(S.skeleton);var z;if(void 0!==v)void 0===this._nodesSkinMap.get(v)&&this._nodesSkinMap.set(v,[]),null===(z=this._nodesSkinMap.get(v))||void 0===z||z.push(D)}}if(S instanceof T.d){const z=this._camerasMap.get(S);if(z){var e;void 0===this._nodesCameraMap.get(z)&&this._nodesCameraMap.set(z,[]),this._setCameraTransformation(D,S,v.convertToRightHanded);const m=S.parent;if(null!==m&&vS(S,m)){const S=this._nodeMap.get(m);if(void 0!==S){var N;const v=this._nodes[S];return SS(D,v),null===(N=this._nodesCameraMap.get(z))||void 0===N||N.push(v),null}}null===(e=this._nodesCameraMap.get(z))||void 0===e||e.push(D)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",D,S,this._nodeMap,v.convertToRightHanded)?D:(H.b.Warn(`Not exporting node ${S.name}`),null)}_exportIndices(S,v,D,z,e,m,B,g,E){let h=S;E.mode=F(m);const A=B!==N.d.CounterClockWiseSideOrientation,w=!g.wasAddedByNoopNode&&A,n=function(S){switch(S){case N.d.TriangleFillMode:case N.d.TriangleStripDrawMode:case N.d.TriangleFanDrawMode:return!0}return!1}(m)&&w;if(n){if(m===N.d.TriangleStripDrawMode||m===N.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");E.mode=F(m);const B=v?new Uint32Array(z):new Uint16Array(z);if(S)for(let v=0;v+2<z;v+=3)B[v]=S[D+v]+e,B[v+1]=S[D+v+2]+e,B[v+2]=S[D+v+1]+e;else for(let S=0;S+2<z;S+=3)B[S]=S,B[S+1]=S+2,B[S+2]=S+1;h=B}else if(S&&0!==e){const N=v?new Uint32Array(z):new Uint16Array(z);for(let v=0;v<z;v++)N[v]=S[D+v]+e;h=N}if(h){let N=g.getIndicesAccessor(S,D,z,e,n);if(void 0===N){const m=function(S,v,D,z){if(S instanceof Uint16Array||S instanceof Uint32Array)return S;if(S instanceof Int32Array)return new Uint32Array(S.buffer,S.byteOffset,S.length);const e=S.slice(v,v+D);return z?new Uint32Array(e):new Uint16Array(e)}(h,0,z,v),B=this._bufferManager.createBufferView(m),E=v?5125:5123;this._accessors.push(this._bufferManager.createAccessor(B,"SCALAR",E,z,0)),N=this._accessors.length-1,g.setIndicesAccessor(S,D,z,e,n,N)}E.indices=N}}_exportVertexBuffer(S,v,D,z,e,N){const m=S.getKind();if(!C(m))return;if(m.startsWith("uv")&&!this._options.exportUnusedUVs&&(!v||!this._materialNeedsUVsSet.has(v)))return;let B=e.getVertexAccessor(S,D,z);if(void 0===B){const v=e.convertedToRightHandedBuffers.get(S._buffer)||S._buffer.getData(),N=m===h.d.PositionKind?function(S,v,D,z){const{byteOffset:e,byteStride:N,type:m,normalized:B}=v,g=v.getSize(),E=new Array(g).fill(1/0),h=new Array(g).fill(-1/0);return(0,J.h)(S,e+D*N,N,g,m,z*g,B,(S=>{for(let v=0;v<g;v++)E[v]=Math.min(E[v],S[v]),h[v]=Math.max(h[v],S[v])})),{min:E,max:h}}(v,S,D,z):void 0,g=(m===h.d.MatricesIndicesKind||m===h.d.MatricesIndicesExtraKind)&&S.type===h.d.FLOAT,E=g?h.d.UNSIGNED_BYTE:S.type,A=g?void 0:S.normalized,w=g?e.getRemappedBufferView(S._buffer,S):e.getVertexBufferView(S._buffer),n=S.byteOffset+D*S.byteStride;this._accessors.push(this._bufferManager.createAccessor(w,function(S,v){if(S==h.d.ColorKind)return v?"VEC4":"VEC3";switch(S){case h.d.PositionKind:case h.d.NormalKind:return"VEC3";case h.d.TangentKind:case h.d.MatricesIndicesKind:case h.d.MatricesIndicesExtraKind:case h.d.MatricesWeightsKind:case h.d.MatricesWeightsExtraKind:return"VEC4";case h.d.UVKind:case h.d.UV2Kind:case h.d.UV3Kind:case h.d.UV4Kind:case h.d.UV5Kind:case h.d.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${S}`)}(m,e.hasVertexColorAlpha(S)),E,z,n,N,A)),B=this._accessors.length-1,e.setVertexAccessor(S,D,z,B)}N.attributes[function(S){switch(S){case h.d.PositionKind:return"POSITION";case h.d.NormalKind:return"NORMAL";case h.d.TangentKind:return"TANGENT";case h.d.ColorKind:return"COLOR_0";case h.d.UVKind:return"TEXCOORD_0";case h.d.UV2Kind:return"TEXCOORD_1";case h.d.UV3Kind:return"TEXCOORD_2";case h.d.UV4Kind:return"TEXCOORD_3";case h.d.UV5Kind:return"TEXCOORD_4";case h.d.UV6Kind:return"TEXCOORD_5";case h.d.MatricesIndicesKind:return"JOINTS_0";case h.d.MatricesIndicesExtraKind:return"JOINTS_1";case h.d.MatricesWeightsKind:return"WEIGHTS_0";case h.d.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${S}`)}(m)]=B}async _exportMaterialAsync(S,v,D,z){let e=this._materialMap.get(S);if(void 0===e){const z=v&&Object.keys(v).some((S=>S.startsWith("uv")));if((S=S instanceof nS.c?S.Ye[D.materialIndex]:S)instanceof RS.d)e=await this._materialExporter.exportPBRMaterialAsync(S,"image/png",z);else{if(!(S instanceof OS.Kv))return void H.b.Warn(`Unsupported material '${S.name}' with type ${S.getClassName()}`);e=await this._materialExporter.exportStandardMaterialAsync(S,"image/png",z)}this._materialMap.set(S,e)}z.material=e}async _exportMeshAsync(S,v){var D;let z=v.getMesh(S);if(void 0!==z)return z;const e={primitives:[]};z=this._meshes.length,this._meshes.push(e),v.setMesh(S,z);const m=S.isUnIndexed?null:S.te(),B=null===(D=S.ie)||void 0===D?void 0:D.getVertexBuffers(),g=v.getMorphTargetsFromMesh(S),E=S instanceof dS.b,h=S instanceof YS,A=S.he;if(B&&A&&A.length>0)for(const R of A){const D={attributes:{}},z=R.cS()||this._babylonScene.defaultMaterial;if(h){var w,n;const v={name:z.name},e=S,N=I.qv.White(),m=(null===(w=e.material)||void 0===w?void 0:w.alpha)??1,B=(null===(n=e.greasedLineMaterial)||void 0===n?void 0:n.color)??N;(!B.equalsWithEpsilon(N,G.e)||m<1)&&(v.pbrMetallicRoughness={baseColorFactor:[...B.Oe(),m]}),this._materials.push(v),D.material=this._materials.length-1}else if(E){const v={name:z.name},e=S;(!e.color.equalsWithEpsilon(I.qv.White(),G.e)||e.alpha<1)&&(v.pbrMetallicRoughness={baseColorFactor:[...e.color.Oe(),e.alpha]}),this._materials.push(v),D.material=this._materials.length-1}else await this._exportMaterialAsync(z,B,R,D);const A=E||h?N.d.LineListDrawMode:S.overrideRenderingFillMode??z.fillMode,O=z._getEffectiveOrientation(S);this._exportIndices(m,m?(0,J.b)(m,R.indexCount,R.indexStart,R.verticesStart):R.verticesCount>65535,m?R.indexStart:R.verticesStart,m?R.indexCount:R.verticesCount,-R.verticesStart,A,O,v,D);for(const S of Object.values(B))this._exportVertexBuffer(S,z,R.verticesStart,R.verticesCount,v,D);if(g){D.targets=[];for(const S of g)D.targets.push(S.attributes)}e.primitives.push(D),this._extensionsPostExportMeshPrimitive(D)}if(g){e.weights=[],e.extras||(e.extras={}),e.extras.targetNames=[];for(const S of g)e.weights.push(S.influence),e.extras.targetNames.push(S.name)}return z}}VS._ExtensionNames=new Array,VS._ExtensionFactories={};class US{static async GLTFAsync(S,v,D){D&&D.exportWithoutWaitingForScene||await S.whenReadyAsync();const z=new VS(S,D),e=await z.generateGLTFAsync(v.replace(/\.[^/.]+$/,""));return z.dispose(),e}static async GLBAsync(S,v,D){D&&D.exportWithoutWaitingForScene||await S.whenReadyAsync();const z=new VS(S,D),e=await z.generateGLBAsync(v.replace(/\.[^/.]+$/,""));return z.dispose(),e}}D(11915);const yS="EXT_mesh_gpu_instancing";class fS{constructor(S){this.name=yS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=S}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(S,v,D,e,N,m){return await new Promise((S=>{if(v&&D instanceof qS.e&&D.hasThinInstances&&this._exporter){this._wasUsed=!0;const S=z.Rv.Zero(),e=z.Quaternion.Identity(),B=z.Rv.One(),g=D.thinInstanceGetWorldMatrices(),E=z.TmpVectors.Rv[2],h=z.TmpVectors.Quaternion[1],A=z.TmpVectors.Rv[3];let w=!1,n=!1,R=!1;const O=new Float32Array(3*D.Ue),I=new Float32Array(4*D.Ue),K=new Float32Array(3*D.Ue);let q=0;for(const v of g)v.decompose(A,h,E),N&&(P(E),Q(h)),O.set(E.Oe(),3*q),I.set(h.normalize().Oe(),4*q),K.set(A.Oe(),3*q),w=w||!E.equalsWithEpsilon(S),n=n||!h.equalsWithEpsilon(e),R=R||!A.equalsWithEpsilon(B),q++;const u={attributes:{}};w&&(u.attributes.TRANSLATION=this._buildAccessor(O,"VEC3",D.Ue,m)),n&&(u.attributes.ROTATION=this._buildAccessor(I,"VEC4",D.Ue,m)),R&&(u.attributes.SCALE=this._buildAccessor(K,"VEC3",D.Ue,m)),v.extensions=v.extensions||{},v.extensions[yS]=u}S(v)}))}_buildAccessor(S,v,D,z){const e=z.createBufferView(S),N=z.createAccessor(e,v,5126,D);return this._exporter._accessors.push(N),this._exporter._accessors.length-1}}VS.RegisterExtension(yS,(S=>new fS(S)));var CS=D(11917),FS=D(11922),lS=D(11929),PS=D(11935);function QS(S){return S===lS.b.PositionKind?"POSITION":S===lS.b.NormalKind?"NORMAL":S===lS.b.ColorKind?"COLOR":S.startsWith(lS.b.UVKind)?"TEX_COORD":"GENERIC"}const LS={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Sv extends CS.c{static get DefaultAvailable(){return(0,CS.k)(Sv.DefaultConfiguration)}static get Default(){return Sv._Default??(Sv._Default=new Sv),Sv._Default}static ResetDefault(S){Sv._Default&&(S||Sv._Default.dispose(),Sv._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(S,v){return{module:await(v||DracoEncoderModule)({wasmBinary:S})}}_getWorkerContent(){return`${FS.j}(${FS.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Sv.DefaultConfiguration)}async _encodeAsync(S,v,D){const z=D?(0,PS.d)(LS,D):LS;if(this._workerPoolPromise){const D=await this._workerPoolPromise;return await new Promise(((e,N)=>{D.push(((D,m)=>{const B=S=>{D.removeEventListener("error",B),D.removeEventListener("message",g),N(S),m()},g=S=>{"encodeMeshDone"===S.data.id&&(D.removeEventListener("error",B),D.removeEventListener("message",g),e(S.data.encodedMeshData),m())};D.addEventListener("error",B),D.addEventListener("message",g);const E=[];for(const v of S)E.push(v.data.buffer);v&&E.push(v.buffer),D.postMessage({id:"encodeMesh",attributes:S,indices:v,options:z},E)}))}))}if(this._modulePromise){const D=await this._modulePromise;return(0,FS.j)(D.module,S,v,z)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(S,v){if(0==S.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");S instanceof qS.e&&S.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===v||void 0===v?void 0:v.method)&&(H.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),v.method="MESH_SEQUENTIAL_ENCODING");const D=function(S){let v=S.te(void 0,!0);return!v||v instanceof Uint32Array||v instanceof Uint16Array||(v=((0,J.b)(v,v.length)?Uint32Array:Uint16Array).from(v)),v}(S),z=function(S,v){const D=[];for(const z of S.getVerticesDataKinds()){if(null!==v&&void 0!==v&&v.includes(z)){if(z===lS.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const e=S.getVertexBuffer(z),N=e.getSize(),m=(0,J.r)(e.getData(),N,e.type,e.byteOffset,e.byteStride,e.normalized,S.getTotalVertices(),!0);D.push({kind:z,dracoName:QS(z),size:N,data:m})}return D}(S,null===v||void 0===v?void 0:v.excludedAttributes);return await this._encodeAsync(z,D,v)}}Sv.DefaultConfiguration={wasmUrl:`${e.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${e.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${e.Tools._DefaultCdnUrl}/draco_encoder.js`},Sv._Default=null;const vv="KHR_draco_mesh_compression";class Dv{get wasUsed(){return this._wasUsed}constructor(S){this.name=vv,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===S.options.meshCompressionMethod&&Sv.DefaultAvailable}dispose(){}postExportMeshPrimitive(S,v,D){if(!this.enabled)return;if(4!==S.mode&&5!==S.mode)return void H.b.Warn("Cannot compress primitive with mode "+S.mode+".");const z=[],e=[];let N=null;if(void 0!==S.indices){const m=D[S.indices],B=v.getBufferView(m);N=v.getData(B).slice(),z.push(B),e.push(m)}const m=[];for(const[h,A]of Object.entries(S.attributes)){const S=D[A],N=v.getBufferView(S),g=f(S.type),E=(0,J.r)(v.getData(N),g,S.componentType,S.byteOffset||0,N.byteStride||(0,J.m)(S.componentType)*g,S.normalized||!1,S.count,!0);m.push({kind:h,dracoName:(B=h,"POSITION"===B?"POSITION":"NORMAL"===B?"NORMAL":B.startsWith("COLOR")?"COLOR":B.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:f(S.type),data:E}),z.push(N),e.push(S)}var B;const g={method:S.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},E=Sv.Default._encodeAsync(m,N,g).then((D=>{if(!D)return void H.b.Error("Draco encoding failed for primitive.");const N={bufferView:-1,attributes:D.attributeIds},m=v.createBufferView(D.data);v.setBufferView(N,m);for(const S of z)this._bufferViewsUsed.add(S);for(const S of e)this._accessorsUsed.add(S);S.extensions||(S.extensions={}),S.extensions[vv]=N})).catch((S=>{H.b.Error("Draco encoding failed for primitive: "+S)}));this._encodePromises.push(E),this._wasUsed=!0}async preGenerateBinaryAsync(S){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((v=>{S.getPropertiesWithBufferView(v).every((S=>this._accessorsUsed.has(S)))&&S.removeBufferView(v)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}VS.RegisterExtension(vv,(S=>new Dv(S)));var zv=D(11944);const ev="KHR_lights_punctual",Nv={name:"",color:[1,1,1],le:1,range:Number.MAX_VALUE},mv={innerConeAngle:0,outerConeAngle:Math.PI/4},Bv=z.Rv.Backward();class gv{constructor(S){this.name=ev,this.enabled=!0,this.required=!1,this._exporter=S}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[ev]=this._lights}async postExportNodeAsync(S,v,D,e,N){return await new Promise((m=>{if(!(D instanceof uS.b))return void m(v);const B=D.getTypeID()==uS.b.LIGHTTYPEID_POINTLIGHT?"point":D.getTypeID()==uS.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":D.getTypeID()==uS.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!B||!(D instanceof zv.c))return H.b.Warn(`${S}: Light ${D.name} is not supported in ${ev}`),void m(v);if(D.falloffType!==uS.b.FALLOFF_GLTF&&H.b.Warn(`${S}: Light falloff for ${D.name} does not match the ${ev} specification!`),!D.position.equalsToFloats(0,0,0)){const S=z.TmpVectors.Rv[0].N(D.position);N&&P(S),v.translation=S.Oe()}if("point"!==B){const S=D.direction.normalizeToRef(z.TmpVectors.Rv[0]);N&&P(S);const e=z.Quaternion.FromUnitVectorsToRef(Bv,S,z.TmpVectors.Quaternion[0]);z.Quaternion.IsIdentity(e)||(v.rotation=e.Oe())}const g={type:B,name:D.name,color:D.sB.Oe(),le:D.le,range:D.range};if(zS(g,Nv),"spot"===B){const S=D;g.spot={innerConeAngle:S.innerAngle/2,outerConeAngle:S.angle/2},zS(g.spot,mv)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(g);const E={nz:this._lights.lights.length-1},h=D.parent;if(h&&vS(D,h)){const S=e.get(h);if(S){const D=this._exporter._nodes[S];return SS(v,D),D.extensions||(D.extensions={}),D.extensions[ev]=E,void m(null)}}v.extensions||(v.extensions={}),v.extensions[ev]=E,m(v)}))}}VS.RegisterExtension(ev,(S=>new gv(S)));var Ev=D(11869);const hv="KHR_materials_anisotropy";class Av{constructor(S){this.name=hv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=S}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(S,v,D){const z=[];return D instanceof Ev.c&&D.anisotropy.isEnabled&&!D.anisotropy.legacy?(D.anisotropy.texture&&z.push(D.anisotropy.texture),z):[]}postExportMaterialAsync(S,v,D){return new Promise((S=>{if(D instanceof Ev.c){if(!D.anisotropy.isEnabled||D.anisotropy.legacy)return void S(v);this._wasUsed=!0,v.extensions=v.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(D.anisotropy.texture),e={anisotropyStrength:D.anisotropy.le,anisotropyRotation:D.anisotropy.angle,anisotropyTexture:z??void 0};null!==e.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(D),v.extensions[hv]=e}S(v)}))}}VS.RegisterExtension(hv,(S=>new Av(S)));const wv="KHR_materials_clearcoat";class nv{constructor(S){this.name=wv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=S}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(S,v,D){const z=[];return D instanceof Ev.c&&D.clearCoat.isEnabled?(D.clearCoat.texture&&z.push(D.clearCoat.texture),!D.clearCoat.useRoughnessFromMainTexture&&D.clearCoat.textureRoughness&&z.push(D.clearCoat.textureRoughness),D.clearCoat.bumpTexture&&z.push(D.clearCoat.bumpTexture),z):[]}postExportMaterialAsync(S,v,D){return new Promise((S=>{if(D instanceof Ev.c){if(!D.clearCoat.isEnabled)return void S(v);this._wasUsed=!0,v.extensions=v.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(D.clearCoat.texture);let N;N=D.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(D.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(D.clearCoat.textureRoughness),D.clearCoat.isTintEnabled&&e.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${D.name}`),D.clearCoat.remapF0OnInterfaceChange&&e.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${D.name}`);const m=this._exporter._materialExporter.getTextureInfo(D.clearCoat.bumpTexture),B={clearcoatFactor:D.clearCoat.le,clearcoatTexture:z??void 0,clearcoatRoughnessFactor:D.clearCoat.roughness,clearcoatRoughnessTexture:N??void 0,clearcoatNormalTexture:m??void 0};null===B.clearcoatTexture&&null===B.clearcoatRoughnessTexture&&null===B.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(D),v.extensions[wv]=B}S(v)}))}}VS.RegisterExtension(wv,(S=>new nv(S)));const Rv="KHR_materials_diffuse_transmission";function Ov(S,v){const D=v.subSurface;let z=null;return D.translucencyIntensityTexture?z=D.translucencyIntensityTexture:D.thicknessTexture&&D.useMaskFromThicknessTexture&&(z=D.thicknessTexture),z&&!D.useGltfStyleTextures?(H.b.Warn(`${S}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${v.name}`,1),null):z}class Iv{constructor(S){this.name=Rv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=S}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(S,v,D){const z=[];if(D instanceof RS.d&&this._isExtensionEnabled(D)){const v=Ov(S,D);return v&&z.push(v),D.subSurface.translucencyColorTexture&&z.push(D.subSurface.translucencyColorTexture),z}return z}_isExtensionEnabled(S){if(S.unlit)return!1;const v=S.subSurface;return!!v.isTranslucencyEnabled&&(!S.unlit&&!v.useAlbedoToTintTranslucency&&v.useGltfStyleTextures&&1===v.volumeIndexOfRefraction&&0===v.minimumThickness&&0===v.maximumThickness)}postExportMaterialAsync(S,v,D){return new Promise((z=>{if(D instanceof RS.d&&this._isExtensionEnabled(D)){this._wasUsed=!0;const z=D.subSurface,e=Ov(S,D),N=0==z.translucencyIntensity?void 0:z.translucencyIntensity,m=this._exporter._materialExporter.getTextureInfo(e)??void 0,B=!z.translucencyColor||z.translucencyColor.equalsFloats(1,1,1)?void 0:z.translucencyColor.Oe(),g=this._exporter._materialExporter.getTextureInfo(z.translucencyColorTexture)??void 0,E={diffuseTransmissionFactor:N,diffuseTransmissionTexture:m,diffuseTransmissionColorFactor:B,diffuseTransmissionColorTexture:g};(m||g)&&this._exporter._materialNeedsUVsSet.add(D),v.extensions=v.extensions||{},v.extensions[Rv]=E}z(v)}))}}VS.RegisterExtension(Rv,(S=>new Iv(S)));const Kv="KHR_materials_dispersion";class qv{constructor(){this.name=Kv,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(S){if(S.unlit)return!1;const v=S.subSurface;return!(!v.isRefractionEnabled&&!v.isDispersionEnabled)}postExportMaterialAsync(S,v,D){return new Promise((S=>{if(D instanceof RS.d&&this._isExtensionEnabled(D)){this._wasUsed=!0;const S={dispersion:D.subSurface.dispersion};v.extensions=v.extensions||{},v.extensions[Kv]=S}S(v)}))}}VS.RegisterExtension(Kv,(()=>new qv));const uv="KHR_materials_emissive_strength";class sv{constructor(){this.name=uv,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(S,v,D){return await new Promise((S=>{if(!(D instanceof RS.d))return S(v);const z=D.emissiveColor.Oe(),e=Math.max(...z);if(e>1){this._wasUsed=!0,v.extensions||(v.extensions={});const S={emissiveStrength:e},z=D.emissiveColor.scale(1/S.emissiveStrength);v.emissiveFactor=z.Oe(),v.extensions[uv]=S}return S(v)}))}}VS.RegisterExtension(uv,(S=>new sv));const rv="KHR_materials_ior";class dv{constructor(){this.name=rv,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(S){return!S.unlit&&(void 0!=S.indexOfRefraction&&1.5!=S.indexOfRefraction)}postExportMaterialAsync(S,v,D){return new Promise((S=>{if(D instanceof RS.d&&this._isExtensionEnabled(D)){this._wasUsed=!0;const S={ior:D.indexOfRefraction};v.extensions=v.extensions||{},v.extensions[rv]=S}S(v)}))}}VS.RegisterExtension(rv,(S=>new dv));const xv="KHR_materials_iridescence";class Wv{constructor(S){this.name=xv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=S}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(S,v,D){const z=[];return D instanceof Ev.c&&D.iridescence.isEnabled?(D.iridescence.texture&&z.push(D.iridescence.texture),D.iridescence.thicknessTexture&&D.iridescence.thicknessTexture!==D.iridescence.texture&&z.push(D.iridescence.thicknessTexture),z):[]}postExportMaterialAsync(S,v,D){return new Promise((S=>{if(D instanceof Ev.c){if(!D.iridescence.isEnabled)return void S(v);this._wasUsed=!0,v.extensions=v.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(D.iridescence.texture),e=this._exporter._materialExporter.getTextureInfo(D.iridescence.thicknessTexture),N={iridescenceFactor:D.iridescence.le,iridescenceIor:D.iridescence.indexOfRefraction,iridescenceThicknessMinimum:D.iridescence.minimumThickness,iridescenceThicknessMaximum:D.iridescence.maximumThickness,iridescenceTexture:z??void 0,iridescenceThicknessTexture:e??void 0};null===N.iridescenceTexture&&null===N.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(D),v.extensions[xv]=N}S(v)}))}}VS.RegisterExtension(xv,(S=>new Wv(S)));const pv="KHR_materials_sheen";class bv{constructor(S){this.name=pv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=S}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(S,v,D){return D instanceof RS.d&&D.sheen.isEnabled&&D.sheen.texture?[D.sheen.texture]:[]}async postExportMaterialAsync(S,v,D){return await new Promise((S=>{if(D instanceof RS.d){if(!D.sheen.isEnabled)return void S(v);this._wasUsed=!0,null==v.extensions&&(v.extensions={});const z={sheenColorFactor:D.sheen.color.Oe(),sheenRoughnessFactor:D.sheen.roughness??0};null===z.sheenColorTexture&&null===z.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(D),D.sheen.texture&&(z.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(D.sheen.texture)??void 0),D.sheen.textureRoughness&&!D.sheen.useRoughnessFromMainTexture?z.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(D.sheen.textureRoughness)??void 0:D.sheen.texture&&D.sheen.useRoughnessFromMainTexture&&(z.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(D.sheen.texture)??void 0),v.extensions[pv]=z}S(v)}))}}VS.RegisterExtension(pv,(S=>new bv(S)));const kv="KHR_materials_specular";class Zv{constructor(S){this.name=kv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=S}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(S,v,D){const z=[];return D instanceof RS.d&&this._isExtensionEnabled(D)?(D.metallicReflectanceTexture&&z.push(D.metallicReflectanceTexture),D.reflectanceTexture&&z.push(D.reflectanceTexture),z):z}_isExtensionEnabled(S){return!S.unlit&&(void 0!=S.metallicF0Factor&&1!=S.metallicF0Factor||void 0!=S.metallicReflectanceColor&&!S.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(S))}_hasTexturesExtension(S){return null!=S.metallicReflectanceTexture||null!=S.reflectanceTexture}postExportMaterialAsync(S,v,D){return new Promise((S=>{if(D instanceof RS.d&&this._isExtensionEnabled(D)){this._wasUsed=!0,v.extensions=v.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(D.metallicReflectanceTexture)??void 0,z=this._exporter._materialExporter.getTextureInfo(D.reflectanceTexture)??void 0,e={specularFactor:1==D.metallicF0Factor?void 0:D.metallicF0Factor,specularTexture:S,specularColorFactor:D.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:D.metallicReflectanceColor.Oe(),specularColorTexture:z};this._hasTexturesExtension(D)&&this._exporter._materialNeedsUVsSet.add(D),v.extensions[kv]=e}S(v)}))}}VS.RegisterExtension(kv,(S=>new Zv(S)));const iv="KHR_materials_transmission";class tv{constructor(S){this.name=iv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=S}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(S,v,D){const z=[];return D instanceof RS.d&&this._isExtensionEnabled(D)?(D.subSurface.thicknessTexture&&z.push(D.subSurface.thicknessTexture),z):z}_isExtensionEnabled(S){if(S.unlit)return!1;const v=S.subSurface;return v.isRefractionEnabled&&void 0!=v.refractionIntensity&&0!=v.refractionIntensity||this._hasTexturesExtension(S)}_hasTexturesExtension(S){return null!=S.subSurface.refractionIntensityTexture}async postExportMaterialAsync(S,v,D){if(D instanceof RS.d&&this._isExtensionEnabled(D)){this._wasUsed=!0;const z=D.subSurface,e={transmissionFactor:0===z.refractionIntensity?void 0:z.refractionIntensity};if(this._hasTexturesExtension(D)&&this._exporter._materialNeedsUVsSet.add(D),z.refractionIntensityTexture)if(z.useGltfStyleTextures){const S=await this._exporter._materialExporter.exportTextureAsync(z.refractionIntensityTexture,"image/png");S&&(e.transmissionTexture=S)}else H.b.Warn(`${S}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);v.extensions||(v.extensions={}),v.extensions[iv]=e}return v}}VS.RegisterExtension(iv,(S=>new tv(S)));const Xv="KHR_materials_unlit";class av{constructor(){this.name=Xv,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(S,v,D){return new Promise((S=>{let z=!1;D instanceof RS.d?z=D.unlit:D instanceof OS.Kv&&(z=D.disableLighting),z&&(this._wasUsed=!0,null==v.extensions&&(v.extensions={}),v.extensions[Xv]={}),S(v)}))}}VS.RegisterExtension(Xv,(()=>new av));const ov="KHR_materials_volume";class Mv{constructor(S){this.name=ov,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=S}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(S,v,D){const z=[];return D instanceof RS.d&&this._isExtensionEnabled(D)?(D.subSurface.thicknessTexture&&z.push(D.subSurface.thicknessTexture),z):z}_isExtensionEnabled(S){if(S.unlit)return!1;const v=S.subSurface;return!(!v.isRefractionEnabled&&!v.isTranslucencyEnabled)&&(void 0!=v.maximumThickness&&0!=v.maximumThickness||void 0!=v.tintColorAtDistance&&v.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=v.tintColor&&v.tintColor!=I.qv.White()||this._hasTexturesExtension(S))}_hasTexturesExtension(S){return null!=S.subSurface.thicknessTexture}postExportMaterialAsync(S,v,D){return new Promise((S=>{if(D instanceof RS.d&&this._isExtensionEnabled(D)){this._wasUsed=!0;const S=D.subSurface,z={thicknessFactor:0==S.maximumThickness?void 0:S.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(S.thicknessTexture)??void 0,attenuationDistance:S.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:S.tintColorAtDistance,attenuationColor:S.tintColor.equalsFloats(1,1,1)?void 0:S.tintColor.Oe()};this._hasTexturesExtension(D)&&this._exporter._materialNeedsUVsSet.add(D),v.extensions=v.extensions||{},v.extensions[ov]=z}S(v)}))}}VS.RegisterExtension(ov,(S=>new Mv(S)));const cv="EXT_materials_diffuse_roughness";class Jv{constructor(S){this.name=cv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=S}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(S,v,D){const z=[];return D instanceof Ev.c&&D._baseDiffuseRoughness?(D._baseDiffuseRoughnessTexture&&z.push(D._baseDiffuseRoughnessTexture),z):[]}postExportMaterialAsync(S,v,D){return new Promise((S=>{if(D instanceof Ev.c){if(!D._baseDiffuseRoughness)return void S(v);this._wasUsed=!0,v.extensions=v.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(D._baseDiffuseRoughnessTexture),e={diffuseRoughnessFactor:D._baseDiffuseRoughness,diffuseRoughnessTexture:z??void 0};null!==e.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(D),v.extensions[cv]=e}S(v)}))}}VS.RegisterExtension(cv,(S=>new Jv(S)));const Hv="KHR_texture_transform";class Tv{constructor(){this.name=Hv,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(S,v,D){if(D.xS()||e.Tools.Warn(`${S}: /*@__KEY__*/"scene" is not defined for Babylon texture ${D.name}!`),(0!==D.uAng||0!==D.vAng)&&(e.Tools.Warn(`${S}: Texture ${D.name} with rotation in the u or v axis is not supported in glTF.`),0!==D.uRotationCenter||0!==D.vRotationCenter))return;const z={};let N=!1;if(0===D.uOffset&&0===D.vOffset||(z.offset=[D.uOffset,D.vOffset],N=!0),1===D.uScale&&1===D.vScale||(z.scale=[D.uScale,D.vScale],N=!0),0!==D.wAng){if(0!==D.uRotationCenter||0!==D.vRotationCenter){if(D.homogeneousRotationInUVTransform&&D.uScale!==D.vScale)return void e.Tools.Warn(`${S}: Texture ${D.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Hv}.`);e.Tools.Warn(`${S}: Texture ${D.name} with non-origin rotation center will be exported using an adjusted offset with ${Hv}.`),z.offset=function(S){const{uOffset:v,vOffset:D,uRotationCenter:z,vRotationCenter:e,uScale:N,vScale:m,wAng:B}=S,g=Math.cos(B),E=Math.sin(B),h=z*N,A=e*m;return[v+(h*(1-g)+A*E),D+(A*(1-g)-h*E)]}(D)}z.rotation=-D.wAng,N=!0}0!==D.coordinatesIndex&&(z.texCoord=D.coordinatesIndex,N=!0),N&&(this._wasUsed=!0,v.extensions||(v.extensions={}),v.extensions[Hv]=z)}}VS.RegisterExtension(Hv,(()=>new Tv));class Gv{static CreateSTL(S){let v=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",e=arguments.length>3&&void 0!==arguments[3]&&arguments[3],N=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],m=arguments.length>5&&void 0!==arguments[5]&&arguments[5],B=arguments.length>6&&void 0!==arguments[6]&&arguments[6],g=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const E=function(S,v,D){const e=[3*S[D],3*S[D+1],3*S[D+2]],N=[new z.Rv(v[e[0]],v[e[0]+2],v[e[0]+1]),new z.Rv(v[e[1]],v[e[1]+2],v[e[1]+1]),new z.Rv(v[e[2]],v[e[2]+2],v[e[2]+1])],m=N[0].Ov(N[1]),B=N[2].Ov(N[1]);return{v:N,n:z.Rv.Cross(B,m).normalize()}},A=function(S,v,D,z){return v=w(S,v,D.x,z),v=w(S,v,D.y,z),w(S,v,D.z,z)},w=function(S,v,D,z){return S.setFloat32(v,D,z),v+4},R=function(S){if(B){let v=S;S instanceof n.c&&(v=S.sourceMesh);const D=v.getVerticesData(h.d.PositionKind,!0,!0);if(!D)return[];const e=z.Rv.Zero();let N;for(N=0;N<D.length;N+=3)z.Rv.TransformCoordinatesFromFloatsToRef(D[N],D[N+1],D[N+2],S.ke(!0),e).toArray(D,N);return D}return S.getVerticesData(h.d.PositionKind)||[]};B&&(m=!0);let O="",I=0,K=0;if(e){for(let D=0;D<S.length;D++){const v=S[D].te();I+=v?v.length/3:0}const v=new ArrayBuffer(84+50*I);O=new DataView(v),K+=80,O.setUint32(K,I,N),K+=4}else g||(O="solid stlmesh\r\n");for(let z=0;z<S.length;z++){const v=S[z];!e&&g&&(O+="solid "+v.name+"\r\n"),!m&&v instanceof qS.e&&v.bakeCurrentTransformIntoVertices();const D=R(v),B=v.te()||[];for(let S=0;S<B.length;S+=3){const v=E(B,D,S);e?(K=A(O,K,v.n,N),K=A(O,K,v.v[0],N),K=A(O,K,v.v[1],N),K=A(O,K,v.v[2],N),K+=2):(O+="\tfacet normal "+v.n.x+" "+v.n.y+" "+v.n.z+"\r\n",O+="\t\touter loop\r\n",O+="\t\t\tvertex "+v.v[0].x+" "+v.v[0].y+" "+v.v[0].z+"\r\n",O+="\t\t\tvertex "+v.v[1].x+" "+v.v[1].y+" "+v.v[1].z+"\r\n",O+="\t\t\tvertex "+v.v[2].x+" "+v.v[2].y+" "+v.v[2].z+"\r\n",O+="\t\tendloop\r\n",O+="\tendfacet\r\n")}!e&&g&&(O+="endsolid "+name+"\r\n")}if(e||g||(O+="endsolid stlmesh"),v){const S=document.createElement("a"),v=new Blob([O],{type:"application/octet-stream"});S.href=window.URL.createObjectURL(v),S.download=D+".stl",S.click()}return O}}function Yv(S,v){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const z=[];for(let e=0;e<S.length/D;e++){const N=S[e*D],m=S[e*D+1],B=S[e*D+2];z.push(`(${N.toPrecision(v.precision)}, ${m.toPrecision(v.precision)}, ${B.toPrecision(v.precision)})`)}return z.join(", ")}function jv(S,v){const D=[];for(let z=0;z<S.length/2;z++){const e=S[2*z],N=S[2*z+1];D.push(`(${e.toPrecision(v.precision)}, ${(1-N).toPrecision(v.precision)})`)}return D.join(", ")}function Vv(S,v){const D=S.getVerticesData(h.d.PositionKind),z=S.getVerticesData(h.d.NormalKind);if(D&&z)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(S){var v;const D=null!==(v=S.te())&&void 0!==v&&v.length?S.getTotalIndices():S.getTotalVertices();return Array(D/3).fill(3).join(", ")}(S)}]\n\t\tint[] faceVertexIndices = [${function(S){const v=S.te(),D=[];if(null!==v)for(let z=0;z<v.length;z++)D.push(v[z]);else{const v=S.getTotalVertices();for(let S=0;S<v;S++)D.push(S)}return D.join(", ")}(S)}]\n\t\tnormal3f[] normals = [${Yv(z,v)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Yv(D,v)}]\n        ${function(S,v){let D="";for(let e=0;e<4;e++){const z=e>0?e:"",N=S.getVerticesData(h.d.UVKind+(z?z+1:""));N&&(D+=`\n\t\ttexCoord2f[] primvars:st${z} = [${jv(N,v)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const z=S.getVerticesData(h.d.ColorKind);return z&&(D+=`\n\tcolor3f[] primvars:displayColor = [${Yv(z,v,z.length/S.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),D}(S,v)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Uv(S,v){return`\n        def "Geometry"\n        {\n        ${Vv(S,v)}\n        }\n        `}function yv(S){let v='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return v+=S,fflate.strToU8(v)}function fv(S){const v=S.m;return`( ${Cv(v,0)}, ${Cv(v,4)}, ${Cv(v,8)}, ${Cv(v,12)} )`}function Cv(S,v){return`(${S[v+0]}, ${S[v+1]}, ${S[v+2]}, ${S[v+3]})`}function Fv(S){const v="Object_"+S.uniqueId,D=function(S){const v=S.getWorldMatrix().clone(),D=S.xS().useRightHandedSystem;if(!D){let z=S.parent;for(;z;){if(mS(z,D)){v.multiplyToRef(z.getWorldMatrix().invert(),v);break}z=z.parent}}return v.determinant()<0&&e.Tools.Warn(`Exporting mesh ${S.name} with negative scale. Result may look incorrect in destination engine.`),v}(S),z=fv(D);return`def Xform "${v}" (\n\tprepend references = @./geometries/Geometry_${S.ie.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${z}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${S.material.uniqueId}>\n}\n\n`}function lv(S){switch(S){case x.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case x.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case x.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Pv(S){return`(${S.x}, ${S.y})`}function Qv(S){return`(${S.r}, ${S.g}, ${S.b})`}function Lv(S,v,D,e,N,m){const B=S.getInternalTexture().uniqueId+"_"+S.invertY;N[B]=S;const g=S.coordinatesIndex>0?"st"+S.coordinatesIndex:"st",E=new z.Vector2(S.uScale,S.vScale),h=new z.Vector2(S.uOffset,S.vOffset),A=S.wAng,w=Math.sin(A),n=Math.cos(A);return h.y=1-h.y-E.y,h.x+=w*E.x,h.y+=(1-n)*E.y,`\n    def Shader "PrimvarReader_${D}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${g}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${D}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${v.uniqueId}/PrimvarReader_${D}.outputs:result>\n        float inputs:rotation = ${(A*(180/Math.PI)).toFixed(m.precision)}\n        float2 inputs:scale = ${Pv(E)}\n        float2 inputs:translation = ${Pv(h)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${S.uniqueId}_${D}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${B}.png@\n        float2 inputs:st.connect = </Materials/Material_${v.uniqueId}/Transform2d_${D}.outputs:result>\n        ${e?"float4 inputs:scale = "+function(S){return`(${S.r}, ${S.g}, ${S.b}, 1.0)`}(e):""}\n        token inputs:sourceColorSpace = "${S.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${lv(S.wrapU)}"\n        token inputs:wrapT = "${lv(S.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${v.needAlphaBlending()?"float outputs:a":""}\n    }`}function SD(S,v,D){const z="\t\t\t",e=[],N=[],{diffuseMap:m,sB:B,alphaCutOff:g,emissiveMap:E,emissive:h,normalMap:A,roughnessMap:w,roughnessChannel:n,roughness:R,metalnessMap:O,metalnessChannel:K,metalness:q,aoMap:u,aoMapChannel:s,aoMapIntensity:r,alphaMap:d,ior:x,clearCoatEnabled:W,clearCoat:p,clearCoatMap:b,clearCoatRoughness:k,clearCoatRoughnessMap:Z}=function(S){const v={diffuseMap:null,sB:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return S instanceof OS.Kv?{...v,diffuseMap:S.diffuseTexture,sB:S.diffuseColor,alphaCutOff:S.alphaCutOff,emissiveMap:S.emissiveTexture,emissive:S.emissiveColor,roughness:1,alphaMap:S.opacityTexture}:S instanceof Ev.c?{...v,diffuseMap:S._albedoTexture,sB:S._albedoColor,alphaCutOff:S._alphaCutOff,emissiveMap:S._emissiveTexture,emissive:S._emissiveColor,normalMap:S._bumpTexture,roughnessMap:S._metallicTexture,roughnessChannel:S._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:S._roughness??1,metalnessMap:S._metallicTexture,metalnessChannel:S._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:S._metallic??0,aoMap:S._ambientTexture,aoMapChannel:S._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:S._ambientTextureStrength,alphaMap:S._opacityTexture,ior:S.subSurface.indexOfRefraction,clearCoatEnabled:S.clearCoat.isEnabled,clearCoat:S.clearCoat.le,clearCoatMap:S.clearCoat.texture,clearCoatRoughness:S.clearCoat.roughness,clearCoatRoughnessMap:S.clearCoat.useRoughnessFromMainTexture?S.clearCoat.texture:S.clearCoat.textureRoughness}:v}(S);return null!==m?(e.push(`${z}color3f inputs:diffuseColor.connect = </Materials/Material_${S.uniqueId}/Texture_${m.uniqueId}_diffuse.outputs:rgb>`),S.needAlphaBlending()?e.push(`${z}float inputs:opacity.connect = </Materials/Material_${S.uniqueId}/Texture_${m.uniqueId}_diffuse.outputs:a>`):S.needAlphaTesting()&&(e.push(`${z}float inputs:opacity.connect = </Materials/Material_${S.uniqueId}/Texture_${m.uniqueId}_diffuse.outputs:a>`),e.push(`${z}float inputs:opacityThreshold = ${g}`)),N.push(Lv(m,S,"diffuse",B,v,D))):e.push(`${z}color3f inputs:diffuseColor = ${Qv(B||I.qv.White())}`),null!==E?(e.push(`${z}color3f inputs:emissiveColor.connect = </Materials/Material_${S.uniqueId}/Texture_${E.uniqueId}_emissive.outputs:rgb>`),N.push(Lv(E,S,"emissive",h,v,D))):h&&h.toLuminance()>0&&e.push(`${z}color3f inputs:emissiveColor = ${Qv(h)}`),null!==A&&(e.push(`${z}normal3f inputs:normal.connect = </Materials/Material_${S.uniqueId}/Texture_${A.uniqueId}_normal.outputs:rgb>`),N.push(Lv(A,S,"normal",null,v,D))),null!==u&&(e.push(`${z}float inputs:occlusion.connect = </Materials/Material_${S.uniqueId}/Texture_${u.uniqueId}_occlusion.outputs:${s}>`),N.push(Lv(u,S,"occlusion",new I.qv(r,r,r),v,D))),null!==w?(e.push(`${z}float inputs:roughness.connect = </Materials/Material_${S.uniqueId}/Texture_${w.uniqueId}_roughness.outputs:${n}>`),N.push(Lv(w,S,"roughness",new I.qv(R,R,R),v,D))):e.push(`${z}float inputs:roughness = ${R}`),null!==O?(e.push(`${z}float inputs:metallic.connect = </Materials/Material_${S.uniqueId}/Texture_${O.uniqueId}_metallic.outputs:${K}>`),N.push(Lv(O,S,"metallic",new I.qv(q,q,q),v,D))):e.push(`${z}float inputs:metallic = ${q}`),null!==d?(e.push(`${z}float inputs:opacity.connect = </Materials/Material_${S.uniqueId}/Texture_${d.uniqueId}_opacity.outputs:r>`),e.push(`${z}float inputs:opacityThreshold = 0.0001`),N.push(Lv(d,S,"opacity",null,v,D))):e.push(`${z}float inputs:opacity = ${S.alpha}`),W&&(null!==b?(e.push(`${z}float inputs:clearcoat.connect = </Materials/Material_${S.uniqueId}/Texture_${b.uniqueId}_clearcoat.outputs:r>`),N.push(Lv(b,S,"clearcoat",new I.qv(p,p,p),v,D))):e.push(`${z}float inputs:clearcoat = ${p}`),null!==Z?(e.push(`${z}float inputs:clearcoatRoughness.connect = </Materials/Material_${S.uniqueId}/Texture_${Z.uniqueId}_clearcoatRoughness.outputs:g>`),N.push(Lv(Z,S,"clearcoatRoughness",new I.qv(k,k,k),v,D))):e.push(`${z}float inputs:clearcoatRoughness = ${k}`)),e.push(`${z}float inputs:ior = ${x}`),`\n\tdef Material "Material_${S.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${e.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${S.uniqueId}/PreviewSurface.outputs:surface>\n\n${N.join("\n")}\n\n\t}\n`}async function vD(S,v,D){const N={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...v};"undefined"===typeof fflate&&await e.Tools.LoadScriptAsync(N.fflateUrl);const m={};m[N.modelFileName]=null;let B='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';B+=function(S){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===S.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${S.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${S.planeAnchoringAlignment}"`:""}\n            `}(N);const g={};for(const z of S.meshes){if(0===z.getTotalVertices())continue;const S=z,v=S.ie,E=S.material;if(!E||!v||D&&!D(S))continue;if(-1!==["Kv","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(E.getClassName())){const D="geometries/Geometry_"+v.uniqueId+".usda";if(!(D in m)){const S=Uv(v,N);m[D]=yv(S)}E.uniqueId in g||(g[E.uniqueId]=E),B+=Fv(S)}else e.Tools.Warn("USDZExportAsync does not support this material type: "+E.getClassName())}S.activeCamera&&N.exportCamera&&(B+=function(S,v){const D="Camera_"+S.uniqueId,e=fv(z.Matrix.RotationY(Math.PI).multiply(S.getWorldMatrix()));if(S.mode===x.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${D}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${e}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${S.xe.toPrecision(v.precision)}, ${S.maxZ.toPrecision(v.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(S.orthoLeft||1)+Math.abs(S.orthoRight||1))).toPrecision(v.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(S.orthoTop||1)+Math.abs(S.orthoBottom||1))).toPrecision(v.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const z=S.getEngine().getAspectRatio(S),N=v.cameraSensorWidth||35;return`def Camera "${D}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${e}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${S.xe.toPrecision(v.precision)}, ${S.maxZ.toPrecision(v.precision)})\n\t\t\tfloat focalLength = ${(N/(2*Math.tan(.5*S.fov))).toPrecision(v.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(N*z).toPrecision(v.precision)}\n\t\t\tfloat verticalAperture = ${(N/z).toPrecision(v.precision)}            \n\t\t}\n\t\n\t`}}(S.activeCamera,N)),B+="\n            }\n        }\n    }";const E={};B+=function(S,v,D){const z=[];for(const e in S){const N=S[e];z.push(SD(N,v,D))}return`\n    def "Materials"\n{\n${z.join("")}\n}\n\n`}(g,E,N),m[N.modelFileName]=fflate.strToU8(B);for(const z in E){const S=E[z],v=S.getSize(),D=await S.readPixels();if(!D)throw new Error("Texture data is not available");const e=await W.DumpTools.DumpDataAsync(v.width,v.height,D,"image/png",void 0,!1,!0);m[`textures/Texture_${z}.png`]=new Uint8Array(e).slice()}let h=0;for(const z in m){const S=m[z];if(!S)continue;h+=34+z.length;const v=63&h;if(4!==v){const D=new Uint8Array(64-v);m[z]=[S,{extra:{12345:D}}]}h=S.length}return fflate.zipSync(m,{level:0})}}}]);