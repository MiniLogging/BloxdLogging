"use strict";(self["3gghkoft8x"]=self["3gghkoft8x"]||[]).push([[26],{12718:(y,S,I)=>{I.r(S),I.d(S,{EXT_materials_diffuse_roughness:()=>bS,EXT_mesh_gpu_instancing:()=>My,GLTF2Export:()=>cy,GLTFData:()=>J,KHR_draco_mesh_compression:()=>IS,KHR_lights_punctual:()=>FS,KHR_materials_anisotropy:()=>KS,KHR_materials_clearcoat:()=>pS,KHR_materials_diffuse_transmission:()=>lS,KHR_materials_dispersion:()=>sS,KHR_materials_emissive_strength:()=>fS,KHR_materials_ior:()=>CS,KHR_materials_iridescence:()=>oS,KHR_materials_sheen:()=>zS,KHR_materials_specular:()=>hS,KHR_materials_transmission:()=>vS,KHR_materials_unlit:()=>qS,KHR_materials_volume:()=>kS,KHR_texture_transform:()=>WS,OBJExport:()=>B,STLExport:()=>aS,USDZExportAsync:()=>SI,_ConvertToGLTFPBRMetallicRoughness:()=>P,_SolveMetallic:()=>v,__IGLTFExporterExtension:()=>d});var V=I(12321),i=I(12128),A=I(12637);class B{static OBJ(y,S,I,B){const d=[];let F=1,J=1;S&&(I||(I="mat"),d.push("mtllib "+I+".mtl"));for(let u=0;u<y.length;u++){const I=y[u],K=I.name||`mesh${u}}`;d.push(`o ${K}`);let G=null;if(B){const y=I.sd(!0);G=new V.Matrix,y.invertToRef(G),I.bakeTransformIntoVertices(y)}if(S){const y=I.material;y&&d.push("usemtl "+y.id)}const p=I.Od;if(!p){i.Tools.Warn("No geometry is present on the mesh");continue}const L=p.getVerticesData("position"),T=p.getVerticesData("normal"),l=p.getVerticesData("uv"),j=p.fd();let s=0,O=0;if(!L||!j){i.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const f=y[0].Ey().useRightHandedSystem?1:-1;for(let y=0;y<L.length;y+=3)d.push("v "+L[y]*f+" "+L[y+1]+" "+L[y+2]),s++;if(null!=T)for(let y=0;y<T.length;y+=3)d.push("vn "+T[y]*f+" "+T[y+1]+" "+T[y+2]);if(null!=l)for(let y=0;y<l.length;y+=2)d.push("vt "+l[y]+" "+l[y+1]),O++;const my=["","",""],C=(I.material||I.Ey().defaultMaterial)._getEffectiveOrientation(I),[D,o]=C===A.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let y=0;y<j.length;y+=3){const S=[String(j[y]+F),String(j[y+D]+F),String(j[y+o]+F)],I=[String(j[y]+J),String(j[y+D]+J),String(j[y+o]+J)],V=S,i=null!=l?I:my,A=null!=T?S:my;d.push("f "+V[0]+"/"+i[0]+"/"+A[0]+" "+V[1]+"/"+i[1]+"/"+A[1]+" "+V[2]+"/"+i[2]+"/"+A[2])}B&&G&&I.bakeTransformIntoVertices(G),F+=s,J+=O}return d.join("\n")}static MTL(y){const S=[],I=y.material;S.push("newmtl mat1"),S.push("  Ns "+I.specularPower.toFixed(4)),S.push("  Ni 1.5000"),S.push("  d "+I.alpha.toFixed(4)),S.push("  Tr 0.0000"),S.push("  Tf 1.0000 1.0000 1.0000"),S.push("  illum 2"),S.push("  Ka "+I.ambientColor.r.toFixed(4)+" "+I.ambientColor.g.toFixed(4)+" "+I.ambientColor.b.toFixed(4)),S.push("  Kd "+I.diffuseColor.r.toFixed(4)+" "+I.diffuseColor.g.toFixed(4)+" "+I.diffuseColor.b.toFixed(4)),S.push("  Ks "+I.specularColor.r.toFixed(4)+" "+I.specularColor.g.toFixed(4)+" "+I.specularColor.b.toFixed(4)),S.push("  Ke "+I.emissiveColor.r.toFixed(4)+" "+I.emissiveColor.g.toFixed(4)+" "+I.emissiveColor.b.toFixed(4));I.ambientTexture&&S.push("  map_Ka "+I.ambientTexture.name),I.diffuseTexture&&S.push("  map_Kd "+I.diffuseTexture.name),I.specularTexture&&S.push("  map_Ks "+I.specularTexture.name),I.bumpTexture&&S.push("  map_bump -imfchan z "+I.bumpTexture.name),I.opacityTexture&&S.push("  map_d "+I.opacityTexture.name);return S.join("\n")}}var d=0,F=I(12193);class J{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const y in this.files){const S=this.files[y],I=new Blob([S],{type:(0,F.j)(y)});i.Tools.Download(I,y)}}}var u=I(12390),K=I(12723),G=I(12734),p=I(12747),L=I(12455),T=I(12185),l=I(12362),j=I(12338);const s=j.HighestCommonFactor,O={...j,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:s};var f=I(12550),my=I(12304),C=I(12782),D=I(12789),o=I(12544);const E=1e-6,z=new l.DS(.04,.04,.04),r=1024,h=l.DS.White(),n=l.DS.Black();function v(y,S,I){if(S<z.r)return 0;const V=z.r,i=y*I/(1-z.r)+S-2*z.r,A=i*i-4*V*(z.r-S);return O.Clamp((-i+Math.sqrt(A))/(2*V),0,1)}function P(y){const S=y.diffuseColor.toLinearSpace(y.Ey().getEngine().useExactSrgbConversions).scale(.5),I=y.alpha,i=function(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new V.Vector2(0,1),I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new V.Vector2(0,.1),i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new V.Vector2(0,.1),A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new V.Vector2(1300,.1);return function(y,S,I,V,i){return(1-y)*(1-y)*(1-y)*S+3*(1-y)*(1-y)*y*I+3*(1-y)*y*y*V+y*y*y*i}(Math.pow(y/A.x,.333333),S.y,I.y,i.y,A.y)}(O.Clamp(y.specularPower,0,r));return{baseColorFactor:[S.r,S.g,S.b,I],metallicFactor:0,roughnessFactor:i}}function q(y,S){S.needAlphaBlending()?y.alphaMode="BLEND":S.needAlphaTesting()&&(y.alphaMode="MASK",y.alphaCutoff=S.alphaCutOff)}function g(y,S,I){const V=new Uint8Array(y*S*4);for(let i=0;i<V.length;i+=4)V[i]=V[i+1]=V[i+2]=V[i+3]=255;return C.b.CreateRGBATexture(V,y,S,I)}function k(y){if(y instanceof Uint8Array){const S=y.length,I=new Float32Array(y.length);for(let V=0;V<S;++V)I[V]=y[V]/255;return I}if(y instanceof Float32Array)return y;throw new Error("Unsupported pixel format!")}class R{constructor(y){this._exporter=y,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(y){return y?this._textureMap.get(y)??null:null}async exportStandardMaterialAsync(y,S,I){const V=P(y),A={name:y.name};if(null==y.Dd||y.Dd||(y.twoSidedLighting||i.Tools.Warn(y.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),A.doubleSided=!0),I){const I=[],i=y.diffuseTexture;i&&I.push(this.exportTextureAsync(i,S).then((y=>{y&&(V.baseColorTexture=y)})));const B=y.bumpTexture;B&&I.push(this.exportTextureAsync(B,S).then((y=>{y&&(A.normalTexture=y,1!==B.level&&(A.normalTexture.scale=B.level))})));const d=y.emissiveTexture;d&&(A.emissiveFactor=[1,1,1],I.push(this.exportTextureAsync(d,S).then((y=>{y&&(A.emissiveTexture=y)}))));const F=y.ambientTexture;F&&I.push(this.exportTextureAsync(F,S).then((y=>{if(y){const S={index:y.index};A.occlusionTexture=S}}))),I.length>0&&(this._exporter._materialNeedsUVsSet.add(y),await Promise.all(I))}(y.alpha<1||y.opacityTexture)&&(y.alphaMode===D.b.ALPHA_COMBINE?A.alphaMode="BLEND":i.Tools.Warn(y.name+": glTF 2.0 does not support alpha mode: "+y.alphaMode.toString())),y.emissiveColor&&!y.emissiveColor.equalsWithEpsilon(n,E)&&(A.emissiveFactor=y.emissiveColor.Vd()),A.pbrMetallicRoughness=V,q(A,y),await this._finishMaterialAsync(A,y,S);const B=this._exporter._materials;return B.push(A),B.length-1}async _finishMaterialAsync(y,S,I){const V=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",y,S),i=[];for(const A of V)i.push(this.exportTextureAsync(A,I));await Promise.all(i),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",y,S)}async _getImageDataAsync(y,S,V,i){const A=D.b.TEXTURETYPE_UNSIGNED_BYTE,B=this._exporter._babylonScene,d=B.getEngine(),F=d.createRawTexture(y,S,V,D.b.TEXTUREFORMAT_RGBA,!1,!0,my.e.NEAREST_SAMPLINGMODE,null,A);d.isWebGPU?await I.e(51).then(I.bind(I,14808)):await I.e(52).then(I.bind(I,14815)),await f.m.ApplyPostProcess("pass",F,B,A,D.b.TEXTURE_NEAREST_SAMPLINGMODE,D.b.TEXTUREFORMAT_RGBA);const J=await d._readTexturePixels(F,S,V);return await o.DumpTools.DumpDataAsync(S,V,J,i,void 0,!0,!0)}_resizeTexturesToSameDimensions(y,S,I){const V=y?y.getSize():{width:0,height:0},i=S?S.getSize():{width:0,height:0};let A,B;return V.width<i.width?(A=y&&y instanceof my.e?f.m.CreateResizedCopy(y,i.width,i.height,!0):g(i.width,i.height,I),B=S):V.width>i.width?(B=S&&S instanceof my.e?f.m.CreateResizedCopy(S,V.width,V.height,!0):g(V.width,V.height,I),A=y):(A=y,B=S),{texture1:A,texture2:B}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(y,S,I,V){const i=new Array;if(!y&&!S)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const A=y?y.Ey():S?S.Ey():null;if(A){var B;const d=this._resizeTexturesToSameDimensions(y,S,A),F=null===(B=d.texture1)||void 0===B?void 0:B.getSize();let J,u;const K=F.width,G=F.height,p=await d.texture1.readPixels(),L=await d.texture2.readPixels();if(!p)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(J=k(p),!L)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");u=k(L);const T=u.byteLength,j=new Uint8Array(T),s=new Uint8Array(T),O=4,f=n;let my=0,C=0;for(let y=0;y<G;++y)for(let S=0;S<K;++S){const V=(K*y+S)*O,i={diffuseColor:new l.DS(J[V],J[V+1],J[V+2]).toLinearSpace(A.getEngine().useExactSrgbConversions).multiply(I.diffuseColor),specularColor:new l.DS(u[V],u[V+1],u[V+2]).toLinearSpace(A.getEngine().useExactSrgbConversions).multiply(I.specularColor),glossiness:u[V+3]*I.glossiness},B=this._convertSpecularGlossinessToMetallicRoughness(i);f.r=Math.max(f.r,B.baseColor.r),f.g=Math.max(f.g,B.baseColor.g),f.b=Math.max(f.b,B.baseColor.b),my=Math.max(my,B.metallic),C=Math.max(C,B.roughness),s[V]=255*B.baseColor.r,s[V+1]=255*B.baseColor.g,s[V+2]=255*B.baseColor.b,s[V+3]=d.texture1.Fd?255*J[V+3]:255,j[V]=0,j[V+1]=255*B.roughness,j[V+2]=255*B.metallic,j[V+3]=255}const D={baseColor:f,metallic:my,roughness:C};let o=!1,z=!1;for(let y=0;y<G;++y)for(let S=0;S<K;++S){const I=(K*y+S)*O;s[I]/=D.baseColor.r>E?D.baseColor.r:1,s[I+1]/=D.baseColor.g>E?D.baseColor.g:1,s[I+2]/=D.baseColor.b>E?D.baseColor.b:1;const V=l.DS.FromInts(s[I],s[I+1],s[I+2]).toGammaSpace(A.getEngine().useExactSrgbConversions);s[I]=255*V.r,s[I+1]=255*V.g,s[I+2]=255*V.b,V.equalsWithEpsilon(h,E)||(z=!0),j[I+1]/=D.roughness>E?D.roughness:1,j[I+2]/=D.metallic>E?D.metallic:1;l.DS.FromInts(255,j[I+1],j[I+2]).equalsWithEpsilon(h,E)||(o=!0)}return o&&i.push(this._getImageDataAsync(j,K,G,V).then((y=>{D.metallicRoughnessTextureData=y}))),z&&i.push(this._getImageDataAsync(s,K,G,V).then((y=>{D.baseColorTextureData=y}))),await Promise.all(i).then((()=>D))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(y){const S=this._getPerceivedBrightness(y.diffuseColor),I=this._getPerceivedBrightness(y.specularColor),V=1-this._getMaxComponent(y.specularColor),i=v(S,I,V),A=y.diffuseColor.scale(V/(1-z.r)/Math.max(1-i)),B=y.specularColor.fS(z.scale(1-i)).scale(1/Math.max(i));let d=l.DS.Lerp(A,B,i*i);d=d.clampToRef(0,1,d);return{baseColor:d,metallic:i,roughness:1-y.glossiness}}_getPerceivedBrightness(y){return y?Math.sqrt(.299*y.r*y.r+.587*y.g*y.g+.114*y.b*y.b):0}_getMaxComponent(y){return y?Math.max(y.r,Math.max(y.g,y.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(y,S,I,V){const i=[],A={baseColor:y._albedoColor,metallic:y._metallic,roughness:y._roughness};if(V){y._albedoTexture&&i.push(this.exportTextureAsync(y._albedoTexture,S).then((y=>{y&&(I.baseColorTexture=y)})));const V=y._metallicTexture;V&&i.push(this.exportTextureAsync(V,S).then((y=>{y&&(I.metallicRoughnessTexture=y)})))}return i.length>0&&(this._exporter._materialNeedsUVsSet.add(y),await Promise.all(i)),A}_getTextureSampler(y){const S={};if(!y||!(y instanceof my.e))return S;const I=this._getGLTFTextureWrapMode(y.wrapU);10497!==I&&(S.wrapS=I);const V=this._getGLTFTextureWrapMode(y.wrapV);switch(10497!==V&&(S.wrapT=V),y.samplingMode){case my.e.LINEAR_LINEAR:S.magFilter=9729,S.minFilter=9729;break;case my.e.LINEAR_NEAREST:S.magFilter=9729,S.minFilter=9728;break;case my.e.NEAREST_LINEAR:S.magFilter=9728,S.minFilter=9729;break;case my.e.NEAREST_LINEAR_MIPLINEAR:S.magFilter=9728,S.minFilter=9987;break;case my.e.NEAREST_NEAREST:S.magFilter=9728,S.minFilter=9728;break;case my.e.NEAREST_LINEAR_MIPNEAREST:S.magFilter=9728,S.minFilter=9985;break;case my.e.LINEAR_NEAREST_MIPNEAREST:S.magFilter=9729,S.minFilter=9984;break;case my.e.LINEAR_NEAREST_MIPLINEAR:S.magFilter=9729,S.minFilter=9986;break;case my.e.NEAREST_NEAREST_MIPLINEAR:S.magFilter=9728,S.minFilter=9986;break;case my.e.LINEAR_LINEAR_MIPLINEAR:S.magFilter=9729,S.minFilter=9987;break;case my.e.LINEAR_LINEAR_MIPNEAREST:S.magFilter=9729,S.minFilter=9985;break;case my.e.NEAREST_NEAREST_MIPNEAREST:S.magFilter=9728,S.minFilter=9984}return S}_getGLTFTextureWrapMode(y){switch(y){case my.e.WRAP_ADDRESSMODE:return 10497;case my.e.CLAMP_ADDRESSMODE:return 33071;case my.e.MIRROR_ADDRESSMODE:return 33648;default:return i.Tools.Error(`Unsupported Texture Wrap Mode ${y}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(y,S,I,V){const i={diffuseColor:y._albedoColor,specularColor:y._reflectivityColor,glossiness:y._microSurface},A=y._albedoTexture,B=y._reflectivityTexture,d=y._useMicroSurfaceFromReflectivityMapAlpha;if(B&&!d)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((A||B)&&V){this._exporter._materialNeedsUVsSet.add(y);const V=this._exportTextureSampler(A||B),d=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(A,B,i,S),F=this._exporter._textures;if(d.baseColorTextureData){const y=this._exportImage(`baseColor${F.length}`,S,d.baseColorTextureData);I.baseColorTexture=this._exportTextureInfo(y,V,null===A||void 0===A?void 0:A.coordinatesIndex)}if(d.metallicRoughnessTextureData){const y=this._exportImage(`metallicRoughness${F.length}`,S,d.metallicRoughnessTextureData);I.metallicRoughnessTexture=this._exportTextureInfo(y,V,null===B||void 0===B?void 0:B.coordinatesIndex)}return d}return this._convertSpecularGlossinessToMetallicRoughness(i)}async exportPBRMaterialAsync(y,S,I){const V={},i={name:y.name},A=y.isMetallicWorkflow();if(A){const S=y._albedoColor,I=y.alpha;S&&(V.baseColorFactor=[S.r,S.g,S.b,I])}const B=A?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(y,S,V,I):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(y,S,V,I);await this._setMetallicRoughnessPbrMaterialAsync(B,y,i,V,S,I),await this._finishMaterialAsync(i,y,S);const d=this._exporter._materials;return d.push(i),d.length-1}async _setMetallicRoughnessPbrMaterialAsync(y,S,I,V,A,B){if(q(I,S),y.baseColor.equalsWithEpsilon(h,E)&&O.WithinEpsilon(S.alpha,1,E)||(V.baseColorFactor=[y.baseColor.r,y.baseColor.g,y.baseColor.b,S.alpha]),null!=y.metallic&&1!==y.metallic&&(V.metallicFactor=y.metallic),null!=y.roughness&&1!==y.roughness&&(V.roughnessFactor=y.roughness),null==S.Dd||S.Dd||(S._twoSidedLighting||i.Tools.Warn(S.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),I.doubleSided=!0),B){const y=[],V=S._bumpTexture;V&&y.push(this.exportTextureAsync(V,A).then((y=>{y&&(I.normalTexture=y,1!==V.level&&(I.normalTexture.scale=V.level))})));const i=S._ambientTexture;i&&y.push(this.exportTextureAsync(i,A).then((y=>{if(y){const V={index:y.index,texCoord:y.texCoord,extensions:y.extensions};I.occlusionTexture=V;const i=S._ambientTextureStrength;i&&(V.strength=i)}})));const B=S._emissiveTexture;B&&y.push(this.exportTextureAsync(B,A).then((y=>{y&&(I.emissiveTexture=y)}))),y.length>0&&(this._exporter._materialNeedsUVsSet.add(S),await Promise.all(y))}const d=S._emissiveColor;d.equalsWithEpsilon(n,E)||(I.emissiveFactor=d.Vd()),I.pbrMetallicRoughness=V}_getPixelsFromTextureAsync(y){return function(y){switch(y){case D.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case D.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case D.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case D.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case D.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case D.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case D.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case D.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case D.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case D.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case D.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case D.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case D.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case D.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case D.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case D.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case D.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case D.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case D.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(y.textureFormat)?(0,f.l)(y,y._texture.width,y._texture.height):(y.textureType,D.b.TEXTURETYPE_UNSIGNED_BYTE,y.readPixels())}async exportTextureAsync(y,S){const I=this._exporter._extensionsPreExportTextureAsync("exporter",y,S);return I?await I.then((async I=>I?await this._exportTextureInfoAsync(I,S):await this._exportTextureInfoAsync(y,S))):await this._exportTextureInfoAsync(y,S)}async _exportTextureInfoAsync(y,S){let I=this._textureMap.get(y);if(!I){const V=await this._getPixelsFromTextureAsync(y);if(!V)return null;const A=this._exportTextureSampler(y),B=y.mimeType;if(B)switch(B){case"image/jpeg":case"image/png":case"image/webp":S=B;break;default:i.Tools.Warn(`Unsupported media type: ${B}. Exporting texture as PNG.`)}const d=this._internalTextureToImage,F=y.getInternalTexture().uniqueId;d[F]||(d[F]={});let J=d[F][S];if(void 0===J){const I=y.getSize();J=(async()=>{const i=await this._getImageDataAsync(V,I.width,I.height,S);return this._exportImage(y.name,S,i)})(),d[F][S]=J}I=this._exportTextureInfo(await J,A,y.coordinatesIndex),this._textureMap.set(y,I),this._exporter._extensionsPostExportTextures("exporter",I,y)}return I}_exportImage(y,S,I){const V=this._exporter._images;let A;if(this._exporter._shouldUseGlb){A={name:y,mimeType:S,bufferView:void 0};const V=this._exporter._bufferManager.createBufferView(new Uint8Array(I));this._exporter._bufferManager.setBufferView(A,V)}else{const B=y.replace(/\.\/|\/|\.\\|\\/g,"_"),d=function(y){switch(y){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(S);let F=B+d;V.some((y=>y.uri===F))&&(F=`${B}_${i.Tools.RandomId()}${d}`),A={name:y,uri:F},this._exporter._imageData[F]={data:I,mimeType:S}}return V.push(A),V.length-1}_exportTextureInfo(y,S,I){const V=this._exporter._textures;let i=V.findIndex((I=>I.sampler==S&&I.source===y));-1===i&&(i=V.length,V.push({source:y,sampler:S}));const A={index:i};return I&&(A.texCoord=I),A}_exportTextureSampler(y){const S=this._getTextureSampler(y),I=this._exporter._samplers,V=I.findIndex((y=>y.minFilter===S.minFilter&&y.magFilter===S.magFilter&&y.wrapS===S.wrapS&&y.wrapT===S.wrapT));return-1!==V?V:(I.push(S),I.length-1)}}var b=I(12404),U=I(12151),W=I(12791),a=I(12325);const e=V.OS.Zero(),x=V.Quaternion.Identity(),Q=V.OS.One(),c=new V.OS(-1,1,1);function X(y,S){const{byteOffset:I,byteStride:V,type:i,normalized:A}=y,B=y.getSize(),d=S.reduce(((y,S)=>S.getTotalVertices()>y?S.getTotalVertices():y),-Number.MAX_VALUE);return{byteOffset:I,byteStride:V,componentCount:B,type:i,count:d*B,normalized:A,totalVertices:d,kind:y.getKind()}}function M(y){switch(y){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function t(y){switch(y){case u.e.PositionKind:case u.e.NormalKind:case u.e.TangentKind:case u.e.ColorKind:case u.e.MatricesIndicesKind:case u.e.MatricesIndicesExtraKind:case u.e.MatricesWeightsKind:case u.e.MatricesWeightsExtraKind:case u.e.UVKind:case u.e.UV2Kind:case u.e.UV3Kind:case u.e.UV4Kind:case u.e.UV5Kind:case u.e.UV6Kind:return!0}return!1}function N(y){switch(y){case A.d.TriangleFillMode:return 4;case A.d.TriangleStripDrawMode:return 5;case A.d.TriangleFanDrawMode:return 6;case A.d.PointListDrawMode:case A.d.PointFillMode:return 0;case A.d.LineLoopDrawMode:return 2;case A.d.LineListDrawMode:return 1;case A.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${y}`)}function Y(y){const S=Math.sqrt(y.x*y.x+y.y*y.y+y.z*y.z);S>0&&(y.x/=S,y.y/=S,y.z/=S)}function H(y){return y.x*=-1,y}function Z(y){if(y.x*y.x+y.y*y.y>.5){const S=Math.abs(y.x),I=Math.abs(y.y);if(S>I){const I=Math.sign(y.x);y.x=S,y.y*=-I,y.z*=-I,y.w*=I}else{const S=Math.sign(y.y);y.x*=-S,y.y=I,y.z*=S,y.w*=-S}}else{const S=Math.abs(y.z),I=Math.abs(y.w);if(S>I){const I=Math.sign(y.z);y.x*=-I,y.y*=I,y.z=S,y.w*=-I}else{const S=Math.sign(y.w);y.x*=S,y.y*=-S,y.z*=-S,y.w=I}}return y}function w(y){y.od(-y.z,y.w,y.x,-y.y)}function yy(y,S){const I=V.OS.FromArrayToRef(S.translation||[0,0,0],0,V.TmpVectors.OS[0]),i=V.Quaternion.FromArrayToRef(S.rotation||[0,0,0,1],0,V.TmpVectors.Quaternion[0]),A=V.Matrix.ComposeToRef(Q,i,I,V.TmpVectors.Matrix[0]),B=V.OS.FromArrayToRef(y.translation||[0,0,0],0,V.TmpVectors.OS[2]),d=V.Quaternion.FromArrayToRef(y.rotation||[0,0,0,1],0,V.TmpVectors.Quaternion[1]),F=V.Matrix.ComposeToRef(Q,d,B,V.TmpVectors.Matrix[1]);A.multiplyToRef(F,F),F.decompose(void 0,i,I),I.equalsWithEpsilon(e,a.c)?delete S.translation:S.translation=I.Vd(),i.equalsWithEpsilon(x,a.c)?delete S.rotation:S.rotation=i.Vd(),S.scale&&delete S.scale}function Sy(y,S){if(!(S instanceof K.d))return!1;if(!(1===S.getChildren().length&&0===y.getChildren().length&&y.parent===S))return!1;const I=y.Ey(),V=y instanceof W.d&&!I.useRightHandedSystem?c:Q;return!!S.zd.equalsWithEpsilon(V,a.c)||(U.b.Warn(`Cannot collapse node ${y.name} into parent node ${S.name} with modified scaling.`),!1)}function Iy(y){if(y instanceof Array){const S=new Float32Array(y);return new Uint8Array(S.buffer,S.byteOffset,S.byteLength)}return ArrayBuffer.isView(y)?new Uint8Array(y.buffer,y.byteOffset,y.byteLength):new Uint8Array(y)}function Vy(y,S){for(const[I,V]of Object.entries(y)){const i=S[I];(Array.isArray(V)&&Array.isArray(i)&&iy(V,i)||V===i)&&delete y[I]}return y}function iy(y,S){return y.length===S.length&&y.every(((y,I)=>y===S[I]))}const Ay=V.Matrix.Compose(new V.OS(-1,1,1),V.Quaternion.Identity(),V.OS.Zero());function By(y,S){if(!(y instanceof K.d))return!1;if(S){if(!y.getWorldMatrix().equalsWithEpsilon(V.Matrix.IdentityReadOnly,a.c))return!1}else{if(!y.getWorldMatrix().multiplyToRef(Ay,V.TmpVectors.Matrix[0]).equalsWithEpsilon(V.Matrix.IdentityReadOnly,a.c))return!1}return!(y instanceof G.e&&y.Od)}const dy=new Map([[Int8Array,(y,S,I)=>y.setInt8(S,I)],[Uint8Array,(y,S,I)=>y.setUint8(S,I)],[Uint8ClampedArray,(y,S,I)=>y.setUint8(S,I)],[Int16Array,(y,S,I)=>y.setInt16(S,I,!0)],[Uint16Array,(y,S,I)=>y.setUint16(S,I,!0)],[Int32Array,(y,S,I)=>y.setInt32(S,I,!0)],[Uint32Array,(y,S,I)=>y.setUint32(S,I,!0)],[Float32Array,(y,S,I)=>y.setFloat32(S,I,!0)],[Float64Array,(y,S,I)=>y.setFloat64(S,I,!0)]]);class Fy{writeTypedArray(y){this._checkGrowBuffer(y.byteLength);const S=dy.get(y.constructor);for(let I=0;I<y.length;I++)S(this._dataView,this._byteOffset,y[I]),this._byteOffset+=y.BYTES_PER_ELEMENT}constructor(y){this._data=new Uint8Array(y),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(y){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,y),this._byteOffset++}writeInt8(y){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,y),this._byteOffset++}writeInt16(y){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,y,!0),this._byteOffset+=2}writeUInt16(y){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,y,!0),this._byteOffset+=2}writeInt32(y){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,y,!0),this._byteOffset+=4}writeUInt32(y){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,y,!0),this._byteOffset+=4}writeFloat32(y){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,y,!0),this._byteOffset+=4}writeFloat64(y){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,y,!0),this._byteOffset+=8}_checkGrowBuffer(y){const S=this.byteOffset+y;if(S>this._data.byteLength){const y=new Uint8Array(2*S);y.set(this._data),this._data=y,this._dataView=new DataView(this._data.buffer)}}}function Jy(y){return y%4===0?4:y%2===0?2:1}class uy{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(y){let S=0;this._bufferViewToData.forEach((y=>{S+=y.byteLength}));const I=new Fy(S),V=Array.from(this._bufferViewToData.keys()).sort(((y,S)=>Jy(S.byteLength)-Jy(y.byteLength)));for(const i of V){i.byteOffset=I.byteOffset,y.push(i);const S=y.length-1,V=this.getPropertiesWithBufferView(i);for(const y of V)y.bufferView=S;I.writeTypedArray(this._bufferViewToData.get(i)),this._bufferViewToData.delete(i)}return I.getOutputData()}createBufferView(y,S){const I={buffer:0,byteOffset:void 0,byteLength:y.byteLength,byteStride:S};return this._bufferViewToData.set(I,y),I}createAccessor(y,S,I,V,i,A,B){this._verifyBufferView(y);const d={bufferView:void 0,componentType:I,count:V,type:S,min:null===A||void 0===A?void 0:A.min,max:null===A||void 0===A?void 0:A.max,normalized:B,byteOffset:i};return this.setBufferView(d,y),this._accessorToBufferView.set(d,y),d}setBufferView(y,S){this._verifyBufferView(S);this.getPropertiesWithBufferView(S).push(y)}removeBufferView(y){const S=this.getPropertiesWithBufferView(y);for(const I of S)void 0!==I.bufferView&&delete I.bufferView;this._bufferViewToData.delete(y),this._bufferViewToProperties.delete(y),this._accessorToBufferView.forEach(((S,I)=>{S===y&&(void 0!==I.byteOffset&&delete I.byteOffset,this._accessorToBufferView.delete(I))}))}getBufferView(y){const S=this._accessorToBufferView.get(y);return this._verifyBufferView(S),S}getPropertiesWithBufferView(y){return this._verifyBufferView(y),this._bufferViewToProperties.set(y,this._bufferViewToProperties.get(y)??[]),this._bufferViewToProperties.get(y)}getData(y){return this._verifyBufferView(y),this._bufferViewToData.get(y)}_verifyBufferView(y){if(void 0===y||!this._bufferViewToData.has(y))throw new Error(`BufferView ${y} not found in BufferManager.`)}}var Ky,Gy=I(12759),py=I(12776),Ly=I(12794),Ty=I(12686),ly=I(12838),jy=I(12854),sy=I(12753),Oy=I(12857);!function(y){y[y.INTANGENT=0]="INTANGENT",y[y.OUTTANGENT=1]="OUTTANGENT"}(Ky||(Ky={}));class fy{static _IsTransformable(y){return y&&(y instanceof K.d||y instanceof Gy.b||y instanceof Oy.e)}static _CreateNodeAnimation(y,S,I,V,A){if(this._IsTransformable(y)){const B=[],d=[],F=S.getKeys(),J=fy._CalculateMinMaxKeyFrames(F),u=fy._DeduceInterpolation(F,I,V),K=u.interpolationType,G=u.shouldBakeAnimation;if(G?fy._CreateBakedAnimation(y,S,I,J.min,J.max,S.framePerSecond,A,B,d,J,V):"LINEAR"===K||"STEP"===K?fy._CreateLinearOrStepAnimation(y,S,I,B,d,V):"CUBICSPLINE"===K?fy._CreateCubicSplineAnimation(y,S,I,B,d,V):fy._CreateBakedAnimation(y,S,I,J.min,J.max,S.framePerSecond,A,B,d,J,V),B.length&&d.length){return{inputs:B,outputs:d,samplerInterpolation:K,inputsMin:G?J.min:i.Tools.FloatRound(J.min/S.framePerSecond),inputsMax:G?J.max:i.Tools.FloatRound(J.max/S.framePerSecond)}}}return null}static _DeduceAnimationInfo(y){let S=null,I="VEC3",V=!1;const A=y.targetProperty.split(".");switch(A[0]){case"zd":S="scale";break;case"position":S="translation";break;case"rotation":I="VEC4",S="rotation";break;case"rotationQuaternion":I="VEC4",V=!0,S="rotation";break;case"influence":I="SCALAR",S="weights";break;default:i.Tools.Error(`Unsupported animatable property ${A[0]}`)}return S?{animationChannelTargetPath:S,dataAccessorType:I,useQuaternion:V}:(i.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(y,S,I,V,i,A,B,d,F,J,u){let K;if(fy._IsTransformable(y)&&y.animations)for(const G of y.animations){if(u&&!u(G))continue;const i=fy._DeduceAnimationInfo(G);i&&(K={name:G.name,samplers:[],channels:[]},fy._AddAnimation(`${G.name}`,G.hasRunningRuntimeAnimations?S:K,y,G,i.dataAccessorType,i.animationChannelTargetPath,V,A,B,d,i.useQuaternion,F,J),K.samplers.length&&K.channels.length&&I.push(K))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(y,S,I,V,i,A,B,d,F,J,u){let K;if(y instanceof sy.c){const i=y.morphTargetManager;if(i)for(let G=0;G<i.numTargets;++G){const p=i.getTarget(G);for(const L of p.animations){if(u&&!u(L))continue;const p=new ly.b(`${L.name}`,"influence",L.framePerSecond,L.dataType,L.loopMode,L.enableBlending),T=[],l=L.getKeys();for(let y=0;y<l.length;++y){const S=l[y];for(let y=0;y<i.numTargets;++y)y==G?T.push(S):T.push({frame:S.frame,value:0})}p.setKeys(T);const j=fy._DeduceAnimationInfo(p);j&&(K={name:p.name,samplers:[],channels:[]},fy._AddAnimation(L.name,L.hasRunningRuntimeAnimations?S:K,y,p,j.dataAccessorType,j.animationChannelTargetPath,V,A,B,d,j.useQuaternion,F,J,i.numTargets),K.samplers.length&&K.channels.length&&I.push(K))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(y,S,I,V,i,A,B,d,F){let J;if(y.animationGroups){const K=y.animationGroups;for(const G of K){const K=new Map,p=new Map,L=new Set,T=G.to-G.from;J={name:G.name,channels:[],samplers:[]};for(let S=0;S<G.targetedAnimations.length;++S){const T=G.targetedAnimations[S],l=T.target,j=T.animation;if(F&&!F(j))continue;const s=d.has(l);if(this._IsTransformable(l)||1===l.length&&this._IsTransformable(l[0])){const y=fy._DeduceAnimationInfo(T.animation);if(y){const S=this._IsTransformable(l)?l:this._IsTransformable(l[0])?l[0]:null;S&&fy._AddAnimation(`${j.name}`,J,S,j,y.dataAccessorType,y.animationChannelTargetPath,I,V,i,A,y.useQuaternion,B,s)}}else if(l instanceof jy.b||1===l.length&&l[0]instanceof jy.b){if(fy._DeduceAnimationInfo(T.animation)){const S=l instanceof jy.b?l:l[0];if(S){const I=y.morphTargetManagers.find((y=>{for(let I=0;I<y.numTargets;++I)if(y.getTarget(I)===S)return!0;return!1}));if(I){const V=y.meshes.find((y=>y.morphTargetManager===I));var u;if(V)K.has(V)||K.set(V,new Map),null===(u=K.get(V))||void 0===u||u.set(S,j),L.add(V),p.set(V,j)}}}}}L.forEach((y=>{const S=y.morphTargetManager;let d=null;const F=[],u=p.get(y).getKeys(),L=u.length;for(let I=0;I<L;++I)for(let V=0;V<S.numTargets;++V){const i=S.getTarget(V),A=K.get(y);if(A){const S=A.get(i);S?(d||(d=new ly.b(`${G.name}_${y.name}_MorphWeightAnimation`,"influence",S.framePerSecond,ly.b.ANIMATIONTYPE_FLOAT,S.loopMode,S.enableBlending)),F.push(S.getKeys()[I])):F.push({frame:G.from+T/L*I,value:i.influence,inTangent:u[0].inTangent?0:void 0,outTangent:u[0].outTangent?0:void 0})}}d.setKeys(F);const l=fy._DeduceAnimationInfo(d);l&&fy._AddAnimation(`${G.name}_${y.name}_MorphWeightAnimation`,J,y,d,l.dataAccessorType,l.animationChannelTargetPath,I,V,i,A,l.useQuaternion,B,!1,null===S||void 0===S?void 0:S.numTargets)})),J.channels.length&&J.samplers.length&&S.push(J)}}}static _AddAnimation(y,S,I,i,A,B,d,F,J,u,K,G,p,L){const T=fy._CreateNodeAnimation(I,i,B,K,G);let l,j,s,O,f,my;if(T){if(L){let y=0,S=0;const I=[];for(;T.inputs.length>0;)S=T.inputs.shift(),y%L==0&&I.push(S),y++;T.inputs=I}const y=d.get(I),i=new Float32Array(T.inputs);l=F.createBufferView(i),j=F.createAccessor(l,"SCALAR",5126,T.inputs.length,void 0,{min:[T.inputsMin],max:[T.inputsMax]}),u.push(j),s=u.length-1;const J=new V.Quaternion,K=new V.OS,G=new V.OS,C=I instanceof Gy.b,D=M(A),o=new Float32Array(T.outputs.length*D);T.outputs.forEach((function(y,S){let I=y;switch(B){case"translation":p&&(V.OS.FromArrayToRef(y,0,G),H(G),G.toArray(I));break;case"rotation":4===y.length?V.Quaternion.FromArrayToRef(y,0,J):(I=new Array(4),V.OS.FromArrayToRef(y,0,K),V.Quaternion.FromEulerVectorToRef(K,J)),p&&(Z(J),C&&w(J)),J.toArray(I)}o.set(I,S*D)})),l=F.createBufferView(o),j=F.createAccessor(l,A,5126,T.outputs.length),u.push(j),O=u.length-1,f={interpolation:T.samplerInterpolation,input:s,output:O},S.samplers.push(f),my={sampler:S.samplers.length-1,target:{node:y,path:B}},S.channels.push(my)}}static _CreateBakedAnimation(y,S,I,A,B,d,F,J,u,K,G){let p;const L=V.Quaternion.Identity();let T,l=null,j=null,s=null,O=null,f=null,my=null;K.min=i.Tools.FloatRound(A/d);const C=S.getKeys();for(let V=0,D=C.length;V<D;++V){if(my=null,s=C[V],V+1<D)if(O=C[V+1],s.value.equals&&s.value.equals(O.value)||s.value===O.value){if(0!==V)continue;my=s.frame}else my=O.frame;else{if(f=C[V-1],s.value.equals&&s.value.equals(f.value)||s.value===f.value)continue;my=B}if(my)for(let V=s.frame;V<=my;V+=F){if(T=i.Tools.FloatRound(V/d),T===l)continue;l=T,j=T;const A={key:0,repeatCount:0,loopMode:S.loopMode};p=S._interpolate(V,A),fy._SetInterpolatedValue(y,p,T,S,I,L,J,u,G)}}j&&(K.max=j)}static _ConvertFactorToVector3OrQuaternion(y,S,I,A,B){const d=fy._GetBasePositionRotationOrScale(S,A,B),F=I.targetProperty.split("."),J=F?F[1]:"",u=B?V.Quaternion.oS(d).normalize():V.OS.oS(d);switch(J){case"x":case"y":case"z":u[J]=y;break;case"w":u.w=y;break;default:i.Tools.Error(`glTFAnimation: Unsupported component name "${J}"!`)}return u}static _SetInterpolatedValue(y,S,I,i,A,B,d,F,J){let u;d.push(I),"weights"!==A?(i.dataType===ly.b.ANIMATIONTYPE_FLOAT&&(S=this._ConvertFactorToVector3OrQuaternion(S,y,i,A,J)),"rotation"===A?(J?B=S:(u=S,V.Quaternion.RotationYawPitchRollToRef(u.y,u.x,u.z,B)),F.push(B.Vd())):(u=S,F.push(u.Vd()))):F.push([S])}static _CreateLinearOrStepAnimation(y,S,I,V,i,A){for(const B of S.getKeys())V.push(B.frame/S.framePerSecond),fy._AddKeyframeValue(B,S,i,I,y,A)}static _CreateCubicSplineAnimation(y,S,I,V,i,A){S.getKeys().forEach((function(B){V.push(B.frame/S.framePerSecond),fy._AddSplineTangent(Ky.INTANGENT,i,I,"CUBICSPLINE",B,A),fy._AddKeyframeValue(B,S,i,I,y,A),fy._AddSplineTangent(Ky.OUTTANGENT,i,I,"CUBICSPLINE",B,A)}))}static _GetBasePositionRotationOrScale(y,S,I){let i;if("rotation"===S)if(I){i=(y.rotationQuaternion??V.Quaternion.Identity()).Vd()}else{i=(y.rotation??V.OS.Zero()).Vd()}else if("translation"===S){i=(y.position??V.OS.Zero()).Vd()}else{i=(y.zd??V.OS.One()).Vd()}return i}static _AddKeyframeValue(y,S,I,A,B,d){let F;const J=S.dataType;if(J===ly.b.ANIMATIONTYPE_VECTOR3){let S=y.value.Vd();if("rotation"===A){const y=V.OS.oS(S);S=V.Quaternion.RotationYawPitchRoll(y.y,y.x,y.z).Vd()}I.push(S)}else if(J===ly.b.ANIMATIONTYPE_FLOAT){if("weights"===A)I.push([y.value]);else if(F=this._ConvertFactorToVector3OrQuaternion(y.value,B,S,A,d),F){if("rotation"===A){const y=d?F:V.Quaternion.RotationYawPitchRoll(F.y,F.x,F.z).normalize();I.push(y.Vd())}I.push(F.Vd())}}else J===ly.b.ANIMATIONTYPE_QUATERNION?I.push(y.value.normalize().Vd()):i.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(y,S,I){let V,i,A=!1;if("rotation"===S&&!I)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let B=0,d=y.length;B<d;++B)if(i=y[B],i.inTangent||i.outTangent)if(V){if("CUBICSPLINE"!==V){V="LINEAR",A=!0;break}}else V="CUBICSPLINE";else if(V){if("CUBICSPLINE"===V||i.interpolation&&1===i.interpolation&&"STEP"!==V){V="LINEAR",A=!0;break}}else V=i.interpolation&&1===i.interpolation?"STEP":"LINEAR";return V||(V="LINEAR"),{interpolationType:V,shouldBakeAnimation:A}}static _AddSplineTangent(y,S,I,i,A,B){let d;const F=y===Ky.INTANGENT?A.inTangent:A.outTangent;if("CUBICSPLINE"===i){if("rotation"===I)if(F)if(B)d=F.Vd();else{const y=F;d=V.Quaternion.RotationYawPitchRoll(y.y,y.x,y.z).Vd()}else d=[0,0,0,0];else d="weights"===I?F?[F]:[0]:F?F.Vd():[0,0,0];S.push(d)}}static _CalculateMinMaxKeyFrames(y){let S=1/0,I=-1/0;return y.forEach((function(y){S=Math.min(S,y.frame),I=Math.max(I,y.frame)})),{min:S,max:I}}}function mS(y,S,I,A,B,d){const F={attributes:{},influence:y.influence,name:y.name},J=S.Od;if(!J)return i.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),F;const K=d?-1:1,G=V.OS.Zero();let p=0,L=0;if(y.hasPositions){const A=y.getPositions(),d=J.getVerticesData(u.e.PositionKind);if(d){const y=new Float32Array(d.length),S=[1/0,1/0,1/0],i=[-1/0,-1/0,-1/0];L=d.length/3,p=0;for(let I=p;I<L;++I){const B=V.OS.oS(d,3*I);V.OS.oS(A,3*I).subtractToRef(B,G),G.x*=K,S[0]=Math.min(S[0],G.x),i[0]=Math.max(i[0],G.x),S[1]=Math.min(S[1],G.y),i[1]=Math.max(i[1],G.y),S[2]=Math.min(S[2],G.z),i[2]=Math.max(i[2],G.z),y[3*I]=G.x,y[3*I+1]=G.y,y[3*I+2]=G.z}const J=I.createBufferView(y,12),u=I.createAccessor(J,"VEC3",5126,A.length/3,0,{min:S,max:i});B.push(u),F.attributes.POSITION=B.length-1}else i.Tools.Warn(`Morph target positions for mesh ${S.name} were not exported. Mesh does not have position vertex data`)}if(y.hasNormals){const A=y.getNormals(),d=J.getVerticesData(u.e.NormalKind);if(d){const y=new Float32Array(d.length);L=d.length/3,p=0;for(let I=p;I<L;++I){const S=V.OS.oS(d,3*I).normalize();V.OS.oS(A,3*I).normalize().subtractToRef(S,G),y[3*I]=G.x*K,y[3*I+1]=G.y,y[3*I+2]=G.z}const S=I.createBufferView(y,12),i=I.createAccessor(S,"VEC3",5126,A.length/3,0);B.push(i),F.attributes.NORMAL=B.length-1}else i.Tools.Warn(`Morph target normals for mesh ${S.name} were not exported. Mesh does not have normals vertex data`)}if(y.hasTangents){const A=y.getTangents(),d=J.getVerticesData(u.e.TangentKind);if(d){L=d.length/4;const y=new Float32Array(3*L);p=0;for(let I=p;I<L;++I){const S=V.OS.oS(d,4*I);Y(S);const i=V.OS.oS(A,3*I);Y(i),i.subtractToRef(S,G),y[3*I]=G.x*K,y[3*I+1]=G.y,y[3*I+2]=G.z}const S=I.createBufferView(y,12),i=I.createAccessor(S,"VEC3",5126,L,0);B.push(i),F.attributes.TANGENT=B.length-1}else i.Tools.Warn(`Morph target tangents for mesh ${S.name} were not exported. Mesh does not have tangents vertex data`)}if(y.hasColors){const A=y.getColors(),d=J.getVerticesData(u.e.ColorKind),K=J.getVertexBuffer(u.e.ColorKind);if(d&&K){const y=K.getSize();L=d.length/y;const S=new Float32Array(L*y);p=0;for(let I=p;I<L;++I)if(3===y){const i=V.OS.oS(d,I*y);V.OS.oS(A,I*y).subtractToRef(i,G),S[3*I]=G.x,S[3*I+1]=G.y,S[3*I+2]=G.z}else if(4===y){const i=new V.Vector4,B=V.Vector4.oS(d,I*y);V.Vector4.oS(A,I*y).subtractToRef(B,i),S[4*I]=i.x,S[4*I+1]=i.y,S[4*I+2]=i.z,S[4*I+3]=i.w}else i.Tools.Warn(`Unsupported number of components for color attribute: ${y}`);const J=I.createBufferView(S,4*y),u=I.createAccessor(J,3===y?"VEC3":"VEC4",5126,L,0);B.push(u),F.attributes.COLOR_0=B.length-1}else i.Tools.Warn(`Morph target colors for mesh ${S.name} were not exported. Mesh does not have colors vertex data`)}return F}var Cy=I(12861),Dy=I(12705),oy=I(12694),Ey=I(12282);class zy{}zy.DEFAULT_COLOR=l.DS.White(),zy.DEFAULT_WIDTH_ATTENUATED=1,zy.DEFAULT_WIDTH=.1;var ry=I(12535),hy=I(12869);class ny{static ConvertPoints(y,S){if(y.length&&Array.isArray(y)&&"number"===typeof y[0])return[y];if(y.length&&Array.isArray(y[0])&&"number"===typeof y[0][0])return y;if(y.length&&!Array.isArray(y[0])&&y[0]instanceof V.OS){const S=[];for(let I=0;I<y.length;I++){const V=y[I];S.push(V.x,V.y,V.z)}return[S]}if(y.length>0&&Array.isArray(y[0])&&y[0].length>0&&y[0][0]instanceof V.OS){const S=[],I=y;for(const y of I)S.push(y.flatMap((y=>[y.x,y.y,y.z])));return S}if(y instanceof Float32Array){if(null!==S&&void 0!==S&&S.floatArrayStride){const I=[],V=3*S.floatArrayStride;for(let S=0;S<y.length;S+=V){const i=new Array(V);for(let I=0;I<V;I++)i[I]=y[S+I];I.push(i)}return I}return[Array.from(y)]}if(y.length&&y[0]instanceof Float32Array){const S=[];for(const I of y)S.push(Array.from(I));return S}return[]}static OmitZeroLengthPredicate(y,S,I){const V=[];return S.fS(y).lengthSquared()>0&&V.push([y,S]),I.fS(S).lengthSquared()>0&&V.push([S,I]),y.fS(I).lengthSquared()>0&&V.push([I,y]),0===V.length?null:V}static OmitDuplicatesPredicate(y,S,I,V){const i=[];return ny._SearchInPoints(y,S,V)||i.push([y,S]),ny._SearchInPoints(S,I,V)||i.push([S,I]),ny._SearchInPoints(I,y,V)||i.push([I,y]),0===i.length?null:i}static _SearchInPoints(y,S,I){for(const B of I)for(let I=0;I<B.length;I++){var V,i,A;if(null!==(V=B[I])&&void 0!==V&&V.equals(y))if(null!==(i=B[I+1])&&void 0!==i&&i.equals(S)||null!==(A=B[I-1])&&void 0!==A&&A.equals(S))return!0}return!1}static MeshesToLines(y,S){const I=[];for(let i=0;i<y.length;i++){const A=y[i],B=A.getVerticesData(u.e.PositionKind),d=A.fd();if(B&&d)for(let y=0,F=0;y<d.length;y++){const J=3*d[F++],u=3*d[F++],K=3*d[F++],G=new V.OS(B[J],B[J+1],B[J+2]),p=new V.OS(B[u],B[u+1],B[u+2]),L=new V.OS(B[K],B[K+1],B[K+2]);if(S){const V=S(G,p,L,I,y,J,A,i,B,d);if(V)for(const y of V)I.push(y)}else I.push([G,p],[p,L],[L,G])}}return I}static ToVector3Array(y){if(Array.isArray(y[0])){const S=[],I=y;for(const y of I){const I=[];for(let S=0;S<y.length;S+=3)I.push(new V.OS(y[S],y[S+1],y[S+2]));S.push(I)}return S}const S=y,I=[];for(let i=0;i<S.length;i+=3)I.push(new V.OS(S[i],S[i+1],S[i+2]));return I}static ToNumberArray(y){return y.flatMap((y=>[y.x,y.y,y.z]))}static GetPointsCountInfo(y){const S=new Array(y.length);let I=0;for(let V=y.length;V--;)S[V]=y[V].length/3,I+=S[V];return{total:I,counts:S}}static GetLineLength(y){if(0===y.length)return 0;let S;S="number"===typeof y[0]?ny.ToVector3Array(y):y;const I=V.TmpVectors.OS[0];let i=0;for(let V=0;V<S.length-1;V++){const y=S[V];i+=S[V+1].subtractToRef(y,I).length()}return i}static GetLineLengthArray(y){const S=new Float32Array(y.length/3);let I=0;for(let V=0,i=y.length/3-1;V<i;V++){let i=y[3*V+0],A=y[3*V+1],B=y[3*V+2];i-=y[3*V+3],A-=y[3*V+4],B-=y[3*V+5];I+=Math.sqrt(i*i+A*A+B*B),S[V+1]=I}return S}static SegmentizeSegmentByCount(y,S,I){const i=[],A=S.fS(y),B=V.TmpVectors.OS[0];B.nd(I);const d=V.TmpVectors.OS[1];A.divideToRef(B,d);let F=y.clone();i.push(F);for(let V=0;V<I;V++)F=F.clone(),i.push(F.addInPlace(d));return i}static SegmentizeLineBySegmentLength(y,S){const I=y[0]instanceof V.OS?ny.GetLineSegments(y):"number"===typeof y[0]?ny.GetLineSegments(ny.ToVector3Array(y)):y,i=[];for(const V of I)if(V.length>S){const y=ny.SegmentizeSegmentByCount(V.point1,V.point2,Math.ceil(V.length/S));for(const S of y)i.push(S)}else i.push(V.point1),i.push(V.point2);return i}static SegmentizeLineBySegmentCount(y,S){const I="number"===typeof y[0]?ny.ToVector3Array(y):y,V=ny.GetLineLength(I)/S;return ny.SegmentizeLineBySegmentLength(I,V)}static GetLineSegments(y){const S=[];for(let I=0;I<y.length-1;I++){const V=y[I],i=y[I+1],A=i.fS(V).length();S.push({point1:V,point2:i,length:A})}return S}static GetMinMaxSegmentLength(y){const S=ny.GetLineSegments(y).sort((y=>y.length));return{min:S[0].length,max:S[S.length-1].length}}static GetPositionOnLineByVisibility(y,S,I){let i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const A=S*I;let B=0,d=0;const F=y.length;for(let V=0;V<F;V++){if(A<=B+y[V].length){d=V;break}B+=y[V].length}const J=(A-B)/y[d].length;return y[d].point2.subtractToRef(y[d].point1,V.TmpVectors.OS[0]),V.TmpVectors.OS[1]=V.TmpVectors.OS[0].multiplyByFloats(J,J,J),i||V.TmpVectors.OS[1].addInPlace(y[d].point1),V.TmpVectors.OS[1].clone()}static GetCircleLinePoints(y,S){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:y,A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/S;const B=[];for(let d=0;d<=S;d++)B.push(new V.OS(Math.cos(d*A)*y,Math.sin(d*A)*i,I));return B}static GetBezierLinePoints(y,S,I,V){return ry.g.CreateQuadraticBezier(y,S,I,V).getPoints().flatMap((y=>[y.x,y.y,y.z]))}static GetArrowCap(y,S,I,V,i){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,B=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[y.clone(),y.add(S.multiplyByFloats(I,I,I))],widths:[V,i,A,B]}}static GetPointsFromText(y,S,I,V){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,A=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const B=[],d=(0,hy.c)(y,S,I,V);for(const F of d){for(const y of F.paths){const S=[],I=y.getPoints();for(const y of I)S.push(y.x,y.y,i);B.push(S)}if(A)for(const y of F.holes){const S=[],I=y.getPoints();for(const y of I)S.push(y.x,y.y,i);B.push(S)}}return B}static Color3toRGBAUint8(y){const S=new Uint8Array(4*y.length);for(let I=0,V=0;I<y.length;I++)S[V++]=255*y[I].r,S[V++]=255*y[I].g,S[V++]=255*y[I].b,S[V++]=255;return S}static CreateColorsTexture(y,S,I,V){const i=V.getEngine().getCaps().maxTextureSize??1,A=S.length>i?i:S.length,B=Math.ceil(S.length/i);B>1&&(S=[...S,...Array(A*B-S.length).fill(S[0])]);const d=ny.Color3toRGBAUint8(S),F=new C.b(d,A,B,L.c.TEXTUREFORMAT_RGBA,V,!1,!0,I);return F.name=y,F}static PrepareEmptyColorsTexture(y){if(!zy.EmptyColorsTexture){const S=new Uint8Array(4);zy.EmptyColorsTexture=new C.b(S,1,1,L.c.TEXTUREFORMAT_RGBA,y,!1,!1,C.b.NEAREST_NEAREST),zy.EmptyColorsTexture.name="grlEmptyColorsTexture"}return zy.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var y;null===(y=zy.EmptyColorsTexture)||void 0===y||y.dispose(),zy.EmptyColorsTexture=null}static BooleanToNumber(y){return y?1:0}}class vy extends oy.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Py extends Dy.e{isCompatible(y){return!0}constructor(y,S,I){var i;I=I||{color:zy.DEFAULT_COLOR};const A=new vy;A.GREASED_LINE_HAS_COLOR=!!I.color&&!I.useColors,A.GREASED_LINE_SIZE_ATTENUATION=I.sizeAttenuation??!1,A.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===I.colorDistributionType,A.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(S??y.Ey()).useRightHandedSystem,A.GREASED_LINE_CAMERA_FACING=I.cameraFacing??!0,super(y,Py.GREASED_LINE_MATERIAL_NAME,200,A,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(i=I)||void 0===i?void 0:i.forceGLSL)||Py.ForceGLSL,this._scene=S??y.Ey(),this._engine=this._scene.getEngine(),this._cameraFacing=I.cameraFacing??!0,this.visibility=I.visibility??1,this.useDash=I.useDash??!1,this.dashRatio=I.dashRatio??.5,this.dashOffset=I.dashOffset??0,this.width=I.width?I.width:I.sizeAttenuation?zy.DEFAULT_WIDTH_ATTENUATED:zy.DEFAULT_WIDTH,this._sizeAttenuation=I.sizeAttenuation??!1,this.colorMode=I.colorMode??0,this._color=I.color??null,this.useColors=I.useColors??!1,this._colorsDistributionType=I.colorDistributionType??0,this.colorsSampling=I.colorsSampling??C.b.NEAREST_NEAREST,this._colors=I.vy??null,this.dashCount=I.dashCount??1,this.resolution=I.resolution??new V.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),I.colorsTexture?this.colorsTexture=I.colorsTexture:this._colors?this.colorsTexture=ny.CreateColorsTexture(`${y.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??zy.DEFAULT_COLOR,ny.PrepareEmptyColorsTexture(this._scene)),this._engine.zi.add((()=>{ny.DisposeEmptyColorsTexture()}))}getAttributes(y){y.push("grl_offsets"),y.push("grl_widths"),y.push("grl_colorPointers"),y.push("grl_counters"),this._cameraFacing?(y.push("grl_previousAndSide"),y.push("grl_nextAndCounters")):y.push("grl_slopes")}getSamplers(y){y.push("grl_colors")}getActiveTextures(y){this.colorsTexture&&y.push(this.colorsTexture)}getUniforms(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const S=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&S.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===y&&S.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:S,vertex:this._cameraFacing&&this._isGLSL(y)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(y)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(y){if(this._cameraFacing){y.jd("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||y.jd("viewProjection",this._scene.getTransformMatrix());const S=V.TmpVectors.Vector4[0];S.x=this._aspect,S.y=this._resolution.x,S.z=this._resolution.y,S.w=this.width,y.updateVector4("grl_aspect_resolution_lineWidth",S)}const S=V.TmpVectors.Vector4[0];S.x=ny.BooleanToNumber(this.useDash),S.y=this._dashArray,S.z=this.dashOffset,S.w=this.dashRatio,y.updateVector4("grl_dashOptions",S);const I=V.TmpVectors.Vector4[1];I.x=this.colorMode,I.y=this.visibility,I.z=this.colorsTexture?this.colorsTexture.getSize().width:0,I.w=ny.BooleanToNumber(this.useColors),y.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",I),this._color&&y.updateColor3("grl_singleColor",this._color);const i=this.colorsTexture??zy.EmptyColorsTexture;y.setTexture("grl_colors",i),y.updateFloat2("grl_textureSize",(null===i||void 0===i?void 0:i.getSize().width)??1,(null===i||void 0===i?void 0:i.getSize().height)??1)}prepareDefines(y,S,I){y.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,y.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,y.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,y.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=S.useRightHandedSystem,y.GREASED_LINE_CAMERA_FACING=this._cameraFacing,y.GREASED_LINE_USE_OFFSETS=!!I.offsets}getClassName(){return Py.GREASED_LINE_MATERIAL_NAME}getCustomCode(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(S)?function(y,S){if("vertex"===y){const y={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return S&&(y["!gl_Position\\=viewProjection\\*worldPos;"]="//"),y}return"fragment"===y?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(y,this._cameraFacing):function(y,S){if("vertex"===y){const y={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return S&&(y["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),y}return"fragment"===y?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(y,this._cameraFacing)}dispose(){var y;null===(y=this.colorsTexture)||void 0===y||y.dispose(),super.dispose()}get vy(){return this._colors}set vy(y){this.setColors(y)}setColors(y){var S;let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=(null===(S=this._colors)||void 0===S?void 0:S.length)??0;var A;if(this._colors=y,null!==y&&0!==y.length){if(!I||V)if(this.colorsTexture&&i===y.length&&!V){const S=ny.Color3toRGBAUint8(y);this.colorsTexture.update(S)}else{var B;null===(B=this.colorsTexture)||void 0===B||B.dispose(),this.colorsTexture=ny.CreateColorsTexture(`${this._material.name}-colors-texture`,y,this.colorsSampling,this._scene)}}else null===(A=this.colorsTexture)||void 0===A||A.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(y){this._dashCount=y,this._dashArray=1/y}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(y){this._sizeAttenuation=y,this.markAllDefinesAsDirty()}get color(){return this._color}set color(y){this.setColor(y)}setColor(y){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==y||null!==this._color&&null===y?(this._color=y,S||this.markAllDefinesAsDirty()):this._color=y}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(y){this._colorsDistributionType=y,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(y){this._aspect=y.x/y.y,this._resolution=y}serialize(){const y=super.serialize(),S={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(S.vy=this._colors),this._color&&(S.color=this._color),y.greasedLineMaterialOptions=S,y}parse(y,S,I){var V;super.parse(y,S,I);const i=y.greasedLineMaterialOptions;null===(V=this.colorsTexture)||void 0===V||V.dispose(),i.color&&this.setColor(i.color,!0),i.colorDistributionType&&(this.colorsDistributionType=i.colorDistributionType),i.vy&&(this.vy=i.vy),i.colorsSampling&&(this.colorsSampling=i.colorsSampling),i.colorMode&&(this.colorMode=i.colorMode),i.useColors&&(this.useColors=i.useColors),i.visibility&&(this.visibility=i.visibility),i.useDash&&(this.useDash=i.useDash),i.dashCount&&(this.dashCount=i.dashCount),i.dashRatio&&(this.dashRatio=i.dashRatio),i.dashOffset&&(this.dashOffset=i.dashOffset),i.width&&(this.width=i.width),i.sizeAttenuation&&(this.sizeAttenuation=i.sizeAttenuation),i.resolution&&(this.resolution=i.resolution),this.vy?this.colorsTexture=ny.CreateColorsTexture(`${this._material.name}-colors-texture`,this.vy,this.colorsSampling,S):ny.PrepareEmptyColorsTexture(S),this.markAllDefinesAsDirty()}copyTo(y){var S;const I=y;null===(S=I.colorsTexture)||void 0===S||S.dispose(),this._colors&&(I.colorsTexture=ny.CreateColorsTexture(`${I._material.name}-colors-texture`,this._colors,I.colorsSampling,this._scene)),I.setColor(this.color,!0),I.colorsDistributionType=this.colorsDistributionType,I.colorsSampling=this.colorsSampling,I.colorMode=this.colorMode,I.useColors=this.useColors,I.visibility=this.visibility,I.useDash=this.useDash,I.dashCount=this.dashCount,I.dashRatio=this.dashRatio,I.dashOffset=this.dashOffset,I.width=this.width,I.sizeAttenuation=this.sizeAttenuation,I.resolution=this.resolution,I.markAllDefinesAsDirty()}_isGLSL(y){return 0===y||this._forceGLSL}}Py.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Py.ForceGLSL=!1,(0,Ey.e)(`BABYLON.${Py.GREASED_LINE_MATERIAL_NAME}`,Py);var qy=I(12739),gy=I(12159),ky=I(12553),Ry=I(12268);class by extends ky.ShaderMaterial{constructor(y,S,i){const A=S.getEngine(),B=A.isWebGPU&&!(i.forceGLSL||by.ForceGLSL),d=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];S.useRightHandedSystem&&d.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const F=["position","grl_widths","grl_offsets","grl_colorPointers"];i.cameraFacing?(d.push("GREASED_LINE_CAMERA_FACING"),F.push("grl_previousAndSide","grl_nextAndCounters")):(F.push("grl_slopes"),F.push("grl_counters"));const J=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(B||J.push("world","viewProjection","view","projection"),super(y,S,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:B?["Scene","Mesh"]:void 0,attributes:F,uniforms:J,samplers:B?[]:["grlColors"],defines:d,extraInitializationsAsync:async()=>{B?await Promise.all([I.e(66).then(I.bind(I,15435)),I.e(75).then(I.bind(I,15438))]):await Promise.all([I.e(69).then(I.bind(I,15440)),I.e(76).then(I.bind(I,15443))])},shaderLanguage:B?1:0}),this._color=l.DS.White(),this._colorsDistributionType=0,this._colorsTexture=null,i=i||{color:zy.DEFAULT_COLOR},this.visibility=i.visibility??1,this.useDash=i.useDash??!1,this.dashRatio=i.dashRatio??.5,this.dashOffset=i.dashOffset??0,this.dashCount=i.dashCount??1,this.width=i.width?i.width:i.sizeAttenuation&&i.cameraFacing?zy.DEFAULT_WIDTH_ATTENUATED:zy.DEFAULT_WIDTH,this.sizeAttenuation=i.sizeAttenuation??!1,this.color=i.color??l.DS.White(),this.useColors=i.useColors??!1,this.colorsDistributionType=i.colorDistributionType??0,this.colorsSampling=i.colorsSampling??C.b.NEAREST_NEAREST,this.colorMode=i.colorMode??0,this._colors=i.vy??null,this._cameraFacing=i.cameraFacing??!0,this.resolution=i.resolution??new V.Vector2(A.getRenderWidth(),A.getRenderHeight()),i.colorsTexture?this.colorsTexture=i.colorsTexture:this._colors?this.colorsTexture=ny.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,S):(this._color=this._color??zy.DEFAULT_COLOR,this.colorsTexture=ny.PrepareEmptyColorsTexture(S)),B){const y=new Ry.c;y.setParameters(),y.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",y)}A.zi.add((()=>{ny.DisposeEmptyColorsTexture()}))}dispose(){var y;null===(y=this._colorsTexture)||void 0===y||y.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new V.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get vy(){return this._colors}set vy(y){this.setColors(y)}setColors(y){var S;let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=(null===(S=this._colors)||void 0===S?void 0:S.length)??0;var A;if(this._colors=y,null!==y&&0!==y.length){if(!I||V)if(this._colorsTexture&&i===y.length&&!V){const S=ny.Color3toRGBAUint8(y);this._colorsTexture.update(S)}else{var B;null===(B=this._colorsTexture)||void 0===B||B.dispose(),this.colorsTexture=ny.CreateColorsTexture(`${this.name}-colors-texture`,y,this.colorsSampling,this.Ey())}}else null===(A=this._colorsTexture)||void 0===A||A.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(y){this._colorsTexture=y,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(y){this._width=y,this.setFloat("grlWidth",y)}get useColors(){return this._useColors}set useColors(y){this._useColors=y,this.setFloat("grlUseColors",ny.BooleanToNumber(y))}get colorsSampling(){return this._colorsSampling}set colorsSampling(y){this._colorsSampling=y}get visibility(){return this._visibility}set visibility(y){this._visibility=y,this.setFloat("grlVisibility",y)}get useDash(){return this._useDash}set useDash(y){this._useDash=y,this.setFloat("grlUseDash",ny.BooleanToNumber(y))}get dashOffset(){return this._dashOffset}set dashOffset(y){this._dashOffset=y,this.setFloat("grlDashOffset",y)}get dashRatio(){return this._dashRatio}set dashRatio(y){this._dashRatio=y,this.setFloat("grlDashRatio",y)}get dashCount(){return this._dashCount}set dashCount(y){this._dashCount=y,this._dashArray=1/y,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(y){this._sizeAttenuation=y,this.setFloat("grlSizeAttenuation",ny.BooleanToNumber(y))}get color(){return this._color}set color(y){this.setColor(y)}setColor(y){y=y??zy.DEFAULT_COLOR,this._color=y,this.setColor3("grlColor",y)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(y){this._colorsDistributionType=y,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(y){this._colorMode=y,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(y){this._resolution=y,this.setVector2("grlResolution",y),this.setFloat("grlAspect",y.x/y.y)}serialize(){const y=super.serialize(),S={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(S.vy=this._colors),y.greasedLineMaterialOptions=S,y}parse(y,S,I){var V;const i=y.greasedLineMaterialOptions;null===(V=this._colorsTexture)||void 0===V||V.dispose(),i.color&&(this.color=i.color),i.colorDistributionType&&(this.colorsDistributionType=i.colorDistributionType),i.colorsSampling&&(this.colorsSampling=i.colorsSampling),i.colorMode&&(this.colorMode=i.colorMode),i.useColors&&(this.useColors=i.useColors),i.visibility&&(this.visibility=i.visibility),i.useDash&&(this.useDash=i.useDash),i.dashCount&&(this.dashCount=i.dashCount),i.dashRatio&&(this.dashRatio=i.dashRatio),i.dashOffset&&(this.dashOffset=i.dashOffset),i.width&&(this.width=i.width),i.sizeAttenuation&&(this.sizeAttenuation=i.sizeAttenuation),i.resolution&&(this.resolution=i.resolution),i.vy?this.colorsTexture=ny.CreateColorsTexture(`${this.name}-colors-texture`,i.vy,this.colorsSampling,this.Ey()):this.colorsTexture=ny.PrepareEmptyColorsTexture(S),this._cameraFacing=i.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Uy,Wy,ay;by.ForceGLSL=!1,function(y){y[y.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",y[y.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Uy||(Uy={})),function(y){y[y.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",y[y.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",y[y.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Wy||(Wy={})),function(y){y[y.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",y[y.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",y[y.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",y[y.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",y[y.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(ay||(ay={}));class ey extends sy.c{constructor(y,S,I){super(y,S,null,null,!1,!1),this.name=y,this._options=I,this._lazy=!1,this._updatable=!1,this._engine=S.getEngine(),this._lazy=I.lazy??!1,this._updatable=I.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=I.colorPointers??[],this._widths=I.widths??new Array(I.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(y){let S=0;for(const V of this._points)S+=V.length;const I=S/3*2-this._widths.length;for(let V=0;V<I;V++)this._widths.push(y)}updateLazy(){var y,S;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(y=this._options.ribbonOptions)||void 0===y?void 0:y.smoothShading),!this.ky&&this.refreshBoundingInfo(),null===(S=this.greasedLineMaterial)||void 0===S||S.updateLazy()}addPoints(y,S){for(const I of y)this._points.push(I);this._lazy||this.setPoints(this._points,S)}dispose(y){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(y,S)}isLazy(){return this._lazy}get Py(){return this._uvs}set Py(y){this._uvs=y instanceof Float32Array?y:new Float32Array(y),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(y){this.material instanceof by&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===y||void 0===y?void 0:y.length)>0),this._offsets=y,this._offsetsBuffer?this._offsetsBuffer.update(y):this._createOffsetsBuffer(y)}get widths(){return this._widths}set widths(y){this._widths=y,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(y)}get colorPointers(){return this._colorPointers}set colorPointers(y){this._colorPointers=y,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(y)}get greasedLineMaterial(){var y,S;if(this.material&&this.material instanceof by)return this.material;const I=null===(y=this.material)||void 0===y||null===(S=y.pluginManager)||void 0===S?void 0:S.getPlugin(Py.GREASED_LINE_MATERIAL_NAME);return I||void 0}get points(){const y=[];return gy.d.DeepCopy(this._points,y),y}setPoints(y,S){this._points=ny.ConvertPoints(y,(null===S||void 0===S?void 0:S.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==S&&void 0!==S&&S.colorPointers||this._updateColorPointers(),this._setPoints(this._points,S)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Py:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(y){super.serialize(y),y.type=this.getClassName(),y.lineOptions=this._createLineOptions()}_createVertexBuffers(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new qy.b;return S.hy=this._vertexPositions,S.indices=this._indices,S.Py=this._uvs,y&&(S.ny=[],qy.b.ComputeNormals(this._vertexPositions,this._indices,S.ny)),S.gy(this,this._options.updatable),S}_createOffsetsBuffer(y){const S=this._scene.getEngine(),I=new u.b(S,y,this._updatable,3);this.setVerticesBuffer(I.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=I}}class xy{constructor(y,S){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=y,this.wasAddedByNoopNode=S}getIndicesAccessor(y,S,I,V,i){var A,B,d,F;return null===(A=this._indicesAccessorMap.get(y))||void 0===A||null===(B=A.get(S))||void 0===B||null===(d=B.get(I))||void 0===d||null===(F=d.get(V))||void 0===F?void 0:F.get(i)}setIndicesAccessor(y,S,I,V,i,A){let B=this._indicesAccessorMap.get(y);B||(B=new Map,this._indicesAccessorMap.set(y,B));let d=B.get(S);d||(d=new Map,B.set(S,d));let F=d.get(I);F||(F=new Map,d.set(I,F));let J=F.get(V);J||(J=new Map,F.set(V,J)),J.set(i,A)}pushExportedNode(y){this._exportedNodes.has(y)||this._exportedNodes.add(y)}getNodesSet(){return this._exportedNodes}getVertexBufferView(y){return this._vertexBufferViewMap.get(y)}setVertexBufferView(y,S){this._vertexBufferViewMap.set(y,S)}setRemappedBufferView(y,S,I){this._remappedBufferView.set(y,new Map),this._remappedBufferView.get(y).set(S,I)}getRemappedBufferView(y,S){var I;return null===(I=this._remappedBufferView.get(y))||void 0===I?void 0:I.get(S)}getVertexAccessor(y,S,I){var V,i;return null===(V=this._vertexAccessorMap.get(y))||void 0===V||null===(i=V.get(S))||void 0===i?void 0:i.get(I)}setVertexAccessor(y,S,I,V){let i=this._vertexAccessorMap.get(y);i||(i=new Map,this._vertexAccessorMap.set(y,i));let A=i.get(S);A||(A=new Map,i.set(S,A)),A.set(I,V)}hasVertexColorAlpha(y){return this._vertexMapColorAlpha.get(y)||!1}setHasVertexColorAlpha(y,S){return this._vertexMapColorAlpha.set(y,S)}getMesh(y){return this._meshMap.get(y)}setMesh(y,S){this._meshMap.set(y,S)}bindMorphDataToMesh(y,S){const I=this._meshMorphTargetMap.get(y)||[];this._meshMorphTargetMap.set(y,I),-1===I.indexOf(S)&&I.push(S)}getMorphTargetsFromMesh(y){return this._meshMorphTargetMap.get(y)}}class Qy{_ApplyExtension(y,S,I,V){if(I>=S.length)return Promise.resolve(y);const i=V(S[I],y);return i?i.then((async y=>y?await this._ApplyExtension(y,S,I+1,V):null)):this._ApplyExtension(y,S,I+1,V)}_ApplyExtensions(y,S){const I=[];for(const V of Qy._ExtensionNames)I.push(this._extensions[V]);return this._ApplyExtension(y,I,0,S)}_extensionsPreExportTextureAsync(y,S,I){return this._ApplyExtensions(S,((S,V)=>S.preExportTextureAsync&&S.preExportTextureAsync(y,V,I)))}_extensionsPostExportNodeAsync(y,S,I,V,i){return this._ApplyExtensions(S,((S,A)=>S.postExportNodeAsync&&S.postExportNodeAsync(y,A,I,V,i,this._bufferManager)))}_extensionsPostExportMaterialAsync(y,S,I){return this._ApplyExtensions(S,((S,V)=>S.postExportMaterialAsync&&S.postExportMaterialAsync(y,V,I)))}_extensionsPostExportMaterialAdditionalTextures(y,S,I){const V=[];for(const i of Qy._ExtensionNames){const A=this._extensions[i];A.postExportMaterialAdditionalTextures&&V.push(...A.postExportMaterialAdditionalTextures(y,S,I))}return V}_extensionsPostExportTextures(y,S,I){for(const V of Qy._ExtensionNames){const i=this._extensions[V];i.postExportTexture&&i.postExportTexture(y,S,I)}}_extensionsPostExportMeshPrimitive(y){for(const S of Qy._ExtensionNames){const I=this._extensions[S];I.postExportMeshPrimitive&&I.postExportMeshPrimitive(y,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const y of Qy._ExtensionNames){const S=this._extensions[y];S.preGenerateBinaryAsync&&await S.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(y){for(const S of Qy._ExtensionNames){const I=this._extensions[S];I.enabled&&y(I)}}_extensionsOnExporting(){this._forEachExtensions((y=>{var S,I,V;y.wasUsed&&((S=this._glTF).extensionsUsed||(S.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(y.name)&&this._glTF.extensionsUsed.push(y.name),y.required&&((I=this._glTF).extensionsRequired||(I.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(y.name)&&this._glTF.extensionsRequired.push(y.name)),(V=this._glTF).extensions||(V.extensions={}),y.onExporting&&y.onExporting())}))}_loadExtensions(){for(const y of Qy._ExtensionNames){const S=Qy._ExtensionFactories[y](this);this._extensions[y]=S}}constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:T.e.LastCreatedScene,S=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${L.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new R(this),this._extensions={},this._bufferManager=new uy,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!y)throw new Error("No scene available to export");this._babylonScene=y,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:y=>{var S;return null===y||void 0===y||null===(S=y.ai)||void 0===S?void 0:S.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...S},this._loadExtensions()}dispose(){for(const y in this._extensions){this._extensions[y].dispose()}}get options(){return this._options}static RegisterExtension(y,S){Qy.UnregisterExtension(y)&&i.Tools.Warn(`Extension with the name ${y} already exists`),Qy._ExtensionFactories[y]=S,Qy._ExtensionNames.push(y)}static UnregisterExtension(y){if(!Qy._ExtensionFactories[y])return!1;delete Qy._ExtensionFactories[y];const S=Qy._ExtensionNames.indexOf(y);return-1!==S&&Qy._ExtensionNames.splice(S,1),!0}_generateJSON(y,S,I){const V={byteLength:y};return V.byteLength&&(this._glTF.buffers=[V]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.mI=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(V.uri=S+".bin"),I?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(y){const S=await this._generateBinaryAsync();this._extensionsOnExporting();const I=this._generateJSON(S.byteLength,y,!0),V=new Blob([S],{type:"application/octet-stream"}),i=y+".gltf",A=y+".bin",B=new J;if(B.files[i]=I,B.files[A]=V,this._imageData)for(const d in this._imageData)B.files[d]=new Blob([this._imageData[d].data],{type:this._imageData[d].mimeType});return B}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(y){const S=y%4;return 0===S?S:4-S}async generateGLBAsync(y){this._shouldUseGlb=!0;const S=await this._generateBinaryAsync();this._extensionsOnExporting();const I=this._generateJSON(S.byteLength),V=y+".glb";let i,A=I.length;if("undefined"!==typeof TextEncoder){i=(new TextEncoder).encode(I),A=i.length}const B=this._getPadding(A),d=this._getPadding(S.byteLength),F=28+A+B+S.byteLength+d,u=new Fy(F);if(u.writeUInt32(1179937895),u.writeUInt32(2),u.writeUInt32(F),u.writeUInt32(A+B),u.writeUInt32(1313821514),i)u.writeTypedArray(i);else{const y="_".charCodeAt(0);for(let S=0;S<A;++S){const V=I.charCodeAt(S);V!=I.codePointAt(S)?u.writeUInt8(y):u.writeUInt8(V)}}for(let J=0;J<B;++J)u.writeUInt8(32);u.writeUInt32(S.byteLength+d),u.writeUInt32(5130562),u.writeTypedArray(S);for(let J=0;J<d;++J)u.writeUInt8(0);const K=new J;return K.files[V]=new Blob([u.getOutputData()],{type:"application/octet-stream"}),K}_setNodeTransformation(y,S,I){if(S.getPivotPoint().equalsWithEpsilon(e,a.c)||i.Tools.Warn("Pivot points are not supported in the glTF serializer"),!S.position.equalsWithEpsilon(e,a.c)){const i=V.TmpVectors.OS[0].A(S.position);I&&H(i),y.translation=i.Vd()}S.zd.equalsWithEpsilon(Q,a.c)||(y.scale=S.zd.Vd());const A=S.rotationQuaternion||V.Quaternion.FromEulerAngles(S.rotation.x,S.rotation.y,S.rotation.z);A.equalsWithEpsilon(x,a.c)||(I&&Z(A),y.rotation=A.normalize().Vd())}_setCameraTransformation(y,S,I){if(!S.position.equalsWithEpsilon(e,a.c)){const i=V.TmpVectors.OS[0].A(S.position);I&&H(i),y.translation=i.Vd()}const i=S.rotationQuaternion||V.Quaternion.FromEulerAngles(S.rotation.x,S.rotation.y,S.rotation.z);I&&Z(i),this._babylonScene.useRightHandedSystem||w(i),i.equalsWithEpsilon(x,a.c)||(y.rotation=i.Vd())}_listAvailableCameras(){for(const y of this._babylonScene.cameras){const S={type:y.mode===Gy.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(y.name&&(S.name=y.name),"perspective"===S.type)S.perspective={aspectRatio:y.getEngine().getAspectRatio(y),yfov:y.fovMode===Gy.b.FOVMODE_VERTICAL_FIXED?y.fov:y.fov*y.getEngine().getAspectRatio(y),znear:y.Ld,zfar:y.maxZ};else if("orthographic"===S.type){const I=y.orthoLeft&&y.orthoRight?.5*(y.orthoRight-y.orthoLeft):.5*y.getEngine().getRenderWidth(),V=y.orthoBottom&&y.orthoTop?.5*(y.orthoTop-y.orthoBottom):.5*y.getEngine().getRenderHeight();S.orthographic={xmag:I,ymag:V,znear:y.Ld,zfar:y.maxZ}}this._camerasMap.set(y,S)}}_exportAndAssignCameras(){const y=Array.from(this._camerasMap.values());for(const S of y){const y=this._nodesCameraMap.get(S);if(void 0!==y){this._cameras.push(S);for(const S of y)S.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const y of this._babylonScene.skeletons){if(y.bones.length<=0)continue;const S={joints:[]};this._skinMap.set(y,S)}}_exportAndAssignSkeletons(){for(const y of this._babylonScene.skeletons){if(y.bones.length<=0)continue;const S=this._skinMap.get(y);if(void 0==S)continue;const I={},V=[];let A=-1;for(let i=0;i<y.bones.length;++i){const S=y.bones[i],V=S.getIndex()??i;-1!==V&&(I[V]=S,V>A&&(A=V))}for(let y=0;y<=A;++y){const A=I[y];V.push(A.getAbsoluteInverseBindMatrix());const B=A.getTransformNode();if(null!==B){const y=this._nodeMap.get(B);B&&null!==y&&void 0!==y?S.joints.push(y):i.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else i.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const B=this._nodesSkinMap.get(S);if(S.joints.length>0&&void 0!==B){const y=64*V.length,I=new Float32Array(y/4);V.forEach(((y,S)=>{I.set(y.m,16*S)}));const i=this._bufferManager.createBufferView(I);this._accessors.push(this._bufferManager.createAccessor(i,"MAT4",5126,V.length)),S.inverseBindMatrices=this._accessors.length-1,this._skins.push(S);for(const S of B)S.skin=this._skins.length-1}}}async _exportSceneAsync(){const y={nodes:[]};if(this._babylonScene.metadata){const S=this._options.metadataSelector(this._babylonScene.metadata);S&&(y.extras=S)}const S=new Array,I=new Array,V=new Array;for(const d of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&By(d,this._babylonScene.useRightHandedSystem)?V.push(...d.getChildren()):this._babylonScene.useRightHandedSystem?S.push(d):I.push(d);this._listAvailableCameras(),this._listAvailableSkeletons();const i=new xy(!0,!1);y.nodes.push(...await this._exportNodesAsync(I,i));const A=new xy(!1,!1);y.nodes.push(...await this._exportNodesAsync(S,A));const B=new xy(!1,!0);y.nodes.push(...await this._exportNodesAsync(V,B)),y.nodes.length&&this._scenes.push(y),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&fy._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,i.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(y){let S=this._shouldExportNodeMap.get(y);return void 0===S&&(S=this._options.shouldExportNode(y),this._shouldExportNodeMap.set(y,S)),S}async _exportNodesAsync(y,S){const I=new Array;this._exportBuffers(y,S);for(const V of y)await this._exportNodeAsync(V,I,S);return I}_collectBuffers(y,S,I,V,i){if(this._shouldExportNode(y)&&y instanceof G.e&&y.Od){const A=y.Od.getVertexBuffers();if(A)for(const V in A){if(!t(V))continue;const B=A[V];i.setHasVertexColorAlpha(B,y.hasVertexAlpha);const d=B._buffer,F=S.get(d)||[];S.set(d,F),-1===F.indexOf(B)&&F.push(B);const J=I.get(B)||[];I.set(B,J),-1===J.indexOf(y)&&J.push(y)}const B=y.morphTargetManager;if(B)for(let S=0;S<B.numTargets;S++){const I=B.getTarget(S),i=V.get(I)||[];V.set(I,i),-1===i.indexOf(y)&&i.push(y)}}for(const A of y.getChildren())this._collectBuffers(A,S,I,V,i)}_exportBuffers(y,S){const I=new Map,V=new Map,i=new Map;for(const d of y)this._collectBuffers(d,I,V,i,S);const A=Array.from(I.keys());for(const d of A){const y=d.getData();if(!y)throw new Error("Buffer data is not available");const i=I.get(d);if(!i)continue;const A=i[0].byteStride;if(i.some((y=>y.byteStride!==A)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const B=Iy(y).slice();for(const S of i){const y=V.get(S),{byteOffset:I,byteStride:i,componentCount:A,type:d,count:F,normalized:J,kind:K}=X(S,y);switch(K){case u.e.NormalKind:case u.e.TangentKind:(0,b.i)(B,I,i,A,d,F,J,(y=>{const S=Math.sqrt(y[0]*y[0]+y[1]*y[1]+y[2]*y[2]);if(S>0){const I=1/S;y[0]*=I,y[1]*=I,y[2]*=I}}));break;case u.e.ColorKind:{const S=y.filter((y=>y.material instanceof Ty.CS||null==y.material)).length;if(0==S)break;if(S!=y.length){U.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}d==u.e.UNSIGNED_BYTE&&U.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const V=new l.DS,K=new l.vd,G=this._babylonScene.getEngine().useExactSrgbConversions;(0,b.i)(B,I,i,A,d,F,J,(y=>{3===y.length?(V.sI(y,0),V.toLinearSpaceToRef(V,G),V.toArray(y,0)):(K.sI(y,0),K.toLinearSpaceToRef(K,G),K.toArray(y,0))}))}}}if(S.convertToRightHanded){for(const y of i){const S=V.get(y),{byteOffset:I,byteStride:i,componentCount:A,type:d,count:F,normalized:J,kind:K}=X(y,S);switch(K){case u.e.PositionKind:case u.e.NormalKind:case u.e.TangentKind:(0,b.i)(B,I,i,A,d,F,J,(y=>{y[0]=-y[0]}))}}S.convertedToRightHandedBuffers.set(d,B)}const F=this._bufferManager.createBufferView(B,A);S.setVertexBufferView(d,F);const J=new Map;for(const S of i){const y=V.get(S),{kind:I,totalVertices:i}=X(S,y);switch(I){case u.e.MatricesIndicesKind:case u.e.MatricesIndicesExtraKind:if(S.type==u.e.FLOAT){const y=S.getFloatData(i);null!==y&&J.set(S,y)}}}0!==J.size&&U.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const K=Array.from(J.keys());for(const I of K){const y=J.get(I);if(!y)continue;const V=y.some((y=>y>=256)),i=new(V?Uint16Array:Uint8Array)(y.length);for(let S=0;S<y.length;S++)i[S]=y[S];const A=this._bufferManager.createBufferView(i,4*(V?2:1));S.setRemappedBufferView(d,I,A)}}const B=Array.from(i.keys());for(const d of B){const y=i.get(d);if(!y)continue;const I=mS(d,y[0],this._bufferManager,this._bufferViews,this._accessors,S.convertToRightHanded);for(const V of y)S.bindMorphDataToMesh(V,I)}}async _exportNodeAsync(y,S,I){let V=this._nodeMap.get(y);if(void 0!==V)return void(S.includes(V)||S.push(V));const i=await this._createNodeAsync(y,I);if(i){V=this._nodes.length,this._nodes.push(i),this._nodeMap.set(y,V),I.pushExportedNode(y),S.push(V);const A={name:"runtime animations",channels:[],samplers:[]},B=[];this._babylonScene.animationGroups.length||(fy._CreateMorphTargetAnimationFromMorphTargetAnimations(y,A,B,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,I.convertToRightHanded,this._options.shouldExportAnimation),y.animations.length&&fy._CreateNodeAnimationFromNodeAnimations(y,A,B,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,I.convertToRightHanded,this._options.shouldExportAnimation)),A.channels.length&&A.samplers.length&&this._animations.push(A),B.forEach((y=>{y.channels.length&&y.samplers.length&&this._animations.push(y)}))}const A=i?[]:S;for(const B of y.getChildren())await this._exportNodeAsync(B,A,I);i&&A.length&&(i.children=A)}async _createNodeAsync(y,S){if(!this._shouldExportNode(y))return null;const I={};if(y.name&&(I.name=y.name),y.metadata){const S=this._options.metadataSelector(y.metadata);S&&(I.extras=S)}if(y instanceof K.d&&(this._setNodeTransformation(I,y,S.convertToRightHanded),y instanceof G.e)){const i=y instanceof p.e?y.sourceMesh:y;if(i.wi&&i.wi.length>0&&(I.mesh=await this._exportMeshAsync(i,S)),y.skeleton){const S=this._skinMap.get(y.skeleton);var V;if(void 0!==S)void 0===this._nodesSkinMap.get(S)&&this._nodesSkinMap.set(S,[]),null===(V=this._nodesSkinMap.get(S))||void 0===V||V.push(I)}}if(y instanceof W.d){const V=this._camerasMap.get(y);if(V){var i;void 0===this._nodesCameraMap.get(V)&&this._nodesCameraMap.set(V,[]),this._setCameraTransformation(I,y,S.convertToRightHanded);const B=y.parent;if(null!==B&&Sy(y,B)){const y=this._nodeMap.get(B);if(void 0!==y){var A;const S=this._nodes[y];return yy(I,S),null===(A=this._nodesCameraMap.get(V))||void 0===A||A.push(S),null}}null===(i=this._nodesCameraMap.get(V))||void 0===i||i.push(I)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",I,y,this._nodeMap,S.convertToRightHanded)?I:(U.b.Warn(`Not exporting node ${y.name}`),null)}_exportIndices(y,S,I,V,i,B,d,F,J){let u=y;J.mode=N(B);const K=d!==A.d.CounterClockWiseSideOrientation,G=!F.wasAddedByNoopNode&&K,p=function(y){switch(y){case A.d.TriangleFillMode:case A.d.TriangleStripDrawMode:case A.d.TriangleFanDrawMode:return!0}return!1}(B)&&G;if(p){if(B===A.d.TriangleStripDrawMode||B===A.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");J.mode=N(B);const d=S?new Uint32Array(V):new Uint16Array(V);if(y)for(let S=0;S+2<V;S+=3)d[S]=y[I+S]+i,d[S+1]=y[I+S+2]+i,d[S+2]=y[I+S+1]+i;else for(let y=0;y+2<V;y+=3)d[y]=y,d[y+1]=y+2,d[y+2]=y+1;u=d}else if(y&&0!==i){const A=S?new Uint32Array(V):new Uint16Array(V);for(let S=0;S<V;S++)A[S]=y[I+S]+i;u=A}if(u){let A=F.getIndicesAccessor(y,I,V,i,p);if(void 0===A){const B=function(y,S,I,V){if(y instanceof Uint16Array||y instanceof Uint32Array)return y;if(y instanceof Int32Array)return new Uint32Array(y.buffer,y.byteOffset,y.length);const i=y.slice(S,S+I);return V?new Uint32Array(i):new Uint16Array(i)}(u,0,V,S),d=this._bufferManager.createBufferView(B),J=S?5125:5123;this._accessors.push(this._bufferManager.createAccessor(d,"SCALAR",J,V,0)),A=this._accessors.length-1,F.setIndicesAccessor(y,I,V,i,p,A)}J.indices=A}}_exportVertexBuffer(y,S,I,V,i,A){const B=y.getKind();if(!t(B))return;if(B.startsWith("uv")&&!this._options.exportUnusedUVs&&(!S||!this._materialNeedsUVsSet.has(S)))return;let d=i.getVertexAccessor(y,I,V);if(void 0===d){const S=i.convertedToRightHandedBuffers.get(y._buffer)||y._buffer.getData(),A=B===u.e.PositionKind?function(y,S,I,V){const{byteOffset:i,byteStride:A,type:B,normalized:d}=S,F=S.getSize(),J=new Array(F).fill(1/0),u=new Array(F).fill(-1/0);return(0,b.i)(y,i+I*A,A,F,B,V*F,d,(y=>{for(let S=0;S<F;S++)J[S]=Math.min(J[S],y[S]),u[S]=Math.max(u[S],y[S])})),{min:J,max:u}}(S,y,I,V):void 0,F=(B===u.e.MatricesIndicesKind||B===u.e.MatricesIndicesExtraKind)&&y.type===u.e.FLOAT,J=F?u.e.UNSIGNED_BYTE:y.type,K=F?void 0:y.normalized,G=F?i.getRemappedBufferView(y._buffer,y):i.getVertexBufferView(y._buffer),p=y.byteOffset+I*y.byteStride;this._accessors.push(this._bufferManager.createAccessor(G,function(y,S){if(y==u.e.ColorKind)return S?"VEC4":"VEC3";switch(y){case u.e.PositionKind:case u.e.NormalKind:return"VEC3";case u.e.TangentKind:case u.e.MatricesIndicesKind:case u.e.MatricesIndicesExtraKind:case u.e.MatricesWeightsKind:case u.e.MatricesWeightsExtraKind:return"VEC4";case u.e.UVKind:case u.e.UV2Kind:case u.e.UV3Kind:case u.e.UV4Kind:case u.e.UV5Kind:case u.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${y}`)}(B,i.hasVertexColorAlpha(y)),J,V,p,A,K)),d=this._accessors.length-1,i.setVertexAccessor(y,I,V,d)}A.attributes[function(y){switch(y){case u.e.PositionKind:return"POSITION";case u.e.NormalKind:return"NORMAL";case u.e.TangentKind:return"TANGENT";case u.e.ColorKind:return"COLOR_0";case u.e.UVKind:return"TEXCOORD_0";case u.e.UV2Kind:return"TEXCOORD_1";case u.e.UV3Kind:return"TEXCOORD_2";case u.e.UV4Kind:return"TEXCOORD_3";case u.e.UV5Kind:return"TEXCOORD_4";case u.e.UV6Kind:return"TEXCOORD_5";case u.e.MatricesIndicesKind:return"JOINTS_0";case u.e.MatricesIndicesExtraKind:return"JOINTS_1";case u.e.MatricesWeightsKind:return"WEIGHTS_0";case u.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${y}`)}(B)]=d}async _exportMaterialAsync(y,S,I,V){let i=this._materialMap.get(y);if(void 0===i){const V=S&&Object.keys(S).some((y=>y.startsWith("uv")));if((y=y instanceof py.b?y.gd[I.materialIndex]:y)instanceof Ly.d)i=await this._materialExporter.exportPBRMaterialAsync(y,"image/png",V);else{if(!(y instanceof Ty.CS))return void U.b.Warn(`Unsupported material '${y.name}' with type ${y.getClassName()}`);i=await this._materialExporter.exportStandardMaterialAsync(y,"image/png",V)}this._materialMap.set(y,i)}V.material=i}async _exportMeshAsync(y,S){var I;let V=S.getMesh(y);if(void 0!==V)return V;const i={primitives:[]};V=this._meshes.length,this._meshes.push(i),S.setMesh(y,V);const B=y.isUnIndexed?null:y.fd(),d=null===(I=y.Od)||void 0===I?void 0:I.getVertexBuffers(),F=S.getMorphTargetsFromMesh(y),J=y instanceof Cy.b,u=y instanceof ey,K=y.wi;if(d&&K&&K.length>0)for(const L of K){const I={attributes:{}},V=L.Wy()||this._babylonScene.defaultMaterial;if(u){var G,p;const S={name:V.name},i=y,A=l.DS.White(),B=(null===(G=i.material)||void 0===G?void 0:G.alpha)??1,d=(null===(p=i.greasedLineMaterial)||void 0===p?void 0:p.color)??A;(!d.equalsWithEpsilon(A,a.c)||B<1)&&(S.pbrMetallicRoughness={baseColorFactor:[...d.Vd(),B]}),this._materials.push(S),I.material=this._materials.length-1}else if(J){const S={name:V.name},i=y;(!i.color.equalsWithEpsilon(l.DS.White(),a.c)||i.alpha<1)&&(S.pbrMetallicRoughness={baseColorFactor:[...i.color.Vd(),i.alpha]}),this._materials.push(S),I.material=this._materials.length-1}else await this._exportMaterialAsync(V,d,L,I);const K=J||u?A.d.LineListDrawMode:y.overrideRenderingFillMode??V.fillMode,T=V._getEffectiveOrientation(y);this._exportIndices(B,B?(0,b.d)(B,L.indexCount,L.indexStart,L.verticesStart):L.verticesCount>65535,B?L.indexStart:L.verticesStart,B?L.indexCount:L.verticesCount,-L.verticesStart,K,T,S,I);for(const y of Object.values(d))this._exportVertexBuffer(y,V,L.verticesStart,L.verticesCount,S,I);if(F){I.targets=[];for(const y of F)I.targets.push(y.attributes)}i.primitives.push(I),this._extensionsPostExportMeshPrimitive(I)}if(F){i.weights=[],i.extras||(i.extras={}),i.extras.targetNames=[];for(const y of F)i.weights.push(y.influence),i.extras.targetNames.push(y.name)}return V}}Qy._ExtensionNames=new Array,Qy._ExtensionFactories={};class cy{static async GLTFAsync(y,S,I){I&&I.exportWithoutWaitingForScene||await y.whenReadyAsync();const V=new Qy(y,I),i=await V.generateGLTFAsync(S.replace(/\.[^/.]+$/,""));return V.dispose(),i}static async GLBAsync(y,S,I){I&&I.exportWithoutWaitingForScene||await y.whenReadyAsync();const V=new Qy(y,I),i=await V.generateGLBAsync(S.replace(/\.[^/.]+$/,""));return V.dispose(),i}}I(12874);const Xy="EXT_mesh_gpu_instancing";class My{constructor(y){this.name=Xy,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(y,S,I,i,A,B){return await new Promise((y=>{if(S&&I instanceof sy.c&&I.hasThinInstances&&this._exporter){this._wasUsed=!0;const y=V.OS.Zero(),i=V.Quaternion.Identity(),d=V.OS.One(),F=I.thinInstanceGetWorldMatrices(),J=V.TmpVectors.OS[2],u=V.TmpVectors.Quaternion[1],K=V.TmpVectors.OS[3];let G=!1,p=!1,L=!1;const T=new Float32Array(3*I.kd),l=new Float32Array(4*I.kd),j=new Float32Array(3*I.kd);let s=0;for(const S of F)S.decompose(K,u,J),A&&(H(J),Z(u)),T.set(J.Vd(),3*s),l.set(u.normalize().Vd(),4*s),j.set(K.Vd(),3*s),G=G||!J.equalsWithEpsilon(y),p=p||!u.equalsWithEpsilon(i),L=L||!K.equalsWithEpsilon(d),s++;const O={attributes:{}};G&&(O.attributes.TRANSLATION=this._buildAccessor(T,"VEC3",I.kd,B)),p&&(O.attributes.ROTATION=this._buildAccessor(l,"VEC4",I.kd,B)),L&&(O.attributes.SCALE=this._buildAccessor(j,"VEC3",I.kd,B)),S.extensions=S.extensions||{},S.extensions[Xy]=O}y(S)}))}_buildAccessor(y,S,I,V){const i=V.createBufferView(y),A=V.createAccessor(i,S,5126,I);return this._exporter._accessors.push(A),this._exporter._accessors.length-1}}Qy.RegisterExtension(Xy,(y=>new My(y)));var ty=I(12883),Ny=I(12900),Yy=I(12906),Hy=I(12913);function Zy(y){return y===Yy.e.PositionKind?"POSITION":y===Yy.e.NormalKind?"NORMAL":y===Yy.e.ColorKind?"COLOR":y.startsWith(Yy.e.UVKind)?"TEX_COORD":"GENERIC"}const wy={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class yS extends ty.d{static get DefaultAvailable(){return(0,ty.f)(yS.DefaultConfiguration)}static get Default(){return yS._Default??(yS._Default=new yS),yS._Default}static ResetDefault(y){yS._Default&&(y||yS._Default.dispose(),yS._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(y,S){return{module:await(S||DracoEncoderModule)({wasmBinary:y})}}_getWorkerContent(){return`${Ny.h}(${Ny.i})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:yS.DefaultConfiguration)}async _encodeAsync(y,S,I){const V=I?(0,Hy.e)(wy,I):wy;if(this._workerPoolPromise){const I=await this._workerPoolPromise;return await new Promise(((i,A)=>{I.push(((I,B)=>{const d=y=>{I.removeEventListener("error",d),I.removeEventListener("message",F),A(y),B()},F=y=>{"encodeMeshDone"===y.data.id&&(I.removeEventListener("error",d),I.removeEventListener("message",F),i(y.data.encodedMeshData),B())};I.addEventListener("error",d),I.addEventListener("message",F);const J=[];for(const S of y)J.push(S.data.buffer);S&&J.push(S.buffer),I.postMessage({id:"encodeMesh",attributes:y,indices:S,options:V},J)}))}))}if(this._modulePromise){const I=await this._modulePromise;return(0,Ny.h)(I.module,y,S,V)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(y,S){if(0==y.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");y instanceof sy.c&&y.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===S||void 0===S?void 0:S.method)&&(U.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),S.method="MESH_SEQUENTIAL_ENCODING");const I=function(y){let S=y.fd(void 0,!0);return!S||S instanceof Uint32Array||S instanceof Uint16Array||(S=((0,b.d)(S,S.length)?Uint32Array:Uint16Array).from(S)),S}(y),V=function(y,S){const I=[];for(const V of y.getVerticesDataKinds()){if(null!==S&&void 0!==S&&S.includes(V)){if(V===Yy.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const i=y.getVertexBuffer(V),A=i.getSize(),B=(0,b.t)(i.getData(),A,i.type,i.byteOffset,i.byteStride,i.normalized,y.getTotalVertices(),!0);I.push({kind:V,dracoName:Zy(V),size:A,data:B})}return I}(y,null===S||void 0===S?void 0:S.excludedAttributes);return await this._encodeAsync(V,I,S)}}yS.DefaultConfiguration={wasmUrl:`${i.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${i.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${i.Tools._DefaultCdnUrl}/draco_encoder.js`},yS._Default=null;const SS="KHR_draco_mesh_compression";class IS{get wasUsed(){return this._wasUsed}constructor(y){this.name=SS,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===y.options.meshCompressionMethod&&yS.DefaultAvailable}dispose(){}postExportMeshPrimitive(y,S,I){if(!this.enabled)return;if(4!==y.mode&&5!==y.mode)return void U.b.Warn("Cannot compress primitive with mode "+y.mode+".");const V=[],i=[];let A=null;if(void 0!==y.indices){const B=I[y.indices],d=S.getBufferView(B);A=S.getData(d).slice(),V.push(d),i.push(B)}const B=[];for(const[u,K]of Object.entries(y.attributes)){const y=I[K],A=S.getBufferView(y),F=M(y.type),J=(0,b.t)(S.getData(A),F,y.componentType,y.byteOffset||0,A.byteStride||(0,b.p)(y.componentType)*F,y.normalized||!1,y.count,!0);B.push({kind:u,dracoName:(d=u,"POSITION"===d?"POSITION":"NORMAL"===d?"NORMAL":d.startsWith("COLOR")?"COLOR":d.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:M(y.type),data:J}),V.push(A),i.push(y)}var d;const F={method:y.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},J=yS.Default._encodeAsync(B,A,F).then((I=>{if(!I)return void U.b.Error("Draco encoding failed for primitive.");const A={bufferView:-1,attributes:I.attributeIds},B=S.createBufferView(I.data);S.setBufferView(A,B);for(const y of V)this._bufferViewsUsed.add(y);for(const y of i)this._accessorsUsed.add(y);y.extensions||(y.extensions={}),y.extensions[SS]=A})).catch((y=>{U.b.Error("Draco encoding failed for primitive: "+y)}));this._encodePromises.push(J),this._wasUsed=!0}async preGenerateBinaryAsync(y){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((S=>{y.getPropertiesWithBufferView(S).every((y=>this._accessorsUsed.has(y)))&&y.removeBufferView(S)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Qy.RegisterExtension(SS,(y=>new IS(y)));var VS=I(12919);const iS="KHR_lights_punctual",AS={name:"",color:[1,1,1],Rd:1,range:Number.MAX_VALUE},BS={innerConeAngle:0,outerConeAngle:Math.PI/4},dS=V.OS.Backward();class FS{constructor(y){this.name=iS,this.enabled=!0,this.required=!1,this._exporter=y}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[iS]=this._lights}async postExportNodeAsync(y,S,I,i,A){return await new Promise((B=>{if(!(I instanceof Oy.e))return void B(S);const d=I.getTypeID()==Oy.e.LIGHTTYPEID_POINTLIGHT?"point":I.getTypeID()==Oy.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":I.getTypeID()==Oy.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!d||!(I instanceof VS.c))return U.b.Warn(`${y}: Light ${I.name} is not supported in ${iS}`),void B(S);if(I.falloffType!==Oy.e.FALLOFF_GLTF&&U.b.Warn(`${y}: Light falloff for ${I.name} does not match the ${iS} specification!`),!I.position.equalsToFloats(0,0,0)){const y=V.TmpVectors.OS[0].A(I.position);A&&H(y),S.translation=y.Vd()}if("point"!==d){const y=I.direction.normalizeToRef(V.TmpVectors.OS[0]);A&&H(y);const i=V.Quaternion.FromUnitVectorsToRef(dS,y,V.TmpVectors.Quaternion[0]);V.Quaternion.IsIdentity(i)||(S.rotation=i.Vd())}const F={type:d,name:I.name,color:I.bd.Vd(),Rd:I.Rd,range:I.range};if(Vy(F,AS),"spot"===d){const y=I;F.spot={innerConeAngle:y.innerAngle/2,outerConeAngle:y.angle/2},Vy(F.spot,BS)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(F);const J={Ki:this._lights.lights.length-1},u=I.parent;if(u&&Sy(I,u)){const y=i.get(u);if(y){const I=this._exporter._nodes[y];return yy(S,I),I.extensions||(I.extensions={}),I.extensions[iS]=J,void B(null)}}S.extensions||(S.extensions={}),S.extensions[iS]=J,B(S)}))}}Qy.RegisterExtension(iS,(y=>new FS(y)));var JS=I(12816);const uS="KHR_materials_anisotropy";class KS{constructor(y){this.name=uS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,S,I){const V=[];return I instanceof JS.c&&I.anisotropy.isEnabled&&!I.anisotropy.legacy?(I.anisotropy.texture&&V.push(I.anisotropy.texture),V):[]}postExportMaterialAsync(y,S,I){return new Promise((y=>{if(I instanceof JS.c){if(!I.anisotropy.isEnabled||I.anisotropy.legacy)return void y(S);this._wasUsed=!0,S.extensions=S.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(I.anisotropy.texture),i={anisotropyStrength:I.anisotropy.Rd,anisotropyRotation:I.anisotropy.angle,anisotropyTexture:V??void 0};null!==i.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(I),S.extensions[uS]=i}y(S)}))}}Qy.RegisterExtension(uS,(y=>new KS(y)));const GS="KHR_materials_clearcoat";class pS{constructor(y){this.name=GS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,S,I){const V=[];return I instanceof JS.c&&I.clearCoat.isEnabled?(I.clearCoat.texture&&V.push(I.clearCoat.texture),!I.clearCoat.useRoughnessFromMainTexture&&I.clearCoat.textureRoughness&&V.push(I.clearCoat.textureRoughness),I.clearCoat.bumpTexture&&V.push(I.clearCoat.bumpTexture),V):[]}postExportMaterialAsync(y,S,I){return new Promise((y=>{if(I instanceof JS.c){if(!I.clearCoat.isEnabled)return void y(S);this._wasUsed=!0,S.extensions=S.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(I.clearCoat.texture);let A;A=I.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(I.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(I.clearCoat.textureRoughness),I.clearCoat.isTintEnabled&&i.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${I.name}`),I.clearCoat.remapF0OnInterfaceChange&&i.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${I.name}`);const B=this._exporter._materialExporter.getTextureInfo(I.clearCoat.bumpTexture),d={clearcoatFactor:I.clearCoat.Rd,clearcoatTexture:V??void 0,clearcoatRoughnessFactor:I.clearCoat.roughness,clearcoatRoughnessTexture:A??void 0,clearcoatNormalTexture:B??void 0};null===d.clearcoatTexture&&null===d.clearcoatRoughnessTexture&&null===d.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(I),S.extensions[GS]=d}y(S)}))}}Qy.RegisterExtension(GS,(y=>new pS(y)));const LS="KHR_materials_diffuse_transmission";function TS(y,S){const I=S.subSurface;let V=null;return I.translucencyIntensityTexture?V=I.translucencyIntensityTexture:I.thicknessTexture&&I.useMaskFromThicknessTexture&&(V=I.thicknessTexture),V&&!I.useGltfStyleTextures?(U.b.Warn(`${y}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${S.name}`,1),null):V}class lS{constructor(y){this.name=LS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,S,I){const V=[];if(I instanceof Ly.d&&this._isExtensionEnabled(I)){const S=TS(y,I);return S&&V.push(S),I.subSurface.translucencyColorTexture&&V.push(I.subSurface.translucencyColorTexture),V}return V}_isExtensionEnabled(y){if(y.unlit)return!1;const S=y.subSurface;return!!S.isTranslucencyEnabled&&(!y.unlit&&!S.useAlbedoToTintTranslucency&&S.useGltfStyleTextures&&1===S.volumeIndexOfRefraction&&0===S.minimumThickness&&0===S.maximumThickness)}postExportMaterialAsync(y,S,I){return new Promise((V=>{if(I instanceof Ly.d&&this._isExtensionEnabled(I)){this._wasUsed=!0;const V=I.subSurface,i=TS(y,I),A=0==V.translucencyIntensity?void 0:V.translucencyIntensity,B=this._exporter._materialExporter.getTextureInfo(i)??void 0,d=!V.translucencyColor||V.translucencyColor.equalsFloats(1,1,1)?void 0:V.translucencyColor.Vd(),F=this._exporter._materialExporter.getTextureInfo(V.translucencyColorTexture)??void 0,J={diffuseTransmissionFactor:A,diffuseTransmissionTexture:B,diffuseTransmissionColorFactor:d,diffuseTransmissionColorTexture:F};(B||F)&&this._exporter._materialNeedsUVsSet.add(I),S.extensions=S.extensions||{},S.extensions[LS]=J}V(S)}))}}Qy.RegisterExtension(LS,(y=>new lS(y)));const jS="KHR_materials_dispersion";class sS{constructor(){this.name=jS,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(y){if(y.unlit)return!1;const S=y.subSurface;return!(!S.isRefractionEnabled&&!S.isDispersionEnabled)}postExportMaterialAsync(y,S,I){return new Promise((y=>{if(I instanceof Ly.d&&this._isExtensionEnabled(I)){this._wasUsed=!0;const y={dispersion:I.subSurface.dispersion};S.extensions=S.extensions||{},S.extensions[jS]=y}y(S)}))}}Qy.RegisterExtension(jS,(()=>new sS));const OS="KHR_materials_emissive_strength";class fS{constructor(){this.name=OS,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(y,S,I){return await new Promise((y=>{if(!(I instanceof Ly.d))return y(S);const V=I.emissiveColor.Vd(),i=Math.max(...V);if(i>1){this._wasUsed=!0,S.extensions||(S.extensions={});const y={emissiveStrength:i},V=I.emissiveColor.scale(1/y.emissiveStrength);S.emissiveFactor=V.Vd(),S.extensions[OS]=y}return y(S)}))}}Qy.RegisterExtension(OS,(y=>new fS));const mI="KHR_materials_ior";class CS{constructor(){this.name=mI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(y){return!y.unlit&&(void 0!=y.indexOfRefraction&&1.5!=y.indexOfRefraction)}postExportMaterialAsync(y,S,I){return new Promise((y=>{if(I instanceof Ly.d&&this._isExtensionEnabled(I)){this._wasUsed=!0;const y={ior:I.indexOfRefraction};S.extensions=S.extensions||{},S.extensions[mI]=y}y(S)}))}}Qy.RegisterExtension(mI,(y=>new CS));const DS="KHR_materials_iridescence";class oS{constructor(y){this.name=DS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,S,I){const V=[];return I instanceof JS.c&&I.iridescence.isEnabled?(I.iridescence.texture&&V.push(I.iridescence.texture),I.iridescence.thicknessTexture&&I.iridescence.thicknessTexture!==I.iridescence.texture&&V.push(I.iridescence.thicknessTexture),V):[]}postExportMaterialAsync(y,S,I){return new Promise((y=>{if(I instanceof JS.c){if(!I.iridescence.isEnabled)return void y(S);this._wasUsed=!0,S.extensions=S.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(I.iridescence.texture),i=this._exporter._materialExporter.getTextureInfo(I.iridescence.thicknessTexture),A={iridescenceFactor:I.iridescence.Rd,iridescenceIor:I.iridescence.indexOfRefraction,iridescenceThicknessMinimum:I.iridescence.minimumThickness,iridescenceThicknessMaximum:I.iridescence.maximumThickness,iridescenceTexture:V??void 0,iridescenceThicknessTexture:i??void 0};null===A.iridescenceTexture&&null===A.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(I),S.extensions[DS]=A}y(S)}))}}Qy.RegisterExtension(DS,(y=>new oS(y)));const ES="KHR_materials_sheen";class zS{constructor(y){this.name=ES,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,S,I){return I instanceof Ly.d&&I.sheen.isEnabled&&I.sheen.texture?[I.sheen.texture]:[]}async postExportMaterialAsync(y,S,I){return await new Promise((y=>{if(I instanceof Ly.d){if(!I.sheen.isEnabled)return void y(S);this._wasUsed=!0,null==S.extensions&&(S.extensions={});const V={sheenColorFactor:I.sheen.color.Vd(),sheenRoughnessFactor:I.sheen.roughness??0};null===V.sheenColorTexture&&null===V.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(I),I.sheen.texture&&(V.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(I.sheen.texture)??void 0),I.sheen.textureRoughness&&!I.sheen.useRoughnessFromMainTexture?V.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(I.sheen.textureRoughness)??void 0:I.sheen.texture&&I.sheen.useRoughnessFromMainTexture&&(V.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(I.sheen.texture)??void 0),S.extensions[ES]=V}y(S)}))}}Qy.RegisterExtension(ES,(y=>new zS(y)));const rS="KHR_materials_specular";class hS{constructor(y){this.name=rS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,S,I){const V=[];return I instanceof Ly.d&&this._isExtensionEnabled(I)?(I.metallicReflectanceTexture&&V.push(I.metallicReflectanceTexture),I.reflectanceTexture&&V.push(I.reflectanceTexture),V):V}_isExtensionEnabled(y){return!y.unlit&&(void 0!=y.metallicF0Factor&&1!=y.metallicF0Factor||void 0!=y.metallicReflectanceColor&&!y.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(y))}_hasTexturesExtension(y){return null!=y.metallicReflectanceTexture||null!=y.reflectanceTexture}postExportMaterialAsync(y,S,I){return new Promise((y=>{if(I instanceof Ly.d&&this._isExtensionEnabled(I)){this._wasUsed=!0,S.extensions=S.extensions||{};const y=this._exporter._materialExporter.getTextureInfo(I.metallicReflectanceTexture)??void 0,V=this._exporter._materialExporter.getTextureInfo(I.reflectanceTexture)??void 0,i={specularFactor:1==I.metallicF0Factor?void 0:I.metallicF0Factor,specularTexture:y,specularColorFactor:I.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:I.metallicReflectanceColor.Vd(),specularColorTexture:V};this._hasTexturesExtension(I)&&this._exporter._materialNeedsUVsSet.add(I),S.extensions[rS]=i}y(S)}))}}Qy.RegisterExtension(rS,(y=>new hS(y)));const nS="KHR_materials_transmission";class vS{constructor(y){this.name=nS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,S,I){const V=[];return I instanceof Ly.d&&this._isExtensionEnabled(I)?(I.subSurface.thicknessTexture&&V.push(I.subSurface.thicknessTexture),V):V}_isExtensionEnabled(y){if(y.unlit)return!1;const S=y.subSurface;return S.isRefractionEnabled&&void 0!=S.refractionIntensity&&0!=S.refractionIntensity||this._hasTexturesExtension(y)}_hasTexturesExtension(y){return null!=y.subSurface.refractionIntensityTexture}async postExportMaterialAsync(y,S,I){if(I instanceof Ly.d&&this._isExtensionEnabled(I)){this._wasUsed=!0;const V=I.subSurface,i={transmissionFactor:0===V.refractionIntensity?void 0:V.refractionIntensity};if(this._hasTexturesExtension(I)&&this._exporter._materialNeedsUVsSet.add(I),V.refractionIntensityTexture)if(V.useGltfStyleTextures){const y=await this._exporter._materialExporter.exportTextureAsync(V.refractionIntensityTexture,"image/png");y&&(i.transmissionTexture=y)}else U.b.Warn(`${y}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);S.extensions||(S.extensions={}),S.extensions[nS]=i}return S}}Qy.RegisterExtension(nS,(y=>new vS(y)));const PS="KHR_materials_unlit";class qS{constructor(){this.name=PS,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(y,S,I){return new Promise((y=>{let V=!1;I instanceof Ly.d?V=I.unlit:I instanceof Ty.CS&&(V=I.disableLighting),V&&(this._wasUsed=!0,null==S.extensions&&(S.extensions={}),S.extensions[PS]={}),y(S)}))}}Qy.RegisterExtension(PS,(()=>new qS));const gS="KHR_materials_volume";class kS{constructor(y){this.name=gS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,S,I){const V=[];return I instanceof Ly.d&&this._isExtensionEnabled(I)?(I.subSurface.thicknessTexture&&V.push(I.subSurface.thicknessTexture),V):V}_isExtensionEnabled(y){if(y.unlit)return!1;const S=y.subSurface;return!(!S.isRefractionEnabled&&!S.isTranslucencyEnabled)&&(void 0!=S.maximumThickness&&0!=S.maximumThickness||void 0!=S.tintColorAtDistance&&S.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=S.tintColor&&S.tintColor!=l.DS.White()||this._hasTexturesExtension(y))}_hasTexturesExtension(y){return null!=y.subSurface.thicknessTexture}postExportMaterialAsync(y,S,I){return new Promise((y=>{if(I instanceof Ly.d&&this._isExtensionEnabled(I)){this._wasUsed=!0;const y=I.subSurface,V={thicknessFactor:0==y.maximumThickness?void 0:y.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(y.thicknessTexture)??void 0,attenuationDistance:y.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:y.tintColorAtDistance,attenuationColor:y.tintColor.equalsFloats(1,1,1)?void 0:y.tintColor.Vd()};this._hasTexturesExtension(I)&&this._exporter._materialNeedsUVsSet.add(I),S.extensions=S.extensions||{},S.extensions[gS]=V}y(S)}))}}Qy.RegisterExtension(gS,(y=>new kS(y)));const RS="EXT_materials_diffuse_roughness";class bS{constructor(y){this.name=RS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(y,S,I){const V=[];return I instanceof JS.c&&I._baseDiffuseRoughness?(I._baseDiffuseRoughnessTexture&&V.push(I._baseDiffuseRoughnessTexture),V):[]}postExportMaterialAsync(y,S,I){return new Promise((y=>{if(I instanceof JS.c){if(!I._baseDiffuseRoughness)return void y(S);this._wasUsed=!0,S.extensions=S.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(I._baseDiffuseRoughnessTexture),i={diffuseRoughnessFactor:I._baseDiffuseRoughness,diffuseRoughnessTexture:V??void 0};null!==i.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(I),S.extensions[RS]=i}y(S)}))}}Qy.RegisterExtension(RS,(y=>new bS(y)));const US="KHR_texture_transform";class WS{constructor(){this.name=US,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(y,S,I){if(I.Ey()||i.Tools.Warn(`${y}: /*@__KEY__*/"scene" is not defined for Babylon texture ${I.name}!`),(0!==I.uAng||0!==I.vAng)&&(i.Tools.Warn(`${y}: Texture ${I.name} with rotation in the u or v axis is not supported in glTF.`),0!==I.uRotationCenter||0!==I.vRotationCenter))return;const V={};let A=!1;if(0===I.uOffset&&0===I.vOffset||(V.offset=[I.uOffset,I.vOffset],A=!0),1===I.uScale&&1===I.vScale||(V.scale=[I.uScale,I.vScale],A=!0),0!==I.wAng){if(0!==I.uRotationCenter||0!==I.vRotationCenter){if(I.homogeneousRotationInUVTransform&&I.uScale!==I.vScale)return void i.Tools.Warn(`${y}: Texture ${I.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${US}.`);i.Tools.Warn(`${y}: Texture ${I.name} with non-origin rotation center will be exported using an adjusted offset with ${US}.`),V.offset=function(y){const{uOffset:S,vOffset:I,uRotationCenter:V,vRotationCenter:i,uScale:A,vScale:B,wAng:d}=y,F=Math.cos(d),J=Math.sin(d),u=V*A,K=i*B;return[S+(u*(1-F)+K*J),I+(K*(1-F)-u*J)]}(I)}V.rotation=-I.wAng,A=!0}0!==I.coordinatesIndex&&(V.texCoord=I.coordinatesIndex,A=!0),A&&(this._wasUsed=!0,S.extensions||(S.extensions={}),S.extensions[US]=V)}}Qy.RegisterExtension(US,(()=>new WS));class aS{static CreateSTL(y){let S=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",i=arguments.length>3&&void 0!==arguments[3]&&arguments[3],A=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],B=arguments.length>5&&void 0!==arguments[5]&&arguments[5],d=arguments.length>6&&void 0!==arguments[6]&&arguments[6],F=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const J=function(y,S,I){const i=[3*y[I],3*y[I+1],3*y[I+2]],A=[new V.OS(S[i[0]],S[i[0]+2],S[i[0]+1]),new V.OS(S[i[1]],S[i[1]+2],S[i[1]+1]),new V.OS(S[i[2]],S[i[2]+2],S[i[2]+1])],B=A[0].fS(A[1]),d=A[2].fS(A[1]);return{v:A,n:V.OS.Cross(d,B).normalize()}},K=function(y,S,I,V){return S=G(y,S,I.x,V),S=G(y,S,I.y,V),G(y,S,I.z,V)},G=function(y,S,I,V){return y.setFloat32(S,I,V),S+4},L=function(y){if(d){let S=y;y instanceof p.e&&(S=y.sourceMesh);const I=S.getVerticesData(u.e.PositionKind,!0,!0);if(!I)return[];const i=V.OS.Zero();let A;for(A=0;A<I.length;A+=3)V.OS.TransformCoordinatesFromFloatsToRef(I[A],I[A+1],I[A+2],y.sd(!0),i).toArray(I,A);return I}return y.getVerticesData(u.e.PositionKind)||[]};d&&(B=!0);let T="",l=0,j=0;if(i){for(let I=0;I<y.length;I++){const S=y[I].fd();l+=S?S.length/3:0}const S=new ArrayBuffer(84+50*l);T=new DataView(S),j+=80,T.setUint32(j,l,A),j+=4}else F||(T="solid stlmesh\r\n");for(let V=0;V<y.length;V++){const S=y[V];!i&&F&&(T+="solid "+S.name+"\r\n"),!B&&S instanceof sy.c&&S.bakeCurrentTransformIntoVertices();const I=L(S),d=S.fd()||[];for(let y=0;y<d.length;y+=3){const S=J(d,I,y);i?(j=K(T,j,S.n,A),j=K(T,j,S.v[0],A),j=K(T,j,S.v[1],A),j=K(T,j,S.v[2],A),j+=2):(T+="\tfacet normal "+S.n.x+" "+S.n.y+" "+S.n.z+"\r\n",T+="\t\touter loop\r\n",T+="\t\t\tvertex "+S.v[0].x+" "+S.v[0].y+" "+S.v[0].z+"\r\n",T+="\t\t\tvertex "+S.v[1].x+" "+S.v[1].y+" "+S.v[1].z+"\r\n",T+="\t\t\tvertex "+S.v[2].x+" "+S.v[2].y+" "+S.v[2].z+"\r\n",T+="\t\tendloop\r\n",T+="\tendfacet\r\n")}!i&&F&&(T+="endsolid "+name+"\r\n")}if(i||F||(T+="endsolid stlmesh"),S){const y=document.createElement("a"),S=new Blob([T],{type:"application/octet-stream"});y.href=window.URL.createObjectURL(S),y.download=I+".stl",y.click()}return T}}function eS(y,S){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const V=[];for(let i=0;i<y.length/I;i++){const A=y[i*I],B=y[i*I+1],d=y[i*I+2];V.push(`(${A.toPrecision(S.precision)}, ${B.toPrecision(S.precision)}, ${d.toPrecision(S.precision)})`)}return V.join(", ")}function xS(y,S){const I=[];for(let V=0;V<y.length/2;V++){const i=y[2*V],A=y[2*V+1];I.push(`(${i.toPrecision(S.precision)}, ${(1-A).toPrecision(S.precision)})`)}return I.join(", ")}function QS(y,S){const I=y.getVerticesData(u.e.PositionKind),V=y.getVerticesData(u.e.NormalKind);if(I&&V)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(y){var S;const I=null!==(S=y.fd())&&void 0!==S&&S.length?y.getTotalIndices():y.getTotalVertices();return Array(I/3).fill(3).join(", ")}(y)}]\n\t\tint[] faceVertexIndices = [${function(y){const S=y.fd(),I=[];if(null!==S)for(let V=0;V<S.length;V++)I.push(S[V]);else{const S=y.getTotalVertices();for(let y=0;y<S;y++)I.push(y)}return I.join(", ")}(y)}]\n\t\tnormal3f[] normals = [${eS(V,S)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${eS(I,S)}]\n        ${function(y,S){let I="";for(let i=0;i<4;i++){const V=i>0?i:"",A=y.getVerticesData(u.e.UVKind+(V?V+1:""));A&&(I+=`\n\t\ttexCoord2f[] primvars:st${V} = [${xS(A,S)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const V=y.getVerticesData(u.e.ColorKind);return V&&(I+=`\n\tcolor3f[] primvars:displayColor = [${eS(V,S,V.length/y.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),I}(y,S)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function cS(y,S){return`\n        def "Geometry"\n        {\n        ${QS(y,S)}\n        }\n        `}function XS(y){let S='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return S+=y,fflate.strToU8(S)}function MS(y){const S=y.m;return`( ${tS(S,0)}, ${tS(S,4)}, ${tS(S,8)}, ${tS(S,12)} )`}function tS(y,S){return`(${y[S+0]}, ${y[S+1]}, ${y[S+2]}, ${y[S+3]})`}function NS(y){const S="Object_"+y.uniqueId,I=function(y){const S=y.getWorldMatrix().clone(),I=y.Ey().useRightHandedSystem;if(!I){let V=y.parent;for(;V;){if(By(V,I)){S.multiplyToRef(V.getWorldMatrix().invert(),S);break}V=V.parent}}return S.determinant()<0&&i.Tools.Warn(`Exporting mesh ${y.name} with negative scale. Result may look incorrect in destination engine.`),S}(y),V=MS(I);return`def Xform "${S}" (\n\tprepend references = @./geometries/Geometry_${y.Od.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${V}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${y.material.uniqueId}>\n}\n\n`}function YS(y){switch(y){case D.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case D.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case D.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function HS(y){return`(${y.x}, ${y.y})`}function ZS(y){return`(${y.r}, ${y.g}, ${y.b})`}function wS(y,S,I,i,A,B){const d=y.getInternalTexture().uniqueId+"_"+y.invertY;A[d]=y;const F=y.coordinatesIndex>0?"st"+y.coordinatesIndex:"st",J=new V.Vector2(y.uScale,y.vScale),u=new V.Vector2(y.uOffset,y.vOffset),K=y.wAng,G=Math.sin(K),p=Math.cos(K);return u.y=1-u.y-J.y,u.x+=G*J.x,u.y+=(1-p)*J.y,`\n    def Shader "PrimvarReader_${I}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${F}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${I}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${S.uniqueId}/PrimvarReader_${I}.outputs:result>\n        float inputs:rotation = ${(K*(180/Math.PI)).toFixed(B.precision)}\n        float2 inputs:scale = ${HS(J)}\n        float2 inputs:translation = ${HS(u)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${y.uniqueId}_${I}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${d}.png@\n        float2 inputs:st.connect = </Materials/Material_${S.uniqueId}/Transform2d_${I}.outputs:result>\n        ${i?"float4 inputs:scale = "+function(y){return`(${y.r}, ${y.g}, ${y.b}, 1.0)`}(i):""}\n        token inputs:sourceColorSpace = "${y.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${YS(y.wrapU)}"\n        token inputs:wrapT = "${YS(y.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${S.needAlphaBlending()?"float outputs:a":""}\n    }`}function yI(y,S,I){const V="\t\t\t",i=[],A=[],{diffuseMap:B,bd:d,alphaCutOff:F,emissiveMap:J,emissive:u,normalMap:K,roughnessMap:G,roughnessChannel:p,roughness:L,metalnessMap:T,metalnessChannel:j,metalness:s,aoMap:O,aoMapChannel:f,aoMapIntensity:my,alphaMap:C,ior:D,clearCoatEnabled:o,clearCoat:E,clearCoatMap:z,clearCoatRoughness:r,clearCoatRoughnessMap:h}=function(y){const S={diffuseMap:null,bd:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return y instanceof Ty.CS?{...S,diffuseMap:y.diffuseTexture,bd:y.diffuseColor,alphaCutOff:y.alphaCutOff,emissiveMap:y.emissiveTexture,emissive:y.emissiveColor,roughness:1,alphaMap:y.opacityTexture}:y instanceof JS.c?{...S,diffuseMap:y._albedoTexture,bd:y._albedoColor,alphaCutOff:y._alphaCutOff,emissiveMap:y._emissiveTexture,emissive:y._emissiveColor,normalMap:y._bumpTexture,roughnessMap:y._metallicTexture,roughnessChannel:y._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:y._roughness??1,metalnessMap:y._metallicTexture,metalnessChannel:y._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:y._metallic??0,aoMap:y._ambientTexture,aoMapChannel:y._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:y._ambientTextureStrength,alphaMap:y._opacityTexture,ior:y.subSurface.indexOfRefraction,clearCoatEnabled:y.clearCoat.isEnabled,clearCoat:y.clearCoat.Rd,clearCoatMap:y.clearCoat.texture,clearCoatRoughness:y.clearCoat.roughness,clearCoatRoughnessMap:y.clearCoat.useRoughnessFromMainTexture?y.clearCoat.texture:y.clearCoat.textureRoughness}:S}(y);return null!==B?(i.push(`${V}color3f inputs:diffuseColor.connect = </Materials/Material_${y.uniqueId}/Texture_${B.uniqueId}_diffuse.outputs:rgb>`),y.needAlphaBlending()?i.push(`${V}float inputs:opacity.connect = </Materials/Material_${y.uniqueId}/Texture_${B.uniqueId}_diffuse.outputs:a>`):y.needAlphaTesting()&&(i.push(`${V}float inputs:opacity.connect = </Materials/Material_${y.uniqueId}/Texture_${B.uniqueId}_diffuse.outputs:a>`),i.push(`${V}float inputs:opacityThreshold = ${F}`)),A.push(wS(B,y,"diffuse",d,S,I))):i.push(`${V}color3f inputs:diffuseColor = ${ZS(d||l.DS.White())}`),null!==J?(i.push(`${V}color3f inputs:emissiveColor.connect = </Materials/Material_${y.uniqueId}/Texture_${J.uniqueId}_emissive.outputs:rgb>`),A.push(wS(J,y,"emissive",u,S,I))):u&&u.toLuminance()>0&&i.push(`${V}color3f inputs:emissiveColor = ${ZS(u)}`),null!==K&&(i.push(`${V}normal3f inputs:normal.connect = </Materials/Material_${y.uniqueId}/Texture_${K.uniqueId}_normal.outputs:rgb>`),A.push(wS(K,y,"normal",null,S,I))),null!==O&&(i.push(`${V}float inputs:occlusion.connect = </Materials/Material_${y.uniqueId}/Texture_${O.uniqueId}_occlusion.outputs:${f}>`),A.push(wS(O,y,"occlusion",new l.DS(my,my,my),S,I))),null!==G?(i.push(`${V}float inputs:roughness.connect = </Materials/Material_${y.uniqueId}/Texture_${G.uniqueId}_roughness.outputs:${p}>`),A.push(wS(G,y,"roughness",new l.DS(L,L,L),S,I))):i.push(`${V}float inputs:roughness = ${L}`),null!==T?(i.push(`${V}float inputs:metallic.connect = </Materials/Material_${y.uniqueId}/Texture_${T.uniqueId}_metallic.outputs:${j}>`),A.push(wS(T,y,"metallic",new l.DS(s,s,s),S,I))):i.push(`${V}float inputs:metallic = ${s}`),null!==C?(i.push(`${V}float inputs:opacity.connect = </Materials/Material_${y.uniqueId}/Texture_${C.uniqueId}_opacity.outputs:r>`),i.push(`${V}float inputs:opacityThreshold = 0.0001`),A.push(wS(C,y,"opacity",null,S,I))):i.push(`${V}float inputs:opacity = ${y.alpha}`),o&&(null!==z?(i.push(`${V}float inputs:clearcoat.connect = </Materials/Material_${y.uniqueId}/Texture_${z.uniqueId}_clearcoat.outputs:r>`),A.push(wS(z,y,"clearcoat",new l.DS(E,E,E),S,I))):i.push(`${V}float inputs:clearcoat = ${E}`),null!==h?(i.push(`${V}float inputs:clearcoatRoughness.connect = </Materials/Material_${y.uniqueId}/Texture_${h.uniqueId}_clearcoatRoughness.outputs:g>`),A.push(wS(h,y,"clearcoatRoughness",new l.DS(r,r,r),S,I))):i.push(`${V}float inputs:clearcoatRoughness = ${r}`)),i.push(`${V}float inputs:ior = ${D}`),`\n\tdef Material "Material_${y.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${i.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${y.uniqueId}/PreviewSurface.outputs:surface>\n\n${A.join("\n")}\n\n\t}\n`}async function SI(y,S,I){const A={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...S};"undefined"===typeof fflate&&await i.Tools.LoadScriptAsync(A.fflateUrl);const B={};B[A.modelFileName]=null;let d='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';d+=function(y){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===y.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${y.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${y.planeAnchoringAlignment}"`:""}\n            `}(A);const F={};for(const V of y.meshes){if(0===V.getTotalVertices())continue;const y=V,S=y.Od,J=y.material;if(!J||!S||I&&!I(y))continue;if(-1!==["CS","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(J.getClassName())){const I="geometries/Geometry_"+S.uniqueId+".usda";if(!(I in B)){const y=cS(S,A);B[I]=XS(y)}J.uniqueId in F||(F[J.uniqueId]=J),d+=NS(y)}else i.Tools.Warn("USDZExportAsync does not support this material type: "+J.getClassName())}y.activeCamera&&A.exportCamera&&(d+=function(y,S){const I="Camera_"+y.uniqueId,i=MS(V.Matrix.RotationY(Math.PI).multiply(y.getWorldMatrix()));if(y.mode===D.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${I}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${i}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${y.Ld.toPrecision(S.precision)}, ${y.maxZ.toPrecision(S.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(y.orthoLeft||1)+Math.abs(y.orthoRight||1))).toPrecision(S.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(y.orthoTop||1)+Math.abs(y.orthoBottom||1))).toPrecision(S.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const V=y.getEngine().getAspectRatio(y),A=S.cameraSensorWidth||35;return`def Camera "${I}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${i}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${y.Ld.toPrecision(S.precision)}, ${y.maxZ.toPrecision(S.precision)})\n\t\t\tfloat focalLength = ${(A/(2*Math.tan(.5*y.fov))).toPrecision(S.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(A*V).toPrecision(S.precision)}\n\t\t\tfloat verticalAperture = ${(A/V).toPrecision(S.precision)}            \n\t\t}\n\t\n\t`}}(y.activeCamera,A)),d+="\n            }\n        }\n    }";const J={};d+=function(y,S,I){const V=[];for(const i in y){const A=y[i];V.push(yI(A,S,I))}return`\n    def "Materials"\n{\n${V.join("")}\n}\n\n`}(F,J,A),B[A.modelFileName]=fflate.strToU8(d);for(const V in J){const y=J[V],S=y.getSize(),I=await y.readPixels();if(!I)throw new Error("Texture data is not available");const i=await o.DumpTools.DumpDataAsync(S.width,S.height,I,"image/png",void 0,!1,!0);B[`textures/Texture_${V}.png`]=new Uint8Array(i).slice()}let u=0;for(const V in B){const y=B[V];if(!y)continue;u+=34+V.length;const S=63&u;if(4!==S){const I=new Uint8Array(64-S);B[V]=[y,{extra:{12345:I}}]}u=y.length}return fflate.zipSync(B,{level:0})}}}]);