"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[26],{12020:(U,X,b)=>{b.r(X),b.d(X,{EXT_materials_diffuse_roughness:()=>tX,EXT_mesh_gpu_instancing:()=>ZU,GLTF2Export:()=>DU,GLTFData:()=>p,KHR_draco_mesh_compression:()=>bX,KHR_lights_punctual:()=>qX,KHR_materials_anisotropy:()=>RX,KHR_materials_clearcoat:()=>aX,KHR_materials_diffuse_transmission:()=>xX,KHR_materials_dispersion:()=>OX,KHR_materials_emissive_strength:()=>uX,KHR_materials_ior:()=>PX,KHR_materials_iridescence:()=>jX,KHR_materials_sheen:()=>lX,KHR_materials_specular:()=>kX,KHR_materials_transmission:()=>AX,KHR_materials_unlit:()=>hX,KHR_materials_volume:()=>oX,KHR_texture_transform:()=>YX,OBJExport:()=>Q,STLExport:()=>KX,USDZExportAsync:()=>Xb,_ConvertToGLTFPBRMetallicRoughness:()=>s,_SolveMetallic:()=>A,__IGLTFExporterExtension:()=>z});var F=b(11593),E=b(11385),w=b(11928);class Q{static OBJ(U,X,b,Q){const z=[];let q=1,p=1;X&&(b||(b="mat"),z.push("mtllib "+b+".mtl"));for(let S=0;S<U.length;S++){const b=U[S],R=b.name||`mesh${S}}`;z.push(`o ${R}`);let n=null;if(Q){const U=b.Ob(!0);n=new F.Matrix,U.invertToRef(n),b.bakeTransformIntoVertices(U)}if(X){const U=b.material;U&&z.push("usemtl "+U.id)}const a=b.Nb;if(!a){E.Tools.Warn("No geometry is present on the mesh");continue}const J=a.getVerticesData("position"),m=a.getVerticesData("normal"),x=a.getVerticesData("uv"),I=a.ub();let O=0,N=0;if(!J||!I){E.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const u=U[0].fU().useRightHandedSystem?1:-1;for(let U=0;U<J.length;U+=3)z.push("v "+J[U]*u+" "+J[U+1]+" "+J[U+2]),O++;if(null!=m)for(let U=0;U<m.length;U+=3)z.push("vn "+m[U]*u+" "+m[U+1]+" "+m[U+2]);if(null!=x)for(let U=0;U<x.length;U+=2)z.push("vt "+x[U]+" "+x[U+1]),N++;const i=["","",""],P=(b.material||b.fU().defaultMaterial)._getEffectiveOrientation(b),[f,j]=P===w.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let U=0;U<I.length;U+=3){const X=[String(I[U]+q),String(I[U+f]+q),String(I[U+j]+q)],b=[String(I[U]+p),String(I[U+f]+p),String(I[U+j]+p)],F=X,E=null!=x?b:i,w=null!=m?X:i;z.push("f "+F[0]+"/"+E[0]+"/"+w[0]+" "+F[1]+"/"+E[1]+"/"+w[1]+" "+F[2]+"/"+E[2]+"/"+w[2])}Q&&n&&b.bakeTransformIntoVertices(n),q+=O,p+=N}return z.join("\n")}static MTL(U){const X=[],b=U.material;X.push("newmtl mat1"),X.push("  Ns "+b.specularPower.toFixed(4)),X.push("  Ni 1.5000"),X.push("  d "+b.alpha.toFixed(4)),X.push("  Tr 0.0000"),X.push("  Tf 1.0000 1.0000 1.0000"),X.push("  illum 2"),X.push("  Ka "+b.ambientColor.r.toFixed(4)+" "+b.ambientColor.g.toFixed(4)+" "+b.ambientColor.b.toFixed(4)),X.push("  Kd "+b.diffuseColor.r.toFixed(4)+" "+b.diffuseColor.g.toFixed(4)+" "+b.diffuseColor.b.toFixed(4)),X.push("  Ks "+b.specularColor.r.toFixed(4)+" "+b.specularColor.g.toFixed(4)+" "+b.specularColor.b.toFixed(4)),X.push("  Ke "+b.emissiveColor.r.toFixed(4)+" "+b.emissiveColor.g.toFixed(4)+" "+b.emissiveColor.b.toFixed(4));b.ambientTexture&&X.push("  map_Ka "+b.ambientTexture.name),b.diffuseTexture&&X.push("  map_Kd "+b.diffuseTexture.name),b.specularTexture&&X.push("  map_Ks "+b.specularTexture.name),b.bumpTexture&&X.push("  map_bump -imfchan z "+b.bumpTexture.name),b.opacityTexture&&X.push("  map_d "+b.opacityTexture.name);return X.join("\n")}}var z=0,q=b(11448);class p{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const U in this.files){const X=this.files[U],b=new Blob([X],{type:(0,q.i)(U)});E.Tools.Download(b,U)}}}var S=b(11664),R=b(12028),n=b(12038),a=b(12059),J=b(11717),m=b(11442),x=b(11636),I=b(11608);const O=I.HighestCommonFactor,N={...I,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:O};var u=b(11821),i=b(11570),P=b(12098),f=b(12104),j=b(11815);const e=1e-6,l=new x.NX(.04,.04,.04),d=1024,k=x.NX.White(),v=x.NX.Black();function A(U,X,b){if(X<l.r)return 0;const F=l.r,E=U*b/(1-l.r)+X-2*l.r,w=E*E-4*F*(l.r-X);return N.Clamp((-E+Math.sqrt(w))/(2*F),0,1)}function s(U){const X=U.diffuseColor.toLinearSpace(U.fU().getEngine().useExactSrgbConversions).scale(.5),b=U.alpha,E=function(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new F.Vector2(0,1),b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new F.Vector2(0,.1),E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new F.Vector2(0,.1),w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new F.Vector2(1300,.1);return function(U,X,b,F,E){return(1-U)*(1-U)*(1-U)*X+3*(1-U)*(1-U)*U*b+3*(1-U)*U*U*F+U*U*U*E}(Math.pow(U/w.x,.333333),X.y,b.y,E.y,w.y)}(N.Clamp(U.specularPower,0,d));return{baseColorFactor:[X.r,X.g,X.b,b],metallicFactor:0,roughnessFactor:E}}function h(U,X){X.needAlphaBlending()?U.alphaMode="BLEND":X.needAlphaTesting()&&(U.alphaMode="MASK",U.alphaCutoff=X.alphaCutOff)}function B(U,X,b){const F=new Uint8Array(U*X*4);for(let E=0;E<F.length;E+=4)F[E]=F[E+1]=F[E+2]=F[E+3]=255;return P.d.CreateRGBATexture(F,U,X,b)}function o(U){if(U instanceof Uint8Array){const X=U.length,b=new Float32Array(U.length);for(let F=0;F<X;++F)b[F]=U[F]/255;return b}if(U instanceof Float32Array)return U;throw new Error("Unsupported pixel format!")}class y{constructor(U){this._exporter=U,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(U){return U?this._textureMap.get(U)??null:null}async exportStandardMaterialAsync(U,X,b){const F=s(U),w={name:U.name};if(null==U.ib||U.ib||(U.twoSidedLighting||E.Tools.Warn(U.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),w.doubleSided=!0),b){const b=[],E=U.diffuseTexture;E&&b.push(this.exportTextureAsync(E,X).then((U=>{U&&(F.baseColorTexture=U)})));const Q=U.bumpTexture;Q&&b.push(this.exportTextureAsync(Q,X).then((U=>{U&&(w.normalTexture=U,1!==Q.level&&(w.normalTexture.scale=Q.level))})));const z=U.emissiveTexture;z&&(w.emissiveFactor=[1,1,1],b.push(this.exportTextureAsync(z,X).then((U=>{U&&(w.emissiveTexture=U)}))));const q=U.ambientTexture;q&&b.push(this.exportTextureAsync(q,X).then((U=>{if(U){const X={index:U.index};w.occlusionTexture=X}}))),b.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(b))}(U.alpha<1||U.opacityTexture)&&(U.alphaMode===f.e.ALPHA_COMBINE?w.alphaMode="BLEND":E.Tools.Warn(U.name+": glTF 2.0 does not support alpha mode: "+U.alphaMode.toString())),U.emissiveColor&&!U.emissiveColor.equalsWithEpsilon(v,e)&&(w.emissiveFactor=U.emissiveColor.Jb()),w.pbrMetallicRoughness=F,h(w,U),await this._finishMaterialAsync(w,U,X);const Q=this._exporter._materials;return Q.push(w),Q.length-1}async _finishMaterialAsync(U,X,b){const F=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",U,X),E=[];for(const w of F)E.push(this.exportTextureAsync(w,b));await Promise.all(E),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",U,X)}async _getImageDataAsync(U,X,F,E){const w=f.e.TEXTURETYPE_UNSIGNED_BYTE,Q=this._exporter._babylonScene,z=Q.getEngine(),q=z.createRawTexture(U,X,F,f.e.TEXTUREFORMAT_RGBA,!1,!0,i.c.NEAREST_SAMPLINGMODE,null,w);z.isWebGPU?await b.e(51).then(b.bind(b,14064)):await b.e(52).then(b.bind(b,14069)),await u.k.ApplyPostProcess("pass",q,Q,w,f.e.TEXTURE_NEAREST_SAMPLINGMODE,f.e.TEXTUREFORMAT_RGBA);const p=await z._readTexturePixels(q,X,F);return await j.DumpTools.DumpDataAsync(X,F,p,E,void 0,!0,!0)}_resizeTexturesToSameDimensions(U,X,b){const F=U?U.getSize():{width:0,height:0},E=X?X.getSize():{width:0,height:0};let w,Q;return F.width<E.width?(w=U&&U instanceof i.c?u.k.CreateResizedCopy(U,E.width,E.height,!0):B(E.width,E.height,b),Q=X):F.width>E.width?(Q=X&&X instanceof i.c?u.k.CreateResizedCopy(X,F.width,F.height,!0):B(F.width,F.height,b),w=U):(w=U,Q=X),{texture1:w,texture2:Q}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(U,X,b,F){const E=new Array;if(!U&&!X)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const w=U?U.fU():X?X.fU():null;if(w){var Q;const z=this._resizeTexturesToSameDimensions(U,X,w),q=null===(Q=z.texture1)||void 0===Q?void 0:Q.getSize();let p,S;const R=q.width,n=q.height,a=await z.texture1.readPixels(),J=await z.texture2.readPixels();if(!a)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(p=o(a),!J)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");S=o(J);const m=S.byteLength,I=new Uint8Array(m),O=new Uint8Array(m),N=4,u=v;let i=0,P=0;for(let U=0;U<n;++U)for(let X=0;X<R;++X){const F=(R*U+X)*N,E={diffuseColor:new x.NX(p[F],p[F+1],p[F+2]).toLinearSpace(w.getEngine().useExactSrgbConversions).multiply(b.diffuseColor),specularColor:new x.NX(S[F],S[F+1],S[F+2]).toLinearSpace(w.getEngine().useExactSrgbConversions).multiply(b.specularColor),glossiness:S[F+3]*b.glossiness},Q=this._convertSpecularGlossinessToMetallicRoughness(E);u.r=Math.max(u.r,Q.baseColor.r),u.g=Math.max(u.g,Q.baseColor.g),u.b=Math.max(u.b,Q.baseColor.b),i=Math.max(i,Q.metallic),P=Math.max(P,Q.roughness),O[F]=255*Q.baseColor.r,O[F+1]=255*Q.baseColor.g,O[F+2]=255*Q.baseColor.b,O[F+3]=z.texture1.mb?255*p[F+3]:255,I[F]=0,I[F+1]=255*Q.roughness,I[F+2]=255*Q.metallic,I[F+3]=255}const f={baseColor:u,metallic:i,roughness:P};let j=!1,l=!1;for(let U=0;U<n;++U)for(let X=0;X<R;++X){const b=(R*U+X)*N;O[b]/=f.baseColor.r>e?f.baseColor.r:1,O[b+1]/=f.baseColor.g>e?f.baseColor.g:1,O[b+2]/=f.baseColor.b>e?f.baseColor.b:1;const F=x.NX.FromInts(O[b],O[b+1],O[b+2]).toGammaSpace(w.getEngine().useExactSrgbConversions);O[b]=255*F.r,O[b+1]=255*F.g,O[b+2]=255*F.b,F.equalsWithEpsilon(k,e)||(l=!0),I[b+1]/=f.roughness>e?f.roughness:1,I[b+2]/=f.metallic>e?f.metallic:1;x.NX.FromInts(255,I[b+1],I[b+2]).equalsWithEpsilon(k,e)||(j=!0)}return j&&E.push(this._getImageDataAsync(I,R,n,F).then((U=>{f.metallicRoughnessTextureData=U}))),l&&E.push(this._getImageDataAsync(O,R,n,F).then((U=>{f.baseColorTextureData=U}))),await Promise.all(E).then((()=>f))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(U){const X=this._getPerceivedBrightness(U.diffuseColor),b=this._getPerceivedBrightness(U.specularColor),F=1-this._getMaxComponent(U.specularColor),E=A(X,b,F),w=U.diffuseColor.scale(F/(1-l.r)/Math.max(1-E)),Q=U.specularColor.mX(l.scale(1-E)).scale(1/Math.max(E));let z=x.NX.Lerp(w,Q,E*E);z=z.clampToRef(0,1,z);return{baseColor:z,metallic:E,roughness:1-U.glossiness}}_getPerceivedBrightness(U){return U?Math.sqrt(.299*U.r*U.r+.587*U.g*U.g+.114*U.b*U.b):0}_getMaxComponent(U){return U?Math.max(U.r,Math.max(U.g,U.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(U,X,b,F){const E=[],w={baseColor:U._albedoColor,metallic:U._metallic,roughness:U._roughness};if(F){U._albedoTexture&&E.push(this.exportTextureAsync(U._albedoTexture,X).then((U=>{U&&(b.baseColorTexture=U)})));const F=U._metallicTexture;F&&E.push(this.exportTextureAsync(F,X).then((U=>{U&&(b.metallicRoughnessTexture=U)})))}return E.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(E)),w}_getTextureSampler(U){const X={};if(!U||!(U instanceof i.c))return X;const b=this._getGLTFTextureWrapMode(U.wrapU);10497!==b&&(X.wrapS=b);const F=this._getGLTFTextureWrapMode(U.wrapV);switch(10497!==F&&(X.wrapT=F),U.samplingMode){case i.c.LINEAR_LINEAR:X.magFilter=9729,X.minFilter=9729;break;case i.c.LINEAR_NEAREST:X.magFilter=9729,X.minFilter=9728;break;case i.c.NEAREST_LINEAR:X.magFilter=9728,X.minFilter=9729;break;case i.c.NEAREST_LINEAR_MIPLINEAR:X.magFilter=9728,X.minFilter=9987;break;case i.c.NEAREST_NEAREST:X.magFilter=9728,X.minFilter=9728;break;case i.c.NEAREST_LINEAR_MIPNEAREST:X.magFilter=9728,X.minFilter=9985;break;case i.c.LINEAR_NEAREST_MIPNEAREST:X.magFilter=9729,X.minFilter=9984;break;case i.c.LINEAR_NEAREST_MIPLINEAR:X.magFilter=9729,X.minFilter=9986;break;case i.c.NEAREST_NEAREST_MIPLINEAR:X.magFilter=9728,X.minFilter=9986;break;case i.c.LINEAR_LINEAR_MIPLINEAR:X.magFilter=9729,X.minFilter=9987;break;case i.c.LINEAR_LINEAR_MIPNEAREST:X.magFilter=9729,X.minFilter=9985;break;case i.c.NEAREST_NEAREST_MIPNEAREST:X.magFilter=9728,X.minFilter=9984}return X}_getGLTFTextureWrapMode(U){switch(U){case i.c.WRAP_ADDRESSMODE:return 10497;case i.c.CLAMP_ADDRESSMODE:return 33071;case i.c.MIRROR_ADDRESSMODE:return 33648;default:return E.Tools.Error(`Unsupported Texture Wrap Mode ${U}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(U,X,b,F){const E={diffuseColor:U._albedoColor,specularColor:U._reflectivityColor,glossiness:U._microSurface},w=U._albedoTexture,Q=U._reflectivityTexture,z=U._useMicroSurfaceFromReflectivityMapAlpha;if(Q&&!z)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((w||Q)&&F){this._exporter._materialNeedsUVsSet.add(U);const F=this._exportTextureSampler(w||Q),z=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(w,Q,E,X),q=this._exporter._textures;if(z.baseColorTextureData){const U=this._exportImage(`baseColor${q.length}`,X,z.baseColorTextureData);b.baseColorTexture=this._exportTextureInfo(U,F,null===w||void 0===w?void 0:w.coordinatesIndex)}if(z.metallicRoughnessTextureData){const U=this._exportImage(`metallicRoughness${q.length}`,X,z.metallicRoughnessTextureData);b.metallicRoughnessTexture=this._exportTextureInfo(U,F,null===Q||void 0===Q?void 0:Q.coordinatesIndex)}return z}return this._convertSpecularGlossinessToMetallicRoughness(E)}async exportPBRMaterialAsync(U,X,b){const F={},E={name:U.name},w=U.isMetallicWorkflow();if(w){const X=U._albedoColor,b=U.alpha;X&&(F.baseColorFactor=[X.r,X.g,X.b,b])}const Q=w?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(U,X,F,b):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(U,X,F,b);await this._setMetallicRoughnessPbrMaterialAsync(Q,U,E,F,X,b),await this._finishMaterialAsync(E,U,X);const z=this._exporter._materials;return z.push(E),z.length-1}async _setMetallicRoughnessPbrMaterialAsync(U,X,b,F,w,Q){if(h(b,X),U.baseColor.equalsWithEpsilon(k,e)&&N.WithinEpsilon(X.alpha,1,e)||(F.baseColorFactor=[U.baseColor.r,U.baseColor.g,U.baseColor.b,X.alpha]),null!=U.metallic&&1!==U.metallic&&(F.metallicFactor=U.metallic),null!=U.roughness&&1!==U.roughness&&(F.roughnessFactor=U.roughness),null==X.ib||X.ib||(X._twoSidedLighting||E.Tools.Warn(X.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),b.doubleSided=!0),Q){const U=[],F=X._bumpTexture;F&&U.push(this.exportTextureAsync(F,w).then((U=>{U&&(b.normalTexture=U,1!==F.level&&(b.normalTexture.scale=F.level))})));const E=X._ambientTexture;E&&U.push(this.exportTextureAsync(E,w).then((U=>{if(U){const F={index:U.index,texCoord:U.texCoord,extensions:U.extensions};b.occlusionTexture=F;const E=X._ambientTextureStrength;E&&(F.strength=E)}})));const Q=X._emissiveTexture;Q&&U.push(this.exportTextureAsync(Q,w).then((U=>{U&&(b.emissiveTexture=U)}))),U.length>0&&(this._exporter._materialNeedsUVsSet.add(X),await Promise.all(U))}const z=X._emissiveColor;z.equalsWithEpsilon(v,e)||(b.emissiveFactor=z.Jb()),b.pbrMetallicRoughness=F}_getPixelsFromTextureAsync(U){return function(U){switch(U){case f.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case f.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case f.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case f.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case f.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case f.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case f.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case f.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case f.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case f.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case f.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case f.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case f.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(U.textureFormat)?(0,u.g)(U,U._texture.width,U._texture.height):(U.textureType,f.e.TEXTURETYPE_UNSIGNED_BYTE,U.readPixels())}async exportTextureAsync(U,X){const b=this._exporter._extensionsPreExportTextureAsync("exporter",U,X);return b?await b.then((async b=>b?await this._exportTextureInfoAsync(b,X):await this._exportTextureInfoAsync(U,X))):await this._exportTextureInfoAsync(U,X)}async _exportTextureInfoAsync(U,X){let b=this._textureMap.get(U);if(!b){const F=await this._getPixelsFromTextureAsync(U);if(!F)return null;const w=this._exportTextureSampler(U),Q=U.mimeType;if(Q)switch(Q){case"image/jpeg":case"image/png":case"image/webp":X=Q;break;default:E.Tools.Warn(`Unsupported media type: ${Q}. Exporting texture as PNG.`)}const z=this._internalTextureToImage,q=U.getInternalTexture().uniqueId;z[q]||(z[q]={});let p=z[q][X];if(void 0===p){const b=U.getSize();p=(async()=>{const E=await this._getImageDataAsync(F,b.width,b.height,X);return this._exportImage(U.name,X,E)})(),z[q][X]=p}b=this._exportTextureInfo(await p,w,U.coordinatesIndex),this._textureMap.set(U,b),this._exporter._extensionsPostExportTextures("exporter",b,U)}return b}_exportImage(U,X,b){const F=this._exporter._images;let w;if(this._exporter._shouldUseGlb){w={name:U,mimeType:X,bufferView:void 0};const F=this._exporter._bufferManager.createBufferView(new Uint8Array(b));this._exporter._bufferManager.setBufferView(w,F)}else{const Q=U.replace(/\.\/|\/|\.\\|\\/g,"_"),z=function(U){switch(U){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(X);let q=Q+z;F.some((U=>U.uri===q))&&(q=`${Q}_${E.Tools.RandomId()}${z}`),w={name:U,uri:q},this._exporter._imageData[q]={data:b,mimeType:X}}return F.push(w),F.length-1}_exportTextureInfo(U,X,b){const F=this._exporter._textures;let E=F.findIndex((b=>b.sampler==X&&b.source===U));-1===E&&(E=F.length,F.push({source:U,sampler:X}));const w={index:E};return b&&(w.texCoord=b),w}_exportTextureSampler(U){const X=this._getTextureSampler(U),b=this._exporter._samplers,F=b.findIndex((U=>U.minFilter===X.minFilter&&U.magFilter===X.magFilter&&U.wrapS===X.wrapS&&U.wrapT===X.wrapT));return-1!==F?F:(b.push(X),b.length-1)}}var t=b(11669),W=b(11408),Y=b(12111),K=b(11597);const V=F.JX.Zero(),g=F.Quaternion.Identity(),L=F.JX.One(),D=new F.JX(-1,1,1);function G(U,X){const{byteOffset:b,byteStride:F,type:E,normalized:w}=U,Q=U.getSize(),z=X.reduce(((U,X)=>X.getTotalVertices()>U?X.getTotalVertices():U),-Number.MAX_VALUE);return{byteOffset:b,byteStride:F,componentCount:Q,type:E,count:z*Q,normalized:w,totalVertices:z,kind:U.getKind()}}function Z(U){switch(U){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function c(U){switch(U){case S.h.PositionKind:case S.h.NormalKind:case S.h.TangentKind:case S.h.ColorKind:case S.h.MatricesIndicesKind:case S.h.MatricesIndicesExtraKind:case S.h.MatricesWeightsKind:case S.h.MatricesWeightsExtraKind:case S.h.UVKind:case S.h.UV2Kind:case S.h.UV3Kind:case S.h.UV4Kind:case S.h.UV5Kind:case S.h.UV6Kind:return!0}return!1}function r(U){switch(U){case w.e.TriangleFillMode:return 4;case w.e.TriangleStripDrawMode:return 5;case w.e.TriangleFanDrawMode:return 6;case w.e.PointListDrawMode:case w.e.PointFillMode:return 0;case w.e.LineLoopDrawMode:return 2;case w.e.LineListDrawMode:return 1;case w.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${U}`)}function M(U){const X=Math.sqrt(U.x*U.x+U.y*U.y+U.z*U.z);X>0&&(U.x/=X,U.y/=X,U.z/=X)}function H(U){return U.x*=-1,U}function T(U){if(U.x*U.x+U.y*U.y>.5){const X=Math.abs(U.x),b=Math.abs(U.y);if(X>b){const b=Math.sign(U.x);U.x=X,U.y*=-b,U.z*=-b,U.w*=b}else{const X=Math.sign(U.y);U.x*=-X,U.y=b,U.z*=X,U.w*=-X}}else{const X=Math.abs(U.z),b=Math.abs(U.w);if(X>b){const b=Math.sign(U.z);U.x*=-b,U.y*=b,U.z=X,U.w*=-b}else{const X=Math.sign(U.w);U.x*=X,U.y*=-X,U.z*=-X,U.w=b}}return U}function C(U){U.Pb(-U.z,U.w,U.x,-U.y)}function UU(U,X){const b=F.JX.FromArrayToRef(X.translation||[0,0,0],0,F.TmpVectors.JX[0]),E=F.Quaternion.FromArrayToRef(X.rotation||[0,0,0,1],0,F.TmpVectors.Quaternion[0]),w=F.Matrix.ComposeToRef(L,E,b,F.TmpVectors.Matrix[0]),Q=F.JX.FromArrayToRef(U.translation||[0,0,0],0,F.TmpVectors.JX[2]),z=F.Quaternion.FromArrayToRef(U.rotation||[0,0,0,1],0,F.TmpVectors.Quaternion[1]),q=F.Matrix.ComposeToRef(L,z,Q,F.TmpVectors.Matrix[1]);w.multiplyToRef(q,q),q.decompose(void 0,E,b),b.equalsWithEpsilon(V,K.d)?delete X.translation:X.translation=b.Jb(),E.equalsWithEpsilon(g,K.d)?delete X.rotation:X.rotation=E.Jb(),X.scale&&delete X.scale}function XU(U,X){if(!(X instanceof R.c))return!1;if(!(1===X.getChildren().length&&0===U.getChildren().length&&U.parent===X))return!1;const b=U.fU(),F=U instanceof Y.e&&!b.useRightHandedSystem?D:L;return!!X.fb.equalsWithEpsilon(F,K.d)||(W.e.Warn(`Cannot collapse node ${U.name} into parent node ${X.name} with modified scaling.`),!1)}function bU(U){if(U instanceof Array){const X=new Float32Array(U);return new Uint8Array(X.buffer,X.byteOffset,X.byteLength)}return ArrayBuffer.isView(U)?new Uint8Array(U.buffer,U.byteOffset,U.byteLength):new Uint8Array(U)}function FU(U,X){for(const[b,F]of Object.entries(U)){const E=X[b];(Array.isArray(F)&&Array.isArray(E)&&EU(F,E)||F===E)&&delete U[b]}return U}function EU(U,X){return U.length===X.length&&U.every(((U,b)=>U===X[b]))}const wU=F.Matrix.Compose(new F.JX(-1,1,1),F.Quaternion.Identity(),F.JX.Zero());function QU(U,X){if(!(U instanceof R.c))return!1;if(X){if(!U.getWorldMatrix().equalsWithEpsilon(F.Matrix.IdentityReadOnly,K.d))return!1}else{if(!U.getWorldMatrix().multiplyToRef(wU,F.TmpVectors.Matrix[0]).equalsWithEpsilon(F.Matrix.IdentityReadOnly,K.d))return!1}return!(U instanceof n.b&&U.Nb)}const zU=new Map([[Int8Array,(U,X,b)=>U.setInt8(X,b)],[Uint8Array,(U,X,b)=>U.setUint8(X,b)],[Uint8ClampedArray,(U,X,b)=>U.setUint8(X,b)],[Int16Array,(U,X,b)=>U.setInt16(X,b,!0)],[Uint16Array,(U,X,b)=>U.setUint16(X,b,!0)],[Int32Array,(U,X,b)=>U.setInt32(X,b,!0)],[Uint32Array,(U,X,b)=>U.setUint32(X,b,!0)],[Float32Array,(U,X,b)=>U.setFloat32(X,b,!0)],[Float64Array,(U,X,b)=>U.setFloat64(X,b,!0)]]);class qU{writeTypedArray(U){this._checkGrowBuffer(U.byteLength);const X=zU.get(U.constructor);for(let b=0;b<U.length;b++)X(this._dataView,this._byteOffset,U[b]),this._byteOffset+=U.BYTES_PER_ELEMENT}constructor(U){this._data=new Uint8Array(U),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(U){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,U),this._byteOffset++}writeInt8(U){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,U),this._byteOffset++}writeInt16(U){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,U,!0),this._byteOffset+=2}writeUInt16(U){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,U,!0),this._byteOffset+=2}writeInt32(U){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,U,!0),this._byteOffset+=4}writeUInt32(U){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,U,!0),this._byteOffset+=4}writeFloat32(U){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,U,!0),this._byteOffset+=4}writeFloat64(U){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,U,!0),this._byteOffset+=8}_checkGrowBuffer(U){const X=this.byteOffset+U;if(X>this._data.byteLength){const U=new Uint8Array(2*X);U.set(this._data),this._data=U,this._dataView=new DataView(this._data.buffer)}}}function pU(U){return U%4===0?4:U%2===0?2:1}class SU{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(U){let X=0;this._bufferViewToData.forEach((U=>{X+=U.byteLength}));const b=new qU(X),F=Array.from(this._bufferViewToData.keys()).sort(((U,X)=>pU(X.byteLength)-pU(U.byteLength)));for(const E of F){E.byteOffset=b.byteOffset,U.push(E);const X=U.length-1,F=this.getPropertiesWithBufferView(E);for(const U of F)U.bufferView=X;b.writeTypedArray(this._bufferViewToData.get(E)),this._bufferViewToData.delete(E)}return b.getOutputData()}createBufferView(U,X){const b={buffer:0,byteOffset:void 0,byteLength:U.byteLength,byteStride:X};return this._bufferViewToData.set(b,U),b}createAccessor(U,X,b,F,E,w,Q){this._verifyBufferView(U);const z={bufferView:void 0,componentType:b,count:F,type:X,min:null===w||void 0===w?void 0:w.min,max:null===w||void 0===w?void 0:w.max,normalized:Q,byteOffset:E};return this.setBufferView(z,U),this._accessorToBufferView.set(z,U),z}setBufferView(U,X){this._verifyBufferView(X);this.getPropertiesWithBufferView(X).push(U)}removeBufferView(U){const X=this.getPropertiesWithBufferView(U);for(const b of X)void 0!==b.bufferView&&delete b.bufferView;this._bufferViewToData.delete(U),this._bufferViewToProperties.delete(U),this._accessorToBufferView.forEach(((X,b)=>{X===U&&(void 0!==b.byteOffset&&delete b.byteOffset,this._accessorToBufferView.delete(b))}))}getBufferView(U){const X=this._accessorToBufferView.get(U);return this._verifyBufferView(X),X}getPropertiesWithBufferView(U){return this._verifyBufferView(U),this._bufferViewToProperties.set(U,this._bufferViewToProperties.get(U)??[]),this._bufferViewToProperties.get(U)}getData(U){return this._verifyBufferView(U),this._bufferViewToData.get(U)}_verifyBufferView(U){if(void 0===U||!this._bufferViewToData.has(U))throw new Error(`BufferView ${U} not found in BufferManager.`)}}var RU,nU=b(12075),aU=b(12094),JU=b(12117),mU=b(11975),xU=b(12142),IU=b(12154),OU=b(12067),NU=b(12158);!function(U){U[U.INTANGENT=0]="INTANGENT",U[U.OUTTANGENT=1]="OUTTANGENT"}(RU||(RU={}));class uU{static _IsTransformable(U){return U&&(U instanceof R.c||U instanceof nU.e||U instanceof NU.c)}static _CreateNodeAnimation(U,X,b,F,w){if(this._IsTransformable(U)){const Q=[],z=[],q=X.getKeys(),p=uU._CalculateMinMaxKeyFrames(q),S=uU._DeduceInterpolation(q,b,F),R=S.interpolationType,n=S.shouldBakeAnimation;if(n?uU._CreateBakedAnimation(U,X,b,p.min,p.max,X.framePerSecond,w,Q,z,p,F):"LINEAR"===R||"STEP"===R?uU._CreateLinearOrStepAnimation(U,X,b,Q,z,F):"CUBICSPLINE"===R?uU._CreateCubicSplineAnimation(U,X,b,Q,z,F):uU._CreateBakedAnimation(U,X,b,p.min,p.max,X.framePerSecond,w,Q,z,p,F),Q.length&&z.length){return{inputs:Q,outputs:z,samplerInterpolation:R,inputsMin:n?p.min:E.Tools.FloatRound(p.min/X.framePerSecond),inputsMax:n?p.max:E.Tools.FloatRound(p.max/X.framePerSecond)}}}return null}static _DeduceAnimationInfo(U){let X=null,b="VEC3",F=!1;const w=U.targetProperty.split(".");switch(w[0]){case"fb":X="scale";break;case"position":X="translation";break;case"rotation":b="VEC4",X="rotation";break;case"rotationQuaternion":b="VEC4",F=!0,X="rotation";break;case"influence":b="SCALAR",X="weights";break;default:E.Tools.Error(`Unsupported animatable property ${w[0]}`)}return X?{animationChannelTargetPath:X,dataAccessorType:b,useQuaternion:F}:(E.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(U,X,b,F,E,w,Q,z,q,p,S){let R;if(uU._IsTransformable(U)&&U.animations)for(const n of U.animations){if(S&&!S(n))continue;const E=uU._DeduceAnimationInfo(n);E&&(R={name:n.name,samplers:[],channels:[]},uU._AddAnimation(`${n.name}`,n.hasRunningRuntimeAnimations?X:R,U,n,E.dataAccessorType,E.animationChannelTargetPath,F,w,Q,z,E.useQuaternion,q,p),R.samplers.length&&R.channels.length&&b.push(R))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(U,X,b,F,E,w,Q,z,q,p,S){let R;if(U instanceof OU.e){const E=U.morphTargetManager;if(E)for(let n=0;n<E.numTargets;++n){const a=E.getTarget(n);for(const J of a.animations){if(S&&!S(J))continue;const a=new xU.e(`${J.name}`,"influence",J.framePerSecond,J.dataType,J.loopMode,J.enableBlending),m=[],x=J.getKeys();for(let U=0;U<x.length;++U){const X=x[U];for(let U=0;U<E.numTargets;++U)U==n?m.push(X):m.push({frame:X.frame,value:0})}a.setKeys(m);const I=uU._DeduceAnimationInfo(a);I&&(R={name:a.name,samplers:[],channels:[]},uU._AddAnimation(J.name,J.hasRunningRuntimeAnimations?X:R,U,a,I.dataAccessorType,I.animationChannelTargetPath,F,w,Q,z,I.useQuaternion,q,p,E.numTargets),R.samplers.length&&R.channels.length&&b.push(R))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(U,X,b,F,E,w,Q,z,q){let p;if(U.animationGroups){const R=U.animationGroups;for(const n of R){const R=new Map,a=new Map,J=new Set,m=n.to-n.from;p={name:n.name,channels:[],samplers:[]};for(let X=0;X<n.targetedAnimations.length;++X){const m=n.targetedAnimations[X],x=m.target,I=m.animation;if(q&&!q(I))continue;const O=z.has(x);if(this._IsTransformable(x)||1===x.length&&this._IsTransformable(x[0])){const U=uU._DeduceAnimationInfo(m.animation);if(U){const X=this._IsTransformable(x)?x:this._IsTransformable(x[0])?x[0]:null;X&&uU._AddAnimation(`${I.name}`,p,X,I,U.dataAccessorType,U.animationChannelTargetPath,b,F,E,w,U.useQuaternion,Q,O)}}else if(x instanceof IU.e||1===x.length&&x[0]instanceof IU.e){if(uU._DeduceAnimationInfo(m.animation)){const X=x instanceof IU.e?x:x[0];if(X){const b=U.morphTargetManagers.find((U=>{for(let b=0;b<U.numTargets;++b)if(U.getTarget(b)===X)return!0;return!1}));if(b){const F=U.meshes.find((U=>U.morphTargetManager===b));var S;if(F)R.has(F)||R.set(F,new Map),null===(S=R.get(F))||void 0===S||S.set(X,I),J.add(F),a.set(F,I)}}}}}J.forEach((U=>{const X=U.morphTargetManager;let z=null;const q=[],S=a.get(U).getKeys(),J=S.length;for(let b=0;b<J;++b)for(let F=0;F<X.numTargets;++F){const E=X.getTarget(F),w=R.get(U);if(w){const X=w.get(E);X?(z||(z=new xU.e(`${n.name}_${U.name}_MorphWeightAnimation`,"influence",X.framePerSecond,xU.e.ANIMATIONTYPE_FLOAT,X.loopMode,X.enableBlending)),q.push(X.getKeys()[b])):q.push({frame:n.from+m/J*b,value:E.influence,inTangent:S[0].inTangent?0:void 0,outTangent:S[0].outTangent?0:void 0})}}z.setKeys(q);const x=uU._DeduceAnimationInfo(z);x&&uU._AddAnimation(`${n.name}_${U.name}_MorphWeightAnimation`,p,U,z,x.dataAccessorType,x.animationChannelTargetPath,b,F,E,w,x.useQuaternion,Q,!1,null===X||void 0===X?void 0:X.numTargets)})),p.channels.length&&p.samplers.length&&X.push(p)}}}static _AddAnimation(U,X,b,E,w,Q,z,q,p,S,R,n,a,J){const m=uU._CreateNodeAnimation(b,E,Q,R,n);let x,I,O,N,u,i;if(m){if(J){let U=0,X=0;const b=[];for(;m.inputs.length>0;)X=m.inputs.shift(),U%J==0&&b.push(X),U++;m.inputs=b}const U=z.get(b),E=new Float32Array(m.inputs);x=q.createBufferView(E),I=q.createAccessor(x,"SCALAR",5126,m.inputs.length,void 0,{min:[m.inputsMin],max:[m.inputsMax]}),S.push(I),O=S.length-1;const p=new F.Quaternion,R=new F.JX,n=new F.JX,P=b instanceof nU.e,f=Z(w),j=new Float32Array(m.outputs.length*f);m.outputs.forEach((function(U,X){let b=U;switch(Q){case"translation":a&&(F.JX.FromArrayToRef(U,0,n),H(n),n.toArray(b));break;case"rotation":4===U.length?F.Quaternion.FromArrayToRef(U,0,p):(b=new Array(4),F.JX.FromArrayToRef(U,0,R),F.Quaternion.FromEulerVectorToRef(R,p)),a&&(T(p),P&&C(p)),p.toArray(b)}j.set(b,X*f)})),x=q.createBufferView(j),I=q.createAccessor(x,w,5126,m.outputs.length),S.push(I),N=S.length-1,u={interpolation:m.samplerInterpolation,input:O,output:N},X.samplers.push(u),i={sampler:X.samplers.length-1,target:{node:U,path:Q}},X.channels.push(i)}}static _CreateBakedAnimation(U,X,b,w,Q,z,q,p,S,R,n){let a;const J=F.Quaternion.Identity();let m,x=null,I=null,O=null,N=null,u=null,i=null;R.min=E.Tools.FloatRound(w/z);const P=X.getKeys();for(let F=0,f=P.length;F<f;++F){if(i=null,O=P[F],F+1<f)if(N=P[F+1],O.value.equals&&O.value.equals(N.value)||O.value===N.value){if(0!==F)continue;i=O.frame}else i=N.frame;else{if(u=P[F-1],O.value.equals&&O.value.equals(u.value)||O.value===u.value)continue;i=Q}if(i)for(let F=O.frame;F<=i;F+=q){if(m=E.Tools.FloatRound(F/z),m===x)continue;x=m,I=m;const w={key:0,repeatCount:0,loopMode:X.loopMode};a=X._interpolate(F,w),uU._SetInterpolatedValue(U,a,m,X,b,J,p,S,n)}}I&&(R.max=I)}static _ConvertFactorToVector3OrQuaternion(U,X,b,w,Q){const z=uU._GetBasePositionRotationOrScale(X,w,Q),q=b.targetProperty.split("."),p=q?q[1]:"",S=Q?F.Quaternion.uX(z).normalize():F.JX.uX(z);switch(p){case"x":case"y":case"z":S[p]=U;break;case"w":S.w=U;break;default:E.Tools.Error(`glTFAnimation: Unsupported component name "${p}"!`)}return S}static _SetInterpolatedValue(U,X,b,E,w,Q,z,q,p){let S;z.push(b),"weights"!==w?(E.dataType===xU.e.ANIMATIONTYPE_FLOAT&&(X=this._ConvertFactorToVector3OrQuaternion(X,U,E,w,p)),"rotation"===w?(p?Q=X:(S=X,F.Quaternion.RotationYawPitchRollToRef(S.y,S.x,S.z,Q)),q.push(Q.Jb())):(S=X,q.push(S.Jb()))):q.push([X])}static _CreateLinearOrStepAnimation(U,X,b,F,E,w){for(const Q of X.getKeys())F.push(Q.frame/X.framePerSecond),uU._AddKeyframeValue(Q,X,E,b,U,w)}static _CreateCubicSplineAnimation(U,X,b,F,E,w){X.getKeys().forEach((function(Q){F.push(Q.frame/X.framePerSecond),uU._AddSplineTangent(RU.INTANGENT,E,b,"CUBICSPLINE",Q,w),uU._AddKeyframeValue(Q,X,E,b,U,w),uU._AddSplineTangent(RU.OUTTANGENT,E,b,"CUBICSPLINE",Q,w)}))}static _GetBasePositionRotationOrScale(U,X,b){let E;if("rotation"===X)if(b){E=(U.rotationQuaternion??F.Quaternion.Identity()).Jb()}else{E=(U.rotation??F.JX.Zero()).Jb()}else if("translation"===X){E=(U.position??F.JX.Zero()).Jb()}else{E=(U.fb??F.JX.One()).Jb()}return E}static _AddKeyframeValue(U,X,b,w,Q,z){let q;const p=X.dataType;if(p===xU.e.ANIMATIONTYPE_VECTOR3){let X=U.value.Jb();if("rotation"===w){const U=F.JX.uX(X);X=F.Quaternion.RotationYawPitchRoll(U.y,U.x,U.z).Jb()}b.push(X)}else if(p===xU.e.ANIMATIONTYPE_FLOAT){if("weights"===w)b.push([U.value]);else if(q=this._ConvertFactorToVector3OrQuaternion(U.value,Q,X,w,z),q){if("rotation"===w){const U=z?q:F.Quaternion.RotationYawPitchRoll(q.y,q.x,q.z).normalize();b.push(U.Jb())}b.push(q.Jb())}}else p===xU.e.ANIMATIONTYPE_QUATERNION?b.push(U.value.normalize().Jb()):E.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(U,X,b){let F,E,w=!1;if("rotation"===X&&!b)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let Q=0,z=U.length;Q<z;++Q)if(E=U[Q],E.inTangent||E.outTangent)if(F){if("CUBICSPLINE"!==F){F="LINEAR",w=!0;break}}else F="CUBICSPLINE";else if(F){if("CUBICSPLINE"===F||E.interpolation&&1===E.interpolation&&"STEP"!==F){F="LINEAR",w=!0;break}}else F=E.interpolation&&1===E.interpolation?"STEP":"LINEAR";return F||(F="LINEAR"),{interpolationType:F,shouldBakeAnimation:w}}static _AddSplineTangent(U,X,b,E,w,Q){let z;const q=U===RU.INTANGENT?w.inTangent:w.outTangent;if("CUBICSPLINE"===E){if("rotation"===b)if(q)if(Q)z=q.Jb();else{const U=q;z=F.Quaternion.RotationYawPitchRoll(U.y,U.x,U.z).Jb()}else z=[0,0,0,0];else z="weights"===b?q?[q]:[0]:q?q.Jb():[0,0,0];X.push(z)}}static _CalculateMinMaxKeyFrames(U){let X=1/0,b=-1/0;return U.forEach((function(U){X=Math.min(X,U.frame),b=Math.max(b,U.frame)})),{min:X,max:b}}}function iU(U,X,b,w,Q,z){const q={attributes:{},influence:U.influence,name:U.name},p=X.Nb;if(!p)return E.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),q;const R=z?-1:1,n=F.JX.Zero();let a=0,J=0;if(U.hasPositions){const w=U.getPositions(),z=p.getVerticesData(S.h.PositionKind);if(z){const U=new Float32Array(z.length),X=[1/0,1/0,1/0],E=[-1/0,-1/0,-1/0];J=z.length/3,a=0;for(let b=a;b<J;++b){const Q=F.JX.uX(z,3*b);F.JX.uX(w,3*b).subtractToRef(Q,n),n.x*=R,X[0]=Math.min(X[0],n.x),E[0]=Math.max(E[0],n.x),X[1]=Math.min(X[1],n.y),E[1]=Math.max(E[1],n.y),X[2]=Math.min(X[2],n.z),E[2]=Math.max(E[2],n.z),U[3*b]=n.x,U[3*b+1]=n.y,U[3*b+2]=n.z}const p=b.createBufferView(U,12),S=b.createAccessor(p,"VEC3",5126,w.length/3,0,{min:X,max:E});Q.push(S),q.attributes.POSITION=Q.length-1}else E.Tools.Warn(`Morph target positions for mesh ${X.name} were not exported. Mesh does not have position vertex data`)}if(U.hasNormals){const w=U.getNormals(),z=p.getVerticesData(S.h.NormalKind);if(z){const U=new Float32Array(z.length);J=z.length/3,a=0;for(let b=a;b<J;++b){const X=F.JX.uX(z,3*b).normalize();F.JX.uX(w,3*b).normalize().subtractToRef(X,n),U[3*b]=n.x*R,U[3*b+1]=n.y,U[3*b+2]=n.z}const X=b.createBufferView(U,12),E=b.createAccessor(X,"VEC3",5126,w.length/3,0);Q.push(E),q.attributes.NORMAL=Q.length-1}else E.Tools.Warn(`Morph target normals for mesh ${X.name} were not exported. Mesh does not have normals vertex data`)}if(U.hasTangents){const w=U.getTangents(),z=p.getVerticesData(S.h.TangentKind);if(z){J=z.length/4;const U=new Float32Array(3*J);a=0;for(let b=a;b<J;++b){const X=F.JX.uX(z,4*b);M(X);const E=F.JX.uX(w,3*b);M(E),E.subtractToRef(X,n),U[3*b]=n.x*R,U[3*b+1]=n.y,U[3*b+2]=n.z}const X=b.createBufferView(U,12),E=b.createAccessor(X,"VEC3",5126,J,0);Q.push(E),q.attributes.TANGENT=Q.length-1}else E.Tools.Warn(`Morph target tangents for mesh ${X.name} were not exported. Mesh does not have tangents vertex data`)}if(U.hasColors){const w=U.getColors(),z=p.getVerticesData(S.h.ColorKind),R=p.getVertexBuffer(S.h.ColorKind);if(z&&R){const U=R.getSize();J=z.length/U;const X=new Float32Array(J*U);a=0;for(let b=a;b<J;++b)if(3===U){const E=F.JX.uX(z,b*U);F.JX.uX(w,b*U).subtractToRef(E,n),X[3*b]=n.x,X[3*b+1]=n.y,X[3*b+2]=n.z}else if(4===U){const E=new F.Vector4,Q=F.Vector4.uX(z,b*U);F.Vector4.uX(w,b*U).subtractToRef(Q,E),X[4*b]=E.x,X[4*b+1]=E.y,X[4*b+2]=E.z,X[4*b+3]=E.w}else E.Tools.Warn(`Unsupported number of components for color attribute: ${U}`);const p=b.createBufferView(X,4*U),S=b.createAccessor(p,3===U?"VEC3":"VEC4",5126,J,0);Q.push(S),q.attributes.COLOR_0=Q.length-1}else E.Tools.Warn(`Morph target colors for mesh ${X.name} were not exported. Mesh does not have colors vertex data`)}return q}var PU=b(12161),fU=b(12006),jU=b(11987),eU=b(11551);class lU{}lU.DEFAULT_COLOR=x.NX.White(),lU.DEFAULT_WIDTH_ATTENUATED=1,lU.DEFAULT_WIDTH=.1;var dU=b(11803),kU=b(12163);class vU{static ConvertPoints(U,X){if(U.length&&Array.isArray(U)&&"number"===typeof U[0])return[U];if(U.length&&Array.isArray(U[0])&&"number"===typeof U[0][0])return U;if(U.length&&!Array.isArray(U[0])&&U[0]instanceof F.JX){const X=[];for(let b=0;b<U.length;b++){const F=U[b];X.push(F.x,F.y,F.z)}return[X]}if(U.length>0&&Array.isArray(U[0])&&U[0].length>0&&U[0][0]instanceof F.JX){const X=[],b=U;for(const U of b)X.push(U.flatMap((U=>[U.x,U.y,U.z])));return X}if(U instanceof Float32Array){if(null!==X&&void 0!==X&&X.floatArrayStride){const b=[],F=3*X.floatArrayStride;for(let X=0;X<U.length;X+=F){const E=new Array(F);for(let b=0;b<F;b++)E[b]=U[X+b];b.push(E)}return b}return[Array.from(U)]}if(U.length&&U[0]instanceof Float32Array){const X=[];for(const b of U)X.push(Array.from(b));return X}return[]}static OmitZeroLengthPredicate(U,X,b){const F=[];return X.mX(U).lengthSquared()>0&&F.push([U,X]),b.mX(X).lengthSquared()>0&&F.push([X,b]),U.mX(b).lengthSquared()>0&&F.push([b,U]),0===F.length?null:F}static OmitDuplicatesPredicate(U,X,b,F){const E=[];return vU._SearchInPoints(U,X,F)||E.push([U,X]),vU._SearchInPoints(X,b,F)||E.push([X,b]),vU._SearchInPoints(b,U,F)||E.push([b,U]),0===E.length?null:E}static _SearchInPoints(U,X,b){for(const Q of b)for(let b=0;b<Q.length;b++){var F,E,w;if(null!==(F=Q[b])&&void 0!==F&&F.equals(U))if(null!==(E=Q[b+1])&&void 0!==E&&E.equals(X)||null!==(w=Q[b-1])&&void 0!==w&&w.equals(X))return!0}return!1}static MeshesToLines(U,X){const b=[];for(let E=0;E<U.length;E++){const w=U[E],Q=w.getVerticesData(S.h.PositionKind),z=w.ub();if(Q&&z)for(let U=0,q=0;U<z.length;U++){const p=3*z[q++],S=3*z[q++],R=3*z[q++],n=new F.JX(Q[p],Q[p+1],Q[p+2]),a=new F.JX(Q[S],Q[S+1],Q[S+2]),J=new F.JX(Q[R],Q[R+1],Q[R+2]);if(X){const F=X(n,a,J,b,U,p,w,E,Q,z);if(F)for(const U of F)b.push(U)}else b.push([n,a],[a,J],[J,n])}}return b}static ToVector3Array(U){if(Array.isArray(U[0])){const X=[],b=U;for(const U of b){const b=[];for(let X=0;X<U.length;X+=3)b.push(new F.JX(U[X],U[X+1],U[X+2]));X.push(b)}return X}const X=U,b=[];for(let E=0;E<X.length;E+=3)b.push(new F.JX(X[E],X[E+1],X[E+2]));return b}static ToNumberArray(U){return U.flatMap((U=>[U.x,U.y,U.z]))}static GetPointsCountInfo(U){const X=new Array(U.length);let b=0;for(let F=U.length;F--;)X[F]=U[F].length/3,b+=X[F];return{total:b,counts:X}}static GetLineLength(U){if(0===U.length)return 0;let X;X="number"===typeof U[0]?vU.ToVector3Array(U):U;const b=F.TmpVectors.JX[0];let E=0;for(let F=0;F<X.length-1;F++){const U=X[F];E+=X[F+1].subtractToRef(U,b).length()}return E}static GetLineLengthArray(U){const X=new Float32Array(U.length/3);let b=0;for(let F=0,E=U.length/3-1;F<E;F++){let E=U[3*F+0],w=U[3*F+1],Q=U[3*F+2];E-=U[3*F+3],w-=U[3*F+4],Q-=U[3*F+5];b+=Math.sqrt(E*E+w*w+Q*Q),X[F+1]=b}return X}static SegmentizeSegmentByCount(U,X,b){const E=[],w=X.mX(U),Q=F.TmpVectors.JX[0];Q.jb(b);const z=F.TmpVectors.JX[1];w.divideToRef(Q,z);let q=U.clone();E.push(q);for(let F=0;F<b;F++)q=q.clone(),E.push(q.addInPlace(z));return E}static SegmentizeLineBySegmentLength(U,X){const b=U[0]instanceof F.JX?vU.GetLineSegments(U):"number"===typeof U[0]?vU.GetLineSegments(vU.ToVector3Array(U)):U,E=[];for(const F of b)if(F.length>X){const U=vU.SegmentizeSegmentByCount(F.point1,F.point2,Math.ceil(F.length/X));for(const X of U)E.push(X)}else E.push(F.point1),E.push(F.point2);return E}static SegmentizeLineBySegmentCount(U,X){const b="number"===typeof U[0]?vU.ToVector3Array(U):U,F=vU.GetLineLength(b)/X;return vU.SegmentizeLineBySegmentLength(b,F)}static GetLineSegments(U){const X=[];for(let b=0;b<U.length-1;b++){const F=U[b],E=U[b+1],w=E.mX(F).length();X.push({point1:F,point2:E,length:w})}return X}static GetMinMaxSegmentLength(U){const X=vU.GetLineSegments(U).sort((U=>U.length));return{min:X[0].length,max:X[X.length-1].length}}static GetPositionOnLineByVisibility(U,X,b){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const w=X*b;let Q=0,z=0;const q=U.length;for(let F=0;F<q;F++){if(w<=Q+U[F].length){z=F;break}Q+=U[F].length}const p=(w-Q)/U[z].length;return U[z].point2.subtractToRef(U[z].point1,F.TmpVectors.JX[0]),F.TmpVectors.JX[1]=F.TmpVectors.JX[0].multiplyByFloats(p,p,p),E||F.TmpVectors.JX[1].addInPlace(U[z].point1),F.TmpVectors.JX[1].clone()}static GetCircleLinePoints(U,X){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:U,w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/X;const Q=[];for(let z=0;z<=X;z++)Q.push(new F.JX(Math.cos(z*w)*U,Math.sin(z*w)*E,b));return Q}static GetBezierLinePoints(U,X,b,F){return dU.g.CreateQuadraticBezier(U,X,b,F).getPoints().flatMap((U=>[U.x,U.y,U.z]))}static GetArrowCap(U,X,b,F,E){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[U.clone(),U.add(X.multiplyByFloats(b,b,b))],widths:[F,E,w,Q]}}static GetPointsFromText(U,X,b,F){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,w=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const Q=[],z=(0,kU.e)(U,X,b,F);for(const q of z){for(const U of q.paths){const X=[],b=U.getPoints();for(const U of b)X.push(U.x,U.y,E);Q.push(X)}if(w)for(const U of q.holes){const X=[],b=U.getPoints();for(const U of b)X.push(U.x,U.y,E);Q.push(X)}}return Q}static Color3toRGBAUint8(U){const X=new Uint8Array(4*U.length);for(let b=0,F=0;b<U.length;b++)X[F++]=255*U[b].r,X[F++]=255*U[b].g,X[F++]=255*U[b].b,X[F++]=255;return X}static CreateColorsTexture(U,X,b,F){const E=F.getEngine().getCaps().maxTextureSize??1,w=X.length>E?E:X.length,Q=Math.ceil(X.length/E);Q>1&&(X=[...X,...Array(w*Q-X.length).fill(X[0])]);const z=vU.Color3toRGBAUint8(X),q=new P.d(z,w,Q,J.e.TEXTUREFORMAT_RGBA,F,!1,!0,b);return q.name=U,q}static PrepareEmptyColorsTexture(U){if(!lU.EmptyColorsTexture){const X=new Uint8Array(4);lU.EmptyColorsTexture=new P.d(X,1,1,J.e.TEXTUREFORMAT_RGBA,U,!1,!1,P.d.NEAREST_NEAREST),lU.EmptyColorsTexture.name="grlEmptyColorsTexture"}return lU.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var U;null===(U=lU.EmptyColorsTexture)||void 0===U||U.dispose(),lU.EmptyColorsTexture=null}static BooleanToNumber(U){return U?1:0}}class AU extends jU.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class sU extends fU.c{isCompatible(U){return!0}constructor(U,X,b){var E;b=b||{color:lU.DEFAULT_COLOR};const w=new AU;w.GREASED_LINE_HAS_COLOR=!!b.color&&!b.useColors,w.GREASED_LINE_SIZE_ATTENUATION=b.sizeAttenuation??!1,w.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===b.colorDistributionType,w.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(X??U.fU()).useRightHandedSystem,w.GREASED_LINE_CAMERA_FACING=b.cameraFacing??!0,super(U,sU.GREASED_LINE_MATERIAL_NAME,200,w,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(E=b)||void 0===E?void 0:E.forceGLSL)||sU.ForceGLSL,this._scene=X??U.fU(),this._engine=this._scene.getEngine(),this._cameraFacing=b.cameraFacing??!0,this.visibility=b.visibility??1,this.useDash=b.useDash??!1,this.dashRatio=b.dashRatio??.5,this.dashOffset=b.dashOffset??0,this.width=b.width?b.width:b.sizeAttenuation?lU.DEFAULT_WIDTH_ATTENUATED:lU.DEFAULT_WIDTH,this._sizeAttenuation=b.sizeAttenuation??!1,this.colorMode=b.colorMode??0,this._color=b.color??null,this.useColors=b.useColors??!1,this._colorsDistributionType=b.colorDistributionType??0,this.colorsSampling=b.colorsSampling??P.d.NEAREST_NEAREST,this._colors=b.dU??null,this.dashCount=b.dashCount??1,this.resolution=b.resolution??new F.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),b.colorsTexture?this.colorsTexture=b.colorsTexture:this._colors?this.colorsTexture=vU.CreateColorsTexture(`${U.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??lU.DEFAULT_COLOR,vU.PrepareEmptyColorsTexture(this._scene)),this._engine.wb.add((()=>{vU.DisposeEmptyColorsTexture()}))}getAttributes(U){U.push("grl_offsets"),U.push("grl_widths"),U.push("grl_colorPointers"),U.push("grl_counters"),this._cameraFacing?(U.push("grl_previousAndSide"),U.push("grl_nextAndCounters")):U.push("grl_slopes")}getSamplers(U){U.push("grl_colors")}getActiveTextures(U){this.colorsTexture&&U.push(this.colorsTexture)}getUniforms(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const X=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&X.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===U&&X.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:X,vertex:this._cameraFacing&&this._isGLSL(U)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(U)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(U){if(this._cameraFacing){U.Ib("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||U.Ib("viewProjection",this._scene.getTransformMatrix());const X=F.TmpVectors.Vector4[0];X.x=this._aspect,X.y=this._resolution.x,X.z=this._resolution.y,X.w=this.width,U.updateVector4("grl_aspect_resolution_lineWidth",X)}const X=F.TmpVectors.Vector4[0];X.x=vU.BooleanToNumber(this.useDash),X.y=this._dashArray,X.z=this.dashOffset,X.w=this.dashRatio,U.updateVector4("grl_dashOptions",X);const b=F.TmpVectors.Vector4[1];b.x=this.colorMode,b.y=this.visibility,b.z=this.colorsTexture?this.colorsTexture.getSize().width:0,b.w=vU.BooleanToNumber(this.useColors),U.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",b),this._color&&U.updateColor3("grl_singleColor",this._color);const E=this.colorsTexture??lU.EmptyColorsTexture;U.setTexture("grl_colors",E),U.updateFloat2("grl_textureSize",(null===E||void 0===E?void 0:E.getSize().width)??1,(null===E||void 0===E?void 0:E.getSize().height)??1)}prepareDefines(U,X,b){U.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,U.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,U.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,U.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=X.useRightHandedSystem,U.GREASED_LINE_CAMERA_FACING=this._cameraFacing,U.GREASED_LINE_USE_OFFSETS=!!b.offsets}getClassName(){return sU.GREASED_LINE_MATERIAL_NAME}getCustomCode(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(X)?function(U,X){if("vertex"===U){const U={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return X&&(U["!gl_Position\\=viewProjection\\*worldPos;"]="//"),U}return"fragment"===U?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(U,this._cameraFacing):function(U,X){if("vertex"===U){const U={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return X&&(U["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),U}return"fragment"===U?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(U,this._cameraFacing)}dispose(){var U;null===(U=this.colorsTexture)||void 0===U||U.dispose(),super.dispose()}get dU(){return this._colors}set dU(U){this.setColors(U)}setColors(U){var X;let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],F=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(X=this._colors)||void 0===X?void 0:X.length)??0;var w;if(this._colors=U,null!==U&&0!==U.length){if(!b||F)if(this.colorsTexture&&E===U.length&&!F){const X=vU.Color3toRGBAUint8(U);this.colorsTexture.update(X)}else{var Q;null===(Q=this.colorsTexture)||void 0===Q||Q.dispose(),this.colorsTexture=vU.CreateColorsTexture(`${this._material.name}-colors-texture`,U,this.colorsSampling,this._scene)}}else null===(w=this.colorsTexture)||void 0===w||w.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(U){this._dashCount=U,this._dashArray=1/U}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(U){this._sizeAttenuation=U,this.markAllDefinesAsDirty()}get color(){return this._color}set color(U){this.setColor(U)}setColor(U){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==U||null!==this._color&&null===U?(this._color=U,X||this.markAllDefinesAsDirty()):this._color=U}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(U){this._colorsDistributionType=U,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(U){this._aspect=U.x/U.y,this._resolution=U}serialize(){const U=super.serialize(),X={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(X.dU=this._colors),this._color&&(X.color=this._color),U.greasedLineMaterialOptions=X,U}parse(U,X,b){var F;super.parse(U,X,b);const E=U.greasedLineMaterialOptions;null===(F=this.colorsTexture)||void 0===F||F.dispose(),E.color&&this.setColor(E.color,!0),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.dU&&(this.dU=E.dU),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),this.dU?this.colorsTexture=vU.CreateColorsTexture(`${this._material.name}-colors-texture`,this.dU,this.colorsSampling,X):vU.PrepareEmptyColorsTexture(X),this.markAllDefinesAsDirty()}copyTo(U){var X;const b=U;null===(X=b.colorsTexture)||void 0===X||X.dispose(),this._colors&&(b.colorsTexture=vU.CreateColorsTexture(`${b._material.name}-colors-texture`,this._colors,b.colorsSampling,this._scene)),b.setColor(this.color,!0),b.colorsDistributionType=this.colorsDistributionType,b.colorsSampling=this.colorsSampling,b.colorMode=this.colorMode,b.useColors=this.useColors,b.visibility=this.visibility,b.useDash=this.useDash,b.dashCount=this.dashCount,b.dashRatio=this.dashRatio,b.dashOffset=this.dashOffset,b.width=this.width,b.sizeAttenuation=this.sizeAttenuation,b.resolution=this.resolution,b.markAllDefinesAsDirty()}_isGLSL(U){return 0===U||this._forceGLSL}}sU.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",sU.ForceGLSL=!1,(0,eU.f)(`BABYLON.${sU.GREASED_LINE_MATERIAL_NAME}`,sU);var hU=b(12047),BU=b(11416),oU=b(11826),yU=b(11535);class tU extends oU.ShaderMaterial{constructor(U,X,E){const w=X.getEngine(),Q=w.isWebGPU&&!(E.forceGLSL||tU.ForceGLSL),z=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];X.useRightHandedSystem&&z.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const q=["position","grl_widths","grl_offsets","grl_colorPointers"];E.cameraFacing?(z.push("GREASED_LINE_CAMERA_FACING"),q.push("grl_previousAndSide","grl_nextAndCounters")):(q.push("grl_slopes"),q.push("grl_counters"));const p=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(Q||p.push("world","viewProjection","view","projection"),super(U,X,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:Q?["Scene","Mesh"]:void 0,attributes:q,uniforms:p,samplers:Q?[]:["grlColors"],defines:z,extraInitializationsAsync:async()=>{Q?await Promise.all([b.e(66).then(b.bind(b,14746)),b.e(75).then(b.bind(b,14748))]):await Promise.all([b.e(69).then(b.bind(b,14752)),b.e(76).then(b.bind(b,14759))])},shaderLanguage:Q?1:0}),this._color=x.NX.White(),this._colorsDistributionType=0,this._colorsTexture=null,E=E||{color:lU.DEFAULT_COLOR},this.visibility=E.visibility??1,this.useDash=E.useDash??!1,this.dashRatio=E.dashRatio??.5,this.dashOffset=E.dashOffset??0,this.dashCount=E.dashCount??1,this.width=E.width?E.width:E.sizeAttenuation&&E.cameraFacing?lU.DEFAULT_WIDTH_ATTENUATED:lU.DEFAULT_WIDTH,this.sizeAttenuation=E.sizeAttenuation??!1,this.color=E.color??x.NX.White(),this.useColors=E.useColors??!1,this.colorsDistributionType=E.colorDistributionType??0,this.colorsSampling=E.colorsSampling??P.d.NEAREST_NEAREST,this.colorMode=E.colorMode??0,this._colors=E.dU??null,this._cameraFacing=E.cameraFacing??!0,this.resolution=E.resolution??new F.Vector2(w.getRenderWidth(),w.getRenderHeight()),E.colorsTexture?this.colorsTexture=E.colorsTexture:this._colors?this.colorsTexture=vU.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,X):(this._color=this._color??lU.DEFAULT_COLOR,this.colorsTexture=vU.PrepareEmptyColorsTexture(X)),Q){const U=new yU.e;U.setParameters(),U.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",U)}w.wb.add((()=>{vU.DisposeEmptyColorsTexture()}))}dispose(){var U;null===(U=this._colorsTexture)||void 0===U||U.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new F.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dU(){return this._colors}set dU(U){this.setColors(U)}setColors(U){var X;let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],F=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(X=this._colors)||void 0===X?void 0:X.length)??0;var w;if(this._colors=U,null!==U&&0!==U.length){if(!b||F)if(this._colorsTexture&&E===U.length&&!F){const X=vU.Color3toRGBAUint8(U);this._colorsTexture.update(X)}else{var Q;null===(Q=this._colorsTexture)||void 0===Q||Q.dispose(),this.colorsTexture=vU.CreateColorsTexture(`${this.name}-colors-texture`,U,this.colorsSampling,this.fU())}}else null===(w=this._colorsTexture)||void 0===w||w.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(U){this._colorsTexture=U,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(U){this._width=U,this.setFloat("grlWidth",U)}get useColors(){return this._useColors}set useColors(U){this._useColors=U,this.setFloat("grlUseColors",vU.BooleanToNumber(U))}get colorsSampling(){return this._colorsSampling}set colorsSampling(U){this._colorsSampling=U}get visibility(){return this._visibility}set visibility(U){this._visibility=U,this.setFloat("grlVisibility",U)}get useDash(){return this._useDash}set useDash(U){this._useDash=U,this.setFloat("grlUseDash",vU.BooleanToNumber(U))}get dashOffset(){return this._dashOffset}set dashOffset(U){this._dashOffset=U,this.setFloat("grlDashOffset",U)}get dashRatio(){return this._dashRatio}set dashRatio(U){this._dashRatio=U,this.setFloat("grlDashRatio",U)}get dashCount(){return this._dashCount}set dashCount(U){this._dashCount=U,this._dashArray=1/U,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(U){this._sizeAttenuation=U,this.setFloat("grlSizeAttenuation",vU.BooleanToNumber(U))}get color(){return this._color}set color(U){this.setColor(U)}setColor(U){U=U??lU.DEFAULT_COLOR,this._color=U,this.setColor3("grlColor",U)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(U){this._colorsDistributionType=U,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(U){this._colorMode=U,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(U){this._resolution=U,this.setVector2("grlResolution",U),this.setFloat("grlAspect",U.x/U.y)}serialize(){const U=super.serialize(),X={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(X.dU=this._colors),U.greasedLineMaterialOptions=X,U}parse(U,X,b){var F;const E=U.greasedLineMaterialOptions;null===(F=this._colorsTexture)||void 0===F||F.dispose(),E.color&&(this.color=E.color),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),E.dU?this.colorsTexture=vU.CreateColorsTexture(`${this.name}-colors-texture`,E.dU,this.colorsSampling,this.fU()):this.colorsTexture=vU.PrepareEmptyColorsTexture(X),this._cameraFacing=E.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var WU,YU,KU;tU.ForceGLSL=!1,function(U){U[U.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",U[U.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(WU||(WU={})),function(U){U[U.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",U[U.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",U[U.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(YU||(YU={})),function(U){U[U.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",U[U.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",U[U.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",U[U.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",U[U.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(KU||(KU={}));class VU extends OU.e{constructor(U,X,b){super(U,X,null,null,!1,!1),this.name=U,this._options=b,this._lazy=!1,this._updatable=!1,this._engine=X.getEngine(),this._lazy=b.lazy??!1,this._updatable=b.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=b.colorPointers??[],this._widths=b.widths??new Array(b.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(U){let X=0;for(const F of this._points)X+=F.length;const b=X/3*2-this._widths.length;for(let F=0;F<b;F++)this._widths.push(U)}updateLazy(){var U,X;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(U=this._options.ribbonOptions)||void 0===U?void 0:U.smoothShading),!this.sU&&this.refreshBoundingInfo(),null===(X=this.greasedLineMaterial)||void 0===X||X.updateLazy()}addPoints(U,X){for(const b of U)this._points.push(b);this._lazy||this.setPoints(this._points,X)}dispose(U){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(U,X)}isLazy(){return this._lazy}get kU(){return this._uvs}set kU(U){this._uvs=U instanceof Float32Array?U:new Float32Array(U),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(U){this.material instanceof tU&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===U||void 0===U?void 0:U.length)>0),this._offsets=U,this._offsetsBuffer?this._offsetsBuffer.update(U):this._createOffsetsBuffer(U)}get widths(){return this._widths}set widths(U){this._widths=U,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(U)}get colorPointers(){return this._colorPointers}set colorPointers(U){this._colorPointers=U,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(U)}get greasedLineMaterial(){var U,X;if(this.material&&this.material instanceof tU)return this.material;const b=null===(U=this.material)||void 0===U||null===(X=U.pluginManager)||void 0===X?void 0:X.getPlugin(sU.GREASED_LINE_MATERIAL_NAME);return b||void 0}get points(){const U=[];return BU.d.DeepCopy(this._points,U),U}setPoints(U,X){this._points=vU.ConvertPoints(U,(null===X||void 0===X?void 0:X.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==X&&void 0!==X&&X.colorPointers||this._updateColorPointers(),this._setPoints(this._points,X)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,kU:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(U){super.serialize(U),U.type=this.getClassName(),U.lineOptions=this._createLineOptions()}_createVertexBuffers(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=new hU.d;return X.eU=this._vertexPositions,X.indices=this._indices,X.kU=this._uvs,U&&(X.lU=[],hU.d.ComputeNormals(this._vertexPositions,this._indices,X.lU)),X.AU(this,this._options.updatable),X}_createOffsetsBuffer(U){const X=this._scene.getEngine(),b=new S.d(X,U,this._updatable,3);this.setVerticesBuffer(b.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=b}}class gU{constructor(U,X){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=U,this.wasAddedByNoopNode=X}getIndicesAccessor(U,X,b,F,E){var w,Q,z,q;return null===(w=this._indicesAccessorMap.get(U))||void 0===w||null===(Q=w.get(X))||void 0===Q||null===(z=Q.get(b))||void 0===z||null===(q=z.get(F))||void 0===q?void 0:q.get(E)}setIndicesAccessor(U,X,b,F,E,w){let Q=this._indicesAccessorMap.get(U);Q||(Q=new Map,this._indicesAccessorMap.set(U,Q));let z=Q.get(X);z||(z=new Map,Q.set(X,z));let q=z.get(b);q||(q=new Map,z.set(b,q));let p=q.get(F);p||(p=new Map,q.set(F,p)),p.set(E,w)}pushExportedNode(U){this._exportedNodes.has(U)||this._exportedNodes.add(U)}getNodesSet(){return this._exportedNodes}getVertexBufferView(U){return this._vertexBufferViewMap.get(U)}setVertexBufferView(U,X){this._vertexBufferViewMap.set(U,X)}setRemappedBufferView(U,X,b){this._remappedBufferView.set(U,new Map),this._remappedBufferView.get(U).set(X,b)}getRemappedBufferView(U,X){var b;return null===(b=this._remappedBufferView.get(U))||void 0===b?void 0:b.get(X)}getVertexAccessor(U,X,b){var F,E;return null===(F=this._vertexAccessorMap.get(U))||void 0===F||null===(E=F.get(X))||void 0===E?void 0:E.get(b)}setVertexAccessor(U,X,b,F){let E=this._vertexAccessorMap.get(U);E||(E=new Map,this._vertexAccessorMap.set(U,E));let w=E.get(X);w||(w=new Map,E.set(X,w)),w.set(b,F)}hasVertexColorAlpha(U){return this._vertexMapColorAlpha.get(U)||!1}setHasVertexColorAlpha(U,X){return this._vertexMapColorAlpha.set(U,X)}getMesh(U){return this._meshMap.get(U)}setMesh(U,X){this._meshMap.set(U,X)}bindMorphDataToMesh(U,X){const b=this._meshMorphTargetMap.get(U)||[];this._meshMorphTargetMap.set(U,b),-1===b.indexOf(X)&&b.push(X)}getMorphTargetsFromMesh(U){return this._meshMorphTargetMap.get(U)}}class LU{_ApplyExtension(U,X,b,F){if(b>=X.length)return Promise.resolve(U);const E=F(X[b],U);return E?E.then((async U=>U?await this._ApplyExtension(U,X,b+1,F):null)):this._ApplyExtension(U,X,b+1,F)}_ApplyExtensions(U,X){const b=[];for(const F of LU._ExtensionNames)b.push(this._extensions[F]);return this._ApplyExtension(U,b,0,X)}_extensionsPreExportTextureAsync(U,X,b){return this._ApplyExtensions(X,((X,F)=>X.preExportTextureAsync&&X.preExportTextureAsync(U,F,b)))}_extensionsPostExportNodeAsync(U,X,b,F,E){return this._ApplyExtensions(X,((X,w)=>X.postExportNodeAsync&&X.postExportNodeAsync(U,w,b,F,E,this._bufferManager)))}_extensionsPostExportMaterialAsync(U,X,b){return this._ApplyExtensions(X,((X,F)=>X.postExportMaterialAsync&&X.postExportMaterialAsync(U,F,b)))}_extensionsPostExportMaterialAdditionalTextures(U,X,b){const F=[];for(const E of LU._ExtensionNames){const w=this._extensions[E];w.postExportMaterialAdditionalTextures&&F.push(...w.postExportMaterialAdditionalTextures(U,X,b))}return F}_extensionsPostExportTextures(U,X,b){for(const F of LU._ExtensionNames){const E=this._extensions[F];E.postExportTexture&&E.postExportTexture(U,X,b)}}_extensionsPostExportMeshPrimitive(U){for(const X of LU._ExtensionNames){const b=this._extensions[X];b.postExportMeshPrimitive&&b.postExportMeshPrimitive(U,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const U of LU._ExtensionNames){const X=this._extensions[U];X.preGenerateBinaryAsync&&await X.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(U){for(const X of LU._ExtensionNames){const b=this._extensions[X];b.enabled&&U(b)}}_extensionsOnExporting(){this._forEachExtensions((U=>{var X,b,F;U.wasUsed&&((X=this._glTF).extensionsUsed||(X.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(U.name)&&this._glTF.extensionsUsed.push(U.name),U.required&&((b=this._glTF).extensionsRequired||(b.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(U.name)&&this._glTF.extensionsRequired.push(U.name)),(F=this._glTF).extensions||(F.extensions={}),U.onExporting&&U.onExporting())}))}_loadExtensions(){for(const U of LU._ExtensionNames){const X=LU._ExtensionFactories[U](this);this._extensions[U]=X}}constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m.c.LastCreatedScene,X=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${J.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new y(this),this._extensions={},this._bufferManager=new SU,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!U)throw new Error("No scene available to export");this._babylonScene=U,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:U=>{var X;return null===U||void 0===U||null===(X=U.Sb)||void 0===X?void 0:X.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...X},this._loadExtensions()}dispose(){for(const U in this._extensions){this._extensions[U].dispose()}}get options(){return this._options}static RegisterExtension(U,X){LU.UnregisterExtension(U)&&E.Tools.Warn(`Extension with the name ${U} already exists`),LU._ExtensionFactories[U]=X,LU._ExtensionNames.push(U)}static UnregisterExtension(U){if(!LU._ExtensionFactories[U])return!1;delete LU._ExtensionFactories[U];const X=LU._ExtensionNames.indexOf(U);return-1!==X&&LU._ExtensionNames.splice(X,1),!0}_generateJSON(U,X,b){const F={byteLength:U};return F.byteLength&&(this._glTF.buffers=[F]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.xX=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(F.uri=X+".bin"),b?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(U){const X=await this._generateBinaryAsync();this._extensionsOnExporting();const b=this._generateJSON(X.byteLength,U,!0),F=new Blob([X],{type:"application/octet-stream"}),E=U+".gltf",w=U+".bin",Q=new p;if(Q.files[E]=b,Q.files[w]=F,this._imageData)for(const z in this._imageData)Q.files[z]=new Blob([this._imageData[z].data],{type:this._imageData[z].mimeType});return Q}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(U){const X=U%4;return 0===X?X:4-X}async generateGLBAsync(U){this._shouldUseGlb=!0;const X=await this._generateBinaryAsync();this._extensionsOnExporting();const b=this._generateJSON(X.byteLength),F=U+".glb";let E,w=b.length;if("undefined"!==typeof TextEncoder){E=(new TextEncoder).encode(b),w=E.length}const Q=this._getPadding(w),z=this._getPadding(X.byteLength),q=28+w+Q+X.byteLength+z,S=new qU(q);if(S.writeUInt32(1179937895),S.writeUInt32(2),S.writeUInt32(q),S.writeUInt32(w+Q),S.writeUInt32(1313821514),E)S.writeTypedArray(E);else{const U="_".charCodeAt(0);for(let X=0;X<w;++X){const F=b.charCodeAt(X);F!=b.codePointAt(X)?S.writeUInt8(U):S.writeUInt8(F)}}for(let p=0;p<Q;++p)S.writeUInt8(32);S.writeUInt32(X.byteLength+z),S.writeUInt32(5130562),S.writeTypedArray(X);for(let p=0;p<z;++p)S.writeUInt8(0);const R=new p;return R.files[F]=new Blob([S.getOutputData()],{type:"application/octet-stream"}),R}_setNodeTransformation(U,X,b){if(X.getPivotPoint().equalsWithEpsilon(V,K.d)||E.Tools.Warn("Pivot points are not supported in the glTF serializer"),!X.position.equalsWithEpsilon(V,K.d)){const E=F.TmpVectors.JX[0].q(X.position);b&&H(E),U.translation=E.Jb()}X.fb.equalsWithEpsilon(L,K.d)||(U.scale=X.fb.Jb());const w=X.rotationQuaternion||F.Quaternion.FromEulerAngles(X.rotation.x,X.rotation.y,X.rotation.z);w.equalsWithEpsilon(g,K.d)||(b&&T(w),U.rotation=w.normalize().Jb())}_setCameraTransformation(U,X,b){if(!X.position.equalsWithEpsilon(V,K.d)){const E=F.TmpVectors.JX[0].q(X.position);b&&H(E),U.translation=E.Jb()}const E=X.rotationQuaternion||F.Quaternion.FromEulerAngles(X.rotation.x,X.rotation.y,X.rotation.z);b&&T(E),this._babylonScene.useRightHandedSystem||C(E),E.equalsWithEpsilon(g,K.d)||(U.rotation=E.Jb())}_listAvailableCameras(){for(const U of this._babylonScene.cameras){const X={type:U.mode===nU.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(U.name&&(X.name=U.name),"perspective"===X.type)X.perspective={aspectRatio:U.getEngine().getAspectRatio(U),yfov:U.fovMode===nU.e.FOVMODE_VERTICAL_FIXED?U.fov:U.fov*U.getEngine().getAspectRatio(U),znear:U.xb,zfar:U.maxZ};else if("orthographic"===X.type){const b=U.orthoLeft&&U.orthoRight?.5*(U.orthoRight-U.orthoLeft):.5*U.getEngine().getRenderWidth(),F=U.orthoBottom&&U.orthoTop?.5*(U.orthoTop-U.orthoBottom):.5*U.getEngine().getRenderHeight();X.orthographic={xmag:b,ymag:F,znear:U.xb,zfar:U.maxZ}}this._camerasMap.set(U,X)}}_exportAndAssignCameras(){const U=Array.from(this._camerasMap.values());for(const X of U){const U=this._nodesCameraMap.get(X);if(void 0!==U){this._cameras.push(X);for(const X of U)X.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const U of this._babylonScene.skeletons){if(U.bones.length<=0)continue;const X={joints:[]};this._skinMap.set(U,X)}}_exportAndAssignSkeletons(){for(const U of this._babylonScene.skeletons){if(U.bones.length<=0)continue;const X=this._skinMap.get(U);if(void 0==X)continue;const b={},F=[];let w=-1;for(let E=0;E<U.bones.length;++E){const X=U.bones[E],F=X.getIndex()??E;-1!==F&&(b[F]=X,F>w&&(w=F))}for(let U=0;U<=w;++U){const w=b[U];F.push(w.getAbsoluteInverseBindMatrix());const Q=w.getTransformNode();if(null!==Q){const U=this._nodeMap.get(Q);Q&&null!==U&&void 0!==U?X.joints.push(U):E.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else E.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const Q=this._nodesSkinMap.get(X);if(X.joints.length>0&&void 0!==Q){const U=64*F.length,b=new Float32Array(U/4);F.forEach(((U,X)=>{b.set(U.m,16*X)}));const E=this._bufferManager.createBufferView(b);this._accessors.push(this._bufferManager.createAccessor(E,"MAT4",5126,F.length)),X.inverseBindMatrices=this._accessors.length-1,this._skins.push(X);for(const X of Q)X.skin=this._skins.length-1}}}async _exportSceneAsync(){const U={nodes:[]};if(this._babylonScene.metadata){const X=this._options.metadataSelector(this._babylonScene.metadata);X&&(U.extras=X)}const X=new Array,b=new Array,F=new Array;for(const z of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&QU(z,this._babylonScene.useRightHandedSystem)?F.push(...z.getChildren()):this._babylonScene.useRightHandedSystem?X.push(z):b.push(z);this._listAvailableCameras(),this._listAvailableSkeletons();const E=new gU(!0,!1);U.nodes.push(...await this._exportNodesAsync(b,E));const w=new gU(!1,!1);U.nodes.push(...await this._exportNodesAsync(X,w));const Q=new gU(!1,!0);U.nodes.push(...await this._exportNodesAsync(F,Q)),U.nodes.length&&this._scenes.push(U),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&uU._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,E.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(U){let X=this._shouldExportNodeMap.get(U);return void 0===X&&(X=this._options.shouldExportNode(U),this._shouldExportNodeMap.set(U,X)),X}async _exportNodesAsync(U,X){const b=new Array;this._exportBuffers(U,X);for(const F of U)await this._exportNodeAsync(F,b,X);return b}_collectBuffers(U,X,b,F,E){if(this._shouldExportNode(U)&&U instanceof n.b&&U.Nb){const w=U.Nb.getVertexBuffers();if(w)for(const F in w){if(!c(F))continue;const Q=w[F];E.setHasVertexColorAlpha(Q,U.hasVertexAlpha);const z=Q._buffer,q=X.get(z)||[];X.set(z,q),-1===q.indexOf(Q)&&q.push(Q);const p=b.get(Q)||[];b.set(Q,p),-1===p.indexOf(U)&&p.push(U)}const Q=U.morphTargetManager;if(Q)for(let X=0;X<Q.numTargets;X++){const b=Q.getTarget(X),E=F.get(b)||[];F.set(b,E),-1===E.indexOf(U)&&E.push(U)}}for(const w of U.getChildren())this._collectBuffers(w,X,b,F,E)}_exportBuffers(U,X){const b=new Map,F=new Map,E=new Map;for(const z of U)this._collectBuffers(z,b,F,E,X);const w=Array.from(b.keys());for(const z of w){const U=z.getData();if(!U)throw new Error("Buffer data is not available");const E=b.get(z);if(!E)continue;const w=E[0].byteStride;if(E.some((U=>U.byteStride!==w)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const Q=bU(U).slice();for(const X of E){const U=F.get(X),{byteOffset:b,byteStride:E,componentCount:w,type:z,count:q,normalized:p,kind:R}=G(X,U);switch(R){case S.h.NormalKind:case S.h.TangentKind:(0,t.j)(Q,b,E,w,z,q,p,(U=>{const X=Math.sqrt(U[0]*U[0]+U[1]*U[1]+U[2]*U[2]);if(X>0){const b=1/X;U[0]*=b,U[1]*=b,U[2]*=b}}));break;case S.h.ColorKind:{const X=U.filter((U=>U.material instanceof mU.OX||null==U.material)).length;if(0==X)break;if(X!=U.length){W.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}z==S.h.UNSIGNED_BYTE&&W.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const F=new x.NX,R=new x.eb,n=this._babylonScene.getEngine().useExactSrgbConversions;(0,t.j)(Q,b,E,w,z,q,p,(U=>{3===U.length?(F.qF(U,0),F.toLinearSpaceToRef(F,n),F.toArray(U,0)):(R.qF(U,0),R.toLinearSpaceToRef(R,n),R.toArray(U,0))}))}}}if(X.convertToRightHanded){for(const U of E){const X=F.get(U),{byteOffset:b,byteStride:E,componentCount:w,type:z,count:q,normalized:p,kind:R}=G(U,X);switch(R){case S.h.PositionKind:case S.h.NormalKind:case S.h.TangentKind:(0,t.j)(Q,b,E,w,z,q,p,(U=>{U[0]=-U[0]}))}}X.convertedToRightHandedBuffers.set(z,Q)}const q=this._bufferManager.createBufferView(Q,w);X.setVertexBufferView(z,q);const p=new Map;for(const X of E){const U=F.get(X),{kind:b,totalVertices:E}=G(X,U);switch(b){case S.h.MatricesIndicesKind:case S.h.MatricesIndicesExtraKind:if(X.type==S.h.FLOAT){const U=X.getFloatData(E);null!==U&&p.set(X,U)}}}0!==p.size&&W.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const R=Array.from(p.keys());for(const b of R){const U=p.get(b);if(!U)continue;const F=U.some((U=>U>=256)),E=new(F?Uint16Array:Uint8Array)(U.length);for(let X=0;X<U.length;X++)E[X]=U[X];const w=this._bufferManager.createBufferView(E,4*(F?2:1));X.setRemappedBufferView(z,b,w)}}const Q=Array.from(E.keys());for(const z of Q){const U=E.get(z);if(!U)continue;const b=iU(z,U[0],this._bufferManager,this._bufferViews,this._accessors,X.convertToRightHanded);for(const F of U)X.bindMorphDataToMesh(F,b)}}async _exportNodeAsync(U,X,b){let F=this._nodeMap.get(U);if(void 0!==F)return void(X.includes(F)||X.push(F));const E=await this._createNodeAsync(U,b);if(E){F=this._nodes.length,this._nodes.push(E),this._nodeMap.set(U,F),b.pushExportedNode(U),X.push(F);const w={name:"runtime animations",channels:[],samplers:[]},Q=[];this._babylonScene.animationGroups.length||(uU._CreateMorphTargetAnimationFromMorphTargetAnimations(U,w,Q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,b.convertToRightHanded,this._options.shouldExportAnimation),U.animations.length&&uU._CreateNodeAnimationFromNodeAnimations(U,w,Q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,b.convertToRightHanded,this._options.shouldExportAnimation)),w.channels.length&&w.samplers.length&&this._animations.push(w),Q.forEach((U=>{U.channels.length&&U.samplers.length&&this._animations.push(U)}))}const w=E?[]:X;for(const Q of U.getChildren())await this._exportNodeAsync(Q,w,b);E&&w.length&&(E.children=w)}async _createNodeAsync(U,X){if(!this._shouldExportNode(U))return null;const b={};if(U.name&&(b.name=U.name),U.metadata){const X=this._options.metadataSelector(U.metadata);X&&(b.extras=X)}if(U instanceof R.c&&(this._setNodeTransformation(b,U,X.convertToRightHanded),U instanceof n.b)){const E=U instanceof a.c?U.sourceMesh:U;if(E.ab&&E.ab.length>0&&(b.mesh=await this._exportMeshAsync(E,X)),U.skeleton){const X=this._skinMap.get(U.skeleton);var F;if(void 0!==X)void 0===this._nodesSkinMap.get(X)&&this._nodesSkinMap.set(X,[]),null===(F=this._nodesSkinMap.get(X))||void 0===F||F.push(b)}}if(U instanceof Y.e){const F=this._camerasMap.get(U);if(F){var E;void 0===this._nodesCameraMap.get(F)&&this._nodesCameraMap.set(F,[]),this._setCameraTransformation(b,U,X.convertToRightHanded);const Q=U.parent;if(null!==Q&&XU(U,Q)){const U=this._nodeMap.get(Q);if(void 0!==U){var w;const X=this._nodes[U];return UU(b,X),null===(w=this._nodesCameraMap.get(F))||void 0===w||w.push(X),null}}null===(E=this._nodesCameraMap.get(F))||void 0===E||E.push(b)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",b,U,this._nodeMap,X.convertToRightHanded)?b:(W.e.Warn(`Not exporting node ${U.name}`),null)}_exportIndices(U,X,b,F,E,Q,z,q,p){let S=U;p.mode=r(Q);const R=z!==w.e.CounterClockWiseSideOrientation,n=!q.wasAddedByNoopNode&&R,a=function(U){switch(U){case w.e.TriangleFillMode:case w.e.TriangleStripDrawMode:case w.e.TriangleFanDrawMode:return!0}return!1}(Q)&&n;if(a){if(Q===w.e.TriangleStripDrawMode||Q===w.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");p.mode=r(Q);const z=X?new Uint32Array(F):new Uint16Array(F);if(U)for(let X=0;X+2<F;X+=3)z[X]=U[b+X]+E,z[X+1]=U[b+X+2]+E,z[X+2]=U[b+X+1]+E;else for(let U=0;U+2<F;U+=3)z[U]=U,z[U+1]=U+2,z[U+2]=U+1;S=z}else if(U&&0!==E){const w=X?new Uint32Array(F):new Uint16Array(F);for(let X=0;X<F;X++)w[X]=U[b+X]+E;S=w}if(S){let w=q.getIndicesAccessor(U,b,F,E,a);if(void 0===w){const Q=function(U,X,b,F){if(U instanceof Uint16Array||U instanceof Uint32Array)return U;if(U instanceof Int32Array)return new Uint32Array(U.buffer,U.byteOffset,U.length);const E=U.slice(X,X+b);return F?new Uint32Array(E):new Uint16Array(E)}(S,0,F,X),z=this._bufferManager.createBufferView(Q),p=X?5125:5123;this._accessors.push(this._bufferManager.createAccessor(z,"SCALAR",p,F,0)),w=this._accessors.length-1,q.setIndicesAccessor(U,b,F,E,a,w)}p.indices=w}}_exportVertexBuffer(U,X,b,F,E,w){const Q=U.getKind();if(!c(Q))return;if(Q.startsWith("uv")&&!this._options.exportUnusedUVs&&(!X||!this._materialNeedsUVsSet.has(X)))return;let z=E.getVertexAccessor(U,b,F);if(void 0===z){const X=E.convertedToRightHandedBuffers.get(U._buffer)||U._buffer.getData(),w=Q===S.h.PositionKind?function(U,X,b,F){const{byteOffset:E,byteStride:w,type:Q,normalized:z}=X,q=X.getSize(),p=new Array(q).fill(1/0),S=new Array(q).fill(-1/0);return(0,t.j)(U,E+b*w,w,q,Q,F*q,z,(U=>{for(let X=0;X<q;X++)p[X]=Math.min(p[X],U[X]),S[X]=Math.max(S[X],U[X])})),{min:p,max:S}}(X,U,b,F):void 0,q=(Q===S.h.MatricesIndicesKind||Q===S.h.MatricesIndicesExtraKind)&&U.type===S.h.FLOAT,p=q?S.h.UNSIGNED_BYTE:U.type,R=q?void 0:U.normalized,n=q?E.getRemappedBufferView(U._buffer,U):E.getVertexBufferView(U._buffer),a=U.byteOffset+b*U.byteStride;this._accessors.push(this._bufferManager.createAccessor(n,function(U,X){if(U==S.h.ColorKind)return X?"VEC4":"VEC3";switch(U){case S.h.PositionKind:case S.h.NormalKind:return"VEC3";case S.h.TangentKind:case S.h.MatricesIndicesKind:case S.h.MatricesIndicesExtraKind:case S.h.MatricesWeightsKind:case S.h.MatricesWeightsExtraKind:return"VEC4";case S.h.UVKind:case S.h.UV2Kind:case S.h.UV3Kind:case S.h.UV4Kind:case S.h.UV5Kind:case S.h.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${U}`)}(Q,E.hasVertexColorAlpha(U)),p,F,a,w,R)),z=this._accessors.length-1,E.setVertexAccessor(U,b,F,z)}w.attributes[function(U){switch(U){case S.h.PositionKind:return"POSITION";case S.h.NormalKind:return"NORMAL";case S.h.TangentKind:return"TANGENT";case S.h.ColorKind:return"COLOR_0";case S.h.UVKind:return"TEXCOORD_0";case S.h.UV2Kind:return"TEXCOORD_1";case S.h.UV3Kind:return"TEXCOORD_2";case S.h.UV4Kind:return"TEXCOORD_3";case S.h.UV5Kind:return"TEXCOORD_4";case S.h.UV6Kind:return"TEXCOORD_5";case S.h.MatricesIndicesKind:return"JOINTS_0";case S.h.MatricesIndicesExtraKind:return"JOINTS_1";case S.h.MatricesWeightsKind:return"WEIGHTS_0";case S.h.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${U}`)}(Q)]=z}async _exportMaterialAsync(U,X,b,F){let E=this._materialMap.get(U);if(void 0===E){const F=X&&Object.keys(X).some((U=>U.startsWith("uv")));if((U=U instanceof aU.b?U.lb[b.materialIndex]:U)instanceof JU.b)E=await this._materialExporter.exportPBRMaterialAsync(U,"image/png",F);else{if(!(U instanceof mU.OX))return void W.e.Warn(`Unsupported material '${U.name}' with type ${U.getClassName()}`);E=await this._materialExporter.exportStandardMaterialAsync(U,"image/png",F)}this._materialMap.set(U,E)}F.material=E}async _exportMeshAsync(U,X){var b;let F=X.getMesh(U);if(void 0!==F)return F;const E={primitives:[]};F=this._meshes.length,this._meshes.push(E),X.setMesh(U,F);const Q=U.isUnIndexed?null:U.ub(),z=null===(b=U.Nb)||void 0===b?void 0:b.getVertexBuffers(),q=X.getMorphTargetsFromMesh(U),p=U instanceof PU.e,S=U instanceof VU,R=U.ab;if(z&&R&&R.length>0)for(const J of R){const b={attributes:{}},F=J.yU()||this._babylonScene.defaultMaterial;if(S){var n,a;const X={name:F.name},E=U,w=x.NX.White(),Q=(null===(n=E.material)||void 0===n?void 0:n.alpha)??1,z=(null===(a=E.greasedLineMaterial)||void 0===a?void 0:a.color)??w;(!z.equalsWithEpsilon(w,K.d)||Q<1)&&(X.pbrMetallicRoughness={baseColorFactor:[...z.Jb(),Q]}),this._materials.push(X),b.material=this._materials.length-1}else if(p){const X={name:F.name},E=U;(!E.color.equalsWithEpsilon(x.NX.White(),K.d)||E.alpha<1)&&(X.pbrMetallicRoughness={baseColorFactor:[...E.color.Jb(),E.alpha]}),this._materials.push(X),b.material=this._materials.length-1}else await this._exportMaterialAsync(F,z,J,b);const R=p||S?w.e.LineListDrawMode:U.overrideRenderingFillMode??F.fillMode,m=F._getEffectiveOrientation(U);this._exportIndices(Q,Q?(0,t.e)(Q,J.indexCount,J.indexStart,J.verticesStart):J.verticesCount>65535,Q?J.indexStart:J.verticesStart,Q?J.indexCount:J.verticesCount,-J.verticesStart,R,m,X,b);for(const U of Object.values(z))this._exportVertexBuffer(U,F,J.verticesStart,J.verticesCount,X,b);if(q){b.targets=[];for(const U of q)b.targets.push(U.attributes)}E.primitives.push(b),this._extensionsPostExportMeshPrimitive(b)}if(q){E.weights=[],E.extras||(E.extras={}),E.extras.targetNames=[];for(const U of q)E.weights.push(U.influence),E.extras.targetNames.push(U.name)}return F}}LU._ExtensionNames=new Array,LU._ExtensionFactories={};class DU{static async GLTFAsync(U,X,b){b&&b.exportWithoutWaitingForScene||await U.whenReadyAsync();const F=new LU(U,b),E=await F.generateGLTFAsync(X.replace(/\.[^/.]+$/,""));return F.dispose(),E}static async GLBAsync(U,X,b){b&&b.exportWithoutWaitingForScene||await U.whenReadyAsync();const F=new LU(U,b),E=await F.generateGLBAsync(X.replace(/\.[^/.]+$/,""));return F.dispose(),E}}b(12175);const GU="EXT_mesh_gpu_instancing";class ZU{constructor(U){this.name=GU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(U,X,b,E,w,Q){return await new Promise((U=>{if(X&&b instanceof OU.e&&b.hasThinInstances&&this._exporter){this._wasUsed=!0;const U=F.JX.Zero(),E=F.Quaternion.Identity(),z=F.JX.One(),q=b.thinInstanceGetWorldMatrices(),p=F.TmpVectors.JX[2],S=F.TmpVectors.Quaternion[1],R=F.TmpVectors.JX[3];let n=!1,a=!1,J=!1;const m=new Float32Array(3*b.kb),x=new Float32Array(4*b.kb),I=new Float32Array(3*b.kb);let O=0;for(const X of q)X.decompose(R,S,p),w&&(H(p),T(S)),m.set(p.Jb(),3*O),x.set(S.normalize().Jb(),4*O),I.set(R.Jb(),3*O),n=n||!p.equalsWithEpsilon(U),a=a||!S.equalsWithEpsilon(E),J=J||!R.equalsWithEpsilon(z),O++;const N={attributes:{}};n&&(N.attributes.TRANSLATION=this._buildAccessor(m,"VEC3",b.kb,Q)),a&&(N.attributes.ROTATION=this._buildAccessor(x,"VEC4",b.kb,Q)),J&&(N.attributes.SCALE=this._buildAccessor(I,"VEC3",b.kb,Q)),X.extensions=X.extensions||{},X.extensions[GU]=N}U(X)}))}_buildAccessor(U,X,b,F){const E=F.createBufferView(U),w=F.createAccessor(E,X,5126,b);return this._exporter._accessors.push(w),this._exporter._accessors.length-1}}LU.RegisterExtension(GU,(U=>new ZU(U)));var cU=b(12179),rU=b(12193),MU=b(12200),HU=b(12204);function TU(U){return U===MU.e.PositionKind?"POSITION":U===MU.e.NormalKind?"NORMAL":U===MU.e.ColorKind?"COLOR":U.startsWith(MU.e.UVKind)?"TEX_COORD":"GENERIC"}const CU={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class UX extends cU.b{static get DefaultAvailable(){return(0,cU.f)(UX.DefaultConfiguration)}static get Default(){return UX._Default??(UX._Default=new UX),UX._Default}static ResetDefault(U){UX._Default&&(U||UX._Default.dispose(),UX._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(U,X){return{module:await(X||DracoEncoderModule)({wasmBinary:U})}}_getWorkerContent(){return`${rU.f}(${rU.g})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:UX.DefaultConfiguration)}async _encodeAsync(U,X,b){const F=b?(0,HU.d)(CU,b):CU;if(this._workerPoolPromise){const b=await this._workerPoolPromise;return await new Promise(((E,w)=>{b.push(((b,Q)=>{const z=U=>{b.removeEventListener("error",z),b.removeEventListener("message",q),w(U),Q()},q=U=>{"encodeMeshDone"===U.data.id&&(b.removeEventListener("error",z),b.removeEventListener("message",q),E(U.data.encodedMeshData),Q())};b.addEventListener("error",z),b.addEventListener("message",q);const p=[];for(const X of U)p.push(X.data.buffer);X&&p.push(X.buffer),b.postMessage({id:"encodeMesh",attributes:U,indices:X,options:F},p)}))}))}if(this._modulePromise){const b=await this._modulePromise;return(0,rU.f)(b.module,U,X,F)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(U,X){if(0==U.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");U instanceof OU.e&&U.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===X||void 0===X?void 0:X.method)&&(W.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),X.method="MESH_SEQUENTIAL_ENCODING");const b=function(U){let X=U.ub(void 0,!0);return!X||X instanceof Uint32Array||X instanceof Uint16Array||(X=((0,t.e)(X,X.length)?Uint32Array:Uint16Array).from(X)),X}(U),F=function(U,X){const b=[];for(const F of U.getVerticesDataKinds()){if(null!==X&&void 0!==X&&X.includes(F)){if(F===MU.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const E=U.getVertexBuffer(F),w=E.getSize(),Q=(0,t.s)(E.getData(),w,E.type,E.byteOffset,E.byteStride,E.normalized,U.getTotalVertices(),!0);b.push({kind:F,dracoName:TU(F),size:w,data:Q})}return b}(U,null===X||void 0===X?void 0:X.excludedAttributes);return await this._encodeAsync(F,b,X)}}UX.DefaultConfiguration={wasmUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder.js`},UX._Default=null;const XX="KHR_draco_mesh_compression";class bX{get wasUsed(){return this._wasUsed}constructor(U){this.name=XX,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===U.options.meshCompressionMethod&&UX.DefaultAvailable}dispose(){}postExportMeshPrimitive(U,X,b){if(!this.enabled)return;if(4!==U.mode&&5!==U.mode)return void W.e.Warn("Cannot compress primitive with mode "+U.mode+".");const F=[],E=[];let w=null;if(void 0!==U.indices){const Q=b[U.indices],z=X.getBufferView(Q);w=X.getData(z).slice(),F.push(z),E.push(Q)}const Q=[];for(const[S,R]of Object.entries(U.attributes)){const U=b[R],w=X.getBufferView(U),q=Z(U.type),p=(0,t.s)(X.getData(w),q,U.componentType,U.byteOffset||0,w.byteStride||(0,t.n)(U.componentType)*q,U.normalized||!1,U.count,!0);Q.push({kind:S,dracoName:(z=S,"POSITION"===z?"POSITION":"NORMAL"===z?"NORMAL":z.startsWith("COLOR")?"COLOR":z.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:Z(U.type),data:p}),F.push(w),E.push(U)}var z;const q={method:U.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},p=UX.Default._encodeAsync(Q,w,q).then((b=>{if(!b)return void W.e.Error("Draco encoding failed for primitive.");const w={bufferView:-1,attributes:b.attributeIds},Q=X.createBufferView(b.data);X.setBufferView(w,Q);for(const U of F)this._bufferViewsUsed.add(U);for(const U of E)this._accessorsUsed.add(U);U.extensions||(U.extensions={}),U.extensions[XX]=w})).catch((U=>{W.e.Error("Draco encoding failed for primitive: "+U)}));this._encodePromises.push(p),this._wasUsed=!0}async preGenerateBinaryAsync(U){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((X=>{U.getPropertiesWithBufferView(X).every((U=>this._accessorsUsed.has(U)))&&U.removeBufferView(X)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}LU.RegisterExtension(XX,(U=>new bX(U)));var FX=b(12210);const EX="KHR_lights_punctual",wX={name:"",color:[1,1,1],sb:1,range:Number.MAX_VALUE},QX={innerConeAngle:0,outerConeAngle:Math.PI/4},zX=F.JX.Backward();class qX{constructor(U){this.name=EX,this.enabled=!0,this.required=!1,this._exporter=U}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[EX]=this._lights}async postExportNodeAsync(U,X,b,E,w){return await new Promise((Q=>{if(!(b instanceof NU.c))return void Q(X);const z=b.getTypeID()==NU.c.LIGHTTYPEID_POINTLIGHT?"point":b.getTypeID()==NU.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":b.getTypeID()==NU.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!z||!(b instanceof FX.d))return W.e.Warn(`${U}: Light ${b.name} is not supported in ${EX}`),void Q(X);if(b.falloffType!==NU.c.FALLOFF_GLTF&&W.e.Warn(`${U}: Light falloff for ${b.name} does not match the ${EX} specification!`),!b.position.equalsToFloats(0,0,0)){const U=F.TmpVectors.JX[0].q(b.position);w&&H(U),X.translation=U.Jb()}if("point"!==z){const U=b.direction.normalizeToRef(F.TmpVectors.JX[0]);w&&H(U);const E=F.Quaternion.FromUnitVectorsToRef(zX,U,F.TmpVectors.Quaternion[0]);F.Quaternion.IsIdentity(E)||(X.rotation=E.Jb())}const q={type:z,name:b.name,color:b.hb.Jb(),sb:b.sb,range:b.range};if(FU(q,wX),"spot"===z){const U=b;q.spot={innerConeAngle:U.innerAngle/2,outerConeAngle:U.angle/2},FU(q.spot,QX)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(q);const p={bb:this._lights.lights.length-1},S=b.parent;if(S&&XU(b,S)){const U=E.get(S);if(U){const b=this._exporter._nodes[U];return UU(X,b),b.extensions||(b.extensions={}),b.extensions[EX]=p,void Q(null)}}X.extensions||(X.extensions={}),X.extensions[EX]=p,Q(X)}))}}LU.RegisterExtension(EX,(U=>new qX(U)));var pX=b(12130);const SX="KHR_materials_anisotropy";class RX{constructor(U){this.name=SX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,X,b){const F=[];return b instanceof pX.d&&b.anisotropy.isEnabled&&!b.anisotropy.legacy?(b.anisotropy.texture&&F.push(b.anisotropy.texture),F):[]}postExportMaterialAsync(U,X,b){return new Promise((U=>{if(b instanceof pX.d){if(!b.anisotropy.isEnabled||b.anisotropy.legacy)return void U(X);this._wasUsed=!0,X.extensions=X.extensions||{};const F=this._exporter._materialExporter.getTextureInfo(b.anisotropy.texture),E={anisotropyStrength:b.anisotropy.sb,anisotropyRotation:b.anisotropy.angle,anisotropyTexture:F??void 0};null!==E.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(b),X.extensions[SX]=E}U(X)}))}}LU.RegisterExtension(SX,(U=>new RX(U)));const nX="KHR_materials_clearcoat";class aX{constructor(U){this.name=nX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,X,b){const F=[];return b instanceof pX.d&&b.clearCoat.isEnabled?(b.clearCoat.texture&&F.push(b.clearCoat.texture),!b.clearCoat.useRoughnessFromMainTexture&&b.clearCoat.textureRoughness&&F.push(b.clearCoat.textureRoughness),b.clearCoat.bumpTexture&&F.push(b.clearCoat.bumpTexture),F):[]}postExportMaterialAsync(U,X,b){return new Promise((U=>{if(b instanceof pX.d){if(!b.clearCoat.isEnabled)return void U(X);this._wasUsed=!0,X.extensions=X.extensions||{};const F=this._exporter._materialExporter.getTextureInfo(b.clearCoat.texture);let w;w=b.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(b.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(b.clearCoat.textureRoughness),b.clearCoat.isTintEnabled&&E.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${b.name}`),b.clearCoat.remapF0OnInterfaceChange&&E.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${b.name}`);const Q=this._exporter._materialExporter.getTextureInfo(b.clearCoat.bumpTexture),z={clearcoatFactor:b.clearCoat.sb,clearcoatTexture:F??void 0,clearcoatRoughnessFactor:b.clearCoat.roughness,clearcoatRoughnessTexture:w??void 0,clearcoatNormalTexture:Q??void 0};null===z.clearcoatTexture&&null===z.clearcoatRoughnessTexture&&null===z.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(b),X.extensions[nX]=z}U(X)}))}}LU.RegisterExtension(nX,(U=>new aX(U)));const JX="KHR_materials_diffuse_transmission";function mX(U,X){const b=X.subSurface;let F=null;return b.translucencyIntensityTexture?F=b.translucencyIntensityTexture:b.thicknessTexture&&b.useMaskFromThicknessTexture&&(F=b.thicknessTexture),F&&!b.useGltfStyleTextures?(W.e.Warn(`${U}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${X.name}`,1),null):F}class xX{constructor(U){this.name=JX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,X,b){const F=[];if(b instanceof JU.b&&this._isExtensionEnabled(b)){const X=mX(U,b);return X&&F.push(X),b.subSurface.translucencyColorTexture&&F.push(b.subSurface.translucencyColorTexture),F}return F}_isExtensionEnabled(U){if(U.unlit)return!1;const X=U.subSurface;return!!X.isTranslucencyEnabled&&(!U.unlit&&!X.useAlbedoToTintTranslucency&&X.useGltfStyleTextures&&1===X.volumeIndexOfRefraction&&0===X.minimumThickness&&0===X.maximumThickness)}postExportMaterialAsync(U,X,b){return new Promise((F=>{if(b instanceof JU.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const F=b.subSurface,E=mX(U,b),w=0==F.translucencyIntensity?void 0:F.translucencyIntensity,Q=this._exporter._materialExporter.getTextureInfo(E)??void 0,z=!F.translucencyColor||F.translucencyColor.equalsFloats(1,1,1)?void 0:F.translucencyColor.Jb(),q=this._exporter._materialExporter.getTextureInfo(F.translucencyColorTexture)??void 0,p={diffuseTransmissionFactor:w,diffuseTransmissionTexture:Q,diffuseTransmissionColorFactor:z,diffuseTransmissionColorTexture:q};(Q||q)&&this._exporter._materialNeedsUVsSet.add(b),X.extensions=X.extensions||{},X.extensions[JX]=p}F(X)}))}}LU.RegisterExtension(JX,(U=>new xX(U)));const IX="KHR_materials_dispersion";class OX{constructor(){this.name=IX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(U){if(U.unlit)return!1;const X=U.subSurface;return!(!X.isRefractionEnabled&&!X.isDispersionEnabled)}postExportMaterialAsync(U,X,b){return new Promise((U=>{if(b instanceof JU.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const U={dispersion:b.subSurface.dispersion};X.extensions=X.extensions||{},X.extensions[IX]=U}U(X)}))}}LU.RegisterExtension(IX,(()=>new OX));const NX="KHR_materials_emissive_strength";class uX{constructor(){this.name=NX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(U,X,b){return await new Promise((U=>{if(!(b instanceof JU.b))return U(X);const F=b.emissiveColor.Jb(),E=Math.max(...F);if(E>1){this._wasUsed=!0,X.extensions||(X.extensions={});const U={emissiveStrength:E},F=b.emissiveColor.scale(1/U.emissiveStrength);X.emissiveFactor=F.Jb(),X.extensions[NX]=U}return U(X)}))}}LU.RegisterExtension(NX,(U=>new uX));const iX="KHR_materials_ior";class PX{constructor(){this.name=iX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(U){return!U.unlit&&(void 0!=U.indexOfRefraction&&1.5!=U.indexOfRefraction)}postExportMaterialAsync(U,X,b){return new Promise((U=>{if(b instanceof JU.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const U={ior:b.indexOfRefraction};X.extensions=X.extensions||{},X.extensions[iX]=U}U(X)}))}}LU.RegisterExtension(iX,(U=>new PX));const fX="KHR_materials_iridescence";class jX{constructor(U){this.name=fX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,X,b){const F=[];return b instanceof pX.d&&b.iridescence.isEnabled?(b.iridescence.texture&&F.push(b.iridescence.texture),b.iridescence.thicknessTexture&&b.iridescence.thicknessTexture!==b.iridescence.texture&&F.push(b.iridescence.thicknessTexture),F):[]}postExportMaterialAsync(U,X,b){return new Promise((U=>{if(b instanceof pX.d){if(!b.iridescence.isEnabled)return void U(X);this._wasUsed=!0,X.extensions=X.extensions||{};const F=this._exporter._materialExporter.getTextureInfo(b.iridescence.texture),E=this._exporter._materialExporter.getTextureInfo(b.iridescence.thicknessTexture),w={iridescenceFactor:b.iridescence.sb,iridescenceIor:b.iridescence.indexOfRefraction,iridescenceThicknessMinimum:b.iridescence.minimumThickness,iridescenceThicknessMaximum:b.iridescence.maximumThickness,iridescenceTexture:F??void 0,iridescenceThicknessTexture:E??void 0};null===w.iridescenceTexture&&null===w.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(b),X.extensions[fX]=w}U(X)}))}}LU.RegisterExtension(fX,(U=>new jX(U)));const eX="KHR_materials_sheen";class lX{constructor(U){this.name=eX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,X,b){return b instanceof JU.b&&b.sheen.isEnabled&&b.sheen.texture?[b.sheen.texture]:[]}async postExportMaterialAsync(U,X,b){return await new Promise((U=>{if(b instanceof JU.b){if(!b.sheen.isEnabled)return void U(X);this._wasUsed=!0,null==X.extensions&&(X.extensions={});const F={sheenColorFactor:b.sheen.color.Jb(),sheenRoughnessFactor:b.sheen.roughness??0};null===F.sheenColorTexture&&null===F.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(b),b.sheen.texture&&(F.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.texture)??void 0),b.sheen.textureRoughness&&!b.sheen.useRoughnessFromMainTexture?F.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.textureRoughness)??void 0:b.sheen.texture&&b.sheen.useRoughnessFromMainTexture&&(F.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.texture)??void 0),X.extensions[eX]=F}U(X)}))}}LU.RegisterExtension(eX,(U=>new lX(U)));const dX="KHR_materials_specular";class kX{constructor(U){this.name=dX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,X,b){const F=[];return b instanceof JU.b&&this._isExtensionEnabled(b)?(b.metallicReflectanceTexture&&F.push(b.metallicReflectanceTexture),b.reflectanceTexture&&F.push(b.reflectanceTexture),F):F}_isExtensionEnabled(U){return!U.unlit&&(void 0!=U.metallicF0Factor&&1!=U.metallicF0Factor||void 0!=U.metallicReflectanceColor&&!U.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(U))}_hasTexturesExtension(U){return null!=U.metallicReflectanceTexture||null!=U.reflectanceTexture}postExportMaterialAsync(U,X,b){return new Promise((U=>{if(b instanceof JU.b&&this._isExtensionEnabled(b)){this._wasUsed=!0,X.extensions=X.extensions||{};const U=this._exporter._materialExporter.getTextureInfo(b.metallicReflectanceTexture)??void 0,F=this._exporter._materialExporter.getTextureInfo(b.reflectanceTexture)??void 0,E={specularFactor:1==b.metallicF0Factor?void 0:b.metallicF0Factor,specularTexture:U,specularColorFactor:b.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:b.metallicReflectanceColor.Jb(),specularColorTexture:F};this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),X.extensions[dX]=E}U(X)}))}}LU.RegisterExtension(dX,(U=>new kX(U)));const vX="KHR_materials_transmission";class AX{constructor(U){this.name=vX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,X,b){const F=[];return b instanceof JU.b&&this._isExtensionEnabled(b)?(b.subSurface.thicknessTexture&&F.push(b.subSurface.thicknessTexture),F):F}_isExtensionEnabled(U){if(U.unlit)return!1;const X=U.subSurface;return X.isRefractionEnabled&&void 0!=X.refractionIntensity&&0!=X.refractionIntensity||this._hasTexturesExtension(U)}_hasTexturesExtension(U){return null!=U.subSurface.refractionIntensityTexture}async postExportMaterialAsync(U,X,b){if(b instanceof JU.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const F=b.subSurface,E={transmissionFactor:0===F.refractionIntensity?void 0:F.refractionIntensity};if(this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),F.refractionIntensityTexture)if(F.useGltfStyleTextures){const U=await this._exporter._materialExporter.exportTextureAsync(F.refractionIntensityTexture,"image/png");U&&(E.transmissionTexture=U)}else W.e.Warn(`${U}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);X.extensions||(X.extensions={}),X.extensions[vX]=E}return X}}LU.RegisterExtension(vX,(U=>new AX(U)));const sX="KHR_materials_unlit";class hX{constructor(){this.name=sX,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(U,X,b){return new Promise((U=>{let F=!1;b instanceof JU.b?F=b.unlit:b instanceof mU.OX&&(F=b.disableLighting),F&&(this._wasUsed=!0,null==X.extensions&&(X.extensions={}),X.extensions[sX]={}),U(X)}))}}LU.RegisterExtension(sX,(()=>new hX));const BX="KHR_materials_volume";class oX{constructor(U){this.name=BX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,X,b){const F=[];return b instanceof JU.b&&this._isExtensionEnabled(b)?(b.subSurface.thicknessTexture&&F.push(b.subSurface.thicknessTexture),F):F}_isExtensionEnabled(U){if(U.unlit)return!1;const X=U.subSurface;return!(!X.isRefractionEnabled&&!X.isTranslucencyEnabled)&&(void 0!=X.maximumThickness&&0!=X.maximumThickness||void 0!=X.tintColorAtDistance&&X.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=X.tintColor&&X.tintColor!=x.NX.White()||this._hasTexturesExtension(U))}_hasTexturesExtension(U){return null!=U.subSurface.thicknessTexture}postExportMaterialAsync(U,X,b){return new Promise((U=>{if(b instanceof JU.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const U=b.subSurface,F={thicknessFactor:0==U.maximumThickness?void 0:U.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(U.thicknessTexture)??void 0,attenuationDistance:U.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:U.tintColorAtDistance,attenuationColor:U.tintColor.equalsFloats(1,1,1)?void 0:U.tintColor.Jb()};this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),X.extensions=X.extensions||{},X.extensions[BX]=F}U(X)}))}}LU.RegisterExtension(BX,(U=>new oX(U)));const yX="EXT_materials_diffuse_roughness";class tX{constructor(U){this.name=yX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,X,b){const F=[];return b instanceof pX.d&&b._baseDiffuseRoughness?(b._baseDiffuseRoughnessTexture&&F.push(b._baseDiffuseRoughnessTexture),F):[]}postExportMaterialAsync(U,X,b){return new Promise((U=>{if(b instanceof pX.d){if(!b._baseDiffuseRoughness)return void U(X);this._wasUsed=!0,X.extensions=X.extensions||{};const F=this._exporter._materialExporter.getTextureInfo(b._baseDiffuseRoughnessTexture),E={diffuseRoughnessFactor:b._baseDiffuseRoughness,diffuseRoughnessTexture:F??void 0};null!==E.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(b),X.extensions[yX]=E}U(X)}))}}LU.RegisterExtension(yX,(U=>new tX(U)));const WX="KHR_texture_transform";class YX{constructor(){this.name=WX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(U,X,b){if(b.fU()||E.Tools.Warn(`${U}: /*@__KEY__*/"scene" is not defined for Babylon texture ${b.name}!`),(0!==b.uAng||0!==b.vAng)&&(E.Tools.Warn(`${U}: Texture ${b.name} with rotation in the u or v axis is not supported in glTF.`),0!==b.uRotationCenter||0!==b.vRotationCenter))return;const F={};let w=!1;if(0===b.uOffset&&0===b.vOffset||(F.offset=[b.uOffset,b.vOffset],w=!0),1===b.uScale&&1===b.vScale||(F.scale=[b.uScale,b.vScale],w=!0),0!==b.wAng){if(0!==b.uRotationCenter||0!==b.vRotationCenter){if(b.homogeneousRotationInUVTransform&&b.uScale!==b.vScale)return void E.Tools.Warn(`${U}: Texture ${b.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${WX}.`);E.Tools.Warn(`${U}: Texture ${b.name} with non-origin rotation center will be exported using an adjusted offset with ${WX}.`),F.offset=function(U){const{uOffset:X,vOffset:b,uRotationCenter:F,vRotationCenter:E,uScale:w,vScale:Q,wAng:z}=U,q=Math.cos(z),p=Math.sin(z),S=F*w,R=E*Q;return[X+(S*(1-q)+R*p),b+(R*(1-q)-S*p)]}(b)}F.rotation=-b.wAng,w=!0}0!==b.coordinatesIndex&&(F.texCoord=b.coordinatesIndex,w=!0),w&&(this._wasUsed=!0,X.extensions||(X.extensions={}),X.extensions[WX]=F)}}LU.RegisterExtension(WX,(()=>new YX));class KX{static CreateSTL(U){let X=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],w=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],Q=arguments.length>5&&void 0!==arguments[5]&&arguments[5],z=arguments.length>6&&void 0!==arguments[6]&&arguments[6],q=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const p=function(U,X,b){const E=[3*U[b],3*U[b+1],3*U[b+2]],w=[new F.JX(X[E[0]],X[E[0]+2],X[E[0]+1]),new F.JX(X[E[1]],X[E[1]+2],X[E[1]+1]),new F.JX(X[E[2]],X[E[2]+2],X[E[2]+1])],Q=w[0].mX(w[1]),z=w[2].mX(w[1]);return{v:w,n:F.JX.Cross(z,Q).normalize()}},R=function(U,X,b,F){return X=n(U,X,b.x,F),X=n(U,X,b.y,F),n(U,X,b.z,F)},n=function(U,X,b,F){return U.setFloat32(X,b,F),X+4},J=function(U){if(z){let X=U;U instanceof a.c&&(X=U.sourceMesh);const b=X.getVerticesData(S.h.PositionKind,!0,!0);if(!b)return[];const E=F.JX.Zero();let w;for(w=0;w<b.length;w+=3)F.JX.TransformCoordinatesFromFloatsToRef(b[w],b[w+1],b[w+2],U.Ob(!0),E).toArray(b,w);return b}return U.getVerticesData(S.h.PositionKind)||[]};z&&(Q=!0);let m="",x=0,I=0;if(E){for(let b=0;b<U.length;b++){const X=U[b].ub();x+=X?X.length/3:0}const X=new ArrayBuffer(84+50*x);m=new DataView(X),I+=80,m.setUint32(I,x,w),I+=4}else q||(m="solid stlmesh\r\n");for(let F=0;F<U.length;F++){const X=U[F];!E&&q&&(m+="solid "+X.name+"\r\n"),!Q&&X instanceof OU.e&&X.bakeCurrentTransformIntoVertices();const b=J(X),z=X.ub()||[];for(let U=0;U<z.length;U+=3){const X=p(z,b,U);E?(I=R(m,I,X.n,w),I=R(m,I,X.v[0],w),I=R(m,I,X.v[1],w),I=R(m,I,X.v[2],w),I+=2):(m+="\tfacet normal "+X.n.x+" "+X.n.y+" "+X.n.z+"\r\n",m+="\t\touter loop\r\n",m+="\t\t\tvertex "+X.v[0].x+" "+X.v[0].y+" "+X.v[0].z+"\r\n",m+="\t\t\tvertex "+X.v[1].x+" "+X.v[1].y+" "+X.v[1].z+"\r\n",m+="\t\t\tvertex "+X.v[2].x+" "+X.v[2].y+" "+X.v[2].z+"\r\n",m+="\t\tendloop\r\n",m+="\tendfacet\r\n")}!E&&q&&(m+="endsolid "+name+"\r\n")}if(E||q||(m+="endsolid stlmesh"),X){const U=document.createElement("a"),X=new Blob([m],{type:"application/octet-stream"});U.href=window.URL.createObjectURL(X),U.download=b+".stl",U.click()}return m}}function VX(U,X){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const F=[];for(let E=0;E<U.length/b;E++){const w=U[E*b],Q=U[E*b+1],z=U[E*b+2];F.push(`(${w.toPrecision(X.precision)}, ${Q.toPrecision(X.precision)}, ${z.toPrecision(X.precision)})`)}return F.join(", ")}function gX(U,X){const b=[];for(let F=0;F<U.length/2;F++){const E=U[2*F],w=U[2*F+1];b.push(`(${E.toPrecision(X.precision)}, ${(1-w).toPrecision(X.precision)})`)}return b.join(", ")}function LX(U,X){const b=U.getVerticesData(S.h.PositionKind),F=U.getVerticesData(S.h.NormalKind);if(b&&F)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(U){var X;const b=null!==(X=U.ub())&&void 0!==X&&X.length?U.getTotalIndices():U.getTotalVertices();return Array(b/3).fill(3).join(", ")}(U)}]\n\t\tint[] faceVertexIndices = [${function(U){const X=U.ub(),b=[];if(null!==X)for(let F=0;F<X.length;F++)b.push(X[F]);else{const X=U.getTotalVertices();for(let U=0;U<X;U++)b.push(U)}return b.join(", ")}(U)}]\n\t\tnormal3f[] normals = [${VX(F,X)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${VX(b,X)}]\n        ${function(U,X){let b="";for(let E=0;E<4;E++){const F=E>0?E:"",w=U.getVerticesData(S.h.UVKind+(F?F+1:""));w&&(b+=`\n\t\ttexCoord2f[] primvars:st${F} = [${gX(w,X)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const F=U.getVerticesData(S.h.ColorKind);return F&&(b+=`\n\tcolor3f[] primvars:displayColor = [${VX(F,X,F.length/U.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),b}(U,X)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function DX(U,X){return`\n        def "Geometry"\n        {\n        ${LX(U,X)}\n        }\n        `}function GX(U){let X='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return X+=U,fflate.strToU8(X)}function ZX(U){const X=U.m;return`( ${cX(X,0)}, ${cX(X,4)}, ${cX(X,8)}, ${cX(X,12)} )`}function cX(U,X){return`(${U[X+0]}, ${U[X+1]}, ${U[X+2]}, ${U[X+3]})`}function rX(U){const X="Object_"+U.uniqueId,b=function(U){const X=U.getWorldMatrix().clone(),b=U.fU().useRightHandedSystem;if(!b){let F=U.parent;for(;F;){if(QU(F,b)){X.multiplyToRef(F.getWorldMatrix().invert(),X);break}F=F.parent}}return X.determinant()<0&&E.Tools.Warn(`Exporting mesh ${U.name} with negative scale. Result may look incorrect in destination engine.`),X}(U),F=ZX(b);return`def Xform "${X}" (\n\tprepend references = @./geometries/Geometry_${U.Nb.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${F}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${U.material.uniqueId}>\n}\n\n`}function MX(U){switch(U){case f.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case f.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case f.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function HX(U){return`(${U.x}, ${U.y})`}function TX(U){return`(${U.r}, ${U.g}, ${U.b})`}function CX(U,X,b,E,w,Q){const z=U.getInternalTexture().uniqueId+"_"+U.invertY;w[z]=U;const q=U.coordinatesIndex>0?"st"+U.coordinatesIndex:"st",p=new F.Vector2(U.uScale,U.vScale),S=new F.Vector2(U.uOffset,U.vOffset),R=U.wAng,n=Math.sin(R),a=Math.cos(R);return S.y=1-S.y-p.y,S.x+=n*p.x,S.y+=(1-a)*p.y,`\n    def Shader "PrimvarReader_${b}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${q}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${b}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${X.uniqueId}/PrimvarReader_${b}.outputs:result>\n        float inputs:rotation = ${(R*(180/Math.PI)).toFixed(Q.precision)}\n        float2 inputs:scale = ${HX(p)}\n        float2 inputs:translation = ${HX(S)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${U.uniqueId}_${b}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${z}.png@\n        float2 inputs:st.connect = </Materials/Material_${X.uniqueId}/Transform2d_${b}.outputs:result>\n        ${E?"float4 inputs:scale = "+function(U){return`(${U.r}, ${U.g}, ${U.b}, 1.0)`}(E):""}\n        token inputs:sourceColorSpace = "${U.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${MX(U.wrapU)}"\n        token inputs:wrapT = "${MX(U.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${X.needAlphaBlending()?"float outputs:a":""}\n    }`}function Ub(U,X,b){const F="\t\t\t",E=[],w=[],{diffuseMap:Q,hb:z,alphaCutOff:q,emissiveMap:p,emissive:S,normalMap:R,roughnessMap:n,roughnessChannel:a,roughness:J,metalnessMap:m,metalnessChannel:I,metalness:O,aoMap:N,aoMapChannel:u,aoMapIntensity:i,alphaMap:P,ior:f,clearCoatEnabled:j,clearCoat:e,clearCoatMap:l,clearCoatRoughness:d,clearCoatRoughnessMap:k}=function(U){const X={diffuseMap:null,hb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return U instanceof mU.OX?{...X,diffuseMap:U.diffuseTexture,hb:U.diffuseColor,alphaCutOff:U.alphaCutOff,emissiveMap:U.emissiveTexture,emissive:U.emissiveColor,roughness:1,alphaMap:U.opacityTexture}:U instanceof pX.d?{...X,diffuseMap:U._albedoTexture,hb:U._albedoColor,alphaCutOff:U._alphaCutOff,emissiveMap:U._emissiveTexture,emissive:U._emissiveColor,normalMap:U._bumpTexture,roughnessMap:U._metallicTexture,roughnessChannel:U._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:U._roughness??1,metalnessMap:U._metallicTexture,metalnessChannel:U._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:U._metallic??0,aoMap:U._ambientTexture,aoMapChannel:U._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:U._ambientTextureStrength,alphaMap:U._opacityTexture,ior:U.subSurface.indexOfRefraction,clearCoatEnabled:U.clearCoat.isEnabled,clearCoat:U.clearCoat.sb,clearCoatMap:U.clearCoat.texture,clearCoatRoughness:U.clearCoat.roughness,clearCoatRoughnessMap:U.clearCoat.useRoughnessFromMainTexture?U.clearCoat.texture:U.clearCoat.textureRoughness}:X}(U);return null!==Q?(E.push(`${F}color3f inputs:diffuseColor.connect = </Materials/Material_${U.uniqueId}/Texture_${Q.uniqueId}_diffuse.outputs:rgb>`),U.needAlphaBlending()?E.push(`${F}float inputs:opacity.connect = </Materials/Material_${U.uniqueId}/Texture_${Q.uniqueId}_diffuse.outputs:a>`):U.needAlphaTesting()&&(E.push(`${F}float inputs:opacity.connect = </Materials/Material_${U.uniqueId}/Texture_${Q.uniqueId}_diffuse.outputs:a>`),E.push(`${F}float inputs:opacityThreshold = ${q}`)),w.push(CX(Q,U,"diffuse",z,X,b))):E.push(`${F}color3f inputs:diffuseColor = ${TX(z||x.NX.White())}`),null!==p?(E.push(`${F}color3f inputs:emissiveColor.connect = </Materials/Material_${U.uniqueId}/Texture_${p.uniqueId}_emissive.outputs:rgb>`),w.push(CX(p,U,"emissive",S,X,b))):S&&S.toLuminance()>0&&E.push(`${F}color3f inputs:emissiveColor = ${TX(S)}`),null!==R&&(E.push(`${F}normal3f inputs:normal.connect = </Materials/Material_${U.uniqueId}/Texture_${R.uniqueId}_normal.outputs:rgb>`),w.push(CX(R,U,"normal",null,X,b))),null!==N&&(E.push(`${F}float inputs:occlusion.connect = </Materials/Material_${U.uniqueId}/Texture_${N.uniqueId}_occlusion.outputs:${u}>`),w.push(CX(N,U,"occlusion",new x.NX(i,i,i),X,b))),null!==n?(E.push(`${F}float inputs:roughness.connect = </Materials/Material_${U.uniqueId}/Texture_${n.uniqueId}_roughness.outputs:${a}>`),w.push(CX(n,U,"roughness",new x.NX(J,J,J),X,b))):E.push(`${F}float inputs:roughness = ${J}`),null!==m?(E.push(`${F}float inputs:metallic.connect = </Materials/Material_${U.uniqueId}/Texture_${m.uniqueId}_metallic.outputs:${I}>`),w.push(CX(m,U,"metallic",new x.NX(O,O,O),X,b))):E.push(`${F}float inputs:metallic = ${O}`),null!==P?(E.push(`${F}float inputs:opacity.connect = </Materials/Material_${U.uniqueId}/Texture_${P.uniqueId}_opacity.outputs:r>`),E.push(`${F}float inputs:opacityThreshold = 0.0001`),w.push(CX(P,U,"opacity",null,X,b))):E.push(`${F}float inputs:opacity = ${U.alpha}`),j&&(null!==l?(E.push(`${F}float inputs:clearcoat.connect = </Materials/Material_${U.uniqueId}/Texture_${l.uniqueId}_clearcoat.outputs:r>`),w.push(CX(l,U,"clearcoat",new x.NX(e,e,e),X,b))):E.push(`${F}float inputs:clearcoat = ${e}`),null!==k?(E.push(`${F}float inputs:clearcoatRoughness.connect = </Materials/Material_${U.uniqueId}/Texture_${k.uniqueId}_clearcoatRoughness.outputs:g>`),w.push(CX(k,U,"clearcoatRoughness",new x.NX(d,d,d),X,b))):E.push(`${F}float inputs:clearcoatRoughness = ${d}`)),E.push(`${F}float inputs:ior = ${f}`),`\n\tdef Material "Material_${U.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${E.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${U.uniqueId}/PreviewSurface.outputs:surface>\n\n${w.join("\n")}\n\n\t}\n`}async function Xb(U,X,b){const w={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...X};"undefined"===typeof fflate&&await E.Tools.LoadScriptAsync(w.fflateUrl);const Q={};Q[w.modelFileName]=null;let z='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';z+=function(U){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===U.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${U.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${U.planeAnchoringAlignment}"`:""}\n            `}(w);const q={};for(const F of U.meshes){if(0===F.getTotalVertices())continue;const U=F,X=U.Nb,p=U.material;if(!p||!X||b&&!b(U))continue;if(-1!==["OX","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(p.getClassName())){const b="geometries/Geometry_"+X.uniqueId+".usda";if(!(b in Q)){const U=DX(X,w);Q[b]=GX(U)}p.uniqueId in q||(q[p.uniqueId]=p),z+=rX(U)}else E.Tools.Warn("USDZExportAsync does not support this material type: "+p.getClassName())}U.activeCamera&&w.exportCamera&&(z+=function(U,X){const b="Camera_"+U.uniqueId,E=ZX(F.Matrix.RotationY(Math.PI).multiply(U.getWorldMatrix()));if(U.mode===f.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${b}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${U.xb.toPrecision(X.precision)}, ${U.maxZ.toPrecision(X.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(U.orthoLeft||1)+Math.abs(U.orthoRight||1))).toPrecision(X.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(U.orthoTop||1)+Math.abs(U.orthoBottom||1))).toPrecision(X.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const F=U.getEngine().getAspectRatio(U),w=X.cameraSensorWidth||35;return`def Camera "${b}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${U.xb.toPrecision(X.precision)}, ${U.maxZ.toPrecision(X.precision)})\n\t\t\tfloat focalLength = ${(w/(2*Math.tan(.5*U.fov))).toPrecision(X.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(w*F).toPrecision(X.precision)}\n\t\t\tfloat verticalAperture = ${(w/F).toPrecision(X.precision)}            \n\t\t}\n\t\n\t`}}(U.activeCamera,w)),z+="\n            }\n        }\n    }";const p={};z+=function(U,X,b){const F=[];for(const E in U){const w=U[E];F.push(Ub(w,X,b))}return`\n    def "Materials"\n{\n${F.join("")}\n}\n\n`}(q,p,w),Q[w.modelFileName]=fflate.strToU8(z);for(const F in p){const U=p[F],X=U.getSize(),b=await U.readPixels();if(!b)throw new Error("Texture data is not available");const E=await j.DumpTools.DumpDataAsync(X.width,X.height,b,"image/png",void 0,!1,!0);Q[`textures/Texture_${F}.png`]=new Uint8Array(E).slice()}let S=0;for(const F in Q){const U=Q[F];if(!U)continue;S+=34+F.length;const X=63&S;if(4!==X){const b=new Uint8Array(64-X);Q[F]=[U,{extra:{12345:b}}]}S=U.length}return fflate.zipSync(Q,{level:0})}}}]);