"use strict";(self["2fwzcez286e"]=self["2fwzcez286e"]||[]).push([[26],{13383:(B,u,F)=>{F.r(u),F.d(u,{EXT_materials_diffuse_roughness:()=>wu,EXT_mesh_gpu_instancing:()=>rB,GLTF2Export:()=>hB,GLTFData:()=>s,KHR_draco_mesh_compression:()=>Fu,KHR_lights_punctual:()=>eu,KHR_materials_anisotropy:()=>Qu,KHR_materials_clearcoat:()=>vu,KHR_materials_diffuse_transmission:()=>qu,KHR_materials_dispersion:()=>Xu,KHR_materials_emissive_strength:()=>Cu,KHR_materials_ior:()=>Uu,KHR_materials_iridescence:()=>Ou,KHR_materials_sheen:()=>Ju,KHR_materials_specular:()=>Tu,KHR_materials_transmission:()=>Mu,KHR_materials_unlit:()=>ou,KHR_materials_volume:()=>mF,KHR_texture_transform:()=>nu,OBJExport:()=>G,STLExport:()=>du,USDZExportAsync:()=>uF,_ConvertToGLTFPBRMetallicRoughness:()=>j,_SolveMetallic:()=>M,__IGLTFExporterExtension:()=>R});var Z=F(12979),V=F(12802),p=F(13299);class G{static OBJ(B,u,F,G){const R=[];let e=1,s=1;u&&(F||(F="mat"),R.push("mtllib "+F+".mtl"));for(let Y=0;Y<B.length;Y++){const F=B[Y],Q=F.name||`mesh${Y}}`;R.push(`o ${Q}`);let t=null;if(G){const B=F.XR(!0);t=new Z.Matrix,B.invertToRef(t),F.bakeTransformIntoVertices(B)}if(u){const B=F.material;B&&R.push("usemtl "+B.id)}const v=F.fR;if(!v){V.Tools.Warn("No geometry is present on the mesh");continue}const D=v.getVerticesData("position"),L=v.getVerticesData("normal"),q=v.getVerticesData("uv"),W=v.CR();let X=0,f=0;if(!D||!W){V.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const C=B[0].yB().useRightHandedSystem?1:-1;for(let B=0;B<D.length;B+=3)R.push("v "+D[B]*C+" "+D[B+1]+" "+D[B+2]),X++;if(null!=L)for(let B=0;B<L.length;B+=3)R.push("vn "+L[B]*C+" "+L[B+1]+" "+L[B+2]);if(null!=q)for(let B=0;B<q.length;B+=2)R.push("vt "+q[B]+" "+q[B+1]),f++;const x=["","",""],U=(F.material||F.yB().defaultMaterial)._getEffectiveOrientation(F),[y,O]=U===p.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let B=0;B<W.length;B+=3){const u=[String(W[B]+e),String(W[B+y]+e),String(W[B+O]+e)],F=[String(W[B]+s),String(W[B+y]+s),String(W[B+O]+s)],Z=u,V=null!=q?F:x,p=null!=L?u:x;R.push("f "+Z[0]+"/"+V[0]+"/"+p[0]+" "+Z[1]+"/"+V[1]+"/"+p[1]+" "+Z[2]+"/"+V[2]+"/"+p[2])}G&&t&&F.bakeTransformIntoVertices(t),e+=X,s+=f}return R.join("\n")}static MTL(B){const u=[],F=B.material;u.push("newmtl mat1"),u.push("  Ns "+F.specularPower.toFixed(4)),u.push("  Ni 1.5000"),u.push("  d "+F.alpha.toFixed(4)),u.push("  Tr 0.0000"),u.push("  Tf 1.0000 1.0000 1.0000"),u.push("  illum 2"),u.push("  Ka "+F.ambientColor.r.toFixed(4)+" "+F.ambientColor.g.toFixed(4)+" "+F.ambientColor.b.toFixed(4)),u.push("  Kd "+F.diffuseColor.r.toFixed(4)+" "+F.diffuseColor.g.toFixed(4)+" "+F.diffuseColor.b.toFixed(4)),u.push("  Ks "+F.specularColor.r.toFixed(4)+" "+F.specularColor.g.toFixed(4)+" "+F.specularColor.b.toFixed(4)),u.push("  Ke "+F.emissiveColor.r.toFixed(4)+" "+F.emissiveColor.g.toFixed(4)+" "+F.emissiveColor.b.toFixed(4));F.ambientTexture&&u.push("  map_Ka "+F.ambientTexture.name),F.diffuseTexture&&u.push("  map_Kd "+F.diffuseTexture.name),F.specularTexture&&u.push("  map_Ks "+F.specularTexture.name),F.bumpTexture&&u.push("  map_bump -imfchan z "+F.bumpTexture.name),F.opacityTexture&&u.push("  map_d "+F.opacityTexture.name);return u.join("\n")}}var R=0,e=F(12861);class s{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const B in this.files){const u=this.files[B],F=new Blob([u],{type:(0,e.e)(B)});V.Tools.Download(F,B)}}}var Y=F(13047),Q=F(13389),t=F(13396),v=F(13406),D=F(13108),L=F(12855),q=F(13023),W=F(12994);const X=W.HighestCommonFactor,f={...W,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:X};var C=F(13215),x=F(12969),U=F(13438),y=F(13446),O=F(13206);const g=1e-6,J=new q.Xu(.04,.04,.04),a=1024,T=q.Xu.White(),z=q.Xu.Black();function M(B,u,F){if(u<J.r)return 0;const Z=J.r,V=B*F/(1-J.r)+u-2*J.r,p=V*V-4*Z*(J.r-u);return f.Clamp((-V+Math.sqrt(p))/(2*Z),0,1)}function j(B){const u=B.diffuseColor.toLinearSpace(B.yB().getEngine().useExactSrgbConversions).scale(.5),F=B.alpha,V=function(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Z.Vector2(0,1),F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Z.Vector2(0,.1),V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Z.Vector2(0,.1),p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new Z.Vector2(1300,.1);return function(B,u,F,Z,V){return(1-B)*(1-B)*(1-B)*u+3*(1-B)*(1-B)*B*F+3*(1-B)*B*B*Z+B*B*B*V}(Math.pow(B/p.x,.333333),u.y,F.y,V.y,p.y)}(f.Clamp(B.specularPower,0,a));return{baseColorFactor:[u.r,u.g,u.b,F],metallicFactor:0,roughnessFactor:V}}function o(B,u){u.needAlphaBlending()?B.alphaMode="BLEND":u.needAlphaTesting()&&(B.alphaMode="MASK",B.alphaCutoff=u.alphaCutOff)}function I(B,u,F){const Z=new Uint8Array(B*u*4);for(let V=0;V<Z.length;V+=4)Z[V]=Z[V+1]=Z[V+2]=Z[V+3]=255;return U.b.CreateRGBATexture(Z,B,u,F)}function mB(B){if(B instanceof Uint8Array){const u=B.length,F=new Float32Array(B.length);for(let Z=0;Z<u;++Z)F[Z]=B[Z]/255;return F}if(B instanceof Float32Array)return B;throw new Error("Unsupported pixel format!")}class E{constructor(B){this._exporter=B,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(B){return B?this._textureMap.get(B)??null:null}async exportStandardMaterialAsync(B,u,F){const Z=j(B),p={name:B.name};if(null==B.xR||B.xR||(B.twoSidedLighting||V.Tools.Warn(B.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),p.doubleSided=!0),F){const F=[],V=B.diffuseTexture;V&&F.push(this.exportTextureAsync(V,u).then((B=>{B&&(Z.baseColorTexture=B)})));const G=B.bumpTexture;G&&F.push(this.exportTextureAsync(G,u).then((B=>{B&&(p.normalTexture=B,1!==G.level&&(p.normalTexture.scale=G.level))})));const R=B.emissiveTexture;R&&(p.emissiveFactor=[1,1,1],F.push(this.exportTextureAsync(R,u).then((B=>{B&&(p.emissiveTexture=B)}))));const e=B.ambientTexture;e&&F.push(this.exportTextureAsync(e,u).then((B=>{if(B){const u={index:B.index};p.occlusionTexture=u}}))),F.length>0&&(this._exporter._materialNeedsUVsSet.add(B),await Promise.all(F))}(B.alpha<1||B.opacityTexture)&&(B.alphaMode===y.d.ALPHA_COMBINE?p.alphaMode="BLEND":V.Tools.Warn(B.name+": glTF 2.0 does not support alpha mode: "+B.alphaMode.toString())),B.emissiveColor&&!B.emissiveColor.equalsWithEpsilon(z,g)&&(p.emissiveFactor=B.emissiveColor.DR()),p.pbrMetallicRoughness=Z,o(p,B),await this._finishMaterialAsync(p,B,u);const G=this._exporter._materials;return G.push(p),G.length-1}async _finishMaterialAsync(B,u,F){const Z=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",B,u),V=[];for(const p of Z)V.push(this.exportTextureAsync(p,F));await Promise.all(V),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",B,u)}async _getImageDataAsync(B,u,Z,V){const p=y.d.TEXTURETYPE_UNSIGNED_BYTE,G=this._exporter._babylonScene,R=G.getEngine(),e=R.createRawTexture(B,u,Z,y.d.TEXTUREFORMAT_RGBA,!1,!0,x.d.NEAREST_SAMPLINGMODE,null,p);R.isWebGPU?await F.e(51).then(F.bind(F,15508)):await F.e(52).then(F.bind(F,15516)),await C.j.ApplyPostProcess("pass",e,G,p,y.d.TEXTURE_NEAREST_SAMPLINGMODE,y.d.TEXTUREFORMAT_RGBA);const s=await R._readTexturePixels(e,u,Z);return await O.DumpTools.DumpDataAsync(u,Z,s,V,void 0,!0,!0)}_resizeTexturesToSameDimensions(B,u,F){const Z=B?B.getSize():{width:0,height:0},V=u?u.getSize():{width:0,height:0};let p,G;return Z.width<V.width?(p=B&&B instanceof x.d?C.j.CreateResizedCopy(B,V.width,V.height,!0):I(V.width,V.height,F),G=u):Z.width>V.width?(G=u&&u instanceof x.d?C.j.CreateResizedCopy(u,Z.width,Z.height,!0):I(Z.width,Z.height,F),p=B):(p=B,G=u),{texture1:p,texture2:G}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(B,u,F,Z){const V=new Array;if(!B&&!u)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const p=B?B.yB():u?u.yB():null;if(p){var G;const R=this._resizeTexturesToSameDimensions(B,u,p),e=null===(G=R.texture1)||void 0===G?void 0:G.getSize();let s,Y;const Q=e.width,t=e.height,v=await R.texture1.readPixels(),D=await R.texture2.readPixels();if(!v)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(s=mB(v),!D)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");Y=mB(D);const L=Y.byteLength,W=new Uint8Array(L),X=new Uint8Array(L),f=4,C=z;let x=0,U=0;for(let B=0;B<t;++B)for(let u=0;u<Q;++u){const Z=(Q*B+u)*f,V={diffuseColor:new q.Xu(s[Z],s[Z+1],s[Z+2]).toLinearSpace(p.getEngine().useExactSrgbConversions).multiply(F.diffuseColor),specularColor:new q.Xu(Y[Z],Y[Z+1],Y[Z+2]).toLinearSpace(p.getEngine().useExactSrgbConversions).multiply(F.specularColor),glossiness:Y[Z+3]*F.glossiness},G=this._convertSpecularGlossinessToMetallicRoughness(V);C.r=Math.max(C.r,G.baseColor.r),C.g=Math.max(C.g,G.baseColor.g),C.b=Math.max(C.b,G.baseColor.b),x=Math.max(x,G.metallic),U=Math.max(U,G.roughness),X[Z]=255*G.baseColor.r,X[Z+1]=255*G.baseColor.g,X[Z+2]=255*G.baseColor.b,X[Z+3]=R.texture1.LR?255*s[Z+3]:255,W[Z]=0,W[Z+1]=255*G.roughness,W[Z+2]=255*G.metallic,W[Z+3]=255}const y={baseColor:C,metallic:x,roughness:U};let O=!1,J=!1;for(let B=0;B<t;++B)for(let u=0;u<Q;++u){const F=(Q*B+u)*f;X[F]/=y.baseColor.r>g?y.baseColor.r:1,X[F+1]/=y.baseColor.g>g?y.baseColor.g:1,X[F+2]/=y.baseColor.b>g?y.baseColor.b:1;const Z=q.Xu.FromInts(X[F],X[F+1],X[F+2]).toGammaSpace(p.getEngine().useExactSrgbConversions);X[F]=255*Z.r,X[F+1]=255*Z.g,X[F+2]=255*Z.b,Z.equalsWithEpsilon(T,g)||(J=!0),W[F+1]/=y.roughness>g?y.roughness:1,W[F+2]/=y.metallic>g?y.metallic:1;q.Xu.FromInts(255,W[F+1],W[F+2]).equalsWithEpsilon(T,g)||(O=!0)}return O&&V.push(this._getImageDataAsync(W,Q,t,Z).then((B=>{y.metallicRoughnessTextureData=B}))),J&&V.push(this._getImageDataAsync(X,Q,t,Z).then((B=>{y.baseColorTextureData=B}))),await Promise.all(V).then((()=>y))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(B){const u=this._getPerceivedBrightness(B.diffuseColor),F=this._getPerceivedBrightness(B.specularColor),Z=1-this._getMaxComponent(B.specularColor),V=M(u,F,Z),p=B.diffuseColor.scale(Z/(1-J.r)/Math.max(1-V)),G=B.specularColor.Lu(J.scale(1-V)).scale(1/Math.max(V));let R=q.Xu.Lerp(p,G,V*V);R=R.clampToRef(0,1,R);return{baseColor:R,metallic:V,roughness:1-B.glossiness}}_getPerceivedBrightness(B){return B?Math.sqrt(.299*B.r*B.r+.587*B.g*B.g+.114*B.b*B.b):0}_getMaxComponent(B){return B?Math.max(B.r,Math.max(B.g,B.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(B,u,F,Z){const V=[],p={baseColor:B._albedoColor,metallic:B._metallic,roughness:B._roughness};if(Z){B._albedoTexture&&V.push(this.exportTextureAsync(B._albedoTexture,u).then((B=>{B&&(F.baseColorTexture=B)})));const Z=B._metallicTexture;Z&&V.push(this.exportTextureAsync(Z,u).then((B=>{B&&(F.metallicRoughnessTexture=B)})))}return V.length>0&&(this._exporter._materialNeedsUVsSet.add(B),await Promise.all(V)),p}_getTextureSampler(B){const u={};if(!B||!(B instanceof x.d))return u;const F=this._getGLTFTextureWrapMode(B.wrapU);10497!==F&&(u.wrapS=F);const Z=this._getGLTFTextureWrapMode(B.wrapV);switch(10497!==Z&&(u.wrapT=Z),B.samplingMode){case x.d.LINEAR_LINEAR:u.magFilter=9729,u.minFilter=9729;break;case x.d.LINEAR_NEAREST:u.magFilter=9729,u.minFilter=9728;break;case x.d.NEAREST_LINEAR:u.magFilter=9728,u.minFilter=9729;break;case x.d.NEAREST_LINEAR_MIPLINEAR:u.magFilter=9728,u.minFilter=9987;break;case x.d.NEAREST_NEAREST:u.magFilter=9728,u.minFilter=9728;break;case x.d.NEAREST_LINEAR_MIPNEAREST:u.magFilter=9728,u.minFilter=9985;break;case x.d.LINEAR_NEAREST_MIPNEAREST:u.magFilter=9729,u.minFilter=9984;break;case x.d.LINEAR_NEAREST_MIPLINEAR:u.magFilter=9729,u.minFilter=9986;break;case x.d.NEAREST_NEAREST_MIPLINEAR:u.magFilter=9728,u.minFilter=9986;break;case x.d.LINEAR_LINEAR_MIPLINEAR:u.magFilter=9729,u.minFilter=9987;break;case x.d.LINEAR_LINEAR_MIPNEAREST:u.magFilter=9729,u.minFilter=9985;break;case x.d.NEAREST_NEAREST_MIPNEAREST:u.magFilter=9728,u.minFilter=9984}return u}_getGLTFTextureWrapMode(B){switch(B){case x.d.WRAP_ADDRESSMODE:return 10497;case x.d.CLAMP_ADDRESSMODE:return 33071;case x.d.MIRROR_ADDRESSMODE:return 33648;default:return V.Tools.Error(`Unsupported Texture Wrap Mode ${B}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(B,u,F,Z){const V={diffuseColor:B._albedoColor,specularColor:B._reflectivityColor,glossiness:B._microSurface},p=B._albedoTexture,G=B._reflectivityTexture,R=B._useMicroSurfaceFromReflectivityMapAlpha;if(G&&!R)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((p||G)&&Z){this._exporter._materialNeedsUVsSet.add(B);const Z=this._exportTextureSampler(p||G),R=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(p,G,V,u),e=this._exporter._textures;if(R.baseColorTextureData){const B=this._exportImage(`baseColor${e.length}`,u,R.baseColorTextureData);F.baseColorTexture=this._exportTextureInfo(B,Z,null===p||void 0===p?void 0:p.coordinatesIndex)}if(R.metallicRoughnessTextureData){const B=this._exportImage(`metallicRoughness${e.length}`,u,R.metallicRoughnessTextureData);F.metallicRoughnessTexture=this._exportTextureInfo(B,Z,null===G||void 0===G?void 0:G.coordinatesIndex)}return R}return this._convertSpecularGlossinessToMetallicRoughness(V)}async exportPBRMaterialAsync(B,u,F){const Z={},V={name:B.name},p=B.isMetallicWorkflow();if(p){const u=B._albedoColor,F=B.alpha;u&&(Z.baseColorFactor=[u.r,u.g,u.b,F])}const G=p?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(B,u,Z,F):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(B,u,Z,F);await this._setMetallicRoughnessPbrMaterialAsync(G,B,V,Z,u,F),await this._finishMaterialAsync(V,B,u);const R=this._exporter._materials;return R.push(V),R.length-1}async _setMetallicRoughnessPbrMaterialAsync(B,u,F,Z,p,G){if(o(F,u),B.baseColor.equalsWithEpsilon(T,g)&&f.WithinEpsilon(u.alpha,1,g)||(Z.baseColorFactor=[B.baseColor.r,B.baseColor.g,B.baseColor.b,u.alpha]),null!=B.metallic&&1!==B.metallic&&(Z.metallicFactor=B.metallic),null!=B.roughness&&1!==B.roughness&&(Z.roughnessFactor=B.roughness),null==u.xR||u.xR||(u._twoSidedLighting||V.Tools.Warn(u.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),F.doubleSided=!0),G){const B=[],Z=u._bumpTexture;Z&&B.push(this.exportTextureAsync(Z,p).then((B=>{B&&(F.normalTexture=B,1!==Z.level&&(F.normalTexture.scale=Z.level))})));const V=u._ambientTexture;V&&B.push(this.exportTextureAsync(V,p).then((B=>{if(B){const Z={index:B.index,texCoord:B.texCoord,extensions:B.extensions};F.occlusionTexture=Z;const V=u._ambientTextureStrength;V&&(Z.strength=V)}})));const G=u._emissiveTexture;G&&B.push(this.exportTextureAsync(G,p).then((B=>{B&&(F.emissiveTexture=B)}))),B.length>0&&(this._exporter._materialNeedsUVsSet.add(u),await Promise.all(B))}const R=u._emissiveColor;R.equalsWithEpsilon(z,g)||(F.emissiveFactor=R.DR()),F.pbrMetallicRoughness=Z}_getPixelsFromTextureAsync(B){return function(B){switch(B){case y.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case y.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case y.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case y.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case y.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case y.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case y.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case y.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case y.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case y.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case y.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case y.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case y.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case y.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case y.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case y.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case y.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case y.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case y.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case y.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case y.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(B.textureFormat)?(0,C.h)(B,B._texture.width,B._texture.height):(B.textureType,y.d.TEXTURETYPE_UNSIGNED_BYTE,B.readPixels())}async exportTextureAsync(B,u){const F=this._exporter._extensionsPreExportTextureAsync("exporter",B,u);return F?await F.then((async F=>F?await this._exportTextureInfoAsync(F,u):await this._exportTextureInfoAsync(B,u))):await this._exportTextureInfoAsync(B,u)}async _exportTextureInfoAsync(B,u){let F=this._textureMap.get(B);if(!F){const Z=await this._getPixelsFromTextureAsync(B);if(!Z)return null;const p=this._exportTextureSampler(B),G=B.mimeType;if(G)switch(G){case"image/jpeg":case"image/png":case"image/webp":u=G;break;default:V.Tools.Warn(`Unsupported media type: ${G}. Exporting texture as PNG.`)}const R=this._internalTextureToImage,e=B.getInternalTexture().uniqueId;R[e]||(R[e]={});let s=R[e][u];if(void 0===s){const F=B.getSize();s=(async()=>{const V=await this._getImageDataAsync(Z,F.width,F.height,u);return this._exportImage(B.name,u,V)})(),R[e][u]=s}F=this._exportTextureInfo(await s,p,B.coordinatesIndex),this._textureMap.set(B,F),this._exporter._extensionsPostExportTextures("exporter",F,B)}return F}_exportImage(B,u,F){const Z=this._exporter._images;let p;if(this._exporter._shouldUseGlb){p={name:B,mimeType:u,bufferView:void 0};const Z=this._exporter._bufferManager.createBufferView(new Uint8Array(F));this._exporter._bufferManager.setBufferView(p,Z)}else{const G=B.replace(/\.\/|\/|\.\\|\\/g,"_"),R=function(B){switch(B){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(u);let e=G+R;Z.some((B=>B.uri===e))&&(e=`${G}_${V.Tools.RandomId()}${R}`),p={name:B,uri:e},this._exporter._imageData[e]={data:F,mimeType:u}}return Z.push(p),Z.length-1}_exportTextureInfo(B,u,F){const Z=this._exporter._textures;let V=Z.findIndex((F=>F.sampler==u&&F.source===B));-1===V&&(V=Z.length,Z.push({source:B,sampler:u}));const p={index:V};return F&&(p.texCoord=F),p}_exportTextureSampler(B){const u=this._getTextureSampler(B),F=this._exporter._samplers,Z=F.findIndex((B=>B.minFilter===u.minFilter&&B.magFilter===u.magFilter&&B.wrapS===u.wrapS&&B.wrapT===u.wrapT));return-1!==Z?Z:(F.push(u),F.length-1)}}var w=F(13064),H=F(12822),n=F(13452),d=F(12982);const l=Z.Du.Zero(),P=Z.Quaternion.Identity(),c=Z.Du.One(),h=new Z.Du(-1,1,1);function i(B,u){const{byteOffset:F,byteStride:Z,type:V,normalized:p}=B,G=B.getSize(),R=u.reduce(((B,u)=>u.getTotalVertices()>B?u.getTotalVertices():B),-Number.MAX_VALUE);return{byteOffset:F,byteStride:Z,componentCount:G,type:V,count:R*G,normalized:p,totalVertices:R,kind:B.getKind()}}function r(B){switch(B){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function K(B){switch(B){case Y.f.PositionKind:case Y.f.NormalKind:case Y.f.TangentKind:case Y.f.ColorKind:case Y.f.MatricesIndicesKind:case Y.f.MatricesIndicesExtraKind:case Y.f.MatricesWeightsKind:case Y.f.MatricesWeightsExtraKind:case Y.f.UVKind:case Y.f.UV2Kind:case Y.f.UV3Kind:case Y.f.UV4Kind:case Y.f.UV5Kind:case Y.f.UV6Kind:return!0}return!1}function N(B){switch(B){case p.c.TriangleFillMode:return 4;case p.c.TriangleStripDrawMode:return 5;case p.c.TriangleFanDrawMode:return 6;case p.c.PointListDrawMode:case p.c.PointFillMode:return 0;case p.c.LineLoopDrawMode:return 2;case p.c.LineListDrawMode:return 1;case p.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${B}`)}function A(B){const u=Math.sqrt(B.x*B.x+B.y*B.y+B.z*B.z);u>0&&(B.x/=u,B.y/=u,B.z/=u)}function b(B){return B.x*=-1,B}function k(B){if(B.x*B.x+B.y*B.y>.5){const u=Math.abs(B.x),F=Math.abs(B.y);if(u>F){const F=Math.sign(B.x);B.x=u,B.y*=-F,B.z*=-F,B.w*=F}else{const u=Math.sign(B.y);B.x*=-u,B.y=F,B.z*=u,B.w*=-u}}else{const u=Math.abs(B.z),F=Math.abs(B.w);if(u>F){const F=Math.sign(B.z);B.x*=-F,B.y*=F,B.z=u,B.w*=-F}else{const u=Math.sign(B.w);B.x*=u,B.y*=-u,B.z*=-u,B.w=F}}return B}function S(B){B.UR(-B.z,B.w,B.x,-B.y)}function BB(B,u){const F=Z.Du.FromArrayToRef(u.translation||[0,0,0],0,Z.TmpVectors.Du[0]),V=Z.Quaternion.FromArrayToRef(u.rotation||[0,0,0,1],0,Z.TmpVectors.Quaternion[0]),p=Z.Matrix.ComposeToRef(c,V,F,Z.TmpVectors.Matrix[0]),G=Z.Du.FromArrayToRef(B.translation||[0,0,0],0,Z.TmpVectors.Du[2]),R=Z.Quaternion.FromArrayToRef(B.rotation||[0,0,0,1],0,Z.TmpVectors.Quaternion[1]),e=Z.Matrix.ComposeToRef(c,R,G,Z.TmpVectors.Matrix[1]);p.multiplyToRef(e,e),e.decompose(void 0,V,F),F.equalsWithEpsilon(l,d.e)?delete u.translation:u.translation=F.DR(),V.equalsWithEpsilon(P,d.e)?delete u.rotation:u.rotation=V.DR(),u.scale&&delete u.scale}function uB(B,u){if(!(u instanceof Q.b))return!1;if(!(1===u.getChildren().length&&0===B.getChildren().length&&B.parent===u))return!1;const F=B.yB(),Z=B instanceof n.b&&!F.useRightHandedSystem?h:c;return!!u.yR.equalsWithEpsilon(Z,d.e)||(H.d.Warn(`Cannot collapse node ${B.name} into parent node ${u.name} with modified scaling.`),!1)}function FB(B){if(B instanceof Array){const u=new Float32Array(B);return new Uint8Array(u.buffer,u.byteOffset,u.byteLength)}return ArrayBuffer.isView(B)?new Uint8Array(B.buffer,B.byteOffset,B.byteLength):new Uint8Array(B)}function ZB(B,u){for(const[F,Z]of Object.entries(B)){const V=u[F];(Array.isArray(Z)&&Array.isArray(V)&&VB(Z,V)||Z===V)&&delete B[F]}return B}function VB(B,u){return B.length===u.length&&B.every(((B,F)=>B===u[F]))}const pB=Z.Matrix.Compose(new Z.Du(-1,1,1),Z.Quaternion.Identity(),Z.Du.Zero());function GB(B,u){if(!(B instanceof Q.b))return!1;if(u){if(!B.getWorldMatrix().equalsWithEpsilon(Z.Matrix.IdentityReadOnly,d.e))return!1}else{if(!B.getWorldMatrix().multiplyToRef(pB,Z.TmpVectors.Matrix[0]).equalsWithEpsilon(Z.Matrix.IdentityReadOnly,d.e))return!1}return!(B instanceof t.e&&B.fR)}const RB=new Map([[Int8Array,(B,u,F)=>B.setInt8(u,F)],[Uint8Array,(B,u,F)=>B.setUint8(u,F)],[Uint8ClampedArray,(B,u,F)=>B.setUint8(u,F)],[Int16Array,(B,u,F)=>B.setInt16(u,F,!0)],[Uint16Array,(B,u,F)=>B.setUint16(u,F,!0)],[Int32Array,(B,u,F)=>B.setInt32(u,F,!0)],[Uint32Array,(B,u,F)=>B.setUint32(u,F,!0)],[Float32Array,(B,u,F)=>B.setFloat32(u,F,!0)],[Float64Array,(B,u,F)=>B.setFloat64(u,F,!0)]]);class eB{writeTypedArray(B){this._checkGrowBuffer(B.byteLength);const u=RB.get(B.constructor);for(let F=0;F<B.length;F++)u(this._dataView,this._byteOffset,B[F]),this._byteOffset+=B.BYTES_PER_ELEMENT}constructor(B){this._data=new Uint8Array(B),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(B){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,B),this._byteOffset++}writeInt8(B){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,B),this._byteOffset++}writeInt16(B){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,B,!0),this._byteOffset+=2}writeUInt16(B){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,B,!0),this._byteOffset+=2}writeInt32(B){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,B,!0),this._byteOffset+=4}writeUInt32(B){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,B,!0),this._byteOffset+=4}writeFloat32(B){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,B,!0),this._byteOffset+=4}writeFloat64(B){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,B,!0),this._byteOffset+=8}_checkGrowBuffer(B){const u=this.byteOffset+B;if(u>this._data.byteLength){const B=new Uint8Array(2*u);B.set(this._data),this._data=B,this._dataView=new DataView(this._data.buffer)}}}function sB(B){return B%4===0?4:B%2===0?2:1}class YB{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(B){let u=0;this._bufferViewToData.forEach((B=>{u+=B.byteLength}));const F=new eB(u),Z=Array.from(this._bufferViewToData.keys()).sort(((B,u)=>sB(u.byteLength)-sB(B.byteLength)));for(const V of Z){V.byteOffset=F.byteOffset,B.push(V);const u=B.length-1,Z=this.getPropertiesWithBufferView(V);for(const B of Z)B.bufferView=u;F.writeTypedArray(this._bufferViewToData.get(V)),this._bufferViewToData.delete(V)}return F.getOutputData()}createBufferView(B,u){const F={buffer:0,byteOffset:void 0,byteLength:B.byteLength,byteStride:u};return this._bufferViewToData.set(F,B),F}createAccessor(B,u,F,Z,V,p,G){this._verifyBufferView(B);const R={bufferView:void 0,componentType:F,count:Z,type:u,min:null===p||void 0===p?void 0:p.min,max:null===p||void 0===p?void 0:p.max,normalized:G,byteOffset:V};return this.setBufferView(R,B),this._accessorToBufferView.set(R,B),R}setBufferView(B,u){this._verifyBufferView(u);this.getPropertiesWithBufferView(u).push(B)}removeBufferView(B){const u=this.getPropertiesWithBufferView(B);for(const F of u)void 0!==F.bufferView&&delete F.bufferView;this._bufferViewToData.delete(B),this._bufferViewToProperties.delete(B),this._accessorToBufferView.forEach(((u,F)=>{u===B&&(void 0!==F.byteOffset&&delete F.byteOffset,this._accessorToBufferView.delete(F))}))}getBufferView(B){const u=this._accessorToBufferView.get(B);return this._verifyBufferView(u),u}getPropertiesWithBufferView(B){return this._verifyBufferView(B),this._bufferViewToProperties.set(B,this._bufferViewToProperties.get(B)??[]),this._bufferViewToProperties.get(B)}getData(B){return this._verifyBufferView(B),this._bufferViewToData.get(B)}_verifyBufferView(B){if(void 0===B||!this._bufferViewToData.has(B))throw new Error(`BufferView ${B} not found in BufferManager.`)}}var QB,tB=F(13414),vB=F(13433),DB=F(13460),LB=F(13359),qB=F(13488),WB=F(13504),XB=F(13409),fB=F(13508);!function(B){B[B.INTANGENT=0]="INTANGENT",B[B.OUTTANGENT=1]="OUTTANGENT"}(QB||(QB={}));class CB{static _IsTransformable(B){return B&&(B instanceof Q.b||B instanceof tB.d||B instanceof fB.c)}static _CreateNodeAnimation(B,u,F,Z,p){if(this._IsTransformable(B)){const G=[],R=[],e=u.getKeys(),s=CB._CalculateMinMaxKeyFrames(e),Y=CB._DeduceInterpolation(e,F,Z),Q=Y.interpolationType,t=Y.shouldBakeAnimation;if(t?CB._CreateBakedAnimation(B,u,F,s.min,s.max,u.framePerSecond,p,G,R,s,Z):"LINEAR"===Q||"STEP"===Q?CB._CreateLinearOrStepAnimation(B,u,F,G,R,Z):"CUBICSPLINE"===Q?CB._CreateCubicSplineAnimation(B,u,F,G,R,Z):CB._CreateBakedAnimation(B,u,F,s.min,s.max,u.framePerSecond,p,G,R,s,Z),G.length&&R.length){return{inputs:G,outputs:R,samplerInterpolation:Q,inputsMin:t?s.min:V.Tools.FloatRound(s.min/u.framePerSecond),inputsMax:t?s.max:V.Tools.FloatRound(s.max/u.framePerSecond)}}}return null}static _DeduceAnimationInfo(B){let u=null,F="VEC3",Z=!1;const p=B.targetProperty.split(".");switch(p[0]){case"yR":u="scale";break;case"position":u="translation";break;case"rotation":F="VEC4",u="rotation";break;case"rotationQuaternion":F="VEC4",Z=!0,u="rotation";break;case"influence":F="SCALAR",u="weights";break;default:V.Tools.Error(`Unsupported animatable property ${p[0]}`)}return u?{animationChannelTargetPath:u,dataAccessorType:F,useQuaternion:Z}:(V.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(B,u,F,Z,V,p,G,R,e,s,Y){let Q;if(CB._IsTransformable(B)&&B.animations)for(const t of B.animations){if(Y&&!Y(t))continue;const V=CB._DeduceAnimationInfo(t);V&&(Q={name:t.name,samplers:[],channels:[]},CB._AddAnimation(`${t.name}`,t.hasRunningRuntimeAnimations?u:Q,B,t,V.dataAccessorType,V.animationChannelTargetPath,Z,p,G,R,V.useQuaternion,e,s),Q.samplers.length&&Q.channels.length&&F.push(Q))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(B,u,F,Z,V,p,G,R,e,s,Y){let Q;if(B instanceof XB.b){const V=B.morphTargetManager;if(V)for(let t=0;t<V.numTargets;++t){const v=V.getTarget(t);for(const D of v.animations){if(Y&&!Y(D))continue;const v=new qB.e(`${D.name}`,"influence",D.framePerSecond,D.dataType,D.loopMode,D.enableBlending),L=[],q=D.getKeys();for(let B=0;B<q.length;++B){const u=q[B];for(let B=0;B<V.numTargets;++B)B==t?L.push(u):L.push({frame:u.frame,value:0})}v.setKeys(L);const W=CB._DeduceAnimationInfo(v);W&&(Q={name:v.name,samplers:[],channels:[]},CB._AddAnimation(D.name,D.hasRunningRuntimeAnimations?u:Q,B,v,W.dataAccessorType,W.animationChannelTargetPath,Z,p,G,R,W.useQuaternion,e,s,V.numTargets),Q.samplers.length&&Q.channels.length&&F.push(Q))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(B,u,F,Z,V,p,G,R,e){let s;if(B.animationGroups){const Q=B.animationGroups;for(const t of Q){const Q=new Map,v=new Map,D=new Set,L=t.to-t.from;s={name:t.name,channels:[],samplers:[]};for(let u=0;u<t.targetedAnimations.length;++u){const L=t.targetedAnimations[u],q=L.target,W=L.animation;if(e&&!e(W))continue;const X=R.has(q);if(this._IsTransformable(q)||1===q.length&&this._IsTransformable(q[0])){const B=CB._DeduceAnimationInfo(L.animation);if(B){const u=this._IsTransformable(q)?q:this._IsTransformable(q[0])?q[0]:null;u&&CB._AddAnimation(`${W.name}`,s,u,W,B.dataAccessorType,B.animationChannelTargetPath,F,Z,V,p,B.useQuaternion,G,X)}}else if(q instanceof WB.c||1===q.length&&q[0]instanceof WB.c){if(CB._DeduceAnimationInfo(L.animation)){const u=q instanceof WB.c?q:q[0];if(u){const F=B.morphTargetManagers.find((B=>{for(let F=0;F<B.numTargets;++F)if(B.getTarget(F)===u)return!0;return!1}));if(F){const Z=B.meshes.find((B=>B.morphTargetManager===F));var Y;if(Z)Q.has(Z)||Q.set(Z,new Map),null===(Y=Q.get(Z))||void 0===Y||Y.set(u,W),D.add(Z),v.set(Z,W)}}}}}D.forEach((B=>{const u=B.morphTargetManager;let R=null;const e=[],Y=v.get(B).getKeys(),D=Y.length;for(let F=0;F<D;++F)for(let Z=0;Z<u.numTargets;++Z){const V=u.getTarget(Z),p=Q.get(B);if(p){const u=p.get(V);u?(R||(R=new qB.e(`${t.name}_${B.name}_MorphWeightAnimation`,"influence",u.framePerSecond,qB.e.ANIMATIONTYPE_FLOAT,u.loopMode,u.enableBlending)),e.push(u.getKeys()[F])):e.push({frame:t.from+L/D*F,value:V.influence,inTangent:Y[0].inTangent?0:void 0,outTangent:Y[0].outTangent?0:void 0})}}R.setKeys(e);const q=CB._DeduceAnimationInfo(R);q&&CB._AddAnimation(`${t.name}_${B.name}_MorphWeightAnimation`,s,B,R,q.dataAccessorType,q.animationChannelTargetPath,F,Z,V,p,q.useQuaternion,G,!1,null===u||void 0===u?void 0:u.numTargets)})),s.channels.length&&s.samplers.length&&u.push(s)}}}static _AddAnimation(B,u,F,V,p,G,R,e,s,Y,Q,t,v,D){const L=CB._CreateNodeAnimation(F,V,G,Q,t);let q,W,X,f,C,x;if(L){if(D){let B=0,u=0;const F=[];for(;L.inputs.length>0;)u=L.inputs.shift(),B%D==0&&F.push(u),B++;L.inputs=F}const B=R.get(F),V=new Float32Array(L.inputs);q=e.createBufferView(V),W=e.createAccessor(q,"SCALAR",5126,L.inputs.length,void 0,{min:[L.inputsMin],max:[L.inputsMax]}),Y.push(W),X=Y.length-1;const s=new Z.Quaternion,Q=new Z.Du,t=new Z.Du,U=F instanceof tB.d,y=r(p),O=new Float32Array(L.outputs.length*y);L.outputs.forEach((function(B,u){let F=B;switch(G){case"translation":v&&(Z.Du.FromArrayToRef(B,0,t),b(t),t.toArray(F));break;case"rotation":4===B.length?Z.Quaternion.FromArrayToRef(B,0,s):(F=new Array(4),Z.Du.FromArrayToRef(B,0,Q),Z.Quaternion.FromEulerVectorToRef(Q,s)),v&&(k(s),U&&S(s)),s.toArray(F)}O.set(F,u*y)})),q=e.createBufferView(O),W=e.createAccessor(q,p,5126,L.outputs.length),Y.push(W),f=Y.length-1,C={interpolation:L.samplerInterpolation,input:X,output:f},u.samplers.push(C),x={sampler:u.samplers.length-1,target:{node:B,path:G}},u.channels.push(x)}}static _CreateBakedAnimation(B,u,F,p,G,R,e,s,Y,Q,t){let v;const D=Z.Quaternion.Identity();let L,q=null,W=null,X=null,f=null,C=null,x=null;Q.min=V.Tools.FloatRound(p/R);const U=u.getKeys();for(let Z=0,y=U.length;Z<y;++Z){if(x=null,X=U[Z],Z+1<y)if(f=U[Z+1],X.value.equals&&X.value.equals(f.value)||X.value===f.value){if(0!==Z)continue;x=X.frame}else x=f.frame;else{if(C=U[Z-1],X.value.equals&&X.value.equals(C.value)||X.value===C.value)continue;x=G}if(x)for(let Z=X.frame;Z<=x;Z+=e){if(L=V.Tools.FloatRound(Z/R),L===q)continue;q=L,W=L;const p={key:0,repeatCount:0,loopMode:u.loopMode};v=u._interpolate(Z,p),CB._SetInterpolatedValue(B,v,L,u,F,D,s,Y,t)}}W&&(Q.max=W)}static _ConvertFactorToVector3OrQuaternion(B,u,F,p,G){const R=CB._GetBasePositionRotationOrScale(u,p,G),e=F.targetProperty.split("."),s=e?e[1]:"",Y=G?Z.Quaternion.fu(R).normalize():Z.Du.fu(R);switch(s){case"x":case"y":case"z":Y[s]=B;break;case"w":Y.w=B;break;default:V.Tools.Error(`glTFAnimation: Unsupported component name "${s}"!`)}return Y}static _SetInterpolatedValue(B,u,F,V,p,G,R,e,s){let Y;R.push(F),"weights"!==p?(V.dataType===qB.e.ANIMATIONTYPE_FLOAT&&(u=this._ConvertFactorToVector3OrQuaternion(u,B,V,p,s)),"rotation"===p?(s?G=u:(Y=u,Z.Quaternion.RotationYawPitchRollToRef(Y.y,Y.x,Y.z,G)),e.push(G.DR())):(Y=u,e.push(Y.DR()))):e.push([u])}static _CreateLinearOrStepAnimation(B,u,F,Z,V,p){for(const G of u.getKeys())Z.push(G.frame/u.framePerSecond),CB._AddKeyframeValue(G,u,V,F,B,p)}static _CreateCubicSplineAnimation(B,u,F,Z,V,p){u.getKeys().forEach((function(G){Z.push(G.frame/u.framePerSecond),CB._AddSplineTangent(QB.INTANGENT,V,F,"CUBICSPLINE",G,p),CB._AddKeyframeValue(G,u,V,F,B,p),CB._AddSplineTangent(QB.OUTTANGENT,V,F,"CUBICSPLINE",G,p)}))}static _GetBasePositionRotationOrScale(B,u,F){let V;if("rotation"===u)if(F){V=(B.rotationQuaternion??Z.Quaternion.Identity()).DR()}else{V=(B.rotation??Z.Du.Zero()).DR()}else if("translation"===u){V=(B.position??Z.Du.Zero()).DR()}else{V=(B.yR??Z.Du.One()).DR()}return V}static _AddKeyframeValue(B,u,F,p,G,R){let e;const s=u.dataType;if(s===qB.e.ANIMATIONTYPE_VECTOR3){let u=B.value.DR();if("rotation"===p){const B=Z.Du.fu(u);u=Z.Quaternion.RotationYawPitchRoll(B.y,B.x,B.z).DR()}F.push(u)}else if(s===qB.e.ANIMATIONTYPE_FLOAT){if("weights"===p)F.push([B.value]);else if(e=this._ConvertFactorToVector3OrQuaternion(B.value,G,u,p,R),e){if("rotation"===p){const B=R?e:Z.Quaternion.RotationYawPitchRoll(e.y,e.x,e.z).normalize();F.push(B.DR())}F.push(e.DR())}}else s===qB.e.ANIMATIONTYPE_QUATERNION?F.push(B.value.normalize().DR()):V.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(B,u,F){let Z,V,p=!1;if("rotation"===u&&!F)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let G=0,R=B.length;G<R;++G)if(V=B[G],V.inTangent||V.outTangent)if(Z){if("CUBICSPLINE"!==Z){Z="LINEAR",p=!0;break}}else Z="CUBICSPLINE";else if(Z){if("CUBICSPLINE"===Z||V.interpolation&&1===V.interpolation&&"STEP"!==Z){Z="LINEAR",p=!0;break}}else Z=V.interpolation&&1===V.interpolation?"STEP":"LINEAR";return Z||(Z="LINEAR"),{interpolationType:Z,shouldBakeAnimation:p}}static _AddSplineTangent(B,u,F,V,p,G){let R;const e=B===QB.INTANGENT?p.inTangent:p.outTangent;if("CUBICSPLINE"===V){if("rotation"===F)if(e)if(G)R=e.DR();else{const B=e;R=Z.Quaternion.RotationYawPitchRoll(B.y,B.x,B.z).DR()}else R=[0,0,0,0];else R="weights"===F?e?[e]:[0]:e?e.DR():[0,0,0];u.push(R)}}static _CalculateMinMaxKeyFrames(B){let u=1/0,F=-1/0;return B.forEach((function(B){u=Math.min(u,B.frame),F=Math.max(F,B.frame)})),{min:u,max:F}}}function xB(B,u,F,p,G,R){const e={attributes:{},influence:B.influence,name:B.name},s=u.fR;if(!s)return V.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),e;const Q=R?-1:1,t=Z.Du.Zero();let v=0,D=0;if(B.hasPositions){const p=B.getPositions(),R=s.getVerticesData(Y.f.PositionKind);if(R){const B=new Float32Array(R.length),u=[1/0,1/0,1/0],V=[-1/0,-1/0,-1/0];D=R.length/3,v=0;for(let F=v;F<D;++F){const G=Z.Du.fu(R,3*F);Z.Du.fu(p,3*F).subtractToRef(G,t),t.x*=Q,u[0]=Math.min(u[0],t.x),V[0]=Math.max(V[0],t.x),u[1]=Math.min(u[1],t.y),V[1]=Math.max(V[1],t.y),u[2]=Math.min(u[2],t.z),V[2]=Math.max(V[2],t.z),B[3*F]=t.x,B[3*F+1]=t.y,B[3*F+2]=t.z}const s=F.createBufferView(B,12),Y=F.createAccessor(s,"VEC3",5126,p.length/3,0,{min:u,max:V});G.push(Y),e.attributes.POSITION=G.length-1}else V.Tools.Warn(`Morph target positions for mesh ${u.name} were not exported. Mesh does not have position vertex data`)}if(B.hasNormals){const p=B.getNormals(),R=s.getVerticesData(Y.f.NormalKind);if(R){const B=new Float32Array(R.length);D=R.length/3,v=0;for(let F=v;F<D;++F){const u=Z.Du.fu(R,3*F).normalize();Z.Du.fu(p,3*F).normalize().subtractToRef(u,t),B[3*F]=t.x*Q,B[3*F+1]=t.y,B[3*F+2]=t.z}const u=F.createBufferView(B,12),V=F.createAccessor(u,"VEC3",5126,p.length/3,0);G.push(V),e.attributes.NORMAL=G.length-1}else V.Tools.Warn(`Morph target normals for mesh ${u.name} were not exported. Mesh does not have normals vertex data`)}if(B.hasTangents){const p=B.getTangents(),R=s.getVerticesData(Y.f.TangentKind);if(R){D=R.length/4;const B=new Float32Array(3*D);v=0;for(let F=v;F<D;++F){const u=Z.Du.fu(R,4*F);A(u);const V=Z.Du.fu(p,3*F);A(V),V.subtractToRef(u,t),B[3*F]=t.x*Q,B[3*F+1]=t.y,B[3*F+2]=t.z}const u=F.createBufferView(B,12),V=F.createAccessor(u,"VEC3",5126,D,0);G.push(V),e.attributes.TANGENT=G.length-1}else V.Tools.Warn(`Morph target tangents for mesh ${u.name} were not exported. Mesh does not have tangents vertex data`)}if(B.hasColors){const p=B.getColors(),R=s.getVerticesData(Y.f.ColorKind),Q=s.getVertexBuffer(Y.f.ColorKind);if(R&&Q){const B=Q.getSize();D=R.length/B;const u=new Float32Array(D*B);v=0;for(let F=v;F<D;++F)if(3===B){const V=Z.Du.fu(R,F*B);Z.Du.fu(p,F*B).subtractToRef(V,t),u[3*F]=t.x,u[3*F+1]=t.y,u[3*F+2]=t.z}else if(4===B){const V=new Z.Vector4,G=Z.Vector4.fu(R,F*B);Z.Vector4.fu(p,F*B).subtractToRef(G,V),u[4*F]=V.x,u[4*F+1]=V.y,u[4*F+2]=V.z,u[4*F+3]=V.w}else V.Tools.Warn(`Unsupported number of components for color attribute: ${B}`);const s=F.createBufferView(u,4*B),Y=F.createAccessor(s,3===B?"VEC3":"VEC4",5126,D,0);G.push(Y),e.attributes.COLOR_0=G.length-1}else V.Tools.Warn(`Morph target colors for mesh ${u.name} were not exported. Mesh does not have colors vertex data`)}return e}var UB=F(13517),yB=F(13377),OB=F(13364),gB=F(12949);class JB{}JB.DEFAULT_COLOR=q.Xu.White(),JB.DEFAULT_WIDTH_ATTENUATED=1,JB.DEFAULT_WIDTH=.1;var aB=F(13199),TB=F(13522);class zB{static ConvertPoints(B,u){if(B.length&&Array.isArray(B)&&"number"===typeof B[0])return[B];if(B.length&&Array.isArray(B[0])&&"number"===typeof B[0][0])return B;if(B.length&&!Array.isArray(B[0])&&B[0]instanceof Z.Du){const u=[];for(let F=0;F<B.length;F++){const Z=B[F];u.push(Z.x,Z.y,Z.z)}return[u]}if(B.length>0&&Array.isArray(B[0])&&B[0].length>0&&B[0][0]instanceof Z.Du){const u=[],F=B;for(const B of F)u.push(B.flatMap((B=>[B.x,B.y,B.z])));return u}if(B instanceof Float32Array){if(null!==u&&void 0!==u&&u.floatArrayStride){const F=[],Z=3*u.floatArrayStride;for(let u=0;u<B.length;u+=Z){const V=new Array(Z);for(let F=0;F<Z;F++)V[F]=B[u+F];F.push(V)}return F}return[Array.from(B)]}if(B.length&&B[0]instanceof Float32Array){const u=[];for(const F of B)u.push(Array.from(F));return u}return[]}static OmitZeroLengthPredicate(B,u,F){const Z=[];return u.Lu(B).lengthSquared()>0&&Z.push([B,u]),F.Lu(u).lengthSquared()>0&&Z.push([u,F]),B.Lu(F).lengthSquared()>0&&Z.push([F,B]),0===Z.length?null:Z}static OmitDuplicatesPredicate(B,u,F,Z){const V=[];return zB._SearchInPoints(B,u,Z)||V.push([B,u]),zB._SearchInPoints(u,F,Z)||V.push([u,F]),zB._SearchInPoints(F,B,Z)||V.push([F,B]),0===V.length?null:V}static _SearchInPoints(B,u,F){for(const G of F)for(let F=0;F<G.length;F++){var Z,V,p;if(null!==(Z=G[F])&&void 0!==Z&&Z.equals(B))if(null!==(V=G[F+1])&&void 0!==V&&V.equals(u)||null!==(p=G[F-1])&&void 0!==p&&p.equals(u))return!0}return!1}static MeshesToLines(B,u){const F=[];for(let V=0;V<B.length;V++){const p=B[V],G=p.getVerticesData(Y.f.PositionKind),R=p.CR();if(G&&R)for(let B=0,e=0;B<R.length;B++){const s=3*R[e++],Y=3*R[e++],Q=3*R[e++],t=new Z.Du(G[s],G[s+1],G[s+2]),v=new Z.Du(G[Y],G[Y+1],G[Y+2]),D=new Z.Du(G[Q],G[Q+1],G[Q+2]);if(u){const Z=u(t,v,D,F,B,s,p,V,G,R);if(Z)for(const B of Z)F.push(B)}else F.push([t,v],[v,D],[D,t])}}return F}static ToVector3Array(B){if(Array.isArray(B[0])){const u=[],F=B;for(const B of F){const F=[];for(let u=0;u<B.length;u+=3)F.push(new Z.Du(B[u],B[u+1],B[u+2]));u.push(F)}return u}const u=B,F=[];for(let V=0;V<u.length;V+=3)F.push(new Z.Du(u[V],u[V+1],u[V+2]));return F}static ToNumberArray(B){return B.flatMap((B=>[B.x,B.y,B.z]))}static GetPointsCountInfo(B){const u=new Array(B.length);let F=0;for(let Z=B.length;Z--;)u[Z]=B[Z].length/3,F+=u[Z];return{total:F,counts:u}}static GetLineLength(B){if(0===B.length)return 0;let u;u="number"===typeof B[0]?zB.ToVector3Array(B):B;const F=Z.TmpVectors.Du[0];let V=0;for(let Z=0;Z<u.length-1;Z++){const B=u[Z];V+=u[Z+1].subtractToRef(B,F).length()}return V}static GetLineLengthArray(B){const u=new Float32Array(B.length/3);let F=0;for(let Z=0,V=B.length/3-1;Z<V;Z++){let V=B[3*Z+0],p=B[3*Z+1],G=B[3*Z+2];V-=B[3*Z+3],p-=B[3*Z+4],G-=B[3*Z+5];F+=Math.sqrt(V*V+p*p+G*G),u[Z+1]=F}return u}static SegmentizeSegmentByCount(B,u,F){const V=[],p=u.Lu(B),G=Z.TmpVectors.Du[0];G.OR(F);const R=Z.TmpVectors.Du[1];p.divideToRef(G,R);let e=B.clone();V.push(e);for(let Z=0;Z<F;Z++)e=e.clone(),V.push(e.addInPlace(R));return V}static SegmentizeLineBySegmentLength(B,u){const F=B[0]instanceof Z.Du?zB.GetLineSegments(B):"number"===typeof B[0]?zB.GetLineSegments(zB.ToVector3Array(B)):B,V=[];for(const Z of F)if(Z.length>u){const B=zB.SegmentizeSegmentByCount(Z.point1,Z.point2,Math.ceil(Z.length/u));for(const u of B)V.push(u)}else V.push(Z.point1),V.push(Z.point2);return V}static SegmentizeLineBySegmentCount(B,u){const F="number"===typeof B[0]?zB.ToVector3Array(B):B,Z=zB.GetLineLength(F)/u;return zB.SegmentizeLineBySegmentLength(F,Z)}static GetLineSegments(B){const u=[];for(let F=0;F<B.length-1;F++){const Z=B[F],V=B[F+1],p=V.Lu(Z).length();u.push({point1:Z,point2:V,length:p})}return u}static GetMinMaxSegmentLength(B){const u=zB.GetLineSegments(B).sort((B=>B.length));return{min:u[0].length,max:u[u.length-1].length}}static GetPositionOnLineByVisibility(B,u,F){let V=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const p=u*F;let G=0,R=0;const e=B.length;for(let Z=0;Z<e;Z++){if(p<=G+B[Z].length){R=Z;break}G+=B[Z].length}const s=(p-G)/B[R].length;return B[R].point2.subtractToRef(B[R].point1,Z.TmpVectors.Du[0]),Z.TmpVectors.Du[1]=Z.TmpVectors.Du[0].multiplyByFloats(s,s,s),V||Z.TmpVectors.Du[1].addInPlace(B[R].point1),Z.TmpVectors.Du[1].clone()}static GetCircleLinePoints(B,u){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:B,p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/u;const G=[];for(let R=0;R<=u;R++)G.push(new Z.Du(Math.cos(R*p)*B,Math.sin(R*p)*V,F));return G}static GetBezierLinePoints(B,u,F,Z){return aB.e.CreateQuadraticBezier(B,u,F,Z).getPoints().flatMap((B=>[B.x,B.y,B.z]))}static GetArrowCap(B,u,F,Z,V){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,G=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[B.clone(),B.add(u.multiplyByFloats(F,F,F))],widths:[Z,V,p,G]}}static GetPointsFromText(B,u,F,Z){let V=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const G=[],R=(0,TB.e)(B,u,F,Z);for(const e of R){for(const B of e.paths){const u=[],F=B.getPoints();for(const B of F)u.push(B.x,B.y,V);G.push(u)}if(p)for(const B of e.holes){const u=[],F=B.getPoints();for(const B of F)u.push(B.x,B.y,V);G.push(u)}}return G}static Color3toRGBAUint8(B){const u=new Uint8Array(4*B.length);for(let F=0,Z=0;F<B.length;F++)u[Z++]=255*B[F].r,u[Z++]=255*B[F].g,u[Z++]=255*B[F].b,u[Z++]=255;return u}static CreateColorsTexture(B,u,F,Z){const V=Z.getEngine().getCaps().maxTextureSize??1,p=u.length>V?V:u.length,G=Math.ceil(u.length/V);G>1&&(u=[...u,...Array(p*G-u.length).fill(u[0])]);const R=zB.Color3toRGBAUint8(u),e=new U.b(R,p,G,D.b.TEXTUREFORMAT_RGBA,Z,!1,!0,F);return e.name=B,e}static PrepareEmptyColorsTexture(B){if(!JB.EmptyColorsTexture){const u=new Uint8Array(4);JB.EmptyColorsTexture=new U.b(u,1,1,D.b.TEXTUREFORMAT_RGBA,B,!1,!1,U.b.NEAREST_NEAREST),JB.EmptyColorsTexture.name="grlEmptyColorsTexture"}return JB.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var B;null===(B=JB.EmptyColorsTexture)||void 0===B||B.dispose(),JB.EmptyColorsTexture=null}static BooleanToNumber(B){return B?1:0}}class MB extends OB.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class jB extends yB.b{isCompatible(B){return!0}constructor(B,u,F){var V;F=F||{color:JB.DEFAULT_COLOR};const p=new MB;p.GREASED_LINE_HAS_COLOR=!!F.color&&!F.useColors,p.GREASED_LINE_SIZE_ATTENUATION=F.sizeAttenuation??!1,p.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===F.colorDistributionType,p.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(u??B.yB()).useRightHandedSystem,p.GREASED_LINE_CAMERA_FACING=F.cameraFacing??!0,super(B,jB.GREASED_LINE_MATERIAL_NAME,200,p,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(V=F)||void 0===V?void 0:V.forceGLSL)||jB.ForceGLSL,this._scene=u??B.yB(),this._engine=this._scene.getEngine(),this._cameraFacing=F.cameraFacing??!0,this.visibility=F.visibility??1,this.useDash=F.useDash??!1,this.dashRatio=F.dashRatio??.5,this.dashOffset=F.dashOffset??0,this.width=F.width?F.width:F.sizeAttenuation?JB.DEFAULT_WIDTH_ATTENUATED:JB.DEFAULT_WIDTH,this._sizeAttenuation=F.sizeAttenuation??!1,this.colorMode=F.colorMode??0,this._color=F.color??null,this.useColors=F.useColors??!1,this._colorsDistributionType=F.colorDistributionType??0,this.colorsSampling=F.colorsSampling??U.b.NEAREST_NEAREST,this._colors=F.aB??null,this.dashCount=F.dashCount??1,this.resolution=F.resolution??new Z.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),F.colorsTexture?this.colorsTexture=F.colorsTexture:this._colors?this.colorsTexture=zB.CreateColorsTexture(`${B.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??JB.DEFAULT_COLOR,zB.PrepareEmptyColorsTexture(this._scene)),this._engine.GR.add((()=>{zB.DisposeEmptyColorsTexture()}))}getAttributes(B){B.push("grl_offsets"),B.push("grl_widths"),B.push("grl_colorPointers"),B.push("grl_counters"),this._cameraFacing?(B.push("grl_previousAndSide"),B.push("grl_nextAndCounters")):B.push("grl_slopes")}getSamplers(B){B.push("grl_colors")}getActiveTextures(B){this.colorsTexture&&B.push(this.colorsTexture)}getUniforms(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const u=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&u.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===B&&u.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:u,vertex:this._cameraFacing&&this._isGLSL(B)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(B)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(B){if(this._cameraFacing){B.WR("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||B.WR("viewProjection",this._scene.getTransformMatrix());const u=Z.TmpVectors.Vector4[0];u.x=this._aspect,u.y=this._resolution.x,u.z=this._resolution.y,u.w=this.width,B.updateVector4("grl_aspect_resolution_lineWidth",u)}const u=Z.TmpVectors.Vector4[0];u.x=zB.BooleanToNumber(this.useDash),u.y=this._dashArray,u.z=this.dashOffset,u.w=this.dashRatio,B.updateVector4("grl_dashOptions",u);const F=Z.TmpVectors.Vector4[1];F.x=this.colorMode,F.y=this.visibility,F.z=this.colorsTexture?this.colorsTexture.getSize().width:0,F.w=zB.BooleanToNumber(this.useColors),B.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",F),this._color&&B.updateColor3("grl_singleColor",this._color);const V=this.colorsTexture??JB.EmptyColorsTexture;B.setTexture("grl_colors",V),B.updateFloat2("grl_textureSize",(null===V||void 0===V?void 0:V.getSize().width)??1,(null===V||void 0===V?void 0:V.getSize().height)??1)}prepareDefines(B,u,F){B.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,B.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,B.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,B.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=u.useRightHandedSystem,B.GREASED_LINE_CAMERA_FACING=this._cameraFacing,B.GREASED_LINE_USE_OFFSETS=!!F.offsets}getClassName(){return jB.GREASED_LINE_MATERIAL_NAME}getCustomCode(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(u)?function(B,u){if("vertex"===B){const B={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return u&&(B["!gl_Position\\=viewProjection\\*worldPos;"]="//"),B}return"fragment"===B?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(B,this._cameraFacing):function(B,u){if("vertex"===B){const B={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return u&&(B["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),B}return"fragment"===B?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(B,this._cameraFacing)}dispose(){var B;null===(B=this.colorsTexture)||void 0===B||B.dispose(),super.dispose()}get aB(){return this._colors}set aB(B){this.setColors(B)}setColors(B){var u;let F=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const V=(null===(u=this._colors)||void 0===u?void 0:u.length)??0;var p;if(this._colors=B,null!==B&&0!==B.length){if(!F||Z)if(this.colorsTexture&&V===B.length&&!Z){const u=zB.Color3toRGBAUint8(B);this.colorsTexture.update(u)}else{var G;null===(G=this.colorsTexture)||void 0===G||G.dispose(),this.colorsTexture=zB.CreateColorsTexture(`${this._material.name}-colors-texture`,B,this.colorsSampling,this._scene)}}else null===(p=this.colorsTexture)||void 0===p||p.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(B){this._dashCount=B,this._dashArray=1/B}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(B){this._sizeAttenuation=B,this.markAllDefinesAsDirty()}get color(){return this._color}set color(B){this.setColor(B)}setColor(B){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==B||null!==this._color&&null===B?(this._color=B,u||this.markAllDefinesAsDirty()):this._color=B}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(B){this._colorsDistributionType=B,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(B){this._aspect=B.x/B.y,this._resolution=B}serialize(){const B=super.serialize(),u={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(u.aB=this._colors),this._color&&(u.color=this._color),B.greasedLineMaterialOptions=u,B}parse(B,u,F){var Z;super.parse(B,u,F);const V=B.greasedLineMaterialOptions;null===(Z=this.colorsTexture)||void 0===Z||Z.dispose(),V.color&&this.setColor(V.color,!0),V.colorDistributionType&&(this.colorsDistributionType=V.colorDistributionType),V.aB&&(this.aB=V.aB),V.colorsSampling&&(this.colorsSampling=V.colorsSampling),V.colorMode&&(this.colorMode=V.colorMode),V.useColors&&(this.useColors=V.useColors),V.visibility&&(this.visibility=V.visibility),V.useDash&&(this.useDash=V.useDash),V.dashCount&&(this.dashCount=V.dashCount),V.dashRatio&&(this.dashRatio=V.dashRatio),V.dashOffset&&(this.dashOffset=V.dashOffset),V.width&&(this.width=V.width),V.sizeAttenuation&&(this.sizeAttenuation=V.sizeAttenuation),V.resolution&&(this.resolution=V.resolution),this.aB?this.colorsTexture=zB.CreateColorsTexture(`${this._material.name}-colors-texture`,this.aB,this.colorsSampling,u):zB.PrepareEmptyColorsTexture(u),this.markAllDefinesAsDirty()}copyTo(B){var u;const F=B;null===(u=F.colorsTexture)||void 0===u||u.dispose(),this._colors&&(F.colorsTexture=zB.CreateColorsTexture(`${F._material.name}-colors-texture`,this._colors,F.colorsSampling,this._scene)),F.setColor(this.color,!0),F.colorsDistributionType=this.colorsDistributionType,F.colorsSampling=this.colorsSampling,F.colorMode=this.colorMode,F.useColors=this.useColors,F.visibility=this.visibility,F.useDash=this.useDash,F.dashCount=this.dashCount,F.dashRatio=this.dashRatio,F.dashOffset=this.dashOffset,F.width=this.width,F.sizeAttenuation=this.sizeAttenuation,F.resolution=this.resolution,F.markAllDefinesAsDirty()}_isGLSL(B){return 0===B||this._forceGLSL}}jB.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",jB.ForceGLSL=!1,(0,gB.f)(`BABYLON.${jB.GREASED_LINE_MATERIAL_NAME}`,jB);var oB=F(13398),IB=F(12830),mu=F(13219),EB=F(12932);class wB extends mu.ShaderMaterial{constructor(B,u,V){const p=u.getEngine(),G=p.isWebGPU&&!(V.forceGLSL||wB.ForceGLSL),R=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];u.useRightHandedSystem&&R.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const e=["position","grl_widths","grl_offsets","grl_colorPointers"];V.cameraFacing?(R.push("GREASED_LINE_CAMERA_FACING"),e.push("grl_previousAndSide","grl_nextAndCounters")):(e.push("grl_slopes"),e.push("grl_counters"));const s=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(G||s.push("world","viewProjection","view","projection"),super(B,u,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:G?["Scene","Mesh"]:void 0,attributes:e,uniforms:s,samplers:G?[]:["grlColors"],defines:R,extraInitializationsAsync:async()=>{G?await Promise.all([F.e(66).then(F.bind(F,16148)),F.e(75).then(F.bind(F,16155))]):await Promise.all([F.e(69).then(F.bind(F,16157)),F.e(76).then(F.bind(F,16163))])},shaderLanguage:G?1:0}),this._color=q.Xu.White(),this._colorsDistributionType=0,this._colorsTexture=null,V=V||{color:JB.DEFAULT_COLOR},this.visibility=V.visibility??1,this.useDash=V.useDash??!1,this.dashRatio=V.dashRatio??.5,this.dashOffset=V.dashOffset??0,this.dashCount=V.dashCount??1,this.width=V.width?V.width:V.sizeAttenuation&&V.cameraFacing?JB.DEFAULT_WIDTH_ATTENUATED:JB.DEFAULT_WIDTH,this.sizeAttenuation=V.sizeAttenuation??!1,this.color=V.color??q.Xu.White(),this.useColors=V.useColors??!1,this.colorsDistributionType=V.colorDistributionType??0,this.colorsSampling=V.colorsSampling??U.b.NEAREST_NEAREST,this.colorMode=V.colorMode??0,this._colors=V.aB??null,this._cameraFacing=V.cameraFacing??!0,this.resolution=V.resolution??new Z.Vector2(p.getRenderWidth(),p.getRenderHeight()),V.colorsTexture?this.colorsTexture=V.colorsTexture:this._colors?this.colorsTexture=zB.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,u):(this._color=this._color??JB.DEFAULT_COLOR,this.colorsTexture=zB.PrepareEmptyColorsTexture(u)),G){const B=new EB.c;B.setParameters(),B.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",B)}p.GR.add((()=>{zB.DisposeEmptyColorsTexture()}))}dispose(){var B;null===(B=this._colorsTexture)||void 0===B||B.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new Z.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get aB(){return this._colors}set aB(B){this.setColors(B)}setColors(B){var u;let F=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const V=(null===(u=this._colors)||void 0===u?void 0:u.length)??0;var p;if(this._colors=B,null!==B&&0!==B.length){if(!F||Z)if(this._colorsTexture&&V===B.length&&!Z){const u=zB.Color3toRGBAUint8(B);this._colorsTexture.update(u)}else{var G;null===(G=this._colorsTexture)||void 0===G||G.dispose(),this.colorsTexture=zB.CreateColorsTexture(`${this.name}-colors-texture`,B,this.colorsSampling,this.yB())}}else null===(p=this._colorsTexture)||void 0===p||p.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(B){this._colorsTexture=B,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(B){this._width=B,this.setFloat("grlWidth",B)}get useColors(){return this._useColors}set useColors(B){this._useColors=B,this.setFloat("grlUseColors",zB.BooleanToNumber(B))}get colorsSampling(){return this._colorsSampling}set colorsSampling(B){this._colorsSampling=B}get visibility(){return this._visibility}set visibility(B){this._visibility=B,this.setFloat("grlVisibility",B)}get useDash(){return this._useDash}set useDash(B){this._useDash=B,this.setFloat("grlUseDash",zB.BooleanToNumber(B))}get dashOffset(){return this._dashOffset}set dashOffset(B){this._dashOffset=B,this.setFloat("grlDashOffset",B)}get dashRatio(){return this._dashRatio}set dashRatio(B){this._dashRatio=B,this.setFloat("grlDashRatio",B)}get dashCount(){return this._dashCount}set dashCount(B){this._dashCount=B,this._dashArray=1/B,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(B){this._sizeAttenuation=B,this.setFloat("grlSizeAttenuation",zB.BooleanToNumber(B))}get color(){return this._color}set color(B){this.setColor(B)}setColor(B){B=B??JB.DEFAULT_COLOR,this._color=B,this.setColor3("grlColor",B)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(B){this._colorsDistributionType=B,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(B){this._colorMode=B,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(B){this._resolution=B,this.setVector2("grlResolution",B),this.setFloat("grlAspect",B.x/B.y)}serialize(){const B=super.serialize(),u={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(u.aB=this._colors),B.greasedLineMaterialOptions=u,B}parse(B,u,F){var Z;const V=B.greasedLineMaterialOptions;null===(Z=this._colorsTexture)||void 0===Z||Z.dispose(),V.color&&(this.color=V.color),V.colorDistributionType&&(this.colorsDistributionType=V.colorDistributionType),V.colorsSampling&&(this.colorsSampling=V.colorsSampling),V.colorMode&&(this.colorMode=V.colorMode),V.useColors&&(this.useColors=V.useColors),V.visibility&&(this.visibility=V.visibility),V.useDash&&(this.useDash=V.useDash),V.dashCount&&(this.dashCount=V.dashCount),V.dashRatio&&(this.dashRatio=V.dashRatio),V.dashOffset&&(this.dashOffset=V.dashOffset),V.width&&(this.width=V.width),V.sizeAttenuation&&(this.sizeAttenuation=V.sizeAttenuation),V.resolution&&(this.resolution=V.resolution),V.aB?this.colorsTexture=zB.CreateColorsTexture(`${this.name}-colors-texture`,V.aB,this.colorsSampling,this.yB()):this.colorsTexture=zB.PrepareEmptyColorsTexture(u),this._cameraFacing=V.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var HB,nB,dB;wB.ForceGLSL=!1,function(B){B[B.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",B[B.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(HB||(HB={})),function(B){B[B.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",B[B.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",B[B.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(nB||(nB={})),function(B){B[B.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",B[B.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",B[B.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",B[B.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",B[B.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(dB||(dB={}));class lB extends XB.b{constructor(B,u,F){super(B,u,null,null,!1,!1),this.name=B,this._options=F,this._lazy=!1,this._updatable=!1,this._engine=u.getEngine(),this._lazy=F.lazy??!1,this._updatable=F.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=F.colorPointers??[],this._widths=F.widths??new Array(F.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(B){let u=0;for(const Z of this._points)u+=Z.length;const F=u/3*2-this._widths.length;for(let Z=0;Z<F;Z++)this._widths.push(B)}updateLazy(){var B,u;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(B=this._options.ribbonOptions)||void 0===B?void 0:B.smoothShading),!this.jB&&this.refreshBoundingInfo(),null===(u=this.greasedLineMaterial)||void 0===u||u.updateLazy()}addPoints(B,u){for(const F of B)this._points.push(F);this._lazy||this.setPoints(this._points,u)}dispose(B){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(B,u)}isLazy(){return this._lazy}get TB(){return this._uvs}set TB(B){this._uvs=B instanceof Float32Array?B:new Float32Array(B),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(B){this.material instanceof wB&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===B||void 0===B?void 0:B.length)>0),this._offsets=B,this._offsetsBuffer?this._offsetsBuffer.update(B):this._createOffsetsBuffer(B)}get widths(){return this._widths}set widths(B){this._widths=B,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(B)}get colorPointers(){return this._colorPointers}set colorPointers(B){this._colorPointers=B,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(B)}get greasedLineMaterial(){var B,u;if(this.material&&this.material instanceof wB)return this.material;const F=null===(B=this.material)||void 0===B||null===(u=B.pluginManager)||void 0===u?void 0:u.getPlugin(jB.GREASED_LINE_MATERIAL_NAME);return F||void 0}get points(){const B=[];return IB.c.DeepCopy(this._points,B),B}setPoints(B,u){this._points=zB.ConvertPoints(B,(null===u||void 0===u?void 0:u.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==u&&void 0!==u&&u.colorPointers||this._updateColorPointers(),this._setPoints(this._points,u)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,TB:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(B){super.serialize(B),B.type=this.getClassName(),B.lineOptions=this._createLineOptions()}_createVertexBuffers(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new oB.c;return u.gB=this._vertexPositions,u.indices=this._indices,u.TB=this._uvs,B&&(u.JB=[],oB.c.ComputeNormals(this._vertexPositions,this._indices,u.JB)),u.MB(this,this._options.updatable),u}_createOffsetsBuffer(B){const u=this._scene.getEngine(),F=new Y.b(u,B,this._updatable,3);this.setVerticesBuffer(F.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=F}}class PB{constructor(B,u){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=B,this.wasAddedByNoopNode=u}getIndicesAccessor(B,u,F,Z,V){var p,G,R,e;return null===(p=this._indicesAccessorMap.get(B))||void 0===p||null===(G=p.get(u))||void 0===G||null===(R=G.get(F))||void 0===R||null===(e=R.get(Z))||void 0===e?void 0:e.get(V)}setIndicesAccessor(B,u,F,Z,V,p){let G=this._indicesAccessorMap.get(B);G||(G=new Map,this._indicesAccessorMap.set(B,G));let R=G.get(u);R||(R=new Map,G.set(u,R));let e=R.get(F);e||(e=new Map,R.set(F,e));let s=e.get(Z);s||(s=new Map,e.set(Z,s)),s.set(V,p)}pushExportedNode(B){this._exportedNodes.has(B)||this._exportedNodes.add(B)}getNodesSet(){return this._exportedNodes}getVertexBufferView(B){return this._vertexBufferViewMap.get(B)}setVertexBufferView(B,u){this._vertexBufferViewMap.set(B,u)}setRemappedBufferView(B,u,F){this._remappedBufferView.set(B,new Map),this._remappedBufferView.get(B).set(u,F)}getRemappedBufferView(B,u){var F;return null===(F=this._remappedBufferView.get(B))||void 0===F?void 0:F.get(u)}getVertexAccessor(B,u,F){var Z,V;return null===(Z=this._vertexAccessorMap.get(B))||void 0===Z||null===(V=Z.get(u))||void 0===V?void 0:V.get(F)}setVertexAccessor(B,u,F,Z){let V=this._vertexAccessorMap.get(B);V||(V=new Map,this._vertexAccessorMap.set(B,V));let p=V.get(u);p||(p=new Map,V.set(u,p)),p.set(F,Z)}hasVertexColorAlpha(B){return this._vertexMapColorAlpha.get(B)||!1}setHasVertexColorAlpha(B,u){return this._vertexMapColorAlpha.set(B,u)}getMesh(B){return this._meshMap.get(B)}setMesh(B,u){this._meshMap.set(B,u)}bindMorphDataToMesh(B,u){const F=this._meshMorphTargetMap.get(B)||[];this._meshMorphTargetMap.set(B,F),-1===F.indexOf(u)&&F.push(u)}getMorphTargetsFromMesh(B){return this._meshMorphTargetMap.get(B)}}class cB{_ApplyExtension(B,u,F,Z){if(F>=u.length)return Promise.resolve(B);const V=Z(u[F],B);return V?V.then((async B=>B?await this._ApplyExtension(B,u,F+1,Z):null)):this._ApplyExtension(B,u,F+1,Z)}_ApplyExtensions(B,u){const F=[];for(const Z of cB._ExtensionNames)F.push(this._extensions[Z]);return this._ApplyExtension(B,F,0,u)}_extensionsPreExportTextureAsync(B,u,F){return this._ApplyExtensions(u,((u,Z)=>u.preExportTextureAsync&&u.preExportTextureAsync(B,Z,F)))}_extensionsPostExportNodeAsync(B,u,F,Z,V){return this._ApplyExtensions(u,((u,p)=>u.postExportNodeAsync&&u.postExportNodeAsync(B,p,F,Z,V,this._bufferManager)))}_extensionsPostExportMaterialAsync(B,u,F){return this._ApplyExtensions(u,((u,Z)=>u.postExportMaterialAsync&&u.postExportMaterialAsync(B,Z,F)))}_extensionsPostExportMaterialAdditionalTextures(B,u,F){const Z=[];for(const V of cB._ExtensionNames){const p=this._extensions[V];p.postExportMaterialAdditionalTextures&&Z.push(...p.postExportMaterialAdditionalTextures(B,u,F))}return Z}_extensionsPostExportTextures(B,u,F){for(const Z of cB._ExtensionNames){const V=this._extensions[Z];V.postExportTexture&&V.postExportTexture(B,u,F)}}_extensionsPostExportMeshPrimitive(B){for(const u of cB._ExtensionNames){const F=this._extensions[u];F.postExportMeshPrimitive&&F.postExportMeshPrimitive(B,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const B of cB._ExtensionNames){const u=this._extensions[B];u.preGenerateBinaryAsync&&await u.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(B){for(const u of cB._ExtensionNames){const F=this._extensions[u];F.enabled&&B(F)}}_extensionsOnExporting(){this._forEachExtensions((B=>{var u,F,Z;B.wasUsed&&((u=this._glTF).extensionsUsed||(u.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(B.name)&&this._glTF.extensionsUsed.push(B.name),B.required&&((F=this._glTF).extensionsRequired||(F.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(B.name)&&this._glTF.extensionsRequired.push(B.name)),(Z=this._glTF).extensions||(Z.extensions={}),B.onExporting&&B.onExporting())}))}_loadExtensions(){for(const B of cB._ExtensionNames){const u=cB._ExtensionFactories[B](this);this._extensions[B]=u}}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:L.b.LastCreatedScene,u=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${D.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new E(this),this._extensions={},this._bufferManager=new YB,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!B)throw new Error("No scene available to export");this._babylonScene=B,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:B=>{var u;return null===B||void 0===B||null===(u=B.YR)||void 0===u?void 0:u.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...u},this._loadExtensions()}dispose(){for(const B in this._extensions){this._extensions[B].dispose()}}get options(){return this._options}static RegisterExtension(B,u){cB.UnregisterExtension(B)&&V.Tools.Warn(`Extension with the name ${B} already exists`),cB._ExtensionFactories[B]=u,cB._ExtensionNames.push(B)}static UnregisterExtension(B){if(!cB._ExtensionFactories[B])return!1;delete cB._ExtensionFactories[B];const u=cB._ExtensionNames.indexOf(B);return-1!==u&&cB._ExtensionNames.splice(u,1),!0}_generateJSON(B,u,F){const Z={byteLength:B};return Z.byteLength&&(this._glTF.buffers=[Z]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.qu=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(Z.uri=u+".bin"),F?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(B){const u=await this._generateBinaryAsync();this._extensionsOnExporting();const F=this._generateJSON(u.byteLength,B,!0),Z=new Blob([u],{type:"application/octet-stream"}),V=B+".gltf",p=B+".bin",G=new s;if(G.files[V]=F,G.files[p]=Z,this._imageData)for(const R in this._imageData)G.files[R]=new Blob([this._imageData[R].data],{type:this._imageData[R].mimeType});return G}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(B){const u=B%4;return 0===u?u:4-u}async generateGLBAsync(B){this._shouldUseGlb=!0;const u=await this._generateBinaryAsync();this._extensionsOnExporting();const F=this._generateJSON(u.byteLength),Z=B+".glb";let V,p=F.length;if("undefined"!==typeof TextEncoder){V=(new TextEncoder).encode(F),p=V.length}const G=this._getPadding(p),R=this._getPadding(u.byteLength),e=28+p+G+u.byteLength+R,Y=new eB(e);if(Y.writeUInt32(1179937895),Y.writeUInt32(2),Y.writeUInt32(e),Y.writeUInt32(p+G),Y.writeUInt32(1313821514),V)Y.writeTypedArray(V);else{const B="_".charCodeAt(0);for(let u=0;u<p;++u){const Z=F.charCodeAt(u);Z!=F.codePointAt(u)?Y.writeUInt8(B):Y.writeUInt8(Z)}}for(let s=0;s<G;++s)Y.writeUInt8(32);Y.writeUInt32(u.byteLength+R),Y.writeUInt32(5130562),Y.writeTypedArray(u);for(let s=0;s<R;++s)Y.writeUInt8(0);const Q=new s;return Q.files[Z]=new Blob([Y.getOutputData()],{type:"application/octet-stream"}),Q}_setNodeTransformation(B,u,F){if(u.getPivotPoint().equalsWithEpsilon(l,d.e)||V.Tools.Warn("Pivot points are not supported in the glTF serializer"),!u.position.equalsWithEpsilon(l,d.e)){const V=Z.TmpVectors.Du[0].Z(u.position);F&&b(V),B.translation=V.DR()}u.yR.equalsWithEpsilon(c,d.e)||(B.scale=u.yR.DR());const p=u.rotationQuaternion||Z.Quaternion.FromEulerAngles(u.rotation.x,u.rotation.y,u.rotation.z);p.equalsWithEpsilon(P,d.e)||(F&&k(p),B.rotation=p.normalize().DR())}_setCameraTransformation(B,u,F){if(!u.position.equalsWithEpsilon(l,d.e)){const V=Z.TmpVectors.Du[0].Z(u.position);F&&b(V),B.translation=V.DR()}const V=u.rotationQuaternion||Z.Quaternion.FromEulerAngles(u.rotation.x,u.rotation.y,u.rotation.z);F&&k(V),this._babylonScene.useRightHandedSystem||S(V),V.equalsWithEpsilon(P,d.e)||(B.rotation=V.DR())}_listAvailableCameras(){for(const B of this._babylonScene.cameras){const u={type:B.mode===tB.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(B.name&&(u.name=B.name),"perspective"===u.type)u.perspective={aspectRatio:B.getEngine().getAspectRatio(B),yfov:B.fovMode===tB.d.FOVMODE_VERTICAL_FIXED?B.fov:B.fov*B.getEngine().getAspectRatio(B),znear:B.qR,zfar:B.maxZ};else if("orthographic"===u.type){const F=B.orthoLeft&&B.orthoRight?.5*(B.orthoRight-B.orthoLeft):.5*B.getEngine().getRenderWidth(),Z=B.orthoBottom&&B.orthoTop?.5*(B.orthoTop-B.orthoBottom):.5*B.getEngine().getRenderHeight();u.orthographic={xmag:F,ymag:Z,znear:B.qR,zfar:B.maxZ}}this._camerasMap.set(B,u)}}_exportAndAssignCameras(){const B=Array.from(this._camerasMap.values());for(const u of B){const B=this._nodesCameraMap.get(u);if(void 0!==B){this._cameras.push(u);for(const u of B)u.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const B of this._babylonScene.skeletons){if(B.bones.length<=0)continue;const u={joints:[]};this._skinMap.set(B,u)}}_exportAndAssignSkeletons(){for(const B of this._babylonScene.skeletons){if(B.bones.length<=0)continue;const u=this._skinMap.get(B);if(void 0==u)continue;const F={},Z=[];let p=-1;for(let V=0;V<B.bones.length;++V){const u=B.bones[V],Z=u.getIndex()??V;-1!==Z&&(F[Z]=u,Z>p&&(p=Z))}for(let B=0;B<=p;++B){const p=F[B];Z.push(p.getAbsoluteInverseBindMatrix());const G=p.getTransformNode();if(null!==G){const B=this._nodeMap.get(G);G&&null!==B&&void 0!==B?u.joints.push(B):V.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else V.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const G=this._nodesSkinMap.get(u);if(u.joints.length>0&&void 0!==G){const B=64*Z.length,F=new Float32Array(B/4);Z.forEach(((B,u)=>{F.set(B.m,16*u)}));const V=this._bufferManager.createBufferView(F);this._accessors.push(this._bufferManager.createAccessor(V,"MAT4",5126,Z.length)),u.inverseBindMatrices=this._accessors.length-1,this._skins.push(u);for(const u of G)u.skin=this._skins.length-1}}}async _exportSceneAsync(){const B={nodes:[]};if(this._babylonScene.metadata){const u=this._options.metadataSelector(this._babylonScene.metadata);u&&(B.extras=u)}const u=new Array,F=new Array,Z=new Array;for(const R of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&GB(R,this._babylonScene.useRightHandedSystem)?Z.push(...R.getChildren()):this._babylonScene.useRightHandedSystem?u.push(R):F.push(R);this._listAvailableCameras(),this._listAvailableSkeletons();const V=new PB(!0,!1);B.nodes.push(...await this._exportNodesAsync(F,V));const p=new PB(!1,!1);B.nodes.push(...await this._exportNodesAsync(u,p));const G=new PB(!1,!0);B.nodes.push(...await this._exportNodesAsync(Z,G)),B.nodes.length&&this._scenes.push(B),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&CB._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,V.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(B){let u=this._shouldExportNodeMap.get(B);return void 0===u&&(u=this._options.shouldExportNode(B),this._shouldExportNodeMap.set(B,u)),u}async _exportNodesAsync(B,u){const F=new Array;this._exportBuffers(B,u);for(const Z of B)await this._exportNodeAsync(Z,F,u);return F}_collectBuffers(B,u,F,Z,V){if(this._shouldExportNode(B)&&B instanceof t.e&&B.fR){const p=B.fR.getVertexBuffers();if(p)for(const Z in p){if(!K(Z))continue;const G=p[Z];V.setHasVertexColorAlpha(G,B.hasVertexAlpha);const R=G._buffer,e=u.get(R)||[];u.set(R,e),-1===e.indexOf(G)&&e.push(G);const s=F.get(G)||[];F.set(G,s),-1===s.indexOf(B)&&s.push(B)}const G=B.morphTargetManager;if(G)for(let u=0;u<G.numTargets;u++){const F=G.getTarget(u),V=Z.get(F)||[];Z.set(F,V),-1===V.indexOf(B)&&V.push(B)}}for(const p of B.getChildren())this._collectBuffers(p,u,F,Z,V)}_exportBuffers(B,u){const F=new Map,Z=new Map,V=new Map;for(const R of B)this._collectBuffers(R,F,Z,V,u);const p=Array.from(F.keys());for(const R of p){const B=R.getData();if(!B)throw new Error("Buffer data is not available");const V=F.get(R);if(!V)continue;const p=V[0].byteStride;if(V.some((B=>B.byteStride!==p)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const G=FB(B).slice();for(const u of V){const B=Z.get(u),{byteOffset:F,byteStride:V,componentCount:p,type:R,count:e,normalized:s,kind:Q}=i(u,B);switch(Q){case Y.f.NormalKind:case Y.f.TangentKind:(0,w.h)(G,F,V,p,R,e,s,(B=>{const u=Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]);if(u>0){const F=1/u;B[0]*=F,B[1]*=F,B[2]*=F}}));break;case Y.f.ColorKind:{const u=B.filter((B=>B.material instanceof LB.Wu||null==B.material)).length;if(0==u)break;if(u!=B.length){H.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}R==Y.f.UNSIGNED_BYTE&&H.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const Z=new q.Xu,Q=new q.gR,t=this._babylonScene.getEngine().useExactSrgbConversions;(0,w.h)(G,F,V,p,R,e,s,(B=>{3===B.length?(Z.vF(B,0),Z.toLinearSpaceToRef(Z,t),Z.toArray(B,0)):(Q.vF(B,0),Q.toLinearSpaceToRef(Q,t),Q.toArray(B,0))}))}}}if(u.convertToRightHanded){for(const B of V){const u=Z.get(B),{byteOffset:F,byteStride:V,componentCount:p,type:R,count:e,normalized:s,kind:Q}=i(B,u);switch(Q){case Y.f.PositionKind:case Y.f.NormalKind:case Y.f.TangentKind:(0,w.h)(G,F,V,p,R,e,s,(B=>{B[0]=-B[0]}))}}u.convertedToRightHandedBuffers.set(R,G)}const e=this._bufferManager.createBufferView(G,p);u.setVertexBufferView(R,e);const s=new Map;for(const u of V){const B=Z.get(u),{kind:F,totalVertices:V}=i(u,B);switch(F){case Y.f.MatricesIndicesKind:case Y.f.MatricesIndicesExtraKind:if(u.type==Y.f.FLOAT){const B=u.getFloatData(V);null!==B&&s.set(u,B)}}}0!==s.size&&H.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const Q=Array.from(s.keys());for(const F of Q){const B=s.get(F);if(!B)continue;const Z=B.some((B=>B>=256)),V=new(Z?Uint16Array:Uint8Array)(B.length);for(let u=0;u<B.length;u++)V[u]=B[u];const p=this._bufferManager.createBufferView(V,4*(Z?2:1));u.setRemappedBufferView(R,F,p)}}const G=Array.from(V.keys());for(const R of G){const B=V.get(R);if(!B)continue;const F=xB(R,B[0],this._bufferManager,this._bufferViews,this._accessors,u.convertToRightHanded);for(const Z of B)u.bindMorphDataToMesh(Z,F)}}async _exportNodeAsync(B,u,F){let Z=this._nodeMap.get(B);if(void 0!==Z)return void(u.includes(Z)||u.push(Z));const V=await this._createNodeAsync(B,F);if(V){Z=this._nodes.length,this._nodes.push(V),this._nodeMap.set(B,Z),F.pushExportedNode(B),u.push(Z);const p={name:"runtime animations",channels:[],samplers:[]},G=[];this._babylonScene.animationGroups.length||(CB._CreateMorphTargetAnimationFromMorphTargetAnimations(B,p,G,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,F.convertToRightHanded,this._options.shouldExportAnimation),B.animations.length&&CB._CreateNodeAnimationFromNodeAnimations(B,p,G,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,F.convertToRightHanded,this._options.shouldExportAnimation)),p.channels.length&&p.samplers.length&&this._animations.push(p),G.forEach((B=>{B.channels.length&&B.samplers.length&&this._animations.push(B)}))}const p=V?[]:u;for(const G of B.getChildren())await this._exportNodeAsync(G,p,F);V&&p.length&&(V.children=p)}async _createNodeAsync(B,u){if(!this._shouldExportNode(B))return null;const F={};if(B.name&&(F.name=B.name),B.metadata){const u=this._options.metadataSelector(B.metadata);u&&(F.extras=u)}if(B instanceof Q.b&&(this._setNodeTransformation(F,B,u.convertToRightHanded),B instanceof t.e)){const V=B instanceof v.d?B.sourceMesh:B;if(V.vR&&V.vR.length>0&&(F.mesh=await this._exportMeshAsync(V,u)),B.skeleton){const u=this._skinMap.get(B.skeleton);var Z;if(void 0!==u)void 0===this._nodesSkinMap.get(u)&&this._nodesSkinMap.set(u,[]),null===(Z=this._nodesSkinMap.get(u))||void 0===Z||Z.push(F)}}if(B instanceof n.b){const Z=this._camerasMap.get(B);if(Z){var V;void 0===this._nodesCameraMap.get(Z)&&this._nodesCameraMap.set(Z,[]),this._setCameraTransformation(F,B,u.convertToRightHanded);const G=B.parent;if(null!==G&&uB(B,G)){const B=this._nodeMap.get(G);if(void 0!==B){var p;const u=this._nodes[B];return BB(F,u),null===(p=this._nodesCameraMap.get(Z))||void 0===p||p.push(u),null}}null===(V=this._nodesCameraMap.get(Z))||void 0===V||V.push(F)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",F,B,this._nodeMap,u.convertToRightHanded)?F:(H.d.Warn(`Not exporting node ${B.name}`),null)}_exportIndices(B,u,F,Z,V,G,R,e,s){let Y=B;s.mode=N(G);const Q=R!==p.c.CounterClockWiseSideOrientation,t=!e.wasAddedByNoopNode&&Q,v=function(B){switch(B){case p.c.TriangleFillMode:case p.c.TriangleStripDrawMode:case p.c.TriangleFanDrawMode:return!0}return!1}(G)&&t;if(v){if(G===p.c.TriangleStripDrawMode||G===p.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");s.mode=N(G);const R=u?new Uint32Array(Z):new Uint16Array(Z);if(B)for(let u=0;u+2<Z;u+=3)R[u]=B[F+u]+V,R[u+1]=B[F+u+2]+V,R[u+2]=B[F+u+1]+V;else for(let B=0;B+2<Z;B+=3)R[B]=B,R[B+1]=B+2,R[B+2]=B+1;Y=R}else if(B&&0!==V){const p=u?new Uint32Array(Z):new Uint16Array(Z);for(let u=0;u<Z;u++)p[u]=B[F+u]+V;Y=p}if(Y){let p=e.getIndicesAccessor(B,F,Z,V,v);if(void 0===p){const G=function(B,u,F,Z){if(B instanceof Uint16Array||B instanceof Uint32Array)return B;if(B instanceof Int32Array)return new Uint32Array(B.buffer,B.byteOffset,B.length);const V=B.slice(u,u+F);return Z?new Uint32Array(V):new Uint16Array(V)}(Y,0,Z,u),R=this._bufferManager.createBufferView(G),s=u?5125:5123;this._accessors.push(this._bufferManager.createAccessor(R,"SCALAR",s,Z,0)),p=this._accessors.length-1,e.setIndicesAccessor(B,F,Z,V,v,p)}s.indices=p}}_exportVertexBuffer(B,u,F,Z,V,p){const G=B.getKind();if(!K(G))return;if(G.startsWith("uv")&&!this._options.exportUnusedUVs&&(!u||!this._materialNeedsUVsSet.has(u)))return;let R=V.getVertexAccessor(B,F,Z);if(void 0===R){const u=V.convertedToRightHandedBuffers.get(B._buffer)||B._buffer.getData(),p=G===Y.f.PositionKind?function(B,u,F,Z){const{byteOffset:V,byteStride:p,type:G,normalized:R}=u,e=u.getSize(),s=new Array(e).fill(1/0),Y=new Array(e).fill(-1/0);return(0,w.h)(B,V+F*p,p,e,G,Z*e,R,(B=>{for(let u=0;u<e;u++)s[u]=Math.min(s[u],B[u]),Y[u]=Math.max(Y[u],B[u])})),{min:s,max:Y}}(u,B,F,Z):void 0,e=(G===Y.f.MatricesIndicesKind||G===Y.f.MatricesIndicesExtraKind)&&B.type===Y.f.FLOAT,s=e?Y.f.UNSIGNED_BYTE:B.type,Q=e?void 0:B.normalized,t=e?V.getRemappedBufferView(B._buffer,B):V.getVertexBufferView(B._buffer),v=B.byteOffset+F*B.byteStride;this._accessors.push(this._bufferManager.createAccessor(t,function(B,u){if(B==Y.f.ColorKind)return u?"VEC4":"VEC3";switch(B){case Y.f.PositionKind:case Y.f.NormalKind:return"VEC3";case Y.f.TangentKind:case Y.f.MatricesIndicesKind:case Y.f.MatricesIndicesExtraKind:case Y.f.MatricesWeightsKind:case Y.f.MatricesWeightsExtraKind:return"VEC4";case Y.f.UVKind:case Y.f.UV2Kind:case Y.f.UV3Kind:case Y.f.UV4Kind:case Y.f.UV5Kind:case Y.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${B}`)}(G,V.hasVertexColorAlpha(B)),s,Z,v,p,Q)),R=this._accessors.length-1,V.setVertexAccessor(B,F,Z,R)}p.attributes[function(B){switch(B){case Y.f.PositionKind:return"POSITION";case Y.f.NormalKind:return"NORMAL";case Y.f.TangentKind:return"TANGENT";case Y.f.ColorKind:return"COLOR_0";case Y.f.UVKind:return"TEXCOORD_0";case Y.f.UV2Kind:return"TEXCOORD_1";case Y.f.UV3Kind:return"TEXCOORD_2";case Y.f.UV4Kind:return"TEXCOORD_3";case Y.f.UV5Kind:return"TEXCOORD_4";case Y.f.UV6Kind:return"TEXCOORD_5";case Y.f.MatricesIndicesKind:return"JOINTS_0";case Y.f.MatricesIndicesExtraKind:return"JOINTS_1";case Y.f.MatricesWeightsKind:return"WEIGHTS_0";case Y.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${B}`)}(G)]=R}async _exportMaterialAsync(B,u,F,Z){let V=this._materialMap.get(B);if(void 0===V){const Z=u&&Object.keys(u).some((B=>B.startsWith("uv")));if((B=B instanceof vB.c?B.JR[F.materialIndex]:B)instanceof DB.c)V=await this._materialExporter.exportPBRMaterialAsync(B,"image/png",Z);else{if(!(B instanceof LB.Wu))return void H.d.Warn(`Unsupported material '${B.name}' with type ${B.getClassName()}`);V=await this._materialExporter.exportStandardMaterialAsync(B,"image/png",Z)}this._materialMap.set(B,V)}Z.material=V}async _exportMeshAsync(B,u){var F;let Z=u.getMesh(B);if(void 0!==Z)return Z;const V={primitives:[]};Z=this._meshes.length,this._meshes.push(V),u.setMesh(B,Z);const G=B.isUnIndexed?null:B.CR(),R=null===(F=B.fR)||void 0===F?void 0:F.getVertexBuffers(),e=u.getMorphTargetsFromMesh(B),s=B instanceof UB.c,Y=B instanceof lB,Q=B.vR;if(R&&Q&&Q.length>0)for(const D of Q){const F={attributes:{}},Z=D.EB()||this._babylonScene.defaultMaterial;if(Y){var t,v;const u={name:Z.name},V=B,p=q.Xu.White(),G=(null===(t=V.material)||void 0===t?void 0:t.alpha)??1,R=(null===(v=V.greasedLineMaterial)||void 0===v?void 0:v.color)??p;(!R.equalsWithEpsilon(p,d.e)||G<1)&&(u.pbrMetallicRoughness={baseColorFactor:[...R.DR(),G]}),this._materials.push(u),F.material=this._materials.length-1}else if(s){const u={name:Z.name},V=B;(!V.color.equalsWithEpsilon(q.Xu.White(),d.e)||V.alpha<1)&&(u.pbrMetallicRoughness={baseColorFactor:[...V.color.DR(),V.alpha]}),this._materials.push(u),F.material=this._materials.length-1}else await this._exportMaterialAsync(Z,R,D,F);const Q=s||Y?p.c.LineListDrawMode:B.overrideRenderingFillMode??Z.fillMode,L=Z._getEffectiveOrientation(B);this._exportIndices(G,G?(0,w.b)(G,D.indexCount,D.indexStart,D.verticesStart):D.verticesCount>65535,G?D.indexStart:D.verticesStart,G?D.indexCount:D.verticesCount,-D.verticesStart,Q,L,u,F);for(const B of Object.values(R))this._exportVertexBuffer(B,Z,D.verticesStart,D.verticesCount,u,F);if(e){F.targets=[];for(const B of e)F.targets.push(B.attributes)}V.primitives.push(F),this._extensionsPostExportMeshPrimitive(F)}if(e){V.weights=[],V.extras||(V.extras={}),V.extras.targetNames=[];for(const B of e)V.weights.push(B.influence),V.extras.targetNames.push(B.name)}return Z}}cB._ExtensionNames=new Array,cB._ExtensionFactories={};class hB{static async GLTFAsync(B,u,F){F&&F.exportWithoutWaitingForScene||await B.whenReadyAsync();const Z=new cB(B,F),V=await Z.generateGLTFAsync(u.replace(/\.[^/.]+$/,""));return Z.dispose(),V}static async GLBAsync(B,u,F){F&&F.exportWithoutWaitingForScene||await B.whenReadyAsync();const Z=new cB(B,F),V=await Z.generateGLBAsync(u.replace(/\.[^/.]+$/,""));return Z.dispose(),V}}F(13528);const iB="EXT_mesh_gpu_instancing";class rB{constructor(B){this.name=iB,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(B,u,F,V,p,G){return await new Promise((B=>{if(u&&F instanceof XB.b&&F.hasThinInstances&&this._exporter){this._wasUsed=!0;const B=Z.Du.Zero(),V=Z.Quaternion.Identity(),R=Z.Du.One(),e=F.thinInstanceGetWorldMatrices(),s=Z.TmpVectors.Du[2],Y=Z.TmpVectors.Quaternion[1],Q=Z.TmpVectors.Du[3];let t=!1,v=!1,D=!1;const L=new Float32Array(3*F.aR),q=new Float32Array(4*F.aR),W=new Float32Array(3*F.aR);let X=0;for(const u of e)u.decompose(Q,Y,s),p&&(b(s),k(Y)),L.set(s.DR(),3*X),q.set(Y.normalize().DR(),4*X),W.set(Q.DR(),3*X),t=t||!s.equalsWithEpsilon(B),v=v||!Y.equalsWithEpsilon(V),D=D||!Q.equalsWithEpsilon(R),X++;const f={attributes:{}};t&&(f.attributes.TRANSLATION=this._buildAccessor(L,"VEC3",F.aR,G)),v&&(f.attributes.ROTATION=this._buildAccessor(q,"VEC4",F.aR,G)),D&&(f.attributes.SCALE=this._buildAccessor(W,"VEC3",F.aR,G)),u.extensions=u.extensions||{},u.extensions[iB]=f}B(u)}))}_buildAccessor(B,u,F,Z){const V=Z.createBufferView(B),p=Z.createAccessor(V,u,5126,F);return this._exporter._accessors.push(p),this._exporter._accessors.length-1}}cB.RegisterExtension(iB,(B=>new rB(B)));var KB=F(13533),NB=F(13546),AB=F(13554),bB=F(13560);function kB(B){return B===AB.d.PositionKind?"POSITION":B===AB.d.NormalKind?"NORMAL":B===AB.d.ColorKind?"COLOR":B.startsWith(AB.d.UVKind)?"TEX_COORD":"GENERIC"}const SB={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Bu extends KB.b{static get DefaultAvailable(){return(0,KB.g)(Bu.DefaultConfiguration)}static get Default(){return Bu._Default??(Bu._Default=new Bu),Bu._Default}static ResetDefault(B){Bu._Default&&(B||Bu._Default.dispose(),Bu._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(B,u){return{module:await(u||DracoEncoderModule)({wasmBinary:B})}}_getWorkerContent(){return`${NB.f}(${NB.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Bu.DefaultConfiguration)}async _encodeAsync(B,u,F){const Z=F?(0,bB.d)(SB,F):SB;if(this._workerPoolPromise){const F=await this._workerPoolPromise;return await new Promise(((V,p)=>{F.push(((F,G)=>{const R=B=>{F.removeEventListener("error",R),F.removeEventListener("message",e),p(B),G()},e=B=>{"encodeMeshDone"===B.data.id&&(F.removeEventListener("error",R),F.removeEventListener("message",e),V(B.data.encodedMeshData),G())};F.addEventListener("error",R),F.addEventListener("message",e);const s=[];for(const u of B)s.push(u.data.buffer);u&&s.push(u.buffer),F.postMessage({id:"encodeMesh",attributes:B,indices:u,options:Z},s)}))}))}if(this._modulePromise){const F=await this._modulePromise;return(0,NB.f)(F.module,B,u,Z)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(B,u){if(0==B.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");B instanceof XB.b&&B.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===u||void 0===u?void 0:u.method)&&(H.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),u.method="MESH_SEQUENTIAL_ENCODING");const F=function(B){let u=B.CR(void 0,!0);return!u||u instanceof Uint32Array||u instanceof Uint16Array||(u=((0,w.b)(u,u.length)?Uint32Array:Uint16Array).from(u)),u}(B),Z=function(B,u){const F=[];for(const Z of B.getVerticesDataKinds()){if(null!==u&&void 0!==u&&u.includes(Z)){if(Z===AB.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const V=B.getVertexBuffer(Z),p=V.getSize(),G=(0,w.p)(V.getData(),p,V.type,V.byteOffset,V.byteStride,V.normalized,B.getTotalVertices(),!0);F.push({kind:Z,dracoName:kB(Z),size:p,data:G})}return F}(B,null===u||void 0===u?void 0:u.excludedAttributes);return await this._encodeAsync(Z,F,u)}}Bu.DefaultConfiguration={wasmUrl:`${V.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${V.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${V.Tools._DefaultCdnUrl}/draco_encoder.js`},Bu._Default=null;const uu="KHR_draco_mesh_compression";class Fu{get wasUsed(){return this._wasUsed}constructor(B){this.name=uu,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===B.options.meshCompressionMethod&&Bu.DefaultAvailable}dispose(){}postExportMeshPrimitive(B,u,F){if(!this.enabled)return;if(4!==B.mode&&5!==B.mode)return void H.d.Warn("Cannot compress primitive with mode "+B.mode+".");const Z=[],V=[];let p=null;if(void 0!==B.indices){const G=F[B.indices],R=u.getBufferView(G);p=u.getData(R).slice(),Z.push(R),V.push(G)}const G=[];for(const[Y,Q]of Object.entries(B.attributes)){const B=F[Q],p=u.getBufferView(B),e=r(B.type),s=(0,w.p)(u.getData(p),e,B.componentType,B.byteOffset||0,p.byteStride||(0,w.k)(B.componentType)*e,B.normalized||!1,B.count,!0);G.push({kind:Y,dracoName:(R=Y,"POSITION"===R?"POSITION":"NORMAL"===R?"NORMAL":R.startsWith("COLOR")?"COLOR":R.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:r(B.type),data:s}),Z.push(p),V.push(B)}var R;const e={method:B.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},s=Bu.Default._encodeAsync(G,p,e).then((F=>{if(!F)return void H.d.Error("Draco encoding failed for primitive.");const p={bufferView:-1,attributes:F.attributeIds},G=u.createBufferView(F.data);u.setBufferView(p,G);for(const B of Z)this._bufferViewsUsed.add(B);for(const B of V)this._accessorsUsed.add(B);B.extensions||(B.extensions={}),B.extensions[uu]=p})).catch((B=>{H.d.Error("Draco encoding failed for primitive: "+B)}));this._encodePromises.push(s),this._wasUsed=!0}async preGenerateBinaryAsync(B){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((u=>{B.getPropertiesWithBufferView(u).every((B=>this._accessorsUsed.has(B)))&&B.removeBufferView(u)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}cB.RegisterExtension(uu,(B=>new Fu(B)));var Zu=F(13564);const Vu="KHR_lights_punctual",pu={name:"",color:[1,1,1],TR:1,range:Number.MAX_VALUE},Gu={innerConeAngle:0,outerConeAngle:Math.PI/4},Ru=Z.Du.Backward();class eu{constructor(B){this.name=Vu,this.enabled=!0,this.required=!1,this._exporter=B}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Vu]=this._lights}async postExportNodeAsync(B,u,F,V,p){return await new Promise((G=>{if(!(F instanceof fB.c))return void G(u);const R=F.getTypeID()==fB.c.LIGHTTYPEID_POINTLIGHT?"point":F.getTypeID()==fB.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":F.getTypeID()==fB.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!R||!(F instanceof Zu.b))return H.d.Warn(`${B}: Light ${F.name} is not supported in ${Vu}`),void G(u);if(F.falloffType!==fB.c.FALLOFF_GLTF&&H.d.Warn(`${B}: Light falloff for ${F.name} does not match the ${Vu} specification!`),!F.position.equalsToFloats(0,0,0)){const B=Z.TmpVectors.Du[0].Z(F.position);p&&b(B),u.translation=B.DR()}if("point"!==R){const B=F.direction.normalizeToRef(Z.TmpVectors.Du[0]);p&&b(B);const V=Z.Quaternion.FromUnitVectorsToRef(Ru,B,Z.TmpVectors.Quaternion[0]);Z.Quaternion.IsIdentity(V)||(u.rotation=V.DR())}const e={type:R,name:F.name,color:F.zR.DR(),TR:F.TR,range:F.range};if(ZB(e,pu),"spot"===R){const B=F;e.spot={innerConeAngle:B.innerAngle/2,outerConeAngle:B.angle/2},ZB(e.spot,Gu)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(e);const s={ip:this._lights.lights.length-1},Y=F.parent;if(Y&&uB(F,Y)){const B=V.get(Y);if(B){const F=this._exporter._nodes[B];return BB(u,F),F.extensions||(F.extensions={}),F.extensions[Vu]=s,void G(null)}}u.extensions||(u.extensions={}),u.extensions[Vu]=s,G(u)}))}}cB.RegisterExtension(Vu,(B=>new eu(B)));var su=F(13476);const Yu="KHR_materials_anisotropy";class Qu{constructor(B){this.name=Yu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,u,F){const Z=[];return F instanceof su.c&&F.anisotropy.isEnabled&&!F.anisotropy.legacy?(F.anisotropy.texture&&Z.push(F.anisotropy.texture),Z):[]}postExportMaterialAsync(B,u,F){return new Promise((B=>{if(F instanceof su.c){if(!F.anisotropy.isEnabled||F.anisotropy.legacy)return void B(u);this._wasUsed=!0,u.extensions=u.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(F.anisotropy.texture),V={anisotropyStrength:F.anisotropy.TR,anisotropyRotation:F.anisotropy.angle,anisotropyTexture:Z??void 0};null!==V.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(F),u.extensions[Yu]=V}B(u)}))}}cB.RegisterExtension(Yu,(B=>new Qu(B)));const tu="KHR_materials_clearcoat";class vu{constructor(B){this.name=tu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,u,F){const Z=[];return F instanceof su.c&&F.clearCoat.isEnabled?(F.clearCoat.texture&&Z.push(F.clearCoat.texture),!F.clearCoat.useRoughnessFromMainTexture&&F.clearCoat.textureRoughness&&Z.push(F.clearCoat.textureRoughness),F.clearCoat.bumpTexture&&Z.push(F.clearCoat.bumpTexture),Z):[]}postExportMaterialAsync(B,u,F){return new Promise((B=>{if(F instanceof su.c){if(!F.clearCoat.isEnabled)return void B(u);this._wasUsed=!0,u.extensions=u.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(F.clearCoat.texture);let p;p=F.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(F.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(F.clearCoat.textureRoughness),F.clearCoat.isTintEnabled&&V.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${F.name}`),F.clearCoat.remapF0OnInterfaceChange&&V.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${F.name}`);const G=this._exporter._materialExporter.getTextureInfo(F.clearCoat.bumpTexture),R={clearcoatFactor:F.clearCoat.TR,clearcoatTexture:Z??void 0,clearcoatRoughnessFactor:F.clearCoat.roughness,clearcoatRoughnessTexture:p??void 0,clearcoatNormalTexture:G??void 0};null===R.clearcoatTexture&&null===R.clearcoatRoughnessTexture&&null===R.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(F),u.extensions[tu]=R}B(u)}))}}cB.RegisterExtension(tu,(B=>new vu(B)));const Du="KHR_materials_diffuse_transmission";function Lu(B,u){const F=u.subSurface;let Z=null;return F.translucencyIntensityTexture?Z=F.translucencyIntensityTexture:F.thicknessTexture&&F.useMaskFromThicknessTexture&&(Z=F.thicknessTexture),Z&&!F.useGltfStyleTextures?(H.d.Warn(`${B}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${u.name}`,1),null):Z}class qu{constructor(B){this.name=Du,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,u,F){const Z=[];if(F instanceof DB.c&&this._isExtensionEnabled(F)){const u=Lu(B,F);return u&&Z.push(u),F.subSurface.translucencyColorTexture&&Z.push(F.subSurface.translucencyColorTexture),Z}return Z}_isExtensionEnabled(B){if(B.unlit)return!1;const u=B.subSurface;return!!u.isTranslucencyEnabled&&(!B.unlit&&!u.useAlbedoToTintTranslucency&&u.useGltfStyleTextures&&1===u.volumeIndexOfRefraction&&0===u.minimumThickness&&0===u.maximumThickness)}postExportMaterialAsync(B,u,F){return new Promise((Z=>{if(F instanceof DB.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const Z=F.subSurface,V=Lu(B,F),p=0==Z.translucencyIntensity?void 0:Z.translucencyIntensity,G=this._exporter._materialExporter.getTextureInfo(V)??void 0,R=!Z.translucencyColor||Z.translucencyColor.equalsFloats(1,1,1)?void 0:Z.translucencyColor.DR(),e=this._exporter._materialExporter.getTextureInfo(Z.translucencyColorTexture)??void 0,s={diffuseTransmissionFactor:p,diffuseTransmissionTexture:G,diffuseTransmissionColorFactor:R,diffuseTransmissionColorTexture:e};(G||e)&&this._exporter._materialNeedsUVsSet.add(F),u.extensions=u.extensions||{},u.extensions[Du]=s}Z(u)}))}}cB.RegisterExtension(Du,(B=>new qu(B)));const Wu="KHR_materials_dispersion";class Xu{constructor(){this.name=Wu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(B){if(B.unlit)return!1;const u=B.subSurface;return!(!u.isRefractionEnabled&&!u.isDispersionEnabled)}postExportMaterialAsync(B,u,F){return new Promise((B=>{if(F instanceof DB.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const B={dispersion:F.subSurface.dispersion};u.extensions=u.extensions||{},u.extensions[Wu]=B}B(u)}))}}cB.RegisterExtension(Wu,(()=>new Xu));const fu="KHR_materials_emissive_strength";class Cu{constructor(){this.name=fu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(B,u,F){return await new Promise((B=>{if(!(F instanceof DB.c))return B(u);const Z=F.emissiveColor.DR(),V=Math.max(...Z);if(V>1){this._wasUsed=!0,u.extensions||(u.extensions={});const B={emissiveStrength:V},Z=F.emissiveColor.scale(1/B.emissiveStrength);u.emissiveFactor=Z.DR(),u.extensions[fu]=B}return B(u)}))}}cB.RegisterExtension(fu,(B=>new Cu));const xu="KHR_materials_ior";class Uu{constructor(){this.name=xu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(B){return!B.unlit&&(void 0!=B.indexOfRefraction&&1.5!=B.indexOfRefraction)}postExportMaterialAsync(B,u,F){return new Promise((B=>{if(F instanceof DB.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const B={ior:F.indexOfRefraction};u.extensions=u.extensions||{},u.extensions[xu]=B}B(u)}))}}cB.RegisterExtension(xu,(B=>new Uu));const yu="KHR_materials_iridescence";class Ou{constructor(B){this.name=yu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,u,F){const Z=[];return F instanceof su.c&&F.iridescence.isEnabled?(F.iridescence.texture&&Z.push(F.iridescence.texture),F.iridescence.thicknessTexture&&F.iridescence.thicknessTexture!==F.iridescence.texture&&Z.push(F.iridescence.thicknessTexture),Z):[]}postExportMaterialAsync(B,u,F){return new Promise((B=>{if(F instanceof su.c){if(!F.iridescence.isEnabled)return void B(u);this._wasUsed=!0,u.extensions=u.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(F.iridescence.texture),V=this._exporter._materialExporter.getTextureInfo(F.iridescence.thicknessTexture),p={iridescenceFactor:F.iridescence.TR,iridescenceIor:F.iridescence.indexOfRefraction,iridescenceThicknessMinimum:F.iridescence.minimumThickness,iridescenceThicknessMaximum:F.iridescence.maximumThickness,iridescenceTexture:Z??void 0,iridescenceThicknessTexture:V??void 0};null===p.iridescenceTexture&&null===p.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(F),u.extensions[yu]=p}B(u)}))}}cB.RegisterExtension(yu,(B=>new Ou(B)));const gu="KHR_materials_sheen";class Ju{constructor(B){this.name=gu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,u,F){return F instanceof DB.c&&F.sheen.isEnabled&&F.sheen.texture?[F.sheen.texture]:[]}async postExportMaterialAsync(B,u,F){return await new Promise((B=>{if(F instanceof DB.c){if(!F.sheen.isEnabled)return void B(u);this._wasUsed=!0,null==u.extensions&&(u.extensions={});const Z={sheenColorFactor:F.sheen.color.DR(),sheenRoughnessFactor:F.sheen.roughness??0};null===Z.sheenColorTexture&&null===Z.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(F),F.sheen.texture&&(Z.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(F.sheen.texture)??void 0),F.sheen.textureRoughness&&!F.sheen.useRoughnessFromMainTexture?Z.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(F.sheen.textureRoughness)??void 0:F.sheen.texture&&F.sheen.useRoughnessFromMainTexture&&(Z.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(F.sheen.texture)??void 0),u.extensions[gu]=Z}B(u)}))}}cB.RegisterExtension(gu,(B=>new Ju(B)));const au="KHR_materials_specular";class Tu{constructor(B){this.name=au,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,u,F){const Z=[];return F instanceof DB.c&&this._isExtensionEnabled(F)?(F.metallicReflectanceTexture&&Z.push(F.metallicReflectanceTexture),F.reflectanceTexture&&Z.push(F.reflectanceTexture),Z):Z}_isExtensionEnabled(B){return!B.unlit&&(void 0!=B.metallicF0Factor&&1!=B.metallicF0Factor||void 0!=B.metallicReflectanceColor&&!B.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(B))}_hasTexturesExtension(B){return null!=B.metallicReflectanceTexture||null!=B.reflectanceTexture}postExportMaterialAsync(B,u,F){return new Promise((B=>{if(F instanceof DB.c&&this._isExtensionEnabled(F)){this._wasUsed=!0,u.extensions=u.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(F.metallicReflectanceTexture)??void 0,Z=this._exporter._materialExporter.getTextureInfo(F.reflectanceTexture)??void 0,V={specularFactor:1==F.metallicF0Factor?void 0:F.metallicF0Factor,specularTexture:B,specularColorFactor:F.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:F.metallicReflectanceColor.DR(),specularColorTexture:Z};this._hasTexturesExtension(F)&&this._exporter._materialNeedsUVsSet.add(F),u.extensions[au]=V}B(u)}))}}cB.RegisterExtension(au,(B=>new Tu(B)));const zu="KHR_materials_transmission";class Mu{constructor(B){this.name=zu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,u,F){const Z=[];return F instanceof DB.c&&this._isExtensionEnabled(F)?(F.subSurface.thicknessTexture&&Z.push(F.subSurface.thicknessTexture),Z):Z}_isExtensionEnabled(B){if(B.unlit)return!1;const u=B.subSurface;return u.isRefractionEnabled&&void 0!=u.refractionIntensity&&0!=u.refractionIntensity||this._hasTexturesExtension(B)}_hasTexturesExtension(B){return null!=B.subSurface.refractionIntensityTexture}async postExportMaterialAsync(B,u,F){if(F instanceof DB.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const Z=F.subSurface,V={transmissionFactor:0===Z.refractionIntensity?void 0:Z.refractionIntensity};if(this._hasTexturesExtension(F)&&this._exporter._materialNeedsUVsSet.add(F),Z.refractionIntensityTexture)if(Z.useGltfStyleTextures){const B=await this._exporter._materialExporter.exportTextureAsync(Z.refractionIntensityTexture,"image/png");B&&(V.transmissionTexture=B)}else H.d.Warn(`${B}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);u.extensions||(u.extensions={}),u.extensions[zu]=V}return u}}cB.RegisterExtension(zu,(B=>new Mu(B)));const ju="KHR_materials_unlit";class ou{constructor(){this.name=ju,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(B,u,F){return new Promise((B=>{let Z=!1;F instanceof DB.c?Z=F.unlit:F instanceof LB.Wu&&(Z=F.disableLighting),Z&&(this._wasUsed=!0,null==u.extensions&&(u.extensions={}),u.extensions[ju]={}),B(u)}))}}cB.RegisterExtension(ju,(()=>new ou));const Iu="KHR_materials_volume";class mF{constructor(B){this.name=Iu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,u,F){const Z=[];return F instanceof DB.c&&this._isExtensionEnabled(F)?(F.subSurface.thicknessTexture&&Z.push(F.subSurface.thicknessTexture),Z):Z}_isExtensionEnabled(B){if(B.unlit)return!1;const u=B.subSurface;return!(!u.isRefractionEnabled&&!u.isTranslucencyEnabled)&&(void 0!=u.maximumThickness&&0!=u.maximumThickness||void 0!=u.tintColorAtDistance&&u.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=u.tintColor&&u.tintColor!=q.Xu.White()||this._hasTexturesExtension(B))}_hasTexturesExtension(B){return null!=B.subSurface.thicknessTexture}postExportMaterialAsync(B,u,F){return new Promise((B=>{if(F instanceof DB.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const B=F.subSurface,Z={thicknessFactor:0==B.maximumThickness?void 0:B.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(B.thicknessTexture)??void 0,attenuationDistance:B.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:B.tintColorAtDistance,attenuationColor:B.tintColor.equalsFloats(1,1,1)?void 0:B.tintColor.DR()};this._hasTexturesExtension(F)&&this._exporter._materialNeedsUVsSet.add(F),u.extensions=u.extensions||{},u.extensions[Iu]=Z}B(u)}))}}cB.RegisterExtension(Iu,(B=>new mF(B)));const Eu="EXT_materials_diffuse_roughness";class wu{constructor(B){this.name=Eu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,u,F){const Z=[];return F instanceof su.c&&F._baseDiffuseRoughness?(F._baseDiffuseRoughnessTexture&&Z.push(F._baseDiffuseRoughnessTexture),Z):[]}postExportMaterialAsync(B,u,F){return new Promise((B=>{if(F instanceof su.c){if(!F._baseDiffuseRoughness)return void B(u);this._wasUsed=!0,u.extensions=u.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(F._baseDiffuseRoughnessTexture),V={diffuseRoughnessFactor:F._baseDiffuseRoughness,diffuseRoughnessTexture:Z??void 0};null!==V.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(F),u.extensions[Eu]=V}B(u)}))}}cB.RegisterExtension(Eu,(B=>new wu(B)));const Hu="KHR_texture_transform";class nu{constructor(){this.name=Hu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(B,u,F){if(F.yB()||V.Tools.Warn(`${B}: /*@__KEY__*/"scene" is not defined for Babylon texture ${F.name}!`),(0!==F.uAng||0!==F.vAng)&&(V.Tools.Warn(`${B}: Texture ${F.name} with rotation in the u or v axis is not supported in glTF.`),0!==F.uRotationCenter||0!==F.vRotationCenter))return;const Z={};let p=!1;if(0===F.uOffset&&0===F.vOffset||(Z.offset=[F.uOffset,F.vOffset],p=!0),1===F.uScale&&1===F.vScale||(Z.scale=[F.uScale,F.vScale],p=!0),0!==F.wAng){if(0!==F.uRotationCenter||0!==F.vRotationCenter){if(F.homogeneousRotationInUVTransform&&F.uScale!==F.vScale)return void V.Tools.Warn(`${B}: Texture ${F.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Hu}.`);V.Tools.Warn(`${B}: Texture ${F.name} with non-origin rotation center will be exported using an adjusted offset with ${Hu}.`),Z.offset=function(B){const{uOffset:u,vOffset:F,uRotationCenter:Z,vRotationCenter:V,uScale:p,vScale:G,wAng:R}=B,e=Math.cos(R),s=Math.sin(R),Y=Z*p,Q=V*G;return[u+(Y*(1-e)+Q*s),F+(Q*(1-e)-Y*s)]}(F)}Z.rotation=-F.wAng,p=!0}0!==F.coordinatesIndex&&(Z.texCoord=F.coordinatesIndex,p=!0),p&&(this._wasUsed=!0,u.extensions||(u.extensions={}),u.extensions[Hu]=Z)}}cB.RegisterExtension(Hu,(()=>new nu));class du{static CreateSTL(B){let u=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",V=arguments.length>3&&void 0!==arguments[3]&&arguments[3],p=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],G=arguments.length>5&&void 0!==arguments[5]&&arguments[5],R=arguments.length>6&&void 0!==arguments[6]&&arguments[6],e=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const s=function(B,u,F){const V=[3*B[F],3*B[F+1],3*B[F+2]],p=[new Z.Du(u[V[0]],u[V[0]+2],u[V[0]+1]),new Z.Du(u[V[1]],u[V[1]+2],u[V[1]+1]),new Z.Du(u[V[2]],u[V[2]+2],u[V[2]+1])],G=p[0].Lu(p[1]),R=p[2].Lu(p[1]);return{v:p,n:Z.Du.Cross(R,G).normalize()}},Q=function(B,u,F,Z){return u=t(B,u,F.x,Z),u=t(B,u,F.y,Z),t(B,u,F.z,Z)},t=function(B,u,F,Z){return B.setFloat32(u,F,Z),u+4},D=function(B){if(R){let u=B;B instanceof v.d&&(u=B.sourceMesh);const F=u.getVerticesData(Y.f.PositionKind,!0,!0);if(!F)return[];const V=Z.Du.Zero();let p;for(p=0;p<F.length;p+=3)Z.Du.TransformCoordinatesFromFloatsToRef(F[p],F[p+1],F[p+2],B.XR(!0),V).toArray(F,p);return F}return B.getVerticesData(Y.f.PositionKind)||[]};R&&(G=!0);let L="",q=0,W=0;if(V){for(let F=0;F<B.length;F++){const u=B[F].CR();q+=u?u.length/3:0}const u=new ArrayBuffer(84+50*q);L=new DataView(u),W+=80,L.setUint32(W,q,p),W+=4}else e||(L="solid stlmesh\r\n");for(let Z=0;Z<B.length;Z++){const u=B[Z];!V&&e&&(L+="solid "+u.name+"\r\n"),!G&&u instanceof XB.b&&u.bakeCurrentTransformIntoVertices();const F=D(u),R=u.CR()||[];for(let B=0;B<R.length;B+=3){const u=s(R,F,B);V?(W=Q(L,W,u.n,p),W=Q(L,W,u.v[0],p),W=Q(L,W,u.v[1],p),W=Q(L,W,u.v[2],p),W+=2):(L+="\tfacet normal "+u.n.x+" "+u.n.y+" "+u.n.z+"\r\n",L+="\t\touter loop\r\n",L+="\t\t\tvertex "+u.v[0].x+" "+u.v[0].y+" "+u.v[0].z+"\r\n",L+="\t\t\tvertex "+u.v[1].x+" "+u.v[1].y+" "+u.v[1].z+"\r\n",L+="\t\t\tvertex "+u.v[2].x+" "+u.v[2].y+" "+u.v[2].z+"\r\n",L+="\t\tendloop\r\n",L+="\tendfacet\r\n")}!V&&e&&(L+="endsolid "+name+"\r\n")}if(V||e||(L+="endsolid stlmesh"),u){const B=document.createElement("a"),u=new Blob([L],{type:"application/octet-stream"});B.href=window.URL.createObjectURL(u),B.download=F+".stl",B.click()}return L}}function lu(B,u){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const Z=[];for(let V=0;V<B.length/F;V++){const p=B[V*F],G=B[V*F+1],R=B[V*F+2];Z.push(`(${p.toPrecision(u.precision)}, ${G.toPrecision(u.precision)}, ${R.toPrecision(u.precision)})`)}return Z.join(", ")}function Pu(B,u){const F=[];for(let Z=0;Z<B.length/2;Z++){const V=B[2*Z],p=B[2*Z+1];F.push(`(${V.toPrecision(u.precision)}, ${(1-p).toPrecision(u.precision)})`)}return F.join(", ")}function cu(B,u){const F=B.getVerticesData(Y.f.PositionKind),Z=B.getVerticesData(Y.f.NormalKind);if(F&&Z)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(B){var u;const F=null!==(u=B.CR())&&void 0!==u&&u.length?B.getTotalIndices():B.getTotalVertices();return Array(F/3).fill(3).join(", ")}(B)}]\n\t\tint[] faceVertexIndices = [${function(B){const u=B.CR(),F=[];if(null!==u)for(let Z=0;Z<u.length;Z++)F.push(u[Z]);else{const u=B.getTotalVertices();for(let B=0;B<u;B++)F.push(B)}return F.join(", ")}(B)}]\n\t\tnormal3f[] normals = [${lu(Z,u)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${lu(F,u)}]\n        ${function(B,u){let F="";for(let V=0;V<4;V++){const Z=V>0?V:"",p=B.getVerticesData(Y.f.UVKind+(Z?Z+1:""));p&&(F+=`\n\t\ttexCoord2f[] primvars:st${Z} = [${Pu(p,u)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const Z=B.getVerticesData(Y.f.ColorKind);return Z&&(F+=`\n\tcolor3f[] primvars:displayColor = [${lu(Z,u,Z.length/B.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),F}(B,u)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function hu(B,u){return`\n        def "Geometry"\n        {\n        ${cu(B,u)}\n        }\n        `}function iu(B){let u='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return u+=B,fflate.strToU8(u)}function ru(B){const u=B.m;return`( ${Ku(u,0)}, ${Ku(u,4)}, ${Ku(u,8)}, ${Ku(u,12)} )`}function Ku(B,u){return`(${B[u+0]}, ${B[u+1]}, ${B[u+2]}, ${B[u+3]})`}function Nu(B){const u="Object_"+B.uniqueId,F=function(B){const u=B.getWorldMatrix().clone(),F=B.yB().useRightHandedSystem;if(!F){let Z=B.parent;for(;Z;){if(GB(Z,F)){u.multiplyToRef(Z.getWorldMatrix().invert(),u);break}Z=Z.parent}}return u.determinant()<0&&V.Tools.Warn(`Exporting mesh ${B.name} with negative scale. Result may look incorrect in destination engine.`),u}(B),Z=ru(F);return`def Xform "${u}" (\n\tprepend references = @./geometries/Geometry_${B.fR.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${Z}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${B.material.uniqueId}>\n}\n\n`}function Au(B){switch(B){case y.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case y.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case y.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function bu(B){return`(${B.x}, ${B.y})`}function ku(B){return`(${B.r}, ${B.g}, ${B.b})`}function Su(B,u,F,V,p,G){const R=B.getInternalTexture().uniqueId+"_"+B.invertY;p[R]=B;const e=B.coordinatesIndex>0?"st"+B.coordinatesIndex:"st",s=new Z.Vector2(B.uScale,B.vScale),Y=new Z.Vector2(B.uOffset,B.vOffset),Q=B.wAng,t=Math.sin(Q),v=Math.cos(Q);return Y.y=1-Y.y-s.y,Y.x+=t*s.x,Y.y+=(1-v)*s.y,`\n    def Shader "PrimvarReader_${F}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${e}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${F}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${u.uniqueId}/PrimvarReader_${F}.outputs:result>\n        float inputs:rotation = ${(Q*(180/Math.PI)).toFixed(G.precision)}\n        float2 inputs:scale = ${bu(s)}\n        float2 inputs:translation = ${bu(Y)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${B.uniqueId}_${F}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${R}.png@\n        float2 inputs:st.connect = </Materials/Material_${u.uniqueId}/Transform2d_${F}.outputs:result>\n        ${V?"float4 inputs:scale = "+function(B){return`(${B.r}, ${B.g}, ${B.b}, 1.0)`}(V):""}\n        token inputs:sourceColorSpace = "${B.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Au(B.wrapU)}"\n        token inputs:wrapT = "${Au(B.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${u.needAlphaBlending()?"float outputs:a":""}\n    }`}function BF(B,u,F){const Z="\t\t\t",V=[],p=[],{diffuseMap:G,zR:R,alphaCutOff:e,emissiveMap:s,emissive:Y,normalMap:Q,roughnessMap:t,roughnessChannel:v,roughness:D,metalnessMap:L,metalnessChannel:W,metalness:X,aoMap:f,aoMapChannel:C,aoMapIntensity:x,alphaMap:U,ior:y,clearCoatEnabled:O,clearCoat:g,clearCoatMap:J,clearCoatRoughness:a,clearCoatRoughnessMap:T}=function(B){const u={diffuseMap:null,zR:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return B instanceof LB.Wu?{...u,diffuseMap:B.diffuseTexture,zR:B.diffuseColor,alphaCutOff:B.alphaCutOff,emissiveMap:B.emissiveTexture,emissive:B.emissiveColor,roughness:1,alphaMap:B.opacityTexture}:B instanceof su.c?{...u,diffuseMap:B._albedoTexture,zR:B._albedoColor,alphaCutOff:B._alphaCutOff,emissiveMap:B._emissiveTexture,emissive:B._emissiveColor,normalMap:B._bumpTexture,roughnessMap:B._metallicTexture,roughnessChannel:B._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:B._roughness??1,metalnessMap:B._metallicTexture,metalnessChannel:B._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:B._metallic??0,aoMap:B._ambientTexture,aoMapChannel:B._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:B._ambientTextureStrength,alphaMap:B._opacityTexture,ior:B.subSurface.indexOfRefraction,clearCoatEnabled:B.clearCoat.isEnabled,clearCoat:B.clearCoat.TR,clearCoatMap:B.clearCoat.texture,clearCoatRoughness:B.clearCoat.roughness,clearCoatRoughnessMap:B.clearCoat.useRoughnessFromMainTexture?B.clearCoat.texture:B.clearCoat.textureRoughness}:u}(B);return null!==G?(V.push(`${Z}color3f inputs:diffuseColor.connect = </Materials/Material_${B.uniqueId}/Texture_${G.uniqueId}_diffuse.outputs:rgb>`),B.needAlphaBlending()?V.push(`${Z}float inputs:opacity.connect = </Materials/Material_${B.uniqueId}/Texture_${G.uniqueId}_diffuse.outputs:a>`):B.needAlphaTesting()&&(V.push(`${Z}float inputs:opacity.connect = </Materials/Material_${B.uniqueId}/Texture_${G.uniqueId}_diffuse.outputs:a>`),V.push(`${Z}float inputs:opacityThreshold = ${e}`)),p.push(Su(G,B,"diffuse",R,u,F))):V.push(`${Z}color3f inputs:diffuseColor = ${ku(R||q.Xu.White())}`),null!==s?(V.push(`${Z}color3f inputs:emissiveColor.connect = </Materials/Material_${B.uniqueId}/Texture_${s.uniqueId}_emissive.outputs:rgb>`),p.push(Su(s,B,"emissive",Y,u,F))):Y&&Y.toLuminance()>0&&V.push(`${Z}color3f inputs:emissiveColor = ${ku(Y)}`),null!==Q&&(V.push(`${Z}normal3f inputs:normal.connect = </Materials/Material_${B.uniqueId}/Texture_${Q.uniqueId}_normal.outputs:rgb>`),p.push(Su(Q,B,"normal",null,u,F))),null!==f&&(V.push(`${Z}float inputs:occlusion.connect = </Materials/Material_${B.uniqueId}/Texture_${f.uniqueId}_occlusion.outputs:${C}>`),p.push(Su(f,B,"occlusion",new q.Xu(x,x,x),u,F))),null!==t?(V.push(`${Z}float inputs:roughness.connect = </Materials/Material_${B.uniqueId}/Texture_${t.uniqueId}_roughness.outputs:${v}>`),p.push(Su(t,B,"roughness",new q.Xu(D,D,D),u,F))):V.push(`${Z}float inputs:roughness = ${D}`),null!==L?(V.push(`${Z}float inputs:metallic.connect = </Materials/Material_${B.uniqueId}/Texture_${L.uniqueId}_metallic.outputs:${W}>`),p.push(Su(L,B,"metallic",new q.Xu(X,X,X),u,F))):V.push(`${Z}float inputs:metallic = ${X}`),null!==U?(V.push(`${Z}float inputs:opacity.connect = </Materials/Material_${B.uniqueId}/Texture_${U.uniqueId}_opacity.outputs:r>`),V.push(`${Z}float inputs:opacityThreshold = 0.0001`),p.push(Su(U,B,"opacity",null,u,F))):V.push(`${Z}float inputs:opacity = ${B.alpha}`),O&&(null!==J?(V.push(`${Z}float inputs:clearcoat.connect = </Materials/Material_${B.uniqueId}/Texture_${J.uniqueId}_clearcoat.outputs:r>`),p.push(Su(J,B,"clearcoat",new q.Xu(g,g,g),u,F))):V.push(`${Z}float inputs:clearcoat = ${g}`),null!==T?(V.push(`${Z}float inputs:clearcoatRoughness.connect = </Materials/Material_${B.uniqueId}/Texture_${T.uniqueId}_clearcoatRoughness.outputs:g>`),p.push(Su(T,B,"clearcoatRoughness",new q.Xu(a,a,a),u,F))):V.push(`${Z}float inputs:clearcoatRoughness = ${a}`)),V.push(`${Z}float inputs:ior = ${y}`),`\n\tdef Material "Material_${B.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${V.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${B.uniqueId}/PreviewSurface.outputs:surface>\n\n${p.join("\n")}\n\n\t}\n`}async function uF(B,u,F){const p={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...u};"undefined"===typeof fflate&&await V.Tools.LoadScriptAsync(p.fflateUrl);const G={};G[p.modelFileName]=null;let R='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';R+=function(B){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===B.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${B.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${B.planeAnchoringAlignment}"`:""}\n            `}(p);const e={};for(const Z of B.meshes){if(0===Z.getTotalVertices())continue;const B=Z,u=B.fR,s=B.material;if(!s||!u||F&&!F(B))continue;if(-1!==["Wu","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(s.getClassName())){const F="geometries/Geometry_"+u.uniqueId+".usda";if(!(F in G)){const B=hu(u,p);G[F]=iu(B)}s.uniqueId in e||(e[s.uniqueId]=s),R+=Nu(B)}else V.Tools.Warn("USDZExportAsync does not support this material type: "+s.getClassName())}B.activeCamera&&p.exportCamera&&(R+=function(B,u){const F="Camera_"+B.uniqueId,V=ru(Z.Matrix.RotationY(Math.PI).multiply(B.getWorldMatrix()));if(B.mode===y.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${F}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${V}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${B.qR.toPrecision(u.precision)}, ${B.maxZ.toPrecision(u.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(B.orthoLeft||1)+Math.abs(B.orthoRight||1))).toPrecision(u.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(B.orthoTop||1)+Math.abs(B.orthoBottom||1))).toPrecision(u.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const Z=B.getEngine().getAspectRatio(B),p=u.cameraSensorWidth||35;return`def Camera "${F}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${V}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${B.qR.toPrecision(u.precision)}, ${B.maxZ.toPrecision(u.precision)})\n\t\t\tfloat focalLength = ${(p/(2*Math.tan(.5*B.fov))).toPrecision(u.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(p*Z).toPrecision(u.precision)}\n\t\t\tfloat verticalAperture = ${(p/Z).toPrecision(u.precision)}            \n\t\t}\n\t\n\t`}}(B.activeCamera,p)),R+="\n            }\n        }\n    }";const s={};R+=function(B,u,F){const Z=[];for(const V in B){const p=B[V];Z.push(BF(p,u,F))}return`\n    def "Materials"\n{\n${Z.join("")}\n}\n\n`}(e,s,p),G[p.modelFileName]=fflate.strToU8(R);for(const Z in s){const B=s[Z],u=B.getSize(),F=await B.readPixels();if(!F)throw new Error("Texture data is not available");const V=await O.DumpTools.DumpDataAsync(u.width,u.height,F,"image/png",void 0,!1,!0);G[`textures/Texture_${Z}.png`]=new Uint8Array(V).slice()}let Y=0;for(const Z in G){const B=G[Z];if(!B)continue;Y+=34+Z.length;const u=63&Y;if(4!==u){const F=new Uint8Array(64-u);G[Z]=[B,{extra:{12345:F}}]}Y=B.length}return fflate.zipSync(G,{level:0})}}}]);