"use strict";(self.vfdo5lmva5i=self.vfdo5lmva5i||[]).push([[26],{12119:(w,o,H)=>{H.r(o),H.d(o,{EXT_materials_diffuse_roughness:()=>qo,EXT_mesh_gpu_instancing:()=>Zw,GLTF2Export:()=>Iw,GLTFData:()=>L,KHR_draco_mesh_compression:()=>Ho,KHR_lights_punctual:()=>Xo,KHR_materials_anisotropy:()=>yo,KHR_materials_clearcoat:()=>Co,KHR_materials_diffuse_transmission:()=>io,KHR_materials_dispersion:()=>Vo,KHR_materials_emissive_strength:()=>ko,KHR_materials_ior:()=>lo,KHR_materials_iridescence:()=>To,KHR_materials_sheen:()=>co,KHR_materials_specular:()=>Bo,KHR_materials_transmission:()=>go,KHR_materials_unlit:()=>po,KHR_materials_volume:()=>No,KHR_texture_transform:()=>no,OBJExport:()=>D,STLExport:()=>Go,USDZExportAsync:()=>HH,_ConvertToGLTFPBRMetallicRoughness:()=>b,_SolveMetallic:()=>g,__IGLTFExporterExtension:()=>t});var h=H(11720),E=H(11531),e=H(12033);class D{static OBJ(w,o,H,D){const t=[];let X=1,L=1;o&&(H||(H="mat"),t.push("mtllib "+H+".mtl"));for(let A=0;A<w.length;A++){const H=w[A],y=H.name||`mesh${A}}`;t.push(`o ${y}`);let z=null;if(D){const w=H.se(!0);z=new h.Matrix,w.invertToRef(z),H.bakeTransformIntoVertices(w)}if(o){const w=H.material;w&&t.push("usemtl "+w.id)}const C=H.re;if(!C){E.Tools.Warn("No geometry is present on the mesh");continue}const Q=C.getVerticesData("position"),M=C.getVerticesData("normal"),i=C.getVerticesData("uv"),s=C.ke();let V=0,r=0;if(!Q||!s){E.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const k=w[0].Ow().useRightHandedSystem?1:-1;for(let w=0;w<Q.length;w+=3)t.push("v "+Q[w]*k+" "+Q[w+1]+" "+Q[w+2]),V++;if(null!=M)for(let w=0;w<M.length;w+=3)t.push("vn "+M[w]*k+" "+M[w+1]+" "+M[w+2]);if(null!=i)for(let w=0;w<i.length;w+=2)t.push("vt "+i[w]+" "+i[w+1]),r++;const P=["","",""],l=(H.material||H.Ow().defaultMaterial)._getEffectiveOrientation(H),[O,T]=l===e.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let w=0;w<s.length;w+=3){const o=[String(s[w]+X),String(s[w+O]+X),String(s[w+T]+X)],H=[String(s[w]+L),String(s[w+O]+L),String(s[w+T]+L)],h=o,E=null!=i?H:P,e=null!=M?o:P;t.push("f "+h[0]+"/"+E[0]+"/"+e[0]+" "+h[1]+"/"+E[1]+"/"+e[1]+" "+h[2]+"/"+E[2]+"/"+e[2])}D&&z&&H.bakeTransformIntoVertices(z),X+=V,L+=r}return t.join("\n")}static MTL(w){const o=[],H=w.material;o.push("newmtl mat1"),o.push("  Ns "+H.specularPower.toFixed(4)),o.push("  Ni 1.5000"),o.push("  d "+H.alpha.toFixed(4)),o.push("  Tr 0.0000"),o.push("  Tf 1.0000 1.0000 1.0000"),o.push("  illum 2"),o.push("  Ka "+H.ambientColor.r.toFixed(4)+" "+H.ambientColor.g.toFixed(4)+" "+H.ambientColor.b.toFixed(4)),o.push("  Kd "+H.diffuseColor.r.toFixed(4)+" "+H.diffuseColor.g.toFixed(4)+" "+H.diffuseColor.b.toFixed(4)),o.push("  Ks "+H.specularColor.r.toFixed(4)+" "+H.specularColor.g.toFixed(4)+" "+H.specularColor.b.toFixed(4)),o.push("  Ke "+H.emissiveColor.r.toFixed(4)+" "+H.emissiveColor.g.toFixed(4)+" "+H.emissiveColor.b.toFixed(4));H.ambientTexture&&o.push("  map_Ka "+H.ambientTexture.name),H.diffuseTexture&&o.push("  map_Kd "+H.diffuseTexture.name),H.specularTexture&&o.push("  map_Ks "+H.specularTexture.name),H.bumpTexture&&o.push("  map_bump -imfchan z "+H.bumpTexture.name),H.opacityTexture&&o.push("  map_d "+H.opacityTexture.name);return o.join("\n")}}var t=0,X=H(11573);class L{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const w in this.files){const o=this.files[w],H=new Blob([o],{type:(0,X.k)(w)});E.Tools.Download(H,w)}}}var A=H(11780),y=H(12128),z=H(12135),C=H(12157),Q=H(11837),M=H(11571),i=H(11757),s=H(11729);const V=s.HighestCommonFactor,r={...s,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:V};var k=H(11945),P=H(11690),l=H(12186),O=H(12189),T=H(11936);const S=1e-6,c=new i.ko(.04,.04,.04),W=1024,B=i.ko.White(),J=i.ko.Black();function g(w,o,H){if(o<c.r)return 0;const h=c.r,E=w*H/(1-c.r)+o-2*c.r,e=E*E-4*h*(c.r-o);return r.Clamp((-E+Math.sqrt(e))/(2*h),0,1)}function b(w){const o=w.diffuseColor.toLinearSpace(w.Ow().getEngine().useExactSrgbConversions).scale(.5),H=w.alpha,E=function(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h.Vector2(0,1),H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new h.Vector2(0,.1),E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new h.Vector2(0,.1),e=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new h.Vector2(1300,.1);return function(w,o,H,h,E){return(1-w)*(1-w)*(1-w)*o+3*(1-w)*(1-w)*w*H+3*(1-w)*w*w*h+w*w*w*E}(Math.pow(w/e.x,.333333),o.y,H.y,E.y,e.y)}(r.Clamp(w.specularPower,0,W));return{baseColorFactor:[o.r,o.g,o.b,H],metallicFactor:0,roughnessFactor:E}}function p(w,o){o.needAlphaBlending()?w.alphaMode="BLEND":o.needAlphaTesting()&&(w.alphaMode="MASK",w.alphaCutoff=o.alphaCutOff)}function f(w,o,H){const h=new Uint8Array(w*o*4);for(let E=0;E<h.length;E+=4)h[E]=h[E+1]=h[E+2]=h[E+3]=255;return l.c.CreateRGBATexture(h,w,o,H)}function N(w){if(w instanceof Uint8Array){const o=w.length,H=new Float32Array(w.length);for(let h=0;h<o;++h)H[h]=w[h]/255;return H}if(w instanceof Float32Array)return w;throw new Error("Unsupported pixel format!")}class j{constructor(w){this._exporter=w,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(w){return w?this._textureMap.get(w)??null:null}async exportStandardMaterialAsync(w,o,H){const h=b(w),e={name:w.name};if(null==w.Oe||w.Oe||(w.twoSidedLighting||E.Tools.Warn(w.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),e.doubleSided=!0),H){const H=[],E=w.diffuseTexture;E&&H.push(this.exportTextureAsync(E,o).then((w=>{w&&(h.baseColorTexture=w)})));const D=w.bumpTexture;D&&H.push(this.exportTextureAsync(D,o).then((w=>{w&&(e.normalTexture=w,1!==D.level&&(e.normalTexture.scale=D.level))})));const t=w.emissiveTexture;t&&(e.emissiveFactor=[1,1,1],H.push(this.exportTextureAsync(t,o).then((w=>{w&&(e.emissiveTexture=w)}))));const X=w.ambientTexture;X&&H.push(this.exportTextureAsync(X,o).then((w=>{if(w){const o={index:w.index};e.occlusionTexture=o}}))),H.length>0&&(this._exporter._materialNeedsUVsSet.add(w),await Promise.all(H))}(w.alpha<1||w.opacityTexture)&&(w.alphaMode===O.e.ALPHA_COMBINE?e.alphaMode="BLEND":E.Tools.Warn(w.name+": glTF 2.0 does not support alpha mode: "+w.alphaMode.toString())),w.emissiveColor&&!w.emissiveColor.equalsWithEpsilon(J,S)&&(e.emissiveFactor=w.emissiveColor.Ae()),e.pbrMetallicRoughness=h,p(e,w),await this._finishMaterialAsync(e,w,o);const D=this._exporter._materials;return D.push(e),D.length-1}async _finishMaterialAsync(w,o,H){const h=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",w,o),E=[];for(const e of h)E.push(this.exportTextureAsync(e,H));await Promise.all(E),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",w,o)}async _getImageDataAsync(w,o,h,E){const e=O.e.TEXTURETYPE_UNSIGNED_BYTE,D=this._exporter._babylonScene,t=D.getEngine(),X=t.createRawTexture(w,o,h,O.e.TEXTUREFORMAT_RGBA,!1,!0,P.d.NEAREST_SAMPLINGMODE,null,e);t.isWebGPU?await H.e(51).then(H.bind(H,14274)):await H.e(52).then(H.bind(H,14283)),await k.m.ApplyPostProcess("pass",X,D,e,O.e.TEXTURE_NEAREST_SAMPLINGMODE,O.e.TEXTUREFORMAT_RGBA);const L=await t._readTexturePixels(X,o,h);return await T.DumpTools.DumpDataAsync(o,h,L,E,void 0,!0,!0)}_resizeTexturesToSameDimensions(w,o,H){const h=w?w.getSize():{width:0,height:0},E=o?o.getSize():{width:0,height:0};let e,D;return h.width<E.width?(e=w&&w instanceof P.d?k.m.CreateResizedCopy(w,E.width,E.height,!0):f(E.width,E.height,H),D=o):h.width>E.width?(D=o&&o instanceof P.d?k.m.CreateResizedCopy(o,h.width,h.height,!0):f(h.width,h.height,H),e=w):(e=w,D=o),{texture1:e,texture2:D}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(w,o,H,h){const E=new Array;if(!w&&!o)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const e=w?w.Ow():o?o.Ow():null;if(e){var D;const t=this._resizeTexturesToSameDimensions(w,o,e),X=null===(D=t.texture1)||void 0===D?void 0:D.getSize();let L,A;const y=X.width,z=X.height,C=await t.texture1.readPixels(),Q=await t.texture2.readPixels();if(!C)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(L=N(C),!Q)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");A=N(Q);const M=A.byteLength,s=new Uint8Array(M),V=new Uint8Array(M),r=4,k=J;let P=0,l=0;for(let w=0;w<z;++w)for(let o=0;o<y;++o){const h=(y*w+o)*r,E={diffuseColor:new i.ko(L[h],L[h+1],L[h+2]).toLinearSpace(e.getEngine().useExactSrgbConversions).multiply(H.diffuseColor),specularColor:new i.ko(A[h],A[h+1],A[h+2]).toLinearSpace(e.getEngine().useExactSrgbConversions).multiply(H.specularColor),glossiness:A[h+3]*H.glossiness},D=this._convertSpecularGlossinessToMetallicRoughness(E);k.r=Math.max(k.r,D.baseColor.r),k.g=Math.max(k.g,D.baseColor.g),k.b=Math.max(k.b,D.baseColor.b),P=Math.max(P,D.metallic),l=Math.max(l,D.roughness),V[h]=255*D.baseColor.r,V[h+1]=255*D.baseColor.g,V[h+2]=255*D.baseColor.b,V[h+3]=t.texture1.ze?255*L[h+3]:255,s[h]=0,s[h+1]=255*D.roughness,s[h+2]=255*D.metallic,s[h+3]=255}const O={baseColor:k,metallic:P,roughness:l};let T=!1,c=!1;for(let w=0;w<z;++w)for(let o=0;o<y;++o){const H=(y*w+o)*r;V[H]/=O.baseColor.r>S?O.baseColor.r:1,V[H+1]/=O.baseColor.g>S?O.baseColor.g:1,V[H+2]/=O.baseColor.b>S?O.baseColor.b:1;const h=i.ko.FromInts(V[H],V[H+1],V[H+2]).toGammaSpace(e.getEngine().useExactSrgbConversions);V[H]=255*h.r,V[H+1]=255*h.g,V[H+2]=255*h.b,h.equalsWithEpsilon(B,S)||(c=!0),s[H+1]/=O.roughness>S?O.roughness:1,s[H+2]/=O.metallic>S?O.metallic:1;i.ko.FromInts(255,s[H+1],s[H+2]).equalsWithEpsilon(B,S)||(T=!0)}return T&&E.push(this._getImageDataAsync(s,y,z,h).then((w=>{O.metallicRoughnessTextureData=w}))),c&&E.push(this._getImageDataAsync(V,y,z,h).then((w=>{O.baseColorTextureData=w}))),await Promise.all(E).then((()=>O))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(w){const o=this._getPerceivedBrightness(w.diffuseColor),H=this._getPerceivedBrightness(w.specularColor),h=1-this._getMaxComponent(w.specularColor),E=g(o,H,h),e=w.diffuseColor.scale(h/(1-c.r)/Math.max(1-E)),D=w.specularColor.so(c.scale(1-E)).scale(1/Math.max(E));let t=i.ko.Lerp(e,D,E*E);t=t.clampToRef(0,1,t);return{baseColor:t,metallic:E,roughness:1-w.glossiness}}_getPerceivedBrightness(w){return w?Math.sqrt(.299*w.r*w.r+.587*w.g*w.g+.114*w.b*w.b):0}_getMaxComponent(w){return w?Math.max(w.r,Math.max(w.g,w.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(w,o,H,h){const E=[],e={baseColor:w._albedoColor,metallic:w._metallic,roughness:w._roughness};if(h){w._albedoTexture&&E.push(this.exportTextureAsync(w._albedoTexture,o).then((w=>{w&&(H.baseColorTexture=w)})));const h=w._metallicTexture;h&&E.push(this.exportTextureAsync(h,o).then((w=>{w&&(H.metallicRoughnessTexture=w)})))}return E.length>0&&(this._exporter._materialNeedsUVsSet.add(w),await Promise.all(E)),e}_getTextureSampler(w){const o={};if(!w||!(w instanceof P.d))return o;const H=this._getGLTFTextureWrapMode(w.wrapU);10497!==H&&(o.wrapS=H);const h=this._getGLTFTextureWrapMode(w.wrapV);switch(10497!==h&&(o.wrapT=h),w.samplingMode){case P.d.LINEAR_LINEAR:o.magFilter=9729,o.minFilter=9729;break;case P.d.LINEAR_NEAREST:o.magFilter=9729,o.minFilter=9728;break;case P.d.NEAREST_LINEAR:o.magFilter=9728,o.minFilter=9729;break;case P.d.NEAREST_LINEAR_MIPLINEAR:o.magFilter=9728,o.minFilter=9987;break;case P.d.NEAREST_NEAREST:o.magFilter=9728,o.minFilter=9728;break;case P.d.NEAREST_LINEAR_MIPNEAREST:o.magFilter=9728,o.minFilter=9985;break;case P.d.LINEAR_NEAREST_MIPNEAREST:o.magFilter=9729,o.minFilter=9984;break;case P.d.LINEAR_NEAREST_MIPLINEAR:o.magFilter=9729,o.minFilter=9986;break;case P.d.NEAREST_NEAREST_MIPLINEAR:o.magFilter=9728,o.minFilter=9986;break;case P.d.LINEAR_LINEAR_MIPLINEAR:o.magFilter=9729,o.minFilter=9987;break;case P.d.LINEAR_LINEAR_MIPNEAREST:o.magFilter=9729,o.minFilter=9985;break;case P.d.NEAREST_NEAREST_MIPNEAREST:o.magFilter=9728,o.minFilter=9984}return o}_getGLTFTextureWrapMode(w){switch(w){case P.d.WRAP_ADDRESSMODE:return 10497;case P.d.CLAMP_ADDRESSMODE:return 33071;case P.d.MIRROR_ADDRESSMODE:return 33648;default:return E.Tools.Error(`Unsupported Texture Wrap Mode ${w}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(w,o,H,h){const E={diffuseColor:w._albedoColor,specularColor:w._reflectivityColor,glossiness:w._microSurface},e=w._albedoTexture,D=w._reflectivityTexture,t=w._useMicroSurfaceFromReflectivityMapAlpha;if(D&&!t)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((e||D)&&h){this._exporter._materialNeedsUVsSet.add(w);const h=this._exportTextureSampler(e||D),t=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(e,D,E,o),X=this._exporter._textures;if(t.baseColorTextureData){const w=this._exportImage(`baseColor${X.length}`,o,t.baseColorTextureData);H.baseColorTexture=this._exportTextureInfo(w,h,null===e||void 0===e?void 0:e.coordinatesIndex)}if(t.metallicRoughnessTextureData){const w=this._exportImage(`metallicRoughness${X.length}`,o,t.metallicRoughnessTextureData);H.metallicRoughnessTexture=this._exportTextureInfo(w,h,null===D||void 0===D?void 0:D.coordinatesIndex)}return t}return this._convertSpecularGlossinessToMetallicRoughness(E)}async exportPBRMaterialAsync(w,o,H){const h={},E={name:w.name},e=w.isMetallicWorkflow();if(e){const o=w._albedoColor,H=w.alpha;o&&(h.baseColorFactor=[o.r,o.g,o.b,H])}const D=e?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(w,o,h,H):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(w,o,h,H);await this._setMetallicRoughnessPbrMaterialAsync(D,w,E,h,o,H),await this._finishMaterialAsync(E,w,o);const t=this._exporter._materials;return t.push(E),t.length-1}async _setMetallicRoughnessPbrMaterialAsync(w,o,H,h,e,D){if(p(H,o),w.baseColor.equalsWithEpsilon(B,S)&&r.WithinEpsilon(o.alpha,1,S)||(h.baseColorFactor=[w.baseColor.r,w.baseColor.g,w.baseColor.b,o.alpha]),null!=w.metallic&&1!==w.metallic&&(h.metallicFactor=w.metallic),null!=w.roughness&&1!==w.roughness&&(h.roughnessFactor=w.roughness),null==o.Oe||o.Oe||(o._twoSidedLighting||E.Tools.Warn(o.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),H.doubleSided=!0),D){const w=[],h=o._bumpTexture;h&&w.push(this.exportTextureAsync(h,e).then((w=>{w&&(H.normalTexture=w,1!==h.level&&(H.normalTexture.scale=h.level))})));const E=o._ambientTexture;E&&w.push(this.exportTextureAsync(E,e).then((w=>{if(w){const h={index:w.index,texCoord:w.texCoord,extensions:w.extensions};H.occlusionTexture=h;const E=o._ambientTextureStrength;E&&(h.strength=E)}})));const D=o._emissiveTexture;D&&w.push(this.exportTextureAsync(D,e).then((w=>{w&&(H.emissiveTexture=w)}))),w.length>0&&(this._exporter._materialNeedsUVsSet.add(o),await Promise.all(w))}const t=o._emissiveColor;t.equalsWithEpsilon(J,S)||(H.emissiveFactor=t.Ae()),H.pbrMetallicRoughness=h}_getPixelsFromTextureAsync(w){return function(w){switch(w){case O.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case O.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case O.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case O.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case O.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case O.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case O.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case O.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case O.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case O.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case O.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case O.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case O.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case O.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case O.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case O.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case O.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case O.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case O.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case O.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case O.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(w.textureFormat)?(0,k.l)(w,w._texture.width,w._texture.height):(w.textureType,O.e.TEXTURETYPE_UNSIGNED_BYTE,w.readPixels())}async exportTextureAsync(w,o){const H=this._exporter._extensionsPreExportTextureAsync("exporter",w,o);return H?await H.then((async H=>H?await this._exportTextureInfoAsync(H,o):await this._exportTextureInfoAsync(w,o))):await this._exportTextureInfoAsync(w,o)}async _exportTextureInfoAsync(w,o){let H=this._textureMap.get(w);if(!H){const h=await this._getPixelsFromTextureAsync(w);if(!h)return null;const e=this._exportTextureSampler(w),D=w.mimeType;if(D)switch(D){case"image/jpeg":case"image/png":case"image/webp":o=D;break;default:E.Tools.Warn(`Unsupported media type: ${D}. Exporting texture as PNG.`)}const t=this._internalTextureToImage,X=w.getInternalTexture().uniqueId;t[X]||(t[X]={});let L=t[X][o];if(void 0===L){const H=w.getSize();L=(async()=>{const E=await this._getImageDataAsync(h,H.width,H.height,o);return this._exportImage(w.name,o,E)})(),t[X][o]=L}H=this._exportTextureInfo(await L,e,w.coordinatesIndex),this._textureMap.set(w,H),this._exporter._extensionsPostExportTextures("exporter",H,w)}return H}_exportImage(w,o,H){const h=this._exporter._images;let e;if(this._exporter._shouldUseGlb){e={name:w,mimeType:o,bufferView:void 0};const h=this._exporter._bufferManager.createBufferView(new Uint8Array(H));this._exporter._bufferManager.setBufferView(e,h)}else{const D=w.replace(/\.\/|\/|\.\\|\\/g,"_"),t=function(w){switch(w){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(o);let X=D+t;h.some((w=>w.uri===X))&&(X=`${D}_${E.Tools.RandomId()}${t}`),e={name:w,uri:X},this._exporter._imageData[X]={data:H,mimeType:o}}return h.push(e),h.length-1}_exportTextureInfo(w,o,H){const h=this._exporter._textures;let E=h.findIndex((H=>H.sampler==o&&H.source===w));-1===E&&(E=h.length,h.push({source:w,sampler:o}));const e={index:E};return H&&(e.texCoord=H),e}_exportTextureSampler(w){const o=this._getTextureSampler(w),H=this._exporter._samplers,h=H.findIndex((w=>w.minFilter===o.minFilter&&w.magFilter===o.magFilter&&w.wrapS===o.wrapS&&w.wrapT===o.wrapT));return-1!==h?h:(H.push(o),H.length-1)}}var q=H(11794),u=H(11551),n=H(12196),G=H(11722);const R=h.io.Zero(),a=h.Quaternion.Identity(),d=h.io.One(),I=new h.io(-1,1,1);function U(w,o){const{byteOffset:H,byteStride:h,type:E,normalized:e}=w,D=w.getSize(),t=o.reduce(((w,o)=>o.getTotalVertices()>w?o.getTotalVertices():w),-Number.MAX_VALUE);return{byteOffset:H,byteStride:h,componentCount:D,type:E,count:t*D,normalized:e,totalVertices:t,kind:w.getKind()}}function Z(w){switch(w){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function K(w){switch(w){case A.e.PositionKind:case A.e.NormalKind:case A.e.TangentKind:case A.e.ColorKind:case A.e.MatricesIndicesKind:case A.e.MatricesIndicesExtraKind:case A.e.MatricesWeightsKind:case A.e.MatricesWeightsExtraKind:case A.e.UVKind:case A.e.UV2Kind:case A.e.UV3Kind:case A.e.UV4Kind:case A.e.UV5Kind:case A.e.UV6Kind:return!0}return!1}function F(w){switch(w){case e.e.TriangleFillMode:return 4;case e.e.TriangleStripDrawMode:return 5;case e.e.TriangleFanDrawMode:return 6;case e.e.PointListDrawMode:case e.e.PointFillMode:return 0;case e.e.LineLoopDrawMode:return 2;case e.e.LineListDrawMode:return 1;case e.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${w}`)}function v(w){const o=Math.sqrt(w.x*w.x+w.y*w.y+w.z*w.z);o>0&&(w.x/=o,w.y/=o,w.z/=o)}function mw(w){return w.x*=-1,w}function Y(w){if(w.x*w.x+w.y*w.y>.5){const o=Math.abs(w.x),H=Math.abs(w.y);if(o>H){const H=Math.sign(w.x);w.x=o,w.y*=-H,w.z*=-H,w.w*=H}else{const o=Math.sign(w.y);w.x*=-o,w.y=H,w.z*=o,w.w*=-o}}else{const o=Math.abs(w.z),H=Math.abs(w.w);if(o>H){const H=Math.sign(w.z);w.x*=-H,w.y*=H,w.z=o,w.w*=-H}else{const o=Math.sign(w.w);w.x*=o,w.y*=-o,w.z*=-o,w.w=H}}return w}function x(w){w.We(-w.z,w.w,w.x,-w.y)}function ww(w,o){const H=h.io.FromArrayToRef(o.translation||[0,0,0],0,h.TmpVectors.io[0]),E=h.Quaternion.FromArrayToRef(o.rotation||[0,0,0,1],0,h.TmpVectors.Quaternion[0]),e=h.Matrix.ComposeToRef(d,E,H,h.TmpVectors.Matrix[0]),D=h.io.FromArrayToRef(w.translation||[0,0,0],0,h.TmpVectors.io[2]),t=h.Quaternion.FromArrayToRef(w.rotation||[0,0,0,1],0,h.TmpVectors.Quaternion[1]),X=h.Matrix.ComposeToRef(d,t,D,h.TmpVectors.Matrix[1]);e.multiplyToRef(X,X),X.decompose(void 0,E,H),H.equalsWithEpsilon(R,G.c)?delete o.translation:o.translation=H.Ae(),E.equalsWithEpsilon(a,G.c)?delete o.rotation:o.rotation=E.Ae(),o.scale&&delete o.scale}function ow(w,o){if(!(o instanceof y.b))return!1;if(!(1===o.getChildren().length&&0===w.getChildren().length&&w.parent===o))return!1;const H=w.Ow(),h=w instanceof n.e&&!H.useRightHandedSystem?I:d;return!!o.Je.equalsWithEpsilon(h,G.c)||(u.d.Warn(`Cannot collapse node ${w.name} into parent node ${o.name} with modified scaling.`),!1)}function Hw(w){if(w instanceof Array){const o=new Float32Array(w);return new Uint8Array(o.buffer,o.byteOffset,o.byteLength)}return ArrayBuffer.isView(w)?new Uint8Array(w.buffer,w.byteOffset,w.byteLength):new Uint8Array(w)}function hw(w,o){for(const[H,h]of Object.entries(w)){const E=o[H];(Array.isArray(h)&&Array.isArray(E)&&Ew(h,E)||h===E)&&delete w[H]}return w}function Ew(w,o){return w.length===o.length&&w.every(((w,H)=>w===o[H]))}const ew=h.Matrix.Compose(new h.io(-1,1,1),h.Quaternion.Identity(),h.io.Zero());function Dw(w,o){if(!(w instanceof y.b))return!1;if(o){if(!w.getWorldMatrix().equalsWithEpsilon(h.Matrix.IdentityReadOnly,G.c))return!1}else{if(!w.getWorldMatrix().multiplyToRef(ew,h.TmpVectors.Matrix[0]).equalsWithEpsilon(h.Matrix.IdentityReadOnly,G.c))return!1}return!(w instanceof z.c&&w.re)}const tw=new Map([[Int8Array,(w,o,H)=>w.setInt8(o,H)],[Uint8Array,(w,o,H)=>w.setUint8(o,H)],[Uint8ClampedArray,(w,o,H)=>w.setUint8(o,H)],[Int16Array,(w,o,H)=>w.setInt16(o,H,!0)],[Uint16Array,(w,o,H)=>w.setUint16(o,H,!0)],[Int32Array,(w,o,H)=>w.setInt32(o,H,!0)],[Uint32Array,(w,o,H)=>w.setUint32(o,H,!0)],[Float32Array,(w,o,H)=>w.setFloat32(o,H,!0)],[Float64Array,(w,o,H)=>w.setFloat64(o,H,!0)]]);class Xw{writeTypedArray(w){this._checkGrowBuffer(w.byteLength);const o=tw.get(w.constructor);for(let H=0;H<w.length;H++)o(this._dataView,this._byteOffset,w[H]),this._byteOffset+=w.BYTES_PER_ELEMENT}constructor(w){this._data=new Uint8Array(w),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(w){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,w),this._byteOffset++}writeInt8(w){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,w),this._byteOffset++}writeInt16(w){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,w,!0),this._byteOffset+=2}writeUInt16(w){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,w,!0),this._byteOffset+=2}writeInt32(w){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,w,!0),this._byteOffset+=4}writeUInt32(w){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,w,!0),this._byteOffset+=4}writeFloat32(w){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,w,!0),this._byteOffset+=4}writeFloat64(w){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,w,!0),this._byteOffset+=8}_checkGrowBuffer(w){const o=this.byteOffset+w;if(o>this._data.byteLength){const w=new Uint8Array(2*o);w.set(this._data),this._data=w,this._dataView=new DataView(this._data.buffer)}}}function Lw(w){return w%4===0?4:w%2===0?2:1}class Aw{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(w){let o=0;this._bufferViewToData.forEach((w=>{o+=w.byteLength}));const H=new Xw(o),h=Array.from(this._bufferViewToData.keys()).sort(((w,o)=>Lw(o.byteLength)-Lw(w.byteLength)));for(const E of h){E.byteOffset=H.byteOffset,w.push(E);const o=w.length-1,h=this.getPropertiesWithBufferView(E);for(const w of h)w.bufferView=o;H.writeTypedArray(this._bufferViewToData.get(E)),this._bufferViewToData.delete(E)}return H.getOutputData()}createBufferView(w,o){const H={buffer:0,byteOffset:void 0,byteLength:w.byteLength,byteStride:o};return this._bufferViewToData.set(H,w),H}createAccessor(w,o,H,h,E,e,D){this._verifyBufferView(w);const t={bufferView:void 0,componentType:H,count:h,type:o,min:null===e||void 0===e?void 0:e.min,max:null===e||void 0===e?void 0:e.max,normalized:D,byteOffset:E};return this.setBufferView(t,w),this._accessorToBufferView.set(t,w),t}setBufferView(w,o){this._verifyBufferView(o);this.getPropertiesWithBufferView(o).push(w)}removeBufferView(w){const o=this.getPropertiesWithBufferView(w);for(const H of o)void 0!==H.bufferView&&delete H.bufferView;this._bufferViewToData.delete(w),this._bufferViewToProperties.delete(w),this._accessorToBufferView.forEach(((o,H)=>{o===w&&(void 0!==H.byteOffset&&delete H.byteOffset,this._accessorToBufferView.delete(H))}))}getBufferView(w){const o=this._accessorToBufferView.get(w);return this._verifyBufferView(o),o}getPropertiesWithBufferView(w){return this._verifyBufferView(w),this._bufferViewToProperties.set(w,this._bufferViewToProperties.get(w)??[]),this._bufferViewToProperties.get(w)}getData(w){return this._verifyBufferView(w),this._bufferViewToData.get(w)}_verifyBufferView(w){if(void 0===w||!this._bufferViewToData.has(w))throw new Error(`BufferView ${w} not found in BufferManager.`)}}var yw,zw=H(12167),Cw=H(12183),Qw=H(12201),Mw=H(12081),iw=H(12247),sw=H(12256),Vw=H(12165),rw=H(12262);!function(w){w[w.INTANGENT=0]="INTANGENT",w[w.OUTTANGENT=1]="OUTTANGENT"}(yw||(yw={}));class kw{static _IsTransformable(w){return w&&(w instanceof y.b||w instanceof zw.e||w instanceof rw.b)}static _CreateNodeAnimation(w,o,H,h,e){if(this._IsTransformable(w)){const D=[],t=[],X=o.getKeys(),L=kw._CalculateMinMaxKeyFrames(X),A=kw._DeduceInterpolation(X,H,h),y=A.interpolationType,z=A.shouldBakeAnimation;if(z?kw._CreateBakedAnimation(w,o,H,L.min,L.max,o.framePerSecond,e,D,t,L,h):"LINEAR"===y||"STEP"===y?kw._CreateLinearOrStepAnimation(w,o,H,D,t,h):"CUBICSPLINE"===y?kw._CreateCubicSplineAnimation(w,o,H,D,t,h):kw._CreateBakedAnimation(w,o,H,L.min,L.max,o.framePerSecond,e,D,t,L,h),D.length&&t.length){return{inputs:D,outputs:t,samplerInterpolation:y,inputsMin:z?L.min:E.Tools.FloatRound(L.min/o.framePerSecond),inputsMax:z?L.max:E.Tools.FloatRound(L.max/o.framePerSecond)}}}return null}static _DeduceAnimationInfo(w){let o=null,H="VEC3",h=!1;const e=w.targetProperty.split(".");switch(e[0]){case"Je":o="scale";break;case"position":o="translation";break;case"rotation":H="VEC4",o="rotation";break;case"rotationQuaternion":H="VEC4",h=!0,o="rotation";break;case"influence":H="SCALAR",o="weights";break;default:E.Tools.Error(`Unsupported animatable property ${e[0]}`)}return o?{animationChannelTargetPath:o,dataAccessorType:H,useQuaternion:h}:(E.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(w,o,H,h,E,e,D,t,X,L,A){let y;if(kw._IsTransformable(w)&&w.animations)for(const z of w.animations){if(A&&!A(z))continue;const E=kw._DeduceAnimationInfo(z);E&&(y={name:z.name,samplers:[],channels:[]},kw._AddAnimation(`${z.name}`,z.hasRunningRuntimeAnimations?o:y,w,z,E.dataAccessorType,E.animationChannelTargetPath,h,e,D,t,E.useQuaternion,X,L),y.samplers.length&&y.channels.length&&H.push(y))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(w,o,H,h,E,e,D,t,X,L,A){let y;if(w instanceof Vw.d){const E=w.morphTargetManager;if(E)for(let z=0;z<E.numTargets;++z){const C=E.getTarget(z);for(const Q of C.animations){if(A&&!A(Q))continue;const C=new iw.b(`${Q.name}`,"influence",Q.framePerSecond,Q.dataType,Q.loopMode,Q.enableBlending),M=[],i=Q.getKeys();for(let w=0;w<i.length;++w){const o=i[w];for(let w=0;w<E.numTargets;++w)w==z?M.push(o):M.push({frame:o.frame,value:0})}C.setKeys(M);const s=kw._DeduceAnimationInfo(C);s&&(y={name:C.name,samplers:[],channels:[]},kw._AddAnimation(Q.name,Q.hasRunningRuntimeAnimations?o:y,w,C,s.dataAccessorType,s.animationChannelTargetPath,h,e,D,t,s.useQuaternion,X,L,E.numTargets),y.samplers.length&&y.channels.length&&H.push(y))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(w,o,H,h,E,e,D,t,X){let L;if(w.animationGroups){const y=w.animationGroups;for(const z of y){const y=new Map,C=new Map,Q=new Set,M=z.to-z.from;L={name:z.name,channels:[],samplers:[]};for(let o=0;o<z.targetedAnimations.length;++o){const M=z.targetedAnimations[o],i=M.target,s=M.animation;if(X&&!X(s))continue;const V=t.has(i);if(this._IsTransformable(i)||1===i.length&&this._IsTransformable(i[0])){const w=kw._DeduceAnimationInfo(M.animation);if(w){const o=this._IsTransformable(i)?i:this._IsTransformable(i[0])?i[0]:null;o&&kw._AddAnimation(`${s.name}`,L,o,s,w.dataAccessorType,w.animationChannelTargetPath,H,h,E,e,w.useQuaternion,D,V)}}else if(i instanceof sw.e||1===i.length&&i[0]instanceof sw.e){if(kw._DeduceAnimationInfo(M.animation)){const o=i instanceof sw.e?i:i[0];if(o){const H=w.morphTargetManagers.find((w=>{for(let H=0;H<w.numTargets;++H)if(w.getTarget(H)===o)return!0;return!1}));if(H){const h=w.meshes.find((w=>w.morphTargetManager===H));var A;if(h)y.has(h)||y.set(h,new Map),null===(A=y.get(h))||void 0===A||A.set(o,s),Q.add(h),C.set(h,s)}}}}}Q.forEach((w=>{const o=w.morphTargetManager;let t=null;const X=[],A=C.get(w).getKeys(),Q=A.length;for(let H=0;H<Q;++H)for(let h=0;h<o.numTargets;++h){const E=o.getTarget(h),e=y.get(w);if(e){const o=e.get(E);o?(t||(t=new iw.b(`${z.name}_${w.name}_MorphWeightAnimation`,"influence",o.framePerSecond,iw.b.ANIMATIONTYPE_FLOAT,o.loopMode,o.enableBlending)),X.push(o.getKeys()[H])):X.push({frame:z.from+M/Q*H,value:E.influence,inTangent:A[0].inTangent?0:void 0,outTangent:A[0].outTangent?0:void 0})}}t.setKeys(X);const i=kw._DeduceAnimationInfo(t);i&&kw._AddAnimation(`${z.name}_${w.name}_MorphWeightAnimation`,L,w,t,i.dataAccessorType,i.animationChannelTargetPath,H,h,E,e,i.useQuaternion,D,!1,null===o||void 0===o?void 0:o.numTargets)})),L.channels.length&&L.samplers.length&&o.push(L)}}}static _AddAnimation(w,o,H,E,e,D,t,X,L,A,y,z,C,Q){const M=kw._CreateNodeAnimation(H,E,D,y,z);let i,s,V,r,k,P;if(M){if(Q){let w=0,o=0;const H=[];for(;M.inputs.length>0;)o=M.inputs.shift(),w%Q==0&&H.push(o),w++;M.inputs=H}const w=t.get(H),E=new Float32Array(M.inputs);i=X.createBufferView(E),s=X.createAccessor(i,"SCALAR",5126,M.inputs.length,void 0,{min:[M.inputsMin],max:[M.inputsMax]}),A.push(s),V=A.length-1;const L=new h.Quaternion,y=new h.io,z=new h.io,l=H instanceof zw.e,O=Z(e),T=new Float32Array(M.outputs.length*O);M.outputs.forEach((function(w,o){let H=w;switch(D){case"translation":C&&(h.io.FromArrayToRef(w,0,z),mw(z),z.toArray(H));break;case"rotation":4===w.length?h.Quaternion.FromArrayToRef(w,0,L):(H=new Array(4),h.io.FromArrayToRef(w,0,y),h.Quaternion.FromEulerVectorToRef(y,L)),C&&(Y(L),l&&x(L)),L.toArray(H)}T.set(H,o*O)})),i=X.createBufferView(T),s=X.createAccessor(i,e,5126,M.outputs.length),A.push(s),r=A.length-1,k={interpolation:M.samplerInterpolation,input:V,output:r},o.samplers.push(k),P={sampler:o.samplers.length-1,target:{node:w,path:D}},o.channels.push(P)}}static _CreateBakedAnimation(w,o,H,e,D,t,X,L,A,y,z){let C;const Q=h.Quaternion.Identity();let M,i=null,s=null,V=null,r=null,k=null,P=null;y.min=E.Tools.FloatRound(e/t);const l=o.getKeys();for(let h=0,O=l.length;h<O;++h){if(P=null,V=l[h],h+1<O)if(r=l[h+1],V.value.equals&&V.value.equals(r.value)||V.value===r.value){if(0!==h)continue;P=V.frame}else P=r.frame;else{if(k=l[h-1],V.value.equals&&V.value.equals(k.value)||V.value===k.value)continue;P=D}if(P)for(let h=V.frame;h<=P;h+=X){if(M=E.Tools.FloatRound(h/t),M===i)continue;i=M,s=M;const e={key:0,repeatCount:0,loopMode:o.loopMode};C=o._interpolate(h,e),kw._SetInterpolatedValue(w,C,M,o,H,Q,L,A,z)}}s&&(y.max=s)}static _ConvertFactorToVector3OrQuaternion(w,o,H,e,D){const t=kw._GetBasePositionRotationOrScale(o,e,D),X=H.targetProperty.split("."),L=X?X[1]:"",A=D?h.Quaternion.Po(t).normalize():h.io.Po(t);switch(L){case"x":case"y":case"z":A[L]=w;break;case"w":A.w=w;break;default:E.Tools.Error(`glTFAnimation: Unsupported component name "${L}"!`)}return A}static _SetInterpolatedValue(w,o,H,E,e,D,t,X,L){let A;t.push(H),"weights"!==e?(E.dataType===iw.b.ANIMATIONTYPE_FLOAT&&(o=this._ConvertFactorToVector3OrQuaternion(o,w,E,e,L)),"rotation"===e?(L?D=o:(A=o,h.Quaternion.RotationYawPitchRollToRef(A.y,A.x,A.z,D)),X.push(D.Ae())):(A=o,X.push(A.Ae()))):X.push([o])}static _CreateLinearOrStepAnimation(w,o,H,h,E,e){for(const D of o.getKeys())h.push(D.frame/o.framePerSecond),kw._AddKeyframeValue(D,o,E,H,w,e)}static _CreateCubicSplineAnimation(w,o,H,h,E,e){o.getKeys().forEach((function(D){h.push(D.frame/o.framePerSecond),kw._AddSplineTangent(yw.INTANGENT,E,H,"CUBICSPLINE",D,e),kw._AddKeyframeValue(D,o,E,H,w,e),kw._AddSplineTangent(yw.OUTTANGENT,E,H,"CUBICSPLINE",D,e)}))}static _GetBasePositionRotationOrScale(w,o,H){let E;if("rotation"===o)if(H){E=(w.rotationQuaternion??h.Quaternion.Identity()).Ae()}else{E=(w.rotation??h.io.Zero()).Ae()}else if("translation"===o){E=(w.position??h.io.Zero()).Ae()}else{E=(w.Je??h.io.One()).Ae()}return E}static _AddKeyframeValue(w,o,H,e,D,t){let X;const L=o.dataType;if(L===iw.b.ANIMATIONTYPE_VECTOR3){let o=w.value.Ae();if("rotation"===e){const w=h.io.Po(o);o=h.Quaternion.RotationYawPitchRoll(w.y,w.x,w.z).Ae()}H.push(o)}else if(L===iw.b.ANIMATIONTYPE_FLOAT){if("weights"===e)H.push([w.value]);else if(X=this._ConvertFactorToVector3OrQuaternion(w.value,D,o,e,t),X){if("rotation"===e){const w=t?X:h.Quaternion.RotationYawPitchRoll(X.y,X.x,X.z).normalize();H.push(w.Ae())}H.push(X.Ae())}}else L===iw.b.ANIMATIONTYPE_QUATERNION?H.push(w.value.normalize().Ae()):E.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(w,o,H){let h,E,e=!1;if("rotation"===o&&!H)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let D=0,t=w.length;D<t;++D)if(E=w[D],E.inTangent||E.outTangent)if(h){if("CUBICSPLINE"!==h){h="LINEAR",e=!0;break}}else h="CUBICSPLINE";else if(h){if("CUBICSPLINE"===h||E.interpolation&&1===E.interpolation&&"STEP"!==h){h="LINEAR",e=!0;break}}else h=E.interpolation&&1===E.interpolation?"STEP":"LINEAR";return h||(h="LINEAR"),{interpolationType:h,shouldBakeAnimation:e}}static _AddSplineTangent(w,o,H,E,e,D){let t;const X=w===yw.INTANGENT?e.inTangent:e.outTangent;if("CUBICSPLINE"===E){if("rotation"===H)if(X)if(D)t=X.Ae();else{const w=X;t=h.Quaternion.RotationYawPitchRoll(w.y,w.x,w.z).Ae()}else t=[0,0,0,0];else t="weights"===H?X?[X]:[0]:X?X.Ae():[0,0,0];o.push(t)}}static _CalculateMinMaxKeyFrames(w){let o=1/0,H=-1/0;return w.forEach((function(w){o=Math.min(o,w.frame),H=Math.max(H,w.frame)})),{min:o,max:H}}}function Pw(w,o,H,e,D,t){const X={attributes:{},influence:w.influence,name:w.name},L=o.re;if(!L)return E.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),X;const y=t?-1:1,z=h.io.Zero();let C=0,Q=0;if(w.hasPositions){const e=w.getPositions(),t=L.getVerticesData(A.e.PositionKind);if(t){const w=new Float32Array(t.length),o=[1/0,1/0,1/0],E=[-1/0,-1/0,-1/0];Q=t.length/3,C=0;for(let H=C;H<Q;++H){const D=h.io.Po(t,3*H);h.io.Po(e,3*H).subtractToRef(D,z),z.x*=y,o[0]=Math.min(o[0],z.x),E[0]=Math.max(E[0],z.x),o[1]=Math.min(o[1],z.y),E[1]=Math.max(E[1],z.y),o[2]=Math.min(o[2],z.z),E[2]=Math.max(E[2],z.z),w[3*H]=z.x,w[3*H+1]=z.y,w[3*H+2]=z.z}const L=H.createBufferView(w,12),A=H.createAccessor(L,"VEC3",5126,e.length/3,0,{min:o,max:E});D.push(A),X.attributes.POSITION=D.length-1}else E.Tools.Warn(`Morph target positions for mesh ${o.name} were not exported. Mesh does not have position vertex data`)}if(w.hasNormals){const e=w.getNormals(),t=L.getVerticesData(A.e.NormalKind);if(t){const w=new Float32Array(t.length);Q=t.length/3,C=0;for(let H=C;H<Q;++H){const o=h.io.Po(t,3*H).normalize();h.io.Po(e,3*H).normalize().subtractToRef(o,z),w[3*H]=z.x*y,w[3*H+1]=z.y,w[3*H+2]=z.z}const o=H.createBufferView(w,12),E=H.createAccessor(o,"VEC3",5126,e.length/3,0);D.push(E),X.attributes.NORMAL=D.length-1}else E.Tools.Warn(`Morph target normals for mesh ${o.name} were not exported. Mesh does not have normals vertex data`)}if(w.hasTangents){const e=w.getTangents(),t=L.getVerticesData(A.e.TangentKind);if(t){Q=t.length/4;const w=new Float32Array(3*Q);C=0;for(let H=C;H<Q;++H){const o=h.io.Po(t,4*H);v(o);const E=h.io.Po(e,3*H);v(E),E.subtractToRef(o,z),w[3*H]=z.x*y,w[3*H+1]=z.y,w[3*H+2]=z.z}const o=H.createBufferView(w,12),E=H.createAccessor(o,"VEC3",5126,Q,0);D.push(E),X.attributes.TANGENT=D.length-1}else E.Tools.Warn(`Morph target tangents for mesh ${o.name} were not exported. Mesh does not have tangents vertex data`)}if(w.hasColors){const e=w.getColors(),t=L.getVerticesData(A.e.ColorKind),y=L.getVertexBuffer(A.e.ColorKind);if(t&&y){const w=y.getSize();Q=t.length/w;const o=new Float32Array(Q*w);C=0;for(let H=C;H<Q;++H)if(3===w){const E=h.io.Po(t,H*w);h.io.Po(e,H*w).subtractToRef(E,z),o[3*H]=z.x,o[3*H+1]=z.y,o[3*H+2]=z.z}else if(4===w){const E=new h.Vector4,D=h.Vector4.Po(t,H*w);h.Vector4.Po(e,H*w).subtractToRef(D,E),o[4*H]=E.x,o[4*H+1]=E.y,o[4*H+2]=E.z,o[4*H+3]=E.w}else E.Tools.Warn(`Unsupported number of components for color attribute: ${w}`);const L=H.createBufferView(o,4*w),A=H.createAccessor(L,3===w?"VEC3":"VEC4",5126,Q,0);D.push(A),X.attributes.COLOR_0=D.length-1}else E.Tools.Warn(`Morph target colors for mesh ${o.name} were not exported. Mesh does not have colors vertex data`)}return X}var lw=H(12266),Ow=H(12106),Tw=H(12091),Sw=H(11666);class cw{}cw.DEFAULT_COLOR=i.ko.White(),cw.DEFAULT_WIDTH_ATTENUATED=1,cw.DEFAULT_WIDTH=.1;var Ww=H(11923),Bw=H(12271);class Jw{static ConvertPoints(w,o){if(w.length&&Array.isArray(w)&&"number"===typeof w[0])return[w];if(w.length&&Array.isArray(w[0])&&"number"===typeof w[0][0])return w;if(w.length&&!Array.isArray(w[0])&&w[0]instanceof h.io){const o=[];for(let H=0;H<w.length;H++){const h=w[H];o.push(h.x,h.y,h.z)}return[o]}if(w.length>0&&Array.isArray(w[0])&&w[0].length>0&&w[0][0]instanceof h.io){const o=[],H=w;for(const w of H)o.push(w.flatMap((w=>[w.x,w.y,w.z])));return o}if(w instanceof Float32Array){if(null!==o&&void 0!==o&&o.floatArrayStride){const H=[],h=3*o.floatArrayStride;for(let o=0;o<w.length;o+=h){const E=new Array(h);for(let H=0;H<h;H++)E[H]=w[o+H];H.push(E)}return H}return[Array.from(w)]}if(w.length&&w[0]instanceof Float32Array){const o=[];for(const H of w)o.push(Array.from(H));return o}return[]}static OmitZeroLengthPredicate(w,o,H){const h=[];return o.so(w).lengthSquared()>0&&h.push([w,o]),H.so(o).lengthSquared()>0&&h.push([o,H]),w.so(H).lengthSquared()>0&&h.push([H,w]),0===h.length?null:h}static OmitDuplicatesPredicate(w,o,H,h){const E=[];return Jw._SearchInPoints(w,o,h)||E.push([w,o]),Jw._SearchInPoints(o,H,h)||E.push([o,H]),Jw._SearchInPoints(H,w,h)||E.push([H,w]),0===E.length?null:E}static _SearchInPoints(w,o,H){for(const D of H)for(let H=0;H<D.length;H++){var h,E,e;if(null!==(h=D[H])&&void 0!==h&&h.equals(w))if(null!==(E=D[H+1])&&void 0!==E&&E.equals(o)||null!==(e=D[H-1])&&void 0!==e&&e.equals(o))return!0}return!1}static MeshesToLines(w,o){const H=[];for(let E=0;E<w.length;E++){const e=w[E],D=e.getVerticesData(A.e.PositionKind),t=e.ke();if(D&&t)for(let w=0,X=0;w<t.length;w++){const L=3*t[X++],A=3*t[X++],y=3*t[X++],z=new h.io(D[L],D[L+1],D[L+2]),C=new h.io(D[A],D[A+1],D[A+2]),Q=new h.io(D[y],D[y+1],D[y+2]);if(o){const h=o(z,C,Q,H,w,L,e,E,D,t);if(h)for(const w of h)H.push(w)}else H.push([z,C],[C,Q],[Q,z])}}return H}static ToVector3Array(w){if(Array.isArray(w[0])){const o=[],H=w;for(const w of H){const H=[];for(let o=0;o<w.length;o+=3)H.push(new h.io(w[o],w[o+1],w[o+2]));o.push(H)}return o}const o=w,H=[];for(let E=0;E<o.length;E+=3)H.push(new h.io(o[E],o[E+1],o[E+2]));return H}static ToNumberArray(w){return w.flatMap((w=>[w.x,w.y,w.z]))}static GetPointsCountInfo(w){const o=new Array(w.length);let H=0;for(let h=w.length;h--;)o[h]=w[h].length/3,H+=o[h];return{total:H,counts:o}}static GetLineLength(w){if(0===w.length)return 0;let o;o="number"===typeof w[0]?Jw.ToVector3Array(w):w;const H=h.TmpVectors.io[0];let E=0;for(let h=0;h<o.length-1;h++){const w=o[h];E+=o[h+1].subtractToRef(w,H).length()}return E}static GetLineLengthArray(w){const o=new Float32Array(w.length/3);let H=0;for(let h=0,E=w.length/3-1;h<E;h++){let E=w[3*h+0],e=w[3*h+1],D=w[3*h+2];E-=w[3*h+3],e-=w[3*h+4],D-=w[3*h+5];H+=Math.sqrt(E*E+e*e+D*D),o[h+1]=H}return o}static SegmentizeSegmentByCount(w,o,H){const E=[],e=o.so(w),D=h.TmpVectors.io[0];D.Ge(H);const t=h.TmpVectors.io[1];e.divideToRef(D,t);let X=w.clone();E.push(X);for(let h=0;h<H;h++)X=X.clone(),E.push(X.addInPlace(t));return E}static SegmentizeLineBySegmentLength(w,o){const H=w[0]instanceof h.io?Jw.GetLineSegments(w):"number"===typeof w[0]?Jw.GetLineSegments(Jw.ToVector3Array(w)):w,E=[];for(const h of H)if(h.length>o){const w=Jw.SegmentizeSegmentByCount(h.point1,h.point2,Math.ceil(h.length/o));for(const o of w)E.push(o)}else E.push(h.point1),E.push(h.point2);return E}static SegmentizeLineBySegmentCount(w,o){const H="number"===typeof w[0]?Jw.ToVector3Array(w):w,h=Jw.GetLineLength(H)/o;return Jw.SegmentizeLineBySegmentLength(H,h)}static GetLineSegments(w){const o=[];for(let H=0;H<w.length-1;H++){const h=w[H],E=w[H+1],e=E.so(h).length();o.push({point1:h,point2:E,length:e})}return o}static GetMinMaxSegmentLength(w){const o=Jw.GetLineSegments(w).sort((w=>w.length));return{min:o[0].length,max:o[o.length-1].length}}static GetPositionOnLineByVisibility(w,o,H){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const e=o*H;let D=0,t=0;const X=w.length;for(let h=0;h<X;h++){if(e<=D+w[h].length){t=h;break}D+=w[h].length}const L=(e-D)/w[t].length;return w[t].point2.subtractToRef(w[t].point1,h.TmpVectors.io[0]),h.TmpVectors.io[1]=h.TmpVectors.io[0].multiplyByFloats(L,L,L),E||h.TmpVectors.io[1].addInPlace(w[t].point1),h.TmpVectors.io[1].clone()}static GetCircleLinePoints(w,o){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:w,e=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/o;const D=[];for(let t=0;t<=o;t++)D.push(new h.io(Math.cos(t*e)*w,Math.sin(t*e)*E,H));return D}static GetBezierLinePoints(w,o,H,h){return Ww.e.CreateQuadraticBezier(w,o,H,h).getPoints().flatMap((w=>[w.x,w.y,w.z]))}static GetArrowCap(w,o,H,h,E){let e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,D=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[w.clone(),w.add(o.multiplyByFloats(H,H,H))],widths:[h,E,e,D]}}static GetPointsFromText(w,o,H,h){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,e=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const D=[],t=(0,Bw.c)(w,o,H,h);for(const X of t){for(const w of X.paths){const o=[],H=w.getPoints();for(const w of H)o.push(w.x,w.y,E);D.push(o)}if(e)for(const w of X.holes){const o=[],H=w.getPoints();for(const w of H)o.push(w.x,w.y,E);D.push(o)}}return D}static Color3toRGBAUint8(w){const o=new Uint8Array(4*w.length);for(let H=0,h=0;H<w.length;H++)o[h++]=255*w[H].r,o[h++]=255*w[H].g,o[h++]=255*w[H].b,o[h++]=255;return o}static CreateColorsTexture(w,o,H,h){const E=h.getEngine().getCaps().maxTextureSize??1,e=o.length>E?E:o.length,D=Math.ceil(o.length/E);D>1&&(o=[...o,...Array(e*D-o.length).fill(o[0])]);const t=Jw.Color3toRGBAUint8(o),X=new l.c(t,e,D,Q.e.TEXTUREFORMAT_RGBA,h,!1,!0,H);return X.name=w,X}static PrepareEmptyColorsTexture(w){if(!cw.EmptyColorsTexture){const o=new Uint8Array(4);cw.EmptyColorsTexture=new l.c(o,1,1,Q.e.TEXTUREFORMAT_RGBA,w,!1,!1,l.c.NEAREST_NEAREST),cw.EmptyColorsTexture.name="grlEmptyColorsTexture"}return cw.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var w;null===(w=cw.EmptyColorsTexture)||void 0===w||w.dispose(),cw.EmptyColorsTexture=null}static BooleanToNumber(w){return w?1:0}}class gw extends Tw.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class bw extends Ow.c{isCompatible(w){return!0}constructor(w,o,H){var E;H=H||{color:cw.DEFAULT_COLOR};const e=new gw;e.GREASED_LINE_HAS_COLOR=!!H.color&&!H.useColors,e.GREASED_LINE_SIZE_ATTENUATION=H.sizeAttenuation??!1,e.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===H.colorDistributionType,e.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(o??w.Ow()).useRightHandedSystem,e.GREASED_LINE_CAMERA_FACING=H.cameraFacing??!0,super(w,bw.GREASED_LINE_MATERIAL_NAME,200,e,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(E=H)||void 0===E?void 0:E.forceGLSL)||bw.ForceGLSL,this._scene=o??w.Ow(),this._engine=this._scene.getEngine(),this._cameraFacing=H.cameraFacing??!0,this.visibility=H.visibility??1,this.useDash=H.useDash??!1,this.dashRatio=H.dashRatio??.5,this.dashOffset=H.dashOffset??0,this.width=H.width?H.width:H.sizeAttenuation?cw.DEFAULT_WIDTH_ATTENUATED:cw.DEFAULT_WIDTH,this._sizeAttenuation=H.sizeAttenuation??!1,this.colorMode=H.colorMode??0,this._color=H.color??null,this.useColors=H.useColors??!1,this._colorsDistributionType=H.colorDistributionType??0,this.colorsSampling=H.colorsSampling??l.c.NEAREST_NEAREST,this._colors=H.Ww??null,this.dashCount=H.dashCount??1,this.resolution=H.resolution??new h.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),H.colorsTexture?this.colorsTexture=H.colorsTexture:this._colors?this.colorsTexture=Jw.CreateColorsTexture(`${w.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??cw.DEFAULT_COLOR,Jw.PrepareEmptyColorsTexture(this._scene)),this._engine.me.add((()=>{Jw.DisposeEmptyColorsTexture()}))}getAttributes(w){w.push("grl_offsets"),w.push("grl_widths"),w.push("grl_colorPointers"),w.push("grl_counters"),this._cameraFacing?(w.push("grl_previousAndSide"),w.push("grl_nextAndCounters")):w.push("grl_slopes")}getSamplers(w){w.push("grl_colors")}getActiveTextures(w){this.colorsTexture&&w.push(this.colorsTexture)}getUniforms(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const o=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&o.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===w&&o.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:o,vertex:this._cameraFacing&&this._isGLSL(w)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(w)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(w){if(this._cameraFacing){w.ie("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||w.ie("viewProjection",this._scene.getTransformMatrix());const o=h.TmpVectors.Vector4[0];o.x=this._aspect,o.y=this._resolution.x,o.z=this._resolution.y,o.w=this.width,w.updateVector4("grl_aspect_resolution_lineWidth",o)}const o=h.TmpVectors.Vector4[0];o.x=Jw.BooleanToNumber(this.useDash),o.y=this._dashArray,o.z=this.dashOffset,o.w=this.dashRatio,w.updateVector4("grl_dashOptions",o);const H=h.TmpVectors.Vector4[1];H.x=this.colorMode,H.y=this.visibility,H.z=this.colorsTexture?this.colorsTexture.getSize().width:0,H.w=Jw.BooleanToNumber(this.useColors),w.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",H),this._color&&w.updateColor3("grl_singleColor",this._color);const E=this.colorsTexture??cw.EmptyColorsTexture;w.setTexture("grl_colors",E),w.updateFloat2("grl_textureSize",(null===E||void 0===E?void 0:E.getSize().width)??1,(null===E||void 0===E?void 0:E.getSize().height)??1)}prepareDefines(w,o,H){w.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,w.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,w.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,w.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=o.useRightHandedSystem,w.GREASED_LINE_CAMERA_FACING=this._cameraFacing,w.GREASED_LINE_USE_OFFSETS=!!H.offsets}getClassName(){return bw.GREASED_LINE_MATERIAL_NAME}getCustomCode(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(o)?function(w,o){if("vertex"===w){const w={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return o&&(w["!gl_Position\\=viewProjection\\*worldPos;"]="//"),w}return"fragment"===w?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(w,this._cameraFacing):function(w,o){if("vertex"===w){const w={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return o&&(w["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),w}return"fragment"===w?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(w,this._cameraFacing)}dispose(){var w;null===(w=this.colorsTexture)||void 0===w||w.dispose(),super.dispose()}get Ww(){return this._colors}set Ww(w){this.setColors(w)}setColors(w){var o;let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(o=this._colors)||void 0===o?void 0:o.length)??0;var e;if(this._colors=w,null!==w&&0!==w.length){if(!H||h)if(this.colorsTexture&&E===w.length&&!h){const o=Jw.Color3toRGBAUint8(w);this.colorsTexture.update(o)}else{var D;null===(D=this.colorsTexture)||void 0===D||D.dispose(),this.colorsTexture=Jw.CreateColorsTexture(`${this._material.name}-colors-texture`,w,this.colorsSampling,this._scene)}}else null===(e=this.colorsTexture)||void 0===e||e.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(w){this._dashCount=w,this._dashArray=1/w}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(w){this._sizeAttenuation=w,this.markAllDefinesAsDirty()}get color(){return this._color}set color(w){this.setColor(w)}setColor(w){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==w||null!==this._color&&null===w?(this._color=w,o||this.markAllDefinesAsDirty()):this._color=w}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(w){this._colorsDistributionType=w,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(w){this._aspect=w.x/w.y,this._resolution=w}serialize(){const w=super.serialize(),o={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(o.Ww=this._colors),this._color&&(o.color=this._color),w.greasedLineMaterialOptions=o,w}parse(w,o,H){var h;super.parse(w,o,H);const E=w.greasedLineMaterialOptions;null===(h=this.colorsTexture)||void 0===h||h.dispose(),E.color&&this.setColor(E.color,!0),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.Ww&&(this.Ww=E.Ww),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),this.Ww?this.colorsTexture=Jw.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Ww,this.colorsSampling,o):Jw.PrepareEmptyColorsTexture(o),this.markAllDefinesAsDirty()}copyTo(w){var o;const H=w;null===(o=H.colorsTexture)||void 0===o||o.dispose(),this._colors&&(H.colorsTexture=Jw.CreateColorsTexture(`${H._material.name}-colors-texture`,this._colors,H.colorsSampling,this._scene)),H.setColor(this.color,!0),H.colorsDistributionType=this.colorsDistributionType,H.colorsSampling=this.colorsSampling,H.colorMode=this.colorMode,H.useColors=this.useColors,H.visibility=this.visibility,H.useDash=this.useDash,H.dashCount=this.dashCount,H.dashRatio=this.dashRatio,H.dashOffset=this.dashOffset,H.width=this.width,H.sizeAttenuation=this.sizeAttenuation,H.resolution=this.resolution,H.markAllDefinesAsDirty()}_isGLSL(w){return 0===w||this._forceGLSL}}bw.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",bw.ForceGLSL=!1,(0,Sw.g)(`BABYLON.${bw.GREASED_LINE_MATERIAL_NAME}`,bw);var pw=H(12142),fw=H(11556),Nw=H(11951),jw=H(11648);class qw extends Nw.ShaderMaterial{constructor(w,o,E){const e=o.getEngine(),D=e.isWebGPU&&!(E.forceGLSL||qw.ForceGLSL),t=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];o.useRightHandedSystem&&t.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const X=["position","grl_widths","grl_offsets","grl_colorPointers"];E.cameraFacing?(t.push("GREASED_LINE_CAMERA_FACING"),X.push("grl_previousAndSide","grl_nextAndCounters")):(X.push("grl_slopes"),X.push("grl_counters"));const L=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(D||L.push("world","viewProjection","view","projection"),super(w,o,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:D?["Scene","Mesh"]:void 0,attributes:X,uniforms:L,samplers:D?[]:["grlColors"],defines:t,extraInitializationsAsync:async()=>{D?await Promise.all([H.e(66).then(H.bind(H,14955)),H.e(75).then(H.bind(H,14964))]):await Promise.all([H.e(69).then(H.bind(H,14967)),H.e(76).then(H.bind(H,14975))])},shaderLanguage:D?1:0}),this._color=i.ko.White(),this._colorsDistributionType=0,this._colorsTexture=null,E=E||{color:cw.DEFAULT_COLOR},this.visibility=E.visibility??1,this.useDash=E.useDash??!1,this.dashRatio=E.dashRatio??.5,this.dashOffset=E.dashOffset??0,this.dashCount=E.dashCount??1,this.width=E.width?E.width:E.sizeAttenuation&&E.cameraFacing?cw.DEFAULT_WIDTH_ATTENUATED:cw.DEFAULT_WIDTH,this.sizeAttenuation=E.sizeAttenuation??!1,this.color=E.color??i.ko.White(),this.useColors=E.useColors??!1,this.colorsDistributionType=E.colorDistributionType??0,this.colorsSampling=E.colorsSampling??l.c.NEAREST_NEAREST,this.colorMode=E.colorMode??0,this._colors=E.Ww??null,this._cameraFacing=E.cameraFacing??!0,this.resolution=E.resolution??new h.Vector2(e.getRenderWidth(),e.getRenderHeight()),E.colorsTexture?this.colorsTexture=E.colorsTexture:this._colors?this.colorsTexture=Jw.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,o):(this._color=this._color??cw.DEFAULT_COLOR,this.colorsTexture=Jw.PrepareEmptyColorsTexture(o)),D){const w=new jw.e;w.setParameters(),w.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",w)}e.me.add((()=>{Jw.DisposeEmptyColorsTexture()}))}dispose(){var w;null===(w=this._colorsTexture)||void 0===w||w.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new h.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Ww(){return this._colors}set Ww(w){this.setColors(w)}setColors(w){var o;let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(o=this._colors)||void 0===o?void 0:o.length)??0;var e;if(this._colors=w,null!==w&&0!==w.length){if(!H||h)if(this._colorsTexture&&E===w.length&&!h){const o=Jw.Color3toRGBAUint8(w);this._colorsTexture.update(o)}else{var D;null===(D=this._colorsTexture)||void 0===D||D.dispose(),this.colorsTexture=Jw.CreateColorsTexture(`${this.name}-colors-texture`,w,this.colorsSampling,this.Ow())}}else null===(e=this._colorsTexture)||void 0===e||e.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(w){this._colorsTexture=w,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(w){this._width=w,this.setFloat("grlWidth",w)}get useColors(){return this._useColors}set useColors(w){this._useColors=w,this.setFloat("grlUseColors",Jw.BooleanToNumber(w))}get colorsSampling(){return this._colorsSampling}set colorsSampling(w){this._colorsSampling=w}get visibility(){return this._visibility}set visibility(w){this._visibility=w,this.setFloat("grlVisibility",w)}get useDash(){return this._useDash}set useDash(w){this._useDash=w,this.setFloat("grlUseDash",Jw.BooleanToNumber(w))}get dashOffset(){return this._dashOffset}set dashOffset(w){this._dashOffset=w,this.setFloat("grlDashOffset",w)}get dashRatio(){return this._dashRatio}set dashRatio(w){this._dashRatio=w,this.setFloat("grlDashRatio",w)}get dashCount(){return this._dashCount}set dashCount(w){this._dashCount=w,this._dashArray=1/w,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(w){this._sizeAttenuation=w,this.setFloat("grlSizeAttenuation",Jw.BooleanToNumber(w))}get color(){return this._color}set color(w){this.setColor(w)}setColor(w){w=w??cw.DEFAULT_COLOR,this._color=w,this.setColor3("grlColor",w)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(w){this._colorsDistributionType=w,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(w){this._colorMode=w,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(w){this._resolution=w,this.setVector2("grlResolution",w),this.setFloat("grlAspect",w.x/w.y)}serialize(){const w=super.serialize(),o={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(o.Ww=this._colors),w.greasedLineMaterialOptions=o,w}parse(w,o,H){var h;const E=w.greasedLineMaterialOptions;null===(h=this._colorsTexture)||void 0===h||h.dispose(),E.color&&(this.color=E.color),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),E.Ww?this.colorsTexture=Jw.CreateColorsTexture(`${this.name}-colors-texture`,E.Ww,this.colorsSampling,this.Ow()):this.colorsTexture=Jw.PrepareEmptyColorsTexture(o),this._cameraFacing=E.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var uw,nw,Gw;qw.ForceGLSL=!1,function(w){w[w.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",w[w.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(uw||(uw={})),function(w){w[w.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",w[w.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",w[w.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(nw||(nw={})),function(w){w[w.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",w[w.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",w[w.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",w[w.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",w[w.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Gw||(Gw={}));class Rw extends Vw.d{constructor(w,o,H){super(w,o,null,null,!1,!1),this.name=w,this._options=H,this._lazy=!1,this._updatable=!1,this._engine=o.getEngine(),this._lazy=H.lazy??!1,this._updatable=H.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=H.colorPointers??[],this._widths=H.widths??new Array(H.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(w){let o=0;for(const h of this._points)o+=h.length;const H=o/3*2-this._widths.length;for(let h=0;h<H;h++)this._widths.push(w)}updateLazy(){var w,o;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(w=this._options.ribbonOptions)||void 0===w?void 0:w.smoothShading),!this.bw&&this.refreshBoundingInfo(),null===(o=this.greasedLineMaterial)||void 0===o||o.updateLazy()}addPoints(w,o){for(const H of w)this._points.push(H);this._lazy||this.setPoints(this._points,o)}dispose(w){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(w,o)}isLazy(){return this._lazy}get Bw(){return this._uvs}set Bw(w){this._uvs=w instanceof Float32Array?w:new Float32Array(w),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(w){this.material instanceof qw&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===w||void 0===w?void 0:w.length)>0),this._offsets=w,this._offsetsBuffer?this._offsetsBuffer.update(w):this._createOffsetsBuffer(w)}get widths(){return this._widths}set widths(w){this._widths=w,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(w)}get colorPointers(){return this._colorPointers}set colorPointers(w){this._colorPointers=w,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(w)}get greasedLineMaterial(){var w,o;if(this.material&&this.material instanceof qw)return this.material;const H=null===(w=this.material)||void 0===w||null===(o=w.pluginManager)||void 0===o?void 0:o.getPlugin(bw.GREASED_LINE_MATERIAL_NAME);return H||void 0}get points(){const w=[];return fw.d.DeepCopy(this._points,w),w}setPoints(w,o){this._points=Jw.ConvertPoints(w,(null===o||void 0===o?void 0:o.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==o&&void 0!==o&&o.colorPointers||this._updateColorPointers(),this._setPoints(this._points,o)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Bw:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(w){super.serialize(w),w.type=this.getClassName(),w.lineOptions=this._createLineOptions()}_createVertexBuffers(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const o=new pw.b;return o.Sw=this._vertexPositions,o.indices=this._indices,o.Bw=this._uvs,w&&(o.cw=[],pw.b.ComputeNormals(this._vertexPositions,this._indices,o.cw)),o.gw(this,this._options.updatable),o}_createOffsetsBuffer(w){const o=this._scene.getEngine(),H=new A.d(o,w,this._updatable,3);this.setVerticesBuffer(H.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=H}}class aw{constructor(w,o){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=w,this.wasAddedByNoopNode=o}getIndicesAccessor(w,o,H,h,E){var e,D,t,X;return null===(e=this._indicesAccessorMap.get(w))||void 0===e||null===(D=e.get(o))||void 0===D||null===(t=D.get(H))||void 0===t||null===(X=t.get(h))||void 0===X?void 0:X.get(E)}setIndicesAccessor(w,o,H,h,E,e){let D=this._indicesAccessorMap.get(w);D||(D=new Map,this._indicesAccessorMap.set(w,D));let t=D.get(o);t||(t=new Map,D.set(o,t));let X=t.get(H);X||(X=new Map,t.set(H,X));let L=X.get(h);L||(L=new Map,X.set(h,L)),L.set(E,e)}pushExportedNode(w){this._exportedNodes.has(w)||this._exportedNodes.add(w)}getNodesSet(){return this._exportedNodes}getVertexBufferView(w){return this._vertexBufferViewMap.get(w)}setVertexBufferView(w,o){this._vertexBufferViewMap.set(w,o)}setRemappedBufferView(w,o,H){this._remappedBufferView.set(w,new Map),this._remappedBufferView.get(w).set(o,H)}getRemappedBufferView(w,o){var H;return null===(H=this._remappedBufferView.get(w))||void 0===H?void 0:H.get(o)}getVertexAccessor(w,o,H){var h,E;return null===(h=this._vertexAccessorMap.get(w))||void 0===h||null===(E=h.get(o))||void 0===E?void 0:E.get(H)}setVertexAccessor(w,o,H,h){let E=this._vertexAccessorMap.get(w);E||(E=new Map,this._vertexAccessorMap.set(w,E));let e=E.get(o);e||(e=new Map,E.set(o,e)),e.set(H,h)}hasVertexColorAlpha(w){return this._vertexMapColorAlpha.get(w)||!1}setHasVertexColorAlpha(w,o){return this._vertexMapColorAlpha.set(w,o)}getMesh(w){return this._meshMap.get(w)}setMesh(w,o){this._meshMap.set(w,o)}bindMorphDataToMesh(w,o){const H=this._meshMorphTargetMap.get(w)||[];this._meshMorphTargetMap.set(w,H),-1===H.indexOf(o)&&H.push(o)}getMorphTargetsFromMesh(w){return this._meshMorphTargetMap.get(w)}}class dw{_ApplyExtension(w,o,H,h){if(H>=o.length)return Promise.resolve(w);const E=h(o[H],w);return E?E.then((async w=>w?await this._ApplyExtension(w,o,H+1,h):null)):this._ApplyExtension(w,o,H+1,h)}_ApplyExtensions(w,o){const H=[];for(const h of dw._ExtensionNames)H.push(this._extensions[h]);return this._ApplyExtension(w,H,0,o)}_extensionsPreExportTextureAsync(w,o,H){return this._ApplyExtensions(o,((o,h)=>o.preExportTextureAsync&&o.preExportTextureAsync(w,h,H)))}_extensionsPostExportNodeAsync(w,o,H,h,E){return this._ApplyExtensions(o,((o,e)=>o.postExportNodeAsync&&o.postExportNodeAsync(w,e,H,h,E,this._bufferManager)))}_extensionsPostExportMaterialAsync(w,o,H){return this._ApplyExtensions(o,((o,h)=>o.postExportMaterialAsync&&o.postExportMaterialAsync(w,h,H)))}_extensionsPostExportMaterialAdditionalTextures(w,o,H){const h=[];for(const E of dw._ExtensionNames){const e=this._extensions[E];e.postExportMaterialAdditionalTextures&&h.push(...e.postExportMaterialAdditionalTextures(w,o,H))}return h}_extensionsPostExportTextures(w,o,H){for(const h of dw._ExtensionNames){const E=this._extensions[h];E.postExportTexture&&E.postExportTexture(w,o,H)}}_extensionsPostExportMeshPrimitive(w){for(const o of dw._ExtensionNames){const H=this._extensions[o];H.postExportMeshPrimitive&&H.postExportMeshPrimitive(w,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const w of dw._ExtensionNames){const o=this._extensions[w];o.preGenerateBinaryAsync&&await o.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(w){for(const o of dw._ExtensionNames){const H=this._extensions[o];H.enabled&&w(H)}}_extensionsOnExporting(){this._forEachExtensions((w=>{var o,H,h;w.wasUsed&&((o=this._glTF).extensionsUsed||(o.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(w.name)&&this._glTF.extensionsUsed.push(w.name),w.required&&((H=this._glTF).extensionsRequired||(H.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(w.name)&&this._glTF.extensionsRequired.push(w.name)),(h=this._glTF).extensions||(h.extensions={}),w.onExporting&&w.onExporting())}))}_loadExtensions(){for(const w of dw._ExtensionNames){const o=dw._ExtensionFactories[w](this);this._extensions[w]=o}}constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:M.e.LastCreatedScene,o=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${Q.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new j(this),this._extensions={},this._bufferManager=new Aw,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!w)throw new Error("No scene available to export");this._babylonScene=w,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:w=>{var o;return null===w||void 0===w||null===(o=w.he)||void 0===o?void 0:o.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...o},this._loadExtensions()}dispose(){for(const w in this._extensions){this._extensions[w].dispose()}}get options(){return this._options}static RegisterExtension(w,o){dw.UnregisterExtension(w)&&E.Tools.Warn(`Extension with the name ${w} already exists`),dw._ExtensionFactories[w]=o,dw._ExtensionNames.push(w)}static UnregisterExtension(w){if(!dw._ExtensionFactories[w])return!1;delete dw._ExtensionFactories[w];const o=dw._ExtensionNames.indexOf(w);return-1!==o&&dw._ExtensionNames.splice(o,1),!0}_generateJSON(w,o,H){const h={byteLength:w};return h.byteLength&&(this._glTF.buffers=[h]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Vo=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(h.uri=o+".bin"),H?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(w){const o=await this._generateBinaryAsync();this._extensionsOnExporting();const H=this._generateJSON(o.byteLength,w,!0),h=new Blob([o],{type:"application/octet-stream"}),E=w+".gltf",e=w+".bin",D=new L;if(D.files[E]=H,D.files[e]=h,this._imageData)for(const t in this._imageData)D.files[t]=new Blob([this._imageData[t].data],{type:this._imageData[t].mimeType});return D}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(w){const o=w%4;return 0===o?o:4-o}async generateGLBAsync(w){this._shouldUseGlb=!0;const o=await this._generateBinaryAsync();this._extensionsOnExporting();const H=this._generateJSON(o.byteLength),h=w+".glb";let E,e=H.length;if("undefined"!==typeof TextEncoder){E=(new TextEncoder).encode(H),e=E.length}const D=this._getPadding(e),t=this._getPadding(o.byteLength),X=28+e+D+o.byteLength+t,A=new Xw(X);if(A.writeUInt32(1179937895),A.writeUInt32(2),A.writeUInt32(X),A.writeUInt32(e+D),A.writeUInt32(1313821514),E)A.writeTypedArray(E);else{const w="_".charCodeAt(0);for(let o=0;o<e;++o){const h=H.charCodeAt(o);h!=H.codePointAt(o)?A.writeUInt8(w):A.writeUInt8(h)}}for(let L=0;L<D;++L)A.writeUInt8(32);A.writeUInt32(o.byteLength+t),A.writeUInt32(5130562),A.writeTypedArray(o);for(let L=0;L<t;++L)A.writeUInt8(0);const y=new L;return y.files[h]=new Blob([A.getOutputData()],{type:"application/octet-stream"}),y}_setNodeTransformation(w,o,H){if(o.getPivotPoint().equalsWithEpsilon(R,G.c)||E.Tools.Warn("Pivot points are not supported in the glTF serializer"),!o.position.equalsWithEpsilon(R,G.c)){const E=h.TmpVectors.io[0].t(o.position);H&&mw(E),w.translation=E.Ae()}o.Je.equalsWithEpsilon(d,G.c)||(w.scale=o.Je.Ae());const e=o.rotationQuaternion||h.Quaternion.FromEulerAngles(o.rotation.x,o.rotation.y,o.rotation.z);e.equalsWithEpsilon(a,G.c)||(H&&Y(e),w.rotation=e.normalize().Ae())}_setCameraTransformation(w,o,H){if(!o.position.equalsWithEpsilon(R,G.c)){const E=h.TmpVectors.io[0].t(o.position);H&&mw(E),w.translation=E.Ae()}const E=o.rotationQuaternion||h.Quaternion.FromEulerAngles(o.rotation.x,o.rotation.y,o.rotation.z);H&&Y(E),this._babylonScene.useRightHandedSystem||x(E),E.equalsWithEpsilon(a,G.c)||(w.rotation=E.Ae())}_listAvailableCameras(){for(const w of this._babylonScene.cameras){const o={type:w.mode===zw.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(w.name&&(o.name=w.name),"perspective"===o.type)o.perspective={aspectRatio:w.getEngine().getAspectRatio(w),yfov:w.fovMode===zw.e.FOVMODE_VERTICAL_FIXED?w.fov:w.fov*w.getEngine().getAspectRatio(w),znear:w.Qe,zfar:w.maxZ};else if("orthographic"===o.type){const H=w.orthoLeft&&w.orthoRight?.5*(w.orthoRight-w.orthoLeft):.5*w.getEngine().getRenderWidth(),h=w.orthoBottom&&w.orthoTop?.5*(w.orthoTop-w.orthoBottom):.5*w.getEngine().getRenderHeight();o.orthographic={xmag:H,ymag:h,znear:w.Qe,zfar:w.maxZ}}this._camerasMap.set(w,o)}}_exportAndAssignCameras(){const w=Array.from(this._camerasMap.values());for(const o of w){const w=this._nodesCameraMap.get(o);if(void 0!==w){this._cameras.push(o);for(const o of w)o.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const w of this._babylonScene.skeletons){if(w.bones.length<=0)continue;const o={joints:[]};this._skinMap.set(w,o)}}_exportAndAssignSkeletons(){for(const w of this._babylonScene.skeletons){if(w.bones.length<=0)continue;const o=this._skinMap.get(w);if(void 0==o)continue;const H={},h=[];let e=-1;for(let E=0;E<w.bones.length;++E){const o=w.bones[E],h=o.getIndex()??E;-1!==h&&(H[h]=o,h>e&&(e=h))}for(let w=0;w<=e;++w){const e=H[w];h.push(e.getAbsoluteInverseBindMatrix());const D=e.getTransformNode();if(null!==D){const w=this._nodeMap.get(D);D&&null!==w&&void 0!==w?o.joints.push(w):E.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else E.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const D=this._nodesSkinMap.get(o);if(o.joints.length>0&&void 0!==D){const w=64*h.length,H=new Float32Array(w/4);h.forEach(((w,o)=>{H.set(w.m,16*o)}));const E=this._bufferManager.createBufferView(H);this._accessors.push(this._bufferManager.createAccessor(E,"MAT4",5126,h.length)),o.inverseBindMatrices=this._accessors.length-1,this._skins.push(o);for(const o of D)o.skin=this._skins.length-1}}}async _exportSceneAsync(){const w={nodes:[]};if(this._babylonScene.metadata){const o=this._options.metadataSelector(this._babylonScene.metadata);o&&(w.extras=o)}const o=new Array,H=new Array,h=new Array;for(const t of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Dw(t,this._babylonScene.useRightHandedSystem)?h.push(...t.getChildren()):this._babylonScene.useRightHandedSystem?o.push(t):H.push(t);this._listAvailableCameras(),this._listAvailableSkeletons();const E=new aw(!0,!1);w.nodes.push(...await this._exportNodesAsync(H,E));const e=new aw(!1,!1);w.nodes.push(...await this._exportNodesAsync(o,e));const D=new aw(!1,!0);w.nodes.push(...await this._exportNodesAsync(h,D)),w.nodes.length&&this._scenes.push(w),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&kw._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,E.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(w){let o=this._shouldExportNodeMap.get(w);return void 0===o&&(o=this._options.shouldExportNode(w),this._shouldExportNodeMap.set(w,o)),o}async _exportNodesAsync(w,o){const H=new Array;this._exportBuffers(w,o);for(const h of w)await this._exportNodeAsync(h,H,o);return H}_collectBuffers(w,o,H,h,E){if(this._shouldExportNode(w)&&w instanceof z.c&&w.re){const e=w.re.getVertexBuffers();if(e)for(const h in e){if(!K(h))continue;const D=e[h];E.setHasVertexColorAlpha(D,w.hasVertexAlpha);const t=D._buffer,X=o.get(t)||[];o.set(t,X),-1===X.indexOf(D)&&X.push(D);const L=H.get(D)||[];H.set(D,L),-1===L.indexOf(w)&&L.push(w)}const D=w.morphTargetManager;if(D)for(let o=0;o<D.numTargets;o++){const H=D.getTarget(o),E=h.get(H)||[];h.set(H,E),-1===E.indexOf(w)&&E.push(w)}}for(const e of w.getChildren())this._collectBuffers(e,o,H,h,E)}_exportBuffers(w,o){const H=new Map,h=new Map,E=new Map;for(const t of w)this._collectBuffers(t,H,h,E,o);const e=Array.from(H.keys());for(const t of e){const w=t.getData();if(!w)throw new Error("Buffer data is not available");const E=H.get(t);if(!E)continue;const e=E[0].byteStride;if(E.some((w=>w.byteStride!==e)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const D=Hw(w).slice();for(const o of E){const w=h.get(o),{byteOffset:H,byteStride:E,componentCount:e,type:t,count:X,normalized:L,kind:y}=U(o,w);switch(y){case A.e.NormalKind:case A.e.TangentKind:(0,q.i)(D,H,E,e,t,X,L,(w=>{const o=Math.sqrt(w[0]*w[0]+w[1]*w[1]+w[2]*w[2]);if(o>0){const H=1/o;w[0]*=H,w[1]*=H,w[2]*=H}}));break;case A.e.ColorKind:{const o=w.filter((w=>w.material instanceof Mw.ro||null==w.material)).length;if(0==o)break;if(o!=w.length){u.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}t==A.e.UNSIGNED_BYTE&&u.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const h=new i.ko,y=new i.ae,z=this._babylonScene.getEngine().useExactSrgbConversions;(0,q.i)(D,H,E,e,t,X,L,(w=>{3===w.length?(h.iH(w,0),h.toLinearSpaceToRef(h,z),h.toArray(w,0)):(y.iH(w,0),y.toLinearSpaceToRef(y,z),y.toArray(w,0))}))}}}if(o.convertToRightHanded){for(const w of E){const o=h.get(w),{byteOffset:H,byteStride:E,componentCount:e,type:t,count:X,normalized:L,kind:y}=U(w,o);switch(y){case A.e.PositionKind:case A.e.NormalKind:case A.e.TangentKind:(0,q.i)(D,H,E,e,t,X,L,(w=>{w[0]=-w[0]}))}}o.convertedToRightHandedBuffers.set(t,D)}const X=this._bufferManager.createBufferView(D,e);o.setVertexBufferView(t,X);const L=new Map;for(const o of E){const w=h.get(o),{kind:H,totalVertices:E}=U(o,w);switch(H){case A.e.MatricesIndicesKind:case A.e.MatricesIndicesExtraKind:if(o.type==A.e.FLOAT){const w=o.getFloatData(E);null!==w&&L.set(o,w)}}}0!==L.size&&u.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const y=Array.from(L.keys());for(const H of y){const w=L.get(H);if(!w)continue;const h=w.some((w=>w>=256)),E=new(h?Uint16Array:Uint8Array)(w.length);for(let o=0;o<w.length;o++)E[o]=w[o];const e=this._bufferManager.createBufferView(E,4*(h?2:1));o.setRemappedBufferView(t,H,e)}}const D=Array.from(E.keys());for(const t of D){const w=E.get(t);if(!w)continue;const H=Pw(t,w[0],this._bufferManager,this._bufferViews,this._accessors,o.convertToRightHanded);for(const h of w)o.bindMorphDataToMesh(h,H)}}async _exportNodeAsync(w,o,H){let h=this._nodeMap.get(w);if(void 0!==h)return void(o.includes(h)||o.push(h));const E=await this._createNodeAsync(w,H);if(E){h=this._nodes.length,this._nodes.push(E),this._nodeMap.set(w,h),H.pushExportedNode(w),o.push(h);const e={name:"runtime animations",channels:[],samplers:[]},D=[];this._babylonScene.animationGroups.length||(kw._CreateMorphTargetAnimationFromMorphTargetAnimations(w,e,D,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,H.convertToRightHanded,this._options.shouldExportAnimation),w.animations.length&&kw._CreateNodeAnimationFromNodeAnimations(w,e,D,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,H.convertToRightHanded,this._options.shouldExportAnimation)),e.channels.length&&e.samplers.length&&this._animations.push(e),D.forEach((w=>{w.channels.length&&w.samplers.length&&this._animations.push(w)}))}const e=E?[]:o;for(const D of w.getChildren())await this._exportNodeAsync(D,e,H);E&&e.length&&(E.children=e)}async _createNodeAsync(w,o){if(!this._shouldExportNode(w))return null;const H={};if(w.name&&(H.name=w.name),w.metadata){const o=this._options.metadataSelector(w.metadata);o&&(H.extras=o)}if(w instanceof y.b&&(this._setNodeTransformation(H,w,o.convertToRightHanded),w instanceof z.c)){const E=w instanceof C.c?w.sourceMesh:w;if(E.Le&&E.Le.length>0&&(H.mesh=await this._exportMeshAsync(E,o)),w.skeleton){const o=this._skinMap.get(w.skeleton);var h;if(void 0!==o)void 0===this._nodesSkinMap.get(o)&&this._nodesSkinMap.set(o,[]),null===(h=this._nodesSkinMap.get(o))||void 0===h||h.push(H)}}if(w instanceof n.e){const h=this._camerasMap.get(w);if(h){var E;void 0===this._nodesCameraMap.get(h)&&this._nodesCameraMap.set(h,[]),this._setCameraTransformation(H,w,o.convertToRightHanded);const D=w.parent;if(null!==D&&ow(w,D)){const w=this._nodeMap.get(D);if(void 0!==w){var e;const o=this._nodes[w];return ww(H,o),null===(e=this._nodesCameraMap.get(h))||void 0===e||e.push(o),null}}null===(E=this._nodesCameraMap.get(h))||void 0===E||E.push(H)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",H,w,this._nodeMap,o.convertToRightHanded)?H:(u.d.Warn(`Not exporting node ${w.name}`),null)}_exportIndices(w,o,H,h,E,D,t,X,L){let A=w;L.mode=F(D);const y=t!==e.e.CounterClockWiseSideOrientation,z=!X.wasAddedByNoopNode&&y,C=function(w){switch(w){case e.e.TriangleFillMode:case e.e.TriangleStripDrawMode:case e.e.TriangleFanDrawMode:return!0}return!1}(D)&&z;if(C){if(D===e.e.TriangleStripDrawMode||D===e.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");L.mode=F(D);const t=o?new Uint32Array(h):new Uint16Array(h);if(w)for(let o=0;o+2<h;o+=3)t[o]=w[H+o]+E,t[o+1]=w[H+o+2]+E,t[o+2]=w[H+o+1]+E;else for(let w=0;w+2<h;w+=3)t[w]=w,t[w+1]=w+2,t[w+2]=w+1;A=t}else if(w&&0!==E){const e=o?new Uint32Array(h):new Uint16Array(h);for(let o=0;o<h;o++)e[o]=w[H+o]+E;A=e}if(A){let e=X.getIndicesAccessor(w,H,h,E,C);if(void 0===e){const D=function(w,o,H,h){if(w instanceof Uint16Array||w instanceof Uint32Array)return w;if(w instanceof Int32Array)return new Uint32Array(w.buffer,w.byteOffset,w.length);const E=w.slice(o,o+H);return h?new Uint32Array(E):new Uint16Array(E)}(A,0,h,o),t=this._bufferManager.createBufferView(D),L=o?5125:5123;this._accessors.push(this._bufferManager.createAccessor(t,"SCALAR",L,h,0)),e=this._accessors.length-1,X.setIndicesAccessor(w,H,h,E,C,e)}L.indices=e}}_exportVertexBuffer(w,o,H,h,E,e){const D=w.getKind();if(!K(D))return;if(D.startsWith("uv")&&!this._options.exportUnusedUVs&&(!o||!this._materialNeedsUVsSet.has(o)))return;let t=E.getVertexAccessor(w,H,h);if(void 0===t){const o=E.convertedToRightHandedBuffers.get(w._buffer)||w._buffer.getData(),e=D===A.e.PositionKind?function(w,o,H,h){const{byteOffset:E,byteStride:e,type:D,normalized:t}=o,X=o.getSize(),L=new Array(X).fill(1/0),A=new Array(X).fill(-1/0);return(0,q.i)(w,E+H*e,e,X,D,h*X,t,(w=>{for(let o=0;o<X;o++)L[o]=Math.min(L[o],w[o]),A[o]=Math.max(A[o],w[o])})),{min:L,max:A}}(o,w,H,h):void 0,X=(D===A.e.MatricesIndicesKind||D===A.e.MatricesIndicesExtraKind)&&w.type===A.e.FLOAT,L=X?A.e.UNSIGNED_BYTE:w.type,y=X?void 0:w.normalized,z=X?E.getRemappedBufferView(w._buffer,w):E.getVertexBufferView(w._buffer),C=w.byteOffset+H*w.byteStride;this._accessors.push(this._bufferManager.createAccessor(z,function(w,o){if(w==A.e.ColorKind)return o?"VEC4":"VEC3";switch(w){case A.e.PositionKind:case A.e.NormalKind:return"VEC3";case A.e.TangentKind:case A.e.MatricesIndicesKind:case A.e.MatricesIndicesExtraKind:case A.e.MatricesWeightsKind:case A.e.MatricesWeightsExtraKind:return"VEC4";case A.e.UVKind:case A.e.UV2Kind:case A.e.UV3Kind:case A.e.UV4Kind:case A.e.UV5Kind:case A.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${w}`)}(D,E.hasVertexColorAlpha(w)),L,h,C,e,y)),t=this._accessors.length-1,E.setVertexAccessor(w,H,h,t)}e.attributes[function(w){switch(w){case A.e.PositionKind:return"POSITION";case A.e.NormalKind:return"NORMAL";case A.e.TangentKind:return"TANGENT";case A.e.ColorKind:return"COLOR_0";case A.e.UVKind:return"TEXCOORD_0";case A.e.UV2Kind:return"TEXCOORD_1";case A.e.UV3Kind:return"TEXCOORD_2";case A.e.UV4Kind:return"TEXCOORD_3";case A.e.UV5Kind:return"TEXCOORD_4";case A.e.UV6Kind:return"TEXCOORD_5";case A.e.MatricesIndicesKind:return"JOINTS_0";case A.e.MatricesIndicesExtraKind:return"JOINTS_1";case A.e.MatricesWeightsKind:return"WEIGHTS_0";case A.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${w}`)}(D)]=t}async _exportMaterialAsync(w,o,H,h){let E=this._materialMap.get(w);if(void 0===E){const h=o&&Object.keys(o).some((w=>w.startsWith("uv")));if((w=w instanceof Cw.e?w.de[H.materialIndex]:w)instanceof Qw.c)E=await this._materialExporter.exportPBRMaterialAsync(w,"image/png",h);else{if(!(w instanceof Mw.ro))return void u.d.Warn(`Unsupported material '${w.name}' with type ${w.getClassName()}`);E=await this._materialExporter.exportStandardMaterialAsync(w,"image/png",h)}this._materialMap.set(w,E)}h.material=E}async _exportMeshAsync(w,o){var H;let h=o.getMesh(w);if(void 0!==h)return h;const E={primitives:[]};h=this._meshes.length,this._meshes.push(E),o.setMesh(w,h);const D=w.isUnIndexed?null:w.ke(),t=null===(H=w.re)||void 0===H?void 0:H.getVertexBuffers(),X=o.getMorphTargetsFromMesh(w),L=w instanceof lw.d,A=w instanceof Rw,y=w.Le;if(t&&y&&y.length>0)for(const Q of y){const H={attributes:{}},h=Q.jw()||this._babylonScene.defaultMaterial;if(A){var z,C;const o={name:h.name},E=w,e=i.ko.White(),D=(null===(z=E.material)||void 0===z?void 0:z.alpha)??1,t=(null===(C=E.greasedLineMaterial)||void 0===C?void 0:C.color)??e;(!t.equalsWithEpsilon(e,G.c)||D<1)&&(o.pbrMetallicRoughness={baseColorFactor:[...t.Ae(),D]}),this._materials.push(o),H.material=this._materials.length-1}else if(L){const o={name:h.name},E=w;(!E.color.equalsWithEpsilon(i.ko.White(),G.c)||E.alpha<1)&&(o.pbrMetallicRoughness={baseColorFactor:[...E.color.Ae(),E.alpha]}),this._materials.push(o),H.material=this._materials.length-1}else await this._exportMaterialAsync(h,t,Q,H);const y=L||A?e.e.LineListDrawMode:w.overrideRenderingFillMode??h.fillMode,M=h._getEffectiveOrientation(w);this._exportIndices(D,D?(0,q.c)(D,Q.indexCount,Q.indexStart,Q.verticesStart):Q.verticesCount>65535,D?Q.indexStart:Q.verticesStart,D?Q.indexCount:Q.verticesCount,-Q.verticesStart,y,M,o,H);for(const w of Object.values(t))this._exportVertexBuffer(w,h,Q.verticesStart,Q.verticesCount,o,H);if(X){H.targets=[];for(const w of X)H.targets.push(w.attributes)}E.primitives.push(H),this._extensionsPostExportMeshPrimitive(H)}if(X){E.weights=[],E.extras||(E.extras={}),E.extras.targetNames=[];for(const w of X)E.weights.push(w.influence),E.extras.targetNames.push(w.name)}return h}}dw._ExtensionNames=new Array,dw._ExtensionFactories={};class Iw{static async GLTFAsync(w,o,H){H&&H.exportWithoutWaitingForScene||await w.whenReadyAsync();const h=new dw(w,H),E=await h.generateGLTFAsync(o.replace(/\.[^/.]+$/,""));return h.dispose(),E}static async GLBAsync(w,o,H){H&&H.exportWithoutWaitingForScene||await w.whenReadyAsync();const h=new dw(w,H),E=await h.generateGLBAsync(o.replace(/\.[^/.]+$/,""));return h.dispose(),E}}H(12285);const Uw="EXT_mesh_gpu_instancing";class Zw{constructor(w){this.name=Uw,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(w,o,H,E,e,D){return await new Promise((w=>{if(o&&H instanceof Vw.d&&H.hasThinInstances&&this._exporter){this._wasUsed=!0;const w=h.io.Zero(),E=h.Quaternion.Identity(),t=h.io.One(),X=H.thinInstanceGetWorldMatrices(),L=h.TmpVectors.io[2],A=h.TmpVectors.Quaternion[1],y=h.TmpVectors.io[3];let z=!1,C=!1,Q=!1;const M=new Float32Array(3*H.Ie),i=new Float32Array(4*H.Ie),s=new Float32Array(3*H.Ie);let V=0;for(const o of X)o.decompose(y,A,L),e&&(mw(L),Y(A)),M.set(L.Ae(),3*V),i.set(A.normalize().Ae(),4*V),s.set(y.Ae(),3*V),z=z||!L.equalsWithEpsilon(w),C=C||!A.equalsWithEpsilon(E),Q=Q||!y.equalsWithEpsilon(t),V++;const r={attributes:{}};z&&(r.attributes.TRANSLATION=this._buildAccessor(M,"VEC3",H.Ie,D)),C&&(r.attributes.ROTATION=this._buildAccessor(i,"VEC4",H.Ie,D)),Q&&(r.attributes.SCALE=this._buildAccessor(s,"VEC3",H.Ie,D)),o.extensions=o.extensions||{},o.extensions[Uw]=r}w(o)}))}_buildAccessor(w,o,H,h){const E=h.createBufferView(w),e=h.createAccessor(E,o,5126,H);return this._exporter._accessors.push(e),this._exporter._accessors.length-1}}dw.RegisterExtension(Uw,(w=>new Zw(w)));var Kw=H(12290),Fw=H(12301),vw=H(12309),mo=H(12315);function Yw(w){return w===vw.b.PositionKind?"POSITION":w===vw.b.NormalKind?"NORMAL":w===vw.b.ColorKind?"COLOR":w.startsWith(vw.b.UVKind)?"TEX_COORD":"GENERIC"}const xw={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class wo extends Kw.d{static get DefaultAvailable(){return(0,Kw.h)(wo.DefaultConfiguration)}static get Default(){return wo._Default??(wo._Default=new wo),wo._Default}static ResetDefault(w){wo._Default&&(w||wo._Default.dispose(),wo._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(w,o){return{module:await(o||DracoEncoderModule)({wasmBinary:w})}}_getWorkerContent(){return`${Fw.g}(${Fw.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:wo.DefaultConfiguration)}async _encodeAsync(w,o,H){const h=H?(0,mo.d)(xw,H):xw;if(this._workerPoolPromise){const H=await this._workerPoolPromise;return await new Promise(((E,e)=>{H.push(((H,D)=>{const t=w=>{H.removeEventListener("error",t),H.removeEventListener("message",X),e(w),D()},X=w=>{"encodeMeshDone"===w.data.id&&(H.removeEventListener("error",t),H.removeEventListener("message",X),E(w.data.encodedMeshData),D())};H.addEventListener("error",t),H.addEventListener("message",X);const L=[];for(const o of w)L.push(o.data.buffer);o&&L.push(o.buffer),H.postMessage({id:"encodeMesh",attributes:w,indices:o,options:h},L)}))}))}if(this._modulePromise){const H=await this._modulePromise;return(0,Fw.g)(H.module,w,o,h)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(w,o){if(0==w.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");w instanceof Vw.d&&w.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===o||void 0===o?void 0:o.method)&&(u.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),o.method="MESH_SEQUENTIAL_ENCODING");const H=function(w){let o=w.ke(void 0,!0);return!o||o instanceof Uint32Array||o instanceof Uint16Array||(o=((0,q.c)(o,o.length)?Uint32Array:Uint16Array).from(o)),o}(w),h=function(w,o){const H=[];for(const h of w.getVerticesDataKinds()){if(null!==o&&void 0!==o&&o.includes(h)){if(h===vw.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const E=w.getVertexBuffer(h),e=E.getSize(),D=(0,q.t)(E.getData(),e,E.type,E.byteOffset,E.byteStride,E.normalized,w.getTotalVertices(),!0);H.push({kind:h,dracoName:Yw(h),size:e,data:D})}return H}(w,null===o||void 0===o?void 0:o.excludedAttributes);return await this._encodeAsync(h,H,o)}}wo.DefaultConfiguration={wasmUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder.js`},wo._Default=null;const oo="KHR_draco_mesh_compression";class Ho{get wasUsed(){return this._wasUsed}constructor(w){this.name=oo,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===w.options.meshCompressionMethod&&wo.DefaultAvailable}dispose(){}postExportMeshPrimitive(w,o,H){if(!this.enabled)return;if(4!==w.mode&&5!==w.mode)return void u.d.Warn("Cannot compress primitive with mode "+w.mode+".");const h=[],E=[];let e=null;if(void 0!==w.indices){const D=H[w.indices],t=o.getBufferView(D);e=o.getData(t).slice(),h.push(t),E.push(D)}const D=[];for(const[A,y]of Object.entries(w.attributes)){const w=H[y],e=o.getBufferView(w),X=Z(w.type),L=(0,q.t)(o.getData(e),X,w.componentType,w.byteOffset||0,e.byteStride||(0,q.m)(w.componentType)*X,w.normalized||!1,w.count,!0);D.push({kind:A,dracoName:(t=A,"POSITION"===t?"POSITION":"NORMAL"===t?"NORMAL":t.startsWith("COLOR")?"COLOR":t.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:Z(w.type),data:L}),h.push(e),E.push(w)}var t;const X={method:w.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},L=wo.Default._encodeAsync(D,e,X).then((H=>{if(!H)return void u.d.Error("Draco encoding failed for primitive.");const e={bufferView:-1,attributes:H.attributeIds},D=o.createBufferView(H.data);o.setBufferView(e,D);for(const w of h)this._bufferViewsUsed.add(w);for(const w of E)this._accessorsUsed.add(w);w.extensions||(w.extensions={}),w.extensions[oo]=e})).catch((w=>{u.d.Error("Draco encoding failed for primitive: "+w)}));this._encodePromises.push(L),this._wasUsed=!0}async preGenerateBinaryAsync(w){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((o=>{w.getPropertiesWithBufferView(o).every((w=>this._accessorsUsed.has(w)))&&w.removeBufferView(o)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}dw.RegisterExtension(oo,(w=>new Ho(w)));var ho=H(12319);const Eo="KHR_lights_punctual",eo={name:"",color:[1,1,1],Ue:1,range:Number.MAX_VALUE},Do={innerConeAngle:0,outerConeAngle:Math.PI/4},to=h.io.Backward();class Xo{constructor(w){this.name=Eo,this.enabled=!0,this.required=!1,this._exporter=w}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Eo]=this._lights}async postExportNodeAsync(w,o,H,E,e){return await new Promise((D=>{if(!(H instanceof rw.b))return void D(o);const t=H.getTypeID()==rw.b.LIGHTTYPEID_POINTLIGHT?"point":H.getTypeID()==rw.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":H.getTypeID()==rw.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!t||!(H instanceof ho.e))return u.d.Warn(`${w}: Light ${H.name} is not supported in ${Eo}`),void D(o);if(H.falloffType!==rw.b.FALLOFF_GLTF&&u.d.Warn(`${w}: Light falloff for ${H.name} does not match the ${Eo} specification!`),!H.position.equalsToFloats(0,0,0)){const w=h.TmpVectors.io[0].t(H.position);e&&mw(w),o.translation=w.Ae()}if("point"!==t){const w=H.direction.normalizeToRef(h.TmpVectors.io[0]);e&&mw(w);const E=h.Quaternion.FromUnitVectorsToRef(to,w,h.TmpVectors.Quaternion[0]);h.Quaternion.IsIdentity(E)||(o.rotation=E.Ae())}const X={type:t,name:H.name,color:H.Ze.Ae(),Ue:H.Ue,range:H.range};if(hw(X,eo),"spot"===t){const w=H;X.spot={innerConeAngle:w.innerAngle/2,outerConeAngle:w.angle/2},hw(X.spot,Do)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(X);const L={qh:this._lights.lights.length-1},A=H.parent;if(A&&ow(H,A)){const w=E.get(A);if(w){const H=this._exporter._nodes[w];return ww(o,H),H.extensions||(H.extensions={}),H.extensions[Eo]=L,void D(null)}}o.extensions||(o.extensions={}),o.extensions[Eo]=L,D(o)}))}}dw.RegisterExtension(Eo,(w=>new Xo(w)));var Lo=H(12223);const Ao="KHR_materials_anisotropy";class yo{constructor(w){this.name=Ao,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,o,H){const h=[];return H instanceof Lo.e&&H.anisotropy.isEnabled&&!H.anisotropy.legacy?(H.anisotropy.texture&&h.push(H.anisotropy.texture),h):[]}postExportMaterialAsync(w,o,H){return new Promise((w=>{if(H instanceof Lo.e){if(!H.anisotropy.isEnabled||H.anisotropy.legacy)return void w(o);this._wasUsed=!0,o.extensions=o.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(H.anisotropy.texture),E={anisotropyStrength:H.anisotropy.Ue,anisotropyRotation:H.anisotropy.angle,anisotropyTexture:h??void 0};null!==E.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(H),o.extensions[Ao]=E}w(o)}))}}dw.RegisterExtension(Ao,(w=>new yo(w)));const zo="KHR_materials_clearcoat";class Co{constructor(w){this.name=zo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,o,H){const h=[];return H instanceof Lo.e&&H.clearCoat.isEnabled?(H.clearCoat.texture&&h.push(H.clearCoat.texture),!H.clearCoat.useRoughnessFromMainTexture&&H.clearCoat.textureRoughness&&h.push(H.clearCoat.textureRoughness),H.clearCoat.bumpTexture&&h.push(H.clearCoat.bumpTexture),h):[]}postExportMaterialAsync(w,o,H){return new Promise((w=>{if(H instanceof Lo.e){if(!H.clearCoat.isEnabled)return void w(o);this._wasUsed=!0,o.extensions=o.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(H.clearCoat.texture);let e;e=H.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(H.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(H.clearCoat.textureRoughness),H.clearCoat.isTintEnabled&&E.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${H.name}`),H.clearCoat.remapF0OnInterfaceChange&&E.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${H.name}`);const D=this._exporter._materialExporter.getTextureInfo(H.clearCoat.bumpTexture),t={clearcoatFactor:H.clearCoat.Ue,clearcoatTexture:h??void 0,clearcoatRoughnessFactor:H.clearCoat.roughness,clearcoatRoughnessTexture:e??void 0,clearcoatNormalTexture:D??void 0};null===t.clearcoatTexture&&null===t.clearcoatRoughnessTexture&&null===t.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(H),o.extensions[zo]=t}w(o)}))}}dw.RegisterExtension(zo,(w=>new Co(w)));const Qo="KHR_materials_diffuse_transmission";function Mo(w,o){const H=o.subSurface;let h=null;return H.translucencyIntensityTexture?h=H.translucencyIntensityTexture:H.thicknessTexture&&H.useMaskFromThicknessTexture&&(h=H.thicknessTexture),h&&!H.useGltfStyleTextures?(u.d.Warn(`${w}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${o.name}`,1),null):h}class io{constructor(w){this.name=Qo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,o,H){const h=[];if(H instanceof Qw.c&&this._isExtensionEnabled(H)){const o=Mo(w,H);return o&&h.push(o),H.subSurface.translucencyColorTexture&&h.push(H.subSurface.translucencyColorTexture),h}return h}_isExtensionEnabled(w){if(w.unlit)return!1;const o=w.subSurface;return!!o.isTranslucencyEnabled&&(!w.unlit&&!o.useAlbedoToTintTranslucency&&o.useGltfStyleTextures&&1===o.volumeIndexOfRefraction&&0===o.minimumThickness&&0===o.maximumThickness)}postExportMaterialAsync(w,o,H){return new Promise((h=>{if(H instanceof Qw.c&&this._isExtensionEnabled(H)){this._wasUsed=!0;const h=H.subSurface,E=Mo(w,H),e=0==h.translucencyIntensity?void 0:h.translucencyIntensity,D=this._exporter._materialExporter.getTextureInfo(E)??void 0,t=!h.translucencyColor||h.translucencyColor.equalsFloats(1,1,1)?void 0:h.translucencyColor.Ae(),X=this._exporter._materialExporter.getTextureInfo(h.translucencyColorTexture)??void 0,L={diffuseTransmissionFactor:e,diffuseTransmissionTexture:D,diffuseTransmissionColorFactor:t,diffuseTransmissionColorTexture:X};(D||X)&&this._exporter._materialNeedsUVsSet.add(H),o.extensions=o.extensions||{},o.extensions[Qo]=L}h(o)}))}}dw.RegisterExtension(Qo,(w=>new io(w)));const so="KHR_materials_dispersion";class Vo{constructor(){this.name=so,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(w){if(w.unlit)return!1;const o=w.subSurface;return!(!o.isRefractionEnabled&&!o.isDispersionEnabled)}postExportMaterialAsync(w,o,H){return new Promise((w=>{if(H instanceof Qw.c&&this._isExtensionEnabled(H)){this._wasUsed=!0;const w={dispersion:H.subSurface.dispersion};o.extensions=o.extensions||{},o.extensions[so]=w}w(o)}))}}dw.RegisterExtension(so,(()=>new Vo));const ro="KHR_materials_emissive_strength";class ko{constructor(){this.name=ro,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(w,o,H){return await new Promise((w=>{if(!(H instanceof Qw.c))return w(o);const h=H.emissiveColor.Ae(),E=Math.max(...h);if(E>1){this._wasUsed=!0,o.extensions||(o.extensions={});const w={emissiveStrength:E},h=H.emissiveColor.scale(1/w.emissiveStrength);o.emissiveFactor=h.Ae(),o.extensions[ro]=w}return w(o)}))}}dw.RegisterExtension(ro,(w=>new ko));const Po="KHR_materials_ior";class lo{constructor(){this.name=Po,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(w){return!w.unlit&&(void 0!=w.indexOfRefraction&&1.5!=w.indexOfRefraction)}postExportMaterialAsync(w,o,H){return new Promise((w=>{if(H instanceof Qw.c&&this._isExtensionEnabled(H)){this._wasUsed=!0;const w={ior:H.indexOfRefraction};o.extensions=o.extensions||{},o.extensions[Po]=w}w(o)}))}}dw.RegisterExtension(Po,(w=>new lo));const Oo="KHR_materials_iridescence";class To{constructor(w){this.name=Oo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,o,H){const h=[];return H instanceof Lo.e&&H.iridescence.isEnabled?(H.iridescence.texture&&h.push(H.iridescence.texture),H.iridescence.thicknessTexture&&H.iridescence.thicknessTexture!==H.iridescence.texture&&h.push(H.iridescence.thicknessTexture),h):[]}postExportMaterialAsync(w,o,H){return new Promise((w=>{if(H instanceof Lo.e){if(!H.iridescence.isEnabled)return void w(o);this._wasUsed=!0,o.extensions=o.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(H.iridescence.texture),E=this._exporter._materialExporter.getTextureInfo(H.iridescence.thicknessTexture),e={iridescenceFactor:H.iridescence.Ue,iridescenceIor:H.iridescence.indexOfRefraction,iridescenceThicknessMinimum:H.iridescence.minimumThickness,iridescenceThicknessMaximum:H.iridescence.maximumThickness,iridescenceTexture:h??void 0,iridescenceThicknessTexture:E??void 0};null===e.iridescenceTexture&&null===e.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(H),o.extensions[Oo]=e}w(o)}))}}dw.RegisterExtension(Oo,(w=>new To(w)));const So="KHR_materials_sheen";class co{constructor(w){this.name=So,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,o,H){return H instanceof Qw.c&&H.sheen.isEnabled&&H.sheen.texture?[H.sheen.texture]:[]}async postExportMaterialAsync(w,o,H){return await new Promise((w=>{if(H instanceof Qw.c){if(!H.sheen.isEnabled)return void w(o);this._wasUsed=!0,null==o.extensions&&(o.extensions={});const h={sheenColorFactor:H.sheen.color.Ae(),sheenRoughnessFactor:H.sheen.roughness??0};null===h.sheenColorTexture&&null===h.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(H),H.sheen.texture&&(h.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.texture)??void 0),H.sheen.textureRoughness&&!H.sheen.useRoughnessFromMainTexture?h.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.textureRoughness)??void 0:H.sheen.texture&&H.sheen.useRoughnessFromMainTexture&&(h.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.texture)??void 0),o.extensions[So]=h}w(o)}))}}dw.RegisterExtension(So,(w=>new co(w)));const Wo="KHR_materials_specular";class Bo{constructor(w){this.name=Wo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,o,H){const h=[];return H instanceof Qw.c&&this._isExtensionEnabled(H)?(H.metallicReflectanceTexture&&h.push(H.metallicReflectanceTexture),H.reflectanceTexture&&h.push(H.reflectanceTexture),h):h}_isExtensionEnabled(w){return!w.unlit&&(void 0!=w.metallicF0Factor&&1!=w.metallicF0Factor||void 0!=w.metallicReflectanceColor&&!w.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(w))}_hasTexturesExtension(w){return null!=w.metallicReflectanceTexture||null!=w.reflectanceTexture}postExportMaterialAsync(w,o,H){return new Promise((w=>{if(H instanceof Qw.c&&this._isExtensionEnabled(H)){this._wasUsed=!0,o.extensions=o.extensions||{};const w=this._exporter._materialExporter.getTextureInfo(H.metallicReflectanceTexture)??void 0,h=this._exporter._materialExporter.getTextureInfo(H.reflectanceTexture)??void 0,E={specularFactor:1==H.metallicF0Factor?void 0:H.metallicF0Factor,specularTexture:w,specularColorFactor:H.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:H.metallicReflectanceColor.Ae(),specularColorTexture:h};this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),o.extensions[Wo]=E}w(o)}))}}dw.RegisterExtension(Wo,(w=>new Bo(w)));const Jo="KHR_materials_transmission";class go{constructor(w){this.name=Jo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,o,H){const h=[];return H instanceof Qw.c&&this._isExtensionEnabled(H)?(H.subSurface.thicknessTexture&&h.push(H.subSurface.thicknessTexture),h):h}_isExtensionEnabled(w){if(w.unlit)return!1;const o=w.subSurface;return o.isRefractionEnabled&&void 0!=o.refractionIntensity&&0!=o.refractionIntensity||this._hasTexturesExtension(w)}_hasTexturesExtension(w){return null!=w.subSurface.refractionIntensityTexture}async postExportMaterialAsync(w,o,H){if(H instanceof Qw.c&&this._isExtensionEnabled(H)){this._wasUsed=!0;const h=H.subSurface,E={transmissionFactor:0===h.refractionIntensity?void 0:h.refractionIntensity};if(this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),h.refractionIntensityTexture)if(h.useGltfStyleTextures){const w=await this._exporter._materialExporter.exportTextureAsync(h.refractionIntensityTexture,"image/png");w&&(E.transmissionTexture=w)}else u.d.Warn(`${w}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);o.extensions||(o.extensions={}),o.extensions[Jo]=E}return o}}dw.RegisterExtension(Jo,(w=>new go(w)));const bo="KHR_materials_unlit";class po{constructor(){this.name=bo,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(w,o,H){return new Promise((w=>{let h=!1;H instanceof Qw.c?h=H.unlit:H instanceof Mw.ro&&(h=H.disableLighting),h&&(this._wasUsed=!0,null==o.extensions&&(o.extensions={}),o.extensions[bo]={}),w(o)}))}}dw.RegisterExtension(bo,(()=>new po));const fo="KHR_materials_volume";class No{constructor(w){this.name=fo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,o,H){const h=[];return H instanceof Qw.c&&this._isExtensionEnabled(H)?(H.subSurface.thicknessTexture&&h.push(H.subSurface.thicknessTexture),h):h}_isExtensionEnabled(w){if(w.unlit)return!1;const o=w.subSurface;return!(!o.isRefractionEnabled&&!o.isTranslucencyEnabled)&&(void 0!=o.maximumThickness&&0!=o.maximumThickness||void 0!=o.tintColorAtDistance&&o.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=o.tintColor&&o.tintColor!=i.ko.White()||this._hasTexturesExtension(w))}_hasTexturesExtension(w){return null!=w.subSurface.thicknessTexture}postExportMaterialAsync(w,o,H){return new Promise((w=>{if(H instanceof Qw.c&&this._isExtensionEnabled(H)){this._wasUsed=!0;const w=H.subSurface,h={thicknessFactor:0==w.maximumThickness?void 0:w.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(w.thicknessTexture)??void 0,attenuationDistance:w.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:w.tintColorAtDistance,attenuationColor:w.tintColor.equalsFloats(1,1,1)?void 0:w.tintColor.Ae()};this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),o.extensions=o.extensions||{},o.extensions[fo]=h}w(o)}))}}dw.RegisterExtension(fo,(w=>new No(w)));const jo="EXT_materials_diffuse_roughness";class qo{constructor(w){this.name=jo,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,o,H){const h=[];return H instanceof Lo.e&&H._baseDiffuseRoughness?(H._baseDiffuseRoughnessTexture&&h.push(H._baseDiffuseRoughnessTexture),h):[]}postExportMaterialAsync(w,o,H){return new Promise((w=>{if(H instanceof Lo.e){if(!H._baseDiffuseRoughness)return void w(o);this._wasUsed=!0,o.extensions=o.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(H._baseDiffuseRoughnessTexture),E={diffuseRoughnessFactor:H._baseDiffuseRoughness,diffuseRoughnessTexture:h??void 0};null!==E.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(H),o.extensions[jo]=E}w(o)}))}}dw.RegisterExtension(jo,(w=>new qo(w)));const uo="KHR_texture_transform";class no{constructor(){this.name=uo,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(w,o,H){if(H.Ow()||E.Tools.Warn(`${w}: /*@__KEY__*/"scene" is not defined for Babylon texture ${H.name}!`),(0!==H.uAng||0!==H.vAng)&&(E.Tools.Warn(`${w}: Texture ${H.name} with rotation in the u or v axis is not supported in glTF.`),0!==H.uRotationCenter||0!==H.vRotationCenter))return;const h={};let e=!1;if(0===H.uOffset&&0===H.vOffset||(h.offset=[H.uOffset,H.vOffset],e=!0),1===H.uScale&&1===H.vScale||(h.scale=[H.uScale,H.vScale],e=!0),0!==H.wAng){if(0!==H.uRotationCenter||0!==H.vRotationCenter){if(H.homogeneousRotationInUVTransform&&H.uScale!==H.vScale)return void E.Tools.Warn(`${w}: Texture ${H.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${uo}.`);E.Tools.Warn(`${w}: Texture ${H.name} with non-origin rotation center will be exported using an adjusted offset with ${uo}.`),h.offset=function(w){const{uOffset:o,vOffset:H,uRotationCenter:h,vRotationCenter:E,uScale:e,vScale:D,wAng:t}=w,X=Math.cos(t),L=Math.sin(t),A=h*e,y=E*D;return[o+(A*(1-X)+y*L),H+(y*(1-X)-A*L)]}(H)}h.rotation=-H.wAng,e=!0}0!==H.coordinatesIndex&&(h.texCoord=H.coordinatesIndex,e=!0),e&&(this._wasUsed=!0,o.extensions||(o.extensions={}),o.extensions[uo]=h)}}dw.RegisterExtension(uo,(()=>new no));class Go{static CreateSTL(w){let o=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],e=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],D=arguments.length>5&&void 0!==arguments[5]&&arguments[5],t=arguments.length>6&&void 0!==arguments[6]&&arguments[6],X=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const L=function(w,o,H){const E=[3*w[H],3*w[H+1],3*w[H+2]],e=[new h.io(o[E[0]],o[E[0]+2],o[E[0]+1]),new h.io(o[E[1]],o[E[1]+2],o[E[1]+1]),new h.io(o[E[2]],o[E[2]+2],o[E[2]+1])],D=e[0].so(e[1]),t=e[2].so(e[1]);return{v:e,n:h.io.Cross(t,D).normalize()}},y=function(w,o,H,h){return o=z(w,o,H.x,h),o=z(w,o,H.y,h),z(w,o,H.z,h)},z=function(w,o,H,h){return w.setFloat32(o,H,h),o+4},Q=function(w){if(t){let o=w;w instanceof C.c&&(o=w.sourceMesh);const H=o.getVerticesData(A.e.PositionKind,!0,!0);if(!H)return[];const E=h.io.Zero();let e;for(e=0;e<H.length;e+=3)h.io.TransformCoordinatesFromFloatsToRef(H[e],H[e+1],H[e+2],w.se(!0),E).toArray(H,e);return H}return w.getVerticesData(A.e.PositionKind)||[]};t&&(D=!0);let M="",i=0,s=0;if(E){for(let H=0;H<w.length;H++){const o=w[H].ke();i+=o?o.length/3:0}const o=new ArrayBuffer(84+50*i);M=new DataView(o),s+=80,M.setUint32(s,i,e),s+=4}else X||(M="solid stlmesh\r\n");for(let h=0;h<w.length;h++){const o=w[h];!E&&X&&(M+="solid "+o.name+"\r\n"),!D&&o instanceof Vw.d&&o.bakeCurrentTransformIntoVertices();const H=Q(o),t=o.ke()||[];for(let w=0;w<t.length;w+=3){const o=L(t,H,w);E?(s=y(M,s,o.n,e),s=y(M,s,o.v[0],e),s=y(M,s,o.v[1],e),s=y(M,s,o.v[2],e),s+=2):(M+="\tfacet normal "+o.n.x+" "+o.n.y+" "+o.n.z+"\r\n",M+="\t\touter loop\r\n",M+="\t\t\tvertex "+o.v[0].x+" "+o.v[0].y+" "+o.v[0].z+"\r\n",M+="\t\t\tvertex "+o.v[1].x+" "+o.v[1].y+" "+o.v[1].z+"\r\n",M+="\t\t\tvertex "+o.v[2].x+" "+o.v[2].y+" "+o.v[2].z+"\r\n",M+="\t\tendloop\r\n",M+="\tendfacet\r\n")}!E&&X&&(M+="endsolid "+name+"\r\n")}if(E||X||(M+="endsolid stlmesh"),o){const w=document.createElement("a"),o=new Blob([M],{type:"application/octet-stream"});w.href=window.URL.createObjectURL(o),w.download=H+".stl",w.click()}return M}}function Ro(w,o){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const h=[];for(let E=0;E<w.length/H;E++){const e=w[E*H],D=w[E*H+1],t=w[E*H+2];h.push(`(${e.toPrecision(o.precision)}, ${D.toPrecision(o.precision)}, ${t.toPrecision(o.precision)})`)}return h.join(", ")}function ao(w,o){const H=[];for(let h=0;h<w.length/2;h++){const E=w[2*h],e=w[2*h+1];H.push(`(${E.toPrecision(o.precision)}, ${(1-e).toPrecision(o.precision)})`)}return H.join(", ")}function Io(w,o){const H=w.getVerticesData(A.e.PositionKind),h=w.getVerticesData(A.e.NormalKind);if(H&&h)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(w){var o;const H=null!==(o=w.ke())&&void 0!==o&&o.length?w.getTotalIndices():w.getTotalVertices();return Array(H/3).fill(3).join(", ")}(w)}]\n\t\tint[] faceVertexIndices = [${function(w){const o=w.ke(),H=[];if(null!==o)for(let h=0;h<o.length;h++)H.push(o[h]);else{const o=w.getTotalVertices();for(let w=0;w<o;w++)H.push(w)}return H.join(", ")}(w)}]\n\t\tnormal3f[] normals = [${Ro(h,o)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Ro(H,o)}]\n        ${function(w,o){let H="";for(let E=0;E<4;E++){const h=E>0?E:"",e=w.getVerticesData(A.e.UVKind+(h?h+1:""));e&&(H+=`\n\t\ttexCoord2f[] primvars:st${h} = [${ao(e,o)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const h=w.getVerticesData(A.e.ColorKind);return h&&(H+=`\n\tcolor3f[] primvars:displayColor = [${Ro(h,o,h.length/w.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),H}(w,o)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Uo(w,o){return`\n        def "Geometry"\n        {\n        ${Io(w,o)}\n        }\n        `}function Zo(w){let o='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return o+=w,fflate.strToU8(o)}function Ko(w){const o=w.m;return`( ${Fo(o,0)}, ${Fo(o,4)}, ${Fo(o,8)}, ${Fo(o,12)} )`}function Fo(w,o){return`(${w[o+0]}, ${w[o+1]}, ${w[o+2]}, ${w[o+3]})`}function vo(w){const o="Object_"+w.uniqueId,H=function(w){const o=w.getWorldMatrix().clone(),H=w.Ow().useRightHandedSystem;if(!H){let h=w.parent;for(;h;){if(Dw(h,H)){o.multiplyToRef(h.getWorldMatrix().invert(),o);break}h=h.parent}}return o.determinant()<0&&E.Tools.Warn(`Exporting mesh ${w.name} with negative scale. Result may look incorrect in destination engine.`),o}(w),h=Ko(H);return`def Xform "${o}" (\n\tprepend references = @./geometries/Geometry_${w.re.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${h}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${w.material.uniqueId}>\n}\n\n`}function mH(w){switch(w){case O.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case O.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case O.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Yo(w){return`(${w.x}, ${w.y})`}function xo(w){return`(${w.r}, ${w.g}, ${w.b})`}function wH(w,o,H,E,e,D){const t=w.getInternalTexture().uniqueId+"_"+w.invertY;e[t]=w;const X=w.coordinatesIndex>0?"st"+w.coordinatesIndex:"st",L=new h.Vector2(w.uScale,w.vScale),A=new h.Vector2(w.uOffset,w.vOffset),y=w.wAng,z=Math.sin(y),C=Math.cos(y);return A.y=1-A.y-L.y,A.x+=z*L.x,A.y+=(1-C)*L.y,`\n    def Shader "PrimvarReader_${H}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${X}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${H}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${o.uniqueId}/PrimvarReader_${H}.outputs:result>\n        float inputs:rotation = ${(y*(180/Math.PI)).toFixed(D.precision)}\n        float2 inputs:scale = ${Yo(L)}\n        float2 inputs:translation = ${Yo(A)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${w.uniqueId}_${H}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${t}.png@\n        float2 inputs:st.connect = </Materials/Material_${o.uniqueId}/Transform2d_${H}.outputs:result>\n        ${E?"float4 inputs:scale = "+function(w){return`(${w.r}, ${w.g}, ${w.b}, 1.0)`}(E):""}\n        token inputs:sourceColorSpace = "${w.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${mH(w.wrapU)}"\n        token inputs:wrapT = "${mH(w.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${o.needAlphaBlending()?"float outputs:a":""}\n    }`}function oH(w,o,H){const h="\t\t\t",E=[],e=[],{diffuseMap:D,Ze:t,alphaCutOff:X,emissiveMap:L,emissive:A,normalMap:y,roughnessMap:z,roughnessChannel:C,roughness:Q,metalnessMap:M,metalnessChannel:s,metalness:V,aoMap:r,aoMapChannel:k,aoMapIntensity:P,alphaMap:l,ior:O,clearCoatEnabled:T,clearCoat:S,clearCoatMap:c,clearCoatRoughness:W,clearCoatRoughnessMap:B}=function(w){const o={diffuseMap:null,Ze:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return w instanceof Mw.ro?{...o,diffuseMap:w.diffuseTexture,Ze:w.diffuseColor,alphaCutOff:w.alphaCutOff,emissiveMap:w.emissiveTexture,emissive:w.emissiveColor,roughness:1,alphaMap:w.opacityTexture}:w instanceof Lo.e?{...o,diffuseMap:w._albedoTexture,Ze:w._albedoColor,alphaCutOff:w._alphaCutOff,emissiveMap:w._emissiveTexture,emissive:w._emissiveColor,normalMap:w._bumpTexture,roughnessMap:w._metallicTexture,roughnessChannel:w._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:w._roughness??1,metalnessMap:w._metallicTexture,metalnessChannel:w._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:w._metallic??0,aoMap:w._ambientTexture,aoMapChannel:w._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:w._ambientTextureStrength,alphaMap:w._opacityTexture,ior:w.subSurface.indexOfRefraction,clearCoatEnabled:w.clearCoat.isEnabled,clearCoat:w.clearCoat.Ue,clearCoatMap:w.clearCoat.texture,clearCoatRoughness:w.clearCoat.roughness,clearCoatRoughnessMap:w.clearCoat.useRoughnessFromMainTexture?w.clearCoat.texture:w.clearCoat.textureRoughness}:o}(w);return null!==D?(E.push(`${h}color3f inputs:diffuseColor.connect = </Materials/Material_${w.uniqueId}/Texture_${D.uniqueId}_diffuse.outputs:rgb>`),w.needAlphaBlending()?E.push(`${h}float inputs:opacity.connect = </Materials/Material_${w.uniqueId}/Texture_${D.uniqueId}_diffuse.outputs:a>`):w.needAlphaTesting()&&(E.push(`${h}float inputs:opacity.connect = </Materials/Material_${w.uniqueId}/Texture_${D.uniqueId}_diffuse.outputs:a>`),E.push(`${h}float inputs:opacityThreshold = ${X}`)),e.push(wH(D,w,"diffuse",t,o,H))):E.push(`${h}color3f inputs:diffuseColor = ${xo(t||i.ko.White())}`),null!==L?(E.push(`${h}color3f inputs:emissiveColor.connect = </Materials/Material_${w.uniqueId}/Texture_${L.uniqueId}_emissive.outputs:rgb>`),e.push(wH(L,w,"emissive",A,o,H))):A&&A.toLuminance()>0&&E.push(`${h}color3f inputs:emissiveColor = ${xo(A)}`),null!==y&&(E.push(`${h}normal3f inputs:normal.connect = </Materials/Material_${w.uniqueId}/Texture_${y.uniqueId}_normal.outputs:rgb>`),e.push(wH(y,w,"normal",null,o,H))),null!==r&&(E.push(`${h}float inputs:occlusion.connect = </Materials/Material_${w.uniqueId}/Texture_${r.uniqueId}_occlusion.outputs:${k}>`),e.push(wH(r,w,"occlusion",new i.ko(P,P,P),o,H))),null!==z?(E.push(`${h}float inputs:roughness.connect = </Materials/Material_${w.uniqueId}/Texture_${z.uniqueId}_roughness.outputs:${C}>`),e.push(wH(z,w,"roughness",new i.ko(Q,Q,Q),o,H))):E.push(`${h}float inputs:roughness = ${Q}`),null!==M?(E.push(`${h}float inputs:metallic.connect = </Materials/Material_${w.uniqueId}/Texture_${M.uniqueId}_metallic.outputs:${s}>`),e.push(wH(M,w,"metallic",new i.ko(V,V,V),o,H))):E.push(`${h}float inputs:metallic = ${V}`),null!==l?(E.push(`${h}float inputs:opacity.connect = </Materials/Material_${w.uniqueId}/Texture_${l.uniqueId}_opacity.outputs:r>`),E.push(`${h}float inputs:opacityThreshold = 0.0001`),e.push(wH(l,w,"opacity",null,o,H))):E.push(`${h}float inputs:opacity = ${w.alpha}`),T&&(null!==c?(E.push(`${h}float inputs:clearcoat.connect = </Materials/Material_${w.uniqueId}/Texture_${c.uniqueId}_clearcoat.outputs:r>`),e.push(wH(c,w,"clearcoat",new i.ko(S,S,S),o,H))):E.push(`${h}float inputs:clearcoat = ${S}`),null!==B?(E.push(`${h}float inputs:clearcoatRoughness.connect = </Materials/Material_${w.uniqueId}/Texture_${B.uniqueId}_clearcoatRoughness.outputs:g>`),e.push(wH(B,w,"clearcoatRoughness",new i.ko(W,W,W),o,H))):E.push(`${h}float inputs:clearcoatRoughness = ${W}`)),E.push(`${h}float inputs:ior = ${O}`),`\n\tdef Material "Material_${w.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${E.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${w.uniqueId}/PreviewSurface.outputs:surface>\n\n${e.join("\n")}\n\n\t}\n`}async function HH(w,o,H){const e={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...o};"undefined"===typeof fflate&&await E.Tools.LoadScriptAsync(e.fflateUrl);const D={};D[e.modelFileName]=null;let t='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';t+=function(w){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===w.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${w.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${w.planeAnchoringAlignment}"`:""}\n            `}(e);const X={};for(const h of w.meshes){if(0===h.getTotalVertices())continue;const w=h,o=w.re,L=w.material;if(!L||!o||H&&!H(w))continue;if(-1!==["ro","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(L.getClassName())){const H="geometries/Geometry_"+o.uniqueId+".usda";if(!(H in D)){const w=Uo(o,e);D[H]=Zo(w)}L.uniqueId in X||(X[L.uniqueId]=L),t+=vo(w)}else E.Tools.Warn("USDZExportAsync does not support this material type: "+L.getClassName())}w.activeCamera&&e.exportCamera&&(t+=function(w,o){const H="Camera_"+w.uniqueId,E=Ko(h.Matrix.RotationY(Math.PI).multiply(w.getWorldMatrix()));if(w.mode===O.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${H}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${w.Qe.toPrecision(o.precision)}, ${w.maxZ.toPrecision(o.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(w.orthoLeft||1)+Math.abs(w.orthoRight||1))).toPrecision(o.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(w.orthoTop||1)+Math.abs(w.orthoBottom||1))).toPrecision(o.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const h=w.getEngine().getAspectRatio(w),e=o.cameraSensorWidth||35;return`def Camera "${H}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${w.Qe.toPrecision(o.precision)}, ${w.maxZ.toPrecision(o.precision)})\n\t\t\tfloat focalLength = ${(e/(2*Math.tan(.5*w.fov))).toPrecision(o.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(e*h).toPrecision(o.precision)}\n\t\t\tfloat verticalAperture = ${(e/h).toPrecision(o.precision)}            \n\t\t}\n\t\n\t`}}(w.activeCamera,e)),t+="\n            }\n        }\n    }";const L={};t+=function(w,o,H){const h=[];for(const E in w){const e=w[E];h.push(oH(e,o,H))}return`\n    def "Materials"\n{\n${h.join("")}\n}\n\n`}(X,L,e),D[e.modelFileName]=fflate.strToU8(t);for(const h in L){const w=L[h],o=w.getSize(),H=await w.readPixels();if(!H)throw new Error("Texture data is not available");const E=await T.DumpTools.DumpDataAsync(o.width,o.height,H,"image/png",void 0,!1,!0);D[`textures/Texture_${h}.png`]=new Uint8Array(E).slice()}let A=0;for(const h in D){const w=D[h];if(!w)continue;A+=34+h.length;const o=63&A;if(4!==o){const H=new Uint8Array(64-o);D[h]=[w,{extra:{12345:H}}]}A=w.length}return fflate.zipSync(D,{level:0})}}}]);