"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[26],{13284:(Y,c,h)=>{h.r(c),h.d(c,{EXT_materials_diffuse_roughness:()=>gc,EXT_mesh_gpu_instancing:()=>BY,GLTF2Export:()=>iY,GLTFData:()=>w,KHR_draco_mesh_compression:()=>hc,KHR_lights_punctual:()=>Hc,KHR_materials_anisotropy:()=>qc,KHR_materials_clearcoat:()=>Mc,KHR_materials_diffuse_transmission:()=>yc,KHR_materials_dispersion:()=>Dc,KHR_materials_emissive_strength:()=>ec,KHR_materials_ior:()=>Xc,KHR_materials_iridescence:()=>ac,KHR_materials_sheen:()=>Kc,KHR_materials_specular:()=>sc,KHR_materials_transmission:()=>Ac,KHR_materials_unlit:()=>Uc,KHR_materials_volume:()=>nc,KHR_texture_transform:()=>Oc,OBJExport:()=>Q,STLExport:()=>oc,USDZExportAsync:()=>ch,_ConvertToGLTFPBRMetallicRoughness:()=>V,_SolveMetallic:()=>A,__IGLTFExporterExtension:()=>b});var C=h(12869),E=h(12687),N=h(13193);class Q{static OBJ(Y,c,h,Q){const b=[];let H=1,w=1;c&&(h||(h="mat"),b.push("mtllib "+h+".mtl"));for(let W=0;W<Y.length;W++){const h=Y[W],q=h.name||`mesh${W}}`;b.push(`o ${q}`);let k=null;if(Q){const Y=h.Kc(!0);k=new C.Matrix,Y.invertToRef(k),h.bakeTransformIntoVertices(Y)}if(c){const Y=h.material;Y&&b.push("usemtl "+Y.id)}const M=h.Ic;if(!M){E.Tools.Warn("No geometry is present on the mesh");continue}const p=M.getVerticesData("position"),P=M.getVerticesData("normal"),y=M.getVerticesData("uv"),d=M.sc();let D=0,T=0;if(!p||!d){E.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const e=Y[0].ZY().useRightHandedSystem?1:-1;for(let Y=0;Y<p.length;Y+=3)b.push("v "+p[Y]*e+" "+p[Y+1]+" "+p[Y+2]),D++;if(null!=P)for(let Y=0;Y<P.length;Y+=3)b.push("vn "+P[Y]*e+" "+P[Y+1]+" "+P[Y+2]);if(null!=y)for(let Y=0;Y<y.length;Y+=2)b.push("vt "+y[Y]+" "+y[Y+1]),T++;const r=["","",""],X=(h.material||h.ZY().defaultMaterial)._getEffectiveOrientation(h),[Z,a]=X===N.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let Y=0;Y<d.length;Y+=3){const c=[String(d[Y]+H),String(d[Y+Z]+H),String(d[Y+a]+H)],h=[String(d[Y]+w),String(d[Y+Z]+w),String(d[Y+a]+w)],C=c,E=null!=y?h:r,N=null!=P?c:r;b.push("f "+C[0]+"/"+E[0]+"/"+N[0]+" "+C[1]+"/"+E[1]+"/"+N[1]+" "+C[2]+"/"+E[2]+"/"+N[2])}Q&&k&&h.bakeTransformIntoVertices(k),H+=D,w+=T}return b.join("\n")}static MTL(Y){const c=[],h=Y.material;c.push("newmtl mat1"),c.push("  Ns "+h.specularPower.toFixed(4)),c.push("  Ni 1.5000"),c.push("  d "+h.alpha.toFixed(4)),c.push("  Tr 0.0000"),c.push("  Tf 1.0000 1.0000 1.0000"),c.push("  illum 2"),c.push("  Ka "+h.ambientColor.r.toFixed(4)+" "+h.ambientColor.g.toFixed(4)+" "+h.ambientColor.b.toFixed(4)),c.push("  Kd "+h.diffuseColor.r.toFixed(4)+" "+h.diffuseColor.g.toFixed(4)+" "+h.diffuseColor.b.toFixed(4)),c.push("  Ks "+h.specularColor.r.toFixed(4)+" "+h.specularColor.g.toFixed(4)+" "+h.specularColor.b.toFixed(4)),c.push("  Ke "+h.emissiveColor.r.toFixed(4)+" "+h.emissiveColor.g.toFixed(4)+" "+h.emissiveColor.b.toFixed(4));h.ambientTexture&&c.push("  map_Ka "+h.ambientTexture.name),h.diffuseTexture&&c.push("  map_Kd "+h.diffuseTexture.name),h.specularTexture&&c.push("  map_Ks "+h.specularTexture.name),h.bumpTexture&&c.push("  map_bump -imfchan z "+h.bumpTexture.name),h.opacityTexture&&c.push("  map_d "+h.opacityTexture.name);return c.join("\n")}}var b=0,H=h(12728);class w{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const Y in this.files){const c=this.files[Y],h=new Blob([c],{type:(0,H.i)(Y)});E.Tools.Download(h,Y)}}}var W=h(12951),q=h(13289),k=h(13303),M=h(13319),p=h(13006),P=h(12722),y=h(12920),d=h(12883);const D=d.HighestCommonFactor,T={...d,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:D};var e=h(13102),r=h(12848),X=h(13346),Z=h(13349),a=h(13097);const G=1e-6,K=new y.ph(.04,.04,.04),I=1024,s=y.ph.White(),x=y.ph.Black();function A(Y,c,h){if(c<K.r)return 0;const C=K.r,E=Y*h/(1-K.r)+c-2*K.r,N=E*E-4*C*(K.r-c);return T.Clamp((-E+Math.sqrt(N))/(2*C),0,1)}function V(Y){const c=Y.diffuseColor.toLinearSpace(Y.ZY().getEngine().useExactSrgbConversions).scale(.5),h=Y.alpha,E=function(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new C.Vector2(0,1),h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new C.Vector2(0,.1),E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new C.Vector2(0,.1),N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new C.Vector2(1300,.1);return function(Y,c,h,C,E){return(1-Y)*(1-Y)*(1-Y)*c+3*(1-Y)*(1-Y)*Y*h+3*(1-Y)*Y*Y*C+Y*Y*Y*E}(Math.pow(Y/N.x,.333333),c.y,h.y,E.y,N.y)}(T.Clamp(Y.specularPower,0,I));return{baseColorFactor:[c.r,c.g,c.b,h],metallicFactor:0,roughnessFactor:E}}function U(Y,c){c.needAlphaBlending()?Y.alphaMode="BLEND":c.needAlphaTesting()&&(Y.alphaMode="MASK",Y.alphaCutoff=c.alphaCutOff)}function l(Y,c,h){const C=new Uint8Array(Y*c*4);for(let E=0;E<C.length;E+=4)C[E]=C[E+1]=C[E+2]=C[E+3]=255;return X.b.CreateRGBATexture(C,Y,c,h)}function n(Y){if(Y instanceof Uint8Array){const c=Y.length,h=new Float32Array(Y.length);for(let C=0;C<c;++C)h[C]=Y[C]/255;return h}if(Y instanceof Float32Array)return Y;throw new Error("Unsupported pixel format!")}class v{constructor(Y){this._exporter=Y,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(Y){return Y?this._textureMap.get(Y)??null:null}async exportStandardMaterialAsync(Y,c,h){const C=V(Y),N={name:Y.name};if(null==Y.Ac||Y.Ac||(Y.twoSidedLighting||E.Tools.Warn(Y.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),N.doubleSided=!0),h){const h=[],E=Y.diffuseTexture;E&&h.push(this.exportTextureAsync(E,c).then((Y=>{Y&&(C.baseColorTexture=Y)})));const Q=Y.bumpTexture;Q&&h.push(this.exportTextureAsync(Q,c).then((Y=>{Y&&(N.normalTexture=Y,1!==Q.level&&(N.normalTexture.scale=Q.level))})));const b=Y.emissiveTexture;b&&(N.emissiveFactor=[1,1,1],h.push(this.exportTextureAsync(b,c).then((Y=>{Y&&(N.emissiveTexture=Y)}))));const H=Y.ambientTexture;H&&h.push(this.exportTextureAsync(H,c).then((Y=>{if(Y){const c={index:Y.index};N.occlusionTexture=c}}))),h.length>0&&(this._exporter._materialNeedsUVsSet.add(Y),await Promise.all(h))}(Y.alpha<1||Y.opacityTexture)&&(Y.alphaMode===Z.e.ALPHA_COMBINE?N.alphaMode="BLEND":E.Tools.Warn(Y.name+": glTF 2.0 does not support alpha mode: "+Y.alphaMode.toString())),Y.emissiveColor&&!Y.emissiveColor.equalsWithEpsilon(x,G)&&(N.emissiveFactor=Y.emissiveColor.Xc()),N.pbrMetallicRoughness=C,U(N,Y),await this._finishMaterialAsync(N,Y,c);const Q=this._exporter._materials;return Q.push(N),Q.length-1}async _finishMaterialAsync(Y,c,h){const C=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",Y,c),E=[];for(const N of C)E.push(this.exportTextureAsync(N,h));await Promise.all(E),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",Y,c)}async _getImageDataAsync(Y,c,C,E){const N=Z.e.TEXTURETYPE_UNSIGNED_BYTE,Q=this._exporter._babylonScene,b=Q.getEngine(),H=b.createRawTexture(Y,c,C,Z.e.TEXTUREFORMAT_RGBA,!1,!0,r.d.NEAREST_SAMPLINGMODE,null,N);b.isWebGPU?await h.e(51).then(h.bind(h,15442)):await h.e(52).then(h.bind(h,15450)),await e.j.ApplyPostProcess("pass",H,Q,N,Z.e.TEXTURE_NEAREST_SAMPLINGMODE,Z.e.TEXTUREFORMAT_RGBA);const w=await b._readTexturePixels(H,c,C);return await a.DumpTools.DumpDataAsync(c,C,w,E,void 0,!0,!0)}_resizeTexturesToSameDimensions(Y,c,h){const C=Y?Y.getSize():{width:0,height:0},E=c?c.getSize():{width:0,height:0};let N,Q;return C.width<E.width?(N=Y&&Y instanceof r.d?e.j.CreateResizedCopy(Y,E.width,E.height,!0):l(E.width,E.height,h),Q=c):C.width>E.width?(Q=c&&c instanceof r.d?e.j.CreateResizedCopy(c,C.width,C.height,!0):l(C.width,C.height,h),N=Y):(N=Y,Q=c),{texture1:N,texture2:Q}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Y,c,h,C){const E=new Array;if(!Y&&!c)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const N=Y?Y.ZY():c?c.ZY():null;if(N){var Q;const b=this._resizeTexturesToSameDimensions(Y,c,N),H=null===(Q=b.texture1)||void 0===Q?void 0:Q.getSize();let w,W;const q=H.width,k=H.height,M=await b.texture1.readPixels(),p=await b.texture2.readPixels();if(!M)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(w=n(M),!p)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");W=n(p);const P=W.byteLength,d=new Uint8Array(P),D=new Uint8Array(P),T=4,e=x;let r=0,X=0;for(let Y=0;Y<k;++Y)for(let c=0;c<q;++c){const C=(q*Y+c)*T,E={diffuseColor:new y.ph(w[C],w[C+1],w[C+2]).toLinearSpace(N.getEngine().useExactSrgbConversions).multiply(h.diffuseColor),specularColor:new y.ph(W[C],W[C+1],W[C+2]).toLinearSpace(N.getEngine().useExactSrgbConversions).multiply(h.specularColor),glossiness:W[C+3]*h.glossiness},Q=this._convertSpecularGlossinessToMetallicRoughness(E);e.r=Math.max(e.r,Q.baseColor.r),e.g=Math.max(e.g,Q.baseColor.g),e.b=Math.max(e.b,Q.baseColor.b),r=Math.max(r,Q.metallic),X=Math.max(X,Q.roughness),D[C]=255*Q.baseColor.r,D[C+1]=255*Q.baseColor.g,D[C+2]=255*Q.baseColor.b,D[C+3]=b.texture1.Zc?255*w[C+3]:255,d[C]=0,d[C+1]=255*Q.roughness,d[C+2]=255*Q.metallic,d[C+3]=255}const Z={baseColor:e,metallic:r,roughness:X};let a=!1,K=!1;for(let Y=0;Y<k;++Y)for(let c=0;c<q;++c){const h=(q*Y+c)*T;D[h]/=Z.baseColor.r>G?Z.baseColor.r:1,D[h+1]/=Z.baseColor.g>G?Z.baseColor.g:1,D[h+2]/=Z.baseColor.b>G?Z.baseColor.b:1;const C=y.ph.FromInts(D[h],D[h+1],D[h+2]).toGammaSpace(N.getEngine().useExactSrgbConversions);D[h]=255*C.r,D[h+1]=255*C.g,D[h+2]=255*C.b,C.equalsWithEpsilon(s,G)||(K=!0),d[h+1]/=Z.roughness>G?Z.roughness:1,d[h+2]/=Z.metallic>G?Z.metallic:1;y.ph.FromInts(255,d[h+1],d[h+2]).equalsWithEpsilon(s,G)||(a=!0)}return a&&E.push(this._getImageDataAsync(d,q,k,C).then((Y=>{Z.metallicRoughnessTextureData=Y}))),K&&E.push(this._getImageDataAsync(D,q,k,C).then((Y=>{Z.baseColorTextureData=Y}))),await Promise.all(E).then((()=>Z))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(Y){const c=this._getPerceivedBrightness(Y.diffuseColor),h=this._getPerceivedBrightness(Y.specularColor),C=1-this._getMaxComponent(Y.specularColor),E=A(c,h,C),N=Y.diffuseColor.scale(C/(1-K.r)/Math.max(1-E)),Q=Y.specularColor.Hh(K.scale(1-E)).scale(1/Math.max(E));let b=y.ph.Lerp(N,Q,E*E);b=b.clampToRef(0,1,b);return{baseColor:b,metallic:E,roughness:1-Y.glossiness}}_getPerceivedBrightness(Y){return Y?Math.sqrt(.299*Y.r*Y.r+.587*Y.g*Y.g+.114*Y.b*Y.b):0}_getMaxComponent(Y){return Y?Math.max(Y.r,Math.max(Y.g,Y.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(Y,c,h,C){const E=[],N={baseColor:Y._albedoColor,metallic:Y._metallic,roughness:Y._roughness};if(C){Y._albedoTexture&&E.push(this.exportTextureAsync(Y._albedoTexture,c).then((Y=>{Y&&(h.baseColorTexture=Y)})));const C=Y._metallicTexture;C&&E.push(this.exportTextureAsync(C,c).then((Y=>{Y&&(h.metallicRoughnessTexture=Y)})))}return E.length>0&&(this._exporter._materialNeedsUVsSet.add(Y),await Promise.all(E)),N}_getTextureSampler(Y){const c={};if(!Y||!(Y instanceof r.d))return c;const h=this._getGLTFTextureWrapMode(Y.wrapU);10497!==h&&(c.wrapS=h);const C=this._getGLTFTextureWrapMode(Y.wrapV);switch(10497!==C&&(c.wrapT=C),Y.samplingMode){case r.d.LINEAR_LINEAR:c.magFilter=9729,c.minFilter=9729;break;case r.d.LINEAR_NEAREST:c.magFilter=9729,c.minFilter=9728;break;case r.d.NEAREST_LINEAR:c.magFilter=9728,c.minFilter=9729;break;case r.d.NEAREST_LINEAR_MIPLINEAR:c.magFilter=9728,c.minFilter=9987;break;case r.d.NEAREST_NEAREST:c.magFilter=9728,c.minFilter=9728;break;case r.d.NEAREST_LINEAR_MIPNEAREST:c.magFilter=9728,c.minFilter=9985;break;case r.d.LINEAR_NEAREST_MIPNEAREST:c.magFilter=9729,c.minFilter=9984;break;case r.d.LINEAR_NEAREST_MIPLINEAR:c.magFilter=9729,c.minFilter=9986;break;case r.d.NEAREST_NEAREST_MIPLINEAR:c.magFilter=9728,c.minFilter=9986;break;case r.d.LINEAR_LINEAR_MIPLINEAR:c.magFilter=9729,c.minFilter=9987;break;case r.d.LINEAR_LINEAR_MIPNEAREST:c.magFilter=9729,c.minFilter=9985;break;case r.d.NEAREST_NEAREST_MIPNEAREST:c.magFilter=9728,c.minFilter=9984}return c}_getGLTFTextureWrapMode(Y){switch(Y){case r.d.WRAP_ADDRESSMODE:return 10497;case r.d.CLAMP_ADDRESSMODE:return 33071;case r.d.MIRROR_ADDRESSMODE:return 33648;default:return E.Tools.Error(`Unsupported Texture Wrap Mode ${Y}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(Y,c,h,C){const E={diffuseColor:Y._albedoColor,specularColor:Y._reflectivityColor,glossiness:Y._microSurface},N=Y._albedoTexture,Q=Y._reflectivityTexture,b=Y._useMicroSurfaceFromReflectivityMapAlpha;if(Q&&!b)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((N||Q)&&C){this._exporter._materialNeedsUVsSet.add(Y);const C=this._exportTextureSampler(N||Q),b=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(N,Q,E,c),H=this._exporter._textures;if(b.baseColorTextureData){const Y=this._exportImage(`baseColor${H.length}`,c,b.baseColorTextureData);h.baseColorTexture=this._exportTextureInfo(Y,C,null===N||void 0===N?void 0:N.coordinatesIndex)}if(b.metallicRoughnessTextureData){const Y=this._exportImage(`metallicRoughness${H.length}`,c,b.metallicRoughnessTextureData);h.metallicRoughnessTexture=this._exportTextureInfo(Y,C,null===Q||void 0===Q?void 0:Q.coordinatesIndex)}return b}return this._convertSpecularGlossinessToMetallicRoughness(E)}async exportPBRMaterialAsync(Y,c,h){const C={},E={name:Y.name},N=Y.isMetallicWorkflow();if(N){const c=Y._albedoColor,h=Y.alpha;c&&(C.baseColorFactor=[c.r,c.g,c.b,h])}const Q=N?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(Y,c,C,h):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(Y,c,C,h);await this._setMetallicRoughnessPbrMaterialAsync(Q,Y,E,C,c,h),await this._finishMaterialAsync(E,Y,c);const b=this._exporter._materials;return b.push(E),b.length-1}async _setMetallicRoughnessPbrMaterialAsync(Y,c,h,C,N,Q){if(U(h,c),Y.baseColor.equalsWithEpsilon(s,G)&&T.WithinEpsilon(c.alpha,1,G)||(C.baseColorFactor=[Y.baseColor.r,Y.baseColor.g,Y.baseColor.b,c.alpha]),null!=Y.metallic&&1!==Y.metallic&&(C.metallicFactor=Y.metallic),null!=Y.roughness&&1!==Y.roughness&&(C.roughnessFactor=Y.roughness),null==c.Ac||c.Ac||(c._twoSidedLighting||E.Tools.Warn(c.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),h.doubleSided=!0),Q){const Y=[],C=c._bumpTexture;C&&Y.push(this.exportTextureAsync(C,N).then((Y=>{Y&&(h.normalTexture=Y,1!==C.level&&(h.normalTexture.scale=C.level))})));const E=c._ambientTexture;E&&Y.push(this.exportTextureAsync(E,N).then((Y=>{if(Y){const C={index:Y.index,texCoord:Y.texCoord,extensions:Y.extensions};h.occlusionTexture=C;const E=c._ambientTextureStrength;E&&(C.strength=E)}})));const Q=c._emissiveTexture;Q&&Y.push(this.exportTextureAsync(Q,N).then((Y=>{Y&&(h.emissiveTexture=Y)}))),Y.length>0&&(this._exporter._materialNeedsUVsSet.add(c),await Promise.all(Y))}const b=c._emissiveColor;b.equalsWithEpsilon(x,G)||(h.emissiveFactor=b.Xc()),h.pbrMetallicRoughness=C}_getPixelsFromTextureAsync(Y){return function(Y){switch(Y){case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(Y.textureFormat)?(0,e.h)(Y,Y._texture.width,Y._texture.height):(Y.textureType,Z.e.TEXTURETYPE_UNSIGNED_BYTE,Y.readPixels())}async exportTextureAsync(Y,c){const h=this._exporter._extensionsPreExportTextureAsync("exporter",Y,c);return h?await h.then((async h=>h?await this._exportTextureInfoAsync(h,c):await this._exportTextureInfoAsync(Y,c))):await this._exportTextureInfoAsync(Y,c)}async _exportTextureInfoAsync(Y,c){let h=this._textureMap.get(Y);if(!h){const C=await this._getPixelsFromTextureAsync(Y);if(!C)return null;const N=this._exportTextureSampler(Y),Q=Y.mimeType;if(Q)switch(Q){case"image/jpeg":case"image/png":case"image/webp":c=Q;break;default:E.Tools.Warn(`Unsupported media type: ${Q}. Exporting texture as PNG.`)}const b=this._internalTextureToImage,H=Y.getInternalTexture().uniqueId;b[H]||(b[H]={});let w=b[H][c];if(void 0===w){const h=Y.getSize();w=(async()=>{const E=await this._getImageDataAsync(C,h.width,h.height,c);return this._exportImage(Y.name,c,E)})(),b[H][c]=w}h=this._exportTextureInfo(await w,N,Y.coordinatesIndex),this._textureMap.set(Y,h),this._exporter._extensionsPostExportTextures("exporter",h,Y)}return h}_exportImage(Y,c,h){const C=this._exporter._images;let N;if(this._exporter._shouldUseGlb){N={name:Y,mimeType:c,bufferView:void 0};const C=this._exporter._bufferManager.createBufferView(new Uint8Array(h));this._exporter._bufferManager.setBufferView(N,C)}else{const Q=Y.replace(/\.\/|\/|\.\\|\\/g,"_"),b=function(Y){switch(Y){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(c);let H=Q+b;C.some((Y=>Y.uri===H))&&(H=`${Q}_${E.Tools.RandomId()}${b}`),N={name:Y,uri:H},this._exporter._imageData[H]={data:h,mimeType:c}}return C.push(N),C.length-1}_exportTextureInfo(Y,c,h){const C=this._exporter._textures;let E=C.findIndex((h=>h.sampler==c&&h.source===Y));-1===E&&(E=C.length,C.push({source:Y,sampler:c}));const N={index:E};return h&&(N.texCoord=h),N}_exportTextureSampler(Y){const c=this._getTextureSampler(Y),h=this._exporter._samplers,C=h.findIndex((Y=>Y.minFilter===c.minFilter&&Y.magFilter===c.magFilter&&Y.wrapS===c.wrapS&&Y.wrapT===c.wrapT));return-1!==C?C:(h.push(c),h.length-1)}}var g=h(12961),z=h(12700),O=h(13354),o=h(12874);const f=C.bh.Zero(),L=C.Quaternion.Identity(),u=C.bh.One(),i=new C.bh(-1,1,1);function R(Y,c){const{byteOffset:h,byteStride:C,type:E,normalized:N}=Y,Q=Y.getSize(),b=c.reduce(((Y,c)=>c.getTotalVertices()>Y?c.getTotalVertices():Y),-Number.MAX_VALUE);return{byteOffset:h,byteStride:C,componentCount:Q,type:E,count:b*Q,normalized:N,totalVertices:b,kind:Y.getKind()}}function B(Y){switch(Y){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function t(Y){switch(Y){case W.f.PositionKind:case W.f.NormalKind:case W.f.TangentKind:case W.f.ColorKind:case W.f.MatricesIndicesKind:case W.f.MatricesIndicesExtraKind:case W.f.MatricesWeightsKind:case W.f.MatricesWeightsExtraKind:case W.f.UVKind:case W.f.UV2Kind:case W.f.UV3Kind:case W.f.UV4Kind:case W.f.UV5Kind:case W.f.UV6Kind:return!0}return!1}function F(Y){switch(Y){case N.d.TriangleFillMode:return 4;case N.d.TriangleStripDrawMode:return 5;case N.d.TriangleFanDrawMode:return 6;case N.d.PointListDrawMode:case N.d.PointFillMode:return 0;case N.d.LineLoopDrawMode:return 2;case N.d.LineListDrawMode:return 1;case N.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${Y}`)}function J(Y){const c=Math.sqrt(Y.x*Y.x+Y.y*Y.y+Y.z*Y.z);c>0&&(Y.x/=c,Y.y/=c,Y.z/=c)}function j(Y){return Y.x*=-1,Y}function S(Y){if(Y.x*Y.x+Y.y*Y.y>.5){const c=Math.abs(Y.x),h=Math.abs(Y.y);if(c>h){const h=Math.sign(Y.x);Y.x=c,Y.y*=-h,Y.z*=-h,Y.w*=h}else{const c=Math.sign(Y.y);Y.x*=-c,Y.y=h,Y.z*=c,Y.w*=-c}}else{const c=Math.abs(Y.z),h=Math.abs(Y.w);if(c>h){const h=Math.sign(Y.z);Y.x*=-h,Y.y*=h,Y.z=c,Y.w*=-h}else{const c=Math.sign(Y.w);Y.x*=c,Y.y*=-c,Y.z*=-c,Y.w=h}}return Y}function mY(Y){Y.Vc(-Y.z,Y.w,Y.x,-Y.y)}function YY(Y,c){const h=C.bh.FromArrayToRef(c.translation||[0,0,0],0,C.TmpVectors.bh[0]),E=C.Quaternion.FromArrayToRef(c.rotation||[0,0,0,1],0,C.TmpVectors.Quaternion[0]),N=C.Matrix.ComposeToRef(u,E,h,C.TmpVectors.Matrix[0]),Q=C.bh.FromArrayToRef(Y.translation||[0,0,0],0,C.TmpVectors.bh[2]),b=C.Quaternion.FromArrayToRef(Y.rotation||[0,0,0,1],0,C.TmpVectors.Quaternion[1]),H=C.Matrix.ComposeToRef(u,b,Q,C.TmpVectors.Matrix[1]);N.multiplyToRef(H,H),H.decompose(void 0,E,h),h.equalsWithEpsilon(f,o.d)?delete c.translation:c.translation=h.Xc(),E.equalsWithEpsilon(L,o.d)?delete c.rotation:c.rotation=E.Xc(),c.scale&&delete c.scale}function cY(Y,c){if(!(c instanceof q.e))return!1;if(!(1===c.getChildren().length&&0===Y.getChildren().length&&Y.parent===c))return!1;const h=Y.ZY(),C=Y instanceof O.d&&!h.useRightHandedSystem?i:u;return!!c.lc.equalsWithEpsilon(C,o.d)||(z.e.Warn(`Cannot collapse node ${Y.name} into parent node ${c.name} with modified scaling.`),!1)}function hY(Y){if(Y instanceof Array){const c=new Float32Array(Y);return new Uint8Array(c.buffer,c.byteOffset,c.byteLength)}return ArrayBuffer.isView(Y)?new Uint8Array(Y.buffer,Y.byteOffset,Y.byteLength):new Uint8Array(Y)}function CY(Y,c){for(const[h,C]of Object.entries(Y)){const E=c[h];(Array.isArray(C)&&Array.isArray(E)&&EY(C,E)||C===E)&&delete Y[h]}return Y}function EY(Y,c){return Y.length===c.length&&Y.every(((Y,h)=>Y===c[h]))}const NY=C.Matrix.Compose(new C.bh(-1,1,1),C.Quaternion.Identity(),C.bh.Zero());function QY(Y,c){if(!(Y instanceof q.e))return!1;if(c){if(!Y.getWorldMatrix().equalsWithEpsilon(C.Matrix.IdentityReadOnly,o.d))return!1}else{if(!Y.getWorldMatrix().multiplyToRef(NY,C.TmpVectors.Matrix[0]).equalsWithEpsilon(C.Matrix.IdentityReadOnly,o.d))return!1}return!(Y instanceof k.c&&Y.Ic)}const bY=new Map([[Int8Array,(Y,c,h)=>Y.setInt8(c,h)],[Uint8Array,(Y,c,h)=>Y.setUint8(c,h)],[Uint8ClampedArray,(Y,c,h)=>Y.setUint8(c,h)],[Int16Array,(Y,c,h)=>Y.setInt16(c,h,!0)],[Uint16Array,(Y,c,h)=>Y.setUint16(c,h,!0)],[Int32Array,(Y,c,h)=>Y.setInt32(c,h,!0)],[Uint32Array,(Y,c,h)=>Y.setUint32(c,h,!0)],[Float32Array,(Y,c,h)=>Y.setFloat32(c,h,!0)],[Float64Array,(Y,c,h)=>Y.setFloat64(c,h,!0)]]);class HY{writeTypedArray(Y){this._checkGrowBuffer(Y.byteLength);const c=bY.get(Y.constructor);for(let h=0;h<Y.length;h++)c(this._dataView,this._byteOffset,Y[h]),this._byteOffset+=Y.BYTES_PER_ELEMENT}constructor(Y){this._data=new Uint8Array(Y),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(Y){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,Y),this._byteOffset++}writeInt8(Y){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,Y),this._byteOffset++}writeInt16(Y){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,Y,!0),this._byteOffset+=2}writeUInt16(Y){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,Y,!0),this._byteOffset+=2}writeInt32(Y){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,Y,!0),this._byteOffset+=4}writeUInt32(Y){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,Y,!0),this._byteOffset+=4}writeFloat32(Y){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,Y,!0),this._byteOffset+=4}writeFloat64(Y){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,Y,!0),this._byteOffset+=8}_checkGrowBuffer(Y){const c=this.byteOffset+Y;if(c>this._data.byteLength){const Y=new Uint8Array(2*c);Y.set(this._data),this._data=Y,this._dataView=new DataView(this._data.buffer)}}}function wY(Y){return Y%4===0?4:Y%2===0?2:1}class WY{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(Y){let c=0;this._bufferViewToData.forEach((Y=>{c+=Y.byteLength}));const h=new HY(c),C=Array.from(this._bufferViewToData.keys()).sort(((Y,c)=>wY(c.byteLength)-wY(Y.byteLength)));for(const E of C){E.byteOffset=h.byteOffset,Y.push(E);const c=Y.length-1,C=this.getPropertiesWithBufferView(E);for(const Y of C)Y.bufferView=c;h.writeTypedArray(this._bufferViewToData.get(E)),this._bufferViewToData.delete(E)}return h.getOutputData()}createBufferView(Y,c){const h={buffer:0,byteOffset:void 0,byteLength:Y.byteLength,byteStride:c};return this._bufferViewToData.set(h,Y),h}createAccessor(Y,c,h,C,E,N,Q){this._verifyBufferView(Y);const b={bufferView:void 0,componentType:h,count:C,type:c,min:null===N||void 0===N?void 0:N.min,max:null===N||void 0===N?void 0:N.max,normalized:Q,byteOffset:E};return this.setBufferView(b,Y),this._accessorToBufferView.set(b,Y),b}setBufferView(Y,c){this._verifyBufferView(c);this.getPropertiesWithBufferView(c).push(Y)}removeBufferView(Y){const c=this.getPropertiesWithBufferView(Y);for(const h of c)void 0!==h.bufferView&&delete h.bufferView;this._bufferViewToData.delete(Y),this._bufferViewToProperties.delete(Y),this._accessorToBufferView.forEach(((c,h)=>{c===Y&&(void 0!==h.byteOffset&&delete h.byteOffset,this._accessorToBufferView.delete(h))}))}getBufferView(Y){const c=this._accessorToBufferView.get(Y);return this._verifyBufferView(c),c}getPropertiesWithBufferView(Y){return this._verifyBufferView(Y),this._bufferViewToProperties.set(Y,this._bufferViewToProperties.get(Y)??[]),this._bufferViewToProperties.get(Y)}getData(Y){return this._verifyBufferView(Y),this._bufferViewToData.get(Y)}_verifyBufferView(Y){if(void 0===Y||!this._bufferViewToData.has(Y))throw new Error(`BufferView ${Y} not found in BufferManager.`)}}var qY,kY=h(13329),MY=h(13341),pY=h(13356),PY=h(13254),yY=h(13395),dY=h(13413),DY=h(13321),TY=h(13422);!function(Y){Y[Y.INTANGENT=0]="INTANGENT",Y[Y.OUTTANGENT=1]="OUTTANGENT"}(qY||(qY={}));class eY{static _IsTransformable(Y){return Y&&(Y instanceof q.e||Y instanceof kY.b||Y instanceof TY.e)}static _CreateNodeAnimation(Y,c,h,C,N){if(this._IsTransformable(Y)){const Q=[],b=[],H=c.getKeys(),w=eY._CalculateMinMaxKeyFrames(H),W=eY._DeduceInterpolation(H,h,C),q=W.interpolationType,k=W.shouldBakeAnimation;if(k?eY._CreateBakedAnimation(Y,c,h,w.min,w.max,c.framePerSecond,N,Q,b,w,C):"LINEAR"===q||"STEP"===q?eY._CreateLinearOrStepAnimation(Y,c,h,Q,b,C):"CUBICSPLINE"===q?eY._CreateCubicSplineAnimation(Y,c,h,Q,b,C):eY._CreateBakedAnimation(Y,c,h,w.min,w.max,c.framePerSecond,N,Q,b,w,C),Q.length&&b.length){return{inputs:Q,outputs:b,samplerInterpolation:q,inputsMin:k?w.min:E.Tools.FloatRound(w.min/c.framePerSecond),inputsMax:k?w.max:E.Tools.FloatRound(w.max/c.framePerSecond)}}}return null}static _DeduceAnimationInfo(Y){let c=null,h="VEC3",C=!1;const N=Y.targetProperty.split(".");switch(N[0]){case"lc":c="scale";break;case"position":c="translation";break;case"rotation":h="VEC4",c="rotation";break;case"rotationQuaternion":h="VEC4",C=!0,c="rotation";break;case"influence":h="SCALAR",c="weights";break;default:E.Tools.Error(`Unsupported animatable property ${N[0]}`)}return c?{animationChannelTargetPath:c,dataAccessorType:h,useQuaternion:C}:(E.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(Y,c,h,C,E,N,Q,b,H,w,W){let q;if(eY._IsTransformable(Y)&&Y.animations)for(const k of Y.animations){if(W&&!W(k))continue;const E=eY._DeduceAnimationInfo(k);E&&(q={name:k.name,samplers:[],channels:[]},eY._AddAnimation(`${k.name}`,k.hasRunningRuntimeAnimations?c:q,Y,k,E.dataAccessorType,E.animationChannelTargetPath,C,N,Q,b,E.useQuaternion,H,w),q.samplers.length&&q.channels.length&&h.push(q))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(Y,c,h,C,E,N,Q,b,H,w,W){let q;if(Y instanceof DY.e){const E=Y.morphTargetManager;if(E)for(let k=0;k<E.numTargets;++k){const M=E.getTarget(k);for(const p of M.animations){if(W&&!W(p))continue;const M=new yY.d(`${p.name}`,"influence",p.framePerSecond,p.dataType,p.loopMode,p.enableBlending),P=[],y=p.getKeys();for(let Y=0;Y<y.length;++Y){const c=y[Y];for(let Y=0;Y<E.numTargets;++Y)Y==k?P.push(c):P.push({frame:c.frame,value:0})}M.setKeys(P);const d=eY._DeduceAnimationInfo(M);d&&(q={name:M.name,samplers:[],channels:[]},eY._AddAnimation(p.name,p.hasRunningRuntimeAnimations?c:q,Y,M,d.dataAccessorType,d.animationChannelTargetPath,C,N,Q,b,d.useQuaternion,H,w,E.numTargets),q.samplers.length&&q.channels.length&&h.push(q))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(Y,c,h,C,E,N,Q,b,H){let w;if(Y.animationGroups){const q=Y.animationGroups;for(const k of q){const q=new Map,M=new Map,p=new Set,P=k.to-k.from;w={name:k.name,channels:[],samplers:[]};for(let c=0;c<k.targetedAnimations.length;++c){const P=k.targetedAnimations[c],y=P.target,d=P.animation;if(H&&!H(d))continue;const D=b.has(y);if(this._IsTransformable(y)||1===y.length&&this._IsTransformable(y[0])){const Y=eY._DeduceAnimationInfo(P.animation);if(Y){const c=this._IsTransformable(y)?y:this._IsTransformable(y[0])?y[0]:null;c&&eY._AddAnimation(`${d.name}`,w,c,d,Y.dataAccessorType,Y.animationChannelTargetPath,h,C,E,N,Y.useQuaternion,Q,D)}}else if(y instanceof dY.d||1===y.length&&y[0]instanceof dY.d){if(eY._DeduceAnimationInfo(P.animation)){const c=y instanceof dY.d?y:y[0];if(c){const h=Y.morphTargetManagers.find((Y=>{for(let h=0;h<Y.numTargets;++h)if(Y.getTarget(h)===c)return!0;return!1}));if(h){const C=Y.meshes.find((Y=>Y.morphTargetManager===h));var W;if(C)q.has(C)||q.set(C,new Map),null===(W=q.get(C))||void 0===W||W.set(c,d),p.add(C),M.set(C,d)}}}}}p.forEach((Y=>{const c=Y.morphTargetManager;let b=null;const H=[],W=M.get(Y).getKeys(),p=W.length;for(let h=0;h<p;++h)for(let C=0;C<c.numTargets;++C){const E=c.getTarget(C),N=q.get(Y);if(N){const c=N.get(E);c?(b||(b=new yY.d(`${k.name}_${Y.name}_MorphWeightAnimation`,"influence",c.framePerSecond,yY.d.ANIMATIONTYPE_FLOAT,c.loopMode,c.enableBlending)),H.push(c.getKeys()[h])):H.push({frame:k.from+P/p*h,value:E.influence,inTangent:W[0].inTangent?0:void 0,outTangent:W[0].outTangent?0:void 0})}}b.setKeys(H);const y=eY._DeduceAnimationInfo(b);y&&eY._AddAnimation(`${k.name}_${Y.name}_MorphWeightAnimation`,w,Y,b,y.dataAccessorType,y.animationChannelTargetPath,h,C,E,N,y.useQuaternion,Q,!1,null===c||void 0===c?void 0:c.numTargets)})),w.channels.length&&w.samplers.length&&c.push(w)}}}static _AddAnimation(Y,c,h,E,N,Q,b,H,w,W,q,k,M,p){const P=eY._CreateNodeAnimation(h,E,Q,q,k);let y,d,D,T,e,r;if(P){if(p){let Y=0,c=0;const h=[];for(;P.inputs.length>0;)c=P.inputs.shift(),Y%p==0&&h.push(c),Y++;P.inputs=h}const Y=b.get(h),E=new Float32Array(P.inputs);y=H.createBufferView(E),d=H.createAccessor(y,"SCALAR",5126,P.inputs.length,void 0,{min:[P.inputsMin],max:[P.inputsMax]}),W.push(d),D=W.length-1;const w=new C.Quaternion,q=new C.bh,k=new C.bh,X=h instanceof kY.b,Z=B(N),a=new Float32Array(P.outputs.length*Z);P.outputs.forEach((function(Y,c){let h=Y;switch(Q){case"translation":M&&(C.bh.FromArrayToRef(Y,0,k),j(k),k.toArray(h));break;case"rotation":4===Y.length?C.Quaternion.FromArrayToRef(Y,0,w):(h=new Array(4),C.bh.FromArrayToRef(Y,0,q),C.Quaternion.FromEulerVectorToRef(q,w)),M&&(S(w),X&&mY(w)),w.toArray(h)}a.set(h,c*Z)})),y=H.createBufferView(a),d=H.createAccessor(y,N,5126,P.outputs.length),W.push(d),T=W.length-1,e={interpolation:P.samplerInterpolation,input:D,output:T},c.samplers.push(e),r={sampler:c.samplers.length-1,target:{node:Y,path:Q}},c.channels.push(r)}}static _CreateBakedAnimation(Y,c,h,N,Q,b,H,w,W,q,k){let M;const p=C.Quaternion.Identity();let P,y=null,d=null,D=null,T=null,e=null,r=null;q.min=E.Tools.FloatRound(N/b);const X=c.getKeys();for(let C=0,Z=X.length;C<Z;++C){if(r=null,D=X[C],C+1<Z)if(T=X[C+1],D.value.equals&&D.value.equals(T.value)||D.value===T.value){if(0!==C)continue;r=D.frame}else r=T.frame;else{if(e=X[C-1],D.value.equals&&D.value.equals(e.value)||D.value===e.value)continue;r=Q}if(r)for(let C=D.frame;C<=r;C+=H){if(P=E.Tools.FloatRound(C/b),P===y)continue;y=P,d=P;const N={key:0,repeatCount:0,loopMode:c.loopMode};M=c._interpolate(C,N),eY._SetInterpolatedValue(Y,M,P,c,h,p,w,W,k)}}d&&(q.max=d)}static _ConvertFactorToVector3OrQuaternion(Y,c,h,N,Q){const b=eY._GetBasePositionRotationOrScale(c,N,Q),H=h.targetProperty.split("."),w=H?H[1]:"",W=Q?C.Quaternion.dh(b).normalize():C.bh.dh(b);switch(w){case"x":case"y":case"z":W[w]=Y;break;case"w":W.w=Y;break;default:E.Tools.Error(`glTFAnimation: Unsupported component name "${w}"!`)}return W}static _SetInterpolatedValue(Y,c,h,E,N,Q,b,H,w){let W;b.push(h),"weights"!==N?(E.dataType===yY.d.ANIMATIONTYPE_FLOAT&&(c=this._ConvertFactorToVector3OrQuaternion(c,Y,E,N,w)),"rotation"===N?(w?Q=c:(W=c,C.Quaternion.RotationYawPitchRollToRef(W.y,W.x,W.z,Q)),H.push(Q.Xc())):(W=c,H.push(W.Xc()))):H.push([c])}static _CreateLinearOrStepAnimation(Y,c,h,C,E,N){for(const Q of c.getKeys())C.push(Q.frame/c.framePerSecond),eY._AddKeyframeValue(Q,c,E,h,Y,N)}static _CreateCubicSplineAnimation(Y,c,h,C,E,N){c.getKeys().forEach((function(Q){C.push(Q.frame/c.framePerSecond),eY._AddSplineTangent(qY.INTANGENT,E,h,"CUBICSPLINE",Q,N),eY._AddKeyframeValue(Q,c,E,h,Y,N),eY._AddSplineTangent(qY.OUTTANGENT,E,h,"CUBICSPLINE",Q,N)}))}static _GetBasePositionRotationOrScale(Y,c,h){let E;if("rotation"===c)if(h){E=(Y.rotationQuaternion??C.Quaternion.Identity()).Xc()}else{E=(Y.rotation??C.bh.Zero()).Xc()}else if("translation"===c){E=(Y.position??C.bh.Zero()).Xc()}else{E=(Y.lc??C.bh.One()).Xc()}return E}static _AddKeyframeValue(Y,c,h,N,Q,b){let H;const w=c.dataType;if(w===yY.d.ANIMATIONTYPE_VECTOR3){let c=Y.value.Xc();if("rotation"===N){const Y=C.bh.dh(c);c=C.Quaternion.RotationYawPitchRoll(Y.y,Y.x,Y.z).Xc()}h.push(c)}else if(w===yY.d.ANIMATIONTYPE_FLOAT){if("weights"===N)h.push([Y.value]);else if(H=this._ConvertFactorToVector3OrQuaternion(Y.value,Q,c,N,b),H){if("rotation"===N){const Y=b?H:C.Quaternion.RotationYawPitchRoll(H.y,H.x,H.z).normalize();h.push(Y.Xc())}h.push(H.Xc())}}else w===yY.d.ANIMATIONTYPE_QUATERNION?h.push(Y.value.normalize().Xc()):E.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(Y,c,h){let C,E,N=!1;if("rotation"===c&&!h)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let Q=0,b=Y.length;Q<b;++Q)if(E=Y[Q],E.inTangent||E.outTangent)if(C){if("CUBICSPLINE"!==C){C="LINEAR",N=!0;break}}else C="CUBICSPLINE";else if(C){if("CUBICSPLINE"===C||E.interpolation&&1===E.interpolation&&"STEP"!==C){C="LINEAR",N=!0;break}}else C=E.interpolation&&1===E.interpolation?"STEP":"LINEAR";return C||(C="LINEAR"),{interpolationType:C,shouldBakeAnimation:N}}static _AddSplineTangent(Y,c,h,E,N,Q){let b;const H=Y===qY.INTANGENT?N.inTangent:N.outTangent;if("CUBICSPLINE"===E){if("rotation"===h)if(H)if(Q)b=H.Xc();else{const Y=H;b=C.Quaternion.RotationYawPitchRoll(Y.y,Y.x,Y.z).Xc()}else b=[0,0,0,0];else b="weights"===h?H?[H]:[0]:H?H.Xc():[0,0,0];c.push(b)}}static _CalculateMinMaxKeyFrames(Y){let c=1/0,h=-1/0;return Y.forEach((function(Y){c=Math.min(c,Y.frame),h=Math.max(h,Y.frame)})),{min:c,max:h}}}function rY(Y,c,h,N,Q,b){const H={attributes:{},influence:Y.influence,name:Y.name},w=c.Ic;if(!w)return E.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),H;const q=b?-1:1,k=C.bh.Zero();let M=0,p=0;if(Y.hasPositions){const N=Y.getPositions(),b=w.getVerticesData(W.f.PositionKind);if(b){const Y=new Float32Array(b.length),c=[1/0,1/0,1/0],E=[-1/0,-1/0,-1/0];p=b.length/3,M=0;for(let h=M;h<p;++h){const Q=C.bh.dh(b,3*h);C.bh.dh(N,3*h).subtractToRef(Q,k),k.x*=q,c[0]=Math.min(c[0],k.x),E[0]=Math.max(E[0],k.x),c[1]=Math.min(c[1],k.y),E[1]=Math.max(E[1],k.y),c[2]=Math.min(c[2],k.z),E[2]=Math.max(E[2],k.z),Y[3*h]=k.x,Y[3*h+1]=k.y,Y[3*h+2]=k.z}const w=h.createBufferView(Y,12),W=h.createAccessor(w,"VEC3",5126,N.length/3,0,{min:c,max:E});Q.push(W),H.attributes.POSITION=Q.length-1}else E.Tools.Warn(`Morph target positions for mesh ${c.name} were not exported. Mesh does not have position vertex data`)}if(Y.hasNormals){const N=Y.getNormals(),b=w.getVerticesData(W.f.NormalKind);if(b){const Y=new Float32Array(b.length);p=b.length/3,M=0;for(let h=M;h<p;++h){const c=C.bh.dh(b,3*h).normalize();C.bh.dh(N,3*h).normalize().subtractToRef(c,k),Y[3*h]=k.x*q,Y[3*h+1]=k.y,Y[3*h+2]=k.z}const c=h.createBufferView(Y,12),E=h.createAccessor(c,"VEC3",5126,N.length/3,0);Q.push(E),H.attributes.NORMAL=Q.length-1}else E.Tools.Warn(`Morph target normals for mesh ${c.name} were not exported. Mesh does not have normals vertex data`)}if(Y.hasTangents){const N=Y.getTangents(),b=w.getVerticesData(W.f.TangentKind);if(b){p=b.length/4;const Y=new Float32Array(3*p);M=0;for(let h=M;h<p;++h){const c=C.bh.dh(b,4*h);J(c);const E=C.bh.dh(N,3*h);J(E),E.subtractToRef(c,k),Y[3*h]=k.x*q,Y[3*h+1]=k.y,Y[3*h+2]=k.z}const c=h.createBufferView(Y,12),E=h.createAccessor(c,"VEC3",5126,p,0);Q.push(E),H.attributes.TANGENT=Q.length-1}else E.Tools.Warn(`Morph target tangents for mesh ${c.name} were not exported. Mesh does not have tangents vertex data`)}if(Y.hasColors){const N=Y.getColors(),b=w.getVerticesData(W.f.ColorKind),q=w.getVertexBuffer(W.f.ColorKind);if(b&&q){const Y=q.getSize();p=b.length/Y;const c=new Float32Array(p*Y);M=0;for(let h=M;h<p;++h)if(3===Y){const E=C.bh.dh(b,h*Y);C.bh.dh(N,h*Y).subtractToRef(E,k),c[3*h]=k.x,c[3*h+1]=k.y,c[3*h+2]=k.z}else if(4===Y){const E=new C.Vector4,Q=C.Vector4.dh(b,h*Y);C.Vector4.dh(N,h*Y).subtractToRef(Q,E),c[4*h]=E.x,c[4*h+1]=E.y,c[4*h+2]=E.z,c[4*h+3]=E.w}else E.Tools.Warn(`Unsupported number of components for color attribute: ${Y}`);const w=h.createBufferView(c,4*Y),W=h.createAccessor(w,3===Y?"VEC3":"VEC4",5126,p,0);Q.push(W),H.attributes.COLOR_0=Q.length-1}else E.Tools.Warn(`Morph target colors for mesh ${c.name} were not exported. Mesh does not have colors vertex data`)}return H}var XY=h(13428),ZY=h(13278),aY=h(13265),GY=h(12825);class KY{}KY.DEFAULT_COLOR=y.ph.White(),KY.DEFAULT_WIDTH_ATTENUATED=1,KY.DEFAULT_WIDTH=.1;var IY=h(13083),sY=h(13435);class xY{static ConvertPoints(Y,c){if(Y.length&&Array.isArray(Y)&&"number"===typeof Y[0])return[Y];if(Y.length&&Array.isArray(Y[0])&&"number"===typeof Y[0][0])return Y;if(Y.length&&!Array.isArray(Y[0])&&Y[0]instanceof C.bh){const c=[];for(let h=0;h<Y.length;h++){const C=Y[h];c.push(C.x,C.y,C.z)}return[c]}if(Y.length>0&&Array.isArray(Y[0])&&Y[0].length>0&&Y[0][0]instanceof C.bh){const c=[],h=Y;for(const Y of h)c.push(Y.flatMap((Y=>[Y.x,Y.y,Y.z])));return c}if(Y instanceof Float32Array){if(null!==c&&void 0!==c&&c.floatArrayStride){const h=[],C=3*c.floatArrayStride;for(let c=0;c<Y.length;c+=C){const E=new Array(C);for(let h=0;h<C;h++)E[h]=Y[c+h];h.push(E)}return h}return[Array.from(Y)]}if(Y.length&&Y[0]instanceof Float32Array){const c=[];for(const h of Y)c.push(Array.from(h));return c}return[]}static OmitZeroLengthPredicate(Y,c,h){const C=[];return c.Hh(Y).lengthSquared()>0&&C.push([Y,c]),h.Hh(c).lengthSquared()>0&&C.push([c,h]),Y.Hh(h).lengthSquared()>0&&C.push([h,Y]),0===C.length?null:C}static OmitDuplicatesPredicate(Y,c,h,C){const E=[];return xY._SearchInPoints(Y,c,C)||E.push([Y,c]),xY._SearchInPoints(c,h,C)||E.push([c,h]),xY._SearchInPoints(h,Y,C)||E.push([h,Y]),0===E.length?null:E}static _SearchInPoints(Y,c,h){for(const Q of h)for(let h=0;h<Q.length;h++){var C,E,N;if(null!==(C=Q[h])&&void 0!==C&&C.equals(Y))if(null!==(E=Q[h+1])&&void 0!==E&&E.equals(c)||null!==(N=Q[h-1])&&void 0!==N&&N.equals(c))return!0}return!1}static MeshesToLines(Y,c){const h=[];for(let E=0;E<Y.length;E++){const N=Y[E],Q=N.getVerticesData(W.f.PositionKind),b=N.sc();if(Q&&b)for(let Y=0,H=0;Y<b.length;Y++){const w=3*b[H++],W=3*b[H++],q=3*b[H++],k=new C.bh(Q[w],Q[w+1],Q[w+2]),M=new C.bh(Q[W],Q[W+1],Q[W+2]),p=new C.bh(Q[q],Q[q+1],Q[q+2]);if(c){const C=c(k,M,p,h,Y,w,N,E,Q,b);if(C)for(const Y of C)h.push(Y)}else h.push([k,M],[M,p],[p,k])}}return h}static ToVector3Array(Y){if(Array.isArray(Y[0])){const c=[],h=Y;for(const Y of h){const h=[];for(let c=0;c<Y.length;c+=3)h.push(new C.bh(Y[c],Y[c+1],Y[c+2]));c.push(h)}return c}const c=Y,h=[];for(let E=0;E<c.length;E+=3)h.push(new C.bh(c[E],c[E+1],c[E+2]));return h}static ToNumberArray(Y){return Y.flatMap((Y=>[Y.x,Y.y,Y.z]))}static GetPointsCountInfo(Y){const c=new Array(Y.length);let h=0;for(let C=Y.length;C--;)c[C]=Y[C].length/3,h+=c[C];return{total:h,counts:c}}static GetLineLength(Y){if(0===Y.length)return 0;let c;c="number"===typeof Y[0]?xY.ToVector3Array(Y):Y;const h=C.TmpVectors.bh[0];let E=0;for(let C=0;C<c.length-1;C++){const Y=c[C];E+=c[C+1].subtractToRef(Y,h).length()}return E}static GetLineLengthArray(Y){const c=new Float32Array(Y.length/3);let h=0;for(let C=0,E=Y.length/3-1;C<E;C++){let E=Y[3*C+0],N=Y[3*C+1],Q=Y[3*C+2];E-=Y[3*C+3],N-=Y[3*C+4],Q-=Y[3*C+5];h+=Math.sqrt(E*E+N*N+Q*Q),c[C+1]=h}return c}static SegmentizeSegmentByCount(Y,c,h){const E=[],N=c.Hh(Y),Q=C.TmpVectors.bh[0];Q.nc(h);const b=C.TmpVectors.bh[1];N.divideToRef(Q,b);let H=Y.clone();E.push(H);for(let C=0;C<h;C++)H=H.clone(),E.push(H.addInPlace(b));return E}static SegmentizeLineBySegmentLength(Y,c){const h=Y[0]instanceof C.bh?xY.GetLineSegments(Y):"number"===typeof Y[0]?xY.GetLineSegments(xY.ToVector3Array(Y)):Y,E=[];for(const C of h)if(C.length>c){const Y=xY.SegmentizeSegmentByCount(C.point1,C.point2,Math.ceil(C.length/c));for(const c of Y)E.push(c)}else E.push(C.point1),E.push(C.point2);return E}static SegmentizeLineBySegmentCount(Y,c){const h="number"===typeof Y[0]?xY.ToVector3Array(Y):Y,C=xY.GetLineLength(h)/c;return xY.SegmentizeLineBySegmentLength(h,C)}static GetLineSegments(Y){const c=[];for(let h=0;h<Y.length-1;h++){const C=Y[h],E=Y[h+1],N=E.Hh(C).length();c.push({point1:C,point2:E,length:N})}return c}static GetMinMaxSegmentLength(Y){const c=xY.GetLineSegments(Y).sort((Y=>Y.length));return{min:c[0].length,max:c[c.length-1].length}}static GetPositionOnLineByVisibility(Y,c,h){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const N=c*h;let Q=0,b=0;const H=Y.length;for(let C=0;C<H;C++){if(N<=Q+Y[C].length){b=C;break}Q+=Y[C].length}const w=(N-Q)/Y[b].length;return Y[b].point2.subtractToRef(Y[b].point1,C.TmpVectors.bh[0]),C.TmpVectors.bh[1]=C.TmpVectors.bh[0].multiplyByFloats(w,w,w),E||C.TmpVectors.bh[1].addInPlace(Y[b].point1),C.TmpVectors.bh[1].clone()}static GetCircleLinePoints(Y,c){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Y,N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/c;const Q=[];for(let b=0;b<=c;b++)Q.push(new C.bh(Math.cos(b*N)*Y,Math.sin(b*N)*E,h));return Q}static GetBezierLinePoints(Y,c,h,C){return IY.f.CreateQuadraticBezier(Y,c,h,C).getPoints().flatMap((Y=>[Y.x,Y.y,Y.z]))}static GetArrowCap(Y,c,h,C,E){let N=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[Y.clone(),Y.add(c.multiplyByFloats(h,h,h))],widths:[C,E,N,Q]}}static GetPointsFromText(Y,c,h,C){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,N=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const Q=[],b=(0,sY.b)(Y,c,h,C);for(const H of b){for(const Y of H.paths){const c=[],h=Y.getPoints();for(const Y of h)c.push(Y.x,Y.y,E);Q.push(c)}if(N)for(const Y of H.holes){const c=[],h=Y.getPoints();for(const Y of h)c.push(Y.x,Y.y,E);Q.push(c)}}return Q}static Color3toRGBAUint8(Y){const c=new Uint8Array(4*Y.length);for(let h=0,C=0;h<Y.length;h++)c[C++]=255*Y[h].r,c[C++]=255*Y[h].g,c[C++]=255*Y[h].b,c[C++]=255;return c}static CreateColorsTexture(Y,c,h,C){const E=C.getEngine().getCaps().maxTextureSize??1,N=c.length>E?E:c.length,Q=Math.ceil(c.length/E);Q>1&&(c=[...c,...Array(N*Q-c.length).fill(c[0])]);const b=xY.Color3toRGBAUint8(c),H=new X.b(b,N,Q,p.c.TEXTUREFORMAT_RGBA,C,!1,!0,h);return H.name=Y,H}static PrepareEmptyColorsTexture(Y){if(!KY.EmptyColorsTexture){const c=new Uint8Array(4);KY.EmptyColorsTexture=new X.b(c,1,1,p.c.TEXTUREFORMAT_RGBA,Y,!1,!1,X.b.NEAREST_NEAREST),KY.EmptyColorsTexture.name="grlEmptyColorsTexture"}return KY.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var Y;null===(Y=KY.EmptyColorsTexture)||void 0===Y||Y.dispose(),KY.EmptyColorsTexture=null}static BooleanToNumber(Y){return Y?1:0}}class AY extends aY.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class VY extends ZY.e{isCompatible(Y){return!0}constructor(Y,c,h){var E;h=h||{color:KY.DEFAULT_COLOR};const N=new AY;N.GREASED_LINE_HAS_COLOR=!!h.color&&!h.useColors,N.GREASED_LINE_SIZE_ATTENUATION=h.sizeAttenuation??!1,N.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===h.colorDistributionType,N.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(c??Y.ZY()).useRightHandedSystem,N.GREASED_LINE_CAMERA_FACING=h.cameraFacing??!0,super(Y,VY.GREASED_LINE_MATERIAL_NAME,200,N,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(E=h)||void 0===E?void 0:E.forceGLSL)||VY.ForceGLSL,this._scene=c??Y.ZY(),this._engine=this._scene.getEngine(),this._cameraFacing=h.cameraFacing??!0,this.visibility=h.visibility??1,this.useDash=h.useDash??!1,this.dashRatio=h.dashRatio??.5,this.dashOffset=h.dashOffset??0,this.width=h.width?h.width:h.sizeAttenuation?KY.DEFAULT_WIDTH_ATTENUATED:KY.DEFAULT_WIDTH,this._sizeAttenuation=h.sizeAttenuation??!1,this.colorMode=h.colorMode??0,this._color=h.color??null,this.useColors=h.useColors??!1,this._colorsDistributionType=h.colorDistributionType??0,this.colorsSampling=h.colorsSampling??X.b.NEAREST_NEAREST,this._colors=h.IY??null,this.dashCount=h.dashCount??1,this.resolution=h.resolution??new C.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),h.colorsTexture?this.colorsTexture=h.colorsTexture:this._colors?this.colorsTexture=xY.CreateColorsTexture(`${Y.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??KY.DEFAULT_COLOR,xY.PrepareEmptyColorsTexture(this._scene)),this._engine.Mc.add((()=>{xY.DisposeEmptyColorsTexture()}))}getAttributes(Y){Y.push("grl_offsets"),Y.push("grl_widths"),Y.push("grl_colorPointers"),Y.push("grl_counters"),this._cameraFacing?(Y.push("grl_previousAndSide"),Y.push("grl_nextAndCounters")):Y.push("grl_slopes")}getSamplers(Y){Y.push("grl_colors")}getActiveTextures(Y){this.colorsTexture&&Y.push(this.colorsTexture)}getUniforms(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const c=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&c.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===Y&&c.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:c,vertex:this._cameraFacing&&this._isGLSL(Y)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(Y)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(Y){if(this._cameraFacing){Y.Gc("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||Y.Gc("viewProjection",this._scene.getTransformMatrix());const c=C.TmpVectors.Vector4[0];c.x=this._aspect,c.y=this._resolution.x,c.z=this._resolution.y,c.w=this.width,Y.updateVector4("grl_aspect_resolution_lineWidth",c)}const c=C.TmpVectors.Vector4[0];c.x=xY.BooleanToNumber(this.useDash),c.y=this._dashArray,c.z=this.dashOffset,c.w=this.dashRatio,Y.updateVector4("grl_dashOptions",c);const h=C.TmpVectors.Vector4[1];h.x=this.colorMode,h.y=this.visibility,h.z=this.colorsTexture?this.colorsTexture.getSize().width:0,h.w=xY.BooleanToNumber(this.useColors),Y.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",h),this._color&&Y.updateColor3("grl_singleColor",this._color);const E=this.colorsTexture??KY.EmptyColorsTexture;Y.setTexture("grl_colors",E),Y.updateFloat2("grl_textureSize",(null===E||void 0===E?void 0:E.getSize().width)??1,(null===E||void 0===E?void 0:E.getSize().height)??1)}prepareDefines(Y,c,h){Y.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,Y.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,Y.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,Y.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=c.useRightHandedSystem,Y.GREASED_LINE_CAMERA_FACING=this._cameraFacing,Y.GREASED_LINE_USE_OFFSETS=!!h.offsets}getClassName(){return VY.GREASED_LINE_MATERIAL_NAME}getCustomCode(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(c)?function(Y,c){if("vertex"===Y){const Y={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return c&&(Y["!gl_Position\\=viewProjection\\*worldPos;"]="//"),Y}return"fragment"===Y?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(Y,this._cameraFacing):function(Y,c){if("vertex"===Y){const Y={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return c&&(Y["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),Y}return"fragment"===Y?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(Y,this._cameraFacing)}dispose(){var Y;null===(Y=this.colorsTexture)||void 0===Y||Y.dispose(),super.dispose()}get IY(){return this._colors}set IY(Y){this.setColors(Y)}setColors(Y){var c;let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var N;if(this._colors=Y,null!==Y&&0!==Y.length){if(!h||C)if(this.colorsTexture&&E===Y.length&&!C){const c=xY.Color3toRGBAUint8(Y);this.colorsTexture.update(c)}else{var Q;null===(Q=this.colorsTexture)||void 0===Q||Q.dispose(),this.colorsTexture=xY.CreateColorsTexture(`${this._material.name}-colors-texture`,Y,this.colorsSampling,this._scene)}}else null===(N=this.colorsTexture)||void 0===N||N.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(Y){this._dashCount=Y,this._dashArray=1/Y}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Y){this._sizeAttenuation=Y,this.markAllDefinesAsDirty()}get color(){return this._color}set color(Y){this.setColor(Y)}setColor(Y){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==Y||null!==this._color&&null===Y?(this._color=Y,c||this.markAllDefinesAsDirty()):this._color=Y}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Y){this._colorsDistributionType=Y,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(Y){this._aspect=Y.x/Y.y,this._resolution=Y}serialize(){const Y=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(c.IY=this._colors),this._color&&(c.color=this._color),Y.greasedLineMaterialOptions=c,Y}parse(Y,c,h){var C;super.parse(Y,c,h);const E=Y.greasedLineMaterialOptions;null===(C=this.colorsTexture)||void 0===C||C.dispose(),E.color&&this.setColor(E.color,!0),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.IY&&(this.IY=E.IY),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),this.IY?this.colorsTexture=xY.CreateColorsTexture(`${this._material.name}-colors-texture`,this.IY,this.colorsSampling,c):xY.PrepareEmptyColorsTexture(c),this.markAllDefinesAsDirty()}copyTo(Y){var c;const h=Y;null===(c=h.colorsTexture)||void 0===c||c.dispose(),this._colors&&(h.colorsTexture=xY.CreateColorsTexture(`${h._material.name}-colors-texture`,this._colors,h.colorsSampling,this._scene)),h.setColor(this.color,!0),h.colorsDistributionType=this.colorsDistributionType,h.colorsSampling=this.colorsSampling,h.colorMode=this.colorMode,h.useColors=this.useColors,h.visibility=this.visibility,h.useDash=this.useDash,h.dashCount=this.dashCount,h.dashRatio=this.dashRatio,h.dashOffset=this.dashOffset,h.width=this.width,h.sizeAttenuation=this.sizeAttenuation,h.resolution=this.resolution,h.markAllDefinesAsDirty()}_isGLSL(Y){return 0===Y||this._forceGLSL}}VY.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",VY.ForceGLSL=!1,(0,GY.e)(`BABYLON.${VY.GREASED_LINE_MATERIAL_NAME}`,VY);var UY=h(13305),lY=h(12707),nY=h(13106),vY=h(12812);class gY extends nY.ShaderMaterial{constructor(Y,c,E){const N=c.getEngine(),Q=N.isWebGPU&&!(E.forceGLSL||gY.ForceGLSL),b=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];c.useRightHandedSystem&&b.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const H=["position","grl_widths","grl_offsets","grl_colorPointers"];E.cameraFacing?(b.push("GREASED_LINE_CAMERA_FACING"),H.push("grl_previousAndSide","grl_nextAndCounters")):(H.push("grl_slopes"),H.push("grl_counters"));const w=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(Q||w.push("world","viewProjection","view","projection"),super(Y,c,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:Q?["Scene","Mesh"]:void 0,attributes:H,uniforms:w,samplers:Q?[]:["grlColors"],defines:b,extraInitializationsAsync:async()=>{Q?await Promise.all([h.e(66).then(h.bind(h,16122)),h.e(75).then(h.bind(h,16128))]):await Promise.all([h.e(69).then(h.bind(h,16134)),h.e(76).then(h.bind(h,16137))])},shaderLanguage:Q?1:0}),this._color=y.ph.White(),this._colorsDistributionType=0,this._colorsTexture=null,E=E||{color:KY.DEFAULT_COLOR},this.visibility=E.visibility??1,this.useDash=E.useDash??!1,this.dashRatio=E.dashRatio??.5,this.dashOffset=E.dashOffset??0,this.dashCount=E.dashCount??1,this.width=E.width?E.width:E.sizeAttenuation&&E.cameraFacing?KY.DEFAULT_WIDTH_ATTENUATED:KY.DEFAULT_WIDTH,this.sizeAttenuation=E.sizeAttenuation??!1,this.color=E.color??y.ph.White(),this.useColors=E.useColors??!1,this.colorsDistributionType=E.colorDistributionType??0,this.colorsSampling=E.colorsSampling??X.b.NEAREST_NEAREST,this.colorMode=E.colorMode??0,this._colors=E.IY??null,this._cameraFacing=E.cameraFacing??!0,this.resolution=E.resolution??new C.Vector2(N.getRenderWidth(),N.getRenderHeight()),E.colorsTexture?this.colorsTexture=E.colorsTexture:this._colors?this.colorsTexture=xY.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,c):(this._color=this._color??KY.DEFAULT_COLOR,this.colorsTexture=xY.PrepareEmptyColorsTexture(c)),Q){const Y=new vY.e;Y.setParameters(),Y.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",Y)}N.Mc.add((()=>{xY.DisposeEmptyColorsTexture()}))}dispose(){var Y;null===(Y=this._colorsTexture)||void 0===Y||Y.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new C.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get IY(){return this._colors}set IY(Y){this.setColors(Y)}setColors(Y){var c;let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var N;if(this._colors=Y,null!==Y&&0!==Y.length){if(!h||C)if(this._colorsTexture&&E===Y.length&&!C){const c=xY.Color3toRGBAUint8(Y);this._colorsTexture.update(c)}else{var Q;null===(Q=this._colorsTexture)||void 0===Q||Q.dispose(),this.colorsTexture=xY.CreateColorsTexture(`${this.name}-colors-texture`,Y,this.colorsSampling,this.ZY())}}else null===(N=this._colorsTexture)||void 0===N||N.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(Y){this._colorsTexture=Y,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(Y){this._width=Y,this.setFloat("grlWidth",Y)}get useColors(){return this._useColors}set useColors(Y){this._useColors=Y,this.setFloat("grlUseColors",xY.BooleanToNumber(Y))}get colorsSampling(){return this._colorsSampling}set colorsSampling(Y){this._colorsSampling=Y}get visibility(){return this._visibility}set visibility(Y){this._visibility=Y,this.setFloat("grlVisibility",Y)}get useDash(){return this._useDash}set useDash(Y){this._useDash=Y,this.setFloat("grlUseDash",xY.BooleanToNumber(Y))}get dashOffset(){return this._dashOffset}set dashOffset(Y){this._dashOffset=Y,this.setFloat("grlDashOffset",Y)}get dashRatio(){return this._dashRatio}set dashRatio(Y){this._dashRatio=Y,this.setFloat("grlDashRatio",Y)}get dashCount(){return this._dashCount}set dashCount(Y){this._dashCount=Y,this._dashArray=1/Y,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Y){this._sizeAttenuation=Y,this.setFloat("grlSizeAttenuation",xY.BooleanToNumber(Y))}get color(){return this._color}set color(Y){this.setColor(Y)}setColor(Y){Y=Y??KY.DEFAULT_COLOR,this._color=Y,this.setColor3("grlColor",Y)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Y){this._colorsDistributionType=Y,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(Y){this._colorMode=Y,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(Y){this._resolution=Y,this.setVector2("grlResolution",Y),this.setFloat("grlAspect",Y.x/Y.y)}serialize(){const Y=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(c.IY=this._colors),Y.greasedLineMaterialOptions=c,Y}parse(Y,c,h){var C;const E=Y.greasedLineMaterialOptions;null===(C=this._colorsTexture)||void 0===C||C.dispose(),E.color&&(this.color=E.color),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),E.IY?this.colorsTexture=xY.CreateColorsTexture(`${this.name}-colors-texture`,E.IY,this.colorsSampling,this.ZY()):this.colorsTexture=xY.PrepareEmptyColorsTexture(c),this._cameraFacing=E.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var zY,OY,oY;gY.ForceGLSL=!1,function(Y){Y[Y.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",Y[Y.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(zY||(zY={})),function(Y){Y[Y.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",Y[Y.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",Y[Y.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(OY||(OY={})),function(Y){Y[Y.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",Y[Y.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",Y[Y.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",Y[Y.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",Y[Y.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(oY||(oY={}));class fY extends DY.e{constructor(Y,c,h){super(Y,c,null,null,!1,!1),this.name=Y,this._options=h,this._lazy=!1,this._updatable=!1,this._engine=c.getEngine(),this._lazy=h.lazy??!1,this._updatable=h.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=h.colorPointers??[],this._widths=h.widths??new Array(h.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(Y){let c=0;for(const C of this._points)c+=C.length;const h=c/3*2-this._widths.length;for(let C=0;C<h;C++)this._widths.push(Y)}updateLazy(){var Y,c;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(Y=this._options.ribbonOptions)||void 0===Y?void 0:Y.smoothShading),!this.VY&&this.refreshBoundingInfo(),null===(c=this.greasedLineMaterial)||void 0===c||c.updateLazy()}addPoints(Y,c){for(const h of Y)this._points.push(h);this._lazy||this.setPoints(this._points,c)}dispose(Y){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(Y,c)}isLazy(){return this._lazy}get sY(){return this._uvs}set sY(Y){this._uvs=Y instanceof Float32Array?Y:new Float32Array(Y),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(Y){this.material instanceof gY&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===Y||void 0===Y?void 0:Y.length)>0),this._offsets=Y,this._offsetsBuffer?this._offsetsBuffer.update(Y):this._createOffsetsBuffer(Y)}get widths(){return this._widths}set widths(Y){this._widths=Y,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(Y)}get colorPointers(){return this._colorPointers}set colorPointers(Y){this._colorPointers=Y,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(Y)}get greasedLineMaterial(){var Y,c;if(this.material&&this.material instanceof gY)return this.material;const h=null===(Y=this.material)||void 0===Y||null===(c=Y.pluginManager)||void 0===c?void 0:c.getPlugin(VY.GREASED_LINE_MATERIAL_NAME);return h||void 0}get points(){const Y=[];return lY.b.DeepCopy(this._points,Y),Y}setPoints(Y,c){this._points=xY.ConvertPoints(Y,(null===c||void 0===c?void 0:c.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==c&&void 0!==c&&c.colorPointers||this._updateColorPointers(),this._setPoints(this._points,c)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,sY:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(Y){super.serialize(Y),Y.type=this.getClassName(),Y.lineOptions=this._createLineOptions()}_createVertexBuffers(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new UY.b;return c.GY=this._vertexPositions,c.indices=this._indices,c.sY=this._uvs,Y&&(c.KY=[],UY.b.ComputeNormals(this._vertexPositions,this._indices,c.KY)),c.AY(this,this._options.updatable),c}_createOffsetsBuffer(Y){const c=this._scene.getEngine(),h=new W.d(c,Y,this._updatable,3);this.setVerticesBuffer(h.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=h}}class LY{constructor(Y,c){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=Y,this.wasAddedByNoopNode=c}getIndicesAccessor(Y,c,h,C,E){var N,Q,b,H;return null===(N=this._indicesAccessorMap.get(Y))||void 0===N||null===(Q=N.get(c))||void 0===Q||null===(b=Q.get(h))||void 0===b||null===(H=b.get(C))||void 0===H?void 0:H.get(E)}setIndicesAccessor(Y,c,h,C,E,N){let Q=this._indicesAccessorMap.get(Y);Q||(Q=new Map,this._indicesAccessorMap.set(Y,Q));let b=Q.get(c);b||(b=new Map,Q.set(c,b));let H=b.get(h);H||(H=new Map,b.set(h,H));let w=H.get(C);w||(w=new Map,H.set(C,w)),w.set(E,N)}pushExportedNode(Y){this._exportedNodes.has(Y)||this._exportedNodes.add(Y)}getNodesSet(){return this._exportedNodes}getVertexBufferView(Y){return this._vertexBufferViewMap.get(Y)}setVertexBufferView(Y,c){this._vertexBufferViewMap.set(Y,c)}setRemappedBufferView(Y,c,h){this._remappedBufferView.set(Y,new Map),this._remappedBufferView.get(Y).set(c,h)}getRemappedBufferView(Y,c){var h;return null===(h=this._remappedBufferView.get(Y))||void 0===h?void 0:h.get(c)}getVertexAccessor(Y,c,h){var C,E;return null===(C=this._vertexAccessorMap.get(Y))||void 0===C||null===(E=C.get(c))||void 0===E?void 0:E.get(h)}setVertexAccessor(Y,c,h,C){let E=this._vertexAccessorMap.get(Y);E||(E=new Map,this._vertexAccessorMap.set(Y,E));let N=E.get(c);N||(N=new Map,E.set(c,N)),N.set(h,C)}hasVertexColorAlpha(Y){return this._vertexMapColorAlpha.get(Y)||!1}setHasVertexColorAlpha(Y,c){return this._vertexMapColorAlpha.set(Y,c)}getMesh(Y){return this._meshMap.get(Y)}setMesh(Y,c){this._meshMap.set(Y,c)}bindMorphDataToMesh(Y,c){const h=this._meshMorphTargetMap.get(Y)||[];this._meshMorphTargetMap.set(Y,h),-1===h.indexOf(c)&&h.push(c)}getMorphTargetsFromMesh(Y){return this._meshMorphTargetMap.get(Y)}}class uY{_ApplyExtension(Y,c,h,C){if(h>=c.length)return Promise.resolve(Y);const E=C(c[h],Y);return E?E.then((async Y=>Y?await this._ApplyExtension(Y,c,h+1,C):null)):this._ApplyExtension(Y,c,h+1,C)}_ApplyExtensions(Y,c){const h=[];for(const C of uY._ExtensionNames)h.push(this._extensions[C]);return this._ApplyExtension(Y,h,0,c)}_extensionsPreExportTextureAsync(Y,c,h){return this._ApplyExtensions(c,((c,C)=>c.preExportTextureAsync&&c.preExportTextureAsync(Y,C,h)))}_extensionsPostExportNodeAsync(Y,c,h,C,E){return this._ApplyExtensions(c,((c,N)=>c.postExportNodeAsync&&c.postExportNodeAsync(Y,N,h,C,E,this._bufferManager)))}_extensionsPostExportMaterialAsync(Y,c,h){return this._ApplyExtensions(c,((c,C)=>c.postExportMaterialAsync&&c.postExportMaterialAsync(Y,C,h)))}_extensionsPostExportMaterialAdditionalTextures(Y,c,h){const C=[];for(const E of uY._ExtensionNames){const N=this._extensions[E];N.postExportMaterialAdditionalTextures&&C.push(...N.postExportMaterialAdditionalTextures(Y,c,h))}return C}_extensionsPostExportTextures(Y,c,h){for(const C of uY._ExtensionNames){const E=this._extensions[C];E.postExportTexture&&E.postExportTexture(Y,c,h)}}_extensionsPostExportMeshPrimitive(Y){for(const c of uY._ExtensionNames){const h=this._extensions[c];h.postExportMeshPrimitive&&h.postExportMeshPrimitive(Y,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const Y of uY._ExtensionNames){const c=this._extensions[Y];c.preGenerateBinaryAsync&&await c.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(Y){for(const c of uY._ExtensionNames){const h=this._extensions[c];h.enabled&&Y(h)}}_extensionsOnExporting(){this._forEachExtensions((Y=>{var c,h,C;Y.wasUsed&&((c=this._glTF).extensionsUsed||(c.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(Y.name)&&this._glTF.extensionsUsed.push(Y.name),Y.required&&((h=this._glTF).extensionsRequired||(h.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(Y.name)&&this._glTF.extensionsRequired.push(Y.name)),(C=this._glTF).extensions||(C.extensions={}),Y.onExporting&&Y.onExporting())}))}_loadExtensions(){for(const Y of uY._ExtensionNames){const c=uY._ExtensionFactories[Y](this);this._extensions[Y]=c}}constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:P.d.LastCreatedScene,c=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${p.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new v(this),this._extensions={},this._bufferManager=new WY,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!Y)throw new Error("No scene available to export");this._babylonScene=Y,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:Y=>{var c;return null===Y||void 0===Y||null===(c=Y.Dc)||void 0===c?void 0:c.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...c},this._loadExtensions()}dispose(){for(const Y in this._extensions){this._extensions[Y].dispose()}}get options(){return this._options}static RegisterExtension(Y,c){uY.UnregisterExtension(Y)&&E.Tools.Warn(`Extension with the name ${Y} already exists`),uY._ExtensionFactories[Y]=c,uY._ExtensionNames.push(Y)}static UnregisterExtension(Y){if(!uY._ExtensionFactories[Y])return!1;delete uY._ExtensionFactories[Y];const c=uY._ExtensionNames.indexOf(Y);return-1!==c&&uY._ExtensionNames.splice(c,1),!0}_generateJSON(Y,c,h){const C={byteLength:Y};return C.byteLength&&(this._glTF.buffers=[C]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.wh=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(C.uri=c+".bin"),h?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(Y){const c=await this._generateBinaryAsync();this._extensionsOnExporting();const h=this._generateJSON(c.byteLength,Y,!0),C=new Blob([c],{type:"application/octet-stream"}),E=Y+".gltf",N=Y+".bin",Q=new w;if(Q.files[E]=h,Q.files[N]=C,this._imageData)for(const b in this._imageData)Q.files[b]=new Blob([this._imageData[b].data],{type:this._imageData[b].mimeType});return Q}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(Y){const c=Y%4;return 0===c?c:4-c}async generateGLBAsync(Y){this._shouldUseGlb=!0;const c=await this._generateBinaryAsync();this._extensionsOnExporting();const h=this._generateJSON(c.byteLength),C=Y+".glb";let E,N=h.length;if("undefined"!==typeof TextEncoder){E=(new TextEncoder).encode(h),N=E.length}const Q=this._getPadding(N),b=this._getPadding(c.byteLength),H=28+N+Q+c.byteLength+b,W=new HY(H);if(W.writeUInt32(1179937895),W.writeUInt32(2),W.writeUInt32(H),W.writeUInt32(N+Q),W.writeUInt32(1313821514),E)W.writeTypedArray(E);else{const Y="_".charCodeAt(0);for(let c=0;c<N;++c){const C=h.charCodeAt(c);C!=h.codePointAt(c)?W.writeUInt8(Y):W.writeUInt8(C)}}for(let w=0;w<Q;++w)W.writeUInt8(32);W.writeUInt32(c.byteLength+b),W.writeUInt32(5130562),W.writeTypedArray(c);for(let w=0;w<b;++w)W.writeUInt8(0);const q=new w;return q.files[C]=new Blob([W.getOutputData()],{type:"application/octet-stream"}),q}_setNodeTransformation(Y,c,h){if(c.getPivotPoint().equalsWithEpsilon(f,o.d)||E.Tools.Warn("Pivot points are not supported in the glTF serializer"),!c.position.equalsWithEpsilon(f,o.d)){const E=C.TmpVectors.bh[0].N(c.position);h&&j(E),Y.translation=E.Xc()}c.lc.equalsWithEpsilon(u,o.d)||(Y.scale=c.lc.Xc());const N=c.rotationQuaternion||C.Quaternion.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);N.equalsWithEpsilon(L,o.d)||(h&&S(N),Y.rotation=N.normalize().Xc())}_setCameraTransformation(Y,c,h){if(!c.position.equalsWithEpsilon(f,o.d)){const E=C.TmpVectors.bh[0].N(c.position);h&&j(E),Y.translation=E.Xc()}const E=c.rotationQuaternion||C.Quaternion.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);h&&S(E),this._babylonScene.useRightHandedSystem||mY(E),E.equalsWithEpsilon(L,o.d)||(Y.rotation=E.Xc())}_listAvailableCameras(){for(const Y of this._babylonScene.cameras){const c={type:Y.mode===kY.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(Y.name&&(c.name=Y.name),"perspective"===c.type)c.perspective={aspectRatio:Y.getEngine().getAspectRatio(Y),yfov:Y.fovMode===kY.b.FOVMODE_VERTICAL_FIXED?Y.fov:Y.fov*Y.getEngine().getAspectRatio(Y),znear:Y.ac,zfar:Y.maxZ};else if("orthographic"===c.type){const h=Y.orthoLeft&&Y.orthoRight?.5*(Y.orthoRight-Y.orthoLeft):.5*Y.getEngine().getRenderWidth(),C=Y.orthoBottom&&Y.orthoTop?.5*(Y.orthoTop-Y.orthoBottom):.5*Y.getEngine().getRenderHeight();c.orthographic={xmag:h,ymag:C,znear:Y.ac,zfar:Y.maxZ}}this._camerasMap.set(Y,c)}}_exportAndAssignCameras(){const Y=Array.from(this._camerasMap.values());for(const c of Y){const Y=this._nodesCameraMap.get(c);if(void 0!==Y){this._cameras.push(c);for(const c of Y)c.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const Y of this._babylonScene.skeletons){if(Y.bones.length<=0)continue;const c={joints:[]};this._skinMap.set(Y,c)}}_exportAndAssignSkeletons(){for(const Y of this._babylonScene.skeletons){if(Y.bones.length<=0)continue;const c=this._skinMap.get(Y);if(void 0==c)continue;const h={},C=[];let N=-1;for(let E=0;E<Y.bones.length;++E){const c=Y.bones[E],C=c.getIndex()??E;-1!==C&&(h[C]=c,C>N&&(N=C))}for(let Y=0;Y<=N;++Y){const N=h[Y];C.push(N.getAbsoluteInverseBindMatrix());const Q=N.getTransformNode();if(null!==Q){const Y=this._nodeMap.get(Q);Q&&null!==Y&&void 0!==Y?c.joints.push(Y):E.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else E.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const Q=this._nodesSkinMap.get(c);if(c.joints.length>0&&void 0!==Q){const Y=64*C.length,h=new Float32Array(Y/4);C.forEach(((Y,c)=>{h.set(Y.m,16*c)}));const E=this._bufferManager.createBufferView(h);this._accessors.push(this._bufferManager.createAccessor(E,"MAT4",5126,C.length)),c.inverseBindMatrices=this._accessors.length-1,this._skins.push(c);for(const c of Q)c.skin=this._skins.length-1}}}async _exportSceneAsync(){const Y={nodes:[]};if(this._babylonScene.metadata){const c=this._options.metadataSelector(this._babylonScene.metadata);c&&(Y.extras=c)}const c=new Array,h=new Array,C=new Array;for(const b of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&QY(b,this._babylonScene.useRightHandedSystem)?C.push(...b.getChildren()):this._babylonScene.useRightHandedSystem?c.push(b):h.push(b);this._listAvailableCameras(),this._listAvailableSkeletons();const E=new LY(!0,!1);Y.nodes.push(...await this._exportNodesAsync(h,E));const N=new LY(!1,!1);Y.nodes.push(...await this._exportNodesAsync(c,N));const Q=new LY(!1,!0);Y.nodes.push(...await this._exportNodesAsync(C,Q)),Y.nodes.length&&this._scenes.push(Y),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&eY._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,E.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(Y){let c=this._shouldExportNodeMap.get(Y);return void 0===c&&(c=this._options.shouldExportNode(Y),this._shouldExportNodeMap.set(Y,c)),c}async _exportNodesAsync(Y,c){const h=new Array;this._exportBuffers(Y,c);for(const C of Y)await this._exportNodeAsync(C,h,c);return h}_collectBuffers(Y,c,h,C,E){if(this._shouldExportNode(Y)&&Y instanceof k.c&&Y.Ic){const N=Y.Ic.getVertexBuffers();if(N)for(const C in N){if(!t(C))continue;const Q=N[C];E.setHasVertexColorAlpha(Q,Y.hasVertexAlpha);const b=Q._buffer,H=c.get(b)||[];c.set(b,H),-1===H.indexOf(Q)&&H.push(Q);const w=h.get(Q)||[];h.set(Q,w),-1===w.indexOf(Y)&&w.push(Y)}const Q=Y.morphTargetManager;if(Q)for(let c=0;c<Q.numTargets;c++){const h=Q.getTarget(c),E=C.get(h)||[];C.set(h,E),-1===E.indexOf(Y)&&E.push(Y)}}for(const N of Y.getChildren())this._collectBuffers(N,c,h,C,E)}_exportBuffers(Y,c){const h=new Map,C=new Map,E=new Map;for(const b of Y)this._collectBuffers(b,h,C,E,c);const N=Array.from(h.keys());for(const b of N){const Y=b.getData();if(!Y)throw new Error("Buffer data is not available");const E=h.get(b);if(!E)continue;const N=E[0].byteStride;if(E.some((Y=>Y.byteStride!==N)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const Q=hY(Y).slice();for(const c of E){const Y=C.get(c),{byteOffset:h,byteStride:E,componentCount:N,type:b,count:H,normalized:w,kind:q}=R(c,Y);switch(q){case W.f.NormalKind:case W.f.TangentKind:(0,g.k)(Q,h,E,N,b,H,w,(Y=>{const c=Math.sqrt(Y[0]*Y[0]+Y[1]*Y[1]+Y[2]*Y[2]);if(c>0){const h=1/c;Y[0]*=h,Y[1]*=h,Y[2]*=h}}));break;case W.f.ColorKind:{const c=Y.filter((Y=>Y.material instanceof PY.kh||null==Y.material)).length;if(0==c)break;if(c!=Y.length){z.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}b==W.f.UNSIGNED_BYTE&&z.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const C=new y.ph,q=new y.vc,k=this._babylonScene.getEngine().useExactSrgbConversions;(0,g.k)(Q,h,E,N,b,H,w,(Y=>{3===Y.length?(C.IC(Y,0),C.toLinearSpaceToRef(C,k),C.toArray(Y,0)):(q.IC(Y,0),q.toLinearSpaceToRef(q,k),q.toArray(Y,0))}))}}}if(c.convertToRightHanded){for(const Y of E){const c=C.get(Y),{byteOffset:h,byteStride:E,componentCount:N,type:b,count:H,normalized:w,kind:q}=R(Y,c);switch(q){case W.f.PositionKind:case W.f.NormalKind:case W.f.TangentKind:(0,g.k)(Q,h,E,N,b,H,w,(Y=>{Y[0]=-Y[0]}))}}c.convertedToRightHandedBuffers.set(b,Q)}const H=this._bufferManager.createBufferView(Q,N);c.setVertexBufferView(b,H);const w=new Map;for(const c of E){const Y=C.get(c),{kind:h,totalVertices:E}=R(c,Y);switch(h){case W.f.MatricesIndicesKind:case W.f.MatricesIndicesExtraKind:if(c.type==W.f.FLOAT){const Y=c.getFloatData(E);null!==Y&&w.set(c,Y)}}}0!==w.size&&z.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const q=Array.from(w.keys());for(const h of q){const Y=w.get(h);if(!Y)continue;const C=Y.some((Y=>Y>=256)),E=new(C?Uint16Array:Uint8Array)(Y.length);for(let c=0;c<Y.length;c++)E[c]=Y[c];const N=this._bufferManager.createBufferView(E,4*(C?2:1));c.setRemappedBufferView(b,h,N)}}const Q=Array.from(E.keys());for(const b of Q){const Y=E.get(b);if(!Y)continue;const h=rY(b,Y[0],this._bufferManager,this._bufferViews,this._accessors,c.convertToRightHanded);for(const C of Y)c.bindMorphDataToMesh(C,h)}}async _exportNodeAsync(Y,c,h){let C=this._nodeMap.get(Y);if(void 0!==C)return void(c.includes(C)||c.push(C));const E=await this._createNodeAsync(Y,h);if(E){C=this._nodes.length,this._nodes.push(E),this._nodeMap.set(Y,C),h.pushExportedNode(Y),c.push(C);const N={name:"runtime animations",channels:[],samplers:[]},Q=[];this._babylonScene.animationGroups.length||(eY._CreateMorphTargetAnimationFromMorphTargetAnimations(Y,N,Q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,h.convertToRightHanded,this._options.shouldExportAnimation),Y.animations.length&&eY._CreateNodeAnimationFromNodeAnimations(Y,N,Q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,h.convertToRightHanded,this._options.shouldExportAnimation)),N.channels.length&&N.samplers.length&&this._animations.push(N),Q.forEach((Y=>{Y.channels.length&&Y.samplers.length&&this._animations.push(Y)}))}const N=E?[]:c;for(const Q of Y.getChildren())await this._exportNodeAsync(Q,N,h);E&&N.length&&(E.children=N)}async _createNodeAsync(Y,c){if(!this._shouldExportNode(Y))return null;const h={};if(Y.name&&(h.name=Y.name),Y.metadata){const c=this._options.metadataSelector(Y.metadata);c&&(h.extras=c)}if(Y instanceof q.e&&(this._setNodeTransformation(h,Y,c.convertToRightHanded),Y instanceof k.c)){const E=Y instanceof M.d?Y.sourceMesh:Y;if(E.rc&&E.rc.length>0&&(h.mesh=await this._exportMeshAsync(E,c)),Y.skeleton){const c=this._skinMap.get(Y.skeleton);var C;if(void 0!==c)void 0===this._nodesSkinMap.get(c)&&this._nodesSkinMap.set(c,[]),null===(C=this._nodesSkinMap.get(c))||void 0===C||C.push(h)}}if(Y instanceof O.d){const C=this._camerasMap.get(Y);if(C){var E;void 0===this._nodesCameraMap.get(C)&&this._nodesCameraMap.set(C,[]),this._setCameraTransformation(h,Y,c.convertToRightHanded);const Q=Y.parent;if(null!==Q&&cY(Y,Q)){const Y=this._nodeMap.get(Q);if(void 0!==Y){var N;const c=this._nodes[Y];return YY(h,c),null===(N=this._nodesCameraMap.get(C))||void 0===N||N.push(c),null}}null===(E=this._nodesCameraMap.get(C))||void 0===E||E.push(h)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",h,Y,this._nodeMap,c.convertToRightHanded)?h:(z.e.Warn(`Not exporting node ${Y.name}`),null)}_exportIndices(Y,c,h,C,E,Q,b,H,w){let W=Y;w.mode=F(Q);const q=b!==N.d.CounterClockWiseSideOrientation,k=!H.wasAddedByNoopNode&&q,M=function(Y){switch(Y){case N.d.TriangleFillMode:case N.d.TriangleStripDrawMode:case N.d.TriangleFanDrawMode:return!0}return!1}(Q)&&k;if(M){if(Q===N.d.TriangleStripDrawMode||Q===N.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");w.mode=F(Q);const b=c?new Uint32Array(C):new Uint16Array(C);if(Y)for(let c=0;c+2<C;c+=3)b[c]=Y[h+c]+E,b[c+1]=Y[h+c+2]+E,b[c+2]=Y[h+c+1]+E;else for(let Y=0;Y+2<C;Y+=3)b[Y]=Y,b[Y+1]=Y+2,b[Y+2]=Y+1;W=b}else if(Y&&0!==E){const N=c?new Uint32Array(C):new Uint16Array(C);for(let c=0;c<C;c++)N[c]=Y[h+c]+E;W=N}if(W){let N=H.getIndicesAccessor(Y,h,C,E,M);if(void 0===N){const Q=function(Y,c,h,C){if(Y instanceof Uint16Array||Y instanceof Uint32Array)return Y;if(Y instanceof Int32Array)return new Uint32Array(Y.buffer,Y.byteOffset,Y.length);const E=Y.slice(c,c+h);return C?new Uint32Array(E):new Uint16Array(E)}(W,0,C,c),b=this._bufferManager.createBufferView(Q),w=c?5125:5123;this._accessors.push(this._bufferManager.createAccessor(b,"SCALAR",w,C,0)),N=this._accessors.length-1,H.setIndicesAccessor(Y,h,C,E,M,N)}w.indices=N}}_exportVertexBuffer(Y,c,h,C,E,N){const Q=Y.getKind();if(!t(Q))return;if(Q.startsWith("uv")&&!this._options.exportUnusedUVs&&(!c||!this._materialNeedsUVsSet.has(c)))return;let b=E.getVertexAccessor(Y,h,C);if(void 0===b){const c=E.convertedToRightHandedBuffers.get(Y._buffer)||Y._buffer.getData(),N=Q===W.f.PositionKind?function(Y,c,h,C){const{byteOffset:E,byteStride:N,type:Q,normalized:b}=c,H=c.getSize(),w=new Array(H).fill(1/0),W=new Array(H).fill(-1/0);return(0,g.k)(Y,E+h*N,N,H,Q,C*H,b,(Y=>{for(let c=0;c<H;c++)w[c]=Math.min(w[c],Y[c]),W[c]=Math.max(W[c],Y[c])})),{min:w,max:W}}(c,Y,h,C):void 0,H=(Q===W.f.MatricesIndicesKind||Q===W.f.MatricesIndicesExtraKind)&&Y.type===W.f.FLOAT,w=H?W.f.UNSIGNED_BYTE:Y.type,q=H?void 0:Y.normalized,k=H?E.getRemappedBufferView(Y._buffer,Y):E.getVertexBufferView(Y._buffer),M=Y.byteOffset+h*Y.byteStride;this._accessors.push(this._bufferManager.createAccessor(k,function(Y,c){if(Y==W.f.ColorKind)return c?"VEC4":"VEC3";switch(Y){case W.f.PositionKind:case W.f.NormalKind:return"VEC3";case W.f.TangentKind:case W.f.MatricesIndicesKind:case W.f.MatricesIndicesExtraKind:case W.f.MatricesWeightsKind:case W.f.MatricesWeightsExtraKind:return"VEC4";case W.f.UVKind:case W.f.UV2Kind:case W.f.UV3Kind:case W.f.UV4Kind:case W.f.UV5Kind:case W.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${Y}`)}(Q,E.hasVertexColorAlpha(Y)),w,C,M,N,q)),b=this._accessors.length-1,E.setVertexAccessor(Y,h,C,b)}N.attributes[function(Y){switch(Y){case W.f.PositionKind:return"POSITION";case W.f.NormalKind:return"NORMAL";case W.f.TangentKind:return"TANGENT";case W.f.ColorKind:return"COLOR_0";case W.f.UVKind:return"TEXCOORD_0";case W.f.UV2Kind:return"TEXCOORD_1";case W.f.UV3Kind:return"TEXCOORD_2";case W.f.UV4Kind:return"TEXCOORD_3";case W.f.UV5Kind:return"TEXCOORD_4";case W.f.UV6Kind:return"TEXCOORD_5";case W.f.MatricesIndicesKind:return"JOINTS_0";case W.f.MatricesIndicesExtraKind:return"JOINTS_1";case W.f.MatricesWeightsKind:return"WEIGHTS_0";case W.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${Y}`)}(Q)]=b}async _exportMaterialAsync(Y,c,h,C){let E=this._materialMap.get(Y);if(void 0===E){const C=c&&Object.keys(c).some((Y=>Y.startsWith("uv")));if((Y=Y instanceof MY.d?Y.gc[h.materialIndex]:Y)instanceof pY.d)E=await this._materialExporter.exportPBRMaterialAsync(Y,"image/png",C);else{if(!(Y instanceof PY.kh))return void z.e.Warn(`Unsupported material '${Y.name}' with type ${Y.getClassName()}`);E=await this._materialExporter.exportStandardMaterialAsync(Y,"image/png",C)}this._materialMap.set(Y,E)}C.material=E}async _exportMeshAsync(Y,c){var h;let C=c.getMesh(Y);if(void 0!==C)return C;const E={primitives:[]};C=this._meshes.length,this._meshes.push(E),c.setMesh(Y,C);const Q=Y.isUnIndexed?null:Y.sc(),b=null===(h=Y.Ic)||void 0===h?void 0:h.getVertexBuffers(),H=c.getMorphTargetsFromMesh(Y),w=Y instanceof XY.e,W=Y instanceof fY,q=Y.rc;if(b&&q&&q.length>0)for(const p of q){const h={attributes:{}},C=p.vY()||this._babylonScene.defaultMaterial;if(W){var k,M;const c={name:C.name},E=Y,N=y.ph.White(),Q=(null===(k=E.material)||void 0===k?void 0:k.alpha)??1,b=(null===(M=E.greasedLineMaterial)||void 0===M?void 0:M.color)??N;(!b.equalsWithEpsilon(N,o.d)||Q<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...b.Xc(),Q]}),this._materials.push(c),h.material=this._materials.length-1}else if(w){const c={name:C.name},E=Y;(!E.color.equalsWithEpsilon(y.ph.White(),o.d)||E.alpha<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...E.color.Xc(),E.alpha]}),this._materials.push(c),h.material=this._materials.length-1}else await this._exportMaterialAsync(C,b,p,h);const q=w||W?N.d.LineListDrawMode:Y.overrideRenderingFillMode??C.fillMode,P=C._getEffectiveOrientation(Y);this._exportIndices(Q,Q?(0,g.e)(Q,p.indexCount,p.indexStart,p.verticesStart):p.verticesCount>65535,Q?p.indexStart:p.verticesStart,Q?p.indexCount:p.verticesCount,-p.verticesStart,q,P,c,h);for(const Y of Object.values(b))this._exportVertexBuffer(Y,C,p.verticesStart,p.verticesCount,c,h);if(H){h.targets=[];for(const Y of H)h.targets.push(Y.attributes)}E.primitives.push(h),this._extensionsPostExportMeshPrimitive(h)}if(H){E.weights=[],E.extras||(E.extras={}),E.extras.targetNames=[];for(const Y of H)E.weights.push(Y.influence),E.extras.targetNames.push(Y.name)}return C}}uY._ExtensionNames=new Array,uY._ExtensionFactories={};class iY{static async GLTFAsync(Y,c,h){h&&h.exportWithoutWaitingForScene||await Y.whenReadyAsync();const C=new uY(Y,h),E=await C.generateGLTFAsync(c.replace(/\.[^/.]+$/,""));return C.dispose(),E}static async GLBAsync(Y,c,h){h&&h.exportWithoutWaitingForScene||await Y.whenReadyAsync();const C=new uY(Y,h),E=await C.generateGLBAsync(c.replace(/\.[^/.]+$/,""));return C.dispose(),E}}h(13446);const RY="EXT_mesh_gpu_instancing";class BY{constructor(Y){this.name=RY,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(Y,c,h,E,N,Q){return await new Promise((Y=>{if(c&&h instanceof DY.e&&h.hasThinInstances&&this._exporter){this._wasUsed=!0;const Y=C.bh.Zero(),E=C.Quaternion.Identity(),b=C.bh.One(),H=h.thinInstanceGetWorldMatrices(),w=C.TmpVectors.bh[2],W=C.TmpVectors.Quaternion[1],q=C.TmpVectors.bh[3];let k=!1,M=!1,p=!1;const P=new Float32Array(3*h.zc),y=new Float32Array(4*h.zc),d=new Float32Array(3*h.zc);let D=0;for(const c of H)c.decompose(q,W,w),N&&(j(w),S(W)),P.set(w.Xc(),3*D),y.set(W.normalize().Xc(),4*D),d.set(q.Xc(),3*D),k=k||!w.equalsWithEpsilon(Y),M=M||!W.equalsWithEpsilon(E),p=p||!q.equalsWithEpsilon(b),D++;const T={attributes:{}};k&&(T.attributes.TRANSLATION=this._buildAccessor(P,"VEC3",h.zc,Q)),M&&(T.attributes.ROTATION=this._buildAccessor(y,"VEC4",h.zc,Q)),p&&(T.attributes.SCALE=this._buildAccessor(d,"VEC3",h.zc,Q)),c.extensions=c.extensions||{},c.extensions[RY]=T}Y(c)}))}_buildAccessor(Y,c,h,C){const E=C.createBufferView(Y),N=C.createAccessor(E,c,5126,h);return this._exporter._accessors.push(N),this._exporter._accessors.length-1}}uY.RegisterExtension(RY,(Y=>new BY(Y)));var tY=h(13451),FY=h(13464),JY=h(13473),jY=h(13481);function SY(Y){return Y===JY.b.PositionKind?"POSITION":Y===JY.b.NormalKind?"NORMAL":Y===JY.b.ColorKind?"COLOR":Y.startsWith(JY.b.UVKind)?"TEX_COORD":"GENERIC"}const mc={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Yc extends tY.e{static get DefaultAvailable(){return(0,tY.l)(Yc.DefaultConfiguration)}static get Default(){return Yc._Default??(Yc._Default=new Yc),Yc._Default}static ResetDefault(Y){Yc._Default&&(Y||Yc._Default.dispose(),Yc._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(Y,c){return{module:await(c||DracoEncoderModule)({wasmBinary:Y})}}_getWorkerContent(){return`${FY.e}(${FY.g})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Yc.DefaultConfiguration)}async _encodeAsync(Y,c,h){const C=h?(0,jY.c)(mc,h):mc;if(this._workerPoolPromise){const h=await this._workerPoolPromise;return await new Promise(((E,N)=>{h.push(((h,Q)=>{const b=Y=>{h.removeEventListener("error",b),h.removeEventListener("message",H),N(Y),Q()},H=Y=>{"encodeMeshDone"===Y.data.id&&(h.removeEventListener("error",b),h.removeEventListener("message",H),E(Y.data.encodedMeshData),Q())};h.addEventListener("error",b),h.addEventListener("message",H);const w=[];for(const c of Y)w.push(c.data.buffer);c&&w.push(c.buffer),h.postMessage({id:"encodeMesh",attributes:Y,indices:c,options:C},w)}))}))}if(this._modulePromise){const h=await this._modulePromise;return(0,FY.e)(h.module,Y,c,C)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(Y,c){if(0==Y.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");Y instanceof DY.e&&Y.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===c||void 0===c?void 0:c.method)&&(z.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),c.method="MESH_SEQUENTIAL_ENCODING");const h=function(Y){let c=Y.sc(void 0,!0);return!c||c instanceof Uint32Array||c instanceof Uint16Array||(c=((0,g.e)(c,c.length)?Uint32Array:Uint16Array).from(c)),c}(Y),C=function(Y,c){const h=[];for(const C of Y.getVerticesDataKinds()){if(null!==c&&void 0!==c&&c.includes(C)){if(C===JY.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const E=Y.getVertexBuffer(C),N=E.getSize(),Q=(0,g.r)(E.getData(),N,E.type,E.byteOffset,E.byteStride,E.normalized,Y.getTotalVertices(),!0);h.push({kind:C,dracoName:SY(C),size:N,data:Q})}return h}(Y,null===c||void 0===c?void 0:c.excludedAttributes);return await this._encodeAsync(C,h,c)}}Yc.DefaultConfiguration={wasmUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${E.Tools._DefaultCdnUrl}/draco_encoder.js`},Yc._Default=null;const cc="KHR_draco_mesh_compression";class hc{get wasUsed(){return this._wasUsed}constructor(Y){this.name=cc,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===Y.options.meshCompressionMethod&&Yc.DefaultAvailable}dispose(){}postExportMeshPrimitive(Y,c,h){if(!this.enabled)return;if(4!==Y.mode&&5!==Y.mode)return void z.e.Warn("Cannot compress primitive with mode "+Y.mode+".");const C=[],E=[];let N=null;if(void 0!==Y.indices){const Q=h[Y.indices],b=c.getBufferView(Q);N=c.getData(b).slice(),C.push(b),E.push(Q)}const Q=[];for(const[W,q]of Object.entries(Y.attributes)){const Y=h[q],N=c.getBufferView(Y),H=B(Y.type),w=(0,g.r)(c.getData(N),H,Y.componentType,Y.byteOffset||0,N.byteStride||(0,g.o)(Y.componentType)*H,Y.normalized||!1,Y.count,!0);Q.push({kind:W,dracoName:(b=W,"POSITION"===b?"POSITION":"NORMAL"===b?"NORMAL":b.startsWith("COLOR")?"COLOR":b.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:B(Y.type),data:w}),C.push(N),E.push(Y)}var b;const H={method:Y.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},w=Yc.Default._encodeAsync(Q,N,H).then((h=>{if(!h)return void z.e.Error("Draco encoding failed for primitive.");const N={bufferView:-1,attributes:h.attributeIds},Q=c.createBufferView(h.data);c.setBufferView(N,Q);for(const Y of C)this._bufferViewsUsed.add(Y);for(const Y of E)this._accessorsUsed.add(Y);Y.extensions||(Y.extensions={}),Y.extensions[cc]=N})).catch((Y=>{z.e.Error("Draco encoding failed for primitive: "+Y)}));this._encodePromises.push(w),this._wasUsed=!0}async preGenerateBinaryAsync(Y){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((c=>{Y.getPropertiesWithBufferView(c).every((Y=>this._accessorsUsed.has(Y)))&&Y.removeBufferView(c)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}uY.RegisterExtension(cc,(Y=>new hc(Y)));var Cc=h(13484);const Ec="KHR_lights_punctual",Nc={name:"",color:[1,1,1],Oc:1,range:Number.MAX_VALUE},Qc={innerConeAngle:0,outerConeAngle:Math.PI/4},bc=C.bh.Backward();class Hc{constructor(Y){this.name=Ec,this.enabled=!0,this.required=!1,this._exporter=Y}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Ec]=this._lights}async postExportNodeAsync(Y,c,h,E,N){return await new Promise((Q=>{if(!(h instanceof TY.e))return void Q(c);const b=h.getTypeID()==TY.e.LIGHTTYPEID_POINTLIGHT?"point":h.getTypeID()==TY.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":h.getTypeID()==TY.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!b||!(h instanceof Cc.c))return z.e.Warn(`${Y}: Light ${h.name} is not supported in ${Ec}`),void Q(c);if(h.falloffType!==TY.e.FALLOFF_GLTF&&z.e.Warn(`${Y}: Light falloff for ${h.name} does not match the ${Ec} specification!`),!h.position.equalsToFloats(0,0,0)){const Y=C.TmpVectors.bh[0].N(h.position);N&&j(Y),c.translation=Y.Xc()}if("point"!==b){const Y=h.direction.normalizeToRef(C.TmpVectors.bh[0]);N&&j(Y);const E=C.Quaternion.FromUnitVectorsToRef(bc,Y,C.TmpVectors.Quaternion[0]);C.Quaternion.IsIdentity(E)||(c.rotation=E.Xc())}const H={type:b,name:h.name,color:h.oc.Xc(),Oc:h.Oc,range:h.range};if(CY(H,Nc),"spot"===b){const Y=h;H.spot={innerConeAngle:Y.innerAngle/2,outerConeAngle:Y.angle/2},CY(H.spot,Qc)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(H);const w={Hc:this._lights.lights.length-1},W=h.parent;if(W&&cY(h,W)){const Y=E.get(W);if(Y){const h=this._exporter._nodes[Y];return YY(c,h),h.extensions||(h.extensions={}),h.extensions[Ec]=w,void Q(null)}}c.extensions||(c.extensions={}),c.extensions[Ec]=w,Q(c)}))}}uY.RegisterExtension(Ec,(Y=>new Hc(Y)));var wc=h(13379);const Wc="KHR_materials_anisotropy";class qc{constructor(Y){this.name=Wc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,c,h){const C=[];return h instanceof wc.c&&h.anisotropy.isEnabled&&!h.anisotropy.legacy?(h.anisotropy.texture&&C.push(h.anisotropy.texture),C):[]}postExportMaterialAsync(Y,c,h){return new Promise((Y=>{if(h instanceof wc.c){if(!h.anisotropy.isEnabled||h.anisotropy.legacy)return void Y(c);this._wasUsed=!0,c.extensions=c.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(h.anisotropy.texture),E={anisotropyStrength:h.anisotropy.Oc,anisotropyRotation:h.anisotropy.angle,anisotropyTexture:C??void 0};null!==E.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(h),c.extensions[Wc]=E}Y(c)}))}}uY.RegisterExtension(Wc,(Y=>new qc(Y)));const kc="KHR_materials_clearcoat";class Mc{constructor(Y){this.name=kc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,c,h){const C=[];return h instanceof wc.c&&h.clearCoat.isEnabled?(h.clearCoat.texture&&C.push(h.clearCoat.texture),!h.clearCoat.useRoughnessFromMainTexture&&h.clearCoat.textureRoughness&&C.push(h.clearCoat.textureRoughness),h.clearCoat.bumpTexture&&C.push(h.clearCoat.bumpTexture),C):[]}postExportMaterialAsync(Y,c,h){return new Promise((Y=>{if(h instanceof wc.c){if(!h.clearCoat.isEnabled)return void Y(c);this._wasUsed=!0,c.extensions=c.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(h.clearCoat.texture);let N;N=h.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(h.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(h.clearCoat.textureRoughness),h.clearCoat.isTintEnabled&&E.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${h.name}`),h.clearCoat.remapF0OnInterfaceChange&&E.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${h.name}`);const Q=this._exporter._materialExporter.getTextureInfo(h.clearCoat.bumpTexture),b={clearcoatFactor:h.clearCoat.Oc,clearcoatTexture:C??void 0,clearcoatRoughnessFactor:h.clearCoat.roughness,clearcoatRoughnessTexture:N??void 0,clearcoatNormalTexture:Q??void 0};null===b.clearcoatTexture&&null===b.clearcoatRoughnessTexture&&null===b.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(h),c.extensions[kc]=b}Y(c)}))}}uY.RegisterExtension(kc,(Y=>new Mc(Y)));const pc="KHR_materials_diffuse_transmission";function Pc(Y,c){const h=c.subSurface;let C=null;return h.translucencyIntensityTexture?C=h.translucencyIntensityTexture:h.thicknessTexture&&h.useMaskFromThicknessTexture&&(C=h.thicknessTexture),C&&!h.useGltfStyleTextures?(z.e.Warn(`${Y}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${c.name}`,1),null):C}class yc{constructor(Y){this.name=pc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,c,h){const C=[];if(h instanceof pY.d&&this._isExtensionEnabled(h)){const c=Pc(Y,h);return c&&C.push(c),h.subSurface.translucencyColorTexture&&C.push(h.subSurface.translucencyColorTexture),C}return C}_isExtensionEnabled(Y){if(Y.unlit)return!1;const c=Y.subSurface;return!!c.isTranslucencyEnabled&&(!Y.unlit&&!c.useAlbedoToTintTranslucency&&c.useGltfStyleTextures&&1===c.volumeIndexOfRefraction&&0===c.minimumThickness&&0===c.maximumThickness)}postExportMaterialAsync(Y,c,h){return new Promise((C=>{if(h instanceof pY.d&&this._isExtensionEnabled(h)){this._wasUsed=!0;const C=h.subSurface,E=Pc(Y,h),N=0==C.translucencyIntensity?void 0:C.translucencyIntensity,Q=this._exporter._materialExporter.getTextureInfo(E)??void 0,b=!C.translucencyColor||C.translucencyColor.equalsFloats(1,1,1)?void 0:C.translucencyColor.Xc(),H=this._exporter._materialExporter.getTextureInfo(C.translucencyColorTexture)??void 0,w={diffuseTransmissionFactor:N,diffuseTransmissionTexture:Q,diffuseTransmissionColorFactor:b,diffuseTransmissionColorTexture:H};(Q||H)&&this._exporter._materialNeedsUVsSet.add(h),c.extensions=c.extensions||{},c.extensions[pc]=w}C(c)}))}}uY.RegisterExtension(pc,(Y=>new yc(Y)));const dc="KHR_materials_dispersion";class Dc{constructor(){this.name=dc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Y){if(Y.unlit)return!1;const c=Y.subSurface;return!(!c.isRefractionEnabled&&!c.isDispersionEnabled)}postExportMaterialAsync(Y,c,h){return new Promise((Y=>{if(h instanceof pY.d&&this._isExtensionEnabled(h)){this._wasUsed=!0;const Y={dispersion:h.subSurface.dispersion};c.extensions=c.extensions||{},c.extensions[dc]=Y}Y(c)}))}}uY.RegisterExtension(dc,(()=>new Dc));const Tc="KHR_materials_emissive_strength";class ec{constructor(){this.name=Tc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(Y,c,h){return await new Promise((Y=>{if(!(h instanceof pY.d))return Y(c);const C=h.emissiveColor.Xc(),E=Math.max(...C);if(E>1){this._wasUsed=!0,c.extensions||(c.extensions={});const Y={emissiveStrength:E},C=h.emissiveColor.scale(1/Y.emissiveStrength);c.emissiveFactor=C.Xc(),c.extensions[Tc]=Y}return Y(c)}))}}uY.RegisterExtension(Tc,(Y=>new ec));const rc="KHR_materials_ior";class Xc{constructor(){this.name=rc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Y){return!Y.unlit&&(void 0!=Y.indexOfRefraction&&1.5!=Y.indexOfRefraction)}postExportMaterialAsync(Y,c,h){return new Promise((Y=>{if(h instanceof pY.d&&this._isExtensionEnabled(h)){this._wasUsed=!0;const Y={ior:h.indexOfRefraction};c.extensions=c.extensions||{},c.extensions[rc]=Y}Y(c)}))}}uY.RegisterExtension(rc,(Y=>new Xc));const Zc="KHR_materials_iridescence";class ac{constructor(Y){this.name=Zc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,c,h){const C=[];return h instanceof wc.c&&h.iridescence.isEnabled?(h.iridescence.texture&&C.push(h.iridescence.texture),h.iridescence.thicknessTexture&&h.iridescence.thicknessTexture!==h.iridescence.texture&&C.push(h.iridescence.thicknessTexture),C):[]}postExportMaterialAsync(Y,c,h){return new Promise((Y=>{if(h instanceof wc.c){if(!h.iridescence.isEnabled)return void Y(c);this._wasUsed=!0,c.extensions=c.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(h.iridescence.texture),E=this._exporter._materialExporter.getTextureInfo(h.iridescence.thicknessTexture),N={iridescenceFactor:h.iridescence.Oc,iridescenceIor:h.iridescence.indexOfRefraction,iridescenceThicknessMinimum:h.iridescence.minimumThickness,iridescenceThicknessMaximum:h.iridescence.maximumThickness,iridescenceTexture:C??void 0,iridescenceThicknessTexture:E??void 0};null===N.iridescenceTexture&&null===N.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(h),c.extensions[Zc]=N}Y(c)}))}}uY.RegisterExtension(Zc,(Y=>new ac(Y)));const Gc="KHR_materials_sheen";class Kc{constructor(Y){this.name=Gc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,c,h){return h instanceof pY.d&&h.sheen.isEnabled&&h.sheen.texture?[h.sheen.texture]:[]}async postExportMaterialAsync(Y,c,h){return await new Promise((Y=>{if(h instanceof pY.d){if(!h.sheen.isEnabled)return void Y(c);this._wasUsed=!0,null==c.extensions&&(c.extensions={});const C={sheenColorFactor:h.sheen.color.Xc(),sheenRoughnessFactor:h.sheen.roughness??0};null===C.sheenColorTexture&&null===C.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(h),h.sheen.texture&&(C.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(h.sheen.texture)??void 0),h.sheen.textureRoughness&&!h.sheen.useRoughnessFromMainTexture?C.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(h.sheen.textureRoughness)??void 0:h.sheen.texture&&h.sheen.useRoughnessFromMainTexture&&(C.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(h.sheen.texture)??void 0),c.extensions[Gc]=C}Y(c)}))}}uY.RegisterExtension(Gc,(Y=>new Kc(Y)));const Ic="KHR_materials_specular";class sc{constructor(Y){this.name=Ic,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,c,h){const C=[];return h instanceof pY.d&&this._isExtensionEnabled(h)?(h.metallicReflectanceTexture&&C.push(h.metallicReflectanceTexture),h.reflectanceTexture&&C.push(h.reflectanceTexture),C):C}_isExtensionEnabled(Y){return!Y.unlit&&(void 0!=Y.metallicF0Factor&&1!=Y.metallicF0Factor||void 0!=Y.metallicReflectanceColor&&!Y.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(Y))}_hasTexturesExtension(Y){return null!=Y.metallicReflectanceTexture||null!=Y.reflectanceTexture}postExportMaterialAsync(Y,c,h){return new Promise((Y=>{if(h instanceof pY.d&&this._isExtensionEnabled(h)){this._wasUsed=!0,c.extensions=c.extensions||{};const Y=this._exporter._materialExporter.getTextureInfo(h.metallicReflectanceTexture)??void 0,C=this._exporter._materialExporter.getTextureInfo(h.reflectanceTexture)??void 0,E={specularFactor:1==h.metallicF0Factor?void 0:h.metallicF0Factor,specularTexture:Y,specularColorFactor:h.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:h.metallicReflectanceColor.Xc(),specularColorTexture:C};this._hasTexturesExtension(h)&&this._exporter._materialNeedsUVsSet.add(h),c.extensions[Ic]=E}Y(c)}))}}uY.RegisterExtension(Ic,(Y=>new sc(Y)));const xc="KHR_materials_transmission";class Ac{constructor(Y){this.name=xc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,c,h){const C=[];return h instanceof pY.d&&this._isExtensionEnabled(h)?(h.subSurface.thicknessTexture&&C.push(h.subSurface.thicknessTexture),C):C}_isExtensionEnabled(Y){if(Y.unlit)return!1;const c=Y.subSurface;return c.isRefractionEnabled&&void 0!=c.refractionIntensity&&0!=c.refractionIntensity||this._hasTexturesExtension(Y)}_hasTexturesExtension(Y){return null!=Y.subSurface.refractionIntensityTexture}async postExportMaterialAsync(Y,c,h){if(h instanceof pY.d&&this._isExtensionEnabled(h)){this._wasUsed=!0;const C=h.subSurface,E={transmissionFactor:0===C.refractionIntensity?void 0:C.refractionIntensity};if(this._hasTexturesExtension(h)&&this._exporter._materialNeedsUVsSet.add(h),C.refractionIntensityTexture)if(C.useGltfStyleTextures){const Y=await this._exporter._materialExporter.exportTextureAsync(C.refractionIntensityTexture,"image/png");Y&&(E.transmissionTexture=Y)}else z.e.Warn(`${Y}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);c.extensions||(c.extensions={}),c.extensions[xc]=E}return c}}uY.RegisterExtension(xc,(Y=>new Ac(Y)));const Vc="KHR_materials_unlit";class Uc{constructor(){this.name=Vc,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(Y,c,h){return new Promise((Y=>{let C=!1;h instanceof pY.d?C=h.unlit:h instanceof PY.kh&&(C=h.disableLighting),C&&(this._wasUsed=!0,null==c.extensions&&(c.extensions={}),c.extensions[Vc]={}),Y(c)}))}}uY.RegisterExtension(Vc,(()=>new Uc));const lc="KHR_materials_volume";class nc{constructor(Y){this.name=lc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,c,h){const C=[];return h instanceof pY.d&&this._isExtensionEnabled(h)?(h.subSurface.thicknessTexture&&C.push(h.subSurface.thicknessTexture),C):C}_isExtensionEnabled(Y){if(Y.unlit)return!1;const c=Y.subSurface;return!(!c.isRefractionEnabled&&!c.isTranslucencyEnabled)&&(void 0!=c.maximumThickness&&0!=c.maximumThickness||void 0!=c.tintColorAtDistance&&c.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=c.tintColor&&c.tintColor!=y.ph.White()||this._hasTexturesExtension(Y))}_hasTexturesExtension(Y){return null!=Y.subSurface.thicknessTexture}postExportMaterialAsync(Y,c,h){return new Promise((Y=>{if(h instanceof pY.d&&this._isExtensionEnabled(h)){this._wasUsed=!0;const Y=h.subSurface,C={thicknessFactor:0==Y.maximumThickness?void 0:Y.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(Y.thicknessTexture)??void 0,attenuationDistance:Y.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:Y.tintColorAtDistance,attenuationColor:Y.tintColor.equalsFloats(1,1,1)?void 0:Y.tintColor.Xc()};this._hasTexturesExtension(h)&&this._exporter._materialNeedsUVsSet.add(h),c.extensions=c.extensions||{},c.extensions[lc]=C}Y(c)}))}}uY.RegisterExtension(lc,(Y=>new nc(Y)));const vc="EXT_materials_diffuse_roughness";class gc{constructor(Y){this.name=vc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Y}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Y,c,h){const C=[];return h instanceof wc.c&&h._baseDiffuseRoughness?(h._baseDiffuseRoughnessTexture&&C.push(h._baseDiffuseRoughnessTexture),C):[]}postExportMaterialAsync(Y,c,h){return new Promise((Y=>{if(h instanceof wc.c){if(!h._baseDiffuseRoughness)return void Y(c);this._wasUsed=!0,c.extensions=c.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(h._baseDiffuseRoughnessTexture),E={diffuseRoughnessFactor:h._baseDiffuseRoughness,diffuseRoughnessTexture:C??void 0};null!==E.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(h),c.extensions[vc]=E}Y(c)}))}}uY.RegisterExtension(vc,(Y=>new gc(Y)));const zc="KHR_texture_transform";class Oc{constructor(){this.name=zc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(Y,c,h){if(h.ZY()||E.Tools.Warn(`${Y}: /*@__KEY__*/"scene" is not defined for Babylon texture ${h.name}!`),(0!==h.uAng||0!==h.vAng)&&(E.Tools.Warn(`${Y}: Texture ${h.name} with rotation in the u or v axis is not supported in glTF.`),0!==h.uRotationCenter||0!==h.vRotationCenter))return;const C={};let N=!1;if(0===h.uOffset&&0===h.vOffset||(C.offset=[h.uOffset,h.vOffset],N=!0),1===h.uScale&&1===h.vScale||(C.scale=[h.uScale,h.vScale],N=!0),0!==h.wAng){if(0!==h.uRotationCenter||0!==h.vRotationCenter){if(h.homogeneousRotationInUVTransform&&h.uScale!==h.vScale)return void E.Tools.Warn(`${Y}: Texture ${h.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${zc}.`);E.Tools.Warn(`${Y}: Texture ${h.name} with non-origin rotation center will be exported using an adjusted offset with ${zc}.`),C.offset=function(Y){const{uOffset:c,vOffset:h,uRotationCenter:C,vRotationCenter:E,uScale:N,vScale:Q,wAng:b}=Y,H=Math.cos(b),w=Math.sin(b),W=C*N,q=E*Q;return[c+(W*(1-H)+q*w),h+(q*(1-H)-W*w)]}(h)}C.rotation=-h.wAng,N=!0}0!==h.coordinatesIndex&&(C.texCoord=h.coordinatesIndex,N=!0),N&&(this._wasUsed=!0,c.extensions||(c.extensions={}),c.extensions[zc]=C)}}uY.RegisterExtension(zc,(()=>new Oc));class oc{static CreateSTL(Y){let c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],N=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],Q=arguments.length>5&&void 0!==arguments[5]&&arguments[5],b=arguments.length>6&&void 0!==arguments[6]&&arguments[6],H=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const w=function(Y,c,h){const E=[3*Y[h],3*Y[h+1],3*Y[h+2]],N=[new C.bh(c[E[0]],c[E[0]+2],c[E[0]+1]),new C.bh(c[E[1]],c[E[1]+2],c[E[1]+1]),new C.bh(c[E[2]],c[E[2]+2],c[E[2]+1])],Q=N[0].Hh(N[1]),b=N[2].Hh(N[1]);return{v:N,n:C.bh.Cross(b,Q).normalize()}},q=function(Y,c,h,C){return c=k(Y,c,h.x,C),c=k(Y,c,h.y,C),k(Y,c,h.z,C)},k=function(Y,c,h,C){return Y.setFloat32(c,h,C),c+4},p=function(Y){if(b){let c=Y;Y instanceof M.d&&(c=Y.sourceMesh);const h=c.getVerticesData(W.f.PositionKind,!0,!0);if(!h)return[];const E=C.bh.Zero();let N;for(N=0;N<h.length;N+=3)C.bh.TransformCoordinatesFromFloatsToRef(h[N],h[N+1],h[N+2],Y.Kc(!0),E).toArray(h,N);return h}return Y.getVerticesData(W.f.PositionKind)||[]};b&&(Q=!0);let P="",y=0,d=0;if(E){for(let h=0;h<Y.length;h++){const c=Y[h].sc();y+=c?c.length/3:0}const c=new ArrayBuffer(84+50*y);P=new DataView(c),d+=80,P.setUint32(d,y,N),d+=4}else H||(P="solid stlmesh\r\n");for(let C=0;C<Y.length;C++){const c=Y[C];!E&&H&&(P+="solid "+c.name+"\r\n"),!Q&&c instanceof DY.e&&c.bakeCurrentTransformIntoVertices();const h=p(c),b=c.sc()||[];for(let Y=0;Y<b.length;Y+=3){const c=w(b,h,Y);E?(d=q(P,d,c.n,N),d=q(P,d,c.v[0],N),d=q(P,d,c.v[1],N),d=q(P,d,c.v[2],N),d+=2):(P+="\tfacet normal "+c.n.x+" "+c.n.y+" "+c.n.z+"\r\n",P+="\t\touter loop\r\n",P+="\t\t\tvertex "+c.v[0].x+" "+c.v[0].y+" "+c.v[0].z+"\r\n",P+="\t\t\tvertex "+c.v[1].x+" "+c.v[1].y+" "+c.v[1].z+"\r\n",P+="\t\t\tvertex "+c.v[2].x+" "+c.v[2].y+" "+c.v[2].z+"\r\n",P+="\t\tendloop\r\n",P+="\tendfacet\r\n")}!E&&H&&(P+="endsolid "+name+"\r\n")}if(E||H||(P+="endsolid stlmesh"),c){const Y=document.createElement("a"),c=new Blob([P],{type:"application/octet-stream"});Y.href=window.URL.createObjectURL(c),Y.download=h+".stl",Y.click()}return P}}function fc(Y,c){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const C=[];for(let E=0;E<Y.length/h;E++){const N=Y[E*h],Q=Y[E*h+1],b=Y[E*h+2];C.push(`(${N.toPrecision(c.precision)}, ${Q.toPrecision(c.precision)}, ${b.toPrecision(c.precision)})`)}return C.join(", ")}function Lc(Y,c){const h=[];for(let C=0;C<Y.length/2;C++){const E=Y[2*C],N=Y[2*C+1];h.push(`(${E.toPrecision(c.precision)}, ${(1-N).toPrecision(c.precision)})`)}return h.join(", ")}function uc(Y,c){const h=Y.getVerticesData(W.f.PositionKind),C=Y.getVerticesData(W.f.NormalKind);if(h&&C)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(Y){var c;const h=null!==(c=Y.sc())&&void 0!==c&&c.length?Y.getTotalIndices():Y.getTotalVertices();return Array(h/3).fill(3).join(", ")}(Y)}]\n\t\tint[] faceVertexIndices = [${function(Y){const c=Y.sc(),h=[];if(null!==c)for(let C=0;C<c.length;C++)h.push(c[C]);else{const c=Y.getTotalVertices();for(let Y=0;Y<c;Y++)h.push(Y)}return h.join(", ")}(Y)}]\n\t\tnormal3f[] normals = [${fc(C,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${fc(h,c)}]\n        ${function(Y,c){let h="";for(let E=0;E<4;E++){const C=E>0?E:"",N=Y.getVerticesData(W.f.UVKind+(C?C+1:""));N&&(h+=`\n\t\ttexCoord2f[] primvars:st${C} = [${Lc(N,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const C=Y.getVerticesData(W.f.ColorKind);return C&&(h+=`\n\tcolor3f[] primvars:displayColor = [${fc(C,c,C.length/Y.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),h}(Y,c)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function ic(Y,c){return`\n        def "Geometry"\n        {\n        ${uc(Y,c)}\n        }\n        `}function Rc(Y){let c='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return c+=Y,fflate.strToU8(c)}function Bc(Y){const c=Y.m;return`( ${tc(c,0)}, ${tc(c,4)}, ${tc(c,8)}, ${tc(c,12)} )`}function tc(Y,c){return`(${Y[c+0]}, ${Y[c+1]}, ${Y[c+2]}, ${Y[c+3]})`}function Fc(Y){const c="Object_"+Y.uniqueId,h=function(Y){const c=Y.getWorldMatrix().clone(),h=Y.ZY().useRightHandedSystem;if(!h){let C=Y.parent;for(;C;){if(QY(C,h)){c.multiplyToRef(C.getWorldMatrix().invert(),c);break}C=C.parent}}return c.determinant()<0&&E.Tools.Warn(`Exporting mesh ${Y.name} with negative scale. Result may look incorrect in destination engine.`),c}(Y),C=Bc(h);return`def Xform "${c}" (\n\tprepend references = @./geometries/Geometry_${Y.Ic.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${C}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${Y.material.uniqueId}>\n}\n\n`}function Jc(Y){switch(Y){case Z.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case Z.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case Z.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function jc(Y){return`(${Y.x}, ${Y.y})`}function Sc(Y){return`(${Y.r}, ${Y.g}, ${Y.b})`}function mh(Y,c,h,E,N,Q){const b=Y.getInternalTexture().uniqueId+"_"+Y.invertY;N[b]=Y;const H=Y.coordinatesIndex>0?"st"+Y.coordinatesIndex:"st",w=new C.Vector2(Y.uScale,Y.vScale),W=new C.Vector2(Y.uOffset,Y.vOffset),q=Y.wAng,k=Math.sin(q),M=Math.cos(q);return W.y=1-W.y-w.y,W.x+=k*w.x,W.y+=(1-M)*w.y,`\n    def Shader "PrimvarReader_${h}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${H}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${h}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${c.uniqueId}/PrimvarReader_${h}.outputs:result>\n        float inputs:rotation = ${(q*(180/Math.PI)).toFixed(Q.precision)}\n        float2 inputs:scale = ${jc(w)}\n        float2 inputs:translation = ${jc(W)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${Y.uniqueId}_${h}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${b}.png@\n        float2 inputs:st.connect = </Materials/Material_${c.uniqueId}/Transform2d_${h}.outputs:result>\n        ${E?"float4 inputs:scale = "+function(Y){return`(${Y.r}, ${Y.g}, ${Y.b}, 1.0)`}(E):""}\n        token inputs:sourceColorSpace = "${Y.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Jc(Y.wrapU)}"\n        token inputs:wrapT = "${Jc(Y.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${c.needAlphaBlending()?"float outputs:a":""}\n    }`}function Yh(Y,c,h){const C="\t\t\t",E=[],N=[],{diffuseMap:Q,oc:b,alphaCutOff:H,emissiveMap:w,emissive:W,normalMap:q,roughnessMap:k,roughnessChannel:M,roughness:p,metalnessMap:P,metalnessChannel:d,metalness:D,aoMap:T,aoMapChannel:e,aoMapIntensity:r,alphaMap:X,ior:Z,clearCoatEnabled:a,clearCoat:G,clearCoatMap:K,clearCoatRoughness:I,clearCoatRoughnessMap:s}=function(Y){const c={diffuseMap:null,oc:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return Y instanceof PY.kh?{...c,diffuseMap:Y.diffuseTexture,oc:Y.diffuseColor,alphaCutOff:Y.alphaCutOff,emissiveMap:Y.emissiveTexture,emissive:Y.emissiveColor,roughness:1,alphaMap:Y.opacityTexture}:Y instanceof wc.c?{...c,diffuseMap:Y._albedoTexture,oc:Y._albedoColor,alphaCutOff:Y._alphaCutOff,emissiveMap:Y._emissiveTexture,emissive:Y._emissiveColor,normalMap:Y._bumpTexture,roughnessMap:Y._metallicTexture,roughnessChannel:Y._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:Y._roughness??1,metalnessMap:Y._metallicTexture,metalnessChannel:Y._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:Y._metallic??0,aoMap:Y._ambientTexture,aoMapChannel:Y._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:Y._ambientTextureStrength,alphaMap:Y._opacityTexture,ior:Y.subSurface.indexOfRefraction,clearCoatEnabled:Y.clearCoat.isEnabled,clearCoat:Y.clearCoat.Oc,clearCoatMap:Y.clearCoat.texture,clearCoatRoughness:Y.clearCoat.roughness,clearCoatRoughnessMap:Y.clearCoat.useRoughnessFromMainTexture?Y.clearCoat.texture:Y.clearCoat.textureRoughness}:c}(Y);return null!==Q?(E.push(`${C}color3f inputs:diffuseColor.connect = </Materials/Material_${Y.uniqueId}/Texture_${Q.uniqueId}_diffuse.outputs:rgb>`),Y.needAlphaBlending()?E.push(`${C}float inputs:opacity.connect = </Materials/Material_${Y.uniqueId}/Texture_${Q.uniqueId}_diffuse.outputs:a>`):Y.needAlphaTesting()&&(E.push(`${C}float inputs:opacity.connect = </Materials/Material_${Y.uniqueId}/Texture_${Q.uniqueId}_diffuse.outputs:a>`),E.push(`${C}float inputs:opacityThreshold = ${H}`)),N.push(mh(Q,Y,"diffuse",b,c,h))):E.push(`${C}color3f inputs:diffuseColor = ${Sc(b||y.ph.White())}`),null!==w?(E.push(`${C}color3f inputs:emissiveColor.connect = </Materials/Material_${Y.uniqueId}/Texture_${w.uniqueId}_emissive.outputs:rgb>`),N.push(mh(w,Y,"emissive",W,c,h))):W&&W.toLuminance()>0&&E.push(`${C}color3f inputs:emissiveColor = ${Sc(W)}`),null!==q&&(E.push(`${C}normal3f inputs:normal.connect = </Materials/Material_${Y.uniqueId}/Texture_${q.uniqueId}_normal.outputs:rgb>`),N.push(mh(q,Y,"normal",null,c,h))),null!==T&&(E.push(`${C}float inputs:occlusion.connect = </Materials/Material_${Y.uniqueId}/Texture_${T.uniqueId}_occlusion.outputs:${e}>`),N.push(mh(T,Y,"occlusion",new y.ph(r,r,r),c,h))),null!==k?(E.push(`${C}float inputs:roughness.connect = </Materials/Material_${Y.uniqueId}/Texture_${k.uniqueId}_roughness.outputs:${M}>`),N.push(mh(k,Y,"roughness",new y.ph(p,p,p),c,h))):E.push(`${C}float inputs:roughness = ${p}`),null!==P?(E.push(`${C}float inputs:metallic.connect = </Materials/Material_${Y.uniqueId}/Texture_${P.uniqueId}_metallic.outputs:${d}>`),N.push(mh(P,Y,"metallic",new y.ph(D,D,D),c,h))):E.push(`${C}float inputs:metallic = ${D}`),null!==X?(E.push(`${C}float inputs:opacity.connect = </Materials/Material_${Y.uniqueId}/Texture_${X.uniqueId}_opacity.outputs:r>`),E.push(`${C}float inputs:opacityThreshold = 0.0001`),N.push(mh(X,Y,"opacity",null,c,h))):E.push(`${C}float inputs:opacity = ${Y.alpha}`),a&&(null!==K?(E.push(`${C}float inputs:clearcoat.connect = </Materials/Material_${Y.uniqueId}/Texture_${K.uniqueId}_clearcoat.outputs:r>`),N.push(mh(K,Y,"clearcoat",new y.ph(G,G,G),c,h))):E.push(`${C}float inputs:clearcoat = ${G}`),null!==s?(E.push(`${C}float inputs:clearcoatRoughness.connect = </Materials/Material_${Y.uniqueId}/Texture_${s.uniqueId}_clearcoatRoughness.outputs:g>`),N.push(mh(s,Y,"clearcoatRoughness",new y.ph(I,I,I),c,h))):E.push(`${C}float inputs:clearcoatRoughness = ${I}`)),E.push(`${C}float inputs:ior = ${Z}`),`\n\tdef Material "Material_${Y.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${E.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${Y.uniqueId}/PreviewSurface.outputs:surface>\n\n${N.join("\n")}\n\n\t}\n`}async function ch(Y,c,h){const N={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...c};"undefined"===typeof fflate&&await E.Tools.LoadScriptAsync(N.fflateUrl);const Q={};Q[N.modelFileName]=null;let b='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';b+=function(Y){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===Y.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${Y.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${Y.planeAnchoringAlignment}"`:""}\n            `}(N);const H={};for(const C of Y.meshes){if(0===C.getTotalVertices())continue;const Y=C,c=Y.Ic,w=Y.material;if(!w||!c||h&&!h(Y))continue;if(-1!==["kh","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(w.getClassName())){const h="geometries/Geometry_"+c.uniqueId+".usda";if(!(h in Q)){const Y=ic(c,N);Q[h]=Rc(Y)}w.uniqueId in H||(H[w.uniqueId]=w),b+=Fc(Y)}else E.Tools.Warn("USDZExportAsync does not support this material type: "+w.getClassName())}Y.activeCamera&&N.exportCamera&&(b+=function(Y,c){const h="Camera_"+Y.uniqueId,E=Bc(C.Matrix.RotationY(Math.PI).multiply(Y.getWorldMatrix()));if(Y.mode===Z.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${h}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Y.ac.toPrecision(c.precision)}, ${Y.maxZ.toPrecision(c.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(Y.orthoLeft||1)+Math.abs(Y.orthoRight||1))).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(Y.orthoTop||1)+Math.abs(Y.orthoBottom||1))).toPrecision(c.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const C=Y.getEngine().getAspectRatio(Y),N=c.cameraSensorWidth||35;return`def Camera "${h}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Y.ac.toPrecision(c.precision)}, ${Y.maxZ.toPrecision(c.precision)})\n\t\t\tfloat focalLength = ${(N/(2*Math.tan(.5*Y.fov))).toPrecision(c.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(N*C).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(N/C).toPrecision(c.precision)}            \n\t\t}\n\t\n\t`}}(Y.activeCamera,N)),b+="\n            }\n        }\n    }";const w={};b+=function(Y,c,h){const C=[];for(const E in Y){const N=Y[E];C.push(Yh(N,c,h))}return`\n    def "Materials"\n{\n${C.join("")}\n}\n\n`}(H,w,N),Q[N.modelFileName]=fflate.strToU8(b);for(const C in w){const Y=w[C],c=Y.getSize(),h=await Y.readPixels();if(!h)throw new Error("Texture data is not available");const E=await a.DumpTools.DumpDataAsync(c.width,c.height,h,"image/png",void 0,!1,!0);Q[`textures/Texture_${C}.png`]=new Uint8Array(E).slice()}let W=0;for(const C in Q){const Y=Q[C];if(!Y)continue;W+=34+C.length;const c=63&W;if(4!==c){const h=new Uint8Array(64-c);Q[C]=[Y,{extra:{12345:h}}]}W=Y.length}return fflate.zipSync(Q,{level:0})}}}]);