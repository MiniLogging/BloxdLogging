"use strict";(self.fkqm0epoq5=self.fkqm0epoq5||[]).push([[26],{12134:(D,l,G)=>{G.r(l),G.d(l,{EXT_materials_diffuse_roughness:()=>vl,EXT_mesh_gpu_instancing:()=>mD,GLTF2Export:()=>pD,GLTFData:()=>R,KHR_draco_mesh_compression:()=>Gl,KHR_lights_punctual:()=>tl,KHR_materials_anisotropy:()=>gl,KHR_materials_clearcoat:()=>el,KHR_materials_diffuse_transmission:()=>dl,KHR_materials_dispersion:()=>hl,KHR_materials_emissive_strength:()=>rl,KHR_materials_ior:()=>Ll,KHR_materials_iridescence:()=>Bl,KHR_materials_sheen:()=>Wl,KHR_materials_specular:()=>yl,KHR_materials_transmission:()=>Ol,KHR_materials_unlit:()=>Ul,KHR_materials_volume:()=>ql,KHR_texture_transform:()=>Jl,OBJExport:()=>b,STLExport:()=>Yl,USDZExportAsync:()=>lG,_ConvertToGLTFPBRMetallicRoughness:()=>s,_SolveMetallic:()=>O,__IGLTFExporterExtension:()=>X});var V=G(11710),N=G(11530),M=G(12052);class b{static OBJ(D,l,G,b){const X=[];let t=1,R=1;l&&(G||(G="mat"),X.push("mtllib "+G+".mtl"));for(let n=0;n<D.length;n++){const G=D[n],g=G.name||`mesh${n}}`;X.push(`o ${g}`);let j=null;if(b){const D=G.hb(!0);j=new V.Matrix,D.invertToRef(j),G.bakeTransformIntoVertices(D)}if(l){const D=G.material;D&&X.push("usemtl "+D.id)}const e=G.xb;if(!e){N.Tools.Warn("No geometry is present on the mesh");continue}const K=e.getVerticesData("position"),F=e.getVerticesData("normal"),d=e.getVerticesData("uv"),H=e.rb();let h=0,x=0;if(!K||!H){N.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const r=D[0].uD().useRightHandedSystem?1:-1;for(let D=0;D<K.length;D+=3)X.push("v "+K[D]*r+" "+K[D+1]+" "+K[D+2]),h++;if(null!=F)for(let D=0;D<F.length;D+=3)X.push("vn "+F[D]*r+" "+F[D+1]+" "+F[D+2]);if(null!=d)for(let D=0;D<d.length;D+=2)X.push("vt "+d[D]+" "+d[D+1]),x++;const o=["","",""],L=(G.material||G.uD().defaultMaterial)._getEffectiveOrientation(G),[u,B]=L===M.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let D=0;D<H.length;D+=3){const l=[String(H[D]+t),String(H[D+u]+t),String(H[D+B]+t)],G=[String(H[D]+R),String(H[D+u]+R),String(H[D+B]+R)],V=l,N=null!=d?G:o,M=null!=F?l:o;X.push("f "+V[0]+"/"+N[0]+"/"+M[0]+" "+V[1]+"/"+N[1]+"/"+M[1]+" "+V[2]+"/"+N[2]+"/"+M[2])}b&&j&&G.bakeTransformIntoVertices(j),t+=h,R+=x}return X.join("\n")}static MTL(D){const l=[],G=D.material;l.push("newmtl mat1"),l.push("  Ns "+G.specularPower.toFixed(4)),l.push("  Ni 1.5000"),l.push("  d "+G.alpha.toFixed(4)),l.push("  Tr 0.0000"),l.push("  Tf 1.0000 1.0000 1.0000"),l.push("  illum 2"),l.push("  Ka "+G.ambientColor.r.toFixed(4)+" "+G.ambientColor.g.toFixed(4)+" "+G.ambientColor.b.toFixed(4)),l.push("  Kd "+G.diffuseColor.r.toFixed(4)+" "+G.diffuseColor.g.toFixed(4)+" "+G.diffuseColor.b.toFixed(4)),l.push("  Ks "+G.specularColor.r.toFixed(4)+" "+G.specularColor.g.toFixed(4)+" "+G.specularColor.b.toFixed(4)),l.push("  Ke "+G.emissiveColor.r.toFixed(4)+" "+G.emissiveColor.g.toFixed(4)+" "+G.emissiveColor.b.toFixed(4));G.ambientTexture&&l.push("  map_Ka "+G.ambientTexture.name),G.diffuseTexture&&l.push("  map_Kd "+G.diffuseTexture.name),G.specularTexture&&l.push("  map_Ks "+G.specularTexture.name),G.bumpTexture&&l.push("  map_bump -imfchan z "+G.bumpTexture.name),G.opacityTexture&&l.push("  map_d "+G.opacityTexture.name);return l.join("\n")}}var X=0,t=G(11573);class R{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const D in this.files){const l=this.files[D],G=new Blob([l],{type:(0,t.h)(D)});N.Tools.Download(G,D)}}}var n=G(11788),g=G(12141),j=G(12149),e=G(12171),K=G(11843),F=G(11571),d=G(11755),H=G(11728);const h=H.HighestCommonFactor,x={...H,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:h};var r=G(11948),o=G(11686),L=G(12202),u=G(12208),B=G(11940);const I=1e-6,W=new d.hl(.04,.04,.04),i=1024,y=d.hl.White(),S=d.hl.Black();function O(D,l,G){if(l<W.r)return 0;const V=W.r,N=D*G/(1-W.r)+l-2*W.r,M=N*N-4*V*(W.r-l);return x.Clamp((-N+Math.sqrt(M))/(2*V),0,1)}function s(D){const l=D.diffuseColor.toLinearSpace(D.uD().getEngine().useExactSrgbConversions).scale(.5),G=D.alpha,N=function(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new V.Vector2(0,1),G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new V.Vector2(0,.1),N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new V.Vector2(0,.1),M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new V.Vector2(1300,.1);return function(D,l,G,V,N){return(1-D)*(1-D)*(1-D)*l+3*(1-D)*(1-D)*D*G+3*(1-D)*D*D*V+D*D*D*N}(Math.pow(D/M.x,.333333),l.y,G.y,N.y,M.y)}(x.Clamp(D.specularPower,0,i));return{baseColorFactor:[l.r,l.g,l.b,G],metallicFactor:0,roughnessFactor:N}}function U(D,l){l.needAlphaBlending()?D.alphaMode="BLEND":l.needAlphaTesting()&&(D.alphaMode="MASK",D.alphaCutoff=l.alphaCutOff)}function f(D,l,G){const V=new Uint8Array(D*l*4);for(let N=0;N<V.length;N+=4)V[N]=V[N+1]=V[N+2]=V[N+3]=255;return L.e.CreateRGBATexture(V,D,l,G)}function q(D){if(D instanceof Uint8Array){const l=D.length,G=new Float32Array(D.length);for(let V=0;V<l;++V)G[V]=D[V]/255;return G}if(D instanceof Float32Array)return D;throw new Error("Unsupported pixel format!")}class c{constructor(D){this._exporter=D,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(D){return D?this._textureMap.get(D)??null:null}async exportStandardMaterialAsync(D,l,G){const V=s(D),M={name:D.name};if(null==D.ob||D.ob||(D.twoSidedLighting||N.Tools.Warn(D.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),M.doubleSided=!0),G){const G=[],N=D.diffuseTexture;N&&G.push(this.exportTextureAsync(N,l).then((D=>{D&&(V.baseColorTexture=D)})));const b=D.bumpTexture;b&&G.push(this.exportTextureAsync(b,l).then((D=>{D&&(M.normalTexture=D,1!==b.level&&(M.normalTexture.scale=b.level))})));const X=D.emissiveTexture;X&&(M.emissiveFactor=[1,1,1],G.push(this.exportTextureAsync(X,l).then((D=>{D&&(M.emissiveTexture=D)}))));const t=D.ambientTexture;t&&G.push(this.exportTextureAsync(t,l).then((D=>{if(D){const l={index:D.index};M.occlusionTexture=l}}))),G.length>0&&(this._exporter._materialNeedsUVsSet.add(D),await Promise.all(G))}(D.alpha<1||D.opacityTexture)&&(D.alphaMode===u.e.ALPHA_COMBINE?M.alphaMode="BLEND":N.Tools.Warn(D.name+": glTF 2.0 does not support alpha mode: "+D.alphaMode.toString())),D.emissiveColor&&!D.emissiveColor.equalsWithEpsilon(S,I)&&(M.emissiveFactor=D.emissiveColor.gb()),M.pbrMetallicRoughness=V,U(M,D),await this._finishMaterialAsync(M,D,l);const b=this._exporter._materials;return b.push(M),b.length-1}async _finishMaterialAsync(D,l,G){const V=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",D,l),N=[];for(const M of V)N.push(this.exportTextureAsync(M,G));await Promise.all(N),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",D,l)}async _getImageDataAsync(D,l,V,N){const M=u.e.TEXTURETYPE_UNSIGNED_BYTE,b=this._exporter._babylonScene,X=b.getEngine(),t=X.createRawTexture(D,l,V,u.e.TEXTUREFORMAT_RGBA,!1,!0,o.b.NEAREST_SAMPLINGMODE,null,M);X.isWebGPU?await G.e(51).then(G.bind(G,14160)):await G.e(52).then(G.bind(G,14169)),await r.i.ApplyPostProcess("pass",t,b,M,u.e.TEXTURE_NEAREST_SAMPLINGMODE,u.e.TEXTUREFORMAT_RGBA);const R=await X._readTexturePixels(t,l,V);return await B.DumpTools.DumpDataAsync(l,V,R,N,void 0,!0,!0)}_resizeTexturesToSameDimensions(D,l,G){const V=D?D.getSize():{width:0,height:0},N=l?l.getSize():{width:0,height:0};let M,b;return V.width<N.width?(M=D&&D instanceof o.b?r.i.CreateResizedCopy(D,N.width,N.height,!0):f(N.width,N.height,G),b=l):V.width>N.width?(b=l&&l instanceof o.b?r.i.CreateResizedCopy(l,V.width,V.height,!0):f(V.width,V.height,G),M=D):(M=D,b=l),{texture1:M,texture2:b}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(D,l,G,V){const N=new Array;if(!D&&!l)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const M=D?D.uD():l?l.uD():null;if(M){var b;const X=this._resizeTexturesToSameDimensions(D,l,M),t=null===(b=X.texture1)||void 0===b?void 0:b.getSize();let R,n;const g=t.width,j=t.height,e=await X.texture1.readPixels(),K=await X.texture2.readPixels();if(!e)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(R=q(e),!K)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");n=q(K);const F=n.byteLength,H=new Uint8Array(F),h=new Uint8Array(F),x=4,r=S;let o=0,L=0;for(let D=0;D<j;++D)for(let l=0;l<g;++l){const V=(g*D+l)*x,N={diffuseColor:new d.hl(R[V],R[V+1],R[V+2]).toLinearSpace(M.getEngine().useExactSrgbConversions).multiply(G.diffuseColor),specularColor:new d.hl(n[V],n[V+1],n[V+2]).toLinearSpace(M.getEngine().useExactSrgbConversions).multiply(G.specularColor),glossiness:n[V+3]*G.glossiness},b=this._convertSpecularGlossinessToMetallicRoughness(N);r.r=Math.max(r.r,b.baseColor.r),r.g=Math.max(r.g,b.baseColor.g),r.b=Math.max(r.b,b.baseColor.b),o=Math.max(o,b.metallic),L=Math.max(L,b.roughness),h[V]=255*b.baseColor.r,h[V+1]=255*b.baseColor.g,h[V+2]=255*b.baseColor.b,h[V+3]=X.texture1.eb?255*R[V+3]:255,H[V]=0,H[V+1]=255*b.roughness,H[V+2]=255*b.metallic,H[V+3]=255}const u={baseColor:r,metallic:o,roughness:L};let B=!1,W=!1;for(let D=0;D<j;++D)for(let l=0;l<g;++l){const G=(g*D+l)*x;h[G]/=u.baseColor.r>I?u.baseColor.r:1,h[G+1]/=u.baseColor.g>I?u.baseColor.g:1,h[G+2]/=u.baseColor.b>I?u.baseColor.b:1;const V=d.hl.FromInts(h[G],h[G+1],h[G+2]).toGammaSpace(M.getEngine().useExactSrgbConversions);h[G]=255*V.r,h[G+1]=255*V.g,h[G+2]=255*V.b,V.equalsWithEpsilon(y,I)||(W=!0),H[G+1]/=u.roughness>I?u.roughness:1,H[G+2]/=u.metallic>I?u.metallic:1;d.hl.FromInts(255,H[G+1],H[G+2]).equalsWithEpsilon(y,I)||(B=!0)}return B&&N.push(this._getImageDataAsync(H,g,j,V).then((D=>{u.metallicRoughnessTextureData=D}))),W&&N.push(this._getImageDataAsync(h,g,j,V).then((D=>{u.baseColorTextureData=D}))),await Promise.all(N).then((()=>u))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(D){const l=this._getPerceivedBrightness(D.diffuseColor),G=this._getPerceivedBrightness(D.specularColor),V=1-this._getMaxComponent(D.specularColor),N=O(l,G,V),M=D.diffuseColor.scale(V/(1-W.r)/Math.max(1-N)),b=D.specularColor.Fl(W.scale(1-N)).scale(1/Math.max(N));let X=d.hl.Lerp(M,b,N*N);X=X.clampToRef(0,1,X);return{baseColor:X,metallic:N,roughness:1-D.glossiness}}_getPerceivedBrightness(D){return D?Math.sqrt(.299*D.r*D.r+.587*D.g*D.g+.114*D.b*D.b):0}_getMaxComponent(D){return D?Math.max(D.r,Math.max(D.g,D.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(D,l,G,V){const N=[],M={baseColor:D._albedoColor,metallic:D._metallic,roughness:D._roughness};if(V){D._albedoTexture&&N.push(this.exportTextureAsync(D._albedoTexture,l).then((D=>{D&&(G.baseColorTexture=D)})));const V=D._metallicTexture;V&&N.push(this.exportTextureAsync(V,l).then((D=>{D&&(G.metallicRoughnessTexture=D)})))}return N.length>0&&(this._exporter._materialNeedsUVsSet.add(D),await Promise.all(N)),M}_getTextureSampler(D){const l={};if(!D||!(D instanceof o.b))return l;const G=this._getGLTFTextureWrapMode(D.wrapU);10497!==G&&(l.wrapS=G);const V=this._getGLTFTextureWrapMode(D.wrapV);switch(10497!==V&&(l.wrapT=V),D.samplingMode){case o.b.LINEAR_LINEAR:l.magFilter=9729,l.minFilter=9729;break;case o.b.LINEAR_NEAREST:l.magFilter=9729,l.minFilter=9728;break;case o.b.NEAREST_LINEAR:l.magFilter=9728,l.minFilter=9729;break;case o.b.NEAREST_LINEAR_MIPLINEAR:l.magFilter=9728,l.minFilter=9987;break;case o.b.NEAREST_NEAREST:l.magFilter=9728,l.minFilter=9728;break;case o.b.NEAREST_LINEAR_MIPNEAREST:l.magFilter=9728,l.minFilter=9985;break;case o.b.LINEAR_NEAREST_MIPNEAREST:l.magFilter=9729,l.minFilter=9984;break;case o.b.LINEAR_NEAREST_MIPLINEAR:l.magFilter=9729,l.minFilter=9986;break;case o.b.NEAREST_NEAREST_MIPLINEAR:l.magFilter=9728,l.minFilter=9986;break;case o.b.LINEAR_LINEAR_MIPLINEAR:l.magFilter=9729,l.minFilter=9987;break;case o.b.LINEAR_LINEAR_MIPNEAREST:l.magFilter=9729,l.minFilter=9985;break;case o.b.NEAREST_NEAREST_MIPNEAREST:l.magFilter=9728,l.minFilter=9984}return l}_getGLTFTextureWrapMode(D){switch(D){case o.b.WRAP_ADDRESSMODE:return 10497;case o.b.CLAMP_ADDRESSMODE:return 33071;case o.b.MIRROR_ADDRESSMODE:return 33648;default:return N.Tools.Error(`Unsupported Texture Wrap Mode ${D}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(D,l,G,V){const N={diffuseColor:D._albedoColor,specularColor:D._reflectivityColor,glossiness:D._microSurface},M=D._albedoTexture,b=D._reflectivityTexture,X=D._useMicroSurfaceFromReflectivityMapAlpha;if(b&&!X)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((M||b)&&V){this._exporter._materialNeedsUVsSet.add(D);const V=this._exportTextureSampler(M||b),X=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(M,b,N,l),t=this._exporter._textures;if(X.baseColorTextureData){const D=this._exportImage(`baseColor${t.length}`,l,X.baseColorTextureData);G.baseColorTexture=this._exportTextureInfo(D,V,null===M||void 0===M?void 0:M.coordinatesIndex)}if(X.metallicRoughnessTextureData){const D=this._exportImage(`metallicRoughness${t.length}`,l,X.metallicRoughnessTextureData);G.metallicRoughnessTexture=this._exportTextureInfo(D,V,null===b||void 0===b?void 0:b.coordinatesIndex)}return X}return this._convertSpecularGlossinessToMetallicRoughness(N)}async exportPBRMaterialAsync(D,l,G){const V={},N={name:D.name},M=D.isMetallicWorkflow();if(M){const l=D._albedoColor,G=D.alpha;l&&(V.baseColorFactor=[l.r,l.g,l.b,G])}const b=M?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(D,l,V,G):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(D,l,V,G);await this._setMetallicRoughnessPbrMaterialAsync(b,D,N,V,l,G),await this._finishMaterialAsync(N,D,l);const X=this._exporter._materials;return X.push(N),X.length-1}async _setMetallicRoughnessPbrMaterialAsync(D,l,G,V,M,b){if(U(G,l),D.baseColor.equalsWithEpsilon(y,I)&&x.WithinEpsilon(l.alpha,1,I)||(V.baseColorFactor=[D.baseColor.r,D.baseColor.g,D.baseColor.b,l.alpha]),null!=D.metallic&&1!==D.metallic&&(V.metallicFactor=D.metallic),null!=D.roughness&&1!==D.roughness&&(V.roughnessFactor=D.roughness),null==l.ob||l.ob||(l._twoSidedLighting||N.Tools.Warn(l.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),G.doubleSided=!0),b){const D=[],V=l._bumpTexture;V&&D.push(this.exportTextureAsync(V,M).then((D=>{D&&(G.normalTexture=D,1!==V.level&&(G.normalTexture.scale=V.level))})));const N=l._ambientTexture;N&&D.push(this.exportTextureAsync(N,M).then((D=>{if(D){const V={index:D.index,texCoord:D.texCoord,extensions:D.extensions};G.occlusionTexture=V;const N=l._ambientTextureStrength;N&&(V.strength=N)}})));const b=l._emissiveTexture;b&&D.push(this.exportTextureAsync(b,M).then((D=>{D&&(G.emissiveTexture=D)}))),D.length>0&&(this._exporter._materialNeedsUVsSet.add(l),await Promise.all(D))}const X=l._emissiveColor;X.equalsWithEpsilon(S,I)||(G.emissiveFactor=X.gb()),G.pbrMetallicRoughness=V}_getPixelsFromTextureAsync(D){return function(D){switch(D){case u.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case u.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case u.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case u.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case u.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case u.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case u.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case u.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case u.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case u.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case u.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case u.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case u.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(D.textureFormat)?(0,r.h)(D,D._texture.width,D._texture.height):(D.textureType,u.e.TEXTURETYPE_UNSIGNED_BYTE,D.readPixels())}async exportTextureAsync(D,l){const G=this._exporter._extensionsPreExportTextureAsync("exporter",D,l);return G?await G.then((async G=>G?await this._exportTextureInfoAsync(G,l):await this._exportTextureInfoAsync(D,l))):await this._exportTextureInfoAsync(D,l)}async _exportTextureInfoAsync(D,l){let G=this._textureMap.get(D);if(!G){const V=await this._getPixelsFromTextureAsync(D);if(!V)return null;const M=this._exportTextureSampler(D),b=D.mimeType;if(b)switch(b){case"image/jpeg":case"image/png":case"image/webp":l=b;break;default:N.Tools.Warn(`Unsupported media type: ${b}. Exporting texture as PNG.`)}const X=this._internalTextureToImage,t=D.getInternalTexture().uniqueId;X[t]||(X[t]={});let R=X[t][l];if(void 0===R){const G=D.getSize();R=(async()=>{const N=await this._getImageDataAsync(V,G.width,G.height,l);return this._exportImage(D.name,l,N)})(),X[t][l]=R}G=this._exportTextureInfo(await R,M,D.coordinatesIndex),this._textureMap.set(D,G),this._exporter._extensionsPostExportTextures("exporter",G,D)}return G}_exportImage(D,l,G){const V=this._exporter._images;let M;if(this._exporter._shouldUseGlb){M={name:D,mimeType:l,bufferView:void 0};const V=this._exporter._bufferManager.createBufferView(new Uint8Array(G));this._exporter._bufferManager.setBufferView(M,V)}else{const b=D.replace(/\.\/|\/|\.\\|\\/g,"_"),X=function(D){switch(D){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(l);let t=b+X;V.some((D=>D.uri===t))&&(t=`${b}_${N.Tools.RandomId()}${X}`),M={name:D,uri:t},this._exporter._imageData[t]={data:G,mimeType:l}}return V.push(M),V.length-1}_exportTextureInfo(D,l,G){const V=this._exporter._textures;let N=V.findIndex((G=>G.sampler==l&&G.source===D));-1===N&&(N=V.length,V.push({source:D,sampler:l}));const M={index:N};return G&&(M.texCoord=G),M}_exportTextureSampler(D){const l=this._getTextureSampler(D),G=this._exporter._samplers,V=G.findIndex((D=>D.minFilter===l.minFilter&&D.magFilter===l.magFilter&&D.wrapS===l.wrapS&&D.wrapT===l.wrapT));return-1!==V?V:(G.push(l),G.length-1)}}var v=G(11798),Z=G(11546),J=G(12213),Y=G(11713);const z=V.Kl.Zero(),E=V.Quaternion.Identity(),P=V.Kl.One(),p=new V.Kl(-1,1,1);function k(D,l){const{byteOffset:G,byteStride:V,type:N,normalized:M}=D,b=D.getSize(),X=l.reduce(((D,l)=>l.getTotalVertices()>D?l.getTotalVertices():D),-Number.MAX_VALUE);return{byteOffset:G,byteStride:V,componentCount:b,type:N,count:X*b,normalized:M,totalVertices:X,kind:D.getKind()}}function m(D){switch(D){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function T(D){switch(D){case n.e.PositionKind:case n.e.NormalKind:case n.e.TangentKind:case n.e.ColorKind:case n.e.MatricesIndicesKind:case n.e.MatricesIndicesExtraKind:case n.e.MatricesWeightsKind:case n.e.MatricesWeightsExtraKind:case n.e.UVKind:case n.e.UV2Kind:case n.e.UV3Kind:case n.e.UV4Kind:case n.e.UV5Kind:case n.e.UV6Kind:return!0}return!1}function C(D){switch(D){case M.c.TriangleFillMode:return 4;case M.c.TriangleStripDrawMode:return 5;case M.c.TriangleFanDrawMode:return 6;case M.c.PointListDrawMode:case M.c.PointFillMode:return 0;case M.c.LineLoopDrawMode:return 2;case M.c.LineListDrawMode:return 1;case M.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${D}`)}function w(D){const l=Math.sqrt(D.x*D.x+D.y*D.y+D.z*D.z);l>0&&(D.x/=l,D.y/=l,D.z/=l)}function A(D){return D.x*=-1,D}function a(D){if(D.x*D.x+D.y*D.y>.5){const l=Math.abs(D.x),G=Math.abs(D.y);if(l>G){const G=Math.sign(D.x);D.x=l,D.y*=-G,D.z*=-G,D.w*=G}else{const l=Math.sign(D.y);D.x*=-l,D.y=G,D.z*=l,D.w*=-l}}else{const l=Math.abs(D.z),G=Math.abs(D.w);if(l>G){const G=Math.sign(D.z);D.x*=-G,D.y*=G,D.z=l,D.w*=-G}else{const l=Math.sign(D.w);D.x*=l,D.y*=-l,D.z*=-l,D.w=G}}return D}function Q(D){D.Lb(-D.z,D.w,D.x,-D.y)}function DD(D,l){const G=V.Kl.FromArrayToRef(l.translation||[0,0,0],0,V.TmpVectors.Kl[0]),N=V.Quaternion.FromArrayToRef(l.rotation||[0,0,0,1],0,V.TmpVectors.Quaternion[0]),M=V.Matrix.ComposeToRef(P,N,G,V.TmpVectors.Matrix[0]),b=V.Kl.FromArrayToRef(D.translation||[0,0,0],0,V.TmpVectors.Kl[2]),X=V.Quaternion.FromArrayToRef(D.rotation||[0,0,0,1],0,V.TmpVectors.Quaternion[1]),t=V.Matrix.ComposeToRef(P,X,b,V.TmpVectors.Matrix[1]);M.multiplyToRef(t,t),t.decompose(void 0,N,G),G.equalsWithEpsilon(z,Y.b)?delete l.translation:l.translation=G.gb(),N.equalsWithEpsilon(E,Y.b)?delete l.rotation:l.rotation=N.gb(),l.scale&&delete l.scale}function lD(D,l){if(!(l instanceof g.d))return!1;if(!(1===l.getChildren().length&&0===D.getChildren().length&&D.parent===l))return!1;const G=D.uD(),V=D instanceof J.e&&!G.useRightHandedSystem?p:P;return!!l.ub.equalsWithEpsilon(V,Y.b)||(Z.d.Warn(`Cannot collapse node ${D.name} into parent node ${l.name} with modified scaling.`),!1)}function GD(D){if(D instanceof Array){const l=new Float32Array(D);return new Uint8Array(l.buffer,l.byteOffset,l.byteLength)}return ArrayBuffer.isView(D)?new Uint8Array(D.buffer,D.byteOffset,D.byteLength):new Uint8Array(D)}function VD(D,l){for(const[G,V]of Object.entries(D)){const N=l[G];(Array.isArray(V)&&Array.isArray(N)&&ND(V,N)||V===N)&&delete D[G]}return D}function ND(D,l){return D.length===l.length&&D.every(((D,G)=>D===l[G]))}const MD=V.Matrix.Compose(new V.Kl(-1,1,1),V.Quaternion.Identity(),V.Kl.Zero());function bD(D,l){if(!(D instanceof g.d))return!1;if(l){if(!D.getWorldMatrix().equalsWithEpsilon(V.Matrix.IdentityReadOnly,Y.b))return!1}else{if(!D.getWorldMatrix().multiplyToRef(MD,V.TmpVectors.Matrix[0]).equalsWithEpsilon(V.Matrix.IdentityReadOnly,Y.b))return!1}return!(D instanceof j.d&&D.xb)}const XD=new Map([[Int8Array,(D,l,G)=>D.setInt8(l,G)],[Uint8Array,(D,l,G)=>D.setUint8(l,G)],[Uint8ClampedArray,(D,l,G)=>D.setUint8(l,G)],[Int16Array,(D,l,G)=>D.setInt16(l,G,!0)],[Uint16Array,(D,l,G)=>D.setUint16(l,G,!0)],[Int32Array,(D,l,G)=>D.setInt32(l,G,!0)],[Uint32Array,(D,l,G)=>D.setUint32(l,G,!0)],[Float32Array,(D,l,G)=>D.setFloat32(l,G,!0)],[Float64Array,(D,l,G)=>D.setFloat64(l,G,!0)]]);class tD{writeTypedArray(D){this._checkGrowBuffer(D.byteLength);const l=XD.get(D.constructor);for(let G=0;G<D.length;G++)l(this._dataView,this._byteOffset,D[G]),this._byteOffset+=D.BYTES_PER_ELEMENT}constructor(D){this._data=new Uint8Array(D),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(D){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,D),this._byteOffset++}writeInt8(D){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,D),this._byteOffset++}writeInt16(D){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,D,!0),this._byteOffset+=2}writeUInt16(D){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,D,!0),this._byteOffset+=2}writeInt32(D){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,D,!0),this._byteOffset+=4}writeUInt32(D){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,D,!0),this._byteOffset+=4}writeFloat32(D){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,D,!0),this._byteOffset+=4}writeFloat64(D){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,D,!0),this._byteOffset+=8}_checkGrowBuffer(D){const l=this.byteOffset+D;if(l>this._data.byteLength){const D=new Uint8Array(2*l);D.set(this._data),this._data=D,this._dataView=new DataView(this._data.buffer)}}}function RD(D){return D%4===0?4:D%2===0?2:1}class nD{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(D){let l=0;this._bufferViewToData.forEach((D=>{l+=D.byteLength}));const G=new tD(l),V=Array.from(this._bufferViewToData.keys()).sort(((D,l)=>RD(l.byteLength)-RD(D.byteLength)));for(const N of V){N.byteOffset=G.byteOffset,D.push(N);const l=D.length-1,V=this.getPropertiesWithBufferView(N);for(const D of V)D.bufferView=l;G.writeTypedArray(this._bufferViewToData.get(N)),this._bufferViewToData.delete(N)}return G.getOutputData()}createBufferView(D,l){const G={buffer:0,byteOffset:void 0,byteLength:D.byteLength,byteStride:l};return this._bufferViewToData.set(G,D),G}createAccessor(D,l,G,V,N,M,b){this._verifyBufferView(D);const X={bufferView:void 0,componentType:G,count:V,type:l,min:null===M||void 0===M?void 0:M.min,max:null===M||void 0===M?void 0:M.max,normalized:b,byteOffset:N};return this.setBufferView(X,D),this._accessorToBufferView.set(X,D),X}setBufferView(D,l){this._verifyBufferView(l);this.getPropertiesWithBufferView(l).push(D)}removeBufferView(D){const l=this.getPropertiesWithBufferView(D);for(const G of l)void 0!==G.bufferView&&delete G.bufferView;this._bufferViewToData.delete(D),this._bufferViewToProperties.delete(D),this._accessorToBufferView.forEach(((l,G)=>{l===D&&(void 0!==G.byteOffset&&delete G.byteOffset,this._accessorToBufferView.delete(G))}))}getBufferView(D){const l=this._accessorToBufferView.get(D);return this._verifyBufferView(l),l}getPropertiesWithBufferView(D){return this._verifyBufferView(D),this._bufferViewToProperties.set(D,this._bufferViewToProperties.get(D)??[]),this._bufferViewToProperties.get(D)}getData(D){return this._verifyBufferView(D),this._bufferViewToData.get(D)}_verifyBufferView(D){if(void 0===D||!this._bufferViewToData.has(D))throw new Error(`BufferView ${D} not found in BufferManager.`)}}var gD,jD=G(12175),eD=G(12196),KD=G(12217),FD=G(12102),dD=G(12247),HD=G(12258),hD=G(12173),xD=G(12265);!function(D){D[D.INTANGENT=0]="INTANGENT",D[D.OUTTANGENT=1]="OUTTANGENT"}(gD||(gD={}));class rD{static _IsTransformable(D){return D&&(D instanceof g.d||D instanceof jD.e||D instanceof xD.c)}static _CreateNodeAnimation(D,l,G,V,M){if(this._IsTransformable(D)){const b=[],X=[],t=l.getKeys(),R=rD._CalculateMinMaxKeyFrames(t),n=rD._DeduceInterpolation(t,G,V),g=n.interpolationType,j=n.shouldBakeAnimation;if(j?rD._CreateBakedAnimation(D,l,G,R.min,R.max,l.framePerSecond,M,b,X,R,V):"LINEAR"===g||"STEP"===g?rD._CreateLinearOrStepAnimation(D,l,G,b,X,V):"CUBICSPLINE"===g?rD._CreateCubicSplineAnimation(D,l,G,b,X,V):rD._CreateBakedAnimation(D,l,G,R.min,R.max,l.framePerSecond,M,b,X,R,V),b.length&&X.length){return{inputs:b,outputs:X,samplerInterpolation:g,inputsMin:j?R.min:N.Tools.FloatRound(R.min/l.framePerSecond),inputsMax:j?R.max:N.Tools.FloatRound(R.max/l.framePerSecond)}}}return null}static _DeduceAnimationInfo(D){let l=null,G="VEC3",V=!1;const M=D.targetProperty.split(".");switch(M[0]){case"ub":l="scale";break;case"position":l="translation";break;case"rotation":G="VEC4",l="rotation";break;case"rotationQuaternion":G="VEC4",V=!0,l="rotation";break;case"influence":G="SCALAR",l="weights";break;default:N.Tools.Error(`Unsupported animatable property ${M[0]}`)}return l?{animationChannelTargetPath:l,dataAccessorType:G,useQuaternion:V}:(N.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(D,l,G,V,N,M,b,X,t,R,n){let g;if(rD._IsTransformable(D)&&D.animations)for(const j of D.animations){if(n&&!n(j))continue;const N=rD._DeduceAnimationInfo(j);N&&(g={name:j.name,samplers:[],channels:[]},rD._AddAnimation(`${j.name}`,j.hasRunningRuntimeAnimations?l:g,D,j,N.dataAccessorType,N.animationChannelTargetPath,V,M,b,X,N.useQuaternion,t,R),g.samplers.length&&g.channels.length&&G.push(g))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(D,l,G,V,N,M,b,X,t,R,n){let g;if(D instanceof hD.b){const N=D.morphTargetManager;if(N)for(let j=0;j<N.numTargets;++j){const e=N.getTarget(j);for(const K of e.animations){if(n&&!n(K))continue;const e=new dD.b(`${K.name}`,"influence",K.framePerSecond,K.dataType,K.loopMode,K.enableBlending),F=[],d=K.getKeys();for(let D=0;D<d.length;++D){const l=d[D];for(let D=0;D<N.numTargets;++D)D==j?F.push(l):F.push({frame:l.frame,value:0})}e.setKeys(F);const H=rD._DeduceAnimationInfo(e);H&&(g={name:e.name,samplers:[],channels:[]},rD._AddAnimation(K.name,K.hasRunningRuntimeAnimations?l:g,D,e,H.dataAccessorType,H.animationChannelTargetPath,V,M,b,X,H.useQuaternion,t,R,N.numTargets),g.samplers.length&&g.channels.length&&G.push(g))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(D,l,G,V,N,M,b,X,t){let R;if(D.animationGroups){const g=D.animationGroups;for(const j of g){const g=new Map,e=new Map,K=new Set,F=j.to-j.from;R={name:j.name,channels:[],samplers:[]};for(let l=0;l<j.targetedAnimations.length;++l){const F=j.targetedAnimations[l],d=F.target,H=F.animation;if(t&&!t(H))continue;const h=X.has(d);if(this._IsTransformable(d)||1===d.length&&this._IsTransformable(d[0])){const D=rD._DeduceAnimationInfo(F.animation);if(D){const l=this._IsTransformable(d)?d:this._IsTransformable(d[0])?d[0]:null;l&&rD._AddAnimation(`${H.name}`,R,l,H,D.dataAccessorType,D.animationChannelTargetPath,G,V,N,M,D.useQuaternion,b,h)}}else if(d instanceof HD.e||1===d.length&&d[0]instanceof HD.e){if(rD._DeduceAnimationInfo(F.animation)){const l=d instanceof HD.e?d:d[0];if(l){const G=D.morphTargetManagers.find((D=>{for(let G=0;G<D.numTargets;++G)if(D.getTarget(G)===l)return!0;return!1}));if(G){const V=D.meshes.find((D=>D.morphTargetManager===G));var n;if(V)g.has(V)||g.set(V,new Map),null===(n=g.get(V))||void 0===n||n.set(l,H),K.add(V),e.set(V,H)}}}}}K.forEach((D=>{const l=D.morphTargetManager;let X=null;const t=[],n=e.get(D).getKeys(),K=n.length;for(let G=0;G<K;++G)for(let V=0;V<l.numTargets;++V){const N=l.getTarget(V),M=g.get(D);if(M){const l=M.get(N);l?(X||(X=new dD.b(`${j.name}_${D.name}_MorphWeightAnimation`,"influence",l.framePerSecond,dD.b.ANIMATIONTYPE_FLOAT,l.loopMode,l.enableBlending)),t.push(l.getKeys()[G])):t.push({frame:j.from+F/K*G,value:N.influence,inTangent:n[0].inTangent?0:void 0,outTangent:n[0].outTangent?0:void 0})}}X.setKeys(t);const d=rD._DeduceAnimationInfo(X);d&&rD._AddAnimation(`${j.name}_${D.name}_MorphWeightAnimation`,R,D,X,d.dataAccessorType,d.animationChannelTargetPath,G,V,N,M,d.useQuaternion,b,!1,null===l||void 0===l?void 0:l.numTargets)})),R.channels.length&&R.samplers.length&&l.push(R)}}}static _AddAnimation(D,l,G,N,M,b,X,t,R,n,g,j,e,K){const F=rD._CreateNodeAnimation(G,N,b,g,j);let d,H,h,x,r,o;if(F){if(K){let D=0,l=0;const G=[];for(;F.inputs.length>0;)l=F.inputs.shift(),D%K==0&&G.push(l),D++;F.inputs=G}const D=X.get(G),N=new Float32Array(F.inputs);d=t.createBufferView(N),H=t.createAccessor(d,"SCALAR",5126,F.inputs.length,void 0,{min:[F.inputsMin],max:[F.inputsMax]}),n.push(H),h=n.length-1;const R=new V.Quaternion,g=new V.Kl,j=new V.Kl,L=G instanceof jD.e,u=m(M),B=new Float32Array(F.outputs.length*u);F.outputs.forEach((function(D,l){let G=D;switch(b){case"translation":e&&(V.Kl.FromArrayToRef(D,0,j),A(j),j.toArray(G));break;case"rotation":4===D.length?V.Quaternion.FromArrayToRef(D,0,R):(G=new Array(4),V.Kl.FromArrayToRef(D,0,g),V.Quaternion.FromEulerVectorToRef(g,R)),e&&(a(R),L&&Q(R)),R.toArray(G)}B.set(G,l*u)})),d=t.createBufferView(B),H=t.createAccessor(d,M,5126,F.outputs.length),n.push(H),x=n.length-1,r={interpolation:F.samplerInterpolation,input:h,output:x},l.samplers.push(r),o={sampler:l.samplers.length-1,target:{node:D,path:b}},l.channels.push(o)}}static _CreateBakedAnimation(D,l,G,M,b,X,t,R,n,g,j){let e;const K=V.Quaternion.Identity();let F,d=null,H=null,h=null,x=null,r=null,o=null;g.min=N.Tools.FloatRound(M/X);const L=l.getKeys();for(let V=0,u=L.length;V<u;++V){if(o=null,h=L[V],V+1<u)if(x=L[V+1],h.value.equals&&h.value.equals(x.value)||h.value===x.value){if(0!==V)continue;o=h.frame}else o=x.frame;else{if(r=L[V-1],h.value.equals&&h.value.equals(r.value)||h.value===r.value)continue;o=b}if(o)for(let V=h.frame;V<=o;V+=t){if(F=N.Tools.FloatRound(V/X),F===d)continue;d=F,H=F;const M={key:0,repeatCount:0,loopMode:l.loopMode};e=l._interpolate(V,M),rD._SetInterpolatedValue(D,e,F,l,G,K,R,n,j)}}H&&(g.max=H)}static _ConvertFactorToVector3OrQuaternion(D,l,G,M,b){const X=rD._GetBasePositionRotationOrScale(l,M,b),t=G.targetProperty.split("."),R=t?t[1]:"",n=b?V.Quaternion.xl(X).normalize():V.Kl.xl(X);switch(R){case"x":case"y":case"z":n[R]=D;break;case"w":n.w=D;break;default:N.Tools.Error(`glTFAnimation: Unsupported component name "${R}"!`)}return n}static _SetInterpolatedValue(D,l,G,N,M,b,X,t,R){let n;X.push(G),"weights"!==M?(N.dataType===dD.b.ANIMATIONTYPE_FLOAT&&(l=this._ConvertFactorToVector3OrQuaternion(l,D,N,M,R)),"rotation"===M?(R?b=l:(n=l,V.Quaternion.RotationYawPitchRollToRef(n.y,n.x,n.z,b)),t.push(b.gb())):(n=l,t.push(n.gb()))):t.push([l])}static _CreateLinearOrStepAnimation(D,l,G,V,N,M){for(const b of l.getKeys())V.push(b.frame/l.framePerSecond),rD._AddKeyframeValue(b,l,N,G,D,M)}static _CreateCubicSplineAnimation(D,l,G,V,N,M){l.getKeys().forEach((function(b){V.push(b.frame/l.framePerSecond),rD._AddSplineTangent(gD.INTANGENT,N,G,"CUBICSPLINE",b,M),rD._AddKeyframeValue(b,l,N,G,D,M),rD._AddSplineTangent(gD.OUTTANGENT,N,G,"CUBICSPLINE",b,M)}))}static _GetBasePositionRotationOrScale(D,l,G){let N;if("rotation"===l)if(G){N=(D.rotationQuaternion??V.Quaternion.Identity()).gb()}else{N=(D.rotation??V.Kl.Zero()).gb()}else if("translation"===l){N=(D.position??V.Kl.Zero()).gb()}else{N=(D.ub??V.Kl.One()).gb()}return N}static _AddKeyframeValue(D,l,G,M,b,X){let t;const R=l.dataType;if(R===dD.b.ANIMATIONTYPE_VECTOR3){let l=D.value.gb();if("rotation"===M){const D=V.Kl.xl(l);l=V.Quaternion.RotationYawPitchRoll(D.y,D.x,D.z).gb()}G.push(l)}else if(R===dD.b.ANIMATIONTYPE_FLOAT){if("weights"===M)G.push([D.value]);else if(t=this._ConvertFactorToVector3OrQuaternion(D.value,b,l,M,X),t){if("rotation"===M){const D=X?t:V.Quaternion.RotationYawPitchRoll(t.y,t.x,t.z).normalize();G.push(D.gb())}G.push(t.gb())}}else R===dD.b.ANIMATIONTYPE_QUATERNION?G.push(D.value.normalize().gb()):N.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(D,l,G){let V,N,M=!1;if("rotation"===l&&!G)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let b=0,X=D.length;b<X;++b)if(N=D[b],N.inTangent||N.outTangent)if(V){if("CUBICSPLINE"!==V){V="LINEAR",M=!0;break}}else V="CUBICSPLINE";else if(V){if("CUBICSPLINE"===V||N.interpolation&&1===N.interpolation&&"STEP"!==V){V="LINEAR",M=!0;break}}else V=N.interpolation&&1===N.interpolation?"STEP":"LINEAR";return V||(V="LINEAR"),{interpolationType:V,shouldBakeAnimation:M}}static _AddSplineTangent(D,l,G,N,M,b){let X;const t=D===gD.INTANGENT?M.inTangent:M.outTangent;if("CUBICSPLINE"===N){if("rotation"===G)if(t)if(b)X=t.gb();else{const D=t;X=V.Quaternion.RotationYawPitchRoll(D.y,D.x,D.z).gb()}else X=[0,0,0,0];else X="weights"===G?t?[t]:[0]:t?t.gb():[0,0,0];l.push(X)}}static _CalculateMinMaxKeyFrames(D){let l=1/0,G=-1/0;return D.forEach((function(D){l=Math.min(l,D.frame),G=Math.max(G,D.frame)})),{min:l,max:G}}}function oD(D,l,G,M,b,X){const t={attributes:{},influence:D.influence,name:D.name},R=l.xb;if(!R)return N.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),t;const g=X?-1:1,j=V.Kl.Zero();let e=0,K=0;if(D.hasPositions){const M=D.getPositions(),X=R.getVerticesData(n.e.PositionKind);if(X){const D=new Float32Array(X.length),l=[1/0,1/0,1/0],N=[-1/0,-1/0,-1/0];K=X.length/3,e=0;for(let G=e;G<K;++G){const b=V.Kl.xl(X,3*G);V.Kl.xl(M,3*G).subtractToRef(b,j),j.x*=g,l[0]=Math.min(l[0],j.x),N[0]=Math.max(N[0],j.x),l[1]=Math.min(l[1],j.y),N[1]=Math.max(N[1],j.y),l[2]=Math.min(l[2],j.z),N[2]=Math.max(N[2],j.z),D[3*G]=j.x,D[3*G+1]=j.y,D[3*G+2]=j.z}const R=G.createBufferView(D,12),n=G.createAccessor(R,"VEC3",5126,M.length/3,0,{min:l,max:N});b.push(n),t.attributes.POSITION=b.length-1}else N.Tools.Warn(`Morph target positions for mesh ${l.name} were not exported. Mesh does not have position vertex data`)}if(D.hasNormals){const M=D.getNormals(),X=R.getVerticesData(n.e.NormalKind);if(X){const D=new Float32Array(X.length);K=X.length/3,e=0;for(let G=e;G<K;++G){const l=V.Kl.xl(X,3*G).normalize();V.Kl.xl(M,3*G).normalize().subtractToRef(l,j),D[3*G]=j.x*g,D[3*G+1]=j.y,D[3*G+2]=j.z}const l=G.createBufferView(D,12),N=G.createAccessor(l,"VEC3",5126,M.length/3,0);b.push(N),t.attributes.NORMAL=b.length-1}else N.Tools.Warn(`Morph target normals for mesh ${l.name} were not exported. Mesh does not have normals vertex data`)}if(D.hasTangents){const M=D.getTangents(),X=R.getVerticesData(n.e.TangentKind);if(X){K=X.length/4;const D=new Float32Array(3*K);e=0;for(let G=e;G<K;++G){const l=V.Kl.xl(X,4*G);w(l);const N=V.Kl.xl(M,3*G);w(N),N.subtractToRef(l,j),D[3*G]=j.x*g,D[3*G+1]=j.y,D[3*G+2]=j.z}const l=G.createBufferView(D,12),N=G.createAccessor(l,"VEC3",5126,K,0);b.push(N),t.attributes.TANGENT=b.length-1}else N.Tools.Warn(`Morph target tangents for mesh ${l.name} were not exported. Mesh does not have tangents vertex data`)}if(D.hasColors){const M=D.getColors(),X=R.getVerticesData(n.e.ColorKind),g=R.getVertexBuffer(n.e.ColorKind);if(X&&g){const D=g.getSize();K=X.length/D;const l=new Float32Array(K*D);e=0;for(let G=e;G<K;++G)if(3===D){const N=V.Kl.xl(X,G*D);V.Kl.xl(M,G*D).subtractToRef(N,j),l[3*G]=j.x,l[3*G+1]=j.y,l[3*G+2]=j.z}else if(4===D){const N=new V.Vector4,b=V.Vector4.xl(X,G*D);V.Vector4.xl(M,G*D).subtractToRef(b,N),l[4*G]=N.x,l[4*G+1]=N.y,l[4*G+2]=N.z,l[4*G+3]=N.w}else N.Tools.Warn(`Unsupported number of components for color attribute: ${D}`);const R=G.createBufferView(l,4*D),n=G.createAccessor(R,3===D?"VEC3":"VEC4",5126,K,0);b.push(n),t.attributes.COLOR_0=b.length-1}else N.Tools.Warn(`Morph target colors for mesh ${l.name} were not exported. Mesh does not have colors vertex data`)}return t}var LD=G(12267),uD=G(12123),BD=G(12112),ID=G(11667);class WD{}WD.DEFAULT_COLOR=d.hl.White(),WD.DEFAULT_WIDTH_ATTENUATED=1,WD.DEFAULT_WIDTH=.1;var iD=G(11925),yD=G(12274);class SD{static ConvertPoints(D,l){if(D.length&&Array.isArray(D)&&"number"===typeof D[0])return[D];if(D.length&&Array.isArray(D[0])&&"number"===typeof D[0][0])return D;if(D.length&&!Array.isArray(D[0])&&D[0]instanceof V.Kl){const l=[];for(let G=0;G<D.length;G++){const V=D[G];l.push(V.x,V.y,V.z)}return[l]}if(D.length>0&&Array.isArray(D[0])&&D[0].length>0&&D[0][0]instanceof V.Kl){const l=[],G=D;for(const D of G)l.push(D.flatMap((D=>[D.x,D.y,D.z])));return l}if(D instanceof Float32Array){if(null!==l&&void 0!==l&&l.floatArrayStride){const G=[],V=3*l.floatArrayStride;for(let l=0;l<D.length;l+=V){const N=new Array(V);for(let G=0;G<V;G++)N[G]=D[l+G];G.push(N)}return G}return[Array.from(D)]}if(D.length&&D[0]instanceof Float32Array){const l=[];for(const G of D)l.push(Array.from(G));return l}return[]}static OmitZeroLengthPredicate(D,l,G){const V=[];return l.Fl(D).lengthSquared()>0&&V.push([D,l]),G.Fl(l).lengthSquared()>0&&V.push([l,G]),D.Fl(G).lengthSquared()>0&&V.push([G,D]),0===V.length?null:V}static OmitDuplicatesPredicate(D,l,G,V){const N=[];return SD._SearchInPoints(D,l,V)||N.push([D,l]),SD._SearchInPoints(l,G,V)||N.push([l,G]),SD._SearchInPoints(G,D,V)||N.push([G,D]),0===N.length?null:N}static _SearchInPoints(D,l,G){for(const b of G)for(let G=0;G<b.length;G++){var V,N,M;if(null!==(V=b[G])&&void 0!==V&&V.equals(D))if(null!==(N=b[G+1])&&void 0!==N&&N.equals(l)||null!==(M=b[G-1])&&void 0!==M&&M.equals(l))return!0}return!1}static MeshesToLines(D,l){const G=[];for(let N=0;N<D.length;N++){const M=D[N],b=M.getVerticesData(n.e.PositionKind),X=M.rb();if(b&&X)for(let D=0,t=0;D<X.length;D++){const R=3*X[t++],n=3*X[t++],g=3*X[t++],j=new V.Kl(b[R],b[R+1],b[R+2]),e=new V.Kl(b[n],b[n+1],b[n+2]),K=new V.Kl(b[g],b[g+1],b[g+2]);if(l){const V=l(j,e,K,G,D,R,M,N,b,X);if(V)for(const D of V)G.push(D)}else G.push([j,e],[e,K],[K,j])}}return G}static ToVector3Array(D){if(Array.isArray(D[0])){const l=[],G=D;for(const D of G){const G=[];for(let l=0;l<D.length;l+=3)G.push(new V.Kl(D[l],D[l+1],D[l+2]));l.push(G)}return l}const l=D,G=[];for(let N=0;N<l.length;N+=3)G.push(new V.Kl(l[N],l[N+1],l[N+2]));return G}static ToNumberArray(D){return D.flatMap((D=>[D.x,D.y,D.z]))}static GetPointsCountInfo(D){const l=new Array(D.length);let G=0;for(let V=D.length;V--;)l[V]=D[V].length/3,G+=l[V];return{total:G,counts:l}}static GetLineLength(D){if(0===D.length)return 0;let l;l="number"===typeof D[0]?SD.ToVector3Array(D):D;const G=V.TmpVectors.Kl[0];let N=0;for(let V=0;V<l.length-1;V++){const D=l[V];N+=l[V+1].subtractToRef(D,G).length()}return N}static GetLineLengthArray(D){const l=new Float32Array(D.length/3);let G=0;for(let V=0,N=D.length/3-1;V<N;V++){let N=D[3*V+0],M=D[3*V+1],b=D[3*V+2];N-=D[3*V+3],M-=D[3*V+4],b-=D[3*V+5];G+=Math.sqrt(N*N+M*M+b*b),l[V+1]=G}return l}static SegmentizeSegmentByCount(D,l,G){const N=[],M=l.Fl(D),b=V.TmpVectors.Kl[0];b.Ib(G);const X=V.TmpVectors.Kl[1];M.divideToRef(b,X);let t=D.clone();N.push(t);for(let V=0;V<G;V++)t=t.clone(),N.push(t.addInPlace(X));return N}static SegmentizeLineBySegmentLength(D,l){const G=D[0]instanceof V.Kl?SD.GetLineSegments(D):"number"===typeof D[0]?SD.GetLineSegments(SD.ToVector3Array(D)):D,N=[];for(const V of G)if(V.length>l){const D=SD.SegmentizeSegmentByCount(V.point1,V.point2,Math.ceil(V.length/l));for(const l of D)N.push(l)}else N.push(V.point1),N.push(V.point2);return N}static SegmentizeLineBySegmentCount(D,l){const G="number"===typeof D[0]?SD.ToVector3Array(D):D,V=SD.GetLineLength(G)/l;return SD.SegmentizeLineBySegmentLength(G,V)}static GetLineSegments(D){const l=[];for(let G=0;G<D.length-1;G++){const V=D[G],N=D[G+1],M=N.Fl(V).length();l.push({point1:V,point2:N,length:M})}return l}static GetMinMaxSegmentLength(D){const l=SD.GetLineSegments(D).sort((D=>D.length));return{min:l[0].length,max:l[l.length-1].length}}static GetPositionOnLineByVisibility(D,l,G){let N=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const M=l*G;let b=0,X=0;const t=D.length;for(let V=0;V<t;V++){if(M<=b+D[V].length){X=V;break}b+=D[V].length}const R=(M-b)/D[X].length;return D[X].point2.subtractToRef(D[X].point1,V.TmpVectors.Kl[0]),V.TmpVectors.Kl[1]=V.TmpVectors.Kl[0].multiplyByFloats(R,R,R),N||V.TmpVectors.Kl[1].addInPlace(D[X].point1),V.TmpVectors.Kl[1].clone()}static GetCircleLinePoints(D,l){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:D,M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/l;const b=[];for(let X=0;X<=l;X++)b.push(new V.Kl(Math.cos(X*M)*D,Math.sin(X*M)*N,G));return b}static GetBezierLinePoints(D,l,G,V){return iD.e.CreateQuadraticBezier(D,l,G,V).getPoints().flatMap((D=>[D.x,D.y,D.z]))}static GetArrowCap(D,l,G,V,N){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,b=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[D.clone(),D.add(l.multiplyByFloats(G,G,G))],widths:[V,N,M,b]}}static GetPointsFromText(D,l,G,V){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,M=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const b=[],X=(0,yD.d)(D,l,G,V);for(const t of X){for(const D of t.paths){const l=[],G=D.getPoints();for(const D of G)l.push(D.x,D.y,N);b.push(l)}if(M)for(const D of t.holes){const l=[],G=D.getPoints();for(const D of G)l.push(D.x,D.y,N);b.push(l)}}return b}static Color3toRGBAUint8(D){const l=new Uint8Array(4*D.length);for(let G=0,V=0;G<D.length;G++)l[V++]=255*D[G].r,l[V++]=255*D[G].g,l[V++]=255*D[G].b,l[V++]=255;return l}static CreateColorsTexture(D,l,G,V){const N=V.getEngine().getCaps().maxTextureSize??1,M=l.length>N?N:l.length,b=Math.ceil(l.length/N);b>1&&(l=[...l,...Array(M*b-l.length).fill(l[0])]);const X=SD.Color3toRGBAUint8(l),t=new L.e(X,M,b,K.e.TEXTUREFORMAT_RGBA,V,!1,!0,G);return t.name=D,t}static PrepareEmptyColorsTexture(D){if(!WD.EmptyColorsTexture){const l=new Uint8Array(4);WD.EmptyColorsTexture=new L.e(l,1,1,K.e.TEXTUREFORMAT_RGBA,D,!1,!1,L.e.NEAREST_NEAREST),WD.EmptyColorsTexture.name="grlEmptyColorsTexture"}return WD.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var D;null===(D=WD.EmptyColorsTexture)||void 0===D||D.dispose(),WD.EmptyColorsTexture=null}static BooleanToNumber(D){return D?1:0}}class OD extends BD.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class sD extends uD.d{isCompatible(D){return!0}constructor(D,l,G){var N;G=G||{color:WD.DEFAULT_COLOR};const M=new OD;M.GREASED_LINE_HAS_COLOR=!!G.color&&!G.useColors,M.GREASED_LINE_SIZE_ATTENUATION=G.sizeAttenuation??!1,M.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===G.colorDistributionType,M.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(l??D.uD()).useRightHandedSystem,M.GREASED_LINE_CAMERA_FACING=G.cameraFacing??!0,super(D,sD.GREASED_LINE_MATERIAL_NAME,200,M,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(N=G)||void 0===N?void 0:N.forceGLSL)||sD.ForceGLSL,this._scene=l??D.uD(),this._engine=this._scene.getEngine(),this._cameraFacing=G.cameraFacing??!0,this.visibility=G.visibility??1,this.useDash=G.useDash??!1,this.dashRatio=G.dashRatio??.5,this.dashOffset=G.dashOffset??0,this.width=G.width?G.width:G.sizeAttenuation?WD.DEFAULT_WIDTH_ATTENUATED:WD.DEFAULT_WIDTH,this._sizeAttenuation=G.sizeAttenuation??!1,this.colorMode=G.colorMode??0,this._color=G.color??null,this.useColors=G.useColors??!1,this._colorsDistributionType=G.colorDistributionType??0,this.colorsSampling=G.colorsSampling??L.e.NEAREST_NEAREST,this._colors=G.iD??null,this.dashCount=G.dashCount??1,this.resolution=G.resolution??new V.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),G.colorsTexture?this.colorsTexture=G.colorsTexture:this._colors?this.colorsTexture=SD.CreateColorsTexture(`${D.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??WD.DEFAULT_COLOR,SD.PrepareEmptyColorsTexture(this._scene)),this._engine.Vb.add((()=>{SD.DisposeEmptyColorsTexture()}))}getAttributes(D){D.push("grl_offsets"),D.push("grl_widths"),D.push("grl_colorPointers"),D.push("grl_counters"),this._cameraFacing?(D.push("grl_previousAndSide"),D.push("grl_nextAndCounters")):D.push("grl_slopes")}getSamplers(D){D.push("grl_colors")}getActiveTextures(D){this.colorsTexture&&D.push(this.colorsTexture)}getUniforms(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const l=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&l.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===D&&l.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:l,vertex:this._cameraFacing&&this._isGLSL(D)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(D)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(D){if(this._cameraFacing){D.Hb("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||D.Hb("viewProjection",this._scene.getTransformMatrix());const l=V.TmpVectors.Vector4[0];l.x=this._aspect,l.y=this._resolution.x,l.z=this._resolution.y,l.w=this.width,D.updateVector4("grl_aspect_resolution_lineWidth",l)}const l=V.TmpVectors.Vector4[0];l.x=SD.BooleanToNumber(this.useDash),l.y=this._dashArray,l.z=this.dashOffset,l.w=this.dashRatio,D.updateVector4("grl_dashOptions",l);const G=V.TmpVectors.Vector4[1];G.x=this.colorMode,G.y=this.visibility,G.z=this.colorsTexture?this.colorsTexture.getSize().width:0,G.w=SD.BooleanToNumber(this.useColors),D.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",G),this._color&&D.updateColor3("grl_singleColor",this._color);const N=this.colorsTexture??WD.EmptyColorsTexture;D.setTexture("grl_colors",N),D.updateFloat2("grl_textureSize",(null===N||void 0===N?void 0:N.getSize().width)??1,(null===N||void 0===N?void 0:N.getSize().height)??1)}prepareDefines(D,l,G){D.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,D.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,D.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,D.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=l.useRightHandedSystem,D.GREASED_LINE_CAMERA_FACING=this._cameraFacing,D.GREASED_LINE_USE_OFFSETS=!!G.offsets}getClassName(){return sD.GREASED_LINE_MATERIAL_NAME}getCustomCode(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(l)?function(D,l){if("vertex"===D){const D={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return l&&(D["!gl_Position\\=viewProjection\\*worldPos;"]="//"),D}return"fragment"===D?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(D,this._cameraFacing):function(D,l){if("vertex"===D){const D={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return l&&(D["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),D}return"fragment"===D?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(D,this._cameraFacing)}dispose(){var D;null===(D=this.colorsTexture)||void 0===D||D.dispose(),super.dispose()}get iD(){return this._colors}set iD(D){this.setColors(D)}setColors(D){var l;let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const N=(null===(l=this._colors)||void 0===l?void 0:l.length)??0;var M;if(this._colors=D,null!==D&&0!==D.length){if(!G||V)if(this.colorsTexture&&N===D.length&&!V){const l=SD.Color3toRGBAUint8(D);this.colorsTexture.update(l)}else{var b;null===(b=this.colorsTexture)||void 0===b||b.dispose(),this.colorsTexture=SD.CreateColorsTexture(`${this._material.name}-colors-texture`,D,this.colorsSampling,this._scene)}}else null===(M=this.colorsTexture)||void 0===M||M.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(D){this._dashCount=D,this._dashArray=1/D}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(D){this._sizeAttenuation=D,this.markAllDefinesAsDirty()}get color(){return this._color}set color(D){this.setColor(D)}setColor(D){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==D||null!==this._color&&null===D?(this._color=D,l||this.markAllDefinesAsDirty()):this._color=D}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(D){this._colorsDistributionType=D,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(D){this._aspect=D.x/D.y,this._resolution=D}serialize(){const D=super.serialize(),l={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(l.iD=this._colors),this._color&&(l.color=this._color),D.greasedLineMaterialOptions=l,D}parse(D,l,G){var V;super.parse(D,l,G);const N=D.greasedLineMaterialOptions;null===(V=this.colorsTexture)||void 0===V||V.dispose(),N.color&&this.setColor(N.color,!0),N.colorDistributionType&&(this.colorsDistributionType=N.colorDistributionType),N.iD&&(this.iD=N.iD),N.colorsSampling&&(this.colorsSampling=N.colorsSampling),N.colorMode&&(this.colorMode=N.colorMode),N.useColors&&(this.useColors=N.useColors),N.visibility&&(this.visibility=N.visibility),N.useDash&&(this.useDash=N.useDash),N.dashCount&&(this.dashCount=N.dashCount),N.dashRatio&&(this.dashRatio=N.dashRatio),N.dashOffset&&(this.dashOffset=N.dashOffset),N.width&&(this.width=N.width),N.sizeAttenuation&&(this.sizeAttenuation=N.sizeAttenuation),N.resolution&&(this.resolution=N.resolution),this.iD?this.colorsTexture=SD.CreateColorsTexture(`${this._material.name}-colors-texture`,this.iD,this.colorsSampling,l):SD.PrepareEmptyColorsTexture(l),this.markAllDefinesAsDirty()}copyTo(D){var l;const G=D;null===(l=G.colorsTexture)||void 0===l||l.dispose(),this._colors&&(G.colorsTexture=SD.CreateColorsTexture(`${G._material.name}-colors-texture`,this._colors,G.colorsSampling,this._scene)),G.setColor(this.color,!0),G.colorsDistributionType=this.colorsDistributionType,G.colorsSampling=this.colorsSampling,G.colorMode=this.colorMode,G.useColors=this.useColors,G.visibility=this.visibility,G.useDash=this.useDash,G.dashCount=this.dashCount,G.dashRatio=this.dashRatio,G.dashOffset=this.dashOffset,G.width=this.width,G.sizeAttenuation=this.sizeAttenuation,G.resolution=this.resolution,G.markAllDefinesAsDirty()}_isGLSL(D){return 0===D||this._forceGLSL}}sD.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",sD.ForceGLSL=!1,(0,ID.c)(`BABYLON.${sD.GREASED_LINE_MATERIAL_NAME}`,sD);var UD=G(12155),fD=G(11551),qD=G(11955),cD=G(11649);class vD extends qD.ShaderMaterial{constructor(D,l,N){const M=l.getEngine(),b=M.isWebGPU&&!(N.forceGLSL||vD.ForceGLSL),X=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];l.useRightHandedSystem&&X.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const t=["position","grl_widths","grl_offsets","grl_colorPointers"];N.cameraFacing?(X.push("GREASED_LINE_CAMERA_FACING"),t.push("grl_previousAndSide","grl_nextAndCounters")):(t.push("grl_slopes"),t.push("grl_counters"));const R=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(b||R.push("world","viewProjection","view","projection"),super(D,l,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:b?["Scene","Mesh"]:void 0,attributes:t,uniforms:R,samplers:b?[]:["grlColors"],defines:X,extraInitializationsAsync:async()=>{b?await Promise.all([G.e(66).then(G.bind(G,14782)),G.e(75).then(G.bind(G,14784))]):await Promise.all([G.e(69).then(G.bind(G,14789)),G.e(76).then(G.bind(G,14794))])},shaderLanguage:b?1:0}),this._color=d.hl.White(),this._colorsDistributionType=0,this._colorsTexture=null,N=N||{color:WD.DEFAULT_COLOR},this.visibility=N.visibility??1,this.useDash=N.useDash??!1,this.dashRatio=N.dashRatio??.5,this.dashOffset=N.dashOffset??0,this.dashCount=N.dashCount??1,this.width=N.width?N.width:N.sizeAttenuation&&N.cameraFacing?WD.DEFAULT_WIDTH_ATTENUATED:WD.DEFAULT_WIDTH,this.sizeAttenuation=N.sizeAttenuation??!1,this.color=N.color??d.hl.White(),this.useColors=N.useColors??!1,this.colorsDistributionType=N.colorDistributionType??0,this.colorsSampling=N.colorsSampling??L.e.NEAREST_NEAREST,this.colorMode=N.colorMode??0,this._colors=N.iD??null,this._cameraFacing=N.cameraFacing??!0,this.resolution=N.resolution??new V.Vector2(M.getRenderWidth(),M.getRenderHeight()),N.colorsTexture?this.colorsTexture=N.colorsTexture:this._colors?this.colorsTexture=SD.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,l):(this._color=this._color??WD.DEFAULT_COLOR,this.colorsTexture=SD.PrepareEmptyColorsTexture(l)),b){const D=new cD.e;D.setParameters(),D.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",D)}M.Vb.add((()=>{SD.DisposeEmptyColorsTexture()}))}dispose(){var D;null===(D=this._colorsTexture)||void 0===D||D.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new V.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get iD(){return this._colors}set iD(D){this.setColors(D)}setColors(D){var l;let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const N=(null===(l=this._colors)||void 0===l?void 0:l.length)??0;var M;if(this._colors=D,null!==D&&0!==D.length){if(!G||V)if(this._colorsTexture&&N===D.length&&!V){const l=SD.Color3toRGBAUint8(D);this._colorsTexture.update(l)}else{var b;null===(b=this._colorsTexture)||void 0===b||b.dispose(),this.colorsTexture=SD.CreateColorsTexture(`${this.name}-colors-texture`,D,this.colorsSampling,this.uD())}}else null===(M=this._colorsTexture)||void 0===M||M.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(D){this._colorsTexture=D,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(D){this._width=D,this.setFloat("grlWidth",D)}get useColors(){return this._useColors}set useColors(D){this._useColors=D,this.setFloat("grlUseColors",SD.BooleanToNumber(D))}get colorsSampling(){return this._colorsSampling}set colorsSampling(D){this._colorsSampling=D}get visibility(){return this._visibility}set visibility(D){this._visibility=D,this.setFloat("grlVisibility",D)}get useDash(){return this._useDash}set useDash(D){this._useDash=D,this.setFloat("grlUseDash",SD.BooleanToNumber(D))}get dashOffset(){return this._dashOffset}set dashOffset(D){this._dashOffset=D,this.setFloat("grlDashOffset",D)}get dashRatio(){return this._dashRatio}set dashRatio(D){this._dashRatio=D,this.setFloat("grlDashRatio",D)}get dashCount(){return this._dashCount}set dashCount(D){this._dashCount=D,this._dashArray=1/D,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(D){this._sizeAttenuation=D,this.setFloat("grlSizeAttenuation",SD.BooleanToNumber(D))}get color(){return this._color}set color(D){this.setColor(D)}setColor(D){D=D??WD.DEFAULT_COLOR,this._color=D,this.setColor3("grlColor",D)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(D){this._colorsDistributionType=D,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(D){this._colorMode=D,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(D){this._resolution=D,this.setVector2("grlResolution",D),this.setFloat("grlAspect",D.x/D.y)}serialize(){const D=super.serialize(),l={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(l.iD=this._colors),D.greasedLineMaterialOptions=l,D}parse(D,l,G){var V;const N=D.greasedLineMaterialOptions;null===(V=this._colorsTexture)||void 0===V||V.dispose(),N.color&&(this.color=N.color),N.colorDistributionType&&(this.colorsDistributionType=N.colorDistributionType),N.colorsSampling&&(this.colorsSampling=N.colorsSampling),N.colorMode&&(this.colorMode=N.colorMode),N.useColors&&(this.useColors=N.useColors),N.visibility&&(this.visibility=N.visibility),N.useDash&&(this.useDash=N.useDash),N.dashCount&&(this.dashCount=N.dashCount),N.dashRatio&&(this.dashRatio=N.dashRatio),N.dashOffset&&(this.dashOffset=N.dashOffset),N.width&&(this.width=N.width),N.sizeAttenuation&&(this.sizeAttenuation=N.sizeAttenuation),N.resolution&&(this.resolution=N.resolution),N.iD?this.colorsTexture=SD.CreateColorsTexture(`${this.name}-colors-texture`,N.iD,this.colorsSampling,this.uD()):this.colorsTexture=SD.PrepareEmptyColorsTexture(l),this._cameraFacing=N.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var ZD,JD,YD;vD.ForceGLSL=!1,function(D){D[D.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",D[D.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(ZD||(ZD={})),function(D){D[D.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",D[D.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",D[D.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(JD||(JD={})),function(D){D[D.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",D[D.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",D[D.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",D[D.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",D[D.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(YD||(YD={}));class zD extends hD.b{constructor(D,l,G){super(D,l,null,null,!1,!1),this.name=D,this._options=G,this._lazy=!1,this._updatable=!1,this._engine=l.getEngine(),this._lazy=G.lazy??!1,this._updatable=G.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=G.colorPointers??[],this._widths=G.widths??new Array(G.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(D){let l=0;for(const V of this._points)l+=V.length;const G=l/3*2-this._widths.length;for(let V=0;V<G;V++)this._widths.push(D)}updateLazy(){var D,l;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(D=this._options.ribbonOptions)||void 0===D?void 0:D.smoothShading),!this.sD&&this.refreshBoundingInfo(),null===(l=this.greasedLineMaterial)||void 0===l||l.updateLazy()}addPoints(D,l){for(const G of D)this._points.push(G);this._lazy||this.setPoints(this._points,l)}dispose(D){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(D,l)}isLazy(){return this._lazy}get yD(){return this._uvs}set yD(D){this._uvs=D instanceof Float32Array?D:new Float32Array(D),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(D){this.material instanceof vD&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===D||void 0===D?void 0:D.length)>0),this._offsets=D,this._offsetsBuffer?this._offsetsBuffer.update(D):this._createOffsetsBuffer(D)}get widths(){return this._widths}set widths(D){this._widths=D,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(D)}get colorPointers(){return this._colorPointers}set colorPointers(D){this._colorPointers=D,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(D)}get greasedLineMaterial(){var D,l;if(this.material&&this.material instanceof vD)return this.material;const G=null===(D=this.material)||void 0===D||null===(l=D.pluginManager)||void 0===l?void 0:l.getPlugin(sD.GREASED_LINE_MATERIAL_NAME);return G||void 0}get points(){const D=[];return fD.e.DeepCopy(this._points,D),D}setPoints(D,l){this._points=SD.ConvertPoints(D,(null===l||void 0===l?void 0:l.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==l&&void 0!==l&&l.colorPointers||this._updateColorPointers(),this._setPoints(this._points,l)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,yD:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(D){super.serialize(D),D.type=this.getClassName(),D.lineOptions=this._createLineOptions()}_createVertexBuffers(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=new UD.d;return l.ID=this._vertexPositions,l.indices=this._indices,l.yD=this._uvs,D&&(l.WD=[],UD.d.ComputeNormals(this._vertexPositions,this._indices,l.WD)),l.OD(this,this._options.updatable),l}_createOffsetsBuffer(D){const l=this._scene.getEngine(),G=new n.d(l,D,this._updatable,3);this.setVerticesBuffer(G.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=G}}class ED{constructor(D,l){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=D,this.wasAddedByNoopNode=l}getIndicesAccessor(D,l,G,V,N){var M,b,X,t;return null===(M=this._indicesAccessorMap.get(D))||void 0===M||null===(b=M.get(l))||void 0===b||null===(X=b.get(G))||void 0===X||null===(t=X.get(V))||void 0===t?void 0:t.get(N)}setIndicesAccessor(D,l,G,V,N,M){let b=this._indicesAccessorMap.get(D);b||(b=new Map,this._indicesAccessorMap.set(D,b));let X=b.get(l);X||(X=new Map,b.set(l,X));let t=X.get(G);t||(t=new Map,X.set(G,t));let R=t.get(V);R||(R=new Map,t.set(V,R)),R.set(N,M)}pushExportedNode(D){this._exportedNodes.has(D)||this._exportedNodes.add(D)}getNodesSet(){return this._exportedNodes}getVertexBufferView(D){return this._vertexBufferViewMap.get(D)}setVertexBufferView(D,l){this._vertexBufferViewMap.set(D,l)}setRemappedBufferView(D,l,G){this._remappedBufferView.set(D,new Map),this._remappedBufferView.get(D).set(l,G)}getRemappedBufferView(D,l){var G;return null===(G=this._remappedBufferView.get(D))||void 0===G?void 0:G.get(l)}getVertexAccessor(D,l,G){var V,N;return null===(V=this._vertexAccessorMap.get(D))||void 0===V||null===(N=V.get(l))||void 0===N?void 0:N.get(G)}setVertexAccessor(D,l,G,V){let N=this._vertexAccessorMap.get(D);N||(N=new Map,this._vertexAccessorMap.set(D,N));let M=N.get(l);M||(M=new Map,N.set(l,M)),M.set(G,V)}hasVertexColorAlpha(D){return this._vertexMapColorAlpha.get(D)||!1}setHasVertexColorAlpha(D,l){return this._vertexMapColorAlpha.set(D,l)}getMesh(D){return this._meshMap.get(D)}setMesh(D,l){this._meshMap.set(D,l)}bindMorphDataToMesh(D,l){const G=this._meshMorphTargetMap.get(D)||[];this._meshMorphTargetMap.set(D,G),-1===G.indexOf(l)&&G.push(l)}getMorphTargetsFromMesh(D){return this._meshMorphTargetMap.get(D)}}class PD{_ApplyExtension(D,l,G,V){if(G>=l.length)return Promise.resolve(D);const N=V(l[G],D);return N?N.then((async D=>D?await this._ApplyExtension(D,l,G+1,V):null)):this._ApplyExtension(D,l,G+1,V)}_ApplyExtensions(D,l){const G=[];for(const V of PD._ExtensionNames)G.push(this._extensions[V]);return this._ApplyExtension(D,G,0,l)}_extensionsPreExportTextureAsync(D,l,G){return this._ApplyExtensions(l,((l,V)=>l.preExportTextureAsync&&l.preExportTextureAsync(D,V,G)))}_extensionsPostExportNodeAsync(D,l,G,V,N){return this._ApplyExtensions(l,((l,M)=>l.postExportNodeAsync&&l.postExportNodeAsync(D,M,G,V,N,this._bufferManager)))}_extensionsPostExportMaterialAsync(D,l,G){return this._ApplyExtensions(l,((l,V)=>l.postExportMaterialAsync&&l.postExportMaterialAsync(D,V,G)))}_extensionsPostExportMaterialAdditionalTextures(D,l,G){const V=[];for(const N of PD._ExtensionNames){const M=this._extensions[N];M.postExportMaterialAdditionalTextures&&V.push(...M.postExportMaterialAdditionalTextures(D,l,G))}return V}_extensionsPostExportTextures(D,l,G){for(const V of PD._ExtensionNames){const N=this._extensions[V];N.postExportTexture&&N.postExportTexture(D,l,G)}}_extensionsPostExportMeshPrimitive(D){for(const l of PD._ExtensionNames){const G=this._extensions[l];G.postExportMeshPrimitive&&G.postExportMeshPrimitive(D,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const D of PD._ExtensionNames){const l=this._extensions[D];l.preGenerateBinaryAsync&&await l.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(D){for(const l of PD._ExtensionNames){const G=this._extensions[l];G.enabled&&D(G)}}_extensionsOnExporting(){this._forEachExtensions((D=>{var l,G,V;D.wasUsed&&((l=this._glTF).extensionsUsed||(l.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(D.name)&&this._glTF.extensionsUsed.push(D.name),D.required&&((G=this._glTF).extensionsRequired||(G.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(D.name)&&this._glTF.extensionsRequired.push(D.name)),(V=this._glTF).extensions||(V.extensions={}),D.onExporting&&D.onExporting())}))}_loadExtensions(){for(const D of PD._ExtensionNames){const l=PD._ExtensionFactories[D](this);this._extensions[D]=l}}constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:F.d.LastCreatedScene,l=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${K.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new c(this),this._extensions={},this._bufferManager=new nD,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!D)throw new Error("No scene available to export");this._babylonScene=D,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:D=>{var l;return null===D||void 0===D||null===(l=D.bb)||void 0===l?void 0:l.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...l},this._loadExtensions()}dispose(){for(const D in this._extensions){this._extensions[D].dispose()}}get options(){return this._options}static RegisterExtension(D,l){PD.UnregisterExtension(D)&&N.Tools.Warn(`Extension with the name ${D} already exists`),PD._ExtensionFactories[D]=l,PD._ExtensionNames.push(D)}static UnregisterExtension(D){if(!PD._ExtensionFactories[D])return!1;delete PD._ExtensionFactories[D];const l=PD._ExtensionNames.indexOf(D);return-1!==l&&PD._ExtensionNames.splice(l,1),!0}_generateJSON(D,l,G){const V={byteLength:D};return V.byteLength&&(this._glTF.buffers=[V]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.dl=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(V.uri=l+".bin"),G?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(D){const l=await this._generateBinaryAsync();this._extensionsOnExporting();const G=this._generateJSON(l.byteLength,D,!0),V=new Blob([l],{type:"application/octet-stream"}),N=D+".gltf",M=D+".bin",b=new R;if(b.files[N]=G,b.files[M]=V,this._imageData)for(const X in this._imageData)b.files[X]=new Blob([this._imageData[X].data],{type:this._imageData[X].mimeType});return b}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(D){const l=D%4;return 0===l?l:4-l}async generateGLBAsync(D){this._shouldUseGlb=!0;const l=await this._generateBinaryAsync();this._extensionsOnExporting();const G=this._generateJSON(l.byteLength),V=D+".glb";let N,M=G.length;if("undefined"!==typeof TextEncoder){N=(new TextEncoder).encode(G),M=N.length}const b=this._getPadding(M),X=this._getPadding(l.byteLength),t=28+M+b+l.byteLength+X,n=new tD(t);if(n.writeUInt32(1179937895),n.writeUInt32(2),n.writeUInt32(t),n.writeUInt32(M+b),n.writeUInt32(1313821514),N)n.writeTypedArray(N);else{const D="_".charCodeAt(0);for(let l=0;l<M;++l){const V=G.charCodeAt(l);V!=G.codePointAt(l)?n.writeUInt8(D):n.writeUInt8(V)}}for(let R=0;R<b;++R)n.writeUInt8(32);n.writeUInt32(l.byteLength+X),n.writeUInt32(5130562),n.writeTypedArray(l);for(let R=0;R<X;++R)n.writeUInt8(0);const g=new R;return g.files[V]=new Blob([n.getOutputData()],{type:"application/octet-stream"}),g}_setNodeTransformation(D,l,G){if(l.getPivotPoint().equalsWithEpsilon(z,Y.b)||N.Tools.Warn("Pivot points are not supported in the glTF serializer"),!l.position.equalsWithEpsilon(z,Y.b)){const N=V.TmpVectors.Kl[0].V(l.position);G&&A(N),D.translation=N.gb()}l.ub.equalsWithEpsilon(P,Y.b)||(D.scale=l.ub.gb());const M=l.rotationQuaternion||V.Quaternion.FromEulerAngles(l.rotation.x,l.rotation.y,l.rotation.z);M.equalsWithEpsilon(E,Y.b)||(G&&a(M),D.rotation=M.normalize().gb())}_setCameraTransformation(D,l,G){if(!l.position.equalsWithEpsilon(z,Y.b)){const N=V.TmpVectors.Kl[0].V(l.position);G&&A(N),D.translation=N.gb()}const N=l.rotationQuaternion||V.Quaternion.FromEulerAngles(l.rotation.x,l.rotation.y,l.rotation.z);G&&a(N),this._babylonScene.useRightHandedSystem||Q(N),N.equalsWithEpsilon(E,Y.b)||(D.rotation=N.gb())}_listAvailableCameras(){for(const D of this._babylonScene.cameras){const l={type:D.mode===jD.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(D.name&&(l.name=D.name),"perspective"===l.type)l.perspective={aspectRatio:D.getEngine().getAspectRatio(D),yfov:D.fovMode===jD.e.FOVMODE_VERTICAL_FIXED?D.fov:D.fov*D.getEngine().getAspectRatio(D),znear:D.Kb,zfar:D.maxZ};else if("orthographic"===l.type){const G=D.orthoLeft&&D.orthoRight?.5*(D.orthoRight-D.orthoLeft):.5*D.getEngine().getRenderWidth(),V=D.orthoBottom&&D.orthoTop?.5*(D.orthoTop-D.orthoBottom):.5*D.getEngine().getRenderHeight();l.orthographic={xmag:G,ymag:V,znear:D.Kb,zfar:D.maxZ}}this._camerasMap.set(D,l)}}_exportAndAssignCameras(){const D=Array.from(this._camerasMap.values());for(const l of D){const D=this._nodesCameraMap.get(l);if(void 0!==D){this._cameras.push(l);for(const l of D)l.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const D of this._babylonScene.skeletons){if(D.bones.length<=0)continue;const l={joints:[]};this._skinMap.set(D,l)}}_exportAndAssignSkeletons(){for(const D of this._babylonScene.skeletons){if(D.bones.length<=0)continue;const l=this._skinMap.get(D);if(void 0==l)continue;const G={},V=[];let M=-1;for(let N=0;N<D.bones.length;++N){const l=D.bones[N],V=l.getIndex()??N;-1!==V&&(G[V]=l,V>M&&(M=V))}for(let D=0;D<=M;++D){const M=G[D];V.push(M.getAbsoluteInverseBindMatrix());const b=M.getTransformNode();if(null!==b){const D=this._nodeMap.get(b);b&&null!==D&&void 0!==D?l.joints.push(D):N.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else N.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const b=this._nodesSkinMap.get(l);if(l.joints.length>0&&void 0!==b){const D=64*V.length,G=new Float32Array(D/4);V.forEach(((D,l)=>{G.set(D.m,16*l)}));const N=this._bufferManager.createBufferView(G);this._accessors.push(this._bufferManager.createAccessor(N,"MAT4",5126,V.length)),l.inverseBindMatrices=this._accessors.length-1,this._skins.push(l);for(const l of b)l.skin=this._skins.length-1}}}async _exportSceneAsync(){const D={nodes:[]};if(this._babylonScene.metadata){const l=this._options.metadataSelector(this._babylonScene.metadata);l&&(D.extras=l)}const l=new Array,G=new Array,V=new Array;for(const X of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&bD(X,this._babylonScene.useRightHandedSystem)?V.push(...X.getChildren()):this._babylonScene.useRightHandedSystem?l.push(X):G.push(X);this._listAvailableCameras(),this._listAvailableSkeletons();const N=new ED(!0,!1);D.nodes.push(...await this._exportNodesAsync(G,N));const M=new ED(!1,!1);D.nodes.push(...await this._exportNodesAsync(l,M));const b=new ED(!1,!0);D.nodes.push(...await this._exportNodesAsync(V,b)),D.nodes.length&&this._scenes.push(D),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&rD._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,N.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(D){let l=this._shouldExportNodeMap.get(D);return void 0===l&&(l=this._options.shouldExportNode(D),this._shouldExportNodeMap.set(D,l)),l}async _exportNodesAsync(D,l){const G=new Array;this._exportBuffers(D,l);for(const V of D)await this._exportNodeAsync(V,G,l);return G}_collectBuffers(D,l,G,V,N){if(this._shouldExportNode(D)&&D instanceof j.d&&D.xb){const M=D.xb.getVertexBuffers();if(M)for(const V in M){if(!T(V))continue;const b=M[V];N.setHasVertexColorAlpha(b,D.hasVertexAlpha);const X=b._buffer,t=l.get(X)||[];l.set(X,t),-1===t.indexOf(b)&&t.push(b);const R=G.get(b)||[];G.set(b,R),-1===R.indexOf(D)&&R.push(D)}const b=D.morphTargetManager;if(b)for(let l=0;l<b.numTargets;l++){const G=b.getTarget(l),N=V.get(G)||[];V.set(G,N),-1===N.indexOf(D)&&N.push(D)}}for(const M of D.getChildren())this._collectBuffers(M,l,G,V,N)}_exportBuffers(D,l){const G=new Map,V=new Map,N=new Map;for(const X of D)this._collectBuffers(X,G,V,N,l);const M=Array.from(G.keys());for(const X of M){const D=X.getData();if(!D)throw new Error("Buffer data is not available");const N=G.get(X);if(!N)continue;const M=N[0].byteStride;if(N.some((D=>D.byteStride!==M)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const b=GD(D).slice();for(const l of N){const D=V.get(l),{byteOffset:G,byteStride:N,componentCount:M,type:X,count:t,normalized:R,kind:g}=k(l,D);switch(g){case n.e.NormalKind:case n.e.TangentKind:(0,v.i)(b,G,N,M,X,t,R,(D=>{const l=Math.sqrt(D[0]*D[0]+D[1]*D[1]+D[2]*D[2]);if(l>0){const G=1/l;D[0]*=G,D[1]*=G,D[2]*=G}}));break;case n.e.ColorKind:{const l=D.filter((D=>D.material instanceof FD.Hl||null==D.material)).length;if(0==l)break;if(l!=D.length){Z.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}X==n.e.UNSIGNED_BYTE&&Z.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const V=new d.hl,g=new d.Wb,j=this._babylonScene.getEngine().useExactSrgbConversions;(0,v.i)(b,G,N,M,X,t,R,(D=>{3===D.length?(V.KG(D,0),V.toLinearSpaceToRef(V,j),V.toArray(D,0)):(g.KG(D,0),g.toLinearSpaceToRef(g,j),g.toArray(D,0))}))}}}if(l.convertToRightHanded){for(const D of N){const l=V.get(D),{byteOffset:G,byteStride:N,componentCount:M,type:X,count:t,normalized:R,kind:g}=k(D,l);switch(g){case n.e.PositionKind:case n.e.NormalKind:case n.e.TangentKind:(0,v.i)(b,G,N,M,X,t,R,(D=>{D[0]=-D[0]}))}}l.convertedToRightHandedBuffers.set(X,b)}const t=this._bufferManager.createBufferView(b,M);l.setVertexBufferView(X,t);const R=new Map;for(const l of N){const D=V.get(l),{kind:G,totalVertices:N}=k(l,D);switch(G){case n.e.MatricesIndicesKind:case n.e.MatricesIndicesExtraKind:if(l.type==n.e.FLOAT){const D=l.getFloatData(N);null!==D&&R.set(l,D)}}}0!==R.size&&Z.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const g=Array.from(R.keys());for(const G of g){const D=R.get(G);if(!D)continue;const V=D.some((D=>D>=256)),N=new(V?Uint16Array:Uint8Array)(D.length);for(let l=0;l<D.length;l++)N[l]=D[l];const M=this._bufferManager.createBufferView(N,4*(V?2:1));l.setRemappedBufferView(X,G,M)}}const b=Array.from(N.keys());for(const X of b){const D=N.get(X);if(!D)continue;const G=oD(X,D[0],this._bufferManager,this._bufferViews,this._accessors,l.convertToRightHanded);for(const V of D)l.bindMorphDataToMesh(V,G)}}async _exportNodeAsync(D,l,G){let V=this._nodeMap.get(D);if(void 0!==V)return void(l.includes(V)||l.push(V));const N=await this._createNodeAsync(D,G);if(N){V=this._nodes.length,this._nodes.push(N),this._nodeMap.set(D,V),G.pushExportedNode(D),l.push(V);const M={name:"runtime animations",channels:[],samplers:[]},b=[];this._babylonScene.animationGroups.length||(rD._CreateMorphTargetAnimationFromMorphTargetAnimations(D,M,b,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,G.convertToRightHanded,this._options.shouldExportAnimation),D.animations.length&&rD._CreateNodeAnimationFromNodeAnimations(D,M,b,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,G.convertToRightHanded,this._options.shouldExportAnimation)),M.channels.length&&M.samplers.length&&this._animations.push(M),b.forEach((D=>{D.channels.length&&D.samplers.length&&this._animations.push(D)}))}const M=N?[]:l;for(const b of D.getChildren())await this._exportNodeAsync(b,M,G);N&&M.length&&(N.children=M)}async _createNodeAsync(D,l){if(!this._shouldExportNode(D))return null;const G={};if(D.name&&(G.name=D.name),D.metadata){const l=this._options.metadataSelector(D.metadata);l&&(G.extras=l)}if(D instanceof g.d&&(this._setNodeTransformation(G,D,l.convertToRightHanded),D instanceof j.d)){const N=D instanceof e.e?D.sourceMesh:D;if(N.nb&&N.nb.length>0&&(G.mesh=await this._exportMeshAsync(N,l)),D.skeleton){const l=this._skinMap.get(D.skeleton);var V;if(void 0!==l)void 0===this._nodesSkinMap.get(l)&&this._nodesSkinMap.set(l,[]),null===(V=this._nodesSkinMap.get(l))||void 0===V||V.push(G)}}if(D instanceof J.e){const V=this._camerasMap.get(D);if(V){var N;void 0===this._nodesCameraMap.get(V)&&this._nodesCameraMap.set(V,[]),this._setCameraTransformation(G,D,l.convertToRightHanded);const b=D.parent;if(null!==b&&lD(D,b)){const D=this._nodeMap.get(b);if(void 0!==D){var M;const l=this._nodes[D];return DD(G,l),null===(M=this._nodesCameraMap.get(V))||void 0===M||M.push(l),null}}null===(N=this._nodesCameraMap.get(V))||void 0===N||N.push(G)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",G,D,this._nodeMap,l.convertToRightHanded)?G:(Z.d.Warn(`Not exporting node ${D.name}`),null)}_exportIndices(D,l,G,V,N,b,X,t,R){let n=D;R.mode=C(b);const g=X!==M.c.CounterClockWiseSideOrientation,j=!t.wasAddedByNoopNode&&g,e=function(D){switch(D){case M.c.TriangleFillMode:case M.c.TriangleStripDrawMode:case M.c.TriangleFanDrawMode:return!0}return!1}(b)&&j;if(e){if(b===M.c.TriangleStripDrawMode||b===M.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");R.mode=C(b);const X=l?new Uint32Array(V):new Uint16Array(V);if(D)for(let l=0;l+2<V;l+=3)X[l]=D[G+l]+N,X[l+1]=D[G+l+2]+N,X[l+2]=D[G+l+1]+N;else for(let D=0;D+2<V;D+=3)X[D]=D,X[D+1]=D+2,X[D+2]=D+1;n=X}else if(D&&0!==N){const M=l?new Uint32Array(V):new Uint16Array(V);for(let l=0;l<V;l++)M[l]=D[G+l]+N;n=M}if(n){let M=t.getIndicesAccessor(D,G,V,N,e);if(void 0===M){const b=function(D,l,G,V){if(D instanceof Uint16Array||D instanceof Uint32Array)return D;if(D instanceof Int32Array)return new Uint32Array(D.buffer,D.byteOffset,D.length);const N=D.slice(l,l+G);return V?new Uint32Array(N):new Uint16Array(N)}(n,0,V,l),X=this._bufferManager.createBufferView(b),R=l?5125:5123;this._accessors.push(this._bufferManager.createAccessor(X,"SCALAR",R,V,0)),M=this._accessors.length-1,t.setIndicesAccessor(D,G,V,N,e,M)}R.indices=M}}_exportVertexBuffer(D,l,G,V,N,M){const b=D.getKind();if(!T(b))return;if(b.startsWith("uv")&&!this._options.exportUnusedUVs&&(!l||!this._materialNeedsUVsSet.has(l)))return;let X=N.getVertexAccessor(D,G,V);if(void 0===X){const l=N.convertedToRightHandedBuffers.get(D._buffer)||D._buffer.getData(),M=b===n.e.PositionKind?function(D,l,G,V){const{byteOffset:N,byteStride:M,type:b,normalized:X}=l,t=l.getSize(),R=new Array(t).fill(1/0),n=new Array(t).fill(-1/0);return(0,v.i)(D,N+G*M,M,t,b,V*t,X,(D=>{for(let l=0;l<t;l++)R[l]=Math.min(R[l],D[l]),n[l]=Math.max(n[l],D[l])})),{min:R,max:n}}(l,D,G,V):void 0,t=(b===n.e.MatricesIndicesKind||b===n.e.MatricesIndicesExtraKind)&&D.type===n.e.FLOAT,R=t?n.e.UNSIGNED_BYTE:D.type,g=t?void 0:D.normalized,j=t?N.getRemappedBufferView(D._buffer,D):N.getVertexBufferView(D._buffer),e=D.byteOffset+G*D.byteStride;this._accessors.push(this._bufferManager.createAccessor(j,function(D,l){if(D==n.e.ColorKind)return l?"VEC4":"VEC3";switch(D){case n.e.PositionKind:case n.e.NormalKind:return"VEC3";case n.e.TangentKind:case n.e.MatricesIndicesKind:case n.e.MatricesIndicesExtraKind:case n.e.MatricesWeightsKind:case n.e.MatricesWeightsExtraKind:return"VEC4";case n.e.UVKind:case n.e.UV2Kind:case n.e.UV3Kind:case n.e.UV4Kind:case n.e.UV5Kind:case n.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${D}`)}(b,N.hasVertexColorAlpha(D)),R,V,e,M,g)),X=this._accessors.length-1,N.setVertexAccessor(D,G,V,X)}M.attributes[function(D){switch(D){case n.e.PositionKind:return"POSITION";case n.e.NormalKind:return"NORMAL";case n.e.TangentKind:return"TANGENT";case n.e.ColorKind:return"COLOR_0";case n.e.UVKind:return"TEXCOORD_0";case n.e.UV2Kind:return"TEXCOORD_1";case n.e.UV3Kind:return"TEXCOORD_2";case n.e.UV4Kind:return"TEXCOORD_3";case n.e.UV5Kind:return"TEXCOORD_4";case n.e.UV6Kind:return"TEXCOORD_5";case n.e.MatricesIndicesKind:return"JOINTS_0";case n.e.MatricesIndicesExtraKind:return"JOINTS_1";case n.e.MatricesWeightsKind:return"WEIGHTS_0";case n.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${D}`)}(b)]=X}async _exportMaterialAsync(D,l,G,V){let N=this._materialMap.get(D);if(void 0===N){const V=l&&Object.keys(l).some((D=>D.startsWith("uv")));if((D=D instanceof eD.d?D.ib[G.materialIndex]:D)instanceof KD.c)N=await this._materialExporter.exportPBRMaterialAsync(D,"image/png",V);else{if(!(D instanceof FD.Hl))return void Z.d.Warn(`Unsupported material '${D.name}' with type ${D.getClassName()}`);N=await this._materialExporter.exportStandardMaterialAsync(D,"image/png",V)}this._materialMap.set(D,N)}V.material=N}async _exportMeshAsync(D,l){var G;let V=l.getMesh(D);if(void 0!==V)return V;const N={primitives:[]};V=this._meshes.length,this._meshes.push(N),l.setMesh(D,V);const b=D.isUnIndexed?null:D.rb(),X=null===(G=D.xb)||void 0===G?void 0:G.getVertexBuffers(),t=l.getMorphTargetsFromMesh(D),R=D instanceof LD.d,n=D instanceof zD,g=D.nb;if(X&&g&&g.length>0)for(const K of g){const G={attributes:{}},V=K.cD()||this._babylonScene.defaultMaterial;if(n){var j,e;const l={name:V.name},N=D,M=d.hl.White(),b=(null===(j=N.material)||void 0===j?void 0:j.alpha)??1,X=(null===(e=N.greasedLineMaterial)||void 0===e?void 0:e.color)??M;(!X.equalsWithEpsilon(M,Y.b)||b<1)&&(l.pbrMetallicRoughness={baseColorFactor:[...X.gb(),b]}),this._materials.push(l),G.material=this._materials.length-1}else if(R){const l={name:V.name},N=D;(!N.color.equalsWithEpsilon(d.hl.White(),Y.b)||N.alpha<1)&&(l.pbrMetallicRoughness={baseColorFactor:[...N.color.gb(),N.alpha]}),this._materials.push(l),G.material=this._materials.length-1}else await this._exportMaterialAsync(V,X,K,G);const g=R||n?M.c.LineListDrawMode:D.overrideRenderingFillMode??V.fillMode,F=V._getEffectiveOrientation(D);this._exportIndices(b,b?(0,v.e)(b,K.indexCount,K.indexStart,K.verticesStart):K.verticesCount>65535,b?K.indexStart:K.verticesStart,b?K.indexCount:K.verticesCount,-K.verticesStart,g,F,l,G);for(const D of Object.values(X))this._exportVertexBuffer(D,V,K.verticesStart,K.verticesCount,l,G);if(t){G.targets=[];for(const D of t)G.targets.push(D.attributes)}N.primitives.push(G),this._extensionsPostExportMeshPrimitive(G)}if(t){N.weights=[],N.extras||(N.extras={}),N.extras.targetNames=[];for(const D of t)N.weights.push(D.influence),N.extras.targetNames.push(D.name)}return V}}PD._ExtensionNames=new Array,PD._ExtensionFactories={};class pD{static async GLTFAsync(D,l,G){G&&G.exportWithoutWaitingForScene||await D.whenReadyAsync();const V=new PD(D,G),N=await V.generateGLTFAsync(l.replace(/\.[^/.]+$/,""));return V.dispose(),N}static async GLBAsync(D,l,G){G&&G.exportWithoutWaitingForScene||await D.whenReadyAsync();const V=new PD(D,G),N=await V.generateGLBAsync(l.replace(/\.[^/.]+$/,""));return V.dispose(),N}}G(12285);const kD="EXT_mesh_gpu_instancing";class mD{constructor(D){this.name=kD,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(D,l,G,N,M,b){return await new Promise((D=>{if(l&&G instanceof hD.b&&G.hasThinInstances&&this._exporter){this._wasUsed=!0;const D=V.Kl.Zero(),N=V.Quaternion.Identity(),X=V.Kl.One(),t=G.thinInstanceGetWorldMatrices(),R=V.TmpVectors.Kl[2],n=V.TmpVectors.Quaternion[1],g=V.TmpVectors.Kl[3];let j=!1,e=!1,K=!1;const F=new Float32Array(3*G.yb),d=new Float32Array(4*G.yb),H=new Float32Array(3*G.yb);let h=0;for(const l of t)l.decompose(g,n,R),M&&(A(R),a(n)),F.set(R.gb(),3*h),d.set(n.normalize().gb(),4*h),H.set(g.gb(),3*h),j=j||!R.equalsWithEpsilon(D),e=e||!n.equalsWithEpsilon(N),K=K||!g.equalsWithEpsilon(X),h++;const x={attributes:{}};j&&(x.attributes.TRANSLATION=this._buildAccessor(F,"VEC3",G.yb,b)),e&&(x.attributes.ROTATION=this._buildAccessor(d,"VEC4",G.yb,b)),K&&(x.attributes.SCALE=this._buildAccessor(H,"VEC3",G.yb,b)),l.extensions=l.extensions||{},l.extensions[kD]=x}D(l)}))}_buildAccessor(D,l,G,V){const N=V.createBufferView(D),M=V.createAccessor(N,l,5126,G);return this._exporter._accessors.push(M),this._exporter._accessors.length-1}}PD.RegisterExtension(kD,(D=>new mD(D)));var TD=G(12294),CD=G(12311),wD=G(12313),AD=G(12322);function aD(D){return D===wD.d.PositionKind?"POSITION":D===wD.d.NormalKind?"NORMAL":D===wD.d.ColorKind?"COLOR":D.startsWith(wD.d.UVKind)?"TEX_COORD":"GENERIC"}const QD={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Dl extends TD.b{static get DefaultAvailable(){return(0,TD.f)(Dl.DefaultConfiguration)}static get Default(){return Dl._Default??(Dl._Default=new Dl),Dl._Default}static ResetDefault(D){Dl._Default&&(D||Dl._Default.dispose(),Dl._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(D,l){return{module:await(l||DracoEncoderModule)({wasmBinary:D})}}_getWorkerContent(){return`${CD.i}(${CD.m})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Dl.DefaultConfiguration)}async _encodeAsync(D,l,G){const V=G?(0,AD.c)(QD,G):QD;if(this._workerPoolPromise){const G=await this._workerPoolPromise;return await new Promise(((N,M)=>{G.push(((G,b)=>{const X=D=>{G.removeEventListener("error",X),G.removeEventListener("message",t),M(D),b()},t=D=>{"encodeMeshDone"===D.data.id&&(G.removeEventListener("error",X),G.removeEventListener("message",t),N(D.data.encodedMeshData),b())};G.addEventListener("error",X),G.addEventListener("message",t);const R=[];for(const l of D)R.push(l.data.buffer);l&&R.push(l.buffer),G.postMessage({id:"encodeMesh",attributes:D,indices:l,options:V},R)}))}))}if(this._modulePromise){const G=await this._modulePromise;return(0,CD.i)(G.module,D,l,V)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(D,l){if(0==D.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");D instanceof hD.b&&D.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===l||void 0===l?void 0:l.method)&&(Z.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),l.method="MESH_SEQUENTIAL_ENCODING");const G=function(D){let l=D.rb(void 0,!0);return!l||l instanceof Uint32Array||l instanceof Uint16Array||(l=((0,v.e)(l,l.length)?Uint32Array:Uint16Array).from(l)),l}(D),V=function(D,l){const G=[];for(const V of D.getVerticesDataKinds()){if(null!==l&&void 0!==l&&l.includes(V)){if(V===wD.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const N=D.getVertexBuffer(V),M=N.getSize(),b=(0,v.o)(N.getData(),M,N.type,N.byteOffset,N.byteStride,N.normalized,D.getTotalVertices(),!0);G.push({kind:V,dracoName:aD(V),size:M,data:b})}return G}(D,null===l||void 0===l?void 0:l.excludedAttributes);return await this._encodeAsync(V,G,l)}}Dl.DefaultConfiguration={wasmUrl:`${N.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${N.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${N.Tools._DefaultCdnUrl}/draco_encoder.js`},Dl._Default=null;const ll="KHR_draco_mesh_compression";class Gl{get wasUsed(){return this._wasUsed}constructor(D){this.name=ll,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===D.options.meshCompressionMethod&&Dl.DefaultAvailable}dispose(){}postExportMeshPrimitive(D,l,G){if(!this.enabled)return;if(4!==D.mode&&5!==D.mode)return void Z.d.Warn("Cannot compress primitive with mode "+D.mode+".");const V=[],N=[];let M=null;if(void 0!==D.indices){const b=G[D.indices],X=l.getBufferView(b);M=l.getData(X).slice(),V.push(X),N.push(b)}const b=[];for(const[n,g]of Object.entries(D.attributes)){const D=G[g],M=l.getBufferView(D),t=m(D.type),R=(0,v.o)(l.getData(M),t,D.componentType,D.byteOffset||0,M.byteStride||(0,v.l)(D.componentType)*t,D.normalized||!1,D.count,!0);b.push({kind:n,dracoName:(X=n,"POSITION"===X?"POSITION":"NORMAL"===X?"NORMAL":X.startsWith("COLOR")?"COLOR":X.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:m(D.type),data:R}),V.push(M),N.push(D)}var X;const t={method:D.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},R=Dl.Default._encodeAsync(b,M,t).then((G=>{if(!G)return void Z.d.Error("Draco encoding failed for primitive.");const M={bufferView:-1,attributes:G.attributeIds},b=l.createBufferView(G.data);l.setBufferView(M,b);for(const D of V)this._bufferViewsUsed.add(D);for(const D of N)this._accessorsUsed.add(D);D.extensions||(D.extensions={}),D.extensions[ll]=M})).catch((D=>{Z.d.Error("Draco encoding failed for primitive: "+D)}));this._encodePromises.push(R),this._wasUsed=!0}async preGenerateBinaryAsync(D){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((l=>{D.getPropertiesWithBufferView(l).every((D=>this._accessorsUsed.has(D)))&&D.removeBufferView(l)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}PD.RegisterExtension(ll,(D=>new Gl(D)));var Vl=G(12325);const Nl="KHR_lights_punctual",Ml={name:"",color:[1,1,1],Sb:1,range:Number.MAX_VALUE},bl={innerConeAngle:0,outerConeAngle:Math.PI/4},Xl=V.Kl.Backward();class tl{constructor(D){this.name=Nl,this.enabled=!0,this.required=!1,this._exporter=D}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Nl]=this._lights}async postExportNodeAsync(D,l,G,N,M){return await new Promise((b=>{if(!(G instanceof xD.c))return void b(l);const X=G.getTypeID()==xD.c.LIGHTTYPEID_POINTLIGHT?"point":G.getTypeID()==xD.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":G.getTypeID()==xD.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!X||!(G instanceof Vl.c))return Z.d.Warn(`${D}: Light ${G.name} is not supported in ${Nl}`),void b(l);if(G.falloffType!==xD.c.FALLOFF_GLTF&&Z.d.Warn(`${D}: Light falloff for ${G.name} does not match the ${Nl} specification!`),!G.position.equalsToFloats(0,0,0)){const D=V.TmpVectors.Kl[0].V(G.position);M&&A(D),l.translation=D.gb()}if("point"!==X){const D=G.direction.normalizeToRef(V.TmpVectors.Kl[0]);M&&A(D);const N=V.Quaternion.FromUnitVectorsToRef(Xl,D,V.TmpVectors.Quaternion[0]);V.Quaternion.IsIdentity(N)||(l.rotation=N.gb())}const t={type:X,name:G.name,color:G.Ob.gb(),Sb:G.Sb,range:G.range};if(VD(t,Ml),"spot"===X){const D=G;t.spot={innerConeAngle:D.innerAngle/2,outerConeAngle:D.angle/2},VD(t.spot,bl)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(t);const R={Db:this._lights.lights.length-1},n=G.parent;if(n&&lD(G,n)){const D=N.get(n);if(D){const G=this._exporter._nodes[D];return DD(l,G),G.extensions||(G.extensions={}),G.extensions[Nl]=R,void b(null)}}l.extensions||(l.extensions={}),l.extensions[Nl]=R,b(l)}))}}PD.RegisterExtension(Nl,(D=>new tl(D)));var Rl=G(12228);const nl="KHR_materials_anisotropy";class gl{constructor(D){this.name=nl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,l,G){const V=[];return G instanceof Rl.b&&G.anisotropy.isEnabled&&!G.anisotropy.legacy?(G.anisotropy.texture&&V.push(G.anisotropy.texture),V):[]}postExportMaterialAsync(D,l,G){return new Promise((D=>{if(G instanceof Rl.b){if(!G.anisotropy.isEnabled||G.anisotropy.legacy)return void D(l);this._wasUsed=!0,l.extensions=l.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(G.anisotropy.texture),N={anisotropyStrength:G.anisotropy.Sb,anisotropyRotation:G.anisotropy.angle,anisotropyTexture:V??void 0};null!==N.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(G),l.extensions[nl]=N}D(l)}))}}PD.RegisterExtension(nl,(D=>new gl(D)));const jl="KHR_materials_clearcoat";class el{constructor(D){this.name=jl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,l,G){const V=[];return G instanceof Rl.b&&G.clearCoat.isEnabled?(G.clearCoat.texture&&V.push(G.clearCoat.texture),!G.clearCoat.useRoughnessFromMainTexture&&G.clearCoat.textureRoughness&&V.push(G.clearCoat.textureRoughness),G.clearCoat.bumpTexture&&V.push(G.clearCoat.bumpTexture),V):[]}postExportMaterialAsync(D,l,G){return new Promise((D=>{if(G instanceof Rl.b){if(!G.clearCoat.isEnabled)return void D(l);this._wasUsed=!0,l.extensions=l.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(G.clearCoat.texture);let M;M=G.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(G.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(G.clearCoat.textureRoughness),G.clearCoat.isTintEnabled&&N.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${G.name}`),G.clearCoat.remapF0OnInterfaceChange&&N.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${G.name}`);const b=this._exporter._materialExporter.getTextureInfo(G.clearCoat.bumpTexture),X={clearcoatFactor:G.clearCoat.Sb,clearcoatTexture:V??void 0,clearcoatRoughnessFactor:G.clearCoat.roughness,clearcoatRoughnessTexture:M??void 0,clearcoatNormalTexture:b??void 0};null===X.clearcoatTexture&&null===X.clearcoatRoughnessTexture&&null===X.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(G),l.extensions[jl]=X}D(l)}))}}PD.RegisterExtension(jl,(D=>new el(D)));const Kl="KHR_materials_diffuse_transmission";function Fl(D,l){const G=l.subSurface;let V=null;return G.translucencyIntensityTexture?V=G.translucencyIntensityTexture:G.thicknessTexture&&G.useMaskFromThicknessTexture&&(V=G.thicknessTexture),V&&!G.useGltfStyleTextures?(Z.d.Warn(`${D}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${l.name}`,1),null):V}class dl{constructor(D){this.name=Kl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,l,G){const V=[];if(G instanceof KD.c&&this._isExtensionEnabled(G)){const l=Fl(D,G);return l&&V.push(l),G.subSurface.translucencyColorTexture&&V.push(G.subSurface.translucencyColorTexture),V}return V}_isExtensionEnabled(D){if(D.unlit)return!1;const l=D.subSurface;return!!l.isTranslucencyEnabled&&(!D.unlit&&!l.useAlbedoToTintTranslucency&&l.useGltfStyleTextures&&1===l.volumeIndexOfRefraction&&0===l.minimumThickness&&0===l.maximumThickness)}postExportMaterialAsync(D,l,G){return new Promise((V=>{if(G instanceof KD.c&&this._isExtensionEnabled(G)){this._wasUsed=!0;const V=G.subSurface,N=Fl(D,G),M=0==V.translucencyIntensity?void 0:V.translucencyIntensity,b=this._exporter._materialExporter.getTextureInfo(N)??void 0,X=!V.translucencyColor||V.translucencyColor.equalsFloats(1,1,1)?void 0:V.translucencyColor.gb(),t=this._exporter._materialExporter.getTextureInfo(V.translucencyColorTexture)??void 0,R={diffuseTransmissionFactor:M,diffuseTransmissionTexture:b,diffuseTransmissionColorFactor:X,diffuseTransmissionColorTexture:t};(b||t)&&this._exporter._materialNeedsUVsSet.add(G),l.extensions=l.extensions||{},l.extensions[Kl]=R}V(l)}))}}PD.RegisterExtension(Kl,(D=>new dl(D)));const Hl="KHR_materials_dispersion";class hl{constructor(){this.name=Hl,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(D){if(D.unlit)return!1;const l=D.subSurface;return!(!l.isRefractionEnabled&&!l.isDispersionEnabled)}postExportMaterialAsync(D,l,G){return new Promise((D=>{if(G instanceof KD.c&&this._isExtensionEnabled(G)){this._wasUsed=!0;const D={dispersion:G.subSurface.dispersion};l.extensions=l.extensions||{},l.extensions[Hl]=D}D(l)}))}}PD.RegisterExtension(Hl,(()=>new hl));const xl="KHR_materials_emissive_strength";class rl{constructor(){this.name=xl,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(D,l,G){return await new Promise((D=>{if(!(G instanceof KD.c))return D(l);const V=G.emissiveColor.gb(),N=Math.max(...V);if(N>1){this._wasUsed=!0,l.extensions||(l.extensions={});const D={emissiveStrength:N},V=G.emissiveColor.scale(1/D.emissiveStrength);l.emissiveFactor=V.gb(),l.extensions[xl]=D}return D(l)}))}}PD.RegisterExtension(xl,(D=>new rl));const ol="KHR_materials_ior";class Ll{constructor(){this.name=ol,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(D){return!D.unlit&&(void 0!=D.indexOfRefraction&&1.5!=D.indexOfRefraction)}postExportMaterialAsync(D,l,G){return new Promise((D=>{if(G instanceof KD.c&&this._isExtensionEnabled(G)){this._wasUsed=!0;const D={ior:G.indexOfRefraction};l.extensions=l.extensions||{},l.extensions[ol]=D}D(l)}))}}PD.RegisterExtension(ol,(D=>new Ll));const ul="KHR_materials_iridescence";class Bl{constructor(D){this.name=ul,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,l,G){const V=[];return G instanceof Rl.b&&G.iridescence.isEnabled?(G.iridescence.texture&&V.push(G.iridescence.texture),G.iridescence.thicknessTexture&&G.iridescence.thicknessTexture!==G.iridescence.texture&&V.push(G.iridescence.thicknessTexture),V):[]}postExportMaterialAsync(D,l,G){return new Promise((D=>{if(G instanceof Rl.b){if(!G.iridescence.isEnabled)return void D(l);this._wasUsed=!0,l.extensions=l.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(G.iridescence.texture),N=this._exporter._materialExporter.getTextureInfo(G.iridescence.thicknessTexture),M={iridescenceFactor:G.iridescence.Sb,iridescenceIor:G.iridescence.indexOfRefraction,iridescenceThicknessMinimum:G.iridescence.minimumThickness,iridescenceThicknessMaximum:G.iridescence.maximumThickness,iridescenceTexture:V??void 0,iridescenceThicknessTexture:N??void 0};null===M.iridescenceTexture&&null===M.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(G),l.extensions[ul]=M}D(l)}))}}PD.RegisterExtension(ul,(D=>new Bl(D)));const Il="KHR_materials_sheen";class Wl{constructor(D){this.name=Il,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,l,G){return G instanceof KD.c&&G.sheen.isEnabled&&G.sheen.texture?[G.sheen.texture]:[]}async postExportMaterialAsync(D,l,G){return await new Promise((D=>{if(G instanceof KD.c){if(!G.sheen.isEnabled)return void D(l);this._wasUsed=!0,null==l.extensions&&(l.extensions={});const V={sheenColorFactor:G.sheen.color.gb(),sheenRoughnessFactor:G.sheen.roughness??0};null===V.sheenColorTexture&&null===V.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(G),G.sheen.texture&&(V.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(G.sheen.texture)??void 0),G.sheen.textureRoughness&&!G.sheen.useRoughnessFromMainTexture?V.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(G.sheen.textureRoughness)??void 0:G.sheen.texture&&G.sheen.useRoughnessFromMainTexture&&(V.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(G.sheen.texture)??void 0),l.extensions[Il]=V}D(l)}))}}PD.RegisterExtension(Il,(D=>new Wl(D)));const il="KHR_materials_specular";class yl{constructor(D){this.name=il,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,l,G){const V=[];return G instanceof KD.c&&this._isExtensionEnabled(G)?(G.metallicReflectanceTexture&&V.push(G.metallicReflectanceTexture),G.reflectanceTexture&&V.push(G.reflectanceTexture),V):V}_isExtensionEnabled(D){return!D.unlit&&(void 0!=D.metallicF0Factor&&1!=D.metallicF0Factor||void 0!=D.metallicReflectanceColor&&!D.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(D))}_hasTexturesExtension(D){return null!=D.metallicReflectanceTexture||null!=D.reflectanceTexture}postExportMaterialAsync(D,l,G){return new Promise((D=>{if(G instanceof KD.c&&this._isExtensionEnabled(G)){this._wasUsed=!0,l.extensions=l.extensions||{};const D=this._exporter._materialExporter.getTextureInfo(G.metallicReflectanceTexture)??void 0,V=this._exporter._materialExporter.getTextureInfo(G.reflectanceTexture)??void 0,N={specularFactor:1==G.metallicF0Factor?void 0:G.metallicF0Factor,specularTexture:D,specularColorFactor:G.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:G.metallicReflectanceColor.gb(),specularColorTexture:V};this._hasTexturesExtension(G)&&this._exporter._materialNeedsUVsSet.add(G),l.extensions[il]=N}D(l)}))}}PD.RegisterExtension(il,(D=>new yl(D)));const Sl="KHR_materials_transmission";class Ol{constructor(D){this.name=Sl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,l,G){const V=[];return G instanceof KD.c&&this._isExtensionEnabled(G)?(G.subSurface.thicknessTexture&&V.push(G.subSurface.thicknessTexture),V):V}_isExtensionEnabled(D){if(D.unlit)return!1;const l=D.subSurface;return l.isRefractionEnabled&&void 0!=l.refractionIntensity&&0!=l.refractionIntensity||this._hasTexturesExtension(D)}_hasTexturesExtension(D){return null!=D.subSurface.refractionIntensityTexture}async postExportMaterialAsync(D,l,G){if(G instanceof KD.c&&this._isExtensionEnabled(G)){this._wasUsed=!0;const V=G.subSurface,N={transmissionFactor:0===V.refractionIntensity?void 0:V.refractionIntensity};if(this._hasTexturesExtension(G)&&this._exporter._materialNeedsUVsSet.add(G),V.refractionIntensityTexture)if(V.useGltfStyleTextures){const D=await this._exporter._materialExporter.exportTextureAsync(V.refractionIntensityTexture,"image/png");D&&(N.transmissionTexture=D)}else Z.d.Warn(`${D}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);l.extensions||(l.extensions={}),l.extensions[Sl]=N}return l}}PD.RegisterExtension(Sl,(D=>new Ol(D)));const sl="KHR_materials_unlit";class Ul{constructor(){this.name=sl,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(D,l,G){return new Promise((D=>{let V=!1;G instanceof KD.c?V=G.unlit:G instanceof FD.Hl&&(V=G.disableLighting),V&&(this._wasUsed=!0,null==l.extensions&&(l.extensions={}),l.extensions[sl]={}),D(l)}))}}PD.RegisterExtension(sl,(()=>new Ul));const fl="KHR_materials_volume";class ql{constructor(D){this.name=fl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,l,G){const V=[];return G instanceof KD.c&&this._isExtensionEnabled(G)?(G.subSurface.thicknessTexture&&V.push(G.subSurface.thicknessTexture),V):V}_isExtensionEnabled(D){if(D.unlit)return!1;const l=D.subSurface;return!(!l.isRefractionEnabled&&!l.isTranslucencyEnabled)&&(void 0!=l.maximumThickness&&0!=l.maximumThickness||void 0!=l.tintColorAtDistance&&l.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=l.tintColor&&l.tintColor!=d.hl.White()||this._hasTexturesExtension(D))}_hasTexturesExtension(D){return null!=D.subSurface.thicknessTexture}postExportMaterialAsync(D,l,G){return new Promise((D=>{if(G instanceof KD.c&&this._isExtensionEnabled(G)){this._wasUsed=!0;const D=G.subSurface,V={thicknessFactor:0==D.maximumThickness?void 0:D.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(D.thicknessTexture)??void 0,attenuationDistance:D.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:D.tintColorAtDistance,attenuationColor:D.tintColor.equalsFloats(1,1,1)?void 0:D.tintColor.gb()};this._hasTexturesExtension(G)&&this._exporter._materialNeedsUVsSet.add(G),l.extensions=l.extensions||{},l.extensions[fl]=V}D(l)}))}}PD.RegisterExtension(fl,(D=>new ql(D)));const cl="EXT_materials_diffuse_roughness";class vl{constructor(D){this.name=cl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=D}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(D,l,G){const V=[];return G instanceof Rl.b&&G._baseDiffuseRoughness?(G._baseDiffuseRoughnessTexture&&V.push(G._baseDiffuseRoughnessTexture),V):[]}postExportMaterialAsync(D,l,G){return new Promise((D=>{if(G instanceof Rl.b){if(!G._baseDiffuseRoughness)return void D(l);this._wasUsed=!0,l.extensions=l.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(G._baseDiffuseRoughnessTexture),N={diffuseRoughnessFactor:G._baseDiffuseRoughness,diffuseRoughnessTexture:V??void 0};null!==N.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(G),l.extensions[cl]=N}D(l)}))}}PD.RegisterExtension(cl,(D=>new vl(D)));const Zl="KHR_texture_transform";class Jl{constructor(){this.name=Zl,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(D,l,G){if(G.uD()||N.Tools.Warn(`${D}: /*@__KEY__*/"scene" is not defined for Babylon texture ${G.name}!`),(0!==G.uAng||0!==G.vAng)&&(N.Tools.Warn(`${D}: Texture ${G.name} with rotation in the u or v axis is not supported in glTF.`),0!==G.uRotationCenter||0!==G.vRotationCenter))return;const V={};let M=!1;if(0===G.uOffset&&0===G.vOffset||(V.offset=[G.uOffset,G.vOffset],M=!0),1===G.uScale&&1===G.vScale||(V.scale=[G.uScale,G.vScale],M=!0),0!==G.wAng){if(0!==G.uRotationCenter||0!==G.vRotationCenter){if(G.homogeneousRotationInUVTransform&&G.uScale!==G.vScale)return void N.Tools.Warn(`${D}: Texture ${G.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Zl}.`);N.Tools.Warn(`${D}: Texture ${G.name} with non-origin rotation center will be exported using an adjusted offset with ${Zl}.`),V.offset=function(D){const{uOffset:l,vOffset:G,uRotationCenter:V,vRotationCenter:N,uScale:M,vScale:b,wAng:X}=D,t=Math.cos(X),R=Math.sin(X),n=V*M,g=N*b;return[l+(n*(1-t)+g*R),G+(g*(1-t)-n*R)]}(G)}V.rotation=-G.wAng,M=!0}0!==G.coordinatesIndex&&(V.texCoord=G.coordinatesIndex,M=!0),M&&(this._wasUsed=!0,l.extensions||(l.extensions={}),l.extensions[Zl]=V)}}PD.RegisterExtension(Zl,(()=>new Jl));class Yl{static CreateSTL(D){let l=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",N=arguments.length>3&&void 0!==arguments[3]&&arguments[3],M=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],b=arguments.length>5&&void 0!==arguments[5]&&arguments[5],X=arguments.length>6&&void 0!==arguments[6]&&arguments[6],t=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const R=function(D,l,G){const N=[3*D[G],3*D[G+1],3*D[G+2]],M=[new V.Kl(l[N[0]],l[N[0]+2],l[N[0]+1]),new V.Kl(l[N[1]],l[N[1]+2],l[N[1]+1]),new V.Kl(l[N[2]],l[N[2]+2],l[N[2]+1])],b=M[0].Fl(M[1]),X=M[2].Fl(M[1]);return{v:M,n:V.Kl.Cross(X,b).normalize()}},g=function(D,l,G,V){return l=j(D,l,G.x,V),l=j(D,l,G.y,V),j(D,l,G.z,V)},j=function(D,l,G,V){return D.setFloat32(l,G,V),l+4},K=function(D){if(X){let l=D;D instanceof e.e&&(l=D.sourceMesh);const G=l.getVerticesData(n.e.PositionKind,!0,!0);if(!G)return[];const N=V.Kl.Zero();let M;for(M=0;M<G.length;M+=3)V.Kl.TransformCoordinatesFromFloatsToRef(G[M],G[M+1],G[M+2],D.hb(!0),N).toArray(G,M);return G}return D.getVerticesData(n.e.PositionKind)||[]};X&&(b=!0);let F="",d=0,H=0;if(N){for(let G=0;G<D.length;G++){const l=D[G].rb();d+=l?l.length/3:0}const l=new ArrayBuffer(84+50*d);F=new DataView(l),H+=80,F.setUint32(H,d,M),H+=4}else t||(F="solid stlmesh\r\n");for(let V=0;V<D.length;V++){const l=D[V];!N&&t&&(F+="solid "+l.name+"\r\n"),!b&&l instanceof hD.b&&l.bakeCurrentTransformIntoVertices();const G=K(l),X=l.rb()||[];for(let D=0;D<X.length;D+=3){const l=R(X,G,D);N?(H=g(F,H,l.n,M),H=g(F,H,l.v[0],M),H=g(F,H,l.v[1],M),H=g(F,H,l.v[2],M),H+=2):(F+="\tfacet normal "+l.n.x+" "+l.n.y+" "+l.n.z+"\r\n",F+="\t\touter loop\r\n",F+="\t\t\tvertex "+l.v[0].x+" "+l.v[0].y+" "+l.v[0].z+"\r\n",F+="\t\t\tvertex "+l.v[1].x+" "+l.v[1].y+" "+l.v[1].z+"\r\n",F+="\t\t\tvertex "+l.v[2].x+" "+l.v[2].y+" "+l.v[2].z+"\r\n",F+="\t\tendloop\r\n",F+="\tendfacet\r\n")}!N&&t&&(F+="endsolid "+name+"\r\n")}if(N||t||(F+="endsolid stlmesh"),l){const D=document.createElement("a"),l=new Blob([F],{type:"application/octet-stream"});D.href=window.URL.createObjectURL(l),D.download=G+".stl",D.click()}return F}}function zl(D,l){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const V=[];for(let N=0;N<D.length/G;N++){const M=D[N*G],b=D[N*G+1],X=D[N*G+2];V.push(`(${M.toPrecision(l.precision)}, ${b.toPrecision(l.precision)}, ${X.toPrecision(l.precision)})`)}return V.join(", ")}function El(D,l){const G=[];for(let V=0;V<D.length/2;V++){const N=D[2*V],M=D[2*V+1];G.push(`(${N.toPrecision(l.precision)}, ${(1-M).toPrecision(l.precision)})`)}return G.join(", ")}function Pl(D,l){const G=D.getVerticesData(n.e.PositionKind),V=D.getVerticesData(n.e.NormalKind);if(G&&V)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(D){var l;const G=null!==(l=D.rb())&&void 0!==l&&l.length?D.getTotalIndices():D.getTotalVertices();return Array(G/3).fill(3).join(", ")}(D)}]\n\t\tint[] faceVertexIndices = [${function(D){const l=D.rb(),G=[];if(null!==l)for(let V=0;V<l.length;V++)G.push(l[V]);else{const l=D.getTotalVertices();for(let D=0;D<l;D++)G.push(D)}return G.join(", ")}(D)}]\n\t\tnormal3f[] normals = [${zl(V,l)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${zl(G,l)}]\n        ${function(D,l){let G="";for(let N=0;N<4;N++){const V=N>0?N:"",M=D.getVerticesData(n.e.UVKind+(V?V+1:""));M&&(G+=`\n\t\ttexCoord2f[] primvars:st${V} = [${El(M,l)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const V=D.getVerticesData(n.e.ColorKind);return V&&(G+=`\n\tcolor3f[] primvars:displayColor = [${zl(V,l,V.length/D.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),G}(D,l)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function pl(D,l){return`\n        def "Geometry"\n        {\n        ${Pl(D,l)}\n        }\n        `}function kl(D){let l='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return l+=D,fflate.strToU8(l)}function ml(D){const l=D.m;return`( ${Tl(l,0)}, ${Tl(l,4)}, ${Tl(l,8)}, ${Tl(l,12)} )`}function Tl(D,l){return`(${D[l+0]}, ${D[l+1]}, ${D[l+2]}, ${D[l+3]})`}function Cl(D){const l="Object_"+D.uniqueId,G=function(D){const l=D.getWorldMatrix().clone(),G=D.uD().useRightHandedSystem;if(!G){let V=D.parent;for(;V;){if(bD(V,G)){l.multiplyToRef(V.getWorldMatrix().invert(),l);break}V=V.parent}}return l.determinant()<0&&N.Tools.Warn(`Exporting mesh ${D.name} with negative scale. Result may look incorrect in destination engine.`),l}(D),V=ml(G);return`def Xform "${l}" (\n\tprepend references = @./geometries/Geometry_${D.xb.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${V}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${D.material.uniqueId}>\n}\n\n`}function wl(D){switch(D){case u.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case u.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case u.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Al(D){return`(${D.x}, ${D.y})`}function al(D){return`(${D.r}, ${D.g}, ${D.b})`}function Ql(D,l,G,N,M,b){const X=D.getInternalTexture().uniqueId+"_"+D.invertY;M[X]=D;const t=D.coordinatesIndex>0?"st"+D.coordinatesIndex:"st",R=new V.Vector2(D.uScale,D.vScale),n=new V.Vector2(D.uOffset,D.vOffset),g=D.wAng,j=Math.sin(g),e=Math.cos(g);return n.y=1-n.y-R.y,n.x+=j*R.x,n.y+=(1-e)*R.y,`\n    def Shader "PrimvarReader_${G}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${t}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${G}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${l.uniqueId}/PrimvarReader_${G}.outputs:result>\n        float inputs:rotation = ${(g*(180/Math.PI)).toFixed(b.precision)}\n        float2 inputs:scale = ${Al(R)}\n        float2 inputs:translation = ${Al(n)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${D.uniqueId}_${G}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${X}.png@\n        float2 inputs:st.connect = </Materials/Material_${l.uniqueId}/Transform2d_${G}.outputs:result>\n        ${N?"float4 inputs:scale = "+function(D){return`(${D.r}, ${D.g}, ${D.b}, 1.0)`}(N):""}\n        token inputs:sourceColorSpace = "${D.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${wl(D.wrapU)}"\n        token inputs:wrapT = "${wl(D.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${l.needAlphaBlending()?"float outputs:a":""}\n    }`}function DG(D,l,G){const V="\t\t\t",N=[],M=[],{diffuseMap:b,Ob:X,alphaCutOff:t,emissiveMap:R,emissive:n,normalMap:g,roughnessMap:j,roughnessChannel:e,roughness:K,metalnessMap:F,metalnessChannel:H,metalness:h,aoMap:x,aoMapChannel:r,aoMapIntensity:o,alphaMap:L,ior:u,clearCoatEnabled:B,clearCoat:I,clearCoatMap:W,clearCoatRoughness:i,clearCoatRoughnessMap:y}=function(D){const l={diffuseMap:null,Ob:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return D instanceof FD.Hl?{...l,diffuseMap:D.diffuseTexture,Ob:D.diffuseColor,alphaCutOff:D.alphaCutOff,emissiveMap:D.emissiveTexture,emissive:D.emissiveColor,roughness:1,alphaMap:D.opacityTexture}:D instanceof Rl.b?{...l,diffuseMap:D._albedoTexture,Ob:D._albedoColor,alphaCutOff:D._alphaCutOff,emissiveMap:D._emissiveTexture,emissive:D._emissiveColor,normalMap:D._bumpTexture,roughnessMap:D._metallicTexture,roughnessChannel:D._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:D._roughness??1,metalnessMap:D._metallicTexture,metalnessChannel:D._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:D._metallic??0,aoMap:D._ambientTexture,aoMapChannel:D._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:D._ambientTextureStrength,alphaMap:D._opacityTexture,ior:D.subSurface.indexOfRefraction,clearCoatEnabled:D.clearCoat.isEnabled,clearCoat:D.clearCoat.Sb,clearCoatMap:D.clearCoat.texture,clearCoatRoughness:D.clearCoat.roughness,clearCoatRoughnessMap:D.clearCoat.useRoughnessFromMainTexture?D.clearCoat.texture:D.clearCoat.textureRoughness}:l}(D);return null!==b?(N.push(`${V}color3f inputs:diffuseColor.connect = </Materials/Material_${D.uniqueId}/Texture_${b.uniqueId}_diffuse.outputs:rgb>`),D.needAlphaBlending()?N.push(`${V}float inputs:opacity.connect = </Materials/Material_${D.uniqueId}/Texture_${b.uniqueId}_diffuse.outputs:a>`):D.needAlphaTesting()&&(N.push(`${V}float inputs:opacity.connect = </Materials/Material_${D.uniqueId}/Texture_${b.uniqueId}_diffuse.outputs:a>`),N.push(`${V}float inputs:opacityThreshold = ${t}`)),M.push(Ql(b,D,"diffuse",X,l,G))):N.push(`${V}color3f inputs:diffuseColor = ${al(X||d.hl.White())}`),null!==R?(N.push(`${V}color3f inputs:emissiveColor.connect = </Materials/Material_${D.uniqueId}/Texture_${R.uniqueId}_emissive.outputs:rgb>`),M.push(Ql(R,D,"emissive",n,l,G))):n&&n.toLuminance()>0&&N.push(`${V}color3f inputs:emissiveColor = ${al(n)}`),null!==g&&(N.push(`${V}normal3f inputs:normal.connect = </Materials/Material_${D.uniqueId}/Texture_${g.uniqueId}_normal.outputs:rgb>`),M.push(Ql(g,D,"normal",null,l,G))),null!==x&&(N.push(`${V}float inputs:occlusion.connect = </Materials/Material_${D.uniqueId}/Texture_${x.uniqueId}_occlusion.outputs:${r}>`),M.push(Ql(x,D,"occlusion",new d.hl(o,o,o),l,G))),null!==j?(N.push(`${V}float inputs:roughness.connect = </Materials/Material_${D.uniqueId}/Texture_${j.uniqueId}_roughness.outputs:${e}>`),M.push(Ql(j,D,"roughness",new d.hl(K,K,K),l,G))):N.push(`${V}float inputs:roughness = ${K}`),null!==F?(N.push(`${V}float inputs:metallic.connect = </Materials/Material_${D.uniqueId}/Texture_${F.uniqueId}_metallic.outputs:${H}>`),M.push(Ql(F,D,"metallic",new d.hl(h,h,h),l,G))):N.push(`${V}float inputs:metallic = ${h}`),null!==L?(N.push(`${V}float inputs:opacity.connect = </Materials/Material_${D.uniqueId}/Texture_${L.uniqueId}_opacity.outputs:r>`),N.push(`${V}float inputs:opacityThreshold = 0.0001`),M.push(Ql(L,D,"opacity",null,l,G))):N.push(`${V}float inputs:opacity = ${D.alpha}`),B&&(null!==W?(N.push(`${V}float inputs:clearcoat.connect = </Materials/Material_${D.uniqueId}/Texture_${W.uniqueId}_clearcoat.outputs:r>`),M.push(Ql(W,D,"clearcoat",new d.hl(I,I,I),l,G))):N.push(`${V}float inputs:clearcoat = ${I}`),null!==y?(N.push(`${V}float inputs:clearcoatRoughness.connect = </Materials/Material_${D.uniqueId}/Texture_${y.uniqueId}_clearcoatRoughness.outputs:g>`),M.push(Ql(y,D,"clearcoatRoughness",new d.hl(i,i,i),l,G))):N.push(`${V}float inputs:clearcoatRoughness = ${i}`)),N.push(`${V}float inputs:ior = ${u}`),`\n\tdef Material "Material_${D.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${N.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${D.uniqueId}/PreviewSurface.outputs:surface>\n\n${M.join("\n")}\n\n\t}\n`}async function lG(D,l,G){const M={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...l};"undefined"===typeof fflate&&await N.Tools.LoadScriptAsync(M.fflateUrl);const b={};b[M.modelFileName]=null;let X='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';X+=function(D){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===D.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${D.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${D.planeAnchoringAlignment}"`:""}\n            `}(M);const t={};for(const V of D.meshes){if(0===V.getTotalVertices())continue;const D=V,l=D.xb,R=D.material;if(!R||!l||G&&!G(D))continue;if(-1!==["Hl","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(R.getClassName())){const G="geometries/Geometry_"+l.uniqueId+".usda";if(!(G in b)){const D=pl(l,M);b[G]=kl(D)}R.uniqueId in t||(t[R.uniqueId]=R),X+=Cl(D)}else N.Tools.Warn("USDZExportAsync does not support this material type: "+R.getClassName())}D.activeCamera&&M.exportCamera&&(X+=function(D,l){const G="Camera_"+D.uniqueId,N=ml(V.Matrix.RotationY(Math.PI).multiply(D.getWorldMatrix()));if(D.mode===u.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${G}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${N}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${D.Kb.toPrecision(l.precision)}, ${D.maxZ.toPrecision(l.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(D.orthoLeft||1)+Math.abs(D.orthoRight||1))).toPrecision(l.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(D.orthoTop||1)+Math.abs(D.orthoBottom||1))).toPrecision(l.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const V=D.getEngine().getAspectRatio(D),M=l.cameraSensorWidth||35;return`def Camera "${G}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${N}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${D.Kb.toPrecision(l.precision)}, ${D.maxZ.toPrecision(l.precision)})\n\t\t\tfloat focalLength = ${(M/(2*Math.tan(.5*D.fov))).toPrecision(l.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(M*V).toPrecision(l.precision)}\n\t\t\tfloat verticalAperture = ${(M/V).toPrecision(l.precision)}            \n\t\t}\n\t\n\t`}}(D.activeCamera,M)),X+="\n            }\n        }\n    }";const R={};X+=function(D,l,G){const V=[];for(const N in D){const M=D[N];V.push(DG(M,l,G))}return`\n    def "Materials"\n{\n${V.join("")}\n}\n\n`}(t,R,M),b[M.modelFileName]=fflate.strToU8(X);for(const V in R){const D=R[V],l=D.getSize(),G=await D.readPixels();if(!G)throw new Error("Texture data is not available");const N=await B.DumpTools.DumpDataAsync(l.width,l.height,G,"image/png",void 0,!1,!0);b[`textures/Texture_${V}.png`]=new Uint8Array(N).slice()}let n=0;for(const V in b){const D=b[V];if(!D)continue;n+=34+V.length;const l=63&n;if(4!==l){const G=new Uint8Array(64-l);b[V]=[D,{extra:{12345:G}}]}n=D.length}return fflate.zipSync(b,{level:0})}}}]);