"use strict";(self.mo7o6813fhb=self.mo7o6813fhb||[]).push([[14],{12392:(t,U,y)=>{y.d(U,{b:()=>mt,c:()=>Y,d:()=>I,g:()=>r});const I=1/2.2,r=2.2,Y=(1+Math.sqrt(5))/2,mt=.001},12404:(t,U,y)=>{function I(t){return parseInt(t.toString().replace(/\W/g,""))}function r(t,U){let y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(t-U)<=y}function Y(t,U,y){let I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return t<U-I||t>y+I}function mt(t,U){return t===U?t:Math.random()*(U-t)+t}function X(t,U,y){return t+(U-t)*y}function P(t,U,y){let I=w(U-t,360);return I>180&&(I-=360),t+I*h(y)}function G(t,U,y){let I=0;return I=t!=U?h((y-t)/(U-t)):0,I}function M(t,U,y,I,r){const Y=r*r,mt=r*Y;return t*(2*mt-3*Y+1)+y*(-2*mt+3*Y)+U*(mt-2*Y+r)+I*(mt-Y)}function L(t,U,y,I,r){const Y=r*r;return 6*(Y-r)*t+(3*Y-4*r+1)*U+6*(-Y+r)*y+(3*Y-2*r)*I}function h(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(y,Math.max(U,t))}function Q(t){return t-=2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function F(t){const U=t.toString(16);return t<=15?("0"+U).toUpperCase():U.toUpperCase()}function E(t){if(Math.log2)return Math.floor(Math.log2(t));if(t<0)return NaN;if(0===t)return-1/0;let U=0;if(t<1){for(;t<1;)U++,t*=2;U=-U}else if(t>1)for(;t>1;)U++,t=Math.floor(t/2);return U}function w(t,U){return t-Math.floor(t/U)*U}function D(t,U,y){return(t-U)/(y-U)}function l(t,U,y){return t*(y-U)+U}function g(t,U){let y=w(U-t,360);return y>180&&(y-=360),y}function B(t,U){const y=w(t,2*U);return U-Math.abs(y-U)}function b(t,U,y){let I=h(y);return I=-2*I*I*I+3*I*I,U*I+t*(1-I)}function p(t,U,y){let I=0;return I=Math.abs(U-t)<=y?U:t+Math.sign(U-t)*y,I}function c(t,U,y){const I=g(t,U);let r=0;return r=-y<I&&I<y?U:p(t,U=t+I,y),r}function f(t,U,y){return(t-U)/(y-U)}function S(t,U,y){return(y-U)*t+U}function N(t,U){const y=t%U;return 0===y?U:N(U,y)}y.r(U),y.d(U,{Clamp:()=>h,DeltaAngle:()=>g,Denormalize:()=>l,ExtractAsInt:()=>I,Hermite:()=>M,Hermite1stDerivative:()=>L,HighestCommonFactor:()=>N,ILog2:()=>E,InverseLerp:()=>G,Lerp:()=>X,LerpAngle:()=>P,MoveTowards:()=>p,MoveTowardsAngle:()=>c,Normalize:()=>D,NormalizeRadians:()=>Q,OutsideRange:()=>Y,PercentToRange:()=>S,PingPong:()=>B,RandomRange:()=>mt,RangeToPercent:()=>f,Repeat:()=>w,SmoothStep:()=>b,ToHex:()=>F,WithinEpsilon:()=>r})},12386:(t,U,y)=>{y.r(U),y.d(U,{Matrix:()=>l,Quaternion:()=>D,TmpVectors:()=>B,Vector2:()=>F,DU:()=>E,Vector4:()=>w});var I=y(12392),r=y(12399),Y=y(12338),mt=y(12313),X=y(12250),P=y(12404);class G{}function M(t,U,y){let I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r=t.bX(),Y=U.bX(),mt=r[0],X=r[1],P=r[2],G=r[3],M=r[4],L=r[5],h=r[6],Q=r[7],F=r[8],E=r[9],w=r[10],D=r[11],l=r[12],g=r[13],B=r[14],b=r[15],p=Y[0],c=Y[1],f=Y[2],S=Y[3],N=Y[4],j=Y[5],J=Y[6],a=Y[7],d=Y[8],q=Y[9],H=Y[10],e=Y[11],o=Y[12],V=Y[13],n=Y[14],i=Y[15];y[I]=mt*p+X*N+P*d+G*o,y[I+1]=mt*c+X*j+P*q+G*V,y[I+2]=mt*f+X*J+P*H+G*n,y[I+3]=mt*S+X*a+P*e+G*i,y[I+4]=M*p+L*N+h*d+Q*o,y[I+5]=M*c+L*j+h*q+Q*V,y[I+6]=M*f+L*J+h*H+Q*n,y[I+7]=M*S+L*a+h*e+Q*i,y[I+8]=F*p+E*N+w*d+D*o,y[I+9]=F*c+E*j+w*q+D*V,y[I+10]=F*f+E*J+w*H+D*n,y[I+11]=F*S+E*a+w*e+D*i,y[I+12]=l*p+g*N+B*d+b*o,y[I+13]=l*c+g*j+B*q+b*V,y[I+14]=l*f+g*J+B*H+b*n,y[I+15]=l*S+g*a+B*e+b*i}function L(t,U){let y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const I=t.bX();U[y]=I[0],U[y+1]=I[1],U[y+2]=I[2],U[y+3]=I[3],U[y+4]=I[4],U[y+5]=I[5],U[y+6]=I[6],U[y+7]=I[7],U[y+8]=I[8],U[y+9]=I[9],U[y+10]=I[10],U[y+11]=I[11],U[y+12]=I[12],U[y+13]=I[13],U[y+14]=I[14],U[y+15]=I[15]}function h(t,U){const y=t.bX(),I=y[0],r=y[1],Y=y[2],mt=y[3],X=y[4],P=y[5],G=y[6],M=y[7],L=y[8],h=y[9],Q=y[10],F=y[11],E=y[12],w=y[13],D=y[14],l=y[15],g=Q*l-D*F,B=h*l-w*F,b=h*D-w*Q,p=L*l-E*F,c=L*D-Q*E,f=L*w-E*h,S=+(P*g-G*B+M*b),N=-(X*g-G*p+M*c),j=+(X*B-P*p+M*f),J=-(X*b-P*c+G*f),a=I*S+r*N+Y*j+mt*J;if(0===a)return!1;const d=1/a,q=G*l-D*M,H=P*l-w*M,e=P*D-w*G,o=X*l-E*M,V=X*D-E*G,n=X*w-E*P,i=G*F-Q*M,v=P*F-h*M,O=P*Q-h*G,k=X*F-L*M,s=X*Q-L*G,x=X*h-L*P,Z=-(r*g-Y*B+mt*b),W=+(I*g-Y*p+mt*c),A=-(I*B-r*p+mt*f),K=+(I*b-r*c+Y*f),C=+(r*q-Y*H+mt*e),R=-(I*q-Y*o+mt*V),u=+(I*H-r*o+mt*n),T=-(I*e-r*V+Y*n),z=-(r*i-Y*v+mt*O),tt=+(I*i-Y*k+mt*s),Ut=-(I*v-r*k+mt*x),yt=+(I*O-r*s+Y*x);return U[0]=S*d,U[1]=Z*d,U[2]=C*d,U[3]=z*d,U[4]=N*d,U[5]=W*d,U[6]=R*d,U[7]=tt*d,U[8]=j*d,U[9]=A*d,U[10]=u*d,U[11]=Ut*d,U[12]=J*d,U[13]=K*d,U[14]=T*d,U[15]=yt*d,!0}G._UpdateFlagSeed=0;const Q=t=>parseInt(t.toString().replace(/\W/g,""));class F{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=t,this.y=U}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let t=Q(this.x);return t=397*t^Q(this.y),t}toArray(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[U]=this.x,t[U+1]=this.y,this}Dy(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F.FromArrayToRef(t,U,this),this}bX(){return[this.x,this.y]}Y(t){return this.x=t.x,this.y=t.y,this}aX(t,U){return this.x=t,this.y=U,this}set(t,U){return this.aX(t,U)}qX(t){return this.aX(t,t)}add(t){return new F(this.x+t.x,this.y+t.y)}addToRef(t,U){return U.x=this.x+t.x,U.y=this.y+t.y,U}addInPlace(t){return this.x+=t.x,this.y+=t.y,this}addInPlaceFromFloats(t,U){return this.x+=t,this.y+=U,this}addVector3(t){return new F(this.x+t.x,this.y+t.y)}lU(t){return new F(this.x-t.x,this.y-t.y)}subtractToRef(t,U){return U.x=this.x-t.x,U.y=this.y-t.y,U}GL(t){return this.x-=t.x,this.y-=t.y,this}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this}multiply(t){return new F(this.x*t.x,this.y*t.y)}multiplyToRef(t,U){return U.x=this.x*t.x,U.y=this.y*t.y,U}multiplyByFloats(t,U){return new F(this.x*t,this.y*U)}divide(t){return new F(this.x/t.x,this.y/t.y)}divideToRef(t,U){return U.x=this.x/t.x,U.y=this.y/t.y,U}divideInPlace(t){return this.x=this.x/t.x,this.y=this.y/t.y,this}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t.x,t.y)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t.x,t.y)}minimizeInPlaceFromFloats(t,U){return this.x=Math.min(t,this.x),this.y=Math.min(U,this.y),this}maximizeInPlaceFromFloats(t,U){return this.x=Math.max(t,this.x),this.y=Math.max(U,this.y),this}subtractFromFloats(t,U){return new F(this.x-t,this.y-U)}subtractFromFloatsToRef(t,U,y){return y.x=this.x-t,y.y=this.y-U,y}negate(){return new F(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(t){return t.x=-this.x,t.y=-this.y,t}scaleInPlace(t){return this.x*=t,this.y*=t,this}scale(t){return new F(this.x*t,this.y*t)}scaleToRef(t,U){return U.x=this.x*t,U.y=this.y*t,U}scaleAndAddToRef(t,U){return U.x+=this.x*t,U.y+=this.y*t,U}equals(t){return t&&this.x===t.x&&this.y===t.y}equalsWithEpsilon(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:I.b;return t&&(0,P.WithinEpsilon)(this.x,t.x,U)&&(0,P.WithinEpsilon)(this.y,t.y,U)}equalsToFloats(t,U){return this.x===t&&this.y===U}floor(){return new F(Math.floor(this.x),Math.floor(this.y))}floorToRef(t){return t.x=Math.floor(this.x),t.y=Math.floor(this.y),t}fract(){return new F(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(t){return t.x=this.x-Math.floor(this.x),t.y=this.y-Math.floor(this.y),t}rotate(t){return this.rotateToRef(t,new F)}rotateToRef(t,U){const y=Math.cos(t),I=Math.sin(t);return U.x=y*this.x-I*this.y,U.y=I*this.x+y*this.y,U}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){const t=new F;return this.normalizeToRef(t),t}normalizeToRef(t){const U=this.length();return 0===U&&(t.x=this.x,t.y=this.y),this.scaleToRef(1/U,t)}clone(){return new F(this.x,this.y)}dot(t){return this.x*t.x+this.y*t.y}static Zero(){return new F(0,0)}static One(){return new F(1,1)}static Random(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new F((0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U))}static RandomToRef(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).aX((0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U))}static get ZeroReadOnly(){return F._ZeroReadOnly}static pU(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(t[U],t[U+1])}static FromArrayToRef(t,U,y){return y.x=t[U],y.y=t[U+1],y}static FromFloatsToRef(t,U,y){return y.aX(t,U),y}static CatmullRom(t,U,y,I,r){const Y=r*r,mt=r*Y,X=.5*(2*U.x+(-t.x+y.x)*r+(2*t.x-5*U.x+4*y.x-I.x)*Y+(-t.x+3*U.x-3*y.x+I.x)*mt),P=.5*(2*U.y+(-t.y+y.y)*r+(2*t.y-5*U.y+4*y.y-I.y)*Y+(-t.y+3*U.y-3*y.y+I.y)*mt);return new F(X,P)}static ClampToRef(t,U,y,I){return I.x=(0,P.Clamp)(t.x,U.x,y.x),I.y=(0,P.Clamp)(t.y,U.y,y.y),I}static Clamp(t,U,y){const I=(0,P.Clamp)(t.x,U.x,y.x),r=(0,P.Clamp)(t.y,U.y,y.y);return new F(I,r)}static Hermite(t,U,y,I,r){const Y=r*r,mt=r*Y,X=2*mt-3*Y+1,P=-2*mt+3*Y,G=mt-2*Y+r,M=mt-Y,L=t.x*X+y.x*P+U.x*G+I.x*M,h=t.y*X+y.y*P+U.y*G+I.y*M;return new F(L,h)}static Hermite1stDerivative(t,U,y,I,r){return this.Hermite1stDerivativeToRef(t,U,y,I,r,new F)}static Hermite1stDerivativeToRef(t,U,y,I,r,Y){const mt=r*r;return Y.x=6*(mt-r)*t.x+(3*mt-4*r+1)*U.x+6*(-mt+r)*y.x+(3*mt-2*r)*I.x,Y.y=6*(mt-r)*t.y+(3*mt-4*r+1)*U.y+6*(-mt+r)*y.y+(3*mt-2*r)*I.y,Y}static Lerp(t,U,y){return F.LerpToRef(t,U,y,new F)}static LerpToRef(t,U,y,I){return I.x=t.x+(U.x-t.x)*y,I.y=t.y+(U.y-t.y)*y,I}static Dot(t,U){return t.x*U.x+t.y*U.y}static Normalize(t){return F.NormalizeToRef(t,new F)}static NormalizeToRef(t,U){return t.normalizeToRef(U),U}static Minimize(t,U){const y=t.x<U.x?t.x:U.x,I=t.y<U.y?t.y:U.y;return new F(y,I)}static Maximize(t,U){const y=t.x>U.x?t.x:U.x,I=t.y>U.y?t.y:U.y;return new F(y,I)}static Transform(t,U){return F.TransformToRef(t,U,new F)}static TransformToRef(t,U,y){const I=U.m,r=t.x*I[0]+t.y*I[4]+I[12],Y=t.x*I[1]+t.y*I[5]+I[13];return y.x=r,y.y=Y,y}static PointInTriangle(t,U,y,I){const r=.5*(-y.y*I.x+U.y*(-y.x+I.x)+U.x*(y.y-I.y)+y.x*I.y),Y=r<0?-1:1,mt=(U.y*I.x-U.x*I.y+(I.y-U.y)*t.x+(U.x-I.x)*t.y)*Y,X=(U.x*y.y-U.y*y.x+(U.y-y.y)*t.x+(y.x-U.x)*t.y)*Y;return mt>0&&X>0&&mt+X<2*r*Y}static Distance(t,U){return Math.sqrt(F.DistanceSquared(t,U))}static DistanceSquared(t,U){const y=t.x-U.x,I=t.y-U.y;return y*y+I*I}static Center(t,U){return F.CenterToRef(t,U,new F)}static CenterToRef(t,U,y){return y.aX((t.x+U.x)/2,(t.y+U.y)/2)}static DistanceOfPointFromSegment(t,U,y){const I=F.DistanceSquared(U,y);if(0===I)return F.Distance(t,U);const r=y.lU(U),Y=Math.max(0,Math.min(1,F.Dot(t.lU(U),r)/I)),mt=U.add(r.multiplyByFloats(Y,Y));return F.Distance(t,mt)}}F._V8PerformanceHack=new F(.5,.5),F._ZeroReadOnly=F.Zero(),Object.defineProperties(F.prototype,{dimension:{value:[2]},rank:{value:1}});class E{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=t,this._y=U,this._z=y}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"DU"}getHashCode(){let t=Q(this._x);return t=397*t^Q(this._y),t=397*t^Q(this._z),t}bX(){return[this._x,this._y,this._z]}toArray(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[U]=this._x,t[U+1]=this._y,t[U+2]=this._z,this}Dy(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(t,U,this),this}toQuaternion(){return D.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this._isDirty=!0,this}addInPlaceFromFloats(t,U,y){return this._x+=t,this._y+=U,this._z+=y,this._isDirty=!0,this}add(t){return new E(this._x+t._x,this._y+t._y,this._z+t._z)}addToRef(t,U){return U._x=this._x+t._x,U._y=this._y+t._y,U._z=this._z+t._z,U._isDirty=!0,U}GL(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._isDirty=!0,this}lU(t){return new E(this._x-t._x,this._y-t._y,this._z-t._z)}subtractToRef(t,U){return this.subtractFromFloatsToRef(t._x,t._y,t._z,U)}subtractFromFloats(t,U,y){return new E(this._x-t,this._y-U,this._z-y)}subtractFromFloatsToRef(t,U,y,I){return I._x=this._x-t,I._y=this._y-U,I._z=this._z-y,I._isDirty=!0,I}negate(){return new E(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(t){return t._x=-1*this._x,t._y=-1*this._y,t._z=-1*this._z,t._isDirty=!0,t}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._isDirty=!0,this}scale(t){return new E(this._x*t,this._y*t,this._z*t)}scaleToRef(t,U){return U._x=this._x*t,U._y=this._y*t,U._z=this._z*t,U._isDirty=!0,U}getNormalToRef(t){const U=this.length();let y=Math.acos(this._y/U);const I=Math.atan2(this._z,this._x);y>Math.PI/2?y-=Math.PI/2:y+=Math.PI/2;const r=U*Math.sin(y)*Math.cos(I),Y=U*Math.cos(y),mt=U*Math.sin(y)*Math.sin(I);return t.set(r,Y,mt),t}applyRotationQuaternionToRef(t,U){const y=this._x,I=this._y,r=this._z,Y=t._x,mt=t._y,X=t._z,P=t._w,G=2*(mt*r-X*I),M=2*(X*y-Y*r),L=2*(Y*I-mt*y);return U._x=y+P*G+mt*L-X*M,U._y=I+P*M+X*G-Y*L,U._z=r+P*L+Y*M-mt*G,U._isDirty=!0,U}applyRotationQuaternionInPlace(t){return this.applyRotationQuaternionToRef(t,this)}applyRotationQuaternion(t){return this.applyRotationQuaternionToRef(t,new E)}scaleAndAddToRef(t,U){return U._x+=this._x*t,U._y+=this._y*t,U._z+=this._z*t,U._isDirty=!0,U}projectOnPlane(t,U){return this.projectOnPlaneToRef(t,U,new E)}projectOnPlaneToRef(t,U,y){const I=t.normal,r=t.d,Y=g.DU[0];this.subtractToRef(U,Y),Y.normalize();const mt=E.Dot(Y,I);if(Math.abs(mt)<1e-10)y.qX(1/0);else{const t=-(E.Dot(U,I)+r)/mt,X=Y.scaleInPlace(t);U.addToRef(X,y)}return y}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z}equalsWithEpsilon(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:I.b;return t&&(0,P.WithinEpsilon)(this._x,t._x,U)&&(0,P.WithinEpsilon)(this._y,t._y,U)&&(0,P.WithinEpsilon)(this._z,t._z,U)}equalsToFloats(t,U,y){return this._x===t&&this._y===U&&this._z===y}multiplyInPlace(t){return this._x*=t._x,this._y*=t._y,this._z*=t._z,this._isDirty=!0,this}multiply(t){return this.multiplyByFloats(t._x,t._y,t._z)}multiplyToRef(t,U){return U._x=this._x*t._x,U._y=this._y*t._y,U._z=this._z*t._z,U._isDirty=!0,U}multiplyByFloats(t,U,y){return new E(this._x*t,this._y*U,this._z*y)}divide(t){return new E(this._x/t._x,this._y/t._y,this._z/t._z)}divideToRef(t,U){return U._x=this._x/t._x,U._y=this._y/t._y,U._z=this._z/t._z,U._isDirty=!0,U}divideInPlace(t){return this._x=this._x/t._x,this._y=this._y/t._y,this._z=this._z/t._z,this._isDirty=!0,this}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t._x,t._y,t._z)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t._x,t._y,t._z)}minimizeInPlaceFromFloats(t,U,y){return t<this._x&&(this.x=t),U<this._y&&(this.y=U),y<this._z&&(this.z=y),this}maximizeInPlaceFromFloats(t,U,y){return t>this._x&&(this.x=t),U>this._y&&(this.y=U),y>this._z&&(this.z=y),this}isNonUniformWithinEpsilon(t){const U=Math.abs(this._x),y=Math.abs(this._y);if(!(0,P.WithinEpsilon)(U,y,t))return!0;const I=Math.abs(this._z);return!(0,P.WithinEpsilon)(U,I,t)||!(0,P.WithinEpsilon)(y,I,t)}get isNonUniform(){const t=Math.abs(this._x);if(t!==Math.abs(this._y))return!0;return t!==Math.abs(this._z)}floorToRef(t){return t._x=Math.floor(this._x),t._y=Math.floor(this._y),t._z=Math.floor(this._z),t._isDirty=!0,t}floor(){return new E(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(t){return t._x=this._x-Math.floor(this._x),t._y=this._y-Math.floor(this._y),t._z=this._z-Math.floor(this._z),t._isDirty=!0,t}fract(){return new E(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(t){if("xyz"===(t=t.toLowerCase()))return this;const U=g.DU[0].Y(this);return this.x=U[t[0]],this.y=U[t[1]],this.z=U[t[2]],this}rotateByQuaternionToRef(t,U){return t.toRotationMatrix(g.Matrix[0]),E.TransformCoordinatesToRef(this,g.Matrix[0],U),U}rotateByQuaternionAroundPointToRef(t,U,y){return this.subtractToRef(U,g.DU[0]),g.DU[0].rotateByQuaternionToRef(t,g.DU[0]),U.addToRef(g.DU[0],y),y}cross(t){return E.CrossToRef(this,t,new E)}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){return this.normalizeToRef(new E)}normalizeToRef(t){const U=this.length();return 0===U||1===U?(t._x=this._x,t._y=this._y,t._z=this._z,t._isDirty=!0,t):this.scaleToRef(1/U,t)}clone(){return new E(this._x,this._y,this._z)}Y(t){return this.aX(t._x,t._y,t._z)}aX(t,U,y){return this._x=t,this._y=U,this._z=y,this._isDirty=!0,this}set(t,U,y){return this.aX(t,U,y)}qX(t){return this._x=this._y=this._z=t,this._isDirty=!0,this}static GetClipFactor(t,U,y,I){const r=E.Dot(t,y);return(r-I)/(r-E.Dot(U,y))}static GetAngleBetweenVectors(t,U,y){const I=t.normalizeToRef(g.DU[1]),r=U.normalizeToRef(g.DU[2]);let Y=E.Dot(I,r);Y=(0,P.Clamp)(Y,-1,1);const mt=Math.acos(Y),X=g.DU[3];return E.CrossToRef(I,r,X),E.Dot(X,y)>0?isNaN(mt)?0:mt:isNaN(mt)?-Math.PI:-Math.acos(Y)}static GetAngleBetweenVectorsOnPlane(t,U,y){g.DU[0].Y(t);const I=g.DU[0];g.DU[1].Y(U);const r=g.DU[1];g.DU[2].Y(y);const Y=g.DU[2],mt=g.DU[3],X=g.DU[4];I.normalize(),r.normalize(),Y.normalize(),E.CrossToRef(Y,I,mt),E.CrossToRef(mt,Y,X);const G=Math.atan2(E.Dot(r,mt),E.Dot(r,X));return(0,P.NormalizeRadians)(G)}static PitchYawRollToMoveBetweenPointsToRef(t,U,y){const I=B.DU[0];return U.subtractToRef(t,I),y._y=Math.atan2(I.x,I.z)||0,y._x=Math.atan2(Math.sqrt(I.x**2+I.z**2),I.y)||0,y._z=0,y._isDirty=!0,y}static PitchYawRollToMoveBetweenPoints(t,U){const y=E.Zero();return E.PitchYawRollToMoveBetweenPointsToRef(t,U,y)}static SlerpToRef(t,U,y,r){y=(0,P.Clamp)(y,0,1);const Y=g.DU[0],mt=g.DU[1];Y.Y(t);const X=Y.length();Y.normalizeFromLength(X),mt.Y(U);const G=mt.length();mt.normalizeFromLength(G);const M=E.Dot(Y,mt);let L,h;if(M<1-I.b){const t=Math.acos(M),U=1/Math.sin(t);L=Math.sin((1-y)*t)*U,h=Math.sin(y*t)*U}else L=1-y,h=y;return Y.scaleInPlace(L),mt.scaleInPlace(h),r.Y(Y).addInPlace(mt),r.scaleInPlace((0,P.Lerp)(X,G,y)),r}static SmoothToRef(t,U,y,I,r){return E.SlerpToRef(t,U,0===I?1:y/I,r),r}static pU(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(t[U],t[U+1],t[U+2])}static FromFloatArray(t,U){return E.pU(t,U)}static FromArrayToRef(t,U,y){return y._x=t[U],y._y=t[U+1],y._z=t[U+2],y._isDirty=!0,y}static FromFloatArrayToRef(t,U,y){return E.FromArrayToRef(t,U,y)}static FromFloatsToRef(t,U,y,I){return I.aX(t,U,y),I}static Zero(){return new E(0,0,0)}static One(){return new E(1,1,1)}static Up(){return new E(0,1,0)}static get UpReadOnly(){return E._UpReadOnly}static get DownReadOnly(){return E._DownReadOnly}static get RightReadOnly(){return E._RightReadOnly}static get LeftReadOnly(){return E._LeftReadOnly}static get LeftHandedForwardReadOnly(){return E._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return E._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return E._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return E._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return E._ZeroReadOnly}static get OneReadOnly(){return E._OneReadOnly}static Down(){return new E(0,-1,0)}static Forward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new E(1,0,0)}static Left(){return new E(-1,0,0)}static Random(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E((0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U))}static RandomToRef(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).aX((0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U))}static TransformCoordinates(t,U){const y=E.Zero();return E.TransformCoordinatesToRef(t,U,y),y}static TransformCoordinatesToRef(t,U,y){return E.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,U,y),y}static TransformCoordinatesFromFloatsToRef(t,U,y,I,r){const Y=I.m,mt=t*Y[0]+U*Y[4]+y*Y[8]+Y[12],X=t*Y[1]+U*Y[5]+y*Y[9]+Y[13],P=t*Y[2]+U*Y[6]+y*Y[10]+Y[14],G=1/(t*Y[3]+U*Y[7]+y*Y[11]+Y[15]);return r._x=mt*G,r._y=X*G,r._z=P*G,r._isDirty=!0,r}static TransformNormal(t,U){const y=E.Zero();return E.TransformNormalToRef(t,U,y),y}static TransformNormalToRef(t,U,y){return this.TransformNormalFromFloatsToRef(t._x,t._y,t._z,U,y),y}static TransformNormalFromFloatsToRef(t,U,y,I,r){const Y=I.m;return r._x=t*Y[0]+U*Y[4]+y*Y[8],r._y=t*Y[1]+U*Y[5]+y*Y[9],r._z=t*Y[2]+U*Y[6]+y*Y[10],r._isDirty=!0,r}static CatmullRom(t,U,y,I,r){const Y=r*r,mt=r*Y,X=.5*(2*U._x+(-t._x+y._x)*r+(2*t._x-5*U._x+4*y._x-I._x)*Y+(-t._x+3*U._x-3*y._x+I._x)*mt),P=.5*(2*U._y+(-t._y+y._y)*r+(2*t._y-5*U._y+4*y._y-I._y)*Y+(-t._y+3*U._y-3*y._y+I._y)*mt),G=.5*(2*U._z+(-t._z+y._z)*r+(2*t._z-5*U._z+4*y._z-I._z)*Y+(-t._z+3*U._z-3*y._z+I._z)*mt);return new E(X,P,G)}static Clamp(t,U,y){const I=new E;return E.ClampToRef(t,U,y,I),I}static ClampToRef(t,U,y,I){let r=t._x;r=r>y._x?y._x:r,r=r<U._x?U._x:r;let Y=t._y;Y=Y>y._y?y._y:Y,Y=Y<U._y?U._y:Y;let mt=t._z;return mt=mt>y._z?y._z:mt,mt=mt<U._z?U._z:mt,I.aX(r,Y,mt),I}static CheckExtends(t,U,y){U.minimizeInPlace(t),y.maximizeInPlace(t)}static Hermite(t,U,y,I,r){const Y=r*r,mt=r*Y,X=2*mt-3*Y+1,P=-2*mt+3*Y,G=mt-2*Y+r,M=mt-Y,L=t._x*X+y._x*P+U._x*G+I._x*M,h=t._y*X+y._y*P+U._y*G+I._y*M,Q=t._z*X+y._z*P+U._z*G+I._z*M;return new E(L,h,Q)}static Hermite1stDerivative(t,U,y,I,r){const Y=new E;return this.Hermite1stDerivativeToRef(t,U,y,I,r,Y),Y}static Hermite1stDerivativeToRef(t,U,y,I,r,Y){const mt=r*r;return Y._x=6*(mt-r)*t._x+(3*mt-4*r+1)*U._x+6*(-mt+r)*y._x+(3*mt-2*r)*I._x,Y._y=6*(mt-r)*t._y+(3*mt-4*r+1)*U._y+6*(-mt+r)*y._y+(3*mt-2*r)*I._y,Y._z=6*(mt-r)*t._z+(3*mt-4*r+1)*U._z+6*(-mt+r)*y._z+(3*mt-2*r)*I._z,Y._isDirty=!0,Y}static Lerp(t,U,y){const I=new E(0,0,0);return E.LerpToRef(t,U,y,I),I}static LerpToRef(t,U,y,I){return I._x=t._x+(U._x-t._x)*y,I._y=t._y+(U._y-t._y)*y,I._z=t._z+(U._z-t._z)*y,I._isDirty=!0,I}static Dot(t,U){return t._x*U._x+t._y*U._y+t._z*U._z}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z}static Cross(t,U){const y=new E;return E.CrossToRef(t,U,y),y}static CrossToRef(t,U,y){const I=t._y*U._z-t._z*U._y,r=t._z*U._x-t._x*U._z,Y=t._x*U._y-t._y*U._x;return y.aX(I,r,Y),y}static Normalize(t){const U=E.Zero();return E.NormalizeToRef(t,U),U}static NormalizeToRef(t,U){return t.normalizeToRef(U),U}static Project(t,U,y,I){const r=new E;return E.ProjectToRef(t,U,y,I,r),r}static ProjectToRef(t,U,y,I,r){var Y;const mt=I.width,P=I.height,G=I.x,M=I.y,L=g.Matrix[1],h=null===(Y=X.d.LastCreatedEngine)||void 0===Y?void 0:Y.isNDCHalfZRange,Q=h?1:.5,F=h?0:.5;l.FromValuesToRef(mt/2,0,0,0,0,-P/2,0,0,0,0,Q,0,G+mt/2,P/2+M,F,1,L);const w=g.Matrix[0];return U.multiplyToRef(y,w),w.multiplyToRef(L,w),E.TransformCoordinatesToRef(t,w,r),r}static Reflect(t,U){return this.ReflectToRef(t,U,new E)}static ReflectToRef(t,U,y){const I=B.DU[0];return I.Y(U).scaleInPlace(2*E.Dot(t,U)),y.Y(t).GL(I)}static _UnprojectFromInvertedMatrixToRef(t,U,y){E.TransformCoordinatesToRef(t,U,y);const I=U.m,r=t._x*I[3]+t._y*I[7]+t._z*I[11]+I[15];return(0,P.WithinEpsilon)(r,1)&&y.scaleInPlace(1/r),y}static UnprojectFromTransform(t,U,y,I,r){return this.Unproject(t,U,y,I,r,l.IdentityReadOnly)}static Unproject(t,U,y,I,r,Y){const mt=new E;return E.UnprojectToRef(t,U,y,I,r,Y,mt),mt}static UnprojectToRef(t,U,y,I,r,Y,mt){return E.UnprojectFloatsToRef(t._x,t._y,t._z,U,y,I,r,Y,mt),mt}static UnprojectFloatsToRef(t,U,y,I,r,Y,mt,P,G){var M;const L=g.Matrix[0];Y.multiplyToRef(mt,L),L.multiplyToRef(P,L),L.invert();const h=g.DU[0];return h.x=t/I*2-1,h.y=-(U/r*2-1),null!==(M=X.d.LastCreatedEngine)&&void 0!==M&&M.isNDCHalfZRange?h.z=y:h.z=2*y-1,E._UnprojectFromInvertedMatrixToRef(h,L,G),G}static Minimize(t,U){const y=new E;return y.Y(t),y.minimizeInPlace(U),y}static Maximize(t,U){const y=new E;return y.Y(t),y.maximizeInPlace(U),y}static Distance(t,U){return Math.sqrt(E.DistanceSquared(t,U))}static DistanceSquared(t,U){const y=t._x-U._x,I=t._y-U._y,r=t._z-U._z;return y*y+I*I+r*r}static ProjectOnTriangleToRef(t,U,y,r,Y){const mt=g.DU[0],X=g.DU[1],G=g.DU[2],M=g.DU[3],L=g.DU[4];y.subtractToRef(U,mt),r.subtractToRef(U,X),r.subtractToRef(y,G);const h=mt.length(),Q=X.length(),F=G.length();if(h<I.b||Q<I.b||F<I.b)return Y.Y(U),E.Distance(t,U);t.subtractToRef(U,L),E.CrossToRef(mt,X,M);const w=M.length();if(w<I.b)return Y.Y(U),E.Distance(t,U);M.normalizeFromLength(w);let D=L.length();if(D<I.b)return Y.Y(U),0;L.normalizeFromLength(D);const l=E.Dot(M,L),B=g.DU[5],b=g.DU[6];B.Y(M).scaleInPlace(-D*l),b.Y(t).addInPlace(B);const p=g.DU[4],c=g.DU[5],f=g.DU[7],S=g.DU[8];p.Y(mt).scaleInPlace(1/h),S.Y(X).scaleInPlace(1/Q),p.addInPlace(S).scaleInPlace(-1),c.Y(mt).scaleInPlace(-1/h),S.Y(G).scaleInPlace(1/F),c.addInPlace(S).scaleInPlace(-1),f.Y(G).scaleInPlace(-1/F),S.Y(X).scaleInPlace(-1/Q),f.addInPlace(S).scaleInPlace(-1);const N=g.DU[9];let j;N.Y(b).GL(U),E.CrossToRef(p,N,S),j=E.Dot(S,M);const J=j;N.Y(b).GL(y),E.CrossToRef(c,N,S),j=E.Dot(S,M);const a=j;N.Y(b).GL(r),E.CrossToRef(f,N,S),j=E.Dot(S,M);const d=j,q=g.DU[10];let H,e;J>0&&a<0?(q.Y(mt),H=U,e=y):a>0&&d<0?(q.Y(G),H=y,e=r):(q.Y(X).scaleInPlace(-1),H=r,e=U);const o=g.DU[9],V=g.DU[4];H.subtractToRef(b,S),e.subtractToRef(b,o),E.CrossToRef(S,o,V);if(!(E.Dot(V,M)<0))return Y.Y(b),Math.abs(D*l);const n=g.DU[5];E.CrossToRef(q,V,n),n.normalize();const i=g.DU[9];i.Y(H).GL(b);const v=i.length();if(v<I.b)return Y.Y(H),E.Distance(t,H);i.normalizeFromLength(v);const O=E.Dot(n,i),k=g.DU[7];k.Y(b).addInPlace(n.scaleInPlace(v*O)),S.Y(k).GL(H),D=q.length(),q.normalizeFromLength(D);let s=E.Dot(S,q)/Math.max(D,I.b);return s=(0,P.Clamp)(s,0,1),k.Y(H).addInPlace(q.scaleInPlace(s*D)),Y.Y(k),E.Distance(t,k)}static Center(t,U){return E.CenterToRef(t,U,E.Zero())}static CenterToRef(t,U,y){return y.aX((t._x+U._x)/2,(t._y+U._y)/2,(t._z+U._z)/2)}static RotationFromAxis(t,U,y){const I=new E;return E.RotationFromAxisToRef(t,U,y,I),I}static RotationFromAxisToRef(t,U,y,I){const r=g.Quaternion[0];return D.RotationQuaternionFromAxisToRef(t,U,y,r),r.toEulerAnglesToRef(I),I}}E._V8PerformanceHack=new E(.5,.5,.5),E._UpReadOnly=E.Up(),E._DownReadOnly=E.Down(),E._LeftHandedForwardReadOnly=E.Forward(!1),E._RightHandedForwardReadOnly=E.Forward(!0),E._LeftHandedBackwardReadOnly=E.Backward(!1),E._RightHandedBackwardReadOnly=E.Backward(!0),E._RightReadOnly=E.Right(),E._LeftReadOnly=E.Left(),E._ZeroReadOnly=E.Zero(),E._OneReadOnly=E.One(),Object.defineProperties(E.prototype,{dimension:{value:[3]},rank:{value:1}});class w{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}get w(){return this._w}set w(t){this._w=t,this._isDirty=!0}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=t,this._y=U,this._z=y,this._w=I}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let t=Q(this._x);return t=397*t^Q(this._y),t=397*t^Q(this._z),t=397*t^Q(this._w),t}bX(){return[this._x,this._y,this._z,this._w]}toArray(t,U){return void 0===U&&(U=0),t[U]=this._x,t[U+1]=this._y,t[U+2]=this._z,t[U+3]=this._w,this}Dy(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w.FromArrayToRef(t,U,this),this}addInPlace(t){return this.x+=t._x,this.y+=t._y,this.z+=t._z,this.w+=t._w,this}addInPlaceFromFloats(t,U,y,I){return this.x+=t,this.y+=U,this.z+=y,this.w+=I,this}add(t){return new w(this._x+t.x,this._y+t.y,this._z+t.z,this._w+t.w)}addToRef(t,U){return U.x=this._x+t.x,U.y=this._y+t.y,U.z=this._z+t.z,U.w=this._w+t.w,U}GL(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}lU(t){return new w(this._x-t.x,this._y-t.y,this._z-t.z,this._w-t.w)}subtractToRef(t,U){return U.x=this._x-t.x,U.y=this._y-t.y,U.z=this._z-t.z,U.w=this._w-t.w,U}subtractFromFloats(t,U,y,I){return new w(this._x-t,this._y-U,this._z-y,this._w-I)}subtractFromFloatsToRef(t,U,y,I,r){return r.x=this._x-t,r.y=this._y-U,r.z=this._z-y,r.w=this._w-I,r}negate(){return new w(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(t){return t.x=-this._x,t.y=-this._y,t.z=-this._z,t.w=-this._w,t}scaleInPlace(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}scale(t){return new w(this._x*t,this._y*t,this._z*t,this._w*t)}scaleToRef(t,U){return U.x=this._x*t,U.y=this._y*t,U.z=this._z*t,U.w=this._w*t,U}scaleAndAddToRef(t,U){return U.x+=this._x*t,U.y+=this._y*t,U.z+=this._z*t,U.w+=this._w*t,U}equals(t){return t&&this._x===t.x&&this._y===t.y&&this._z===t.z&&this._w===t.w}equalsWithEpsilon(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:I.b;return t&&(0,P.WithinEpsilon)(this._x,t.x,U)&&(0,P.WithinEpsilon)(this._y,t.y,U)&&(0,P.WithinEpsilon)(this._z,t.z,U)&&(0,P.WithinEpsilon)(this._w,t.w,U)}equalsToFloats(t,U,y,I){return this._x===t&&this._y===U&&this._z===y&&this._w===I}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiply(t){return new w(this._x*t.x,this._y*t.y,this._z*t.z,this._w*t.w)}multiplyToRef(t,U){return U.x=this._x*t.x,U.y=this._y*t.y,U.z=this._z*t.z,U.w=this._w*t.w,U}multiplyByFloats(t,U,y,I){return new w(this._x*t,this._y*U,this._z*y,this._w*I)}divide(t){return new w(this._x/t.x,this._y/t.y,this._z/t.z,this._w/t.w)}divideToRef(t,U){return U.x=this._x/t.x,U.y=this._y/t.y,U.z=this._z/t.z,U.w=this._w/t.w,U}divideInPlace(t){return this.divideToRef(t,this)}minimizeInPlace(t){return t.x<this._x&&(this.x=t.x),t.y<this._y&&(this.y=t.y),t.z<this._z&&(this.z=t.z),t.w<this._w&&(this.w=t.w),this}maximizeInPlace(t){return t.x>this._x&&(this.x=t.x),t.y>this._y&&(this.y=t.y),t.z>this._z&&(this.z=t.z),t.w>this._w&&(this.w=t.w),this}minimizeInPlaceFromFloats(t,U,y,I){return this.x=Math.min(t,this._x),this.y=Math.min(U,this._y),this.z=Math.min(y,this._z),this.w=Math.min(I,this._w),this}maximizeInPlaceFromFloats(t,U,y,I){return this.x=Math.max(t,this._x),this.y=Math.max(U,this._y),this.z=Math.max(y,this._z),this.w=Math.max(I,this._w),this}floorToRef(t){return t.x=Math.floor(this._x),t.y=Math.floor(this._y),t.z=Math.floor(this._z),t.w=Math.floor(this._w),t}floor(){return new w(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(t){return t.x=this._x-Math.floor(this._x),t.y=this._y-Math.floor(this._y),t.z=this._z-Math.floor(this._z),t.w=this._w-Math.floor(this._w),t}fract(){return new w(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){return this.normalizeToRef(new w)}normalizeToRef(t){const U=this.length();return 0===U||1===U?(t.x=this._x,t.y=this._y,t.z=this._z,t.w=this._w,t):this.scaleToRef(1/U,t)}toVector3(){return new E(this._x,this._y,this._z)}clone(){return new w(this._x,this._y,this._z,this._w)}Y(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}aX(t,U,y,I){return this.x=t,this.y=U,this.z=y,this.w=I,this}set(t,U,y,I){return this.aX(t,U,y,I)}qX(t){return this.x=this.y=this.z=this.w=t,this}dot(t){return this._x*t.x+this._y*t.y+this._z*t.z+this._w*t.w}static pU(t,U){return U||(U=0),new w(t[U],t[U+1],t[U+2],t[U+3])}static FromArrayToRef(t,U,y){return y.x=t[U],y.y=t[U+1],y.z=t[U+2],y.w=t[U+3],y}static FromFloatArrayToRef(t,U,y){return w.FromArrayToRef(t,U,y),y}static FromFloatsToRef(t,U,y,I,r){return r.x=t,r.y=U,r.z=y,r.w=I,r}static Zero(){return new w(0,0,0,0)}static One(){return new w(1,1,1,1)}static Random(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new w((0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U))}static RandomToRef(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,y=arguments.length>2?arguments[2]:void 0;return y.x=(0,P.RandomRange)(t,U),y.y=(0,P.RandomRange)(t,U),y.z=(0,P.RandomRange)(t,U),y.w=(0,P.RandomRange)(t,U),y}static Clamp(t,U,y){return w.ClampToRef(t,U,y,new w)}static ClampToRef(t,U,y,I){return I.x=(0,P.Clamp)(t.x,U.x,y.x),I.y=(0,P.Clamp)(t.y,U.y,y.y),I.z=(0,P.Clamp)(t.z,U.z,y.z),I.w=(0,P.Clamp)(t.w,U.w,y.w),I}static CheckExtends(t,U,y){U.minimizeInPlace(t),y.maximizeInPlace(t)}static get ZeroReadOnly(){return w._ZeroReadOnly}static Normalize(t){return w.NormalizeToRef(t,new w)}static NormalizeToRef(t,U){return t.normalizeToRef(U),U}static Minimize(t,U){const y=new w;return y.Y(t),y.minimizeInPlace(U),y}static Maximize(t,U){const y=new w;return y.Y(t),y.maximizeInPlace(U),y}static Distance(t,U){return Math.sqrt(w.DistanceSquared(t,U))}static DistanceSquared(t,U){const y=t.x-U.x,I=t.y-U.y,r=t.z-U.z,Y=t.w-U.w;return y*y+I*I+r*r+Y*Y}static Center(t,U){return w.CenterToRef(t,U,new w)}static CenterToRef(t,U,y){return y.x=(t.x+U.x)/2,y.y=(t.y+U.y)/2,y.z=(t.z+U.z)/2,y.w=(t.w+U.w)/2,y}static TransformCoordinates(t,U){return w.TransformCoordinatesToRef(t,U,new w)}static TransformCoordinatesToRef(t,U,y){return w.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,U,y),y}static TransformCoordinatesFromFloatsToRef(t,U,y,I,r){const Y=I.m,mt=t*Y[0]+U*Y[4]+y*Y[8]+Y[12],X=t*Y[1]+U*Y[5]+y*Y[9]+Y[13],P=t*Y[2]+U*Y[6]+y*Y[10]+Y[14],G=t*Y[3]+U*Y[7]+y*Y[11]+Y[15];return r.x=mt,r.y=X,r.z=P,r.w=G,r}static TransformNormal(t,U){return w.TransformNormalToRef(t,U,new w)}static TransformNormalToRef(t,U,y){const I=U.m,r=t.x*I[0]+t.y*I[4]+t.z*I[8],Y=t.x*I[1]+t.y*I[5]+t.z*I[9],mt=t.x*I[2]+t.y*I[6]+t.z*I[10];return y.x=r,y.y=Y,y.z=mt,y.w=t.w,y}static TransformNormalFromFloatsToRef(t,U,y,I,r,Y){const mt=r.m;return Y.x=t*mt[0]+U*mt[4]+y*mt[8],Y.y=t*mt[1]+U*mt[5]+y*mt[9],Y.z=t*mt[2]+U*mt[6]+y*mt[10],Y.w=I,Y}static FromVector3(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new w(t._x,t._y,t._z,U)}static Dot(t,U){return t.x*U.x+t.y*U.y+t.z*U.z+t.w*U.w}}w._V8PerformanceHack=new w(.5,.5,.5,.5),w._ZeroReadOnly=w.Zero(),Object.defineProperties(w.prototype,{dimension:{value:[4]},rank:{value:1}});class D{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}get w(){return this._w}set w(t){this._w=t,this._isDirty=!0}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=t,this._y=U,this._z=y,this._w=I}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let t=Q(this._x);return t=397*t^Q(this._y),t=397*t^Q(this._z),t=397*t^Q(this._w),t}bX(){return[this._x,this._y,this._z,this._w]}toArray(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[U]=this._x,t[U+1]=this._y,t[U+2]=this._z,t[U+3]=this._w,this}Dy(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D.FromArrayToRef(t,U,this)}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z&&this._w===t._w}equalsWithEpsilon(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:I.b;return t&&(0,P.WithinEpsilon)(this._x,t._x,U)&&(0,P.WithinEpsilon)(this._y,t._y,U)&&(0,P.WithinEpsilon)(this._z,t._z,U)&&(0,P.WithinEpsilon)(this._w,t._w,U)}isApprox(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:I.b;return t&&((0,P.WithinEpsilon)(this._x,t._x,U)&&(0,P.WithinEpsilon)(this._y,t._y,U)&&(0,P.WithinEpsilon)(this._z,t._z,U)&&(0,P.WithinEpsilon)(this._w,t._w,U)||(0,P.WithinEpsilon)(this._x,-t._x,U)&&(0,P.WithinEpsilon)(this._y,-t._y,U)&&(0,P.WithinEpsilon)(this._z,-t._z,U)&&(0,P.WithinEpsilon)(this._w,-t._w,U))}clone(){return new D(this._x,this._y,this._z,this._w)}Y(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._w=t._w,this._isDirty=!0,this}aX(t,U,y,I){return this._x=t,this._y=U,this._z=y,this._w=I,this._isDirty=!0,this}set(t,U,y,I){return this.aX(t,U,y,I)}qX(t){return this.aX(t,t,t,t)}add(t){return new D(this._x+t._x,this._y+t._y,this._z+t._z,this._w+t._w)}addInPlace(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this._w+=t._w,this._isDirty=!0,this}addToRef(t,U){return U._x=this._x+t._x,U._y=this._y+t._y,U._z=this._z+t._z,U._w=this._w+t._w,U._isDirty=!0,U}addInPlaceFromFloats(t,U,y,I){return this._x+=t,this._y+=U,this._z+=y,this._w+=I,this._isDirty=!0,this}subtractToRef(t,U){return U._x=this._x-t._x,U._y=this._y-t._y,U._z=this._z-t._z,U._w=this._w-t._w,U._isDirty=!0,U}subtractFromFloats(t,U,y,I){return this.subtractFromFloatsToRef(t,U,y,I,new D)}subtractFromFloatsToRef(t,U,y,I,r){return r._x=this._x-t,r._y=this._y-U,r._z=this._z-y,r._w=this._w-I,r._isDirty=!0,r}lU(t){return new D(this._x-t._x,this._y-t._y,this._z-t._z,this._w-t._w)}GL(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._w-=t._w,this._isDirty=!0,this}scale(t){return new D(this._x*t,this._y*t,this._z*t,this._w*t)}scaleToRef(t,U){return U._x=this._x*t,U._y=this._y*t,U._z=this._z*t,U._w=this._w*t,U._isDirty=!0,U}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._w*=t,this._isDirty=!0,this}scaleAndAddToRef(t,U){return U._x+=this._x*t,U._y+=this._y*t,U._z+=this._z*t,U._w+=this._w*t,U._isDirty=!0,U}multiply(t){const U=new D(0,0,0,1);return this.multiplyToRef(t,U),U}multiplyToRef(t,U){const y=this._x*t._w+this._y*t._z-this._z*t._y+this._w*t._x,I=-this._x*t._z+this._y*t._w+this._z*t._x+this._w*t._y,r=this._x*t._y-this._y*t._x+this._z*t._w+this._w*t._z,Y=-this._x*t._x-this._y*t._y-this._z*t._z+this._w*t._w;return U.aX(y,I,r,Y),U}multiplyInPlace(t){return this.multiplyToRef(t,this)}multiplyByFloats(t,U,y,I){return this._x*=t,this._y*=U,this._z*=y,this._w*=I,this._isDirty=!0,this}divide(t){throw new ReferenceError("Can not divide a quaternion")}divideToRef(t,U){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(t){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new D)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(t){return t._x=-this._x,t._y=-this._y,t._z=-this._z,t._w=-this._w,t._isDirty=!0,t}equalsToFloats(t,U,y,I){return this._x===t&&this._y===U&&this._z===y&&this._w===I}floorToRef(t){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(t){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(t){return t.aX(-this._x,-this._y,-this._z,this._w),t}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new D(-this._x,-this._y,-this._z,this._w)}invert(){const t=this.conjugate(),U=this.lengthSquared();return 0==U||1==U||t.scaleInPlace(1/U),t}invertInPlace(){this.conjugateInPlace();const t=this.lengthSquared();return 0==t||1==t||this.scaleInPlace(1/t),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){const t=new D(0,0,0,1);return this.normalizeToRef(t),t}normalizeToRef(t){const U=this.length();return 0===U||1===U?t.aX(this._x,this._y,this._z,this._w):this.scaleToRef(1/U,t)}toEulerAngles(){const t=E.Zero();return this.toEulerAnglesToRef(t),t}toEulerAnglesToRef(t){const U=this._z,y=this._x,I=this._y,r=this._w,Y=I*U-y*r,mt=.4999999;if(Y<-mt)t._y=2*Math.atan2(I,r),t._x=Math.PI/2,t._z=0,t._isDirty=!0;else if(Y>mt)t._y=2*Math.atan2(I,r),t._x=-Math.PI/2,t._z=0,t._isDirty=!0;else{const mt=r*r,X=U*U,P=y*y,G=I*I;t._z=Math.atan2(2*(y*I+U*r),-X-P+G+mt),t._x=Math.asin(-2*Y),t._y=Math.atan2(2*(U*y+I*r),X-P-G+mt),t._isDirty=!0}return t}toAlphaBetaGammaToRef(t){const U=this._z,y=this._x,I=this._y,r=this._w,Y=Math.sqrt(y*y+I*I),mt=Math.sqrt(U*U+r*r),X=2*Math.atan2(Y,mt),P=2*Math.atan2(U,r),G=2*Math.atan2(I,y),M=(P+G)/2,L=(P-G)/2;return t.set(L,X,M),t}toRotationMatrix(t){return l.FromQuaternionToRef(this,t),t}fromRotationMatrix(t){return D.FromRotationMatrixToRef(t,this),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}toAxisAngle(){const t=E.Zero();return{axis:t,angle:this.toAxisAngleToRef(t)}}toAxisAngleToRef(t){let U=0;const y=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),I=this._w;return y>0?(U=2*Math.atan2(y,I),t.set(this._x/y,this._y/y,this._z/y)):(U=0,t.set(1,0,0)),U}static FromRotationMatrix(t){const U=new D;return D.FromRotationMatrixToRef(t,U),U}static FromRotationMatrixToRef(t,U){const y=t.m,I=y[0],r=y[4],Y=y[8],mt=y[1],X=y[5],P=y[9],G=y[2],M=y[6],L=y[10],h=I+X+L;let Q;return h>0?(Q=.5/Math.sqrt(h+1),U._w=.25/Q,U._x=(M-P)*Q,U._y=(Y-G)*Q,U._z=(mt-r)*Q,U._isDirty=!0):I>X&&I>L?(Q=2*Math.sqrt(1+I-X-L),U._w=(M-P)/Q,U._x=.25*Q,U._y=(r+mt)/Q,U._z=(Y+G)/Q,U._isDirty=!0):X>L?(Q=2*Math.sqrt(1+X-I-L),U._w=(Y-G)/Q,U._x=(r+mt)/Q,U._y=.25*Q,U._z=(P+M)/Q,U._isDirty=!0):(Q=2*Math.sqrt(1+L-I-X),U._w=(mt-r)/Q,U._x=(Y+G)/Q,U._y=(P+M)/Q,U._z=.25*Q,U._isDirty=!0),U}static Dot(t,U){return t._x*U._x+t._y*U._y+t._z*U._z+t._w*U._w}static AreClose(t,U){let y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const I=D.Dot(t,U);return 1-I*I<=y}static SmoothToRef(t,U,y,I,r){let Y=0===I?1:y/I;return Y=(0,P.Clamp)(Y,0,1),D.SlerpToRef(t,U,Y,r),r}static Zero(){return new D(0,0,0,0)}static Inverse(t){return new D(-t._x,-t._y,-t._z,t._w)}static InverseToRef(t,U){return U.set(-t._x,-t._y,-t._z,t._w),U}static Identity(){return new D(0,0,0,1)}static IsIdentity(t){return t&&0===t._x&&0===t._y&&0===t._z&&1===t._w}static RotationAxis(t,U){return D.RotationAxisToRef(t,U,new D)}static RotationAxisToRef(t,U,y){y._w=Math.cos(U/2);const I=Math.sin(U/2)/t.length();return y._x=t._x*I,y._y=t._y*I,y._z=t._z*I,y._isDirty=!0,y}static pU(t,U){return U||(U=0),new D(t[U],t[U+1],t[U+2],t[U+3])}static FromArrayToRef(t,U,y){return y._x=t[U],y._y=t[U+1],y._z=t[U+2],y._w=t[U+3],y._isDirty=!0,y}static FromFloatsToRef(t,U,y,I,r){return r.aX(t,U,y,I),r}static FromEulerAngles(t,U,y){const I=new D;return D.RotationYawPitchRollToRef(U,t,y,I),I}static FromEulerAnglesToRef(t,U,y,I){return D.RotationYawPitchRollToRef(U,t,y,I),I}static FromEulerVector(t){const U=new D;return D.RotationYawPitchRollToRef(t._y,t._x,t._z,U),U}static FromEulerVectorToRef(t,U){return D.RotationYawPitchRollToRef(t._y,t._x,t._z,U),U}static FromUnitVectorsToRef(t,U,y){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I.b;const Y=E.Dot(t,U)+1;return Y<r?Math.abs(t.x)>Math.abs(t.z)?y.set(-t.y,t.x,0,0):y.set(0,-t.z,t.y,0):(E.CrossToRef(t,U,B.DU[0]),y.set(B.DU[0].x,B.DU[0].y,B.DU[0].z,Y)),y.normalize()}static RotationYawPitchRoll(t,U,y){const I=new D;return D.RotationYawPitchRollToRef(t,U,y,I),I}static RotationYawPitchRollToRef(t,U,y,I){const r=.5*y,Y=.5*U,mt=.5*t,X=Math.sin(r),P=Math.cos(r),G=Math.sin(Y),M=Math.cos(Y),L=Math.sin(mt),h=Math.cos(mt);return I._x=h*G*P+L*M*X,I._y=L*M*P-h*G*X,I._z=h*M*X-L*G*P,I._w=h*M*P+L*G*X,I._isDirty=!0,I}static RotationAlphaBetaGamma(t,U,y){const I=new D;return D.RotationAlphaBetaGammaToRef(t,U,y,I),I}static RotationAlphaBetaGammaToRef(t,U,y,I){const r=.5*(y+t),Y=.5*(y-t),mt=.5*U;return I._x=Math.cos(Y)*Math.sin(mt),I._y=Math.sin(Y)*Math.sin(mt),I._z=Math.sin(r)*Math.cos(mt),I._w=Math.cos(r)*Math.cos(mt),I._isDirty=!0,I}static RotationQuaternionFromAxis(t,U,y){const I=new D(0,0,0,0);return D.RotationQuaternionFromAxisToRef(t,U,y,I),I}static RotationQuaternionFromAxisToRef(t,U,y,I){const r=g.Matrix[0];return t=t.normalizeToRef(g.DU[0]),U=U.normalizeToRef(g.DU[1]),y=y.normalizeToRef(g.DU[2]),l.FromXYZAxesToRef(t,U,y,r),D.FromRotationMatrixToRef(r,I),I}static FromLookDirectionLH(t,U){const y=new D;return D.FromLookDirectionLHToRef(t,U,y),y}static FromLookDirectionLHToRef(t,U,y){const I=g.Matrix[0];return l.LookDirectionLHToRef(t,U,I),D.FromRotationMatrixToRef(I,y),y}static FromLookDirectionRH(t,U){const y=new D;return D.FromLookDirectionRHToRef(t,U,y),y}static FromLookDirectionRHToRef(t,U,y){const I=g.Matrix[0];return l.LookDirectionRHToRef(t,U,I),D.FromRotationMatrixToRef(I,y)}static Slerp(t,U,y){const I=D.Identity();return D.SlerpToRef(t,U,y,I),I}static SlerpToRef(t,U,y,I){let r,Y,mt=t._x*U._x+t._y*U._y+t._z*U._z+t._w*U._w,X=!1;if(mt<0&&(X=!0,mt=-mt),mt>.999999)Y=1-y,r=X?-y:y;else{const t=Math.acos(mt),U=1/Math.sin(t);Y=Math.sin((1-y)*t)*U,r=X?-Math.sin(y*t)*U:Math.sin(y*t)*U}return I._x=Y*t._x+r*U._x,I._y=Y*t._y+r*U._y,I._z=Y*t._z+r*U._z,I._w=Y*t._w+r*U._w,I._isDirty=!0,I}static Hermite(t,U,y,I,r){const Y=r*r,mt=r*Y,X=2*mt-3*Y+1,P=-2*mt+3*Y,G=mt-2*Y+r,M=mt-Y,L=t._x*X+y._x*P+U._x*G+I._x*M,h=t._y*X+y._y*P+U._y*G+I._y*M,Q=t._z*X+y._z*P+U._z*G+I._z*M,F=t._w*X+y._w*P+U._w*G+I._w*M;return new D(L,h,Q,F)}static Hermite1stDerivative(t,U,y,I,r){const Y=new D;return this.Hermite1stDerivativeToRef(t,U,y,I,r,Y),Y}static Hermite1stDerivativeToRef(t,U,y,I,r,Y){const mt=r*r;return Y._x=6*(mt-r)*t._x+(3*mt-4*r+1)*U._x+6*(-mt+r)*y._x+(3*mt-2*r)*I._x,Y._y=6*(mt-r)*t._y+(3*mt-4*r+1)*U._y+6*(-mt+r)*y._y+(3*mt-2*r)*I._y,Y._z=6*(mt-r)*t._z+(3*mt-4*r+1)*U._z+6*(-mt+r)*y._z+(3*mt-2*r)*I._z,Y._w=6*(mt-r)*t._w+(3*mt-4*r+1)*U._w+6*(-mt+r)*y._w+(3*mt-2*r)*I._w,Y._isDirty=!0,Y}static Normalize(t){const U=D.Zero();return D.NormalizeToRef(t,U),U}static NormalizeToRef(t,U){return t.normalizeToRef(U),U}static Clamp(t,U,y){const I=new D;return D.ClampToRef(t,U,y,I),I}static ClampToRef(t,U,y,I){return I.aX((0,P.Clamp)(t.x,U.x,y.x),(0,P.Clamp)(t.y,U.y,y.y),(0,P.Clamp)(t.z,U.z,y.z),(0,P.Clamp)(t.w,U.w,y.w))}static Random(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new D((0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U))}static RandomToRef(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).aX((0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U),(0,P.RandomRange)(t,U))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(t,U){return Math.sqrt(D.DistanceSquared(t,U))}static DistanceSquared(t,U){const y=t.x-U.x,I=t.y-U.y,r=t.z-U.z,Y=t.w-U.w;return y*y+I*I+r*r+Y*Y}static Center(t,U){return D.CenterToRef(t,U,D.Zero())}static CenterToRef(t,U,y){return y.aX((t.x+U.x)/2,(t.y+U.y)/2,(t.z+U.z)/2,(t.w+U.w)/2)}}D._V8PerformanceHack=new D(.5,.5,.5,.5),Object.defineProperties(D.prototype,{dimension:{value:[4]},rank:{value:1}});class l{static get Use64Bits(){return mt.d.MatrixUse64Bits}get m(){return this.wX}markAsUpdated(){this.updateFlag=G._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(t){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1],y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],I=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=t,this._isIdentity3x2=t||y,this._isIdentityDirty=!this._isIdentity&&U,this._isIdentity3x2Dirty=!this._isIdentity3x2&&I}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,mt.d.MatrixTrackPrecisionChange&&mt.d.MatrixTrackedMatrices.push(this),this.wX=new mt.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const t=this.wX;this._isIdentity=1===t[0]&&0===t[1]&&0===t[2]&&0===t[3]&&0===t[4]&&1===t[5]&&0===t[6]&&0===t[7]&&0===t[8]&&0===t[9]&&1===t[10]&&0===t[11]&&0===t[12]&&0===t[13]&&0===t[14]&&1===t[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.wX[0]||1!==this.wX[5]||1!==this.wX[15]||0!==this.wX[1]||0!==this.wX[2]||0!==this.wX[3]||0!==this.wX[4]||0!==this.wX[6]||0!==this.wX[7]||0!==this.wX[8]||0!==this.wX[9]||0!==this.wX[10]||0!==this.wX[11]||0!==this.wX[12]||0!==this.wX[13]||0!==this.wX[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const t=this.wX,U=t[0],y=t[1],I=t[2],r=t[3],Y=t[4],mt=t[5],X=t[6],P=t[7],G=t[8],M=t[9],L=t[10],h=t[11],Q=t[12],F=t[13],E=t[14],w=t[15],D=L*w-E*h,l=M*w-F*h,g=M*E-F*L,B=G*w-Q*h,b=G*E-L*Q,p=G*F-Q*M;return U*+(mt*D-X*l+P*g)+y*-(Y*D-X*B+P*b)+I*+(Y*l-mt*B+P*p)+r*-(Y*g-mt*b+X*p)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t)return this.wX;const y=this.wX;for(let I=0;I<16;I++)t[U+I]=y[I];return this}bX(){return this.wX}Dy(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(t,U,this)}aX(){for(var t=arguments.length,U=new Array(t),y=0;y<t;y++)U[y]=arguments[y];return l.FromArrayToRef(U,0,this)}set(){const t=this.wX;for(let U=0;U<16;U++)t[U]=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}qX(t){const U=this.wX;for(let y=0;y<16;y++)U[y]=t;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return l.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(t){const U=new l;return this.addToRef(t,U),U}addToRef(t,U){const y=this.wX,I=U.wX,r=t.m;for(let Y=0;Y<16;Y++)I[Y]=y[Y]+r[Y];return U.markAsUpdated(),U}addToSelf(t){const U=this.wX,y=t.m;return U[0]+=y[0],U[1]+=y[1],U[2]+=y[2],U[3]+=y[3],U[4]+=y[4],U[5]+=y[5],U[6]+=y[6],U[7]+=y[7],U[8]+=y[8],U[9]+=y[9],U[10]+=y[10],U[11]+=y[11],U[12]+=y[12],U[13]+=y[13],U[14]+=y[14],U[15]+=y[15],this.markAsUpdated(),this}addInPlace(t){const U=this.wX,y=t.m;for(let I=0;I<16;I++)U[I]+=y[I];return this.markAsUpdated(),this}addInPlaceFromFloats(){const t=this.wX;for(let U=0;U<16;U++)t[U]+=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}lU(t){const U=this.wX,y=t.m;for(let I=0;I<16;I++)U[I]-=y[I];return this.markAsUpdated(),this}subtractToRef(t,U){const y=this.wX,I=t.m,r=U.wX;for(let Y=0;Y<16;Y++)r[Y]=y[Y]-I[Y];return U.markAsUpdated(),U}GL(t){const U=this.wX,y=t.m;for(let I=0;I<16;I++)U[I]-=y[I];return this.markAsUpdated(),this}subtractFromFloats(){for(var t=arguments.length,U=new Array(t),y=0;y<t;y++)U[y]=arguments[y];return this.subtractFromFloatsToRef(...U,new l)}subtractFromFloatsToRef(){for(var t=arguments.length,U=new Array(t),y=0;y<t;y++)U[y]=arguments[y];const I=U.pop(),r=this.wX,Y=I.wX,mt=U;for(let X=0;X<16;X++)Y[X]=r[X]-mt[X];return I.markAsUpdated(),I}invertToRef(t){return!0===this._isIdentity?(l.IdentityToRef(t),t):(h(this,t.bX())?t.markAsUpdated():t.Y(this),t)}addAtIndex(t,U){return this.wX[t]+=U,this.markAsUpdated(),this}multiplyAtIndex(t,U){return this.wX[t]*=U,this.markAsUpdated(),this}setTranslationFromFloats(t,U,y){return this.wX[12]=t,this.wX[13]=U,this.wX[14]=y,this.markAsUpdated(),this}addTranslationFromFloats(t,U,y){return this.wX[12]+=t,this.wX[13]+=U,this.wX[14]+=y,this.markAsUpdated(),this}setTranslation(t){return this.setTranslationFromFloats(t._x,t._y,t._z)}getTranslation(){return new E(this.wX[12],this.wX[13],this.wX[14])}getTranslationToRef(t){return t.x=this.wX[12],t.y=this.wX[13],t.z=this.wX[14],t}removeRotationAndScaling(){const t=this.m;return l.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t[12],t[13],t[14],t[15],this),this._updateIdentityStatus(0===t[12]&&0===t[13]&&0===t[14]&&1===t[15]),this}Y(t){t.copyToArray(this.wX);const U=t;return this.updateFlag=U.updateFlag,this._updateIdentityStatus(U._isIdentity,U._isIdentityDirty,U._isIdentity3x2,U._isIdentity3x2Dirty),this}copyToArray(t){return L(this,t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(t){const U=new l;return this.multiplyToRef(t,U),U}multiplyInPlace(t){const U=this.wX,y=t.m;for(let I=0;I<16;I++)U[I]*=y[I];return this.markAsUpdated(),this}multiplyByFloats(){const t=this.wX;for(let U=0;U<16;U++)t[U]*=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var t=arguments.length,U=new Array(t),y=0;y<t;y++)U[y]=arguments[y];const I=U.pop(),r=this.wX,Y=I.wX,mt=U;for(let X=0;X<16;X++)Y[X]=r[X]*mt[X];return I.markAsUpdated(),I}multiplyToRef(t,U){return this._isIdentity?(U.Y(t),U):t._isIdentity?(U.Y(this),U):(this.multiplyToArray(t,U.wX,0),U.markAsUpdated(),U)}multiplyToArray(t,U,y){return M(this,t,U,y),this}divide(t){return this.divideToRef(t,new l)}divideToRef(t,U){const y=this.wX,I=t.m,r=U.wX;for(let Y=0;Y<16;Y++)r[Y]=y[Y]/I[Y];return U.markAsUpdated(),U}divideInPlace(t){const U=this.wX,y=t.m;for(let I=0;I<16;I++)U[I]/=y[I];return this.markAsUpdated(),this}minimizeInPlace(t){const U=this.wX,y=t.m;for(let I=0;I<16;I++)U[I]=Math.min(U[I],y[I]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const t=this.wX;for(let U=0;U<16;U++)t[U]=Math.min(t[U],U<0||arguments.length<=U?void 0:arguments[U]);return this.markAsUpdated(),this}maximizeInPlace(t){const U=this.wX,y=t.m;for(let I=0;I<16;I++)U[I]=Math.min(U[I],y[I]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const t=this.wX;for(let U=0;U<16;U++)t[U]=Math.min(t[U],U<0||arguments.length<=U?void 0:arguments[U]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new l)}negateInPlace(){const t=this.wX;for(let U=0;U<16;U++)t[U]=-t[U];return this.markAsUpdated(),this}negateToRef(t){const U=this.wX,y=t.wX;for(let I=0;I<16;I++)y[I]=-U[I];return t.markAsUpdated(),t}equals(t){const U=t;if(!U)return!1;if((this._isIdentity||U._isIdentity)&&!this._isIdentityDirty&&!U._isIdentityDirty)return this._isIdentity&&U._isIdentity;const y=this.m,I=U.m;return y[0]===I[0]&&y[1]===I[1]&&y[2]===I[2]&&y[3]===I[3]&&y[4]===I[4]&&y[5]===I[5]&&y[6]===I[6]&&y[7]===I[7]&&y[8]===I[8]&&y[9]===I[9]&&y[10]===I[10]&&y[11]===I[11]&&y[12]===I[12]&&y[13]===I[13]&&y[14]===I[14]&&y[15]===I[15]}equalsWithEpsilon(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const y=this.wX,I=t.m;for(let r=0;r<16;r++)if(!(0,P.WithinEpsilon)(y[r],I[r],U))return!1;return!0}equalsToFloats(){const t=this.wX;for(let U=0;U<16;U++)if(t[U]!=(U<0||arguments.length<=U?void 0:arguments[U]))return!1;return!0}floor(){return this.floorToRef(new l)}floorToRef(t){const U=this.wX,y=t.wX;for(let I=0;I<16;I++)y[I]=Math.floor(U[I]);return t.markAsUpdated(),t}fract(){return this.fractToRef(new l)}fractToRef(t){const U=this.wX,y=t.wX;for(let I=0;I<16;I++)y[I]=U[I]-Math.floor(U[I]);return t.markAsUpdated(),t}clone(){const t=new l;return t.Y(this),t}getClassName(){return"Matrix"}getHashCode(){let t=Q(this.wX[0]);for(let U=1;U<16;U++)t=397*t^Q(this.wX[U]);return t}decomposeToTransformNode(t){return t.rotationQuaternion=t.rotationQuaternion||new D,this.decompose(t.dX,t.rotationQuaternion,t.position)}decompose(t,U,y,I){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return y&&y.qX(0),t&&t.qX(1),U&&U.aX(0,0,0,1),!0;const Y=this.wX;if(y&&y.aX(Y[12],Y[13],Y[14]),(t=t||g.DU[0]).x=Math.sqrt(Y[0]*Y[0]+Y[1]*Y[1]+Y[2]*Y[2]),t.y=Math.sqrt(Y[4]*Y[4]+Y[5]*Y[5]+Y[6]*Y[6]),t.z=Math.sqrt(Y[8]*Y[8]+Y[9]*Y[9]+Y[10]*Y[10]),I){const U=(r?I.absoluteScaling.x:I.dX.x)<0?-1:1,y=(r?I.absoluteScaling.y:I.dX.y)<0?-1:1,Y=(r?I.absoluteScaling.z:I.dX.z)<0?-1:1;t.x*=U,t.y*=y,t.z*=Y}else this.determinant()<=0&&(t.y*=-1);if(0===t._x||0===t._y||0===t._z)return U&&U.aX(0,0,0,1),!1;if(U){const y=1/t._x,I=1/t._y,r=1/t._z;l.FromValuesToRef(Y[0]*y,Y[1]*y,Y[2]*y,0,Y[4]*I,Y[5]*I,Y[6]*I,0,Y[8]*r,Y[9]*r,Y[10]*r,0,0,0,0,1,g.Matrix[0]),D.FromRotationMatrixToRef(g.Matrix[0],U)}return!0}getRow(t){if(t<0||t>3)return null;const U=4*t;return new w(this.wX[U+0],this.wX[U+1],this.wX[U+2],this.wX[U+3])}getRowToRef(t,U){if(t>=0&&t<=3){const y=4*t;U.x=this.wX[y+0],U.y=this.wX[y+1],U.z=this.wX[y+2],U.w=this.wX[y+3]}return U}setRow(t,U){return this.setRowFromFloats(t,U.x,U.y,U.z,U.w)}transpose(){const t=new l;return l.TransposeToRef(this,t),t}transposeToRef(t){return l.TransposeToRef(this,t),t}setRowFromFloats(t,U,y,I,r){if(t<0||t>3)return this;const Y=4*t;return this.wX[Y+0]=U,this.wX[Y+1]=y,this.wX[Y+2]=I,this.wX[Y+3]=r,this.markAsUpdated(),this}scale(t){const U=new l;return this.scaleToRef(t,U),U}scaleToRef(t,U){for(let y=0;y<16;y++)U.wX[y]=this.wX[y]*t;return U.markAsUpdated(),U}scaleAndAddToRef(t,U){for(let y=0;y<16;y++)U.wX[y]+=this.wX[y]*t;return U.markAsUpdated(),U}scaleInPlace(t){const U=this.wX;for(let y=0;y<16;y++)U[y]*=t;return this.markAsUpdated(),this}toNormalMatrix(t){const U=g.Matrix[0];this.invertToRef(U),U.transposeToRef(t);const y=t.wX;return l.FromValuesToRef(y[0],y[1],y[2],0,y[4],y[5],y[6],0,y[8],y[9],y[10],0,0,0,0,1,t),t}getRotationMatrix(){const t=new l;return this.getRotationMatrixToRef(t),t}getRotationMatrixToRef(t){const U=g.DU[0];if(!this.decompose(U))return l.IdentityToRef(t),t;const y=this.wX,I=1/U._x,r=1/U._y,Y=1/U._z;return l.FromValuesToRef(y[0]*I,y[1]*I,y[2]*I,0,y[4]*r,y[5]*r,y[6]*r,0,y[8]*Y,y[9]*Y,y[10]*Y,0,0,0,0,1,t),t}toggleModelMatrixHandInPlace(){const t=this.wX;return t[2]*=-1,t[6]*=-1,t[8]*=-1,t[9]*=-1,t[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const t=this.wX;return t[8]*=-1,t[9]*=-1,t[10]*=-1,t[11]*=-1,this.markAsUpdated(),this}static pU(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const y=new l;return l.FromArrayToRef(t,U,y),y}static FromArrayToRef(t,U,y){for(let I=0;I<16;I++)y.wX[I]=t[I+U];return y.markAsUpdated(),y}static FromFloat32ArrayToRefScaled(t,U,y,I){return I.wX[0]=t[0+U]*y,I.wX[1]=t[1+U]*y,I.wX[2]=t[2+U]*y,I.wX[3]=t[3+U]*y,I.wX[4]=t[4+U]*y,I.wX[5]=t[5+U]*y,I.wX[6]=t[6+U]*y,I.wX[7]=t[7+U]*y,I.wX[8]=t[8+U]*y,I.wX[9]=t[9+U]*y,I.wX[10]=t[10+U]*y,I.wX[11]=t[11+U]*y,I.wX[12]=t[12+U]*y,I.wX[13]=t[13+U]*y,I.wX[14]=t[14+U]*y,I.wX[15]=t[15+U]*y,I.markAsUpdated(),I}static get IdentityReadOnly(){return l._IdentityReadOnly}static FromValuesToRef(t,U,y,I,r,Y,mt,X,P,G,M,L,h,Q,F,E,w){const D=w.wX;D[0]=t,D[1]=U,D[2]=y,D[3]=I,D[4]=r,D[5]=Y,D[6]=mt,D[7]=X,D[8]=P,D[9]=G,D[10]=M,D[11]=L,D[12]=h,D[13]=Q,D[14]=F,D[15]=E,w.markAsUpdated()}static FromValues(t,U,y,I,r,Y,mt,X,P,G,M,L,h,Q,F,E){const w=new l,D=w.wX;return D[0]=t,D[1]=U,D[2]=y,D[3]=I,D[4]=r,D[5]=Y,D[6]=mt,D[7]=X,D[8]=P,D[9]=G,D[10]=M,D[11]=L,D[12]=h,D[13]=Q,D[14]=F,D[15]=E,w.markAsUpdated(),w}static Compose(t,U,y){const I=new l;return l.ComposeToRef(t,U,y,I),I}static ComposeToRef(t,U,y,I){const r=I.wX,Y=U._x,mt=U._y,X=U._z,P=U._w,G=Y+Y,M=mt+mt,L=X+X,h=Y*G,Q=Y*M,F=Y*L,E=mt*M,w=mt*L,D=X*L,l=P*G,g=P*M,B=P*L,b=t._x,p=t._y,c=t._z;return r[0]=(1-(E+D))*b,r[1]=(Q+B)*b,r[2]=(F-g)*b,r[3]=0,r[4]=(Q-B)*p,r[5]=(1-(h+D))*p,r[6]=(w+l)*p,r[7]=0,r[8]=(F+g)*c,r[9]=(w-l)*c,r[10]=(1-(h+E))*c,r[11]=0,r[12]=y._x,r[13]=y._y,r[14]=y._z,r[15]=1,I.markAsUpdated(),I}static Identity(){const t=l.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return t._updateIdentityStatus(!0),t}static IdentityToRef(t){return l.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,t),t._updateIdentityStatus(!0),t}static Zero(){const t=l.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return t._updateIdentityStatus(!1),t}static RotationX(t){const U=new l;return l.RotationXToRef(t,U),U}static Invert(t){const U=new l;return t.invertToRef(U),U}static RotationXToRef(t,U){const y=Math.sin(t),I=Math.cos(t);return l.FromValuesToRef(1,0,0,0,0,I,y,0,0,-y,I,0,0,0,0,1,U),U._updateIdentityStatus(1===I&&0===y),U}static RotationY(t){const U=new l;return l.RotationYToRef(t,U),U}static RotationYToRef(t,U){const y=Math.sin(t),I=Math.cos(t);return l.FromValuesToRef(I,0,-y,0,0,1,0,0,y,0,I,0,0,0,0,1,U),U._updateIdentityStatus(1===I&&0===y),U}static RotationZ(t){const U=new l;return l.RotationZToRef(t,U),U}static RotationZToRef(t,U){const y=Math.sin(t),I=Math.cos(t);return l.FromValuesToRef(I,y,0,0,-y,I,0,0,0,0,1,0,0,0,0,1,U),U._updateIdentityStatus(1===I&&0===y),U}static RotationAxis(t,U){const y=new l;return l.RotationAxisToRef(t,U,y),y}static RotationAxisToRef(t,U,y){const I=Math.sin(-U),r=Math.cos(-U),Y=1-r;t=t.normalizeToRef(g.DU[0]);const mt=y.wX;return mt[0]=t._x*t._x*Y+r,mt[1]=t._x*t._y*Y-t._z*I,mt[2]=t._x*t._z*Y+t._y*I,mt[3]=0,mt[4]=t._y*t._x*Y+t._z*I,mt[5]=t._y*t._y*Y+r,mt[6]=t._y*t._z*Y-t._x*I,mt[7]=0,mt[8]=t._z*t._x*Y-t._y*I,mt[9]=t._z*t._y*Y+t._x*I,mt[10]=t._z*t._z*Y+r,mt[11]=0,mt[12]=0,mt[13]=0,mt[14]=0,mt[15]=1,y.markAsUpdated(),y}static RotationAlignToRef(t,U,y){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const Y=E.Dot(U,t),mt=y.wX;if(Y<-1+I.b)mt[0]=-1,mt[1]=0,mt[2]=0,mt[3]=0,mt[4]=0,mt[5]=r?1:-1,mt[6]=0,mt[7]=0,mt[8]=0,mt[9]=0,mt[10]=r?-1:1,mt[11]=0;else{const y=E.Cross(U,t),I=1/(1+Y);mt[0]=y._x*y._x*I+Y,mt[1]=y._y*y._x*I-y._z,mt[2]=y._z*y._x*I+y._y,mt[3]=0,mt[4]=y._x*y._y*I+y._z,mt[5]=y._y*y._y*I+Y,mt[6]=y._z*y._y*I-y._x,mt[7]=0,mt[8]=y._x*y._z*I-y._y,mt[9]=y._y*y._z*I+y._x,mt[10]=y._z*y._z*I+Y,mt[11]=0}return mt[12]=0,mt[13]=0,mt[14]=0,mt[15]=1,y.markAsUpdated(),y}static RotationYawPitchRoll(t,U,y){const I=new l;return l.RotationYawPitchRollToRef(t,U,y,I),I}static RotationYawPitchRollToRef(t,U,y,I){return D.RotationYawPitchRollToRef(t,U,y,g.Quaternion[0]),g.Quaternion[0].toRotationMatrix(I),I}static Scaling(t,U,y){const I=new l;return l.ScalingToRef(t,U,y,I),I}static ScalingToRef(t,U,y,I){return l.FromValuesToRef(t,0,0,0,0,U,0,0,0,0,y,0,0,0,0,1,I),I._updateIdentityStatus(1===t&&1===U&&1===y),I}static Translation(t,U,y){const I=new l;return l.TranslationToRef(t,U,y,I),I}static TranslationToRef(t,U,y,I){return l.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t,U,y,1,I),I._updateIdentityStatus(0===t&&0===U&&0===y),I}static Lerp(t,U,y){const I=new l;return l.LerpToRef(t,U,y,I),I}static LerpToRef(t,U,y,I){const r=I.wX,Y=t.m,mt=U.m;for(let X=0;X<16;X++)r[X]=Y[X]*(1-y)+mt[X]*y;return I.markAsUpdated(),I}static DecomposeLerp(t,U,y){const I=new l;return l.DecomposeLerpToRef(t,U,y,I),I}static DecomposeLerpToRef(t,U,y,I){const r=g.DU[0],Y=g.Quaternion[0],mt=g.DU[1];t.decompose(r,Y,mt);const X=g.DU[2],P=g.Quaternion[1],G=g.DU[3];U.decompose(X,P,G);const M=g.DU[4];E.LerpToRef(r,X,y,M);const L=g.Quaternion[2];D.SlerpToRef(Y,P,y,L);const h=g.DU[5];return E.LerpToRef(mt,G,y,h),l.ComposeToRef(M,L,h,I),I}static LookAtLH(t,U,y){const I=new l;return l.LookAtLHToRef(t,U,y,I),I}static LookAtLHToRef(t,U,y,I){const r=g.DU[0],Y=g.DU[1],mt=g.DU[2];U.subtractToRef(t,mt),mt.normalize(),E.CrossToRef(y,mt,r);const X=r.lengthSquared();0===X?r.x=1:r.normalizeFromLength(Math.sqrt(X)),E.CrossToRef(mt,r,Y),Y.normalize();const P=-E.Dot(r,t),G=-E.Dot(Y,t),M=-E.Dot(mt,t);return l.FromValuesToRef(r._x,Y._x,mt._x,0,r._y,Y._y,mt._y,0,r._z,Y._z,mt._z,0,P,G,M,1,I),I}static LookAtRH(t,U,y){const I=new l;return l.LookAtRHToRef(t,U,y,I),I}static LookAtRHToRef(t,U,y,I){const r=g.DU[0],Y=g.DU[1],mt=g.DU[2];t.subtractToRef(U,mt),mt.normalize(),E.CrossToRef(y,mt,r);const X=r.lengthSquared();0===X?r.x=1:r.normalizeFromLength(Math.sqrt(X)),E.CrossToRef(mt,r,Y),Y.normalize();const P=-E.Dot(r,t),G=-E.Dot(Y,t),M=-E.Dot(mt,t);return l.FromValuesToRef(r._x,Y._x,mt._x,0,r._y,Y._y,mt._y,0,r._z,Y._z,mt._z,0,P,G,M,1,I),I}static LookDirectionLH(t,U){const y=new l;return l.LookDirectionLHToRef(t,U,y),y}static LookDirectionLHToRef(t,U,y){const I=g.DU[0];I.Y(t),I.scaleInPlace(-1);const r=g.DU[1];return E.CrossToRef(U,I,r),l.FromValuesToRef(r._x,r._y,r._z,0,U._x,U._y,U._z,0,I._x,I._y,I._z,0,0,0,0,1,y),y}static LookDirectionRH(t,U){const y=new l;return l.LookDirectionRHToRef(t,U,y),y}static LookDirectionRHToRef(t,U,y){const I=g.DU[2];return E.CrossToRef(U,t,I),l.FromValuesToRef(I._x,I._y,I._z,0,U._x,U._y,U._z,0,t._x,t._y,t._z,0,0,0,0,1,y),y}static OrthoLH(t,U,y,I,r){const Y=new l;return l.OrthoLHToRef(t,U,y,I,Y,r),Y}static OrthoLHToRef(t,U,y,I,r,Y){const mt=2/t,X=2/U,P=2/(I-y),G=-(I+y)/(I-y);return l.FromValuesToRef(mt,0,0,0,0,X,0,0,0,0,P,0,0,0,G,1,r),Y&&r.multiplyToRef(b,r),r._updateIdentityStatus(1===mt&&1===X&&1===P&&0===G),r}static OrthoOffCenterLH(t,U,y,I,r,Y,mt){const X=new l;return l.OrthoOffCenterLHToRef(t,U,y,I,r,Y,X,mt),X}static OrthoOffCenterLHToRef(t,U,y,I,r,Y,mt,X){const P=2/(U-t),G=2/(I-y),M=2/(Y-r),L=-(Y+r)/(Y-r),h=(t+U)/(t-U),Q=(I+y)/(y-I);return l.FromValuesToRef(P,0,0,0,0,G,0,0,0,0,M,0,h,Q,L,1,mt),X&&mt.multiplyToRef(b,mt),mt.markAsUpdated(),mt}static ObliqueOffCenterLHToRef(t,U,y,I,r,Y,mt,X,P,G,M){const L=-mt*Math.cos(X),h=-mt*Math.sin(X);return l.TranslationToRef(0,0,-P,g.Matrix[1]),l.FromValuesToRef(1,0,0,0,0,1,0,0,L,h,1,0,0,0,0,1,g.Matrix[0]),g.Matrix[1].multiplyToRef(g.Matrix[0],g.Matrix[0]),l.TranslationToRef(0,0,P,g.Matrix[1]),g.Matrix[0].multiplyToRef(g.Matrix[1],g.Matrix[0]),l.OrthoOffCenterLHToRef(t,U,y,I,r,Y,G,M),g.Matrix[0].multiplyToRef(G,G),G}static OrthoOffCenterRH(t,U,y,I,r,Y,mt){const X=new l;return l.OrthoOffCenterRHToRef(t,U,y,I,r,Y,X,mt),X}static OrthoOffCenterRHToRef(t,U,y,I,r,Y,mt,X){return l.OrthoOffCenterLHToRef(t,U,y,I,r,Y,mt,X),mt.wX[10]*=-1,mt}static ObliqueOffCenterRHToRef(t,U,y,I,r,Y,mt,X,P,G,M){const L=mt*Math.cos(X),h=mt*Math.sin(X);return l.TranslationToRef(0,0,P,g.Matrix[1]),l.FromValuesToRef(1,0,0,0,0,1,0,0,L,h,1,0,0,0,0,1,g.Matrix[0]),g.Matrix[1].multiplyToRef(g.Matrix[0],g.Matrix[0]),l.TranslationToRef(0,0,-P,g.Matrix[1]),g.Matrix[0].multiplyToRef(g.Matrix[1],g.Matrix[0]),l.OrthoOffCenterRHToRef(t,U,y,I,r,Y,G,M),g.Matrix[0].multiplyToRef(G,G),G}static PerspectiveLH(t,U,y,I,r){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const mt=new l,X=2*y/t,P=2*y/U,G=(I+y)/(I-y),M=-2*I*y/(I-y),L=Math.tan(Y);return l.FromValuesToRef(X,0,0,0,0,P,0,L,0,0,G,1,0,0,M,0,mt),r&&mt.multiplyToRef(b,mt),mt._updateIdentityStatus(!1),mt}static PerspectiveFovLH(t,U,y,I,r){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,mt=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const X=new l;return l.PerspectiveFovLHToRef(t,U,y,I,X,!0,r,Y,mt),X}static PerspectiveFovLHToRef(t,U,y,I,r){let Y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],mt=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,P=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const G=y,M=I,L=1/Math.tan(.5*t),h=Y?L/U:L,Q=Y?L:L*U,F=P&&0===G?-1:0!==M?(M+G)/(M-G):1,E=P&&0===G?2*M:0!==M?-2*M*G/(M-G):-2*G,w=Math.tan(X);return l.FromValuesToRef(h,0,0,0,0,Q,0,w,0,0,F,1,0,0,E,0,r),mt&&r.multiplyToRef(b,r),r._updateIdentityStatus(!1),r}static PerspectiveFovReverseLHToRef(t,U,y,I,r){let Y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],mt=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const P=1/Math.tan(.5*t),G=Y?P/U:P,M=Y?P:P*U,L=Math.tan(X);return l.FromValuesToRef(G,0,0,0,0,M,0,L,0,0,-y,1,0,0,1,0,r),mt&&r.multiplyToRef(b,r),r._updateIdentityStatus(!1),r}static PerspectiveFovRH(t,U,y,I,r){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,mt=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const X=new l;return l.PerspectiveFovRHToRef(t,U,y,I,X,!0,r,Y,mt),X}static PerspectiveFovRHToRef(t,U,y,I,r){let Y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],mt=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,P=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const G=y,M=I,L=1/Math.tan(.5*t),h=Y?L/U:L,Q=Y?L:L*U,F=P&&0===G?1:0!==M?-(M+G)/(M-G):-1,E=P&&0===G?2*M:0!==M?-2*M*G/(M-G):-2*G,w=Math.tan(X);return l.FromValuesToRef(h,0,0,0,0,Q,0,w,0,0,F,-1,0,0,E,0,r),mt&&r.multiplyToRef(b,r),r._updateIdentityStatus(!1),r}static PerspectiveFovReverseRHToRef(t,U,y,I,r){let Y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],mt=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const P=1/Math.tan(.5*t),G=Y?P/U:P,M=Y?P:P*U,L=Math.tan(X);return l.FromValuesToRef(G,0,0,0,0,M,0,L,0,0,-y,-1,0,0,-1,0,r),mt&&r.multiplyToRef(b,r),r._updateIdentityStatus(!1),r}static GetFinalMatrix(t,U,y,I,r,Y){const mt=t.width,X=t.height,P=t.x,G=t.y,M=l.FromValues(mt/2,0,0,0,0,-X/2,0,0,0,0,Y-r,0,P+mt/2,X/2+G,r,1),L=new l;return U.multiplyToRef(y,L),L.multiplyToRef(I,L),L.multiplyToRef(M,L)}static GetAsMatrix2x2(t){const U=t.m,y=[U[0],U[1],U[4],U[5]];return mt.d.MatrixUse64Bits?y:new Float32Array(y)}static GetAsMatrix3x3(t){const U=t.m,y=[U[0],U[1],U[2],U[4],U[5],U[6],U[8],U[9],U[10]];return mt.d.MatrixUse64Bits?y:new Float32Array(y)}static Transpose(t){const U=new l;return l.TransposeToRef(t,U),U}static TransposeToRef(t,U){const y=t.m,I=y[0],r=y[4],Y=y[8],mt=y[12],X=y[1],P=y[5],G=y[9],M=y[13],L=y[2],h=y[6],Q=y[10],F=y[14],E=y[3],w=y[7],D=y[11],l=y[15],g=U.wX;return g[0]=I,g[1]=r,g[2]=Y,g[3]=mt,g[4]=X,g[5]=P,g[6]=G,g[7]=M,g[8]=L,g[9]=h,g[10]=Q,g[11]=F,g[12]=E,g[13]=w,g[14]=D,g[15]=l,U.markAsUpdated(),U._updateIdentityStatus(t._isIdentity,t._isIdentityDirty),U}static Reflection(t){const U=new l;return l.ReflectionToRef(t,U),U}static ReflectionToRef(t,U){t.normalize();const y=t.normal.x,I=t.normal.y,r=t.normal.z,Y=-2*y,mt=-2*I,X=-2*r;return l.FromValuesToRef(Y*y+1,mt*y,X*y,0,Y*I,mt*I+1,X*I,0,Y*r,mt*r,X*r+1,0,Y*t.d,mt*t.d,X*t.d,1,U),U}static FromXYZAxesToRef(t,U,y,I){return l.FromValuesToRef(t._x,t._y,t._z,0,U._x,U._y,U._z,0,y._x,y._y,y._z,0,0,0,0,1,I),I}static FromQuaternionToRef(t,U){const y=t._x*t._x,I=t._y*t._y,r=t._z*t._z,Y=t._x*t._y,mt=t._z*t._w,X=t._z*t._x,P=t._y*t._w,G=t._y*t._z,M=t._x*t._w;return U.wX[0]=1-2*(I+r),U.wX[1]=2*(Y+mt),U.wX[2]=2*(X-P),U.wX[3]=0,U.wX[4]=2*(Y-mt),U.wX[5]=1-2*(r+y),U.wX[6]=2*(G+M),U.wX[7]=0,U.wX[8]=2*(X+P),U.wX[9]=2*(G-M),U.wX[10]=1-2*(I+y),U.wX[11]=0,U.wX[12]=0,U.wX[13]=0,U.wX[14]=0,U.wX[15]=1,U.markAsUpdated(),U}}l._IdentityReadOnly=l.Identity(),Object.defineProperties(l.prototype,{dimension:{value:[4,4]},rank:{value:2}});class g{}g.DU=(0,r.h)(11,E.Zero),g.Matrix=(0,r.h)(2,l.Identity),g.Quaternion=(0,r.h)(3,D.Zero);class B{}B.Vector2=(0,r.h)(3,F.Zero),B.DU=(0,r.h)(13,E.Zero),B.Vector4=(0,r.h)(3,w.Zero),B.Quaternion=(0,r.h)(3,D.Zero),B.Matrix=(0,r.h)(8,l.Identity),(0,Y.f)("BABYLON.Vector2",F),(0,Y.f)("BABYLON.Vector3",E),(0,Y.f)("BABYLON.Vector4",w),(0,Y.f)("BABYLON.Matrix",l);const b=l.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12399:(t,U,y)=>{function I(t,U){const y=[];for(let I=0;I<t;++I)y.push(U());return y}function r(t,U){return I(t,U)}y.d(U,{d:()=>I,h:()=>r,j:()=>mt});const Y=["push","splice","pop","shift","unshift"];function mt(t,U){const y=Y.map((y=>function(t,U,y){const I=t[U];if("function"!==typeof I)return null;const r=function(){const I=t.length,Y=r.previous.apply(t,arguments);return y(U,I),Y};return I.next=r,r.previous=I,t[U]=r,()=>{const y=r.previous;if(!y)return;const I=r.next;I?(y.next=I,I.previous=y):(y.next=void 0,t[U]=y),r.next=void 0,r.previous=void 0}}(t,y,U)));return()=>{for(const t of y)null===t||void 0===t||t()}}}}]);