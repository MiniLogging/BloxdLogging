"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[14],{11189:(R,J,B)=>{B.d(J,{d:()=>N,e:()=>y,f:()=>Q,i:()=>h});const Q=1/2.2,h=2.2,y=(1+Math.sqrt(5))/2,N=.001},11201:(R,J,B)=>{function Q(R){return parseInt(R.toString().replace(/\W/g,""))}function h(R,J){let B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(R-J)<=B}function y(R,J,B){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return R<J-Q||R>B+Q}function N(R,J){return R===J?R:Math.random()*(J-R)+R}function r(R,J,B){return R+(J-R)*B}function q(R,J,B){let Q=A(J-R,360);return Q>180&&(Q-=360),R+Q*E(B)}function e(R,J,B){let Q=0;return Q=R!=J?E((B-R)/(J-R)):0,Q}function D(R,J,B,Q,h){const y=h*h,N=h*y;return R*(2*N-3*y+1)+B*(-2*N+3*y)+J*(N-2*y+h)+Q*(N-y)}function l(R,J,B,Q,h){const y=h*h;return 6*(y-h)*R+(3*y-4*h+1)*J+6*(-y+h)*B+(3*y-2*h)*Q}function E(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(B,Math.max(J,R))}function O(R){return R-=2*Math.PI*Math.floor((R+Math.PI)/(2*Math.PI))}function n(R){const J=R.toString(16);return R<=15?("0"+J).toUpperCase():J.toUpperCase()}function P(R){if(Math.log2)return Math.floor(Math.log2(R));if(R<0)return NaN;if(0===R)return-1/0;let J=0;if(R<1){for(;R<1;)J++,R*=2;J=-J}else if(R>1)for(;R>1;)J++,R=Math.floor(R/2);return J}function A(R,J){return R-Math.floor(R/J)*J}function u(R,J,B){return(R-J)/(B-J)}function S(R,J,B){return R*(B-J)+J}function f(R,J){let B=A(J-R,360);return B>180&&(B-=360),B}function a(R,J){const B=A(R,2*J);return J-Math.abs(B-J)}function s(R,J,B){let Q=E(B);return Q=-2*Q*Q*Q+3*Q*Q,J*Q+R*(1-Q)}function x(R,J,B){let Q=0;return Q=Math.abs(J-R)<=B?J:R+Math.sign(J-R)*B,Q}function I(R,J,B){const Q=f(R,J);let h=0;return h=-B<Q&&Q<B?J:x(R,J=R+Q,B),h}function V(R,J,B){return(R-J)/(B-J)}function M(R,J,B){return(B-J)*R+J}function H(R,J){const B=R%J;return 0===B?J:H(J,B)}B.r(J),B.d(J,{Clamp:()=>E,DeltaAngle:()=>f,Denormalize:()=>S,ExtractAsInt:()=>Q,Hermite:()=>D,Hermite1stDerivative:()=>l,HighestCommonFactor:()=>H,ILog2:()=>P,InverseLerp:()=>e,Lerp:()=>r,LerpAngle:()=>q,MoveTowards:()=>x,MoveTowardsAngle:()=>I,Normalize:()=>u,NormalizeRadians:()=>O,OutsideRange:()=>y,PercentToRange:()=>M,PingPong:()=>a,RandomRange:()=>N,RangeToPercent:()=>V,Repeat:()=>A,SmoothStep:()=>s,ToHex:()=>n,WithinEpsilon:()=>h})},11186:(R,J,B)=>{B.r(J),B.d(J,{Matrix:()=>S,Quaternion:()=>u,TmpVectors:()=>a,Vector2:()=>n,nJ:()=>P,Vector4:()=>A});var Q=B(11189),h=B(11193),y=B(11142),N=B(11117),r=B(11065),q=B(11201);class e{}function D(R,J,B){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const h=R.Ch(),y=J.Ch(),N=h[0],r=h[1],q=h[2],e=h[3],D=h[4],l=h[5],E=h[6],O=h[7],n=h[8],P=h[9],A=h[10],u=h[11],S=h[12],f=h[13],a=h[14],s=h[15],x=y[0],I=y[1],V=y[2],M=y[3],H=y[4],d=y[5],X=y[6],c=y[7],z=y[8],p=y[9],i=y[10],W=y[11],k=y[12],Y=y[13],G=y[14],g=y[15];B[Q]=N*x+r*H+q*z+e*k,B[Q+1]=N*I+r*d+q*p+e*Y,B[Q+2]=N*V+r*X+q*i+e*G,B[Q+3]=N*M+r*c+q*W+e*g,B[Q+4]=D*x+l*H+E*z+O*k,B[Q+5]=D*I+l*d+E*p+O*Y,B[Q+6]=D*V+l*X+E*i+O*G,B[Q+7]=D*M+l*c+E*W+O*g,B[Q+8]=n*x+P*H+A*z+u*k,B[Q+9]=n*I+P*d+A*p+u*Y,B[Q+10]=n*V+P*X+A*i+u*G,B[Q+11]=n*M+P*c+A*W+u*g,B[Q+12]=S*x+f*H+a*z+s*k,B[Q+13]=S*I+f*d+a*p+s*Y,B[Q+14]=S*V+f*X+a*i+s*G,B[Q+15]=S*M+f*c+a*W+s*g}function l(R,J){let B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const Q=R.Ch();J[B]=Q[0],J[B+1]=Q[1],J[B+2]=Q[2],J[B+3]=Q[3],J[B+4]=Q[4],J[B+5]=Q[5],J[B+6]=Q[6],J[B+7]=Q[7],J[B+8]=Q[8],J[B+9]=Q[9],J[B+10]=Q[10],J[B+11]=Q[11],J[B+12]=Q[12],J[B+13]=Q[13],J[B+14]=Q[14],J[B+15]=Q[15]}function E(R,J){const B=R.Ch(),Q=B[0],h=B[1],y=B[2],N=B[3],r=B[4],q=B[5],e=B[6],D=B[7],l=B[8],E=B[9],O=B[10],n=B[11],P=B[12],A=B[13],u=B[14],S=B[15],f=O*S-u*n,a=E*S-A*n,s=E*u-A*O,x=l*S-P*n,I=l*u-O*P,V=l*A-P*E,M=+(q*f-e*a+D*s),H=-(r*f-e*x+D*I),d=+(r*a-q*x+D*V),X=-(r*s-q*I+e*V),c=Q*M+h*H+y*d+N*X;if(0===c)return!1;const z=1/c,p=e*S-u*D,i=q*S-A*D,W=q*u-A*e,k=r*S-P*D,Y=r*u-P*e,G=r*A-P*q,g=e*n-O*D,L=q*n-E*D,j=q*O-E*e,T=r*n-l*D,F=r*O-l*e,C=r*E-l*q,b=-(h*f-y*a+N*s),w=+(Q*f-y*x+N*I),K=-(Q*a-h*x+N*V),v=+(Q*s-h*I+y*V),m=+(h*p-y*i+N*W),o=-(Q*p-y*k+N*Y),t=+(Q*i-h*k+N*G),Z=-(Q*W-h*Y+y*G),U=-(h*g-y*L+N*j),RR=+(Q*g-y*T+N*F),JR=-(Q*L-h*T+N*C),BR=+(Q*j-h*F+y*C);return J[0]=M*z,J[1]=b*z,J[2]=m*z,J[3]=U*z,J[4]=H*z,J[5]=w*z,J[6]=o*z,J[7]=RR*z,J[8]=d*z,J[9]=K*z,J[10]=t*z,J[11]=JR*z,J[12]=X*z,J[13]=v*z,J[14]=Z*z,J[15]=BR*z,!0}e._UpdateFlagSeed=0;const O=R=>parseInt(R.toString().replace(/\W/g,""));class n{constructor(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=R,this.y=J}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let R=O(this.x);return R=397*R^O(this.y),R}toArray(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R[J]=this.x,R[J+1]=this.y,this}EB(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n.FromArrayToRef(R,J,this),this}Ch(){return[this.x,this.y]}h(R){return this.x=R.x,this.y=R.y,this}Ar(R,J){return this.x=R,this.y=J,this}set(R,J){return this.Ar(R,J)}Sr(R){return this.Ar(R,R)}add(R){return new n(this.x+R.x,this.y+R.y)}addToRef(R,J){return J.x=this.x+R.x,J.y=this.y+R.y,J}addInPlace(R){return this.x+=R.x,this.y+=R.y,this}addInPlaceFromFloats(R,J){return this.x+=R,this.y+=J,this}addVector3(R){return new n(this.x+R.x,this.y+R.y)}PJ(R){return new n(this.x-R.x,this.y-R.y)}subtractToRef(R,J){return J.x=this.x-R.x,J.y=this.y-R.y,J}ul(R){return this.x-=R.x,this.y-=R.y,this}multiplyInPlace(R){return this.x*=R.x,this.y*=R.y,this}multiply(R){return new n(this.x*R.x,this.y*R.y)}multiplyToRef(R,J){return J.x=this.x*R.x,J.y=this.y*R.y,J}multiplyByFloats(R,J){return new n(this.x*R,this.y*J)}divide(R){return new n(this.x/R.x,this.y/R.y)}divideToRef(R,J){return J.x=this.x/R.x,J.y=this.y/R.y,J}divideInPlace(R){return this.x=this.x/R.x,this.y=this.y/R.y,this}minimizeInPlace(R){return this.minimizeInPlaceFromFloats(R.x,R.y)}maximizeInPlace(R){return this.maximizeInPlaceFromFloats(R.x,R.y)}minimizeInPlaceFromFloats(R,J){return this.x=Math.min(R,this.x),this.y=Math.min(J,this.y),this}maximizeInPlaceFromFloats(R,J){return this.x=Math.max(R,this.x),this.y=Math.max(J,this.y),this}subtractFromFloats(R,J){return new n(this.x-R,this.y-J)}subtractFromFloatsToRef(R,J,B){return B.x=this.x-R,B.y=this.y-J,B}negate(){return new n(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(R){return R.x=-this.x,R.y=-this.y,R}scaleInPlace(R){return this.x*=R,this.y*=R,this}scale(R){return new n(this.x*R,this.y*R)}scaleToRef(R,J){return J.x=this.x*R,J.y=this.y*R,J}scaleAndAddToRef(R,J){return J.x+=this.x*R,J.y+=this.y*R,J}equals(R){return R&&this.x===R.x&&this.y===R.y}equalsWithEpsilon(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.d;return R&&(0,q.WithinEpsilon)(this.x,R.x,J)&&(0,q.WithinEpsilon)(this.y,R.y,J)}equalsToFloats(R,J){return this.x===R&&this.y===J}floor(){return new n(Math.floor(this.x),Math.floor(this.y))}floorToRef(R){return R.x=Math.floor(this.x),R.y=Math.floor(this.y),R}fract(){return new n(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(R){return R.x=this.x-Math.floor(this.x),R.y=this.y-Math.floor(this.y),R}rotate(R){return this.rotateToRef(R,new n)}rotateToRef(R,J){const B=Math.cos(R),Q=Math.sin(R);return J.x=B*this.x-Q*this.y,J.y=Q*this.x+B*this.y,J}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(R){return 0===R||1===R?this:this.scaleInPlace(1/R)}normalizeToNew(){const R=new n;return this.normalizeToRef(R),R}normalizeToRef(R){const J=this.length();return 0===J&&(R.x=this.x,R.y=this.y),this.scaleToRef(1/J,R)}clone(){return new n(this.x,this.y)}dot(R){return this.x*R.x+this.y*R.y}static Zero(){return new n(0,0)}static One(){return new n(1,1)}static Random(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new n((0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J))}static RandomToRef(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ar((0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J))}static get ZeroReadOnly(){return n._ZeroReadOnly}static fJ(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new n(R[J],R[J+1])}static FromArrayToRef(R,J,B){return B.x=R[J],B.y=R[J+1],B}static FromFloatsToRef(R,J,B){return B.Ar(R,J),B}static CatmullRom(R,J,B,Q,h){const y=h*h,N=h*y,r=.5*(2*J.x+(-R.x+B.x)*h+(2*R.x-5*J.x+4*B.x-Q.x)*y+(-R.x+3*J.x-3*B.x+Q.x)*N),q=.5*(2*J.y+(-R.y+B.y)*h+(2*R.y-5*J.y+4*B.y-Q.y)*y+(-R.y+3*J.y-3*B.y+Q.y)*N);return new n(r,q)}static ClampToRef(R,J,B,Q){return Q.x=(0,q.Clamp)(R.x,J.x,B.x),Q.y=(0,q.Clamp)(R.y,J.y,B.y),Q}static Clamp(R,J,B){const Q=(0,q.Clamp)(R.x,J.x,B.x),h=(0,q.Clamp)(R.y,J.y,B.y);return new n(Q,h)}static Hermite(R,J,B,Q,h){const y=h*h,N=h*y,r=2*N-3*y+1,q=-2*N+3*y,e=N-2*y+h,D=N-y,l=R.x*r+B.x*q+J.x*e+Q.x*D,E=R.y*r+B.y*q+J.y*e+Q.y*D;return new n(l,E)}static Hermite1stDerivative(R,J,B,Q,h){return this.Hermite1stDerivativeToRef(R,J,B,Q,h,new n)}static Hermite1stDerivativeToRef(R,J,B,Q,h,y){const N=h*h;return y.x=6*(N-h)*R.x+(3*N-4*h+1)*J.x+6*(-N+h)*B.x+(3*N-2*h)*Q.x,y.y=6*(N-h)*R.y+(3*N-4*h+1)*J.y+6*(-N+h)*B.y+(3*N-2*h)*Q.y,y}static Lerp(R,J,B){return n.LerpToRef(R,J,B,new n)}static LerpToRef(R,J,B,Q){return Q.x=R.x+(J.x-R.x)*B,Q.y=R.y+(J.y-R.y)*B,Q}static Dot(R,J){return R.x*J.x+R.y*J.y}static Normalize(R){return n.NormalizeToRef(R,new n)}static NormalizeToRef(R,J){return R.normalizeToRef(J),J}static Minimize(R,J){const B=R.x<J.x?R.x:J.x,Q=R.y<J.y?R.y:J.y;return new n(B,Q)}static Maximize(R,J){const B=R.x>J.x?R.x:J.x,Q=R.y>J.y?R.y:J.y;return new n(B,Q)}static Transform(R,J){return n.TransformToRef(R,J,new n)}static TransformToRef(R,J,B){const Q=J.m,h=R.x*Q[0]+R.y*Q[4]+Q[12],y=R.x*Q[1]+R.y*Q[5]+Q[13];return B.x=h,B.y=y,B}static PointInTriangle(R,J,B,Q){const h=.5*(-B.y*Q.x+J.y*(-B.x+Q.x)+J.x*(B.y-Q.y)+B.x*Q.y),y=h<0?-1:1,N=(J.y*Q.x-J.x*Q.y+(Q.y-J.y)*R.x+(J.x-Q.x)*R.y)*y,r=(J.x*B.y-J.y*B.x+(J.y-B.y)*R.x+(B.x-J.x)*R.y)*y;return N>0&&r>0&&N+r<2*h*y}static Distance(R,J){return Math.sqrt(n.DistanceSquared(R,J))}static DistanceSquared(R,J){const B=R.x-J.x,Q=R.y-J.y;return B*B+Q*Q}static Center(R,J){return n.CenterToRef(R,J,new n)}static CenterToRef(R,J,B){return B.Ar((R.x+J.x)/2,(R.y+J.y)/2)}static DistanceOfPointFromSegment(R,J,B){const Q=n.DistanceSquared(J,B);if(0===Q)return n.Distance(R,J);const h=B.PJ(J),y=Math.max(0,Math.min(1,n.Dot(R.PJ(J),h)/Q)),N=J.add(h.multiplyByFloats(y,y));return n.Distance(R,N)}}n._V8PerformanceHack=new n(.5,.5),n._ZeroReadOnly=n.Zero(),Object.defineProperties(n.prototype,{dimension:{value:[2]},rank:{value:1}});class P{get x(){return this._x}set x(R){this._x=R,this._isDirty=!0}get y(){return this._y}set y(R){this._y=R,this._isDirty=!0}get z(){return this._z}set z(R){this._z=R,this._isDirty=!0}constructor(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=R,this._y=J,this._z=B}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"nJ"}getHashCode(){let R=O(this._x);return R=397*R^O(this._y),R=397*R^O(this._z),R}Ch(){return[this._x,this._y,this._z]}toArray(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R[J]=this._x,R[J+1]=this._y,R[J+2]=this._z,this}EB(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P.FromArrayToRef(R,J,this),this}toQuaternion(){return u.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(R){return this._x+=R._x,this._y+=R._y,this._z+=R._z,this._isDirty=!0,this}addInPlaceFromFloats(R,J,B){return this._x+=R,this._y+=J,this._z+=B,this._isDirty=!0,this}add(R){return new P(this._x+R._x,this._y+R._y,this._z+R._z)}addToRef(R,J){return J._x=this._x+R._x,J._y=this._y+R._y,J._z=this._z+R._z,J._isDirty=!0,J}ul(R){return this._x-=R._x,this._y-=R._y,this._z-=R._z,this._isDirty=!0,this}PJ(R){return new P(this._x-R._x,this._y-R._y,this._z-R._z)}subtractToRef(R,J){return this.subtractFromFloatsToRef(R._x,R._y,R._z,J)}subtractFromFloats(R,J,B){return new P(this._x-R,this._y-J,this._z-B)}subtractFromFloatsToRef(R,J,B,Q){return Q._x=this._x-R,Q._y=this._y-J,Q._z=this._z-B,Q._isDirty=!0,Q}negate(){return new P(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(R){return R._x=-1*this._x,R._y=-1*this._y,R._z=-1*this._z,R._isDirty=!0,R}scaleInPlace(R){return this._x*=R,this._y*=R,this._z*=R,this._isDirty=!0,this}scale(R){return new P(this._x*R,this._y*R,this._z*R)}scaleToRef(R,J){return J._x=this._x*R,J._y=this._y*R,J._z=this._z*R,J._isDirty=!0,J}getNormalToRef(R){const J=this.length();let B=Math.acos(this._y/J);const Q=Math.atan2(this._z,this._x);B>Math.PI/2?B-=Math.PI/2:B+=Math.PI/2;const h=J*Math.sin(B)*Math.cos(Q),y=J*Math.cos(B),N=J*Math.sin(B)*Math.sin(Q);return R.set(h,y,N),R}applyRotationQuaternionToRef(R,J){const B=this._x,Q=this._y,h=this._z,y=R._x,N=R._y,r=R._z,q=R._w,e=2*(N*h-r*Q),D=2*(r*B-y*h),l=2*(y*Q-N*B);return J._x=B+q*e+N*l-r*D,J._y=Q+q*D+r*e-y*l,J._z=h+q*l+y*D-N*e,J._isDirty=!0,J}applyRotationQuaternionInPlace(R){return this.applyRotationQuaternionToRef(R,this)}applyRotationQuaternion(R){return this.applyRotationQuaternionToRef(R,new P)}scaleAndAddToRef(R,J){return J._x+=this._x*R,J._y+=this._y*R,J._z+=this._z*R,J._isDirty=!0,J}projectOnPlane(R,J){return this.projectOnPlaneToRef(R,J,new P)}projectOnPlaneToRef(R,J,B){const Q=R.normal,h=R.d,y=f.nJ[0];this.subtractToRef(J,y),y.normalize();const N=P.Dot(y,Q);if(Math.abs(N)<1e-10)B.Sr(1/0);else{const R=-(P.Dot(J,Q)+h)/N,r=y.scaleInPlace(R);J.addToRef(r,B)}return B}equals(R){return R&&this._x===R._x&&this._y===R._y&&this._z===R._z}equalsWithEpsilon(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.d;return R&&(0,q.WithinEpsilon)(this._x,R._x,J)&&(0,q.WithinEpsilon)(this._y,R._y,J)&&(0,q.WithinEpsilon)(this._z,R._z,J)}equalsToFloats(R,J,B){return this._x===R&&this._y===J&&this._z===B}multiplyInPlace(R){return this._x*=R._x,this._y*=R._y,this._z*=R._z,this._isDirty=!0,this}multiply(R){return this.multiplyByFloats(R._x,R._y,R._z)}multiplyToRef(R,J){return J._x=this._x*R._x,J._y=this._y*R._y,J._z=this._z*R._z,J._isDirty=!0,J}multiplyByFloats(R,J,B){return new P(this._x*R,this._y*J,this._z*B)}divide(R){return new P(this._x/R._x,this._y/R._y,this._z/R._z)}divideToRef(R,J){return J._x=this._x/R._x,J._y=this._y/R._y,J._z=this._z/R._z,J._isDirty=!0,J}divideInPlace(R){return this._x=this._x/R._x,this._y=this._y/R._y,this._z=this._z/R._z,this._isDirty=!0,this}minimizeInPlace(R){return this.minimizeInPlaceFromFloats(R._x,R._y,R._z)}maximizeInPlace(R){return this.maximizeInPlaceFromFloats(R._x,R._y,R._z)}minimizeInPlaceFromFloats(R,J,B){return R<this._x&&(this.x=R),J<this._y&&(this.y=J),B<this._z&&(this.z=B),this}maximizeInPlaceFromFloats(R,J,B){return R>this._x&&(this.x=R),J>this._y&&(this.y=J),B>this._z&&(this.z=B),this}isNonUniformWithinEpsilon(R){const J=Math.abs(this._x),B=Math.abs(this._y);if(!(0,q.WithinEpsilon)(J,B,R))return!0;const Q=Math.abs(this._z);return!(0,q.WithinEpsilon)(J,Q,R)||!(0,q.WithinEpsilon)(B,Q,R)}get isNonUniform(){const R=Math.abs(this._x);if(R!==Math.abs(this._y))return!0;return R!==Math.abs(this._z)}floorToRef(R){return R._x=Math.floor(this._x),R._y=Math.floor(this._y),R._z=Math.floor(this._z),R._isDirty=!0,R}floor(){return new P(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(R){return R._x=this._x-Math.floor(this._x),R._y=this._y-Math.floor(this._y),R._z=this._z-Math.floor(this._z),R._isDirty=!0,R}fract(){return new P(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(R){if("xyz"===(R=R.toLowerCase()))return this;const J=f.nJ[0].h(this);return this.x=J[R[0]],this.y=J[R[1]],this.z=J[R[2]],this}rotateByQuaternionToRef(R,J){return R.toRotationMatrix(f.Matrix[0]),P.TransformCoordinatesToRef(this,f.Matrix[0],J),J}rotateByQuaternionAroundPointToRef(R,J,B){return this.subtractToRef(J,f.nJ[0]),f.nJ[0].rotateByQuaternionToRef(R,f.nJ[0]),J.addToRef(f.nJ[0],B),B}cross(R){return P.CrossToRef(this,R,new P)}normalizeFromLength(R){return 0===R||1===R?this:this.scaleInPlace(1/R)}normalizeToNew(){return this.normalizeToRef(new P)}normalizeToRef(R){const J=this.length();return 0===J||1===J?(R._x=this._x,R._y=this._y,R._z=this._z,R._isDirty=!0,R):this.scaleToRef(1/J,R)}clone(){return new P(this._x,this._y,this._z)}h(R){return this.Ar(R._x,R._y,R._z)}Ar(R,J,B){return this._x=R,this._y=J,this._z=B,this._isDirty=!0,this}set(R,J,B){return this.Ar(R,J,B)}Sr(R){return this._x=this._y=this._z=R,this._isDirty=!0,this}static GetClipFactor(R,J,B,Q){const h=P.Dot(R,B);return(h-Q)/(h-P.Dot(J,B))}static GetAngleBetweenVectors(R,J,B){const Q=R.normalizeToRef(f.nJ[1]),h=J.normalizeToRef(f.nJ[2]);let y=P.Dot(Q,h);y=(0,q.Clamp)(y,-1,1);const N=Math.acos(y),r=f.nJ[3];return P.CrossToRef(Q,h,r),P.Dot(r,B)>0?isNaN(N)?0:N:isNaN(N)?-Math.PI:-Math.acos(y)}static GetAngleBetweenVectorsOnPlane(R,J,B){f.nJ[0].h(R);const Q=f.nJ[0];f.nJ[1].h(J);const h=f.nJ[1];f.nJ[2].h(B);const y=f.nJ[2],N=f.nJ[3],r=f.nJ[4];Q.normalize(),h.normalize(),y.normalize(),P.CrossToRef(y,Q,N),P.CrossToRef(N,y,r);const e=Math.atan2(P.Dot(h,N),P.Dot(h,r));return(0,q.NormalizeRadians)(e)}static PitchYawRollToMoveBetweenPointsToRef(R,J,B){const Q=a.nJ[0];return J.subtractToRef(R,Q),B._y=Math.atan2(Q.x,Q.z)||0,B._x=Math.atan2(Math.sqrt(Q.x**2+Q.z**2),Q.y)||0,B._z=0,B._isDirty=!0,B}static PitchYawRollToMoveBetweenPoints(R,J){const B=P.Zero();return P.PitchYawRollToMoveBetweenPointsToRef(R,J,B)}static SlerpToRef(R,J,B,h){B=(0,q.Clamp)(B,0,1);const y=f.nJ[0],N=f.nJ[1];y.h(R);const r=y.length();y.normalizeFromLength(r),N.h(J);const e=N.length();N.normalizeFromLength(e);const D=P.Dot(y,N);let l,E;if(D<1-Q.d){const R=Math.acos(D),J=1/Math.sin(R);l=Math.sin((1-B)*R)*J,E=Math.sin(B*R)*J}else l=1-B,E=B;return y.scaleInPlace(l),N.scaleInPlace(E),h.h(y).addInPlace(N),h.scaleInPlace((0,q.Lerp)(r,e,B)),h}static SmoothToRef(R,J,B,Q,h){return P.SlerpToRef(R,J,0===Q?1:B/Q,h),h}static fJ(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new P(R[J],R[J+1],R[J+2])}static FromFloatArray(R,J){return P.fJ(R,J)}static FromArrayToRef(R,J,B){return B._x=R[J],B._y=R[J+1],B._z=R[J+2],B._isDirty=!0,B}static FromFloatArrayToRef(R,J,B){return P.FromArrayToRef(R,J,B)}static FromFloatsToRef(R,J,B,Q){return Q.Ar(R,J,B),Q}static Zero(){return new P(0,0,0)}static One(){return new P(1,1,1)}static Up(){return new P(0,1,0)}static get UpReadOnly(){return P._UpReadOnly}static get DownReadOnly(){return P._DownReadOnly}static get RightReadOnly(){return P._RightReadOnly}static get LeftReadOnly(){return P._LeftReadOnly}static get LeftHandedForwardReadOnly(){return P._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return P._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return P._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return P._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return P._ZeroReadOnly}static get OneReadOnly(){return P._OneReadOnly}static Down(){return new P(0,-1,0)}static Forward(){return new P(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new P(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new P(1,0,0)}static Left(){return new P(-1,0,0)}static Random(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new P((0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J))}static RandomToRef(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ar((0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J))}static TransformCoordinates(R,J){const B=P.Zero();return P.TransformCoordinatesToRef(R,J,B),B}static TransformCoordinatesToRef(R,J,B){return P.TransformCoordinatesFromFloatsToRef(R._x,R._y,R._z,J,B),B}static TransformCoordinatesFromFloatsToRef(R,J,B,Q,h){const y=Q.m,N=R*y[0]+J*y[4]+B*y[8]+y[12],r=R*y[1]+J*y[5]+B*y[9]+y[13],q=R*y[2]+J*y[6]+B*y[10]+y[14],e=1/(R*y[3]+J*y[7]+B*y[11]+y[15]);return h._x=N*e,h._y=r*e,h._z=q*e,h._isDirty=!0,h}static TransformNormal(R,J){const B=P.Zero();return P.TransformNormalToRef(R,J,B),B}static TransformNormalToRef(R,J,B){return this.TransformNormalFromFloatsToRef(R._x,R._y,R._z,J,B),B}static TransformNormalFromFloatsToRef(R,J,B,Q,h){const y=Q.m;return h._x=R*y[0]+J*y[4]+B*y[8],h._y=R*y[1]+J*y[5]+B*y[9],h._z=R*y[2]+J*y[6]+B*y[10],h._isDirty=!0,h}static CatmullRom(R,J,B,Q,h){const y=h*h,N=h*y,r=.5*(2*J._x+(-R._x+B._x)*h+(2*R._x-5*J._x+4*B._x-Q._x)*y+(-R._x+3*J._x-3*B._x+Q._x)*N),q=.5*(2*J._y+(-R._y+B._y)*h+(2*R._y-5*J._y+4*B._y-Q._y)*y+(-R._y+3*J._y-3*B._y+Q._y)*N),e=.5*(2*J._z+(-R._z+B._z)*h+(2*R._z-5*J._z+4*B._z-Q._z)*y+(-R._z+3*J._z-3*B._z+Q._z)*N);return new P(r,q,e)}static Clamp(R,J,B){const Q=new P;return P.ClampToRef(R,J,B,Q),Q}static ClampToRef(R,J,B,Q){let h=R._x;h=h>B._x?B._x:h,h=h<J._x?J._x:h;let y=R._y;y=y>B._y?B._y:y,y=y<J._y?J._y:y;let N=R._z;return N=N>B._z?B._z:N,N=N<J._z?J._z:N,Q.Ar(h,y,N),Q}static CheckExtends(R,J,B){J.minimizeInPlace(R),B.maximizeInPlace(R)}static Hermite(R,J,B,Q,h){const y=h*h,N=h*y,r=2*N-3*y+1,q=-2*N+3*y,e=N-2*y+h,D=N-y,l=R._x*r+B._x*q+J._x*e+Q._x*D,E=R._y*r+B._y*q+J._y*e+Q._y*D,O=R._z*r+B._z*q+J._z*e+Q._z*D;return new P(l,E,O)}static Hermite1stDerivative(R,J,B,Q,h){const y=new P;return this.Hermite1stDerivativeToRef(R,J,B,Q,h,y),y}static Hermite1stDerivativeToRef(R,J,B,Q,h,y){const N=h*h;return y._x=6*(N-h)*R._x+(3*N-4*h+1)*J._x+6*(-N+h)*B._x+(3*N-2*h)*Q._x,y._y=6*(N-h)*R._y+(3*N-4*h+1)*J._y+6*(-N+h)*B._y+(3*N-2*h)*Q._y,y._z=6*(N-h)*R._z+(3*N-4*h+1)*J._z+6*(-N+h)*B._z+(3*N-2*h)*Q._z,y._isDirty=!0,y}static Lerp(R,J,B){const Q=new P(0,0,0);return P.LerpToRef(R,J,B,Q),Q}static LerpToRef(R,J,B,Q){return Q._x=R._x+(J._x-R._x)*B,Q._y=R._y+(J._y-R._y)*B,Q._z=R._z+(J._z-R._z)*B,Q._isDirty=!0,Q}static Dot(R,J){return R._x*J._x+R._y*J._y+R._z*J._z}dot(R){return this._x*R._x+this._y*R._y+this._z*R._z}static Cross(R,J){const B=new P;return P.CrossToRef(R,J,B),B}static CrossToRef(R,J,B){const Q=R._y*J._z-R._z*J._y,h=R._z*J._x-R._x*J._z,y=R._x*J._y-R._y*J._x;return B.Ar(Q,h,y),B}static Normalize(R){const J=P.Zero();return P.NormalizeToRef(R,J),J}static NormalizeToRef(R,J){return R.normalizeToRef(J),J}static Project(R,J,B,Q){const h=new P;return P.ProjectToRef(R,J,B,Q,h),h}static ProjectToRef(R,J,B,Q,h){var y;const N=Q.width,q=Q.height,e=Q.x,D=Q.y,l=f.Matrix[1],E=null===(y=r.e.LastCreatedEngine)||void 0===y?void 0:y.isNDCHalfZRange,O=E?1:.5,n=E?0:.5;S.FromValuesToRef(N/2,0,0,0,0,-q/2,0,0,0,0,O,0,e+N/2,q/2+D,n,1,l);const A=f.Matrix[0];return J.multiplyToRef(B,A),A.multiplyToRef(l,A),P.TransformCoordinatesToRef(R,A,h),h}static Reflect(R,J){return this.ReflectToRef(R,J,new P)}static ReflectToRef(R,J,B){const Q=a.nJ[0];return Q.h(J).scaleInPlace(2*P.Dot(R,J)),B.h(R).ul(Q)}static _UnprojectFromInvertedMatrixToRef(R,J,B){P.TransformCoordinatesToRef(R,J,B);const Q=J.m,h=R._x*Q[3]+R._y*Q[7]+R._z*Q[11]+Q[15];return(0,q.WithinEpsilon)(h,1)&&B.scaleInPlace(1/h),B}static UnprojectFromTransform(R,J,B,Q,h){return this.Unproject(R,J,B,Q,h,S.IdentityReadOnly)}static Unproject(R,J,B,Q,h,y){const N=new P;return P.UnprojectToRef(R,J,B,Q,h,y,N),N}static UnprojectToRef(R,J,B,Q,h,y,N){return P.UnprojectFloatsToRef(R._x,R._y,R._z,J,B,Q,h,y,N),N}static UnprojectFloatsToRef(R,J,B,Q,h,y,N,q,e){var D;const l=f.Matrix[0];y.multiplyToRef(N,l),l.multiplyToRef(q,l),l.invert();const E=f.nJ[0];return E.x=R/Q*2-1,E.y=-(J/h*2-1),null!==(D=r.e.LastCreatedEngine)&&void 0!==D&&D.isNDCHalfZRange?E.z=B:E.z=2*B-1,P._UnprojectFromInvertedMatrixToRef(E,l,e),e}static Minimize(R,J){const B=new P;return B.h(R),B.minimizeInPlace(J),B}static Maximize(R,J){const B=new P;return B.h(R),B.maximizeInPlace(J),B}static Distance(R,J){return Math.sqrt(P.DistanceSquared(R,J))}static DistanceSquared(R,J){const B=R._x-J._x,Q=R._y-J._y,h=R._z-J._z;return B*B+Q*Q+h*h}static ProjectOnTriangleToRef(R,J,B,h,y){const N=f.nJ[0],r=f.nJ[1],e=f.nJ[2],D=f.nJ[3],l=f.nJ[4];B.subtractToRef(J,N),h.subtractToRef(J,r),h.subtractToRef(B,e);const E=N.length(),O=r.length(),n=e.length();if(E<Q.d||O<Q.d||n<Q.d)return y.h(J),P.Distance(R,J);R.subtractToRef(J,l),P.CrossToRef(N,r,D);const A=D.length();if(A<Q.d)return y.h(J),P.Distance(R,J);D.normalizeFromLength(A);let u=l.length();if(u<Q.d)return y.h(J),0;l.normalizeFromLength(u);const S=P.Dot(D,l),a=f.nJ[5],s=f.nJ[6];a.h(D).scaleInPlace(-u*S),s.h(R).addInPlace(a);const x=f.nJ[4],I=f.nJ[5],V=f.nJ[7],M=f.nJ[8];x.h(N).scaleInPlace(1/E),M.h(r).scaleInPlace(1/O),x.addInPlace(M).scaleInPlace(-1),I.h(N).scaleInPlace(-1/E),M.h(e).scaleInPlace(1/n),I.addInPlace(M).scaleInPlace(-1),V.h(e).scaleInPlace(-1/n),M.h(r).scaleInPlace(-1/O),V.addInPlace(M).scaleInPlace(-1);const H=f.nJ[9];let d;H.h(s).ul(J),P.CrossToRef(x,H,M),d=P.Dot(M,D);const X=d;H.h(s).ul(B),P.CrossToRef(I,H,M),d=P.Dot(M,D);const c=d;H.h(s).ul(h),P.CrossToRef(V,H,M),d=P.Dot(M,D);const z=d,p=f.nJ[10];let i,W;X>0&&c<0?(p.h(N),i=J,W=B):c>0&&z<0?(p.h(e),i=B,W=h):(p.h(r).scaleInPlace(-1),i=h,W=J);const k=f.nJ[9],Y=f.nJ[4];i.subtractToRef(s,M),W.subtractToRef(s,k),P.CrossToRef(M,k,Y);if(!(P.Dot(Y,D)<0))return y.h(s),Math.abs(u*S);const G=f.nJ[5];P.CrossToRef(p,Y,G),G.normalize();const g=f.nJ[9];g.h(i).ul(s);const L=g.length();if(L<Q.d)return y.h(i),P.Distance(R,i);g.normalizeFromLength(L);const j=P.Dot(G,g),T=f.nJ[7];T.h(s).addInPlace(G.scaleInPlace(L*j)),M.h(T).ul(i),u=p.length(),p.normalizeFromLength(u);let F=P.Dot(M,p)/Math.max(u,Q.d);return F=(0,q.Clamp)(F,0,1),T.h(i).addInPlace(p.scaleInPlace(F*u)),y.h(T),P.Distance(R,T)}static Center(R,J){return P.CenterToRef(R,J,P.Zero())}static CenterToRef(R,J,B){return B.Ar((R._x+J._x)/2,(R._y+J._y)/2,(R._z+J._z)/2)}static RotationFromAxis(R,J,B){const Q=new P;return P.RotationFromAxisToRef(R,J,B,Q),Q}static RotationFromAxisToRef(R,J,B,Q){const h=f.Quaternion[0];return u.RotationQuaternionFromAxisToRef(R,J,B,h),h.toEulerAnglesToRef(Q),Q}}P._V8PerformanceHack=new P(.5,.5,.5),P._UpReadOnly=P.Up(),P._DownReadOnly=P.Down(),P._LeftHandedForwardReadOnly=P.Forward(!1),P._RightHandedForwardReadOnly=P.Forward(!0),P._LeftHandedBackwardReadOnly=P.Backward(!1),P._RightHandedBackwardReadOnly=P.Backward(!0),P._RightReadOnly=P.Right(),P._LeftReadOnly=P.Left(),P._ZeroReadOnly=P.Zero(),P._OneReadOnly=P.One(),Object.defineProperties(P.prototype,{dimension:{value:[3]},rank:{value:1}});class A{get x(){return this._x}set x(R){this._x=R,this._isDirty=!0}get y(){return this._y}set y(R){this._y=R,this._isDirty=!0}get z(){return this._z}set z(R){this._z=R,this._isDirty=!0}get w(){return this._w}set w(R){this._w=R,this._isDirty=!0}constructor(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=R,this._y=J,this._z=B,this._w=Q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let R=O(this._x);return R=397*R^O(this._y),R=397*R^O(this._z),R=397*R^O(this._w),R}Ch(){return[this._x,this._y,this._z,this._w]}toArray(R,J){return void 0===J&&(J=0),R[J]=this._x,R[J+1]=this._y,R[J+2]=this._z,R[J+3]=this._w,this}EB(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return A.FromArrayToRef(R,J,this),this}addInPlace(R){return this.x+=R._x,this.y+=R._y,this.z+=R._z,this.w+=R._w,this}addInPlaceFromFloats(R,J,B,Q){return this.x+=R,this.y+=J,this.z+=B,this.w+=Q,this}add(R){return new A(this._x+R.x,this._y+R.y,this._z+R.z,this._w+R.w)}addToRef(R,J){return J.x=this._x+R.x,J.y=this._y+R.y,J.z=this._z+R.z,J.w=this._w+R.w,J}ul(R){return this.x-=R.x,this.y-=R.y,this.z-=R.z,this.w-=R.w,this}PJ(R){return new A(this._x-R.x,this._y-R.y,this._z-R.z,this._w-R.w)}subtractToRef(R,J){return J.x=this._x-R.x,J.y=this._y-R.y,J.z=this._z-R.z,J.w=this._w-R.w,J}subtractFromFloats(R,J,B,Q){return new A(this._x-R,this._y-J,this._z-B,this._w-Q)}subtractFromFloatsToRef(R,J,B,Q,h){return h.x=this._x-R,h.y=this._y-J,h.z=this._z-B,h.w=this._w-Q,h}negate(){return new A(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(R){return R.x=-this._x,R.y=-this._y,R.z=-this._z,R.w=-this._w,R}scaleInPlace(R){return this.x*=R,this.y*=R,this.z*=R,this.w*=R,this}scale(R){return new A(this._x*R,this._y*R,this._z*R,this._w*R)}scaleToRef(R,J){return J.x=this._x*R,J.y=this._y*R,J.z=this._z*R,J.w=this._w*R,J}scaleAndAddToRef(R,J){return J.x+=this._x*R,J.y+=this._y*R,J.z+=this._z*R,J.w+=this._w*R,J}equals(R){return R&&this._x===R.x&&this._y===R.y&&this._z===R.z&&this._w===R.w}equalsWithEpsilon(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.d;return R&&(0,q.WithinEpsilon)(this._x,R.x,J)&&(0,q.WithinEpsilon)(this._y,R.y,J)&&(0,q.WithinEpsilon)(this._z,R.z,J)&&(0,q.WithinEpsilon)(this._w,R.w,J)}equalsToFloats(R,J,B,Q){return this._x===R&&this._y===J&&this._z===B&&this._w===Q}multiplyInPlace(R){return this.x*=R.x,this.y*=R.y,this.z*=R.z,this.w*=R.w,this}multiply(R){return new A(this._x*R.x,this._y*R.y,this._z*R.z,this._w*R.w)}multiplyToRef(R,J){return J.x=this._x*R.x,J.y=this._y*R.y,J.z=this._z*R.z,J.w=this._w*R.w,J}multiplyByFloats(R,J,B,Q){return new A(this._x*R,this._y*J,this._z*B,this._w*Q)}divide(R){return new A(this._x/R.x,this._y/R.y,this._z/R.z,this._w/R.w)}divideToRef(R,J){return J.x=this._x/R.x,J.y=this._y/R.y,J.z=this._z/R.z,J.w=this._w/R.w,J}divideInPlace(R){return this.divideToRef(R,this)}minimizeInPlace(R){return R.x<this._x&&(this.x=R.x),R.y<this._y&&(this.y=R.y),R.z<this._z&&(this.z=R.z),R.w<this._w&&(this.w=R.w),this}maximizeInPlace(R){return R.x>this._x&&(this.x=R.x),R.y>this._y&&(this.y=R.y),R.z>this._z&&(this.z=R.z),R.w>this._w&&(this.w=R.w),this}minimizeInPlaceFromFloats(R,J,B,Q){return this.x=Math.min(R,this._x),this.y=Math.min(J,this._y),this.z=Math.min(B,this._z),this.w=Math.min(Q,this._w),this}maximizeInPlaceFromFloats(R,J,B,Q){return this.x=Math.max(R,this._x),this.y=Math.max(J,this._y),this.z=Math.max(B,this._z),this.w=Math.max(Q,this._w),this}floorToRef(R){return R.x=Math.floor(this._x),R.y=Math.floor(this._y),R.z=Math.floor(this._z),R.w=Math.floor(this._w),R}floor(){return new A(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(R){return R.x=this._x-Math.floor(this._x),R.y=this._y-Math.floor(this._y),R.z=this._z-Math.floor(this._z),R.w=this._w-Math.floor(this._w),R}fract(){return new A(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(R){return 0===R||1===R?this:this.scaleInPlace(1/R)}normalizeToNew(){return this.normalizeToRef(new A)}normalizeToRef(R){const J=this.length();return 0===J||1===J?(R.x=this._x,R.y=this._y,R.z=this._z,R.w=this._w,R):this.scaleToRef(1/J,R)}toVector3(){return new P(this._x,this._y,this._z)}clone(){return new A(this._x,this._y,this._z,this._w)}h(R){return this.x=R.x,this.y=R.y,this.z=R.z,this.w=R.w,this}Ar(R,J,B,Q){return this.x=R,this.y=J,this.z=B,this.w=Q,this}set(R,J,B,Q){return this.Ar(R,J,B,Q)}Sr(R){return this.x=this.y=this.z=this.w=R,this}dot(R){return this._x*R.x+this._y*R.y+this._z*R.z+this._w*R.w}static fJ(R,J){return J||(J=0),new A(R[J],R[J+1],R[J+2],R[J+3])}static FromArrayToRef(R,J,B){return B.x=R[J],B.y=R[J+1],B.z=R[J+2],B.w=R[J+3],B}static FromFloatArrayToRef(R,J,B){return A.FromArrayToRef(R,J,B),B}static FromFloatsToRef(R,J,B,Q,h){return h.x=R,h.y=J,h.z=B,h.w=Q,h}static Zero(){return new A(0,0,0,0)}static One(){return new A(1,1,1,1)}static Random(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new A((0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J))}static RandomToRef(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,B=arguments.length>2?arguments[2]:void 0;return B.x=(0,q.RandomRange)(R,J),B.y=(0,q.RandomRange)(R,J),B.z=(0,q.RandomRange)(R,J),B.w=(0,q.RandomRange)(R,J),B}static Clamp(R,J,B){return A.ClampToRef(R,J,B,new A)}static ClampToRef(R,J,B,Q){return Q.x=(0,q.Clamp)(R.x,J.x,B.x),Q.y=(0,q.Clamp)(R.y,J.y,B.y),Q.z=(0,q.Clamp)(R.z,J.z,B.z),Q.w=(0,q.Clamp)(R.w,J.w,B.w),Q}static CheckExtends(R,J,B){J.minimizeInPlace(R),B.maximizeInPlace(R)}static get ZeroReadOnly(){return A._ZeroReadOnly}static Normalize(R){return A.NormalizeToRef(R,new A)}static NormalizeToRef(R,J){return R.normalizeToRef(J),J}static Minimize(R,J){const B=new A;return B.h(R),B.minimizeInPlace(J),B}static Maximize(R,J){const B=new A;return B.h(R),B.maximizeInPlace(J),B}static Distance(R,J){return Math.sqrt(A.DistanceSquared(R,J))}static DistanceSquared(R,J){const B=R.x-J.x,Q=R.y-J.y,h=R.z-J.z,y=R.w-J.w;return B*B+Q*Q+h*h+y*y}static Center(R,J){return A.CenterToRef(R,J,new A)}static CenterToRef(R,J,B){return B.x=(R.x+J.x)/2,B.y=(R.y+J.y)/2,B.z=(R.z+J.z)/2,B.w=(R.w+J.w)/2,B}static TransformCoordinates(R,J){return A.TransformCoordinatesToRef(R,J,new A)}static TransformCoordinatesToRef(R,J,B){return A.TransformCoordinatesFromFloatsToRef(R._x,R._y,R._z,J,B),B}static TransformCoordinatesFromFloatsToRef(R,J,B,Q,h){const y=Q.m,N=R*y[0]+J*y[4]+B*y[8]+y[12],r=R*y[1]+J*y[5]+B*y[9]+y[13],q=R*y[2]+J*y[6]+B*y[10]+y[14],e=R*y[3]+J*y[7]+B*y[11]+y[15];return h.x=N,h.y=r,h.z=q,h.w=e,h}static TransformNormal(R,J){return A.TransformNormalToRef(R,J,new A)}static TransformNormalToRef(R,J,B){const Q=J.m,h=R.x*Q[0]+R.y*Q[4]+R.z*Q[8],y=R.x*Q[1]+R.y*Q[5]+R.z*Q[9],N=R.x*Q[2]+R.y*Q[6]+R.z*Q[10];return B.x=h,B.y=y,B.z=N,B.w=R.w,B}static TransformNormalFromFloatsToRef(R,J,B,Q,h,y){const N=h.m;return y.x=R*N[0]+J*N[4]+B*N[8],y.y=R*N[1]+J*N[5]+B*N[9],y.z=R*N[2]+J*N[6]+B*N[10],y.w=Q,y}static FromVector3(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new A(R._x,R._y,R._z,J)}static Dot(R,J){return R.x*J.x+R.y*J.y+R.z*J.z+R.w*J.w}}A._V8PerformanceHack=new A(.5,.5,.5,.5),A._ZeroReadOnly=A.Zero(),Object.defineProperties(A.prototype,{dimension:{value:[4]},rank:{value:1}});class u{get x(){return this._x}set x(R){this._x=R,this._isDirty=!0}get y(){return this._y}set y(R){this._y=R,this._isDirty=!0}get z(){return this._z}set z(R){this._z=R,this._isDirty=!0}get w(){return this._w}set w(R){this._w=R,this._isDirty=!0}constructor(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=R,this._y=J,this._z=B,this._w=Q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let R=O(this._x);return R=397*R^O(this._y),R=397*R^O(this._z),R=397*R^O(this._w),R}Ch(){return[this._x,this._y,this._z,this._w]}toArray(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R[J]=this._x,R[J+1]=this._y,R[J+2]=this._z,R[J+3]=this._w,this}EB(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(R,J,this)}equals(R){return R&&this._x===R._x&&this._y===R._y&&this._z===R._z&&this._w===R._w}equalsWithEpsilon(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.d;return R&&(0,q.WithinEpsilon)(this._x,R._x,J)&&(0,q.WithinEpsilon)(this._y,R._y,J)&&(0,q.WithinEpsilon)(this._z,R._z,J)&&(0,q.WithinEpsilon)(this._w,R._w,J)}isApprox(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.d;return R&&((0,q.WithinEpsilon)(this._x,R._x,J)&&(0,q.WithinEpsilon)(this._y,R._y,J)&&(0,q.WithinEpsilon)(this._z,R._z,J)&&(0,q.WithinEpsilon)(this._w,R._w,J)||(0,q.WithinEpsilon)(this._x,-R._x,J)&&(0,q.WithinEpsilon)(this._y,-R._y,J)&&(0,q.WithinEpsilon)(this._z,-R._z,J)&&(0,q.WithinEpsilon)(this._w,-R._w,J))}clone(){return new u(this._x,this._y,this._z,this._w)}h(R){return this._x=R._x,this._y=R._y,this._z=R._z,this._w=R._w,this._isDirty=!0,this}Ar(R,J,B,Q){return this._x=R,this._y=J,this._z=B,this._w=Q,this._isDirty=!0,this}set(R,J,B,Q){return this.Ar(R,J,B,Q)}Sr(R){return this.Ar(R,R,R,R)}add(R){return new u(this._x+R._x,this._y+R._y,this._z+R._z,this._w+R._w)}addInPlace(R){return this._x+=R._x,this._y+=R._y,this._z+=R._z,this._w+=R._w,this._isDirty=!0,this}addToRef(R,J){return J._x=this._x+R._x,J._y=this._y+R._y,J._z=this._z+R._z,J._w=this._w+R._w,J._isDirty=!0,J}addInPlaceFromFloats(R,J,B,Q){return this._x+=R,this._y+=J,this._z+=B,this._w+=Q,this._isDirty=!0,this}subtractToRef(R,J){return J._x=this._x-R._x,J._y=this._y-R._y,J._z=this._z-R._z,J._w=this._w-R._w,J._isDirty=!0,J}subtractFromFloats(R,J,B,Q){return this.subtractFromFloatsToRef(R,J,B,Q,new u)}subtractFromFloatsToRef(R,J,B,Q,h){return h._x=this._x-R,h._y=this._y-J,h._z=this._z-B,h._w=this._w-Q,h._isDirty=!0,h}PJ(R){return new u(this._x-R._x,this._y-R._y,this._z-R._z,this._w-R._w)}ul(R){return this._x-=R._x,this._y-=R._y,this._z-=R._z,this._w-=R._w,this._isDirty=!0,this}scale(R){return new u(this._x*R,this._y*R,this._z*R,this._w*R)}scaleToRef(R,J){return J._x=this._x*R,J._y=this._y*R,J._z=this._z*R,J._w=this._w*R,J._isDirty=!0,J}scaleInPlace(R){return this._x*=R,this._y*=R,this._z*=R,this._w*=R,this._isDirty=!0,this}scaleAndAddToRef(R,J){return J._x+=this._x*R,J._y+=this._y*R,J._z+=this._z*R,J._w+=this._w*R,J._isDirty=!0,J}multiply(R){const J=new u(0,0,0,1);return this.multiplyToRef(R,J),J}multiplyToRef(R,J){const B=this._x*R._w+this._y*R._z-this._z*R._y+this._w*R._x,Q=-this._x*R._z+this._y*R._w+this._z*R._x+this._w*R._y,h=this._x*R._y-this._y*R._x+this._z*R._w+this._w*R._z,y=-this._x*R._x-this._y*R._y-this._z*R._z+this._w*R._w;return J.Ar(B,Q,h,y),J}multiplyInPlace(R){return this.multiplyToRef(R,this)}multiplyByFloats(R,J,B,Q){return this._x*=R,this._y*=J,this._z*=B,this._w*=Q,this._isDirty=!0,this}divide(R){throw new ReferenceError("Can not divide a quaternion")}divideToRef(R,J){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(R){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new u)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(R){return R._x=-this._x,R._y=-this._y,R._z=-this._z,R._w=-this._w,R._isDirty=!0,R}equalsToFloats(R,J,B,Q){return this._x===R&&this._y===J&&this._z===B&&this._w===Q}floorToRef(R){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(R){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(R){return R.Ar(-this._x,-this._y,-this._z,this._w),R}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new u(-this._x,-this._y,-this._z,this._w)}invert(){const R=this.conjugate(),J=this.lengthSquared();return 0==J||1==J||R.scaleInPlace(1/J),R}invertInPlace(){this.conjugateInPlace();const R=this.lengthSquared();return 0==R||1==R||this.scaleInPlace(1/R),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(R){return 0===R||1===R?this:this.scaleInPlace(1/R)}normalizeToNew(){const R=new u(0,0,0,1);return this.normalizeToRef(R),R}normalizeToRef(R){const J=this.length();return 0===J||1===J?R.Ar(this._x,this._y,this._z,this._w):this.scaleToRef(1/J,R)}toEulerAngles(){const R=P.Zero();return this.toEulerAnglesToRef(R),R}toEulerAnglesToRef(R){const J=this._z,B=this._x,Q=this._y,h=this._w,y=Q*J-B*h,N=.4999999;if(y<-N)R._y=2*Math.atan2(Q,h),R._x=Math.PI/2,R._z=0,R._isDirty=!0;else if(y>N)R._y=2*Math.atan2(Q,h),R._x=-Math.PI/2,R._z=0,R._isDirty=!0;else{const N=h*h,r=J*J,q=B*B,e=Q*Q;R._z=Math.atan2(2*(B*Q+J*h),-r-q+e+N),R._x=Math.asin(-2*y),R._y=Math.atan2(2*(J*B+Q*h),r-q-e+N),R._isDirty=!0}return R}toAlphaBetaGammaToRef(R){const J=this._z,B=this._x,Q=this._y,h=this._w,y=Math.sqrt(B*B+Q*Q),N=Math.sqrt(J*J+h*h),r=2*Math.atan2(y,N),q=2*Math.atan2(J,h),e=2*Math.atan2(Q,B),D=(q+e)/2,l=(q-e)/2;return R.set(l,r,D),R}toRotationMatrix(R){return S.FromQuaternionToRef(this,R),R}fromRotationMatrix(R){return u.FromRotationMatrixToRef(R,this),this}dot(R){return this._x*R._x+this._y*R._y+this._z*R._z+this._w*R._w}toAxisAngle(){const R=P.Zero();return{axis:R,angle:this.toAxisAngleToRef(R)}}toAxisAngleToRef(R){let J=0;const B=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),Q=this._w;return B>0?(J=2*Math.atan2(B,Q),R.set(this._x/B,this._y/B,this._z/B)):(J=0,R.set(1,0,0)),J}static FromRotationMatrix(R){const J=new u;return u.FromRotationMatrixToRef(R,J),J}static FromRotationMatrixToRef(R,J){const B=R.m,Q=B[0],h=B[4],y=B[8],N=B[1],r=B[5],q=B[9],e=B[2],D=B[6],l=B[10],E=Q+r+l;let O;return E>0?(O=.5/Math.sqrt(E+1),J._w=.25/O,J._x=(D-q)*O,J._y=(y-e)*O,J._z=(N-h)*O,J._isDirty=!0):Q>r&&Q>l?(O=2*Math.sqrt(1+Q-r-l),J._w=(D-q)/O,J._x=.25*O,J._y=(h+N)/O,J._z=(y+e)/O,J._isDirty=!0):r>l?(O=2*Math.sqrt(1+r-Q-l),J._w=(y-e)/O,J._x=(h+N)/O,J._y=.25*O,J._z=(q+D)/O,J._isDirty=!0):(O=2*Math.sqrt(1+l-Q-r),J._w=(N-h)/O,J._x=(y+e)/O,J._y=(q+D)/O,J._z=.25*O,J._isDirty=!0),J}static Dot(R,J){return R._x*J._x+R._y*J._y+R._z*J._z+R._w*J._w}static AreClose(R,J){let B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const Q=u.Dot(R,J);return 1-Q*Q<=B}static SmoothToRef(R,J,B,Q,h){let y=0===Q?1:B/Q;return y=(0,q.Clamp)(y,0,1),u.SlerpToRef(R,J,y,h),h}static Zero(){return new u(0,0,0,0)}static Inverse(R){return new u(-R._x,-R._y,-R._z,R._w)}static InverseToRef(R,J){return J.set(-R._x,-R._y,-R._z,R._w),J}static Identity(){return new u(0,0,0,1)}static IsIdentity(R){return R&&0===R._x&&0===R._y&&0===R._z&&1===R._w}static RotationAxis(R,J){return u.RotationAxisToRef(R,J,new u)}static RotationAxisToRef(R,J,B){B._w=Math.cos(J/2);const Q=Math.sin(J/2)/R.length();return B._x=R._x*Q,B._y=R._y*Q,B._z=R._z*Q,B._isDirty=!0,B}static fJ(R,J){return J||(J=0),new u(R[J],R[J+1],R[J+2],R[J+3])}static FromArrayToRef(R,J,B){return B._x=R[J],B._y=R[J+1],B._z=R[J+2],B._w=R[J+3],B._isDirty=!0,B}static FromFloatsToRef(R,J,B,Q,h){return h.Ar(R,J,B,Q),h}static FromEulerAngles(R,J,B){const Q=new u;return u.RotationYawPitchRollToRef(J,R,B,Q),Q}static FromEulerAnglesToRef(R,J,B,Q){return u.RotationYawPitchRollToRef(J,R,B,Q),Q}static FromEulerVector(R){const J=new u;return u.RotationYawPitchRollToRef(R._y,R._x,R._z,J),J}static FromEulerVectorToRef(R,J){return u.RotationYawPitchRollToRef(R._y,R._x,R._z,J),J}static FromUnitVectorsToRef(R,J,B){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Q.d;const y=P.Dot(R,J)+1;return y<h?Math.abs(R.x)>Math.abs(R.z)?B.set(-R.y,R.x,0,0):B.set(0,-R.z,R.y,0):(P.CrossToRef(R,J,a.nJ[0]),B.set(a.nJ[0].x,a.nJ[0].y,a.nJ[0].z,y)),B.normalize()}static RotationYawPitchRoll(R,J,B){const Q=new u;return u.RotationYawPitchRollToRef(R,J,B,Q),Q}static RotationYawPitchRollToRef(R,J,B,Q){const h=.5*B,y=.5*J,N=.5*R,r=Math.sin(h),q=Math.cos(h),e=Math.sin(y),D=Math.cos(y),l=Math.sin(N),E=Math.cos(N);return Q._x=E*e*q+l*D*r,Q._y=l*D*q-E*e*r,Q._z=E*D*r-l*e*q,Q._w=E*D*q+l*e*r,Q._isDirty=!0,Q}static RotationAlphaBetaGamma(R,J,B){const Q=new u;return u.RotationAlphaBetaGammaToRef(R,J,B,Q),Q}static RotationAlphaBetaGammaToRef(R,J,B,Q){const h=.5*(B+R),y=.5*(B-R),N=.5*J;return Q._x=Math.cos(y)*Math.sin(N),Q._y=Math.sin(y)*Math.sin(N),Q._z=Math.sin(h)*Math.cos(N),Q._w=Math.cos(h)*Math.cos(N),Q._isDirty=!0,Q}static RotationQuaternionFromAxis(R,J,B){const Q=new u(0,0,0,0);return u.RotationQuaternionFromAxisToRef(R,J,B,Q),Q}static RotationQuaternionFromAxisToRef(R,J,B,Q){const h=f.Matrix[0];return R=R.normalizeToRef(f.nJ[0]),J=J.normalizeToRef(f.nJ[1]),B=B.normalizeToRef(f.nJ[2]),S.FromXYZAxesToRef(R,J,B,h),u.FromRotationMatrixToRef(h,Q),Q}static FromLookDirectionLH(R,J){const B=new u;return u.FromLookDirectionLHToRef(R,J,B),B}static FromLookDirectionLHToRef(R,J,B){const Q=f.Matrix[0];return S.LookDirectionLHToRef(R,J,Q),u.FromRotationMatrixToRef(Q,B),B}static FromLookDirectionRH(R,J){const B=new u;return u.FromLookDirectionRHToRef(R,J,B),B}static FromLookDirectionRHToRef(R,J,B){const Q=f.Matrix[0];return S.LookDirectionRHToRef(R,J,Q),u.FromRotationMatrixToRef(Q,B)}static Slerp(R,J,B){const Q=u.Identity();return u.SlerpToRef(R,J,B,Q),Q}static SlerpToRef(R,J,B,Q){let h,y,N=R._x*J._x+R._y*J._y+R._z*J._z+R._w*J._w,r=!1;if(N<0&&(r=!0,N=-N),N>.999999)y=1-B,h=r?-B:B;else{const R=Math.acos(N),J=1/Math.sin(R);y=Math.sin((1-B)*R)*J,h=r?-Math.sin(B*R)*J:Math.sin(B*R)*J}return Q._x=y*R._x+h*J._x,Q._y=y*R._y+h*J._y,Q._z=y*R._z+h*J._z,Q._w=y*R._w+h*J._w,Q._isDirty=!0,Q}static Hermite(R,J,B,Q,h){const y=h*h,N=h*y,r=2*N-3*y+1,q=-2*N+3*y,e=N-2*y+h,D=N-y,l=R._x*r+B._x*q+J._x*e+Q._x*D,E=R._y*r+B._y*q+J._y*e+Q._y*D,O=R._z*r+B._z*q+J._z*e+Q._z*D,n=R._w*r+B._w*q+J._w*e+Q._w*D;return new u(l,E,O,n)}static Hermite1stDerivative(R,J,B,Q,h){const y=new u;return this.Hermite1stDerivativeToRef(R,J,B,Q,h,y),y}static Hermite1stDerivativeToRef(R,J,B,Q,h,y){const N=h*h;return y._x=6*(N-h)*R._x+(3*N-4*h+1)*J._x+6*(-N+h)*B._x+(3*N-2*h)*Q._x,y._y=6*(N-h)*R._y+(3*N-4*h+1)*J._y+6*(-N+h)*B._y+(3*N-2*h)*Q._y,y._z=6*(N-h)*R._z+(3*N-4*h+1)*J._z+6*(-N+h)*B._z+(3*N-2*h)*Q._z,y._w=6*(N-h)*R._w+(3*N-4*h+1)*J._w+6*(-N+h)*B._w+(3*N-2*h)*Q._w,y._isDirty=!0,y}static Normalize(R){const J=u.Zero();return u.NormalizeToRef(R,J),J}static NormalizeToRef(R,J){return R.normalizeToRef(J),J}static Clamp(R,J,B){const Q=new u;return u.ClampToRef(R,J,B,Q),Q}static ClampToRef(R,J,B,Q){return Q.Ar((0,q.Clamp)(R.x,J.x,B.x),(0,q.Clamp)(R.y,J.y,B.y),(0,q.Clamp)(R.z,J.z,B.z),(0,q.Clamp)(R.w,J.w,B.w))}static Random(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new u((0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J))}static RandomToRef(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ar((0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J),(0,q.RandomRange)(R,J))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(R,J){return Math.sqrt(u.DistanceSquared(R,J))}static DistanceSquared(R,J){const B=R.x-J.x,Q=R.y-J.y,h=R.z-J.z,y=R.w-J.w;return B*B+Q*Q+h*h+y*y}static Center(R,J){return u.CenterToRef(R,J,u.Zero())}static CenterToRef(R,J,B){return B.Ar((R.x+J.x)/2,(R.y+J.y)/2,(R.z+J.z)/2,(R.w+J.w)/2)}}u._V8PerformanceHack=new u(.5,.5,.5,.5),Object.defineProperties(u.prototype,{dimension:{value:[4]},rank:{value:1}});class S{static get Use64Bits(){return N.e.MatrixUse64Bits}get m(){return this.nh}markAsUpdated(){this.updateFlag=e._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(R){let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1],B=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=R,this._isIdentity3x2=R||B,this._isIdentityDirty=!this._isIdentity&&J,this._isIdentity3x2Dirty=!this._isIdentity3x2&&Q}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,N.e.MatrixTrackPrecisionChange&&N.e.MatrixTrackedMatrices.push(this),this.nh=new N.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const R=this.nh;this._isIdentity=1===R[0]&&0===R[1]&&0===R[2]&&0===R[3]&&0===R[4]&&1===R[5]&&0===R[6]&&0===R[7]&&0===R[8]&&0===R[9]&&1===R[10]&&0===R[11]&&0===R[12]&&0===R[13]&&0===R[14]&&1===R[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.nh[0]||1!==this.nh[5]||1!==this.nh[15]||0!==this.nh[1]||0!==this.nh[2]||0!==this.nh[3]||0!==this.nh[4]||0!==this.nh[6]||0!==this.nh[7]||0!==this.nh[8]||0!==this.nh[9]||0!==this.nh[10]||0!==this.nh[11]||0!==this.nh[12]||0!==this.nh[13]||0!==this.nh[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const R=this.nh,J=R[0],B=R[1],Q=R[2],h=R[3],y=R[4],N=R[5],r=R[6],q=R[7],e=R[8],D=R[9],l=R[10],E=R[11],O=R[12],n=R[13],P=R[14],A=R[15],u=l*A-P*E,S=D*A-n*E,f=D*P-n*l,a=e*A-O*E,s=e*P-l*O,x=e*n-O*D;return J*+(N*u-r*S+q*f)+B*-(y*u-r*a+q*s)+Q*+(y*S-N*a+q*x)+h*-(y*f-N*s+r*x)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!R)return this.nh;const B=this.nh;for(let Q=0;Q<16;Q++)R[J+Q]=B[Q];return this}Ch(){return this.nh}EB(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(R,J,this)}Ar(){for(var R=arguments.length,J=new Array(R),B=0;B<R;B++)J[B]=arguments[B];return S.FromArrayToRef(J,0,this)}set(){const R=this.nh;for(let J=0;J<16;J++)R[J]=J<0||arguments.length<=J?void 0:arguments[J];return this.markAsUpdated(),this}Sr(R){const J=this.nh;for(let B=0;B<16;B++)J[B]=R;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return S.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(R){const J=new S;return this.addToRef(R,J),J}addToRef(R,J){const B=this.nh,Q=J.nh,h=R.m;for(let y=0;y<16;y++)Q[y]=B[y]+h[y];return J.markAsUpdated(),J}addToSelf(R){const J=this.nh,B=R.m;return J[0]+=B[0],J[1]+=B[1],J[2]+=B[2],J[3]+=B[3],J[4]+=B[4],J[5]+=B[5],J[6]+=B[6],J[7]+=B[7],J[8]+=B[8],J[9]+=B[9],J[10]+=B[10],J[11]+=B[11],J[12]+=B[12],J[13]+=B[13],J[14]+=B[14],J[15]+=B[15],this.markAsUpdated(),this}addInPlace(R){const J=this.nh,B=R.m;for(let Q=0;Q<16;Q++)J[Q]+=B[Q];return this.markAsUpdated(),this}addInPlaceFromFloats(){const R=this.nh;for(let J=0;J<16;J++)R[J]+=J<0||arguments.length<=J?void 0:arguments[J];return this.markAsUpdated(),this}PJ(R){const J=this.nh,B=R.m;for(let Q=0;Q<16;Q++)J[Q]-=B[Q];return this.markAsUpdated(),this}subtractToRef(R,J){const B=this.nh,Q=R.m,h=J.nh;for(let y=0;y<16;y++)h[y]=B[y]-Q[y];return J.markAsUpdated(),J}ul(R){const J=this.nh,B=R.m;for(let Q=0;Q<16;Q++)J[Q]-=B[Q];return this.markAsUpdated(),this}subtractFromFloats(){for(var R=arguments.length,J=new Array(R),B=0;B<R;B++)J[B]=arguments[B];return this.subtractFromFloatsToRef(...J,new S)}subtractFromFloatsToRef(){for(var R=arguments.length,J=new Array(R),B=0;B<R;B++)J[B]=arguments[B];const Q=J.pop(),h=this.nh,y=Q.nh,N=J;for(let r=0;r<16;r++)y[r]=h[r]-N[r];return Q.markAsUpdated(),Q}invertToRef(R){return!0===this._isIdentity?(S.IdentityToRef(R),R):(E(this,R.Ch())?R.markAsUpdated():R.h(this),R)}addAtIndex(R,J){return this.nh[R]+=J,this.markAsUpdated(),this}multiplyAtIndex(R,J){return this.nh[R]*=J,this.markAsUpdated(),this}setTranslationFromFloats(R,J,B){return this.nh[12]=R,this.nh[13]=J,this.nh[14]=B,this.markAsUpdated(),this}addTranslationFromFloats(R,J,B){return this.nh[12]+=R,this.nh[13]+=J,this.nh[14]+=B,this.markAsUpdated(),this}setTranslation(R){return this.setTranslationFromFloats(R._x,R._y,R._z)}getTranslation(){return new P(this.nh[12],this.nh[13],this.nh[14])}getTranslationToRef(R){return R.x=this.nh[12],R.y=this.nh[13],R.z=this.nh[14],R}removeRotationAndScaling(){const R=this.m;return S.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,R[12],R[13],R[14],R[15],this),this._updateIdentityStatus(0===R[12]&&0===R[13]&&0===R[14]&&1===R[15]),this}h(R){R.copyToArray(this.nh);const J=R;return this.updateFlag=J.updateFlag,this._updateIdentityStatus(J._isIdentity,J._isIdentityDirty,J._isIdentity3x2,J._isIdentity3x2Dirty),this}copyToArray(R){return l(this,R,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(R){const J=new S;return this.multiplyToRef(R,J),J}multiplyInPlace(R){const J=this.nh,B=R.m;for(let Q=0;Q<16;Q++)J[Q]*=B[Q];return this.markAsUpdated(),this}multiplyByFloats(){const R=this.nh;for(let J=0;J<16;J++)R[J]*=J<0||arguments.length<=J?void 0:arguments[J];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var R=arguments.length,J=new Array(R),B=0;B<R;B++)J[B]=arguments[B];const Q=J.pop(),h=this.nh,y=Q.nh,N=J;for(let r=0;r<16;r++)y[r]=h[r]*N[r];return Q.markAsUpdated(),Q}multiplyToRef(R,J){return this._isIdentity?(J.h(R),J):R._isIdentity?(J.h(this),J):(this.multiplyToArray(R,J.nh,0),J.markAsUpdated(),J)}multiplyToArray(R,J,B){return D(this,R,J,B),this}divide(R){return this.divideToRef(R,new S)}divideToRef(R,J){const B=this.nh,Q=R.m,h=J.nh;for(let y=0;y<16;y++)h[y]=B[y]/Q[y];return J.markAsUpdated(),J}divideInPlace(R){const J=this.nh,B=R.m;for(let Q=0;Q<16;Q++)J[Q]/=B[Q];return this.markAsUpdated(),this}minimizeInPlace(R){const J=this.nh,B=R.m;for(let Q=0;Q<16;Q++)J[Q]=Math.min(J[Q],B[Q]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const R=this.nh;for(let J=0;J<16;J++)R[J]=Math.min(R[J],J<0||arguments.length<=J?void 0:arguments[J]);return this.markAsUpdated(),this}maximizeInPlace(R){const J=this.nh,B=R.m;for(let Q=0;Q<16;Q++)J[Q]=Math.min(J[Q],B[Q]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const R=this.nh;for(let J=0;J<16;J++)R[J]=Math.min(R[J],J<0||arguments.length<=J?void 0:arguments[J]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new S)}negateInPlace(){const R=this.nh;for(let J=0;J<16;J++)R[J]=-R[J];return this.markAsUpdated(),this}negateToRef(R){const J=this.nh,B=R.nh;for(let Q=0;Q<16;Q++)B[Q]=-J[Q];return R.markAsUpdated(),R}equals(R){const J=R;if(!J)return!1;if((this._isIdentity||J._isIdentity)&&!this._isIdentityDirty&&!J._isIdentityDirty)return this._isIdentity&&J._isIdentity;const B=this.m,Q=J.m;return B[0]===Q[0]&&B[1]===Q[1]&&B[2]===Q[2]&&B[3]===Q[3]&&B[4]===Q[4]&&B[5]===Q[5]&&B[6]===Q[6]&&B[7]===Q[7]&&B[8]===Q[8]&&B[9]===Q[9]&&B[10]===Q[10]&&B[11]===Q[11]&&B[12]===Q[12]&&B[13]===Q[13]&&B[14]===Q[14]&&B[15]===Q[15]}equalsWithEpsilon(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const B=this.nh,Q=R.m;for(let h=0;h<16;h++)if(!(0,q.WithinEpsilon)(B[h],Q[h],J))return!1;return!0}equalsToFloats(){const R=this.nh;for(let J=0;J<16;J++)if(R[J]!=(J<0||arguments.length<=J?void 0:arguments[J]))return!1;return!0}floor(){return this.floorToRef(new S)}floorToRef(R){const J=this.nh,B=R.nh;for(let Q=0;Q<16;Q++)B[Q]=Math.floor(J[Q]);return R.markAsUpdated(),R}fract(){return this.fractToRef(new S)}fractToRef(R){const J=this.nh,B=R.nh;for(let Q=0;Q<16;Q++)B[Q]=J[Q]-Math.floor(J[Q]);return R.markAsUpdated(),R}clone(){const R=new S;return R.h(this),R}getClassName(){return"Matrix"}getHashCode(){let R=O(this.nh[0]);for(let J=1;J<16;J++)R=397*R^O(this.nh[J]);return R}decomposeToTransformNode(R){return R.rotationQuaternion=R.rotationQuaternion||new u,this.decompose(R.ur,R.rotationQuaternion,R.position)}decompose(R,J,B,Q){let h=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return B&&B.Sr(0),R&&R.Sr(1),J&&J.Ar(0,0,0,1),!0;const y=this.nh;if(B&&B.Ar(y[12],y[13],y[14]),(R=R||f.nJ[0]).x=Math.sqrt(y[0]*y[0]+y[1]*y[1]+y[2]*y[2]),R.y=Math.sqrt(y[4]*y[4]+y[5]*y[5]+y[6]*y[6]),R.z=Math.sqrt(y[8]*y[8]+y[9]*y[9]+y[10]*y[10]),Q){const J=(h?Q.absoluteScaling.x:Q.ur.x)<0?-1:1,B=(h?Q.absoluteScaling.y:Q.ur.y)<0?-1:1,y=(h?Q.absoluteScaling.z:Q.ur.z)<0?-1:1;R.x*=J,R.y*=B,R.z*=y}else this.determinant()<=0&&(R.y*=-1);if(0===R._x||0===R._y||0===R._z)return J&&J.Ar(0,0,0,1),!1;if(J){const B=1/R._x,Q=1/R._y,h=1/R._z;S.FromValuesToRef(y[0]*B,y[1]*B,y[2]*B,0,y[4]*Q,y[5]*Q,y[6]*Q,0,y[8]*h,y[9]*h,y[10]*h,0,0,0,0,1,f.Matrix[0]),u.FromRotationMatrixToRef(f.Matrix[0],J)}return!0}getRow(R){if(R<0||R>3)return null;const J=4*R;return new A(this.nh[J+0],this.nh[J+1],this.nh[J+2],this.nh[J+3])}getRowToRef(R,J){if(R>=0&&R<=3){const B=4*R;J.x=this.nh[B+0],J.y=this.nh[B+1],J.z=this.nh[B+2],J.w=this.nh[B+3]}return J}setRow(R,J){return this.setRowFromFloats(R,J.x,J.y,J.z,J.w)}transpose(){const R=new S;return S.TransposeToRef(this,R),R}transposeToRef(R){return S.TransposeToRef(this,R),R}setRowFromFloats(R,J,B,Q,h){if(R<0||R>3)return this;const y=4*R;return this.nh[y+0]=J,this.nh[y+1]=B,this.nh[y+2]=Q,this.nh[y+3]=h,this.markAsUpdated(),this}scale(R){const J=new S;return this.scaleToRef(R,J),J}scaleToRef(R,J){for(let B=0;B<16;B++)J.nh[B]=this.nh[B]*R;return J.markAsUpdated(),J}scaleAndAddToRef(R,J){for(let B=0;B<16;B++)J.nh[B]+=this.nh[B]*R;return J.markAsUpdated(),J}scaleInPlace(R){const J=this.nh;for(let B=0;B<16;B++)J[B]*=R;return this.markAsUpdated(),this}toNormalMatrix(R){const J=f.Matrix[0];this.invertToRef(J),J.transposeToRef(R);const B=R.nh;return S.FromValuesToRef(B[0],B[1],B[2],0,B[4],B[5],B[6],0,B[8],B[9],B[10],0,0,0,0,1,R),R}getRotationMatrix(){const R=new S;return this.getRotationMatrixToRef(R),R}getRotationMatrixToRef(R){const J=f.nJ[0];if(!this.decompose(J))return S.IdentityToRef(R),R;const B=this.nh,Q=1/J._x,h=1/J._y,y=1/J._z;return S.FromValuesToRef(B[0]*Q,B[1]*Q,B[2]*Q,0,B[4]*h,B[5]*h,B[6]*h,0,B[8]*y,B[9]*y,B[10]*y,0,0,0,0,1,R),R}toggleModelMatrixHandInPlace(){const R=this.nh;return R[2]*=-1,R[6]*=-1,R[8]*=-1,R[9]*=-1,R[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const R=this.nh;return R[8]*=-1,R[9]*=-1,R[10]*=-1,R[11]*=-1,this.markAsUpdated(),this}static fJ(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const B=new S;return S.FromArrayToRef(R,J,B),B}static FromArrayToRef(R,J,B){for(let Q=0;Q<16;Q++)B.nh[Q]=R[Q+J];return B.markAsUpdated(),B}static FromFloat32ArrayToRefScaled(R,J,B,Q){return Q.nh[0]=R[0+J]*B,Q.nh[1]=R[1+J]*B,Q.nh[2]=R[2+J]*B,Q.nh[3]=R[3+J]*B,Q.nh[4]=R[4+J]*B,Q.nh[5]=R[5+J]*B,Q.nh[6]=R[6+J]*B,Q.nh[7]=R[7+J]*B,Q.nh[8]=R[8+J]*B,Q.nh[9]=R[9+J]*B,Q.nh[10]=R[10+J]*B,Q.nh[11]=R[11+J]*B,Q.nh[12]=R[12+J]*B,Q.nh[13]=R[13+J]*B,Q.nh[14]=R[14+J]*B,Q.nh[15]=R[15+J]*B,Q.markAsUpdated(),Q}static get IdentityReadOnly(){return S._IdentityReadOnly}static FromValuesToRef(R,J,B,Q,h,y,N,r,q,e,D,l,E,O,n,P,A){const u=A.nh;u[0]=R,u[1]=J,u[2]=B,u[3]=Q,u[4]=h,u[5]=y,u[6]=N,u[7]=r,u[8]=q,u[9]=e,u[10]=D,u[11]=l,u[12]=E,u[13]=O,u[14]=n,u[15]=P,A.markAsUpdated()}static FromValues(R,J,B,Q,h,y,N,r,q,e,D,l,E,O,n,P){const A=new S,u=A.nh;return u[0]=R,u[1]=J,u[2]=B,u[3]=Q,u[4]=h,u[5]=y,u[6]=N,u[7]=r,u[8]=q,u[9]=e,u[10]=D,u[11]=l,u[12]=E,u[13]=O,u[14]=n,u[15]=P,A.markAsUpdated(),A}static Compose(R,J,B){const Q=new S;return S.ComposeToRef(R,J,B,Q),Q}static ComposeToRef(R,J,B,Q){const h=Q.nh,y=J._x,N=J._y,r=J._z,q=J._w,e=y+y,D=N+N,l=r+r,E=y*e,O=y*D,n=y*l,P=N*D,A=N*l,u=r*l,S=q*e,f=q*D,a=q*l,s=R._x,x=R._y,I=R._z;return h[0]=(1-(P+u))*s,h[1]=(O+a)*s,h[2]=(n-f)*s,h[3]=0,h[4]=(O-a)*x,h[5]=(1-(E+u))*x,h[6]=(A+S)*x,h[7]=0,h[8]=(n+f)*I,h[9]=(A-S)*I,h[10]=(1-(E+P))*I,h[11]=0,h[12]=B._x,h[13]=B._y,h[14]=B._z,h[15]=1,Q.markAsUpdated(),Q}static Identity(){const R=S.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return R._updateIdentityStatus(!0),R}static IdentityToRef(R){return S.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,R),R._updateIdentityStatus(!0),R}static Zero(){const R=S.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return R._updateIdentityStatus(!1),R}static RotationX(R){const J=new S;return S.RotationXToRef(R,J),J}static Invert(R){const J=new S;return R.invertToRef(J),J}static RotationXToRef(R,J){const B=Math.sin(R),Q=Math.cos(R);return S.FromValuesToRef(1,0,0,0,0,Q,B,0,0,-B,Q,0,0,0,0,1,J),J._updateIdentityStatus(1===Q&&0===B),J}static RotationY(R){const J=new S;return S.RotationYToRef(R,J),J}static RotationYToRef(R,J){const B=Math.sin(R),Q=Math.cos(R);return S.FromValuesToRef(Q,0,-B,0,0,1,0,0,B,0,Q,0,0,0,0,1,J),J._updateIdentityStatus(1===Q&&0===B),J}static RotationZ(R){const J=new S;return S.RotationZToRef(R,J),J}static RotationZToRef(R,J){const B=Math.sin(R),Q=Math.cos(R);return S.FromValuesToRef(Q,B,0,0,-B,Q,0,0,0,0,1,0,0,0,0,1,J),J._updateIdentityStatus(1===Q&&0===B),J}static RotationAxis(R,J){const B=new S;return S.RotationAxisToRef(R,J,B),B}static RotationAxisToRef(R,J,B){const Q=Math.sin(-J),h=Math.cos(-J),y=1-h;R=R.normalizeToRef(f.nJ[0]);const N=B.nh;return N[0]=R._x*R._x*y+h,N[1]=R._x*R._y*y-R._z*Q,N[2]=R._x*R._z*y+R._y*Q,N[3]=0,N[4]=R._y*R._x*y+R._z*Q,N[5]=R._y*R._y*y+h,N[6]=R._y*R._z*y-R._x*Q,N[7]=0,N[8]=R._z*R._x*y-R._y*Q,N[9]=R._z*R._y*y+R._x*Q,N[10]=R._z*R._z*y+h,N[11]=0,N[12]=0,N[13]=0,N[14]=0,N[15]=1,B.markAsUpdated(),B}static RotationAlignToRef(R,J,B){let h=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const y=P.Dot(J,R),N=B.nh;if(y<-1+Q.d)N[0]=-1,N[1]=0,N[2]=0,N[3]=0,N[4]=0,N[5]=h?1:-1,N[6]=0,N[7]=0,N[8]=0,N[9]=0,N[10]=h?-1:1,N[11]=0;else{const B=P.Cross(J,R),Q=1/(1+y);N[0]=B._x*B._x*Q+y,N[1]=B._y*B._x*Q-B._z,N[2]=B._z*B._x*Q+B._y,N[3]=0,N[4]=B._x*B._y*Q+B._z,N[5]=B._y*B._y*Q+y,N[6]=B._z*B._y*Q-B._x,N[7]=0,N[8]=B._x*B._z*Q-B._y,N[9]=B._y*B._z*Q+B._x,N[10]=B._z*B._z*Q+y,N[11]=0}return N[12]=0,N[13]=0,N[14]=0,N[15]=1,B.markAsUpdated(),B}static RotationYawPitchRoll(R,J,B){const Q=new S;return S.RotationYawPitchRollToRef(R,J,B,Q),Q}static RotationYawPitchRollToRef(R,J,B,Q){return u.RotationYawPitchRollToRef(R,J,B,f.Quaternion[0]),f.Quaternion[0].toRotationMatrix(Q),Q}static Scaling(R,J,B){const Q=new S;return S.ScalingToRef(R,J,B,Q),Q}static ScalingToRef(R,J,B,Q){return S.FromValuesToRef(R,0,0,0,0,J,0,0,0,0,B,0,0,0,0,1,Q),Q._updateIdentityStatus(1===R&&1===J&&1===B),Q}static Translation(R,J,B){const Q=new S;return S.TranslationToRef(R,J,B,Q),Q}static TranslationToRef(R,J,B,Q){return S.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,R,J,B,1,Q),Q._updateIdentityStatus(0===R&&0===J&&0===B),Q}static Lerp(R,J,B){const Q=new S;return S.LerpToRef(R,J,B,Q),Q}static LerpToRef(R,J,B,Q){const h=Q.nh,y=R.m,N=J.m;for(let r=0;r<16;r++)h[r]=y[r]*(1-B)+N[r]*B;return Q.markAsUpdated(),Q}static DecomposeLerp(R,J,B){const Q=new S;return S.DecomposeLerpToRef(R,J,B,Q),Q}static DecomposeLerpToRef(R,J,B,Q){const h=f.nJ[0],y=f.Quaternion[0],N=f.nJ[1];R.decompose(h,y,N);const r=f.nJ[2],q=f.Quaternion[1],e=f.nJ[3];J.decompose(r,q,e);const D=f.nJ[4];P.LerpToRef(h,r,B,D);const l=f.Quaternion[2];u.SlerpToRef(y,q,B,l);const E=f.nJ[5];return P.LerpToRef(N,e,B,E),S.ComposeToRef(D,l,E,Q),Q}static LookAtLH(R,J,B){const Q=new S;return S.LookAtLHToRef(R,J,B,Q),Q}static LookAtLHToRef(R,J,B,Q){const h=f.nJ[0],y=f.nJ[1],N=f.nJ[2];J.subtractToRef(R,N),N.normalize(),P.CrossToRef(B,N,h);const r=h.lengthSquared();0===r?h.x=1:h.normalizeFromLength(Math.sqrt(r)),P.CrossToRef(N,h,y),y.normalize();const q=-P.Dot(h,R),e=-P.Dot(y,R),D=-P.Dot(N,R);return S.FromValuesToRef(h._x,y._x,N._x,0,h._y,y._y,N._y,0,h._z,y._z,N._z,0,q,e,D,1,Q),Q}static LookAtRH(R,J,B){const Q=new S;return S.LookAtRHToRef(R,J,B,Q),Q}static LookAtRHToRef(R,J,B,Q){const h=f.nJ[0],y=f.nJ[1],N=f.nJ[2];R.subtractToRef(J,N),N.normalize(),P.CrossToRef(B,N,h);const r=h.lengthSquared();0===r?h.x=1:h.normalizeFromLength(Math.sqrt(r)),P.CrossToRef(N,h,y),y.normalize();const q=-P.Dot(h,R),e=-P.Dot(y,R),D=-P.Dot(N,R);return S.FromValuesToRef(h._x,y._x,N._x,0,h._y,y._y,N._y,0,h._z,y._z,N._z,0,q,e,D,1,Q),Q}static LookDirectionLH(R,J){const B=new S;return S.LookDirectionLHToRef(R,J,B),B}static LookDirectionLHToRef(R,J,B){const Q=f.nJ[0];Q.h(R),Q.scaleInPlace(-1);const h=f.nJ[1];return P.CrossToRef(J,Q,h),S.FromValuesToRef(h._x,h._y,h._z,0,J._x,J._y,J._z,0,Q._x,Q._y,Q._z,0,0,0,0,1,B),B}static LookDirectionRH(R,J){const B=new S;return S.LookDirectionRHToRef(R,J,B),B}static LookDirectionRHToRef(R,J,B){const Q=f.nJ[2];return P.CrossToRef(J,R,Q),S.FromValuesToRef(Q._x,Q._y,Q._z,0,J._x,J._y,J._z,0,R._x,R._y,R._z,0,0,0,0,1,B),B}static OrthoLH(R,J,B,Q,h){const y=new S;return S.OrthoLHToRef(R,J,B,Q,y,h),y}static OrthoLHToRef(R,J,B,Q,h,y){const N=2/R,r=2/J,q=2/(Q-B),e=-(Q+B)/(Q-B);return S.FromValuesToRef(N,0,0,0,0,r,0,0,0,0,q,0,0,0,e,1,h),y&&h.multiplyToRef(s,h),h._updateIdentityStatus(1===N&&1===r&&1===q&&0===e),h}static OrthoOffCenterLH(R,J,B,Q,h,y,N){const r=new S;return S.OrthoOffCenterLHToRef(R,J,B,Q,h,y,r,N),r}static OrthoOffCenterLHToRef(R,J,B,Q,h,y,N,r){const q=2/(J-R),e=2/(Q-B),D=2/(y-h),l=-(y+h)/(y-h),E=(R+J)/(R-J),O=(Q+B)/(B-Q);return S.FromValuesToRef(q,0,0,0,0,e,0,0,0,0,D,0,E,O,l,1,N),r&&N.multiplyToRef(s,N),N.markAsUpdated(),N}static ObliqueOffCenterLHToRef(R,J,B,Q,h,y,N,r,q,e,D){const l=-N*Math.cos(r),E=-N*Math.sin(r);return S.TranslationToRef(0,0,-q,f.Matrix[1]),S.FromValuesToRef(1,0,0,0,0,1,0,0,l,E,1,0,0,0,0,1,f.Matrix[0]),f.Matrix[1].multiplyToRef(f.Matrix[0],f.Matrix[0]),S.TranslationToRef(0,0,q,f.Matrix[1]),f.Matrix[0].multiplyToRef(f.Matrix[1],f.Matrix[0]),S.OrthoOffCenterLHToRef(R,J,B,Q,h,y,e,D),f.Matrix[0].multiplyToRef(e,e),e}static OrthoOffCenterRH(R,J,B,Q,h,y,N){const r=new S;return S.OrthoOffCenterRHToRef(R,J,B,Q,h,y,r,N),r}static OrthoOffCenterRHToRef(R,J,B,Q,h,y,N,r){return S.OrthoOffCenterLHToRef(R,J,B,Q,h,y,N,r),N.nh[10]*=-1,N}static ObliqueOffCenterRHToRef(R,J,B,Q,h,y,N,r,q,e,D){const l=N*Math.cos(r),E=N*Math.sin(r);return S.TranslationToRef(0,0,q,f.Matrix[1]),S.FromValuesToRef(1,0,0,0,0,1,0,0,l,E,1,0,0,0,0,1,f.Matrix[0]),f.Matrix[1].multiplyToRef(f.Matrix[0],f.Matrix[0]),S.TranslationToRef(0,0,-q,f.Matrix[1]),f.Matrix[0].multiplyToRef(f.Matrix[1],f.Matrix[0]),S.OrthoOffCenterRHToRef(R,J,B,Q,h,y,e,D),f.Matrix[0].multiplyToRef(e,e),e}static PerspectiveLH(R,J,B,Q,h){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const N=new S,r=2*B/R,q=2*B/J,e=(Q+B)/(Q-B),D=-2*Q*B/(Q-B),l=Math.tan(y);return S.FromValuesToRef(r,0,0,0,0,q,0,l,0,0,e,1,0,0,D,0,N),h&&N.multiplyToRef(s,N),N._updateIdentityStatus(!1),N}static PerspectiveFovLH(R,J,B,Q,h){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,N=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const r=new S;return S.PerspectiveFovLHToRef(R,J,B,Q,r,!0,h,y,N),r}static PerspectiveFovLHToRef(R,J,B,Q,h){let y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],N=arguments.length>6?arguments[6]:void 0,r=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,q=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const e=B,D=Q,l=1/Math.tan(.5*R),E=y?l/J:l,O=y?l:l*J,n=q&&0===e?-1:0!==D?(D+e)/(D-e):1,P=q&&0===e?2*D:0!==D?-2*D*e/(D-e):-2*e,A=Math.tan(r);return S.FromValuesToRef(E,0,0,0,0,O,0,A,0,0,n,1,0,0,P,0,h),N&&h.multiplyToRef(s,h),h._updateIdentityStatus(!1),h}static PerspectiveFovReverseLHToRef(R,J,B,Q,h){let y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],N=arguments.length>6?arguments[6]:void 0,r=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const q=1/Math.tan(.5*R),e=y?q/J:q,D=y?q:q*J,l=Math.tan(r);return S.FromValuesToRef(e,0,0,0,0,D,0,l,0,0,-B,1,0,0,1,0,h),N&&h.multiplyToRef(s,h),h._updateIdentityStatus(!1),h}static PerspectiveFovRH(R,J,B,Q,h){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,N=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const r=new S;return S.PerspectiveFovRHToRef(R,J,B,Q,r,!0,h,y,N),r}static PerspectiveFovRHToRef(R,J,B,Q,h){let y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],N=arguments.length>6?arguments[6]:void 0,r=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,q=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const e=B,D=Q,l=1/Math.tan(.5*R),E=y?l/J:l,O=y?l:l*J,n=q&&0===e?1:0!==D?-(D+e)/(D-e):-1,P=q&&0===e?2*D:0!==D?-2*D*e/(D-e):-2*e,A=Math.tan(r);return S.FromValuesToRef(E,0,0,0,0,O,0,A,0,0,n,-1,0,0,P,0,h),N&&h.multiplyToRef(s,h),h._updateIdentityStatus(!1),h}static PerspectiveFovReverseRHToRef(R,J,B,Q,h){let y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],N=arguments.length>6?arguments[6]:void 0,r=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const q=1/Math.tan(.5*R),e=y?q/J:q,D=y?q:q*J,l=Math.tan(r);return S.FromValuesToRef(e,0,0,0,0,D,0,l,0,0,-B,-1,0,0,-1,0,h),N&&h.multiplyToRef(s,h),h._updateIdentityStatus(!1),h}static GetFinalMatrix(R,J,B,Q,h,y){const N=R.width,r=R.height,q=R.x,e=R.y,D=S.FromValues(N/2,0,0,0,0,-r/2,0,0,0,0,y-h,0,q+N/2,r/2+e,h,1),l=new S;return J.multiplyToRef(B,l),l.multiplyToRef(Q,l),l.multiplyToRef(D,l)}static GetAsMatrix2x2(R){const J=R.m,B=[J[0],J[1],J[4],J[5]];return N.e.MatrixUse64Bits?B:new Float32Array(B)}static GetAsMatrix3x3(R){const J=R.m,B=[J[0],J[1],J[2],J[4],J[5],J[6],J[8],J[9],J[10]];return N.e.MatrixUse64Bits?B:new Float32Array(B)}static Transpose(R){const J=new S;return S.TransposeToRef(R,J),J}static TransposeToRef(R,J){const B=R.m,Q=B[0],h=B[4],y=B[8],N=B[12],r=B[1],q=B[5],e=B[9],D=B[13],l=B[2],E=B[6],O=B[10],n=B[14],P=B[3],A=B[7],u=B[11],S=B[15],f=J.nh;return f[0]=Q,f[1]=h,f[2]=y,f[3]=N,f[4]=r,f[5]=q,f[6]=e,f[7]=D,f[8]=l,f[9]=E,f[10]=O,f[11]=n,f[12]=P,f[13]=A,f[14]=u,f[15]=S,J.markAsUpdated(),J._updateIdentityStatus(R._isIdentity,R._isIdentityDirty),J}static Reflection(R){const J=new S;return S.ReflectionToRef(R,J),J}static ReflectionToRef(R,J){R.normalize();const B=R.normal.x,Q=R.normal.y,h=R.normal.z,y=-2*B,N=-2*Q,r=-2*h;return S.FromValuesToRef(y*B+1,N*B,r*B,0,y*Q,N*Q+1,r*Q,0,y*h,N*h,r*h+1,0,y*R.d,N*R.d,r*R.d,1,J),J}static FromXYZAxesToRef(R,J,B,Q){return S.FromValuesToRef(R._x,R._y,R._z,0,J._x,J._y,J._z,0,B._x,B._y,B._z,0,0,0,0,1,Q),Q}static FromQuaternionToRef(R,J){const B=R._x*R._x,Q=R._y*R._y,h=R._z*R._z,y=R._x*R._y,N=R._z*R._w,r=R._z*R._x,q=R._y*R._w,e=R._y*R._z,D=R._x*R._w;return J.nh[0]=1-2*(Q+h),J.nh[1]=2*(y+N),J.nh[2]=2*(r-q),J.nh[3]=0,J.nh[4]=2*(y-N),J.nh[5]=1-2*(h+B),J.nh[6]=2*(e+D),J.nh[7]=0,J.nh[8]=2*(r+q),J.nh[9]=2*(e-D),J.nh[10]=1-2*(Q+B),J.nh[11]=0,J.nh[12]=0,J.nh[13]=0,J.nh[14]=0,J.nh[15]=1,J.markAsUpdated(),J}}S._IdentityReadOnly=S.Identity(),Object.defineProperties(S.prototype,{dimension:{value:[4,4]},rank:{value:2}});class f{}f.nJ=(0,h.g)(11,P.Zero),f.Matrix=(0,h.g)(2,S.Identity),f.Quaternion=(0,h.g)(3,u.Zero);class a{}a.Vector2=(0,h.g)(3,n.Zero),a.nJ=(0,h.g)(13,P.Zero),a.Vector4=(0,h.g)(3,A.Zero),a.Quaternion=(0,h.g)(3,u.Zero),a.Matrix=(0,h.g)(8,S.Identity),(0,y.h)("BABYLON.Vector2",n),(0,y.h)("BABYLON.Vector3",P),(0,y.h)("BABYLON.Vector4",A),(0,y.h)("BABYLON.Matrix",S);const s=S.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11193:(R,J,B)=>{function Q(R,J){const B=[];for(let Q=0;Q<R;++Q)B.push(J());return B}function h(R,J){return Q(R,J)}B.d(J,{e:()=>Q,g:()=>h,h:()=>N});const y=["push","splice","pop","shift","unshift"];function N(R,J){const B=y.map((B=>function(R,J,B){const Q=R[J];if("function"!==typeof Q)return null;const h=function(){const Q=R.length,y=h.previous.apply(R,arguments);return B(J,Q),y};return Q.next=h,h.previous=Q,R[J]=h,()=>{const B=h.previous;if(!B)return;const Q=h.next;Q?(B.next=Q,Q.previous=B):(B.next=void 0,R[J]=B),h.next=void 0,h.previous=void 0}}(R,B,J)));return()=>{for(const R of B)null===R||void 0===R||R()}}}}]);