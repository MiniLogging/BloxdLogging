"use strict";(self["2fwzcez286e"]=self["2fwzcez286e"]||[]).push([[14],{12982:(B,u,F)=>{F.d(u,{e:()=>G,f:()=>p,i:()=>Z,m:()=>V});const Z=1/2.2,V=2.2,p=(1+Math.sqrt(5))/2,G=.001},12994:(B,u,F)=>{function Z(B){return parseInt(B.toString().replace(/\W/g,""))}function V(B,u){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(B-u)<=F}function p(B,u,F){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return B<u-Z||B>F+Z}function G(B,u){return B===u?B:Math.random()*(u-B)+B}function R(B,u,F){return B+(u-B)*F}function e(B,u,F){let Z=q(u-B,360);return Z>180&&(Z-=360),B+Z*t(F)}function s(B,u,F){let Z=0;return Z=B!=u?t((F-B)/(u-B)):0,Z}function Y(B,u,F,Z,V){const p=V*V,G=V*p;return B*(2*G-3*p+1)+F*(-2*G+3*p)+u*(G-2*p+V)+Z*(G-p)}function Q(B,u,F,Z,V){const p=V*V;return 6*(p-V)*B+(3*p-4*V+1)*u+6*(-p+V)*F+(3*p-2*V)*Z}function t(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(F,Math.max(u,B))}function v(B){return B-=2*Math.PI*Math.floor((B+Math.PI)/(2*Math.PI))}function D(B){const u=B.toString(16);return B<=15?("0"+u).toUpperCase():u.toUpperCase()}function L(B){if(Math.log2)return Math.floor(Math.log2(B));if(B<0)return NaN;if(0===B)return-1/0;let u=0;if(B<1){for(;B<1;)u++,B*=2;u=-u}else if(B>1)for(;B>1;)u++,B=Math.floor(B/2);return u}function q(B,u){return B-Math.floor(B/u)*u}function W(B,u,F){return(B-u)/(F-u)}function X(B,u,F){return B*(F-u)+u}function f(B,u){let F=q(u-B,360);return F>180&&(F-=360),F}function C(B,u){const F=q(B,2*u);return u-Math.abs(F-u)}function x(B,u,F){let Z=t(F);return Z=-2*Z*Z*Z+3*Z*Z,u*Z+B*(1-Z)}function U(B,u,F){let Z=0;return Z=Math.abs(u-B)<=F?u:B+Math.sign(u-B)*F,Z}function y(B,u,F){const Z=f(B,u);let V=0;return V=-F<Z&&Z<F?u:U(B,u=B+Z,F),V}function O(B,u,F){return(B-u)/(F-u)}function g(B,u,F){return(F-u)*B+u}function J(B,u){const F=B%u;return 0===F?u:J(u,F)}F.r(u),F.d(u,{Clamp:()=>t,DeltaAngle:()=>f,Denormalize:()=>X,ExtractAsInt:()=>Z,Hermite:()=>Y,Hermite1stDerivative:()=>Q,HighestCommonFactor:()=>J,ILog2:()=>L,InverseLerp:()=>s,Lerp:()=>R,LerpAngle:()=>e,MoveTowards:()=>U,MoveTowardsAngle:()=>y,Normalize:()=>W,NormalizeRadians:()=>v,OutsideRange:()=>p,PercentToRange:()=>g,PingPong:()=>C,RandomRange:()=>G,RangeToPercent:()=>O,Repeat:()=>q,SmoothStep:()=>x,ToHex:()=>D,WithinEpsilon:()=>V})},12979:(B,u,F)=>{F.r(u),F.d(u,{Matrix:()=>X,Quaternion:()=>W,TmpVectors:()=>C,Vector2:()=>D,Du:()=>L,Vector4:()=>q});var Z=F(12982),V=F(12985),p=F(12949),G=F(12917),R=F(12855),e=F(12994);class s{}function Y(B,u,F){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const V=B.DR(),p=u.DR(),G=V[0],R=V[1],e=V[2],s=V[3],Y=V[4],Q=V[5],t=V[6],v=V[7],D=V[8],L=V[9],q=V[10],W=V[11],X=V[12],f=V[13],C=V[14],x=V[15],U=p[0],y=p[1],O=p[2],g=p[3],J=p[4],a=p[5],T=p[6],z=p[7],M=p[8],j=p[9],o=p[10],I=p[11],mB=p[12],E=p[13],w=p[14],H=p[15];F[Z]=G*U+R*J+e*M+s*mB,F[Z+1]=G*y+R*a+e*j+s*E,F[Z+2]=G*O+R*T+e*o+s*w,F[Z+3]=G*g+R*z+e*I+s*H,F[Z+4]=Y*U+Q*J+t*M+v*mB,F[Z+5]=Y*y+Q*a+t*j+v*E,F[Z+6]=Y*O+Q*T+t*o+v*w,F[Z+7]=Y*g+Q*z+t*I+v*H,F[Z+8]=D*U+L*J+q*M+W*mB,F[Z+9]=D*y+L*a+q*j+W*E,F[Z+10]=D*O+L*T+q*o+W*w,F[Z+11]=D*g+L*z+q*I+W*H,F[Z+12]=X*U+f*J+C*M+x*mB,F[Z+13]=X*y+f*a+C*j+x*E,F[Z+14]=X*O+f*T+C*o+x*w,F[Z+15]=X*g+f*z+C*I+x*H}function Q(B,u){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const Z=B.DR();u[F]=Z[0],u[F+1]=Z[1],u[F+2]=Z[2],u[F+3]=Z[3],u[F+4]=Z[4],u[F+5]=Z[5],u[F+6]=Z[6],u[F+7]=Z[7],u[F+8]=Z[8],u[F+9]=Z[9],u[F+10]=Z[10],u[F+11]=Z[11],u[F+12]=Z[12],u[F+13]=Z[13],u[F+14]=Z[14],u[F+15]=Z[15]}function t(B,u){const F=B.DR(),Z=F[0],V=F[1],p=F[2],G=F[3],R=F[4],e=F[5],s=F[6],Y=F[7],Q=F[8],t=F[9],v=F[10],D=F[11],L=F[12],q=F[13],W=F[14],X=F[15],f=v*X-W*D,C=t*X-q*D,x=t*W-q*v,U=Q*X-L*D,y=Q*W-v*L,O=Q*q-L*t,g=+(e*f-s*C+Y*x),J=-(R*f-s*U+Y*y),a=+(R*C-e*U+Y*O),T=-(R*x-e*y+s*O),z=Z*g+V*J+p*a+G*T;if(0===z)return!1;const M=1/z,j=s*X-W*Y,o=e*X-q*Y,I=e*W-q*s,mB=R*X-L*Y,E=R*W-L*s,w=R*q-L*e,H=s*D-v*Y,n=e*D-t*Y,d=e*v-t*s,l=R*D-Q*Y,P=R*v-Q*s,c=R*t-Q*e,h=-(V*f-p*C+G*x),i=+(Z*f-p*U+G*y),r=-(Z*C-V*U+G*O),K=+(Z*x-V*y+p*O),N=+(V*j-p*o+G*I),A=-(Z*j-p*mB+G*E),b=+(Z*o-V*mB+G*w),k=-(Z*I-V*E+p*w),S=-(V*H-p*n+G*d),BB=+(Z*H-p*l+G*P),uB=-(Z*n-V*l+G*c),FB=+(Z*d-V*P+p*c);return u[0]=g*M,u[1]=h*M,u[2]=N*M,u[3]=S*M,u[4]=J*M,u[5]=i*M,u[6]=A*M,u[7]=BB*M,u[8]=a*M,u[9]=r*M,u[10]=b*M,u[11]=uB*M,u[12]=T*M,u[13]=K*M,u[14]=k*M,u[15]=FB*M,!0}s._UpdateFlagSeed=0;const v=B=>parseInt(B.toString().replace(/\W/g,""));class D{constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=B,this.y=u}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let B=v(this.x);return B=397*B^v(this.y),B}toArray(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[u]=this.x,B[u+1]=this.y,this}vF(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D.FromArrayToRef(B,u,this),this}DR(){return[this.x,this.y]}Z(B){return this.x=B.x,this.y=B.y,this}UR(B,u){return this.x=B,this.y=u,this}set(B,u){return this.UR(B,u)}OR(B){return this.UR(B,B)}add(B){return new D(this.x+B.x,this.y+B.y)}addToRef(B,u){return u.x=this.x+B.x,u.y=this.y+B.y,u}addInPlace(B){return this.x+=B.x,this.y+=B.y,this}addInPlaceFromFloats(B,u){return this.x+=B,this.y+=u,this}addVector3(B){return new D(this.x+B.x,this.y+B.y)}Lu(B){return new D(this.x-B.x,this.y-B.y)}subtractToRef(B,u){return u.x=this.x-B.x,u.y=this.y-B.y,u}yQ(B){return this.x-=B.x,this.y-=B.y,this}multiplyInPlace(B){return this.x*=B.x,this.y*=B.y,this}multiply(B){return new D(this.x*B.x,this.y*B.y)}multiplyToRef(B,u){return u.x=this.x*B.x,u.y=this.y*B.y,u}multiplyByFloats(B,u){return new D(this.x*B,this.y*u)}divide(B){return new D(this.x/B.x,this.y/B.y)}divideToRef(B,u){return u.x=this.x/B.x,u.y=this.y/B.y,u}divideInPlace(B){return this.x=this.x/B.x,this.y=this.y/B.y,this}minimizeInPlace(B){return this.minimizeInPlaceFromFloats(B.x,B.y)}maximizeInPlace(B){return this.maximizeInPlaceFromFloats(B.x,B.y)}minimizeInPlaceFromFloats(B,u){return this.x=Math.min(B,this.x),this.y=Math.min(u,this.y),this}maximizeInPlaceFromFloats(B,u){return this.x=Math.max(B,this.x),this.y=Math.max(u,this.y),this}subtractFromFloats(B,u){return new D(this.x-B,this.y-u)}subtractFromFloatsToRef(B,u,F){return F.x=this.x-B,F.y=this.y-u,F}negate(){return new D(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(B){return B.x=-this.x,B.y=-this.y,B}scaleInPlace(B){return this.x*=B,this.y*=B,this}scale(B){return new D(this.x*B,this.y*B)}scaleToRef(B,u){return u.x=this.x*B,u.y=this.y*B,u}scaleAndAddToRef(B,u){return u.x+=this.x*B,u.y+=this.y*B,u}equals(B){return B&&this.x===B.x&&this.y===B.y}equalsWithEpsilon(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.e;return B&&(0,e.WithinEpsilon)(this.x,B.x,u)&&(0,e.WithinEpsilon)(this.y,B.y,u)}equalsToFloats(B,u){return this.x===B&&this.y===u}floor(){return new D(Math.floor(this.x),Math.floor(this.y))}floorToRef(B){return B.x=Math.floor(this.x),B.y=Math.floor(this.y),B}fract(){return new D(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(B){return B.x=this.x-Math.floor(this.x),B.y=this.y-Math.floor(this.y),B}rotate(B){return this.rotateToRef(B,new D)}rotateToRef(B,u){const F=Math.cos(B),Z=Math.sin(B);return u.x=F*this.x-Z*this.y,u.y=Z*this.x+F*this.y,u}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){const B=new D;return this.normalizeToRef(B),B}normalizeToRef(B){const u=this.length();return 0===u&&(B.x=this.x,B.y=this.y),this.scaleToRef(1/u,B)}clone(){return new D(this.x,this.y)}dot(B){return this.x*B.x+this.y*B.y}static Zero(){return new D(0,0)}static One(){return new D(1,1)}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new D((0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).UR((0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u))}static get ZeroReadOnly(){return D._ZeroReadOnly}static fu(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new D(B[u],B[u+1])}static FromArrayToRef(B,u,F){return F.x=B[u],F.y=B[u+1],F}static FromFloatsToRef(B,u,F){return F.UR(B,u),F}static CatmullRom(B,u,F,Z,V){const p=V*V,G=V*p,R=.5*(2*u.x+(-B.x+F.x)*V+(2*B.x-5*u.x+4*F.x-Z.x)*p+(-B.x+3*u.x-3*F.x+Z.x)*G),e=.5*(2*u.y+(-B.y+F.y)*V+(2*B.y-5*u.y+4*F.y-Z.y)*p+(-B.y+3*u.y-3*F.y+Z.y)*G);return new D(R,e)}static ClampToRef(B,u,F,Z){return Z.x=(0,e.Clamp)(B.x,u.x,F.x),Z.y=(0,e.Clamp)(B.y,u.y,F.y),Z}static Clamp(B,u,F){const Z=(0,e.Clamp)(B.x,u.x,F.x),V=(0,e.Clamp)(B.y,u.y,F.y);return new D(Z,V)}static Hermite(B,u,F,Z,V){const p=V*V,G=V*p,R=2*G-3*p+1,e=-2*G+3*p,s=G-2*p+V,Y=G-p,Q=B.x*R+F.x*e+u.x*s+Z.x*Y,t=B.y*R+F.y*e+u.y*s+Z.y*Y;return new D(Q,t)}static Hermite1stDerivative(B,u,F,Z,V){return this.Hermite1stDerivativeToRef(B,u,F,Z,V,new D)}static Hermite1stDerivativeToRef(B,u,F,Z,V,p){const G=V*V;return p.x=6*(G-V)*B.x+(3*G-4*V+1)*u.x+6*(-G+V)*F.x+(3*G-2*V)*Z.x,p.y=6*(G-V)*B.y+(3*G-4*V+1)*u.y+6*(-G+V)*F.y+(3*G-2*V)*Z.y,p}static Lerp(B,u,F){return D.LerpToRef(B,u,F,new D)}static LerpToRef(B,u,F,Z){return Z.x=B.x+(u.x-B.x)*F,Z.y=B.y+(u.y-B.y)*F,Z}static Dot(B,u){return B.x*u.x+B.y*u.y}static Normalize(B){return D.NormalizeToRef(B,new D)}static NormalizeToRef(B,u){return B.normalizeToRef(u),u}static Minimize(B,u){const F=B.x<u.x?B.x:u.x,Z=B.y<u.y?B.y:u.y;return new D(F,Z)}static Maximize(B,u){const F=B.x>u.x?B.x:u.x,Z=B.y>u.y?B.y:u.y;return new D(F,Z)}static Transform(B,u){return D.TransformToRef(B,u,new D)}static TransformToRef(B,u,F){const Z=u.m,V=B.x*Z[0]+B.y*Z[4]+Z[12],p=B.x*Z[1]+B.y*Z[5]+Z[13];return F.x=V,F.y=p,F}static PointInTriangle(B,u,F,Z){const V=.5*(-F.y*Z.x+u.y*(-F.x+Z.x)+u.x*(F.y-Z.y)+F.x*Z.y),p=V<0?-1:1,G=(u.y*Z.x-u.x*Z.y+(Z.y-u.y)*B.x+(u.x-Z.x)*B.y)*p,R=(u.x*F.y-u.y*F.x+(u.y-F.y)*B.x+(F.x-u.x)*B.y)*p;return G>0&&R>0&&G+R<2*V*p}static Distance(B,u){return Math.sqrt(D.DistanceSquared(B,u))}static DistanceSquared(B,u){const F=B.x-u.x,Z=B.y-u.y;return F*F+Z*Z}static Center(B,u){return D.CenterToRef(B,u,new D)}static CenterToRef(B,u,F){return F.UR((B.x+u.x)/2,(B.y+u.y)/2)}static DistanceOfPointFromSegment(B,u,F){const Z=D.DistanceSquared(u,F);if(0===Z)return D.Distance(B,u);const V=F.Lu(u),p=Math.max(0,Math.min(1,D.Dot(B.Lu(u),V)/Z)),G=u.add(V.multiplyByFloats(p,p));return D.Distance(B,G)}}D._V8PerformanceHack=new D(.5,.5),D._ZeroReadOnly=D.Zero(),Object.defineProperties(D.prototype,{dimension:{value:[2]},rank:{value:1}});class L{get x(){return this._x}set x(B){this._x=B,this._isDirty=!0}get y(){return this._y}set y(B){this._y=B,this._isDirty=!0}get z(){return this._z}set z(B){this._z=B,this._isDirty=!0}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=B,this._y=u,this._z=F}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Du"}getHashCode(){let B=v(this._x);return B=397*B^v(this._y),B=397*B^v(this._z),B}DR(){return[this._x,this._y,this._z]}toArray(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[u]=this._x,B[u+1]=this._y,B[u+2]=this._z,this}vF(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(B,u,this),this}toQuaternion(){return W.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(B){return this._x+=B._x,this._y+=B._y,this._z+=B._z,this._isDirty=!0,this}addInPlaceFromFloats(B,u,F){return this._x+=B,this._y+=u,this._z+=F,this._isDirty=!0,this}add(B){return new L(this._x+B._x,this._y+B._y,this._z+B._z)}addToRef(B,u){return u._x=this._x+B._x,u._y=this._y+B._y,u._z=this._z+B._z,u._isDirty=!0,u}yQ(B){return this._x-=B._x,this._y-=B._y,this._z-=B._z,this._isDirty=!0,this}Lu(B){return new L(this._x-B._x,this._y-B._y,this._z-B._z)}subtractToRef(B,u){return this.subtractFromFloatsToRef(B._x,B._y,B._z,u)}subtractFromFloats(B,u,F){return new L(this._x-B,this._y-u,this._z-F)}subtractFromFloatsToRef(B,u,F,Z){return Z._x=this._x-B,Z._y=this._y-u,Z._z=this._z-F,Z._isDirty=!0,Z}negate(){return new L(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(B){return B._x=-1*this._x,B._y=-1*this._y,B._z=-1*this._z,B._isDirty=!0,B}scaleInPlace(B){return this._x*=B,this._y*=B,this._z*=B,this._isDirty=!0,this}scale(B){return new L(this._x*B,this._y*B,this._z*B)}scaleToRef(B,u){return u._x=this._x*B,u._y=this._y*B,u._z=this._z*B,u._isDirty=!0,u}getNormalToRef(B){const u=this.length();let F=Math.acos(this._y/u);const Z=Math.atan2(this._z,this._x);F>Math.PI/2?F-=Math.PI/2:F+=Math.PI/2;const V=u*Math.sin(F)*Math.cos(Z),p=u*Math.cos(F),G=u*Math.sin(F)*Math.sin(Z);return B.set(V,p,G),B}applyRotationQuaternionToRef(B,u){const F=this._x,Z=this._y,V=this._z,p=B._x,G=B._y,R=B._z,e=B._w,s=2*(G*V-R*Z),Y=2*(R*F-p*V),Q=2*(p*Z-G*F);return u._x=F+e*s+G*Q-R*Y,u._y=Z+e*Y+R*s-p*Q,u._z=V+e*Q+p*Y-G*s,u._isDirty=!0,u}applyRotationQuaternionInPlace(B){return this.applyRotationQuaternionToRef(B,this)}applyRotationQuaternion(B){return this.applyRotationQuaternionToRef(B,new L)}scaleAndAddToRef(B,u){return u._x+=this._x*B,u._y+=this._y*B,u._z+=this._z*B,u._isDirty=!0,u}projectOnPlane(B,u){return this.projectOnPlaneToRef(B,u,new L)}projectOnPlaneToRef(B,u,F){const Z=B.normal,V=B.d,p=f.Du[0];this.subtractToRef(u,p),p.normalize();const G=L.Dot(p,Z);if(Math.abs(G)<1e-10)F.OR(1/0);else{const B=-(L.Dot(u,Z)+V)/G,R=p.scaleInPlace(B);u.addToRef(R,F)}return F}equals(B){return B&&this._x===B._x&&this._y===B._y&&this._z===B._z}equalsWithEpsilon(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.e;return B&&(0,e.WithinEpsilon)(this._x,B._x,u)&&(0,e.WithinEpsilon)(this._y,B._y,u)&&(0,e.WithinEpsilon)(this._z,B._z,u)}equalsToFloats(B,u,F){return this._x===B&&this._y===u&&this._z===F}multiplyInPlace(B){return this._x*=B._x,this._y*=B._y,this._z*=B._z,this._isDirty=!0,this}multiply(B){return this.multiplyByFloats(B._x,B._y,B._z)}multiplyToRef(B,u){return u._x=this._x*B._x,u._y=this._y*B._y,u._z=this._z*B._z,u._isDirty=!0,u}multiplyByFloats(B,u,F){return new L(this._x*B,this._y*u,this._z*F)}divide(B){return new L(this._x/B._x,this._y/B._y,this._z/B._z)}divideToRef(B,u){return u._x=this._x/B._x,u._y=this._y/B._y,u._z=this._z/B._z,u._isDirty=!0,u}divideInPlace(B){return this._x=this._x/B._x,this._y=this._y/B._y,this._z=this._z/B._z,this._isDirty=!0,this}minimizeInPlace(B){return this.minimizeInPlaceFromFloats(B._x,B._y,B._z)}maximizeInPlace(B){return this.maximizeInPlaceFromFloats(B._x,B._y,B._z)}minimizeInPlaceFromFloats(B,u,F){return B<this._x&&(this.x=B),u<this._y&&(this.y=u),F<this._z&&(this.z=F),this}maximizeInPlaceFromFloats(B,u,F){return B>this._x&&(this.x=B),u>this._y&&(this.y=u),F>this._z&&(this.z=F),this}isNonUniformWithinEpsilon(B){const u=Math.abs(this._x),F=Math.abs(this._y);if(!(0,e.WithinEpsilon)(u,F,B))return!0;const Z=Math.abs(this._z);return!(0,e.WithinEpsilon)(u,Z,B)||!(0,e.WithinEpsilon)(F,Z,B)}get isNonUniform(){const B=Math.abs(this._x);if(B!==Math.abs(this._y))return!0;return B!==Math.abs(this._z)}floorToRef(B){return B._x=Math.floor(this._x),B._y=Math.floor(this._y),B._z=Math.floor(this._z),B._isDirty=!0,B}floor(){return new L(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(B){return B._x=this._x-Math.floor(this._x),B._y=this._y-Math.floor(this._y),B._z=this._z-Math.floor(this._z),B._isDirty=!0,B}fract(){return new L(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(B){if("xyz"===(B=B.toLowerCase()))return this;const u=f.Du[0].Z(this);return this.x=u[B[0]],this.y=u[B[1]],this.z=u[B[2]],this}rotateByQuaternionToRef(B,u){return B.toRotationMatrix(f.Matrix[0]),L.TransformCoordinatesToRef(this,f.Matrix[0],u),u}rotateByQuaternionAroundPointToRef(B,u,F){return this.subtractToRef(u,f.Du[0]),f.Du[0].rotateByQuaternionToRef(B,f.Du[0]),u.addToRef(f.Du[0],F),F}cross(B){return L.CrossToRef(this,B,new L)}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){return this.normalizeToRef(new L)}normalizeToRef(B){const u=this.length();return 0===u||1===u?(B._x=this._x,B._y=this._y,B._z=this._z,B._isDirty=!0,B):this.scaleToRef(1/u,B)}clone(){return new L(this._x,this._y,this._z)}Z(B){return this.UR(B._x,B._y,B._z)}UR(B,u,F){return this._x=B,this._y=u,this._z=F,this._isDirty=!0,this}set(B,u,F){return this.UR(B,u,F)}OR(B){return this._x=this._y=this._z=B,this._isDirty=!0,this}static GetClipFactor(B,u,F,Z){const V=L.Dot(B,F);return(V-Z)/(V-L.Dot(u,F))}static GetAngleBetweenVectors(B,u,F){const Z=B.normalizeToRef(f.Du[1]),V=u.normalizeToRef(f.Du[2]);let p=L.Dot(Z,V);p=(0,e.Clamp)(p,-1,1);const G=Math.acos(p),R=f.Du[3];return L.CrossToRef(Z,V,R),L.Dot(R,F)>0?isNaN(G)?0:G:isNaN(G)?-Math.PI:-Math.acos(p)}static GetAngleBetweenVectorsOnPlane(B,u,F){f.Du[0].Z(B);const Z=f.Du[0];f.Du[1].Z(u);const V=f.Du[1];f.Du[2].Z(F);const p=f.Du[2],G=f.Du[3],R=f.Du[4];Z.normalize(),V.normalize(),p.normalize(),L.CrossToRef(p,Z,G),L.CrossToRef(G,p,R);const s=Math.atan2(L.Dot(V,G),L.Dot(V,R));return(0,e.NormalizeRadians)(s)}static PitchYawRollToMoveBetweenPointsToRef(B,u,F){const Z=C.Du[0];return u.subtractToRef(B,Z),F._y=Math.atan2(Z.x,Z.z)||0,F._x=Math.atan2(Math.sqrt(Z.x**2+Z.z**2),Z.y)||0,F._z=0,F._isDirty=!0,F}static PitchYawRollToMoveBetweenPoints(B,u){const F=L.Zero();return L.PitchYawRollToMoveBetweenPointsToRef(B,u,F)}static SlerpToRef(B,u,F,V){F=(0,e.Clamp)(F,0,1);const p=f.Du[0],G=f.Du[1];p.Z(B);const R=p.length();p.normalizeFromLength(R),G.Z(u);const s=G.length();G.normalizeFromLength(s);const Y=L.Dot(p,G);let Q,t;if(Y<1-Z.e){const B=Math.acos(Y),u=1/Math.sin(B);Q=Math.sin((1-F)*B)*u,t=Math.sin(F*B)*u}else Q=1-F,t=F;return p.scaleInPlace(Q),G.scaleInPlace(t),V.Z(p).addInPlace(G),V.scaleInPlace((0,e.Lerp)(R,s,F)),V}static SmoothToRef(B,u,F,Z,V){return L.SlerpToRef(B,u,0===Z?1:F/Z,V),V}static fu(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new L(B[u],B[u+1],B[u+2])}static FromFloatArray(B,u){return L.fu(B,u)}static FromArrayToRef(B,u,F){return F._x=B[u],F._y=B[u+1],F._z=B[u+2],F._isDirty=!0,F}static FromFloatArrayToRef(B,u,F){return L.FromArrayToRef(B,u,F)}static FromFloatsToRef(B,u,F,Z){return Z.UR(B,u,F),Z}static Zero(){return new L(0,0,0)}static One(){return new L(1,1,1)}static Up(){return new L(0,1,0)}static get UpReadOnly(){return L._UpReadOnly}static get DownReadOnly(){return L._DownReadOnly}static get RightReadOnly(){return L._RightReadOnly}static get LeftReadOnly(){return L._LeftReadOnly}static get LeftHandedForwardReadOnly(){return L._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return L._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return L._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return L._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return L._ZeroReadOnly}static get OneReadOnly(){return L._OneReadOnly}static Down(){return new L(0,-1,0)}static Forward(){return new L(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new L(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new L(1,0,0)}static Left(){return new L(-1,0,0)}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new L((0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).UR((0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u))}static TransformCoordinates(B,u){const F=L.Zero();return L.TransformCoordinatesToRef(B,u,F),F}static TransformCoordinatesToRef(B,u,F){return L.TransformCoordinatesFromFloatsToRef(B._x,B._y,B._z,u,F),F}static TransformCoordinatesFromFloatsToRef(B,u,F,Z,V){const p=Z.m,G=B*p[0]+u*p[4]+F*p[8]+p[12],R=B*p[1]+u*p[5]+F*p[9]+p[13],e=B*p[2]+u*p[6]+F*p[10]+p[14],s=1/(B*p[3]+u*p[7]+F*p[11]+p[15]);return V._x=G*s,V._y=R*s,V._z=e*s,V._isDirty=!0,V}static TransformNormal(B,u){const F=L.Zero();return L.TransformNormalToRef(B,u,F),F}static TransformNormalToRef(B,u,F){return this.TransformNormalFromFloatsToRef(B._x,B._y,B._z,u,F),F}static TransformNormalFromFloatsToRef(B,u,F,Z,V){const p=Z.m;return V._x=B*p[0]+u*p[4]+F*p[8],V._y=B*p[1]+u*p[5]+F*p[9],V._z=B*p[2]+u*p[6]+F*p[10],V._isDirty=!0,V}static CatmullRom(B,u,F,Z,V){const p=V*V,G=V*p,R=.5*(2*u._x+(-B._x+F._x)*V+(2*B._x-5*u._x+4*F._x-Z._x)*p+(-B._x+3*u._x-3*F._x+Z._x)*G),e=.5*(2*u._y+(-B._y+F._y)*V+(2*B._y-5*u._y+4*F._y-Z._y)*p+(-B._y+3*u._y-3*F._y+Z._y)*G),s=.5*(2*u._z+(-B._z+F._z)*V+(2*B._z-5*u._z+4*F._z-Z._z)*p+(-B._z+3*u._z-3*F._z+Z._z)*G);return new L(R,e,s)}static Clamp(B,u,F){const Z=new L;return L.ClampToRef(B,u,F,Z),Z}static ClampToRef(B,u,F,Z){let V=B._x;V=V>F._x?F._x:V,V=V<u._x?u._x:V;let p=B._y;p=p>F._y?F._y:p,p=p<u._y?u._y:p;let G=B._z;return G=G>F._z?F._z:G,G=G<u._z?u._z:G,Z.UR(V,p,G),Z}static CheckExtends(B,u,F){u.minimizeInPlace(B),F.maximizeInPlace(B)}static Hermite(B,u,F,Z,V){const p=V*V,G=V*p,R=2*G-3*p+1,e=-2*G+3*p,s=G-2*p+V,Y=G-p,Q=B._x*R+F._x*e+u._x*s+Z._x*Y,t=B._y*R+F._y*e+u._y*s+Z._y*Y,v=B._z*R+F._z*e+u._z*s+Z._z*Y;return new L(Q,t,v)}static Hermite1stDerivative(B,u,F,Z,V){const p=new L;return this.Hermite1stDerivativeToRef(B,u,F,Z,V,p),p}static Hermite1stDerivativeToRef(B,u,F,Z,V,p){const G=V*V;return p._x=6*(G-V)*B._x+(3*G-4*V+1)*u._x+6*(-G+V)*F._x+(3*G-2*V)*Z._x,p._y=6*(G-V)*B._y+(3*G-4*V+1)*u._y+6*(-G+V)*F._y+(3*G-2*V)*Z._y,p._z=6*(G-V)*B._z+(3*G-4*V+1)*u._z+6*(-G+V)*F._z+(3*G-2*V)*Z._z,p._isDirty=!0,p}static Lerp(B,u,F){const Z=new L(0,0,0);return L.LerpToRef(B,u,F,Z),Z}static LerpToRef(B,u,F,Z){return Z._x=B._x+(u._x-B._x)*F,Z._y=B._y+(u._y-B._y)*F,Z._z=B._z+(u._z-B._z)*F,Z._isDirty=!0,Z}static Dot(B,u){return B._x*u._x+B._y*u._y+B._z*u._z}dot(B){return this._x*B._x+this._y*B._y+this._z*B._z}static Cross(B,u){const F=new L;return L.CrossToRef(B,u,F),F}static CrossToRef(B,u,F){const Z=B._y*u._z-B._z*u._y,V=B._z*u._x-B._x*u._z,p=B._x*u._y-B._y*u._x;return F.UR(Z,V,p),F}static Normalize(B){const u=L.Zero();return L.NormalizeToRef(B,u),u}static NormalizeToRef(B,u){return B.normalizeToRef(u),u}static Project(B,u,F,Z){const V=new L;return L.ProjectToRef(B,u,F,Z,V),V}static ProjectToRef(B,u,F,Z,V){var p;const G=Z.width,e=Z.height,s=Z.x,Y=Z.y,Q=f.Matrix[1],t=null===(p=R.b.LastCreatedEngine)||void 0===p?void 0:p.isNDCHalfZRange,v=t?1:.5,D=t?0:.5;X.FromValuesToRef(G/2,0,0,0,0,-e/2,0,0,0,0,v,0,s+G/2,e/2+Y,D,1,Q);const q=f.Matrix[0];return u.multiplyToRef(F,q),q.multiplyToRef(Q,q),L.TransformCoordinatesToRef(B,q,V),V}static Reflect(B,u){return this.ReflectToRef(B,u,new L)}static ReflectToRef(B,u,F){const Z=C.Du[0];return Z.Z(u).scaleInPlace(2*L.Dot(B,u)),F.Z(B).yQ(Z)}static _UnprojectFromInvertedMatrixToRef(B,u,F){L.TransformCoordinatesToRef(B,u,F);const Z=u.m,V=B._x*Z[3]+B._y*Z[7]+B._z*Z[11]+Z[15];return(0,e.WithinEpsilon)(V,1)&&F.scaleInPlace(1/V),F}static UnprojectFromTransform(B,u,F,Z,V){return this.Unproject(B,u,F,Z,V,X.IdentityReadOnly)}static Unproject(B,u,F,Z,V,p){const G=new L;return L.UnprojectToRef(B,u,F,Z,V,p,G),G}static UnprojectToRef(B,u,F,Z,V,p,G){return L.UnprojectFloatsToRef(B._x,B._y,B._z,u,F,Z,V,p,G),G}static UnprojectFloatsToRef(B,u,F,Z,V,p,G,e,s){var Y;const Q=f.Matrix[0];p.multiplyToRef(G,Q),Q.multiplyToRef(e,Q),Q.invert();const t=f.Du[0];return t.x=B/Z*2-1,t.y=-(u/V*2-1),null!==(Y=R.b.LastCreatedEngine)&&void 0!==Y&&Y.isNDCHalfZRange?t.z=F:t.z=2*F-1,L._UnprojectFromInvertedMatrixToRef(t,Q,s),s}static Minimize(B,u){const F=new L;return F.Z(B),F.minimizeInPlace(u),F}static Maximize(B,u){const F=new L;return F.Z(B),F.maximizeInPlace(u),F}static Distance(B,u){return Math.sqrt(L.DistanceSquared(B,u))}static DistanceSquared(B,u){const F=B._x-u._x,Z=B._y-u._y,V=B._z-u._z;return F*F+Z*Z+V*V}static ProjectOnTriangleToRef(B,u,F,V,p){const G=f.Du[0],R=f.Du[1],s=f.Du[2],Y=f.Du[3],Q=f.Du[4];F.subtractToRef(u,G),V.subtractToRef(u,R),V.subtractToRef(F,s);const t=G.length(),v=R.length(),D=s.length();if(t<Z.e||v<Z.e||D<Z.e)return p.Z(u),L.Distance(B,u);B.subtractToRef(u,Q),L.CrossToRef(G,R,Y);const q=Y.length();if(q<Z.e)return p.Z(u),L.Distance(B,u);Y.normalizeFromLength(q);let W=Q.length();if(W<Z.e)return p.Z(u),0;Q.normalizeFromLength(W);const X=L.Dot(Y,Q),C=f.Du[5],x=f.Du[6];C.Z(Y).scaleInPlace(-W*X),x.Z(B).addInPlace(C);const U=f.Du[4],y=f.Du[5],O=f.Du[7],g=f.Du[8];U.Z(G).scaleInPlace(1/t),g.Z(R).scaleInPlace(1/v),U.addInPlace(g).scaleInPlace(-1),y.Z(G).scaleInPlace(-1/t),g.Z(s).scaleInPlace(1/D),y.addInPlace(g).scaleInPlace(-1),O.Z(s).scaleInPlace(-1/D),g.Z(R).scaleInPlace(-1/v),O.addInPlace(g).scaleInPlace(-1);const J=f.Du[9];let a;J.Z(x).yQ(u),L.CrossToRef(U,J,g),a=L.Dot(g,Y);const T=a;J.Z(x).yQ(F),L.CrossToRef(y,J,g),a=L.Dot(g,Y);const z=a;J.Z(x).yQ(V),L.CrossToRef(O,J,g),a=L.Dot(g,Y);const M=a,j=f.Du[10];let o,I;T>0&&z<0?(j.Z(G),o=u,I=F):z>0&&M<0?(j.Z(s),o=F,I=V):(j.Z(R).scaleInPlace(-1),o=V,I=u);const mB=f.Du[9],E=f.Du[4];o.subtractToRef(x,g),I.subtractToRef(x,mB),L.CrossToRef(g,mB,E);if(!(L.Dot(E,Y)<0))return p.Z(x),Math.abs(W*X);const w=f.Du[5];L.CrossToRef(j,E,w),w.normalize();const H=f.Du[9];H.Z(o).yQ(x);const n=H.length();if(n<Z.e)return p.Z(o),L.Distance(B,o);H.normalizeFromLength(n);const d=L.Dot(w,H),l=f.Du[7];l.Z(x).addInPlace(w.scaleInPlace(n*d)),g.Z(l).yQ(o),W=j.length(),j.normalizeFromLength(W);let P=L.Dot(g,j)/Math.max(W,Z.e);return P=(0,e.Clamp)(P,0,1),l.Z(o).addInPlace(j.scaleInPlace(P*W)),p.Z(l),L.Distance(B,l)}static Center(B,u){return L.CenterToRef(B,u,L.Zero())}static CenterToRef(B,u,F){return F.UR((B._x+u._x)/2,(B._y+u._y)/2,(B._z+u._z)/2)}static RotationFromAxis(B,u,F){const Z=new L;return L.RotationFromAxisToRef(B,u,F,Z),Z}static RotationFromAxisToRef(B,u,F,Z){const V=f.Quaternion[0];return W.RotationQuaternionFromAxisToRef(B,u,F,V),V.toEulerAnglesToRef(Z),Z}}L._V8PerformanceHack=new L(.5,.5,.5),L._UpReadOnly=L.Up(),L._DownReadOnly=L.Down(),L._LeftHandedForwardReadOnly=L.Forward(!1),L._RightHandedForwardReadOnly=L.Forward(!0),L._LeftHandedBackwardReadOnly=L.Backward(!1),L._RightHandedBackwardReadOnly=L.Backward(!0),L._RightReadOnly=L.Right(),L._LeftReadOnly=L.Left(),L._ZeroReadOnly=L.Zero(),L._OneReadOnly=L.One(),Object.defineProperties(L.prototype,{dimension:{value:[3]},rank:{value:1}});class q{get x(){return this._x}set x(B){this._x=B,this._isDirty=!0}get y(){return this._y}set y(B){this._y=B,this._isDirty=!0}get z(){return this._z}set z(B){this._z=B,this._isDirty=!0}get w(){return this._w}set w(B){this._w=B,this._isDirty=!0}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=B,this._y=u,this._z=F,this._w=Z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let B=v(this._x);return B=397*B^v(this._y),B=397*B^v(this._z),B=397*B^v(this._w),B}DR(){return[this._x,this._y,this._z,this._w]}toArray(B,u){return void 0===u&&(u=0),B[u]=this._x,B[u+1]=this._y,B[u+2]=this._z,B[u+3]=this._w,this}vF(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q.FromArrayToRef(B,u,this),this}addInPlace(B){return this.x+=B._x,this.y+=B._y,this.z+=B._z,this.w+=B._w,this}addInPlaceFromFloats(B,u,F,Z){return this.x+=B,this.y+=u,this.z+=F,this.w+=Z,this}add(B){return new q(this._x+B.x,this._y+B.y,this._z+B.z,this._w+B.w)}addToRef(B,u){return u.x=this._x+B.x,u.y=this._y+B.y,u.z=this._z+B.z,u.w=this._w+B.w,u}yQ(B){return this.x-=B.x,this.y-=B.y,this.z-=B.z,this.w-=B.w,this}Lu(B){return new q(this._x-B.x,this._y-B.y,this._z-B.z,this._w-B.w)}subtractToRef(B,u){return u.x=this._x-B.x,u.y=this._y-B.y,u.z=this._z-B.z,u.w=this._w-B.w,u}subtractFromFloats(B,u,F,Z){return new q(this._x-B,this._y-u,this._z-F,this._w-Z)}subtractFromFloatsToRef(B,u,F,Z,V){return V.x=this._x-B,V.y=this._y-u,V.z=this._z-F,V.w=this._w-Z,V}negate(){return new q(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(B){return B.x=-this._x,B.y=-this._y,B.z=-this._z,B.w=-this._w,B}scaleInPlace(B){return this.x*=B,this.y*=B,this.z*=B,this.w*=B,this}scale(B){return new q(this._x*B,this._y*B,this._z*B,this._w*B)}scaleToRef(B,u){return u.x=this._x*B,u.y=this._y*B,u.z=this._z*B,u.w=this._w*B,u}scaleAndAddToRef(B,u){return u.x+=this._x*B,u.y+=this._y*B,u.z+=this._z*B,u.w+=this._w*B,u}equals(B){return B&&this._x===B.x&&this._y===B.y&&this._z===B.z&&this._w===B.w}equalsWithEpsilon(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.e;return B&&(0,e.WithinEpsilon)(this._x,B.x,u)&&(0,e.WithinEpsilon)(this._y,B.y,u)&&(0,e.WithinEpsilon)(this._z,B.z,u)&&(0,e.WithinEpsilon)(this._w,B.w,u)}equalsToFloats(B,u,F,Z){return this._x===B&&this._y===u&&this._z===F&&this._w===Z}multiplyInPlace(B){return this.x*=B.x,this.y*=B.y,this.z*=B.z,this.w*=B.w,this}multiply(B){return new q(this._x*B.x,this._y*B.y,this._z*B.z,this._w*B.w)}multiplyToRef(B,u){return u.x=this._x*B.x,u.y=this._y*B.y,u.z=this._z*B.z,u.w=this._w*B.w,u}multiplyByFloats(B,u,F,Z){return new q(this._x*B,this._y*u,this._z*F,this._w*Z)}divide(B){return new q(this._x/B.x,this._y/B.y,this._z/B.z,this._w/B.w)}divideToRef(B,u){return u.x=this._x/B.x,u.y=this._y/B.y,u.z=this._z/B.z,u.w=this._w/B.w,u}divideInPlace(B){return this.divideToRef(B,this)}minimizeInPlace(B){return B.x<this._x&&(this.x=B.x),B.y<this._y&&(this.y=B.y),B.z<this._z&&(this.z=B.z),B.w<this._w&&(this.w=B.w),this}maximizeInPlace(B){return B.x>this._x&&(this.x=B.x),B.y>this._y&&(this.y=B.y),B.z>this._z&&(this.z=B.z),B.w>this._w&&(this.w=B.w),this}minimizeInPlaceFromFloats(B,u,F,Z){return this.x=Math.min(B,this._x),this.y=Math.min(u,this._y),this.z=Math.min(F,this._z),this.w=Math.min(Z,this._w),this}maximizeInPlaceFromFloats(B,u,F,Z){return this.x=Math.max(B,this._x),this.y=Math.max(u,this._y),this.z=Math.max(F,this._z),this.w=Math.max(Z,this._w),this}floorToRef(B){return B.x=Math.floor(this._x),B.y=Math.floor(this._y),B.z=Math.floor(this._z),B.w=Math.floor(this._w),B}floor(){return new q(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(B){return B.x=this._x-Math.floor(this._x),B.y=this._y-Math.floor(this._y),B.z=this._z-Math.floor(this._z),B.w=this._w-Math.floor(this._w),B}fract(){return new q(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){return this.normalizeToRef(new q)}normalizeToRef(B){const u=this.length();return 0===u||1===u?(B.x=this._x,B.y=this._y,B.z=this._z,B.w=this._w,B):this.scaleToRef(1/u,B)}toVector3(){return new L(this._x,this._y,this._z)}clone(){return new q(this._x,this._y,this._z,this._w)}Z(B){return this.x=B.x,this.y=B.y,this.z=B.z,this.w=B.w,this}UR(B,u,F,Z){return this.x=B,this.y=u,this.z=F,this.w=Z,this}set(B,u,F,Z){return this.UR(B,u,F,Z)}OR(B){return this.x=this.y=this.z=this.w=B,this}dot(B){return this._x*B.x+this._y*B.y+this._z*B.z+this._w*B.w}static fu(B,u){return u||(u=0),new q(B[u],B[u+1],B[u+2],B[u+3])}static FromArrayToRef(B,u,F){return F.x=B[u],F.y=B[u+1],F.z=B[u+2],F.w=B[u+3],F}static FromFloatArrayToRef(B,u,F){return q.FromArrayToRef(B,u,F),F}static FromFloatsToRef(B,u,F,Z,V){return V.x=B,V.y=u,V.z=F,V.w=Z,V}static Zero(){return new q(0,0,0,0)}static One(){return new q(1,1,1,1)}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new q((0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0;return F.x=(0,e.RandomRange)(B,u),F.y=(0,e.RandomRange)(B,u),F.z=(0,e.RandomRange)(B,u),F.w=(0,e.RandomRange)(B,u),F}static Clamp(B,u,F){return q.ClampToRef(B,u,F,new q)}static ClampToRef(B,u,F,Z){return Z.x=(0,e.Clamp)(B.x,u.x,F.x),Z.y=(0,e.Clamp)(B.y,u.y,F.y),Z.z=(0,e.Clamp)(B.z,u.z,F.z),Z.w=(0,e.Clamp)(B.w,u.w,F.w),Z}static CheckExtends(B,u,F){u.minimizeInPlace(B),F.maximizeInPlace(B)}static get ZeroReadOnly(){return q._ZeroReadOnly}static Normalize(B){return q.NormalizeToRef(B,new q)}static NormalizeToRef(B,u){return B.normalizeToRef(u),u}static Minimize(B,u){const F=new q;return F.Z(B),F.minimizeInPlace(u),F}static Maximize(B,u){const F=new q;return F.Z(B),F.maximizeInPlace(u),F}static Distance(B,u){return Math.sqrt(q.DistanceSquared(B,u))}static DistanceSquared(B,u){const F=B.x-u.x,Z=B.y-u.y,V=B.z-u.z,p=B.w-u.w;return F*F+Z*Z+V*V+p*p}static Center(B,u){return q.CenterToRef(B,u,new q)}static CenterToRef(B,u,F){return F.x=(B.x+u.x)/2,F.y=(B.y+u.y)/2,F.z=(B.z+u.z)/2,F.w=(B.w+u.w)/2,F}static TransformCoordinates(B,u){return q.TransformCoordinatesToRef(B,u,new q)}static TransformCoordinatesToRef(B,u,F){return q.TransformCoordinatesFromFloatsToRef(B._x,B._y,B._z,u,F),F}static TransformCoordinatesFromFloatsToRef(B,u,F,Z,V){const p=Z.m,G=B*p[0]+u*p[4]+F*p[8]+p[12],R=B*p[1]+u*p[5]+F*p[9]+p[13],e=B*p[2]+u*p[6]+F*p[10]+p[14],s=B*p[3]+u*p[7]+F*p[11]+p[15];return V.x=G,V.y=R,V.z=e,V.w=s,V}static TransformNormal(B,u){return q.TransformNormalToRef(B,u,new q)}static TransformNormalToRef(B,u,F){const Z=u.m,V=B.x*Z[0]+B.y*Z[4]+B.z*Z[8],p=B.x*Z[1]+B.y*Z[5]+B.z*Z[9],G=B.x*Z[2]+B.y*Z[6]+B.z*Z[10];return F.x=V,F.y=p,F.z=G,F.w=B.w,F}static TransformNormalFromFloatsToRef(B,u,F,Z,V,p){const G=V.m;return p.x=B*G[0]+u*G[4]+F*G[8],p.y=B*G[1]+u*G[5]+F*G[9],p.z=B*G[2]+u*G[6]+F*G[10],p.w=Z,p}static FromVector3(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new q(B._x,B._y,B._z,u)}static Dot(B,u){return B.x*u.x+B.y*u.y+B.z*u.z+B.w*u.w}}q._V8PerformanceHack=new q(.5,.5,.5,.5),q._ZeroReadOnly=q.Zero(),Object.defineProperties(q.prototype,{dimension:{value:[4]},rank:{value:1}});class W{get x(){return this._x}set x(B){this._x=B,this._isDirty=!0}get y(){return this._y}set y(B){this._y=B,this._isDirty=!0}get z(){return this._z}set z(B){this._z=B,this._isDirty=!0}get w(){return this._w}set w(B){this._w=B,this._isDirty=!0}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=B,this._y=u,this._z=F,this._w=Z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let B=v(this._x);return B=397*B^v(this._y),B=397*B^v(this._z),B=397*B^v(this._w),B}DR(){return[this._x,this._y,this._z,this._w]}toArray(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[u]=this._x,B[u+1]=this._y,B[u+2]=this._z,B[u+3]=this._w,this}vF(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return W.FromArrayToRef(B,u,this)}equals(B){return B&&this._x===B._x&&this._y===B._y&&this._z===B._z&&this._w===B._w}equalsWithEpsilon(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.e;return B&&(0,e.WithinEpsilon)(this._x,B._x,u)&&(0,e.WithinEpsilon)(this._y,B._y,u)&&(0,e.WithinEpsilon)(this._z,B._z,u)&&(0,e.WithinEpsilon)(this._w,B._w,u)}isApprox(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.e;return B&&((0,e.WithinEpsilon)(this._x,B._x,u)&&(0,e.WithinEpsilon)(this._y,B._y,u)&&(0,e.WithinEpsilon)(this._z,B._z,u)&&(0,e.WithinEpsilon)(this._w,B._w,u)||(0,e.WithinEpsilon)(this._x,-B._x,u)&&(0,e.WithinEpsilon)(this._y,-B._y,u)&&(0,e.WithinEpsilon)(this._z,-B._z,u)&&(0,e.WithinEpsilon)(this._w,-B._w,u))}clone(){return new W(this._x,this._y,this._z,this._w)}Z(B){return this._x=B._x,this._y=B._y,this._z=B._z,this._w=B._w,this._isDirty=!0,this}UR(B,u,F,Z){return this._x=B,this._y=u,this._z=F,this._w=Z,this._isDirty=!0,this}set(B,u,F,Z){return this.UR(B,u,F,Z)}OR(B){return this.UR(B,B,B,B)}add(B){return new W(this._x+B._x,this._y+B._y,this._z+B._z,this._w+B._w)}addInPlace(B){return this._x+=B._x,this._y+=B._y,this._z+=B._z,this._w+=B._w,this._isDirty=!0,this}addToRef(B,u){return u._x=this._x+B._x,u._y=this._y+B._y,u._z=this._z+B._z,u._w=this._w+B._w,u._isDirty=!0,u}addInPlaceFromFloats(B,u,F,Z){return this._x+=B,this._y+=u,this._z+=F,this._w+=Z,this._isDirty=!0,this}subtractToRef(B,u){return u._x=this._x-B._x,u._y=this._y-B._y,u._z=this._z-B._z,u._w=this._w-B._w,u._isDirty=!0,u}subtractFromFloats(B,u,F,Z){return this.subtractFromFloatsToRef(B,u,F,Z,new W)}subtractFromFloatsToRef(B,u,F,Z,V){return V._x=this._x-B,V._y=this._y-u,V._z=this._z-F,V._w=this._w-Z,V._isDirty=!0,V}Lu(B){return new W(this._x-B._x,this._y-B._y,this._z-B._z,this._w-B._w)}yQ(B){return this._x-=B._x,this._y-=B._y,this._z-=B._z,this._w-=B._w,this._isDirty=!0,this}scale(B){return new W(this._x*B,this._y*B,this._z*B,this._w*B)}scaleToRef(B,u){return u._x=this._x*B,u._y=this._y*B,u._z=this._z*B,u._w=this._w*B,u._isDirty=!0,u}scaleInPlace(B){return this._x*=B,this._y*=B,this._z*=B,this._w*=B,this._isDirty=!0,this}scaleAndAddToRef(B,u){return u._x+=this._x*B,u._y+=this._y*B,u._z+=this._z*B,u._w+=this._w*B,u._isDirty=!0,u}multiply(B){const u=new W(0,0,0,1);return this.multiplyToRef(B,u),u}multiplyToRef(B,u){const F=this._x*B._w+this._y*B._z-this._z*B._y+this._w*B._x,Z=-this._x*B._z+this._y*B._w+this._z*B._x+this._w*B._y,V=this._x*B._y-this._y*B._x+this._z*B._w+this._w*B._z,p=-this._x*B._x-this._y*B._y-this._z*B._z+this._w*B._w;return u.UR(F,Z,V,p),u}multiplyInPlace(B){return this.multiplyToRef(B,this)}multiplyByFloats(B,u,F,Z){return this._x*=B,this._y*=u,this._z*=F,this._w*=Z,this._isDirty=!0,this}divide(B){throw new ReferenceError("Can not divide a quaternion")}divideToRef(B,u){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(B){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new W)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(B){return B._x=-this._x,B._y=-this._y,B._z=-this._z,B._w=-this._w,B._isDirty=!0,B}equalsToFloats(B,u,F,Z){return this._x===B&&this._y===u&&this._z===F&&this._w===Z}floorToRef(B){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(B){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(B){return B.UR(-this._x,-this._y,-this._z,this._w),B}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new W(-this._x,-this._y,-this._z,this._w)}invert(){const B=this.conjugate(),u=this.lengthSquared();return 0==u||1==u||B.scaleInPlace(1/u),B}invertInPlace(){this.conjugateInPlace();const B=this.lengthSquared();return 0==B||1==B||this.scaleInPlace(1/B),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(B){return 0===B||1===B?this:this.scaleInPlace(1/B)}normalizeToNew(){const B=new W(0,0,0,1);return this.normalizeToRef(B),B}normalizeToRef(B){const u=this.length();return 0===u||1===u?B.UR(this._x,this._y,this._z,this._w):this.scaleToRef(1/u,B)}toEulerAngles(){const B=L.Zero();return this.toEulerAnglesToRef(B),B}toEulerAnglesToRef(B){const u=this._z,F=this._x,Z=this._y,V=this._w,p=Z*u-F*V,G=.4999999;if(p<-G)B._y=2*Math.atan2(Z,V),B._x=Math.PI/2,B._z=0,B._isDirty=!0;else if(p>G)B._y=2*Math.atan2(Z,V),B._x=-Math.PI/2,B._z=0,B._isDirty=!0;else{const G=V*V,R=u*u,e=F*F,s=Z*Z;B._z=Math.atan2(2*(F*Z+u*V),-R-e+s+G),B._x=Math.asin(-2*p),B._y=Math.atan2(2*(u*F+Z*V),R-e-s+G),B._isDirty=!0}return B}toAlphaBetaGammaToRef(B){const u=this._z,F=this._x,Z=this._y,V=this._w,p=Math.sqrt(F*F+Z*Z),G=Math.sqrt(u*u+V*V),R=2*Math.atan2(p,G),e=2*Math.atan2(u,V),s=2*Math.atan2(Z,F),Y=(e+s)/2,Q=(e-s)/2;return B.set(Q,R,Y),B}toRotationMatrix(B){return X.FromQuaternionToRef(this,B),B}fromRotationMatrix(B){return W.FromRotationMatrixToRef(B,this),this}dot(B){return this._x*B._x+this._y*B._y+this._z*B._z+this._w*B._w}toAxisAngle(){const B=L.Zero();return{axis:B,angle:this.toAxisAngleToRef(B)}}toAxisAngleToRef(B){let u=0;const F=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),Z=this._w;return F>0?(u=2*Math.atan2(F,Z),B.set(this._x/F,this._y/F,this._z/F)):(u=0,B.set(1,0,0)),u}static FromRotationMatrix(B){const u=new W;return W.FromRotationMatrixToRef(B,u),u}static FromRotationMatrixToRef(B,u){const F=B.m,Z=F[0],V=F[4],p=F[8],G=F[1],R=F[5],e=F[9],s=F[2],Y=F[6],Q=F[10],t=Z+R+Q;let v;return t>0?(v=.5/Math.sqrt(t+1),u._w=.25/v,u._x=(Y-e)*v,u._y=(p-s)*v,u._z=(G-V)*v,u._isDirty=!0):Z>R&&Z>Q?(v=2*Math.sqrt(1+Z-R-Q),u._w=(Y-e)/v,u._x=.25*v,u._y=(V+G)/v,u._z=(p+s)/v,u._isDirty=!0):R>Q?(v=2*Math.sqrt(1+R-Z-Q),u._w=(p-s)/v,u._x=(V+G)/v,u._y=.25*v,u._z=(e+Y)/v,u._isDirty=!0):(v=2*Math.sqrt(1+Q-Z-R),u._w=(G-V)/v,u._x=(p+s)/v,u._y=(e+Y)/v,u._z=.25*v,u._isDirty=!0),u}static Dot(B,u){return B._x*u._x+B._y*u._y+B._z*u._z+B._w*u._w}static AreClose(B,u){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const Z=W.Dot(B,u);return 1-Z*Z<=F}static SmoothToRef(B,u,F,Z,V){let p=0===Z?1:F/Z;return p=(0,e.Clamp)(p,0,1),W.SlerpToRef(B,u,p,V),V}static Zero(){return new W(0,0,0,0)}static Inverse(B){return new W(-B._x,-B._y,-B._z,B._w)}static InverseToRef(B,u){return u.set(-B._x,-B._y,-B._z,B._w),u}static Identity(){return new W(0,0,0,1)}static IsIdentity(B){return B&&0===B._x&&0===B._y&&0===B._z&&1===B._w}static RotationAxis(B,u){return W.RotationAxisToRef(B,u,new W)}static RotationAxisToRef(B,u,F){F._w=Math.cos(u/2);const Z=Math.sin(u/2)/B.length();return F._x=B._x*Z,F._y=B._y*Z,F._z=B._z*Z,F._isDirty=!0,F}static fu(B,u){return u||(u=0),new W(B[u],B[u+1],B[u+2],B[u+3])}static FromArrayToRef(B,u,F){return F._x=B[u],F._y=B[u+1],F._z=B[u+2],F._w=B[u+3],F._isDirty=!0,F}static FromFloatsToRef(B,u,F,Z,V){return V.UR(B,u,F,Z),V}static FromEulerAngles(B,u,F){const Z=new W;return W.RotationYawPitchRollToRef(u,B,F,Z),Z}static FromEulerAnglesToRef(B,u,F,Z){return W.RotationYawPitchRollToRef(u,B,F,Z),Z}static FromEulerVector(B){const u=new W;return W.RotationYawPitchRollToRef(B._y,B._x,B._z,u),u}static FromEulerVectorToRef(B,u){return W.RotationYawPitchRollToRef(B._y,B._x,B._z,u),u}static FromUnitVectorsToRef(B,u,F){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Z.e;const p=L.Dot(B,u)+1;return p<V?Math.abs(B.x)>Math.abs(B.z)?F.set(-B.y,B.x,0,0):F.set(0,-B.z,B.y,0):(L.CrossToRef(B,u,C.Du[0]),F.set(C.Du[0].x,C.Du[0].y,C.Du[0].z,p)),F.normalize()}static RotationYawPitchRoll(B,u,F){const Z=new W;return W.RotationYawPitchRollToRef(B,u,F,Z),Z}static RotationYawPitchRollToRef(B,u,F,Z){const V=.5*F,p=.5*u,G=.5*B,R=Math.sin(V),e=Math.cos(V),s=Math.sin(p),Y=Math.cos(p),Q=Math.sin(G),t=Math.cos(G);return Z._x=t*s*e+Q*Y*R,Z._y=Q*Y*e-t*s*R,Z._z=t*Y*R-Q*s*e,Z._w=t*Y*e+Q*s*R,Z._isDirty=!0,Z}static RotationAlphaBetaGamma(B,u,F){const Z=new W;return W.RotationAlphaBetaGammaToRef(B,u,F,Z),Z}static RotationAlphaBetaGammaToRef(B,u,F,Z){const V=.5*(F+B),p=.5*(F-B),G=.5*u;return Z._x=Math.cos(p)*Math.sin(G),Z._y=Math.sin(p)*Math.sin(G),Z._z=Math.sin(V)*Math.cos(G),Z._w=Math.cos(V)*Math.cos(G),Z._isDirty=!0,Z}static RotationQuaternionFromAxis(B,u,F){const Z=new W(0,0,0,0);return W.RotationQuaternionFromAxisToRef(B,u,F,Z),Z}static RotationQuaternionFromAxisToRef(B,u,F,Z){const V=f.Matrix[0];return B=B.normalizeToRef(f.Du[0]),u=u.normalizeToRef(f.Du[1]),F=F.normalizeToRef(f.Du[2]),X.FromXYZAxesToRef(B,u,F,V),W.FromRotationMatrixToRef(V,Z),Z}static FromLookDirectionLH(B,u){const F=new W;return W.FromLookDirectionLHToRef(B,u,F),F}static FromLookDirectionLHToRef(B,u,F){const Z=f.Matrix[0];return X.LookDirectionLHToRef(B,u,Z),W.FromRotationMatrixToRef(Z,F),F}static FromLookDirectionRH(B,u){const F=new W;return W.FromLookDirectionRHToRef(B,u,F),F}static FromLookDirectionRHToRef(B,u,F){const Z=f.Matrix[0];return X.LookDirectionRHToRef(B,u,Z),W.FromRotationMatrixToRef(Z,F)}static Slerp(B,u,F){const Z=W.Identity();return W.SlerpToRef(B,u,F,Z),Z}static SlerpToRef(B,u,F,Z){let V,p,G=B._x*u._x+B._y*u._y+B._z*u._z+B._w*u._w,R=!1;if(G<0&&(R=!0,G=-G),G>.999999)p=1-F,V=R?-F:F;else{const B=Math.acos(G),u=1/Math.sin(B);p=Math.sin((1-F)*B)*u,V=R?-Math.sin(F*B)*u:Math.sin(F*B)*u}return Z._x=p*B._x+V*u._x,Z._y=p*B._y+V*u._y,Z._z=p*B._z+V*u._z,Z._w=p*B._w+V*u._w,Z._isDirty=!0,Z}static Hermite(B,u,F,Z,V){const p=V*V,G=V*p,R=2*G-3*p+1,e=-2*G+3*p,s=G-2*p+V,Y=G-p,Q=B._x*R+F._x*e+u._x*s+Z._x*Y,t=B._y*R+F._y*e+u._y*s+Z._y*Y,v=B._z*R+F._z*e+u._z*s+Z._z*Y,D=B._w*R+F._w*e+u._w*s+Z._w*Y;return new W(Q,t,v,D)}static Hermite1stDerivative(B,u,F,Z,V){const p=new W;return this.Hermite1stDerivativeToRef(B,u,F,Z,V,p),p}static Hermite1stDerivativeToRef(B,u,F,Z,V,p){const G=V*V;return p._x=6*(G-V)*B._x+(3*G-4*V+1)*u._x+6*(-G+V)*F._x+(3*G-2*V)*Z._x,p._y=6*(G-V)*B._y+(3*G-4*V+1)*u._y+6*(-G+V)*F._y+(3*G-2*V)*Z._y,p._z=6*(G-V)*B._z+(3*G-4*V+1)*u._z+6*(-G+V)*F._z+(3*G-2*V)*Z._z,p._w=6*(G-V)*B._w+(3*G-4*V+1)*u._w+6*(-G+V)*F._w+(3*G-2*V)*Z._w,p._isDirty=!0,p}static Normalize(B){const u=W.Zero();return W.NormalizeToRef(B,u),u}static NormalizeToRef(B,u){return B.normalizeToRef(u),u}static Clamp(B,u,F){const Z=new W;return W.ClampToRef(B,u,F,Z),Z}static ClampToRef(B,u,F,Z){return Z.UR((0,e.Clamp)(B.x,u.x,F.x),(0,e.Clamp)(B.y,u.y,F.y),(0,e.Clamp)(B.z,u.z,F.z),(0,e.Clamp)(B.w,u.w,F.w))}static Random(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new W((0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u))}static RandomToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).UR((0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u),(0,e.RandomRange)(B,u))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(B,u){return Math.sqrt(W.DistanceSquared(B,u))}static DistanceSquared(B,u){const F=B.x-u.x,Z=B.y-u.y,V=B.z-u.z,p=B.w-u.w;return F*F+Z*Z+V*V+p*p}static Center(B,u){return W.CenterToRef(B,u,W.Zero())}static CenterToRef(B,u,F){return F.UR((B.x+u.x)/2,(B.y+u.y)/2,(B.z+u.z)/2,(B.w+u.w)/2)}}W._V8PerformanceHack=new W(.5,.5,.5,.5),Object.defineProperties(W.prototype,{dimension:{value:[4]},rank:{value:1}});class X{static get Use64Bits(){return G.e.MatrixUse64Bits}get m(){return this.eR}markAsUpdated(){this.updateFlag=s._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(B){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1],F=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Z=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=B,this._isIdentity3x2=B||F,this._isIdentityDirty=!this._isIdentity&&u,this._isIdentity3x2Dirty=!this._isIdentity3x2&&Z}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,G.e.MatrixTrackPrecisionChange&&G.e.MatrixTrackedMatrices.push(this),this.eR=new G.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const B=this.eR;this._isIdentity=1===B[0]&&0===B[1]&&0===B[2]&&0===B[3]&&0===B[4]&&1===B[5]&&0===B[6]&&0===B[7]&&0===B[8]&&0===B[9]&&1===B[10]&&0===B[11]&&0===B[12]&&0===B[13]&&0===B[14]&&1===B[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.eR[0]||1!==this.eR[5]||1!==this.eR[15]||0!==this.eR[1]||0!==this.eR[2]||0!==this.eR[3]||0!==this.eR[4]||0!==this.eR[6]||0!==this.eR[7]||0!==this.eR[8]||0!==this.eR[9]||0!==this.eR[10]||0!==this.eR[11]||0!==this.eR[12]||0!==this.eR[13]||0!==this.eR[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const B=this.eR,u=B[0],F=B[1],Z=B[2],V=B[3],p=B[4],G=B[5],R=B[6],e=B[7],s=B[8],Y=B[9],Q=B[10],t=B[11],v=B[12],D=B[13],L=B[14],q=B[15],W=Q*q-L*t,X=Y*q-D*t,f=Y*L-D*Q,C=s*q-v*t,x=s*L-Q*v,U=s*D-v*Y;return u*+(G*W-R*X+e*f)+F*-(p*W-R*C+e*x)+Z*+(p*X-G*C+e*U)+V*-(p*f-G*x+R*U)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!B)return this.eR;const F=this.eR;for(let Z=0;Z<16;Z++)B[u+Z]=F[Z];return this}DR(){return this.eR}vF(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return X.FromArrayToRef(B,u,this)}UR(){for(var B=arguments.length,u=new Array(B),F=0;F<B;F++)u[F]=arguments[F];return X.FromArrayToRef(u,0,this)}set(){const B=this.eR;for(let u=0;u<16;u++)B[u]=u<0||arguments.length<=u?void 0:arguments[u];return this.markAsUpdated(),this}OR(B){const u=this.eR;for(let F=0;F<16;F++)u[F]=B;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return X.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(B){const u=new X;return this.addToRef(B,u),u}addToRef(B,u){const F=this.eR,Z=u.eR,V=B.m;for(let p=0;p<16;p++)Z[p]=F[p]+V[p];return u.markAsUpdated(),u}addToSelf(B){const u=this.eR,F=B.m;return u[0]+=F[0],u[1]+=F[1],u[2]+=F[2],u[3]+=F[3],u[4]+=F[4],u[5]+=F[5],u[6]+=F[6],u[7]+=F[7],u[8]+=F[8],u[9]+=F[9],u[10]+=F[10],u[11]+=F[11],u[12]+=F[12],u[13]+=F[13],u[14]+=F[14],u[15]+=F[15],this.markAsUpdated(),this}addInPlace(B){const u=this.eR,F=B.m;for(let Z=0;Z<16;Z++)u[Z]+=F[Z];return this.markAsUpdated(),this}addInPlaceFromFloats(){const B=this.eR;for(let u=0;u<16;u++)B[u]+=u<0||arguments.length<=u?void 0:arguments[u];return this.markAsUpdated(),this}Lu(B){const u=this.eR,F=B.m;for(let Z=0;Z<16;Z++)u[Z]-=F[Z];return this.markAsUpdated(),this}subtractToRef(B,u){const F=this.eR,Z=B.m,V=u.eR;for(let p=0;p<16;p++)V[p]=F[p]-Z[p];return u.markAsUpdated(),u}yQ(B){const u=this.eR,F=B.m;for(let Z=0;Z<16;Z++)u[Z]-=F[Z];return this.markAsUpdated(),this}subtractFromFloats(){for(var B=arguments.length,u=new Array(B),F=0;F<B;F++)u[F]=arguments[F];return this.subtractFromFloatsToRef(...u,new X)}subtractFromFloatsToRef(){for(var B=arguments.length,u=new Array(B),F=0;F<B;F++)u[F]=arguments[F];const Z=u.pop(),V=this.eR,p=Z.eR,G=u;for(let R=0;R<16;R++)p[R]=V[R]-G[R];return Z.markAsUpdated(),Z}invertToRef(B){return!0===this._isIdentity?(X.IdentityToRef(B),B):(t(this,B.DR())?B.markAsUpdated():B.Z(this),B)}addAtIndex(B,u){return this.eR[B]+=u,this.markAsUpdated(),this}multiplyAtIndex(B,u){return this.eR[B]*=u,this.markAsUpdated(),this}setTranslationFromFloats(B,u,F){return this.eR[12]=B,this.eR[13]=u,this.eR[14]=F,this.markAsUpdated(),this}addTranslationFromFloats(B,u,F){return this.eR[12]+=B,this.eR[13]+=u,this.eR[14]+=F,this.markAsUpdated(),this}setTranslation(B){return this.setTranslationFromFloats(B._x,B._y,B._z)}getTranslation(){return new L(this.eR[12],this.eR[13],this.eR[14])}getTranslationToRef(B){return B.x=this.eR[12],B.y=this.eR[13],B.z=this.eR[14],B}removeRotationAndScaling(){const B=this.m;return X.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,B[12],B[13],B[14],B[15],this),this._updateIdentityStatus(0===B[12]&&0===B[13]&&0===B[14]&&1===B[15]),this}Z(B){B.copyToArray(this.eR);const u=B;return this.updateFlag=u.updateFlag,this._updateIdentityStatus(u._isIdentity,u._isIdentityDirty,u._isIdentity3x2,u._isIdentity3x2Dirty),this}copyToArray(B){return Q(this,B,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(B){const u=new X;return this.multiplyToRef(B,u),u}multiplyInPlace(B){const u=this.eR,F=B.m;for(let Z=0;Z<16;Z++)u[Z]*=F[Z];return this.markAsUpdated(),this}multiplyByFloats(){const B=this.eR;for(let u=0;u<16;u++)B[u]*=u<0||arguments.length<=u?void 0:arguments[u];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var B=arguments.length,u=new Array(B),F=0;F<B;F++)u[F]=arguments[F];const Z=u.pop(),V=this.eR,p=Z.eR,G=u;for(let R=0;R<16;R++)p[R]=V[R]*G[R];return Z.markAsUpdated(),Z}multiplyToRef(B,u){return this._isIdentity?(u.Z(B),u):B._isIdentity?(u.Z(this),u):(this.multiplyToArray(B,u.eR,0),u.markAsUpdated(),u)}multiplyToArray(B,u,F){return Y(this,B,u,F),this}divide(B){return this.divideToRef(B,new X)}divideToRef(B,u){const F=this.eR,Z=B.m,V=u.eR;for(let p=0;p<16;p++)V[p]=F[p]/Z[p];return u.markAsUpdated(),u}divideInPlace(B){const u=this.eR,F=B.m;for(let Z=0;Z<16;Z++)u[Z]/=F[Z];return this.markAsUpdated(),this}minimizeInPlace(B){const u=this.eR,F=B.m;for(let Z=0;Z<16;Z++)u[Z]=Math.min(u[Z],F[Z]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const B=this.eR;for(let u=0;u<16;u++)B[u]=Math.min(B[u],u<0||arguments.length<=u?void 0:arguments[u]);return this.markAsUpdated(),this}maximizeInPlace(B){const u=this.eR,F=B.m;for(let Z=0;Z<16;Z++)u[Z]=Math.min(u[Z],F[Z]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const B=this.eR;for(let u=0;u<16;u++)B[u]=Math.min(B[u],u<0||arguments.length<=u?void 0:arguments[u]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new X)}negateInPlace(){const B=this.eR;for(let u=0;u<16;u++)B[u]=-B[u];return this.markAsUpdated(),this}negateToRef(B){const u=this.eR,F=B.eR;for(let Z=0;Z<16;Z++)F[Z]=-u[Z];return B.markAsUpdated(),B}equals(B){const u=B;if(!u)return!1;if((this._isIdentity||u._isIdentity)&&!this._isIdentityDirty&&!u._isIdentityDirty)return this._isIdentity&&u._isIdentity;const F=this.m,Z=u.m;return F[0]===Z[0]&&F[1]===Z[1]&&F[2]===Z[2]&&F[3]===Z[3]&&F[4]===Z[4]&&F[5]===Z[5]&&F[6]===Z[6]&&F[7]===Z[7]&&F[8]===Z[8]&&F[9]===Z[9]&&F[10]===Z[10]&&F[11]===Z[11]&&F[12]===Z[12]&&F[13]===Z[13]&&F[14]===Z[14]&&F[15]===Z[15]}equalsWithEpsilon(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const F=this.eR,Z=B.m;for(let V=0;V<16;V++)if(!(0,e.WithinEpsilon)(F[V],Z[V],u))return!1;return!0}equalsToFloats(){const B=this.eR;for(let u=0;u<16;u++)if(B[u]!=(u<0||arguments.length<=u?void 0:arguments[u]))return!1;return!0}floor(){return this.floorToRef(new X)}floorToRef(B){const u=this.eR,F=B.eR;for(let Z=0;Z<16;Z++)F[Z]=Math.floor(u[Z]);return B.markAsUpdated(),B}fract(){return this.fractToRef(new X)}fractToRef(B){const u=this.eR,F=B.eR;for(let Z=0;Z<16;Z++)F[Z]=u[Z]-Math.floor(u[Z]);return B.markAsUpdated(),B}clone(){const B=new X;return B.Z(this),B}getClassName(){return"Matrix"}getHashCode(){let B=v(this.eR[0]);for(let u=1;u<16;u++)B=397*B^v(this.eR[u]);return B}decomposeToTransformNode(B){return B.rotationQuaternion=B.rotationQuaternion||new W,this.decompose(B.yR,B.rotationQuaternion,B.position)}decompose(B,u,F,Z){let V=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return F&&F.OR(0),B&&B.OR(1),u&&u.UR(0,0,0,1),!0;const p=this.eR;if(F&&F.UR(p[12],p[13],p[14]),(B=B||f.Du[0]).x=Math.sqrt(p[0]*p[0]+p[1]*p[1]+p[2]*p[2]),B.y=Math.sqrt(p[4]*p[4]+p[5]*p[5]+p[6]*p[6]),B.z=Math.sqrt(p[8]*p[8]+p[9]*p[9]+p[10]*p[10]),Z){const u=(V?Z.absoluteScaling.x:Z.yR.x)<0?-1:1,F=(V?Z.absoluteScaling.y:Z.yR.y)<0?-1:1,p=(V?Z.absoluteScaling.z:Z.yR.z)<0?-1:1;B.x*=u,B.y*=F,B.z*=p}else this.determinant()<=0&&(B.y*=-1);if(0===B._x||0===B._y||0===B._z)return u&&u.UR(0,0,0,1),!1;if(u){const F=1/B._x,Z=1/B._y,V=1/B._z;X.FromValuesToRef(p[0]*F,p[1]*F,p[2]*F,0,p[4]*Z,p[5]*Z,p[6]*Z,0,p[8]*V,p[9]*V,p[10]*V,0,0,0,0,1,f.Matrix[0]),W.FromRotationMatrixToRef(f.Matrix[0],u)}return!0}getRow(B){if(B<0||B>3)return null;const u=4*B;return new q(this.eR[u+0],this.eR[u+1],this.eR[u+2],this.eR[u+3])}getRowToRef(B,u){if(B>=0&&B<=3){const F=4*B;u.x=this.eR[F+0],u.y=this.eR[F+1],u.z=this.eR[F+2],u.w=this.eR[F+3]}return u}setRow(B,u){return this.setRowFromFloats(B,u.x,u.y,u.z,u.w)}transpose(){const B=new X;return X.TransposeToRef(this,B),B}transposeToRef(B){return X.TransposeToRef(this,B),B}setRowFromFloats(B,u,F,Z,V){if(B<0||B>3)return this;const p=4*B;return this.eR[p+0]=u,this.eR[p+1]=F,this.eR[p+2]=Z,this.eR[p+3]=V,this.markAsUpdated(),this}scale(B){const u=new X;return this.scaleToRef(B,u),u}scaleToRef(B,u){for(let F=0;F<16;F++)u.eR[F]=this.eR[F]*B;return u.markAsUpdated(),u}scaleAndAddToRef(B,u){for(let F=0;F<16;F++)u.eR[F]+=this.eR[F]*B;return u.markAsUpdated(),u}scaleInPlace(B){const u=this.eR;for(let F=0;F<16;F++)u[F]*=B;return this.markAsUpdated(),this}toNormalMatrix(B){const u=f.Matrix[0];this.invertToRef(u),u.transposeToRef(B);const F=B.eR;return X.FromValuesToRef(F[0],F[1],F[2],0,F[4],F[5],F[6],0,F[8],F[9],F[10],0,0,0,0,1,B),B}getRotationMatrix(){const B=new X;return this.getRotationMatrixToRef(B),B}getRotationMatrixToRef(B){const u=f.Du[0];if(!this.decompose(u))return X.IdentityToRef(B),B;const F=this.eR,Z=1/u._x,V=1/u._y,p=1/u._z;return X.FromValuesToRef(F[0]*Z,F[1]*Z,F[2]*Z,0,F[4]*V,F[5]*V,F[6]*V,0,F[8]*p,F[9]*p,F[10]*p,0,0,0,0,1,B),B}toggleModelMatrixHandInPlace(){const B=this.eR;return B[2]*=-1,B[6]*=-1,B[8]*=-1,B[9]*=-1,B[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const B=this.eR;return B[8]*=-1,B[9]*=-1,B[10]*=-1,B[11]*=-1,this.markAsUpdated(),this}static fu(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const F=new X;return X.FromArrayToRef(B,u,F),F}static FromArrayToRef(B,u,F){for(let Z=0;Z<16;Z++)F.eR[Z]=B[Z+u];return F.markAsUpdated(),F}static FromFloat32ArrayToRefScaled(B,u,F,Z){return Z.eR[0]=B[0+u]*F,Z.eR[1]=B[1+u]*F,Z.eR[2]=B[2+u]*F,Z.eR[3]=B[3+u]*F,Z.eR[4]=B[4+u]*F,Z.eR[5]=B[5+u]*F,Z.eR[6]=B[6+u]*F,Z.eR[7]=B[7+u]*F,Z.eR[8]=B[8+u]*F,Z.eR[9]=B[9+u]*F,Z.eR[10]=B[10+u]*F,Z.eR[11]=B[11+u]*F,Z.eR[12]=B[12+u]*F,Z.eR[13]=B[13+u]*F,Z.eR[14]=B[14+u]*F,Z.eR[15]=B[15+u]*F,Z.markAsUpdated(),Z}static get IdentityReadOnly(){return X._IdentityReadOnly}static FromValuesToRef(B,u,F,Z,V,p,G,R,e,s,Y,Q,t,v,D,L,q){const W=q.eR;W[0]=B,W[1]=u,W[2]=F,W[3]=Z,W[4]=V,W[5]=p,W[6]=G,W[7]=R,W[8]=e,W[9]=s,W[10]=Y,W[11]=Q,W[12]=t,W[13]=v,W[14]=D,W[15]=L,q.markAsUpdated()}static FromValues(B,u,F,Z,V,p,G,R,e,s,Y,Q,t,v,D,L){const q=new X,W=q.eR;return W[0]=B,W[1]=u,W[2]=F,W[3]=Z,W[4]=V,W[5]=p,W[6]=G,W[7]=R,W[8]=e,W[9]=s,W[10]=Y,W[11]=Q,W[12]=t,W[13]=v,W[14]=D,W[15]=L,q.markAsUpdated(),q}static Compose(B,u,F){const Z=new X;return X.ComposeToRef(B,u,F,Z),Z}static ComposeToRef(B,u,F,Z){const V=Z.eR,p=u._x,G=u._y,R=u._z,e=u._w,s=p+p,Y=G+G,Q=R+R,t=p*s,v=p*Y,D=p*Q,L=G*Y,q=G*Q,W=R*Q,X=e*s,f=e*Y,C=e*Q,x=B._x,U=B._y,y=B._z;return V[0]=(1-(L+W))*x,V[1]=(v+C)*x,V[2]=(D-f)*x,V[3]=0,V[4]=(v-C)*U,V[5]=(1-(t+W))*U,V[6]=(q+X)*U,V[7]=0,V[8]=(D+f)*y,V[9]=(q-X)*y,V[10]=(1-(t+L))*y,V[11]=0,V[12]=F._x,V[13]=F._y,V[14]=F._z,V[15]=1,Z.markAsUpdated(),Z}static Identity(){const B=X.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return B._updateIdentityStatus(!0),B}static IdentityToRef(B){return X.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,B),B._updateIdentityStatus(!0),B}static Zero(){const B=X.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return B._updateIdentityStatus(!1),B}static RotationX(B){const u=new X;return X.RotationXToRef(B,u),u}static Invert(B){const u=new X;return B.invertToRef(u),u}static RotationXToRef(B,u){const F=Math.sin(B),Z=Math.cos(B);return X.FromValuesToRef(1,0,0,0,0,Z,F,0,0,-F,Z,0,0,0,0,1,u),u._updateIdentityStatus(1===Z&&0===F),u}static RotationY(B){const u=new X;return X.RotationYToRef(B,u),u}static RotationYToRef(B,u){const F=Math.sin(B),Z=Math.cos(B);return X.FromValuesToRef(Z,0,-F,0,0,1,0,0,F,0,Z,0,0,0,0,1,u),u._updateIdentityStatus(1===Z&&0===F),u}static RotationZ(B){const u=new X;return X.RotationZToRef(B,u),u}static RotationZToRef(B,u){const F=Math.sin(B),Z=Math.cos(B);return X.FromValuesToRef(Z,F,0,0,-F,Z,0,0,0,0,1,0,0,0,0,1,u),u._updateIdentityStatus(1===Z&&0===F),u}static RotationAxis(B,u){const F=new X;return X.RotationAxisToRef(B,u,F),F}static RotationAxisToRef(B,u,F){const Z=Math.sin(-u),V=Math.cos(-u),p=1-V;B=B.normalizeToRef(f.Du[0]);const G=F.eR;return G[0]=B._x*B._x*p+V,G[1]=B._x*B._y*p-B._z*Z,G[2]=B._x*B._z*p+B._y*Z,G[3]=0,G[4]=B._y*B._x*p+B._z*Z,G[5]=B._y*B._y*p+V,G[6]=B._y*B._z*p-B._x*Z,G[7]=0,G[8]=B._z*B._x*p-B._y*Z,G[9]=B._z*B._y*p+B._x*Z,G[10]=B._z*B._z*p+V,G[11]=0,G[12]=0,G[13]=0,G[14]=0,G[15]=1,F.markAsUpdated(),F}static RotationAlignToRef(B,u,F){let V=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const p=L.Dot(u,B),G=F.eR;if(p<-1+Z.e)G[0]=-1,G[1]=0,G[2]=0,G[3]=0,G[4]=0,G[5]=V?1:-1,G[6]=0,G[7]=0,G[8]=0,G[9]=0,G[10]=V?-1:1,G[11]=0;else{const F=L.Cross(u,B),Z=1/(1+p);G[0]=F._x*F._x*Z+p,G[1]=F._y*F._x*Z-F._z,G[2]=F._z*F._x*Z+F._y,G[3]=0,G[4]=F._x*F._y*Z+F._z,G[5]=F._y*F._y*Z+p,G[6]=F._z*F._y*Z-F._x,G[7]=0,G[8]=F._x*F._z*Z-F._y,G[9]=F._y*F._z*Z+F._x,G[10]=F._z*F._z*Z+p,G[11]=0}return G[12]=0,G[13]=0,G[14]=0,G[15]=1,F.markAsUpdated(),F}static RotationYawPitchRoll(B,u,F){const Z=new X;return X.RotationYawPitchRollToRef(B,u,F,Z),Z}static RotationYawPitchRollToRef(B,u,F,Z){return W.RotationYawPitchRollToRef(B,u,F,f.Quaternion[0]),f.Quaternion[0].toRotationMatrix(Z),Z}static Scaling(B,u,F){const Z=new X;return X.ScalingToRef(B,u,F,Z),Z}static ScalingToRef(B,u,F,Z){return X.FromValuesToRef(B,0,0,0,0,u,0,0,0,0,F,0,0,0,0,1,Z),Z._updateIdentityStatus(1===B&&1===u&&1===F),Z}static Translation(B,u,F){const Z=new X;return X.TranslationToRef(B,u,F,Z),Z}static TranslationToRef(B,u,F,Z){return X.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,B,u,F,1,Z),Z._updateIdentityStatus(0===B&&0===u&&0===F),Z}static Lerp(B,u,F){const Z=new X;return X.LerpToRef(B,u,F,Z),Z}static LerpToRef(B,u,F,Z){const V=Z.eR,p=B.m,G=u.m;for(let R=0;R<16;R++)V[R]=p[R]*(1-F)+G[R]*F;return Z.markAsUpdated(),Z}static DecomposeLerp(B,u,F){const Z=new X;return X.DecomposeLerpToRef(B,u,F,Z),Z}static DecomposeLerpToRef(B,u,F,Z){const V=f.Du[0],p=f.Quaternion[0],G=f.Du[1];B.decompose(V,p,G);const R=f.Du[2],e=f.Quaternion[1],s=f.Du[3];u.decompose(R,e,s);const Y=f.Du[4];L.LerpToRef(V,R,F,Y);const Q=f.Quaternion[2];W.SlerpToRef(p,e,F,Q);const t=f.Du[5];return L.LerpToRef(G,s,F,t),X.ComposeToRef(Y,Q,t,Z),Z}static LookAtLH(B,u,F){const Z=new X;return X.LookAtLHToRef(B,u,F,Z),Z}static LookAtLHToRef(B,u,F,Z){const V=f.Du[0],p=f.Du[1],G=f.Du[2];u.subtractToRef(B,G),G.normalize(),L.CrossToRef(F,G,V);const R=V.lengthSquared();0===R?V.x=1:V.normalizeFromLength(Math.sqrt(R)),L.CrossToRef(G,V,p),p.normalize();const e=-L.Dot(V,B),s=-L.Dot(p,B),Y=-L.Dot(G,B);return X.FromValuesToRef(V._x,p._x,G._x,0,V._y,p._y,G._y,0,V._z,p._z,G._z,0,e,s,Y,1,Z),Z}static LookAtRH(B,u,F){const Z=new X;return X.LookAtRHToRef(B,u,F,Z),Z}static LookAtRHToRef(B,u,F,Z){const V=f.Du[0],p=f.Du[1],G=f.Du[2];B.subtractToRef(u,G),G.normalize(),L.CrossToRef(F,G,V);const R=V.lengthSquared();0===R?V.x=1:V.normalizeFromLength(Math.sqrt(R)),L.CrossToRef(G,V,p),p.normalize();const e=-L.Dot(V,B),s=-L.Dot(p,B),Y=-L.Dot(G,B);return X.FromValuesToRef(V._x,p._x,G._x,0,V._y,p._y,G._y,0,V._z,p._z,G._z,0,e,s,Y,1,Z),Z}static LookDirectionLH(B,u){const F=new X;return X.LookDirectionLHToRef(B,u,F),F}static LookDirectionLHToRef(B,u,F){const Z=f.Du[0];Z.Z(B),Z.scaleInPlace(-1);const V=f.Du[1];return L.CrossToRef(u,Z,V),X.FromValuesToRef(V._x,V._y,V._z,0,u._x,u._y,u._z,0,Z._x,Z._y,Z._z,0,0,0,0,1,F),F}static LookDirectionRH(B,u){const F=new X;return X.LookDirectionRHToRef(B,u,F),F}static LookDirectionRHToRef(B,u,F){const Z=f.Du[2];return L.CrossToRef(u,B,Z),X.FromValuesToRef(Z._x,Z._y,Z._z,0,u._x,u._y,u._z,0,B._x,B._y,B._z,0,0,0,0,1,F),F}static OrthoLH(B,u,F,Z,V){const p=new X;return X.OrthoLHToRef(B,u,F,Z,p,V),p}static OrthoLHToRef(B,u,F,Z,V,p){const G=2/B,R=2/u,e=2/(Z-F),s=-(Z+F)/(Z-F);return X.FromValuesToRef(G,0,0,0,0,R,0,0,0,0,e,0,0,0,s,1,V),p&&V.multiplyToRef(x,V),V._updateIdentityStatus(1===G&&1===R&&1===e&&0===s),V}static OrthoOffCenterLH(B,u,F,Z,V,p,G){const R=new X;return X.OrthoOffCenterLHToRef(B,u,F,Z,V,p,R,G),R}static OrthoOffCenterLHToRef(B,u,F,Z,V,p,G,R){const e=2/(u-B),s=2/(Z-F),Y=2/(p-V),Q=-(p+V)/(p-V),t=(B+u)/(B-u),v=(Z+F)/(F-Z);return X.FromValuesToRef(e,0,0,0,0,s,0,0,0,0,Y,0,t,v,Q,1,G),R&&G.multiplyToRef(x,G),G.markAsUpdated(),G}static ObliqueOffCenterLHToRef(B,u,F,Z,V,p,G,R,e,s,Y){const Q=-G*Math.cos(R),t=-G*Math.sin(R);return X.TranslationToRef(0,0,-e,f.Matrix[1]),X.FromValuesToRef(1,0,0,0,0,1,0,0,Q,t,1,0,0,0,0,1,f.Matrix[0]),f.Matrix[1].multiplyToRef(f.Matrix[0],f.Matrix[0]),X.TranslationToRef(0,0,e,f.Matrix[1]),f.Matrix[0].multiplyToRef(f.Matrix[1],f.Matrix[0]),X.OrthoOffCenterLHToRef(B,u,F,Z,V,p,s,Y),f.Matrix[0].multiplyToRef(s,s),s}static OrthoOffCenterRH(B,u,F,Z,V,p,G){const R=new X;return X.OrthoOffCenterRHToRef(B,u,F,Z,V,p,R,G),R}static OrthoOffCenterRHToRef(B,u,F,Z,V,p,G,R){return X.OrthoOffCenterLHToRef(B,u,F,Z,V,p,G,R),G.eR[10]*=-1,G}static ObliqueOffCenterRHToRef(B,u,F,Z,V,p,G,R,e,s,Y){const Q=G*Math.cos(R),t=G*Math.sin(R);return X.TranslationToRef(0,0,e,f.Matrix[1]),X.FromValuesToRef(1,0,0,0,0,1,0,0,Q,t,1,0,0,0,0,1,f.Matrix[0]),f.Matrix[1].multiplyToRef(f.Matrix[0],f.Matrix[0]),X.TranslationToRef(0,0,-e,f.Matrix[1]),f.Matrix[0].multiplyToRef(f.Matrix[1],f.Matrix[0]),X.OrthoOffCenterRHToRef(B,u,F,Z,V,p,s,Y),f.Matrix[0].multiplyToRef(s,s),s}static PerspectiveLH(B,u,F,Z,V){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const G=new X,R=2*F/B,e=2*F/u,s=(Z+F)/(Z-F),Y=-2*Z*F/(Z-F),Q=Math.tan(p);return X.FromValuesToRef(R,0,0,0,0,e,0,Q,0,0,s,1,0,0,Y,0,G),V&&G.multiplyToRef(x,G),G._updateIdentityStatus(!1),G}static PerspectiveFovLH(B,u,F,Z,V){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,G=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const R=new X;return X.PerspectiveFovLHToRef(B,u,F,Z,R,!0,V,p,G),R}static PerspectiveFovLHToRef(B,u,F,Z,V){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],G=arguments.length>6?arguments[6]:void 0,R=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,e=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const s=F,Y=Z,Q=1/Math.tan(.5*B),t=p?Q/u:Q,v=p?Q:Q*u,D=e&&0===s?-1:0!==Y?(Y+s)/(Y-s):1,L=e&&0===s?2*Y:0!==Y?-2*Y*s/(Y-s):-2*s,q=Math.tan(R);return X.FromValuesToRef(t,0,0,0,0,v,0,q,0,0,D,1,0,0,L,0,V),G&&V.multiplyToRef(x,V),V._updateIdentityStatus(!1),V}static PerspectiveFovReverseLHToRef(B,u,F,Z,V){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],G=arguments.length>6?arguments[6]:void 0,R=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const e=1/Math.tan(.5*B),s=p?e/u:e,Y=p?e:e*u,Q=Math.tan(R);return X.FromValuesToRef(s,0,0,0,0,Y,0,Q,0,0,-F,1,0,0,1,0,V),G&&V.multiplyToRef(x,V),V._updateIdentityStatus(!1),V}static PerspectiveFovRH(B,u,F,Z,V){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,G=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const R=new X;return X.PerspectiveFovRHToRef(B,u,F,Z,R,!0,V,p,G),R}static PerspectiveFovRHToRef(B,u,F,Z,V){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],G=arguments.length>6?arguments[6]:void 0,R=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,e=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const s=F,Y=Z,Q=1/Math.tan(.5*B),t=p?Q/u:Q,v=p?Q:Q*u,D=e&&0===s?1:0!==Y?-(Y+s)/(Y-s):-1,L=e&&0===s?2*Y:0!==Y?-2*Y*s/(Y-s):-2*s,q=Math.tan(R);return X.FromValuesToRef(t,0,0,0,0,v,0,q,0,0,D,-1,0,0,L,0,V),G&&V.multiplyToRef(x,V),V._updateIdentityStatus(!1),V}static PerspectiveFovReverseRHToRef(B,u,F,Z,V){let p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],G=arguments.length>6?arguments[6]:void 0,R=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const e=1/Math.tan(.5*B),s=p?e/u:e,Y=p?e:e*u,Q=Math.tan(R);return X.FromValuesToRef(s,0,0,0,0,Y,0,Q,0,0,-F,-1,0,0,-1,0,V),G&&V.multiplyToRef(x,V),V._updateIdentityStatus(!1),V}static GetFinalMatrix(B,u,F,Z,V,p){const G=B.width,R=B.height,e=B.x,s=B.y,Y=X.FromValues(G/2,0,0,0,0,-R/2,0,0,0,0,p-V,0,e+G/2,R/2+s,V,1),Q=new X;return u.multiplyToRef(F,Q),Q.multiplyToRef(Z,Q),Q.multiplyToRef(Y,Q)}static GetAsMatrix2x2(B){const u=B.m,F=[u[0],u[1],u[4],u[5]];return G.e.MatrixUse64Bits?F:new Float32Array(F)}static GetAsMatrix3x3(B){const u=B.m,F=[u[0],u[1],u[2],u[4],u[5],u[6],u[8],u[9],u[10]];return G.e.MatrixUse64Bits?F:new Float32Array(F)}static Transpose(B){const u=new X;return X.TransposeToRef(B,u),u}static TransposeToRef(B,u){const F=B.m,Z=F[0],V=F[4],p=F[8],G=F[12],R=F[1],e=F[5],s=F[9],Y=F[13],Q=F[2],t=F[6],v=F[10],D=F[14],L=F[3],q=F[7],W=F[11],X=F[15],f=u.eR;return f[0]=Z,f[1]=V,f[2]=p,f[3]=G,f[4]=R,f[5]=e,f[6]=s,f[7]=Y,f[8]=Q,f[9]=t,f[10]=v,f[11]=D,f[12]=L,f[13]=q,f[14]=W,f[15]=X,u.markAsUpdated(),u._updateIdentityStatus(B._isIdentity,B._isIdentityDirty),u}static Reflection(B){const u=new X;return X.ReflectionToRef(B,u),u}static ReflectionToRef(B,u){B.normalize();const F=B.normal.x,Z=B.normal.y,V=B.normal.z,p=-2*F,G=-2*Z,R=-2*V;return X.FromValuesToRef(p*F+1,G*F,R*F,0,p*Z,G*Z+1,R*Z,0,p*V,G*V,R*V+1,0,p*B.d,G*B.d,R*B.d,1,u),u}static FromXYZAxesToRef(B,u,F,Z){return X.FromValuesToRef(B._x,B._y,B._z,0,u._x,u._y,u._z,0,F._x,F._y,F._z,0,0,0,0,1,Z),Z}static FromQuaternionToRef(B,u){const F=B._x*B._x,Z=B._y*B._y,V=B._z*B._z,p=B._x*B._y,G=B._z*B._w,R=B._z*B._x,e=B._y*B._w,s=B._y*B._z,Y=B._x*B._w;return u.eR[0]=1-2*(Z+V),u.eR[1]=2*(p+G),u.eR[2]=2*(R-e),u.eR[3]=0,u.eR[4]=2*(p-G),u.eR[5]=1-2*(V+F),u.eR[6]=2*(s+Y),u.eR[7]=0,u.eR[8]=2*(R+e),u.eR[9]=2*(s-Y),u.eR[10]=1-2*(Z+F),u.eR[11]=0,u.eR[12]=0,u.eR[13]=0,u.eR[14]=0,u.eR[15]=1,u.markAsUpdated(),u}}X._IdentityReadOnly=X.Identity(),Object.defineProperties(X.prototype,{dimension:{value:[4,4]},rank:{value:2}});class f{}f.Du=(0,V.h)(11,L.Zero),f.Matrix=(0,V.h)(2,X.Identity),f.Quaternion=(0,V.h)(3,W.Zero);class C{}C.Vector2=(0,V.h)(3,D.Zero),C.Du=(0,V.h)(13,L.Zero),C.Vector4=(0,V.h)(3,q.Zero),C.Quaternion=(0,V.h)(3,W.Zero),C.Matrix=(0,V.h)(8,X.Identity),(0,p.f)("BABYLON.Vector2",D),(0,p.f)("BABYLON.Vector3",L),(0,p.f)("BABYLON.Vector4",q),(0,p.f)("BABYLON.Matrix",X);const x=X.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12985:(B,u,F)=>{function Z(B,u){const F=[];for(let Z=0;Z<B;++Z)F.push(u());return F}function V(B,u){return Z(B,u)}F.d(u,{e:()=>Z,h:()=>V,j:()=>G});const p=["push","splice","pop","shift","unshift"];function G(B,u){const F=p.map((F=>function(B,u,F){const Z=B[u];if("function"!==typeof Z)return null;const V=function(){const Z=B.length,p=V.previous.apply(B,arguments);return F(u,Z),p};return Z.next=V,V.previous=Z,B[u]=V,()=>{const F=V.previous;if(!F)return;const Z=V.next;Z?(F.next=Z,Z.previous=F):(F.next=void 0,B[u]=F),V.next=void 0,V.previous=void 0}}(B,F,u)));return()=>{for(const B of F)null===B||void 0===B||B()}}}}]);