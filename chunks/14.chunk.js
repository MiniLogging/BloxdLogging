"use strict";(self.fyqbdzs5tyo=self.fyqbdzs5tyo||[]).push([[14],{11237:(V,I,A)=>{A.d(I,{d:()=>Y,e:()=>E,h:()=>B,j:()=>F});const B=1/2.2,F=2.2,E=(1+Math.sqrt(5))/2,Y=.001},11249:(V,I,A)=>{function B(V){return parseInt(V.toString().replace(/\W/g,""))}function F(V,I){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(V-I)<=A}function E(V,I,A){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return V<I-B||V>A+B}function Y(V,I){return V===I?V:Math.random()*(I-V)+V}function H(V,I,A){return V+(I-V)*A}function c(V,I,A){let B=u(I-V,360);return B>180&&(B-=360),V+B*J(A)}function b(V,I,A){let B=0;return B=V!=I?J((A-V)/(I-V)):0,B}function X(V,I,A,B,F){const E=F*F,Y=F*E;return V*(2*Y-3*E+1)+A*(-2*Y+3*E)+I*(Y-2*E+F)+B*(Y-E)}function P(V,I,A,B,F){const E=F*F;return 6*(E-F)*V+(3*E-4*F+1)*I+6*(-E+F)*A+(3*E-2*F)*B}function J(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(A,Math.max(I,V))}function G(V){return V-=2*Math.PI*Math.floor((V+Math.PI)/(2*Math.PI))}function w(V){const I=V.toString(16);return V<=15?("0"+I).toUpperCase():I.toUpperCase()}function t(V){if(Math.log2)return Math.floor(Math.log2(V));if(V<0)return NaN;if(0===V)return-1/0;let I=0;if(V<1){for(;V<1;)I++,V*=2;I=-I}else if(V>1)for(;V>1;)I++,V=Math.floor(V/2);return I}function u(V,I){return V-Math.floor(V/I)*I}function W(V,I,A){return(V-I)/(A-I)}function g(V,I,A){return V*(A-I)+I}function o(V,I){let A=u(I-V,360);return A>180&&(A-=360),A}function L(V,I){const A=u(V,2*I);return I-Math.abs(A-I)}function z(V,I,A){let B=J(A);return B=-2*B*B*B+3*B*B,I*B+V*(1-B)}function m(V,I,A){let B=0;return B=Math.abs(I-V)<=A?I:V+Math.sign(I-V)*A,B}function s(V,I,A){const B=o(V,I);let F=0;return F=-A<B&&B<A?I:m(V,I=V+B,A),F}function e(V,I,A){return(V-I)/(A-I)}function S(V,I,A){return(A-I)*V+I}function Q(V,I){const A=V%I;return 0===A?I:Q(I,A)}A.r(I),A.d(I,{Clamp:()=>J,DeltaAngle:()=>o,Denormalize:()=>g,ExtractAsInt:()=>B,Hermite:()=>X,Hermite1stDerivative:()=>P,HighestCommonFactor:()=>Q,ILog2:()=>t,InverseLerp:()=>b,Lerp:()=>H,LerpAngle:()=>c,MoveTowards:()=>m,MoveTowardsAngle:()=>s,Normalize:()=>W,NormalizeRadians:()=>G,OutsideRange:()=>E,PercentToRange:()=>S,PingPong:()=>L,RandomRange:()=>Y,RangeToPercent:()=>e,Repeat:()=>u,SmoothStep:()=>z,ToHex:()=>w,WithinEpsilon:()=>F})},11231:(V,I,A)=>{A.r(I),A.d(I,{Matrix:()=>g,Quaternion:()=>W,TmpVectors:()=>L,Vector2:()=>w,tI:()=>t,Vector4:()=>u});var B=A(11237),F=A(11240),E=A(11189),Y=A(11164),H=A(11097),c=A(11249);class b{}function X(V,I,A){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const F=V.AH(),E=I.AH(),Y=F[0],H=F[1],c=F[2],b=F[3],X=F[4],P=F[5],J=F[6],G=F[7],w=F[8],t=F[9],u=F[10],W=F[11],g=F[12],o=F[13],L=F[14],z=F[15],m=E[0],s=E[1],e=E[2],S=E[3],Q=E[4],h=E[5],r=E[6],M=E[7],x=E[8],f=E[9],R=E[10],q=E[11],N=E[12],l=E[13],i=E[14],y=E[15];A[B]=Y*m+H*Q+c*x+b*N,A[B+1]=Y*s+H*h+c*f+b*l,A[B+2]=Y*e+H*r+c*R+b*i,A[B+3]=Y*S+H*M+c*q+b*y,A[B+4]=X*m+P*Q+J*x+G*N,A[B+5]=X*s+P*h+J*f+G*l,A[B+6]=X*e+P*r+J*R+G*i,A[B+7]=X*S+P*M+J*q+G*y,A[B+8]=w*m+t*Q+u*x+W*N,A[B+9]=w*s+t*h+u*f+W*l,A[B+10]=w*e+t*r+u*R+W*i,A[B+11]=w*S+t*M+u*q+W*y,A[B+12]=g*m+o*Q+L*x+z*N,A[B+13]=g*s+o*h+L*f+z*l,A[B+14]=g*e+o*r+L*R+z*i,A[B+15]=g*S+o*M+L*q+z*y}function P(V,I){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const B=V.AH();I[A]=B[0],I[A+1]=B[1],I[A+2]=B[2],I[A+3]=B[3],I[A+4]=B[4],I[A+5]=B[5],I[A+6]=B[6],I[A+7]=B[7],I[A+8]=B[8],I[A+9]=B[9],I[A+10]=B[10],I[A+11]=B[11],I[A+12]=B[12],I[A+13]=B[13],I[A+14]=B[14],I[A+15]=B[15]}function J(V,I){const A=V.AH(),B=A[0],F=A[1],E=A[2],Y=A[3],H=A[4],c=A[5],b=A[6],X=A[7],P=A[8],J=A[9],G=A[10],w=A[11],t=A[12],u=A[13],W=A[14],g=A[15],o=G*g-W*w,L=J*g-u*w,z=J*W-u*G,m=P*g-t*w,s=P*W-G*t,e=P*u-t*J,S=+(c*o-b*L+X*z),Q=-(H*o-b*m+X*s),h=+(H*L-c*m+X*e),r=-(H*z-c*s+b*e),M=B*S+F*Q+E*h+Y*r;if(0===M)return!1;const x=1/M,f=b*g-W*X,R=c*g-u*X,q=c*W-u*b,N=H*g-t*X,l=H*W-t*b,i=H*u-t*c,y=b*w-G*X,v=c*w-J*X,C=c*G-J*b,K=H*w-P*X,p=H*G-P*b,j=H*J-P*c,T=-(F*o-E*L+Y*z),d=+(B*o-E*m+Y*s),D=-(B*L-F*m+Y*e),O=+(B*z-F*s+E*e),Z=+(F*f-E*R+Y*q),a=-(B*f-E*N+Y*l),k=+(B*R-F*N+Y*i),U=-(B*q-F*l+E*i),n=-(F*y-E*v+Y*C),VV=+(B*y-E*K+Y*p),IV=-(B*v-F*K+Y*j),AV=+(B*C-F*p+E*j);return I[0]=S*x,I[1]=T*x,I[2]=Z*x,I[3]=n*x,I[4]=Q*x,I[5]=d*x,I[6]=a*x,I[7]=VV*x,I[8]=h*x,I[9]=D*x,I[10]=k*x,I[11]=IV*x,I[12]=r*x,I[13]=O*x,I[14]=U*x,I[15]=AV*x,!0}b._UpdateFlagSeed=0;const G=V=>parseInt(V.toString().replace(/\W/g,""));class w{constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=V,this.y=I}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let V=G(this.x);return V=397*V^G(this.y),V}toArray(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V[I]=this.x,V[I+1]=this.y,this}GA(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w.FromArrayToRef(V,I,this),this}AH(){return[this.x,this.y]}B(V){return this.x=V.x,this.y=V.y,this}XH(V,I){return this.x=V,this.y=I,this}set(V,I){return this.XH(V,I)}JH(V){return this.XH(V,V)}add(V){return new w(this.x+V.x,this.y+V.y)}addToRef(V,I){return I.x=this.x+V.x,I.y=this.y+V.y,I}addInPlace(V){return this.x+=V.x,this.y+=V.y,this}addInPlaceFromFloats(V,I){return this.x+=V,this.y+=I,this}addVector3(V){return new w(this.x+V.x,this.y+V.y)}uI(V){return new w(this.x-V.x,this.y-V.y)}subtractToRef(V,I){return I.x=this.x-V.x,I.y=this.y-V.y,I}wJ(V){return this.x-=V.x,this.y-=V.y,this}multiplyInPlace(V){return this.x*=V.x,this.y*=V.y,this}multiply(V){return new w(this.x*V.x,this.y*V.y)}multiplyToRef(V,I){return I.x=this.x*V.x,I.y=this.y*V.y,I}multiplyByFloats(V,I){return new w(this.x*V,this.y*I)}divide(V){return new w(this.x/V.x,this.y/V.y)}divideToRef(V,I){return I.x=this.x/V.x,I.y=this.y/V.y,I}divideInPlace(V){return this.x=this.x/V.x,this.y=this.y/V.y,this}minimizeInPlace(V){return this.minimizeInPlaceFromFloats(V.x,V.y)}maximizeInPlace(V){return this.maximizeInPlaceFromFloats(V.x,V.y)}minimizeInPlaceFromFloats(V,I){return this.x=Math.min(V,this.x),this.y=Math.min(I,this.y),this}maximizeInPlaceFromFloats(V,I){return this.x=Math.max(V,this.x),this.y=Math.max(I,this.y),this}subtractFromFloats(V,I){return new w(this.x-V,this.y-I)}subtractFromFloatsToRef(V,I,A){return A.x=this.x-V,A.y=this.y-I,A}negate(){return new w(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(V){return V.x=-this.x,V.y=-this.y,V}scaleInPlace(V){return this.x*=V,this.y*=V,this}scale(V){return new w(this.x*V,this.y*V)}scaleToRef(V,I){return I.x=this.x*V,I.y=this.y*V,I}scaleAndAddToRef(V,I){return I.x+=this.x*V,I.y+=this.y*V,I}equals(V){return V&&this.x===V.x&&this.y===V.y}equalsWithEpsilon(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.d;return V&&(0,c.WithinEpsilon)(this.x,V.x,I)&&(0,c.WithinEpsilon)(this.y,V.y,I)}equalsToFloats(V,I){return this.x===V&&this.y===I}floor(){return new w(Math.floor(this.x),Math.floor(this.y))}floorToRef(V){return V.x=Math.floor(this.x),V.y=Math.floor(this.y),V}fract(){return new w(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(V){return V.x=this.x-Math.floor(this.x),V.y=this.y-Math.floor(this.y),V}rotate(V){return this.rotateToRef(V,new w)}rotateToRef(V,I){const A=Math.cos(V),B=Math.sin(V);return I.x=A*this.x-B*this.y,I.y=B*this.x+A*this.y,I}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(V){return 0===V||1===V?this:this.scaleInPlace(1/V)}normalizeToNew(){const V=new w;return this.normalizeToRef(V),V}normalizeToRef(V){const I=this.length();return 0===I&&(V.x=this.x,V.y=this.y),this.scaleToRef(1/I,V)}clone(){return new w(this.x,this.y)}dot(V){return this.x*V.x+this.y*V.y}static Zero(){return new w(0,0)}static One(){return new w(1,1)}static Random(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new w((0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I))}static RandomToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).XH((0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I))}static get ZeroReadOnly(){return w._ZeroReadOnly}static LI(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new w(V[I],V[I+1])}static FromArrayToRef(V,I,A){return A.x=V[I],A.y=V[I+1],A}static FromFloatsToRef(V,I,A){return A.XH(V,I),A}static CatmullRom(V,I,A,B,F){const E=F*F,Y=F*E,H=.5*(2*I.x+(-V.x+A.x)*F+(2*V.x-5*I.x+4*A.x-B.x)*E+(-V.x+3*I.x-3*A.x+B.x)*Y),c=.5*(2*I.y+(-V.y+A.y)*F+(2*V.y-5*I.y+4*A.y-B.y)*E+(-V.y+3*I.y-3*A.y+B.y)*Y);return new w(H,c)}static ClampToRef(V,I,A,B){return B.x=(0,c.Clamp)(V.x,I.x,A.x),B.y=(0,c.Clamp)(V.y,I.y,A.y),B}static Clamp(V,I,A){const B=(0,c.Clamp)(V.x,I.x,A.x),F=(0,c.Clamp)(V.y,I.y,A.y);return new w(B,F)}static Hermite(V,I,A,B,F){const E=F*F,Y=F*E,H=2*Y-3*E+1,c=-2*Y+3*E,b=Y-2*E+F,X=Y-E,P=V.x*H+A.x*c+I.x*b+B.x*X,J=V.y*H+A.y*c+I.y*b+B.y*X;return new w(P,J)}static Hermite1stDerivative(V,I,A,B,F){return this.Hermite1stDerivativeToRef(V,I,A,B,F,new w)}static Hermite1stDerivativeToRef(V,I,A,B,F,E){const Y=F*F;return E.x=6*(Y-F)*V.x+(3*Y-4*F+1)*I.x+6*(-Y+F)*A.x+(3*Y-2*F)*B.x,E.y=6*(Y-F)*V.y+(3*Y-4*F+1)*I.y+6*(-Y+F)*A.y+(3*Y-2*F)*B.y,E}static Lerp(V,I,A){return w.LerpToRef(V,I,A,new w)}static LerpToRef(V,I,A,B){return B.x=V.x+(I.x-V.x)*A,B.y=V.y+(I.y-V.y)*A,B}static Dot(V,I){return V.x*I.x+V.y*I.y}static Normalize(V){return w.NormalizeToRef(V,new w)}static NormalizeToRef(V,I){return V.normalizeToRef(I),I}static Minimize(V,I){const A=V.x<I.x?V.x:I.x,B=V.y<I.y?V.y:I.y;return new w(A,B)}static Maximize(V,I){const A=V.x>I.x?V.x:I.x,B=V.y>I.y?V.y:I.y;return new w(A,B)}static Transform(V,I){return w.TransformToRef(V,I,new w)}static TransformToRef(V,I,A){const B=I.m,F=V.x*B[0]+V.y*B[4]+B[12],E=V.x*B[1]+V.y*B[5]+B[13];return A.x=F,A.y=E,A}static PointInTriangle(V,I,A,B){const F=.5*(-A.y*B.x+I.y*(-A.x+B.x)+I.x*(A.y-B.y)+A.x*B.y),E=F<0?-1:1,Y=(I.y*B.x-I.x*B.y+(B.y-I.y)*V.x+(I.x-B.x)*V.y)*E,H=(I.x*A.y-I.y*A.x+(I.y-A.y)*V.x+(A.x-I.x)*V.y)*E;return Y>0&&H>0&&Y+H<2*F*E}static Distance(V,I){return Math.sqrt(w.DistanceSquared(V,I))}static DistanceSquared(V,I){const A=V.x-I.x,B=V.y-I.y;return A*A+B*B}static Center(V,I){return w.CenterToRef(V,I,new w)}static CenterToRef(V,I,A){return A.XH((V.x+I.x)/2,(V.y+I.y)/2)}static DistanceOfPointFromSegment(V,I,A){const B=w.DistanceSquared(I,A);if(0===B)return w.Distance(V,I);const F=A.uI(I),E=Math.max(0,Math.min(1,w.Dot(V.uI(I),F)/B)),Y=I.add(F.multiplyByFloats(E,E));return w.Distance(V,Y)}}w._V8PerformanceHack=new w(.5,.5),w._ZeroReadOnly=w.Zero(),Object.defineProperties(w.prototype,{dimension:{value:[2]},rank:{value:1}});class t{get x(){return this._x}set x(V){this._x=V,this._isDirty=!0}get y(){return this._y}set y(V){this._y=V,this._isDirty=!0}get z(){return this._z}set z(V){this._z=V,this._isDirty=!0}constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=V,this._y=I,this._z=A}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"tI"}getHashCode(){let V=G(this._x);return V=397*V^G(this._y),V=397*V^G(this._z),V}AH(){return[this._x,this._y,this._z]}toArray(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V[I]=this._x,V[I+1]=this._y,V[I+2]=this._z,this}GA(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(V,I,this),this}toQuaternion(){return W.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(V){return this._x+=V._x,this._y+=V._y,this._z+=V._z,this._isDirty=!0,this}addInPlaceFromFloats(V,I,A){return this._x+=V,this._y+=I,this._z+=A,this._isDirty=!0,this}add(V){return new t(this._x+V._x,this._y+V._y,this._z+V._z)}addToRef(V,I){return I._x=this._x+V._x,I._y=this._y+V._y,I._z=this._z+V._z,I._isDirty=!0,I}wJ(V){return this._x-=V._x,this._y-=V._y,this._z-=V._z,this._isDirty=!0,this}uI(V){return new t(this._x-V._x,this._y-V._y,this._z-V._z)}subtractToRef(V,I){return this.subtractFromFloatsToRef(V._x,V._y,V._z,I)}subtractFromFloats(V,I,A){return new t(this._x-V,this._y-I,this._z-A)}subtractFromFloatsToRef(V,I,A,B){return B._x=this._x-V,B._y=this._y-I,B._z=this._z-A,B._isDirty=!0,B}negate(){return new t(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(V){return V._x=-1*this._x,V._y=-1*this._y,V._z=-1*this._z,V._isDirty=!0,V}scaleInPlace(V){return this._x*=V,this._y*=V,this._z*=V,this._isDirty=!0,this}scale(V){return new t(this._x*V,this._y*V,this._z*V)}scaleToRef(V,I){return I._x=this._x*V,I._y=this._y*V,I._z=this._z*V,I._isDirty=!0,I}getNormalToRef(V){const I=this.length();let A=Math.acos(this._y/I);const B=Math.atan2(this._z,this._x);A>Math.PI/2?A-=Math.PI/2:A+=Math.PI/2;const F=I*Math.sin(A)*Math.cos(B),E=I*Math.cos(A),Y=I*Math.sin(A)*Math.sin(B);return V.set(F,E,Y),V}applyRotationQuaternionToRef(V,I){const A=this._x,B=this._y,F=this._z,E=V._x,Y=V._y,H=V._z,c=V._w,b=2*(Y*F-H*B),X=2*(H*A-E*F),P=2*(E*B-Y*A);return I._x=A+c*b+Y*P-H*X,I._y=B+c*X+H*b-E*P,I._z=F+c*P+E*X-Y*b,I._isDirty=!0,I}applyRotationQuaternionInPlace(V){return this.applyRotationQuaternionToRef(V,this)}applyRotationQuaternion(V){return this.applyRotationQuaternionToRef(V,new t)}scaleAndAddToRef(V,I){return I._x+=this._x*V,I._y+=this._y*V,I._z+=this._z*V,I._isDirty=!0,I}projectOnPlane(V,I){return this.projectOnPlaneToRef(V,I,new t)}projectOnPlaneToRef(V,I,A){const B=V.normal,F=V.d,E=o.tI[0];this.subtractToRef(I,E),E.normalize();const Y=t.Dot(E,B);if(Math.abs(Y)<1e-10)A.JH(1/0);else{const V=-(t.Dot(I,B)+F)/Y,H=E.scaleInPlace(V);I.addToRef(H,A)}return A}equals(V){return V&&this._x===V._x&&this._y===V._y&&this._z===V._z}equalsWithEpsilon(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.d;return V&&(0,c.WithinEpsilon)(this._x,V._x,I)&&(0,c.WithinEpsilon)(this._y,V._y,I)&&(0,c.WithinEpsilon)(this._z,V._z,I)}equalsToFloats(V,I,A){return this._x===V&&this._y===I&&this._z===A}multiplyInPlace(V){return this._x*=V._x,this._y*=V._y,this._z*=V._z,this._isDirty=!0,this}multiply(V){return this.multiplyByFloats(V._x,V._y,V._z)}multiplyToRef(V,I){return I._x=this._x*V._x,I._y=this._y*V._y,I._z=this._z*V._z,I._isDirty=!0,I}multiplyByFloats(V,I,A){return new t(this._x*V,this._y*I,this._z*A)}divide(V){return new t(this._x/V._x,this._y/V._y,this._z/V._z)}divideToRef(V,I){return I._x=this._x/V._x,I._y=this._y/V._y,I._z=this._z/V._z,I._isDirty=!0,I}divideInPlace(V){return this._x=this._x/V._x,this._y=this._y/V._y,this._z=this._z/V._z,this._isDirty=!0,this}minimizeInPlace(V){return this.minimizeInPlaceFromFloats(V._x,V._y,V._z)}maximizeInPlace(V){return this.maximizeInPlaceFromFloats(V._x,V._y,V._z)}minimizeInPlaceFromFloats(V,I,A){return V<this._x&&(this.x=V),I<this._y&&(this.y=I),A<this._z&&(this.z=A),this}maximizeInPlaceFromFloats(V,I,A){return V>this._x&&(this.x=V),I>this._y&&(this.y=I),A>this._z&&(this.z=A),this}isNonUniformWithinEpsilon(V){const I=Math.abs(this._x),A=Math.abs(this._y);if(!(0,c.WithinEpsilon)(I,A,V))return!0;const B=Math.abs(this._z);return!(0,c.WithinEpsilon)(I,B,V)||!(0,c.WithinEpsilon)(A,B,V)}get isNonUniform(){const V=Math.abs(this._x);if(V!==Math.abs(this._y))return!0;return V!==Math.abs(this._z)}floorToRef(V){return V._x=Math.floor(this._x),V._y=Math.floor(this._y),V._z=Math.floor(this._z),V._isDirty=!0,V}floor(){return new t(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(V){return V._x=this._x-Math.floor(this._x),V._y=this._y-Math.floor(this._y),V._z=this._z-Math.floor(this._z),V._isDirty=!0,V}fract(){return new t(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(V){if("xyz"===(V=V.toLowerCase()))return this;const I=o.tI[0].B(this);return this.x=I[V[0]],this.y=I[V[1]],this.z=I[V[2]],this}rotateByQuaternionToRef(V,I){return V.toRotationMatrix(o.Matrix[0]),t.TransformCoordinatesToRef(this,o.Matrix[0],I),I}rotateByQuaternionAroundPointToRef(V,I,A){return this.subtractToRef(I,o.tI[0]),o.tI[0].rotateByQuaternionToRef(V,o.tI[0]),I.addToRef(o.tI[0],A),A}cross(V){return t.CrossToRef(this,V,new t)}normalizeFromLength(V){return 0===V||1===V?this:this.scaleInPlace(1/V)}normalizeToNew(){return this.normalizeToRef(new t)}normalizeToRef(V){const I=this.length();return 0===I||1===I?(V._x=this._x,V._y=this._y,V._z=this._z,V._isDirty=!0,V):this.scaleToRef(1/I,V)}clone(){return new t(this._x,this._y,this._z)}B(V){return this.XH(V._x,V._y,V._z)}XH(V,I,A){return this._x=V,this._y=I,this._z=A,this._isDirty=!0,this}set(V,I,A){return this.XH(V,I,A)}JH(V){return this._x=this._y=this._z=V,this._isDirty=!0,this}static GetClipFactor(V,I,A,B){const F=t.Dot(V,A);return(F-B)/(F-t.Dot(I,A))}static GetAngleBetweenVectors(V,I,A){const B=V.normalizeToRef(o.tI[1]),F=I.normalizeToRef(o.tI[2]);let E=t.Dot(B,F);E=(0,c.Clamp)(E,-1,1);const Y=Math.acos(E),H=o.tI[3];return t.CrossToRef(B,F,H),t.Dot(H,A)>0?isNaN(Y)?0:Y:isNaN(Y)?-Math.PI:-Math.acos(E)}static GetAngleBetweenVectorsOnPlane(V,I,A){o.tI[0].B(V);const B=o.tI[0];o.tI[1].B(I);const F=o.tI[1];o.tI[2].B(A);const E=o.tI[2],Y=o.tI[3],H=o.tI[4];B.normalize(),F.normalize(),E.normalize(),t.CrossToRef(E,B,Y),t.CrossToRef(Y,E,H);const b=Math.atan2(t.Dot(F,Y),t.Dot(F,H));return(0,c.NormalizeRadians)(b)}static PitchYawRollToMoveBetweenPointsToRef(V,I,A){const B=L.tI[0];return I.subtractToRef(V,B),A._y=Math.atan2(B.x,B.z)||0,A._x=Math.atan2(Math.sqrt(B.x**2+B.z**2),B.y)||0,A._z=0,A._isDirty=!0,A}static PitchYawRollToMoveBetweenPoints(V,I){const A=t.Zero();return t.PitchYawRollToMoveBetweenPointsToRef(V,I,A)}static SlerpToRef(V,I,A,F){A=(0,c.Clamp)(A,0,1);const E=o.tI[0],Y=o.tI[1];E.B(V);const H=E.length();E.normalizeFromLength(H),Y.B(I);const b=Y.length();Y.normalizeFromLength(b);const X=t.Dot(E,Y);let P,J;if(X<1-B.d){const V=Math.acos(X),I=1/Math.sin(V);P=Math.sin((1-A)*V)*I,J=Math.sin(A*V)*I}else P=1-A,J=A;return E.scaleInPlace(P),Y.scaleInPlace(J),F.B(E).addInPlace(Y),F.scaleInPlace((0,c.Lerp)(H,b,A)),F}static SmoothToRef(V,I,A,B,F){return t.SlerpToRef(V,I,0===B?1:A/B,F),F}static LI(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new t(V[I],V[I+1],V[I+2])}static FromFloatArray(V,I){return t.LI(V,I)}static FromArrayToRef(V,I,A){return A._x=V[I],A._y=V[I+1],A._z=V[I+2],A._isDirty=!0,A}static FromFloatArrayToRef(V,I,A){return t.FromArrayToRef(V,I,A)}static FromFloatsToRef(V,I,A,B){return B.XH(V,I,A),B}static Zero(){return new t(0,0,0)}static One(){return new t(1,1,1)}static Up(){return new t(0,1,0)}static get UpReadOnly(){return t._UpReadOnly}static get DownReadOnly(){return t._DownReadOnly}static get RightReadOnly(){return t._RightReadOnly}static get LeftReadOnly(){return t._LeftReadOnly}static get LeftHandedForwardReadOnly(){return t._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return t._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return t._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return t._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return t._ZeroReadOnly}static get OneReadOnly(){return t._OneReadOnly}static Down(){return new t(0,-1,0)}static Forward(){return new t(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new t(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new t(1,0,0)}static Left(){return new t(-1,0,0)}static Random(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new t((0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I))}static RandomToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).XH((0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I))}static TransformCoordinates(V,I){const A=t.Zero();return t.TransformCoordinatesToRef(V,I,A),A}static TransformCoordinatesToRef(V,I,A){return t.TransformCoordinatesFromFloatsToRef(V._x,V._y,V._z,I,A),A}static TransformCoordinatesFromFloatsToRef(V,I,A,B,F){const E=B.m,Y=V*E[0]+I*E[4]+A*E[8]+E[12],H=V*E[1]+I*E[5]+A*E[9]+E[13],c=V*E[2]+I*E[6]+A*E[10]+E[14],b=1/(V*E[3]+I*E[7]+A*E[11]+E[15]);return F._x=Y*b,F._y=H*b,F._z=c*b,F._isDirty=!0,F}static TransformNormal(V,I){const A=t.Zero();return t.TransformNormalToRef(V,I,A),A}static TransformNormalToRef(V,I,A){return this.TransformNormalFromFloatsToRef(V._x,V._y,V._z,I,A),A}static TransformNormalFromFloatsToRef(V,I,A,B,F){const E=B.m;return F._x=V*E[0]+I*E[4]+A*E[8],F._y=V*E[1]+I*E[5]+A*E[9],F._z=V*E[2]+I*E[6]+A*E[10],F._isDirty=!0,F}static CatmullRom(V,I,A,B,F){const E=F*F,Y=F*E,H=.5*(2*I._x+(-V._x+A._x)*F+(2*V._x-5*I._x+4*A._x-B._x)*E+(-V._x+3*I._x-3*A._x+B._x)*Y),c=.5*(2*I._y+(-V._y+A._y)*F+(2*V._y-5*I._y+4*A._y-B._y)*E+(-V._y+3*I._y-3*A._y+B._y)*Y),b=.5*(2*I._z+(-V._z+A._z)*F+(2*V._z-5*I._z+4*A._z-B._z)*E+(-V._z+3*I._z-3*A._z+B._z)*Y);return new t(H,c,b)}static Clamp(V,I,A){const B=new t;return t.ClampToRef(V,I,A,B),B}static ClampToRef(V,I,A,B){let F=V._x;F=F>A._x?A._x:F,F=F<I._x?I._x:F;let E=V._y;E=E>A._y?A._y:E,E=E<I._y?I._y:E;let Y=V._z;return Y=Y>A._z?A._z:Y,Y=Y<I._z?I._z:Y,B.XH(F,E,Y),B}static CheckExtends(V,I,A){I.minimizeInPlace(V),A.maximizeInPlace(V)}static Hermite(V,I,A,B,F){const E=F*F,Y=F*E,H=2*Y-3*E+1,c=-2*Y+3*E,b=Y-2*E+F,X=Y-E,P=V._x*H+A._x*c+I._x*b+B._x*X,J=V._y*H+A._y*c+I._y*b+B._y*X,G=V._z*H+A._z*c+I._z*b+B._z*X;return new t(P,J,G)}static Hermite1stDerivative(V,I,A,B,F){const E=new t;return this.Hermite1stDerivativeToRef(V,I,A,B,F,E),E}static Hermite1stDerivativeToRef(V,I,A,B,F,E){const Y=F*F;return E._x=6*(Y-F)*V._x+(3*Y-4*F+1)*I._x+6*(-Y+F)*A._x+(3*Y-2*F)*B._x,E._y=6*(Y-F)*V._y+(3*Y-4*F+1)*I._y+6*(-Y+F)*A._y+(3*Y-2*F)*B._y,E._z=6*(Y-F)*V._z+(3*Y-4*F+1)*I._z+6*(-Y+F)*A._z+(3*Y-2*F)*B._z,E._isDirty=!0,E}static Lerp(V,I,A){const B=new t(0,0,0);return t.LerpToRef(V,I,A,B),B}static LerpToRef(V,I,A,B){return B._x=V._x+(I._x-V._x)*A,B._y=V._y+(I._y-V._y)*A,B._z=V._z+(I._z-V._z)*A,B._isDirty=!0,B}static Dot(V,I){return V._x*I._x+V._y*I._y+V._z*I._z}dot(V){return this._x*V._x+this._y*V._y+this._z*V._z}static Cross(V,I){const A=new t;return t.CrossToRef(V,I,A),A}static CrossToRef(V,I,A){const B=V._y*I._z-V._z*I._y,F=V._z*I._x-V._x*I._z,E=V._x*I._y-V._y*I._x;return A.XH(B,F,E),A}static Normalize(V){const I=t.Zero();return t.NormalizeToRef(V,I),I}static NormalizeToRef(V,I){return V.normalizeToRef(I),I}static Project(V,I,A,B){const F=new t;return t.ProjectToRef(V,I,A,B,F),F}static ProjectToRef(V,I,A,B,F){var E;const Y=B.width,c=B.height,b=B.x,X=B.y,P=o.Matrix[1],J=null===(E=H.e.LastCreatedEngine)||void 0===E?void 0:E.isNDCHalfZRange,G=J?1:.5,w=J?0:.5;g.FromValuesToRef(Y/2,0,0,0,0,-c/2,0,0,0,0,G,0,b+Y/2,c/2+X,w,1,P);const u=o.Matrix[0];return I.multiplyToRef(A,u),u.multiplyToRef(P,u),t.TransformCoordinatesToRef(V,u,F),F}static Reflect(V,I){return this.ReflectToRef(V,I,new t)}static ReflectToRef(V,I,A){const B=L.tI[0];return B.B(I).scaleInPlace(2*t.Dot(V,I)),A.B(V).wJ(B)}static _UnprojectFromInvertedMatrixToRef(V,I,A){t.TransformCoordinatesToRef(V,I,A);const B=I.m,F=V._x*B[3]+V._y*B[7]+V._z*B[11]+B[15];return(0,c.WithinEpsilon)(F,1)&&A.scaleInPlace(1/F),A}static UnprojectFromTransform(V,I,A,B,F){return this.Unproject(V,I,A,B,F,g.IdentityReadOnly)}static Unproject(V,I,A,B,F,E){const Y=new t;return t.UnprojectToRef(V,I,A,B,F,E,Y),Y}static UnprojectToRef(V,I,A,B,F,E,Y){return t.UnprojectFloatsToRef(V._x,V._y,V._z,I,A,B,F,E,Y),Y}static UnprojectFloatsToRef(V,I,A,B,F,E,Y,c,b){var X;const P=o.Matrix[0];E.multiplyToRef(Y,P),P.multiplyToRef(c,P),P.invert();const J=o.tI[0];return J.x=V/B*2-1,J.y=-(I/F*2-1),null!==(X=H.e.LastCreatedEngine)&&void 0!==X&&X.isNDCHalfZRange?J.z=A:J.z=2*A-1,t._UnprojectFromInvertedMatrixToRef(J,P,b),b}static Minimize(V,I){const A=new t;return A.B(V),A.minimizeInPlace(I),A}static Maximize(V,I){const A=new t;return A.B(V),A.maximizeInPlace(I),A}static Distance(V,I){return Math.sqrt(t.DistanceSquared(V,I))}static DistanceSquared(V,I){const A=V._x-I._x,B=V._y-I._y,F=V._z-I._z;return A*A+B*B+F*F}static ProjectOnTriangleToRef(V,I,A,F,E){const Y=o.tI[0],H=o.tI[1],b=o.tI[2],X=o.tI[3],P=o.tI[4];A.subtractToRef(I,Y),F.subtractToRef(I,H),F.subtractToRef(A,b);const J=Y.length(),G=H.length(),w=b.length();if(J<B.d||G<B.d||w<B.d)return E.B(I),t.Distance(V,I);V.subtractToRef(I,P),t.CrossToRef(Y,H,X);const u=X.length();if(u<B.d)return E.B(I),t.Distance(V,I);X.normalizeFromLength(u);let W=P.length();if(W<B.d)return E.B(I),0;P.normalizeFromLength(W);const g=t.Dot(X,P),L=o.tI[5],z=o.tI[6];L.B(X).scaleInPlace(-W*g),z.B(V).addInPlace(L);const m=o.tI[4],s=o.tI[5],e=o.tI[7],S=o.tI[8];m.B(Y).scaleInPlace(1/J),S.B(H).scaleInPlace(1/G),m.addInPlace(S).scaleInPlace(-1),s.B(Y).scaleInPlace(-1/J),S.B(b).scaleInPlace(1/w),s.addInPlace(S).scaleInPlace(-1),e.B(b).scaleInPlace(-1/w),S.B(H).scaleInPlace(-1/G),e.addInPlace(S).scaleInPlace(-1);const Q=o.tI[9];let h;Q.B(z).wJ(I),t.CrossToRef(m,Q,S),h=t.Dot(S,X);const r=h;Q.B(z).wJ(A),t.CrossToRef(s,Q,S),h=t.Dot(S,X);const M=h;Q.B(z).wJ(F),t.CrossToRef(e,Q,S),h=t.Dot(S,X);const x=h,f=o.tI[10];let R,q;r>0&&M<0?(f.B(Y),R=I,q=A):M>0&&x<0?(f.B(b),R=A,q=F):(f.B(H).scaleInPlace(-1),R=F,q=I);const N=o.tI[9],l=o.tI[4];R.subtractToRef(z,S),q.subtractToRef(z,N),t.CrossToRef(S,N,l);if(!(t.Dot(l,X)<0))return E.B(z),Math.abs(W*g);const i=o.tI[5];t.CrossToRef(f,l,i),i.normalize();const y=o.tI[9];y.B(R).wJ(z);const v=y.length();if(v<B.d)return E.B(R),t.Distance(V,R);y.normalizeFromLength(v);const C=t.Dot(i,y),K=o.tI[7];K.B(z).addInPlace(i.scaleInPlace(v*C)),S.B(K).wJ(R),W=f.length(),f.normalizeFromLength(W);let p=t.Dot(S,f)/Math.max(W,B.d);return p=(0,c.Clamp)(p,0,1),K.B(R).addInPlace(f.scaleInPlace(p*W)),E.B(K),t.Distance(V,K)}static Center(V,I){return t.CenterToRef(V,I,t.Zero())}static CenterToRef(V,I,A){return A.XH((V._x+I._x)/2,(V._y+I._y)/2,(V._z+I._z)/2)}static RotationFromAxis(V,I,A){const B=new t;return t.RotationFromAxisToRef(V,I,A,B),B}static RotationFromAxisToRef(V,I,A,B){const F=o.Quaternion[0];return W.RotationQuaternionFromAxisToRef(V,I,A,F),F.toEulerAnglesToRef(B),B}}t._V8PerformanceHack=new t(.5,.5,.5),t._UpReadOnly=t.Up(),t._DownReadOnly=t.Down(),t._LeftHandedForwardReadOnly=t.Forward(!1),t._RightHandedForwardReadOnly=t.Forward(!0),t._LeftHandedBackwardReadOnly=t.Backward(!1),t._RightHandedBackwardReadOnly=t.Backward(!0),t._RightReadOnly=t.Right(),t._LeftReadOnly=t.Left(),t._ZeroReadOnly=t.Zero(),t._OneReadOnly=t.One(),Object.defineProperties(t.prototype,{dimension:{value:[3]},rank:{value:1}});class u{get x(){return this._x}set x(V){this._x=V,this._isDirty=!0}get y(){return this._y}set y(V){this._y=V,this._isDirty=!0}get z(){return this._z}set z(V){this._z=V,this._isDirty=!0}get w(){return this._w}set w(V){this._w=V,this._isDirty=!0}constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=V,this._y=I,this._z=A,this._w=B}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let V=G(this._x);return V=397*V^G(this._y),V=397*V^G(this._z),V=397*V^G(this._w),V}AH(){return[this._x,this._y,this._z,this._w]}toArray(V,I){return void 0===I&&(I=0),V[I]=this._x,V[I+1]=this._y,V[I+2]=this._z,V[I+3]=this._w,this}GA(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(V,I,this),this}addInPlace(V){return this.x+=V._x,this.y+=V._y,this.z+=V._z,this.w+=V._w,this}addInPlaceFromFloats(V,I,A,B){return this.x+=V,this.y+=I,this.z+=A,this.w+=B,this}add(V){return new u(this._x+V.x,this._y+V.y,this._z+V.z,this._w+V.w)}addToRef(V,I){return I.x=this._x+V.x,I.y=this._y+V.y,I.z=this._z+V.z,I.w=this._w+V.w,I}wJ(V){return this.x-=V.x,this.y-=V.y,this.z-=V.z,this.w-=V.w,this}uI(V){return new u(this._x-V.x,this._y-V.y,this._z-V.z,this._w-V.w)}subtractToRef(V,I){return I.x=this._x-V.x,I.y=this._y-V.y,I.z=this._z-V.z,I.w=this._w-V.w,I}subtractFromFloats(V,I,A,B){return new u(this._x-V,this._y-I,this._z-A,this._w-B)}subtractFromFloatsToRef(V,I,A,B,F){return F.x=this._x-V,F.y=this._y-I,F.z=this._z-A,F.w=this._w-B,F}negate(){return new u(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(V){return V.x=-this._x,V.y=-this._y,V.z=-this._z,V.w=-this._w,V}scaleInPlace(V){return this.x*=V,this.y*=V,this.z*=V,this.w*=V,this}scale(V){return new u(this._x*V,this._y*V,this._z*V,this._w*V)}scaleToRef(V,I){return I.x=this._x*V,I.y=this._y*V,I.z=this._z*V,I.w=this._w*V,I}scaleAndAddToRef(V,I){return I.x+=this._x*V,I.y+=this._y*V,I.z+=this._z*V,I.w+=this._w*V,I}equals(V){return V&&this._x===V.x&&this._y===V.y&&this._z===V.z&&this._w===V.w}equalsWithEpsilon(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.d;return V&&(0,c.WithinEpsilon)(this._x,V.x,I)&&(0,c.WithinEpsilon)(this._y,V.y,I)&&(0,c.WithinEpsilon)(this._z,V.z,I)&&(0,c.WithinEpsilon)(this._w,V.w,I)}equalsToFloats(V,I,A,B){return this._x===V&&this._y===I&&this._z===A&&this._w===B}multiplyInPlace(V){return this.x*=V.x,this.y*=V.y,this.z*=V.z,this.w*=V.w,this}multiply(V){return new u(this._x*V.x,this._y*V.y,this._z*V.z,this._w*V.w)}multiplyToRef(V,I){return I.x=this._x*V.x,I.y=this._y*V.y,I.z=this._z*V.z,I.w=this._w*V.w,I}multiplyByFloats(V,I,A,B){return new u(this._x*V,this._y*I,this._z*A,this._w*B)}divide(V){return new u(this._x/V.x,this._y/V.y,this._z/V.z,this._w/V.w)}divideToRef(V,I){return I.x=this._x/V.x,I.y=this._y/V.y,I.z=this._z/V.z,I.w=this._w/V.w,I}divideInPlace(V){return this.divideToRef(V,this)}minimizeInPlace(V){return V.x<this._x&&(this.x=V.x),V.y<this._y&&(this.y=V.y),V.z<this._z&&(this.z=V.z),V.w<this._w&&(this.w=V.w),this}maximizeInPlace(V){return V.x>this._x&&(this.x=V.x),V.y>this._y&&(this.y=V.y),V.z>this._z&&(this.z=V.z),V.w>this._w&&(this.w=V.w),this}minimizeInPlaceFromFloats(V,I,A,B){return this.x=Math.min(V,this._x),this.y=Math.min(I,this._y),this.z=Math.min(A,this._z),this.w=Math.min(B,this._w),this}maximizeInPlaceFromFloats(V,I,A,B){return this.x=Math.max(V,this._x),this.y=Math.max(I,this._y),this.z=Math.max(A,this._z),this.w=Math.max(B,this._w),this}floorToRef(V){return V.x=Math.floor(this._x),V.y=Math.floor(this._y),V.z=Math.floor(this._z),V.w=Math.floor(this._w),V}floor(){return new u(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(V){return V.x=this._x-Math.floor(this._x),V.y=this._y-Math.floor(this._y),V.z=this._z-Math.floor(this._z),V.w=this._w-Math.floor(this._w),V}fract(){return new u(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(V){return 0===V||1===V?this:this.scaleInPlace(1/V)}normalizeToNew(){return this.normalizeToRef(new u)}normalizeToRef(V){const I=this.length();return 0===I||1===I?(V.x=this._x,V.y=this._y,V.z=this._z,V.w=this._w,V):this.scaleToRef(1/I,V)}toVector3(){return new t(this._x,this._y,this._z)}clone(){return new u(this._x,this._y,this._z,this._w)}B(V){return this.x=V.x,this.y=V.y,this.z=V.z,this.w=V.w,this}XH(V,I,A,B){return this.x=V,this.y=I,this.z=A,this.w=B,this}set(V,I,A,B){return this.XH(V,I,A,B)}JH(V){return this.x=this.y=this.z=this.w=V,this}dot(V){return this._x*V.x+this._y*V.y+this._z*V.z+this._w*V.w}static LI(V,I){return I||(I=0),new u(V[I],V[I+1],V[I+2],V[I+3])}static FromArrayToRef(V,I,A){return A.x=V[I],A.y=V[I+1],A.z=V[I+2],A.w=V[I+3],A}static FromFloatArrayToRef(V,I,A){return u.FromArrayToRef(V,I,A),A}static FromFloatsToRef(V,I,A,B,F){return F.x=V,F.y=I,F.z=A,F.w=B,F}static Zero(){return new u(0,0,0,0)}static One(){return new u(1,1,1,1)}static Random(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new u((0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I))}static RandomToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,A=arguments.length>2?arguments[2]:void 0;return A.x=(0,c.RandomRange)(V,I),A.y=(0,c.RandomRange)(V,I),A.z=(0,c.RandomRange)(V,I),A.w=(0,c.RandomRange)(V,I),A}static Clamp(V,I,A){return u.ClampToRef(V,I,A,new u)}static ClampToRef(V,I,A,B){return B.x=(0,c.Clamp)(V.x,I.x,A.x),B.y=(0,c.Clamp)(V.y,I.y,A.y),B.z=(0,c.Clamp)(V.z,I.z,A.z),B.w=(0,c.Clamp)(V.w,I.w,A.w),B}static CheckExtends(V,I,A){I.minimizeInPlace(V),A.maximizeInPlace(V)}static get ZeroReadOnly(){return u._ZeroReadOnly}static Normalize(V){return u.NormalizeToRef(V,new u)}static NormalizeToRef(V,I){return V.normalizeToRef(I),I}static Minimize(V,I){const A=new u;return A.B(V),A.minimizeInPlace(I),A}static Maximize(V,I){const A=new u;return A.B(V),A.maximizeInPlace(I),A}static Distance(V,I){return Math.sqrt(u.DistanceSquared(V,I))}static DistanceSquared(V,I){const A=V.x-I.x,B=V.y-I.y,F=V.z-I.z,E=V.w-I.w;return A*A+B*B+F*F+E*E}static Center(V,I){return u.CenterToRef(V,I,new u)}static CenterToRef(V,I,A){return A.x=(V.x+I.x)/2,A.y=(V.y+I.y)/2,A.z=(V.z+I.z)/2,A.w=(V.w+I.w)/2,A}static TransformCoordinates(V,I){return u.TransformCoordinatesToRef(V,I,new u)}static TransformCoordinatesToRef(V,I,A){return u.TransformCoordinatesFromFloatsToRef(V._x,V._y,V._z,I,A),A}static TransformCoordinatesFromFloatsToRef(V,I,A,B,F){const E=B.m,Y=V*E[0]+I*E[4]+A*E[8]+E[12],H=V*E[1]+I*E[5]+A*E[9]+E[13],c=V*E[2]+I*E[6]+A*E[10]+E[14],b=V*E[3]+I*E[7]+A*E[11]+E[15];return F.x=Y,F.y=H,F.z=c,F.w=b,F}static TransformNormal(V,I){return u.TransformNormalToRef(V,I,new u)}static TransformNormalToRef(V,I,A){const B=I.m,F=V.x*B[0]+V.y*B[4]+V.z*B[8],E=V.x*B[1]+V.y*B[5]+V.z*B[9],Y=V.x*B[2]+V.y*B[6]+V.z*B[10];return A.x=F,A.y=E,A.z=Y,A.w=V.w,A}static TransformNormalFromFloatsToRef(V,I,A,B,F,E){const Y=F.m;return E.x=V*Y[0]+I*Y[4]+A*Y[8],E.y=V*Y[1]+I*Y[5]+A*Y[9],E.z=V*Y[2]+I*Y[6]+A*Y[10],E.w=B,E}static FromVector3(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new u(V._x,V._y,V._z,I)}static Dot(V,I){return V.x*I.x+V.y*I.y+V.z*I.z+V.w*I.w}}u._V8PerformanceHack=new u(.5,.5,.5,.5),u._ZeroReadOnly=u.Zero(),Object.defineProperties(u.prototype,{dimension:{value:[4]},rank:{value:1}});class W{get x(){return this._x}set x(V){this._x=V,this._isDirty=!0}get y(){return this._y}set y(V){this._y=V,this._isDirty=!0}get z(){return this._z}set z(V){this._z=V,this._isDirty=!0}get w(){return this._w}set w(V){this._w=V,this._isDirty=!0}constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=V,this._y=I,this._z=A,this._w=B}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let V=G(this._x);return V=397*V^G(this._y),V=397*V^G(this._z),V=397*V^G(this._w),V}AH(){return[this._x,this._y,this._z,this._w]}toArray(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V[I]=this._x,V[I+1]=this._y,V[I+2]=this._z,V[I+3]=this._w,this}GA(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return W.FromArrayToRef(V,I,this)}equals(V){return V&&this._x===V._x&&this._y===V._y&&this._z===V._z&&this._w===V._w}equalsWithEpsilon(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.d;return V&&(0,c.WithinEpsilon)(this._x,V._x,I)&&(0,c.WithinEpsilon)(this._y,V._y,I)&&(0,c.WithinEpsilon)(this._z,V._z,I)&&(0,c.WithinEpsilon)(this._w,V._w,I)}isApprox(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.d;return V&&((0,c.WithinEpsilon)(this._x,V._x,I)&&(0,c.WithinEpsilon)(this._y,V._y,I)&&(0,c.WithinEpsilon)(this._z,V._z,I)&&(0,c.WithinEpsilon)(this._w,V._w,I)||(0,c.WithinEpsilon)(this._x,-V._x,I)&&(0,c.WithinEpsilon)(this._y,-V._y,I)&&(0,c.WithinEpsilon)(this._z,-V._z,I)&&(0,c.WithinEpsilon)(this._w,-V._w,I))}clone(){return new W(this._x,this._y,this._z,this._w)}B(V){return this._x=V._x,this._y=V._y,this._z=V._z,this._w=V._w,this._isDirty=!0,this}XH(V,I,A,B){return this._x=V,this._y=I,this._z=A,this._w=B,this._isDirty=!0,this}set(V,I,A,B){return this.XH(V,I,A,B)}JH(V){return this.XH(V,V,V,V)}add(V){return new W(this._x+V._x,this._y+V._y,this._z+V._z,this._w+V._w)}addInPlace(V){return this._x+=V._x,this._y+=V._y,this._z+=V._z,this._w+=V._w,this._isDirty=!0,this}addToRef(V,I){return I._x=this._x+V._x,I._y=this._y+V._y,I._z=this._z+V._z,I._w=this._w+V._w,I._isDirty=!0,I}addInPlaceFromFloats(V,I,A,B){return this._x+=V,this._y+=I,this._z+=A,this._w+=B,this._isDirty=!0,this}subtractToRef(V,I){return I._x=this._x-V._x,I._y=this._y-V._y,I._z=this._z-V._z,I._w=this._w-V._w,I._isDirty=!0,I}subtractFromFloats(V,I,A,B){return this.subtractFromFloatsToRef(V,I,A,B,new W)}subtractFromFloatsToRef(V,I,A,B,F){return F._x=this._x-V,F._y=this._y-I,F._z=this._z-A,F._w=this._w-B,F._isDirty=!0,F}uI(V){return new W(this._x-V._x,this._y-V._y,this._z-V._z,this._w-V._w)}wJ(V){return this._x-=V._x,this._y-=V._y,this._z-=V._z,this._w-=V._w,this._isDirty=!0,this}scale(V){return new W(this._x*V,this._y*V,this._z*V,this._w*V)}scaleToRef(V,I){return I._x=this._x*V,I._y=this._y*V,I._z=this._z*V,I._w=this._w*V,I._isDirty=!0,I}scaleInPlace(V){return this._x*=V,this._y*=V,this._z*=V,this._w*=V,this._isDirty=!0,this}scaleAndAddToRef(V,I){return I._x+=this._x*V,I._y+=this._y*V,I._z+=this._z*V,I._w+=this._w*V,I._isDirty=!0,I}multiply(V){const I=new W(0,0,0,1);return this.multiplyToRef(V,I),I}multiplyToRef(V,I){const A=this._x*V._w+this._y*V._z-this._z*V._y+this._w*V._x,B=-this._x*V._z+this._y*V._w+this._z*V._x+this._w*V._y,F=this._x*V._y-this._y*V._x+this._z*V._w+this._w*V._z,E=-this._x*V._x-this._y*V._y-this._z*V._z+this._w*V._w;return I.XH(A,B,F,E),I}multiplyInPlace(V){return this.multiplyToRef(V,this)}multiplyByFloats(V,I,A,B){return this._x*=V,this._y*=I,this._z*=A,this._w*=B,this._isDirty=!0,this}divide(V){throw new ReferenceError("Can not divide a quaternion")}divideToRef(V,I){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(V){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new W)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(V){return V._x=-this._x,V._y=-this._y,V._z=-this._z,V._w=-this._w,V._isDirty=!0,V}equalsToFloats(V,I,A,B){return this._x===V&&this._y===I&&this._z===A&&this._w===B}floorToRef(V){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(V){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(V){return V.XH(-this._x,-this._y,-this._z,this._w),V}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new W(-this._x,-this._y,-this._z,this._w)}invert(){const V=this.conjugate(),I=this.lengthSquared();return 0==I||1==I||V.scaleInPlace(1/I),V}invertInPlace(){this.conjugateInPlace();const V=this.lengthSquared();return 0==V||1==V||this.scaleInPlace(1/V),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(V){return 0===V||1===V?this:this.scaleInPlace(1/V)}normalizeToNew(){const V=new W(0,0,0,1);return this.normalizeToRef(V),V}normalizeToRef(V){const I=this.length();return 0===I||1===I?V.XH(this._x,this._y,this._z,this._w):this.scaleToRef(1/I,V)}toEulerAngles(){const V=t.Zero();return this.toEulerAnglesToRef(V),V}toEulerAnglesToRef(V){const I=this._z,A=this._x,B=this._y,F=this._w,E=B*I-A*F,Y=.4999999;if(E<-Y)V._y=2*Math.atan2(B,F),V._x=Math.PI/2,V._z=0,V._isDirty=!0;else if(E>Y)V._y=2*Math.atan2(B,F),V._x=-Math.PI/2,V._z=0,V._isDirty=!0;else{const Y=F*F,H=I*I,c=A*A,b=B*B;V._z=Math.atan2(2*(A*B+I*F),-H-c+b+Y),V._x=Math.asin(-2*E),V._y=Math.atan2(2*(I*A+B*F),H-c-b+Y),V._isDirty=!0}return V}toAlphaBetaGammaToRef(V){const I=this._z,A=this._x,B=this._y,F=this._w,E=Math.sqrt(A*A+B*B),Y=Math.sqrt(I*I+F*F),H=2*Math.atan2(E,Y),c=2*Math.atan2(I,F),b=2*Math.atan2(B,A),X=(c+b)/2,P=(c-b)/2;return V.set(P,H,X),V}toRotationMatrix(V){return g.FromQuaternionToRef(this,V),V}fromRotationMatrix(V){return W.FromRotationMatrixToRef(V,this),this}dot(V){return this._x*V._x+this._y*V._y+this._z*V._z+this._w*V._w}toAxisAngle(){const V=t.Zero();return{axis:V,angle:this.toAxisAngleToRef(V)}}toAxisAngleToRef(V){let I=0;const A=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),B=this._w;return A>0?(I=2*Math.atan2(A,B),V.set(this._x/A,this._y/A,this._z/A)):(I=0,V.set(1,0,0)),I}static FromRotationMatrix(V){const I=new W;return W.FromRotationMatrixToRef(V,I),I}static FromRotationMatrixToRef(V,I){const A=V.m,B=A[0],F=A[4],E=A[8],Y=A[1],H=A[5],c=A[9],b=A[2],X=A[6],P=A[10],J=B+H+P;let G;return J>0?(G=.5/Math.sqrt(J+1),I._w=.25/G,I._x=(X-c)*G,I._y=(E-b)*G,I._z=(Y-F)*G,I._isDirty=!0):B>H&&B>P?(G=2*Math.sqrt(1+B-H-P),I._w=(X-c)/G,I._x=.25*G,I._y=(F+Y)/G,I._z=(E+b)/G,I._isDirty=!0):H>P?(G=2*Math.sqrt(1+H-B-P),I._w=(E-b)/G,I._x=(F+Y)/G,I._y=.25*G,I._z=(c+X)/G,I._isDirty=!0):(G=2*Math.sqrt(1+P-B-H),I._w=(Y-F)/G,I._x=(E+b)/G,I._y=(c+X)/G,I._z=.25*G,I._isDirty=!0),I}static Dot(V,I){return V._x*I._x+V._y*I._y+V._z*I._z+V._w*I._w}static AreClose(V,I){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const B=W.Dot(V,I);return 1-B*B<=A}static SmoothToRef(V,I,A,B,F){let E=0===B?1:A/B;return E=(0,c.Clamp)(E,0,1),W.SlerpToRef(V,I,E,F),F}static Zero(){return new W(0,0,0,0)}static Inverse(V){return new W(-V._x,-V._y,-V._z,V._w)}static InverseToRef(V,I){return I.set(-V._x,-V._y,-V._z,V._w),I}static Identity(){return new W(0,0,0,1)}static IsIdentity(V){return V&&0===V._x&&0===V._y&&0===V._z&&1===V._w}static RotationAxis(V,I){return W.RotationAxisToRef(V,I,new W)}static RotationAxisToRef(V,I,A){A._w=Math.cos(I/2);const B=Math.sin(I/2)/V.length();return A._x=V._x*B,A._y=V._y*B,A._z=V._z*B,A._isDirty=!0,A}static LI(V,I){return I||(I=0),new W(V[I],V[I+1],V[I+2],V[I+3])}static FromArrayToRef(V,I,A){return A._x=V[I],A._y=V[I+1],A._z=V[I+2],A._w=V[I+3],A._isDirty=!0,A}static FromFloatsToRef(V,I,A,B,F){return F.XH(V,I,A,B),F}static FromEulerAngles(V,I,A){const B=new W;return W.RotationYawPitchRollToRef(I,V,A,B),B}static FromEulerAnglesToRef(V,I,A,B){return W.RotationYawPitchRollToRef(I,V,A,B),B}static FromEulerVector(V){const I=new W;return W.RotationYawPitchRollToRef(V._y,V._x,V._z,I),I}static FromEulerVectorToRef(V,I){return W.RotationYawPitchRollToRef(V._y,V._x,V._z,I),I}static FromUnitVectorsToRef(V,I,A){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:B.d;const E=t.Dot(V,I)+1;return E<F?Math.abs(V.x)>Math.abs(V.z)?A.set(-V.y,V.x,0,0):A.set(0,-V.z,V.y,0):(t.CrossToRef(V,I,L.tI[0]),A.set(L.tI[0].x,L.tI[0].y,L.tI[0].z,E)),A.normalize()}static RotationYawPitchRoll(V,I,A){const B=new W;return W.RotationYawPitchRollToRef(V,I,A,B),B}static RotationYawPitchRollToRef(V,I,A,B){const F=.5*A,E=.5*I,Y=.5*V,H=Math.sin(F),c=Math.cos(F),b=Math.sin(E),X=Math.cos(E),P=Math.sin(Y),J=Math.cos(Y);return B._x=J*b*c+P*X*H,B._y=P*X*c-J*b*H,B._z=J*X*H-P*b*c,B._w=J*X*c+P*b*H,B._isDirty=!0,B}static RotationAlphaBetaGamma(V,I,A){const B=new W;return W.RotationAlphaBetaGammaToRef(V,I,A,B),B}static RotationAlphaBetaGammaToRef(V,I,A,B){const F=.5*(A+V),E=.5*(A-V),Y=.5*I;return B._x=Math.cos(E)*Math.sin(Y),B._y=Math.sin(E)*Math.sin(Y),B._z=Math.sin(F)*Math.cos(Y),B._w=Math.cos(F)*Math.cos(Y),B._isDirty=!0,B}static RotationQuaternionFromAxis(V,I,A){const B=new W(0,0,0,0);return W.RotationQuaternionFromAxisToRef(V,I,A,B),B}static RotationQuaternionFromAxisToRef(V,I,A,B){const F=o.Matrix[0];return V=V.normalizeToRef(o.tI[0]),I=I.normalizeToRef(o.tI[1]),A=A.normalizeToRef(o.tI[2]),g.FromXYZAxesToRef(V,I,A,F),W.FromRotationMatrixToRef(F,B),B}static FromLookDirectionLH(V,I){const A=new W;return W.FromLookDirectionLHToRef(V,I,A),A}static FromLookDirectionLHToRef(V,I,A){const B=o.Matrix[0];return g.LookDirectionLHToRef(V,I,B),W.FromRotationMatrixToRef(B,A),A}static FromLookDirectionRH(V,I){const A=new W;return W.FromLookDirectionRHToRef(V,I,A),A}static FromLookDirectionRHToRef(V,I,A){const B=o.Matrix[0];return g.LookDirectionRHToRef(V,I,B),W.FromRotationMatrixToRef(B,A)}static Slerp(V,I,A){const B=W.Identity();return W.SlerpToRef(V,I,A,B),B}static SlerpToRef(V,I,A,B){let F,E,Y=V._x*I._x+V._y*I._y+V._z*I._z+V._w*I._w,H=!1;if(Y<0&&(H=!0,Y=-Y),Y>.999999)E=1-A,F=H?-A:A;else{const V=Math.acos(Y),I=1/Math.sin(V);E=Math.sin((1-A)*V)*I,F=H?-Math.sin(A*V)*I:Math.sin(A*V)*I}return B._x=E*V._x+F*I._x,B._y=E*V._y+F*I._y,B._z=E*V._z+F*I._z,B._w=E*V._w+F*I._w,B._isDirty=!0,B}static Hermite(V,I,A,B,F){const E=F*F,Y=F*E,H=2*Y-3*E+1,c=-2*Y+3*E,b=Y-2*E+F,X=Y-E,P=V._x*H+A._x*c+I._x*b+B._x*X,J=V._y*H+A._y*c+I._y*b+B._y*X,G=V._z*H+A._z*c+I._z*b+B._z*X,w=V._w*H+A._w*c+I._w*b+B._w*X;return new W(P,J,G,w)}static Hermite1stDerivative(V,I,A,B,F){const E=new W;return this.Hermite1stDerivativeToRef(V,I,A,B,F,E),E}static Hermite1stDerivativeToRef(V,I,A,B,F,E){const Y=F*F;return E._x=6*(Y-F)*V._x+(3*Y-4*F+1)*I._x+6*(-Y+F)*A._x+(3*Y-2*F)*B._x,E._y=6*(Y-F)*V._y+(3*Y-4*F+1)*I._y+6*(-Y+F)*A._y+(3*Y-2*F)*B._y,E._z=6*(Y-F)*V._z+(3*Y-4*F+1)*I._z+6*(-Y+F)*A._z+(3*Y-2*F)*B._z,E._w=6*(Y-F)*V._w+(3*Y-4*F+1)*I._w+6*(-Y+F)*A._w+(3*Y-2*F)*B._w,E._isDirty=!0,E}static Normalize(V){const I=W.Zero();return W.NormalizeToRef(V,I),I}static NormalizeToRef(V,I){return V.normalizeToRef(I),I}static Clamp(V,I,A){const B=new W;return W.ClampToRef(V,I,A,B),B}static ClampToRef(V,I,A,B){return B.XH((0,c.Clamp)(V.x,I.x,A.x),(0,c.Clamp)(V.y,I.y,A.y),(0,c.Clamp)(V.z,I.z,A.z),(0,c.Clamp)(V.w,I.w,A.w))}static Random(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new W((0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I))}static RandomToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).XH((0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I),(0,c.RandomRange)(V,I))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(V,I){return Math.sqrt(W.DistanceSquared(V,I))}static DistanceSquared(V,I){const A=V.x-I.x,B=V.y-I.y,F=V.z-I.z,E=V.w-I.w;return A*A+B*B+F*F+E*E}static Center(V,I){return W.CenterToRef(V,I,W.Zero())}static CenterToRef(V,I,A){return A.XH((V.x+I.x)/2,(V.y+I.y)/2,(V.z+I.z)/2,(V.w+I.w)/2)}}W._V8PerformanceHack=new W(.5,.5,.5,.5),Object.defineProperties(W.prototype,{dimension:{value:[4]},rank:{value:1}});class g{static get Use64Bits(){return Y.d.MatrixUse64Bits}get m(){return this.kY}markAsUpdated(){this.updateFlag=b._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(V){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=V,this._isIdentity3x2=V||A,this._isIdentityDirty=!this._isIdentity&&I,this._isIdentity3x2Dirty=!this._isIdentity3x2&&B}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,Y.d.MatrixTrackPrecisionChange&&Y.d.MatrixTrackedMatrices.push(this),this.kY=new Y.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const V=this.kY;this._isIdentity=1===V[0]&&0===V[1]&&0===V[2]&&0===V[3]&&0===V[4]&&1===V[5]&&0===V[6]&&0===V[7]&&0===V[8]&&0===V[9]&&1===V[10]&&0===V[11]&&0===V[12]&&0===V[13]&&0===V[14]&&1===V[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.kY[0]||1!==this.kY[5]||1!==this.kY[15]||0!==this.kY[1]||0!==this.kY[2]||0!==this.kY[3]||0!==this.kY[4]||0!==this.kY[6]||0!==this.kY[7]||0!==this.kY[8]||0!==this.kY[9]||0!==this.kY[10]||0!==this.kY[11]||0!==this.kY[12]||0!==this.kY[13]||0!==this.kY[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const V=this.kY,I=V[0],A=V[1],B=V[2],F=V[3],E=V[4],Y=V[5],H=V[6],c=V[7],b=V[8],X=V[9],P=V[10],J=V[11],G=V[12],w=V[13],t=V[14],u=V[15],W=P*u-t*J,g=X*u-w*J,o=X*t-w*P,L=b*u-G*J,z=b*t-P*G,m=b*w-G*X;return I*+(Y*W-H*g+c*o)+A*-(E*W-H*L+c*z)+B*+(E*g-Y*L+c*m)+F*-(E*o-Y*z+H*m)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!V)return this.kY;const A=this.kY;for(let B=0;B<16;B++)V[I+B]=A[B];return this}AH(){return this.kY}GA(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return g.FromArrayToRef(V,I,this)}XH(){for(var V=arguments.length,I=new Array(V),A=0;A<V;A++)I[A]=arguments[A];return g.FromArrayToRef(I,0,this)}set(){const V=this.kY;for(let I=0;I<16;I++)V[I]=I<0||arguments.length<=I?void 0:arguments[I];return this.markAsUpdated(),this}JH(V){const I=this.kY;for(let A=0;A<16;A++)I[A]=V;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return g.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(V){const I=new g;return this.addToRef(V,I),I}addToRef(V,I){const A=this.kY,B=I.kY,F=V.m;for(let E=0;E<16;E++)B[E]=A[E]+F[E];return I.markAsUpdated(),I}addToSelf(V){const I=this.kY,A=V.m;return I[0]+=A[0],I[1]+=A[1],I[2]+=A[2],I[3]+=A[3],I[4]+=A[4],I[5]+=A[5],I[6]+=A[6],I[7]+=A[7],I[8]+=A[8],I[9]+=A[9],I[10]+=A[10],I[11]+=A[11],I[12]+=A[12],I[13]+=A[13],I[14]+=A[14],I[15]+=A[15],this.markAsUpdated(),this}addInPlace(V){const I=this.kY,A=V.m;for(let B=0;B<16;B++)I[B]+=A[B];return this.markAsUpdated(),this}addInPlaceFromFloats(){const V=this.kY;for(let I=0;I<16;I++)V[I]+=I<0||arguments.length<=I?void 0:arguments[I];return this.markAsUpdated(),this}uI(V){const I=this.kY,A=V.m;for(let B=0;B<16;B++)I[B]-=A[B];return this.markAsUpdated(),this}subtractToRef(V,I){const A=this.kY,B=V.m,F=I.kY;for(let E=0;E<16;E++)F[E]=A[E]-B[E];return I.markAsUpdated(),I}wJ(V){const I=this.kY,A=V.m;for(let B=0;B<16;B++)I[B]-=A[B];return this.markAsUpdated(),this}subtractFromFloats(){for(var V=arguments.length,I=new Array(V),A=0;A<V;A++)I[A]=arguments[A];return this.subtractFromFloatsToRef(...I,new g)}subtractFromFloatsToRef(){for(var V=arguments.length,I=new Array(V),A=0;A<V;A++)I[A]=arguments[A];const B=I.pop(),F=this.kY,E=B.kY,Y=I;for(let H=0;H<16;H++)E[H]=F[H]-Y[H];return B.markAsUpdated(),B}invertToRef(V){return!0===this._isIdentity?(g.IdentityToRef(V),V):(J(this,V.AH())?V.markAsUpdated():V.B(this),V)}addAtIndex(V,I){return this.kY[V]+=I,this.markAsUpdated(),this}multiplyAtIndex(V,I){return this.kY[V]*=I,this.markAsUpdated(),this}setTranslationFromFloats(V,I,A){return this.kY[12]=V,this.kY[13]=I,this.kY[14]=A,this.markAsUpdated(),this}addTranslationFromFloats(V,I,A){return this.kY[12]+=V,this.kY[13]+=I,this.kY[14]+=A,this.markAsUpdated(),this}setTranslation(V){return this.setTranslationFromFloats(V._x,V._y,V._z)}getTranslation(){return new t(this.kY[12],this.kY[13],this.kY[14])}getTranslationToRef(V){return V.x=this.kY[12],V.y=this.kY[13],V.z=this.kY[14],V}removeRotationAndScaling(){const V=this.m;return g.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,V[12],V[13],V[14],V[15],this),this._updateIdentityStatus(0===V[12]&&0===V[13]&&0===V[14]&&1===V[15]),this}B(V){V.copyToArray(this.kY);const I=V;return this.updateFlag=I.updateFlag,this._updateIdentityStatus(I._isIdentity,I._isIdentityDirty,I._isIdentity3x2,I._isIdentity3x2Dirty),this}copyToArray(V){return P(this,V,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(V){const I=new g;return this.multiplyToRef(V,I),I}multiplyInPlace(V){const I=this.kY,A=V.m;for(let B=0;B<16;B++)I[B]*=A[B];return this.markAsUpdated(),this}multiplyByFloats(){const V=this.kY;for(let I=0;I<16;I++)V[I]*=I<0||arguments.length<=I?void 0:arguments[I];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var V=arguments.length,I=new Array(V),A=0;A<V;A++)I[A]=arguments[A];const B=I.pop(),F=this.kY,E=B.kY,Y=I;for(let H=0;H<16;H++)E[H]=F[H]*Y[H];return B.markAsUpdated(),B}multiplyToRef(V,I){return this._isIdentity?(I.B(V),I):V._isIdentity?(I.B(this),I):(this.multiplyToArray(V,I.kY,0),I.markAsUpdated(),I)}multiplyToArray(V,I,A){return X(this,V,I,A),this}divide(V){return this.divideToRef(V,new g)}divideToRef(V,I){const A=this.kY,B=V.m,F=I.kY;for(let E=0;E<16;E++)F[E]=A[E]/B[E];return I.markAsUpdated(),I}divideInPlace(V){const I=this.kY,A=V.m;for(let B=0;B<16;B++)I[B]/=A[B];return this.markAsUpdated(),this}minimizeInPlace(V){const I=this.kY,A=V.m;for(let B=0;B<16;B++)I[B]=Math.min(I[B],A[B]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const V=this.kY;for(let I=0;I<16;I++)V[I]=Math.min(V[I],I<0||arguments.length<=I?void 0:arguments[I]);return this.markAsUpdated(),this}maximizeInPlace(V){const I=this.kY,A=V.m;for(let B=0;B<16;B++)I[B]=Math.min(I[B],A[B]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const V=this.kY;for(let I=0;I<16;I++)V[I]=Math.min(V[I],I<0||arguments.length<=I?void 0:arguments[I]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new g)}negateInPlace(){const V=this.kY;for(let I=0;I<16;I++)V[I]=-V[I];return this.markAsUpdated(),this}negateToRef(V){const I=this.kY,A=V.kY;for(let B=0;B<16;B++)A[B]=-I[B];return V.markAsUpdated(),V}equals(V){const I=V;if(!I)return!1;if((this._isIdentity||I._isIdentity)&&!this._isIdentityDirty&&!I._isIdentityDirty)return this._isIdentity&&I._isIdentity;const A=this.m,B=I.m;return A[0]===B[0]&&A[1]===B[1]&&A[2]===B[2]&&A[3]===B[3]&&A[4]===B[4]&&A[5]===B[5]&&A[6]===B[6]&&A[7]===B[7]&&A[8]===B[8]&&A[9]===B[9]&&A[10]===B[10]&&A[11]===B[11]&&A[12]===B[12]&&A[13]===B[13]&&A[14]===B[14]&&A[15]===B[15]}equalsWithEpsilon(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const A=this.kY,B=V.m;for(let F=0;F<16;F++)if(!(0,c.WithinEpsilon)(A[F],B[F],I))return!1;return!0}equalsToFloats(){const V=this.kY;for(let I=0;I<16;I++)if(V[I]!=(I<0||arguments.length<=I?void 0:arguments[I]))return!1;return!0}floor(){return this.floorToRef(new g)}floorToRef(V){const I=this.kY,A=V.kY;for(let B=0;B<16;B++)A[B]=Math.floor(I[B]);return V.markAsUpdated(),V}fract(){return this.fractToRef(new g)}fractToRef(V){const I=this.kY,A=V.kY;for(let B=0;B<16;B++)A[B]=I[B]-Math.floor(I[B]);return V.markAsUpdated(),V}clone(){const V=new g;return V.B(this),V}getClassName(){return"Matrix"}getHashCode(){let V=G(this.kY[0]);for(let I=1;I<16;I++)V=397*V^G(this.kY[I]);return V}decomposeToTransformNode(V){return V.rotationQuaternion=V.rotationQuaternion||new W,this.decompose(V.PH,V.rotationQuaternion,V.position)}decompose(V,I,A,B){let F=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return A&&A.JH(0),V&&V.JH(1),I&&I.XH(0,0,0,1),!0;const E=this.kY;if(A&&A.XH(E[12],E[13],E[14]),(V=V||o.tI[0]).x=Math.sqrt(E[0]*E[0]+E[1]*E[1]+E[2]*E[2]),V.y=Math.sqrt(E[4]*E[4]+E[5]*E[5]+E[6]*E[6]),V.z=Math.sqrt(E[8]*E[8]+E[9]*E[9]+E[10]*E[10]),B){const I=(F?B.absoluteScaling.x:B.PH.x)<0?-1:1,A=(F?B.absoluteScaling.y:B.PH.y)<0?-1:1,E=(F?B.absoluteScaling.z:B.PH.z)<0?-1:1;V.x*=I,V.y*=A,V.z*=E}else this.determinant()<=0&&(V.y*=-1);if(0===V._x||0===V._y||0===V._z)return I&&I.XH(0,0,0,1),!1;if(I){const A=1/V._x,B=1/V._y,F=1/V._z;g.FromValuesToRef(E[0]*A,E[1]*A,E[2]*A,0,E[4]*B,E[5]*B,E[6]*B,0,E[8]*F,E[9]*F,E[10]*F,0,0,0,0,1,o.Matrix[0]),W.FromRotationMatrixToRef(o.Matrix[0],I)}return!0}getRow(V){if(V<0||V>3)return null;const I=4*V;return new u(this.kY[I+0],this.kY[I+1],this.kY[I+2],this.kY[I+3])}getRowToRef(V,I){if(V>=0&&V<=3){const A=4*V;I.x=this.kY[A+0],I.y=this.kY[A+1],I.z=this.kY[A+2],I.w=this.kY[A+3]}return I}setRow(V,I){return this.setRowFromFloats(V,I.x,I.y,I.z,I.w)}transpose(){const V=new g;return g.TransposeToRef(this,V),V}transposeToRef(V){return g.TransposeToRef(this,V),V}setRowFromFloats(V,I,A,B,F){if(V<0||V>3)return this;const E=4*V;return this.kY[E+0]=I,this.kY[E+1]=A,this.kY[E+2]=B,this.kY[E+3]=F,this.markAsUpdated(),this}scale(V){const I=new g;return this.scaleToRef(V,I),I}scaleToRef(V,I){for(let A=0;A<16;A++)I.kY[A]=this.kY[A]*V;return I.markAsUpdated(),I}scaleAndAddToRef(V,I){for(let A=0;A<16;A++)I.kY[A]+=this.kY[A]*V;return I.markAsUpdated(),I}scaleInPlace(V){const I=this.kY;for(let A=0;A<16;A++)I[A]*=V;return this.markAsUpdated(),this}toNormalMatrix(V){const I=o.Matrix[0];this.invertToRef(I),I.transposeToRef(V);const A=V.kY;return g.FromValuesToRef(A[0],A[1],A[2],0,A[4],A[5],A[6],0,A[8],A[9],A[10],0,0,0,0,1,V),V}getRotationMatrix(){const V=new g;return this.getRotationMatrixToRef(V),V}getRotationMatrixToRef(V){const I=o.tI[0];if(!this.decompose(I))return g.IdentityToRef(V),V;const A=this.kY,B=1/I._x,F=1/I._y,E=1/I._z;return g.FromValuesToRef(A[0]*B,A[1]*B,A[2]*B,0,A[4]*F,A[5]*F,A[6]*F,0,A[8]*E,A[9]*E,A[10]*E,0,0,0,0,1,V),V}toggleModelMatrixHandInPlace(){const V=this.kY;return V[2]*=-1,V[6]*=-1,V[8]*=-1,V[9]*=-1,V[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const V=this.kY;return V[8]*=-1,V[9]*=-1,V[10]*=-1,V[11]*=-1,this.markAsUpdated(),this}static LI(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const A=new g;return g.FromArrayToRef(V,I,A),A}static FromArrayToRef(V,I,A){for(let B=0;B<16;B++)A.kY[B]=V[B+I];return A.markAsUpdated(),A}static FromFloat32ArrayToRefScaled(V,I,A,B){return B.kY[0]=V[0+I]*A,B.kY[1]=V[1+I]*A,B.kY[2]=V[2+I]*A,B.kY[3]=V[3+I]*A,B.kY[4]=V[4+I]*A,B.kY[5]=V[5+I]*A,B.kY[6]=V[6+I]*A,B.kY[7]=V[7+I]*A,B.kY[8]=V[8+I]*A,B.kY[9]=V[9+I]*A,B.kY[10]=V[10+I]*A,B.kY[11]=V[11+I]*A,B.kY[12]=V[12+I]*A,B.kY[13]=V[13+I]*A,B.kY[14]=V[14+I]*A,B.kY[15]=V[15+I]*A,B.markAsUpdated(),B}static get IdentityReadOnly(){return g._IdentityReadOnly}static FromValuesToRef(V,I,A,B,F,E,Y,H,c,b,X,P,J,G,w,t,u){const W=u.kY;W[0]=V,W[1]=I,W[2]=A,W[3]=B,W[4]=F,W[5]=E,W[6]=Y,W[7]=H,W[8]=c,W[9]=b,W[10]=X,W[11]=P,W[12]=J,W[13]=G,W[14]=w,W[15]=t,u.markAsUpdated()}static FromValues(V,I,A,B,F,E,Y,H,c,b,X,P,J,G,w,t){const u=new g,W=u.kY;return W[0]=V,W[1]=I,W[2]=A,W[3]=B,W[4]=F,W[5]=E,W[6]=Y,W[7]=H,W[8]=c,W[9]=b,W[10]=X,W[11]=P,W[12]=J,W[13]=G,W[14]=w,W[15]=t,u.markAsUpdated(),u}static Compose(V,I,A){const B=new g;return g.ComposeToRef(V,I,A,B),B}static ComposeToRef(V,I,A,B){const F=B.kY,E=I._x,Y=I._y,H=I._z,c=I._w,b=E+E,X=Y+Y,P=H+H,J=E*b,G=E*X,w=E*P,t=Y*X,u=Y*P,W=H*P,g=c*b,o=c*X,L=c*P,z=V._x,m=V._y,s=V._z;return F[0]=(1-(t+W))*z,F[1]=(G+L)*z,F[2]=(w-o)*z,F[3]=0,F[4]=(G-L)*m,F[5]=(1-(J+W))*m,F[6]=(u+g)*m,F[7]=0,F[8]=(w+o)*s,F[9]=(u-g)*s,F[10]=(1-(J+t))*s,F[11]=0,F[12]=A._x,F[13]=A._y,F[14]=A._z,F[15]=1,B.markAsUpdated(),B}static Identity(){const V=g.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return V._updateIdentityStatus(!0),V}static IdentityToRef(V){return g.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,V),V._updateIdentityStatus(!0),V}static Zero(){const V=g.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return V._updateIdentityStatus(!1),V}static RotationX(V){const I=new g;return g.RotationXToRef(V,I),I}static Invert(V){const I=new g;return V.invertToRef(I),I}static RotationXToRef(V,I){const A=Math.sin(V),B=Math.cos(V);return g.FromValuesToRef(1,0,0,0,0,B,A,0,0,-A,B,0,0,0,0,1,I),I._updateIdentityStatus(1===B&&0===A),I}static RotationY(V){const I=new g;return g.RotationYToRef(V,I),I}static RotationYToRef(V,I){const A=Math.sin(V),B=Math.cos(V);return g.FromValuesToRef(B,0,-A,0,0,1,0,0,A,0,B,0,0,0,0,1,I),I._updateIdentityStatus(1===B&&0===A),I}static RotationZ(V){const I=new g;return g.RotationZToRef(V,I),I}static RotationZToRef(V,I){const A=Math.sin(V),B=Math.cos(V);return g.FromValuesToRef(B,A,0,0,-A,B,0,0,0,0,1,0,0,0,0,1,I),I._updateIdentityStatus(1===B&&0===A),I}static RotationAxis(V,I){const A=new g;return g.RotationAxisToRef(V,I,A),A}static RotationAxisToRef(V,I,A){const B=Math.sin(-I),F=Math.cos(-I),E=1-F;V=V.normalizeToRef(o.tI[0]);const Y=A.kY;return Y[0]=V._x*V._x*E+F,Y[1]=V._x*V._y*E-V._z*B,Y[2]=V._x*V._z*E+V._y*B,Y[3]=0,Y[4]=V._y*V._x*E+V._z*B,Y[5]=V._y*V._y*E+F,Y[6]=V._y*V._z*E-V._x*B,Y[7]=0,Y[8]=V._z*V._x*E-V._y*B,Y[9]=V._z*V._y*E+V._x*B,Y[10]=V._z*V._z*E+F,Y[11]=0,Y[12]=0,Y[13]=0,Y[14]=0,Y[15]=1,A.markAsUpdated(),A}static RotationAlignToRef(V,I,A){let F=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const E=t.Dot(I,V),Y=A.kY;if(E<-1+B.d)Y[0]=-1,Y[1]=0,Y[2]=0,Y[3]=0,Y[4]=0,Y[5]=F?1:-1,Y[6]=0,Y[7]=0,Y[8]=0,Y[9]=0,Y[10]=F?-1:1,Y[11]=0;else{const A=t.Cross(I,V),B=1/(1+E);Y[0]=A._x*A._x*B+E,Y[1]=A._y*A._x*B-A._z,Y[2]=A._z*A._x*B+A._y,Y[3]=0,Y[4]=A._x*A._y*B+A._z,Y[5]=A._y*A._y*B+E,Y[6]=A._z*A._y*B-A._x,Y[7]=0,Y[8]=A._x*A._z*B-A._y,Y[9]=A._y*A._z*B+A._x,Y[10]=A._z*A._z*B+E,Y[11]=0}return Y[12]=0,Y[13]=0,Y[14]=0,Y[15]=1,A.markAsUpdated(),A}static RotationYawPitchRoll(V,I,A){const B=new g;return g.RotationYawPitchRollToRef(V,I,A,B),B}static RotationYawPitchRollToRef(V,I,A,B){return W.RotationYawPitchRollToRef(V,I,A,o.Quaternion[0]),o.Quaternion[0].toRotationMatrix(B),B}static Scaling(V,I,A){const B=new g;return g.ScalingToRef(V,I,A,B),B}static ScalingToRef(V,I,A,B){return g.FromValuesToRef(V,0,0,0,0,I,0,0,0,0,A,0,0,0,0,1,B),B._updateIdentityStatus(1===V&&1===I&&1===A),B}static Translation(V,I,A){const B=new g;return g.TranslationToRef(V,I,A,B),B}static TranslationToRef(V,I,A,B){return g.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,V,I,A,1,B),B._updateIdentityStatus(0===V&&0===I&&0===A),B}static Lerp(V,I,A){const B=new g;return g.LerpToRef(V,I,A,B),B}static LerpToRef(V,I,A,B){const F=B.kY,E=V.m,Y=I.m;for(let H=0;H<16;H++)F[H]=E[H]*(1-A)+Y[H]*A;return B.markAsUpdated(),B}static DecomposeLerp(V,I,A){const B=new g;return g.DecomposeLerpToRef(V,I,A,B),B}static DecomposeLerpToRef(V,I,A,B){const F=o.tI[0],E=o.Quaternion[0],Y=o.tI[1];V.decompose(F,E,Y);const H=o.tI[2],c=o.Quaternion[1],b=o.tI[3];I.decompose(H,c,b);const X=o.tI[4];t.LerpToRef(F,H,A,X);const P=o.Quaternion[2];W.SlerpToRef(E,c,A,P);const J=o.tI[5];return t.LerpToRef(Y,b,A,J),g.ComposeToRef(X,P,J,B),B}static LookAtLH(V,I,A){const B=new g;return g.LookAtLHToRef(V,I,A,B),B}static LookAtLHToRef(V,I,A,B){const F=o.tI[0],E=o.tI[1],Y=o.tI[2];I.subtractToRef(V,Y),Y.normalize(),t.CrossToRef(A,Y,F);const H=F.lengthSquared();0===H?F.x=1:F.normalizeFromLength(Math.sqrt(H)),t.CrossToRef(Y,F,E),E.normalize();const c=-t.Dot(F,V),b=-t.Dot(E,V),X=-t.Dot(Y,V);return g.FromValuesToRef(F._x,E._x,Y._x,0,F._y,E._y,Y._y,0,F._z,E._z,Y._z,0,c,b,X,1,B),B}static LookAtRH(V,I,A){const B=new g;return g.LookAtRHToRef(V,I,A,B),B}static LookAtRHToRef(V,I,A,B){const F=o.tI[0],E=o.tI[1],Y=o.tI[2];V.subtractToRef(I,Y),Y.normalize(),t.CrossToRef(A,Y,F);const H=F.lengthSquared();0===H?F.x=1:F.normalizeFromLength(Math.sqrt(H)),t.CrossToRef(Y,F,E),E.normalize();const c=-t.Dot(F,V),b=-t.Dot(E,V),X=-t.Dot(Y,V);return g.FromValuesToRef(F._x,E._x,Y._x,0,F._y,E._y,Y._y,0,F._z,E._z,Y._z,0,c,b,X,1,B),B}static LookDirectionLH(V,I){const A=new g;return g.LookDirectionLHToRef(V,I,A),A}static LookDirectionLHToRef(V,I,A){const B=o.tI[0];B.B(V),B.scaleInPlace(-1);const F=o.tI[1];return t.CrossToRef(I,B,F),g.FromValuesToRef(F._x,F._y,F._z,0,I._x,I._y,I._z,0,B._x,B._y,B._z,0,0,0,0,1,A),A}static LookDirectionRH(V,I){const A=new g;return g.LookDirectionRHToRef(V,I,A),A}static LookDirectionRHToRef(V,I,A){const B=o.tI[2];return t.CrossToRef(I,V,B),g.FromValuesToRef(B._x,B._y,B._z,0,I._x,I._y,I._z,0,V._x,V._y,V._z,0,0,0,0,1,A),A}static OrthoLH(V,I,A,B,F){const E=new g;return g.OrthoLHToRef(V,I,A,B,E,F),E}static OrthoLHToRef(V,I,A,B,F,E){const Y=2/V,H=2/I,c=2/(B-A),b=-(B+A)/(B-A);return g.FromValuesToRef(Y,0,0,0,0,H,0,0,0,0,c,0,0,0,b,1,F),E&&F.multiplyToRef(z,F),F._updateIdentityStatus(1===Y&&1===H&&1===c&&0===b),F}static OrthoOffCenterLH(V,I,A,B,F,E,Y){const H=new g;return g.OrthoOffCenterLHToRef(V,I,A,B,F,E,H,Y),H}static OrthoOffCenterLHToRef(V,I,A,B,F,E,Y,H){const c=2/(I-V),b=2/(B-A),X=2/(E-F),P=-(E+F)/(E-F),J=(V+I)/(V-I),G=(B+A)/(A-B);return g.FromValuesToRef(c,0,0,0,0,b,0,0,0,0,X,0,J,G,P,1,Y),H&&Y.multiplyToRef(z,Y),Y.markAsUpdated(),Y}static ObliqueOffCenterLHToRef(V,I,A,B,F,E,Y,H,c,b,X){const P=-Y*Math.cos(H),J=-Y*Math.sin(H);return g.TranslationToRef(0,0,-c,o.Matrix[1]),g.FromValuesToRef(1,0,0,0,0,1,0,0,P,J,1,0,0,0,0,1,o.Matrix[0]),o.Matrix[1].multiplyToRef(o.Matrix[0],o.Matrix[0]),g.TranslationToRef(0,0,c,o.Matrix[1]),o.Matrix[0].multiplyToRef(o.Matrix[1],o.Matrix[0]),g.OrthoOffCenterLHToRef(V,I,A,B,F,E,b,X),o.Matrix[0].multiplyToRef(b,b),b}static OrthoOffCenterRH(V,I,A,B,F,E,Y){const H=new g;return g.OrthoOffCenterRHToRef(V,I,A,B,F,E,H,Y),H}static OrthoOffCenterRHToRef(V,I,A,B,F,E,Y,H){return g.OrthoOffCenterLHToRef(V,I,A,B,F,E,Y,H),Y.kY[10]*=-1,Y}static ObliqueOffCenterRHToRef(V,I,A,B,F,E,Y,H,c,b,X){const P=Y*Math.cos(H),J=Y*Math.sin(H);return g.TranslationToRef(0,0,c,o.Matrix[1]),g.FromValuesToRef(1,0,0,0,0,1,0,0,P,J,1,0,0,0,0,1,o.Matrix[0]),o.Matrix[1].multiplyToRef(o.Matrix[0],o.Matrix[0]),g.TranslationToRef(0,0,-c,o.Matrix[1]),o.Matrix[0].multiplyToRef(o.Matrix[1],o.Matrix[0]),g.OrthoOffCenterRHToRef(V,I,A,B,F,E,b,X),o.Matrix[0].multiplyToRef(b,b),b}static PerspectiveLH(V,I,A,B,F){let E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const Y=new g,H=2*A/V,c=2*A/I,b=(B+A)/(B-A),X=-2*B*A/(B-A),P=Math.tan(E);return g.FromValuesToRef(H,0,0,0,0,c,0,P,0,0,b,1,0,0,X,0,Y),F&&Y.multiplyToRef(z,Y),Y._updateIdentityStatus(!1),Y}static PerspectiveFovLH(V,I,A,B,F){let E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const H=new g;return g.PerspectiveFovLHToRef(V,I,A,B,H,!0,F,E,Y),H}static PerspectiveFovLHToRef(V,I,A,B,F){let E=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,H=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const b=A,X=B,P=1/Math.tan(.5*V),J=E?P/I:P,G=E?P:P*I,w=c&&0===b?-1:0!==X?(X+b)/(X-b):1,t=c&&0===b?2*X:0!==X?-2*X*b/(X-b):-2*b,u=Math.tan(H);return g.FromValuesToRef(J,0,0,0,0,G,0,u,0,0,w,1,0,0,t,0,F),Y&&F.multiplyToRef(z,F),F._updateIdentityStatus(!1),F}static PerspectiveFovReverseLHToRef(V,I,A,B,F){let E=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,H=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const c=1/Math.tan(.5*V),b=E?c/I:c,X=E?c:c*I,P=Math.tan(H);return g.FromValuesToRef(b,0,0,0,0,X,0,P,0,0,-A,1,0,0,1,0,F),Y&&F.multiplyToRef(z,F),F._updateIdentityStatus(!1),F}static PerspectiveFovRH(V,I,A,B,F){let E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const H=new g;return g.PerspectiveFovRHToRef(V,I,A,B,H,!0,F,E,Y),H}static PerspectiveFovRHToRef(V,I,A,B,F){let E=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,H=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const b=A,X=B,P=1/Math.tan(.5*V),J=E?P/I:P,G=E?P:P*I,w=c&&0===b?1:0!==X?-(X+b)/(X-b):-1,t=c&&0===b?2*X:0!==X?-2*X*b/(X-b):-2*b,u=Math.tan(H);return g.FromValuesToRef(J,0,0,0,0,G,0,u,0,0,w,-1,0,0,t,0,F),Y&&F.multiplyToRef(z,F),F._updateIdentityStatus(!1),F}static PerspectiveFovReverseRHToRef(V,I,A,B,F){let E=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,H=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const c=1/Math.tan(.5*V),b=E?c/I:c,X=E?c:c*I,P=Math.tan(H);return g.FromValuesToRef(b,0,0,0,0,X,0,P,0,0,-A,-1,0,0,-1,0,F),Y&&F.multiplyToRef(z,F),F._updateIdentityStatus(!1),F}static GetFinalMatrix(V,I,A,B,F,E){const Y=V.width,H=V.height,c=V.x,b=V.y,X=g.FromValues(Y/2,0,0,0,0,-H/2,0,0,0,0,E-F,0,c+Y/2,H/2+b,F,1),P=new g;return I.multiplyToRef(A,P),P.multiplyToRef(B,P),P.multiplyToRef(X,P)}static GetAsMatrix2x2(V){const I=V.m,A=[I[0],I[1],I[4],I[5]];return Y.d.MatrixUse64Bits?A:new Float32Array(A)}static GetAsMatrix3x3(V){const I=V.m,A=[I[0],I[1],I[2],I[4],I[5],I[6],I[8],I[9],I[10]];return Y.d.MatrixUse64Bits?A:new Float32Array(A)}static Transpose(V){const I=new g;return g.TransposeToRef(V,I),I}static TransposeToRef(V,I){const A=V.m,B=A[0],F=A[4],E=A[8],Y=A[12],H=A[1],c=A[5],b=A[9],X=A[13],P=A[2],J=A[6],G=A[10],w=A[14],t=A[3],u=A[7],W=A[11],g=A[15],o=I.kY;return o[0]=B,o[1]=F,o[2]=E,o[3]=Y,o[4]=H,o[5]=c,o[6]=b,o[7]=X,o[8]=P,o[9]=J,o[10]=G,o[11]=w,o[12]=t,o[13]=u,o[14]=W,o[15]=g,I.markAsUpdated(),I._updateIdentityStatus(V._isIdentity,V._isIdentityDirty),I}static Reflection(V){const I=new g;return g.ReflectionToRef(V,I),I}static ReflectionToRef(V,I){V.normalize();const A=V.normal.x,B=V.normal.y,F=V.normal.z,E=-2*A,Y=-2*B,H=-2*F;return g.FromValuesToRef(E*A+1,Y*A,H*A,0,E*B,Y*B+1,H*B,0,E*F,Y*F,H*F+1,0,E*V.d,Y*V.d,H*V.d,1,I),I}static FromXYZAxesToRef(V,I,A,B){return g.FromValuesToRef(V._x,V._y,V._z,0,I._x,I._y,I._z,0,A._x,A._y,A._z,0,0,0,0,1,B),B}static FromQuaternionToRef(V,I){const A=V._x*V._x,B=V._y*V._y,F=V._z*V._z,E=V._x*V._y,Y=V._z*V._w,H=V._z*V._x,c=V._y*V._w,b=V._y*V._z,X=V._x*V._w;return I.kY[0]=1-2*(B+F),I.kY[1]=2*(E+Y),I.kY[2]=2*(H-c),I.kY[3]=0,I.kY[4]=2*(E-Y),I.kY[5]=1-2*(F+A),I.kY[6]=2*(b+X),I.kY[7]=0,I.kY[8]=2*(H+c),I.kY[9]=2*(b-X),I.kY[10]=1-2*(B+A),I.kY[11]=0,I.kY[12]=0,I.kY[13]=0,I.kY[14]=0,I.kY[15]=1,I.markAsUpdated(),I}}g._IdentityReadOnly=g.Identity(),Object.defineProperties(g.prototype,{dimension:{value:[4,4]},rank:{value:2}});class o{}o.tI=(0,F.c)(11,t.Zero),o.Matrix=(0,F.c)(2,g.Identity),o.Quaternion=(0,F.c)(3,W.Zero);class L{}L.Vector2=(0,F.c)(3,w.Zero),L.tI=(0,F.c)(13,t.Zero),L.Vector4=(0,F.c)(3,u.Zero),L.Quaternion=(0,F.c)(3,W.Zero),L.Matrix=(0,F.c)(8,g.Identity),(0,E.e)("BABYLON.Vector2",w),(0,E.e)("BABYLON.Vector3",t),(0,E.e)("BABYLON.Vector4",u),(0,E.e)("BABYLON.Matrix",g);const z=g.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11240:(V,I,A)=>{function B(V,I){const A=[];for(let B=0;B<V;++B)A.push(I());return A}function F(V,I){return B(V,I)}A.d(I,{b:()=>B,c:()=>F,d:()=>Y});const E=["push","splice","pop","shift","unshift"];function Y(V,I){const A=E.map((A=>function(V,I,A){const B=V[I];if("function"!==typeof B)return null;const F=function(){const B=V.length,E=F.previous.apply(V,arguments);return A(I,B),E};return B.next=F,F.previous=B,V[I]=F,()=>{const A=F.previous;if(!A)return;const B=F.next;B?(A.next=B,B.previous=A):(A.next=void 0,V[I]=A),F.next=void 0,F.previous=void 0}}(V,A,I)));return()=>{for(const V of A)null===V||void 0===V||V()}}}}]);