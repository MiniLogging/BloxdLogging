"use strict";(self.fwuvyyymhp8=self.fwuvyyymhp8||[]).push([[14],{12389:(N,U,V)=>{V.d(U,{d:()=>q,f:()=>n,j:()=>A,n:()=>t});const A=1/2.2,t=2.2,n=(1+Math.sqrt(5))/2,q=.001},12395:(N,U,V)=>{function A(N){return parseInt(N.toString().replace(/\W/g,""))}function t(N,U){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(N-U)<=V}function n(N,U,V){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return N<U-A||N>V+A}function q(N,U){return N===U?N:Math.random()*(U-N)+N}function i(N,U,V){return N+(U-N)*V}function z(N,U,V){let A=J(U-N,360);return A>180&&(A-=360),N+A*k(V)}function S(N,U,V){let A=0;return A=N!=U?k((V-N)/(U-N)):0,A}function E(N,U,V,A,t){const n=t*t,q=t*n;return N*(2*q-3*n+1)+V*(-2*q+3*n)+U*(q-2*n+t)+A*(q-n)}function p(N,U,V,A,t){const n=t*t;return 6*(n-t)*N+(3*n-4*t+1)*U+6*(-n+t)*V+(3*n-2*t)*A}function k(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(V,Math.max(U,N))}function B(N){return N-=2*Math.PI*Math.floor((N+Math.PI)/(2*Math.PI))}function C(N){const U=N.toString(16);return N<=15?("0"+U).toUpperCase():U.toUpperCase()}function x(N){if(Math.log2)return Math.floor(Math.log2(N));if(N<0)return NaN;if(0===N)return-1/0;let U=0;if(N<1){for(;N<1;)U++,N*=2;U=-U}else if(N>1)for(;N>1;)U++,N=Math.floor(N/2);return U}function J(N,U){return N-Math.floor(N/U)*U}function d(N,U,V){return(N-U)/(V-U)}function r(N,U,V){return N*(V-U)+U}function v(N,U){let V=J(U-N,360);return V>180&&(V-=360),V}function h(N,U){const V=J(N,2*U);return U-Math.abs(V-U)}function c(N,U,V){let A=k(V);return A=-2*A*A*A+3*A*A,U*A+N*(1-A)}function H(N,U,V){let A=0;return A=Math.abs(U-N)<=V?U:N+Math.sign(U-N)*V,A}function Y(N,U,V){const A=v(N,U);let t=0;return t=-V<A&&A<V?U:H(N,U=N+A,V),t}function W(N,U,V){return(N-U)/(V-U)}function s(N,U,V){return(V-U)*N+U}function M(N,U){const V=N%U;return 0===V?U:M(U,V)}V.r(U),V.d(U,{Clamp:()=>k,DeltaAngle:()=>v,Denormalize:()=>r,ExtractAsInt:()=>A,Hermite:()=>E,Hermite1stDerivative:()=>p,HighestCommonFactor:()=>M,ILog2:()=>x,InverseLerp:()=>S,Lerp:()=>i,LerpAngle:()=>z,MoveTowards:()=>H,MoveTowardsAngle:()=>Y,Normalize:()=>d,NormalizeRadians:()=>B,OutsideRange:()=>n,PercentToRange:()=>s,PingPong:()=>h,RandomRange:()=>q,RangeToPercent:()=>W,Repeat:()=>J,SmoothStep:()=>c,ToHex:()=>C,WithinEpsilon:()=>t})},12383:(N,U,V)=>{V.r(U),V.d(U,{Matrix:()=>r,Quaternion:()=>d,TmpVectors:()=>h,Vector2:()=>C,CU:()=>x,Vector4:()=>J});var A=V(12389),t=V(12392),n=V(12344),q=V(12313),i=V(12223),z=V(12395);class S{}function E(N,U,V){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const t=N.pi(),n=U.pi(),q=t[0],i=t[1],z=t[2],S=t[3],E=t[4],p=t[5],k=t[6],B=t[7],C=t[8],x=t[9],J=t[10],d=t[11],r=t[12],v=t[13],h=t[14],c=t[15],H=n[0],Y=n[1],W=n[2],s=n[3],M=n[4],a=n[5],mN=n[6],w=n[7],X=n[8],e=n[9],Q=n[10],u=n[11],L=n[12],I=n[13],o=n[14],R=n[15];V[A]=q*H+i*M+z*X+S*L,V[A+1]=q*Y+i*a+z*e+S*I,V[A+2]=q*W+i*mN+z*Q+S*o,V[A+3]=q*s+i*w+z*u+S*R,V[A+4]=E*H+p*M+k*X+B*L,V[A+5]=E*Y+p*a+k*e+B*I,V[A+6]=E*W+p*mN+k*Q+B*o,V[A+7]=E*s+p*w+k*u+B*R,V[A+8]=C*H+x*M+J*X+d*L,V[A+9]=C*Y+x*a+J*e+d*I,V[A+10]=C*W+x*mN+J*Q+d*o,V[A+11]=C*s+x*w+J*u+d*R,V[A+12]=r*H+v*M+h*X+c*L,V[A+13]=r*Y+v*a+h*e+c*I,V[A+14]=r*W+v*mN+h*Q+c*o,V[A+15]=r*s+v*w+h*u+c*R}function p(N,U){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const A=N.pi();U[V]=A[0],U[V+1]=A[1],U[V+2]=A[2],U[V+3]=A[3],U[V+4]=A[4],U[V+5]=A[5],U[V+6]=A[6],U[V+7]=A[7],U[V+8]=A[8],U[V+9]=A[9],U[V+10]=A[10],U[V+11]=A[11],U[V+12]=A[12],U[V+13]=A[13],U[V+14]=A[14],U[V+15]=A[15]}function k(N,U){const V=N.pi(),A=V[0],t=V[1],n=V[2],q=V[3],i=V[4],z=V[5],S=V[6],E=V[7],p=V[8],k=V[9],B=V[10],C=V[11],x=V[12],J=V[13],d=V[14],r=V[15],v=B*r-d*C,h=k*r-J*C,c=k*d-J*B,H=p*r-x*C,Y=p*d-B*x,W=p*J-x*k,s=+(z*v-S*h+E*c),M=-(i*v-S*H+E*Y),a=+(i*h-z*H+E*W),mN=-(i*c-z*Y+S*W),w=A*s+t*M+n*a+q*mN;if(0===w)return!1;const X=1/w,e=S*r-d*E,Q=z*r-J*E,u=z*d-J*S,L=i*r-x*E,I=i*d-x*S,o=i*J-x*z,R=S*C-B*E,D=z*C-k*E,G=z*B-k*S,g=i*C-p*E,l=i*B-p*S,K=i*k-p*z,j=-(t*v-n*h+q*c),F=+(A*v-n*H+q*Y),P=-(A*h-t*H+q*W),T=+(A*c-t*Y+n*W),f=+(t*e-n*Q+q*u),O=-(A*e-n*L+q*I),Z=+(A*Q-t*L+q*o),b=-(A*u-t*I+n*o),y=-(t*R-n*D+q*G),NN=+(A*R-n*g+q*l),UN=-(A*D-t*g+q*K),VN=+(A*G-t*l+n*K);return U[0]=s*X,U[1]=j*X,U[2]=f*X,U[3]=y*X,U[4]=M*X,U[5]=F*X,U[6]=O*X,U[7]=NN*X,U[8]=a*X,U[9]=P*X,U[10]=Z*X,U[11]=UN*X,U[12]=mN*X,U[13]=T*X,U[14]=b*X,U[15]=VN*X,!0}S._UpdateFlagSeed=0;const B=N=>parseInt(N.toString().replace(/\W/g,""));class C{constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=N,this.y=U}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let N=B(this.x);return N=397*N^B(this.y),N}toArray(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[U]=this.x,N[U+1]=this.y,this}BV(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C.FromArrayToRef(N,U,this),this}pi(){return[this.x,this.y]}A(N){return this.x=N.x,this.y=N.y,this}hi(N,U){return this.x=N,this.y=U,this}set(N,U){return this.hi(N,U)}Hi(N){return this.hi(N,N)}add(N){return new C(this.x+N.x,this.y+N.y)}addToRef(N,U){return U.x=this.x+N.x,U.y=this.y+N.y,U}addInPlace(N){return this.x+=N.x,this.y+=N.y,this}addInPlaceFromFloats(N,U){return this.x+=N,this.y+=U,this}addVector3(N){return new C(this.x+N.x,this.y+N.y)}xU(N){return new C(this.x-N.x,this.y-N.y)}subtractToRef(N,U){return U.x=this.x-N.x,U.y=this.y-N.y,U}Vp(N){return this.x-=N.x,this.y-=N.y,this}multiplyInPlace(N){return this.x*=N.x,this.y*=N.y,this}multiply(N){return new C(this.x*N.x,this.y*N.y)}multiplyToRef(N,U){return U.x=this.x*N.x,U.y=this.y*N.y,U}multiplyByFloats(N,U){return new C(this.x*N,this.y*U)}divide(N){return new C(this.x/N.x,this.y/N.y)}divideToRef(N,U){return U.x=this.x/N.x,U.y=this.y/N.y,U}divideInPlace(N){return this.x=this.x/N.x,this.y=this.y/N.y,this}minimizeInPlace(N){return this.minimizeInPlaceFromFloats(N.x,N.y)}maximizeInPlace(N){return this.maximizeInPlaceFromFloats(N.x,N.y)}minimizeInPlaceFromFloats(N,U){return this.x=Math.min(N,this.x),this.y=Math.min(U,this.y),this}maximizeInPlaceFromFloats(N,U){return this.x=Math.max(N,this.x),this.y=Math.max(U,this.y),this}subtractFromFloats(N,U){return new C(this.x-N,this.y-U)}subtractFromFloatsToRef(N,U,V){return V.x=this.x-N,V.y=this.y-U,V}negate(){return new C(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(N){return N.x=-this.x,N.y=-this.y,N}scaleInPlace(N){return this.x*=N,this.y*=N,this}scale(N){return new C(this.x*N,this.y*N)}scaleToRef(N,U){return U.x=this.x*N,U.y=this.y*N,U}scaleAndAddToRef(N,U){return U.x+=this.x*N,U.y+=this.y*N,U}equals(N){return N&&this.x===N.x&&this.y===N.y}equalsWithEpsilon(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.d;return N&&(0,z.WithinEpsilon)(this.x,N.x,U)&&(0,z.WithinEpsilon)(this.y,N.y,U)}equalsToFloats(N,U){return this.x===N&&this.y===U}floor(){return new C(Math.floor(this.x),Math.floor(this.y))}floorToRef(N){return N.x=Math.floor(this.x),N.y=Math.floor(this.y),N}fract(){return new C(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(N){return N.x=this.x-Math.floor(this.x),N.y=this.y-Math.floor(this.y),N}rotate(N){return this.rotateToRef(N,new C)}rotateToRef(N,U){const V=Math.cos(N),A=Math.sin(N);return U.x=V*this.x-A*this.y,U.y=A*this.x+V*this.y,U}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){const N=new C;return this.normalizeToRef(N),N}normalizeToRef(N){const U=this.length();return 0===U&&(N.x=this.x,N.y=this.y),this.scaleToRef(1/U,N)}clone(){return new C(this.x,this.y)}dot(N){return this.x*N.x+this.y*N.y}static Zero(){return new C(0,0)}static One(){return new C(1,1)}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new C((0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).hi((0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U))}static get ZeroReadOnly(){return C._ZeroReadOnly}static vU(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new C(N[U],N[U+1])}static FromArrayToRef(N,U,V){return V.x=N[U],V.y=N[U+1],V}static FromFloatsToRef(N,U,V){return V.hi(N,U),V}static CatmullRom(N,U,V,A,t){const n=t*t,q=t*n,i=.5*(2*U.x+(-N.x+V.x)*t+(2*N.x-5*U.x+4*V.x-A.x)*n+(-N.x+3*U.x-3*V.x+A.x)*q),z=.5*(2*U.y+(-N.y+V.y)*t+(2*N.y-5*U.y+4*V.y-A.y)*n+(-N.y+3*U.y-3*V.y+A.y)*q);return new C(i,z)}static ClampToRef(N,U,V,A){return A.x=(0,z.Clamp)(N.x,U.x,V.x),A.y=(0,z.Clamp)(N.y,U.y,V.y),A}static Clamp(N,U,V){const A=(0,z.Clamp)(N.x,U.x,V.x),t=(0,z.Clamp)(N.y,U.y,V.y);return new C(A,t)}static Hermite(N,U,V,A,t){const n=t*t,q=t*n,i=2*q-3*n+1,z=-2*q+3*n,S=q-2*n+t,E=q-n,p=N.x*i+V.x*z+U.x*S+A.x*E,k=N.y*i+V.y*z+U.y*S+A.y*E;return new C(p,k)}static Hermite1stDerivative(N,U,V,A,t){return this.Hermite1stDerivativeToRef(N,U,V,A,t,new C)}static Hermite1stDerivativeToRef(N,U,V,A,t,n){const q=t*t;return n.x=6*(q-t)*N.x+(3*q-4*t+1)*U.x+6*(-q+t)*V.x+(3*q-2*t)*A.x,n.y=6*(q-t)*N.y+(3*q-4*t+1)*U.y+6*(-q+t)*V.y+(3*q-2*t)*A.y,n}static Lerp(N,U,V){return C.LerpToRef(N,U,V,new C)}static LerpToRef(N,U,V,A){return A.x=N.x+(U.x-N.x)*V,A.y=N.y+(U.y-N.y)*V,A}static Dot(N,U){return N.x*U.x+N.y*U.y}static Normalize(N){return C.NormalizeToRef(N,new C)}static NormalizeToRef(N,U){return N.normalizeToRef(U),U}static Minimize(N,U){const V=N.x<U.x?N.x:U.x,A=N.y<U.y?N.y:U.y;return new C(V,A)}static Maximize(N,U){const V=N.x>U.x?N.x:U.x,A=N.y>U.y?N.y:U.y;return new C(V,A)}static Transform(N,U){return C.TransformToRef(N,U,new C)}static TransformToRef(N,U,V){const A=U.m,t=N.x*A[0]+N.y*A[4]+A[12],n=N.x*A[1]+N.y*A[5]+A[13];return V.x=t,V.y=n,V}static PointInTriangle(N,U,V,A){const t=.5*(-V.y*A.x+U.y*(-V.x+A.x)+U.x*(V.y-A.y)+V.x*A.y),n=t<0?-1:1,q=(U.y*A.x-U.x*A.y+(A.y-U.y)*N.x+(U.x-A.x)*N.y)*n,i=(U.x*V.y-U.y*V.x+(U.y-V.y)*N.x+(V.x-U.x)*N.y)*n;return q>0&&i>0&&q+i<2*t*n}static Distance(N,U){return Math.sqrt(C.DistanceSquared(N,U))}static DistanceSquared(N,U){const V=N.x-U.x,A=N.y-U.y;return V*V+A*A}static Center(N,U){return C.CenterToRef(N,U,new C)}static CenterToRef(N,U,V){return V.hi((N.x+U.x)/2,(N.y+U.y)/2)}static DistanceOfPointFromSegment(N,U,V){const A=C.DistanceSquared(U,V);if(0===A)return C.Distance(N,U);const t=V.xU(U),n=Math.max(0,Math.min(1,C.Dot(N.xU(U),t)/A)),q=U.add(t.multiplyByFloats(n,n));return C.Distance(N,q)}}C._V8PerformanceHack=new C(.5,.5),C._ZeroReadOnly=C.Zero(),Object.defineProperties(C.prototype,{dimension:{value:[2]},rank:{value:1}});class x{get x(){return this._x}set x(N){this._x=N,this._isDirty=!0}get y(){return this._y}set y(N){this._y=N,this._isDirty=!0}get z(){return this._z}set z(N){this._z=N,this._isDirty=!0}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=N,this._y=U,this._z=V}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"CU"}getHashCode(){let N=B(this._x);return N=397*N^B(this._y),N=397*N^B(this._z),N}pi(){return[this._x,this._y,this._z]}toArray(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[U]=this._x,N[U+1]=this._y,N[U+2]=this._z,this}BV(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return x.FromArrayToRef(N,U,this),this}toQuaternion(){return d.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(N){return this._x+=N._x,this._y+=N._y,this._z+=N._z,this._isDirty=!0,this}addInPlaceFromFloats(N,U,V){return this._x+=N,this._y+=U,this._z+=V,this._isDirty=!0,this}add(N){return new x(this._x+N._x,this._y+N._y,this._z+N._z)}addToRef(N,U){return U._x=this._x+N._x,U._y=this._y+N._y,U._z=this._z+N._z,U._isDirty=!0,U}Vp(N){return this._x-=N._x,this._y-=N._y,this._z-=N._z,this._isDirty=!0,this}xU(N){return new x(this._x-N._x,this._y-N._y,this._z-N._z)}subtractToRef(N,U){return this.subtractFromFloatsToRef(N._x,N._y,N._z,U)}subtractFromFloats(N,U,V){return new x(this._x-N,this._y-U,this._z-V)}subtractFromFloatsToRef(N,U,V,A){return A._x=this._x-N,A._y=this._y-U,A._z=this._z-V,A._isDirty=!0,A}negate(){return new x(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(N){return N._x=-1*this._x,N._y=-1*this._y,N._z=-1*this._z,N._isDirty=!0,N}scaleInPlace(N){return this._x*=N,this._y*=N,this._z*=N,this._isDirty=!0,this}scale(N){return new x(this._x*N,this._y*N,this._z*N)}scaleToRef(N,U){return U._x=this._x*N,U._y=this._y*N,U._z=this._z*N,U._isDirty=!0,U}getNormalToRef(N){const U=this.length();let V=Math.acos(this._y/U);const A=Math.atan2(this._z,this._x);V>Math.PI/2?V-=Math.PI/2:V+=Math.PI/2;const t=U*Math.sin(V)*Math.cos(A),n=U*Math.cos(V),q=U*Math.sin(V)*Math.sin(A);return N.set(t,n,q),N}applyRotationQuaternionToRef(N,U){const V=this._x,A=this._y,t=this._z,n=N._x,q=N._y,i=N._z,z=N._w,S=2*(q*t-i*A),E=2*(i*V-n*t),p=2*(n*A-q*V);return U._x=V+z*S+q*p-i*E,U._y=A+z*E+i*S-n*p,U._z=t+z*p+n*E-q*S,U._isDirty=!0,U}applyRotationQuaternionInPlace(N){return this.applyRotationQuaternionToRef(N,this)}applyRotationQuaternion(N){return this.applyRotationQuaternionToRef(N,new x)}scaleAndAddToRef(N,U){return U._x+=this._x*N,U._y+=this._y*N,U._z+=this._z*N,U._isDirty=!0,U}projectOnPlane(N,U){return this.projectOnPlaneToRef(N,U,new x)}projectOnPlaneToRef(N,U,V){const A=N.normal,t=N.d,n=v.CU[0];this.subtractToRef(U,n),n.normalize();const q=x.Dot(n,A);if(Math.abs(q)<1e-10)V.Hi(1/0);else{const N=-(x.Dot(U,A)+t)/q,i=n.scaleInPlace(N);U.addToRef(i,V)}return V}equals(N){return N&&this._x===N._x&&this._y===N._y&&this._z===N._z}equalsWithEpsilon(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.d;return N&&(0,z.WithinEpsilon)(this._x,N._x,U)&&(0,z.WithinEpsilon)(this._y,N._y,U)&&(0,z.WithinEpsilon)(this._z,N._z,U)}equalsToFloats(N,U,V){return this._x===N&&this._y===U&&this._z===V}multiplyInPlace(N){return this._x*=N._x,this._y*=N._y,this._z*=N._z,this._isDirty=!0,this}multiply(N){return this.multiplyByFloats(N._x,N._y,N._z)}multiplyToRef(N,U){return U._x=this._x*N._x,U._y=this._y*N._y,U._z=this._z*N._z,U._isDirty=!0,U}multiplyByFloats(N,U,V){return new x(this._x*N,this._y*U,this._z*V)}divide(N){return new x(this._x/N._x,this._y/N._y,this._z/N._z)}divideToRef(N,U){return U._x=this._x/N._x,U._y=this._y/N._y,U._z=this._z/N._z,U._isDirty=!0,U}divideInPlace(N){return this._x=this._x/N._x,this._y=this._y/N._y,this._z=this._z/N._z,this._isDirty=!0,this}minimizeInPlace(N){return this.minimizeInPlaceFromFloats(N._x,N._y,N._z)}maximizeInPlace(N){return this.maximizeInPlaceFromFloats(N._x,N._y,N._z)}minimizeInPlaceFromFloats(N,U,V){return N<this._x&&(this.x=N),U<this._y&&(this.y=U),V<this._z&&(this.z=V),this}maximizeInPlaceFromFloats(N,U,V){return N>this._x&&(this.x=N),U>this._y&&(this.y=U),V>this._z&&(this.z=V),this}isNonUniformWithinEpsilon(N){const U=Math.abs(this._x),V=Math.abs(this._y);if(!(0,z.WithinEpsilon)(U,V,N))return!0;const A=Math.abs(this._z);return!(0,z.WithinEpsilon)(U,A,N)||!(0,z.WithinEpsilon)(V,A,N)}get isNonUniform(){const N=Math.abs(this._x);if(N!==Math.abs(this._y))return!0;return N!==Math.abs(this._z)}floorToRef(N){return N._x=Math.floor(this._x),N._y=Math.floor(this._y),N._z=Math.floor(this._z),N._isDirty=!0,N}floor(){return new x(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(N){return N._x=this._x-Math.floor(this._x),N._y=this._y-Math.floor(this._y),N._z=this._z-Math.floor(this._z),N._isDirty=!0,N}fract(){return new x(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(N){if("xyz"===(N=N.toLowerCase()))return this;const U=v.CU[0].A(this);return this.x=U[N[0]],this.y=U[N[1]],this.z=U[N[2]],this}rotateByQuaternionToRef(N,U){return N.toRotationMatrix(v.Matrix[0]),x.TransformCoordinatesToRef(this,v.Matrix[0],U),U}rotateByQuaternionAroundPointToRef(N,U,V){return this.subtractToRef(U,v.CU[0]),v.CU[0].rotateByQuaternionToRef(N,v.CU[0]),U.addToRef(v.CU[0],V),V}cross(N){return x.CrossToRef(this,N,new x)}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){return this.normalizeToRef(new x)}normalizeToRef(N){const U=this.length();return 0===U||1===U?(N._x=this._x,N._y=this._y,N._z=this._z,N._isDirty=!0,N):this.scaleToRef(1/U,N)}clone(){return new x(this._x,this._y,this._z)}A(N){return this.hi(N._x,N._y,N._z)}hi(N,U,V){return this._x=N,this._y=U,this._z=V,this._isDirty=!0,this}set(N,U,V){return this.hi(N,U,V)}Hi(N){return this._x=this._y=this._z=N,this._isDirty=!0,this}static GetClipFactor(N,U,V,A){const t=x.Dot(N,V);return(t-A)/(t-x.Dot(U,V))}static GetAngleBetweenVectors(N,U,V){const A=N.normalizeToRef(v.CU[1]),t=U.normalizeToRef(v.CU[2]);let n=x.Dot(A,t);n=(0,z.Clamp)(n,-1,1);const q=Math.acos(n),i=v.CU[3];return x.CrossToRef(A,t,i),x.Dot(i,V)>0?isNaN(q)?0:q:isNaN(q)?-Math.PI:-Math.acos(n)}static GetAngleBetweenVectorsOnPlane(N,U,V){v.CU[0].A(N);const A=v.CU[0];v.CU[1].A(U);const t=v.CU[1];v.CU[2].A(V);const n=v.CU[2],q=v.CU[3],i=v.CU[4];A.normalize(),t.normalize(),n.normalize(),x.CrossToRef(n,A,q),x.CrossToRef(q,n,i);const S=Math.atan2(x.Dot(t,q),x.Dot(t,i));return(0,z.NormalizeRadians)(S)}static PitchYawRollToMoveBetweenPointsToRef(N,U,V){const A=h.CU[0];return U.subtractToRef(N,A),V._y=Math.atan2(A.x,A.z)||0,V._x=Math.atan2(Math.sqrt(A.x**2+A.z**2),A.y)||0,V._z=0,V._isDirty=!0,V}static PitchYawRollToMoveBetweenPoints(N,U){const V=x.Zero();return x.PitchYawRollToMoveBetweenPointsToRef(N,U,V)}static SlerpToRef(N,U,V,t){V=(0,z.Clamp)(V,0,1);const n=v.CU[0],q=v.CU[1];n.A(N);const i=n.length();n.normalizeFromLength(i),q.A(U);const S=q.length();q.normalizeFromLength(S);const E=x.Dot(n,q);let p,k;if(E<1-A.d){const N=Math.acos(E),U=1/Math.sin(N);p=Math.sin((1-V)*N)*U,k=Math.sin(V*N)*U}else p=1-V,k=V;return n.scaleInPlace(p),q.scaleInPlace(k),t.A(n).addInPlace(q),t.scaleInPlace((0,z.Lerp)(i,S,V)),t}static SmoothToRef(N,U,V,A,t){return x.SlerpToRef(N,U,0===A?1:V/A,t),t}static vU(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new x(N[U],N[U+1],N[U+2])}static FromFloatArray(N,U){return x.vU(N,U)}static FromArrayToRef(N,U,V){return V._x=N[U],V._y=N[U+1],V._z=N[U+2],V._isDirty=!0,V}static FromFloatArrayToRef(N,U,V){return x.FromArrayToRef(N,U,V)}static FromFloatsToRef(N,U,V,A){return A.hi(N,U,V),A}static Zero(){return new x(0,0,0)}static One(){return new x(1,1,1)}static Up(){return new x(0,1,0)}static get UpReadOnly(){return x._UpReadOnly}static get DownReadOnly(){return x._DownReadOnly}static get RightReadOnly(){return x._RightReadOnly}static get LeftReadOnly(){return x._LeftReadOnly}static get LeftHandedForwardReadOnly(){return x._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return x._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return x._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return x._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return x._ZeroReadOnly}static get OneReadOnly(){return x._OneReadOnly}static Down(){return new x(0,-1,0)}static Forward(){return new x(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new x(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new x(1,0,0)}static Left(){return new x(-1,0,0)}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new x((0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).hi((0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U))}static TransformCoordinates(N,U){const V=x.Zero();return x.TransformCoordinatesToRef(N,U,V),V}static TransformCoordinatesToRef(N,U,V){return x.TransformCoordinatesFromFloatsToRef(N._x,N._y,N._z,U,V),V}static TransformCoordinatesFromFloatsToRef(N,U,V,A,t){const n=A.m,q=N*n[0]+U*n[4]+V*n[8]+n[12],i=N*n[1]+U*n[5]+V*n[9]+n[13],z=N*n[2]+U*n[6]+V*n[10]+n[14],S=1/(N*n[3]+U*n[7]+V*n[11]+n[15]);return t._x=q*S,t._y=i*S,t._z=z*S,t._isDirty=!0,t}static TransformNormal(N,U){const V=x.Zero();return x.TransformNormalToRef(N,U,V),V}static TransformNormalToRef(N,U,V){return this.TransformNormalFromFloatsToRef(N._x,N._y,N._z,U,V),V}static TransformNormalFromFloatsToRef(N,U,V,A,t){const n=A.m;return t._x=N*n[0]+U*n[4]+V*n[8],t._y=N*n[1]+U*n[5]+V*n[9],t._z=N*n[2]+U*n[6]+V*n[10],t._isDirty=!0,t}static CatmullRom(N,U,V,A,t){const n=t*t,q=t*n,i=.5*(2*U._x+(-N._x+V._x)*t+(2*N._x-5*U._x+4*V._x-A._x)*n+(-N._x+3*U._x-3*V._x+A._x)*q),z=.5*(2*U._y+(-N._y+V._y)*t+(2*N._y-5*U._y+4*V._y-A._y)*n+(-N._y+3*U._y-3*V._y+A._y)*q),S=.5*(2*U._z+(-N._z+V._z)*t+(2*N._z-5*U._z+4*V._z-A._z)*n+(-N._z+3*U._z-3*V._z+A._z)*q);return new x(i,z,S)}static Clamp(N,U,V){const A=new x;return x.ClampToRef(N,U,V,A),A}static ClampToRef(N,U,V,A){let t=N._x;t=t>V._x?V._x:t,t=t<U._x?U._x:t;let n=N._y;n=n>V._y?V._y:n,n=n<U._y?U._y:n;let q=N._z;return q=q>V._z?V._z:q,q=q<U._z?U._z:q,A.hi(t,n,q),A}static CheckExtends(N,U,V){U.minimizeInPlace(N),V.maximizeInPlace(N)}static Hermite(N,U,V,A,t){const n=t*t,q=t*n,i=2*q-3*n+1,z=-2*q+3*n,S=q-2*n+t,E=q-n,p=N._x*i+V._x*z+U._x*S+A._x*E,k=N._y*i+V._y*z+U._y*S+A._y*E,B=N._z*i+V._z*z+U._z*S+A._z*E;return new x(p,k,B)}static Hermite1stDerivative(N,U,V,A,t){const n=new x;return this.Hermite1stDerivativeToRef(N,U,V,A,t,n),n}static Hermite1stDerivativeToRef(N,U,V,A,t,n){const q=t*t;return n._x=6*(q-t)*N._x+(3*q-4*t+1)*U._x+6*(-q+t)*V._x+(3*q-2*t)*A._x,n._y=6*(q-t)*N._y+(3*q-4*t+1)*U._y+6*(-q+t)*V._y+(3*q-2*t)*A._y,n._z=6*(q-t)*N._z+(3*q-4*t+1)*U._z+6*(-q+t)*V._z+(3*q-2*t)*A._z,n._isDirty=!0,n}static Lerp(N,U,V){const A=new x(0,0,0);return x.LerpToRef(N,U,V,A),A}static LerpToRef(N,U,V,A){return A._x=N._x+(U._x-N._x)*V,A._y=N._y+(U._y-N._y)*V,A._z=N._z+(U._z-N._z)*V,A._isDirty=!0,A}static Dot(N,U){return N._x*U._x+N._y*U._y+N._z*U._z}dot(N){return this._x*N._x+this._y*N._y+this._z*N._z}static Cross(N,U){const V=new x;return x.CrossToRef(N,U,V),V}static CrossToRef(N,U,V){const A=N._y*U._z-N._z*U._y,t=N._z*U._x-N._x*U._z,n=N._x*U._y-N._y*U._x;return V.hi(A,t,n),V}static Normalize(N){const U=x.Zero();return x.NormalizeToRef(N,U),U}static NormalizeToRef(N,U){return N.normalizeToRef(U),U}static Project(N,U,V,A){const t=new x;return x.ProjectToRef(N,U,V,A,t),t}static ProjectToRef(N,U,V,A,t){var n;const q=A.width,z=A.height,S=A.x,E=A.y,p=v.Matrix[1],k=null===(n=i.e.LastCreatedEngine)||void 0===n?void 0:n.isNDCHalfZRange,B=k?1:.5,C=k?0:.5;r.FromValuesToRef(q/2,0,0,0,0,-z/2,0,0,0,0,B,0,S+q/2,z/2+E,C,1,p);const J=v.Matrix[0];return U.multiplyToRef(V,J),J.multiplyToRef(p,J),x.TransformCoordinatesToRef(N,J,t),t}static Reflect(N,U){return this.ReflectToRef(N,U,new x)}static ReflectToRef(N,U,V){const A=h.CU[0];return A.A(U).scaleInPlace(2*x.Dot(N,U)),V.A(N).Vp(A)}static _UnprojectFromInvertedMatrixToRef(N,U,V){x.TransformCoordinatesToRef(N,U,V);const A=U.m,t=N._x*A[3]+N._y*A[7]+N._z*A[11]+A[15];return(0,z.WithinEpsilon)(t,1)&&V.scaleInPlace(1/t),V}static UnprojectFromTransform(N,U,V,A,t){return this.Unproject(N,U,V,A,t,r.IdentityReadOnly)}static Unproject(N,U,V,A,t,n){const q=new x;return x.UnprojectToRef(N,U,V,A,t,n,q),q}static UnprojectToRef(N,U,V,A,t,n,q){return x.UnprojectFloatsToRef(N._x,N._y,N._z,U,V,A,t,n,q),q}static UnprojectFloatsToRef(N,U,V,A,t,n,q,z,S){var E;const p=v.Matrix[0];n.multiplyToRef(q,p),p.multiplyToRef(z,p),p.invert();const k=v.CU[0];return k.x=N/A*2-1,k.y=-(U/t*2-1),null!==(E=i.e.LastCreatedEngine)&&void 0!==E&&E.isNDCHalfZRange?k.z=V:k.z=2*V-1,x._UnprojectFromInvertedMatrixToRef(k,p,S),S}static Minimize(N,U){const V=new x;return V.A(N),V.minimizeInPlace(U),V}static Maximize(N,U){const V=new x;return V.A(N),V.maximizeInPlace(U),V}static Distance(N,U){return Math.sqrt(x.DistanceSquared(N,U))}static DistanceSquared(N,U){const V=N._x-U._x,A=N._y-U._y,t=N._z-U._z;return V*V+A*A+t*t}static ProjectOnTriangleToRef(N,U,V,t,n){const q=v.CU[0],i=v.CU[1],S=v.CU[2],E=v.CU[3],p=v.CU[4];V.subtractToRef(U,q),t.subtractToRef(U,i),t.subtractToRef(V,S);const k=q.length(),B=i.length(),C=S.length();if(k<A.d||B<A.d||C<A.d)return n.A(U),x.Distance(N,U);N.subtractToRef(U,p),x.CrossToRef(q,i,E);const J=E.length();if(J<A.d)return n.A(U),x.Distance(N,U);E.normalizeFromLength(J);let d=p.length();if(d<A.d)return n.A(U),0;p.normalizeFromLength(d);const r=x.Dot(E,p),h=v.CU[5],c=v.CU[6];h.A(E).scaleInPlace(-d*r),c.A(N).addInPlace(h);const H=v.CU[4],Y=v.CU[5],W=v.CU[7],s=v.CU[8];H.A(q).scaleInPlace(1/k),s.A(i).scaleInPlace(1/B),H.addInPlace(s).scaleInPlace(-1),Y.A(q).scaleInPlace(-1/k),s.A(S).scaleInPlace(1/C),Y.addInPlace(s).scaleInPlace(-1),W.A(S).scaleInPlace(-1/C),s.A(i).scaleInPlace(-1/B),W.addInPlace(s).scaleInPlace(-1);const M=v.CU[9];let a;M.A(c).Vp(U),x.CrossToRef(H,M,s),a=x.Dot(s,E);const mN=a;M.A(c).Vp(V),x.CrossToRef(Y,M,s),a=x.Dot(s,E);const w=a;M.A(c).Vp(t),x.CrossToRef(W,M,s),a=x.Dot(s,E);const X=a,e=v.CU[10];let Q,u;mN>0&&w<0?(e.A(q),Q=U,u=V):w>0&&X<0?(e.A(S),Q=V,u=t):(e.A(i).scaleInPlace(-1),Q=t,u=U);const L=v.CU[9],I=v.CU[4];Q.subtractToRef(c,s),u.subtractToRef(c,L),x.CrossToRef(s,L,I);if(!(x.Dot(I,E)<0))return n.A(c),Math.abs(d*r);const o=v.CU[5];x.CrossToRef(e,I,o),o.normalize();const R=v.CU[9];R.A(Q).Vp(c);const D=R.length();if(D<A.d)return n.A(Q),x.Distance(N,Q);R.normalizeFromLength(D);const G=x.Dot(o,R),g=v.CU[7];g.A(c).addInPlace(o.scaleInPlace(D*G)),s.A(g).Vp(Q),d=e.length(),e.normalizeFromLength(d);let l=x.Dot(s,e)/Math.max(d,A.d);return l=(0,z.Clamp)(l,0,1),g.A(Q).addInPlace(e.scaleInPlace(l*d)),n.A(g),x.Distance(N,g)}static Center(N,U){return x.CenterToRef(N,U,x.Zero())}static CenterToRef(N,U,V){return V.hi((N._x+U._x)/2,(N._y+U._y)/2,(N._z+U._z)/2)}static RotationFromAxis(N,U,V){const A=new x;return x.RotationFromAxisToRef(N,U,V,A),A}static RotationFromAxisToRef(N,U,V,A){const t=v.Quaternion[0];return d.RotationQuaternionFromAxisToRef(N,U,V,t),t.toEulerAnglesToRef(A),A}}x._V8PerformanceHack=new x(.5,.5,.5),x._UpReadOnly=x.Up(),x._DownReadOnly=x.Down(),x._LeftHandedForwardReadOnly=x.Forward(!1),x._RightHandedForwardReadOnly=x.Forward(!0),x._LeftHandedBackwardReadOnly=x.Backward(!1),x._RightHandedBackwardReadOnly=x.Backward(!0),x._RightReadOnly=x.Right(),x._LeftReadOnly=x.Left(),x._ZeroReadOnly=x.Zero(),x._OneReadOnly=x.One(),Object.defineProperties(x.prototype,{dimension:{value:[3]},rank:{value:1}});class J{get x(){return this._x}set x(N){this._x=N,this._isDirty=!0}get y(){return this._y}set y(N){this._y=N,this._isDirty=!0}get z(){return this._z}set z(N){this._z=N,this._isDirty=!0}get w(){return this._w}set w(N){this._w=N,this._isDirty=!0}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=N,this._y=U,this._z=V,this._w=A}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let N=B(this._x);return N=397*N^B(this._y),N=397*N^B(this._z),N=397*N^B(this._w),N}pi(){return[this._x,this._y,this._z,this._w]}toArray(N,U){return void 0===U&&(U=0),N[U]=this._x,N[U+1]=this._y,N[U+2]=this._z,N[U+3]=this._w,this}BV(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(N,U,this),this}addInPlace(N){return this.x+=N._x,this.y+=N._y,this.z+=N._z,this.w+=N._w,this}addInPlaceFromFloats(N,U,V,A){return this.x+=N,this.y+=U,this.z+=V,this.w+=A,this}add(N){return new J(this._x+N.x,this._y+N.y,this._z+N.z,this._w+N.w)}addToRef(N,U){return U.x=this._x+N.x,U.y=this._y+N.y,U.z=this._z+N.z,U.w=this._w+N.w,U}Vp(N){return this.x-=N.x,this.y-=N.y,this.z-=N.z,this.w-=N.w,this}xU(N){return new J(this._x-N.x,this._y-N.y,this._z-N.z,this._w-N.w)}subtractToRef(N,U){return U.x=this._x-N.x,U.y=this._y-N.y,U.z=this._z-N.z,U.w=this._w-N.w,U}subtractFromFloats(N,U,V,A){return new J(this._x-N,this._y-U,this._z-V,this._w-A)}subtractFromFloatsToRef(N,U,V,A,t){return t.x=this._x-N,t.y=this._y-U,t.z=this._z-V,t.w=this._w-A,t}negate(){return new J(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(N){return N.x=-this._x,N.y=-this._y,N.z=-this._z,N.w=-this._w,N}scaleInPlace(N){return this.x*=N,this.y*=N,this.z*=N,this.w*=N,this}scale(N){return new J(this._x*N,this._y*N,this._z*N,this._w*N)}scaleToRef(N,U){return U.x=this._x*N,U.y=this._y*N,U.z=this._z*N,U.w=this._w*N,U}scaleAndAddToRef(N,U){return U.x+=this._x*N,U.y+=this._y*N,U.z+=this._z*N,U.w+=this._w*N,U}equals(N){return N&&this._x===N.x&&this._y===N.y&&this._z===N.z&&this._w===N.w}equalsWithEpsilon(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.d;return N&&(0,z.WithinEpsilon)(this._x,N.x,U)&&(0,z.WithinEpsilon)(this._y,N.y,U)&&(0,z.WithinEpsilon)(this._z,N.z,U)&&(0,z.WithinEpsilon)(this._w,N.w,U)}equalsToFloats(N,U,V,A){return this._x===N&&this._y===U&&this._z===V&&this._w===A}multiplyInPlace(N){return this.x*=N.x,this.y*=N.y,this.z*=N.z,this.w*=N.w,this}multiply(N){return new J(this._x*N.x,this._y*N.y,this._z*N.z,this._w*N.w)}multiplyToRef(N,U){return U.x=this._x*N.x,U.y=this._y*N.y,U.z=this._z*N.z,U.w=this._w*N.w,U}multiplyByFloats(N,U,V,A){return new J(this._x*N,this._y*U,this._z*V,this._w*A)}divide(N){return new J(this._x/N.x,this._y/N.y,this._z/N.z,this._w/N.w)}divideToRef(N,U){return U.x=this._x/N.x,U.y=this._y/N.y,U.z=this._z/N.z,U.w=this._w/N.w,U}divideInPlace(N){return this.divideToRef(N,this)}minimizeInPlace(N){return N.x<this._x&&(this.x=N.x),N.y<this._y&&(this.y=N.y),N.z<this._z&&(this.z=N.z),N.w<this._w&&(this.w=N.w),this}maximizeInPlace(N){return N.x>this._x&&(this.x=N.x),N.y>this._y&&(this.y=N.y),N.z>this._z&&(this.z=N.z),N.w>this._w&&(this.w=N.w),this}minimizeInPlaceFromFloats(N,U,V,A){return this.x=Math.min(N,this._x),this.y=Math.min(U,this._y),this.z=Math.min(V,this._z),this.w=Math.min(A,this._w),this}maximizeInPlaceFromFloats(N,U,V,A){return this.x=Math.max(N,this._x),this.y=Math.max(U,this._y),this.z=Math.max(V,this._z),this.w=Math.max(A,this._w),this}floorToRef(N){return N.x=Math.floor(this._x),N.y=Math.floor(this._y),N.z=Math.floor(this._z),N.w=Math.floor(this._w),N}floor(){return new J(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(N){return N.x=this._x-Math.floor(this._x),N.y=this._y-Math.floor(this._y),N.z=this._z-Math.floor(this._z),N.w=this._w-Math.floor(this._w),N}fract(){return new J(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){return this.normalizeToRef(new J)}normalizeToRef(N){const U=this.length();return 0===U||1===U?(N.x=this._x,N.y=this._y,N.z=this._z,N.w=this._w,N):this.scaleToRef(1/U,N)}toVector3(){return new x(this._x,this._y,this._z)}clone(){return new J(this._x,this._y,this._z,this._w)}A(N){return this.x=N.x,this.y=N.y,this.z=N.z,this.w=N.w,this}hi(N,U,V,A){return this.x=N,this.y=U,this.z=V,this.w=A,this}set(N,U,V,A){return this.hi(N,U,V,A)}Hi(N){return this.x=this.y=this.z=this.w=N,this}dot(N){return this._x*N.x+this._y*N.y+this._z*N.z+this._w*N.w}static vU(N,U){return U||(U=0),new J(N[U],N[U+1],N[U+2],N[U+3])}static FromArrayToRef(N,U,V){return V.x=N[U],V.y=N[U+1],V.z=N[U+2],V.w=N[U+3],V}static FromFloatArrayToRef(N,U,V){return J.FromArrayToRef(N,U,V),V}static FromFloatsToRef(N,U,V,A,t){return t.x=N,t.y=U,t.z=V,t.w=A,t}static Zero(){return new J(0,0,0,0)}static One(){return new J(1,1,1,1)}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new J((0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,V=arguments.length>2?arguments[2]:void 0;return V.x=(0,z.RandomRange)(N,U),V.y=(0,z.RandomRange)(N,U),V.z=(0,z.RandomRange)(N,U),V.w=(0,z.RandomRange)(N,U),V}static Clamp(N,U,V){return J.ClampToRef(N,U,V,new J)}static ClampToRef(N,U,V,A){return A.x=(0,z.Clamp)(N.x,U.x,V.x),A.y=(0,z.Clamp)(N.y,U.y,V.y),A.z=(0,z.Clamp)(N.z,U.z,V.z),A.w=(0,z.Clamp)(N.w,U.w,V.w),A}static CheckExtends(N,U,V){U.minimizeInPlace(N),V.maximizeInPlace(N)}static get ZeroReadOnly(){return J._ZeroReadOnly}static Normalize(N){return J.NormalizeToRef(N,new J)}static NormalizeToRef(N,U){return N.normalizeToRef(U),U}static Minimize(N,U){const V=new J;return V.A(N),V.minimizeInPlace(U),V}static Maximize(N,U){const V=new J;return V.A(N),V.maximizeInPlace(U),V}static Distance(N,U){return Math.sqrt(J.DistanceSquared(N,U))}static DistanceSquared(N,U){const V=N.x-U.x,A=N.y-U.y,t=N.z-U.z,n=N.w-U.w;return V*V+A*A+t*t+n*n}static Center(N,U){return J.CenterToRef(N,U,new J)}static CenterToRef(N,U,V){return V.x=(N.x+U.x)/2,V.y=(N.y+U.y)/2,V.z=(N.z+U.z)/2,V.w=(N.w+U.w)/2,V}static TransformCoordinates(N,U){return J.TransformCoordinatesToRef(N,U,new J)}static TransformCoordinatesToRef(N,U,V){return J.TransformCoordinatesFromFloatsToRef(N._x,N._y,N._z,U,V),V}static TransformCoordinatesFromFloatsToRef(N,U,V,A,t){const n=A.m,q=N*n[0]+U*n[4]+V*n[8]+n[12],i=N*n[1]+U*n[5]+V*n[9]+n[13],z=N*n[2]+U*n[6]+V*n[10]+n[14],S=N*n[3]+U*n[7]+V*n[11]+n[15];return t.x=q,t.y=i,t.z=z,t.w=S,t}static TransformNormal(N,U){return J.TransformNormalToRef(N,U,new J)}static TransformNormalToRef(N,U,V){const A=U.m,t=N.x*A[0]+N.y*A[4]+N.z*A[8],n=N.x*A[1]+N.y*A[5]+N.z*A[9],q=N.x*A[2]+N.y*A[6]+N.z*A[10];return V.x=t,V.y=n,V.z=q,V.w=N.w,V}static TransformNormalFromFloatsToRef(N,U,V,A,t,n){const q=t.m;return n.x=N*q[0]+U*q[4]+V*q[8],n.y=N*q[1]+U*q[5]+V*q[9],n.z=N*q[2]+U*q[6]+V*q[10],n.w=A,n}static FromVector3(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new J(N._x,N._y,N._z,U)}static Dot(N,U){return N.x*U.x+N.y*U.y+N.z*U.z+N.w*U.w}}J._V8PerformanceHack=new J(.5,.5,.5,.5),J._ZeroReadOnly=J.Zero(),Object.defineProperties(J.prototype,{dimension:{value:[4]},rank:{value:1}});class d{get x(){return this._x}set x(N){this._x=N,this._isDirty=!0}get y(){return this._y}set y(N){this._y=N,this._isDirty=!0}get z(){return this._z}set z(N){this._z=N,this._isDirty=!0}get w(){return this._w}set w(N){this._w=N,this._isDirty=!0}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=N,this._y=U,this._z=V,this._w=A}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let N=B(this._x);return N=397*N^B(this._y),N=397*N^B(this._z),N=397*N^B(this._w),N}pi(){return[this._x,this._y,this._z,this._w]}toArray(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[U]=this._x,N[U+1]=this._y,N[U+2]=this._z,N[U+3]=this._w,this}BV(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return d.FromArrayToRef(N,U,this)}equals(N){return N&&this._x===N._x&&this._y===N._y&&this._z===N._z&&this._w===N._w}equalsWithEpsilon(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.d;return N&&(0,z.WithinEpsilon)(this._x,N._x,U)&&(0,z.WithinEpsilon)(this._y,N._y,U)&&(0,z.WithinEpsilon)(this._z,N._z,U)&&(0,z.WithinEpsilon)(this._w,N._w,U)}isApprox(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.d;return N&&((0,z.WithinEpsilon)(this._x,N._x,U)&&(0,z.WithinEpsilon)(this._y,N._y,U)&&(0,z.WithinEpsilon)(this._z,N._z,U)&&(0,z.WithinEpsilon)(this._w,N._w,U)||(0,z.WithinEpsilon)(this._x,-N._x,U)&&(0,z.WithinEpsilon)(this._y,-N._y,U)&&(0,z.WithinEpsilon)(this._z,-N._z,U)&&(0,z.WithinEpsilon)(this._w,-N._w,U))}clone(){return new d(this._x,this._y,this._z,this._w)}A(N){return this._x=N._x,this._y=N._y,this._z=N._z,this._w=N._w,this._isDirty=!0,this}hi(N,U,V,A){return this._x=N,this._y=U,this._z=V,this._w=A,this._isDirty=!0,this}set(N,U,V,A){return this.hi(N,U,V,A)}Hi(N){return this.hi(N,N,N,N)}add(N){return new d(this._x+N._x,this._y+N._y,this._z+N._z,this._w+N._w)}addInPlace(N){return this._x+=N._x,this._y+=N._y,this._z+=N._z,this._w+=N._w,this._isDirty=!0,this}addToRef(N,U){return U._x=this._x+N._x,U._y=this._y+N._y,U._z=this._z+N._z,U._w=this._w+N._w,U._isDirty=!0,U}addInPlaceFromFloats(N,U,V,A){return this._x+=N,this._y+=U,this._z+=V,this._w+=A,this._isDirty=!0,this}subtractToRef(N,U){return U._x=this._x-N._x,U._y=this._y-N._y,U._z=this._z-N._z,U._w=this._w-N._w,U._isDirty=!0,U}subtractFromFloats(N,U,V,A){return this.subtractFromFloatsToRef(N,U,V,A,new d)}subtractFromFloatsToRef(N,U,V,A,t){return t._x=this._x-N,t._y=this._y-U,t._z=this._z-V,t._w=this._w-A,t._isDirty=!0,t}xU(N){return new d(this._x-N._x,this._y-N._y,this._z-N._z,this._w-N._w)}Vp(N){return this._x-=N._x,this._y-=N._y,this._z-=N._z,this._w-=N._w,this._isDirty=!0,this}scale(N){return new d(this._x*N,this._y*N,this._z*N,this._w*N)}scaleToRef(N,U){return U._x=this._x*N,U._y=this._y*N,U._z=this._z*N,U._w=this._w*N,U._isDirty=!0,U}scaleInPlace(N){return this._x*=N,this._y*=N,this._z*=N,this._w*=N,this._isDirty=!0,this}scaleAndAddToRef(N,U){return U._x+=this._x*N,U._y+=this._y*N,U._z+=this._z*N,U._w+=this._w*N,U._isDirty=!0,U}multiply(N){const U=new d(0,0,0,1);return this.multiplyToRef(N,U),U}multiplyToRef(N,U){const V=this._x*N._w+this._y*N._z-this._z*N._y+this._w*N._x,A=-this._x*N._z+this._y*N._w+this._z*N._x+this._w*N._y,t=this._x*N._y-this._y*N._x+this._z*N._w+this._w*N._z,n=-this._x*N._x-this._y*N._y-this._z*N._z+this._w*N._w;return U.hi(V,A,t,n),U}multiplyInPlace(N){return this.multiplyToRef(N,this)}multiplyByFloats(N,U,V,A){return this._x*=N,this._y*=U,this._z*=V,this._w*=A,this._isDirty=!0,this}divide(N){throw new ReferenceError("Can not divide a quaternion")}divideToRef(N,U){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(N){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new d)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(N){return N._x=-this._x,N._y=-this._y,N._z=-this._z,N._w=-this._w,N._isDirty=!0,N}equalsToFloats(N,U,V,A){return this._x===N&&this._y===U&&this._z===V&&this._w===A}floorToRef(N){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(N){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(N){return N.hi(-this._x,-this._y,-this._z,this._w),N}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new d(-this._x,-this._y,-this._z,this._w)}invert(){const N=this.conjugate(),U=this.lengthSquared();return 0==U||1==U||N.scaleInPlace(1/U),N}invertInPlace(){this.conjugateInPlace();const N=this.lengthSquared();return 0==N||1==N||this.scaleInPlace(1/N),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){const N=new d(0,0,0,1);return this.normalizeToRef(N),N}normalizeToRef(N){const U=this.length();return 0===U||1===U?N.hi(this._x,this._y,this._z,this._w):this.scaleToRef(1/U,N)}toEulerAngles(){const N=x.Zero();return this.toEulerAnglesToRef(N),N}toEulerAnglesToRef(N){const U=this._z,V=this._x,A=this._y,t=this._w,n=A*U-V*t,q=.4999999;if(n<-q)N._y=2*Math.atan2(A,t),N._x=Math.PI/2,N._z=0,N._isDirty=!0;else if(n>q)N._y=2*Math.atan2(A,t),N._x=-Math.PI/2,N._z=0,N._isDirty=!0;else{const q=t*t,i=U*U,z=V*V,S=A*A;N._z=Math.atan2(2*(V*A+U*t),-i-z+S+q),N._x=Math.asin(-2*n),N._y=Math.atan2(2*(U*V+A*t),i-z-S+q),N._isDirty=!0}return N}toAlphaBetaGammaToRef(N){const U=this._z,V=this._x,A=this._y,t=this._w,n=Math.sqrt(V*V+A*A),q=Math.sqrt(U*U+t*t),i=2*Math.atan2(n,q),z=2*Math.atan2(U,t),S=2*Math.atan2(A,V),E=(z+S)/2,p=(z-S)/2;return N.set(p,i,E),N}toRotationMatrix(N){return r.FromQuaternionToRef(this,N),N}fromRotationMatrix(N){return d.FromRotationMatrixToRef(N,this),this}dot(N){return this._x*N._x+this._y*N._y+this._z*N._z+this._w*N._w}toAxisAngle(){const N=x.Zero();return{axis:N,angle:this.toAxisAngleToRef(N)}}toAxisAngleToRef(N){let U=0;const V=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),A=this._w;return V>0?(U=2*Math.atan2(V,A),N.set(this._x/V,this._y/V,this._z/V)):(U=0,N.set(1,0,0)),U}static FromRotationMatrix(N){const U=new d;return d.FromRotationMatrixToRef(N,U),U}static FromRotationMatrixToRef(N,U){const V=N.m,A=V[0],t=V[4],n=V[8],q=V[1],i=V[5],z=V[9],S=V[2],E=V[6],p=V[10],k=A+i+p;let B;return k>0?(B=.5/Math.sqrt(k+1),U._w=.25/B,U._x=(E-z)*B,U._y=(n-S)*B,U._z=(q-t)*B,U._isDirty=!0):A>i&&A>p?(B=2*Math.sqrt(1+A-i-p),U._w=(E-z)/B,U._x=.25*B,U._y=(t+q)/B,U._z=(n+S)/B,U._isDirty=!0):i>p?(B=2*Math.sqrt(1+i-A-p),U._w=(n-S)/B,U._x=(t+q)/B,U._y=.25*B,U._z=(z+E)/B,U._isDirty=!0):(B=2*Math.sqrt(1+p-A-i),U._w=(q-t)/B,U._x=(n+S)/B,U._y=(z+E)/B,U._z=.25*B,U._isDirty=!0),U}static Dot(N,U){return N._x*U._x+N._y*U._y+N._z*U._z+N._w*U._w}static AreClose(N,U){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const A=d.Dot(N,U);return 1-A*A<=V}static SmoothToRef(N,U,V,A,t){let n=0===A?1:V/A;return n=(0,z.Clamp)(n,0,1),d.SlerpToRef(N,U,n,t),t}static Zero(){return new d(0,0,0,0)}static Inverse(N){return new d(-N._x,-N._y,-N._z,N._w)}static InverseToRef(N,U){return U.set(-N._x,-N._y,-N._z,N._w),U}static Identity(){return new d(0,0,0,1)}static IsIdentity(N){return N&&0===N._x&&0===N._y&&0===N._z&&1===N._w}static RotationAxis(N,U){return d.RotationAxisToRef(N,U,new d)}static RotationAxisToRef(N,U,V){V._w=Math.cos(U/2);const A=Math.sin(U/2)/N.length();return V._x=N._x*A,V._y=N._y*A,V._z=N._z*A,V._isDirty=!0,V}static vU(N,U){return U||(U=0),new d(N[U],N[U+1],N[U+2],N[U+3])}static FromArrayToRef(N,U,V){return V._x=N[U],V._y=N[U+1],V._z=N[U+2],V._w=N[U+3],V._isDirty=!0,V}static FromFloatsToRef(N,U,V,A,t){return t.hi(N,U,V,A),t}static FromEulerAngles(N,U,V){const A=new d;return d.RotationYawPitchRollToRef(U,N,V,A),A}static FromEulerAnglesToRef(N,U,V,A){return d.RotationYawPitchRollToRef(U,N,V,A),A}static FromEulerVector(N){const U=new d;return d.RotationYawPitchRollToRef(N._y,N._x,N._z,U),U}static FromEulerVectorToRef(N,U){return d.RotationYawPitchRollToRef(N._y,N._x,N._z,U),U}static FromUnitVectorsToRef(N,U,V){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:A.d;const n=x.Dot(N,U)+1;return n<t?Math.abs(N.x)>Math.abs(N.z)?V.set(-N.y,N.x,0,0):V.set(0,-N.z,N.y,0):(x.CrossToRef(N,U,h.CU[0]),V.set(h.CU[0].x,h.CU[0].y,h.CU[0].z,n)),V.normalize()}static RotationYawPitchRoll(N,U,V){const A=new d;return d.RotationYawPitchRollToRef(N,U,V,A),A}static RotationYawPitchRollToRef(N,U,V,A){const t=.5*V,n=.5*U,q=.5*N,i=Math.sin(t),z=Math.cos(t),S=Math.sin(n),E=Math.cos(n),p=Math.sin(q),k=Math.cos(q);return A._x=k*S*z+p*E*i,A._y=p*E*z-k*S*i,A._z=k*E*i-p*S*z,A._w=k*E*z+p*S*i,A._isDirty=!0,A}static RotationAlphaBetaGamma(N,U,V){const A=new d;return d.RotationAlphaBetaGammaToRef(N,U,V,A),A}static RotationAlphaBetaGammaToRef(N,U,V,A){const t=.5*(V+N),n=.5*(V-N),q=.5*U;return A._x=Math.cos(n)*Math.sin(q),A._y=Math.sin(n)*Math.sin(q),A._z=Math.sin(t)*Math.cos(q),A._w=Math.cos(t)*Math.cos(q),A._isDirty=!0,A}static RotationQuaternionFromAxis(N,U,V){const A=new d(0,0,0,0);return d.RotationQuaternionFromAxisToRef(N,U,V,A),A}static RotationQuaternionFromAxisToRef(N,U,V,A){const t=v.Matrix[0];return N=N.normalizeToRef(v.CU[0]),U=U.normalizeToRef(v.CU[1]),V=V.normalizeToRef(v.CU[2]),r.FromXYZAxesToRef(N,U,V,t),d.FromRotationMatrixToRef(t,A),A}static FromLookDirectionLH(N,U){const V=new d;return d.FromLookDirectionLHToRef(N,U,V),V}static FromLookDirectionLHToRef(N,U,V){const A=v.Matrix[0];return r.LookDirectionLHToRef(N,U,A),d.FromRotationMatrixToRef(A,V),V}static FromLookDirectionRH(N,U){const V=new d;return d.FromLookDirectionRHToRef(N,U,V),V}static FromLookDirectionRHToRef(N,U,V){const A=v.Matrix[0];return r.LookDirectionRHToRef(N,U,A),d.FromRotationMatrixToRef(A,V)}static Slerp(N,U,V){const A=d.Identity();return d.SlerpToRef(N,U,V,A),A}static SlerpToRef(N,U,V,A){let t,n,q=N._x*U._x+N._y*U._y+N._z*U._z+N._w*U._w,i=!1;if(q<0&&(i=!0,q=-q),q>.999999)n=1-V,t=i?-V:V;else{const N=Math.acos(q),U=1/Math.sin(N);n=Math.sin((1-V)*N)*U,t=i?-Math.sin(V*N)*U:Math.sin(V*N)*U}return A._x=n*N._x+t*U._x,A._y=n*N._y+t*U._y,A._z=n*N._z+t*U._z,A._w=n*N._w+t*U._w,A._isDirty=!0,A}static Hermite(N,U,V,A,t){const n=t*t,q=t*n,i=2*q-3*n+1,z=-2*q+3*n,S=q-2*n+t,E=q-n,p=N._x*i+V._x*z+U._x*S+A._x*E,k=N._y*i+V._y*z+U._y*S+A._y*E,B=N._z*i+V._z*z+U._z*S+A._z*E,C=N._w*i+V._w*z+U._w*S+A._w*E;return new d(p,k,B,C)}static Hermite1stDerivative(N,U,V,A,t){const n=new d;return this.Hermite1stDerivativeToRef(N,U,V,A,t,n),n}static Hermite1stDerivativeToRef(N,U,V,A,t,n){const q=t*t;return n._x=6*(q-t)*N._x+(3*q-4*t+1)*U._x+6*(-q+t)*V._x+(3*q-2*t)*A._x,n._y=6*(q-t)*N._y+(3*q-4*t+1)*U._y+6*(-q+t)*V._y+(3*q-2*t)*A._y,n._z=6*(q-t)*N._z+(3*q-4*t+1)*U._z+6*(-q+t)*V._z+(3*q-2*t)*A._z,n._w=6*(q-t)*N._w+(3*q-4*t+1)*U._w+6*(-q+t)*V._w+(3*q-2*t)*A._w,n._isDirty=!0,n}static Normalize(N){const U=d.Zero();return d.NormalizeToRef(N,U),U}static NormalizeToRef(N,U){return N.normalizeToRef(U),U}static Clamp(N,U,V){const A=new d;return d.ClampToRef(N,U,V,A),A}static ClampToRef(N,U,V,A){return A.hi((0,z.Clamp)(N.x,U.x,V.x),(0,z.Clamp)(N.y,U.y,V.y),(0,z.Clamp)(N.z,U.z,V.z),(0,z.Clamp)(N.w,U.w,V.w))}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new d((0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).hi((0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U),(0,z.RandomRange)(N,U))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(N,U){return Math.sqrt(d.DistanceSquared(N,U))}static DistanceSquared(N,U){const V=N.x-U.x,A=N.y-U.y,t=N.z-U.z,n=N.w-U.w;return V*V+A*A+t*t+n*n}static Center(N,U){return d.CenterToRef(N,U,d.Zero())}static CenterToRef(N,U,V){return V.hi((N.x+U.x)/2,(N.y+U.y)/2,(N.z+U.z)/2,(N.w+U.w)/2)}}d._V8PerformanceHack=new d(.5,.5,.5,.5),Object.defineProperties(d.prototype,{dimension:{value:[4]},rank:{value:1}});class r{static get Use64Bits(){return q.c.MatrixUse64Bits}get m(){return this.ni}markAsUpdated(){this.updateFlag=S._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(N){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2&&void 0!==arguments[2]&&arguments[2],A=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=N,this._isIdentity3x2=N||V,this._isIdentityDirty=!this._isIdentity&&U,this._isIdentity3x2Dirty=!this._isIdentity3x2&&A}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,q.c.MatrixTrackPrecisionChange&&q.c.MatrixTrackedMatrices.push(this),this.ni=new q.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const N=this.ni;this._isIdentity=1===N[0]&&0===N[1]&&0===N[2]&&0===N[3]&&0===N[4]&&1===N[5]&&0===N[6]&&0===N[7]&&0===N[8]&&0===N[9]&&1===N[10]&&0===N[11]&&0===N[12]&&0===N[13]&&0===N[14]&&1===N[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ni[0]||1!==this.ni[5]||1!==this.ni[15]||0!==this.ni[1]||0!==this.ni[2]||0!==this.ni[3]||0!==this.ni[4]||0!==this.ni[6]||0!==this.ni[7]||0!==this.ni[8]||0!==this.ni[9]||0!==this.ni[10]||0!==this.ni[11]||0!==this.ni[12]||0!==this.ni[13]||0!==this.ni[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const N=this.ni,U=N[0],V=N[1],A=N[2],t=N[3],n=N[4],q=N[5],i=N[6],z=N[7],S=N[8],E=N[9],p=N[10],k=N[11],B=N[12],C=N[13],x=N[14],J=N[15],d=p*J-x*k,r=E*J-C*k,v=E*x-C*p,h=S*J-B*k,c=S*x-p*B,H=S*C-B*E;return U*+(q*d-i*r+z*v)+V*-(n*d-i*h+z*c)+A*+(n*r-q*h+z*H)+t*-(n*v-q*c+i*H)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!N)return this.ni;const V=this.ni;for(let A=0;A<16;A++)N[U+A]=V[A];return this}pi(){return this.ni}BV(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r.FromArrayToRef(N,U,this)}hi(){for(var N=arguments.length,U=new Array(N),V=0;V<N;V++)U[V]=arguments[V];return r.FromArrayToRef(U,0,this)}set(){const N=this.ni;for(let U=0;U<16;U++)N[U]=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}Hi(N){const U=this.ni;for(let V=0;V<16;V++)U[V]=N;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return r.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(N){const U=new r;return this.addToRef(N,U),U}addToRef(N,U){const V=this.ni,A=U.ni,t=N.m;for(let n=0;n<16;n++)A[n]=V[n]+t[n];return U.markAsUpdated(),U}addToSelf(N){const U=this.ni,V=N.m;return U[0]+=V[0],U[1]+=V[1],U[2]+=V[2],U[3]+=V[3],U[4]+=V[4],U[5]+=V[5],U[6]+=V[6],U[7]+=V[7],U[8]+=V[8],U[9]+=V[9],U[10]+=V[10],U[11]+=V[11],U[12]+=V[12],U[13]+=V[13],U[14]+=V[14],U[15]+=V[15],this.markAsUpdated(),this}addInPlace(N){const U=this.ni,V=N.m;for(let A=0;A<16;A++)U[A]+=V[A];return this.markAsUpdated(),this}addInPlaceFromFloats(){const N=this.ni;for(let U=0;U<16;U++)N[U]+=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}xU(N){const U=this.ni,V=N.m;for(let A=0;A<16;A++)U[A]-=V[A];return this.markAsUpdated(),this}subtractToRef(N,U){const V=this.ni,A=N.m,t=U.ni;for(let n=0;n<16;n++)t[n]=V[n]-A[n];return U.markAsUpdated(),U}Vp(N){const U=this.ni,V=N.m;for(let A=0;A<16;A++)U[A]-=V[A];return this.markAsUpdated(),this}subtractFromFloats(){for(var N=arguments.length,U=new Array(N),V=0;V<N;V++)U[V]=arguments[V];return this.subtractFromFloatsToRef(...U,new r)}subtractFromFloatsToRef(){for(var N=arguments.length,U=new Array(N),V=0;V<N;V++)U[V]=arguments[V];const A=U.pop(),t=this.ni,n=A.ni,q=U;for(let i=0;i<16;i++)n[i]=t[i]-q[i];return A.markAsUpdated(),A}invertToRef(N){return!0===this._isIdentity?(r.IdentityToRef(N),N):(k(this,N.pi())?N.markAsUpdated():N.A(this),N)}addAtIndex(N,U){return this.ni[N]+=U,this.markAsUpdated(),this}multiplyAtIndex(N,U){return this.ni[N]*=U,this.markAsUpdated(),this}setTranslationFromFloats(N,U,V){return this.ni[12]=N,this.ni[13]=U,this.ni[14]=V,this.markAsUpdated(),this}addTranslationFromFloats(N,U,V){return this.ni[12]+=N,this.ni[13]+=U,this.ni[14]+=V,this.markAsUpdated(),this}setTranslation(N){return this.setTranslationFromFloats(N._x,N._y,N._z)}getTranslation(){return new x(this.ni[12],this.ni[13],this.ni[14])}getTranslationToRef(N){return N.x=this.ni[12],N.y=this.ni[13],N.z=this.ni[14],N}removeRotationAndScaling(){const N=this.m;return r.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,N[12],N[13],N[14],N[15],this),this._updateIdentityStatus(0===N[12]&&0===N[13]&&0===N[14]&&1===N[15]),this}A(N){N.copyToArray(this.ni);const U=N;return this.updateFlag=U.updateFlag,this._updateIdentityStatus(U._isIdentity,U._isIdentityDirty,U._isIdentity3x2,U._isIdentity3x2Dirty),this}copyToArray(N){return p(this,N,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(N){const U=new r;return this.multiplyToRef(N,U),U}multiplyInPlace(N){const U=this.ni,V=N.m;for(let A=0;A<16;A++)U[A]*=V[A];return this.markAsUpdated(),this}multiplyByFloats(){const N=this.ni;for(let U=0;U<16;U++)N[U]*=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var N=arguments.length,U=new Array(N),V=0;V<N;V++)U[V]=arguments[V];const A=U.pop(),t=this.ni,n=A.ni,q=U;for(let i=0;i<16;i++)n[i]=t[i]*q[i];return A.markAsUpdated(),A}multiplyToRef(N,U){return this._isIdentity?(U.A(N),U):N._isIdentity?(U.A(this),U):(this.multiplyToArray(N,U.ni,0),U.markAsUpdated(),U)}multiplyToArray(N,U,V){return E(this,N,U,V),this}divide(N){return this.divideToRef(N,new r)}divideToRef(N,U){const V=this.ni,A=N.m,t=U.ni;for(let n=0;n<16;n++)t[n]=V[n]/A[n];return U.markAsUpdated(),U}divideInPlace(N){const U=this.ni,V=N.m;for(let A=0;A<16;A++)U[A]/=V[A];return this.markAsUpdated(),this}minimizeInPlace(N){const U=this.ni,V=N.m;for(let A=0;A<16;A++)U[A]=Math.min(U[A],V[A]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const N=this.ni;for(let U=0;U<16;U++)N[U]=Math.min(N[U],U<0||arguments.length<=U?void 0:arguments[U]);return this.markAsUpdated(),this}maximizeInPlace(N){const U=this.ni,V=N.m;for(let A=0;A<16;A++)U[A]=Math.min(U[A],V[A]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const N=this.ni;for(let U=0;U<16;U++)N[U]=Math.min(N[U],U<0||arguments.length<=U?void 0:arguments[U]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new r)}negateInPlace(){const N=this.ni;for(let U=0;U<16;U++)N[U]=-N[U];return this.markAsUpdated(),this}negateToRef(N){const U=this.ni,V=N.ni;for(let A=0;A<16;A++)V[A]=-U[A];return N.markAsUpdated(),N}equals(N){const U=N;if(!U)return!1;if((this._isIdentity||U._isIdentity)&&!this._isIdentityDirty&&!U._isIdentityDirty)return this._isIdentity&&U._isIdentity;const V=this.m,A=U.m;return V[0]===A[0]&&V[1]===A[1]&&V[2]===A[2]&&V[3]===A[3]&&V[4]===A[4]&&V[5]===A[5]&&V[6]===A[6]&&V[7]===A[7]&&V[8]===A[8]&&V[9]===A[9]&&V[10]===A[10]&&V[11]===A[11]&&V[12]===A[12]&&V[13]===A[13]&&V[14]===A[14]&&V[15]===A[15]}equalsWithEpsilon(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const V=this.ni,A=N.m;for(let t=0;t<16;t++)if(!(0,z.WithinEpsilon)(V[t],A[t],U))return!1;return!0}equalsToFloats(){const N=this.ni;for(let U=0;U<16;U++)if(N[U]!=(U<0||arguments.length<=U?void 0:arguments[U]))return!1;return!0}floor(){return this.floorToRef(new r)}floorToRef(N){const U=this.ni,V=N.ni;for(let A=0;A<16;A++)V[A]=Math.floor(U[A]);return N.markAsUpdated(),N}fract(){return this.fractToRef(new r)}fractToRef(N){const U=this.ni,V=N.ni;for(let A=0;A<16;A++)V[A]=U[A]-Math.floor(U[A]);return N.markAsUpdated(),N}clone(){const N=new r;return N.A(this),N}getClassName(){return"Matrix"}getHashCode(){let N=B(this.ni[0]);for(let U=1;U<16;U++)N=397*N^B(this.ni[U]);return N}decomposeToTransformNode(N){return N.rotationQuaternion=N.rotationQuaternion||new d,this.decompose(N.ci,N.rotationQuaternion,N.position)}decompose(N,U,V,A){let t=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return V&&V.Hi(0),N&&N.Hi(1),U&&U.hi(0,0,0,1),!0;const n=this.ni;if(V&&V.hi(n[12],n[13],n[14]),(N=N||v.CU[0]).x=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]),N.y=Math.sqrt(n[4]*n[4]+n[5]*n[5]+n[6]*n[6]),N.z=Math.sqrt(n[8]*n[8]+n[9]*n[9]+n[10]*n[10]),A){const U=(t?A.absoluteScaling.x:A.ci.x)<0?-1:1,V=(t?A.absoluteScaling.y:A.ci.y)<0?-1:1,n=(t?A.absoluteScaling.z:A.ci.z)<0?-1:1;N.x*=U,N.y*=V,N.z*=n}else this.determinant()<=0&&(N.y*=-1);if(0===N._x||0===N._y||0===N._z)return U&&U.hi(0,0,0,1),!1;if(U){const V=1/N._x,A=1/N._y,t=1/N._z;r.FromValuesToRef(n[0]*V,n[1]*V,n[2]*V,0,n[4]*A,n[5]*A,n[6]*A,0,n[8]*t,n[9]*t,n[10]*t,0,0,0,0,1,v.Matrix[0]),d.FromRotationMatrixToRef(v.Matrix[0],U)}return!0}getRow(N){if(N<0||N>3)return null;const U=4*N;return new J(this.ni[U+0],this.ni[U+1],this.ni[U+2],this.ni[U+3])}getRowToRef(N,U){if(N>=0&&N<=3){const V=4*N;U.x=this.ni[V+0],U.y=this.ni[V+1],U.z=this.ni[V+2],U.w=this.ni[V+3]}return U}setRow(N,U){return this.setRowFromFloats(N,U.x,U.y,U.z,U.w)}transpose(){const N=new r;return r.TransposeToRef(this,N),N}transposeToRef(N){return r.TransposeToRef(this,N),N}setRowFromFloats(N,U,V,A,t){if(N<0||N>3)return this;const n=4*N;return this.ni[n+0]=U,this.ni[n+1]=V,this.ni[n+2]=A,this.ni[n+3]=t,this.markAsUpdated(),this}scale(N){const U=new r;return this.scaleToRef(N,U),U}scaleToRef(N,U){for(let V=0;V<16;V++)U.ni[V]=this.ni[V]*N;return U.markAsUpdated(),U}scaleAndAddToRef(N,U){for(let V=0;V<16;V++)U.ni[V]+=this.ni[V]*N;return U.markAsUpdated(),U}scaleInPlace(N){const U=this.ni;for(let V=0;V<16;V++)U[V]*=N;return this.markAsUpdated(),this}toNormalMatrix(N){const U=v.Matrix[0];this.invertToRef(U),U.transposeToRef(N);const V=N.ni;return r.FromValuesToRef(V[0],V[1],V[2],0,V[4],V[5],V[6],0,V[8],V[9],V[10],0,0,0,0,1,N),N}getRotationMatrix(){const N=new r;return this.getRotationMatrixToRef(N),N}getRotationMatrixToRef(N){const U=v.CU[0];if(!this.decompose(U))return r.IdentityToRef(N),N;const V=this.ni,A=1/U._x,t=1/U._y,n=1/U._z;return r.FromValuesToRef(V[0]*A,V[1]*A,V[2]*A,0,V[4]*t,V[5]*t,V[6]*t,0,V[8]*n,V[9]*n,V[10]*n,0,0,0,0,1,N),N}toggleModelMatrixHandInPlace(){const N=this.ni;return N[2]*=-1,N[6]*=-1,N[8]*=-1,N[9]*=-1,N[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const N=this.ni;return N[8]*=-1,N[9]*=-1,N[10]*=-1,N[11]*=-1,this.markAsUpdated(),this}static vU(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const V=new r;return r.FromArrayToRef(N,U,V),V}static FromArrayToRef(N,U,V){for(let A=0;A<16;A++)V.ni[A]=N[A+U];return V.markAsUpdated(),V}static FromFloat32ArrayToRefScaled(N,U,V,A){return A.ni[0]=N[0+U]*V,A.ni[1]=N[1+U]*V,A.ni[2]=N[2+U]*V,A.ni[3]=N[3+U]*V,A.ni[4]=N[4+U]*V,A.ni[5]=N[5+U]*V,A.ni[6]=N[6+U]*V,A.ni[7]=N[7+U]*V,A.ni[8]=N[8+U]*V,A.ni[9]=N[9+U]*V,A.ni[10]=N[10+U]*V,A.ni[11]=N[11+U]*V,A.ni[12]=N[12+U]*V,A.ni[13]=N[13+U]*V,A.ni[14]=N[14+U]*V,A.ni[15]=N[15+U]*V,A.markAsUpdated(),A}static get IdentityReadOnly(){return r._IdentityReadOnly}static FromValuesToRef(N,U,V,A,t,n,q,i,z,S,E,p,k,B,C,x,J){const d=J.ni;d[0]=N,d[1]=U,d[2]=V,d[3]=A,d[4]=t,d[5]=n,d[6]=q,d[7]=i,d[8]=z,d[9]=S,d[10]=E,d[11]=p,d[12]=k,d[13]=B,d[14]=C,d[15]=x,J.markAsUpdated()}static FromValues(N,U,V,A,t,n,q,i,z,S,E,p,k,B,C,x){const J=new r,d=J.ni;return d[0]=N,d[1]=U,d[2]=V,d[3]=A,d[4]=t,d[5]=n,d[6]=q,d[7]=i,d[8]=z,d[9]=S,d[10]=E,d[11]=p,d[12]=k,d[13]=B,d[14]=C,d[15]=x,J.markAsUpdated(),J}static Compose(N,U,V){const A=new r;return r.ComposeToRef(N,U,V,A),A}static ComposeToRef(N,U,V,A){const t=A.ni,n=U._x,q=U._y,i=U._z,z=U._w,S=n+n,E=q+q,p=i+i,k=n*S,B=n*E,C=n*p,x=q*E,J=q*p,d=i*p,r=z*S,v=z*E,h=z*p,c=N._x,H=N._y,Y=N._z;return t[0]=(1-(x+d))*c,t[1]=(B+h)*c,t[2]=(C-v)*c,t[3]=0,t[4]=(B-h)*H,t[5]=(1-(k+d))*H,t[6]=(J+r)*H,t[7]=0,t[8]=(C+v)*Y,t[9]=(J-r)*Y,t[10]=(1-(k+x))*Y,t[11]=0,t[12]=V._x,t[13]=V._y,t[14]=V._z,t[15]=1,A.markAsUpdated(),A}static Identity(){const N=r.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return N._updateIdentityStatus(!0),N}static IdentityToRef(N){return r.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,N),N._updateIdentityStatus(!0),N}static Zero(){const N=r.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return N._updateIdentityStatus(!1),N}static RotationX(N){const U=new r;return r.RotationXToRef(N,U),U}static Invert(N){const U=new r;return N.invertToRef(U),U}static RotationXToRef(N,U){const V=Math.sin(N),A=Math.cos(N);return r.FromValuesToRef(1,0,0,0,0,A,V,0,0,-V,A,0,0,0,0,1,U),U._updateIdentityStatus(1===A&&0===V),U}static RotationY(N){const U=new r;return r.RotationYToRef(N,U),U}static RotationYToRef(N,U){const V=Math.sin(N),A=Math.cos(N);return r.FromValuesToRef(A,0,-V,0,0,1,0,0,V,0,A,0,0,0,0,1,U),U._updateIdentityStatus(1===A&&0===V),U}static RotationZ(N){const U=new r;return r.RotationZToRef(N,U),U}static RotationZToRef(N,U){const V=Math.sin(N),A=Math.cos(N);return r.FromValuesToRef(A,V,0,0,-V,A,0,0,0,0,1,0,0,0,0,1,U),U._updateIdentityStatus(1===A&&0===V),U}static RotationAxis(N,U){const V=new r;return r.RotationAxisToRef(N,U,V),V}static RotationAxisToRef(N,U,V){const A=Math.sin(-U),t=Math.cos(-U),n=1-t;N=N.normalizeToRef(v.CU[0]);const q=V.ni;return q[0]=N._x*N._x*n+t,q[1]=N._x*N._y*n-N._z*A,q[2]=N._x*N._z*n+N._y*A,q[3]=0,q[4]=N._y*N._x*n+N._z*A,q[5]=N._y*N._y*n+t,q[6]=N._y*N._z*n-N._x*A,q[7]=0,q[8]=N._z*N._x*n-N._y*A,q[9]=N._z*N._y*n+N._x*A,q[10]=N._z*N._z*n+t,q[11]=0,q[12]=0,q[13]=0,q[14]=0,q[15]=1,V.markAsUpdated(),V}static RotationAlignToRef(N,U,V){let t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const n=x.Dot(U,N),q=V.ni;if(n<-1+A.d)q[0]=-1,q[1]=0,q[2]=0,q[3]=0,q[4]=0,q[5]=t?1:-1,q[6]=0,q[7]=0,q[8]=0,q[9]=0,q[10]=t?-1:1,q[11]=0;else{const V=x.Cross(U,N),A=1/(1+n);q[0]=V._x*V._x*A+n,q[1]=V._y*V._x*A-V._z,q[2]=V._z*V._x*A+V._y,q[3]=0,q[4]=V._x*V._y*A+V._z,q[5]=V._y*V._y*A+n,q[6]=V._z*V._y*A-V._x,q[7]=0,q[8]=V._x*V._z*A-V._y,q[9]=V._y*V._z*A+V._x,q[10]=V._z*V._z*A+n,q[11]=0}return q[12]=0,q[13]=0,q[14]=0,q[15]=1,V.markAsUpdated(),V}static RotationYawPitchRoll(N,U,V){const A=new r;return r.RotationYawPitchRollToRef(N,U,V,A),A}static RotationYawPitchRollToRef(N,U,V,A){return d.RotationYawPitchRollToRef(N,U,V,v.Quaternion[0]),v.Quaternion[0].toRotationMatrix(A),A}static Scaling(N,U,V){const A=new r;return r.ScalingToRef(N,U,V,A),A}static ScalingToRef(N,U,V,A){return r.FromValuesToRef(N,0,0,0,0,U,0,0,0,0,V,0,0,0,0,1,A),A._updateIdentityStatus(1===N&&1===U&&1===V),A}static Translation(N,U,V){const A=new r;return r.TranslationToRef(N,U,V,A),A}static TranslationToRef(N,U,V,A){return r.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,N,U,V,1,A),A._updateIdentityStatus(0===N&&0===U&&0===V),A}static Lerp(N,U,V){const A=new r;return r.LerpToRef(N,U,V,A),A}static LerpToRef(N,U,V,A){const t=A.ni,n=N.m,q=U.m;for(let i=0;i<16;i++)t[i]=n[i]*(1-V)+q[i]*V;return A.markAsUpdated(),A}static DecomposeLerp(N,U,V){const A=new r;return r.DecomposeLerpToRef(N,U,V,A),A}static DecomposeLerpToRef(N,U,V,A){const t=v.CU[0],n=v.Quaternion[0],q=v.CU[1];N.decompose(t,n,q);const i=v.CU[2],z=v.Quaternion[1],S=v.CU[3];U.decompose(i,z,S);const E=v.CU[4];x.LerpToRef(t,i,V,E);const p=v.Quaternion[2];d.SlerpToRef(n,z,V,p);const k=v.CU[5];return x.LerpToRef(q,S,V,k),r.ComposeToRef(E,p,k,A),A}static LookAtLH(N,U,V){const A=new r;return r.LookAtLHToRef(N,U,V,A),A}static LookAtLHToRef(N,U,V,A){const t=v.CU[0],n=v.CU[1],q=v.CU[2];U.subtractToRef(N,q),q.normalize(),x.CrossToRef(V,q,t);const i=t.lengthSquared();0===i?t.x=1:t.normalizeFromLength(Math.sqrt(i)),x.CrossToRef(q,t,n),n.normalize();const z=-x.Dot(t,N),S=-x.Dot(n,N),E=-x.Dot(q,N);return r.FromValuesToRef(t._x,n._x,q._x,0,t._y,n._y,q._y,0,t._z,n._z,q._z,0,z,S,E,1,A),A}static LookAtRH(N,U,V){const A=new r;return r.LookAtRHToRef(N,U,V,A),A}static LookAtRHToRef(N,U,V,A){const t=v.CU[0],n=v.CU[1],q=v.CU[2];N.subtractToRef(U,q),q.normalize(),x.CrossToRef(V,q,t);const i=t.lengthSquared();0===i?t.x=1:t.normalizeFromLength(Math.sqrt(i)),x.CrossToRef(q,t,n),n.normalize();const z=-x.Dot(t,N),S=-x.Dot(n,N),E=-x.Dot(q,N);return r.FromValuesToRef(t._x,n._x,q._x,0,t._y,n._y,q._y,0,t._z,n._z,q._z,0,z,S,E,1,A),A}static LookDirectionLH(N,U){const V=new r;return r.LookDirectionLHToRef(N,U,V),V}static LookDirectionLHToRef(N,U,V){const A=v.CU[0];A.A(N),A.scaleInPlace(-1);const t=v.CU[1];return x.CrossToRef(U,A,t),r.FromValuesToRef(t._x,t._y,t._z,0,U._x,U._y,U._z,0,A._x,A._y,A._z,0,0,0,0,1,V),V}static LookDirectionRH(N,U){const V=new r;return r.LookDirectionRHToRef(N,U,V),V}static LookDirectionRHToRef(N,U,V){const A=v.CU[2];return x.CrossToRef(U,N,A),r.FromValuesToRef(A._x,A._y,A._z,0,U._x,U._y,U._z,0,N._x,N._y,N._z,0,0,0,0,1,V),V}static OrthoLH(N,U,V,A,t){const n=new r;return r.OrthoLHToRef(N,U,V,A,n,t),n}static OrthoLHToRef(N,U,V,A,t,n){const q=2/N,i=2/U,z=2/(A-V),S=-(A+V)/(A-V);return r.FromValuesToRef(q,0,0,0,0,i,0,0,0,0,z,0,0,0,S,1,t),n&&t.multiplyToRef(c,t),t._updateIdentityStatus(1===q&&1===i&&1===z&&0===S),t}static OrthoOffCenterLH(N,U,V,A,t,n,q){const i=new r;return r.OrthoOffCenterLHToRef(N,U,V,A,t,n,i,q),i}static OrthoOffCenterLHToRef(N,U,V,A,t,n,q,i){const z=2/(U-N),S=2/(A-V),E=2/(n-t),p=-(n+t)/(n-t),k=(N+U)/(N-U),B=(A+V)/(V-A);return r.FromValuesToRef(z,0,0,0,0,S,0,0,0,0,E,0,k,B,p,1,q),i&&q.multiplyToRef(c,q),q.markAsUpdated(),q}static ObliqueOffCenterLHToRef(N,U,V,A,t,n,q,i,z,S,E){const p=-q*Math.cos(i),k=-q*Math.sin(i);return r.TranslationToRef(0,0,-z,v.Matrix[1]),r.FromValuesToRef(1,0,0,0,0,1,0,0,p,k,1,0,0,0,0,1,v.Matrix[0]),v.Matrix[1].multiplyToRef(v.Matrix[0],v.Matrix[0]),r.TranslationToRef(0,0,z,v.Matrix[1]),v.Matrix[0].multiplyToRef(v.Matrix[1],v.Matrix[0]),r.OrthoOffCenterLHToRef(N,U,V,A,t,n,S,E),v.Matrix[0].multiplyToRef(S,S),S}static OrthoOffCenterRH(N,U,V,A,t,n,q){const i=new r;return r.OrthoOffCenterRHToRef(N,U,V,A,t,n,i,q),i}static OrthoOffCenterRHToRef(N,U,V,A,t,n,q,i){return r.OrthoOffCenterLHToRef(N,U,V,A,t,n,q,i),q.ni[10]*=-1,q}static ObliqueOffCenterRHToRef(N,U,V,A,t,n,q,i,z,S,E){const p=q*Math.cos(i),k=q*Math.sin(i);return r.TranslationToRef(0,0,z,v.Matrix[1]),r.FromValuesToRef(1,0,0,0,0,1,0,0,p,k,1,0,0,0,0,1,v.Matrix[0]),v.Matrix[1].multiplyToRef(v.Matrix[0],v.Matrix[0]),r.TranslationToRef(0,0,-z,v.Matrix[1]),v.Matrix[0].multiplyToRef(v.Matrix[1],v.Matrix[0]),r.OrthoOffCenterRHToRef(N,U,V,A,t,n,S,E),v.Matrix[0].multiplyToRef(S,S),S}static PerspectiveLH(N,U,V,A,t){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const q=new r,i=2*V/N,z=2*V/U,S=(A+V)/(A-V),E=-2*A*V/(A-V),p=Math.tan(n);return r.FromValuesToRef(i,0,0,0,0,z,0,p,0,0,S,1,0,0,E,0,q),t&&q.multiplyToRef(c,q),q._updateIdentityStatus(!1),q}static PerspectiveFovLH(N,U,V,A,t){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const i=new r;return r.PerspectiveFovLHToRef(N,U,V,A,i,!0,t,n,q),i}static PerspectiveFovLHToRef(N,U,V,A,t){let n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,z=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const S=V,E=A,p=1/Math.tan(.5*N),k=n?p/U:p,B=n?p:p*U,C=z&&0===S?-1:0!==E?(E+S)/(E-S):1,x=z&&0===S?2*E:0!==E?-2*E*S/(E-S):-2*S,J=Math.tan(i);return r.FromValuesToRef(k,0,0,0,0,B,0,J,0,0,C,1,0,0,x,0,t),q&&t.multiplyToRef(c,t),t._updateIdentityStatus(!1),t}static PerspectiveFovReverseLHToRef(N,U,V,A,t){let n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const z=1/Math.tan(.5*N),S=n?z/U:z,E=n?z:z*U,p=Math.tan(i);return r.FromValuesToRef(S,0,0,0,0,E,0,p,0,0,-V,1,0,0,1,0,t),q&&t.multiplyToRef(c,t),t._updateIdentityStatus(!1),t}static PerspectiveFovRH(N,U,V,A,t){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const i=new r;return r.PerspectiveFovRHToRef(N,U,V,A,i,!0,t,n,q),i}static PerspectiveFovRHToRef(N,U,V,A,t){let n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,z=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const S=V,E=A,p=1/Math.tan(.5*N),k=n?p/U:p,B=n?p:p*U,C=z&&0===S?1:0!==E?-(E+S)/(E-S):-1,x=z&&0===S?2*E:0!==E?-2*E*S/(E-S):-2*S,J=Math.tan(i);return r.FromValuesToRef(k,0,0,0,0,B,0,J,0,0,C,-1,0,0,x,0,t),q&&t.multiplyToRef(c,t),t._updateIdentityStatus(!1),t}static PerspectiveFovReverseRHToRef(N,U,V,A,t){let n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],q=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const z=1/Math.tan(.5*N),S=n?z/U:z,E=n?z:z*U,p=Math.tan(i);return r.FromValuesToRef(S,0,0,0,0,E,0,p,0,0,-V,-1,0,0,-1,0,t),q&&t.multiplyToRef(c,t),t._updateIdentityStatus(!1),t}static GetFinalMatrix(N,U,V,A,t,n){const q=N.width,i=N.height,z=N.x,S=N.y,E=r.FromValues(q/2,0,0,0,0,-i/2,0,0,0,0,n-t,0,z+q/2,i/2+S,t,1),p=new r;return U.multiplyToRef(V,p),p.multiplyToRef(A,p),p.multiplyToRef(E,p)}static GetAsMatrix2x2(N){const U=N.m,V=[U[0],U[1],U[4],U[5]];return q.c.MatrixUse64Bits?V:new Float32Array(V)}static GetAsMatrix3x3(N){const U=N.m,V=[U[0],U[1],U[2],U[4],U[5],U[6],U[8],U[9],U[10]];return q.c.MatrixUse64Bits?V:new Float32Array(V)}static Transpose(N){const U=new r;return r.TransposeToRef(N,U),U}static TransposeToRef(N,U){const V=N.m,A=V[0],t=V[4],n=V[8],q=V[12],i=V[1],z=V[5],S=V[9],E=V[13],p=V[2],k=V[6],B=V[10],C=V[14],x=V[3],J=V[7],d=V[11],r=V[15],v=U.ni;return v[0]=A,v[1]=t,v[2]=n,v[3]=q,v[4]=i,v[5]=z,v[6]=S,v[7]=E,v[8]=p,v[9]=k,v[10]=B,v[11]=C,v[12]=x,v[13]=J,v[14]=d,v[15]=r,U.markAsUpdated(),U._updateIdentityStatus(N._isIdentity,N._isIdentityDirty),U}static Reflection(N){const U=new r;return r.ReflectionToRef(N,U),U}static ReflectionToRef(N,U){N.normalize();const V=N.normal.x,A=N.normal.y,t=N.normal.z,n=-2*V,q=-2*A,i=-2*t;return r.FromValuesToRef(n*V+1,q*V,i*V,0,n*A,q*A+1,i*A,0,n*t,q*t,i*t+1,0,n*N.d,q*N.d,i*N.d,1,U),U}static FromXYZAxesToRef(N,U,V,A){return r.FromValuesToRef(N._x,N._y,N._z,0,U._x,U._y,U._z,0,V._x,V._y,V._z,0,0,0,0,1,A),A}static FromQuaternionToRef(N,U){const V=N._x*N._x,A=N._y*N._y,t=N._z*N._z,n=N._x*N._y,q=N._z*N._w,i=N._z*N._x,z=N._y*N._w,S=N._y*N._z,E=N._x*N._w;return U.ni[0]=1-2*(A+t),U.ni[1]=2*(n+q),U.ni[2]=2*(i-z),U.ni[3]=0,U.ni[4]=2*(n-q),U.ni[5]=1-2*(t+V),U.ni[6]=2*(S+E),U.ni[7]=0,U.ni[8]=2*(i+z),U.ni[9]=2*(S-E),U.ni[10]=1-2*(A+V),U.ni[11]=0,U.ni[12]=0,U.ni[13]=0,U.ni[14]=0,U.ni[15]=1,U.markAsUpdated(),U}}r._IdentityReadOnly=r.Identity(),Object.defineProperties(r.prototype,{dimension:{value:[4,4]},rank:{value:2}});class v{}v.CU=(0,t.c)(11,x.Zero),v.Matrix=(0,t.c)(2,r.Identity),v.Quaternion=(0,t.c)(3,d.Zero);class h{}h.Vector2=(0,t.c)(3,C.Zero),h.CU=(0,t.c)(13,x.Zero),h.Vector4=(0,t.c)(3,J.Zero),h.Quaternion=(0,t.c)(3,d.Zero),h.Matrix=(0,t.c)(8,r.Identity),(0,n.e)("BABYLON.Vector2",C),(0,n.e)("BABYLON.Vector3",x),(0,n.e)("BABYLON.Vector4",J),(0,n.e)("BABYLON.Matrix",r);const c=r.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12392:(N,U,V)=>{function A(N,U){const V=[];for(let A=0;A<N;++A)V.push(U());return V}function t(N,U){return A(N,U)}V.d(U,{b:()=>A,c:()=>t,g:()=>q});const n=["push","splice","pop","shift","unshift"];function q(N,U){const V=n.map((V=>function(N,U,V){const A=N[U];if("function"!==typeof A)return null;const t=function(){const A=N.length,n=t.previous.apply(N,arguments);return V(U,A),n};return A.next=t,t.previous=A,N[U]=t,()=>{const V=t.previous;if(!V)return;const A=t.next;A?(V.next=A,A.previous=V):(V.next=void 0,N[U]=V),t.next=void 0,t.previous=void 0}}(N,V,U)));return()=>{for(const N of V)null===N||void 0===N||N()}}}}]);