"use strict";(self["3gghkoft8x"]=self["3gghkoft8x"]||[]).push([[14],{12325:(y,S,I)=>{I.d(S,{c:()=>B,f:()=>A,g:()=>V,h:()=>i});const V=1/2.2,i=2.2,A=(1+Math.sqrt(5))/2,B=.001},12338:(y,S,I)=>{function V(y){return parseInt(y.toString().replace(/\W/g,""))}function i(y,S){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(y-S)<=I}function A(y,S,I){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return y<S-V||y>I+V}function B(y,S){return y===S?y:Math.random()*(S-y)+y}function d(y,S,I){return y+(S-y)*I}function F(y,S,I){let V=l(S-y,360);return V>180&&(V-=360),y+V*G(I)}function J(y,S,I){let V=0;return V=y!=S?G((I-y)/(S-y)):0,V}function u(y,S,I,V,i){const A=i*i,B=i*A;return y*(2*B-3*A+1)+I*(-2*B+3*A)+S*(B-2*A+i)+V*(B-A)}function K(y,S,I,V,i){const A=i*i;return 6*(A-i)*y+(3*A-4*i+1)*S+6*(-A+i)*I+(3*A-2*i)*V}function G(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(I,Math.max(S,y))}function p(y){return y-=2*Math.PI*Math.floor((y+Math.PI)/(2*Math.PI))}function L(y){const S=y.toString(16);return y<=15?("0"+S).toUpperCase():S.toUpperCase()}function T(y){if(Math.log2)return Math.floor(Math.log2(y));if(y<0)return NaN;if(0===y)return-1/0;let S=0;if(y<1){for(;y<1;)S++,y*=2;S=-S}else if(y>1)for(;y>1;)S++,y=Math.floor(y/2);return S}function l(y,S){return y-Math.floor(y/S)*S}function j(y,S,I){return(y-S)/(I-S)}function s(y,S,I){return y*(I-S)+S}function O(y,S){let I=l(S-y,360);return I>180&&(I-=360),I}function f(y,S){const I=l(y,2*S);return S-Math.abs(I-S)}function my(y,S,I){let V=G(I);return V=-2*V*V*V+3*V*V,S*V+y*(1-V)}function C(y,S,I){let V=0;return V=Math.abs(S-y)<=I?S:y+Math.sign(S-y)*I,V}function D(y,S,I){const V=O(y,S);let i=0;return i=-I<V&&V<I?S:C(y,S=y+V,I),i}function o(y,S,I){return(y-S)/(I-S)}function E(y,S,I){return(I-S)*y+S}function z(y,S){const I=y%S;return 0===I?S:z(S,I)}I.r(S),I.d(S,{Clamp:()=>G,DeltaAngle:()=>O,Denormalize:()=>s,ExtractAsInt:()=>V,Hermite:()=>u,Hermite1stDerivative:()=>K,HighestCommonFactor:()=>z,ILog2:()=>T,InverseLerp:()=>J,Lerp:()=>d,LerpAngle:()=>F,MoveTowards:()=>C,MoveTowardsAngle:()=>D,Normalize:()=>j,NormalizeRadians:()=>p,OutsideRange:()=>A,PercentToRange:()=>E,PingPong:()=>f,RandomRange:()=>B,RangeToPercent:()=>o,Repeat:()=>l,SmoothStep:()=>my,ToHex:()=>L,WithinEpsilon:()=>i})},12321:(y,S,I)=>{I.r(S),I.d(S,{Matrix:()=>s,Quaternion:()=>j,TmpVectors:()=>f,Vector2:()=>L,OS:()=>T,Vector4:()=>l});var V=I(12325),i=I(12331),A=I(12282),B=I(12260),d=I(12185),F=I(12338);class J{}function u(y,S,I){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const i=y.Vd(),A=S.Vd(),B=i[0],d=i[1],F=i[2],J=i[3],u=i[4],K=i[5],G=i[6],p=i[7],L=i[8],T=i[9],l=i[10],j=i[11],s=i[12],O=i[13],f=i[14],my=i[15],C=A[0],D=A[1],o=A[2],E=A[3],z=A[4],r=A[5],h=A[6],n=A[7],v=A[8],P=A[9],q=A[10],g=A[11],k=A[12],R=A[13],b=A[14],U=A[15];I[V]=B*C+d*z+F*v+J*k,I[V+1]=B*D+d*r+F*P+J*R,I[V+2]=B*o+d*h+F*q+J*b,I[V+3]=B*E+d*n+F*g+J*U,I[V+4]=u*C+K*z+G*v+p*k,I[V+5]=u*D+K*r+G*P+p*R,I[V+6]=u*o+K*h+G*q+p*b,I[V+7]=u*E+K*n+G*g+p*U,I[V+8]=L*C+T*z+l*v+j*k,I[V+9]=L*D+T*r+l*P+j*R,I[V+10]=L*o+T*h+l*q+j*b,I[V+11]=L*E+T*n+l*g+j*U,I[V+12]=s*C+O*z+f*v+my*k,I[V+13]=s*D+O*r+f*P+my*R,I[V+14]=s*o+O*h+f*q+my*b,I[V+15]=s*E+O*n+f*g+my*U}function K(y,S){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const V=y.Vd();S[I]=V[0],S[I+1]=V[1],S[I+2]=V[2],S[I+3]=V[3],S[I+4]=V[4],S[I+5]=V[5],S[I+6]=V[6],S[I+7]=V[7],S[I+8]=V[8],S[I+9]=V[9],S[I+10]=V[10],S[I+11]=V[11],S[I+12]=V[12],S[I+13]=V[13],S[I+14]=V[14],S[I+15]=V[15]}function G(y,S){const I=y.Vd(),V=I[0],i=I[1],A=I[2],B=I[3],d=I[4],F=I[5],J=I[6],u=I[7],K=I[8],G=I[9],p=I[10],L=I[11],T=I[12],l=I[13],j=I[14],s=I[15],O=p*s-j*L,f=G*s-l*L,my=G*j-l*p,C=K*s-T*L,D=K*j-p*T,o=K*l-T*G,E=+(F*O-J*f+u*my),z=-(d*O-J*C+u*D),r=+(d*f-F*C+u*o),h=-(d*my-F*D+J*o),n=V*E+i*z+A*r+B*h;if(0===n)return!1;const v=1/n,P=J*s-j*u,q=F*s-l*u,g=F*j-l*J,k=d*s-T*u,R=d*j-T*J,b=d*l-T*F,U=J*L-p*u,W=F*L-G*u,a=F*p-G*J,e=d*L-K*u,x=d*p-K*J,Q=d*G-K*F,c=-(i*O-A*f+B*my),X=+(V*O-A*C+B*D),M=-(V*f-i*C+B*o),t=+(V*my-i*D+A*o),N=+(i*P-A*q+B*g),Y=-(V*P-A*k+B*R),H=+(V*q-i*k+B*b),Z=-(V*g-i*R+A*b),w=-(i*U-A*W+B*a),yy=+(V*U-A*e+B*x),Sy=-(V*W-i*e+B*Q),Iy=+(V*a-i*x+A*Q);return S[0]=E*v,S[1]=c*v,S[2]=N*v,S[3]=w*v,S[4]=z*v,S[5]=X*v,S[6]=Y*v,S[7]=yy*v,S[8]=r*v,S[9]=M*v,S[10]=H*v,S[11]=Sy*v,S[12]=h*v,S[13]=t*v,S[14]=Z*v,S[15]=Iy*v,!0}J._UpdateFlagSeed=0;const p=y=>parseInt(y.toString().replace(/\W/g,""));class L{constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=y,this.y=S}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let y=p(this.x);return y=397*y^p(this.y),y}toArray(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y[S]=this.x,y[S+1]=this.y,this}sI(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(y,S,this),this}Vd(){return[this.x,this.y]}A(y){return this.x=y.x,this.y=y.y,this}od(y,S){return this.x=y,this.y=S,this}set(y,S){return this.od(y,S)}nd(y){return this.od(y,y)}add(y){return new L(this.x+y.x,this.y+y.y)}addToRef(y,S){return S.x=this.x+y.x,S.y=this.y+y.y,S}addInPlace(y){return this.x+=y.x,this.y+=y.y,this}addInPlaceFromFloats(y,S){return this.x+=y,this.y+=S,this}addVector3(y){return new L(this.x+y.x,this.y+y.y)}fS(y){return new L(this.x-y.x,this.y-y.y)}subtractToRef(y,S){return S.x=this.x-y.x,S.y=this.y-y.y,S}uK(y){return this.x-=y.x,this.y-=y.y,this}multiplyInPlace(y){return this.x*=y.x,this.y*=y.y,this}multiply(y){return new L(this.x*y.x,this.y*y.y)}multiplyToRef(y,S){return S.x=this.x*y.x,S.y=this.y*y.y,S}multiplyByFloats(y,S){return new L(this.x*y,this.y*S)}divide(y){return new L(this.x/y.x,this.y/y.y)}divideToRef(y,S){return S.x=this.x/y.x,S.y=this.y/y.y,S}divideInPlace(y){return this.x=this.x/y.x,this.y=this.y/y.y,this}minimizeInPlace(y){return this.minimizeInPlaceFromFloats(y.x,y.y)}maximizeInPlace(y){return this.maximizeInPlaceFromFloats(y.x,y.y)}minimizeInPlaceFromFloats(y,S){return this.x=Math.min(y,this.x),this.y=Math.min(S,this.y),this}maximizeInPlaceFromFloats(y,S){return this.x=Math.max(y,this.x),this.y=Math.max(S,this.y),this}subtractFromFloats(y,S){return new L(this.x-y,this.y-S)}subtractFromFloatsToRef(y,S,I){return I.x=this.x-y,I.y=this.y-S,I}negate(){return new L(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(y){return y.x=-this.x,y.y=-this.y,y}scaleInPlace(y){return this.x*=y,this.y*=y,this}scale(y){return new L(this.x*y,this.y*y)}scaleToRef(y,S){return S.x=this.x*y,S.y=this.y*y,S}scaleAndAddToRef(y,S){return S.x+=this.x*y,S.y+=this.y*y,S}equals(y){return y&&this.x===y.x&&this.y===y.y}equalsWithEpsilon(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.c;return y&&(0,F.WithinEpsilon)(this.x,y.x,S)&&(0,F.WithinEpsilon)(this.y,y.y,S)}equalsToFloats(y,S){return this.x===y&&this.y===S}floor(){return new L(Math.floor(this.x),Math.floor(this.y))}floorToRef(y){return y.x=Math.floor(this.x),y.y=Math.floor(this.y),y}fract(){return new L(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(y){return y.x=this.x-Math.floor(this.x),y.y=this.y-Math.floor(this.y),y}rotate(y){return this.rotateToRef(y,new L)}rotateToRef(y,S){const I=Math.cos(y),V=Math.sin(y);return S.x=I*this.x-V*this.y,S.y=V*this.x+I*this.y,S}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(y){return 0===y||1===y?this:this.scaleInPlace(1/y)}normalizeToNew(){const y=new L;return this.normalizeToRef(y),y}normalizeToRef(y){const S=this.length();return 0===S&&(y.x=this.x,y.y=this.y),this.scaleToRef(1/S,y)}clone(){return new L(this.x,this.y)}dot(y){return this.x*y.x+this.y*y.y}static Zero(){return new L(0,0)}static One(){return new L(1,1)}static Random(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new L((0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S))}static RandomToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).od((0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S))}static get ZeroReadOnly(){return L._ZeroReadOnly}static oS(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new L(y[S],y[S+1])}static FromArrayToRef(y,S,I){return I.x=y[S],I.y=y[S+1],I}static FromFloatsToRef(y,S,I){return I.od(y,S),I}static CatmullRom(y,S,I,V,i){const A=i*i,B=i*A,d=.5*(2*S.x+(-y.x+I.x)*i+(2*y.x-5*S.x+4*I.x-V.x)*A+(-y.x+3*S.x-3*I.x+V.x)*B),F=.5*(2*S.y+(-y.y+I.y)*i+(2*y.y-5*S.y+4*I.y-V.y)*A+(-y.y+3*S.y-3*I.y+V.y)*B);return new L(d,F)}static ClampToRef(y,S,I,V){return V.x=(0,F.Clamp)(y.x,S.x,I.x),V.y=(0,F.Clamp)(y.y,S.y,I.y),V}static Clamp(y,S,I){const V=(0,F.Clamp)(y.x,S.x,I.x),i=(0,F.Clamp)(y.y,S.y,I.y);return new L(V,i)}static Hermite(y,S,I,V,i){const A=i*i,B=i*A,d=2*B-3*A+1,F=-2*B+3*A,J=B-2*A+i,u=B-A,K=y.x*d+I.x*F+S.x*J+V.x*u,G=y.y*d+I.y*F+S.y*J+V.y*u;return new L(K,G)}static Hermite1stDerivative(y,S,I,V,i){return this.Hermite1stDerivativeToRef(y,S,I,V,i,new L)}static Hermite1stDerivativeToRef(y,S,I,V,i,A){const B=i*i;return A.x=6*(B-i)*y.x+(3*B-4*i+1)*S.x+6*(-B+i)*I.x+(3*B-2*i)*V.x,A.y=6*(B-i)*y.y+(3*B-4*i+1)*S.y+6*(-B+i)*I.y+(3*B-2*i)*V.y,A}static Lerp(y,S,I){return L.LerpToRef(y,S,I,new L)}static LerpToRef(y,S,I,V){return V.x=y.x+(S.x-y.x)*I,V.y=y.y+(S.y-y.y)*I,V}static Dot(y,S){return y.x*S.x+y.y*S.y}static Normalize(y){return L.NormalizeToRef(y,new L)}static NormalizeToRef(y,S){return y.normalizeToRef(S),S}static Minimize(y,S){const I=y.x<S.x?y.x:S.x,V=y.y<S.y?y.y:S.y;return new L(I,V)}static Maximize(y,S){const I=y.x>S.x?y.x:S.x,V=y.y>S.y?y.y:S.y;return new L(I,V)}static Transform(y,S){return L.TransformToRef(y,S,new L)}static TransformToRef(y,S,I){const V=S.m,i=y.x*V[0]+y.y*V[4]+V[12],A=y.x*V[1]+y.y*V[5]+V[13];return I.x=i,I.y=A,I}static PointInTriangle(y,S,I,V){const i=.5*(-I.y*V.x+S.y*(-I.x+V.x)+S.x*(I.y-V.y)+I.x*V.y),A=i<0?-1:1,B=(S.y*V.x-S.x*V.y+(V.y-S.y)*y.x+(S.x-V.x)*y.y)*A,d=(S.x*I.y-S.y*I.x+(S.y-I.y)*y.x+(I.x-S.x)*y.y)*A;return B>0&&d>0&&B+d<2*i*A}static Distance(y,S){return Math.sqrt(L.DistanceSquared(y,S))}static DistanceSquared(y,S){const I=y.x-S.x,V=y.y-S.y;return I*I+V*V}static Center(y,S){return L.CenterToRef(y,S,new L)}static CenterToRef(y,S,I){return I.od((y.x+S.x)/2,(y.y+S.y)/2)}static DistanceOfPointFromSegment(y,S,I){const V=L.DistanceSquared(S,I);if(0===V)return L.Distance(y,S);const i=I.fS(S),A=Math.max(0,Math.min(1,L.Dot(y.fS(S),i)/V)),B=S.add(i.multiplyByFloats(A,A));return L.Distance(y,B)}}L._V8PerformanceHack=new L(.5,.5),L._ZeroReadOnly=L.Zero(),Object.defineProperties(L.prototype,{dimension:{value:[2]},rank:{value:1}});class T{get x(){return this._x}set x(y){this._x=y,this._isDirty=!0}get y(){return this._y}set y(y){this._y=y,this._isDirty=!0}get z(){return this._z}set z(y){this._z=y,this._isDirty=!0}constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=y,this._y=S,this._z=I}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"OS"}getHashCode(){let y=p(this._x);return y=397*y^p(this._y),y=397*y^p(this._z),y}Vd(){return[this._x,this._y,this._z]}toArray(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y[S]=this._x,y[S+1]=this._y,y[S+2]=this._z,this}sI(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return T.FromArrayToRef(y,S,this),this}toQuaternion(){return j.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(y){return this._x+=y._x,this._y+=y._y,this._z+=y._z,this._isDirty=!0,this}addInPlaceFromFloats(y,S,I){return this._x+=y,this._y+=S,this._z+=I,this._isDirty=!0,this}add(y){return new T(this._x+y._x,this._y+y._y,this._z+y._z)}addToRef(y,S){return S._x=this._x+y._x,S._y=this._y+y._y,S._z=this._z+y._z,S._isDirty=!0,S}uK(y){return this._x-=y._x,this._y-=y._y,this._z-=y._z,this._isDirty=!0,this}fS(y){return new T(this._x-y._x,this._y-y._y,this._z-y._z)}subtractToRef(y,S){return this.subtractFromFloatsToRef(y._x,y._y,y._z,S)}subtractFromFloats(y,S,I){return new T(this._x-y,this._y-S,this._z-I)}subtractFromFloatsToRef(y,S,I,V){return V._x=this._x-y,V._y=this._y-S,V._z=this._z-I,V._isDirty=!0,V}negate(){return new T(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(y){return y._x=-1*this._x,y._y=-1*this._y,y._z=-1*this._z,y._isDirty=!0,y}scaleInPlace(y){return this._x*=y,this._y*=y,this._z*=y,this._isDirty=!0,this}scale(y){return new T(this._x*y,this._y*y,this._z*y)}scaleToRef(y,S){return S._x=this._x*y,S._y=this._y*y,S._z=this._z*y,S._isDirty=!0,S}getNormalToRef(y){const S=this.length();let I=Math.acos(this._y/S);const V=Math.atan2(this._z,this._x);I>Math.PI/2?I-=Math.PI/2:I+=Math.PI/2;const i=S*Math.sin(I)*Math.cos(V),A=S*Math.cos(I),B=S*Math.sin(I)*Math.sin(V);return y.set(i,A,B),y}applyRotationQuaternionToRef(y,S){const I=this._x,V=this._y,i=this._z,A=y._x,B=y._y,d=y._z,F=y._w,J=2*(B*i-d*V),u=2*(d*I-A*i),K=2*(A*V-B*I);return S._x=I+F*J+B*K-d*u,S._y=V+F*u+d*J-A*K,S._z=i+F*K+A*u-B*J,S._isDirty=!0,S}applyRotationQuaternionInPlace(y){return this.applyRotationQuaternionToRef(y,this)}applyRotationQuaternion(y){return this.applyRotationQuaternionToRef(y,new T)}scaleAndAddToRef(y,S){return S._x+=this._x*y,S._y+=this._y*y,S._z+=this._z*y,S._isDirty=!0,S}projectOnPlane(y,S){return this.projectOnPlaneToRef(y,S,new T)}projectOnPlaneToRef(y,S,I){const V=y.normal,i=y.d,A=O.OS[0];this.subtractToRef(S,A),A.normalize();const B=T.Dot(A,V);if(Math.abs(B)<1e-10)I.nd(1/0);else{const y=-(T.Dot(S,V)+i)/B,d=A.scaleInPlace(y);S.addToRef(d,I)}return I}equals(y){return y&&this._x===y._x&&this._y===y._y&&this._z===y._z}equalsWithEpsilon(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.c;return y&&(0,F.WithinEpsilon)(this._x,y._x,S)&&(0,F.WithinEpsilon)(this._y,y._y,S)&&(0,F.WithinEpsilon)(this._z,y._z,S)}equalsToFloats(y,S,I){return this._x===y&&this._y===S&&this._z===I}multiplyInPlace(y){return this._x*=y._x,this._y*=y._y,this._z*=y._z,this._isDirty=!0,this}multiply(y){return this.multiplyByFloats(y._x,y._y,y._z)}multiplyToRef(y,S){return S._x=this._x*y._x,S._y=this._y*y._y,S._z=this._z*y._z,S._isDirty=!0,S}multiplyByFloats(y,S,I){return new T(this._x*y,this._y*S,this._z*I)}divide(y){return new T(this._x/y._x,this._y/y._y,this._z/y._z)}divideToRef(y,S){return S._x=this._x/y._x,S._y=this._y/y._y,S._z=this._z/y._z,S._isDirty=!0,S}divideInPlace(y){return this._x=this._x/y._x,this._y=this._y/y._y,this._z=this._z/y._z,this._isDirty=!0,this}minimizeInPlace(y){return this.minimizeInPlaceFromFloats(y._x,y._y,y._z)}maximizeInPlace(y){return this.maximizeInPlaceFromFloats(y._x,y._y,y._z)}minimizeInPlaceFromFloats(y,S,I){return y<this._x&&(this.x=y),S<this._y&&(this.y=S),I<this._z&&(this.z=I),this}maximizeInPlaceFromFloats(y,S,I){return y>this._x&&(this.x=y),S>this._y&&(this.y=S),I>this._z&&(this.z=I),this}isNonUniformWithinEpsilon(y){const S=Math.abs(this._x),I=Math.abs(this._y);if(!(0,F.WithinEpsilon)(S,I,y))return!0;const V=Math.abs(this._z);return!(0,F.WithinEpsilon)(S,V,y)||!(0,F.WithinEpsilon)(I,V,y)}get isNonUniform(){const y=Math.abs(this._x);if(y!==Math.abs(this._y))return!0;return y!==Math.abs(this._z)}floorToRef(y){return y._x=Math.floor(this._x),y._y=Math.floor(this._y),y._z=Math.floor(this._z),y._isDirty=!0,y}floor(){return new T(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(y){return y._x=this._x-Math.floor(this._x),y._y=this._y-Math.floor(this._y),y._z=this._z-Math.floor(this._z),y._isDirty=!0,y}fract(){return new T(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(y){if("xyz"===(y=y.toLowerCase()))return this;const S=O.OS[0].A(this);return this.x=S[y[0]],this.y=S[y[1]],this.z=S[y[2]],this}rotateByQuaternionToRef(y,S){return y.toRotationMatrix(O.Matrix[0]),T.TransformCoordinatesToRef(this,O.Matrix[0],S),S}rotateByQuaternionAroundPointToRef(y,S,I){return this.subtractToRef(S,O.OS[0]),O.OS[0].rotateByQuaternionToRef(y,O.OS[0]),S.addToRef(O.OS[0],I),I}cross(y){return T.CrossToRef(this,y,new T)}normalizeFromLength(y){return 0===y||1===y?this:this.scaleInPlace(1/y)}normalizeToNew(){return this.normalizeToRef(new T)}normalizeToRef(y){const S=this.length();return 0===S||1===S?(y._x=this._x,y._y=this._y,y._z=this._z,y._isDirty=!0,y):this.scaleToRef(1/S,y)}clone(){return new T(this._x,this._y,this._z)}A(y){return this.od(y._x,y._y,y._z)}od(y,S,I){return this._x=y,this._y=S,this._z=I,this._isDirty=!0,this}set(y,S,I){return this.od(y,S,I)}nd(y){return this._x=this._y=this._z=y,this._isDirty=!0,this}static GetClipFactor(y,S,I,V){const i=T.Dot(y,I);return(i-V)/(i-T.Dot(S,I))}static GetAngleBetweenVectors(y,S,I){const V=y.normalizeToRef(O.OS[1]),i=S.normalizeToRef(O.OS[2]);let A=T.Dot(V,i);A=(0,F.Clamp)(A,-1,1);const B=Math.acos(A),d=O.OS[3];return T.CrossToRef(V,i,d),T.Dot(d,I)>0?isNaN(B)?0:B:isNaN(B)?-Math.PI:-Math.acos(A)}static GetAngleBetweenVectorsOnPlane(y,S,I){O.OS[0].A(y);const V=O.OS[0];O.OS[1].A(S);const i=O.OS[1];O.OS[2].A(I);const A=O.OS[2],B=O.OS[3],d=O.OS[4];V.normalize(),i.normalize(),A.normalize(),T.CrossToRef(A,V,B),T.CrossToRef(B,A,d);const J=Math.atan2(T.Dot(i,B),T.Dot(i,d));return(0,F.NormalizeRadians)(J)}static PitchYawRollToMoveBetweenPointsToRef(y,S,I){const V=f.OS[0];return S.subtractToRef(y,V),I._y=Math.atan2(V.x,V.z)||0,I._x=Math.atan2(Math.sqrt(V.x**2+V.z**2),V.y)||0,I._z=0,I._isDirty=!0,I}static PitchYawRollToMoveBetweenPoints(y,S){const I=T.Zero();return T.PitchYawRollToMoveBetweenPointsToRef(y,S,I)}static SlerpToRef(y,S,I,i){I=(0,F.Clamp)(I,0,1);const A=O.OS[0],B=O.OS[1];A.A(y);const d=A.length();A.normalizeFromLength(d),B.A(S);const J=B.length();B.normalizeFromLength(J);const u=T.Dot(A,B);let K,G;if(u<1-V.c){const y=Math.acos(u),S=1/Math.sin(y);K=Math.sin((1-I)*y)*S,G=Math.sin(I*y)*S}else K=1-I,G=I;return A.scaleInPlace(K),B.scaleInPlace(G),i.A(A).addInPlace(B),i.scaleInPlace((0,F.Lerp)(d,J,I)),i}static SmoothToRef(y,S,I,V,i){return T.SlerpToRef(y,S,0===V?1:I/V,i),i}static oS(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new T(y[S],y[S+1],y[S+2])}static FromFloatArray(y,S){return T.oS(y,S)}static FromArrayToRef(y,S,I){return I._x=y[S],I._y=y[S+1],I._z=y[S+2],I._isDirty=!0,I}static FromFloatArrayToRef(y,S,I){return T.FromArrayToRef(y,S,I)}static FromFloatsToRef(y,S,I,V){return V.od(y,S,I),V}static Zero(){return new T(0,0,0)}static One(){return new T(1,1,1)}static Up(){return new T(0,1,0)}static get UpReadOnly(){return T._UpReadOnly}static get DownReadOnly(){return T._DownReadOnly}static get RightReadOnly(){return T._RightReadOnly}static get LeftReadOnly(){return T._LeftReadOnly}static get LeftHandedForwardReadOnly(){return T._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return T._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return T._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return T._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return T._ZeroReadOnly}static get OneReadOnly(){return T._OneReadOnly}static Down(){return new T(0,-1,0)}static Forward(){return new T(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new T(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new T(1,0,0)}static Left(){return new T(-1,0,0)}static Random(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new T((0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S))}static RandomToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).od((0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S))}static TransformCoordinates(y,S){const I=T.Zero();return T.TransformCoordinatesToRef(y,S,I),I}static TransformCoordinatesToRef(y,S,I){return T.TransformCoordinatesFromFloatsToRef(y._x,y._y,y._z,S,I),I}static TransformCoordinatesFromFloatsToRef(y,S,I,V,i){const A=V.m,B=y*A[0]+S*A[4]+I*A[8]+A[12],d=y*A[1]+S*A[5]+I*A[9]+A[13],F=y*A[2]+S*A[6]+I*A[10]+A[14],J=1/(y*A[3]+S*A[7]+I*A[11]+A[15]);return i._x=B*J,i._y=d*J,i._z=F*J,i._isDirty=!0,i}static TransformNormal(y,S){const I=T.Zero();return T.TransformNormalToRef(y,S,I),I}static TransformNormalToRef(y,S,I){return this.TransformNormalFromFloatsToRef(y._x,y._y,y._z,S,I),I}static TransformNormalFromFloatsToRef(y,S,I,V,i){const A=V.m;return i._x=y*A[0]+S*A[4]+I*A[8],i._y=y*A[1]+S*A[5]+I*A[9],i._z=y*A[2]+S*A[6]+I*A[10],i._isDirty=!0,i}static CatmullRom(y,S,I,V,i){const A=i*i,B=i*A,d=.5*(2*S._x+(-y._x+I._x)*i+(2*y._x-5*S._x+4*I._x-V._x)*A+(-y._x+3*S._x-3*I._x+V._x)*B),F=.5*(2*S._y+(-y._y+I._y)*i+(2*y._y-5*S._y+4*I._y-V._y)*A+(-y._y+3*S._y-3*I._y+V._y)*B),J=.5*(2*S._z+(-y._z+I._z)*i+(2*y._z-5*S._z+4*I._z-V._z)*A+(-y._z+3*S._z-3*I._z+V._z)*B);return new T(d,F,J)}static Clamp(y,S,I){const V=new T;return T.ClampToRef(y,S,I,V),V}static ClampToRef(y,S,I,V){let i=y._x;i=i>I._x?I._x:i,i=i<S._x?S._x:i;let A=y._y;A=A>I._y?I._y:A,A=A<S._y?S._y:A;let B=y._z;return B=B>I._z?I._z:B,B=B<S._z?S._z:B,V.od(i,A,B),V}static CheckExtends(y,S,I){S.minimizeInPlace(y),I.maximizeInPlace(y)}static Hermite(y,S,I,V,i){const A=i*i,B=i*A,d=2*B-3*A+1,F=-2*B+3*A,J=B-2*A+i,u=B-A,K=y._x*d+I._x*F+S._x*J+V._x*u,G=y._y*d+I._y*F+S._y*J+V._y*u,p=y._z*d+I._z*F+S._z*J+V._z*u;return new T(K,G,p)}static Hermite1stDerivative(y,S,I,V,i){const A=new T;return this.Hermite1stDerivativeToRef(y,S,I,V,i,A),A}static Hermite1stDerivativeToRef(y,S,I,V,i,A){const B=i*i;return A._x=6*(B-i)*y._x+(3*B-4*i+1)*S._x+6*(-B+i)*I._x+(3*B-2*i)*V._x,A._y=6*(B-i)*y._y+(3*B-4*i+1)*S._y+6*(-B+i)*I._y+(3*B-2*i)*V._y,A._z=6*(B-i)*y._z+(3*B-4*i+1)*S._z+6*(-B+i)*I._z+(3*B-2*i)*V._z,A._isDirty=!0,A}static Lerp(y,S,I){const V=new T(0,0,0);return T.LerpToRef(y,S,I,V),V}static LerpToRef(y,S,I,V){return V._x=y._x+(S._x-y._x)*I,V._y=y._y+(S._y-y._y)*I,V._z=y._z+(S._z-y._z)*I,V._isDirty=!0,V}static Dot(y,S){return y._x*S._x+y._y*S._y+y._z*S._z}dot(y){return this._x*y._x+this._y*y._y+this._z*y._z}static Cross(y,S){const I=new T;return T.CrossToRef(y,S,I),I}static CrossToRef(y,S,I){const V=y._y*S._z-y._z*S._y,i=y._z*S._x-y._x*S._z,A=y._x*S._y-y._y*S._x;return I.od(V,i,A),I}static Normalize(y){const S=T.Zero();return T.NormalizeToRef(y,S),S}static NormalizeToRef(y,S){return y.normalizeToRef(S),S}static Project(y,S,I,V){const i=new T;return T.ProjectToRef(y,S,I,V,i),i}static ProjectToRef(y,S,I,V,i){var A;const B=V.width,F=V.height,J=V.x,u=V.y,K=O.Matrix[1],G=null===(A=d.e.LastCreatedEngine)||void 0===A?void 0:A.isNDCHalfZRange,p=G?1:.5,L=G?0:.5;s.FromValuesToRef(B/2,0,0,0,0,-F/2,0,0,0,0,p,0,J+B/2,F/2+u,L,1,K);const l=O.Matrix[0];return S.multiplyToRef(I,l),l.multiplyToRef(K,l),T.TransformCoordinatesToRef(y,l,i),i}static Reflect(y,S){return this.ReflectToRef(y,S,new T)}static ReflectToRef(y,S,I){const V=f.OS[0];return V.A(S).scaleInPlace(2*T.Dot(y,S)),I.A(y).uK(V)}static _UnprojectFromInvertedMatrixToRef(y,S,I){T.TransformCoordinatesToRef(y,S,I);const V=S.m,i=y._x*V[3]+y._y*V[7]+y._z*V[11]+V[15];return(0,F.WithinEpsilon)(i,1)&&I.scaleInPlace(1/i),I}static UnprojectFromTransform(y,S,I,V,i){return this.Unproject(y,S,I,V,i,s.IdentityReadOnly)}static Unproject(y,S,I,V,i,A){const B=new T;return T.UnprojectToRef(y,S,I,V,i,A,B),B}static UnprojectToRef(y,S,I,V,i,A,B){return T.UnprojectFloatsToRef(y._x,y._y,y._z,S,I,V,i,A,B),B}static UnprojectFloatsToRef(y,S,I,V,i,A,B,F,J){var u;const K=O.Matrix[0];A.multiplyToRef(B,K),K.multiplyToRef(F,K),K.invert();const G=O.OS[0];return G.x=y/V*2-1,G.y=-(S/i*2-1),null!==(u=d.e.LastCreatedEngine)&&void 0!==u&&u.isNDCHalfZRange?G.z=I:G.z=2*I-1,T._UnprojectFromInvertedMatrixToRef(G,K,J),J}static Minimize(y,S){const I=new T;return I.A(y),I.minimizeInPlace(S),I}static Maximize(y,S){const I=new T;return I.A(y),I.maximizeInPlace(S),I}static Distance(y,S){return Math.sqrt(T.DistanceSquared(y,S))}static DistanceSquared(y,S){const I=y._x-S._x,V=y._y-S._y,i=y._z-S._z;return I*I+V*V+i*i}static ProjectOnTriangleToRef(y,S,I,i,A){const B=O.OS[0],d=O.OS[1],J=O.OS[2],u=O.OS[3],K=O.OS[4];I.subtractToRef(S,B),i.subtractToRef(S,d),i.subtractToRef(I,J);const G=B.length(),p=d.length(),L=J.length();if(G<V.c||p<V.c||L<V.c)return A.A(S),T.Distance(y,S);y.subtractToRef(S,K),T.CrossToRef(B,d,u);const l=u.length();if(l<V.c)return A.A(S),T.Distance(y,S);u.normalizeFromLength(l);let j=K.length();if(j<V.c)return A.A(S),0;K.normalizeFromLength(j);const s=T.Dot(u,K),f=O.OS[5],my=O.OS[6];f.A(u).scaleInPlace(-j*s),my.A(y).addInPlace(f);const C=O.OS[4],D=O.OS[5],o=O.OS[7],E=O.OS[8];C.A(B).scaleInPlace(1/G),E.A(d).scaleInPlace(1/p),C.addInPlace(E).scaleInPlace(-1),D.A(B).scaleInPlace(-1/G),E.A(J).scaleInPlace(1/L),D.addInPlace(E).scaleInPlace(-1),o.A(J).scaleInPlace(-1/L),E.A(d).scaleInPlace(-1/p),o.addInPlace(E).scaleInPlace(-1);const z=O.OS[9];let r;z.A(my).uK(S),T.CrossToRef(C,z,E),r=T.Dot(E,u);const h=r;z.A(my).uK(I),T.CrossToRef(D,z,E),r=T.Dot(E,u);const n=r;z.A(my).uK(i),T.CrossToRef(o,z,E),r=T.Dot(E,u);const v=r,P=O.OS[10];let q,g;h>0&&n<0?(P.A(B),q=S,g=I):n>0&&v<0?(P.A(J),q=I,g=i):(P.A(d).scaleInPlace(-1),q=i,g=S);const k=O.OS[9],R=O.OS[4];q.subtractToRef(my,E),g.subtractToRef(my,k),T.CrossToRef(E,k,R);if(!(T.Dot(R,u)<0))return A.A(my),Math.abs(j*s);const b=O.OS[5];T.CrossToRef(P,R,b),b.normalize();const U=O.OS[9];U.A(q).uK(my);const W=U.length();if(W<V.c)return A.A(q),T.Distance(y,q);U.normalizeFromLength(W);const a=T.Dot(b,U),e=O.OS[7];e.A(my).addInPlace(b.scaleInPlace(W*a)),E.A(e).uK(q),j=P.length(),P.normalizeFromLength(j);let x=T.Dot(E,P)/Math.max(j,V.c);return x=(0,F.Clamp)(x,0,1),e.A(q).addInPlace(P.scaleInPlace(x*j)),A.A(e),T.Distance(y,e)}static Center(y,S){return T.CenterToRef(y,S,T.Zero())}static CenterToRef(y,S,I){return I.od((y._x+S._x)/2,(y._y+S._y)/2,(y._z+S._z)/2)}static RotationFromAxis(y,S,I){const V=new T;return T.RotationFromAxisToRef(y,S,I,V),V}static RotationFromAxisToRef(y,S,I,V){const i=O.Quaternion[0];return j.RotationQuaternionFromAxisToRef(y,S,I,i),i.toEulerAnglesToRef(V),V}}T._V8PerformanceHack=new T(.5,.5,.5),T._UpReadOnly=T.Up(),T._DownReadOnly=T.Down(),T._LeftHandedForwardReadOnly=T.Forward(!1),T._RightHandedForwardReadOnly=T.Forward(!0),T._LeftHandedBackwardReadOnly=T.Backward(!1),T._RightHandedBackwardReadOnly=T.Backward(!0),T._RightReadOnly=T.Right(),T._LeftReadOnly=T.Left(),T._ZeroReadOnly=T.Zero(),T._OneReadOnly=T.One(),Object.defineProperties(T.prototype,{dimension:{value:[3]},rank:{value:1}});class l{get x(){return this._x}set x(y){this._x=y,this._isDirty=!0}get y(){return this._y}set y(y){this._y=y,this._isDirty=!0}get z(){return this._z}set z(y){this._z=y,this._isDirty=!0}get w(){return this._w}set w(y){this._w=y,this._isDirty=!0}constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=y,this._y=S,this._z=I,this._w=V}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let y=p(this._x);return y=397*y^p(this._y),y=397*y^p(this._z),y=397*y^p(this._w),y}Vd(){return[this._x,this._y,this._z,this._w]}toArray(y,S){return void 0===S&&(S=0),y[S]=this._x,y[S+1]=this._y,y[S+2]=this._z,y[S+3]=this._w,this}sI(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(y,S,this),this}addInPlace(y){return this.x+=y._x,this.y+=y._y,this.z+=y._z,this.w+=y._w,this}addInPlaceFromFloats(y,S,I,V){return this.x+=y,this.y+=S,this.z+=I,this.w+=V,this}add(y){return new l(this._x+y.x,this._y+y.y,this._z+y.z,this._w+y.w)}addToRef(y,S){return S.x=this._x+y.x,S.y=this._y+y.y,S.z=this._z+y.z,S.w=this._w+y.w,S}uK(y){return this.x-=y.x,this.y-=y.y,this.z-=y.z,this.w-=y.w,this}fS(y){return new l(this._x-y.x,this._y-y.y,this._z-y.z,this._w-y.w)}subtractToRef(y,S){return S.x=this._x-y.x,S.y=this._y-y.y,S.z=this._z-y.z,S.w=this._w-y.w,S}subtractFromFloats(y,S,I,V){return new l(this._x-y,this._y-S,this._z-I,this._w-V)}subtractFromFloatsToRef(y,S,I,V,i){return i.x=this._x-y,i.y=this._y-S,i.z=this._z-I,i.w=this._w-V,i}negate(){return new l(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(y){return y.x=-this._x,y.y=-this._y,y.z=-this._z,y.w=-this._w,y}scaleInPlace(y){return this.x*=y,this.y*=y,this.z*=y,this.w*=y,this}scale(y){return new l(this._x*y,this._y*y,this._z*y,this._w*y)}scaleToRef(y,S){return S.x=this._x*y,S.y=this._y*y,S.z=this._z*y,S.w=this._w*y,S}scaleAndAddToRef(y,S){return S.x+=this._x*y,S.y+=this._y*y,S.z+=this._z*y,S.w+=this._w*y,S}equals(y){return y&&this._x===y.x&&this._y===y.y&&this._z===y.z&&this._w===y.w}equalsWithEpsilon(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.c;return y&&(0,F.WithinEpsilon)(this._x,y.x,S)&&(0,F.WithinEpsilon)(this._y,y.y,S)&&(0,F.WithinEpsilon)(this._z,y.z,S)&&(0,F.WithinEpsilon)(this._w,y.w,S)}equalsToFloats(y,S,I,V){return this._x===y&&this._y===S&&this._z===I&&this._w===V}multiplyInPlace(y){return this.x*=y.x,this.y*=y.y,this.z*=y.z,this.w*=y.w,this}multiply(y){return new l(this._x*y.x,this._y*y.y,this._z*y.z,this._w*y.w)}multiplyToRef(y,S){return S.x=this._x*y.x,S.y=this._y*y.y,S.z=this._z*y.z,S.w=this._w*y.w,S}multiplyByFloats(y,S,I,V){return new l(this._x*y,this._y*S,this._z*I,this._w*V)}divide(y){return new l(this._x/y.x,this._y/y.y,this._z/y.z,this._w/y.w)}divideToRef(y,S){return S.x=this._x/y.x,S.y=this._y/y.y,S.z=this._z/y.z,S.w=this._w/y.w,S}divideInPlace(y){return this.divideToRef(y,this)}minimizeInPlace(y){return y.x<this._x&&(this.x=y.x),y.y<this._y&&(this.y=y.y),y.z<this._z&&(this.z=y.z),y.w<this._w&&(this.w=y.w),this}maximizeInPlace(y){return y.x>this._x&&(this.x=y.x),y.y>this._y&&(this.y=y.y),y.z>this._z&&(this.z=y.z),y.w>this._w&&(this.w=y.w),this}minimizeInPlaceFromFloats(y,S,I,V){return this.x=Math.min(y,this._x),this.y=Math.min(S,this._y),this.z=Math.min(I,this._z),this.w=Math.min(V,this._w),this}maximizeInPlaceFromFloats(y,S,I,V){return this.x=Math.max(y,this._x),this.y=Math.max(S,this._y),this.z=Math.max(I,this._z),this.w=Math.max(V,this._w),this}floorToRef(y){return y.x=Math.floor(this._x),y.y=Math.floor(this._y),y.z=Math.floor(this._z),y.w=Math.floor(this._w),y}floor(){return new l(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(y){return y.x=this._x-Math.floor(this._x),y.y=this._y-Math.floor(this._y),y.z=this._z-Math.floor(this._z),y.w=this._w-Math.floor(this._w),y}fract(){return new l(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(y){return 0===y||1===y?this:this.scaleInPlace(1/y)}normalizeToNew(){return this.normalizeToRef(new l)}normalizeToRef(y){const S=this.length();return 0===S||1===S?(y.x=this._x,y.y=this._y,y.z=this._z,y.w=this._w,y):this.scaleToRef(1/S,y)}toVector3(){return new T(this._x,this._y,this._z)}clone(){return new l(this._x,this._y,this._z,this._w)}A(y){return this.x=y.x,this.y=y.y,this.z=y.z,this.w=y.w,this}od(y,S,I,V){return this.x=y,this.y=S,this.z=I,this.w=V,this}set(y,S,I,V){return this.od(y,S,I,V)}nd(y){return this.x=this.y=this.z=this.w=y,this}dot(y){return this._x*y.x+this._y*y.y+this._z*y.z+this._w*y.w}static oS(y,S){return S||(S=0),new l(y[S],y[S+1],y[S+2],y[S+3])}static FromArrayToRef(y,S,I){return I.x=y[S],I.y=y[S+1],I.z=y[S+2],I.w=y[S+3],I}static FromFloatArrayToRef(y,S,I){return l.FromArrayToRef(y,S,I),I}static FromFloatsToRef(y,S,I,V,i){return i.x=y,i.y=S,i.z=I,i.w=V,i}static Zero(){return new l(0,0,0,0)}static One(){return new l(1,1,1,1)}static Random(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new l((0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S))}static RandomToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,I=arguments.length>2?arguments[2]:void 0;return I.x=(0,F.RandomRange)(y,S),I.y=(0,F.RandomRange)(y,S),I.z=(0,F.RandomRange)(y,S),I.w=(0,F.RandomRange)(y,S),I}static Clamp(y,S,I){return l.ClampToRef(y,S,I,new l)}static ClampToRef(y,S,I,V){return V.x=(0,F.Clamp)(y.x,S.x,I.x),V.y=(0,F.Clamp)(y.y,S.y,I.y),V.z=(0,F.Clamp)(y.z,S.z,I.z),V.w=(0,F.Clamp)(y.w,S.w,I.w),V}static CheckExtends(y,S,I){S.minimizeInPlace(y),I.maximizeInPlace(y)}static get ZeroReadOnly(){return l._ZeroReadOnly}static Normalize(y){return l.NormalizeToRef(y,new l)}static NormalizeToRef(y,S){return y.normalizeToRef(S),S}static Minimize(y,S){const I=new l;return I.A(y),I.minimizeInPlace(S),I}static Maximize(y,S){const I=new l;return I.A(y),I.maximizeInPlace(S),I}static Distance(y,S){return Math.sqrt(l.DistanceSquared(y,S))}static DistanceSquared(y,S){const I=y.x-S.x,V=y.y-S.y,i=y.z-S.z,A=y.w-S.w;return I*I+V*V+i*i+A*A}static Center(y,S){return l.CenterToRef(y,S,new l)}static CenterToRef(y,S,I){return I.x=(y.x+S.x)/2,I.y=(y.y+S.y)/2,I.z=(y.z+S.z)/2,I.w=(y.w+S.w)/2,I}static TransformCoordinates(y,S){return l.TransformCoordinatesToRef(y,S,new l)}static TransformCoordinatesToRef(y,S,I){return l.TransformCoordinatesFromFloatsToRef(y._x,y._y,y._z,S,I),I}static TransformCoordinatesFromFloatsToRef(y,S,I,V,i){const A=V.m,B=y*A[0]+S*A[4]+I*A[8]+A[12],d=y*A[1]+S*A[5]+I*A[9]+A[13],F=y*A[2]+S*A[6]+I*A[10]+A[14],J=y*A[3]+S*A[7]+I*A[11]+A[15];return i.x=B,i.y=d,i.z=F,i.w=J,i}static TransformNormal(y,S){return l.TransformNormalToRef(y,S,new l)}static TransformNormalToRef(y,S,I){const V=S.m,i=y.x*V[0]+y.y*V[4]+y.z*V[8],A=y.x*V[1]+y.y*V[5]+y.z*V[9],B=y.x*V[2]+y.y*V[6]+y.z*V[10];return I.x=i,I.y=A,I.z=B,I.w=y.w,I}static TransformNormalFromFloatsToRef(y,S,I,V,i,A){const B=i.m;return A.x=y*B[0]+S*B[4]+I*B[8],A.y=y*B[1]+S*B[5]+I*B[9],A.z=y*B[2]+S*B[6]+I*B[10],A.w=V,A}static FromVector3(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new l(y._x,y._y,y._z,S)}static Dot(y,S){return y.x*S.x+y.y*S.y+y.z*S.z+y.w*S.w}}l._V8PerformanceHack=new l(.5,.5,.5,.5),l._ZeroReadOnly=l.Zero(),Object.defineProperties(l.prototype,{dimension:{value:[4]},rank:{value:1}});class j{get x(){return this._x}set x(y){this._x=y,this._isDirty=!0}get y(){return this._y}set y(y){this._y=y,this._isDirty=!0}get z(){return this._z}set z(y){this._z=y,this._isDirty=!0}get w(){return this._w}set w(y){this._w=y,this._isDirty=!0}constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=y,this._y=S,this._z=I,this._w=V}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let y=p(this._x);return y=397*y^p(this._y),y=397*y^p(this._z),y=397*y^p(this._w),y}Vd(){return[this._x,this._y,this._z,this._w]}toArray(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y[S]=this._x,y[S+1]=this._y,y[S+2]=this._z,y[S+3]=this._w,this}sI(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return j.FromArrayToRef(y,S,this)}equals(y){return y&&this._x===y._x&&this._y===y._y&&this._z===y._z&&this._w===y._w}equalsWithEpsilon(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.c;return y&&(0,F.WithinEpsilon)(this._x,y._x,S)&&(0,F.WithinEpsilon)(this._y,y._y,S)&&(0,F.WithinEpsilon)(this._z,y._z,S)&&(0,F.WithinEpsilon)(this._w,y._w,S)}isApprox(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.c;return y&&((0,F.WithinEpsilon)(this._x,y._x,S)&&(0,F.WithinEpsilon)(this._y,y._y,S)&&(0,F.WithinEpsilon)(this._z,y._z,S)&&(0,F.WithinEpsilon)(this._w,y._w,S)||(0,F.WithinEpsilon)(this._x,-y._x,S)&&(0,F.WithinEpsilon)(this._y,-y._y,S)&&(0,F.WithinEpsilon)(this._z,-y._z,S)&&(0,F.WithinEpsilon)(this._w,-y._w,S))}clone(){return new j(this._x,this._y,this._z,this._w)}A(y){return this._x=y._x,this._y=y._y,this._z=y._z,this._w=y._w,this._isDirty=!0,this}od(y,S,I,V){return this._x=y,this._y=S,this._z=I,this._w=V,this._isDirty=!0,this}set(y,S,I,V){return this.od(y,S,I,V)}nd(y){return this.od(y,y,y,y)}add(y){return new j(this._x+y._x,this._y+y._y,this._z+y._z,this._w+y._w)}addInPlace(y){return this._x+=y._x,this._y+=y._y,this._z+=y._z,this._w+=y._w,this._isDirty=!0,this}addToRef(y,S){return S._x=this._x+y._x,S._y=this._y+y._y,S._z=this._z+y._z,S._w=this._w+y._w,S._isDirty=!0,S}addInPlaceFromFloats(y,S,I,V){return this._x+=y,this._y+=S,this._z+=I,this._w+=V,this._isDirty=!0,this}subtractToRef(y,S){return S._x=this._x-y._x,S._y=this._y-y._y,S._z=this._z-y._z,S._w=this._w-y._w,S._isDirty=!0,S}subtractFromFloats(y,S,I,V){return this.subtractFromFloatsToRef(y,S,I,V,new j)}subtractFromFloatsToRef(y,S,I,V,i){return i._x=this._x-y,i._y=this._y-S,i._z=this._z-I,i._w=this._w-V,i._isDirty=!0,i}fS(y){return new j(this._x-y._x,this._y-y._y,this._z-y._z,this._w-y._w)}uK(y){return this._x-=y._x,this._y-=y._y,this._z-=y._z,this._w-=y._w,this._isDirty=!0,this}scale(y){return new j(this._x*y,this._y*y,this._z*y,this._w*y)}scaleToRef(y,S){return S._x=this._x*y,S._y=this._y*y,S._z=this._z*y,S._w=this._w*y,S._isDirty=!0,S}scaleInPlace(y){return this._x*=y,this._y*=y,this._z*=y,this._w*=y,this._isDirty=!0,this}scaleAndAddToRef(y,S){return S._x+=this._x*y,S._y+=this._y*y,S._z+=this._z*y,S._w+=this._w*y,S._isDirty=!0,S}multiply(y){const S=new j(0,0,0,1);return this.multiplyToRef(y,S),S}multiplyToRef(y,S){const I=this._x*y._w+this._y*y._z-this._z*y._y+this._w*y._x,V=-this._x*y._z+this._y*y._w+this._z*y._x+this._w*y._y,i=this._x*y._y-this._y*y._x+this._z*y._w+this._w*y._z,A=-this._x*y._x-this._y*y._y-this._z*y._z+this._w*y._w;return S.od(I,V,i,A),S}multiplyInPlace(y){return this.multiplyToRef(y,this)}multiplyByFloats(y,S,I,V){return this._x*=y,this._y*=S,this._z*=I,this._w*=V,this._isDirty=!0,this}divide(y){throw new ReferenceError("Can not divide a quaternion")}divideToRef(y,S){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(y){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new j)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(y){return y._x=-this._x,y._y=-this._y,y._z=-this._z,y._w=-this._w,y._isDirty=!0,y}equalsToFloats(y,S,I,V){return this._x===y&&this._y===S&&this._z===I&&this._w===V}floorToRef(y){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(y){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(y){return y.od(-this._x,-this._y,-this._z,this._w),y}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new j(-this._x,-this._y,-this._z,this._w)}invert(){const y=this.conjugate(),S=this.lengthSquared();return 0==S||1==S||y.scaleInPlace(1/S),y}invertInPlace(){this.conjugateInPlace();const y=this.lengthSquared();return 0==y||1==y||this.scaleInPlace(1/y),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(y){return 0===y||1===y?this:this.scaleInPlace(1/y)}normalizeToNew(){const y=new j(0,0,0,1);return this.normalizeToRef(y),y}normalizeToRef(y){const S=this.length();return 0===S||1===S?y.od(this._x,this._y,this._z,this._w):this.scaleToRef(1/S,y)}toEulerAngles(){const y=T.Zero();return this.toEulerAnglesToRef(y),y}toEulerAnglesToRef(y){const S=this._z,I=this._x,V=this._y,i=this._w,A=V*S-I*i,B=.4999999;if(A<-B)y._y=2*Math.atan2(V,i),y._x=Math.PI/2,y._z=0,y._isDirty=!0;else if(A>B)y._y=2*Math.atan2(V,i),y._x=-Math.PI/2,y._z=0,y._isDirty=!0;else{const B=i*i,d=S*S,F=I*I,J=V*V;y._z=Math.atan2(2*(I*V+S*i),-d-F+J+B),y._x=Math.asin(-2*A),y._y=Math.atan2(2*(S*I+V*i),d-F-J+B),y._isDirty=!0}return y}toAlphaBetaGammaToRef(y){const S=this._z,I=this._x,V=this._y,i=this._w,A=Math.sqrt(I*I+V*V),B=Math.sqrt(S*S+i*i),d=2*Math.atan2(A,B),F=2*Math.atan2(S,i),J=2*Math.atan2(V,I),u=(F+J)/2,K=(F-J)/2;return y.set(K,d,u),y}toRotationMatrix(y){return s.FromQuaternionToRef(this,y),y}fromRotationMatrix(y){return j.FromRotationMatrixToRef(y,this),this}dot(y){return this._x*y._x+this._y*y._y+this._z*y._z+this._w*y._w}toAxisAngle(){const y=T.Zero();return{axis:y,angle:this.toAxisAngleToRef(y)}}toAxisAngleToRef(y){let S=0;const I=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),V=this._w;return I>0?(S=2*Math.atan2(I,V),y.set(this._x/I,this._y/I,this._z/I)):(S=0,y.set(1,0,0)),S}static FromRotationMatrix(y){const S=new j;return j.FromRotationMatrixToRef(y,S),S}static FromRotationMatrixToRef(y,S){const I=y.m,V=I[0],i=I[4],A=I[8],B=I[1],d=I[5],F=I[9],J=I[2],u=I[6],K=I[10],G=V+d+K;let p;return G>0?(p=.5/Math.sqrt(G+1),S._w=.25/p,S._x=(u-F)*p,S._y=(A-J)*p,S._z=(B-i)*p,S._isDirty=!0):V>d&&V>K?(p=2*Math.sqrt(1+V-d-K),S._w=(u-F)/p,S._x=.25*p,S._y=(i+B)/p,S._z=(A+J)/p,S._isDirty=!0):d>K?(p=2*Math.sqrt(1+d-V-K),S._w=(A-J)/p,S._x=(i+B)/p,S._y=.25*p,S._z=(F+u)/p,S._isDirty=!0):(p=2*Math.sqrt(1+K-V-d),S._w=(B-i)/p,S._x=(A+J)/p,S._y=(F+u)/p,S._z=.25*p,S._isDirty=!0),S}static Dot(y,S){return y._x*S._x+y._y*S._y+y._z*S._z+y._w*S._w}static AreClose(y,S){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const V=j.Dot(y,S);return 1-V*V<=I}static SmoothToRef(y,S,I,V,i){let A=0===V?1:I/V;return A=(0,F.Clamp)(A,0,1),j.SlerpToRef(y,S,A,i),i}static Zero(){return new j(0,0,0,0)}static Inverse(y){return new j(-y._x,-y._y,-y._z,y._w)}static InverseToRef(y,S){return S.set(-y._x,-y._y,-y._z,y._w),S}static Identity(){return new j(0,0,0,1)}static IsIdentity(y){return y&&0===y._x&&0===y._y&&0===y._z&&1===y._w}static RotationAxis(y,S){return j.RotationAxisToRef(y,S,new j)}static RotationAxisToRef(y,S,I){I._w=Math.cos(S/2);const V=Math.sin(S/2)/y.length();return I._x=y._x*V,I._y=y._y*V,I._z=y._z*V,I._isDirty=!0,I}static oS(y,S){return S||(S=0),new j(y[S],y[S+1],y[S+2],y[S+3])}static FromArrayToRef(y,S,I){return I._x=y[S],I._y=y[S+1],I._z=y[S+2],I._w=y[S+3],I._isDirty=!0,I}static FromFloatsToRef(y,S,I,V,i){return i.od(y,S,I,V),i}static FromEulerAngles(y,S,I){const V=new j;return j.RotationYawPitchRollToRef(S,y,I,V),V}static FromEulerAnglesToRef(y,S,I,V){return j.RotationYawPitchRollToRef(S,y,I,V),V}static FromEulerVector(y){const S=new j;return j.RotationYawPitchRollToRef(y._y,y._x,y._z,S),S}static FromEulerVectorToRef(y,S){return j.RotationYawPitchRollToRef(y._y,y._x,y._z,S),S}static FromUnitVectorsToRef(y,S,I){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V.c;const A=T.Dot(y,S)+1;return A<i?Math.abs(y.x)>Math.abs(y.z)?I.set(-y.y,y.x,0,0):I.set(0,-y.z,y.y,0):(T.CrossToRef(y,S,f.OS[0]),I.set(f.OS[0].x,f.OS[0].y,f.OS[0].z,A)),I.normalize()}static RotationYawPitchRoll(y,S,I){const V=new j;return j.RotationYawPitchRollToRef(y,S,I,V),V}static RotationYawPitchRollToRef(y,S,I,V){const i=.5*I,A=.5*S,B=.5*y,d=Math.sin(i),F=Math.cos(i),J=Math.sin(A),u=Math.cos(A),K=Math.sin(B),G=Math.cos(B);return V._x=G*J*F+K*u*d,V._y=K*u*F-G*J*d,V._z=G*u*d-K*J*F,V._w=G*u*F+K*J*d,V._isDirty=!0,V}static RotationAlphaBetaGamma(y,S,I){const V=new j;return j.RotationAlphaBetaGammaToRef(y,S,I,V),V}static RotationAlphaBetaGammaToRef(y,S,I,V){const i=.5*(I+y),A=.5*(I-y),B=.5*S;return V._x=Math.cos(A)*Math.sin(B),V._y=Math.sin(A)*Math.sin(B),V._z=Math.sin(i)*Math.cos(B),V._w=Math.cos(i)*Math.cos(B),V._isDirty=!0,V}static RotationQuaternionFromAxis(y,S,I){const V=new j(0,0,0,0);return j.RotationQuaternionFromAxisToRef(y,S,I,V),V}static RotationQuaternionFromAxisToRef(y,S,I,V){const i=O.Matrix[0];return y=y.normalizeToRef(O.OS[0]),S=S.normalizeToRef(O.OS[1]),I=I.normalizeToRef(O.OS[2]),s.FromXYZAxesToRef(y,S,I,i),j.FromRotationMatrixToRef(i,V),V}static FromLookDirectionLH(y,S){const I=new j;return j.FromLookDirectionLHToRef(y,S,I),I}static FromLookDirectionLHToRef(y,S,I){const V=O.Matrix[0];return s.LookDirectionLHToRef(y,S,V),j.FromRotationMatrixToRef(V,I),I}static FromLookDirectionRH(y,S){const I=new j;return j.FromLookDirectionRHToRef(y,S,I),I}static FromLookDirectionRHToRef(y,S,I){const V=O.Matrix[0];return s.LookDirectionRHToRef(y,S,V),j.FromRotationMatrixToRef(V,I)}static Slerp(y,S,I){const V=j.Identity();return j.SlerpToRef(y,S,I,V),V}static SlerpToRef(y,S,I,V){let i,A,B=y._x*S._x+y._y*S._y+y._z*S._z+y._w*S._w,d=!1;if(B<0&&(d=!0,B=-B),B>.999999)A=1-I,i=d?-I:I;else{const y=Math.acos(B),S=1/Math.sin(y);A=Math.sin((1-I)*y)*S,i=d?-Math.sin(I*y)*S:Math.sin(I*y)*S}return V._x=A*y._x+i*S._x,V._y=A*y._y+i*S._y,V._z=A*y._z+i*S._z,V._w=A*y._w+i*S._w,V._isDirty=!0,V}static Hermite(y,S,I,V,i){const A=i*i,B=i*A,d=2*B-3*A+1,F=-2*B+3*A,J=B-2*A+i,u=B-A,K=y._x*d+I._x*F+S._x*J+V._x*u,G=y._y*d+I._y*F+S._y*J+V._y*u,p=y._z*d+I._z*F+S._z*J+V._z*u,L=y._w*d+I._w*F+S._w*J+V._w*u;return new j(K,G,p,L)}static Hermite1stDerivative(y,S,I,V,i){const A=new j;return this.Hermite1stDerivativeToRef(y,S,I,V,i,A),A}static Hermite1stDerivativeToRef(y,S,I,V,i,A){const B=i*i;return A._x=6*(B-i)*y._x+(3*B-4*i+1)*S._x+6*(-B+i)*I._x+(3*B-2*i)*V._x,A._y=6*(B-i)*y._y+(3*B-4*i+1)*S._y+6*(-B+i)*I._y+(3*B-2*i)*V._y,A._z=6*(B-i)*y._z+(3*B-4*i+1)*S._z+6*(-B+i)*I._z+(3*B-2*i)*V._z,A._w=6*(B-i)*y._w+(3*B-4*i+1)*S._w+6*(-B+i)*I._w+(3*B-2*i)*V._w,A._isDirty=!0,A}static Normalize(y){const S=j.Zero();return j.NormalizeToRef(y,S),S}static NormalizeToRef(y,S){return y.normalizeToRef(S),S}static Clamp(y,S,I){const V=new j;return j.ClampToRef(y,S,I,V),V}static ClampToRef(y,S,I,V){return V.od((0,F.Clamp)(y.x,S.x,I.x),(0,F.Clamp)(y.y,S.y,I.y),(0,F.Clamp)(y.z,S.z,I.z),(0,F.Clamp)(y.w,S.w,I.w))}static Random(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new j((0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S))}static RandomToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).od((0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S),(0,F.RandomRange)(y,S))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(y,S){return Math.sqrt(j.DistanceSquared(y,S))}static DistanceSquared(y,S){const I=y.x-S.x,V=y.y-S.y,i=y.z-S.z,A=y.w-S.w;return I*I+V*V+i*i+A*A}static Center(y,S){return j.CenterToRef(y,S,j.Zero())}static CenterToRef(y,S,I){return I.od((y.x+S.x)/2,(y.y+S.y)/2,(y.z+S.z)/2,(y.w+S.w)/2)}}j._V8PerformanceHack=new j(.5,.5,.5,.5),Object.defineProperties(j.prototype,{dimension:{value:[4]},rank:{value:1}});class s{static get Use64Bits(){return B.d.MatrixUse64Bits}get m(){return this.ki}markAsUpdated(){this.updateFlag=J._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(y){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1],I=arguments.length>2&&void 0!==arguments[2]&&arguments[2],V=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=y,this._isIdentity3x2=y||I,this._isIdentityDirty=!this._isIdentity&&S,this._isIdentity3x2Dirty=!this._isIdentity3x2&&V}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,B.d.MatrixTrackPrecisionChange&&B.d.MatrixTrackedMatrices.push(this),this.ki=new B.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const y=this.ki;this._isIdentity=1===y[0]&&0===y[1]&&0===y[2]&&0===y[3]&&0===y[4]&&1===y[5]&&0===y[6]&&0===y[7]&&0===y[8]&&0===y[9]&&1===y[10]&&0===y[11]&&0===y[12]&&0===y[13]&&0===y[14]&&1===y[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ki[0]||1!==this.ki[5]||1!==this.ki[15]||0!==this.ki[1]||0!==this.ki[2]||0!==this.ki[3]||0!==this.ki[4]||0!==this.ki[6]||0!==this.ki[7]||0!==this.ki[8]||0!==this.ki[9]||0!==this.ki[10]||0!==this.ki[11]||0!==this.ki[12]||0!==this.ki[13]||0!==this.ki[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const y=this.ki,S=y[0],I=y[1],V=y[2],i=y[3],A=y[4],B=y[5],d=y[6],F=y[7],J=y[8],u=y[9],K=y[10],G=y[11],p=y[12],L=y[13],T=y[14],l=y[15],j=K*l-T*G,s=u*l-L*G,O=u*T-L*K,f=J*l-p*G,my=J*T-K*p,C=J*L-p*u;return S*+(B*j-d*s+F*O)+I*-(A*j-d*f+F*my)+V*+(A*s-B*f+F*C)+i*-(A*O-B*my+d*C)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!y)return this.ki;const I=this.ki;for(let V=0;V<16;V++)y[S+V]=I[V];return this}Vd(){return this.ki}sI(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return s.FromArrayToRef(y,S,this)}od(){for(var y=arguments.length,S=new Array(y),I=0;I<y;I++)S[I]=arguments[I];return s.FromArrayToRef(S,0,this)}set(){const y=this.ki;for(let S=0;S<16;S++)y[S]=S<0||arguments.length<=S?void 0:arguments[S];return this.markAsUpdated(),this}nd(y){const S=this.ki;for(let I=0;I<16;I++)S[I]=y;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return s.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(y){const S=new s;return this.addToRef(y,S),S}addToRef(y,S){const I=this.ki,V=S.ki,i=y.m;for(let A=0;A<16;A++)V[A]=I[A]+i[A];return S.markAsUpdated(),S}addToSelf(y){const S=this.ki,I=y.m;return S[0]+=I[0],S[1]+=I[1],S[2]+=I[2],S[3]+=I[3],S[4]+=I[4],S[5]+=I[5],S[6]+=I[6],S[7]+=I[7],S[8]+=I[8],S[9]+=I[9],S[10]+=I[10],S[11]+=I[11],S[12]+=I[12],S[13]+=I[13],S[14]+=I[14],S[15]+=I[15],this.markAsUpdated(),this}addInPlace(y){const S=this.ki,I=y.m;for(let V=0;V<16;V++)S[V]+=I[V];return this.markAsUpdated(),this}addInPlaceFromFloats(){const y=this.ki;for(let S=0;S<16;S++)y[S]+=S<0||arguments.length<=S?void 0:arguments[S];return this.markAsUpdated(),this}fS(y){const S=this.ki,I=y.m;for(let V=0;V<16;V++)S[V]-=I[V];return this.markAsUpdated(),this}subtractToRef(y,S){const I=this.ki,V=y.m,i=S.ki;for(let A=0;A<16;A++)i[A]=I[A]-V[A];return S.markAsUpdated(),S}uK(y){const S=this.ki,I=y.m;for(let V=0;V<16;V++)S[V]-=I[V];return this.markAsUpdated(),this}subtractFromFloats(){for(var y=arguments.length,S=new Array(y),I=0;I<y;I++)S[I]=arguments[I];return this.subtractFromFloatsToRef(...S,new s)}subtractFromFloatsToRef(){for(var y=arguments.length,S=new Array(y),I=0;I<y;I++)S[I]=arguments[I];const V=S.pop(),i=this.ki,A=V.ki,B=S;for(let d=0;d<16;d++)A[d]=i[d]-B[d];return V.markAsUpdated(),V}invertToRef(y){return!0===this._isIdentity?(s.IdentityToRef(y),y):(G(this,y.Vd())?y.markAsUpdated():y.A(this),y)}addAtIndex(y,S){return this.ki[y]+=S,this.markAsUpdated(),this}multiplyAtIndex(y,S){return this.ki[y]*=S,this.markAsUpdated(),this}setTranslationFromFloats(y,S,I){return this.ki[12]=y,this.ki[13]=S,this.ki[14]=I,this.markAsUpdated(),this}addTranslationFromFloats(y,S,I){return this.ki[12]+=y,this.ki[13]+=S,this.ki[14]+=I,this.markAsUpdated(),this}setTranslation(y){return this.setTranslationFromFloats(y._x,y._y,y._z)}getTranslation(){return new T(this.ki[12],this.ki[13],this.ki[14])}getTranslationToRef(y){return y.x=this.ki[12],y.y=this.ki[13],y.z=this.ki[14],y}removeRotationAndScaling(){const y=this.m;return s.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,y[12],y[13],y[14],y[15],this),this._updateIdentityStatus(0===y[12]&&0===y[13]&&0===y[14]&&1===y[15]),this}A(y){y.copyToArray(this.ki);const S=y;return this.updateFlag=S.updateFlag,this._updateIdentityStatus(S._isIdentity,S._isIdentityDirty,S._isIdentity3x2,S._isIdentity3x2Dirty),this}copyToArray(y){return K(this,y,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(y){const S=new s;return this.multiplyToRef(y,S),S}multiplyInPlace(y){const S=this.ki,I=y.m;for(let V=0;V<16;V++)S[V]*=I[V];return this.markAsUpdated(),this}multiplyByFloats(){const y=this.ki;for(let S=0;S<16;S++)y[S]*=S<0||arguments.length<=S?void 0:arguments[S];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var y=arguments.length,S=new Array(y),I=0;I<y;I++)S[I]=arguments[I];const V=S.pop(),i=this.ki,A=V.ki,B=S;for(let d=0;d<16;d++)A[d]=i[d]*B[d];return V.markAsUpdated(),V}multiplyToRef(y,S){return this._isIdentity?(S.A(y),S):y._isIdentity?(S.A(this),S):(this.multiplyToArray(y,S.ki,0),S.markAsUpdated(),S)}multiplyToArray(y,S,I){return u(this,y,S,I),this}divide(y){return this.divideToRef(y,new s)}divideToRef(y,S){const I=this.ki,V=y.m,i=S.ki;for(let A=0;A<16;A++)i[A]=I[A]/V[A];return S.markAsUpdated(),S}divideInPlace(y){const S=this.ki,I=y.m;for(let V=0;V<16;V++)S[V]/=I[V];return this.markAsUpdated(),this}minimizeInPlace(y){const S=this.ki,I=y.m;for(let V=0;V<16;V++)S[V]=Math.min(S[V],I[V]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const y=this.ki;for(let S=0;S<16;S++)y[S]=Math.min(y[S],S<0||arguments.length<=S?void 0:arguments[S]);return this.markAsUpdated(),this}maximizeInPlace(y){const S=this.ki,I=y.m;for(let V=0;V<16;V++)S[V]=Math.min(S[V],I[V]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const y=this.ki;for(let S=0;S<16;S++)y[S]=Math.min(y[S],S<0||arguments.length<=S?void 0:arguments[S]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new s)}negateInPlace(){const y=this.ki;for(let S=0;S<16;S++)y[S]=-y[S];return this.markAsUpdated(),this}negateToRef(y){const S=this.ki,I=y.ki;for(let V=0;V<16;V++)I[V]=-S[V];return y.markAsUpdated(),y}equals(y){const S=y;if(!S)return!1;if((this._isIdentity||S._isIdentity)&&!this._isIdentityDirty&&!S._isIdentityDirty)return this._isIdentity&&S._isIdentity;const I=this.m,V=S.m;return I[0]===V[0]&&I[1]===V[1]&&I[2]===V[2]&&I[3]===V[3]&&I[4]===V[4]&&I[5]===V[5]&&I[6]===V[6]&&I[7]===V[7]&&I[8]===V[8]&&I[9]===V[9]&&I[10]===V[10]&&I[11]===V[11]&&I[12]===V[12]&&I[13]===V[13]&&I[14]===V[14]&&I[15]===V[15]}equalsWithEpsilon(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const I=this.ki,V=y.m;for(let i=0;i<16;i++)if(!(0,F.WithinEpsilon)(I[i],V[i],S))return!1;return!0}equalsToFloats(){const y=this.ki;for(let S=0;S<16;S++)if(y[S]!=(S<0||arguments.length<=S?void 0:arguments[S]))return!1;return!0}floor(){return this.floorToRef(new s)}floorToRef(y){const S=this.ki,I=y.ki;for(let V=0;V<16;V++)I[V]=Math.floor(S[V]);return y.markAsUpdated(),y}fract(){return this.fractToRef(new s)}fractToRef(y){const S=this.ki,I=y.ki;for(let V=0;V<16;V++)I[V]=S[V]-Math.floor(S[V]);return y.markAsUpdated(),y}clone(){const y=new s;return y.A(this),y}getClassName(){return"Matrix"}getHashCode(){let y=p(this.ki[0]);for(let S=1;S<16;S++)y=397*y^p(this.ki[S]);return y}decomposeToTransformNode(y){return y.rotationQuaternion=y.rotationQuaternion||new j,this.decompose(y.zd,y.rotationQuaternion,y.position)}decompose(y,S,I,V){let i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return I&&I.nd(0),y&&y.nd(1),S&&S.od(0,0,0,1),!0;const A=this.ki;if(I&&I.od(A[12],A[13],A[14]),(y=y||O.OS[0]).x=Math.sqrt(A[0]*A[0]+A[1]*A[1]+A[2]*A[2]),y.y=Math.sqrt(A[4]*A[4]+A[5]*A[5]+A[6]*A[6]),y.z=Math.sqrt(A[8]*A[8]+A[9]*A[9]+A[10]*A[10]),V){const S=(i?V.absoluteScaling.x:V.zd.x)<0?-1:1,I=(i?V.absoluteScaling.y:V.zd.y)<0?-1:1,A=(i?V.absoluteScaling.z:V.zd.z)<0?-1:1;y.x*=S,y.y*=I,y.z*=A}else this.determinant()<=0&&(y.y*=-1);if(0===y._x||0===y._y||0===y._z)return S&&S.od(0,0,0,1),!1;if(S){const I=1/y._x,V=1/y._y,i=1/y._z;s.FromValuesToRef(A[0]*I,A[1]*I,A[2]*I,0,A[4]*V,A[5]*V,A[6]*V,0,A[8]*i,A[9]*i,A[10]*i,0,0,0,0,1,O.Matrix[0]),j.FromRotationMatrixToRef(O.Matrix[0],S)}return!0}getRow(y){if(y<0||y>3)return null;const S=4*y;return new l(this.ki[S+0],this.ki[S+1],this.ki[S+2],this.ki[S+3])}getRowToRef(y,S){if(y>=0&&y<=3){const I=4*y;S.x=this.ki[I+0],S.y=this.ki[I+1],S.z=this.ki[I+2],S.w=this.ki[I+3]}return S}setRow(y,S){return this.setRowFromFloats(y,S.x,S.y,S.z,S.w)}transpose(){const y=new s;return s.TransposeToRef(this,y),y}transposeToRef(y){return s.TransposeToRef(this,y),y}setRowFromFloats(y,S,I,V,i){if(y<0||y>3)return this;const A=4*y;return this.ki[A+0]=S,this.ki[A+1]=I,this.ki[A+2]=V,this.ki[A+3]=i,this.markAsUpdated(),this}scale(y){const S=new s;return this.scaleToRef(y,S),S}scaleToRef(y,S){for(let I=0;I<16;I++)S.ki[I]=this.ki[I]*y;return S.markAsUpdated(),S}scaleAndAddToRef(y,S){for(let I=0;I<16;I++)S.ki[I]+=this.ki[I]*y;return S.markAsUpdated(),S}scaleInPlace(y){const S=this.ki;for(let I=0;I<16;I++)S[I]*=y;return this.markAsUpdated(),this}toNormalMatrix(y){const S=O.Matrix[0];this.invertToRef(S),S.transposeToRef(y);const I=y.ki;return s.FromValuesToRef(I[0],I[1],I[2],0,I[4],I[5],I[6],0,I[8],I[9],I[10],0,0,0,0,1,y),y}getRotationMatrix(){const y=new s;return this.getRotationMatrixToRef(y),y}getRotationMatrixToRef(y){const S=O.OS[0];if(!this.decompose(S))return s.IdentityToRef(y),y;const I=this.ki,V=1/S._x,i=1/S._y,A=1/S._z;return s.FromValuesToRef(I[0]*V,I[1]*V,I[2]*V,0,I[4]*i,I[5]*i,I[6]*i,0,I[8]*A,I[9]*A,I[10]*A,0,0,0,0,1,y),y}toggleModelMatrixHandInPlace(){const y=this.ki;return y[2]*=-1,y[6]*=-1,y[8]*=-1,y[9]*=-1,y[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const y=this.ki;return y[8]*=-1,y[9]*=-1,y[10]*=-1,y[11]*=-1,this.markAsUpdated(),this}static oS(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const I=new s;return s.FromArrayToRef(y,S,I),I}static FromArrayToRef(y,S,I){for(let V=0;V<16;V++)I.ki[V]=y[V+S];return I.markAsUpdated(),I}static FromFloat32ArrayToRefScaled(y,S,I,V){return V.ki[0]=y[0+S]*I,V.ki[1]=y[1+S]*I,V.ki[2]=y[2+S]*I,V.ki[3]=y[3+S]*I,V.ki[4]=y[4+S]*I,V.ki[5]=y[5+S]*I,V.ki[6]=y[6+S]*I,V.ki[7]=y[7+S]*I,V.ki[8]=y[8+S]*I,V.ki[9]=y[9+S]*I,V.ki[10]=y[10+S]*I,V.ki[11]=y[11+S]*I,V.ki[12]=y[12+S]*I,V.ki[13]=y[13+S]*I,V.ki[14]=y[14+S]*I,V.ki[15]=y[15+S]*I,V.markAsUpdated(),V}static get IdentityReadOnly(){return s._IdentityReadOnly}static FromValuesToRef(y,S,I,V,i,A,B,d,F,J,u,K,G,p,L,T,l){const j=l.ki;j[0]=y,j[1]=S,j[2]=I,j[3]=V,j[4]=i,j[5]=A,j[6]=B,j[7]=d,j[8]=F,j[9]=J,j[10]=u,j[11]=K,j[12]=G,j[13]=p,j[14]=L,j[15]=T,l.markAsUpdated()}static FromValues(y,S,I,V,i,A,B,d,F,J,u,K,G,p,L,T){const l=new s,j=l.ki;return j[0]=y,j[1]=S,j[2]=I,j[3]=V,j[4]=i,j[5]=A,j[6]=B,j[7]=d,j[8]=F,j[9]=J,j[10]=u,j[11]=K,j[12]=G,j[13]=p,j[14]=L,j[15]=T,l.markAsUpdated(),l}static Compose(y,S,I){const V=new s;return s.ComposeToRef(y,S,I,V),V}static ComposeToRef(y,S,I,V){const i=V.ki,A=S._x,B=S._y,d=S._z,F=S._w,J=A+A,u=B+B,K=d+d,G=A*J,p=A*u,L=A*K,T=B*u,l=B*K,j=d*K,s=F*J,O=F*u,f=F*K,my=y._x,C=y._y,D=y._z;return i[0]=(1-(T+j))*my,i[1]=(p+f)*my,i[2]=(L-O)*my,i[3]=0,i[4]=(p-f)*C,i[5]=(1-(G+j))*C,i[6]=(l+s)*C,i[7]=0,i[8]=(L+O)*D,i[9]=(l-s)*D,i[10]=(1-(G+T))*D,i[11]=0,i[12]=I._x,i[13]=I._y,i[14]=I._z,i[15]=1,V.markAsUpdated(),V}static Identity(){const y=s.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return y._updateIdentityStatus(!0),y}static IdentityToRef(y){return s.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,y),y._updateIdentityStatus(!0),y}static Zero(){const y=s.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return y._updateIdentityStatus(!1),y}static RotationX(y){const S=new s;return s.RotationXToRef(y,S),S}static Invert(y){const S=new s;return y.invertToRef(S),S}static RotationXToRef(y,S){const I=Math.sin(y),V=Math.cos(y);return s.FromValuesToRef(1,0,0,0,0,V,I,0,0,-I,V,0,0,0,0,1,S),S._updateIdentityStatus(1===V&&0===I),S}static RotationY(y){const S=new s;return s.RotationYToRef(y,S),S}static RotationYToRef(y,S){const I=Math.sin(y),V=Math.cos(y);return s.FromValuesToRef(V,0,-I,0,0,1,0,0,I,0,V,0,0,0,0,1,S),S._updateIdentityStatus(1===V&&0===I),S}static RotationZ(y){const S=new s;return s.RotationZToRef(y,S),S}static RotationZToRef(y,S){const I=Math.sin(y),V=Math.cos(y);return s.FromValuesToRef(V,I,0,0,-I,V,0,0,0,0,1,0,0,0,0,1,S),S._updateIdentityStatus(1===V&&0===I),S}static RotationAxis(y,S){const I=new s;return s.RotationAxisToRef(y,S,I),I}static RotationAxisToRef(y,S,I){const V=Math.sin(-S),i=Math.cos(-S),A=1-i;y=y.normalizeToRef(O.OS[0]);const B=I.ki;return B[0]=y._x*y._x*A+i,B[1]=y._x*y._y*A-y._z*V,B[2]=y._x*y._z*A+y._y*V,B[3]=0,B[4]=y._y*y._x*A+y._z*V,B[5]=y._y*y._y*A+i,B[6]=y._y*y._z*A-y._x*V,B[7]=0,B[8]=y._z*y._x*A-y._y*V,B[9]=y._z*y._y*A+y._x*V,B[10]=y._z*y._z*A+i,B[11]=0,B[12]=0,B[13]=0,B[14]=0,B[15]=1,I.markAsUpdated(),I}static RotationAlignToRef(y,S,I){let i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const A=T.Dot(S,y),B=I.ki;if(A<-1+V.c)B[0]=-1,B[1]=0,B[2]=0,B[3]=0,B[4]=0,B[5]=i?1:-1,B[6]=0,B[7]=0,B[8]=0,B[9]=0,B[10]=i?-1:1,B[11]=0;else{const I=T.Cross(S,y),V=1/(1+A);B[0]=I._x*I._x*V+A,B[1]=I._y*I._x*V-I._z,B[2]=I._z*I._x*V+I._y,B[3]=0,B[4]=I._x*I._y*V+I._z,B[5]=I._y*I._y*V+A,B[6]=I._z*I._y*V-I._x,B[7]=0,B[8]=I._x*I._z*V-I._y,B[9]=I._y*I._z*V+I._x,B[10]=I._z*I._z*V+A,B[11]=0}return B[12]=0,B[13]=0,B[14]=0,B[15]=1,I.markAsUpdated(),I}static RotationYawPitchRoll(y,S,I){const V=new s;return s.RotationYawPitchRollToRef(y,S,I,V),V}static RotationYawPitchRollToRef(y,S,I,V){return j.RotationYawPitchRollToRef(y,S,I,O.Quaternion[0]),O.Quaternion[0].toRotationMatrix(V),V}static Scaling(y,S,I){const V=new s;return s.ScalingToRef(y,S,I,V),V}static ScalingToRef(y,S,I,V){return s.FromValuesToRef(y,0,0,0,0,S,0,0,0,0,I,0,0,0,0,1,V),V._updateIdentityStatus(1===y&&1===S&&1===I),V}static Translation(y,S,I){const V=new s;return s.TranslationToRef(y,S,I,V),V}static TranslationToRef(y,S,I,V){return s.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,y,S,I,1,V),V._updateIdentityStatus(0===y&&0===S&&0===I),V}static Lerp(y,S,I){const V=new s;return s.LerpToRef(y,S,I,V),V}static LerpToRef(y,S,I,V){const i=V.ki,A=y.m,B=S.m;for(let d=0;d<16;d++)i[d]=A[d]*(1-I)+B[d]*I;return V.markAsUpdated(),V}static DecomposeLerp(y,S,I){const V=new s;return s.DecomposeLerpToRef(y,S,I,V),V}static DecomposeLerpToRef(y,S,I,V){const i=O.OS[0],A=O.Quaternion[0],B=O.OS[1];y.decompose(i,A,B);const d=O.OS[2],F=O.Quaternion[1],J=O.OS[3];S.decompose(d,F,J);const u=O.OS[4];T.LerpToRef(i,d,I,u);const K=O.Quaternion[2];j.SlerpToRef(A,F,I,K);const G=O.OS[5];return T.LerpToRef(B,J,I,G),s.ComposeToRef(u,K,G,V),V}static LookAtLH(y,S,I){const V=new s;return s.LookAtLHToRef(y,S,I,V),V}static LookAtLHToRef(y,S,I,V){const i=O.OS[0],A=O.OS[1],B=O.OS[2];S.subtractToRef(y,B),B.normalize(),T.CrossToRef(I,B,i);const d=i.lengthSquared();0===d?i.x=1:i.normalizeFromLength(Math.sqrt(d)),T.CrossToRef(B,i,A),A.normalize();const F=-T.Dot(i,y),J=-T.Dot(A,y),u=-T.Dot(B,y);return s.FromValuesToRef(i._x,A._x,B._x,0,i._y,A._y,B._y,0,i._z,A._z,B._z,0,F,J,u,1,V),V}static LookAtRH(y,S,I){const V=new s;return s.LookAtRHToRef(y,S,I,V),V}static LookAtRHToRef(y,S,I,V){const i=O.OS[0],A=O.OS[1],B=O.OS[2];y.subtractToRef(S,B),B.normalize(),T.CrossToRef(I,B,i);const d=i.lengthSquared();0===d?i.x=1:i.normalizeFromLength(Math.sqrt(d)),T.CrossToRef(B,i,A),A.normalize();const F=-T.Dot(i,y),J=-T.Dot(A,y),u=-T.Dot(B,y);return s.FromValuesToRef(i._x,A._x,B._x,0,i._y,A._y,B._y,0,i._z,A._z,B._z,0,F,J,u,1,V),V}static LookDirectionLH(y,S){const I=new s;return s.LookDirectionLHToRef(y,S,I),I}static LookDirectionLHToRef(y,S,I){const V=O.OS[0];V.A(y),V.scaleInPlace(-1);const i=O.OS[1];return T.CrossToRef(S,V,i),s.FromValuesToRef(i._x,i._y,i._z,0,S._x,S._y,S._z,0,V._x,V._y,V._z,0,0,0,0,1,I),I}static LookDirectionRH(y,S){const I=new s;return s.LookDirectionRHToRef(y,S,I),I}static LookDirectionRHToRef(y,S,I){const V=O.OS[2];return T.CrossToRef(S,y,V),s.FromValuesToRef(V._x,V._y,V._z,0,S._x,S._y,S._z,0,y._x,y._y,y._z,0,0,0,0,1,I),I}static OrthoLH(y,S,I,V,i){const A=new s;return s.OrthoLHToRef(y,S,I,V,A,i),A}static OrthoLHToRef(y,S,I,V,i,A){const B=2/y,d=2/S,F=2/(V-I),J=-(V+I)/(V-I);return s.FromValuesToRef(B,0,0,0,0,d,0,0,0,0,F,0,0,0,J,1,i),A&&i.multiplyToRef(my,i),i._updateIdentityStatus(1===B&&1===d&&1===F&&0===J),i}static OrthoOffCenterLH(y,S,I,V,i,A,B){const d=new s;return s.OrthoOffCenterLHToRef(y,S,I,V,i,A,d,B),d}static OrthoOffCenterLHToRef(y,S,I,V,i,A,B,d){const F=2/(S-y),J=2/(V-I),u=2/(A-i),K=-(A+i)/(A-i),G=(y+S)/(y-S),p=(V+I)/(I-V);return s.FromValuesToRef(F,0,0,0,0,J,0,0,0,0,u,0,G,p,K,1,B),d&&B.multiplyToRef(my,B),B.markAsUpdated(),B}static ObliqueOffCenterLHToRef(y,S,I,V,i,A,B,d,F,J,u){const K=-B*Math.cos(d),G=-B*Math.sin(d);return s.TranslationToRef(0,0,-F,O.Matrix[1]),s.FromValuesToRef(1,0,0,0,0,1,0,0,K,G,1,0,0,0,0,1,O.Matrix[0]),O.Matrix[1].multiplyToRef(O.Matrix[0],O.Matrix[0]),s.TranslationToRef(0,0,F,O.Matrix[1]),O.Matrix[0].multiplyToRef(O.Matrix[1],O.Matrix[0]),s.OrthoOffCenterLHToRef(y,S,I,V,i,A,J,u),O.Matrix[0].multiplyToRef(J,J),J}static OrthoOffCenterRH(y,S,I,V,i,A,B){const d=new s;return s.OrthoOffCenterRHToRef(y,S,I,V,i,A,d,B),d}static OrthoOffCenterRHToRef(y,S,I,V,i,A,B,d){return s.OrthoOffCenterLHToRef(y,S,I,V,i,A,B,d),B.ki[10]*=-1,B}static ObliqueOffCenterRHToRef(y,S,I,V,i,A,B,d,F,J,u){const K=B*Math.cos(d),G=B*Math.sin(d);return s.TranslationToRef(0,0,F,O.Matrix[1]),s.FromValuesToRef(1,0,0,0,0,1,0,0,K,G,1,0,0,0,0,1,O.Matrix[0]),O.Matrix[1].multiplyToRef(O.Matrix[0],O.Matrix[0]),s.TranslationToRef(0,0,-F,O.Matrix[1]),O.Matrix[0].multiplyToRef(O.Matrix[1],O.Matrix[0]),s.OrthoOffCenterRHToRef(y,S,I,V,i,A,J,u),O.Matrix[0].multiplyToRef(J,J),J}static PerspectiveLH(y,S,I,V,i){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const B=new s,d=2*I/y,F=2*I/S,J=(V+I)/(V-I),u=-2*V*I/(V-I),K=Math.tan(A);return s.FromValuesToRef(d,0,0,0,0,F,0,K,0,0,J,1,0,0,u,0,B),i&&B.multiplyToRef(my,B),B._updateIdentityStatus(!1),B}static PerspectiveFovLH(y,S,I,V,i){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,B=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const d=new s;return s.PerspectiveFovLHToRef(y,S,I,V,d,!0,i,A,B),d}static PerspectiveFovLHToRef(y,S,I,V,i){let A=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,F=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const J=I,u=V,K=1/Math.tan(.5*y),G=A?K/S:K,p=A?K:K*S,L=F&&0===J?-1:0!==u?(u+J)/(u-J):1,T=F&&0===J?2*u:0!==u?-2*u*J/(u-J):-2*J,l=Math.tan(d);return s.FromValuesToRef(G,0,0,0,0,p,0,l,0,0,L,1,0,0,T,0,i),B&&i.multiplyToRef(my,i),i._updateIdentityStatus(!1),i}static PerspectiveFovReverseLHToRef(y,S,I,V,i){let A=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const F=1/Math.tan(.5*y),J=A?F/S:F,u=A?F:F*S,K=Math.tan(d);return s.FromValuesToRef(J,0,0,0,0,u,0,K,0,0,-I,1,0,0,1,0,i),B&&i.multiplyToRef(my,i),i._updateIdentityStatus(!1),i}static PerspectiveFovRH(y,S,I,V,i){let A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,B=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const d=new s;return s.PerspectiveFovRHToRef(y,S,I,V,d,!0,i,A,B),d}static PerspectiveFovRHToRef(y,S,I,V,i){let A=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,F=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const J=I,u=V,K=1/Math.tan(.5*y),G=A?K/S:K,p=A?K:K*S,L=F&&0===J?1:0!==u?-(u+J)/(u-J):-1,T=F&&0===J?2*u:0!==u?-2*u*J/(u-J):-2*J,l=Math.tan(d);return s.FromValuesToRef(G,0,0,0,0,p,0,l,0,0,L,-1,0,0,T,0,i),B&&i.multiplyToRef(my,i),i._updateIdentityStatus(!1),i}static PerspectiveFovReverseRHToRef(y,S,I,V,i){let A=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],B=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const F=1/Math.tan(.5*y),J=A?F/S:F,u=A?F:F*S,K=Math.tan(d);return s.FromValuesToRef(J,0,0,0,0,u,0,K,0,0,-I,-1,0,0,-1,0,i),B&&i.multiplyToRef(my,i),i._updateIdentityStatus(!1),i}static GetFinalMatrix(y,S,I,V,i,A){const B=y.width,d=y.height,F=y.x,J=y.y,u=s.FromValues(B/2,0,0,0,0,-d/2,0,0,0,0,A-i,0,F+B/2,d/2+J,i,1),K=new s;return S.multiplyToRef(I,K),K.multiplyToRef(V,K),K.multiplyToRef(u,K)}static GetAsMatrix2x2(y){const S=y.m,I=[S[0],S[1],S[4],S[5]];return B.d.MatrixUse64Bits?I:new Float32Array(I)}static GetAsMatrix3x3(y){const S=y.m,I=[S[0],S[1],S[2],S[4],S[5],S[6],S[8],S[9],S[10]];return B.d.MatrixUse64Bits?I:new Float32Array(I)}static Transpose(y){const S=new s;return s.TransposeToRef(y,S),S}static TransposeToRef(y,S){const I=y.m,V=I[0],i=I[4],A=I[8],B=I[12],d=I[1],F=I[5],J=I[9],u=I[13],K=I[2],G=I[6],p=I[10],L=I[14],T=I[3],l=I[7],j=I[11],s=I[15],O=S.ki;return O[0]=V,O[1]=i,O[2]=A,O[3]=B,O[4]=d,O[5]=F,O[6]=J,O[7]=u,O[8]=K,O[9]=G,O[10]=p,O[11]=L,O[12]=T,O[13]=l,O[14]=j,O[15]=s,S.markAsUpdated(),S._updateIdentityStatus(y._isIdentity,y._isIdentityDirty),S}static Reflection(y){const S=new s;return s.ReflectionToRef(y,S),S}static ReflectionToRef(y,S){y.normalize();const I=y.normal.x,V=y.normal.y,i=y.normal.z,A=-2*I,B=-2*V,d=-2*i;return s.FromValuesToRef(A*I+1,B*I,d*I,0,A*V,B*V+1,d*V,0,A*i,B*i,d*i+1,0,A*y.d,B*y.d,d*y.d,1,S),S}static FromXYZAxesToRef(y,S,I,V){return s.FromValuesToRef(y._x,y._y,y._z,0,S._x,S._y,S._z,0,I._x,I._y,I._z,0,0,0,0,1,V),V}static FromQuaternionToRef(y,S){const I=y._x*y._x,V=y._y*y._y,i=y._z*y._z,A=y._x*y._y,B=y._z*y._w,d=y._z*y._x,F=y._y*y._w,J=y._y*y._z,u=y._x*y._w;return S.ki[0]=1-2*(V+i),S.ki[1]=2*(A+B),S.ki[2]=2*(d-F),S.ki[3]=0,S.ki[4]=2*(A-B),S.ki[5]=1-2*(i+I),S.ki[6]=2*(J+u),S.ki[7]=0,S.ki[8]=2*(d+F),S.ki[9]=2*(J-u),S.ki[10]=1-2*(V+I),S.ki[11]=0,S.ki[12]=0,S.ki[13]=0,S.ki[14]=0,S.ki[15]=1,S.markAsUpdated(),S}}s._IdentityReadOnly=s.Identity(),Object.defineProperties(s.prototype,{dimension:{value:[4,4]},rank:{value:2}});class O{}O.OS=(0,i.h)(11,T.Zero),O.Matrix=(0,i.h)(2,s.Identity),O.Quaternion=(0,i.h)(3,j.Zero);class f{}f.Vector2=(0,i.h)(3,L.Zero),f.OS=(0,i.h)(13,T.Zero),f.Vector4=(0,i.h)(3,l.Zero),f.Quaternion=(0,i.h)(3,j.Zero),f.Matrix=(0,i.h)(8,s.Identity),(0,A.e)("BABYLON.Vector2",L),(0,A.e)("BABYLON.Vector3",T),(0,A.e)("BABYLON.Vector4",l),(0,A.e)("BABYLON.Matrix",s);const my=s.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12331:(y,S,I)=>{function V(y,S){const I=[];for(let V=0;V<y;++V)I.push(S());return I}function i(y,S){return V(y,S)}I.d(S,{e:()=>V,h:()=>i,l:()=>B});const A=["push","splice","pop","shift","unshift"];function B(y,S){const I=A.map((I=>function(y,S,I){const V=y[S];if("function"!==typeof V)return null;const i=function(){const V=y.length,A=i.previous.apply(y,arguments);return I(S,V),A};return V.next=i,i.previous=V,y[S]=i,()=>{const I=i.previous;if(!I)return;const V=i.next;V?(I.next=V,V.previous=I):(I.next=void 0,y[S]=I),i.next=void 0,i.previous=void 0}}(y,I,S)));return()=>{for(const y of I)null===y||void 0===y||y()}}}}]);