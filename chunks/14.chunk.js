"use strict";(self["3nlrbof8msu"]=self["3nlrbof8msu"]||[]).push([[14],{12737:(t,b,Z)=>{Z.d(b,{e:()=>v,i:()=>P,k:()=>J,m:()=>S});const J=1/2.2,S=2.2,P=(1+Math.sqrt(5))/2,v=.001},12745:(t,b,Z)=>{function J(t){return parseInt(t.toString().replace(/\W/g,""))}function S(t,b){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(t-b)<=Z}function P(t,b,Z){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return t<b-J||t>Z+J}function v(t,b){return t===b?t:Math.random()*(b-t)+t}function h(t,b,Z){return t+(b-t)*Z}function C(t,b,Z){let J=k(b-t,360);return J>180&&(J-=360),t+J*r(Z)}function Y(t,b,Z){let J=0;return J=t!=b?r((Z-t)/(b-t)):0,J}function g(t,b,Z,J,S){const P=S*S,v=S*P;return t*(2*v-3*P+1)+Z*(-2*v+3*P)+b*(v-2*P+S)+J*(v-P)}function I(t,b,Z,J,S){const P=S*S;return 6*(P-S)*t+(3*P-4*S+1)*b+6*(-P+S)*Z+(3*P-2*S)*J}function r(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(Z,Math.max(b,t))}function M(t){return t-=2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function T(t){const b=t.toString(16);return t<=15?("0"+b).toUpperCase():b.toUpperCase()}function a(t){if(Math.log2)return Math.floor(Math.log2(t));if(t<0)return NaN;if(0===t)return-1/0;let b=0;if(t<1){for(;t<1;)b++,t*=2;b=-b}else if(t>1)for(;t>1;)b++,t=Math.floor(t/2);return b}function k(t,b){return t-Math.floor(t/b)*b}function u(t,b,Z){return(t-b)/(Z-b)}function l(t,b,Z){return t*(Z-b)+b}function U(t,b){let Z=k(b-t,360);return Z>180&&(Z-=360),Z}function E(t,b){const Z=k(t,2*b);return b-Math.abs(Z-b)}function c(t,b,Z){let J=r(Z);return J=-2*J*J*J+3*J*J,b*J+t*(1-J)}function H(t,b,Z){let J=0;return J=Math.abs(b-t)<=Z?b:t+Math.sign(b-t)*Z,J}function o(t,b,Z){const J=U(t,b);let S=0;return S=-Z<J&&J<Z?b:H(t,b=t+J,Z),S}function O(t,b,Z){return(t-b)/(Z-b)}function p(t,b,Z){return(Z-b)*t+b}function e(t,b){const Z=t%b;return 0===Z?b:e(b,Z)}Z.r(b),Z.d(b,{Clamp:()=>r,DeltaAngle:()=>U,Denormalize:()=>l,ExtractAsInt:()=>J,Hermite:()=>g,Hermite1stDerivative:()=>I,HighestCommonFactor:()=>e,ILog2:()=>a,InverseLerp:()=>Y,Lerp:()=>h,LerpAngle:()=>C,MoveTowards:()=>H,MoveTowardsAngle:()=>o,Normalize:()=>u,NormalizeRadians:()=>M,OutsideRange:()=>P,PercentToRange:()=>p,PingPong:()=>E,RandomRange:()=>v,RangeToPercent:()=>O,Repeat:()=>k,SmoothStep:()=>c,ToHex:()=>T,WithinEpsilon:()=>S})},12735:(t,b,Z)=>{Z.r(b),Z.d(b,{Matrix:()=>l,Quaternion:()=>u,TmpVectors:()=>E,Vector2:()=>T,JZ:()=>a,Vector4:()=>k});var J=Z(12737),S=Z(12742),P=Z(12688),v=Z(12658),h=Z(12585),C=Z(12745);class Y{}function g(t,b,Z){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const S=t.jb(),P=b.jb(),v=S[0],h=S[1],C=S[2],Y=S[3],g=S[4],I=S[5],r=S[6],M=S[7],T=S[8],a=S[9],k=S[10],u=S[11],l=S[12],U=S[13],E=S[14],c=S[15],H=P[0],o=P[1],O=P[2],p=P[3],e=P[4],W=P[5],j=P[6],V=P[7],n=P[8],y=P[9],d=P[10],s=P[11],q=P[12],Q=P[13],N=P[14],A=P[15];Z[J]=v*H+h*e+C*n+Y*q,Z[J+1]=v*o+h*W+C*y+Y*Q,Z[J+2]=v*O+h*j+C*d+Y*N,Z[J+3]=v*p+h*V+C*s+Y*A,Z[J+4]=g*H+I*e+r*n+M*q,Z[J+5]=g*o+I*W+r*y+M*Q,Z[J+6]=g*O+I*j+r*d+M*N,Z[J+7]=g*p+I*V+r*s+M*A,Z[J+8]=T*H+a*e+k*n+u*q,Z[J+9]=T*o+a*W+k*y+u*Q,Z[J+10]=T*O+a*j+k*d+u*N,Z[J+11]=T*p+a*V+k*s+u*A,Z[J+12]=l*H+U*e+E*n+c*q,Z[J+13]=l*o+U*W+E*y+c*Q,Z[J+14]=l*O+U*j+E*d+c*N,Z[J+15]=l*p+U*V+E*s+c*A}function I(t,b){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const J=t.jb();b[Z]=J[0],b[Z+1]=J[1],b[Z+2]=J[2],b[Z+3]=J[3],b[Z+4]=J[4],b[Z+5]=J[5],b[Z+6]=J[6],b[Z+7]=J[7],b[Z+8]=J[8],b[Z+9]=J[9],b[Z+10]=J[10],b[Z+11]=J[11],b[Z+12]=J[12],b[Z+13]=J[13],b[Z+14]=J[14],b[Z+15]=J[15]}function r(t,b){const Z=t.jb(),J=Z[0],S=Z[1],P=Z[2],v=Z[3],h=Z[4],C=Z[5],Y=Z[6],g=Z[7],I=Z[8],r=Z[9],M=Z[10],T=Z[11],a=Z[12],k=Z[13],u=Z[14],l=Z[15],U=M*l-u*T,E=r*l-k*T,c=r*u-k*M,H=I*l-a*T,o=I*u-M*a,O=I*k-a*r,p=+(C*U-Y*E+g*c),e=-(h*U-Y*H+g*o),W=+(h*E-C*H+g*O),j=-(h*c-C*o+Y*O),V=J*p+S*e+P*W+v*j;if(0===V)return!1;const n=1/V,y=Y*l-u*g,d=C*l-k*g,s=C*u-k*Y,q=h*l-a*g,Q=h*u-a*Y,N=h*k-a*C,A=Y*T-M*g,K=C*T-r*g,L=C*M-r*Y,F=h*T-I*g,B=h*M-I*Y,X=h*r-I*C,x=-(S*U-P*E+v*c),i=+(J*U-P*H+v*o),z=-(J*E-S*H+v*O),D=+(J*c-S*o+P*O),f=+(S*y-P*d+v*s),mt=-(J*y-P*q+v*Q),R=+(J*d-S*q+v*N),w=-(J*s-S*Q+P*N),G=-(S*A-P*K+v*L),tt=+(J*A-P*F+v*B),bt=-(J*K-S*F+v*X),Zt=+(J*L-S*B+P*X);return b[0]=p*n,b[1]=x*n,b[2]=f*n,b[3]=G*n,b[4]=e*n,b[5]=i*n,b[6]=mt*n,b[7]=tt*n,b[8]=W*n,b[9]=z*n,b[10]=R*n,b[11]=bt*n,b[12]=j*n,b[13]=D*n,b[14]=w*n,b[15]=Zt*n,!0}Y._UpdateFlagSeed=0;const M=t=>parseInt(t.toString().replace(/\W/g,""));class T{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=t,this.y=b}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let t=M(this.x);return t=397*t^M(this.y),t}toArray(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[b]=this.x,t[b+1]=this.y,this}ZJ(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return T.FromArrayToRef(t,b,this),this}jb(){return[this.x,this.y]}S(t){return this.x=t.x,this.y=t.y,this}Ab(t,b){return this.x=t,this.y=b,this}set(t,b){return this.Ab(t,b)}Lb(t){return this.Ab(t,t)}add(t){return new T(this.x+t.x,this.y+t.y)}addToRef(t,b){return b.x=this.x+t.x,b.y=this.y+t.y,b}addInPlace(t){return this.x+=t.x,this.y+=t.y,this}addInPlaceFromFloats(t,b){return this.x+=t,this.y+=b,this}addVector3(t){return new T(this.x+t.x,this.y+t.y)}SZ(t){return new T(this.x-t.x,this.y-t.y)}subtractToRef(t,b){return b.x=this.x-t.x,b.y=this.y-t.y,b}XI(t){return this.x-=t.x,this.y-=t.y,this}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this}multiply(t){return new T(this.x*t.x,this.y*t.y)}multiplyToRef(t,b){return b.x=this.x*t.x,b.y=this.y*t.y,b}multiplyByFloats(t,b){return new T(this.x*t,this.y*b)}divide(t){return new T(this.x/t.x,this.y/t.y)}divideToRef(t,b){return b.x=this.x/t.x,b.y=this.y/t.y,b}divideInPlace(t){return this.x=this.x/t.x,this.y=this.y/t.y,this}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t.x,t.y)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t.x,t.y)}minimizeInPlaceFromFloats(t,b){return this.x=Math.min(t,this.x),this.y=Math.min(b,this.y),this}maximizeInPlaceFromFloats(t,b){return this.x=Math.max(t,this.x),this.y=Math.max(b,this.y),this}subtractFromFloats(t,b){return new T(this.x-t,this.y-b)}subtractFromFloatsToRef(t,b,Z){return Z.x=this.x-t,Z.y=this.y-b,Z}negate(){return new T(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(t){return t.x=-this.x,t.y=-this.y,t}scaleInPlace(t){return this.x*=t,this.y*=t,this}scale(t){return new T(this.x*t,this.y*t)}scaleToRef(t,b){return b.x=this.x*t,b.y=this.y*t,b}scaleAndAddToRef(t,b){return b.x+=this.x*t,b.y+=this.y*t,b}equals(t){return t&&this.x===t.x&&this.y===t.y}equalsWithEpsilon(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.e;return t&&(0,C.WithinEpsilon)(this.x,t.x,b)&&(0,C.WithinEpsilon)(this.y,t.y,b)}equalsToFloats(t,b){return this.x===t&&this.y===b}floor(){return new T(Math.floor(this.x),Math.floor(this.y))}floorToRef(t){return t.x=Math.floor(this.x),t.y=Math.floor(this.y),t}fract(){return new T(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(t){return t.x=this.x-Math.floor(this.x),t.y=this.y-Math.floor(this.y),t}rotate(t){return this.rotateToRef(t,new T)}rotateToRef(t,b){const Z=Math.cos(t),J=Math.sin(t);return b.x=Z*this.x-J*this.y,b.y=J*this.x+Z*this.y,b}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){const t=new T;return this.normalizeToRef(t),t}normalizeToRef(t){const b=this.length();return 0===b&&(t.x=this.x,t.y=this.y),this.scaleToRef(1/b,t)}clone(){return new T(this.x,this.y)}dot(t){return this.x*t.x+this.y*t.y}static Zero(){return new T(0,0)}static One(){return new T(1,1)}static Random(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new T((0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b))}static RandomToRef(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ab((0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b))}static get ZeroReadOnly(){return T._ZeroReadOnly}static CZ(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new T(t[b],t[b+1])}static FromArrayToRef(t,b,Z){return Z.x=t[b],Z.y=t[b+1],Z}static FromFloatsToRef(t,b,Z){return Z.Ab(t,b),Z}static CatmullRom(t,b,Z,J,S){const P=S*S,v=S*P,h=.5*(2*b.x+(-t.x+Z.x)*S+(2*t.x-5*b.x+4*Z.x-J.x)*P+(-t.x+3*b.x-3*Z.x+J.x)*v),C=.5*(2*b.y+(-t.y+Z.y)*S+(2*t.y-5*b.y+4*Z.y-J.y)*P+(-t.y+3*b.y-3*Z.y+J.y)*v);return new T(h,C)}static ClampToRef(t,b,Z,J){return J.x=(0,C.Clamp)(t.x,b.x,Z.x),J.y=(0,C.Clamp)(t.y,b.y,Z.y),J}static Clamp(t,b,Z){const J=(0,C.Clamp)(t.x,b.x,Z.x),S=(0,C.Clamp)(t.y,b.y,Z.y);return new T(J,S)}static Hermite(t,b,Z,J,S){const P=S*S,v=S*P,h=2*v-3*P+1,C=-2*v+3*P,Y=v-2*P+S,g=v-P,I=t.x*h+Z.x*C+b.x*Y+J.x*g,r=t.y*h+Z.y*C+b.y*Y+J.y*g;return new T(I,r)}static Hermite1stDerivative(t,b,Z,J,S){return this.Hermite1stDerivativeToRef(t,b,Z,J,S,new T)}static Hermite1stDerivativeToRef(t,b,Z,J,S,P){const v=S*S;return P.x=6*(v-S)*t.x+(3*v-4*S+1)*b.x+6*(-v+S)*Z.x+(3*v-2*S)*J.x,P.y=6*(v-S)*t.y+(3*v-4*S+1)*b.y+6*(-v+S)*Z.y+(3*v-2*S)*J.y,P}static Lerp(t,b,Z){return T.LerpToRef(t,b,Z,new T)}static LerpToRef(t,b,Z,J){return J.x=t.x+(b.x-t.x)*Z,J.y=t.y+(b.y-t.y)*Z,J}static Dot(t,b){return t.x*b.x+t.y*b.y}static Normalize(t){return T.NormalizeToRef(t,new T)}static NormalizeToRef(t,b){return t.normalizeToRef(b),b}static Minimize(t,b){const Z=t.x<b.x?t.x:b.x,J=t.y<b.y?t.y:b.y;return new T(Z,J)}static Maximize(t,b){const Z=t.x>b.x?t.x:b.x,J=t.y>b.y?t.y:b.y;return new T(Z,J)}static Transform(t,b){return T.TransformToRef(t,b,new T)}static TransformToRef(t,b,Z){const J=b.m,S=t.x*J[0]+t.y*J[4]+J[12],P=t.x*J[1]+t.y*J[5]+J[13];return Z.x=S,Z.y=P,Z}static PointInTriangle(t,b,Z,J){const S=.5*(-Z.y*J.x+b.y*(-Z.x+J.x)+b.x*(Z.y-J.y)+Z.x*J.y),P=S<0?-1:1,v=(b.y*J.x-b.x*J.y+(J.y-b.y)*t.x+(b.x-J.x)*t.y)*P,h=(b.x*Z.y-b.y*Z.x+(b.y-Z.y)*t.x+(Z.x-b.x)*t.y)*P;return v>0&&h>0&&v+h<2*S*P}static Distance(t,b){return Math.sqrt(T.DistanceSquared(t,b))}static DistanceSquared(t,b){const Z=t.x-b.x,J=t.y-b.y;return Z*Z+J*J}static Center(t,b){return T.CenterToRef(t,b,new T)}static CenterToRef(t,b,Z){return Z.Ab((t.x+b.x)/2,(t.y+b.y)/2)}static DistanceOfPointFromSegment(t,b,Z){const J=T.DistanceSquared(b,Z);if(0===J)return T.Distance(t,b);const S=Z.SZ(b),P=Math.max(0,Math.min(1,T.Dot(t.SZ(b),S)/J)),v=b.add(S.multiplyByFloats(P,P));return T.Distance(t,v)}}T._V8PerformanceHack=new T(.5,.5),T._ZeroReadOnly=T.Zero(),Object.defineProperties(T.prototype,{dimension:{value:[2]},rank:{value:1}});class a{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=t,this._y=b,this._z=Z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"JZ"}getHashCode(){let t=M(this._x);return t=397*t^M(this._y),t=397*t^M(this._z),t}jb(){return[this._x,this._y,this._z]}toArray(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[b]=this._x,t[b+1]=this._y,t[b+2]=this._z,this}ZJ(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return a.FromArrayToRef(t,b,this),this}toQuaternion(){return u.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this._isDirty=!0,this}addInPlaceFromFloats(t,b,Z){return this._x+=t,this._y+=b,this._z+=Z,this._isDirty=!0,this}add(t){return new a(this._x+t._x,this._y+t._y,this._z+t._z)}addToRef(t,b){return b._x=this._x+t._x,b._y=this._y+t._y,b._z=this._z+t._z,b._isDirty=!0,b}XI(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._isDirty=!0,this}SZ(t){return new a(this._x-t._x,this._y-t._y,this._z-t._z)}subtractToRef(t,b){return this.subtractFromFloatsToRef(t._x,t._y,t._z,b)}subtractFromFloats(t,b,Z){return new a(this._x-t,this._y-b,this._z-Z)}subtractFromFloatsToRef(t,b,Z,J){return J._x=this._x-t,J._y=this._y-b,J._z=this._z-Z,J._isDirty=!0,J}negate(){return new a(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(t){return t._x=-1*this._x,t._y=-1*this._y,t._z=-1*this._z,t._isDirty=!0,t}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._isDirty=!0,this}scale(t){return new a(this._x*t,this._y*t,this._z*t)}scaleToRef(t,b){return b._x=this._x*t,b._y=this._y*t,b._z=this._z*t,b._isDirty=!0,b}getNormalToRef(t){const b=this.length();let Z=Math.acos(this._y/b);const J=Math.atan2(this._z,this._x);Z>Math.PI/2?Z-=Math.PI/2:Z+=Math.PI/2;const S=b*Math.sin(Z)*Math.cos(J),P=b*Math.cos(Z),v=b*Math.sin(Z)*Math.sin(J);return t.set(S,P,v),t}applyRotationQuaternionToRef(t,b){const Z=this._x,J=this._y,S=this._z,P=t._x,v=t._y,h=t._z,C=t._w,Y=2*(v*S-h*J),g=2*(h*Z-P*S),I=2*(P*J-v*Z);return b._x=Z+C*Y+v*I-h*g,b._y=J+C*g+h*Y-P*I,b._z=S+C*I+P*g-v*Y,b._isDirty=!0,b}applyRotationQuaternionInPlace(t){return this.applyRotationQuaternionToRef(t,this)}applyRotationQuaternion(t){return this.applyRotationQuaternionToRef(t,new a)}scaleAndAddToRef(t,b){return b._x+=this._x*t,b._y+=this._y*t,b._z+=this._z*t,b._isDirty=!0,b}projectOnPlane(t,b){return this.projectOnPlaneToRef(t,b,new a)}projectOnPlaneToRef(t,b,Z){const J=t.normal,S=t.d,P=U.JZ[0];this.subtractToRef(b,P),P.normalize();const v=a.Dot(P,J);if(Math.abs(v)<1e-10)Z.Lb(1/0);else{const t=-(a.Dot(b,J)+S)/v,h=P.scaleInPlace(t);b.addToRef(h,Z)}return Z}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z}equalsWithEpsilon(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.e;return t&&(0,C.WithinEpsilon)(this._x,t._x,b)&&(0,C.WithinEpsilon)(this._y,t._y,b)&&(0,C.WithinEpsilon)(this._z,t._z,b)}equalsToFloats(t,b,Z){return this._x===t&&this._y===b&&this._z===Z}multiplyInPlace(t){return this._x*=t._x,this._y*=t._y,this._z*=t._z,this._isDirty=!0,this}multiply(t){return this.multiplyByFloats(t._x,t._y,t._z)}multiplyToRef(t,b){return b._x=this._x*t._x,b._y=this._y*t._y,b._z=this._z*t._z,b._isDirty=!0,b}multiplyByFloats(t,b,Z){return new a(this._x*t,this._y*b,this._z*Z)}divide(t){return new a(this._x/t._x,this._y/t._y,this._z/t._z)}divideToRef(t,b){return b._x=this._x/t._x,b._y=this._y/t._y,b._z=this._z/t._z,b._isDirty=!0,b}divideInPlace(t){return this._x=this._x/t._x,this._y=this._y/t._y,this._z=this._z/t._z,this._isDirty=!0,this}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t._x,t._y,t._z)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t._x,t._y,t._z)}minimizeInPlaceFromFloats(t,b,Z){return t<this._x&&(this.x=t),b<this._y&&(this.y=b),Z<this._z&&(this.z=Z),this}maximizeInPlaceFromFloats(t,b,Z){return t>this._x&&(this.x=t),b>this._y&&(this.y=b),Z>this._z&&(this.z=Z),this}isNonUniformWithinEpsilon(t){const b=Math.abs(this._x),Z=Math.abs(this._y);if(!(0,C.WithinEpsilon)(b,Z,t))return!0;const J=Math.abs(this._z);return!(0,C.WithinEpsilon)(b,J,t)||!(0,C.WithinEpsilon)(Z,J,t)}get isNonUniform(){const t=Math.abs(this._x);if(t!==Math.abs(this._y))return!0;return t!==Math.abs(this._z)}floorToRef(t){return t._x=Math.floor(this._x),t._y=Math.floor(this._y),t._z=Math.floor(this._z),t._isDirty=!0,t}floor(){return new a(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(t){return t._x=this._x-Math.floor(this._x),t._y=this._y-Math.floor(this._y),t._z=this._z-Math.floor(this._z),t._isDirty=!0,t}fract(){return new a(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(t){if("xyz"===(t=t.toLowerCase()))return this;const b=U.JZ[0].S(this);return this.x=b[t[0]],this.y=b[t[1]],this.z=b[t[2]],this}rotateByQuaternionToRef(t,b){return t.toRotationMatrix(U.Matrix[0]),a.TransformCoordinatesToRef(this,U.Matrix[0],b),b}rotateByQuaternionAroundPointToRef(t,b,Z){return this.subtractToRef(b,U.JZ[0]),U.JZ[0].rotateByQuaternionToRef(t,U.JZ[0]),b.addToRef(U.JZ[0],Z),Z}cross(t){return a.CrossToRef(this,t,new a)}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){return this.normalizeToRef(new a)}normalizeToRef(t){const b=this.length();return 0===b||1===b?(t._x=this._x,t._y=this._y,t._z=this._z,t._isDirty=!0,t):this.scaleToRef(1/b,t)}clone(){return new a(this._x,this._y,this._z)}S(t){return this.Ab(t._x,t._y,t._z)}Ab(t,b,Z){return this._x=t,this._y=b,this._z=Z,this._isDirty=!0,this}set(t,b,Z){return this.Ab(t,b,Z)}Lb(t){return this._x=this._y=this._z=t,this._isDirty=!0,this}static GetClipFactor(t,b,Z,J){const S=a.Dot(t,Z);return(S-J)/(S-a.Dot(b,Z))}static GetAngleBetweenVectors(t,b,Z){const J=t.normalizeToRef(U.JZ[1]),S=b.normalizeToRef(U.JZ[2]);let P=a.Dot(J,S);P=(0,C.Clamp)(P,-1,1);const v=Math.acos(P),h=U.JZ[3];return a.CrossToRef(J,S,h),a.Dot(h,Z)>0?isNaN(v)?0:v:isNaN(v)?-Math.PI:-Math.acos(P)}static GetAngleBetweenVectorsOnPlane(t,b,Z){U.JZ[0].S(t);const J=U.JZ[0];U.JZ[1].S(b);const S=U.JZ[1];U.JZ[2].S(Z);const P=U.JZ[2],v=U.JZ[3],h=U.JZ[4];J.normalize(),S.normalize(),P.normalize(),a.CrossToRef(P,J,v),a.CrossToRef(v,P,h);const Y=Math.atan2(a.Dot(S,v),a.Dot(S,h));return(0,C.NormalizeRadians)(Y)}static PitchYawRollToMoveBetweenPointsToRef(t,b,Z){const J=E.JZ[0];return b.subtractToRef(t,J),Z._y=Math.atan2(J.x,J.z)||0,Z._x=Math.atan2(Math.sqrt(J.x**2+J.z**2),J.y)||0,Z._z=0,Z._isDirty=!0,Z}static PitchYawRollToMoveBetweenPoints(t,b){const Z=a.Zero();return a.PitchYawRollToMoveBetweenPointsToRef(t,b,Z)}static SlerpToRef(t,b,Z,S){Z=(0,C.Clamp)(Z,0,1);const P=U.JZ[0],v=U.JZ[1];P.S(t);const h=P.length();P.normalizeFromLength(h),v.S(b);const Y=v.length();v.normalizeFromLength(Y);const g=a.Dot(P,v);let I,r;if(g<1-J.e){const t=Math.acos(g),b=1/Math.sin(t);I=Math.sin((1-Z)*t)*b,r=Math.sin(Z*t)*b}else I=1-Z,r=Z;return P.scaleInPlace(I),v.scaleInPlace(r),S.S(P).addInPlace(v),S.scaleInPlace((0,C.Lerp)(h,Y,Z)),S}static SmoothToRef(t,b,Z,J,S){return a.SlerpToRef(t,b,0===J?1:Z/J,S),S}static CZ(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new a(t[b],t[b+1],t[b+2])}static FromFloatArray(t,b){return a.CZ(t,b)}static FromArrayToRef(t,b,Z){return Z._x=t[b],Z._y=t[b+1],Z._z=t[b+2],Z._isDirty=!0,Z}static FromFloatArrayToRef(t,b,Z){return a.FromArrayToRef(t,b,Z)}static FromFloatsToRef(t,b,Z,J){return J.Ab(t,b,Z),J}static Zero(){return new a(0,0,0)}static One(){return new a(1,1,1)}static Up(){return new a(0,1,0)}static get UpReadOnly(){return a._UpReadOnly}static get DownReadOnly(){return a._DownReadOnly}static get RightReadOnly(){return a._RightReadOnly}static get LeftReadOnly(){return a._LeftReadOnly}static get LeftHandedForwardReadOnly(){return a._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return a._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return a._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return a._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return a._ZeroReadOnly}static get OneReadOnly(){return a._OneReadOnly}static Down(){return new a(0,-1,0)}static Forward(){return new a(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new a(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new a(1,0,0)}static Left(){return new a(-1,0,0)}static Random(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new a((0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b))}static RandomToRef(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ab((0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b))}static TransformCoordinates(t,b){const Z=a.Zero();return a.TransformCoordinatesToRef(t,b,Z),Z}static TransformCoordinatesToRef(t,b,Z){return a.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,b,Z),Z}static TransformCoordinatesFromFloatsToRef(t,b,Z,J,S){const P=J.m,v=t*P[0]+b*P[4]+Z*P[8]+P[12],h=t*P[1]+b*P[5]+Z*P[9]+P[13],C=t*P[2]+b*P[6]+Z*P[10]+P[14],Y=1/(t*P[3]+b*P[7]+Z*P[11]+P[15]);return S._x=v*Y,S._y=h*Y,S._z=C*Y,S._isDirty=!0,S}static TransformNormal(t,b){const Z=a.Zero();return a.TransformNormalToRef(t,b,Z),Z}static TransformNormalToRef(t,b,Z){return this.TransformNormalFromFloatsToRef(t._x,t._y,t._z,b,Z),Z}static TransformNormalFromFloatsToRef(t,b,Z,J,S){const P=J.m;return S._x=t*P[0]+b*P[4]+Z*P[8],S._y=t*P[1]+b*P[5]+Z*P[9],S._z=t*P[2]+b*P[6]+Z*P[10],S._isDirty=!0,S}static CatmullRom(t,b,Z,J,S){const P=S*S,v=S*P,h=.5*(2*b._x+(-t._x+Z._x)*S+(2*t._x-5*b._x+4*Z._x-J._x)*P+(-t._x+3*b._x-3*Z._x+J._x)*v),C=.5*(2*b._y+(-t._y+Z._y)*S+(2*t._y-5*b._y+4*Z._y-J._y)*P+(-t._y+3*b._y-3*Z._y+J._y)*v),Y=.5*(2*b._z+(-t._z+Z._z)*S+(2*t._z-5*b._z+4*Z._z-J._z)*P+(-t._z+3*b._z-3*Z._z+J._z)*v);return new a(h,C,Y)}static Clamp(t,b,Z){const J=new a;return a.ClampToRef(t,b,Z,J),J}static ClampToRef(t,b,Z,J){let S=t._x;S=S>Z._x?Z._x:S,S=S<b._x?b._x:S;let P=t._y;P=P>Z._y?Z._y:P,P=P<b._y?b._y:P;let v=t._z;return v=v>Z._z?Z._z:v,v=v<b._z?b._z:v,J.Ab(S,P,v),J}static CheckExtends(t,b,Z){b.minimizeInPlace(t),Z.maximizeInPlace(t)}static Hermite(t,b,Z,J,S){const P=S*S,v=S*P,h=2*v-3*P+1,C=-2*v+3*P,Y=v-2*P+S,g=v-P,I=t._x*h+Z._x*C+b._x*Y+J._x*g,r=t._y*h+Z._y*C+b._y*Y+J._y*g,M=t._z*h+Z._z*C+b._z*Y+J._z*g;return new a(I,r,M)}static Hermite1stDerivative(t,b,Z,J,S){const P=new a;return this.Hermite1stDerivativeToRef(t,b,Z,J,S,P),P}static Hermite1stDerivativeToRef(t,b,Z,J,S,P){const v=S*S;return P._x=6*(v-S)*t._x+(3*v-4*S+1)*b._x+6*(-v+S)*Z._x+(3*v-2*S)*J._x,P._y=6*(v-S)*t._y+(3*v-4*S+1)*b._y+6*(-v+S)*Z._y+(3*v-2*S)*J._y,P._z=6*(v-S)*t._z+(3*v-4*S+1)*b._z+6*(-v+S)*Z._z+(3*v-2*S)*J._z,P._isDirty=!0,P}static Lerp(t,b,Z){const J=new a(0,0,0);return a.LerpToRef(t,b,Z,J),J}static LerpToRef(t,b,Z,J){return J._x=t._x+(b._x-t._x)*Z,J._y=t._y+(b._y-t._y)*Z,J._z=t._z+(b._z-t._z)*Z,J._isDirty=!0,J}static Dot(t,b){return t._x*b._x+t._y*b._y+t._z*b._z}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z}static Cross(t,b){const Z=new a;return a.CrossToRef(t,b,Z),Z}static CrossToRef(t,b,Z){const J=t._y*b._z-t._z*b._y,S=t._z*b._x-t._x*b._z,P=t._x*b._y-t._y*b._x;return Z.Ab(J,S,P),Z}static Normalize(t){const b=a.Zero();return a.NormalizeToRef(t,b),b}static NormalizeToRef(t,b){return t.normalizeToRef(b),b}static Project(t,b,Z,J){const S=new a;return a.ProjectToRef(t,b,Z,J,S),S}static ProjectToRef(t,b,Z,J,S){var P;const v=J.width,C=J.height,Y=J.x,g=J.y,I=U.Matrix[1],r=null===(P=h.e.LastCreatedEngine)||void 0===P?void 0:P.isNDCHalfZRange,M=r?1:.5,T=r?0:.5;l.FromValuesToRef(v/2,0,0,0,0,-C/2,0,0,0,0,M,0,Y+v/2,C/2+g,T,1,I);const k=U.Matrix[0];return b.multiplyToRef(Z,k),k.multiplyToRef(I,k),a.TransformCoordinatesToRef(t,k,S),S}static Reflect(t,b){return this.ReflectToRef(t,b,new a)}static ReflectToRef(t,b,Z){const J=E.JZ[0];return J.S(b).scaleInPlace(2*a.Dot(t,b)),Z.S(t).XI(J)}static _UnprojectFromInvertedMatrixToRef(t,b,Z){a.TransformCoordinatesToRef(t,b,Z);const J=b.m,S=t._x*J[3]+t._y*J[7]+t._z*J[11]+J[15];return(0,C.WithinEpsilon)(S,1)&&Z.scaleInPlace(1/S),Z}static UnprojectFromTransform(t,b,Z,J,S){return this.Unproject(t,b,Z,J,S,l.IdentityReadOnly)}static Unproject(t,b,Z,J,S,P){const v=new a;return a.UnprojectToRef(t,b,Z,J,S,P,v),v}static UnprojectToRef(t,b,Z,J,S,P,v){return a.UnprojectFloatsToRef(t._x,t._y,t._z,b,Z,J,S,P,v),v}static UnprojectFloatsToRef(t,b,Z,J,S,P,v,C,Y){var g;const I=U.Matrix[0];P.multiplyToRef(v,I),I.multiplyToRef(C,I),I.invert();const r=U.JZ[0];return r.x=t/J*2-1,r.y=-(b/S*2-1),null!==(g=h.e.LastCreatedEngine)&&void 0!==g&&g.isNDCHalfZRange?r.z=Z:r.z=2*Z-1,a._UnprojectFromInvertedMatrixToRef(r,I,Y),Y}static Minimize(t,b){const Z=new a;return Z.S(t),Z.minimizeInPlace(b),Z}static Maximize(t,b){const Z=new a;return Z.S(t),Z.maximizeInPlace(b),Z}static Distance(t,b){return Math.sqrt(a.DistanceSquared(t,b))}static DistanceSquared(t,b){const Z=t._x-b._x,J=t._y-b._y,S=t._z-b._z;return Z*Z+J*J+S*S}static ProjectOnTriangleToRef(t,b,Z,S,P){const v=U.JZ[0],h=U.JZ[1],Y=U.JZ[2],g=U.JZ[3],I=U.JZ[4];Z.subtractToRef(b,v),S.subtractToRef(b,h),S.subtractToRef(Z,Y);const r=v.length(),M=h.length(),T=Y.length();if(r<J.e||M<J.e||T<J.e)return P.S(b),a.Distance(t,b);t.subtractToRef(b,I),a.CrossToRef(v,h,g);const k=g.length();if(k<J.e)return P.S(b),a.Distance(t,b);g.normalizeFromLength(k);let u=I.length();if(u<J.e)return P.S(b),0;I.normalizeFromLength(u);const l=a.Dot(g,I),E=U.JZ[5],c=U.JZ[6];E.S(g).scaleInPlace(-u*l),c.S(t).addInPlace(E);const H=U.JZ[4],o=U.JZ[5],O=U.JZ[7],p=U.JZ[8];H.S(v).scaleInPlace(1/r),p.S(h).scaleInPlace(1/M),H.addInPlace(p).scaleInPlace(-1),o.S(v).scaleInPlace(-1/r),p.S(Y).scaleInPlace(1/T),o.addInPlace(p).scaleInPlace(-1),O.S(Y).scaleInPlace(-1/T),p.S(h).scaleInPlace(-1/M),O.addInPlace(p).scaleInPlace(-1);const e=U.JZ[9];let W;e.S(c).XI(b),a.CrossToRef(H,e,p),W=a.Dot(p,g);const j=W;e.S(c).XI(Z),a.CrossToRef(o,e,p),W=a.Dot(p,g);const V=W;e.S(c).XI(S),a.CrossToRef(O,e,p),W=a.Dot(p,g);const n=W,y=U.JZ[10];let d,s;j>0&&V<0?(y.S(v),d=b,s=Z):V>0&&n<0?(y.S(Y),d=Z,s=S):(y.S(h).scaleInPlace(-1),d=S,s=b);const q=U.JZ[9],Q=U.JZ[4];d.subtractToRef(c,p),s.subtractToRef(c,q),a.CrossToRef(p,q,Q);if(!(a.Dot(Q,g)<0))return P.S(c),Math.abs(u*l);const N=U.JZ[5];a.CrossToRef(y,Q,N),N.normalize();const A=U.JZ[9];A.S(d).XI(c);const K=A.length();if(K<J.e)return P.S(d),a.Distance(t,d);A.normalizeFromLength(K);const L=a.Dot(N,A),F=U.JZ[7];F.S(c).addInPlace(N.scaleInPlace(K*L)),p.S(F).XI(d),u=y.length(),y.normalizeFromLength(u);let B=a.Dot(p,y)/Math.max(u,J.e);return B=(0,C.Clamp)(B,0,1),F.S(d).addInPlace(y.scaleInPlace(B*u)),P.S(F),a.Distance(t,F)}static Center(t,b){return a.CenterToRef(t,b,a.Zero())}static CenterToRef(t,b,Z){return Z.Ab((t._x+b._x)/2,(t._y+b._y)/2,(t._z+b._z)/2)}static RotationFromAxis(t,b,Z){const J=new a;return a.RotationFromAxisToRef(t,b,Z,J),J}static RotationFromAxisToRef(t,b,Z,J){const S=U.Quaternion[0];return u.RotationQuaternionFromAxisToRef(t,b,Z,S),S.toEulerAnglesToRef(J),J}}a._V8PerformanceHack=new a(.5,.5,.5),a._UpReadOnly=a.Up(),a._DownReadOnly=a.Down(),a._LeftHandedForwardReadOnly=a.Forward(!1),a._RightHandedForwardReadOnly=a.Forward(!0),a._LeftHandedBackwardReadOnly=a.Backward(!1),a._RightHandedBackwardReadOnly=a.Backward(!0),a._RightReadOnly=a.Right(),a._LeftReadOnly=a.Left(),a._ZeroReadOnly=a.Zero(),a._OneReadOnly=a.One(),Object.defineProperties(a.prototype,{dimension:{value:[3]},rank:{value:1}});class k{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}get w(){return this._w}set w(t){this._w=t,this._isDirty=!0}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=t,this._y=b,this._z=Z,this._w=J}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let t=M(this._x);return t=397*t^M(this._y),t=397*t^M(this._z),t=397*t^M(this._w),t}jb(){return[this._x,this._y,this._z,this._w]}toArray(t,b){return void 0===b&&(b=0),t[b]=this._x,t[b+1]=this._y,t[b+2]=this._z,t[b+3]=this._w,this}ZJ(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k.FromArrayToRef(t,b,this),this}addInPlace(t){return this.x+=t._x,this.y+=t._y,this.z+=t._z,this.w+=t._w,this}addInPlaceFromFloats(t,b,Z,J){return this.x+=t,this.y+=b,this.z+=Z,this.w+=J,this}add(t){return new k(this._x+t.x,this._y+t.y,this._z+t.z,this._w+t.w)}addToRef(t,b){return b.x=this._x+t.x,b.y=this._y+t.y,b.z=this._z+t.z,b.w=this._w+t.w,b}XI(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}SZ(t){return new k(this._x-t.x,this._y-t.y,this._z-t.z,this._w-t.w)}subtractToRef(t,b){return b.x=this._x-t.x,b.y=this._y-t.y,b.z=this._z-t.z,b.w=this._w-t.w,b}subtractFromFloats(t,b,Z,J){return new k(this._x-t,this._y-b,this._z-Z,this._w-J)}subtractFromFloatsToRef(t,b,Z,J,S){return S.x=this._x-t,S.y=this._y-b,S.z=this._z-Z,S.w=this._w-J,S}negate(){return new k(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(t){return t.x=-this._x,t.y=-this._y,t.z=-this._z,t.w=-this._w,t}scaleInPlace(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}scale(t){return new k(this._x*t,this._y*t,this._z*t,this._w*t)}scaleToRef(t,b){return b.x=this._x*t,b.y=this._y*t,b.z=this._z*t,b.w=this._w*t,b}scaleAndAddToRef(t,b){return b.x+=this._x*t,b.y+=this._y*t,b.z+=this._z*t,b.w+=this._w*t,b}equals(t){return t&&this._x===t.x&&this._y===t.y&&this._z===t.z&&this._w===t.w}equalsWithEpsilon(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.e;return t&&(0,C.WithinEpsilon)(this._x,t.x,b)&&(0,C.WithinEpsilon)(this._y,t.y,b)&&(0,C.WithinEpsilon)(this._z,t.z,b)&&(0,C.WithinEpsilon)(this._w,t.w,b)}equalsToFloats(t,b,Z,J){return this._x===t&&this._y===b&&this._z===Z&&this._w===J}multiplyInPlace(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiply(t){return new k(this._x*t.x,this._y*t.y,this._z*t.z,this._w*t.w)}multiplyToRef(t,b){return b.x=this._x*t.x,b.y=this._y*t.y,b.z=this._z*t.z,b.w=this._w*t.w,b}multiplyByFloats(t,b,Z,J){return new k(this._x*t,this._y*b,this._z*Z,this._w*J)}divide(t){return new k(this._x/t.x,this._y/t.y,this._z/t.z,this._w/t.w)}divideToRef(t,b){return b.x=this._x/t.x,b.y=this._y/t.y,b.z=this._z/t.z,b.w=this._w/t.w,b}divideInPlace(t){return this.divideToRef(t,this)}minimizeInPlace(t){return t.x<this._x&&(this.x=t.x),t.y<this._y&&(this.y=t.y),t.z<this._z&&(this.z=t.z),t.w<this._w&&(this.w=t.w),this}maximizeInPlace(t){return t.x>this._x&&(this.x=t.x),t.y>this._y&&(this.y=t.y),t.z>this._z&&(this.z=t.z),t.w>this._w&&(this.w=t.w),this}minimizeInPlaceFromFloats(t,b,Z,J){return this.x=Math.min(t,this._x),this.y=Math.min(b,this._y),this.z=Math.min(Z,this._z),this.w=Math.min(J,this._w),this}maximizeInPlaceFromFloats(t,b,Z,J){return this.x=Math.max(t,this._x),this.y=Math.max(b,this._y),this.z=Math.max(Z,this._z),this.w=Math.max(J,this._w),this}floorToRef(t){return t.x=Math.floor(this._x),t.y=Math.floor(this._y),t.z=Math.floor(this._z),t.w=Math.floor(this._w),t}floor(){return new k(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(t){return t.x=this._x-Math.floor(this._x),t.y=this._y-Math.floor(this._y),t.z=this._z-Math.floor(this._z),t.w=this._w-Math.floor(this._w),t}fract(){return new k(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){return this.normalizeToRef(new k)}normalizeToRef(t){const b=this.length();return 0===b||1===b?(t.x=this._x,t.y=this._y,t.z=this._z,t.w=this._w,t):this.scaleToRef(1/b,t)}toVector3(){return new a(this._x,this._y,this._z)}clone(){return new k(this._x,this._y,this._z,this._w)}S(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}Ab(t,b,Z,J){return this.x=t,this.y=b,this.z=Z,this.w=J,this}set(t,b,Z,J){return this.Ab(t,b,Z,J)}Lb(t){return this.x=this.y=this.z=this.w=t,this}dot(t){return this._x*t.x+this._y*t.y+this._z*t.z+this._w*t.w}static CZ(t,b){return b||(b=0),new k(t[b],t[b+1],t[b+2],t[b+3])}static FromArrayToRef(t,b,Z){return Z.x=t[b],Z.y=t[b+1],Z.z=t[b+2],Z.w=t[b+3],Z}static FromFloatArrayToRef(t,b,Z){return k.FromArrayToRef(t,b,Z),Z}static FromFloatsToRef(t,b,Z,J,S){return S.x=t,S.y=b,S.z=Z,S.w=J,S}static Zero(){return new k(0,0,0,0)}static One(){return new k(1,1,1,1)}static Random(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new k((0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b))}static RandomToRef(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Z=arguments.length>2?arguments[2]:void 0;return Z.x=(0,C.RandomRange)(t,b),Z.y=(0,C.RandomRange)(t,b),Z.z=(0,C.RandomRange)(t,b),Z.w=(0,C.RandomRange)(t,b),Z}static Clamp(t,b,Z){return k.ClampToRef(t,b,Z,new k)}static ClampToRef(t,b,Z,J){return J.x=(0,C.Clamp)(t.x,b.x,Z.x),J.y=(0,C.Clamp)(t.y,b.y,Z.y),J.z=(0,C.Clamp)(t.z,b.z,Z.z),J.w=(0,C.Clamp)(t.w,b.w,Z.w),J}static CheckExtends(t,b,Z){b.minimizeInPlace(t),Z.maximizeInPlace(t)}static get ZeroReadOnly(){return k._ZeroReadOnly}static Normalize(t){return k.NormalizeToRef(t,new k)}static NormalizeToRef(t,b){return t.normalizeToRef(b),b}static Minimize(t,b){const Z=new k;return Z.S(t),Z.minimizeInPlace(b),Z}static Maximize(t,b){const Z=new k;return Z.S(t),Z.maximizeInPlace(b),Z}static Distance(t,b){return Math.sqrt(k.DistanceSquared(t,b))}static DistanceSquared(t,b){const Z=t.x-b.x,J=t.y-b.y,S=t.z-b.z,P=t.w-b.w;return Z*Z+J*J+S*S+P*P}static Center(t,b){return k.CenterToRef(t,b,new k)}static CenterToRef(t,b,Z){return Z.x=(t.x+b.x)/2,Z.y=(t.y+b.y)/2,Z.z=(t.z+b.z)/2,Z.w=(t.w+b.w)/2,Z}static TransformCoordinates(t,b){return k.TransformCoordinatesToRef(t,b,new k)}static TransformCoordinatesToRef(t,b,Z){return k.TransformCoordinatesFromFloatsToRef(t._x,t._y,t._z,b,Z),Z}static TransformCoordinatesFromFloatsToRef(t,b,Z,J,S){const P=J.m,v=t*P[0]+b*P[4]+Z*P[8]+P[12],h=t*P[1]+b*P[5]+Z*P[9]+P[13],C=t*P[2]+b*P[6]+Z*P[10]+P[14],Y=t*P[3]+b*P[7]+Z*P[11]+P[15];return S.x=v,S.y=h,S.z=C,S.w=Y,S}static TransformNormal(t,b){return k.TransformNormalToRef(t,b,new k)}static TransformNormalToRef(t,b,Z){const J=b.m,S=t.x*J[0]+t.y*J[4]+t.z*J[8],P=t.x*J[1]+t.y*J[5]+t.z*J[9],v=t.x*J[2]+t.y*J[6]+t.z*J[10];return Z.x=S,Z.y=P,Z.z=v,Z.w=t.w,Z}static TransformNormalFromFloatsToRef(t,b,Z,J,S,P){const v=S.m;return P.x=t*v[0]+b*v[4]+Z*v[8],P.y=t*v[1]+b*v[5]+Z*v[9],P.z=t*v[2]+b*v[6]+Z*v[10],P.w=J,P}static FromVector3(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new k(t._x,t._y,t._z,b)}static Dot(t,b){return t.x*b.x+t.y*b.y+t.z*b.z+t.w*b.w}}k._V8PerformanceHack=new k(.5,.5,.5,.5),k._ZeroReadOnly=k.Zero(),Object.defineProperties(k.prototype,{dimension:{value:[4]},rank:{value:1}});class u{get x(){return this._x}set x(t){this._x=t,this._isDirty=!0}get y(){return this._y}set y(t){this._y=t,this._isDirty=!0}get z(){return this._z}set z(t){this._z=t,this._isDirty=!0}get w(){return this._w}set w(t){this._w=t,this._isDirty=!0}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=t,this._y=b,this._z=Z,this._w=J}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let t=M(this._x);return t=397*t^M(this._y),t=397*t^M(this._z),t=397*t^M(this._w),t}jb(){return[this._x,this._y,this._z,this._w]}toArray(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[b]=this._x,t[b+1]=this._y,t[b+2]=this._z,t[b+3]=this._w,this}ZJ(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(t,b,this)}equals(t){return t&&this._x===t._x&&this._y===t._y&&this._z===t._z&&this._w===t._w}equalsWithEpsilon(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.e;return t&&(0,C.WithinEpsilon)(this._x,t._x,b)&&(0,C.WithinEpsilon)(this._y,t._y,b)&&(0,C.WithinEpsilon)(this._z,t._z,b)&&(0,C.WithinEpsilon)(this._w,t._w,b)}isApprox(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.e;return t&&((0,C.WithinEpsilon)(this._x,t._x,b)&&(0,C.WithinEpsilon)(this._y,t._y,b)&&(0,C.WithinEpsilon)(this._z,t._z,b)&&(0,C.WithinEpsilon)(this._w,t._w,b)||(0,C.WithinEpsilon)(this._x,-t._x,b)&&(0,C.WithinEpsilon)(this._y,-t._y,b)&&(0,C.WithinEpsilon)(this._z,-t._z,b)&&(0,C.WithinEpsilon)(this._w,-t._w,b))}clone(){return new u(this._x,this._y,this._z,this._w)}S(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._w=t._w,this._isDirty=!0,this}Ab(t,b,Z,J){return this._x=t,this._y=b,this._z=Z,this._w=J,this._isDirty=!0,this}set(t,b,Z,J){return this.Ab(t,b,Z,J)}Lb(t){return this.Ab(t,t,t,t)}add(t){return new u(this._x+t._x,this._y+t._y,this._z+t._z,this._w+t._w)}addInPlace(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this._w+=t._w,this._isDirty=!0,this}addToRef(t,b){return b._x=this._x+t._x,b._y=this._y+t._y,b._z=this._z+t._z,b._w=this._w+t._w,b._isDirty=!0,b}addInPlaceFromFloats(t,b,Z,J){return this._x+=t,this._y+=b,this._z+=Z,this._w+=J,this._isDirty=!0,this}subtractToRef(t,b){return b._x=this._x-t._x,b._y=this._y-t._y,b._z=this._z-t._z,b._w=this._w-t._w,b._isDirty=!0,b}subtractFromFloats(t,b,Z,J){return this.subtractFromFloatsToRef(t,b,Z,J,new u)}subtractFromFloatsToRef(t,b,Z,J,S){return S._x=this._x-t,S._y=this._y-b,S._z=this._z-Z,S._w=this._w-J,S._isDirty=!0,S}SZ(t){return new u(this._x-t._x,this._y-t._y,this._z-t._z,this._w-t._w)}XI(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this._w-=t._w,this._isDirty=!0,this}scale(t){return new u(this._x*t,this._y*t,this._z*t,this._w*t)}scaleToRef(t,b){return b._x=this._x*t,b._y=this._y*t,b._z=this._z*t,b._w=this._w*t,b._isDirty=!0,b}scaleInPlace(t){return this._x*=t,this._y*=t,this._z*=t,this._w*=t,this._isDirty=!0,this}scaleAndAddToRef(t,b){return b._x+=this._x*t,b._y+=this._y*t,b._z+=this._z*t,b._w+=this._w*t,b._isDirty=!0,b}multiply(t){const b=new u(0,0,0,1);return this.multiplyToRef(t,b),b}multiplyToRef(t,b){const Z=this._x*t._w+this._y*t._z-this._z*t._y+this._w*t._x,J=-this._x*t._z+this._y*t._w+this._z*t._x+this._w*t._y,S=this._x*t._y-this._y*t._x+this._z*t._w+this._w*t._z,P=-this._x*t._x-this._y*t._y-this._z*t._z+this._w*t._w;return b.Ab(Z,J,S,P),b}multiplyInPlace(t){return this.multiplyToRef(t,this)}multiplyByFloats(t,b,Z,J){return this._x*=t,this._y*=b,this._z*=Z,this._w*=J,this._isDirty=!0,this}divide(t){throw new ReferenceError("Can not divide a quaternion")}divideToRef(t,b){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(t){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new u)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(t){return t._x=-this._x,t._y=-this._y,t._z=-this._z,t._w=-this._w,t._isDirty=!0,t}equalsToFloats(t,b,Z,J){return this._x===t&&this._y===b&&this._z===Z&&this._w===J}floorToRef(t){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(t){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(t){return t.Ab(-this._x,-this._y,-this._z,this._w),t}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new u(-this._x,-this._y,-this._z,this._w)}invert(){const t=this.conjugate(),b=this.lengthSquared();return 0==b||1==b||t.scaleInPlace(1/b),t}invertInPlace(){this.conjugateInPlace();const t=this.lengthSquared();return 0==t||1==t||this.scaleInPlace(1/t),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(t){return 0===t||1===t?this:this.scaleInPlace(1/t)}normalizeToNew(){const t=new u(0,0,0,1);return this.normalizeToRef(t),t}normalizeToRef(t){const b=this.length();return 0===b||1===b?t.Ab(this._x,this._y,this._z,this._w):this.scaleToRef(1/b,t)}toEulerAngles(){const t=a.Zero();return this.toEulerAnglesToRef(t),t}toEulerAnglesToRef(t){const b=this._z,Z=this._x,J=this._y,S=this._w,P=J*b-Z*S,v=.4999999;if(P<-v)t._y=2*Math.atan2(J,S),t._x=Math.PI/2,t._z=0,t._isDirty=!0;else if(P>v)t._y=2*Math.atan2(J,S),t._x=-Math.PI/2,t._z=0,t._isDirty=!0;else{const v=S*S,h=b*b,C=Z*Z,Y=J*J;t._z=Math.atan2(2*(Z*J+b*S),-h-C+Y+v),t._x=Math.asin(-2*P),t._y=Math.atan2(2*(b*Z+J*S),h-C-Y+v),t._isDirty=!0}return t}toAlphaBetaGammaToRef(t){const b=this._z,Z=this._x,J=this._y,S=this._w,P=Math.sqrt(Z*Z+J*J),v=Math.sqrt(b*b+S*S),h=2*Math.atan2(P,v),C=2*Math.atan2(b,S),Y=2*Math.atan2(J,Z),g=(C+Y)/2,I=(C-Y)/2;return t.set(I,h,g),t}toRotationMatrix(t){return l.FromQuaternionToRef(this,t),t}fromRotationMatrix(t){return u.FromRotationMatrixToRef(t,this),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}toAxisAngle(){const t=a.Zero();return{axis:t,angle:this.toAxisAngleToRef(t)}}toAxisAngleToRef(t){let b=0;const Z=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),J=this._w;return Z>0?(b=2*Math.atan2(Z,J),t.set(this._x/Z,this._y/Z,this._z/Z)):(b=0,t.set(1,0,0)),b}static FromRotationMatrix(t){const b=new u;return u.FromRotationMatrixToRef(t,b),b}static FromRotationMatrixToRef(t,b){const Z=t.m,J=Z[0],S=Z[4],P=Z[8],v=Z[1],h=Z[5],C=Z[9],Y=Z[2],g=Z[6],I=Z[10],r=J+h+I;let M;return r>0?(M=.5/Math.sqrt(r+1),b._w=.25/M,b._x=(g-C)*M,b._y=(P-Y)*M,b._z=(v-S)*M,b._isDirty=!0):J>h&&J>I?(M=2*Math.sqrt(1+J-h-I),b._w=(g-C)/M,b._x=.25*M,b._y=(S+v)/M,b._z=(P+Y)/M,b._isDirty=!0):h>I?(M=2*Math.sqrt(1+h-J-I),b._w=(P-Y)/M,b._x=(S+v)/M,b._y=.25*M,b._z=(C+g)/M,b._isDirty=!0):(M=2*Math.sqrt(1+I-J-h),b._w=(v-S)/M,b._x=(P+Y)/M,b._y=(C+g)/M,b._z=.25*M,b._isDirty=!0),b}static Dot(t,b){return t._x*b._x+t._y*b._y+t._z*b._z+t._w*b._w}static AreClose(t,b){let Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const J=u.Dot(t,b);return 1-J*J<=Z}static SmoothToRef(t,b,Z,J,S){let P=0===J?1:Z/J;return P=(0,C.Clamp)(P,0,1),u.SlerpToRef(t,b,P,S),S}static Zero(){return new u(0,0,0,0)}static Inverse(t){return new u(-t._x,-t._y,-t._z,t._w)}static InverseToRef(t,b){return b.set(-t._x,-t._y,-t._z,t._w),b}static Identity(){return new u(0,0,0,1)}static IsIdentity(t){return t&&0===t._x&&0===t._y&&0===t._z&&1===t._w}static RotationAxis(t,b){return u.RotationAxisToRef(t,b,new u)}static RotationAxisToRef(t,b,Z){Z._w=Math.cos(b/2);const J=Math.sin(b/2)/t.length();return Z._x=t._x*J,Z._y=t._y*J,Z._z=t._z*J,Z._isDirty=!0,Z}static CZ(t,b){return b||(b=0),new u(t[b],t[b+1],t[b+2],t[b+3])}static FromArrayToRef(t,b,Z){return Z._x=t[b],Z._y=t[b+1],Z._z=t[b+2],Z._w=t[b+3],Z._isDirty=!0,Z}static FromFloatsToRef(t,b,Z,J,S){return S.Ab(t,b,Z,J),S}static FromEulerAngles(t,b,Z){const J=new u;return u.RotationYawPitchRollToRef(b,t,Z,J),J}static FromEulerAnglesToRef(t,b,Z,J){return u.RotationYawPitchRollToRef(b,t,Z,J),J}static FromEulerVector(t){const b=new u;return u.RotationYawPitchRollToRef(t._y,t._x,t._z,b),b}static FromEulerVectorToRef(t,b){return u.RotationYawPitchRollToRef(t._y,t._x,t._z,b),b}static FromUnitVectorsToRef(t,b,Z){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:J.e;const P=a.Dot(t,b)+1;return P<S?Math.abs(t.x)>Math.abs(t.z)?Z.set(-t.y,t.x,0,0):Z.set(0,-t.z,t.y,0):(a.CrossToRef(t,b,E.JZ[0]),Z.set(E.JZ[0].x,E.JZ[0].y,E.JZ[0].z,P)),Z.normalize()}static RotationYawPitchRoll(t,b,Z){const J=new u;return u.RotationYawPitchRollToRef(t,b,Z,J),J}static RotationYawPitchRollToRef(t,b,Z,J){const S=.5*Z,P=.5*b,v=.5*t,h=Math.sin(S),C=Math.cos(S),Y=Math.sin(P),g=Math.cos(P),I=Math.sin(v),r=Math.cos(v);return J._x=r*Y*C+I*g*h,J._y=I*g*C-r*Y*h,J._z=r*g*h-I*Y*C,J._w=r*g*C+I*Y*h,J._isDirty=!0,J}static RotationAlphaBetaGamma(t,b,Z){const J=new u;return u.RotationAlphaBetaGammaToRef(t,b,Z,J),J}static RotationAlphaBetaGammaToRef(t,b,Z,J){const S=.5*(Z+t),P=.5*(Z-t),v=.5*b;return J._x=Math.cos(P)*Math.sin(v),J._y=Math.sin(P)*Math.sin(v),J._z=Math.sin(S)*Math.cos(v),J._w=Math.cos(S)*Math.cos(v),J._isDirty=!0,J}static RotationQuaternionFromAxis(t,b,Z){const J=new u(0,0,0,0);return u.RotationQuaternionFromAxisToRef(t,b,Z,J),J}static RotationQuaternionFromAxisToRef(t,b,Z,J){const S=U.Matrix[0];return t=t.normalizeToRef(U.JZ[0]),b=b.normalizeToRef(U.JZ[1]),Z=Z.normalizeToRef(U.JZ[2]),l.FromXYZAxesToRef(t,b,Z,S),u.FromRotationMatrixToRef(S,J),J}static FromLookDirectionLH(t,b){const Z=new u;return u.FromLookDirectionLHToRef(t,b,Z),Z}static FromLookDirectionLHToRef(t,b,Z){const J=U.Matrix[0];return l.LookDirectionLHToRef(t,b,J),u.FromRotationMatrixToRef(J,Z),Z}static FromLookDirectionRH(t,b){const Z=new u;return u.FromLookDirectionRHToRef(t,b,Z),Z}static FromLookDirectionRHToRef(t,b,Z){const J=U.Matrix[0];return l.LookDirectionRHToRef(t,b,J),u.FromRotationMatrixToRef(J,Z)}static Slerp(t,b,Z){const J=u.Identity();return u.SlerpToRef(t,b,Z,J),J}static SlerpToRef(t,b,Z,J){let S,P,v=t._x*b._x+t._y*b._y+t._z*b._z+t._w*b._w,h=!1;if(v<0&&(h=!0,v=-v),v>.999999)P=1-Z,S=h?-Z:Z;else{const t=Math.acos(v),b=1/Math.sin(t);P=Math.sin((1-Z)*t)*b,S=h?-Math.sin(Z*t)*b:Math.sin(Z*t)*b}return J._x=P*t._x+S*b._x,J._y=P*t._y+S*b._y,J._z=P*t._z+S*b._z,J._w=P*t._w+S*b._w,J._isDirty=!0,J}static Hermite(t,b,Z,J,S){const P=S*S,v=S*P,h=2*v-3*P+1,C=-2*v+3*P,Y=v-2*P+S,g=v-P,I=t._x*h+Z._x*C+b._x*Y+J._x*g,r=t._y*h+Z._y*C+b._y*Y+J._y*g,M=t._z*h+Z._z*C+b._z*Y+J._z*g,T=t._w*h+Z._w*C+b._w*Y+J._w*g;return new u(I,r,M,T)}static Hermite1stDerivative(t,b,Z,J,S){const P=new u;return this.Hermite1stDerivativeToRef(t,b,Z,J,S,P),P}static Hermite1stDerivativeToRef(t,b,Z,J,S,P){const v=S*S;return P._x=6*(v-S)*t._x+(3*v-4*S+1)*b._x+6*(-v+S)*Z._x+(3*v-2*S)*J._x,P._y=6*(v-S)*t._y+(3*v-4*S+1)*b._y+6*(-v+S)*Z._y+(3*v-2*S)*J._y,P._z=6*(v-S)*t._z+(3*v-4*S+1)*b._z+6*(-v+S)*Z._z+(3*v-2*S)*J._z,P._w=6*(v-S)*t._w+(3*v-4*S+1)*b._w+6*(-v+S)*Z._w+(3*v-2*S)*J._w,P._isDirty=!0,P}static Normalize(t){const b=u.Zero();return u.NormalizeToRef(t,b),b}static NormalizeToRef(t,b){return t.normalizeToRef(b),b}static Clamp(t,b,Z){const J=new u;return u.ClampToRef(t,b,Z,J),J}static ClampToRef(t,b,Z,J){return J.Ab((0,C.Clamp)(t.x,b.x,Z.x),(0,C.Clamp)(t.y,b.y,Z.y),(0,C.Clamp)(t.z,b.z,Z.z),(0,C.Clamp)(t.w,b.w,Z.w))}static Random(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new u((0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b))}static RandomToRef(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ab((0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b),(0,C.RandomRange)(t,b))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(t,b){return Math.sqrt(u.DistanceSquared(t,b))}static DistanceSquared(t,b){const Z=t.x-b.x,J=t.y-b.y,S=t.z-b.z,P=t.w-b.w;return Z*Z+J*J+S*S+P*P}static Center(t,b){return u.CenterToRef(t,b,u.Zero())}static CenterToRef(t,b,Z){return Z.Ab((t.x+b.x)/2,(t.y+b.y)/2,(t.z+b.z)/2,(t.w+b.w)/2)}}u._V8PerformanceHack=new u(.5,.5,.5,.5),Object.defineProperties(u.prototype,{dimension:{value:[4]},rank:{value:1}});class l{static get Use64Bits(){return v.c.MatrixUse64Bits}get m(){return this.cb}markAsUpdated(){this.updateFlag=Y._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(t){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Z=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=t,this._isIdentity3x2=t||Z,this._isIdentityDirty=!this._isIdentity&&b,this._isIdentity3x2Dirty=!this._isIdentity3x2&&J}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,v.c.MatrixTrackPrecisionChange&&v.c.MatrixTrackedMatrices.push(this),this.cb=new v.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const t=this.cb;this._isIdentity=1===t[0]&&0===t[1]&&0===t[2]&&0===t[3]&&0===t[4]&&1===t[5]&&0===t[6]&&0===t[7]&&0===t[8]&&0===t[9]&&1===t[10]&&0===t[11]&&0===t[12]&&0===t[13]&&0===t[14]&&1===t[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.cb[0]||1!==this.cb[5]||1!==this.cb[15]||0!==this.cb[1]||0!==this.cb[2]||0!==this.cb[3]||0!==this.cb[4]||0!==this.cb[6]||0!==this.cb[7]||0!==this.cb[8]||0!==this.cb[9]||0!==this.cb[10]||0!==this.cb[11]||0!==this.cb[12]||0!==this.cb[13]||0!==this.cb[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const t=this.cb,b=t[0],Z=t[1],J=t[2],S=t[3],P=t[4],v=t[5],h=t[6],C=t[7],Y=t[8],g=t[9],I=t[10],r=t[11],M=t[12],T=t[13],a=t[14],k=t[15],u=I*k-a*r,l=g*k-T*r,U=g*a-T*I,E=Y*k-M*r,c=Y*a-I*M,H=Y*T-M*g;return b*+(v*u-h*l+C*U)+Z*-(P*u-h*E+C*c)+J*+(P*l-v*E+C*H)+S*-(P*U-v*c+h*H)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t)return this.cb;const Z=this.cb;for(let J=0;J<16;J++)t[b+J]=Z[J];return this}jb(){return this.cb}ZJ(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(t,b,this)}Ab(){for(var t=arguments.length,b=new Array(t),Z=0;Z<t;Z++)b[Z]=arguments[Z];return l.FromArrayToRef(b,0,this)}set(){const t=this.cb;for(let b=0;b<16;b++)t[b]=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}Lb(t){const b=this.cb;for(let Z=0;Z<16;Z++)b[Z]=t;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return l.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(t){const b=new l;return this.addToRef(t,b),b}addToRef(t,b){const Z=this.cb,J=b.cb,S=t.m;for(let P=0;P<16;P++)J[P]=Z[P]+S[P];return b.markAsUpdated(),b}addToSelf(t){const b=this.cb,Z=t.m;return b[0]+=Z[0],b[1]+=Z[1],b[2]+=Z[2],b[3]+=Z[3],b[4]+=Z[4],b[5]+=Z[5],b[6]+=Z[6],b[7]+=Z[7],b[8]+=Z[8],b[9]+=Z[9],b[10]+=Z[10],b[11]+=Z[11],b[12]+=Z[12],b[13]+=Z[13],b[14]+=Z[14],b[15]+=Z[15],this.markAsUpdated(),this}addInPlace(t){const b=this.cb,Z=t.m;for(let J=0;J<16;J++)b[J]+=Z[J];return this.markAsUpdated(),this}addInPlaceFromFloats(){const t=this.cb;for(let b=0;b<16;b++)t[b]+=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}SZ(t){const b=this.cb,Z=t.m;for(let J=0;J<16;J++)b[J]-=Z[J];return this.markAsUpdated(),this}subtractToRef(t,b){const Z=this.cb,J=t.m,S=b.cb;for(let P=0;P<16;P++)S[P]=Z[P]-J[P];return b.markAsUpdated(),b}XI(t){const b=this.cb,Z=t.m;for(let J=0;J<16;J++)b[J]-=Z[J];return this.markAsUpdated(),this}subtractFromFloats(){for(var t=arguments.length,b=new Array(t),Z=0;Z<t;Z++)b[Z]=arguments[Z];return this.subtractFromFloatsToRef(...b,new l)}subtractFromFloatsToRef(){for(var t=arguments.length,b=new Array(t),Z=0;Z<t;Z++)b[Z]=arguments[Z];const J=b.pop(),S=this.cb,P=J.cb,v=b;for(let h=0;h<16;h++)P[h]=S[h]-v[h];return J.markAsUpdated(),J}invertToRef(t){return!0===this._isIdentity?(l.IdentityToRef(t),t):(r(this,t.jb())?t.markAsUpdated():t.S(this),t)}addAtIndex(t,b){return this.cb[t]+=b,this.markAsUpdated(),this}multiplyAtIndex(t,b){return this.cb[t]*=b,this.markAsUpdated(),this}setTranslationFromFloats(t,b,Z){return this.cb[12]=t,this.cb[13]=b,this.cb[14]=Z,this.markAsUpdated(),this}addTranslationFromFloats(t,b,Z){return this.cb[12]+=t,this.cb[13]+=b,this.cb[14]+=Z,this.markAsUpdated(),this}setTranslation(t){return this.setTranslationFromFloats(t._x,t._y,t._z)}getTranslation(){return new a(this.cb[12],this.cb[13],this.cb[14])}getTranslationToRef(t){return t.x=this.cb[12],t.y=this.cb[13],t.z=this.cb[14],t}removeRotationAndScaling(){const t=this.m;return l.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t[12],t[13],t[14],t[15],this),this._updateIdentityStatus(0===t[12]&&0===t[13]&&0===t[14]&&1===t[15]),this}S(t){t.copyToArray(this.cb);const b=t;return this.updateFlag=b.updateFlag,this._updateIdentityStatus(b._isIdentity,b._isIdentityDirty,b._isIdentity3x2,b._isIdentity3x2Dirty),this}copyToArray(t){return I(this,t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(t){const b=new l;return this.multiplyToRef(t,b),b}multiplyInPlace(t){const b=this.cb,Z=t.m;for(let J=0;J<16;J++)b[J]*=Z[J];return this.markAsUpdated(),this}multiplyByFloats(){const t=this.cb;for(let b=0;b<16;b++)t[b]*=b<0||arguments.length<=b?void 0:arguments[b];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var t=arguments.length,b=new Array(t),Z=0;Z<t;Z++)b[Z]=arguments[Z];const J=b.pop(),S=this.cb,P=J.cb,v=b;for(let h=0;h<16;h++)P[h]=S[h]*v[h];return J.markAsUpdated(),J}multiplyToRef(t,b){return this._isIdentity?(b.S(t),b):t._isIdentity?(b.S(this),b):(this.multiplyToArray(t,b.cb,0),b.markAsUpdated(),b)}multiplyToArray(t,b,Z){return g(this,t,b,Z),this}divide(t){return this.divideToRef(t,new l)}divideToRef(t,b){const Z=this.cb,J=t.m,S=b.cb;for(let P=0;P<16;P++)S[P]=Z[P]/J[P];return b.markAsUpdated(),b}divideInPlace(t){const b=this.cb,Z=t.m;for(let J=0;J<16;J++)b[J]/=Z[J];return this.markAsUpdated(),this}minimizeInPlace(t){const b=this.cb,Z=t.m;for(let J=0;J<16;J++)b[J]=Math.min(b[J],Z[J]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const t=this.cb;for(let b=0;b<16;b++)t[b]=Math.min(t[b],b<0||arguments.length<=b?void 0:arguments[b]);return this.markAsUpdated(),this}maximizeInPlace(t){const b=this.cb,Z=t.m;for(let J=0;J<16;J++)b[J]=Math.min(b[J],Z[J]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const t=this.cb;for(let b=0;b<16;b++)t[b]=Math.min(t[b],b<0||arguments.length<=b?void 0:arguments[b]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new l)}negateInPlace(){const t=this.cb;for(let b=0;b<16;b++)t[b]=-t[b];return this.markAsUpdated(),this}negateToRef(t){const b=this.cb,Z=t.cb;for(let J=0;J<16;J++)Z[J]=-b[J];return t.markAsUpdated(),t}equals(t){const b=t;if(!b)return!1;if((this._isIdentity||b._isIdentity)&&!this._isIdentityDirty&&!b._isIdentityDirty)return this._isIdentity&&b._isIdentity;const Z=this.m,J=b.m;return Z[0]===J[0]&&Z[1]===J[1]&&Z[2]===J[2]&&Z[3]===J[3]&&Z[4]===J[4]&&Z[5]===J[5]&&Z[6]===J[6]&&Z[7]===J[7]&&Z[8]===J[8]&&Z[9]===J[9]&&Z[10]===J[10]&&Z[11]===J[11]&&Z[12]===J[12]&&Z[13]===J[13]&&Z[14]===J[14]&&Z[15]===J[15]}equalsWithEpsilon(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Z=this.cb,J=t.m;for(let S=0;S<16;S++)if(!(0,C.WithinEpsilon)(Z[S],J[S],b))return!1;return!0}equalsToFloats(){const t=this.cb;for(let b=0;b<16;b++)if(t[b]!=(b<0||arguments.length<=b?void 0:arguments[b]))return!1;return!0}floor(){return this.floorToRef(new l)}floorToRef(t){const b=this.cb,Z=t.cb;for(let J=0;J<16;J++)Z[J]=Math.floor(b[J]);return t.markAsUpdated(),t}fract(){return this.fractToRef(new l)}fractToRef(t){const b=this.cb,Z=t.cb;for(let J=0;J<16;J++)Z[J]=b[J]-Math.floor(b[J]);return t.markAsUpdated(),t}clone(){const t=new l;return t.S(this),t}getClassName(){return"Matrix"}getHashCode(){let t=M(this.cb[0]);for(let b=1;b<16;b++)t=397*t^M(this.cb[b]);return t}decomposeToTransformNode(t){return t.rotationQuaternion=t.rotationQuaternion||new u,this.decompose(t.Kb,t.rotationQuaternion,t.position)}decompose(t,b,Z,J){let S=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return Z&&Z.Lb(0),t&&t.Lb(1),b&&b.Ab(0,0,0,1),!0;const P=this.cb;if(Z&&Z.Ab(P[12],P[13],P[14]),(t=t||U.JZ[0]).x=Math.sqrt(P[0]*P[0]+P[1]*P[1]+P[2]*P[2]),t.y=Math.sqrt(P[4]*P[4]+P[5]*P[5]+P[6]*P[6]),t.z=Math.sqrt(P[8]*P[8]+P[9]*P[9]+P[10]*P[10]),J){const b=(S?J.absoluteScaling.x:J.Kb.x)<0?-1:1,Z=(S?J.absoluteScaling.y:J.Kb.y)<0?-1:1,P=(S?J.absoluteScaling.z:J.Kb.z)<0?-1:1;t.x*=b,t.y*=Z,t.z*=P}else this.determinant()<=0&&(t.y*=-1);if(0===t._x||0===t._y||0===t._z)return b&&b.Ab(0,0,0,1),!1;if(b){const Z=1/t._x,J=1/t._y,S=1/t._z;l.FromValuesToRef(P[0]*Z,P[1]*Z,P[2]*Z,0,P[4]*J,P[5]*J,P[6]*J,0,P[8]*S,P[9]*S,P[10]*S,0,0,0,0,1,U.Matrix[0]),u.FromRotationMatrixToRef(U.Matrix[0],b)}return!0}getRow(t){if(t<0||t>3)return null;const b=4*t;return new k(this.cb[b+0],this.cb[b+1],this.cb[b+2],this.cb[b+3])}getRowToRef(t,b){if(t>=0&&t<=3){const Z=4*t;b.x=this.cb[Z+0],b.y=this.cb[Z+1],b.z=this.cb[Z+2],b.w=this.cb[Z+3]}return b}setRow(t,b){return this.setRowFromFloats(t,b.x,b.y,b.z,b.w)}transpose(){const t=new l;return l.TransposeToRef(this,t),t}transposeToRef(t){return l.TransposeToRef(this,t),t}setRowFromFloats(t,b,Z,J,S){if(t<0||t>3)return this;const P=4*t;return this.cb[P+0]=b,this.cb[P+1]=Z,this.cb[P+2]=J,this.cb[P+3]=S,this.markAsUpdated(),this}scale(t){const b=new l;return this.scaleToRef(t,b),b}scaleToRef(t,b){for(let Z=0;Z<16;Z++)b.cb[Z]=this.cb[Z]*t;return b.markAsUpdated(),b}scaleAndAddToRef(t,b){for(let Z=0;Z<16;Z++)b.cb[Z]+=this.cb[Z]*t;return b.markAsUpdated(),b}scaleInPlace(t){const b=this.cb;for(let Z=0;Z<16;Z++)b[Z]*=t;return this.markAsUpdated(),this}toNormalMatrix(t){const b=U.Matrix[0];this.invertToRef(b),b.transposeToRef(t);const Z=t.cb;return l.FromValuesToRef(Z[0],Z[1],Z[2],0,Z[4],Z[5],Z[6],0,Z[8],Z[9],Z[10],0,0,0,0,1,t),t}getRotationMatrix(){const t=new l;return this.getRotationMatrixToRef(t),t}getRotationMatrixToRef(t){const b=U.JZ[0];if(!this.decompose(b))return l.IdentityToRef(t),t;const Z=this.cb,J=1/b._x,S=1/b._y,P=1/b._z;return l.FromValuesToRef(Z[0]*J,Z[1]*J,Z[2]*J,0,Z[4]*S,Z[5]*S,Z[6]*S,0,Z[8]*P,Z[9]*P,Z[10]*P,0,0,0,0,1,t),t}toggleModelMatrixHandInPlace(){const t=this.cb;return t[2]*=-1,t[6]*=-1,t[8]*=-1,t[9]*=-1,t[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const t=this.cb;return t[8]*=-1,t[9]*=-1,t[10]*=-1,t[11]*=-1,this.markAsUpdated(),this}static CZ(t){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const Z=new l;return l.FromArrayToRef(t,b,Z),Z}static FromArrayToRef(t,b,Z){for(let J=0;J<16;J++)Z.cb[J]=t[J+b];return Z.markAsUpdated(),Z}static FromFloat32ArrayToRefScaled(t,b,Z,J){return J.cb[0]=t[0+b]*Z,J.cb[1]=t[1+b]*Z,J.cb[2]=t[2+b]*Z,J.cb[3]=t[3+b]*Z,J.cb[4]=t[4+b]*Z,J.cb[5]=t[5+b]*Z,J.cb[6]=t[6+b]*Z,J.cb[7]=t[7+b]*Z,J.cb[8]=t[8+b]*Z,J.cb[9]=t[9+b]*Z,J.cb[10]=t[10+b]*Z,J.cb[11]=t[11+b]*Z,J.cb[12]=t[12+b]*Z,J.cb[13]=t[13+b]*Z,J.cb[14]=t[14+b]*Z,J.cb[15]=t[15+b]*Z,J.markAsUpdated(),J}static get IdentityReadOnly(){return l._IdentityReadOnly}static FromValuesToRef(t,b,Z,J,S,P,v,h,C,Y,g,I,r,M,T,a,k){const u=k.cb;u[0]=t,u[1]=b,u[2]=Z,u[3]=J,u[4]=S,u[5]=P,u[6]=v,u[7]=h,u[8]=C,u[9]=Y,u[10]=g,u[11]=I,u[12]=r,u[13]=M,u[14]=T,u[15]=a,k.markAsUpdated()}static FromValues(t,b,Z,J,S,P,v,h,C,Y,g,I,r,M,T,a){const k=new l,u=k.cb;return u[0]=t,u[1]=b,u[2]=Z,u[3]=J,u[4]=S,u[5]=P,u[6]=v,u[7]=h,u[8]=C,u[9]=Y,u[10]=g,u[11]=I,u[12]=r,u[13]=M,u[14]=T,u[15]=a,k.markAsUpdated(),k}static Compose(t,b,Z){const J=new l;return l.ComposeToRef(t,b,Z,J),J}static ComposeToRef(t,b,Z,J){const S=J.cb,P=b._x,v=b._y,h=b._z,C=b._w,Y=P+P,g=v+v,I=h+h,r=P*Y,M=P*g,T=P*I,a=v*g,k=v*I,u=h*I,l=C*Y,U=C*g,E=C*I,c=t._x,H=t._y,o=t._z;return S[0]=(1-(a+u))*c,S[1]=(M+E)*c,S[2]=(T-U)*c,S[3]=0,S[4]=(M-E)*H,S[5]=(1-(r+u))*H,S[6]=(k+l)*H,S[7]=0,S[8]=(T+U)*o,S[9]=(k-l)*o,S[10]=(1-(r+a))*o,S[11]=0,S[12]=Z._x,S[13]=Z._y,S[14]=Z._z,S[15]=1,J.markAsUpdated(),J}static Identity(){const t=l.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return t._updateIdentityStatus(!0),t}static IdentityToRef(t){return l.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,t),t._updateIdentityStatus(!0),t}static Zero(){const t=l.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return t._updateIdentityStatus(!1),t}static RotationX(t){const b=new l;return l.RotationXToRef(t,b),b}static Invert(t){const b=new l;return t.invertToRef(b),b}static RotationXToRef(t,b){const Z=Math.sin(t),J=Math.cos(t);return l.FromValuesToRef(1,0,0,0,0,J,Z,0,0,-Z,J,0,0,0,0,1,b),b._updateIdentityStatus(1===J&&0===Z),b}static RotationY(t){const b=new l;return l.RotationYToRef(t,b),b}static RotationYToRef(t,b){const Z=Math.sin(t),J=Math.cos(t);return l.FromValuesToRef(J,0,-Z,0,0,1,0,0,Z,0,J,0,0,0,0,1,b),b._updateIdentityStatus(1===J&&0===Z),b}static RotationZ(t){const b=new l;return l.RotationZToRef(t,b),b}static RotationZToRef(t,b){const Z=Math.sin(t),J=Math.cos(t);return l.FromValuesToRef(J,Z,0,0,-Z,J,0,0,0,0,1,0,0,0,0,1,b),b._updateIdentityStatus(1===J&&0===Z),b}static RotationAxis(t,b){const Z=new l;return l.RotationAxisToRef(t,b,Z),Z}static RotationAxisToRef(t,b,Z){const J=Math.sin(-b),S=Math.cos(-b),P=1-S;t=t.normalizeToRef(U.JZ[0]);const v=Z.cb;return v[0]=t._x*t._x*P+S,v[1]=t._x*t._y*P-t._z*J,v[2]=t._x*t._z*P+t._y*J,v[3]=0,v[4]=t._y*t._x*P+t._z*J,v[5]=t._y*t._y*P+S,v[6]=t._y*t._z*P-t._x*J,v[7]=0,v[8]=t._z*t._x*P-t._y*J,v[9]=t._z*t._y*P+t._x*J,v[10]=t._z*t._z*P+S,v[11]=0,v[12]=0,v[13]=0,v[14]=0,v[15]=1,Z.markAsUpdated(),Z}static RotationAlignToRef(t,b,Z){let S=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const P=a.Dot(b,t),v=Z.cb;if(P<-1+J.e)v[0]=-1,v[1]=0,v[2]=0,v[3]=0,v[4]=0,v[5]=S?1:-1,v[6]=0,v[7]=0,v[8]=0,v[9]=0,v[10]=S?-1:1,v[11]=0;else{const Z=a.Cross(b,t),J=1/(1+P);v[0]=Z._x*Z._x*J+P,v[1]=Z._y*Z._x*J-Z._z,v[2]=Z._z*Z._x*J+Z._y,v[3]=0,v[4]=Z._x*Z._y*J+Z._z,v[5]=Z._y*Z._y*J+P,v[6]=Z._z*Z._y*J-Z._x,v[7]=0,v[8]=Z._x*Z._z*J-Z._y,v[9]=Z._y*Z._z*J+Z._x,v[10]=Z._z*Z._z*J+P,v[11]=0}return v[12]=0,v[13]=0,v[14]=0,v[15]=1,Z.markAsUpdated(),Z}static RotationYawPitchRoll(t,b,Z){const J=new l;return l.RotationYawPitchRollToRef(t,b,Z,J),J}static RotationYawPitchRollToRef(t,b,Z,J){return u.RotationYawPitchRollToRef(t,b,Z,U.Quaternion[0]),U.Quaternion[0].toRotationMatrix(J),J}static Scaling(t,b,Z){const J=new l;return l.ScalingToRef(t,b,Z,J),J}static ScalingToRef(t,b,Z,J){return l.FromValuesToRef(t,0,0,0,0,b,0,0,0,0,Z,0,0,0,0,1,J),J._updateIdentityStatus(1===t&&1===b&&1===Z),J}static Translation(t,b,Z){const J=new l;return l.TranslationToRef(t,b,Z,J),J}static TranslationToRef(t,b,Z,J){return l.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,t,b,Z,1,J),J._updateIdentityStatus(0===t&&0===b&&0===Z),J}static Lerp(t,b,Z){const J=new l;return l.LerpToRef(t,b,Z,J),J}static LerpToRef(t,b,Z,J){const S=J.cb,P=t.m,v=b.m;for(let h=0;h<16;h++)S[h]=P[h]*(1-Z)+v[h]*Z;return J.markAsUpdated(),J}static DecomposeLerp(t,b,Z){const J=new l;return l.DecomposeLerpToRef(t,b,Z,J),J}static DecomposeLerpToRef(t,b,Z,J){const S=U.JZ[0],P=U.Quaternion[0],v=U.JZ[1];t.decompose(S,P,v);const h=U.JZ[2],C=U.Quaternion[1],Y=U.JZ[3];b.decompose(h,C,Y);const g=U.JZ[4];a.LerpToRef(S,h,Z,g);const I=U.Quaternion[2];u.SlerpToRef(P,C,Z,I);const r=U.JZ[5];return a.LerpToRef(v,Y,Z,r),l.ComposeToRef(g,I,r,J),J}static LookAtLH(t,b,Z){const J=new l;return l.LookAtLHToRef(t,b,Z,J),J}static LookAtLHToRef(t,b,Z,J){const S=U.JZ[0],P=U.JZ[1],v=U.JZ[2];b.subtractToRef(t,v),v.normalize(),a.CrossToRef(Z,v,S);const h=S.lengthSquared();0===h?S.x=1:S.normalizeFromLength(Math.sqrt(h)),a.CrossToRef(v,S,P),P.normalize();const C=-a.Dot(S,t),Y=-a.Dot(P,t),g=-a.Dot(v,t);return l.FromValuesToRef(S._x,P._x,v._x,0,S._y,P._y,v._y,0,S._z,P._z,v._z,0,C,Y,g,1,J),J}static LookAtRH(t,b,Z){const J=new l;return l.LookAtRHToRef(t,b,Z,J),J}static LookAtRHToRef(t,b,Z,J){const S=U.JZ[0],P=U.JZ[1],v=U.JZ[2];t.subtractToRef(b,v),v.normalize(),a.CrossToRef(Z,v,S);const h=S.lengthSquared();0===h?S.x=1:S.normalizeFromLength(Math.sqrt(h)),a.CrossToRef(v,S,P),P.normalize();const C=-a.Dot(S,t),Y=-a.Dot(P,t),g=-a.Dot(v,t);return l.FromValuesToRef(S._x,P._x,v._x,0,S._y,P._y,v._y,0,S._z,P._z,v._z,0,C,Y,g,1,J),J}static LookDirectionLH(t,b){const Z=new l;return l.LookDirectionLHToRef(t,b,Z),Z}static LookDirectionLHToRef(t,b,Z){const J=U.JZ[0];J.S(t),J.scaleInPlace(-1);const S=U.JZ[1];return a.CrossToRef(b,J,S),l.FromValuesToRef(S._x,S._y,S._z,0,b._x,b._y,b._z,0,J._x,J._y,J._z,0,0,0,0,1,Z),Z}static LookDirectionRH(t,b){const Z=new l;return l.LookDirectionRHToRef(t,b,Z),Z}static LookDirectionRHToRef(t,b,Z){const J=U.JZ[2];return a.CrossToRef(b,t,J),l.FromValuesToRef(J._x,J._y,J._z,0,b._x,b._y,b._z,0,t._x,t._y,t._z,0,0,0,0,1,Z),Z}static OrthoLH(t,b,Z,J,S){const P=new l;return l.OrthoLHToRef(t,b,Z,J,P,S),P}static OrthoLHToRef(t,b,Z,J,S,P){const v=2/t,h=2/b,C=2/(J-Z),Y=-(J+Z)/(J-Z);return l.FromValuesToRef(v,0,0,0,0,h,0,0,0,0,C,0,0,0,Y,1,S),P&&S.multiplyToRef(c,S),S._updateIdentityStatus(1===v&&1===h&&1===C&&0===Y),S}static OrthoOffCenterLH(t,b,Z,J,S,P,v){const h=new l;return l.OrthoOffCenterLHToRef(t,b,Z,J,S,P,h,v),h}static OrthoOffCenterLHToRef(t,b,Z,J,S,P,v,h){const C=2/(b-t),Y=2/(J-Z),g=2/(P-S),I=-(P+S)/(P-S),r=(t+b)/(t-b),M=(J+Z)/(Z-J);return l.FromValuesToRef(C,0,0,0,0,Y,0,0,0,0,g,0,r,M,I,1,v),h&&v.multiplyToRef(c,v),v.markAsUpdated(),v}static ObliqueOffCenterLHToRef(t,b,Z,J,S,P,v,h,C,Y,g){const I=-v*Math.cos(h),r=-v*Math.sin(h);return l.TranslationToRef(0,0,-C,U.Matrix[1]),l.FromValuesToRef(1,0,0,0,0,1,0,0,I,r,1,0,0,0,0,1,U.Matrix[0]),U.Matrix[1].multiplyToRef(U.Matrix[0],U.Matrix[0]),l.TranslationToRef(0,0,C,U.Matrix[1]),U.Matrix[0].multiplyToRef(U.Matrix[1],U.Matrix[0]),l.OrthoOffCenterLHToRef(t,b,Z,J,S,P,Y,g),U.Matrix[0].multiplyToRef(Y,Y),Y}static OrthoOffCenterRH(t,b,Z,J,S,P,v){const h=new l;return l.OrthoOffCenterRHToRef(t,b,Z,J,S,P,h,v),h}static OrthoOffCenterRHToRef(t,b,Z,J,S,P,v,h){return l.OrthoOffCenterLHToRef(t,b,Z,J,S,P,v,h),v.cb[10]*=-1,v}static ObliqueOffCenterRHToRef(t,b,Z,J,S,P,v,h,C,Y,g){const I=v*Math.cos(h),r=v*Math.sin(h);return l.TranslationToRef(0,0,C,U.Matrix[1]),l.FromValuesToRef(1,0,0,0,0,1,0,0,I,r,1,0,0,0,0,1,U.Matrix[0]),U.Matrix[1].multiplyToRef(U.Matrix[0],U.Matrix[0]),l.TranslationToRef(0,0,-C,U.Matrix[1]),U.Matrix[0].multiplyToRef(U.Matrix[1],U.Matrix[0]),l.OrthoOffCenterRHToRef(t,b,Z,J,S,P,Y,g),U.Matrix[0].multiplyToRef(Y,Y),Y}static PerspectiveLH(t,b,Z,J,S){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const v=new l,h=2*Z/t,C=2*Z/b,Y=(J+Z)/(J-Z),g=-2*J*Z/(J-Z),I=Math.tan(P);return l.FromValuesToRef(h,0,0,0,0,C,0,I,0,0,Y,1,0,0,g,0,v),S&&v.multiplyToRef(c,v),v._updateIdentityStatus(!1),v}static PerspectiveFovLH(t,b,Z,J,S){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,v=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const h=new l;return l.PerspectiveFovLHToRef(t,b,Z,J,h,!0,S,P,v),h}static PerspectiveFovLHToRef(t,b,Z,J,S){let P=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],v=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,C=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const Y=Z,g=J,I=1/Math.tan(.5*t),r=P?I/b:I,M=P?I:I*b,T=C&&0===Y?-1:0!==g?(g+Y)/(g-Y):1,a=C&&0===Y?2*g:0!==g?-2*g*Y/(g-Y):-2*Y,k=Math.tan(h);return l.FromValuesToRef(r,0,0,0,0,M,0,k,0,0,T,1,0,0,a,0,S),v&&S.multiplyToRef(c,S),S._updateIdentityStatus(!1),S}static PerspectiveFovReverseLHToRef(t,b,Z,J,S){let P=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],v=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const C=1/Math.tan(.5*t),Y=P?C/b:C,g=P?C:C*b,I=Math.tan(h);return l.FromValuesToRef(Y,0,0,0,0,g,0,I,0,0,-Z,1,0,0,1,0,S),v&&S.multiplyToRef(c,S),S._updateIdentityStatus(!1),S}static PerspectiveFovRH(t,b,Z,J,S){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,v=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const h=new l;return l.PerspectiveFovRHToRef(t,b,Z,J,h,!0,S,P,v),h}static PerspectiveFovRHToRef(t,b,Z,J,S){let P=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],v=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,C=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const Y=Z,g=J,I=1/Math.tan(.5*t),r=P?I/b:I,M=P?I:I*b,T=C&&0===Y?1:0!==g?-(g+Y)/(g-Y):-1,a=C&&0===Y?2*g:0!==g?-2*g*Y/(g-Y):-2*Y,k=Math.tan(h);return l.FromValuesToRef(r,0,0,0,0,M,0,k,0,0,T,-1,0,0,a,0,S),v&&S.multiplyToRef(c,S),S._updateIdentityStatus(!1),S}static PerspectiveFovReverseRHToRef(t,b,Z,J,S){let P=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],v=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const C=1/Math.tan(.5*t),Y=P?C/b:C,g=P?C:C*b,I=Math.tan(h);return l.FromValuesToRef(Y,0,0,0,0,g,0,I,0,0,-Z,-1,0,0,-1,0,S),v&&S.multiplyToRef(c,S),S._updateIdentityStatus(!1),S}static GetFinalMatrix(t,b,Z,J,S,P){const v=t.width,h=t.height,C=t.x,Y=t.y,g=l.FromValues(v/2,0,0,0,0,-h/2,0,0,0,0,P-S,0,C+v/2,h/2+Y,S,1),I=new l;return b.multiplyToRef(Z,I),I.multiplyToRef(J,I),I.multiplyToRef(g,I)}static GetAsMatrix2x2(t){const b=t.m,Z=[b[0],b[1],b[4],b[5]];return v.c.MatrixUse64Bits?Z:new Float32Array(Z)}static GetAsMatrix3x3(t){const b=t.m,Z=[b[0],b[1],b[2],b[4],b[5],b[6],b[8],b[9],b[10]];return v.c.MatrixUse64Bits?Z:new Float32Array(Z)}static Transpose(t){const b=new l;return l.TransposeToRef(t,b),b}static TransposeToRef(t,b){const Z=t.m,J=Z[0],S=Z[4],P=Z[8],v=Z[12],h=Z[1],C=Z[5],Y=Z[9],g=Z[13],I=Z[2],r=Z[6],M=Z[10],T=Z[14],a=Z[3],k=Z[7],u=Z[11],l=Z[15],U=b.cb;return U[0]=J,U[1]=S,U[2]=P,U[3]=v,U[4]=h,U[5]=C,U[6]=Y,U[7]=g,U[8]=I,U[9]=r,U[10]=M,U[11]=T,U[12]=a,U[13]=k,U[14]=u,U[15]=l,b.markAsUpdated(),b._updateIdentityStatus(t._isIdentity,t._isIdentityDirty),b}static Reflection(t){const b=new l;return l.ReflectionToRef(t,b),b}static ReflectionToRef(t,b){t.normalize();const Z=t.normal.x,J=t.normal.y,S=t.normal.z,P=-2*Z,v=-2*J,h=-2*S;return l.FromValuesToRef(P*Z+1,v*Z,h*Z,0,P*J,v*J+1,h*J,0,P*S,v*S,h*S+1,0,P*t.d,v*t.d,h*t.d,1,b),b}static FromXYZAxesToRef(t,b,Z,J){return l.FromValuesToRef(t._x,t._y,t._z,0,b._x,b._y,b._z,0,Z._x,Z._y,Z._z,0,0,0,0,1,J),J}static FromQuaternionToRef(t,b){const Z=t._x*t._x,J=t._y*t._y,S=t._z*t._z,P=t._x*t._y,v=t._z*t._w,h=t._z*t._x,C=t._y*t._w,Y=t._y*t._z,g=t._x*t._w;return b.cb[0]=1-2*(J+S),b.cb[1]=2*(P+v),b.cb[2]=2*(h-C),b.cb[3]=0,b.cb[4]=2*(P-v),b.cb[5]=1-2*(S+Z),b.cb[6]=2*(Y+g),b.cb[7]=0,b.cb[8]=2*(h+C),b.cb[9]=2*(Y-g),b.cb[10]=1-2*(J+Z),b.cb[11]=0,b.cb[12]=0,b.cb[13]=0,b.cb[14]=0,b.cb[15]=1,b.markAsUpdated(),b}}l._IdentityReadOnly=l.Identity(),Object.defineProperties(l.prototype,{dimension:{value:[4,4]},rank:{value:2}});class U{}U.JZ=(0,S.g)(11,a.Zero),U.Matrix=(0,S.g)(2,l.Identity),U.Quaternion=(0,S.g)(3,u.Zero);class E{}E.Vector2=(0,S.g)(3,T.Zero),E.JZ=(0,S.g)(13,a.Zero),E.Vector4=(0,S.g)(3,k.Zero),E.Quaternion=(0,S.g)(3,u.Zero),E.Matrix=(0,S.g)(8,l.Identity),(0,P.f)("BABYLON.Vector2",T),(0,P.f)("BABYLON.Vector3",a),(0,P.f)("BABYLON.Vector4",k),(0,P.f)("BABYLON.Matrix",l);const c=l.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12742:(t,b,Z)=>{function J(t,b){const Z=[];for(let J=0;J<t;++J)Z.push(b());return Z}function S(t,b){return J(t,b)}Z.d(b,{c:()=>J,g:()=>S,h:()=>v});const P=["push","splice","pop","shift","unshift"];function v(t,b){const Z=P.map((Z=>function(t,b,Z){const J=t[b];if("function"!==typeof J)return null;const S=function(){const J=t.length,P=S.previous.apply(t,arguments);return Z(b,J),P};return J.next=S,S.previous=J,t[b]=S,()=>{const Z=S.previous;if(!Z)return;const J=S.next;J?(Z.next=J,J.previous=Z):(Z.next=void 0,t[b]=Z),S.next=void 0,S.previous=void 0}}(t,Z,b)));return()=>{for(const t of Z)null===t||void 0===t||t()}}}}]);