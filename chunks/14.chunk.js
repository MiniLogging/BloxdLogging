"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[14],{12989:(I,x,L)=>{L.d(x,{e:()=>Y,h:()=>G,l:()=>F,m:()=>X});const F=1/2.2,X=2.2,G=(1+Math.sqrt(5))/2,Y=.001},13001:(I,x,L)=>{function F(I){return parseInt(I.toString().replace(/\W/g,""))}function X(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(I-x)<=L}function G(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return I<x-F||I>L+F}function Y(I,x){return I===x?I:Math.random()*(x-I)+I}function p(I,x,L){return I+(x-I)*L}function B(I,x,L){let F=H(x-I,360);return F>180&&(F-=360),I+F*e(L)}function l(I,x,L){let F=0;return F=I!=x?e((L-I)/(x-I)):0,F}function W(I,x,L,F,X){const G=X*X,Y=X*G;return I*(2*Y-3*G+1)+L*(-2*Y+3*G)+x*(Y-2*G+X)+F*(Y-G)}function Q(I,x,L,F,X){const G=X*X;return 6*(G-X)*I+(3*G-4*X+1)*x+6*(-G+X)*L+(3*G-2*X)*F}function e(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(L,Math.max(x,I))}function g(I){return I-=2*Math.PI*Math.floor((I+Math.PI)/(2*Math.PI))}function v(I){const x=I.toString(16);return I<=15?("0"+x).toUpperCase():x.toUpperCase()}function z(I){if(Math.log2)return Math.floor(Math.log2(I));if(I<0)return NaN;if(0===I)return-1/0;let x=0;if(I<1){for(;I<1;)x++,I*=2;x=-x}else if(I>1)for(;I>1;)x++,I=Math.floor(I/2);return x}function H(I,x){return I-Math.floor(I/x)*x}function s(I,x,L){return(I-x)/(L-x)}function U(I,x,L){return I*(L-x)+x}function q(I,x){let L=H(x-I,360);return L>180&&(L-=360),L}function y(I,x){const L=H(I,2*x);return x-Math.abs(L-x)}function T(I,x,L){let F=e(L);return F=-2*F*F*F+3*F*F,x*F+I*(1-F)}function Z(I,x,L){let F=0;return F=Math.abs(x-I)<=L?x:I+Math.sign(x-I)*L,F}function t(I,x,L){const F=q(I,x);let X=0;return X=-L<F&&F<L?x:Z(I,x=I+F,L),X}function f(I,x,L){return(I-x)/(L-x)}function R(I,x,L){return(L-x)*I+x}function n(I,x){const L=I%x;return 0===L?x:n(x,L)}L.r(x),L.d(x,{Clamp:()=>e,DeltaAngle:()=>q,Denormalize:()=>U,ExtractAsInt:()=>F,Hermite:()=>W,Hermite1stDerivative:()=>Q,HighestCommonFactor:()=>n,ILog2:()=>z,InverseLerp:()=>l,Lerp:()=>p,LerpAngle:()=>B,MoveTowards:()=>Z,MoveTowardsAngle:()=>t,Normalize:()=>s,NormalizeRadians:()=>g,OutsideRange:()=>G,PercentToRange:()=>R,PingPong:()=>y,RandomRange:()=>Y,RangeToPercent:()=>f,Repeat:()=>H,SmoothStep:()=>T,ToHex:()=>v,WithinEpsilon:()=>X})},12983:(I,x,L)=>{L.r(x),L.d(x,{Matrix:()=>U,Quaternion:()=>s,TmpVectors:()=>y,Vector2:()=>v,sx:()=>z,Vector4:()=>H});var F=L(12989),X=L(12996),G=L(12938),Y=L(12901),p=L(12840),B=L(13001);class l{}function W(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const X=I.Cp(),G=x.Cp(),Y=X[0],p=X[1],B=X[2],l=X[3],W=X[4],Q=X[5],e=X[6],g=X[7],v=X[8],z=X[9],H=X[10],s=X[11],U=X[12],q=X[13],y=X[14],T=X[15],Z=G[0],t=G[1],f=G[2],R=G[3],n=G[4],P=G[5],d=G[6],M=G[7],K=G[8],u=G[9],A=G[10],mI=G[11],O=G[12],w=G[13],k=G[14],a=G[15];L[F]=Y*Z+p*n+B*K+l*O,L[F+1]=Y*t+p*P+B*u+l*w,L[F+2]=Y*f+p*d+B*A+l*k,L[F+3]=Y*R+p*M+B*mI+l*a,L[F+4]=W*Z+Q*n+e*K+g*O,L[F+5]=W*t+Q*P+e*u+g*w,L[F+6]=W*f+Q*d+e*A+g*k,L[F+7]=W*R+Q*M+e*mI+g*a,L[F+8]=v*Z+z*n+H*K+s*O,L[F+9]=v*t+z*P+H*u+s*w,L[F+10]=v*f+z*d+H*A+s*k,L[F+11]=v*R+z*M+H*mI+s*a,L[F+12]=U*Z+q*n+y*K+T*O,L[F+13]=U*t+q*P+y*u+T*w,L[F+14]=U*f+q*d+y*A+T*k,L[F+15]=U*R+q*M+y*mI+T*a}function Q(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const F=I.Cp();x[L]=F[0],x[L+1]=F[1],x[L+2]=F[2],x[L+3]=F[3],x[L+4]=F[4],x[L+5]=F[5],x[L+6]=F[6],x[L+7]=F[7],x[L+8]=F[8],x[L+9]=F[9],x[L+10]=F[10],x[L+11]=F[11],x[L+12]=F[12],x[L+13]=F[13],x[L+14]=F[14],x[L+15]=F[15]}function e(I,x){const L=I.Cp(),F=L[0],X=L[1],G=L[2],Y=L[3],p=L[4],B=L[5],l=L[6],W=L[7],Q=L[8],e=L[9],g=L[10],v=L[11],z=L[12],H=L[13],s=L[14],U=L[15],q=g*U-s*v,y=e*U-H*v,T=e*s-H*g,Z=Q*U-z*v,t=Q*s-g*z,f=Q*H-z*e,R=+(B*q-l*y+W*T),n=-(p*q-l*Z+W*t),P=+(p*y-B*Z+W*f),d=-(p*T-B*t+l*f),M=F*R+X*n+G*P+Y*d;if(0===M)return!1;const K=1/M,u=l*U-s*W,A=B*U-H*W,mI=B*s-H*l,O=p*U-z*W,w=p*s-z*l,k=p*H-z*B,a=l*v-g*W,D=B*v-e*W,r=B*g-e*l,N=p*v-Q*W,S=p*g-Q*l,c=p*e-Q*B,o=-(X*q-G*y+Y*T),J=+(F*q-G*Z+Y*t),h=-(F*y-X*Z+Y*f),E=+(F*T-X*t+G*f),i=+(X*u-G*A+Y*mI),V=-(F*u-G*O+Y*w),j=+(F*A-X*O+Y*k),C=-(F*mI-X*w+G*k),b=-(X*a-G*D+Y*r),II=+(F*a-G*N+Y*S),xI=-(F*D-X*N+Y*c),LI=+(F*r-X*S+G*c);return x[0]=R*K,x[1]=o*K,x[2]=i*K,x[3]=b*K,x[4]=n*K,x[5]=J*K,x[6]=V*K,x[7]=II*K,x[8]=P*K,x[9]=h*K,x[10]=j*K,x[11]=xI*K,x[12]=d*K,x[13]=E*K,x[14]=C*K,x[15]=LI*K,!0}l._UpdateFlagSeed=0;const g=I=>parseInt(I.toString().replace(/\W/g,""));class v{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=I,this.y=x}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let I=g(this.x);return I=397*I^g(this.y),I}toArray(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[x]=this.x,I[x+1]=this.y,this}PL(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return v.FromArrayToRef(I,x,this),this}Cp(){return[this.x,this.y]}X(I){return this.x=I.x,this.y=I.y,this}YB(I,x){return this.x=I,this.y=x,this}set(I,x){return this.YB(I,x)}BB(I){return this.YB(I,I)}add(I){return new v(this.x+I.x,this.y+I.y)}addToRef(I,x){return x.x=this.x+I.x,x.y=this.y+I.y,x}addInPlace(I){return this.x+=I.x,this.y+=I.y,this}addInPlaceFromFloats(I,x){return this.x+=I,this.y+=x,this}addVector3(I){return new v(this.x+I.x,this.y+I.y)}Ux(I){return new v(this.x-I.x,this.y-I.y)}subtractToRef(I,x){return x.x=this.x-I.x,x.y=this.y-I.y,x}aQ(I){return this.x-=I.x,this.y-=I.y,this}multiplyInPlace(I){return this.x*=I.x,this.y*=I.y,this}multiply(I){return new v(this.x*I.x,this.y*I.y)}multiplyToRef(I,x){return x.x=this.x*I.x,x.y=this.y*I.y,x}multiplyByFloats(I,x){return new v(this.x*I,this.y*x)}divide(I){return new v(this.x/I.x,this.y/I.y)}divideToRef(I,x){return x.x=this.x/I.x,x.y=this.y/I.y,x}divideInPlace(I){return this.x=this.x/I.x,this.y=this.y/I.y,this}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I.x,I.y)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I.x,I.y)}minimizeInPlaceFromFloats(I,x){return this.x=Math.min(I,this.x),this.y=Math.min(x,this.y),this}maximizeInPlaceFromFloats(I,x){return this.x=Math.max(I,this.x),this.y=Math.max(x,this.y),this}subtractFromFloats(I,x){return new v(this.x-I,this.y-x)}subtractFromFloatsToRef(I,x,L){return L.x=this.x-I,L.y=this.y-x,L}negate(){return new v(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(I){return I.x=-this.x,I.y=-this.y,I}scaleInPlace(I){return this.x*=I,this.y*=I,this}scale(I){return new v(this.x*I,this.y*I)}scaleToRef(I,x){return x.x=this.x*I,x.y=this.y*I,x}scaleAndAddToRef(I,x){return x.x+=this.x*I,x.y+=this.y*I,x}equals(I){return I&&this.x===I.x&&this.y===I.y}equalsWithEpsilon(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:F.e;return I&&(0,B.WithinEpsilon)(this.x,I.x,x)&&(0,B.WithinEpsilon)(this.y,I.y,x)}equalsToFloats(I,x){return this.x===I&&this.y===x}floor(){return new v(Math.floor(this.x),Math.floor(this.y))}floorToRef(I){return I.x=Math.floor(this.x),I.y=Math.floor(this.y),I}fract(){return new v(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(I){return I.x=this.x-Math.floor(this.x),I.y=this.y-Math.floor(this.y),I}rotate(I){return this.rotateToRef(I,new v)}rotateToRef(I,x){const L=Math.cos(I),F=Math.sin(I);return x.x=L*this.x-F*this.y,x.y=F*this.x+L*this.y,x}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){const I=new v;return this.normalizeToRef(I),I}normalizeToRef(I){const x=this.length();return 0===x&&(I.x=this.x,I.y=this.y),this.scaleToRef(1/x,I)}clone(){return new v(this.x,this.y)}dot(I){return this.x*I.x+this.y*I.y}static Zero(){return new v(0,0)}static One(){return new v(1,1)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new v((0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).YB((0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x))}static get ZeroReadOnly(){return v._ZeroReadOnly}static tx(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new v(I[x],I[x+1])}static FromArrayToRef(I,x,L){return L.x=I[x],L.y=I[x+1],L}static FromFloatsToRef(I,x,L){return L.YB(I,x),L}static CatmullRom(I,x,L,F,X){const G=X*X,Y=X*G,p=.5*(2*x.x+(-I.x+L.x)*X+(2*I.x-5*x.x+4*L.x-F.x)*G+(-I.x+3*x.x-3*L.x+F.x)*Y),B=.5*(2*x.y+(-I.y+L.y)*X+(2*I.y-5*x.y+4*L.y-F.y)*G+(-I.y+3*x.y-3*L.y+F.y)*Y);return new v(p,B)}static ClampToRef(I,x,L,F){return F.x=(0,B.Clamp)(I.x,x.x,L.x),F.y=(0,B.Clamp)(I.y,x.y,L.y),F}static Clamp(I,x,L){const F=(0,B.Clamp)(I.x,x.x,L.x),X=(0,B.Clamp)(I.y,x.y,L.y);return new v(F,X)}static Hermite(I,x,L,F,X){const G=X*X,Y=X*G,p=2*Y-3*G+1,B=-2*Y+3*G,l=Y-2*G+X,W=Y-G,Q=I.x*p+L.x*B+x.x*l+F.x*W,e=I.y*p+L.y*B+x.y*l+F.y*W;return new v(Q,e)}static Hermite1stDerivative(I,x,L,F,X){return this.Hermite1stDerivativeToRef(I,x,L,F,X,new v)}static Hermite1stDerivativeToRef(I,x,L,F,X,G){const Y=X*X;return G.x=6*(Y-X)*I.x+(3*Y-4*X+1)*x.x+6*(-Y+X)*L.x+(3*Y-2*X)*F.x,G.y=6*(Y-X)*I.y+(3*Y-4*X+1)*x.y+6*(-Y+X)*L.y+(3*Y-2*X)*F.y,G}static Lerp(I,x,L){return v.LerpToRef(I,x,L,new v)}static LerpToRef(I,x,L,F){return F.x=I.x+(x.x-I.x)*L,F.y=I.y+(x.y-I.y)*L,F}static Dot(I,x){return I.x*x.x+I.y*x.y}static Normalize(I){return v.NormalizeToRef(I,new v)}static NormalizeToRef(I,x){return I.normalizeToRef(x),x}static Minimize(I,x){const L=I.x<x.x?I.x:x.x,F=I.y<x.y?I.y:x.y;return new v(L,F)}static Maximize(I,x){const L=I.x>x.x?I.x:x.x,F=I.y>x.y?I.y:x.y;return new v(L,F)}static Transform(I,x){return v.TransformToRef(I,x,new v)}static TransformToRef(I,x,L){const F=x.m,X=I.x*F[0]+I.y*F[4]+F[12],G=I.x*F[1]+I.y*F[5]+F[13];return L.x=X,L.y=G,L}static PointInTriangle(I,x,L,F){const X=.5*(-L.y*F.x+x.y*(-L.x+F.x)+x.x*(L.y-F.y)+L.x*F.y),G=X<0?-1:1,Y=(x.y*F.x-x.x*F.y+(F.y-x.y)*I.x+(x.x-F.x)*I.y)*G,p=(x.x*L.y-x.y*L.x+(x.y-L.y)*I.x+(L.x-x.x)*I.y)*G;return Y>0&&p>0&&Y+p<2*X*G}static Distance(I,x){return Math.sqrt(v.DistanceSquared(I,x))}static DistanceSquared(I,x){const L=I.x-x.x,F=I.y-x.y;return L*L+F*F}static Center(I,x){return v.CenterToRef(I,x,new v)}static CenterToRef(I,x,L){return L.YB((I.x+x.x)/2,(I.y+x.y)/2)}static DistanceOfPointFromSegment(I,x,L){const F=v.DistanceSquared(x,L);if(0===F)return v.Distance(I,x);const X=L.Ux(x),G=Math.max(0,Math.min(1,v.Dot(I.Ux(x),X)/F)),Y=x.add(X.multiplyByFloats(G,G));return v.Distance(I,Y)}}v._V8PerformanceHack=new v(.5,.5),v._ZeroReadOnly=v.Zero(),Object.defineProperties(v.prototype,{dimension:{value:[2]},rank:{value:1}});class z{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=I,this._y=x,this._z=L}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"sx"}getHashCode(){let I=g(this._x);return I=397*I^g(this._y),I=397*I^g(this._z),I}Cp(){return[this._x,this._y,this._z]}toArray(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[x]=this._x,I[x+1]=this._y,I[x+2]=this._z,this}PL(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z.FromArrayToRef(I,x,this),this}toQuaternion(){return s.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(I){return this._x+=I._x,this._y+=I._y,this._z+=I._z,this._isDirty=!0,this}addInPlaceFromFloats(I,x,L){return this._x+=I,this._y+=x,this._z+=L,this._isDirty=!0,this}add(I){return new z(this._x+I._x,this._y+I._y,this._z+I._z)}addToRef(I,x){return x._x=this._x+I._x,x._y=this._y+I._y,x._z=this._z+I._z,x._isDirty=!0,x}aQ(I){return this._x-=I._x,this._y-=I._y,this._z-=I._z,this._isDirty=!0,this}Ux(I){return new z(this._x-I._x,this._y-I._y,this._z-I._z)}subtractToRef(I,x){return this.subtractFromFloatsToRef(I._x,I._y,I._z,x)}subtractFromFloats(I,x,L){return new z(this._x-I,this._y-x,this._z-L)}subtractFromFloatsToRef(I,x,L,F){return F._x=this._x-I,F._y=this._y-x,F._z=this._z-L,F._isDirty=!0,F}negate(){return new z(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(I){return I._x=-1*this._x,I._y=-1*this._y,I._z=-1*this._z,I._isDirty=!0,I}scaleInPlace(I){return this._x*=I,this._y*=I,this._z*=I,this._isDirty=!0,this}scale(I){return new z(this._x*I,this._y*I,this._z*I)}scaleToRef(I,x){return x._x=this._x*I,x._y=this._y*I,x._z=this._z*I,x._isDirty=!0,x}getNormalToRef(I){const x=this.length();let L=Math.acos(this._y/x);const F=Math.atan2(this._z,this._x);L>Math.PI/2?L-=Math.PI/2:L+=Math.PI/2;const X=x*Math.sin(L)*Math.cos(F),G=x*Math.cos(L),Y=x*Math.sin(L)*Math.sin(F);return I.set(X,G,Y),I}applyRotationQuaternionToRef(I,x){const L=this._x,F=this._y,X=this._z,G=I._x,Y=I._y,p=I._z,B=I._w,l=2*(Y*X-p*F),W=2*(p*L-G*X),Q=2*(G*F-Y*L);return x._x=L+B*l+Y*Q-p*W,x._y=F+B*W+p*l-G*Q,x._z=X+B*Q+G*W-Y*l,x._isDirty=!0,x}applyRotationQuaternionInPlace(I){return this.applyRotationQuaternionToRef(I,this)}applyRotationQuaternion(I){return this.applyRotationQuaternionToRef(I,new z)}scaleAndAddToRef(I,x){return x._x+=this._x*I,x._y+=this._y*I,x._z+=this._z*I,x._isDirty=!0,x}projectOnPlane(I,x){return this.projectOnPlaneToRef(I,x,new z)}projectOnPlaneToRef(I,x,L){const F=I.normal,X=I.d,G=q.sx[0];this.subtractToRef(x,G),G.normalize();const Y=z.Dot(G,F);if(Math.abs(Y)<1e-10)L.BB(1/0);else{const I=-(z.Dot(x,F)+X)/Y,p=G.scaleInPlace(I);x.addToRef(p,L)}return L}equals(I){return I&&this._x===I._x&&this._y===I._y&&this._z===I._z}equalsWithEpsilon(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:F.e;return I&&(0,B.WithinEpsilon)(this._x,I._x,x)&&(0,B.WithinEpsilon)(this._y,I._y,x)&&(0,B.WithinEpsilon)(this._z,I._z,x)}equalsToFloats(I,x,L){return this._x===I&&this._y===x&&this._z===L}multiplyInPlace(I){return this._x*=I._x,this._y*=I._y,this._z*=I._z,this._isDirty=!0,this}multiply(I){return this.multiplyByFloats(I._x,I._y,I._z)}multiplyToRef(I,x){return x._x=this._x*I._x,x._y=this._y*I._y,x._z=this._z*I._z,x._isDirty=!0,x}multiplyByFloats(I,x,L){return new z(this._x*I,this._y*x,this._z*L)}divide(I){return new z(this._x/I._x,this._y/I._y,this._z/I._z)}divideToRef(I,x){return x._x=this._x/I._x,x._y=this._y/I._y,x._z=this._z/I._z,x._isDirty=!0,x}divideInPlace(I){return this._x=this._x/I._x,this._y=this._y/I._y,this._z=this._z/I._z,this._isDirty=!0,this}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I._x,I._y,I._z)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I._x,I._y,I._z)}minimizeInPlaceFromFloats(I,x,L){return I<this._x&&(this.x=I),x<this._y&&(this.y=x),L<this._z&&(this.z=L),this}maximizeInPlaceFromFloats(I,x,L){return I>this._x&&(this.x=I),x>this._y&&(this.y=x),L>this._z&&(this.z=L),this}isNonUniformWithinEpsilon(I){const x=Math.abs(this._x),L=Math.abs(this._y);if(!(0,B.WithinEpsilon)(x,L,I))return!0;const F=Math.abs(this._z);return!(0,B.WithinEpsilon)(x,F,I)||!(0,B.WithinEpsilon)(L,F,I)}get isNonUniform(){const I=Math.abs(this._x);if(I!==Math.abs(this._y))return!0;return I!==Math.abs(this._z)}floorToRef(I){return I._x=Math.floor(this._x),I._y=Math.floor(this._y),I._z=Math.floor(this._z),I._isDirty=!0,I}floor(){return new z(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(I){return I._x=this._x-Math.floor(this._x),I._y=this._y-Math.floor(this._y),I._z=this._z-Math.floor(this._z),I._isDirty=!0,I}fract(){return new z(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(I){if("xyz"===(I=I.toLowerCase()))return this;const x=q.sx[0].X(this);return this.x=x[I[0]],this.y=x[I[1]],this.z=x[I[2]],this}rotateByQuaternionToRef(I,x){return I.toRotationMatrix(q.Matrix[0]),z.TransformCoordinatesToRef(this,q.Matrix[0],x),x}rotateByQuaternionAroundPointToRef(I,x,L){return this.subtractToRef(x,q.sx[0]),q.sx[0].rotateByQuaternionToRef(I,q.sx[0]),x.addToRef(q.sx[0],L),L}cross(I){return z.CrossToRef(this,I,new z)}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){return this.normalizeToRef(new z)}normalizeToRef(I){const x=this.length();return 0===x||1===x?(I._x=this._x,I._y=this._y,I._z=this._z,I._isDirty=!0,I):this.scaleToRef(1/x,I)}clone(){return new z(this._x,this._y,this._z)}X(I){return this.YB(I._x,I._y,I._z)}YB(I,x,L){return this._x=I,this._y=x,this._z=L,this._isDirty=!0,this}set(I,x,L){return this.YB(I,x,L)}BB(I){return this._x=this._y=this._z=I,this._isDirty=!0,this}static GetClipFactor(I,x,L,F){const X=z.Dot(I,L);return(X-F)/(X-z.Dot(x,L))}static GetAngleBetweenVectors(I,x,L){const F=I.normalizeToRef(q.sx[1]),X=x.normalizeToRef(q.sx[2]);let G=z.Dot(F,X);G=(0,B.Clamp)(G,-1,1);const Y=Math.acos(G),p=q.sx[3];return z.CrossToRef(F,X,p),z.Dot(p,L)>0?isNaN(Y)?0:Y:isNaN(Y)?-Math.PI:-Math.acos(G)}static GetAngleBetweenVectorsOnPlane(I,x,L){q.sx[0].X(I);const F=q.sx[0];q.sx[1].X(x);const X=q.sx[1];q.sx[2].X(L);const G=q.sx[2],Y=q.sx[3],p=q.sx[4];F.normalize(),X.normalize(),G.normalize(),z.CrossToRef(G,F,Y),z.CrossToRef(Y,G,p);const l=Math.atan2(z.Dot(X,Y),z.Dot(X,p));return(0,B.NormalizeRadians)(l)}static PitchYawRollToMoveBetweenPointsToRef(I,x,L){const F=y.sx[0];return x.subtractToRef(I,F),L._y=Math.atan2(F.x,F.z)||0,L._x=Math.atan2(Math.sqrt(F.x**2+F.z**2),F.y)||0,L._z=0,L._isDirty=!0,L}static PitchYawRollToMoveBetweenPoints(I,x){const L=z.Zero();return z.PitchYawRollToMoveBetweenPointsToRef(I,x,L)}static SlerpToRef(I,x,L,X){L=(0,B.Clamp)(L,0,1);const G=q.sx[0],Y=q.sx[1];G.X(I);const p=G.length();G.normalizeFromLength(p),Y.X(x);const l=Y.length();Y.normalizeFromLength(l);const W=z.Dot(G,Y);let Q,e;if(W<1-F.e){const I=Math.acos(W),x=1/Math.sin(I);Q=Math.sin((1-L)*I)*x,e=Math.sin(L*I)*x}else Q=1-L,e=L;return G.scaleInPlace(Q),Y.scaleInPlace(e),X.X(G).addInPlace(Y),X.scaleInPlace((0,B.Lerp)(p,l,L)),X}static SmoothToRef(I,x,L,F,X){return z.SlerpToRef(I,x,0===F?1:L/F,X),X}static tx(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new z(I[x],I[x+1],I[x+2])}static FromFloatArray(I,x){return z.tx(I,x)}static FromArrayToRef(I,x,L){return L._x=I[x],L._y=I[x+1],L._z=I[x+2],L._isDirty=!0,L}static FromFloatArrayToRef(I,x,L){return z.FromArrayToRef(I,x,L)}static FromFloatsToRef(I,x,L,F){return F.YB(I,x,L),F}static Zero(){return new z(0,0,0)}static One(){return new z(1,1,1)}static Up(){return new z(0,1,0)}static get UpReadOnly(){return z._UpReadOnly}static get DownReadOnly(){return z._DownReadOnly}static get RightReadOnly(){return z._RightReadOnly}static get LeftReadOnly(){return z._LeftReadOnly}static get LeftHandedForwardReadOnly(){return z._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return z._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return z._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return z._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return z._ZeroReadOnly}static get OneReadOnly(){return z._OneReadOnly}static Down(){return new z(0,-1,0)}static Forward(){return new z(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new z(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new z(1,0,0)}static Left(){return new z(-1,0,0)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new z((0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).YB((0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x))}static TransformCoordinates(I,x){const L=z.Zero();return z.TransformCoordinatesToRef(I,x,L),L}static TransformCoordinatesToRef(I,x,L){return z.TransformCoordinatesFromFloatsToRef(I._x,I._y,I._z,x,L),L}static TransformCoordinatesFromFloatsToRef(I,x,L,F,X){const G=F.m,Y=I*G[0]+x*G[4]+L*G[8]+G[12],p=I*G[1]+x*G[5]+L*G[9]+G[13],B=I*G[2]+x*G[6]+L*G[10]+G[14],l=1/(I*G[3]+x*G[7]+L*G[11]+G[15]);return X._x=Y*l,X._y=p*l,X._z=B*l,X._isDirty=!0,X}static TransformNormal(I,x){const L=z.Zero();return z.TransformNormalToRef(I,x,L),L}static TransformNormalToRef(I,x,L){return this.TransformNormalFromFloatsToRef(I._x,I._y,I._z,x,L),L}static TransformNormalFromFloatsToRef(I,x,L,F,X){const G=F.m;return X._x=I*G[0]+x*G[4]+L*G[8],X._y=I*G[1]+x*G[5]+L*G[9],X._z=I*G[2]+x*G[6]+L*G[10],X._isDirty=!0,X}static CatmullRom(I,x,L,F,X){const G=X*X,Y=X*G,p=.5*(2*x._x+(-I._x+L._x)*X+(2*I._x-5*x._x+4*L._x-F._x)*G+(-I._x+3*x._x-3*L._x+F._x)*Y),B=.5*(2*x._y+(-I._y+L._y)*X+(2*I._y-5*x._y+4*L._y-F._y)*G+(-I._y+3*x._y-3*L._y+F._y)*Y),l=.5*(2*x._z+(-I._z+L._z)*X+(2*I._z-5*x._z+4*L._z-F._z)*G+(-I._z+3*x._z-3*L._z+F._z)*Y);return new z(p,B,l)}static Clamp(I,x,L){const F=new z;return z.ClampToRef(I,x,L,F),F}static ClampToRef(I,x,L,F){let X=I._x;X=X>L._x?L._x:X,X=X<x._x?x._x:X;let G=I._y;G=G>L._y?L._y:G,G=G<x._y?x._y:G;let Y=I._z;return Y=Y>L._z?L._z:Y,Y=Y<x._z?x._z:Y,F.YB(X,G,Y),F}static CheckExtends(I,x,L){x.minimizeInPlace(I),L.maximizeInPlace(I)}static Hermite(I,x,L,F,X){const G=X*X,Y=X*G,p=2*Y-3*G+1,B=-2*Y+3*G,l=Y-2*G+X,W=Y-G,Q=I._x*p+L._x*B+x._x*l+F._x*W,e=I._y*p+L._y*B+x._y*l+F._y*W,g=I._z*p+L._z*B+x._z*l+F._z*W;return new z(Q,e,g)}static Hermite1stDerivative(I,x,L,F,X){const G=new z;return this.Hermite1stDerivativeToRef(I,x,L,F,X,G),G}static Hermite1stDerivativeToRef(I,x,L,F,X,G){const Y=X*X;return G._x=6*(Y-X)*I._x+(3*Y-4*X+1)*x._x+6*(-Y+X)*L._x+(3*Y-2*X)*F._x,G._y=6*(Y-X)*I._y+(3*Y-4*X+1)*x._y+6*(-Y+X)*L._y+(3*Y-2*X)*F._y,G._z=6*(Y-X)*I._z+(3*Y-4*X+1)*x._z+6*(-Y+X)*L._z+(3*Y-2*X)*F._z,G._isDirty=!0,G}static Lerp(I,x,L){const F=new z(0,0,0);return z.LerpToRef(I,x,L,F),F}static LerpToRef(I,x,L,F){return F._x=I._x+(x._x-I._x)*L,F._y=I._y+(x._y-I._y)*L,F._z=I._z+(x._z-I._z)*L,F._isDirty=!0,F}static Dot(I,x){return I._x*x._x+I._y*x._y+I._z*x._z}dot(I){return this._x*I._x+this._y*I._y+this._z*I._z}static Cross(I,x){const L=new z;return z.CrossToRef(I,x,L),L}static CrossToRef(I,x,L){const F=I._y*x._z-I._z*x._y,X=I._z*x._x-I._x*x._z,G=I._x*x._y-I._y*x._x;return L.YB(F,X,G),L}static Normalize(I){const x=z.Zero();return z.NormalizeToRef(I,x),x}static NormalizeToRef(I,x){return I.normalizeToRef(x),x}static Project(I,x,L,F){const X=new z;return z.ProjectToRef(I,x,L,F,X),X}static ProjectToRef(I,x,L,F,X){var G;const Y=F.width,B=F.height,l=F.x,W=F.y,Q=q.Matrix[1],e=null===(G=p.e.LastCreatedEngine)||void 0===G?void 0:G.isNDCHalfZRange,g=e?1:.5,v=e?0:.5;U.FromValuesToRef(Y/2,0,0,0,0,-B/2,0,0,0,0,g,0,l+Y/2,B/2+W,v,1,Q);const H=q.Matrix[0];return x.multiplyToRef(L,H),H.multiplyToRef(Q,H),z.TransformCoordinatesToRef(I,H,X),X}static Reflect(I,x){return this.ReflectToRef(I,x,new z)}static ReflectToRef(I,x,L){const F=y.sx[0];return F.X(x).scaleInPlace(2*z.Dot(I,x)),L.X(I).aQ(F)}static _UnprojectFromInvertedMatrixToRef(I,x,L){z.TransformCoordinatesToRef(I,x,L);const F=x.m,X=I._x*F[3]+I._y*F[7]+I._z*F[11]+F[15];return(0,B.WithinEpsilon)(X,1)&&L.scaleInPlace(1/X),L}static UnprojectFromTransform(I,x,L,F,X){return this.Unproject(I,x,L,F,X,U.IdentityReadOnly)}static Unproject(I,x,L,F,X,G){const Y=new z;return z.UnprojectToRef(I,x,L,F,X,G,Y),Y}static UnprojectToRef(I,x,L,F,X,G,Y){return z.UnprojectFloatsToRef(I._x,I._y,I._z,x,L,F,X,G,Y),Y}static UnprojectFloatsToRef(I,x,L,F,X,G,Y,B,l){var W;const Q=q.Matrix[0];G.multiplyToRef(Y,Q),Q.multiplyToRef(B,Q),Q.invert();const e=q.sx[0];return e.x=I/F*2-1,e.y=-(x/X*2-1),null!==(W=p.e.LastCreatedEngine)&&void 0!==W&&W.isNDCHalfZRange?e.z=L:e.z=2*L-1,z._UnprojectFromInvertedMatrixToRef(e,Q,l),l}static Minimize(I,x){const L=new z;return L.X(I),L.minimizeInPlace(x),L}static Maximize(I,x){const L=new z;return L.X(I),L.maximizeInPlace(x),L}static Distance(I,x){return Math.sqrt(z.DistanceSquared(I,x))}static DistanceSquared(I,x){const L=I._x-x._x,F=I._y-x._y,X=I._z-x._z;return L*L+F*F+X*X}static ProjectOnTriangleToRef(I,x,L,X,G){const Y=q.sx[0],p=q.sx[1],l=q.sx[2],W=q.sx[3],Q=q.sx[4];L.subtractToRef(x,Y),X.subtractToRef(x,p),X.subtractToRef(L,l);const e=Y.length(),g=p.length(),v=l.length();if(e<F.e||g<F.e||v<F.e)return G.X(x),z.Distance(I,x);I.subtractToRef(x,Q),z.CrossToRef(Y,p,W);const H=W.length();if(H<F.e)return G.X(x),z.Distance(I,x);W.normalizeFromLength(H);let s=Q.length();if(s<F.e)return G.X(x),0;Q.normalizeFromLength(s);const U=z.Dot(W,Q),y=q.sx[5],T=q.sx[6];y.X(W).scaleInPlace(-s*U),T.X(I).addInPlace(y);const Z=q.sx[4],t=q.sx[5],f=q.sx[7],R=q.sx[8];Z.X(Y).scaleInPlace(1/e),R.X(p).scaleInPlace(1/g),Z.addInPlace(R).scaleInPlace(-1),t.X(Y).scaleInPlace(-1/e),R.X(l).scaleInPlace(1/v),t.addInPlace(R).scaleInPlace(-1),f.X(l).scaleInPlace(-1/v),R.X(p).scaleInPlace(-1/g),f.addInPlace(R).scaleInPlace(-1);const n=q.sx[9];let P;n.X(T).aQ(x),z.CrossToRef(Z,n,R),P=z.Dot(R,W);const d=P;n.X(T).aQ(L),z.CrossToRef(t,n,R),P=z.Dot(R,W);const M=P;n.X(T).aQ(X),z.CrossToRef(f,n,R),P=z.Dot(R,W);const K=P,u=q.sx[10];let A,mI;d>0&&M<0?(u.X(Y),A=x,mI=L):M>0&&K<0?(u.X(l),A=L,mI=X):(u.X(p).scaleInPlace(-1),A=X,mI=x);const O=q.sx[9],w=q.sx[4];A.subtractToRef(T,R),mI.subtractToRef(T,O),z.CrossToRef(R,O,w);if(!(z.Dot(w,W)<0))return G.X(T),Math.abs(s*U);const k=q.sx[5];z.CrossToRef(u,w,k),k.normalize();const a=q.sx[9];a.X(A).aQ(T);const D=a.length();if(D<F.e)return G.X(A),z.Distance(I,A);a.normalizeFromLength(D);const r=z.Dot(k,a),N=q.sx[7];N.X(T).addInPlace(k.scaleInPlace(D*r)),R.X(N).aQ(A),s=u.length(),u.normalizeFromLength(s);let S=z.Dot(R,u)/Math.max(s,F.e);return S=(0,B.Clamp)(S,0,1),N.X(A).addInPlace(u.scaleInPlace(S*s)),G.X(N),z.Distance(I,N)}static Center(I,x){return z.CenterToRef(I,x,z.Zero())}static CenterToRef(I,x,L){return L.YB((I._x+x._x)/2,(I._y+x._y)/2,(I._z+x._z)/2)}static RotationFromAxis(I,x,L){const F=new z;return z.RotationFromAxisToRef(I,x,L,F),F}static RotationFromAxisToRef(I,x,L,F){const X=q.Quaternion[0];return s.RotationQuaternionFromAxisToRef(I,x,L,X),X.toEulerAnglesToRef(F),F}}z._V8PerformanceHack=new z(.5,.5,.5),z._UpReadOnly=z.Up(),z._DownReadOnly=z.Down(),z._LeftHandedForwardReadOnly=z.Forward(!1),z._RightHandedForwardReadOnly=z.Forward(!0),z._LeftHandedBackwardReadOnly=z.Backward(!1),z._RightHandedBackwardReadOnly=z.Backward(!0),z._RightReadOnly=z.Right(),z._LeftReadOnly=z.Left(),z._ZeroReadOnly=z.Zero(),z._OneReadOnly=z.One(),Object.defineProperties(z.prototype,{dimension:{value:[3]},rank:{value:1}});class H{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}get w(){return this._w}set w(I){this._w=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=I,this._y=x,this._z=L,this._w=F}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let I=g(this._x);return I=397*I^g(this._y),I=397*I^g(this._z),I=397*I^g(this._w),I}Cp(){return[this._x,this._y,this._z,this._w]}toArray(I,x){return void 0===x&&(x=0),I[x]=this._x,I[x+1]=this._y,I[x+2]=this._z,I[x+3]=this._w,this}PL(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H.FromArrayToRef(I,x,this),this}addInPlace(I){return this.x+=I._x,this.y+=I._y,this.z+=I._z,this.w+=I._w,this}addInPlaceFromFloats(I,x,L,F){return this.x+=I,this.y+=x,this.z+=L,this.w+=F,this}add(I){return new H(this._x+I.x,this._y+I.y,this._z+I.z,this._w+I.w)}addToRef(I,x){return x.x=this._x+I.x,x.y=this._y+I.y,x.z=this._z+I.z,x.w=this._w+I.w,x}aQ(I){return this.x-=I.x,this.y-=I.y,this.z-=I.z,this.w-=I.w,this}Ux(I){return new H(this._x-I.x,this._y-I.y,this._z-I.z,this._w-I.w)}subtractToRef(I,x){return x.x=this._x-I.x,x.y=this._y-I.y,x.z=this._z-I.z,x.w=this._w-I.w,x}subtractFromFloats(I,x,L,F){return new H(this._x-I,this._y-x,this._z-L,this._w-F)}subtractFromFloatsToRef(I,x,L,F,X){return X.x=this._x-I,X.y=this._y-x,X.z=this._z-L,X.w=this._w-F,X}negate(){return new H(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(I){return I.x=-this._x,I.y=-this._y,I.z=-this._z,I.w=-this._w,I}scaleInPlace(I){return this.x*=I,this.y*=I,this.z*=I,this.w*=I,this}scale(I){return new H(this._x*I,this._y*I,this._z*I,this._w*I)}scaleToRef(I,x){return x.x=this._x*I,x.y=this._y*I,x.z=this._z*I,x.w=this._w*I,x}scaleAndAddToRef(I,x){return x.x+=this._x*I,x.y+=this._y*I,x.z+=this._z*I,x.w+=this._w*I,x}equals(I){return I&&this._x===I.x&&this._y===I.y&&this._z===I.z&&this._w===I.w}equalsWithEpsilon(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:F.e;return I&&(0,B.WithinEpsilon)(this._x,I.x,x)&&(0,B.WithinEpsilon)(this._y,I.y,x)&&(0,B.WithinEpsilon)(this._z,I.z,x)&&(0,B.WithinEpsilon)(this._w,I.w,x)}equalsToFloats(I,x,L,F){return this._x===I&&this._y===x&&this._z===L&&this._w===F}multiplyInPlace(I){return this.x*=I.x,this.y*=I.y,this.z*=I.z,this.w*=I.w,this}multiply(I){return new H(this._x*I.x,this._y*I.y,this._z*I.z,this._w*I.w)}multiplyToRef(I,x){return x.x=this._x*I.x,x.y=this._y*I.y,x.z=this._z*I.z,x.w=this._w*I.w,x}multiplyByFloats(I,x,L,F){return new H(this._x*I,this._y*x,this._z*L,this._w*F)}divide(I){return new H(this._x/I.x,this._y/I.y,this._z/I.z,this._w/I.w)}divideToRef(I,x){return x.x=this._x/I.x,x.y=this._y/I.y,x.z=this._z/I.z,x.w=this._w/I.w,x}divideInPlace(I){return this.divideToRef(I,this)}minimizeInPlace(I){return I.x<this._x&&(this.x=I.x),I.y<this._y&&(this.y=I.y),I.z<this._z&&(this.z=I.z),I.w<this._w&&(this.w=I.w),this}maximizeInPlace(I){return I.x>this._x&&(this.x=I.x),I.y>this._y&&(this.y=I.y),I.z>this._z&&(this.z=I.z),I.w>this._w&&(this.w=I.w),this}minimizeInPlaceFromFloats(I,x,L,F){return this.x=Math.min(I,this._x),this.y=Math.min(x,this._y),this.z=Math.min(L,this._z),this.w=Math.min(F,this._w),this}maximizeInPlaceFromFloats(I,x,L,F){return this.x=Math.max(I,this._x),this.y=Math.max(x,this._y),this.z=Math.max(L,this._z),this.w=Math.max(F,this._w),this}floorToRef(I){return I.x=Math.floor(this._x),I.y=Math.floor(this._y),I.z=Math.floor(this._z),I.w=Math.floor(this._w),I}floor(){return new H(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(I){return I.x=this._x-Math.floor(this._x),I.y=this._y-Math.floor(this._y),I.z=this._z-Math.floor(this._z),I.w=this._w-Math.floor(this._w),I}fract(){return new H(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){return this.normalizeToRef(new H)}normalizeToRef(I){const x=this.length();return 0===x||1===x?(I.x=this._x,I.y=this._y,I.z=this._z,I.w=this._w,I):this.scaleToRef(1/x,I)}toVector3(){return new z(this._x,this._y,this._z)}clone(){return new H(this._x,this._y,this._z,this._w)}X(I){return this.x=I.x,this.y=I.y,this.z=I.z,this.w=I.w,this}YB(I,x,L,F){return this.x=I,this.y=x,this.z=L,this.w=F,this}set(I,x,L,F){return this.YB(I,x,L,F)}BB(I){return this.x=this.y=this.z=this.w=I,this}dot(I){return this._x*I.x+this._y*I.y+this._z*I.z+this._w*I.w}static tx(I,x){return x||(x=0),new H(I[x],I[x+1],I[x+2],I[x+3])}static FromArrayToRef(I,x,L){return L.x=I[x],L.y=I[x+1],L.z=I[x+2],L.w=I[x+3],L}static FromFloatArrayToRef(I,x,L){return H.FromArrayToRef(I,x,L),L}static FromFloatsToRef(I,x,L,F,X){return X.x=I,X.y=x,X.z=L,X.w=F,X}static Zero(){return new H(0,0,0,0)}static One(){return new H(1,1,1,1)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new H((0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,L=arguments.length>2?arguments[2]:void 0;return L.x=(0,B.RandomRange)(I,x),L.y=(0,B.RandomRange)(I,x),L.z=(0,B.RandomRange)(I,x),L.w=(0,B.RandomRange)(I,x),L}static Clamp(I,x,L){return H.ClampToRef(I,x,L,new H)}static ClampToRef(I,x,L,F){return F.x=(0,B.Clamp)(I.x,x.x,L.x),F.y=(0,B.Clamp)(I.y,x.y,L.y),F.z=(0,B.Clamp)(I.z,x.z,L.z),F.w=(0,B.Clamp)(I.w,x.w,L.w),F}static CheckExtends(I,x,L){x.minimizeInPlace(I),L.maximizeInPlace(I)}static get ZeroReadOnly(){return H._ZeroReadOnly}static Normalize(I){return H.NormalizeToRef(I,new H)}static NormalizeToRef(I,x){return I.normalizeToRef(x),x}static Minimize(I,x){const L=new H;return L.X(I),L.minimizeInPlace(x),L}static Maximize(I,x){const L=new H;return L.X(I),L.maximizeInPlace(x),L}static Distance(I,x){return Math.sqrt(H.DistanceSquared(I,x))}static DistanceSquared(I,x){const L=I.x-x.x,F=I.y-x.y,X=I.z-x.z,G=I.w-x.w;return L*L+F*F+X*X+G*G}static Center(I,x){return H.CenterToRef(I,x,new H)}static CenterToRef(I,x,L){return L.x=(I.x+x.x)/2,L.y=(I.y+x.y)/2,L.z=(I.z+x.z)/2,L.w=(I.w+x.w)/2,L}static TransformCoordinates(I,x){return H.TransformCoordinatesToRef(I,x,new H)}static TransformCoordinatesToRef(I,x,L){return H.TransformCoordinatesFromFloatsToRef(I._x,I._y,I._z,x,L),L}static TransformCoordinatesFromFloatsToRef(I,x,L,F,X){const G=F.m,Y=I*G[0]+x*G[4]+L*G[8]+G[12],p=I*G[1]+x*G[5]+L*G[9]+G[13],B=I*G[2]+x*G[6]+L*G[10]+G[14],l=I*G[3]+x*G[7]+L*G[11]+G[15];return X.x=Y,X.y=p,X.z=B,X.w=l,X}static TransformNormal(I,x){return H.TransformNormalToRef(I,x,new H)}static TransformNormalToRef(I,x,L){const F=x.m,X=I.x*F[0]+I.y*F[4]+I.z*F[8],G=I.x*F[1]+I.y*F[5]+I.z*F[9],Y=I.x*F[2]+I.y*F[6]+I.z*F[10];return L.x=X,L.y=G,L.z=Y,L.w=I.w,L}static TransformNormalFromFloatsToRef(I,x,L,F,X,G){const Y=X.m;return G.x=I*Y[0]+x*Y[4]+L*Y[8],G.y=I*Y[1]+x*Y[5]+L*Y[9],G.z=I*Y[2]+x*Y[6]+L*Y[10],G.w=F,G}static FromVector3(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new H(I._x,I._y,I._z,x)}static Dot(I,x){return I.x*x.x+I.y*x.y+I.z*x.z+I.w*x.w}}H._V8PerformanceHack=new H(.5,.5,.5,.5),H._ZeroReadOnly=H.Zero(),Object.defineProperties(H.prototype,{dimension:{value:[4]},rank:{value:1}});class s{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}get w(){return this._w}set w(I){this._w=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=I,this._y=x,this._z=L,this._w=F}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let I=g(this._x);return I=397*I^g(this._y),I=397*I^g(this._z),I=397*I^g(this._w),I}Cp(){return[this._x,this._y,this._z,this._w]}toArray(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[x]=this._x,I[x+1]=this._y,I[x+2]=this._z,I[x+3]=this._w,this}PL(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return s.FromArrayToRef(I,x,this)}equals(I){return I&&this._x===I._x&&this._y===I._y&&this._z===I._z&&this._w===I._w}equalsWithEpsilon(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:F.e;return I&&(0,B.WithinEpsilon)(this._x,I._x,x)&&(0,B.WithinEpsilon)(this._y,I._y,x)&&(0,B.WithinEpsilon)(this._z,I._z,x)&&(0,B.WithinEpsilon)(this._w,I._w,x)}isApprox(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:F.e;return I&&((0,B.WithinEpsilon)(this._x,I._x,x)&&(0,B.WithinEpsilon)(this._y,I._y,x)&&(0,B.WithinEpsilon)(this._z,I._z,x)&&(0,B.WithinEpsilon)(this._w,I._w,x)||(0,B.WithinEpsilon)(this._x,-I._x,x)&&(0,B.WithinEpsilon)(this._y,-I._y,x)&&(0,B.WithinEpsilon)(this._z,-I._z,x)&&(0,B.WithinEpsilon)(this._w,-I._w,x))}clone(){return new s(this._x,this._y,this._z,this._w)}X(I){return this._x=I._x,this._y=I._y,this._z=I._z,this._w=I._w,this._isDirty=!0,this}YB(I,x,L,F){return this._x=I,this._y=x,this._z=L,this._w=F,this._isDirty=!0,this}set(I,x,L,F){return this.YB(I,x,L,F)}BB(I){return this.YB(I,I,I,I)}add(I){return new s(this._x+I._x,this._y+I._y,this._z+I._z,this._w+I._w)}addInPlace(I){return this._x+=I._x,this._y+=I._y,this._z+=I._z,this._w+=I._w,this._isDirty=!0,this}addToRef(I,x){return x._x=this._x+I._x,x._y=this._y+I._y,x._z=this._z+I._z,x._w=this._w+I._w,x._isDirty=!0,x}addInPlaceFromFloats(I,x,L,F){return this._x+=I,this._y+=x,this._z+=L,this._w+=F,this._isDirty=!0,this}subtractToRef(I,x){return x._x=this._x-I._x,x._y=this._y-I._y,x._z=this._z-I._z,x._w=this._w-I._w,x._isDirty=!0,x}subtractFromFloats(I,x,L,F){return this.subtractFromFloatsToRef(I,x,L,F,new s)}subtractFromFloatsToRef(I,x,L,F,X){return X._x=this._x-I,X._y=this._y-x,X._z=this._z-L,X._w=this._w-F,X._isDirty=!0,X}Ux(I){return new s(this._x-I._x,this._y-I._y,this._z-I._z,this._w-I._w)}aQ(I){return this._x-=I._x,this._y-=I._y,this._z-=I._z,this._w-=I._w,this._isDirty=!0,this}scale(I){return new s(this._x*I,this._y*I,this._z*I,this._w*I)}scaleToRef(I,x){return x._x=this._x*I,x._y=this._y*I,x._z=this._z*I,x._w=this._w*I,x._isDirty=!0,x}scaleInPlace(I){return this._x*=I,this._y*=I,this._z*=I,this._w*=I,this._isDirty=!0,this}scaleAndAddToRef(I,x){return x._x+=this._x*I,x._y+=this._y*I,x._z+=this._z*I,x._w+=this._w*I,x._isDirty=!0,x}multiply(I){const x=new s(0,0,0,1);return this.multiplyToRef(I,x),x}multiplyToRef(I,x){const L=this._x*I._w+this._y*I._z-this._z*I._y+this._w*I._x,F=-this._x*I._z+this._y*I._w+this._z*I._x+this._w*I._y,X=this._x*I._y-this._y*I._x+this._z*I._w+this._w*I._z,G=-this._x*I._x-this._y*I._y-this._z*I._z+this._w*I._w;return x.YB(L,F,X,G),x}multiplyInPlace(I){return this.multiplyToRef(I,this)}multiplyByFloats(I,x,L,F){return this._x*=I,this._y*=x,this._z*=L,this._w*=F,this._isDirty=!0,this}divide(I){throw new ReferenceError("Can not divide a quaternion")}divideToRef(I,x){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(I){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new s)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(I){return I._x=-this._x,I._y=-this._y,I._z=-this._z,I._w=-this._w,I._isDirty=!0,I}equalsToFloats(I,x,L,F){return this._x===I&&this._y===x&&this._z===L&&this._w===F}floorToRef(I){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(I){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(I){return I.YB(-this._x,-this._y,-this._z,this._w),I}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new s(-this._x,-this._y,-this._z,this._w)}invert(){const I=this.conjugate(),x=this.lengthSquared();return 0==x||1==x||I.scaleInPlace(1/x),I}invertInPlace(){this.conjugateInPlace();const I=this.lengthSquared();return 0==I||1==I||this.scaleInPlace(1/I),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){const I=new s(0,0,0,1);return this.normalizeToRef(I),I}normalizeToRef(I){const x=this.length();return 0===x||1===x?I.YB(this._x,this._y,this._z,this._w):this.scaleToRef(1/x,I)}toEulerAngles(){const I=z.Zero();return this.toEulerAnglesToRef(I),I}toEulerAnglesToRef(I){const x=this._z,L=this._x,F=this._y,X=this._w,G=F*x-L*X,Y=.4999999;if(G<-Y)I._y=2*Math.atan2(F,X),I._x=Math.PI/2,I._z=0,I._isDirty=!0;else if(G>Y)I._y=2*Math.atan2(F,X),I._x=-Math.PI/2,I._z=0,I._isDirty=!0;else{const Y=X*X,p=x*x,B=L*L,l=F*F;I._z=Math.atan2(2*(L*F+x*X),-p-B+l+Y),I._x=Math.asin(-2*G),I._y=Math.atan2(2*(x*L+F*X),p-B-l+Y),I._isDirty=!0}return I}toAlphaBetaGammaToRef(I){const x=this._z,L=this._x,F=this._y,X=this._w,G=Math.sqrt(L*L+F*F),Y=Math.sqrt(x*x+X*X),p=2*Math.atan2(G,Y),B=2*Math.atan2(x,X),l=2*Math.atan2(F,L),W=(B+l)/2,Q=(B-l)/2;return I.set(Q,p,W),I}toRotationMatrix(I){return U.FromQuaternionToRef(this,I),I}fromRotationMatrix(I){return s.FromRotationMatrixToRef(I,this),this}dot(I){return this._x*I._x+this._y*I._y+this._z*I._z+this._w*I._w}toAxisAngle(){const I=z.Zero();return{axis:I,angle:this.toAxisAngleToRef(I)}}toAxisAngleToRef(I){let x=0;const L=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),F=this._w;return L>0?(x=2*Math.atan2(L,F),I.set(this._x/L,this._y/L,this._z/L)):(x=0,I.set(1,0,0)),x}static FromRotationMatrix(I){const x=new s;return s.FromRotationMatrixToRef(I,x),x}static FromRotationMatrixToRef(I,x){const L=I.m,F=L[0],X=L[4],G=L[8],Y=L[1],p=L[5],B=L[9],l=L[2],W=L[6],Q=L[10],e=F+p+Q;let g;return e>0?(g=.5/Math.sqrt(e+1),x._w=.25/g,x._x=(W-B)*g,x._y=(G-l)*g,x._z=(Y-X)*g,x._isDirty=!0):F>p&&F>Q?(g=2*Math.sqrt(1+F-p-Q),x._w=(W-B)/g,x._x=.25*g,x._y=(X+Y)/g,x._z=(G+l)/g,x._isDirty=!0):p>Q?(g=2*Math.sqrt(1+p-F-Q),x._w=(G-l)/g,x._x=(X+Y)/g,x._y=.25*g,x._z=(B+W)/g,x._isDirty=!0):(g=2*Math.sqrt(1+Q-F-p),x._w=(Y-X)/g,x._x=(G+l)/g,x._y=(B+W)/g,x._z=.25*g,x._isDirty=!0),x}static Dot(I,x){return I._x*x._x+I._y*x._y+I._z*x._z+I._w*x._w}static AreClose(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const F=s.Dot(I,x);return 1-F*F<=L}static SmoothToRef(I,x,L,F,X){let G=0===F?1:L/F;return G=(0,B.Clamp)(G,0,1),s.SlerpToRef(I,x,G,X),X}static Zero(){return new s(0,0,0,0)}static Inverse(I){return new s(-I._x,-I._y,-I._z,I._w)}static InverseToRef(I,x){return x.set(-I._x,-I._y,-I._z,I._w),x}static Identity(){return new s(0,0,0,1)}static IsIdentity(I){return I&&0===I._x&&0===I._y&&0===I._z&&1===I._w}static RotationAxis(I,x){return s.RotationAxisToRef(I,x,new s)}static RotationAxisToRef(I,x,L){L._w=Math.cos(x/2);const F=Math.sin(x/2)/I.length();return L._x=I._x*F,L._y=I._y*F,L._z=I._z*F,L._isDirty=!0,L}static tx(I,x){return x||(x=0),new s(I[x],I[x+1],I[x+2],I[x+3])}static FromArrayToRef(I,x,L){return L._x=I[x],L._y=I[x+1],L._z=I[x+2],L._w=I[x+3],L._isDirty=!0,L}static FromFloatsToRef(I,x,L,F,X){return X.YB(I,x,L,F),X}static FromEulerAngles(I,x,L){const F=new s;return s.RotationYawPitchRollToRef(x,I,L,F),F}static FromEulerAnglesToRef(I,x,L,F){return s.RotationYawPitchRollToRef(x,I,L,F),F}static FromEulerVector(I){const x=new s;return s.RotationYawPitchRollToRef(I._y,I._x,I._z,x),x}static FromEulerVectorToRef(I,x){return s.RotationYawPitchRollToRef(I._y,I._x,I._z,x),x}static FromUnitVectorsToRef(I,x,L){let X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:F.e;const G=z.Dot(I,x)+1;return G<X?Math.abs(I.x)>Math.abs(I.z)?L.set(-I.y,I.x,0,0):L.set(0,-I.z,I.y,0):(z.CrossToRef(I,x,y.sx[0]),L.set(y.sx[0].x,y.sx[0].y,y.sx[0].z,G)),L.normalize()}static RotationYawPitchRoll(I,x,L){const F=new s;return s.RotationYawPitchRollToRef(I,x,L,F),F}static RotationYawPitchRollToRef(I,x,L,F){const X=.5*L,G=.5*x,Y=.5*I,p=Math.sin(X),B=Math.cos(X),l=Math.sin(G),W=Math.cos(G),Q=Math.sin(Y),e=Math.cos(Y);return F._x=e*l*B+Q*W*p,F._y=Q*W*B-e*l*p,F._z=e*W*p-Q*l*B,F._w=e*W*B+Q*l*p,F._isDirty=!0,F}static RotationAlphaBetaGamma(I,x,L){const F=new s;return s.RotationAlphaBetaGammaToRef(I,x,L,F),F}static RotationAlphaBetaGammaToRef(I,x,L,F){const X=.5*(L+I),G=.5*(L-I),Y=.5*x;return F._x=Math.cos(G)*Math.sin(Y),F._y=Math.sin(G)*Math.sin(Y),F._z=Math.sin(X)*Math.cos(Y),F._w=Math.cos(X)*Math.cos(Y),F._isDirty=!0,F}static RotationQuaternionFromAxis(I,x,L){const F=new s(0,0,0,0);return s.RotationQuaternionFromAxisToRef(I,x,L,F),F}static RotationQuaternionFromAxisToRef(I,x,L,F){const X=q.Matrix[0];return I=I.normalizeToRef(q.sx[0]),x=x.normalizeToRef(q.sx[1]),L=L.normalizeToRef(q.sx[2]),U.FromXYZAxesToRef(I,x,L,X),s.FromRotationMatrixToRef(X,F),F}static FromLookDirectionLH(I,x){const L=new s;return s.FromLookDirectionLHToRef(I,x,L),L}static FromLookDirectionLHToRef(I,x,L){const F=q.Matrix[0];return U.LookDirectionLHToRef(I,x,F),s.FromRotationMatrixToRef(F,L),L}static FromLookDirectionRH(I,x){const L=new s;return s.FromLookDirectionRHToRef(I,x,L),L}static FromLookDirectionRHToRef(I,x,L){const F=q.Matrix[0];return U.LookDirectionRHToRef(I,x,F),s.FromRotationMatrixToRef(F,L)}static Slerp(I,x,L){const F=s.Identity();return s.SlerpToRef(I,x,L,F),F}static SlerpToRef(I,x,L,F){let X,G,Y=I._x*x._x+I._y*x._y+I._z*x._z+I._w*x._w,p=!1;if(Y<0&&(p=!0,Y=-Y),Y>.999999)G=1-L,X=p?-L:L;else{const I=Math.acos(Y),x=1/Math.sin(I);G=Math.sin((1-L)*I)*x,X=p?-Math.sin(L*I)*x:Math.sin(L*I)*x}return F._x=G*I._x+X*x._x,F._y=G*I._y+X*x._y,F._z=G*I._z+X*x._z,F._w=G*I._w+X*x._w,F._isDirty=!0,F}static Hermite(I,x,L,F,X){const G=X*X,Y=X*G,p=2*Y-3*G+1,B=-2*Y+3*G,l=Y-2*G+X,W=Y-G,Q=I._x*p+L._x*B+x._x*l+F._x*W,e=I._y*p+L._y*B+x._y*l+F._y*W,g=I._z*p+L._z*B+x._z*l+F._z*W,v=I._w*p+L._w*B+x._w*l+F._w*W;return new s(Q,e,g,v)}static Hermite1stDerivative(I,x,L,F,X){const G=new s;return this.Hermite1stDerivativeToRef(I,x,L,F,X,G),G}static Hermite1stDerivativeToRef(I,x,L,F,X,G){const Y=X*X;return G._x=6*(Y-X)*I._x+(3*Y-4*X+1)*x._x+6*(-Y+X)*L._x+(3*Y-2*X)*F._x,G._y=6*(Y-X)*I._y+(3*Y-4*X+1)*x._y+6*(-Y+X)*L._y+(3*Y-2*X)*F._y,G._z=6*(Y-X)*I._z+(3*Y-4*X+1)*x._z+6*(-Y+X)*L._z+(3*Y-2*X)*F._z,G._w=6*(Y-X)*I._w+(3*Y-4*X+1)*x._w+6*(-Y+X)*L._w+(3*Y-2*X)*F._w,G._isDirty=!0,G}static Normalize(I){const x=s.Zero();return s.NormalizeToRef(I,x),x}static NormalizeToRef(I,x){return I.normalizeToRef(x),x}static Clamp(I,x,L){const F=new s;return s.ClampToRef(I,x,L,F),F}static ClampToRef(I,x,L,F){return F.YB((0,B.Clamp)(I.x,x.x,L.x),(0,B.Clamp)(I.y,x.y,L.y),(0,B.Clamp)(I.z,x.z,L.z),(0,B.Clamp)(I.w,x.w,L.w))}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new s((0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).YB((0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x),(0,B.RandomRange)(I,x))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(I,x){return Math.sqrt(s.DistanceSquared(I,x))}static DistanceSquared(I,x){const L=I.x-x.x,F=I.y-x.y,X=I.z-x.z,G=I.w-x.w;return L*L+F*F+X*X+G*G}static Center(I,x){return s.CenterToRef(I,x,s.Zero())}static CenterToRef(I,x,L){return L.YB((I.x+x.x)/2,(I.y+x.y)/2,(I.z+x.z)/2,(I.w+x.w)/2)}}s._V8PerformanceHack=new s(.5,.5,.5,.5),Object.defineProperties(s.prototype,{dimension:{value:[4]},rank:{value:1}});class U{static get Use64Bits(){return Y.d.MatrixUse64Bits}get m(){return this.Jp}markAsUpdated(){this.updateFlag=l._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(I){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1],L=arguments.length>2&&void 0!==arguments[2]&&arguments[2],F=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=I,this._isIdentity3x2=I||L,this._isIdentityDirty=!this._isIdentity&&x,this._isIdentity3x2Dirty=!this._isIdentity3x2&&F}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,Y.d.MatrixTrackPrecisionChange&&Y.d.MatrixTrackedMatrices.push(this),this.Jp=new Y.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const I=this.Jp;this._isIdentity=1===I[0]&&0===I[1]&&0===I[2]&&0===I[3]&&0===I[4]&&1===I[5]&&0===I[6]&&0===I[7]&&0===I[8]&&0===I[9]&&1===I[10]&&0===I[11]&&0===I[12]&&0===I[13]&&0===I[14]&&1===I[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Jp[0]||1!==this.Jp[5]||1!==this.Jp[15]||0!==this.Jp[1]||0!==this.Jp[2]||0!==this.Jp[3]||0!==this.Jp[4]||0!==this.Jp[6]||0!==this.Jp[7]||0!==this.Jp[8]||0!==this.Jp[9]||0!==this.Jp[10]||0!==this.Jp[11]||0!==this.Jp[12]||0!==this.Jp[13]||0!==this.Jp[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const I=this.Jp,x=I[0],L=I[1],F=I[2],X=I[3],G=I[4],Y=I[5],p=I[6],B=I[7],l=I[8],W=I[9],Q=I[10],e=I[11],g=I[12],v=I[13],z=I[14],H=I[15],s=Q*H-z*e,U=W*H-v*e,q=W*z-v*Q,y=l*H-g*e,T=l*z-Q*g,Z=l*v-g*W;return x*+(Y*s-p*U+B*q)+L*-(G*s-p*y+B*T)+F*+(G*U-Y*y+B*Z)+X*-(G*q-Y*T+p*Z)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!I)return this.Jp;const L=this.Jp;for(let F=0;F<16;F++)I[x+F]=L[F];return this}Cp(){return this.Jp}PL(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U.FromArrayToRef(I,x,this)}YB(){for(var I=arguments.length,x=new Array(I),L=0;L<I;L++)x[L]=arguments[L];return U.FromArrayToRef(x,0,this)}set(){const I=this.Jp;for(let x=0;x<16;x++)I[x]=x<0||arguments.length<=x?void 0:arguments[x];return this.markAsUpdated(),this}BB(I){const x=this.Jp;for(let L=0;L<16;L++)x[L]=I;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return U.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(I){const x=new U;return this.addToRef(I,x),x}addToRef(I,x){const L=this.Jp,F=x.Jp,X=I.m;for(let G=0;G<16;G++)F[G]=L[G]+X[G];return x.markAsUpdated(),x}addToSelf(I){const x=this.Jp,L=I.m;return x[0]+=L[0],x[1]+=L[1],x[2]+=L[2],x[3]+=L[3],x[4]+=L[4],x[5]+=L[5],x[6]+=L[6],x[7]+=L[7],x[8]+=L[8],x[9]+=L[9],x[10]+=L[10],x[11]+=L[11],x[12]+=L[12],x[13]+=L[13],x[14]+=L[14],x[15]+=L[15],this.markAsUpdated(),this}addInPlace(I){const x=this.Jp,L=I.m;for(let F=0;F<16;F++)x[F]+=L[F];return this.markAsUpdated(),this}addInPlaceFromFloats(){const I=this.Jp;for(let x=0;x<16;x++)I[x]+=x<0||arguments.length<=x?void 0:arguments[x];return this.markAsUpdated(),this}Ux(I){const x=this.Jp,L=I.m;for(let F=0;F<16;F++)x[F]-=L[F];return this.markAsUpdated(),this}subtractToRef(I,x){const L=this.Jp,F=I.m,X=x.Jp;for(let G=0;G<16;G++)X[G]=L[G]-F[G];return x.markAsUpdated(),x}aQ(I){const x=this.Jp,L=I.m;for(let F=0;F<16;F++)x[F]-=L[F];return this.markAsUpdated(),this}subtractFromFloats(){for(var I=arguments.length,x=new Array(I),L=0;L<I;L++)x[L]=arguments[L];return this.subtractFromFloatsToRef(...x,new U)}subtractFromFloatsToRef(){for(var I=arguments.length,x=new Array(I),L=0;L<I;L++)x[L]=arguments[L];const F=x.pop(),X=this.Jp,G=F.Jp,Y=x;for(let p=0;p<16;p++)G[p]=X[p]-Y[p];return F.markAsUpdated(),F}invertToRef(I){return!0===this._isIdentity?(U.IdentityToRef(I),I):(e(this,I.Cp())?I.markAsUpdated():I.X(this),I)}addAtIndex(I,x){return this.Jp[I]+=x,this.markAsUpdated(),this}multiplyAtIndex(I,x){return this.Jp[I]*=x,this.markAsUpdated(),this}setTranslationFromFloats(I,x,L){return this.Jp[12]=I,this.Jp[13]=x,this.Jp[14]=L,this.markAsUpdated(),this}addTranslationFromFloats(I,x,L){return this.Jp[12]+=I,this.Jp[13]+=x,this.Jp[14]+=L,this.markAsUpdated(),this}setTranslation(I){return this.setTranslationFromFloats(I._x,I._y,I._z)}getTranslation(){return new z(this.Jp[12],this.Jp[13],this.Jp[14])}getTranslationToRef(I){return I.x=this.Jp[12],I.y=this.Jp[13],I.z=this.Jp[14],I}removeRotationAndScaling(){const I=this.m;return U.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,I[12],I[13],I[14],I[15],this),this._updateIdentityStatus(0===I[12]&&0===I[13]&&0===I[14]&&1===I[15]),this}X(I){I.copyToArray(this.Jp);const x=I;return this.updateFlag=x.updateFlag,this._updateIdentityStatus(x._isIdentity,x._isIdentityDirty,x._isIdentity3x2,x._isIdentity3x2Dirty),this}copyToArray(I){return Q(this,I,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(I){const x=new U;return this.multiplyToRef(I,x),x}multiplyInPlace(I){const x=this.Jp,L=I.m;for(let F=0;F<16;F++)x[F]*=L[F];return this.markAsUpdated(),this}multiplyByFloats(){const I=this.Jp;for(let x=0;x<16;x++)I[x]*=x<0||arguments.length<=x?void 0:arguments[x];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var I=arguments.length,x=new Array(I),L=0;L<I;L++)x[L]=arguments[L];const F=x.pop(),X=this.Jp,G=F.Jp,Y=x;for(let p=0;p<16;p++)G[p]=X[p]*Y[p];return F.markAsUpdated(),F}multiplyToRef(I,x){return this._isIdentity?(x.X(I),x):I._isIdentity?(x.X(this),x):(this.multiplyToArray(I,x.Jp,0),x.markAsUpdated(),x)}multiplyToArray(I,x,L){return W(this,I,x,L),this}divide(I){return this.divideToRef(I,new U)}divideToRef(I,x){const L=this.Jp,F=I.m,X=x.Jp;for(let G=0;G<16;G++)X[G]=L[G]/F[G];return x.markAsUpdated(),x}divideInPlace(I){const x=this.Jp,L=I.m;for(let F=0;F<16;F++)x[F]/=L[F];return this.markAsUpdated(),this}minimizeInPlace(I){const x=this.Jp,L=I.m;for(let F=0;F<16;F++)x[F]=Math.min(x[F],L[F]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const I=this.Jp;for(let x=0;x<16;x++)I[x]=Math.min(I[x],x<0||arguments.length<=x?void 0:arguments[x]);return this.markAsUpdated(),this}maximizeInPlace(I){const x=this.Jp,L=I.m;for(let F=0;F<16;F++)x[F]=Math.min(x[F],L[F]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const I=this.Jp;for(let x=0;x<16;x++)I[x]=Math.min(I[x],x<0||arguments.length<=x?void 0:arguments[x]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new U)}negateInPlace(){const I=this.Jp;for(let x=0;x<16;x++)I[x]=-I[x];return this.markAsUpdated(),this}negateToRef(I){const x=this.Jp,L=I.Jp;for(let F=0;F<16;F++)L[F]=-x[F];return I.markAsUpdated(),I}equals(I){const x=I;if(!x)return!1;if((this._isIdentity||x._isIdentity)&&!this._isIdentityDirty&&!x._isIdentityDirty)return this._isIdentity&&x._isIdentity;const L=this.m,F=x.m;return L[0]===F[0]&&L[1]===F[1]&&L[2]===F[2]&&L[3]===F[3]&&L[4]===F[4]&&L[5]===F[5]&&L[6]===F[6]&&L[7]===F[7]&&L[8]===F[8]&&L[9]===F[9]&&L[10]===F[10]&&L[11]===F[11]&&L[12]===F[12]&&L[13]===F[13]&&L[14]===F[14]&&L[15]===F[15]}equalsWithEpsilon(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const L=this.Jp,F=I.m;for(let X=0;X<16;X++)if(!(0,B.WithinEpsilon)(L[X],F[X],x))return!1;return!0}equalsToFloats(){const I=this.Jp;for(let x=0;x<16;x++)if(I[x]!=(x<0||arguments.length<=x?void 0:arguments[x]))return!1;return!0}floor(){return this.floorToRef(new U)}floorToRef(I){const x=this.Jp,L=I.Jp;for(let F=0;F<16;F++)L[F]=Math.floor(x[F]);return I.markAsUpdated(),I}fract(){return this.fractToRef(new U)}fractToRef(I){const x=this.Jp,L=I.Jp;for(let F=0;F<16;F++)L[F]=x[F]-Math.floor(x[F]);return I.markAsUpdated(),I}clone(){const I=new U;return I.X(this),I}getClassName(){return"Matrix"}getHashCode(){let I=g(this.Jp[0]);for(let x=1;x<16;x++)I=397*I^g(this.Jp[x]);return I}decomposeToTransformNode(I){return I.rotationQuaternion=I.rotationQuaternion||new s,this.decompose(I.pB,I.rotationQuaternion,I.position)}decompose(I,x,L,F){let X=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return L&&L.BB(0),I&&I.BB(1),x&&x.YB(0,0,0,1),!0;const G=this.Jp;if(L&&L.YB(G[12],G[13],G[14]),(I=I||q.sx[0]).x=Math.sqrt(G[0]*G[0]+G[1]*G[1]+G[2]*G[2]),I.y=Math.sqrt(G[4]*G[4]+G[5]*G[5]+G[6]*G[6]),I.z=Math.sqrt(G[8]*G[8]+G[9]*G[9]+G[10]*G[10]),F){const x=(X?F.absoluteScaling.x:F.pB.x)<0?-1:1,L=(X?F.absoluteScaling.y:F.pB.y)<0?-1:1,G=(X?F.absoluteScaling.z:F.pB.z)<0?-1:1;I.x*=x,I.y*=L,I.z*=G}else this.determinant()<=0&&(I.y*=-1);if(0===I._x||0===I._y||0===I._z)return x&&x.YB(0,0,0,1),!1;if(x){const L=1/I._x,F=1/I._y,X=1/I._z;U.FromValuesToRef(G[0]*L,G[1]*L,G[2]*L,0,G[4]*F,G[5]*F,G[6]*F,0,G[8]*X,G[9]*X,G[10]*X,0,0,0,0,1,q.Matrix[0]),s.FromRotationMatrixToRef(q.Matrix[0],x)}return!0}getRow(I){if(I<0||I>3)return null;const x=4*I;return new H(this.Jp[x+0],this.Jp[x+1],this.Jp[x+2],this.Jp[x+3])}getRowToRef(I,x){if(I>=0&&I<=3){const L=4*I;x.x=this.Jp[L+0],x.y=this.Jp[L+1],x.z=this.Jp[L+2],x.w=this.Jp[L+3]}return x}setRow(I,x){return this.setRowFromFloats(I,x.x,x.y,x.z,x.w)}transpose(){const I=new U;return U.TransposeToRef(this,I),I}transposeToRef(I){return U.TransposeToRef(this,I),I}setRowFromFloats(I,x,L,F,X){if(I<0||I>3)return this;const G=4*I;return this.Jp[G+0]=x,this.Jp[G+1]=L,this.Jp[G+2]=F,this.Jp[G+3]=X,this.markAsUpdated(),this}scale(I){const x=new U;return this.scaleToRef(I,x),x}scaleToRef(I,x){for(let L=0;L<16;L++)x.Jp[L]=this.Jp[L]*I;return x.markAsUpdated(),x}scaleAndAddToRef(I,x){for(let L=0;L<16;L++)x.Jp[L]+=this.Jp[L]*I;return x.markAsUpdated(),x}scaleInPlace(I){const x=this.Jp;for(let L=0;L<16;L++)x[L]*=I;return this.markAsUpdated(),this}toNormalMatrix(I){const x=q.Matrix[0];this.invertToRef(x),x.transposeToRef(I);const L=I.Jp;return U.FromValuesToRef(L[0],L[1],L[2],0,L[4],L[5],L[6],0,L[8],L[9],L[10],0,0,0,0,1,I),I}getRotationMatrix(){const I=new U;return this.getRotationMatrixToRef(I),I}getRotationMatrixToRef(I){const x=q.sx[0];if(!this.decompose(x))return U.IdentityToRef(I),I;const L=this.Jp,F=1/x._x,X=1/x._y,G=1/x._z;return U.FromValuesToRef(L[0]*F,L[1]*F,L[2]*F,0,L[4]*X,L[5]*X,L[6]*X,0,L[8]*G,L[9]*G,L[10]*G,0,0,0,0,1,I),I}toggleModelMatrixHandInPlace(){const I=this.Jp;return I[2]*=-1,I[6]*=-1,I[8]*=-1,I[9]*=-1,I[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const I=this.Jp;return I[8]*=-1,I[9]*=-1,I[10]*=-1,I[11]*=-1,this.markAsUpdated(),this}static tx(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const L=new U;return U.FromArrayToRef(I,x,L),L}static FromArrayToRef(I,x,L){for(let F=0;F<16;F++)L.Jp[F]=I[F+x];return L.markAsUpdated(),L}static FromFloat32ArrayToRefScaled(I,x,L,F){return F.Jp[0]=I[0+x]*L,F.Jp[1]=I[1+x]*L,F.Jp[2]=I[2+x]*L,F.Jp[3]=I[3+x]*L,F.Jp[4]=I[4+x]*L,F.Jp[5]=I[5+x]*L,F.Jp[6]=I[6+x]*L,F.Jp[7]=I[7+x]*L,F.Jp[8]=I[8+x]*L,F.Jp[9]=I[9+x]*L,F.Jp[10]=I[10+x]*L,F.Jp[11]=I[11+x]*L,F.Jp[12]=I[12+x]*L,F.Jp[13]=I[13+x]*L,F.Jp[14]=I[14+x]*L,F.Jp[15]=I[15+x]*L,F.markAsUpdated(),F}static get IdentityReadOnly(){return U._IdentityReadOnly}static FromValuesToRef(I,x,L,F,X,G,Y,p,B,l,W,Q,e,g,v,z,H){const s=H.Jp;s[0]=I,s[1]=x,s[2]=L,s[3]=F,s[4]=X,s[5]=G,s[6]=Y,s[7]=p,s[8]=B,s[9]=l,s[10]=W,s[11]=Q,s[12]=e,s[13]=g,s[14]=v,s[15]=z,H.markAsUpdated()}static FromValues(I,x,L,F,X,G,Y,p,B,l,W,Q,e,g,v,z){const H=new U,s=H.Jp;return s[0]=I,s[1]=x,s[2]=L,s[3]=F,s[4]=X,s[5]=G,s[6]=Y,s[7]=p,s[8]=B,s[9]=l,s[10]=W,s[11]=Q,s[12]=e,s[13]=g,s[14]=v,s[15]=z,H.markAsUpdated(),H}static Compose(I,x,L){const F=new U;return U.ComposeToRef(I,x,L,F),F}static ComposeToRef(I,x,L,F){const X=F.Jp,G=x._x,Y=x._y,p=x._z,B=x._w,l=G+G,W=Y+Y,Q=p+p,e=G*l,g=G*W,v=G*Q,z=Y*W,H=Y*Q,s=p*Q,U=B*l,q=B*W,y=B*Q,T=I._x,Z=I._y,t=I._z;return X[0]=(1-(z+s))*T,X[1]=(g+y)*T,X[2]=(v-q)*T,X[3]=0,X[4]=(g-y)*Z,X[5]=(1-(e+s))*Z,X[6]=(H+U)*Z,X[7]=0,X[8]=(v+q)*t,X[9]=(H-U)*t,X[10]=(1-(e+z))*t,X[11]=0,X[12]=L._x,X[13]=L._y,X[14]=L._z,X[15]=1,F.markAsUpdated(),F}static Identity(){const I=U.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return I._updateIdentityStatus(!0),I}static IdentityToRef(I){return U.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,I),I._updateIdentityStatus(!0),I}static Zero(){const I=U.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return I._updateIdentityStatus(!1),I}static RotationX(I){const x=new U;return U.RotationXToRef(I,x),x}static Invert(I){const x=new U;return I.invertToRef(x),x}static RotationXToRef(I,x){const L=Math.sin(I),F=Math.cos(I);return U.FromValuesToRef(1,0,0,0,0,F,L,0,0,-L,F,0,0,0,0,1,x),x._updateIdentityStatus(1===F&&0===L),x}static RotationY(I){const x=new U;return U.RotationYToRef(I,x),x}static RotationYToRef(I,x){const L=Math.sin(I),F=Math.cos(I);return U.FromValuesToRef(F,0,-L,0,0,1,0,0,L,0,F,0,0,0,0,1,x),x._updateIdentityStatus(1===F&&0===L),x}static RotationZ(I){const x=new U;return U.RotationZToRef(I,x),x}static RotationZToRef(I,x){const L=Math.sin(I),F=Math.cos(I);return U.FromValuesToRef(F,L,0,0,-L,F,0,0,0,0,1,0,0,0,0,1,x),x._updateIdentityStatus(1===F&&0===L),x}static RotationAxis(I,x){const L=new U;return U.RotationAxisToRef(I,x,L),L}static RotationAxisToRef(I,x,L){const F=Math.sin(-x),X=Math.cos(-x),G=1-X;I=I.normalizeToRef(q.sx[0]);const Y=L.Jp;return Y[0]=I._x*I._x*G+X,Y[1]=I._x*I._y*G-I._z*F,Y[2]=I._x*I._z*G+I._y*F,Y[3]=0,Y[4]=I._y*I._x*G+I._z*F,Y[5]=I._y*I._y*G+X,Y[6]=I._y*I._z*G-I._x*F,Y[7]=0,Y[8]=I._z*I._x*G-I._y*F,Y[9]=I._z*I._y*G+I._x*F,Y[10]=I._z*I._z*G+X,Y[11]=0,Y[12]=0,Y[13]=0,Y[14]=0,Y[15]=1,L.markAsUpdated(),L}static RotationAlignToRef(I,x,L){let X=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const G=z.Dot(x,I),Y=L.Jp;if(G<-1+F.e)Y[0]=-1,Y[1]=0,Y[2]=0,Y[3]=0,Y[4]=0,Y[5]=X?1:-1,Y[6]=0,Y[7]=0,Y[8]=0,Y[9]=0,Y[10]=X?-1:1,Y[11]=0;else{const L=z.Cross(x,I),F=1/(1+G);Y[0]=L._x*L._x*F+G,Y[1]=L._y*L._x*F-L._z,Y[2]=L._z*L._x*F+L._y,Y[3]=0,Y[4]=L._x*L._y*F+L._z,Y[5]=L._y*L._y*F+G,Y[6]=L._z*L._y*F-L._x,Y[7]=0,Y[8]=L._x*L._z*F-L._y,Y[9]=L._y*L._z*F+L._x,Y[10]=L._z*L._z*F+G,Y[11]=0}return Y[12]=0,Y[13]=0,Y[14]=0,Y[15]=1,L.markAsUpdated(),L}static RotationYawPitchRoll(I,x,L){const F=new U;return U.RotationYawPitchRollToRef(I,x,L,F),F}static RotationYawPitchRollToRef(I,x,L,F){return s.RotationYawPitchRollToRef(I,x,L,q.Quaternion[0]),q.Quaternion[0].toRotationMatrix(F),F}static Scaling(I,x,L){const F=new U;return U.ScalingToRef(I,x,L,F),F}static ScalingToRef(I,x,L,F){return U.FromValuesToRef(I,0,0,0,0,x,0,0,0,0,L,0,0,0,0,1,F),F._updateIdentityStatus(1===I&&1===x&&1===L),F}static Translation(I,x,L){const F=new U;return U.TranslationToRef(I,x,L,F),F}static TranslationToRef(I,x,L,F){return U.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,I,x,L,1,F),F._updateIdentityStatus(0===I&&0===x&&0===L),F}static Lerp(I,x,L){const F=new U;return U.LerpToRef(I,x,L,F),F}static LerpToRef(I,x,L,F){const X=F.Jp,G=I.m,Y=x.m;for(let p=0;p<16;p++)X[p]=G[p]*(1-L)+Y[p]*L;return F.markAsUpdated(),F}static DecomposeLerp(I,x,L){const F=new U;return U.DecomposeLerpToRef(I,x,L,F),F}static DecomposeLerpToRef(I,x,L,F){const X=q.sx[0],G=q.Quaternion[0],Y=q.sx[1];I.decompose(X,G,Y);const p=q.sx[2],B=q.Quaternion[1],l=q.sx[3];x.decompose(p,B,l);const W=q.sx[4];z.LerpToRef(X,p,L,W);const Q=q.Quaternion[2];s.SlerpToRef(G,B,L,Q);const e=q.sx[5];return z.LerpToRef(Y,l,L,e),U.ComposeToRef(W,Q,e,F),F}static LookAtLH(I,x,L){const F=new U;return U.LookAtLHToRef(I,x,L,F),F}static LookAtLHToRef(I,x,L,F){const X=q.sx[0],G=q.sx[1],Y=q.sx[2];x.subtractToRef(I,Y),Y.normalize(),z.CrossToRef(L,Y,X);const p=X.lengthSquared();0===p?X.x=1:X.normalizeFromLength(Math.sqrt(p)),z.CrossToRef(Y,X,G),G.normalize();const B=-z.Dot(X,I),l=-z.Dot(G,I),W=-z.Dot(Y,I);return U.FromValuesToRef(X._x,G._x,Y._x,0,X._y,G._y,Y._y,0,X._z,G._z,Y._z,0,B,l,W,1,F),F}static LookAtRH(I,x,L){const F=new U;return U.LookAtRHToRef(I,x,L,F),F}static LookAtRHToRef(I,x,L,F){const X=q.sx[0],G=q.sx[1],Y=q.sx[2];I.subtractToRef(x,Y),Y.normalize(),z.CrossToRef(L,Y,X);const p=X.lengthSquared();0===p?X.x=1:X.normalizeFromLength(Math.sqrt(p)),z.CrossToRef(Y,X,G),G.normalize();const B=-z.Dot(X,I),l=-z.Dot(G,I),W=-z.Dot(Y,I);return U.FromValuesToRef(X._x,G._x,Y._x,0,X._y,G._y,Y._y,0,X._z,G._z,Y._z,0,B,l,W,1,F),F}static LookDirectionLH(I,x){const L=new U;return U.LookDirectionLHToRef(I,x,L),L}static LookDirectionLHToRef(I,x,L){const F=q.sx[0];F.X(I),F.scaleInPlace(-1);const X=q.sx[1];return z.CrossToRef(x,F,X),U.FromValuesToRef(X._x,X._y,X._z,0,x._x,x._y,x._z,0,F._x,F._y,F._z,0,0,0,0,1,L),L}static LookDirectionRH(I,x){const L=new U;return U.LookDirectionRHToRef(I,x,L),L}static LookDirectionRHToRef(I,x,L){const F=q.sx[2];return z.CrossToRef(x,I,F),U.FromValuesToRef(F._x,F._y,F._z,0,x._x,x._y,x._z,0,I._x,I._y,I._z,0,0,0,0,1,L),L}static OrthoLH(I,x,L,F,X){const G=new U;return U.OrthoLHToRef(I,x,L,F,G,X),G}static OrthoLHToRef(I,x,L,F,X,G){const Y=2/I,p=2/x,B=2/(F-L),l=-(F+L)/(F-L);return U.FromValuesToRef(Y,0,0,0,0,p,0,0,0,0,B,0,0,0,l,1,X),G&&X.multiplyToRef(T,X),X._updateIdentityStatus(1===Y&&1===p&&1===B&&0===l),X}static OrthoOffCenterLH(I,x,L,F,X,G,Y){const p=new U;return U.OrthoOffCenterLHToRef(I,x,L,F,X,G,p,Y),p}static OrthoOffCenterLHToRef(I,x,L,F,X,G,Y,p){const B=2/(x-I),l=2/(F-L),W=2/(G-X),Q=-(G+X)/(G-X),e=(I+x)/(I-x),g=(F+L)/(L-F);return U.FromValuesToRef(B,0,0,0,0,l,0,0,0,0,W,0,e,g,Q,1,Y),p&&Y.multiplyToRef(T,Y),Y.markAsUpdated(),Y}static ObliqueOffCenterLHToRef(I,x,L,F,X,G,Y,p,B,l,W){const Q=-Y*Math.cos(p),e=-Y*Math.sin(p);return U.TranslationToRef(0,0,-B,q.Matrix[1]),U.FromValuesToRef(1,0,0,0,0,1,0,0,Q,e,1,0,0,0,0,1,q.Matrix[0]),q.Matrix[1].multiplyToRef(q.Matrix[0],q.Matrix[0]),U.TranslationToRef(0,0,B,q.Matrix[1]),q.Matrix[0].multiplyToRef(q.Matrix[1],q.Matrix[0]),U.OrthoOffCenterLHToRef(I,x,L,F,X,G,l,W),q.Matrix[0].multiplyToRef(l,l),l}static OrthoOffCenterRH(I,x,L,F,X,G,Y){const p=new U;return U.OrthoOffCenterRHToRef(I,x,L,F,X,G,p,Y),p}static OrthoOffCenterRHToRef(I,x,L,F,X,G,Y,p){return U.OrthoOffCenterLHToRef(I,x,L,F,X,G,Y,p),Y.Jp[10]*=-1,Y}static ObliqueOffCenterRHToRef(I,x,L,F,X,G,Y,p,B,l,W){const Q=Y*Math.cos(p),e=Y*Math.sin(p);return U.TranslationToRef(0,0,B,q.Matrix[1]),U.FromValuesToRef(1,0,0,0,0,1,0,0,Q,e,1,0,0,0,0,1,q.Matrix[0]),q.Matrix[1].multiplyToRef(q.Matrix[0],q.Matrix[0]),U.TranslationToRef(0,0,-B,q.Matrix[1]),q.Matrix[0].multiplyToRef(q.Matrix[1],q.Matrix[0]),U.OrthoOffCenterRHToRef(I,x,L,F,X,G,l,W),q.Matrix[0].multiplyToRef(l,l),l}static PerspectiveLH(I,x,L,F,X){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const Y=new U,p=2*L/I,B=2*L/x,l=(F+L)/(F-L),W=-2*F*L/(F-L),Q=Math.tan(G);return U.FromValuesToRef(p,0,0,0,0,B,0,Q,0,0,l,1,0,0,W,0,Y),X&&Y.multiplyToRef(T,Y),Y._updateIdentityStatus(!1),Y}static PerspectiveFovLH(I,x,L,F,X){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const p=new U;return U.PerspectiveFovLHToRef(I,x,L,F,p,!0,X,G,Y),p}static PerspectiveFovLHToRef(I,x,L,F,X){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,p=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,B=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=L,W=F,Q=1/Math.tan(.5*I),e=G?Q/x:Q,g=G?Q:Q*x,v=B&&0===l?-1:0!==W?(W+l)/(W-l):1,z=B&&0===l?2*W:0!==W?-2*W*l/(W-l):-2*l,H=Math.tan(p);return U.FromValuesToRef(e,0,0,0,0,g,0,H,0,0,v,1,0,0,z,0,X),Y&&X.multiplyToRef(T,X),X._updateIdentityStatus(!1),X}static PerspectiveFovReverseLHToRef(I,x,L,F,X){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,p=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const B=1/Math.tan(.5*I),l=G?B/x:B,W=G?B:B*x,Q=Math.tan(p);return U.FromValuesToRef(l,0,0,0,0,W,0,Q,0,0,-L,1,0,0,1,0,X),Y&&X.multiplyToRef(T,X),X._updateIdentityStatus(!1),X}static PerspectiveFovRH(I,x,L,F,X){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const p=new U;return U.PerspectiveFovRHToRef(I,x,L,F,p,!0,X,G,Y),p}static PerspectiveFovRHToRef(I,x,L,F,X){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,p=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,B=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=L,W=F,Q=1/Math.tan(.5*I),e=G?Q/x:Q,g=G?Q:Q*x,v=B&&0===l?1:0!==W?-(W+l)/(W-l):-1,z=B&&0===l?2*W:0!==W?-2*W*l/(W-l):-2*l,H=Math.tan(p);return U.FromValuesToRef(e,0,0,0,0,g,0,H,0,0,v,-1,0,0,z,0,X),Y&&X.multiplyToRef(T,X),X._updateIdentityStatus(!1),X}static PerspectiveFovReverseRHToRef(I,x,L,F,X){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Y=arguments.length>6?arguments[6]:void 0,p=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const B=1/Math.tan(.5*I),l=G?B/x:B,W=G?B:B*x,Q=Math.tan(p);return U.FromValuesToRef(l,0,0,0,0,W,0,Q,0,0,-L,-1,0,0,-1,0,X),Y&&X.multiplyToRef(T,X),X._updateIdentityStatus(!1),X}static GetFinalMatrix(I,x,L,F,X,G){const Y=I.width,p=I.height,B=I.x,l=I.y,W=U.FromValues(Y/2,0,0,0,0,-p/2,0,0,0,0,G-X,0,B+Y/2,p/2+l,X,1),Q=new U;return x.multiplyToRef(L,Q),Q.multiplyToRef(F,Q),Q.multiplyToRef(W,Q)}static GetAsMatrix2x2(I){const x=I.m,L=[x[0],x[1],x[4],x[5]];return Y.d.MatrixUse64Bits?L:new Float32Array(L)}static GetAsMatrix3x3(I){const x=I.m,L=[x[0],x[1],x[2],x[4],x[5],x[6],x[8],x[9],x[10]];return Y.d.MatrixUse64Bits?L:new Float32Array(L)}static Transpose(I){const x=new U;return U.TransposeToRef(I,x),x}static TransposeToRef(I,x){const L=I.m,F=L[0],X=L[4],G=L[8],Y=L[12],p=L[1],B=L[5],l=L[9],W=L[13],Q=L[2],e=L[6],g=L[10],v=L[14],z=L[3],H=L[7],s=L[11],U=L[15],q=x.Jp;return q[0]=F,q[1]=X,q[2]=G,q[3]=Y,q[4]=p,q[5]=B,q[6]=l,q[7]=W,q[8]=Q,q[9]=e,q[10]=g,q[11]=v,q[12]=z,q[13]=H,q[14]=s,q[15]=U,x.markAsUpdated(),x._updateIdentityStatus(I._isIdentity,I._isIdentityDirty),x}static Reflection(I){const x=new U;return U.ReflectionToRef(I,x),x}static ReflectionToRef(I,x){I.normalize();const L=I.normal.x,F=I.normal.y,X=I.normal.z,G=-2*L,Y=-2*F,p=-2*X;return U.FromValuesToRef(G*L+1,Y*L,p*L,0,G*F,Y*F+1,p*F,0,G*X,Y*X,p*X+1,0,G*I.d,Y*I.d,p*I.d,1,x),x}static FromXYZAxesToRef(I,x,L,F){return U.FromValuesToRef(I._x,I._y,I._z,0,x._x,x._y,x._z,0,L._x,L._y,L._z,0,0,0,0,1,F),F}static FromQuaternionToRef(I,x){const L=I._x*I._x,F=I._y*I._y,X=I._z*I._z,G=I._x*I._y,Y=I._z*I._w,p=I._z*I._x,B=I._y*I._w,l=I._y*I._z,W=I._x*I._w;return x.Jp[0]=1-2*(F+X),x.Jp[1]=2*(G+Y),x.Jp[2]=2*(p-B),x.Jp[3]=0,x.Jp[4]=2*(G-Y),x.Jp[5]=1-2*(X+L),x.Jp[6]=2*(l+W),x.Jp[7]=0,x.Jp[8]=2*(p+B),x.Jp[9]=2*(l-W),x.Jp[10]=1-2*(F+L),x.Jp[11]=0,x.Jp[12]=0,x.Jp[13]=0,x.Jp[14]=0,x.Jp[15]=1,x.markAsUpdated(),x}}U._IdentityReadOnly=U.Identity(),Object.defineProperties(U.prototype,{dimension:{value:[4,4]},rank:{value:2}});class q{}q.sx=(0,X.d)(11,z.Zero),q.Matrix=(0,X.d)(2,U.Identity),q.Quaternion=(0,X.d)(3,s.Zero);class y{}y.Vector2=(0,X.d)(3,v.Zero),y.sx=(0,X.d)(13,z.Zero),y.Vector4=(0,X.d)(3,H.Zero),y.Quaternion=(0,X.d)(3,s.Zero),y.Matrix=(0,X.d)(8,U.Identity),(0,G.d)("BABYLON.Vector2",v),(0,G.d)("BABYLON.Vector3",z),(0,G.d)("BABYLON.Vector4",H),(0,G.d)("BABYLON.Matrix",U);const T=U.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12996:(I,x,L)=>{function F(I,x){const L=[];for(let F=0;F<I;++F)L.push(x());return L}function X(I,x){return F(I,x)}L.d(x,{c:()=>F,d:()=>X,f:()=>Y});const G=["push","splice","pop","shift","unshift"];function Y(I,x){const L=G.map((L=>function(I,x,L){const F=I[x];if("function"!==typeof F)return null;const X=function(){const F=I.length,G=X.previous.apply(I,arguments);return L(x,F),G};return F.next=X,X.previous=F,I[x]=X,()=>{const L=X.previous;if(!L)return;const F=X.next;F?(L.next=F,F.previous=L):(L.next=void 0,I[x]=L),X.next=void 0,X.previous=void 0}}(I,L,x)));return()=>{for(const I of L)null===I||void 0===I||I()}}}}]);