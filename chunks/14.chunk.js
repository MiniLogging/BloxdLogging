"use strict";(self.fkqm0epoq5=self.fkqm0epoq5||[]).push([[14],{11713:(D,l,G)=>{G.d(l,{b:()=>b,e:()=>M,g:()=>V,k:()=>N});const V=1/2.2,N=2.2,M=(1+Math.sqrt(5))/2,b=.001},11728:(D,l,G)=>{function V(D){return parseInt(D.toString().replace(/\W/g,""))}function N(D,l){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(D-l)<=G}function M(D,l,G){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return D<l-V||D>G+V}function b(D,l){return D===l?D:Math.random()*(l-D)+D}function X(D,l,G){return D+(l-D)*G}function t(D,l,G){let V=d(l-D,360);return V>180&&(V-=360),D+V*j(G)}function R(D,l,G){let V=0;return V=D!=l?j((G-D)/(l-D)):0,V}function n(D,l,G,V,N){const M=N*N,b=N*M;return D*(2*b-3*M+1)+G*(-2*b+3*M)+l*(b-2*M+N)+V*(b-M)}function g(D,l,G,V,N){const M=N*N;return 6*(M-N)*D+(3*M-4*N+1)*l+6*(-M+N)*G+(3*M-2*N)*V}function j(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(G,Math.max(l,D))}function e(D){return D-=2*Math.PI*Math.floor((D+Math.PI)/(2*Math.PI))}function K(D){const l=D.toString(16);return D<=15?("0"+l).toUpperCase():l.toUpperCase()}function F(D){if(Math.log2)return Math.floor(Math.log2(D));if(D<0)return NaN;if(0===D)return-1/0;let l=0;if(D<1){for(;D<1;)l++,D*=2;l=-l}else if(D>1)for(;D>1;)l++,D=Math.floor(D/2);return l}function d(D,l){return D-Math.floor(D/l)*l}function H(D,l,G){return(D-l)/(G-l)}function h(D,l,G){return D*(G-l)+l}function x(D,l){let G=d(l-D,360);return G>180&&(G-=360),G}function r(D,l){const G=d(D,2*l);return l-Math.abs(G-l)}function o(D,l,G){let V=j(G);return V=-2*V*V*V+3*V*V,l*V+D*(1-V)}function L(D,l,G){let V=0;return V=Math.abs(l-D)<=G?l:D+Math.sign(l-D)*G,V}function u(D,l,G){const V=x(D,l);let N=0;return N=-G<V&&V<G?l:L(D,l=D+V,G),N}function B(D,l,G){return(D-l)/(G-l)}function I(D,l,G){return(G-l)*D+l}function W(D,l){const G=D%l;return 0===G?l:W(l,G)}G.r(l),G.d(l,{Clamp:()=>j,DeltaAngle:()=>x,Denormalize:()=>h,ExtractAsInt:()=>V,Hermite:()=>n,Hermite1stDerivative:()=>g,HighestCommonFactor:()=>W,ILog2:()=>F,InverseLerp:()=>R,Lerp:()=>X,LerpAngle:()=>t,MoveTowards:()=>L,MoveTowardsAngle:()=>u,Normalize:()=>H,NormalizeRadians:()=>e,OutsideRange:()=>M,PercentToRange:()=>I,PingPong:()=>r,RandomRange:()=>b,RangeToPercent:()=>B,Repeat:()=>d,SmoothStep:()=>o,ToHex:()=>K,WithinEpsilon:()=>N})},11710:(D,l,G)=>{G.r(l),G.d(l,{Matrix:()=>h,Quaternion:()=>H,TmpVectors:()=>r,Vector2:()=>K,Kl:()=>F,Vector4:()=>d});var V=G(11713),N=G(11721),M=G(11667),b=G(11637),X=G(11571),t=G(11728);class R{}function n(D,l,G){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const N=D.gb(),M=l.gb(),b=N[0],X=N[1],t=N[2],R=N[3],n=N[4],g=N[5],j=N[6],e=N[7],K=N[8],F=N[9],d=N[10],H=N[11],h=N[12],x=N[13],r=N[14],o=N[15],L=M[0],u=M[1],B=M[2],I=M[3],W=M[4],i=M[5],y=M[6],S=M[7],O=M[8],s=M[9],U=M[10],f=M[11],q=M[12],c=M[13],v=M[14],Z=M[15];G[V]=b*L+X*W+t*O+R*q,G[V+1]=b*u+X*i+t*s+R*c,G[V+2]=b*B+X*y+t*U+R*v,G[V+3]=b*I+X*S+t*f+R*Z,G[V+4]=n*L+g*W+j*O+e*q,G[V+5]=n*u+g*i+j*s+e*c,G[V+6]=n*B+g*y+j*U+e*v,G[V+7]=n*I+g*S+j*f+e*Z,G[V+8]=K*L+F*W+d*O+H*q,G[V+9]=K*u+F*i+d*s+H*c,G[V+10]=K*B+F*y+d*U+H*v,G[V+11]=K*I+F*S+d*f+H*Z,G[V+12]=h*L+x*W+r*O+o*q,G[V+13]=h*u+x*i+r*s+o*c,G[V+14]=h*B+x*y+r*U+o*v,G[V+15]=h*I+x*S+r*f+o*Z}function g(D,l){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const V=D.gb();l[G]=V[0],l[G+1]=V[1],l[G+2]=V[2],l[G+3]=V[3],l[G+4]=V[4],l[G+5]=V[5],l[G+6]=V[6],l[G+7]=V[7],l[G+8]=V[8],l[G+9]=V[9],l[G+10]=V[10],l[G+11]=V[11],l[G+12]=V[12],l[G+13]=V[13],l[G+14]=V[14],l[G+15]=V[15]}function j(D,l){const G=D.gb(),V=G[0],N=G[1],M=G[2],b=G[3],X=G[4],t=G[5],R=G[6],n=G[7],g=G[8],j=G[9],e=G[10],K=G[11],F=G[12],d=G[13],H=G[14],h=G[15],x=e*h-H*K,r=j*h-d*K,o=j*H-d*e,L=g*h-F*K,u=g*H-e*F,B=g*d-F*j,I=+(t*x-R*r+n*o),W=-(X*x-R*L+n*u),i=+(X*r-t*L+n*B),y=-(X*o-t*u+R*B),S=V*I+N*W+M*i+b*y;if(0===S)return!1;const O=1/S,s=R*h-H*n,U=t*h-d*n,f=t*H-d*R,q=X*h-F*n,c=X*H-F*R,v=X*d-F*t,Z=R*K-e*n,J=t*K-j*n,Y=t*e-j*R,z=X*K-g*n,E=X*e-g*R,P=X*j-g*t,p=-(N*x-M*r+b*o),k=+(V*x-M*L+b*u),m=-(V*r-N*L+b*B),T=+(V*o-N*u+M*B),C=+(N*s-M*U+b*f),w=-(V*s-M*q+b*c),A=+(V*U-N*q+b*v),a=-(V*f-N*c+M*v),Q=-(N*Z-M*J+b*Y),DD=+(V*Z-M*z+b*E),lD=-(V*J-N*z+b*P),GD=+(V*Y-N*E+M*P);return l[0]=I*O,l[1]=p*O,l[2]=C*O,l[3]=Q*O,l[4]=W*O,l[5]=k*O,l[6]=w*O,l[7]=DD*O,l[8]=i*O,l[9]=m*O,l[10]=A*O,l[11]=lD*O,l[12]=y*O,l[13]=T*O,l[14]=a*O,l[15]=GD*O,!0}R._UpdateFlagSeed=0;const e=D=>parseInt(D.toString().replace(/\W/g,""));class K{constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=D,this.y=l}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let D=e(this.x);return D=397*D^e(this.y),D}toArray(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D[l]=this.x,D[l+1]=this.y,this}KG(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K.FromArrayToRef(D,l,this),this}gb(){return[this.x,this.y]}V(D){return this.x=D.x,this.y=D.y,this}Lb(D,l){return this.x=D,this.y=l,this}set(D,l){return this.Lb(D,l)}Ib(D){return this.Lb(D,D)}add(D){return new K(this.x+D.x,this.y+D.y)}addToRef(D,l){return l.x=this.x+D.x,l.y=this.y+D.y,l}addInPlace(D){return this.x+=D.x,this.y+=D.y,this}addInPlaceFromFloats(D,l){return this.x+=D,this.y+=l,this}addVector3(D){return new K(this.x+D.x,this.y+D.y)}Fl(D){return new K(this.x-D.x,this.y-D.y)}subtractToRef(D,l){return l.x=this.x-D.x,l.y=this.y-D.y,l}Kg(D){return this.x-=D.x,this.y-=D.y,this}multiplyInPlace(D){return this.x*=D.x,this.y*=D.y,this}multiply(D){return new K(this.x*D.x,this.y*D.y)}multiplyToRef(D,l){return l.x=this.x*D.x,l.y=this.y*D.y,l}multiplyByFloats(D,l){return new K(this.x*D,this.y*l)}divide(D){return new K(this.x/D.x,this.y/D.y)}divideToRef(D,l){return l.x=this.x/D.x,l.y=this.y/D.y,l}divideInPlace(D){return this.x=this.x/D.x,this.y=this.y/D.y,this}minimizeInPlace(D){return this.minimizeInPlaceFromFloats(D.x,D.y)}maximizeInPlace(D){return this.maximizeInPlaceFromFloats(D.x,D.y)}minimizeInPlaceFromFloats(D,l){return this.x=Math.min(D,this.x),this.y=Math.min(l,this.y),this}maximizeInPlaceFromFloats(D,l){return this.x=Math.max(D,this.x),this.y=Math.max(l,this.y),this}subtractFromFloats(D,l){return new K(this.x-D,this.y-l)}subtractFromFloatsToRef(D,l,G){return G.x=this.x-D,G.y=this.y-l,G}negate(){return new K(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(D){return D.x=-this.x,D.y=-this.y,D}scaleInPlace(D){return this.x*=D,this.y*=D,this}scale(D){return new K(this.x*D,this.y*D)}scaleToRef(D,l){return l.x=this.x*D,l.y=this.y*D,l}scaleAndAddToRef(D,l){return l.x+=this.x*D,l.y+=this.y*D,l}equals(D){return D&&this.x===D.x&&this.y===D.y}equalsWithEpsilon(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.b;return D&&(0,t.WithinEpsilon)(this.x,D.x,l)&&(0,t.WithinEpsilon)(this.y,D.y,l)}equalsToFloats(D,l){return this.x===D&&this.y===l}floor(){return new K(Math.floor(this.x),Math.floor(this.y))}floorToRef(D){return D.x=Math.floor(this.x),D.y=Math.floor(this.y),D}fract(){return new K(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(D){return D.x=this.x-Math.floor(this.x),D.y=this.y-Math.floor(this.y),D}rotate(D){return this.rotateToRef(D,new K)}rotateToRef(D,l){const G=Math.cos(D),V=Math.sin(D);return l.x=G*this.x-V*this.y,l.y=V*this.x+G*this.y,l}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(D){return 0===D||1===D?this:this.scaleInPlace(1/D)}normalizeToNew(){const D=new K;return this.normalizeToRef(D),D}normalizeToRef(D){const l=this.length();return 0===l&&(D.x=this.x,D.y=this.y),this.scaleToRef(1/l,D)}clone(){return new K(this.x,this.y)}dot(D){return this.x*D.x+this.y*D.y}static Zero(){return new K(0,0)}static One(){return new K(1,1)}static Random(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new K((0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l))}static RandomToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Lb((0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l))}static get ZeroReadOnly(){return K._ZeroReadOnly}static xl(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new K(D[l],D[l+1])}static FromArrayToRef(D,l,G){return G.x=D[l],G.y=D[l+1],G}static FromFloatsToRef(D,l,G){return G.Lb(D,l),G}static CatmullRom(D,l,G,V,N){const M=N*N,b=N*M,X=.5*(2*l.x+(-D.x+G.x)*N+(2*D.x-5*l.x+4*G.x-V.x)*M+(-D.x+3*l.x-3*G.x+V.x)*b),t=.5*(2*l.y+(-D.y+G.y)*N+(2*D.y-5*l.y+4*G.y-V.y)*M+(-D.y+3*l.y-3*G.y+V.y)*b);return new K(X,t)}static ClampToRef(D,l,G,V){return V.x=(0,t.Clamp)(D.x,l.x,G.x),V.y=(0,t.Clamp)(D.y,l.y,G.y),V}static Clamp(D,l,G){const V=(0,t.Clamp)(D.x,l.x,G.x),N=(0,t.Clamp)(D.y,l.y,G.y);return new K(V,N)}static Hermite(D,l,G,V,N){const M=N*N,b=N*M,X=2*b-3*M+1,t=-2*b+3*M,R=b-2*M+N,n=b-M,g=D.x*X+G.x*t+l.x*R+V.x*n,j=D.y*X+G.y*t+l.y*R+V.y*n;return new K(g,j)}static Hermite1stDerivative(D,l,G,V,N){return this.Hermite1stDerivativeToRef(D,l,G,V,N,new K)}static Hermite1stDerivativeToRef(D,l,G,V,N,M){const b=N*N;return M.x=6*(b-N)*D.x+(3*b-4*N+1)*l.x+6*(-b+N)*G.x+(3*b-2*N)*V.x,M.y=6*(b-N)*D.y+(3*b-4*N+1)*l.y+6*(-b+N)*G.y+(3*b-2*N)*V.y,M}static Lerp(D,l,G){return K.LerpToRef(D,l,G,new K)}static LerpToRef(D,l,G,V){return V.x=D.x+(l.x-D.x)*G,V.y=D.y+(l.y-D.y)*G,V}static Dot(D,l){return D.x*l.x+D.y*l.y}static Normalize(D){return K.NormalizeToRef(D,new K)}static NormalizeToRef(D,l){return D.normalizeToRef(l),l}static Minimize(D,l){const G=D.x<l.x?D.x:l.x,V=D.y<l.y?D.y:l.y;return new K(G,V)}static Maximize(D,l){const G=D.x>l.x?D.x:l.x,V=D.y>l.y?D.y:l.y;return new K(G,V)}static Transform(D,l){return K.TransformToRef(D,l,new K)}static TransformToRef(D,l,G){const V=l.m,N=D.x*V[0]+D.y*V[4]+V[12],M=D.x*V[1]+D.y*V[5]+V[13];return G.x=N,G.y=M,G}static PointInTriangle(D,l,G,V){const N=.5*(-G.y*V.x+l.y*(-G.x+V.x)+l.x*(G.y-V.y)+G.x*V.y),M=N<0?-1:1,b=(l.y*V.x-l.x*V.y+(V.y-l.y)*D.x+(l.x-V.x)*D.y)*M,X=(l.x*G.y-l.y*G.x+(l.y-G.y)*D.x+(G.x-l.x)*D.y)*M;return b>0&&X>0&&b+X<2*N*M}static Distance(D,l){return Math.sqrt(K.DistanceSquared(D,l))}static DistanceSquared(D,l){const G=D.x-l.x,V=D.y-l.y;return G*G+V*V}static Center(D,l){return K.CenterToRef(D,l,new K)}static CenterToRef(D,l,G){return G.Lb((D.x+l.x)/2,(D.y+l.y)/2)}static DistanceOfPointFromSegment(D,l,G){const V=K.DistanceSquared(l,G);if(0===V)return K.Distance(D,l);const N=G.Fl(l),M=Math.max(0,Math.min(1,K.Dot(D.Fl(l),N)/V)),b=l.add(N.multiplyByFloats(M,M));return K.Distance(D,b)}}K._V8PerformanceHack=new K(.5,.5),K._ZeroReadOnly=K.Zero(),Object.defineProperties(K.prototype,{dimension:{value:[2]},rank:{value:1}});class F{get x(){return this._x}set x(D){this._x=D,this._isDirty=!0}get y(){return this._y}set y(D){this._y=D,this._isDirty=!0}get z(){return this._z}set z(D){this._z=D,this._isDirty=!0}constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=D,this._y=l,this._z=G}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Kl"}getHashCode(){let D=e(this._x);return D=397*D^e(this._y),D=397*D^e(this._z),D}gb(){return[this._x,this._y,this._z]}toArray(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D[l]=this._x,D[l+1]=this._y,D[l+2]=this._z,this}KG(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F.FromArrayToRef(D,l,this),this}toQuaternion(){return H.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(D){return this._x+=D._x,this._y+=D._y,this._z+=D._z,this._isDirty=!0,this}addInPlaceFromFloats(D,l,G){return this._x+=D,this._y+=l,this._z+=G,this._isDirty=!0,this}add(D){return new F(this._x+D._x,this._y+D._y,this._z+D._z)}addToRef(D,l){return l._x=this._x+D._x,l._y=this._y+D._y,l._z=this._z+D._z,l._isDirty=!0,l}Kg(D){return this._x-=D._x,this._y-=D._y,this._z-=D._z,this._isDirty=!0,this}Fl(D){return new F(this._x-D._x,this._y-D._y,this._z-D._z)}subtractToRef(D,l){return this.subtractFromFloatsToRef(D._x,D._y,D._z,l)}subtractFromFloats(D,l,G){return new F(this._x-D,this._y-l,this._z-G)}subtractFromFloatsToRef(D,l,G,V){return V._x=this._x-D,V._y=this._y-l,V._z=this._z-G,V._isDirty=!0,V}negate(){return new F(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(D){return D._x=-1*this._x,D._y=-1*this._y,D._z=-1*this._z,D._isDirty=!0,D}scaleInPlace(D){return this._x*=D,this._y*=D,this._z*=D,this._isDirty=!0,this}scale(D){return new F(this._x*D,this._y*D,this._z*D)}scaleToRef(D,l){return l._x=this._x*D,l._y=this._y*D,l._z=this._z*D,l._isDirty=!0,l}getNormalToRef(D){const l=this.length();let G=Math.acos(this._y/l);const V=Math.atan2(this._z,this._x);G>Math.PI/2?G-=Math.PI/2:G+=Math.PI/2;const N=l*Math.sin(G)*Math.cos(V),M=l*Math.cos(G),b=l*Math.sin(G)*Math.sin(V);return D.set(N,M,b),D}applyRotationQuaternionToRef(D,l){const G=this._x,V=this._y,N=this._z,M=D._x,b=D._y,X=D._z,t=D._w,R=2*(b*N-X*V),n=2*(X*G-M*N),g=2*(M*V-b*G);return l._x=G+t*R+b*g-X*n,l._y=V+t*n+X*R-M*g,l._z=N+t*g+M*n-b*R,l._isDirty=!0,l}applyRotationQuaternionInPlace(D){return this.applyRotationQuaternionToRef(D,this)}applyRotationQuaternion(D){return this.applyRotationQuaternionToRef(D,new F)}scaleAndAddToRef(D,l){return l._x+=this._x*D,l._y+=this._y*D,l._z+=this._z*D,l._isDirty=!0,l}projectOnPlane(D,l){return this.projectOnPlaneToRef(D,l,new F)}projectOnPlaneToRef(D,l,G){const V=D.normal,N=D.d,M=x.Kl[0];this.subtractToRef(l,M),M.normalize();const b=F.Dot(M,V);if(Math.abs(b)<1e-10)G.Ib(1/0);else{const D=-(F.Dot(l,V)+N)/b,X=M.scaleInPlace(D);l.addToRef(X,G)}return G}equals(D){return D&&this._x===D._x&&this._y===D._y&&this._z===D._z}equalsWithEpsilon(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.b;return D&&(0,t.WithinEpsilon)(this._x,D._x,l)&&(0,t.WithinEpsilon)(this._y,D._y,l)&&(0,t.WithinEpsilon)(this._z,D._z,l)}equalsToFloats(D,l,G){return this._x===D&&this._y===l&&this._z===G}multiplyInPlace(D){return this._x*=D._x,this._y*=D._y,this._z*=D._z,this._isDirty=!0,this}multiply(D){return this.multiplyByFloats(D._x,D._y,D._z)}multiplyToRef(D,l){return l._x=this._x*D._x,l._y=this._y*D._y,l._z=this._z*D._z,l._isDirty=!0,l}multiplyByFloats(D,l,G){return new F(this._x*D,this._y*l,this._z*G)}divide(D){return new F(this._x/D._x,this._y/D._y,this._z/D._z)}divideToRef(D,l){return l._x=this._x/D._x,l._y=this._y/D._y,l._z=this._z/D._z,l._isDirty=!0,l}divideInPlace(D){return this._x=this._x/D._x,this._y=this._y/D._y,this._z=this._z/D._z,this._isDirty=!0,this}minimizeInPlace(D){return this.minimizeInPlaceFromFloats(D._x,D._y,D._z)}maximizeInPlace(D){return this.maximizeInPlaceFromFloats(D._x,D._y,D._z)}minimizeInPlaceFromFloats(D,l,G){return D<this._x&&(this.x=D),l<this._y&&(this.y=l),G<this._z&&(this.z=G),this}maximizeInPlaceFromFloats(D,l,G){return D>this._x&&(this.x=D),l>this._y&&(this.y=l),G>this._z&&(this.z=G),this}isNonUniformWithinEpsilon(D){const l=Math.abs(this._x),G=Math.abs(this._y);if(!(0,t.WithinEpsilon)(l,G,D))return!0;const V=Math.abs(this._z);return!(0,t.WithinEpsilon)(l,V,D)||!(0,t.WithinEpsilon)(G,V,D)}get isNonUniform(){const D=Math.abs(this._x);if(D!==Math.abs(this._y))return!0;return D!==Math.abs(this._z)}floorToRef(D){return D._x=Math.floor(this._x),D._y=Math.floor(this._y),D._z=Math.floor(this._z),D._isDirty=!0,D}floor(){return new F(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(D){return D._x=this._x-Math.floor(this._x),D._y=this._y-Math.floor(this._y),D._z=this._z-Math.floor(this._z),D._isDirty=!0,D}fract(){return new F(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(D){if("xyz"===(D=D.toLowerCase()))return this;const l=x.Kl[0].V(this);return this.x=l[D[0]],this.y=l[D[1]],this.z=l[D[2]],this}rotateByQuaternionToRef(D,l){return D.toRotationMatrix(x.Matrix[0]),F.TransformCoordinatesToRef(this,x.Matrix[0],l),l}rotateByQuaternionAroundPointToRef(D,l,G){return this.subtractToRef(l,x.Kl[0]),x.Kl[0].rotateByQuaternionToRef(D,x.Kl[0]),l.addToRef(x.Kl[0],G),G}cross(D){return F.CrossToRef(this,D,new F)}normalizeFromLength(D){return 0===D||1===D?this:this.scaleInPlace(1/D)}normalizeToNew(){return this.normalizeToRef(new F)}normalizeToRef(D){const l=this.length();return 0===l||1===l?(D._x=this._x,D._y=this._y,D._z=this._z,D._isDirty=!0,D):this.scaleToRef(1/l,D)}clone(){return new F(this._x,this._y,this._z)}V(D){return this.Lb(D._x,D._y,D._z)}Lb(D,l,G){return this._x=D,this._y=l,this._z=G,this._isDirty=!0,this}set(D,l,G){return this.Lb(D,l,G)}Ib(D){return this._x=this._y=this._z=D,this._isDirty=!0,this}static GetClipFactor(D,l,G,V){const N=F.Dot(D,G);return(N-V)/(N-F.Dot(l,G))}static GetAngleBetweenVectors(D,l,G){const V=D.normalizeToRef(x.Kl[1]),N=l.normalizeToRef(x.Kl[2]);let M=F.Dot(V,N);M=(0,t.Clamp)(M,-1,1);const b=Math.acos(M),X=x.Kl[3];return F.CrossToRef(V,N,X),F.Dot(X,G)>0?isNaN(b)?0:b:isNaN(b)?-Math.PI:-Math.acos(M)}static GetAngleBetweenVectorsOnPlane(D,l,G){x.Kl[0].V(D);const V=x.Kl[0];x.Kl[1].V(l);const N=x.Kl[1];x.Kl[2].V(G);const M=x.Kl[2],b=x.Kl[3],X=x.Kl[4];V.normalize(),N.normalize(),M.normalize(),F.CrossToRef(M,V,b),F.CrossToRef(b,M,X);const R=Math.atan2(F.Dot(N,b),F.Dot(N,X));return(0,t.NormalizeRadians)(R)}static PitchYawRollToMoveBetweenPointsToRef(D,l,G){const V=r.Kl[0];return l.subtractToRef(D,V),G._y=Math.atan2(V.x,V.z)||0,G._x=Math.atan2(Math.sqrt(V.x**2+V.z**2),V.y)||0,G._z=0,G._isDirty=!0,G}static PitchYawRollToMoveBetweenPoints(D,l){const G=F.Zero();return F.PitchYawRollToMoveBetweenPointsToRef(D,l,G)}static SlerpToRef(D,l,G,N){G=(0,t.Clamp)(G,0,1);const M=x.Kl[0],b=x.Kl[1];M.V(D);const X=M.length();M.normalizeFromLength(X),b.V(l);const R=b.length();b.normalizeFromLength(R);const n=F.Dot(M,b);let g,j;if(n<1-V.b){const D=Math.acos(n),l=1/Math.sin(D);g=Math.sin((1-G)*D)*l,j=Math.sin(G*D)*l}else g=1-G,j=G;return M.scaleInPlace(g),b.scaleInPlace(j),N.V(M).addInPlace(b),N.scaleInPlace((0,t.Lerp)(X,R,G)),N}static SmoothToRef(D,l,G,V,N){return F.SlerpToRef(D,l,0===V?1:G/V,N),N}static xl(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(D[l],D[l+1],D[l+2])}static FromFloatArray(D,l){return F.xl(D,l)}static FromArrayToRef(D,l,G){return G._x=D[l],G._y=D[l+1],G._z=D[l+2],G._isDirty=!0,G}static FromFloatArrayToRef(D,l,G){return F.FromArrayToRef(D,l,G)}static FromFloatsToRef(D,l,G,V){return V.Lb(D,l,G),V}static Zero(){return new F(0,0,0)}static One(){return new F(1,1,1)}static Up(){return new F(0,1,0)}static get UpReadOnly(){return F._UpReadOnly}static get DownReadOnly(){return F._DownReadOnly}static get RightReadOnly(){return F._RightReadOnly}static get LeftReadOnly(){return F._LeftReadOnly}static get LeftHandedForwardReadOnly(){return F._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return F._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return F._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return F._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return F._ZeroReadOnly}static get OneReadOnly(){return F._OneReadOnly}static Down(){return new F(0,-1,0)}static Forward(){return new F(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new F(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new F(1,0,0)}static Left(){return new F(-1,0,0)}static Random(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new F((0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l))}static RandomToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Lb((0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l))}static TransformCoordinates(D,l){const G=F.Zero();return F.TransformCoordinatesToRef(D,l,G),G}static TransformCoordinatesToRef(D,l,G){return F.TransformCoordinatesFromFloatsToRef(D._x,D._y,D._z,l,G),G}static TransformCoordinatesFromFloatsToRef(D,l,G,V,N){const M=V.m,b=D*M[0]+l*M[4]+G*M[8]+M[12],X=D*M[1]+l*M[5]+G*M[9]+M[13],t=D*M[2]+l*M[6]+G*M[10]+M[14],R=1/(D*M[3]+l*M[7]+G*M[11]+M[15]);return N._x=b*R,N._y=X*R,N._z=t*R,N._isDirty=!0,N}static TransformNormal(D,l){const G=F.Zero();return F.TransformNormalToRef(D,l,G),G}static TransformNormalToRef(D,l,G){return this.TransformNormalFromFloatsToRef(D._x,D._y,D._z,l,G),G}static TransformNormalFromFloatsToRef(D,l,G,V,N){const M=V.m;return N._x=D*M[0]+l*M[4]+G*M[8],N._y=D*M[1]+l*M[5]+G*M[9],N._z=D*M[2]+l*M[6]+G*M[10],N._isDirty=!0,N}static CatmullRom(D,l,G,V,N){const M=N*N,b=N*M,X=.5*(2*l._x+(-D._x+G._x)*N+(2*D._x-5*l._x+4*G._x-V._x)*M+(-D._x+3*l._x-3*G._x+V._x)*b),t=.5*(2*l._y+(-D._y+G._y)*N+(2*D._y-5*l._y+4*G._y-V._y)*M+(-D._y+3*l._y-3*G._y+V._y)*b),R=.5*(2*l._z+(-D._z+G._z)*N+(2*D._z-5*l._z+4*G._z-V._z)*M+(-D._z+3*l._z-3*G._z+V._z)*b);return new F(X,t,R)}static Clamp(D,l,G){const V=new F;return F.ClampToRef(D,l,G,V),V}static ClampToRef(D,l,G,V){let N=D._x;N=N>G._x?G._x:N,N=N<l._x?l._x:N;let M=D._y;M=M>G._y?G._y:M,M=M<l._y?l._y:M;let b=D._z;return b=b>G._z?G._z:b,b=b<l._z?l._z:b,V.Lb(N,M,b),V}static CheckExtends(D,l,G){l.minimizeInPlace(D),G.maximizeInPlace(D)}static Hermite(D,l,G,V,N){const M=N*N,b=N*M,X=2*b-3*M+1,t=-2*b+3*M,R=b-2*M+N,n=b-M,g=D._x*X+G._x*t+l._x*R+V._x*n,j=D._y*X+G._y*t+l._y*R+V._y*n,e=D._z*X+G._z*t+l._z*R+V._z*n;return new F(g,j,e)}static Hermite1stDerivative(D,l,G,V,N){const M=new F;return this.Hermite1stDerivativeToRef(D,l,G,V,N,M),M}static Hermite1stDerivativeToRef(D,l,G,V,N,M){const b=N*N;return M._x=6*(b-N)*D._x+(3*b-4*N+1)*l._x+6*(-b+N)*G._x+(3*b-2*N)*V._x,M._y=6*(b-N)*D._y+(3*b-4*N+1)*l._y+6*(-b+N)*G._y+(3*b-2*N)*V._y,M._z=6*(b-N)*D._z+(3*b-4*N+1)*l._z+6*(-b+N)*G._z+(3*b-2*N)*V._z,M._isDirty=!0,M}static Lerp(D,l,G){const V=new F(0,0,0);return F.LerpToRef(D,l,G,V),V}static LerpToRef(D,l,G,V){return V._x=D._x+(l._x-D._x)*G,V._y=D._y+(l._y-D._y)*G,V._z=D._z+(l._z-D._z)*G,V._isDirty=!0,V}static Dot(D,l){return D._x*l._x+D._y*l._y+D._z*l._z}dot(D){return this._x*D._x+this._y*D._y+this._z*D._z}static Cross(D,l){const G=new F;return F.CrossToRef(D,l,G),G}static CrossToRef(D,l,G){const V=D._y*l._z-D._z*l._y,N=D._z*l._x-D._x*l._z,M=D._x*l._y-D._y*l._x;return G.Lb(V,N,M),G}static Normalize(D){const l=F.Zero();return F.NormalizeToRef(D,l),l}static NormalizeToRef(D,l){return D.normalizeToRef(l),l}static Project(D,l,G,V){const N=new F;return F.ProjectToRef(D,l,G,V,N),N}static ProjectToRef(D,l,G,V,N){var M;const b=V.width,t=V.height,R=V.x,n=V.y,g=x.Matrix[1],j=null===(M=X.d.LastCreatedEngine)||void 0===M?void 0:M.isNDCHalfZRange,e=j?1:.5,K=j?0:.5;h.FromValuesToRef(b/2,0,0,0,0,-t/2,0,0,0,0,e,0,R+b/2,t/2+n,K,1,g);const d=x.Matrix[0];return l.multiplyToRef(G,d),d.multiplyToRef(g,d),F.TransformCoordinatesToRef(D,d,N),N}static Reflect(D,l){return this.ReflectToRef(D,l,new F)}static ReflectToRef(D,l,G){const V=r.Kl[0];return V.V(l).scaleInPlace(2*F.Dot(D,l)),G.V(D).Kg(V)}static _UnprojectFromInvertedMatrixToRef(D,l,G){F.TransformCoordinatesToRef(D,l,G);const V=l.m,N=D._x*V[3]+D._y*V[7]+D._z*V[11]+V[15];return(0,t.WithinEpsilon)(N,1)&&G.scaleInPlace(1/N),G}static UnprojectFromTransform(D,l,G,V,N){return this.Unproject(D,l,G,V,N,h.IdentityReadOnly)}static Unproject(D,l,G,V,N,M){const b=new F;return F.UnprojectToRef(D,l,G,V,N,M,b),b}static UnprojectToRef(D,l,G,V,N,M,b){return F.UnprojectFloatsToRef(D._x,D._y,D._z,l,G,V,N,M,b),b}static UnprojectFloatsToRef(D,l,G,V,N,M,b,t,R){var n;const g=x.Matrix[0];M.multiplyToRef(b,g),g.multiplyToRef(t,g),g.invert();const j=x.Kl[0];return j.x=D/V*2-1,j.y=-(l/N*2-1),null!==(n=X.d.LastCreatedEngine)&&void 0!==n&&n.isNDCHalfZRange?j.z=G:j.z=2*G-1,F._UnprojectFromInvertedMatrixToRef(j,g,R),R}static Minimize(D,l){const G=new F;return G.V(D),G.minimizeInPlace(l),G}static Maximize(D,l){const G=new F;return G.V(D),G.maximizeInPlace(l),G}static Distance(D,l){return Math.sqrt(F.DistanceSquared(D,l))}static DistanceSquared(D,l){const G=D._x-l._x,V=D._y-l._y,N=D._z-l._z;return G*G+V*V+N*N}static ProjectOnTriangleToRef(D,l,G,N,M){const b=x.Kl[0],X=x.Kl[1],R=x.Kl[2],n=x.Kl[3],g=x.Kl[4];G.subtractToRef(l,b),N.subtractToRef(l,X),N.subtractToRef(G,R);const j=b.length(),e=X.length(),K=R.length();if(j<V.b||e<V.b||K<V.b)return M.V(l),F.Distance(D,l);D.subtractToRef(l,g),F.CrossToRef(b,X,n);const d=n.length();if(d<V.b)return M.V(l),F.Distance(D,l);n.normalizeFromLength(d);let H=g.length();if(H<V.b)return M.V(l),0;g.normalizeFromLength(H);const h=F.Dot(n,g),r=x.Kl[5],o=x.Kl[6];r.V(n).scaleInPlace(-H*h),o.V(D).addInPlace(r);const L=x.Kl[4],u=x.Kl[5],B=x.Kl[7],I=x.Kl[8];L.V(b).scaleInPlace(1/j),I.V(X).scaleInPlace(1/e),L.addInPlace(I).scaleInPlace(-1),u.V(b).scaleInPlace(-1/j),I.V(R).scaleInPlace(1/K),u.addInPlace(I).scaleInPlace(-1),B.V(R).scaleInPlace(-1/K),I.V(X).scaleInPlace(-1/e),B.addInPlace(I).scaleInPlace(-1);const W=x.Kl[9];let i;W.V(o).Kg(l),F.CrossToRef(L,W,I),i=F.Dot(I,n);const y=i;W.V(o).Kg(G),F.CrossToRef(u,W,I),i=F.Dot(I,n);const S=i;W.V(o).Kg(N),F.CrossToRef(B,W,I),i=F.Dot(I,n);const O=i,s=x.Kl[10];let U,f;y>0&&S<0?(s.V(b),U=l,f=G):S>0&&O<0?(s.V(R),U=G,f=N):(s.V(X).scaleInPlace(-1),U=N,f=l);const q=x.Kl[9],c=x.Kl[4];U.subtractToRef(o,I),f.subtractToRef(o,q),F.CrossToRef(I,q,c);if(!(F.Dot(c,n)<0))return M.V(o),Math.abs(H*h);const v=x.Kl[5];F.CrossToRef(s,c,v),v.normalize();const Z=x.Kl[9];Z.V(U).Kg(o);const J=Z.length();if(J<V.b)return M.V(U),F.Distance(D,U);Z.normalizeFromLength(J);const Y=F.Dot(v,Z),z=x.Kl[7];z.V(o).addInPlace(v.scaleInPlace(J*Y)),I.V(z).Kg(U),H=s.length(),s.normalizeFromLength(H);let E=F.Dot(I,s)/Math.max(H,V.b);return E=(0,t.Clamp)(E,0,1),z.V(U).addInPlace(s.scaleInPlace(E*H)),M.V(z),F.Distance(D,z)}static Center(D,l){return F.CenterToRef(D,l,F.Zero())}static CenterToRef(D,l,G){return G.Lb((D._x+l._x)/2,(D._y+l._y)/2,(D._z+l._z)/2)}static RotationFromAxis(D,l,G){const V=new F;return F.RotationFromAxisToRef(D,l,G,V),V}static RotationFromAxisToRef(D,l,G,V){const N=x.Quaternion[0];return H.RotationQuaternionFromAxisToRef(D,l,G,N),N.toEulerAnglesToRef(V),V}}F._V8PerformanceHack=new F(.5,.5,.5),F._UpReadOnly=F.Up(),F._DownReadOnly=F.Down(),F._LeftHandedForwardReadOnly=F.Forward(!1),F._RightHandedForwardReadOnly=F.Forward(!0),F._LeftHandedBackwardReadOnly=F.Backward(!1),F._RightHandedBackwardReadOnly=F.Backward(!0),F._RightReadOnly=F.Right(),F._LeftReadOnly=F.Left(),F._ZeroReadOnly=F.Zero(),F._OneReadOnly=F.One(),Object.defineProperties(F.prototype,{dimension:{value:[3]},rank:{value:1}});class d{get x(){return this._x}set x(D){this._x=D,this._isDirty=!0}get y(){return this._y}set y(D){this._y=D,this._isDirty=!0}get z(){return this._z}set z(D){this._z=D,this._isDirty=!0}get w(){return this._w}set w(D){this._w=D,this._isDirty=!0}constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=D,this._y=l,this._z=G,this._w=V}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let D=e(this._x);return D=397*D^e(this._y),D=397*D^e(this._z),D=397*D^e(this._w),D}gb(){return[this._x,this._y,this._z,this._w]}toArray(D,l){return void 0===l&&(l=0),D[l]=this._x,D[l+1]=this._y,D[l+2]=this._z,D[l+3]=this._w,this}KG(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return d.FromArrayToRef(D,l,this),this}addInPlace(D){return this.x+=D._x,this.y+=D._y,this.z+=D._z,this.w+=D._w,this}addInPlaceFromFloats(D,l,G,V){return this.x+=D,this.y+=l,this.z+=G,this.w+=V,this}add(D){return new d(this._x+D.x,this._y+D.y,this._z+D.z,this._w+D.w)}addToRef(D,l){return l.x=this._x+D.x,l.y=this._y+D.y,l.z=this._z+D.z,l.w=this._w+D.w,l}Kg(D){return this.x-=D.x,this.y-=D.y,this.z-=D.z,this.w-=D.w,this}Fl(D){return new d(this._x-D.x,this._y-D.y,this._z-D.z,this._w-D.w)}subtractToRef(D,l){return l.x=this._x-D.x,l.y=this._y-D.y,l.z=this._z-D.z,l.w=this._w-D.w,l}subtractFromFloats(D,l,G,V){return new d(this._x-D,this._y-l,this._z-G,this._w-V)}subtractFromFloatsToRef(D,l,G,V,N){return N.x=this._x-D,N.y=this._y-l,N.z=this._z-G,N.w=this._w-V,N}negate(){return new d(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(D){return D.x=-this._x,D.y=-this._y,D.z=-this._z,D.w=-this._w,D}scaleInPlace(D){return this.x*=D,this.y*=D,this.z*=D,this.w*=D,this}scale(D){return new d(this._x*D,this._y*D,this._z*D,this._w*D)}scaleToRef(D,l){return l.x=this._x*D,l.y=this._y*D,l.z=this._z*D,l.w=this._w*D,l}scaleAndAddToRef(D,l){return l.x+=this._x*D,l.y+=this._y*D,l.z+=this._z*D,l.w+=this._w*D,l}equals(D){return D&&this._x===D.x&&this._y===D.y&&this._z===D.z&&this._w===D.w}equalsWithEpsilon(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.b;return D&&(0,t.WithinEpsilon)(this._x,D.x,l)&&(0,t.WithinEpsilon)(this._y,D.y,l)&&(0,t.WithinEpsilon)(this._z,D.z,l)&&(0,t.WithinEpsilon)(this._w,D.w,l)}equalsToFloats(D,l,G,V){return this._x===D&&this._y===l&&this._z===G&&this._w===V}multiplyInPlace(D){return this.x*=D.x,this.y*=D.y,this.z*=D.z,this.w*=D.w,this}multiply(D){return new d(this._x*D.x,this._y*D.y,this._z*D.z,this._w*D.w)}multiplyToRef(D,l){return l.x=this._x*D.x,l.y=this._y*D.y,l.z=this._z*D.z,l.w=this._w*D.w,l}multiplyByFloats(D,l,G,V){return new d(this._x*D,this._y*l,this._z*G,this._w*V)}divide(D){return new d(this._x/D.x,this._y/D.y,this._z/D.z,this._w/D.w)}divideToRef(D,l){return l.x=this._x/D.x,l.y=this._y/D.y,l.z=this._z/D.z,l.w=this._w/D.w,l}divideInPlace(D){return this.divideToRef(D,this)}minimizeInPlace(D){return D.x<this._x&&(this.x=D.x),D.y<this._y&&(this.y=D.y),D.z<this._z&&(this.z=D.z),D.w<this._w&&(this.w=D.w),this}maximizeInPlace(D){return D.x>this._x&&(this.x=D.x),D.y>this._y&&(this.y=D.y),D.z>this._z&&(this.z=D.z),D.w>this._w&&(this.w=D.w),this}minimizeInPlaceFromFloats(D,l,G,V){return this.x=Math.min(D,this._x),this.y=Math.min(l,this._y),this.z=Math.min(G,this._z),this.w=Math.min(V,this._w),this}maximizeInPlaceFromFloats(D,l,G,V){return this.x=Math.max(D,this._x),this.y=Math.max(l,this._y),this.z=Math.max(G,this._z),this.w=Math.max(V,this._w),this}floorToRef(D){return D.x=Math.floor(this._x),D.y=Math.floor(this._y),D.z=Math.floor(this._z),D.w=Math.floor(this._w),D}floor(){return new d(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(D){return D.x=this._x-Math.floor(this._x),D.y=this._y-Math.floor(this._y),D.z=this._z-Math.floor(this._z),D.w=this._w-Math.floor(this._w),D}fract(){return new d(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(D){return 0===D||1===D?this:this.scaleInPlace(1/D)}normalizeToNew(){return this.normalizeToRef(new d)}normalizeToRef(D){const l=this.length();return 0===l||1===l?(D.x=this._x,D.y=this._y,D.z=this._z,D.w=this._w,D):this.scaleToRef(1/l,D)}toVector3(){return new F(this._x,this._y,this._z)}clone(){return new d(this._x,this._y,this._z,this._w)}V(D){return this.x=D.x,this.y=D.y,this.z=D.z,this.w=D.w,this}Lb(D,l,G,V){return this.x=D,this.y=l,this.z=G,this.w=V,this}set(D,l,G,V){return this.Lb(D,l,G,V)}Ib(D){return this.x=this.y=this.z=this.w=D,this}dot(D){return this._x*D.x+this._y*D.y+this._z*D.z+this._w*D.w}static xl(D,l){return l||(l=0),new d(D[l],D[l+1],D[l+2],D[l+3])}static FromArrayToRef(D,l,G){return G.x=D[l],G.y=D[l+1],G.z=D[l+2],G.w=D[l+3],G}static FromFloatArrayToRef(D,l,G){return d.FromArrayToRef(D,l,G),G}static FromFloatsToRef(D,l,G,V,N){return N.x=D,N.y=l,N.z=G,N.w=V,N}static Zero(){return new d(0,0,0,0)}static One(){return new d(1,1,1,1)}static Random(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new d((0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l))}static RandomToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,G=arguments.length>2?arguments[2]:void 0;return G.x=(0,t.RandomRange)(D,l),G.y=(0,t.RandomRange)(D,l),G.z=(0,t.RandomRange)(D,l),G.w=(0,t.RandomRange)(D,l),G}static Clamp(D,l,G){return d.ClampToRef(D,l,G,new d)}static ClampToRef(D,l,G,V){return V.x=(0,t.Clamp)(D.x,l.x,G.x),V.y=(0,t.Clamp)(D.y,l.y,G.y),V.z=(0,t.Clamp)(D.z,l.z,G.z),V.w=(0,t.Clamp)(D.w,l.w,G.w),V}static CheckExtends(D,l,G){l.minimizeInPlace(D),G.maximizeInPlace(D)}static get ZeroReadOnly(){return d._ZeroReadOnly}static Normalize(D){return d.NormalizeToRef(D,new d)}static NormalizeToRef(D,l){return D.normalizeToRef(l),l}static Minimize(D,l){const G=new d;return G.V(D),G.minimizeInPlace(l),G}static Maximize(D,l){const G=new d;return G.V(D),G.maximizeInPlace(l),G}static Distance(D,l){return Math.sqrt(d.DistanceSquared(D,l))}static DistanceSquared(D,l){const G=D.x-l.x,V=D.y-l.y,N=D.z-l.z,M=D.w-l.w;return G*G+V*V+N*N+M*M}static Center(D,l){return d.CenterToRef(D,l,new d)}static CenterToRef(D,l,G){return G.x=(D.x+l.x)/2,G.y=(D.y+l.y)/2,G.z=(D.z+l.z)/2,G.w=(D.w+l.w)/2,G}static TransformCoordinates(D,l){return d.TransformCoordinatesToRef(D,l,new d)}static TransformCoordinatesToRef(D,l,G){return d.TransformCoordinatesFromFloatsToRef(D._x,D._y,D._z,l,G),G}static TransformCoordinatesFromFloatsToRef(D,l,G,V,N){const M=V.m,b=D*M[0]+l*M[4]+G*M[8]+M[12],X=D*M[1]+l*M[5]+G*M[9]+M[13],t=D*M[2]+l*M[6]+G*M[10]+M[14],R=D*M[3]+l*M[7]+G*M[11]+M[15];return N.x=b,N.y=X,N.z=t,N.w=R,N}static TransformNormal(D,l){return d.TransformNormalToRef(D,l,new d)}static TransformNormalToRef(D,l,G){const V=l.m,N=D.x*V[0]+D.y*V[4]+D.z*V[8],M=D.x*V[1]+D.y*V[5]+D.z*V[9],b=D.x*V[2]+D.y*V[6]+D.z*V[10];return G.x=N,G.y=M,G.z=b,G.w=D.w,G}static TransformNormalFromFloatsToRef(D,l,G,V,N,M){const b=N.m;return M.x=D*b[0]+l*b[4]+G*b[8],M.y=D*b[1]+l*b[5]+G*b[9],M.z=D*b[2]+l*b[6]+G*b[10],M.w=V,M}static FromVector3(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new d(D._x,D._y,D._z,l)}static Dot(D,l){return D.x*l.x+D.y*l.y+D.z*l.z+D.w*l.w}}d._V8PerformanceHack=new d(.5,.5,.5,.5),d._ZeroReadOnly=d.Zero(),Object.defineProperties(d.prototype,{dimension:{value:[4]},rank:{value:1}});class H{get x(){return this._x}set x(D){this._x=D,this._isDirty=!0}get y(){return this._y}set y(D){this._y=D,this._isDirty=!0}get z(){return this._z}set z(D){this._z=D,this._isDirty=!0}get w(){return this._w}set w(D){this._w=D,this._isDirty=!0}constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=D,this._y=l,this._z=G,this._w=V}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let D=e(this._x);return D=397*D^e(this._y),D=397*D^e(this._z),D=397*D^e(this._w),D}gb(){return[this._x,this._y,this._z,this._w]}toArray(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D[l]=this._x,D[l+1]=this._y,D[l+2]=this._z,D[l+3]=this._w,this}KG(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H.FromArrayToRef(D,l,this)}equals(D){return D&&this._x===D._x&&this._y===D._y&&this._z===D._z&&this._w===D._w}equalsWithEpsilon(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.b;return D&&(0,t.WithinEpsilon)(this._x,D._x,l)&&(0,t.WithinEpsilon)(this._y,D._y,l)&&(0,t.WithinEpsilon)(this._z,D._z,l)&&(0,t.WithinEpsilon)(this._w,D._w,l)}isApprox(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:V.b;return D&&((0,t.WithinEpsilon)(this._x,D._x,l)&&(0,t.WithinEpsilon)(this._y,D._y,l)&&(0,t.WithinEpsilon)(this._z,D._z,l)&&(0,t.WithinEpsilon)(this._w,D._w,l)||(0,t.WithinEpsilon)(this._x,-D._x,l)&&(0,t.WithinEpsilon)(this._y,-D._y,l)&&(0,t.WithinEpsilon)(this._z,-D._z,l)&&(0,t.WithinEpsilon)(this._w,-D._w,l))}clone(){return new H(this._x,this._y,this._z,this._w)}V(D){return this._x=D._x,this._y=D._y,this._z=D._z,this._w=D._w,this._isDirty=!0,this}Lb(D,l,G,V){return this._x=D,this._y=l,this._z=G,this._w=V,this._isDirty=!0,this}set(D,l,G,V){return this.Lb(D,l,G,V)}Ib(D){return this.Lb(D,D,D,D)}add(D){return new H(this._x+D._x,this._y+D._y,this._z+D._z,this._w+D._w)}addInPlace(D){return this._x+=D._x,this._y+=D._y,this._z+=D._z,this._w+=D._w,this._isDirty=!0,this}addToRef(D,l){return l._x=this._x+D._x,l._y=this._y+D._y,l._z=this._z+D._z,l._w=this._w+D._w,l._isDirty=!0,l}addInPlaceFromFloats(D,l,G,V){return this._x+=D,this._y+=l,this._z+=G,this._w+=V,this._isDirty=!0,this}subtractToRef(D,l){return l._x=this._x-D._x,l._y=this._y-D._y,l._z=this._z-D._z,l._w=this._w-D._w,l._isDirty=!0,l}subtractFromFloats(D,l,G,V){return this.subtractFromFloatsToRef(D,l,G,V,new H)}subtractFromFloatsToRef(D,l,G,V,N){return N._x=this._x-D,N._y=this._y-l,N._z=this._z-G,N._w=this._w-V,N._isDirty=!0,N}Fl(D){return new H(this._x-D._x,this._y-D._y,this._z-D._z,this._w-D._w)}Kg(D){return this._x-=D._x,this._y-=D._y,this._z-=D._z,this._w-=D._w,this._isDirty=!0,this}scale(D){return new H(this._x*D,this._y*D,this._z*D,this._w*D)}scaleToRef(D,l){return l._x=this._x*D,l._y=this._y*D,l._z=this._z*D,l._w=this._w*D,l._isDirty=!0,l}scaleInPlace(D){return this._x*=D,this._y*=D,this._z*=D,this._w*=D,this._isDirty=!0,this}scaleAndAddToRef(D,l){return l._x+=this._x*D,l._y+=this._y*D,l._z+=this._z*D,l._w+=this._w*D,l._isDirty=!0,l}multiply(D){const l=new H(0,0,0,1);return this.multiplyToRef(D,l),l}multiplyToRef(D,l){const G=this._x*D._w+this._y*D._z-this._z*D._y+this._w*D._x,V=-this._x*D._z+this._y*D._w+this._z*D._x+this._w*D._y,N=this._x*D._y-this._y*D._x+this._z*D._w+this._w*D._z,M=-this._x*D._x-this._y*D._y-this._z*D._z+this._w*D._w;return l.Lb(G,V,N,M),l}multiplyInPlace(D){return this.multiplyToRef(D,this)}multiplyByFloats(D,l,G,V){return this._x*=D,this._y*=l,this._z*=G,this._w*=V,this._isDirty=!0,this}divide(D){throw new ReferenceError("Can not divide a quaternion")}divideToRef(D,l){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(D){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new H)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(D){return D._x=-this._x,D._y=-this._y,D._z=-this._z,D._w=-this._w,D._isDirty=!0,D}equalsToFloats(D,l,G,V){return this._x===D&&this._y===l&&this._z===G&&this._w===V}floorToRef(D){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(D){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(D){return D.Lb(-this._x,-this._y,-this._z,this._w),D}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new H(-this._x,-this._y,-this._z,this._w)}invert(){const D=this.conjugate(),l=this.lengthSquared();return 0==l||1==l||D.scaleInPlace(1/l),D}invertInPlace(){this.conjugateInPlace();const D=this.lengthSquared();return 0==D||1==D||this.scaleInPlace(1/D),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(D){return 0===D||1===D?this:this.scaleInPlace(1/D)}normalizeToNew(){const D=new H(0,0,0,1);return this.normalizeToRef(D),D}normalizeToRef(D){const l=this.length();return 0===l||1===l?D.Lb(this._x,this._y,this._z,this._w):this.scaleToRef(1/l,D)}toEulerAngles(){const D=F.Zero();return this.toEulerAnglesToRef(D),D}toEulerAnglesToRef(D){const l=this._z,G=this._x,V=this._y,N=this._w,M=V*l-G*N,b=.4999999;if(M<-b)D._y=2*Math.atan2(V,N),D._x=Math.PI/2,D._z=0,D._isDirty=!0;else if(M>b)D._y=2*Math.atan2(V,N),D._x=-Math.PI/2,D._z=0,D._isDirty=!0;else{const b=N*N,X=l*l,t=G*G,R=V*V;D._z=Math.atan2(2*(G*V+l*N),-X-t+R+b),D._x=Math.asin(-2*M),D._y=Math.atan2(2*(l*G+V*N),X-t-R+b),D._isDirty=!0}return D}toAlphaBetaGammaToRef(D){const l=this._z,G=this._x,V=this._y,N=this._w,M=Math.sqrt(G*G+V*V),b=Math.sqrt(l*l+N*N),X=2*Math.atan2(M,b),t=2*Math.atan2(l,N),R=2*Math.atan2(V,G),n=(t+R)/2,g=(t-R)/2;return D.set(g,X,n),D}toRotationMatrix(D){return h.FromQuaternionToRef(this,D),D}fromRotationMatrix(D){return H.FromRotationMatrixToRef(D,this),this}dot(D){return this._x*D._x+this._y*D._y+this._z*D._z+this._w*D._w}toAxisAngle(){const D=F.Zero();return{axis:D,angle:this.toAxisAngleToRef(D)}}toAxisAngleToRef(D){let l=0;const G=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),V=this._w;return G>0?(l=2*Math.atan2(G,V),D.set(this._x/G,this._y/G,this._z/G)):(l=0,D.set(1,0,0)),l}static FromRotationMatrix(D){const l=new H;return H.FromRotationMatrixToRef(D,l),l}static FromRotationMatrixToRef(D,l){const G=D.m,V=G[0],N=G[4],M=G[8],b=G[1],X=G[5],t=G[9],R=G[2],n=G[6],g=G[10],j=V+X+g;let e;return j>0?(e=.5/Math.sqrt(j+1),l._w=.25/e,l._x=(n-t)*e,l._y=(M-R)*e,l._z=(b-N)*e,l._isDirty=!0):V>X&&V>g?(e=2*Math.sqrt(1+V-X-g),l._w=(n-t)/e,l._x=.25*e,l._y=(N+b)/e,l._z=(M+R)/e,l._isDirty=!0):X>g?(e=2*Math.sqrt(1+X-V-g),l._w=(M-R)/e,l._x=(N+b)/e,l._y=.25*e,l._z=(t+n)/e,l._isDirty=!0):(e=2*Math.sqrt(1+g-V-X),l._w=(b-N)/e,l._x=(M+R)/e,l._y=(t+n)/e,l._z=.25*e,l._isDirty=!0),l}static Dot(D,l){return D._x*l._x+D._y*l._y+D._z*l._z+D._w*l._w}static AreClose(D,l){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const V=H.Dot(D,l);return 1-V*V<=G}static SmoothToRef(D,l,G,V,N){let M=0===V?1:G/V;return M=(0,t.Clamp)(M,0,1),H.SlerpToRef(D,l,M,N),N}static Zero(){return new H(0,0,0,0)}static Inverse(D){return new H(-D._x,-D._y,-D._z,D._w)}static InverseToRef(D,l){return l.set(-D._x,-D._y,-D._z,D._w),l}static Identity(){return new H(0,0,0,1)}static IsIdentity(D){return D&&0===D._x&&0===D._y&&0===D._z&&1===D._w}static RotationAxis(D,l){return H.RotationAxisToRef(D,l,new H)}static RotationAxisToRef(D,l,G){G._w=Math.cos(l/2);const V=Math.sin(l/2)/D.length();return G._x=D._x*V,G._y=D._y*V,G._z=D._z*V,G._isDirty=!0,G}static xl(D,l){return l||(l=0),new H(D[l],D[l+1],D[l+2],D[l+3])}static FromArrayToRef(D,l,G){return G._x=D[l],G._y=D[l+1],G._z=D[l+2],G._w=D[l+3],G._isDirty=!0,G}static FromFloatsToRef(D,l,G,V,N){return N.Lb(D,l,G,V),N}static FromEulerAngles(D,l,G){const V=new H;return H.RotationYawPitchRollToRef(l,D,G,V),V}static FromEulerAnglesToRef(D,l,G,V){return H.RotationYawPitchRollToRef(l,D,G,V),V}static FromEulerVector(D){const l=new H;return H.RotationYawPitchRollToRef(D._y,D._x,D._z,l),l}static FromEulerVectorToRef(D,l){return H.RotationYawPitchRollToRef(D._y,D._x,D._z,l),l}static FromUnitVectorsToRef(D,l,G){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V.b;const M=F.Dot(D,l)+1;return M<N?Math.abs(D.x)>Math.abs(D.z)?G.set(-D.y,D.x,0,0):G.set(0,-D.z,D.y,0):(F.CrossToRef(D,l,r.Kl[0]),G.set(r.Kl[0].x,r.Kl[0].y,r.Kl[0].z,M)),G.normalize()}static RotationYawPitchRoll(D,l,G){const V=new H;return H.RotationYawPitchRollToRef(D,l,G,V),V}static RotationYawPitchRollToRef(D,l,G,V){const N=.5*G,M=.5*l,b=.5*D,X=Math.sin(N),t=Math.cos(N),R=Math.sin(M),n=Math.cos(M),g=Math.sin(b),j=Math.cos(b);return V._x=j*R*t+g*n*X,V._y=g*n*t-j*R*X,V._z=j*n*X-g*R*t,V._w=j*n*t+g*R*X,V._isDirty=!0,V}static RotationAlphaBetaGamma(D,l,G){const V=new H;return H.RotationAlphaBetaGammaToRef(D,l,G,V),V}static RotationAlphaBetaGammaToRef(D,l,G,V){const N=.5*(G+D),M=.5*(G-D),b=.5*l;return V._x=Math.cos(M)*Math.sin(b),V._y=Math.sin(M)*Math.sin(b),V._z=Math.sin(N)*Math.cos(b),V._w=Math.cos(N)*Math.cos(b),V._isDirty=!0,V}static RotationQuaternionFromAxis(D,l,G){const V=new H(0,0,0,0);return H.RotationQuaternionFromAxisToRef(D,l,G,V),V}static RotationQuaternionFromAxisToRef(D,l,G,V){const N=x.Matrix[0];return D=D.normalizeToRef(x.Kl[0]),l=l.normalizeToRef(x.Kl[1]),G=G.normalizeToRef(x.Kl[2]),h.FromXYZAxesToRef(D,l,G,N),H.FromRotationMatrixToRef(N,V),V}static FromLookDirectionLH(D,l){const G=new H;return H.FromLookDirectionLHToRef(D,l,G),G}static FromLookDirectionLHToRef(D,l,G){const V=x.Matrix[0];return h.LookDirectionLHToRef(D,l,V),H.FromRotationMatrixToRef(V,G),G}static FromLookDirectionRH(D,l){const G=new H;return H.FromLookDirectionRHToRef(D,l,G),G}static FromLookDirectionRHToRef(D,l,G){const V=x.Matrix[0];return h.LookDirectionRHToRef(D,l,V),H.FromRotationMatrixToRef(V,G)}static Slerp(D,l,G){const V=H.Identity();return H.SlerpToRef(D,l,G,V),V}static SlerpToRef(D,l,G,V){let N,M,b=D._x*l._x+D._y*l._y+D._z*l._z+D._w*l._w,X=!1;if(b<0&&(X=!0,b=-b),b>.999999)M=1-G,N=X?-G:G;else{const D=Math.acos(b),l=1/Math.sin(D);M=Math.sin((1-G)*D)*l,N=X?-Math.sin(G*D)*l:Math.sin(G*D)*l}return V._x=M*D._x+N*l._x,V._y=M*D._y+N*l._y,V._z=M*D._z+N*l._z,V._w=M*D._w+N*l._w,V._isDirty=!0,V}static Hermite(D,l,G,V,N){const M=N*N,b=N*M,X=2*b-3*M+1,t=-2*b+3*M,R=b-2*M+N,n=b-M,g=D._x*X+G._x*t+l._x*R+V._x*n,j=D._y*X+G._y*t+l._y*R+V._y*n,e=D._z*X+G._z*t+l._z*R+V._z*n,K=D._w*X+G._w*t+l._w*R+V._w*n;return new H(g,j,e,K)}static Hermite1stDerivative(D,l,G,V,N){const M=new H;return this.Hermite1stDerivativeToRef(D,l,G,V,N,M),M}static Hermite1stDerivativeToRef(D,l,G,V,N,M){const b=N*N;return M._x=6*(b-N)*D._x+(3*b-4*N+1)*l._x+6*(-b+N)*G._x+(3*b-2*N)*V._x,M._y=6*(b-N)*D._y+(3*b-4*N+1)*l._y+6*(-b+N)*G._y+(3*b-2*N)*V._y,M._z=6*(b-N)*D._z+(3*b-4*N+1)*l._z+6*(-b+N)*G._z+(3*b-2*N)*V._z,M._w=6*(b-N)*D._w+(3*b-4*N+1)*l._w+6*(-b+N)*G._w+(3*b-2*N)*V._w,M._isDirty=!0,M}static Normalize(D){const l=H.Zero();return H.NormalizeToRef(D,l),l}static NormalizeToRef(D,l){return D.normalizeToRef(l),l}static Clamp(D,l,G){const V=new H;return H.ClampToRef(D,l,G,V),V}static ClampToRef(D,l,G,V){return V.Lb((0,t.Clamp)(D.x,l.x,G.x),(0,t.Clamp)(D.y,l.y,G.y),(0,t.Clamp)(D.z,l.z,G.z),(0,t.Clamp)(D.w,l.w,G.w))}static Random(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new H((0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l))}static RandomToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Lb((0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l),(0,t.RandomRange)(D,l))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(D,l){return Math.sqrt(H.DistanceSquared(D,l))}static DistanceSquared(D,l){const G=D.x-l.x,V=D.y-l.y,N=D.z-l.z,M=D.w-l.w;return G*G+V*V+N*N+M*M}static Center(D,l){return H.CenterToRef(D,l,H.Zero())}static CenterToRef(D,l,G){return G.Lb((D.x+l.x)/2,(D.y+l.y)/2,(D.z+l.z)/2,(D.w+l.w)/2)}}H._V8PerformanceHack=new H(.5,.5,.5,.5),Object.defineProperties(H.prototype,{dimension:{value:[4]},rank:{value:1}});class h{static get Use64Bits(){return b.d.MatrixUse64Bits}get m(){return this.Nb}markAsUpdated(){this.updateFlag=R._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(D){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1],G=arguments.length>2&&void 0!==arguments[2]&&arguments[2],V=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=D,this._isIdentity3x2=D||G,this._isIdentityDirty=!this._isIdentity&&l,this._isIdentity3x2Dirty=!this._isIdentity3x2&&V}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,b.d.MatrixTrackPrecisionChange&&b.d.MatrixTrackedMatrices.push(this),this.Nb=new b.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const D=this.Nb;this._isIdentity=1===D[0]&&0===D[1]&&0===D[2]&&0===D[3]&&0===D[4]&&1===D[5]&&0===D[6]&&0===D[7]&&0===D[8]&&0===D[9]&&1===D[10]&&0===D[11]&&0===D[12]&&0===D[13]&&0===D[14]&&1===D[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Nb[0]||1!==this.Nb[5]||1!==this.Nb[15]||0!==this.Nb[1]||0!==this.Nb[2]||0!==this.Nb[3]||0!==this.Nb[4]||0!==this.Nb[6]||0!==this.Nb[7]||0!==this.Nb[8]||0!==this.Nb[9]||0!==this.Nb[10]||0!==this.Nb[11]||0!==this.Nb[12]||0!==this.Nb[13]||0!==this.Nb[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const D=this.Nb,l=D[0],G=D[1],V=D[2],N=D[3],M=D[4],b=D[5],X=D[6],t=D[7],R=D[8],n=D[9],g=D[10],j=D[11],e=D[12],K=D[13],F=D[14],d=D[15],H=g*d-F*j,h=n*d-K*j,x=n*F-K*g,r=R*d-e*j,o=R*F-g*e,L=R*K-e*n;return l*+(b*H-X*h+t*x)+G*-(M*H-X*r+t*o)+V*+(M*h-b*r+t*L)+N*-(M*x-b*o+X*L)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!D)return this.Nb;const G=this.Nb;for(let V=0;V<16;V++)D[l+V]=G[V];return this}gb(){return this.Nb}KG(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h.FromArrayToRef(D,l,this)}Lb(){for(var D=arguments.length,l=new Array(D),G=0;G<D;G++)l[G]=arguments[G];return h.FromArrayToRef(l,0,this)}set(){const D=this.Nb;for(let l=0;l<16;l++)D[l]=l<0||arguments.length<=l?void 0:arguments[l];return this.markAsUpdated(),this}Ib(D){const l=this.Nb;for(let G=0;G<16;G++)l[G]=D;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return h.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(D){const l=new h;return this.addToRef(D,l),l}addToRef(D,l){const G=this.Nb,V=l.Nb,N=D.m;for(let M=0;M<16;M++)V[M]=G[M]+N[M];return l.markAsUpdated(),l}addToSelf(D){const l=this.Nb,G=D.m;return l[0]+=G[0],l[1]+=G[1],l[2]+=G[2],l[3]+=G[3],l[4]+=G[4],l[5]+=G[5],l[6]+=G[6],l[7]+=G[7],l[8]+=G[8],l[9]+=G[9],l[10]+=G[10],l[11]+=G[11],l[12]+=G[12],l[13]+=G[13],l[14]+=G[14],l[15]+=G[15],this.markAsUpdated(),this}addInPlace(D){const l=this.Nb,G=D.m;for(let V=0;V<16;V++)l[V]+=G[V];return this.markAsUpdated(),this}addInPlaceFromFloats(){const D=this.Nb;for(let l=0;l<16;l++)D[l]+=l<0||arguments.length<=l?void 0:arguments[l];return this.markAsUpdated(),this}Fl(D){const l=this.Nb,G=D.m;for(let V=0;V<16;V++)l[V]-=G[V];return this.markAsUpdated(),this}subtractToRef(D,l){const G=this.Nb,V=D.m,N=l.Nb;for(let M=0;M<16;M++)N[M]=G[M]-V[M];return l.markAsUpdated(),l}Kg(D){const l=this.Nb,G=D.m;for(let V=0;V<16;V++)l[V]-=G[V];return this.markAsUpdated(),this}subtractFromFloats(){for(var D=arguments.length,l=new Array(D),G=0;G<D;G++)l[G]=arguments[G];return this.subtractFromFloatsToRef(...l,new h)}subtractFromFloatsToRef(){for(var D=arguments.length,l=new Array(D),G=0;G<D;G++)l[G]=arguments[G];const V=l.pop(),N=this.Nb,M=V.Nb,b=l;for(let X=0;X<16;X++)M[X]=N[X]-b[X];return V.markAsUpdated(),V}invertToRef(D){return!0===this._isIdentity?(h.IdentityToRef(D),D):(j(this,D.gb())?D.markAsUpdated():D.V(this),D)}addAtIndex(D,l){return this.Nb[D]+=l,this.markAsUpdated(),this}multiplyAtIndex(D,l){return this.Nb[D]*=l,this.markAsUpdated(),this}setTranslationFromFloats(D,l,G){return this.Nb[12]=D,this.Nb[13]=l,this.Nb[14]=G,this.markAsUpdated(),this}addTranslationFromFloats(D,l,G){return this.Nb[12]+=D,this.Nb[13]+=l,this.Nb[14]+=G,this.markAsUpdated(),this}setTranslation(D){return this.setTranslationFromFloats(D._x,D._y,D._z)}getTranslation(){return new F(this.Nb[12],this.Nb[13],this.Nb[14])}getTranslationToRef(D){return D.x=this.Nb[12],D.y=this.Nb[13],D.z=this.Nb[14],D}removeRotationAndScaling(){const D=this.m;return h.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,D[12],D[13],D[14],D[15],this),this._updateIdentityStatus(0===D[12]&&0===D[13]&&0===D[14]&&1===D[15]),this}V(D){D.copyToArray(this.Nb);const l=D;return this.updateFlag=l.updateFlag,this._updateIdentityStatus(l._isIdentity,l._isIdentityDirty,l._isIdentity3x2,l._isIdentity3x2Dirty),this}copyToArray(D){return g(this,D,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(D){const l=new h;return this.multiplyToRef(D,l),l}multiplyInPlace(D){const l=this.Nb,G=D.m;for(let V=0;V<16;V++)l[V]*=G[V];return this.markAsUpdated(),this}multiplyByFloats(){const D=this.Nb;for(let l=0;l<16;l++)D[l]*=l<0||arguments.length<=l?void 0:arguments[l];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var D=arguments.length,l=new Array(D),G=0;G<D;G++)l[G]=arguments[G];const V=l.pop(),N=this.Nb,M=V.Nb,b=l;for(let X=0;X<16;X++)M[X]=N[X]*b[X];return V.markAsUpdated(),V}multiplyToRef(D,l){return this._isIdentity?(l.V(D),l):D._isIdentity?(l.V(this),l):(this.multiplyToArray(D,l.Nb,0),l.markAsUpdated(),l)}multiplyToArray(D,l,G){return n(this,D,l,G),this}divide(D){return this.divideToRef(D,new h)}divideToRef(D,l){const G=this.Nb,V=D.m,N=l.Nb;for(let M=0;M<16;M++)N[M]=G[M]/V[M];return l.markAsUpdated(),l}divideInPlace(D){const l=this.Nb,G=D.m;for(let V=0;V<16;V++)l[V]/=G[V];return this.markAsUpdated(),this}minimizeInPlace(D){const l=this.Nb,G=D.m;for(let V=0;V<16;V++)l[V]=Math.min(l[V],G[V]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const D=this.Nb;for(let l=0;l<16;l++)D[l]=Math.min(D[l],l<0||arguments.length<=l?void 0:arguments[l]);return this.markAsUpdated(),this}maximizeInPlace(D){const l=this.Nb,G=D.m;for(let V=0;V<16;V++)l[V]=Math.min(l[V],G[V]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const D=this.Nb;for(let l=0;l<16;l++)D[l]=Math.min(D[l],l<0||arguments.length<=l?void 0:arguments[l]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new h)}negateInPlace(){const D=this.Nb;for(let l=0;l<16;l++)D[l]=-D[l];return this.markAsUpdated(),this}negateToRef(D){const l=this.Nb,G=D.Nb;for(let V=0;V<16;V++)G[V]=-l[V];return D.markAsUpdated(),D}equals(D){const l=D;if(!l)return!1;if((this._isIdentity||l._isIdentity)&&!this._isIdentityDirty&&!l._isIdentityDirty)return this._isIdentity&&l._isIdentity;const G=this.m,V=l.m;return G[0]===V[0]&&G[1]===V[1]&&G[2]===V[2]&&G[3]===V[3]&&G[4]===V[4]&&G[5]===V[5]&&G[6]===V[6]&&G[7]===V[7]&&G[8]===V[8]&&G[9]===V[9]&&G[10]===V[10]&&G[11]===V[11]&&G[12]===V[12]&&G[13]===V[13]&&G[14]===V[14]&&G[15]===V[15]}equalsWithEpsilon(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const G=this.Nb,V=D.m;for(let N=0;N<16;N++)if(!(0,t.WithinEpsilon)(G[N],V[N],l))return!1;return!0}equalsToFloats(){const D=this.Nb;for(let l=0;l<16;l++)if(D[l]!=(l<0||arguments.length<=l?void 0:arguments[l]))return!1;return!0}floor(){return this.floorToRef(new h)}floorToRef(D){const l=this.Nb,G=D.Nb;for(let V=0;V<16;V++)G[V]=Math.floor(l[V]);return D.markAsUpdated(),D}fract(){return this.fractToRef(new h)}fractToRef(D){const l=this.Nb,G=D.Nb;for(let V=0;V<16;V++)G[V]=l[V]-Math.floor(l[V]);return D.markAsUpdated(),D}clone(){const D=new h;return D.V(this),D}getClassName(){return"Matrix"}getHashCode(){let D=e(this.Nb[0]);for(let l=1;l<16;l++)D=397*D^e(this.Nb[l]);return D}decomposeToTransformNode(D){return D.rotationQuaternion=D.rotationQuaternion||new H,this.decompose(D.ub,D.rotationQuaternion,D.position)}decompose(D,l,G,V){let N=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return G&&G.Ib(0),D&&D.Ib(1),l&&l.Lb(0,0,0,1),!0;const M=this.Nb;if(G&&G.Lb(M[12],M[13],M[14]),(D=D||x.Kl[0]).x=Math.sqrt(M[0]*M[0]+M[1]*M[1]+M[2]*M[2]),D.y=Math.sqrt(M[4]*M[4]+M[5]*M[5]+M[6]*M[6]),D.z=Math.sqrt(M[8]*M[8]+M[9]*M[9]+M[10]*M[10]),V){const l=(N?V.absoluteScaling.x:V.ub.x)<0?-1:1,G=(N?V.absoluteScaling.y:V.ub.y)<0?-1:1,M=(N?V.absoluteScaling.z:V.ub.z)<0?-1:1;D.x*=l,D.y*=G,D.z*=M}else this.determinant()<=0&&(D.y*=-1);if(0===D._x||0===D._y||0===D._z)return l&&l.Lb(0,0,0,1),!1;if(l){const G=1/D._x,V=1/D._y,N=1/D._z;h.FromValuesToRef(M[0]*G,M[1]*G,M[2]*G,0,M[4]*V,M[5]*V,M[6]*V,0,M[8]*N,M[9]*N,M[10]*N,0,0,0,0,1,x.Matrix[0]),H.FromRotationMatrixToRef(x.Matrix[0],l)}return!0}getRow(D){if(D<0||D>3)return null;const l=4*D;return new d(this.Nb[l+0],this.Nb[l+1],this.Nb[l+2],this.Nb[l+3])}getRowToRef(D,l){if(D>=0&&D<=3){const G=4*D;l.x=this.Nb[G+0],l.y=this.Nb[G+1],l.z=this.Nb[G+2],l.w=this.Nb[G+3]}return l}setRow(D,l){return this.setRowFromFloats(D,l.x,l.y,l.z,l.w)}transpose(){const D=new h;return h.TransposeToRef(this,D),D}transposeToRef(D){return h.TransposeToRef(this,D),D}setRowFromFloats(D,l,G,V,N){if(D<0||D>3)return this;const M=4*D;return this.Nb[M+0]=l,this.Nb[M+1]=G,this.Nb[M+2]=V,this.Nb[M+3]=N,this.markAsUpdated(),this}scale(D){const l=new h;return this.scaleToRef(D,l),l}scaleToRef(D,l){for(let G=0;G<16;G++)l.Nb[G]=this.Nb[G]*D;return l.markAsUpdated(),l}scaleAndAddToRef(D,l){for(let G=0;G<16;G++)l.Nb[G]+=this.Nb[G]*D;return l.markAsUpdated(),l}scaleInPlace(D){const l=this.Nb;for(let G=0;G<16;G++)l[G]*=D;return this.markAsUpdated(),this}toNormalMatrix(D){const l=x.Matrix[0];this.invertToRef(l),l.transposeToRef(D);const G=D.Nb;return h.FromValuesToRef(G[0],G[1],G[2],0,G[4],G[5],G[6],0,G[8],G[9],G[10],0,0,0,0,1,D),D}getRotationMatrix(){const D=new h;return this.getRotationMatrixToRef(D),D}getRotationMatrixToRef(D){const l=x.Kl[0];if(!this.decompose(l))return h.IdentityToRef(D),D;const G=this.Nb,V=1/l._x,N=1/l._y,M=1/l._z;return h.FromValuesToRef(G[0]*V,G[1]*V,G[2]*V,0,G[4]*N,G[5]*N,G[6]*N,0,G[8]*M,G[9]*M,G[10]*M,0,0,0,0,1,D),D}toggleModelMatrixHandInPlace(){const D=this.Nb;return D[2]*=-1,D[6]*=-1,D[8]*=-1,D[9]*=-1,D[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const D=this.Nb;return D[8]*=-1,D[9]*=-1,D[10]*=-1,D[11]*=-1,this.markAsUpdated(),this}static xl(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const G=new h;return h.FromArrayToRef(D,l,G),G}static FromArrayToRef(D,l,G){for(let V=0;V<16;V++)G.Nb[V]=D[V+l];return G.markAsUpdated(),G}static FromFloat32ArrayToRefScaled(D,l,G,V){return V.Nb[0]=D[0+l]*G,V.Nb[1]=D[1+l]*G,V.Nb[2]=D[2+l]*G,V.Nb[3]=D[3+l]*G,V.Nb[4]=D[4+l]*G,V.Nb[5]=D[5+l]*G,V.Nb[6]=D[6+l]*G,V.Nb[7]=D[7+l]*G,V.Nb[8]=D[8+l]*G,V.Nb[9]=D[9+l]*G,V.Nb[10]=D[10+l]*G,V.Nb[11]=D[11+l]*G,V.Nb[12]=D[12+l]*G,V.Nb[13]=D[13+l]*G,V.Nb[14]=D[14+l]*G,V.Nb[15]=D[15+l]*G,V.markAsUpdated(),V}static get IdentityReadOnly(){return h._IdentityReadOnly}static FromValuesToRef(D,l,G,V,N,M,b,X,t,R,n,g,j,e,K,F,d){const H=d.Nb;H[0]=D,H[1]=l,H[2]=G,H[3]=V,H[4]=N,H[5]=M,H[6]=b,H[7]=X,H[8]=t,H[9]=R,H[10]=n,H[11]=g,H[12]=j,H[13]=e,H[14]=K,H[15]=F,d.markAsUpdated()}static FromValues(D,l,G,V,N,M,b,X,t,R,n,g,j,e,K,F){const d=new h,H=d.Nb;return H[0]=D,H[1]=l,H[2]=G,H[3]=V,H[4]=N,H[5]=M,H[6]=b,H[7]=X,H[8]=t,H[9]=R,H[10]=n,H[11]=g,H[12]=j,H[13]=e,H[14]=K,H[15]=F,d.markAsUpdated(),d}static Compose(D,l,G){const V=new h;return h.ComposeToRef(D,l,G,V),V}static ComposeToRef(D,l,G,V){const N=V.Nb,M=l._x,b=l._y,X=l._z,t=l._w,R=M+M,n=b+b,g=X+X,j=M*R,e=M*n,K=M*g,F=b*n,d=b*g,H=X*g,h=t*R,x=t*n,r=t*g,o=D._x,L=D._y,u=D._z;return N[0]=(1-(F+H))*o,N[1]=(e+r)*o,N[2]=(K-x)*o,N[3]=0,N[4]=(e-r)*L,N[5]=(1-(j+H))*L,N[6]=(d+h)*L,N[7]=0,N[8]=(K+x)*u,N[9]=(d-h)*u,N[10]=(1-(j+F))*u,N[11]=0,N[12]=G._x,N[13]=G._y,N[14]=G._z,N[15]=1,V.markAsUpdated(),V}static Identity(){const D=h.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return D._updateIdentityStatus(!0),D}static IdentityToRef(D){return h.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,D),D._updateIdentityStatus(!0),D}static Zero(){const D=h.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return D._updateIdentityStatus(!1),D}static RotationX(D){const l=new h;return h.RotationXToRef(D,l),l}static Invert(D){const l=new h;return D.invertToRef(l),l}static RotationXToRef(D,l){const G=Math.sin(D),V=Math.cos(D);return h.FromValuesToRef(1,0,0,0,0,V,G,0,0,-G,V,0,0,0,0,1,l),l._updateIdentityStatus(1===V&&0===G),l}static RotationY(D){const l=new h;return h.RotationYToRef(D,l),l}static RotationYToRef(D,l){const G=Math.sin(D),V=Math.cos(D);return h.FromValuesToRef(V,0,-G,0,0,1,0,0,G,0,V,0,0,0,0,1,l),l._updateIdentityStatus(1===V&&0===G),l}static RotationZ(D){const l=new h;return h.RotationZToRef(D,l),l}static RotationZToRef(D,l){const G=Math.sin(D),V=Math.cos(D);return h.FromValuesToRef(V,G,0,0,-G,V,0,0,0,0,1,0,0,0,0,1,l),l._updateIdentityStatus(1===V&&0===G),l}static RotationAxis(D,l){const G=new h;return h.RotationAxisToRef(D,l,G),G}static RotationAxisToRef(D,l,G){const V=Math.sin(-l),N=Math.cos(-l),M=1-N;D=D.normalizeToRef(x.Kl[0]);const b=G.Nb;return b[0]=D._x*D._x*M+N,b[1]=D._x*D._y*M-D._z*V,b[2]=D._x*D._z*M+D._y*V,b[3]=0,b[4]=D._y*D._x*M+D._z*V,b[5]=D._y*D._y*M+N,b[6]=D._y*D._z*M-D._x*V,b[7]=0,b[8]=D._z*D._x*M-D._y*V,b[9]=D._z*D._y*M+D._x*V,b[10]=D._z*D._z*M+N,b[11]=0,b[12]=0,b[13]=0,b[14]=0,b[15]=1,G.markAsUpdated(),G}static RotationAlignToRef(D,l,G){let N=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const M=F.Dot(l,D),b=G.Nb;if(M<-1+V.b)b[0]=-1,b[1]=0,b[2]=0,b[3]=0,b[4]=0,b[5]=N?1:-1,b[6]=0,b[7]=0,b[8]=0,b[9]=0,b[10]=N?-1:1,b[11]=0;else{const G=F.Cross(l,D),V=1/(1+M);b[0]=G._x*G._x*V+M,b[1]=G._y*G._x*V-G._z,b[2]=G._z*G._x*V+G._y,b[3]=0,b[4]=G._x*G._y*V+G._z,b[5]=G._y*G._y*V+M,b[6]=G._z*G._y*V-G._x,b[7]=0,b[8]=G._x*G._z*V-G._y,b[9]=G._y*G._z*V+G._x,b[10]=G._z*G._z*V+M,b[11]=0}return b[12]=0,b[13]=0,b[14]=0,b[15]=1,G.markAsUpdated(),G}static RotationYawPitchRoll(D,l,G){const V=new h;return h.RotationYawPitchRollToRef(D,l,G,V),V}static RotationYawPitchRollToRef(D,l,G,V){return H.RotationYawPitchRollToRef(D,l,G,x.Quaternion[0]),x.Quaternion[0].toRotationMatrix(V),V}static Scaling(D,l,G){const V=new h;return h.ScalingToRef(D,l,G,V),V}static ScalingToRef(D,l,G,V){return h.FromValuesToRef(D,0,0,0,0,l,0,0,0,0,G,0,0,0,0,1,V),V._updateIdentityStatus(1===D&&1===l&&1===G),V}static Translation(D,l,G){const V=new h;return h.TranslationToRef(D,l,G,V),V}static TranslationToRef(D,l,G,V){return h.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,D,l,G,1,V),V._updateIdentityStatus(0===D&&0===l&&0===G),V}static Lerp(D,l,G){const V=new h;return h.LerpToRef(D,l,G,V),V}static LerpToRef(D,l,G,V){const N=V.Nb,M=D.m,b=l.m;for(let X=0;X<16;X++)N[X]=M[X]*(1-G)+b[X]*G;return V.markAsUpdated(),V}static DecomposeLerp(D,l,G){const V=new h;return h.DecomposeLerpToRef(D,l,G,V),V}static DecomposeLerpToRef(D,l,G,V){const N=x.Kl[0],M=x.Quaternion[0],b=x.Kl[1];D.decompose(N,M,b);const X=x.Kl[2],t=x.Quaternion[1],R=x.Kl[3];l.decompose(X,t,R);const n=x.Kl[4];F.LerpToRef(N,X,G,n);const g=x.Quaternion[2];H.SlerpToRef(M,t,G,g);const j=x.Kl[5];return F.LerpToRef(b,R,G,j),h.ComposeToRef(n,g,j,V),V}static LookAtLH(D,l,G){const V=new h;return h.LookAtLHToRef(D,l,G,V),V}static LookAtLHToRef(D,l,G,V){const N=x.Kl[0],M=x.Kl[1],b=x.Kl[2];l.subtractToRef(D,b),b.normalize(),F.CrossToRef(G,b,N);const X=N.lengthSquared();0===X?N.x=1:N.normalizeFromLength(Math.sqrt(X)),F.CrossToRef(b,N,M),M.normalize();const t=-F.Dot(N,D),R=-F.Dot(M,D),n=-F.Dot(b,D);return h.FromValuesToRef(N._x,M._x,b._x,0,N._y,M._y,b._y,0,N._z,M._z,b._z,0,t,R,n,1,V),V}static LookAtRH(D,l,G){const V=new h;return h.LookAtRHToRef(D,l,G,V),V}static LookAtRHToRef(D,l,G,V){const N=x.Kl[0],M=x.Kl[1],b=x.Kl[2];D.subtractToRef(l,b),b.normalize(),F.CrossToRef(G,b,N);const X=N.lengthSquared();0===X?N.x=1:N.normalizeFromLength(Math.sqrt(X)),F.CrossToRef(b,N,M),M.normalize();const t=-F.Dot(N,D),R=-F.Dot(M,D),n=-F.Dot(b,D);return h.FromValuesToRef(N._x,M._x,b._x,0,N._y,M._y,b._y,0,N._z,M._z,b._z,0,t,R,n,1,V),V}static LookDirectionLH(D,l){const G=new h;return h.LookDirectionLHToRef(D,l,G),G}static LookDirectionLHToRef(D,l,G){const V=x.Kl[0];V.V(D),V.scaleInPlace(-1);const N=x.Kl[1];return F.CrossToRef(l,V,N),h.FromValuesToRef(N._x,N._y,N._z,0,l._x,l._y,l._z,0,V._x,V._y,V._z,0,0,0,0,1,G),G}static LookDirectionRH(D,l){const G=new h;return h.LookDirectionRHToRef(D,l,G),G}static LookDirectionRHToRef(D,l,G){const V=x.Kl[2];return F.CrossToRef(l,D,V),h.FromValuesToRef(V._x,V._y,V._z,0,l._x,l._y,l._z,0,D._x,D._y,D._z,0,0,0,0,1,G),G}static OrthoLH(D,l,G,V,N){const M=new h;return h.OrthoLHToRef(D,l,G,V,M,N),M}static OrthoLHToRef(D,l,G,V,N,M){const b=2/D,X=2/l,t=2/(V-G),R=-(V+G)/(V-G);return h.FromValuesToRef(b,0,0,0,0,X,0,0,0,0,t,0,0,0,R,1,N),M&&N.multiplyToRef(o,N),N._updateIdentityStatus(1===b&&1===X&&1===t&&0===R),N}static OrthoOffCenterLH(D,l,G,V,N,M,b){const X=new h;return h.OrthoOffCenterLHToRef(D,l,G,V,N,M,X,b),X}static OrthoOffCenterLHToRef(D,l,G,V,N,M,b,X){const t=2/(l-D),R=2/(V-G),n=2/(M-N),g=-(M+N)/(M-N),j=(D+l)/(D-l),e=(V+G)/(G-V);return h.FromValuesToRef(t,0,0,0,0,R,0,0,0,0,n,0,j,e,g,1,b),X&&b.multiplyToRef(o,b),b.markAsUpdated(),b}static ObliqueOffCenterLHToRef(D,l,G,V,N,M,b,X,t,R,n){const g=-b*Math.cos(X),j=-b*Math.sin(X);return h.TranslationToRef(0,0,-t,x.Matrix[1]),h.FromValuesToRef(1,0,0,0,0,1,0,0,g,j,1,0,0,0,0,1,x.Matrix[0]),x.Matrix[1].multiplyToRef(x.Matrix[0],x.Matrix[0]),h.TranslationToRef(0,0,t,x.Matrix[1]),x.Matrix[0].multiplyToRef(x.Matrix[1],x.Matrix[0]),h.OrthoOffCenterLHToRef(D,l,G,V,N,M,R,n),x.Matrix[0].multiplyToRef(R,R),R}static OrthoOffCenterRH(D,l,G,V,N,M,b){const X=new h;return h.OrthoOffCenterRHToRef(D,l,G,V,N,M,X,b),X}static OrthoOffCenterRHToRef(D,l,G,V,N,M,b,X){return h.OrthoOffCenterLHToRef(D,l,G,V,N,M,b,X),b.Nb[10]*=-1,b}static ObliqueOffCenterRHToRef(D,l,G,V,N,M,b,X,t,R,n){const g=b*Math.cos(X),j=b*Math.sin(X);return h.TranslationToRef(0,0,t,x.Matrix[1]),h.FromValuesToRef(1,0,0,0,0,1,0,0,g,j,1,0,0,0,0,1,x.Matrix[0]),x.Matrix[1].multiplyToRef(x.Matrix[0],x.Matrix[0]),h.TranslationToRef(0,0,-t,x.Matrix[1]),x.Matrix[0].multiplyToRef(x.Matrix[1],x.Matrix[0]),h.OrthoOffCenterRHToRef(D,l,G,V,N,M,R,n),x.Matrix[0].multiplyToRef(R,R),R}static PerspectiveLH(D,l,G,V,N){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const b=new h,X=2*G/D,t=2*G/l,R=(V+G)/(V-G),n=-2*V*G/(V-G),g=Math.tan(M);return h.FromValuesToRef(X,0,0,0,0,t,0,g,0,0,R,1,0,0,n,0,b),N&&b.multiplyToRef(o,b),b._updateIdentityStatus(!1),b}static PerspectiveFovLH(D,l,G,V,N){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,b=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const X=new h;return h.PerspectiveFovLHToRef(D,l,G,V,X,!0,N,M,b),X}static PerspectiveFovLHToRef(D,l,G,V,N){let M=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],b=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,t=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const R=G,n=V,g=1/Math.tan(.5*D),j=M?g/l:g,e=M?g:g*l,K=t&&0===R?-1:0!==n?(n+R)/(n-R):1,F=t&&0===R?2*n:0!==n?-2*n*R/(n-R):-2*R,d=Math.tan(X);return h.FromValuesToRef(j,0,0,0,0,e,0,d,0,0,K,1,0,0,F,0,N),b&&N.multiplyToRef(o,N),N._updateIdentityStatus(!1),N}static PerspectiveFovReverseLHToRef(D,l,G,V,N){let M=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],b=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const t=1/Math.tan(.5*D),R=M?t/l:t,n=M?t:t*l,g=Math.tan(X);return h.FromValuesToRef(R,0,0,0,0,n,0,g,0,0,-G,1,0,0,1,0,N),b&&N.multiplyToRef(o,N),N._updateIdentityStatus(!1),N}static PerspectiveFovRH(D,l,G,V,N){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,b=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const X=new h;return h.PerspectiveFovRHToRef(D,l,G,V,X,!0,N,M,b),X}static PerspectiveFovRHToRef(D,l,G,V,N){let M=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],b=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,t=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const R=G,n=V,g=1/Math.tan(.5*D),j=M?g/l:g,e=M?g:g*l,K=t&&0===R?1:0!==n?-(n+R)/(n-R):-1,F=t&&0===R?2*n:0!==n?-2*n*R/(n-R):-2*R,d=Math.tan(X);return h.FromValuesToRef(j,0,0,0,0,e,0,d,0,0,K,-1,0,0,F,0,N),b&&N.multiplyToRef(o,N),N._updateIdentityStatus(!1),N}static PerspectiveFovReverseRHToRef(D,l,G,V,N){let M=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],b=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const t=1/Math.tan(.5*D),R=M?t/l:t,n=M?t:t*l,g=Math.tan(X);return h.FromValuesToRef(R,0,0,0,0,n,0,g,0,0,-G,-1,0,0,-1,0,N),b&&N.multiplyToRef(o,N),N._updateIdentityStatus(!1),N}static GetFinalMatrix(D,l,G,V,N,M){const b=D.width,X=D.height,t=D.x,R=D.y,n=h.FromValues(b/2,0,0,0,0,-X/2,0,0,0,0,M-N,0,t+b/2,X/2+R,N,1),g=new h;return l.multiplyToRef(G,g),g.multiplyToRef(V,g),g.multiplyToRef(n,g)}static GetAsMatrix2x2(D){const l=D.m,G=[l[0],l[1],l[4],l[5]];return b.d.MatrixUse64Bits?G:new Float32Array(G)}static GetAsMatrix3x3(D){const l=D.m,G=[l[0],l[1],l[2],l[4],l[5],l[6],l[8],l[9],l[10]];return b.d.MatrixUse64Bits?G:new Float32Array(G)}static Transpose(D){const l=new h;return h.TransposeToRef(D,l),l}static TransposeToRef(D,l){const G=D.m,V=G[0],N=G[4],M=G[8],b=G[12],X=G[1],t=G[5],R=G[9],n=G[13],g=G[2],j=G[6],e=G[10],K=G[14],F=G[3],d=G[7],H=G[11],h=G[15],x=l.Nb;return x[0]=V,x[1]=N,x[2]=M,x[3]=b,x[4]=X,x[5]=t,x[6]=R,x[7]=n,x[8]=g,x[9]=j,x[10]=e,x[11]=K,x[12]=F,x[13]=d,x[14]=H,x[15]=h,l.markAsUpdated(),l._updateIdentityStatus(D._isIdentity,D._isIdentityDirty),l}static Reflection(D){const l=new h;return h.ReflectionToRef(D,l),l}static ReflectionToRef(D,l){D.normalize();const G=D.normal.x,V=D.normal.y,N=D.normal.z,M=-2*G,b=-2*V,X=-2*N;return h.FromValuesToRef(M*G+1,b*G,X*G,0,M*V,b*V+1,X*V,0,M*N,b*N,X*N+1,0,M*D.d,b*D.d,X*D.d,1,l),l}static FromXYZAxesToRef(D,l,G,V){return h.FromValuesToRef(D._x,D._y,D._z,0,l._x,l._y,l._z,0,G._x,G._y,G._z,0,0,0,0,1,V),V}static FromQuaternionToRef(D,l){const G=D._x*D._x,V=D._y*D._y,N=D._z*D._z,M=D._x*D._y,b=D._z*D._w,X=D._z*D._x,t=D._y*D._w,R=D._y*D._z,n=D._x*D._w;return l.Nb[0]=1-2*(V+N),l.Nb[1]=2*(M+b),l.Nb[2]=2*(X-t),l.Nb[3]=0,l.Nb[4]=2*(M-b),l.Nb[5]=1-2*(N+G),l.Nb[6]=2*(R+n),l.Nb[7]=0,l.Nb[8]=2*(X+t),l.Nb[9]=2*(R-n),l.Nb[10]=1-2*(V+G),l.Nb[11]=0,l.Nb[12]=0,l.Nb[13]=0,l.Nb[14]=0,l.Nb[15]=1,l.markAsUpdated(),l}}h._IdentityReadOnly=h.Identity(),Object.defineProperties(h.prototype,{dimension:{value:[4,4]},rank:{value:2}});class x{}x.Kl=(0,N.d)(11,F.Zero),x.Matrix=(0,N.d)(2,h.Identity),x.Quaternion=(0,N.d)(3,H.Zero);class r{}r.Vector2=(0,N.d)(3,K.Zero),r.Kl=(0,N.d)(13,F.Zero),r.Vector4=(0,N.d)(3,d.Zero),r.Quaternion=(0,N.d)(3,H.Zero),r.Matrix=(0,N.d)(8,h.Identity),(0,M.c)("BABYLON.Vector2",K),(0,M.c)("BABYLON.Vector3",F),(0,M.c)("BABYLON.Vector4",d),(0,M.c)("BABYLON.Matrix",h);const o=h.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11721:(D,l,G)=>{function V(D,l){const G=[];for(let V=0;V<D;++V)G.push(l());return G}function N(D,l){return V(D,l)}G.d(l,{b:()=>V,d:()=>N,f:()=>b});const M=["push","splice","pop","shift","unshift"];function b(D,l){const G=M.map((G=>function(D,l,G){const V=D[l];if("function"!==typeof V)return null;const N=function(){const V=D.length,M=N.previous.apply(D,arguments);return G(l,V),M};return V.next=N,N.previous=V,D[l]=N,()=>{const G=N.previous;if(!G)return;const V=N.next;V?(G.next=V,V.previous=G):(G.next=void 0,D[l]=G),N.next=void 0,N.previous=void 0}}(D,G,l)));return()=>{for(const D of G)null===D||void 0===D||D()}}}}]);