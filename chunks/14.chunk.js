"use strict";(self.u4k1rqylno=self.u4k1rqylno||[]).push([[14],{11746:(e,E,H)=>{H.d(E,{d:()=>P,g:()=>z,h:()=>N,j:()=>u});const N=1/2.2,u=2.2,z=(1+Math.sqrt(5))/2,P=.001},11756:(e,E,H)=>{function N(e){return parseInt(e.toString().replace(/\W/g,""))}function u(e,E){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(e-E)<=H}function z(e,E,H){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return e<E-N||e>H+N}function P(e,E){return e===E?e:Math.random()*(E-e)+e}function M(e,E,H){return e+(E-e)*H}function D(e,E,H){let N=h(E-e,360);return N>180&&(N-=360),e+N*V(H)}function A(e,E,H){let N=0;return N=e!=E?V((H-e)/(E-e)):0,N}function C(e,E,H,N,u){const z=u*u,P=u*z;return e*(2*P-3*z+1)+H*(-2*P+3*z)+E*(P-2*z+u)+N*(P-z)}function i(e,E,H,N,u){const z=u*u;return 6*(z-u)*e+(3*z-4*u+1)*E+6*(-z+u)*H+(3*z-2*u)*N}function V(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(H,Math.max(E,e))}function U(e){return e-=2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function j(e){const E=e.toString(16);return e<=15?("0"+E).toUpperCase():E.toUpperCase()}function F(e){if(Math.log2)return Math.floor(Math.log2(e));if(e<0)return NaN;if(0===e)return-1/0;let E=0;if(e<1){for(;e<1;)E++,e*=2;E=-E}else if(e>1)for(;e>1;)E++,e=Math.floor(e/2);return E}function h(e,E){return e-Math.floor(e/E)*E}function S(e,E,H){return(e-E)/(H-E)}function X(e,E,H){return e*(H-E)+E}function a(e,E){let H=h(E-e,360);return H>180&&(H-=360),H}function W(e,E){const H=h(e,2*E);return E-Math.abs(H-E)}function r(e,E,H){let N=V(H);return N=-2*N*N*N+3*N*N,E*N+e*(1-N)}function Y(e,E,H){let N=0;return N=Math.abs(E-e)<=H?E:e+Math.sign(E-e)*H,N}function f(e,E,H){const N=a(e,E);let u=0;return u=-H<N&&N<H?E:Y(e,E=e+N,H),u}function w(e,E,H){return(e-E)/(H-E)}function s(e,E,H){return(H-E)*e+E}function p(e,E){const H=e%E;return 0===H?E:p(E,H)}H.r(E),H.d(E,{Clamp:()=>V,DeltaAngle:()=>a,Denormalize:()=>X,ExtractAsInt:()=>N,Hermite:()=>C,Hermite1stDerivative:()=>i,HighestCommonFactor:()=>p,ILog2:()=>F,InverseLerp:()=>A,Lerp:()=>M,LerpAngle:()=>D,MoveTowards:()=>Y,MoveTowardsAngle:()=>f,Normalize:()=>S,NormalizeRadians:()=>U,OutsideRange:()=>z,PercentToRange:()=>s,PingPong:()=>W,RandomRange:()=>P,RangeToPercent:()=>w,Repeat:()=>h,SmoothStep:()=>r,ToHex:()=>j,WithinEpsilon:()=>u})},11738:(e,E,H)=>{H.r(E),H.d(E,{Matrix:()=>X,Quaternion:()=>S,TmpVectors:()=>W,Vector2:()=>j,jE:()=>F,Vector4:()=>h});var N=H(11746),u=H(11753),z=H(11690),P=H(11651),M=H(11579),D=H(11756);class A{}function C(e,E,H){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const u=e.uM(),z=E.uM(),P=u[0],M=u[1],D=u[2],A=u[3],C=u[4],i=u[5],V=u[6],U=u[7],j=u[8],F=u[9],h=u[10],S=u[11],X=u[12],a=u[13],W=u[14],r=u[15],Y=z[0],f=z[1],w=z[2],s=z[3],p=z[4],o=z[5],y=z[6],b=z[7],K=z[8],l=z[9],O=z[10],v=z[11],R=z[12],T=z[13],L=z[14],d=z[15];H[N]=P*Y+M*p+D*K+A*R,H[N+1]=P*f+M*o+D*l+A*T,H[N+2]=P*w+M*y+D*O+A*L,H[N+3]=P*s+M*b+D*v+A*d,H[N+4]=C*Y+i*p+V*K+U*R,H[N+5]=C*f+i*o+V*l+U*T,H[N+6]=C*w+i*y+V*O+U*L,H[N+7]=C*s+i*b+V*v+U*d,H[N+8]=j*Y+F*p+h*K+S*R,H[N+9]=j*f+F*o+h*l+S*T,H[N+10]=j*w+F*y+h*O+S*L,H[N+11]=j*s+F*b+h*v+S*d,H[N+12]=X*Y+a*p+W*K+r*R,H[N+13]=X*f+a*o+W*l+r*T,H[N+14]=X*w+a*y+W*O+r*L,H[N+15]=X*s+a*b+W*v+r*d}function i(e,E){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const N=e.uM();E[H]=N[0],E[H+1]=N[1],E[H+2]=N[2],E[H+3]=N[3],E[H+4]=N[4],E[H+5]=N[5],E[H+6]=N[6],E[H+7]=N[7],E[H+8]=N[8],E[H+9]=N[9],E[H+10]=N[10],E[H+11]=N[11],E[H+12]=N[12],E[H+13]=N[13],E[H+14]=N[14],E[H+15]=N[15]}function V(e,E){const H=e.uM(),N=H[0],u=H[1],z=H[2],P=H[3],M=H[4],D=H[5],A=H[6],C=H[7],i=H[8],V=H[9],U=H[10],j=H[11],F=H[12],h=H[13],S=H[14],X=H[15],a=U*X-S*j,W=V*X-h*j,r=V*S-h*U,Y=i*X-F*j,f=i*S-U*F,w=i*h-F*V,s=+(D*a-A*W+C*r),p=-(M*a-A*Y+C*f),o=+(M*W-D*Y+C*w),y=-(M*r-D*f+A*w),b=N*s+u*p+z*o+P*y;if(0===b)return!1;const K=1/b,l=A*X-S*C,O=D*X-h*C,v=D*S-h*A,R=M*X-F*C,T=M*S-F*A,L=M*h-F*D,d=A*j-U*C,G=D*j-V*C,me=D*U-V*A,Q=M*j-i*C,Z=M*U-i*A,k=M*V-i*D,J=-(u*a-z*W+P*r),B=+(N*a-z*Y+P*f),I=-(N*W-u*Y+P*w),t=+(N*r-u*f+z*w),q=+(u*l-z*O+P*v),c=-(N*l-z*R+P*T),n=+(N*O-u*R+P*L),g=-(N*v-u*T+z*L),x=-(u*d-z*G+P*me),ee=+(N*d-z*Q+P*Z),Ee=-(N*G-u*Q+P*k),He=+(N*me-u*Z+z*k);return E[0]=s*K,E[1]=J*K,E[2]=q*K,E[3]=x*K,E[4]=p*K,E[5]=B*K,E[6]=c*K,E[7]=ee*K,E[8]=o*K,E[9]=I*K,E[10]=n*K,E[11]=Ee*K,E[12]=y*K,E[13]=t*K,E[14]=g*K,E[15]=He*K,!0}A._UpdateFlagSeed=0;const U=e=>parseInt(e.toString().replace(/\W/g,""));class j{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=e,this.y=E}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let e=U(this.x);return e=397*e^U(this.y),e}toArray(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return e[E]=this.x,e[E+1]=this.y,this}VH(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return j.FromArrayToRef(e,E,this),this}uM(){return[this.x,this.y]}P(e){return this.x=e.x,this.y=e.y,this}VM(e,E){return this.x=e,this.y=E,this}set(e,E){return this.VM(e,E)}jM(e){return this.VM(e,e)}add(e){return new j(this.x+e.x,this.y+e.y)}addToRef(e,E){return E.x=this.x+e.x,E.y=this.y+e.y,E}addInPlace(e){return this.x+=e.x,this.y+=e.y,this}addInPlaceFromFloats(e,E){return this.x+=e,this.y+=E,this}addVector3(e){return new j(this.x+e.x,this.y+e.y)}FE(e){return new j(this.x-e.x,this.y-e.y)}subtractToRef(e,E){return E.x=this.x-e.x,E.y=this.y-e.y,E}JC(e){return this.x-=e.x,this.y-=e.y,this}multiplyInPlace(e){return this.x*=e.x,this.y*=e.y,this}multiply(e){return new j(this.x*e.x,this.y*e.y)}multiplyToRef(e,E){return E.x=this.x*e.x,E.y=this.y*e.y,E}multiplyByFloats(e,E){return new j(this.x*e,this.y*E)}divide(e){return new j(this.x/e.x,this.y/e.y)}divideToRef(e,E){return E.x=this.x/e.x,E.y=this.y/e.y,E}divideInPlace(e){return this.x=this.x/e.x,this.y=this.y/e.y,this}minimizeInPlace(e){return this.minimizeInPlaceFromFloats(e.x,e.y)}maximizeInPlace(e){return this.maximizeInPlaceFromFloats(e.x,e.y)}minimizeInPlaceFromFloats(e,E){return this.x=Math.min(e,this.x),this.y=Math.min(E,this.y),this}maximizeInPlaceFromFloats(e,E){return this.x=Math.max(e,this.x),this.y=Math.max(E,this.y),this}subtractFromFloats(e,E){return new j(this.x-e,this.y-E)}subtractFromFloatsToRef(e,E,H){return H.x=this.x-e,H.y=this.y-E,H}negate(){return new j(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(e){return e.x=-this.x,e.y=-this.y,e}scaleInPlace(e){return this.x*=e,this.y*=e,this}scale(e){return new j(this.x*e,this.y*e)}scaleToRef(e,E){return E.x=this.x*e,E.y=this.y*e,E}scaleAndAddToRef(e,E){return E.x+=this.x*e,E.y+=this.y*e,E}equals(e){return e&&this.x===e.x&&this.y===e.y}equalsWithEpsilon(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.d;return e&&(0,D.WithinEpsilon)(this.x,e.x,E)&&(0,D.WithinEpsilon)(this.y,e.y,E)}equalsToFloats(e,E){return this.x===e&&this.y===E}floor(){return new j(Math.floor(this.x),Math.floor(this.y))}floorToRef(e){return e.x=Math.floor(this.x),e.y=Math.floor(this.y),e}fract(){return new j(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(e){return e.x=this.x-Math.floor(this.x),e.y=this.y-Math.floor(this.y),e}rotate(e){return this.rotateToRef(e,new j)}rotateToRef(e,E){const H=Math.cos(e),N=Math.sin(e);return E.x=H*this.x-N*this.y,E.y=N*this.x+H*this.y,E}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(e){return 0===e||1===e?this:this.scaleInPlace(1/e)}normalizeToNew(){const e=new j;return this.normalizeToRef(e),e}normalizeToRef(e){const E=this.length();return 0===E&&(e.x=this.x,e.y=this.y),this.scaleToRef(1/E,e)}clone(){return new j(this.x,this.y)}dot(e){return this.x*e.x+this.y*e.y}static Zero(){return new j(0,0)}static One(){return new j(1,1)}static Random(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new j((0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E))}static RandomToRef(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).VM((0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E))}static get ZeroReadOnly(){return j._ZeroReadOnly}static aE(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new j(e[E],e[E+1])}static FromArrayToRef(e,E,H){return H.x=e[E],H.y=e[E+1],H}static FromFloatsToRef(e,E,H){return H.VM(e,E),H}static CatmullRom(e,E,H,N,u){const z=u*u,P=u*z,M=.5*(2*E.x+(-e.x+H.x)*u+(2*e.x-5*E.x+4*H.x-N.x)*z+(-e.x+3*E.x-3*H.x+N.x)*P),D=.5*(2*E.y+(-e.y+H.y)*u+(2*e.y-5*E.y+4*H.y-N.y)*z+(-e.y+3*E.y-3*H.y+N.y)*P);return new j(M,D)}static ClampToRef(e,E,H,N){return N.x=(0,D.Clamp)(e.x,E.x,H.x),N.y=(0,D.Clamp)(e.y,E.y,H.y),N}static Clamp(e,E,H){const N=(0,D.Clamp)(e.x,E.x,H.x),u=(0,D.Clamp)(e.y,E.y,H.y);return new j(N,u)}static Hermite(e,E,H,N,u){const z=u*u,P=u*z,M=2*P-3*z+1,D=-2*P+3*z,A=P-2*z+u,C=P-z,i=e.x*M+H.x*D+E.x*A+N.x*C,V=e.y*M+H.y*D+E.y*A+N.y*C;return new j(i,V)}static Hermite1stDerivative(e,E,H,N,u){return this.Hermite1stDerivativeToRef(e,E,H,N,u,new j)}static Hermite1stDerivativeToRef(e,E,H,N,u,z){const P=u*u;return z.x=6*(P-u)*e.x+(3*P-4*u+1)*E.x+6*(-P+u)*H.x+(3*P-2*u)*N.x,z.y=6*(P-u)*e.y+(3*P-4*u+1)*E.y+6*(-P+u)*H.y+(3*P-2*u)*N.y,z}static Lerp(e,E,H){return j.LerpToRef(e,E,H,new j)}static LerpToRef(e,E,H,N){return N.x=e.x+(E.x-e.x)*H,N.y=e.y+(E.y-e.y)*H,N}static Dot(e,E){return e.x*E.x+e.y*E.y}static Normalize(e){return j.NormalizeToRef(e,new j)}static NormalizeToRef(e,E){return e.normalizeToRef(E),E}static Minimize(e,E){const H=e.x<E.x?e.x:E.x,N=e.y<E.y?e.y:E.y;return new j(H,N)}static Maximize(e,E){const H=e.x>E.x?e.x:E.x,N=e.y>E.y?e.y:E.y;return new j(H,N)}static Transform(e,E){return j.TransformToRef(e,E,new j)}static TransformToRef(e,E,H){const N=E.m,u=e.x*N[0]+e.y*N[4]+N[12],z=e.x*N[1]+e.y*N[5]+N[13];return H.x=u,H.y=z,H}static PointInTriangle(e,E,H,N){const u=.5*(-H.y*N.x+E.y*(-H.x+N.x)+E.x*(H.y-N.y)+H.x*N.y),z=u<0?-1:1,P=(E.y*N.x-E.x*N.y+(N.y-E.y)*e.x+(E.x-N.x)*e.y)*z,M=(E.x*H.y-E.y*H.x+(E.y-H.y)*e.x+(H.x-E.x)*e.y)*z;return P>0&&M>0&&P+M<2*u*z}static Distance(e,E){return Math.sqrt(j.DistanceSquared(e,E))}static DistanceSquared(e,E){const H=e.x-E.x,N=e.y-E.y;return H*H+N*N}static Center(e,E){return j.CenterToRef(e,E,new j)}static CenterToRef(e,E,H){return H.VM((e.x+E.x)/2,(e.y+E.y)/2)}static DistanceOfPointFromSegment(e,E,H){const N=j.DistanceSquared(E,H);if(0===N)return j.Distance(e,E);const u=H.FE(E),z=Math.max(0,Math.min(1,j.Dot(e.FE(E),u)/N)),P=E.add(u.multiplyByFloats(z,z));return j.Distance(e,P)}}j._V8PerformanceHack=new j(.5,.5),j._ZeroReadOnly=j.Zero(),Object.defineProperties(j.prototype,{dimension:{value:[2]},rank:{value:1}});class F{get x(){return this._x}set x(e){this._x=e,this._isDirty=!0}get y(){return this._y}set y(e){this._y=e,this._isDirty=!0}get z(){return this._z}set z(e){this._z=e,this._isDirty=!0}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=e,this._y=E,this._z=H}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"jE"}getHashCode(){let e=U(this._x);return e=397*e^U(this._y),e=397*e^U(this._z),e}uM(){return[this._x,this._y,this._z]}toArray(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return e[E]=this._x,e[E+1]=this._y,e[E+2]=this._z,this}VH(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F.FromArrayToRef(e,E,this),this}toQuaternion(){return S.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(e){return this._x+=e._x,this._y+=e._y,this._z+=e._z,this._isDirty=!0,this}addInPlaceFromFloats(e,E,H){return this._x+=e,this._y+=E,this._z+=H,this._isDirty=!0,this}add(e){return new F(this._x+e._x,this._y+e._y,this._z+e._z)}addToRef(e,E){return E._x=this._x+e._x,E._y=this._y+e._y,E._z=this._z+e._z,E._isDirty=!0,E}JC(e){return this._x-=e._x,this._y-=e._y,this._z-=e._z,this._isDirty=!0,this}FE(e){return new F(this._x-e._x,this._y-e._y,this._z-e._z)}subtractToRef(e,E){return this.subtractFromFloatsToRef(e._x,e._y,e._z,E)}subtractFromFloats(e,E,H){return new F(this._x-e,this._y-E,this._z-H)}subtractFromFloatsToRef(e,E,H,N){return N._x=this._x-e,N._y=this._y-E,N._z=this._z-H,N._isDirty=!0,N}negate(){return new F(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(e){return e._x=-1*this._x,e._y=-1*this._y,e._z=-1*this._z,e._isDirty=!0,e}scaleInPlace(e){return this._x*=e,this._y*=e,this._z*=e,this._isDirty=!0,this}scale(e){return new F(this._x*e,this._y*e,this._z*e)}scaleToRef(e,E){return E._x=this._x*e,E._y=this._y*e,E._z=this._z*e,E._isDirty=!0,E}getNormalToRef(e){const E=this.length();let H=Math.acos(this._y/E);const N=Math.atan2(this._z,this._x);H>Math.PI/2?H-=Math.PI/2:H+=Math.PI/2;const u=E*Math.sin(H)*Math.cos(N),z=E*Math.cos(H),P=E*Math.sin(H)*Math.sin(N);return e.set(u,z,P),e}applyRotationQuaternionToRef(e,E){const H=this._x,N=this._y,u=this._z,z=e._x,P=e._y,M=e._z,D=e._w,A=2*(P*u-M*N),C=2*(M*H-z*u),i=2*(z*N-P*H);return E._x=H+D*A+P*i-M*C,E._y=N+D*C+M*A-z*i,E._z=u+D*i+z*C-P*A,E._isDirty=!0,E}applyRotationQuaternionInPlace(e){return this.applyRotationQuaternionToRef(e,this)}applyRotationQuaternion(e){return this.applyRotationQuaternionToRef(e,new F)}scaleAndAddToRef(e,E){return E._x+=this._x*e,E._y+=this._y*e,E._z+=this._z*e,E._isDirty=!0,E}projectOnPlane(e,E){return this.projectOnPlaneToRef(e,E,new F)}projectOnPlaneToRef(e,E,H){const N=e.normal,u=e.d,z=a.jE[0];this.subtractToRef(E,z),z.normalize();const P=F.Dot(z,N);if(Math.abs(P)<1e-10)H.jM(1/0);else{const e=-(F.Dot(E,N)+u)/P,M=z.scaleInPlace(e);E.addToRef(M,H)}return H}equals(e){return e&&this._x===e._x&&this._y===e._y&&this._z===e._z}equalsWithEpsilon(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.d;return e&&(0,D.WithinEpsilon)(this._x,e._x,E)&&(0,D.WithinEpsilon)(this._y,e._y,E)&&(0,D.WithinEpsilon)(this._z,e._z,E)}equalsToFloats(e,E,H){return this._x===e&&this._y===E&&this._z===H}multiplyInPlace(e){return this._x*=e._x,this._y*=e._y,this._z*=e._z,this._isDirty=!0,this}multiply(e){return this.multiplyByFloats(e._x,e._y,e._z)}multiplyToRef(e,E){return E._x=this._x*e._x,E._y=this._y*e._y,E._z=this._z*e._z,E._isDirty=!0,E}multiplyByFloats(e,E,H){return new F(this._x*e,this._y*E,this._z*H)}divide(e){return new F(this._x/e._x,this._y/e._y,this._z/e._z)}divideToRef(e,E){return E._x=this._x/e._x,E._y=this._y/e._y,E._z=this._z/e._z,E._isDirty=!0,E}divideInPlace(e){return this._x=this._x/e._x,this._y=this._y/e._y,this._z=this._z/e._z,this._isDirty=!0,this}minimizeInPlace(e){return this.minimizeInPlaceFromFloats(e._x,e._y,e._z)}maximizeInPlace(e){return this.maximizeInPlaceFromFloats(e._x,e._y,e._z)}minimizeInPlaceFromFloats(e,E,H){return e<this._x&&(this.x=e),E<this._y&&(this.y=E),H<this._z&&(this.z=H),this}maximizeInPlaceFromFloats(e,E,H){return e>this._x&&(this.x=e),E>this._y&&(this.y=E),H>this._z&&(this.z=H),this}isNonUniformWithinEpsilon(e){const E=Math.abs(this._x),H=Math.abs(this._y);if(!(0,D.WithinEpsilon)(E,H,e))return!0;const N=Math.abs(this._z);return!(0,D.WithinEpsilon)(E,N,e)||!(0,D.WithinEpsilon)(H,N,e)}get isNonUniform(){const e=Math.abs(this._x);if(e!==Math.abs(this._y))return!0;return e!==Math.abs(this._z)}floorToRef(e){return e._x=Math.floor(this._x),e._y=Math.floor(this._y),e._z=Math.floor(this._z),e._isDirty=!0,e}floor(){return new F(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(e){return e._x=this._x-Math.floor(this._x),e._y=this._y-Math.floor(this._y),e._z=this._z-Math.floor(this._z),e._isDirty=!0,e}fract(){return new F(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(e){if("xyz"===(e=e.toLowerCase()))return this;const E=a.jE[0].P(this);return this.x=E[e[0]],this.y=E[e[1]],this.z=E[e[2]],this}rotateByQuaternionToRef(e,E){return e.toRotationMatrix(a.Matrix[0]),F.TransformCoordinatesToRef(this,a.Matrix[0],E),E}rotateByQuaternionAroundPointToRef(e,E,H){return this.subtractToRef(E,a.jE[0]),a.jE[0].rotateByQuaternionToRef(e,a.jE[0]),E.addToRef(a.jE[0],H),H}cross(e){return F.CrossToRef(this,e,new F)}normalizeFromLength(e){return 0===e||1===e?this:this.scaleInPlace(1/e)}normalizeToNew(){return this.normalizeToRef(new F)}normalizeToRef(e){const E=this.length();return 0===E||1===E?(e._x=this._x,e._y=this._y,e._z=this._z,e._isDirty=!0,e):this.scaleToRef(1/E,e)}clone(){return new F(this._x,this._y,this._z)}P(e){return this.VM(e._x,e._y,e._z)}VM(e,E,H){return this._x=e,this._y=E,this._z=H,this._isDirty=!0,this}set(e,E,H){return this.VM(e,E,H)}jM(e){return this._x=this._y=this._z=e,this._isDirty=!0,this}static GetClipFactor(e,E,H,N){const u=F.Dot(e,H);return(u-N)/(u-F.Dot(E,H))}static GetAngleBetweenVectors(e,E,H){const N=e.normalizeToRef(a.jE[1]),u=E.normalizeToRef(a.jE[2]);let z=F.Dot(N,u);z=(0,D.Clamp)(z,-1,1);const P=Math.acos(z),M=a.jE[3];return F.CrossToRef(N,u,M),F.Dot(M,H)>0?isNaN(P)?0:P:isNaN(P)?-Math.PI:-Math.acos(z)}static GetAngleBetweenVectorsOnPlane(e,E,H){a.jE[0].P(e);const N=a.jE[0];a.jE[1].P(E);const u=a.jE[1];a.jE[2].P(H);const z=a.jE[2],P=a.jE[3],M=a.jE[4];N.normalize(),u.normalize(),z.normalize(),F.CrossToRef(z,N,P),F.CrossToRef(P,z,M);const A=Math.atan2(F.Dot(u,P),F.Dot(u,M));return(0,D.NormalizeRadians)(A)}static PitchYawRollToMoveBetweenPointsToRef(e,E,H){const N=W.jE[0];return E.subtractToRef(e,N),H._y=Math.atan2(N.x,N.z)||0,H._x=Math.atan2(Math.sqrt(N.x**2+N.z**2),N.y)||0,H._z=0,H._isDirty=!0,H}static PitchYawRollToMoveBetweenPoints(e,E){const H=F.Zero();return F.PitchYawRollToMoveBetweenPointsToRef(e,E,H)}static SlerpToRef(e,E,H,u){H=(0,D.Clamp)(H,0,1);const z=a.jE[0],P=a.jE[1];z.P(e);const M=z.length();z.normalizeFromLength(M),P.P(E);const A=P.length();P.normalizeFromLength(A);const C=F.Dot(z,P);let i,V;if(C<1-N.d){const e=Math.acos(C),E=1/Math.sin(e);i=Math.sin((1-H)*e)*E,V=Math.sin(H*e)*E}else i=1-H,V=H;return z.scaleInPlace(i),P.scaleInPlace(V),u.P(z).addInPlace(P),u.scaleInPlace((0,D.Lerp)(M,A,H)),u}static SmoothToRef(e,E,H,N,u){return F.SlerpToRef(e,E,0===N?1:H/N,u),u}static aE(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(e[E],e[E+1],e[E+2])}static FromFloatArray(e,E){return F.aE(e,E)}static FromArrayToRef(e,E,H){return H._x=e[E],H._y=e[E+1],H._z=e[E+2],H._isDirty=!0,H}static FromFloatArrayToRef(e,E,H){return F.FromArrayToRef(e,E,H)}static FromFloatsToRef(e,E,H,N){return N.VM(e,E,H),N}static Zero(){return new F(0,0,0)}static One(){return new F(1,1,1)}static Up(){return new F(0,1,0)}static get UpReadOnly(){return F._UpReadOnly}static get DownReadOnly(){return F._DownReadOnly}static get RightReadOnly(){return F._RightReadOnly}static get LeftReadOnly(){return F._LeftReadOnly}static get LeftHandedForwardReadOnly(){return F._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return F._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return F._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return F._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return F._ZeroReadOnly}static get OneReadOnly(){return F._OneReadOnly}static Down(){return new F(0,-1,0)}static Forward(){return new F(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new F(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new F(1,0,0)}static Left(){return new F(-1,0,0)}static Random(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new F((0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E))}static RandomToRef(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).VM((0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E))}static TransformCoordinates(e,E){const H=F.Zero();return F.TransformCoordinatesToRef(e,E,H),H}static TransformCoordinatesToRef(e,E,H){return F.TransformCoordinatesFromFloatsToRef(e._x,e._y,e._z,E,H),H}static TransformCoordinatesFromFloatsToRef(e,E,H,N,u){const z=N.m,P=e*z[0]+E*z[4]+H*z[8]+z[12],M=e*z[1]+E*z[5]+H*z[9]+z[13],D=e*z[2]+E*z[6]+H*z[10]+z[14],A=1/(e*z[3]+E*z[7]+H*z[11]+z[15]);return u._x=P*A,u._y=M*A,u._z=D*A,u._isDirty=!0,u}static TransformNormal(e,E){const H=F.Zero();return F.TransformNormalToRef(e,E,H),H}static TransformNormalToRef(e,E,H){return this.TransformNormalFromFloatsToRef(e._x,e._y,e._z,E,H),H}static TransformNormalFromFloatsToRef(e,E,H,N,u){const z=N.m;return u._x=e*z[0]+E*z[4]+H*z[8],u._y=e*z[1]+E*z[5]+H*z[9],u._z=e*z[2]+E*z[6]+H*z[10],u._isDirty=!0,u}static CatmullRom(e,E,H,N,u){const z=u*u,P=u*z,M=.5*(2*E._x+(-e._x+H._x)*u+(2*e._x-5*E._x+4*H._x-N._x)*z+(-e._x+3*E._x-3*H._x+N._x)*P),D=.5*(2*E._y+(-e._y+H._y)*u+(2*e._y-5*E._y+4*H._y-N._y)*z+(-e._y+3*E._y-3*H._y+N._y)*P),A=.5*(2*E._z+(-e._z+H._z)*u+(2*e._z-5*E._z+4*H._z-N._z)*z+(-e._z+3*E._z-3*H._z+N._z)*P);return new F(M,D,A)}static Clamp(e,E,H){const N=new F;return F.ClampToRef(e,E,H,N),N}static ClampToRef(e,E,H,N){let u=e._x;u=u>H._x?H._x:u,u=u<E._x?E._x:u;let z=e._y;z=z>H._y?H._y:z,z=z<E._y?E._y:z;let P=e._z;return P=P>H._z?H._z:P,P=P<E._z?E._z:P,N.VM(u,z,P),N}static CheckExtends(e,E,H){E.minimizeInPlace(e),H.maximizeInPlace(e)}static Hermite(e,E,H,N,u){const z=u*u,P=u*z,M=2*P-3*z+1,D=-2*P+3*z,A=P-2*z+u,C=P-z,i=e._x*M+H._x*D+E._x*A+N._x*C,V=e._y*M+H._y*D+E._y*A+N._y*C,U=e._z*M+H._z*D+E._z*A+N._z*C;return new F(i,V,U)}static Hermite1stDerivative(e,E,H,N,u){const z=new F;return this.Hermite1stDerivativeToRef(e,E,H,N,u,z),z}static Hermite1stDerivativeToRef(e,E,H,N,u,z){const P=u*u;return z._x=6*(P-u)*e._x+(3*P-4*u+1)*E._x+6*(-P+u)*H._x+(3*P-2*u)*N._x,z._y=6*(P-u)*e._y+(3*P-4*u+1)*E._y+6*(-P+u)*H._y+(3*P-2*u)*N._y,z._z=6*(P-u)*e._z+(3*P-4*u+1)*E._z+6*(-P+u)*H._z+(3*P-2*u)*N._z,z._isDirty=!0,z}static Lerp(e,E,H){const N=new F(0,0,0);return F.LerpToRef(e,E,H,N),N}static LerpToRef(e,E,H,N){return N._x=e._x+(E._x-e._x)*H,N._y=e._y+(E._y-e._y)*H,N._z=e._z+(E._z-e._z)*H,N._isDirty=!0,N}static Dot(e,E){return e._x*E._x+e._y*E._y+e._z*E._z}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z}static Cross(e,E){const H=new F;return F.CrossToRef(e,E,H),H}static CrossToRef(e,E,H){const N=e._y*E._z-e._z*E._y,u=e._z*E._x-e._x*E._z,z=e._x*E._y-e._y*E._x;return H.VM(N,u,z),H}static Normalize(e){const E=F.Zero();return F.NormalizeToRef(e,E),E}static NormalizeToRef(e,E){return e.normalizeToRef(E),E}static Project(e,E,H,N){const u=new F;return F.ProjectToRef(e,E,H,N,u),u}static ProjectToRef(e,E,H,N,u){var z;const P=N.width,D=N.height,A=N.x,C=N.y,i=a.Matrix[1],V=null===(z=M.d.LastCreatedEngine)||void 0===z?void 0:z.isNDCHalfZRange,U=V?1:.5,j=V?0:.5;X.FromValuesToRef(P/2,0,0,0,0,-D/2,0,0,0,0,U,0,A+P/2,D/2+C,j,1,i);const h=a.Matrix[0];return E.multiplyToRef(H,h),h.multiplyToRef(i,h),F.TransformCoordinatesToRef(e,h,u),u}static Reflect(e,E){return this.ReflectToRef(e,E,new F)}static ReflectToRef(e,E,H){const N=W.jE[0];return N.P(E).scaleInPlace(2*F.Dot(e,E)),H.P(e).JC(N)}static _UnprojectFromInvertedMatrixToRef(e,E,H){F.TransformCoordinatesToRef(e,E,H);const N=E.m,u=e._x*N[3]+e._y*N[7]+e._z*N[11]+N[15];return(0,D.WithinEpsilon)(u,1)&&H.scaleInPlace(1/u),H}static UnprojectFromTransform(e,E,H,N,u){return this.Unproject(e,E,H,N,u,X.IdentityReadOnly)}static Unproject(e,E,H,N,u,z){const P=new F;return F.UnprojectToRef(e,E,H,N,u,z,P),P}static UnprojectToRef(e,E,H,N,u,z,P){return F.UnprojectFloatsToRef(e._x,e._y,e._z,E,H,N,u,z,P),P}static UnprojectFloatsToRef(e,E,H,N,u,z,P,D,A){var C;const i=a.Matrix[0];z.multiplyToRef(P,i),i.multiplyToRef(D,i),i.invert();const V=a.jE[0];return V.x=e/N*2-1,V.y=-(E/u*2-1),null!==(C=M.d.LastCreatedEngine)&&void 0!==C&&C.isNDCHalfZRange?V.z=H:V.z=2*H-1,F._UnprojectFromInvertedMatrixToRef(V,i,A),A}static Minimize(e,E){const H=new F;return H.P(e),H.minimizeInPlace(E),H}static Maximize(e,E){const H=new F;return H.P(e),H.maximizeInPlace(E),H}static Distance(e,E){return Math.sqrt(F.DistanceSquared(e,E))}static DistanceSquared(e,E){const H=e._x-E._x,N=e._y-E._y,u=e._z-E._z;return H*H+N*N+u*u}static ProjectOnTriangleToRef(e,E,H,u,z){const P=a.jE[0],M=a.jE[1],A=a.jE[2],C=a.jE[3],i=a.jE[4];H.subtractToRef(E,P),u.subtractToRef(E,M),u.subtractToRef(H,A);const V=P.length(),U=M.length(),j=A.length();if(V<N.d||U<N.d||j<N.d)return z.P(E),F.Distance(e,E);e.subtractToRef(E,i),F.CrossToRef(P,M,C);const h=C.length();if(h<N.d)return z.P(E),F.Distance(e,E);C.normalizeFromLength(h);let S=i.length();if(S<N.d)return z.P(E),0;i.normalizeFromLength(S);const X=F.Dot(C,i),W=a.jE[5],r=a.jE[6];W.P(C).scaleInPlace(-S*X),r.P(e).addInPlace(W);const Y=a.jE[4],f=a.jE[5],w=a.jE[7],s=a.jE[8];Y.P(P).scaleInPlace(1/V),s.P(M).scaleInPlace(1/U),Y.addInPlace(s).scaleInPlace(-1),f.P(P).scaleInPlace(-1/V),s.P(A).scaleInPlace(1/j),f.addInPlace(s).scaleInPlace(-1),w.P(A).scaleInPlace(-1/j),s.P(M).scaleInPlace(-1/U),w.addInPlace(s).scaleInPlace(-1);const p=a.jE[9];let o;p.P(r).JC(E),F.CrossToRef(Y,p,s),o=F.Dot(s,C);const y=o;p.P(r).JC(H),F.CrossToRef(f,p,s),o=F.Dot(s,C);const b=o;p.P(r).JC(u),F.CrossToRef(w,p,s),o=F.Dot(s,C);const K=o,l=a.jE[10];let O,v;y>0&&b<0?(l.P(P),O=E,v=H):b>0&&K<0?(l.P(A),O=H,v=u):(l.P(M).scaleInPlace(-1),O=u,v=E);const R=a.jE[9],T=a.jE[4];O.subtractToRef(r,s),v.subtractToRef(r,R),F.CrossToRef(s,R,T);if(!(F.Dot(T,C)<0))return z.P(r),Math.abs(S*X);const L=a.jE[5];F.CrossToRef(l,T,L),L.normalize();const d=a.jE[9];d.P(O).JC(r);const G=d.length();if(G<N.d)return z.P(O),F.Distance(e,O);d.normalizeFromLength(G);const me=F.Dot(L,d),Q=a.jE[7];Q.P(r).addInPlace(L.scaleInPlace(G*me)),s.P(Q).JC(O),S=l.length(),l.normalizeFromLength(S);let Z=F.Dot(s,l)/Math.max(S,N.d);return Z=(0,D.Clamp)(Z,0,1),Q.P(O).addInPlace(l.scaleInPlace(Z*S)),z.P(Q),F.Distance(e,Q)}static Center(e,E){return F.CenterToRef(e,E,F.Zero())}static CenterToRef(e,E,H){return H.VM((e._x+E._x)/2,(e._y+E._y)/2,(e._z+E._z)/2)}static RotationFromAxis(e,E,H){const N=new F;return F.RotationFromAxisToRef(e,E,H,N),N}static RotationFromAxisToRef(e,E,H,N){const u=a.Quaternion[0];return S.RotationQuaternionFromAxisToRef(e,E,H,u),u.toEulerAnglesToRef(N),N}}F._V8PerformanceHack=new F(.5,.5,.5),F._UpReadOnly=F.Up(),F._DownReadOnly=F.Down(),F._LeftHandedForwardReadOnly=F.Forward(!1),F._RightHandedForwardReadOnly=F.Forward(!0),F._LeftHandedBackwardReadOnly=F.Backward(!1),F._RightHandedBackwardReadOnly=F.Backward(!0),F._RightReadOnly=F.Right(),F._LeftReadOnly=F.Left(),F._ZeroReadOnly=F.Zero(),F._OneReadOnly=F.One(),Object.defineProperties(F.prototype,{dimension:{value:[3]},rank:{value:1}});class h{get x(){return this._x}set x(e){this._x=e,this._isDirty=!0}get y(){return this._y}set y(e){this._y=e,this._isDirty=!0}get z(){return this._z}set z(e){this._z=e,this._isDirty=!0}get w(){return this._w}set w(e){this._w=e,this._isDirty=!0}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=e,this._y=E,this._z=H,this._w=N}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let e=U(this._x);return e=397*e^U(this._y),e=397*e^U(this._z),e=397*e^U(this._w),e}uM(){return[this._x,this._y,this._z,this._w]}toArray(e,E){return void 0===E&&(E=0),e[E]=this._x,e[E+1]=this._y,e[E+2]=this._z,e[E+3]=this._w,this}VH(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h.FromArrayToRef(e,E,this),this}addInPlace(e){return this.x+=e._x,this.y+=e._y,this.z+=e._z,this.w+=e._w,this}addInPlaceFromFloats(e,E,H,N){return this.x+=e,this.y+=E,this.z+=H,this.w+=N,this}add(e){return new h(this._x+e.x,this._y+e.y,this._z+e.z,this._w+e.w)}addToRef(e,E){return E.x=this._x+e.x,E.y=this._y+e.y,E.z=this._z+e.z,E.w=this._w+e.w,E}JC(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}FE(e){return new h(this._x-e.x,this._y-e.y,this._z-e.z,this._w-e.w)}subtractToRef(e,E){return E.x=this._x-e.x,E.y=this._y-e.y,E.z=this._z-e.z,E.w=this._w-e.w,E}subtractFromFloats(e,E,H,N){return new h(this._x-e,this._y-E,this._z-H,this._w-N)}subtractFromFloatsToRef(e,E,H,N,u){return u.x=this._x-e,u.y=this._y-E,u.z=this._z-H,u.w=this._w-N,u}negate(){return new h(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(e){return e.x=-this._x,e.y=-this._y,e.z=-this._z,e.w=-this._w,e}scaleInPlace(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}scale(e){return new h(this._x*e,this._y*e,this._z*e,this._w*e)}scaleToRef(e,E){return E.x=this._x*e,E.y=this._y*e,E.z=this._z*e,E.w=this._w*e,E}scaleAndAddToRef(e,E){return E.x+=this._x*e,E.y+=this._y*e,E.z+=this._z*e,E.w+=this._w*e,E}equals(e){return e&&this._x===e.x&&this._y===e.y&&this._z===e.z&&this._w===e.w}equalsWithEpsilon(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.d;return e&&(0,D.WithinEpsilon)(this._x,e.x,E)&&(0,D.WithinEpsilon)(this._y,e.y,E)&&(0,D.WithinEpsilon)(this._z,e.z,E)&&(0,D.WithinEpsilon)(this._w,e.w,E)}equalsToFloats(e,E,H,N){return this._x===e&&this._y===E&&this._z===H&&this._w===N}multiplyInPlace(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiply(e){return new h(this._x*e.x,this._y*e.y,this._z*e.z,this._w*e.w)}multiplyToRef(e,E){return E.x=this._x*e.x,E.y=this._y*e.y,E.z=this._z*e.z,E.w=this._w*e.w,E}multiplyByFloats(e,E,H,N){return new h(this._x*e,this._y*E,this._z*H,this._w*N)}divide(e){return new h(this._x/e.x,this._y/e.y,this._z/e.z,this._w/e.w)}divideToRef(e,E){return E.x=this._x/e.x,E.y=this._y/e.y,E.z=this._z/e.z,E.w=this._w/e.w,E}divideInPlace(e){return this.divideToRef(e,this)}minimizeInPlace(e){return e.x<this._x&&(this.x=e.x),e.y<this._y&&(this.y=e.y),e.z<this._z&&(this.z=e.z),e.w<this._w&&(this.w=e.w),this}maximizeInPlace(e){return e.x>this._x&&(this.x=e.x),e.y>this._y&&(this.y=e.y),e.z>this._z&&(this.z=e.z),e.w>this._w&&(this.w=e.w),this}minimizeInPlaceFromFloats(e,E,H,N){return this.x=Math.min(e,this._x),this.y=Math.min(E,this._y),this.z=Math.min(H,this._z),this.w=Math.min(N,this._w),this}maximizeInPlaceFromFloats(e,E,H,N){return this.x=Math.max(e,this._x),this.y=Math.max(E,this._y),this.z=Math.max(H,this._z),this.w=Math.max(N,this._w),this}floorToRef(e){return e.x=Math.floor(this._x),e.y=Math.floor(this._y),e.z=Math.floor(this._z),e.w=Math.floor(this._w),e}floor(){return new h(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(e){return e.x=this._x-Math.floor(this._x),e.y=this._y-Math.floor(this._y),e.z=this._z-Math.floor(this._z),e.w=this._w-Math.floor(this._w),e}fract(){return new h(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(e){return 0===e||1===e?this:this.scaleInPlace(1/e)}normalizeToNew(){return this.normalizeToRef(new h)}normalizeToRef(e){const E=this.length();return 0===E||1===E?(e.x=this._x,e.y=this._y,e.z=this._z,e.w=this._w,e):this.scaleToRef(1/E,e)}toVector3(){return new F(this._x,this._y,this._z)}clone(){return new h(this._x,this._y,this._z,this._w)}P(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}VM(e,E,H,N){return this.x=e,this.y=E,this.z=H,this.w=N,this}set(e,E,H,N){return this.VM(e,E,H,N)}jM(e){return this.x=this.y=this.z=this.w=e,this}dot(e){return this._x*e.x+this._y*e.y+this._z*e.z+this._w*e.w}static aE(e,E){return E||(E=0),new h(e[E],e[E+1],e[E+2],e[E+3])}static FromArrayToRef(e,E,H){return H.x=e[E],H.y=e[E+1],H.z=e[E+2],H.w=e[E+3],H}static FromFloatArrayToRef(e,E,H){return h.FromArrayToRef(e,E,H),H}static FromFloatsToRef(e,E,H,N,u){return u.x=e,u.y=E,u.z=H,u.w=N,u}static Zero(){return new h(0,0,0,0)}static One(){return new h(1,1,1,1)}static Random(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new h((0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E))}static RandomToRef(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0;return H.x=(0,D.RandomRange)(e,E),H.y=(0,D.RandomRange)(e,E),H.z=(0,D.RandomRange)(e,E),H.w=(0,D.RandomRange)(e,E),H}static Clamp(e,E,H){return h.ClampToRef(e,E,H,new h)}static ClampToRef(e,E,H,N){return N.x=(0,D.Clamp)(e.x,E.x,H.x),N.y=(0,D.Clamp)(e.y,E.y,H.y),N.z=(0,D.Clamp)(e.z,E.z,H.z),N.w=(0,D.Clamp)(e.w,E.w,H.w),N}static CheckExtends(e,E,H){E.minimizeInPlace(e),H.maximizeInPlace(e)}static get ZeroReadOnly(){return h._ZeroReadOnly}static Normalize(e){return h.NormalizeToRef(e,new h)}static NormalizeToRef(e,E){return e.normalizeToRef(E),E}static Minimize(e,E){const H=new h;return H.P(e),H.minimizeInPlace(E),H}static Maximize(e,E){const H=new h;return H.P(e),H.maximizeInPlace(E),H}static Distance(e,E){return Math.sqrt(h.DistanceSquared(e,E))}static DistanceSquared(e,E){const H=e.x-E.x,N=e.y-E.y,u=e.z-E.z,z=e.w-E.w;return H*H+N*N+u*u+z*z}static Center(e,E){return h.CenterToRef(e,E,new h)}static CenterToRef(e,E,H){return H.x=(e.x+E.x)/2,H.y=(e.y+E.y)/2,H.z=(e.z+E.z)/2,H.w=(e.w+E.w)/2,H}static TransformCoordinates(e,E){return h.TransformCoordinatesToRef(e,E,new h)}static TransformCoordinatesToRef(e,E,H){return h.TransformCoordinatesFromFloatsToRef(e._x,e._y,e._z,E,H),H}static TransformCoordinatesFromFloatsToRef(e,E,H,N,u){const z=N.m,P=e*z[0]+E*z[4]+H*z[8]+z[12],M=e*z[1]+E*z[5]+H*z[9]+z[13],D=e*z[2]+E*z[6]+H*z[10]+z[14],A=e*z[3]+E*z[7]+H*z[11]+z[15];return u.x=P,u.y=M,u.z=D,u.w=A,u}static TransformNormal(e,E){return h.TransformNormalToRef(e,E,new h)}static TransformNormalToRef(e,E,H){const N=E.m,u=e.x*N[0]+e.y*N[4]+e.z*N[8],z=e.x*N[1]+e.y*N[5]+e.z*N[9],P=e.x*N[2]+e.y*N[6]+e.z*N[10];return H.x=u,H.y=z,H.z=P,H.w=e.w,H}static TransformNormalFromFloatsToRef(e,E,H,N,u,z){const P=u.m;return z.x=e*P[0]+E*P[4]+H*P[8],z.y=e*P[1]+E*P[5]+H*P[9],z.z=e*P[2]+E*P[6]+H*P[10],z.w=N,z}static FromVector3(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new h(e._x,e._y,e._z,E)}static Dot(e,E){return e.x*E.x+e.y*E.y+e.z*E.z+e.w*E.w}}h._V8PerformanceHack=new h(.5,.5,.5,.5),h._ZeroReadOnly=h.Zero(),Object.defineProperties(h.prototype,{dimension:{value:[4]},rank:{value:1}});class S{get x(){return this._x}set x(e){this._x=e,this._isDirty=!0}get y(){return this._y}set y(e){this._y=e,this._isDirty=!0}get z(){return this._z}set z(e){this._z=e,this._isDirty=!0}get w(){return this._w}set w(e){this._w=e,this._isDirty=!0}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=e,this._y=E,this._z=H,this._w=N}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let e=U(this._x);return e=397*e^U(this._y),e=397*e^U(this._z),e=397*e^U(this._w),e}uM(){return[this._x,this._y,this._z,this._w]}toArray(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return e[E]=this._x,e[E+1]=this._y,e[E+2]=this._z,e[E+3]=this._w,this}VH(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(e,E,this)}equals(e){return e&&this._x===e._x&&this._y===e._y&&this._z===e._z&&this._w===e._w}equalsWithEpsilon(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.d;return e&&(0,D.WithinEpsilon)(this._x,e._x,E)&&(0,D.WithinEpsilon)(this._y,e._y,E)&&(0,D.WithinEpsilon)(this._z,e._z,E)&&(0,D.WithinEpsilon)(this._w,e._w,E)}isApprox(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.d;return e&&((0,D.WithinEpsilon)(this._x,e._x,E)&&(0,D.WithinEpsilon)(this._y,e._y,E)&&(0,D.WithinEpsilon)(this._z,e._z,E)&&(0,D.WithinEpsilon)(this._w,e._w,E)||(0,D.WithinEpsilon)(this._x,-e._x,E)&&(0,D.WithinEpsilon)(this._y,-e._y,E)&&(0,D.WithinEpsilon)(this._z,-e._z,E)&&(0,D.WithinEpsilon)(this._w,-e._w,E))}clone(){return new S(this._x,this._y,this._z,this._w)}P(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._w=e._w,this._isDirty=!0,this}VM(e,E,H,N){return this._x=e,this._y=E,this._z=H,this._w=N,this._isDirty=!0,this}set(e,E,H,N){return this.VM(e,E,H,N)}jM(e){return this.VM(e,e,e,e)}add(e){return new S(this._x+e._x,this._y+e._y,this._z+e._z,this._w+e._w)}addInPlace(e){return this._x+=e._x,this._y+=e._y,this._z+=e._z,this._w+=e._w,this._isDirty=!0,this}addToRef(e,E){return E._x=this._x+e._x,E._y=this._y+e._y,E._z=this._z+e._z,E._w=this._w+e._w,E._isDirty=!0,E}addInPlaceFromFloats(e,E,H,N){return this._x+=e,this._y+=E,this._z+=H,this._w+=N,this._isDirty=!0,this}subtractToRef(e,E){return E._x=this._x-e._x,E._y=this._y-e._y,E._z=this._z-e._z,E._w=this._w-e._w,E._isDirty=!0,E}subtractFromFloats(e,E,H,N){return this.subtractFromFloatsToRef(e,E,H,N,new S)}subtractFromFloatsToRef(e,E,H,N,u){return u._x=this._x-e,u._y=this._y-E,u._z=this._z-H,u._w=this._w-N,u._isDirty=!0,u}FE(e){return new S(this._x-e._x,this._y-e._y,this._z-e._z,this._w-e._w)}JC(e){return this._x-=e._x,this._y-=e._y,this._z-=e._z,this._w-=e._w,this._isDirty=!0,this}scale(e){return new S(this._x*e,this._y*e,this._z*e,this._w*e)}scaleToRef(e,E){return E._x=this._x*e,E._y=this._y*e,E._z=this._z*e,E._w=this._w*e,E._isDirty=!0,E}scaleInPlace(e){return this._x*=e,this._y*=e,this._z*=e,this._w*=e,this._isDirty=!0,this}scaleAndAddToRef(e,E){return E._x+=this._x*e,E._y+=this._y*e,E._z+=this._z*e,E._w+=this._w*e,E._isDirty=!0,E}multiply(e){const E=new S(0,0,0,1);return this.multiplyToRef(e,E),E}multiplyToRef(e,E){const H=this._x*e._w+this._y*e._z-this._z*e._y+this._w*e._x,N=-this._x*e._z+this._y*e._w+this._z*e._x+this._w*e._y,u=this._x*e._y-this._y*e._x+this._z*e._w+this._w*e._z,z=-this._x*e._x-this._y*e._y-this._z*e._z+this._w*e._w;return E.VM(H,N,u,z),E}multiplyInPlace(e){return this.multiplyToRef(e,this)}multiplyByFloats(e,E,H,N){return this._x*=e,this._y*=E,this._z*=H,this._w*=N,this._isDirty=!0,this}divide(e){throw new ReferenceError("Can not divide a quaternion")}divideToRef(e,E){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(e){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new S)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(e){return e._x=-this._x,e._y=-this._y,e._z=-this._z,e._w=-this._w,e._isDirty=!0,e}equalsToFloats(e,E,H,N){return this._x===e&&this._y===E&&this._z===H&&this._w===N}floorToRef(e){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(e){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(e){return e.VM(-this._x,-this._y,-this._z,this._w),e}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new S(-this._x,-this._y,-this._z,this._w)}invert(){const e=this.conjugate(),E=this.lengthSquared();return 0==E||1==E||e.scaleInPlace(1/E),e}invertInPlace(){this.conjugateInPlace();const e=this.lengthSquared();return 0==e||1==e||this.scaleInPlace(1/e),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(e){return 0===e||1===e?this:this.scaleInPlace(1/e)}normalizeToNew(){const e=new S(0,0,0,1);return this.normalizeToRef(e),e}normalizeToRef(e){const E=this.length();return 0===E||1===E?e.VM(this._x,this._y,this._z,this._w):this.scaleToRef(1/E,e)}toEulerAngles(){const e=F.Zero();return this.toEulerAnglesToRef(e),e}toEulerAnglesToRef(e){const E=this._z,H=this._x,N=this._y,u=this._w,z=N*E-H*u,P=.4999999;if(z<-P)e._y=2*Math.atan2(N,u),e._x=Math.PI/2,e._z=0,e._isDirty=!0;else if(z>P)e._y=2*Math.atan2(N,u),e._x=-Math.PI/2,e._z=0,e._isDirty=!0;else{const P=u*u,M=E*E,D=H*H,A=N*N;e._z=Math.atan2(2*(H*N+E*u),-M-D+A+P),e._x=Math.asin(-2*z),e._y=Math.atan2(2*(E*H+N*u),M-D-A+P),e._isDirty=!0}return e}toAlphaBetaGammaToRef(e){const E=this._z,H=this._x,N=this._y,u=this._w,z=Math.sqrt(H*H+N*N),P=Math.sqrt(E*E+u*u),M=2*Math.atan2(z,P),D=2*Math.atan2(E,u),A=2*Math.atan2(N,H),C=(D+A)/2,i=(D-A)/2;return e.set(i,M,C),e}toRotationMatrix(e){return X.FromQuaternionToRef(this,e),e}fromRotationMatrix(e){return S.FromRotationMatrixToRef(e,this),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}toAxisAngle(){const e=F.Zero();return{axis:e,angle:this.toAxisAngleToRef(e)}}toAxisAngleToRef(e){let E=0;const H=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),N=this._w;return H>0?(E=2*Math.atan2(H,N),e.set(this._x/H,this._y/H,this._z/H)):(E=0,e.set(1,0,0)),E}static FromRotationMatrix(e){const E=new S;return S.FromRotationMatrixToRef(e,E),E}static FromRotationMatrixToRef(e,E){const H=e.m,N=H[0],u=H[4],z=H[8],P=H[1],M=H[5],D=H[9],A=H[2],C=H[6],i=H[10],V=N+M+i;let U;return V>0?(U=.5/Math.sqrt(V+1),E._w=.25/U,E._x=(C-D)*U,E._y=(z-A)*U,E._z=(P-u)*U,E._isDirty=!0):N>M&&N>i?(U=2*Math.sqrt(1+N-M-i),E._w=(C-D)/U,E._x=.25*U,E._y=(u+P)/U,E._z=(z+A)/U,E._isDirty=!0):M>i?(U=2*Math.sqrt(1+M-N-i),E._w=(z-A)/U,E._x=(u+P)/U,E._y=.25*U,E._z=(D+C)/U,E._isDirty=!0):(U=2*Math.sqrt(1+i-N-M),E._w=(P-u)/U,E._x=(z+A)/U,E._y=(D+C)/U,E._z=.25*U,E._isDirty=!0),E}static Dot(e,E){return e._x*E._x+e._y*E._y+e._z*E._z+e._w*E._w}static AreClose(e,E){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const N=S.Dot(e,E);return 1-N*N<=H}static SmoothToRef(e,E,H,N,u){let z=0===N?1:H/N;return z=(0,D.Clamp)(z,0,1),S.SlerpToRef(e,E,z,u),u}static Zero(){return new S(0,0,0,0)}static Inverse(e){return new S(-e._x,-e._y,-e._z,e._w)}static InverseToRef(e,E){return E.set(-e._x,-e._y,-e._z,e._w),E}static Identity(){return new S(0,0,0,1)}static IsIdentity(e){return e&&0===e._x&&0===e._y&&0===e._z&&1===e._w}static RotationAxis(e,E){return S.RotationAxisToRef(e,E,new S)}static RotationAxisToRef(e,E,H){H._w=Math.cos(E/2);const N=Math.sin(E/2)/e.length();return H._x=e._x*N,H._y=e._y*N,H._z=e._z*N,H._isDirty=!0,H}static aE(e,E){return E||(E=0),new S(e[E],e[E+1],e[E+2],e[E+3])}static FromArrayToRef(e,E,H){return H._x=e[E],H._y=e[E+1],H._z=e[E+2],H._w=e[E+3],H._isDirty=!0,H}static FromFloatsToRef(e,E,H,N,u){return u.VM(e,E,H,N),u}static FromEulerAngles(e,E,H){const N=new S;return S.RotationYawPitchRollToRef(E,e,H,N),N}static FromEulerAnglesToRef(e,E,H,N){return S.RotationYawPitchRollToRef(E,e,H,N),N}static FromEulerVector(e){const E=new S;return S.RotationYawPitchRollToRef(e._y,e._x,e._z,E),E}static FromEulerVectorToRef(e,E){return S.RotationYawPitchRollToRef(e._y,e._x,e._z,E),E}static FromUnitVectorsToRef(e,E,H){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:N.d;const z=F.Dot(e,E)+1;return z<u?Math.abs(e.x)>Math.abs(e.z)?H.set(-e.y,e.x,0,0):H.set(0,-e.z,e.y,0):(F.CrossToRef(e,E,W.jE[0]),H.set(W.jE[0].x,W.jE[0].y,W.jE[0].z,z)),H.normalize()}static RotationYawPitchRoll(e,E,H){const N=new S;return S.RotationYawPitchRollToRef(e,E,H,N),N}static RotationYawPitchRollToRef(e,E,H,N){const u=.5*H,z=.5*E,P=.5*e,M=Math.sin(u),D=Math.cos(u),A=Math.sin(z),C=Math.cos(z),i=Math.sin(P),V=Math.cos(P);return N._x=V*A*D+i*C*M,N._y=i*C*D-V*A*M,N._z=V*C*M-i*A*D,N._w=V*C*D+i*A*M,N._isDirty=!0,N}static RotationAlphaBetaGamma(e,E,H){const N=new S;return S.RotationAlphaBetaGammaToRef(e,E,H,N),N}static RotationAlphaBetaGammaToRef(e,E,H,N){const u=.5*(H+e),z=.5*(H-e),P=.5*E;return N._x=Math.cos(z)*Math.sin(P),N._y=Math.sin(z)*Math.sin(P),N._z=Math.sin(u)*Math.cos(P),N._w=Math.cos(u)*Math.cos(P),N._isDirty=!0,N}static RotationQuaternionFromAxis(e,E,H){const N=new S(0,0,0,0);return S.RotationQuaternionFromAxisToRef(e,E,H,N),N}static RotationQuaternionFromAxisToRef(e,E,H,N){const u=a.Matrix[0];return e=e.normalizeToRef(a.jE[0]),E=E.normalizeToRef(a.jE[1]),H=H.normalizeToRef(a.jE[2]),X.FromXYZAxesToRef(e,E,H,u),S.FromRotationMatrixToRef(u,N),N}static FromLookDirectionLH(e,E){const H=new S;return S.FromLookDirectionLHToRef(e,E,H),H}static FromLookDirectionLHToRef(e,E,H){const N=a.Matrix[0];return X.LookDirectionLHToRef(e,E,N),S.FromRotationMatrixToRef(N,H),H}static FromLookDirectionRH(e,E){const H=new S;return S.FromLookDirectionRHToRef(e,E,H),H}static FromLookDirectionRHToRef(e,E,H){const N=a.Matrix[0];return X.LookDirectionRHToRef(e,E,N),S.FromRotationMatrixToRef(N,H)}static Slerp(e,E,H){const N=S.Identity();return S.SlerpToRef(e,E,H,N),N}static SlerpToRef(e,E,H,N){let u,z,P=e._x*E._x+e._y*E._y+e._z*E._z+e._w*E._w,M=!1;if(P<0&&(M=!0,P=-P),P>.999999)z=1-H,u=M?-H:H;else{const e=Math.acos(P),E=1/Math.sin(e);z=Math.sin((1-H)*e)*E,u=M?-Math.sin(H*e)*E:Math.sin(H*e)*E}return N._x=z*e._x+u*E._x,N._y=z*e._y+u*E._y,N._z=z*e._z+u*E._z,N._w=z*e._w+u*E._w,N._isDirty=!0,N}static Hermite(e,E,H,N,u){const z=u*u,P=u*z,M=2*P-3*z+1,D=-2*P+3*z,A=P-2*z+u,C=P-z,i=e._x*M+H._x*D+E._x*A+N._x*C,V=e._y*M+H._y*D+E._y*A+N._y*C,U=e._z*M+H._z*D+E._z*A+N._z*C,j=e._w*M+H._w*D+E._w*A+N._w*C;return new S(i,V,U,j)}static Hermite1stDerivative(e,E,H,N,u){const z=new S;return this.Hermite1stDerivativeToRef(e,E,H,N,u,z),z}static Hermite1stDerivativeToRef(e,E,H,N,u,z){const P=u*u;return z._x=6*(P-u)*e._x+(3*P-4*u+1)*E._x+6*(-P+u)*H._x+(3*P-2*u)*N._x,z._y=6*(P-u)*e._y+(3*P-4*u+1)*E._y+6*(-P+u)*H._y+(3*P-2*u)*N._y,z._z=6*(P-u)*e._z+(3*P-4*u+1)*E._z+6*(-P+u)*H._z+(3*P-2*u)*N._z,z._w=6*(P-u)*e._w+(3*P-4*u+1)*E._w+6*(-P+u)*H._w+(3*P-2*u)*N._w,z._isDirty=!0,z}static Normalize(e){const E=S.Zero();return S.NormalizeToRef(e,E),E}static NormalizeToRef(e,E){return e.normalizeToRef(E),E}static Clamp(e,E,H){const N=new S;return S.ClampToRef(e,E,H,N),N}static ClampToRef(e,E,H,N){return N.VM((0,D.Clamp)(e.x,E.x,H.x),(0,D.Clamp)(e.y,E.y,H.y),(0,D.Clamp)(e.z,E.z,H.z),(0,D.Clamp)(e.w,E.w,H.w))}static Random(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new S((0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E))}static RandomToRef(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).VM((0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E),(0,D.RandomRange)(e,E))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(e,E){return Math.sqrt(S.DistanceSquared(e,E))}static DistanceSquared(e,E){const H=e.x-E.x,N=e.y-E.y,u=e.z-E.z,z=e.w-E.w;return H*H+N*N+u*u+z*z}static Center(e,E){return S.CenterToRef(e,E,S.Zero())}static CenterToRef(e,E,H){return H.VM((e.x+E.x)/2,(e.y+E.y)/2,(e.z+E.z)/2,(e.w+E.w)/2)}}S._V8PerformanceHack=new S(.5,.5,.5,.5),Object.defineProperties(S.prototype,{dimension:{value:[4]},rank:{value:1}});class X{static get Use64Bits(){return P.e.MatrixUse64Bits}get m(){return this.gP}markAsUpdated(){this.updateFlag=A._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(e){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],N=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=e,this._isIdentity3x2=e||H,this._isIdentityDirty=!this._isIdentity&&E,this._isIdentity3x2Dirty=!this._isIdentity3x2&&N}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,P.e.MatrixTrackPrecisionChange&&P.e.MatrixTrackedMatrices.push(this),this.gP=new P.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const e=this.gP;this._isIdentity=1===e[0]&&0===e[1]&&0===e[2]&&0===e[3]&&0===e[4]&&1===e[5]&&0===e[6]&&0===e[7]&&0===e[8]&&0===e[9]&&1===e[10]&&0===e[11]&&0===e[12]&&0===e[13]&&0===e[14]&&1===e[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.gP[0]||1!==this.gP[5]||1!==this.gP[15]||0!==this.gP[1]||0!==this.gP[2]||0!==this.gP[3]||0!==this.gP[4]||0!==this.gP[6]||0!==this.gP[7]||0!==this.gP[8]||0!==this.gP[9]||0!==this.gP[10]||0!==this.gP[11]||0!==this.gP[12]||0!==this.gP[13]||0!==this.gP[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const e=this.gP,E=e[0],H=e[1],N=e[2],u=e[3],z=e[4],P=e[5],M=e[6],D=e[7],A=e[8],C=e[9],i=e[10],V=e[11],U=e[12],j=e[13],F=e[14],h=e[15],S=i*h-F*V,X=C*h-j*V,a=C*F-j*i,W=A*h-U*V,r=A*F-i*U,Y=A*j-U*C;return E*+(P*S-M*X+D*a)+H*-(z*S-M*W+D*r)+N*+(z*X-P*W+D*Y)+u*-(z*a-P*r+M*Y)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e)return this.gP;const H=this.gP;for(let N=0;N<16;N++)e[E+N]=H[N];return this}uM(){return this.gP}VH(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return X.FromArrayToRef(e,E,this)}VM(){for(var e=arguments.length,E=new Array(e),H=0;H<e;H++)E[H]=arguments[H];return X.FromArrayToRef(E,0,this)}set(){const e=this.gP;for(let E=0;E<16;E++)e[E]=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}jM(e){const E=this.gP;for(let H=0;H<16;H++)E[H]=e;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return X.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(e){const E=new X;return this.addToRef(e,E),E}addToRef(e,E){const H=this.gP,N=E.gP,u=e.m;for(let z=0;z<16;z++)N[z]=H[z]+u[z];return E.markAsUpdated(),E}addToSelf(e){const E=this.gP,H=e.m;return E[0]+=H[0],E[1]+=H[1],E[2]+=H[2],E[3]+=H[3],E[4]+=H[4],E[5]+=H[5],E[6]+=H[6],E[7]+=H[7],E[8]+=H[8],E[9]+=H[9],E[10]+=H[10],E[11]+=H[11],E[12]+=H[12],E[13]+=H[13],E[14]+=H[14],E[15]+=H[15],this.markAsUpdated(),this}addInPlace(e){const E=this.gP,H=e.m;for(let N=0;N<16;N++)E[N]+=H[N];return this.markAsUpdated(),this}addInPlaceFromFloats(){const e=this.gP;for(let E=0;E<16;E++)e[E]+=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}FE(e){const E=this.gP,H=e.m;for(let N=0;N<16;N++)E[N]-=H[N];return this.markAsUpdated(),this}subtractToRef(e,E){const H=this.gP,N=e.m,u=E.gP;for(let z=0;z<16;z++)u[z]=H[z]-N[z];return E.markAsUpdated(),E}JC(e){const E=this.gP,H=e.m;for(let N=0;N<16;N++)E[N]-=H[N];return this.markAsUpdated(),this}subtractFromFloats(){for(var e=arguments.length,E=new Array(e),H=0;H<e;H++)E[H]=arguments[H];return this.subtractFromFloatsToRef(...E,new X)}subtractFromFloatsToRef(){for(var e=arguments.length,E=new Array(e),H=0;H<e;H++)E[H]=arguments[H];const N=E.pop(),u=this.gP,z=N.gP,P=E;for(let M=0;M<16;M++)z[M]=u[M]-P[M];return N.markAsUpdated(),N}invertToRef(e){return!0===this._isIdentity?(X.IdentityToRef(e),e):(V(this,e.uM())?e.markAsUpdated():e.P(this),e)}addAtIndex(e,E){return this.gP[e]+=E,this.markAsUpdated(),this}multiplyAtIndex(e,E){return this.gP[e]*=E,this.markAsUpdated(),this}setTranslationFromFloats(e,E,H){return this.gP[12]=e,this.gP[13]=E,this.gP[14]=H,this.markAsUpdated(),this}addTranslationFromFloats(e,E,H){return this.gP[12]+=e,this.gP[13]+=E,this.gP[14]+=H,this.markAsUpdated(),this}setTranslation(e){return this.setTranslationFromFloats(e._x,e._y,e._z)}getTranslation(){return new F(this.gP[12],this.gP[13],this.gP[14])}getTranslationToRef(e){return e.x=this.gP[12],e.y=this.gP[13],e.z=this.gP[14],e}removeRotationAndScaling(){const e=this.m;return X.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,e[12],e[13],e[14],e[15],this),this._updateIdentityStatus(0===e[12]&&0===e[13]&&0===e[14]&&1===e[15]),this}P(e){e.copyToArray(this.gP);const E=e;return this.updateFlag=E.updateFlag,this._updateIdentityStatus(E._isIdentity,E._isIdentityDirty,E._isIdentity3x2,E._isIdentity3x2Dirty),this}copyToArray(e){return i(this,e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(e){const E=new X;return this.multiplyToRef(e,E),E}multiplyInPlace(e){const E=this.gP,H=e.m;for(let N=0;N<16;N++)E[N]*=H[N];return this.markAsUpdated(),this}multiplyByFloats(){const e=this.gP;for(let E=0;E<16;E++)e[E]*=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var e=arguments.length,E=new Array(e),H=0;H<e;H++)E[H]=arguments[H];const N=E.pop(),u=this.gP,z=N.gP,P=E;for(let M=0;M<16;M++)z[M]=u[M]*P[M];return N.markAsUpdated(),N}multiplyToRef(e,E){return this._isIdentity?(E.P(e),E):e._isIdentity?(E.P(this),E):(this.multiplyToArray(e,E.gP,0),E.markAsUpdated(),E)}multiplyToArray(e,E,H){return C(this,e,E,H),this}divide(e){return this.divideToRef(e,new X)}divideToRef(e,E){const H=this.gP,N=e.m,u=E.gP;for(let z=0;z<16;z++)u[z]=H[z]/N[z];return E.markAsUpdated(),E}divideInPlace(e){const E=this.gP,H=e.m;for(let N=0;N<16;N++)E[N]/=H[N];return this.markAsUpdated(),this}minimizeInPlace(e){const E=this.gP,H=e.m;for(let N=0;N<16;N++)E[N]=Math.min(E[N],H[N]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const e=this.gP;for(let E=0;E<16;E++)e[E]=Math.min(e[E],E<0||arguments.length<=E?void 0:arguments[E]);return this.markAsUpdated(),this}maximizeInPlace(e){const E=this.gP,H=e.m;for(let N=0;N<16;N++)E[N]=Math.min(E[N],H[N]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const e=this.gP;for(let E=0;E<16;E++)e[E]=Math.min(e[E],E<0||arguments.length<=E?void 0:arguments[E]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new X)}negateInPlace(){const e=this.gP;for(let E=0;E<16;E++)e[E]=-e[E];return this.markAsUpdated(),this}negateToRef(e){const E=this.gP,H=e.gP;for(let N=0;N<16;N++)H[N]=-E[N];return e.markAsUpdated(),e}equals(e){const E=e;if(!E)return!1;if((this._isIdentity||E._isIdentity)&&!this._isIdentityDirty&&!E._isIdentityDirty)return this._isIdentity&&E._isIdentity;const H=this.m,N=E.m;return H[0]===N[0]&&H[1]===N[1]&&H[2]===N[2]&&H[3]===N[3]&&H[4]===N[4]&&H[5]===N[5]&&H[6]===N[6]&&H[7]===N[7]&&H[8]===N[8]&&H[9]===N[9]&&H[10]===N[10]&&H[11]===N[11]&&H[12]===N[12]&&H[13]===N[13]&&H[14]===N[14]&&H[15]===N[15]}equalsWithEpsilon(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const H=this.gP,N=e.m;for(let u=0;u<16;u++)if(!(0,D.WithinEpsilon)(H[u],N[u],E))return!1;return!0}equalsToFloats(){const e=this.gP;for(let E=0;E<16;E++)if(e[E]!=(E<0||arguments.length<=E?void 0:arguments[E]))return!1;return!0}floor(){return this.floorToRef(new X)}floorToRef(e){const E=this.gP,H=e.gP;for(let N=0;N<16;N++)H[N]=Math.floor(E[N]);return e.markAsUpdated(),e}fract(){return this.fractToRef(new X)}fractToRef(e){const E=this.gP,H=e.gP;for(let N=0;N<16;N++)H[N]=E[N]-Math.floor(E[N]);return e.markAsUpdated(),e}clone(){const e=new X;return e.P(this),e}getClassName(){return"Matrix"}getHashCode(){let e=U(this.gP[0]);for(let E=1;E<16;E++)e=397*e^U(this.gP[E]);return e}decomposeToTransformNode(e){return e.rotationQuaternion=e.rotationQuaternion||new S,this.decompose(e.UM,e.rotationQuaternion,e.position)}decompose(e,E,H,N){let u=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return H&&H.jM(0),e&&e.jM(1),E&&E.VM(0,0,0,1),!0;const z=this.gP;if(H&&H.VM(z[12],z[13],z[14]),(e=e||a.jE[0]).x=Math.sqrt(z[0]*z[0]+z[1]*z[1]+z[2]*z[2]),e.y=Math.sqrt(z[4]*z[4]+z[5]*z[5]+z[6]*z[6]),e.z=Math.sqrt(z[8]*z[8]+z[9]*z[9]+z[10]*z[10]),N){const E=(u?N.absoluteScaling.x:N.UM.x)<0?-1:1,H=(u?N.absoluteScaling.y:N.UM.y)<0?-1:1,z=(u?N.absoluteScaling.z:N.UM.z)<0?-1:1;e.x*=E,e.y*=H,e.z*=z}else this.determinant()<=0&&(e.y*=-1);if(0===e._x||0===e._y||0===e._z)return E&&E.VM(0,0,0,1),!1;if(E){const H=1/e._x,N=1/e._y,u=1/e._z;X.FromValuesToRef(z[0]*H,z[1]*H,z[2]*H,0,z[4]*N,z[5]*N,z[6]*N,0,z[8]*u,z[9]*u,z[10]*u,0,0,0,0,1,a.Matrix[0]),S.FromRotationMatrixToRef(a.Matrix[0],E)}return!0}getRow(e){if(e<0||e>3)return null;const E=4*e;return new h(this.gP[E+0],this.gP[E+1],this.gP[E+2],this.gP[E+3])}getRowToRef(e,E){if(e>=0&&e<=3){const H=4*e;E.x=this.gP[H+0],E.y=this.gP[H+1],E.z=this.gP[H+2],E.w=this.gP[H+3]}return E}setRow(e,E){return this.setRowFromFloats(e,E.x,E.y,E.z,E.w)}transpose(){const e=new X;return X.TransposeToRef(this,e),e}transposeToRef(e){return X.TransposeToRef(this,e),e}setRowFromFloats(e,E,H,N,u){if(e<0||e>3)return this;const z=4*e;return this.gP[z+0]=E,this.gP[z+1]=H,this.gP[z+2]=N,this.gP[z+3]=u,this.markAsUpdated(),this}scale(e){const E=new X;return this.scaleToRef(e,E),E}scaleToRef(e,E){for(let H=0;H<16;H++)E.gP[H]=this.gP[H]*e;return E.markAsUpdated(),E}scaleAndAddToRef(e,E){for(let H=0;H<16;H++)E.gP[H]+=this.gP[H]*e;return E.markAsUpdated(),E}scaleInPlace(e){const E=this.gP;for(let H=0;H<16;H++)E[H]*=e;return this.markAsUpdated(),this}toNormalMatrix(e){const E=a.Matrix[0];this.invertToRef(E),E.transposeToRef(e);const H=e.gP;return X.FromValuesToRef(H[0],H[1],H[2],0,H[4],H[5],H[6],0,H[8],H[9],H[10],0,0,0,0,1,e),e}getRotationMatrix(){const e=new X;return this.getRotationMatrixToRef(e),e}getRotationMatrixToRef(e){const E=a.jE[0];if(!this.decompose(E))return X.IdentityToRef(e),e;const H=this.gP,N=1/E._x,u=1/E._y,z=1/E._z;return X.FromValuesToRef(H[0]*N,H[1]*N,H[2]*N,0,H[4]*u,H[5]*u,H[6]*u,0,H[8]*z,H[9]*z,H[10]*z,0,0,0,0,1,e),e}toggleModelMatrixHandInPlace(){const e=this.gP;return e[2]*=-1,e[6]*=-1,e[8]*=-1,e[9]*=-1,e[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const e=this.gP;return e[8]*=-1,e[9]*=-1,e[10]*=-1,e[11]*=-1,this.markAsUpdated(),this}static aE(e){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const H=new X;return X.FromArrayToRef(e,E,H),H}static FromArrayToRef(e,E,H){for(let N=0;N<16;N++)H.gP[N]=e[N+E];return H.markAsUpdated(),H}static FromFloat32ArrayToRefScaled(e,E,H,N){return N.gP[0]=e[0+E]*H,N.gP[1]=e[1+E]*H,N.gP[2]=e[2+E]*H,N.gP[3]=e[3+E]*H,N.gP[4]=e[4+E]*H,N.gP[5]=e[5+E]*H,N.gP[6]=e[6+E]*H,N.gP[7]=e[7+E]*H,N.gP[8]=e[8+E]*H,N.gP[9]=e[9+E]*H,N.gP[10]=e[10+E]*H,N.gP[11]=e[11+E]*H,N.gP[12]=e[12+E]*H,N.gP[13]=e[13+E]*H,N.gP[14]=e[14+E]*H,N.gP[15]=e[15+E]*H,N.markAsUpdated(),N}static get IdentityReadOnly(){return X._IdentityReadOnly}static FromValuesToRef(e,E,H,N,u,z,P,M,D,A,C,i,V,U,j,F,h){const S=h.gP;S[0]=e,S[1]=E,S[2]=H,S[3]=N,S[4]=u,S[5]=z,S[6]=P,S[7]=M,S[8]=D,S[9]=A,S[10]=C,S[11]=i,S[12]=V,S[13]=U,S[14]=j,S[15]=F,h.markAsUpdated()}static FromValues(e,E,H,N,u,z,P,M,D,A,C,i,V,U,j,F){const h=new X,S=h.gP;return S[0]=e,S[1]=E,S[2]=H,S[3]=N,S[4]=u,S[5]=z,S[6]=P,S[7]=M,S[8]=D,S[9]=A,S[10]=C,S[11]=i,S[12]=V,S[13]=U,S[14]=j,S[15]=F,h.markAsUpdated(),h}static Compose(e,E,H){const N=new X;return X.ComposeToRef(e,E,H,N),N}static ComposeToRef(e,E,H,N){const u=N.gP,z=E._x,P=E._y,M=E._z,D=E._w,A=z+z,C=P+P,i=M+M,V=z*A,U=z*C,j=z*i,F=P*C,h=P*i,S=M*i,X=D*A,a=D*C,W=D*i,r=e._x,Y=e._y,f=e._z;return u[0]=(1-(F+S))*r,u[1]=(U+W)*r,u[2]=(j-a)*r,u[3]=0,u[4]=(U-W)*Y,u[5]=(1-(V+S))*Y,u[6]=(h+X)*Y,u[7]=0,u[8]=(j+a)*f,u[9]=(h-X)*f,u[10]=(1-(V+F))*f,u[11]=0,u[12]=H._x,u[13]=H._y,u[14]=H._z,u[15]=1,N.markAsUpdated(),N}static Identity(){const e=X.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return e._updateIdentityStatus(!0),e}static IdentityToRef(e){return X.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,e),e._updateIdentityStatus(!0),e}static Zero(){const e=X.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return e._updateIdentityStatus(!1),e}static RotationX(e){const E=new X;return X.RotationXToRef(e,E),E}static Invert(e){const E=new X;return e.invertToRef(E),E}static RotationXToRef(e,E){const H=Math.sin(e),N=Math.cos(e);return X.FromValuesToRef(1,0,0,0,0,N,H,0,0,-H,N,0,0,0,0,1,E),E._updateIdentityStatus(1===N&&0===H),E}static RotationY(e){const E=new X;return X.RotationYToRef(e,E),E}static RotationYToRef(e,E){const H=Math.sin(e),N=Math.cos(e);return X.FromValuesToRef(N,0,-H,0,0,1,0,0,H,0,N,0,0,0,0,1,E),E._updateIdentityStatus(1===N&&0===H),E}static RotationZ(e){const E=new X;return X.RotationZToRef(e,E),E}static RotationZToRef(e,E){const H=Math.sin(e),N=Math.cos(e);return X.FromValuesToRef(N,H,0,0,-H,N,0,0,0,0,1,0,0,0,0,1,E),E._updateIdentityStatus(1===N&&0===H),E}static RotationAxis(e,E){const H=new X;return X.RotationAxisToRef(e,E,H),H}static RotationAxisToRef(e,E,H){const N=Math.sin(-E),u=Math.cos(-E),z=1-u;e=e.normalizeToRef(a.jE[0]);const P=H.gP;return P[0]=e._x*e._x*z+u,P[1]=e._x*e._y*z-e._z*N,P[2]=e._x*e._z*z+e._y*N,P[3]=0,P[4]=e._y*e._x*z+e._z*N,P[5]=e._y*e._y*z+u,P[6]=e._y*e._z*z-e._x*N,P[7]=0,P[8]=e._z*e._x*z-e._y*N,P[9]=e._z*e._y*z+e._x*N,P[10]=e._z*e._z*z+u,P[11]=0,P[12]=0,P[13]=0,P[14]=0,P[15]=1,H.markAsUpdated(),H}static RotationAlignToRef(e,E,H){let u=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const z=F.Dot(E,e),P=H.gP;if(z<-1+N.d)P[0]=-1,P[1]=0,P[2]=0,P[3]=0,P[4]=0,P[5]=u?1:-1,P[6]=0,P[7]=0,P[8]=0,P[9]=0,P[10]=u?-1:1,P[11]=0;else{const H=F.Cross(E,e),N=1/(1+z);P[0]=H._x*H._x*N+z,P[1]=H._y*H._x*N-H._z,P[2]=H._z*H._x*N+H._y,P[3]=0,P[4]=H._x*H._y*N+H._z,P[5]=H._y*H._y*N+z,P[6]=H._z*H._y*N-H._x,P[7]=0,P[8]=H._x*H._z*N-H._y,P[9]=H._y*H._z*N+H._x,P[10]=H._z*H._z*N+z,P[11]=0}return P[12]=0,P[13]=0,P[14]=0,P[15]=1,H.markAsUpdated(),H}static RotationYawPitchRoll(e,E,H){const N=new X;return X.RotationYawPitchRollToRef(e,E,H,N),N}static RotationYawPitchRollToRef(e,E,H,N){return S.RotationYawPitchRollToRef(e,E,H,a.Quaternion[0]),a.Quaternion[0].toRotationMatrix(N),N}static Scaling(e,E,H){const N=new X;return X.ScalingToRef(e,E,H,N),N}static ScalingToRef(e,E,H,N){return X.FromValuesToRef(e,0,0,0,0,E,0,0,0,0,H,0,0,0,0,1,N),N._updateIdentityStatus(1===e&&1===E&&1===H),N}static Translation(e,E,H){const N=new X;return X.TranslationToRef(e,E,H,N),N}static TranslationToRef(e,E,H,N){return X.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,e,E,H,1,N),N._updateIdentityStatus(0===e&&0===E&&0===H),N}static Lerp(e,E,H){const N=new X;return X.LerpToRef(e,E,H,N),N}static LerpToRef(e,E,H,N){const u=N.gP,z=e.m,P=E.m;for(let M=0;M<16;M++)u[M]=z[M]*(1-H)+P[M]*H;return N.markAsUpdated(),N}static DecomposeLerp(e,E,H){const N=new X;return X.DecomposeLerpToRef(e,E,H,N),N}static DecomposeLerpToRef(e,E,H,N){const u=a.jE[0],z=a.Quaternion[0],P=a.jE[1];e.decompose(u,z,P);const M=a.jE[2],D=a.Quaternion[1],A=a.jE[3];E.decompose(M,D,A);const C=a.jE[4];F.LerpToRef(u,M,H,C);const i=a.Quaternion[2];S.SlerpToRef(z,D,H,i);const V=a.jE[5];return F.LerpToRef(P,A,H,V),X.ComposeToRef(C,i,V,N),N}static LookAtLH(e,E,H){const N=new X;return X.LookAtLHToRef(e,E,H,N),N}static LookAtLHToRef(e,E,H,N){const u=a.jE[0],z=a.jE[1],P=a.jE[2];E.subtractToRef(e,P),P.normalize(),F.CrossToRef(H,P,u);const M=u.lengthSquared();0===M?u.x=1:u.normalizeFromLength(Math.sqrt(M)),F.CrossToRef(P,u,z),z.normalize();const D=-F.Dot(u,e),A=-F.Dot(z,e),C=-F.Dot(P,e);return X.FromValuesToRef(u._x,z._x,P._x,0,u._y,z._y,P._y,0,u._z,z._z,P._z,0,D,A,C,1,N),N}static LookAtRH(e,E,H){const N=new X;return X.LookAtRHToRef(e,E,H,N),N}static LookAtRHToRef(e,E,H,N){const u=a.jE[0],z=a.jE[1],P=a.jE[2];e.subtractToRef(E,P),P.normalize(),F.CrossToRef(H,P,u);const M=u.lengthSquared();0===M?u.x=1:u.normalizeFromLength(Math.sqrt(M)),F.CrossToRef(P,u,z),z.normalize();const D=-F.Dot(u,e),A=-F.Dot(z,e),C=-F.Dot(P,e);return X.FromValuesToRef(u._x,z._x,P._x,0,u._y,z._y,P._y,0,u._z,z._z,P._z,0,D,A,C,1,N),N}static LookDirectionLH(e,E){const H=new X;return X.LookDirectionLHToRef(e,E,H),H}static LookDirectionLHToRef(e,E,H){const N=a.jE[0];N.P(e),N.scaleInPlace(-1);const u=a.jE[1];return F.CrossToRef(E,N,u),X.FromValuesToRef(u._x,u._y,u._z,0,E._x,E._y,E._z,0,N._x,N._y,N._z,0,0,0,0,1,H),H}static LookDirectionRH(e,E){const H=new X;return X.LookDirectionRHToRef(e,E,H),H}static LookDirectionRHToRef(e,E,H){const N=a.jE[2];return F.CrossToRef(E,e,N),X.FromValuesToRef(N._x,N._y,N._z,0,E._x,E._y,E._z,0,e._x,e._y,e._z,0,0,0,0,1,H),H}static OrthoLH(e,E,H,N,u){const z=new X;return X.OrthoLHToRef(e,E,H,N,z,u),z}static OrthoLHToRef(e,E,H,N,u,z){const P=2/e,M=2/E,D=2/(N-H),A=-(N+H)/(N-H);return X.FromValuesToRef(P,0,0,0,0,M,0,0,0,0,D,0,0,0,A,1,u),z&&u.multiplyToRef(r,u),u._updateIdentityStatus(1===P&&1===M&&1===D&&0===A),u}static OrthoOffCenterLH(e,E,H,N,u,z,P){const M=new X;return X.OrthoOffCenterLHToRef(e,E,H,N,u,z,M,P),M}static OrthoOffCenterLHToRef(e,E,H,N,u,z,P,M){const D=2/(E-e),A=2/(N-H),C=2/(z-u),i=-(z+u)/(z-u),V=(e+E)/(e-E),U=(N+H)/(H-N);return X.FromValuesToRef(D,0,0,0,0,A,0,0,0,0,C,0,V,U,i,1,P),M&&P.multiplyToRef(r,P),P.markAsUpdated(),P}static ObliqueOffCenterLHToRef(e,E,H,N,u,z,P,M,D,A,C){const i=-P*Math.cos(M),V=-P*Math.sin(M);return X.TranslationToRef(0,0,-D,a.Matrix[1]),X.FromValuesToRef(1,0,0,0,0,1,0,0,i,V,1,0,0,0,0,1,a.Matrix[0]),a.Matrix[1].multiplyToRef(a.Matrix[0],a.Matrix[0]),X.TranslationToRef(0,0,D,a.Matrix[1]),a.Matrix[0].multiplyToRef(a.Matrix[1],a.Matrix[0]),X.OrthoOffCenterLHToRef(e,E,H,N,u,z,A,C),a.Matrix[0].multiplyToRef(A,A),A}static OrthoOffCenterRH(e,E,H,N,u,z,P){const M=new X;return X.OrthoOffCenterRHToRef(e,E,H,N,u,z,M,P),M}static OrthoOffCenterRHToRef(e,E,H,N,u,z,P,M){return X.OrthoOffCenterLHToRef(e,E,H,N,u,z,P,M),P.gP[10]*=-1,P}static ObliqueOffCenterRHToRef(e,E,H,N,u,z,P,M,D,A,C){const i=P*Math.cos(M),V=P*Math.sin(M);return X.TranslationToRef(0,0,D,a.Matrix[1]),X.FromValuesToRef(1,0,0,0,0,1,0,0,i,V,1,0,0,0,0,1,a.Matrix[0]),a.Matrix[1].multiplyToRef(a.Matrix[0],a.Matrix[0]),X.TranslationToRef(0,0,-D,a.Matrix[1]),a.Matrix[0].multiplyToRef(a.Matrix[1],a.Matrix[0]),X.OrthoOffCenterRHToRef(e,E,H,N,u,z,A,C),a.Matrix[0].multiplyToRef(A,A),A}static PerspectiveLH(e,E,H,N,u){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const P=new X,M=2*H/e,D=2*H/E,A=(N+H)/(N-H),C=-2*N*H/(N-H),i=Math.tan(z);return X.FromValuesToRef(M,0,0,0,0,D,0,i,0,0,A,1,0,0,C,0,P),u&&P.multiplyToRef(r,P),P._updateIdentityStatus(!1),P}static PerspectiveFovLH(e,E,H,N,u){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,P=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const M=new X;return X.PerspectiveFovLHToRef(e,E,H,N,M,!0,u,z,P),M}static PerspectiveFovLHToRef(e,E,H,N,u){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],P=arguments.length>6?arguments[6]:void 0,M=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,D=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const A=H,C=N,i=1/Math.tan(.5*e),V=z?i/E:i,U=z?i:i*E,j=D&&0===A?-1:0!==C?(C+A)/(C-A):1,F=D&&0===A?2*C:0!==C?-2*C*A/(C-A):-2*A,h=Math.tan(M);return X.FromValuesToRef(V,0,0,0,0,U,0,h,0,0,j,1,0,0,F,0,u),P&&u.multiplyToRef(r,u),u._updateIdentityStatus(!1),u}static PerspectiveFovReverseLHToRef(e,E,H,N,u){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],P=arguments.length>6?arguments[6]:void 0,M=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const D=1/Math.tan(.5*e),A=z?D/E:D,C=z?D:D*E,i=Math.tan(M);return X.FromValuesToRef(A,0,0,0,0,C,0,i,0,0,-H,1,0,0,1,0,u),P&&u.multiplyToRef(r,u),u._updateIdentityStatus(!1),u}static PerspectiveFovRH(e,E,H,N,u){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,P=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const M=new X;return X.PerspectiveFovRHToRef(e,E,H,N,M,!0,u,z,P),M}static PerspectiveFovRHToRef(e,E,H,N,u){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],P=arguments.length>6?arguments[6]:void 0,M=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,D=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const A=H,C=N,i=1/Math.tan(.5*e),V=z?i/E:i,U=z?i:i*E,j=D&&0===A?1:0!==C?-(C+A)/(C-A):-1,F=D&&0===A?2*C:0!==C?-2*C*A/(C-A):-2*A,h=Math.tan(M);return X.FromValuesToRef(V,0,0,0,0,U,0,h,0,0,j,-1,0,0,F,0,u),P&&u.multiplyToRef(r,u),u._updateIdentityStatus(!1),u}static PerspectiveFovReverseRHToRef(e,E,H,N,u){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],P=arguments.length>6?arguments[6]:void 0,M=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const D=1/Math.tan(.5*e),A=z?D/E:D,C=z?D:D*E,i=Math.tan(M);return X.FromValuesToRef(A,0,0,0,0,C,0,i,0,0,-H,-1,0,0,-1,0,u),P&&u.multiplyToRef(r,u),u._updateIdentityStatus(!1),u}static GetFinalMatrix(e,E,H,N,u,z){const P=e.width,M=e.height,D=e.x,A=e.y,C=X.FromValues(P/2,0,0,0,0,-M/2,0,0,0,0,z-u,0,D+P/2,M/2+A,u,1),i=new X;return E.multiplyToRef(H,i),i.multiplyToRef(N,i),i.multiplyToRef(C,i)}static GetAsMatrix2x2(e){const E=e.m,H=[E[0],E[1],E[4],E[5]];return P.e.MatrixUse64Bits?H:new Float32Array(H)}static GetAsMatrix3x3(e){const E=e.m,H=[E[0],E[1],E[2],E[4],E[5],E[6],E[8],E[9],E[10]];return P.e.MatrixUse64Bits?H:new Float32Array(H)}static Transpose(e){const E=new X;return X.TransposeToRef(e,E),E}static TransposeToRef(e,E){const H=e.m,N=H[0],u=H[4],z=H[8],P=H[12],M=H[1],D=H[5],A=H[9],C=H[13],i=H[2],V=H[6],U=H[10],j=H[14],F=H[3],h=H[7],S=H[11],X=H[15],a=E.gP;return a[0]=N,a[1]=u,a[2]=z,a[3]=P,a[4]=M,a[5]=D,a[6]=A,a[7]=C,a[8]=i,a[9]=V,a[10]=U,a[11]=j,a[12]=F,a[13]=h,a[14]=S,a[15]=X,E.markAsUpdated(),E._updateIdentityStatus(e._isIdentity,e._isIdentityDirty),E}static Reflection(e){const E=new X;return X.ReflectionToRef(e,E),E}static ReflectionToRef(e,E){e.normalize();const H=e.normal.x,N=e.normal.y,u=e.normal.z,z=-2*H,P=-2*N,M=-2*u;return X.FromValuesToRef(z*H+1,P*H,M*H,0,z*N,P*N+1,M*N,0,z*u,P*u,M*u+1,0,z*e.d,P*e.d,M*e.d,1,E),E}static FromXYZAxesToRef(e,E,H,N){return X.FromValuesToRef(e._x,e._y,e._z,0,E._x,E._y,E._z,0,H._x,H._y,H._z,0,0,0,0,1,N),N}static FromQuaternionToRef(e,E){const H=e._x*e._x,N=e._y*e._y,u=e._z*e._z,z=e._x*e._y,P=e._z*e._w,M=e._z*e._x,D=e._y*e._w,A=e._y*e._z,C=e._x*e._w;return E.gP[0]=1-2*(N+u),E.gP[1]=2*(z+P),E.gP[2]=2*(M-D),E.gP[3]=0,E.gP[4]=2*(z-P),E.gP[5]=1-2*(u+H),E.gP[6]=2*(A+C),E.gP[7]=0,E.gP[8]=2*(M+D),E.gP[9]=2*(A-C),E.gP[10]=1-2*(N+H),E.gP[11]=0,E.gP[12]=0,E.gP[13]=0,E.gP[14]=0,E.gP[15]=1,E.markAsUpdated(),E}}X._IdentityReadOnly=X.Identity(),Object.defineProperties(X.prototype,{dimension:{value:[4,4]},rank:{value:2}});class a{}a.jE=(0,u.e)(11,F.Zero),a.Matrix=(0,u.e)(2,X.Identity),a.Quaternion=(0,u.e)(3,S.Zero);class W{}W.Vector2=(0,u.e)(3,j.Zero),W.jE=(0,u.e)(13,F.Zero),W.Vector4=(0,u.e)(3,h.Zero),W.Quaternion=(0,u.e)(3,S.Zero),W.Matrix=(0,u.e)(8,X.Identity),(0,z.g)("BABYLON.Vector2",j),(0,z.g)("BABYLON.Vector3",F),(0,z.g)("BABYLON.Vector4",h),(0,z.g)("BABYLON.Matrix",X);const r=X.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11753:(e,E,H)=>{function N(e,E){const H=[];for(let N=0;N<e;++N)H.push(E());return H}function u(e,E){return N(e,E)}H.d(E,{d:()=>N,e:()=>u,f:()=>P});const z=["push","splice","pop","shift","unshift"];function P(e,E){const H=z.map((H=>function(e,E,H){const N=e[E];if("function"!==typeof N)return null;const u=function(){const N=e.length,z=u.previous.apply(e,arguments);return H(E,N),z};return N.next=u,u.previous=N,e[E]=u,()=>{const H=u.previous;if(!H)return;const N=u.next;N?(H.next=N,N.previous=H):(H.next=void 0,e[E]=H),u.next=void 0,u.previous=void 0}}(e,H,E)));return()=>{for(const e of H)null===e||void 0===e||e()}}}}]);