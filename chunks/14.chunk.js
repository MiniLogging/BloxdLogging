"use strict";(self.bbj0x35f849=self.bbj0x35f849||[]).push([[14],{11129:(N,q,C)=>{C.d(q,{e:()=>a,h:()=>W,l:()=>d,m:()=>U});const d=1/2.2,U=2.2,W=(1+Math.sqrt(5))/2,a=.001},11142:(N,q,C)=>{function d(N){return parseInt(N.toString().replace(/\W/g,""))}function U(N,q){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(N-q)<=C}function W(N,q,C){let d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return N<q-d||N>C+d}function a(N,q){return N===q?N:Math.random()*(q-N)+N}function F(N,q,C){return N+(q-N)*C}function w(N,q,C){let d=v(q-N,360);return d>180&&(d-=360),N+d*V(C)}function A(N,q,C){let d=0;return d=N!=q?V((C-N)/(q-N)):0,d}function n(N,q,C,d,U){const W=U*U,a=U*W;return N*(2*a-3*W+1)+C*(-2*a+3*W)+q*(a-2*W+U)+d*(a-W)}function t(N,q,C,d,U){const W=U*U;return 6*(W-U)*N+(3*W-4*U+1)*q+6*(-W+U)*C+(3*W-2*U)*d}function V(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(q,N))}function Z(N){return N-=2*Math.PI*Math.floor((N+Math.PI)/(2*Math.PI))}function J(N){const q=N.toString(16);return N<=15?("0"+q).toUpperCase():q.toUpperCase()}function Q(N){if(Math.log2)return Math.floor(Math.log2(N));if(N<0)return NaN;if(0===N)return-1/0;let q=0;if(N<1){for(;N<1;)q++,N*=2;q=-q}else if(N>1)for(;N>1;)q++,N=Math.floor(N/2);return q}function v(N,q){return N-Math.floor(N/q)*q}function r(N,q,C){return(N-q)/(C-q)}function O(N,q,C){return N*(C-q)+q}function K(N,q){let C=v(q-N,360);return C>180&&(C-=360),C}function i(N,q){const C=v(N,2*q);return q-Math.abs(C-q)}function I(N,q,C){let d=V(C);return d=-2*d*d*d+3*d*d,q*d+N*(1-d)}function j(N,q,C){let d=0;return d=Math.abs(q-N)<=C?q:N+Math.sign(q-N)*C,d}function l(N,q,C){const d=K(N,q);let U=0;return U=-C<d&&d<C?q:j(N,q=N+d,C),U}function T(N,q,C){return(N-q)/(C-q)}function z(N,q,C){return(C-q)*N+q}function p(N,q){const C=N%q;return 0===C?q:p(q,C)}C.r(q),C.d(q,{Clamp:()=>V,DeltaAngle:()=>K,Denormalize:()=>O,ExtractAsInt:()=>d,Hermite:()=>n,Hermite1stDerivative:()=>t,HighestCommonFactor:()=>p,ILog2:()=>Q,InverseLerp:()=>A,Lerp:()=>F,LerpAngle:()=>w,MoveTowards:()=>j,MoveTowardsAngle:()=>l,Normalize:()=>r,NormalizeRadians:()=>Z,OutsideRange:()=>W,PercentToRange:()=>z,PingPong:()=>i,RandomRange:()=>a,RangeToPercent:()=>T,Repeat:()=>v,SmoothStep:()=>I,ToHex:()=>J,WithinEpsilon:()=>U})},11122:(N,q,C)=>{C.r(q),C.d(q,{Matrix:()=>O,Quaternion:()=>r,TmpVectors:()=>i,Vector2:()=>J,Jq:()=>Q,Vector4:()=>v});var d=C(11129),U=C(11134),W=C(11076),a=C(11048),F=C(10995),w=C(11142);class A{}function n(N,q,C){let d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const U=N.zd(),W=q.zd(),a=U[0],F=U[1],w=U[2],A=U[3],n=U[4],t=U[5],V=U[6],Z=U[7],J=U[8],Q=U[9],v=U[10],r=U[11],O=U[12],K=U[13],i=U[14],I=U[15],j=W[0],l=W[1],T=W[2],z=W[3],p=W[4],s=W[5],X=W[6],P=W[7],M=W[8],Y=W[9],E=W[10],H=W[11],e=W[12],b=W[13],o=W[14],S=W[15];C[d]=a*j+F*p+w*M+A*e,C[d+1]=a*l+F*s+w*Y+A*b,C[d+2]=a*T+F*X+w*E+A*o,C[d+3]=a*z+F*P+w*H+A*S,C[d+4]=n*j+t*p+V*M+Z*e,C[d+5]=n*l+t*s+V*Y+Z*b,C[d+6]=n*T+t*X+V*E+Z*o,C[d+7]=n*z+t*P+V*H+Z*S,C[d+8]=J*j+Q*p+v*M+r*e,C[d+9]=J*l+Q*s+v*Y+r*b,C[d+10]=J*T+Q*X+v*E+r*o,C[d+11]=J*z+Q*P+v*H+r*S,C[d+12]=O*j+K*p+i*M+I*e,C[d+13]=O*l+K*s+i*Y+I*b,C[d+14]=O*T+K*X+i*E+I*o,C[d+15]=O*z+K*P+i*H+I*S}function t(N,q){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const d=N.zd();q[C]=d[0],q[C+1]=d[1],q[C+2]=d[2],q[C+3]=d[3],q[C+4]=d[4],q[C+5]=d[5],q[C+6]=d[6],q[C+7]=d[7],q[C+8]=d[8],q[C+9]=d[9],q[C+10]=d[10],q[C+11]=d[11],q[C+12]=d[12],q[C+13]=d[13],q[C+14]=d[14],q[C+15]=d[15]}function V(N,q){const C=N.zd(),d=C[0],U=C[1],W=C[2],a=C[3],F=C[4],w=C[5],A=C[6],n=C[7],t=C[8],V=C[9],Z=C[10],J=C[11],Q=C[12],v=C[13],r=C[14],O=C[15],K=Z*O-r*J,i=V*O-v*J,I=V*r-v*Z,j=t*O-Q*J,l=t*r-Z*Q,T=t*v-Q*V,z=+(w*K-A*i+n*I),p=-(F*K-A*j+n*l),s=+(F*i-w*j+n*T),X=-(F*I-w*l+A*T),P=d*z+U*p+W*s+a*X;if(0===P)return!1;const M=1/P,Y=A*O-r*n,E=w*O-v*n,H=w*r-v*A,e=F*O-Q*n,b=F*r-Q*A,o=F*v-Q*w,S=A*J-Z*n,D=w*J-V*n,c=w*Z-V*A,L=F*J-t*n,G=F*Z-t*A,h=F*V-t*w,B=-(U*K-W*i+a*I),y=+(d*K-W*j+a*l),R=-(d*i-U*j+a*T),u=+(d*I-U*l+W*T),m=+(U*Y-W*E+a*H),f=-(d*Y-W*e+a*b),k=+(d*E-U*e+a*o),g=-(d*H-U*b+W*o),x=-(U*S-W*D+a*c),NN=+(d*S-W*L+a*G),qN=-(d*D-U*L+a*h),CN=+(d*c-U*G+W*h);return q[0]=z*M,q[1]=B*M,q[2]=m*M,q[3]=x*M,q[4]=p*M,q[5]=y*M,q[6]=f*M,q[7]=NN*M,q[8]=s*M,q[9]=R*M,q[10]=k*M,q[11]=qN*M,q[12]=X*M,q[13]=u*M,q[14]=g*M,q[15]=CN*M,!0}A._UpdateFlagSeed=0;const Z=N=>parseInt(N.toString().replace(/\W/g,""));class J{constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=N,this.y=q}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let N=Z(this.x);return N=397*N^Z(this.y),N}toArray(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[q]=this.x,N[q+1]=this.y,this}JC(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(N,q,this),this}zd(){return[this.x,this.y]}U(N){return this.x=N.x,this.y=N.y,this}hd(N,q){return this.x=N,this.y=q,this}set(N,q){return this.hd(N,q)}Rd(N){return this.hd(N,N)}add(N){return new J(this.x+N.x,this.y+N.y)}addToRef(N,q){return q.x=this.x+N.x,q.y=this.y+N.y,q}addInPlace(N){return this.x+=N.x,this.y+=N.y,this}addInPlaceFromFloats(N,q){return this.x+=N,this.y+=q,this}addVector3(N){return new J(this.x+N.x,this.y+N.y)}Qq(N){return new J(this.x-N.x,this.y-N.y)}subtractToRef(N,q){return q.x=this.x-N.x,q.y=this.y-N.y,q}Rn(N){return this.x-=N.x,this.y-=N.y,this}multiplyInPlace(N){return this.x*=N.x,this.y*=N.y,this}multiply(N){return new J(this.x*N.x,this.y*N.y)}multiplyToRef(N,q){return q.x=this.x*N.x,q.y=this.y*N.y,q}multiplyByFloats(N,q){return new J(this.x*N,this.y*q)}divide(N){return new J(this.x/N.x,this.y/N.y)}divideToRef(N,q){return q.x=this.x/N.x,q.y=this.y/N.y,q}divideInPlace(N){return this.x=this.x/N.x,this.y=this.y/N.y,this}minimizeInPlace(N){return this.minimizeInPlaceFromFloats(N.x,N.y)}maximizeInPlace(N){return this.maximizeInPlaceFromFloats(N.x,N.y)}minimizeInPlaceFromFloats(N,q){return this.x=Math.min(N,this.x),this.y=Math.min(q,this.y),this}maximizeInPlaceFromFloats(N,q){return this.x=Math.max(N,this.x),this.y=Math.max(q,this.y),this}subtractFromFloats(N,q){return new J(this.x-N,this.y-q)}subtractFromFloatsToRef(N,q,C){return C.x=this.x-N,C.y=this.y-q,C}negate(){return new J(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(N){return N.x=-this.x,N.y=-this.y,N}scaleInPlace(N){return this.x*=N,this.y*=N,this}scale(N){return new J(this.x*N,this.y*N)}scaleToRef(N,q){return q.x=this.x*N,q.y=this.y*N,q}scaleAndAddToRef(N,q){return q.x+=this.x*N,q.y+=this.y*N,q}equals(N){return N&&this.x===N.x&&this.y===N.y}equalsWithEpsilon(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d.e;return N&&(0,w.WithinEpsilon)(this.x,N.x,q)&&(0,w.WithinEpsilon)(this.y,N.y,q)}equalsToFloats(N,q){return this.x===N&&this.y===q}floor(){return new J(Math.floor(this.x),Math.floor(this.y))}floorToRef(N){return N.x=Math.floor(this.x),N.y=Math.floor(this.y),N}fract(){return new J(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(N){return N.x=this.x-Math.floor(this.x),N.y=this.y-Math.floor(this.y),N}rotate(N){return this.rotateToRef(N,new J)}rotateToRef(N,q){const C=Math.cos(N),d=Math.sin(N);return q.x=C*this.x-d*this.y,q.y=d*this.x+C*this.y,q}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){const N=new J;return this.normalizeToRef(N),N}normalizeToRef(N){const q=this.length();return 0===q&&(N.x=this.x,N.y=this.y),this.scaleToRef(1/q,N)}clone(){return new J(this.x,this.y)}dot(N){return this.x*N.x+this.y*N.y}static Zero(){return new J(0,0)}static One(){return new J(1,1)}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new J((0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).hd((0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q))}static get ZeroReadOnly(){return J._ZeroReadOnly}static Kq(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new J(N[q],N[q+1])}static FromArrayToRef(N,q,C){return C.x=N[q],C.y=N[q+1],C}static FromFloatsToRef(N,q,C){return C.hd(N,q),C}static CatmullRom(N,q,C,d,U){const W=U*U,a=U*W,F=.5*(2*q.x+(-N.x+C.x)*U+(2*N.x-5*q.x+4*C.x-d.x)*W+(-N.x+3*q.x-3*C.x+d.x)*a),w=.5*(2*q.y+(-N.y+C.y)*U+(2*N.y-5*q.y+4*C.y-d.y)*W+(-N.y+3*q.y-3*C.y+d.y)*a);return new J(F,w)}static ClampToRef(N,q,C,d){return d.x=(0,w.Clamp)(N.x,q.x,C.x),d.y=(0,w.Clamp)(N.y,q.y,C.y),d}static Clamp(N,q,C){const d=(0,w.Clamp)(N.x,q.x,C.x),U=(0,w.Clamp)(N.y,q.y,C.y);return new J(d,U)}static Hermite(N,q,C,d,U){const W=U*U,a=U*W,F=2*a-3*W+1,w=-2*a+3*W,A=a-2*W+U,n=a-W,t=N.x*F+C.x*w+q.x*A+d.x*n,V=N.y*F+C.y*w+q.y*A+d.y*n;return new J(t,V)}static Hermite1stDerivative(N,q,C,d,U){return this.Hermite1stDerivativeToRef(N,q,C,d,U,new J)}static Hermite1stDerivativeToRef(N,q,C,d,U,W){const a=U*U;return W.x=6*(a-U)*N.x+(3*a-4*U+1)*q.x+6*(-a+U)*C.x+(3*a-2*U)*d.x,W.y=6*(a-U)*N.y+(3*a-4*U+1)*q.y+6*(-a+U)*C.y+(3*a-2*U)*d.y,W}static Lerp(N,q,C){return J.LerpToRef(N,q,C,new J)}static LerpToRef(N,q,C,d){return d.x=N.x+(q.x-N.x)*C,d.y=N.y+(q.y-N.y)*C,d}static Dot(N,q){return N.x*q.x+N.y*q.y}static Normalize(N){return J.NormalizeToRef(N,new J)}static NormalizeToRef(N,q){return N.normalizeToRef(q),q}static Minimize(N,q){const C=N.x<q.x?N.x:q.x,d=N.y<q.y?N.y:q.y;return new J(C,d)}static Maximize(N,q){const C=N.x>q.x?N.x:q.x,d=N.y>q.y?N.y:q.y;return new J(C,d)}static Transform(N,q){return J.TransformToRef(N,q,new J)}static TransformToRef(N,q,C){const d=q.m,U=N.x*d[0]+N.y*d[4]+d[12],W=N.x*d[1]+N.y*d[5]+d[13];return C.x=U,C.y=W,C}static PointInTriangle(N,q,C,d){const U=.5*(-C.y*d.x+q.y*(-C.x+d.x)+q.x*(C.y-d.y)+C.x*d.y),W=U<0?-1:1,a=(q.y*d.x-q.x*d.y+(d.y-q.y)*N.x+(q.x-d.x)*N.y)*W,F=(q.x*C.y-q.y*C.x+(q.y-C.y)*N.x+(C.x-q.x)*N.y)*W;return a>0&&F>0&&a+F<2*U*W}static Distance(N,q){return Math.sqrt(J.DistanceSquared(N,q))}static DistanceSquared(N,q){const C=N.x-q.x,d=N.y-q.y;return C*C+d*d}static Center(N,q){return J.CenterToRef(N,q,new J)}static CenterToRef(N,q,C){return C.hd((N.x+q.x)/2,(N.y+q.y)/2)}static DistanceOfPointFromSegment(N,q,C){const d=J.DistanceSquared(q,C);if(0===d)return J.Distance(N,q);const U=C.Qq(q),W=Math.max(0,Math.min(1,J.Dot(N.Qq(q),U)/d)),a=q.add(U.multiplyByFloats(W,W));return J.Distance(N,a)}}J._V8PerformanceHack=new J(.5,.5),J._ZeroReadOnly=J.Zero(),Object.defineProperties(J.prototype,{dimension:{value:[2]},rank:{value:1}});class Q{get x(){return this._x}set x(N){this._x=N,this._isDirty=!0}get y(){return this._y}set y(N){this._y=N,this._isDirty=!0}get z(){return this._z}set z(N){this._z=N,this._isDirty=!0}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=N,this._y=q,this._z=C}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Jq"}getHashCode(){let N=Z(this._x);return N=397*N^Z(this._y),N=397*N^Z(this._z),N}zd(){return[this._x,this._y,this._z]}toArray(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[q]=this._x,N[q+1]=this._y,N[q+2]=this._z,this}JC(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(N,q,this),this}toQuaternion(){return r.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(N){return this._x+=N._x,this._y+=N._y,this._z+=N._z,this._isDirty=!0,this}addInPlaceFromFloats(N,q,C){return this._x+=N,this._y+=q,this._z+=C,this._isDirty=!0,this}add(N){return new Q(this._x+N._x,this._y+N._y,this._z+N._z)}addToRef(N,q){return q._x=this._x+N._x,q._y=this._y+N._y,q._z=this._z+N._z,q._isDirty=!0,q}Rn(N){return this._x-=N._x,this._y-=N._y,this._z-=N._z,this._isDirty=!0,this}Qq(N){return new Q(this._x-N._x,this._y-N._y,this._z-N._z)}subtractToRef(N,q){return this.subtractFromFloatsToRef(N._x,N._y,N._z,q)}subtractFromFloats(N,q,C){return new Q(this._x-N,this._y-q,this._z-C)}subtractFromFloatsToRef(N,q,C,d){return d._x=this._x-N,d._y=this._y-q,d._z=this._z-C,d._isDirty=!0,d}negate(){return new Q(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(N){return N._x=-1*this._x,N._y=-1*this._y,N._z=-1*this._z,N._isDirty=!0,N}scaleInPlace(N){return this._x*=N,this._y*=N,this._z*=N,this._isDirty=!0,this}scale(N){return new Q(this._x*N,this._y*N,this._z*N)}scaleToRef(N,q){return q._x=this._x*N,q._y=this._y*N,q._z=this._z*N,q._isDirty=!0,q}getNormalToRef(N){const q=this.length();let C=Math.acos(this._y/q);const d=Math.atan2(this._z,this._x);C>Math.PI/2?C-=Math.PI/2:C+=Math.PI/2;const U=q*Math.sin(C)*Math.cos(d),W=q*Math.cos(C),a=q*Math.sin(C)*Math.sin(d);return N.set(U,W,a),N}applyRotationQuaternionToRef(N,q){const C=this._x,d=this._y,U=this._z,W=N._x,a=N._y,F=N._z,w=N._w,A=2*(a*U-F*d),n=2*(F*C-W*U),t=2*(W*d-a*C);return q._x=C+w*A+a*t-F*n,q._y=d+w*n+F*A-W*t,q._z=U+w*t+W*n-a*A,q._isDirty=!0,q}applyRotationQuaternionInPlace(N){return this.applyRotationQuaternionToRef(N,this)}applyRotationQuaternion(N){return this.applyRotationQuaternionToRef(N,new Q)}scaleAndAddToRef(N,q){return q._x+=this._x*N,q._y+=this._y*N,q._z+=this._z*N,q._isDirty=!0,q}projectOnPlane(N,q){return this.projectOnPlaneToRef(N,q,new Q)}projectOnPlaneToRef(N,q,C){const d=N.normal,U=N.d,W=K.Jq[0];this.subtractToRef(q,W),W.normalize();const a=Q.Dot(W,d);if(Math.abs(a)<1e-10)C.Rd(1/0);else{const N=-(Q.Dot(q,d)+U)/a,F=W.scaleInPlace(N);q.addToRef(F,C)}return C}equals(N){return N&&this._x===N._x&&this._y===N._y&&this._z===N._z}equalsWithEpsilon(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d.e;return N&&(0,w.WithinEpsilon)(this._x,N._x,q)&&(0,w.WithinEpsilon)(this._y,N._y,q)&&(0,w.WithinEpsilon)(this._z,N._z,q)}equalsToFloats(N,q,C){return this._x===N&&this._y===q&&this._z===C}multiplyInPlace(N){return this._x*=N._x,this._y*=N._y,this._z*=N._z,this._isDirty=!0,this}multiply(N){return this.multiplyByFloats(N._x,N._y,N._z)}multiplyToRef(N,q){return q._x=this._x*N._x,q._y=this._y*N._y,q._z=this._z*N._z,q._isDirty=!0,q}multiplyByFloats(N,q,C){return new Q(this._x*N,this._y*q,this._z*C)}divide(N){return new Q(this._x/N._x,this._y/N._y,this._z/N._z)}divideToRef(N,q){return q._x=this._x/N._x,q._y=this._y/N._y,q._z=this._z/N._z,q._isDirty=!0,q}divideInPlace(N){return this._x=this._x/N._x,this._y=this._y/N._y,this._z=this._z/N._z,this._isDirty=!0,this}minimizeInPlace(N){return this.minimizeInPlaceFromFloats(N._x,N._y,N._z)}maximizeInPlace(N){return this.maximizeInPlaceFromFloats(N._x,N._y,N._z)}minimizeInPlaceFromFloats(N,q,C){return N<this._x&&(this.x=N),q<this._y&&(this.y=q),C<this._z&&(this.z=C),this}maximizeInPlaceFromFloats(N,q,C){return N>this._x&&(this.x=N),q>this._y&&(this.y=q),C>this._z&&(this.z=C),this}isNonUniformWithinEpsilon(N){const q=Math.abs(this._x),C=Math.abs(this._y);if(!(0,w.WithinEpsilon)(q,C,N))return!0;const d=Math.abs(this._z);return!(0,w.WithinEpsilon)(q,d,N)||!(0,w.WithinEpsilon)(C,d,N)}get isNonUniform(){const N=Math.abs(this._x);if(N!==Math.abs(this._y))return!0;return N!==Math.abs(this._z)}floorToRef(N){return N._x=Math.floor(this._x),N._y=Math.floor(this._y),N._z=Math.floor(this._z),N._isDirty=!0,N}floor(){return new Q(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(N){return N._x=this._x-Math.floor(this._x),N._y=this._y-Math.floor(this._y),N._z=this._z-Math.floor(this._z),N._isDirty=!0,N}fract(){return new Q(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(N){if("xyz"===(N=N.toLowerCase()))return this;const q=K.Jq[0].U(this);return this.x=q[N[0]],this.y=q[N[1]],this.z=q[N[2]],this}rotateByQuaternionToRef(N,q){return N.toRotationMatrix(K.Matrix[0]),Q.TransformCoordinatesToRef(this,K.Matrix[0],q),q}rotateByQuaternionAroundPointToRef(N,q,C){return this.subtractToRef(q,K.Jq[0]),K.Jq[0].rotateByQuaternionToRef(N,K.Jq[0]),q.addToRef(K.Jq[0],C),C}cross(N){return Q.CrossToRef(this,N,new Q)}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){return this.normalizeToRef(new Q)}normalizeToRef(N){const q=this.length();return 0===q||1===q?(N._x=this._x,N._y=this._y,N._z=this._z,N._isDirty=!0,N):this.scaleToRef(1/q,N)}clone(){return new Q(this._x,this._y,this._z)}U(N){return this.hd(N._x,N._y,N._z)}hd(N,q,C){return this._x=N,this._y=q,this._z=C,this._isDirty=!0,this}set(N,q,C){return this.hd(N,q,C)}Rd(N){return this._x=this._y=this._z=N,this._isDirty=!0,this}static GetClipFactor(N,q,C,d){const U=Q.Dot(N,C);return(U-d)/(U-Q.Dot(q,C))}static GetAngleBetweenVectors(N,q,C){const d=N.normalizeToRef(K.Jq[1]),U=q.normalizeToRef(K.Jq[2]);let W=Q.Dot(d,U);W=(0,w.Clamp)(W,-1,1);const a=Math.acos(W),F=K.Jq[3];return Q.CrossToRef(d,U,F),Q.Dot(F,C)>0?isNaN(a)?0:a:isNaN(a)?-Math.PI:-Math.acos(W)}static GetAngleBetweenVectorsOnPlane(N,q,C){K.Jq[0].U(N);const d=K.Jq[0];K.Jq[1].U(q);const U=K.Jq[1];K.Jq[2].U(C);const W=K.Jq[2],a=K.Jq[3],F=K.Jq[4];d.normalize(),U.normalize(),W.normalize(),Q.CrossToRef(W,d,a),Q.CrossToRef(a,W,F);const A=Math.atan2(Q.Dot(U,a),Q.Dot(U,F));return(0,w.NormalizeRadians)(A)}static PitchYawRollToMoveBetweenPointsToRef(N,q,C){const d=i.Jq[0];return q.subtractToRef(N,d),C._y=Math.atan2(d.x,d.z)||0,C._x=Math.atan2(Math.sqrt(d.x**2+d.z**2),d.y)||0,C._z=0,C._isDirty=!0,C}static PitchYawRollToMoveBetweenPoints(N,q){const C=Q.Zero();return Q.PitchYawRollToMoveBetweenPointsToRef(N,q,C)}static SlerpToRef(N,q,C,U){C=(0,w.Clamp)(C,0,1);const W=K.Jq[0],a=K.Jq[1];W.U(N);const F=W.length();W.normalizeFromLength(F),a.U(q);const A=a.length();a.normalizeFromLength(A);const n=Q.Dot(W,a);let t,V;if(n<1-d.e){const N=Math.acos(n),q=1/Math.sin(N);t=Math.sin((1-C)*N)*q,V=Math.sin(C*N)*q}else t=1-C,V=C;return W.scaleInPlace(t),a.scaleInPlace(V),U.U(W).addInPlace(a),U.scaleInPlace((0,w.Lerp)(F,A,C)),U}static SmoothToRef(N,q,C,d,U){return Q.SlerpToRef(N,q,0===d?1:C/d,U),U}static Kq(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Q(N[q],N[q+1],N[q+2])}static FromFloatArray(N,q){return Q.Kq(N,q)}static FromArrayToRef(N,q,C){return C._x=N[q],C._y=N[q+1],C._z=N[q+2],C._isDirty=!0,C}static FromFloatArrayToRef(N,q,C){return Q.FromArrayToRef(N,q,C)}static FromFloatsToRef(N,q,C,d){return d.hd(N,q,C),d}static Zero(){return new Q(0,0,0)}static One(){return new Q(1,1,1)}static Up(){return new Q(0,1,0)}static get UpReadOnly(){return Q._UpReadOnly}static get DownReadOnly(){return Q._DownReadOnly}static get RightReadOnly(){return Q._RightReadOnly}static get LeftReadOnly(){return Q._LeftReadOnly}static get LeftHandedForwardReadOnly(){return Q._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return Q._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return Q._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return Q._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return Q._ZeroReadOnly}static get OneReadOnly(){return Q._OneReadOnly}static Down(){return new Q(0,-1,0)}static Forward(){return new Q(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new Q(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new Q(1,0,0)}static Left(){return new Q(-1,0,0)}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Q((0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).hd((0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q))}static TransformCoordinates(N,q){const C=Q.Zero();return Q.TransformCoordinatesToRef(N,q,C),C}static TransformCoordinatesToRef(N,q,C){return Q.TransformCoordinatesFromFloatsToRef(N._x,N._y,N._z,q,C),C}static TransformCoordinatesFromFloatsToRef(N,q,C,d,U){const W=d.m,a=N*W[0]+q*W[4]+C*W[8]+W[12],F=N*W[1]+q*W[5]+C*W[9]+W[13],w=N*W[2]+q*W[6]+C*W[10]+W[14],A=1/(N*W[3]+q*W[7]+C*W[11]+W[15]);return U._x=a*A,U._y=F*A,U._z=w*A,U._isDirty=!0,U}static TransformNormal(N,q){const C=Q.Zero();return Q.TransformNormalToRef(N,q,C),C}static TransformNormalToRef(N,q,C){return this.TransformNormalFromFloatsToRef(N._x,N._y,N._z,q,C),C}static TransformNormalFromFloatsToRef(N,q,C,d,U){const W=d.m;return U._x=N*W[0]+q*W[4]+C*W[8],U._y=N*W[1]+q*W[5]+C*W[9],U._z=N*W[2]+q*W[6]+C*W[10],U._isDirty=!0,U}static CatmullRom(N,q,C,d,U){const W=U*U,a=U*W,F=.5*(2*q._x+(-N._x+C._x)*U+(2*N._x-5*q._x+4*C._x-d._x)*W+(-N._x+3*q._x-3*C._x+d._x)*a),w=.5*(2*q._y+(-N._y+C._y)*U+(2*N._y-5*q._y+4*C._y-d._y)*W+(-N._y+3*q._y-3*C._y+d._y)*a),A=.5*(2*q._z+(-N._z+C._z)*U+(2*N._z-5*q._z+4*C._z-d._z)*W+(-N._z+3*q._z-3*C._z+d._z)*a);return new Q(F,w,A)}static Clamp(N,q,C){const d=new Q;return Q.ClampToRef(N,q,C,d),d}static ClampToRef(N,q,C,d){let U=N._x;U=U>C._x?C._x:U,U=U<q._x?q._x:U;let W=N._y;W=W>C._y?C._y:W,W=W<q._y?q._y:W;let a=N._z;return a=a>C._z?C._z:a,a=a<q._z?q._z:a,d.hd(U,W,a),d}static CheckExtends(N,q,C){q.minimizeInPlace(N),C.maximizeInPlace(N)}static Hermite(N,q,C,d,U){const W=U*U,a=U*W,F=2*a-3*W+1,w=-2*a+3*W,A=a-2*W+U,n=a-W,t=N._x*F+C._x*w+q._x*A+d._x*n,V=N._y*F+C._y*w+q._y*A+d._y*n,Z=N._z*F+C._z*w+q._z*A+d._z*n;return new Q(t,V,Z)}static Hermite1stDerivative(N,q,C,d,U){const W=new Q;return this.Hermite1stDerivativeToRef(N,q,C,d,U,W),W}static Hermite1stDerivativeToRef(N,q,C,d,U,W){const a=U*U;return W._x=6*(a-U)*N._x+(3*a-4*U+1)*q._x+6*(-a+U)*C._x+(3*a-2*U)*d._x,W._y=6*(a-U)*N._y+(3*a-4*U+1)*q._y+6*(-a+U)*C._y+(3*a-2*U)*d._y,W._z=6*(a-U)*N._z+(3*a-4*U+1)*q._z+6*(-a+U)*C._z+(3*a-2*U)*d._z,W._isDirty=!0,W}static Lerp(N,q,C){const d=new Q(0,0,0);return Q.LerpToRef(N,q,C,d),d}static LerpToRef(N,q,C,d){return d._x=N._x+(q._x-N._x)*C,d._y=N._y+(q._y-N._y)*C,d._z=N._z+(q._z-N._z)*C,d._isDirty=!0,d}static Dot(N,q){return N._x*q._x+N._y*q._y+N._z*q._z}dot(N){return this._x*N._x+this._y*N._y+this._z*N._z}static Cross(N,q){const C=new Q;return Q.CrossToRef(N,q,C),C}static CrossToRef(N,q,C){const d=N._y*q._z-N._z*q._y,U=N._z*q._x-N._x*q._z,W=N._x*q._y-N._y*q._x;return C.hd(d,U,W),C}static Normalize(N){const q=Q.Zero();return Q.NormalizeToRef(N,q),q}static NormalizeToRef(N,q){return N.normalizeToRef(q),q}static Project(N,q,C,d){const U=new Q;return Q.ProjectToRef(N,q,C,d,U),U}static ProjectToRef(N,q,C,d,U){var W;const a=d.width,w=d.height,A=d.x,n=d.y,t=K.Matrix[1],V=null===(W=F.e.LastCreatedEngine)||void 0===W?void 0:W.isNDCHalfZRange,Z=V?1:.5,J=V?0:.5;O.FromValuesToRef(a/2,0,0,0,0,-w/2,0,0,0,0,Z,0,A+a/2,w/2+n,J,1,t);const v=K.Matrix[0];return q.multiplyToRef(C,v),v.multiplyToRef(t,v),Q.TransformCoordinatesToRef(N,v,U),U}static Reflect(N,q){return this.ReflectToRef(N,q,new Q)}static ReflectToRef(N,q,C){const d=i.Jq[0];return d.U(q).scaleInPlace(2*Q.Dot(N,q)),C.U(N).Rn(d)}static _UnprojectFromInvertedMatrixToRef(N,q,C){Q.TransformCoordinatesToRef(N,q,C);const d=q.m,U=N._x*d[3]+N._y*d[7]+N._z*d[11]+d[15];return(0,w.WithinEpsilon)(U,1)&&C.scaleInPlace(1/U),C}static UnprojectFromTransform(N,q,C,d,U){return this.Unproject(N,q,C,d,U,O.IdentityReadOnly)}static Unproject(N,q,C,d,U,W){const a=new Q;return Q.UnprojectToRef(N,q,C,d,U,W,a),a}static UnprojectToRef(N,q,C,d,U,W,a){return Q.UnprojectFloatsToRef(N._x,N._y,N._z,q,C,d,U,W,a),a}static UnprojectFloatsToRef(N,q,C,d,U,W,a,w,A){var n;const t=K.Matrix[0];W.multiplyToRef(a,t),t.multiplyToRef(w,t),t.invert();const V=K.Jq[0];return V.x=N/d*2-1,V.y=-(q/U*2-1),null!==(n=F.e.LastCreatedEngine)&&void 0!==n&&n.isNDCHalfZRange?V.z=C:V.z=2*C-1,Q._UnprojectFromInvertedMatrixToRef(V,t,A),A}static Minimize(N,q){const C=new Q;return C.U(N),C.minimizeInPlace(q),C}static Maximize(N,q){const C=new Q;return C.U(N),C.maximizeInPlace(q),C}static Distance(N,q){return Math.sqrt(Q.DistanceSquared(N,q))}static DistanceSquared(N,q){const C=N._x-q._x,d=N._y-q._y,U=N._z-q._z;return C*C+d*d+U*U}static ProjectOnTriangleToRef(N,q,C,U,W){const a=K.Jq[0],F=K.Jq[1],A=K.Jq[2],n=K.Jq[3],t=K.Jq[4];C.subtractToRef(q,a),U.subtractToRef(q,F),U.subtractToRef(C,A);const V=a.length(),Z=F.length(),J=A.length();if(V<d.e||Z<d.e||J<d.e)return W.U(q),Q.Distance(N,q);N.subtractToRef(q,t),Q.CrossToRef(a,F,n);const v=n.length();if(v<d.e)return W.U(q),Q.Distance(N,q);n.normalizeFromLength(v);let r=t.length();if(r<d.e)return W.U(q),0;t.normalizeFromLength(r);const O=Q.Dot(n,t),i=K.Jq[5],I=K.Jq[6];i.U(n).scaleInPlace(-r*O),I.U(N).addInPlace(i);const j=K.Jq[4],l=K.Jq[5],T=K.Jq[7],z=K.Jq[8];j.U(a).scaleInPlace(1/V),z.U(F).scaleInPlace(1/Z),j.addInPlace(z).scaleInPlace(-1),l.U(a).scaleInPlace(-1/V),z.U(A).scaleInPlace(1/J),l.addInPlace(z).scaleInPlace(-1),T.U(A).scaleInPlace(-1/J),z.U(F).scaleInPlace(-1/Z),T.addInPlace(z).scaleInPlace(-1);const p=K.Jq[9];let s;p.U(I).Rn(q),Q.CrossToRef(j,p,z),s=Q.Dot(z,n);const X=s;p.U(I).Rn(C),Q.CrossToRef(l,p,z),s=Q.Dot(z,n);const P=s;p.U(I).Rn(U),Q.CrossToRef(T,p,z),s=Q.Dot(z,n);const M=s,Y=K.Jq[10];let E,H;X>0&&P<0?(Y.U(a),E=q,H=C):P>0&&M<0?(Y.U(A),E=C,H=U):(Y.U(F).scaleInPlace(-1),E=U,H=q);const e=K.Jq[9],b=K.Jq[4];E.subtractToRef(I,z),H.subtractToRef(I,e),Q.CrossToRef(z,e,b);if(!(Q.Dot(b,n)<0))return W.U(I),Math.abs(r*O);const o=K.Jq[5];Q.CrossToRef(Y,b,o),o.normalize();const S=K.Jq[9];S.U(E).Rn(I);const D=S.length();if(D<d.e)return W.U(E),Q.Distance(N,E);S.normalizeFromLength(D);const c=Q.Dot(o,S),L=K.Jq[7];L.U(I).addInPlace(o.scaleInPlace(D*c)),z.U(L).Rn(E),r=Y.length(),Y.normalizeFromLength(r);let G=Q.Dot(z,Y)/Math.max(r,d.e);return G=(0,w.Clamp)(G,0,1),L.U(E).addInPlace(Y.scaleInPlace(G*r)),W.U(L),Q.Distance(N,L)}static Center(N,q){return Q.CenterToRef(N,q,Q.Zero())}static CenterToRef(N,q,C){return C.hd((N._x+q._x)/2,(N._y+q._y)/2,(N._z+q._z)/2)}static RotationFromAxis(N,q,C){const d=new Q;return Q.RotationFromAxisToRef(N,q,C,d),d}static RotationFromAxisToRef(N,q,C,d){const U=K.Quaternion[0];return r.RotationQuaternionFromAxisToRef(N,q,C,U),U.toEulerAnglesToRef(d),d}}Q._V8PerformanceHack=new Q(.5,.5,.5),Q._UpReadOnly=Q.Up(),Q._DownReadOnly=Q.Down(),Q._LeftHandedForwardReadOnly=Q.Forward(!1),Q._RightHandedForwardReadOnly=Q.Forward(!0),Q._LeftHandedBackwardReadOnly=Q.Backward(!1),Q._RightHandedBackwardReadOnly=Q.Backward(!0),Q._RightReadOnly=Q.Right(),Q._LeftReadOnly=Q.Left(),Q._ZeroReadOnly=Q.Zero(),Q._OneReadOnly=Q.One(),Object.defineProperties(Q.prototype,{dimension:{value:[3]},rank:{value:1}});class v{get x(){return this._x}set x(N){this._x=N,this._isDirty=!0}get y(){return this._y}set y(N){this._y=N,this._isDirty=!0}get z(){return this._z}set z(N){this._z=N,this._isDirty=!0}get w(){return this._w}set w(N){this._w=N,this._isDirty=!0}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=N,this._y=q,this._z=C,this._w=d}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let N=Z(this._x);return N=397*N^Z(this._y),N=397*N^Z(this._z),N=397*N^Z(this._w),N}zd(){return[this._x,this._y,this._z,this._w]}toArray(N,q){return void 0===q&&(q=0),N[q]=this._x,N[q+1]=this._y,N[q+2]=this._z,N[q+3]=this._w,this}JC(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return v.FromArrayToRef(N,q,this),this}addInPlace(N){return this.x+=N._x,this.y+=N._y,this.z+=N._z,this.w+=N._w,this}addInPlaceFromFloats(N,q,C,d){return this.x+=N,this.y+=q,this.z+=C,this.w+=d,this}add(N){return new v(this._x+N.x,this._y+N.y,this._z+N.z,this._w+N.w)}addToRef(N,q){return q.x=this._x+N.x,q.y=this._y+N.y,q.z=this._z+N.z,q.w=this._w+N.w,q}Rn(N){return this.x-=N.x,this.y-=N.y,this.z-=N.z,this.w-=N.w,this}Qq(N){return new v(this._x-N.x,this._y-N.y,this._z-N.z,this._w-N.w)}subtractToRef(N,q){return q.x=this._x-N.x,q.y=this._y-N.y,q.z=this._z-N.z,q.w=this._w-N.w,q}subtractFromFloats(N,q,C,d){return new v(this._x-N,this._y-q,this._z-C,this._w-d)}subtractFromFloatsToRef(N,q,C,d,U){return U.x=this._x-N,U.y=this._y-q,U.z=this._z-C,U.w=this._w-d,U}negate(){return new v(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(N){return N.x=-this._x,N.y=-this._y,N.z=-this._z,N.w=-this._w,N}scaleInPlace(N){return this.x*=N,this.y*=N,this.z*=N,this.w*=N,this}scale(N){return new v(this._x*N,this._y*N,this._z*N,this._w*N)}scaleToRef(N,q){return q.x=this._x*N,q.y=this._y*N,q.z=this._z*N,q.w=this._w*N,q}scaleAndAddToRef(N,q){return q.x+=this._x*N,q.y+=this._y*N,q.z+=this._z*N,q.w+=this._w*N,q}equals(N){return N&&this._x===N.x&&this._y===N.y&&this._z===N.z&&this._w===N.w}equalsWithEpsilon(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d.e;return N&&(0,w.WithinEpsilon)(this._x,N.x,q)&&(0,w.WithinEpsilon)(this._y,N.y,q)&&(0,w.WithinEpsilon)(this._z,N.z,q)&&(0,w.WithinEpsilon)(this._w,N.w,q)}equalsToFloats(N,q,C,d){return this._x===N&&this._y===q&&this._z===C&&this._w===d}multiplyInPlace(N){return this.x*=N.x,this.y*=N.y,this.z*=N.z,this.w*=N.w,this}multiply(N){return new v(this._x*N.x,this._y*N.y,this._z*N.z,this._w*N.w)}multiplyToRef(N,q){return q.x=this._x*N.x,q.y=this._y*N.y,q.z=this._z*N.z,q.w=this._w*N.w,q}multiplyByFloats(N,q,C,d){return new v(this._x*N,this._y*q,this._z*C,this._w*d)}divide(N){return new v(this._x/N.x,this._y/N.y,this._z/N.z,this._w/N.w)}divideToRef(N,q){return q.x=this._x/N.x,q.y=this._y/N.y,q.z=this._z/N.z,q.w=this._w/N.w,q}divideInPlace(N){return this.divideToRef(N,this)}minimizeInPlace(N){return N.x<this._x&&(this.x=N.x),N.y<this._y&&(this.y=N.y),N.z<this._z&&(this.z=N.z),N.w<this._w&&(this.w=N.w),this}maximizeInPlace(N){return N.x>this._x&&(this.x=N.x),N.y>this._y&&(this.y=N.y),N.z>this._z&&(this.z=N.z),N.w>this._w&&(this.w=N.w),this}minimizeInPlaceFromFloats(N,q,C,d){return this.x=Math.min(N,this._x),this.y=Math.min(q,this._y),this.z=Math.min(C,this._z),this.w=Math.min(d,this._w),this}maximizeInPlaceFromFloats(N,q,C,d){return this.x=Math.max(N,this._x),this.y=Math.max(q,this._y),this.z=Math.max(C,this._z),this.w=Math.max(d,this._w),this}floorToRef(N){return N.x=Math.floor(this._x),N.y=Math.floor(this._y),N.z=Math.floor(this._z),N.w=Math.floor(this._w),N}floor(){return new v(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(N){return N.x=this._x-Math.floor(this._x),N.y=this._y-Math.floor(this._y),N.z=this._z-Math.floor(this._z),N.w=this._w-Math.floor(this._w),N}fract(){return new v(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){return this.normalizeToRef(new v)}normalizeToRef(N){const q=this.length();return 0===q||1===q?(N.x=this._x,N.y=this._y,N.z=this._z,N.w=this._w,N):this.scaleToRef(1/q,N)}toVector3(){return new Q(this._x,this._y,this._z)}clone(){return new v(this._x,this._y,this._z,this._w)}U(N){return this.x=N.x,this.y=N.y,this.z=N.z,this.w=N.w,this}hd(N,q,C,d){return this.x=N,this.y=q,this.z=C,this.w=d,this}set(N,q,C,d){return this.hd(N,q,C,d)}Rd(N){return this.x=this.y=this.z=this.w=N,this}dot(N){return this._x*N.x+this._y*N.y+this._z*N.z+this._w*N.w}static Kq(N,q){return q||(q=0),new v(N[q],N[q+1],N[q+2],N[q+3])}static FromArrayToRef(N,q,C){return C.x=N[q],C.y=N[q+1],C.z=N[q+2],C.w=N[q+3],C}static FromFloatArrayToRef(N,q,C){return v.FromArrayToRef(N,q,C),C}static FromFloatsToRef(N,q,C,d,U){return U.x=N,U.y=q,U.z=C,U.w=d,U}static Zero(){return new v(0,0,0,0)}static One(){return new v(1,1,1,1)}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new v((0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.x=(0,w.RandomRange)(N,q),C.y=(0,w.RandomRange)(N,q),C.z=(0,w.RandomRange)(N,q),C.w=(0,w.RandomRange)(N,q),C}static Clamp(N,q,C){return v.ClampToRef(N,q,C,new v)}static ClampToRef(N,q,C,d){return d.x=(0,w.Clamp)(N.x,q.x,C.x),d.y=(0,w.Clamp)(N.y,q.y,C.y),d.z=(0,w.Clamp)(N.z,q.z,C.z),d.w=(0,w.Clamp)(N.w,q.w,C.w),d}static CheckExtends(N,q,C){q.minimizeInPlace(N),C.maximizeInPlace(N)}static get ZeroReadOnly(){return v._ZeroReadOnly}static Normalize(N){return v.NormalizeToRef(N,new v)}static NormalizeToRef(N,q){return N.normalizeToRef(q),q}static Minimize(N,q){const C=new v;return C.U(N),C.minimizeInPlace(q),C}static Maximize(N,q){const C=new v;return C.U(N),C.maximizeInPlace(q),C}static Distance(N,q){return Math.sqrt(v.DistanceSquared(N,q))}static DistanceSquared(N,q){const C=N.x-q.x,d=N.y-q.y,U=N.z-q.z,W=N.w-q.w;return C*C+d*d+U*U+W*W}static Center(N,q){return v.CenterToRef(N,q,new v)}static CenterToRef(N,q,C){return C.x=(N.x+q.x)/2,C.y=(N.y+q.y)/2,C.z=(N.z+q.z)/2,C.w=(N.w+q.w)/2,C}static TransformCoordinates(N,q){return v.TransformCoordinatesToRef(N,q,new v)}static TransformCoordinatesToRef(N,q,C){return v.TransformCoordinatesFromFloatsToRef(N._x,N._y,N._z,q,C),C}static TransformCoordinatesFromFloatsToRef(N,q,C,d,U){const W=d.m,a=N*W[0]+q*W[4]+C*W[8]+W[12],F=N*W[1]+q*W[5]+C*W[9]+W[13],w=N*W[2]+q*W[6]+C*W[10]+W[14],A=N*W[3]+q*W[7]+C*W[11]+W[15];return U.x=a,U.y=F,U.z=w,U.w=A,U}static TransformNormal(N,q){return v.TransformNormalToRef(N,q,new v)}static TransformNormalToRef(N,q,C){const d=q.m,U=N.x*d[0]+N.y*d[4]+N.z*d[8],W=N.x*d[1]+N.y*d[5]+N.z*d[9],a=N.x*d[2]+N.y*d[6]+N.z*d[10];return C.x=U,C.y=W,C.z=a,C.w=N.w,C}static TransformNormalFromFloatsToRef(N,q,C,d,U,W){const a=U.m;return W.x=N*a[0]+q*a[4]+C*a[8],W.y=N*a[1]+q*a[5]+C*a[9],W.z=N*a[2]+q*a[6]+C*a[10],W.w=d,W}static FromVector3(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new v(N._x,N._y,N._z,q)}static Dot(N,q){return N.x*q.x+N.y*q.y+N.z*q.z+N.w*q.w}}v._V8PerformanceHack=new v(.5,.5,.5,.5),v._ZeroReadOnly=v.Zero(),Object.defineProperties(v.prototype,{dimension:{value:[4]},rank:{value:1}});class r{get x(){return this._x}set x(N){this._x=N,this._isDirty=!0}get y(){return this._y}set y(N){this._y=N,this._isDirty=!0}get z(){return this._z}set z(N){this._z=N,this._isDirty=!0}get w(){return this._w}set w(N){this._w=N,this._isDirty=!0}constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=N,this._y=q,this._z=C,this._w=d}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let N=Z(this._x);return N=397*N^Z(this._y),N=397*N^Z(this._z),N=397*N^Z(this._w),N}zd(){return[this._x,this._y,this._z,this._w]}toArray(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[q]=this._x,N[q+1]=this._y,N[q+2]=this._z,N[q+3]=this._w,this}JC(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r.FromArrayToRef(N,q,this)}equals(N){return N&&this._x===N._x&&this._y===N._y&&this._z===N._z&&this._w===N._w}equalsWithEpsilon(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d.e;return N&&(0,w.WithinEpsilon)(this._x,N._x,q)&&(0,w.WithinEpsilon)(this._y,N._y,q)&&(0,w.WithinEpsilon)(this._z,N._z,q)&&(0,w.WithinEpsilon)(this._w,N._w,q)}isApprox(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d.e;return N&&((0,w.WithinEpsilon)(this._x,N._x,q)&&(0,w.WithinEpsilon)(this._y,N._y,q)&&(0,w.WithinEpsilon)(this._z,N._z,q)&&(0,w.WithinEpsilon)(this._w,N._w,q)||(0,w.WithinEpsilon)(this._x,-N._x,q)&&(0,w.WithinEpsilon)(this._y,-N._y,q)&&(0,w.WithinEpsilon)(this._z,-N._z,q)&&(0,w.WithinEpsilon)(this._w,-N._w,q))}clone(){return new r(this._x,this._y,this._z,this._w)}U(N){return this._x=N._x,this._y=N._y,this._z=N._z,this._w=N._w,this._isDirty=!0,this}hd(N,q,C,d){return this._x=N,this._y=q,this._z=C,this._w=d,this._isDirty=!0,this}set(N,q,C,d){return this.hd(N,q,C,d)}Rd(N){return this.hd(N,N,N,N)}add(N){return new r(this._x+N._x,this._y+N._y,this._z+N._z,this._w+N._w)}addInPlace(N){return this._x+=N._x,this._y+=N._y,this._z+=N._z,this._w+=N._w,this._isDirty=!0,this}addToRef(N,q){return q._x=this._x+N._x,q._y=this._y+N._y,q._z=this._z+N._z,q._w=this._w+N._w,q._isDirty=!0,q}addInPlaceFromFloats(N,q,C,d){return this._x+=N,this._y+=q,this._z+=C,this._w+=d,this._isDirty=!0,this}subtractToRef(N,q){return q._x=this._x-N._x,q._y=this._y-N._y,q._z=this._z-N._z,q._w=this._w-N._w,q._isDirty=!0,q}subtractFromFloats(N,q,C,d){return this.subtractFromFloatsToRef(N,q,C,d,new r)}subtractFromFloatsToRef(N,q,C,d,U){return U._x=this._x-N,U._y=this._y-q,U._z=this._z-C,U._w=this._w-d,U._isDirty=!0,U}Qq(N){return new r(this._x-N._x,this._y-N._y,this._z-N._z,this._w-N._w)}Rn(N){return this._x-=N._x,this._y-=N._y,this._z-=N._z,this._w-=N._w,this._isDirty=!0,this}scale(N){return new r(this._x*N,this._y*N,this._z*N,this._w*N)}scaleToRef(N,q){return q._x=this._x*N,q._y=this._y*N,q._z=this._z*N,q._w=this._w*N,q._isDirty=!0,q}scaleInPlace(N){return this._x*=N,this._y*=N,this._z*=N,this._w*=N,this._isDirty=!0,this}scaleAndAddToRef(N,q){return q._x+=this._x*N,q._y+=this._y*N,q._z+=this._z*N,q._w+=this._w*N,q._isDirty=!0,q}multiply(N){const q=new r(0,0,0,1);return this.multiplyToRef(N,q),q}multiplyToRef(N,q){const C=this._x*N._w+this._y*N._z-this._z*N._y+this._w*N._x,d=-this._x*N._z+this._y*N._w+this._z*N._x+this._w*N._y,U=this._x*N._y-this._y*N._x+this._z*N._w+this._w*N._z,W=-this._x*N._x-this._y*N._y-this._z*N._z+this._w*N._w;return q.hd(C,d,U,W),q}multiplyInPlace(N){return this.multiplyToRef(N,this)}multiplyByFloats(N,q,C,d){return this._x*=N,this._y*=q,this._z*=C,this._w*=d,this._isDirty=!0,this}divide(N){throw new ReferenceError("Can not divide a quaternion")}divideToRef(N,q){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(N){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new r)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(N){return N._x=-this._x,N._y=-this._y,N._z=-this._z,N._w=-this._w,N._isDirty=!0,N}equalsToFloats(N,q,C,d){return this._x===N&&this._y===q&&this._z===C&&this._w===d}floorToRef(N){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(N){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(N){return N.hd(-this._x,-this._y,-this._z,this._w),N}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new r(-this._x,-this._y,-this._z,this._w)}invert(){const N=this.conjugate(),q=this.lengthSquared();return 0==q||1==q||N.scaleInPlace(1/q),N}invertInPlace(){this.conjugateInPlace();const N=this.lengthSquared();return 0==N||1==N||this.scaleInPlace(1/N),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(N){return 0===N||1===N?this:this.scaleInPlace(1/N)}normalizeToNew(){const N=new r(0,0,0,1);return this.normalizeToRef(N),N}normalizeToRef(N){const q=this.length();return 0===q||1===q?N.hd(this._x,this._y,this._z,this._w):this.scaleToRef(1/q,N)}toEulerAngles(){const N=Q.Zero();return this.toEulerAnglesToRef(N),N}toEulerAnglesToRef(N){const q=this._z,C=this._x,d=this._y,U=this._w,W=d*q-C*U,a=.4999999;if(W<-a)N._y=2*Math.atan2(d,U),N._x=Math.PI/2,N._z=0,N._isDirty=!0;else if(W>a)N._y=2*Math.atan2(d,U),N._x=-Math.PI/2,N._z=0,N._isDirty=!0;else{const a=U*U,F=q*q,w=C*C,A=d*d;N._z=Math.atan2(2*(C*d+q*U),-F-w+A+a),N._x=Math.asin(-2*W),N._y=Math.atan2(2*(q*C+d*U),F-w-A+a),N._isDirty=!0}return N}toAlphaBetaGammaToRef(N){const q=this._z,C=this._x,d=this._y,U=this._w,W=Math.sqrt(C*C+d*d),a=Math.sqrt(q*q+U*U),F=2*Math.atan2(W,a),w=2*Math.atan2(q,U),A=2*Math.atan2(d,C),n=(w+A)/2,t=(w-A)/2;return N.set(t,F,n),N}toRotationMatrix(N){return O.FromQuaternionToRef(this,N),N}fromRotationMatrix(N){return r.FromRotationMatrixToRef(N,this),this}dot(N){return this._x*N._x+this._y*N._y+this._z*N._z+this._w*N._w}toAxisAngle(){const N=Q.Zero();return{axis:N,angle:this.toAxisAngleToRef(N)}}toAxisAngleToRef(N){let q=0;const C=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),d=this._w;return C>0?(q=2*Math.atan2(C,d),N.set(this._x/C,this._y/C,this._z/C)):(q=0,N.set(1,0,0)),q}static FromRotationMatrix(N){const q=new r;return r.FromRotationMatrixToRef(N,q),q}static FromRotationMatrixToRef(N,q){const C=N.m,d=C[0],U=C[4],W=C[8],a=C[1],F=C[5],w=C[9],A=C[2],n=C[6],t=C[10],V=d+F+t;let Z;return V>0?(Z=.5/Math.sqrt(V+1),q._w=.25/Z,q._x=(n-w)*Z,q._y=(W-A)*Z,q._z=(a-U)*Z,q._isDirty=!0):d>F&&d>t?(Z=2*Math.sqrt(1+d-F-t),q._w=(n-w)/Z,q._x=.25*Z,q._y=(U+a)/Z,q._z=(W+A)/Z,q._isDirty=!0):F>t?(Z=2*Math.sqrt(1+F-d-t),q._w=(W-A)/Z,q._x=(U+a)/Z,q._y=.25*Z,q._z=(w+n)/Z,q._isDirty=!0):(Z=2*Math.sqrt(1+t-d-F),q._w=(a-U)/Z,q._x=(W+A)/Z,q._y=(w+n)/Z,q._z=.25*Z,q._isDirty=!0),q}static Dot(N,q){return N._x*q._x+N._y*q._y+N._z*q._z+N._w*q._w}static AreClose(N,q){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const d=r.Dot(N,q);return 1-d*d<=C}static SmoothToRef(N,q,C,d,U){let W=0===d?1:C/d;return W=(0,w.Clamp)(W,0,1),r.SlerpToRef(N,q,W,U),U}static Zero(){return new r(0,0,0,0)}static Inverse(N){return new r(-N._x,-N._y,-N._z,N._w)}static InverseToRef(N,q){return q.set(-N._x,-N._y,-N._z,N._w),q}static Identity(){return new r(0,0,0,1)}static IsIdentity(N){return N&&0===N._x&&0===N._y&&0===N._z&&1===N._w}static RotationAxis(N,q){return r.RotationAxisToRef(N,q,new r)}static RotationAxisToRef(N,q,C){C._w=Math.cos(q/2);const d=Math.sin(q/2)/N.length();return C._x=N._x*d,C._y=N._y*d,C._z=N._z*d,C._isDirty=!0,C}static Kq(N,q){return q||(q=0),new r(N[q],N[q+1],N[q+2],N[q+3])}static FromArrayToRef(N,q,C){return C._x=N[q],C._y=N[q+1],C._z=N[q+2],C._w=N[q+3],C._isDirty=!0,C}static FromFloatsToRef(N,q,C,d,U){return U.hd(N,q,C,d),U}static FromEulerAngles(N,q,C){const d=new r;return r.RotationYawPitchRollToRef(q,N,C,d),d}static FromEulerAnglesToRef(N,q,C,d){return r.RotationYawPitchRollToRef(q,N,C,d),d}static FromEulerVector(N){const q=new r;return r.RotationYawPitchRollToRef(N._y,N._x,N._z,q),q}static FromEulerVectorToRef(N,q){return r.RotationYawPitchRollToRef(N._y,N._x,N._z,q),q}static FromUnitVectorsToRef(N,q,C){let U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:d.e;const W=Q.Dot(N,q)+1;return W<U?Math.abs(N.x)>Math.abs(N.z)?C.set(-N.y,N.x,0,0):C.set(0,-N.z,N.y,0):(Q.CrossToRef(N,q,i.Jq[0]),C.set(i.Jq[0].x,i.Jq[0].y,i.Jq[0].z,W)),C.normalize()}static RotationYawPitchRoll(N,q,C){const d=new r;return r.RotationYawPitchRollToRef(N,q,C,d),d}static RotationYawPitchRollToRef(N,q,C,d){const U=.5*C,W=.5*q,a=.5*N,F=Math.sin(U),w=Math.cos(U),A=Math.sin(W),n=Math.cos(W),t=Math.sin(a),V=Math.cos(a);return d._x=V*A*w+t*n*F,d._y=t*n*w-V*A*F,d._z=V*n*F-t*A*w,d._w=V*n*w+t*A*F,d._isDirty=!0,d}static RotationAlphaBetaGamma(N,q,C){const d=new r;return r.RotationAlphaBetaGammaToRef(N,q,C,d),d}static RotationAlphaBetaGammaToRef(N,q,C,d){const U=.5*(C+N),W=.5*(C-N),a=.5*q;return d._x=Math.cos(W)*Math.sin(a),d._y=Math.sin(W)*Math.sin(a),d._z=Math.sin(U)*Math.cos(a),d._w=Math.cos(U)*Math.cos(a),d._isDirty=!0,d}static RotationQuaternionFromAxis(N,q,C){const d=new r(0,0,0,0);return r.RotationQuaternionFromAxisToRef(N,q,C,d),d}static RotationQuaternionFromAxisToRef(N,q,C,d){const U=K.Matrix[0];return N=N.normalizeToRef(K.Jq[0]),q=q.normalizeToRef(K.Jq[1]),C=C.normalizeToRef(K.Jq[2]),O.FromXYZAxesToRef(N,q,C,U),r.FromRotationMatrixToRef(U,d),d}static FromLookDirectionLH(N,q){const C=new r;return r.FromLookDirectionLHToRef(N,q,C),C}static FromLookDirectionLHToRef(N,q,C){const d=K.Matrix[0];return O.LookDirectionLHToRef(N,q,d),r.FromRotationMatrixToRef(d,C),C}static FromLookDirectionRH(N,q){const C=new r;return r.FromLookDirectionRHToRef(N,q,C),C}static FromLookDirectionRHToRef(N,q,C){const d=K.Matrix[0];return O.LookDirectionRHToRef(N,q,d),r.FromRotationMatrixToRef(d,C)}static Slerp(N,q,C){const d=r.Identity();return r.SlerpToRef(N,q,C,d),d}static SlerpToRef(N,q,C,d){let U,W,a=N._x*q._x+N._y*q._y+N._z*q._z+N._w*q._w,F=!1;if(a<0&&(F=!0,a=-a),a>.999999)W=1-C,U=F?-C:C;else{const N=Math.acos(a),q=1/Math.sin(N);W=Math.sin((1-C)*N)*q,U=F?-Math.sin(C*N)*q:Math.sin(C*N)*q}return d._x=W*N._x+U*q._x,d._y=W*N._y+U*q._y,d._z=W*N._z+U*q._z,d._w=W*N._w+U*q._w,d._isDirty=!0,d}static Hermite(N,q,C,d,U){const W=U*U,a=U*W,F=2*a-3*W+1,w=-2*a+3*W,A=a-2*W+U,n=a-W,t=N._x*F+C._x*w+q._x*A+d._x*n,V=N._y*F+C._y*w+q._y*A+d._y*n,Z=N._z*F+C._z*w+q._z*A+d._z*n,J=N._w*F+C._w*w+q._w*A+d._w*n;return new r(t,V,Z,J)}static Hermite1stDerivative(N,q,C,d,U){const W=new r;return this.Hermite1stDerivativeToRef(N,q,C,d,U,W),W}static Hermite1stDerivativeToRef(N,q,C,d,U,W){const a=U*U;return W._x=6*(a-U)*N._x+(3*a-4*U+1)*q._x+6*(-a+U)*C._x+(3*a-2*U)*d._x,W._y=6*(a-U)*N._y+(3*a-4*U+1)*q._y+6*(-a+U)*C._y+(3*a-2*U)*d._y,W._z=6*(a-U)*N._z+(3*a-4*U+1)*q._z+6*(-a+U)*C._z+(3*a-2*U)*d._z,W._w=6*(a-U)*N._w+(3*a-4*U+1)*q._w+6*(-a+U)*C._w+(3*a-2*U)*d._w,W._isDirty=!0,W}static Normalize(N){const q=r.Zero();return r.NormalizeToRef(N,q),q}static NormalizeToRef(N,q){return N.normalizeToRef(q),q}static Clamp(N,q,C){const d=new r;return r.ClampToRef(N,q,C,d),d}static ClampToRef(N,q,C,d){return d.hd((0,w.Clamp)(N.x,q.x,C.x),(0,w.Clamp)(N.y,q.y,C.y),(0,w.Clamp)(N.z,q.z,C.z),(0,w.Clamp)(N.w,q.w,C.w))}static Random(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new r((0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q))}static RandomToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).hd((0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q),(0,w.RandomRange)(N,q))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(N,q){return Math.sqrt(r.DistanceSquared(N,q))}static DistanceSquared(N,q){const C=N.x-q.x,d=N.y-q.y,U=N.z-q.z,W=N.w-q.w;return C*C+d*d+U*U+W*W}static Center(N,q){return r.CenterToRef(N,q,r.Zero())}static CenterToRef(N,q,C){return C.hd((N.x+q.x)/2,(N.y+q.y)/2,(N.z+q.z)/2,(N.w+q.w)/2)}}r._V8PerformanceHack=new r(.5,.5,.5,.5),Object.defineProperties(r.prototype,{dimension:{value:[4]},rank:{value:1}});class O{static get Use64Bits(){return a.d.MatrixUse64Bits}get m(){return this.Vd}markAsUpdated(){this.updateFlag=A._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(N){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],d=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=N,this._isIdentity3x2=N||C,this._isIdentityDirty=!this._isIdentity&&q,this._isIdentity3x2Dirty=!this._isIdentity3x2&&d}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,a.d.MatrixTrackPrecisionChange&&a.d.MatrixTrackedMatrices.push(this),this.Vd=new a.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const N=this.Vd;this._isIdentity=1===N[0]&&0===N[1]&&0===N[2]&&0===N[3]&&0===N[4]&&1===N[5]&&0===N[6]&&0===N[7]&&0===N[8]&&0===N[9]&&1===N[10]&&0===N[11]&&0===N[12]&&0===N[13]&&0===N[14]&&1===N[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Vd[0]||1!==this.Vd[5]||1!==this.Vd[15]||0!==this.Vd[1]||0!==this.Vd[2]||0!==this.Vd[3]||0!==this.Vd[4]||0!==this.Vd[6]||0!==this.Vd[7]||0!==this.Vd[8]||0!==this.Vd[9]||0!==this.Vd[10]||0!==this.Vd[11]||0!==this.Vd[12]||0!==this.Vd[13]||0!==this.Vd[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const N=this.Vd,q=N[0],C=N[1],d=N[2],U=N[3],W=N[4],a=N[5],F=N[6],w=N[7],A=N[8],n=N[9],t=N[10],V=N[11],Z=N[12],J=N[13],Q=N[14],v=N[15],r=t*v-Q*V,O=n*v-J*V,K=n*Q-J*t,i=A*v-Z*V,I=A*Q-t*Z,j=A*J-Z*n;return q*+(a*r-F*O+w*K)+C*-(W*r-F*i+w*I)+d*+(W*O-a*i+w*j)+U*-(W*K-a*I+F*j)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!N)return this.Vd;const C=this.Vd;for(let d=0;d<16;d++)N[q+d]=C[d];return this}zd(){return this.Vd}JC(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(N,q,this)}hd(){for(var N=arguments.length,q=new Array(N),C=0;C<N;C++)q[C]=arguments[C];return O.FromArrayToRef(q,0,this)}set(){const N=this.Vd;for(let q=0;q<16;q++)N[q]=q<0||arguments.length<=q?void 0:arguments[q];return this.markAsUpdated(),this}Rd(N){const q=this.Vd;for(let C=0;C<16;C++)q[C]=N;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return O.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(N){const q=new O;return this.addToRef(N,q),q}addToRef(N,q){const C=this.Vd,d=q.Vd,U=N.m;for(let W=0;W<16;W++)d[W]=C[W]+U[W];return q.markAsUpdated(),q}addToSelf(N){const q=this.Vd,C=N.m;return q[0]+=C[0],q[1]+=C[1],q[2]+=C[2],q[3]+=C[3],q[4]+=C[4],q[5]+=C[5],q[6]+=C[6],q[7]+=C[7],q[8]+=C[8],q[9]+=C[9],q[10]+=C[10],q[11]+=C[11],q[12]+=C[12],q[13]+=C[13],q[14]+=C[14],q[15]+=C[15],this.markAsUpdated(),this}addInPlace(N){const q=this.Vd,C=N.m;for(let d=0;d<16;d++)q[d]+=C[d];return this.markAsUpdated(),this}addInPlaceFromFloats(){const N=this.Vd;for(let q=0;q<16;q++)N[q]+=q<0||arguments.length<=q?void 0:arguments[q];return this.markAsUpdated(),this}Qq(N){const q=this.Vd,C=N.m;for(let d=0;d<16;d++)q[d]-=C[d];return this.markAsUpdated(),this}subtractToRef(N,q){const C=this.Vd,d=N.m,U=q.Vd;for(let W=0;W<16;W++)U[W]=C[W]-d[W];return q.markAsUpdated(),q}Rn(N){const q=this.Vd,C=N.m;for(let d=0;d<16;d++)q[d]-=C[d];return this.markAsUpdated(),this}subtractFromFloats(){for(var N=arguments.length,q=new Array(N),C=0;C<N;C++)q[C]=arguments[C];return this.subtractFromFloatsToRef(...q,new O)}subtractFromFloatsToRef(){for(var N=arguments.length,q=new Array(N),C=0;C<N;C++)q[C]=arguments[C];const d=q.pop(),U=this.Vd,W=d.Vd,a=q;for(let F=0;F<16;F++)W[F]=U[F]-a[F];return d.markAsUpdated(),d}invertToRef(N){return!0===this._isIdentity?(O.IdentityToRef(N),N):(V(this,N.zd())?N.markAsUpdated():N.U(this),N)}addAtIndex(N,q){return this.Vd[N]+=q,this.markAsUpdated(),this}multiplyAtIndex(N,q){return this.Vd[N]*=q,this.markAsUpdated(),this}setTranslationFromFloats(N,q,C){return this.Vd[12]=N,this.Vd[13]=q,this.Vd[14]=C,this.markAsUpdated(),this}addTranslationFromFloats(N,q,C){return this.Vd[12]+=N,this.Vd[13]+=q,this.Vd[14]+=C,this.markAsUpdated(),this}setTranslation(N){return this.setTranslationFromFloats(N._x,N._y,N._z)}getTranslation(){return new Q(this.Vd[12],this.Vd[13],this.Vd[14])}getTranslationToRef(N){return N.x=this.Vd[12],N.y=this.Vd[13],N.z=this.Vd[14],N}removeRotationAndScaling(){const N=this.m;return O.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,N[12],N[13],N[14],N[15],this),this._updateIdentityStatus(0===N[12]&&0===N[13]&&0===N[14]&&1===N[15]),this}U(N){N.copyToArray(this.Vd);const q=N;return this.updateFlag=q.updateFlag,this._updateIdentityStatus(q._isIdentity,q._isIdentityDirty,q._isIdentity3x2,q._isIdentity3x2Dirty),this}copyToArray(N){return t(this,N,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(N){const q=new O;return this.multiplyToRef(N,q),q}multiplyInPlace(N){const q=this.Vd,C=N.m;for(let d=0;d<16;d++)q[d]*=C[d];return this.markAsUpdated(),this}multiplyByFloats(){const N=this.Vd;for(let q=0;q<16;q++)N[q]*=q<0||arguments.length<=q?void 0:arguments[q];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var N=arguments.length,q=new Array(N),C=0;C<N;C++)q[C]=arguments[C];const d=q.pop(),U=this.Vd,W=d.Vd,a=q;for(let F=0;F<16;F++)W[F]=U[F]*a[F];return d.markAsUpdated(),d}multiplyToRef(N,q){return this._isIdentity?(q.U(N),q):N._isIdentity?(q.U(this),q):(this.multiplyToArray(N,q.Vd,0),q.markAsUpdated(),q)}multiplyToArray(N,q,C){return n(this,N,q,C),this}divide(N){return this.divideToRef(N,new O)}divideToRef(N,q){const C=this.Vd,d=N.m,U=q.Vd;for(let W=0;W<16;W++)U[W]=C[W]/d[W];return q.markAsUpdated(),q}divideInPlace(N){const q=this.Vd,C=N.m;for(let d=0;d<16;d++)q[d]/=C[d];return this.markAsUpdated(),this}minimizeInPlace(N){const q=this.Vd,C=N.m;for(let d=0;d<16;d++)q[d]=Math.min(q[d],C[d]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const N=this.Vd;for(let q=0;q<16;q++)N[q]=Math.min(N[q],q<0||arguments.length<=q?void 0:arguments[q]);return this.markAsUpdated(),this}maximizeInPlace(N){const q=this.Vd,C=N.m;for(let d=0;d<16;d++)q[d]=Math.min(q[d],C[d]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const N=this.Vd;for(let q=0;q<16;q++)N[q]=Math.min(N[q],q<0||arguments.length<=q?void 0:arguments[q]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new O)}negateInPlace(){const N=this.Vd;for(let q=0;q<16;q++)N[q]=-N[q];return this.markAsUpdated(),this}negateToRef(N){const q=this.Vd,C=N.Vd;for(let d=0;d<16;d++)C[d]=-q[d];return N.markAsUpdated(),N}equals(N){const q=N;if(!q)return!1;if((this._isIdentity||q._isIdentity)&&!this._isIdentityDirty&&!q._isIdentityDirty)return this._isIdentity&&q._isIdentity;const C=this.m,d=q.m;return C[0]===d[0]&&C[1]===d[1]&&C[2]===d[2]&&C[3]===d[3]&&C[4]===d[4]&&C[5]===d[5]&&C[6]===d[6]&&C[7]===d[7]&&C[8]===d[8]&&C[9]===d[9]&&C[10]===d[10]&&C[11]===d[11]&&C[12]===d[12]&&C[13]===d[13]&&C[14]===d[14]&&C[15]===d[15]}equalsWithEpsilon(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this.Vd,d=N.m;for(let U=0;U<16;U++)if(!(0,w.WithinEpsilon)(C[U],d[U],q))return!1;return!0}equalsToFloats(){const N=this.Vd;for(let q=0;q<16;q++)if(N[q]!=(q<0||arguments.length<=q?void 0:arguments[q]))return!1;return!0}floor(){return this.floorToRef(new O)}floorToRef(N){const q=this.Vd,C=N.Vd;for(let d=0;d<16;d++)C[d]=Math.floor(q[d]);return N.markAsUpdated(),N}fract(){return this.fractToRef(new O)}fractToRef(N){const q=this.Vd,C=N.Vd;for(let d=0;d<16;d++)C[d]=q[d]-Math.floor(q[d]);return N.markAsUpdated(),N}clone(){const N=new O;return N.U(this),N}getClassName(){return"Matrix"}getHashCode(){let N=Z(this.Vd[0]);for(let q=1;q<16;q++)N=397*N^Z(this.Vd[q]);return N}decomposeToTransformNode(N){return N.rotationQuaternion=N.rotationQuaternion||new r,this.decompose(N.yd,N.rotationQuaternion,N.position)}decompose(N,q,C,d){let U=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return C&&C.Rd(0),N&&N.Rd(1),q&&q.hd(0,0,0,1),!0;const W=this.Vd;if(C&&C.hd(W[12],W[13],W[14]),(N=N||K.Jq[0]).x=Math.sqrt(W[0]*W[0]+W[1]*W[1]+W[2]*W[2]),N.y=Math.sqrt(W[4]*W[4]+W[5]*W[5]+W[6]*W[6]),N.z=Math.sqrt(W[8]*W[8]+W[9]*W[9]+W[10]*W[10]),d){const q=(U?d.absoluteScaling.x:d.yd.x)<0?-1:1,C=(U?d.absoluteScaling.y:d.yd.y)<0?-1:1,W=(U?d.absoluteScaling.z:d.yd.z)<0?-1:1;N.x*=q,N.y*=C,N.z*=W}else this.determinant()<=0&&(N.y*=-1);if(0===N._x||0===N._y||0===N._z)return q&&q.hd(0,0,0,1),!1;if(q){const C=1/N._x,d=1/N._y,U=1/N._z;O.FromValuesToRef(W[0]*C,W[1]*C,W[2]*C,0,W[4]*d,W[5]*d,W[6]*d,0,W[8]*U,W[9]*U,W[10]*U,0,0,0,0,1,K.Matrix[0]),r.FromRotationMatrixToRef(K.Matrix[0],q)}return!0}getRow(N){if(N<0||N>3)return null;const q=4*N;return new v(this.Vd[q+0],this.Vd[q+1],this.Vd[q+2],this.Vd[q+3])}getRowToRef(N,q){if(N>=0&&N<=3){const C=4*N;q.x=this.Vd[C+0],q.y=this.Vd[C+1],q.z=this.Vd[C+2],q.w=this.Vd[C+3]}return q}setRow(N,q){return this.setRowFromFloats(N,q.x,q.y,q.z,q.w)}transpose(){const N=new O;return O.TransposeToRef(this,N),N}transposeToRef(N){return O.TransposeToRef(this,N),N}setRowFromFloats(N,q,C,d,U){if(N<0||N>3)return this;const W=4*N;return this.Vd[W+0]=q,this.Vd[W+1]=C,this.Vd[W+2]=d,this.Vd[W+3]=U,this.markAsUpdated(),this}scale(N){const q=new O;return this.scaleToRef(N,q),q}scaleToRef(N,q){for(let C=0;C<16;C++)q.Vd[C]=this.Vd[C]*N;return q.markAsUpdated(),q}scaleAndAddToRef(N,q){for(let C=0;C<16;C++)q.Vd[C]+=this.Vd[C]*N;return q.markAsUpdated(),q}scaleInPlace(N){const q=this.Vd;for(let C=0;C<16;C++)q[C]*=N;return this.markAsUpdated(),this}toNormalMatrix(N){const q=K.Matrix[0];this.invertToRef(q),q.transposeToRef(N);const C=N.Vd;return O.FromValuesToRef(C[0],C[1],C[2],0,C[4],C[5],C[6],0,C[8],C[9],C[10],0,0,0,0,1,N),N}getRotationMatrix(){const N=new O;return this.getRotationMatrixToRef(N),N}getRotationMatrixToRef(N){const q=K.Jq[0];if(!this.decompose(q))return O.IdentityToRef(N),N;const C=this.Vd,d=1/q._x,U=1/q._y,W=1/q._z;return O.FromValuesToRef(C[0]*d,C[1]*d,C[2]*d,0,C[4]*U,C[5]*U,C[6]*U,0,C[8]*W,C[9]*W,C[10]*W,0,0,0,0,1,N),N}toggleModelMatrixHandInPlace(){const N=this.Vd;return N[2]*=-1,N[6]*=-1,N[8]*=-1,N[9]*=-1,N[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const N=this.Vd;return N[8]*=-1,N[9]*=-1,N[10]*=-1,N[11]*=-1,this.markAsUpdated(),this}static Kq(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=new O;return O.FromArrayToRef(N,q,C),C}static FromArrayToRef(N,q,C){for(let d=0;d<16;d++)C.Vd[d]=N[d+q];return C.markAsUpdated(),C}static FromFloat32ArrayToRefScaled(N,q,C,d){return d.Vd[0]=N[0+q]*C,d.Vd[1]=N[1+q]*C,d.Vd[2]=N[2+q]*C,d.Vd[3]=N[3+q]*C,d.Vd[4]=N[4+q]*C,d.Vd[5]=N[5+q]*C,d.Vd[6]=N[6+q]*C,d.Vd[7]=N[7+q]*C,d.Vd[8]=N[8+q]*C,d.Vd[9]=N[9+q]*C,d.Vd[10]=N[10+q]*C,d.Vd[11]=N[11+q]*C,d.Vd[12]=N[12+q]*C,d.Vd[13]=N[13+q]*C,d.Vd[14]=N[14+q]*C,d.Vd[15]=N[15+q]*C,d.markAsUpdated(),d}static get IdentityReadOnly(){return O._IdentityReadOnly}static FromValuesToRef(N,q,C,d,U,W,a,F,w,A,n,t,V,Z,J,Q,v){const r=v.Vd;r[0]=N,r[1]=q,r[2]=C,r[3]=d,r[4]=U,r[5]=W,r[6]=a,r[7]=F,r[8]=w,r[9]=A,r[10]=n,r[11]=t,r[12]=V,r[13]=Z,r[14]=J,r[15]=Q,v.markAsUpdated()}static FromValues(N,q,C,d,U,W,a,F,w,A,n,t,V,Z,J,Q){const v=new O,r=v.Vd;return r[0]=N,r[1]=q,r[2]=C,r[3]=d,r[4]=U,r[5]=W,r[6]=a,r[7]=F,r[8]=w,r[9]=A,r[10]=n,r[11]=t,r[12]=V,r[13]=Z,r[14]=J,r[15]=Q,v.markAsUpdated(),v}static Compose(N,q,C){const d=new O;return O.ComposeToRef(N,q,C,d),d}static ComposeToRef(N,q,C,d){const U=d.Vd,W=q._x,a=q._y,F=q._z,w=q._w,A=W+W,n=a+a,t=F+F,V=W*A,Z=W*n,J=W*t,Q=a*n,v=a*t,r=F*t,O=w*A,K=w*n,i=w*t,I=N._x,j=N._y,l=N._z;return U[0]=(1-(Q+r))*I,U[1]=(Z+i)*I,U[2]=(J-K)*I,U[3]=0,U[4]=(Z-i)*j,U[5]=(1-(V+r))*j,U[6]=(v+O)*j,U[7]=0,U[8]=(J+K)*l,U[9]=(v-O)*l,U[10]=(1-(V+Q))*l,U[11]=0,U[12]=C._x,U[13]=C._y,U[14]=C._z,U[15]=1,d.markAsUpdated(),d}static Identity(){const N=O.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return N._updateIdentityStatus(!0),N}static IdentityToRef(N){return O.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,N),N._updateIdentityStatus(!0),N}static Zero(){const N=O.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return N._updateIdentityStatus(!1),N}static RotationX(N){const q=new O;return O.RotationXToRef(N,q),q}static Invert(N){const q=new O;return N.invertToRef(q),q}static RotationXToRef(N,q){const C=Math.sin(N),d=Math.cos(N);return O.FromValuesToRef(1,0,0,0,0,d,C,0,0,-C,d,0,0,0,0,1,q),q._updateIdentityStatus(1===d&&0===C),q}static RotationY(N){const q=new O;return O.RotationYToRef(N,q),q}static RotationYToRef(N,q){const C=Math.sin(N),d=Math.cos(N);return O.FromValuesToRef(d,0,-C,0,0,1,0,0,C,0,d,0,0,0,0,1,q),q._updateIdentityStatus(1===d&&0===C),q}static RotationZ(N){const q=new O;return O.RotationZToRef(N,q),q}static RotationZToRef(N,q){const C=Math.sin(N),d=Math.cos(N);return O.FromValuesToRef(d,C,0,0,-C,d,0,0,0,0,1,0,0,0,0,1,q),q._updateIdentityStatus(1===d&&0===C),q}static RotationAxis(N,q){const C=new O;return O.RotationAxisToRef(N,q,C),C}static RotationAxisToRef(N,q,C){const d=Math.sin(-q),U=Math.cos(-q),W=1-U;N=N.normalizeToRef(K.Jq[0]);const a=C.Vd;return a[0]=N._x*N._x*W+U,a[1]=N._x*N._y*W-N._z*d,a[2]=N._x*N._z*W+N._y*d,a[3]=0,a[4]=N._y*N._x*W+N._z*d,a[5]=N._y*N._y*W+U,a[6]=N._y*N._z*W-N._x*d,a[7]=0,a[8]=N._z*N._x*W-N._y*d,a[9]=N._z*N._y*W+N._x*d,a[10]=N._z*N._z*W+U,a[11]=0,a[12]=0,a[13]=0,a[14]=0,a[15]=1,C.markAsUpdated(),C}static RotationAlignToRef(N,q,C){let U=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const W=Q.Dot(q,N),a=C.Vd;if(W<-1+d.e)a[0]=-1,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=U?1:-1,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=U?-1:1,a[11]=0;else{const C=Q.Cross(q,N),d=1/(1+W);a[0]=C._x*C._x*d+W,a[1]=C._y*C._x*d-C._z,a[2]=C._z*C._x*d+C._y,a[3]=0,a[4]=C._x*C._y*d+C._z,a[5]=C._y*C._y*d+W,a[6]=C._z*C._y*d-C._x,a[7]=0,a[8]=C._x*C._z*d-C._y,a[9]=C._y*C._z*d+C._x,a[10]=C._z*C._z*d+W,a[11]=0}return a[12]=0,a[13]=0,a[14]=0,a[15]=1,C.markAsUpdated(),C}static RotationYawPitchRoll(N,q,C){const d=new O;return O.RotationYawPitchRollToRef(N,q,C,d),d}static RotationYawPitchRollToRef(N,q,C,d){return r.RotationYawPitchRollToRef(N,q,C,K.Quaternion[0]),K.Quaternion[0].toRotationMatrix(d),d}static Scaling(N,q,C){const d=new O;return O.ScalingToRef(N,q,C,d),d}static ScalingToRef(N,q,C,d){return O.FromValuesToRef(N,0,0,0,0,q,0,0,0,0,C,0,0,0,0,1,d),d._updateIdentityStatus(1===N&&1===q&&1===C),d}static Translation(N,q,C){const d=new O;return O.TranslationToRef(N,q,C,d),d}static TranslationToRef(N,q,C,d){return O.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,N,q,C,1,d),d._updateIdentityStatus(0===N&&0===q&&0===C),d}static Lerp(N,q,C){const d=new O;return O.LerpToRef(N,q,C,d),d}static LerpToRef(N,q,C,d){const U=d.Vd,W=N.m,a=q.m;for(let F=0;F<16;F++)U[F]=W[F]*(1-C)+a[F]*C;return d.markAsUpdated(),d}static DecomposeLerp(N,q,C){const d=new O;return O.DecomposeLerpToRef(N,q,C,d),d}static DecomposeLerpToRef(N,q,C,d){const U=K.Jq[0],W=K.Quaternion[0],a=K.Jq[1];N.decompose(U,W,a);const F=K.Jq[2],w=K.Quaternion[1],A=K.Jq[3];q.decompose(F,w,A);const n=K.Jq[4];Q.LerpToRef(U,F,C,n);const t=K.Quaternion[2];r.SlerpToRef(W,w,C,t);const V=K.Jq[5];return Q.LerpToRef(a,A,C,V),O.ComposeToRef(n,t,V,d),d}static LookAtLH(N,q,C){const d=new O;return O.LookAtLHToRef(N,q,C,d),d}static LookAtLHToRef(N,q,C,d){const U=K.Jq[0],W=K.Jq[1],a=K.Jq[2];q.subtractToRef(N,a),a.normalize(),Q.CrossToRef(C,a,U);const F=U.lengthSquared();0===F?U.x=1:U.normalizeFromLength(Math.sqrt(F)),Q.CrossToRef(a,U,W),W.normalize();const w=-Q.Dot(U,N),A=-Q.Dot(W,N),n=-Q.Dot(a,N);return O.FromValuesToRef(U._x,W._x,a._x,0,U._y,W._y,a._y,0,U._z,W._z,a._z,0,w,A,n,1,d),d}static LookAtRH(N,q,C){const d=new O;return O.LookAtRHToRef(N,q,C,d),d}static LookAtRHToRef(N,q,C,d){const U=K.Jq[0],W=K.Jq[1],a=K.Jq[2];N.subtractToRef(q,a),a.normalize(),Q.CrossToRef(C,a,U);const F=U.lengthSquared();0===F?U.x=1:U.normalizeFromLength(Math.sqrt(F)),Q.CrossToRef(a,U,W),W.normalize();const w=-Q.Dot(U,N),A=-Q.Dot(W,N),n=-Q.Dot(a,N);return O.FromValuesToRef(U._x,W._x,a._x,0,U._y,W._y,a._y,0,U._z,W._z,a._z,0,w,A,n,1,d),d}static LookDirectionLH(N,q){const C=new O;return O.LookDirectionLHToRef(N,q,C),C}static LookDirectionLHToRef(N,q,C){const d=K.Jq[0];d.U(N),d.scaleInPlace(-1);const U=K.Jq[1];return Q.CrossToRef(q,d,U),O.FromValuesToRef(U._x,U._y,U._z,0,q._x,q._y,q._z,0,d._x,d._y,d._z,0,0,0,0,1,C),C}static LookDirectionRH(N,q){const C=new O;return O.LookDirectionRHToRef(N,q,C),C}static LookDirectionRHToRef(N,q,C){const d=K.Jq[2];return Q.CrossToRef(q,N,d),O.FromValuesToRef(d._x,d._y,d._z,0,q._x,q._y,q._z,0,N._x,N._y,N._z,0,0,0,0,1,C),C}static OrthoLH(N,q,C,d,U){const W=new O;return O.OrthoLHToRef(N,q,C,d,W,U),W}static OrthoLHToRef(N,q,C,d,U,W){const a=2/N,F=2/q,w=2/(d-C),A=-(d+C)/(d-C);return O.FromValuesToRef(a,0,0,0,0,F,0,0,0,0,w,0,0,0,A,1,U),W&&U.multiplyToRef(I,U),U._updateIdentityStatus(1===a&&1===F&&1===w&&0===A),U}static OrthoOffCenterLH(N,q,C,d,U,W,a){const F=new O;return O.OrthoOffCenterLHToRef(N,q,C,d,U,W,F,a),F}static OrthoOffCenterLHToRef(N,q,C,d,U,W,a,F){const w=2/(q-N),A=2/(d-C),n=2/(W-U),t=-(W+U)/(W-U),V=(N+q)/(N-q),Z=(d+C)/(C-d);return O.FromValuesToRef(w,0,0,0,0,A,0,0,0,0,n,0,V,Z,t,1,a),F&&a.multiplyToRef(I,a),a.markAsUpdated(),a}static ObliqueOffCenterLHToRef(N,q,C,d,U,W,a,F,w,A,n){const t=-a*Math.cos(F),V=-a*Math.sin(F);return O.TranslationToRef(0,0,-w,K.Matrix[1]),O.FromValuesToRef(1,0,0,0,0,1,0,0,t,V,1,0,0,0,0,1,K.Matrix[0]),K.Matrix[1].multiplyToRef(K.Matrix[0],K.Matrix[0]),O.TranslationToRef(0,0,w,K.Matrix[1]),K.Matrix[0].multiplyToRef(K.Matrix[1],K.Matrix[0]),O.OrthoOffCenterLHToRef(N,q,C,d,U,W,A,n),K.Matrix[0].multiplyToRef(A,A),A}static OrthoOffCenterRH(N,q,C,d,U,W,a){const F=new O;return O.OrthoOffCenterRHToRef(N,q,C,d,U,W,F,a),F}static OrthoOffCenterRHToRef(N,q,C,d,U,W,a,F){return O.OrthoOffCenterLHToRef(N,q,C,d,U,W,a,F),a.Vd[10]*=-1,a}static ObliqueOffCenterRHToRef(N,q,C,d,U,W,a,F,w,A,n){const t=a*Math.cos(F),V=a*Math.sin(F);return O.TranslationToRef(0,0,w,K.Matrix[1]),O.FromValuesToRef(1,0,0,0,0,1,0,0,t,V,1,0,0,0,0,1,K.Matrix[0]),K.Matrix[1].multiplyToRef(K.Matrix[0],K.Matrix[0]),O.TranslationToRef(0,0,-w,K.Matrix[1]),K.Matrix[0].multiplyToRef(K.Matrix[1],K.Matrix[0]),O.OrthoOffCenterRHToRef(N,q,C,d,U,W,A,n),K.Matrix[0].multiplyToRef(A,A),A}static PerspectiveLH(N,q,C,d,U){let W=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const a=new O,F=2*C/N,w=2*C/q,A=(d+C)/(d-C),n=-2*d*C/(d-C),t=Math.tan(W);return O.FromValuesToRef(F,0,0,0,0,w,0,t,0,0,A,1,0,0,n,0,a),U&&a.multiplyToRef(I,a),a._updateIdentityStatus(!1),a}static PerspectiveFovLH(N,q,C,d,U){let W=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,a=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const F=new O;return O.PerspectiveFovLHToRef(N,q,C,d,F,!0,U,W,a),F}static PerspectiveFovLHToRef(N,q,C,d,U){let W=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0,F=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,w=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const A=C,n=d,t=1/Math.tan(.5*N),V=W?t/q:t,Z=W?t:t*q,J=w&&0===A?-1:0!==n?(n+A)/(n-A):1,Q=w&&0===A?2*n:0!==n?-2*n*A/(n-A):-2*A,v=Math.tan(F);return O.FromValuesToRef(V,0,0,0,0,Z,0,v,0,0,J,1,0,0,Q,0,U),a&&U.multiplyToRef(I,U),U._updateIdentityStatus(!1),U}static PerspectiveFovReverseLHToRef(N,q,C,d,U){let W=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0,F=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const w=1/Math.tan(.5*N),A=W?w/q:w,n=W?w:w*q,t=Math.tan(F);return O.FromValuesToRef(A,0,0,0,0,n,0,t,0,0,-C,1,0,0,1,0,U),a&&U.multiplyToRef(I,U),U._updateIdentityStatus(!1),U}static PerspectiveFovRH(N,q,C,d,U){let W=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,a=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const F=new O;return O.PerspectiveFovRHToRef(N,q,C,d,F,!0,U,W,a),F}static PerspectiveFovRHToRef(N,q,C,d,U){let W=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0,F=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,w=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const A=C,n=d,t=1/Math.tan(.5*N),V=W?t/q:t,Z=W?t:t*q,J=w&&0===A?1:0!==n?-(n+A)/(n-A):-1,Q=w&&0===A?2*n:0!==n?-2*n*A/(n-A):-2*A,v=Math.tan(F);return O.FromValuesToRef(V,0,0,0,0,Z,0,v,0,0,J,-1,0,0,Q,0,U),a&&U.multiplyToRef(I,U),U._updateIdentityStatus(!1),U}static PerspectiveFovReverseRHToRef(N,q,C,d,U){let W=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=arguments.length>6?arguments[6]:void 0,F=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const w=1/Math.tan(.5*N),A=W?w/q:w,n=W?w:w*q,t=Math.tan(F);return O.FromValuesToRef(A,0,0,0,0,n,0,t,0,0,-C,-1,0,0,-1,0,U),a&&U.multiplyToRef(I,U),U._updateIdentityStatus(!1),U}static GetFinalMatrix(N,q,C,d,U,W){const a=N.width,F=N.height,w=N.x,A=N.y,n=O.FromValues(a/2,0,0,0,0,-F/2,0,0,0,0,W-U,0,w+a/2,F/2+A,U,1),t=new O;return q.multiplyToRef(C,t),t.multiplyToRef(d,t),t.multiplyToRef(n,t)}static GetAsMatrix2x2(N){const q=N.m,C=[q[0],q[1],q[4],q[5]];return a.d.MatrixUse64Bits?C:new Float32Array(C)}static GetAsMatrix3x3(N){const q=N.m,C=[q[0],q[1],q[2],q[4],q[5],q[6],q[8],q[9],q[10]];return a.d.MatrixUse64Bits?C:new Float32Array(C)}static Transpose(N){const q=new O;return O.TransposeToRef(N,q),q}static TransposeToRef(N,q){const C=N.m,d=C[0],U=C[4],W=C[8],a=C[12],F=C[1],w=C[5],A=C[9],n=C[13],t=C[2],V=C[6],Z=C[10],J=C[14],Q=C[3],v=C[7],r=C[11],O=C[15],K=q.Vd;return K[0]=d,K[1]=U,K[2]=W,K[3]=a,K[4]=F,K[5]=w,K[6]=A,K[7]=n,K[8]=t,K[9]=V,K[10]=Z,K[11]=J,K[12]=Q,K[13]=v,K[14]=r,K[15]=O,q.markAsUpdated(),q._updateIdentityStatus(N._isIdentity,N._isIdentityDirty),q}static Reflection(N){const q=new O;return O.ReflectionToRef(N,q),q}static ReflectionToRef(N,q){N.normalize();const C=N.normal.x,d=N.normal.y,U=N.normal.z,W=-2*C,a=-2*d,F=-2*U;return O.FromValuesToRef(W*C+1,a*C,F*C,0,W*d,a*d+1,F*d,0,W*U,a*U,F*U+1,0,W*N.d,a*N.d,F*N.d,1,q),q}static FromXYZAxesToRef(N,q,C,d){return O.FromValuesToRef(N._x,N._y,N._z,0,q._x,q._y,q._z,0,C._x,C._y,C._z,0,0,0,0,1,d),d}static FromQuaternionToRef(N,q){const C=N._x*N._x,d=N._y*N._y,U=N._z*N._z,W=N._x*N._y,a=N._z*N._w,F=N._z*N._x,w=N._y*N._w,A=N._y*N._z,n=N._x*N._w;return q.Vd[0]=1-2*(d+U),q.Vd[1]=2*(W+a),q.Vd[2]=2*(F-w),q.Vd[3]=0,q.Vd[4]=2*(W-a),q.Vd[5]=1-2*(U+C),q.Vd[6]=2*(A+n),q.Vd[7]=0,q.Vd[8]=2*(F+w),q.Vd[9]=2*(A-n),q.Vd[10]=1-2*(d+C),q.Vd[11]=0,q.Vd[12]=0,q.Vd[13]=0,q.Vd[14]=0,q.Vd[15]=1,q.markAsUpdated(),q}}O._IdentityReadOnly=O.Identity(),Object.defineProperties(O.prototype,{dimension:{value:[4,4]},rank:{value:2}});class K{}K.Jq=(0,U.e)(11,Q.Zero),K.Matrix=(0,U.e)(2,O.Identity),K.Quaternion=(0,U.e)(3,r.Zero);class i{}i.Vector2=(0,U.e)(3,J.Zero),i.Jq=(0,U.e)(13,Q.Zero),i.Vector4=(0,U.e)(3,v.Zero),i.Quaternion=(0,U.e)(3,r.Zero),i.Matrix=(0,U.e)(8,O.Identity),(0,W.h)("BABYLON.Vector2",J),(0,W.h)("BABYLON.Vector3",Q),(0,W.h)("BABYLON.Vector4",v),(0,W.h)("BABYLON.Matrix",O);const I=O.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11134:(N,q,C)=>{function d(N,q){const C=[];for(let d=0;d<N;++d)C.push(q());return C}function U(N,q){return d(N,q)}C.d(q,{d:()=>d,e:()=>U,h:()=>a});const W=["push","splice","pop","shift","unshift"];function a(N,q){const C=W.map((C=>function(N,q,C){const d=N[q];if("function"!==typeof d)return null;const U=function(){const d=N.length,W=U.previous.apply(N,arguments);return C(q,d),W};return d.next=U,U.previous=d,N[q]=U,()=>{const C=U.previous;if(!C)return;const d=U.next;d?(C.next=d,d.previous=C):(C.next=void 0,N[q]=C),U.next=void 0,U.previous=void 0}}(N,C,q)));return()=>{for(const N of C)null===N||void 0===N||N()}}}}]);