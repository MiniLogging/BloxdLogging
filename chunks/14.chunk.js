"use strict";(self["9d4d30r2sf"]=self["9d4d30r2sf"]||[]).push([[14],{12497:(o,v,V)=>{V.d(v,{d:()=>Q,f:()=>I,i:()=>g,k:()=>E});const g=1/2.2,E=2.2,I=(1+Math.sqrt(5))/2,Q=.001},12511:(o,v,V)=>{function g(o){return parseInt(o.toString().replace(/\W/g,""))}function E(o,v){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(o-v)<=V}function I(o,v,V){let g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return o<v-g||o>V+g}function Q(o,v){return o===v?o:Math.random()*(v-o)+o}function U(o,v,V){return o+(v-o)*V}function n(o,v,V){let g=c(v-o,360);return g>180&&(g-=360),o+g*f(V)}function O(o,v,V){let g=0;return g=o!=v?f((V-o)/(v-o)):0,g}function h(o,v,V,g,E){const I=E*E,Q=E*I;return o*(2*Q-3*I+1)+V*(-2*Q+3*I)+v*(Q-2*I+E)+g*(Q-I)}function x(o,v,V,g,E){const I=E*E;return 6*(I-E)*o+(3*I-4*E+1)*v+6*(-I+E)*V+(3*I-2*E)*g}function f(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(V,Math.max(v,o))}function l(o){return o-=2*Math.PI*Math.floor((o+Math.PI)/(2*Math.PI))}function S(o){const v=o.toString(16);return o<=15?("0"+v).toUpperCase():v.toUpperCase()}function T(o){if(Math.log2)return Math.floor(Math.log2(o));if(o<0)return NaN;if(0===o)return-1/0;let v=0;if(o<1){for(;o<1;)v++,o*=2;v=-v}else if(o>1)for(;o>1;)v++,o=Math.floor(o/2);return v}function c(o,v){return o-Math.floor(o/v)*v}function R(o,v,V){return(o-v)/(V-v)}function j(o,v,V){return o*(V-v)+v}function t(o,v){let V=c(v-o,360);return V>180&&(V-=360),V}function s(o,v){const V=c(o,2*v);return v-Math.abs(V-v)}function L(o,v,V){let g=f(V);return g=-2*g*g*g+3*g*g,v*g+o*(1-g)}function b(o,v,V){let g=0;return g=Math.abs(v-o)<=V?v:o+Math.sign(v-o)*V,g}function u(o,v,V){const g=t(o,v);let E=0;return E=-V<g&&g<V?v:b(o,v=o+g,V),E}function mo(o,v,V){return(o-v)/(V-v)}function a(o,v,V){return(V-v)*o+v}function F(o,v){const V=o%v;return 0===V?v:F(v,V)}V.r(v),V.d(v,{Clamp:()=>f,DeltaAngle:()=>t,Denormalize:()=>j,ExtractAsInt:()=>g,Hermite:()=>h,Hermite1stDerivative:()=>x,HighestCommonFactor:()=>F,ILog2:()=>T,InverseLerp:()=>O,Lerp:()=>U,LerpAngle:()=>n,MoveTowards:()=>b,MoveTowardsAngle:()=>u,Normalize:()=>R,NormalizeRadians:()=>l,OutsideRange:()=>I,PercentToRange:()=>a,PingPong:()=>s,RandomRange:()=>Q,RangeToPercent:()=>mo,Repeat:()=>c,SmoothStep:()=>L,ToHex:()=>S,WithinEpsilon:()=>E})},12488:(o,v,V)=>{V.r(v),V.d(v,{Matrix:()=>j,Quaternion:()=>R,TmpVectors:()=>s,Vector2:()=>S,cv:()=>T,Vector4:()=>c});var g=V(12497),E=V(12503),I=V(12449),Q=V(12410),U=V(12339),n=V(12511);class O{}function h(o,v,V){let g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const E=o.Dg(),I=v.Dg(),Q=E[0],U=E[1],n=E[2],O=E[3],h=E[4],x=E[5],f=E[6],l=E[7],S=E[8],T=E[9],c=E[10],R=E[11],j=E[12],t=E[13],s=E[14],L=E[15],b=I[0],u=I[1],mo=I[2],a=I[3],F=I[4],i=I[5],J=I[6],d=I[7],N=I[8],Y=I[9],q=I[10],P=I[11],M=I[12],W=I[13],w=I[14],z=I[15];V[g]=Q*b+U*F+n*N+O*M,V[g+1]=Q*u+U*i+n*Y+O*W,V[g+2]=Q*mo+U*J+n*q+O*w,V[g+3]=Q*a+U*d+n*P+O*z,V[g+4]=h*b+x*F+f*N+l*M,V[g+5]=h*u+x*i+f*Y+l*W,V[g+6]=h*mo+x*J+f*q+l*w,V[g+7]=h*a+x*d+f*P+l*z,V[g+8]=S*b+T*F+c*N+R*M,V[g+9]=S*u+T*i+c*Y+R*W,V[g+10]=S*mo+T*J+c*q+R*w,V[g+11]=S*a+T*d+c*P+R*z,V[g+12]=j*b+t*F+s*N+L*M,V[g+13]=j*u+t*i+s*Y+L*W,V[g+14]=j*mo+t*J+s*q+L*w,V[g+15]=j*a+t*d+s*P+L*z}function x(o,v){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const g=o.Dg();v[V]=g[0],v[V+1]=g[1],v[V+2]=g[2],v[V+3]=g[3],v[V+4]=g[4],v[V+5]=g[5],v[V+6]=g[6],v[V+7]=g[7],v[V+8]=g[8],v[V+9]=g[9],v[V+10]=g[10],v[V+11]=g[11],v[V+12]=g[12],v[V+13]=g[13],v[V+14]=g[14],v[V+15]=g[15]}function f(o,v){const V=o.Dg(),g=V[0],E=V[1],I=V[2],Q=V[3],U=V[4],n=V[5],O=V[6],h=V[7],x=V[8],f=V[9],l=V[10],S=V[11],T=V[12],c=V[13],R=V[14],j=V[15],t=l*j-R*S,s=f*j-c*S,L=f*R-c*l,b=x*j-T*S,u=x*R-l*T,mo=x*c-T*f,a=+(n*t-O*s+h*L),F=-(U*t-O*b+h*u),i=+(U*s-n*b+h*mo),J=-(U*L-n*u+O*mo),d=g*a+E*F+I*i+Q*J;if(0===d)return!1;const N=1/d,Y=O*j-R*h,q=n*j-c*h,P=n*R-c*O,M=U*j-T*h,W=U*R-T*O,w=U*c-T*n,z=O*S-l*h,y=n*S-f*h,H=n*l-f*O,e=U*S-x*h,D=U*l-x*O,Z=U*f-x*n,K=-(E*t-I*s+Q*L),X=+(g*t-I*b+Q*u),r=-(g*s-E*b+Q*mo),B=+(g*L-E*u+I*mo),A=+(E*Y-I*q+Q*P),C=-(g*Y-I*M+Q*W),p=+(g*q-E*M+Q*w),G=-(g*P-E*W+I*w),k=-(E*z-I*y+Q*H),oo=+(g*z-I*e+Q*D),vo=-(g*y-E*e+Q*Z),Vo=+(g*H-E*D+I*Z);return v[0]=a*N,v[1]=K*N,v[2]=A*N,v[3]=k*N,v[4]=F*N,v[5]=X*N,v[6]=C*N,v[7]=oo*N,v[8]=i*N,v[9]=r*N,v[10]=p*N,v[11]=vo*N,v[12]=J*N,v[13]=B*N,v[14]=G*N,v[15]=Vo*N,!0}O._UpdateFlagSeed=0;const l=o=>parseInt(o.toString().replace(/\W/g,""));class S{constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=o,this.y=v}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let o=l(this.x);return o=397*o^l(this.y),o}toArray(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o[v]=this.x,o[v+1]=this.y,this}RV(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(o,v,this),this}Dg(){return[this.x,this.y]}U(o){return this.x=o.x,this.y=o.y,this}RU(o,v){return this.x=o,this.y=v,this}set(o,v){return this.RU(o,v)}tU(o){return this.RU(o,o)}add(o){return new S(this.x+o.x,this.y+o.y)}addToRef(o,v){return v.x=this.x+o.x,v.y=this.y+o.y,v}addInPlace(o){return this.x+=o.x,this.y+=o.y,this}addInPlaceFromFloats(o,v){return this.x+=o,this.y+=v,this}addVector3(o){return new S(this.x+o.x,this.y+o.y)}Rv(o){return new S(this.x-o.x,this.y-o.y)}subtractToRef(o,v){return v.x=this.x-o.x,v.y=this.y-o.y,v}Lx(o){return this.x-=o.x,this.y-=o.y,this}multiplyInPlace(o){return this.x*=o.x,this.y*=o.y,this}multiply(o){return new S(this.x*o.x,this.y*o.y)}multiplyToRef(o,v){return v.x=this.x*o.x,v.y=this.y*o.y,v}multiplyByFloats(o,v){return new S(this.x*o,this.y*v)}divide(o){return new S(this.x/o.x,this.y/o.y)}divideToRef(o,v){return v.x=this.x/o.x,v.y=this.y/o.y,v}divideInPlace(o){return this.x=this.x/o.x,this.y=this.y/o.y,this}minimizeInPlace(o){return this.minimizeInPlaceFromFloats(o.x,o.y)}maximizeInPlace(o){return this.maximizeInPlaceFromFloats(o.x,o.y)}minimizeInPlaceFromFloats(o,v){return this.x=Math.min(o,this.x),this.y=Math.min(v,this.y),this}maximizeInPlaceFromFloats(o,v){return this.x=Math.max(o,this.x),this.y=Math.max(v,this.y),this}subtractFromFloats(o,v){return new S(this.x-o,this.y-v)}subtractFromFloatsToRef(o,v,V){return V.x=this.x-o,V.y=this.y-v,V}negate(){return new S(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(o){return o.x=-this.x,o.y=-this.y,o}scaleInPlace(o){return this.x*=o,this.y*=o,this}scale(o){return new S(this.x*o,this.y*o)}scaleToRef(o,v){return v.x=this.x*o,v.y=this.y*o,v}scaleAndAddToRef(o,v){return v.x+=this.x*o,v.y+=this.y*o,v}equals(o){return o&&this.x===o.x&&this.y===o.y}equalsWithEpsilon(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:g.d;return o&&(0,n.WithinEpsilon)(this.x,o.x,v)&&(0,n.WithinEpsilon)(this.y,o.y,v)}equalsToFloats(o,v){return this.x===o&&this.y===v}floor(){return new S(Math.floor(this.x),Math.floor(this.y))}floorToRef(o){return o.x=Math.floor(this.x),o.y=Math.floor(this.y),o}fract(){return new S(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(o){return o.x=this.x-Math.floor(this.x),o.y=this.y-Math.floor(this.y),o}rotate(o){return this.rotateToRef(o,new S)}rotateToRef(o,v){const V=Math.cos(o),g=Math.sin(o);return v.x=V*this.x-g*this.y,v.y=g*this.x+V*this.y,v}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(o){return 0===o||1===o?this:this.scaleInPlace(1/o)}normalizeToNew(){const o=new S;return this.normalizeToRef(o),o}normalizeToRef(o){const v=this.length();return 0===v&&(o.x=this.x,o.y=this.y),this.scaleToRef(1/v,o)}clone(){return new S(this.x,this.y)}dot(o){return this.x*o.x+this.y*o.y}static Zero(){return new S(0,0)}static One(){return new S(1,1)}static Random(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new S((0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v))}static RandomToRef(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).RU((0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v))}static get ZeroReadOnly(){return S._ZeroReadOnly}static bv(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new S(o[v],o[v+1])}static FromArrayToRef(o,v,V){return V.x=o[v],V.y=o[v+1],V}static FromFloatsToRef(o,v,V){return V.RU(o,v),V}static CatmullRom(o,v,V,g,E){const I=E*E,Q=E*I,U=.5*(2*v.x+(-o.x+V.x)*E+(2*o.x-5*v.x+4*V.x-g.x)*I+(-o.x+3*v.x-3*V.x+g.x)*Q),n=.5*(2*v.y+(-o.y+V.y)*E+(2*o.y-5*v.y+4*V.y-g.y)*I+(-o.y+3*v.y-3*V.y+g.y)*Q);return new S(U,n)}static ClampToRef(o,v,V,g){return g.x=(0,n.Clamp)(o.x,v.x,V.x),g.y=(0,n.Clamp)(o.y,v.y,V.y),g}static Clamp(o,v,V){const g=(0,n.Clamp)(o.x,v.x,V.x),E=(0,n.Clamp)(o.y,v.y,V.y);return new S(g,E)}static Hermite(o,v,V,g,E){const I=E*E,Q=E*I,U=2*Q-3*I+1,n=-2*Q+3*I,O=Q-2*I+E,h=Q-I,x=o.x*U+V.x*n+v.x*O+g.x*h,f=o.y*U+V.y*n+v.y*O+g.y*h;return new S(x,f)}static Hermite1stDerivative(o,v,V,g,E){return this.Hermite1stDerivativeToRef(o,v,V,g,E,new S)}static Hermite1stDerivativeToRef(o,v,V,g,E,I){const Q=E*E;return I.x=6*(Q-E)*o.x+(3*Q-4*E+1)*v.x+6*(-Q+E)*V.x+(3*Q-2*E)*g.x,I.y=6*(Q-E)*o.y+(3*Q-4*E+1)*v.y+6*(-Q+E)*V.y+(3*Q-2*E)*g.y,I}static Lerp(o,v,V){return S.LerpToRef(o,v,V,new S)}static LerpToRef(o,v,V,g){return g.x=o.x+(v.x-o.x)*V,g.y=o.y+(v.y-o.y)*V,g}static Dot(o,v){return o.x*v.x+o.y*v.y}static Normalize(o){return S.NormalizeToRef(o,new S)}static NormalizeToRef(o,v){return o.normalizeToRef(v),v}static Minimize(o,v){const V=o.x<v.x?o.x:v.x,g=o.y<v.y?o.y:v.y;return new S(V,g)}static Maximize(o,v){const V=o.x>v.x?o.x:v.x,g=o.y>v.y?o.y:v.y;return new S(V,g)}static Transform(o,v){return S.TransformToRef(o,v,new S)}static TransformToRef(o,v,V){const g=v.m,E=o.x*g[0]+o.y*g[4]+g[12],I=o.x*g[1]+o.y*g[5]+g[13];return V.x=E,V.y=I,V}static PointInTriangle(o,v,V,g){const E=.5*(-V.y*g.x+v.y*(-V.x+g.x)+v.x*(V.y-g.y)+V.x*g.y),I=E<0?-1:1,Q=(v.y*g.x-v.x*g.y+(g.y-v.y)*o.x+(v.x-g.x)*o.y)*I,U=(v.x*V.y-v.y*V.x+(v.y-V.y)*o.x+(V.x-v.x)*o.y)*I;return Q>0&&U>0&&Q+U<2*E*I}static Distance(o,v){return Math.sqrt(S.DistanceSquared(o,v))}static DistanceSquared(o,v){const V=o.x-v.x,g=o.y-v.y;return V*V+g*g}static Center(o,v){return S.CenterToRef(o,v,new S)}static CenterToRef(o,v,V){return V.RU((o.x+v.x)/2,(o.y+v.y)/2)}static DistanceOfPointFromSegment(o,v,V){const g=S.DistanceSquared(v,V);if(0===g)return S.Distance(o,v);const E=V.Rv(v),I=Math.max(0,Math.min(1,S.Dot(o.Rv(v),E)/g)),Q=v.add(E.multiplyByFloats(I,I));return S.Distance(o,Q)}}S._V8PerformanceHack=new S(.5,.5),S._ZeroReadOnly=S.Zero(),Object.defineProperties(S.prototype,{dimension:{value:[2]},rank:{value:1}});class T{get x(){return this._x}set x(o){this._x=o,this._isDirty=!0}get y(){return this._y}set y(o){this._y=o,this._isDirty=!0}get z(){return this._z}set z(o){this._z=o,this._isDirty=!0}constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=o,this._y=v,this._z=V}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"cv"}getHashCode(){let o=l(this._x);return o=397*o^l(this._y),o=397*o^l(this._z),o}Dg(){return[this._x,this._y,this._z]}toArray(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o[v]=this._x,o[v+1]=this._y,o[v+2]=this._z,this}RV(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return T.FromArrayToRef(o,v,this),this}toQuaternion(){return R.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(o){return this._x+=o._x,this._y+=o._y,this._z+=o._z,this._isDirty=!0,this}addInPlaceFromFloats(o,v,V){return this._x+=o,this._y+=v,this._z+=V,this._isDirty=!0,this}add(o){return new T(this._x+o._x,this._y+o._y,this._z+o._z)}addToRef(o,v){return v._x=this._x+o._x,v._y=this._y+o._y,v._z=this._z+o._z,v._isDirty=!0,v}Lx(o){return this._x-=o._x,this._y-=o._y,this._z-=o._z,this._isDirty=!0,this}Rv(o){return new T(this._x-o._x,this._y-o._y,this._z-o._z)}subtractToRef(o,v){return this.subtractFromFloatsToRef(o._x,o._y,o._z,v)}subtractFromFloats(o,v,V){return new T(this._x-o,this._y-v,this._z-V)}subtractFromFloatsToRef(o,v,V,g){return g._x=this._x-o,g._y=this._y-v,g._z=this._z-V,g._isDirty=!0,g}negate(){return new T(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(o){return o._x=-1*this._x,o._y=-1*this._y,o._z=-1*this._z,o._isDirty=!0,o}scaleInPlace(o){return this._x*=o,this._y*=o,this._z*=o,this._isDirty=!0,this}scale(o){return new T(this._x*o,this._y*o,this._z*o)}scaleToRef(o,v){return v._x=this._x*o,v._y=this._y*o,v._z=this._z*o,v._isDirty=!0,v}getNormalToRef(o){const v=this.length();let V=Math.acos(this._y/v);const g=Math.atan2(this._z,this._x);V>Math.PI/2?V-=Math.PI/2:V+=Math.PI/2;const E=v*Math.sin(V)*Math.cos(g),I=v*Math.cos(V),Q=v*Math.sin(V)*Math.sin(g);return o.set(E,I,Q),o}applyRotationQuaternionToRef(o,v){const V=this._x,g=this._y,E=this._z,I=o._x,Q=o._y,U=o._z,n=o._w,O=2*(Q*E-U*g),h=2*(U*V-I*E),x=2*(I*g-Q*V);return v._x=V+n*O+Q*x-U*h,v._y=g+n*h+U*O-I*x,v._z=E+n*x+I*h-Q*O,v._isDirty=!0,v}applyRotationQuaternionInPlace(o){return this.applyRotationQuaternionToRef(o,this)}applyRotationQuaternion(o){return this.applyRotationQuaternionToRef(o,new T)}scaleAndAddToRef(o,v){return v._x+=this._x*o,v._y+=this._y*o,v._z+=this._z*o,v._isDirty=!0,v}projectOnPlane(o,v){return this.projectOnPlaneToRef(o,v,new T)}projectOnPlaneToRef(o,v,V){const g=o.normal,E=o.d,I=t.cv[0];this.subtractToRef(v,I),I.normalize();const Q=T.Dot(I,g);if(Math.abs(Q)<1e-10)V.tU(1/0);else{const o=-(T.Dot(v,g)+E)/Q,U=I.scaleInPlace(o);v.addToRef(U,V)}return V}equals(o){return o&&this._x===o._x&&this._y===o._y&&this._z===o._z}equalsWithEpsilon(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:g.d;return o&&(0,n.WithinEpsilon)(this._x,o._x,v)&&(0,n.WithinEpsilon)(this._y,o._y,v)&&(0,n.WithinEpsilon)(this._z,o._z,v)}equalsToFloats(o,v,V){return this._x===o&&this._y===v&&this._z===V}multiplyInPlace(o){return this._x*=o._x,this._y*=o._y,this._z*=o._z,this._isDirty=!0,this}multiply(o){return this.multiplyByFloats(o._x,o._y,o._z)}multiplyToRef(o,v){return v._x=this._x*o._x,v._y=this._y*o._y,v._z=this._z*o._z,v._isDirty=!0,v}multiplyByFloats(o,v,V){return new T(this._x*o,this._y*v,this._z*V)}divide(o){return new T(this._x/o._x,this._y/o._y,this._z/o._z)}divideToRef(o,v){return v._x=this._x/o._x,v._y=this._y/o._y,v._z=this._z/o._z,v._isDirty=!0,v}divideInPlace(o){return this._x=this._x/o._x,this._y=this._y/o._y,this._z=this._z/o._z,this._isDirty=!0,this}minimizeInPlace(o){return this.minimizeInPlaceFromFloats(o._x,o._y,o._z)}maximizeInPlace(o){return this.maximizeInPlaceFromFloats(o._x,o._y,o._z)}minimizeInPlaceFromFloats(o,v,V){return o<this._x&&(this.x=o),v<this._y&&(this.y=v),V<this._z&&(this.z=V),this}maximizeInPlaceFromFloats(o,v,V){return o>this._x&&(this.x=o),v>this._y&&(this.y=v),V>this._z&&(this.z=V),this}isNonUniformWithinEpsilon(o){const v=Math.abs(this._x),V=Math.abs(this._y);if(!(0,n.WithinEpsilon)(v,V,o))return!0;const g=Math.abs(this._z);return!(0,n.WithinEpsilon)(v,g,o)||!(0,n.WithinEpsilon)(V,g,o)}get isNonUniform(){const o=Math.abs(this._x);if(o!==Math.abs(this._y))return!0;return o!==Math.abs(this._z)}floorToRef(o){return o._x=Math.floor(this._x),o._y=Math.floor(this._y),o._z=Math.floor(this._z),o._isDirty=!0,o}floor(){return new T(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(o){return o._x=this._x-Math.floor(this._x),o._y=this._y-Math.floor(this._y),o._z=this._z-Math.floor(this._z),o._isDirty=!0,o}fract(){return new T(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(o){if("xyz"===(o=o.toLowerCase()))return this;const v=t.cv[0].U(this);return this.x=v[o[0]],this.y=v[o[1]],this.z=v[o[2]],this}rotateByQuaternionToRef(o,v){return o.toRotationMatrix(t.Matrix[0]),T.TransformCoordinatesToRef(this,t.Matrix[0],v),v}rotateByQuaternionAroundPointToRef(o,v,V){return this.subtractToRef(v,t.cv[0]),t.cv[0].rotateByQuaternionToRef(o,t.cv[0]),v.addToRef(t.cv[0],V),V}cross(o){return T.CrossToRef(this,o,new T)}normalizeFromLength(o){return 0===o||1===o?this:this.scaleInPlace(1/o)}normalizeToNew(){return this.normalizeToRef(new T)}normalizeToRef(o){const v=this.length();return 0===v||1===v?(o._x=this._x,o._y=this._y,o._z=this._z,o._isDirty=!0,o):this.scaleToRef(1/v,o)}clone(){return new T(this._x,this._y,this._z)}U(o){return this.RU(o._x,o._y,o._z)}RU(o,v,V){return this._x=o,this._y=v,this._z=V,this._isDirty=!0,this}set(o,v,V){return this.RU(o,v,V)}tU(o){return this._x=this._y=this._z=o,this._isDirty=!0,this}static GetClipFactor(o,v,V,g){const E=T.Dot(o,V);return(E-g)/(E-T.Dot(v,V))}static GetAngleBetweenVectors(o,v,V){const g=o.normalizeToRef(t.cv[1]),E=v.normalizeToRef(t.cv[2]);let I=T.Dot(g,E);I=(0,n.Clamp)(I,-1,1);const Q=Math.acos(I),U=t.cv[3];return T.CrossToRef(g,E,U),T.Dot(U,V)>0?isNaN(Q)?0:Q:isNaN(Q)?-Math.PI:-Math.acos(I)}static GetAngleBetweenVectorsOnPlane(o,v,V){t.cv[0].U(o);const g=t.cv[0];t.cv[1].U(v);const E=t.cv[1];t.cv[2].U(V);const I=t.cv[2],Q=t.cv[3],U=t.cv[4];g.normalize(),E.normalize(),I.normalize(),T.CrossToRef(I,g,Q),T.CrossToRef(Q,I,U);const O=Math.atan2(T.Dot(E,Q),T.Dot(E,U));return(0,n.NormalizeRadians)(O)}static PitchYawRollToMoveBetweenPointsToRef(o,v,V){const g=s.cv[0];return v.subtractToRef(o,g),V._y=Math.atan2(g.x,g.z)||0,V._x=Math.atan2(Math.sqrt(g.x**2+g.z**2),g.y)||0,V._z=0,V._isDirty=!0,V}static PitchYawRollToMoveBetweenPoints(o,v){const V=T.Zero();return T.PitchYawRollToMoveBetweenPointsToRef(o,v,V)}static SlerpToRef(o,v,V,E){V=(0,n.Clamp)(V,0,1);const I=t.cv[0],Q=t.cv[1];I.U(o);const U=I.length();I.normalizeFromLength(U),Q.U(v);const O=Q.length();Q.normalizeFromLength(O);const h=T.Dot(I,Q);let x,f;if(h<1-g.d){const o=Math.acos(h),v=1/Math.sin(o);x=Math.sin((1-V)*o)*v,f=Math.sin(V*o)*v}else x=1-V,f=V;return I.scaleInPlace(x),Q.scaleInPlace(f),E.U(I).addInPlace(Q),E.scaleInPlace((0,n.Lerp)(U,O,V)),E}static SmoothToRef(o,v,V,g,E){return T.SlerpToRef(o,v,0===g?1:V/g,E),E}static bv(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new T(o[v],o[v+1],o[v+2])}static FromFloatArray(o,v){return T.bv(o,v)}static FromArrayToRef(o,v,V){return V._x=o[v],V._y=o[v+1],V._z=o[v+2],V._isDirty=!0,V}static FromFloatArrayToRef(o,v,V){return T.FromArrayToRef(o,v,V)}static FromFloatsToRef(o,v,V,g){return g.RU(o,v,V),g}static Zero(){return new T(0,0,0)}static One(){return new T(1,1,1)}static Up(){return new T(0,1,0)}static get UpReadOnly(){return T._UpReadOnly}static get DownReadOnly(){return T._DownReadOnly}static get RightReadOnly(){return T._RightReadOnly}static get LeftReadOnly(){return T._LeftReadOnly}static get LeftHandedForwardReadOnly(){return T._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return T._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return T._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return T._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return T._ZeroReadOnly}static get OneReadOnly(){return T._OneReadOnly}static Down(){return new T(0,-1,0)}static Forward(){return new T(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new T(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new T(1,0,0)}static Left(){return new T(-1,0,0)}static Random(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new T((0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v))}static RandomToRef(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).RU((0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v))}static TransformCoordinates(o,v){const V=T.Zero();return T.TransformCoordinatesToRef(o,v,V),V}static TransformCoordinatesToRef(o,v,V){return T.TransformCoordinatesFromFloatsToRef(o._x,o._y,o._z,v,V),V}static TransformCoordinatesFromFloatsToRef(o,v,V,g,E){const I=g.m,Q=o*I[0]+v*I[4]+V*I[8]+I[12],U=o*I[1]+v*I[5]+V*I[9]+I[13],n=o*I[2]+v*I[6]+V*I[10]+I[14],O=1/(o*I[3]+v*I[7]+V*I[11]+I[15]);return E._x=Q*O,E._y=U*O,E._z=n*O,E._isDirty=!0,E}static TransformNormal(o,v){const V=T.Zero();return T.TransformNormalToRef(o,v,V),V}static TransformNormalToRef(o,v,V){return this.TransformNormalFromFloatsToRef(o._x,o._y,o._z,v,V),V}static TransformNormalFromFloatsToRef(o,v,V,g,E){const I=g.m;return E._x=o*I[0]+v*I[4]+V*I[8],E._y=o*I[1]+v*I[5]+V*I[9],E._z=o*I[2]+v*I[6]+V*I[10],E._isDirty=!0,E}static CatmullRom(o,v,V,g,E){const I=E*E,Q=E*I,U=.5*(2*v._x+(-o._x+V._x)*E+(2*o._x-5*v._x+4*V._x-g._x)*I+(-o._x+3*v._x-3*V._x+g._x)*Q),n=.5*(2*v._y+(-o._y+V._y)*E+(2*o._y-5*v._y+4*V._y-g._y)*I+(-o._y+3*v._y-3*V._y+g._y)*Q),O=.5*(2*v._z+(-o._z+V._z)*E+(2*o._z-5*v._z+4*V._z-g._z)*I+(-o._z+3*v._z-3*V._z+g._z)*Q);return new T(U,n,O)}static Clamp(o,v,V){const g=new T;return T.ClampToRef(o,v,V,g),g}static ClampToRef(o,v,V,g){let E=o._x;E=E>V._x?V._x:E,E=E<v._x?v._x:E;let I=o._y;I=I>V._y?V._y:I,I=I<v._y?v._y:I;let Q=o._z;return Q=Q>V._z?V._z:Q,Q=Q<v._z?v._z:Q,g.RU(E,I,Q),g}static CheckExtends(o,v,V){v.minimizeInPlace(o),V.maximizeInPlace(o)}static Hermite(o,v,V,g,E){const I=E*E,Q=E*I,U=2*Q-3*I+1,n=-2*Q+3*I,O=Q-2*I+E,h=Q-I,x=o._x*U+V._x*n+v._x*O+g._x*h,f=o._y*U+V._y*n+v._y*O+g._y*h,l=o._z*U+V._z*n+v._z*O+g._z*h;return new T(x,f,l)}static Hermite1stDerivative(o,v,V,g,E){const I=new T;return this.Hermite1stDerivativeToRef(o,v,V,g,E,I),I}static Hermite1stDerivativeToRef(o,v,V,g,E,I){const Q=E*E;return I._x=6*(Q-E)*o._x+(3*Q-4*E+1)*v._x+6*(-Q+E)*V._x+(3*Q-2*E)*g._x,I._y=6*(Q-E)*o._y+(3*Q-4*E+1)*v._y+6*(-Q+E)*V._y+(3*Q-2*E)*g._y,I._z=6*(Q-E)*o._z+(3*Q-4*E+1)*v._z+6*(-Q+E)*V._z+(3*Q-2*E)*g._z,I._isDirty=!0,I}static Lerp(o,v,V){const g=new T(0,0,0);return T.LerpToRef(o,v,V,g),g}static LerpToRef(o,v,V,g){return g._x=o._x+(v._x-o._x)*V,g._y=o._y+(v._y-o._y)*V,g._z=o._z+(v._z-o._z)*V,g._isDirty=!0,g}static Dot(o,v){return o._x*v._x+o._y*v._y+o._z*v._z}dot(o){return this._x*o._x+this._y*o._y+this._z*o._z}static Cross(o,v){const V=new T;return T.CrossToRef(o,v,V),V}static CrossToRef(o,v,V){const g=o._y*v._z-o._z*v._y,E=o._z*v._x-o._x*v._z,I=o._x*v._y-o._y*v._x;return V.RU(g,E,I),V}static Normalize(o){const v=T.Zero();return T.NormalizeToRef(o,v),v}static NormalizeToRef(o,v){return o.normalizeToRef(v),v}static Project(o,v,V,g){const E=new T;return T.ProjectToRef(o,v,V,g,E),E}static ProjectToRef(o,v,V,g,E){var I;const Q=g.width,n=g.height,O=g.x,h=g.y,x=t.Matrix[1],f=null===(I=U.d.LastCreatedEngine)||void 0===I?void 0:I.isNDCHalfZRange,l=f?1:.5,S=f?0:.5;j.FromValuesToRef(Q/2,0,0,0,0,-n/2,0,0,0,0,l,0,O+Q/2,n/2+h,S,1,x);const c=t.Matrix[0];return v.multiplyToRef(V,c),c.multiplyToRef(x,c),T.TransformCoordinatesToRef(o,c,E),E}static Reflect(o,v){return this.ReflectToRef(o,v,new T)}static ReflectToRef(o,v,V){const g=s.cv[0];return g.U(v).scaleInPlace(2*T.Dot(o,v)),V.U(o).Lx(g)}static _UnprojectFromInvertedMatrixToRef(o,v,V){T.TransformCoordinatesToRef(o,v,V);const g=v.m,E=o._x*g[3]+o._y*g[7]+o._z*g[11]+g[15];return(0,n.WithinEpsilon)(E,1)&&V.scaleInPlace(1/E),V}static UnprojectFromTransform(o,v,V,g,E){return this.Unproject(o,v,V,g,E,j.IdentityReadOnly)}static Unproject(o,v,V,g,E,I){const Q=new T;return T.UnprojectToRef(o,v,V,g,E,I,Q),Q}static UnprojectToRef(o,v,V,g,E,I,Q){return T.UnprojectFloatsToRef(o._x,o._y,o._z,v,V,g,E,I,Q),Q}static UnprojectFloatsToRef(o,v,V,g,E,I,Q,n,O){var h;const x=t.Matrix[0];I.multiplyToRef(Q,x),x.multiplyToRef(n,x),x.invert();const f=t.cv[0];return f.x=o/g*2-1,f.y=-(v/E*2-1),null!==(h=U.d.LastCreatedEngine)&&void 0!==h&&h.isNDCHalfZRange?f.z=V:f.z=2*V-1,T._UnprojectFromInvertedMatrixToRef(f,x,O),O}static Minimize(o,v){const V=new T;return V.U(o),V.minimizeInPlace(v),V}static Maximize(o,v){const V=new T;return V.U(o),V.maximizeInPlace(v),V}static Distance(o,v){return Math.sqrt(T.DistanceSquared(o,v))}static DistanceSquared(o,v){const V=o._x-v._x,g=o._y-v._y,E=o._z-v._z;return V*V+g*g+E*E}static ProjectOnTriangleToRef(o,v,V,E,I){const Q=t.cv[0],U=t.cv[1],O=t.cv[2],h=t.cv[3],x=t.cv[4];V.subtractToRef(v,Q),E.subtractToRef(v,U),E.subtractToRef(V,O);const f=Q.length(),l=U.length(),S=O.length();if(f<g.d||l<g.d||S<g.d)return I.U(v),T.Distance(o,v);o.subtractToRef(v,x),T.CrossToRef(Q,U,h);const c=h.length();if(c<g.d)return I.U(v),T.Distance(o,v);h.normalizeFromLength(c);let R=x.length();if(R<g.d)return I.U(v),0;x.normalizeFromLength(R);const j=T.Dot(h,x),s=t.cv[5],L=t.cv[6];s.U(h).scaleInPlace(-R*j),L.U(o).addInPlace(s);const b=t.cv[4],u=t.cv[5],mo=t.cv[7],a=t.cv[8];b.U(Q).scaleInPlace(1/f),a.U(U).scaleInPlace(1/l),b.addInPlace(a).scaleInPlace(-1),u.U(Q).scaleInPlace(-1/f),a.U(O).scaleInPlace(1/S),u.addInPlace(a).scaleInPlace(-1),mo.U(O).scaleInPlace(-1/S),a.U(U).scaleInPlace(-1/l),mo.addInPlace(a).scaleInPlace(-1);const F=t.cv[9];let i;F.U(L).Lx(v),T.CrossToRef(b,F,a),i=T.Dot(a,h);const J=i;F.U(L).Lx(V),T.CrossToRef(u,F,a),i=T.Dot(a,h);const d=i;F.U(L).Lx(E),T.CrossToRef(mo,F,a),i=T.Dot(a,h);const N=i,Y=t.cv[10];let q,P;J>0&&d<0?(Y.U(Q),q=v,P=V):d>0&&N<0?(Y.U(O),q=V,P=E):(Y.U(U).scaleInPlace(-1),q=E,P=v);const M=t.cv[9],W=t.cv[4];q.subtractToRef(L,a),P.subtractToRef(L,M),T.CrossToRef(a,M,W);if(!(T.Dot(W,h)<0))return I.U(L),Math.abs(R*j);const w=t.cv[5];T.CrossToRef(Y,W,w),w.normalize();const z=t.cv[9];z.U(q).Lx(L);const y=z.length();if(y<g.d)return I.U(q),T.Distance(o,q);z.normalizeFromLength(y);const H=T.Dot(w,z),e=t.cv[7];e.U(L).addInPlace(w.scaleInPlace(y*H)),a.U(e).Lx(q),R=Y.length(),Y.normalizeFromLength(R);let D=T.Dot(a,Y)/Math.max(R,g.d);return D=(0,n.Clamp)(D,0,1),e.U(q).addInPlace(Y.scaleInPlace(D*R)),I.U(e),T.Distance(o,e)}static Center(o,v){return T.CenterToRef(o,v,T.Zero())}static CenterToRef(o,v,V){return V.RU((o._x+v._x)/2,(o._y+v._y)/2,(o._z+v._z)/2)}static RotationFromAxis(o,v,V){const g=new T;return T.RotationFromAxisToRef(o,v,V,g),g}static RotationFromAxisToRef(o,v,V,g){const E=t.Quaternion[0];return R.RotationQuaternionFromAxisToRef(o,v,V,E),E.toEulerAnglesToRef(g),g}}T._V8PerformanceHack=new T(.5,.5,.5),T._UpReadOnly=T.Up(),T._DownReadOnly=T.Down(),T._LeftHandedForwardReadOnly=T.Forward(!1),T._RightHandedForwardReadOnly=T.Forward(!0),T._LeftHandedBackwardReadOnly=T.Backward(!1),T._RightHandedBackwardReadOnly=T.Backward(!0),T._RightReadOnly=T.Right(),T._LeftReadOnly=T.Left(),T._ZeroReadOnly=T.Zero(),T._OneReadOnly=T.One(),Object.defineProperties(T.prototype,{dimension:{value:[3]},rank:{value:1}});class c{get x(){return this._x}set x(o){this._x=o,this._isDirty=!0}get y(){return this._y}set y(o){this._y=o,this._isDirty=!0}get z(){return this._z}set z(o){this._z=o,this._isDirty=!0}get w(){return this._w}set w(o){this._w=o,this._isDirty=!0}constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=o,this._y=v,this._z=V,this._w=g}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let o=l(this._x);return o=397*o^l(this._y),o=397*o^l(this._z),o=397*o^l(this._w),o}Dg(){return[this._x,this._y,this._z,this._w]}toArray(o,v){return void 0===v&&(v=0),o[v]=this._x,o[v+1]=this._y,o[v+2]=this._z,o[v+3]=this._w,this}RV(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c.FromArrayToRef(o,v,this),this}addInPlace(o){return this.x+=o._x,this.y+=o._y,this.z+=o._z,this.w+=o._w,this}addInPlaceFromFloats(o,v,V,g){return this.x+=o,this.y+=v,this.z+=V,this.w+=g,this}add(o){return new c(this._x+o.x,this._y+o.y,this._z+o.z,this._w+o.w)}addToRef(o,v){return v.x=this._x+o.x,v.y=this._y+o.y,v.z=this._z+o.z,v.w=this._w+o.w,v}Lx(o){return this.x-=o.x,this.y-=o.y,this.z-=o.z,this.w-=o.w,this}Rv(o){return new c(this._x-o.x,this._y-o.y,this._z-o.z,this._w-o.w)}subtractToRef(o,v){return v.x=this._x-o.x,v.y=this._y-o.y,v.z=this._z-o.z,v.w=this._w-o.w,v}subtractFromFloats(o,v,V,g){return new c(this._x-o,this._y-v,this._z-V,this._w-g)}subtractFromFloatsToRef(o,v,V,g,E){return E.x=this._x-o,E.y=this._y-v,E.z=this._z-V,E.w=this._w-g,E}negate(){return new c(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(o){return o.x=-this._x,o.y=-this._y,o.z=-this._z,o.w=-this._w,o}scaleInPlace(o){return this.x*=o,this.y*=o,this.z*=o,this.w*=o,this}scale(o){return new c(this._x*o,this._y*o,this._z*o,this._w*o)}scaleToRef(o,v){return v.x=this._x*o,v.y=this._y*o,v.z=this._z*o,v.w=this._w*o,v}scaleAndAddToRef(o,v){return v.x+=this._x*o,v.y+=this._y*o,v.z+=this._z*o,v.w+=this._w*o,v}equals(o){return o&&this._x===o.x&&this._y===o.y&&this._z===o.z&&this._w===o.w}equalsWithEpsilon(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:g.d;return o&&(0,n.WithinEpsilon)(this._x,o.x,v)&&(0,n.WithinEpsilon)(this._y,o.y,v)&&(0,n.WithinEpsilon)(this._z,o.z,v)&&(0,n.WithinEpsilon)(this._w,o.w,v)}equalsToFloats(o,v,V,g){return this._x===o&&this._y===v&&this._z===V&&this._w===g}multiplyInPlace(o){return this.x*=o.x,this.y*=o.y,this.z*=o.z,this.w*=o.w,this}multiply(o){return new c(this._x*o.x,this._y*o.y,this._z*o.z,this._w*o.w)}multiplyToRef(o,v){return v.x=this._x*o.x,v.y=this._y*o.y,v.z=this._z*o.z,v.w=this._w*o.w,v}multiplyByFloats(o,v,V,g){return new c(this._x*o,this._y*v,this._z*V,this._w*g)}divide(o){return new c(this._x/o.x,this._y/o.y,this._z/o.z,this._w/o.w)}divideToRef(o,v){return v.x=this._x/o.x,v.y=this._y/o.y,v.z=this._z/o.z,v.w=this._w/o.w,v}divideInPlace(o){return this.divideToRef(o,this)}minimizeInPlace(o){return o.x<this._x&&(this.x=o.x),o.y<this._y&&(this.y=o.y),o.z<this._z&&(this.z=o.z),o.w<this._w&&(this.w=o.w),this}maximizeInPlace(o){return o.x>this._x&&(this.x=o.x),o.y>this._y&&(this.y=o.y),o.z>this._z&&(this.z=o.z),o.w>this._w&&(this.w=o.w),this}minimizeInPlaceFromFloats(o,v,V,g){return this.x=Math.min(o,this._x),this.y=Math.min(v,this._y),this.z=Math.min(V,this._z),this.w=Math.min(g,this._w),this}maximizeInPlaceFromFloats(o,v,V,g){return this.x=Math.max(o,this._x),this.y=Math.max(v,this._y),this.z=Math.max(V,this._z),this.w=Math.max(g,this._w),this}floorToRef(o){return o.x=Math.floor(this._x),o.y=Math.floor(this._y),o.z=Math.floor(this._z),o.w=Math.floor(this._w),o}floor(){return new c(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(o){return o.x=this._x-Math.floor(this._x),o.y=this._y-Math.floor(this._y),o.z=this._z-Math.floor(this._z),o.w=this._w-Math.floor(this._w),o}fract(){return new c(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(o){return 0===o||1===o?this:this.scaleInPlace(1/o)}normalizeToNew(){return this.normalizeToRef(new c)}normalizeToRef(o){const v=this.length();return 0===v||1===v?(o.x=this._x,o.y=this._y,o.z=this._z,o.w=this._w,o):this.scaleToRef(1/v,o)}toVector3(){return new T(this._x,this._y,this._z)}clone(){return new c(this._x,this._y,this._z,this._w)}U(o){return this.x=o.x,this.y=o.y,this.z=o.z,this.w=o.w,this}RU(o,v,V,g){return this.x=o,this.y=v,this.z=V,this.w=g,this}set(o,v,V,g){return this.RU(o,v,V,g)}tU(o){return this.x=this.y=this.z=this.w=o,this}dot(o){return this._x*o.x+this._y*o.y+this._z*o.z+this._w*o.w}static bv(o,v){return v||(v=0),new c(o[v],o[v+1],o[v+2],o[v+3])}static FromArrayToRef(o,v,V){return V.x=o[v],V.y=o[v+1],V.z=o[v+2],V.w=o[v+3],V}static FromFloatArrayToRef(o,v,V){return c.FromArrayToRef(o,v,V),V}static FromFloatsToRef(o,v,V,g,E){return E.x=o,E.y=v,E.z=V,E.w=g,E}static Zero(){return new c(0,0,0,0)}static One(){return new c(1,1,1,1)}static Random(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new c((0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v))}static RandomToRef(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,V=arguments.length>2?arguments[2]:void 0;return V.x=(0,n.RandomRange)(o,v),V.y=(0,n.RandomRange)(o,v),V.z=(0,n.RandomRange)(o,v),V.w=(0,n.RandomRange)(o,v),V}static Clamp(o,v,V){return c.ClampToRef(o,v,V,new c)}static ClampToRef(o,v,V,g){return g.x=(0,n.Clamp)(o.x,v.x,V.x),g.y=(0,n.Clamp)(o.y,v.y,V.y),g.z=(0,n.Clamp)(o.z,v.z,V.z),g.w=(0,n.Clamp)(o.w,v.w,V.w),g}static CheckExtends(o,v,V){v.minimizeInPlace(o),V.maximizeInPlace(o)}static get ZeroReadOnly(){return c._ZeroReadOnly}static Normalize(o){return c.NormalizeToRef(o,new c)}static NormalizeToRef(o,v){return o.normalizeToRef(v),v}static Minimize(o,v){const V=new c;return V.U(o),V.minimizeInPlace(v),V}static Maximize(o,v){const V=new c;return V.U(o),V.maximizeInPlace(v),V}static Distance(o,v){return Math.sqrt(c.DistanceSquared(o,v))}static DistanceSquared(o,v){const V=o.x-v.x,g=o.y-v.y,E=o.z-v.z,I=o.w-v.w;return V*V+g*g+E*E+I*I}static Center(o,v){return c.CenterToRef(o,v,new c)}static CenterToRef(o,v,V){return V.x=(o.x+v.x)/2,V.y=(o.y+v.y)/2,V.z=(o.z+v.z)/2,V.w=(o.w+v.w)/2,V}static TransformCoordinates(o,v){return c.TransformCoordinatesToRef(o,v,new c)}static TransformCoordinatesToRef(o,v,V){return c.TransformCoordinatesFromFloatsToRef(o._x,o._y,o._z,v,V),V}static TransformCoordinatesFromFloatsToRef(o,v,V,g,E){const I=g.m,Q=o*I[0]+v*I[4]+V*I[8]+I[12],U=o*I[1]+v*I[5]+V*I[9]+I[13],n=o*I[2]+v*I[6]+V*I[10]+I[14],O=o*I[3]+v*I[7]+V*I[11]+I[15];return E.x=Q,E.y=U,E.z=n,E.w=O,E}static TransformNormal(o,v){return c.TransformNormalToRef(o,v,new c)}static TransformNormalToRef(o,v,V){const g=v.m,E=o.x*g[0]+o.y*g[4]+o.z*g[8],I=o.x*g[1]+o.y*g[5]+o.z*g[9],Q=o.x*g[2]+o.y*g[6]+o.z*g[10];return V.x=E,V.y=I,V.z=Q,V.w=o.w,V}static TransformNormalFromFloatsToRef(o,v,V,g,E,I){const Q=E.m;return I.x=o*Q[0]+v*Q[4]+V*Q[8],I.y=o*Q[1]+v*Q[5]+V*Q[9],I.z=o*Q[2]+v*Q[6]+V*Q[10],I.w=g,I}static FromVector3(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new c(o._x,o._y,o._z,v)}static Dot(o,v){return o.x*v.x+o.y*v.y+o.z*v.z+o.w*v.w}}c._V8PerformanceHack=new c(.5,.5,.5,.5),c._ZeroReadOnly=c.Zero(),Object.defineProperties(c.prototype,{dimension:{value:[4]},rank:{value:1}});class R{get x(){return this._x}set x(o){this._x=o,this._isDirty=!0}get y(){return this._y}set y(o){this._y=o,this._isDirty=!0}get z(){return this._z}set z(o){this._z=o,this._isDirty=!0}get w(){return this._w}set w(o){this._w=o,this._isDirty=!0}constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=o,this._y=v,this._z=V,this._w=g}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let o=l(this._x);return o=397*o^l(this._y),o=397*o^l(this._z),o=397*o^l(this._w),o}Dg(){return[this._x,this._y,this._z,this._w]}toArray(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o[v]=this._x,o[v+1]=this._y,o[v+2]=this._z,o[v+3]=this._w,this}RV(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R.FromArrayToRef(o,v,this)}equals(o){return o&&this._x===o._x&&this._y===o._y&&this._z===o._z&&this._w===o._w}equalsWithEpsilon(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:g.d;return o&&(0,n.WithinEpsilon)(this._x,o._x,v)&&(0,n.WithinEpsilon)(this._y,o._y,v)&&(0,n.WithinEpsilon)(this._z,o._z,v)&&(0,n.WithinEpsilon)(this._w,o._w,v)}isApprox(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:g.d;return o&&((0,n.WithinEpsilon)(this._x,o._x,v)&&(0,n.WithinEpsilon)(this._y,o._y,v)&&(0,n.WithinEpsilon)(this._z,o._z,v)&&(0,n.WithinEpsilon)(this._w,o._w,v)||(0,n.WithinEpsilon)(this._x,-o._x,v)&&(0,n.WithinEpsilon)(this._y,-o._y,v)&&(0,n.WithinEpsilon)(this._z,-o._z,v)&&(0,n.WithinEpsilon)(this._w,-o._w,v))}clone(){return new R(this._x,this._y,this._z,this._w)}U(o){return this._x=o._x,this._y=o._y,this._z=o._z,this._w=o._w,this._isDirty=!0,this}RU(o,v,V,g){return this._x=o,this._y=v,this._z=V,this._w=g,this._isDirty=!0,this}set(o,v,V,g){return this.RU(o,v,V,g)}tU(o){return this.RU(o,o,o,o)}add(o){return new R(this._x+o._x,this._y+o._y,this._z+o._z,this._w+o._w)}addInPlace(o){return this._x+=o._x,this._y+=o._y,this._z+=o._z,this._w+=o._w,this._isDirty=!0,this}addToRef(o,v){return v._x=this._x+o._x,v._y=this._y+o._y,v._z=this._z+o._z,v._w=this._w+o._w,v._isDirty=!0,v}addInPlaceFromFloats(o,v,V,g){return this._x+=o,this._y+=v,this._z+=V,this._w+=g,this._isDirty=!0,this}subtractToRef(o,v){return v._x=this._x-o._x,v._y=this._y-o._y,v._z=this._z-o._z,v._w=this._w-o._w,v._isDirty=!0,v}subtractFromFloats(o,v,V,g){return this.subtractFromFloatsToRef(o,v,V,g,new R)}subtractFromFloatsToRef(o,v,V,g,E){return E._x=this._x-o,E._y=this._y-v,E._z=this._z-V,E._w=this._w-g,E._isDirty=!0,E}Rv(o){return new R(this._x-o._x,this._y-o._y,this._z-o._z,this._w-o._w)}Lx(o){return this._x-=o._x,this._y-=o._y,this._z-=o._z,this._w-=o._w,this._isDirty=!0,this}scale(o){return new R(this._x*o,this._y*o,this._z*o,this._w*o)}scaleToRef(o,v){return v._x=this._x*o,v._y=this._y*o,v._z=this._z*o,v._w=this._w*o,v._isDirty=!0,v}scaleInPlace(o){return this._x*=o,this._y*=o,this._z*=o,this._w*=o,this._isDirty=!0,this}scaleAndAddToRef(o,v){return v._x+=this._x*o,v._y+=this._y*o,v._z+=this._z*o,v._w+=this._w*o,v._isDirty=!0,v}multiply(o){const v=new R(0,0,0,1);return this.multiplyToRef(o,v),v}multiplyToRef(o,v){const V=this._x*o._w+this._y*o._z-this._z*o._y+this._w*o._x,g=-this._x*o._z+this._y*o._w+this._z*o._x+this._w*o._y,E=this._x*o._y-this._y*o._x+this._z*o._w+this._w*o._z,I=-this._x*o._x-this._y*o._y-this._z*o._z+this._w*o._w;return v.RU(V,g,E,I),v}multiplyInPlace(o){return this.multiplyToRef(o,this)}multiplyByFloats(o,v,V,g){return this._x*=o,this._y*=v,this._z*=V,this._w*=g,this._isDirty=!0,this}divide(o){throw new ReferenceError("Can not divide a quaternion")}divideToRef(o,v){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(o){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new R)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(o){return o._x=-this._x,o._y=-this._y,o._z=-this._z,o._w=-this._w,o._isDirty=!0,o}equalsToFloats(o,v,V,g){return this._x===o&&this._y===v&&this._z===V&&this._w===g}floorToRef(o){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(o){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(o){return o.RU(-this._x,-this._y,-this._z,this._w),o}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new R(-this._x,-this._y,-this._z,this._w)}invert(){const o=this.conjugate(),v=this.lengthSquared();return 0==v||1==v||o.scaleInPlace(1/v),o}invertInPlace(){this.conjugateInPlace();const o=this.lengthSquared();return 0==o||1==o||this.scaleInPlace(1/o),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(o){return 0===o||1===o?this:this.scaleInPlace(1/o)}normalizeToNew(){const o=new R(0,0,0,1);return this.normalizeToRef(o),o}normalizeToRef(o){const v=this.length();return 0===v||1===v?o.RU(this._x,this._y,this._z,this._w):this.scaleToRef(1/v,o)}toEulerAngles(){const o=T.Zero();return this.toEulerAnglesToRef(o),o}toEulerAnglesToRef(o){const v=this._z,V=this._x,g=this._y,E=this._w,I=g*v-V*E,Q=.4999999;if(I<-Q)o._y=2*Math.atan2(g,E),o._x=Math.PI/2,o._z=0,o._isDirty=!0;else if(I>Q)o._y=2*Math.atan2(g,E),o._x=-Math.PI/2,o._z=0,o._isDirty=!0;else{const Q=E*E,U=v*v,n=V*V,O=g*g;o._z=Math.atan2(2*(V*g+v*E),-U-n+O+Q),o._x=Math.asin(-2*I),o._y=Math.atan2(2*(v*V+g*E),U-n-O+Q),o._isDirty=!0}return o}toAlphaBetaGammaToRef(o){const v=this._z,V=this._x,g=this._y,E=this._w,I=Math.sqrt(V*V+g*g),Q=Math.sqrt(v*v+E*E),U=2*Math.atan2(I,Q),n=2*Math.atan2(v,E),O=2*Math.atan2(g,V),h=(n+O)/2,x=(n-O)/2;return o.set(x,U,h),o}toRotationMatrix(o){return j.FromQuaternionToRef(this,o),o}fromRotationMatrix(o){return R.FromRotationMatrixToRef(o,this),this}dot(o){return this._x*o._x+this._y*o._y+this._z*o._z+this._w*o._w}toAxisAngle(){const o=T.Zero();return{axis:o,angle:this.toAxisAngleToRef(o)}}toAxisAngleToRef(o){let v=0;const V=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),g=this._w;return V>0?(v=2*Math.atan2(V,g),o.set(this._x/V,this._y/V,this._z/V)):(v=0,o.set(1,0,0)),v}static FromRotationMatrix(o){const v=new R;return R.FromRotationMatrixToRef(o,v),v}static FromRotationMatrixToRef(o,v){const V=o.m,g=V[0],E=V[4],I=V[8],Q=V[1],U=V[5],n=V[9],O=V[2],h=V[6],x=V[10],f=g+U+x;let l;return f>0?(l=.5/Math.sqrt(f+1),v._w=.25/l,v._x=(h-n)*l,v._y=(I-O)*l,v._z=(Q-E)*l,v._isDirty=!0):g>U&&g>x?(l=2*Math.sqrt(1+g-U-x),v._w=(h-n)/l,v._x=.25*l,v._y=(E+Q)/l,v._z=(I+O)/l,v._isDirty=!0):U>x?(l=2*Math.sqrt(1+U-g-x),v._w=(I-O)/l,v._x=(E+Q)/l,v._y=.25*l,v._z=(n+h)/l,v._isDirty=!0):(l=2*Math.sqrt(1+x-g-U),v._w=(Q-E)/l,v._x=(I+O)/l,v._y=(n+h)/l,v._z=.25*l,v._isDirty=!0),v}static Dot(o,v){return o._x*v._x+o._y*v._y+o._z*v._z+o._w*v._w}static AreClose(o,v){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const g=R.Dot(o,v);return 1-g*g<=V}static SmoothToRef(o,v,V,g,E){let I=0===g?1:V/g;return I=(0,n.Clamp)(I,0,1),R.SlerpToRef(o,v,I,E),E}static Zero(){return new R(0,0,0,0)}static Inverse(o){return new R(-o._x,-o._y,-o._z,o._w)}static InverseToRef(o,v){return v.set(-o._x,-o._y,-o._z,o._w),v}static Identity(){return new R(0,0,0,1)}static IsIdentity(o){return o&&0===o._x&&0===o._y&&0===o._z&&1===o._w}static RotationAxis(o,v){return R.RotationAxisToRef(o,v,new R)}static RotationAxisToRef(o,v,V){V._w=Math.cos(v/2);const g=Math.sin(v/2)/o.length();return V._x=o._x*g,V._y=o._y*g,V._z=o._z*g,V._isDirty=!0,V}static bv(o,v){return v||(v=0),new R(o[v],o[v+1],o[v+2],o[v+3])}static FromArrayToRef(o,v,V){return V._x=o[v],V._y=o[v+1],V._z=o[v+2],V._w=o[v+3],V._isDirty=!0,V}static FromFloatsToRef(o,v,V,g,E){return E.RU(o,v,V,g),E}static FromEulerAngles(o,v,V){const g=new R;return R.RotationYawPitchRollToRef(v,o,V,g),g}static FromEulerAnglesToRef(o,v,V,g){return R.RotationYawPitchRollToRef(v,o,V,g),g}static FromEulerVector(o){const v=new R;return R.RotationYawPitchRollToRef(o._y,o._x,o._z,v),v}static FromEulerVectorToRef(o,v){return R.RotationYawPitchRollToRef(o._y,o._x,o._z,v),v}static FromUnitVectorsToRef(o,v,V){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g.d;const I=T.Dot(o,v)+1;return I<E?Math.abs(o.x)>Math.abs(o.z)?V.set(-o.y,o.x,0,0):V.set(0,-o.z,o.y,0):(T.CrossToRef(o,v,s.cv[0]),V.set(s.cv[0].x,s.cv[0].y,s.cv[0].z,I)),V.normalize()}static RotationYawPitchRoll(o,v,V){const g=new R;return R.RotationYawPitchRollToRef(o,v,V,g),g}static RotationYawPitchRollToRef(o,v,V,g){const E=.5*V,I=.5*v,Q=.5*o,U=Math.sin(E),n=Math.cos(E),O=Math.sin(I),h=Math.cos(I),x=Math.sin(Q),f=Math.cos(Q);return g._x=f*O*n+x*h*U,g._y=x*h*n-f*O*U,g._z=f*h*U-x*O*n,g._w=f*h*n+x*O*U,g._isDirty=!0,g}static RotationAlphaBetaGamma(o,v,V){const g=new R;return R.RotationAlphaBetaGammaToRef(o,v,V,g),g}static RotationAlphaBetaGammaToRef(o,v,V,g){const E=.5*(V+o),I=.5*(V-o),Q=.5*v;return g._x=Math.cos(I)*Math.sin(Q),g._y=Math.sin(I)*Math.sin(Q),g._z=Math.sin(E)*Math.cos(Q),g._w=Math.cos(E)*Math.cos(Q),g._isDirty=!0,g}static RotationQuaternionFromAxis(o,v,V){const g=new R(0,0,0,0);return R.RotationQuaternionFromAxisToRef(o,v,V,g),g}static RotationQuaternionFromAxisToRef(o,v,V,g){const E=t.Matrix[0];return o=o.normalizeToRef(t.cv[0]),v=v.normalizeToRef(t.cv[1]),V=V.normalizeToRef(t.cv[2]),j.FromXYZAxesToRef(o,v,V,E),R.FromRotationMatrixToRef(E,g),g}static FromLookDirectionLH(o,v){const V=new R;return R.FromLookDirectionLHToRef(o,v,V),V}static FromLookDirectionLHToRef(o,v,V){const g=t.Matrix[0];return j.LookDirectionLHToRef(o,v,g),R.FromRotationMatrixToRef(g,V),V}static FromLookDirectionRH(o,v){const V=new R;return R.FromLookDirectionRHToRef(o,v,V),V}static FromLookDirectionRHToRef(o,v,V){const g=t.Matrix[0];return j.LookDirectionRHToRef(o,v,g),R.FromRotationMatrixToRef(g,V)}static Slerp(o,v,V){const g=R.Identity();return R.SlerpToRef(o,v,V,g),g}static SlerpToRef(o,v,V,g){let E,I,Q=o._x*v._x+o._y*v._y+o._z*v._z+o._w*v._w,U=!1;if(Q<0&&(U=!0,Q=-Q),Q>.999999)I=1-V,E=U?-V:V;else{const o=Math.acos(Q),v=1/Math.sin(o);I=Math.sin((1-V)*o)*v,E=U?-Math.sin(V*o)*v:Math.sin(V*o)*v}return g._x=I*o._x+E*v._x,g._y=I*o._y+E*v._y,g._z=I*o._z+E*v._z,g._w=I*o._w+E*v._w,g._isDirty=!0,g}static Hermite(o,v,V,g,E){const I=E*E,Q=E*I,U=2*Q-3*I+1,n=-2*Q+3*I,O=Q-2*I+E,h=Q-I,x=o._x*U+V._x*n+v._x*O+g._x*h,f=o._y*U+V._y*n+v._y*O+g._y*h,l=o._z*U+V._z*n+v._z*O+g._z*h,S=o._w*U+V._w*n+v._w*O+g._w*h;return new R(x,f,l,S)}static Hermite1stDerivative(o,v,V,g,E){const I=new R;return this.Hermite1stDerivativeToRef(o,v,V,g,E,I),I}static Hermite1stDerivativeToRef(o,v,V,g,E,I){const Q=E*E;return I._x=6*(Q-E)*o._x+(3*Q-4*E+1)*v._x+6*(-Q+E)*V._x+(3*Q-2*E)*g._x,I._y=6*(Q-E)*o._y+(3*Q-4*E+1)*v._y+6*(-Q+E)*V._y+(3*Q-2*E)*g._y,I._z=6*(Q-E)*o._z+(3*Q-4*E+1)*v._z+6*(-Q+E)*V._z+(3*Q-2*E)*g._z,I._w=6*(Q-E)*o._w+(3*Q-4*E+1)*v._w+6*(-Q+E)*V._w+(3*Q-2*E)*g._w,I._isDirty=!0,I}static Normalize(o){const v=R.Zero();return R.NormalizeToRef(o,v),v}static NormalizeToRef(o,v){return o.normalizeToRef(v),v}static Clamp(o,v,V){const g=new R;return R.ClampToRef(o,v,V,g),g}static ClampToRef(o,v,V,g){return g.RU((0,n.Clamp)(o.x,v.x,V.x),(0,n.Clamp)(o.y,v.y,V.y),(0,n.Clamp)(o.z,v.z,V.z),(0,n.Clamp)(o.w,v.w,V.w))}static Random(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new R((0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v))}static RandomToRef(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).RU((0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v),(0,n.RandomRange)(o,v))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(o,v){return Math.sqrt(R.DistanceSquared(o,v))}static DistanceSquared(o,v){const V=o.x-v.x,g=o.y-v.y,E=o.z-v.z,I=o.w-v.w;return V*V+g*g+E*E+I*I}static Center(o,v){return R.CenterToRef(o,v,R.Zero())}static CenterToRef(o,v,V){return V.RU((o.x+v.x)/2,(o.y+v.y)/2,(o.z+v.z)/2,(o.w+v.w)/2)}}R._V8PerformanceHack=new R(.5,.5,.5,.5),Object.defineProperties(R.prototype,{dimension:{value:[4]},rank:{value:1}});class j{static get Use64Bits(){return Q.d.MatrixUse64Bits}get m(){return this.tg}markAsUpdated(){this.updateFlag=O._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(o){let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1],V=arguments.length>2&&void 0!==arguments[2]&&arguments[2],g=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=o,this._isIdentity3x2=o||V,this._isIdentityDirty=!this._isIdentity&&v,this._isIdentity3x2Dirty=!this._isIdentity3x2&&g}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,Q.d.MatrixTrackPrecisionChange&&Q.d.MatrixTrackedMatrices.push(this),this.tg=new Q.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const o=this.tg;this._isIdentity=1===o[0]&&0===o[1]&&0===o[2]&&0===o[3]&&0===o[4]&&1===o[5]&&0===o[6]&&0===o[7]&&0===o[8]&&0===o[9]&&1===o[10]&&0===o[11]&&0===o[12]&&0===o[13]&&0===o[14]&&1===o[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.tg[0]||1!==this.tg[5]||1!==this.tg[15]||0!==this.tg[1]||0!==this.tg[2]||0!==this.tg[3]||0!==this.tg[4]||0!==this.tg[6]||0!==this.tg[7]||0!==this.tg[8]||0!==this.tg[9]||0!==this.tg[10]||0!==this.tg[11]||0!==this.tg[12]||0!==this.tg[13]||0!==this.tg[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const o=this.tg,v=o[0],V=o[1],g=o[2],E=o[3],I=o[4],Q=o[5],U=o[6],n=o[7],O=o[8],h=o[9],x=o[10],f=o[11],l=o[12],S=o[13],T=o[14],c=o[15],R=x*c-T*f,j=h*c-S*f,t=h*T-S*x,s=O*c-l*f,L=O*T-x*l,b=O*S-l*h;return v*+(Q*R-U*j+n*t)+V*-(I*R-U*s+n*L)+g*+(I*j-Q*s+n*b)+E*-(I*t-Q*L+U*b)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!o)return this.tg;const V=this.tg;for(let g=0;g<16;g++)o[v+g]=V[g];return this}Dg(){return this.tg}RV(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return j.FromArrayToRef(o,v,this)}RU(){for(var o=arguments.length,v=new Array(o),V=0;V<o;V++)v[V]=arguments[V];return j.FromArrayToRef(v,0,this)}set(){const o=this.tg;for(let v=0;v<16;v++)o[v]=v<0||arguments.length<=v?void 0:arguments[v];return this.markAsUpdated(),this}tU(o){const v=this.tg;for(let V=0;V<16;V++)v[V]=o;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return j.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(o){const v=new j;return this.addToRef(o,v),v}addToRef(o,v){const V=this.tg,g=v.tg,E=o.m;for(let I=0;I<16;I++)g[I]=V[I]+E[I];return v.markAsUpdated(),v}addToSelf(o){const v=this.tg,V=o.m;return v[0]+=V[0],v[1]+=V[1],v[2]+=V[2],v[3]+=V[3],v[4]+=V[4],v[5]+=V[5],v[6]+=V[6],v[7]+=V[7],v[8]+=V[8],v[9]+=V[9],v[10]+=V[10],v[11]+=V[11],v[12]+=V[12],v[13]+=V[13],v[14]+=V[14],v[15]+=V[15],this.markAsUpdated(),this}addInPlace(o){const v=this.tg,V=o.m;for(let g=0;g<16;g++)v[g]+=V[g];return this.markAsUpdated(),this}addInPlaceFromFloats(){const o=this.tg;for(let v=0;v<16;v++)o[v]+=v<0||arguments.length<=v?void 0:arguments[v];return this.markAsUpdated(),this}Rv(o){const v=this.tg,V=o.m;for(let g=0;g<16;g++)v[g]-=V[g];return this.markAsUpdated(),this}subtractToRef(o,v){const V=this.tg,g=o.m,E=v.tg;for(let I=0;I<16;I++)E[I]=V[I]-g[I];return v.markAsUpdated(),v}Lx(o){const v=this.tg,V=o.m;for(let g=0;g<16;g++)v[g]-=V[g];return this.markAsUpdated(),this}subtractFromFloats(){for(var o=arguments.length,v=new Array(o),V=0;V<o;V++)v[V]=arguments[V];return this.subtractFromFloatsToRef(...v,new j)}subtractFromFloatsToRef(){for(var o=arguments.length,v=new Array(o),V=0;V<o;V++)v[V]=arguments[V];const g=v.pop(),E=this.tg,I=g.tg,Q=v;for(let U=0;U<16;U++)I[U]=E[U]-Q[U];return g.markAsUpdated(),g}invertToRef(o){return!0===this._isIdentity?(j.IdentityToRef(o),o):(f(this,o.Dg())?o.markAsUpdated():o.U(this),o)}addAtIndex(o,v){return this.tg[o]+=v,this.markAsUpdated(),this}multiplyAtIndex(o,v){return this.tg[o]*=v,this.markAsUpdated(),this}setTranslationFromFloats(o,v,V){return this.tg[12]=o,this.tg[13]=v,this.tg[14]=V,this.markAsUpdated(),this}addTranslationFromFloats(o,v,V){return this.tg[12]+=o,this.tg[13]+=v,this.tg[14]+=V,this.markAsUpdated(),this}setTranslation(o){return this.setTranslationFromFloats(o._x,o._y,o._z)}getTranslation(){return new T(this.tg[12],this.tg[13],this.tg[14])}getTranslationToRef(o){return o.x=this.tg[12],o.y=this.tg[13],o.z=this.tg[14],o}removeRotationAndScaling(){const o=this.m;return j.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,o[12],o[13],o[14],o[15],this),this._updateIdentityStatus(0===o[12]&&0===o[13]&&0===o[14]&&1===o[15]),this}U(o){o.copyToArray(this.tg);const v=o;return this.updateFlag=v.updateFlag,this._updateIdentityStatus(v._isIdentity,v._isIdentityDirty,v._isIdentity3x2,v._isIdentity3x2Dirty),this}copyToArray(o){return x(this,o,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(o){const v=new j;return this.multiplyToRef(o,v),v}multiplyInPlace(o){const v=this.tg,V=o.m;for(let g=0;g<16;g++)v[g]*=V[g];return this.markAsUpdated(),this}multiplyByFloats(){const o=this.tg;for(let v=0;v<16;v++)o[v]*=v<0||arguments.length<=v?void 0:arguments[v];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var o=arguments.length,v=new Array(o),V=0;V<o;V++)v[V]=arguments[V];const g=v.pop(),E=this.tg,I=g.tg,Q=v;for(let U=0;U<16;U++)I[U]=E[U]*Q[U];return g.markAsUpdated(),g}multiplyToRef(o,v){return this._isIdentity?(v.U(o),v):o._isIdentity?(v.U(this),v):(this.multiplyToArray(o,v.tg,0),v.markAsUpdated(),v)}multiplyToArray(o,v,V){return h(this,o,v,V),this}divide(o){return this.divideToRef(o,new j)}divideToRef(o,v){const V=this.tg,g=o.m,E=v.tg;for(let I=0;I<16;I++)E[I]=V[I]/g[I];return v.markAsUpdated(),v}divideInPlace(o){const v=this.tg,V=o.m;for(let g=0;g<16;g++)v[g]/=V[g];return this.markAsUpdated(),this}minimizeInPlace(o){const v=this.tg,V=o.m;for(let g=0;g<16;g++)v[g]=Math.min(v[g],V[g]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const o=this.tg;for(let v=0;v<16;v++)o[v]=Math.min(o[v],v<0||arguments.length<=v?void 0:arguments[v]);return this.markAsUpdated(),this}maximizeInPlace(o){const v=this.tg,V=o.m;for(let g=0;g<16;g++)v[g]=Math.min(v[g],V[g]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const o=this.tg;for(let v=0;v<16;v++)o[v]=Math.min(o[v],v<0||arguments.length<=v?void 0:arguments[v]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new j)}negateInPlace(){const o=this.tg;for(let v=0;v<16;v++)o[v]=-o[v];return this.markAsUpdated(),this}negateToRef(o){const v=this.tg,V=o.tg;for(let g=0;g<16;g++)V[g]=-v[g];return o.markAsUpdated(),o}equals(o){const v=o;if(!v)return!1;if((this._isIdentity||v._isIdentity)&&!this._isIdentityDirty&&!v._isIdentityDirty)return this._isIdentity&&v._isIdentity;const V=this.m,g=v.m;return V[0]===g[0]&&V[1]===g[1]&&V[2]===g[2]&&V[3]===g[3]&&V[4]===g[4]&&V[5]===g[5]&&V[6]===g[6]&&V[7]===g[7]&&V[8]===g[8]&&V[9]===g[9]&&V[10]===g[10]&&V[11]===g[11]&&V[12]===g[12]&&V[13]===g[13]&&V[14]===g[14]&&V[15]===g[15]}equalsWithEpsilon(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const V=this.tg,g=o.m;for(let E=0;E<16;E++)if(!(0,n.WithinEpsilon)(V[E],g[E],v))return!1;return!0}equalsToFloats(){const o=this.tg;for(let v=0;v<16;v++)if(o[v]!=(v<0||arguments.length<=v?void 0:arguments[v]))return!1;return!0}floor(){return this.floorToRef(new j)}floorToRef(o){const v=this.tg,V=o.tg;for(let g=0;g<16;g++)V[g]=Math.floor(v[g]);return o.markAsUpdated(),o}fract(){return this.fractToRef(new j)}fractToRef(o){const v=this.tg,V=o.tg;for(let g=0;g<16;g++)V[g]=v[g]-Math.floor(v[g]);return o.markAsUpdated(),o}clone(){const o=new j;return o.U(this),o}getClassName(){return"Matrix"}getHashCode(){let o=l(this.tg[0]);for(let v=1;v<16;v++)o=397*o^l(this.tg[v]);return o}decomposeToTransformNode(o){return o.rotationQuaternion=o.rotationQuaternion||new R,this.decompose(o.jU,o.rotationQuaternion,o.position)}decompose(o,v,V,g){let E=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return V&&V.tU(0),o&&o.tU(1),v&&v.RU(0,0,0,1),!0;const I=this.tg;if(V&&V.RU(I[12],I[13],I[14]),(o=o||t.cv[0]).x=Math.sqrt(I[0]*I[0]+I[1]*I[1]+I[2]*I[2]),o.y=Math.sqrt(I[4]*I[4]+I[5]*I[5]+I[6]*I[6]),o.z=Math.sqrt(I[8]*I[8]+I[9]*I[9]+I[10]*I[10]),g){const v=(E?g.absoluteScaling.x:g.jU.x)<0?-1:1,V=(E?g.absoluteScaling.y:g.jU.y)<0?-1:1,I=(E?g.absoluteScaling.z:g.jU.z)<0?-1:1;o.x*=v,o.y*=V,o.z*=I}else this.determinant()<=0&&(o.y*=-1);if(0===o._x||0===o._y||0===o._z)return v&&v.RU(0,0,0,1),!1;if(v){const V=1/o._x,g=1/o._y,E=1/o._z;j.FromValuesToRef(I[0]*V,I[1]*V,I[2]*V,0,I[4]*g,I[5]*g,I[6]*g,0,I[8]*E,I[9]*E,I[10]*E,0,0,0,0,1,t.Matrix[0]),R.FromRotationMatrixToRef(t.Matrix[0],v)}return!0}getRow(o){if(o<0||o>3)return null;const v=4*o;return new c(this.tg[v+0],this.tg[v+1],this.tg[v+2],this.tg[v+3])}getRowToRef(o,v){if(o>=0&&o<=3){const V=4*o;v.x=this.tg[V+0],v.y=this.tg[V+1],v.z=this.tg[V+2],v.w=this.tg[V+3]}return v}setRow(o,v){return this.setRowFromFloats(o,v.x,v.y,v.z,v.w)}transpose(){const o=new j;return j.TransposeToRef(this,o),o}transposeToRef(o){return j.TransposeToRef(this,o),o}setRowFromFloats(o,v,V,g,E){if(o<0||o>3)return this;const I=4*o;return this.tg[I+0]=v,this.tg[I+1]=V,this.tg[I+2]=g,this.tg[I+3]=E,this.markAsUpdated(),this}scale(o){const v=new j;return this.scaleToRef(o,v),v}scaleToRef(o,v){for(let V=0;V<16;V++)v.tg[V]=this.tg[V]*o;return v.markAsUpdated(),v}scaleAndAddToRef(o,v){for(let V=0;V<16;V++)v.tg[V]+=this.tg[V]*o;return v.markAsUpdated(),v}scaleInPlace(o){const v=this.tg;for(let V=0;V<16;V++)v[V]*=o;return this.markAsUpdated(),this}toNormalMatrix(o){const v=t.Matrix[0];this.invertToRef(v),v.transposeToRef(o);const V=o.tg;return j.FromValuesToRef(V[0],V[1],V[2],0,V[4],V[5],V[6],0,V[8],V[9],V[10],0,0,0,0,1,o),o}getRotationMatrix(){const o=new j;return this.getRotationMatrixToRef(o),o}getRotationMatrixToRef(o){const v=t.cv[0];if(!this.decompose(v))return j.IdentityToRef(o),o;const V=this.tg,g=1/v._x,E=1/v._y,I=1/v._z;return j.FromValuesToRef(V[0]*g,V[1]*g,V[2]*g,0,V[4]*E,V[5]*E,V[6]*E,0,V[8]*I,V[9]*I,V[10]*I,0,0,0,0,1,o),o}toggleModelMatrixHandInPlace(){const o=this.tg;return o[2]*=-1,o[6]*=-1,o[8]*=-1,o[9]*=-1,o[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const o=this.tg;return o[8]*=-1,o[9]*=-1,o[10]*=-1,o[11]*=-1,this.markAsUpdated(),this}static bv(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const V=new j;return j.FromArrayToRef(o,v,V),V}static FromArrayToRef(o,v,V){for(let g=0;g<16;g++)V.tg[g]=o[g+v];return V.markAsUpdated(),V}static FromFloat32ArrayToRefScaled(o,v,V,g){return g.tg[0]=o[0+v]*V,g.tg[1]=o[1+v]*V,g.tg[2]=o[2+v]*V,g.tg[3]=o[3+v]*V,g.tg[4]=o[4+v]*V,g.tg[5]=o[5+v]*V,g.tg[6]=o[6+v]*V,g.tg[7]=o[7+v]*V,g.tg[8]=o[8+v]*V,g.tg[9]=o[9+v]*V,g.tg[10]=o[10+v]*V,g.tg[11]=o[11+v]*V,g.tg[12]=o[12+v]*V,g.tg[13]=o[13+v]*V,g.tg[14]=o[14+v]*V,g.tg[15]=o[15+v]*V,g.markAsUpdated(),g}static get IdentityReadOnly(){return j._IdentityReadOnly}static FromValuesToRef(o,v,V,g,E,I,Q,U,n,O,h,x,f,l,S,T,c){const R=c.tg;R[0]=o,R[1]=v,R[2]=V,R[3]=g,R[4]=E,R[5]=I,R[6]=Q,R[7]=U,R[8]=n,R[9]=O,R[10]=h,R[11]=x,R[12]=f,R[13]=l,R[14]=S,R[15]=T,c.markAsUpdated()}static FromValues(o,v,V,g,E,I,Q,U,n,O,h,x,f,l,S,T){const c=new j,R=c.tg;return R[0]=o,R[1]=v,R[2]=V,R[3]=g,R[4]=E,R[5]=I,R[6]=Q,R[7]=U,R[8]=n,R[9]=O,R[10]=h,R[11]=x,R[12]=f,R[13]=l,R[14]=S,R[15]=T,c.markAsUpdated(),c}static Compose(o,v,V){const g=new j;return j.ComposeToRef(o,v,V,g),g}static ComposeToRef(o,v,V,g){const E=g.tg,I=v._x,Q=v._y,U=v._z,n=v._w,O=I+I,h=Q+Q,x=U+U,f=I*O,l=I*h,S=I*x,T=Q*h,c=Q*x,R=U*x,j=n*O,t=n*h,s=n*x,L=o._x,b=o._y,u=o._z;return E[0]=(1-(T+R))*L,E[1]=(l+s)*L,E[2]=(S-t)*L,E[3]=0,E[4]=(l-s)*b,E[5]=(1-(f+R))*b,E[6]=(c+j)*b,E[7]=0,E[8]=(S+t)*u,E[9]=(c-j)*u,E[10]=(1-(f+T))*u,E[11]=0,E[12]=V._x,E[13]=V._y,E[14]=V._z,E[15]=1,g.markAsUpdated(),g}static Identity(){const o=j.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return o._updateIdentityStatus(!0),o}static IdentityToRef(o){return j.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,o),o._updateIdentityStatus(!0),o}static Zero(){const o=j.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return o._updateIdentityStatus(!1),o}static RotationX(o){const v=new j;return j.RotationXToRef(o,v),v}static Invert(o){const v=new j;return o.invertToRef(v),v}static RotationXToRef(o,v){const V=Math.sin(o),g=Math.cos(o);return j.FromValuesToRef(1,0,0,0,0,g,V,0,0,-V,g,0,0,0,0,1,v),v._updateIdentityStatus(1===g&&0===V),v}static RotationY(o){const v=new j;return j.RotationYToRef(o,v),v}static RotationYToRef(o,v){const V=Math.sin(o),g=Math.cos(o);return j.FromValuesToRef(g,0,-V,0,0,1,0,0,V,0,g,0,0,0,0,1,v),v._updateIdentityStatus(1===g&&0===V),v}static RotationZ(o){const v=new j;return j.RotationZToRef(o,v),v}static RotationZToRef(o,v){const V=Math.sin(o),g=Math.cos(o);return j.FromValuesToRef(g,V,0,0,-V,g,0,0,0,0,1,0,0,0,0,1,v),v._updateIdentityStatus(1===g&&0===V),v}static RotationAxis(o,v){const V=new j;return j.RotationAxisToRef(o,v,V),V}static RotationAxisToRef(o,v,V){const g=Math.sin(-v),E=Math.cos(-v),I=1-E;o=o.normalizeToRef(t.cv[0]);const Q=V.tg;return Q[0]=o._x*o._x*I+E,Q[1]=o._x*o._y*I-o._z*g,Q[2]=o._x*o._z*I+o._y*g,Q[3]=0,Q[4]=o._y*o._x*I+o._z*g,Q[5]=o._y*o._y*I+E,Q[6]=o._y*o._z*I-o._x*g,Q[7]=0,Q[8]=o._z*o._x*I-o._y*g,Q[9]=o._z*o._y*I+o._x*g,Q[10]=o._z*o._z*I+E,Q[11]=0,Q[12]=0,Q[13]=0,Q[14]=0,Q[15]=1,V.markAsUpdated(),V}static RotationAlignToRef(o,v,V){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const I=T.Dot(v,o),Q=V.tg;if(I<-1+g.d)Q[0]=-1,Q[1]=0,Q[2]=0,Q[3]=0,Q[4]=0,Q[5]=E?1:-1,Q[6]=0,Q[7]=0,Q[8]=0,Q[9]=0,Q[10]=E?-1:1,Q[11]=0;else{const V=T.Cross(v,o),g=1/(1+I);Q[0]=V._x*V._x*g+I,Q[1]=V._y*V._x*g-V._z,Q[2]=V._z*V._x*g+V._y,Q[3]=0,Q[4]=V._x*V._y*g+V._z,Q[5]=V._y*V._y*g+I,Q[6]=V._z*V._y*g-V._x,Q[7]=0,Q[8]=V._x*V._z*g-V._y,Q[9]=V._y*V._z*g+V._x,Q[10]=V._z*V._z*g+I,Q[11]=0}return Q[12]=0,Q[13]=0,Q[14]=0,Q[15]=1,V.markAsUpdated(),V}static RotationYawPitchRoll(o,v,V){const g=new j;return j.RotationYawPitchRollToRef(o,v,V,g),g}static RotationYawPitchRollToRef(o,v,V,g){return R.RotationYawPitchRollToRef(o,v,V,t.Quaternion[0]),t.Quaternion[0].toRotationMatrix(g),g}static Scaling(o,v,V){const g=new j;return j.ScalingToRef(o,v,V,g),g}static ScalingToRef(o,v,V,g){return j.FromValuesToRef(o,0,0,0,0,v,0,0,0,0,V,0,0,0,0,1,g),g._updateIdentityStatus(1===o&&1===v&&1===V),g}static Translation(o,v,V){const g=new j;return j.TranslationToRef(o,v,V,g),g}static TranslationToRef(o,v,V,g){return j.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,o,v,V,1,g),g._updateIdentityStatus(0===o&&0===v&&0===V),g}static Lerp(o,v,V){const g=new j;return j.LerpToRef(o,v,V,g),g}static LerpToRef(o,v,V,g){const E=g.tg,I=o.m,Q=v.m;for(let U=0;U<16;U++)E[U]=I[U]*(1-V)+Q[U]*V;return g.markAsUpdated(),g}static DecomposeLerp(o,v,V){const g=new j;return j.DecomposeLerpToRef(o,v,V,g),g}static DecomposeLerpToRef(o,v,V,g){const E=t.cv[0],I=t.Quaternion[0],Q=t.cv[1];o.decompose(E,I,Q);const U=t.cv[2],n=t.Quaternion[1],O=t.cv[3];v.decompose(U,n,O);const h=t.cv[4];T.LerpToRef(E,U,V,h);const x=t.Quaternion[2];R.SlerpToRef(I,n,V,x);const f=t.cv[5];return T.LerpToRef(Q,O,V,f),j.ComposeToRef(h,x,f,g),g}static LookAtLH(o,v,V){const g=new j;return j.LookAtLHToRef(o,v,V,g),g}static LookAtLHToRef(o,v,V,g){const E=t.cv[0],I=t.cv[1],Q=t.cv[2];v.subtractToRef(o,Q),Q.normalize(),T.CrossToRef(V,Q,E);const U=E.lengthSquared();0===U?E.x=1:E.normalizeFromLength(Math.sqrt(U)),T.CrossToRef(Q,E,I),I.normalize();const n=-T.Dot(E,o),O=-T.Dot(I,o),h=-T.Dot(Q,o);return j.FromValuesToRef(E._x,I._x,Q._x,0,E._y,I._y,Q._y,0,E._z,I._z,Q._z,0,n,O,h,1,g),g}static LookAtRH(o,v,V){const g=new j;return j.LookAtRHToRef(o,v,V,g),g}static LookAtRHToRef(o,v,V,g){const E=t.cv[0],I=t.cv[1],Q=t.cv[2];o.subtractToRef(v,Q),Q.normalize(),T.CrossToRef(V,Q,E);const U=E.lengthSquared();0===U?E.x=1:E.normalizeFromLength(Math.sqrt(U)),T.CrossToRef(Q,E,I),I.normalize();const n=-T.Dot(E,o),O=-T.Dot(I,o),h=-T.Dot(Q,o);return j.FromValuesToRef(E._x,I._x,Q._x,0,E._y,I._y,Q._y,0,E._z,I._z,Q._z,0,n,O,h,1,g),g}static LookDirectionLH(o,v){const V=new j;return j.LookDirectionLHToRef(o,v,V),V}static LookDirectionLHToRef(o,v,V){const g=t.cv[0];g.U(o),g.scaleInPlace(-1);const E=t.cv[1];return T.CrossToRef(v,g,E),j.FromValuesToRef(E._x,E._y,E._z,0,v._x,v._y,v._z,0,g._x,g._y,g._z,0,0,0,0,1,V),V}static LookDirectionRH(o,v){const V=new j;return j.LookDirectionRHToRef(o,v,V),V}static LookDirectionRHToRef(o,v,V){const g=t.cv[2];return T.CrossToRef(v,o,g),j.FromValuesToRef(g._x,g._y,g._z,0,v._x,v._y,v._z,0,o._x,o._y,o._z,0,0,0,0,1,V),V}static OrthoLH(o,v,V,g,E){const I=new j;return j.OrthoLHToRef(o,v,V,g,I,E),I}static OrthoLHToRef(o,v,V,g,E,I){const Q=2/o,U=2/v,n=2/(g-V),O=-(g+V)/(g-V);return j.FromValuesToRef(Q,0,0,0,0,U,0,0,0,0,n,0,0,0,O,1,E),I&&E.multiplyToRef(L,E),E._updateIdentityStatus(1===Q&&1===U&&1===n&&0===O),E}static OrthoOffCenterLH(o,v,V,g,E,I,Q){const U=new j;return j.OrthoOffCenterLHToRef(o,v,V,g,E,I,U,Q),U}static OrthoOffCenterLHToRef(o,v,V,g,E,I,Q,U){const n=2/(v-o),O=2/(g-V),h=2/(I-E),x=-(I+E)/(I-E),f=(o+v)/(o-v),l=(g+V)/(V-g);return j.FromValuesToRef(n,0,0,0,0,O,0,0,0,0,h,0,f,l,x,1,Q),U&&Q.multiplyToRef(L,Q),Q.markAsUpdated(),Q}static ObliqueOffCenterLHToRef(o,v,V,g,E,I,Q,U,n,O,h){const x=-Q*Math.cos(U),f=-Q*Math.sin(U);return j.TranslationToRef(0,0,-n,t.Matrix[1]),j.FromValuesToRef(1,0,0,0,0,1,0,0,x,f,1,0,0,0,0,1,t.Matrix[0]),t.Matrix[1].multiplyToRef(t.Matrix[0],t.Matrix[0]),j.TranslationToRef(0,0,n,t.Matrix[1]),t.Matrix[0].multiplyToRef(t.Matrix[1],t.Matrix[0]),j.OrthoOffCenterLHToRef(o,v,V,g,E,I,O,h),t.Matrix[0].multiplyToRef(O,O),O}static OrthoOffCenterRH(o,v,V,g,E,I,Q){const U=new j;return j.OrthoOffCenterRHToRef(o,v,V,g,E,I,U,Q),U}static OrthoOffCenterRHToRef(o,v,V,g,E,I,Q,U){return j.OrthoOffCenterLHToRef(o,v,V,g,E,I,Q,U),Q.tg[10]*=-1,Q}static ObliqueOffCenterRHToRef(o,v,V,g,E,I,Q,U,n,O,h){const x=Q*Math.cos(U),f=Q*Math.sin(U);return j.TranslationToRef(0,0,n,t.Matrix[1]),j.FromValuesToRef(1,0,0,0,0,1,0,0,x,f,1,0,0,0,0,1,t.Matrix[0]),t.Matrix[1].multiplyToRef(t.Matrix[0],t.Matrix[0]),j.TranslationToRef(0,0,-n,t.Matrix[1]),t.Matrix[0].multiplyToRef(t.Matrix[1],t.Matrix[0]),j.OrthoOffCenterRHToRef(o,v,V,g,E,I,O,h),t.Matrix[0].multiplyToRef(O,O),O}static PerspectiveLH(o,v,V,g,E){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const Q=new j,U=2*V/o,n=2*V/v,O=(g+V)/(g-V),h=-2*g*V/(g-V),x=Math.tan(I);return j.FromValuesToRef(U,0,0,0,0,n,0,x,0,0,O,1,0,0,h,0,Q),E&&Q.multiplyToRef(L,Q),Q._updateIdentityStatus(!1),Q}static PerspectiveFovLH(o,v,V,g,E){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const U=new j;return j.PerspectiveFovLHToRef(o,v,V,g,U,!0,E,I,Q),U}static PerspectiveFovLHToRef(o,v,V,g,E){let I=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,U=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,n=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const O=V,h=g,x=1/Math.tan(.5*o),f=I?x/v:x,l=I?x:x*v,S=n&&0===O?-1:0!==h?(h+O)/(h-O):1,T=n&&0===O?2*h:0!==h?-2*h*O/(h-O):-2*O,c=Math.tan(U);return j.FromValuesToRef(f,0,0,0,0,l,0,c,0,0,S,1,0,0,T,0,E),Q&&E.multiplyToRef(L,E),E._updateIdentityStatus(!1),E}static PerspectiveFovReverseLHToRef(o,v,V,g,E){let I=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,U=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const n=1/Math.tan(.5*o),O=I?n/v:n,h=I?n:n*v,x=Math.tan(U);return j.FromValuesToRef(O,0,0,0,0,h,0,x,0,0,-V,1,0,0,1,0,E),Q&&E.multiplyToRef(L,E),E._updateIdentityStatus(!1),E}static PerspectiveFovRH(o,v,V,g,E){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Q=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const U=new j;return j.PerspectiveFovRHToRef(o,v,V,g,U,!0,E,I,Q),U}static PerspectiveFovRHToRef(o,v,V,g,E){let I=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,U=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,n=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const O=V,h=g,x=1/Math.tan(.5*o),f=I?x/v:x,l=I?x:x*v,S=n&&0===O?1:0!==h?-(h+O)/(h-O):-1,T=n&&0===O?2*h:0!==h?-2*h*O/(h-O):-2*O,c=Math.tan(U);return j.FromValuesToRef(f,0,0,0,0,l,0,c,0,0,S,-1,0,0,T,0,E),Q&&E.multiplyToRef(L,E),E._updateIdentityStatus(!1),E}static PerspectiveFovReverseRHToRef(o,v,V,g,E){let I=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],Q=arguments.length>6?arguments[6]:void 0,U=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const n=1/Math.tan(.5*o),O=I?n/v:n,h=I?n:n*v,x=Math.tan(U);return j.FromValuesToRef(O,0,0,0,0,h,0,x,0,0,-V,-1,0,0,-1,0,E),Q&&E.multiplyToRef(L,E),E._updateIdentityStatus(!1),E}static GetFinalMatrix(o,v,V,g,E,I){const Q=o.width,U=o.height,n=o.x,O=o.y,h=j.FromValues(Q/2,0,0,0,0,-U/2,0,0,0,0,I-E,0,n+Q/2,U/2+O,E,1),x=new j;return v.multiplyToRef(V,x),x.multiplyToRef(g,x),x.multiplyToRef(h,x)}static GetAsMatrix2x2(o){const v=o.m,V=[v[0],v[1],v[4],v[5]];return Q.d.MatrixUse64Bits?V:new Float32Array(V)}static GetAsMatrix3x3(o){const v=o.m,V=[v[0],v[1],v[2],v[4],v[5],v[6],v[8],v[9],v[10]];return Q.d.MatrixUse64Bits?V:new Float32Array(V)}static Transpose(o){const v=new j;return j.TransposeToRef(o,v),v}static TransposeToRef(o,v){const V=o.m,g=V[0],E=V[4],I=V[8],Q=V[12],U=V[1],n=V[5],O=V[9],h=V[13],x=V[2],f=V[6],l=V[10],S=V[14],T=V[3],c=V[7],R=V[11],j=V[15],t=v.tg;return t[0]=g,t[1]=E,t[2]=I,t[3]=Q,t[4]=U,t[5]=n,t[6]=O,t[7]=h,t[8]=x,t[9]=f,t[10]=l,t[11]=S,t[12]=T,t[13]=c,t[14]=R,t[15]=j,v.markAsUpdated(),v._updateIdentityStatus(o._isIdentity,o._isIdentityDirty),v}static Reflection(o){const v=new j;return j.ReflectionToRef(o,v),v}static ReflectionToRef(o,v){o.normalize();const V=o.normal.x,g=o.normal.y,E=o.normal.z,I=-2*V,Q=-2*g,U=-2*E;return j.FromValuesToRef(I*V+1,Q*V,U*V,0,I*g,Q*g+1,U*g,0,I*E,Q*E,U*E+1,0,I*o.d,Q*o.d,U*o.d,1,v),v}static FromXYZAxesToRef(o,v,V,g){return j.FromValuesToRef(o._x,o._y,o._z,0,v._x,v._y,v._z,0,V._x,V._y,V._z,0,0,0,0,1,g),g}static FromQuaternionToRef(o,v){const V=o._x*o._x,g=o._y*o._y,E=o._z*o._z,I=o._x*o._y,Q=o._z*o._w,U=o._z*o._x,n=o._y*o._w,O=o._y*o._z,h=o._x*o._w;return v.tg[0]=1-2*(g+E),v.tg[1]=2*(I+Q),v.tg[2]=2*(U-n),v.tg[3]=0,v.tg[4]=2*(I-Q),v.tg[5]=1-2*(E+V),v.tg[6]=2*(O+h),v.tg[7]=0,v.tg[8]=2*(U+n),v.tg[9]=2*(O-h),v.tg[10]=1-2*(g+V),v.tg[11]=0,v.tg[12]=0,v.tg[13]=0,v.tg[14]=0,v.tg[15]=1,v.markAsUpdated(),v}}j._IdentityReadOnly=j.Identity(),Object.defineProperties(j.prototype,{dimension:{value:[4,4]},rank:{value:2}});class t{}t.cv=(0,E.c)(11,T.Zero),t.Matrix=(0,E.c)(2,j.Identity),t.Quaternion=(0,E.c)(3,R.Zero);class s{}s.Vector2=(0,E.c)(3,S.Zero),s.cv=(0,E.c)(13,T.Zero),s.Vector4=(0,E.c)(3,c.Zero),s.Quaternion=(0,E.c)(3,R.Zero),s.Matrix=(0,E.c)(8,j.Identity),(0,I.h)("BABYLON.Vector2",S),(0,I.h)("BABYLON.Vector3",T),(0,I.h)("BABYLON.Vector4",c),(0,I.h)("BABYLON.Matrix",j);const L=j.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12503:(o,v,V)=>{function g(o,v){const V=[];for(let g=0;g<o;++g)V.push(v());return V}function E(o,v){return g(o,v)}V.d(v,{b:()=>g,c:()=>E,g:()=>Q});const I=["push","splice","pop","shift","unshift"];function Q(o,v){const V=I.map((V=>function(o,v,V){const g=o[v];if("function"!==typeof g)return null;const E=function(){const g=o.length,I=E.previous.apply(o,arguments);return V(v,g),I};return g.next=E,E.previous=g,o[v]=E,()=>{const V=E.previous;if(!V)return;const g=E.next;g?(V.next=g,g.previous=V):(V.next=void 0,o[v]=V),E.next=void 0,E.previous=void 0}}(o,V,v)));return()=>{for(const o of V)null===o||void 0===o||o()}}}}]);