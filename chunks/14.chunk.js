"use strict";(self["1xyrlsr8vb9"]=self["1xyrlsr8vb9"]||[]).push([[14],{12274:(I,O,C)=>{C.d(O,{d:()=>y,h:()=>i,i:()=>j,j:()=>K});const j=1/2.2,K=2.2,i=(1+Math.sqrt(5))/2,y=.001},12282:(I,O,C)=>{function j(I){return parseInt(I.toString().replace(/\W/g,""))}function K(I,O){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(I-O)<=C}function i(I,O,C){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return I<O-j||I>C+j}function y(I,O){return I===O?I:Math.random()*(O-I)+I}function S(I,O,C){return I+(O-I)*C}function U(I,O,C){let j=E(O-I,360);return j>180&&(j-=360),I+j*s(C)}function p(I,O,C){let j=0;return j=I!=O?s((C-I)/(O-I)):0,j}function N(I,O,C,j,K){const i=K*K,y=K*i;return I*(2*y-3*i+1)+C*(-2*y+3*i)+O*(y-2*i+K)+j*(y-i)}function Q(I,O,C,j,K){const i=K*K;return 6*(i-K)*I+(3*i-4*K+1)*O+6*(-i+K)*C+(3*i-2*K)*j}function s(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(O,I))}function Z(I){return I-=2*Math.PI*Math.floor((I+Math.PI)/(2*Math.PI))}function q(I){const O=I.toString(16);return I<=15?("0"+O).toUpperCase():O.toUpperCase()}function mI(I){if(Math.log2)return Math.floor(Math.log2(I));if(I<0)return NaN;if(0===I)return-1/0;let O=0;if(I<1){for(;I<1;)O++,I*=2;O=-O}else if(I>1)for(;I>1;)O++,I=Math.floor(I/2);return O}function E(I,O){return I-Math.floor(I/O)*O}function h(I,O,C){return(I-O)/(C-O)}function r(I,O,C){return I*(C-O)+O}function W(I,O){let C=E(O-I,360);return C>180&&(C-=360),C}function Y(I,O){const C=E(I,2*O);return O-Math.abs(C-O)}function o(I,O,C){let j=s(C);return j=-2*j*j*j+3*j*j,O*j+I*(1-j)}function c(I,O,C){let j=0;return j=Math.abs(O-I)<=C?O:I+Math.sign(O-I)*C,j}function n(I,O,C){const j=W(I,O);let K=0;return K=-C<j&&j<C?O:c(I,O=I+j,C),K}function X(I,O,C){return(I-O)/(C-O)}function T(I,O,C){return(C-O)*I+O}function H(I,O){const C=I%O;return 0===C?O:H(O,C)}C.r(O),C.d(O,{Clamp:()=>s,DeltaAngle:()=>W,Denormalize:()=>r,ExtractAsInt:()=>j,Hermite:()=>N,Hermite1stDerivative:()=>Q,HighestCommonFactor:()=>H,ILog2:()=>mI,InverseLerp:()=>p,Lerp:()=>S,LerpAngle:()=>U,MoveTowards:()=>c,MoveTowardsAngle:()=>n,Normalize:()=>h,NormalizeRadians:()=>Z,OutsideRange:()=>i,PercentToRange:()=>T,PingPong:()=>Y,RandomRange:()=>y,RangeToPercent:()=>X,Repeat:()=>E,SmoothStep:()=>o,ToHex:()=>q,WithinEpsilon:()=>K})},12272:(I,O,C)=>{C.r(O),C.d(O,{Matrix:()=>r,Quaternion:()=>h,TmpVectors:()=>Y,Vector2:()=>q,mC:()=>mI,Vector4:()=>E});var j=C(12274),K=C(12276),i=C(12226),y=C(12197),S=C(12132),U=C(12282);class p{}function N(I,O,C){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const K=I.qS(),i=O.qS(),y=K[0],S=K[1],U=K[2],p=K[3],N=K[4],Q=K[5],s=K[6],Z=K[7],q=K[8],mI=K[9],E=K[10],h=K[11],r=K[12],W=K[13],Y=K[14],o=K[15],c=i[0],n=i[1],X=i[2],T=i[3],H=i[4],b=i[5],a=i[6],M=i[7],u=i[8],J=i[9],f=i[10],l=i[11],x=i[12],D=i[13],t=i[14],d=i[15];C[j]=y*c+S*H+U*u+p*x,C[j+1]=y*n+S*b+U*J+p*D,C[j+2]=y*X+S*a+U*f+p*t,C[j+3]=y*T+S*M+U*l+p*d,C[j+4]=N*c+Q*H+s*u+Z*x,C[j+5]=N*n+Q*b+s*J+Z*D,C[j+6]=N*X+Q*a+s*f+Z*t,C[j+7]=N*T+Q*M+s*l+Z*d,C[j+8]=q*c+mI*H+E*u+h*x,C[j+9]=q*n+mI*b+E*J+h*D,C[j+10]=q*X+mI*a+E*f+h*t,C[j+11]=q*T+mI*M+E*l+h*d,C[j+12]=r*c+W*H+Y*u+o*x,C[j+13]=r*n+W*b+Y*J+o*D,C[j+14]=r*X+W*a+Y*f+o*t,C[j+15]=r*T+W*M+Y*l+o*d}function Q(I,O){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const j=I.qS();O[C]=j[0],O[C+1]=j[1],O[C+2]=j[2],O[C+3]=j[3],O[C+4]=j[4],O[C+5]=j[5],O[C+6]=j[6],O[C+7]=j[7],O[C+8]=j[8],O[C+9]=j[9],O[C+10]=j[10],O[C+11]=j[11],O[C+12]=j[12],O[C+13]=j[13],O[C+14]=j[14],O[C+15]=j[15]}function s(I,O){const C=I.qS(),j=C[0],K=C[1],i=C[2],y=C[3],S=C[4],U=C[5],p=C[6],N=C[7],Q=C[8],s=C[9],Z=C[10],q=C[11],mI=C[12],E=C[13],h=C[14],r=C[15],W=Z*r-h*q,Y=s*r-E*q,o=s*h-E*Z,c=Q*r-mI*q,n=Q*h-Z*mI,X=Q*E-mI*s,T=+(U*W-p*Y+N*o),H=-(S*W-p*c+N*n),b=+(S*Y-U*c+N*X),a=-(S*o-U*n+p*X),M=j*T+K*H+i*b+y*a;if(0===M)return!1;const u=1/M,J=p*r-h*N,f=U*r-E*N,l=U*h-E*p,x=S*r-mI*N,D=S*h-mI*p,t=S*E-mI*U,d=p*q-Z*N,w=U*q-s*N,g=U*Z-s*p,V=S*q-Q*N,e=S*Z-Q*p,L=S*s-Q*U,z=-(K*W-i*Y+y*o),k=+(j*W-i*c+y*n),A=-(j*Y-K*c+y*X),P=+(j*o-K*n+i*X),v=+(K*J-i*f+y*l),B=-(j*J-i*x+y*D),F=+(j*f-K*x+y*t),R=-(j*l-K*D+i*t),G=-(K*d-i*w+y*g),II=+(j*d-i*V+y*e),OI=-(j*w-K*V+y*L),CI=+(j*g-K*e+i*L);return O[0]=T*u,O[1]=z*u,O[2]=v*u,O[3]=G*u,O[4]=H*u,O[5]=k*u,O[6]=B*u,O[7]=II*u,O[8]=b*u,O[9]=A*u,O[10]=F*u,O[11]=OI*u,O[12]=a*u,O[13]=P*u,O[14]=R*u,O[15]=CI*u,!0}p._UpdateFlagSeed=0;const Z=I=>parseInt(I.toString().replace(/\W/g,""));class q{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=I,this.y=O}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let I=Z(this.x);return I=397*I^Z(this.y),I}toArray(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[O]=this.x,I[O+1]=this.y,this}qC(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q.FromArrayToRef(I,O,this),this}qS(){return[this.x,this.y]}K(I){return this.x=I.x,this.y=I.y,this}cS(I,O){return this.x=I,this.y=O,this}set(I,O){return this.cS(I,O)}XS(I){return this.cS(I,I)}add(I){return new q(this.x+I.x,this.y+I.y)}addToRef(I,O){return O.x=this.x+I.x,O.y=this.y+I.y,O}addInPlace(I){return this.x+=I.x,this.y+=I.y,this}addInPlaceFromFloats(I,O){return this.x+=I,this.y+=O,this}addVector3(I){return new q(this.x+I.x,this.y+I.y)}EO(I){return new q(this.x-I.x,this.y-I.y)}subtractToRef(I,O){return O.x=this.x-I.x,O.y=this.y-I.y,O}OQ(I){return this.x-=I.x,this.y-=I.y,this}multiplyInPlace(I){return this.x*=I.x,this.y*=I.y,this}multiply(I){return new q(this.x*I.x,this.y*I.y)}multiplyToRef(I,O){return O.x=this.x*I.x,O.y=this.y*I.y,O}multiplyByFloats(I,O){return new q(this.x*I,this.y*O)}divide(I){return new q(this.x/I.x,this.y/I.y)}divideToRef(I,O){return O.x=this.x/I.x,O.y=this.y/I.y,O}divideInPlace(I){return this.x=this.x/I.x,this.y=this.y/I.y,this}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I.x,I.y)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I.x,I.y)}minimizeInPlaceFromFloats(I,O){return this.x=Math.min(I,this.x),this.y=Math.min(O,this.y),this}maximizeInPlaceFromFloats(I,O){return this.x=Math.max(I,this.x),this.y=Math.max(O,this.y),this}subtractFromFloats(I,O){return new q(this.x-I,this.y-O)}subtractFromFloatsToRef(I,O,C){return C.x=this.x-I,C.y=this.y-O,C}negate(){return new q(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(I){return I.x=-this.x,I.y=-this.y,I}scaleInPlace(I){return this.x*=I,this.y*=I,this}scale(I){return new q(this.x*I,this.y*I)}scaleToRef(I,O){return O.x=this.x*I,O.y=this.y*I,O}scaleAndAddToRef(I,O){return O.x+=this.x*I,O.y+=this.y*I,O}equals(I){return I&&this.x===I.x&&this.y===I.y}equalsWithEpsilon(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return I&&(0,U.WithinEpsilon)(this.x,I.x,O)&&(0,U.WithinEpsilon)(this.y,I.y,O)}equalsToFloats(I,O){return this.x===I&&this.y===O}floor(){return new q(Math.floor(this.x),Math.floor(this.y))}floorToRef(I){return I.x=Math.floor(this.x),I.y=Math.floor(this.y),I}fract(){return new q(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(I){return I.x=this.x-Math.floor(this.x),I.y=this.y-Math.floor(this.y),I}rotate(I){return this.rotateToRef(I,new q)}rotateToRef(I,O){const C=Math.cos(I),j=Math.sin(I);return O.x=C*this.x-j*this.y,O.y=j*this.x+C*this.y,O}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){const I=new q;return this.normalizeToRef(I),I}normalizeToRef(I){const O=this.length();return 0===O&&(I.x=this.x,I.y=this.y),this.scaleToRef(1/O,I)}clone(){return new q(this.x,this.y)}dot(I){return this.x*I.x+this.y*I.y}static Zero(){return new q(0,0)}static One(){return new q(1,1)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new q((0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).cS((0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O))}static get ZeroReadOnly(){return q._ZeroReadOnly}static YO(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new q(I[O],I[O+1])}static FromArrayToRef(I,O,C){return C.x=I[O],C.y=I[O+1],C}static FromFloatsToRef(I,O,C){return C.cS(I,O),C}static CatmullRom(I,O,C,j,K){const i=K*K,y=K*i,S=.5*(2*O.x+(-I.x+C.x)*K+(2*I.x-5*O.x+4*C.x-j.x)*i+(-I.x+3*O.x-3*C.x+j.x)*y),U=.5*(2*O.y+(-I.y+C.y)*K+(2*I.y-5*O.y+4*C.y-j.y)*i+(-I.y+3*O.y-3*C.y+j.y)*y);return new q(S,U)}static ClampToRef(I,O,C,j){return j.x=(0,U.Clamp)(I.x,O.x,C.x),j.y=(0,U.Clamp)(I.y,O.y,C.y),j}static Clamp(I,O,C){const j=(0,U.Clamp)(I.x,O.x,C.x),K=(0,U.Clamp)(I.y,O.y,C.y);return new q(j,K)}static Hermite(I,O,C,j,K){const i=K*K,y=K*i,S=2*y-3*i+1,U=-2*y+3*i,p=y-2*i+K,N=y-i,Q=I.x*S+C.x*U+O.x*p+j.x*N,s=I.y*S+C.y*U+O.y*p+j.y*N;return new q(Q,s)}static Hermite1stDerivative(I,O,C,j,K){return this.Hermite1stDerivativeToRef(I,O,C,j,K,new q)}static Hermite1stDerivativeToRef(I,O,C,j,K,i){const y=K*K;return i.x=6*(y-K)*I.x+(3*y-4*K+1)*O.x+6*(-y+K)*C.x+(3*y-2*K)*j.x,i.y=6*(y-K)*I.y+(3*y-4*K+1)*O.y+6*(-y+K)*C.y+(3*y-2*K)*j.y,i}static Lerp(I,O,C){return q.LerpToRef(I,O,C,new q)}static LerpToRef(I,O,C,j){return j.x=I.x+(O.x-I.x)*C,j.y=I.y+(O.y-I.y)*C,j}static Dot(I,O){return I.x*O.x+I.y*O.y}static Normalize(I){return q.NormalizeToRef(I,new q)}static NormalizeToRef(I,O){return I.normalizeToRef(O),O}static Minimize(I,O){const C=I.x<O.x?I.x:O.x,j=I.y<O.y?I.y:O.y;return new q(C,j)}static Maximize(I,O){const C=I.x>O.x?I.x:O.x,j=I.y>O.y?I.y:O.y;return new q(C,j)}static Transform(I,O){return q.TransformToRef(I,O,new q)}static TransformToRef(I,O,C){const j=O.m,K=I.x*j[0]+I.y*j[4]+j[12],i=I.x*j[1]+I.y*j[5]+j[13];return C.x=K,C.y=i,C}static PointInTriangle(I,O,C,j){const K=.5*(-C.y*j.x+O.y*(-C.x+j.x)+O.x*(C.y-j.y)+C.x*j.y),i=K<0?-1:1,y=(O.y*j.x-O.x*j.y+(j.y-O.y)*I.x+(O.x-j.x)*I.y)*i,S=(O.x*C.y-O.y*C.x+(O.y-C.y)*I.x+(C.x-O.x)*I.y)*i;return y>0&&S>0&&y+S<2*K*i}static Distance(I,O){return Math.sqrt(q.DistanceSquared(I,O))}static DistanceSquared(I,O){const C=I.x-O.x,j=I.y-O.y;return C*C+j*j}static Center(I,O){return q.CenterToRef(I,O,new q)}static CenterToRef(I,O,C){return C.cS((I.x+O.x)/2,(I.y+O.y)/2)}static DistanceOfPointFromSegment(I,O,C){const j=q.DistanceSquared(O,C);if(0===j)return q.Distance(I,O);const K=C.EO(O),i=Math.max(0,Math.min(1,q.Dot(I.EO(O),K)/j)),y=O.add(K.multiplyByFloats(i,i));return q.Distance(I,y)}}q._V8PerformanceHack=new q(.5,.5),q._ZeroReadOnly=q.Zero(),Object.defineProperties(q.prototype,{dimension:{value:[2]},rank:{value:1}});class mI{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=I,this._y=O,this._z=C}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"mC"}getHashCode(){let I=Z(this._x);return I=397*I^Z(this._y),I=397*I^Z(this._z),I}qS(){return[this._x,this._y,this._z]}toArray(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[O]=this._x,I[O+1]=this._y,I[O+2]=this._z,this}qC(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return mI.FromArrayToRef(I,O,this),this}toQuaternion(){return h.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(I){return this._x+=I._x,this._y+=I._y,this._z+=I._z,this._isDirty=!0,this}addInPlaceFromFloats(I,O,C){return this._x+=I,this._y+=O,this._z+=C,this._isDirty=!0,this}add(I){return new mI(this._x+I._x,this._y+I._y,this._z+I._z)}addToRef(I,O){return O._x=this._x+I._x,O._y=this._y+I._y,O._z=this._z+I._z,O._isDirty=!0,O}OQ(I){return this._x-=I._x,this._y-=I._y,this._z-=I._z,this._isDirty=!0,this}EO(I){return new mI(this._x-I._x,this._y-I._y,this._z-I._z)}subtractToRef(I,O){return this.subtractFromFloatsToRef(I._x,I._y,I._z,O)}subtractFromFloats(I,O,C){return new mI(this._x-I,this._y-O,this._z-C)}subtractFromFloatsToRef(I,O,C,j){return j._x=this._x-I,j._y=this._y-O,j._z=this._z-C,j._isDirty=!0,j}negate(){return new mI(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(I){return I._x=-1*this._x,I._y=-1*this._y,I._z=-1*this._z,I._isDirty=!0,I}scaleInPlace(I){return this._x*=I,this._y*=I,this._z*=I,this._isDirty=!0,this}scale(I){return new mI(this._x*I,this._y*I,this._z*I)}scaleToRef(I,O){return O._x=this._x*I,O._y=this._y*I,O._z=this._z*I,O._isDirty=!0,O}getNormalToRef(I){const O=this.length();let C=Math.acos(this._y/O);const j=Math.atan2(this._z,this._x);C>Math.PI/2?C-=Math.PI/2:C+=Math.PI/2;const K=O*Math.sin(C)*Math.cos(j),i=O*Math.cos(C),y=O*Math.sin(C)*Math.sin(j);return I.set(K,i,y),I}applyRotationQuaternionToRef(I,O){const C=this._x,j=this._y,K=this._z,i=I._x,y=I._y,S=I._z,U=I._w,p=2*(y*K-S*j),N=2*(S*C-i*K),Q=2*(i*j-y*C);return O._x=C+U*p+y*Q-S*N,O._y=j+U*N+S*p-i*Q,O._z=K+U*Q+i*N-y*p,O._isDirty=!0,O}applyRotationQuaternionInPlace(I){return this.applyRotationQuaternionToRef(I,this)}applyRotationQuaternion(I){return this.applyRotationQuaternionToRef(I,new mI)}scaleAndAddToRef(I,O){return O._x+=this._x*I,O._y+=this._y*I,O._z+=this._z*I,O._isDirty=!0,O}projectOnPlane(I,O){return this.projectOnPlaneToRef(I,O,new mI)}projectOnPlaneToRef(I,O,C){const j=I.normal,K=I.d,i=W.mC[0];this.subtractToRef(O,i),i.normalize();const y=mI.Dot(i,j);if(Math.abs(y)<1e-10)C.XS(1/0);else{const I=-(mI.Dot(O,j)+K)/y,S=i.scaleInPlace(I);O.addToRef(S,C)}return C}equals(I){return I&&this._x===I._x&&this._y===I._y&&this._z===I._z}equalsWithEpsilon(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return I&&(0,U.WithinEpsilon)(this._x,I._x,O)&&(0,U.WithinEpsilon)(this._y,I._y,O)&&(0,U.WithinEpsilon)(this._z,I._z,O)}equalsToFloats(I,O,C){return this._x===I&&this._y===O&&this._z===C}multiplyInPlace(I){return this._x*=I._x,this._y*=I._y,this._z*=I._z,this._isDirty=!0,this}multiply(I){return this.multiplyByFloats(I._x,I._y,I._z)}multiplyToRef(I,O){return O._x=this._x*I._x,O._y=this._y*I._y,O._z=this._z*I._z,O._isDirty=!0,O}multiplyByFloats(I,O,C){return new mI(this._x*I,this._y*O,this._z*C)}divide(I){return new mI(this._x/I._x,this._y/I._y,this._z/I._z)}divideToRef(I,O){return O._x=this._x/I._x,O._y=this._y/I._y,O._z=this._z/I._z,O._isDirty=!0,O}divideInPlace(I){return this._x=this._x/I._x,this._y=this._y/I._y,this._z=this._z/I._z,this._isDirty=!0,this}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I._x,I._y,I._z)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I._x,I._y,I._z)}minimizeInPlaceFromFloats(I,O,C){return I<this._x&&(this.x=I),O<this._y&&(this.y=O),C<this._z&&(this.z=C),this}maximizeInPlaceFromFloats(I,O,C){return I>this._x&&(this.x=I),O>this._y&&(this.y=O),C>this._z&&(this.z=C),this}isNonUniformWithinEpsilon(I){const O=Math.abs(this._x),C=Math.abs(this._y);if(!(0,U.WithinEpsilon)(O,C,I))return!0;const j=Math.abs(this._z);return!(0,U.WithinEpsilon)(O,j,I)||!(0,U.WithinEpsilon)(C,j,I)}get isNonUniform(){const I=Math.abs(this._x);if(I!==Math.abs(this._y))return!0;return I!==Math.abs(this._z)}floorToRef(I){return I._x=Math.floor(this._x),I._y=Math.floor(this._y),I._z=Math.floor(this._z),I._isDirty=!0,I}floor(){return new mI(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(I){return I._x=this._x-Math.floor(this._x),I._y=this._y-Math.floor(this._y),I._z=this._z-Math.floor(this._z),I._isDirty=!0,I}fract(){return new mI(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(I){if("xyz"===(I=I.toLowerCase()))return this;const O=W.mC[0].K(this);return this.x=O[I[0]],this.y=O[I[1]],this.z=O[I[2]],this}rotateByQuaternionToRef(I,O){return I.toRotationMatrix(W.Matrix[0]),mI.TransformCoordinatesToRef(this,W.Matrix[0],O),O}rotateByQuaternionAroundPointToRef(I,O,C){return this.subtractToRef(O,W.mC[0]),W.mC[0].rotateByQuaternionToRef(I,W.mC[0]),O.addToRef(W.mC[0],C),C}cross(I){return mI.CrossToRef(this,I,new mI)}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){return this.normalizeToRef(new mI)}normalizeToRef(I){const O=this.length();return 0===O||1===O?(I._x=this._x,I._y=this._y,I._z=this._z,I._isDirty=!0,I):this.scaleToRef(1/O,I)}clone(){return new mI(this._x,this._y,this._z)}K(I){return this.cS(I._x,I._y,I._z)}cS(I,O,C){return this._x=I,this._y=O,this._z=C,this._isDirty=!0,this}set(I,O,C){return this.cS(I,O,C)}XS(I){return this._x=this._y=this._z=I,this._isDirty=!0,this}static GetClipFactor(I,O,C,j){const K=mI.Dot(I,C);return(K-j)/(K-mI.Dot(O,C))}static GetAngleBetweenVectors(I,O,C){const j=I.normalizeToRef(W.mC[1]),K=O.normalizeToRef(W.mC[2]);let i=mI.Dot(j,K);i=(0,U.Clamp)(i,-1,1);const y=Math.acos(i),S=W.mC[3];return mI.CrossToRef(j,K,S),mI.Dot(S,C)>0?isNaN(y)?0:y:isNaN(y)?-Math.PI:-Math.acos(i)}static GetAngleBetweenVectorsOnPlane(I,O,C){W.mC[0].K(I);const j=W.mC[0];W.mC[1].K(O);const K=W.mC[1];W.mC[2].K(C);const i=W.mC[2],y=W.mC[3],S=W.mC[4];j.normalize(),K.normalize(),i.normalize(),mI.CrossToRef(i,j,y),mI.CrossToRef(y,i,S);const p=Math.atan2(mI.Dot(K,y),mI.Dot(K,S));return(0,U.NormalizeRadians)(p)}static PitchYawRollToMoveBetweenPointsToRef(I,O,C){const j=Y.mC[0];return O.subtractToRef(I,j),C._y=Math.atan2(j.x,j.z)||0,C._x=Math.atan2(Math.sqrt(j.x**2+j.z**2),j.y)||0,C._z=0,C._isDirty=!0,C}static PitchYawRollToMoveBetweenPoints(I,O){const C=mI.Zero();return mI.PitchYawRollToMoveBetweenPointsToRef(I,O,C)}static SlerpToRef(I,O,C,K){C=(0,U.Clamp)(C,0,1);const i=W.mC[0],y=W.mC[1];i.K(I);const S=i.length();i.normalizeFromLength(S),y.K(O);const p=y.length();y.normalizeFromLength(p);const N=mI.Dot(i,y);let Q,s;if(N<1-j.d){const I=Math.acos(N),O=1/Math.sin(I);Q=Math.sin((1-C)*I)*O,s=Math.sin(C*I)*O}else Q=1-C,s=C;return i.scaleInPlace(Q),y.scaleInPlace(s),K.K(i).addInPlace(y),K.scaleInPlace((0,U.Lerp)(S,p,C)),K}static SmoothToRef(I,O,C,j,K){return mI.SlerpToRef(I,O,0===j?1:C/j,K),K}static YO(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new mI(I[O],I[O+1],I[O+2])}static FromFloatArray(I,O){return mI.YO(I,O)}static FromArrayToRef(I,O,C){return C._x=I[O],C._y=I[O+1],C._z=I[O+2],C._isDirty=!0,C}static FromFloatArrayToRef(I,O,C){return mI.FromArrayToRef(I,O,C)}static FromFloatsToRef(I,O,C,j){return j.cS(I,O,C),j}static Zero(){return new mI(0,0,0)}static One(){return new mI(1,1,1)}static Up(){return new mI(0,1,0)}static get UpReadOnly(){return mI._UpReadOnly}static get DownReadOnly(){return mI._DownReadOnly}static get RightReadOnly(){return mI._RightReadOnly}static get LeftReadOnly(){return mI._LeftReadOnly}static get LeftHandedForwardReadOnly(){return mI._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return mI._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return mI._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return mI._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return mI._ZeroReadOnly}static get OneReadOnly(){return mI._OneReadOnly}static Down(){return new mI(0,-1,0)}static Forward(){return new mI(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new mI(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new mI(1,0,0)}static Left(){return new mI(-1,0,0)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new mI((0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).cS((0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O))}static TransformCoordinates(I,O){const C=mI.Zero();return mI.TransformCoordinatesToRef(I,O,C),C}static TransformCoordinatesToRef(I,O,C){return mI.TransformCoordinatesFromFloatsToRef(I._x,I._y,I._z,O,C),C}static TransformCoordinatesFromFloatsToRef(I,O,C,j,K){const i=j.m,y=I*i[0]+O*i[4]+C*i[8]+i[12],S=I*i[1]+O*i[5]+C*i[9]+i[13],U=I*i[2]+O*i[6]+C*i[10]+i[14],p=1/(I*i[3]+O*i[7]+C*i[11]+i[15]);return K._x=y*p,K._y=S*p,K._z=U*p,K._isDirty=!0,K}static TransformNormal(I,O){const C=mI.Zero();return mI.TransformNormalToRef(I,O,C),C}static TransformNormalToRef(I,O,C){return this.TransformNormalFromFloatsToRef(I._x,I._y,I._z,O,C),C}static TransformNormalFromFloatsToRef(I,O,C,j,K){const i=j.m;return K._x=I*i[0]+O*i[4]+C*i[8],K._y=I*i[1]+O*i[5]+C*i[9],K._z=I*i[2]+O*i[6]+C*i[10],K._isDirty=!0,K}static CatmullRom(I,O,C,j,K){const i=K*K,y=K*i,S=.5*(2*O._x+(-I._x+C._x)*K+(2*I._x-5*O._x+4*C._x-j._x)*i+(-I._x+3*O._x-3*C._x+j._x)*y),U=.5*(2*O._y+(-I._y+C._y)*K+(2*I._y-5*O._y+4*C._y-j._y)*i+(-I._y+3*O._y-3*C._y+j._y)*y),p=.5*(2*O._z+(-I._z+C._z)*K+(2*I._z-5*O._z+4*C._z-j._z)*i+(-I._z+3*O._z-3*C._z+j._z)*y);return new mI(S,U,p)}static Clamp(I,O,C){const j=new mI;return mI.ClampToRef(I,O,C,j),j}static ClampToRef(I,O,C,j){let K=I._x;K=K>C._x?C._x:K,K=K<O._x?O._x:K;let i=I._y;i=i>C._y?C._y:i,i=i<O._y?O._y:i;let y=I._z;return y=y>C._z?C._z:y,y=y<O._z?O._z:y,j.cS(K,i,y),j}static CheckExtends(I,O,C){O.minimizeInPlace(I),C.maximizeInPlace(I)}static Hermite(I,O,C,j,K){const i=K*K,y=K*i,S=2*y-3*i+1,U=-2*y+3*i,p=y-2*i+K,N=y-i,Q=I._x*S+C._x*U+O._x*p+j._x*N,s=I._y*S+C._y*U+O._y*p+j._y*N,Z=I._z*S+C._z*U+O._z*p+j._z*N;return new mI(Q,s,Z)}static Hermite1stDerivative(I,O,C,j,K){const i=new mI;return this.Hermite1stDerivativeToRef(I,O,C,j,K,i),i}static Hermite1stDerivativeToRef(I,O,C,j,K,i){const y=K*K;return i._x=6*(y-K)*I._x+(3*y-4*K+1)*O._x+6*(-y+K)*C._x+(3*y-2*K)*j._x,i._y=6*(y-K)*I._y+(3*y-4*K+1)*O._y+6*(-y+K)*C._y+(3*y-2*K)*j._y,i._z=6*(y-K)*I._z+(3*y-4*K+1)*O._z+6*(-y+K)*C._z+(3*y-2*K)*j._z,i._isDirty=!0,i}static Lerp(I,O,C){const j=new mI(0,0,0);return mI.LerpToRef(I,O,C,j),j}static LerpToRef(I,O,C,j){return j._x=I._x+(O._x-I._x)*C,j._y=I._y+(O._y-I._y)*C,j._z=I._z+(O._z-I._z)*C,j._isDirty=!0,j}static Dot(I,O){return I._x*O._x+I._y*O._y+I._z*O._z}dot(I){return this._x*I._x+this._y*I._y+this._z*I._z}static Cross(I,O){const C=new mI;return mI.CrossToRef(I,O,C),C}static CrossToRef(I,O,C){const j=I._y*O._z-I._z*O._y,K=I._z*O._x-I._x*O._z,i=I._x*O._y-I._y*O._x;return C.cS(j,K,i),C}static Normalize(I){const O=mI.Zero();return mI.NormalizeToRef(I,O),O}static NormalizeToRef(I,O){return I.normalizeToRef(O),O}static Project(I,O,C,j){const K=new mI;return mI.ProjectToRef(I,O,C,j,K),K}static ProjectToRef(I,O,C,j,K){var i;const y=j.width,U=j.height,p=j.x,N=j.y,Q=W.Matrix[1],s=null===(i=S.e.LastCreatedEngine)||void 0===i?void 0:i.isNDCHalfZRange,Z=s?1:.5,q=s?0:.5;r.FromValuesToRef(y/2,0,0,0,0,-U/2,0,0,0,0,Z,0,p+y/2,U/2+N,q,1,Q);const E=W.Matrix[0];return O.multiplyToRef(C,E),E.multiplyToRef(Q,E),mI.TransformCoordinatesToRef(I,E,K),K}static Reflect(I,O){return this.ReflectToRef(I,O,new mI)}static ReflectToRef(I,O,C){const j=Y.mC[0];return j.K(O).scaleInPlace(2*mI.Dot(I,O)),C.K(I).OQ(j)}static _UnprojectFromInvertedMatrixToRef(I,O,C){mI.TransformCoordinatesToRef(I,O,C);const j=O.m,K=I._x*j[3]+I._y*j[7]+I._z*j[11]+j[15];return(0,U.WithinEpsilon)(K,1)&&C.scaleInPlace(1/K),C}static UnprojectFromTransform(I,O,C,j,K){return this.Unproject(I,O,C,j,K,r.IdentityReadOnly)}static Unproject(I,O,C,j,K,i){const y=new mI;return mI.UnprojectToRef(I,O,C,j,K,i,y),y}static UnprojectToRef(I,O,C,j,K,i,y){return mI.UnprojectFloatsToRef(I._x,I._y,I._z,O,C,j,K,i,y),y}static UnprojectFloatsToRef(I,O,C,j,K,i,y,U,p){var N;const Q=W.Matrix[0];i.multiplyToRef(y,Q),Q.multiplyToRef(U,Q),Q.invert();const s=W.mC[0];return s.x=I/j*2-1,s.y=-(O/K*2-1),null!==(N=S.e.LastCreatedEngine)&&void 0!==N&&N.isNDCHalfZRange?s.z=C:s.z=2*C-1,mI._UnprojectFromInvertedMatrixToRef(s,Q,p),p}static Minimize(I,O){const C=new mI;return C.K(I),C.minimizeInPlace(O),C}static Maximize(I,O){const C=new mI;return C.K(I),C.maximizeInPlace(O),C}static Distance(I,O){return Math.sqrt(mI.DistanceSquared(I,O))}static DistanceSquared(I,O){const C=I._x-O._x,j=I._y-O._y,K=I._z-O._z;return C*C+j*j+K*K}static ProjectOnTriangleToRef(I,O,C,K,i){const y=W.mC[0],S=W.mC[1],p=W.mC[2],N=W.mC[3],Q=W.mC[4];C.subtractToRef(O,y),K.subtractToRef(O,S),K.subtractToRef(C,p);const s=y.length(),Z=S.length(),q=p.length();if(s<j.d||Z<j.d||q<j.d)return i.K(O),mI.Distance(I,O);I.subtractToRef(O,Q),mI.CrossToRef(y,S,N);const E=N.length();if(E<j.d)return i.K(O),mI.Distance(I,O);N.normalizeFromLength(E);let h=Q.length();if(h<j.d)return i.K(O),0;Q.normalizeFromLength(h);const r=mI.Dot(N,Q),Y=W.mC[5],o=W.mC[6];Y.K(N).scaleInPlace(-h*r),o.K(I).addInPlace(Y);const c=W.mC[4],n=W.mC[5],X=W.mC[7],T=W.mC[8];c.K(y).scaleInPlace(1/s),T.K(S).scaleInPlace(1/Z),c.addInPlace(T).scaleInPlace(-1),n.K(y).scaleInPlace(-1/s),T.K(p).scaleInPlace(1/q),n.addInPlace(T).scaleInPlace(-1),X.K(p).scaleInPlace(-1/q),T.K(S).scaleInPlace(-1/Z),X.addInPlace(T).scaleInPlace(-1);const H=W.mC[9];let b;H.K(o).OQ(O),mI.CrossToRef(c,H,T),b=mI.Dot(T,N);const a=b;H.K(o).OQ(C),mI.CrossToRef(n,H,T),b=mI.Dot(T,N);const M=b;H.K(o).OQ(K),mI.CrossToRef(X,H,T),b=mI.Dot(T,N);const u=b,J=W.mC[10];let f,l;a>0&&M<0?(J.K(y),f=O,l=C):M>0&&u<0?(J.K(p),f=C,l=K):(J.K(S).scaleInPlace(-1),f=K,l=O);const x=W.mC[9],D=W.mC[4];f.subtractToRef(o,T),l.subtractToRef(o,x),mI.CrossToRef(T,x,D);if(!(mI.Dot(D,N)<0))return i.K(o),Math.abs(h*r);const t=W.mC[5];mI.CrossToRef(J,D,t),t.normalize();const d=W.mC[9];d.K(f).OQ(o);const w=d.length();if(w<j.d)return i.K(f),mI.Distance(I,f);d.normalizeFromLength(w);const g=mI.Dot(t,d),V=W.mC[7];V.K(o).addInPlace(t.scaleInPlace(w*g)),T.K(V).OQ(f),h=J.length(),J.normalizeFromLength(h);let e=mI.Dot(T,J)/Math.max(h,j.d);return e=(0,U.Clamp)(e,0,1),V.K(f).addInPlace(J.scaleInPlace(e*h)),i.K(V),mI.Distance(I,V)}static Center(I,O){return mI.CenterToRef(I,O,mI.Zero())}static CenterToRef(I,O,C){return C.cS((I._x+O._x)/2,(I._y+O._y)/2,(I._z+O._z)/2)}static RotationFromAxis(I,O,C){const j=new mI;return mI.RotationFromAxisToRef(I,O,C,j),j}static RotationFromAxisToRef(I,O,C,j){const K=W.Quaternion[0];return h.RotationQuaternionFromAxisToRef(I,O,C,K),K.toEulerAnglesToRef(j),j}}mI._V8PerformanceHack=new mI(.5,.5,.5),mI._UpReadOnly=mI.Up(),mI._DownReadOnly=mI.Down(),mI._LeftHandedForwardReadOnly=mI.Forward(!1),mI._RightHandedForwardReadOnly=mI.Forward(!0),mI._LeftHandedBackwardReadOnly=mI.Backward(!1),mI._RightHandedBackwardReadOnly=mI.Backward(!0),mI._RightReadOnly=mI.Right(),mI._LeftReadOnly=mI.Left(),mI._ZeroReadOnly=mI.Zero(),mI._OneReadOnly=mI.One(),Object.defineProperties(mI.prototype,{dimension:{value:[3]},rank:{value:1}});class E{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}get w(){return this._w}set w(I){this._w=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=I,this._y=O,this._z=C,this._w=j}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let I=Z(this._x);return I=397*I^Z(this._y),I=397*I^Z(this._z),I=397*I^Z(this._w),I}qS(){return[this._x,this._y,this._z,this._w]}toArray(I,O){return void 0===O&&(O=0),I[O]=this._x,I[O+1]=this._y,I[O+2]=this._z,I[O+3]=this._w,this}qC(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(I,O,this),this}addInPlace(I){return this.x+=I._x,this.y+=I._y,this.z+=I._z,this.w+=I._w,this}addInPlaceFromFloats(I,O,C,j){return this.x+=I,this.y+=O,this.z+=C,this.w+=j,this}add(I){return new E(this._x+I.x,this._y+I.y,this._z+I.z,this._w+I.w)}addToRef(I,O){return O.x=this._x+I.x,O.y=this._y+I.y,O.z=this._z+I.z,O.w=this._w+I.w,O}OQ(I){return this.x-=I.x,this.y-=I.y,this.z-=I.z,this.w-=I.w,this}EO(I){return new E(this._x-I.x,this._y-I.y,this._z-I.z,this._w-I.w)}subtractToRef(I,O){return O.x=this._x-I.x,O.y=this._y-I.y,O.z=this._z-I.z,O.w=this._w-I.w,O}subtractFromFloats(I,O,C,j){return new E(this._x-I,this._y-O,this._z-C,this._w-j)}subtractFromFloatsToRef(I,O,C,j,K){return K.x=this._x-I,K.y=this._y-O,K.z=this._z-C,K.w=this._w-j,K}negate(){return new E(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(I){return I.x=-this._x,I.y=-this._y,I.z=-this._z,I.w=-this._w,I}scaleInPlace(I){return this.x*=I,this.y*=I,this.z*=I,this.w*=I,this}scale(I){return new E(this._x*I,this._y*I,this._z*I,this._w*I)}scaleToRef(I,O){return O.x=this._x*I,O.y=this._y*I,O.z=this._z*I,O.w=this._w*I,O}scaleAndAddToRef(I,O){return O.x+=this._x*I,O.y+=this._y*I,O.z+=this._z*I,O.w+=this._w*I,O}equals(I){return I&&this._x===I.x&&this._y===I.y&&this._z===I.z&&this._w===I.w}equalsWithEpsilon(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return I&&(0,U.WithinEpsilon)(this._x,I.x,O)&&(0,U.WithinEpsilon)(this._y,I.y,O)&&(0,U.WithinEpsilon)(this._z,I.z,O)&&(0,U.WithinEpsilon)(this._w,I.w,O)}equalsToFloats(I,O,C,j){return this._x===I&&this._y===O&&this._z===C&&this._w===j}multiplyInPlace(I){return this.x*=I.x,this.y*=I.y,this.z*=I.z,this.w*=I.w,this}multiply(I){return new E(this._x*I.x,this._y*I.y,this._z*I.z,this._w*I.w)}multiplyToRef(I,O){return O.x=this._x*I.x,O.y=this._y*I.y,O.z=this._z*I.z,O.w=this._w*I.w,O}multiplyByFloats(I,O,C,j){return new E(this._x*I,this._y*O,this._z*C,this._w*j)}divide(I){return new E(this._x/I.x,this._y/I.y,this._z/I.z,this._w/I.w)}divideToRef(I,O){return O.x=this._x/I.x,O.y=this._y/I.y,O.z=this._z/I.z,O.w=this._w/I.w,O}divideInPlace(I){return this.divideToRef(I,this)}minimizeInPlace(I){return I.x<this._x&&(this.x=I.x),I.y<this._y&&(this.y=I.y),I.z<this._z&&(this.z=I.z),I.w<this._w&&(this.w=I.w),this}maximizeInPlace(I){return I.x>this._x&&(this.x=I.x),I.y>this._y&&(this.y=I.y),I.z>this._z&&(this.z=I.z),I.w>this._w&&(this.w=I.w),this}minimizeInPlaceFromFloats(I,O,C,j){return this.x=Math.min(I,this._x),this.y=Math.min(O,this._y),this.z=Math.min(C,this._z),this.w=Math.min(j,this._w),this}maximizeInPlaceFromFloats(I,O,C,j){return this.x=Math.max(I,this._x),this.y=Math.max(O,this._y),this.z=Math.max(C,this._z),this.w=Math.max(j,this._w),this}floorToRef(I){return I.x=Math.floor(this._x),I.y=Math.floor(this._y),I.z=Math.floor(this._z),I.w=Math.floor(this._w),I}floor(){return new E(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(I){return I.x=this._x-Math.floor(this._x),I.y=this._y-Math.floor(this._y),I.z=this._z-Math.floor(this._z),I.w=this._w-Math.floor(this._w),I}fract(){return new E(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){return this.normalizeToRef(new E)}normalizeToRef(I){const O=this.length();return 0===O||1===O?(I.x=this._x,I.y=this._y,I.z=this._z,I.w=this._w,I):this.scaleToRef(1/O,I)}toVector3(){return new mI(this._x,this._y,this._z)}clone(){return new E(this._x,this._y,this._z,this._w)}K(I){return this.x=I.x,this.y=I.y,this.z=I.z,this.w=I.w,this}cS(I,O,C,j){return this.x=I,this.y=O,this.z=C,this.w=j,this}set(I,O,C,j){return this.cS(I,O,C,j)}XS(I){return this.x=this.y=this.z=this.w=I,this}dot(I){return this._x*I.x+this._y*I.y+this._z*I.z+this._w*I.w}static YO(I,O){return O||(O=0),new E(I[O],I[O+1],I[O+2],I[O+3])}static FromArrayToRef(I,O,C){return C.x=I[O],C.y=I[O+1],C.z=I[O+2],C.w=I[O+3],C}static FromFloatArrayToRef(I,O,C){return E.FromArrayToRef(I,O,C),C}static FromFloatsToRef(I,O,C,j,K){return K.x=I,K.y=O,K.z=C,K.w=j,K}static Zero(){return new E(0,0,0,0)}static One(){return new E(1,1,1,1)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E((0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.x=(0,U.RandomRange)(I,O),C.y=(0,U.RandomRange)(I,O),C.z=(0,U.RandomRange)(I,O),C.w=(0,U.RandomRange)(I,O),C}static Clamp(I,O,C){return E.ClampToRef(I,O,C,new E)}static ClampToRef(I,O,C,j){return j.x=(0,U.Clamp)(I.x,O.x,C.x),j.y=(0,U.Clamp)(I.y,O.y,C.y),j.z=(0,U.Clamp)(I.z,O.z,C.z),j.w=(0,U.Clamp)(I.w,O.w,C.w),j}static CheckExtends(I,O,C){O.minimizeInPlace(I),C.maximizeInPlace(I)}static get ZeroReadOnly(){return E._ZeroReadOnly}static Normalize(I){return E.NormalizeToRef(I,new E)}static NormalizeToRef(I,O){return I.normalizeToRef(O),O}static Minimize(I,O){const C=new E;return C.K(I),C.minimizeInPlace(O),C}static Maximize(I,O){const C=new E;return C.K(I),C.maximizeInPlace(O),C}static Distance(I,O){return Math.sqrt(E.DistanceSquared(I,O))}static DistanceSquared(I,O){const C=I.x-O.x,j=I.y-O.y,K=I.z-O.z,i=I.w-O.w;return C*C+j*j+K*K+i*i}static Center(I,O){return E.CenterToRef(I,O,new E)}static CenterToRef(I,O,C){return C.x=(I.x+O.x)/2,C.y=(I.y+O.y)/2,C.z=(I.z+O.z)/2,C.w=(I.w+O.w)/2,C}static TransformCoordinates(I,O){return E.TransformCoordinatesToRef(I,O,new E)}static TransformCoordinatesToRef(I,O,C){return E.TransformCoordinatesFromFloatsToRef(I._x,I._y,I._z,O,C),C}static TransformCoordinatesFromFloatsToRef(I,O,C,j,K){const i=j.m,y=I*i[0]+O*i[4]+C*i[8]+i[12],S=I*i[1]+O*i[5]+C*i[9]+i[13],U=I*i[2]+O*i[6]+C*i[10]+i[14],p=I*i[3]+O*i[7]+C*i[11]+i[15];return K.x=y,K.y=S,K.z=U,K.w=p,K}static TransformNormal(I,O){return E.TransformNormalToRef(I,O,new E)}static TransformNormalToRef(I,O,C){const j=O.m,K=I.x*j[0]+I.y*j[4]+I.z*j[8],i=I.x*j[1]+I.y*j[5]+I.z*j[9],y=I.x*j[2]+I.y*j[6]+I.z*j[10];return C.x=K,C.y=i,C.z=y,C.w=I.w,C}static TransformNormalFromFloatsToRef(I,O,C,j,K,i){const y=K.m;return i.x=I*y[0]+O*y[4]+C*y[8],i.y=I*y[1]+O*y[5]+C*y[9],i.z=I*y[2]+O*y[6]+C*y[10],i.w=j,i}static FromVector3(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(I._x,I._y,I._z,O)}static Dot(I,O){return I.x*O.x+I.y*O.y+I.z*O.z+I.w*O.w}}E._V8PerformanceHack=new E(.5,.5,.5,.5),E._ZeroReadOnly=E.Zero(),Object.defineProperties(E.prototype,{dimension:{value:[4]},rank:{value:1}});class h{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}get w(){return this._w}set w(I){this._w=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=I,this._y=O,this._z=C,this._w=j}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let I=Z(this._x);return I=397*I^Z(this._y),I=397*I^Z(this._z),I=397*I^Z(this._w),I}qS(){return[this._x,this._y,this._z,this._w]}toArray(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[O]=this._x,I[O+1]=this._y,I[O+2]=this._z,I[O+3]=this._w,this}qC(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h.FromArrayToRef(I,O,this)}equals(I){return I&&this._x===I._x&&this._y===I._y&&this._z===I._z&&this._w===I._w}equalsWithEpsilon(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return I&&(0,U.WithinEpsilon)(this._x,I._x,O)&&(0,U.WithinEpsilon)(this._y,I._y,O)&&(0,U.WithinEpsilon)(this._z,I._z,O)&&(0,U.WithinEpsilon)(this._w,I._w,O)}isApprox(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return I&&((0,U.WithinEpsilon)(this._x,I._x,O)&&(0,U.WithinEpsilon)(this._y,I._y,O)&&(0,U.WithinEpsilon)(this._z,I._z,O)&&(0,U.WithinEpsilon)(this._w,I._w,O)||(0,U.WithinEpsilon)(this._x,-I._x,O)&&(0,U.WithinEpsilon)(this._y,-I._y,O)&&(0,U.WithinEpsilon)(this._z,-I._z,O)&&(0,U.WithinEpsilon)(this._w,-I._w,O))}clone(){return new h(this._x,this._y,this._z,this._w)}K(I){return this._x=I._x,this._y=I._y,this._z=I._z,this._w=I._w,this._isDirty=!0,this}cS(I,O,C,j){return this._x=I,this._y=O,this._z=C,this._w=j,this._isDirty=!0,this}set(I,O,C,j){return this.cS(I,O,C,j)}XS(I){return this.cS(I,I,I,I)}add(I){return new h(this._x+I._x,this._y+I._y,this._z+I._z,this._w+I._w)}addInPlace(I){return this._x+=I._x,this._y+=I._y,this._z+=I._z,this._w+=I._w,this._isDirty=!0,this}addToRef(I,O){return O._x=this._x+I._x,O._y=this._y+I._y,O._z=this._z+I._z,O._w=this._w+I._w,O._isDirty=!0,O}addInPlaceFromFloats(I,O,C,j){return this._x+=I,this._y+=O,this._z+=C,this._w+=j,this._isDirty=!0,this}subtractToRef(I,O){return O._x=this._x-I._x,O._y=this._y-I._y,O._z=this._z-I._z,O._w=this._w-I._w,O._isDirty=!0,O}subtractFromFloats(I,O,C,j){return this.subtractFromFloatsToRef(I,O,C,j,new h)}subtractFromFloatsToRef(I,O,C,j,K){return K._x=this._x-I,K._y=this._y-O,K._z=this._z-C,K._w=this._w-j,K._isDirty=!0,K}EO(I){return new h(this._x-I._x,this._y-I._y,this._z-I._z,this._w-I._w)}OQ(I){return this._x-=I._x,this._y-=I._y,this._z-=I._z,this._w-=I._w,this._isDirty=!0,this}scale(I){return new h(this._x*I,this._y*I,this._z*I,this._w*I)}scaleToRef(I,O){return O._x=this._x*I,O._y=this._y*I,O._z=this._z*I,O._w=this._w*I,O._isDirty=!0,O}scaleInPlace(I){return this._x*=I,this._y*=I,this._z*=I,this._w*=I,this._isDirty=!0,this}scaleAndAddToRef(I,O){return O._x+=this._x*I,O._y+=this._y*I,O._z+=this._z*I,O._w+=this._w*I,O._isDirty=!0,O}multiply(I){const O=new h(0,0,0,1);return this.multiplyToRef(I,O),O}multiplyToRef(I,O){const C=this._x*I._w+this._y*I._z-this._z*I._y+this._w*I._x,j=-this._x*I._z+this._y*I._w+this._z*I._x+this._w*I._y,K=this._x*I._y-this._y*I._x+this._z*I._w+this._w*I._z,i=-this._x*I._x-this._y*I._y-this._z*I._z+this._w*I._w;return O.cS(C,j,K,i),O}multiplyInPlace(I){return this.multiplyToRef(I,this)}multiplyByFloats(I,O,C,j){return this._x*=I,this._y*=O,this._z*=C,this._w*=j,this._isDirty=!0,this}divide(I){throw new ReferenceError("Can not divide a quaternion")}divideToRef(I,O){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(I){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new h)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(I){return I._x=-this._x,I._y=-this._y,I._z=-this._z,I._w=-this._w,I._isDirty=!0,I}equalsToFloats(I,O,C,j){return this._x===I&&this._y===O&&this._z===C&&this._w===j}floorToRef(I){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(I){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(I){return I.cS(-this._x,-this._y,-this._z,this._w),I}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new h(-this._x,-this._y,-this._z,this._w)}invert(){const I=this.conjugate(),O=this.lengthSquared();return 0==O||1==O||I.scaleInPlace(1/O),I}invertInPlace(){this.conjugateInPlace();const I=this.lengthSquared();return 0==I||1==I||this.scaleInPlace(1/I),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){const I=new h(0,0,0,1);return this.normalizeToRef(I),I}normalizeToRef(I){const O=this.length();return 0===O||1===O?I.cS(this._x,this._y,this._z,this._w):this.scaleToRef(1/O,I)}toEulerAngles(){const I=mI.Zero();return this.toEulerAnglesToRef(I),I}toEulerAnglesToRef(I){const O=this._z,C=this._x,j=this._y,K=this._w,i=j*O-C*K,y=.4999999;if(i<-y)I._y=2*Math.atan2(j,K),I._x=Math.PI/2,I._z=0,I._isDirty=!0;else if(i>y)I._y=2*Math.atan2(j,K),I._x=-Math.PI/2,I._z=0,I._isDirty=!0;else{const y=K*K,S=O*O,U=C*C,p=j*j;I._z=Math.atan2(2*(C*j+O*K),-S-U+p+y),I._x=Math.asin(-2*i),I._y=Math.atan2(2*(O*C+j*K),S-U-p+y),I._isDirty=!0}return I}toAlphaBetaGammaToRef(I){const O=this._z,C=this._x,j=this._y,K=this._w,i=Math.sqrt(C*C+j*j),y=Math.sqrt(O*O+K*K),S=2*Math.atan2(i,y),U=2*Math.atan2(O,K),p=2*Math.atan2(j,C),N=(U+p)/2,Q=(U-p)/2;return I.set(Q,S,N),I}toRotationMatrix(I){return r.FromQuaternionToRef(this,I),I}fromRotationMatrix(I){return h.FromRotationMatrixToRef(I,this),this}dot(I){return this._x*I._x+this._y*I._y+this._z*I._z+this._w*I._w}toAxisAngle(){const I=mI.Zero();return{axis:I,angle:this.toAxisAngleToRef(I)}}toAxisAngleToRef(I){let O=0;const C=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),j=this._w;return C>0?(O=2*Math.atan2(C,j),I.set(this._x/C,this._y/C,this._z/C)):(O=0,I.set(1,0,0)),O}static FromRotationMatrix(I){const O=new h;return h.FromRotationMatrixToRef(I,O),O}static FromRotationMatrixToRef(I,O){const C=I.m,j=C[0],K=C[4],i=C[8],y=C[1],S=C[5],U=C[9],p=C[2],N=C[6],Q=C[10],s=j+S+Q;let Z;return s>0?(Z=.5/Math.sqrt(s+1),O._w=.25/Z,O._x=(N-U)*Z,O._y=(i-p)*Z,O._z=(y-K)*Z,O._isDirty=!0):j>S&&j>Q?(Z=2*Math.sqrt(1+j-S-Q),O._w=(N-U)/Z,O._x=.25*Z,O._y=(K+y)/Z,O._z=(i+p)/Z,O._isDirty=!0):S>Q?(Z=2*Math.sqrt(1+S-j-Q),O._w=(i-p)/Z,O._x=(K+y)/Z,O._y=.25*Z,O._z=(U+N)/Z,O._isDirty=!0):(Z=2*Math.sqrt(1+Q-j-S),O._w=(y-K)/Z,O._x=(i+p)/Z,O._y=(U+N)/Z,O._z=.25*Z,O._isDirty=!0),O}static Dot(I,O){return I._x*O._x+I._y*O._y+I._z*O._z+I._w*O._w}static AreClose(I,O){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const j=h.Dot(I,O);return 1-j*j<=C}static SmoothToRef(I,O,C,j,K){let i=0===j?1:C/j;return i=(0,U.Clamp)(i,0,1),h.SlerpToRef(I,O,i,K),K}static Zero(){return new h(0,0,0,0)}static Inverse(I){return new h(-I._x,-I._y,-I._z,I._w)}static InverseToRef(I,O){return O.set(-I._x,-I._y,-I._z,I._w),O}static Identity(){return new h(0,0,0,1)}static IsIdentity(I){return I&&0===I._x&&0===I._y&&0===I._z&&1===I._w}static RotationAxis(I,O){return h.RotationAxisToRef(I,O,new h)}static RotationAxisToRef(I,O,C){C._w=Math.cos(O/2);const j=Math.sin(O/2)/I.length();return C._x=I._x*j,C._y=I._y*j,C._z=I._z*j,C._isDirty=!0,C}static YO(I,O){return O||(O=0),new h(I[O],I[O+1],I[O+2],I[O+3])}static FromArrayToRef(I,O,C){return C._x=I[O],C._y=I[O+1],C._z=I[O+2],C._w=I[O+3],C._isDirty=!0,C}static FromFloatsToRef(I,O,C,j,K){return K.cS(I,O,C,j),K}static FromEulerAngles(I,O,C){const j=new h;return h.RotationYawPitchRollToRef(O,I,C,j),j}static FromEulerAnglesToRef(I,O,C,j){return h.RotationYawPitchRollToRef(O,I,C,j),j}static FromEulerVector(I){const O=new h;return h.RotationYawPitchRollToRef(I._y,I._x,I._z,O),O}static FromEulerVectorToRef(I,O){return h.RotationYawPitchRollToRef(I._y,I._x,I._z,O),O}static FromUnitVectorsToRef(I,O,C){let K=arguments.length>3&&void 0!==arguments[3]?arguments[3]:j.d;const i=mI.Dot(I,O)+1;return i<K?Math.abs(I.x)>Math.abs(I.z)?C.set(-I.y,I.x,0,0):C.set(0,-I.z,I.y,0):(mI.CrossToRef(I,O,Y.mC[0]),C.set(Y.mC[0].x,Y.mC[0].y,Y.mC[0].z,i)),C.normalize()}static RotationYawPitchRoll(I,O,C){const j=new h;return h.RotationYawPitchRollToRef(I,O,C,j),j}static RotationYawPitchRollToRef(I,O,C,j){const K=.5*C,i=.5*O,y=.5*I,S=Math.sin(K),U=Math.cos(K),p=Math.sin(i),N=Math.cos(i),Q=Math.sin(y),s=Math.cos(y);return j._x=s*p*U+Q*N*S,j._y=Q*N*U-s*p*S,j._z=s*N*S-Q*p*U,j._w=s*N*U+Q*p*S,j._isDirty=!0,j}static RotationAlphaBetaGamma(I,O,C){const j=new h;return h.RotationAlphaBetaGammaToRef(I,O,C,j),j}static RotationAlphaBetaGammaToRef(I,O,C,j){const K=.5*(C+I),i=.5*(C-I),y=.5*O;return j._x=Math.cos(i)*Math.sin(y),j._y=Math.sin(i)*Math.sin(y),j._z=Math.sin(K)*Math.cos(y),j._w=Math.cos(K)*Math.cos(y),j._isDirty=!0,j}static RotationQuaternionFromAxis(I,O,C){const j=new h(0,0,0,0);return h.RotationQuaternionFromAxisToRef(I,O,C,j),j}static RotationQuaternionFromAxisToRef(I,O,C,j){const K=W.Matrix[0];return I=I.normalizeToRef(W.mC[0]),O=O.normalizeToRef(W.mC[1]),C=C.normalizeToRef(W.mC[2]),r.FromXYZAxesToRef(I,O,C,K),h.FromRotationMatrixToRef(K,j),j}static FromLookDirectionLH(I,O){const C=new h;return h.FromLookDirectionLHToRef(I,O,C),C}static FromLookDirectionLHToRef(I,O,C){const j=W.Matrix[0];return r.LookDirectionLHToRef(I,O,j),h.FromRotationMatrixToRef(j,C),C}static FromLookDirectionRH(I,O){const C=new h;return h.FromLookDirectionRHToRef(I,O,C),C}static FromLookDirectionRHToRef(I,O,C){const j=W.Matrix[0];return r.LookDirectionRHToRef(I,O,j),h.FromRotationMatrixToRef(j,C)}static Slerp(I,O,C){const j=h.Identity();return h.SlerpToRef(I,O,C,j),j}static SlerpToRef(I,O,C,j){let K,i,y=I._x*O._x+I._y*O._y+I._z*O._z+I._w*O._w,S=!1;if(y<0&&(S=!0,y=-y),y>.999999)i=1-C,K=S?-C:C;else{const I=Math.acos(y),O=1/Math.sin(I);i=Math.sin((1-C)*I)*O,K=S?-Math.sin(C*I)*O:Math.sin(C*I)*O}return j._x=i*I._x+K*O._x,j._y=i*I._y+K*O._y,j._z=i*I._z+K*O._z,j._w=i*I._w+K*O._w,j._isDirty=!0,j}static Hermite(I,O,C,j,K){const i=K*K,y=K*i,S=2*y-3*i+1,U=-2*y+3*i,p=y-2*i+K,N=y-i,Q=I._x*S+C._x*U+O._x*p+j._x*N,s=I._y*S+C._y*U+O._y*p+j._y*N,Z=I._z*S+C._z*U+O._z*p+j._z*N,q=I._w*S+C._w*U+O._w*p+j._w*N;return new h(Q,s,Z,q)}static Hermite1stDerivative(I,O,C,j,K){const i=new h;return this.Hermite1stDerivativeToRef(I,O,C,j,K,i),i}static Hermite1stDerivativeToRef(I,O,C,j,K,i){const y=K*K;return i._x=6*(y-K)*I._x+(3*y-4*K+1)*O._x+6*(-y+K)*C._x+(3*y-2*K)*j._x,i._y=6*(y-K)*I._y+(3*y-4*K+1)*O._y+6*(-y+K)*C._y+(3*y-2*K)*j._y,i._z=6*(y-K)*I._z+(3*y-4*K+1)*O._z+6*(-y+K)*C._z+(3*y-2*K)*j._z,i._w=6*(y-K)*I._w+(3*y-4*K+1)*O._w+6*(-y+K)*C._w+(3*y-2*K)*j._w,i._isDirty=!0,i}static Normalize(I){const O=h.Zero();return h.NormalizeToRef(I,O),O}static NormalizeToRef(I,O){return I.normalizeToRef(O),O}static Clamp(I,O,C){const j=new h;return h.ClampToRef(I,O,C,j),j}static ClampToRef(I,O,C,j){return j.cS((0,U.Clamp)(I.x,O.x,C.x),(0,U.Clamp)(I.y,O.y,C.y),(0,U.Clamp)(I.z,O.z,C.z),(0,U.Clamp)(I.w,O.w,C.w))}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new h((0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).cS((0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O),(0,U.RandomRange)(I,O))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(I,O){return Math.sqrt(h.DistanceSquared(I,O))}static DistanceSquared(I,O){const C=I.x-O.x,j=I.y-O.y,K=I.z-O.z,i=I.w-O.w;return C*C+j*j+K*K+i*i}static Center(I,O){return h.CenterToRef(I,O,h.Zero())}static CenterToRef(I,O,C){return C.cS((I.x+O.x)/2,(I.y+O.y)/2,(I.z+O.z)/2,(I.w+O.w)/2)}}h._V8PerformanceHack=new h(.5,.5,.5,.5),Object.defineProperties(h.prototype,{dimension:{value:[4]},rank:{value:1}});class r{static get Use64Bits(){return y.b.MatrixUse64Bits}get m(){return this.US}markAsUpdated(){this.updateFlag=p._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(I){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],j=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=I,this._isIdentity3x2=I||C,this._isIdentityDirty=!this._isIdentity&&O,this._isIdentity3x2Dirty=!this._isIdentity3x2&&j}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,y.b.MatrixTrackPrecisionChange&&y.b.MatrixTrackedMatrices.push(this),this.US=new y.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const I=this.US;this._isIdentity=1===I[0]&&0===I[1]&&0===I[2]&&0===I[3]&&0===I[4]&&1===I[5]&&0===I[6]&&0===I[7]&&0===I[8]&&0===I[9]&&1===I[10]&&0===I[11]&&0===I[12]&&0===I[13]&&0===I[14]&&1===I[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.US[0]||1!==this.US[5]||1!==this.US[15]||0!==this.US[1]||0!==this.US[2]||0!==this.US[3]||0!==this.US[4]||0!==this.US[6]||0!==this.US[7]||0!==this.US[8]||0!==this.US[9]||0!==this.US[10]||0!==this.US[11]||0!==this.US[12]||0!==this.US[13]||0!==this.US[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const I=this.US,O=I[0],C=I[1],j=I[2],K=I[3],i=I[4],y=I[5],S=I[6],U=I[7],p=I[8],N=I[9],Q=I[10],s=I[11],Z=I[12],q=I[13],mI=I[14],E=I[15],h=Q*E-mI*s,r=N*E-q*s,W=N*mI-q*Q,Y=p*E-Z*s,o=p*mI-Q*Z,c=p*q-Z*N;return O*+(y*h-S*r+U*W)+C*-(i*h-S*Y+U*o)+j*+(i*r-y*Y+U*c)+K*-(i*W-y*o+S*c)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!I)return this.US;const C=this.US;for(let j=0;j<16;j++)I[O+j]=C[j];return this}qS(){return this.US}qC(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r.FromArrayToRef(I,O,this)}cS(){for(var I=arguments.length,O=new Array(I),C=0;C<I;C++)O[C]=arguments[C];return r.FromArrayToRef(O,0,this)}set(){const I=this.US;for(let O=0;O<16;O++)I[O]=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}XS(I){const O=this.US;for(let C=0;C<16;C++)O[C]=I;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return r.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(I){const O=new r;return this.addToRef(I,O),O}addToRef(I,O){const C=this.US,j=O.US,K=I.m;for(let i=0;i<16;i++)j[i]=C[i]+K[i];return O.markAsUpdated(),O}addToSelf(I){const O=this.US,C=I.m;return O[0]+=C[0],O[1]+=C[1],O[2]+=C[2],O[3]+=C[3],O[4]+=C[4],O[5]+=C[5],O[6]+=C[6],O[7]+=C[7],O[8]+=C[8],O[9]+=C[9],O[10]+=C[10],O[11]+=C[11],O[12]+=C[12],O[13]+=C[13],O[14]+=C[14],O[15]+=C[15],this.markAsUpdated(),this}addInPlace(I){const O=this.US,C=I.m;for(let j=0;j<16;j++)O[j]+=C[j];return this.markAsUpdated(),this}addInPlaceFromFloats(){const I=this.US;for(let O=0;O<16;O++)I[O]+=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}EO(I){const O=this.US,C=I.m;for(let j=0;j<16;j++)O[j]-=C[j];return this.markAsUpdated(),this}subtractToRef(I,O){const C=this.US,j=I.m,K=O.US;for(let i=0;i<16;i++)K[i]=C[i]-j[i];return O.markAsUpdated(),O}OQ(I){const O=this.US,C=I.m;for(let j=0;j<16;j++)O[j]-=C[j];return this.markAsUpdated(),this}subtractFromFloats(){for(var I=arguments.length,O=new Array(I),C=0;C<I;C++)O[C]=arguments[C];return this.subtractFromFloatsToRef(...O,new r)}subtractFromFloatsToRef(){for(var I=arguments.length,O=new Array(I),C=0;C<I;C++)O[C]=arguments[C];const j=O.pop(),K=this.US,i=j.US,y=O;for(let S=0;S<16;S++)i[S]=K[S]-y[S];return j.markAsUpdated(),j}invertToRef(I){return!0===this._isIdentity?(r.IdentityToRef(I),I):(s(this,I.qS())?I.markAsUpdated():I.K(this),I)}addAtIndex(I,O){return this.US[I]+=O,this.markAsUpdated(),this}multiplyAtIndex(I,O){return this.US[I]*=O,this.markAsUpdated(),this}setTranslationFromFloats(I,O,C){return this.US[12]=I,this.US[13]=O,this.US[14]=C,this.markAsUpdated(),this}addTranslationFromFloats(I,O,C){return this.US[12]+=I,this.US[13]+=O,this.US[14]+=C,this.markAsUpdated(),this}setTranslation(I){return this.setTranslationFromFloats(I._x,I._y,I._z)}getTranslation(){return new mI(this.US[12],this.US[13],this.US[14])}getTranslationToRef(I){return I.x=this.US[12],I.y=this.US[13],I.z=this.US[14],I}removeRotationAndScaling(){const I=this.m;return r.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,I[12],I[13],I[14],I[15],this),this._updateIdentityStatus(0===I[12]&&0===I[13]&&0===I[14]&&1===I[15]),this}K(I){I.copyToArray(this.US);const O=I;return this.updateFlag=O.updateFlag,this._updateIdentityStatus(O._isIdentity,O._isIdentityDirty,O._isIdentity3x2,O._isIdentity3x2Dirty),this}copyToArray(I){return Q(this,I,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(I){const O=new r;return this.multiplyToRef(I,O),O}multiplyInPlace(I){const O=this.US,C=I.m;for(let j=0;j<16;j++)O[j]*=C[j];return this.markAsUpdated(),this}multiplyByFloats(){const I=this.US;for(let O=0;O<16;O++)I[O]*=O<0||arguments.length<=O?void 0:arguments[O];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var I=arguments.length,O=new Array(I),C=0;C<I;C++)O[C]=arguments[C];const j=O.pop(),K=this.US,i=j.US,y=O;for(let S=0;S<16;S++)i[S]=K[S]*y[S];return j.markAsUpdated(),j}multiplyToRef(I,O){return this._isIdentity?(O.K(I),O):I._isIdentity?(O.K(this),O):(this.multiplyToArray(I,O.US,0),O.markAsUpdated(),O)}multiplyToArray(I,O,C){return N(this,I,O,C),this}divide(I){return this.divideToRef(I,new r)}divideToRef(I,O){const C=this.US,j=I.m,K=O.US;for(let i=0;i<16;i++)K[i]=C[i]/j[i];return O.markAsUpdated(),O}divideInPlace(I){const O=this.US,C=I.m;for(let j=0;j<16;j++)O[j]/=C[j];return this.markAsUpdated(),this}minimizeInPlace(I){const O=this.US,C=I.m;for(let j=0;j<16;j++)O[j]=Math.min(O[j],C[j]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const I=this.US;for(let O=0;O<16;O++)I[O]=Math.min(I[O],O<0||arguments.length<=O?void 0:arguments[O]);return this.markAsUpdated(),this}maximizeInPlace(I){const O=this.US,C=I.m;for(let j=0;j<16;j++)O[j]=Math.min(O[j],C[j]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const I=this.US;for(let O=0;O<16;O++)I[O]=Math.min(I[O],O<0||arguments.length<=O?void 0:arguments[O]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new r)}negateInPlace(){const I=this.US;for(let O=0;O<16;O++)I[O]=-I[O];return this.markAsUpdated(),this}negateToRef(I){const O=this.US,C=I.US;for(let j=0;j<16;j++)C[j]=-O[j];return I.markAsUpdated(),I}equals(I){const O=I;if(!O)return!1;if((this._isIdentity||O._isIdentity)&&!this._isIdentityDirty&&!O._isIdentityDirty)return this._isIdentity&&O._isIdentity;const C=this.m,j=O.m;return C[0]===j[0]&&C[1]===j[1]&&C[2]===j[2]&&C[3]===j[3]&&C[4]===j[4]&&C[5]===j[5]&&C[6]===j[6]&&C[7]===j[7]&&C[8]===j[8]&&C[9]===j[9]&&C[10]===j[10]&&C[11]===j[11]&&C[12]===j[12]&&C[13]===j[13]&&C[14]===j[14]&&C[15]===j[15]}equalsWithEpsilon(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this.US,j=I.m;for(let K=0;K<16;K++)if(!(0,U.WithinEpsilon)(C[K],j[K],O))return!1;return!0}equalsToFloats(){const I=this.US;for(let O=0;O<16;O++)if(I[O]!=(O<0||arguments.length<=O?void 0:arguments[O]))return!1;return!0}floor(){return this.floorToRef(new r)}floorToRef(I){const O=this.US,C=I.US;for(let j=0;j<16;j++)C[j]=Math.floor(O[j]);return I.markAsUpdated(),I}fract(){return this.fractToRef(new r)}fractToRef(I){const O=this.US,C=I.US;for(let j=0;j<16;j++)C[j]=O[j]-Math.floor(O[j]);return I.markAsUpdated(),I}clone(){const I=new r;return I.K(this),I}getClassName(){return"Matrix"}getHashCode(){let I=Z(this.US[0]);for(let O=1;O<16;O++)I=397*I^Z(this.US[O]);return I}decomposeToTransformNode(I){return I.rotationQuaternion=I.rotationQuaternion||new h,this.decompose(I.nS,I.rotationQuaternion,I.position)}decompose(I,O,C,j){let K=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return C&&C.XS(0),I&&I.XS(1),O&&O.cS(0,0,0,1),!0;const i=this.US;if(C&&C.cS(i[12],i[13],i[14]),(I=I||W.mC[0]).x=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]),I.y=Math.sqrt(i[4]*i[4]+i[5]*i[5]+i[6]*i[6]),I.z=Math.sqrt(i[8]*i[8]+i[9]*i[9]+i[10]*i[10]),j){const O=(K?j.absoluteScaling.x:j.nS.x)<0?-1:1,C=(K?j.absoluteScaling.y:j.nS.y)<0?-1:1,i=(K?j.absoluteScaling.z:j.nS.z)<0?-1:1;I.x*=O,I.y*=C,I.z*=i}else this.determinant()<=0&&(I.y*=-1);if(0===I._x||0===I._y||0===I._z)return O&&O.cS(0,0,0,1),!1;if(O){const C=1/I._x,j=1/I._y,K=1/I._z;r.FromValuesToRef(i[0]*C,i[1]*C,i[2]*C,0,i[4]*j,i[5]*j,i[6]*j,0,i[8]*K,i[9]*K,i[10]*K,0,0,0,0,1,W.Matrix[0]),h.FromRotationMatrixToRef(W.Matrix[0],O)}return!0}getRow(I){if(I<0||I>3)return null;const O=4*I;return new E(this.US[O+0],this.US[O+1],this.US[O+2],this.US[O+3])}getRowToRef(I,O){if(I>=0&&I<=3){const C=4*I;O.x=this.US[C+0],O.y=this.US[C+1],O.z=this.US[C+2],O.w=this.US[C+3]}return O}setRow(I,O){return this.setRowFromFloats(I,O.x,O.y,O.z,O.w)}transpose(){const I=new r;return r.TransposeToRef(this,I),I}transposeToRef(I){return r.TransposeToRef(this,I),I}setRowFromFloats(I,O,C,j,K){if(I<0||I>3)return this;const i=4*I;return this.US[i+0]=O,this.US[i+1]=C,this.US[i+2]=j,this.US[i+3]=K,this.markAsUpdated(),this}scale(I){const O=new r;return this.scaleToRef(I,O),O}scaleToRef(I,O){for(let C=0;C<16;C++)O.US[C]=this.US[C]*I;return O.markAsUpdated(),O}scaleAndAddToRef(I,O){for(let C=0;C<16;C++)O.US[C]+=this.US[C]*I;return O.markAsUpdated(),O}scaleInPlace(I){const O=this.US;for(let C=0;C<16;C++)O[C]*=I;return this.markAsUpdated(),this}toNormalMatrix(I){const O=W.Matrix[0];this.invertToRef(O),O.transposeToRef(I);const C=I.US;return r.FromValuesToRef(C[0],C[1],C[2],0,C[4],C[5],C[6],0,C[8],C[9],C[10],0,0,0,0,1,I),I}getRotationMatrix(){const I=new r;return this.getRotationMatrixToRef(I),I}getRotationMatrixToRef(I){const O=W.mC[0];if(!this.decompose(O))return r.IdentityToRef(I),I;const C=this.US,j=1/O._x,K=1/O._y,i=1/O._z;return r.FromValuesToRef(C[0]*j,C[1]*j,C[2]*j,0,C[4]*K,C[5]*K,C[6]*K,0,C[8]*i,C[9]*i,C[10]*i,0,0,0,0,1,I),I}toggleModelMatrixHandInPlace(){const I=this.US;return I[2]*=-1,I[6]*=-1,I[8]*=-1,I[9]*=-1,I[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const I=this.US;return I[8]*=-1,I[9]*=-1,I[10]*=-1,I[11]*=-1,this.markAsUpdated(),this}static YO(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=new r;return r.FromArrayToRef(I,O,C),C}static FromArrayToRef(I,O,C){for(let j=0;j<16;j++)C.US[j]=I[j+O];return C.markAsUpdated(),C}static FromFloat32ArrayToRefScaled(I,O,C,j){return j.US[0]=I[0+O]*C,j.US[1]=I[1+O]*C,j.US[2]=I[2+O]*C,j.US[3]=I[3+O]*C,j.US[4]=I[4+O]*C,j.US[5]=I[5+O]*C,j.US[6]=I[6+O]*C,j.US[7]=I[7+O]*C,j.US[8]=I[8+O]*C,j.US[9]=I[9+O]*C,j.US[10]=I[10+O]*C,j.US[11]=I[11+O]*C,j.US[12]=I[12+O]*C,j.US[13]=I[13+O]*C,j.US[14]=I[14+O]*C,j.US[15]=I[15+O]*C,j.markAsUpdated(),j}static get IdentityReadOnly(){return r._IdentityReadOnly}static FromValuesToRef(I,O,C,j,K,i,y,S,U,p,N,Q,s,Z,q,mI,E){const h=E.US;h[0]=I,h[1]=O,h[2]=C,h[3]=j,h[4]=K,h[5]=i,h[6]=y,h[7]=S,h[8]=U,h[9]=p,h[10]=N,h[11]=Q,h[12]=s,h[13]=Z,h[14]=q,h[15]=mI,E.markAsUpdated()}static FromValues(I,O,C,j,K,i,y,S,U,p,N,Q,s,Z,q,mI){const E=new r,h=E.US;return h[0]=I,h[1]=O,h[2]=C,h[3]=j,h[4]=K,h[5]=i,h[6]=y,h[7]=S,h[8]=U,h[9]=p,h[10]=N,h[11]=Q,h[12]=s,h[13]=Z,h[14]=q,h[15]=mI,E.markAsUpdated(),E}static Compose(I,O,C){const j=new r;return r.ComposeToRef(I,O,C,j),j}static ComposeToRef(I,O,C,j){const K=j.US,i=O._x,y=O._y,S=O._z,U=O._w,p=i+i,N=y+y,Q=S+S,s=i*p,Z=i*N,q=i*Q,mI=y*N,E=y*Q,h=S*Q,r=U*p,W=U*N,Y=U*Q,o=I._x,c=I._y,n=I._z;return K[0]=(1-(mI+h))*o,K[1]=(Z+Y)*o,K[2]=(q-W)*o,K[3]=0,K[4]=(Z-Y)*c,K[5]=(1-(s+h))*c,K[6]=(E+r)*c,K[7]=0,K[8]=(q+W)*n,K[9]=(E-r)*n,K[10]=(1-(s+mI))*n,K[11]=0,K[12]=C._x,K[13]=C._y,K[14]=C._z,K[15]=1,j.markAsUpdated(),j}static Identity(){const I=r.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return I._updateIdentityStatus(!0),I}static IdentityToRef(I){return r.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,I),I._updateIdentityStatus(!0),I}static Zero(){const I=r.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return I._updateIdentityStatus(!1),I}static RotationX(I){const O=new r;return r.RotationXToRef(I,O),O}static Invert(I){const O=new r;return I.invertToRef(O),O}static RotationXToRef(I,O){const C=Math.sin(I),j=Math.cos(I);return r.FromValuesToRef(1,0,0,0,0,j,C,0,0,-C,j,0,0,0,0,1,O),O._updateIdentityStatus(1===j&&0===C),O}static RotationY(I){const O=new r;return r.RotationYToRef(I,O),O}static RotationYToRef(I,O){const C=Math.sin(I),j=Math.cos(I);return r.FromValuesToRef(j,0,-C,0,0,1,0,0,C,0,j,0,0,0,0,1,O),O._updateIdentityStatus(1===j&&0===C),O}static RotationZ(I){const O=new r;return r.RotationZToRef(I,O),O}static RotationZToRef(I,O){const C=Math.sin(I),j=Math.cos(I);return r.FromValuesToRef(j,C,0,0,-C,j,0,0,0,0,1,0,0,0,0,1,O),O._updateIdentityStatus(1===j&&0===C),O}static RotationAxis(I,O){const C=new r;return r.RotationAxisToRef(I,O,C),C}static RotationAxisToRef(I,O,C){const j=Math.sin(-O),K=Math.cos(-O),i=1-K;I=I.normalizeToRef(W.mC[0]);const y=C.US;return y[0]=I._x*I._x*i+K,y[1]=I._x*I._y*i-I._z*j,y[2]=I._x*I._z*i+I._y*j,y[3]=0,y[4]=I._y*I._x*i+I._z*j,y[5]=I._y*I._y*i+K,y[6]=I._y*I._z*i-I._x*j,y[7]=0,y[8]=I._z*I._x*i-I._y*j,y[9]=I._z*I._y*i+I._x*j,y[10]=I._z*I._z*i+K,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,C.markAsUpdated(),C}static RotationAlignToRef(I,O,C){let K=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const i=mI.Dot(O,I),y=C.US;if(i<-1+j.d)y[0]=-1,y[1]=0,y[2]=0,y[3]=0,y[4]=0,y[5]=K?1:-1,y[6]=0,y[7]=0,y[8]=0,y[9]=0,y[10]=K?-1:1,y[11]=0;else{const C=mI.Cross(O,I),j=1/(1+i);y[0]=C._x*C._x*j+i,y[1]=C._y*C._x*j-C._z,y[2]=C._z*C._x*j+C._y,y[3]=0,y[4]=C._x*C._y*j+C._z,y[5]=C._y*C._y*j+i,y[6]=C._z*C._y*j-C._x,y[7]=0,y[8]=C._x*C._z*j-C._y,y[9]=C._y*C._z*j+C._x,y[10]=C._z*C._z*j+i,y[11]=0}return y[12]=0,y[13]=0,y[14]=0,y[15]=1,C.markAsUpdated(),C}static RotationYawPitchRoll(I,O,C){const j=new r;return r.RotationYawPitchRollToRef(I,O,C,j),j}static RotationYawPitchRollToRef(I,O,C,j){return h.RotationYawPitchRollToRef(I,O,C,W.Quaternion[0]),W.Quaternion[0].toRotationMatrix(j),j}static Scaling(I,O,C){const j=new r;return r.ScalingToRef(I,O,C,j),j}static ScalingToRef(I,O,C,j){return r.FromValuesToRef(I,0,0,0,0,O,0,0,0,0,C,0,0,0,0,1,j),j._updateIdentityStatus(1===I&&1===O&&1===C),j}static Translation(I,O,C){const j=new r;return r.TranslationToRef(I,O,C,j),j}static TranslationToRef(I,O,C,j){return r.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,I,O,C,1,j),j._updateIdentityStatus(0===I&&0===O&&0===C),j}static Lerp(I,O,C){const j=new r;return r.LerpToRef(I,O,C,j),j}static LerpToRef(I,O,C,j){const K=j.US,i=I.m,y=O.m;for(let S=0;S<16;S++)K[S]=i[S]*(1-C)+y[S]*C;return j.markAsUpdated(),j}static DecomposeLerp(I,O,C){const j=new r;return r.DecomposeLerpToRef(I,O,C,j),j}static DecomposeLerpToRef(I,O,C,j){const K=W.mC[0],i=W.Quaternion[0],y=W.mC[1];I.decompose(K,i,y);const S=W.mC[2],U=W.Quaternion[1],p=W.mC[3];O.decompose(S,U,p);const N=W.mC[4];mI.LerpToRef(K,S,C,N);const Q=W.Quaternion[2];h.SlerpToRef(i,U,C,Q);const s=W.mC[5];return mI.LerpToRef(y,p,C,s),r.ComposeToRef(N,Q,s,j),j}static LookAtLH(I,O,C){const j=new r;return r.LookAtLHToRef(I,O,C,j),j}static LookAtLHToRef(I,O,C,j){const K=W.mC[0],i=W.mC[1],y=W.mC[2];O.subtractToRef(I,y),y.normalize(),mI.CrossToRef(C,y,K);const S=K.lengthSquared();0===S?K.x=1:K.normalizeFromLength(Math.sqrt(S)),mI.CrossToRef(y,K,i),i.normalize();const U=-mI.Dot(K,I),p=-mI.Dot(i,I),N=-mI.Dot(y,I);return r.FromValuesToRef(K._x,i._x,y._x,0,K._y,i._y,y._y,0,K._z,i._z,y._z,0,U,p,N,1,j),j}static LookAtRH(I,O,C){const j=new r;return r.LookAtRHToRef(I,O,C,j),j}static LookAtRHToRef(I,O,C,j){const K=W.mC[0],i=W.mC[1],y=W.mC[2];I.subtractToRef(O,y),y.normalize(),mI.CrossToRef(C,y,K);const S=K.lengthSquared();0===S?K.x=1:K.normalizeFromLength(Math.sqrt(S)),mI.CrossToRef(y,K,i),i.normalize();const U=-mI.Dot(K,I),p=-mI.Dot(i,I),N=-mI.Dot(y,I);return r.FromValuesToRef(K._x,i._x,y._x,0,K._y,i._y,y._y,0,K._z,i._z,y._z,0,U,p,N,1,j),j}static LookDirectionLH(I,O){const C=new r;return r.LookDirectionLHToRef(I,O,C),C}static LookDirectionLHToRef(I,O,C){const j=W.mC[0];j.K(I),j.scaleInPlace(-1);const K=W.mC[1];return mI.CrossToRef(O,j,K),r.FromValuesToRef(K._x,K._y,K._z,0,O._x,O._y,O._z,0,j._x,j._y,j._z,0,0,0,0,1,C),C}static LookDirectionRH(I,O){const C=new r;return r.LookDirectionRHToRef(I,O,C),C}static LookDirectionRHToRef(I,O,C){const j=W.mC[2];return mI.CrossToRef(O,I,j),r.FromValuesToRef(j._x,j._y,j._z,0,O._x,O._y,O._z,0,I._x,I._y,I._z,0,0,0,0,1,C),C}static OrthoLH(I,O,C,j,K){const i=new r;return r.OrthoLHToRef(I,O,C,j,i,K),i}static OrthoLHToRef(I,O,C,j,K,i){const y=2/I,S=2/O,U=2/(j-C),p=-(j+C)/(j-C);return r.FromValuesToRef(y,0,0,0,0,S,0,0,0,0,U,0,0,0,p,1,K),i&&K.multiplyToRef(o,K),K._updateIdentityStatus(1===y&&1===S&&1===U&&0===p),K}static OrthoOffCenterLH(I,O,C,j,K,i,y){const S=new r;return r.OrthoOffCenterLHToRef(I,O,C,j,K,i,S,y),S}static OrthoOffCenterLHToRef(I,O,C,j,K,i,y,S){const U=2/(O-I),p=2/(j-C),N=2/(i-K),Q=-(i+K)/(i-K),s=(I+O)/(I-O),Z=(j+C)/(C-j);return r.FromValuesToRef(U,0,0,0,0,p,0,0,0,0,N,0,s,Z,Q,1,y),S&&y.multiplyToRef(o,y),y.markAsUpdated(),y}static ObliqueOffCenterLHToRef(I,O,C,j,K,i,y,S,U,p,N){const Q=-y*Math.cos(S),s=-y*Math.sin(S);return r.TranslationToRef(0,0,-U,W.Matrix[1]),r.FromValuesToRef(1,0,0,0,0,1,0,0,Q,s,1,0,0,0,0,1,W.Matrix[0]),W.Matrix[1].multiplyToRef(W.Matrix[0],W.Matrix[0]),r.TranslationToRef(0,0,U,W.Matrix[1]),W.Matrix[0].multiplyToRef(W.Matrix[1],W.Matrix[0]),r.OrthoOffCenterLHToRef(I,O,C,j,K,i,p,N),W.Matrix[0].multiplyToRef(p,p),p}static OrthoOffCenterRH(I,O,C,j,K,i,y){const S=new r;return r.OrthoOffCenterRHToRef(I,O,C,j,K,i,S,y),S}static OrthoOffCenterRHToRef(I,O,C,j,K,i,y,S){return r.OrthoOffCenterLHToRef(I,O,C,j,K,i,y,S),y.US[10]*=-1,y}static ObliqueOffCenterRHToRef(I,O,C,j,K,i,y,S,U,p,N){const Q=y*Math.cos(S),s=y*Math.sin(S);return r.TranslationToRef(0,0,U,W.Matrix[1]),r.FromValuesToRef(1,0,0,0,0,1,0,0,Q,s,1,0,0,0,0,1,W.Matrix[0]),W.Matrix[1].multiplyToRef(W.Matrix[0],W.Matrix[0]),r.TranslationToRef(0,0,-U,W.Matrix[1]),W.Matrix[0].multiplyToRef(W.Matrix[1],W.Matrix[0]),r.OrthoOffCenterRHToRef(I,O,C,j,K,i,p,N),W.Matrix[0].multiplyToRef(p,p),p}static PerspectiveLH(I,O,C,j,K){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const y=new r,S=2*C/I,U=2*C/O,p=(j+C)/(j-C),N=-2*j*C/(j-C),Q=Math.tan(i);return r.FromValuesToRef(S,0,0,0,0,U,0,Q,0,0,p,1,0,0,N,0,y),K&&y.multiplyToRef(o,y),y._updateIdentityStatus(!1),y}static PerspectiveFovLH(I,O,C,j,K){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const S=new r;return r.PerspectiveFovLHToRef(I,O,C,j,S,!0,K,i,y),S}static PerspectiveFovLHToRef(I,O,C,j,K){let i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,S=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,U=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const p=C,N=j,Q=1/Math.tan(.5*I),s=i?Q/O:Q,Z=i?Q:Q*O,q=U&&0===p?-1:0!==N?(N+p)/(N-p):1,mI=U&&0===p?2*N:0!==N?-2*N*p/(N-p):-2*p,E=Math.tan(S);return r.FromValuesToRef(s,0,0,0,0,Z,0,E,0,0,q,1,0,0,mI,0,K),y&&K.multiplyToRef(o,K),K._updateIdentityStatus(!1),K}static PerspectiveFovReverseLHToRef(I,O,C,j,K){let i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,S=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const U=1/Math.tan(.5*I),p=i?U/O:U,N=i?U:U*O,Q=Math.tan(S);return r.FromValuesToRef(p,0,0,0,0,N,0,Q,0,0,-C,1,0,0,1,0,K),y&&K.multiplyToRef(o,K),K._updateIdentityStatus(!1),K}static PerspectiveFovRH(I,O,C,j,K){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const S=new r;return r.PerspectiveFovRHToRef(I,O,C,j,S,!0,K,i,y),S}static PerspectiveFovRHToRef(I,O,C,j,K){let i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,S=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,U=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const p=C,N=j,Q=1/Math.tan(.5*I),s=i?Q/O:Q,Z=i?Q:Q*O,q=U&&0===p?1:0!==N?-(N+p)/(N-p):-1,mI=U&&0===p?2*N:0!==N?-2*N*p/(N-p):-2*p,E=Math.tan(S);return r.FromValuesToRef(s,0,0,0,0,Z,0,E,0,0,q,-1,0,0,mI,0,K),y&&K.multiplyToRef(o,K),K._updateIdentityStatus(!1),K}static PerspectiveFovReverseRHToRef(I,O,C,j,K){let i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,S=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const U=1/Math.tan(.5*I),p=i?U/O:U,N=i?U:U*O,Q=Math.tan(S);return r.FromValuesToRef(p,0,0,0,0,N,0,Q,0,0,-C,-1,0,0,-1,0,K),y&&K.multiplyToRef(o,K),K._updateIdentityStatus(!1),K}static GetFinalMatrix(I,O,C,j,K,i){const y=I.width,S=I.height,U=I.x,p=I.y,N=r.FromValues(y/2,0,0,0,0,-S/2,0,0,0,0,i-K,0,U+y/2,S/2+p,K,1),Q=new r;return O.multiplyToRef(C,Q),Q.multiplyToRef(j,Q),Q.multiplyToRef(N,Q)}static GetAsMatrix2x2(I){const O=I.m,C=[O[0],O[1],O[4],O[5]];return y.b.MatrixUse64Bits?C:new Float32Array(C)}static GetAsMatrix3x3(I){const O=I.m,C=[O[0],O[1],O[2],O[4],O[5],O[6],O[8],O[9],O[10]];return y.b.MatrixUse64Bits?C:new Float32Array(C)}static Transpose(I){const O=new r;return r.TransposeToRef(I,O),O}static TransposeToRef(I,O){const C=I.m,j=C[0],K=C[4],i=C[8],y=C[12],S=C[1],U=C[5],p=C[9],N=C[13],Q=C[2],s=C[6],Z=C[10],q=C[14],mI=C[3],E=C[7],h=C[11],r=C[15],W=O.US;return W[0]=j,W[1]=K,W[2]=i,W[3]=y,W[4]=S,W[5]=U,W[6]=p,W[7]=N,W[8]=Q,W[9]=s,W[10]=Z,W[11]=q,W[12]=mI,W[13]=E,W[14]=h,W[15]=r,O.markAsUpdated(),O._updateIdentityStatus(I._isIdentity,I._isIdentityDirty),O}static Reflection(I){const O=new r;return r.ReflectionToRef(I,O),O}static ReflectionToRef(I,O){I.normalize();const C=I.normal.x,j=I.normal.y,K=I.normal.z,i=-2*C,y=-2*j,S=-2*K;return r.FromValuesToRef(i*C+1,y*C,S*C,0,i*j,y*j+1,S*j,0,i*K,y*K,S*K+1,0,i*I.d,y*I.d,S*I.d,1,O),O}static FromXYZAxesToRef(I,O,C,j){return r.FromValuesToRef(I._x,I._y,I._z,0,O._x,O._y,O._z,0,C._x,C._y,C._z,0,0,0,0,1,j),j}static FromQuaternionToRef(I,O){const C=I._x*I._x,j=I._y*I._y,K=I._z*I._z,i=I._x*I._y,y=I._z*I._w,S=I._z*I._x,U=I._y*I._w,p=I._y*I._z,N=I._x*I._w;return O.US[0]=1-2*(j+K),O.US[1]=2*(i+y),O.US[2]=2*(S-U),O.US[3]=0,O.US[4]=2*(i-y),O.US[5]=1-2*(K+C),O.US[6]=2*(p+N),O.US[7]=0,O.US[8]=2*(S+U),O.US[9]=2*(p-N),O.US[10]=1-2*(j+C),O.US[11]=0,O.US[12]=0,O.US[13]=0,O.US[14]=0,O.US[15]=1,O.markAsUpdated(),O}}r._IdentityReadOnly=r.Identity(),Object.defineProperties(r.prototype,{dimension:{value:[4,4]},rank:{value:2}});class W{}W.mC=(0,K.h)(11,mI.Zero),W.Matrix=(0,K.h)(2,r.Identity),W.Quaternion=(0,K.h)(3,h.Zero);class Y{}Y.Vector2=(0,K.h)(3,q.Zero),Y.mC=(0,K.h)(13,mI.Zero),Y.Vector4=(0,K.h)(3,E.Zero),Y.Quaternion=(0,K.h)(3,h.Zero),Y.Matrix=(0,K.h)(8,r.Identity),(0,i.e)("BABYLON.Vector2",q),(0,i.e)("BABYLON.Vector3",mI),(0,i.e)("BABYLON.Vector4",E),(0,i.e)("BABYLON.Matrix",r);const o=r.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12276:(I,O,C)=>{function j(I,O){const C=[];for(let j=0;j<I;++j)C.push(O());return C}function K(I,O){return j(I,O)}C.d(O,{e:()=>j,h:()=>K,j:()=>y});const i=["push","splice","pop","shift","unshift"];function y(I,O){const C=i.map((C=>function(I,O,C){const j=I[O];if("function"!==typeof j)return null;const K=function(){const j=I.length,i=K.previous.apply(I,arguments);return C(O,j),i};return j.next=K,K.previous=j,I[O]=K,()=>{const C=K.previous;if(!C)return;const j=K.next;j?(C.next=j,j.previous=C):(C.next=void 0,I[O]=C),K.next=void 0,K.previous=void 0}}(I,C,O)));return()=>{for(const I of C)null===I||void 0===I||I()}}}}]);