"use strict";(self.ynu1yiqvs98=self.ynu1yiqvs98||[]).push([[14],{11120:(I,E,j)=>{j.d(E,{b:()=>h,f:()=>z,h:()=>e,l:()=>w});const e=1/2.2,w=2.2,z=(1+Math.sqrt(5))/2,h=.001},11136:(I,E,j)=>{function e(I){return parseInt(I.toString().replace(/\W/g,""))}function w(I,E){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(I-E)<=j}function z(I,E,j){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return I<E-e||I>j+e}function h(I,E){return I===E?I:Math.random()*(E-I)+I}function t(I,E,j){return I+(E-I)*j}function U(I,E,j){let e=F(E-I,360);return e>180&&(e-=360),I+e*Z(j)}function R(I,E,j){let e=0;return e=I!=E?Z((j-I)/(E-I)):0,e}function P(I,E,j,e,w){const z=w*w,h=w*z;return I*(2*h-3*z+1)+j*(-2*h+3*z)+E*(h-2*z+w)+e*(h-z)}function o(I,E,j,e,w){const z=w*w;return 6*(z-w)*I+(3*z-4*w+1)*E+6*(-z+w)*j+(3*z-2*w)*e}function Z(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(j,Math.max(E,I))}function c(I){return I-=2*Math.PI*Math.floor((I+Math.PI)/(2*Math.PI))}function K(I){const E=I.toString(16);return I<=15?("0"+E).toUpperCase():E.toUpperCase()}function L(I){if(Math.log2)return Math.floor(Math.log2(I));if(I<0)return NaN;if(0===I)return-1/0;let E=0;if(I<1){for(;I<1;)E++,I*=2;E=-E}else if(I>1)for(;I>1;)E++,I=Math.floor(I/2);return E}function F(I,E){return I-Math.floor(I/E)*E}function C(I,E,j){return(I-E)/(j-E)}function X(I,E,j){return I*(j-E)+E}function q(I,E){let j=F(E-I,360);return j>180&&(j-=360),j}function x(I,E){const j=F(I,2*E);return E-Math.abs(j-E)}function u(I,E,j){let e=Z(j);return e=-2*e*e*e+3*e*e,E*e+I*(1-e)}function b(I,E,j){let e=0;return e=Math.abs(E-I)<=j?E:I+Math.sign(E-I)*j,e}function Q(I,E,j){const e=q(I,E);let w=0;return w=-j<e&&e<j?E:b(I,E=I+e,j),w}function G(I,E,j){return(I-E)/(j-E)}function y(I,E,j){return(j-E)*I+E}function d(I,E){const j=I%E;return 0===j?E:d(E,j)}j.r(E),j.d(E,{Clamp:()=>Z,DeltaAngle:()=>q,Denormalize:()=>X,ExtractAsInt:()=>e,Hermite:()=>P,Hermite1stDerivative:()=>o,HighestCommonFactor:()=>d,ILog2:()=>L,InverseLerp:()=>R,Lerp:()=>t,LerpAngle:()=>U,MoveTowards:()=>b,MoveTowardsAngle:()=>Q,Normalize:()=>C,NormalizeRadians:()=>c,OutsideRange:()=>z,PercentToRange:()=>y,PingPong:()=>x,RandomRange:()=>h,RangeToPercent:()=>G,Repeat:()=>F,SmoothStep:()=>u,ToHex:()=>K,WithinEpsilon:()=>w})},11117:(I,E,j)=>{j.r(E),j.d(E,{Matrix:()=>X,Quaternion:()=>C,TmpVectors:()=>x,Vector2:()=>K,LE:()=>L,Vector4:()=>F});var e=j(11120),w=j(11127),z=j(11073),h=j(11054),t=j(10993),U=j(11136);class R{}function P(I,E,j){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const w=I.re(),z=E.re(),h=w[0],t=w[1],U=w[2],R=w[3],P=w[4],o=w[5],Z=w[6],c=w[7],K=w[8],L=w[9],F=w[10],C=w[11],X=w[12],q=w[13],x=w[14],u=w[15],b=z[0],Q=z[1],G=z[2],y=z[3],d=z[4],a=z[5],l=z[6],i=z[7],r=z[8],n=z[9],H=z[10],g=z[11],Y=z[12],A=z[13],T=z[14],M=z[15];j[e]=h*b+t*d+U*r+R*Y,j[e+1]=h*Q+t*a+U*n+R*A,j[e+2]=h*G+t*l+U*H+R*T,j[e+3]=h*y+t*i+U*g+R*M,j[e+4]=P*b+o*d+Z*r+c*Y,j[e+5]=P*Q+o*a+Z*n+c*A,j[e+6]=P*G+o*l+Z*H+c*T,j[e+7]=P*y+o*i+Z*g+c*M,j[e+8]=K*b+L*d+F*r+C*Y,j[e+9]=K*Q+L*a+F*n+C*A,j[e+10]=K*G+L*l+F*H+C*T,j[e+11]=K*y+L*i+F*g+C*M,j[e+12]=X*b+q*d+x*r+u*Y,j[e+13]=X*Q+q*a+x*n+u*A,j[e+14]=X*G+q*l+x*H+u*T,j[e+15]=X*y+q*i+x*g+u*M}function o(I,E){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const e=I.re();E[j]=e[0],E[j+1]=e[1],E[j+2]=e[2],E[j+3]=e[3],E[j+4]=e[4],E[j+5]=e[5],E[j+6]=e[6],E[j+7]=e[7],E[j+8]=e[8],E[j+9]=e[9],E[j+10]=e[10],E[j+11]=e[11],E[j+12]=e[12],E[j+13]=e[13],E[j+14]=e[14],E[j+15]=e[15]}function Z(I,E){const j=I.re(),e=j[0],w=j[1],z=j[2],h=j[3],t=j[4],U=j[5],R=j[6],P=j[7],o=j[8],Z=j[9],c=j[10],K=j[11],L=j[12],F=j[13],C=j[14],X=j[15],q=c*X-C*K,x=Z*X-F*K,u=Z*C-F*c,b=o*X-L*K,Q=o*C-c*L,G=o*F-L*Z,y=+(U*q-R*x+P*u),d=-(t*q-R*b+P*Q),a=+(t*x-U*b+P*G),l=-(t*u-U*Q+R*G),i=e*y+w*d+z*a+h*l;if(0===i)return!1;const r=1/i,n=R*X-C*P,H=U*X-F*P,g=U*C-F*R,Y=t*X-L*P,A=t*C-L*R,T=t*F-L*U,M=R*K-c*P,W=U*K-Z*P,O=U*c-Z*R,s=t*K-o*P,v=t*c-o*R,V=t*Z-o*U,f=-(w*q-z*x+h*u),S=+(e*q-z*b+h*Q),B=-(e*x-w*b+h*G),p=+(e*u-w*Q+z*G),D=+(w*n-z*H+h*g),k=-(e*n-z*Y+h*A),J=+(e*H-w*Y+h*T),N=-(e*g-w*A+z*T),m=-(w*M-z*W+h*O),II=+(e*M-z*s+h*v),EI=-(e*W-w*s+h*V),jI=+(e*O-w*v+z*V);return E[0]=y*r,E[1]=f*r,E[2]=D*r,E[3]=m*r,E[4]=d*r,E[5]=S*r,E[6]=k*r,E[7]=II*r,E[8]=a*r,E[9]=B*r,E[10]=J*r,E[11]=EI*r,E[12]=l*r,E[13]=p*r,E[14]=N*r,E[15]=jI*r,!0}R._UpdateFlagSeed=0;const c=I=>parseInt(I.toString().replace(/\W/g,""));class K{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=I,this.y=E}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let I=c(this.x);return I=397*I^c(this.y),I}toArray(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[E]=this.x,I[E+1]=this.y,this}Kj(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K.FromArrayToRef(I,E,this),this}re(){return[this.x,this.y]}U(I){return this.x=I.x,this.y=I.y,this}nz(I,E){return this.x=I,this.y=E,this}set(I,E){return this.nz(I,E)}mz(I){return this.nz(I,I)}add(I){return new K(this.x+I.x,this.y+I.y)}addToRef(I,E){return E.x=this.x+I.x,E.y=this.y+I.y,E}addInPlace(I){return this.x+=I.x,this.y+=I.y,this}addInPlaceFromFloats(I,E){return this.x+=I,this.y+=E,this}addVector3(I){return new K(this.x+I.x,this.y+I.y)}FE(I){return new K(this.x-I.x,this.y-I.y)}subtractToRef(I,E){return E.x=this.x-I.x,E.y=this.y-I.y,E}Uo(I){return this.x-=I.x,this.y-=I.y,this}multiplyInPlace(I){return this.x*=I.x,this.y*=I.y,this}multiply(I){return new K(this.x*I.x,this.y*I.y)}multiplyToRef(I,E){return E.x=this.x*I.x,E.y=this.y*I.y,E}multiplyByFloats(I,E){return new K(this.x*I,this.y*E)}divide(I){return new K(this.x/I.x,this.y/I.y)}divideToRef(I,E){return E.x=this.x/I.x,E.y=this.y/I.y,E}divideInPlace(I){return this.x=this.x/I.x,this.y=this.y/I.y,this}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I.x,I.y)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I.x,I.y)}minimizeInPlaceFromFloats(I,E){return this.x=Math.min(I,this.x),this.y=Math.min(E,this.y),this}maximizeInPlaceFromFloats(I,E){return this.x=Math.max(I,this.x),this.y=Math.max(E,this.y),this}subtractFromFloats(I,E){return new K(this.x-I,this.y-E)}subtractFromFloatsToRef(I,E,j){return j.x=this.x-I,j.y=this.y-E,j}negate(){return new K(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(I){return I.x=-this.x,I.y=-this.y,I}scaleInPlace(I){return this.x*=I,this.y*=I,this}scale(I){return new K(this.x*I,this.y*I)}scaleToRef(I,E){return E.x=this.x*I,E.y=this.y*I,E}scaleAndAddToRef(I,E){return E.x+=this.x*I,E.y+=this.y*I,E}equals(I){return I&&this.x===I.x&&this.y===I.y}equalsWithEpsilon(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.b;return I&&(0,U.WithinEpsilon)(this.x,I.x,E)&&(0,U.WithinEpsilon)(this.y,I.y,E)}equalsToFloats(I,E){return this.x===I&&this.y===E}floor(){return new K(Math.floor(this.x),Math.floor(this.y))}floorToRef(I){return I.x=Math.floor(this.x),I.y=Math.floor(this.y),I}fract(){return new K(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(I){return I.x=this.x-Math.floor(this.x),I.y=this.y-Math.floor(this.y),I}rotate(I){return this.rotateToRef(I,new K)}rotateToRef(I,E){const j=Math.cos(I),e=Math.sin(I);return E.x=j*this.x-e*this.y,E.y=e*this.x+j*this.y,E}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){const I=new K;return this.normalizeToRef(I),I}normalizeToRef(I){const E=this.length();return 0===E&&(I.x=this.x,I.y=this.y),this.scaleToRef(1/E,I)}clone(){return new K(this.x,this.y)}dot(I){return this.x*I.x+this.y*I.y}static Zero(){return new K(0,0)}static One(){return new K(1,1)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new K((0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).nz((0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E))}static get ZeroReadOnly(){return K._ZeroReadOnly}static xE(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new K(I[E],I[E+1])}static FromArrayToRef(I,E,j){return j.x=I[E],j.y=I[E+1],j}static FromFloatsToRef(I,E,j){return j.nz(I,E),j}static CatmullRom(I,E,j,e,w){const z=w*w,h=w*z,t=.5*(2*E.x+(-I.x+j.x)*w+(2*I.x-5*E.x+4*j.x-e.x)*z+(-I.x+3*E.x-3*j.x+e.x)*h),U=.5*(2*E.y+(-I.y+j.y)*w+(2*I.y-5*E.y+4*j.y-e.y)*z+(-I.y+3*E.y-3*j.y+e.y)*h);return new K(t,U)}static ClampToRef(I,E,j,e){return e.x=(0,U.Clamp)(I.x,E.x,j.x),e.y=(0,U.Clamp)(I.y,E.y,j.y),e}static Clamp(I,E,j){const e=(0,U.Clamp)(I.x,E.x,j.x),w=(0,U.Clamp)(I.y,E.y,j.y);return new K(e,w)}static Hermite(I,E,j,e,w){const z=w*w,h=w*z,t=2*h-3*z+1,U=-2*h+3*z,R=h-2*z+w,P=h-z,o=I.x*t+j.x*U+E.x*R+e.x*P,Z=I.y*t+j.y*U+E.y*R+e.y*P;return new K(o,Z)}static Hermite1stDerivative(I,E,j,e,w){return this.Hermite1stDerivativeToRef(I,E,j,e,w,new K)}static Hermite1stDerivativeToRef(I,E,j,e,w,z){const h=w*w;return z.x=6*(h-w)*I.x+(3*h-4*w+1)*E.x+6*(-h+w)*j.x+(3*h-2*w)*e.x,z.y=6*(h-w)*I.y+(3*h-4*w+1)*E.y+6*(-h+w)*j.y+(3*h-2*w)*e.y,z}static Lerp(I,E,j){return K.LerpToRef(I,E,j,new K)}static LerpToRef(I,E,j,e){return e.x=I.x+(E.x-I.x)*j,e.y=I.y+(E.y-I.y)*j,e}static Dot(I,E){return I.x*E.x+I.y*E.y}static Normalize(I){return K.NormalizeToRef(I,new K)}static NormalizeToRef(I,E){return I.normalizeToRef(E),E}static Minimize(I,E){const j=I.x<E.x?I.x:E.x,e=I.y<E.y?I.y:E.y;return new K(j,e)}static Maximize(I,E){const j=I.x>E.x?I.x:E.x,e=I.y>E.y?I.y:E.y;return new K(j,e)}static Transform(I,E){return K.TransformToRef(I,E,new K)}static TransformToRef(I,E,j){const e=E.m,w=I.x*e[0]+I.y*e[4]+e[12],z=I.x*e[1]+I.y*e[5]+e[13];return j.x=w,j.y=z,j}static PointInTriangle(I,E,j,e){const w=.5*(-j.y*e.x+E.y*(-j.x+e.x)+E.x*(j.y-e.y)+j.x*e.y),z=w<0?-1:1,h=(E.y*e.x-E.x*e.y+(e.y-E.y)*I.x+(E.x-e.x)*I.y)*z,t=(E.x*j.y-E.y*j.x+(E.y-j.y)*I.x+(j.x-E.x)*I.y)*z;return h>0&&t>0&&h+t<2*w*z}static Distance(I,E){return Math.sqrt(K.DistanceSquared(I,E))}static DistanceSquared(I,E){const j=I.x-E.x,e=I.y-E.y;return j*j+e*e}static Center(I,E){return K.CenterToRef(I,E,new K)}static CenterToRef(I,E,j){return j.nz((I.x+E.x)/2,(I.y+E.y)/2)}static DistanceOfPointFromSegment(I,E,j){const e=K.DistanceSquared(E,j);if(0===e)return K.Distance(I,E);const w=j.FE(E),z=Math.max(0,Math.min(1,K.Dot(I.FE(E),w)/e)),h=E.add(w.multiplyByFloats(z,z));return K.Distance(I,h)}}K._V8PerformanceHack=new K(.5,.5),K._ZeroReadOnly=K.Zero(),Object.defineProperties(K.prototype,{dimension:{value:[2]},rank:{value:1}});class L{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=I,this._y=E,this._z=j}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"LE"}getHashCode(){let I=c(this._x);return I=397*I^c(this._y),I=397*I^c(this._z),I}re(){return[this._x,this._y,this._z]}toArray(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[E]=this._x,I[E+1]=this._y,I[E+2]=this._z,this}Kj(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(I,E,this),this}toQuaternion(){return C.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(I){return this._x+=I._x,this._y+=I._y,this._z+=I._z,this._isDirty=!0,this}addInPlaceFromFloats(I,E,j){return this._x+=I,this._y+=E,this._z+=j,this._isDirty=!0,this}add(I){return new L(this._x+I._x,this._y+I._y,this._z+I._z)}addToRef(I,E){return E._x=this._x+I._x,E._y=this._y+I._y,E._z=this._z+I._z,E._isDirty=!0,E}Uo(I){return this._x-=I._x,this._y-=I._y,this._z-=I._z,this._isDirty=!0,this}FE(I){return new L(this._x-I._x,this._y-I._y,this._z-I._z)}subtractToRef(I,E){return this.subtractFromFloatsToRef(I._x,I._y,I._z,E)}subtractFromFloats(I,E,j){return new L(this._x-I,this._y-E,this._z-j)}subtractFromFloatsToRef(I,E,j,e){return e._x=this._x-I,e._y=this._y-E,e._z=this._z-j,e._isDirty=!0,e}negate(){return new L(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(I){return I._x=-1*this._x,I._y=-1*this._y,I._z=-1*this._z,I._isDirty=!0,I}scaleInPlace(I){return this._x*=I,this._y*=I,this._z*=I,this._isDirty=!0,this}scale(I){return new L(this._x*I,this._y*I,this._z*I)}scaleToRef(I,E){return E._x=this._x*I,E._y=this._y*I,E._z=this._z*I,E._isDirty=!0,E}getNormalToRef(I){const E=this.length();let j=Math.acos(this._y/E);const e=Math.atan2(this._z,this._x);j>Math.PI/2?j-=Math.PI/2:j+=Math.PI/2;const w=E*Math.sin(j)*Math.cos(e),z=E*Math.cos(j),h=E*Math.sin(j)*Math.sin(e);return I.set(w,z,h),I}applyRotationQuaternionToRef(I,E){const j=this._x,e=this._y,w=this._z,z=I._x,h=I._y,t=I._z,U=I._w,R=2*(h*w-t*e),P=2*(t*j-z*w),o=2*(z*e-h*j);return E._x=j+U*R+h*o-t*P,E._y=e+U*P+t*R-z*o,E._z=w+U*o+z*P-h*R,E._isDirty=!0,E}applyRotationQuaternionInPlace(I){return this.applyRotationQuaternionToRef(I,this)}applyRotationQuaternion(I){return this.applyRotationQuaternionToRef(I,new L)}scaleAndAddToRef(I,E){return E._x+=this._x*I,E._y+=this._y*I,E._z+=this._z*I,E._isDirty=!0,E}projectOnPlane(I,E){return this.projectOnPlaneToRef(I,E,new L)}projectOnPlaneToRef(I,E,j){const e=I.normal,w=I.d,z=q.LE[0];this.subtractToRef(E,z),z.normalize();const h=L.Dot(z,e);if(Math.abs(h)<1e-10)j.mz(1/0);else{const I=-(L.Dot(E,e)+w)/h,t=z.scaleInPlace(I);E.addToRef(t,j)}return j}equals(I){return I&&this._x===I._x&&this._y===I._y&&this._z===I._z}equalsWithEpsilon(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.b;return I&&(0,U.WithinEpsilon)(this._x,I._x,E)&&(0,U.WithinEpsilon)(this._y,I._y,E)&&(0,U.WithinEpsilon)(this._z,I._z,E)}equalsToFloats(I,E,j){return this._x===I&&this._y===E&&this._z===j}multiplyInPlace(I){return this._x*=I._x,this._y*=I._y,this._z*=I._z,this._isDirty=!0,this}multiply(I){return this.multiplyByFloats(I._x,I._y,I._z)}multiplyToRef(I,E){return E._x=this._x*I._x,E._y=this._y*I._y,E._z=this._z*I._z,E._isDirty=!0,E}multiplyByFloats(I,E,j){return new L(this._x*I,this._y*E,this._z*j)}divide(I){return new L(this._x/I._x,this._y/I._y,this._z/I._z)}divideToRef(I,E){return E._x=this._x/I._x,E._y=this._y/I._y,E._z=this._z/I._z,E._isDirty=!0,E}divideInPlace(I){return this._x=this._x/I._x,this._y=this._y/I._y,this._z=this._z/I._z,this._isDirty=!0,this}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I._x,I._y,I._z)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I._x,I._y,I._z)}minimizeInPlaceFromFloats(I,E,j){return I<this._x&&(this.x=I),E<this._y&&(this.y=E),j<this._z&&(this.z=j),this}maximizeInPlaceFromFloats(I,E,j){return I>this._x&&(this.x=I),E>this._y&&(this.y=E),j>this._z&&(this.z=j),this}isNonUniformWithinEpsilon(I){const E=Math.abs(this._x),j=Math.abs(this._y);if(!(0,U.WithinEpsilon)(E,j,I))return!0;const e=Math.abs(this._z);return!(0,U.WithinEpsilon)(E,e,I)||!(0,U.WithinEpsilon)(j,e,I)}get isNonUniform(){const I=Math.abs(this._x);if(I!==Math.abs(this._y))return!0;return I!==Math.abs(this._z)}floorToRef(I){return I._x=Math.floor(this._x),I._y=Math.floor(this._y),I._z=Math.floor(this._z),I._isDirty=!0,I}floor(){return new L(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(I){return I._x=this._x-Math.floor(this._x),I._y=this._y-Math.floor(this._y),I._z=this._z-Math.floor(this._z),I._isDirty=!0,I}fract(){return new L(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(I){if("xyz"===(I=I.toLowerCase()))return this;const E=q.LE[0].U(this);return this.x=E[I[0]],this.y=E[I[1]],this.z=E[I[2]],this}rotateByQuaternionToRef(I,E){return I.toRotationMatrix(q.Matrix[0]),L.TransformCoordinatesToRef(this,q.Matrix[0],E),E}rotateByQuaternionAroundPointToRef(I,E,j){return this.subtractToRef(E,q.LE[0]),q.LE[0].rotateByQuaternionToRef(I,q.LE[0]),E.addToRef(q.LE[0],j),j}cross(I){return L.CrossToRef(this,I,new L)}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){return this.normalizeToRef(new L)}normalizeToRef(I){const E=this.length();return 0===E||1===E?(I._x=this._x,I._y=this._y,I._z=this._z,I._isDirty=!0,I):this.scaleToRef(1/E,I)}clone(){return new L(this._x,this._y,this._z)}U(I){return this.nz(I._x,I._y,I._z)}nz(I,E,j){return this._x=I,this._y=E,this._z=j,this._isDirty=!0,this}set(I,E,j){return this.nz(I,E,j)}mz(I){return this._x=this._y=this._z=I,this._isDirty=!0,this}static GetClipFactor(I,E,j,e){const w=L.Dot(I,j);return(w-e)/(w-L.Dot(E,j))}static GetAngleBetweenVectors(I,E,j){const e=I.normalizeToRef(q.LE[1]),w=E.normalizeToRef(q.LE[2]);let z=L.Dot(e,w);z=(0,U.Clamp)(z,-1,1);const h=Math.acos(z),t=q.LE[3];return L.CrossToRef(e,w,t),L.Dot(t,j)>0?isNaN(h)?0:h:isNaN(h)?-Math.PI:-Math.acos(z)}static GetAngleBetweenVectorsOnPlane(I,E,j){q.LE[0].U(I);const e=q.LE[0];q.LE[1].U(E);const w=q.LE[1];q.LE[2].U(j);const z=q.LE[2],h=q.LE[3],t=q.LE[4];e.normalize(),w.normalize(),z.normalize(),L.CrossToRef(z,e,h),L.CrossToRef(h,z,t);const R=Math.atan2(L.Dot(w,h),L.Dot(w,t));return(0,U.NormalizeRadians)(R)}static PitchYawRollToMoveBetweenPointsToRef(I,E,j){const e=x.LE[0];return E.subtractToRef(I,e),j._y=Math.atan2(e.x,e.z)||0,j._x=Math.atan2(Math.sqrt(e.x**2+e.z**2),e.y)||0,j._z=0,j._isDirty=!0,j}static PitchYawRollToMoveBetweenPoints(I,E){const j=L.Zero();return L.PitchYawRollToMoveBetweenPointsToRef(I,E,j)}static SlerpToRef(I,E,j,w){j=(0,U.Clamp)(j,0,1);const z=q.LE[0],h=q.LE[1];z.U(I);const t=z.length();z.normalizeFromLength(t),h.U(E);const R=h.length();h.normalizeFromLength(R);const P=L.Dot(z,h);let o,Z;if(P<1-e.b){const I=Math.acos(P),E=1/Math.sin(I);o=Math.sin((1-j)*I)*E,Z=Math.sin(j*I)*E}else o=1-j,Z=j;return z.scaleInPlace(o),h.scaleInPlace(Z),w.U(z).addInPlace(h),w.scaleInPlace((0,U.Lerp)(t,R,j)),w}static SmoothToRef(I,E,j,e,w){return L.SlerpToRef(I,E,0===e?1:j/e,w),w}static xE(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new L(I[E],I[E+1],I[E+2])}static FromFloatArray(I,E){return L.xE(I,E)}static FromArrayToRef(I,E,j){return j._x=I[E],j._y=I[E+1],j._z=I[E+2],j._isDirty=!0,j}static FromFloatArrayToRef(I,E,j){return L.FromArrayToRef(I,E,j)}static FromFloatsToRef(I,E,j,e){return e.nz(I,E,j),e}static Zero(){return new L(0,0,0)}static One(){return new L(1,1,1)}static Up(){return new L(0,1,0)}static get UpReadOnly(){return L._UpReadOnly}static get DownReadOnly(){return L._DownReadOnly}static get RightReadOnly(){return L._RightReadOnly}static get LeftReadOnly(){return L._LeftReadOnly}static get LeftHandedForwardReadOnly(){return L._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return L._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return L._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return L._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return L._ZeroReadOnly}static get OneReadOnly(){return L._OneReadOnly}static Down(){return new L(0,-1,0)}static Forward(){return new L(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new L(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new L(1,0,0)}static Left(){return new L(-1,0,0)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new L((0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).nz((0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E))}static TransformCoordinates(I,E){const j=L.Zero();return L.TransformCoordinatesToRef(I,E,j),j}static TransformCoordinatesToRef(I,E,j){return L.TransformCoordinatesFromFloatsToRef(I._x,I._y,I._z,E,j),j}static TransformCoordinatesFromFloatsToRef(I,E,j,e,w){const z=e.m,h=I*z[0]+E*z[4]+j*z[8]+z[12],t=I*z[1]+E*z[5]+j*z[9]+z[13],U=I*z[2]+E*z[6]+j*z[10]+z[14],R=1/(I*z[3]+E*z[7]+j*z[11]+z[15]);return w._x=h*R,w._y=t*R,w._z=U*R,w._isDirty=!0,w}static TransformNormal(I,E){const j=L.Zero();return L.TransformNormalToRef(I,E,j),j}static TransformNormalToRef(I,E,j){return this.TransformNormalFromFloatsToRef(I._x,I._y,I._z,E,j),j}static TransformNormalFromFloatsToRef(I,E,j,e,w){const z=e.m;return w._x=I*z[0]+E*z[4]+j*z[8],w._y=I*z[1]+E*z[5]+j*z[9],w._z=I*z[2]+E*z[6]+j*z[10],w._isDirty=!0,w}static CatmullRom(I,E,j,e,w){const z=w*w,h=w*z,t=.5*(2*E._x+(-I._x+j._x)*w+(2*I._x-5*E._x+4*j._x-e._x)*z+(-I._x+3*E._x-3*j._x+e._x)*h),U=.5*(2*E._y+(-I._y+j._y)*w+(2*I._y-5*E._y+4*j._y-e._y)*z+(-I._y+3*E._y-3*j._y+e._y)*h),R=.5*(2*E._z+(-I._z+j._z)*w+(2*I._z-5*E._z+4*j._z-e._z)*z+(-I._z+3*E._z-3*j._z+e._z)*h);return new L(t,U,R)}static Clamp(I,E,j){const e=new L;return L.ClampToRef(I,E,j,e),e}static ClampToRef(I,E,j,e){let w=I._x;w=w>j._x?j._x:w,w=w<E._x?E._x:w;let z=I._y;z=z>j._y?j._y:z,z=z<E._y?E._y:z;let h=I._z;return h=h>j._z?j._z:h,h=h<E._z?E._z:h,e.nz(w,z,h),e}static CheckExtends(I,E,j){E.minimizeInPlace(I),j.maximizeInPlace(I)}static Hermite(I,E,j,e,w){const z=w*w,h=w*z,t=2*h-3*z+1,U=-2*h+3*z,R=h-2*z+w,P=h-z,o=I._x*t+j._x*U+E._x*R+e._x*P,Z=I._y*t+j._y*U+E._y*R+e._y*P,c=I._z*t+j._z*U+E._z*R+e._z*P;return new L(o,Z,c)}static Hermite1stDerivative(I,E,j,e,w){const z=new L;return this.Hermite1stDerivativeToRef(I,E,j,e,w,z),z}static Hermite1stDerivativeToRef(I,E,j,e,w,z){const h=w*w;return z._x=6*(h-w)*I._x+(3*h-4*w+1)*E._x+6*(-h+w)*j._x+(3*h-2*w)*e._x,z._y=6*(h-w)*I._y+(3*h-4*w+1)*E._y+6*(-h+w)*j._y+(3*h-2*w)*e._y,z._z=6*(h-w)*I._z+(3*h-4*w+1)*E._z+6*(-h+w)*j._z+(3*h-2*w)*e._z,z._isDirty=!0,z}static Lerp(I,E,j){const e=new L(0,0,0);return L.LerpToRef(I,E,j,e),e}static LerpToRef(I,E,j,e){return e._x=I._x+(E._x-I._x)*j,e._y=I._y+(E._y-I._y)*j,e._z=I._z+(E._z-I._z)*j,e._isDirty=!0,e}static Dot(I,E){return I._x*E._x+I._y*E._y+I._z*E._z}dot(I){return this._x*I._x+this._y*I._y+this._z*I._z}static Cross(I,E){const j=new L;return L.CrossToRef(I,E,j),j}static CrossToRef(I,E,j){const e=I._y*E._z-I._z*E._y,w=I._z*E._x-I._x*E._z,z=I._x*E._y-I._y*E._x;return j.nz(e,w,z),j}static Normalize(I){const E=L.Zero();return L.NormalizeToRef(I,E),E}static NormalizeToRef(I,E){return I.normalizeToRef(E),E}static Project(I,E,j,e){const w=new L;return L.ProjectToRef(I,E,j,e,w),w}static ProjectToRef(I,E,j,e,w){var z;const h=e.width,U=e.height,R=e.x,P=e.y,o=q.Matrix[1],Z=null===(z=t.d.LastCreatedEngine)||void 0===z?void 0:z.isNDCHalfZRange,c=Z?1:.5,K=Z?0:.5;X.FromValuesToRef(h/2,0,0,0,0,-U/2,0,0,0,0,c,0,R+h/2,U/2+P,K,1,o);const F=q.Matrix[0];return E.multiplyToRef(j,F),F.multiplyToRef(o,F),L.TransformCoordinatesToRef(I,F,w),w}static Reflect(I,E){return this.ReflectToRef(I,E,new L)}static ReflectToRef(I,E,j){const e=x.LE[0];return e.U(E).scaleInPlace(2*L.Dot(I,E)),j.U(I).Uo(e)}static _UnprojectFromInvertedMatrixToRef(I,E,j){L.TransformCoordinatesToRef(I,E,j);const e=E.m,w=I._x*e[3]+I._y*e[7]+I._z*e[11]+e[15];return(0,U.WithinEpsilon)(w,1)&&j.scaleInPlace(1/w),j}static UnprojectFromTransform(I,E,j,e,w){return this.Unproject(I,E,j,e,w,X.IdentityReadOnly)}static Unproject(I,E,j,e,w,z){const h=new L;return L.UnprojectToRef(I,E,j,e,w,z,h),h}static UnprojectToRef(I,E,j,e,w,z,h){return L.UnprojectFloatsToRef(I._x,I._y,I._z,E,j,e,w,z,h),h}static UnprojectFloatsToRef(I,E,j,e,w,z,h,U,R){var P;const o=q.Matrix[0];z.multiplyToRef(h,o),o.multiplyToRef(U,o),o.invert();const Z=q.LE[0];return Z.x=I/e*2-1,Z.y=-(E/w*2-1),null!==(P=t.d.LastCreatedEngine)&&void 0!==P&&P.isNDCHalfZRange?Z.z=j:Z.z=2*j-1,L._UnprojectFromInvertedMatrixToRef(Z,o,R),R}static Minimize(I,E){const j=new L;return j.U(I),j.minimizeInPlace(E),j}static Maximize(I,E){const j=new L;return j.U(I),j.maximizeInPlace(E),j}static Distance(I,E){return Math.sqrt(L.DistanceSquared(I,E))}static DistanceSquared(I,E){const j=I._x-E._x,e=I._y-E._y,w=I._z-E._z;return j*j+e*e+w*w}static ProjectOnTriangleToRef(I,E,j,w,z){const h=q.LE[0],t=q.LE[1],R=q.LE[2],P=q.LE[3],o=q.LE[4];j.subtractToRef(E,h),w.subtractToRef(E,t),w.subtractToRef(j,R);const Z=h.length(),c=t.length(),K=R.length();if(Z<e.b||c<e.b||K<e.b)return z.U(E),L.Distance(I,E);I.subtractToRef(E,o),L.CrossToRef(h,t,P);const F=P.length();if(F<e.b)return z.U(E),L.Distance(I,E);P.normalizeFromLength(F);let C=o.length();if(C<e.b)return z.U(E),0;o.normalizeFromLength(C);const X=L.Dot(P,o),x=q.LE[5],u=q.LE[6];x.U(P).scaleInPlace(-C*X),u.U(I).addInPlace(x);const b=q.LE[4],Q=q.LE[5],G=q.LE[7],y=q.LE[8];b.U(h).scaleInPlace(1/Z),y.U(t).scaleInPlace(1/c),b.addInPlace(y).scaleInPlace(-1),Q.U(h).scaleInPlace(-1/Z),y.U(R).scaleInPlace(1/K),Q.addInPlace(y).scaleInPlace(-1),G.U(R).scaleInPlace(-1/K),y.U(t).scaleInPlace(-1/c),G.addInPlace(y).scaleInPlace(-1);const d=q.LE[9];let a;d.U(u).Uo(E),L.CrossToRef(b,d,y),a=L.Dot(y,P);const l=a;d.U(u).Uo(j),L.CrossToRef(Q,d,y),a=L.Dot(y,P);const i=a;d.U(u).Uo(w),L.CrossToRef(G,d,y),a=L.Dot(y,P);const r=a,n=q.LE[10];let H,g;l>0&&i<0?(n.U(h),H=E,g=j):i>0&&r<0?(n.U(R),H=j,g=w):(n.U(t).scaleInPlace(-1),H=w,g=E);const Y=q.LE[9],A=q.LE[4];H.subtractToRef(u,y),g.subtractToRef(u,Y),L.CrossToRef(y,Y,A);if(!(L.Dot(A,P)<0))return z.U(u),Math.abs(C*X);const T=q.LE[5];L.CrossToRef(n,A,T),T.normalize();const M=q.LE[9];M.U(H).Uo(u);const W=M.length();if(W<e.b)return z.U(H),L.Distance(I,H);M.normalizeFromLength(W);const O=L.Dot(T,M),s=q.LE[7];s.U(u).addInPlace(T.scaleInPlace(W*O)),y.U(s).Uo(H),C=n.length(),n.normalizeFromLength(C);let v=L.Dot(y,n)/Math.max(C,e.b);return v=(0,U.Clamp)(v,0,1),s.U(H).addInPlace(n.scaleInPlace(v*C)),z.U(s),L.Distance(I,s)}static Center(I,E){return L.CenterToRef(I,E,L.Zero())}static CenterToRef(I,E,j){return j.nz((I._x+E._x)/2,(I._y+E._y)/2,(I._z+E._z)/2)}static RotationFromAxis(I,E,j){const e=new L;return L.RotationFromAxisToRef(I,E,j,e),e}static RotationFromAxisToRef(I,E,j,e){const w=q.Quaternion[0];return C.RotationQuaternionFromAxisToRef(I,E,j,w),w.toEulerAnglesToRef(e),e}}L._V8PerformanceHack=new L(.5,.5,.5),L._UpReadOnly=L.Up(),L._DownReadOnly=L.Down(),L._LeftHandedForwardReadOnly=L.Forward(!1),L._RightHandedForwardReadOnly=L.Forward(!0),L._LeftHandedBackwardReadOnly=L.Backward(!1),L._RightHandedBackwardReadOnly=L.Backward(!0),L._RightReadOnly=L.Right(),L._LeftReadOnly=L.Left(),L._ZeroReadOnly=L.Zero(),L._OneReadOnly=L.One(),Object.defineProperties(L.prototype,{dimension:{value:[3]},rank:{value:1}});class F{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}get w(){return this._w}set w(I){this._w=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=I,this._y=E,this._z=j,this._w=e}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let I=c(this._x);return I=397*I^c(this._y),I=397*I^c(this._z),I=397*I^c(this._w),I}re(){return[this._x,this._y,this._z,this._w]}toArray(I,E){return void 0===E&&(E=0),I[E]=this._x,I[E+1]=this._y,I[E+2]=this._z,I[E+3]=this._w,this}Kj(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F.FromArrayToRef(I,E,this),this}addInPlace(I){return this.x+=I._x,this.y+=I._y,this.z+=I._z,this.w+=I._w,this}addInPlaceFromFloats(I,E,j,e){return this.x+=I,this.y+=E,this.z+=j,this.w+=e,this}add(I){return new F(this._x+I.x,this._y+I.y,this._z+I.z,this._w+I.w)}addToRef(I,E){return E.x=this._x+I.x,E.y=this._y+I.y,E.z=this._z+I.z,E.w=this._w+I.w,E}Uo(I){return this.x-=I.x,this.y-=I.y,this.z-=I.z,this.w-=I.w,this}FE(I){return new F(this._x-I.x,this._y-I.y,this._z-I.z,this._w-I.w)}subtractToRef(I,E){return E.x=this._x-I.x,E.y=this._y-I.y,E.z=this._z-I.z,E.w=this._w-I.w,E}subtractFromFloats(I,E,j,e){return new F(this._x-I,this._y-E,this._z-j,this._w-e)}subtractFromFloatsToRef(I,E,j,e,w){return w.x=this._x-I,w.y=this._y-E,w.z=this._z-j,w.w=this._w-e,w}negate(){return new F(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(I){return I.x=-this._x,I.y=-this._y,I.z=-this._z,I.w=-this._w,I}scaleInPlace(I){return this.x*=I,this.y*=I,this.z*=I,this.w*=I,this}scale(I){return new F(this._x*I,this._y*I,this._z*I,this._w*I)}scaleToRef(I,E){return E.x=this._x*I,E.y=this._y*I,E.z=this._z*I,E.w=this._w*I,E}scaleAndAddToRef(I,E){return E.x+=this._x*I,E.y+=this._y*I,E.z+=this._z*I,E.w+=this._w*I,E}equals(I){return I&&this._x===I.x&&this._y===I.y&&this._z===I.z&&this._w===I.w}equalsWithEpsilon(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.b;return I&&(0,U.WithinEpsilon)(this._x,I.x,E)&&(0,U.WithinEpsilon)(this._y,I.y,E)&&(0,U.WithinEpsilon)(this._z,I.z,E)&&(0,U.WithinEpsilon)(this._w,I.w,E)}equalsToFloats(I,E,j,e){return this._x===I&&this._y===E&&this._z===j&&this._w===e}multiplyInPlace(I){return this.x*=I.x,this.y*=I.y,this.z*=I.z,this.w*=I.w,this}multiply(I){return new F(this._x*I.x,this._y*I.y,this._z*I.z,this._w*I.w)}multiplyToRef(I,E){return E.x=this._x*I.x,E.y=this._y*I.y,E.z=this._z*I.z,E.w=this._w*I.w,E}multiplyByFloats(I,E,j,e){return new F(this._x*I,this._y*E,this._z*j,this._w*e)}divide(I){return new F(this._x/I.x,this._y/I.y,this._z/I.z,this._w/I.w)}divideToRef(I,E){return E.x=this._x/I.x,E.y=this._y/I.y,E.z=this._z/I.z,E.w=this._w/I.w,E}divideInPlace(I){return this.divideToRef(I,this)}minimizeInPlace(I){return I.x<this._x&&(this.x=I.x),I.y<this._y&&(this.y=I.y),I.z<this._z&&(this.z=I.z),I.w<this._w&&(this.w=I.w),this}maximizeInPlace(I){return I.x>this._x&&(this.x=I.x),I.y>this._y&&(this.y=I.y),I.z>this._z&&(this.z=I.z),I.w>this._w&&(this.w=I.w),this}minimizeInPlaceFromFloats(I,E,j,e){return this.x=Math.min(I,this._x),this.y=Math.min(E,this._y),this.z=Math.min(j,this._z),this.w=Math.min(e,this._w),this}maximizeInPlaceFromFloats(I,E,j,e){return this.x=Math.max(I,this._x),this.y=Math.max(E,this._y),this.z=Math.max(j,this._z),this.w=Math.max(e,this._w),this}floorToRef(I){return I.x=Math.floor(this._x),I.y=Math.floor(this._y),I.z=Math.floor(this._z),I.w=Math.floor(this._w),I}floor(){return new F(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(I){return I.x=this._x-Math.floor(this._x),I.y=this._y-Math.floor(this._y),I.z=this._z-Math.floor(this._z),I.w=this._w-Math.floor(this._w),I}fract(){return new F(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){return this.normalizeToRef(new F)}normalizeToRef(I){const E=this.length();return 0===E||1===E?(I.x=this._x,I.y=this._y,I.z=this._z,I.w=this._w,I):this.scaleToRef(1/E,I)}toVector3(){return new L(this._x,this._y,this._z)}clone(){return new F(this._x,this._y,this._z,this._w)}U(I){return this.x=I.x,this.y=I.y,this.z=I.z,this.w=I.w,this}nz(I,E,j,e){return this.x=I,this.y=E,this.z=j,this.w=e,this}set(I,E,j,e){return this.nz(I,E,j,e)}mz(I){return this.x=this.y=this.z=this.w=I,this}dot(I){return this._x*I.x+this._y*I.y+this._z*I.z+this._w*I.w}static xE(I,E){return E||(E=0),new F(I[E],I[E+1],I[E+2],I[E+3])}static FromArrayToRef(I,E,j){return j.x=I[E],j.y=I[E+1],j.z=I[E+2],j.w=I[E+3],j}static FromFloatArrayToRef(I,E,j){return F.FromArrayToRef(I,E,j),j}static FromFloatsToRef(I,E,j,e,w){return w.x=I,w.y=E,w.z=j,w.w=e,w}static Zero(){return new F(0,0,0,0)}static One(){return new F(1,1,1,1)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new F((0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,j=arguments.length>2?arguments[2]:void 0;return j.x=(0,U.RandomRange)(I,E),j.y=(0,U.RandomRange)(I,E),j.z=(0,U.RandomRange)(I,E),j.w=(0,U.RandomRange)(I,E),j}static Clamp(I,E,j){return F.ClampToRef(I,E,j,new F)}static ClampToRef(I,E,j,e){return e.x=(0,U.Clamp)(I.x,E.x,j.x),e.y=(0,U.Clamp)(I.y,E.y,j.y),e.z=(0,U.Clamp)(I.z,E.z,j.z),e.w=(0,U.Clamp)(I.w,E.w,j.w),e}static CheckExtends(I,E,j){E.minimizeInPlace(I),j.maximizeInPlace(I)}static get ZeroReadOnly(){return F._ZeroReadOnly}static Normalize(I){return F.NormalizeToRef(I,new F)}static NormalizeToRef(I,E){return I.normalizeToRef(E),E}static Minimize(I,E){const j=new F;return j.U(I),j.minimizeInPlace(E),j}static Maximize(I,E){const j=new F;return j.U(I),j.maximizeInPlace(E),j}static Distance(I,E){return Math.sqrt(F.DistanceSquared(I,E))}static DistanceSquared(I,E){const j=I.x-E.x,e=I.y-E.y,w=I.z-E.z,z=I.w-E.w;return j*j+e*e+w*w+z*z}static Center(I,E){return F.CenterToRef(I,E,new F)}static CenterToRef(I,E,j){return j.x=(I.x+E.x)/2,j.y=(I.y+E.y)/2,j.z=(I.z+E.z)/2,j.w=(I.w+E.w)/2,j}static TransformCoordinates(I,E){return F.TransformCoordinatesToRef(I,E,new F)}static TransformCoordinatesToRef(I,E,j){return F.TransformCoordinatesFromFloatsToRef(I._x,I._y,I._z,E,j),j}static TransformCoordinatesFromFloatsToRef(I,E,j,e,w){const z=e.m,h=I*z[0]+E*z[4]+j*z[8]+z[12],t=I*z[1]+E*z[5]+j*z[9]+z[13],U=I*z[2]+E*z[6]+j*z[10]+z[14],R=I*z[3]+E*z[7]+j*z[11]+z[15];return w.x=h,w.y=t,w.z=U,w.w=R,w}static TransformNormal(I,E){return F.TransformNormalToRef(I,E,new F)}static TransformNormalToRef(I,E,j){const e=E.m,w=I.x*e[0]+I.y*e[4]+I.z*e[8],z=I.x*e[1]+I.y*e[5]+I.z*e[9],h=I.x*e[2]+I.y*e[6]+I.z*e[10];return j.x=w,j.y=z,j.z=h,j.w=I.w,j}static TransformNormalFromFloatsToRef(I,E,j,e,w,z){const h=w.m;return z.x=I*h[0]+E*h[4]+j*h[8],z.y=I*h[1]+E*h[5]+j*h[9],z.z=I*h[2]+E*h[6]+j*h[10],z.w=e,z}static FromVector3(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(I._x,I._y,I._z,E)}static Dot(I,E){return I.x*E.x+I.y*E.y+I.z*E.z+I.w*E.w}}F._V8PerformanceHack=new F(.5,.5,.5,.5),F._ZeroReadOnly=F.Zero(),Object.defineProperties(F.prototype,{dimension:{value:[4]},rank:{value:1}});class C{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}get w(){return this._w}set w(I){this._w=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=I,this._y=E,this._z=j,this._w=e}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let I=c(this._x);return I=397*I^c(this._y),I=397*I^c(this._z),I=397*I^c(this._w),I}re(){return[this._x,this._y,this._z,this._w]}toArray(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[E]=this._x,I[E+1]=this._y,I[E+2]=this._z,I[E+3]=this._w,this}Kj(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C.FromArrayToRef(I,E,this)}equals(I){return I&&this._x===I._x&&this._y===I._y&&this._z===I._z&&this._w===I._w}equalsWithEpsilon(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.b;return I&&(0,U.WithinEpsilon)(this._x,I._x,E)&&(0,U.WithinEpsilon)(this._y,I._y,E)&&(0,U.WithinEpsilon)(this._z,I._z,E)&&(0,U.WithinEpsilon)(this._w,I._w,E)}isApprox(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.b;return I&&((0,U.WithinEpsilon)(this._x,I._x,E)&&(0,U.WithinEpsilon)(this._y,I._y,E)&&(0,U.WithinEpsilon)(this._z,I._z,E)&&(0,U.WithinEpsilon)(this._w,I._w,E)||(0,U.WithinEpsilon)(this._x,-I._x,E)&&(0,U.WithinEpsilon)(this._y,-I._y,E)&&(0,U.WithinEpsilon)(this._z,-I._z,E)&&(0,U.WithinEpsilon)(this._w,-I._w,E))}clone(){return new C(this._x,this._y,this._z,this._w)}U(I){return this._x=I._x,this._y=I._y,this._z=I._z,this._w=I._w,this._isDirty=!0,this}nz(I,E,j,e){return this._x=I,this._y=E,this._z=j,this._w=e,this._isDirty=!0,this}set(I,E,j,e){return this.nz(I,E,j,e)}mz(I){return this.nz(I,I,I,I)}add(I){return new C(this._x+I._x,this._y+I._y,this._z+I._z,this._w+I._w)}addInPlace(I){return this._x+=I._x,this._y+=I._y,this._z+=I._z,this._w+=I._w,this._isDirty=!0,this}addToRef(I,E){return E._x=this._x+I._x,E._y=this._y+I._y,E._z=this._z+I._z,E._w=this._w+I._w,E._isDirty=!0,E}addInPlaceFromFloats(I,E,j,e){return this._x+=I,this._y+=E,this._z+=j,this._w+=e,this._isDirty=!0,this}subtractToRef(I,E){return E._x=this._x-I._x,E._y=this._y-I._y,E._z=this._z-I._z,E._w=this._w-I._w,E._isDirty=!0,E}subtractFromFloats(I,E,j,e){return this.subtractFromFloatsToRef(I,E,j,e,new C)}subtractFromFloatsToRef(I,E,j,e,w){return w._x=this._x-I,w._y=this._y-E,w._z=this._z-j,w._w=this._w-e,w._isDirty=!0,w}FE(I){return new C(this._x-I._x,this._y-I._y,this._z-I._z,this._w-I._w)}Uo(I){return this._x-=I._x,this._y-=I._y,this._z-=I._z,this._w-=I._w,this._isDirty=!0,this}scale(I){return new C(this._x*I,this._y*I,this._z*I,this._w*I)}scaleToRef(I,E){return E._x=this._x*I,E._y=this._y*I,E._z=this._z*I,E._w=this._w*I,E._isDirty=!0,E}scaleInPlace(I){return this._x*=I,this._y*=I,this._z*=I,this._w*=I,this._isDirty=!0,this}scaleAndAddToRef(I,E){return E._x+=this._x*I,E._y+=this._y*I,E._z+=this._z*I,E._w+=this._w*I,E._isDirty=!0,E}multiply(I){const E=new C(0,0,0,1);return this.multiplyToRef(I,E),E}multiplyToRef(I,E){const j=this._x*I._w+this._y*I._z-this._z*I._y+this._w*I._x,e=-this._x*I._z+this._y*I._w+this._z*I._x+this._w*I._y,w=this._x*I._y-this._y*I._x+this._z*I._w+this._w*I._z,z=-this._x*I._x-this._y*I._y-this._z*I._z+this._w*I._w;return E.nz(j,e,w,z),E}multiplyInPlace(I){return this.multiplyToRef(I,this)}multiplyByFloats(I,E,j,e){return this._x*=I,this._y*=E,this._z*=j,this._w*=e,this._isDirty=!0,this}divide(I){throw new ReferenceError("Can not divide a quaternion")}divideToRef(I,E){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(I){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new C)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(I){return I._x=-this._x,I._y=-this._y,I._z=-this._z,I._w=-this._w,I._isDirty=!0,I}equalsToFloats(I,E,j,e){return this._x===I&&this._y===E&&this._z===j&&this._w===e}floorToRef(I){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(I){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(I){return I.nz(-this._x,-this._y,-this._z,this._w),I}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new C(-this._x,-this._y,-this._z,this._w)}invert(){const I=this.conjugate(),E=this.lengthSquared();return 0==E||1==E||I.scaleInPlace(1/E),I}invertInPlace(){this.conjugateInPlace();const I=this.lengthSquared();return 0==I||1==I||this.scaleInPlace(1/I),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){const I=new C(0,0,0,1);return this.normalizeToRef(I),I}normalizeToRef(I){const E=this.length();return 0===E||1===E?I.nz(this._x,this._y,this._z,this._w):this.scaleToRef(1/E,I)}toEulerAngles(){const I=L.Zero();return this.toEulerAnglesToRef(I),I}toEulerAnglesToRef(I){const E=this._z,j=this._x,e=this._y,w=this._w,z=e*E-j*w,h=.4999999;if(z<-h)I._y=2*Math.atan2(e,w),I._x=Math.PI/2,I._z=0,I._isDirty=!0;else if(z>h)I._y=2*Math.atan2(e,w),I._x=-Math.PI/2,I._z=0,I._isDirty=!0;else{const h=w*w,t=E*E,U=j*j,R=e*e;I._z=Math.atan2(2*(j*e+E*w),-t-U+R+h),I._x=Math.asin(-2*z),I._y=Math.atan2(2*(E*j+e*w),t-U-R+h),I._isDirty=!0}return I}toAlphaBetaGammaToRef(I){const E=this._z,j=this._x,e=this._y,w=this._w,z=Math.sqrt(j*j+e*e),h=Math.sqrt(E*E+w*w),t=2*Math.atan2(z,h),U=2*Math.atan2(E,w),R=2*Math.atan2(e,j),P=(U+R)/2,o=(U-R)/2;return I.set(o,t,P),I}toRotationMatrix(I){return X.FromQuaternionToRef(this,I),I}fromRotationMatrix(I){return C.FromRotationMatrixToRef(I,this),this}dot(I){return this._x*I._x+this._y*I._y+this._z*I._z+this._w*I._w}toAxisAngle(){const I=L.Zero();return{axis:I,angle:this.toAxisAngleToRef(I)}}toAxisAngleToRef(I){let E=0;const j=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),e=this._w;return j>0?(E=2*Math.atan2(j,e),I.set(this._x/j,this._y/j,this._z/j)):(E=0,I.set(1,0,0)),E}static FromRotationMatrix(I){const E=new C;return C.FromRotationMatrixToRef(I,E),E}static FromRotationMatrixToRef(I,E){const j=I.m,e=j[0],w=j[4],z=j[8],h=j[1],t=j[5],U=j[9],R=j[2],P=j[6],o=j[10],Z=e+t+o;let c;return Z>0?(c=.5/Math.sqrt(Z+1),E._w=.25/c,E._x=(P-U)*c,E._y=(z-R)*c,E._z=(h-w)*c,E._isDirty=!0):e>t&&e>o?(c=2*Math.sqrt(1+e-t-o),E._w=(P-U)/c,E._x=.25*c,E._y=(w+h)/c,E._z=(z+R)/c,E._isDirty=!0):t>o?(c=2*Math.sqrt(1+t-e-o),E._w=(z-R)/c,E._x=(w+h)/c,E._y=.25*c,E._z=(U+P)/c,E._isDirty=!0):(c=2*Math.sqrt(1+o-e-t),E._w=(h-w)/c,E._x=(z+R)/c,E._y=(U+P)/c,E._z=.25*c,E._isDirty=!0),E}static Dot(I,E){return I._x*E._x+I._y*E._y+I._z*E._z+I._w*E._w}static AreClose(I,E){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const e=C.Dot(I,E);return 1-e*e<=j}static SmoothToRef(I,E,j,e,w){let z=0===e?1:j/e;return z=(0,U.Clamp)(z,0,1),C.SlerpToRef(I,E,z,w),w}static Zero(){return new C(0,0,0,0)}static Inverse(I){return new C(-I._x,-I._y,-I._z,I._w)}static InverseToRef(I,E){return E.set(-I._x,-I._y,-I._z,I._w),E}static Identity(){return new C(0,0,0,1)}static IsIdentity(I){return I&&0===I._x&&0===I._y&&0===I._z&&1===I._w}static RotationAxis(I,E){return C.RotationAxisToRef(I,E,new C)}static RotationAxisToRef(I,E,j){j._w=Math.cos(E/2);const e=Math.sin(E/2)/I.length();return j._x=I._x*e,j._y=I._y*e,j._z=I._z*e,j._isDirty=!0,j}static xE(I,E){return E||(E=0),new C(I[E],I[E+1],I[E+2],I[E+3])}static FromArrayToRef(I,E,j){return j._x=I[E],j._y=I[E+1],j._z=I[E+2],j._w=I[E+3],j._isDirty=!0,j}static FromFloatsToRef(I,E,j,e,w){return w.nz(I,E,j,e),w}static FromEulerAngles(I,E,j){const e=new C;return C.RotationYawPitchRollToRef(E,I,j,e),e}static FromEulerAnglesToRef(I,E,j,e){return C.RotationYawPitchRollToRef(E,I,j,e),e}static FromEulerVector(I){const E=new C;return C.RotationYawPitchRollToRef(I._y,I._x,I._z,E),E}static FromEulerVectorToRef(I,E){return C.RotationYawPitchRollToRef(I._y,I._x,I._z,E),E}static FromUnitVectorsToRef(I,E,j){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.b;const z=L.Dot(I,E)+1;return z<w?Math.abs(I.x)>Math.abs(I.z)?j.set(-I.y,I.x,0,0):j.set(0,-I.z,I.y,0):(L.CrossToRef(I,E,x.LE[0]),j.set(x.LE[0].x,x.LE[0].y,x.LE[0].z,z)),j.normalize()}static RotationYawPitchRoll(I,E,j){const e=new C;return C.RotationYawPitchRollToRef(I,E,j,e),e}static RotationYawPitchRollToRef(I,E,j,e){const w=.5*j,z=.5*E,h=.5*I,t=Math.sin(w),U=Math.cos(w),R=Math.sin(z),P=Math.cos(z),o=Math.sin(h),Z=Math.cos(h);return e._x=Z*R*U+o*P*t,e._y=o*P*U-Z*R*t,e._z=Z*P*t-o*R*U,e._w=Z*P*U+o*R*t,e._isDirty=!0,e}static RotationAlphaBetaGamma(I,E,j){const e=new C;return C.RotationAlphaBetaGammaToRef(I,E,j,e),e}static RotationAlphaBetaGammaToRef(I,E,j,e){const w=.5*(j+I),z=.5*(j-I),h=.5*E;return e._x=Math.cos(z)*Math.sin(h),e._y=Math.sin(z)*Math.sin(h),e._z=Math.sin(w)*Math.cos(h),e._w=Math.cos(w)*Math.cos(h),e._isDirty=!0,e}static RotationQuaternionFromAxis(I,E,j){const e=new C(0,0,0,0);return C.RotationQuaternionFromAxisToRef(I,E,j,e),e}static RotationQuaternionFromAxisToRef(I,E,j,e){const w=q.Matrix[0];return I=I.normalizeToRef(q.LE[0]),E=E.normalizeToRef(q.LE[1]),j=j.normalizeToRef(q.LE[2]),X.FromXYZAxesToRef(I,E,j,w),C.FromRotationMatrixToRef(w,e),e}static FromLookDirectionLH(I,E){const j=new C;return C.FromLookDirectionLHToRef(I,E,j),j}static FromLookDirectionLHToRef(I,E,j){const e=q.Matrix[0];return X.LookDirectionLHToRef(I,E,e),C.FromRotationMatrixToRef(e,j),j}static FromLookDirectionRH(I,E){const j=new C;return C.FromLookDirectionRHToRef(I,E,j),j}static FromLookDirectionRHToRef(I,E,j){const e=q.Matrix[0];return X.LookDirectionRHToRef(I,E,e),C.FromRotationMatrixToRef(e,j)}static Slerp(I,E,j){const e=C.Identity();return C.SlerpToRef(I,E,j,e),e}static SlerpToRef(I,E,j,e){let w,z,h=I._x*E._x+I._y*E._y+I._z*E._z+I._w*E._w,t=!1;if(h<0&&(t=!0,h=-h),h>.999999)z=1-j,w=t?-j:j;else{const I=Math.acos(h),E=1/Math.sin(I);z=Math.sin((1-j)*I)*E,w=t?-Math.sin(j*I)*E:Math.sin(j*I)*E}return e._x=z*I._x+w*E._x,e._y=z*I._y+w*E._y,e._z=z*I._z+w*E._z,e._w=z*I._w+w*E._w,e._isDirty=!0,e}static Hermite(I,E,j,e,w){const z=w*w,h=w*z,t=2*h-3*z+1,U=-2*h+3*z,R=h-2*z+w,P=h-z,o=I._x*t+j._x*U+E._x*R+e._x*P,Z=I._y*t+j._y*U+E._y*R+e._y*P,c=I._z*t+j._z*U+E._z*R+e._z*P,K=I._w*t+j._w*U+E._w*R+e._w*P;return new C(o,Z,c,K)}static Hermite1stDerivative(I,E,j,e,w){const z=new C;return this.Hermite1stDerivativeToRef(I,E,j,e,w,z),z}static Hermite1stDerivativeToRef(I,E,j,e,w,z){const h=w*w;return z._x=6*(h-w)*I._x+(3*h-4*w+1)*E._x+6*(-h+w)*j._x+(3*h-2*w)*e._x,z._y=6*(h-w)*I._y+(3*h-4*w+1)*E._y+6*(-h+w)*j._y+(3*h-2*w)*e._y,z._z=6*(h-w)*I._z+(3*h-4*w+1)*E._z+6*(-h+w)*j._z+(3*h-2*w)*e._z,z._w=6*(h-w)*I._w+(3*h-4*w+1)*E._w+6*(-h+w)*j._w+(3*h-2*w)*e._w,z._isDirty=!0,z}static Normalize(I){const E=C.Zero();return C.NormalizeToRef(I,E),E}static NormalizeToRef(I,E){return I.normalizeToRef(E),E}static Clamp(I,E,j){const e=new C;return C.ClampToRef(I,E,j,e),e}static ClampToRef(I,E,j,e){return e.nz((0,U.Clamp)(I.x,E.x,j.x),(0,U.Clamp)(I.y,E.y,j.y),(0,U.Clamp)(I.z,E.z,j.z),(0,U.Clamp)(I.w,E.w,j.w))}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new C((0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).nz((0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E),(0,U.RandomRange)(I,E))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(I,E){return Math.sqrt(C.DistanceSquared(I,E))}static DistanceSquared(I,E){const j=I.x-E.x,e=I.y-E.y,w=I.z-E.z,z=I.w-E.w;return j*j+e*e+w*w+z*z}static Center(I,E){return C.CenterToRef(I,E,C.Zero())}static CenterToRef(I,E,j){return j.nz((I.x+E.x)/2,(I.y+E.y)/2,(I.z+E.z)/2,(I.w+E.w)/2)}}C._V8PerformanceHack=new C(.5,.5,.5,.5),Object.defineProperties(C.prototype,{dimension:{value:[4]},rank:{value:1}});class X{static get Use64Bits(){return h.c.MatrixUse64Bits}get m(){return this.Xe}markAsUpdated(){this.updateFlag=R._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(I){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1],j=arguments.length>2&&void 0!==arguments[2]&&arguments[2],e=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=I,this._isIdentity3x2=I||j,this._isIdentityDirty=!this._isIdentity&&E,this._isIdentity3x2Dirty=!this._isIdentity3x2&&e}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,h.c.MatrixTrackPrecisionChange&&h.c.MatrixTrackedMatrices.push(this),this.Xe=new h.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const I=this.Xe;this._isIdentity=1===I[0]&&0===I[1]&&0===I[2]&&0===I[3]&&0===I[4]&&1===I[5]&&0===I[6]&&0===I[7]&&0===I[8]&&0===I[9]&&1===I[10]&&0===I[11]&&0===I[12]&&0===I[13]&&0===I[14]&&1===I[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Xe[0]||1!==this.Xe[5]||1!==this.Xe[15]||0!==this.Xe[1]||0!==this.Xe[2]||0!==this.Xe[3]||0!==this.Xe[4]||0!==this.Xe[6]||0!==this.Xe[7]||0!==this.Xe[8]||0!==this.Xe[9]||0!==this.Xe[10]||0!==this.Xe[11]||0!==this.Xe[12]||0!==this.Xe[13]||0!==this.Xe[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const I=this.Xe,E=I[0],j=I[1],e=I[2],w=I[3],z=I[4],h=I[5],t=I[6],U=I[7],R=I[8],P=I[9],o=I[10],Z=I[11],c=I[12],K=I[13],L=I[14],F=I[15],C=o*F-L*Z,X=P*F-K*Z,q=P*L-K*o,x=R*F-c*Z,u=R*L-o*c,b=R*K-c*P;return E*+(h*C-t*X+U*q)+j*-(z*C-t*x+U*u)+e*+(z*X-h*x+U*b)+w*-(z*q-h*u+t*b)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!I)return this.Xe;const j=this.Xe;for(let e=0;e<16;e++)I[E+e]=j[e];return this}re(){return this.Xe}Kj(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return X.FromArrayToRef(I,E,this)}nz(){for(var I=arguments.length,E=new Array(I),j=0;j<I;j++)E[j]=arguments[j];return X.FromArrayToRef(E,0,this)}set(){const I=this.Xe;for(let E=0;E<16;E++)I[E]=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}mz(I){const E=this.Xe;for(let j=0;j<16;j++)E[j]=I;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return X.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(I){const E=new X;return this.addToRef(I,E),E}addToRef(I,E){const j=this.Xe,e=E.Xe,w=I.m;for(let z=0;z<16;z++)e[z]=j[z]+w[z];return E.markAsUpdated(),E}addToSelf(I){const E=this.Xe,j=I.m;return E[0]+=j[0],E[1]+=j[1],E[2]+=j[2],E[3]+=j[3],E[4]+=j[4],E[5]+=j[5],E[6]+=j[6],E[7]+=j[7],E[8]+=j[8],E[9]+=j[9],E[10]+=j[10],E[11]+=j[11],E[12]+=j[12],E[13]+=j[13],E[14]+=j[14],E[15]+=j[15],this.markAsUpdated(),this}addInPlace(I){const E=this.Xe,j=I.m;for(let e=0;e<16;e++)E[e]+=j[e];return this.markAsUpdated(),this}addInPlaceFromFloats(){const I=this.Xe;for(let E=0;E<16;E++)I[E]+=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}FE(I){const E=this.Xe,j=I.m;for(let e=0;e<16;e++)E[e]-=j[e];return this.markAsUpdated(),this}subtractToRef(I,E){const j=this.Xe,e=I.m,w=E.Xe;for(let z=0;z<16;z++)w[z]=j[z]-e[z];return E.markAsUpdated(),E}Uo(I){const E=this.Xe,j=I.m;for(let e=0;e<16;e++)E[e]-=j[e];return this.markAsUpdated(),this}subtractFromFloats(){for(var I=arguments.length,E=new Array(I),j=0;j<I;j++)E[j]=arguments[j];return this.subtractFromFloatsToRef(...E,new X)}subtractFromFloatsToRef(){for(var I=arguments.length,E=new Array(I),j=0;j<I;j++)E[j]=arguments[j];const e=E.pop(),w=this.Xe,z=e.Xe,h=E;for(let t=0;t<16;t++)z[t]=w[t]-h[t];return e.markAsUpdated(),e}invertToRef(I){return!0===this._isIdentity?(X.IdentityToRef(I),I):(Z(this,I.re())?I.markAsUpdated():I.U(this),I)}addAtIndex(I,E){return this.Xe[I]+=E,this.markAsUpdated(),this}multiplyAtIndex(I,E){return this.Xe[I]*=E,this.markAsUpdated(),this}setTranslationFromFloats(I,E,j){return this.Xe[12]=I,this.Xe[13]=E,this.Xe[14]=j,this.markAsUpdated(),this}addTranslationFromFloats(I,E,j){return this.Xe[12]+=I,this.Xe[13]+=E,this.Xe[14]+=j,this.markAsUpdated(),this}setTranslation(I){return this.setTranslationFromFloats(I._x,I._y,I._z)}getTranslation(){return new L(this.Xe[12],this.Xe[13],this.Xe[14])}getTranslationToRef(I){return I.x=this.Xe[12],I.y=this.Xe[13],I.z=this.Xe[14],I}removeRotationAndScaling(){const I=this.m;return X.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,I[12],I[13],I[14],I[15],this),this._updateIdentityStatus(0===I[12]&&0===I[13]&&0===I[14]&&1===I[15]),this}U(I){I.copyToArray(this.Xe);const E=I;return this.updateFlag=E.updateFlag,this._updateIdentityStatus(E._isIdentity,E._isIdentityDirty,E._isIdentity3x2,E._isIdentity3x2Dirty),this}copyToArray(I){return o(this,I,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(I){const E=new X;return this.multiplyToRef(I,E),E}multiplyInPlace(I){const E=this.Xe,j=I.m;for(let e=0;e<16;e++)E[e]*=j[e];return this.markAsUpdated(),this}multiplyByFloats(){const I=this.Xe;for(let E=0;E<16;E++)I[E]*=E<0||arguments.length<=E?void 0:arguments[E];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var I=arguments.length,E=new Array(I),j=0;j<I;j++)E[j]=arguments[j];const e=E.pop(),w=this.Xe,z=e.Xe,h=E;for(let t=0;t<16;t++)z[t]=w[t]*h[t];return e.markAsUpdated(),e}multiplyToRef(I,E){return this._isIdentity?(E.U(I),E):I._isIdentity?(E.U(this),E):(this.multiplyToArray(I,E.Xe,0),E.markAsUpdated(),E)}multiplyToArray(I,E,j){return P(this,I,E,j),this}divide(I){return this.divideToRef(I,new X)}divideToRef(I,E){const j=this.Xe,e=I.m,w=E.Xe;for(let z=0;z<16;z++)w[z]=j[z]/e[z];return E.markAsUpdated(),E}divideInPlace(I){const E=this.Xe,j=I.m;for(let e=0;e<16;e++)E[e]/=j[e];return this.markAsUpdated(),this}minimizeInPlace(I){const E=this.Xe,j=I.m;for(let e=0;e<16;e++)E[e]=Math.min(E[e],j[e]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const I=this.Xe;for(let E=0;E<16;E++)I[E]=Math.min(I[E],E<0||arguments.length<=E?void 0:arguments[E]);return this.markAsUpdated(),this}maximizeInPlace(I){const E=this.Xe,j=I.m;for(let e=0;e<16;e++)E[e]=Math.min(E[e],j[e]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const I=this.Xe;for(let E=0;E<16;E++)I[E]=Math.min(I[E],E<0||arguments.length<=E?void 0:arguments[E]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new X)}negateInPlace(){const I=this.Xe;for(let E=0;E<16;E++)I[E]=-I[E];return this.markAsUpdated(),this}negateToRef(I){const E=this.Xe,j=I.Xe;for(let e=0;e<16;e++)j[e]=-E[e];return I.markAsUpdated(),I}equals(I){const E=I;if(!E)return!1;if((this._isIdentity||E._isIdentity)&&!this._isIdentityDirty&&!E._isIdentityDirty)return this._isIdentity&&E._isIdentity;const j=this.m,e=E.m;return j[0]===e[0]&&j[1]===e[1]&&j[2]===e[2]&&j[3]===e[3]&&j[4]===e[4]&&j[5]===e[5]&&j[6]===e[6]&&j[7]===e[7]&&j[8]===e[8]&&j[9]===e[9]&&j[10]===e[10]&&j[11]===e[11]&&j[12]===e[12]&&j[13]===e[13]&&j[14]===e[14]&&j[15]===e[15]}equalsWithEpsilon(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const j=this.Xe,e=I.m;for(let w=0;w<16;w++)if(!(0,U.WithinEpsilon)(j[w],e[w],E))return!1;return!0}equalsToFloats(){const I=this.Xe;for(let E=0;E<16;E++)if(I[E]!=(E<0||arguments.length<=E?void 0:arguments[E]))return!1;return!0}floor(){return this.floorToRef(new X)}floorToRef(I){const E=this.Xe,j=I.Xe;for(let e=0;e<16;e++)j[e]=Math.floor(E[e]);return I.markAsUpdated(),I}fract(){return this.fractToRef(new X)}fractToRef(I){const E=this.Xe,j=I.Xe;for(let e=0;e<16;e++)j[e]=E[e]-Math.floor(E[e]);return I.markAsUpdated(),I}clone(){const I=new X;return I.U(this),I}getClassName(){return"Matrix"}getHashCode(){let I=c(this.Xe[0]);for(let E=1;E<16;E++)I=397*I^c(this.Xe[E]);return I}decomposeToTransformNode(I){return I.rotationQuaternion=I.rotationQuaternion||new C,this.decompose(I.pz,I.rotationQuaternion,I.position)}decompose(I,E,j,e){let w=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return j&&j.mz(0),I&&I.mz(1),E&&E.nz(0,0,0,1),!0;const z=this.Xe;if(j&&j.nz(z[12],z[13],z[14]),(I=I||q.LE[0]).x=Math.sqrt(z[0]*z[0]+z[1]*z[1]+z[2]*z[2]),I.y=Math.sqrt(z[4]*z[4]+z[5]*z[5]+z[6]*z[6]),I.z=Math.sqrt(z[8]*z[8]+z[9]*z[9]+z[10]*z[10]),e){const E=(w?e.absoluteScaling.x:e.pz.x)<0?-1:1,j=(w?e.absoluteScaling.y:e.pz.y)<0?-1:1,z=(w?e.absoluteScaling.z:e.pz.z)<0?-1:1;I.x*=E,I.y*=j,I.z*=z}else this.determinant()<=0&&(I.y*=-1);if(0===I._x||0===I._y||0===I._z)return E&&E.nz(0,0,0,1),!1;if(E){const j=1/I._x,e=1/I._y,w=1/I._z;X.FromValuesToRef(z[0]*j,z[1]*j,z[2]*j,0,z[4]*e,z[5]*e,z[6]*e,0,z[8]*w,z[9]*w,z[10]*w,0,0,0,0,1,q.Matrix[0]),C.FromRotationMatrixToRef(q.Matrix[0],E)}return!0}getRow(I){if(I<0||I>3)return null;const E=4*I;return new F(this.Xe[E+0],this.Xe[E+1],this.Xe[E+2],this.Xe[E+3])}getRowToRef(I,E){if(I>=0&&I<=3){const j=4*I;E.x=this.Xe[j+0],E.y=this.Xe[j+1],E.z=this.Xe[j+2],E.w=this.Xe[j+3]}return E}setRow(I,E){return this.setRowFromFloats(I,E.x,E.y,E.z,E.w)}transpose(){const I=new X;return X.TransposeToRef(this,I),I}transposeToRef(I){return X.TransposeToRef(this,I),I}setRowFromFloats(I,E,j,e,w){if(I<0||I>3)return this;const z=4*I;return this.Xe[z+0]=E,this.Xe[z+1]=j,this.Xe[z+2]=e,this.Xe[z+3]=w,this.markAsUpdated(),this}scale(I){const E=new X;return this.scaleToRef(I,E),E}scaleToRef(I,E){for(let j=0;j<16;j++)E.Xe[j]=this.Xe[j]*I;return E.markAsUpdated(),E}scaleAndAddToRef(I,E){for(let j=0;j<16;j++)E.Xe[j]+=this.Xe[j]*I;return E.markAsUpdated(),E}scaleInPlace(I){const E=this.Xe;for(let j=0;j<16;j++)E[j]*=I;return this.markAsUpdated(),this}toNormalMatrix(I){const E=q.Matrix[0];this.invertToRef(E),E.transposeToRef(I);const j=I.Xe;return X.FromValuesToRef(j[0],j[1],j[2],0,j[4],j[5],j[6],0,j[8],j[9],j[10],0,0,0,0,1,I),I}getRotationMatrix(){const I=new X;return this.getRotationMatrixToRef(I),I}getRotationMatrixToRef(I){const E=q.LE[0];if(!this.decompose(E))return X.IdentityToRef(I),I;const j=this.Xe,e=1/E._x,w=1/E._y,z=1/E._z;return X.FromValuesToRef(j[0]*e,j[1]*e,j[2]*e,0,j[4]*w,j[5]*w,j[6]*w,0,j[8]*z,j[9]*z,j[10]*z,0,0,0,0,1,I),I}toggleModelMatrixHandInPlace(){const I=this.Xe;return I[2]*=-1,I[6]*=-1,I[8]*=-1,I[9]*=-1,I[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const I=this.Xe;return I[8]*=-1,I[9]*=-1,I[10]*=-1,I[11]*=-1,this.markAsUpdated(),this}static xE(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const j=new X;return X.FromArrayToRef(I,E,j),j}static FromArrayToRef(I,E,j){for(let e=0;e<16;e++)j.Xe[e]=I[e+E];return j.markAsUpdated(),j}static FromFloat32ArrayToRefScaled(I,E,j,e){return e.Xe[0]=I[0+E]*j,e.Xe[1]=I[1+E]*j,e.Xe[2]=I[2+E]*j,e.Xe[3]=I[3+E]*j,e.Xe[4]=I[4+E]*j,e.Xe[5]=I[5+E]*j,e.Xe[6]=I[6+E]*j,e.Xe[7]=I[7+E]*j,e.Xe[8]=I[8+E]*j,e.Xe[9]=I[9+E]*j,e.Xe[10]=I[10+E]*j,e.Xe[11]=I[11+E]*j,e.Xe[12]=I[12+E]*j,e.Xe[13]=I[13+E]*j,e.Xe[14]=I[14+E]*j,e.Xe[15]=I[15+E]*j,e.markAsUpdated(),e}static get IdentityReadOnly(){return X._IdentityReadOnly}static FromValuesToRef(I,E,j,e,w,z,h,t,U,R,P,o,Z,c,K,L,F){const C=F.Xe;C[0]=I,C[1]=E,C[2]=j,C[3]=e,C[4]=w,C[5]=z,C[6]=h,C[7]=t,C[8]=U,C[9]=R,C[10]=P,C[11]=o,C[12]=Z,C[13]=c,C[14]=K,C[15]=L,F.markAsUpdated()}static FromValues(I,E,j,e,w,z,h,t,U,R,P,o,Z,c,K,L){const F=new X,C=F.Xe;return C[0]=I,C[1]=E,C[2]=j,C[3]=e,C[4]=w,C[5]=z,C[6]=h,C[7]=t,C[8]=U,C[9]=R,C[10]=P,C[11]=o,C[12]=Z,C[13]=c,C[14]=K,C[15]=L,F.markAsUpdated(),F}static Compose(I,E,j){const e=new X;return X.ComposeToRef(I,E,j,e),e}static ComposeToRef(I,E,j,e){const w=e.Xe,z=E._x,h=E._y,t=E._z,U=E._w,R=z+z,P=h+h,o=t+t,Z=z*R,c=z*P,K=z*o,L=h*P,F=h*o,C=t*o,X=U*R,q=U*P,x=U*o,u=I._x,b=I._y,Q=I._z;return w[0]=(1-(L+C))*u,w[1]=(c+x)*u,w[2]=(K-q)*u,w[3]=0,w[4]=(c-x)*b,w[5]=(1-(Z+C))*b,w[6]=(F+X)*b,w[7]=0,w[8]=(K+q)*Q,w[9]=(F-X)*Q,w[10]=(1-(Z+L))*Q,w[11]=0,w[12]=j._x,w[13]=j._y,w[14]=j._z,w[15]=1,e.markAsUpdated(),e}static Identity(){const I=X.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return I._updateIdentityStatus(!0),I}static IdentityToRef(I){return X.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,I),I._updateIdentityStatus(!0),I}static Zero(){const I=X.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return I._updateIdentityStatus(!1),I}static RotationX(I){const E=new X;return X.RotationXToRef(I,E),E}static Invert(I){const E=new X;return I.invertToRef(E),E}static RotationXToRef(I,E){const j=Math.sin(I),e=Math.cos(I);return X.FromValuesToRef(1,0,0,0,0,e,j,0,0,-j,e,0,0,0,0,1,E),E._updateIdentityStatus(1===e&&0===j),E}static RotationY(I){const E=new X;return X.RotationYToRef(I,E),E}static RotationYToRef(I,E){const j=Math.sin(I),e=Math.cos(I);return X.FromValuesToRef(e,0,-j,0,0,1,0,0,j,0,e,0,0,0,0,1,E),E._updateIdentityStatus(1===e&&0===j),E}static RotationZ(I){const E=new X;return X.RotationZToRef(I,E),E}static RotationZToRef(I,E){const j=Math.sin(I),e=Math.cos(I);return X.FromValuesToRef(e,j,0,0,-j,e,0,0,0,0,1,0,0,0,0,1,E),E._updateIdentityStatus(1===e&&0===j),E}static RotationAxis(I,E){const j=new X;return X.RotationAxisToRef(I,E,j),j}static RotationAxisToRef(I,E,j){const e=Math.sin(-E),w=Math.cos(-E),z=1-w;I=I.normalizeToRef(q.LE[0]);const h=j.Xe;return h[0]=I._x*I._x*z+w,h[1]=I._x*I._y*z-I._z*e,h[2]=I._x*I._z*z+I._y*e,h[3]=0,h[4]=I._y*I._x*z+I._z*e,h[5]=I._y*I._y*z+w,h[6]=I._y*I._z*z-I._x*e,h[7]=0,h[8]=I._z*I._x*z-I._y*e,h[9]=I._z*I._y*z+I._x*e,h[10]=I._z*I._z*z+w,h[11]=0,h[12]=0,h[13]=0,h[14]=0,h[15]=1,j.markAsUpdated(),j}static RotationAlignToRef(I,E,j){let w=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const z=L.Dot(E,I),h=j.Xe;if(z<-1+e.b)h[0]=-1,h[1]=0,h[2]=0,h[3]=0,h[4]=0,h[5]=w?1:-1,h[6]=0,h[7]=0,h[8]=0,h[9]=0,h[10]=w?-1:1,h[11]=0;else{const j=L.Cross(E,I),e=1/(1+z);h[0]=j._x*j._x*e+z,h[1]=j._y*j._x*e-j._z,h[2]=j._z*j._x*e+j._y,h[3]=0,h[4]=j._x*j._y*e+j._z,h[5]=j._y*j._y*e+z,h[6]=j._z*j._y*e-j._x,h[7]=0,h[8]=j._x*j._z*e-j._y,h[9]=j._y*j._z*e+j._x,h[10]=j._z*j._z*e+z,h[11]=0}return h[12]=0,h[13]=0,h[14]=0,h[15]=1,j.markAsUpdated(),j}static RotationYawPitchRoll(I,E,j){const e=new X;return X.RotationYawPitchRollToRef(I,E,j,e),e}static RotationYawPitchRollToRef(I,E,j,e){return C.RotationYawPitchRollToRef(I,E,j,q.Quaternion[0]),q.Quaternion[0].toRotationMatrix(e),e}static Scaling(I,E,j){const e=new X;return X.ScalingToRef(I,E,j,e),e}static ScalingToRef(I,E,j,e){return X.FromValuesToRef(I,0,0,0,0,E,0,0,0,0,j,0,0,0,0,1,e),e._updateIdentityStatus(1===I&&1===E&&1===j),e}static Translation(I,E,j){const e=new X;return X.TranslationToRef(I,E,j,e),e}static TranslationToRef(I,E,j,e){return X.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,I,E,j,1,e),e._updateIdentityStatus(0===I&&0===E&&0===j),e}static Lerp(I,E,j){const e=new X;return X.LerpToRef(I,E,j,e),e}static LerpToRef(I,E,j,e){const w=e.Xe,z=I.m,h=E.m;for(let t=0;t<16;t++)w[t]=z[t]*(1-j)+h[t]*j;return e.markAsUpdated(),e}static DecomposeLerp(I,E,j){const e=new X;return X.DecomposeLerpToRef(I,E,j,e),e}static DecomposeLerpToRef(I,E,j,e){const w=q.LE[0],z=q.Quaternion[0],h=q.LE[1];I.decompose(w,z,h);const t=q.LE[2],U=q.Quaternion[1],R=q.LE[3];E.decompose(t,U,R);const P=q.LE[4];L.LerpToRef(w,t,j,P);const o=q.Quaternion[2];C.SlerpToRef(z,U,j,o);const Z=q.LE[5];return L.LerpToRef(h,R,j,Z),X.ComposeToRef(P,o,Z,e),e}static LookAtLH(I,E,j){const e=new X;return X.LookAtLHToRef(I,E,j,e),e}static LookAtLHToRef(I,E,j,e){const w=q.LE[0],z=q.LE[1],h=q.LE[2];E.subtractToRef(I,h),h.normalize(),L.CrossToRef(j,h,w);const t=w.lengthSquared();0===t?w.x=1:w.normalizeFromLength(Math.sqrt(t)),L.CrossToRef(h,w,z),z.normalize();const U=-L.Dot(w,I),R=-L.Dot(z,I),P=-L.Dot(h,I);return X.FromValuesToRef(w._x,z._x,h._x,0,w._y,z._y,h._y,0,w._z,z._z,h._z,0,U,R,P,1,e),e}static LookAtRH(I,E,j){const e=new X;return X.LookAtRHToRef(I,E,j,e),e}static LookAtRHToRef(I,E,j,e){const w=q.LE[0],z=q.LE[1],h=q.LE[2];I.subtractToRef(E,h),h.normalize(),L.CrossToRef(j,h,w);const t=w.lengthSquared();0===t?w.x=1:w.normalizeFromLength(Math.sqrt(t)),L.CrossToRef(h,w,z),z.normalize();const U=-L.Dot(w,I),R=-L.Dot(z,I),P=-L.Dot(h,I);return X.FromValuesToRef(w._x,z._x,h._x,0,w._y,z._y,h._y,0,w._z,z._z,h._z,0,U,R,P,1,e),e}static LookDirectionLH(I,E){const j=new X;return X.LookDirectionLHToRef(I,E,j),j}static LookDirectionLHToRef(I,E,j){const e=q.LE[0];e.U(I),e.scaleInPlace(-1);const w=q.LE[1];return L.CrossToRef(E,e,w),X.FromValuesToRef(w._x,w._y,w._z,0,E._x,E._y,E._z,0,e._x,e._y,e._z,0,0,0,0,1,j),j}static LookDirectionRH(I,E){const j=new X;return X.LookDirectionRHToRef(I,E,j),j}static LookDirectionRHToRef(I,E,j){const e=q.LE[2];return L.CrossToRef(E,I,e),X.FromValuesToRef(e._x,e._y,e._z,0,E._x,E._y,E._z,0,I._x,I._y,I._z,0,0,0,0,1,j),j}static OrthoLH(I,E,j,e,w){const z=new X;return X.OrthoLHToRef(I,E,j,e,z,w),z}static OrthoLHToRef(I,E,j,e,w,z){const h=2/I,t=2/E,U=2/(e-j),R=-(e+j)/(e-j);return X.FromValuesToRef(h,0,0,0,0,t,0,0,0,0,U,0,0,0,R,1,w),z&&w.multiplyToRef(u,w),w._updateIdentityStatus(1===h&&1===t&&1===U&&0===R),w}static OrthoOffCenterLH(I,E,j,e,w,z,h){const t=new X;return X.OrthoOffCenterLHToRef(I,E,j,e,w,z,t,h),t}static OrthoOffCenterLHToRef(I,E,j,e,w,z,h,t){const U=2/(E-I),R=2/(e-j),P=2/(z-w),o=-(z+w)/(z-w),Z=(I+E)/(I-E),c=(e+j)/(j-e);return X.FromValuesToRef(U,0,0,0,0,R,0,0,0,0,P,0,Z,c,o,1,h),t&&h.multiplyToRef(u,h),h.markAsUpdated(),h}static ObliqueOffCenterLHToRef(I,E,j,e,w,z,h,t,U,R,P){const o=-h*Math.cos(t),Z=-h*Math.sin(t);return X.TranslationToRef(0,0,-U,q.Matrix[1]),X.FromValuesToRef(1,0,0,0,0,1,0,0,o,Z,1,0,0,0,0,1,q.Matrix[0]),q.Matrix[1].multiplyToRef(q.Matrix[0],q.Matrix[0]),X.TranslationToRef(0,0,U,q.Matrix[1]),q.Matrix[0].multiplyToRef(q.Matrix[1],q.Matrix[0]),X.OrthoOffCenterLHToRef(I,E,j,e,w,z,R,P),q.Matrix[0].multiplyToRef(R,R),R}static OrthoOffCenterRH(I,E,j,e,w,z,h){const t=new X;return X.OrthoOffCenterRHToRef(I,E,j,e,w,z,t,h),t}static OrthoOffCenterRHToRef(I,E,j,e,w,z,h,t){return X.OrthoOffCenterLHToRef(I,E,j,e,w,z,h,t),h.Xe[10]*=-1,h}static ObliqueOffCenterRHToRef(I,E,j,e,w,z,h,t,U,R,P){const o=h*Math.cos(t),Z=h*Math.sin(t);return X.TranslationToRef(0,0,U,q.Matrix[1]),X.FromValuesToRef(1,0,0,0,0,1,0,0,o,Z,1,0,0,0,0,1,q.Matrix[0]),q.Matrix[1].multiplyToRef(q.Matrix[0],q.Matrix[0]),X.TranslationToRef(0,0,-U,q.Matrix[1]),q.Matrix[0].multiplyToRef(q.Matrix[1],q.Matrix[0]),X.OrthoOffCenterRHToRef(I,E,j,e,w,z,R,P),q.Matrix[0].multiplyToRef(R,R),R}static PerspectiveLH(I,E,j,e,w){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const h=new X,t=2*j/I,U=2*j/E,R=(e+j)/(e-j),P=-2*e*j/(e-j),o=Math.tan(z);return X.FromValuesToRef(t,0,0,0,0,U,0,o,0,0,R,1,0,0,P,0,h),w&&h.multiplyToRef(u,h),h._updateIdentityStatus(!1),h}static PerspectiveFovLH(I,E,j,e,w){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,h=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const t=new X;return X.PerspectiveFovLHToRef(I,E,j,e,t,!0,w,z,h),t}static PerspectiveFovLHToRef(I,E,j,e,w){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],h=arguments.length>6?arguments[6]:void 0,t=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,U=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const R=j,P=e,o=1/Math.tan(.5*I),Z=z?o/E:o,c=z?o:o*E,K=U&&0===R?-1:0!==P?(P+R)/(P-R):1,L=U&&0===R?2*P:0!==P?-2*P*R/(P-R):-2*R,F=Math.tan(t);return X.FromValuesToRef(Z,0,0,0,0,c,0,F,0,0,K,1,0,0,L,0,w),h&&w.multiplyToRef(u,w),w._updateIdentityStatus(!1),w}static PerspectiveFovReverseLHToRef(I,E,j,e,w){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],h=arguments.length>6?arguments[6]:void 0,t=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const U=1/Math.tan(.5*I),R=z?U/E:U,P=z?U:U*E,o=Math.tan(t);return X.FromValuesToRef(R,0,0,0,0,P,0,o,0,0,-j,1,0,0,1,0,w),h&&w.multiplyToRef(u,w),w._updateIdentityStatus(!1),w}static PerspectiveFovRH(I,E,j,e,w){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,h=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const t=new X;return X.PerspectiveFovRHToRef(I,E,j,e,t,!0,w,z,h),t}static PerspectiveFovRHToRef(I,E,j,e,w){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],h=arguments.length>6?arguments[6]:void 0,t=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,U=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const R=j,P=e,o=1/Math.tan(.5*I),Z=z?o/E:o,c=z?o:o*E,K=U&&0===R?1:0!==P?-(P+R)/(P-R):-1,L=U&&0===R?2*P:0!==P?-2*P*R/(P-R):-2*R,F=Math.tan(t);return X.FromValuesToRef(Z,0,0,0,0,c,0,F,0,0,K,-1,0,0,L,0,w),h&&w.multiplyToRef(u,w),w._updateIdentityStatus(!1),w}static PerspectiveFovReverseRHToRef(I,E,j,e,w){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],h=arguments.length>6?arguments[6]:void 0,t=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const U=1/Math.tan(.5*I),R=z?U/E:U,P=z?U:U*E,o=Math.tan(t);return X.FromValuesToRef(R,0,0,0,0,P,0,o,0,0,-j,-1,0,0,-1,0,w),h&&w.multiplyToRef(u,w),w._updateIdentityStatus(!1),w}static GetFinalMatrix(I,E,j,e,w,z){const h=I.width,t=I.height,U=I.x,R=I.y,P=X.FromValues(h/2,0,0,0,0,-t/2,0,0,0,0,z-w,0,U+h/2,t/2+R,w,1),o=new X;return E.multiplyToRef(j,o),o.multiplyToRef(e,o),o.multiplyToRef(P,o)}static GetAsMatrix2x2(I){const E=I.m,j=[E[0],E[1],E[4],E[5]];return h.c.MatrixUse64Bits?j:new Float32Array(j)}static GetAsMatrix3x3(I){const E=I.m,j=[E[0],E[1],E[2],E[4],E[5],E[6],E[8],E[9],E[10]];return h.c.MatrixUse64Bits?j:new Float32Array(j)}static Transpose(I){const E=new X;return X.TransposeToRef(I,E),E}static TransposeToRef(I,E){const j=I.m,e=j[0],w=j[4],z=j[8],h=j[12],t=j[1],U=j[5],R=j[9],P=j[13],o=j[2],Z=j[6],c=j[10],K=j[14],L=j[3],F=j[7],C=j[11],X=j[15],q=E.Xe;return q[0]=e,q[1]=w,q[2]=z,q[3]=h,q[4]=t,q[5]=U,q[6]=R,q[7]=P,q[8]=o,q[9]=Z,q[10]=c,q[11]=K,q[12]=L,q[13]=F,q[14]=C,q[15]=X,E.markAsUpdated(),E._updateIdentityStatus(I._isIdentity,I._isIdentityDirty),E}static Reflection(I){const E=new X;return X.ReflectionToRef(I,E),E}static ReflectionToRef(I,E){I.normalize();const j=I.normal.x,e=I.normal.y,w=I.normal.z,z=-2*j,h=-2*e,t=-2*w;return X.FromValuesToRef(z*j+1,h*j,t*j,0,z*e,h*e+1,t*e,0,z*w,h*w,t*w+1,0,z*I.d,h*I.d,t*I.d,1,E),E}static FromXYZAxesToRef(I,E,j,e){return X.FromValuesToRef(I._x,I._y,I._z,0,E._x,E._y,E._z,0,j._x,j._y,j._z,0,0,0,0,1,e),e}static FromQuaternionToRef(I,E){const j=I._x*I._x,e=I._y*I._y,w=I._z*I._z,z=I._x*I._y,h=I._z*I._w,t=I._z*I._x,U=I._y*I._w,R=I._y*I._z,P=I._x*I._w;return E.Xe[0]=1-2*(e+w),E.Xe[1]=2*(z+h),E.Xe[2]=2*(t-U),E.Xe[3]=0,E.Xe[4]=2*(z-h),E.Xe[5]=1-2*(w+j),E.Xe[6]=2*(R+P),E.Xe[7]=0,E.Xe[8]=2*(t+U),E.Xe[9]=2*(R-P),E.Xe[10]=1-2*(e+j),E.Xe[11]=0,E.Xe[12]=0,E.Xe[13]=0,E.Xe[14]=0,E.Xe[15]=1,E.markAsUpdated(),E}}X._IdentityReadOnly=X.Identity(),Object.defineProperties(X.prototype,{dimension:{value:[4,4]},rank:{value:2}});class q{}q.LE=(0,w.e)(11,L.Zero),q.Matrix=(0,w.e)(2,X.Identity),q.Quaternion=(0,w.e)(3,C.Zero);class x{}x.Vector2=(0,w.e)(3,K.Zero),x.LE=(0,w.e)(13,L.Zero),x.Vector4=(0,w.e)(3,F.Zero),x.Quaternion=(0,w.e)(3,C.Zero),x.Matrix=(0,w.e)(8,X.Identity),(0,z.h)("BABYLON.Vector2",K),(0,z.h)("BABYLON.Vector3",L),(0,z.h)("BABYLON.Vector4",F),(0,z.h)("BABYLON.Matrix",X);const u=X.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11127:(I,E,j)=>{function e(I,E){const j=[];for(let e=0;e<I;++e)j.push(E());return j}function w(I,E){return e(I,E)}j.d(E,{d:()=>e,e:()=>w,i:()=>h});const z=["push","splice","pop","shift","unshift"];function h(I,E){const j=z.map((j=>function(I,E,j){const e=I[E];if("function"!==typeof e)return null;const w=function(){const e=I.length,z=w.previous.apply(I,arguments);return j(E,e),z};return e.next=w,w.previous=e,I[E]=w,()=>{const j=w.previous;if(!j)return;const e=w.next;e?(j.next=e,e.previous=j):(j.next=void 0,I[E]=j),w.next=void 0,w.previous=void 0}}(I,j,E)));return()=>{for(const I of j)null===I||void 0===I||I()}}}}]);