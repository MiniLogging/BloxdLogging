"use strict";(self["686i8587bmi"]=self["686i8587bmi"]||[]).push([[14],{12772:(h,d,T)=>{T.d(d,{d:()=>n,f:()=>C,j:()=>Y,l:()=>y});const Y=1/2.2,y=2.2,C=(1+Math.sqrt(5))/2,n=.001},12787:(h,d,T)=>{function Y(h){return parseInt(h.toString().replace(/\W/g,""))}function y(h,d){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(h-d)<=T}function C(h,d,T){let Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return h<d-Y||h>T+Y}function n(h,d){return h===d?h:Math.random()*(d-h)+h}function X(h,d,T){return h+(d-h)*T}function F(h,d,T){let Y=J(d-h,360);return Y>180&&(Y-=360),h+Y*r(T)}function U(h,d,T){let Y=0;return Y=h!=d?r((T-h)/(d-h)):0,Y}function Z(h,d,T,Y,y){const C=y*y,n=y*C;return h*(2*n-3*C+1)+T*(-2*n+3*C)+d*(n-2*C+y)+Y*(n-C)}function S(h,d,T,Y,y){const C=y*y;return 6*(C-y)*h+(3*C-4*y+1)*d+6*(-C+y)*T+(3*C-2*y)*Y}function r(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(T,Math.max(d,h))}function c(h){return h-=2*Math.PI*Math.floor((h+Math.PI)/(2*Math.PI))}function O(h){const d=h.toString(16);return h<=15?("0"+d).toUpperCase():d.toUpperCase()}function f(h){if(Math.log2)return Math.floor(Math.log2(h));if(h<0)return NaN;if(0===h)return-1/0;let d=0;if(h<1){for(;h<1;)d++,h*=2;d=-d}else if(h>1)for(;h>1;)d++,h=Math.floor(h/2);return d}function J(h,d){return h-Math.floor(h/d)*d}function W(h,d,T){return(h-d)/(T-d)}function L(h,d,T){return h*(T-d)+d}function D(h,d){let T=J(d-h,360);return T>180&&(T-=360),T}function V(h,d){const T=J(h,2*d);return d-Math.abs(T-d)}function i(h,d,T){let Y=r(T);return Y=-2*Y*Y*Y+3*Y*Y,d*Y+h*(1-Y)}function w(h,d,T){let Y=0;return Y=Math.abs(d-h)<=T?d:h+Math.sign(d-h)*T,Y}function s(h,d,T){const Y=D(h,d);let y=0;return y=-T<Y&&Y<T?d:w(h,d=h+Y,T),y}function E(h,d,T){return(h-d)/(T-d)}function z(h,d,T){return(T-d)*h+d}function x(h,d){const T=h%d;return 0===T?d:x(d,T)}T.r(d),T.d(d,{Clamp:()=>r,DeltaAngle:()=>D,Denormalize:()=>L,ExtractAsInt:()=>Y,Hermite:()=>Z,Hermite1stDerivative:()=>S,HighestCommonFactor:()=>x,ILog2:()=>f,InverseLerp:()=>U,Lerp:()=>X,LerpAngle:()=>F,MoveTowards:()=>w,MoveTowardsAngle:()=>s,Normalize:()=>W,NormalizeRadians:()=>c,OutsideRange:()=>C,PercentToRange:()=>z,PingPong:()=>V,RandomRange:()=>n,RangeToPercent:()=>E,Repeat:()=>J,SmoothStep:()=>i,ToHex:()=>O,WithinEpsilon:()=>y})},12765:(h,d,T)=>{T.r(d),T.d(d,{Matrix:()=>L,Quaternion:()=>W,TmpVectors:()=>V,Vector2:()=>O,pd:()=>f,Vector4:()=>J});var Y=T(12772),y=T(12779),C=T(12714),n=T(12676),X=T(12625),F=T(12787);class U{}function Z(h,d,T){let Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const y=h.ad(),C=d.ad(),n=y[0],X=y[1],F=y[2],U=y[3],Z=y[4],S=y[5],r=y[6],c=y[7],O=y[8],f=y[9],J=y[10],W=y[11],L=y[12],D=y[13],V=y[14],i=y[15],w=C[0],s=C[1],E=C[2],z=C[3],x=C[4],g=C[5],H=C[6],p=C[7],k=C[8],o=C[9],u=C[10],N=C[11],K=C[12],l=C[13],q=C[14],j=C[15];T[Y]=n*w+X*x+F*k+U*K,T[Y+1]=n*s+X*g+F*o+U*l,T[Y+2]=n*E+X*H+F*u+U*q,T[Y+3]=n*z+X*p+F*N+U*j,T[Y+4]=Z*w+S*x+r*k+c*K,T[Y+5]=Z*s+S*g+r*o+c*l,T[Y+6]=Z*E+S*H+r*u+c*q,T[Y+7]=Z*z+S*p+r*N+c*j,T[Y+8]=O*w+f*x+J*k+W*K,T[Y+9]=O*s+f*g+J*o+W*l,T[Y+10]=O*E+f*H+J*u+W*q,T[Y+11]=O*z+f*p+J*N+W*j,T[Y+12]=L*w+D*x+V*k+i*K,T[Y+13]=L*s+D*g+V*o+i*l,T[Y+14]=L*E+D*H+V*u+i*q,T[Y+15]=L*z+D*p+V*N+i*j}function S(h,d){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const Y=h.ad();d[T]=Y[0],d[T+1]=Y[1],d[T+2]=Y[2],d[T+3]=Y[3],d[T+4]=Y[4],d[T+5]=Y[5],d[T+6]=Y[6],d[T+7]=Y[7],d[T+8]=Y[8],d[T+9]=Y[9],d[T+10]=Y[10],d[T+11]=Y[11],d[T+12]=Y[12],d[T+13]=Y[13],d[T+14]=Y[14],d[T+15]=Y[15]}function r(h,d){const T=h.ad(),Y=T[0],y=T[1],C=T[2],n=T[3],X=T[4],F=T[5],U=T[6],Z=T[7],S=T[8],r=T[9],c=T[10],O=T[11],f=T[12],J=T[13],W=T[14],L=T[15],D=c*L-W*O,V=r*L-J*O,i=r*W-J*c,w=S*L-f*O,s=S*W-c*f,E=S*J-f*r,z=+(F*D-U*V+Z*i),x=-(X*D-U*w+Z*s),g=+(X*V-F*w+Z*E),H=-(X*i-F*s+U*E),p=Y*z+y*x+C*g+n*H;if(0===p)return!1;const k=1/p,o=U*L-W*Z,u=F*L-J*Z,N=F*W-J*U,K=X*L-f*Z,l=X*W-f*U,q=X*J-f*F,j=U*O-c*Z,a=F*O-r*Z,e=F*c-r*U,v=X*O-S*Z,G=X*c-S*U,b=X*r-S*F,B=-(y*D-C*V+n*i),M=+(Y*D-C*w+n*s),mh=-(Y*V-y*w+n*E),R=+(Y*i-y*s+C*E),Q=+(y*o-C*u+n*N),I=-(Y*o-C*K+n*l),A=+(Y*u-y*K+n*q),P=-(Y*N-y*l+C*q),t=-(y*j-C*a+n*e),hh=+(Y*j-C*v+n*G),dh=-(Y*a-y*v+n*b),Th=+(Y*e-y*G+C*b);return d[0]=z*k,d[1]=B*k,d[2]=Q*k,d[3]=t*k,d[4]=x*k,d[5]=M*k,d[6]=I*k,d[7]=hh*k,d[8]=g*k,d[9]=mh*k,d[10]=A*k,d[11]=dh*k,d[12]=H*k,d[13]=R*k,d[14]=P*k,d[15]=Th*k,!0}U._UpdateFlagSeed=0;const c=h=>parseInt(h.toString().replace(/\W/g,""));class O{constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=h,this.y=d}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let h=c(this.x);return h=397*h^c(this.y),h}toArray(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[d]=this.x,h[d+1]=this.y,this}vT(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(h,d,this),this}ad(){return[this.x,this.y]}C(h){return this.x=h.x,this.y=h.y,this}ny(h,d){return this.x=h,this.y=d,this}set(h,d){return this.ny(h,d)}XC(h){return this.ny(h,h)}add(h){return new O(this.x+h.x,this.y+h.y)}addToRef(h,d){return d.x=this.x+h.x,d.y=this.y+h.y,d}addInPlace(h){return this.x+=h.x,this.y+=h.y,this}addInPlaceFromFloats(h,d){return this.x+=h,this.y+=d,this}addVector3(h){return new O(this.x+h.x,this.y+h.y)}Nd(h){return new O(this.x-h.x,this.y-h.y)}subtractToRef(h,d){return d.x=this.x-h.x,d.y=this.y-h.y,d}rS(h){return this.x-=h.x,this.y-=h.y,this}multiplyInPlace(h){return this.x*=h.x,this.y*=h.y,this}multiply(h){return new O(this.x*h.x,this.y*h.y)}multiplyToRef(h,d){return d.x=this.x*h.x,d.y=this.y*h.y,d}multiplyByFloats(h,d){return new O(this.x*h,this.y*d)}divide(h){return new O(this.x/h.x,this.y/h.y)}divideToRef(h,d){return d.x=this.x/h.x,d.y=this.y/h.y,d}divideInPlace(h){return this.x=this.x/h.x,this.y=this.y/h.y,this}minimizeInPlace(h){return this.minimizeInPlaceFromFloats(h.x,h.y)}maximizeInPlace(h){return this.maximizeInPlaceFromFloats(h.x,h.y)}minimizeInPlaceFromFloats(h,d){return this.x=Math.min(h,this.x),this.y=Math.min(d,this.y),this}maximizeInPlaceFromFloats(h,d){return this.x=Math.max(h,this.x),this.y=Math.max(d,this.y),this}subtractFromFloats(h,d){return new O(this.x-h,this.y-d)}subtractFromFloatsToRef(h,d,T){return T.x=this.x-h,T.y=this.y-d,T}negate(){return new O(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(h){return h.x=-this.x,h.y=-this.y,h}scaleInPlace(h){return this.x*=h,this.y*=h,this}scale(h){return new O(this.x*h,this.y*h)}scaleToRef(h,d){return d.x=this.x*h,d.y=this.y*h,d}scaleAndAddToRef(h,d){return d.x+=this.x*h,d.y+=this.y*h,d}equals(h){return h&&this.x===h.x&&this.y===h.y}equalsWithEpsilon(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Y.d;return h&&(0,F.WithinEpsilon)(this.x,h.x,d)&&(0,F.WithinEpsilon)(this.y,h.y,d)}equalsToFloats(h,d){return this.x===h&&this.y===d}floor(){return new O(Math.floor(this.x),Math.floor(this.y))}floorToRef(h){return h.x=Math.floor(this.x),h.y=Math.floor(this.y),h}fract(){return new O(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(h){return h.x=this.x-Math.floor(this.x),h.y=this.y-Math.floor(this.y),h}rotate(h){return this.rotateToRef(h,new O)}rotateToRef(h,d){const T=Math.cos(h),Y=Math.sin(h);return d.x=T*this.x-Y*this.y,d.y=Y*this.x+T*this.y,d}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){const h=new O;return this.normalizeToRef(h),h}normalizeToRef(h){const d=this.length();return 0===d&&(h.x=this.x,h.y=this.y),this.scaleToRef(1/d,h)}clone(){return new O(this.x,this.y)}dot(h){return this.x*h.x+this.y*h.y}static Zero(){return new O(0,0)}static One(){return new O(1,1)}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new O((0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).ny((0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d))}static get ZeroReadOnly(){return O._ZeroReadOnly}static Bd(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new O(h[d],h[d+1])}static FromArrayToRef(h,d,T){return T.x=h[d],T.y=h[d+1],T}static FromFloatsToRef(h,d,T){return T.ny(h,d),T}static CatmullRom(h,d,T,Y,y){const C=y*y,n=y*C,X=.5*(2*d.x+(-h.x+T.x)*y+(2*h.x-5*d.x+4*T.x-Y.x)*C+(-h.x+3*d.x-3*T.x+Y.x)*n),F=.5*(2*d.y+(-h.y+T.y)*y+(2*h.y-5*d.y+4*T.y-Y.y)*C+(-h.y+3*d.y-3*T.y+Y.y)*n);return new O(X,F)}static ClampToRef(h,d,T,Y){return Y.x=(0,F.Clamp)(h.x,d.x,T.x),Y.y=(0,F.Clamp)(h.y,d.y,T.y),Y}static Clamp(h,d,T){const Y=(0,F.Clamp)(h.x,d.x,T.x),y=(0,F.Clamp)(h.y,d.y,T.y);return new O(Y,y)}static Hermite(h,d,T,Y,y){const C=y*y,n=y*C,X=2*n-3*C+1,F=-2*n+3*C,U=n-2*C+y,Z=n-C,S=h.x*X+T.x*F+d.x*U+Y.x*Z,r=h.y*X+T.y*F+d.y*U+Y.y*Z;return new O(S,r)}static Hermite1stDerivative(h,d,T,Y,y){return this.Hermite1stDerivativeToRef(h,d,T,Y,y,new O)}static Hermite1stDerivativeToRef(h,d,T,Y,y,C){const n=y*y;return C.x=6*(n-y)*h.x+(3*n-4*y+1)*d.x+6*(-n+y)*T.x+(3*n-2*y)*Y.x,C.y=6*(n-y)*h.y+(3*n-4*y+1)*d.y+6*(-n+y)*T.y+(3*n-2*y)*Y.y,C}static Lerp(h,d,T){return O.LerpToRef(h,d,T,new O)}static LerpToRef(h,d,T,Y){return Y.x=h.x+(d.x-h.x)*T,Y.y=h.y+(d.y-h.y)*T,Y}static Dot(h,d){return h.x*d.x+h.y*d.y}static Normalize(h){return O.NormalizeToRef(h,new O)}static NormalizeToRef(h,d){return h.normalizeToRef(d),d}static Minimize(h,d){const T=h.x<d.x?h.x:d.x,Y=h.y<d.y?h.y:d.y;return new O(T,Y)}static Maximize(h,d){const T=h.x>d.x?h.x:d.x,Y=h.y>d.y?h.y:d.y;return new O(T,Y)}static Transform(h,d){return O.TransformToRef(h,d,new O)}static TransformToRef(h,d,T){const Y=d.m,y=h.x*Y[0]+h.y*Y[4]+Y[12],C=h.x*Y[1]+h.y*Y[5]+Y[13];return T.x=y,T.y=C,T}static PointInTriangle(h,d,T,Y){const y=.5*(-T.y*Y.x+d.y*(-T.x+Y.x)+d.x*(T.y-Y.y)+T.x*Y.y),C=y<0?-1:1,n=(d.y*Y.x-d.x*Y.y+(Y.y-d.y)*h.x+(d.x-Y.x)*h.y)*C,X=(d.x*T.y-d.y*T.x+(d.y-T.y)*h.x+(T.x-d.x)*h.y)*C;return n>0&&X>0&&n+X<2*y*C}static Distance(h,d){return Math.sqrt(O.DistanceSquared(h,d))}static DistanceSquared(h,d){const T=h.x-d.x,Y=h.y-d.y;return T*T+Y*Y}static Center(h,d){return O.CenterToRef(h,d,new O)}static CenterToRef(h,d,T){return T.ny((h.x+d.x)/2,(h.y+d.y)/2)}static DistanceOfPointFromSegment(h,d,T){const Y=O.DistanceSquared(d,T);if(0===Y)return O.Distance(h,d);const y=T.Nd(d),C=Math.max(0,Math.min(1,O.Dot(h.Nd(d),y)/Y)),n=d.add(y.multiplyByFloats(C,C));return O.Distance(h,n)}}O._V8PerformanceHack=new O(.5,.5),O._ZeroReadOnly=O.Zero(),Object.defineProperties(O.prototype,{dimension:{value:[2]},rank:{value:1}});class f{get x(){return this._x}set x(h){this._x=h,this._isDirty=!0}get y(){return this._y}set y(h){this._y=h,this._isDirty=!0}get z(){return this._z}set z(h){this._z=h,this._isDirty=!0}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=h,this._y=d,this._z=T}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"pd"}getHashCode(){let h=c(this._x);return h=397*h^c(this._y),h=397*h^c(this._z),h}ad(){return[this._x,this._y,this._z]}toArray(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[d]=this._x,h[d+1]=this._y,h[d+2]=this._z,this}vT(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f.FromArrayToRef(h,d,this),this}toQuaternion(){return W.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(h){return this._x+=h._x,this._y+=h._y,this._z+=h._z,this._isDirty=!0,this}addInPlaceFromFloats(h,d,T){return this._x+=h,this._y+=d,this._z+=T,this._isDirty=!0,this}add(h){return new f(this._x+h._x,this._y+h._y,this._z+h._z)}addToRef(h,d){return d._x=this._x+h._x,d._y=this._y+h._y,d._z=this._z+h._z,d._isDirty=!0,d}rS(h){return this._x-=h._x,this._y-=h._y,this._z-=h._z,this._isDirty=!0,this}Nd(h){return new f(this._x-h._x,this._y-h._y,this._z-h._z)}subtractToRef(h,d){return this.subtractFromFloatsToRef(h._x,h._y,h._z,d)}subtractFromFloats(h,d,T){return new f(this._x-h,this._y-d,this._z-T)}subtractFromFloatsToRef(h,d,T,Y){return Y._x=this._x-h,Y._y=this._y-d,Y._z=this._z-T,Y._isDirty=!0,Y}negate(){return new f(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(h){return h._x=-1*this._x,h._y=-1*this._y,h._z=-1*this._z,h._isDirty=!0,h}scaleInPlace(h){return this._x*=h,this._y*=h,this._z*=h,this._isDirty=!0,this}scale(h){return new f(this._x*h,this._y*h,this._z*h)}scaleToRef(h,d){return d._x=this._x*h,d._y=this._y*h,d._z=this._z*h,d._isDirty=!0,d}getNormalToRef(h){const d=this.length();let T=Math.acos(this._y/d);const Y=Math.atan2(this._z,this._x);T>Math.PI/2?T-=Math.PI/2:T+=Math.PI/2;const y=d*Math.sin(T)*Math.cos(Y),C=d*Math.cos(T),n=d*Math.sin(T)*Math.sin(Y);return h.set(y,C,n),h}applyRotationQuaternionToRef(h,d){const T=this._x,Y=this._y,y=this._z,C=h._x,n=h._y,X=h._z,F=h._w,U=2*(n*y-X*Y),Z=2*(X*T-C*y),S=2*(C*Y-n*T);return d._x=T+F*U+n*S-X*Z,d._y=Y+F*Z+X*U-C*S,d._z=y+F*S+C*Z-n*U,d._isDirty=!0,d}applyRotationQuaternionInPlace(h){return this.applyRotationQuaternionToRef(h,this)}applyRotationQuaternion(h){return this.applyRotationQuaternionToRef(h,new f)}scaleAndAddToRef(h,d){return d._x+=this._x*h,d._y+=this._y*h,d._z+=this._z*h,d._isDirty=!0,d}projectOnPlane(h,d){return this.projectOnPlaneToRef(h,d,new f)}projectOnPlaneToRef(h,d,T){const Y=h.normal,y=h.d,C=D.pd[0];this.subtractToRef(d,C),C.normalize();const n=f.Dot(C,Y);if(Math.abs(n)<1e-10)T.XC(1/0);else{const h=-(f.Dot(d,Y)+y)/n,X=C.scaleInPlace(h);d.addToRef(X,T)}return T}equals(h){return h&&this._x===h._x&&this._y===h._y&&this._z===h._z}equalsWithEpsilon(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Y.d;return h&&(0,F.WithinEpsilon)(this._x,h._x,d)&&(0,F.WithinEpsilon)(this._y,h._y,d)&&(0,F.WithinEpsilon)(this._z,h._z,d)}equalsToFloats(h,d,T){return this._x===h&&this._y===d&&this._z===T}multiplyInPlace(h){return this._x*=h._x,this._y*=h._y,this._z*=h._z,this._isDirty=!0,this}multiply(h){return this.multiplyByFloats(h._x,h._y,h._z)}multiplyToRef(h,d){return d._x=this._x*h._x,d._y=this._y*h._y,d._z=this._z*h._z,d._isDirty=!0,d}multiplyByFloats(h,d,T){return new f(this._x*h,this._y*d,this._z*T)}divide(h){return new f(this._x/h._x,this._y/h._y,this._z/h._z)}divideToRef(h,d){return d._x=this._x/h._x,d._y=this._y/h._y,d._z=this._z/h._z,d._isDirty=!0,d}divideInPlace(h){return this._x=this._x/h._x,this._y=this._y/h._y,this._z=this._z/h._z,this._isDirty=!0,this}minimizeInPlace(h){return this.minimizeInPlaceFromFloats(h._x,h._y,h._z)}maximizeInPlace(h){return this.maximizeInPlaceFromFloats(h._x,h._y,h._z)}minimizeInPlaceFromFloats(h,d,T){return h<this._x&&(this.x=h),d<this._y&&(this.y=d),T<this._z&&(this.z=T),this}maximizeInPlaceFromFloats(h,d,T){return h>this._x&&(this.x=h),d>this._y&&(this.y=d),T>this._z&&(this.z=T),this}isNonUniformWithinEpsilon(h){const d=Math.abs(this._x),T=Math.abs(this._y);if(!(0,F.WithinEpsilon)(d,T,h))return!0;const Y=Math.abs(this._z);return!(0,F.WithinEpsilon)(d,Y,h)||!(0,F.WithinEpsilon)(T,Y,h)}get isNonUniform(){const h=Math.abs(this._x);if(h!==Math.abs(this._y))return!0;return h!==Math.abs(this._z)}floorToRef(h){return h._x=Math.floor(this._x),h._y=Math.floor(this._y),h._z=Math.floor(this._z),h._isDirty=!0,h}floor(){return new f(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(h){return h._x=this._x-Math.floor(this._x),h._y=this._y-Math.floor(this._y),h._z=this._z-Math.floor(this._z),h._isDirty=!0,h}fract(){return new f(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(h){if("xyz"===(h=h.toLowerCase()))return this;const d=D.pd[0].C(this);return this.x=d[h[0]],this.y=d[h[1]],this.z=d[h[2]],this}rotateByQuaternionToRef(h,d){return h.toRotationMatrix(D.Matrix[0]),f.TransformCoordinatesToRef(this,D.Matrix[0],d),d}rotateByQuaternionAroundPointToRef(h,d,T){return this.subtractToRef(d,D.pd[0]),D.pd[0].rotateByQuaternionToRef(h,D.pd[0]),d.addToRef(D.pd[0],T),T}cross(h){return f.CrossToRef(this,h,new f)}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){return this.normalizeToRef(new f)}normalizeToRef(h){const d=this.length();return 0===d||1===d?(h._x=this._x,h._y=this._y,h._z=this._z,h._isDirty=!0,h):this.scaleToRef(1/d,h)}clone(){return new f(this._x,this._y,this._z)}C(h){return this.ny(h._x,h._y,h._z)}ny(h,d,T){return this._x=h,this._y=d,this._z=T,this._isDirty=!0,this}set(h,d,T){return this.ny(h,d,T)}XC(h){return this._x=this._y=this._z=h,this._isDirty=!0,this}static GetClipFactor(h,d,T,Y){const y=f.Dot(h,T);return(y-Y)/(y-f.Dot(d,T))}static GetAngleBetweenVectors(h,d,T){const Y=h.normalizeToRef(D.pd[1]),y=d.normalizeToRef(D.pd[2]);let C=f.Dot(Y,y);C=(0,F.Clamp)(C,-1,1);const n=Math.acos(C),X=D.pd[3];return f.CrossToRef(Y,y,X),f.Dot(X,T)>0?isNaN(n)?0:n:isNaN(n)?-Math.PI:-Math.acos(C)}static GetAngleBetweenVectorsOnPlane(h,d,T){D.pd[0].C(h);const Y=D.pd[0];D.pd[1].C(d);const y=D.pd[1];D.pd[2].C(T);const C=D.pd[2],n=D.pd[3],X=D.pd[4];Y.normalize(),y.normalize(),C.normalize(),f.CrossToRef(C,Y,n),f.CrossToRef(n,C,X);const U=Math.atan2(f.Dot(y,n),f.Dot(y,X));return(0,F.NormalizeRadians)(U)}static PitchYawRollToMoveBetweenPointsToRef(h,d,T){const Y=V.pd[0];return d.subtractToRef(h,Y),T._y=Math.atan2(Y.x,Y.z)||0,T._x=Math.atan2(Math.sqrt(Y.x**2+Y.z**2),Y.y)||0,T._z=0,T._isDirty=!0,T}static PitchYawRollToMoveBetweenPoints(h,d){const T=f.Zero();return f.PitchYawRollToMoveBetweenPointsToRef(h,d,T)}static SlerpToRef(h,d,T,y){T=(0,F.Clamp)(T,0,1);const C=D.pd[0],n=D.pd[1];C.C(h);const X=C.length();C.normalizeFromLength(X),n.C(d);const U=n.length();n.normalizeFromLength(U);const Z=f.Dot(C,n);let S,r;if(Z<1-Y.d){const h=Math.acos(Z),d=1/Math.sin(h);S=Math.sin((1-T)*h)*d,r=Math.sin(T*h)*d}else S=1-T,r=T;return C.scaleInPlace(S),n.scaleInPlace(r),y.C(C).addInPlace(n),y.scaleInPlace((0,F.Lerp)(X,U,T)),y}static SmoothToRef(h,d,T,Y,y){return f.SlerpToRef(h,d,0===Y?1:T/Y,y),y}static Bd(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new f(h[d],h[d+1],h[d+2])}static FromFloatArray(h,d){return f.Bd(h,d)}static FromArrayToRef(h,d,T){return T._x=h[d],T._y=h[d+1],T._z=h[d+2],T._isDirty=!0,T}static FromFloatArrayToRef(h,d,T){return f.FromArrayToRef(h,d,T)}static FromFloatsToRef(h,d,T,Y){return Y.ny(h,d,T),Y}static Zero(){return new f(0,0,0)}static One(){return new f(1,1,1)}static Up(){return new f(0,1,0)}static get UpReadOnly(){return f._UpReadOnly}static get DownReadOnly(){return f._DownReadOnly}static get RightReadOnly(){return f._RightReadOnly}static get LeftReadOnly(){return f._LeftReadOnly}static get LeftHandedForwardReadOnly(){return f._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return f._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return f._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return f._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return f._ZeroReadOnly}static get OneReadOnly(){return f._OneReadOnly}static Down(){return new f(0,-1,0)}static Forward(){return new f(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new f(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new f(1,0,0)}static Left(){return new f(-1,0,0)}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new f((0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).ny((0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d))}static TransformCoordinates(h,d){const T=f.Zero();return f.TransformCoordinatesToRef(h,d,T),T}static TransformCoordinatesToRef(h,d,T){return f.TransformCoordinatesFromFloatsToRef(h._x,h._y,h._z,d,T),T}static TransformCoordinatesFromFloatsToRef(h,d,T,Y,y){const C=Y.m,n=h*C[0]+d*C[4]+T*C[8]+C[12],X=h*C[1]+d*C[5]+T*C[9]+C[13],F=h*C[2]+d*C[6]+T*C[10]+C[14],U=1/(h*C[3]+d*C[7]+T*C[11]+C[15]);return y._x=n*U,y._y=X*U,y._z=F*U,y._isDirty=!0,y}static TransformNormal(h,d){const T=f.Zero();return f.TransformNormalToRef(h,d,T),T}static TransformNormalToRef(h,d,T){return this.TransformNormalFromFloatsToRef(h._x,h._y,h._z,d,T),T}static TransformNormalFromFloatsToRef(h,d,T,Y,y){const C=Y.m;return y._x=h*C[0]+d*C[4]+T*C[8],y._y=h*C[1]+d*C[5]+T*C[9],y._z=h*C[2]+d*C[6]+T*C[10],y._isDirty=!0,y}static CatmullRom(h,d,T,Y,y){const C=y*y,n=y*C,X=.5*(2*d._x+(-h._x+T._x)*y+(2*h._x-5*d._x+4*T._x-Y._x)*C+(-h._x+3*d._x-3*T._x+Y._x)*n),F=.5*(2*d._y+(-h._y+T._y)*y+(2*h._y-5*d._y+4*T._y-Y._y)*C+(-h._y+3*d._y-3*T._y+Y._y)*n),U=.5*(2*d._z+(-h._z+T._z)*y+(2*h._z-5*d._z+4*T._z-Y._z)*C+(-h._z+3*d._z-3*T._z+Y._z)*n);return new f(X,F,U)}static Clamp(h,d,T){const Y=new f;return f.ClampToRef(h,d,T,Y),Y}static ClampToRef(h,d,T,Y){let y=h._x;y=y>T._x?T._x:y,y=y<d._x?d._x:y;let C=h._y;C=C>T._y?T._y:C,C=C<d._y?d._y:C;let n=h._z;return n=n>T._z?T._z:n,n=n<d._z?d._z:n,Y.ny(y,C,n),Y}static CheckExtends(h,d,T){d.minimizeInPlace(h),T.maximizeInPlace(h)}static Hermite(h,d,T,Y,y){const C=y*y,n=y*C,X=2*n-3*C+1,F=-2*n+3*C,U=n-2*C+y,Z=n-C,S=h._x*X+T._x*F+d._x*U+Y._x*Z,r=h._y*X+T._y*F+d._y*U+Y._y*Z,c=h._z*X+T._z*F+d._z*U+Y._z*Z;return new f(S,r,c)}static Hermite1stDerivative(h,d,T,Y,y){const C=new f;return this.Hermite1stDerivativeToRef(h,d,T,Y,y,C),C}static Hermite1stDerivativeToRef(h,d,T,Y,y,C){const n=y*y;return C._x=6*(n-y)*h._x+(3*n-4*y+1)*d._x+6*(-n+y)*T._x+(3*n-2*y)*Y._x,C._y=6*(n-y)*h._y+(3*n-4*y+1)*d._y+6*(-n+y)*T._y+(3*n-2*y)*Y._y,C._z=6*(n-y)*h._z+(3*n-4*y+1)*d._z+6*(-n+y)*T._z+(3*n-2*y)*Y._z,C._isDirty=!0,C}static Lerp(h,d,T){const Y=new f(0,0,0);return f.LerpToRef(h,d,T,Y),Y}static LerpToRef(h,d,T,Y){return Y._x=h._x+(d._x-h._x)*T,Y._y=h._y+(d._y-h._y)*T,Y._z=h._z+(d._z-h._z)*T,Y._isDirty=!0,Y}static Dot(h,d){return h._x*d._x+h._y*d._y+h._z*d._z}dot(h){return this._x*h._x+this._y*h._y+this._z*h._z}static Cross(h,d){const T=new f;return f.CrossToRef(h,d,T),T}static CrossToRef(h,d,T){const Y=h._y*d._z-h._z*d._y,y=h._z*d._x-h._x*d._z,C=h._x*d._y-h._y*d._x;return T.ny(Y,y,C),T}static Normalize(h){const d=f.Zero();return f.NormalizeToRef(h,d),d}static NormalizeToRef(h,d){return h.normalizeToRef(d),d}static Project(h,d,T,Y){const y=new f;return f.ProjectToRef(h,d,T,Y,y),y}static ProjectToRef(h,d,T,Y,y){var C;const n=Y.width,F=Y.height,U=Y.x,Z=Y.y,S=D.Matrix[1],r=null===(C=X.d.LastCreatedEngine)||void 0===C?void 0:C.isNDCHalfZRange,c=r?1:.5,O=r?0:.5;L.FromValuesToRef(n/2,0,0,0,0,-F/2,0,0,0,0,c,0,U+n/2,F/2+Z,O,1,S);const J=D.Matrix[0];return d.multiplyToRef(T,J),J.multiplyToRef(S,J),f.TransformCoordinatesToRef(h,J,y),y}static Reflect(h,d){return this.ReflectToRef(h,d,new f)}static ReflectToRef(h,d,T){const Y=V.pd[0];return Y.C(d).scaleInPlace(2*f.Dot(h,d)),T.C(h).rS(Y)}static _UnprojectFromInvertedMatrixToRef(h,d,T){f.TransformCoordinatesToRef(h,d,T);const Y=d.m,y=h._x*Y[3]+h._y*Y[7]+h._z*Y[11]+Y[15];return(0,F.WithinEpsilon)(y,1)&&T.scaleInPlace(1/y),T}static UnprojectFromTransform(h,d,T,Y,y){return this.Unproject(h,d,T,Y,y,L.IdentityReadOnly)}static Unproject(h,d,T,Y,y,C){const n=new f;return f.UnprojectToRef(h,d,T,Y,y,C,n),n}static UnprojectToRef(h,d,T,Y,y,C,n){return f.UnprojectFloatsToRef(h._x,h._y,h._z,d,T,Y,y,C,n),n}static UnprojectFloatsToRef(h,d,T,Y,y,C,n,F,U){var Z;const S=D.Matrix[0];C.multiplyToRef(n,S),S.multiplyToRef(F,S),S.invert();const r=D.pd[0];return r.x=h/Y*2-1,r.y=-(d/y*2-1),null!==(Z=X.d.LastCreatedEngine)&&void 0!==Z&&Z.isNDCHalfZRange?r.z=T:r.z=2*T-1,f._UnprojectFromInvertedMatrixToRef(r,S,U),U}static Minimize(h,d){const T=new f;return T.C(h),T.minimizeInPlace(d),T}static Maximize(h,d){const T=new f;return T.C(h),T.maximizeInPlace(d),T}static Distance(h,d){return Math.sqrt(f.DistanceSquared(h,d))}static DistanceSquared(h,d){const T=h._x-d._x,Y=h._y-d._y,y=h._z-d._z;return T*T+Y*Y+y*y}static ProjectOnTriangleToRef(h,d,T,y,C){const n=D.pd[0],X=D.pd[1],U=D.pd[2],Z=D.pd[3],S=D.pd[4];T.subtractToRef(d,n),y.subtractToRef(d,X),y.subtractToRef(T,U);const r=n.length(),c=X.length(),O=U.length();if(r<Y.d||c<Y.d||O<Y.d)return C.C(d),f.Distance(h,d);h.subtractToRef(d,S),f.CrossToRef(n,X,Z);const J=Z.length();if(J<Y.d)return C.C(d),f.Distance(h,d);Z.normalizeFromLength(J);let W=S.length();if(W<Y.d)return C.C(d),0;S.normalizeFromLength(W);const L=f.Dot(Z,S),V=D.pd[5],i=D.pd[6];V.C(Z).scaleInPlace(-W*L),i.C(h).addInPlace(V);const w=D.pd[4],s=D.pd[5],E=D.pd[7],z=D.pd[8];w.C(n).scaleInPlace(1/r),z.C(X).scaleInPlace(1/c),w.addInPlace(z).scaleInPlace(-1),s.C(n).scaleInPlace(-1/r),z.C(U).scaleInPlace(1/O),s.addInPlace(z).scaleInPlace(-1),E.C(U).scaleInPlace(-1/O),z.C(X).scaleInPlace(-1/c),E.addInPlace(z).scaleInPlace(-1);const x=D.pd[9];let g;x.C(i).rS(d),f.CrossToRef(w,x,z),g=f.Dot(z,Z);const H=g;x.C(i).rS(T),f.CrossToRef(s,x,z),g=f.Dot(z,Z);const p=g;x.C(i).rS(y),f.CrossToRef(E,x,z),g=f.Dot(z,Z);const k=g,o=D.pd[10];let u,N;H>0&&p<0?(o.C(n),u=d,N=T):p>0&&k<0?(o.C(U),u=T,N=y):(o.C(X).scaleInPlace(-1),u=y,N=d);const K=D.pd[9],l=D.pd[4];u.subtractToRef(i,z),N.subtractToRef(i,K),f.CrossToRef(z,K,l);if(!(f.Dot(l,Z)<0))return C.C(i),Math.abs(W*L);const q=D.pd[5];f.CrossToRef(o,l,q),q.normalize();const j=D.pd[9];j.C(u).rS(i);const a=j.length();if(a<Y.d)return C.C(u),f.Distance(h,u);j.normalizeFromLength(a);const e=f.Dot(q,j),v=D.pd[7];v.C(i).addInPlace(q.scaleInPlace(a*e)),z.C(v).rS(u),W=o.length(),o.normalizeFromLength(W);let G=f.Dot(z,o)/Math.max(W,Y.d);return G=(0,F.Clamp)(G,0,1),v.C(u).addInPlace(o.scaleInPlace(G*W)),C.C(v),f.Distance(h,v)}static Center(h,d){return f.CenterToRef(h,d,f.Zero())}static CenterToRef(h,d,T){return T.ny((h._x+d._x)/2,(h._y+d._y)/2,(h._z+d._z)/2)}static RotationFromAxis(h,d,T){const Y=new f;return f.RotationFromAxisToRef(h,d,T,Y),Y}static RotationFromAxisToRef(h,d,T,Y){const y=D.Quaternion[0];return W.RotationQuaternionFromAxisToRef(h,d,T,y),y.toEulerAnglesToRef(Y),Y}}f._V8PerformanceHack=new f(.5,.5,.5),f._UpReadOnly=f.Up(),f._DownReadOnly=f.Down(),f._LeftHandedForwardReadOnly=f.Forward(!1),f._RightHandedForwardReadOnly=f.Forward(!0),f._LeftHandedBackwardReadOnly=f.Backward(!1),f._RightHandedBackwardReadOnly=f.Backward(!0),f._RightReadOnly=f.Right(),f._LeftReadOnly=f.Left(),f._ZeroReadOnly=f.Zero(),f._OneReadOnly=f.One(),Object.defineProperties(f.prototype,{dimension:{value:[3]},rank:{value:1}});class J{get x(){return this._x}set x(h){this._x=h,this._isDirty=!0}get y(){return this._y}set y(h){this._y=h,this._isDirty=!0}get z(){return this._z}set z(h){this._z=h,this._isDirty=!0}get w(){return this._w}set w(h){this._w=h,this._isDirty=!0}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=h,this._y=d,this._z=T,this._w=Y}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let h=c(this._x);return h=397*h^c(this._y),h=397*h^c(this._z),h=397*h^c(this._w),h}ad(){return[this._x,this._y,this._z,this._w]}toArray(h,d){return void 0===d&&(d=0),h[d]=this._x,h[d+1]=this._y,h[d+2]=this._z,h[d+3]=this._w,this}vT(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return J.FromArrayToRef(h,d,this),this}addInPlace(h){return this.x+=h._x,this.y+=h._y,this.z+=h._z,this.w+=h._w,this}addInPlaceFromFloats(h,d,T,Y){return this.x+=h,this.y+=d,this.z+=T,this.w+=Y,this}add(h){return new J(this._x+h.x,this._y+h.y,this._z+h.z,this._w+h.w)}addToRef(h,d){return d.x=this._x+h.x,d.y=this._y+h.y,d.z=this._z+h.z,d.w=this._w+h.w,d}rS(h){return this.x-=h.x,this.y-=h.y,this.z-=h.z,this.w-=h.w,this}Nd(h){return new J(this._x-h.x,this._y-h.y,this._z-h.z,this._w-h.w)}subtractToRef(h,d){return d.x=this._x-h.x,d.y=this._y-h.y,d.z=this._z-h.z,d.w=this._w-h.w,d}subtractFromFloats(h,d,T,Y){return new J(this._x-h,this._y-d,this._z-T,this._w-Y)}subtractFromFloatsToRef(h,d,T,Y,y){return y.x=this._x-h,y.y=this._y-d,y.z=this._z-T,y.w=this._w-Y,y}negate(){return new J(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(h){return h.x=-this._x,h.y=-this._y,h.z=-this._z,h.w=-this._w,h}scaleInPlace(h){return this.x*=h,this.y*=h,this.z*=h,this.w*=h,this}scale(h){return new J(this._x*h,this._y*h,this._z*h,this._w*h)}scaleToRef(h,d){return d.x=this._x*h,d.y=this._y*h,d.z=this._z*h,d.w=this._w*h,d}scaleAndAddToRef(h,d){return d.x+=this._x*h,d.y+=this._y*h,d.z+=this._z*h,d.w+=this._w*h,d}equals(h){return h&&this._x===h.x&&this._y===h.y&&this._z===h.z&&this._w===h.w}equalsWithEpsilon(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Y.d;return h&&(0,F.WithinEpsilon)(this._x,h.x,d)&&(0,F.WithinEpsilon)(this._y,h.y,d)&&(0,F.WithinEpsilon)(this._z,h.z,d)&&(0,F.WithinEpsilon)(this._w,h.w,d)}equalsToFloats(h,d,T,Y){return this._x===h&&this._y===d&&this._z===T&&this._w===Y}multiplyInPlace(h){return this.x*=h.x,this.y*=h.y,this.z*=h.z,this.w*=h.w,this}multiply(h){return new J(this._x*h.x,this._y*h.y,this._z*h.z,this._w*h.w)}multiplyToRef(h,d){return d.x=this._x*h.x,d.y=this._y*h.y,d.z=this._z*h.z,d.w=this._w*h.w,d}multiplyByFloats(h,d,T,Y){return new J(this._x*h,this._y*d,this._z*T,this._w*Y)}divide(h){return new J(this._x/h.x,this._y/h.y,this._z/h.z,this._w/h.w)}divideToRef(h,d){return d.x=this._x/h.x,d.y=this._y/h.y,d.z=this._z/h.z,d.w=this._w/h.w,d}divideInPlace(h){return this.divideToRef(h,this)}minimizeInPlace(h){return h.x<this._x&&(this.x=h.x),h.y<this._y&&(this.y=h.y),h.z<this._z&&(this.z=h.z),h.w<this._w&&(this.w=h.w),this}maximizeInPlace(h){return h.x>this._x&&(this.x=h.x),h.y>this._y&&(this.y=h.y),h.z>this._z&&(this.z=h.z),h.w>this._w&&(this.w=h.w),this}minimizeInPlaceFromFloats(h,d,T,Y){return this.x=Math.min(h,this._x),this.y=Math.min(d,this._y),this.z=Math.min(T,this._z),this.w=Math.min(Y,this._w),this}maximizeInPlaceFromFloats(h,d,T,Y){return this.x=Math.max(h,this._x),this.y=Math.max(d,this._y),this.z=Math.max(T,this._z),this.w=Math.max(Y,this._w),this}floorToRef(h){return h.x=Math.floor(this._x),h.y=Math.floor(this._y),h.z=Math.floor(this._z),h.w=Math.floor(this._w),h}floor(){return new J(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(h){return h.x=this._x-Math.floor(this._x),h.y=this._y-Math.floor(this._y),h.z=this._z-Math.floor(this._z),h.w=this._w-Math.floor(this._w),h}fract(){return new J(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){return this.normalizeToRef(new J)}normalizeToRef(h){const d=this.length();return 0===d||1===d?(h.x=this._x,h.y=this._y,h.z=this._z,h.w=this._w,h):this.scaleToRef(1/d,h)}toVector3(){return new f(this._x,this._y,this._z)}clone(){return new J(this._x,this._y,this._z,this._w)}C(h){return this.x=h.x,this.y=h.y,this.z=h.z,this.w=h.w,this}ny(h,d,T,Y){return this.x=h,this.y=d,this.z=T,this.w=Y,this}set(h,d,T,Y){return this.ny(h,d,T,Y)}XC(h){return this.x=this.y=this.z=this.w=h,this}dot(h){return this._x*h.x+this._y*h.y+this._z*h.z+this._w*h.w}static Bd(h,d){return d||(d=0),new J(h[d],h[d+1],h[d+2],h[d+3])}static FromArrayToRef(h,d,T){return T.x=h[d],T.y=h[d+1],T.z=h[d+2],T.w=h[d+3],T}static FromFloatArrayToRef(h,d,T){return J.FromArrayToRef(h,d,T),T}static FromFloatsToRef(h,d,T,Y,y){return y.x=h,y.y=d,y.z=T,y.w=Y,y}static Zero(){return new J(0,0,0,0)}static One(){return new J(1,1,1,1)}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new J((0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,T=arguments.length>2?arguments[2]:void 0;return T.x=(0,F.RandomRange)(h,d),T.y=(0,F.RandomRange)(h,d),T.z=(0,F.RandomRange)(h,d),T.w=(0,F.RandomRange)(h,d),T}static Clamp(h,d,T){return J.ClampToRef(h,d,T,new J)}static ClampToRef(h,d,T,Y){return Y.x=(0,F.Clamp)(h.x,d.x,T.x),Y.y=(0,F.Clamp)(h.y,d.y,T.y),Y.z=(0,F.Clamp)(h.z,d.z,T.z),Y.w=(0,F.Clamp)(h.w,d.w,T.w),Y}static CheckExtends(h,d,T){d.minimizeInPlace(h),T.maximizeInPlace(h)}static get ZeroReadOnly(){return J._ZeroReadOnly}static Normalize(h){return J.NormalizeToRef(h,new J)}static NormalizeToRef(h,d){return h.normalizeToRef(d),d}static Minimize(h,d){const T=new J;return T.C(h),T.minimizeInPlace(d),T}static Maximize(h,d){const T=new J;return T.C(h),T.maximizeInPlace(d),T}static Distance(h,d){return Math.sqrt(J.DistanceSquared(h,d))}static DistanceSquared(h,d){const T=h.x-d.x,Y=h.y-d.y,y=h.z-d.z,C=h.w-d.w;return T*T+Y*Y+y*y+C*C}static Center(h,d){return J.CenterToRef(h,d,new J)}static CenterToRef(h,d,T){return T.x=(h.x+d.x)/2,T.y=(h.y+d.y)/2,T.z=(h.z+d.z)/2,T.w=(h.w+d.w)/2,T}static TransformCoordinates(h,d){return J.TransformCoordinatesToRef(h,d,new J)}static TransformCoordinatesToRef(h,d,T){return J.TransformCoordinatesFromFloatsToRef(h._x,h._y,h._z,d,T),T}static TransformCoordinatesFromFloatsToRef(h,d,T,Y,y){const C=Y.m,n=h*C[0]+d*C[4]+T*C[8]+C[12],X=h*C[1]+d*C[5]+T*C[9]+C[13],F=h*C[2]+d*C[6]+T*C[10]+C[14],U=h*C[3]+d*C[7]+T*C[11]+C[15];return y.x=n,y.y=X,y.z=F,y.w=U,y}static TransformNormal(h,d){return J.TransformNormalToRef(h,d,new J)}static TransformNormalToRef(h,d,T){const Y=d.m,y=h.x*Y[0]+h.y*Y[4]+h.z*Y[8],C=h.x*Y[1]+h.y*Y[5]+h.z*Y[9],n=h.x*Y[2]+h.y*Y[6]+h.z*Y[10];return T.x=y,T.y=C,T.z=n,T.w=h.w,T}static TransformNormalFromFloatsToRef(h,d,T,Y,y,C){const n=y.m;return C.x=h*n[0]+d*n[4]+T*n[8],C.y=h*n[1]+d*n[5]+T*n[9],C.z=h*n[2]+d*n[6]+T*n[10],C.w=Y,C}static FromVector3(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new J(h._x,h._y,h._z,d)}static Dot(h,d){return h.x*d.x+h.y*d.y+h.z*d.z+h.w*d.w}}J._V8PerformanceHack=new J(.5,.5,.5,.5),J._ZeroReadOnly=J.Zero(),Object.defineProperties(J.prototype,{dimension:{value:[4]},rank:{value:1}});class W{get x(){return this._x}set x(h){this._x=h,this._isDirty=!0}get y(){return this._y}set y(h){this._y=h,this._isDirty=!0}get z(){return this._z}set z(h){this._z=h,this._isDirty=!0}get w(){return this._w}set w(h){this._w=h,this._isDirty=!0}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=h,this._y=d,this._z=T,this._w=Y}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let h=c(this._x);return h=397*h^c(this._y),h=397*h^c(this._z),h=397*h^c(this._w),h}ad(){return[this._x,this._y,this._z,this._w]}toArray(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[d]=this._x,h[d+1]=this._y,h[d+2]=this._z,h[d+3]=this._w,this}vT(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return W.FromArrayToRef(h,d,this)}equals(h){return h&&this._x===h._x&&this._y===h._y&&this._z===h._z&&this._w===h._w}equalsWithEpsilon(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Y.d;return h&&(0,F.WithinEpsilon)(this._x,h._x,d)&&(0,F.WithinEpsilon)(this._y,h._y,d)&&(0,F.WithinEpsilon)(this._z,h._z,d)&&(0,F.WithinEpsilon)(this._w,h._w,d)}isApprox(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Y.d;return h&&((0,F.WithinEpsilon)(this._x,h._x,d)&&(0,F.WithinEpsilon)(this._y,h._y,d)&&(0,F.WithinEpsilon)(this._z,h._z,d)&&(0,F.WithinEpsilon)(this._w,h._w,d)||(0,F.WithinEpsilon)(this._x,-h._x,d)&&(0,F.WithinEpsilon)(this._y,-h._y,d)&&(0,F.WithinEpsilon)(this._z,-h._z,d)&&(0,F.WithinEpsilon)(this._w,-h._w,d))}clone(){return new W(this._x,this._y,this._z,this._w)}C(h){return this._x=h._x,this._y=h._y,this._z=h._z,this._w=h._w,this._isDirty=!0,this}ny(h,d,T,Y){return this._x=h,this._y=d,this._z=T,this._w=Y,this._isDirty=!0,this}set(h,d,T,Y){return this.ny(h,d,T,Y)}XC(h){return this.ny(h,h,h,h)}add(h){return new W(this._x+h._x,this._y+h._y,this._z+h._z,this._w+h._w)}addInPlace(h){return this._x+=h._x,this._y+=h._y,this._z+=h._z,this._w+=h._w,this._isDirty=!0,this}addToRef(h,d){return d._x=this._x+h._x,d._y=this._y+h._y,d._z=this._z+h._z,d._w=this._w+h._w,d._isDirty=!0,d}addInPlaceFromFloats(h,d,T,Y){return this._x+=h,this._y+=d,this._z+=T,this._w+=Y,this._isDirty=!0,this}subtractToRef(h,d){return d._x=this._x-h._x,d._y=this._y-h._y,d._z=this._z-h._z,d._w=this._w-h._w,d._isDirty=!0,d}subtractFromFloats(h,d,T,Y){return this.subtractFromFloatsToRef(h,d,T,Y,new W)}subtractFromFloatsToRef(h,d,T,Y,y){return y._x=this._x-h,y._y=this._y-d,y._z=this._z-T,y._w=this._w-Y,y._isDirty=!0,y}Nd(h){return new W(this._x-h._x,this._y-h._y,this._z-h._z,this._w-h._w)}rS(h){return this._x-=h._x,this._y-=h._y,this._z-=h._z,this._w-=h._w,this._isDirty=!0,this}scale(h){return new W(this._x*h,this._y*h,this._z*h,this._w*h)}scaleToRef(h,d){return d._x=this._x*h,d._y=this._y*h,d._z=this._z*h,d._w=this._w*h,d._isDirty=!0,d}scaleInPlace(h){return this._x*=h,this._y*=h,this._z*=h,this._w*=h,this._isDirty=!0,this}scaleAndAddToRef(h,d){return d._x+=this._x*h,d._y+=this._y*h,d._z+=this._z*h,d._w+=this._w*h,d._isDirty=!0,d}multiply(h){const d=new W(0,0,0,1);return this.multiplyToRef(h,d),d}multiplyToRef(h,d){const T=this._x*h._w+this._y*h._z-this._z*h._y+this._w*h._x,Y=-this._x*h._z+this._y*h._w+this._z*h._x+this._w*h._y,y=this._x*h._y-this._y*h._x+this._z*h._w+this._w*h._z,C=-this._x*h._x-this._y*h._y-this._z*h._z+this._w*h._w;return d.ny(T,Y,y,C),d}multiplyInPlace(h){return this.multiplyToRef(h,this)}multiplyByFloats(h,d,T,Y){return this._x*=h,this._y*=d,this._z*=T,this._w*=Y,this._isDirty=!0,this}divide(h){throw new ReferenceError("Can not divide a quaternion")}divideToRef(h,d){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(h){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new W)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(h){return h._x=-this._x,h._y=-this._y,h._z=-this._z,h._w=-this._w,h._isDirty=!0,h}equalsToFloats(h,d,T,Y){return this._x===h&&this._y===d&&this._z===T&&this._w===Y}floorToRef(h){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(h){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(h){return h.ny(-this._x,-this._y,-this._z,this._w),h}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new W(-this._x,-this._y,-this._z,this._w)}invert(){const h=this.conjugate(),d=this.lengthSquared();return 0==d||1==d||h.scaleInPlace(1/d),h}invertInPlace(){this.conjugateInPlace();const h=this.lengthSquared();return 0==h||1==h||this.scaleInPlace(1/h),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(h){return 0===h||1===h?this:this.scaleInPlace(1/h)}normalizeToNew(){const h=new W(0,0,0,1);return this.normalizeToRef(h),h}normalizeToRef(h){const d=this.length();return 0===d||1===d?h.ny(this._x,this._y,this._z,this._w):this.scaleToRef(1/d,h)}toEulerAngles(){const h=f.Zero();return this.toEulerAnglesToRef(h),h}toEulerAnglesToRef(h){const d=this._z,T=this._x,Y=this._y,y=this._w,C=Y*d-T*y,n=.4999999;if(C<-n)h._y=2*Math.atan2(Y,y),h._x=Math.PI/2,h._z=0,h._isDirty=!0;else if(C>n)h._y=2*Math.atan2(Y,y),h._x=-Math.PI/2,h._z=0,h._isDirty=!0;else{const n=y*y,X=d*d,F=T*T,U=Y*Y;h._z=Math.atan2(2*(T*Y+d*y),-X-F+U+n),h._x=Math.asin(-2*C),h._y=Math.atan2(2*(d*T+Y*y),X-F-U+n),h._isDirty=!0}return h}toAlphaBetaGammaToRef(h){const d=this._z,T=this._x,Y=this._y,y=this._w,C=Math.sqrt(T*T+Y*Y),n=Math.sqrt(d*d+y*y),X=2*Math.atan2(C,n),F=2*Math.atan2(d,y),U=2*Math.atan2(Y,T),Z=(F+U)/2,S=(F-U)/2;return h.set(S,X,Z),h}toRotationMatrix(h){return L.FromQuaternionToRef(this,h),h}fromRotationMatrix(h){return W.FromRotationMatrixToRef(h,this),this}dot(h){return this._x*h._x+this._y*h._y+this._z*h._z+this._w*h._w}toAxisAngle(){const h=f.Zero();return{axis:h,angle:this.toAxisAngleToRef(h)}}toAxisAngleToRef(h){let d=0;const T=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),Y=this._w;return T>0?(d=2*Math.atan2(T,Y),h.set(this._x/T,this._y/T,this._z/T)):(d=0,h.set(1,0,0)),d}static FromRotationMatrix(h){const d=new W;return W.FromRotationMatrixToRef(h,d),d}static FromRotationMatrixToRef(h,d){const T=h.m,Y=T[0],y=T[4],C=T[8],n=T[1],X=T[5],F=T[9],U=T[2],Z=T[6],S=T[10],r=Y+X+S;let c;return r>0?(c=.5/Math.sqrt(r+1),d._w=.25/c,d._x=(Z-F)*c,d._y=(C-U)*c,d._z=(n-y)*c,d._isDirty=!0):Y>X&&Y>S?(c=2*Math.sqrt(1+Y-X-S),d._w=(Z-F)/c,d._x=.25*c,d._y=(y+n)/c,d._z=(C+U)/c,d._isDirty=!0):X>S?(c=2*Math.sqrt(1+X-Y-S),d._w=(C-U)/c,d._x=(y+n)/c,d._y=.25*c,d._z=(F+Z)/c,d._isDirty=!0):(c=2*Math.sqrt(1+S-Y-X),d._w=(n-y)/c,d._x=(C+U)/c,d._y=(F+Z)/c,d._z=.25*c,d._isDirty=!0),d}static Dot(h,d){return h._x*d._x+h._y*d._y+h._z*d._z+h._w*d._w}static AreClose(h,d){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const Y=W.Dot(h,d);return 1-Y*Y<=T}static SmoothToRef(h,d,T,Y,y){let C=0===Y?1:T/Y;return C=(0,F.Clamp)(C,0,1),W.SlerpToRef(h,d,C,y),y}static Zero(){return new W(0,0,0,0)}static Inverse(h){return new W(-h._x,-h._y,-h._z,h._w)}static InverseToRef(h,d){return d.set(-h._x,-h._y,-h._z,h._w),d}static Identity(){return new W(0,0,0,1)}static IsIdentity(h){return h&&0===h._x&&0===h._y&&0===h._z&&1===h._w}static RotationAxis(h,d){return W.RotationAxisToRef(h,d,new W)}static RotationAxisToRef(h,d,T){T._w=Math.cos(d/2);const Y=Math.sin(d/2)/h.length();return T._x=h._x*Y,T._y=h._y*Y,T._z=h._z*Y,T._isDirty=!0,T}static Bd(h,d){return d||(d=0),new W(h[d],h[d+1],h[d+2],h[d+3])}static FromArrayToRef(h,d,T){return T._x=h[d],T._y=h[d+1],T._z=h[d+2],T._w=h[d+3],T._isDirty=!0,T}static FromFloatsToRef(h,d,T,Y,y){return y.ny(h,d,T,Y),y}static FromEulerAngles(h,d,T){const Y=new W;return W.RotationYawPitchRollToRef(d,h,T,Y),Y}static FromEulerAnglesToRef(h,d,T,Y){return W.RotationYawPitchRollToRef(d,h,T,Y),Y}static FromEulerVector(h){const d=new W;return W.RotationYawPitchRollToRef(h._y,h._x,h._z,d),d}static FromEulerVectorToRef(h,d){return W.RotationYawPitchRollToRef(h._y,h._x,h._z,d),d}static FromUnitVectorsToRef(h,d,T){let y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Y.d;const C=f.Dot(h,d)+1;return C<y?Math.abs(h.x)>Math.abs(h.z)?T.set(-h.y,h.x,0,0):T.set(0,-h.z,h.y,0):(f.CrossToRef(h,d,V.pd[0]),T.set(V.pd[0].x,V.pd[0].y,V.pd[0].z,C)),T.normalize()}static RotationYawPitchRoll(h,d,T){const Y=new W;return W.RotationYawPitchRollToRef(h,d,T,Y),Y}static RotationYawPitchRollToRef(h,d,T,Y){const y=.5*T,C=.5*d,n=.5*h,X=Math.sin(y),F=Math.cos(y),U=Math.sin(C),Z=Math.cos(C),S=Math.sin(n),r=Math.cos(n);return Y._x=r*U*F+S*Z*X,Y._y=S*Z*F-r*U*X,Y._z=r*Z*X-S*U*F,Y._w=r*Z*F+S*U*X,Y._isDirty=!0,Y}static RotationAlphaBetaGamma(h,d,T){const Y=new W;return W.RotationAlphaBetaGammaToRef(h,d,T,Y),Y}static RotationAlphaBetaGammaToRef(h,d,T,Y){const y=.5*(T+h),C=.5*(T-h),n=.5*d;return Y._x=Math.cos(C)*Math.sin(n),Y._y=Math.sin(C)*Math.sin(n),Y._z=Math.sin(y)*Math.cos(n),Y._w=Math.cos(y)*Math.cos(n),Y._isDirty=!0,Y}static RotationQuaternionFromAxis(h,d,T){const Y=new W(0,0,0,0);return W.RotationQuaternionFromAxisToRef(h,d,T,Y),Y}static RotationQuaternionFromAxisToRef(h,d,T,Y){const y=D.Matrix[0];return h=h.normalizeToRef(D.pd[0]),d=d.normalizeToRef(D.pd[1]),T=T.normalizeToRef(D.pd[2]),L.FromXYZAxesToRef(h,d,T,y),W.FromRotationMatrixToRef(y,Y),Y}static FromLookDirectionLH(h,d){const T=new W;return W.FromLookDirectionLHToRef(h,d,T),T}static FromLookDirectionLHToRef(h,d,T){const Y=D.Matrix[0];return L.LookDirectionLHToRef(h,d,Y),W.FromRotationMatrixToRef(Y,T),T}static FromLookDirectionRH(h,d){const T=new W;return W.FromLookDirectionRHToRef(h,d,T),T}static FromLookDirectionRHToRef(h,d,T){const Y=D.Matrix[0];return L.LookDirectionRHToRef(h,d,Y),W.FromRotationMatrixToRef(Y,T)}static Slerp(h,d,T){const Y=W.Identity();return W.SlerpToRef(h,d,T,Y),Y}static SlerpToRef(h,d,T,Y){let y,C,n=h._x*d._x+h._y*d._y+h._z*d._z+h._w*d._w,X=!1;if(n<0&&(X=!0,n=-n),n>.999999)C=1-T,y=X?-T:T;else{const h=Math.acos(n),d=1/Math.sin(h);C=Math.sin((1-T)*h)*d,y=X?-Math.sin(T*h)*d:Math.sin(T*h)*d}return Y._x=C*h._x+y*d._x,Y._y=C*h._y+y*d._y,Y._z=C*h._z+y*d._z,Y._w=C*h._w+y*d._w,Y._isDirty=!0,Y}static Hermite(h,d,T,Y,y){const C=y*y,n=y*C,X=2*n-3*C+1,F=-2*n+3*C,U=n-2*C+y,Z=n-C,S=h._x*X+T._x*F+d._x*U+Y._x*Z,r=h._y*X+T._y*F+d._y*U+Y._y*Z,c=h._z*X+T._z*F+d._z*U+Y._z*Z,O=h._w*X+T._w*F+d._w*U+Y._w*Z;return new W(S,r,c,O)}static Hermite1stDerivative(h,d,T,Y,y){const C=new W;return this.Hermite1stDerivativeToRef(h,d,T,Y,y,C),C}static Hermite1stDerivativeToRef(h,d,T,Y,y,C){const n=y*y;return C._x=6*(n-y)*h._x+(3*n-4*y+1)*d._x+6*(-n+y)*T._x+(3*n-2*y)*Y._x,C._y=6*(n-y)*h._y+(3*n-4*y+1)*d._y+6*(-n+y)*T._y+(3*n-2*y)*Y._y,C._z=6*(n-y)*h._z+(3*n-4*y+1)*d._z+6*(-n+y)*T._z+(3*n-2*y)*Y._z,C._w=6*(n-y)*h._w+(3*n-4*y+1)*d._w+6*(-n+y)*T._w+(3*n-2*y)*Y._w,C._isDirty=!0,C}static Normalize(h){const d=W.Zero();return W.NormalizeToRef(h,d),d}static NormalizeToRef(h,d){return h.normalizeToRef(d),d}static Clamp(h,d,T){const Y=new W;return W.ClampToRef(h,d,T,Y),Y}static ClampToRef(h,d,T,Y){return Y.ny((0,F.Clamp)(h.x,d.x,T.x),(0,F.Clamp)(h.y,d.y,T.y),(0,F.Clamp)(h.z,d.z,T.z),(0,F.Clamp)(h.w,d.w,T.w))}static Random(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new W((0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d))}static RandomToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).ny((0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d),(0,F.RandomRange)(h,d))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(h,d){return Math.sqrt(W.DistanceSquared(h,d))}static DistanceSquared(h,d){const T=h.x-d.x,Y=h.y-d.y,y=h.z-d.z,C=h.w-d.w;return T*T+Y*Y+y*y+C*C}static Center(h,d){return W.CenterToRef(h,d,W.Zero())}static CenterToRef(h,d,T){return T.ny((h.x+d.x)/2,(h.y+d.y)/2,(h.z+d.z)/2,(h.w+d.w)/2)}}W._V8PerformanceHack=new W(.5,.5,.5,.5),Object.defineProperties(W.prototype,{dimension:{value:[4]},rank:{value:1}});class L{static get Use64Bits(){return n.c.MatrixUse64Bits}get m(){return this.kd}markAsUpdated(){this.updateFlag=U._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(h){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1],T=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Y=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=h,this._isIdentity3x2=h||T,this._isIdentityDirty=!this._isIdentity&&d,this._isIdentity3x2Dirty=!this._isIdentity3x2&&Y}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,n.c.MatrixTrackPrecisionChange&&n.c.MatrixTrackedMatrices.push(this),this.kd=new n.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const h=this.kd;this._isIdentity=1===h[0]&&0===h[1]&&0===h[2]&&0===h[3]&&0===h[4]&&1===h[5]&&0===h[6]&&0===h[7]&&0===h[8]&&0===h[9]&&1===h[10]&&0===h[11]&&0===h[12]&&0===h[13]&&0===h[14]&&1===h[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.kd[0]||1!==this.kd[5]||1!==this.kd[15]||0!==this.kd[1]||0!==this.kd[2]||0!==this.kd[3]||0!==this.kd[4]||0!==this.kd[6]||0!==this.kd[7]||0!==this.kd[8]||0!==this.kd[9]||0!==this.kd[10]||0!==this.kd[11]||0!==this.kd[12]||0!==this.kd[13]||0!==this.kd[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const h=this.kd,d=h[0],T=h[1],Y=h[2],y=h[3],C=h[4],n=h[5],X=h[6],F=h[7],U=h[8],Z=h[9],S=h[10],r=h[11],c=h[12],O=h[13],f=h[14],J=h[15],W=S*J-f*r,L=Z*J-O*r,D=Z*f-O*S,V=U*J-c*r,i=U*f-S*c,w=U*O-c*Z;return d*+(n*W-X*L+F*D)+T*-(C*W-X*V+F*i)+Y*+(C*L-n*V+F*w)+y*-(C*D-n*i+X*w)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!h)return this.kd;const T=this.kd;for(let Y=0;Y<16;Y++)h[d+Y]=T[Y];return this}ad(){return this.kd}vT(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(h,d,this)}ny(){for(var h=arguments.length,d=new Array(h),T=0;T<h;T++)d[T]=arguments[T];return L.FromArrayToRef(d,0,this)}set(){const h=this.kd;for(let d=0;d<16;d++)h[d]=d<0||arguments.length<=d?void 0:arguments[d];return this.markAsUpdated(),this}XC(h){const d=this.kd;for(let T=0;T<16;T++)d[T]=h;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return L.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(h){const d=new L;return this.addToRef(h,d),d}addToRef(h,d){const T=this.kd,Y=d.kd,y=h.m;for(let C=0;C<16;C++)Y[C]=T[C]+y[C];return d.markAsUpdated(),d}addToSelf(h){const d=this.kd,T=h.m;return d[0]+=T[0],d[1]+=T[1],d[2]+=T[2],d[3]+=T[3],d[4]+=T[4],d[5]+=T[5],d[6]+=T[6],d[7]+=T[7],d[8]+=T[8],d[9]+=T[9],d[10]+=T[10],d[11]+=T[11],d[12]+=T[12],d[13]+=T[13],d[14]+=T[14],d[15]+=T[15],this.markAsUpdated(),this}addInPlace(h){const d=this.kd,T=h.m;for(let Y=0;Y<16;Y++)d[Y]+=T[Y];return this.markAsUpdated(),this}addInPlaceFromFloats(){const h=this.kd;for(let d=0;d<16;d++)h[d]+=d<0||arguments.length<=d?void 0:arguments[d];return this.markAsUpdated(),this}Nd(h){const d=this.kd,T=h.m;for(let Y=0;Y<16;Y++)d[Y]-=T[Y];return this.markAsUpdated(),this}subtractToRef(h,d){const T=this.kd,Y=h.m,y=d.kd;for(let C=0;C<16;C++)y[C]=T[C]-Y[C];return d.markAsUpdated(),d}rS(h){const d=this.kd,T=h.m;for(let Y=0;Y<16;Y++)d[Y]-=T[Y];return this.markAsUpdated(),this}subtractFromFloats(){for(var h=arguments.length,d=new Array(h),T=0;T<h;T++)d[T]=arguments[T];return this.subtractFromFloatsToRef(...d,new L)}subtractFromFloatsToRef(){for(var h=arguments.length,d=new Array(h),T=0;T<h;T++)d[T]=arguments[T];const Y=d.pop(),y=this.kd,C=Y.kd,n=d;for(let X=0;X<16;X++)C[X]=y[X]-n[X];return Y.markAsUpdated(),Y}invertToRef(h){return!0===this._isIdentity?(L.IdentityToRef(h),h):(r(this,h.ad())?h.markAsUpdated():h.C(this),h)}addAtIndex(h,d){return this.kd[h]+=d,this.markAsUpdated(),this}multiplyAtIndex(h,d){return this.kd[h]*=d,this.markAsUpdated(),this}setTranslationFromFloats(h,d,T){return this.kd[12]=h,this.kd[13]=d,this.kd[14]=T,this.markAsUpdated(),this}addTranslationFromFloats(h,d,T){return this.kd[12]+=h,this.kd[13]+=d,this.kd[14]+=T,this.markAsUpdated(),this}setTranslation(h){return this.setTranslationFromFloats(h._x,h._y,h._z)}getTranslation(){return new f(this.kd[12],this.kd[13],this.kd[14])}getTranslationToRef(h){return h.x=this.kd[12],h.y=this.kd[13],h.z=this.kd[14],h}removeRotationAndScaling(){const h=this.m;return L.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,h[12],h[13],h[14],h[15],this),this._updateIdentityStatus(0===h[12]&&0===h[13]&&0===h[14]&&1===h[15]),this}C(h){h.copyToArray(this.kd);const d=h;return this.updateFlag=d.updateFlag,this._updateIdentityStatus(d._isIdentity,d._isIdentityDirty,d._isIdentity3x2,d._isIdentity3x2Dirty),this}copyToArray(h){return S(this,h,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(h){const d=new L;return this.multiplyToRef(h,d),d}multiplyInPlace(h){const d=this.kd,T=h.m;for(let Y=0;Y<16;Y++)d[Y]*=T[Y];return this.markAsUpdated(),this}multiplyByFloats(){const h=this.kd;for(let d=0;d<16;d++)h[d]*=d<0||arguments.length<=d?void 0:arguments[d];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var h=arguments.length,d=new Array(h),T=0;T<h;T++)d[T]=arguments[T];const Y=d.pop(),y=this.kd,C=Y.kd,n=d;for(let X=0;X<16;X++)C[X]=y[X]*n[X];return Y.markAsUpdated(),Y}multiplyToRef(h,d){return this._isIdentity?(d.C(h),d):h._isIdentity?(d.C(this),d):(this.multiplyToArray(h,d.kd,0),d.markAsUpdated(),d)}multiplyToArray(h,d,T){return Z(this,h,d,T),this}divide(h){return this.divideToRef(h,new L)}divideToRef(h,d){const T=this.kd,Y=h.m,y=d.kd;for(let C=0;C<16;C++)y[C]=T[C]/Y[C];return d.markAsUpdated(),d}divideInPlace(h){const d=this.kd,T=h.m;for(let Y=0;Y<16;Y++)d[Y]/=T[Y];return this.markAsUpdated(),this}minimizeInPlace(h){const d=this.kd,T=h.m;for(let Y=0;Y<16;Y++)d[Y]=Math.min(d[Y],T[Y]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const h=this.kd;for(let d=0;d<16;d++)h[d]=Math.min(h[d],d<0||arguments.length<=d?void 0:arguments[d]);return this.markAsUpdated(),this}maximizeInPlace(h){const d=this.kd,T=h.m;for(let Y=0;Y<16;Y++)d[Y]=Math.min(d[Y],T[Y]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const h=this.kd;for(let d=0;d<16;d++)h[d]=Math.min(h[d],d<0||arguments.length<=d?void 0:arguments[d]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new L)}negateInPlace(){const h=this.kd;for(let d=0;d<16;d++)h[d]=-h[d];return this.markAsUpdated(),this}negateToRef(h){const d=this.kd,T=h.kd;for(let Y=0;Y<16;Y++)T[Y]=-d[Y];return h.markAsUpdated(),h}equals(h){const d=h;if(!d)return!1;if((this._isIdentity||d._isIdentity)&&!this._isIdentityDirty&&!d._isIdentityDirty)return this._isIdentity&&d._isIdentity;const T=this.m,Y=d.m;return T[0]===Y[0]&&T[1]===Y[1]&&T[2]===Y[2]&&T[3]===Y[3]&&T[4]===Y[4]&&T[5]===Y[5]&&T[6]===Y[6]&&T[7]===Y[7]&&T[8]===Y[8]&&T[9]===Y[9]&&T[10]===Y[10]&&T[11]===Y[11]&&T[12]===Y[12]&&T[13]===Y[13]&&T[14]===Y[14]&&T[15]===Y[15]}equalsWithEpsilon(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const T=this.kd,Y=h.m;for(let y=0;y<16;y++)if(!(0,F.WithinEpsilon)(T[y],Y[y],d))return!1;return!0}equalsToFloats(){const h=this.kd;for(let d=0;d<16;d++)if(h[d]!=(d<0||arguments.length<=d?void 0:arguments[d]))return!1;return!0}floor(){return this.floorToRef(new L)}floorToRef(h){const d=this.kd,T=h.kd;for(let Y=0;Y<16;Y++)T[Y]=Math.floor(d[Y]);return h.markAsUpdated(),h}fract(){return this.fractToRef(new L)}fractToRef(h){const d=this.kd,T=h.kd;for(let Y=0;Y<16;Y++)T[Y]=d[Y]-Math.floor(d[Y]);return h.markAsUpdated(),h}clone(){const h=new L;return h.C(this),h}getClassName(){return"Matrix"}getHashCode(){let h=c(this.kd[0]);for(let d=1;d<16;d++)h=397*h^c(this.kd[d]);return h}decomposeToTransformNode(h){return h.rotationQuaternion=h.rotationQuaternion||new W,this.decompose(h.py,h.rotationQuaternion,h.position)}decompose(h,d,T,Y){let y=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return T&&T.XC(0),h&&h.XC(1),d&&d.ny(0,0,0,1),!0;const C=this.kd;if(T&&T.ny(C[12],C[13],C[14]),(h=h||D.pd[0]).x=Math.sqrt(C[0]*C[0]+C[1]*C[1]+C[2]*C[2]),h.y=Math.sqrt(C[4]*C[4]+C[5]*C[5]+C[6]*C[6]),h.z=Math.sqrt(C[8]*C[8]+C[9]*C[9]+C[10]*C[10]),Y){const d=(y?Y.absoluteScaling.x:Y.py.x)<0?-1:1,T=(y?Y.absoluteScaling.y:Y.py.y)<0?-1:1,C=(y?Y.absoluteScaling.z:Y.py.z)<0?-1:1;h.x*=d,h.y*=T,h.z*=C}else this.determinant()<=0&&(h.y*=-1);if(0===h._x||0===h._y||0===h._z)return d&&d.ny(0,0,0,1),!1;if(d){const T=1/h._x,Y=1/h._y,y=1/h._z;L.FromValuesToRef(C[0]*T,C[1]*T,C[2]*T,0,C[4]*Y,C[5]*Y,C[6]*Y,0,C[8]*y,C[9]*y,C[10]*y,0,0,0,0,1,D.Matrix[0]),W.FromRotationMatrixToRef(D.Matrix[0],d)}return!0}getRow(h){if(h<0||h>3)return null;const d=4*h;return new J(this.kd[d+0],this.kd[d+1],this.kd[d+2],this.kd[d+3])}getRowToRef(h,d){if(h>=0&&h<=3){const T=4*h;d.x=this.kd[T+0],d.y=this.kd[T+1],d.z=this.kd[T+2],d.w=this.kd[T+3]}return d}setRow(h,d){return this.setRowFromFloats(h,d.x,d.y,d.z,d.w)}transpose(){const h=new L;return L.TransposeToRef(this,h),h}transposeToRef(h){return L.TransposeToRef(this,h),h}setRowFromFloats(h,d,T,Y,y){if(h<0||h>3)return this;const C=4*h;return this.kd[C+0]=d,this.kd[C+1]=T,this.kd[C+2]=Y,this.kd[C+3]=y,this.markAsUpdated(),this}scale(h){const d=new L;return this.scaleToRef(h,d),d}scaleToRef(h,d){for(let T=0;T<16;T++)d.kd[T]=this.kd[T]*h;return d.markAsUpdated(),d}scaleAndAddToRef(h,d){for(let T=0;T<16;T++)d.kd[T]+=this.kd[T]*h;return d.markAsUpdated(),d}scaleInPlace(h){const d=this.kd;for(let T=0;T<16;T++)d[T]*=h;return this.markAsUpdated(),this}toNormalMatrix(h){const d=D.Matrix[0];this.invertToRef(d),d.transposeToRef(h);const T=h.kd;return L.FromValuesToRef(T[0],T[1],T[2],0,T[4],T[5],T[6],0,T[8],T[9],T[10],0,0,0,0,1,h),h}getRotationMatrix(){const h=new L;return this.getRotationMatrixToRef(h),h}getRotationMatrixToRef(h){const d=D.pd[0];if(!this.decompose(d))return L.IdentityToRef(h),h;const T=this.kd,Y=1/d._x,y=1/d._y,C=1/d._z;return L.FromValuesToRef(T[0]*Y,T[1]*Y,T[2]*Y,0,T[4]*y,T[5]*y,T[6]*y,0,T[8]*C,T[9]*C,T[10]*C,0,0,0,0,1,h),h}toggleModelMatrixHandInPlace(){const h=this.kd;return h[2]*=-1,h[6]*=-1,h[8]*=-1,h[9]*=-1,h[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const h=this.kd;return h[8]*=-1,h[9]*=-1,h[10]*=-1,h[11]*=-1,this.markAsUpdated(),this}static Bd(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const T=new L;return L.FromArrayToRef(h,d,T),T}static FromArrayToRef(h,d,T){for(let Y=0;Y<16;Y++)T.kd[Y]=h[Y+d];return T.markAsUpdated(),T}static FromFloat32ArrayToRefScaled(h,d,T,Y){return Y.kd[0]=h[0+d]*T,Y.kd[1]=h[1+d]*T,Y.kd[2]=h[2+d]*T,Y.kd[3]=h[3+d]*T,Y.kd[4]=h[4+d]*T,Y.kd[5]=h[5+d]*T,Y.kd[6]=h[6+d]*T,Y.kd[7]=h[7+d]*T,Y.kd[8]=h[8+d]*T,Y.kd[9]=h[9+d]*T,Y.kd[10]=h[10+d]*T,Y.kd[11]=h[11+d]*T,Y.kd[12]=h[12+d]*T,Y.kd[13]=h[13+d]*T,Y.kd[14]=h[14+d]*T,Y.kd[15]=h[15+d]*T,Y.markAsUpdated(),Y}static get IdentityReadOnly(){return L._IdentityReadOnly}static FromValuesToRef(h,d,T,Y,y,C,n,X,F,U,Z,S,r,c,O,f,J){const W=J.kd;W[0]=h,W[1]=d,W[2]=T,W[3]=Y,W[4]=y,W[5]=C,W[6]=n,W[7]=X,W[8]=F,W[9]=U,W[10]=Z,W[11]=S,W[12]=r,W[13]=c,W[14]=O,W[15]=f,J.markAsUpdated()}static FromValues(h,d,T,Y,y,C,n,X,F,U,Z,S,r,c,O,f){const J=new L,W=J.kd;return W[0]=h,W[1]=d,W[2]=T,W[3]=Y,W[4]=y,W[5]=C,W[6]=n,W[7]=X,W[8]=F,W[9]=U,W[10]=Z,W[11]=S,W[12]=r,W[13]=c,W[14]=O,W[15]=f,J.markAsUpdated(),J}static Compose(h,d,T){const Y=new L;return L.ComposeToRef(h,d,T,Y),Y}static ComposeToRef(h,d,T,Y){const y=Y.kd,C=d._x,n=d._y,X=d._z,F=d._w,U=C+C,Z=n+n,S=X+X,r=C*U,c=C*Z,O=C*S,f=n*Z,J=n*S,W=X*S,L=F*U,D=F*Z,V=F*S,i=h._x,w=h._y,s=h._z;return y[0]=(1-(f+W))*i,y[1]=(c+V)*i,y[2]=(O-D)*i,y[3]=0,y[4]=(c-V)*w,y[5]=(1-(r+W))*w,y[6]=(J+L)*w,y[7]=0,y[8]=(O+D)*s,y[9]=(J-L)*s,y[10]=(1-(r+f))*s,y[11]=0,y[12]=T._x,y[13]=T._y,y[14]=T._z,y[15]=1,Y.markAsUpdated(),Y}static Identity(){const h=L.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return h._updateIdentityStatus(!0),h}static IdentityToRef(h){return L.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,h),h._updateIdentityStatus(!0),h}static Zero(){const h=L.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return h._updateIdentityStatus(!1),h}static RotationX(h){const d=new L;return L.RotationXToRef(h,d),d}static Invert(h){const d=new L;return h.invertToRef(d),d}static RotationXToRef(h,d){const T=Math.sin(h),Y=Math.cos(h);return L.FromValuesToRef(1,0,0,0,0,Y,T,0,0,-T,Y,0,0,0,0,1,d),d._updateIdentityStatus(1===Y&&0===T),d}static RotationY(h){const d=new L;return L.RotationYToRef(h,d),d}static RotationYToRef(h,d){const T=Math.sin(h),Y=Math.cos(h);return L.FromValuesToRef(Y,0,-T,0,0,1,0,0,T,0,Y,0,0,0,0,1,d),d._updateIdentityStatus(1===Y&&0===T),d}static RotationZ(h){const d=new L;return L.RotationZToRef(h,d),d}static RotationZToRef(h,d){const T=Math.sin(h),Y=Math.cos(h);return L.FromValuesToRef(Y,T,0,0,-T,Y,0,0,0,0,1,0,0,0,0,1,d),d._updateIdentityStatus(1===Y&&0===T),d}static RotationAxis(h,d){const T=new L;return L.RotationAxisToRef(h,d,T),T}static RotationAxisToRef(h,d,T){const Y=Math.sin(-d),y=Math.cos(-d),C=1-y;h=h.normalizeToRef(D.pd[0]);const n=T.kd;return n[0]=h._x*h._x*C+y,n[1]=h._x*h._y*C-h._z*Y,n[2]=h._x*h._z*C+h._y*Y,n[3]=0,n[4]=h._y*h._x*C+h._z*Y,n[5]=h._y*h._y*C+y,n[6]=h._y*h._z*C-h._x*Y,n[7]=0,n[8]=h._z*h._x*C-h._y*Y,n[9]=h._z*h._y*C+h._x*Y,n[10]=h._z*h._z*C+y,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,T.markAsUpdated(),T}static RotationAlignToRef(h,d,T){let y=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const C=f.Dot(d,h),n=T.kd;if(C<-1+Y.d)n[0]=-1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=y?1:-1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=y?-1:1,n[11]=0;else{const T=f.Cross(d,h),Y=1/(1+C);n[0]=T._x*T._x*Y+C,n[1]=T._y*T._x*Y-T._z,n[2]=T._z*T._x*Y+T._y,n[3]=0,n[4]=T._x*T._y*Y+T._z,n[5]=T._y*T._y*Y+C,n[6]=T._z*T._y*Y-T._x,n[7]=0,n[8]=T._x*T._z*Y-T._y,n[9]=T._y*T._z*Y+T._x,n[10]=T._z*T._z*Y+C,n[11]=0}return n[12]=0,n[13]=0,n[14]=0,n[15]=1,T.markAsUpdated(),T}static RotationYawPitchRoll(h,d,T){const Y=new L;return L.RotationYawPitchRollToRef(h,d,T,Y),Y}static RotationYawPitchRollToRef(h,d,T,Y){return W.RotationYawPitchRollToRef(h,d,T,D.Quaternion[0]),D.Quaternion[0].toRotationMatrix(Y),Y}static Scaling(h,d,T){const Y=new L;return L.ScalingToRef(h,d,T,Y),Y}static ScalingToRef(h,d,T,Y){return L.FromValuesToRef(h,0,0,0,0,d,0,0,0,0,T,0,0,0,0,1,Y),Y._updateIdentityStatus(1===h&&1===d&&1===T),Y}static Translation(h,d,T){const Y=new L;return L.TranslationToRef(h,d,T,Y),Y}static TranslationToRef(h,d,T,Y){return L.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,h,d,T,1,Y),Y._updateIdentityStatus(0===h&&0===d&&0===T),Y}static Lerp(h,d,T){const Y=new L;return L.LerpToRef(h,d,T,Y),Y}static LerpToRef(h,d,T,Y){const y=Y.kd,C=h.m,n=d.m;for(let X=0;X<16;X++)y[X]=C[X]*(1-T)+n[X]*T;return Y.markAsUpdated(),Y}static DecomposeLerp(h,d,T){const Y=new L;return L.DecomposeLerpToRef(h,d,T,Y),Y}static DecomposeLerpToRef(h,d,T,Y){const y=D.pd[0],C=D.Quaternion[0],n=D.pd[1];h.decompose(y,C,n);const X=D.pd[2],F=D.Quaternion[1],U=D.pd[3];d.decompose(X,F,U);const Z=D.pd[4];f.LerpToRef(y,X,T,Z);const S=D.Quaternion[2];W.SlerpToRef(C,F,T,S);const r=D.pd[5];return f.LerpToRef(n,U,T,r),L.ComposeToRef(Z,S,r,Y),Y}static LookAtLH(h,d,T){const Y=new L;return L.LookAtLHToRef(h,d,T,Y),Y}static LookAtLHToRef(h,d,T,Y){const y=D.pd[0],C=D.pd[1],n=D.pd[2];d.subtractToRef(h,n),n.normalize(),f.CrossToRef(T,n,y);const X=y.lengthSquared();0===X?y.x=1:y.normalizeFromLength(Math.sqrt(X)),f.CrossToRef(n,y,C),C.normalize();const F=-f.Dot(y,h),U=-f.Dot(C,h),Z=-f.Dot(n,h);return L.FromValuesToRef(y._x,C._x,n._x,0,y._y,C._y,n._y,0,y._z,C._z,n._z,0,F,U,Z,1,Y),Y}static LookAtRH(h,d,T){const Y=new L;return L.LookAtRHToRef(h,d,T,Y),Y}static LookAtRHToRef(h,d,T,Y){const y=D.pd[0],C=D.pd[1],n=D.pd[2];h.subtractToRef(d,n),n.normalize(),f.CrossToRef(T,n,y);const X=y.lengthSquared();0===X?y.x=1:y.normalizeFromLength(Math.sqrt(X)),f.CrossToRef(n,y,C),C.normalize();const F=-f.Dot(y,h),U=-f.Dot(C,h),Z=-f.Dot(n,h);return L.FromValuesToRef(y._x,C._x,n._x,0,y._y,C._y,n._y,0,y._z,C._z,n._z,0,F,U,Z,1,Y),Y}static LookDirectionLH(h,d){const T=new L;return L.LookDirectionLHToRef(h,d,T),T}static LookDirectionLHToRef(h,d,T){const Y=D.pd[0];Y.C(h),Y.scaleInPlace(-1);const y=D.pd[1];return f.CrossToRef(d,Y,y),L.FromValuesToRef(y._x,y._y,y._z,0,d._x,d._y,d._z,0,Y._x,Y._y,Y._z,0,0,0,0,1,T),T}static LookDirectionRH(h,d){const T=new L;return L.LookDirectionRHToRef(h,d,T),T}static LookDirectionRHToRef(h,d,T){const Y=D.pd[2];return f.CrossToRef(d,h,Y),L.FromValuesToRef(Y._x,Y._y,Y._z,0,d._x,d._y,d._z,0,h._x,h._y,h._z,0,0,0,0,1,T),T}static OrthoLH(h,d,T,Y,y){const C=new L;return L.OrthoLHToRef(h,d,T,Y,C,y),C}static OrthoLHToRef(h,d,T,Y,y,C){const n=2/h,X=2/d,F=2/(Y-T),U=-(Y+T)/(Y-T);return L.FromValuesToRef(n,0,0,0,0,X,0,0,0,0,F,0,0,0,U,1,y),C&&y.multiplyToRef(i,y),y._updateIdentityStatus(1===n&&1===X&&1===F&&0===U),y}static OrthoOffCenterLH(h,d,T,Y,y,C,n){const X=new L;return L.OrthoOffCenterLHToRef(h,d,T,Y,y,C,X,n),X}static OrthoOffCenterLHToRef(h,d,T,Y,y,C,n,X){const F=2/(d-h),U=2/(Y-T),Z=2/(C-y),S=-(C+y)/(C-y),r=(h+d)/(h-d),c=(Y+T)/(T-Y);return L.FromValuesToRef(F,0,0,0,0,U,0,0,0,0,Z,0,r,c,S,1,n),X&&n.multiplyToRef(i,n),n.markAsUpdated(),n}static ObliqueOffCenterLHToRef(h,d,T,Y,y,C,n,X,F,U,Z){const S=-n*Math.cos(X),r=-n*Math.sin(X);return L.TranslationToRef(0,0,-F,D.Matrix[1]),L.FromValuesToRef(1,0,0,0,0,1,0,0,S,r,1,0,0,0,0,1,D.Matrix[0]),D.Matrix[1].multiplyToRef(D.Matrix[0],D.Matrix[0]),L.TranslationToRef(0,0,F,D.Matrix[1]),D.Matrix[0].multiplyToRef(D.Matrix[1],D.Matrix[0]),L.OrthoOffCenterLHToRef(h,d,T,Y,y,C,U,Z),D.Matrix[0].multiplyToRef(U,U),U}static OrthoOffCenterRH(h,d,T,Y,y,C,n){const X=new L;return L.OrthoOffCenterRHToRef(h,d,T,Y,y,C,X,n),X}static OrthoOffCenterRHToRef(h,d,T,Y,y,C,n,X){return L.OrthoOffCenterLHToRef(h,d,T,Y,y,C,n,X),n.kd[10]*=-1,n}static ObliqueOffCenterRHToRef(h,d,T,Y,y,C,n,X,F,U,Z){const S=n*Math.cos(X),r=n*Math.sin(X);return L.TranslationToRef(0,0,F,D.Matrix[1]),L.FromValuesToRef(1,0,0,0,0,1,0,0,S,r,1,0,0,0,0,1,D.Matrix[0]),D.Matrix[1].multiplyToRef(D.Matrix[0],D.Matrix[0]),L.TranslationToRef(0,0,-F,D.Matrix[1]),D.Matrix[0].multiplyToRef(D.Matrix[1],D.Matrix[0]),L.OrthoOffCenterRHToRef(h,d,T,Y,y,C,U,Z),D.Matrix[0].multiplyToRef(U,U),U}static PerspectiveLH(h,d,T,Y,y){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const n=new L,X=2*T/h,F=2*T/d,U=(Y+T)/(Y-T),Z=-2*Y*T/(Y-T),S=Math.tan(C);return L.FromValuesToRef(X,0,0,0,0,F,0,S,0,0,U,1,0,0,Z,0,n),y&&n.multiplyToRef(i,n),n._updateIdentityStatus(!1),n}static PerspectiveFovLH(h,d,T,Y,y){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,n=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const X=new L;return L.PerspectiveFovLHToRef(h,d,T,Y,X,!0,y,C,n),X}static PerspectiveFovLHToRef(h,d,T,Y,y){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],n=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,F=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const U=T,Z=Y,S=1/Math.tan(.5*h),r=C?S/d:S,c=C?S:S*d,O=F&&0===U?-1:0!==Z?(Z+U)/(Z-U):1,f=F&&0===U?2*Z:0!==Z?-2*Z*U/(Z-U):-2*U,J=Math.tan(X);return L.FromValuesToRef(r,0,0,0,0,c,0,J,0,0,O,1,0,0,f,0,y),n&&y.multiplyToRef(i,y),y._updateIdentityStatus(!1),y}static PerspectiveFovReverseLHToRef(h,d,T,Y,y){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],n=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const F=1/Math.tan(.5*h),U=C?F/d:F,Z=C?F:F*d,S=Math.tan(X);return L.FromValuesToRef(U,0,0,0,0,Z,0,S,0,0,-T,1,0,0,1,0,y),n&&y.multiplyToRef(i,y),y._updateIdentityStatus(!1),y}static PerspectiveFovRH(h,d,T,Y,y){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,n=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const X=new L;return L.PerspectiveFovRHToRef(h,d,T,Y,X,!0,y,C,n),X}static PerspectiveFovRHToRef(h,d,T,Y,y){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],n=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,F=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const U=T,Z=Y,S=1/Math.tan(.5*h),r=C?S/d:S,c=C?S:S*d,O=F&&0===U?1:0!==Z?-(Z+U)/(Z-U):-1,f=F&&0===U?2*Z:0!==Z?-2*Z*U/(Z-U):-2*U,J=Math.tan(X);return L.FromValuesToRef(r,0,0,0,0,c,0,J,0,0,O,-1,0,0,f,0,y),n&&y.multiplyToRef(i,y),y._updateIdentityStatus(!1),y}static PerspectiveFovReverseRHToRef(h,d,T,Y,y){let C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],n=arguments.length>6?arguments[6]:void 0,X=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const F=1/Math.tan(.5*h),U=C?F/d:F,Z=C?F:F*d,S=Math.tan(X);return L.FromValuesToRef(U,0,0,0,0,Z,0,S,0,0,-T,-1,0,0,-1,0,y),n&&y.multiplyToRef(i,y),y._updateIdentityStatus(!1),y}static GetFinalMatrix(h,d,T,Y,y,C){const n=h.width,X=h.height,F=h.x,U=h.y,Z=L.FromValues(n/2,0,0,0,0,-X/2,0,0,0,0,C-y,0,F+n/2,X/2+U,y,1),S=new L;return d.multiplyToRef(T,S),S.multiplyToRef(Y,S),S.multiplyToRef(Z,S)}static GetAsMatrix2x2(h){const d=h.m,T=[d[0],d[1],d[4],d[5]];return n.c.MatrixUse64Bits?T:new Float32Array(T)}static GetAsMatrix3x3(h){const d=h.m,T=[d[0],d[1],d[2],d[4],d[5],d[6],d[8],d[9],d[10]];return n.c.MatrixUse64Bits?T:new Float32Array(T)}static Transpose(h){const d=new L;return L.TransposeToRef(h,d),d}static TransposeToRef(h,d){const T=h.m,Y=T[0],y=T[4],C=T[8],n=T[12],X=T[1],F=T[5],U=T[9],Z=T[13],S=T[2],r=T[6],c=T[10],O=T[14],f=T[3],J=T[7],W=T[11],L=T[15],D=d.kd;return D[0]=Y,D[1]=y,D[2]=C,D[3]=n,D[4]=X,D[5]=F,D[6]=U,D[7]=Z,D[8]=S,D[9]=r,D[10]=c,D[11]=O,D[12]=f,D[13]=J,D[14]=W,D[15]=L,d.markAsUpdated(),d._updateIdentityStatus(h._isIdentity,h._isIdentityDirty),d}static Reflection(h){const d=new L;return L.ReflectionToRef(h,d),d}static ReflectionToRef(h,d){h.normalize();const T=h.normal.x,Y=h.normal.y,y=h.normal.z,C=-2*T,n=-2*Y,X=-2*y;return L.FromValuesToRef(C*T+1,n*T,X*T,0,C*Y,n*Y+1,X*Y,0,C*y,n*y,X*y+1,0,C*h.d,n*h.d,X*h.d,1,d),d}static FromXYZAxesToRef(h,d,T,Y){return L.FromValuesToRef(h._x,h._y,h._z,0,d._x,d._y,d._z,0,T._x,T._y,T._z,0,0,0,0,1,Y),Y}static FromQuaternionToRef(h,d){const T=h._x*h._x,Y=h._y*h._y,y=h._z*h._z,C=h._x*h._y,n=h._z*h._w,X=h._z*h._x,F=h._y*h._w,U=h._y*h._z,Z=h._x*h._w;return d.kd[0]=1-2*(Y+y),d.kd[1]=2*(C+n),d.kd[2]=2*(X-F),d.kd[3]=0,d.kd[4]=2*(C-n),d.kd[5]=1-2*(y+T),d.kd[6]=2*(U+Z),d.kd[7]=0,d.kd[8]=2*(X+F),d.kd[9]=2*(U-Z),d.kd[10]=1-2*(Y+T),d.kd[11]=0,d.kd[12]=0,d.kd[13]=0,d.kd[14]=0,d.kd[15]=1,d.markAsUpdated(),d}}L._IdentityReadOnly=L.Identity(),Object.defineProperties(L.prototype,{dimension:{value:[4,4]},rank:{value:2}});class D{}D.pd=(0,y.h)(11,f.Zero),D.Matrix=(0,y.h)(2,L.Identity),D.Quaternion=(0,y.h)(3,W.Zero);class V{}V.Vector2=(0,y.h)(3,O.Zero),V.pd=(0,y.h)(13,f.Zero),V.Vector4=(0,y.h)(3,J.Zero),V.Quaternion=(0,y.h)(3,W.Zero),V.Matrix=(0,y.h)(8,L.Identity),(0,C.e)("BABYLON.Vector2",O),(0,C.e)("BABYLON.Vector3",f),(0,C.e)("BABYLON.Vector4",J),(0,C.e)("BABYLON.Matrix",L);const i=L.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12779:(h,d,T)=>{function Y(h,d){const T=[];for(let Y=0;Y<h;++Y)T.push(d());return T}function y(h,d){return Y(h,d)}T.d(d,{e:()=>Y,h:()=>y,i:()=>n});const C=["push","splice","pop","shift","unshift"];function n(h,d){const T=C.map((T=>function(h,d,T){const Y=h[d];if("function"!==typeof Y)return null;const y=function(){const Y=h.length,C=y.previous.apply(h,arguments);return T(d,Y),C};return Y.next=y,y.previous=Y,h[d]=y,()=>{const T=y.previous;if(!T)return;const Y=y.next;Y?(T.next=Y,Y.previous=T):(T.next=void 0,h[d]=T),y.next=void 0,y.previous=void 0}}(h,T,d)));return()=>{for(const h of T)null===h||void 0===h||h()}}}}]);