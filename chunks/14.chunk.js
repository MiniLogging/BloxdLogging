"use strict";(self["80dd64vgxnn"]=self["80dd64vgxnn"]||[]).push([[14],{12746:(mm,o,u)=>{u.d(o,{e:()=>r,f:()=>O,h:()=>f,l:()=>B});const f=1/2.2,B=2.2,O=(1+Math.sqrt(5))/2,r=.001},12752:(mm,o,u)=>{function f(mm){return parseInt(mm.toString().replace(/\W/g,""))}function B(mm,o){let u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(mm-o)<=u}function O(mm,o,u){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return mm<o-f||mm>u+f}function r(mm,o){return mm===o?mm:Math.random()*(o-mm)+mm}function w(mm,o,u){return mm+(o-mm)*u}function p(mm,o,u){let f=M(o-mm,360);return f>180&&(f-=360),mm+f*q(u)}function K(mm,o,u){let f=0;return f=mm!=o?q((u-mm)/(o-mm)):0,f}function z(mm,o,u,f,B){const O=B*B,r=B*O;return mm*(2*r-3*O+1)+u*(-2*r+3*O)+o*(r-2*O+B)+f*(r-O)}function Y(mm,o,u,f,B){const O=B*B;return 6*(O-B)*mm+(3*O-4*B+1)*o+6*(-O+B)*u+(3*O-2*B)*f}function q(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(u,Math.max(o,mm))}function x(mm){return mm-=2*Math.PI*Math.floor((mm+Math.PI)/(2*Math.PI))}function H(mm){const o=mm.toString(16);return mm<=15?("0"+o).toUpperCase():o.toUpperCase()}function E(mm){if(Math.log2)return Math.floor(Math.log2(mm));if(mm<0)return NaN;if(0===mm)return-1/0;let o=0;if(mm<1){for(;mm<1;)o++,mm*=2;o=-o}else if(mm>1)for(;mm>1;)o++,mm=Math.floor(mm/2);return o}function M(mm,o){return mm-Math.floor(mm/o)*o}function l(mm,o,u){return(mm-o)/(u-o)}function t(mm,o,u){return mm*(u-o)+o}function Q(mm,o){let u=M(o-mm,360);return u>180&&(u-=360),u}function b(mm,o){const u=M(mm,2*o);return o-Math.abs(u-o)}function J(mm,o,u){let f=q(u);return f=-2*f*f*f+3*f*f,o*f+mm*(1-f)}function N(mm,o,u){let f=0;return f=Math.abs(o-mm)<=u?o:mm+Math.sign(o-mm)*u,f}function S(mm,o,u){const f=Q(mm,o);let B=0;return B=-u<f&&f<u?o:N(mm,o=mm+f,u),B}function P(mm,o,u){return(mm-o)/(u-o)}function R(mm,o,u){return(u-o)*mm+o}function g(mm,o){const u=mm%o;return 0===u?o:g(o,u)}u.r(o),u.d(o,{Clamp:()=>q,DeltaAngle:()=>Q,Denormalize:()=>t,ExtractAsInt:()=>f,Hermite:()=>z,Hermite1stDerivative:()=>Y,HighestCommonFactor:()=>g,ILog2:()=>E,InverseLerp:()=>K,Lerp:()=>w,LerpAngle:()=>p,MoveTowards:()=>N,MoveTowardsAngle:()=>S,Normalize:()=>l,NormalizeRadians:()=>x,OutsideRange:()=>O,PercentToRange:()=>R,PingPong:()=>b,RandomRange:()=>r,RangeToPercent:()=>P,Repeat:()=>M,SmoothStep:()=>J,ToHex:()=>H,WithinEpsilon:()=>B})},12740:(mm,o,u)=>{u.r(o),u.d(o,{Matrix:()=>t,Quaternion:()=>l,TmpVectors:()=>b,Vector2:()=>H,lo:()=>E,Vector4:()=>M});var f=u(12746),B=u(12748),O=u(12702),r=u(12668),w=u(12596),p=u(12752);class K{}function z(mm,o,u){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const B=mm.df(),O=o.df(),r=B[0],w=B[1],p=B[2],K=B[3],z=B[4],Y=B[5],q=B[6],x=B[7],H=B[8],E=B[9],M=B[10],l=B[11],t=B[12],Q=B[13],b=B[14],J=B[15],N=O[0],S=O[1],P=O[2],R=O[3],g=O[4],W=O[5],F=O[6],c=O[7],A=O[8],y=O[9],I=O[10],s=O[11],j=O[12],a=O[13],X=O[14],G=O[15];u[f]=r*N+w*g+p*A+K*j,u[f+1]=r*S+w*W+p*y+K*a,u[f+2]=r*P+w*F+p*I+K*X,u[f+3]=r*R+w*c+p*s+K*G,u[f+4]=z*N+Y*g+q*A+x*j,u[f+5]=z*S+Y*W+q*y+x*a,u[f+6]=z*P+Y*F+q*I+x*X,u[f+7]=z*R+Y*c+q*s+x*G,u[f+8]=H*N+E*g+M*A+l*j,u[f+9]=H*S+E*W+M*y+l*a,u[f+10]=H*P+E*F+M*I+l*X,u[f+11]=H*R+E*c+M*s+l*G,u[f+12]=t*N+Q*g+b*A+J*j,u[f+13]=t*S+Q*W+b*y+J*a,u[f+14]=t*P+Q*F+b*I+J*X,u[f+15]=t*R+Q*c+b*s+J*G}function Y(mm,o){let u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const f=mm.df();o[u]=f[0],o[u+1]=f[1],o[u+2]=f[2],o[u+3]=f[3],o[u+4]=f[4],o[u+5]=f[5],o[u+6]=f[6],o[u+7]=f[7],o[u+8]=f[8],o[u+9]=f[9],o[u+10]=f[10],o[u+11]=f[11],o[u+12]=f[12],o[u+13]=f[13],o[u+14]=f[14],o[u+15]=f[15]}function q(mm,o){const u=mm.df(),f=u[0],B=u[1],O=u[2],r=u[3],w=u[4],p=u[5],K=u[6],z=u[7],Y=u[8],q=u[9],x=u[10],H=u[11],E=u[12],M=u[13],l=u[14],t=u[15],Q=x*t-l*H,b=q*t-M*H,J=q*l-M*x,N=Y*t-E*H,S=Y*l-x*E,P=Y*M-E*q,R=+(p*Q-K*b+z*J),g=-(w*Q-K*N+z*S),W=+(w*b-p*N+z*P),F=-(w*J-p*S+K*P),c=f*R+B*g+O*W+r*F;if(0===c)return!1;const A=1/c,y=K*t-l*z,I=p*t-M*z,s=p*l-M*K,j=w*t-E*z,a=w*l-E*K,X=w*M-E*p,G=K*H-x*z,k=p*H-q*z,d=p*x-q*K,e=w*H-Y*z,L=w*x-Y*K,C=w*q-Y*p,v=-(B*Q-O*b+r*J),V=+(f*Q-O*N+r*S),n=-(f*b-B*N+r*P),U=+(f*J-B*S+O*P),h=+(B*y-O*I+r*s),Z=-(f*y-O*j+r*a),T=+(f*I-B*j+r*X),D=-(f*s-B*a+O*X),i=-(B*G-O*k+r*d),mo=+(f*G-O*e+r*L),om=-(f*k-B*e+r*C),um=+(f*d-B*L+O*C);return o[0]=R*A,o[1]=v*A,o[2]=h*A,o[3]=i*A,o[4]=g*A,o[5]=V*A,o[6]=Z*A,o[7]=mo*A,o[8]=W*A,o[9]=n*A,o[10]=T*A,o[11]=om*A,o[12]=F*A,o[13]=U*A,o[14]=D*A,o[15]=um*A,!0}K._UpdateFlagSeed=0;const x=mm=>parseInt(mm.toString().replace(/\W/g,""));class H{constructor(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=mm,this.y=o}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let mm=x(this.x);return mm=397*mm^x(this.y),mm}toArray(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return mm[o]=this.x,mm[o+1]=this.y,this}bu(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H.FromArrayToRef(mm,o,this),this}df(){return[this.x,this.y]}p(mm){return this.x=mm.x,this.y=mm.y,this}Op(mm,o){return this.x=mm,this.y=o,this}set(mm,o){return this.Op(mm,o)}wp(mm){return this.Op(mm,mm)}add(mm){return new H(this.x+mm.x,this.y+mm.y)}addToRef(mm,o){return o.x=this.x+mm.x,o.y=this.y+mm.y,o}addInPlace(mm){return this.x+=mm.x,this.y+=mm.y,this}addInPlaceFromFloats(mm,o){return this.x+=mm,this.y+=o,this}addVector3(mm){return new H(this.x+mm.x,this.y+mm.y)}Qo(mm){return new H(this.x-mm.x,this.y-mm.y)}subtractToRef(mm,o){return o.x=this.x-mm.x,o.y=this.y-mm.y,o}LY(mm){return this.x-=mm.x,this.y-=mm.y,this}multiplyInPlace(mm){return this.x*=mm.x,this.y*=mm.y,this}multiply(mm){return new H(this.x*mm.x,this.y*mm.y)}multiplyToRef(mm,o){return o.x=this.x*mm.x,o.y=this.y*mm.y,o}multiplyByFloats(mm,o){return new H(this.x*mm,this.y*o)}divide(mm){return new H(this.x/mm.x,this.y/mm.y)}divideToRef(mm,o){return o.x=this.x/mm.x,o.y=this.y/mm.y,o}divideInPlace(mm){return this.x=this.x/mm.x,this.y=this.y/mm.y,this}minimizeInPlace(mm){return this.minimizeInPlaceFromFloats(mm.x,mm.y)}maximizeInPlace(mm){return this.maximizeInPlaceFromFloats(mm.x,mm.y)}minimizeInPlaceFromFloats(mm,o){return this.x=Math.min(mm,this.x),this.y=Math.min(o,this.y),this}maximizeInPlaceFromFloats(mm,o){return this.x=Math.max(mm,this.x),this.y=Math.max(o,this.y),this}subtractFromFloats(mm,o){return new H(this.x-mm,this.y-o)}subtractFromFloatsToRef(mm,o,u){return u.x=this.x-mm,u.y=this.y-o,u}negate(){return new H(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(mm){return mm.x=-this.x,mm.y=-this.y,mm}scaleInPlace(mm){return this.x*=mm,this.y*=mm,this}scale(mm){return new H(this.x*mm,this.y*mm)}scaleToRef(mm,o){return o.x=this.x*mm,o.y=this.y*mm,o}scaleAndAddToRef(mm,o){return o.x+=this.x*mm,o.y+=this.y*mm,o}equals(mm){return mm&&this.x===mm.x&&this.y===mm.y}equalsWithEpsilon(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return mm&&(0,p.WithinEpsilon)(this.x,mm.x,o)&&(0,p.WithinEpsilon)(this.y,mm.y,o)}equalsToFloats(mm,o){return this.x===mm&&this.y===o}floor(){return new H(Math.floor(this.x),Math.floor(this.y))}floorToRef(mm){return mm.x=Math.floor(this.x),mm.y=Math.floor(this.y),mm}fract(){return new H(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(mm){return mm.x=this.x-Math.floor(this.x),mm.y=this.y-Math.floor(this.y),mm}rotate(mm){return this.rotateToRef(mm,new H)}rotateToRef(mm,o){const u=Math.cos(mm),f=Math.sin(mm);return o.x=u*this.x-f*this.y,o.y=f*this.x+u*this.y,o}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(mm){return 0===mm||1===mm?this:this.scaleInPlace(1/mm)}normalizeToNew(){const mm=new H;return this.normalizeToRef(mm),mm}normalizeToRef(mm){const o=this.length();return 0===o&&(mm.x=this.x,mm.y=this.y),this.scaleToRef(1/o,mm)}clone(){return new H(this.x,this.y)}dot(mm){return this.x*mm.x+this.y*mm.y}static Zero(){return new H(0,0)}static One(){return new H(1,1)}static Random(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new H((0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o))}static RandomToRef(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Op((0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o))}static get ZeroReadOnly(){return H._ZeroReadOnly}static So(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new H(mm[o],mm[o+1])}static FromArrayToRef(mm,o,u){return u.x=mm[o],u.y=mm[o+1],u}static FromFloatsToRef(mm,o,u){return u.Op(mm,o),u}static CatmullRom(mm,o,u,f,B){const O=B*B,r=B*O,w=.5*(2*o.x+(-mm.x+u.x)*B+(2*mm.x-5*o.x+4*u.x-f.x)*O+(-mm.x+3*o.x-3*u.x+f.x)*r),p=.5*(2*o.y+(-mm.y+u.y)*B+(2*mm.y-5*o.y+4*u.y-f.y)*O+(-mm.y+3*o.y-3*u.y+f.y)*r);return new H(w,p)}static ClampToRef(mm,o,u,f){return f.x=(0,p.Clamp)(mm.x,o.x,u.x),f.y=(0,p.Clamp)(mm.y,o.y,u.y),f}static Clamp(mm,o,u){const f=(0,p.Clamp)(mm.x,o.x,u.x),B=(0,p.Clamp)(mm.y,o.y,u.y);return new H(f,B)}static Hermite(mm,o,u,f,B){const O=B*B,r=B*O,w=2*r-3*O+1,p=-2*r+3*O,K=r-2*O+B,z=r-O,Y=mm.x*w+u.x*p+o.x*K+f.x*z,q=mm.y*w+u.y*p+o.y*K+f.y*z;return new H(Y,q)}static Hermite1stDerivative(mm,o,u,f,B){return this.Hermite1stDerivativeToRef(mm,o,u,f,B,new H)}static Hermite1stDerivativeToRef(mm,o,u,f,B,O){const r=B*B;return O.x=6*(r-B)*mm.x+(3*r-4*B+1)*o.x+6*(-r+B)*u.x+(3*r-2*B)*f.x,O.y=6*(r-B)*mm.y+(3*r-4*B+1)*o.y+6*(-r+B)*u.y+(3*r-2*B)*f.y,O}static Lerp(mm,o,u){return H.LerpToRef(mm,o,u,new H)}static LerpToRef(mm,o,u,f){return f.x=mm.x+(o.x-mm.x)*u,f.y=mm.y+(o.y-mm.y)*u,f}static Dot(mm,o){return mm.x*o.x+mm.y*o.y}static Normalize(mm){return H.NormalizeToRef(mm,new H)}static NormalizeToRef(mm,o){return mm.normalizeToRef(o),o}static Minimize(mm,o){const u=mm.x<o.x?mm.x:o.x,f=mm.y<o.y?mm.y:o.y;return new H(u,f)}static Maximize(mm,o){const u=mm.x>o.x?mm.x:o.x,f=mm.y>o.y?mm.y:o.y;return new H(u,f)}static Transform(mm,o){return H.TransformToRef(mm,o,new H)}static TransformToRef(mm,o,u){const f=o.m,B=mm.x*f[0]+mm.y*f[4]+f[12],O=mm.x*f[1]+mm.y*f[5]+f[13];return u.x=B,u.y=O,u}static PointInTriangle(mm,o,u,f){const B=.5*(-u.y*f.x+o.y*(-u.x+f.x)+o.x*(u.y-f.y)+u.x*f.y),O=B<0?-1:1,r=(o.y*f.x-o.x*f.y+(f.y-o.y)*mm.x+(o.x-f.x)*mm.y)*O,w=(o.x*u.y-o.y*u.x+(o.y-u.y)*mm.x+(u.x-o.x)*mm.y)*O;return r>0&&w>0&&r+w<2*B*O}static Distance(mm,o){return Math.sqrt(H.DistanceSquared(mm,o))}static DistanceSquared(mm,o){const u=mm.x-o.x,f=mm.y-o.y;return u*u+f*f}static Center(mm,o){return H.CenterToRef(mm,o,new H)}static CenterToRef(mm,o,u){return u.Op((mm.x+o.x)/2,(mm.y+o.y)/2)}static DistanceOfPointFromSegment(mm,o,u){const f=H.DistanceSquared(o,u);if(0===f)return H.Distance(mm,o);const B=u.Qo(o),O=Math.max(0,Math.min(1,H.Dot(mm.Qo(o),B)/f)),r=o.add(B.multiplyByFloats(O,O));return H.Distance(mm,r)}}H._V8PerformanceHack=new H(.5,.5),H._ZeroReadOnly=H.Zero(),Object.defineProperties(H.prototype,{dimension:{value:[2]},rank:{value:1}});class E{get x(){return this._x}set x(mm){this._x=mm,this._isDirty=!0}get y(){return this._y}set y(mm){this._y=mm,this._isDirty=!0}get z(){return this._z}set z(mm){this._z=mm,this._isDirty=!0}constructor(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=mm,this._y=o,this._z=u}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"lo"}getHashCode(){let mm=x(this._x);return mm=397*mm^x(this._y),mm=397*mm^x(this._z),mm}df(){return[this._x,this._y,this._z]}toArray(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return mm[o]=this._x,mm[o+1]=this._y,mm[o+2]=this._z,this}bu(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(mm,o,this),this}toQuaternion(){return l.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(mm){return this._x+=mm._x,this._y+=mm._y,this._z+=mm._z,this._isDirty=!0,this}addInPlaceFromFloats(mm,o,u){return this._x+=mm,this._y+=o,this._z+=u,this._isDirty=!0,this}add(mm){return new E(this._x+mm._x,this._y+mm._y,this._z+mm._z)}addToRef(mm,o){return o._x=this._x+mm._x,o._y=this._y+mm._y,o._z=this._z+mm._z,o._isDirty=!0,o}LY(mm){return this._x-=mm._x,this._y-=mm._y,this._z-=mm._z,this._isDirty=!0,this}Qo(mm){return new E(this._x-mm._x,this._y-mm._y,this._z-mm._z)}subtractToRef(mm,o){return this.subtractFromFloatsToRef(mm._x,mm._y,mm._z,o)}subtractFromFloats(mm,o,u){return new E(this._x-mm,this._y-o,this._z-u)}subtractFromFloatsToRef(mm,o,u,f){return f._x=this._x-mm,f._y=this._y-o,f._z=this._z-u,f._isDirty=!0,f}negate(){return new E(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(mm){return mm._x=-1*this._x,mm._y=-1*this._y,mm._z=-1*this._z,mm._isDirty=!0,mm}scaleInPlace(mm){return this._x*=mm,this._y*=mm,this._z*=mm,this._isDirty=!0,this}scale(mm){return new E(this._x*mm,this._y*mm,this._z*mm)}scaleToRef(mm,o){return o._x=this._x*mm,o._y=this._y*mm,o._z=this._z*mm,o._isDirty=!0,o}getNormalToRef(mm){const o=this.length();let u=Math.acos(this._y/o);const f=Math.atan2(this._z,this._x);u>Math.PI/2?u-=Math.PI/2:u+=Math.PI/2;const B=o*Math.sin(u)*Math.cos(f),O=o*Math.cos(u),r=o*Math.sin(u)*Math.sin(f);return mm.set(B,O,r),mm}applyRotationQuaternionToRef(mm,o){const u=this._x,f=this._y,B=this._z,O=mm._x,r=mm._y,w=mm._z,p=mm._w,K=2*(r*B-w*f),z=2*(w*u-O*B),Y=2*(O*f-r*u);return o._x=u+p*K+r*Y-w*z,o._y=f+p*z+w*K-O*Y,o._z=B+p*Y+O*z-r*K,o._isDirty=!0,o}applyRotationQuaternionInPlace(mm){return this.applyRotationQuaternionToRef(mm,this)}applyRotationQuaternion(mm){return this.applyRotationQuaternionToRef(mm,new E)}scaleAndAddToRef(mm,o){return o._x+=this._x*mm,o._y+=this._y*mm,o._z+=this._z*mm,o._isDirty=!0,o}projectOnPlane(mm,o){return this.projectOnPlaneToRef(mm,o,new E)}projectOnPlaneToRef(mm,o,u){const f=mm.normal,B=mm.d,O=Q.lo[0];this.subtractToRef(o,O),O.normalize();const r=E.Dot(O,f);if(Math.abs(r)<1e-10)u.wp(1/0);else{const mm=-(E.Dot(o,f)+B)/r,w=O.scaleInPlace(mm);o.addToRef(w,u)}return u}equals(mm){return mm&&this._x===mm._x&&this._y===mm._y&&this._z===mm._z}equalsWithEpsilon(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return mm&&(0,p.WithinEpsilon)(this._x,mm._x,o)&&(0,p.WithinEpsilon)(this._y,mm._y,o)&&(0,p.WithinEpsilon)(this._z,mm._z,o)}equalsToFloats(mm,o,u){return this._x===mm&&this._y===o&&this._z===u}multiplyInPlace(mm){return this._x*=mm._x,this._y*=mm._y,this._z*=mm._z,this._isDirty=!0,this}multiply(mm){return this.multiplyByFloats(mm._x,mm._y,mm._z)}multiplyToRef(mm,o){return o._x=this._x*mm._x,o._y=this._y*mm._y,o._z=this._z*mm._z,o._isDirty=!0,o}multiplyByFloats(mm,o,u){return new E(this._x*mm,this._y*o,this._z*u)}divide(mm){return new E(this._x/mm._x,this._y/mm._y,this._z/mm._z)}divideToRef(mm,o){return o._x=this._x/mm._x,o._y=this._y/mm._y,o._z=this._z/mm._z,o._isDirty=!0,o}divideInPlace(mm){return this._x=this._x/mm._x,this._y=this._y/mm._y,this._z=this._z/mm._z,this._isDirty=!0,this}minimizeInPlace(mm){return this.minimizeInPlaceFromFloats(mm._x,mm._y,mm._z)}maximizeInPlace(mm){return this.maximizeInPlaceFromFloats(mm._x,mm._y,mm._z)}minimizeInPlaceFromFloats(mm,o,u){return mm<this._x&&(this.x=mm),o<this._y&&(this.y=o),u<this._z&&(this.z=u),this}maximizeInPlaceFromFloats(mm,o,u){return mm>this._x&&(this.x=mm),o>this._y&&(this.y=o),u>this._z&&(this.z=u),this}isNonUniformWithinEpsilon(mm){const o=Math.abs(this._x),u=Math.abs(this._y);if(!(0,p.WithinEpsilon)(o,u,mm))return!0;const f=Math.abs(this._z);return!(0,p.WithinEpsilon)(o,f,mm)||!(0,p.WithinEpsilon)(u,f,mm)}get isNonUniform(){const mm=Math.abs(this._x);if(mm!==Math.abs(this._y))return!0;return mm!==Math.abs(this._z)}floorToRef(mm){return mm._x=Math.floor(this._x),mm._y=Math.floor(this._y),mm._z=Math.floor(this._z),mm._isDirty=!0,mm}floor(){return new E(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(mm){return mm._x=this._x-Math.floor(this._x),mm._y=this._y-Math.floor(this._y),mm._z=this._z-Math.floor(this._z),mm._isDirty=!0,mm}fract(){return new E(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(mm){if("xyz"===(mm=mm.toLowerCase()))return this;const o=Q.lo[0].p(this);return this.x=o[mm[0]],this.y=o[mm[1]],this.z=o[mm[2]],this}rotateByQuaternionToRef(mm,o){return mm.toRotationMatrix(Q.Matrix[0]),E.TransformCoordinatesToRef(this,Q.Matrix[0],o),o}rotateByQuaternionAroundPointToRef(mm,o,u){return this.subtractToRef(o,Q.lo[0]),Q.lo[0].rotateByQuaternionToRef(mm,Q.lo[0]),o.addToRef(Q.lo[0],u),u}cross(mm){return E.CrossToRef(this,mm,new E)}normalizeFromLength(mm){return 0===mm||1===mm?this:this.scaleInPlace(1/mm)}normalizeToNew(){return this.normalizeToRef(new E)}normalizeToRef(mm){const o=this.length();return 0===o||1===o?(mm._x=this._x,mm._y=this._y,mm._z=this._z,mm._isDirty=!0,mm):this.scaleToRef(1/o,mm)}clone(){return new E(this._x,this._y,this._z)}p(mm){return this.Op(mm._x,mm._y,mm._z)}Op(mm,o,u){return this._x=mm,this._y=o,this._z=u,this._isDirty=!0,this}set(mm,o,u){return this.Op(mm,o,u)}wp(mm){return this._x=this._y=this._z=mm,this._isDirty=!0,this}static GetClipFactor(mm,o,u,f){const B=E.Dot(mm,u);return(B-f)/(B-E.Dot(o,u))}static GetAngleBetweenVectors(mm,o,u){const f=mm.normalizeToRef(Q.lo[1]),B=o.normalizeToRef(Q.lo[2]);let O=E.Dot(f,B);O=(0,p.Clamp)(O,-1,1);const r=Math.acos(O),w=Q.lo[3];return E.CrossToRef(f,B,w),E.Dot(w,u)>0?isNaN(r)?0:r:isNaN(r)?-Math.PI:-Math.acos(O)}static GetAngleBetweenVectorsOnPlane(mm,o,u){Q.lo[0].p(mm);const f=Q.lo[0];Q.lo[1].p(o);const B=Q.lo[1];Q.lo[2].p(u);const O=Q.lo[2],r=Q.lo[3],w=Q.lo[4];f.normalize(),B.normalize(),O.normalize(),E.CrossToRef(O,f,r),E.CrossToRef(r,O,w);const K=Math.atan2(E.Dot(B,r),E.Dot(B,w));return(0,p.NormalizeRadians)(K)}static PitchYawRollToMoveBetweenPointsToRef(mm,o,u){const f=b.lo[0];return o.subtractToRef(mm,f),u._y=Math.atan2(f.x,f.z)||0,u._x=Math.atan2(Math.sqrt(f.x**2+f.z**2),f.y)||0,u._z=0,u._isDirty=!0,u}static PitchYawRollToMoveBetweenPoints(mm,o){const u=E.Zero();return E.PitchYawRollToMoveBetweenPointsToRef(mm,o,u)}static SlerpToRef(mm,o,u,B){u=(0,p.Clamp)(u,0,1);const O=Q.lo[0],r=Q.lo[1];O.p(mm);const w=O.length();O.normalizeFromLength(w),r.p(o);const K=r.length();r.normalizeFromLength(K);const z=E.Dot(O,r);let Y,q;if(z<1-f.e){const mm=Math.acos(z),o=1/Math.sin(mm);Y=Math.sin((1-u)*mm)*o,q=Math.sin(u*mm)*o}else Y=1-u,q=u;return O.scaleInPlace(Y),r.scaleInPlace(q),B.p(O).addInPlace(r),B.scaleInPlace((0,p.Lerp)(w,K,u)),B}static SmoothToRef(mm,o,u,f,B){return E.SlerpToRef(mm,o,0===f?1:u/f,B),B}static So(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(mm[o],mm[o+1],mm[o+2])}static FromFloatArray(mm,o){return E.So(mm,o)}static FromArrayToRef(mm,o,u){return u._x=mm[o],u._y=mm[o+1],u._z=mm[o+2],u._isDirty=!0,u}static FromFloatArrayToRef(mm,o,u){return E.FromArrayToRef(mm,o,u)}static FromFloatsToRef(mm,o,u,f){return f.Op(mm,o,u),f}static Zero(){return new E(0,0,0)}static One(){return new E(1,1,1)}static Up(){return new E(0,1,0)}static get UpReadOnly(){return E._UpReadOnly}static get DownReadOnly(){return E._DownReadOnly}static get RightReadOnly(){return E._RightReadOnly}static get LeftReadOnly(){return E._LeftReadOnly}static get LeftHandedForwardReadOnly(){return E._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return E._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return E._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return E._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return E._ZeroReadOnly}static get OneReadOnly(){return E._OneReadOnly}static Down(){return new E(0,-1,0)}static Forward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new E(1,0,0)}static Left(){return new E(-1,0,0)}static Random(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E((0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o))}static RandomToRef(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Op((0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o))}static TransformCoordinates(mm,o){const u=E.Zero();return E.TransformCoordinatesToRef(mm,o,u),u}static TransformCoordinatesToRef(mm,o,u){return E.TransformCoordinatesFromFloatsToRef(mm._x,mm._y,mm._z,o,u),u}static TransformCoordinatesFromFloatsToRef(mm,o,u,f,B){const O=f.m,r=mm*O[0]+o*O[4]+u*O[8]+O[12],w=mm*O[1]+o*O[5]+u*O[9]+O[13],p=mm*O[2]+o*O[6]+u*O[10]+O[14],K=1/(mm*O[3]+o*O[7]+u*O[11]+O[15]);return B._x=r*K,B._y=w*K,B._z=p*K,B._isDirty=!0,B}static TransformNormal(mm,o){const u=E.Zero();return E.TransformNormalToRef(mm,o,u),u}static TransformNormalToRef(mm,o,u){return this.TransformNormalFromFloatsToRef(mm._x,mm._y,mm._z,o,u),u}static TransformNormalFromFloatsToRef(mm,o,u,f,B){const O=f.m;return B._x=mm*O[0]+o*O[4]+u*O[8],B._y=mm*O[1]+o*O[5]+u*O[9],B._z=mm*O[2]+o*O[6]+u*O[10],B._isDirty=!0,B}static CatmullRom(mm,o,u,f,B){const O=B*B,r=B*O,w=.5*(2*o._x+(-mm._x+u._x)*B+(2*mm._x-5*o._x+4*u._x-f._x)*O+(-mm._x+3*o._x-3*u._x+f._x)*r),p=.5*(2*o._y+(-mm._y+u._y)*B+(2*mm._y-5*o._y+4*u._y-f._y)*O+(-mm._y+3*o._y-3*u._y+f._y)*r),K=.5*(2*o._z+(-mm._z+u._z)*B+(2*mm._z-5*o._z+4*u._z-f._z)*O+(-mm._z+3*o._z-3*u._z+f._z)*r);return new E(w,p,K)}static Clamp(mm,o,u){const f=new E;return E.ClampToRef(mm,o,u,f),f}static ClampToRef(mm,o,u,f){let B=mm._x;B=B>u._x?u._x:B,B=B<o._x?o._x:B;let O=mm._y;O=O>u._y?u._y:O,O=O<o._y?o._y:O;let r=mm._z;return r=r>u._z?u._z:r,r=r<o._z?o._z:r,f.Op(B,O,r),f}static CheckExtends(mm,o,u){o.minimizeInPlace(mm),u.maximizeInPlace(mm)}static Hermite(mm,o,u,f,B){const O=B*B,r=B*O,w=2*r-3*O+1,p=-2*r+3*O,K=r-2*O+B,z=r-O,Y=mm._x*w+u._x*p+o._x*K+f._x*z,q=mm._y*w+u._y*p+o._y*K+f._y*z,x=mm._z*w+u._z*p+o._z*K+f._z*z;return new E(Y,q,x)}static Hermite1stDerivative(mm,o,u,f,B){const O=new E;return this.Hermite1stDerivativeToRef(mm,o,u,f,B,O),O}static Hermite1stDerivativeToRef(mm,o,u,f,B,O){const r=B*B;return O._x=6*(r-B)*mm._x+(3*r-4*B+1)*o._x+6*(-r+B)*u._x+(3*r-2*B)*f._x,O._y=6*(r-B)*mm._y+(3*r-4*B+1)*o._y+6*(-r+B)*u._y+(3*r-2*B)*f._y,O._z=6*(r-B)*mm._z+(3*r-4*B+1)*o._z+6*(-r+B)*u._z+(3*r-2*B)*f._z,O._isDirty=!0,O}static Lerp(mm,o,u){const f=new E(0,0,0);return E.LerpToRef(mm,o,u,f),f}static LerpToRef(mm,o,u,f){return f._x=mm._x+(o._x-mm._x)*u,f._y=mm._y+(o._y-mm._y)*u,f._z=mm._z+(o._z-mm._z)*u,f._isDirty=!0,f}static Dot(mm,o){return mm._x*o._x+mm._y*o._y+mm._z*o._z}dot(mm){return this._x*mm._x+this._y*mm._y+this._z*mm._z}static Cross(mm,o){const u=new E;return E.CrossToRef(mm,o,u),u}static CrossToRef(mm,o,u){const f=mm._y*o._z-mm._z*o._y,B=mm._z*o._x-mm._x*o._z,O=mm._x*o._y-mm._y*o._x;return u.Op(f,B,O),u}static Normalize(mm){const o=E.Zero();return E.NormalizeToRef(mm,o),o}static NormalizeToRef(mm,o){return mm.normalizeToRef(o),o}static Project(mm,o,u,f){const B=new E;return E.ProjectToRef(mm,o,u,f,B),B}static ProjectToRef(mm,o,u,f,B){var O;const r=f.width,p=f.height,K=f.x,z=f.y,Y=Q.Matrix[1],q=null===(O=w.d.LastCreatedEngine)||void 0===O?void 0:O.isNDCHalfZRange,x=q?1:.5,H=q?0:.5;t.FromValuesToRef(r/2,0,0,0,0,-p/2,0,0,0,0,x,0,K+r/2,p/2+z,H,1,Y);const M=Q.Matrix[0];return o.multiplyToRef(u,M),M.multiplyToRef(Y,M),E.TransformCoordinatesToRef(mm,M,B),B}static Reflect(mm,o){return this.ReflectToRef(mm,o,new E)}static ReflectToRef(mm,o,u){const f=b.lo[0];return f.p(o).scaleInPlace(2*E.Dot(mm,o)),u.p(mm).LY(f)}static _UnprojectFromInvertedMatrixToRef(mm,o,u){E.TransformCoordinatesToRef(mm,o,u);const f=o.m,B=mm._x*f[3]+mm._y*f[7]+mm._z*f[11]+f[15];return(0,p.WithinEpsilon)(B,1)&&u.scaleInPlace(1/B),u}static UnprojectFromTransform(mm,o,u,f,B){return this.Unproject(mm,o,u,f,B,t.IdentityReadOnly)}static Unproject(mm,o,u,f,B,O){const r=new E;return E.UnprojectToRef(mm,o,u,f,B,O,r),r}static UnprojectToRef(mm,o,u,f,B,O,r){return E.UnprojectFloatsToRef(mm._x,mm._y,mm._z,o,u,f,B,O,r),r}static UnprojectFloatsToRef(mm,o,u,f,B,O,r,p,K){var z;const Y=Q.Matrix[0];O.multiplyToRef(r,Y),Y.multiplyToRef(p,Y),Y.invert();const q=Q.lo[0];return q.x=mm/f*2-1,q.y=-(o/B*2-1),null!==(z=w.d.LastCreatedEngine)&&void 0!==z&&z.isNDCHalfZRange?q.z=u:q.z=2*u-1,E._UnprojectFromInvertedMatrixToRef(q,Y,K),K}static Minimize(mm,o){const u=new E;return u.p(mm),u.minimizeInPlace(o),u}static Maximize(mm,o){const u=new E;return u.p(mm),u.maximizeInPlace(o),u}static Distance(mm,o){return Math.sqrt(E.DistanceSquared(mm,o))}static DistanceSquared(mm,o){const u=mm._x-o._x,f=mm._y-o._y,B=mm._z-o._z;return u*u+f*f+B*B}static ProjectOnTriangleToRef(mm,o,u,B,O){const r=Q.lo[0],w=Q.lo[1],K=Q.lo[2],z=Q.lo[3],Y=Q.lo[4];u.subtractToRef(o,r),B.subtractToRef(o,w),B.subtractToRef(u,K);const q=r.length(),x=w.length(),H=K.length();if(q<f.e||x<f.e||H<f.e)return O.p(o),E.Distance(mm,o);mm.subtractToRef(o,Y),E.CrossToRef(r,w,z);const M=z.length();if(M<f.e)return O.p(o),E.Distance(mm,o);z.normalizeFromLength(M);let l=Y.length();if(l<f.e)return O.p(o),0;Y.normalizeFromLength(l);const t=E.Dot(z,Y),b=Q.lo[5],J=Q.lo[6];b.p(z).scaleInPlace(-l*t),J.p(mm).addInPlace(b);const N=Q.lo[4],S=Q.lo[5],P=Q.lo[7],R=Q.lo[8];N.p(r).scaleInPlace(1/q),R.p(w).scaleInPlace(1/x),N.addInPlace(R).scaleInPlace(-1),S.p(r).scaleInPlace(-1/q),R.p(K).scaleInPlace(1/H),S.addInPlace(R).scaleInPlace(-1),P.p(K).scaleInPlace(-1/H),R.p(w).scaleInPlace(-1/x),P.addInPlace(R).scaleInPlace(-1);const g=Q.lo[9];let W;g.p(J).LY(o),E.CrossToRef(N,g,R),W=E.Dot(R,z);const F=W;g.p(J).LY(u),E.CrossToRef(S,g,R),W=E.Dot(R,z);const c=W;g.p(J).LY(B),E.CrossToRef(P,g,R),W=E.Dot(R,z);const A=W,y=Q.lo[10];let I,s;F>0&&c<0?(y.p(r),I=o,s=u):c>0&&A<0?(y.p(K),I=u,s=B):(y.p(w).scaleInPlace(-1),I=B,s=o);const j=Q.lo[9],a=Q.lo[4];I.subtractToRef(J,R),s.subtractToRef(J,j),E.CrossToRef(R,j,a);if(!(E.Dot(a,z)<0))return O.p(J),Math.abs(l*t);const X=Q.lo[5];E.CrossToRef(y,a,X),X.normalize();const G=Q.lo[9];G.p(I).LY(J);const k=G.length();if(k<f.e)return O.p(I),E.Distance(mm,I);G.normalizeFromLength(k);const d=E.Dot(X,G),e=Q.lo[7];e.p(J).addInPlace(X.scaleInPlace(k*d)),R.p(e).LY(I),l=y.length(),y.normalizeFromLength(l);let L=E.Dot(R,y)/Math.max(l,f.e);return L=(0,p.Clamp)(L,0,1),e.p(I).addInPlace(y.scaleInPlace(L*l)),O.p(e),E.Distance(mm,e)}static Center(mm,o){return E.CenterToRef(mm,o,E.Zero())}static CenterToRef(mm,o,u){return u.Op((mm._x+o._x)/2,(mm._y+o._y)/2,(mm._z+o._z)/2)}static RotationFromAxis(mm,o,u){const f=new E;return E.RotationFromAxisToRef(mm,o,u,f),f}static RotationFromAxisToRef(mm,o,u,f){const B=Q.Quaternion[0];return l.RotationQuaternionFromAxisToRef(mm,o,u,B),B.toEulerAnglesToRef(f),f}}E._V8PerformanceHack=new E(.5,.5,.5),E._UpReadOnly=E.Up(),E._DownReadOnly=E.Down(),E._LeftHandedForwardReadOnly=E.Forward(!1),E._RightHandedForwardReadOnly=E.Forward(!0),E._LeftHandedBackwardReadOnly=E.Backward(!1),E._RightHandedBackwardReadOnly=E.Backward(!0),E._RightReadOnly=E.Right(),E._LeftReadOnly=E.Left(),E._ZeroReadOnly=E.Zero(),E._OneReadOnly=E.One(),Object.defineProperties(E.prototype,{dimension:{value:[3]},rank:{value:1}});class M{get x(){return this._x}set x(mm){this._x=mm,this._isDirty=!0}get y(){return this._y}set y(mm){this._y=mm,this._isDirty=!0}get z(){return this._z}set z(mm){this._z=mm,this._isDirty=!0}get w(){return this._w}set w(mm){this._w=mm,this._isDirty=!0}constructor(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=mm,this._y=o,this._z=u,this._w=f}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let mm=x(this._x);return mm=397*mm^x(this._y),mm=397*mm^x(this._z),mm=397*mm^x(this._w),mm}df(){return[this._x,this._y,this._z,this._w]}toArray(mm,o){return void 0===o&&(o=0),mm[o]=this._x,mm[o+1]=this._y,mm[o+2]=this._z,mm[o+3]=this._w,this}bu(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M.FromArrayToRef(mm,o,this),this}addInPlace(mm){return this.x+=mm._x,this.y+=mm._y,this.z+=mm._z,this.w+=mm._w,this}addInPlaceFromFloats(mm,o,u,f){return this.x+=mm,this.y+=o,this.z+=u,this.w+=f,this}add(mm){return new M(this._x+mm.x,this._y+mm.y,this._z+mm.z,this._w+mm.w)}addToRef(mm,o){return o.x=this._x+mm.x,o.y=this._y+mm.y,o.z=this._z+mm.z,o.w=this._w+mm.w,o}LY(mm){return this.x-=mm.x,this.y-=mm.y,this.z-=mm.z,this.w-=mm.w,this}Qo(mm){return new M(this._x-mm.x,this._y-mm.y,this._z-mm.z,this._w-mm.w)}subtractToRef(mm,o){return o.x=this._x-mm.x,o.y=this._y-mm.y,o.z=this._z-mm.z,o.w=this._w-mm.w,o}subtractFromFloats(mm,o,u,f){return new M(this._x-mm,this._y-o,this._z-u,this._w-f)}subtractFromFloatsToRef(mm,o,u,f,B){return B.x=this._x-mm,B.y=this._y-o,B.z=this._z-u,B.w=this._w-f,B}negate(){return new M(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(mm){return mm.x=-this._x,mm.y=-this._y,mm.z=-this._z,mm.w=-this._w,mm}scaleInPlace(mm){return this.x*=mm,this.y*=mm,this.z*=mm,this.w*=mm,this}scale(mm){return new M(this._x*mm,this._y*mm,this._z*mm,this._w*mm)}scaleToRef(mm,o){return o.x=this._x*mm,o.y=this._y*mm,o.z=this._z*mm,o.w=this._w*mm,o}scaleAndAddToRef(mm,o){return o.x+=this._x*mm,o.y+=this._y*mm,o.z+=this._z*mm,o.w+=this._w*mm,o}equals(mm){return mm&&this._x===mm.x&&this._y===mm.y&&this._z===mm.z&&this._w===mm.w}equalsWithEpsilon(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return mm&&(0,p.WithinEpsilon)(this._x,mm.x,o)&&(0,p.WithinEpsilon)(this._y,mm.y,o)&&(0,p.WithinEpsilon)(this._z,mm.z,o)&&(0,p.WithinEpsilon)(this._w,mm.w,o)}equalsToFloats(mm,o,u,f){return this._x===mm&&this._y===o&&this._z===u&&this._w===f}multiplyInPlace(mm){return this.x*=mm.x,this.y*=mm.y,this.z*=mm.z,this.w*=mm.w,this}multiply(mm){return new M(this._x*mm.x,this._y*mm.y,this._z*mm.z,this._w*mm.w)}multiplyToRef(mm,o){return o.x=this._x*mm.x,o.y=this._y*mm.y,o.z=this._z*mm.z,o.w=this._w*mm.w,o}multiplyByFloats(mm,o,u,f){return new M(this._x*mm,this._y*o,this._z*u,this._w*f)}divide(mm){return new M(this._x/mm.x,this._y/mm.y,this._z/mm.z,this._w/mm.w)}divideToRef(mm,o){return o.x=this._x/mm.x,o.y=this._y/mm.y,o.z=this._z/mm.z,o.w=this._w/mm.w,o}divideInPlace(mm){return this.divideToRef(mm,this)}minimizeInPlace(mm){return mm.x<this._x&&(this.x=mm.x),mm.y<this._y&&(this.y=mm.y),mm.z<this._z&&(this.z=mm.z),mm.w<this._w&&(this.w=mm.w),this}maximizeInPlace(mm){return mm.x>this._x&&(this.x=mm.x),mm.y>this._y&&(this.y=mm.y),mm.z>this._z&&(this.z=mm.z),mm.w>this._w&&(this.w=mm.w),this}minimizeInPlaceFromFloats(mm,o,u,f){return this.x=Math.min(mm,this._x),this.y=Math.min(o,this._y),this.z=Math.min(u,this._z),this.w=Math.min(f,this._w),this}maximizeInPlaceFromFloats(mm,o,u,f){return this.x=Math.max(mm,this._x),this.y=Math.max(o,this._y),this.z=Math.max(u,this._z),this.w=Math.max(f,this._w),this}floorToRef(mm){return mm.x=Math.floor(this._x),mm.y=Math.floor(this._y),mm.z=Math.floor(this._z),mm.w=Math.floor(this._w),mm}floor(){return new M(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(mm){return mm.x=this._x-Math.floor(this._x),mm.y=this._y-Math.floor(this._y),mm.z=this._z-Math.floor(this._z),mm.w=this._w-Math.floor(this._w),mm}fract(){return new M(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(mm){return 0===mm||1===mm?this:this.scaleInPlace(1/mm)}normalizeToNew(){return this.normalizeToRef(new M)}normalizeToRef(mm){const o=this.length();return 0===o||1===o?(mm.x=this._x,mm.y=this._y,mm.z=this._z,mm.w=this._w,mm):this.scaleToRef(1/o,mm)}toVector3(){return new E(this._x,this._y,this._z)}clone(){return new M(this._x,this._y,this._z,this._w)}p(mm){return this.x=mm.x,this.y=mm.y,this.z=mm.z,this.w=mm.w,this}Op(mm,o,u,f){return this.x=mm,this.y=o,this.z=u,this.w=f,this}set(mm,o,u,f){return this.Op(mm,o,u,f)}wp(mm){return this.x=this.y=this.z=this.w=mm,this}dot(mm){return this._x*mm.x+this._y*mm.y+this._z*mm.z+this._w*mm.w}static So(mm,o){return o||(o=0),new M(mm[o],mm[o+1],mm[o+2],mm[o+3])}static FromArrayToRef(mm,o,u){return u.x=mm[o],u.y=mm[o+1],u.z=mm[o+2],u.w=mm[o+3],u}static FromFloatArrayToRef(mm,o,u){return M.FromArrayToRef(mm,o,u),u}static FromFloatsToRef(mm,o,u,f,B){return B.x=mm,B.y=o,B.z=u,B.w=f,B}static Zero(){return new M(0,0,0,0)}static One(){return new M(1,1,1,1)}static Random(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new M((0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o))}static RandomToRef(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,u=arguments.length>2?arguments[2]:void 0;return u.x=(0,p.RandomRange)(mm,o),u.y=(0,p.RandomRange)(mm,o),u.z=(0,p.RandomRange)(mm,o),u.w=(0,p.RandomRange)(mm,o),u}static Clamp(mm,o,u){return M.ClampToRef(mm,o,u,new M)}static ClampToRef(mm,o,u,f){return f.x=(0,p.Clamp)(mm.x,o.x,u.x),f.y=(0,p.Clamp)(mm.y,o.y,u.y),f.z=(0,p.Clamp)(mm.z,o.z,u.z),f.w=(0,p.Clamp)(mm.w,o.w,u.w),f}static CheckExtends(mm,o,u){o.minimizeInPlace(mm),u.maximizeInPlace(mm)}static get ZeroReadOnly(){return M._ZeroReadOnly}static Normalize(mm){return M.NormalizeToRef(mm,new M)}static NormalizeToRef(mm,o){return mm.normalizeToRef(o),o}static Minimize(mm,o){const u=new M;return u.p(mm),u.minimizeInPlace(o),u}static Maximize(mm,o){const u=new M;return u.p(mm),u.maximizeInPlace(o),u}static Distance(mm,o){return Math.sqrt(M.DistanceSquared(mm,o))}static DistanceSquared(mm,o){const u=mm.x-o.x,f=mm.y-o.y,B=mm.z-o.z,O=mm.w-o.w;return u*u+f*f+B*B+O*O}static Center(mm,o){return M.CenterToRef(mm,o,new M)}static CenterToRef(mm,o,u){return u.x=(mm.x+o.x)/2,u.y=(mm.y+o.y)/2,u.z=(mm.z+o.z)/2,u.w=(mm.w+o.w)/2,u}static TransformCoordinates(mm,o){return M.TransformCoordinatesToRef(mm,o,new M)}static TransformCoordinatesToRef(mm,o,u){return M.TransformCoordinatesFromFloatsToRef(mm._x,mm._y,mm._z,o,u),u}static TransformCoordinatesFromFloatsToRef(mm,o,u,f,B){const O=f.m,r=mm*O[0]+o*O[4]+u*O[8]+O[12],w=mm*O[1]+o*O[5]+u*O[9]+O[13],p=mm*O[2]+o*O[6]+u*O[10]+O[14],K=mm*O[3]+o*O[7]+u*O[11]+O[15];return B.x=r,B.y=w,B.z=p,B.w=K,B}static TransformNormal(mm,o){return M.TransformNormalToRef(mm,o,new M)}static TransformNormalToRef(mm,o,u){const f=o.m,B=mm.x*f[0]+mm.y*f[4]+mm.z*f[8],O=mm.x*f[1]+mm.y*f[5]+mm.z*f[9],r=mm.x*f[2]+mm.y*f[6]+mm.z*f[10];return u.x=B,u.y=O,u.z=r,u.w=mm.w,u}static TransformNormalFromFloatsToRef(mm,o,u,f,B,O){const r=B.m;return O.x=mm*r[0]+o*r[4]+u*r[8],O.y=mm*r[1]+o*r[5]+u*r[9],O.z=mm*r[2]+o*r[6]+u*r[10],O.w=f,O}static FromVector3(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new M(mm._x,mm._y,mm._z,o)}static Dot(mm,o){return mm.x*o.x+mm.y*o.y+mm.z*o.z+mm.w*o.w}}M._V8PerformanceHack=new M(.5,.5,.5,.5),M._ZeroReadOnly=M.Zero(),Object.defineProperties(M.prototype,{dimension:{value:[4]},rank:{value:1}});class l{get x(){return this._x}set x(mm){this._x=mm,this._isDirty=!0}get y(){return this._y}set y(mm){this._y=mm,this._isDirty=!0}get z(){return this._z}set z(mm){this._z=mm,this._isDirty=!0}get w(){return this._w}set w(mm){this._w=mm,this._isDirty=!0}constructor(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=mm,this._y=o,this._z=u,this._w=f}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let mm=x(this._x);return mm=397*mm^x(this._y),mm=397*mm^x(this._z),mm=397*mm^x(this._w),mm}df(){return[this._x,this._y,this._z,this._w]}toArray(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return mm[o]=this._x,mm[o+1]=this._y,mm[o+2]=this._z,mm[o+3]=this._w,this}bu(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(mm,o,this)}equals(mm){return mm&&this._x===mm._x&&this._y===mm._y&&this._z===mm._z&&this._w===mm._w}equalsWithEpsilon(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return mm&&(0,p.WithinEpsilon)(this._x,mm._x,o)&&(0,p.WithinEpsilon)(this._y,mm._y,o)&&(0,p.WithinEpsilon)(this._z,mm._z,o)&&(0,p.WithinEpsilon)(this._w,mm._w,o)}isApprox(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return mm&&((0,p.WithinEpsilon)(this._x,mm._x,o)&&(0,p.WithinEpsilon)(this._y,mm._y,o)&&(0,p.WithinEpsilon)(this._z,mm._z,o)&&(0,p.WithinEpsilon)(this._w,mm._w,o)||(0,p.WithinEpsilon)(this._x,-mm._x,o)&&(0,p.WithinEpsilon)(this._y,-mm._y,o)&&(0,p.WithinEpsilon)(this._z,-mm._z,o)&&(0,p.WithinEpsilon)(this._w,-mm._w,o))}clone(){return new l(this._x,this._y,this._z,this._w)}p(mm){return this._x=mm._x,this._y=mm._y,this._z=mm._z,this._w=mm._w,this._isDirty=!0,this}Op(mm,o,u,f){return this._x=mm,this._y=o,this._z=u,this._w=f,this._isDirty=!0,this}set(mm,o,u,f){return this.Op(mm,o,u,f)}wp(mm){return this.Op(mm,mm,mm,mm)}add(mm){return new l(this._x+mm._x,this._y+mm._y,this._z+mm._z,this._w+mm._w)}addInPlace(mm){return this._x+=mm._x,this._y+=mm._y,this._z+=mm._z,this._w+=mm._w,this._isDirty=!0,this}addToRef(mm,o){return o._x=this._x+mm._x,o._y=this._y+mm._y,o._z=this._z+mm._z,o._w=this._w+mm._w,o._isDirty=!0,o}addInPlaceFromFloats(mm,o,u,f){return this._x+=mm,this._y+=o,this._z+=u,this._w+=f,this._isDirty=!0,this}subtractToRef(mm,o){return o._x=this._x-mm._x,o._y=this._y-mm._y,o._z=this._z-mm._z,o._w=this._w-mm._w,o._isDirty=!0,o}subtractFromFloats(mm,o,u,f){return this.subtractFromFloatsToRef(mm,o,u,f,new l)}subtractFromFloatsToRef(mm,o,u,f,B){return B._x=this._x-mm,B._y=this._y-o,B._z=this._z-u,B._w=this._w-f,B._isDirty=!0,B}Qo(mm){return new l(this._x-mm._x,this._y-mm._y,this._z-mm._z,this._w-mm._w)}LY(mm){return this._x-=mm._x,this._y-=mm._y,this._z-=mm._z,this._w-=mm._w,this._isDirty=!0,this}scale(mm){return new l(this._x*mm,this._y*mm,this._z*mm,this._w*mm)}scaleToRef(mm,o){return o._x=this._x*mm,o._y=this._y*mm,o._z=this._z*mm,o._w=this._w*mm,o._isDirty=!0,o}scaleInPlace(mm){return this._x*=mm,this._y*=mm,this._z*=mm,this._w*=mm,this._isDirty=!0,this}scaleAndAddToRef(mm,o){return o._x+=this._x*mm,o._y+=this._y*mm,o._z+=this._z*mm,o._w+=this._w*mm,o._isDirty=!0,o}multiply(mm){const o=new l(0,0,0,1);return this.multiplyToRef(mm,o),o}multiplyToRef(mm,o){const u=this._x*mm._w+this._y*mm._z-this._z*mm._y+this._w*mm._x,f=-this._x*mm._z+this._y*mm._w+this._z*mm._x+this._w*mm._y,B=this._x*mm._y-this._y*mm._x+this._z*mm._w+this._w*mm._z,O=-this._x*mm._x-this._y*mm._y-this._z*mm._z+this._w*mm._w;return o.Op(u,f,B,O),o}multiplyInPlace(mm){return this.multiplyToRef(mm,this)}multiplyByFloats(mm,o,u,f){return this._x*=mm,this._y*=o,this._z*=u,this._w*=f,this._isDirty=!0,this}divide(mm){throw new ReferenceError("Can not divide a quaternion")}divideToRef(mm,o){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(mm){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new l)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(mm){return mm._x=-this._x,mm._y=-this._y,mm._z=-this._z,mm._w=-this._w,mm._isDirty=!0,mm}equalsToFloats(mm,o,u,f){return this._x===mm&&this._y===o&&this._z===u&&this._w===f}floorToRef(mm){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(mm){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(mm){return mm.Op(-this._x,-this._y,-this._z,this._w),mm}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new l(-this._x,-this._y,-this._z,this._w)}invert(){const mm=this.conjugate(),o=this.lengthSquared();return 0==o||1==o||mm.scaleInPlace(1/o),mm}invertInPlace(){this.conjugateInPlace();const mm=this.lengthSquared();return 0==mm||1==mm||this.scaleInPlace(1/mm),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(mm){return 0===mm||1===mm?this:this.scaleInPlace(1/mm)}normalizeToNew(){const mm=new l(0,0,0,1);return this.normalizeToRef(mm),mm}normalizeToRef(mm){const o=this.length();return 0===o||1===o?mm.Op(this._x,this._y,this._z,this._w):this.scaleToRef(1/o,mm)}toEulerAngles(){const mm=E.Zero();return this.toEulerAnglesToRef(mm),mm}toEulerAnglesToRef(mm){const o=this._z,u=this._x,f=this._y,B=this._w,O=f*o-u*B,r=.4999999;if(O<-r)mm._y=2*Math.atan2(f,B),mm._x=Math.PI/2,mm._z=0,mm._isDirty=!0;else if(O>r)mm._y=2*Math.atan2(f,B),mm._x=-Math.PI/2,mm._z=0,mm._isDirty=!0;else{const r=B*B,w=o*o,p=u*u,K=f*f;mm._z=Math.atan2(2*(u*f+o*B),-w-p+K+r),mm._x=Math.asin(-2*O),mm._y=Math.atan2(2*(o*u+f*B),w-p-K+r),mm._isDirty=!0}return mm}toAlphaBetaGammaToRef(mm){const o=this._z,u=this._x,f=this._y,B=this._w,O=Math.sqrt(u*u+f*f),r=Math.sqrt(o*o+B*B),w=2*Math.atan2(O,r),p=2*Math.atan2(o,B),K=2*Math.atan2(f,u),z=(p+K)/2,Y=(p-K)/2;return mm.set(Y,w,z),mm}toRotationMatrix(mm){return t.FromQuaternionToRef(this,mm),mm}fromRotationMatrix(mm){return l.FromRotationMatrixToRef(mm,this),this}dot(mm){return this._x*mm._x+this._y*mm._y+this._z*mm._z+this._w*mm._w}toAxisAngle(){const mm=E.Zero();return{axis:mm,angle:this.toAxisAngleToRef(mm)}}toAxisAngleToRef(mm){let o=0;const u=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),f=this._w;return u>0?(o=2*Math.atan2(u,f),mm.set(this._x/u,this._y/u,this._z/u)):(o=0,mm.set(1,0,0)),o}static FromRotationMatrix(mm){const o=new l;return l.FromRotationMatrixToRef(mm,o),o}static FromRotationMatrixToRef(mm,o){const u=mm.m,f=u[0],B=u[4],O=u[8],r=u[1],w=u[5],p=u[9],K=u[2],z=u[6],Y=u[10],q=f+w+Y;let x;return q>0?(x=.5/Math.sqrt(q+1),o._w=.25/x,o._x=(z-p)*x,o._y=(O-K)*x,o._z=(r-B)*x,o._isDirty=!0):f>w&&f>Y?(x=2*Math.sqrt(1+f-w-Y),o._w=(z-p)/x,o._x=.25*x,o._y=(B+r)/x,o._z=(O+K)/x,o._isDirty=!0):w>Y?(x=2*Math.sqrt(1+w-f-Y),o._w=(O-K)/x,o._x=(B+r)/x,o._y=.25*x,o._z=(p+z)/x,o._isDirty=!0):(x=2*Math.sqrt(1+Y-f-w),o._w=(r-B)/x,o._x=(O+K)/x,o._y=(p+z)/x,o._z=.25*x,o._isDirty=!0),o}static Dot(mm,o){return mm._x*o._x+mm._y*o._y+mm._z*o._z+mm._w*o._w}static AreClose(mm,o){let u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const f=l.Dot(mm,o);return 1-f*f<=u}static SmoothToRef(mm,o,u,f,B){let O=0===f?1:u/f;return O=(0,p.Clamp)(O,0,1),l.SlerpToRef(mm,o,O,B),B}static Zero(){return new l(0,0,0,0)}static Inverse(mm){return new l(-mm._x,-mm._y,-mm._z,mm._w)}static InverseToRef(mm,o){return o.set(-mm._x,-mm._y,-mm._z,mm._w),o}static Identity(){return new l(0,0,0,1)}static IsIdentity(mm){return mm&&0===mm._x&&0===mm._y&&0===mm._z&&1===mm._w}static RotationAxis(mm,o){return l.RotationAxisToRef(mm,o,new l)}static RotationAxisToRef(mm,o,u){u._w=Math.cos(o/2);const f=Math.sin(o/2)/mm.length();return u._x=mm._x*f,u._y=mm._y*f,u._z=mm._z*f,u._isDirty=!0,u}static So(mm,o){return o||(o=0),new l(mm[o],mm[o+1],mm[o+2],mm[o+3])}static FromArrayToRef(mm,o,u){return u._x=mm[o],u._y=mm[o+1],u._z=mm[o+2],u._w=mm[o+3],u._isDirty=!0,u}static FromFloatsToRef(mm,o,u,f,B){return B.Op(mm,o,u,f),B}static FromEulerAngles(mm,o,u){const f=new l;return l.RotationYawPitchRollToRef(o,mm,u,f),f}static FromEulerAnglesToRef(mm,o,u,f){return l.RotationYawPitchRollToRef(o,mm,u,f),f}static FromEulerVector(mm){const o=new l;return l.RotationYawPitchRollToRef(mm._y,mm._x,mm._z,o),o}static FromEulerVectorToRef(mm,o){return l.RotationYawPitchRollToRef(mm._y,mm._x,mm._z,o),o}static FromUnitVectorsToRef(mm,o,u){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:f.e;const O=E.Dot(mm,o)+1;return O<B?Math.abs(mm.x)>Math.abs(mm.z)?u.set(-mm.y,mm.x,0,0):u.set(0,-mm.z,mm.y,0):(E.CrossToRef(mm,o,b.lo[0]),u.set(b.lo[0].x,b.lo[0].y,b.lo[0].z,O)),u.normalize()}static RotationYawPitchRoll(mm,o,u){const f=new l;return l.RotationYawPitchRollToRef(mm,o,u,f),f}static RotationYawPitchRollToRef(mm,o,u,f){const B=.5*u,O=.5*o,r=.5*mm,w=Math.sin(B),p=Math.cos(B),K=Math.sin(O),z=Math.cos(O),Y=Math.sin(r),q=Math.cos(r);return f._x=q*K*p+Y*z*w,f._y=Y*z*p-q*K*w,f._z=q*z*w-Y*K*p,f._w=q*z*p+Y*K*w,f._isDirty=!0,f}static RotationAlphaBetaGamma(mm,o,u){const f=new l;return l.RotationAlphaBetaGammaToRef(mm,o,u,f),f}static RotationAlphaBetaGammaToRef(mm,o,u,f){const B=.5*(u+mm),O=.5*(u-mm),r=.5*o;return f._x=Math.cos(O)*Math.sin(r),f._y=Math.sin(O)*Math.sin(r),f._z=Math.sin(B)*Math.cos(r),f._w=Math.cos(B)*Math.cos(r),f._isDirty=!0,f}static RotationQuaternionFromAxis(mm,o,u){const f=new l(0,0,0,0);return l.RotationQuaternionFromAxisToRef(mm,o,u,f),f}static RotationQuaternionFromAxisToRef(mm,o,u,f){const B=Q.Matrix[0];return mm=mm.normalizeToRef(Q.lo[0]),o=o.normalizeToRef(Q.lo[1]),u=u.normalizeToRef(Q.lo[2]),t.FromXYZAxesToRef(mm,o,u,B),l.FromRotationMatrixToRef(B,f),f}static FromLookDirectionLH(mm,o){const u=new l;return l.FromLookDirectionLHToRef(mm,o,u),u}static FromLookDirectionLHToRef(mm,o,u){const f=Q.Matrix[0];return t.LookDirectionLHToRef(mm,o,f),l.FromRotationMatrixToRef(f,u),u}static FromLookDirectionRH(mm,o){const u=new l;return l.FromLookDirectionRHToRef(mm,o,u),u}static FromLookDirectionRHToRef(mm,o,u){const f=Q.Matrix[0];return t.LookDirectionRHToRef(mm,o,f),l.FromRotationMatrixToRef(f,u)}static Slerp(mm,o,u){const f=l.Identity();return l.SlerpToRef(mm,o,u,f),f}static SlerpToRef(mm,o,u,f){let B,O,r=mm._x*o._x+mm._y*o._y+mm._z*o._z+mm._w*o._w,w=!1;if(r<0&&(w=!0,r=-r),r>.999999)O=1-u,B=w?-u:u;else{const mm=Math.acos(r),o=1/Math.sin(mm);O=Math.sin((1-u)*mm)*o,B=w?-Math.sin(u*mm)*o:Math.sin(u*mm)*o}return f._x=O*mm._x+B*o._x,f._y=O*mm._y+B*o._y,f._z=O*mm._z+B*o._z,f._w=O*mm._w+B*o._w,f._isDirty=!0,f}static Hermite(mm,o,u,f,B){const O=B*B,r=B*O,w=2*r-3*O+1,p=-2*r+3*O,K=r-2*O+B,z=r-O,Y=mm._x*w+u._x*p+o._x*K+f._x*z,q=mm._y*w+u._y*p+o._y*K+f._y*z,x=mm._z*w+u._z*p+o._z*K+f._z*z,H=mm._w*w+u._w*p+o._w*K+f._w*z;return new l(Y,q,x,H)}static Hermite1stDerivative(mm,o,u,f,B){const O=new l;return this.Hermite1stDerivativeToRef(mm,o,u,f,B,O),O}static Hermite1stDerivativeToRef(mm,o,u,f,B,O){const r=B*B;return O._x=6*(r-B)*mm._x+(3*r-4*B+1)*o._x+6*(-r+B)*u._x+(3*r-2*B)*f._x,O._y=6*(r-B)*mm._y+(3*r-4*B+1)*o._y+6*(-r+B)*u._y+(3*r-2*B)*f._y,O._z=6*(r-B)*mm._z+(3*r-4*B+1)*o._z+6*(-r+B)*u._z+(3*r-2*B)*f._z,O._w=6*(r-B)*mm._w+(3*r-4*B+1)*o._w+6*(-r+B)*u._w+(3*r-2*B)*f._w,O._isDirty=!0,O}static Normalize(mm){const o=l.Zero();return l.NormalizeToRef(mm,o),o}static NormalizeToRef(mm,o){return mm.normalizeToRef(o),o}static Clamp(mm,o,u){const f=new l;return l.ClampToRef(mm,o,u,f),f}static ClampToRef(mm,o,u,f){return f.Op((0,p.Clamp)(mm.x,o.x,u.x),(0,p.Clamp)(mm.y,o.y,u.y),(0,p.Clamp)(mm.z,o.z,u.z),(0,p.Clamp)(mm.w,o.w,u.w))}static Random(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new l((0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o))}static RandomToRef(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Op((0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o),(0,p.RandomRange)(mm,o))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(mm,o){return Math.sqrt(l.DistanceSquared(mm,o))}static DistanceSquared(mm,o){const u=mm.x-o.x,f=mm.y-o.y,B=mm.z-o.z,O=mm.w-o.w;return u*u+f*f+B*B+O*O}static Center(mm,o){return l.CenterToRef(mm,o,l.Zero())}static CenterToRef(mm,o,u){return u.Op((mm.x+o.x)/2,(mm.y+o.y)/2,(mm.z+o.z)/2,(mm.w+o.w)/2)}}l._V8PerformanceHack=new l(.5,.5,.5,.5),Object.defineProperties(l.prototype,{dimension:{value:[4]},rank:{value:1}});class t{static get Use64Bits(){return r.b.MatrixUse64Bits}get m(){return this.gf}markAsUpdated(){this.updateFlag=K._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(mm){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],u=arguments.length>2&&void 0!==arguments[2]&&arguments[2],f=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=mm,this._isIdentity3x2=mm||u,this._isIdentityDirty=!this._isIdentity&&o,this._isIdentity3x2Dirty=!this._isIdentity3x2&&f}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,r.b.MatrixTrackPrecisionChange&&r.b.MatrixTrackedMatrices.push(this),this.gf=new r.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const mm=this.gf;this._isIdentity=1===mm[0]&&0===mm[1]&&0===mm[2]&&0===mm[3]&&0===mm[4]&&1===mm[5]&&0===mm[6]&&0===mm[7]&&0===mm[8]&&0===mm[9]&&1===mm[10]&&0===mm[11]&&0===mm[12]&&0===mm[13]&&0===mm[14]&&1===mm[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.gf[0]||1!==this.gf[5]||1!==this.gf[15]||0!==this.gf[1]||0!==this.gf[2]||0!==this.gf[3]||0!==this.gf[4]||0!==this.gf[6]||0!==this.gf[7]||0!==this.gf[8]||0!==this.gf[9]||0!==this.gf[10]||0!==this.gf[11]||0!==this.gf[12]||0!==this.gf[13]||0!==this.gf[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const mm=this.gf,o=mm[0],u=mm[1],f=mm[2],B=mm[3],O=mm[4],r=mm[5],w=mm[6],p=mm[7],K=mm[8],z=mm[9],Y=mm[10],q=mm[11],x=mm[12],H=mm[13],E=mm[14],M=mm[15],l=Y*M-E*q,t=z*M-H*q,Q=z*E-H*Y,b=K*M-x*q,J=K*E-Y*x,N=K*H-x*z;return o*+(r*l-w*t+p*Q)+u*-(O*l-w*b+p*J)+f*+(O*t-r*b+p*N)+B*-(O*Q-r*J+w*N)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!mm)return this.gf;const u=this.gf;for(let f=0;f<16;f++)mm[o+f]=u[f];return this}df(){return this.gf}bu(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(mm,o,this)}Op(){for(var mm=arguments.length,o=new Array(mm),u=0;u<mm;u++)o[u]=arguments[u];return t.FromArrayToRef(o,0,this)}set(){const mm=this.gf;for(let o=0;o<16;o++)mm[o]=o<0||arguments.length<=o?void 0:arguments[o];return this.markAsUpdated(),this}wp(mm){const o=this.gf;for(let u=0;u<16;u++)o[u]=mm;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return t.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(mm){const o=new t;return this.addToRef(mm,o),o}addToRef(mm,o){const u=this.gf,f=o.gf,B=mm.m;for(let O=0;O<16;O++)f[O]=u[O]+B[O];return o.markAsUpdated(),o}addToSelf(mm){const o=this.gf,u=mm.m;return o[0]+=u[0],o[1]+=u[1],o[2]+=u[2],o[3]+=u[3],o[4]+=u[4],o[5]+=u[5],o[6]+=u[6],o[7]+=u[7],o[8]+=u[8],o[9]+=u[9],o[10]+=u[10],o[11]+=u[11],o[12]+=u[12],o[13]+=u[13],o[14]+=u[14],o[15]+=u[15],this.markAsUpdated(),this}addInPlace(mm){const o=this.gf,u=mm.m;for(let f=0;f<16;f++)o[f]+=u[f];return this.markAsUpdated(),this}addInPlaceFromFloats(){const mm=this.gf;for(let o=0;o<16;o++)mm[o]+=o<0||arguments.length<=o?void 0:arguments[o];return this.markAsUpdated(),this}Qo(mm){const o=this.gf,u=mm.m;for(let f=0;f<16;f++)o[f]-=u[f];return this.markAsUpdated(),this}subtractToRef(mm,o){const u=this.gf,f=mm.m,B=o.gf;for(let O=0;O<16;O++)B[O]=u[O]-f[O];return o.markAsUpdated(),o}LY(mm){const o=this.gf,u=mm.m;for(let f=0;f<16;f++)o[f]-=u[f];return this.markAsUpdated(),this}subtractFromFloats(){for(var mm=arguments.length,o=new Array(mm),u=0;u<mm;u++)o[u]=arguments[u];return this.subtractFromFloatsToRef(...o,new t)}subtractFromFloatsToRef(){for(var mm=arguments.length,o=new Array(mm),u=0;u<mm;u++)o[u]=arguments[u];const f=o.pop(),B=this.gf,O=f.gf,r=o;for(let w=0;w<16;w++)O[w]=B[w]-r[w];return f.markAsUpdated(),f}invertToRef(mm){return!0===this._isIdentity?(t.IdentityToRef(mm),mm):(q(this,mm.df())?mm.markAsUpdated():mm.p(this),mm)}addAtIndex(mm,o){return this.gf[mm]+=o,this.markAsUpdated(),this}multiplyAtIndex(mm,o){return this.gf[mm]*=o,this.markAsUpdated(),this}setTranslationFromFloats(mm,o,u){return this.gf[12]=mm,this.gf[13]=o,this.gf[14]=u,this.markAsUpdated(),this}addTranslationFromFloats(mm,o,u){return this.gf[12]+=mm,this.gf[13]+=o,this.gf[14]+=u,this.markAsUpdated(),this}setTranslation(mm){return this.setTranslationFromFloats(mm._x,mm._y,mm._z)}getTranslation(){return new E(this.gf[12],this.gf[13],this.gf[14])}getTranslationToRef(mm){return mm.x=this.gf[12],mm.y=this.gf[13],mm.z=this.gf[14],mm}removeRotationAndScaling(){const mm=this.m;return t.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,mm[12],mm[13],mm[14],mm[15],this),this._updateIdentityStatus(0===mm[12]&&0===mm[13]&&0===mm[14]&&1===mm[15]),this}p(mm){mm.copyToArray(this.gf);const o=mm;return this.updateFlag=o.updateFlag,this._updateIdentityStatus(o._isIdentity,o._isIdentityDirty,o._isIdentity3x2,o._isIdentity3x2Dirty),this}copyToArray(mm){return Y(this,mm,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(mm){const o=new t;return this.multiplyToRef(mm,o),o}multiplyInPlace(mm){const o=this.gf,u=mm.m;for(let f=0;f<16;f++)o[f]*=u[f];return this.markAsUpdated(),this}multiplyByFloats(){const mm=this.gf;for(let o=0;o<16;o++)mm[o]*=o<0||arguments.length<=o?void 0:arguments[o];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var mm=arguments.length,o=new Array(mm),u=0;u<mm;u++)o[u]=arguments[u];const f=o.pop(),B=this.gf,O=f.gf,r=o;for(let w=0;w<16;w++)O[w]=B[w]*r[w];return f.markAsUpdated(),f}multiplyToRef(mm,o){return this._isIdentity?(o.p(mm),o):mm._isIdentity?(o.p(this),o):(this.multiplyToArray(mm,o.gf,0),o.markAsUpdated(),o)}multiplyToArray(mm,o,u){return z(this,mm,o,u),this}divide(mm){return this.divideToRef(mm,new t)}divideToRef(mm,o){const u=this.gf,f=mm.m,B=o.gf;for(let O=0;O<16;O++)B[O]=u[O]/f[O];return o.markAsUpdated(),o}divideInPlace(mm){const o=this.gf,u=mm.m;for(let f=0;f<16;f++)o[f]/=u[f];return this.markAsUpdated(),this}minimizeInPlace(mm){const o=this.gf,u=mm.m;for(let f=0;f<16;f++)o[f]=Math.min(o[f],u[f]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const mm=this.gf;for(let o=0;o<16;o++)mm[o]=Math.min(mm[o],o<0||arguments.length<=o?void 0:arguments[o]);return this.markAsUpdated(),this}maximizeInPlace(mm){const o=this.gf,u=mm.m;for(let f=0;f<16;f++)o[f]=Math.min(o[f],u[f]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const mm=this.gf;for(let o=0;o<16;o++)mm[o]=Math.min(mm[o],o<0||arguments.length<=o?void 0:arguments[o]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new t)}negateInPlace(){const mm=this.gf;for(let o=0;o<16;o++)mm[o]=-mm[o];return this.markAsUpdated(),this}negateToRef(mm){const o=this.gf,u=mm.gf;for(let f=0;f<16;f++)u[f]=-o[f];return mm.markAsUpdated(),mm}equals(mm){const o=mm;if(!o)return!1;if((this._isIdentity||o._isIdentity)&&!this._isIdentityDirty&&!o._isIdentityDirty)return this._isIdentity&&o._isIdentity;const u=this.m,f=o.m;return u[0]===f[0]&&u[1]===f[1]&&u[2]===f[2]&&u[3]===f[3]&&u[4]===f[4]&&u[5]===f[5]&&u[6]===f[6]&&u[7]===f[7]&&u[8]===f[8]&&u[9]===f[9]&&u[10]===f[10]&&u[11]===f[11]&&u[12]===f[12]&&u[13]===f[13]&&u[14]===f[14]&&u[15]===f[15]}equalsWithEpsilon(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const u=this.gf,f=mm.m;for(let B=0;B<16;B++)if(!(0,p.WithinEpsilon)(u[B],f[B],o))return!1;return!0}equalsToFloats(){const mm=this.gf;for(let o=0;o<16;o++)if(mm[o]!=(o<0||arguments.length<=o?void 0:arguments[o]))return!1;return!0}floor(){return this.floorToRef(new t)}floorToRef(mm){const o=this.gf,u=mm.gf;for(let f=0;f<16;f++)u[f]=Math.floor(o[f]);return mm.markAsUpdated(),mm}fract(){return this.fractToRef(new t)}fractToRef(mm){const o=this.gf,u=mm.gf;for(let f=0;f<16;f++)u[f]=o[f]-Math.floor(o[f]);return mm.markAsUpdated(),mm}clone(){const mm=new t;return mm.p(this),mm}getClassName(){return"Matrix"}getHashCode(){let mm=x(this.gf[0]);for(let o=1;o<16;o++)mm=397*mm^x(this.gf[o]);return mm}decomposeToTransformNode(mm){return mm.rotationQuaternion=mm.rotationQuaternion||new l,this.decompose(mm.rp,mm.rotationQuaternion,mm.position)}decompose(mm,o,u,f){let B=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return u&&u.wp(0),mm&&mm.wp(1),o&&o.Op(0,0,0,1),!0;const O=this.gf;if(u&&u.Op(O[12],O[13],O[14]),(mm=mm||Q.lo[0]).x=Math.sqrt(O[0]*O[0]+O[1]*O[1]+O[2]*O[2]),mm.y=Math.sqrt(O[4]*O[4]+O[5]*O[5]+O[6]*O[6]),mm.z=Math.sqrt(O[8]*O[8]+O[9]*O[9]+O[10]*O[10]),f){const o=(B?f.absoluteScaling.x:f.rp.x)<0?-1:1,u=(B?f.absoluteScaling.y:f.rp.y)<0?-1:1,O=(B?f.absoluteScaling.z:f.rp.z)<0?-1:1;mm.x*=o,mm.y*=u,mm.z*=O}else this.determinant()<=0&&(mm.y*=-1);if(0===mm._x||0===mm._y||0===mm._z)return o&&o.Op(0,0,0,1),!1;if(o){const u=1/mm._x,f=1/mm._y,B=1/mm._z;t.FromValuesToRef(O[0]*u,O[1]*u,O[2]*u,0,O[4]*f,O[5]*f,O[6]*f,0,O[8]*B,O[9]*B,O[10]*B,0,0,0,0,1,Q.Matrix[0]),l.FromRotationMatrixToRef(Q.Matrix[0],o)}return!0}getRow(mm){if(mm<0||mm>3)return null;const o=4*mm;return new M(this.gf[o+0],this.gf[o+1],this.gf[o+2],this.gf[o+3])}getRowToRef(mm,o){if(mm>=0&&mm<=3){const u=4*mm;o.x=this.gf[u+0],o.y=this.gf[u+1],o.z=this.gf[u+2],o.w=this.gf[u+3]}return o}setRow(mm,o){return this.setRowFromFloats(mm,o.x,o.y,o.z,o.w)}transpose(){const mm=new t;return t.TransposeToRef(this,mm),mm}transposeToRef(mm){return t.TransposeToRef(this,mm),mm}setRowFromFloats(mm,o,u,f,B){if(mm<0||mm>3)return this;const O=4*mm;return this.gf[O+0]=o,this.gf[O+1]=u,this.gf[O+2]=f,this.gf[O+3]=B,this.markAsUpdated(),this}scale(mm){const o=new t;return this.scaleToRef(mm,o),o}scaleToRef(mm,o){for(let u=0;u<16;u++)o.gf[u]=this.gf[u]*mm;return o.markAsUpdated(),o}scaleAndAddToRef(mm,o){for(let u=0;u<16;u++)o.gf[u]+=this.gf[u]*mm;return o.markAsUpdated(),o}scaleInPlace(mm){const o=this.gf;for(let u=0;u<16;u++)o[u]*=mm;return this.markAsUpdated(),this}toNormalMatrix(mm){const o=Q.Matrix[0];this.invertToRef(o),o.transposeToRef(mm);const u=mm.gf;return t.FromValuesToRef(u[0],u[1],u[2],0,u[4],u[5],u[6],0,u[8],u[9],u[10],0,0,0,0,1,mm),mm}getRotationMatrix(){const mm=new t;return this.getRotationMatrixToRef(mm),mm}getRotationMatrixToRef(mm){const o=Q.lo[0];if(!this.decompose(o))return t.IdentityToRef(mm),mm;const u=this.gf,f=1/o._x,B=1/o._y,O=1/o._z;return t.FromValuesToRef(u[0]*f,u[1]*f,u[2]*f,0,u[4]*B,u[5]*B,u[6]*B,0,u[8]*O,u[9]*O,u[10]*O,0,0,0,0,1,mm),mm}toggleModelMatrixHandInPlace(){const mm=this.gf;return mm[2]*=-1,mm[6]*=-1,mm[8]*=-1,mm[9]*=-1,mm[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const mm=this.gf;return mm[8]*=-1,mm[9]*=-1,mm[10]*=-1,mm[11]*=-1,this.markAsUpdated(),this}static So(mm){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const u=new t;return t.FromArrayToRef(mm,o,u),u}static FromArrayToRef(mm,o,u){for(let f=0;f<16;f++)u.gf[f]=mm[f+o];return u.markAsUpdated(),u}static FromFloat32ArrayToRefScaled(mm,o,u,f){return f.gf[0]=mm[0+o]*u,f.gf[1]=mm[1+o]*u,f.gf[2]=mm[2+o]*u,f.gf[3]=mm[3+o]*u,f.gf[4]=mm[4+o]*u,f.gf[5]=mm[5+o]*u,f.gf[6]=mm[6+o]*u,f.gf[7]=mm[7+o]*u,f.gf[8]=mm[8+o]*u,f.gf[9]=mm[9+o]*u,f.gf[10]=mm[10+o]*u,f.gf[11]=mm[11+o]*u,f.gf[12]=mm[12+o]*u,f.gf[13]=mm[13+o]*u,f.gf[14]=mm[14+o]*u,f.gf[15]=mm[15+o]*u,f.markAsUpdated(),f}static get IdentityReadOnly(){return t._IdentityReadOnly}static FromValuesToRef(mm,o,u,f,B,O,r,w,p,K,z,Y,q,x,H,E,M){const l=M.gf;l[0]=mm,l[1]=o,l[2]=u,l[3]=f,l[4]=B,l[5]=O,l[6]=r,l[7]=w,l[8]=p,l[9]=K,l[10]=z,l[11]=Y,l[12]=q,l[13]=x,l[14]=H,l[15]=E,M.markAsUpdated()}static FromValues(mm,o,u,f,B,O,r,w,p,K,z,Y,q,x,H,E){const M=new t,l=M.gf;return l[0]=mm,l[1]=o,l[2]=u,l[3]=f,l[4]=B,l[5]=O,l[6]=r,l[7]=w,l[8]=p,l[9]=K,l[10]=z,l[11]=Y,l[12]=q,l[13]=x,l[14]=H,l[15]=E,M.markAsUpdated(),M}static Compose(mm,o,u){const f=new t;return t.ComposeToRef(mm,o,u,f),f}static ComposeToRef(mm,o,u,f){const B=f.gf,O=o._x,r=o._y,w=o._z,p=o._w,K=O+O,z=r+r,Y=w+w,q=O*K,x=O*z,H=O*Y,E=r*z,M=r*Y,l=w*Y,t=p*K,Q=p*z,b=p*Y,J=mm._x,N=mm._y,S=mm._z;return B[0]=(1-(E+l))*J,B[1]=(x+b)*J,B[2]=(H-Q)*J,B[3]=0,B[4]=(x-b)*N,B[5]=(1-(q+l))*N,B[6]=(M+t)*N,B[7]=0,B[8]=(H+Q)*S,B[9]=(M-t)*S,B[10]=(1-(q+E))*S,B[11]=0,B[12]=u._x,B[13]=u._y,B[14]=u._z,B[15]=1,f.markAsUpdated(),f}static Identity(){const mm=t.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return mm._updateIdentityStatus(!0),mm}static IdentityToRef(mm){return t.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,mm),mm._updateIdentityStatus(!0),mm}static Zero(){const mm=t.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return mm._updateIdentityStatus(!1),mm}static RotationX(mm){const o=new t;return t.RotationXToRef(mm,o),o}static Invert(mm){const o=new t;return mm.invertToRef(o),o}static RotationXToRef(mm,o){const u=Math.sin(mm),f=Math.cos(mm);return t.FromValuesToRef(1,0,0,0,0,f,u,0,0,-u,f,0,0,0,0,1,o),o._updateIdentityStatus(1===f&&0===u),o}static RotationY(mm){const o=new t;return t.RotationYToRef(mm,o),o}static RotationYToRef(mm,o){const u=Math.sin(mm),f=Math.cos(mm);return t.FromValuesToRef(f,0,-u,0,0,1,0,0,u,0,f,0,0,0,0,1,o),o._updateIdentityStatus(1===f&&0===u),o}static RotationZ(mm){const o=new t;return t.RotationZToRef(mm,o),o}static RotationZToRef(mm,o){const u=Math.sin(mm),f=Math.cos(mm);return t.FromValuesToRef(f,u,0,0,-u,f,0,0,0,0,1,0,0,0,0,1,o),o._updateIdentityStatus(1===f&&0===u),o}static RotationAxis(mm,o){const u=new t;return t.RotationAxisToRef(mm,o,u),u}static RotationAxisToRef(mm,o,u){const f=Math.sin(-o),B=Math.cos(-o),O=1-B;mm=mm.normalizeToRef(Q.lo[0]);const r=u.gf;return r[0]=mm._x*mm._x*O+B,r[1]=mm._x*mm._y*O-mm._z*f,r[2]=mm._x*mm._z*O+mm._y*f,r[3]=0,r[4]=mm._y*mm._x*O+mm._z*f,r[5]=mm._y*mm._y*O+B,r[6]=mm._y*mm._z*O-mm._x*f,r[7]=0,r[8]=mm._z*mm._x*O-mm._y*f,r[9]=mm._z*mm._y*O+mm._x*f,r[10]=mm._z*mm._z*O+B,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,u.markAsUpdated(),u}static RotationAlignToRef(mm,o,u){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const O=E.Dot(o,mm),r=u.gf;if(O<-1+f.e)r[0]=-1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=B?1:-1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=B?-1:1,r[11]=0;else{const u=E.Cross(o,mm),f=1/(1+O);r[0]=u._x*u._x*f+O,r[1]=u._y*u._x*f-u._z,r[2]=u._z*u._x*f+u._y,r[3]=0,r[4]=u._x*u._y*f+u._z,r[5]=u._y*u._y*f+O,r[6]=u._z*u._y*f-u._x,r[7]=0,r[8]=u._x*u._z*f-u._y,r[9]=u._y*u._z*f+u._x,r[10]=u._z*u._z*f+O,r[11]=0}return r[12]=0,r[13]=0,r[14]=0,r[15]=1,u.markAsUpdated(),u}static RotationYawPitchRoll(mm,o,u){const f=new t;return t.RotationYawPitchRollToRef(mm,o,u,f),f}static RotationYawPitchRollToRef(mm,o,u,f){return l.RotationYawPitchRollToRef(mm,o,u,Q.Quaternion[0]),Q.Quaternion[0].toRotationMatrix(f),f}static Scaling(mm,o,u){const f=new t;return t.ScalingToRef(mm,o,u,f),f}static ScalingToRef(mm,o,u,f){return t.FromValuesToRef(mm,0,0,0,0,o,0,0,0,0,u,0,0,0,0,1,f),f._updateIdentityStatus(1===mm&&1===o&&1===u),f}static Translation(mm,o,u){const f=new t;return t.TranslationToRef(mm,o,u,f),f}static TranslationToRef(mm,o,u,f){return t.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,mm,o,u,1,f),f._updateIdentityStatus(0===mm&&0===o&&0===u),f}static Lerp(mm,o,u){const f=new t;return t.LerpToRef(mm,o,u,f),f}static LerpToRef(mm,o,u,f){const B=f.gf,O=mm.m,r=o.m;for(let w=0;w<16;w++)B[w]=O[w]*(1-u)+r[w]*u;return f.markAsUpdated(),f}static DecomposeLerp(mm,o,u){const f=new t;return t.DecomposeLerpToRef(mm,o,u,f),f}static DecomposeLerpToRef(mm,o,u,f){const B=Q.lo[0],O=Q.Quaternion[0],r=Q.lo[1];mm.decompose(B,O,r);const w=Q.lo[2],p=Q.Quaternion[1],K=Q.lo[3];o.decompose(w,p,K);const z=Q.lo[4];E.LerpToRef(B,w,u,z);const Y=Q.Quaternion[2];l.SlerpToRef(O,p,u,Y);const q=Q.lo[5];return E.LerpToRef(r,K,u,q),t.ComposeToRef(z,Y,q,f),f}static LookAtLH(mm,o,u){const f=new t;return t.LookAtLHToRef(mm,o,u,f),f}static LookAtLHToRef(mm,o,u,f){const B=Q.lo[0],O=Q.lo[1],r=Q.lo[2];o.subtractToRef(mm,r),r.normalize(),E.CrossToRef(u,r,B);const w=B.lengthSquared();0===w?B.x=1:B.normalizeFromLength(Math.sqrt(w)),E.CrossToRef(r,B,O),O.normalize();const p=-E.Dot(B,mm),K=-E.Dot(O,mm),z=-E.Dot(r,mm);return t.FromValuesToRef(B._x,O._x,r._x,0,B._y,O._y,r._y,0,B._z,O._z,r._z,0,p,K,z,1,f),f}static LookAtRH(mm,o,u){const f=new t;return t.LookAtRHToRef(mm,o,u,f),f}static LookAtRHToRef(mm,o,u,f){const B=Q.lo[0],O=Q.lo[1],r=Q.lo[2];mm.subtractToRef(o,r),r.normalize(),E.CrossToRef(u,r,B);const w=B.lengthSquared();0===w?B.x=1:B.normalizeFromLength(Math.sqrt(w)),E.CrossToRef(r,B,O),O.normalize();const p=-E.Dot(B,mm),K=-E.Dot(O,mm),z=-E.Dot(r,mm);return t.FromValuesToRef(B._x,O._x,r._x,0,B._y,O._y,r._y,0,B._z,O._z,r._z,0,p,K,z,1,f),f}static LookDirectionLH(mm,o){const u=new t;return t.LookDirectionLHToRef(mm,o,u),u}static LookDirectionLHToRef(mm,o,u){const f=Q.lo[0];f.p(mm),f.scaleInPlace(-1);const B=Q.lo[1];return E.CrossToRef(o,f,B),t.FromValuesToRef(B._x,B._y,B._z,0,o._x,o._y,o._z,0,f._x,f._y,f._z,0,0,0,0,1,u),u}static LookDirectionRH(mm,o){const u=new t;return t.LookDirectionRHToRef(mm,o,u),u}static LookDirectionRHToRef(mm,o,u){const f=Q.lo[2];return E.CrossToRef(o,mm,f),t.FromValuesToRef(f._x,f._y,f._z,0,o._x,o._y,o._z,0,mm._x,mm._y,mm._z,0,0,0,0,1,u),u}static OrthoLH(mm,o,u,f,B){const O=new t;return t.OrthoLHToRef(mm,o,u,f,O,B),O}static OrthoLHToRef(mm,o,u,f,B,O){const r=2/mm,w=2/o,p=2/(f-u),K=-(f+u)/(f-u);return t.FromValuesToRef(r,0,0,0,0,w,0,0,0,0,p,0,0,0,K,1,B),O&&B.multiplyToRef(J,B),B._updateIdentityStatus(1===r&&1===w&&1===p&&0===K),B}static OrthoOffCenterLH(mm,o,u,f,B,O,r){const w=new t;return t.OrthoOffCenterLHToRef(mm,o,u,f,B,O,w,r),w}static OrthoOffCenterLHToRef(mm,o,u,f,B,O,r,w){const p=2/(o-mm),K=2/(f-u),z=2/(O-B),Y=-(O+B)/(O-B),q=(mm+o)/(mm-o),x=(f+u)/(u-f);return t.FromValuesToRef(p,0,0,0,0,K,0,0,0,0,z,0,q,x,Y,1,r),w&&r.multiplyToRef(J,r),r.markAsUpdated(),r}static ObliqueOffCenterLHToRef(mm,o,u,f,B,O,r,w,p,K,z){const Y=-r*Math.cos(w),q=-r*Math.sin(w);return t.TranslationToRef(0,0,-p,Q.Matrix[1]),t.FromValuesToRef(1,0,0,0,0,1,0,0,Y,q,1,0,0,0,0,1,Q.Matrix[0]),Q.Matrix[1].multiplyToRef(Q.Matrix[0],Q.Matrix[0]),t.TranslationToRef(0,0,p,Q.Matrix[1]),Q.Matrix[0].multiplyToRef(Q.Matrix[1],Q.Matrix[0]),t.OrthoOffCenterLHToRef(mm,o,u,f,B,O,K,z),Q.Matrix[0].multiplyToRef(K,K),K}static OrthoOffCenterRH(mm,o,u,f,B,O,r){const w=new t;return t.OrthoOffCenterRHToRef(mm,o,u,f,B,O,w,r),w}static OrthoOffCenterRHToRef(mm,o,u,f,B,O,r,w){return t.OrthoOffCenterLHToRef(mm,o,u,f,B,O,r,w),r.gf[10]*=-1,r}static ObliqueOffCenterRHToRef(mm,o,u,f,B,O,r,w,p,K,z){const Y=r*Math.cos(w),q=r*Math.sin(w);return t.TranslationToRef(0,0,p,Q.Matrix[1]),t.FromValuesToRef(1,0,0,0,0,1,0,0,Y,q,1,0,0,0,0,1,Q.Matrix[0]),Q.Matrix[1].multiplyToRef(Q.Matrix[0],Q.Matrix[0]),t.TranslationToRef(0,0,-p,Q.Matrix[1]),Q.Matrix[0].multiplyToRef(Q.Matrix[1],Q.Matrix[0]),t.OrthoOffCenterRHToRef(mm,o,u,f,B,O,K,z),Q.Matrix[0].multiplyToRef(K,K),K}static PerspectiveLH(mm,o,u,f,B){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const r=new t,w=2*u/mm,p=2*u/o,K=(f+u)/(f-u),z=-2*f*u/(f-u),Y=Math.tan(O);return t.FromValuesToRef(w,0,0,0,0,p,0,Y,0,0,K,1,0,0,z,0,r),B&&r.multiplyToRef(J,r),r._updateIdentityStatus(!1),r}static PerspectiveFovLH(mm,o,u,f,B){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,r=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const w=new t;return t.PerspectiveFovLHToRef(mm,o,u,f,w,!0,B,O,r),w}static PerspectiveFovLHToRef(mm,o,u,f,B){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],r=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,p=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const K=u,z=f,Y=1/Math.tan(.5*mm),q=O?Y/o:Y,x=O?Y:Y*o,H=p&&0===K?-1:0!==z?(z+K)/(z-K):1,E=p&&0===K?2*z:0!==z?-2*z*K/(z-K):-2*K,M=Math.tan(w);return t.FromValuesToRef(q,0,0,0,0,x,0,M,0,0,H,1,0,0,E,0,B),r&&B.multiplyToRef(J,B),B._updateIdentityStatus(!1),B}static PerspectiveFovReverseLHToRef(mm,o,u,f,B){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],r=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const p=1/Math.tan(.5*mm),K=O?p/o:p,z=O?p:p*o,Y=Math.tan(w);return t.FromValuesToRef(K,0,0,0,0,z,0,Y,0,0,-u,1,0,0,1,0,B),r&&B.multiplyToRef(J,B),B._updateIdentityStatus(!1),B}static PerspectiveFovRH(mm,o,u,f,B){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,r=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const w=new t;return t.PerspectiveFovRHToRef(mm,o,u,f,w,!0,B,O,r),w}static PerspectiveFovRHToRef(mm,o,u,f,B){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],r=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,p=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const K=u,z=f,Y=1/Math.tan(.5*mm),q=O?Y/o:Y,x=O?Y:Y*o,H=p&&0===K?1:0!==z?-(z+K)/(z-K):-1,E=p&&0===K?2*z:0!==z?-2*z*K/(z-K):-2*K,M=Math.tan(w);return t.FromValuesToRef(q,0,0,0,0,x,0,M,0,0,H,-1,0,0,E,0,B),r&&B.multiplyToRef(J,B),B._updateIdentityStatus(!1),B}static PerspectiveFovReverseRHToRef(mm,o,u,f,B){let O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],r=arguments.length>6?arguments[6]:void 0,w=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const p=1/Math.tan(.5*mm),K=O?p/o:p,z=O?p:p*o,Y=Math.tan(w);return t.FromValuesToRef(K,0,0,0,0,z,0,Y,0,0,-u,-1,0,0,-1,0,B),r&&B.multiplyToRef(J,B),B._updateIdentityStatus(!1),B}static GetFinalMatrix(mm,o,u,f,B,O){const r=mm.width,w=mm.height,p=mm.x,K=mm.y,z=t.FromValues(r/2,0,0,0,0,-w/2,0,0,0,0,O-B,0,p+r/2,w/2+K,B,1),Y=new t;return o.multiplyToRef(u,Y),Y.multiplyToRef(f,Y),Y.multiplyToRef(z,Y)}static GetAsMatrix2x2(mm){const o=mm.m,u=[o[0],o[1],o[4],o[5]];return r.b.MatrixUse64Bits?u:new Float32Array(u)}static GetAsMatrix3x3(mm){const o=mm.m,u=[o[0],o[1],o[2],o[4],o[5],o[6],o[8],o[9],o[10]];return r.b.MatrixUse64Bits?u:new Float32Array(u)}static Transpose(mm){const o=new t;return t.TransposeToRef(mm,o),o}static TransposeToRef(mm,o){const u=mm.m,f=u[0],B=u[4],O=u[8],r=u[12],w=u[1],p=u[5],K=u[9],z=u[13],Y=u[2],q=u[6],x=u[10],H=u[14],E=u[3],M=u[7],l=u[11],t=u[15],Q=o.gf;return Q[0]=f,Q[1]=B,Q[2]=O,Q[3]=r,Q[4]=w,Q[5]=p,Q[6]=K,Q[7]=z,Q[8]=Y,Q[9]=q,Q[10]=x,Q[11]=H,Q[12]=E,Q[13]=M,Q[14]=l,Q[15]=t,o.markAsUpdated(),o._updateIdentityStatus(mm._isIdentity,mm._isIdentityDirty),o}static Reflection(mm){const o=new t;return t.ReflectionToRef(mm,o),o}static ReflectionToRef(mm,o){mm.normalize();const u=mm.normal.x,f=mm.normal.y,B=mm.normal.z,O=-2*u,r=-2*f,w=-2*B;return t.FromValuesToRef(O*u+1,r*u,w*u,0,O*f,r*f+1,w*f,0,O*B,r*B,w*B+1,0,O*mm.d,r*mm.d,w*mm.d,1,o),o}static FromXYZAxesToRef(mm,o,u,f){return t.FromValuesToRef(mm._x,mm._y,mm._z,0,o._x,o._y,o._z,0,u._x,u._y,u._z,0,0,0,0,1,f),f}static FromQuaternionToRef(mm,o){const u=mm._x*mm._x,f=mm._y*mm._y,B=mm._z*mm._z,O=mm._x*mm._y,r=mm._z*mm._w,w=mm._z*mm._x,p=mm._y*mm._w,K=mm._y*mm._z,z=mm._x*mm._w;return o.gf[0]=1-2*(f+B),o.gf[1]=2*(O+r),o.gf[2]=2*(w-p),o.gf[3]=0,o.gf[4]=2*(O-r),o.gf[5]=1-2*(B+u),o.gf[6]=2*(K+z),o.gf[7]=0,o.gf[8]=2*(w+p),o.gf[9]=2*(K-z),o.gf[10]=1-2*(f+u),o.gf[11]=0,o.gf[12]=0,o.gf[13]=0,o.gf[14]=0,o.gf[15]=1,o.markAsUpdated(),o}}t._IdentityReadOnly=t.Identity(),Object.defineProperties(t.prototype,{dimension:{value:[4,4]},rank:{value:2}});class Q{}Q.lo=(0,B.c)(11,E.Zero),Q.Matrix=(0,B.c)(2,t.Identity),Q.Quaternion=(0,B.c)(3,l.Zero);class b{}b.Vector2=(0,B.c)(3,H.Zero),b.lo=(0,B.c)(13,E.Zero),b.Vector4=(0,B.c)(3,M.Zero),b.Quaternion=(0,B.c)(3,l.Zero),b.Matrix=(0,B.c)(8,t.Identity),(0,O.c)("BABYLON.Vector2",H),(0,O.c)("BABYLON.Vector3",E),(0,O.c)("BABYLON.Vector4",M),(0,O.c)("BABYLON.Matrix",t);const J=t.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12748:(mm,o,u)=>{function f(mm,o){const u=[];for(let f=0;f<mm;++f)u.push(o());return u}function B(mm,o){return f(mm,o)}u.d(o,{b:()=>f,c:()=>B,f:()=>r});const O=["push","splice","pop","shift","unshift"];function r(mm,o){const u=O.map((u=>function(mm,o,u){const f=mm[o];if("function"!==typeof f)return null;const B=function(){const f=mm.length,O=B.previous.apply(mm,arguments);return u(o,f),O};return f.next=B,B.previous=f,mm[o]=B,()=>{const u=B.previous;if(!u)return;const f=B.next;f?(u.next=f,f.previous=u):(u.next=void 0,mm[o]=u),B.next=void 0,B.previous=void 0}}(mm,u,o)));return()=>{for(const mm of u)null===mm||void 0===mm||mm()}}}}]);