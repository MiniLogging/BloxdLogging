"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[14],{12598:(L,U,x)=>{x.d(U,{c:()=>F,d:()=>G,f:()=>mL,g:()=>p});const mL=1/2.2,p=2.2,G=(1+Math.sqrt(5))/2,F=.001},12610:(L,U,x)=>{function mL(L){return parseInt(L.toString().replace(/\W/g,""))}function p(L,U){let x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(L-U)<=x}function G(L,U,x){let mL=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return L<U-mL||L>x+mL}function F(L,U){return L===U?L:Math.random()*(U-L)+L}function a(L,U,x){return L+(U-L)*x}function o(L,U,x){let mL=V(U-L,360);return mL>180&&(mL-=360),L+mL*b(x)}function A(L,U,x){let mL=0;return mL=L!=U?b((x-L)/(U-L)):0,mL}function r(L,U,x,mL,p){const G=p*p,F=p*G;return L*(2*F-3*G+1)+x*(-2*F+3*G)+U*(F-2*G+p)+mL*(F-G)}function h(L,U,x,mL,p){const G=p*p;return 6*(G-p)*L+(3*G-4*p+1)*U+6*(-G+p)*x+(3*G-2*p)*mL}function b(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(x,Math.max(U,L))}function E(L){return L-=2*Math.PI*Math.floor((L+Math.PI)/(2*Math.PI))}function Y(L){const U=L.toString(16);return L<=15?("0"+U).toUpperCase():U.toUpperCase()}function S(L){if(Math.log2)return Math.floor(Math.log2(L));if(L<0)return NaN;if(0===L)return-1/0;let U=0;if(L<1){for(;L<1;)U++,L*=2;U=-U}else if(L>1)for(;L>1;)U++,L=Math.floor(L/2);return U}function V(L,U){return L-Math.floor(L/U)*U}function H(L,U,x){return(L-U)/(x-U)}function Q(L,U,x){return L*(x-U)+U}function q(L,U){let x=V(U-L,360);return x>180&&(x-=360),x}function f(L,U){const x=V(L,2*U);return U-Math.abs(x-U)}function v(L,U,x){let mL=b(x);return mL=-2*mL*mL*mL+3*mL*mL,U*mL+L*(1-mL)}function D(L,U,x){let mL=0;return mL=Math.abs(U-L)<=x?U:L+Math.sign(U-L)*x,mL}function P(L,U,x){const mL=q(L,U);let p=0;return p=-x<mL&&mL<x?U:D(L,U=L+mL,x),p}function d(L,U,x){return(L-U)/(x-U)}function K(L,U,x){return(x-U)*L+U}function l(L,U){const x=L%U;return 0===x?U:l(U,x)}x.r(U),x.d(U,{Clamp:()=>b,DeltaAngle:()=>q,Denormalize:()=>Q,ExtractAsInt:()=>mL,Hermite:()=>r,Hermite1stDerivative:()=>h,HighestCommonFactor:()=>l,ILog2:()=>S,InverseLerp:()=>A,Lerp:()=>a,LerpAngle:()=>o,MoveTowards:()=>D,MoveTowardsAngle:()=>P,Normalize:()=>H,NormalizeRadians:()=>E,OutsideRange:()=>G,PercentToRange:()=>K,PingPong:()=>f,RandomRange:()=>F,RangeToPercent:()=>d,Repeat:()=>V,SmoothStep:()=>v,ToHex:()=>Y,WithinEpsilon:()=>p})},12589:(L,U,x)=>{x.r(U),x.d(U,{Matrix:()=>Q,Quaternion:()=>H,TmpVectors:()=>f,Vector2:()=>Y,YU:()=>S,Vector4:()=>V});var mL=x(12598),p=x(12602),G=x(12547),F=x(12515),a=x(12440),o=x(12610);class A{}function r(L,U,x){let mL=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const p=L.Va(),G=U.Va(),F=p[0],a=p[1],o=p[2],A=p[3],r=p[4],h=p[5],b=p[6],E=p[7],Y=p[8],S=p[9],V=p[10],H=p[11],Q=p[12],q=p[13],f=p[14],v=p[15],D=G[0],P=G[1],d=G[2],K=G[3],l=G[4],i=G[5],X=G[6],t=G[7],y=G[8],n=G[9],N=G[10],e=G[11],u=G[12],Z=G[13],g=G[14],z=G[15];x[mL]=F*D+a*l+o*y+A*u,x[mL+1]=F*P+a*i+o*n+A*Z,x[mL+2]=F*d+a*X+o*N+A*g,x[mL+3]=F*K+a*t+o*e+A*z,x[mL+4]=r*D+h*l+b*y+E*u,x[mL+5]=r*P+h*i+b*n+E*Z,x[mL+6]=r*d+h*X+b*N+E*g,x[mL+7]=r*K+h*t+b*e+E*z,x[mL+8]=Y*D+S*l+V*y+H*u,x[mL+9]=Y*P+S*i+V*n+H*Z,x[mL+10]=Y*d+S*X+V*N+H*g,x[mL+11]=Y*K+S*t+V*e+H*z,x[mL+12]=Q*D+q*l+f*y+v*u,x[mL+13]=Q*P+q*i+f*n+v*Z,x[mL+14]=Q*d+q*X+f*N+v*g,x[mL+15]=Q*K+q*t+f*e+v*z}function h(L,U){let x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const mL=L.Va();U[x]=mL[0],U[x+1]=mL[1],U[x+2]=mL[2],U[x+3]=mL[3],U[x+4]=mL[4],U[x+5]=mL[5],U[x+6]=mL[6],U[x+7]=mL[7],U[x+8]=mL[8],U[x+9]=mL[9],U[x+10]=mL[10],U[x+11]=mL[11],U[x+12]=mL[12],U[x+13]=mL[13],U[x+14]=mL[14],U[x+15]=mL[15]}function b(L,U){const x=L.Va(),mL=x[0],p=x[1],G=x[2],F=x[3],a=x[4],o=x[5],A=x[6],r=x[7],h=x[8],b=x[9],E=x[10],Y=x[11],S=x[12],V=x[13],H=x[14],Q=x[15],q=E*Q-H*Y,f=b*Q-V*Y,v=b*H-V*E,D=h*Q-S*Y,P=h*H-E*S,d=h*V-S*b,K=+(o*q-A*f+r*v),l=-(a*q-A*D+r*P),i=+(a*f-o*D+r*d),X=-(a*v-o*P+A*d),t=mL*K+p*l+G*i+F*X;if(0===t)return!1;const y=1/t,n=A*Q-H*r,N=o*Q-V*r,e=o*H-V*A,u=a*Q-S*r,Z=a*H-S*A,g=a*V-S*o,z=A*Y-E*r,M=o*Y-b*r,J=o*E-b*A,j=a*Y-h*r,R=a*E-h*A,c=a*b-h*o,W=-(p*q-G*f+F*v),I=+(mL*q-G*D+F*P),w=-(mL*f-p*D+F*d),B=+(mL*v-p*P+G*d),s=+(p*n-G*N+F*e),C=-(mL*n-G*u+F*Z),k=+(mL*N-p*u+F*g),T=-(mL*e-p*Z+G*g),O=-(p*z-G*M+F*J),LL=+(mL*z-G*j+F*R),UL=-(mL*M-p*j+F*c),xL=+(mL*J-p*R+G*c);return U[0]=K*y,U[1]=W*y,U[2]=s*y,U[3]=O*y,U[4]=l*y,U[5]=I*y,U[6]=C*y,U[7]=LL*y,U[8]=i*y,U[9]=w*y,U[10]=k*y,U[11]=UL*y,U[12]=X*y,U[13]=B*y,U[14]=T*y,U[15]=xL*y,!0}A._UpdateFlagSeed=0;const E=L=>parseInt(L.toString().replace(/\W/g,""));class Y{constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=L,this.y=U}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let L=E(this.x);return L=397*L^E(this.y),L}toArray(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L[U]=this.x,L[U+1]=this.y,this}Vx(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y.FromArrayToRef(L,U,this),this}Va(){return[this.x,this.y]}p(L){return this.x=L.x,this.y=L.y,this}da(L,U){return this.x=L,this.y=U,this}set(L,U){return this.da(L,U)}la(L){return this.da(L,L)}add(L){return new Y(this.x+L.x,this.y+L.y)}addToRef(L,U){return U.x=this.x+L.x,U.y=this.y+L.y,U}addInPlace(L){return this.x+=L.x,this.y+=L.y,this}addInPlaceFromFloats(L,U){return this.x+=L,this.y+=U,this}addVector3(L){return new Y(this.x+L.x,this.y+L.y)}SU(L){return new Y(this.x-L.x,this.y-L.y)}subtractToRef(L,U){return U.x=this.x-L.x,U.y=this.y-L.y,U}dh(L){return this.x-=L.x,this.y-=L.y,this}multiplyInPlace(L){return this.x*=L.x,this.y*=L.y,this}multiply(L){return new Y(this.x*L.x,this.y*L.y)}multiplyToRef(L,U){return U.x=this.x*L.x,U.y=this.y*L.y,U}multiplyByFloats(L,U){return new Y(this.x*L,this.y*U)}divide(L){return new Y(this.x/L.x,this.y/L.y)}divideToRef(L,U){return U.x=this.x/L.x,U.y=this.y/L.y,U}divideInPlace(L){return this.x=this.x/L.x,this.y=this.y/L.y,this}minimizeInPlace(L){return this.minimizeInPlaceFromFloats(L.x,L.y)}maximizeInPlace(L){return this.maximizeInPlaceFromFloats(L.x,L.y)}minimizeInPlaceFromFloats(L,U){return this.x=Math.min(L,this.x),this.y=Math.min(U,this.y),this}maximizeInPlaceFromFloats(L,U){return this.x=Math.max(L,this.x),this.y=Math.max(U,this.y),this}subtractFromFloats(L,U){return new Y(this.x-L,this.y-U)}subtractFromFloatsToRef(L,U,x){return x.x=this.x-L,x.y=this.y-U,x}negate(){return new Y(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(L){return L.x=-this.x,L.y=-this.y,L}scaleInPlace(L){return this.x*=L,this.y*=L,this}scale(L){return new Y(this.x*L,this.y*L)}scaleToRef(L,U){return U.x=this.x*L,U.y=this.y*L,U}scaleAndAddToRef(L,U){return U.x+=this.x*L,U.y+=this.y*L,U}equals(L){return L&&this.x===L.x&&this.y===L.y}equalsWithEpsilon(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mL.c;return L&&(0,o.WithinEpsilon)(this.x,L.x,U)&&(0,o.WithinEpsilon)(this.y,L.y,U)}equalsToFloats(L,U){return this.x===L&&this.y===U}floor(){return new Y(Math.floor(this.x),Math.floor(this.y))}floorToRef(L){return L.x=Math.floor(this.x),L.y=Math.floor(this.y),L}fract(){return new Y(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(L){return L.x=this.x-Math.floor(this.x),L.y=this.y-Math.floor(this.y),L}rotate(L){return this.rotateToRef(L,new Y)}rotateToRef(L,U){const x=Math.cos(L),mL=Math.sin(L);return U.x=x*this.x-mL*this.y,U.y=mL*this.x+x*this.y,U}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(L){return 0===L||1===L?this:this.scaleInPlace(1/L)}normalizeToNew(){const L=new Y;return this.normalizeToRef(L),L}normalizeToRef(L){const U=this.length();return 0===U&&(L.x=this.x,L.y=this.y),this.scaleToRef(1/U,L)}clone(){return new Y(this.x,this.y)}dot(L){return this.x*L.x+this.y*L.y}static Zero(){return new Y(0,0)}static One(){return new Y(1,1)}static Random(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Y((0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U))}static RandomToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).da((0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U))}static get ZeroReadOnly(){return Y._ZeroReadOnly}static qU(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Y(L[U],L[U+1])}static FromArrayToRef(L,U,x){return x.x=L[U],x.y=L[U+1],x}static FromFloatsToRef(L,U,x){return x.da(L,U),x}static CatmullRom(L,U,x,mL,p){const G=p*p,F=p*G,a=.5*(2*U.x+(-L.x+x.x)*p+(2*L.x-5*U.x+4*x.x-mL.x)*G+(-L.x+3*U.x-3*x.x+mL.x)*F),o=.5*(2*U.y+(-L.y+x.y)*p+(2*L.y-5*U.y+4*x.y-mL.y)*G+(-L.y+3*U.y-3*x.y+mL.y)*F);return new Y(a,o)}static ClampToRef(L,U,x,mL){return mL.x=(0,o.Clamp)(L.x,U.x,x.x),mL.y=(0,o.Clamp)(L.y,U.y,x.y),mL}static Clamp(L,U,x){const mL=(0,o.Clamp)(L.x,U.x,x.x),p=(0,o.Clamp)(L.y,U.y,x.y);return new Y(mL,p)}static Hermite(L,U,x,mL,p){const G=p*p,F=p*G,a=2*F-3*G+1,o=-2*F+3*G,A=F-2*G+p,r=F-G,h=L.x*a+x.x*o+U.x*A+mL.x*r,b=L.y*a+x.y*o+U.y*A+mL.y*r;return new Y(h,b)}static Hermite1stDerivative(L,U,x,mL,p){return this.Hermite1stDerivativeToRef(L,U,x,mL,p,new Y)}static Hermite1stDerivativeToRef(L,U,x,mL,p,G){const F=p*p;return G.x=6*(F-p)*L.x+(3*F-4*p+1)*U.x+6*(-F+p)*x.x+(3*F-2*p)*mL.x,G.y=6*(F-p)*L.y+(3*F-4*p+1)*U.y+6*(-F+p)*x.y+(3*F-2*p)*mL.y,G}static Lerp(L,U,x){return Y.LerpToRef(L,U,x,new Y)}static LerpToRef(L,U,x,mL){return mL.x=L.x+(U.x-L.x)*x,mL.y=L.y+(U.y-L.y)*x,mL}static Dot(L,U){return L.x*U.x+L.y*U.y}static Normalize(L){return Y.NormalizeToRef(L,new Y)}static NormalizeToRef(L,U){return L.normalizeToRef(U),U}static Minimize(L,U){const x=L.x<U.x?L.x:U.x,mL=L.y<U.y?L.y:U.y;return new Y(x,mL)}static Maximize(L,U){const x=L.x>U.x?L.x:U.x,mL=L.y>U.y?L.y:U.y;return new Y(x,mL)}static Transform(L,U){return Y.TransformToRef(L,U,new Y)}static TransformToRef(L,U,x){const mL=U.m,p=L.x*mL[0]+L.y*mL[4]+mL[12],G=L.x*mL[1]+L.y*mL[5]+mL[13];return x.x=p,x.y=G,x}static PointInTriangle(L,U,x,mL){const p=.5*(-x.y*mL.x+U.y*(-x.x+mL.x)+U.x*(x.y-mL.y)+x.x*mL.y),G=p<0?-1:1,F=(U.y*mL.x-U.x*mL.y+(mL.y-U.y)*L.x+(U.x-mL.x)*L.y)*G,a=(U.x*x.y-U.y*x.x+(U.y-x.y)*L.x+(x.x-U.x)*L.y)*G;return F>0&&a>0&&F+a<2*p*G}static Distance(L,U){return Math.sqrt(Y.DistanceSquared(L,U))}static DistanceSquared(L,U){const x=L.x-U.x,mL=L.y-U.y;return x*x+mL*mL}static Center(L,U){return Y.CenterToRef(L,U,new Y)}static CenterToRef(L,U,x){return x.da((L.x+U.x)/2,(L.y+U.y)/2)}static DistanceOfPointFromSegment(L,U,x){const mL=Y.DistanceSquared(U,x);if(0===mL)return Y.Distance(L,U);const p=x.SU(U),G=Math.max(0,Math.min(1,Y.Dot(L.SU(U),p)/mL)),F=U.add(p.multiplyByFloats(G,G));return Y.Distance(L,F)}}Y._V8PerformanceHack=new Y(.5,.5),Y._ZeroReadOnly=Y.Zero(),Object.defineProperties(Y.prototype,{dimension:{value:[2]},rank:{value:1}});class S{get x(){return this._x}set x(L){this._x=L,this._isDirty=!0}get y(){return this._y}set y(L){this._y=L,this._isDirty=!0}get z(){return this._z}set z(L){this._z=L,this._isDirty=!0}constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=L,this._y=U,this._z=x}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"YU"}getHashCode(){let L=E(this._x);return L=397*L^E(this._y),L=397*L^E(this._z),L}Va(){return[this._x,this._y,this._z]}toArray(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L[U]=this._x,L[U+1]=this._y,L[U+2]=this._z,this}Vx(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(L,U,this),this}toQuaternion(){return H.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(L){return this._x+=L._x,this._y+=L._y,this._z+=L._z,this._isDirty=!0,this}addInPlaceFromFloats(L,U,x){return this._x+=L,this._y+=U,this._z+=x,this._isDirty=!0,this}add(L){return new S(this._x+L._x,this._y+L._y,this._z+L._z)}addToRef(L,U){return U._x=this._x+L._x,U._y=this._y+L._y,U._z=this._z+L._z,U._isDirty=!0,U}dh(L){return this._x-=L._x,this._y-=L._y,this._z-=L._z,this._isDirty=!0,this}SU(L){return new S(this._x-L._x,this._y-L._y,this._z-L._z)}subtractToRef(L,U){return this.subtractFromFloatsToRef(L._x,L._y,L._z,U)}subtractFromFloats(L,U,x){return new S(this._x-L,this._y-U,this._z-x)}subtractFromFloatsToRef(L,U,x,mL){return mL._x=this._x-L,mL._y=this._y-U,mL._z=this._z-x,mL._isDirty=!0,mL}negate(){return new S(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(L){return L._x=-1*this._x,L._y=-1*this._y,L._z=-1*this._z,L._isDirty=!0,L}scaleInPlace(L){return this._x*=L,this._y*=L,this._z*=L,this._isDirty=!0,this}scale(L){return new S(this._x*L,this._y*L,this._z*L)}scaleToRef(L,U){return U._x=this._x*L,U._y=this._y*L,U._z=this._z*L,U._isDirty=!0,U}getNormalToRef(L){const U=this.length();let x=Math.acos(this._y/U);const mL=Math.atan2(this._z,this._x);x>Math.PI/2?x-=Math.PI/2:x+=Math.PI/2;const p=U*Math.sin(x)*Math.cos(mL),G=U*Math.cos(x),F=U*Math.sin(x)*Math.sin(mL);return L.set(p,G,F),L}applyRotationQuaternionToRef(L,U){const x=this._x,mL=this._y,p=this._z,G=L._x,F=L._y,a=L._z,o=L._w,A=2*(F*p-a*mL),r=2*(a*x-G*p),h=2*(G*mL-F*x);return U._x=x+o*A+F*h-a*r,U._y=mL+o*r+a*A-G*h,U._z=p+o*h+G*r-F*A,U._isDirty=!0,U}applyRotationQuaternionInPlace(L){return this.applyRotationQuaternionToRef(L,this)}applyRotationQuaternion(L){return this.applyRotationQuaternionToRef(L,new S)}scaleAndAddToRef(L,U){return U._x+=this._x*L,U._y+=this._y*L,U._z+=this._z*L,U._isDirty=!0,U}projectOnPlane(L,U){return this.projectOnPlaneToRef(L,U,new S)}projectOnPlaneToRef(L,U,x){const mL=L.normal,p=L.d,G=q.YU[0];this.subtractToRef(U,G),G.normalize();const F=S.Dot(G,mL);if(Math.abs(F)<1e-10)x.la(1/0);else{const L=-(S.Dot(U,mL)+p)/F,a=G.scaleInPlace(L);U.addToRef(a,x)}return x}equals(L){return L&&this._x===L._x&&this._y===L._y&&this._z===L._z}equalsWithEpsilon(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mL.c;return L&&(0,o.WithinEpsilon)(this._x,L._x,U)&&(0,o.WithinEpsilon)(this._y,L._y,U)&&(0,o.WithinEpsilon)(this._z,L._z,U)}equalsToFloats(L,U,x){return this._x===L&&this._y===U&&this._z===x}multiplyInPlace(L){return this._x*=L._x,this._y*=L._y,this._z*=L._z,this._isDirty=!0,this}multiply(L){return this.multiplyByFloats(L._x,L._y,L._z)}multiplyToRef(L,U){return U._x=this._x*L._x,U._y=this._y*L._y,U._z=this._z*L._z,U._isDirty=!0,U}multiplyByFloats(L,U,x){return new S(this._x*L,this._y*U,this._z*x)}divide(L){return new S(this._x/L._x,this._y/L._y,this._z/L._z)}divideToRef(L,U){return U._x=this._x/L._x,U._y=this._y/L._y,U._z=this._z/L._z,U._isDirty=!0,U}divideInPlace(L){return this._x=this._x/L._x,this._y=this._y/L._y,this._z=this._z/L._z,this._isDirty=!0,this}minimizeInPlace(L){return this.minimizeInPlaceFromFloats(L._x,L._y,L._z)}maximizeInPlace(L){return this.maximizeInPlaceFromFloats(L._x,L._y,L._z)}minimizeInPlaceFromFloats(L,U,x){return L<this._x&&(this.x=L),U<this._y&&(this.y=U),x<this._z&&(this.z=x),this}maximizeInPlaceFromFloats(L,U,x){return L>this._x&&(this.x=L),U>this._y&&(this.y=U),x>this._z&&(this.z=x),this}isNonUniformWithinEpsilon(L){const U=Math.abs(this._x),x=Math.abs(this._y);if(!(0,o.WithinEpsilon)(U,x,L))return!0;const mL=Math.abs(this._z);return!(0,o.WithinEpsilon)(U,mL,L)||!(0,o.WithinEpsilon)(x,mL,L)}get isNonUniform(){const L=Math.abs(this._x);if(L!==Math.abs(this._y))return!0;return L!==Math.abs(this._z)}floorToRef(L){return L._x=Math.floor(this._x),L._y=Math.floor(this._y),L._z=Math.floor(this._z),L._isDirty=!0,L}floor(){return new S(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(L){return L._x=this._x-Math.floor(this._x),L._y=this._y-Math.floor(this._y),L._z=this._z-Math.floor(this._z),L._isDirty=!0,L}fract(){return new S(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(L){if("xyz"===(L=L.toLowerCase()))return this;const U=q.YU[0].p(this);return this.x=U[L[0]],this.y=U[L[1]],this.z=U[L[2]],this}rotateByQuaternionToRef(L,U){return L.toRotationMatrix(q.Matrix[0]),S.TransformCoordinatesToRef(this,q.Matrix[0],U),U}rotateByQuaternionAroundPointToRef(L,U,x){return this.subtractToRef(U,q.YU[0]),q.YU[0].rotateByQuaternionToRef(L,q.YU[0]),U.addToRef(q.YU[0],x),x}cross(L){return S.CrossToRef(this,L,new S)}normalizeFromLength(L){return 0===L||1===L?this:this.scaleInPlace(1/L)}normalizeToNew(){return this.normalizeToRef(new S)}normalizeToRef(L){const U=this.length();return 0===U||1===U?(L._x=this._x,L._y=this._y,L._z=this._z,L._isDirty=!0,L):this.scaleToRef(1/U,L)}clone(){return new S(this._x,this._y,this._z)}p(L){return this.da(L._x,L._y,L._z)}da(L,U,x){return this._x=L,this._y=U,this._z=x,this._isDirty=!0,this}set(L,U,x){return this.da(L,U,x)}la(L){return this._x=this._y=this._z=L,this._isDirty=!0,this}static GetClipFactor(L,U,x,mL){const p=S.Dot(L,x);return(p-mL)/(p-S.Dot(U,x))}static GetAngleBetweenVectors(L,U,x){const mL=L.normalizeToRef(q.YU[1]),p=U.normalizeToRef(q.YU[2]);let G=S.Dot(mL,p);G=(0,o.Clamp)(G,-1,1);const F=Math.acos(G),a=q.YU[3];return S.CrossToRef(mL,p,a),S.Dot(a,x)>0?isNaN(F)?0:F:isNaN(F)?-Math.PI:-Math.acos(G)}static GetAngleBetweenVectorsOnPlane(L,U,x){q.YU[0].p(L);const mL=q.YU[0];q.YU[1].p(U);const p=q.YU[1];q.YU[2].p(x);const G=q.YU[2],F=q.YU[3],a=q.YU[4];mL.normalize(),p.normalize(),G.normalize(),S.CrossToRef(G,mL,F),S.CrossToRef(F,G,a);const A=Math.atan2(S.Dot(p,F),S.Dot(p,a));return(0,o.NormalizeRadians)(A)}static PitchYawRollToMoveBetweenPointsToRef(L,U,x){const mL=f.YU[0];return U.subtractToRef(L,mL),x._y=Math.atan2(mL.x,mL.z)||0,x._x=Math.atan2(Math.sqrt(mL.x**2+mL.z**2),mL.y)||0,x._z=0,x._isDirty=!0,x}static PitchYawRollToMoveBetweenPoints(L,U){const x=S.Zero();return S.PitchYawRollToMoveBetweenPointsToRef(L,U,x)}static SlerpToRef(L,U,x,p){x=(0,o.Clamp)(x,0,1);const G=q.YU[0],F=q.YU[1];G.p(L);const a=G.length();G.normalizeFromLength(a),F.p(U);const A=F.length();F.normalizeFromLength(A);const r=S.Dot(G,F);let h,b;if(r<1-mL.c){const L=Math.acos(r),U=1/Math.sin(L);h=Math.sin((1-x)*L)*U,b=Math.sin(x*L)*U}else h=1-x,b=x;return G.scaleInPlace(h),F.scaleInPlace(b),p.p(G).addInPlace(F),p.scaleInPlace((0,o.Lerp)(a,A,x)),p}static SmoothToRef(L,U,x,mL,p){return S.SlerpToRef(L,U,0===mL?1:x/mL,p),p}static qU(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new S(L[U],L[U+1],L[U+2])}static FromFloatArray(L,U){return S.qU(L,U)}static FromArrayToRef(L,U,x){return x._x=L[U],x._y=L[U+1],x._z=L[U+2],x._isDirty=!0,x}static FromFloatArrayToRef(L,U,x){return S.FromArrayToRef(L,U,x)}static FromFloatsToRef(L,U,x,mL){return mL.da(L,U,x),mL}static Zero(){return new S(0,0,0)}static One(){return new S(1,1,1)}static Up(){return new S(0,1,0)}static get UpReadOnly(){return S._UpReadOnly}static get DownReadOnly(){return S._DownReadOnly}static get RightReadOnly(){return S._RightReadOnly}static get LeftReadOnly(){return S._LeftReadOnly}static get LeftHandedForwardReadOnly(){return S._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return S._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return S._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return S._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return S._ZeroReadOnly}static get OneReadOnly(){return S._OneReadOnly}static Down(){return new S(0,-1,0)}static Forward(){return new S(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new S(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new S(1,0,0)}static Left(){return new S(-1,0,0)}static Random(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new S((0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U))}static RandomToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).da((0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U))}static TransformCoordinates(L,U){const x=S.Zero();return S.TransformCoordinatesToRef(L,U,x),x}static TransformCoordinatesToRef(L,U,x){return S.TransformCoordinatesFromFloatsToRef(L._x,L._y,L._z,U,x),x}static TransformCoordinatesFromFloatsToRef(L,U,x,mL,p){const G=mL.m,F=L*G[0]+U*G[4]+x*G[8]+G[12],a=L*G[1]+U*G[5]+x*G[9]+G[13],o=L*G[2]+U*G[6]+x*G[10]+G[14],A=1/(L*G[3]+U*G[7]+x*G[11]+G[15]);return p._x=F*A,p._y=a*A,p._z=o*A,p._isDirty=!0,p}static TransformNormal(L,U){const x=S.Zero();return S.TransformNormalToRef(L,U,x),x}static TransformNormalToRef(L,U,x){return this.TransformNormalFromFloatsToRef(L._x,L._y,L._z,U,x),x}static TransformNormalFromFloatsToRef(L,U,x,mL,p){const G=mL.m;return p._x=L*G[0]+U*G[4]+x*G[8],p._y=L*G[1]+U*G[5]+x*G[9],p._z=L*G[2]+U*G[6]+x*G[10],p._isDirty=!0,p}static CatmullRom(L,U,x,mL,p){const G=p*p,F=p*G,a=.5*(2*U._x+(-L._x+x._x)*p+(2*L._x-5*U._x+4*x._x-mL._x)*G+(-L._x+3*U._x-3*x._x+mL._x)*F),o=.5*(2*U._y+(-L._y+x._y)*p+(2*L._y-5*U._y+4*x._y-mL._y)*G+(-L._y+3*U._y-3*x._y+mL._y)*F),A=.5*(2*U._z+(-L._z+x._z)*p+(2*L._z-5*U._z+4*x._z-mL._z)*G+(-L._z+3*U._z-3*x._z+mL._z)*F);return new S(a,o,A)}static Clamp(L,U,x){const mL=new S;return S.ClampToRef(L,U,x,mL),mL}static ClampToRef(L,U,x,mL){let p=L._x;p=p>x._x?x._x:p,p=p<U._x?U._x:p;let G=L._y;G=G>x._y?x._y:G,G=G<U._y?U._y:G;let F=L._z;return F=F>x._z?x._z:F,F=F<U._z?U._z:F,mL.da(p,G,F),mL}static CheckExtends(L,U,x){U.minimizeInPlace(L),x.maximizeInPlace(L)}static Hermite(L,U,x,mL,p){const G=p*p,F=p*G,a=2*F-3*G+1,o=-2*F+3*G,A=F-2*G+p,r=F-G,h=L._x*a+x._x*o+U._x*A+mL._x*r,b=L._y*a+x._y*o+U._y*A+mL._y*r,E=L._z*a+x._z*o+U._z*A+mL._z*r;return new S(h,b,E)}static Hermite1stDerivative(L,U,x,mL,p){const G=new S;return this.Hermite1stDerivativeToRef(L,U,x,mL,p,G),G}static Hermite1stDerivativeToRef(L,U,x,mL,p,G){const F=p*p;return G._x=6*(F-p)*L._x+(3*F-4*p+1)*U._x+6*(-F+p)*x._x+(3*F-2*p)*mL._x,G._y=6*(F-p)*L._y+(3*F-4*p+1)*U._y+6*(-F+p)*x._y+(3*F-2*p)*mL._y,G._z=6*(F-p)*L._z+(3*F-4*p+1)*U._z+6*(-F+p)*x._z+(3*F-2*p)*mL._z,G._isDirty=!0,G}static Lerp(L,U,x){const mL=new S(0,0,0);return S.LerpToRef(L,U,x,mL),mL}static LerpToRef(L,U,x,mL){return mL._x=L._x+(U._x-L._x)*x,mL._y=L._y+(U._y-L._y)*x,mL._z=L._z+(U._z-L._z)*x,mL._isDirty=!0,mL}static Dot(L,U){return L._x*U._x+L._y*U._y+L._z*U._z}dot(L){return this._x*L._x+this._y*L._y+this._z*L._z}static Cross(L,U){const x=new S;return S.CrossToRef(L,U,x),x}static CrossToRef(L,U,x){const mL=L._y*U._z-L._z*U._y,p=L._z*U._x-L._x*U._z,G=L._x*U._y-L._y*U._x;return x.da(mL,p,G),x}static Normalize(L){const U=S.Zero();return S.NormalizeToRef(L,U),U}static NormalizeToRef(L,U){return L.normalizeToRef(U),U}static Project(L,U,x,mL){const p=new S;return S.ProjectToRef(L,U,x,mL,p),p}static ProjectToRef(L,U,x,mL,p){var G;const F=mL.width,o=mL.height,A=mL.x,r=mL.y,h=q.Matrix[1],b=null===(G=a.c.LastCreatedEngine)||void 0===G?void 0:G.isNDCHalfZRange,E=b?1:.5,Y=b?0:.5;Q.FromValuesToRef(F/2,0,0,0,0,-o/2,0,0,0,0,E,0,A+F/2,o/2+r,Y,1,h);const V=q.Matrix[0];return U.multiplyToRef(x,V),V.multiplyToRef(h,V),S.TransformCoordinatesToRef(L,V,p),p}static Reflect(L,U){return this.ReflectToRef(L,U,new S)}static ReflectToRef(L,U,x){const mL=f.YU[0];return mL.p(U).scaleInPlace(2*S.Dot(L,U)),x.p(L).dh(mL)}static _UnprojectFromInvertedMatrixToRef(L,U,x){S.TransformCoordinatesToRef(L,U,x);const mL=U.m,p=L._x*mL[3]+L._y*mL[7]+L._z*mL[11]+mL[15];return(0,o.WithinEpsilon)(p,1)&&x.scaleInPlace(1/p),x}static UnprojectFromTransform(L,U,x,mL,p){return this.Unproject(L,U,x,mL,p,Q.IdentityReadOnly)}static Unproject(L,U,x,mL,p,G){const F=new S;return S.UnprojectToRef(L,U,x,mL,p,G,F),F}static UnprojectToRef(L,U,x,mL,p,G,F){return S.UnprojectFloatsToRef(L._x,L._y,L._z,U,x,mL,p,G,F),F}static UnprojectFloatsToRef(L,U,x,mL,p,G,F,o,A){var r;const h=q.Matrix[0];G.multiplyToRef(F,h),h.multiplyToRef(o,h),h.invert();const b=q.YU[0];return b.x=L/mL*2-1,b.y=-(U/p*2-1),null!==(r=a.c.LastCreatedEngine)&&void 0!==r&&r.isNDCHalfZRange?b.z=x:b.z=2*x-1,S._UnprojectFromInvertedMatrixToRef(b,h,A),A}static Minimize(L,U){const x=new S;return x.p(L),x.minimizeInPlace(U),x}static Maximize(L,U){const x=new S;return x.p(L),x.maximizeInPlace(U),x}static Distance(L,U){return Math.sqrt(S.DistanceSquared(L,U))}static DistanceSquared(L,U){const x=L._x-U._x,mL=L._y-U._y,p=L._z-U._z;return x*x+mL*mL+p*p}static ProjectOnTriangleToRef(L,U,x,p,G){const F=q.YU[0],a=q.YU[1],A=q.YU[2],r=q.YU[3],h=q.YU[4];x.subtractToRef(U,F),p.subtractToRef(U,a),p.subtractToRef(x,A);const b=F.length(),E=a.length(),Y=A.length();if(b<mL.c||E<mL.c||Y<mL.c)return G.p(U),S.Distance(L,U);L.subtractToRef(U,h),S.CrossToRef(F,a,r);const V=r.length();if(V<mL.c)return G.p(U),S.Distance(L,U);r.normalizeFromLength(V);let H=h.length();if(H<mL.c)return G.p(U),0;h.normalizeFromLength(H);const Q=S.Dot(r,h),f=q.YU[5],v=q.YU[6];f.p(r).scaleInPlace(-H*Q),v.p(L).addInPlace(f);const D=q.YU[4],P=q.YU[5],d=q.YU[7],K=q.YU[8];D.p(F).scaleInPlace(1/b),K.p(a).scaleInPlace(1/E),D.addInPlace(K).scaleInPlace(-1),P.p(F).scaleInPlace(-1/b),K.p(A).scaleInPlace(1/Y),P.addInPlace(K).scaleInPlace(-1),d.p(A).scaleInPlace(-1/Y),K.p(a).scaleInPlace(-1/E),d.addInPlace(K).scaleInPlace(-1);const l=q.YU[9];let i;l.p(v).dh(U),S.CrossToRef(D,l,K),i=S.Dot(K,r);const X=i;l.p(v).dh(x),S.CrossToRef(P,l,K),i=S.Dot(K,r);const t=i;l.p(v).dh(p),S.CrossToRef(d,l,K),i=S.Dot(K,r);const y=i,n=q.YU[10];let N,e;X>0&&t<0?(n.p(F),N=U,e=x):t>0&&y<0?(n.p(A),N=x,e=p):(n.p(a).scaleInPlace(-1),N=p,e=U);const u=q.YU[9],Z=q.YU[4];N.subtractToRef(v,K),e.subtractToRef(v,u),S.CrossToRef(K,u,Z);if(!(S.Dot(Z,r)<0))return G.p(v),Math.abs(H*Q);const g=q.YU[5];S.CrossToRef(n,Z,g),g.normalize();const z=q.YU[9];z.p(N).dh(v);const M=z.length();if(M<mL.c)return G.p(N),S.Distance(L,N);z.normalizeFromLength(M);const J=S.Dot(g,z),j=q.YU[7];j.p(v).addInPlace(g.scaleInPlace(M*J)),K.p(j).dh(N),H=n.length(),n.normalizeFromLength(H);let R=S.Dot(K,n)/Math.max(H,mL.c);return R=(0,o.Clamp)(R,0,1),j.p(N).addInPlace(n.scaleInPlace(R*H)),G.p(j),S.Distance(L,j)}static Center(L,U){return S.CenterToRef(L,U,S.Zero())}static CenterToRef(L,U,x){return x.da((L._x+U._x)/2,(L._y+U._y)/2,(L._z+U._z)/2)}static RotationFromAxis(L,U,x){const mL=new S;return S.RotationFromAxisToRef(L,U,x,mL),mL}static RotationFromAxisToRef(L,U,x,mL){const p=q.Quaternion[0];return H.RotationQuaternionFromAxisToRef(L,U,x,p),p.toEulerAnglesToRef(mL),mL}}S._V8PerformanceHack=new S(.5,.5,.5),S._UpReadOnly=S.Up(),S._DownReadOnly=S.Down(),S._LeftHandedForwardReadOnly=S.Forward(!1),S._RightHandedForwardReadOnly=S.Forward(!0),S._LeftHandedBackwardReadOnly=S.Backward(!1),S._RightHandedBackwardReadOnly=S.Backward(!0),S._RightReadOnly=S.Right(),S._LeftReadOnly=S.Left(),S._ZeroReadOnly=S.Zero(),S._OneReadOnly=S.One(),Object.defineProperties(S.prototype,{dimension:{value:[3]},rank:{value:1}});class V{get x(){return this._x}set x(L){this._x=L,this._isDirty=!0}get y(){return this._y}set y(L){this._y=L,this._isDirty=!0}get z(){return this._z}set z(L){this._z=L,this._isDirty=!0}get w(){return this._w}set w(L){this._w=L,this._isDirty=!0}constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,mL=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=L,this._y=U,this._z=x,this._w=mL}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let L=E(this._x);return L=397*L^E(this._y),L=397*L^E(this._z),L=397*L^E(this._w),L}Va(){return[this._x,this._y,this._z,this._w]}toArray(L,U){return void 0===U&&(U=0),L[U]=this._x,L[U+1]=this._y,L[U+2]=this._z,L[U+3]=this._w,this}Vx(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V.FromArrayToRef(L,U,this),this}addInPlace(L){return this.x+=L._x,this.y+=L._y,this.z+=L._z,this.w+=L._w,this}addInPlaceFromFloats(L,U,x,mL){return this.x+=L,this.y+=U,this.z+=x,this.w+=mL,this}add(L){return new V(this._x+L.x,this._y+L.y,this._z+L.z,this._w+L.w)}addToRef(L,U){return U.x=this._x+L.x,U.y=this._y+L.y,U.z=this._z+L.z,U.w=this._w+L.w,U}dh(L){return this.x-=L.x,this.y-=L.y,this.z-=L.z,this.w-=L.w,this}SU(L){return new V(this._x-L.x,this._y-L.y,this._z-L.z,this._w-L.w)}subtractToRef(L,U){return U.x=this._x-L.x,U.y=this._y-L.y,U.z=this._z-L.z,U.w=this._w-L.w,U}subtractFromFloats(L,U,x,mL){return new V(this._x-L,this._y-U,this._z-x,this._w-mL)}subtractFromFloatsToRef(L,U,x,mL,p){return p.x=this._x-L,p.y=this._y-U,p.z=this._z-x,p.w=this._w-mL,p}negate(){return new V(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(L){return L.x=-this._x,L.y=-this._y,L.z=-this._z,L.w=-this._w,L}scaleInPlace(L){return this.x*=L,this.y*=L,this.z*=L,this.w*=L,this}scale(L){return new V(this._x*L,this._y*L,this._z*L,this._w*L)}scaleToRef(L,U){return U.x=this._x*L,U.y=this._y*L,U.z=this._z*L,U.w=this._w*L,U}scaleAndAddToRef(L,U){return U.x+=this._x*L,U.y+=this._y*L,U.z+=this._z*L,U.w+=this._w*L,U}equals(L){return L&&this._x===L.x&&this._y===L.y&&this._z===L.z&&this._w===L.w}equalsWithEpsilon(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mL.c;return L&&(0,o.WithinEpsilon)(this._x,L.x,U)&&(0,o.WithinEpsilon)(this._y,L.y,U)&&(0,o.WithinEpsilon)(this._z,L.z,U)&&(0,o.WithinEpsilon)(this._w,L.w,U)}equalsToFloats(L,U,x,mL){return this._x===L&&this._y===U&&this._z===x&&this._w===mL}multiplyInPlace(L){return this.x*=L.x,this.y*=L.y,this.z*=L.z,this.w*=L.w,this}multiply(L){return new V(this._x*L.x,this._y*L.y,this._z*L.z,this._w*L.w)}multiplyToRef(L,U){return U.x=this._x*L.x,U.y=this._y*L.y,U.z=this._z*L.z,U.w=this._w*L.w,U}multiplyByFloats(L,U,x,mL){return new V(this._x*L,this._y*U,this._z*x,this._w*mL)}divide(L){return new V(this._x/L.x,this._y/L.y,this._z/L.z,this._w/L.w)}divideToRef(L,U){return U.x=this._x/L.x,U.y=this._y/L.y,U.z=this._z/L.z,U.w=this._w/L.w,U}divideInPlace(L){return this.divideToRef(L,this)}minimizeInPlace(L){return L.x<this._x&&(this.x=L.x),L.y<this._y&&(this.y=L.y),L.z<this._z&&(this.z=L.z),L.w<this._w&&(this.w=L.w),this}maximizeInPlace(L){return L.x>this._x&&(this.x=L.x),L.y>this._y&&(this.y=L.y),L.z>this._z&&(this.z=L.z),L.w>this._w&&(this.w=L.w),this}minimizeInPlaceFromFloats(L,U,x,mL){return this.x=Math.min(L,this._x),this.y=Math.min(U,this._y),this.z=Math.min(x,this._z),this.w=Math.min(mL,this._w),this}maximizeInPlaceFromFloats(L,U,x,mL){return this.x=Math.max(L,this._x),this.y=Math.max(U,this._y),this.z=Math.max(x,this._z),this.w=Math.max(mL,this._w),this}floorToRef(L){return L.x=Math.floor(this._x),L.y=Math.floor(this._y),L.z=Math.floor(this._z),L.w=Math.floor(this._w),L}floor(){return new V(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(L){return L.x=this._x-Math.floor(this._x),L.y=this._y-Math.floor(this._y),L.z=this._z-Math.floor(this._z),L.w=this._w-Math.floor(this._w),L}fract(){return new V(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(L){return 0===L||1===L?this:this.scaleInPlace(1/L)}normalizeToNew(){return this.normalizeToRef(new V)}normalizeToRef(L){const U=this.length();return 0===U||1===U?(L.x=this._x,L.y=this._y,L.z=this._z,L.w=this._w,L):this.scaleToRef(1/U,L)}toVector3(){return new S(this._x,this._y,this._z)}clone(){return new V(this._x,this._y,this._z,this._w)}p(L){return this.x=L.x,this.y=L.y,this.z=L.z,this.w=L.w,this}da(L,U,x,mL){return this.x=L,this.y=U,this.z=x,this.w=mL,this}set(L,U,x,mL){return this.da(L,U,x,mL)}la(L){return this.x=this.y=this.z=this.w=L,this}dot(L){return this._x*L.x+this._y*L.y+this._z*L.z+this._w*L.w}static qU(L,U){return U||(U=0),new V(L[U],L[U+1],L[U+2],L[U+3])}static FromArrayToRef(L,U,x){return x.x=L[U],x.y=L[U+1],x.z=L[U+2],x.w=L[U+3],x}static FromFloatArrayToRef(L,U,x){return V.FromArrayToRef(L,U,x),x}static FromFloatsToRef(L,U,x,mL,p){return p.x=L,p.y=U,p.z=x,p.w=mL,p}static Zero(){return new V(0,0,0,0)}static One(){return new V(1,1,1,1)}static Random(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new V((0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U))}static RandomToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,x=arguments.length>2?arguments[2]:void 0;return x.x=(0,o.RandomRange)(L,U),x.y=(0,o.RandomRange)(L,U),x.z=(0,o.RandomRange)(L,U),x.w=(0,o.RandomRange)(L,U),x}static Clamp(L,U,x){return V.ClampToRef(L,U,x,new V)}static ClampToRef(L,U,x,mL){return mL.x=(0,o.Clamp)(L.x,U.x,x.x),mL.y=(0,o.Clamp)(L.y,U.y,x.y),mL.z=(0,o.Clamp)(L.z,U.z,x.z),mL.w=(0,o.Clamp)(L.w,U.w,x.w),mL}static CheckExtends(L,U,x){U.minimizeInPlace(L),x.maximizeInPlace(L)}static get ZeroReadOnly(){return V._ZeroReadOnly}static Normalize(L){return V.NormalizeToRef(L,new V)}static NormalizeToRef(L,U){return L.normalizeToRef(U),U}static Minimize(L,U){const x=new V;return x.p(L),x.minimizeInPlace(U),x}static Maximize(L,U){const x=new V;return x.p(L),x.maximizeInPlace(U),x}static Distance(L,U){return Math.sqrt(V.DistanceSquared(L,U))}static DistanceSquared(L,U){const x=L.x-U.x,mL=L.y-U.y,p=L.z-U.z,G=L.w-U.w;return x*x+mL*mL+p*p+G*G}static Center(L,U){return V.CenterToRef(L,U,new V)}static CenterToRef(L,U,x){return x.x=(L.x+U.x)/2,x.y=(L.y+U.y)/2,x.z=(L.z+U.z)/2,x.w=(L.w+U.w)/2,x}static TransformCoordinates(L,U){return V.TransformCoordinatesToRef(L,U,new V)}static TransformCoordinatesToRef(L,U,x){return V.TransformCoordinatesFromFloatsToRef(L._x,L._y,L._z,U,x),x}static TransformCoordinatesFromFloatsToRef(L,U,x,mL,p){const G=mL.m,F=L*G[0]+U*G[4]+x*G[8]+G[12],a=L*G[1]+U*G[5]+x*G[9]+G[13],o=L*G[2]+U*G[6]+x*G[10]+G[14],A=L*G[3]+U*G[7]+x*G[11]+G[15];return p.x=F,p.y=a,p.z=o,p.w=A,p}static TransformNormal(L,U){return V.TransformNormalToRef(L,U,new V)}static TransformNormalToRef(L,U,x){const mL=U.m,p=L.x*mL[0]+L.y*mL[4]+L.z*mL[8],G=L.x*mL[1]+L.y*mL[5]+L.z*mL[9],F=L.x*mL[2]+L.y*mL[6]+L.z*mL[10];return x.x=p,x.y=G,x.z=F,x.w=L.w,x}static TransformNormalFromFloatsToRef(L,U,x,mL,p,G){const F=p.m;return G.x=L*F[0]+U*F[4]+x*F[8],G.y=L*F[1]+U*F[5]+x*F[9],G.z=L*F[2]+U*F[6]+x*F[10],G.w=mL,G}static FromVector3(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new V(L._x,L._y,L._z,U)}static Dot(L,U){return L.x*U.x+L.y*U.y+L.z*U.z+L.w*U.w}}V._V8PerformanceHack=new V(.5,.5,.5,.5),V._ZeroReadOnly=V.Zero(),Object.defineProperties(V.prototype,{dimension:{value:[4]},rank:{value:1}});class H{get x(){return this._x}set x(L){this._x=L,this._isDirty=!0}get y(){return this._y}set y(L){this._y=L,this._isDirty=!0}get z(){return this._z}set z(L){this._z=L,this._isDirty=!0}get w(){return this._w}set w(L){this._w=L,this._isDirty=!0}constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,mL=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=L,this._y=U,this._z=x,this._w=mL}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let L=E(this._x);return L=397*L^E(this._y),L=397*L^E(this._z),L=397*L^E(this._w),L}Va(){return[this._x,this._y,this._z,this._w]}toArray(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L[U]=this._x,L[U+1]=this._y,L[U+2]=this._z,L[U+3]=this._w,this}Vx(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H.FromArrayToRef(L,U,this)}equals(L){return L&&this._x===L._x&&this._y===L._y&&this._z===L._z&&this._w===L._w}equalsWithEpsilon(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mL.c;return L&&(0,o.WithinEpsilon)(this._x,L._x,U)&&(0,o.WithinEpsilon)(this._y,L._y,U)&&(0,o.WithinEpsilon)(this._z,L._z,U)&&(0,o.WithinEpsilon)(this._w,L._w,U)}isApprox(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mL.c;return L&&((0,o.WithinEpsilon)(this._x,L._x,U)&&(0,o.WithinEpsilon)(this._y,L._y,U)&&(0,o.WithinEpsilon)(this._z,L._z,U)&&(0,o.WithinEpsilon)(this._w,L._w,U)||(0,o.WithinEpsilon)(this._x,-L._x,U)&&(0,o.WithinEpsilon)(this._y,-L._y,U)&&(0,o.WithinEpsilon)(this._z,-L._z,U)&&(0,o.WithinEpsilon)(this._w,-L._w,U))}clone(){return new H(this._x,this._y,this._z,this._w)}p(L){return this._x=L._x,this._y=L._y,this._z=L._z,this._w=L._w,this._isDirty=!0,this}da(L,U,x,mL){return this._x=L,this._y=U,this._z=x,this._w=mL,this._isDirty=!0,this}set(L,U,x,mL){return this.da(L,U,x,mL)}la(L){return this.da(L,L,L,L)}add(L){return new H(this._x+L._x,this._y+L._y,this._z+L._z,this._w+L._w)}addInPlace(L){return this._x+=L._x,this._y+=L._y,this._z+=L._z,this._w+=L._w,this._isDirty=!0,this}addToRef(L,U){return U._x=this._x+L._x,U._y=this._y+L._y,U._z=this._z+L._z,U._w=this._w+L._w,U._isDirty=!0,U}addInPlaceFromFloats(L,U,x,mL){return this._x+=L,this._y+=U,this._z+=x,this._w+=mL,this._isDirty=!0,this}subtractToRef(L,U){return U._x=this._x-L._x,U._y=this._y-L._y,U._z=this._z-L._z,U._w=this._w-L._w,U._isDirty=!0,U}subtractFromFloats(L,U,x,mL){return this.subtractFromFloatsToRef(L,U,x,mL,new H)}subtractFromFloatsToRef(L,U,x,mL,p){return p._x=this._x-L,p._y=this._y-U,p._z=this._z-x,p._w=this._w-mL,p._isDirty=!0,p}SU(L){return new H(this._x-L._x,this._y-L._y,this._z-L._z,this._w-L._w)}dh(L){return this._x-=L._x,this._y-=L._y,this._z-=L._z,this._w-=L._w,this._isDirty=!0,this}scale(L){return new H(this._x*L,this._y*L,this._z*L,this._w*L)}scaleToRef(L,U){return U._x=this._x*L,U._y=this._y*L,U._z=this._z*L,U._w=this._w*L,U._isDirty=!0,U}scaleInPlace(L){return this._x*=L,this._y*=L,this._z*=L,this._w*=L,this._isDirty=!0,this}scaleAndAddToRef(L,U){return U._x+=this._x*L,U._y+=this._y*L,U._z+=this._z*L,U._w+=this._w*L,U._isDirty=!0,U}multiply(L){const U=new H(0,0,0,1);return this.multiplyToRef(L,U),U}multiplyToRef(L,U){const x=this._x*L._w+this._y*L._z-this._z*L._y+this._w*L._x,mL=-this._x*L._z+this._y*L._w+this._z*L._x+this._w*L._y,p=this._x*L._y-this._y*L._x+this._z*L._w+this._w*L._z,G=-this._x*L._x-this._y*L._y-this._z*L._z+this._w*L._w;return U.da(x,mL,p,G),U}multiplyInPlace(L){return this.multiplyToRef(L,this)}multiplyByFloats(L,U,x,mL){return this._x*=L,this._y*=U,this._z*=x,this._w*=mL,this._isDirty=!0,this}divide(L){throw new ReferenceError("Can not divide a quaternion")}divideToRef(L,U){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(L){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new H)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(L){return L._x=-this._x,L._y=-this._y,L._z=-this._z,L._w=-this._w,L._isDirty=!0,L}equalsToFloats(L,U,x,mL){return this._x===L&&this._y===U&&this._z===x&&this._w===mL}floorToRef(L){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(L){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(L){return L.da(-this._x,-this._y,-this._z,this._w),L}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new H(-this._x,-this._y,-this._z,this._w)}invert(){const L=this.conjugate(),U=this.lengthSquared();return 0==U||1==U||L.scaleInPlace(1/U),L}invertInPlace(){this.conjugateInPlace();const L=this.lengthSquared();return 0==L||1==L||this.scaleInPlace(1/L),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(L){return 0===L||1===L?this:this.scaleInPlace(1/L)}normalizeToNew(){const L=new H(0,0,0,1);return this.normalizeToRef(L),L}normalizeToRef(L){const U=this.length();return 0===U||1===U?L.da(this._x,this._y,this._z,this._w):this.scaleToRef(1/U,L)}toEulerAngles(){const L=S.Zero();return this.toEulerAnglesToRef(L),L}toEulerAnglesToRef(L){const U=this._z,x=this._x,mL=this._y,p=this._w,G=mL*U-x*p,F=.4999999;if(G<-F)L._y=2*Math.atan2(mL,p),L._x=Math.PI/2,L._z=0,L._isDirty=!0;else if(G>F)L._y=2*Math.atan2(mL,p),L._x=-Math.PI/2,L._z=0,L._isDirty=!0;else{const F=p*p,a=U*U,o=x*x,A=mL*mL;L._z=Math.atan2(2*(x*mL+U*p),-a-o+A+F),L._x=Math.asin(-2*G),L._y=Math.atan2(2*(U*x+mL*p),a-o-A+F),L._isDirty=!0}return L}toAlphaBetaGammaToRef(L){const U=this._z,x=this._x,mL=this._y,p=this._w,G=Math.sqrt(x*x+mL*mL),F=Math.sqrt(U*U+p*p),a=2*Math.atan2(G,F),o=2*Math.atan2(U,p),A=2*Math.atan2(mL,x),r=(o+A)/2,h=(o-A)/2;return L.set(h,a,r),L}toRotationMatrix(L){return Q.FromQuaternionToRef(this,L),L}fromRotationMatrix(L){return H.FromRotationMatrixToRef(L,this),this}dot(L){return this._x*L._x+this._y*L._y+this._z*L._z+this._w*L._w}toAxisAngle(){const L=S.Zero();return{axis:L,angle:this.toAxisAngleToRef(L)}}toAxisAngleToRef(L){let U=0;const x=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),mL=this._w;return x>0?(U=2*Math.atan2(x,mL),L.set(this._x/x,this._y/x,this._z/x)):(U=0,L.set(1,0,0)),U}static FromRotationMatrix(L){const U=new H;return H.FromRotationMatrixToRef(L,U),U}static FromRotationMatrixToRef(L,U){const x=L.m,mL=x[0],p=x[4],G=x[8],F=x[1],a=x[5],o=x[9],A=x[2],r=x[6],h=x[10],b=mL+a+h;let E;return b>0?(E=.5/Math.sqrt(b+1),U._w=.25/E,U._x=(r-o)*E,U._y=(G-A)*E,U._z=(F-p)*E,U._isDirty=!0):mL>a&&mL>h?(E=2*Math.sqrt(1+mL-a-h),U._w=(r-o)/E,U._x=.25*E,U._y=(p+F)/E,U._z=(G+A)/E,U._isDirty=!0):a>h?(E=2*Math.sqrt(1+a-mL-h),U._w=(G-A)/E,U._x=(p+F)/E,U._y=.25*E,U._z=(o+r)/E,U._isDirty=!0):(E=2*Math.sqrt(1+h-mL-a),U._w=(F-p)/E,U._x=(G+A)/E,U._y=(o+r)/E,U._z=.25*E,U._isDirty=!0),U}static Dot(L,U){return L._x*U._x+L._y*U._y+L._z*U._z+L._w*U._w}static AreClose(L,U){let x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const mL=H.Dot(L,U);return 1-mL*mL<=x}static SmoothToRef(L,U,x,mL,p){let G=0===mL?1:x/mL;return G=(0,o.Clamp)(G,0,1),H.SlerpToRef(L,U,G,p),p}static Zero(){return new H(0,0,0,0)}static Inverse(L){return new H(-L._x,-L._y,-L._z,L._w)}static InverseToRef(L,U){return U.set(-L._x,-L._y,-L._z,L._w),U}static Identity(){return new H(0,0,0,1)}static IsIdentity(L){return L&&0===L._x&&0===L._y&&0===L._z&&1===L._w}static RotationAxis(L,U){return H.RotationAxisToRef(L,U,new H)}static RotationAxisToRef(L,U,x){x._w=Math.cos(U/2);const mL=Math.sin(U/2)/L.length();return x._x=L._x*mL,x._y=L._y*mL,x._z=L._z*mL,x._isDirty=!0,x}static qU(L,U){return U||(U=0),new H(L[U],L[U+1],L[U+2],L[U+3])}static FromArrayToRef(L,U,x){return x._x=L[U],x._y=L[U+1],x._z=L[U+2],x._w=L[U+3],x._isDirty=!0,x}static FromFloatsToRef(L,U,x,mL,p){return p.da(L,U,x,mL),p}static FromEulerAngles(L,U,x){const mL=new H;return H.RotationYawPitchRollToRef(U,L,x,mL),mL}static FromEulerAnglesToRef(L,U,x,mL){return H.RotationYawPitchRollToRef(U,L,x,mL),mL}static FromEulerVector(L){const U=new H;return H.RotationYawPitchRollToRef(L._y,L._x,L._z,U),U}static FromEulerVectorToRef(L,U){return H.RotationYawPitchRollToRef(L._y,L._x,L._z,U),U}static FromUnitVectorsToRef(L,U,x){let p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:mL.c;const G=S.Dot(L,U)+1;return G<p?Math.abs(L.x)>Math.abs(L.z)?x.set(-L.y,L.x,0,0):x.set(0,-L.z,L.y,0):(S.CrossToRef(L,U,f.YU[0]),x.set(f.YU[0].x,f.YU[0].y,f.YU[0].z,G)),x.normalize()}static RotationYawPitchRoll(L,U,x){const mL=new H;return H.RotationYawPitchRollToRef(L,U,x,mL),mL}static RotationYawPitchRollToRef(L,U,x,mL){const p=.5*x,G=.5*U,F=.5*L,a=Math.sin(p),o=Math.cos(p),A=Math.sin(G),r=Math.cos(G),h=Math.sin(F),b=Math.cos(F);return mL._x=b*A*o+h*r*a,mL._y=h*r*o-b*A*a,mL._z=b*r*a-h*A*o,mL._w=b*r*o+h*A*a,mL._isDirty=!0,mL}static RotationAlphaBetaGamma(L,U,x){const mL=new H;return H.RotationAlphaBetaGammaToRef(L,U,x,mL),mL}static RotationAlphaBetaGammaToRef(L,U,x,mL){const p=.5*(x+L),G=.5*(x-L),F=.5*U;return mL._x=Math.cos(G)*Math.sin(F),mL._y=Math.sin(G)*Math.sin(F),mL._z=Math.sin(p)*Math.cos(F),mL._w=Math.cos(p)*Math.cos(F),mL._isDirty=!0,mL}static RotationQuaternionFromAxis(L,U,x){const mL=new H(0,0,0,0);return H.RotationQuaternionFromAxisToRef(L,U,x,mL),mL}static RotationQuaternionFromAxisToRef(L,U,x,mL){const p=q.Matrix[0];return L=L.normalizeToRef(q.YU[0]),U=U.normalizeToRef(q.YU[1]),x=x.normalizeToRef(q.YU[2]),Q.FromXYZAxesToRef(L,U,x,p),H.FromRotationMatrixToRef(p,mL),mL}static FromLookDirectionLH(L,U){const x=new H;return H.FromLookDirectionLHToRef(L,U,x),x}static FromLookDirectionLHToRef(L,U,x){const mL=q.Matrix[0];return Q.LookDirectionLHToRef(L,U,mL),H.FromRotationMatrixToRef(mL,x),x}static FromLookDirectionRH(L,U){const x=new H;return H.FromLookDirectionRHToRef(L,U,x),x}static FromLookDirectionRHToRef(L,U,x){const mL=q.Matrix[0];return Q.LookDirectionRHToRef(L,U,mL),H.FromRotationMatrixToRef(mL,x)}static Slerp(L,U,x){const mL=H.Identity();return H.SlerpToRef(L,U,x,mL),mL}static SlerpToRef(L,U,x,mL){let p,G,F=L._x*U._x+L._y*U._y+L._z*U._z+L._w*U._w,a=!1;if(F<0&&(a=!0,F=-F),F>.999999)G=1-x,p=a?-x:x;else{const L=Math.acos(F),U=1/Math.sin(L);G=Math.sin((1-x)*L)*U,p=a?-Math.sin(x*L)*U:Math.sin(x*L)*U}return mL._x=G*L._x+p*U._x,mL._y=G*L._y+p*U._y,mL._z=G*L._z+p*U._z,mL._w=G*L._w+p*U._w,mL._isDirty=!0,mL}static Hermite(L,U,x,mL,p){const G=p*p,F=p*G,a=2*F-3*G+1,o=-2*F+3*G,A=F-2*G+p,r=F-G,h=L._x*a+x._x*o+U._x*A+mL._x*r,b=L._y*a+x._y*o+U._y*A+mL._y*r,E=L._z*a+x._z*o+U._z*A+mL._z*r,Y=L._w*a+x._w*o+U._w*A+mL._w*r;return new H(h,b,E,Y)}static Hermite1stDerivative(L,U,x,mL,p){const G=new H;return this.Hermite1stDerivativeToRef(L,U,x,mL,p,G),G}static Hermite1stDerivativeToRef(L,U,x,mL,p,G){const F=p*p;return G._x=6*(F-p)*L._x+(3*F-4*p+1)*U._x+6*(-F+p)*x._x+(3*F-2*p)*mL._x,G._y=6*(F-p)*L._y+(3*F-4*p+1)*U._y+6*(-F+p)*x._y+(3*F-2*p)*mL._y,G._z=6*(F-p)*L._z+(3*F-4*p+1)*U._z+6*(-F+p)*x._z+(3*F-2*p)*mL._z,G._w=6*(F-p)*L._w+(3*F-4*p+1)*U._w+6*(-F+p)*x._w+(3*F-2*p)*mL._w,G._isDirty=!0,G}static Normalize(L){const U=H.Zero();return H.NormalizeToRef(L,U),U}static NormalizeToRef(L,U){return L.normalizeToRef(U),U}static Clamp(L,U,x){const mL=new H;return H.ClampToRef(L,U,x,mL),mL}static ClampToRef(L,U,x,mL){return mL.da((0,o.Clamp)(L.x,U.x,x.x),(0,o.Clamp)(L.y,U.y,x.y),(0,o.Clamp)(L.z,U.z,x.z),(0,o.Clamp)(L.w,U.w,x.w))}static Random(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new H((0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U))}static RandomToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).da((0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U),(0,o.RandomRange)(L,U))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(L,U){return Math.sqrt(H.DistanceSquared(L,U))}static DistanceSquared(L,U){const x=L.x-U.x,mL=L.y-U.y,p=L.z-U.z,G=L.w-U.w;return x*x+mL*mL+p*p+G*G}static Center(L,U){return H.CenterToRef(L,U,H.Zero())}static CenterToRef(L,U,x){return x.da((L.x+U.x)/2,(L.y+U.y)/2,(L.z+U.z)/2,(L.w+U.w)/2)}}H._V8PerformanceHack=new H(.5,.5,.5,.5),Object.defineProperties(H.prototype,{dimension:{value:[4]},rank:{value:1}});class Q{static get Use64Bits(){return F.d.MatrixUse64Bits}get m(){return this.ra}markAsUpdated(){this.updateFlag=A._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(L){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1],x=arguments.length>2&&void 0!==arguments[2]&&arguments[2],mL=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=L,this._isIdentity3x2=L||x,this._isIdentityDirty=!this._isIdentity&&U,this._isIdentity3x2Dirty=!this._isIdentity3x2&&mL}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,F.d.MatrixTrackPrecisionChange&&F.d.MatrixTrackedMatrices.push(this),this.ra=new F.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const L=this.ra;this._isIdentity=1===L[0]&&0===L[1]&&0===L[2]&&0===L[3]&&0===L[4]&&1===L[5]&&0===L[6]&&0===L[7]&&0===L[8]&&0===L[9]&&1===L[10]&&0===L[11]&&0===L[12]&&0===L[13]&&0===L[14]&&1===L[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ra[0]||1!==this.ra[5]||1!==this.ra[15]||0!==this.ra[1]||0!==this.ra[2]||0!==this.ra[3]||0!==this.ra[4]||0!==this.ra[6]||0!==this.ra[7]||0!==this.ra[8]||0!==this.ra[9]||0!==this.ra[10]||0!==this.ra[11]||0!==this.ra[12]||0!==this.ra[13]||0!==this.ra[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const L=this.ra,U=L[0],x=L[1],mL=L[2],p=L[3],G=L[4],F=L[5],a=L[6],o=L[7],A=L[8],r=L[9],h=L[10],b=L[11],E=L[12],Y=L[13],S=L[14],V=L[15],H=h*V-S*b,Q=r*V-Y*b,q=r*S-Y*h,f=A*V-E*b,v=A*S-h*E,D=A*Y-E*r;return U*+(F*H-a*Q+o*q)+x*-(G*H-a*f+o*v)+mL*+(G*Q-F*f+o*D)+p*-(G*q-F*v+a*D)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!L)return this.ra;const x=this.ra;for(let mL=0;mL<16;mL++)L[U+mL]=x[mL];return this}Va(){return this.ra}Vx(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(L,U,this)}da(){for(var L=arguments.length,U=new Array(L),x=0;x<L;x++)U[x]=arguments[x];return Q.FromArrayToRef(U,0,this)}set(){const L=this.ra;for(let U=0;U<16;U++)L[U]=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}la(L){const U=this.ra;for(let x=0;x<16;x++)U[x]=L;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return Q.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(L){const U=new Q;return this.addToRef(L,U),U}addToRef(L,U){const x=this.ra,mL=U.ra,p=L.m;for(let G=0;G<16;G++)mL[G]=x[G]+p[G];return U.markAsUpdated(),U}addToSelf(L){const U=this.ra,x=L.m;return U[0]+=x[0],U[1]+=x[1],U[2]+=x[2],U[3]+=x[3],U[4]+=x[4],U[5]+=x[5],U[6]+=x[6],U[7]+=x[7],U[8]+=x[8],U[9]+=x[9],U[10]+=x[10],U[11]+=x[11],U[12]+=x[12],U[13]+=x[13],U[14]+=x[14],U[15]+=x[15],this.markAsUpdated(),this}addInPlace(L){const U=this.ra,x=L.m;for(let mL=0;mL<16;mL++)U[mL]+=x[mL];return this.markAsUpdated(),this}addInPlaceFromFloats(){const L=this.ra;for(let U=0;U<16;U++)L[U]+=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}SU(L){const U=this.ra,x=L.m;for(let mL=0;mL<16;mL++)U[mL]-=x[mL];return this.markAsUpdated(),this}subtractToRef(L,U){const x=this.ra,mL=L.m,p=U.ra;for(let G=0;G<16;G++)p[G]=x[G]-mL[G];return U.markAsUpdated(),U}dh(L){const U=this.ra,x=L.m;for(let mL=0;mL<16;mL++)U[mL]-=x[mL];return this.markAsUpdated(),this}subtractFromFloats(){for(var L=arguments.length,U=new Array(L),x=0;x<L;x++)U[x]=arguments[x];return this.subtractFromFloatsToRef(...U,new Q)}subtractFromFloatsToRef(){for(var L=arguments.length,U=new Array(L),x=0;x<L;x++)U[x]=arguments[x];const mL=U.pop(),p=this.ra,G=mL.ra,F=U;for(let a=0;a<16;a++)G[a]=p[a]-F[a];return mL.markAsUpdated(),mL}invertToRef(L){return!0===this._isIdentity?(Q.IdentityToRef(L),L):(b(this,L.Va())?L.markAsUpdated():L.p(this),L)}addAtIndex(L,U){return this.ra[L]+=U,this.markAsUpdated(),this}multiplyAtIndex(L,U){return this.ra[L]*=U,this.markAsUpdated(),this}setTranslationFromFloats(L,U,x){return this.ra[12]=L,this.ra[13]=U,this.ra[14]=x,this.markAsUpdated(),this}addTranslationFromFloats(L,U,x){return this.ra[12]+=L,this.ra[13]+=U,this.ra[14]+=x,this.markAsUpdated(),this}setTranslation(L){return this.setTranslationFromFloats(L._x,L._y,L._z)}getTranslation(){return new S(this.ra[12],this.ra[13],this.ra[14])}getTranslationToRef(L){return L.x=this.ra[12],L.y=this.ra[13],L.z=this.ra[14],L}removeRotationAndScaling(){const L=this.m;return Q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,L[12],L[13],L[14],L[15],this),this._updateIdentityStatus(0===L[12]&&0===L[13]&&0===L[14]&&1===L[15]),this}p(L){L.copyToArray(this.ra);const U=L;return this.updateFlag=U.updateFlag,this._updateIdentityStatus(U._isIdentity,U._isIdentityDirty,U._isIdentity3x2,U._isIdentity3x2Dirty),this}copyToArray(L){return h(this,L,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(L){const U=new Q;return this.multiplyToRef(L,U),U}multiplyInPlace(L){const U=this.ra,x=L.m;for(let mL=0;mL<16;mL++)U[mL]*=x[mL];return this.markAsUpdated(),this}multiplyByFloats(){const L=this.ra;for(let U=0;U<16;U++)L[U]*=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var L=arguments.length,U=new Array(L),x=0;x<L;x++)U[x]=arguments[x];const mL=U.pop(),p=this.ra,G=mL.ra,F=U;for(let a=0;a<16;a++)G[a]=p[a]*F[a];return mL.markAsUpdated(),mL}multiplyToRef(L,U){return this._isIdentity?(U.p(L),U):L._isIdentity?(U.p(this),U):(this.multiplyToArray(L,U.ra,0),U.markAsUpdated(),U)}multiplyToArray(L,U,x){return r(this,L,U,x),this}divide(L){return this.divideToRef(L,new Q)}divideToRef(L,U){const x=this.ra,mL=L.m,p=U.ra;for(let G=0;G<16;G++)p[G]=x[G]/mL[G];return U.markAsUpdated(),U}divideInPlace(L){const U=this.ra,x=L.m;for(let mL=0;mL<16;mL++)U[mL]/=x[mL];return this.markAsUpdated(),this}minimizeInPlace(L){const U=this.ra,x=L.m;for(let mL=0;mL<16;mL++)U[mL]=Math.min(U[mL],x[mL]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const L=this.ra;for(let U=0;U<16;U++)L[U]=Math.min(L[U],U<0||arguments.length<=U?void 0:arguments[U]);return this.markAsUpdated(),this}maximizeInPlace(L){const U=this.ra,x=L.m;for(let mL=0;mL<16;mL++)U[mL]=Math.min(U[mL],x[mL]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const L=this.ra;for(let U=0;U<16;U++)L[U]=Math.min(L[U],U<0||arguments.length<=U?void 0:arguments[U]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new Q)}negateInPlace(){const L=this.ra;for(let U=0;U<16;U++)L[U]=-L[U];return this.markAsUpdated(),this}negateToRef(L){const U=this.ra,x=L.ra;for(let mL=0;mL<16;mL++)x[mL]=-U[mL];return L.markAsUpdated(),L}equals(L){const U=L;if(!U)return!1;if((this._isIdentity||U._isIdentity)&&!this._isIdentityDirty&&!U._isIdentityDirty)return this._isIdentity&&U._isIdentity;const x=this.m,mL=U.m;return x[0]===mL[0]&&x[1]===mL[1]&&x[2]===mL[2]&&x[3]===mL[3]&&x[4]===mL[4]&&x[5]===mL[5]&&x[6]===mL[6]&&x[7]===mL[7]&&x[8]===mL[8]&&x[9]===mL[9]&&x[10]===mL[10]&&x[11]===mL[11]&&x[12]===mL[12]&&x[13]===mL[13]&&x[14]===mL[14]&&x[15]===mL[15]}equalsWithEpsilon(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const x=this.ra,mL=L.m;for(let p=0;p<16;p++)if(!(0,o.WithinEpsilon)(x[p],mL[p],U))return!1;return!0}equalsToFloats(){const L=this.ra;for(let U=0;U<16;U++)if(L[U]!=(U<0||arguments.length<=U?void 0:arguments[U]))return!1;return!0}floor(){return this.floorToRef(new Q)}floorToRef(L){const U=this.ra,x=L.ra;for(let mL=0;mL<16;mL++)x[mL]=Math.floor(U[mL]);return L.markAsUpdated(),L}fract(){return this.fractToRef(new Q)}fractToRef(L){const U=this.ra,x=L.ra;for(let mL=0;mL<16;mL++)x[mL]=U[mL]-Math.floor(U[mL]);return L.markAsUpdated(),L}clone(){const L=new Q;return L.p(this),L}getClassName(){return"Matrix"}getHashCode(){let L=E(this.ra[0]);for(let U=1;U<16;U++)L=397*L^E(this.ra[U]);return L}decomposeToTransformNode(L){return L.rotationQuaternion=L.rotationQuaternion||new H,this.decompose(L.Ka,L.rotationQuaternion,L.position)}decompose(L,U,x,mL){let p=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return x&&x.la(0),L&&L.la(1),U&&U.da(0,0,0,1),!0;const G=this.ra;if(x&&x.da(G[12],G[13],G[14]),(L=L||q.YU[0]).x=Math.sqrt(G[0]*G[0]+G[1]*G[1]+G[2]*G[2]),L.y=Math.sqrt(G[4]*G[4]+G[5]*G[5]+G[6]*G[6]),L.z=Math.sqrt(G[8]*G[8]+G[9]*G[9]+G[10]*G[10]),mL){const U=(p?mL.absoluteScaling.x:mL.Ka.x)<0?-1:1,x=(p?mL.absoluteScaling.y:mL.Ka.y)<0?-1:1,G=(p?mL.absoluteScaling.z:mL.Ka.z)<0?-1:1;L.x*=U,L.y*=x,L.z*=G}else this.determinant()<=0&&(L.y*=-1);if(0===L._x||0===L._y||0===L._z)return U&&U.da(0,0,0,1),!1;if(U){const x=1/L._x,mL=1/L._y,p=1/L._z;Q.FromValuesToRef(G[0]*x,G[1]*x,G[2]*x,0,G[4]*mL,G[5]*mL,G[6]*mL,0,G[8]*p,G[9]*p,G[10]*p,0,0,0,0,1,q.Matrix[0]),H.FromRotationMatrixToRef(q.Matrix[0],U)}return!0}getRow(L){if(L<0||L>3)return null;const U=4*L;return new V(this.ra[U+0],this.ra[U+1],this.ra[U+2],this.ra[U+3])}getRowToRef(L,U){if(L>=0&&L<=3){const x=4*L;U.x=this.ra[x+0],U.y=this.ra[x+1],U.z=this.ra[x+2],U.w=this.ra[x+3]}return U}setRow(L,U){return this.setRowFromFloats(L,U.x,U.y,U.z,U.w)}transpose(){const L=new Q;return Q.TransposeToRef(this,L),L}transposeToRef(L){return Q.TransposeToRef(this,L),L}setRowFromFloats(L,U,x,mL,p){if(L<0||L>3)return this;const G=4*L;return this.ra[G+0]=U,this.ra[G+1]=x,this.ra[G+2]=mL,this.ra[G+3]=p,this.markAsUpdated(),this}scale(L){const U=new Q;return this.scaleToRef(L,U),U}scaleToRef(L,U){for(let x=0;x<16;x++)U.ra[x]=this.ra[x]*L;return U.markAsUpdated(),U}scaleAndAddToRef(L,U){for(let x=0;x<16;x++)U.ra[x]+=this.ra[x]*L;return U.markAsUpdated(),U}scaleInPlace(L){const U=this.ra;for(let x=0;x<16;x++)U[x]*=L;return this.markAsUpdated(),this}toNormalMatrix(L){const U=q.Matrix[0];this.invertToRef(U),U.transposeToRef(L);const x=L.ra;return Q.FromValuesToRef(x[0],x[1],x[2],0,x[4],x[5],x[6],0,x[8],x[9],x[10],0,0,0,0,1,L),L}getRotationMatrix(){const L=new Q;return this.getRotationMatrixToRef(L),L}getRotationMatrixToRef(L){const U=q.YU[0];if(!this.decompose(U))return Q.IdentityToRef(L),L;const x=this.ra,mL=1/U._x,p=1/U._y,G=1/U._z;return Q.FromValuesToRef(x[0]*mL,x[1]*mL,x[2]*mL,0,x[4]*p,x[5]*p,x[6]*p,0,x[8]*G,x[9]*G,x[10]*G,0,0,0,0,1,L),L}toggleModelMatrixHandInPlace(){const L=this.ra;return L[2]*=-1,L[6]*=-1,L[8]*=-1,L[9]*=-1,L[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const L=this.ra;return L[8]*=-1,L[9]*=-1,L[10]*=-1,L[11]*=-1,this.markAsUpdated(),this}static qU(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const x=new Q;return Q.FromArrayToRef(L,U,x),x}static FromArrayToRef(L,U,x){for(let mL=0;mL<16;mL++)x.ra[mL]=L[mL+U];return x.markAsUpdated(),x}static FromFloat32ArrayToRefScaled(L,U,x,mL){return mL.ra[0]=L[0+U]*x,mL.ra[1]=L[1+U]*x,mL.ra[2]=L[2+U]*x,mL.ra[3]=L[3+U]*x,mL.ra[4]=L[4+U]*x,mL.ra[5]=L[5+U]*x,mL.ra[6]=L[6+U]*x,mL.ra[7]=L[7+U]*x,mL.ra[8]=L[8+U]*x,mL.ra[9]=L[9+U]*x,mL.ra[10]=L[10+U]*x,mL.ra[11]=L[11+U]*x,mL.ra[12]=L[12+U]*x,mL.ra[13]=L[13+U]*x,mL.ra[14]=L[14+U]*x,mL.ra[15]=L[15+U]*x,mL.markAsUpdated(),mL}static get IdentityReadOnly(){return Q._IdentityReadOnly}static FromValuesToRef(L,U,x,mL,p,G,F,a,o,A,r,h,b,E,Y,S,V){const H=V.ra;H[0]=L,H[1]=U,H[2]=x,H[3]=mL,H[4]=p,H[5]=G,H[6]=F,H[7]=a,H[8]=o,H[9]=A,H[10]=r,H[11]=h,H[12]=b,H[13]=E,H[14]=Y,H[15]=S,V.markAsUpdated()}static FromValues(L,U,x,mL,p,G,F,a,o,A,r,h,b,E,Y,S){const V=new Q,H=V.ra;return H[0]=L,H[1]=U,H[2]=x,H[3]=mL,H[4]=p,H[5]=G,H[6]=F,H[7]=a,H[8]=o,H[9]=A,H[10]=r,H[11]=h,H[12]=b,H[13]=E,H[14]=Y,H[15]=S,V.markAsUpdated(),V}static Compose(L,U,x){const mL=new Q;return Q.ComposeToRef(L,U,x,mL),mL}static ComposeToRef(L,U,x,mL){const p=mL.ra,G=U._x,F=U._y,a=U._z,o=U._w,A=G+G,r=F+F,h=a+a,b=G*A,E=G*r,Y=G*h,S=F*r,V=F*h,H=a*h,Q=o*A,q=o*r,f=o*h,v=L._x,D=L._y,P=L._z;return p[0]=(1-(S+H))*v,p[1]=(E+f)*v,p[2]=(Y-q)*v,p[3]=0,p[4]=(E-f)*D,p[5]=(1-(b+H))*D,p[6]=(V+Q)*D,p[7]=0,p[8]=(Y+q)*P,p[9]=(V-Q)*P,p[10]=(1-(b+S))*P,p[11]=0,p[12]=x._x,p[13]=x._y,p[14]=x._z,p[15]=1,mL.markAsUpdated(),mL}static Identity(){const L=Q.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return L._updateIdentityStatus(!0),L}static IdentityToRef(L){return Q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,L),L._updateIdentityStatus(!0),L}static Zero(){const L=Q.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return L._updateIdentityStatus(!1),L}static RotationX(L){const U=new Q;return Q.RotationXToRef(L,U),U}static Invert(L){const U=new Q;return L.invertToRef(U),U}static RotationXToRef(L,U){const x=Math.sin(L),mL=Math.cos(L);return Q.FromValuesToRef(1,0,0,0,0,mL,x,0,0,-x,mL,0,0,0,0,1,U),U._updateIdentityStatus(1===mL&&0===x),U}static RotationY(L){const U=new Q;return Q.RotationYToRef(L,U),U}static RotationYToRef(L,U){const x=Math.sin(L),mL=Math.cos(L);return Q.FromValuesToRef(mL,0,-x,0,0,1,0,0,x,0,mL,0,0,0,0,1,U),U._updateIdentityStatus(1===mL&&0===x),U}static RotationZ(L){const U=new Q;return Q.RotationZToRef(L,U),U}static RotationZToRef(L,U){const x=Math.sin(L),mL=Math.cos(L);return Q.FromValuesToRef(mL,x,0,0,-x,mL,0,0,0,0,1,0,0,0,0,1,U),U._updateIdentityStatus(1===mL&&0===x),U}static RotationAxis(L,U){const x=new Q;return Q.RotationAxisToRef(L,U,x),x}static RotationAxisToRef(L,U,x){const mL=Math.sin(-U),p=Math.cos(-U),G=1-p;L=L.normalizeToRef(q.YU[0]);const F=x.ra;return F[0]=L._x*L._x*G+p,F[1]=L._x*L._y*G-L._z*mL,F[2]=L._x*L._z*G+L._y*mL,F[3]=0,F[4]=L._y*L._x*G+L._z*mL,F[5]=L._y*L._y*G+p,F[6]=L._y*L._z*G-L._x*mL,F[7]=0,F[8]=L._z*L._x*G-L._y*mL,F[9]=L._z*L._y*G+L._x*mL,F[10]=L._z*L._z*G+p,F[11]=0,F[12]=0,F[13]=0,F[14]=0,F[15]=1,x.markAsUpdated(),x}static RotationAlignToRef(L,U,x){let p=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const G=S.Dot(U,L),F=x.ra;if(G<-1+mL.c)F[0]=-1,F[1]=0,F[2]=0,F[3]=0,F[4]=0,F[5]=p?1:-1,F[6]=0,F[7]=0,F[8]=0,F[9]=0,F[10]=p?-1:1,F[11]=0;else{const x=S.Cross(U,L),mL=1/(1+G);F[0]=x._x*x._x*mL+G,F[1]=x._y*x._x*mL-x._z,F[2]=x._z*x._x*mL+x._y,F[3]=0,F[4]=x._x*x._y*mL+x._z,F[5]=x._y*x._y*mL+G,F[6]=x._z*x._y*mL-x._x,F[7]=0,F[8]=x._x*x._z*mL-x._y,F[9]=x._y*x._z*mL+x._x,F[10]=x._z*x._z*mL+G,F[11]=0}return F[12]=0,F[13]=0,F[14]=0,F[15]=1,x.markAsUpdated(),x}static RotationYawPitchRoll(L,U,x){const mL=new Q;return Q.RotationYawPitchRollToRef(L,U,x,mL),mL}static RotationYawPitchRollToRef(L,U,x,mL){return H.RotationYawPitchRollToRef(L,U,x,q.Quaternion[0]),q.Quaternion[0].toRotationMatrix(mL),mL}static Scaling(L,U,x){const mL=new Q;return Q.ScalingToRef(L,U,x,mL),mL}static ScalingToRef(L,U,x,mL){return Q.FromValuesToRef(L,0,0,0,0,U,0,0,0,0,x,0,0,0,0,1,mL),mL._updateIdentityStatus(1===L&&1===U&&1===x),mL}static Translation(L,U,x){const mL=new Q;return Q.TranslationToRef(L,U,x,mL),mL}static TranslationToRef(L,U,x,mL){return Q.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,L,U,x,1,mL),mL._updateIdentityStatus(0===L&&0===U&&0===x),mL}static Lerp(L,U,x){const mL=new Q;return Q.LerpToRef(L,U,x,mL),mL}static LerpToRef(L,U,x,mL){const p=mL.ra,G=L.m,F=U.m;for(let a=0;a<16;a++)p[a]=G[a]*(1-x)+F[a]*x;return mL.markAsUpdated(),mL}static DecomposeLerp(L,U,x){const mL=new Q;return Q.DecomposeLerpToRef(L,U,x,mL),mL}static DecomposeLerpToRef(L,U,x,mL){const p=q.YU[0],G=q.Quaternion[0],F=q.YU[1];L.decompose(p,G,F);const a=q.YU[2],o=q.Quaternion[1],A=q.YU[3];U.decompose(a,o,A);const r=q.YU[4];S.LerpToRef(p,a,x,r);const h=q.Quaternion[2];H.SlerpToRef(G,o,x,h);const b=q.YU[5];return S.LerpToRef(F,A,x,b),Q.ComposeToRef(r,h,b,mL),mL}static LookAtLH(L,U,x){const mL=new Q;return Q.LookAtLHToRef(L,U,x,mL),mL}static LookAtLHToRef(L,U,x,mL){const p=q.YU[0],G=q.YU[1],F=q.YU[2];U.subtractToRef(L,F),F.normalize(),S.CrossToRef(x,F,p);const a=p.lengthSquared();0===a?p.x=1:p.normalizeFromLength(Math.sqrt(a)),S.CrossToRef(F,p,G),G.normalize();const o=-S.Dot(p,L),A=-S.Dot(G,L),r=-S.Dot(F,L);return Q.FromValuesToRef(p._x,G._x,F._x,0,p._y,G._y,F._y,0,p._z,G._z,F._z,0,o,A,r,1,mL),mL}static LookAtRH(L,U,x){const mL=new Q;return Q.LookAtRHToRef(L,U,x,mL),mL}static LookAtRHToRef(L,U,x,mL){const p=q.YU[0],G=q.YU[1],F=q.YU[2];L.subtractToRef(U,F),F.normalize(),S.CrossToRef(x,F,p);const a=p.lengthSquared();0===a?p.x=1:p.normalizeFromLength(Math.sqrt(a)),S.CrossToRef(F,p,G),G.normalize();const o=-S.Dot(p,L),A=-S.Dot(G,L),r=-S.Dot(F,L);return Q.FromValuesToRef(p._x,G._x,F._x,0,p._y,G._y,F._y,0,p._z,G._z,F._z,0,o,A,r,1,mL),mL}static LookDirectionLH(L,U){const x=new Q;return Q.LookDirectionLHToRef(L,U,x),x}static LookDirectionLHToRef(L,U,x){const mL=q.YU[0];mL.p(L),mL.scaleInPlace(-1);const p=q.YU[1];return S.CrossToRef(U,mL,p),Q.FromValuesToRef(p._x,p._y,p._z,0,U._x,U._y,U._z,0,mL._x,mL._y,mL._z,0,0,0,0,1,x),x}static LookDirectionRH(L,U){const x=new Q;return Q.LookDirectionRHToRef(L,U,x),x}static LookDirectionRHToRef(L,U,x){const mL=q.YU[2];return S.CrossToRef(U,L,mL),Q.FromValuesToRef(mL._x,mL._y,mL._z,0,U._x,U._y,U._z,0,L._x,L._y,L._z,0,0,0,0,1,x),x}static OrthoLH(L,U,x,mL,p){const G=new Q;return Q.OrthoLHToRef(L,U,x,mL,G,p),G}static OrthoLHToRef(L,U,x,mL,p,G){const F=2/L,a=2/U,o=2/(mL-x),A=-(mL+x)/(mL-x);return Q.FromValuesToRef(F,0,0,0,0,a,0,0,0,0,o,0,0,0,A,1,p),G&&p.multiplyToRef(v,p),p._updateIdentityStatus(1===F&&1===a&&1===o&&0===A),p}static OrthoOffCenterLH(L,U,x,mL,p,G,F){const a=new Q;return Q.OrthoOffCenterLHToRef(L,U,x,mL,p,G,a,F),a}static OrthoOffCenterLHToRef(L,U,x,mL,p,G,F,a){const o=2/(U-L),A=2/(mL-x),r=2/(G-p),h=-(G+p)/(G-p),b=(L+U)/(L-U),E=(mL+x)/(x-mL);return Q.FromValuesToRef(o,0,0,0,0,A,0,0,0,0,r,0,b,E,h,1,F),a&&F.multiplyToRef(v,F),F.markAsUpdated(),F}static ObliqueOffCenterLHToRef(L,U,x,mL,p,G,F,a,o,A,r){const h=-F*Math.cos(a),b=-F*Math.sin(a);return Q.TranslationToRef(0,0,-o,q.Matrix[1]),Q.FromValuesToRef(1,0,0,0,0,1,0,0,h,b,1,0,0,0,0,1,q.Matrix[0]),q.Matrix[1].multiplyToRef(q.Matrix[0],q.Matrix[0]),Q.TranslationToRef(0,0,o,q.Matrix[1]),q.Matrix[0].multiplyToRef(q.Matrix[1],q.Matrix[0]),Q.OrthoOffCenterLHToRef(L,U,x,mL,p,G,A,r),q.Matrix[0].multiplyToRef(A,A),A}static OrthoOffCenterRH(L,U,x,mL,p,G,F){const a=new Q;return Q.OrthoOffCenterRHToRef(L,U,x,mL,p,G,a,F),a}static OrthoOffCenterRHToRef(L,U,x,mL,p,G,F,a){return Q.OrthoOffCenterLHToRef(L,U,x,mL,p,G,F,a),F.ra[10]*=-1,F}static ObliqueOffCenterRHToRef(L,U,x,mL,p,G,F,a,o,A,r){const h=F*Math.cos(a),b=F*Math.sin(a);return Q.TranslationToRef(0,0,o,q.Matrix[1]),Q.FromValuesToRef(1,0,0,0,0,1,0,0,h,b,1,0,0,0,0,1,q.Matrix[0]),q.Matrix[1].multiplyToRef(q.Matrix[0],q.Matrix[0]),Q.TranslationToRef(0,0,-o,q.Matrix[1]),q.Matrix[0].multiplyToRef(q.Matrix[1],q.Matrix[0]),Q.OrthoOffCenterRHToRef(L,U,x,mL,p,G,A,r),q.Matrix[0].multiplyToRef(A,A),A}static PerspectiveLH(L,U,x,mL,p){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const F=new Q,a=2*x/L,o=2*x/U,A=(mL+x)/(mL-x),r=-2*mL*x/(mL-x),h=Math.tan(G);return Q.FromValuesToRef(a,0,0,0,0,o,0,h,0,0,A,1,0,0,r,0,F),p&&F.multiplyToRef(v,F),F._updateIdentityStatus(!1),F}static PerspectiveFovLH(L,U,x,mL,p){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,F=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=new Q;return Q.PerspectiveFovLHToRef(L,U,x,mL,a,!0,p,G,F),a}static PerspectiveFovLHToRef(L,U,x,mL,p){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],F=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,o=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const A=x,r=mL,h=1/Math.tan(.5*L),b=G?h/U:h,E=G?h:h*U,Y=o&&0===A?-1:0!==r?(r+A)/(r-A):1,S=o&&0===A?2*r:0!==r?-2*r*A/(r-A):-2*A,V=Math.tan(a);return Q.FromValuesToRef(b,0,0,0,0,E,0,V,0,0,Y,1,0,0,S,0,p),F&&p.multiplyToRef(v,p),p._updateIdentityStatus(!1),p}static PerspectiveFovReverseLHToRef(L,U,x,mL,p){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],F=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const o=1/Math.tan(.5*L),A=G?o/U:o,r=G?o:o*U,h=Math.tan(a);return Q.FromValuesToRef(A,0,0,0,0,r,0,h,0,0,-x,1,0,0,1,0,p),F&&p.multiplyToRef(v,p),p._updateIdentityStatus(!1),p}static PerspectiveFovRH(L,U,x,mL,p){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,F=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const a=new Q;return Q.PerspectiveFovRHToRef(L,U,x,mL,a,!0,p,G,F),a}static PerspectiveFovRHToRef(L,U,x,mL,p){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],F=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,o=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const A=x,r=mL,h=1/Math.tan(.5*L),b=G?h/U:h,E=G?h:h*U,Y=o&&0===A?1:0!==r?-(r+A)/(r-A):-1,S=o&&0===A?2*r:0!==r?-2*r*A/(r-A):-2*A,V=Math.tan(a);return Q.FromValuesToRef(b,0,0,0,0,E,0,V,0,0,Y,-1,0,0,S,0,p),F&&p.multiplyToRef(v,p),p._updateIdentityStatus(!1),p}static PerspectiveFovReverseRHToRef(L,U,x,mL,p){let G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],F=arguments.length>6?arguments[6]:void 0,a=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const o=1/Math.tan(.5*L),A=G?o/U:o,r=G?o:o*U,h=Math.tan(a);return Q.FromValuesToRef(A,0,0,0,0,r,0,h,0,0,-x,-1,0,0,-1,0,p),F&&p.multiplyToRef(v,p),p._updateIdentityStatus(!1),p}static GetFinalMatrix(L,U,x,mL,p,G){const F=L.width,a=L.height,o=L.x,A=L.y,r=Q.FromValues(F/2,0,0,0,0,-a/2,0,0,0,0,G-p,0,o+F/2,a/2+A,p,1),h=new Q;return U.multiplyToRef(x,h),h.multiplyToRef(mL,h),h.multiplyToRef(r,h)}static GetAsMatrix2x2(L){const U=L.m,x=[U[0],U[1],U[4],U[5]];return F.d.MatrixUse64Bits?x:new Float32Array(x)}static GetAsMatrix3x3(L){const U=L.m,x=[U[0],U[1],U[2],U[4],U[5],U[6],U[8],U[9],U[10]];return F.d.MatrixUse64Bits?x:new Float32Array(x)}static Transpose(L){const U=new Q;return Q.TransposeToRef(L,U),U}static TransposeToRef(L,U){const x=L.m,mL=x[0],p=x[4],G=x[8],F=x[12],a=x[1],o=x[5],A=x[9],r=x[13],h=x[2],b=x[6],E=x[10],Y=x[14],S=x[3],V=x[7],H=x[11],Q=x[15],q=U.ra;return q[0]=mL,q[1]=p,q[2]=G,q[3]=F,q[4]=a,q[5]=o,q[6]=A,q[7]=r,q[8]=h,q[9]=b,q[10]=E,q[11]=Y,q[12]=S,q[13]=V,q[14]=H,q[15]=Q,U.markAsUpdated(),U._updateIdentityStatus(L._isIdentity,L._isIdentityDirty),U}static Reflection(L){const U=new Q;return Q.ReflectionToRef(L,U),U}static ReflectionToRef(L,U){L.normalize();const x=L.normal.x,mL=L.normal.y,p=L.normal.z,G=-2*x,F=-2*mL,a=-2*p;return Q.FromValuesToRef(G*x+1,F*x,a*x,0,G*mL,F*mL+1,a*mL,0,G*p,F*p,a*p+1,0,G*L.d,F*L.d,a*L.d,1,U),U}static FromXYZAxesToRef(L,U,x,mL){return Q.FromValuesToRef(L._x,L._y,L._z,0,U._x,U._y,U._z,0,x._x,x._y,x._z,0,0,0,0,1,mL),mL}static FromQuaternionToRef(L,U){const x=L._x*L._x,mL=L._y*L._y,p=L._z*L._z,G=L._x*L._y,F=L._z*L._w,a=L._z*L._x,o=L._y*L._w,A=L._y*L._z,r=L._x*L._w;return U.ra[0]=1-2*(mL+p),U.ra[1]=2*(G+F),U.ra[2]=2*(a-o),U.ra[3]=0,U.ra[4]=2*(G-F),U.ra[5]=1-2*(p+x),U.ra[6]=2*(A+r),U.ra[7]=0,U.ra[8]=2*(a+o),U.ra[9]=2*(A-r),U.ra[10]=1-2*(mL+x),U.ra[11]=0,U.ra[12]=0,U.ra[13]=0,U.ra[14]=0,U.ra[15]=1,U.markAsUpdated(),U}}Q._IdentityReadOnly=Q.Identity(),Object.defineProperties(Q.prototype,{dimension:{value:[4,4]},rank:{value:2}});class q{}q.YU=(0,p.i)(11,S.Zero),q.Matrix=(0,p.i)(2,Q.Identity),q.Quaternion=(0,p.i)(3,H.Zero);class f{}f.Vector2=(0,p.i)(3,Y.Zero),f.YU=(0,p.i)(13,S.Zero),f.Vector4=(0,p.i)(3,V.Zero),f.Quaternion=(0,p.i)(3,H.Zero),f.Matrix=(0,p.i)(8,Q.Identity),(0,G.d)("BABYLON.Vector2",Y),(0,G.d)("BABYLON.Vector3",S),(0,G.d)("BABYLON.Vector4",V),(0,G.d)("BABYLON.Matrix",Q);const v=Q.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12602:(L,U,x)=>{function mL(L,U){const x=[];for(let mL=0;mL<L;++mL)x.push(U());return x}function p(L,U){return mL(L,U)}x.d(U,{e:()=>mL,i:()=>p,j:()=>F});const G=["push","splice","pop","shift","unshift"];function F(L,U){const x=G.map((x=>function(L,U,x){const mL=L[U];if("function"!==typeof mL)return null;const p=function(){const mL=L.length,G=p.previous.apply(L,arguments);return x(U,mL),G};return mL.next=p,p.previous=mL,L[U]=p,()=>{const x=p.previous;if(!x)return;const mL=p.next;mL?(x.next=mL,mL.previous=x):(x.next=void 0,L[U]=x),p.next=void 0,p.previous=void 0}}(L,x,U)));return()=>{for(const L of x)null===L||void 0===L||L()}}}}]);