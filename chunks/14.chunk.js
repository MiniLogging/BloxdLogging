"use strict";(self.b15p7b72fr8=self.b15p7b72fr8||[]).push([[14],{12598:(s,k,h)=>{h.d(k,{c:()=>i,d:()=>ms,g:()=>A,j:()=>g});const A=1/2.2,g=2.2,ms=(1+Math.sqrt(5))/2,i=.001},12607:(s,k,h)=>{function A(s){return parseInt(s.toString().replace(/\W/g,""))}function g(s,k){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(s-k)<=h}function ms(s,k,h){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return s<k-A||s>h+A}function i(s,k){return s===k?s:Math.random()*(k-s)+s}function K(s,k,h){return s+(k-s)*h}function H(s,k,h){let A=j(k-s,360);return A>180&&(A-=360),s+A*a(h)}function O(s,k,h){let A=0;return A=s!=k?a((h-s)/(k-s)):0,A}function c(s,k,h,A,g){const ms=g*g,i=g*ms;return s*(2*i-3*ms+1)+h*(-2*i+3*ms)+k*(i-2*ms+g)+A*(i-ms)}function S(s,k,h,A,g){const ms=g*g;return 6*(ms-g)*s+(3*ms-4*g+1)*k+6*(-ms+g)*h+(3*ms-2*g)*A}function a(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(h,Math.max(k,s))}function r(s){return s-=2*Math.PI*Math.floor((s+Math.PI)/(2*Math.PI))}function d(s){const k=s.toString(16);return s<=15?("0"+k).toUpperCase():k.toUpperCase()}function E(s){if(Math.log2)return Math.floor(Math.log2(s));if(s<0)return NaN;if(0===s)return-1/0;let k=0;if(s<1){for(;s<1;)k++,s*=2;k=-k}else if(s>1)for(;s>1;)k++,s=Math.floor(s/2);return k}function j(s,k){return s-Math.floor(s/k)*k}function P(s,k,h){return(s-k)/(h-k)}function R(s,k,h){return s*(h-k)+k}function D(s,k){let h=j(k-s,360);return h>180&&(h-=360),h}function w(s,k){const h=j(s,2*k);return k-Math.abs(h-k)}function B(s,k,h){let A=a(h);return A=-2*A*A*A+3*A*A,k*A+s*(1-A)}function u(s,k,h){let A=0;return A=Math.abs(k-s)<=h?k:s+Math.sign(k-s)*h,A}function G(s,k,h){const A=D(s,k);let g=0;return g=-h<A&&A<h?k:u(s,k=s+A,h),g}function Q(s,k,h){return(s-k)/(h-k)}function p(s,k,h){return(h-k)*s+k}function I(s,k){const h=s%k;return 0===h?k:I(k,h)}h.r(k),h.d(k,{Clamp:()=>a,DeltaAngle:()=>D,Denormalize:()=>R,ExtractAsInt:()=>A,Hermite:()=>c,Hermite1stDerivative:()=>S,HighestCommonFactor:()=>I,ILog2:()=>E,InverseLerp:()=>O,Lerp:()=>K,LerpAngle:()=>H,MoveTowards:()=>u,MoveTowardsAngle:()=>G,Normalize:()=>P,NormalizeRadians:()=>r,OutsideRange:()=>ms,PercentToRange:()=>p,PingPong:()=>w,RandomRange:()=>i,RangeToPercent:()=>Q,Repeat:()=>j,SmoothStep:()=>B,ToHex:()=>d,WithinEpsilon:()=>g})},12590:(s,k,h)=>{h.r(k),h.d(k,{Matrix:()=>R,Quaternion:()=>P,TmpVectors:()=>w,Vector2:()=>d,Pk:()=>E,Vector4:()=>j});var A=h(12598),g=h(12603),ms=h(12543),i=h(12508),K=h(12445),H=h(12607);class O{}function c(s,k,h){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const g=s.yh(),ms=k.yh(),i=g[0],K=g[1],H=g[2],O=g[3],c=g[4],S=g[5],a=g[6],r=g[7],d=g[8],E=g[9],j=g[10],P=g[11],R=g[12],D=g[13],w=g[14],B=g[15],u=ms[0],G=ms[1],Q=ms[2],p=ms[3],I=ms[4],N=ms[5],b=ms[6],t=ms[7],z=ms[8],C=ms[9],v=ms[10],Y=ms[11],n=ms[12],T=ms[13],U=ms[14],q=ms[15];h[A]=i*u+K*I+H*z+O*n,h[A+1]=i*G+K*N+H*C+O*T,h[A+2]=i*Q+K*b+H*v+O*U,h[A+3]=i*p+K*t+H*Y+O*q,h[A+4]=c*u+S*I+a*z+r*n,h[A+5]=c*G+S*N+a*C+r*T,h[A+6]=c*Q+S*b+a*v+r*U,h[A+7]=c*p+S*t+a*Y+r*q,h[A+8]=d*u+E*I+j*z+P*n,h[A+9]=d*G+E*N+j*C+P*T,h[A+10]=d*Q+E*b+j*v+P*U,h[A+11]=d*p+E*t+j*Y+P*q,h[A+12]=R*u+D*I+w*z+B*n,h[A+13]=R*G+D*N+w*C+B*T,h[A+14]=R*Q+D*b+w*v+B*U,h[A+15]=R*p+D*t+w*Y+B*q}function S(s,k){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const A=s.yh();k[h]=A[0],k[h+1]=A[1],k[h+2]=A[2],k[h+3]=A[3],k[h+4]=A[4],k[h+5]=A[5],k[h+6]=A[6],k[h+7]=A[7],k[h+8]=A[8],k[h+9]=A[9],k[h+10]=A[10],k[h+11]=A[11],k[h+12]=A[12],k[h+13]=A[13],k[h+14]=A[14],k[h+15]=A[15]}function a(s,k){const h=s.yh(),A=h[0],g=h[1],ms=h[2],i=h[3],K=h[4],H=h[5],O=h[6],c=h[7],S=h[8],a=h[9],r=h[10],d=h[11],E=h[12],j=h[13],P=h[14],R=h[15],D=r*R-P*d,w=a*R-j*d,B=a*P-j*r,u=S*R-E*d,G=S*P-r*E,Q=S*j-E*a,p=+(H*D-O*w+c*B),I=-(K*D-O*u+c*G),N=+(K*w-H*u+c*Q),b=-(K*B-H*G+O*Q),t=A*p+g*I+ms*N+i*b;if(0===t)return!1;const z=1/t,C=O*R-P*c,v=H*R-j*c,Y=H*P-j*O,n=K*R-E*c,T=K*P-E*O,U=K*j-E*H,q=O*d-r*c,M=H*d-a*c,V=H*r-a*O,X=K*d-S*c,L=K*r-S*O,Z=K*a-S*H,x=-(g*D-ms*w+i*B),y=+(A*D-ms*u+i*G),W=-(A*w-g*u+i*Q),J=+(A*B-g*G+ms*Q),F=+(g*C-ms*v+i*Y),o=-(A*C-ms*n+i*T),l=+(A*v-g*n+i*U),f=-(A*Y-g*T+ms*U),e=-(g*q-ms*M+i*V),ss=+(A*q-ms*X+i*L),ks=-(A*M-g*X+i*Z),hs=+(A*V-g*L+ms*Z);return k[0]=p*z,k[1]=x*z,k[2]=F*z,k[3]=e*z,k[4]=I*z,k[5]=y*z,k[6]=o*z,k[7]=ss*z,k[8]=N*z,k[9]=W*z,k[10]=l*z,k[11]=ks*z,k[12]=b*z,k[13]=J*z,k[14]=f*z,k[15]=hs*z,!0}O._UpdateFlagSeed=0;const r=s=>parseInt(s.toString().replace(/\W/g,""));class d{constructor(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=s,this.y=k}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let s=r(this.x);return s=397*s^r(this.y),s}toArray(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return s[k]=this.x,s[k+1]=this.y,this}Nh(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return d.FromArrayToRef(s,k,this),this}yh(){return[this.x,this.y]}H(s){return this.x=s.x,this.y=s.y,this}cg(s,k){return this.x=s,this.y=k,this}set(s,k){return this.cg(s,k)}Eg(s){return this.cg(s,s)}add(s){return new d(this.x+s.x,this.y+s.y)}addToRef(s,k){return k.x=this.x+s.x,k.y=this.y+s.y,k}addInPlace(s){return this.x+=s.x,this.y+=s.y,this}addInPlaceFromFloats(s,k){return this.x+=s,this.y+=k,this}addVector3(s){return new d(this.x+s.x,this.y+s.y)}Rk(s){return new d(this.x-s.x,this.y-s.y)}subtractToRef(s,k){return k.x=this.x-s.x,k.y=this.y-s.y,k}ka(s){return this.x-=s.x,this.y-=s.y,this}multiplyInPlace(s){return this.x*=s.x,this.y*=s.y,this}multiply(s){return new d(this.x*s.x,this.y*s.y)}multiplyToRef(s,k){return k.x=this.x*s.x,k.y=this.y*s.y,k}multiplyByFloats(s,k){return new d(this.x*s,this.y*k)}divide(s){return new d(this.x/s.x,this.y/s.y)}divideToRef(s,k){return k.x=this.x/s.x,k.y=this.y/s.y,k}divideInPlace(s){return this.x=this.x/s.x,this.y=this.y/s.y,this}minimizeInPlace(s){return this.minimizeInPlaceFromFloats(s.x,s.y)}maximizeInPlace(s){return this.maximizeInPlaceFromFloats(s.x,s.y)}minimizeInPlaceFromFloats(s,k){return this.x=Math.min(s,this.x),this.y=Math.min(k,this.y),this}maximizeInPlaceFromFloats(s,k){return this.x=Math.max(s,this.x),this.y=Math.max(k,this.y),this}subtractFromFloats(s,k){return new d(this.x-s,this.y-k)}subtractFromFloatsToRef(s,k,h){return h.x=this.x-s,h.y=this.y-k,h}negate(){return new d(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(s){return s.x=-this.x,s.y=-this.y,s}scaleInPlace(s){return this.x*=s,this.y*=s,this}scale(s){return new d(this.x*s,this.y*s)}scaleToRef(s,k){return k.x=this.x*s,k.y=this.y*s,k}scaleAndAddToRef(s,k){return k.x+=this.x*s,k.y+=this.y*s,k}equals(s){return s&&this.x===s.x&&this.y===s.y}equalsWithEpsilon(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return s&&(0,H.WithinEpsilon)(this.x,s.x,k)&&(0,H.WithinEpsilon)(this.y,s.y,k)}equalsToFloats(s,k){return this.x===s&&this.y===k}floor(){return new d(Math.floor(this.x),Math.floor(this.y))}floorToRef(s){return s.x=Math.floor(this.x),s.y=Math.floor(this.y),s}fract(){return new d(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(s){return s.x=this.x-Math.floor(this.x),s.y=this.y-Math.floor(this.y),s}rotate(s){return this.rotateToRef(s,new d)}rotateToRef(s,k){const h=Math.cos(s),A=Math.sin(s);return k.x=h*this.x-A*this.y,k.y=A*this.x+h*this.y,k}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(s){return 0===s||1===s?this:this.scaleInPlace(1/s)}normalizeToNew(){const s=new d;return this.normalizeToRef(s),s}normalizeToRef(s){const k=this.length();return 0===k&&(s.x=this.x,s.y=this.y),this.scaleToRef(1/k,s)}clone(){return new d(this.x,this.y)}dot(s){return this.x*s.x+this.y*s.y}static Zero(){return new d(0,0)}static One(){return new d(1,1)}static Random(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new d((0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k))}static RandomToRef(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).cg((0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k))}static get ZeroReadOnly(){return d._ZeroReadOnly}static uk(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new d(s[k],s[k+1])}static FromArrayToRef(s,k,h){return h.x=s[k],h.y=s[k+1],h}static FromFloatsToRef(s,k,h){return h.cg(s,k),h}static CatmullRom(s,k,h,A,g){const ms=g*g,i=g*ms,K=.5*(2*k.x+(-s.x+h.x)*g+(2*s.x-5*k.x+4*h.x-A.x)*ms+(-s.x+3*k.x-3*h.x+A.x)*i),H=.5*(2*k.y+(-s.y+h.y)*g+(2*s.y-5*k.y+4*h.y-A.y)*ms+(-s.y+3*k.y-3*h.y+A.y)*i);return new d(K,H)}static ClampToRef(s,k,h,A){return A.x=(0,H.Clamp)(s.x,k.x,h.x),A.y=(0,H.Clamp)(s.y,k.y,h.y),A}static Clamp(s,k,h){const A=(0,H.Clamp)(s.x,k.x,h.x),g=(0,H.Clamp)(s.y,k.y,h.y);return new d(A,g)}static Hermite(s,k,h,A,g){const ms=g*g,i=g*ms,K=2*i-3*ms+1,H=-2*i+3*ms,O=i-2*ms+g,c=i-ms,S=s.x*K+h.x*H+k.x*O+A.x*c,a=s.y*K+h.y*H+k.y*O+A.y*c;return new d(S,a)}static Hermite1stDerivative(s,k,h,A,g){return this.Hermite1stDerivativeToRef(s,k,h,A,g,new d)}static Hermite1stDerivativeToRef(s,k,h,A,g,ms){const i=g*g;return ms.x=6*(i-g)*s.x+(3*i-4*g+1)*k.x+6*(-i+g)*h.x+(3*i-2*g)*A.x,ms.y=6*(i-g)*s.y+(3*i-4*g+1)*k.y+6*(-i+g)*h.y+(3*i-2*g)*A.y,ms}static Lerp(s,k,h){return d.LerpToRef(s,k,h,new d)}static LerpToRef(s,k,h,A){return A.x=s.x+(k.x-s.x)*h,A.y=s.y+(k.y-s.y)*h,A}static Dot(s,k){return s.x*k.x+s.y*k.y}static Normalize(s){return d.NormalizeToRef(s,new d)}static NormalizeToRef(s,k){return s.normalizeToRef(k),k}static Minimize(s,k){const h=s.x<k.x?s.x:k.x,A=s.y<k.y?s.y:k.y;return new d(h,A)}static Maximize(s,k){const h=s.x>k.x?s.x:k.x,A=s.y>k.y?s.y:k.y;return new d(h,A)}static Transform(s,k){return d.TransformToRef(s,k,new d)}static TransformToRef(s,k,h){const A=k.m,g=s.x*A[0]+s.y*A[4]+A[12],ms=s.x*A[1]+s.y*A[5]+A[13];return h.x=g,h.y=ms,h}static PointInTriangle(s,k,h,A){const g=.5*(-h.y*A.x+k.y*(-h.x+A.x)+k.x*(h.y-A.y)+h.x*A.y),ms=g<0?-1:1,i=(k.y*A.x-k.x*A.y+(A.y-k.y)*s.x+(k.x-A.x)*s.y)*ms,K=(k.x*h.y-k.y*h.x+(k.y-h.y)*s.x+(h.x-k.x)*s.y)*ms;return i>0&&K>0&&i+K<2*g*ms}static Distance(s,k){return Math.sqrt(d.DistanceSquared(s,k))}static DistanceSquared(s,k){const h=s.x-k.x,A=s.y-k.y;return h*h+A*A}static Center(s,k){return d.CenterToRef(s,k,new d)}static CenterToRef(s,k,h){return h.cg((s.x+k.x)/2,(s.y+k.y)/2)}static DistanceOfPointFromSegment(s,k,h){const A=d.DistanceSquared(k,h);if(0===A)return d.Distance(s,k);const g=h.Rk(k),ms=Math.max(0,Math.min(1,d.Dot(s.Rk(k),g)/A)),i=k.add(g.multiplyByFloats(ms,ms));return d.Distance(s,i)}}d._V8PerformanceHack=new d(.5,.5),d._ZeroReadOnly=d.Zero(),Object.defineProperties(d.prototype,{dimension:{value:[2]},rank:{value:1}});class E{get x(){return this._x}set x(s){this._x=s,this._isDirty=!0}get y(){return this._y}set y(s){this._y=s,this._isDirty=!0}get z(){return this._z}set z(s){this._z=s,this._isDirty=!0}constructor(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=s,this._y=k,this._z=h}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Pk"}getHashCode(){let s=r(this._x);return s=397*s^r(this._y),s=397*s^r(this._z),s}yh(){return[this._x,this._y,this._z]}toArray(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return s[k]=this._x,s[k+1]=this._y,s[k+2]=this._z,this}Nh(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(s,k,this),this}toQuaternion(){return P.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(s){return this._x+=s._x,this._y+=s._y,this._z+=s._z,this._isDirty=!0,this}addInPlaceFromFloats(s,k,h){return this._x+=s,this._y+=k,this._z+=h,this._isDirty=!0,this}add(s){return new E(this._x+s._x,this._y+s._y,this._z+s._z)}addToRef(s,k){return k._x=this._x+s._x,k._y=this._y+s._y,k._z=this._z+s._z,k._isDirty=!0,k}ka(s){return this._x-=s._x,this._y-=s._y,this._z-=s._z,this._isDirty=!0,this}Rk(s){return new E(this._x-s._x,this._y-s._y,this._z-s._z)}subtractToRef(s,k){return this.subtractFromFloatsToRef(s._x,s._y,s._z,k)}subtractFromFloats(s,k,h){return new E(this._x-s,this._y-k,this._z-h)}subtractFromFloatsToRef(s,k,h,A){return A._x=this._x-s,A._y=this._y-k,A._z=this._z-h,A._isDirty=!0,A}negate(){return new E(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(s){return s._x=-1*this._x,s._y=-1*this._y,s._z=-1*this._z,s._isDirty=!0,s}scaleInPlace(s){return this._x*=s,this._y*=s,this._z*=s,this._isDirty=!0,this}scale(s){return new E(this._x*s,this._y*s,this._z*s)}scaleToRef(s,k){return k._x=this._x*s,k._y=this._y*s,k._z=this._z*s,k._isDirty=!0,k}getNormalToRef(s){const k=this.length();let h=Math.acos(this._y/k);const A=Math.atan2(this._z,this._x);h>Math.PI/2?h-=Math.PI/2:h+=Math.PI/2;const g=k*Math.sin(h)*Math.cos(A),ms=k*Math.cos(h),i=k*Math.sin(h)*Math.sin(A);return s.set(g,ms,i),s}applyRotationQuaternionToRef(s,k){const h=this._x,A=this._y,g=this._z,ms=s._x,i=s._y,K=s._z,H=s._w,O=2*(i*g-K*A),c=2*(K*h-ms*g),S=2*(ms*A-i*h);return k._x=h+H*O+i*S-K*c,k._y=A+H*c+K*O-ms*S,k._z=g+H*S+ms*c-i*O,k._isDirty=!0,k}applyRotationQuaternionInPlace(s){return this.applyRotationQuaternionToRef(s,this)}applyRotationQuaternion(s){return this.applyRotationQuaternionToRef(s,new E)}scaleAndAddToRef(s,k){return k._x+=this._x*s,k._y+=this._y*s,k._z+=this._z*s,k._isDirty=!0,k}projectOnPlane(s,k){return this.projectOnPlaneToRef(s,k,new E)}projectOnPlaneToRef(s,k,h){const A=s.normal,g=s.d,ms=D.Pk[0];this.subtractToRef(k,ms),ms.normalize();const i=E.Dot(ms,A);if(Math.abs(i)<1e-10)h.Eg(1/0);else{const s=-(E.Dot(k,A)+g)/i,K=ms.scaleInPlace(s);k.addToRef(K,h)}return h}equals(s){return s&&this._x===s._x&&this._y===s._y&&this._z===s._z}equalsWithEpsilon(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return s&&(0,H.WithinEpsilon)(this._x,s._x,k)&&(0,H.WithinEpsilon)(this._y,s._y,k)&&(0,H.WithinEpsilon)(this._z,s._z,k)}equalsToFloats(s,k,h){return this._x===s&&this._y===k&&this._z===h}multiplyInPlace(s){return this._x*=s._x,this._y*=s._y,this._z*=s._z,this._isDirty=!0,this}multiply(s){return this.multiplyByFloats(s._x,s._y,s._z)}multiplyToRef(s,k){return k._x=this._x*s._x,k._y=this._y*s._y,k._z=this._z*s._z,k._isDirty=!0,k}multiplyByFloats(s,k,h){return new E(this._x*s,this._y*k,this._z*h)}divide(s){return new E(this._x/s._x,this._y/s._y,this._z/s._z)}divideToRef(s,k){return k._x=this._x/s._x,k._y=this._y/s._y,k._z=this._z/s._z,k._isDirty=!0,k}divideInPlace(s){return this._x=this._x/s._x,this._y=this._y/s._y,this._z=this._z/s._z,this._isDirty=!0,this}minimizeInPlace(s){return this.minimizeInPlaceFromFloats(s._x,s._y,s._z)}maximizeInPlace(s){return this.maximizeInPlaceFromFloats(s._x,s._y,s._z)}minimizeInPlaceFromFloats(s,k,h){return s<this._x&&(this.x=s),k<this._y&&(this.y=k),h<this._z&&(this.z=h),this}maximizeInPlaceFromFloats(s,k,h){return s>this._x&&(this.x=s),k>this._y&&(this.y=k),h>this._z&&(this.z=h),this}isNonUniformWithinEpsilon(s){const k=Math.abs(this._x),h=Math.abs(this._y);if(!(0,H.WithinEpsilon)(k,h,s))return!0;const A=Math.abs(this._z);return!(0,H.WithinEpsilon)(k,A,s)||!(0,H.WithinEpsilon)(h,A,s)}get isNonUniform(){const s=Math.abs(this._x);if(s!==Math.abs(this._y))return!0;return s!==Math.abs(this._z)}floorToRef(s){return s._x=Math.floor(this._x),s._y=Math.floor(this._y),s._z=Math.floor(this._z),s._isDirty=!0,s}floor(){return new E(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(s){return s._x=this._x-Math.floor(this._x),s._y=this._y-Math.floor(this._y),s._z=this._z-Math.floor(this._z),s._isDirty=!0,s}fract(){return new E(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(s){if("xyz"===(s=s.toLowerCase()))return this;const k=D.Pk[0].H(this);return this.x=k[s[0]],this.y=k[s[1]],this.z=k[s[2]],this}rotateByQuaternionToRef(s,k){return s.toRotationMatrix(D.Matrix[0]),E.TransformCoordinatesToRef(this,D.Matrix[0],k),k}rotateByQuaternionAroundPointToRef(s,k,h){return this.subtractToRef(k,D.Pk[0]),D.Pk[0].rotateByQuaternionToRef(s,D.Pk[0]),k.addToRef(D.Pk[0],h),h}cross(s){return E.CrossToRef(this,s,new E)}normalizeFromLength(s){return 0===s||1===s?this:this.scaleInPlace(1/s)}normalizeToNew(){return this.normalizeToRef(new E)}normalizeToRef(s){const k=this.length();return 0===k||1===k?(s._x=this._x,s._y=this._y,s._z=this._z,s._isDirty=!0,s):this.scaleToRef(1/k,s)}clone(){return new E(this._x,this._y,this._z)}H(s){return this.cg(s._x,s._y,s._z)}cg(s,k,h){return this._x=s,this._y=k,this._z=h,this._isDirty=!0,this}set(s,k,h){return this.cg(s,k,h)}Eg(s){return this._x=this._y=this._z=s,this._isDirty=!0,this}static GetClipFactor(s,k,h,A){const g=E.Dot(s,h);return(g-A)/(g-E.Dot(k,h))}static GetAngleBetweenVectors(s,k,h){const A=s.normalizeToRef(D.Pk[1]),g=k.normalizeToRef(D.Pk[2]);let ms=E.Dot(A,g);ms=(0,H.Clamp)(ms,-1,1);const i=Math.acos(ms),K=D.Pk[3];return E.CrossToRef(A,g,K),E.Dot(K,h)>0?isNaN(i)?0:i:isNaN(i)?-Math.PI:-Math.acos(ms)}static GetAngleBetweenVectorsOnPlane(s,k,h){D.Pk[0].H(s);const A=D.Pk[0];D.Pk[1].H(k);const g=D.Pk[1];D.Pk[2].H(h);const ms=D.Pk[2],i=D.Pk[3],K=D.Pk[4];A.normalize(),g.normalize(),ms.normalize(),E.CrossToRef(ms,A,i),E.CrossToRef(i,ms,K);const O=Math.atan2(E.Dot(g,i),E.Dot(g,K));return(0,H.NormalizeRadians)(O)}static PitchYawRollToMoveBetweenPointsToRef(s,k,h){const A=w.Pk[0];return k.subtractToRef(s,A),h._y=Math.atan2(A.x,A.z)||0,h._x=Math.atan2(Math.sqrt(A.x**2+A.z**2),A.y)||0,h._z=0,h._isDirty=!0,h}static PitchYawRollToMoveBetweenPoints(s,k){const h=E.Zero();return E.PitchYawRollToMoveBetweenPointsToRef(s,k,h)}static SlerpToRef(s,k,h,g){h=(0,H.Clamp)(h,0,1);const ms=D.Pk[0],i=D.Pk[1];ms.H(s);const K=ms.length();ms.normalizeFromLength(K),i.H(k);const O=i.length();i.normalizeFromLength(O);const c=E.Dot(ms,i);let S,a;if(c<1-A.c){const s=Math.acos(c),k=1/Math.sin(s);S=Math.sin((1-h)*s)*k,a=Math.sin(h*s)*k}else S=1-h,a=h;return ms.scaleInPlace(S),i.scaleInPlace(a),g.H(ms).addInPlace(i),g.scaleInPlace((0,H.Lerp)(K,O,h)),g}static SmoothToRef(s,k,h,A,g){return E.SlerpToRef(s,k,0===A?1:h/A,g),g}static uk(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(s[k],s[k+1],s[k+2])}static FromFloatArray(s,k){return E.uk(s,k)}static FromArrayToRef(s,k,h){return h._x=s[k],h._y=s[k+1],h._z=s[k+2],h._isDirty=!0,h}static FromFloatArrayToRef(s,k,h){return E.FromArrayToRef(s,k,h)}static FromFloatsToRef(s,k,h,A){return A.cg(s,k,h),A}static Zero(){return new E(0,0,0)}static One(){return new E(1,1,1)}static Up(){return new E(0,1,0)}static get UpReadOnly(){return E._UpReadOnly}static get DownReadOnly(){return E._DownReadOnly}static get RightReadOnly(){return E._RightReadOnly}static get LeftReadOnly(){return E._LeftReadOnly}static get LeftHandedForwardReadOnly(){return E._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return E._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return E._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return E._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return E._ZeroReadOnly}static get OneReadOnly(){return E._OneReadOnly}static Down(){return new E(0,-1,0)}static Forward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new E(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new E(1,0,0)}static Left(){return new E(-1,0,0)}static Random(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E((0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k))}static RandomToRef(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).cg((0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k))}static TransformCoordinates(s,k){const h=E.Zero();return E.TransformCoordinatesToRef(s,k,h),h}static TransformCoordinatesToRef(s,k,h){return E.TransformCoordinatesFromFloatsToRef(s._x,s._y,s._z,k,h),h}static TransformCoordinatesFromFloatsToRef(s,k,h,A,g){const ms=A.m,i=s*ms[0]+k*ms[4]+h*ms[8]+ms[12],K=s*ms[1]+k*ms[5]+h*ms[9]+ms[13],H=s*ms[2]+k*ms[6]+h*ms[10]+ms[14],O=1/(s*ms[3]+k*ms[7]+h*ms[11]+ms[15]);return g._x=i*O,g._y=K*O,g._z=H*O,g._isDirty=!0,g}static TransformNormal(s,k){const h=E.Zero();return E.TransformNormalToRef(s,k,h),h}static TransformNormalToRef(s,k,h){return this.TransformNormalFromFloatsToRef(s._x,s._y,s._z,k,h),h}static TransformNormalFromFloatsToRef(s,k,h,A,g){const ms=A.m;return g._x=s*ms[0]+k*ms[4]+h*ms[8],g._y=s*ms[1]+k*ms[5]+h*ms[9],g._z=s*ms[2]+k*ms[6]+h*ms[10],g._isDirty=!0,g}static CatmullRom(s,k,h,A,g){const ms=g*g,i=g*ms,K=.5*(2*k._x+(-s._x+h._x)*g+(2*s._x-5*k._x+4*h._x-A._x)*ms+(-s._x+3*k._x-3*h._x+A._x)*i),H=.5*(2*k._y+(-s._y+h._y)*g+(2*s._y-5*k._y+4*h._y-A._y)*ms+(-s._y+3*k._y-3*h._y+A._y)*i),O=.5*(2*k._z+(-s._z+h._z)*g+(2*s._z-5*k._z+4*h._z-A._z)*ms+(-s._z+3*k._z-3*h._z+A._z)*i);return new E(K,H,O)}static Clamp(s,k,h){const A=new E;return E.ClampToRef(s,k,h,A),A}static ClampToRef(s,k,h,A){let g=s._x;g=g>h._x?h._x:g,g=g<k._x?k._x:g;let ms=s._y;ms=ms>h._y?h._y:ms,ms=ms<k._y?k._y:ms;let i=s._z;return i=i>h._z?h._z:i,i=i<k._z?k._z:i,A.cg(g,ms,i),A}static CheckExtends(s,k,h){k.minimizeInPlace(s),h.maximizeInPlace(s)}static Hermite(s,k,h,A,g){const ms=g*g,i=g*ms,K=2*i-3*ms+1,H=-2*i+3*ms,O=i-2*ms+g,c=i-ms,S=s._x*K+h._x*H+k._x*O+A._x*c,a=s._y*K+h._y*H+k._y*O+A._y*c,r=s._z*K+h._z*H+k._z*O+A._z*c;return new E(S,a,r)}static Hermite1stDerivative(s,k,h,A,g){const ms=new E;return this.Hermite1stDerivativeToRef(s,k,h,A,g,ms),ms}static Hermite1stDerivativeToRef(s,k,h,A,g,ms){const i=g*g;return ms._x=6*(i-g)*s._x+(3*i-4*g+1)*k._x+6*(-i+g)*h._x+(3*i-2*g)*A._x,ms._y=6*(i-g)*s._y+(3*i-4*g+1)*k._y+6*(-i+g)*h._y+(3*i-2*g)*A._y,ms._z=6*(i-g)*s._z+(3*i-4*g+1)*k._z+6*(-i+g)*h._z+(3*i-2*g)*A._z,ms._isDirty=!0,ms}static Lerp(s,k,h){const A=new E(0,0,0);return E.LerpToRef(s,k,h,A),A}static LerpToRef(s,k,h,A){return A._x=s._x+(k._x-s._x)*h,A._y=s._y+(k._y-s._y)*h,A._z=s._z+(k._z-s._z)*h,A._isDirty=!0,A}static Dot(s,k){return s._x*k._x+s._y*k._y+s._z*k._z}dot(s){return this._x*s._x+this._y*s._y+this._z*s._z}static Cross(s,k){const h=new E;return E.CrossToRef(s,k,h),h}static CrossToRef(s,k,h){const A=s._y*k._z-s._z*k._y,g=s._z*k._x-s._x*k._z,ms=s._x*k._y-s._y*k._x;return h.cg(A,g,ms),h}static Normalize(s){const k=E.Zero();return E.NormalizeToRef(s,k),k}static NormalizeToRef(s,k){return s.normalizeToRef(k),k}static Project(s,k,h,A){const g=new E;return E.ProjectToRef(s,k,h,A,g),g}static ProjectToRef(s,k,h,A,g){var ms;const i=A.width,H=A.height,O=A.x,c=A.y,S=D.Matrix[1],a=null===(ms=K.b.LastCreatedEngine)||void 0===ms?void 0:ms.isNDCHalfZRange,r=a?1:.5,d=a?0:.5;R.FromValuesToRef(i/2,0,0,0,0,-H/2,0,0,0,0,r,0,O+i/2,H/2+c,d,1,S);const j=D.Matrix[0];return k.multiplyToRef(h,j),j.multiplyToRef(S,j),E.TransformCoordinatesToRef(s,j,g),g}static Reflect(s,k){return this.ReflectToRef(s,k,new E)}static ReflectToRef(s,k,h){const A=w.Pk[0];return A.H(k).scaleInPlace(2*E.Dot(s,k)),h.H(s).ka(A)}static _UnprojectFromInvertedMatrixToRef(s,k,h){E.TransformCoordinatesToRef(s,k,h);const A=k.m,g=s._x*A[3]+s._y*A[7]+s._z*A[11]+A[15];return(0,H.WithinEpsilon)(g,1)&&h.scaleInPlace(1/g),h}static UnprojectFromTransform(s,k,h,A,g){return this.Unproject(s,k,h,A,g,R.IdentityReadOnly)}static Unproject(s,k,h,A,g,ms){const i=new E;return E.UnprojectToRef(s,k,h,A,g,ms,i),i}static UnprojectToRef(s,k,h,A,g,ms,i){return E.UnprojectFloatsToRef(s._x,s._y,s._z,k,h,A,g,ms,i),i}static UnprojectFloatsToRef(s,k,h,A,g,ms,i,H,O){var c;const S=D.Matrix[0];ms.multiplyToRef(i,S),S.multiplyToRef(H,S),S.invert();const a=D.Pk[0];return a.x=s/A*2-1,a.y=-(k/g*2-1),null!==(c=K.b.LastCreatedEngine)&&void 0!==c&&c.isNDCHalfZRange?a.z=h:a.z=2*h-1,E._UnprojectFromInvertedMatrixToRef(a,S,O),O}static Minimize(s,k){const h=new E;return h.H(s),h.minimizeInPlace(k),h}static Maximize(s,k){const h=new E;return h.H(s),h.maximizeInPlace(k),h}static Distance(s,k){return Math.sqrt(E.DistanceSquared(s,k))}static DistanceSquared(s,k){const h=s._x-k._x,A=s._y-k._y,g=s._z-k._z;return h*h+A*A+g*g}static ProjectOnTriangleToRef(s,k,h,g,ms){const i=D.Pk[0],K=D.Pk[1],O=D.Pk[2],c=D.Pk[3],S=D.Pk[4];h.subtractToRef(k,i),g.subtractToRef(k,K),g.subtractToRef(h,O);const a=i.length(),r=K.length(),d=O.length();if(a<A.c||r<A.c||d<A.c)return ms.H(k),E.Distance(s,k);s.subtractToRef(k,S),E.CrossToRef(i,K,c);const j=c.length();if(j<A.c)return ms.H(k),E.Distance(s,k);c.normalizeFromLength(j);let P=S.length();if(P<A.c)return ms.H(k),0;S.normalizeFromLength(P);const R=E.Dot(c,S),w=D.Pk[5],B=D.Pk[6];w.H(c).scaleInPlace(-P*R),B.H(s).addInPlace(w);const u=D.Pk[4],G=D.Pk[5],Q=D.Pk[7],p=D.Pk[8];u.H(i).scaleInPlace(1/a),p.H(K).scaleInPlace(1/r),u.addInPlace(p).scaleInPlace(-1),G.H(i).scaleInPlace(-1/a),p.H(O).scaleInPlace(1/d),G.addInPlace(p).scaleInPlace(-1),Q.H(O).scaleInPlace(-1/d),p.H(K).scaleInPlace(-1/r),Q.addInPlace(p).scaleInPlace(-1);const I=D.Pk[9];let N;I.H(B).ka(k),E.CrossToRef(u,I,p),N=E.Dot(p,c);const b=N;I.H(B).ka(h),E.CrossToRef(G,I,p),N=E.Dot(p,c);const t=N;I.H(B).ka(g),E.CrossToRef(Q,I,p),N=E.Dot(p,c);const z=N,C=D.Pk[10];let v,Y;b>0&&t<0?(C.H(i),v=k,Y=h):t>0&&z<0?(C.H(O),v=h,Y=g):(C.H(K).scaleInPlace(-1),v=g,Y=k);const n=D.Pk[9],T=D.Pk[4];v.subtractToRef(B,p),Y.subtractToRef(B,n),E.CrossToRef(p,n,T);if(!(E.Dot(T,c)<0))return ms.H(B),Math.abs(P*R);const U=D.Pk[5];E.CrossToRef(C,T,U),U.normalize();const q=D.Pk[9];q.H(v).ka(B);const M=q.length();if(M<A.c)return ms.H(v),E.Distance(s,v);q.normalizeFromLength(M);const V=E.Dot(U,q),X=D.Pk[7];X.H(B).addInPlace(U.scaleInPlace(M*V)),p.H(X).ka(v),P=C.length(),C.normalizeFromLength(P);let L=E.Dot(p,C)/Math.max(P,A.c);return L=(0,H.Clamp)(L,0,1),X.H(v).addInPlace(C.scaleInPlace(L*P)),ms.H(X),E.Distance(s,X)}static Center(s,k){return E.CenterToRef(s,k,E.Zero())}static CenterToRef(s,k,h){return h.cg((s._x+k._x)/2,(s._y+k._y)/2,(s._z+k._z)/2)}static RotationFromAxis(s,k,h){const A=new E;return E.RotationFromAxisToRef(s,k,h,A),A}static RotationFromAxisToRef(s,k,h,A){const g=D.Quaternion[0];return P.RotationQuaternionFromAxisToRef(s,k,h,g),g.toEulerAnglesToRef(A),A}}E._V8PerformanceHack=new E(.5,.5,.5),E._UpReadOnly=E.Up(),E._DownReadOnly=E.Down(),E._LeftHandedForwardReadOnly=E.Forward(!1),E._RightHandedForwardReadOnly=E.Forward(!0),E._LeftHandedBackwardReadOnly=E.Backward(!1),E._RightHandedBackwardReadOnly=E.Backward(!0),E._RightReadOnly=E.Right(),E._LeftReadOnly=E.Left(),E._ZeroReadOnly=E.Zero(),E._OneReadOnly=E.One(),Object.defineProperties(E.prototype,{dimension:{value:[3]},rank:{value:1}});class j{get x(){return this._x}set x(s){this._x=s,this._isDirty=!0}get y(){return this._y}set y(s){this._y=s,this._isDirty=!0}get z(){return this._z}set z(s){this._z=s,this._isDirty=!0}get w(){return this._w}set w(s){this._w=s,this._isDirty=!0}constructor(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=s,this._y=k,this._z=h,this._w=A}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let s=r(this._x);return s=397*s^r(this._y),s=397*s^r(this._z),s=397*s^r(this._w),s}yh(){return[this._x,this._y,this._z,this._w]}toArray(s,k){return void 0===k&&(k=0),s[k]=this._x,s[k+1]=this._y,s[k+2]=this._z,s[k+3]=this._w,this}Nh(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return j.FromArrayToRef(s,k,this),this}addInPlace(s){return this.x+=s._x,this.y+=s._y,this.z+=s._z,this.w+=s._w,this}addInPlaceFromFloats(s,k,h,A){return this.x+=s,this.y+=k,this.z+=h,this.w+=A,this}add(s){return new j(this._x+s.x,this._y+s.y,this._z+s.z,this._w+s.w)}addToRef(s,k){return k.x=this._x+s.x,k.y=this._y+s.y,k.z=this._z+s.z,k.w=this._w+s.w,k}ka(s){return this.x-=s.x,this.y-=s.y,this.z-=s.z,this.w-=s.w,this}Rk(s){return new j(this._x-s.x,this._y-s.y,this._z-s.z,this._w-s.w)}subtractToRef(s,k){return k.x=this._x-s.x,k.y=this._y-s.y,k.z=this._z-s.z,k.w=this._w-s.w,k}subtractFromFloats(s,k,h,A){return new j(this._x-s,this._y-k,this._z-h,this._w-A)}subtractFromFloatsToRef(s,k,h,A,g){return g.x=this._x-s,g.y=this._y-k,g.z=this._z-h,g.w=this._w-A,g}negate(){return new j(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(s){return s.x=-this._x,s.y=-this._y,s.z=-this._z,s.w=-this._w,s}scaleInPlace(s){return this.x*=s,this.y*=s,this.z*=s,this.w*=s,this}scale(s){return new j(this._x*s,this._y*s,this._z*s,this._w*s)}scaleToRef(s,k){return k.x=this._x*s,k.y=this._y*s,k.z=this._z*s,k.w=this._w*s,k}scaleAndAddToRef(s,k){return k.x+=this._x*s,k.y+=this._y*s,k.z+=this._z*s,k.w+=this._w*s,k}equals(s){return s&&this._x===s.x&&this._y===s.y&&this._z===s.z&&this._w===s.w}equalsWithEpsilon(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return s&&(0,H.WithinEpsilon)(this._x,s.x,k)&&(0,H.WithinEpsilon)(this._y,s.y,k)&&(0,H.WithinEpsilon)(this._z,s.z,k)&&(0,H.WithinEpsilon)(this._w,s.w,k)}equalsToFloats(s,k,h,A){return this._x===s&&this._y===k&&this._z===h&&this._w===A}multiplyInPlace(s){return this.x*=s.x,this.y*=s.y,this.z*=s.z,this.w*=s.w,this}multiply(s){return new j(this._x*s.x,this._y*s.y,this._z*s.z,this._w*s.w)}multiplyToRef(s,k){return k.x=this._x*s.x,k.y=this._y*s.y,k.z=this._z*s.z,k.w=this._w*s.w,k}multiplyByFloats(s,k,h,A){return new j(this._x*s,this._y*k,this._z*h,this._w*A)}divide(s){return new j(this._x/s.x,this._y/s.y,this._z/s.z,this._w/s.w)}divideToRef(s,k){return k.x=this._x/s.x,k.y=this._y/s.y,k.z=this._z/s.z,k.w=this._w/s.w,k}divideInPlace(s){return this.divideToRef(s,this)}minimizeInPlace(s){return s.x<this._x&&(this.x=s.x),s.y<this._y&&(this.y=s.y),s.z<this._z&&(this.z=s.z),s.w<this._w&&(this.w=s.w),this}maximizeInPlace(s){return s.x>this._x&&(this.x=s.x),s.y>this._y&&(this.y=s.y),s.z>this._z&&(this.z=s.z),s.w>this._w&&(this.w=s.w),this}minimizeInPlaceFromFloats(s,k,h,A){return this.x=Math.min(s,this._x),this.y=Math.min(k,this._y),this.z=Math.min(h,this._z),this.w=Math.min(A,this._w),this}maximizeInPlaceFromFloats(s,k,h,A){return this.x=Math.max(s,this._x),this.y=Math.max(k,this._y),this.z=Math.max(h,this._z),this.w=Math.max(A,this._w),this}floorToRef(s){return s.x=Math.floor(this._x),s.y=Math.floor(this._y),s.z=Math.floor(this._z),s.w=Math.floor(this._w),s}floor(){return new j(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(s){return s.x=this._x-Math.floor(this._x),s.y=this._y-Math.floor(this._y),s.z=this._z-Math.floor(this._z),s.w=this._w-Math.floor(this._w),s}fract(){return new j(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(s){return 0===s||1===s?this:this.scaleInPlace(1/s)}normalizeToNew(){return this.normalizeToRef(new j)}normalizeToRef(s){const k=this.length();return 0===k||1===k?(s.x=this._x,s.y=this._y,s.z=this._z,s.w=this._w,s):this.scaleToRef(1/k,s)}toVector3(){return new E(this._x,this._y,this._z)}clone(){return new j(this._x,this._y,this._z,this._w)}H(s){return this.x=s.x,this.y=s.y,this.z=s.z,this.w=s.w,this}cg(s,k,h,A){return this.x=s,this.y=k,this.z=h,this.w=A,this}set(s,k,h,A){return this.cg(s,k,h,A)}Eg(s){return this.x=this.y=this.z=this.w=s,this}dot(s){return this._x*s.x+this._y*s.y+this._z*s.z+this._w*s.w}static uk(s,k){return k||(k=0),new j(s[k],s[k+1],s[k+2],s[k+3])}static FromArrayToRef(s,k,h){return h.x=s[k],h.y=s[k+1],h.z=s[k+2],h.w=s[k+3],h}static FromFloatArrayToRef(s,k,h){return j.FromArrayToRef(s,k,h),h}static FromFloatsToRef(s,k,h,A,g){return g.x=s,g.y=k,g.z=h,g.w=A,g}static Zero(){return new j(0,0,0,0)}static One(){return new j(1,1,1,1)}static Random(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new j((0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k))}static RandomToRef(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0;return h.x=(0,H.RandomRange)(s,k),h.y=(0,H.RandomRange)(s,k),h.z=(0,H.RandomRange)(s,k),h.w=(0,H.RandomRange)(s,k),h}static Clamp(s,k,h){return j.ClampToRef(s,k,h,new j)}static ClampToRef(s,k,h,A){return A.x=(0,H.Clamp)(s.x,k.x,h.x),A.y=(0,H.Clamp)(s.y,k.y,h.y),A.z=(0,H.Clamp)(s.z,k.z,h.z),A.w=(0,H.Clamp)(s.w,k.w,h.w),A}static CheckExtends(s,k,h){k.minimizeInPlace(s),h.maximizeInPlace(s)}static get ZeroReadOnly(){return j._ZeroReadOnly}static Normalize(s){return j.NormalizeToRef(s,new j)}static NormalizeToRef(s,k){return s.normalizeToRef(k),k}static Minimize(s,k){const h=new j;return h.H(s),h.minimizeInPlace(k),h}static Maximize(s,k){const h=new j;return h.H(s),h.maximizeInPlace(k),h}static Distance(s,k){return Math.sqrt(j.DistanceSquared(s,k))}static DistanceSquared(s,k){const h=s.x-k.x,A=s.y-k.y,g=s.z-k.z,ms=s.w-k.w;return h*h+A*A+g*g+ms*ms}static Center(s,k){return j.CenterToRef(s,k,new j)}static CenterToRef(s,k,h){return h.x=(s.x+k.x)/2,h.y=(s.y+k.y)/2,h.z=(s.z+k.z)/2,h.w=(s.w+k.w)/2,h}static TransformCoordinates(s,k){return j.TransformCoordinatesToRef(s,k,new j)}static TransformCoordinatesToRef(s,k,h){return j.TransformCoordinatesFromFloatsToRef(s._x,s._y,s._z,k,h),h}static TransformCoordinatesFromFloatsToRef(s,k,h,A,g){const ms=A.m,i=s*ms[0]+k*ms[4]+h*ms[8]+ms[12],K=s*ms[1]+k*ms[5]+h*ms[9]+ms[13],H=s*ms[2]+k*ms[6]+h*ms[10]+ms[14],O=s*ms[3]+k*ms[7]+h*ms[11]+ms[15];return g.x=i,g.y=K,g.z=H,g.w=O,g}static TransformNormal(s,k){return j.TransformNormalToRef(s,k,new j)}static TransformNormalToRef(s,k,h){const A=k.m,g=s.x*A[0]+s.y*A[4]+s.z*A[8],ms=s.x*A[1]+s.y*A[5]+s.z*A[9],i=s.x*A[2]+s.y*A[6]+s.z*A[10];return h.x=g,h.y=ms,h.z=i,h.w=s.w,h}static TransformNormalFromFloatsToRef(s,k,h,A,g,ms){const i=g.m;return ms.x=s*i[0]+k*i[4]+h*i[8],ms.y=s*i[1]+k*i[5]+h*i[9],ms.z=s*i[2]+k*i[6]+h*i[10],ms.w=A,ms}static FromVector3(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new j(s._x,s._y,s._z,k)}static Dot(s,k){return s.x*k.x+s.y*k.y+s.z*k.z+s.w*k.w}}j._V8PerformanceHack=new j(.5,.5,.5,.5),j._ZeroReadOnly=j.Zero(),Object.defineProperties(j.prototype,{dimension:{value:[4]},rank:{value:1}});class P{get x(){return this._x}set x(s){this._x=s,this._isDirty=!0}get y(){return this._y}set y(s){this._y=s,this._isDirty=!0}get z(){return this._z}set z(s){this._z=s,this._isDirty=!0}get w(){return this._w}set w(s){this._w=s,this._isDirty=!0}constructor(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=s,this._y=k,this._z=h,this._w=A}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let s=r(this._x);return s=397*s^r(this._y),s=397*s^r(this._z),s=397*s^r(this._w),s}yh(){return[this._x,this._y,this._z,this._w]}toArray(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return s[k]=this._x,s[k+1]=this._y,s[k+2]=this._z,s[k+3]=this._w,this}Nh(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P.FromArrayToRef(s,k,this)}equals(s){return s&&this._x===s._x&&this._y===s._y&&this._z===s._z&&this._w===s._w}equalsWithEpsilon(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return s&&(0,H.WithinEpsilon)(this._x,s._x,k)&&(0,H.WithinEpsilon)(this._y,s._y,k)&&(0,H.WithinEpsilon)(this._z,s._z,k)&&(0,H.WithinEpsilon)(this._w,s._w,k)}isApprox(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return s&&((0,H.WithinEpsilon)(this._x,s._x,k)&&(0,H.WithinEpsilon)(this._y,s._y,k)&&(0,H.WithinEpsilon)(this._z,s._z,k)&&(0,H.WithinEpsilon)(this._w,s._w,k)||(0,H.WithinEpsilon)(this._x,-s._x,k)&&(0,H.WithinEpsilon)(this._y,-s._y,k)&&(0,H.WithinEpsilon)(this._z,-s._z,k)&&(0,H.WithinEpsilon)(this._w,-s._w,k))}clone(){return new P(this._x,this._y,this._z,this._w)}H(s){return this._x=s._x,this._y=s._y,this._z=s._z,this._w=s._w,this._isDirty=!0,this}cg(s,k,h,A){return this._x=s,this._y=k,this._z=h,this._w=A,this._isDirty=!0,this}set(s,k,h,A){return this.cg(s,k,h,A)}Eg(s){return this.cg(s,s,s,s)}add(s){return new P(this._x+s._x,this._y+s._y,this._z+s._z,this._w+s._w)}addInPlace(s){return this._x+=s._x,this._y+=s._y,this._z+=s._z,this._w+=s._w,this._isDirty=!0,this}addToRef(s,k){return k._x=this._x+s._x,k._y=this._y+s._y,k._z=this._z+s._z,k._w=this._w+s._w,k._isDirty=!0,k}addInPlaceFromFloats(s,k,h,A){return this._x+=s,this._y+=k,this._z+=h,this._w+=A,this._isDirty=!0,this}subtractToRef(s,k){return k._x=this._x-s._x,k._y=this._y-s._y,k._z=this._z-s._z,k._w=this._w-s._w,k._isDirty=!0,k}subtractFromFloats(s,k,h,A){return this.subtractFromFloatsToRef(s,k,h,A,new P)}subtractFromFloatsToRef(s,k,h,A,g){return g._x=this._x-s,g._y=this._y-k,g._z=this._z-h,g._w=this._w-A,g._isDirty=!0,g}Rk(s){return new P(this._x-s._x,this._y-s._y,this._z-s._z,this._w-s._w)}ka(s){return this._x-=s._x,this._y-=s._y,this._z-=s._z,this._w-=s._w,this._isDirty=!0,this}scale(s){return new P(this._x*s,this._y*s,this._z*s,this._w*s)}scaleToRef(s,k){return k._x=this._x*s,k._y=this._y*s,k._z=this._z*s,k._w=this._w*s,k._isDirty=!0,k}scaleInPlace(s){return this._x*=s,this._y*=s,this._z*=s,this._w*=s,this._isDirty=!0,this}scaleAndAddToRef(s,k){return k._x+=this._x*s,k._y+=this._y*s,k._z+=this._z*s,k._w+=this._w*s,k._isDirty=!0,k}multiply(s){const k=new P(0,0,0,1);return this.multiplyToRef(s,k),k}multiplyToRef(s,k){const h=this._x*s._w+this._y*s._z-this._z*s._y+this._w*s._x,A=-this._x*s._z+this._y*s._w+this._z*s._x+this._w*s._y,g=this._x*s._y-this._y*s._x+this._z*s._w+this._w*s._z,ms=-this._x*s._x-this._y*s._y-this._z*s._z+this._w*s._w;return k.cg(h,A,g,ms),k}multiplyInPlace(s){return this.multiplyToRef(s,this)}multiplyByFloats(s,k,h,A){return this._x*=s,this._y*=k,this._z*=h,this._w*=A,this._isDirty=!0,this}divide(s){throw new ReferenceError("Can not divide a quaternion")}divideToRef(s,k){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(s){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new P)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(s){return s._x=-this._x,s._y=-this._y,s._z=-this._z,s._w=-this._w,s._isDirty=!0,s}equalsToFloats(s,k,h,A){return this._x===s&&this._y===k&&this._z===h&&this._w===A}floorToRef(s){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(s){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(s){return s.cg(-this._x,-this._y,-this._z,this._w),s}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new P(-this._x,-this._y,-this._z,this._w)}invert(){const s=this.conjugate(),k=this.lengthSquared();return 0==k||1==k||s.scaleInPlace(1/k),s}invertInPlace(){this.conjugateInPlace();const s=this.lengthSquared();return 0==s||1==s||this.scaleInPlace(1/s),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(s){return 0===s||1===s?this:this.scaleInPlace(1/s)}normalizeToNew(){const s=new P(0,0,0,1);return this.normalizeToRef(s),s}normalizeToRef(s){const k=this.length();return 0===k||1===k?s.cg(this._x,this._y,this._z,this._w):this.scaleToRef(1/k,s)}toEulerAngles(){const s=E.Zero();return this.toEulerAnglesToRef(s),s}toEulerAnglesToRef(s){const k=this._z,h=this._x,A=this._y,g=this._w,ms=A*k-h*g,i=.4999999;if(ms<-i)s._y=2*Math.atan2(A,g),s._x=Math.PI/2,s._z=0,s._isDirty=!0;else if(ms>i)s._y=2*Math.atan2(A,g),s._x=-Math.PI/2,s._z=0,s._isDirty=!0;else{const i=g*g,K=k*k,H=h*h,O=A*A;s._z=Math.atan2(2*(h*A+k*g),-K-H+O+i),s._x=Math.asin(-2*ms),s._y=Math.atan2(2*(k*h+A*g),K-H-O+i),s._isDirty=!0}return s}toAlphaBetaGammaToRef(s){const k=this._z,h=this._x,A=this._y,g=this._w,ms=Math.sqrt(h*h+A*A),i=Math.sqrt(k*k+g*g),K=2*Math.atan2(ms,i),H=2*Math.atan2(k,g),O=2*Math.atan2(A,h),c=(H+O)/2,S=(H-O)/2;return s.set(S,K,c),s}toRotationMatrix(s){return R.FromQuaternionToRef(this,s),s}fromRotationMatrix(s){return P.FromRotationMatrixToRef(s,this),this}dot(s){return this._x*s._x+this._y*s._y+this._z*s._z+this._w*s._w}toAxisAngle(){const s=E.Zero();return{axis:s,angle:this.toAxisAngleToRef(s)}}toAxisAngleToRef(s){let k=0;const h=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),A=this._w;return h>0?(k=2*Math.atan2(h,A),s.set(this._x/h,this._y/h,this._z/h)):(k=0,s.set(1,0,0)),k}static FromRotationMatrix(s){const k=new P;return P.FromRotationMatrixToRef(s,k),k}static FromRotationMatrixToRef(s,k){const h=s.m,A=h[0],g=h[4],ms=h[8],i=h[1],K=h[5],H=h[9],O=h[2],c=h[6],S=h[10],a=A+K+S;let r;return a>0?(r=.5/Math.sqrt(a+1),k._w=.25/r,k._x=(c-H)*r,k._y=(ms-O)*r,k._z=(i-g)*r,k._isDirty=!0):A>K&&A>S?(r=2*Math.sqrt(1+A-K-S),k._w=(c-H)/r,k._x=.25*r,k._y=(g+i)/r,k._z=(ms+O)/r,k._isDirty=!0):K>S?(r=2*Math.sqrt(1+K-A-S),k._w=(ms-O)/r,k._x=(g+i)/r,k._y=.25*r,k._z=(H+c)/r,k._isDirty=!0):(r=2*Math.sqrt(1+S-A-K),k._w=(i-g)/r,k._x=(ms+O)/r,k._y=(H+c)/r,k._z=.25*r,k._isDirty=!0),k}static Dot(s,k){return s._x*k._x+s._y*k._y+s._z*k._z+s._w*k._w}static AreClose(s,k){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const A=P.Dot(s,k);return 1-A*A<=h}static SmoothToRef(s,k,h,A,g){let ms=0===A?1:h/A;return ms=(0,H.Clamp)(ms,0,1),P.SlerpToRef(s,k,ms,g),g}static Zero(){return new P(0,0,0,0)}static Inverse(s){return new P(-s._x,-s._y,-s._z,s._w)}static InverseToRef(s,k){return k.set(-s._x,-s._y,-s._z,s._w),k}static Identity(){return new P(0,0,0,1)}static IsIdentity(s){return s&&0===s._x&&0===s._y&&0===s._z&&1===s._w}static RotationAxis(s,k){return P.RotationAxisToRef(s,k,new P)}static RotationAxisToRef(s,k,h){h._w=Math.cos(k/2);const A=Math.sin(k/2)/s.length();return h._x=s._x*A,h._y=s._y*A,h._z=s._z*A,h._isDirty=!0,h}static uk(s,k){return k||(k=0),new P(s[k],s[k+1],s[k+2],s[k+3])}static FromArrayToRef(s,k,h){return h._x=s[k],h._y=s[k+1],h._z=s[k+2],h._w=s[k+3],h._isDirty=!0,h}static FromFloatsToRef(s,k,h,A,g){return g.cg(s,k,h,A),g}static FromEulerAngles(s,k,h){const A=new P;return P.RotationYawPitchRollToRef(k,s,h,A),A}static FromEulerAnglesToRef(s,k,h,A){return P.RotationYawPitchRollToRef(k,s,h,A),A}static FromEulerVector(s){const k=new P;return P.RotationYawPitchRollToRef(s._y,s._x,s._z,k),k}static FromEulerVectorToRef(s,k){return P.RotationYawPitchRollToRef(s._y,s._x,s._z,k),k}static FromUnitVectorsToRef(s,k,h){let g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:A.c;const ms=E.Dot(s,k)+1;return ms<g?Math.abs(s.x)>Math.abs(s.z)?h.set(-s.y,s.x,0,0):h.set(0,-s.z,s.y,0):(E.CrossToRef(s,k,w.Pk[0]),h.set(w.Pk[0].x,w.Pk[0].y,w.Pk[0].z,ms)),h.normalize()}static RotationYawPitchRoll(s,k,h){const A=new P;return P.RotationYawPitchRollToRef(s,k,h,A),A}static RotationYawPitchRollToRef(s,k,h,A){const g=.5*h,ms=.5*k,i=.5*s,K=Math.sin(g),H=Math.cos(g),O=Math.sin(ms),c=Math.cos(ms),S=Math.sin(i),a=Math.cos(i);return A._x=a*O*H+S*c*K,A._y=S*c*H-a*O*K,A._z=a*c*K-S*O*H,A._w=a*c*H+S*O*K,A._isDirty=!0,A}static RotationAlphaBetaGamma(s,k,h){const A=new P;return P.RotationAlphaBetaGammaToRef(s,k,h,A),A}static RotationAlphaBetaGammaToRef(s,k,h,A){const g=.5*(h+s),ms=.5*(h-s),i=.5*k;return A._x=Math.cos(ms)*Math.sin(i),A._y=Math.sin(ms)*Math.sin(i),A._z=Math.sin(g)*Math.cos(i),A._w=Math.cos(g)*Math.cos(i),A._isDirty=!0,A}static RotationQuaternionFromAxis(s,k,h){const A=new P(0,0,0,0);return P.RotationQuaternionFromAxisToRef(s,k,h,A),A}static RotationQuaternionFromAxisToRef(s,k,h,A){const g=D.Matrix[0];return s=s.normalizeToRef(D.Pk[0]),k=k.normalizeToRef(D.Pk[1]),h=h.normalizeToRef(D.Pk[2]),R.FromXYZAxesToRef(s,k,h,g),P.FromRotationMatrixToRef(g,A),A}static FromLookDirectionLH(s,k){const h=new P;return P.FromLookDirectionLHToRef(s,k,h),h}static FromLookDirectionLHToRef(s,k,h){const A=D.Matrix[0];return R.LookDirectionLHToRef(s,k,A),P.FromRotationMatrixToRef(A,h),h}static FromLookDirectionRH(s,k){const h=new P;return P.FromLookDirectionRHToRef(s,k,h),h}static FromLookDirectionRHToRef(s,k,h){const A=D.Matrix[0];return R.LookDirectionRHToRef(s,k,A),P.FromRotationMatrixToRef(A,h)}static Slerp(s,k,h){const A=P.Identity();return P.SlerpToRef(s,k,h,A),A}static SlerpToRef(s,k,h,A){let g,ms,i=s._x*k._x+s._y*k._y+s._z*k._z+s._w*k._w,K=!1;if(i<0&&(K=!0,i=-i),i>.999999)ms=1-h,g=K?-h:h;else{const s=Math.acos(i),k=1/Math.sin(s);ms=Math.sin((1-h)*s)*k,g=K?-Math.sin(h*s)*k:Math.sin(h*s)*k}return A._x=ms*s._x+g*k._x,A._y=ms*s._y+g*k._y,A._z=ms*s._z+g*k._z,A._w=ms*s._w+g*k._w,A._isDirty=!0,A}static Hermite(s,k,h,A,g){const ms=g*g,i=g*ms,K=2*i-3*ms+1,H=-2*i+3*ms,O=i-2*ms+g,c=i-ms,S=s._x*K+h._x*H+k._x*O+A._x*c,a=s._y*K+h._y*H+k._y*O+A._y*c,r=s._z*K+h._z*H+k._z*O+A._z*c,d=s._w*K+h._w*H+k._w*O+A._w*c;return new P(S,a,r,d)}static Hermite1stDerivative(s,k,h,A,g){const ms=new P;return this.Hermite1stDerivativeToRef(s,k,h,A,g,ms),ms}static Hermite1stDerivativeToRef(s,k,h,A,g,ms){const i=g*g;return ms._x=6*(i-g)*s._x+(3*i-4*g+1)*k._x+6*(-i+g)*h._x+(3*i-2*g)*A._x,ms._y=6*(i-g)*s._y+(3*i-4*g+1)*k._y+6*(-i+g)*h._y+(3*i-2*g)*A._y,ms._z=6*(i-g)*s._z+(3*i-4*g+1)*k._z+6*(-i+g)*h._z+(3*i-2*g)*A._z,ms._w=6*(i-g)*s._w+(3*i-4*g+1)*k._w+6*(-i+g)*h._w+(3*i-2*g)*A._w,ms._isDirty=!0,ms}static Normalize(s){const k=P.Zero();return P.NormalizeToRef(s,k),k}static NormalizeToRef(s,k){return s.normalizeToRef(k),k}static Clamp(s,k,h){const A=new P;return P.ClampToRef(s,k,h,A),A}static ClampToRef(s,k,h,A){return A.cg((0,H.Clamp)(s.x,k.x,h.x),(0,H.Clamp)(s.y,k.y,h.y),(0,H.Clamp)(s.z,k.z,h.z),(0,H.Clamp)(s.w,k.w,h.w))}static Random(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new P((0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k))}static RandomToRef(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).cg((0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k),(0,H.RandomRange)(s,k))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(s,k){return Math.sqrt(P.DistanceSquared(s,k))}static DistanceSquared(s,k){const h=s.x-k.x,A=s.y-k.y,g=s.z-k.z,ms=s.w-k.w;return h*h+A*A+g*g+ms*ms}static Center(s,k){return P.CenterToRef(s,k,P.Zero())}static CenterToRef(s,k,h){return h.cg((s.x+k.x)/2,(s.y+k.y)/2,(s.z+k.z)/2,(s.w+k.w)/2)}}P._V8PerformanceHack=new P(.5,.5,.5,.5),Object.defineProperties(P.prototype,{dimension:{value:[4]},rank:{value:1}});class R{static get Use64Bits(){return i.c.MatrixUse64Bits}get m(){return this.Gh}markAsUpdated(){this.updateFlag=O._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(s){let k=arguments.length>1&&void 0!==arguments[1]&&arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],A=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=s,this._isIdentity3x2=s||h,this._isIdentityDirty=!this._isIdentity&&k,this._isIdentity3x2Dirty=!this._isIdentity3x2&&A}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,i.c.MatrixTrackPrecisionChange&&i.c.MatrixTrackedMatrices.push(this),this.Gh=new i.c.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const s=this.Gh;this._isIdentity=1===s[0]&&0===s[1]&&0===s[2]&&0===s[3]&&0===s[4]&&1===s[5]&&0===s[6]&&0===s[7]&&0===s[8]&&0===s[9]&&1===s[10]&&0===s[11]&&0===s[12]&&0===s[13]&&0===s[14]&&1===s[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Gh[0]||1!==this.Gh[5]||1!==this.Gh[15]||0!==this.Gh[1]||0!==this.Gh[2]||0!==this.Gh[3]||0!==this.Gh[4]||0!==this.Gh[6]||0!==this.Gh[7]||0!==this.Gh[8]||0!==this.Gh[9]||0!==this.Gh[10]||0!==this.Gh[11]||0!==this.Gh[12]||0!==this.Gh[13]||0!==this.Gh[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const s=this.Gh,k=s[0],h=s[1],A=s[2],g=s[3],ms=s[4],i=s[5],K=s[6],H=s[7],O=s[8],c=s[9],S=s[10],a=s[11],r=s[12],d=s[13],E=s[14],j=s[15],P=S*j-E*a,R=c*j-d*a,D=c*E-d*S,w=O*j-r*a,B=O*E-S*r,u=O*d-r*c;return k*+(i*P-K*R+H*D)+h*-(ms*P-K*w+H*B)+A*+(ms*R-i*w+H*u)+g*-(ms*D-i*B+K*u)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!s)return this.Gh;const h=this.Gh;for(let A=0;A<16;A++)s[k+A]=h[A];return this}yh(){return this.Gh}Nh(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R.FromArrayToRef(s,k,this)}cg(){for(var s=arguments.length,k=new Array(s),h=0;h<s;h++)k[h]=arguments[h];return R.FromArrayToRef(k,0,this)}set(){const s=this.Gh;for(let k=0;k<16;k++)s[k]=k<0||arguments.length<=k?void 0:arguments[k];return this.markAsUpdated(),this}Eg(s){const k=this.Gh;for(let h=0;h<16;h++)k[h]=s;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return R.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(s){const k=new R;return this.addToRef(s,k),k}addToRef(s,k){const h=this.Gh,A=k.Gh,g=s.m;for(let ms=0;ms<16;ms++)A[ms]=h[ms]+g[ms];return k.markAsUpdated(),k}addToSelf(s){const k=this.Gh,h=s.m;return k[0]+=h[0],k[1]+=h[1],k[2]+=h[2],k[3]+=h[3],k[4]+=h[4],k[5]+=h[5],k[6]+=h[6],k[7]+=h[7],k[8]+=h[8],k[9]+=h[9],k[10]+=h[10],k[11]+=h[11],k[12]+=h[12],k[13]+=h[13],k[14]+=h[14],k[15]+=h[15],this.markAsUpdated(),this}addInPlace(s){const k=this.Gh,h=s.m;for(let A=0;A<16;A++)k[A]+=h[A];return this.markAsUpdated(),this}addInPlaceFromFloats(){const s=this.Gh;for(let k=0;k<16;k++)s[k]+=k<0||arguments.length<=k?void 0:arguments[k];return this.markAsUpdated(),this}Rk(s){const k=this.Gh,h=s.m;for(let A=0;A<16;A++)k[A]-=h[A];return this.markAsUpdated(),this}subtractToRef(s,k){const h=this.Gh,A=s.m,g=k.Gh;for(let ms=0;ms<16;ms++)g[ms]=h[ms]-A[ms];return k.markAsUpdated(),k}ka(s){const k=this.Gh,h=s.m;for(let A=0;A<16;A++)k[A]-=h[A];return this.markAsUpdated(),this}subtractFromFloats(){for(var s=arguments.length,k=new Array(s),h=0;h<s;h++)k[h]=arguments[h];return this.subtractFromFloatsToRef(...k,new R)}subtractFromFloatsToRef(){for(var s=arguments.length,k=new Array(s),h=0;h<s;h++)k[h]=arguments[h];const A=k.pop(),g=this.Gh,ms=A.Gh,i=k;for(let K=0;K<16;K++)ms[K]=g[K]-i[K];return A.markAsUpdated(),A}invertToRef(s){return!0===this._isIdentity?(R.IdentityToRef(s),s):(a(this,s.yh())?s.markAsUpdated():s.H(this),s)}addAtIndex(s,k){return this.Gh[s]+=k,this.markAsUpdated(),this}multiplyAtIndex(s,k){return this.Gh[s]*=k,this.markAsUpdated(),this}setTranslationFromFloats(s,k,h){return this.Gh[12]=s,this.Gh[13]=k,this.Gh[14]=h,this.markAsUpdated(),this}addTranslationFromFloats(s,k,h){return this.Gh[12]+=s,this.Gh[13]+=k,this.Gh[14]+=h,this.markAsUpdated(),this}setTranslation(s){return this.setTranslationFromFloats(s._x,s._y,s._z)}getTranslation(){return new E(this.Gh[12],this.Gh[13],this.Gh[14])}getTranslationToRef(s){return s.x=this.Gh[12],s.y=this.Gh[13],s.z=this.Gh[14],s}removeRotationAndScaling(){const s=this.m;return R.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,s[12],s[13],s[14],s[15],this),this._updateIdentityStatus(0===s[12]&&0===s[13]&&0===s[14]&&1===s[15]),this}H(s){s.copyToArray(this.Gh);const k=s;return this.updateFlag=k.updateFlag,this._updateIdentityStatus(k._isIdentity,k._isIdentityDirty,k._isIdentity3x2,k._isIdentity3x2Dirty),this}copyToArray(s){return S(this,s,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(s){const k=new R;return this.multiplyToRef(s,k),k}multiplyInPlace(s){const k=this.Gh,h=s.m;for(let A=0;A<16;A++)k[A]*=h[A];return this.markAsUpdated(),this}multiplyByFloats(){const s=this.Gh;for(let k=0;k<16;k++)s[k]*=k<0||arguments.length<=k?void 0:arguments[k];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var s=arguments.length,k=new Array(s),h=0;h<s;h++)k[h]=arguments[h];const A=k.pop(),g=this.Gh,ms=A.Gh,i=k;for(let K=0;K<16;K++)ms[K]=g[K]*i[K];return A.markAsUpdated(),A}multiplyToRef(s,k){return this._isIdentity?(k.H(s),k):s._isIdentity?(k.H(this),k):(this.multiplyToArray(s,k.Gh,0),k.markAsUpdated(),k)}multiplyToArray(s,k,h){return c(this,s,k,h),this}divide(s){return this.divideToRef(s,new R)}divideToRef(s,k){const h=this.Gh,A=s.m,g=k.Gh;for(let ms=0;ms<16;ms++)g[ms]=h[ms]/A[ms];return k.markAsUpdated(),k}divideInPlace(s){const k=this.Gh,h=s.m;for(let A=0;A<16;A++)k[A]/=h[A];return this.markAsUpdated(),this}minimizeInPlace(s){const k=this.Gh,h=s.m;for(let A=0;A<16;A++)k[A]=Math.min(k[A],h[A]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const s=this.Gh;for(let k=0;k<16;k++)s[k]=Math.min(s[k],k<0||arguments.length<=k?void 0:arguments[k]);return this.markAsUpdated(),this}maximizeInPlace(s){const k=this.Gh,h=s.m;for(let A=0;A<16;A++)k[A]=Math.min(k[A],h[A]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const s=this.Gh;for(let k=0;k<16;k++)s[k]=Math.min(s[k],k<0||arguments.length<=k?void 0:arguments[k]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new R)}negateInPlace(){const s=this.Gh;for(let k=0;k<16;k++)s[k]=-s[k];return this.markAsUpdated(),this}negateToRef(s){const k=this.Gh,h=s.Gh;for(let A=0;A<16;A++)h[A]=-k[A];return s.markAsUpdated(),s}equals(s){const k=s;if(!k)return!1;if((this._isIdentity||k._isIdentity)&&!this._isIdentityDirty&&!k._isIdentityDirty)return this._isIdentity&&k._isIdentity;const h=this.m,A=k.m;return h[0]===A[0]&&h[1]===A[1]&&h[2]===A[2]&&h[3]===A[3]&&h[4]===A[4]&&h[5]===A[5]&&h[6]===A[6]&&h[7]===A[7]&&h[8]===A[8]&&h[9]===A[9]&&h[10]===A[10]&&h[11]===A[11]&&h[12]===A[12]&&h[13]===A[13]&&h[14]===A[14]&&h[15]===A[15]}equalsWithEpsilon(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const h=this.Gh,A=s.m;for(let g=0;g<16;g++)if(!(0,H.WithinEpsilon)(h[g],A[g],k))return!1;return!0}equalsToFloats(){const s=this.Gh;for(let k=0;k<16;k++)if(s[k]!=(k<0||arguments.length<=k?void 0:arguments[k]))return!1;return!0}floor(){return this.floorToRef(new R)}floorToRef(s){const k=this.Gh,h=s.Gh;for(let A=0;A<16;A++)h[A]=Math.floor(k[A]);return s.markAsUpdated(),s}fract(){return this.fractToRef(new R)}fractToRef(s){const k=this.Gh,h=s.Gh;for(let A=0;A<16;A++)h[A]=k[A]-Math.floor(k[A]);return s.markAsUpdated(),s}clone(){const s=new R;return s.H(this),s}getClassName(){return"Matrix"}getHashCode(){let s=r(this.Gh[0]);for(let k=1;k<16;k++)s=397*s^r(this.Gh[k]);return s}decomposeToTransformNode(s){return s.rotationQuaternion=s.rotationQuaternion||new P,this.decompose(s.Sg,s.rotationQuaternion,s.position)}decompose(s,k,h,A){let g=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return h&&h.Eg(0),s&&s.Eg(1),k&&k.cg(0,0,0,1),!0;const ms=this.Gh;if(h&&h.cg(ms[12],ms[13],ms[14]),(s=s||D.Pk[0]).x=Math.sqrt(ms[0]*ms[0]+ms[1]*ms[1]+ms[2]*ms[2]),s.y=Math.sqrt(ms[4]*ms[4]+ms[5]*ms[5]+ms[6]*ms[6]),s.z=Math.sqrt(ms[8]*ms[8]+ms[9]*ms[9]+ms[10]*ms[10]),A){const k=(g?A.absoluteScaling.x:A.Sg.x)<0?-1:1,h=(g?A.absoluteScaling.y:A.Sg.y)<0?-1:1,ms=(g?A.absoluteScaling.z:A.Sg.z)<0?-1:1;s.x*=k,s.y*=h,s.z*=ms}else this.determinant()<=0&&(s.y*=-1);if(0===s._x||0===s._y||0===s._z)return k&&k.cg(0,0,0,1),!1;if(k){const h=1/s._x,A=1/s._y,g=1/s._z;R.FromValuesToRef(ms[0]*h,ms[1]*h,ms[2]*h,0,ms[4]*A,ms[5]*A,ms[6]*A,0,ms[8]*g,ms[9]*g,ms[10]*g,0,0,0,0,1,D.Matrix[0]),P.FromRotationMatrixToRef(D.Matrix[0],k)}return!0}getRow(s){if(s<0||s>3)return null;const k=4*s;return new j(this.Gh[k+0],this.Gh[k+1],this.Gh[k+2],this.Gh[k+3])}getRowToRef(s,k){if(s>=0&&s<=3){const h=4*s;k.x=this.Gh[h+0],k.y=this.Gh[h+1],k.z=this.Gh[h+2],k.w=this.Gh[h+3]}return k}setRow(s,k){return this.setRowFromFloats(s,k.x,k.y,k.z,k.w)}transpose(){const s=new R;return R.TransposeToRef(this,s),s}transposeToRef(s){return R.TransposeToRef(this,s),s}setRowFromFloats(s,k,h,A,g){if(s<0||s>3)return this;const ms=4*s;return this.Gh[ms+0]=k,this.Gh[ms+1]=h,this.Gh[ms+2]=A,this.Gh[ms+3]=g,this.markAsUpdated(),this}scale(s){const k=new R;return this.scaleToRef(s,k),k}scaleToRef(s,k){for(let h=0;h<16;h++)k.Gh[h]=this.Gh[h]*s;return k.markAsUpdated(),k}scaleAndAddToRef(s,k){for(let h=0;h<16;h++)k.Gh[h]+=this.Gh[h]*s;return k.markAsUpdated(),k}scaleInPlace(s){const k=this.Gh;for(let h=0;h<16;h++)k[h]*=s;return this.markAsUpdated(),this}toNormalMatrix(s){const k=D.Matrix[0];this.invertToRef(k),k.transposeToRef(s);const h=s.Gh;return R.FromValuesToRef(h[0],h[1],h[2],0,h[4],h[5],h[6],0,h[8],h[9],h[10],0,0,0,0,1,s),s}getRotationMatrix(){const s=new R;return this.getRotationMatrixToRef(s),s}getRotationMatrixToRef(s){const k=D.Pk[0];if(!this.decompose(k))return R.IdentityToRef(s),s;const h=this.Gh,A=1/k._x,g=1/k._y,ms=1/k._z;return R.FromValuesToRef(h[0]*A,h[1]*A,h[2]*A,0,h[4]*g,h[5]*g,h[6]*g,0,h[8]*ms,h[9]*ms,h[10]*ms,0,0,0,0,1,s),s}toggleModelMatrixHandInPlace(){const s=this.Gh;return s[2]*=-1,s[6]*=-1,s[8]*=-1,s[9]*=-1,s[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const s=this.Gh;return s[8]*=-1,s[9]*=-1,s[10]*=-1,s[11]*=-1,this.markAsUpdated(),this}static uk(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const h=new R;return R.FromArrayToRef(s,k,h),h}static FromArrayToRef(s,k,h){for(let A=0;A<16;A++)h.Gh[A]=s[A+k];return h.markAsUpdated(),h}static FromFloat32ArrayToRefScaled(s,k,h,A){return A.Gh[0]=s[0+k]*h,A.Gh[1]=s[1+k]*h,A.Gh[2]=s[2+k]*h,A.Gh[3]=s[3+k]*h,A.Gh[4]=s[4+k]*h,A.Gh[5]=s[5+k]*h,A.Gh[6]=s[6+k]*h,A.Gh[7]=s[7+k]*h,A.Gh[8]=s[8+k]*h,A.Gh[9]=s[9+k]*h,A.Gh[10]=s[10+k]*h,A.Gh[11]=s[11+k]*h,A.Gh[12]=s[12+k]*h,A.Gh[13]=s[13+k]*h,A.Gh[14]=s[14+k]*h,A.Gh[15]=s[15+k]*h,A.markAsUpdated(),A}static get IdentityReadOnly(){return R._IdentityReadOnly}static FromValuesToRef(s,k,h,A,g,ms,i,K,H,O,c,S,a,r,d,E,j){const P=j.Gh;P[0]=s,P[1]=k,P[2]=h,P[3]=A,P[4]=g,P[5]=ms,P[6]=i,P[7]=K,P[8]=H,P[9]=O,P[10]=c,P[11]=S,P[12]=a,P[13]=r,P[14]=d,P[15]=E,j.markAsUpdated()}static FromValues(s,k,h,A,g,ms,i,K,H,O,c,S,a,r,d,E){const j=new R,P=j.Gh;return P[0]=s,P[1]=k,P[2]=h,P[3]=A,P[4]=g,P[5]=ms,P[6]=i,P[7]=K,P[8]=H,P[9]=O,P[10]=c,P[11]=S,P[12]=a,P[13]=r,P[14]=d,P[15]=E,j.markAsUpdated(),j}static Compose(s,k,h){const A=new R;return R.ComposeToRef(s,k,h,A),A}static ComposeToRef(s,k,h,A){const g=A.Gh,ms=k._x,i=k._y,K=k._z,H=k._w,O=ms+ms,c=i+i,S=K+K,a=ms*O,r=ms*c,d=ms*S,E=i*c,j=i*S,P=K*S,R=H*O,D=H*c,w=H*S,B=s._x,u=s._y,G=s._z;return g[0]=(1-(E+P))*B,g[1]=(r+w)*B,g[2]=(d-D)*B,g[3]=0,g[4]=(r-w)*u,g[5]=(1-(a+P))*u,g[6]=(j+R)*u,g[7]=0,g[8]=(d+D)*G,g[9]=(j-R)*G,g[10]=(1-(a+E))*G,g[11]=0,g[12]=h._x,g[13]=h._y,g[14]=h._z,g[15]=1,A.markAsUpdated(),A}static Identity(){const s=R.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return s._updateIdentityStatus(!0),s}static IdentityToRef(s){return R.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,s),s._updateIdentityStatus(!0),s}static Zero(){const s=R.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return s._updateIdentityStatus(!1),s}static RotationX(s){const k=new R;return R.RotationXToRef(s,k),k}static Invert(s){const k=new R;return s.invertToRef(k),k}static RotationXToRef(s,k){const h=Math.sin(s),A=Math.cos(s);return R.FromValuesToRef(1,0,0,0,0,A,h,0,0,-h,A,0,0,0,0,1,k),k._updateIdentityStatus(1===A&&0===h),k}static RotationY(s){const k=new R;return R.RotationYToRef(s,k),k}static RotationYToRef(s,k){const h=Math.sin(s),A=Math.cos(s);return R.FromValuesToRef(A,0,-h,0,0,1,0,0,h,0,A,0,0,0,0,1,k),k._updateIdentityStatus(1===A&&0===h),k}static RotationZ(s){const k=new R;return R.RotationZToRef(s,k),k}static RotationZToRef(s,k){const h=Math.sin(s),A=Math.cos(s);return R.FromValuesToRef(A,h,0,0,-h,A,0,0,0,0,1,0,0,0,0,1,k),k._updateIdentityStatus(1===A&&0===h),k}static RotationAxis(s,k){const h=new R;return R.RotationAxisToRef(s,k,h),h}static RotationAxisToRef(s,k,h){const A=Math.sin(-k),g=Math.cos(-k),ms=1-g;s=s.normalizeToRef(D.Pk[0]);const i=h.Gh;return i[0]=s._x*s._x*ms+g,i[1]=s._x*s._y*ms-s._z*A,i[2]=s._x*s._z*ms+s._y*A,i[3]=0,i[4]=s._y*s._x*ms+s._z*A,i[5]=s._y*s._y*ms+g,i[6]=s._y*s._z*ms-s._x*A,i[7]=0,i[8]=s._z*s._x*ms-s._y*A,i[9]=s._z*s._y*ms+s._x*A,i[10]=s._z*s._z*ms+g,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,h.markAsUpdated(),h}static RotationAlignToRef(s,k,h){let g=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const ms=E.Dot(k,s),i=h.Gh;if(ms<-1+A.c)i[0]=-1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=g?1:-1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=g?-1:1,i[11]=0;else{const h=E.Cross(k,s),A=1/(1+ms);i[0]=h._x*h._x*A+ms,i[1]=h._y*h._x*A-h._z,i[2]=h._z*h._x*A+h._y,i[3]=0,i[4]=h._x*h._y*A+h._z,i[5]=h._y*h._y*A+ms,i[6]=h._z*h._y*A-h._x,i[7]=0,i[8]=h._x*h._z*A-h._y,i[9]=h._y*h._z*A+h._x,i[10]=h._z*h._z*A+ms,i[11]=0}return i[12]=0,i[13]=0,i[14]=0,i[15]=1,h.markAsUpdated(),h}static RotationYawPitchRoll(s,k,h){const A=new R;return R.RotationYawPitchRollToRef(s,k,h,A),A}static RotationYawPitchRollToRef(s,k,h,A){return P.RotationYawPitchRollToRef(s,k,h,D.Quaternion[0]),D.Quaternion[0].toRotationMatrix(A),A}static Scaling(s,k,h){const A=new R;return R.ScalingToRef(s,k,h,A),A}static ScalingToRef(s,k,h,A){return R.FromValuesToRef(s,0,0,0,0,k,0,0,0,0,h,0,0,0,0,1,A),A._updateIdentityStatus(1===s&&1===k&&1===h),A}static Translation(s,k,h){const A=new R;return R.TranslationToRef(s,k,h,A),A}static TranslationToRef(s,k,h,A){return R.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,s,k,h,1,A),A._updateIdentityStatus(0===s&&0===k&&0===h),A}static Lerp(s,k,h){const A=new R;return R.LerpToRef(s,k,h,A),A}static LerpToRef(s,k,h,A){const g=A.Gh,ms=s.m,i=k.m;for(let K=0;K<16;K++)g[K]=ms[K]*(1-h)+i[K]*h;return A.markAsUpdated(),A}static DecomposeLerp(s,k,h){const A=new R;return R.DecomposeLerpToRef(s,k,h,A),A}static DecomposeLerpToRef(s,k,h,A){const g=D.Pk[0],ms=D.Quaternion[0],i=D.Pk[1];s.decompose(g,ms,i);const K=D.Pk[2],H=D.Quaternion[1],O=D.Pk[3];k.decompose(K,H,O);const c=D.Pk[4];E.LerpToRef(g,K,h,c);const S=D.Quaternion[2];P.SlerpToRef(ms,H,h,S);const a=D.Pk[5];return E.LerpToRef(i,O,h,a),R.ComposeToRef(c,S,a,A),A}static LookAtLH(s,k,h){const A=new R;return R.LookAtLHToRef(s,k,h,A),A}static LookAtLHToRef(s,k,h,A){const g=D.Pk[0],ms=D.Pk[1],i=D.Pk[2];k.subtractToRef(s,i),i.normalize(),E.CrossToRef(h,i,g);const K=g.lengthSquared();0===K?g.x=1:g.normalizeFromLength(Math.sqrt(K)),E.CrossToRef(i,g,ms),ms.normalize();const H=-E.Dot(g,s),O=-E.Dot(ms,s),c=-E.Dot(i,s);return R.FromValuesToRef(g._x,ms._x,i._x,0,g._y,ms._y,i._y,0,g._z,ms._z,i._z,0,H,O,c,1,A),A}static LookAtRH(s,k,h){const A=new R;return R.LookAtRHToRef(s,k,h,A),A}static LookAtRHToRef(s,k,h,A){const g=D.Pk[0],ms=D.Pk[1],i=D.Pk[2];s.subtractToRef(k,i),i.normalize(),E.CrossToRef(h,i,g);const K=g.lengthSquared();0===K?g.x=1:g.normalizeFromLength(Math.sqrt(K)),E.CrossToRef(i,g,ms),ms.normalize();const H=-E.Dot(g,s),O=-E.Dot(ms,s),c=-E.Dot(i,s);return R.FromValuesToRef(g._x,ms._x,i._x,0,g._y,ms._y,i._y,0,g._z,ms._z,i._z,0,H,O,c,1,A),A}static LookDirectionLH(s,k){const h=new R;return R.LookDirectionLHToRef(s,k,h),h}static LookDirectionLHToRef(s,k,h){const A=D.Pk[0];A.H(s),A.scaleInPlace(-1);const g=D.Pk[1];return E.CrossToRef(k,A,g),R.FromValuesToRef(g._x,g._y,g._z,0,k._x,k._y,k._z,0,A._x,A._y,A._z,0,0,0,0,1,h),h}static LookDirectionRH(s,k){const h=new R;return R.LookDirectionRHToRef(s,k,h),h}static LookDirectionRHToRef(s,k,h){const A=D.Pk[2];return E.CrossToRef(k,s,A),R.FromValuesToRef(A._x,A._y,A._z,0,k._x,k._y,k._z,0,s._x,s._y,s._z,0,0,0,0,1,h),h}static OrthoLH(s,k,h,A,g){const ms=new R;return R.OrthoLHToRef(s,k,h,A,ms,g),ms}static OrthoLHToRef(s,k,h,A,g,ms){const i=2/s,K=2/k,H=2/(A-h),O=-(A+h)/(A-h);return R.FromValuesToRef(i,0,0,0,0,K,0,0,0,0,H,0,0,0,O,1,g),ms&&g.multiplyToRef(B,g),g._updateIdentityStatus(1===i&&1===K&&1===H&&0===O),g}static OrthoOffCenterLH(s,k,h,A,g,ms,i){const K=new R;return R.OrthoOffCenterLHToRef(s,k,h,A,g,ms,K,i),K}static OrthoOffCenterLHToRef(s,k,h,A,g,ms,i,K){const H=2/(k-s),O=2/(A-h),c=2/(ms-g),S=-(ms+g)/(ms-g),a=(s+k)/(s-k),r=(A+h)/(h-A);return R.FromValuesToRef(H,0,0,0,0,O,0,0,0,0,c,0,a,r,S,1,i),K&&i.multiplyToRef(B,i),i.markAsUpdated(),i}static ObliqueOffCenterLHToRef(s,k,h,A,g,ms,i,K,H,O,c){const S=-i*Math.cos(K),a=-i*Math.sin(K);return R.TranslationToRef(0,0,-H,D.Matrix[1]),R.FromValuesToRef(1,0,0,0,0,1,0,0,S,a,1,0,0,0,0,1,D.Matrix[0]),D.Matrix[1].multiplyToRef(D.Matrix[0],D.Matrix[0]),R.TranslationToRef(0,0,H,D.Matrix[1]),D.Matrix[0].multiplyToRef(D.Matrix[1],D.Matrix[0]),R.OrthoOffCenterLHToRef(s,k,h,A,g,ms,O,c),D.Matrix[0].multiplyToRef(O,O),O}static OrthoOffCenterRH(s,k,h,A,g,ms,i){const K=new R;return R.OrthoOffCenterRHToRef(s,k,h,A,g,ms,K,i),K}static OrthoOffCenterRHToRef(s,k,h,A,g,ms,i,K){return R.OrthoOffCenterLHToRef(s,k,h,A,g,ms,i,K),i.Gh[10]*=-1,i}static ObliqueOffCenterRHToRef(s,k,h,A,g,ms,i,K,H,O,c){const S=i*Math.cos(K),a=i*Math.sin(K);return R.TranslationToRef(0,0,H,D.Matrix[1]),R.FromValuesToRef(1,0,0,0,0,1,0,0,S,a,1,0,0,0,0,1,D.Matrix[0]),D.Matrix[1].multiplyToRef(D.Matrix[0],D.Matrix[0]),R.TranslationToRef(0,0,-H,D.Matrix[1]),D.Matrix[0].multiplyToRef(D.Matrix[1],D.Matrix[0]),R.OrthoOffCenterRHToRef(s,k,h,A,g,ms,O,c),D.Matrix[0].multiplyToRef(O,O),O}static PerspectiveLH(s,k,h,A,g){let ms=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=new R,K=2*h/s,H=2*h/k,O=(A+h)/(A-h),c=-2*A*h/(A-h),S=Math.tan(ms);return R.FromValuesToRef(K,0,0,0,0,H,0,S,0,0,O,1,0,0,c,0,i),g&&i.multiplyToRef(B,i),i._updateIdentityStatus(!1),i}static PerspectiveFovLH(s,k,h,A,g){let ms=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const K=new R;return R.PerspectiveFovLHToRef(s,k,h,A,K,!0,g,ms,i),K}static PerspectiveFovLHToRef(s,k,h,A,g){let ms=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],i=arguments.length>6?arguments[6]:void 0,K=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,H=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const O=h,c=A,S=1/Math.tan(.5*s),a=ms?S/k:S,r=ms?S:S*k,d=H&&0===O?-1:0!==c?(c+O)/(c-O):1,E=H&&0===O?2*c:0!==c?-2*c*O/(c-O):-2*O,j=Math.tan(K);return R.FromValuesToRef(a,0,0,0,0,r,0,j,0,0,d,1,0,0,E,0,g),i&&g.multiplyToRef(B,g),g._updateIdentityStatus(!1),g}static PerspectiveFovReverseLHToRef(s,k,h,A,g){let ms=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],i=arguments.length>6?arguments[6]:void 0,K=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const H=1/Math.tan(.5*s),O=ms?H/k:H,c=ms?H:H*k,S=Math.tan(K);return R.FromValuesToRef(O,0,0,0,0,c,0,S,0,0,-h,1,0,0,1,0,g),i&&g.multiplyToRef(B,g),g._updateIdentityStatus(!1),g}static PerspectiveFovRH(s,k,h,A,g){let ms=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const K=new R;return R.PerspectiveFovRHToRef(s,k,h,A,K,!0,g,ms,i),K}static PerspectiveFovRHToRef(s,k,h,A,g){let ms=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],i=arguments.length>6?arguments[6]:void 0,K=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,H=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const O=h,c=A,S=1/Math.tan(.5*s),a=ms?S/k:S,r=ms?S:S*k,d=H&&0===O?1:0!==c?-(c+O)/(c-O):-1,E=H&&0===O?2*c:0!==c?-2*c*O/(c-O):-2*O,j=Math.tan(K);return R.FromValuesToRef(a,0,0,0,0,r,0,j,0,0,d,-1,0,0,E,0,g),i&&g.multiplyToRef(B,g),g._updateIdentityStatus(!1),g}static PerspectiveFovReverseRHToRef(s,k,h,A,g){let ms=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],i=arguments.length>6?arguments[6]:void 0,K=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const H=1/Math.tan(.5*s),O=ms?H/k:H,c=ms?H:H*k,S=Math.tan(K);return R.FromValuesToRef(O,0,0,0,0,c,0,S,0,0,-h,-1,0,0,-1,0,g),i&&g.multiplyToRef(B,g),g._updateIdentityStatus(!1),g}static GetFinalMatrix(s,k,h,A,g,ms){const i=s.width,K=s.height,H=s.x,O=s.y,c=R.FromValues(i/2,0,0,0,0,-K/2,0,0,0,0,ms-g,0,H+i/2,K/2+O,g,1),S=new R;return k.multiplyToRef(h,S),S.multiplyToRef(A,S),S.multiplyToRef(c,S)}static GetAsMatrix2x2(s){const k=s.m,h=[k[0],k[1],k[4],k[5]];return i.c.MatrixUse64Bits?h:new Float32Array(h)}static GetAsMatrix3x3(s){const k=s.m,h=[k[0],k[1],k[2],k[4],k[5],k[6],k[8],k[9],k[10]];return i.c.MatrixUse64Bits?h:new Float32Array(h)}static Transpose(s){const k=new R;return R.TransposeToRef(s,k),k}static TransposeToRef(s,k){const h=s.m,A=h[0],g=h[4],ms=h[8],i=h[12],K=h[1],H=h[5],O=h[9],c=h[13],S=h[2],a=h[6],r=h[10],d=h[14],E=h[3],j=h[7],P=h[11],R=h[15],D=k.Gh;return D[0]=A,D[1]=g,D[2]=ms,D[3]=i,D[4]=K,D[5]=H,D[6]=O,D[7]=c,D[8]=S,D[9]=a,D[10]=r,D[11]=d,D[12]=E,D[13]=j,D[14]=P,D[15]=R,k.markAsUpdated(),k._updateIdentityStatus(s._isIdentity,s._isIdentityDirty),k}static Reflection(s){const k=new R;return R.ReflectionToRef(s,k),k}static ReflectionToRef(s,k){s.normalize();const h=s.normal.x,A=s.normal.y,g=s.normal.z,ms=-2*h,i=-2*A,K=-2*g;return R.FromValuesToRef(ms*h+1,i*h,K*h,0,ms*A,i*A+1,K*A,0,ms*g,i*g,K*g+1,0,ms*s.d,i*s.d,K*s.d,1,k),k}static FromXYZAxesToRef(s,k,h,A){return R.FromValuesToRef(s._x,s._y,s._z,0,k._x,k._y,k._z,0,h._x,h._y,h._z,0,0,0,0,1,A),A}static FromQuaternionToRef(s,k){const h=s._x*s._x,A=s._y*s._y,g=s._z*s._z,ms=s._x*s._y,i=s._z*s._w,K=s._z*s._x,H=s._y*s._w,O=s._y*s._z,c=s._x*s._w;return k.Gh[0]=1-2*(A+g),k.Gh[1]=2*(ms+i),k.Gh[2]=2*(K-H),k.Gh[3]=0,k.Gh[4]=2*(ms-i),k.Gh[5]=1-2*(g+h),k.Gh[6]=2*(O+c),k.Gh[7]=0,k.Gh[8]=2*(K+H),k.Gh[9]=2*(O-c),k.Gh[10]=1-2*(A+h),k.Gh[11]=0,k.Gh[12]=0,k.Gh[13]=0,k.Gh[14]=0,k.Gh[15]=1,k.markAsUpdated(),k}}R._IdentityReadOnly=R.Identity(),Object.defineProperties(R.prototype,{dimension:{value:[4,4]},rank:{value:2}});class D{}D.Pk=(0,g.g)(11,E.Zero),D.Matrix=(0,g.g)(2,R.Identity),D.Quaternion=(0,g.g)(3,P.Zero);class w{}w.Vector2=(0,g.g)(3,d.Zero),w.Pk=(0,g.g)(13,E.Zero),w.Vector4=(0,g.g)(3,j.Zero),w.Quaternion=(0,g.g)(3,P.Zero),w.Matrix=(0,g.g)(8,R.Identity),(0,ms.f)("BABYLON.Vector2",d),(0,ms.f)("BABYLON.Vector3",E),(0,ms.f)("BABYLON.Vector4",j),(0,ms.f)("BABYLON.Matrix",R);const B=R.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12603:(s,k,h)=>{function A(s,k){const h=[];for(let A=0;A<s;++A)h.push(k());return h}function g(s,k){return A(s,k)}h.d(k,{e:()=>A,g:()=>g,h:()=>i});const ms=["push","splice","pop","shift","unshift"];function i(s,k){const h=ms.map((h=>function(s,k,h){const A=s[k];if("function"!==typeof A)return null;const g=function(){const A=s.length,ms=g.previous.apply(s,arguments);return h(k,A),ms};return A.next=g,g.previous=A,s[k]=g,()=>{const h=g.previous;if(!h)return;const A=g.next;A?(h.next=A,A.previous=h):(h.next=void 0,s[k]=h),g.next=void 0,g.previous=void 0}}(s,h,k)));return()=>{for(const s of h)null===s||void 0===s||s()}}}}]);