"use strict";(self.nyfa010khv=self.nyfa010khv||[]).push([[14],{12140:(L,r,p)=>{p.d(r,{d:()=>j,e:()=>n,g:()=>J,i:()=>i});const J=1/2.2,i=2.2,n=(1+Math.sqrt(5))/2,j=.001},12154:(L,r,p)=>{function J(L){return parseInt(L.toString().replace(/\W/g,""))}function i(L,r){let p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(L-r)<=p}function n(L,r,p){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return L<r-J||L>p+J}function j(L,r){return L===r?L:Math.random()*(r-L)+L}function z(L,r,p){return L+(r-L)*p}function G(L,r,p){let J=c(r-L,360);return J>180&&(J-=360),L+J*x(p)}function C(L,r,p){let J=0;return J=L!=r?x((p-L)/(r-L)):0,J}function t(L,r,p,J,i){const n=i*i,j=i*n;return L*(2*j-3*n+1)+p*(-2*j+3*n)+r*(j-2*n+i)+J*(j-n)}function E(L,r,p,J,i){const n=i*i;return 6*(n-i)*L+(3*n-4*i+1)*r+6*(-n+i)*p+(3*n-2*i)*J}function x(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(p,Math.max(r,L))}function w(L){return L-=2*Math.PI*Math.floor((L+Math.PI)/(2*Math.PI))}function g(L){const r=L.toString(16);return L<=15?("0"+r).toUpperCase():r.toUpperCase()}function b(L){if(Math.log2)return Math.floor(Math.log2(L));if(L<0)return NaN;if(0===L)return-1/0;let r=0;if(L<1){for(;L<1;)r++,L*=2;r=-r}else if(L>1)for(;L>1;)r++,L=Math.floor(L/2);return r}function c(L,r){return L-Math.floor(L/r)*r}function P(L,r,p){return(L-r)/(p-r)}function O(L,r,p){return L*(p-r)+r}function h(L,r){let p=c(r-L,360);return p>180&&(p-=360),p}function U(L,r){const p=c(L,2*r);return r-Math.abs(p-r)}function W(L,r,p){let J=x(p);return J=-2*J*J*J+3*J*J,r*J+L*(1-J)}function B(L,r,p){let J=0;return J=Math.abs(r-L)<=p?r:L+Math.sign(r-L)*p,J}function F(L,r,p){const J=h(L,r);let i=0;return i=-p<J&&J<p?r:B(L,r=L+J,p),i}function Q(L,r,p){return(L-r)/(p-r)}function e(L,r,p){return(p-r)*L+r}function v(L,r){const p=L%r;return 0===p?r:v(r,p)}p.r(r),p.d(r,{Clamp:()=>x,DeltaAngle:()=>h,Denormalize:()=>O,ExtractAsInt:()=>J,Hermite:()=>t,Hermite1stDerivative:()=>E,HighestCommonFactor:()=>v,ILog2:()=>b,InverseLerp:()=>C,Lerp:()=>z,LerpAngle:()=>G,MoveTowards:()=>B,MoveTowardsAngle:()=>F,Normalize:()=>P,NormalizeRadians:()=>w,OutsideRange:()=>n,PercentToRange:()=>e,PingPong:()=>U,RandomRange:()=>j,RangeToPercent:()=>Q,Repeat:()=>c,SmoothStep:()=>W,ToHex:()=>g,WithinEpsilon:()=>i})},12136:(L,r,p)=>{p.r(r),p.d(r,{Matrix:()=>O,Quaternion:()=>P,TmpVectors:()=>U,Vector2:()=>g,cr:()=>b,Vector4:()=>c});var J=p(12140),i=p(12149),n=p(12087),j=p(12055),z=p(12009),G=p(12154);class C{}function t(L,r,p){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const i=L.mz(),n=r.mz(),j=i[0],z=i[1],G=i[2],C=i[3],t=i[4],E=i[5],x=i[6],w=i[7],g=i[8],b=i[9],c=i[10],P=i[11],O=i[12],h=i[13],U=i[14],W=i[15],B=n[0],F=n[1],Q=n[2],e=n[3],v=n[4],y=n[5],A=n[6],u=n[7],a=n[8],q=n[9],Z=n[10],X=n[11],D=n[12],l=n[13],T=n[14],Y=n[15];p[J]=j*B+z*v+G*a+C*D,p[J+1]=j*F+z*y+G*q+C*l,p[J+2]=j*Q+z*A+G*Z+C*T,p[J+3]=j*e+z*u+G*X+C*Y,p[J+4]=t*B+E*v+x*a+w*D,p[J+5]=t*F+E*y+x*q+w*l,p[J+6]=t*Q+E*A+x*Z+w*T,p[J+7]=t*e+E*u+x*X+w*Y,p[J+8]=g*B+b*v+c*a+P*D,p[J+9]=g*F+b*y+c*q+P*l,p[J+10]=g*Q+b*A+c*Z+P*T,p[J+11]=g*e+b*u+c*X+P*Y,p[J+12]=O*B+h*v+U*a+W*D,p[J+13]=O*F+h*y+U*q+W*l,p[J+14]=O*Q+h*A+U*Z+W*T,p[J+15]=O*e+h*u+U*X+W*Y}function E(L,r){let p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const J=L.mz();r[p]=J[0],r[p+1]=J[1],r[p+2]=J[2],r[p+3]=J[3],r[p+4]=J[4],r[p+5]=J[5],r[p+6]=J[6],r[p+7]=J[7],r[p+8]=J[8],r[p+9]=J[9],r[p+10]=J[10],r[p+11]=J[11],r[p+12]=J[12],r[p+13]=J[13],r[p+14]=J[14],r[p+15]=J[15]}function x(L,r){const p=L.mz(),J=p[0],i=p[1],n=p[2],j=p[3],z=p[4],G=p[5],C=p[6],t=p[7],E=p[8],x=p[9],w=p[10],g=p[11],b=p[12],c=p[13],P=p[14],O=p[15],h=w*O-P*g,U=x*O-c*g,W=x*P-c*w,B=E*O-b*g,F=E*P-w*b,Q=E*c-b*x,e=+(G*h-C*U+t*W),v=-(z*h-C*B+t*F),y=+(z*U-G*B+t*Q),A=-(z*W-G*F+C*Q),u=J*e+i*v+n*y+j*A;if(0===u)return!1;const a=1/u,q=C*O-P*t,Z=G*O-c*t,X=G*P-c*C,D=z*O-b*t,l=z*P-b*C,T=z*c-b*G,Y=C*g-w*t,M=G*g-x*t,f=G*w-x*C,d=z*g-E*t,s=z*w-E*C,H=z*x-E*G,o=-(i*h-n*U+j*W),k=+(J*h-n*B+j*F),R=-(J*U-i*B+j*Q),I=+(J*W-i*F+n*Q),N=+(i*q-n*Z+j*X),K=-(J*q-n*D+j*l),mL=+(J*Z-i*D+j*T),V=-(J*X-i*l+n*T),S=-(i*Y-n*M+j*f),LL=+(J*Y-n*d+j*s),rL=-(J*M-i*d+j*H),pL=+(J*f-i*s+n*H);return r[0]=e*a,r[1]=o*a,r[2]=N*a,r[3]=S*a,r[4]=v*a,r[5]=k*a,r[6]=K*a,r[7]=LL*a,r[8]=y*a,r[9]=R*a,r[10]=mL*a,r[11]=rL*a,r[12]=A*a,r[13]=I*a,r[14]=V*a,r[15]=pL*a,!0}C._UpdateFlagSeed=0;const w=L=>parseInt(L.toString().replace(/\W/g,""));class g{constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=L,this.y=r}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let L=w(this.x);return L=397*L^w(this.y),L}toArray(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L[r]=this.x,L[r+1]=this.y,this}hp(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return g.FromArrayToRef(L,r,this),this}mz(){return[this.x,this.y]}G(L){return this.x=L.x,this.y=L.y,this}Uz(L,r){return this.x=L,this.y=r,this}set(L,r){return this.Uz(L,r)}Bz(L){return this.Uz(L,L)}add(L){return new g(this.x+L.x,this.y+L.y)}addToRef(L,r){return r.x=this.x+L.x,r.y=this.y+L.y,r}addInPlace(L){return this.x+=L.x,this.y+=L.y,this}addInPlaceFromFloats(L,r){return this.x+=L,this.y+=r,this}addVector3(L){return new g(this.x+L.x,this.y+L.y)}Pr(L){return new g(this.x-L.x,this.y-L.y)}subtractToRef(L,r){return r.x=this.x-L.x,r.y=this.y-L.y,r}JE(L){return this.x-=L.x,this.y-=L.y,this}multiplyInPlace(L){return this.x*=L.x,this.y*=L.y,this}multiply(L){return new g(this.x*L.x,this.y*L.y)}multiplyToRef(L,r){return r.x=this.x*L.x,r.y=this.y*L.y,r}multiplyByFloats(L,r){return new g(this.x*L,this.y*r)}divide(L){return new g(this.x/L.x,this.y/L.y)}divideToRef(L,r){return r.x=this.x/L.x,r.y=this.y/L.y,r}divideInPlace(L){return this.x=this.x/L.x,this.y=this.y/L.y,this}minimizeInPlace(L){return this.minimizeInPlaceFromFloats(L.x,L.y)}maximizeInPlace(L){return this.maximizeInPlaceFromFloats(L.x,L.y)}minimizeInPlaceFromFloats(L,r){return this.x=Math.min(L,this.x),this.y=Math.min(r,this.y),this}maximizeInPlaceFromFloats(L,r){return this.x=Math.max(L,this.x),this.y=Math.max(r,this.y),this}subtractFromFloats(L,r){return new g(this.x-L,this.y-r)}subtractFromFloatsToRef(L,r,p){return p.x=this.x-L,p.y=this.y-r,p}negate(){return new g(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(L){return L.x=-this.x,L.y=-this.y,L}scaleInPlace(L){return this.x*=L,this.y*=L,this}scale(L){return new g(this.x*L,this.y*L)}scaleToRef(L,r){return r.x=this.x*L,r.y=this.y*L,r}scaleAndAddToRef(L,r){return r.x+=this.x*L,r.y+=this.y*L,r}equals(L){return L&&this.x===L.x&&this.y===L.y}equalsWithEpsilon(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.d;return L&&(0,G.WithinEpsilon)(this.x,L.x,r)&&(0,G.WithinEpsilon)(this.y,L.y,r)}equalsToFloats(L,r){return this.x===L&&this.y===r}floor(){return new g(Math.floor(this.x),Math.floor(this.y))}floorToRef(L){return L.x=Math.floor(this.x),L.y=Math.floor(this.y),L}fract(){return new g(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(L){return L.x=this.x-Math.floor(this.x),L.y=this.y-Math.floor(this.y),L}rotate(L){return this.rotateToRef(L,new g)}rotateToRef(L,r){const p=Math.cos(L),J=Math.sin(L);return r.x=p*this.x-J*this.y,r.y=J*this.x+p*this.y,r}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(L){return 0===L||1===L?this:this.scaleInPlace(1/L)}normalizeToNew(){const L=new g;return this.normalizeToRef(L),L}normalizeToRef(L){const r=this.length();return 0===r&&(L.x=this.x,L.y=this.y),this.scaleToRef(1/r,L)}clone(){return new g(this.x,this.y)}dot(L){return this.x*L.x+this.y*L.y}static Zero(){return new g(0,0)}static One(){return new g(1,1)}static Random(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new g((0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r))}static RandomToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Uz((0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r))}static get ZeroReadOnly(){return g._ZeroReadOnly}static Br(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new g(L[r],L[r+1])}static FromArrayToRef(L,r,p){return p.x=L[r],p.y=L[r+1],p}static FromFloatsToRef(L,r,p){return p.Uz(L,r),p}static CatmullRom(L,r,p,J,i){const n=i*i,j=i*n,z=.5*(2*r.x+(-L.x+p.x)*i+(2*L.x-5*r.x+4*p.x-J.x)*n+(-L.x+3*r.x-3*p.x+J.x)*j),G=.5*(2*r.y+(-L.y+p.y)*i+(2*L.y-5*r.y+4*p.y-J.y)*n+(-L.y+3*r.y-3*p.y+J.y)*j);return new g(z,G)}static ClampToRef(L,r,p,J){return J.x=(0,G.Clamp)(L.x,r.x,p.x),J.y=(0,G.Clamp)(L.y,r.y,p.y),J}static Clamp(L,r,p){const J=(0,G.Clamp)(L.x,r.x,p.x),i=(0,G.Clamp)(L.y,r.y,p.y);return new g(J,i)}static Hermite(L,r,p,J,i){const n=i*i,j=i*n,z=2*j-3*n+1,G=-2*j+3*n,C=j-2*n+i,t=j-n,E=L.x*z+p.x*G+r.x*C+J.x*t,x=L.y*z+p.y*G+r.y*C+J.y*t;return new g(E,x)}static Hermite1stDerivative(L,r,p,J,i){return this.Hermite1stDerivativeToRef(L,r,p,J,i,new g)}static Hermite1stDerivativeToRef(L,r,p,J,i,n){const j=i*i;return n.x=6*(j-i)*L.x+(3*j-4*i+1)*r.x+6*(-j+i)*p.x+(3*j-2*i)*J.x,n.y=6*(j-i)*L.y+(3*j-4*i+1)*r.y+6*(-j+i)*p.y+(3*j-2*i)*J.y,n}static Lerp(L,r,p){return g.LerpToRef(L,r,p,new g)}static LerpToRef(L,r,p,J){return J.x=L.x+(r.x-L.x)*p,J.y=L.y+(r.y-L.y)*p,J}static Dot(L,r){return L.x*r.x+L.y*r.y}static Normalize(L){return g.NormalizeToRef(L,new g)}static NormalizeToRef(L,r){return L.normalizeToRef(r),r}static Minimize(L,r){const p=L.x<r.x?L.x:r.x,J=L.y<r.y?L.y:r.y;return new g(p,J)}static Maximize(L,r){const p=L.x>r.x?L.x:r.x,J=L.y>r.y?L.y:r.y;return new g(p,J)}static Transform(L,r){return g.TransformToRef(L,r,new g)}static TransformToRef(L,r,p){const J=r.m,i=L.x*J[0]+L.y*J[4]+J[12],n=L.x*J[1]+L.y*J[5]+J[13];return p.x=i,p.y=n,p}static PointInTriangle(L,r,p,J){const i=.5*(-p.y*J.x+r.y*(-p.x+J.x)+r.x*(p.y-J.y)+p.x*J.y),n=i<0?-1:1,j=(r.y*J.x-r.x*J.y+(J.y-r.y)*L.x+(r.x-J.x)*L.y)*n,z=(r.x*p.y-r.y*p.x+(r.y-p.y)*L.x+(p.x-r.x)*L.y)*n;return j>0&&z>0&&j+z<2*i*n}static Distance(L,r){return Math.sqrt(g.DistanceSquared(L,r))}static DistanceSquared(L,r){const p=L.x-r.x,J=L.y-r.y;return p*p+J*J}static Center(L,r){return g.CenterToRef(L,r,new g)}static CenterToRef(L,r,p){return p.Uz((L.x+r.x)/2,(L.y+r.y)/2)}static DistanceOfPointFromSegment(L,r,p){const J=g.DistanceSquared(r,p);if(0===J)return g.Distance(L,r);const i=p.Pr(r),n=Math.max(0,Math.min(1,g.Dot(L.Pr(r),i)/J)),j=r.add(i.multiplyByFloats(n,n));return g.Distance(L,j)}}g._V8PerformanceHack=new g(.5,.5),g._ZeroReadOnly=g.Zero(),Object.defineProperties(g.prototype,{dimension:{value:[2]},rank:{value:1}});class b{get x(){return this._x}set x(L){this._x=L,this._isDirty=!0}get y(){return this._y}set y(L){this._y=L,this._isDirty=!0}get z(){return this._z}set z(L){this._z=L,this._isDirty=!0}constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=L,this._y=r,this._z=p}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"cr"}getHashCode(){let L=w(this._x);return L=397*L^w(this._y),L=397*L^w(this._z),L}mz(){return[this._x,this._y,this._z]}toArray(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L[r]=this._x,L[r+1]=this._y,L[r+2]=this._z,this}hp(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b.FromArrayToRef(L,r,this),this}toQuaternion(){return P.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(L){return this._x+=L._x,this._y+=L._y,this._z+=L._z,this._isDirty=!0,this}addInPlaceFromFloats(L,r,p){return this._x+=L,this._y+=r,this._z+=p,this._isDirty=!0,this}add(L){return new b(this._x+L._x,this._y+L._y,this._z+L._z)}addToRef(L,r){return r._x=this._x+L._x,r._y=this._y+L._y,r._z=this._z+L._z,r._isDirty=!0,r}JE(L){return this._x-=L._x,this._y-=L._y,this._z-=L._z,this._isDirty=!0,this}Pr(L){return new b(this._x-L._x,this._y-L._y,this._z-L._z)}subtractToRef(L,r){return this.subtractFromFloatsToRef(L._x,L._y,L._z,r)}subtractFromFloats(L,r,p){return new b(this._x-L,this._y-r,this._z-p)}subtractFromFloatsToRef(L,r,p,J){return J._x=this._x-L,J._y=this._y-r,J._z=this._z-p,J._isDirty=!0,J}negate(){return new b(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(L){return L._x=-1*this._x,L._y=-1*this._y,L._z=-1*this._z,L._isDirty=!0,L}scaleInPlace(L){return this._x*=L,this._y*=L,this._z*=L,this._isDirty=!0,this}scale(L){return new b(this._x*L,this._y*L,this._z*L)}scaleToRef(L,r){return r._x=this._x*L,r._y=this._y*L,r._z=this._z*L,r._isDirty=!0,r}getNormalToRef(L){const r=this.length();let p=Math.acos(this._y/r);const J=Math.atan2(this._z,this._x);p>Math.PI/2?p-=Math.PI/2:p+=Math.PI/2;const i=r*Math.sin(p)*Math.cos(J),n=r*Math.cos(p),j=r*Math.sin(p)*Math.sin(J);return L.set(i,n,j),L}applyRotationQuaternionToRef(L,r){const p=this._x,J=this._y,i=this._z,n=L._x,j=L._y,z=L._z,G=L._w,C=2*(j*i-z*J),t=2*(z*p-n*i),E=2*(n*J-j*p);return r._x=p+G*C+j*E-z*t,r._y=J+G*t+z*C-n*E,r._z=i+G*E+n*t-j*C,r._isDirty=!0,r}applyRotationQuaternionInPlace(L){return this.applyRotationQuaternionToRef(L,this)}applyRotationQuaternion(L){return this.applyRotationQuaternionToRef(L,new b)}scaleAndAddToRef(L,r){return r._x+=this._x*L,r._y+=this._y*L,r._z+=this._z*L,r._isDirty=!0,r}projectOnPlane(L,r){return this.projectOnPlaneToRef(L,r,new b)}projectOnPlaneToRef(L,r,p){const J=L.normal,i=L.d,n=h.cr[0];this.subtractToRef(r,n),n.normalize();const j=b.Dot(n,J);if(Math.abs(j)<1e-10)p.Bz(1/0);else{const L=-(b.Dot(r,J)+i)/j,z=n.scaleInPlace(L);r.addToRef(z,p)}return p}equals(L){return L&&this._x===L._x&&this._y===L._y&&this._z===L._z}equalsWithEpsilon(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.d;return L&&(0,G.WithinEpsilon)(this._x,L._x,r)&&(0,G.WithinEpsilon)(this._y,L._y,r)&&(0,G.WithinEpsilon)(this._z,L._z,r)}equalsToFloats(L,r,p){return this._x===L&&this._y===r&&this._z===p}multiplyInPlace(L){return this._x*=L._x,this._y*=L._y,this._z*=L._z,this._isDirty=!0,this}multiply(L){return this.multiplyByFloats(L._x,L._y,L._z)}multiplyToRef(L,r){return r._x=this._x*L._x,r._y=this._y*L._y,r._z=this._z*L._z,r._isDirty=!0,r}multiplyByFloats(L,r,p){return new b(this._x*L,this._y*r,this._z*p)}divide(L){return new b(this._x/L._x,this._y/L._y,this._z/L._z)}divideToRef(L,r){return r._x=this._x/L._x,r._y=this._y/L._y,r._z=this._z/L._z,r._isDirty=!0,r}divideInPlace(L){return this._x=this._x/L._x,this._y=this._y/L._y,this._z=this._z/L._z,this._isDirty=!0,this}minimizeInPlace(L){return this.minimizeInPlaceFromFloats(L._x,L._y,L._z)}maximizeInPlace(L){return this.maximizeInPlaceFromFloats(L._x,L._y,L._z)}minimizeInPlaceFromFloats(L,r,p){return L<this._x&&(this.x=L),r<this._y&&(this.y=r),p<this._z&&(this.z=p),this}maximizeInPlaceFromFloats(L,r,p){return L>this._x&&(this.x=L),r>this._y&&(this.y=r),p>this._z&&(this.z=p),this}isNonUniformWithinEpsilon(L){const r=Math.abs(this._x),p=Math.abs(this._y);if(!(0,G.WithinEpsilon)(r,p,L))return!0;const J=Math.abs(this._z);return!(0,G.WithinEpsilon)(r,J,L)||!(0,G.WithinEpsilon)(p,J,L)}get isNonUniform(){const L=Math.abs(this._x);if(L!==Math.abs(this._y))return!0;return L!==Math.abs(this._z)}floorToRef(L){return L._x=Math.floor(this._x),L._y=Math.floor(this._y),L._z=Math.floor(this._z),L._isDirty=!0,L}floor(){return new b(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(L){return L._x=this._x-Math.floor(this._x),L._y=this._y-Math.floor(this._y),L._z=this._z-Math.floor(this._z),L._isDirty=!0,L}fract(){return new b(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(L){if("xyz"===(L=L.toLowerCase()))return this;const r=h.cr[0].G(this);return this.x=r[L[0]],this.y=r[L[1]],this.z=r[L[2]],this}rotateByQuaternionToRef(L,r){return L.toRotationMatrix(h.Matrix[0]),b.TransformCoordinatesToRef(this,h.Matrix[0],r),r}rotateByQuaternionAroundPointToRef(L,r,p){return this.subtractToRef(r,h.cr[0]),h.cr[0].rotateByQuaternionToRef(L,h.cr[0]),r.addToRef(h.cr[0],p),p}cross(L){return b.CrossToRef(this,L,new b)}normalizeFromLength(L){return 0===L||1===L?this:this.scaleInPlace(1/L)}normalizeToNew(){return this.normalizeToRef(new b)}normalizeToRef(L){const r=this.length();return 0===r||1===r?(L._x=this._x,L._y=this._y,L._z=this._z,L._isDirty=!0,L):this.scaleToRef(1/r,L)}clone(){return new b(this._x,this._y,this._z)}G(L){return this.Uz(L._x,L._y,L._z)}Uz(L,r,p){return this._x=L,this._y=r,this._z=p,this._isDirty=!0,this}set(L,r,p){return this.Uz(L,r,p)}Bz(L){return this._x=this._y=this._z=L,this._isDirty=!0,this}static GetClipFactor(L,r,p,J){const i=b.Dot(L,p);return(i-J)/(i-b.Dot(r,p))}static GetAngleBetweenVectors(L,r,p){const J=L.normalizeToRef(h.cr[1]),i=r.normalizeToRef(h.cr[2]);let n=b.Dot(J,i);n=(0,G.Clamp)(n,-1,1);const j=Math.acos(n),z=h.cr[3];return b.CrossToRef(J,i,z),b.Dot(z,p)>0?isNaN(j)?0:j:isNaN(j)?-Math.PI:-Math.acos(n)}static GetAngleBetweenVectorsOnPlane(L,r,p){h.cr[0].G(L);const J=h.cr[0];h.cr[1].G(r);const i=h.cr[1];h.cr[2].G(p);const n=h.cr[2],j=h.cr[3],z=h.cr[4];J.normalize(),i.normalize(),n.normalize(),b.CrossToRef(n,J,j),b.CrossToRef(j,n,z);const C=Math.atan2(b.Dot(i,j),b.Dot(i,z));return(0,G.NormalizeRadians)(C)}static PitchYawRollToMoveBetweenPointsToRef(L,r,p){const J=U.cr[0];return r.subtractToRef(L,J),p._y=Math.atan2(J.x,J.z)||0,p._x=Math.atan2(Math.sqrt(J.x**2+J.z**2),J.y)||0,p._z=0,p._isDirty=!0,p}static PitchYawRollToMoveBetweenPoints(L,r){const p=b.Zero();return b.PitchYawRollToMoveBetweenPointsToRef(L,r,p)}static SlerpToRef(L,r,p,i){p=(0,G.Clamp)(p,0,1);const n=h.cr[0],j=h.cr[1];n.G(L);const z=n.length();n.normalizeFromLength(z),j.G(r);const C=j.length();j.normalizeFromLength(C);const t=b.Dot(n,j);let E,x;if(t<1-J.d){const L=Math.acos(t),r=1/Math.sin(L);E=Math.sin((1-p)*L)*r,x=Math.sin(p*L)*r}else E=1-p,x=p;return n.scaleInPlace(E),j.scaleInPlace(x),i.G(n).addInPlace(j),i.scaleInPlace((0,G.Lerp)(z,C,p)),i}static SmoothToRef(L,r,p,J,i){return b.SlerpToRef(L,r,0===J?1:p/J,i),i}static Br(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new b(L[r],L[r+1],L[r+2])}static FromFloatArray(L,r){return b.Br(L,r)}static FromArrayToRef(L,r,p){return p._x=L[r],p._y=L[r+1],p._z=L[r+2],p._isDirty=!0,p}static FromFloatArrayToRef(L,r,p){return b.FromArrayToRef(L,r,p)}static FromFloatsToRef(L,r,p,J){return J.Uz(L,r,p),J}static Zero(){return new b(0,0,0)}static One(){return new b(1,1,1)}static Up(){return new b(0,1,0)}static get UpReadOnly(){return b._UpReadOnly}static get DownReadOnly(){return b._DownReadOnly}static get RightReadOnly(){return b._RightReadOnly}static get LeftReadOnly(){return b._LeftReadOnly}static get LeftHandedForwardReadOnly(){return b._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return b._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return b._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return b._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return b._ZeroReadOnly}static get OneReadOnly(){return b._OneReadOnly}static Down(){return new b(0,-1,0)}static Forward(){return new b(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new b(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new b(1,0,0)}static Left(){return new b(-1,0,0)}static Random(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new b((0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r))}static RandomToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Uz((0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r))}static TransformCoordinates(L,r){const p=b.Zero();return b.TransformCoordinatesToRef(L,r,p),p}static TransformCoordinatesToRef(L,r,p){return b.TransformCoordinatesFromFloatsToRef(L._x,L._y,L._z,r,p),p}static TransformCoordinatesFromFloatsToRef(L,r,p,J,i){const n=J.m,j=L*n[0]+r*n[4]+p*n[8]+n[12],z=L*n[1]+r*n[5]+p*n[9]+n[13],G=L*n[2]+r*n[6]+p*n[10]+n[14],C=1/(L*n[3]+r*n[7]+p*n[11]+n[15]);return i._x=j*C,i._y=z*C,i._z=G*C,i._isDirty=!0,i}static TransformNormal(L,r){const p=b.Zero();return b.TransformNormalToRef(L,r,p),p}static TransformNormalToRef(L,r,p){return this.TransformNormalFromFloatsToRef(L._x,L._y,L._z,r,p),p}static TransformNormalFromFloatsToRef(L,r,p,J,i){const n=J.m;return i._x=L*n[0]+r*n[4]+p*n[8],i._y=L*n[1]+r*n[5]+p*n[9],i._z=L*n[2]+r*n[6]+p*n[10],i._isDirty=!0,i}static CatmullRom(L,r,p,J,i){const n=i*i,j=i*n,z=.5*(2*r._x+(-L._x+p._x)*i+(2*L._x-5*r._x+4*p._x-J._x)*n+(-L._x+3*r._x-3*p._x+J._x)*j),G=.5*(2*r._y+(-L._y+p._y)*i+(2*L._y-5*r._y+4*p._y-J._y)*n+(-L._y+3*r._y-3*p._y+J._y)*j),C=.5*(2*r._z+(-L._z+p._z)*i+(2*L._z-5*r._z+4*p._z-J._z)*n+(-L._z+3*r._z-3*p._z+J._z)*j);return new b(z,G,C)}static Clamp(L,r,p){const J=new b;return b.ClampToRef(L,r,p,J),J}static ClampToRef(L,r,p,J){let i=L._x;i=i>p._x?p._x:i,i=i<r._x?r._x:i;let n=L._y;n=n>p._y?p._y:n,n=n<r._y?r._y:n;let j=L._z;return j=j>p._z?p._z:j,j=j<r._z?r._z:j,J.Uz(i,n,j),J}static CheckExtends(L,r,p){r.minimizeInPlace(L),p.maximizeInPlace(L)}static Hermite(L,r,p,J,i){const n=i*i,j=i*n,z=2*j-3*n+1,G=-2*j+3*n,C=j-2*n+i,t=j-n,E=L._x*z+p._x*G+r._x*C+J._x*t,x=L._y*z+p._y*G+r._y*C+J._y*t,w=L._z*z+p._z*G+r._z*C+J._z*t;return new b(E,x,w)}static Hermite1stDerivative(L,r,p,J,i){const n=new b;return this.Hermite1stDerivativeToRef(L,r,p,J,i,n),n}static Hermite1stDerivativeToRef(L,r,p,J,i,n){const j=i*i;return n._x=6*(j-i)*L._x+(3*j-4*i+1)*r._x+6*(-j+i)*p._x+(3*j-2*i)*J._x,n._y=6*(j-i)*L._y+(3*j-4*i+1)*r._y+6*(-j+i)*p._y+(3*j-2*i)*J._y,n._z=6*(j-i)*L._z+(3*j-4*i+1)*r._z+6*(-j+i)*p._z+(3*j-2*i)*J._z,n._isDirty=!0,n}static Lerp(L,r,p){const J=new b(0,0,0);return b.LerpToRef(L,r,p,J),J}static LerpToRef(L,r,p,J){return J._x=L._x+(r._x-L._x)*p,J._y=L._y+(r._y-L._y)*p,J._z=L._z+(r._z-L._z)*p,J._isDirty=!0,J}static Dot(L,r){return L._x*r._x+L._y*r._y+L._z*r._z}dot(L){return this._x*L._x+this._y*L._y+this._z*L._z}static Cross(L,r){const p=new b;return b.CrossToRef(L,r,p),p}static CrossToRef(L,r,p){const J=L._y*r._z-L._z*r._y,i=L._z*r._x-L._x*r._z,n=L._x*r._y-L._y*r._x;return p.Uz(J,i,n),p}static Normalize(L){const r=b.Zero();return b.NormalizeToRef(L,r),r}static NormalizeToRef(L,r){return L.normalizeToRef(r),r}static Project(L,r,p,J){const i=new b;return b.ProjectToRef(L,r,p,J,i),i}static ProjectToRef(L,r,p,J,i){var n;const j=J.width,G=J.height,C=J.x,t=J.y,E=h.Matrix[1],x=null===(n=z.c.LastCreatedEngine)||void 0===n?void 0:n.isNDCHalfZRange,w=x?1:.5,g=x?0:.5;O.FromValuesToRef(j/2,0,0,0,0,-G/2,0,0,0,0,w,0,C+j/2,G/2+t,g,1,E);const c=h.Matrix[0];return r.multiplyToRef(p,c),c.multiplyToRef(E,c),b.TransformCoordinatesToRef(L,c,i),i}static Reflect(L,r){return this.ReflectToRef(L,r,new b)}static ReflectToRef(L,r,p){const J=U.cr[0];return J.G(r).scaleInPlace(2*b.Dot(L,r)),p.G(L).JE(J)}static _UnprojectFromInvertedMatrixToRef(L,r,p){b.TransformCoordinatesToRef(L,r,p);const J=r.m,i=L._x*J[3]+L._y*J[7]+L._z*J[11]+J[15];return(0,G.WithinEpsilon)(i,1)&&p.scaleInPlace(1/i),p}static UnprojectFromTransform(L,r,p,J,i){return this.Unproject(L,r,p,J,i,O.IdentityReadOnly)}static Unproject(L,r,p,J,i,n){const j=new b;return b.UnprojectToRef(L,r,p,J,i,n,j),j}static UnprojectToRef(L,r,p,J,i,n,j){return b.UnprojectFloatsToRef(L._x,L._y,L._z,r,p,J,i,n,j),j}static UnprojectFloatsToRef(L,r,p,J,i,n,j,G,C){var t;const E=h.Matrix[0];n.multiplyToRef(j,E),E.multiplyToRef(G,E),E.invert();const x=h.cr[0];return x.x=L/J*2-1,x.y=-(r/i*2-1),null!==(t=z.c.LastCreatedEngine)&&void 0!==t&&t.isNDCHalfZRange?x.z=p:x.z=2*p-1,b._UnprojectFromInvertedMatrixToRef(x,E,C),C}static Minimize(L,r){const p=new b;return p.G(L),p.minimizeInPlace(r),p}static Maximize(L,r){const p=new b;return p.G(L),p.maximizeInPlace(r),p}static Distance(L,r){return Math.sqrt(b.DistanceSquared(L,r))}static DistanceSquared(L,r){const p=L._x-r._x,J=L._y-r._y,i=L._z-r._z;return p*p+J*J+i*i}static ProjectOnTriangleToRef(L,r,p,i,n){const j=h.cr[0],z=h.cr[1],C=h.cr[2],t=h.cr[3],E=h.cr[4];p.subtractToRef(r,j),i.subtractToRef(r,z),i.subtractToRef(p,C);const x=j.length(),w=z.length(),g=C.length();if(x<J.d||w<J.d||g<J.d)return n.G(r),b.Distance(L,r);L.subtractToRef(r,E),b.CrossToRef(j,z,t);const c=t.length();if(c<J.d)return n.G(r),b.Distance(L,r);t.normalizeFromLength(c);let P=E.length();if(P<J.d)return n.G(r),0;E.normalizeFromLength(P);const O=b.Dot(t,E),U=h.cr[5],W=h.cr[6];U.G(t).scaleInPlace(-P*O),W.G(L).addInPlace(U);const B=h.cr[4],F=h.cr[5],Q=h.cr[7],e=h.cr[8];B.G(j).scaleInPlace(1/x),e.G(z).scaleInPlace(1/w),B.addInPlace(e).scaleInPlace(-1),F.G(j).scaleInPlace(-1/x),e.G(C).scaleInPlace(1/g),F.addInPlace(e).scaleInPlace(-1),Q.G(C).scaleInPlace(-1/g),e.G(z).scaleInPlace(-1/w),Q.addInPlace(e).scaleInPlace(-1);const v=h.cr[9];let y;v.G(W).JE(r),b.CrossToRef(B,v,e),y=b.Dot(e,t);const A=y;v.G(W).JE(p),b.CrossToRef(F,v,e),y=b.Dot(e,t);const u=y;v.G(W).JE(i),b.CrossToRef(Q,v,e),y=b.Dot(e,t);const a=y,q=h.cr[10];let Z,X;A>0&&u<0?(q.G(j),Z=r,X=p):u>0&&a<0?(q.G(C),Z=p,X=i):(q.G(z).scaleInPlace(-1),Z=i,X=r);const D=h.cr[9],l=h.cr[4];Z.subtractToRef(W,e),X.subtractToRef(W,D),b.CrossToRef(e,D,l);if(!(b.Dot(l,t)<0))return n.G(W),Math.abs(P*O);const T=h.cr[5];b.CrossToRef(q,l,T),T.normalize();const Y=h.cr[9];Y.G(Z).JE(W);const M=Y.length();if(M<J.d)return n.G(Z),b.Distance(L,Z);Y.normalizeFromLength(M);const f=b.Dot(T,Y),d=h.cr[7];d.G(W).addInPlace(T.scaleInPlace(M*f)),e.G(d).JE(Z),P=q.length(),q.normalizeFromLength(P);let s=b.Dot(e,q)/Math.max(P,J.d);return s=(0,G.Clamp)(s,0,1),d.G(Z).addInPlace(q.scaleInPlace(s*P)),n.G(d),b.Distance(L,d)}static Center(L,r){return b.CenterToRef(L,r,b.Zero())}static CenterToRef(L,r,p){return p.Uz((L._x+r._x)/2,(L._y+r._y)/2,(L._z+r._z)/2)}static RotationFromAxis(L,r,p){const J=new b;return b.RotationFromAxisToRef(L,r,p,J),J}static RotationFromAxisToRef(L,r,p,J){const i=h.Quaternion[0];return P.RotationQuaternionFromAxisToRef(L,r,p,i),i.toEulerAnglesToRef(J),J}}b._V8PerformanceHack=new b(.5,.5,.5),b._UpReadOnly=b.Up(),b._DownReadOnly=b.Down(),b._LeftHandedForwardReadOnly=b.Forward(!1),b._RightHandedForwardReadOnly=b.Forward(!0),b._LeftHandedBackwardReadOnly=b.Backward(!1),b._RightHandedBackwardReadOnly=b.Backward(!0),b._RightReadOnly=b.Right(),b._LeftReadOnly=b.Left(),b._ZeroReadOnly=b.Zero(),b._OneReadOnly=b.One(),Object.defineProperties(b.prototype,{dimension:{value:[3]},rank:{value:1}});class c{get x(){return this._x}set x(L){this._x=L,this._isDirty=!0}get y(){return this._y}set y(L){this._y=L,this._isDirty=!0}get z(){return this._z}set z(L){this._z=L,this._isDirty=!0}get w(){return this._w}set w(L){this._w=L,this._isDirty=!0}constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=L,this._y=r,this._z=p,this._w=J}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let L=w(this._x);return L=397*L^w(this._y),L=397*L^w(this._z),L=397*L^w(this._w),L}mz(){return[this._x,this._y,this._z,this._w]}toArray(L,r){return void 0===r&&(r=0),L[r]=this._x,L[r+1]=this._y,L[r+2]=this._z,L[r+3]=this._w,this}hp(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c.FromArrayToRef(L,r,this),this}addInPlace(L){return this.x+=L._x,this.y+=L._y,this.z+=L._z,this.w+=L._w,this}addInPlaceFromFloats(L,r,p,J){return this.x+=L,this.y+=r,this.z+=p,this.w+=J,this}add(L){return new c(this._x+L.x,this._y+L.y,this._z+L.z,this._w+L.w)}addToRef(L,r){return r.x=this._x+L.x,r.y=this._y+L.y,r.z=this._z+L.z,r.w=this._w+L.w,r}JE(L){return this.x-=L.x,this.y-=L.y,this.z-=L.z,this.w-=L.w,this}Pr(L){return new c(this._x-L.x,this._y-L.y,this._z-L.z,this._w-L.w)}subtractToRef(L,r){return r.x=this._x-L.x,r.y=this._y-L.y,r.z=this._z-L.z,r.w=this._w-L.w,r}subtractFromFloats(L,r,p,J){return new c(this._x-L,this._y-r,this._z-p,this._w-J)}subtractFromFloatsToRef(L,r,p,J,i){return i.x=this._x-L,i.y=this._y-r,i.z=this._z-p,i.w=this._w-J,i}negate(){return new c(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(L){return L.x=-this._x,L.y=-this._y,L.z=-this._z,L.w=-this._w,L}scaleInPlace(L){return this.x*=L,this.y*=L,this.z*=L,this.w*=L,this}scale(L){return new c(this._x*L,this._y*L,this._z*L,this._w*L)}scaleToRef(L,r){return r.x=this._x*L,r.y=this._y*L,r.z=this._z*L,r.w=this._w*L,r}scaleAndAddToRef(L,r){return r.x+=this._x*L,r.y+=this._y*L,r.z+=this._z*L,r.w+=this._w*L,r}equals(L){return L&&this._x===L.x&&this._y===L.y&&this._z===L.z&&this._w===L.w}equalsWithEpsilon(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.d;return L&&(0,G.WithinEpsilon)(this._x,L.x,r)&&(0,G.WithinEpsilon)(this._y,L.y,r)&&(0,G.WithinEpsilon)(this._z,L.z,r)&&(0,G.WithinEpsilon)(this._w,L.w,r)}equalsToFloats(L,r,p,J){return this._x===L&&this._y===r&&this._z===p&&this._w===J}multiplyInPlace(L){return this.x*=L.x,this.y*=L.y,this.z*=L.z,this.w*=L.w,this}multiply(L){return new c(this._x*L.x,this._y*L.y,this._z*L.z,this._w*L.w)}multiplyToRef(L,r){return r.x=this._x*L.x,r.y=this._y*L.y,r.z=this._z*L.z,r.w=this._w*L.w,r}multiplyByFloats(L,r,p,J){return new c(this._x*L,this._y*r,this._z*p,this._w*J)}divide(L){return new c(this._x/L.x,this._y/L.y,this._z/L.z,this._w/L.w)}divideToRef(L,r){return r.x=this._x/L.x,r.y=this._y/L.y,r.z=this._z/L.z,r.w=this._w/L.w,r}divideInPlace(L){return this.divideToRef(L,this)}minimizeInPlace(L){return L.x<this._x&&(this.x=L.x),L.y<this._y&&(this.y=L.y),L.z<this._z&&(this.z=L.z),L.w<this._w&&(this.w=L.w),this}maximizeInPlace(L){return L.x>this._x&&(this.x=L.x),L.y>this._y&&(this.y=L.y),L.z>this._z&&(this.z=L.z),L.w>this._w&&(this.w=L.w),this}minimizeInPlaceFromFloats(L,r,p,J){return this.x=Math.min(L,this._x),this.y=Math.min(r,this._y),this.z=Math.min(p,this._z),this.w=Math.min(J,this._w),this}maximizeInPlaceFromFloats(L,r,p,J){return this.x=Math.max(L,this._x),this.y=Math.max(r,this._y),this.z=Math.max(p,this._z),this.w=Math.max(J,this._w),this}floorToRef(L){return L.x=Math.floor(this._x),L.y=Math.floor(this._y),L.z=Math.floor(this._z),L.w=Math.floor(this._w),L}floor(){return new c(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(L){return L.x=this._x-Math.floor(this._x),L.y=this._y-Math.floor(this._y),L.z=this._z-Math.floor(this._z),L.w=this._w-Math.floor(this._w),L}fract(){return new c(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(L){return 0===L||1===L?this:this.scaleInPlace(1/L)}normalizeToNew(){return this.normalizeToRef(new c)}normalizeToRef(L){const r=this.length();return 0===r||1===r?(L.x=this._x,L.y=this._y,L.z=this._z,L.w=this._w,L):this.scaleToRef(1/r,L)}toVector3(){return new b(this._x,this._y,this._z)}clone(){return new c(this._x,this._y,this._z,this._w)}G(L){return this.x=L.x,this.y=L.y,this.z=L.z,this.w=L.w,this}Uz(L,r,p,J){return this.x=L,this.y=r,this.z=p,this.w=J,this}set(L,r,p,J){return this.Uz(L,r,p,J)}Bz(L){return this.x=this.y=this.z=this.w=L,this}dot(L){return this._x*L.x+this._y*L.y+this._z*L.z+this._w*L.w}static Br(L,r){return r||(r=0),new c(L[r],L[r+1],L[r+2],L[r+3])}static FromArrayToRef(L,r,p){return p.x=L[r],p.y=L[r+1],p.z=L[r+2],p.w=L[r+3],p}static FromFloatArrayToRef(L,r,p){return c.FromArrayToRef(L,r,p),p}static FromFloatsToRef(L,r,p,J,i){return i.x=L,i.y=r,i.z=p,i.w=J,i}static Zero(){return new c(0,0,0,0)}static One(){return new c(1,1,1,1)}static Random(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new c((0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r))}static RandomToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,p=arguments.length>2?arguments[2]:void 0;return p.x=(0,G.RandomRange)(L,r),p.y=(0,G.RandomRange)(L,r),p.z=(0,G.RandomRange)(L,r),p.w=(0,G.RandomRange)(L,r),p}static Clamp(L,r,p){return c.ClampToRef(L,r,p,new c)}static ClampToRef(L,r,p,J){return J.x=(0,G.Clamp)(L.x,r.x,p.x),J.y=(0,G.Clamp)(L.y,r.y,p.y),J.z=(0,G.Clamp)(L.z,r.z,p.z),J.w=(0,G.Clamp)(L.w,r.w,p.w),J}static CheckExtends(L,r,p){r.minimizeInPlace(L),p.maximizeInPlace(L)}static get ZeroReadOnly(){return c._ZeroReadOnly}static Normalize(L){return c.NormalizeToRef(L,new c)}static NormalizeToRef(L,r){return L.normalizeToRef(r),r}static Minimize(L,r){const p=new c;return p.G(L),p.minimizeInPlace(r),p}static Maximize(L,r){const p=new c;return p.G(L),p.maximizeInPlace(r),p}static Distance(L,r){return Math.sqrt(c.DistanceSquared(L,r))}static DistanceSquared(L,r){const p=L.x-r.x,J=L.y-r.y,i=L.z-r.z,n=L.w-r.w;return p*p+J*J+i*i+n*n}static Center(L,r){return c.CenterToRef(L,r,new c)}static CenterToRef(L,r,p){return p.x=(L.x+r.x)/2,p.y=(L.y+r.y)/2,p.z=(L.z+r.z)/2,p.w=(L.w+r.w)/2,p}static TransformCoordinates(L,r){return c.TransformCoordinatesToRef(L,r,new c)}static TransformCoordinatesToRef(L,r,p){return c.TransformCoordinatesFromFloatsToRef(L._x,L._y,L._z,r,p),p}static TransformCoordinatesFromFloatsToRef(L,r,p,J,i){const n=J.m,j=L*n[0]+r*n[4]+p*n[8]+n[12],z=L*n[1]+r*n[5]+p*n[9]+n[13],G=L*n[2]+r*n[6]+p*n[10]+n[14],C=L*n[3]+r*n[7]+p*n[11]+n[15];return i.x=j,i.y=z,i.z=G,i.w=C,i}static TransformNormal(L,r){return c.TransformNormalToRef(L,r,new c)}static TransformNormalToRef(L,r,p){const J=r.m,i=L.x*J[0]+L.y*J[4]+L.z*J[8],n=L.x*J[1]+L.y*J[5]+L.z*J[9],j=L.x*J[2]+L.y*J[6]+L.z*J[10];return p.x=i,p.y=n,p.z=j,p.w=L.w,p}static TransformNormalFromFloatsToRef(L,r,p,J,i,n){const j=i.m;return n.x=L*j[0]+r*j[4]+p*j[8],n.y=L*j[1]+r*j[5]+p*j[9],n.z=L*j[2]+r*j[6]+p*j[10],n.w=J,n}static FromVector3(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new c(L._x,L._y,L._z,r)}static Dot(L,r){return L.x*r.x+L.y*r.y+L.z*r.z+L.w*r.w}}c._V8PerformanceHack=new c(.5,.5,.5,.5),c._ZeroReadOnly=c.Zero(),Object.defineProperties(c.prototype,{dimension:{value:[4]},rank:{value:1}});class P{get x(){return this._x}set x(L){this._x=L,this._isDirty=!0}get y(){return this._y}set y(L){this._y=L,this._isDirty=!0}get z(){return this._z}set z(L){this._z=L,this._isDirty=!0}get w(){return this._w}set w(L){this._w=L,this._isDirty=!0}constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=L,this._y=r,this._z=p,this._w=J}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let L=w(this._x);return L=397*L^w(this._y),L=397*L^w(this._z),L=397*L^w(this._w),L}mz(){return[this._x,this._y,this._z,this._w]}toArray(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L[r]=this._x,L[r+1]=this._y,L[r+2]=this._z,L[r+3]=this._w,this}hp(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P.FromArrayToRef(L,r,this)}equals(L){return L&&this._x===L._x&&this._y===L._y&&this._z===L._z&&this._w===L._w}equalsWithEpsilon(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.d;return L&&(0,G.WithinEpsilon)(this._x,L._x,r)&&(0,G.WithinEpsilon)(this._y,L._y,r)&&(0,G.WithinEpsilon)(this._z,L._z,r)&&(0,G.WithinEpsilon)(this._w,L._w,r)}isApprox(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.d;return L&&((0,G.WithinEpsilon)(this._x,L._x,r)&&(0,G.WithinEpsilon)(this._y,L._y,r)&&(0,G.WithinEpsilon)(this._z,L._z,r)&&(0,G.WithinEpsilon)(this._w,L._w,r)||(0,G.WithinEpsilon)(this._x,-L._x,r)&&(0,G.WithinEpsilon)(this._y,-L._y,r)&&(0,G.WithinEpsilon)(this._z,-L._z,r)&&(0,G.WithinEpsilon)(this._w,-L._w,r))}clone(){return new P(this._x,this._y,this._z,this._w)}G(L){return this._x=L._x,this._y=L._y,this._z=L._z,this._w=L._w,this._isDirty=!0,this}Uz(L,r,p,J){return this._x=L,this._y=r,this._z=p,this._w=J,this._isDirty=!0,this}set(L,r,p,J){return this.Uz(L,r,p,J)}Bz(L){return this.Uz(L,L,L,L)}add(L){return new P(this._x+L._x,this._y+L._y,this._z+L._z,this._w+L._w)}addInPlace(L){return this._x+=L._x,this._y+=L._y,this._z+=L._z,this._w+=L._w,this._isDirty=!0,this}addToRef(L,r){return r._x=this._x+L._x,r._y=this._y+L._y,r._z=this._z+L._z,r._w=this._w+L._w,r._isDirty=!0,r}addInPlaceFromFloats(L,r,p,J){return this._x+=L,this._y+=r,this._z+=p,this._w+=J,this._isDirty=!0,this}subtractToRef(L,r){return r._x=this._x-L._x,r._y=this._y-L._y,r._z=this._z-L._z,r._w=this._w-L._w,r._isDirty=!0,r}subtractFromFloats(L,r,p,J){return this.subtractFromFloatsToRef(L,r,p,J,new P)}subtractFromFloatsToRef(L,r,p,J,i){return i._x=this._x-L,i._y=this._y-r,i._z=this._z-p,i._w=this._w-J,i._isDirty=!0,i}Pr(L){return new P(this._x-L._x,this._y-L._y,this._z-L._z,this._w-L._w)}JE(L){return this._x-=L._x,this._y-=L._y,this._z-=L._z,this._w-=L._w,this._isDirty=!0,this}scale(L){return new P(this._x*L,this._y*L,this._z*L,this._w*L)}scaleToRef(L,r){return r._x=this._x*L,r._y=this._y*L,r._z=this._z*L,r._w=this._w*L,r._isDirty=!0,r}scaleInPlace(L){return this._x*=L,this._y*=L,this._z*=L,this._w*=L,this._isDirty=!0,this}scaleAndAddToRef(L,r){return r._x+=this._x*L,r._y+=this._y*L,r._z+=this._z*L,r._w+=this._w*L,r._isDirty=!0,r}multiply(L){const r=new P(0,0,0,1);return this.multiplyToRef(L,r),r}multiplyToRef(L,r){const p=this._x*L._w+this._y*L._z-this._z*L._y+this._w*L._x,J=-this._x*L._z+this._y*L._w+this._z*L._x+this._w*L._y,i=this._x*L._y-this._y*L._x+this._z*L._w+this._w*L._z,n=-this._x*L._x-this._y*L._y-this._z*L._z+this._w*L._w;return r.Uz(p,J,i,n),r}multiplyInPlace(L){return this.multiplyToRef(L,this)}multiplyByFloats(L,r,p,J){return this._x*=L,this._y*=r,this._z*=p,this._w*=J,this._isDirty=!0,this}divide(L){throw new ReferenceError("Can not divide a quaternion")}divideToRef(L,r){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(L){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new P)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(L){return L._x=-this._x,L._y=-this._y,L._z=-this._z,L._w=-this._w,L._isDirty=!0,L}equalsToFloats(L,r,p,J){return this._x===L&&this._y===r&&this._z===p&&this._w===J}floorToRef(L){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(L){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(L){return L.Uz(-this._x,-this._y,-this._z,this._w),L}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new P(-this._x,-this._y,-this._z,this._w)}invert(){const L=this.conjugate(),r=this.lengthSquared();return 0==r||1==r||L.scaleInPlace(1/r),L}invertInPlace(){this.conjugateInPlace();const L=this.lengthSquared();return 0==L||1==L||this.scaleInPlace(1/L),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(L){return 0===L||1===L?this:this.scaleInPlace(1/L)}normalizeToNew(){const L=new P(0,0,0,1);return this.normalizeToRef(L),L}normalizeToRef(L){const r=this.length();return 0===r||1===r?L.Uz(this._x,this._y,this._z,this._w):this.scaleToRef(1/r,L)}toEulerAngles(){const L=b.Zero();return this.toEulerAnglesToRef(L),L}toEulerAnglesToRef(L){const r=this._z,p=this._x,J=this._y,i=this._w,n=J*r-p*i,j=.4999999;if(n<-j)L._y=2*Math.atan2(J,i),L._x=Math.PI/2,L._z=0,L._isDirty=!0;else if(n>j)L._y=2*Math.atan2(J,i),L._x=-Math.PI/2,L._z=0,L._isDirty=!0;else{const j=i*i,z=r*r,G=p*p,C=J*J;L._z=Math.atan2(2*(p*J+r*i),-z-G+C+j),L._x=Math.asin(-2*n),L._y=Math.atan2(2*(r*p+J*i),z-G-C+j),L._isDirty=!0}return L}toAlphaBetaGammaToRef(L){const r=this._z,p=this._x,J=this._y,i=this._w,n=Math.sqrt(p*p+J*J),j=Math.sqrt(r*r+i*i),z=2*Math.atan2(n,j),G=2*Math.atan2(r,i),C=2*Math.atan2(J,p),t=(G+C)/2,E=(G-C)/2;return L.set(E,z,t),L}toRotationMatrix(L){return O.FromQuaternionToRef(this,L),L}fromRotationMatrix(L){return P.FromRotationMatrixToRef(L,this),this}dot(L){return this._x*L._x+this._y*L._y+this._z*L._z+this._w*L._w}toAxisAngle(){const L=b.Zero();return{axis:L,angle:this.toAxisAngleToRef(L)}}toAxisAngleToRef(L){let r=0;const p=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),J=this._w;return p>0?(r=2*Math.atan2(p,J),L.set(this._x/p,this._y/p,this._z/p)):(r=0,L.set(1,0,0)),r}static FromRotationMatrix(L){const r=new P;return P.FromRotationMatrixToRef(L,r),r}static FromRotationMatrixToRef(L,r){const p=L.m,J=p[0],i=p[4],n=p[8],j=p[1],z=p[5],G=p[9],C=p[2],t=p[6],E=p[10],x=J+z+E;let w;return x>0?(w=.5/Math.sqrt(x+1),r._w=.25/w,r._x=(t-G)*w,r._y=(n-C)*w,r._z=(j-i)*w,r._isDirty=!0):J>z&&J>E?(w=2*Math.sqrt(1+J-z-E),r._w=(t-G)/w,r._x=.25*w,r._y=(i+j)/w,r._z=(n+C)/w,r._isDirty=!0):z>E?(w=2*Math.sqrt(1+z-J-E),r._w=(n-C)/w,r._x=(i+j)/w,r._y=.25*w,r._z=(G+t)/w,r._isDirty=!0):(w=2*Math.sqrt(1+E-J-z),r._w=(j-i)/w,r._x=(n+C)/w,r._y=(G+t)/w,r._z=.25*w,r._isDirty=!0),r}static Dot(L,r){return L._x*r._x+L._y*r._y+L._z*r._z+L._w*r._w}static AreClose(L,r){let p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const J=P.Dot(L,r);return 1-J*J<=p}static SmoothToRef(L,r,p,J,i){let n=0===J?1:p/J;return n=(0,G.Clamp)(n,0,1),P.SlerpToRef(L,r,n,i),i}static Zero(){return new P(0,0,0,0)}static Inverse(L){return new P(-L._x,-L._y,-L._z,L._w)}static InverseToRef(L,r){return r.set(-L._x,-L._y,-L._z,L._w),r}static Identity(){return new P(0,0,0,1)}static IsIdentity(L){return L&&0===L._x&&0===L._y&&0===L._z&&1===L._w}static RotationAxis(L,r){return P.RotationAxisToRef(L,r,new P)}static RotationAxisToRef(L,r,p){p._w=Math.cos(r/2);const J=Math.sin(r/2)/L.length();return p._x=L._x*J,p._y=L._y*J,p._z=L._z*J,p._isDirty=!0,p}static Br(L,r){return r||(r=0),new P(L[r],L[r+1],L[r+2],L[r+3])}static FromArrayToRef(L,r,p){return p._x=L[r],p._y=L[r+1],p._z=L[r+2],p._w=L[r+3],p._isDirty=!0,p}static FromFloatsToRef(L,r,p,J,i){return i.Uz(L,r,p,J),i}static FromEulerAngles(L,r,p){const J=new P;return P.RotationYawPitchRollToRef(r,L,p,J),J}static FromEulerAnglesToRef(L,r,p,J){return P.RotationYawPitchRollToRef(r,L,p,J),J}static FromEulerVector(L){const r=new P;return P.RotationYawPitchRollToRef(L._y,L._x,L._z,r),r}static FromEulerVectorToRef(L,r){return P.RotationYawPitchRollToRef(L._y,L._x,L._z,r),r}static FromUnitVectorsToRef(L,r,p){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:J.d;const n=b.Dot(L,r)+1;return n<i?Math.abs(L.x)>Math.abs(L.z)?p.set(-L.y,L.x,0,0):p.set(0,-L.z,L.y,0):(b.CrossToRef(L,r,U.cr[0]),p.set(U.cr[0].x,U.cr[0].y,U.cr[0].z,n)),p.normalize()}static RotationYawPitchRoll(L,r,p){const J=new P;return P.RotationYawPitchRollToRef(L,r,p,J),J}static RotationYawPitchRollToRef(L,r,p,J){const i=.5*p,n=.5*r,j=.5*L,z=Math.sin(i),G=Math.cos(i),C=Math.sin(n),t=Math.cos(n),E=Math.sin(j),x=Math.cos(j);return J._x=x*C*G+E*t*z,J._y=E*t*G-x*C*z,J._z=x*t*z-E*C*G,J._w=x*t*G+E*C*z,J._isDirty=!0,J}static RotationAlphaBetaGamma(L,r,p){const J=new P;return P.RotationAlphaBetaGammaToRef(L,r,p,J),J}static RotationAlphaBetaGammaToRef(L,r,p,J){const i=.5*(p+L),n=.5*(p-L),j=.5*r;return J._x=Math.cos(n)*Math.sin(j),J._y=Math.sin(n)*Math.sin(j),J._z=Math.sin(i)*Math.cos(j),J._w=Math.cos(i)*Math.cos(j),J._isDirty=!0,J}static RotationQuaternionFromAxis(L,r,p){const J=new P(0,0,0,0);return P.RotationQuaternionFromAxisToRef(L,r,p,J),J}static RotationQuaternionFromAxisToRef(L,r,p,J){const i=h.Matrix[0];return L=L.normalizeToRef(h.cr[0]),r=r.normalizeToRef(h.cr[1]),p=p.normalizeToRef(h.cr[2]),O.FromXYZAxesToRef(L,r,p,i),P.FromRotationMatrixToRef(i,J),J}static FromLookDirectionLH(L,r){const p=new P;return P.FromLookDirectionLHToRef(L,r,p),p}static FromLookDirectionLHToRef(L,r,p){const J=h.Matrix[0];return O.LookDirectionLHToRef(L,r,J),P.FromRotationMatrixToRef(J,p),p}static FromLookDirectionRH(L,r){const p=new P;return P.FromLookDirectionRHToRef(L,r,p),p}static FromLookDirectionRHToRef(L,r,p){const J=h.Matrix[0];return O.LookDirectionRHToRef(L,r,J),P.FromRotationMatrixToRef(J,p)}static Slerp(L,r,p){const J=P.Identity();return P.SlerpToRef(L,r,p,J),J}static SlerpToRef(L,r,p,J){let i,n,j=L._x*r._x+L._y*r._y+L._z*r._z+L._w*r._w,z=!1;if(j<0&&(z=!0,j=-j),j>.999999)n=1-p,i=z?-p:p;else{const L=Math.acos(j),r=1/Math.sin(L);n=Math.sin((1-p)*L)*r,i=z?-Math.sin(p*L)*r:Math.sin(p*L)*r}return J._x=n*L._x+i*r._x,J._y=n*L._y+i*r._y,J._z=n*L._z+i*r._z,J._w=n*L._w+i*r._w,J._isDirty=!0,J}static Hermite(L,r,p,J,i){const n=i*i,j=i*n,z=2*j-3*n+1,G=-2*j+3*n,C=j-2*n+i,t=j-n,E=L._x*z+p._x*G+r._x*C+J._x*t,x=L._y*z+p._y*G+r._y*C+J._y*t,w=L._z*z+p._z*G+r._z*C+J._z*t,g=L._w*z+p._w*G+r._w*C+J._w*t;return new P(E,x,w,g)}static Hermite1stDerivative(L,r,p,J,i){const n=new P;return this.Hermite1stDerivativeToRef(L,r,p,J,i,n),n}static Hermite1stDerivativeToRef(L,r,p,J,i,n){const j=i*i;return n._x=6*(j-i)*L._x+(3*j-4*i+1)*r._x+6*(-j+i)*p._x+(3*j-2*i)*J._x,n._y=6*(j-i)*L._y+(3*j-4*i+1)*r._y+6*(-j+i)*p._y+(3*j-2*i)*J._y,n._z=6*(j-i)*L._z+(3*j-4*i+1)*r._z+6*(-j+i)*p._z+(3*j-2*i)*J._z,n._w=6*(j-i)*L._w+(3*j-4*i+1)*r._w+6*(-j+i)*p._w+(3*j-2*i)*J._w,n._isDirty=!0,n}static Normalize(L){const r=P.Zero();return P.NormalizeToRef(L,r),r}static NormalizeToRef(L,r){return L.normalizeToRef(r),r}static Clamp(L,r,p){const J=new P;return P.ClampToRef(L,r,p,J),J}static ClampToRef(L,r,p,J){return J.Uz((0,G.Clamp)(L.x,r.x,p.x),(0,G.Clamp)(L.y,r.y,p.y),(0,G.Clamp)(L.z,r.z,p.z),(0,G.Clamp)(L.w,r.w,p.w))}static Random(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new P((0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r))}static RandomToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Uz((0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r),(0,G.RandomRange)(L,r))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(L,r){return Math.sqrt(P.DistanceSquared(L,r))}static DistanceSquared(L,r){const p=L.x-r.x,J=L.y-r.y,i=L.z-r.z,n=L.w-r.w;return p*p+J*J+i*i+n*n}static Center(L,r){return P.CenterToRef(L,r,P.Zero())}static CenterToRef(L,r,p){return p.Uz((L.x+r.x)/2,(L.y+r.y)/2,(L.z+r.z)/2,(L.w+r.w)/2)}}P._V8PerformanceHack=new P(.5,.5,.5,.5),Object.defineProperties(P.prototype,{dimension:{value:[4]},rank:{value:1}});class O{static get Use64Bits(){return j.e.MatrixUse64Bits}get m(){return this.ai}markAsUpdated(){this.updateFlag=C._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(L){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],p=arguments.length>2&&void 0!==arguments[2]&&arguments[2],J=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=L,this._isIdentity3x2=L||p,this._isIdentityDirty=!this._isIdentity&&r,this._isIdentity3x2Dirty=!this._isIdentity3x2&&J}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,j.e.MatrixTrackPrecisionChange&&j.e.MatrixTrackedMatrices.push(this),this.ai=new j.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const L=this.ai;this._isIdentity=1===L[0]&&0===L[1]&&0===L[2]&&0===L[3]&&0===L[4]&&1===L[5]&&0===L[6]&&0===L[7]&&0===L[8]&&0===L[9]&&1===L[10]&&0===L[11]&&0===L[12]&&0===L[13]&&0===L[14]&&1===L[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.ai[0]||1!==this.ai[5]||1!==this.ai[15]||0!==this.ai[1]||0!==this.ai[2]||0!==this.ai[3]||0!==this.ai[4]||0!==this.ai[6]||0!==this.ai[7]||0!==this.ai[8]||0!==this.ai[9]||0!==this.ai[10]||0!==this.ai[11]||0!==this.ai[12]||0!==this.ai[13]||0!==this.ai[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const L=this.ai,r=L[0],p=L[1],J=L[2],i=L[3],n=L[4],j=L[5],z=L[6],G=L[7],C=L[8],t=L[9],E=L[10],x=L[11],w=L[12],g=L[13],b=L[14],c=L[15],P=E*c-b*x,O=t*c-g*x,h=t*b-g*E,U=C*c-w*x,W=C*b-E*w,B=C*g-w*t;return r*+(j*P-z*O+G*h)+p*-(n*P-z*U+G*W)+J*+(n*O-j*U+G*B)+i*-(n*h-j*W+z*B)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!L)return this.ai;const p=this.ai;for(let J=0;J<16;J++)L[r+J]=p[J];return this}mz(){return this.ai}hp(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(L,r,this)}Uz(){for(var L=arguments.length,r=new Array(L),p=0;p<L;p++)r[p]=arguments[p];return O.FromArrayToRef(r,0,this)}set(){const L=this.ai;for(let r=0;r<16;r++)L[r]=r<0||arguments.length<=r?void 0:arguments[r];return this.markAsUpdated(),this}Bz(L){const r=this.ai;for(let p=0;p<16;p++)r[p]=L;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return O.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(L){const r=new O;return this.addToRef(L,r),r}addToRef(L,r){const p=this.ai,J=r.ai,i=L.m;for(let n=0;n<16;n++)J[n]=p[n]+i[n];return r.markAsUpdated(),r}addToSelf(L){const r=this.ai,p=L.m;return r[0]+=p[0],r[1]+=p[1],r[2]+=p[2],r[3]+=p[3],r[4]+=p[4],r[5]+=p[5],r[6]+=p[6],r[7]+=p[7],r[8]+=p[8],r[9]+=p[9],r[10]+=p[10],r[11]+=p[11],r[12]+=p[12],r[13]+=p[13],r[14]+=p[14],r[15]+=p[15],this.markAsUpdated(),this}addInPlace(L){const r=this.ai,p=L.m;for(let J=0;J<16;J++)r[J]+=p[J];return this.markAsUpdated(),this}addInPlaceFromFloats(){const L=this.ai;for(let r=0;r<16;r++)L[r]+=r<0||arguments.length<=r?void 0:arguments[r];return this.markAsUpdated(),this}Pr(L){const r=this.ai,p=L.m;for(let J=0;J<16;J++)r[J]-=p[J];return this.markAsUpdated(),this}subtractToRef(L,r){const p=this.ai,J=L.m,i=r.ai;for(let n=0;n<16;n++)i[n]=p[n]-J[n];return r.markAsUpdated(),r}JE(L){const r=this.ai,p=L.m;for(let J=0;J<16;J++)r[J]-=p[J];return this.markAsUpdated(),this}subtractFromFloats(){for(var L=arguments.length,r=new Array(L),p=0;p<L;p++)r[p]=arguments[p];return this.subtractFromFloatsToRef(...r,new O)}subtractFromFloatsToRef(){for(var L=arguments.length,r=new Array(L),p=0;p<L;p++)r[p]=arguments[p];const J=r.pop(),i=this.ai,n=J.ai,j=r;for(let z=0;z<16;z++)n[z]=i[z]-j[z];return J.markAsUpdated(),J}invertToRef(L){return!0===this._isIdentity?(O.IdentityToRef(L),L):(x(this,L.mz())?L.markAsUpdated():L.G(this),L)}addAtIndex(L,r){return this.ai[L]+=r,this.markAsUpdated(),this}multiplyAtIndex(L,r){return this.ai[L]*=r,this.markAsUpdated(),this}setTranslationFromFloats(L,r,p){return this.ai[12]=L,this.ai[13]=r,this.ai[14]=p,this.markAsUpdated(),this}addTranslationFromFloats(L,r,p){return this.ai[12]+=L,this.ai[13]+=r,this.ai[14]+=p,this.markAsUpdated(),this}setTranslation(L){return this.setTranslationFromFloats(L._x,L._y,L._z)}getTranslation(){return new b(this.ai[12],this.ai[13],this.ai[14])}getTranslationToRef(L){return L.x=this.ai[12],L.y=this.ai[13],L.z=this.ai[14],L}removeRotationAndScaling(){const L=this.m;return O.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,L[12],L[13],L[14],L[15],this),this._updateIdentityStatus(0===L[12]&&0===L[13]&&0===L[14]&&1===L[15]),this}G(L){L.copyToArray(this.ai);const r=L;return this.updateFlag=r.updateFlag,this._updateIdentityStatus(r._isIdentity,r._isIdentityDirty,r._isIdentity3x2,r._isIdentity3x2Dirty),this}copyToArray(L){return E(this,L,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(L){const r=new O;return this.multiplyToRef(L,r),r}multiplyInPlace(L){const r=this.ai,p=L.m;for(let J=0;J<16;J++)r[J]*=p[J];return this.markAsUpdated(),this}multiplyByFloats(){const L=this.ai;for(let r=0;r<16;r++)L[r]*=r<0||arguments.length<=r?void 0:arguments[r];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var L=arguments.length,r=new Array(L),p=0;p<L;p++)r[p]=arguments[p];const J=r.pop(),i=this.ai,n=J.ai,j=r;for(let z=0;z<16;z++)n[z]=i[z]*j[z];return J.markAsUpdated(),J}multiplyToRef(L,r){return this._isIdentity?(r.G(L),r):L._isIdentity?(r.G(this),r):(this.multiplyToArray(L,r.ai,0),r.markAsUpdated(),r)}multiplyToArray(L,r,p){return t(this,L,r,p),this}divide(L){return this.divideToRef(L,new O)}divideToRef(L,r){const p=this.ai,J=L.m,i=r.ai;for(let n=0;n<16;n++)i[n]=p[n]/J[n];return r.markAsUpdated(),r}divideInPlace(L){const r=this.ai,p=L.m;for(let J=0;J<16;J++)r[J]/=p[J];return this.markAsUpdated(),this}minimizeInPlace(L){const r=this.ai,p=L.m;for(let J=0;J<16;J++)r[J]=Math.min(r[J],p[J]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const L=this.ai;for(let r=0;r<16;r++)L[r]=Math.min(L[r],r<0||arguments.length<=r?void 0:arguments[r]);return this.markAsUpdated(),this}maximizeInPlace(L){const r=this.ai,p=L.m;for(let J=0;J<16;J++)r[J]=Math.min(r[J],p[J]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const L=this.ai;for(let r=0;r<16;r++)L[r]=Math.min(L[r],r<0||arguments.length<=r?void 0:arguments[r]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new O)}negateInPlace(){const L=this.ai;for(let r=0;r<16;r++)L[r]=-L[r];return this.markAsUpdated(),this}negateToRef(L){const r=this.ai,p=L.ai;for(let J=0;J<16;J++)p[J]=-r[J];return L.markAsUpdated(),L}equals(L){const r=L;if(!r)return!1;if((this._isIdentity||r._isIdentity)&&!this._isIdentityDirty&&!r._isIdentityDirty)return this._isIdentity&&r._isIdentity;const p=this.m,J=r.m;return p[0]===J[0]&&p[1]===J[1]&&p[2]===J[2]&&p[3]===J[3]&&p[4]===J[4]&&p[5]===J[5]&&p[6]===J[6]&&p[7]===J[7]&&p[8]===J[8]&&p[9]===J[9]&&p[10]===J[10]&&p[11]===J[11]&&p[12]===J[12]&&p[13]===J[13]&&p[14]===J[14]&&p[15]===J[15]}equalsWithEpsilon(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const p=this.ai,J=L.m;for(let i=0;i<16;i++)if(!(0,G.WithinEpsilon)(p[i],J[i],r))return!1;return!0}equalsToFloats(){const L=this.ai;for(let r=0;r<16;r++)if(L[r]!=(r<0||arguments.length<=r?void 0:arguments[r]))return!1;return!0}floor(){return this.floorToRef(new O)}floorToRef(L){const r=this.ai,p=L.ai;for(let J=0;J<16;J++)p[J]=Math.floor(r[J]);return L.markAsUpdated(),L}fract(){return this.fractToRef(new O)}fractToRef(L){const r=this.ai,p=L.ai;for(let J=0;J<16;J++)p[J]=r[J]-Math.floor(r[J]);return L.markAsUpdated(),L}clone(){const L=new O;return L.G(this),L}getClassName(){return"Matrix"}getHashCode(){let L=w(this.ai[0]);for(let r=1;r<16;r++)L=397*L^w(this.ai[r]);return L}decomposeToTransformNode(L){return L.rotationQuaternion=L.rotationQuaternion||new P,this.decompose(L.Wz,L.rotationQuaternion,L.position)}decompose(L,r,p,J){let i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return p&&p.Bz(0),L&&L.Bz(1),r&&r.Uz(0,0,0,1),!0;const n=this.ai;if(p&&p.Uz(n[12],n[13],n[14]),(L=L||h.cr[0]).x=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]),L.y=Math.sqrt(n[4]*n[4]+n[5]*n[5]+n[6]*n[6]),L.z=Math.sqrt(n[8]*n[8]+n[9]*n[9]+n[10]*n[10]),J){const r=(i?J.absoluteScaling.x:J.Wz.x)<0?-1:1,p=(i?J.absoluteScaling.y:J.Wz.y)<0?-1:1,n=(i?J.absoluteScaling.z:J.Wz.z)<0?-1:1;L.x*=r,L.y*=p,L.z*=n}else this.determinant()<=0&&(L.y*=-1);if(0===L._x||0===L._y||0===L._z)return r&&r.Uz(0,0,0,1),!1;if(r){const p=1/L._x,J=1/L._y,i=1/L._z;O.FromValuesToRef(n[0]*p,n[1]*p,n[2]*p,0,n[4]*J,n[5]*J,n[6]*J,0,n[8]*i,n[9]*i,n[10]*i,0,0,0,0,1,h.Matrix[0]),P.FromRotationMatrixToRef(h.Matrix[0],r)}return!0}getRow(L){if(L<0||L>3)return null;const r=4*L;return new c(this.ai[r+0],this.ai[r+1],this.ai[r+2],this.ai[r+3])}getRowToRef(L,r){if(L>=0&&L<=3){const p=4*L;r.x=this.ai[p+0],r.y=this.ai[p+1],r.z=this.ai[p+2],r.w=this.ai[p+3]}return r}setRow(L,r){return this.setRowFromFloats(L,r.x,r.y,r.z,r.w)}transpose(){const L=new O;return O.TransposeToRef(this,L),L}transposeToRef(L){return O.TransposeToRef(this,L),L}setRowFromFloats(L,r,p,J,i){if(L<0||L>3)return this;const n=4*L;return this.ai[n+0]=r,this.ai[n+1]=p,this.ai[n+2]=J,this.ai[n+3]=i,this.markAsUpdated(),this}scale(L){const r=new O;return this.scaleToRef(L,r),r}scaleToRef(L,r){for(let p=0;p<16;p++)r.ai[p]=this.ai[p]*L;return r.markAsUpdated(),r}scaleAndAddToRef(L,r){for(let p=0;p<16;p++)r.ai[p]+=this.ai[p]*L;return r.markAsUpdated(),r}scaleInPlace(L){const r=this.ai;for(let p=0;p<16;p++)r[p]*=L;return this.markAsUpdated(),this}toNormalMatrix(L){const r=h.Matrix[0];this.invertToRef(r),r.transposeToRef(L);const p=L.ai;return O.FromValuesToRef(p[0],p[1],p[2],0,p[4],p[5],p[6],0,p[8],p[9],p[10],0,0,0,0,1,L),L}getRotationMatrix(){const L=new O;return this.getRotationMatrixToRef(L),L}getRotationMatrixToRef(L){const r=h.cr[0];if(!this.decompose(r))return O.IdentityToRef(L),L;const p=this.ai,J=1/r._x,i=1/r._y,n=1/r._z;return O.FromValuesToRef(p[0]*J,p[1]*J,p[2]*J,0,p[4]*i,p[5]*i,p[6]*i,0,p[8]*n,p[9]*n,p[10]*n,0,0,0,0,1,L),L}toggleModelMatrixHandInPlace(){const L=this.ai;return L[2]*=-1,L[6]*=-1,L[8]*=-1,L[9]*=-1,L[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const L=this.ai;return L[8]*=-1,L[9]*=-1,L[10]*=-1,L[11]*=-1,this.markAsUpdated(),this}static Br(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const p=new O;return O.FromArrayToRef(L,r,p),p}static FromArrayToRef(L,r,p){for(let J=0;J<16;J++)p.ai[J]=L[J+r];return p.markAsUpdated(),p}static FromFloat32ArrayToRefScaled(L,r,p,J){return J.ai[0]=L[0+r]*p,J.ai[1]=L[1+r]*p,J.ai[2]=L[2+r]*p,J.ai[3]=L[3+r]*p,J.ai[4]=L[4+r]*p,J.ai[5]=L[5+r]*p,J.ai[6]=L[6+r]*p,J.ai[7]=L[7+r]*p,J.ai[8]=L[8+r]*p,J.ai[9]=L[9+r]*p,J.ai[10]=L[10+r]*p,J.ai[11]=L[11+r]*p,J.ai[12]=L[12+r]*p,J.ai[13]=L[13+r]*p,J.ai[14]=L[14+r]*p,J.ai[15]=L[15+r]*p,J.markAsUpdated(),J}static get IdentityReadOnly(){return O._IdentityReadOnly}static FromValuesToRef(L,r,p,J,i,n,j,z,G,C,t,E,x,w,g,b,c){const P=c.ai;P[0]=L,P[1]=r,P[2]=p,P[3]=J,P[4]=i,P[5]=n,P[6]=j,P[7]=z,P[8]=G,P[9]=C,P[10]=t,P[11]=E,P[12]=x,P[13]=w,P[14]=g,P[15]=b,c.markAsUpdated()}static FromValues(L,r,p,J,i,n,j,z,G,C,t,E,x,w,g,b){const c=new O,P=c.ai;return P[0]=L,P[1]=r,P[2]=p,P[3]=J,P[4]=i,P[5]=n,P[6]=j,P[7]=z,P[8]=G,P[9]=C,P[10]=t,P[11]=E,P[12]=x,P[13]=w,P[14]=g,P[15]=b,c.markAsUpdated(),c}static Compose(L,r,p){const J=new O;return O.ComposeToRef(L,r,p,J),J}static ComposeToRef(L,r,p,J){const i=J.ai,n=r._x,j=r._y,z=r._z,G=r._w,C=n+n,t=j+j,E=z+z,x=n*C,w=n*t,g=n*E,b=j*t,c=j*E,P=z*E,O=G*C,h=G*t,U=G*E,W=L._x,B=L._y,F=L._z;return i[0]=(1-(b+P))*W,i[1]=(w+U)*W,i[2]=(g-h)*W,i[3]=0,i[4]=(w-U)*B,i[5]=(1-(x+P))*B,i[6]=(c+O)*B,i[7]=0,i[8]=(g+h)*F,i[9]=(c-O)*F,i[10]=(1-(x+b))*F,i[11]=0,i[12]=p._x,i[13]=p._y,i[14]=p._z,i[15]=1,J.markAsUpdated(),J}static Identity(){const L=O.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return L._updateIdentityStatus(!0),L}static IdentityToRef(L){return O.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,L),L._updateIdentityStatus(!0),L}static Zero(){const L=O.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return L._updateIdentityStatus(!1),L}static RotationX(L){const r=new O;return O.RotationXToRef(L,r),r}static Invert(L){const r=new O;return L.invertToRef(r),r}static RotationXToRef(L,r){const p=Math.sin(L),J=Math.cos(L);return O.FromValuesToRef(1,0,0,0,0,J,p,0,0,-p,J,0,0,0,0,1,r),r._updateIdentityStatus(1===J&&0===p),r}static RotationY(L){const r=new O;return O.RotationYToRef(L,r),r}static RotationYToRef(L,r){const p=Math.sin(L),J=Math.cos(L);return O.FromValuesToRef(J,0,-p,0,0,1,0,0,p,0,J,0,0,0,0,1,r),r._updateIdentityStatus(1===J&&0===p),r}static RotationZ(L){const r=new O;return O.RotationZToRef(L,r),r}static RotationZToRef(L,r){const p=Math.sin(L),J=Math.cos(L);return O.FromValuesToRef(J,p,0,0,-p,J,0,0,0,0,1,0,0,0,0,1,r),r._updateIdentityStatus(1===J&&0===p),r}static RotationAxis(L,r){const p=new O;return O.RotationAxisToRef(L,r,p),p}static RotationAxisToRef(L,r,p){const J=Math.sin(-r),i=Math.cos(-r),n=1-i;L=L.normalizeToRef(h.cr[0]);const j=p.ai;return j[0]=L._x*L._x*n+i,j[1]=L._x*L._y*n-L._z*J,j[2]=L._x*L._z*n+L._y*J,j[3]=0,j[4]=L._y*L._x*n+L._z*J,j[5]=L._y*L._y*n+i,j[6]=L._y*L._z*n-L._x*J,j[7]=0,j[8]=L._z*L._x*n-L._y*J,j[9]=L._z*L._y*n+L._x*J,j[10]=L._z*L._z*n+i,j[11]=0,j[12]=0,j[13]=0,j[14]=0,j[15]=1,p.markAsUpdated(),p}static RotationAlignToRef(L,r,p){let i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const n=b.Dot(r,L),j=p.ai;if(n<-1+J.d)j[0]=-1,j[1]=0,j[2]=0,j[3]=0,j[4]=0,j[5]=i?1:-1,j[6]=0,j[7]=0,j[8]=0,j[9]=0,j[10]=i?-1:1,j[11]=0;else{const p=b.Cross(r,L),J=1/(1+n);j[0]=p._x*p._x*J+n,j[1]=p._y*p._x*J-p._z,j[2]=p._z*p._x*J+p._y,j[3]=0,j[4]=p._x*p._y*J+p._z,j[5]=p._y*p._y*J+n,j[6]=p._z*p._y*J-p._x,j[7]=0,j[8]=p._x*p._z*J-p._y,j[9]=p._y*p._z*J+p._x,j[10]=p._z*p._z*J+n,j[11]=0}return j[12]=0,j[13]=0,j[14]=0,j[15]=1,p.markAsUpdated(),p}static RotationYawPitchRoll(L,r,p){const J=new O;return O.RotationYawPitchRollToRef(L,r,p,J),J}static RotationYawPitchRollToRef(L,r,p,J){return P.RotationYawPitchRollToRef(L,r,p,h.Quaternion[0]),h.Quaternion[0].toRotationMatrix(J),J}static Scaling(L,r,p){const J=new O;return O.ScalingToRef(L,r,p,J),J}static ScalingToRef(L,r,p,J){return O.FromValuesToRef(L,0,0,0,0,r,0,0,0,0,p,0,0,0,0,1,J),J._updateIdentityStatus(1===L&&1===r&&1===p),J}static Translation(L,r,p){const J=new O;return O.TranslationToRef(L,r,p,J),J}static TranslationToRef(L,r,p,J){return O.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,L,r,p,1,J),J._updateIdentityStatus(0===L&&0===r&&0===p),J}static Lerp(L,r,p){const J=new O;return O.LerpToRef(L,r,p,J),J}static LerpToRef(L,r,p,J){const i=J.ai,n=L.m,j=r.m;for(let z=0;z<16;z++)i[z]=n[z]*(1-p)+j[z]*p;return J.markAsUpdated(),J}static DecomposeLerp(L,r,p){const J=new O;return O.DecomposeLerpToRef(L,r,p,J),J}static DecomposeLerpToRef(L,r,p,J){const i=h.cr[0],n=h.Quaternion[0],j=h.cr[1];L.decompose(i,n,j);const z=h.cr[2],G=h.Quaternion[1],C=h.cr[3];r.decompose(z,G,C);const t=h.cr[4];b.LerpToRef(i,z,p,t);const E=h.Quaternion[2];P.SlerpToRef(n,G,p,E);const x=h.cr[5];return b.LerpToRef(j,C,p,x),O.ComposeToRef(t,E,x,J),J}static LookAtLH(L,r,p){const J=new O;return O.LookAtLHToRef(L,r,p,J),J}static LookAtLHToRef(L,r,p,J){const i=h.cr[0],n=h.cr[1],j=h.cr[2];r.subtractToRef(L,j),j.normalize(),b.CrossToRef(p,j,i);const z=i.lengthSquared();0===z?i.x=1:i.normalizeFromLength(Math.sqrt(z)),b.CrossToRef(j,i,n),n.normalize();const G=-b.Dot(i,L),C=-b.Dot(n,L),t=-b.Dot(j,L);return O.FromValuesToRef(i._x,n._x,j._x,0,i._y,n._y,j._y,0,i._z,n._z,j._z,0,G,C,t,1,J),J}static LookAtRH(L,r,p){const J=new O;return O.LookAtRHToRef(L,r,p,J),J}static LookAtRHToRef(L,r,p,J){const i=h.cr[0],n=h.cr[1],j=h.cr[2];L.subtractToRef(r,j),j.normalize(),b.CrossToRef(p,j,i);const z=i.lengthSquared();0===z?i.x=1:i.normalizeFromLength(Math.sqrt(z)),b.CrossToRef(j,i,n),n.normalize();const G=-b.Dot(i,L),C=-b.Dot(n,L),t=-b.Dot(j,L);return O.FromValuesToRef(i._x,n._x,j._x,0,i._y,n._y,j._y,0,i._z,n._z,j._z,0,G,C,t,1,J),J}static LookDirectionLH(L,r){const p=new O;return O.LookDirectionLHToRef(L,r,p),p}static LookDirectionLHToRef(L,r,p){const J=h.cr[0];J.G(L),J.scaleInPlace(-1);const i=h.cr[1];return b.CrossToRef(r,J,i),O.FromValuesToRef(i._x,i._y,i._z,0,r._x,r._y,r._z,0,J._x,J._y,J._z,0,0,0,0,1,p),p}static LookDirectionRH(L,r){const p=new O;return O.LookDirectionRHToRef(L,r,p),p}static LookDirectionRHToRef(L,r,p){const J=h.cr[2];return b.CrossToRef(r,L,J),O.FromValuesToRef(J._x,J._y,J._z,0,r._x,r._y,r._z,0,L._x,L._y,L._z,0,0,0,0,1,p),p}static OrthoLH(L,r,p,J,i){const n=new O;return O.OrthoLHToRef(L,r,p,J,n,i),n}static OrthoLHToRef(L,r,p,J,i,n){const j=2/L,z=2/r,G=2/(J-p),C=-(J+p)/(J-p);return O.FromValuesToRef(j,0,0,0,0,z,0,0,0,0,G,0,0,0,C,1,i),n&&i.multiplyToRef(W,i),i._updateIdentityStatus(1===j&&1===z&&1===G&&0===C),i}static OrthoOffCenterLH(L,r,p,J,i,n,j){const z=new O;return O.OrthoOffCenterLHToRef(L,r,p,J,i,n,z,j),z}static OrthoOffCenterLHToRef(L,r,p,J,i,n,j,z){const G=2/(r-L),C=2/(J-p),t=2/(n-i),E=-(n+i)/(n-i),x=(L+r)/(L-r),w=(J+p)/(p-J);return O.FromValuesToRef(G,0,0,0,0,C,0,0,0,0,t,0,x,w,E,1,j),z&&j.multiplyToRef(W,j),j.markAsUpdated(),j}static ObliqueOffCenterLHToRef(L,r,p,J,i,n,j,z,G,C,t){const E=-j*Math.cos(z),x=-j*Math.sin(z);return O.TranslationToRef(0,0,-G,h.Matrix[1]),O.FromValuesToRef(1,0,0,0,0,1,0,0,E,x,1,0,0,0,0,1,h.Matrix[0]),h.Matrix[1].multiplyToRef(h.Matrix[0],h.Matrix[0]),O.TranslationToRef(0,0,G,h.Matrix[1]),h.Matrix[0].multiplyToRef(h.Matrix[1],h.Matrix[0]),O.OrthoOffCenterLHToRef(L,r,p,J,i,n,C,t),h.Matrix[0].multiplyToRef(C,C),C}static OrthoOffCenterRH(L,r,p,J,i,n,j){const z=new O;return O.OrthoOffCenterRHToRef(L,r,p,J,i,n,z,j),z}static OrthoOffCenterRHToRef(L,r,p,J,i,n,j,z){return O.OrthoOffCenterLHToRef(L,r,p,J,i,n,j,z),j.ai[10]*=-1,j}static ObliqueOffCenterRHToRef(L,r,p,J,i,n,j,z,G,C,t){const E=j*Math.cos(z),x=j*Math.sin(z);return O.TranslationToRef(0,0,G,h.Matrix[1]),O.FromValuesToRef(1,0,0,0,0,1,0,0,E,x,1,0,0,0,0,1,h.Matrix[0]),h.Matrix[1].multiplyToRef(h.Matrix[0],h.Matrix[0]),O.TranslationToRef(0,0,-G,h.Matrix[1]),h.Matrix[0].multiplyToRef(h.Matrix[1],h.Matrix[0]),O.OrthoOffCenterRHToRef(L,r,p,J,i,n,C,t),h.Matrix[0].multiplyToRef(C,C),C}static PerspectiveLH(L,r,p,J,i){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const j=new O,z=2*p/L,G=2*p/r,C=(J+p)/(J-p),t=-2*J*p/(J-p),E=Math.tan(n);return O.FromValuesToRef(z,0,0,0,0,G,0,E,0,0,C,1,0,0,t,0,j),i&&j.multiplyToRef(W,j),j._updateIdentityStatus(!1),j}static PerspectiveFovLH(L,r,p,J,i){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,j=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const z=new O;return O.PerspectiveFovLHToRef(L,r,p,J,z,!0,i,n,j),z}static PerspectiveFovLHToRef(L,r,p,J,i){let n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],j=arguments.length>6?arguments[6]:void 0,z=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,G=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const C=p,t=J,E=1/Math.tan(.5*L),x=n?E/r:E,w=n?E:E*r,g=G&&0===C?-1:0!==t?(t+C)/(t-C):1,b=G&&0===C?2*t:0!==t?-2*t*C/(t-C):-2*C,c=Math.tan(z);return O.FromValuesToRef(x,0,0,0,0,w,0,c,0,0,g,1,0,0,b,0,i),j&&i.multiplyToRef(W,i),i._updateIdentityStatus(!1),i}static PerspectiveFovReverseLHToRef(L,r,p,J,i){let n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],j=arguments.length>6?arguments[6]:void 0,z=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const G=1/Math.tan(.5*L),C=n?G/r:G,t=n?G:G*r,E=Math.tan(z);return O.FromValuesToRef(C,0,0,0,0,t,0,E,0,0,-p,1,0,0,1,0,i),j&&i.multiplyToRef(W,i),i._updateIdentityStatus(!1),i}static PerspectiveFovRH(L,r,p,J,i){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,j=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const z=new O;return O.PerspectiveFovRHToRef(L,r,p,J,z,!0,i,n,j),z}static PerspectiveFovRHToRef(L,r,p,J,i){let n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],j=arguments.length>6?arguments[6]:void 0,z=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,G=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const C=p,t=J,E=1/Math.tan(.5*L),x=n?E/r:E,w=n?E:E*r,g=G&&0===C?1:0!==t?-(t+C)/(t-C):-1,b=G&&0===C?2*t:0!==t?-2*t*C/(t-C):-2*C,c=Math.tan(z);return O.FromValuesToRef(x,0,0,0,0,w,0,c,0,0,g,-1,0,0,b,0,i),j&&i.multiplyToRef(W,i),i._updateIdentityStatus(!1),i}static PerspectiveFovReverseRHToRef(L,r,p,J,i){let n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],j=arguments.length>6?arguments[6]:void 0,z=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const G=1/Math.tan(.5*L),C=n?G/r:G,t=n?G:G*r,E=Math.tan(z);return O.FromValuesToRef(C,0,0,0,0,t,0,E,0,0,-p,-1,0,0,-1,0,i),j&&i.multiplyToRef(W,i),i._updateIdentityStatus(!1),i}static GetFinalMatrix(L,r,p,J,i,n){const j=L.width,z=L.height,G=L.x,C=L.y,t=O.FromValues(j/2,0,0,0,0,-z/2,0,0,0,0,n-i,0,G+j/2,z/2+C,i,1),E=new O;return r.multiplyToRef(p,E),E.multiplyToRef(J,E),E.multiplyToRef(t,E)}static GetAsMatrix2x2(L){const r=L.m,p=[r[0],r[1],r[4],r[5]];return j.e.MatrixUse64Bits?p:new Float32Array(p)}static GetAsMatrix3x3(L){const r=L.m,p=[r[0],r[1],r[2],r[4],r[5],r[6],r[8],r[9],r[10]];return j.e.MatrixUse64Bits?p:new Float32Array(p)}static Transpose(L){const r=new O;return O.TransposeToRef(L,r),r}static TransposeToRef(L,r){const p=L.m,J=p[0],i=p[4],n=p[8],j=p[12],z=p[1],G=p[5],C=p[9],t=p[13],E=p[2],x=p[6],w=p[10],g=p[14],b=p[3],c=p[7],P=p[11],O=p[15],h=r.ai;return h[0]=J,h[1]=i,h[2]=n,h[3]=j,h[4]=z,h[5]=G,h[6]=C,h[7]=t,h[8]=E,h[9]=x,h[10]=w,h[11]=g,h[12]=b,h[13]=c,h[14]=P,h[15]=O,r.markAsUpdated(),r._updateIdentityStatus(L._isIdentity,L._isIdentityDirty),r}static Reflection(L){const r=new O;return O.ReflectionToRef(L,r),r}static ReflectionToRef(L,r){L.normalize();const p=L.normal.x,J=L.normal.y,i=L.normal.z,n=-2*p,j=-2*J,z=-2*i;return O.FromValuesToRef(n*p+1,j*p,z*p,0,n*J,j*J+1,z*J,0,n*i,j*i,z*i+1,0,n*L.d,j*L.d,z*L.d,1,r),r}static FromXYZAxesToRef(L,r,p,J){return O.FromValuesToRef(L._x,L._y,L._z,0,r._x,r._y,r._z,0,p._x,p._y,p._z,0,0,0,0,1,J),J}static FromQuaternionToRef(L,r){const p=L._x*L._x,J=L._y*L._y,i=L._z*L._z,n=L._x*L._y,j=L._z*L._w,z=L._z*L._x,G=L._y*L._w,C=L._y*L._z,t=L._x*L._w;return r.ai[0]=1-2*(J+i),r.ai[1]=2*(n+j),r.ai[2]=2*(z-G),r.ai[3]=0,r.ai[4]=2*(n-j),r.ai[5]=1-2*(i+p),r.ai[6]=2*(C+t),r.ai[7]=0,r.ai[8]=2*(z+G),r.ai[9]=2*(C-t),r.ai[10]=1-2*(J+p),r.ai[11]=0,r.ai[12]=0,r.ai[13]=0,r.ai[14]=0,r.ai[15]=1,r.markAsUpdated(),r}}O._IdentityReadOnly=O.Identity(),Object.defineProperties(O.prototype,{dimension:{value:[4,4]},rank:{value:2}});class h{}h.cr=(0,i.i)(11,b.Zero),h.Matrix=(0,i.i)(2,O.Identity),h.Quaternion=(0,i.i)(3,P.Zero);class U{}U.Vector2=(0,i.i)(3,g.Zero),U.cr=(0,i.i)(13,b.Zero),U.Vector4=(0,i.i)(3,c.Zero),U.Quaternion=(0,i.i)(3,P.Zero),U.Matrix=(0,i.i)(8,O.Identity),(0,n.e)("BABYLON.Vector2",g),(0,n.e)("BABYLON.Vector3",b),(0,n.e)("BABYLON.Vector4",c),(0,n.e)("BABYLON.Matrix",O);const W=O.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12149:(L,r,p)=>{function J(L,r){const p=[];for(let J=0;J<L;++J)p.push(r());return p}function i(L,r){return J(L,r)}p.d(r,{e:()=>J,i:()=>i,j:()=>j});const n=["push","splice","pop","shift","unshift"];function j(L,r){const p=n.map((p=>function(L,r,p){const J=L[r];if("function"!==typeof J)return null;const i=function(){const J=L.length,n=i.previous.apply(L,arguments);return p(r,J),n};return J.next=i,i.previous=J,L[r]=i,()=>{const p=i.previous;if(!p)return;const J=i.next;J?(p.next=J,J.previous=p):(p.next=void 0,L[r]=p),i.next=void 0,i.previous=void 0}}(L,p,r)));return()=>{for(const L of p)null===L||void 0===L||L()}}}}]);