"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[14],{12377:(M,Z,P)=>{P.d(Z,{c:()=>v,d:()=>w,f:()=>x,g:()=>c});const x=1/2.2,c=2.2,w=(1+Math.sqrt(5))/2,v=.001},12387:(M,Z,P)=>{function x(M){return parseInt(M.toString().replace(/\W/g,""))}function c(M,Z){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(M-Z)<=P}function w(M,Z,P){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return M<Z-x||M>P+x}function v(M,Z){return M===Z?M:Math.random()*(Z-M)+M}function G(M,Z,P){return M+(Z-M)*P}function mM(M,Z,P){let x=n(Z-M,360);return x>180&&(x-=360),M+x*H(P)}function K(M,Z,P){let x=0;return x=M!=Z?H((P-M)/(Z-M)):0,x}function d(M,Z,P,x,c){const w=c*c,v=c*w;return M*(2*v-3*w+1)+P*(-2*v+3*w)+Z*(v-2*w+c)+x*(v-w)}function O(M,Z,P,x,c){const w=c*c;return 6*(w-c)*M+(3*w-4*c+1)*Z+6*(-w+c)*P+(3*w-2*c)*x}function H(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(P,Math.max(Z,M))}function j(M){return M-=2*Math.PI*Math.floor((M+Math.PI)/(2*Math.PI))}function B(M){const Z=M.toString(16);return M<=15?("0"+Z).toUpperCase():Z.toUpperCase()}function U(M){if(Math.log2)return Math.floor(Math.log2(M));if(M<0)return NaN;if(0===M)return-1/0;let Z=0;if(M<1){for(;M<1;)Z++,M*=2;Z=-Z}else if(M>1)for(;M>1;)Z++,M=Math.floor(M/2);return Z}function n(M,Z){return M-Math.floor(M/Z)*Z}function L(M,Z,P){return(M-Z)/(P-Z)}function u(M,Z,P){return M*(P-Z)+Z}function N(M,Z){let P=n(Z-M,360);return P>180&&(P-=360),P}function J(M,Z){const P=n(M,2*Z);return Z-Math.abs(P-Z)}function t(M,Z,P){let x=H(P);return x=-2*x*x*x+3*x*x,Z*x+M*(1-x)}function F(M,Z,P){let x=0;return x=Math.abs(Z-M)<=P?Z:M+Math.sign(Z-M)*P,x}function D(M,Z,P){const x=N(M,Z);let c=0;return c=-P<x&&x<P?Z:F(M,Z=M+x,P),c}function l(M,Z,P){return(M-Z)/(P-Z)}function h(M,Z,P){return(P-Z)*M+Z}function Q(M,Z){const P=M%Z;return 0===P?Z:Q(Z,P)}P.r(Z),P.d(Z,{Clamp:()=>H,DeltaAngle:()=>N,Denormalize:()=>u,ExtractAsInt:()=>x,Hermite:()=>d,Hermite1stDerivative:()=>O,HighestCommonFactor:()=>Q,ILog2:()=>U,InverseLerp:()=>K,Lerp:()=>G,LerpAngle:()=>mM,MoveTowards:()=>F,MoveTowardsAngle:()=>D,Normalize:()=>L,NormalizeRadians:()=>j,OutsideRange:()=>w,PercentToRange:()=>h,PingPong:()=>J,RandomRange:()=>v,RangeToPercent:()=>l,Repeat:()=>n,SmoothStep:()=>t,ToHex:()=>B,WithinEpsilon:()=>c})},12373:(M,Z,P)=>{P.r(Z),P.d(Z,{Matrix:()=>u,Quaternion:()=>L,TmpVectors:()=>J,Vector2:()=>B,BZ:()=>U,Vector4:()=>n});var x=P(12377),c=P(12379),w=P(12317),v=P(12282),G=P(12225),mM=P(12387);class K{}function d(M,Z,P){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const c=M.nc(),w=Z.nc(),v=c[0],G=c[1],mM=c[2],K=c[3],d=c[4],O=c[5],H=c[6],j=c[7],B=c[8],U=c[9],n=c[10],L=c[11],u=c[12],N=c[13],J=c[14],t=c[15],F=w[0],D=w[1],l=w[2],h=w[3],Q=w[4],I=w[5],s=w[6],C=w[7],R=w[8],W=w[9],k=w[10],A=w[11],o=w[12],E=w[13],r=w[14],q=w[15];P[x]=v*F+G*Q+mM*R+K*o,P[x+1]=v*D+G*I+mM*W+K*E,P[x+2]=v*l+G*s+mM*k+K*r,P[x+3]=v*h+G*C+mM*A+K*q,P[x+4]=d*F+O*Q+H*R+j*o,P[x+5]=d*D+O*I+H*W+j*E,P[x+6]=d*l+O*s+H*k+j*r,P[x+7]=d*h+O*C+H*A+j*q,P[x+8]=B*F+U*Q+n*R+L*o,P[x+9]=B*D+U*I+n*W+L*E,P[x+10]=B*l+U*s+n*k+L*r,P[x+11]=B*h+U*C+n*A+L*q,P[x+12]=u*F+N*Q+J*R+t*o,P[x+13]=u*D+N*I+J*W+t*E,P[x+14]=u*l+N*s+J*k+t*r,P[x+15]=u*h+N*C+J*A+t*q}function O(M,Z){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const x=M.nc();Z[P]=x[0],Z[P+1]=x[1],Z[P+2]=x[2],Z[P+3]=x[3],Z[P+4]=x[4],Z[P+5]=x[5],Z[P+6]=x[6],Z[P+7]=x[7],Z[P+8]=x[8],Z[P+9]=x[9],Z[P+10]=x[10],Z[P+11]=x[11],Z[P+12]=x[12],Z[P+13]=x[13],Z[P+14]=x[14],Z[P+15]=x[15]}function H(M,Z){const P=M.nc(),x=P[0],c=P[1],w=P[2],v=P[3],G=P[4],mM=P[5],K=P[6],d=P[7],O=P[8],H=P[9],j=P[10],B=P[11],U=P[12],n=P[13],L=P[14],u=P[15],N=j*u-L*B,J=H*u-n*B,t=H*L-n*j,F=O*u-U*B,D=O*L-j*U,l=O*n-U*H,h=+(mM*N-K*J+d*t),Q=-(G*N-K*F+d*D),I=+(G*J-mM*F+d*l),s=-(G*t-mM*D+K*l),C=x*h+c*Q+w*I+v*s;if(0===C)return!1;const R=1/C,W=K*u-L*d,k=mM*u-n*d,A=mM*L-n*K,o=G*u-U*d,E=G*L-U*K,r=G*n-U*mM,q=K*B-j*d,e=mM*B-H*d,b=mM*j-H*K,a=G*B-O*d,y=G*j-O*K,f=G*H-O*mM,Y=-(c*N-w*J+v*t),z=+(x*N-w*F+v*D),i=-(x*J-c*F+v*l),T=+(x*t-c*D+w*l),p=+(c*W-w*k+v*A),S=-(x*W-w*o+v*E),X=+(x*k-c*o+v*r),V=-(x*A-c*E+w*r),g=-(c*q-w*e+v*b),MM=+(x*q-w*a+v*y),ZM=-(x*e-c*a+v*f),PM=+(x*b-c*y+w*f);return Z[0]=h*R,Z[1]=Y*R,Z[2]=p*R,Z[3]=g*R,Z[4]=Q*R,Z[5]=z*R,Z[6]=S*R,Z[7]=MM*R,Z[8]=I*R,Z[9]=i*R,Z[10]=X*R,Z[11]=ZM*R,Z[12]=s*R,Z[13]=T*R,Z[14]=V*R,Z[15]=PM*R,!0}K._UpdateFlagSeed=0;const j=M=>parseInt(M.toString().replace(/\W/g,""));class B{constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=M,this.y=Z}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let M=j(this.x);return M=397*M^j(this.y),M}toArray(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[Z]=this.x,M[Z+1]=this.y,this}jP(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B.FromArrayToRef(M,Z,this),this}nc(){return[this.x,this.y]}v(M){return this.x=M.x,this.y=M.y,this}lc(M,Z){return this.x=M,this.y=Z,this}set(M,Z){return this.lc(M,Z)}Qc(M){return this.lc(M,M)}add(M){return new B(this.x+M.x,this.y+M.y)}addToRef(M,Z){return Z.x=this.x+M.x,Z.y=this.y+M.y,Z}addInPlace(M){return this.x+=M.x,this.y+=M.y,this}addInPlaceFromFloats(M,Z){return this.x+=M,this.y+=Z,this}addVector3(M){return new B(this.x+M.x,this.y+M.y)}UZ(M){return new B(this.x-M.x,this.y-M.y)}subtractToRef(M,Z){return Z.x=this.x-M.x,Z.y=this.y-M.y,Z}MH(M){return this.x-=M.x,this.y-=M.y,this}multiplyInPlace(M){return this.x*=M.x,this.y*=M.y,this}multiply(M){return new B(this.x*M.x,this.y*M.y)}multiplyToRef(M,Z){return Z.x=this.x*M.x,Z.y=this.y*M.y,Z}multiplyByFloats(M,Z){return new B(this.x*M,this.y*Z)}divide(M){return new B(this.x/M.x,this.y/M.y)}divideToRef(M,Z){return Z.x=this.x/M.x,Z.y=this.y/M.y,Z}divideInPlace(M){return this.x=this.x/M.x,this.y=this.y/M.y,this}minimizeInPlace(M){return this.minimizeInPlaceFromFloats(M.x,M.y)}maximizeInPlace(M){return this.maximizeInPlaceFromFloats(M.x,M.y)}minimizeInPlaceFromFloats(M,Z){return this.x=Math.min(M,this.x),this.y=Math.min(Z,this.y),this}maximizeInPlaceFromFloats(M,Z){return this.x=Math.max(M,this.x),this.y=Math.max(Z,this.y),this}subtractFromFloats(M,Z){return new B(this.x-M,this.y-Z)}subtractFromFloatsToRef(M,Z,P){return P.x=this.x-M,P.y=this.y-Z,P}negate(){return new B(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(M){return M.x=-this.x,M.y=-this.y,M}scaleInPlace(M){return this.x*=M,this.y*=M,this}scale(M){return new B(this.x*M,this.y*M)}scaleToRef(M,Z){return Z.x=this.x*M,Z.y=this.y*M,Z}scaleAndAddToRef(M,Z){return Z.x+=this.x*M,Z.y+=this.y*M,Z}equals(M){return M&&this.x===M.x&&this.y===M.y}equalsWithEpsilon(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:x.c;return M&&(0,mM.WithinEpsilon)(this.x,M.x,Z)&&(0,mM.WithinEpsilon)(this.y,M.y,Z)}equalsToFloats(M,Z){return this.x===M&&this.y===Z}floor(){return new B(Math.floor(this.x),Math.floor(this.y))}floorToRef(M){return M.x=Math.floor(this.x),M.y=Math.floor(this.y),M}fract(){return new B(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(M){return M.x=this.x-Math.floor(this.x),M.y=this.y-Math.floor(this.y),M}rotate(M){return this.rotateToRef(M,new B)}rotateToRef(M,Z){const P=Math.cos(M),x=Math.sin(M);return Z.x=P*this.x-x*this.y,Z.y=x*this.x+P*this.y,Z}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){const M=new B;return this.normalizeToRef(M),M}normalizeToRef(M){const Z=this.length();return 0===Z&&(M.x=this.x,M.y=this.y),this.scaleToRef(1/Z,M)}clone(){return new B(this.x,this.y)}dot(M){return this.x*M.x+this.y*M.y}static Zero(){return new B(0,0)}static One(){return new B(1,1)}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new B((0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).lc((0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z))}static get ZeroReadOnly(){return B._ZeroReadOnly}static NZ(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new B(M[Z],M[Z+1])}static FromArrayToRef(M,Z,P){return P.x=M[Z],P.y=M[Z+1],P}static FromFloatsToRef(M,Z,P){return P.lc(M,Z),P}static CatmullRom(M,Z,P,x,c){const w=c*c,v=c*w,G=.5*(2*Z.x+(-M.x+P.x)*c+(2*M.x-5*Z.x+4*P.x-x.x)*w+(-M.x+3*Z.x-3*P.x+x.x)*v),mM=.5*(2*Z.y+(-M.y+P.y)*c+(2*M.y-5*Z.y+4*P.y-x.y)*w+(-M.y+3*Z.y-3*P.y+x.y)*v);return new B(G,mM)}static ClampToRef(M,Z,P,x){return x.x=(0,mM.Clamp)(M.x,Z.x,P.x),x.y=(0,mM.Clamp)(M.y,Z.y,P.y),x}static Clamp(M,Z,P){const x=(0,mM.Clamp)(M.x,Z.x,P.x),c=(0,mM.Clamp)(M.y,Z.y,P.y);return new B(x,c)}static Hermite(M,Z,P,x,c){const w=c*c,v=c*w,G=2*v-3*w+1,mM=-2*v+3*w,K=v-2*w+c,d=v-w,O=M.x*G+P.x*mM+Z.x*K+x.x*d,H=M.y*G+P.y*mM+Z.y*K+x.y*d;return new B(O,H)}static Hermite1stDerivative(M,Z,P,x,c){return this.Hermite1stDerivativeToRef(M,Z,P,x,c,new B)}static Hermite1stDerivativeToRef(M,Z,P,x,c,w){const v=c*c;return w.x=6*(v-c)*M.x+(3*v-4*c+1)*Z.x+6*(-v+c)*P.x+(3*v-2*c)*x.x,w.y=6*(v-c)*M.y+(3*v-4*c+1)*Z.y+6*(-v+c)*P.y+(3*v-2*c)*x.y,w}static Lerp(M,Z,P){return B.LerpToRef(M,Z,P,new B)}static LerpToRef(M,Z,P,x){return x.x=M.x+(Z.x-M.x)*P,x.y=M.y+(Z.y-M.y)*P,x}static Dot(M,Z){return M.x*Z.x+M.y*Z.y}static Normalize(M){return B.NormalizeToRef(M,new B)}static NormalizeToRef(M,Z){return M.normalizeToRef(Z),Z}static Minimize(M,Z){const P=M.x<Z.x?M.x:Z.x,x=M.y<Z.y?M.y:Z.y;return new B(P,x)}static Maximize(M,Z){const P=M.x>Z.x?M.x:Z.x,x=M.y>Z.y?M.y:Z.y;return new B(P,x)}static Transform(M,Z){return B.TransformToRef(M,Z,new B)}static TransformToRef(M,Z,P){const x=Z.m,c=M.x*x[0]+M.y*x[4]+x[12],w=M.x*x[1]+M.y*x[5]+x[13];return P.x=c,P.y=w,P}static PointInTriangle(M,Z,P,x){const c=.5*(-P.y*x.x+Z.y*(-P.x+x.x)+Z.x*(P.y-x.y)+P.x*x.y),w=c<0?-1:1,v=(Z.y*x.x-Z.x*x.y+(x.y-Z.y)*M.x+(Z.x-x.x)*M.y)*w,G=(Z.x*P.y-Z.y*P.x+(Z.y-P.y)*M.x+(P.x-Z.x)*M.y)*w;return v>0&&G>0&&v+G<2*c*w}static Distance(M,Z){return Math.sqrt(B.DistanceSquared(M,Z))}static DistanceSquared(M,Z){const P=M.x-Z.x,x=M.y-Z.y;return P*P+x*x}static Center(M,Z){return B.CenterToRef(M,Z,new B)}static CenterToRef(M,Z,P){return P.lc((M.x+Z.x)/2,(M.y+Z.y)/2)}static DistanceOfPointFromSegment(M,Z,P){const x=B.DistanceSquared(Z,P);if(0===x)return B.Distance(M,Z);const c=P.UZ(Z),w=Math.max(0,Math.min(1,B.Dot(M.UZ(Z),c)/x)),v=Z.add(c.multiplyByFloats(w,w));return B.Distance(M,v)}}B._V8PerformanceHack=new B(.5,.5),B._ZeroReadOnly=B.Zero(),Object.defineProperties(B.prototype,{dimension:{value:[2]},rank:{value:1}});class U{get x(){return this._x}set x(M){this._x=M,this._isDirty=!0}get y(){return this._y}set y(M){this._y=M,this._isDirty=!0}get z(){return this._z}set z(M){this._z=M,this._isDirty=!0}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=M,this._y=Z,this._z=P}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"BZ"}getHashCode(){let M=j(this._x);return M=397*M^j(this._y),M=397*M^j(this._z),M}nc(){return[this._x,this._y,this._z]}toArray(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[Z]=this._x,M[Z+1]=this._y,M[Z+2]=this._z,this}jP(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U.FromArrayToRef(M,Z,this),this}toQuaternion(){return L.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(M){return this._x+=M._x,this._y+=M._y,this._z+=M._z,this._isDirty=!0,this}addInPlaceFromFloats(M,Z,P){return this._x+=M,this._y+=Z,this._z+=P,this._isDirty=!0,this}add(M){return new U(this._x+M._x,this._y+M._y,this._z+M._z)}addToRef(M,Z){return Z._x=this._x+M._x,Z._y=this._y+M._y,Z._z=this._z+M._z,Z._isDirty=!0,Z}MH(M){return this._x-=M._x,this._y-=M._y,this._z-=M._z,this._isDirty=!0,this}UZ(M){return new U(this._x-M._x,this._y-M._y,this._z-M._z)}subtractToRef(M,Z){return this.subtractFromFloatsToRef(M._x,M._y,M._z,Z)}subtractFromFloats(M,Z,P){return new U(this._x-M,this._y-Z,this._z-P)}subtractFromFloatsToRef(M,Z,P,x){return x._x=this._x-M,x._y=this._y-Z,x._z=this._z-P,x._isDirty=!0,x}negate(){return new U(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(M){return M._x=-1*this._x,M._y=-1*this._y,M._z=-1*this._z,M._isDirty=!0,M}scaleInPlace(M){return this._x*=M,this._y*=M,this._z*=M,this._isDirty=!0,this}scale(M){return new U(this._x*M,this._y*M,this._z*M)}scaleToRef(M,Z){return Z._x=this._x*M,Z._y=this._y*M,Z._z=this._z*M,Z._isDirty=!0,Z}getNormalToRef(M){const Z=this.length();let P=Math.acos(this._y/Z);const x=Math.atan2(this._z,this._x);P>Math.PI/2?P-=Math.PI/2:P+=Math.PI/2;const c=Z*Math.sin(P)*Math.cos(x),w=Z*Math.cos(P),v=Z*Math.sin(P)*Math.sin(x);return M.set(c,w,v),M}applyRotationQuaternionToRef(M,Z){const P=this._x,x=this._y,c=this._z,w=M._x,v=M._y,G=M._z,mM=M._w,K=2*(v*c-G*x),d=2*(G*P-w*c),O=2*(w*x-v*P);return Z._x=P+mM*K+v*O-G*d,Z._y=x+mM*d+G*K-w*O,Z._z=c+mM*O+w*d-v*K,Z._isDirty=!0,Z}applyRotationQuaternionInPlace(M){return this.applyRotationQuaternionToRef(M,this)}applyRotationQuaternion(M){return this.applyRotationQuaternionToRef(M,new U)}scaleAndAddToRef(M,Z){return Z._x+=this._x*M,Z._y+=this._y*M,Z._z+=this._z*M,Z._isDirty=!0,Z}projectOnPlane(M,Z){return this.projectOnPlaneToRef(M,Z,new U)}projectOnPlaneToRef(M,Z,P){const x=M.normal,c=M.d,w=N.BZ[0];this.subtractToRef(Z,w),w.normalize();const v=U.Dot(w,x);if(Math.abs(v)<1e-10)P.Qc(1/0);else{const M=-(U.Dot(Z,x)+c)/v,G=w.scaleInPlace(M);Z.addToRef(G,P)}return P}equals(M){return M&&this._x===M._x&&this._y===M._y&&this._z===M._z}equalsWithEpsilon(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:x.c;return M&&(0,mM.WithinEpsilon)(this._x,M._x,Z)&&(0,mM.WithinEpsilon)(this._y,M._y,Z)&&(0,mM.WithinEpsilon)(this._z,M._z,Z)}equalsToFloats(M,Z,P){return this._x===M&&this._y===Z&&this._z===P}multiplyInPlace(M){return this._x*=M._x,this._y*=M._y,this._z*=M._z,this._isDirty=!0,this}multiply(M){return this.multiplyByFloats(M._x,M._y,M._z)}multiplyToRef(M,Z){return Z._x=this._x*M._x,Z._y=this._y*M._y,Z._z=this._z*M._z,Z._isDirty=!0,Z}multiplyByFloats(M,Z,P){return new U(this._x*M,this._y*Z,this._z*P)}divide(M){return new U(this._x/M._x,this._y/M._y,this._z/M._z)}divideToRef(M,Z){return Z._x=this._x/M._x,Z._y=this._y/M._y,Z._z=this._z/M._z,Z._isDirty=!0,Z}divideInPlace(M){return this._x=this._x/M._x,this._y=this._y/M._y,this._z=this._z/M._z,this._isDirty=!0,this}minimizeInPlace(M){return this.minimizeInPlaceFromFloats(M._x,M._y,M._z)}maximizeInPlace(M){return this.maximizeInPlaceFromFloats(M._x,M._y,M._z)}minimizeInPlaceFromFloats(M,Z,P){return M<this._x&&(this.x=M),Z<this._y&&(this.y=Z),P<this._z&&(this.z=P),this}maximizeInPlaceFromFloats(M,Z,P){return M>this._x&&(this.x=M),Z>this._y&&(this.y=Z),P>this._z&&(this.z=P),this}isNonUniformWithinEpsilon(M){const Z=Math.abs(this._x),P=Math.abs(this._y);if(!(0,mM.WithinEpsilon)(Z,P,M))return!0;const x=Math.abs(this._z);return!(0,mM.WithinEpsilon)(Z,x,M)||!(0,mM.WithinEpsilon)(P,x,M)}get isNonUniform(){const M=Math.abs(this._x);if(M!==Math.abs(this._y))return!0;return M!==Math.abs(this._z)}floorToRef(M){return M._x=Math.floor(this._x),M._y=Math.floor(this._y),M._z=Math.floor(this._z),M._isDirty=!0,M}floor(){return new U(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(M){return M._x=this._x-Math.floor(this._x),M._y=this._y-Math.floor(this._y),M._z=this._z-Math.floor(this._z),M._isDirty=!0,M}fract(){return new U(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(M){if("xyz"===(M=M.toLowerCase()))return this;const Z=N.BZ[0].v(this);return this.x=Z[M[0]],this.y=Z[M[1]],this.z=Z[M[2]],this}rotateByQuaternionToRef(M,Z){return M.toRotationMatrix(N.Matrix[0]),U.TransformCoordinatesToRef(this,N.Matrix[0],Z),Z}rotateByQuaternionAroundPointToRef(M,Z,P){return this.subtractToRef(Z,N.BZ[0]),N.BZ[0].rotateByQuaternionToRef(M,N.BZ[0]),Z.addToRef(N.BZ[0],P),P}cross(M){return U.CrossToRef(this,M,new U)}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){return this.normalizeToRef(new U)}normalizeToRef(M){const Z=this.length();return 0===Z||1===Z?(M._x=this._x,M._y=this._y,M._z=this._z,M._isDirty=!0,M):this.scaleToRef(1/Z,M)}clone(){return new U(this._x,this._y,this._z)}v(M){return this.lc(M._x,M._y,M._z)}lc(M,Z,P){return this._x=M,this._y=Z,this._z=P,this._isDirty=!0,this}set(M,Z,P){return this.lc(M,Z,P)}Qc(M){return this._x=this._y=this._z=M,this._isDirty=!0,this}static GetClipFactor(M,Z,P,x){const c=U.Dot(M,P);return(c-x)/(c-U.Dot(Z,P))}static GetAngleBetweenVectors(M,Z,P){const x=M.normalizeToRef(N.BZ[1]),c=Z.normalizeToRef(N.BZ[2]);let w=U.Dot(x,c);w=(0,mM.Clamp)(w,-1,1);const v=Math.acos(w),G=N.BZ[3];return U.CrossToRef(x,c,G),U.Dot(G,P)>0?isNaN(v)?0:v:isNaN(v)?-Math.PI:-Math.acos(w)}static GetAngleBetweenVectorsOnPlane(M,Z,P){N.BZ[0].v(M);const x=N.BZ[0];N.BZ[1].v(Z);const c=N.BZ[1];N.BZ[2].v(P);const w=N.BZ[2],v=N.BZ[3],G=N.BZ[4];x.normalize(),c.normalize(),w.normalize(),U.CrossToRef(w,x,v),U.CrossToRef(v,w,G);const K=Math.atan2(U.Dot(c,v),U.Dot(c,G));return(0,mM.NormalizeRadians)(K)}static PitchYawRollToMoveBetweenPointsToRef(M,Z,P){const x=J.BZ[0];return Z.subtractToRef(M,x),P._y=Math.atan2(x.x,x.z)||0,P._x=Math.atan2(Math.sqrt(x.x**2+x.z**2),x.y)||0,P._z=0,P._isDirty=!0,P}static PitchYawRollToMoveBetweenPoints(M,Z){const P=U.Zero();return U.PitchYawRollToMoveBetweenPointsToRef(M,Z,P)}static SlerpToRef(M,Z,P,c){P=(0,mM.Clamp)(P,0,1);const w=N.BZ[0],v=N.BZ[1];w.v(M);const G=w.length();w.normalizeFromLength(G),v.v(Z);const K=v.length();v.normalizeFromLength(K);const d=U.Dot(w,v);let O,H;if(d<1-x.c){const M=Math.acos(d),Z=1/Math.sin(M);O=Math.sin((1-P)*M)*Z,H=Math.sin(P*M)*Z}else O=1-P,H=P;return w.scaleInPlace(O),v.scaleInPlace(H),c.v(w).addInPlace(v),c.scaleInPlace((0,mM.Lerp)(G,K,P)),c}static SmoothToRef(M,Z,P,x,c){return U.SlerpToRef(M,Z,0===x?1:P/x,c),c}static NZ(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new U(M[Z],M[Z+1],M[Z+2])}static FromFloatArray(M,Z){return U.NZ(M,Z)}static FromArrayToRef(M,Z,P){return P._x=M[Z],P._y=M[Z+1],P._z=M[Z+2],P._isDirty=!0,P}static FromFloatArrayToRef(M,Z,P){return U.FromArrayToRef(M,Z,P)}static FromFloatsToRef(M,Z,P,x){return x.lc(M,Z,P),x}static Zero(){return new U(0,0,0)}static One(){return new U(1,1,1)}static Up(){return new U(0,1,0)}static get UpReadOnly(){return U._UpReadOnly}static get DownReadOnly(){return U._DownReadOnly}static get RightReadOnly(){return U._RightReadOnly}static get LeftReadOnly(){return U._LeftReadOnly}static get LeftHandedForwardReadOnly(){return U._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return U._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return U._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return U._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return U._ZeroReadOnly}static get OneReadOnly(){return U._OneReadOnly}static Down(){return new U(0,-1,0)}static Forward(){return new U(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new U(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new U(1,0,0)}static Left(){return new U(-1,0,0)}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new U((0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).lc((0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z))}static TransformCoordinates(M,Z){const P=U.Zero();return U.TransformCoordinatesToRef(M,Z,P),P}static TransformCoordinatesToRef(M,Z,P){return U.TransformCoordinatesFromFloatsToRef(M._x,M._y,M._z,Z,P),P}static TransformCoordinatesFromFloatsToRef(M,Z,P,x,c){const w=x.m,v=M*w[0]+Z*w[4]+P*w[8]+w[12],G=M*w[1]+Z*w[5]+P*w[9]+w[13],mM=M*w[2]+Z*w[6]+P*w[10]+w[14],K=1/(M*w[3]+Z*w[7]+P*w[11]+w[15]);return c._x=v*K,c._y=G*K,c._z=mM*K,c._isDirty=!0,c}static TransformNormal(M,Z){const P=U.Zero();return U.TransformNormalToRef(M,Z,P),P}static TransformNormalToRef(M,Z,P){return this.TransformNormalFromFloatsToRef(M._x,M._y,M._z,Z,P),P}static TransformNormalFromFloatsToRef(M,Z,P,x,c){const w=x.m;return c._x=M*w[0]+Z*w[4]+P*w[8],c._y=M*w[1]+Z*w[5]+P*w[9],c._z=M*w[2]+Z*w[6]+P*w[10],c._isDirty=!0,c}static CatmullRom(M,Z,P,x,c){const w=c*c,v=c*w,G=.5*(2*Z._x+(-M._x+P._x)*c+(2*M._x-5*Z._x+4*P._x-x._x)*w+(-M._x+3*Z._x-3*P._x+x._x)*v),mM=.5*(2*Z._y+(-M._y+P._y)*c+(2*M._y-5*Z._y+4*P._y-x._y)*w+(-M._y+3*Z._y-3*P._y+x._y)*v),K=.5*(2*Z._z+(-M._z+P._z)*c+(2*M._z-5*Z._z+4*P._z-x._z)*w+(-M._z+3*Z._z-3*P._z+x._z)*v);return new U(G,mM,K)}static Clamp(M,Z,P){const x=new U;return U.ClampToRef(M,Z,P,x),x}static ClampToRef(M,Z,P,x){let c=M._x;c=c>P._x?P._x:c,c=c<Z._x?Z._x:c;let w=M._y;w=w>P._y?P._y:w,w=w<Z._y?Z._y:w;let v=M._z;return v=v>P._z?P._z:v,v=v<Z._z?Z._z:v,x.lc(c,w,v),x}static CheckExtends(M,Z,P){Z.minimizeInPlace(M),P.maximizeInPlace(M)}static Hermite(M,Z,P,x,c){const w=c*c,v=c*w,G=2*v-3*w+1,mM=-2*v+3*w,K=v-2*w+c,d=v-w,O=M._x*G+P._x*mM+Z._x*K+x._x*d,H=M._y*G+P._y*mM+Z._y*K+x._y*d,j=M._z*G+P._z*mM+Z._z*K+x._z*d;return new U(O,H,j)}static Hermite1stDerivative(M,Z,P,x,c){const w=new U;return this.Hermite1stDerivativeToRef(M,Z,P,x,c,w),w}static Hermite1stDerivativeToRef(M,Z,P,x,c,w){const v=c*c;return w._x=6*(v-c)*M._x+(3*v-4*c+1)*Z._x+6*(-v+c)*P._x+(3*v-2*c)*x._x,w._y=6*(v-c)*M._y+(3*v-4*c+1)*Z._y+6*(-v+c)*P._y+(3*v-2*c)*x._y,w._z=6*(v-c)*M._z+(3*v-4*c+1)*Z._z+6*(-v+c)*P._z+(3*v-2*c)*x._z,w._isDirty=!0,w}static Lerp(M,Z,P){const x=new U(0,0,0);return U.LerpToRef(M,Z,P,x),x}static LerpToRef(M,Z,P,x){return x._x=M._x+(Z._x-M._x)*P,x._y=M._y+(Z._y-M._y)*P,x._z=M._z+(Z._z-M._z)*P,x._isDirty=!0,x}static Dot(M,Z){return M._x*Z._x+M._y*Z._y+M._z*Z._z}dot(M){return this._x*M._x+this._y*M._y+this._z*M._z}static Cross(M,Z){const P=new U;return U.CrossToRef(M,Z,P),P}static CrossToRef(M,Z,P){const x=M._y*Z._z-M._z*Z._y,c=M._z*Z._x-M._x*Z._z,w=M._x*Z._y-M._y*Z._x;return P.lc(x,c,w),P}static Normalize(M){const Z=U.Zero();return U.NormalizeToRef(M,Z),Z}static NormalizeToRef(M,Z){return M.normalizeToRef(Z),Z}static Project(M,Z,P,x){const c=new U;return U.ProjectToRef(M,Z,P,x,c),c}static ProjectToRef(M,Z,P,x,c){var w;const v=x.width,mM=x.height,K=x.x,d=x.y,O=N.Matrix[1],H=null===(w=G.b.LastCreatedEngine)||void 0===w?void 0:w.isNDCHalfZRange,j=H?1:.5,B=H?0:.5;u.FromValuesToRef(v/2,0,0,0,0,-mM/2,0,0,0,0,j,0,K+v/2,mM/2+d,B,1,O);const n=N.Matrix[0];return Z.multiplyToRef(P,n),n.multiplyToRef(O,n),U.TransformCoordinatesToRef(M,n,c),c}static Reflect(M,Z){return this.ReflectToRef(M,Z,new U)}static ReflectToRef(M,Z,P){const x=J.BZ[0];return x.v(Z).scaleInPlace(2*U.Dot(M,Z)),P.v(M).MH(x)}static _UnprojectFromInvertedMatrixToRef(M,Z,P){U.TransformCoordinatesToRef(M,Z,P);const x=Z.m,c=M._x*x[3]+M._y*x[7]+M._z*x[11]+x[15];return(0,mM.WithinEpsilon)(c,1)&&P.scaleInPlace(1/c),P}static UnprojectFromTransform(M,Z,P,x,c){return this.Unproject(M,Z,P,x,c,u.IdentityReadOnly)}static Unproject(M,Z,P,x,c,w){const v=new U;return U.UnprojectToRef(M,Z,P,x,c,w,v),v}static UnprojectToRef(M,Z,P,x,c,w,v){return U.UnprojectFloatsToRef(M._x,M._y,M._z,Z,P,x,c,w,v),v}static UnprojectFloatsToRef(M,Z,P,x,c,w,v,mM,K){var d;const O=N.Matrix[0];w.multiplyToRef(v,O),O.multiplyToRef(mM,O),O.invert();const H=N.BZ[0];return H.x=M/x*2-1,H.y=-(Z/c*2-1),null!==(d=G.b.LastCreatedEngine)&&void 0!==d&&d.isNDCHalfZRange?H.z=P:H.z=2*P-1,U._UnprojectFromInvertedMatrixToRef(H,O,K),K}static Minimize(M,Z){const P=new U;return P.v(M),P.minimizeInPlace(Z),P}static Maximize(M,Z){const P=new U;return P.v(M),P.maximizeInPlace(Z),P}static Distance(M,Z){return Math.sqrt(U.DistanceSquared(M,Z))}static DistanceSquared(M,Z){const P=M._x-Z._x,x=M._y-Z._y,c=M._z-Z._z;return P*P+x*x+c*c}static ProjectOnTriangleToRef(M,Z,P,c,w){const v=N.BZ[0],G=N.BZ[1],K=N.BZ[2],d=N.BZ[3],O=N.BZ[4];P.subtractToRef(Z,v),c.subtractToRef(Z,G),c.subtractToRef(P,K);const H=v.length(),j=G.length(),B=K.length();if(H<x.c||j<x.c||B<x.c)return w.v(Z),U.Distance(M,Z);M.subtractToRef(Z,O),U.CrossToRef(v,G,d);const n=d.length();if(n<x.c)return w.v(Z),U.Distance(M,Z);d.normalizeFromLength(n);let L=O.length();if(L<x.c)return w.v(Z),0;O.normalizeFromLength(L);const u=U.Dot(d,O),J=N.BZ[5],t=N.BZ[6];J.v(d).scaleInPlace(-L*u),t.v(M).addInPlace(J);const F=N.BZ[4],D=N.BZ[5],l=N.BZ[7],h=N.BZ[8];F.v(v).scaleInPlace(1/H),h.v(G).scaleInPlace(1/j),F.addInPlace(h).scaleInPlace(-1),D.v(v).scaleInPlace(-1/H),h.v(K).scaleInPlace(1/B),D.addInPlace(h).scaleInPlace(-1),l.v(K).scaleInPlace(-1/B),h.v(G).scaleInPlace(-1/j),l.addInPlace(h).scaleInPlace(-1);const Q=N.BZ[9];let I;Q.v(t).MH(Z),U.CrossToRef(F,Q,h),I=U.Dot(h,d);const s=I;Q.v(t).MH(P),U.CrossToRef(D,Q,h),I=U.Dot(h,d);const C=I;Q.v(t).MH(c),U.CrossToRef(l,Q,h),I=U.Dot(h,d);const R=I,W=N.BZ[10];let k,A;s>0&&C<0?(W.v(v),k=Z,A=P):C>0&&R<0?(W.v(K),k=P,A=c):(W.v(G).scaleInPlace(-1),k=c,A=Z);const o=N.BZ[9],E=N.BZ[4];k.subtractToRef(t,h),A.subtractToRef(t,o),U.CrossToRef(h,o,E);if(!(U.Dot(E,d)<0))return w.v(t),Math.abs(L*u);const r=N.BZ[5];U.CrossToRef(W,E,r),r.normalize();const q=N.BZ[9];q.v(k).MH(t);const e=q.length();if(e<x.c)return w.v(k),U.Distance(M,k);q.normalizeFromLength(e);const b=U.Dot(r,q),a=N.BZ[7];a.v(t).addInPlace(r.scaleInPlace(e*b)),h.v(a).MH(k),L=W.length(),W.normalizeFromLength(L);let y=U.Dot(h,W)/Math.max(L,x.c);return y=(0,mM.Clamp)(y,0,1),a.v(k).addInPlace(W.scaleInPlace(y*L)),w.v(a),U.Distance(M,a)}static Center(M,Z){return U.CenterToRef(M,Z,U.Zero())}static CenterToRef(M,Z,P){return P.lc((M._x+Z._x)/2,(M._y+Z._y)/2,(M._z+Z._z)/2)}static RotationFromAxis(M,Z,P){const x=new U;return U.RotationFromAxisToRef(M,Z,P,x),x}static RotationFromAxisToRef(M,Z,P,x){const c=N.Quaternion[0];return L.RotationQuaternionFromAxisToRef(M,Z,P,c),c.toEulerAnglesToRef(x),x}}U._V8PerformanceHack=new U(.5,.5,.5),U._UpReadOnly=U.Up(),U._DownReadOnly=U.Down(),U._LeftHandedForwardReadOnly=U.Forward(!1),U._RightHandedForwardReadOnly=U.Forward(!0),U._LeftHandedBackwardReadOnly=U.Backward(!1),U._RightHandedBackwardReadOnly=U.Backward(!0),U._RightReadOnly=U.Right(),U._LeftReadOnly=U.Left(),U._ZeroReadOnly=U.Zero(),U._OneReadOnly=U.One(),Object.defineProperties(U.prototype,{dimension:{value:[3]},rank:{value:1}});class n{get x(){return this._x}set x(M){this._x=M,this._isDirty=!0}get y(){return this._y}set y(M){this._y=M,this._isDirty=!0}get z(){return this._z}set z(M){this._z=M,this._isDirty=!0}get w(){return this._w}set w(M){this._w=M,this._isDirty=!0}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=M,this._y=Z,this._z=P,this._w=x}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let M=j(this._x);return M=397*M^j(this._y),M=397*M^j(this._z),M=397*M^j(this._w),M}nc(){return[this._x,this._y,this._z,this._w]}toArray(M,Z){return void 0===Z&&(Z=0),M[Z]=this._x,M[Z+1]=this._y,M[Z+2]=this._z,M[Z+3]=this._w,this}jP(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n.FromArrayToRef(M,Z,this),this}addInPlace(M){return this.x+=M._x,this.y+=M._y,this.z+=M._z,this.w+=M._w,this}addInPlaceFromFloats(M,Z,P,x){return this.x+=M,this.y+=Z,this.z+=P,this.w+=x,this}add(M){return new n(this._x+M.x,this._y+M.y,this._z+M.z,this._w+M.w)}addToRef(M,Z){return Z.x=this._x+M.x,Z.y=this._y+M.y,Z.z=this._z+M.z,Z.w=this._w+M.w,Z}MH(M){return this.x-=M.x,this.y-=M.y,this.z-=M.z,this.w-=M.w,this}UZ(M){return new n(this._x-M.x,this._y-M.y,this._z-M.z,this._w-M.w)}subtractToRef(M,Z){return Z.x=this._x-M.x,Z.y=this._y-M.y,Z.z=this._z-M.z,Z.w=this._w-M.w,Z}subtractFromFloats(M,Z,P,x){return new n(this._x-M,this._y-Z,this._z-P,this._w-x)}subtractFromFloatsToRef(M,Z,P,x,c){return c.x=this._x-M,c.y=this._y-Z,c.z=this._z-P,c.w=this._w-x,c}negate(){return new n(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(M){return M.x=-this._x,M.y=-this._y,M.z=-this._z,M.w=-this._w,M}scaleInPlace(M){return this.x*=M,this.y*=M,this.z*=M,this.w*=M,this}scale(M){return new n(this._x*M,this._y*M,this._z*M,this._w*M)}scaleToRef(M,Z){return Z.x=this._x*M,Z.y=this._y*M,Z.z=this._z*M,Z.w=this._w*M,Z}scaleAndAddToRef(M,Z){return Z.x+=this._x*M,Z.y+=this._y*M,Z.z+=this._z*M,Z.w+=this._w*M,Z}equals(M){return M&&this._x===M.x&&this._y===M.y&&this._z===M.z&&this._w===M.w}equalsWithEpsilon(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:x.c;return M&&(0,mM.WithinEpsilon)(this._x,M.x,Z)&&(0,mM.WithinEpsilon)(this._y,M.y,Z)&&(0,mM.WithinEpsilon)(this._z,M.z,Z)&&(0,mM.WithinEpsilon)(this._w,M.w,Z)}equalsToFloats(M,Z,P,x){return this._x===M&&this._y===Z&&this._z===P&&this._w===x}multiplyInPlace(M){return this.x*=M.x,this.y*=M.y,this.z*=M.z,this.w*=M.w,this}multiply(M){return new n(this._x*M.x,this._y*M.y,this._z*M.z,this._w*M.w)}multiplyToRef(M,Z){return Z.x=this._x*M.x,Z.y=this._y*M.y,Z.z=this._z*M.z,Z.w=this._w*M.w,Z}multiplyByFloats(M,Z,P,x){return new n(this._x*M,this._y*Z,this._z*P,this._w*x)}divide(M){return new n(this._x/M.x,this._y/M.y,this._z/M.z,this._w/M.w)}divideToRef(M,Z){return Z.x=this._x/M.x,Z.y=this._y/M.y,Z.z=this._z/M.z,Z.w=this._w/M.w,Z}divideInPlace(M){return this.divideToRef(M,this)}minimizeInPlace(M){return M.x<this._x&&(this.x=M.x),M.y<this._y&&(this.y=M.y),M.z<this._z&&(this.z=M.z),M.w<this._w&&(this.w=M.w),this}maximizeInPlace(M){return M.x>this._x&&(this.x=M.x),M.y>this._y&&(this.y=M.y),M.z>this._z&&(this.z=M.z),M.w>this._w&&(this.w=M.w),this}minimizeInPlaceFromFloats(M,Z,P,x){return this.x=Math.min(M,this._x),this.y=Math.min(Z,this._y),this.z=Math.min(P,this._z),this.w=Math.min(x,this._w),this}maximizeInPlaceFromFloats(M,Z,P,x){return this.x=Math.max(M,this._x),this.y=Math.max(Z,this._y),this.z=Math.max(P,this._z),this.w=Math.max(x,this._w),this}floorToRef(M){return M.x=Math.floor(this._x),M.y=Math.floor(this._y),M.z=Math.floor(this._z),M.w=Math.floor(this._w),M}floor(){return new n(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(M){return M.x=this._x-Math.floor(this._x),M.y=this._y-Math.floor(this._y),M.z=this._z-Math.floor(this._z),M.w=this._w-Math.floor(this._w),M}fract(){return new n(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){return this.normalizeToRef(new n)}normalizeToRef(M){const Z=this.length();return 0===Z||1===Z?(M.x=this._x,M.y=this._y,M.z=this._z,M.w=this._w,M):this.scaleToRef(1/Z,M)}toVector3(){return new U(this._x,this._y,this._z)}clone(){return new n(this._x,this._y,this._z,this._w)}v(M){return this.x=M.x,this.y=M.y,this.z=M.z,this.w=M.w,this}lc(M,Z,P,x){return this.x=M,this.y=Z,this.z=P,this.w=x,this}set(M,Z,P,x){return this.lc(M,Z,P,x)}Qc(M){return this.x=this.y=this.z=this.w=M,this}dot(M){return this._x*M.x+this._y*M.y+this._z*M.z+this._w*M.w}static NZ(M,Z){return Z||(Z=0),new n(M[Z],M[Z+1],M[Z+2],M[Z+3])}static FromArrayToRef(M,Z,P){return P.x=M[Z],P.y=M[Z+1],P.z=M[Z+2],P.w=M[Z+3],P}static FromFloatArrayToRef(M,Z,P){return n.FromArrayToRef(M,Z,P),P}static FromFloatsToRef(M,Z,P,x,c){return c.x=M,c.y=Z,c.z=P,c.w=x,c}static Zero(){return new n(0,0,0,0)}static One(){return new n(1,1,1,1)}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new n((0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0;return P.x=(0,mM.RandomRange)(M,Z),P.y=(0,mM.RandomRange)(M,Z),P.z=(0,mM.RandomRange)(M,Z),P.w=(0,mM.RandomRange)(M,Z),P}static Clamp(M,Z,P){return n.ClampToRef(M,Z,P,new n)}static ClampToRef(M,Z,P,x){return x.x=(0,mM.Clamp)(M.x,Z.x,P.x),x.y=(0,mM.Clamp)(M.y,Z.y,P.y),x.z=(0,mM.Clamp)(M.z,Z.z,P.z),x.w=(0,mM.Clamp)(M.w,Z.w,P.w),x}static CheckExtends(M,Z,P){Z.minimizeInPlace(M),P.maximizeInPlace(M)}static get ZeroReadOnly(){return n._ZeroReadOnly}static Normalize(M){return n.NormalizeToRef(M,new n)}static NormalizeToRef(M,Z){return M.normalizeToRef(Z),Z}static Minimize(M,Z){const P=new n;return P.v(M),P.minimizeInPlace(Z),P}static Maximize(M,Z){const P=new n;return P.v(M),P.maximizeInPlace(Z),P}static Distance(M,Z){return Math.sqrt(n.DistanceSquared(M,Z))}static DistanceSquared(M,Z){const P=M.x-Z.x,x=M.y-Z.y,c=M.z-Z.z,w=M.w-Z.w;return P*P+x*x+c*c+w*w}static Center(M,Z){return n.CenterToRef(M,Z,new n)}static CenterToRef(M,Z,P){return P.x=(M.x+Z.x)/2,P.y=(M.y+Z.y)/2,P.z=(M.z+Z.z)/2,P.w=(M.w+Z.w)/2,P}static TransformCoordinates(M,Z){return n.TransformCoordinatesToRef(M,Z,new n)}static TransformCoordinatesToRef(M,Z,P){return n.TransformCoordinatesFromFloatsToRef(M._x,M._y,M._z,Z,P),P}static TransformCoordinatesFromFloatsToRef(M,Z,P,x,c){const w=x.m,v=M*w[0]+Z*w[4]+P*w[8]+w[12],G=M*w[1]+Z*w[5]+P*w[9]+w[13],mM=M*w[2]+Z*w[6]+P*w[10]+w[14],K=M*w[3]+Z*w[7]+P*w[11]+w[15];return c.x=v,c.y=G,c.z=mM,c.w=K,c}static TransformNormal(M,Z){return n.TransformNormalToRef(M,Z,new n)}static TransformNormalToRef(M,Z,P){const x=Z.m,c=M.x*x[0]+M.y*x[4]+M.z*x[8],w=M.x*x[1]+M.y*x[5]+M.z*x[9],v=M.x*x[2]+M.y*x[6]+M.z*x[10];return P.x=c,P.y=w,P.z=v,P.w=M.w,P}static TransformNormalFromFloatsToRef(M,Z,P,x,c,w){const v=c.m;return w.x=M*v[0]+Z*v[4]+P*v[8],w.y=M*v[1]+Z*v[5]+P*v[9],w.z=M*v[2]+Z*v[6]+P*v[10],w.w=x,w}static FromVector3(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new n(M._x,M._y,M._z,Z)}static Dot(M,Z){return M.x*Z.x+M.y*Z.y+M.z*Z.z+M.w*Z.w}}n._V8PerformanceHack=new n(.5,.5,.5,.5),n._ZeroReadOnly=n.Zero(),Object.defineProperties(n.prototype,{dimension:{value:[4]},rank:{value:1}});class L{get x(){return this._x}set x(M){this._x=M,this._isDirty=!0}get y(){return this._y}set y(M){this._y=M,this._isDirty=!0}get z(){return this._z}set z(M){this._z=M,this._isDirty=!0}get w(){return this._w}set w(M){this._w=M,this._isDirty=!0}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=M,this._y=Z,this._z=P,this._w=x}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let M=j(this._x);return M=397*M^j(this._y),M=397*M^j(this._z),M=397*M^j(this._w),M}nc(){return[this._x,this._y,this._z,this._w]}toArray(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[Z]=this._x,M[Z+1]=this._y,M[Z+2]=this._z,M[Z+3]=this._w,this}jP(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(M,Z,this)}equals(M){return M&&this._x===M._x&&this._y===M._y&&this._z===M._z&&this._w===M._w}equalsWithEpsilon(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:x.c;return M&&(0,mM.WithinEpsilon)(this._x,M._x,Z)&&(0,mM.WithinEpsilon)(this._y,M._y,Z)&&(0,mM.WithinEpsilon)(this._z,M._z,Z)&&(0,mM.WithinEpsilon)(this._w,M._w,Z)}isApprox(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:x.c;return M&&((0,mM.WithinEpsilon)(this._x,M._x,Z)&&(0,mM.WithinEpsilon)(this._y,M._y,Z)&&(0,mM.WithinEpsilon)(this._z,M._z,Z)&&(0,mM.WithinEpsilon)(this._w,M._w,Z)||(0,mM.WithinEpsilon)(this._x,-M._x,Z)&&(0,mM.WithinEpsilon)(this._y,-M._y,Z)&&(0,mM.WithinEpsilon)(this._z,-M._z,Z)&&(0,mM.WithinEpsilon)(this._w,-M._w,Z))}clone(){return new L(this._x,this._y,this._z,this._w)}v(M){return this._x=M._x,this._y=M._y,this._z=M._z,this._w=M._w,this._isDirty=!0,this}lc(M,Z,P,x){return this._x=M,this._y=Z,this._z=P,this._w=x,this._isDirty=!0,this}set(M,Z,P,x){return this.lc(M,Z,P,x)}Qc(M){return this.lc(M,M,M,M)}add(M){return new L(this._x+M._x,this._y+M._y,this._z+M._z,this._w+M._w)}addInPlace(M){return this._x+=M._x,this._y+=M._y,this._z+=M._z,this._w+=M._w,this._isDirty=!0,this}addToRef(M,Z){return Z._x=this._x+M._x,Z._y=this._y+M._y,Z._z=this._z+M._z,Z._w=this._w+M._w,Z._isDirty=!0,Z}addInPlaceFromFloats(M,Z,P,x){return this._x+=M,this._y+=Z,this._z+=P,this._w+=x,this._isDirty=!0,this}subtractToRef(M,Z){return Z._x=this._x-M._x,Z._y=this._y-M._y,Z._z=this._z-M._z,Z._w=this._w-M._w,Z._isDirty=!0,Z}subtractFromFloats(M,Z,P,x){return this.subtractFromFloatsToRef(M,Z,P,x,new L)}subtractFromFloatsToRef(M,Z,P,x,c){return c._x=this._x-M,c._y=this._y-Z,c._z=this._z-P,c._w=this._w-x,c._isDirty=!0,c}UZ(M){return new L(this._x-M._x,this._y-M._y,this._z-M._z,this._w-M._w)}MH(M){return this._x-=M._x,this._y-=M._y,this._z-=M._z,this._w-=M._w,this._isDirty=!0,this}scale(M){return new L(this._x*M,this._y*M,this._z*M,this._w*M)}scaleToRef(M,Z){return Z._x=this._x*M,Z._y=this._y*M,Z._z=this._z*M,Z._w=this._w*M,Z._isDirty=!0,Z}scaleInPlace(M){return this._x*=M,this._y*=M,this._z*=M,this._w*=M,this._isDirty=!0,this}scaleAndAddToRef(M,Z){return Z._x+=this._x*M,Z._y+=this._y*M,Z._z+=this._z*M,Z._w+=this._w*M,Z._isDirty=!0,Z}multiply(M){const Z=new L(0,0,0,1);return this.multiplyToRef(M,Z),Z}multiplyToRef(M,Z){const P=this._x*M._w+this._y*M._z-this._z*M._y+this._w*M._x,x=-this._x*M._z+this._y*M._w+this._z*M._x+this._w*M._y,c=this._x*M._y-this._y*M._x+this._z*M._w+this._w*M._z,w=-this._x*M._x-this._y*M._y-this._z*M._z+this._w*M._w;return Z.lc(P,x,c,w),Z}multiplyInPlace(M){return this.multiplyToRef(M,this)}multiplyByFloats(M,Z,P,x){return this._x*=M,this._y*=Z,this._z*=P,this._w*=x,this._isDirty=!0,this}divide(M){throw new ReferenceError("Can not divide a quaternion")}divideToRef(M,Z){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(M){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new L)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(M){return M._x=-this._x,M._y=-this._y,M._z=-this._z,M._w=-this._w,M._isDirty=!0,M}equalsToFloats(M,Z,P,x){return this._x===M&&this._y===Z&&this._z===P&&this._w===x}floorToRef(M){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(M){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(M){return M.lc(-this._x,-this._y,-this._z,this._w),M}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new L(-this._x,-this._y,-this._z,this._w)}invert(){const M=this.conjugate(),Z=this.lengthSquared();return 0==Z||1==Z||M.scaleInPlace(1/Z),M}invertInPlace(){this.conjugateInPlace();const M=this.lengthSquared();return 0==M||1==M||this.scaleInPlace(1/M),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(M){return 0===M||1===M?this:this.scaleInPlace(1/M)}normalizeToNew(){const M=new L(0,0,0,1);return this.normalizeToRef(M),M}normalizeToRef(M){const Z=this.length();return 0===Z||1===Z?M.lc(this._x,this._y,this._z,this._w):this.scaleToRef(1/Z,M)}toEulerAngles(){const M=U.Zero();return this.toEulerAnglesToRef(M),M}toEulerAnglesToRef(M){const Z=this._z,P=this._x,x=this._y,c=this._w,w=x*Z-P*c,v=.4999999;if(w<-v)M._y=2*Math.atan2(x,c),M._x=Math.PI/2,M._z=0,M._isDirty=!0;else if(w>v)M._y=2*Math.atan2(x,c),M._x=-Math.PI/2,M._z=0,M._isDirty=!0;else{const v=c*c,G=Z*Z,mM=P*P,K=x*x;M._z=Math.atan2(2*(P*x+Z*c),-G-mM+K+v),M._x=Math.asin(-2*w),M._y=Math.atan2(2*(Z*P+x*c),G-mM-K+v),M._isDirty=!0}return M}toAlphaBetaGammaToRef(M){const Z=this._z,P=this._x,x=this._y,c=this._w,w=Math.sqrt(P*P+x*x),v=Math.sqrt(Z*Z+c*c),G=2*Math.atan2(w,v),mM=2*Math.atan2(Z,c),K=2*Math.atan2(x,P),d=(mM+K)/2,O=(mM-K)/2;return M.set(O,G,d),M}toRotationMatrix(M){return u.FromQuaternionToRef(this,M),M}fromRotationMatrix(M){return L.FromRotationMatrixToRef(M,this),this}dot(M){return this._x*M._x+this._y*M._y+this._z*M._z+this._w*M._w}toAxisAngle(){const M=U.Zero();return{axis:M,angle:this.toAxisAngleToRef(M)}}toAxisAngleToRef(M){let Z=0;const P=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),x=this._w;return P>0?(Z=2*Math.atan2(P,x),M.set(this._x/P,this._y/P,this._z/P)):(Z=0,M.set(1,0,0)),Z}static FromRotationMatrix(M){const Z=new L;return L.FromRotationMatrixToRef(M,Z),Z}static FromRotationMatrixToRef(M,Z){const P=M.m,x=P[0],c=P[4],w=P[8],v=P[1],G=P[5],mM=P[9],K=P[2],d=P[6],O=P[10],H=x+G+O;let j;return H>0?(j=.5/Math.sqrt(H+1),Z._w=.25/j,Z._x=(d-mM)*j,Z._y=(w-K)*j,Z._z=(v-c)*j,Z._isDirty=!0):x>G&&x>O?(j=2*Math.sqrt(1+x-G-O),Z._w=(d-mM)/j,Z._x=.25*j,Z._y=(c+v)/j,Z._z=(w+K)/j,Z._isDirty=!0):G>O?(j=2*Math.sqrt(1+G-x-O),Z._w=(w-K)/j,Z._x=(c+v)/j,Z._y=.25*j,Z._z=(mM+d)/j,Z._isDirty=!0):(j=2*Math.sqrt(1+O-x-G),Z._w=(v-c)/j,Z._x=(w+K)/j,Z._y=(mM+d)/j,Z._z=.25*j,Z._isDirty=!0),Z}static Dot(M,Z){return M._x*Z._x+M._y*Z._y+M._z*Z._z+M._w*Z._w}static AreClose(M,Z){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const x=L.Dot(M,Z);return 1-x*x<=P}static SmoothToRef(M,Z,P,x,c){let w=0===x?1:P/x;return w=(0,mM.Clamp)(w,0,1),L.SlerpToRef(M,Z,w,c),c}static Zero(){return new L(0,0,0,0)}static Inverse(M){return new L(-M._x,-M._y,-M._z,M._w)}static InverseToRef(M,Z){return Z.set(-M._x,-M._y,-M._z,M._w),Z}static Identity(){return new L(0,0,0,1)}static IsIdentity(M){return M&&0===M._x&&0===M._y&&0===M._z&&1===M._w}static RotationAxis(M,Z){return L.RotationAxisToRef(M,Z,new L)}static RotationAxisToRef(M,Z,P){P._w=Math.cos(Z/2);const x=Math.sin(Z/2)/M.length();return P._x=M._x*x,P._y=M._y*x,P._z=M._z*x,P._isDirty=!0,P}static NZ(M,Z){return Z||(Z=0),new L(M[Z],M[Z+1],M[Z+2],M[Z+3])}static FromArrayToRef(M,Z,P){return P._x=M[Z],P._y=M[Z+1],P._z=M[Z+2],P._w=M[Z+3],P._isDirty=!0,P}static FromFloatsToRef(M,Z,P,x,c){return c.lc(M,Z,P,x),c}static FromEulerAngles(M,Z,P){const x=new L;return L.RotationYawPitchRollToRef(Z,M,P,x),x}static FromEulerAnglesToRef(M,Z,P,x){return L.RotationYawPitchRollToRef(Z,M,P,x),x}static FromEulerVector(M){const Z=new L;return L.RotationYawPitchRollToRef(M._y,M._x,M._z,Z),Z}static FromEulerVectorToRef(M,Z){return L.RotationYawPitchRollToRef(M._y,M._x,M._z,Z),Z}static FromUnitVectorsToRef(M,Z,P){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:x.c;const w=U.Dot(M,Z)+1;return w<c?Math.abs(M.x)>Math.abs(M.z)?P.set(-M.y,M.x,0,0):P.set(0,-M.z,M.y,0):(U.CrossToRef(M,Z,J.BZ[0]),P.set(J.BZ[0].x,J.BZ[0].y,J.BZ[0].z,w)),P.normalize()}static RotationYawPitchRoll(M,Z,P){const x=new L;return L.RotationYawPitchRollToRef(M,Z,P,x),x}static RotationYawPitchRollToRef(M,Z,P,x){const c=.5*P,w=.5*Z,v=.5*M,G=Math.sin(c),mM=Math.cos(c),K=Math.sin(w),d=Math.cos(w),O=Math.sin(v),H=Math.cos(v);return x._x=H*K*mM+O*d*G,x._y=O*d*mM-H*K*G,x._z=H*d*G-O*K*mM,x._w=H*d*mM+O*K*G,x._isDirty=!0,x}static RotationAlphaBetaGamma(M,Z,P){const x=new L;return L.RotationAlphaBetaGammaToRef(M,Z,P,x),x}static RotationAlphaBetaGammaToRef(M,Z,P,x){const c=.5*(P+M),w=.5*(P-M),v=.5*Z;return x._x=Math.cos(w)*Math.sin(v),x._y=Math.sin(w)*Math.sin(v),x._z=Math.sin(c)*Math.cos(v),x._w=Math.cos(c)*Math.cos(v),x._isDirty=!0,x}static RotationQuaternionFromAxis(M,Z,P){const x=new L(0,0,0,0);return L.RotationQuaternionFromAxisToRef(M,Z,P,x),x}static RotationQuaternionFromAxisToRef(M,Z,P,x){const c=N.Matrix[0];return M=M.normalizeToRef(N.BZ[0]),Z=Z.normalizeToRef(N.BZ[1]),P=P.normalizeToRef(N.BZ[2]),u.FromXYZAxesToRef(M,Z,P,c),L.FromRotationMatrixToRef(c,x),x}static FromLookDirectionLH(M,Z){const P=new L;return L.FromLookDirectionLHToRef(M,Z,P),P}static FromLookDirectionLHToRef(M,Z,P){const x=N.Matrix[0];return u.LookDirectionLHToRef(M,Z,x),L.FromRotationMatrixToRef(x,P),P}static FromLookDirectionRH(M,Z){const P=new L;return L.FromLookDirectionRHToRef(M,Z,P),P}static FromLookDirectionRHToRef(M,Z,P){const x=N.Matrix[0];return u.LookDirectionRHToRef(M,Z,x),L.FromRotationMatrixToRef(x,P)}static Slerp(M,Z,P){const x=L.Identity();return L.SlerpToRef(M,Z,P,x),x}static SlerpToRef(M,Z,P,x){let c,w,v=M._x*Z._x+M._y*Z._y+M._z*Z._z+M._w*Z._w,G=!1;if(v<0&&(G=!0,v=-v),v>.999999)w=1-P,c=G?-P:P;else{const M=Math.acos(v),Z=1/Math.sin(M);w=Math.sin((1-P)*M)*Z,c=G?-Math.sin(P*M)*Z:Math.sin(P*M)*Z}return x._x=w*M._x+c*Z._x,x._y=w*M._y+c*Z._y,x._z=w*M._z+c*Z._z,x._w=w*M._w+c*Z._w,x._isDirty=!0,x}static Hermite(M,Z,P,x,c){const w=c*c,v=c*w,G=2*v-3*w+1,mM=-2*v+3*w,K=v-2*w+c,d=v-w,O=M._x*G+P._x*mM+Z._x*K+x._x*d,H=M._y*G+P._y*mM+Z._y*K+x._y*d,j=M._z*G+P._z*mM+Z._z*K+x._z*d,B=M._w*G+P._w*mM+Z._w*K+x._w*d;return new L(O,H,j,B)}static Hermite1stDerivative(M,Z,P,x,c){const w=new L;return this.Hermite1stDerivativeToRef(M,Z,P,x,c,w),w}static Hermite1stDerivativeToRef(M,Z,P,x,c,w){const v=c*c;return w._x=6*(v-c)*M._x+(3*v-4*c+1)*Z._x+6*(-v+c)*P._x+(3*v-2*c)*x._x,w._y=6*(v-c)*M._y+(3*v-4*c+1)*Z._y+6*(-v+c)*P._y+(3*v-2*c)*x._y,w._z=6*(v-c)*M._z+(3*v-4*c+1)*Z._z+6*(-v+c)*P._z+(3*v-2*c)*x._z,w._w=6*(v-c)*M._w+(3*v-4*c+1)*Z._w+6*(-v+c)*P._w+(3*v-2*c)*x._w,w._isDirty=!0,w}static Normalize(M){const Z=L.Zero();return L.NormalizeToRef(M,Z),Z}static NormalizeToRef(M,Z){return M.normalizeToRef(Z),Z}static Clamp(M,Z,P){const x=new L;return L.ClampToRef(M,Z,P,x),x}static ClampToRef(M,Z,P,x){return x.lc((0,mM.Clamp)(M.x,Z.x,P.x),(0,mM.Clamp)(M.y,Z.y,P.y),(0,mM.Clamp)(M.z,Z.z,P.z),(0,mM.Clamp)(M.w,Z.w,P.w))}static Random(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new L((0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z))}static RandomToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).lc((0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z),(0,mM.RandomRange)(M,Z))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(M,Z){return Math.sqrt(L.DistanceSquared(M,Z))}static DistanceSquared(M,Z){const P=M.x-Z.x,x=M.y-Z.y,c=M.z-Z.z,w=M.w-Z.w;return P*P+x*x+c*c+w*w}static Center(M,Z){return L.CenterToRef(M,Z,L.Zero())}static CenterToRef(M,Z,P){return P.lc((M.x+Z.x)/2,(M.y+Z.y)/2,(M.z+Z.z)/2,(M.w+Z.w)/2)}}L._V8PerformanceHack=new L(.5,.5,.5,.5),Object.defineProperties(L.prototype,{dimension:{value:[4]},rank:{value:1}});class u{static get Use64Bits(){return v.e.MatrixUse64Bits}get m(){return this.dc}markAsUpdated(){this.updateFlag=K._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(M){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=M,this._isIdentity3x2=M||P,this._isIdentityDirty=!this._isIdentity&&Z,this._isIdentity3x2Dirty=!this._isIdentity3x2&&x}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,v.e.MatrixTrackPrecisionChange&&v.e.MatrixTrackedMatrices.push(this),this.dc=new v.e.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const M=this.dc;this._isIdentity=1===M[0]&&0===M[1]&&0===M[2]&&0===M[3]&&0===M[4]&&1===M[5]&&0===M[6]&&0===M[7]&&0===M[8]&&0===M[9]&&1===M[10]&&0===M[11]&&0===M[12]&&0===M[13]&&0===M[14]&&1===M[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.dc[0]||1!==this.dc[5]||1!==this.dc[15]||0!==this.dc[1]||0!==this.dc[2]||0!==this.dc[3]||0!==this.dc[4]||0!==this.dc[6]||0!==this.dc[7]||0!==this.dc[8]||0!==this.dc[9]||0!==this.dc[10]||0!==this.dc[11]||0!==this.dc[12]||0!==this.dc[13]||0!==this.dc[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const M=this.dc,Z=M[0],P=M[1],x=M[2],c=M[3],w=M[4],v=M[5],G=M[6],mM=M[7],K=M[8],d=M[9],O=M[10],H=M[11],j=M[12],B=M[13],U=M[14],n=M[15],L=O*n-U*H,u=d*n-B*H,N=d*U-B*O,J=K*n-j*H,t=K*U-O*j,F=K*B-j*d;return Z*+(v*L-G*u+mM*N)+P*-(w*L-G*J+mM*t)+x*+(w*u-v*J+mM*F)+c*-(w*N-v*t+G*F)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!M)return this.dc;const P=this.dc;for(let x=0;x<16;x++)M[Z+x]=P[x];return this}nc(){return this.dc}jP(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(M,Z,this)}lc(){for(var M=arguments.length,Z=new Array(M),P=0;P<M;P++)Z[P]=arguments[P];return u.FromArrayToRef(Z,0,this)}set(){const M=this.dc;for(let Z=0;Z<16;Z++)M[Z]=Z<0||arguments.length<=Z?void 0:arguments[Z];return this.markAsUpdated(),this}Qc(M){const Z=this.dc;for(let P=0;P<16;P++)Z[P]=M;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return u.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(M){const Z=new u;return this.addToRef(M,Z),Z}addToRef(M,Z){const P=this.dc,x=Z.dc,c=M.m;for(let w=0;w<16;w++)x[w]=P[w]+c[w];return Z.markAsUpdated(),Z}addToSelf(M){const Z=this.dc,P=M.m;return Z[0]+=P[0],Z[1]+=P[1],Z[2]+=P[2],Z[3]+=P[3],Z[4]+=P[4],Z[5]+=P[5],Z[6]+=P[6],Z[7]+=P[7],Z[8]+=P[8],Z[9]+=P[9],Z[10]+=P[10],Z[11]+=P[11],Z[12]+=P[12],Z[13]+=P[13],Z[14]+=P[14],Z[15]+=P[15],this.markAsUpdated(),this}addInPlace(M){const Z=this.dc,P=M.m;for(let x=0;x<16;x++)Z[x]+=P[x];return this.markAsUpdated(),this}addInPlaceFromFloats(){const M=this.dc;for(let Z=0;Z<16;Z++)M[Z]+=Z<0||arguments.length<=Z?void 0:arguments[Z];return this.markAsUpdated(),this}UZ(M){const Z=this.dc,P=M.m;for(let x=0;x<16;x++)Z[x]-=P[x];return this.markAsUpdated(),this}subtractToRef(M,Z){const P=this.dc,x=M.m,c=Z.dc;for(let w=0;w<16;w++)c[w]=P[w]-x[w];return Z.markAsUpdated(),Z}MH(M){const Z=this.dc,P=M.m;for(let x=0;x<16;x++)Z[x]-=P[x];return this.markAsUpdated(),this}subtractFromFloats(){for(var M=arguments.length,Z=new Array(M),P=0;P<M;P++)Z[P]=arguments[P];return this.subtractFromFloatsToRef(...Z,new u)}subtractFromFloatsToRef(){for(var M=arguments.length,Z=new Array(M),P=0;P<M;P++)Z[P]=arguments[P];const x=Z.pop(),c=this.dc,w=x.dc,v=Z;for(let G=0;G<16;G++)w[G]=c[G]-v[G];return x.markAsUpdated(),x}invertToRef(M){return!0===this._isIdentity?(u.IdentityToRef(M),M):(H(this,M.nc())?M.markAsUpdated():M.v(this),M)}addAtIndex(M,Z){return this.dc[M]+=Z,this.markAsUpdated(),this}multiplyAtIndex(M,Z){return this.dc[M]*=Z,this.markAsUpdated(),this}setTranslationFromFloats(M,Z,P){return this.dc[12]=M,this.dc[13]=Z,this.dc[14]=P,this.markAsUpdated(),this}addTranslationFromFloats(M,Z,P){return this.dc[12]+=M,this.dc[13]+=Z,this.dc[14]+=P,this.markAsUpdated(),this}setTranslation(M){return this.setTranslationFromFloats(M._x,M._y,M._z)}getTranslation(){return new U(this.dc[12],this.dc[13],this.dc[14])}getTranslationToRef(M){return M.x=this.dc[12],M.y=this.dc[13],M.z=this.dc[14],M}removeRotationAndScaling(){const M=this.m;return u.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,M[12],M[13],M[14],M[15],this),this._updateIdentityStatus(0===M[12]&&0===M[13]&&0===M[14]&&1===M[15]),this}v(M){M.copyToArray(this.dc);const Z=M;return this.updateFlag=Z.updateFlag,this._updateIdentityStatus(Z._isIdentity,Z._isIdentityDirty,Z._isIdentity3x2,Z._isIdentity3x2Dirty),this}copyToArray(M){return O(this,M,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(M){const Z=new u;return this.multiplyToRef(M,Z),Z}multiplyInPlace(M){const Z=this.dc,P=M.m;for(let x=0;x<16;x++)Z[x]*=P[x];return this.markAsUpdated(),this}multiplyByFloats(){const M=this.dc;for(let Z=0;Z<16;Z++)M[Z]*=Z<0||arguments.length<=Z?void 0:arguments[Z];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var M=arguments.length,Z=new Array(M),P=0;P<M;P++)Z[P]=arguments[P];const x=Z.pop(),c=this.dc,w=x.dc,v=Z;for(let G=0;G<16;G++)w[G]=c[G]*v[G];return x.markAsUpdated(),x}multiplyToRef(M,Z){return this._isIdentity?(Z.v(M),Z):M._isIdentity?(Z.v(this),Z):(this.multiplyToArray(M,Z.dc,0),Z.markAsUpdated(),Z)}multiplyToArray(M,Z,P){return d(this,M,Z,P),this}divide(M){return this.divideToRef(M,new u)}divideToRef(M,Z){const P=this.dc,x=M.m,c=Z.dc;for(let w=0;w<16;w++)c[w]=P[w]/x[w];return Z.markAsUpdated(),Z}divideInPlace(M){const Z=this.dc,P=M.m;for(let x=0;x<16;x++)Z[x]/=P[x];return this.markAsUpdated(),this}minimizeInPlace(M){const Z=this.dc,P=M.m;for(let x=0;x<16;x++)Z[x]=Math.min(Z[x],P[x]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const M=this.dc;for(let Z=0;Z<16;Z++)M[Z]=Math.min(M[Z],Z<0||arguments.length<=Z?void 0:arguments[Z]);return this.markAsUpdated(),this}maximizeInPlace(M){const Z=this.dc,P=M.m;for(let x=0;x<16;x++)Z[x]=Math.min(Z[x],P[x]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const M=this.dc;for(let Z=0;Z<16;Z++)M[Z]=Math.min(M[Z],Z<0||arguments.length<=Z?void 0:arguments[Z]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new u)}negateInPlace(){const M=this.dc;for(let Z=0;Z<16;Z++)M[Z]=-M[Z];return this.markAsUpdated(),this}negateToRef(M){const Z=this.dc,P=M.dc;for(let x=0;x<16;x++)P[x]=-Z[x];return M.markAsUpdated(),M}equals(M){const Z=M;if(!Z)return!1;if((this._isIdentity||Z._isIdentity)&&!this._isIdentityDirty&&!Z._isIdentityDirty)return this._isIdentity&&Z._isIdentity;const P=this.m,x=Z.m;return P[0]===x[0]&&P[1]===x[1]&&P[2]===x[2]&&P[3]===x[3]&&P[4]===x[4]&&P[5]===x[5]&&P[6]===x[6]&&P[7]===x[7]&&P[8]===x[8]&&P[9]===x[9]&&P[10]===x[10]&&P[11]===x[11]&&P[12]===x[12]&&P[13]===x[13]&&P[14]===x[14]&&P[15]===x[15]}equalsWithEpsilon(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const P=this.dc,x=M.m;for(let c=0;c<16;c++)if(!(0,mM.WithinEpsilon)(P[c],x[c],Z))return!1;return!0}equalsToFloats(){const M=this.dc;for(let Z=0;Z<16;Z++)if(M[Z]!=(Z<0||arguments.length<=Z?void 0:arguments[Z]))return!1;return!0}floor(){return this.floorToRef(new u)}floorToRef(M){const Z=this.dc,P=M.dc;for(let x=0;x<16;x++)P[x]=Math.floor(Z[x]);return M.markAsUpdated(),M}fract(){return this.fractToRef(new u)}fractToRef(M){const Z=this.dc,P=M.dc;for(let x=0;x<16;x++)P[x]=Z[x]-Math.floor(Z[x]);return M.markAsUpdated(),M}clone(){const M=new u;return M.v(this),M}getClassName(){return"Matrix"}getHashCode(){let M=j(this.dc[0]);for(let Z=1;Z<16;Z++)M=397*M^j(this.dc[Z]);return M}decomposeToTransformNode(M){return M.rotationQuaternion=M.rotationQuaternion||new L,this.decompose(M.hc,M.rotationQuaternion,M.position)}decompose(M,Z,P,x){let c=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return P&&P.Qc(0),M&&M.Qc(1),Z&&Z.lc(0,0,0,1),!0;const w=this.dc;if(P&&P.lc(w[12],w[13],w[14]),(M=M||N.BZ[0]).x=Math.sqrt(w[0]*w[0]+w[1]*w[1]+w[2]*w[2]),M.y=Math.sqrt(w[4]*w[4]+w[5]*w[5]+w[6]*w[6]),M.z=Math.sqrt(w[8]*w[8]+w[9]*w[9]+w[10]*w[10]),x){const Z=(c?x.absoluteScaling.x:x.hc.x)<0?-1:1,P=(c?x.absoluteScaling.y:x.hc.y)<0?-1:1,w=(c?x.absoluteScaling.z:x.hc.z)<0?-1:1;M.x*=Z,M.y*=P,M.z*=w}else this.determinant()<=0&&(M.y*=-1);if(0===M._x||0===M._y||0===M._z)return Z&&Z.lc(0,0,0,1),!1;if(Z){const P=1/M._x,x=1/M._y,c=1/M._z;u.FromValuesToRef(w[0]*P,w[1]*P,w[2]*P,0,w[4]*x,w[5]*x,w[6]*x,0,w[8]*c,w[9]*c,w[10]*c,0,0,0,0,1,N.Matrix[0]),L.FromRotationMatrixToRef(N.Matrix[0],Z)}return!0}getRow(M){if(M<0||M>3)return null;const Z=4*M;return new n(this.dc[Z+0],this.dc[Z+1],this.dc[Z+2],this.dc[Z+3])}getRowToRef(M,Z){if(M>=0&&M<=3){const P=4*M;Z.x=this.dc[P+0],Z.y=this.dc[P+1],Z.z=this.dc[P+2],Z.w=this.dc[P+3]}return Z}setRow(M,Z){return this.setRowFromFloats(M,Z.x,Z.y,Z.z,Z.w)}transpose(){const M=new u;return u.TransposeToRef(this,M),M}transposeToRef(M){return u.TransposeToRef(this,M),M}setRowFromFloats(M,Z,P,x,c){if(M<0||M>3)return this;const w=4*M;return this.dc[w+0]=Z,this.dc[w+1]=P,this.dc[w+2]=x,this.dc[w+3]=c,this.markAsUpdated(),this}scale(M){const Z=new u;return this.scaleToRef(M,Z),Z}scaleToRef(M,Z){for(let P=0;P<16;P++)Z.dc[P]=this.dc[P]*M;return Z.markAsUpdated(),Z}scaleAndAddToRef(M,Z){for(let P=0;P<16;P++)Z.dc[P]+=this.dc[P]*M;return Z.markAsUpdated(),Z}scaleInPlace(M){const Z=this.dc;for(let P=0;P<16;P++)Z[P]*=M;return this.markAsUpdated(),this}toNormalMatrix(M){const Z=N.Matrix[0];this.invertToRef(Z),Z.transposeToRef(M);const P=M.dc;return u.FromValuesToRef(P[0],P[1],P[2],0,P[4],P[5],P[6],0,P[8],P[9],P[10],0,0,0,0,1,M),M}getRotationMatrix(){const M=new u;return this.getRotationMatrixToRef(M),M}getRotationMatrixToRef(M){const Z=N.BZ[0];if(!this.decompose(Z))return u.IdentityToRef(M),M;const P=this.dc,x=1/Z._x,c=1/Z._y,w=1/Z._z;return u.FromValuesToRef(P[0]*x,P[1]*x,P[2]*x,0,P[4]*c,P[5]*c,P[6]*c,0,P[8]*w,P[9]*w,P[10]*w,0,0,0,0,1,M),M}toggleModelMatrixHandInPlace(){const M=this.dc;return M[2]*=-1,M[6]*=-1,M[8]*=-1,M[9]*=-1,M[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const M=this.dc;return M[8]*=-1,M[9]*=-1,M[10]*=-1,M[11]*=-1,this.markAsUpdated(),this}static NZ(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const P=new u;return u.FromArrayToRef(M,Z,P),P}static FromArrayToRef(M,Z,P){for(let x=0;x<16;x++)P.dc[x]=M[x+Z];return P.markAsUpdated(),P}static FromFloat32ArrayToRefScaled(M,Z,P,x){return x.dc[0]=M[0+Z]*P,x.dc[1]=M[1+Z]*P,x.dc[2]=M[2+Z]*P,x.dc[3]=M[3+Z]*P,x.dc[4]=M[4+Z]*P,x.dc[5]=M[5+Z]*P,x.dc[6]=M[6+Z]*P,x.dc[7]=M[7+Z]*P,x.dc[8]=M[8+Z]*P,x.dc[9]=M[9+Z]*P,x.dc[10]=M[10+Z]*P,x.dc[11]=M[11+Z]*P,x.dc[12]=M[12+Z]*P,x.dc[13]=M[13+Z]*P,x.dc[14]=M[14+Z]*P,x.dc[15]=M[15+Z]*P,x.markAsUpdated(),x}static get IdentityReadOnly(){return u._IdentityReadOnly}static FromValuesToRef(M,Z,P,x,c,w,v,G,mM,K,d,O,H,j,B,U,n){const L=n.dc;L[0]=M,L[1]=Z,L[2]=P,L[3]=x,L[4]=c,L[5]=w,L[6]=v,L[7]=G,L[8]=mM,L[9]=K,L[10]=d,L[11]=O,L[12]=H,L[13]=j,L[14]=B,L[15]=U,n.markAsUpdated()}static FromValues(M,Z,P,x,c,w,v,G,mM,K,d,O,H,j,B,U){const n=new u,L=n.dc;return L[0]=M,L[1]=Z,L[2]=P,L[3]=x,L[4]=c,L[5]=w,L[6]=v,L[7]=G,L[8]=mM,L[9]=K,L[10]=d,L[11]=O,L[12]=H,L[13]=j,L[14]=B,L[15]=U,n.markAsUpdated(),n}static Compose(M,Z,P){const x=new u;return u.ComposeToRef(M,Z,P,x),x}static ComposeToRef(M,Z,P,x){const c=x.dc,w=Z._x,v=Z._y,G=Z._z,mM=Z._w,K=w+w,d=v+v,O=G+G,H=w*K,j=w*d,B=w*O,U=v*d,n=v*O,L=G*O,u=mM*K,N=mM*d,J=mM*O,t=M._x,F=M._y,D=M._z;return c[0]=(1-(U+L))*t,c[1]=(j+J)*t,c[2]=(B-N)*t,c[3]=0,c[4]=(j-J)*F,c[5]=(1-(H+L))*F,c[6]=(n+u)*F,c[7]=0,c[8]=(B+N)*D,c[9]=(n-u)*D,c[10]=(1-(H+U))*D,c[11]=0,c[12]=P._x,c[13]=P._y,c[14]=P._z,c[15]=1,x.markAsUpdated(),x}static Identity(){const M=u.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return M._updateIdentityStatus(!0),M}static IdentityToRef(M){return u.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,M),M._updateIdentityStatus(!0),M}static Zero(){const M=u.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return M._updateIdentityStatus(!1),M}static RotationX(M){const Z=new u;return u.RotationXToRef(M,Z),Z}static Invert(M){const Z=new u;return M.invertToRef(Z),Z}static RotationXToRef(M,Z){const P=Math.sin(M),x=Math.cos(M);return u.FromValuesToRef(1,0,0,0,0,x,P,0,0,-P,x,0,0,0,0,1,Z),Z._updateIdentityStatus(1===x&&0===P),Z}static RotationY(M){const Z=new u;return u.RotationYToRef(M,Z),Z}static RotationYToRef(M,Z){const P=Math.sin(M),x=Math.cos(M);return u.FromValuesToRef(x,0,-P,0,0,1,0,0,P,0,x,0,0,0,0,1,Z),Z._updateIdentityStatus(1===x&&0===P),Z}static RotationZ(M){const Z=new u;return u.RotationZToRef(M,Z),Z}static RotationZToRef(M,Z){const P=Math.sin(M),x=Math.cos(M);return u.FromValuesToRef(x,P,0,0,-P,x,0,0,0,0,1,0,0,0,0,1,Z),Z._updateIdentityStatus(1===x&&0===P),Z}static RotationAxis(M,Z){const P=new u;return u.RotationAxisToRef(M,Z,P),P}static RotationAxisToRef(M,Z,P){const x=Math.sin(-Z),c=Math.cos(-Z),w=1-c;M=M.normalizeToRef(N.BZ[0]);const v=P.dc;return v[0]=M._x*M._x*w+c,v[1]=M._x*M._y*w-M._z*x,v[2]=M._x*M._z*w+M._y*x,v[3]=0,v[4]=M._y*M._x*w+M._z*x,v[5]=M._y*M._y*w+c,v[6]=M._y*M._z*w-M._x*x,v[7]=0,v[8]=M._z*M._x*w-M._y*x,v[9]=M._z*M._y*w+M._x*x,v[10]=M._z*M._z*w+c,v[11]=0,v[12]=0,v[13]=0,v[14]=0,v[15]=1,P.markAsUpdated(),P}static RotationAlignToRef(M,Z,P){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const w=U.Dot(Z,M),v=P.dc;if(w<-1+x.c)v[0]=-1,v[1]=0,v[2]=0,v[3]=0,v[4]=0,v[5]=c?1:-1,v[6]=0,v[7]=0,v[8]=0,v[9]=0,v[10]=c?-1:1,v[11]=0;else{const P=U.Cross(Z,M),x=1/(1+w);v[0]=P._x*P._x*x+w,v[1]=P._y*P._x*x-P._z,v[2]=P._z*P._x*x+P._y,v[3]=0,v[4]=P._x*P._y*x+P._z,v[5]=P._y*P._y*x+w,v[6]=P._z*P._y*x-P._x,v[7]=0,v[8]=P._x*P._z*x-P._y,v[9]=P._y*P._z*x+P._x,v[10]=P._z*P._z*x+w,v[11]=0}return v[12]=0,v[13]=0,v[14]=0,v[15]=1,P.markAsUpdated(),P}static RotationYawPitchRoll(M,Z,P){const x=new u;return u.RotationYawPitchRollToRef(M,Z,P,x),x}static RotationYawPitchRollToRef(M,Z,P,x){return L.RotationYawPitchRollToRef(M,Z,P,N.Quaternion[0]),N.Quaternion[0].toRotationMatrix(x),x}static Scaling(M,Z,P){const x=new u;return u.ScalingToRef(M,Z,P,x),x}static ScalingToRef(M,Z,P,x){return u.FromValuesToRef(M,0,0,0,0,Z,0,0,0,0,P,0,0,0,0,1,x),x._updateIdentityStatus(1===M&&1===Z&&1===P),x}static Translation(M,Z,P){const x=new u;return u.TranslationToRef(M,Z,P,x),x}static TranslationToRef(M,Z,P,x){return u.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,M,Z,P,1,x),x._updateIdentityStatus(0===M&&0===Z&&0===P),x}static Lerp(M,Z,P){const x=new u;return u.LerpToRef(M,Z,P,x),x}static LerpToRef(M,Z,P,x){const c=x.dc,w=M.m,v=Z.m;for(let G=0;G<16;G++)c[G]=w[G]*(1-P)+v[G]*P;return x.markAsUpdated(),x}static DecomposeLerp(M,Z,P){const x=new u;return u.DecomposeLerpToRef(M,Z,P,x),x}static DecomposeLerpToRef(M,Z,P,x){const c=N.BZ[0],w=N.Quaternion[0],v=N.BZ[1];M.decompose(c,w,v);const G=N.BZ[2],mM=N.Quaternion[1],K=N.BZ[3];Z.decompose(G,mM,K);const d=N.BZ[4];U.LerpToRef(c,G,P,d);const O=N.Quaternion[2];L.SlerpToRef(w,mM,P,O);const H=N.BZ[5];return U.LerpToRef(v,K,P,H),u.ComposeToRef(d,O,H,x),x}static LookAtLH(M,Z,P){const x=new u;return u.LookAtLHToRef(M,Z,P,x),x}static LookAtLHToRef(M,Z,P,x){const c=N.BZ[0],w=N.BZ[1],v=N.BZ[2];Z.subtractToRef(M,v),v.normalize(),U.CrossToRef(P,v,c);const G=c.lengthSquared();0===G?c.x=1:c.normalizeFromLength(Math.sqrt(G)),U.CrossToRef(v,c,w),w.normalize();const mM=-U.Dot(c,M),K=-U.Dot(w,M),d=-U.Dot(v,M);return u.FromValuesToRef(c._x,w._x,v._x,0,c._y,w._y,v._y,0,c._z,w._z,v._z,0,mM,K,d,1,x),x}static LookAtRH(M,Z,P){const x=new u;return u.LookAtRHToRef(M,Z,P,x),x}static LookAtRHToRef(M,Z,P,x){const c=N.BZ[0],w=N.BZ[1],v=N.BZ[2];M.subtractToRef(Z,v),v.normalize(),U.CrossToRef(P,v,c);const G=c.lengthSquared();0===G?c.x=1:c.normalizeFromLength(Math.sqrt(G)),U.CrossToRef(v,c,w),w.normalize();const mM=-U.Dot(c,M),K=-U.Dot(w,M),d=-U.Dot(v,M);return u.FromValuesToRef(c._x,w._x,v._x,0,c._y,w._y,v._y,0,c._z,w._z,v._z,0,mM,K,d,1,x),x}static LookDirectionLH(M,Z){const P=new u;return u.LookDirectionLHToRef(M,Z,P),P}static LookDirectionLHToRef(M,Z,P){const x=N.BZ[0];x.v(M),x.scaleInPlace(-1);const c=N.BZ[1];return U.CrossToRef(Z,x,c),u.FromValuesToRef(c._x,c._y,c._z,0,Z._x,Z._y,Z._z,0,x._x,x._y,x._z,0,0,0,0,1,P),P}static LookDirectionRH(M,Z){const P=new u;return u.LookDirectionRHToRef(M,Z,P),P}static LookDirectionRHToRef(M,Z,P){const x=N.BZ[2];return U.CrossToRef(Z,M,x),u.FromValuesToRef(x._x,x._y,x._z,0,Z._x,Z._y,Z._z,0,M._x,M._y,M._z,0,0,0,0,1,P),P}static OrthoLH(M,Z,P,x,c){const w=new u;return u.OrthoLHToRef(M,Z,P,x,w,c),w}static OrthoLHToRef(M,Z,P,x,c,w){const v=2/M,G=2/Z,mM=2/(x-P),K=-(x+P)/(x-P);return u.FromValuesToRef(v,0,0,0,0,G,0,0,0,0,mM,0,0,0,K,1,c),w&&c.multiplyToRef(t,c),c._updateIdentityStatus(1===v&&1===G&&1===mM&&0===K),c}static OrthoOffCenterLH(M,Z,P,x,c,w,v){const G=new u;return u.OrthoOffCenterLHToRef(M,Z,P,x,c,w,G,v),G}static OrthoOffCenterLHToRef(M,Z,P,x,c,w,v,G){const mM=2/(Z-M),K=2/(x-P),d=2/(w-c),O=-(w+c)/(w-c),H=(M+Z)/(M-Z),j=(x+P)/(P-x);return u.FromValuesToRef(mM,0,0,0,0,K,0,0,0,0,d,0,H,j,O,1,v),G&&v.multiplyToRef(t,v),v.markAsUpdated(),v}static ObliqueOffCenterLHToRef(M,Z,P,x,c,w,v,G,mM,K,d){const O=-v*Math.cos(G),H=-v*Math.sin(G);return u.TranslationToRef(0,0,-mM,N.Matrix[1]),u.FromValuesToRef(1,0,0,0,0,1,0,0,O,H,1,0,0,0,0,1,N.Matrix[0]),N.Matrix[1].multiplyToRef(N.Matrix[0],N.Matrix[0]),u.TranslationToRef(0,0,mM,N.Matrix[1]),N.Matrix[0].multiplyToRef(N.Matrix[1],N.Matrix[0]),u.OrthoOffCenterLHToRef(M,Z,P,x,c,w,K,d),N.Matrix[0].multiplyToRef(K,K),K}static OrthoOffCenterRH(M,Z,P,x,c,w,v){const G=new u;return u.OrthoOffCenterRHToRef(M,Z,P,x,c,w,G,v),G}static OrthoOffCenterRHToRef(M,Z,P,x,c,w,v,G){return u.OrthoOffCenterLHToRef(M,Z,P,x,c,w,v,G),v.dc[10]*=-1,v}static ObliqueOffCenterRHToRef(M,Z,P,x,c,w,v,G,mM,K,d){const O=v*Math.cos(G),H=v*Math.sin(G);return u.TranslationToRef(0,0,mM,N.Matrix[1]),u.FromValuesToRef(1,0,0,0,0,1,0,0,O,H,1,0,0,0,0,1,N.Matrix[0]),N.Matrix[1].multiplyToRef(N.Matrix[0],N.Matrix[0]),u.TranslationToRef(0,0,-mM,N.Matrix[1]),N.Matrix[0].multiplyToRef(N.Matrix[1],N.Matrix[0]),u.OrthoOffCenterRHToRef(M,Z,P,x,c,w,K,d),N.Matrix[0].multiplyToRef(K,K),K}static PerspectiveLH(M,Z,P,x,c){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const v=new u,G=2*P/M,mM=2*P/Z,K=(x+P)/(x-P),d=-2*x*P/(x-P),O=Math.tan(w);return u.FromValuesToRef(G,0,0,0,0,mM,0,O,0,0,K,1,0,0,d,0,v),c&&v.multiplyToRef(t,v),v._updateIdentityStatus(!1),v}static PerspectiveFovLH(M,Z,P,x,c){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,v=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const G=new u;return u.PerspectiveFovLHToRef(M,Z,P,x,G,!0,c,w,v),G}static PerspectiveFovLHToRef(M,Z,P,x,c){let w=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],v=arguments.length>6?arguments[6]:void 0,G=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,mM=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const K=P,d=x,O=1/Math.tan(.5*M),H=w?O/Z:O,j=w?O:O*Z,B=mM&&0===K?-1:0!==d?(d+K)/(d-K):1,U=mM&&0===K?2*d:0!==d?-2*d*K/(d-K):-2*K,n=Math.tan(G);return u.FromValuesToRef(H,0,0,0,0,j,0,n,0,0,B,1,0,0,U,0,c),v&&c.multiplyToRef(t,c),c._updateIdentityStatus(!1),c}static PerspectiveFovReverseLHToRef(M,Z,P,x,c){let w=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],v=arguments.length>6?arguments[6]:void 0,G=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const mM=1/Math.tan(.5*M),K=w?mM/Z:mM,d=w?mM:mM*Z,O=Math.tan(G);return u.FromValuesToRef(K,0,0,0,0,d,0,O,0,0,-P,1,0,0,1,0,c),v&&c.multiplyToRef(t,c),c._updateIdentityStatus(!1),c}static PerspectiveFovRH(M,Z,P,x,c){let w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,v=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const G=new u;return u.PerspectiveFovRHToRef(M,Z,P,x,G,!0,c,w,v),G}static PerspectiveFovRHToRef(M,Z,P,x,c){let w=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],v=arguments.length>6?arguments[6]:void 0,G=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,mM=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const K=P,d=x,O=1/Math.tan(.5*M),H=w?O/Z:O,j=w?O:O*Z,B=mM&&0===K?1:0!==d?-(d+K)/(d-K):-1,U=mM&&0===K?2*d:0!==d?-2*d*K/(d-K):-2*K,n=Math.tan(G);return u.FromValuesToRef(H,0,0,0,0,j,0,n,0,0,B,-1,0,0,U,0,c),v&&c.multiplyToRef(t,c),c._updateIdentityStatus(!1),c}static PerspectiveFovReverseRHToRef(M,Z,P,x,c){let w=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],v=arguments.length>6?arguments[6]:void 0,G=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const mM=1/Math.tan(.5*M),K=w?mM/Z:mM,d=w?mM:mM*Z,O=Math.tan(G);return u.FromValuesToRef(K,0,0,0,0,d,0,O,0,0,-P,-1,0,0,-1,0,c),v&&c.multiplyToRef(t,c),c._updateIdentityStatus(!1),c}static GetFinalMatrix(M,Z,P,x,c,w){const v=M.width,G=M.height,mM=M.x,K=M.y,d=u.FromValues(v/2,0,0,0,0,-G/2,0,0,0,0,w-c,0,mM+v/2,G/2+K,c,1),O=new u;return Z.multiplyToRef(P,O),O.multiplyToRef(x,O),O.multiplyToRef(d,O)}static GetAsMatrix2x2(M){const Z=M.m,P=[Z[0],Z[1],Z[4],Z[5]];return v.e.MatrixUse64Bits?P:new Float32Array(P)}static GetAsMatrix3x3(M){const Z=M.m,P=[Z[0],Z[1],Z[2],Z[4],Z[5],Z[6],Z[8],Z[9],Z[10]];return v.e.MatrixUse64Bits?P:new Float32Array(P)}static Transpose(M){const Z=new u;return u.TransposeToRef(M,Z),Z}static TransposeToRef(M,Z){const P=M.m,x=P[0],c=P[4],w=P[8],v=P[12],G=P[1],mM=P[5],K=P[9],d=P[13],O=P[2],H=P[6],j=P[10],B=P[14],U=P[3],n=P[7],L=P[11],u=P[15],N=Z.dc;return N[0]=x,N[1]=c,N[2]=w,N[3]=v,N[4]=G,N[5]=mM,N[6]=K,N[7]=d,N[8]=O,N[9]=H,N[10]=j,N[11]=B,N[12]=U,N[13]=n,N[14]=L,N[15]=u,Z.markAsUpdated(),Z._updateIdentityStatus(M._isIdentity,M._isIdentityDirty),Z}static Reflection(M){const Z=new u;return u.ReflectionToRef(M,Z),Z}static ReflectionToRef(M,Z){M.normalize();const P=M.normal.x,x=M.normal.y,c=M.normal.z,w=-2*P,v=-2*x,G=-2*c;return u.FromValuesToRef(w*P+1,v*P,G*P,0,w*x,v*x+1,G*x,0,w*c,v*c,G*c+1,0,w*M.d,v*M.d,G*M.d,1,Z),Z}static FromXYZAxesToRef(M,Z,P,x){return u.FromValuesToRef(M._x,M._y,M._z,0,Z._x,Z._y,Z._z,0,P._x,P._y,P._z,0,0,0,0,1,x),x}static FromQuaternionToRef(M,Z){const P=M._x*M._x,x=M._y*M._y,c=M._z*M._z,w=M._x*M._y,v=M._z*M._w,G=M._z*M._x,mM=M._y*M._w,K=M._y*M._z,d=M._x*M._w;return Z.dc[0]=1-2*(x+c),Z.dc[1]=2*(w+v),Z.dc[2]=2*(G-mM),Z.dc[3]=0,Z.dc[4]=2*(w-v),Z.dc[5]=1-2*(c+P),Z.dc[6]=2*(K+d),Z.dc[7]=0,Z.dc[8]=2*(G+mM),Z.dc[9]=2*(K-d),Z.dc[10]=1-2*(x+P),Z.dc[11]=0,Z.dc[12]=0,Z.dc[13]=0,Z.dc[14]=0,Z.dc[15]=1,Z.markAsUpdated(),Z}}u._IdentityReadOnly=u.Identity(),Object.defineProperties(u.prototype,{dimension:{value:[4,4]},rank:{value:2}});class N{}N.BZ=(0,c.g)(11,U.Zero),N.Matrix=(0,c.g)(2,u.Identity),N.Quaternion=(0,c.g)(3,L.Zero);class J{}J.Vector2=(0,c.g)(3,B.Zero),J.BZ=(0,c.g)(13,U.Zero),J.Vector4=(0,c.g)(3,n.Zero),J.Quaternion=(0,c.g)(3,L.Zero),J.Matrix=(0,c.g)(8,u.Identity),(0,w.g)("BABYLON.Vector2",B),(0,w.g)("BABYLON.Vector3",U),(0,w.g)("BABYLON.Vector4",n),(0,w.g)("BABYLON.Matrix",u);const t=u.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12379:(M,Z,P)=>{function x(M,Z){const P=[];for(let x=0;x<M;++x)P.push(Z());return P}function c(M,Z){return x(M,Z)}P.d(Z,{c:()=>x,g:()=>c,i:()=>v});const w=["push","splice","pop","shift","unshift"];function v(M,Z){const P=w.map((P=>function(M,Z,P){const x=M[Z];if("function"!==typeof x)return null;const c=function(){const x=M.length,w=c.previous.apply(M,arguments);return P(Z,x),w};return x.next=c,c.previous=x,M[Z]=c,()=>{const P=c.previous;if(!P)return;const x=c.next;x?(P.next=x,x.previous=P):(P.next=void 0,M[Z]=P),c.next=void 0,c.previous=void 0}}(M,P,Z)));return()=>{for(const M of P)null===M||void 0===M||M()}}}}]);