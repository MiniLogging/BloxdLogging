"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[14],{2460:(a,x,Q)=>{Q.r(x),Q.d(x,{_ExrTextureLoader:()=>w});var s=Q(507),h=Q(699);const D=65536,N=14,C=65537,R=16384;var U,W;!function(a){a[a.NO_COMPRESSION=0]="NO_COMPRESSION",a[a.RLE_COMPRESSION=1]="RLE_COMPRESSION",a[a.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",a[a.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",a[a.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",a[a.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(U||(U={})),function(a){a[a.INCREASING_Y=0]="INCREASING_Y",a[a.DECREASING_Y=1]="DECREASING_Y"}(W||(W={}));const v=function(){const a=new ArrayBuffer(4),x=new Float32Array(a),Q=new Uint32Array(a),s=new Uint32Array(512),h=new Uint32Array(512);for(let R=0;R<256;++R){const a=R-127;a<-27?(s[R]=0,s[256|R]=32768,h[R]=24,h[256|R]=24):a<-14?(s[R]=1024>>-a-14,s[256|R]=1024>>-a-14|32768,h[R]=-a-1,h[256|R]=-a-1):a<=15?(s[R]=a+15<<10,s[256|R]=a+15<<10|32768,h[R]=13,h[256|R]=13):a<128?(s[R]=31744,s[256|R]=64512,h[R]=24,h[256|R]=24):(s[R]=31744,s[256|R]=64512,h[R]=13,h[256|R]=13)}const D=new Uint32Array(2048),N=new Uint32Array(64),C=new Uint32Array(64);for(let R=1;R<1024;++R){let a=R<<13,x=0;for(;0===(8388608&a);)a<<=1,x-=8388608;a&=-8388609,x+=947912704,D[R]=a|x}for(let R=1024;R<2048;++R)D[R]=939524096+(R-1024<<13);for(let R=1;R<31;++R)N[R]=R<<23;N[31]=1199570944,N[32]=2147483648;for(let R=33;R<63;++R)N[R]=2147483648+(R-32<<23);N[63]=3347054592;for(let R=1;R<64;++R)32!==R&&(C[R]=1024);return{floatView:x,uint32View:Q,baseTable:s,shiftTable:h,mantissaTable:D,exponentTable:N,offsetTable:C}}();function e(a,x){const Q=new Uint8Array(a);let s=0;for(;0!=Q[x.value+s];)s+=1;const h=(new TextDecoder).decode(Q.slice(x.value,x.value+s));return x.value=x.value+s+1,h}function p(a,x){const Q=a.getInt32(x.value,!0);return x.value+=4,Q}function j(a,x){const Q=a.getUint32(x.value,!0);return x.value+=4,Q}function H(a,x){const Q=a.getUint8(x.value);return x.value+=1,Q}function d(a,x){const Q=a.getUint16(x.value,!0);return x.value+=2,Q}function i(a,x){const Q=a[x.value];return x.value+=1,Q}function Z(a,x){let Q;return Q="getBigInt64"in DataView.prototype?Number(a.getBigInt64(x.value,!0)):a.getUint32(x.value+4,!0)+Number(a.getUint32(x.value,!0)<<32),x.value+=8,Q}function y(a,x){const Q=a.getFloat32(x.value,!0);return x.value+=4,Q}function k(a,x){return function(a){const x=(31744&a)>>10,Q=1023&a;return(a>>15?-1:1)*(x?31===x?Q?NaN:1/0:Math.pow(2,x-15)*(1+Q/1024):Q/1024*6103515625e-14)}(d(a,x))}function F(a,x){return function(a){if(Math.abs(a)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");a=(0,h.c)(a,-65504,65504),v.floatView[0]=a;const x=v.uint32View[0],Q=x>>23&511;return v.baseTable[Q]+((8388607&x)>>v.shiftTable[Q])}(y(a,x))}function g(a,x,Q,s){switch(Q){case"string":case"stringvector":case"iccProfile":return function(a,x,Q){const s=(new TextDecoder).decode(new Uint8Array(a).slice(x.value,x.value+Q));return x.value=x.value+Q,s}(a.buffer,x,s);case"chlist":return function(a,x,Q){const s=x.value,h=[];for(;x.value<s+Q-1;){const Q=e(a.buffer,x),s=p(a,x),D=H(a,x);x.value+=3;const N=p(a,x),C=p(a,x);h.push({name:Q,pixelType:s,pLinear:D,xSampling:N,ySampling:C})}return x.value+=1,h}(a,x,s);case"chromaticities":return function(a,x){return{redX:y(a,x),redY:y(a,x),greenX:y(a,x),greenY:y(a,x),blueX:y(a,x),blueY:y(a,x),whiteX:y(a,x),whiteY:y(a,x)}}(a,x);case"compression":return function(a,x){return H(a,x)}(a,x);case"box2i":return function(a,x){return{xMin:p(a,x),yMin:p(a,x),xMax:p(a,x),yMax:p(a,x)}}(a,x);case"lineOrder":return function(a,x){const Q=H(a,x);return W[Q]}(a,x);case"float":return y(a,x);case"v2f":return function(a,x){return[y(a,x),y(a,x)]}(a,x);case"v3f":return function(a,x){return[y(a,x),y(a,x),y(a,x)]}(a,x);case"int":return p(a,x);case"rational":return function(a,x){return[p(a,x),j(a,x)]}(a,x);case"timecode":return function(a,x){return[j(a,x),j(a,x)]}(a,x);case"preview":return x.value+=s,"skipped";default:return void(x.value+=s)}}function l(a){for(let x=1;x<a.length;x++){const Q=a[x-1]+a[x]-128;a[x]=Q}}function r(a,x){let Q=0,s=Math.floor((a.length+1)/2),h=0;const D=a.length-1;for(;!(h>D)&&(x[h++]=a[Q++],!(h>D));)x[h++]=a[s++]}function J(a,x,Q,s,h){for(;Q<a;)x=x<<8|i(s,h),Q+=8;return{l:x>>(Q-=a)&(1<<a)-1,c:x,lc:Q}}function K(a,x,Q,s){return{c:a=a<<8|i(Q,s),lc:x+=8}}function E(a,x,Q,s,h,D,N,C,R){if(a==x){if(s<8){const a=K(Q,s,h,D);Q=a.c,s=a.lc}let a=Q>>(s-=8);if(a=new Uint8Array([a])[0],C.value+a>R)return null;const x=N[C.value-1];for(;a-- >0;)N[C.value++]=x}else{if(!(C.value<R))return null;N[C.value++]=a}return{c:Q,lc:s}}const G=new Array(59);function T(a,x,Q,s,h,D){const N=x;let R=0,U=0;for(;s<=h;s++){if(N.value-x.value>Q)return;let C=J(6,R,U,a,N);const W=C.l;if(R=C.c,U=C.lc,D[s]=W,63==W){if(N.value-x.value>Q)throw new Error("Error in HufUnpackEncTable");C=J(8,R,U,a,N);let W=C.l+6;if(R=C.c,U=C.lc,s+W>h+1)throw new Error("Error in HufUnpackEncTable");for(;W--;)D[s++]=0;s--}else if(W>=59){let a=W-59+2;if(s+a>h+1)throw new Error("Error in HufUnpackEncTable");for(;a--;)D[s++]=0;s--}}!function(a){for(let Q=0;Q<=58;++Q)G[Q]=0;for(let Q=0;Q<C;++Q)G[a[Q]]+=1;let x=0;for(let Q=58;Q>0;--Q){const a=x+G[Q]>>1;G[Q]=x,x=a}for(let Q=0;Q<C;++Q){const x=a[Q];x>0&&(a[Q]=x|G[x]++<<6)}}(D)}function L(a){return 63&a}function b(a){return a>>6}function Y(a,x,Q,s,h,D){const U=Q.value,W=j(x,Q),v=j(x,Q);Q.value+=4;const e=j(x,Q);if(Q.value+=4,W<0||W>=C||v<0||v>=C)throw new Error("Wrong HUF_ENCSIZE");const p=new Array(C),H=new Array(R);!function(a){for(let x=0;x<R;x++)a[x]={},a[x].len=0,a[x].lit=0,a[x].p=null}(H);if(T(a,Q,s-(Q.value-U),W,v,p),e>8*(s-(Q.value-U)))throw new Error("Wrong hufUncompress");!function(a,x,Q,s){for(;x<=Q;x++){const Q=b(a[x]),h=L(a[x]);if(Q>>h)throw new Error("Invalid table entry");if(h>N){const a=s[Q>>h-N];if(a.len)throw new Error("Invalid table entry");if(a.lit++,a.p){const x=a.p;a.p=new Array(a.lit);for(let Q=0;Q<a.lit-1;++Q)a.p[Q]=x[Q]}else a.p=new Array(1);a.p[a.lit-1]=x}else if(h){let a=0;for(let D=1<<N-h;D>0;D--){const D=s[(Q<<N-h)+a];if(D.len||D.p)throw new Error("Invalid table entry");D.len=h,D.lit=x,a++}}}}(p,W,v,H),function(a,x,Q,s,h,D,C,R,U){let W=0,v=0;const e=C,p=Math.trunc(s.value+(h+7)/8);for(;s.value<p;){let h=K(W,v,Q,s);for(W=h.c,v=h.lc;v>=N;){const C=x[W>>v-N&16383];if(C.len){v-=C.len;const a=E(C.lit,D,W,v,Q,s,R,U,e);a&&(W=a.c,v=a.lc)}else{if(!C.p)throw new Error("hufDecode issues");let x;for(x=0;x<C.lit;x++){const N=L(a[C.p[x]]);for(;v<N&&s.value<p;)h=K(W,v,Q,s),W=h.c,v=h.lc;if(v>=N&&b(a[C.p[x]])==(W>>v-N&(1<<N)-1)){v-=N;const a=E(C.p[x],D,W,v,Q,s,R,U,e);a&&(W=a.c,v=a.lc);break}}if(x==C.lit)throw new Error("HufDecode issues")}}}const j=8-h&7;for(W>>=j,v-=j;v>0;){const a=x[W<<N-v&16383];if(!a.len)throw new Error("HufDecode issues");{v-=a.len;const x=E(a.lit,D,W,v,Q,s,R,U,e);x&&(W=x.c,v=x.lc)}}}(p,H,a,Q,e,v,D,h,{value:0})}function q(a){return 65535&a}function t(a){const x=q(a);return x>32767?x-65536:x}function V(a,x){const Q=t(a),s=t(x),h=Q+(1&s)+(s>>1);return{a:h,b:h-s}}function f(a,x){const Q=q(a),s=q(x),h=Q-(s>>1)&65535;return{a:s+h-32768&65535,b:h}}function n(a,x,Q,s,h,D,N){const C=N<16384,R=Q>h?h:Q;let U,W,v=1;for(;v<=R;)v<<=1;for(v>>=1,U=v,v>>=1;v>=1;){W=0;const N=W+D*(h-U),R=D*v,e=D*U,p=s*v,j=s*U;let H,d,i,Z;for(;W<=N;W+=e){let h=W;const D=W+s*(Q-U);for(;h<=D;h+=j){const Q=h+p,s=h+R,D=s+p;if(C){let N=V(a[h+x],a[s+x]);H=N.a,i=N.b,N=V(a[Q+x],a[D+x]),d=N.a,Z=N.b,N=V(H,d),a[h+x]=N.a,a[Q+x]=N.b,N=V(i,Z),a[s+x]=N.a,a[D+x]=N.b}else{let N=f(a[h+x],a[s+x]);H=N.a,i=N.b,N=f(a[Q+x],a[D+x]),d=N.a,Z=N.b,N=f(H,d),a[h+x]=N.a,a[Q+x]=N.b,N=f(i,Z),a[s+x]=N.a,a[D+x]=N.b}}if(Q&v){const Q=h+R;let s;s=C?V(a[h+x],a[Q+x]):f(a[h+x],a[Q+x]),H=s.a,a[Q+x]=s.b,a[h+x]=H}}if(h&v){let h=W;const D=W+s*(Q-U);for(;h<=D;h+=j){const Q=h+p;let s;s=C?V(a[h+x],a[Q+x]):f(a[h+x],a[Q+x]),H=s.a,a[Q+x]=s.b,a[h+x]=H}}U=v,v>>=1}return W}function m(a){return new DataView(a.array.buffer,a.offset.value,a.size)}function S(a){const x=a.viewer.buffer.slice(a.offset.value,a.offset.value+a.size),Q=new Uint8Array(function(a){let x=a.byteLength;const Q=new Array;let s=0;const h=new DataView(a);for(;x>0;){const a=h.getInt8(s++);if(a<0){const D=-a;x-=D+1;for(let a=0;a<D;a++)Q.push(h.getUint8(s++))}else{const D=a;x-=2;const N=h.getUint8(s++);for(let a=0;a<D+1;a++)Q.push(N)}}return Q}(x)),s=new Uint8Array(Q.length);return l(Q),r(Q,s),new DataView(s.buffer)}function z(a){const x=a.array.slice(a.offset.value,a.offset.value+a.size),Q=fflate.unzlibSync(x),s=new Uint8Array(Q.length);return l(Q),r(Q,s),new DataView(s.buffer)}function M(a){const x=a.array.slice(a.offset.value,a.offset.value+a.size),Q=fflate.unzlibSync(x),s=a.lines*a.channels*a.width,h=1==a.type?new Uint16Array(s):new Uint32Array(s);let D=0,N=0;const C=new Array(4);for(let R=0;R<a.lines;R++)for(let x=0;x<a.channels;x++){let x=0;switch(a.type){case 1:C[0]=D,C[1]=C[0]+a.width,D=C[1]+a.width;for(let s=0;s<a.width;++s){x+=Q[C[0]++]<<8|Q[C[1]++],h[N]=x,N++}break;case 2:C[0]=D,C[1]=C[0]+a.width,C[2]=C[1]+a.width,D=C[2]+a.width;for(let s=0;s<a.width;++s){x+=Q[C[0]++]<<24|Q[C[1]++]<<16|Q[C[2]++]<<8,h[N]=x,N++}}}return new DataView(h.buffer)}function O(a){const x=a.viewer,Q={value:a.offset.value},s=new Uint16Array(a.width*a.scanlineBlockSize*(a.channels*a.type)),h=new Uint8Array(8192);let N=0;const C=new Array(a.channels);for(let D=0;D<a.channels;D++)C[D]={},C[D].start=N,C[D].end=C[D].start,C[D].nx=a.width,C[D].ny=a.lines,C[D].size=a.type,N+=C[D].nx*C[D].ny*C[D].size;const R=d(x,Q),U=d(x,Q);if(U>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(R<=U)for(let D=0;D<U-R+1;D++)h[D+R]=H(x,Q);const W=new Uint16Array(D),v=function(a,x){let Q=0;for(let h=0;h<D;++h)(0==h||a[h>>3]&1<<(7&h))&&(x[Q++]=h);const s=Q-1;for(;Q<D;)x[Q++]=0;return s}(h,W),e=j(x,Q);Y(a.array,x,Q,e,s,N);for(let D=0;D<a.channels;++D){const a=C[D];for(let x=0;x<C[D].size;++x)n(s,a.start+x,a.nx,a.size,a.ny,a.nx*a.size,v)}!function(a,x,Q){for(let s=0;s<Q;++s)x[s]=a[x[s]]}(W,s,N);let p=0;const i=new Uint8Array(s.buffer.byteLength);for(let D=0;D<a.lines;D++)for(let x=0;x<a.channels;x++){const a=C[x],Q=a.nx*a.size,h=new Uint8Array(s.buffer,2*a.end,2*Q);i.set(h,p),p+=2*Q,a.end+=Q}return new DataView(i.buffer)}var I,B=Q(496);!function(a){a[a.Float=0]="Float",a[a.HalfFloat=1]="HalfFloat"}(I||(I={}));class P{}P.DefaultOutputType=I.HalfFloat,P.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class w{constructor(){this.supportCascades=!1}loadCubeData(a,x,Q,s,h){throw".exr not supported in Cube."}async loadData(a,x,Q){const h=new DataView(a.buffer),D={value:0},N=function(a,x){if(20000630!=a.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const Q=a.getUint8(4),h=a.getUint8(5),D={singleTile:!!(2&h),longName:!!(4&h),deepFormat:!!(8&h),multiPart:!!(16&h)};x.value=8;const N={};let C=!0;for(;C;){const Q=e(a.buffer,x);if(Q){const h=e(a.buffer,x),D=g(a,x,h,j(a,x));void 0===D?s.d.Warn(`Unknown header attribute type ${h}'.`):N[Q]=D}else C=!1}if(0!=(-5&h))throw new Error("Unsupported file format");return{version:Q,spec:D,...N}}(h,D),C=await async function(a,x,Q,s){const h={size:0,viewer:x,array:new Uint8Array(x.buffer),offset:Q,width:a.dataWindow.xMax-a.dataWindow.xMin+1,height:a.dataWindow.yMax-a.dataWindow.yMin+1,channels:a.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(a.compression){case U.NO_COMPRESSION:h.lines=1,h.uncompress=m;break;case U.RLE_COMPRESSION:h.lines=1,h.uncompress=S;break;case U.ZIPS_COMPRESSION:h.lines=1,h.uncompress=z,await B.g.LoadScriptAsync(P.FFLATEUrl);break;case U.ZIP_COMPRESSION:h.lines=16,h.uncompress=z,await B.g.LoadScriptAsync(P.FFLATEUrl);break;case U.PIZ_COMPRESSION:h.lines=32,h.uncompress=O;break;case U.PXR24_COMPRESSION:h.lines=16,h.uncompress=M,await B.g.LoadScriptAsync(P.FFLATEUrl);break;default:throw new Error(U[a.compression]+" is unsupported")}h.scanlineBlockSize=h.lines;const D={};for(const U of a.channels)switch(U.name){case"Y":case"R":case"G":case"B":case"A":D[U.name]=!0,h.type=U.pixelType}let N=!1;if(D.R&&D.G&&D.B)N=!D.A,h.outputChannels=4,h.decodeChannels={R:0,G:1,B:2,A:3};else{if(!D.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");h.outputChannels=1,h.decodeChannels={Y:0}}if(1===h.type)switch(s){case I.Float:h.getter=k,h.inputSize=2;break;case I.HalfFloat:h.getter=d,h.inputSize=2}else{if(2!==h.type)throw new Error("Unsupported pixelType "+h.type+" for "+a.compression);switch(s){case I.Float:h.getter=y,h.inputSize=4;break;case I.HalfFloat:h.getter=F,h.inputSize=4}}h.blockCount=h.height/h.scanlineBlockSize;for(let U=0;U<h.blockCount;U++)Z(x,Q);const C=h.width*h.height*h.outputChannels;switch(s){case I.Float:h.byteArray=new Float32Array(C),h.textureType=1,N&&h.byteArray.fill(1,0,C);break;case I.HalfFloat:h.byteArray=new Uint16Array(C),h.textureType=2,N&&h.byteArray.fill(15360,0,C);break;default:throw new Error("Unsupported type: "+s)}let R=0;for(const U of a.channels)void 0!==h.decodeChannels[U.name]&&(h.channelLineOffsets[U.name]=R*h.width),R+=2*U.pixelType;return h.bytesPerLine=h.width*R,h.outLineWidth=h.width*h.outputChannels,"INCREASING_Y"===a.lineOrder?h.scanOrder=a=>a:h.scanOrder=a=>h.height-1-a,4==h.outputChannels?(h.format=5,h.linearSpace=!0):(h.format=6,h.linearSpace=!1),h}(N,h,D,P.DefaultOutputType);!function(a,x,Q,s){const h={value:0};for(let D=0;D<a.height/a.scanlineBlockSize;D++){const N=p(Q,s)-x.dataWindow.yMin;a.size=j(Q,s),a.lines=N+a.scanlineBlockSize>a.height?a.height-N:a.scanlineBlockSize;const C=a.size<a.lines*a.bytesPerLine&&a.uncompress?a.uncompress(a):m(a);s.value+=a.size;for(let Q=0;Q<a.scanlineBlockSize;Q++){const s=D*a.scanlineBlockSize,N=Q+a.scanOrder(s);if(N>=a.height)continue;const R=Q*a.bytesPerLine,U=(a.height-1-N)*a.outLineWidth;for(let Q=0;Q<a.channels;Q++){const s=x.channels[Q].name,D=a.channelLineOffsets[s],N=a.decodeChannels[s];if(void 0!==N){h.value=R+D;for(let x=0;x<a.width;x++){const Q=U+x*a.outputChannels+N;a.byteArray&&(a.byteArray[Q]=a.getter(C,h))}}}}}}(C,N,h,D);Q(N.dataWindow.xMax-N.dataWindow.xMin+1,N.dataWindow.yMax-N.dataWindow.yMin+1,x.generateMipMaps,!1,(()=>{const a=x.getEngine();x.format=N.format,x.type=C.textureType,x.invertY=!1,x._gammaSpace=!N.linearSpace,C.byteArray&&a._uploadDataToTextureDirectly(x,C.byteArray,0,0,void 0,!0)}))}}}}]);