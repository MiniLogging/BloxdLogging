"use strict";(self.g111kvdsqxc=self.g111kvdsqxc||[]).push([[14],{11297:(K,H,M)=>{M.d(H,{d:()=>y,e:()=>u,h:()=>q,l:()=>w});const q=1/2.2,w=2.2,u=(1+Math.sqrt(5))/2,y=.001},11307:(K,H,M)=>{function q(K){return parseInt(K.toString().replace(/\W/g,""))}function w(K,H){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(K-H)<=M}function u(K,H,M){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return K<H-q||K>M+q}function y(K,H){return K===H?K:Math.random()*(H-K)+K}function h(K,H,M){return K+(H-K)*M}function W(K,H,M){let q=L(H-K,360);return q>180&&(q-=360),K+q*G(M)}function I(K,H,M){let q=0;return q=K!=H?G((M-K)/(H-K)):0,q}function f(K,H,M,q,w){const u=w*w,y=w*u;return K*(2*y-3*u+1)+M*(-2*y+3*u)+H*(y-2*u+w)+q*(y-u)}function z(K,H,M,q,w){const u=w*w;return 6*(u-w)*K+(3*u-4*w+1)*H+6*(-u+w)*M+(3*u-2*w)*q}function G(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(M,Math.max(H,K))}function a(K){return K-=2*Math.PI*Math.floor((K+Math.PI)/(2*Math.PI))}function v(K){const H=K.toString(16);return K<=15?("0"+H).toUpperCase():H.toUpperCase()}function O(K){if(Math.log2)return Math.floor(Math.log2(K));if(K<0)return NaN;if(0===K)return-1/0;let H=0;if(K<1){for(;K<1;)H++,K*=2;H=-H}else if(K>1)for(;K>1;)H++,K=Math.floor(K/2);return H}function L(K,H){return K-Math.floor(K/H)*H}function S(K,H,M){return(K-H)/(M-H)}function B(K,H,M){return K*(M-H)+H}function C(K,H){let M=L(H-K,360);return M>180&&(M-=360),M}function i(K,H){const M=L(K,2*H);return H-Math.abs(M-H)}function Z(K,H,M){let q=G(M);return q=-2*q*q*q+3*q*q,H*q+K*(1-q)}function E(K,H,M){let q=0;return q=Math.abs(H-K)<=M?H:K+Math.sign(H-K)*M,q}function l(K,H,M){const q=C(K,H);let w=0;return w=-M<q&&q<M?H:E(K,H=K+q,M),w}function s(K,H,M){return(K-H)/(M-H)}function D(K,H,M){return(M-H)*K+H}function V(K,H){const M=K%H;return 0===M?H:V(H,M)}M.r(H),M.d(H,{Clamp:()=>G,DeltaAngle:()=>C,Denormalize:()=>B,ExtractAsInt:()=>q,Hermite:()=>f,Hermite1stDerivative:()=>z,HighestCommonFactor:()=>V,ILog2:()=>O,InverseLerp:()=>I,Lerp:()=>h,LerpAngle:()=>W,MoveTowards:()=>E,MoveTowardsAngle:()=>l,Normalize:()=>S,NormalizeRadians:()=>a,OutsideRange:()=>u,PercentToRange:()=>D,PingPong:()=>i,RandomRange:()=>y,RangeToPercent:()=>s,Repeat:()=>L,SmoothStep:()=>Z,ToHex:()=>v,WithinEpsilon:()=>w})},11290:(K,H,M)=>{M.r(H),M.d(H,{Matrix:()=>B,Quaternion:()=>S,TmpVectors:()=>i,Vector2:()=>v,OH:()=>O,Vector4:()=>L});var q=M(11297),w=M(11301),u=M(11242),y=M(11212),h=M(11143),W=M(11307);class I{}function f(K,H,M){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const w=K.hh(),u=H.hh(),y=w[0],h=w[1],W=w[2],I=w[3],f=w[4],z=w[5],G=w[6],a=w[7],v=w[8],O=w[9],L=w[10],S=w[11],B=w[12],C=w[13],i=w[14],Z=w[15],E=u[0],l=u[1],s=u[2],D=u[3],V=u[4],n=u[5],c=u[6],k=u[7],T=u[8],d=u[9],x=u[10],Q=u[11],J=u[12],N=u[13],p=u[14],o=u[15];M[q]=y*E+h*V+W*T+I*J,M[q+1]=y*l+h*n+W*d+I*N,M[q+2]=y*s+h*c+W*x+I*p,M[q+3]=y*D+h*k+W*Q+I*o,M[q+4]=f*E+z*V+G*T+a*J,M[q+5]=f*l+z*n+G*d+a*N,M[q+6]=f*s+z*c+G*x+a*p,M[q+7]=f*D+z*k+G*Q+a*o,M[q+8]=v*E+O*V+L*T+S*J,M[q+9]=v*l+O*n+L*d+S*N,M[q+10]=v*s+O*c+L*x+S*p,M[q+11]=v*D+O*k+L*Q+S*o,M[q+12]=B*E+C*V+i*T+Z*J,M[q+13]=B*l+C*n+i*d+Z*N,M[q+14]=B*s+C*c+i*x+Z*p,M[q+15]=B*D+C*k+i*Q+Z*o}function z(K,H){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const q=K.hh();H[M]=q[0],H[M+1]=q[1],H[M+2]=q[2],H[M+3]=q[3],H[M+4]=q[4],H[M+5]=q[5],H[M+6]=q[6],H[M+7]=q[7],H[M+8]=q[8],H[M+9]=q[9],H[M+10]=q[10],H[M+11]=q[11],H[M+12]=q[12],H[M+13]=q[13],H[M+14]=q[14],H[M+15]=q[15]}function G(K,H){const M=K.hh(),q=M[0],w=M[1],u=M[2],y=M[3],h=M[4],W=M[5],I=M[6],f=M[7],z=M[8],G=M[9],a=M[10],v=M[11],O=M[12],L=M[13],S=M[14],B=M[15],C=a*B-S*v,i=G*B-L*v,Z=G*S-L*a,E=z*B-O*v,l=z*S-a*O,s=z*L-O*G,D=+(W*C-I*i+f*Z),V=-(h*C-I*E+f*l),n=+(h*i-W*E+f*s),c=-(h*Z-W*l+I*s),k=q*D+w*V+u*n+y*c;if(0===k)return!1;const T=1/k,d=I*B-S*f,x=W*B-L*f,Q=W*S-L*I,J=h*B-O*f,N=h*S-O*I,p=h*L-O*W,o=I*v-a*f,R=W*v-G*f,t=W*a-G*I,U=h*v-z*f,j=h*a-z*I,m=h*G-z*W,F=-(w*C-u*i+y*Z),Y=+(q*C-u*E+y*l),r=-(q*i-w*E+y*s),e=+(q*Z-w*l+u*s),b=+(w*d-u*x+y*Q),P=-(q*d-u*J+y*N),g=+(q*x-w*J+y*p),X=-(q*Q-w*N+u*p),A=-(w*o-u*R+y*t),KK=+(q*o-u*U+y*j),HK=-(q*R-w*U+y*m),MK=+(q*t-w*j+u*m);return H[0]=D*T,H[1]=F*T,H[2]=b*T,H[3]=A*T,H[4]=V*T,H[5]=Y*T,H[6]=P*T,H[7]=KK*T,H[8]=n*T,H[9]=r*T,H[10]=g*T,H[11]=HK*T,H[12]=c*T,H[13]=e*T,H[14]=X*T,H[15]=MK*T,!0}I._UpdateFlagSeed=0;const a=K=>parseInt(K.toString().replace(/\W/g,""));class v{constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=K,this.y=H}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let K=a(this.x);return K=397*K^a(this.y),K}toArray(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[H]=this.x,K[H+1]=this.y,this}aM(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return v.FromArrayToRef(K,H,this),this}hh(){return[this.x,this.y]}q(K){return this.x=K.x,this.y=K.y,this}Lh(K,H){return this.x=K,this.y=H,this}set(K,H){return this.Lh(K,H)}Bh(K){return this.Lh(K,K)}add(K){return new v(this.x+K.x,this.y+K.y)}addToRef(K,H){return H.x=this.x+K.x,H.y=this.y+K.y,H}addInPlace(K){return this.x+=K.x,this.y+=K.y,this}addInPlaceFromFloats(K,H){return this.x+=K,this.y+=H,this}addVector3(K){return new v(this.x+K.x,this.y+K.y)}LH(K){return new v(this.x-K.x,this.y-K.y)}subtractToRef(K,H){return H.x=this.x-K.x,H.y=this.y-K.y,H}Zz(K){return this.x-=K.x,this.y-=K.y,this}multiplyInPlace(K){return this.x*=K.x,this.y*=K.y,this}multiply(K){return new v(this.x*K.x,this.y*K.y)}multiplyToRef(K,H){return H.x=this.x*K.x,H.y=this.y*K.y,H}multiplyByFloats(K,H){return new v(this.x*K,this.y*H)}divide(K){return new v(this.x/K.x,this.y/K.y)}divideToRef(K,H){return H.x=this.x/K.x,H.y=this.y/K.y,H}divideInPlace(K){return this.x=this.x/K.x,this.y=this.y/K.y,this}minimizeInPlace(K){return this.minimizeInPlaceFromFloats(K.x,K.y)}maximizeInPlace(K){return this.maximizeInPlaceFromFloats(K.x,K.y)}minimizeInPlaceFromFloats(K,H){return this.x=Math.min(K,this.x),this.y=Math.min(H,this.y),this}maximizeInPlaceFromFloats(K,H){return this.x=Math.max(K,this.x),this.y=Math.max(H,this.y),this}subtractFromFloats(K,H){return new v(this.x-K,this.y-H)}subtractFromFloatsToRef(K,H,M){return M.x=this.x-K,M.y=this.y-H,M}negate(){return new v(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(K){return K.x=-this.x,K.y=-this.y,K}scaleInPlace(K){return this.x*=K,this.y*=K,this}scale(K){return new v(this.x*K,this.y*K)}scaleToRef(K,H){return H.x=this.x*K,H.y=this.y*K,H}scaleAndAddToRef(K,H){return H.x+=this.x*K,H.y+=this.y*K,H}equals(K){return K&&this.x===K.x&&this.y===K.y}equalsWithEpsilon(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.d;return K&&(0,W.WithinEpsilon)(this.x,K.x,H)&&(0,W.WithinEpsilon)(this.y,K.y,H)}equalsToFloats(K,H){return this.x===K&&this.y===H}floor(){return new v(Math.floor(this.x),Math.floor(this.y))}floorToRef(K){return K.x=Math.floor(this.x),K.y=Math.floor(this.y),K}fract(){return new v(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(K){return K.x=this.x-Math.floor(this.x),K.y=this.y-Math.floor(this.y),K}rotate(K){return this.rotateToRef(K,new v)}rotateToRef(K,H){const M=Math.cos(K),q=Math.sin(K);return H.x=M*this.x-q*this.y,H.y=q*this.x+M*this.y,H}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){const K=new v;return this.normalizeToRef(K),K}normalizeToRef(K){const H=this.length();return 0===H&&(K.x=this.x,K.y=this.y),this.scaleToRef(1/H,K)}clone(){return new v(this.x,this.y)}dot(K){return this.x*K.x+this.y*K.y}static Zero(){return new v(0,0)}static One(){return new v(1,1)}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new v((0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Lh((0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H))}static get ZeroReadOnly(){return v._ZeroReadOnly}static iH(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new v(K[H],K[H+1])}static FromArrayToRef(K,H,M){return M.x=K[H],M.y=K[H+1],M}static FromFloatsToRef(K,H,M){return M.Lh(K,H),M}static CatmullRom(K,H,M,q,w){const u=w*w,y=w*u,h=.5*(2*H.x+(-K.x+M.x)*w+(2*K.x-5*H.x+4*M.x-q.x)*u+(-K.x+3*H.x-3*M.x+q.x)*y),W=.5*(2*H.y+(-K.y+M.y)*w+(2*K.y-5*H.y+4*M.y-q.y)*u+(-K.y+3*H.y-3*M.y+q.y)*y);return new v(h,W)}static ClampToRef(K,H,M,q){return q.x=(0,W.Clamp)(K.x,H.x,M.x),q.y=(0,W.Clamp)(K.y,H.y,M.y),q}static Clamp(K,H,M){const q=(0,W.Clamp)(K.x,H.x,M.x),w=(0,W.Clamp)(K.y,H.y,M.y);return new v(q,w)}static Hermite(K,H,M,q,w){const u=w*w,y=w*u,h=2*y-3*u+1,W=-2*y+3*u,I=y-2*u+w,f=y-u,z=K.x*h+M.x*W+H.x*I+q.x*f,G=K.y*h+M.y*W+H.y*I+q.y*f;return new v(z,G)}static Hermite1stDerivative(K,H,M,q,w){return this.Hermite1stDerivativeToRef(K,H,M,q,w,new v)}static Hermite1stDerivativeToRef(K,H,M,q,w,u){const y=w*w;return u.x=6*(y-w)*K.x+(3*y-4*w+1)*H.x+6*(-y+w)*M.x+(3*y-2*w)*q.x,u.y=6*(y-w)*K.y+(3*y-4*w+1)*H.y+6*(-y+w)*M.y+(3*y-2*w)*q.y,u}static Lerp(K,H,M){return v.LerpToRef(K,H,M,new v)}static LerpToRef(K,H,M,q){return q.x=K.x+(H.x-K.x)*M,q.y=K.y+(H.y-K.y)*M,q}static Dot(K,H){return K.x*H.x+K.y*H.y}static Normalize(K){return v.NormalizeToRef(K,new v)}static NormalizeToRef(K,H){return K.normalizeToRef(H),H}static Minimize(K,H){const M=K.x<H.x?K.x:H.x,q=K.y<H.y?K.y:H.y;return new v(M,q)}static Maximize(K,H){const M=K.x>H.x?K.x:H.x,q=K.y>H.y?K.y:H.y;return new v(M,q)}static Transform(K,H){return v.TransformToRef(K,H,new v)}static TransformToRef(K,H,M){const q=H.m,w=K.x*q[0]+K.y*q[4]+q[12],u=K.x*q[1]+K.y*q[5]+q[13];return M.x=w,M.y=u,M}static PointInTriangle(K,H,M,q){const w=.5*(-M.y*q.x+H.y*(-M.x+q.x)+H.x*(M.y-q.y)+M.x*q.y),u=w<0?-1:1,y=(H.y*q.x-H.x*q.y+(q.y-H.y)*K.x+(H.x-q.x)*K.y)*u,h=(H.x*M.y-H.y*M.x+(H.y-M.y)*K.x+(M.x-H.x)*K.y)*u;return y>0&&h>0&&y+h<2*w*u}static Distance(K,H){return Math.sqrt(v.DistanceSquared(K,H))}static DistanceSquared(K,H){const M=K.x-H.x,q=K.y-H.y;return M*M+q*q}static Center(K,H){return v.CenterToRef(K,H,new v)}static CenterToRef(K,H,M){return M.Lh((K.x+H.x)/2,(K.y+H.y)/2)}static DistanceOfPointFromSegment(K,H,M){const q=v.DistanceSquared(H,M);if(0===q)return v.Distance(K,H);const w=M.LH(H),u=Math.max(0,Math.min(1,v.Dot(K.LH(H),w)/q)),y=H.add(w.multiplyByFloats(u,u));return v.Distance(K,y)}}v._V8PerformanceHack=new v(.5,.5),v._ZeroReadOnly=v.Zero(),Object.defineProperties(v.prototype,{dimension:{value:[2]},rank:{value:1}});class O{get x(){return this._x}set x(K){this._x=K,this._isDirty=!0}get y(){return this._y}set y(K){this._y=K,this._isDirty=!0}get z(){return this._z}set z(K){this._z=K,this._isDirty=!0}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=K,this._y=H,this._z=M}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"OH"}getHashCode(){let K=a(this._x);return K=397*K^a(this._y),K=397*K^a(this._z),K}hh(){return[this._x,this._y,this._z]}toArray(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[H]=this._x,K[H+1]=this._y,K[H+2]=this._z,this}aM(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(K,H,this),this}toQuaternion(){return S.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(K){return this._x+=K._x,this._y+=K._y,this._z+=K._z,this._isDirty=!0,this}addInPlaceFromFloats(K,H,M){return this._x+=K,this._y+=H,this._z+=M,this._isDirty=!0,this}add(K){return new O(this._x+K._x,this._y+K._y,this._z+K._z)}addToRef(K,H){return H._x=this._x+K._x,H._y=this._y+K._y,H._z=this._z+K._z,H._isDirty=!0,H}Zz(K){return this._x-=K._x,this._y-=K._y,this._z-=K._z,this._isDirty=!0,this}LH(K){return new O(this._x-K._x,this._y-K._y,this._z-K._z)}subtractToRef(K,H){return this.subtractFromFloatsToRef(K._x,K._y,K._z,H)}subtractFromFloats(K,H,M){return new O(this._x-K,this._y-H,this._z-M)}subtractFromFloatsToRef(K,H,M,q){return q._x=this._x-K,q._y=this._y-H,q._z=this._z-M,q._isDirty=!0,q}negate(){return new O(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(K){return K._x=-1*this._x,K._y=-1*this._y,K._z=-1*this._z,K._isDirty=!0,K}scaleInPlace(K){return this._x*=K,this._y*=K,this._z*=K,this._isDirty=!0,this}scale(K){return new O(this._x*K,this._y*K,this._z*K)}scaleToRef(K,H){return H._x=this._x*K,H._y=this._y*K,H._z=this._z*K,H._isDirty=!0,H}getNormalToRef(K){const H=this.length();let M=Math.acos(this._y/H);const q=Math.atan2(this._z,this._x);M>Math.PI/2?M-=Math.PI/2:M+=Math.PI/2;const w=H*Math.sin(M)*Math.cos(q),u=H*Math.cos(M),y=H*Math.sin(M)*Math.sin(q);return K.set(w,u,y),K}applyRotationQuaternionToRef(K,H){const M=this._x,q=this._y,w=this._z,u=K._x,y=K._y,h=K._z,W=K._w,I=2*(y*w-h*q),f=2*(h*M-u*w),z=2*(u*q-y*M);return H._x=M+W*I+y*z-h*f,H._y=q+W*f+h*I-u*z,H._z=w+W*z+u*f-y*I,H._isDirty=!0,H}applyRotationQuaternionInPlace(K){return this.applyRotationQuaternionToRef(K,this)}applyRotationQuaternion(K){return this.applyRotationQuaternionToRef(K,new O)}scaleAndAddToRef(K,H){return H._x+=this._x*K,H._y+=this._y*K,H._z+=this._z*K,H._isDirty=!0,H}projectOnPlane(K,H){return this.projectOnPlaneToRef(K,H,new O)}projectOnPlaneToRef(K,H,M){const q=K.normal,w=K.d,u=C.OH[0];this.subtractToRef(H,u),u.normalize();const y=O.Dot(u,q);if(Math.abs(y)<1e-10)M.Bh(1/0);else{const K=-(O.Dot(H,q)+w)/y,h=u.scaleInPlace(K);H.addToRef(h,M)}return M}equals(K){return K&&this._x===K._x&&this._y===K._y&&this._z===K._z}equalsWithEpsilon(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.d;return K&&(0,W.WithinEpsilon)(this._x,K._x,H)&&(0,W.WithinEpsilon)(this._y,K._y,H)&&(0,W.WithinEpsilon)(this._z,K._z,H)}equalsToFloats(K,H,M){return this._x===K&&this._y===H&&this._z===M}multiplyInPlace(K){return this._x*=K._x,this._y*=K._y,this._z*=K._z,this._isDirty=!0,this}multiply(K){return this.multiplyByFloats(K._x,K._y,K._z)}multiplyToRef(K,H){return H._x=this._x*K._x,H._y=this._y*K._y,H._z=this._z*K._z,H._isDirty=!0,H}multiplyByFloats(K,H,M){return new O(this._x*K,this._y*H,this._z*M)}divide(K){return new O(this._x/K._x,this._y/K._y,this._z/K._z)}divideToRef(K,H){return H._x=this._x/K._x,H._y=this._y/K._y,H._z=this._z/K._z,H._isDirty=!0,H}divideInPlace(K){return this._x=this._x/K._x,this._y=this._y/K._y,this._z=this._z/K._z,this._isDirty=!0,this}minimizeInPlace(K){return this.minimizeInPlaceFromFloats(K._x,K._y,K._z)}maximizeInPlace(K){return this.maximizeInPlaceFromFloats(K._x,K._y,K._z)}minimizeInPlaceFromFloats(K,H,M){return K<this._x&&(this.x=K),H<this._y&&(this.y=H),M<this._z&&(this.z=M),this}maximizeInPlaceFromFloats(K,H,M){return K>this._x&&(this.x=K),H>this._y&&(this.y=H),M>this._z&&(this.z=M),this}isNonUniformWithinEpsilon(K){const H=Math.abs(this._x),M=Math.abs(this._y);if(!(0,W.WithinEpsilon)(H,M,K))return!0;const q=Math.abs(this._z);return!(0,W.WithinEpsilon)(H,q,K)||!(0,W.WithinEpsilon)(M,q,K)}get isNonUniform(){const K=Math.abs(this._x);if(K!==Math.abs(this._y))return!0;return K!==Math.abs(this._z)}floorToRef(K){return K._x=Math.floor(this._x),K._y=Math.floor(this._y),K._z=Math.floor(this._z),K._isDirty=!0,K}floor(){return new O(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(K){return K._x=this._x-Math.floor(this._x),K._y=this._y-Math.floor(this._y),K._z=this._z-Math.floor(this._z),K._isDirty=!0,K}fract(){return new O(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(K){if("xyz"===(K=K.toLowerCase()))return this;const H=C.OH[0].q(this);return this.x=H[K[0]],this.y=H[K[1]],this.z=H[K[2]],this}rotateByQuaternionToRef(K,H){return K.toRotationMatrix(C.Matrix[0]),O.TransformCoordinatesToRef(this,C.Matrix[0],H),H}rotateByQuaternionAroundPointToRef(K,H,M){return this.subtractToRef(H,C.OH[0]),C.OH[0].rotateByQuaternionToRef(K,C.OH[0]),H.addToRef(C.OH[0],M),M}cross(K){return O.CrossToRef(this,K,new O)}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){return this.normalizeToRef(new O)}normalizeToRef(K){const H=this.length();return 0===H||1===H?(K._x=this._x,K._y=this._y,K._z=this._z,K._isDirty=!0,K):this.scaleToRef(1/H,K)}clone(){return new O(this._x,this._y,this._z)}q(K){return this.Lh(K._x,K._y,K._z)}Lh(K,H,M){return this._x=K,this._y=H,this._z=M,this._isDirty=!0,this}set(K,H,M){return this.Lh(K,H,M)}Bh(K){return this._x=this._y=this._z=K,this._isDirty=!0,this}static GetClipFactor(K,H,M,q){const w=O.Dot(K,M);return(w-q)/(w-O.Dot(H,M))}static GetAngleBetweenVectors(K,H,M){const q=K.normalizeToRef(C.OH[1]),w=H.normalizeToRef(C.OH[2]);let u=O.Dot(q,w);u=(0,W.Clamp)(u,-1,1);const y=Math.acos(u),h=C.OH[3];return O.CrossToRef(q,w,h),O.Dot(h,M)>0?isNaN(y)?0:y:isNaN(y)?-Math.PI:-Math.acos(u)}static GetAngleBetweenVectorsOnPlane(K,H,M){C.OH[0].q(K);const q=C.OH[0];C.OH[1].q(H);const w=C.OH[1];C.OH[2].q(M);const u=C.OH[2],y=C.OH[3],h=C.OH[4];q.normalize(),w.normalize(),u.normalize(),O.CrossToRef(u,q,y),O.CrossToRef(y,u,h);const I=Math.atan2(O.Dot(w,y),O.Dot(w,h));return(0,W.NormalizeRadians)(I)}static PitchYawRollToMoveBetweenPointsToRef(K,H,M){const q=i.OH[0];return H.subtractToRef(K,q),M._y=Math.atan2(q.x,q.z)||0,M._x=Math.atan2(Math.sqrt(q.x**2+q.z**2),q.y)||0,M._z=0,M._isDirty=!0,M}static PitchYawRollToMoveBetweenPoints(K,H){const M=O.Zero();return O.PitchYawRollToMoveBetweenPointsToRef(K,H,M)}static SlerpToRef(K,H,M,w){M=(0,W.Clamp)(M,0,1);const u=C.OH[0],y=C.OH[1];u.q(K);const h=u.length();u.normalizeFromLength(h),y.q(H);const I=y.length();y.normalizeFromLength(I);const f=O.Dot(u,y);let z,G;if(f<1-q.d){const K=Math.acos(f),H=1/Math.sin(K);z=Math.sin((1-M)*K)*H,G=Math.sin(M*K)*H}else z=1-M,G=M;return u.scaleInPlace(z),y.scaleInPlace(G),w.q(u).addInPlace(y),w.scaleInPlace((0,W.Lerp)(h,I,M)),w}static SmoothToRef(K,H,M,q,w){return O.SlerpToRef(K,H,0===q?1:M/q,w),w}static iH(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new O(K[H],K[H+1],K[H+2])}static FromFloatArray(K,H){return O.iH(K,H)}static FromArrayToRef(K,H,M){return M._x=K[H],M._y=K[H+1],M._z=K[H+2],M._isDirty=!0,M}static FromFloatArrayToRef(K,H,M){return O.FromArrayToRef(K,H,M)}static FromFloatsToRef(K,H,M,q){return q.Lh(K,H,M),q}static Zero(){return new O(0,0,0)}static One(){return new O(1,1,1)}static Up(){return new O(0,1,0)}static get UpReadOnly(){return O._UpReadOnly}static get DownReadOnly(){return O._DownReadOnly}static get RightReadOnly(){return O._RightReadOnly}static get LeftReadOnly(){return O._LeftReadOnly}static get LeftHandedForwardReadOnly(){return O._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return O._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return O._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return O._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return O._ZeroReadOnly}static get OneReadOnly(){return O._OneReadOnly}static Down(){return new O(0,-1,0)}static Forward(){return new O(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new O(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new O(1,0,0)}static Left(){return new O(-1,0,0)}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new O((0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Lh((0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H))}static TransformCoordinates(K,H){const M=O.Zero();return O.TransformCoordinatesToRef(K,H,M),M}static TransformCoordinatesToRef(K,H,M){return O.TransformCoordinatesFromFloatsToRef(K._x,K._y,K._z,H,M),M}static TransformCoordinatesFromFloatsToRef(K,H,M,q,w){const u=q.m,y=K*u[0]+H*u[4]+M*u[8]+u[12],h=K*u[1]+H*u[5]+M*u[9]+u[13],W=K*u[2]+H*u[6]+M*u[10]+u[14],I=1/(K*u[3]+H*u[7]+M*u[11]+u[15]);return w._x=y*I,w._y=h*I,w._z=W*I,w._isDirty=!0,w}static TransformNormal(K,H){const M=O.Zero();return O.TransformNormalToRef(K,H,M),M}static TransformNormalToRef(K,H,M){return this.TransformNormalFromFloatsToRef(K._x,K._y,K._z,H,M),M}static TransformNormalFromFloatsToRef(K,H,M,q,w){const u=q.m;return w._x=K*u[0]+H*u[4]+M*u[8],w._y=K*u[1]+H*u[5]+M*u[9],w._z=K*u[2]+H*u[6]+M*u[10],w._isDirty=!0,w}static CatmullRom(K,H,M,q,w){const u=w*w,y=w*u,h=.5*(2*H._x+(-K._x+M._x)*w+(2*K._x-5*H._x+4*M._x-q._x)*u+(-K._x+3*H._x-3*M._x+q._x)*y),W=.5*(2*H._y+(-K._y+M._y)*w+(2*K._y-5*H._y+4*M._y-q._y)*u+(-K._y+3*H._y-3*M._y+q._y)*y),I=.5*(2*H._z+(-K._z+M._z)*w+(2*K._z-5*H._z+4*M._z-q._z)*u+(-K._z+3*H._z-3*M._z+q._z)*y);return new O(h,W,I)}static Clamp(K,H,M){const q=new O;return O.ClampToRef(K,H,M,q),q}static ClampToRef(K,H,M,q){let w=K._x;w=w>M._x?M._x:w,w=w<H._x?H._x:w;let u=K._y;u=u>M._y?M._y:u,u=u<H._y?H._y:u;let y=K._z;return y=y>M._z?M._z:y,y=y<H._z?H._z:y,q.Lh(w,u,y),q}static CheckExtends(K,H,M){H.minimizeInPlace(K),M.maximizeInPlace(K)}static Hermite(K,H,M,q,w){const u=w*w,y=w*u,h=2*y-3*u+1,W=-2*y+3*u,I=y-2*u+w,f=y-u,z=K._x*h+M._x*W+H._x*I+q._x*f,G=K._y*h+M._y*W+H._y*I+q._y*f,a=K._z*h+M._z*W+H._z*I+q._z*f;return new O(z,G,a)}static Hermite1stDerivative(K,H,M,q,w){const u=new O;return this.Hermite1stDerivativeToRef(K,H,M,q,w,u),u}static Hermite1stDerivativeToRef(K,H,M,q,w,u){const y=w*w;return u._x=6*(y-w)*K._x+(3*y-4*w+1)*H._x+6*(-y+w)*M._x+(3*y-2*w)*q._x,u._y=6*(y-w)*K._y+(3*y-4*w+1)*H._y+6*(-y+w)*M._y+(3*y-2*w)*q._y,u._z=6*(y-w)*K._z+(3*y-4*w+1)*H._z+6*(-y+w)*M._z+(3*y-2*w)*q._z,u._isDirty=!0,u}static Lerp(K,H,M){const q=new O(0,0,0);return O.LerpToRef(K,H,M,q),q}static LerpToRef(K,H,M,q){return q._x=K._x+(H._x-K._x)*M,q._y=K._y+(H._y-K._y)*M,q._z=K._z+(H._z-K._z)*M,q._isDirty=!0,q}static Dot(K,H){return K._x*H._x+K._y*H._y+K._z*H._z}dot(K){return this._x*K._x+this._y*K._y+this._z*K._z}static Cross(K,H){const M=new O;return O.CrossToRef(K,H,M),M}static CrossToRef(K,H,M){const q=K._y*H._z-K._z*H._y,w=K._z*H._x-K._x*H._z,u=K._x*H._y-K._y*H._x;return M.Lh(q,w,u),M}static Normalize(K){const H=O.Zero();return O.NormalizeToRef(K,H),H}static NormalizeToRef(K,H){return K.normalizeToRef(H),H}static Project(K,H,M,q){const w=new O;return O.ProjectToRef(K,H,M,q,w),w}static ProjectToRef(K,H,M,q,w){var u;const y=q.width,W=q.height,I=q.x,f=q.y,z=C.Matrix[1],G=null===(u=h.b.LastCreatedEngine)||void 0===u?void 0:u.isNDCHalfZRange,a=G?1:.5,v=G?0:.5;B.FromValuesToRef(y/2,0,0,0,0,-W/2,0,0,0,0,a,0,I+y/2,W/2+f,v,1,z);const L=C.Matrix[0];return H.multiplyToRef(M,L),L.multiplyToRef(z,L),O.TransformCoordinatesToRef(K,L,w),w}static Reflect(K,H){return this.ReflectToRef(K,H,new O)}static ReflectToRef(K,H,M){const q=i.OH[0];return q.q(H).scaleInPlace(2*O.Dot(K,H)),M.q(K).Zz(q)}static _UnprojectFromInvertedMatrixToRef(K,H,M){O.TransformCoordinatesToRef(K,H,M);const q=H.m,w=K._x*q[3]+K._y*q[7]+K._z*q[11]+q[15];return(0,W.WithinEpsilon)(w,1)&&M.scaleInPlace(1/w),M}static UnprojectFromTransform(K,H,M,q,w){return this.Unproject(K,H,M,q,w,B.IdentityReadOnly)}static Unproject(K,H,M,q,w,u){const y=new O;return O.UnprojectToRef(K,H,M,q,w,u,y),y}static UnprojectToRef(K,H,M,q,w,u,y){return O.UnprojectFloatsToRef(K._x,K._y,K._z,H,M,q,w,u,y),y}static UnprojectFloatsToRef(K,H,M,q,w,u,y,W,I){var f;const z=C.Matrix[0];u.multiplyToRef(y,z),z.multiplyToRef(W,z),z.invert();const G=C.OH[0];return G.x=K/q*2-1,G.y=-(H/w*2-1),null!==(f=h.b.LastCreatedEngine)&&void 0!==f&&f.isNDCHalfZRange?G.z=M:G.z=2*M-1,O._UnprojectFromInvertedMatrixToRef(G,z,I),I}static Minimize(K,H){const M=new O;return M.q(K),M.minimizeInPlace(H),M}static Maximize(K,H){const M=new O;return M.q(K),M.maximizeInPlace(H),M}static Distance(K,H){return Math.sqrt(O.DistanceSquared(K,H))}static DistanceSquared(K,H){const M=K._x-H._x,q=K._y-H._y,w=K._z-H._z;return M*M+q*q+w*w}static ProjectOnTriangleToRef(K,H,M,w,u){const y=C.OH[0],h=C.OH[1],I=C.OH[2],f=C.OH[3],z=C.OH[4];M.subtractToRef(H,y),w.subtractToRef(H,h),w.subtractToRef(M,I);const G=y.length(),a=h.length(),v=I.length();if(G<q.d||a<q.d||v<q.d)return u.q(H),O.Distance(K,H);K.subtractToRef(H,z),O.CrossToRef(y,h,f);const L=f.length();if(L<q.d)return u.q(H),O.Distance(K,H);f.normalizeFromLength(L);let S=z.length();if(S<q.d)return u.q(H),0;z.normalizeFromLength(S);const B=O.Dot(f,z),i=C.OH[5],Z=C.OH[6];i.q(f).scaleInPlace(-S*B),Z.q(K).addInPlace(i);const E=C.OH[4],l=C.OH[5],s=C.OH[7],D=C.OH[8];E.q(y).scaleInPlace(1/G),D.q(h).scaleInPlace(1/a),E.addInPlace(D).scaleInPlace(-1),l.q(y).scaleInPlace(-1/G),D.q(I).scaleInPlace(1/v),l.addInPlace(D).scaleInPlace(-1),s.q(I).scaleInPlace(-1/v),D.q(h).scaleInPlace(-1/a),s.addInPlace(D).scaleInPlace(-1);const V=C.OH[9];let n;V.q(Z).Zz(H),O.CrossToRef(E,V,D),n=O.Dot(D,f);const c=n;V.q(Z).Zz(M),O.CrossToRef(l,V,D),n=O.Dot(D,f);const k=n;V.q(Z).Zz(w),O.CrossToRef(s,V,D),n=O.Dot(D,f);const T=n,d=C.OH[10];let x,Q;c>0&&k<0?(d.q(y),x=H,Q=M):k>0&&T<0?(d.q(I),x=M,Q=w):(d.q(h).scaleInPlace(-1),x=w,Q=H);const J=C.OH[9],N=C.OH[4];x.subtractToRef(Z,D),Q.subtractToRef(Z,J),O.CrossToRef(D,J,N);if(!(O.Dot(N,f)<0))return u.q(Z),Math.abs(S*B);const p=C.OH[5];O.CrossToRef(d,N,p),p.normalize();const o=C.OH[9];o.q(x).Zz(Z);const R=o.length();if(R<q.d)return u.q(x),O.Distance(K,x);o.normalizeFromLength(R);const t=O.Dot(p,o),U=C.OH[7];U.q(Z).addInPlace(p.scaleInPlace(R*t)),D.q(U).Zz(x),S=d.length(),d.normalizeFromLength(S);let j=O.Dot(D,d)/Math.max(S,q.d);return j=(0,W.Clamp)(j,0,1),U.q(x).addInPlace(d.scaleInPlace(j*S)),u.q(U),O.Distance(K,U)}static Center(K,H){return O.CenterToRef(K,H,O.Zero())}static CenterToRef(K,H,M){return M.Lh((K._x+H._x)/2,(K._y+H._y)/2,(K._z+H._z)/2)}static RotationFromAxis(K,H,M){const q=new O;return O.RotationFromAxisToRef(K,H,M,q),q}static RotationFromAxisToRef(K,H,M,q){const w=C.Quaternion[0];return S.RotationQuaternionFromAxisToRef(K,H,M,w),w.toEulerAnglesToRef(q),q}}O._V8PerformanceHack=new O(.5,.5,.5),O._UpReadOnly=O.Up(),O._DownReadOnly=O.Down(),O._LeftHandedForwardReadOnly=O.Forward(!1),O._RightHandedForwardReadOnly=O.Forward(!0),O._LeftHandedBackwardReadOnly=O.Backward(!1),O._RightHandedBackwardReadOnly=O.Backward(!0),O._RightReadOnly=O.Right(),O._LeftReadOnly=O.Left(),O._ZeroReadOnly=O.Zero(),O._OneReadOnly=O.One(),Object.defineProperties(O.prototype,{dimension:{value:[3]},rank:{value:1}});class L{get x(){return this._x}set x(K){this._x=K,this._isDirty=!0}get y(){return this._y}set y(K){this._y=K,this._isDirty=!0}get z(){return this._z}set z(K){this._z=K,this._isDirty=!0}get w(){return this._w}set w(K){this._w=K,this._isDirty=!0}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=K,this._y=H,this._z=M,this._w=q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let K=a(this._x);return K=397*K^a(this._y),K=397*K^a(this._z),K=397*K^a(this._w),K}hh(){return[this._x,this._y,this._z,this._w]}toArray(K,H){return void 0===H&&(H=0),K[H]=this._x,K[H+1]=this._y,K[H+2]=this._z,K[H+3]=this._w,this}aM(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(K,H,this),this}addInPlace(K){return this.x+=K._x,this.y+=K._y,this.z+=K._z,this.w+=K._w,this}addInPlaceFromFloats(K,H,M,q){return this.x+=K,this.y+=H,this.z+=M,this.w+=q,this}add(K){return new L(this._x+K.x,this._y+K.y,this._z+K.z,this._w+K.w)}addToRef(K,H){return H.x=this._x+K.x,H.y=this._y+K.y,H.z=this._z+K.z,H.w=this._w+K.w,H}Zz(K){return this.x-=K.x,this.y-=K.y,this.z-=K.z,this.w-=K.w,this}LH(K){return new L(this._x-K.x,this._y-K.y,this._z-K.z,this._w-K.w)}subtractToRef(K,H){return H.x=this._x-K.x,H.y=this._y-K.y,H.z=this._z-K.z,H.w=this._w-K.w,H}subtractFromFloats(K,H,M,q){return new L(this._x-K,this._y-H,this._z-M,this._w-q)}subtractFromFloatsToRef(K,H,M,q,w){return w.x=this._x-K,w.y=this._y-H,w.z=this._z-M,w.w=this._w-q,w}negate(){return new L(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(K){return K.x=-this._x,K.y=-this._y,K.z=-this._z,K.w=-this._w,K}scaleInPlace(K){return this.x*=K,this.y*=K,this.z*=K,this.w*=K,this}scale(K){return new L(this._x*K,this._y*K,this._z*K,this._w*K)}scaleToRef(K,H){return H.x=this._x*K,H.y=this._y*K,H.z=this._z*K,H.w=this._w*K,H}scaleAndAddToRef(K,H){return H.x+=this._x*K,H.y+=this._y*K,H.z+=this._z*K,H.w+=this._w*K,H}equals(K){return K&&this._x===K.x&&this._y===K.y&&this._z===K.z&&this._w===K.w}equalsWithEpsilon(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.d;return K&&(0,W.WithinEpsilon)(this._x,K.x,H)&&(0,W.WithinEpsilon)(this._y,K.y,H)&&(0,W.WithinEpsilon)(this._z,K.z,H)&&(0,W.WithinEpsilon)(this._w,K.w,H)}equalsToFloats(K,H,M,q){return this._x===K&&this._y===H&&this._z===M&&this._w===q}multiplyInPlace(K){return this.x*=K.x,this.y*=K.y,this.z*=K.z,this.w*=K.w,this}multiply(K){return new L(this._x*K.x,this._y*K.y,this._z*K.z,this._w*K.w)}multiplyToRef(K,H){return H.x=this._x*K.x,H.y=this._y*K.y,H.z=this._z*K.z,H.w=this._w*K.w,H}multiplyByFloats(K,H,M,q){return new L(this._x*K,this._y*H,this._z*M,this._w*q)}divide(K){return new L(this._x/K.x,this._y/K.y,this._z/K.z,this._w/K.w)}divideToRef(K,H){return H.x=this._x/K.x,H.y=this._y/K.y,H.z=this._z/K.z,H.w=this._w/K.w,H}divideInPlace(K){return this.divideToRef(K,this)}minimizeInPlace(K){return K.x<this._x&&(this.x=K.x),K.y<this._y&&(this.y=K.y),K.z<this._z&&(this.z=K.z),K.w<this._w&&(this.w=K.w),this}maximizeInPlace(K){return K.x>this._x&&(this.x=K.x),K.y>this._y&&(this.y=K.y),K.z>this._z&&(this.z=K.z),K.w>this._w&&(this.w=K.w),this}minimizeInPlaceFromFloats(K,H,M,q){return this.x=Math.min(K,this._x),this.y=Math.min(H,this._y),this.z=Math.min(M,this._z),this.w=Math.min(q,this._w),this}maximizeInPlaceFromFloats(K,H,M,q){return this.x=Math.max(K,this._x),this.y=Math.max(H,this._y),this.z=Math.max(M,this._z),this.w=Math.max(q,this._w),this}floorToRef(K){return K.x=Math.floor(this._x),K.y=Math.floor(this._y),K.z=Math.floor(this._z),K.w=Math.floor(this._w),K}floor(){return new L(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(K){return K.x=this._x-Math.floor(this._x),K.y=this._y-Math.floor(this._y),K.z=this._z-Math.floor(this._z),K.w=this._w-Math.floor(this._w),K}fract(){return new L(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){return this.normalizeToRef(new L)}normalizeToRef(K){const H=this.length();return 0===H||1===H?(K.x=this._x,K.y=this._y,K.z=this._z,K.w=this._w,K):this.scaleToRef(1/H,K)}toVector3(){return new O(this._x,this._y,this._z)}clone(){return new L(this._x,this._y,this._z,this._w)}q(K){return this.x=K.x,this.y=K.y,this.z=K.z,this.w=K.w,this}Lh(K,H,M,q){return this.x=K,this.y=H,this.z=M,this.w=q,this}set(K,H,M,q){return this.Lh(K,H,M,q)}Bh(K){return this.x=this.y=this.z=this.w=K,this}dot(K){return this._x*K.x+this._y*K.y+this._z*K.z+this._w*K.w}static iH(K,H){return H||(H=0),new L(K[H],K[H+1],K[H+2],K[H+3])}static FromArrayToRef(K,H,M){return M.x=K[H],M.y=K[H+1],M.z=K[H+2],M.w=K[H+3],M}static FromFloatArrayToRef(K,H,M){return L.FromArrayToRef(K,H,M),M}static FromFloatsToRef(K,H,M,q,w){return w.x=K,w.y=H,w.z=M,w.w=q,w}static Zero(){return new L(0,0,0,0)}static One(){return new L(1,1,1,1)}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new L((0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,M=arguments.length>2?arguments[2]:void 0;return M.x=(0,W.RandomRange)(K,H),M.y=(0,W.RandomRange)(K,H),M.z=(0,W.RandomRange)(K,H),M.w=(0,W.RandomRange)(K,H),M}static Clamp(K,H,M){return L.ClampToRef(K,H,M,new L)}static ClampToRef(K,H,M,q){return q.x=(0,W.Clamp)(K.x,H.x,M.x),q.y=(0,W.Clamp)(K.y,H.y,M.y),q.z=(0,W.Clamp)(K.z,H.z,M.z),q.w=(0,W.Clamp)(K.w,H.w,M.w),q}static CheckExtends(K,H,M){H.minimizeInPlace(K),M.maximizeInPlace(K)}static get ZeroReadOnly(){return L._ZeroReadOnly}static Normalize(K){return L.NormalizeToRef(K,new L)}static NormalizeToRef(K,H){return K.normalizeToRef(H),H}static Minimize(K,H){const M=new L;return M.q(K),M.minimizeInPlace(H),M}static Maximize(K,H){const M=new L;return M.q(K),M.maximizeInPlace(H),M}static Distance(K,H){return Math.sqrt(L.DistanceSquared(K,H))}static DistanceSquared(K,H){const M=K.x-H.x,q=K.y-H.y,w=K.z-H.z,u=K.w-H.w;return M*M+q*q+w*w+u*u}static Center(K,H){return L.CenterToRef(K,H,new L)}static CenterToRef(K,H,M){return M.x=(K.x+H.x)/2,M.y=(K.y+H.y)/2,M.z=(K.z+H.z)/2,M.w=(K.w+H.w)/2,M}static TransformCoordinates(K,H){return L.TransformCoordinatesToRef(K,H,new L)}static TransformCoordinatesToRef(K,H,M){return L.TransformCoordinatesFromFloatsToRef(K._x,K._y,K._z,H,M),M}static TransformCoordinatesFromFloatsToRef(K,H,M,q,w){const u=q.m,y=K*u[0]+H*u[4]+M*u[8]+u[12],h=K*u[1]+H*u[5]+M*u[9]+u[13],W=K*u[2]+H*u[6]+M*u[10]+u[14],I=K*u[3]+H*u[7]+M*u[11]+u[15];return w.x=y,w.y=h,w.z=W,w.w=I,w}static TransformNormal(K,H){return L.TransformNormalToRef(K,H,new L)}static TransformNormalToRef(K,H,M){const q=H.m,w=K.x*q[0]+K.y*q[4]+K.z*q[8],u=K.x*q[1]+K.y*q[5]+K.z*q[9],y=K.x*q[2]+K.y*q[6]+K.z*q[10];return M.x=w,M.y=u,M.z=y,M.w=K.w,M}static TransformNormalFromFloatsToRef(K,H,M,q,w,u){const y=w.m;return u.x=K*y[0]+H*y[4]+M*y[8],u.y=K*y[1]+H*y[5]+M*y[9],u.z=K*y[2]+H*y[6]+M*y[10],u.w=q,u}static FromVector3(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new L(K._x,K._y,K._z,H)}static Dot(K,H){return K.x*H.x+K.y*H.y+K.z*H.z+K.w*H.w}}L._V8PerformanceHack=new L(.5,.5,.5,.5),L._ZeroReadOnly=L.Zero(),Object.defineProperties(L.prototype,{dimension:{value:[4]},rank:{value:1}});class S{get x(){return this._x}set x(K){this._x=K,this._isDirty=!0}get y(){return this._y}set y(K){this._y=K,this._isDirty=!0}get z(){return this._z}set z(K){this._z=K,this._isDirty=!0}get w(){return this._w}set w(K){this._w=K,this._isDirty=!0}constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=K,this._y=H,this._z=M,this._w=q}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let K=a(this._x);return K=397*K^a(this._y),K=397*K^a(this._z),K=397*K^a(this._w),K}hh(){return[this._x,this._y,this._z,this._w]}toArray(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[H]=this._x,K[H+1]=this._y,K[H+2]=this._z,K[H+3]=this._w,this}aM(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(K,H,this)}equals(K){return K&&this._x===K._x&&this._y===K._y&&this._z===K._z&&this._w===K._w}equalsWithEpsilon(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.d;return K&&(0,W.WithinEpsilon)(this._x,K._x,H)&&(0,W.WithinEpsilon)(this._y,K._y,H)&&(0,W.WithinEpsilon)(this._z,K._z,H)&&(0,W.WithinEpsilon)(this._w,K._w,H)}isApprox(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.d;return K&&((0,W.WithinEpsilon)(this._x,K._x,H)&&(0,W.WithinEpsilon)(this._y,K._y,H)&&(0,W.WithinEpsilon)(this._z,K._z,H)&&(0,W.WithinEpsilon)(this._w,K._w,H)||(0,W.WithinEpsilon)(this._x,-K._x,H)&&(0,W.WithinEpsilon)(this._y,-K._y,H)&&(0,W.WithinEpsilon)(this._z,-K._z,H)&&(0,W.WithinEpsilon)(this._w,-K._w,H))}clone(){return new S(this._x,this._y,this._z,this._w)}q(K){return this._x=K._x,this._y=K._y,this._z=K._z,this._w=K._w,this._isDirty=!0,this}Lh(K,H,M,q){return this._x=K,this._y=H,this._z=M,this._w=q,this._isDirty=!0,this}set(K,H,M,q){return this.Lh(K,H,M,q)}Bh(K){return this.Lh(K,K,K,K)}add(K){return new S(this._x+K._x,this._y+K._y,this._z+K._z,this._w+K._w)}addInPlace(K){return this._x+=K._x,this._y+=K._y,this._z+=K._z,this._w+=K._w,this._isDirty=!0,this}addToRef(K,H){return H._x=this._x+K._x,H._y=this._y+K._y,H._z=this._z+K._z,H._w=this._w+K._w,H._isDirty=!0,H}addInPlaceFromFloats(K,H,M,q){return this._x+=K,this._y+=H,this._z+=M,this._w+=q,this._isDirty=!0,this}subtractToRef(K,H){return H._x=this._x-K._x,H._y=this._y-K._y,H._z=this._z-K._z,H._w=this._w-K._w,H._isDirty=!0,H}subtractFromFloats(K,H,M,q){return this.subtractFromFloatsToRef(K,H,M,q,new S)}subtractFromFloatsToRef(K,H,M,q,w){return w._x=this._x-K,w._y=this._y-H,w._z=this._z-M,w._w=this._w-q,w._isDirty=!0,w}LH(K){return new S(this._x-K._x,this._y-K._y,this._z-K._z,this._w-K._w)}Zz(K){return this._x-=K._x,this._y-=K._y,this._z-=K._z,this._w-=K._w,this._isDirty=!0,this}scale(K){return new S(this._x*K,this._y*K,this._z*K,this._w*K)}scaleToRef(K,H){return H._x=this._x*K,H._y=this._y*K,H._z=this._z*K,H._w=this._w*K,H._isDirty=!0,H}scaleInPlace(K){return this._x*=K,this._y*=K,this._z*=K,this._w*=K,this._isDirty=!0,this}scaleAndAddToRef(K,H){return H._x+=this._x*K,H._y+=this._y*K,H._z+=this._z*K,H._w+=this._w*K,H._isDirty=!0,H}multiply(K){const H=new S(0,0,0,1);return this.multiplyToRef(K,H),H}multiplyToRef(K,H){const M=this._x*K._w+this._y*K._z-this._z*K._y+this._w*K._x,q=-this._x*K._z+this._y*K._w+this._z*K._x+this._w*K._y,w=this._x*K._y-this._y*K._x+this._z*K._w+this._w*K._z,u=-this._x*K._x-this._y*K._y-this._z*K._z+this._w*K._w;return H.Lh(M,q,w,u),H}multiplyInPlace(K){return this.multiplyToRef(K,this)}multiplyByFloats(K,H,M,q){return this._x*=K,this._y*=H,this._z*=M,this._w*=q,this._isDirty=!0,this}divide(K){throw new ReferenceError("Can not divide a quaternion")}divideToRef(K,H){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(K){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new S)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(K){return K._x=-this._x,K._y=-this._y,K._z=-this._z,K._w=-this._w,K._isDirty=!0,K}equalsToFloats(K,H,M,q){return this._x===K&&this._y===H&&this._z===M&&this._w===q}floorToRef(K){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(K){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(K){return K.Lh(-this._x,-this._y,-this._z,this._w),K}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new S(-this._x,-this._y,-this._z,this._w)}invert(){const K=this.conjugate(),H=this.lengthSquared();return 0==H||1==H||K.scaleInPlace(1/H),K}invertInPlace(){this.conjugateInPlace();const K=this.lengthSquared();return 0==K||1==K||this.scaleInPlace(1/K),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(K){return 0===K||1===K?this:this.scaleInPlace(1/K)}normalizeToNew(){const K=new S(0,0,0,1);return this.normalizeToRef(K),K}normalizeToRef(K){const H=this.length();return 0===H||1===H?K.Lh(this._x,this._y,this._z,this._w):this.scaleToRef(1/H,K)}toEulerAngles(){const K=O.Zero();return this.toEulerAnglesToRef(K),K}toEulerAnglesToRef(K){const H=this._z,M=this._x,q=this._y,w=this._w,u=q*H-M*w,y=.4999999;if(u<-y)K._y=2*Math.atan2(q,w),K._x=Math.PI/2,K._z=0,K._isDirty=!0;else if(u>y)K._y=2*Math.atan2(q,w),K._x=-Math.PI/2,K._z=0,K._isDirty=!0;else{const y=w*w,h=H*H,W=M*M,I=q*q;K._z=Math.atan2(2*(M*q+H*w),-h-W+I+y),K._x=Math.asin(-2*u),K._y=Math.atan2(2*(H*M+q*w),h-W-I+y),K._isDirty=!0}return K}toAlphaBetaGammaToRef(K){const H=this._z,M=this._x,q=this._y,w=this._w,u=Math.sqrt(M*M+q*q),y=Math.sqrt(H*H+w*w),h=2*Math.atan2(u,y),W=2*Math.atan2(H,w),I=2*Math.atan2(q,M),f=(W+I)/2,z=(W-I)/2;return K.set(z,h,f),K}toRotationMatrix(K){return B.FromQuaternionToRef(this,K),K}fromRotationMatrix(K){return S.FromRotationMatrixToRef(K,this),this}dot(K){return this._x*K._x+this._y*K._y+this._z*K._z+this._w*K._w}toAxisAngle(){const K=O.Zero();return{axis:K,angle:this.toAxisAngleToRef(K)}}toAxisAngleToRef(K){let H=0;const M=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),q=this._w;return M>0?(H=2*Math.atan2(M,q),K.set(this._x/M,this._y/M,this._z/M)):(H=0,K.set(1,0,0)),H}static FromRotationMatrix(K){const H=new S;return S.FromRotationMatrixToRef(K,H),H}static FromRotationMatrixToRef(K,H){const M=K.m,q=M[0],w=M[4],u=M[8],y=M[1],h=M[5],W=M[9],I=M[2],f=M[6],z=M[10],G=q+h+z;let a;return G>0?(a=.5/Math.sqrt(G+1),H._w=.25/a,H._x=(f-W)*a,H._y=(u-I)*a,H._z=(y-w)*a,H._isDirty=!0):q>h&&q>z?(a=2*Math.sqrt(1+q-h-z),H._w=(f-W)/a,H._x=.25*a,H._y=(w+y)/a,H._z=(u+I)/a,H._isDirty=!0):h>z?(a=2*Math.sqrt(1+h-q-z),H._w=(u-I)/a,H._x=(w+y)/a,H._y=.25*a,H._z=(W+f)/a,H._isDirty=!0):(a=2*Math.sqrt(1+z-q-h),H._w=(y-w)/a,H._x=(u+I)/a,H._y=(W+f)/a,H._z=.25*a,H._isDirty=!0),H}static Dot(K,H){return K._x*H._x+K._y*H._y+K._z*H._z+K._w*H._w}static AreClose(K,H){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const q=S.Dot(K,H);return 1-q*q<=M}static SmoothToRef(K,H,M,q,w){let u=0===q?1:M/q;return u=(0,W.Clamp)(u,0,1),S.SlerpToRef(K,H,u,w),w}static Zero(){return new S(0,0,0,0)}static Inverse(K){return new S(-K._x,-K._y,-K._z,K._w)}static InverseToRef(K,H){return H.set(-K._x,-K._y,-K._z,K._w),H}static Identity(){return new S(0,0,0,1)}static IsIdentity(K){return K&&0===K._x&&0===K._y&&0===K._z&&1===K._w}static RotationAxis(K,H){return S.RotationAxisToRef(K,H,new S)}static RotationAxisToRef(K,H,M){M._w=Math.cos(H/2);const q=Math.sin(H/2)/K.length();return M._x=K._x*q,M._y=K._y*q,M._z=K._z*q,M._isDirty=!0,M}static iH(K,H){return H||(H=0),new S(K[H],K[H+1],K[H+2],K[H+3])}static FromArrayToRef(K,H,M){return M._x=K[H],M._y=K[H+1],M._z=K[H+2],M._w=K[H+3],M._isDirty=!0,M}static FromFloatsToRef(K,H,M,q,w){return w.Lh(K,H,M,q),w}static FromEulerAngles(K,H,M){const q=new S;return S.RotationYawPitchRollToRef(H,K,M,q),q}static FromEulerAnglesToRef(K,H,M,q){return S.RotationYawPitchRollToRef(H,K,M,q),q}static FromEulerVector(K){const H=new S;return S.RotationYawPitchRollToRef(K._y,K._x,K._z,H),H}static FromEulerVectorToRef(K,H){return S.RotationYawPitchRollToRef(K._y,K._x,K._z,H),H}static FromUnitVectorsToRef(K,H,M){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:q.d;const u=O.Dot(K,H)+1;return u<w?Math.abs(K.x)>Math.abs(K.z)?M.set(-K.y,K.x,0,0):M.set(0,-K.z,K.y,0):(O.CrossToRef(K,H,i.OH[0]),M.set(i.OH[0].x,i.OH[0].y,i.OH[0].z,u)),M.normalize()}static RotationYawPitchRoll(K,H,M){const q=new S;return S.RotationYawPitchRollToRef(K,H,M,q),q}static RotationYawPitchRollToRef(K,H,M,q){const w=.5*M,u=.5*H,y=.5*K,h=Math.sin(w),W=Math.cos(w),I=Math.sin(u),f=Math.cos(u),z=Math.sin(y),G=Math.cos(y);return q._x=G*I*W+z*f*h,q._y=z*f*W-G*I*h,q._z=G*f*h-z*I*W,q._w=G*f*W+z*I*h,q._isDirty=!0,q}static RotationAlphaBetaGamma(K,H,M){const q=new S;return S.RotationAlphaBetaGammaToRef(K,H,M,q),q}static RotationAlphaBetaGammaToRef(K,H,M,q){const w=.5*(M+K),u=.5*(M-K),y=.5*H;return q._x=Math.cos(u)*Math.sin(y),q._y=Math.sin(u)*Math.sin(y),q._z=Math.sin(w)*Math.cos(y),q._w=Math.cos(w)*Math.cos(y),q._isDirty=!0,q}static RotationQuaternionFromAxis(K,H,M){const q=new S(0,0,0,0);return S.RotationQuaternionFromAxisToRef(K,H,M,q),q}static RotationQuaternionFromAxisToRef(K,H,M,q){const w=C.Matrix[0];return K=K.normalizeToRef(C.OH[0]),H=H.normalizeToRef(C.OH[1]),M=M.normalizeToRef(C.OH[2]),B.FromXYZAxesToRef(K,H,M,w),S.FromRotationMatrixToRef(w,q),q}static FromLookDirectionLH(K,H){const M=new S;return S.FromLookDirectionLHToRef(K,H,M),M}static FromLookDirectionLHToRef(K,H,M){const q=C.Matrix[0];return B.LookDirectionLHToRef(K,H,q),S.FromRotationMatrixToRef(q,M),M}static FromLookDirectionRH(K,H){const M=new S;return S.FromLookDirectionRHToRef(K,H,M),M}static FromLookDirectionRHToRef(K,H,M){const q=C.Matrix[0];return B.LookDirectionRHToRef(K,H,q),S.FromRotationMatrixToRef(q,M)}static Slerp(K,H,M){const q=S.Identity();return S.SlerpToRef(K,H,M,q),q}static SlerpToRef(K,H,M,q){let w,u,y=K._x*H._x+K._y*H._y+K._z*H._z+K._w*H._w,h=!1;if(y<0&&(h=!0,y=-y),y>.999999)u=1-M,w=h?-M:M;else{const K=Math.acos(y),H=1/Math.sin(K);u=Math.sin((1-M)*K)*H,w=h?-Math.sin(M*K)*H:Math.sin(M*K)*H}return q._x=u*K._x+w*H._x,q._y=u*K._y+w*H._y,q._z=u*K._z+w*H._z,q._w=u*K._w+w*H._w,q._isDirty=!0,q}static Hermite(K,H,M,q,w){const u=w*w,y=w*u,h=2*y-3*u+1,W=-2*y+3*u,I=y-2*u+w,f=y-u,z=K._x*h+M._x*W+H._x*I+q._x*f,G=K._y*h+M._y*W+H._y*I+q._y*f,a=K._z*h+M._z*W+H._z*I+q._z*f,v=K._w*h+M._w*W+H._w*I+q._w*f;return new S(z,G,a,v)}static Hermite1stDerivative(K,H,M,q,w){const u=new S;return this.Hermite1stDerivativeToRef(K,H,M,q,w,u),u}static Hermite1stDerivativeToRef(K,H,M,q,w,u){const y=w*w;return u._x=6*(y-w)*K._x+(3*y-4*w+1)*H._x+6*(-y+w)*M._x+(3*y-2*w)*q._x,u._y=6*(y-w)*K._y+(3*y-4*w+1)*H._y+6*(-y+w)*M._y+(3*y-2*w)*q._y,u._z=6*(y-w)*K._z+(3*y-4*w+1)*H._z+6*(-y+w)*M._z+(3*y-2*w)*q._z,u._w=6*(y-w)*K._w+(3*y-4*w+1)*H._w+6*(-y+w)*M._w+(3*y-2*w)*q._w,u._isDirty=!0,u}static Normalize(K){const H=S.Zero();return S.NormalizeToRef(K,H),H}static NormalizeToRef(K,H){return K.normalizeToRef(H),H}static Clamp(K,H,M){const q=new S;return S.ClampToRef(K,H,M,q),q}static ClampToRef(K,H,M,q){return q.Lh((0,W.Clamp)(K.x,H.x,M.x),(0,W.Clamp)(K.y,H.y,M.y),(0,W.Clamp)(K.z,H.z,M.z),(0,W.Clamp)(K.w,H.w,M.w))}static Random(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new S((0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H))}static RandomToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Lh((0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H),(0,W.RandomRange)(K,H))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(K,H){return Math.sqrt(S.DistanceSquared(K,H))}static DistanceSquared(K,H){const M=K.x-H.x,q=K.y-H.y,w=K.z-H.z,u=K.w-H.w;return M*M+q*q+w*w+u*u}static Center(K,H){return S.CenterToRef(K,H,S.Zero())}static CenterToRef(K,H,M){return M.Lh((K.x+H.x)/2,(K.y+H.y)/2,(K.z+H.z)/2,(K.w+H.w)/2)}}S._V8PerformanceHack=new S(.5,.5,.5,.5),Object.defineProperties(S.prototype,{dimension:{value:[4]},rank:{value:1}});class B{static get Use64Bits(){return y.d.MatrixUse64Bits}get m(){return this.Mh}markAsUpdated(){this.updateFlag=I._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(K){let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1],M=arguments.length>2&&void 0!==arguments[2]&&arguments[2],q=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=K,this._isIdentity3x2=K||M,this._isIdentityDirty=!this._isIdentity&&H,this._isIdentity3x2Dirty=!this._isIdentity3x2&&q}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,y.d.MatrixTrackPrecisionChange&&y.d.MatrixTrackedMatrices.push(this),this.Mh=new y.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const K=this.Mh;this._isIdentity=1===K[0]&&0===K[1]&&0===K[2]&&0===K[3]&&0===K[4]&&1===K[5]&&0===K[6]&&0===K[7]&&0===K[8]&&0===K[9]&&1===K[10]&&0===K[11]&&0===K[12]&&0===K[13]&&0===K[14]&&1===K[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Mh[0]||1!==this.Mh[5]||1!==this.Mh[15]||0!==this.Mh[1]||0!==this.Mh[2]||0!==this.Mh[3]||0!==this.Mh[4]||0!==this.Mh[6]||0!==this.Mh[7]||0!==this.Mh[8]||0!==this.Mh[9]||0!==this.Mh[10]||0!==this.Mh[11]||0!==this.Mh[12]||0!==this.Mh[13]||0!==this.Mh[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const K=this.Mh,H=K[0],M=K[1],q=K[2],w=K[3],u=K[4],y=K[5],h=K[6],W=K[7],I=K[8],f=K[9],z=K[10],G=K[11],a=K[12],v=K[13],O=K[14],L=K[15],S=z*L-O*G,B=f*L-v*G,C=f*O-v*z,i=I*L-a*G,Z=I*O-z*a,E=I*v-a*f;return H*+(y*S-h*B+W*C)+M*-(u*S-h*i+W*Z)+q*+(u*B-y*i+W*E)+w*-(u*C-y*Z+h*E)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!K)return this.Mh;const M=this.Mh;for(let q=0;q<16;q++)K[H+q]=M[q];return this}hh(){return this.Mh}aM(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B.FromArrayToRef(K,H,this)}Lh(){for(var K=arguments.length,H=new Array(K),M=0;M<K;M++)H[M]=arguments[M];return B.FromArrayToRef(H,0,this)}set(){const K=this.Mh;for(let H=0;H<16;H++)K[H]=H<0||arguments.length<=H?void 0:arguments[H];return this.markAsUpdated(),this}Bh(K){const H=this.Mh;for(let M=0;M<16;M++)H[M]=K;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return B.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(K){const H=new B;return this.addToRef(K,H),H}addToRef(K,H){const M=this.Mh,q=H.Mh,w=K.m;for(let u=0;u<16;u++)q[u]=M[u]+w[u];return H.markAsUpdated(),H}addToSelf(K){const H=this.Mh,M=K.m;return H[0]+=M[0],H[1]+=M[1],H[2]+=M[2],H[3]+=M[3],H[4]+=M[4],H[5]+=M[5],H[6]+=M[6],H[7]+=M[7],H[8]+=M[8],H[9]+=M[9],H[10]+=M[10],H[11]+=M[11],H[12]+=M[12],H[13]+=M[13],H[14]+=M[14],H[15]+=M[15],this.markAsUpdated(),this}addInPlace(K){const H=this.Mh,M=K.m;for(let q=0;q<16;q++)H[q]+=M[q];return this.markAsUpdated(),this}addInPlaceFromFloats(){const K=this.Mh;for(let H=0;H<16;H++)K[H]+=H<0||arguments.length<=H?void 0:arguments[H];return this.markAsUpdated(),this}LH(K){const H=this.Mh,M=K.m;for(let q=0;q<16;q++)H[q]-=M[q];return this.markAsUpdated(),this}subtractToRef(K,H){const M=this.Mh,q=K.m,w=H.Mh;for(let u=0;u<16;u++)w[u]=M[u]-q[u];return H.markAsUpdated(),H}Zz(K){const H=this.Mh,M=K.m;for(let q=0;q<16;q++)H[q]-=M[q];return this.markAsUpdated(),this}subtractFromFloats(){for(var K=arguments.length,H=new Array(K),M=0;M<K;M++)H[M]=arguments[M];return this.subtractFromFloatsToRef(...H,new B)}subtractFromFloatsToRef(){for(var K=arguments.length,H=new Array(K),M=0;M<K;M++)H[M]=arguments[M];const q=H.pop(),w=this.Mh,u=q.Mh,y=H;for(let h=0;h<16;h++)u[h]=w[h]-y[h];return q.markAsUpdated(),q}invertToRef(K){return!0===this._isIdentity?(B.IdentityToRef(K),K):(G(this,K.hh())?K.markAsUpdated():K.q(this),K)}addAtIndex(K,H){return this.Mh[K]+=H,this.markAsUpdated(),this}multiplyAtIndex(K,H){return this.Mh[K]*=H,this.markAsUpdated(),this}setTranslationFromFloats(K,H,M){return this.Mh[12]=K,this.Mh[13]=H,this.Mh[14]=M,this.markAsUpdated(),this}addTranslationFromFloats(K,H,M){return this.Mh[12]+=K,this.Mh[13]+=H,this.Mh[14]+=M,this.markAsUpdated(),this}setTranslation(K){return this.setTranslationFromFloats(K._x,K._y,K._z)}getTranslation(){return new O(this.Mh[12],this.Mh[13],this.Mh[14])}getTranslationToRef(K){return K.x=this.Mh[12],K.y=this.Mh[13],K.z=this.Mh[14],K}removeRotationAndScaling(){const K=this.m;return B.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,K[12],K[13],K[14],K[15],this),this._updateIdentityStatus(0===K[12]&&0===K[13]&&0===K[14]&&1===K[15]),this}q(K){K.copyToArray(this.Mh);const H=K;return this.updateFlag=H.updateFlag,this._updateIdentityStatus(H._isIdentity,H._isIdentityDirty,H._isIdentity3x2,H._isIdentity3x2Dirty),this}copyToArray(K){return z(this,K,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(K){const H=new B;return this.multiplyToRef(K,H),H}multiplyInPlace(K){const H=this.Mh,M=K.m;for(let q=0;q<16;q++)H[q]*=M[q];return this.markAsUpdated(),this}multiplyByFloats(){const K=this.Mh;for(let H=0;H<16;H++)K[H]*=H<0||arguments.length<=H?void 0:arguments[H];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var K=arguments.length,H=new Array(K),M=0;M<K;M++)H[M]=arguments[M];const q=H.pop(),w=this.Mh,u=q.Mh,y=H;for(let h=0;h<16;h++)u[h]=w[h]*y[h];return q.markAsUpdated(),q}multiplyToRef(K,H){return this._isIdentity?(H.q(K),H):K._isIdentity?(H.q(this),H):(this.multiplyToArray(K,H.Mh,0),H.markAsUpdated(),H)}multiplyToArray(K,H,M){return f(this,K,H,M),this}divide(K){return this.divideToRef(K,new B)}divideToRef(K,H){const M=this.Mh,q=K.m,w=H.Mh;for(let u=0;u<16;u++)w[u]=M[u]/q[u];return H.markAsUpdated(),H}divideInPlace(K){const H=this.Mh,M=K.m;for(let q=0;q<16;q++)H[q]/=M[q];return this.markAsUpdated(),this}minimizeInPlace(K){const H=this.Mh,M=K.m;for(let q=0;q<16;q++)H[q]=Math.min(H[q],M[q]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const K=this.Mh;for(let H=0;H<16;H++)K[H]=Math.min(K[H],H<0||arguments.length<=H?void 0:arguments[H]);return this.markAsUpdated(),this}maximizeInPlace(K){const H=this.Mh,M=K.m;for(let q=0;q<16;q++)H[q]=Math.min(H[q],M[q]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const K=this.Mh;for(let H=0;H<16;H++)K[H]=Math.min(K[H],H<0||arguments.length<=H?void 0:arguments[H]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new B)}negateInPlace(){const K=this.Mh;for(let H=0;H<16;H++)K[H]=-K[H];return this.markAsUpdated(),this}negateToRef(K){const H=this.Mh,M=K.Mh;for(let q=0;q<16;q++)M[q]=-H[q];return K.markAsUpdated(),K}equals(K){const H=K;if(!H)return!1;if((this._isIdentity||H._isIdentity)&&!this._isIdentityDirty&&!H._isIdentityDirty)return this._isIdentity&&H._isIdentity;const M=this.m,q=H.m;return M[0]===q[0]&&M[1]===q[1]&&M[2]===q[2]&&M[3]===q[3]&&M[4]===q[4]&&M[5]===q[5]&&M[6]===q[6]&&M[7]===q[7]&&M[8]===q[8]&&M[9]===q[9]&&M[10]===q[10]&&M[11]===q[11]&&M[12]===q[12]&&M[13]===q[13]&&M[14]===q[14]&&M[15]===q[15]}equalsWithEpsilon(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const M=this.Mh,q=K.m;for(let w=0;w<16;w++)if(!(0,W.WithinEpsilon)(M[w],q[w],H))return!1;return!0}equalsToFloats(){const K=this.Mh;for(let H=0;H<16;H++)if(K[H]!=(H<0||arguments.length<=H?void 0:arguments[H]))return!1;return!0}floor(){return this.floorToRef(new B)}floorToRef(K){const H=this.Mh,M=K.Mh;for(let q=0;q<16;q++)M[q]=Math.floor(H[q]);return K.markAsUpdated(),K}fract(){return this.fractToRef(new B)}fractToRef(K){const H=this.Mh,M=K.Mh;for(let q=0;q<16;q++)M[q]=H[q]-Math.floor(H[q]);return K.markAsUpdated(),K}clone(){const K=new B;return K.q(this),K}getClassName(){return"Matrix"}getHashCode(){let K=a(this.Mh[0]);for(let H=1;H<16;H++)K=397*K^a(this.Mh[H]);return K}decomposeToTransformNode(K){return K.rotationQuaternion=K.rotationQuaternion||new S,this.decompose(K.Sh,K.rotationQuaternion,K.position)}decompose(K,H,M,q){let w=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return M&&M.Bh(0),K&&K.Bh(1),H&&H.Lh(0,0,0,1),!0;const u=this.Mh;if(M&&M.Lh(u[12],u[13],u[14]),(K=K||C.OH[0]).x=Math.sqrt(u[0]*u[0]+u[1]*u[1]+u[2]*u[2]),K.y=Math.sqrt(u[4]*u[4]+u[5]*u[5]+u[6]*u[6]),K.z=Math.sqrt(u[8]*u[8]+u[9]*u[9]+u[10]*u[10]),q){const H=(w?q.absoluteScaling.x:q.Sh.x)<0?-1:1,M=(w?q.absoluteScaling.y:q.Sh.y)<0?-1:1,u=(w?q.absoluteScaling.z:q.Sh.z)<0?-1:1;K.x*=H,K.y*=M,K.z*=u}else this.determinant()<=0&&(K.y*=-1);if(0===K._x||0===K._y||0===K._z)return H&&H.Lh(0,0,0,1),!1;if(H){const M=1/K._x,q=1/K._y,w=1/K._z;B.FromValuesToRef(u[0]*M,u[1]*M,u[2]*M,0,u[4]*q,u[5]*q,u[6]*q,0,u[8]*w,u[9]*w,u[10]*w,0,0,0,0,1,C.Matrix[0]),S.FromRotationMatrixToRef(C.Matrix[0],H)}return!0}getRow(K){if(K<0||K>3)return null;const H=4*K;return new L(this.Mh[H+0],this.Mh[H+1],this.Mh[H+2],this.Mh[H+3])}getRowToRef(K,H){if(K>=0&&K<=3){const M=4*K;H.x=this.Mh[M+0],H.y=this.Mh[M+1],H.z=this.Mh[M+2],H.w=this.Mh[M+3]}return H}setRow(K,H){return this.setRowFromFloats(K,H.x,H.y,H.z,H.w)}transpose(){const K=new B;return B.TransposeToRef(this,K),K}transposeToRef(K){return B.TransposeToRef(this,K),K}setRowFromFloats(K,H,M,q,w){if(K<0||K>3)return this;const u=4*K;return this.Mh[u+0]=H,this.Mh[u+1]=M,this.Mh[u+2]=q,this.Mh[u+3]=w,this.markAsUpdated(),this}scale(K){const H=new B;return this.scaleToRef(K,H),H}scaleToRef(K,H){for(let M=0;M<16;M++)H.Mh[M]=this.Mh[M]*K;return H.markAsUpdated(),H}scaleAndAddToRef(K,H){for(let M=0;M<16;M++)H.Mh[M]+=this.Mh[M]*K;return H.markAsUpdated(),H}scaleInPlace(K){const H=this.Mh;for(let M=0;M<16;M++)H[M]*=K;return this.markAsUpdated(),this}toNormalMatrix(K){const H=C.Matrix[0];this.invertToRef(H),H.transposeToRef(K);const M=K.Mh;return B.FromValuesToRef(M[0],M[1],M[2],0,M[4],M[5],M[6],0,M[8],M[9],M[10],0,0,0,0,1,K),K}getRotationMatrix(){const K=new B;return this.getRotationMatrixToRef(K),K}getRotationMatrixToRef(K){const H=C.OH[0];if(!this.decompose(H))return B.IdentityToRef(K),K;const M=this.Mh,q=1/H._x,w=1/H._y,u=1/H._z;return B.FromValuesToRef(M[0]*q,M[1]*q,M[2]*q,0,M[4]*w,M[5]*w,M[6]*w,0,M[8]*u,M[9]*u,M[10]*u,0,0,0,0,1,K),K}toggleModelMatrixHandInPlace(){const K=this.Mh;return K[2]*=-1,K[6]*=-1,K[8]*=-1,K[9]*=-1,K[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const K=this.Mh;return K[8]*=-1,K[9]*=-1,K[10]*=-1,K[11]*=-1,this.markAsUpdated(),this}static iH(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const M=new B;return B.FromArrayToRef(K,H,M),M}static FromArrayToRef(K,H,M){for(let q=0;q<16;q++)M.Mh[q]=K[q+H];return M.markAsUpdated(),M}static FromFloat32ArrayToRefScaled(K,H,M,q){return q.Mh[0]=K[0+H]*M,q.Mh[1]=K[1+H]*M,q.Mh[2]=K[2+H]*M,q.Mh[3]=K[3+H]*M,q.Mh[4]=K[4+H]*M,q.Mh[5]=K[5+H]*M,q.Mh[6]=K[6+H]*M,q.Mh[7]=K[7+H]*M,q.Mh[8]=K[8+H]*M,q.Mh[9]=K[9+H]*M,q.Mh[10]=K[10+H]*M,q.Mh[11]=K[11+H]*M,q.Mh[12]=K[12+H]*M,q.Mh[13]=K[13+H]*M,q.Mh[14]=K[14+H]*M,q.Mh[15]=K[15+H]*M,q.markAsUpdated(),q}static get IdentityReadOnly(){return B._IdentityReadOnly}static FromValuesToRef(K,H,M,q,w,u,y,h,W,I,f,z,G,a,v,O,L){const S=L.Mh;S[0]=K,S[1]=H,S[2]=M,S[3]=q,S[4]=w,S[5]=u,S[6]=y,S[7]=h,S[8]=W,S[9]=I,S[10]=f,S[11]=z,S[12]=G,S[13]=a,S[14]=v,S[15]=O,L.markAsUpdated()}static FromValues(K,H,M,q,w,u,y,h,W,I,f,z,G,a,v,O){const L=new B,S=L.Mh;return S[0]=K,S[1]=H,S[2]=M,S[3]=q,S[4]=w,S[5]=u,S[6]=y,S[7]=h,S[8]=W,S[9]=I,S[10]=f,S[11]=z,S[12]=G,S[13]=a,S[14]=v,S[15]=O,L.markAsUpdated(),L}static Compose(K,H,M){const q=new B;return B.ComposeToRef(K,H,M,q),q}static ComposeToRef(K,H,M,q){const w=q.Mh,u=H._x,y=H._y,h=H._z,W=H._w,I=u+u,f=y+y,z=h+h,G=u*I,a=u*f,v=u*z,O=y*f,L=y*z,S=h*z,B=W*I,C=W*f,i=W*z,Z=K._x,E=K._y,l=K._z;return w[0]=(1-(O+S))*Z,w[1]=(a+i)*Z,w[2]=(v-C)*Z,w[3]=0,w[4]=(a-i)*E,w[5]=(1-(G+S))*E,w[6]=(L+B)*E,w[7]=0,w[8]=(v+C)*l,w[9]=(L-B)*l,w[10]=(1-(G+O))*l,w[11]=0,w[12]=M._x,w[13]=M._y,w[14]=M._z,w[15]=1,q.markAsUpdated(),q}static Identity(){const K=B.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return K._updateIdentityStatus(!0),K}static IdentityToRef(K){return B.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,K),K._updateIdentityStatus(!0),K}static Zero(){const K=B.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return K._updateIdentityStatus(!1),K}static RotationX(K){const H=new B;return B.RotationXToRef(K,H),H}static Invert(K){const H=new B;return K.invertToRef(H),H}static RotationXToRef(K,H){const M=Math.sin(K),q=Math.cos(K);return B.FromValuesToRef(1,0,0,0,0,q,M,0,0,-M,q,0,0,0,0,1,H),H._updateIdentityStatus(1===q&&0===M),H}static RotationY(K){const H=new B;return B.RotationYToRef(K,H),H}static RotationYToRef(K,H){const M=Math.sin(K),q=Math.cos(K);return B.FromValuesToRef(q,0,-M,0,0,1,0,0,M,0,q,0,0,0,0,1,H),H._updateIdentityStatus(1===q&&0===M),H}static RotationZ(K){const H=new B;return B.RotationZToRef(K,H),H}static RotationZToRef(K,H){const M=Math.sin(K),q=Math.cos(K);return B.FromValuesToRef(q,M,0,0,-M,q,0,0,0,0,1,0,0,0,0,1,H),H._updateIdentityStatus(1===q&&0===M),H}static RotationAxis(K,H){const M=new B;return B.RotationAxisToRef(K,H,M),M}static RotationAxisToRef(K,H,M){const q=Math.sin(-H),w=Math.cos(-H),u=1-w;K=K.normalizeToRef(C.OH[0]);const y=M.Mh;return y[0]=K._x*K._x*u+w,y[1]=K._x*K._y*u-K._z*q,y[2]=K._x*K._z*u+K._y*q,y[3]=0,y[4]=K._y*K._x*u+K._z*q,y[5]=K._y*K._y*u+w,y[6]=K._y*K._z*u-K._x*q,y[7]=0,y[8]=K._z*K._x*u-K._y*q,y[9]=K._z*K._y*u+K._x*q,y[10]=K._z*K._z*u+w,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,M.markAsUpdated(),M}static RotationAlignToRef(K,H,M){let w=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const u=O.Dot(H,K),y=M.Mh;if(u<-1+q.d)y[0]=-1,y[1]=0,y[2]=0,y[3]=0,y[4]=0,y[5]=w?1:-1,y[6]=0,y[7]=0,y[8]=0,y[9]=0,y[10]=w?-1:1,y[11]=0;else{const M=O.Cross(H,K),q=1/(1+u);y[0]=M._x*M._x*q+u,y[1]=M._y*M._x*q-M._z,y[2]=M._z*M._x*q+M._y,y[3]=0,y[4]=M._x*M._y*q+M._z,y[5]=M._y*M._y*q+u,y[6]=M._z*M._y*q-M._x,y[7]=0,y[8]=M._x*M._z*q-M._y,y[9]=M._y*M._z*q+M._x,y[10]=M._z*M._z*q+u,y[11]=0}return y[12]=0,y[13]=0,y[14]=0,y[15]=1,M.markAsUpdated(),M}static RotationYawPitchRoll(K,H,M){const q=new B;return B.RotationYawPitchRollToRef(K,H,M,q),q}static RotationYawPitchRollToRef(K,H,M,q){return S.RotationYawPitchRollToRef(K,H,M,C.Quaternion[0]),C.Quaternion[0].toRotationMatrix(q),q}static Scaling(K,H,M){const q=new B;return B.ScalingToRef(K,H,M,q),q}static ScalingToRef(K,H,M,q){return B.FromValuesToRef(K,0,0,0,0,H,0,0,0,0,M,0,0,0,0,1,q),q._updateIdentityStatus(1===K&&1===H&&1===M),q}static Translation(K,H,M){const q=new B;return B.TranslationToRef(K,H,M,q),q}static TranslationToRef(K,H,M,q){return B.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,K,H,M,1,q),q._updateIdentityStatus(0===K&&0===H&&0===M),q}static Lerp(K,H,M){const q=new B;return B.LerpToRef(K,H,M,q),q}static LerpToRef(K,H,M,q){const w=q.Mh,u=K.m,y=H.m;for(let h=0;h<16;h++)w[h]=u[h]*(1-M)+y[h]*M;return q.markAsUpdated(),q}static DecomposeLerp(K,H,M){const q=new B;return B.DecomposeLerpToRef(K,H,M,q),q}static DecomposeLerpToRef(K,H,M,q){const w=C.OH[0],u=C.Quaternion[0],y=C.OH[1];K.decompose(w,u,y);const h=C.OH[2],W=C.Quaternion[1],I=C.OH[3];H.decompose(h,W,I);const f=C.OH[4];O.LerpToRef(w,h,M,f);const z=C.Quaternion[2];S.SlerpToRef(u,W,M,z);const G=C.OH[5];return O.LerpToRef(y,I,M,G),B.ComposeToRef(f,z,G,q),q}static LookAtLH(K,H,M){const q=new B;return B.LookAtLHToRef(K,H,M,q),q}static LookAtLHToRef(K,H,M,q){const w=C.OH[0],u=C.OH[1],y=C.OH[2];H.subtractToRef(K,y),y.normalize(),O.CrossToRef(M,y,w);const h=w.lengthSquared();0===h?w.x=1:w.normalizeFromLength(Math.sqrt(h)),O.CrossToRef(y,w,u),u.normalize();const W=-O.Dot(w,K),I=-O.Dot(u,K),f=-O.Dot(y,K);return B.FromValuesToRef(w._x,u._x,y._x,0,w._y,u._y,y._y,0,w._z,u._z,y._z,0,W,I,f,1,q),q}static LookAtRH(K,H,M){const q=new B;return B.LookAtRHToRef(K,H,M,q),q}static LookAtRHToRef(K,H,M,q){const w=C.OH[0],u=C.OH[1],y=C.OH[2];K.subtractToRef(H,y),y.normalize(),O.CrossToRef(M,y,w);const h=w.lengthSquared();0===h?w.x=1:w.normalizeFromLength(Math.sqrt(h)),O.CrossToRef(y,w,u),u.normalize();const W=-O.Dot(w,K),I=-O.Dot(u,K),f=-O.Dot(y,K);return B.FromValuesToRef(w._x,u._x,y._x,0,w._y,u._y,y._y,0,w._z,u._z,y._z,0,W,I,f,1,q),q}static LookDirectionLH(K,H){const M=new B;return B.LookDirectionLHToRef(K,H,M),M}static LookDirectionLHToRef(K,H,M){const q=C.OH[0];q.q(K),q.scaleInPlace(-1);const w=C.OH[1];return O.CrossToRef(H,q,w),B.FromValuesToRef(w._x,w._y,w._z,0,H._x,H._y,H._z,0,q._x,q._y,q._z,0,0,0,0,1,M),M}static LookDirectionRH(K,H){const M=new B;return B.LookDirectionRHToRef(K,H,M),M}static LookDirectionRHToRef(K,H,M){const q=C.OH[2];return O.CrossToRef(H,K,q),B.FromValuesToRef(q._x,q._y,q._z,0,H._x,H._y,H._z,0,K._x,K._y,K._z,0,0,0,0,1,M),M}static OrthoLH(K,H,M,q,w){const u=new B;return B.OrthoLHToRef(K,H,M,q,u,w),u}static OrthoLHToRef(K,H,M,q,w,u){const y=2/K,h=2/H,W=2/(q-M),I=-(q+M)/(q-M);return B.FromValuesToRef(y,0,0,0,0,h,0,0,0,0,W,0,0,0,I,1,w),u&&w.multiplyToRef(Z,w),w._updateIdentityStatus(1===y&&1===h&&1===W&&0===I),w}static OrthoOffCenterLH(K,H,M,q,w,u,y){const h=new B;return B.OrthoOffCenterLHToRef(K,H,M,q,w,u,h,y),h}static OrthoOffCenterLHToRef(K,H,M,q,w,u,y,h){const W=2/(H-K),I=2/(q-M),f=2/(u-w),z=-(u+w)/(u-w),G=(K+H)/(K-H),a=(q+M)/(M-q);return B.FromValuesToRef(W,0,0,0,0,I,0,0,0,0,f,0,G,a,z,1,y),h&&y.multiplyToRef(Z,y),y.markAsUpdated(),y}static ObliqueOffCenterLHToRef(K,H,M,q,w,u,y,h,W,I,f){const z=-y*Math.cos(h),G=-y*Math.sin(h);return B.TranslationToRef(0,0,-W,C.Matrix[1]),B.FromValuesToRef(1,0,0,0,0,1,0,0,z,G,1,0,0,0,0,1,C.Matrix[0]),C.Matrix[1].multiplyToRef(C.Matrix[0],C.Matrix[0]),B.TranslationToRef(0,0,W,C.Matrix[1]),C.Matrix[0].multiplyToRef(C.Matrix[1],C.Matrix[0]),B.OrthoOffCenterLHToRef(K,H,M,q,w,u,I,f),C.Matrix[0].multiplyToRef(I,I),I}static OrthoOffCenterRH(K,H,M,q,w,u,y){const h=new B;return B.OrthoOffCenterRHToRef(K,H,M,q,w,u,h,y),h}static OrthoOffCenterRHToRef(K,H,M,q,w,u,y,h){return B.OrthoOffCenterLHToRef(K,H,M,q,w,u,y,h),y.Mh[10]*=-1,y}static ObliqueOffCenterRHToRef(K,H,M,q,w,u,y,h,W,I,f){const z=y*Math.cos(h),G=y*Math.sin(h);return B.TranslationToRef(0,0,W,C.Matrix[1]),B.FromValuesToRef(1,0,0,0,0,1,0,0,z,G,1,0,0,0,0,1,C.Matrix[0]),C.Matrix[1].multiplyToRef(C.Matrix[0],C.Matrix[0]),B.TranslationToRef(0,0,-W,C.Matrix[1]),C.Matrix[0].multiplyToRef(C.Matrix[1],C.Matrix[0]),B.OrthoOffCenterRHToRef(K,H,M,q,w,u,I,f),C.Matrix[0].multiplyToRef(I,I),I}static PerspectiveLH(K,H,M,q,w){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const y=new B,h=2*M/K,W=2*M/H,I=(q+M)/(q-M),f=-2*q*M/(q-M),z=Math.tan(u);return B.FromValuesToRef(h,0,0,0,0,W,0,z,0,0,I,1,0,0,f,0,y),w&&y.multiplyToRef(Z,y),y._updateIdentityStatus(!1),y}static PerspectiveFovLH(K,H,M,q,w){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const h=new B;return B.PerspectiveFovLHToRef(K,H,M,q,h,!0,w,u,y),h}static PerspectiveFovLHToRef(K,H,M,q,w){let u=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,W=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const I=M,f=q,z=1/Math.tan(.5*K),G=u?z/H:z,a=u?z:z*H,v=W&&0===I?-1:0!==f?(f+I)/(f-I):1,O=W&&0===I?2*f:0!==f?-2*f*I/(f-I):-2*I,L=Math.tan(h);return B.FromValuesToRef(G,0,0,0,0,a,0,L,0,0,v,1,0,0,O,0,w),y&&w.multiplyToRef(Z,w),w._updateIdentityStatus(!1),w}static PerspectiveFovReverseLHToRef(K,H,M,q,w){let u=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const W=1/Math.tan(.5*K),I=u?W/H:W,f=u?W:W*H,z=Math.tan(h);return B.FromValuesToRef(I,0,0,0,0,f,0,z,0,0,-M,1,0,0,1,0,w),y&&w.multiplyToRef(Z,w),w._updateIdentityStatus(!1),w}static PerspectiveFovRH(K,H,M,q,w){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const h=new B;return B.PerspectiveFovRHToRef(K,H,M,q,h,!0,w,u,y),h}static PerspectiveFovRHToRef(K,H,M,q,w){let u=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,W=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const I=M,f=q,z=1/Math.tan(.5*K),G=u?z/H:z,a=u?z:z*H,v=W&&0===I?1:0!==f?-(f+I)/(f-I):-1,O=W&&0===I?2*f:0!==f?-2*f*I/(f-I):-2*I,L=Math.tan(h);return B.FromValuesToRef(G,0,0,0,0,a,0,L,0,0,v,-1,0,0,O,0,w),y&&w.multiplyToRef(Z,w),w._updateIdentityStatus(!1),w}static PerspectiveFovReverseRHToRef(K,H,M,q,w){let u=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],y=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const W=1/Math.tan(.5*K),I=u?W/H:W,f=u?W:W*H,z=Math.tan(h);return B.FromValuesToRef(I,0,0,0,0,f,0,z,0,0,-M,-1,0,0,-1,0,w),y&&w.multiplyToRef(Z,w),w._updateIdentityStatus(!1),w}static GetFinalMatrix(K,H,M,q,w,u){const y=K.width,h=K.height,W=K.x,I=K.y,f=B.FromValues(y/2,0,0,0,0,-h/2,0,0,0,0,u-w,0,W+y/2,h/2+I,w,1),z=new B;return H.multiplyToRef(M,z),z.multiplyToRef(q,z),z.multiplyToRef(f,z)}static GetAsMatrix2x2(K){const H=K.m,M=[H[0],H[1],H[4],H[5]];return y.d.MatrixUse64Bits?M:new Float32Array(M)}static GetAsMatrix3x3(K){const H=K.m,M=[H[0],H[1],H[2],H[4],H[5],H[6],H[8],H[9],H[10]];return y.d.MatrixUse64Bits?M:new Float32Array(M)}static Transpose(K){const H=new B;return B.TransposeToRef(K,H),H}static TransposeToRef(K,H){const M=K.m,q=M[0],w=M[4],u=M[8],y=M[12],h=M[1],W=M[5],I=M[9],f=M[13],z=M[2],G=M[6],a=M[10],v=M[14],O=M[3],L=M[7],S=M[11],B=M[15],C=H.Mh;return C[0]=q,C[1]=w,C[2]=u,C[3]=y,C[4]=h,C[5]=W,C[6]=I,C[7]=f,C[8]=z,C[9]=G,C[10]=a,C[11]=v,C[12]=O,C[13]=L,C[14]=S,C[15]=B,H.markAsUpdated(),H._updateIdentityStatus(K._isIdentity,K._isIdentityDirty),H}static Reflection(K){const H=new B;return B.ReflectionToRef(K,H),H}static ReflectionToRef(K,H){K.normalize();const M=K.normal.x,q=K.normal.y,w=K.normal.z,u=-2*M,y=-2*q,h=-2*w;return B.FromValuesToRef(u*M+1,y*M,h*M,0,u*q,y*q+1,h*q,0,u*w,y*w,h*w+1,0,u*K.d,y*K.d,h*K.d,1,H),H}static FromXYZAxesToRef(K,H,M,q){return B.FromValuesToRef(K._x,K._y,K._z,0,H._x,H._y,H._z,0,M._x,M._y,M._z,0,0,0,0,1,q),q}static FromQuaternionToRef(K,H){const M=K._x*K._x,q=K._y*K._y,w=K._z*K._z,u=K._x*K._y,y=K._z*K._w,h=K._z*K._x,W=K._y*K._w,I=K._y*K._z,f=K._x*K._w;return H.Mh[0]=1-2*(q+w),H.Mh[1]=2*(u+y),H.Mh[2]=2*(h-W),H.Mh[3]=0,H.Mh[4]=2*(u-y),H.Mh[5]=1-2*(w+M),H.Mh[6]=2*(I+f),H.Mh[7]=0,H.Mh[8]=2*(h+W),H.Mh[9]=2*(I-f),H.Mh[10]=1-2*(q+M),H.Mh[11]=0,H.Mh[12]=0,H.Mh[13]=0,H.Mh[14]=0,H.Mh[15]=1,H.markAsUpdated(),H}}B._IdentityReadOnly=B.Identity(),Object.defineProperties(B.prototype,{dimension:{value:[4,4]},rank:{value:2}});class C{}C.OH=(0,w.e)(11,O.Zero),C.Matrix=(0,w.e)(2,B.Identity),C.Quaternion=(0,w.e)(3,S.Zero);class i{}i.Vector2=(0,w.e)(3,v.Zero),i.OH=(0,w.e)(13,O.Zero),i.Vector4=(0,w.e)(3,L.Zero),i.Quaternion=(0,w.e)(3,S.Zero),i.Matrix=(0,w.e)(8,B.Identity),(0,u.f)("BABYLON.Vector2",v),(0,u.f)("BABYLON.Vector3",O),(0,u.f)("BABYLON.Vector4",L),(0,u.f)("BABYLON.Matrix",B);const Z=B.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11301:(K,H,M)=>{function q(K,H){const M=[];for(let q=0;q<K;++q)M.push(H());return M}function w(K,H){return q(K,H)}M.d(H,{d:()=>q,e:()=>w,f:()=>y});const u=["push","splice","pop","shift","unshift"];function y(K,H){const M=u.map((M=>function(K,H,M){const q=K[H];if("function"!==typeof q)return null;const w=function(){const q=K.length,u=w.previous.apply(K,arguments);return M(H,q),u};return q.next=w,w.previous=q,K[H]=w,()=>{const M=w.previous;if(!M)return;const q=w.next;q?(M.next=q,q.previous=M):(M.next=void 0,K[H]=M),w.next=void 0,w.previous=void 0}}(K,M,H)));return()=>{for(const K of M)null===K||void 0===K||K()}}}}]);