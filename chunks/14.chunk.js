"use strict";(self.vfdo5lmva5i=self.vfdo5lmva5i||[]).push([[14],{11722:(w,o,H)=>{H.d(o,{c:()=>D,d:()=>e,e:()=>h,g:()=>E});const h=1/2.2,E=2.2,e=(1+Math.sqrt(5))/2,D=.001},11729:(w,o,H)=>{function h(w){return parseInt(w.toString().replace(/\W/g,""))}function E(w,o){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(w-o)<=H}function e(w,o,H){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return w<o-h||w>H+h}function D(w,o){return w===o?w:Math.random()*(o-w)+w}function t(w,o,H){return w+(o-w)*H}function X(w,o,H){let h=i(o-w,360);return h>180&&(h-=360),w+h*z(H)}function L(w,o,H){let h=0;return h=w!=o?z((H-w)/(o-w)):0,h}function A(w,o,H,h,E){const e=E*E,D=E*e;return w*(2*D-3*e+1)+H*(-2*D+3*e)+o*(D-2*e+E)+h*(D-e)}function y(w,o,H,h,E){const e=E*E;return 6*(e-E)*w+(3*e-4*E+1)*o+6*(-e+E)*H+(3*e-2*E)*h}function z(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(H,Math.max(o,w))}function C(w){return w-=2*Math.PI*Math.floor((w+Math.PI)/(2*Math.PI))}function Q(w){const o=w.toString(16);return w<=15?("0"+o).toUpperCase():o.toUpperCase()}function M(w){if(Math.log2)return Math.floor(Math.log2(w));if(w<0)return NaN;if(0===w)return-1/0;let o=0;if(w<1){for(;w<1;)o++,w*=2;o=-o}else if(w>1)for(;w>1;)o++,w=Math.floor(w/2);return o}function i(w,o){return w-Math.floor(w/o)*o}function s(w,o,H){return(w-o)/(H-o)}function V(w,o,H){return w*(H-o)+o}function r(w,o){let H=i(o-w,360);return H>180&&(H-=360),H}function k(w,o){const H=i(w,2*o);return o-Math.abs(H-o)}function P(w,o,H){let h=z(H);return h=-2*h*h*h+3*h*h,o*h+w*(1-h)}function l(w,o,H){let h=0;return h=Math.abs(o-w)<=H?o:w+Math.sign(o-w)*H,h}function O(w,o,H){const h=r(w,o);let E=0;return E=-H<h&&h<H?o:l(w,o=w+h,H),E}function T(w,o,H){return(w-o)/(H-o)}function S(w,o,H){return(H-o)*w+o}function c(w,o){const H=w%o;return 0===H?o:c(o,H)}H.r(o),H.d(o,{Clamp:()=>z,DeltaAngle:()=>r,Denormalize:()=>V,ExtractAsInt:()=>h,Hermite:()=>A,Hermite1stDerivative:()=>y,HighestCommonFactor:()=>c,ILog2:()=>M,InverseLerp:()=>L,Lerp:()=>t,LerpAngle:()=>X,MoveTowards:()=>l,MoveTowardsAngle:()=>O,Normalize:()=>s,NormalizeRadians:()=>C,OutsideRange:()=>e,PercentToRange:()=>S,PingPong:()=>k,RandomRange:()=>D,RangeToPercent:()=>T,Repeat:()=>i,SmoothStep:()=>P,ToHex:()=>Q,WithinEpsilon:()=>E})},11720:(w,o,H)=>{H.r(o),H.d(o,{Matrix:()=>V,Quaternion:()=>s,TmpVectors:()=>k,Vector2:()=>Q,io:()=>M,Vector4:()=>i});var h=H(11722),E=H(11727),e=H(11666),D=H(11635),t=H(11571),X=H(11729);class L{}function A(w,o,H){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const E=w.Ae(),e=o.Ae(),D=E[0],t=E[1],X=E[2],L=E[3],A=E[4],y=E[5],z=E[6],C=E[7],Q=E[8],M=E[9],i=E[10],s=E[11],V=E[12],r=E[13],k=E[14],P=E[15],l=e[0],O=e[1],T=e[2],S=e[3],c=e[4],W=e[5],B=e[6],J=e[7],g=e[8],b=e[9],p=e[10],f=e[11],N=e[12],j=e[13],q=e[14],u=e[15];H[h]=D*l+t*c+X*g+L*N,H[h+1]=D*O+t*W+X*b+L*j,H[h+2]=D*T+t*B+X*p+L*q,H[h+3]=D*S+t*J+X*f+L*u,H[h+4]=A*l+y*c+z*g+C*N,H[h+5]=A*O+y*W+z*b+C*j,H[h+6]=A*T+y*B+z*p+C*q,H[h+7]=A*S+y*J+z*f+C*u,H[h+8]=Q*l+M*c+i*g+s*N,H[h+9]=Q*O+M*W+i*b+s*j,H[h+10]=Q*T+M*B+i*p+s*q,H[h+11]=Q*S+M*J+i*f+s*u,H[h+12]=V*l+r*c+k*g+P*N,H[h+13]=V*O+r*W+k*b+P*j,H[h+14]=V*T+r*B+k*p+P*q,H[h+15]=V*S+r*J+k*f+P*u}function y(w,o){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const h=w.Ae();o[H]=h[0],o[H+1]=h[1],o[H+2]=h[2],o[H+3]=h[3],o[H+4]=h[4],o[H+5]=h[5],o[H+6]=h[6],o[H+7]=h[7],o[H+8]=h[8],o[H+9]=h[9],o[H+10]=h[10],o[H+11]=h[11],o[H+12]=h[12],o[H+13]=h[13],o[H+14]=h[14],o[H+15]=h[15]}function z(w,o){const H=w.Ae(),h=H[0],E=H[1],e=H[2],D=H[3],t=H[4],X=H[5],L=H[6],A=H[7],y=H[8],z=H[9],C=H[10],Q=H[11],M=H[12],i=H[13],s=H[14],V=H[15],r=C*V-s*Q,k=z*V-i*Q,P=z*s-i*C,l=y*V-M*Q,O=y*s-C*M,T=y*i-M*z,S=+(X*r-L*k+A*P),c=-(t*r-L*l+A*O),W=+(t*k-X*l+A*T),B=-(t*P-X*O+L*T),J=h*S+E*c+e*W+D*B;if(0===J)return!1;const g=1/J,b=L*V-s*A,p=X*V-i*A,f=X*s-i*L,N=t*V-M*A,j=t*s-M*L,q=t*i-M*X,u=L*Q-C*A,n=X*Q-z*A,G=X*C-z*L,R=t*Q-y*A,a=t*C-y*L,d=t*z-y*X,I=-(E*r-e*k+D*P),U=+(h*r-e*l+D*O),Z=-(h*k-E*l+D*T),K=+(h*P-E*O+e*T),F=+(E*b-e*p+D*f),v=-(h*b-e*N+D*j),mw=+(h*p-E*N+D*q),Y=-(h*f-E*j+e*q),x=-(E*u-e*n+D*G),ww=+(h*u-e*R+D*a),ow=-(h*n-E*R+D*d),Hw=+(h*G-E*a+e*d);return o[0]=S*g,o[1]=I*g,o[2]=F*g,o[3]=x*g,o[4]=c*g,o[5]=U*g,o[6]=v*g,o[7]=ww*g,o[8]=W*g,o[9]=Z*g,o[10]=mw*g,o[11]=ow*g,o[12]=B*g,o[13]=K*g,o[14]=Y*g,o[15]=Hw*g,!0}L._UpdateFlagSeed=0;const C=w=>parseInt(w.toString().replace(/\W/g,""));class Q{constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=w,this.y=o}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let w=C(this.x);return w=397*w^C(this.y),w}toArray(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w[o]=this.x,w[o+1]=this.y,this}iH(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(w,o,this),this}Ae(){return[this.x,this.y]}t(w){return this.x=w.x,this.y=w.y,this}We(w,o){return this.x=w,this.y=o,this}set(w,o){return this.We(w,o)}Ge(w){return this.We(w,w)}add(w){return new Q(this.x+w.x,this.y+w.y)}addToRef(w,o){return o.x=this.x+w.x,o.y=this.y+w.y,o}addInPlace(w){return this.x+=w.x,this.y+=w.y,this}addInPlaceFromFloats(w,o){return this.x+=w,this.y+=o,this}addVector3(w){return new Q(this.x+w.x,this.y+w.y)}so(w){return new Q(this.x-w.x,this.y-w.y)}subtractToRef(w,o){return o.x=this.x-w.x,o.y=this.y-w.y,o}wy(w){return this.x-=w.x,this.y-=w.y,this}multiplyInPlace(w){return this.x*=w.x,this.y*=w.y,this}multiply(w){return new Q(this.x*w.x,this.y*w.y)}multiplyToRef(w,o){return o.x=this.x*w.x,o.y=this.y*w.y,o}multiplyByFloats(w,o){return new Q(this.x*w,this.y*o)}divide(w){return new Q(this.x/w.x,this.y/w.y)}divideToRef(w,o){return o.x=this.x/w.x,o.y=this.y/w.y,o}divideInPlace(w){return this.x=this.x/w.x,this.y=this.y/w.y,this}minimizeInPlace(w){return this.minimizeInPlaceFromFloats(w.x,w.y)}maximizeInPlace(w){return this.maximizeInPlaceFromFloats(w.x,w.y)}minimizeInPlaceFromFloats(w,o){return this.x=Math.min(w,this.x),this.y=Math.min(o,this.y),this}maximizeInPlaceFromFloats(w,o){return this.x=Math.max(w,this.x),this.y=Math.max(o,this.y),this}subtractFromFloats(w,o){return new Q(this.x-w,this.y-o)}subtractFromFloatsToRef(w,o,H){return H.x=this.x-w,H.y=this.y-o,H}negate(){return new Q(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(w){return w.x=-this.x,w.y=-this.y,w}scaleInPlace(w){return this.x*=w,this.y*=w,this}scale(w){return new Q(this.x*w,this.y*w)}scaleToRef(w,o){return o.x=this.x*w,o.y=this.y*w,o}scaleAndAddToRef(w,o){return o.x+=this.x*w,o.y+=this.y*w,o}equals(w){return w&&this.x===w.x&&this.y===w.y}equalsWithEpsilon(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.c;return w&&(0,X.WithinEpsilon)(this.x,w.x,o)&&(0,X.WithinEpsilon)(this.y,w.y,o)}equalsToFloats(w,o){return this.x===w&&this.y===o}floor(){return new Q(Math.floor(this.x),Math.floor(this.y))}floorToRef(w){return w.x=Math.floor(this.x),w.y=Math.floor(this.y),w}fract(){return new Q(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(w){return w.x=this.x-Math.floor(this.x),w.y=this.y-Math.floor(this.y),w}rotate(w){return this.rotateToRef(w,new Q)}rotateToRef(w,o){const H=Math.cos(w),h=Math.sin(w);return o.x=H*this.x-h*this.y,o.y=h*this.x+H*this.y,o}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(w){return 0===w||1===w?this:this.scaleInPlace(1/w)}normalizeToNew(){const w=new Q;return this.normalizeToRef(w),w}normalizeToRef(w){const o=this.length();return 0===o&&(w.x=this.x,w.y=this.y),this.scaleToRef(1/o,w)}clone(){return new Q(this.x,this.y)}dot(w){return this.x*w.x+this.y*w.y}static Zero(){return new Q(0,0)}static One(){return new Q(1,1)}static Random(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Q((0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o))}static RandomToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).We((0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o))}static get ZeroReadOnly(){return Q._ZeroReadOnly}static Po(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Q(w[o],w[o+1])}static FromArrayToRef(w,o,H){return H.x=w[o],H.y=w[o+1],H}static FromFloatsToRef(w,o,H){return H.We(w,o),H}static CatmullRom(w,o,H,h,E){const e=E*E,D=E*e,t=.5*(2*o.x+(-w.x+H.x)*E+(2*w.x-5*o.x+4*H.x-h.x)*e+(-w.x+3*o.x-3*H.x+h.x)*D),X=.5*(2*o.y+(-w.y+H.y)*E+(2*w.y-5*o.y+4*H.y-h.y)*e+(-w.y+3*o.y-3*H.y+h.y)*D);return new Q(t,X)}static ClampToRef(w,o,H,h){return h.x=(0,X.Clamp)(w.x,o.x,H.x),h.y=(0,X.Clamp)(w.y,o.y,H.y),h}static Clamp(w,o,H){const h=(0,X.Clamp)(w.x,o.x,H.x),E=(0,X.Clamp)(w.y,o.y,H.y);return new Q(h,E)}static Hermite(w,o,H,h,E){const e=E*E,D=E*e,t=2*D-3*e+1,X=-2*D+3*e,L=D-2*e+E,A=D-e,y=w.x*t+H.x*X+o.x*L+h.x*A,z=w.y*t+H.y*X+o.y*L+h.y*A;return new Q(y,z)}static Hermite1stDerivative(w,o,H,h,E){return this.Hermite1stDerivativeToRef(w,o,H,h,E,new Q)}static Hermite1stDerivativeToRef(w,o,H,h,E,e){const D=E*E;return e.x=6*(D-E)*w.x+(3*D-4*E+1)*o.x+6*(-D+E)*H.x+(3*D-2*E)*h.x,e.y=6*(D-E)*w.y+(3*D-4*E+1)*o.y+6*(-D+E)*H.y+(3*D-2*E)*h.y,e}static Lerp(w,o,H){return Q.LerpToRef(w,o,H,new Q)}static LerpToRef(w,o,H,h){return h.x=w.x+(o.x-w.x)*H,h.y=w.y+(o.y-w.y)*H,h}static Dot(w,o){return w.x*o.x+w.y*o.y}static Normalize(w){return Q.NormalizeToRef(w,new Q)}static NormalizeToRef(w,o){return w.normalizeToRef(o),o}static Minimize(w,o){const H=w.x<o.x?w.x:o.x,h=w.y<o.y?w.y:o.y;return new Q(H,h)}static Maximize(w,o){const H=w.x>o.x?w.x:o.x,h=w.y>o.y?w.y:o.y;return new Q(H,h)}static Transform(w,o){return Q.TransformToRef(w,o,new Q)}static TransformToRef(w,o,H){const h=o.m,E=w.x*h[0]+w.y*h[4]+h[12],e=w.x*h[1]+w.y*h[5]+h[13];return H.x=E,H.y=e,H}static PointInTriangle(w,o,H,h){const E=.5*(-H.y*h.x+o.y*(-H.x+h.x)+o.x*(H.y-h.y)+H.x*h.y),e=E<0?-1:1,D=(o.y*h.x-o.x*h.y+(h.y-o.y)*w.x+(o.x-h.x)*w.y)*e,t=(o.x*H.y-o.y*H.x+(o.y-H.y)*w.x+(H.x-o.x)*w.y)*e;return D>0&&t>0&&D+t<2*E*e}static Distance(w,o){return Math.sqrt(Q.DistanceSquared(w,o))}static DistanceSquared(w,o){const H=w.x-o.x,h=w.y-o.y;return H*H+h*h}static Center(w,o){return Q.CenterToRef(w,o,new Q)}static CenterToRef(w,o,H){return H.We((w.x+o.x)/2,(w.y+o.y)/2)}static DistanceOfPointFromSegment(w,o,H){const h=Q.DistanceSquared(o,H);if(0===h)return Q.Distance(w,o);const E=H.so(o),e=Math.max(0,Math.min(1,Q.Dot(w.so(o),E)/h)),D=o.add(E.multiplyByFloats(e,e));return Q.Distance(w,D)}}Q._V8PerformanceHack=new Q(.5,.5),Q._ZeroReadOnly=Q.Zero(),Object.defineProperties(Q.prototype,{dimension:{value:[2]},rank:{value:1}});class M{get x(){return this._x}set x(w){this._x=w,this._isDirty=!0}get y(){return this._y}set y(w){this._y=w,this._isDirty=!0}get z(){return this._z}set z(w){this._z=w,this._isDirty=!0}constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=w,this._y=o,this._z=H}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"io"}getHashCode(){let w=C(this._x);return w=397*w^C(this._y),w=397*w^C(this._z),w}Ae(){return[this._x,this._y,this._z]}toArray(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w[o]=this._x,w[o+1]=this._y,w[o+2]=this._z,this}iH(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M.FromArrayToRef(w,o,this),this}toQuaternion(){return s.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(w){return this._x+=w._x,this._y+=w._y,this._z+=w._z,this._isDirty=!0,this}addInPlaceFromFloats(w,o,H){return this._x+=w,this._y+=o,this._z+=H,this._isDirty=!0,this}add(w){return new M(this._x+w._x,this._y+w._y,this._z+w._z)}addToRef(w,o){return o._x=this._x+w._x,o._y=this._y+w._y,o._z=this._z+w._z,o._isDirty=!0,o}wy(w){return this._x-=w._x,this._y-=w._y,this._z-=w._z,this._isDirty=!0,this}so(w){return new M(this._x-w._x,this._y-w._y,this._z-w._z)}subtractToRef(w,o){return this.subtractFromFloatsToRef(w._x,w._y,w._z,o)}subtractFromFloats(w,o,H){return new M(this._x-w,this._y-o,this._z-H)}subtractFromFloatsToRef(w,o,H,h){return h._x=this._x-w,h._y=this._y-o,h._z=this._z-H,h._isDirty=!0,h}negate(){return new M(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(w){return w._x=-1*this._x,w._y=-1*this._y,w._z=-1*this._z,w._isDirty=!0,w}scaleInPlace(w){return this._x*=w,this._y*=w,this._z*=w,this._isDirty=!0,this}scale(w){return new M(this._x*w,this._y*w,this._z*w)}scaleToRef(w,o){return o._x=this._x*w,o._y=this._y*w,o._z=this._z*w,o._isDirty=!0,o}getNormalToRef(w){const o=this.length();let H=Math.acos(this._y/o);const h=Math.atan2(this._z,this._x);H>Math.PI/2?H-=Math.PI/2:H+=Math.PI/2;const E=o*Math.sin(H)*Math.cos(h),e=o*Math.cos(H),D=o*Math.sin(H)*Math.sin(h);return w.set(E,e,D),w}applyRotationQuaternionToRef(w,o){const H=this._x,h=this._y,E=this._z,e=w._x,D=w._y,t=w._z,X=w._w,L=2*(D*E-t*h),A=2*(t*H-e*E),y=2*(e*h-D*H);return o._x=H+X*L+D*y-t*A,o._y=h+X*A+t*L-e*y,o._z=E+X*y+e*A-D*L,o._isDirty=!0,o}applyRotationQuaternionInPlace(w){return this.applyRotationQuaternionToRef(w,this)}applyRotationQuaternion(w){return this.applyRotationQuaternionToRef(w,new M)}scaleAndAddToRef(w,o){return o._x+=this._x*w,o._y+=this._y*w,o._z+=this._z*w,o._isDirty=!0,o}projectOnPlane(w,o){return this.projectOnPlaneToRef(w,o,new M)}projectOnPlaneToRef(w,o,H){const h=w.normal,E=w.d,e=r.io[0];this.subtractToRef(o,e),e.normalize();const D=M.Dot(e,h);if(Math.abs(D)<1e-10)H.Ge(1/0);else{const w=-(M.Dot(o,h)+E)/D,t=e.scaleInPlace(w);o.addToRef(t,H)}return H}equals(w){return w&&this._x===w._x&&this._y===w._y&&this._z===w._z}equalsWithEpsilon(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.c;return w&&(0,X.WithinEpsilon)(this._x,w._x,o)&&(0,X.WithinEpsilon)(this._y,w._y,o)&&(0,X.WithinEpsilon)(this._z,w._z,o)}equalsToFloats(w,o,H){return this._x===w&&this._y===o&&this._z===H}multiplyInPlace(w){return this._x*=w._x,this._y*=w._y,this._z*=w._z,this._isDirty=!0,this}multiply(w){return this.multiplyByFloats(w._x,w._y,w._z)}multiplyToRef(w,o){return o._x=this._x*w._x,o._y=this._y*w._y,o._z=this._z*w._z,o._isDirty=!0,o}multiplyByFloats(w,o,H){return new M(this._x*w,this._y*o,this._z*H)}divide(w){return new M(this._x/w._x,this._y/w._y,this._z/w._z)}divideToRef(w,o){return o._x=this._x/w._x,o._y=this._y/w._y,o._z=this._z/w._z,o._isDirty=!0,o}divideInPlace(w){return this._x=this._x/w._x,this._y=this._y/w._y,this._z=this._z/w._z,this._isDirty=!0,this}minimizeInPlace(w){return this.minimizeInPlaceFromFloats(w._x,w._y,w._z)}maximizeInPlace(w){return this.maximizeInPlaceFromFloats(w._x,w._y,w._z)}minimizeInPlaceFromFloats(w,o,H){return w<this._x&&(this.x=w),o<this._y&&(this.y=o),H<this._z&&(this.z=H),this}maximizeInPlaceFromFloats(w,o,H){return w>this._x&&(this.x=w),o>this._y&&(this.y=o),H>this._z&&(this.z=H),this}isNonUniformWithinEpsilon(w){const o=Math.abs(this._x),H=Math.abs(this._y);if(!(0,X.WithinEpsilon)(o,H,w))return!0;const h=Math.abs(this._z);return!(0,X.WithinEpsilon)(o,h,w)||!(0,X.WithinEpsilon)(H,h,w)}get isNonUniform(){const w=Math.abs(this._x);if(w!==Math.abs(this._y))return!0;return w!==Math.abs(this._z)}floorToRef(w){return w._x=Math.floor(this._x),w._y=Math.floor(this._y),w._z=Math.floor(this._z),w._isDirty=!0,w}floor(){return new M(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(w){return w._x=this._x-Math.floor(this._x),w._y=this._y-Math.floor(this._y),w._z=this._z-Math.floor(this._z),w._isDirty=!0,w}fract(){return new M(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(w){if("xyz"===(w=w.toLowerCase()))return this;const o=r.io[0].t(this);return this.x=o[w[0]],this.y=o[w[1]],this.z=o[w[2]],this}rotateByQuaternionToRef(w,o){return w.toRotationMatrix(r.Matrix[0]),M.TransformCoordinatesToRef(this,r.Matrix[0],o),o}rotateByQuaternionAroundPointToRef(w,o,H){return this.subtractToRef(o,r.io[0]),r.io[0].rotateByQuaternionToRef(w,r.io[0]),o.addToRef(r.io[0],H),H}cross(w){return M.CrossToRef(this,w,new M)}normalizeFromLength(w){return 0===w||1===w?this:this.scaleInPlace(1/w)}normalizeToNew(){return this.normalizeToRef(new M)}normalizeToRef(w){const o=this.length();return 0===o||1===o?(w._x=this._x,w._y=this._y,w._z=this._z,w._isDirty=!0,w):this.scaleToRef(1/o,w)}clone(){return new M(this._x,this._y,this._z)}t(w){return this.We(w._x,w._y,w._z)}We(w,o,H){return this._x=w,this._y=o,this._z=H,this._isDirty=!0,this}set(w,o,H){return this.We(w,o,H)}Ge(w){return this._x=this._y=this._z=w,this._isDirty=!0,this}static GetClipFactor(w,o,H,h){const E=M.Dot(w,H);return(E-h)/(E-M.Dot(o,H))}static GetAngleBetweenVectors(w,o,H){const h=w.normalizeToRef(r.io[1]),E=o.normalizeToRef(r.io[2]);let e=M.Dot(h,E);e=(0,X.Clamp)(e,-1,1);const D=Math.acos(e),t=r.io[3];return M.CrossToRef(h,E,t),M.Dot(t,H)>0?isNaN(D)?0:D:isNaN(D)?-Math.PI:-Math.acos(e)}static GetAngleBetweenVectorsOnPlane(w,o,H){r.io[0].t(w);const h=r.io[0];r.io[1].t(o);const E=r.io[1];r.io[2].t(H);const e=r.io[2],D=r.io[3],t=r.io[4];h.normalize(),E.normalize(),e.normalize(),M.CrossToRef(e,h,D),M.CrossToRef(D,e,t);const L=Math.atan2(M.Dot(E,D),M.Dot(E,t));return(0,X.NormalizeRadians)(L)}static PitchYawRollToMoveBetweenPointsToRef(w,o,H){const h=k.io[0];return o.subtractToRef(w,h),H._y=Math.atan2(h.x,h.z)||0,H._x=Math.atan2(Math.sqrt(h.x**2+h.z**2),h.y)||0,H._z=0,H._isDirty=!0,H}static PitchYawRollToMoveBetweenPoints(w,o){const H=M.Zero();return M.PitchYawRollToMoveBetweenPointsToRef(w,o,H)}static SlerpToRef(w,o,H,E){H=(0,X.Clamp)(H,0,1);const e=r.io[0],D=r.io[1];e.t(w);const t=e.length();e.normalizeFromLength(t),D.t(o);const L=D.length();D.normalizeFromLength(L);const A=M.Dot(e,D);let y,z;if(A<1-h.c){const w=Math.acos(A),o=1/Math.sin(w);y=Math.sin((1-H)*w)*o,z=Math.sin(H*w)*o}else y=1-H,z=H;return e.scaleInPlace(y),D.scaleInPlace(z),E.t(e).addInPlace(D),E.scaleInPlace((0,X.Lerp)(t,L,H)),E}static SmoothToRef(w,o,H,h,E){return M.SlerpToRef(w,o,0===h?1:H/h,E),E}static Po(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new M(w[o],w[o+1],w[o+2])}static FromFloatArray(w,o){return M.Po(w,o)}static FromArrayToRef(w,o,H){return H._x=w[o],H._y=w[o+1],H._z=w[o+2],H._isDirty=!0,H}static FromFloatArrayToRef(w,o,H){return M.FromArrayToRef(w,o,H)}static FromFloatsToRef(w,o,H,h){return h.We(w,o,H),h}static Zero(){return new M(0,0,0)}static One(){return new M(1,1,1)}static Up(){return new M(0,1,0)}static get UpReadOnly(){return M._UpReadOnly}static get DownReadOnly(){return M._DownReadOnly}static get RightReadOnly(){return M._RightReadOnly}static get LeftReadOnly(){return M._LeftReadOnly}static get LeftHandedForwardReadOnly(){return M._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return M._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return M._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return M._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return M._ZeroReadOnly}static get OneReadOnly(){return M._OneReadOnly}static Down(){return new M(0,-1,0)}static Forward(){return new M(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new M(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new M(1,0,0)}static Left(){return new M(-1,0,0)}static Random(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new M((0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o))}static RandomToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).We((0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o))}static TransformCoordinates(w,o){const H=M.Zero();return M.TransformCoordinatesToRef(w,o,H),H}static TransformCoordinatesToRef(w,o,H){return M.TransformCoordinatesFromFloatsToRef(w._x,w._y,w._z,o,H),H}static TransformCoordinatesFromFloatsToRef(w,o,H,h,E){const e=h.m,D=w*e[0]+o*e[4]+H*e[8]+e[12],t=w*e[1]+o*e[5]+H*e[9]+e[13],X=w*e[2]+o*e[6]+H*e[10]+e[14],L=1/(w*e[3]+o*e[7]+H*e[11]+e[15]);return E._x=D*L,E._y=t*L,E._z=X*L,E._isDirty=!0,E}static TransformNormal(w,o){const H=M.Zero();return M.TransformNormalToRef(w,o,H),H}static TransformNormalToRef(w,o,H){return this.TransformNormalFromFloatsToRef(w._x,w._y,w._z,o,H),H}static TransformNormalFromFloatsToRef(w,o,H,h,E){const e=h.m;return E._x=w*e[0]+o*e[4]+H*e[8],E._y=w*e[1]+o*e[5]+H*e[9],E._z=w*e[2]+o*e[6]+H*e[10],E._isDirty=!0,E}static CatmullRom(w,o,H,h,E){const e=E*E,D=E*e,t=.5*(2*o._x+(-w._x+H._x)*E+(2*w._x-5*o._x+4*H._x-h._x)*e+(-w._x+3*o._x-3*H._x+h._x)*D),X=.5*(2*o._y+(-w._y+H._y)*E+(2*w._y-5*o._y+4*H._y-h._y)*e+(-w._y+3*o._y-3*H._y+h._y)*D),L=.5*(2*o._z+(-w._z+H._z)*E+(2*w._z-5*o._z+4*H._z-h._z)*e+(-w._z+3*o._z-3*H._z+h._z)*D);return new M(t,X,L)}static Clamp(w,o,H){const h=new M;return M.ClampToRef(w,o,H,h),h}static ClampToRef(w,o,H,h){let E=w._x;E=E>H._x?H._x:E,E=E<o._x?o._x:E;let e=w._y;e=e>H._y?H._y:e,e=e<o._y?o._y:e;let D=w._z;return D=D>H._z?H._z:D,D=D<o._z?o._z:D,h.We(E,e,D),h}static CheckExtends(w,o,H){o.minimizeInPlace(w),H.maximizeInPlace(w)}static Hermite(w,o,H,h,E){const e=E*E,D=E*e,t=2*D-3*e+1,X=-2*D+3*e,L=D-2*e+E,A=D-e,y=w._x*t+H._x*X+o._x*L+h._x*A,z=w._y*t+H._y*X+o._y*L+h._y*A,C=w._z*t+H._z*X+o._z*L+h._z*A;return new M(y,z,C)}static Hermite1stDerivative(w,o,H,h,E){const e=new M;return this.Hermite1stDerivativeToRef(w,o,H,h,E,e),e}static Hermite1stDerivativeToRef(w,o,H,h,E,e){const D=E*E;return e._x=6*(D-E)*w._x+(3*D-4*E+1)*o._x+6*(-D+E)*H._x+(3*D-2*E)*h._x,e._y=6*(D-E)*w._y+(3*D-4*E+1)*o._y+6*(-D+E)*H._y+(3*D-2*E)*h._y,e._z=6*(D-E)*w._z+(3*D-4*E+1)*o._z+6*(-D+E)*H._z+(3*D-2*E)*h._z,e._isDirty=!0,e}static Lerp(w,o,H){const h=new M(0,0,0);return M.LerpToRef(w,o,H,h),h}static LerpToRef(w,o,H,h){return h._x=w._x+(o._x-w._x)*H,h._y=w._y+(o._y-w._y)*H,h._z=w._z+(o._z-w._z)*H,h._isDirty=!0,h}static Dot(w,o){return w._x*o._x+w._y*o._y+w._z*o._z}dot(w){return this._x*w._x+this._y*w._y+this._z*w._z}static Cross(w,o){const H=new M;return M.CrossToRef(w,o,H),H}static CrossToRef(w,o,H){const h=w._y*o._z-w._z*o._y,E=w._z*o._x-w._x*o._z,e=w._x*o._y-w._y*o._x;return H.We(h,E,e),H}static Normalize(w){const o=M.Zero();return M.NormalizeToRef(w,o),o}static NormalizeToRef(w,o){return w.normalizeToRef(o),o}static Project(w,o,H,h){const E=new M;return M.ProjectToRef(w,o,H,h,E),E}static ProjectToRef(w,o,H,h,E){var e;const D=h.width,X=h.height,L=h.x,A=h.y,y=r.Matrix[1],z=null===(e=t.e.LastCreatedEngine)||void 0===e?void 0:e.isNDCHalfZRange,C=z?1:.5,Q=z?0:.5;V.FromValuesToRef(D/2,0,0,0,0,-X/2,0,0,0,0,C,0,L+D/2,X/2+A,Q,1,y);const i=r.Matrix[0];return o.multiplyToRef(H,i),i.multiplyToRef(y,i),M.TransformCoordinatesToRef(w,i,E),E}static Reflect(w,o){return this.ReflectToRef(w,o,new M)}static ReflectToRef(w,o,H){const h=k.io[0];return h.t(o).scaleInPlace(2*M.Dot(w,o)),H.t(w).wy(h)}static _UnprojectFromInvertedMatrixToRef(w,o,H){M.TransformCoordinatesToRef(w,o,H);const h=o.m,E=w._x*h[3]+w._y*h[7]+w._z*h[11]+h[15];return(0,X.WithinEpsilon)(E,1)&&H.scaleInPlace(1/E),H}static UnprojectFromTransform(w,o,H,h,E){return this.Unproject(w,o,H,h,E,V.IdentityReadOnly)}static Unproject(w,o,H,h,E,e){const D=new M;return M.UnprojectToRef(w,o,H,h,E,e,D),D}static UnprojectToRef(w,o,H,h,E,e,D){return M.UnprojectFloatsToRef(w._x,w._y,w._z,o,H,h,E,e,D),D}static UnprojectFloatsToRef(w,o,H,h,E,e,D,X,L){var A;const y=r.Matrix[0];e.multiplyToRef(D,y),y.multiplyToRef(X,y),y.invert();const z=r.io[0];return z.x=w/h*2-1,z.y=-(o/E*2-1),null!==(A=t.e.LastCreatedEngine)&&void 0!==A&&A.isNDCHalfZRange?z.z=H:z.z=2*H-1,M._UnprojectFromInvertedMatrixToRef(z,y,L),L}static Minimize(w,o){const H=new M;return H.t(w),H.minimizeInPlace(o),H}static Maximize(w,o){const H=new M;return H.t(w),H.maximizeInPlace(o),H}static Distance(w,o){return Math.sqrt(M.DistanceSquared(w,o))}static DistanceSquared(w,o){const H=w._x-o._x,h=w._y-o._y,E=w._z-o._z;return H*H+h*h+E*E}static ProjectOnTriangleToRef(w,o,H,E,e){const D=r.io[0],t=r.io[1],L=r.io[2],A=r.io[3],y=r.io[4];H.subtractToRef(o,D),E.subtractToRef(o,t),E.subtractToRef(H,L);const z=D.length(),C=t.length(),Q=L.length();if(z<h.c||C<h.c||Q<h.c)return e.t(o),M.Distance(w,o);w.subtractToRef(o,y),M.CrossToRef(D,t,A);const i=A.length();if(i<h.c)return e.t(o),M.Distance(w,o);A.normalizeFromLength(i);let s=y.length();if(s<h.c)return e.t(o),0;y.normalizeFromLength(s);const V=M.Dot(A,y),k=r.io[5],P=r.io[6];k.t(A).scaleInPlace(-s*V),P.t(w).addInPlace(k);const l=r.io[4],O=r.io[5],T=r.io[7],S=r.io[8];l.t(D).scaleInPlace(1/z),S.t(t).scaleInPlace(1/C),l.addInPlace(S).scaleInPlace(-1),O.t(D).scaleInPlace(-1/z),S.t(L).scaleInPlace(1/Q),O.addInPlace(S).scaleInPlace(-1),T.t(L).scaleInPlace(-1/Q),S.t(t).scaleInPlace(-1/C),T.addInPlace(S).scaleInPlace(-1);const c=r.io[9];let W;c.t(P).wy(o),M.CrossToRef(l,c,S),W=M.Dot(S,A);const B=W;c.t(P).wy(H),M.CrossToRef(O,c,S),W=M.Dot(S,A);const J=W;c.t(P).wy(E),M.CrossToRef(T,c,S),W=M.Dot(S,A);const g=W,b=r.io[10];let p,f;B>0&&J<0?(b.t(D),p=o,f=H):J>0&&g<0?(b.t(L),p=H,f=E):(b.t(t).scaleInPlace(-1),p=E,f=o);const N=r.io[9],j=r.io[4];p.subtractToRef(P,S),f.subtractToRef(P,N),M.CrossToRef(S,N,j);if(!(M.Dot(j,A)<0))return e.t(P),Math.abs(s*V);const q=r.io[5];M.CrossToRef(b,j,q),q.normalize();const u=r.io[9];u.t(p).wy(P);const n=u.length();if(n<h.c)return e.t(p),M.Distance(w,p);u.normalizeFromLength(n);const G=M.Dot(q,u),R=r.io[7];R.t(P).addInPlace(q.scaleInPlace(n*G)),S.t(R).wy(p),s=b.length(),b.normalizeFromLength(s);let a=M.Dot(S,b)/Math.max(s,h.c);return a=(0,X.Clamp)(a,0,1),R.t(p).addInPlace(b.scaleInPlace(a*s)),e.t(R),M.Distance(w,R)}static Center(w,o){return M.CenterToRef(w,o,M.Zero())}static CenterToRef(w,o,H){return H.We((w._x+o._x)/2,(w._y+o._y)/2,(w._z+o._z)/2)}static RotationFromAxis(w,o,H){const h=new M;return M.RotationFromAxisToRef(w,o,H,h),h}static RotationFromAxisToRef(w,o,H,h){const E=r.Quaternion[0];return s.RotationQuaternionFromAxisToRef(w,o,H,E),E.toEulerAnglesToRef(h),h}}M._V8PerformanceHack=new M(.5,.5,.5),M._UpReadOnly=M.Up(),M._DownReadOnly=M.Down(),M._LeftHandedForwardReadOnly=M.Forward(!1),M._RightHandedForwardReadOnly=M.Forward(!0),M._LeftHandedBackwardReadOnly=M.Backward(!1),M._RightHandedBackwardReadOnly=M.Backward(!0),M._RightReadOnly=M.Right(),M._LeftReadOnly=M.Left(),M._ZeroReadOnly=M.Zero(),M._OneReadOnly=M.One(),Object.defineProperties(M.prototype,{dimension:{value:[3]},rank:{value:1}});class i{get x(){return this._x}set x(w){this._x=w,this._isDirty=!0}get y(){return this._y}set y(w){this._y=w,this._isDirty=!0}get z(){return this._z}set z(w){this._z=w,this._isDirty=!0}get w(){return this._w}set w(w){this._w=w,this._isDirty=!0}constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=w,this._y=o,this._z=H,this._w=h}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let w=C(this._x);return w=397*w^C(this._y),w=397*w^C(this._z),w=397*w^C(this._w),w}Ae(){return[this._x,this._y,this._z,this._w]}toArray(w,o){return void 0===o&&(o=0),w[o]=this._x,w[o+1]=this._y,w[o+2]=this._z,w[o+3]=this._w,this}iH(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return i.FromArrayToRef(w,o,this),this}addInPlace(w){return this.x+=w._x,this.y+=w._y,this.z+=w._z,this.w+=w._w,this}addInPlaceFromFloats(w,o,H,h){return this.x+=w,this.y+=o,this.z+=H,this.w+=h,this}add(w){return new i(this._x+w.x,this._y+w.y,this._z+w.z,this._w+w.w)}addToRef(w,o){return o.x=this._x+w.x,o.y=this._y+w.y,o.z=this._z+w.z,o.w=this._w+w.w,o}wy(w){return this.x-=w.x,this.y-=w.y,this.z-=w.z,this.w-=w.w,this}so(w){return new i(this._x-w.x,this._y-w.y,this._z-w.z,this._w-w.w)}subtractToRef(w,o){return o.x=this._x-w.x,o.y=this._y-w.y,o.z=this._z-w.z,o.w=this._w-w.w,o}subtractFromFloats(w,o,H,h){return new i(this._x-w,this._y-o,this._z-H,this._w-h)}subtractFromFloatsToRef(w,o,H,h,E){return E.x=this._x-w,E.y=this._y-o,E.z=this._z-H,E.w=this._w-h,E}negate(){return new i(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(w){return w.x=-this._x,w.y=-this._y,w.z=-this._z,w.w=-this._w,w}scaleInPlace(w){return this.x*=w,this.y*=w,this.z*=w,this.w*=w,this}scale(w){return new i(this._x*w,this._y*w,this._z*w,this._w*w)}scaleToRef(w,o){return o.x=this._x*w,o.y=this._y*w,o.z=this._z*w,o.w=this._w*w,o}scaleAndAddToRef(w,o){return o.x+=this._x*w,o.y+=this._y*w,o.z+=this._z*w,o.w+=this._w*w,o}equals(w){return w&&this._x===w.x&&this._y===w.y&&this._z===w.z&&this._w===w.w}equalsWithEpsilon(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.c;return w&&(0,X.WithinEpsilon)(this._x,w.x,o)&&(0,X.WithinEpsilon)(this._y,w.y,o)&&(0,X.WithinEpsilon)(this._z,w.z,o)&&(0,X.WithinEpsilon)(this._w,w.w,o)}equalsToFloats(w,o,H,h){return this._x===w&&this._y===o&&this._z===H&&this._w===h}multiplyInPlace(w){return this.x*=w.x,this.y*=w.y,this.z*=w.z,this.w*=w.w,this}multiply(w){return new i(this._x*w.x,this._y*w.y,this._z*w.z,this._w*w.w)}multiplyToRef(w,o){return o.x=this._x*w.x,o.y=this._y*w.y,o.z=this._z*w.z,o.w=this._w*w.w,o}multiplyByFloats(w,o,H,h){return new i(this._x*w,this._y*o,this._z*H,this._w*h)}divide(w){return new i(this._x/w.x,this._y/w.y,this._z/w.z,this._w/w.w)}divideToRef(w,o){return o.x=this._x/w.x,o.y=this._y/w.y,o.z=this._z/w.z,o.w=this._w/w.w,o}divideInPlace(w){return this.divideToRef(w,this)}minimizeInPlace(w){return w.x<this._x&&(this.x=w.x),w.y<this._y&&(this.y=w.y),w.z<this._z&&(this.z=w.z),w.w<this._w&&(this.w=w.w),this}maximizeInPlace(w){return w.x>this._x&&(this.x=w.x),w.y>this._y&&(this.y=w.y),w.z>this._z&&(this.z=w.z),w.w>this._w&&(this.w=w.w),this}minimizeInPlaceFromFloats(w,o,H,h){return this.x=Math.min(w,this._x),this.y=Math.min(o,this._y),this.z=Math.min(H,this._z),this.w=Math.min(h,this._w),this}maximizeInPlaceFromFloats(w,o,H,h){return this.x=Math.max(w,this._x),this.y=Math.max(o,this._y),this.z=Math.max(H,this._z),this.w=Math.max(h,this._w),this}floorToRef(w){return w.x=Math.floor(this._x),w.y=Math.floor(this._y),w.z=Math.floor(this._z),w.w=Math.floor(this._w),w}floor(){return new i(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(w){return w.x=this._x-Math.floor(this._x),w.y=this._y-Math.floor(this._y),w.z=this._z-Math.floor(this._z),w.w=this._w-Math.floor(this._w),w}fract(){return new i(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(w){return 0===w||1===w?this:this.scaleInPlace(1/w)}normalizeToNew(){return this.normalizeToRef(new i)}normalizeToRef(w){const o=this.length();return 0===o||1===o?(w.x=this._x,w.y=this._y,w.z=this._z,w.w=this._w,w):this.scaleToRef(1/o,w)}toVector3(){return new M(this._x,this._y,this._z)}clone(){return new i(this._x,this._y,this._z,this._w)}t(w){return this.x=w.x,this.y=w.y,this.z=w.z,this.w=w.w,this}We(w,o,H,h){return this.x=w,this.y=o,this.z=H,this.w=h,this}set(w,o,H,h){return this.We(w,o,H,h)}Ge(w){return this.x=this.y=this.z=this.w=w,this}dot(w){return this._x*w.x+this._y*w.y+this._z*w.z+this._w*w.w}static Po(w,o){return o||(o=0),new i(w[o],w[o+1],w[o+2],w[o+3])}static FromArrayToRef(w,o,H){return H.x=w[o],H.y=w[o+1],H.z=w[o+2],H.w=w[o+3],H}static FromFloatArrayToRef(w,o,H){return i.FromArrayToRef(w,o,H),H}static FromFloatsToRef(w,o,H,h,E){return E.x=w,E.y=o,E.z=H,E.w=h,E}static Zero(){return new i(0,0,0,0)}static One(){return new i(1,1,1,1)}static Random(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new i((0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o))}static RandomToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0;return H.x=(0,X.RandomRange)(w,o),H.y=(0,X.RandomRange)(w,o),H.z=(0,X.RandomRange)(w,o),H.w=(0,X.RandomRange)(w,o),H}static Clamp(w,o,H){return i.ClampToRef(w,o,H,new i)}static ClampToRef(w,o,H,h){return h.x=(0,X.Clamp)(w.x,o.x,H.x),h.y=(0,X.Clamp)(w.y,o.y,H.y),h.z=(0,X.Clamp)(w.z,o.z,H.z),h.w=(0,X.Clamp)(w.w,o.w,H.w),h}static CheckExtends(w,o,H){o.minimizeInPlace(w),H.maximizeInPlace(w)}static get ZeroReadOnly(){return i._ZeroReadOnly}static Normalize(w){return i.NormalizeToRef(w,new i)}static NormalizeToRef(w,o){return w.normalizeToRef(o),o}static Minimize(w,o){const H=new i;return H.t(w),H.minimizeInPlace(o),H}static Maximize(w,o){const H=new i;return H.t(w),H.maximizeInPlace(o),H}static Distance(w,o){return Math.sqrt(i.DistanceSquared(w,o))}static DistanceSquared(w,o){const H=w.x-o.x,h=w.y-o.y,E=w.z-o.z,e=w.w-o.w;return H*H+h*h+E*E+e*e}static Center(w,o){return i.CenterToRef(w,o,new i)}static CenterToRef(w,o,H){return H.x=(w.x+o.x)/2,H.y=(w.y+o.y)/2,H.z=(w.z+o.z)/2,H.w=(w.w+o.w)/2,H}static TransformCoordinates(w,o){return i.TransformCoordinatesToRef(w,o,new i)}static TransformCoordinatesToRef(w,o,H){return i.TransformCoordinatesFromFloatsToRef(w._x,w._y,w._z,o,H),H}static TransformCoordinatesFromFloatsToRef(w,o,H,h,E){const e=h.m,D=w*e[0]+o*e[4]+H*e[8]+e[12],t=w*e[1]+o*e[5]+H*e[9]+e[13],X=w*e[2]+o*e[6]+H*e[10]+e[14],L=w*e[3]+o*e[7]+H*e[11]+e[15];return E.x=D,E.y=t,E.z=X,E.w=L,E}static TransformNormal(w,o){return i.TransformNormalToRef(w,o,new i)}static TransformNormalToRef(w,o,H){const h=o.m,E=w.x*h[0]+w.y*h[4]+w.z*h[8],e=w.x*h[1]+w.y*h[5]+w.z*h[9],D=w.x*h[2]+w.y*h[6]+w.z*h[10];return H.x=E,H.y=e,H.z=D,H.w=w.w,H}static TransformNormalFromFloatsToRef(w,o,H,h,E,e){const D=E.m;return e.x=w*D[0]+o*D[4]+H*D[8],e.y=w*D[1]+o*D[5]+H*D[9],e.z=w*D[2]+o*D[6]+H*D[10],e.w=h,e}static FromVector3(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new i(w._x,w._y,w._z,o)}static Dot(w,o){return w.x*o.x+w.y*o.y+w.z*o.z+w.w*o.w}}i._V8PerformanceHack=new i(.5,.5,.5,.5),i._ZeroReadOnly=i.Zero(),Object.defineProperties(i.prototype,{dimension:{value:[4]},rank:{value:1}});class s{get x(){return this._x}set x(w){this._x=w,this._isDirty=!0}get y(){return this._y}set y(w){this._y=w,this._isDirty=!0}get z(){return this._z}set z(w){this._z=w,this._isDirty=!0}get w(){return this._w}set w(w){this._w=w,this._isDirty=!0}constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=w,this._y=o,this._z=H,this._w=h}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let w=C(this._x);return w=397*w^C(this._y),w=397*w^C(this._z),w=397*w^C(this._w),w}Ae(){return[this._x,this._y,this._z,this._w]}toArray(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w[o]=this._x,w[o+1]=this._y,w[o+2]=this._z,w[o+3]=this._w,this}iH(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return s.FromArrayToRef(w,o,this)}equals(w){return w&&this._x===w._x&&this._y===w._y&&this._z===w._z&&this._w===w._w}equalsWithEpsilon(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.c;return w&&(0,X.WithinEpsilon)(this._x,w._x,o)&&(0,X.WithinEpsilon)(this._y,w._y,o)&&(0,X.WithinEpsilon)(this._z,w._z,o)&&(0,X.WithinEpsilon)(this._w,w._w,o)}isApprox(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.c;return w&&((0,X.WithinEpsilon)(this._x,w._x,o)&&(0,X.WithinEpsilon)(this._y,w._y,o)&&(0,X.WithinEpsilon)(this._z,w._z,o)&&(0,X.WithinEpsilon)(this._w,w._w,o)||(0,X.WithinEpsilon)(this._x,-w._x,o)&&(0,X.WithinEpsilon)(this._y,-w._y,o)&&(0,X.WithinEpsilon)(this._z,-w._z,o)&&(0,X.WithinEpsilon)(this._w,-w._w,o))}clone(){return new s(this._x,this._y,this._z,this._w)}t(w){return this._x=w._x,this._y=w._y,this._z=w._z,this._w=w._w,this._isDirty=!0,this}We(w,o,H,h){return this._x=w,this._y=o,this._z=H,this._w=h,this._isDirty=!0,this}set(w,o,H,h){return this.We(w,o,H,h)}Ge(w){return this.We(w,w,w,w)}add(w){return new s(this._x+w._x,this._y+w._y,this._z+w._z,this._w+w._w)}addInPlace(w){return this._x+=w._x,this._y+=w._y,this._z+=w._z,this._w+=w._w,this._isDirty=!0,this}addToRef(w,o){return o._x=this._x+w._x,o._y=this._y+w._y,o._z=this._z+w._z,o._w=this._w+w._w,o._isDirty=!0,o}addInPlaceFromFloats(w,o,H,h){return this._x+=w,this._y+=o,this._z+=H,this._w+=h,this._isDirty=!0,this}subtractToRef(w,o){return o._x=this._x-w._x,o._y=this._y-w._y,o._z=this._z-w._z,o._w=this._w-w._w,o._isDirty=!0,o}subtractFromFloats(w,o,H,h){return this.subtractFromFloatsToRef(w,o,H,h,new s)}subtractFromFloatsToRef(w,o,H,h,E){return E._x=this._x-w,E._y=this._y-o,E._z=this._z-H,E._w=this._w-h,E._isDirty=!0,E}so(w){return new s(this._x-w._x,this._y-w._y,this._z-w._z,this._w-w._w)}wy(w){return this._x-=w._x,this._y-=w._y,this._z-=w._z,this._w-=w._w,this._isDirty=!0,this}scale(w){return new s(this._x*w,this._y*w,this._z*w,this._w*w)}scaleToRef(w,o){return o._x=this._x*w,o._y=this._y*w,o._z=this._z*w,o._w=this._w*w,o._isDirty=!0,o}scaleInPlace(w){return this._x*=w,this._y*=w,this._z*=w,this._w*=w,this._isDirty=!0,this}scaleAndAddToRef(w,o){return o._x+=this._x*w,o._y+=this._y*w,o._z+=this._z*w,o._w+=this._w*w,o._isDirty=!0,o}multiply(w){const o=new s(0,0,0,1);return this.multiplyToRef(w,o),o}multiplyToRef(w,o){const H=this._x*w._w+this._y*w._z-this._z*w._y+this._w*w._x,h=-this._x*w._z+this._y*w._w+this._z*w._x+this._w*w._y,E=this._x*w._y-this._y*w._x+this._z*w._w+this._w*w._z,e=-this._x*w._x-this._y*w._y-this._z*w._z+this._w*w._w;return o.We(H,h,E,e),o}multiplyInPlace(w){return this.multiplyToRef(w,this)}multiplyByFloats(w,o,H,h){return this._x*=w,this._y*=o,this._z*=H,this._w*=h,this._isDirty=!0,this}divide(w){throw new ReferenceError("Can not divide a quaternion")}divideToRef(w,o){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(w){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new s)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(w){return w._x=-this._x,w._y=-this._y,w._z=-this._z,w._w=-this._w,w._isDirty=!0,w}equalsToFloats(w,o,H,h){return this._x===w&&this._y===o&&this._z===H&&this._w===h}floorToRef(w){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(w){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(w){return w.We(-this._x,-this._y,-this._z,this._w),w}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new s(-this._x,-this._y,-this._z,this._w)}invert(){const w=this.conjugate(),o=this.lengthSquared();return 0==o||1==o||w.scaleInPlace(1/o),w}invertInPlace(){this.conjugateInPlace();const w=this.lengthSquared();return 0==w||1==w||this.scaleInPlace(1/w),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(w){return 0===w||1===w?this:this.scaleInPlace(1/w)}normalizeToNew(){const w=new s(0,0,0,1);return this.normalizeToRef(w),w}normalizeToRef(w){const o=this.length();return 0===o||1===o?w.We(this._x,this._y,this._z,this._w):this.scaleToRef(1/o,w)}toEulerAngles(){const w=M.Zero();return this.toEulerAnglesToRef(w),w}toEulerAnglesToRef(w){const o=this._z,H=this._x,h=this._y,E=this._w,e=h*o-H*E,D=.4999999;if(e<-D)w._y=2*Math.atan2(h,E),w._x=Math.PI/2,w._z=0,w._isDirty=!0;else if(e>D)w._y=2*Math.atan2(h,E),w._x=-Math.PI/2,w._z=0,w._isDirty=!0;else{const D=E*E,t=o*o,X=H*H,L=h*h;w._z=Math.atan2(2*(H*h+o*E),-t-X+L+D),w._x=Math.asin(-2*e),w._y=Math.atan2(2*(o*H+h*E),t-X-L+D),w._isDirty=!0}return w}toAlphaBetaGammaToRef(w){const o=this._z,H=this._x,h=this._y,E=this._w,e=Math.sqrt(H*H+h*h),D=Math.sqrt(o*o+E*E),t=2*Math.atan2(e,D),X=2*Math.atan2(o,E),L=2*Math.atan2(h,H),A=(X+L)/2,y=(X-L)/2;return w.set(y,t,A),w}toRotationMatrix(w){return V.FromQuaternionToRef(this,w),w}fromRotationMatrix(w){return s.FromRotationMatrixToRef(w,this),this}dot(w){return this._x*w._x+this._y*w._y+this._z*w._z+this._w*w._w}toAxisAngle(){const w=M.Zero();return{axis:w,angle:this.toAxisAngleToRef(w)}}toAxisAngleToRef(w){let o=0;const H=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),h=this._w;return H>0?(o=2*Math.atan2(H,h),w.set(this._x/H,this._y/H,this._z/H)):(o=0,w.set(1,0,0)),o}static FromRotationMatrix(w){const o=new s;return s.FromRotationMatrixToRef(w,o),o}static FromRotationMatrixToRef(w,o){const H=w.m,h=H[0],E=H[4],e=H[8],D=H[1],t=H[5],X=H[9],L=H[2],A=H[6],y=H[10],z=h+t+y;let C;return z>0?(C=.5/Math.sqrt(z+1),o._w=.25/C,o._x=(A-X)*C,o._y=(e-L)*C,o._z=(D-E)*C,o._isDirty=!0):h>t&&h>y?(C=2*Math.sqrt(1+h-t-y),o._w=(A-X)/C,o._x=.25*C,o._y=(E+D)/C,o._z=(e+L)/C,o._isDirty=!0):t>y?(C=2*Math.sqrt(1+t-h-y),o._w=(e-L)/C,o._x=(E+D)/C,o._y=.25*C,o._z=(X+A)/C,o._isDirty=!0):(C=2*Math.sqrt(1+y-h-t),o._w=(D-E)/C,o._x=(e+L)/C,o._y=(X+A)/C,o._z=.25*C,o._isDirty=!0),o}static Dot(w,o){return w._x*o._x+w._y*o._y+w._z*o._z+w._w*o._w}static AreClose(w,o){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const h=s.Dot(w,o);return 1-h*h<=H}static SmoothToRef(w,o,H,h,E){let e=0===h?1:H/h;return e=(0,X.Clamp)(e,0,1),s.SlerpToRef(w,o,e,E),E}static Zero(){return new s(0,0,0,0)}static Inverse(w){return new s(-w._x,-w._y,-w._z,w._w)}static InverseToRef(w,o){return o.set(-w._x,-w._y,-w._z,w._w),o}static Identity(){return new s(0,0,0,1)}static IsIdentity(w){return w&&0===w._x&&0===w._y&&0===w._z&&1===w._w}static RotationAxis(w,o){return s.RotationAxisToRef(w,o,new s)}static RotationAxisToRef(w,o,H){H._w=Math.cos(o/2);const h=Math.sin(o/2)/w.length();return H._x=w._x*h,H._y=w._y*h,H._z=w._z*h,H._isDirty=!0,H}static Po(w,o){return o||(o=0),new s(w[o],w[o+1],w[o+2],w[o+3])}static FromArrayToRef(w,o,H){return H._x=w[o],H._y=w[o+1],H._z=w[o+2],H._w=w[o+3],H._isDirty=!0,H}static FromFloatsToRef(w,o,H,h,E){return E.We(w,o,H,h),E}static FromEulerAngles(w,o,H){const h=new s;return s.RotationYawPitchRollToRef(o,w,H,h),h}static FromEulerAnglesToRef(w,o,H,h){return s.RotationYawPitchRollToRef(o,w,H,h),h}static FromEulerVector(w){const o=new s;return s.RotationYawPitchRollToRef(w._y,w._x,w._z,o),o}static FromEulerVectorToRef(w,o){return s.RotationYawPitchRollToRef(w._y,w._x,w._z,o),o}static FromUnitVectorsToRef(w,o,H){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:h.c;const e=M.Dot(w,o)+1;return e<E?Math.abs(w.x)>Math.abs(w.z)?H.set(-w.y,w.x,0,0):H.set(0,-w.z,w.y,0):(M.CrossToRef(w,o,k.io[0]),H.set(k.io[0].x,k.io[0].y,k.io[0].z,e)),H.normalize()}static RotationYawPitchRoll(w,o,H){const h=new s;return s.RotationYawPitchRollToRef(w,o,H,h),h}static RotationYawPitchRollToRef(w,o,H,h){const E=.5*H,e=.5*o,D=.5*w,t=Math.sin(E),X=Math.cos(E),L=Math.sin(e),A=Math.cos(e),y=Math.sin(D),z=Math.cos(D);return h._x=z*L*X+y*A*t,h._y=y*A*X-z*L*t,h._z=z*A*t-y*L*X,h._w=z*A*X+y*L*t,h._isDirty=!0,h}static RotationAlphaBetaGamma(w,o,H){const h=new s;return s.RotationAlphaBetaGammaToRef(w,o,H,h),h}static RotationAlphaBetaGammaToRef(w,o,H,h){const E=.5*(H+w),e=.5*(H-w),D=.5*o;return h._x=Math.cos(e)*Math.sin(D),h._y=Math.sin(e)*Math.sin(D),h._z=Math.sin(E)*Math.cos(D),h._w=Math.cos(E)*Math.cos(D),h._isDirty=!0,h}static RotationQuaternionFromAxis(w,o,H){const h=new s(0,0,0,0);return s.RotationQuaternionFromAxisToRef(w,o,H,h),h}static RotationQuaternionFromAxisToRef(w,o,H,h){const E=r.Matrix[0];return w=w.normalizeToRef(r.io[0]),o=o.normalizeToRef(r.io[1]),H=H.normalizeToRef(r.io[2]),V.FromXYZAxesToRef(w,o,H,E),s.FromRotationMatrixToRef(E,h),h}static FromLookDirectionLH(w,o){const H=new s;return s.FromLookDirectionLHToRef(w,o,H),H}static FromLookDirectionLHToRef(w,o,H){const h=r.Matrix[0];return V.LookDirectionLHToRef(w,o,h),s.FromRotationMatrixToRef(h,H),H}static FromLookDirectionRH(w,o){const H=new s;return s.FromLookDirectionRHToRef(w,o,H),H}static FromLookDirectionRHToRef(w,o,H){const h=r.Matrix[0];return V.LookDirectionRHToRef(w,o,h),s.FromRotationMatrixToRef(h,H)}static Slerp(w,o,H){const h=s.Identity();return s.SlerpToRef(w,o,H,h),h}static SlerpToRef(w,o,H,h){let E,e,D=w._x*o._x+w._y*o._y+w._z*o._z+w._w*o._w,t=!1;if(D<0&&(t=!0,D=-D),D>.999999)e=1-H,E=t?-H:H;else{const w=Math.acos(D),o=1/Math.sin(w);e=Math.sin((1-H)*w)*o,E=t?-Math.sin(H*w)*o:Math.sin(H*w)*o}return h._x=e*w._x+E*o._x,h._y=e*w._y+E*o._y,h._z=e*w._z+E*o._z,h._w=e*w._w+E*o._w,h._isDirty=!0,h}static Hermite(w,o,H,h,E){const e=E*E,D=E*e,t=2*D-3*e+1,X=-2*D+3*e,L=D-2*e+E,A=D-e,y=w._x*t+H._x*X+o._x*L+h._x*A,z=w._y*t+H._y*X+o._y*L+h._y*A,C=w._z*t+H._z*X+o._z*L+h._z*A,Q=w._w*t+H._w*X+o._w*L+h._w*A;return new s(y,z,C,Q)}static Hermite1stDerivative(w,o,H,h,E){const e=new s;return this.Hermite1stDerivativeToRef(w,o,H,h,E,e),e}static Hermite1stDerivativeToRef(w,o,H,h,E,e){const D=E*E;return e._x=6*(D-E)*w._x+(3*D-4*E+1)*o._x+6*(-D+E)*H._x+(3*D-2*E)*h._x,e._y=6*(D-E)*w._y+(3*D-4*E+1)*o._y+6*(-D+E)*H._y+(3*D-2*E)*h._y,e._z=6*(D-E)*w._z+(3*D-4*E+1)*o._z+6*(-D+E)*H._z+(3*D-2*E)*h._z,e._w=6*(D-E)*w._w+(3*D-4*E+1)*o._w+6*(-D+E)*H._w+(3*D-2*E)*h._w,e._isDirty=!0,e}static Normalize(w){const o=s.Zero();return s.NormalizeToRef(w,o),o}static NormalizeToRef(w,o){return w.normalizeToRef(o),o}static Clamp(w,o,H){const h=new s;return s.ClampToRef(w,o,H,h),h}static ClampToRef(w,o,H,h){return h.We((0,X.Clamp)(w.x,o.x,H.x),(0,X.Clamp)(w.y,o.y,H.y),(0,X.Clamp)(w.z,o.z,H.z),(0,X.Clamp)(w.w,o.w,H.w))}static Random(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new s((0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o))}static RandomToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).We((0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o),(0,X.RandomRange)(w,o))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(w,o){return Math.sqrt(s.DistanceSquared(w,o))}static DistanceSquared(w,o){const H=w.x-o.x,h=w.y-o.y,E=w.z-o.z,e=w.w-o.w;return H*H+h*h+E*E+e*e}static Center(w,o){return s.CenterToRef(w,o,s.Zero())}static CenterToRef(w,o,H){return H.We((w.x+o.x)/2,(w.y+o.y)/2,(w.z+o.z)/2,(w.w+o.w)/2)}}s._V8PerformanceHack=new s(.5,.5,.5,.5),Object.defineProperties(s.prototype,{dimension:{value:[4]},rank:{value:1}});class V{static get Use64Bits(){return D.d.MatrixUse64Bits}get m(){return this.we}markAsUpdated(){this.updateFlag=L._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(w){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2],h=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=w,this._isIdentity3x2=w||H,this._isIdentityDirty=!this._isIdentity&&o,this._isIdentity3x2Dirty=!this._isIdentity3x2&&h}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,D.d.MatrixTrackPrecisionChange&&D.d.MatrixTrackedMatrices.push(this),this.we=new D.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const w=this.we;this._isIdentity=1===w[0]&&0===w[1]&&0===w[2]&&0===w[3]&&0===w[4]&&1===w[5]&&0===w[6]&&0===w[7]&&0===w[8]&&0===w[9]&&1===w[10]&&0===w[11]&&0===w[12]&&0===w[13]&&0===w[14]&&1===w[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.we[0]||1!==this.we[5]||1!==this.we[15]||0!==this.we[1]||0!==this.we[2]||0!==this.we[3]||0!==this.we[4]||0!==this.we[6]||0!==this.we[7]||0!==this.we[8]||0!==this.we[9]||0!==this.we[10]||0!==this.we[11]||0!==this.we[12]||0!==this.we[13]||0!==this.we[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const w=this.we,o=w[0],H=w[1],h=w[2],E=w[3],e=w[4],D=w[5],t=w[6],X=w[7],L=w[8],A=w[9],y=w[10],z=w[11],C=w[12],Q=w[13],M=w[14],i=w[15],s=y*i-M*z,V=A*i-Q*z,r=A*M-Q*y,k=L*i-C*z,P=L*M-y*C,l=L*Q-C*A;return o*+(D*s-t*V+X*r)+H*-(e*s-t*k+X*P)+h*+(e*V-D*k+X*l)+E*-(e*r-D*P+t*l)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!w)return this.we;const H=this.we;for(let h=0;h<16;h++)w[o+h]=H[h];return this}Ae(){return this.we}iH(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V.FromArrayToRef(w,o,this)}We(){for(var w=arguments.length,o=new Array(w),H=0;H<w;H++)o[H]=arguments[H];return V.FromArrayToRef(o,0,this)}set(){const w=this.we;for(let o=0;o<16;o++)w[o]=o<0||arguments.length<=o?void 0:arguments[o];return this.markAsUpdated(),this}Ge(w){const o=this.we;for(let H=0;H<16;H++)o[H]=w;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return V.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(w){const o=new V;return this.addToRef(w,o),o}addToRef(w,o){const H=this.we,h=o.we,E=w.m;for(let e=0;e<16;e++)h[e]=H[e]+E[e];return o.markAsUpdated(),o}addToSelf(w){const o=this.we,H=w.m;return o[0]+=H[0],o[1]+=H[1],o[2]+=H[2],o[3]+=H[3],o[4]+=H[4],o[5]+=H[5],o[6]+=H[6],o[7]+=H[7],o[8]+=H[8],o[9]+=H[9],o[10]+=H[10],o[11]+=H[11],o[12]+=H[12],o[13]+=H[13],o[14]+=H[14],o[15]+=H[15],this.markAsUpdated(),this}addInPlace(w){const o=this.we,H=w.m;for(let h=0;h<16;h++)o[h]+=H[h];return this.markAsUpdated(),this}addInPlaceFromFloats(){const w=this.we;for(let o=0;o<16;o++)w[o]+=o<0||arguments.length<=o?void 0:arguments[o];return this.markAsUpdated(),this}so(w){const o=this.we,H=w.m;for(let h=0;h<16;h++)o[h]-=H[h];return this.markAsUpdated(),this}subtractToRef(w,o){const H=this.we,h=w.m,E=o.we;for(let e=0;e<16;e++)E[e]=H[e]-h[e];return o.markAsUpdated(),o}wy(w){const o=this.we,H=w.m;for(let h=0;h<16;h++)o[h]-=H[h];return this.markAsUpdated(),this}subtractFromFloats(){for(var w=arguments.length,o=new Array(w),H=0;H<w;H++)o[H]=arguments[H];return this.subtractFromFloatsToRef(...o,new V)}subtractFromFloatsToRef(){for(var w=arguments.length,o=new Array(w),H=0;H<w;H++)o[H]=arguments[H];const h=o.pop(),E=this.we,e=h.we,D=o;for(let t=0;t<16;t++)e[t]=E[t]-D[t];return h.markAsUpdated(),h}invertToRef(w){return!0===this._isIdentity?(V.IdentityToRef(w),w):(z(this,w.Ae())?w.markAsUpdated():w.t(this),w)}addAtIndex(w,o){return this.we[w]+=o,this.markAsUpdated(),this}multiplyAtIndex(w,o){return this.we[w]*=o,this.markAsUpdated(),this}setTranslationFromFloats(w,o,H){return this.we[12]=w,this.we[13]=o,this.we[14]=H,this.markAsUpdated(),this}addTranslationFromFloats(w,o,H){return this.we[12]+=w,this.we[13]+=o,this.we[14]+=H,this.markAsUpdated(),this}setTranslation(w){return this.setTranslationFromFloats(w._x,w._y,w._z)}getTranslation(){return new M(this.we[12],this.we[13],this.we[14])}getTranslationToRef(w){return w.x=this.we[12],w.y=this.we[13],w.z=this.we[14],w}removeRotationAndScaling(){const w=this.m;return V.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,w[12],w[13],w[14],w[15],this),this._updateIdentityStatus(0===w[12]&&0===w[13]&&0===w[14]&&1===w[15]),this}t(w){w.copyToArray(this.we);const o=w;return this.updateFlag=o.updateFlag,this._updateIdentityStatus(o._isIdentity,o._isIdentityDirty,o._isIdentity3x2,o._isIdentity3x2Dirty),this}copyToArray(w){return y(this,w,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(w){const o=new V;return this.multiplyToRef(w,o),o}multiplyInPlace(w){const o=this.we,H=w.m;for(let h=0;h<16;h++)o[h]*=H[h];return this.markAsUpdated(),this}multiplyByFloats(){const w=this.we;for(let o=0;o<16;o++)w[o]*=o<0||arguments.length<=o?void 0:arguments[o];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var w=arguments.length,o=new Array(w),H=0;H<w;H++)o[H]=arguments[H];const h=o.pop(),E=this.we,e=h.we,D=o;for(let t=0;t<16;t++)e[t]=E[t]*D[t];return h.markAsUpdated(),h}multiplyToRef(w,o){return this._isIdentity?(o.t(w),o):w._isIdentity?(o.t(this),o):(this.multiplyToArray(w,o.we,0),o.markAsUpdated(),o)}multiplyToArray(w,o,H){return A(this,w,o,H),this}divide(w){return this.divideToRef(w,new V)}divideToRef(w,o){const H=this.we,h=w.m,E=o.we;for(let e=0;e<16;e++)E[e]=H[e]/h[e];return o.markAsUpdated(),o}divideInPlace(w){const o=this.we,H=w.m;for(let h=0;h<16;h++)o[h]/=H[h];return this.markAsUpdated(),this}minimizeInPlace(w){const o=this.we,H=w.m;for(let h=0;h<16;h++)o[h]=Math.min(o[h],H[h]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const w=this.we;for(let o=0;o<16;o++)w[o]=Math.min(w[o],o<0||arguments.length<=o?void 0:arguments[o]);return this.markAsUpdated(),this}maximizeInPlace(w){const o=this.we,H=w.m;for(let h=0;h<16;h++)o[h]=Math.min(o[h],H[h]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const w=this.we;for(let o=0;o<16;o++)w[o]=Math.min(w[o],o<0||arguments.length<=o?void 0:arguments[o]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new V)}negateInPlace(){const w=this.we;for(let o=0;o<16;o++)w[o]=-w[o];return this.markAsUpdated(),this}negateToRef(w){const o=this.we,H=w.we;for(let h=0;h<16;h++)H[h]=-o[h];return w.markAsUpdated(),w}equals(w){const o=w;if(!o)return!1;if((this._isIdentity||o._isIdentity)&&!this._isIdentityDirty&&!o._isIdentityDirty)return this._isIdentity&&o._isIdentity;const H=this.m,h=o.m;return H[0]===h[0]&&H[1]===h[1]&&H[2]===h[2]&&H[3]===h[3]&&H[4]===h[4]&&H[5]===h[5]&&H[6]===h[6]&&H[7]===h[7]&&H[8]===h[8]&&H[9]===h[9]&&H[10]===h[10]&&H[11]===h[11]&&H[12]===h[12]&&H[13]===h[13]&&H[14]===h[14]&&H[15]===h[15]}equalsWithEpsilon(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const H=this.we,h=w.m;for(let E=0;E<16;E++)if(!(0,X.WithinEpsilon)(H[E],h[E],o))return!1;return!0}equalsToFloats(){const w=this.we;for(let o=0;o<16;o++)if(w[o]!=(o<0||arguments.length<=o?void 0:arguments[o]))return!1;return!0}floor(){return this.floorToRef(new V)}floorToRef(w){const o=this.we,H=w.we;for(let h=0;h<16;h++)H[h]=Math.floor(o[h]);return w.markAsUpdated(),w}fract(){return this.fractToRef(new V)}fractToRef(w){const o=this.we,H=w.we;for(let h=0;h<16;h++)H[h]=o[h]-Math.floor(o[h]);return w.markAsUpdated(),w}clone(){const w=new V;return w.t(this),w}getClassName(){return"Matrix"}getHashCode(){let w=C(this.we[0]);for(let o=1;o<16;o++)w=397*w^C(this.we[o]);return w}decomposeToTransformNode(w){return w.rotationQuaternion=w.rotationQuaternion||new s,this.decompose(w.Je,w.rotationQuaternion,w.position)}decompose(w,o,H,h){let E=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return H&&H.Ge(0),w&&w.Ge(1),o&&o.We(0,0,0,1),!0;const e=this.we;if(H&&H.We(e[12],e[13],e[14]),(w=w||r.io[0]).x=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),w.y=Math.sqrt(e[4]*e[4]+e[5]*e[5]+e[6]*e[6]),w.z=Math.sqrt(e[8]*e[8]+e[9]*e[9]+e[10]*e[10]),h){const o=(E?h.absoluteScaling.x:h.Je.x)<0?-1:1,H=(E?h.absoluteScaling.y:h.Je.y)<0?-1:1,e=(E?h.absoluteScaling.z:h.Je.z)<0?-1:1;w.x*=o,w.y*=H,w.z*=e}else this.determinant()<=0&&(w.y*=-1);if(0===w._x||0===w._y||0===w._z)return o&&o.We(0,0,0,1),!1;if(o){const H=1/w._x,h=1/w._y,E=1/w._z;V.FromValuesToRef(e[0]*H,e[1]*H,e[2]*H,0,e[4]*h,e[5]*h,e[6]*h,0,e[8]*E,e[9]*E,e[10]*E,0,0,0,0,1,r.Matrix[0]),s.FromRotationMatrixToRef(r.Matrix[0],o)}return!0}getRow(w){if(w<0||w>3)return null;const o=4*w;return new i(this.we[o+0],this.we[o+1],this.we[o+2],this.we[o+3])}getRowToRef(w,o){if(w>=0&&w<=3){const H=4*w;o.x=this.we[H+0],o.y=this.we[H+1],o.z=this.we[H+2],o.w=this.we[H+3]}return o}setRow(w,o){return this.setRowFromFloats(w,o.x,o.y,o.z,o.w)}transpose(){const w=new V;return V.TransposeToRef(this,w),w}transposeToRef(w){return V.TransposeToRef(this,w),w}setRowFromFloats(w,o,H,h,E){if(w<0||w>3)return this;const e=4*w;return this.we[e+0]=o,this.we[e+1]=H,this.we[e+2]=h,this.we[e+3]=E,this.markAsUpdated(),this}scale(w){const o=new V;return this.scaleToRef(w,o),o}scaleToRef(w,o){for(let H=0;H<16;H++)o.we[H]=this.we[H]*w;return o.markAsUpdated(),o}scaleAndAddToRef(w,o){for(let H=0;H<16;H++)o.we[H]+=this.we[H]*w;return o.markAsUpdated(),o}scaleInPlace(w){const o=this.we;for(let H=0;H<16;H++)o[H]*=w;return this.markAsUpdated(),this}toNormalMatrix(w){const o=r.Matrix[0];this.invertToRef(o),o.transposeToRef(w);const H=w.we;return V.FromValuesToRef(H[0],H[1],H[2],0,H[4],H[5],H[6],0,H[8],H[9],H[10],0,0,0,0,1,w),w}getRotationMatrix(){const w=new V;return this.getRotationMatrixToRef(w),w}getRotationMatrixToRef(w){const o=r.io[0];if(!this.decompose(o))return V.IdentityToRef(w),w;const H=this.we,h=1/o._x,E=1/o._y,e=1/o._z;return V.FromValuesToRef(H[0]*h,H[1]*h,H[2]*h,0,H[4]*E,H[5]*E,H[6]*E,0,H[8]*e,H[9]*e,H[10]*e,0,0,0,0,1,w),w}toggleModelMatrixHandInPlace(){const w=this.we;return w[2]*=-1,w[6]*=-1,w[8]*=-1,w[9]*=-1,w[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const w=this.we;return w[8]*=-1,w[9]*=-1,w[10]*=-1,w[11]*=-1,this.markAsUpdated(),this}static Po(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const H=new V;return V.FromArrayToRef(w,o,H),H}static FromArrayToRef(w,o,H){for(let h=0;h<16;h++)H.we[h]=w[h+o];return H.markAsUpdated(),H}static FromFloat32ArrayToRefScaled(w,o,H,h){return h.we[0]=w[0+o]*H,h.we[1]=w[1+o]*H,h.we[2]=w[2+o]*H,h.we[3]=w[3+o]*H,h.we[4]=w[4+o]*H,h.we[5]=w[5+o]*H,h.we[6]=w[6+o]*H,h.we[7]=w[7+o]*H,h.we[8]=w[8+o]*H,h.we[9]=w[9+o]*H,h.we[10]=w[10+o]*H,h.we[11]=w[11+o]*H,h.we[12]=w[12+o]*H,h.we[13]=w[13+o]*H,h.we[14]=w[14+o]*H,h.we[15]=w[15+o]*H,h.markAsUpdated(),h}static get IdentityReadOnly(){return V._IdentityReadOnly}static FromValuesToRef(w,o,H,h,E,e,D,t,X,L,A,y,z,C,Q,M,i){const s=i.we;s[0]=w,s[1]=o,s[2]=H,s[3]=h,s[4]=E,s[5]=e,s[6]=D,s[7]=t,s[8]=X,s[9]=L,s[10]=A,s[11]=y,s[12]=z,s[13]=C,s[14]=Q,s[15]=M,i.markAsUpdated()}static FromValues(w,o,H,h,E,e,D,t,X,L,A,y,z,C,Q,M){const i=new V,s=i.we;return s[0]=w,s[1]=o,s[2]=H,s[3]=h,s[4]=E,s[5]=e,s[6]=D,s[7]=t,s[8]=X,s[9]=L,s[10]=A,s[11]=y,s[12]=z,s[13]=C,s[14]=Q,s[15]=M,i.markAsUpdated(),i}static Compose(w,o,H){const h=new V;return V.ComposeToRef(w,o,H,h),h}static ComposeToRef(w,o,H,h){const E=h.we,e=o._x,D=o._y,t=o._z,X=o._w,L=e+e,A=D+D,y=t+t,z=e*L,C=e*A,Q=e*y,M=D*A,i=D*y,s=t*y,V=X*L,r=X*A,k=X*y,P=w._x,l=w._y,O=w._z;return E[0]=(1-(M+s))*P,E[1]=(C+k)*P,E[2]=(Q-r)*P,E[3]=0,E[4]=(C-k)*l,E[5]=(1-(z+s))*l,E[6]=(i+V)*l,E[7]=0,E[8]=(Q+r)*O,E[9]=(i-V)*O,E[10]=(1-(z+M))*O,E[11]=0,E[12]=H._x,E[13]=H._y,E[14]=H._z,E[15]=1,h.markAsUpdated(),h}static Identity(){const w=V.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return w._updateIdentityStatus(!0),w}static IdentityToRef(w){return V.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,w),w._updateIdentityStatus(!0),w}static Zero(){const w=V.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return w._updateIdentityStatus(!1),w}static RotationX(w){const o=new V;return V.RotationXToRef(w,o),o}static Invert(w){const o=new V;return w.invertToRef(o),o}static RotationXToRef(w,o){const H=Math.sin(w),h=Math.cos(w);return V.FromValuesToRef(1,0,0,0,0,h,H,0,0,-H,h,0,0,0,0,1,o),o._updateIdentityStatus(1===h&&0===H),o}static RotationY(w){const o=new V;return V.RotationYToRef(w,o),o}static RotationYToRef(w,o){const H=Math.sin(w),h=Math.cos(w);return V.FromValuesToRef(h,0,-H,0,0,1,0,0,H,0,h,0,0,0,0,1,o),o._updateIdentityStatus(1===h&&0===H),o}static RotationZ(w){const o=new V;return V.RotationZToRef(w,o),o}static RotationZToRef(w,o){const H=Math.sin(w),h=Math.cos(w);return V.FromValuesToRef(h,H,0,0,-H,h,0,0,0,0,1,0,0,0,0,1,o),o._updateIdentityStatus(1===h&&0===H),o}static RotationAxis(w,o){const H=new V;return V.RotationAxisToRef(w,o,H),H}static RotationAxisToRef(w,o,H){const h=Math.sin(-o),E=Math.cos(-o),e=1-E;w=w.normalizeToRef(r.io[0]);const D=H.we;return D[0]=w._x*w._x*e+E,D[1]=w._x*w._y*e-w._z*h,D[2]=w._x*w._z*e+w._y*h,D[3]=0,D[4]=w._y*w._x*e+w._z*h,D[5]=w._y*w._y*e+E,D[6]=w._y*w._z*e-w._x*h,D[7]=0,D[8]=w._z*w._x*e-w._y*h,D[9]=w._z*w._y*e+w._x*h,D[10]=w._z*w._z*e+E,D[11]=0,D[12]=0,D[13]=0,D[14]=0,D[15]=1,H.markAsUpdated(),H}static RotationAlignToRef(w,o,H){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const e=M.Dot(o,w),D=H.we;if(e<-1+h.c)D[0]=-1,D[1]=0,D[2]=0,D[3]=0,D[4]=0,D[5]=E?1:-1,D[6]=0,D[7]=0,D[8]=0,D[9]=0,D[10]=E?-1:1,D[11]=0;else{const H=M.Cross(o,w),h=1/(1+e);D[0]=H._x*H._x*h+e,D[1]=H._y*H._x*h-H._z,D[2]=H._z*H._x*h+H._y,D[3]=0,D[4]=H._x*H._y*h+H._z,D[5]=H._y*H._y*h+e,D[6]=H._z*H._y*h-H._x,D[7]=0,D[8]=H._x*H._z*h-H._y,D[9]=H._y*H._z*h+H._x,D[10]=H._z*H._z*h+e,D[11]=0}return D[12]=0,D[13]=0,D[14]=0,D[15]=1,H.markAsUpdated(),H}static RotationYawPitchRoll(w,o,H){const h=new V;return V.RotationYawPitchRollToRef(w,o,H,h),h}static RotationYawPitchRollToRef(w,o,H,h){return s.RotationYawPitchRollToRef(w,o,H,r.Quaternion[0]),r.Quaternion[0].toRotationMatrix(h),h}static Scaling(w,o,H){const h=new V;return V.ScalingToRef(w,o,H,h),h}static ScalingToRef(w,o,H,h){return V.FromValuesToRef(w,0,0,0,0,o,0,0,0,0,H,0,0,0,0,1,h),h._updateIdentityStatus(1===w&&1===o&&1===H),h}static Translation(w,o,H){const h=new V;return V.TranslationToRef(w,o,H,h),h}static TranslationToRef(w,o,H,h){return V.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,w,o,H,1,h),h._updateIdentityStatus(0===w&&0===o&&0===H),h}static Lerp(w,o,H){const h=new V;return V.LerpToRef(w,o,H,h),h}static LerpToRef(w,o,H,h){const E=h.we,e=w.m,D=o.m;for(let t=0;t<16;t++)E[t]=e[t]*(1-H)+D[t]*H;return h.markAsUpdated(),h}static DecomposeLerp(w,o,H){const h=new V;return V.DecomposeLerpToRef(w,o,H,h),h}static DecomposeLerpToRef(w,o,H,h){const E=r.io[0],e=r.Quaternion[0],D=r.io[1];w.decompose(E,e,D);const t=r.io[2],X=r.Quaternion[1],L=r.io[3];o.decompose(t,X,L);const A=r.io[4];M.LerpToRef(E,t,H,A);const y=r.Quaternion[2];s.SlerpToRef(e,X,H,y);const z=r.io[5];return M.LerpToRef(D,L,H,z),V.ComposeToRef(A,y,z,h),h}static LookAtLH(w,o,H){const h=new V;return V.LookAtLHToRef(w,o,H,h),h}static LookAtLHToRef(w,o,H,h){const E=r.io[0],e=r.io[1],D=r.io[2];o.subtractToRef(w,D),D.normalize(),M.CrossToRef(H,D,E);const t=E.lengthSquared();0===t?E.x=1:E.normalizeFromLength(Math.sqrt(t)),M.CrossToRef(D,E,e),e.normalize();const X=-M.Dot(E,w),L=-M.Dot(e,w),A=-M.Dot(D,w);return V.FromValuesToRef(E._x,e._x,D._x,0,E._y,e._y,D._y,0,E._z,e._z,D._z,0,X,L,A,1,h),h}static LookAtRH(w,o,H){const h=new V;return V.LookAtRHToRef(w,o,H,h),h}static LookAtRHToRef(w,o,H,h){const E=r.io[0],e=r.io[1],D=r.io[2];w.subtractToRef(o,D),D.normalize(),M.CrossToRef(H,D,E);const t=E.lengthSquared();0===t?E.x=1:E.normalizeFromLength(Math.sqrt(t)),M.CrossToRef(D,E,e),e.normalize();const X=-M.Dot(E,w),L=-M.Dot(e,w),A=-M.Dot(D,w);return V.FromValuesToRef(E._x,e._x,D._x,0,E._y,e._y,D._y,0,E._z,e._z,D._z,0,X,L,A,1,h),h}static LookDirectionLH(w,o){const H=new V;return V.LookDirectionLHToRef(w,o,H),H}static LookDirectionLHToRef(w,o,H){const h=r.io[0];h.t(w),h.scaleInPlace(-1);const E=r.io[1];return M.CrossToRef(o,h,E),V.FromValuesToRef(E._x,E._y,E._z,0,o._x,o._y,o._z,0,h._x,h._y,h._z,0,0,0,0,1,H),H}static LookDirectionRH(w,o){const H=new V;return V.LookDirectionRHToRef(w,o,H),H}static LookDirectionRHToRef(w,o,H){const h=r.io[2];return M.CrossToRef(o,w,h),V.FromValuesToRef(h._x,h._y,h._z,0,o._x,o._y,o._z,0,w._x,w._y,w._z,0,0,0,0,1,H),H}static OrthoLH(w,o,H,h,E){const e=new V;return V.OrthoLHToRef(w,o,H,h,e,E),e}static OrthoLHToRef(w,o,H,h,E,e){const D=2/w,t=2/o,X=2/(h-H),L=-(h+H)/(h-H);return V.FromValuesToRef(D,0,0,0,0,t,0,0,0,0,X,0,0,0,L,1,E),e&&E.multiplyToRef(P,E),E._updateIdentityStatus(1===D&&1===t&&1===X&&0===L),E}static OrthoOffCenterLH(w,o,H,h,E,e,D){const t=new V;return V.OrthoOffCenterLHToRef(w,o,H,h,E,e,t,D),t}static OrthoOffCenterLHToRef(w,o,H,h,E,e,D,t){const X=2/(o-w),L=2/(h-H),A=2/(e-E),y=-(e+E)/(e-E),z=(w+o)/(w-o),C=(h+H)/(H-h);return V.FromValuesToRef(X,0,0,0,0,L,0,0,0,0,A,0,z,C,y,1,D),t&&D.multiplyToRef(P,D),D.markAsUpdated(),D}static ObliqueOffCenterLHToRef(w,o,H,h,E,e,D,t,X,L,A){const y=-D*Math.cos(t),z=-D*Math.sin(t);return V.TranslationToRef(0,0,-X,r.Matrix[1]),V.FromValuesToRef(1,0,0,0,0,1,0,0,y,z,1,0,0,0,0,1,r.Matrix[0]),r.Matrix[1].multiplyToRef(r.Matrix[0],r.Matrix[0]),V.TranslationToRef(0,0,X,r.Matrix[1]),r.Matrix[0].multiplyToRef(r.Matrix[1],r.Matrix[0]),V.OrthoOffCenterLHToRef(w,o,H,h,E,e,L,A),r.Matrix[0].multiplyToRef(L,L),L}static OrthoOffCenterRH(w,o,H,h,E,e,D){const t=new V;return V.OrthoOffCenterRHToRef(w,o,H,h,E,e,t,D),t}static OrthoOffCenterRHToRef(w,o,H,h,E,e,D,t){return V.OrthoOffCenterLHToRef(w,o,H,h,E,e,D,t),D.we[10]*=-1,D}static ObliqueOffCenterRHToRef(w,o,H,h,E,e,D,t,X,L,A){const y=D*Math.cos(t),z=D*Math.sin(t);return V.TranslationToRef(0,0,X,r.Matrix[1]),V.FromValuesToRef(1,0,0,0,0,1,0,0,y,z,1,0,0,0,0,1,r.Matrix[0]),r.Matrix[1].multiplyToRef(r.Matrix[0],r.Matrix[0]),V.TranslationToRef(0,0,-X,r.Matrix[1]),r.Matrix[0].multiplyToRef(r.Matrix[1],r.Matrix[0]),V.OrthoOffCenterRHToRef(w,o,H,h,E,e,L,A),r.Matrix[0].multiplyToRef(L,L),L}static PerspectiveLH(w,o,H,h,E){let e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const D=new V,t=2*H/w,X=2*H/o,L=(h+H)/(h-H),A=-2*h*H/(h-H),y=Math.tan(e);return V.FromValuesToRef(t,0,0,0,0,X,0,y,0,0,L,1,0,0,A,0,D),E&&D.multiplyToRef(P,D),D._updateIdentityStatus(!1),D}static PerspectiveFovLH(w,o,H,h,E){let e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,D=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const t=new V;return V.PerspectiveFovLHToRef(w,o,H,h,t,!0,E,e,D),t}static PerspectiveFovLHToRef(w,o,H,h,E){let e=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],D=arguments.length>6?arguments[6]:void 0,t=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,X=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const L=H,A=h,y=1/Math.tan(.5*w),z=e?y/o:y,C=e?y:y*o,Q=X&&0===L?-1:0!==A?(A+L)/(A-L):1,M=X&&0===L?2*A:0!==A?-2*A*L/(A-L):-2*L,i=Math.tan(t);return V.FromValuesToRef(z,0,0,0,0,C,0,i,0,0,Q,1,0,0,M,0,E),D&&E.multiplyToRef(P,E),E._updateIdentityStatus(!1),E}static PerspectiveFovReverseLHToRef(w,o,H,h,E){let e=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],D=arguments.length>6?arguments[6]:void 0,t=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const X=1/Math.tan(.5*w),L=e?X/o:X,A=e?X:X*o,y=Math.tan(t);return V.FromValuesToRef(L,0,0,0,0,A,0,y,0,0,-H,1,0,0,1,0,E),D&&E.multiplyToRef(P,E),E._updateIdentityStatus(!1),E}static PerspectiveFovRH(w,o,H,h,E){let e=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,D=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const t=new V;return V.PerspectiveFovRHToRef(w,o,H,h,t,!0,E,e,D),t}static PerspectiveFovRHToRef(w,o,H,h,E){let e=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],D=arguments.length>6?arguments[6]:void 0,t=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,X=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const L=H,A=h,y=1/Math.tan(.5*w),z=e?y/o:y,C=e?y:y*o,Q=X&&0===L?1:0!==A?-(A+L)/(A-L):-1,M=X&&0===L?2*A:0!==A?-2*A*L/(A-L):-2*L,i=Math.tan(t);return V.FromValuesToRef(z,0,0,0,0,C,0,i,0,0,Q,-1,0,0,M,0,E),D&&E.multiplyToRef(P,E),E._updateIdentityStatus(!1),E}static PerspectiveFovReverseRHToRef(w,o,H,h,E){let e=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],D=arguments.length>6?arguments[6]:void 0,t=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const X=1/Math.tan(.5*w),L=e?X/o:X,A=e?X:X*o,y=Math.tan(t);return V.FromValuesToRef(L,0,0,0,0,A,0,y,0,0,-H,-1,0,0,-1,0,E),D&&E.multiplyToRef(P,E),E._updateIdentityStatus(!1),E}static GetFinalMatrix(w,o,H,h,E,e){const D=w.width,t=w.height,X=w.x,L=w.y,A=V.FromValues(D/2,0,0,0,0,-t/2,0,0,0,0,e-E,0,X+D/2,t/2+L,E,1),y=new V;return o.multiplyToRef(H,y),y.multiplyToRef(h,y),y.multiplyToRef(A,y)}static GetAsMatrix2x2(w){const o=w.m,H=[o[0],o[1],o[4],o[5]];return D.d.MatrixUse64Bits?H:new Float32Array(H)}static GetAsMatrix3x3(w){const o=w.m,H=[o[0],o[1],o[2],o[4],o[5],o[6],o[8],o[9],o[10]];return D.d.MatrixUse64Bits?H:new Float32Array(H)}static Transpose(w){const o=new V;return V.TransposeToRef(w,o),o}static TransposeToRef(w,o){const H=w.m,h=H[0],E=H[4],e=H[8],D=H[12],t=H[1],X=H[5],L=H[9],A=H[13],y=H[2],z=H[6],C=H[10],Q=H[14],M=H[3],i=H[7],s=H[11],V=H[15],r=o.we;return r[0]=h,r[1]=E,r[2]=e,r[3]=D,r[4]=t,r[5]=X,r[6]=L,r[7]=A,r[8]=y,r[9]=z,r[10]=C,r[11]=Q,r[12]=M,r[13]=i,r[14]=s,r[15]=V,o.markAsUpdated(),o._updateIdentityStatus(w._isIdentity,w._isIdentityDirty),o}static Reflection(w){const o=new V;return V.ReflectionToRef(w,o),o}static ReflectionToRef(w,o){w.normalize();const H=w.normal.x,h=w.normal.y,E=w.normal.z,e=-2*H,D=-2*h,t=-2*E;return V.FromValuesToRef(e*H+1,D*H,t*H,0,e*h,D*h+1,t*h,0,e*E,D*E,t*E+1,0,e*w.d,D*w.d,t*w.d,1,o),o}static FromXYZAxesToRef(w,o,H,h){return V.FromValuesToRef(w._x,w._y,w._z,0,o._x,o._y,o._z,0,H._x,H._y,H._z,0,0,0,0,1,h),h}static FromQuaternionToRef(w,o){const H=w._x*w._x,h=w._y*w._y,E=w._z*w._z,e=w._x*w._y,D=w._z*w._w,t=w._z*w._x,X=w._y*w._w,L=w._y*w._z,A=w._x*w._w;return o.we[0]=1-2*(h+E),o.we[1]=2*(e+D),o.we[2]=2*(t-X),o.we[3]=0,o.we[4]=2*(e-D),o.we[5]=1-2*(E+H),o.we[6]=2*(L+A),o.we[7]=0,o.we[8]=2*(t+X),o.we[9]=2*(L-A),o.we[10]=1-2*(h+H),o.we[11]=0,o.we[12]=0,o.we[13]=0,o.we[14]=0,o.we[15]=1,o.markAsUpdated(),o}}V._IdentityReadOnly=V.Identity(),Object.defineProperties(V.prototype,{dimension:{value:[4,4]},rank:{value:2}});class r{}r.io=(0,E.f)(11,M.Zero),r.Matrix=(0,E.f)(2,V.Identity),r.Quaternion=(0,E.f)(3,s.Zero);class k{}k.Vector2=(0,E.f)(3,Q.Zero),k.io=(0,E.f)(13,M.Zero),k.Vector4=(0,E.f)(3,i.Zero),k.Quaternion=(0,E.f)(3,s.Zero),k.Matrix=(0,E.f)(8,V.Identity),(0,e.g)("BABYLON.Vector2",Q),(0,e.g)("BABYLON.Vector3",M),(0,e.g)("BABYLON.Vector4",i),(0,e.g)("BABYLON.Matrix",V);const P=V.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11727:(w,o,H)=>{function h(w,o){const H=[];for(let h=0;h<w;++h)H.push(o());return H}function E(w,o){return h(w,o)}H.d(o,{c:()=>h,f:()=>E,i:()=>D});const e=["push","splice","pop","shift","unshift"];function D(w,o){const H=e.map((H=>function(w,o,H){const h=w[o];if("function"!==typeof h)return null;const E=function(){const h=w.length,e=E.previous.apply(w,arguments);return H(o,h),e};return h.next=E,E.previous=h,w[o]=E,()=>{const H=E.previous;if(!H)return;const h=E.next;h?(H.next=h,h.previous=H):(H.next=void 0,w[o]=H),E.next=void 0,E.previous=void 0}}(w,H,o)));return()=>{for(const w of H)null===w||void 0===w||w()}}}}]);