"use strict";(self.zcqpiao938m=self.zcqpiao938m||[]).push([[14],{11835:(C,U,K)=>{K.d(U,{d:()=>A,f:()=>X,i:()=>m,j:()=>O});const m=1/2.2,O=2.2,X=(1+Math.sqrt(5))/2,A=.001},11846:(C,U,K)=>{function m(C){return parseInt(C.toString().replace(/\W/g,""))}function O(C,U){let K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(C-U)<=K}function X(C,U,K){let m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return C<U-m||C>K+m}function A(C,U){return C===U?C:Math.random()*(U-C)+C}function e(C,U,K){return C+(U-C)*K}function t(C,U,K){let m=Q(U-C,360);return m>180&&(m-=360),C+m*E(K)}function z(C,U,K){let m=0;return m=C!=U?E((K-C)/(U-C)):0,m}function j(C,U,K,m,O){const X=O*O,A=O*X;return C*(2*A-3*X+1)+K*(-2*A+3*X)+U*(A-2*X+O)+m*(A-X)}function p(C,U,K,m,O){const X=O*O;return 6*(X-O)*C+(3*X-4*O+1)*U+6*(-X+O)*K+(3*X-2*O)*m}function E(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(K,Math.max(U,C))}function u(C){return C-=2*Math.PI*Math.floor((C+Math.PI)/(2*Math.PI))}function b(C){const U=C.toString(16);return C<=15?("0"+U).toUpperCase():U.toUpperCase()}function v(C){if(Math.log2)return Math.floor(Math.log2(C));if(C<0)return NaN;if(0===C)return-1/0;let U=0;if(C<1){for(;C<1;)U++,C*=2;U=-U}else if(C>1)for(;C>1;)U++,C=Math.floor(C/2);return U}function Q(C,U){return C-Math.floor(C/U)*U}function V(C,U,K){return(C-U)/(K-U)}function f(C,U,K){return C*(K-U)+U}function F(C,U){let K=Q(U-C,360);return K>180&&(K-=360),K}function Z(C,U){const K=Q(C,2*U);return U-Math.abs(K-U)}function P(C,U,K){let m=E(K);return m=-2*m*m*m+3*m*m,U*m+C*(1-m)}function H(C,U,K){let m=0;return m=Math.abs(U-C)<=K?U:C+Math.sign(U-C)*K,m}function d(C,U,K){const m=F(C,U);let O=0;return O=-K<m&&m<K?U:H(C,U=C+m,K),O}function T(C,U,K){return(C-U)/(K-U)}function y(C,U,K){return(K-U)*C+U}function a(C,U){const K=C%U;return 0===K?U:a(U,K)}K.r(U),K.d(U,{Clamp:()=>E,DeltaAngle:()=>F,Denormalize:()=>f,ExtractAsInt:()=>m,Hermite:()=>j,Hermite1stDerivative:()=>p,HighestCommonFactor:()=>a,ILog2:()=>v,InverseLerp:()=>z,Lerp:()=>e,LerpAngle:()=>t,MoveTowards:()=>H,MoveTowardsAngle:()=>d,Normalize:()=>V,NormalizeRadians:()=>u,OutsideRange:()=>X,PercentToRange:()=>y,PingPong:()=>Z,RandomRange:()=>A,RangeToPercent:()=>T,Repeat:()=>Q,SmoothStep:()=>P,ToHex:()=>b,WithinEpsilon:()=>O})},11827:(C,U,K)=>{K.r(U),K.d(U,{Matrix:()=>f,Quaternion:()=>V,TmpVectors:()=>Z,Vector2:()=>b,bU:()=>v,Vector4:()=>Q});var m=K(11835),O=K(11844),X=K(11789),A=K(11764),e=K(11703),t=K(11846);class z{}function j(C,U,K){let m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const O=C.Oe(),X=U.Oe(),A=O[0],e=O[1],t=O[2],z=O[3],j=O[4],p=O[5],E=O[6],u=O[7],b=O[8],v=O[9],Q=O[10],V=O[11],f=O[12],F=O[13],Z=O[14],P=O[15],H=X[0],d=X[1],T=X[2],y=X[3],a=X[4],r=X[5],i=X[6],D=X[7],l=X[8],G=X[9],J=X[10],o=X[11],B=X[12],k=X[13],w=X[14],h=X[15];K[m]=A*H+e*a+t*l+z*B,K[m+1]=A*d+e*r+t*G+z*k,K[m+2]=A*T+e*i+t*J+z*w,K[m+3]=A*y+e*D+t*o+z*h,K[m+4]=j*H+p*a+E*l+u*B,K[m+5]=j*d+p*r+E*G+u*k,K[m+6]=j*T+p*i+E*J+u*w,K[m+7]=j*y+p*D+E*o+u*h,K[m+8]=b*H+v*a+Q*l+V*B,K[m+9]=b*d+v*r+Q*G+V*k,K[m+10]=b*T+v*i+Q*J+V*w,K[m+11]=b*y+v*D+Q*o+V*h,K[m+12]=f*H+F*a+Z*l+P*B,K[m+13]=f*d+F*r+Z*G+P*k,K[m+14]=f*T+F*i+Z*J+P*w,K[m+15]=f*y+F*D+Z*o+P*h}function p(C,U){let K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const m=C.Oe();U[K]=m[0],U[K+1]=m[1],U[K+2]=m[2],U[K+3]=m[3],U[K+4]=m[4],U[K+5]=m[5],U[K+6]=m[6],U[K+7]=m[7],U[K+8]=m[8],U[K+9]=m[9],U[K+10]=m[10],U[K+11]=m[11],U[K+12]=m[12],U[K+13]=m[13],U[K+14]=m[14],U[K+15]=m[15]}function E(C,U){const K=C.Oe(),m=K[0],O=K[1],X=K[2],A=K[3],e=K[4],t=K[5],z=K[6],j=K[7],p=K[8],E=K[9],u=K[10],b=K[11],v=K[12],Q=K[13],V=K[14],f=K[15],F=u*f-V*b,Z=E*f-Q*b,P=E*V-Q*u,H=p*f-v*b,d=p*V-u*v,T=p*Q-v*E,y=+(t*F-z*Z+j*P),a=-(e*F-z*H+j*d),r=+(e*Z-t*H+j*T),i=-(e*P-t*d+z*T),D=m*y+O*a+X*r+A*i;if(0===D)return!1;const l=1/D,G=z*f-V*j,J=t*f-Q*j,o=t*V-Q*z,B=e*f-v*j,k=e*V-v*z,w=e*Q-v*t,h=z*b-u*j,c=t*b-E*j,N=t*u-E*z,g=e*b-p*j,M=e*u-p*z,L=e*E-p*t,Y=-(O*F-X*Z+A*P),W=+(m*F-X*H+A*d),x=-(m*Z-O*H+A*T),n=+(m*P-O*d+X*T),S=+(O*G-X*J+A*o),s=-(m*G-X*B+A*k),R=+(m*J-O*B+A*w),q=-(m*o-O*k+X*w),I=-(O*h-X*c+A*N),CC=+(m*h-X*g+A*M),UC=-(m*c-O*g+A*L),KC=+(m*N-O*M+X*L);return U[0]=y*l,U[1]=Y*l,U[2]=S*l,U[3]=I*l,U[4]=a*l,U[5]=W*l,U[6]=s*l,U[7]=CC*l,U[8]=r*l,U[9]=x*l,U[10]=R*l,U[11]=UC*l,U[12]=i*l,U[13]=n*l,U[14]=q*l,U[15]=KC*l,!0}z._UpdateFlagSeed=0;const u=C=>parseInt(C.toString().replace(/\W/g,""));class b{constructor(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=C,this.y=U}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let C=u(this.x);return C=397*C^u(this.y),C}toArray(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C[U]=this.x,C[U+1]=this.y,this}uK(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b.FromArrayToRef(C,U,this),this}Oe(){return[this.x,this.y]}m(C){return this.x=C.x,this.y=C.y,this}Ee(C,U){return this.x=C,this.y=U,this}set(C,U){return this.Ee(C,U)}be(C){return this.Ee(C,C)}add(C){return new b(this.x+C.x,this.y+C.y)}addToRef(C,U){return U.x=this.x+C.x,U.y=this.y+C.y,U}addInPlace(C){return this.x+=C.x,this.y+=C.y,this}addInPlaceFromFloats(C,U){return this.x+=C,this.y+=U,this}addVector3(C){return new b(this.x+C.x,this.y+C.y)}vU(C){return new b(this.x-C.x,this.y-C.y)}subtractToRef(C,U){return U.x=this.x-C.x,U.y=this.y-C.y,U}zp(C){return this.x-=C.x,this.y-=C.y,this}multiplyInPlace(C){return this.x*=C.x,this.y*=C.y,this}multiply(C){return new b(this.x*C.x,this.y*C.y)}multiplyToRef(C,U){return U.x=this.x*C.x,U.y=this.y*C.y,U}multiplyByFloats(C,U){return new b(this.x*C,this.y*U)}divide(C){return new b(this.x/C.x,this.y/C.y)}divideToRef(C,U){return U.x=this.x/C.x,U.y=this.y/C.y,U}divideInPlace(C){return this.x=this.x/C.x,this.y=this.y/C.y,this}minimizeInPlace(C){return this.minimizeInPlaceFromFloats(C.x,C.y)}maximizeInPlace(C){return this.maximizeInPlaceFromFloats(C.x,C.y)}minimizeInPlaceFromFloats(C,U){return this.x=Math.min(C,this.x),this.y=Math.min(U,this.y),this}maximizeInPlaceFromFloats(C,U){return this.x=Math.max(C,this.x),this.y=Math.max(U,this.y),this}subtractFromFloats(C,U){return new b(this.x-C,this.y-U)}subtractFromFloatsToRef(C,U,K){return K.x=this.x-C,K.y=this.y-U,K}negate(){return new b(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(C){return C.x=-this.x,C.y=-this.y,C}scaleInPlace(C){return this.x*=C,this.y*=C,this}scale(C){return new b(this.x*C,this.y*C)}scaleToRef(C,U){return U.x=this.x*C,U.y=this.y*C,U}scaleAndAddToRef(C,U){return U.x+=this.x*C,U.y+=this.y*C,U}equals(C){return C&&this.x===C.x&&this.y===C.y}equalsWithEpsilon(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m.d;return C&&(0,t.WithinEpsilon)(this.x,C.x,U)&&(0,t.WithinEpsilon)(this.y,C.y,U)}equalsToFloats(C,U){return this.x===C&&this.y===U}floor(){return new b(Math.floor(this.x),Math.floor(this.y))}floorToRef(C){return C.x=Math.floor(this.x),C.y=Math.floor(this.y),C}fract(){return new b(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(C){return C.x=this.x-Math.floor(this.x),C.y=this.y-Math.floor(this.y),C}rotate(C){return this.rotateToRef(C,new b)}rotateToRef(C,U){const K=Math.cos(C),m=Math.sin(C);return U.x=K*this.x-m*this.y,U.y=m*this.x+K*this.y,U}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(C){return 0===C||1===C?this:this.scaleInPlace(1/C)}normalizeToNew(){const C=new b;return this.normalizeToRef(C),C}normalizeToRef(C){const U=this.length();return 0===U&&(C.x=this.x,C.y=this.y),this.scaleToRef(1/U,C)}clone(){return new b(this.x,this.y)}dot(C){return this.x*C.x+this.y*C.y}static Zero(){return new b(0,0)}static One(){return new b(1,1)}static Random(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new b((0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U))}static RandomToRef(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ee((0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U))}static get ZeroReadOnly(){return b._ZeroReadOnly}static FU(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new b(C[U],C[U+1])}static FromArrayToRef(C,U,K){return K.x=C[U],K.y=C[U+1],K}static FromFloatsToRef(C,U,K){return K.Ee(C,U),K}static CatmullRom(C,U,K,m,O){const X=O*O,A=O*X,e=.5*(2*U.x+(-C.x+K.x)*O+(2*C.x-5*U.x+4*K.x-m.x)*X+(-C.x+3*U.x-3*K.x+m.x)*A),t=.5*(2*U.y+(-C.y+K.y)*O+(2*C.y-5*U.y+4*K.y-m.y)*X+(-C.y+3*U.y-3*K.y+m.y)*A);return new b(e,t)}static ClampToRef(C,U,K,m){return m.x=(0,t.Clamp)(C.x,U.x,K.x),m.y=(0,t.Clamp)(C.y,U.y,K.y),m}static Clamp(C,U,K){const m=(0,t.Clamp)(C.x,U.x,K.x),O=(0,t.Clamp)(C.y,U.y,K.y);return new b(m,O)}static Hermite(C,U,K,m,O){const X=O*O,A=O*X,e=2*A-3*X+1,t=-2*A+3*X,z=A-2*X+O,j=A-X,p=C.x*e+K.x*t+U.x*z+m.x*j,E=C.y*e+K.y*t+U.y*z+m.y*j;return new b(p,E)}static Hermite1stDerivative(C,U,K,m,O){return this.Hermite1stDerivativeToRef(C,U,K,m,O,new b)}static Hermite1stDerivativeToRef(C,U,K,m,O,X){const A=O*O;return X.x=6*(A-O)*C.x+(3*A-4*O+1)*U.x+6*(-A+O)*K.x+(3*A-2*O)*m.x,X.y=6*(A-O)*C.y+(3*A-4*O+1)*U.y+6*(-A+O)*K.y+(3*A-2*O)*m.y,X}static Lerp(C,U,K){return b.LerpToRef(C,U,K,new b)}static LerpToRef(C,U,K,m){return m.x=C.x+(U.x-C.x)*K,m.y=C.y+(U.y-C.y)*K,m}static Dot(C,U){return C.x*U.x+C.y*U.y}static Normalize(C){return b.NormalizeToRef(C,new b)}static NormalizeToRef(C,U){return C.normalizeToRef(U),U}static Minimize(C,U){const K=C.x<U.x?C.x:U.x,m=C.y<U.y?C.y:U.y;return new b(K,m)}static Maximize(C,U){const K=C.x>U.x?C.x:U.x,m=C.y>U.y?C.y:U.y;return new b(K,m)}static Transform(C,U){return b.TransformToRef(C,U,new b)}static TransformToRef(C,U,K){const m=U.m,O=C.x*m[0]+C.y*m[4]+m[12],X=C.x*m[1]+C.y*m[5]+m[13];return K.x=O,K.y=X,K}static PointInTriangle(C,U,K,m){const O=.5*(-K.y*m.x+U.y*(-K.x+m.x)+U.x*(K.y-m.y)+K.x*m.y),X=O<0?-1:1,A=(U.y*m.x-U.x*m.y+(m.y-U.y)*C.x+(U.x-m.x)*C.y)*X,e=(U.x*K.y-U.y*K.x+(U.y-K.y)*C.x+(K.x-U.x)*C.y)*X;return A>0&&e>0&&A+e<2*O*X}static Distance(C,U){return Math.sqrt(b.DistanceSquared(C,U))}static DistanceSquared(C,U){const K=C.x-U.x,m=C.y-U.y;return K*K+m*m}static Center(C,U){return b.CenterToRef(C,U,new b)}static CenterToRef(C,U,K){return K.Ee((C.x+U.x)/2,(C.y+U.y)/2)}static DistanceOfPointFromSegment(C,U,K){const m=b.DistanceSquared(U,K);if(0===m)return b.Distance(C,U);const O=K.vU(U),X=Math.max(0,Math.min(1,b.Dot(C.vU(U),O)/m)),A=U.add(O.multiplyByFloats(X,X));return b.Distance(C,A)}}b._V8PerformanceHack=new b(.5,.5),b._ZeroReadOnly=b.Zero(),Object.defineProperties(b.prototype,{dimension:{value:[2]},rank:{value:1}});class v{get x(){return this._x}set x(C){this._x=C,this._isDirty=!0}get y(){return this._y}set y(C){this._y=C,this._isDirty=!0}get z(){return this._z}set z(C){this._z=C,this._isDirty=!0}constructor(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=C,this._y=U,this._z=K}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"bU"}getHashCode(){let C=u(this._x);return C=397*C^u(this._y),C=397*C^u(this._z),C}Oe(){return[this._x,this._y,this._z]}toArray(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C[U]=this._x,C[U+1]=this._y,C[U+2]=this._z,this}uK(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return v.FromArrayToRef(C,U,this),this}toQuaternion(){return V.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(C){return this._x+=C._x,this._y+=C._y,this._z+=C._z,this._isDirty=!0,this}addInPlaceFromFloats(C,U,K){return this._x+=C,this._y+=U,this._z+=K,this._isDirty=!0,this}add(C){return new v(this._x+C._x,this._y+C._y,this._z+C._z)}addToRef(C,U){return U._x=this._x+C._x,U._y=this._y+C._y,U._z=this._z+C._z,U._isDirty=!0,U}zp(C){return this._x-=C._x,this._y-=C._y,this._z-=C._z,this._isDirty=!0,this}vU(C){return new v(this._x-C._x,this._y-C._y,this._z-C._z)}subtractToRef(C,U){return this.subtractFromFloatsToRef(C._x,C._y,C._z,U)}subtractFromFloats(C,U,K){return new v(this._x-C,this._y-U,this._z-K)}subtractFromFloatsToRef(C,U,K,m){return m._x=this._x-C,m._y=this._y-U,m._z=this._z-K,m._isDirty=!0,m}negate(){return new v(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(C){return C._x=-1*this._x,C._y=-1*this._y,C._z=-1*this._z,C._isDirty=!0,C}scaleInPlace(C){return this._x*=C,this._y*=C,this._z*=C,this._isDirty=!0,this}scale(C){return new v(this._x*C,this._y*C,this._z*C)}scaleToRef(C,U){return U._x=this._x*C,U._y=this._y*C,U._z=this._z*C,U._isDirty=!0,U}getNormalToRef(C){const U=this.length();let K=Math.acos(this._y/U);const m=Math.atan2(this._z,this._x);K>Math.PI/2?K-=Math.PI/2:K+=Math.PI/2;const O=U*Math.sin(K)*Math.cos(m),X=U*Math.cos(K),A=U*Math.sin(K)*Math.sin(m);return C.set(O,X,A),C}applyRotationQuaternionToRef(C,U){const K=this._x,m=this._y,O=this._z,X=C._x,A=C._y,e=C._z,t=C._w,z=2*(A*O-e*m),j=2*(e*K-X*O),p=2*(X*m-A*K);return U._x=K+t*z+A*p-e*j,U._y=m+t*j+e*z-X*p,U._z=O+t*p+X*j-A*z,U._isDirty=!0,U}applyRotationQuaternionInPlace(C){return this.applyRotationQuaternionToRef(C,this)}applyRotationQuaternion(C){return this.applyRotationQuaternionToRef(C,new v)}scaleAndAddToRef(C,U){return U._x+=this._x*C,U._y+=this._y*C,U._z+=this._z*C,U._isDirty=!0,U}projectOnPlane(C,U){return this.projectOnPlaneToRef(C,U,new v)}projectOnPlaneToRef(C,U,K){const m=C.normal,O=C.d,X=F.bU[0];this.subtractToRef(U,X),X.normalize();const A=v.Dot(X,m);if(Math.abs(A)<1e-10)K.be(1/0);else{const C=-(v.Dot(U,m)+O)/A,e=X.scaleInPlace(C);U.addToRef(e,K)}return K}equals(C){return C&&this._x===C._x&&this._y===C._y&&this._z===C._z}equalsWithEpsilon(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m.d;return C&&(0,t.WithinEpsilon)(this._x,C._x,U)&&(0,t.WithinEpsilon)(this._y,C._y,U)&&(0,t.WithinEpsilon)(this._z,C._z,U)}equalsToFloats(C,U,K){return this._x===C&&this._y===U&&this._z===K}multiplyInPlace(C){return this._x*=C._x,this._y*=C._y,this._z*=C._z,this._isDirty=!0,this}multiply(C){return this.multiplyByFloats(C._x,C._y,C._z)}multiplyToRef(C,U){return U._x=this._x*C._x,U._y=this._y*C._y,U._z=this._z*C._z,U._isDirty=!0,U}multiplyByFloats(C,U,K){return new v(this._x*C,this._y*U,this._z*K)}divide(C){return new v(this._x/C._x,this._y/C._y,this._z/C._z)}divideToRef(C,U){return U._x=this._x/C._x,U._y=this._y/C._y,U._z=this._z/C._z,U._isDirty=!0,U}divideInPlace(C){return this._x=this._x/C._x,this._y=this._y/C._y,this._z=this._z/C._z,this._isDirty=!0,this}minimizeInPlace(C){return this.minimizeInPlaceFromFloats(C._x,C._y,C._z)}maximizeInPlace(C){return this.maximizeInPlaceFromFloats(C._x,C._y,C._z)}minimizeInPlaceFromFloats(C,U,K){return C<this._x&&(this.x=C),U<this._y&&(this.y=U),K<this._z&&(this.z=K),this}maximizeInPlaceFromFloats(C,U,K){return C>this._x&&(this.x=C),U>this._y&&(this.y=U),K>this._z&&(this.z=K),this}isNonUniformWithinEpsilon(C){const U=Math.abs(this._x),K=Math.abs(this._y);if(!(0,t.WithinEpsilon)(U,K,C))return!0;const m=Math.abs(this._z);return!(0,t.WithinEpsilon)(U,m,C)||!(0,t.WithinEpsilon)(K,m,C)}get isNonUniform(){const C=Math.abs(this._x);if(C!==Math.abs(this._y))return!0;return C!==Math.abs(this._z)}floorToRef(C){return C._x=Math.floor(this._x),C._y=Math.floor(this._y),C._z=Math.floor(this._z),C._isDirty=!0,C}floor(){return new v(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(C){return C._x=this._x-Math.floor(this._x),C._y=this._y-Math.floor(this._y),C._z=this._z-Math.floor(this._z),C._isDirty=!0,C}fract(){return new v(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(C){if("xyz"===(C=C.toLowerCase()))return this;const U=F.bU[0].m(this);return this.x=U[C[0]],this.y=U[C[1]],this.z=U[C[2]],this}rotateByQuaternionToRef(C,U){return C.toRotationMatrix(F.Matrix[0]),v.TransformCoordinatesToRef(this,F.Matrix[0],U),U}rotateByQuaternionAroundPointToRef(C,U,K){return this.subtractToRef(U,F.bU[0]),F.bU[0].rotateByQuaternionToRef(C,F.bU[0]),U.addToRef(F.bU[0],K),K}cross(C){return v.CrossToRef(this,C,new v)}normalizeFromLength(C){return 0===C||1===C?this:this.scaleInPlace(1/C)}normalizeToNew(){return this.normalizeToRef(new v)}normalizeToRef(C){const U=this.length();return 0===U||1===U?(C._x=this._x,C._y=this._y,C._z=this._z,C._isDirty=!0,C):this.scaleToRef(1/U,C)}clone(){return new v(this._x,this._y,this._z)}m(C){return this.Ee(C._x,C._y,C._z)}Ee(C,U,K){return this._x=C,this._y=U,this._z=K,this._isDirty=!0,this}set(C,U,K){return this.Ee(C,U,K)}be(C){return this._x=this._y=this._z=C,this._isDirty=!0,this}static GetClipFactor(C,U,K,m){const O=v.Dot(C,K);return(O-m)/(O-v.Dot(U,K))}static GetAngleBetweenVectors(C,U,K){const m=C.normalizeToRef(F.bU[1]),O=U.normalizeToRef(F.bU[2]);let X=v.Dot(m,O);X=(0,t.Clamp)(X,-1,1);const A=Math.acos(X),e=F.bU[3];return v.CrossToRef(m,O,e),v.Dot(e,K)>0?isNaN(A)?0:A:isNaN(A)?-Math.PI:-Math.acos(X)}static GetAngleBetweenVectorsOnPlane(C,U,K){F.bU[0].m(C);const m=F.bU[0];F.bU[1].m(U);const O=F.bU[1];F.bU[2].m(K);const X=F.bU[2],A=F.bU[3],e=F.bU[4];m.normalize(),O.normalize(),X.normalize(),v.CrossToRef(X,m,A),v.CrossToRef(A,X,e);const z=Math.atan2(v.Dot(O,A),v.Dot(O,e));return(0,t.NormalizeRadians)(z)}static PitchYawRollToMoveBetweenPointsToRef(C,U,K){const m=Z.bU[0];return U.subtractToRef(C,m),K._y=Math.atan2(m.x,m.z)||0,K._x=Math.atan2(Math.sqrt(m.x**2+m.z**2),m.y)||0,K._z=0,K._isDirty=!0,K}static PitchYawRollToMoveBetweenPoints(C,U){const K=v.Zero();return v.PitchYawRollToMoveBetweenPointsToRef(C,U,K)}static SlerpToRef(C,U,K,O){K=(0,t.Clamp)(K,0,1);const X=F.bU[0],A=F.bU[1];X.m(C);const e=X.length();X.normalizeFromLength(e),A.m(U);const z=A.length();A.normalizeFromLength(z);const j=v.Dot(X,A);let p,E;if(j<1-m.d){const C=Math.acos(j),U=1/Math.sin(C);p=Math.sin((1-K)*C)*U,E=Math.sin(K*C)*U}else p=1-K,E=K;return X.scaleInPlace(p),A.scaleInPlace(E),O.m(X).addInPlace(A),O.scaleInPlace((0,t.Lerp)(e,z,K)),O}static SmoothToRef(C,U,K,m,O){return v.SlerpToRef(C,U,0===m?1:K/m,O),O}static FU(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new v(C[U],C[U+1],C[U+2])}static FromFloatArray(C,U){return v.FU(C,U)}static FromArrayToRef(C,U,K){return K._x=C[U],K._y=C[U+1],K._z=C[U+2],K._isDirty=!0,K}static FromFloatArrayToRef(C,U,K){return v.FromArrayToRef(C,U,K)}static FromFloatsToRef(C,U,K,m){return m.Ee(C,U,K),m}static Zero(){return new v(0,0,0)}static One(){return new v(1,1,1)}static Up(){return new v(0,1,0)}static get UpReadOnly(){return v._UpReadOnly}static get DownReadOnly(){return v._DownReadOnly}static get RightReadOnly(){return v._RightReadOnly}static get LeftReadOnly(){return v._LeftReadOnly}static get LeftHandedForwardReadOnly(){return v._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return v._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return v._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return v._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return v._ZeroReadOnly}static get OneReadOnly(){return v._OneReadOnly}static Down(){return new v(0,-1,0)}static Forward(){return new v(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new v(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new v(1,0,0)}static Left(){return new v(-1,0,0)}static Random(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new v((0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U))}static RandomToRef(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ee((0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U))}static TransformCoordinates(C,U){const K=v.Zero();return v.TransformCoordinatesToRef(C,U,K),K}static TransformCoordinatesToRef(C,U,K){return v.TransformCoordinatesFromFloatsToRef(C._x,C._y,C._z,U,K),K}static TransformCoordinatesFromFloatsToRef(C,U,K,m,O){const X=m.m,A=C*X[0]+U*X[4]+K*X[8]+X[12],e=C*X[1]+U*X[5]+K*X[9]+X[13],t=C*X[2]+U*X[6]+K*X[10]+X[14],z=1/(C*X[3]+U*X[7]+K*X[11]+X[15]);return O._x=A*z,O._y=e*z,O._z=t*z,O._isDirty=!0,O}static TransformNormal(C,U){const K=v.Zero();return v.TransformNormalToRef(C,U,K),K}static TransformNormalToRef(C,U,K){return this.TransformNormalFromFloatsToRef(C._x,C._y,C._z,U,K),K}static TransformNormalFromFloatsToRef(C,U,K,m,O){const X=m.m;return O._x=C*X[0]+U*X[4]+K*X[8],O._y=C*X[1]+U*X[5]+K*X[9],O._z=C*X[2]+U*X[6]+K*X[10],O._isDirty=!0,O}static CatmullRom(C,U,K,m,O){const X=O*O,A=O*X,e=.5*(2*U._x+(-C._x+K._x)*O+(2*C._x-5*U._x+4*K._x-m._x)*X+(-C._x+3*U._x-3*K._x+m._x)*A),t=.5*(2*U._y+(-C._y+K._y)*O+(2*C._y-5*U._y+4*K._y-m._y)*X+(-C._y+3*U._y-3*K._y+m._y)*A),z=.5*(2*U._z+(-C._z+K._z)*O+(2*C._z-5*U._z+4*K._z-m._z)*X+(-C._z+3*U._z-3*K._z+m._z)*A);return new v(e,t,z)}static Clamp(C,U,K){const m=new v;return v.ClampToRef(C,U,K,m),m}static ClampToRef(C,U,K,m){let O=C._x;O=O>K._x?K._x:O,O=O<U._x?U._x:O;let X=C._y;X=X>K._y?K._y:X,X=X<U._y?U._y:X;let A=C._z;return A=A>K._z?K._z:A,A=A<U._z?U._z:A,m.Ee(O,X,A),m}static CheckExtends(C,U,K){U.minimizeInPlace(C),K.maximizeInPlace(C)}static Hermite(C,U,K,m,O){const X=O*O,A=O*X,e=2*A-3*X+1,t=-2*A+3*X,z=A-2*X+O,j=A-X,p=C._x*e+K._x*t+U._x*z+m._x*j,E=C._y*e+K._y*t+U._y*z+m._y*j,u=C._z*e+K._z*t+U._z*z+m._z*j;return new v(p,E,u)}static Hermite1stDerivative(C,U,K,m,O){const X=new v;return this.Hermite1stDerivativeToRef(C,U,K,m,O,X),X}static Hermite1stDerivativeToRef(C,U,K,m,O,X){const A=O*O;return X._x=6*(A-O)*C._x+(3*A-4*O+1)*U._x+6*(-A+O)*K._x+(3*A-2*O)*m._x,X._y=6*(A-O)*C._y+(3*A-4*O+1)*U._y+6*(-A+O)*K._y+(3*A-2*O)*m._y,X._z=6*(A-O)*C._z+(3*A-4*O+1)*U._z+6*(-A+O)*K._z+(3*A-2*O)*m._z,X._isDirty=!0,X}static Lerp(C,U,K){const m=new v(0,0,0);return v.LerpToRef(C,U,K,m),m}static LerpToRef(C,U,K,m){return m._x=C._x+(U._x-C._x)*K,m._y=C._y+(U._y-C._y)*K,m._z=C._z+(U._z-C._z)*K,m._isDirty=!0,m}static Dot(C,U){return C._x*U._x+C._y*U._y+C._z*U._z}dot(C){return this._x*C._x+this._y*C._y+this._z*C._z}static Cross(C,U){const K=new v;return v.CrossToRef(C,U,K),K}static CrossToRef(C,U,K){const m=C._y*U._z-C._z*U._y,O=C._z*U._x-C._x*U._z,X=C._x*U._y-C._y*U._x;return K.Ee(m,O,X),K}static Normalize(C){const U=v.Zero();return v.NormalizeToRef(C,U),U}static NormalizeToRef(C,U){return C.normalizeToRef(U),U}static Project(C,U,K,m){const O=new v;return v.ProjectToRef(C,U,K,m,O),O}static ProjectToRef(C,U,K,m,O){var X;const A=m.width,t=m.height,z=m.x,j=m.y,p=F.Matrix[1],E=null===(X=e.c.LastCreatedEngine)||void 0===X?void 0:X.isNDCHalfZRange,u=E?1:.5,b=E?0:.5;f.FromValuesToRef(A/2,0,0,0,0,-t/2,0,0,0,0,u,0,z+A/2,t/2+j,b,1,p);const Q=F.Matrix[0];return U.multiplyToRef(K,Q),Q.multiplyToRef(p,Q),v.TransformCoordinatesToRef(C,Q,O),O}static Reflect(C,U){return this.ReflectToRef(C,U,new v)}static ReflectToRef(C,U,K){const m=Z.bU[0];return m.m(U).scaleInPlace(2*v.Dot(C,U)),K.m(C).zp(m)}static _UnprojectFromInvertedMatrixToRef(C,U,K){v.TransformCoordinatesToRef(C,U,K);const m=U.m,O=C._x*m[3]+C._y*m[7]+C._z*m[11]+m[15];return(0,t.WithinEpsilon)(O,1)&&K.scaleInPlace(1/O),K}static UnprojectFromTransform(C,U,K,m,O){return this.Unproject(C,U,K,m,O,f.IdentityReadOnly)}static Unproject(C,U,K,m,O,X){const A=new v;return v.UnprojectToRef(C,U,K,m,O,X,A),A}static UnprojectToRef(C,U,K,m,O,X,A){return v.UnprojectFloatsToRef(C._x,C._y,C._z,U,K,m,O,X,A),A}static UnprojectFloatsToRef(C,U,K,m,O,X,A,t,z){var j;const p=F.Matrix[0];X.multiplyToRef(A,p),p.multiplyToRef(t,p),p.invert();const E=F.bU[0];return E.x=C/m*2-1,E.y=-(U/O*2-1),null!==(j=e.c.LastCreatedEngine)&&void 0!==j&&j.isNDCHalfZRange?E.z=K:E.z=2*K-1,v._UnprojectFromInvertedMatrixToRef(E,p,z),z}static Minimize(C,U){const K=new v;return K.m(C),K.minimizeInPlace(U),K}static Maximize(C,U){const K=new v;return K.m(C),K.maximizeInPlace(U),K}static Distance(C,U){return Math.sqrt(v.DistanceSquared(C,U))}static DistanceSquared(C,U){const K=C._x-U._x,m=C._y-U._y,O=C._z-U._z;return K*K+m*m+O*O}static ProjectOnTriangleToRef(C,U,K,O,X){const A=F.bU[0],e=F.bU[1],z=F.bU[2],j=F.bU[3],p=F.bU[4];K.subtractToRef(U,A),O.subtractToRef(U,e),O.subtractToRef(K,z);const E=A.length(),u=e.length(),b=z.length();if(E<m.d||u<m.d||b<m.d)return X.m(U),v.Distance(C,U);C.subtractToRef(U,p),v.CrossToRef(A,e,j);const Q=j.length();if(Q<m.d)return X.m(U),v.Distance(C,U);j.normalizeFromLength(Q);let V=p.length();if(V<m.d)return X.m(U),0;p.normalizeFromLength(V);const f=v.Dot(j,p),Z=F.bU[5],P=F.bU[6];Z.m(j).scaleInPlace(-V*f),P.m(C).addInPlace(Z);const H=F.bU[4],d=F.bU[5],T=F.bU[7],y=F.bU[8];H.m(A).scaleInPlace(1/E),y.m(e).scaleInPlace(1/u),H.addInPlace(y).scaleInPlace(-1),d.m(A).scaleInPlace(-1/E),y.m(z).scaleInPlace(1/b),d.addInPlace(y).scaleInPlace(-1),T.m(z).scaleInPlace(-1/b),y.m(e).scaleInPlace(-1/u),T.addInPlace(y).scaleInPlace(-1);const a=F.bU[9];let r;a.m(P).zp(U),v.CrossToRef(H,a,y),r=v.Dot(y,j);const i=r;a.m(P).zp(K),v.CrossToRef(d,a,y),r=v.Dot(y,j);const D=r;a.m(P).zp(O),v.CrossToRef(T,a,y),r=v.Dot(y,j);const l=r,G=F.bU[10];let J,o;i>0&&D<0?(G.m(A),J=U,o=K):D>0&&l<0?(G.m(z),J=K,o=O):(G.m(e).scaleInPlace(-1),J=O,o=U);const B=F.bU[9],k=F.bU[4];J.subtractToRef(P,y),o.subtractToRef(P,B),v.CrossToRef(y,B,k);if(!(v.Dot(k,j)<0))return X.m(P),Math.abs(V*f);const w=F.bU[5];v.CrossToRef(G,k,w),w.normalize();const h=F.bU[9];h.m(J).zp(P);const c=h.length();if(c<m.d)return X.m(J),v.Distance(C,J);h.normalizeFromLength(c);const N=v.Dot(w,h),g=F.bU[7];g.m(P).addInPlace(w.scaleInPlace(c*N)),y.m(g).zp(J),V=G.length(),G.normalizeFromLength(V);let M=v.Dot(y,G)/Math.max(V,m.d);return M=(0,t.Clamp)(M,0,1),g.m(J).addInPlace(G.scaleInPlace(M*V)),X.m(g),v.Distance(C,g)}static Center(C,U){return v.CenterToRef(C,U,v.Zero())}static CenterToRef(C,U,K){return K.Ee((C._x+U._x)/2,(C._y+U._y)/2,(C._z+U._z)/2)}static RotationFromAxis(C,U,K){const m=new v;return v.RotationFromAxisToRef(C,U,K,m),m}static RotationFromAxisToRef(C,U,K,m){const O=F.Quaternion[0];return V.RotationQuaternionFromAxisToRef(C,U,K,O),O.toEulerAnglesToRef(m),m}}v._V8PerformanceHack=new v(.5,.5,.5),v._UpReadOnly=v.Up(),v._DownReadOnly=v.Down(),v._LeftHandedForwardReadOnly=v.Forward(!1),v._RightHandedForwardReadOnly=v.Forward(!0),v._LeftHandedBackwardReadOnly=v.Backward(!1),v._RightHandedBackwardReadOnly=v.Backward(!0),v._RightReadOnly=v.Right(),v._LeftReadOnly=v.Left(),v._ZeroReadOnly=v.Zero(),v._OneReadOnly=v.One(),Object.defineProperties(v.prototype,{dimension:{value:[3]},rank:{value:1}});class Q{get x(){return this._x}set x(C){this._x=C,this._isDirty=!0}get y(){return this._y}set y(C){this._y=C,this._isDirty=!0}get z(){return this._z}set z(C){this._z=C,this._isDirty=!0}get w(){return this._w}set w(C){this._w=C,this._isDirty=!0}constructor(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=C,this._y=U,this._z=K,this._w=m}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let C=u(this._x);return C=397*C^u(this._y),C=397*C^u(this._z),C=397*C^u(this._w),C}Oe(){return[this._x,this._y,this._z,this._w]}toArray(C,U){return void 0===U&&(U=0),C[U]=this._x,C[U+1]=this._y,C[U+2]=this._z,C[U+3]=this._w,this}uK(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(C,U,this),this}addInPlace(C){return this.x+=C._x,this.y+=C._y,this.z+=C._z,this.w+=C._w,this}addInPlaceFromFloats(C,U,K,m){return this.x+=C,this.y+=U,this.z+=K,this.w+=m,this}add(C){return new Q(this._x+C.x,this._y+C.y,this._z+C.z,this._w+C.w)}addToRef(C,U){return U.x=this._x+C.x,U.y=this._y+C.y,U.z=this._z+C.z,U.w=this._w+C.w,U}zp(C){return this.x-=C.x,this.y-=C.y,this.z-=C.z,this.w-=C.w,this}vU(C){return new Q(this._x-C.x,this._y-C.y,this._z-C.z,this._w-C.w)}subtractToRef(C,U){return U.x=this._x-C.x,U.y=this._y-C.y,U.z=this._z-C.z,U.w=this._w-C.w,U}subtractFromFloats(C,U,K,m){return new Q(this._x-C,this._y-U,this._z-K,this._w-m)}subtractFromFloatsToRef(C,U,K,m,O){return O.x=this._x-C,O.y=this._y-U,O.z=this._z-K,O.w=this._w-m,O}negate(){return new Q(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(C){return C.x=-this._x,C.y=-this._y,C.z=-this._z,C.w=-this._w,C}scaleInPlace(C){return this.x*=C,this.y*=C,this.z*=C,this.w*=C,this}scale(C){return new Q(this._x*C,this._y*C,this._z*C,this._w*C)}scaleToRef(C,U){return U.x=this._x*C,U.y=this._y*C,U.z=this._z*C,U.w=this._w*C,U}scaleAndAddToRef(C,U){return U.x+=this._x*C,U.y+=this._y*C,U.z+=this._z*C,U.w+=this._w*C,U}equals(C){return C&&this._x===C.x&&this._y===C.y&&this._z===C.z&&this._w===C.w}equalsWithEpsilon(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m.d;return C&&(0,t.WithinEpsilon)(this._x,C.x,U)&&(0,t.WithinEpsilon)(this._y,C.y,U)&&(0,t.WithinEpsilon)(this._z,C.z,U)&&(0,t.WithinEpsilon)(this._w,C.w,U)}equalsToFloats(C,U,K,m){return this._x===C&&this._y===U&&this._z===K&&this._w===m}multiplyInPlace(C){return this.x*=C.x,this.y*=C.y,this.z*=C.z,this.w*=C.w,this}multiply(C){return new Q(this._x*C.x,this._y*C.y,this._z*C.z,this._w*C.w)}multiplyToRef(C,U){return U.x=this._x*C.x,U.y=this._y*C.y,U.z=this._z*C.z,U.w=this._w*C.w,U}multiplyByFloats(C,U,K,m){return new Q(this._x*C,this._y*U,this._z*K,this._w*m)}divide(C){return new Q(this._x/C.x,this._y/C.y,this._z/C.z,this._w/C.w)}divideToRef(C,U){return U.x=this._x/C.x,U.y=this._y/C.y,U.z=this._z/C.z,U.w=this._w/C.w,U}divideInPlace(C){return this.divideToRef(C,this)}minimizeInPlace(C){return C.x<this._x&&(this.x=C.x),C.y<this._y&&(this.y=C.y),C.z<this._z&&(this.z=C.z),C.w<this._w&&(this.w=C.w),this}maximizeInPlace(C){return C.x>this._x&&(this.x=C.x),C.y>this._y&&(this.y=C.y),C.z>this._z&&(this.z=C.z),C.w>this._w&&(this.w=C.w),this}minimizeInPlaceFromFloats(C,U,K,m){return this.x=Math.min(C,this._x),this.y=Math.min(U,this._y),this.z=Math.min(K,this._z),this.w=Math.min(m,this._w),this}maximizeInPlaceFromFloats(C,U,K,m){return this.x=Math.max(C,this._x),this.y=Math.max(U,this._y),this.z=Math.max(K,this._z),this.w=Math.max(m,this._w),this}floorToRef(C){return C.x=Math.floor(this._x),C.y=Math.floor(this._y),C.z=Math.floor(this._z),C.w=Math.floor(this._w),C}floor(){return new Q(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(C){return C.x=this._x-Math.floor(this._x),C.y=this._y-Math.floor(this._y),C.z=this._z-Math.floor(this._z),C.w=this._w-Math.floor(this._w),C}fract(){return new Q(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(C){return 0===C||1===C?this:this.scaleInPlace(1/C)}normalizeToNew(){return this.normalizeToRef(new Q)}normalizeToRef(C){const U=this.length();return 0===U||1===U?(C.x=this._x,C.y=this._y,C.z=this._z,C.w=this._w,C):this.scaleToRef(1/U,C)}toVector3(){return new v(this._x,this._y,this._z)}clone(){return new Q(this._x,this._y,this._z,this._w)}m(C){return this.x=C.x,this.y=C.y,this.z=C.z,this.w=C.w,this}Ee(C,U,K,m){return this.x=C,this.y=U,this.z=K,this.w=m,this}set(C,U,K,m){return this.Ee(C,U,K,m)}be(C){return this.x=this.y=this.z=this.w=C,this}dot(C){return this._x*C.x+this._y*C.y+this._z*C.z+this._w*C.w}static FU(C,U){return U||(U=0),new Q(C[U],C[U+1],C[U+2],C[U+3])}static FromArrayToRef(C,U,K){return K.x=C[U],K.y=C[U+1],K.z=C[U+2],K.w=C[U+3],K}static FromFloatArrayToRef(C,U,K){return Q.FromArrayToRef(C,U,K),K}static FromFloatsToRef(C,U,K,m,O){return O.x=C,O.y=U,O.z=K,O.w=m,O}static Zero(){return new Q(0,0,0,0)}static One(){return new Q(1,1,1,1)}static Random(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Q((0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U))}static RandomToRef(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,K=arguments.length>2?arguments[2]:void 0;return K.x=(0,t.RandomRange)(C,U),K.y=(0,t.RandomRange)(C,U),K.z=(0,t.RandomRange)(C,U),K.w=(0,t.RandomRange)(C,U),K}static Clamp(C,U,K){return Q.ClampToRef(C,U,K,new Q)}static ClampToRef(C,U,K,m){return m.x=(0,t.Clamp)(C.x,U.x,K.x),m.y=(0,t.Clamp)(C.y,U.y,K.y),m.z=(0,t.Clamp)(C.z,U.z,K.z),m.w=(0,t.Clamp)(C.w,U.w,K.w),m}static CheckExtends(C,U,K){U.minimizeInPlace(C),K.maximizeInPlace(C)}static get ZeroReadOnly(){return Q._ZeroReadOnly}static Normalize(C){return Q.NormalizeToRef(C,new Q)}static NormalizeToRef(C,U){return C.normalizeToRef(U),U}static Minimize(C,U){const K=new Q;return K.m(C),K.minimizeInPlace(U),K}static Maximize(C,U){const K=new Q;return K.m(C),K.maximizeInPlace(U),K}static Distance(C,U){return Math.sqrt(Q.DistanceSquared(C,U))}static DistanceSquared(C,U){const K=C.x-U.x,m=C.y-U.y,O=C.z-U.z,X=C.w-U.w;return K*K+m*m+O*O+X*X}static Center(C,U){return Q.CenterToRef(C,U,new Q)}static CenterToRef(C,U,K){return K.x=(C.x+U.x)/2,K.y=(C.y+U.y)/2,K.z=(C.z+U.z)/2,K.w=(C.w+U.w)/2,K}static TransformCoordinates(C,U){return Q.TransformCoordinatesToRef(C,U,new Q)}static TransformCoordinatesToRef(C,U,K){return Q.TransformCoordinatesFromFloatsToRef(C._x,C._y,C._z,U,K),K}static TransformCoordinatesFromFloatsToRef(C,U,K,m,O){const X=m.m,A=C*X[0]+U*X[4]+K*X[8]+X[12],e=C*X[1]+U*X[5]+K*X[9]+X[13],t=C*X[2]+U*X[6]+K*X[10]+X[14],z=C*X[3]+U*X[7]+K*X[11]+X[15];return O.x=A,O.y=e,O.z=t,O.w=z,O}static TransformNormal(C,U){return Q.TransformNormalToRef(C,U,new Q)}static TransformNormalToRef(C,U,K){const m=U.m,O=C.x*m[0]+C.y*m[4]+C.z*m[8],X=C.x*m[1]+C.y*m[5]+C.z*m[9],A=C.x*m[2]+C.y*m[6]+C.z*m[10];return K.x=O,K.y=X,K.z=A,K.w=C.w,K}static TransformNormalFromFloatsToRef(C,U,K,m,O,X){const A=O.m;return X.x=C*A[0]+U*A[4]+K*A[8],X.y=C*A[1]+U*A[5]+K*A[9],X.z=C*A[2]+U*A[6]+K*A[10],X.w=m,X}static FromVector3(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Q(C._x,C._y,C._z,U)}static Dot(C,U){return C.x*U.x+C.y*U.y+C.z*U.z+C.w*U.w}}Q._V8PerformanceHack=new Q(.5,.5,.5,.5),Q._ZeroReadOnly=Q.Zero(),Object.defineProperties(Q.prototype,{dimension:{value:[4]},rank:{value:1}});class V{get x(){return this._x}set x(C){this._x=C,this._isDirty=!0}get y(){return this._y}set y(C){this._y=C,this._isDirty=!0}get z(){return this._z}set z(C){this._z=C,this._isDirty=!0}get w(){return this._w}set w(C){this._w=C,this._isDirty=!0}constructor(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=C,this._y=U,this._z=K,this._w=m}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let C=u(this._x);return C=397*C^u(this._y),C=397*C^u(this._z),C=397*C^u(this._w),C}Oe(){return[this._x,this._y,this._z,this._w]}toArray(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C[U]=this._x,C[U+1]=this._y,C[U+2]=this._z,C[U+3]=this._w,this}uK(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V.FromArrayToRef(C,U,this)}equals(C){return C&&this._x===C._x&&this._y===C._y&&this._z===C._z&&this._w===C._w}equalsWithEpsilon(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m.d;return C&&(0,t.WithinEpsilon)(this._x,C._x,U)&&(0,t.WithinEpsilon)(this._y,C._y,U)&&(0,t.WithinEpsilon)(this._z,C._z,U)&&(0,t.WithinEpsilon)(this._w,C._w,U)}isApprox(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m.d;return C&&((0,t.WithinEpsilon)(this._x,C._x,U)&&(0,t.WithinEpsilon)(this._y,C._y,U)&&(0,t.WithinEpsilon)(this._z,C._z,U)&&(0,t.WithinEpsilon)(this._w,C._w,U)||(0,t.WithinEpsilon)(this._x,-C._x,U)&&(0,t.WithinEpsilon)(this._y,-C._y,U)&&(0,t.WithinEpsilon)(this._z,-C._z,U)&&(0,t.WithinEpsilon)(this._w,-C._w,U))}clone(){return new V(this._x,this._y,this._z,this._w)}m(C){return this._x=C._x,this._y=C._y,this._z=C._z,this._w=C._w,this._isDirty=!0,this}Ee(C,U,K,m){return this._x=C,this._y=U,this._z=K,this._w=m,this._isDirty=!0,this}set(C,U,K,m){return this.Ee(C,U,K,m)}be(C){return this.Ee(C,C,C,C)}add(C){return new V(this._x+C._x,this._y+C._y,this._z+C._z,this._w+C._w)}addInPlace(C){return this._x+=C._x,this._y+=C._y,this._z+=C._z,this._w+=C._w,this._isDirty=!0,this}addToRef(C,U){return U._x=this._x+C._x,U._y=this._y+C._y,U._z=this._z+C._z,U._w=this._w+C._w,U._isDirty=!0,U}addInPlaceFromFloats(C,U,K,m){return this._x+=C,this._y+=U,this._z+=K,this._w+=m,this._isDirty=!0,this}subtractToRef(C,U){return U._x=this._x-C._x,U._y=this._y-C._y,U._z=this._z-C._z,U._w=this._w-C._w,U._isDirty=!0,U}subtractFromFloats(C,U,K,m){return this.subtractFromFloatsToRef(C,U,K,m,new V)}subtractFromFloatsToRef(C,U,K,m,O){return O._x=this._x-C,O._y=this._y-U,O._z=this._z-K,O._w=this._w-m,O._isDirty=!0,O}vU(C){return new V(this._x-C._x,this._y-C._y,this._z-C._z,this._w-C._w)}zp(C){return this._x-=C._x,this._y-=C._y,this._z-=C._z,this._w-=C._w,this._isDirty=!0,this}scale(C){return new V(this._x*C,this._y*C,this._z*C,this._w*C)}scaleToRef(C,U){return U._x=this._x*C,U._y=this._y*C,U._z=this._z*C,U._w=this._w*C,U._isDirty=!0,U}scaleInPlace(C){return this._x*=C,this._y*=C,this._z*=C,this._w*=C,this._isDirty=!0,this}scaleAndAddToRef(C,U){return U._x+=this._x*C,U._y+=this._y*C,U._z+=this._z*C,U._w+=this._w*C,U._isDirty=!0,U}multiply(C){const U=new V(0,0,0,1);return this.multiplyToRef(C,U),U}multiplyToRef(C,U){const K=this._x*C._w+this._y*C._z-this._z*C._y+this._w*C._x,m=-this._x*C._z+this._y*C._w+this._z*C._x+this._w*C._y,O=this._x*C._y-this._y*C._x+this._z*C._w+this._w*C._z,X=-this._x*C._x-this._y*C._y-this._z*C._z+this._w*C._w;return U.Ee(K,m,O,X),U}multiplyInPlace(C){return this.multiplyToRef(C,this)}multiplyByFloats(C,U,K,m){return this._x*=C,this._y*=U,this._z*=K,this._w*=m,this._isDirty=!0,this}divide(C){throw new ReferenceError("Can not divide a quaternion")}divideToRef(C,U){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(C){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new V)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(C){return C._x=-this._x,C._y=-this._y,C._z=-this._z,C._w=-this._w,C._isDirty=!0,C}equalsToFloats(C,U,K,m){return this._x===C&&this._y===U&&this._z===K&&this._w===m}floorToRef(C){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(C){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(C){return C.Ee(-this._x,-this._y,-this._z,this._w),C}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new V(-this._x,-this._y,-this._z,this._w)}invert(){const C=this.conjugate(),U=this.lengthSquared();return 0==U||1==U||C.scaleInPlace(1/U),C}invertInPlace(){this.conjugateInPlace();const C=this.lengthSquared();return 0==C||1==C||this.scaleInPlace(1/C),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(C){return 0===C||1===C?this:this.scaleInPlace(1/C)}normalizeToNew(){const C=new V(0,0,0,1);return this.normalizeToRef(C),C}normalizeToRef(C){const U=this.length();return 0===U||1===U?C.Ee(this._x,this._y,this._z,this._w):this.scaleToRef(1/U,C)}toEulerAngles(){const C=v.Zero();return this.toEulerAnglesToRef(C),C}toEulerAnglesToRef(C){const U=this._z,K=this._x,m=this._y,O=this._w,X=m*U-K*O,A=.4999999;if(X<-A)C._y=2*Math.atan2(m,O),C._x=Math.PI/2,C._z=0,C._isDirty=!0;else if(X>A)C._y=2*Math.atan2(m,O),C._x=-Math.PI/2,C._z=0,C._isDirty=!0;else{const A=O*O,e=U*U,t=K*K,z=m*m;C._z=Math.atan2(2*(K*m+U*O),-e-t+z+A),C._x=Math.asin(-2*X),C._y=Math.atan2(2*(U*K+m*O),e-t-z+A),C._isDirty=!0}return C}toAlphaBetaGammaToRef(C){const U=this._z,K=this._x,m=this._y,O=this._w,X=Math.sqrt(K*K+m*m),A=Math.sqrt(U*U+O*O),e=2*Math.atan2(X,A),t=2*Math.atan2(U,O),z=2*Math.atan2(m,K),j=(t+z)/2,p=(t-z)/2;return C.set(p,e,j),C}toRotationMatrix(C){return f.FromQuaternionToRef(this,C),C}fromRotationMatrix(C){return V.FromRotationMatrixToRef(C,this),this}dot(C){return this._x*C._x+this._y*C._y+this._z*C._z+this._w*C._w}toAxisAngle(){const C=v.Zero();return{axis:C,angle:this.toAxisAngleToRef(C)}}toAxisAngleToRef(C){let U=0;const K=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),m=this._w;return K>0?(U=2*Math.atan2(K,m),C.set(this._x/K,this._y/K,this._z/K)):(U=0,C.set(1,0,0)),U}static FromRotationMatrix(C){const U=new V;return V.FromRotationMatrixToRef(C,U),U}static FromRotationMatrixToRef(C,U){const K=C.m,m=K[0],O=K[4],X=K[8],A=K[1],e=K[5],t=K[9],z=K[2],j=K[6],p=K[10],E=m+e+p;let u;return E>0?(u=.5/Math.sqrt(E+1),U._w=.25/u,U._x=(j-t)*u,U._y=(X-z)*u,U._z=(A-O)*u,U._isDirty=!0):m>e&&m>p?(u=2*Math.sqrt(1+m-e-p),U._w=(j-t)/u,U._x=.25*u,U._y=(O+A)/u,U._z=(X+z)/u,U._isDirty=!0):e>p?(u=2*Math.sqrt(1+e-m-p),U._w=(X-z)/u,U._x=(O+A)/u,U._y=.25*u,U._z=(t+j)/u,U._isDirty=!0):(u=2*Math.sqrt(1+p-m-e),U._w=(A-O)/u,U._x=(X+z)/u,U._y=(t+j)/u,U._z=.25*u,U._isDirty=!0),U}static Dot(C,U){return C._x*U._x+C._y*U._y+C._z*U._z+C._w*U._w}static AreClose(C,U){let K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const m=V.Dot(C,U);return 1-m*m<=K}static SmoothToRef(C,U,K,m,O){let X=0===m?1:K/m;return X=(0,t.Clamp)(X,0,1),V.SlerpToRef(C,U,X,O),O}static Zero(){return new V(0,0,0,0)}static Inverse(C){return new V(-C._x,-C._y,-C._z,C._w)}static InverseToRef(C,U){return U.set(-C._x,-C._y,-C._z,C._w),U}static Identity(){return new V(0,0,0,1)}static IsIdentity(C){return C&&0===C._x&&0===C._y&&0===C._z&&1===C._w}static RotationAxis(C,U){return V.RotationAxisToRef(C,U,new V)}static RotationAxisToRef(C,U,K){K._w=Math.cos(U/2);const m=Math.sin(U/2)/C.length();return K._x=C._x*m,K._y=C._y*m,K._z=C._z*m,K._isDirty=!0,K}static FU(C,U){return U||(U=0),new V(C[U],C[U+1],C[U+2],C[U+3])}static FromArrayToRef(C,U,K){return K._x=C[U],K._y=C[U+1],K._z=C[U+2],K._w=C[U+3],K._isDirty=!0,K}static FromFloatsToRef(C,U,K,m,O){return O.Ee(C,U,K,m),O}static FromEulerAngles(C,U,K){const m=new V;return V.RotationYawPitchRollToRef(U,C,K,m),m}static FromEulerAnglesToRef(C,U,K,m){return V.RotationYawPitchRollToRef(U,C,K,m),m}static FromEulerVector(C){const U=new V;return V.RotationYawPitchRollToRef(C._y,C._x,C._z,U),U}static FromEulerVectorToRef(C,U){return V.RotationYawPitchRollToRef(C._y,C._x,C._z,U),U}static FromUnitVectorsToRef(C,U,K){let O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:m.d;const X=v.Dot(C,U)+1;return X<O?Math.abs(C.x)>Math.abs(C.z)?K.set(-C.y,C.x,0,0):K.set(0,-C.z,C.y,0):(v.CrossToRef(C,U,Z.bU[0]),K.set(Z.bU[0].x,Z.bU[0].y,Z.bU[0].z,X)),K.normalize()}static RotationYawPitchRoll(C,U,K){const m=new V;return V.RotationYawPitchRollToRef(C,U,K,m),m}static RotationYawPitchRollToRef(C,U,K,m){const O=.5*K,X=.5*U,A=.5*C,e=Math.sin(O),t=Math.cos(O),z=Math.sin(X),j=Math.cos(X),p=Math.sin(A),E=Math.cos(A);return m._x=E*z*t+p*j*e,m._y=p*j*t-E*z*e,m._z=E*j*e-p*z*t,m._w=E*j*t+p*z*e,m._isDirty=!0,m}static RotationAlphaBetaGamma(C,U,K){const m=new V;return V.RotationAlphaBetaGammaToRef(C,U,K,m),m}static RotationAlphaBetaGammaToRef(C,U,K,m){const O=.5*(K+C),X=.5*(K-C),A=.5*U;return m._x=Math.cos(X)*Math.sin(A),m._y=Math.sin(X)*Math.sin(A),m._z=Math.sin(O)*Math.cos(A),m._w=Math.cos(O)*Math.cos(A),m._isDirty=!0,m}static RotationQuaternionFromAxis(C,U,K){const m=new V(0,0,0,0);return V.RotationQuaternionFromAxisToRef(C,U,K,m),m}static RotationQuaternionFromAxisToRef(C,U,K,m){const O=F.Matrix[0];return C=C.normalizeToRef(F.bU[0]),U=U.normalizeToRef(F.bU[1]),K=K.normalizeToRef(F.bU[2]),f.FromXYZAxesToRef(C,U,K,O),V.FromRotationMatrixToRef(O,m),m}static FromLookDirectionLH(C,U){const K=new V;return V.FromLookDirectionLHToRef(C,U,K),K}static FromLookDirectionLHToRef(C,U,K){const m=F.Matrix[0];return f.LookDirectionLHToRef(C,U,m),V.FromRotationMatrixToRef(m,K),K}static FromLookDirectionRH(C,U){const K=new V;return V.FromLookDirectionRHToRef(C,U,K),K}static FromLookDirectionRHToRef(C,U,K){const m=F.Matrix[0];return f.LookDirectionRHToRef(C,U,m),V.FromRotationMatrixToRef(m,K)}static Slerp(C,U,K){const m=V.Identity();return V.SlerpToRef(C,U,K,m),m}static SlerpToRef(C,U,K,m){let O,X,A=C._x*U._x+C._y*U._y+C._z*U._z+C._w*U._w,e=!1;if(A<0&&(e=!0,A=-A),A>.999999)X=1-K,O=e?-K:K;else{const C=Math.acos(A),U=1/Math.sin(C);X=Math.sin((1-K)*C)*U,O=e?-Math.sin(K*C)*U:Math.sin(K*C)*U}return m._x=X*C._x+O*U._x,m._y=X*C._y+O*U._y,m._z=X*C._z+O*U._z,m._w=X*C._w+O*U._w,m._isDirty=!0,m}static Hermite(C,U,K,m,O){const X=O*O,A=O*X,e=2*A-3*X+1,t=-2*A+3*X,z=A-2*X+O,j=A-X,p=C._x*e+K._x*t+U._x*z+m._x*j,E=C._y*e+K._y*t+U._y*z+m._y*j,u=C._z*e+K._z*t+U._z*z+m._z*j,b=C._w*e+K._w*t+U._w*z+m._w*j;return new V(p,E,u,b)}static Hermite1stDerivative(C,U,K,m,O){const X=new V;return this.Hermite1stDerivativeToRef(C,U,K,m,O,X),X}static Hermite1stDerivativeToRef(C,U,K,m,O,X){const A=O*O;return X._x=6*(A-O)*C._x+(3*A-4*O+1)*U._x+6*(-A+O)*K._x+(3*A-2*O)*m._x,X._y=6*(A-O)*C._y+(3*A-4*O+1)*U._y+6*(-A+O)*K._y+(3*A-2*O)*m._y,X._z=6*(A-O)*C._z+(3*A-4*O+1)*U._z+6*(-A+O)*K._z+(3*A-2*O)*m._z,X._w=6*(A-O)*C._w+(3*A-4*O+1)*U._w+6*(-A+O)*K._w+(3*A-2*O)*m._w,X._isDirty=!0,X}static Normalize(C){const U=V.Zero();return V.NormalizeToRef(C,U),U}static NormalizeToRef(C,U){return C.normalizeToRef(U),U}static Clamp(C,U,K){const m=new V;return V.ClampToRef(C,U,K,m),m}static ClampToRef(C,U,K,m){return m.Ee((0,t.Clamp)(C.x,U.x,K.x),(0,t.Clamp)(C.y,U.y,K.y),(0,t.Clamp)(C.z,U.z,K.z),(0,t.Clamp)(C.w,U.w,K.w))}static Random(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new V((0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U))}static RandomToRef(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Ee((0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U),(0,t.RandomRange)(C,U))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(C,U){return Math.sqrt(V.DistanceSquared(C,U))}static DistanceSquared(C,U){const K=C.x-U.x,m=C.y-U.y,O=C.z-U.z,X=C.w-U.w;return K*K+m*m+O*O+X*X}static Center(C,U){return V.CenterToRef(C,U,V.Zero())}static CenterToRef(C,U,K){return K.Ee((C.x+U.x)/2,(C.y+U.y)/2,(C.z+U.z)/2,(C.w+U.w)/2)}}V._V8PerformanceHack=new V(.5,.5,.5,.5),Object.defineProperties(V.prototype,{dimension:{value:[4]},rank:{value:1}});class f{static get Use64Bits(){return A.d.MatrixUse64Bits}get m(){return this.qA}markAsUpdated(){this.updateFlag=z._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(C){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1],K=arguments.length>2&&void 0!==arguments[2]&&arguments[2],m=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=C,this._isIdentity3x2=C||K,this._isIdentityDirty=!this._isIdentity&&U,this._isIdentity3x2Dirty=!this._isIdentity3x2&&m}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,A.d.MatrixTrackPrecisionChange&&A.d.MatrixTrackedMatrices.push(this),this.qA=new A.d.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const C=this.qA;this._isIdentity=1===C[0]&&0===C[1]&&0===C[2]&&0===C[3]&&0===C[4]&&1===C[5]&&0===C[6]&&0===C[7]&&0===C[8]&&0===C[9]&&1===C[10]&&0===C[11]&&0===C[12]&&0===C[13]&&0===C[14]&&1===C[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.qA[0]||1!==this.qA[5]||1!==this.qA[15]||0!==this.qA[1]||0!==this.qA[2]||0!==this.qA[3]||0!==this.qA[4]||0!==this.qA[6]||0!==this.qA[7]||0!==this.qA[8]||0!==this.qA[9]||0!==this.qA[10]||0!==this.qA[11]||0!==this.qA[12]||0!==this.qA[13]||0!==this.qA[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const C=this.qA,U=C[0],K=C[1],m=C[2],O=C[3],X=C[4],A=C[5],e=C[6],t=C[7],z=C[8],j=C[9],p=C[10],E=C[11],u=C[12],b=C[13],v=C[14],Q=C[15],V=p*Q-v*E,f=j*Q-b*E,F=j*v-b*p,Z=z*Q-u*E,P=z*v-p*u,H=z*b-u*j;return U*+(A*V-e*f+t*F)+K*-(X*V-e*Z+t*P)+m*+(X*f-A*Z+t*H)+O*-(X*F-A*P+e*H)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!C)return this.qA;const K=this.qA;for(let m=0;m<16;m++)C[U+m]=K[m];return this}Oe(){return this.qA}uK(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f.FromArrayToRef(C,U,this)}Ee(){for(var C=arguments.length,U=new Array(C),K=0;K<C;K++)U[K]=arguments[K];return f.FromArrayToRef(U,0,this)}set(){const C=this.qA;for(let U=0;U<16;U++)C[U]=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}be(C){const U=this.qA;for(let K=0;K<16;K++)U[K]=C;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return f.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(C){const U=new f;return this.addToRef(C,U),U}addToRef(C,U){const K=this.qA,m=U.qA,O=C.m;for(let X=0;X<16;X++)m[X]=K[X]+O[X];return U.markAsUpdated(),U}addToSelf(C){const U=this.qA,K=C.m;return U[0]+=K[0],U[1]+=K[1],U[2]+=K[2],U[3]+=K[3],U[4]+=K[4],U[5]+=K[5],U[6]+=K[6],U[7]+=K[7],U[8]+=K[8],U[9]+=K[9],U[10]+=K[10],U[11]+=K[11],U[12]+=K[12],U[13]+=K[13],U[14]+=K[14],U[15]+=K[15],this.markAsUpdated(),this}addInPlace(C){const U=this.qA,K=C.m;for(let m=0;m<16;m++)U[m]+=K[m];return this.markAsUpdated(),this}addInPlaceFromFloats(){const C=this.qA;for(let U=0;U<16;U++)C[U]+=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}vU(C){const U=this.qA,K=C.m;for(let m=0;m<16;m++)U[m]-=K[m];return this.markAsUpdated(),this}subtractToRef(C,U){const K=this.qA,m=C.m,O=U.qA;for(let X=0;X<16;X++)O[X]=K[X]-m[X];return U.markAsUpdated(),U}zp(C){const U=this.qA,K=C.m;for(let m=0;m<16;m++)U[m]-=K[m];return this.markAsUpdated(),this}subtractFromFloats(){for(var C=arguments.length,U=new Array(C),K=0;K<C;K++)U[K]=arguments[K];return this.subtractFromFloatsToRef(...U,new f)}subtractFromFloatsToRef(){for(var C=arguments.length,U=new Array(C),K=0;K<C;K++)U[K]=arguments[K];const m=U.pop(),O=this.qA,X=m.qA,A=U;for(let e=0;e<16;e++)X[e]=O[e]-A[e];return m.markAsUpdated(),m}invertToRef(C){return!0===this._isIdentity?(f.IdentityToRef(C),C):(E(this,C.Oe())?C.markAsUpdated():C.m(this),C)}addAtIndex(C,U){return this.qA[C]+=U,this.markAsUpdated(),this}multiplyAtIndex(C,U){return this.qA[C]*=U,this.markAsUpdated(),this}setTranslationFromFloats(C,U,K){return this.qA[12]=C,this.qA[13]=U,this.qA[14]=K,this.markAsUpdated(),this}addTranslationFromFloats(C,U,K){return this.qA[12]+=C,this.qA[13]+=U,this.qA[14]+=K,this.markAsUpdated(),this}setTranslation(C){return this.setTranslationFromFloats(C._x,C._y,C._z)}getTranslation(){return new v(this.qA[12],this.qA[13],this.qA[14])}getTranslationToRef(C){return C.x=this.qA[12],C.y=this.qA[13],C.z=this.qA[14],C}removeRotationAndScaling(){const C=this.m;return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,C[12],C[13],C[14],C[15],this),this._updateIdentityStatus(0===C[12]&&0===C[13]&&0===C[14]&&1===C[15]),this}m(C){C.copyToArray(this.qA);const U=C;return this.updateFlag=U.updateFlag,this._updateIdentityStatus(U._isIdentity,U._isIdentityDirty,U._isIdentity3x2,U._isIdentity3x2Dirty),this}copyToArray(C){return p(this,C,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(C){const U=new f;return this.multiplyToRef(C,U),U}multiplyInPlace(C){const U=this.qA,K=C.m;for(let m=0;m<16;m++)U[m]*=K[m];return this.markAsUpdated(),this}multiplyByFloats(){const C=this.qA;for(let U=0;U<16;U++)C[U]*=U<0||arguments.length<=U?void 0:arguments[U];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var C=arguments.length,U=new Array(C),K=0;K<C;K++)U[K]=arguments[K];const m=U.pop(),O=this.qA,X=m.qA,A=U;for(let e=0;e<16;e++)X[e]=O[e]*A[e];return m.markAsUpdated(),m}multiplyToRef(C,U){return this._isIdentity?(U.m(C),U):C._isIdentity?(U.m(this),U):(this.multiplyToArray(C,U.qA,0),U.markAsUpdated(),U)}multiplyToArray(C,U,K){return j(this,C,U,K),this}divide(C){return this.divideToRef(C,new f)}divideToRef(C,U){const K=this.qA,m=C.m,O=U.qA;for(let X=0;X<16;X++)O[X]=K[X]/m[X];return U.markAsUpdated(),U}divideInPlace(C){const U=this.qA,K=C.m;for(let m=0;m<16;m++)U[m]/=K[m];return this.markAsUpdated(),this}minimizeInPlace(C){const U=this.qA,K=C.m;for(let m=0;m<16;m++)U[m]=Math.min(U[m],K[m]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const C=this.qA;for(let U=0;U<16;U++)C[U]=Math.min(C[U],U<0||arguments.length<=U?void 0:arguments[U]);return this.markAsUpdated(),this}maximizeInPlace(C){const U=this.qA,K=C.m;for(let m=0;m<16;m++)U[m]=Math.min(U[m],K[m]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const C=this.qA;for(let U=0;U<16;U++)C[U]=Math.min(C[U],U<0||arguments.length<=U?void 0:arguments[U]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new f)}negateInPlace(){const C=this.qA;for(let U=0;U<16;U++)C[U]=-C[U];return this.markAsUpdated(),this}negateToRef(C){const U=this.qA,K=C.qA;for(let m=0;m<16;m++)K[m]=-U[m];return C.markAsUpdated(),C}equals(C){const U=C;if(!U)return!1;if((this._isIdentity||U._isIdentity)&&!this._isIdentityDirty&&!U._isIdentityDirty)return this._isIdentity&&U._isIdentity;const K=this.m,m=U.m;return K[0]===m[0]&&K[1]===m[1]&&K[2]===m[2]&&K[3]===m[3]&&K[4]===m[4]&&K[5]===m[5]&&K[6]===m[6]&&K[7]===m[7]&&K[8]===m[8]&&K[9]===m[9]&&K[10]===m[10]&&K[11]===m[11]&&K[12]===m[12]&&K[13]===m[13]&&K[14]===m[14]&&K[15]===m[15]}equalsWithEpsilon(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const K=this.qA,m=C.m;for(let O=0;O<16;O++)if(!(0,t.WithinEpsilon)(K[O],m[O],U))return!1;return!0}equalsToFloats(){const C=this.qA;for(let U=0;U<16;U++)if(C[U]!=(U<0||arguments.length<=U?void 0:arguments[U]))return!1;return!0}floor(){return this.floorToRef(new f)}floorToRef(C){const U=this.qA,K=C.qA;for(let m=0;m<16;m++)K[m]=Math.floor(U[m]);return C.markAsUpdated(),C}fract(){return this.fractToRef(new f)}fractToRef(C){const U=this.qA,K=C.qA;for(let m=0;m<16;m++)K[m]=U[m]-Math.floor(U[m]);return C.markAsUpdated(),C}clone(){const C=new f;return C.m(this),C}getClassName(){return"Matrix"}getHashCode(){let C=u(this.qA[0]);for(let U=1;U<16;U++)C=397*C^u(this.qA[U]);return C}decomposeToTransformNode(C){return C.rotationQuaternion=C.rotationQuaternion||new V,this.decompose(C.ue,C.rotationQuaternion,C.position)}decompose(C,U,K,m){let O=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return K&&K.be(0),C&&C.be(1),U&&U.Ee(0,0,0,1),!0;const X=this.qA;if(K&&K.Ee(X[12],X[13],X[14]),(C=C||F.bU[0]).x=Math.sqrt(X[0]*X[0]+X[1]*X[1]+X[2]*X[2]),C.y=Math.sqrt(X[4]*X[4]+X[5]*X[5]+X[6]*X[6]),C.z=Math.sqrt(X[8]*X[8]+X[9]*X[9]+X[10]*X[10]),m){const U=(O?m.absoluteScaling.x:m.ue.x)<0?-1:1,K=(O?m.absoluteScaling.y:m.ue.y)<0?-1:1,X=(O?m.absoluteScaling.z:m.ue.z)<0?-1:1;C.x*=U,C.y*=K,C.z*=X}else this.determinant()<=0&&(C.y*=-1);if(0===C._x||0===C._y||0===C._z)return U&&U.Ee(0,0,0,1),!1;if(U){const K=1/C._x,m=1/C._y,O=1/C._z;f.FromValuesToRef(X[0]*K,X[1]*K,X[2]*K,0,X[4]*m,X[5]*m,X[6]*m,0,X[8]*O,X[9]*O,X[10]*O,0,0,0,0,1,F.Matrix[0]),V.FromRotationMatrixToRef(F.Matrix[0],U)}return!0}getRow(C){if(C<0||C>3)return null;const U=4*C;return new Q(this.qA[U+0],this.qA[U+1],this.qA[U+2],this.qA[U+3])}getRowToRef(C,U){if(C>=0&&C<=3){const K=4*C;U.x=this.qA[K+0],U.y=this.qA[K+1],U.z=this.qA[K+2],U.w=this.qA[K+3]}return U}setRow(C,U){return this.setRowFromFloats(C,U.x,U.y,U.z,U.w)}transpose(){const C=new f;return f.TransposeToRef(this,C),C}transposeToRef(C){return f.TransposeToRef(this,C),C}setRowFromFloats(C,U,K,m,O){if(C<0||C>3)return this;const X=4*C;return this.qA[X+0]=U,this.qA[X+1]=K,this.qA[X+2]=m,this.qA[X+3]=O,this.markAsUpdated(),this}scale(C){const U=new f;return this.scaleToRef(C,U),U}scaleToRef(C,U){for(let K=0;K<16;K++)U.qA[K]=this.qA[K]*C;return U.markAsUpdated(),U}scaleAndAddToRef(C,U){for(let K=0;K<16;K++)U.qA[K]+=this.qA[K]*C;return U.markAsUpdated(),U}scaleInPlace(C){const U=this.qA;for(let K=0;K<16;K++)U[K]*=C;return this.markAsUpdated(),this}toNormalMatrix(C){const U=F.Matrix[0];this.invertToRef(U),U.transposeToRef(C);const K=C.qA;return f.FromValuesToRef(K[0],K[1],K[2],0,K[4],K[5],K[6],0,K[8],K[9],K[10],0,0,0,0,1,C),C}getRotationMatrix(){const C=new f;return this.getRotationMatrixToRef(C),C}getRotationMatrixToRef(C){const U=F.bU[0];if(!this.decompose(U))return f.IdentityToRef(C),C;const K=this.qA,m=1/U._x,O=1/U._y,X=1/U._z;return f.FromValuesToRef(K[0]*m,K[1]*m,K[2]*m,0,K[4]*O,K[5]*O,K[6]*O,0,K[8]*X,K[9]*X,K[10]*X,0,0,0,0,1,C),C}toggleModelMatrixHandInPlace(){const C=this.qA;return C[2]*=-1,C[6]*=-1,C[8]*=-1,C[9]*=-1,C[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const C=this.qA;return C[8]*=-1,C[9]*=-1,C[10]*=-1,C[11]*=-1,this.markAsUpdated(),this}static FU(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const K=new f;return f.FromArrayToRef(C,U,K),K}static FromArrayToRef(C,U,K){for(let m=0;m<16;m++)K.qA[m]=C[m+U];return K.markAsUpdated(),K}static FromFloat32ArrayToRefScaled(C,U,K,m){return m.qA[0]=C[0+U]*K,m.qA[1]=C[1+U]*K,m.qA[2]=C[2+U]*K,m.qA[3]=C[3+U]*K,m.qA[4]=C[4+U]*K,m.qA[5]=C[5+U]*K,m.qA[6]=C[6+U]*K,m.qA[7]=C[7+U]*K,m.qA[8]=C[8+U]*K,m.qA[9]=C[9+U]*K,m.qA[10]=C[10+U]*K,m.qA[11]=C[11+U]*K,m.qA[12]=C[12+U]*K,m.qA[13]=C[13+U]*K,m.qA[14]=C[14+U]*K,m.qA[15]=C[15+U]*K,m.markAsUpdated(),m}static get IdentityReadOnly(){return f._IdentityReadOnly}static FromValuesToRef(C,U,K,m,O,X,A,e,t,z,j,p,E,u,b,v,Q){const V=Q.qA;V[0]=C,V[1]=U,V[2]=K,V[3]=m,V[4]=O,V[5]=X,V[6]=A,V[7]=e,V[8]=t,V[9]=z,V[10]=j,V[11]=p,V[12]=E,V[13]=u,V[14]=b,V[15]=v,Q.markAsUpdated()}static FromValues(C,U,K,m,O,X,A,e,t,z,j,p,E,u,b,v){const Q=new f,V=Q.qA;return V[0]=C,V[1]=U,V[2]=K,V[3]=m,V[4]=O,V[5]=X,V[6]=A,V[7]=e,V[8]=t,V[9]=z,V[10]=j,V[11]=p,V[12]=E,V[13]=u,V[14]=b,V[15]=v,Q.markAsUpdated(),Q}static Compose(C,U,K){const m=new f;return f.ComposeToRef(C,U,K,m),m}static ComposeToRef(C,U,K,m){const O=m.qA,X=U._x,A=U._y,e=U._z,t=U._w,z=X+X,j=A+A,p=e+e,E=X*z,u=X*j,b=X*p,v=A*j,Q=A*p,V=e*p,f=t*z,F=t*j,Z=t*p,P=C._x,H=C._y,d=C._z;return O[0]=(1-(v+V))*P,O[1]=(u+Z)*P,O[2]=(b-F)*P,O[3]=0,O[4]=(u-Z)*H,O[5]=(1-(E+V))*H,O[6]=(Q+f)*H,O[7]=0,O[8]=(b+F)*d,O[9]=(Q-f)*d,O[10]=(1-(E+v))*d,O[11]=0,O[12]=K._x,O[13]=K._y,O[14]=K._z,O[15]=1,m.markAsUpdated(),m}static Identity(){const C=f.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return C._updateIdentityStatus(!0),C}static IdentityToRef(C){return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,C),C._updateIdentityStatus(!0),C}static Zero(){const C=f.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return C._updateIdentityStatus(!1),C}static RotationX(C){const U=new f;return f.RotationXToRef(C,U),U}static Invert(C){const U=new f;return C.invertToRef(U),U}static RotationXToRef(C,U){const K=Math.sin(C),m=Math.cos(C);return f.FromValuesToRef(1,0,0,0,0,m,K,0,0,-K,m,0,0,0,0,1,U),U._updateIdentityStatus(1===m&&0===K),U}static RotationY(C){const U=new f;return f.RotationYToRef(C,U),U}static RotationYToRef(C,U){const K=Math.sin(C),m=Math.cos(C);return f.FromValuesToRef(m,0,-K,0,0,1,0,0,K,0,m,0,0,0,0,1,U),U._updateIdentityStatus(1===m&&0===K),U}static RotationZ(C){const U=new f;return f.RotationZToRef(C,U),U}static RotationZToRef(C,U){const K=Math.sin(C),m=Math.cos(C);return f.FromValuesToRef(m,K,0,0,-K,m,0,0,0,0,1,0,0,0,0,1,U),U._updateIdentityStatus(1===m&&0===K),U}static RotationAxis(C,U){const K=new f;return f.RotationAxisToRef(C,U,K),K}static RotationAxisToRef(C,U,K){const m=Math.sin(-U),O=Math.cos(-U),X=1-O;C=C.normalizeToRef(F.bU[0]);const A=K.qA;return A[0]=C._x*C._x*X+O,A[1]=C._x*C._y*X-C._z*m,A[2]=C._x*C._z*X+C._y*m,A[3]=0,A[4]=C._y*C._x*X+C._z*m,A[5]=C._y*C._y*X+O,A[6]=C._y*C._z*X-C._x*m,A[7]=0,A[8]=C._z*C._x*X-C._y*m,A[9]=C._z*C._y*X+C._x*m,A[10]=C._z*C._z*X+O,A[11]=0,A[12]=0,A[13]=0,A[14]=0,A[15]=1,K.markAsUpdated(),K}static RotationAlignToRef(C,U,K){let O=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const X=v.Dot(U,C),A=K.qA;if(X<-1+m.d)A[0]=-1,A[1]=0,A[2]=0,A[3]=0,A[4]=0,A[5]=O?1:-1,A[6]=0,A[7]=0,A[8]=0,A[9]=0,A[10]=O?-1:1,A[11]=0;else{const K=v.Cross(U,C),m=1/(1+X);A[0]=K._x*K._x*m+X,A[1]=K._y*K._x*m-K._z,A[2]=K._z*K._x*m+K._y,A[3]=0,A[4]=K._x*K._y*m+K._z,A[5]=K._y*K._y*m+X,A[6]=K._z*K._y*m-K._x,A[7]=0,A[8]=K._x*K._z*m-K._y,A[9]=K._y*K._z*m+K._x,A[10]=K._z*K._z*m+X,A[11]=0}return A[12]=0,A[13]=0,A[14]=0,A[15]=1,K.markAsUpdated(),K}static RotationYawPitchRoll(C,U,K){const m=new f;return f.RotationYawPitchRollToRef(C,U,K,m),m}static RotationYawPitchRollToRef(C,U,K,m){return V.RotationYawPitchRollToRef(C,U,K,F.Quaternion[0]),F.Quaternion[0].toRotationMatrix(m),m}static Scaling(C,U,K){const m=new f;return f.ScalingToRef(C,U,K,m),m}static ScalingToRef(C,U,K,m){return f.FromValuesToRef(C,0,0,0,0,U,0,0,0,0,K,0,0,0,0,1,m),m._updateIdentityStatus(1===C&&1===U&&1===K),m}static Translation(C,U,K){const m=new f;return f.TranslationToRef(C,U,K,m),m}static TranslationToRef(C,U,K,m){return f.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,C,U,K,1,m),m._updateIdentityStatus(0===C&&0===U&&0===K),m}static Lerp(C,U,K){const m=new f;return f.LerpToRef(C,U,K,m),m}static LerpToRef(C,U,K,m){const O=m.qA,X=C.m,A=U.m;for(let e=0;e<16;e++)O[e]=X[e]*(1-K)+A[e]*K;return m.markAsUpdated(),m}static DecomposeLerp(C,U,K){const m=new f;return f.DecomposeLerpToRef(C,U,K,m),m}static DecomposeLerpToRef(C,U,K,m){const O=F.bU[0],X=F.Quaternion[0],A=F.bU[1];C.decompose(O,X,A);const e=F.bU[2],t=F.Quaternion[1],z=F.bU[3];U.decompose(e,t,z);const j=F.bU[4];v.LerpToRef(O,e,K,j);const p=F.Quaternion[2];V.SlerpToRef(X,t,K,p);const E=F.bU[5];return v.LerpToRef(A,z,K,E),f.ComposeToRef(j,p,E,m),m}static LookAtLH(C,U,K){const m=new f;return f.LookAtLHToRef(C,U,K,m),m}static LookAtLHToRef(C,U,K,m){const O=F.bU[0],X=F.bU[1],A=F.bU[2];U.subtractToRef(C,A),A.normalize(),v.CrossToRef(K,A,O);const e=O.lengthSquared();0===e?O.x=1:O.normalizeFromLength(Math.sqrt(e)),v.CrossToRef(A,O,X),X.normalize();const t=-v.Dot(O,C),z=-v.Dot(X,C),j=-v.Dot(A,C);return f.FromValuesToRef(O._x,X._x,A._x,0,O._y,X._y,A._y,0,O._z,X._z,A._z,0,t,z,j,1,m),m}static LookAtRH(C,U,K){const m=new f;return f.LookAtRHToRef(C,U,K,m),m}static LookAtRHToRef(C,U,K,m){const O=F.bU[0],X=F.bU[1],A=F.bU[2];C.subtractToRef(U,A),A.normalize(),v.CrossToRef(K,A,O);const e=O.lengthSquared();0===e?O.x=1:O.normalizeFromLength(Math.sqrt(e)),v.CrossToRef(A,O,X),X.normalize();const t=-v.Dot(O,C),z=-v.Dot(X,C),j=-v.Dot(A,C);return f.FromValuesToRef(O._x,X._x,A._x,0,O._y,X._y,A._y,0,O._z,X._z,A._z,0,t,z,j,1,m),m}static LookDirectionLH(C,U){const K=new f;return f.LookDirectionLHToRef(C,U,K),K}static LookDirectionLHToRef(C,U,K){const m=F.bU[0];m.m(C),m.scaleInPlace(-1);const O=F.bU[1];return v.CrossToRef(U,m,O),f.FromValuesToRef(O._x,O._y,O._z,0,U._x,U._y,U._z,0,m._x,m._y,m._z,0,0,0,0,1,K),K}static LookDirectionRH(C,U){const K=new f;return f.LookDirectionRHToRef(C,U,K),K}static LookDirectionRHToRef(C,U,K){const m=F.bU[2];return v.CrossToRef(U,C,m),f.FromValuesToRef(m._x,m._y,m._z,0,U._x,U._y,U._z,0,C._x,C._y,C._z,0,0,0,0,1,K),K}static OrthoLH(C,U,K,m,O){const X=new f;return f.OrthoLHToRef(C,U,K,m,X,O),X}static OrthoLHToRef(C,U,K,m,O,X){const A=2/C,e=2/U,t=2/(m-K),z=-(m+K)/(m-K);return f.FromValuesToRef(A,0,0,0,0,e,0,0,0,0,t,0,0,0,z,1,O),X&&O.multiplyToRef(P,O),O._updateIdentityStatus(1===A&&1===e&&1===t&&0===z),O}static OrthoOffCenterLH(C,U,K,m,O,X,A){const e=new f;return f.OrthoOffCenterLHToRef(C,U,K,m,O,X,e,A),e}static OrthoOffCenterLHToRef(C,U,K,m,O,X,A,e){const t=2/(U-C),z=2/(m-K),j=2/(X-O),p=-(X+O)/(X-O),E=(C+U)/(C-U),u=(m+K)/(K-m);return f.FromValuesToRef(t,0,0,0,0,z,0,0,0,0,j,0,E,u,p,1,A),e&&A.multiplyToRef(P,A),A.markAsUpdated(),A}static ObliqueOffCenterLHToRef(C,U,K,m,O,X,A,e,t,z,j){const p=-A*Math.cos(e),E=-A*Math.sin(e);return f.TranslationToRef(0,0,-t,F.Matrix[1]),f.FromValuesToRef(1,0,0,0,0,1,0,0,p,E,1,0,0,0,0,1,F.Matrix[0]),F.Matrix[1].multiplyToRef(F.Matrix[0],F.Matrix[0]),f.TranslationToRef(0,0,t,F.Matrix[1]),F.Matrix[0].multiplyToRef(F.Matrix[1],F.Matrix[0]),f.OrthoOffCenterLHToRef(C,U,K,m,O,X,z,j),F.Matrix[0].multiplyToRef(z,z),z}static OrthoOffCenterRH(C,U,K,m,O,X,A){const e=new f;return f.OrthoOffCenterRHToRef(C,U,K,m,O,X,e,A),e}static OrthoOffCenterRHToRef(C,U,K,m,O,X,A,e){return f.OrthoOffCenterLHToRef(C,U,K,m,O,X,A,e),A.qA[10]*=-1,A}static ObliqueOffCenterRHToRef(C,U,K,m,O,X,A,e,t,z,j){const p=A*Math.cos(e),E=A*Math.sin(e);return f.TranslationToRef(0,0,t,F.Matrix[1]),f.FromValuesToRef(1,0,0,0,0,1,0,0,p,E,1,0,0,0,0,1,F.Matrix[0]),F.Matrix[1].multiplyToRef(F.Matrix[0],F.Matrix[0]),f.TranslationToRef(0,0,-t,F.Matrix[1]),F.Matrix[0].multiplyToRef(F.Matrix[1],F.Matrix[0]),f.OrthoOffCenterRHToRef(C,U,K,m,O,X,z,j),F.Matrix[0].multiplyToRef(z,z),z}static PerspectiveLH(C,U,K,m,O){let X=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const A=new f,e=2*K/C,t=2*K/U,z=(m+K)/(m-K),j=-2*m*K/(m-K),p=Math.tan(X);return f.FromValuesToRef(e,0,0,0,0,t,0,p,0,0,z,1,0,0,j,0,A),O&&A.multiplyToRef(P,A),A._updateIdentityStatus(!1),A}static PerspectiveFovLH(C,U,K,m,O){let X=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,A=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const e=new f;return f.PerspectiveFovLHToRef(C,U,K,m,e,!0,O,X,A),e}static PerspectiveFovLHToRef(C,U,K,m,O){let X=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],A=arguments.length>6?arguments[6]:void 0,e=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,t=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const z=K,j=m,p=1/Math.tan(.5*C),E=X?p/U:p,u=X?p:p*U,b=t&&0===z?-1:0!==j?(j+z)/(j-z):1,v=t&&0===z?2*j:0!==j?-2*j*z/(j-z):-2*z,Q=Math.tan(e);return f.FromValuesToRef(E,0,0,0,0,u,0,Q,0,0,b,1,0,0,v,0,O),A&&O.multiplyToRef(P,O),O._updateIdentityStatus(!1),O}static PerspectiveFovReverseLHToRef(C,U,K,m,O){let X=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],A=arguments.length>6?arguments[6]:void 0,e=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const t=1/Math.tan(.5*C),z=X?t/U:t,j=X?t:t*U,p=Math.tan(e);return f.FromValuesToRef(z,0,0,0,0,j,0,p,0,0,-K,1,0,0,1,0,O),A&&O.multiplyToRef(P,O),O._updateIdentityStatus(!1),O}static PerspectiveFovRH(C,U,K,m,O){let X=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,A=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const e=new f;return f.PerspectiveFovRHToRef(C,U,K,m,e,!0,O,X,A),e}static PerspectiveFovRHToRef(C,U,K,m,O){let X=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],A=arguments.length>6?arguments[6]:void 0,e=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,t=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const z=K,j=m,p=1/Math.tan(.5*C),E=X?p/U:p,u=X?p:p*U,b=t&&0===z?1:0!==j?-(j+z)/(j-z):-1,v=t&&0===z?2*j:0!==j?-2*j*z/(j-z):-2*z,Q=Math.tan(e);return f.FromValuesToRef(E,0,0,0,0,u,0,Q,0,0,b,-1,0,0,v,0,O),A&&O.multiplyToRef(P,O),O._updateIdentityStatus(!1),O}static PerspectiveFovReverseRHToRef(C,U,K,m,O){let X=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],A=arguments.length>6?arguments[6]:void 0,e=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const t=1/Math.tan(.5*C),z=X?t/U:t,j=X?t:t*U,p=Math.tan(e);return f.FromValuesToRef(z,0,0,0,0,j,0,p,0,0,-K,-1,0,0,-1,0,O),A&&O.multiplyToRef(P,O),O._updateIdentityStatus(!1),O}static GetFinalMatrix(C,U,K,m,O,X){const A=C.width,e=C.height,t=C.x,z=C.y,j=f.FromValues(A/2,0,0,0,0,-e/2,0,0,0,0,X-O,0,t+A/2,e/2+z,O,1),p=new f;return U.multiplyToRef(K,p),p.multiplyToRef(m,p),p.multiplyToRef(j,p)}static GetAsMatrix2x2(C){const U=C.m,K=[U[0],U[1],U[4],U[5]];return A.d.MatrixUse64Bits?K:new Float32Array(K)}static GetAsMatrix3x3(C){const U=C.m,K=[U[0],U[1],U[2],U[4],U[5],U[6],U[8],U[9],U[10]];return A.d.MatrixUse64Bits?K:new Float32Array(K)}static Transpose(C){const U=new f;return f.TransposeToRef(C,U),U}static TransposeToRef(C,U){const K=C.m,m=K[0],O=K[4],X=K[8],A=K[12],e=K[1],t=K[5],z=K[9],j=K[13],p=K[2],E=K[6],u=K[10],b=K[14],v=K[3],Q=K[7],V=K[11],f=K[15],F=U.qA;return F[0]=m,F[1]=O,F[2]=X,F[3]=A,F[4]=e,F[5]=t,F[6]=z,F[7]=j,F[8]=p,F[9]=E,F[10]=u,F[11]=b,F[12]=v,F[13]=Q,F[14]=V,F[15]=f,U.markAsUpdated(),U._updateIdentityStatus(C._isIdentity,C._isIdentityDirty),U}static Reflection(C){const U=new f;return f.ReflectionToRef(C,U),U}static ReflectionToRef(C,U){C.normalize();const K=C.normal.x,m=C.normal.y,O=C.normal.z,X=-2*K,A=-2*m,e=-2*O;return f.FromValuesToRef(X*K+1,A*K,e*K,0,X*m,A*m+1,e*m,0,X*O,A*O,e*O+1,0,X*C.d,A*C.d,e*C.d,1,U),U}static FromXYZAxesToRef(C,U,K,m){return f.FromValuesToRef(C._x,C._y,C._z,0,U._x,U._y,U._z,0,K._x,K._y,K._z,0,0,0,0,1,m),m}static FromQuaternionToRef(C,U){const K=C._x*C._x,m=C._y*C._y,O=C._z*C._z,X=C._x*C._y,A=C._z*C._w,e=C._z*C._x,t=C._y*C._w,z=C._y*C._z,j=C._x*C._w;return U.qA[0]=1-2*(m+O),U.qA[1]=2*(X+A),U.qA[2]=2*(e-t),U.qA[3]=0,U.qA[4]=2*(X-A),U.qA[5]=1-2*(O+K),U.qA[6]=2*(z+j),U.qA[7]=0,U.qA[8]=2*(e+t),U.qA[9]=2*(z-j),U.qA[10]=1-2*(m+K),U.qA[11]=0,U.qA[12]=0,U.qA[13]=0,U.qA[14]=0,U.qA[15]=1,U.markAsUpdated(),U}}f._IdentityReadOnly=f.Identity(),Object.defineProperties(f.prototype,{dimension:{value:[4,4]},rank:{value:2}});class F{}F.bU=(0,O.i)(11,v.Zero),F.Matrix=(0,O.i)(2,f.Identity),F.Quaternion=(0,O.i)(3,V.Zero);class Z{}Z.Vector2=(0,O.i)(3,b.Zero),Z.bU=(0,O.i)(13,v.Zero),Z.Vector4=(0,O.i)(3,Q.Zero),Z.Quaternion=(0,O.i)(3,V.Zero),Z.Matrix=(0,O.i)(8,f.Identity),(0,X.h)("BABYLON.Vector2",b),(0,X.h)("BABYLON.Vector3",v),(0,X.h)("BABYLON.Vector4",Q),(0,X.h)("BABYLON.Matrix",f);const P=f.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},11844:(C,U,K)=>{function m(C,U){const K=[];for(let m=0;m<C;++m)K.push(U());return K}function O(C,U){return m(C,U)}K.d(U,{e:()=>m,i:()=>O,k:()=>A});const X=["push","splice","pop","shift","unshift"];function A(C,U){const K=X.map((K=>function(C,U,K){const m=C[U];if("function"!==typeof m)return null;const O=function(){const m=C.length,X=O.previous.apply(C,arguments);return K(U,m),X};return m.next=O,O.previous=m,C[U]=O,()=>{const K=O.previous;if(!K)return;const m=O.next;m?(K.next=m,m.previous=K):(K.next=void 0,C[U]=K),O.next=void 0,O.previous=void 0}}(C,K,U)));return()=>{for(const C of K)null===C||void 0===C||C()}}}}]);