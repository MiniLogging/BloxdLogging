"use strict";(self.ex92n20nlz8=self.ex92n20nlz8||[]).push([[14],{12597:(I,g,b)=>{b.d(g,{b:()=>M,e:()=>z,i:()=>e,l:()=>c});const e=1/2.2,c=2.2,z=(1+Math.sqrt(5))/2,M=.001},12610:(I,g,b)=>{function e(I){return parseInt(I.toString().replace(/\W/g,""))}function c(I,g){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(I-g)<=b}function z(I,g,b){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return I<g-e||I>b+e}function M(I,g){return I===g?I:Math.random()*(g-I)+I}function J(I,g,b){return I+(g-I)*b}function o(I,g,b){let e=S(g-I,360);return e>180&&(e-=360),I+e*p(b)}function n(I,g,b){let e=0;return e=I!=g?p((b-I)/(g-I)):0,e}function G(I,g,b,e,c){const z=c*c,M=c*z;return I*(2*M-3*z+1)+b*(-2*M+3*z)+g*(M-2*z+c)+e*(M-z)}function D(I,g,b,e,c){const z=c*c;return 6*(z-c)*I+(3*z-4*c+1)*g+6*(-z+c)*b+(3*z-2*c)*e}function p(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(b,Math.max(g,I))}function x(I){return I-=2*Math.PI*Math.floor((I+Math.PI)/(2*Math.PI))}function Z(I){const g=I.toString(16);return I<=15?("0"+g).toUpperCase():g.toUpperCase()}function k(I){if(Math.log2)return Math.floor(Math.log2(I));if(I<0)return NaN;if(0===I)return-1/0;let g=0;if(I<1){for(;I<1;)g++,I*=2;g=-g}else if(I>1)for(;I>1;)g++,I=Math.floor(I/2);return g}function S(I,g){return I-Math.floor(I/g)*g}function f(I,g,b){return(I-g)/(b-g)}function V(I,g,b){return I*(b-g)+g}function a(I,g){let b=S(g-I,360);return b>180&&(b-=360),b}function v(I,g){const b=S(I,2*g);return g-Math.abs(b-g)}function X(I,g,b){let e=p(b);return e=-2*e*e*e+3*e*e,g*e+I*(1-e)}function R(I,g,b){let e=0;return e=Math.abs(g-I)<=b?g:I+Math.sign(g-I)*b,e}function E(I,g,b){const e=a(I,g);let c=0;return c=-b<e&&e<b?g:R(I,g=I+e,b),c}function mI(I,g,b){return(I-g)/(b-g)}function s(I,g,b){return(b-g)*I+g}function F(I,g){const b=I%g;return 0===b?g:F(g,b)}b.r(g),b.d(g,{Clamp:()=>p,DeltaAngle:()=>a,Denormalize:()=>V,ExtractAsInt:()=>e,Hermite:()=>G,Hermite1stDerivative:()=>D,HighestCommonFactor:()=>F,ILog2:()=>k,InverseLerp:()=>n,Lerp:()=>J,LerpAngle:()=>o,MoveTowards:()=>R,MoveTowardsAngle:()=>E,Normalize:()=>f,NormalizeRadians:()=>x,OutsideRange:()=>z,PercentToRange:()=>s,PingPong:()=>v,RandomRange:()=>M,RangeToPercent:()=>mI,Repeat:()=>S,SmoothStep:()=>X,ToHex:()=>Z,WithinEpsilon:()=>c})},12590:(I,g,b)=>{b.r(g),b.d(g,{Matrix:()=>V,Quaternion:()=>f,TmpVectors:()=>v,Vector2:()=>Z,Vg:()=>k,Vector4:()=>S});var e=b(12597),c=b(12604),z=b(12558),M=b(12526),J=b(12449),o=b(12610);class n{}function G(I,g,b){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const c=I.bb(),z=g.bb(),M=c[0],J=c[1],o=c[2],n=c[3],G=c[4],D=c[5],p=c[6],x=c[7],Z=c[8],k=c[9],S=c[10],f=c[11],V=c[12],a=c[13],v=c[14],X=c[15],R=z[0],E=z[1],mI=z[2],s=z[3],F=z[4],Y=z[5],d=z[6],C=z[7],r=z[8],O=z[9],H=z[10],i=z[11],U=z[12],h=z[13],A=z[14],j=z[15];b[e]=M*R+J*F+o*r+n*U,b[e+1]=M*E+J*Y+o*O+n*h,b[e+2]=M*mI+J*d+o*H+n*A,b[e+3]=M*s+J*C+o*i+n*j,b[e+4]=G*R+D*F+p*r+x*U,b[e+5]=G*E+D*Y+p*O+x*h,b[e+6]=G*mI+D*d+p*H+x*A,b[e+7]=G*s+D*C+p*i+x*j,b[e+8]=Z*R+k*F+S*r+f*U,b[e+9]=Z*E+k*Y+S*O+f*h,b[e+10]=Z*mI+k*d+S*H+f*A,b[e+11]=Z*s+k*C+S*i+f*j,b[e+12]=V*R+a*F+v*r+X*U,b[e+13]=V*E+a*Y+v*O+X*h,b[e+14]=V*mI+a*d+v*H+X*A,b[e+15]=V*s+a*C+v*i+X*j}function D(I,g){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const e=I.bb();g[b]=e[0],g[b+1]=e[1],g[b+2]=e[2],g[b+3]=e[3],g[b+4]=e[4],g[b+5]=e[5],g[b+6]=e[6],g[b+7]=e[7],g[b+8]=e[8],g[b+9]=e[9],g[b+10]=e[10],g[b+11]=e[11],g[b+12]=e[12],g[b+13]=e[13],g[b+14]=e[14],g[b+15]=e[15]}function p(I,g){const b=I.bb(),e=b[0],c=b[1],z=b[2],M=b[3],J=b[4],o=b[5],n=b[6],G=b[7],D=b[8],p=b[9],x=b[10],Z=b[11],k=b[12],S=b[13],f=b[14],V=b[15],a=x*V-f*Z,v=p*V-S*Z,X=p*f-S*x,R=D*V-k*Z,E=D*f-x*k,mI=D*S-k*p,s=+(o*a-n*v+G*X),F=-(J*a-n*R+G*E),Y=+(J*v-o*R+G*mI),d=-(J*X-o*E+n*mI),C=e*s+c*F+z*Y+M*d;if(0===C)return!1;const r=1/C,O=n*V-f*G,H=o*V-S*G,i=o*f-S*n,U=J*V-k*G,h=J*f-k*n,A=J*S-k*o,j=n*Z-x*G,Q=o*Z-p*G,L=o*x-p*n,N=J*Z-D*G,K=J*x-D*n,B=J*p-D*o,P=-(c*a-z*v+M*X),u=+(e*a-z*R+M*E),t=-(e*v-c*R+M*mI),y=+(e*X-c*E+z*mI),q=+(c*O-z*H+M*i),l=-(e*O-z*U+M*h),w=+(e*H-c*U+M*A),T=-(e*i-c*h+z*A),W=-(c*j-z*Q+M*L),II=+(e*j-z*N+M*K),gI=-(e*Q-c*N+M*B),bI=+(e*L-c*K+z*B);return g[0]=s*r,g[1]=P*r,g[2]=q*r,g[3]=W*r,g[4]=F*r,g[5]=u*r,g[6]=l*r,g[7]=II*r,g[8]=Y*r,g[9]=t*r,g[10]=w*r,g[11]=gI*r,g[12]=d*r,g[13]=y*r,g[14]=T*r,g[15]=bI*r,!0}n._UpdateFlagSeed=0;const x=I=>parseInt(I.toString().replace(/\W/g,""));class Z{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.x=I,this.y=g}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){let I=x(this.x);return I=397*I^x(this.y),I}toArray(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[g]=this.x,I[g+1]=this.y,this}Le(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z.FromArrayToRef(I,g,this),this}bb(){return[this.x,this.y]}G(I){return this.x=I.x,this.y=I.y,this}Db(I,g){return this.x=I,this.y=g,this}set(I,g){return this.Db(I,g)}kb(I){return this.Db(I,I)}add(I){return new Z(this.x+I.x,this.y+I.y)}addToRef(I,g){return g.x=this.x+I.x,g.y=this.y+I.y,g}addInPlace(I){return this.x+=I.x,this.y+=I.y,this}addInPlaceFromFloats(I,g){return this.x+=I,this.y+=g,this}addVector3(I){return new Z(this.x+I.x,this.y+I.y)}ag(I){return new Z(this.x-I.x,this.y-I.y)}subtractToRef(I,g){return g.x=this.x-I.x,g.y=this.y-I.y,g}Op(I){return this.x-=I.x,this.y-=I.y,this}multiplyInPlace(I){return this.x*=I.x,this.y*=I.y,this}multiply(I){return new Z(this.x*I.x,this.y*I.y)}multiplyToRef(I,g){return g.x=this.x*I.x,g.y=this.y*I.y,g}multiplyByFloats(I,g){return new Z(this.x*I,this.y*g)}divide(I){return new Z(this.x/I.x,this.y/I.y)}divideToRef(I,g){return g.x=this.x/I.x,g.y=this.y/I.y,g}divideInPlace(I){return this.x=this.x/I.x,this.y=this.y/I.y,this}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I.x,I.y)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I.x,I.y)}minimizeInPlaceFromFloats(I,g){return this.x=Math.min(I,this.x),this.y=Math.min(g,this.y),this}maximizeInPlaceFromFloats(I,g){return this.x=Math.max(I,this.x),this.y=Math.max(g,this.y),this}subtractFromFloats(I,g){return new Z(this.x-I,this.y-g)}subtractFromFloatsToRef(I,g,b){return b.x=this.x-I,b.y=this.y-g,b}negate(){return new Z(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(I){return I.x=-this.x,I.y=-this.y,I}scaleInPlace(I){return this.x*=I,this.y*=I,this}scale(I){return new Z(this.x*I,this.y*I)}scaleToRef(I,g){return g.x=this.x*I,g.y=this.y*I,g}scaleAndAddToRef(I,g){return g.x+=this.x*I,g.y+=this.y*I,g}equals(I){return I&&this.x===I.x&&this.y===I.y}equalsWithEpsilon(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.b;return I&&(0,o.WithinEpsilon)(this.x,I.x,g)&&(0,o.WithinEpsilon)(this.y,I.y,g)}equalsToFloats(I,g){return this.x===I&&this.y===g}floor(){return new Z(Math.floor(this.x),Math.floor(this.y))}floorToRef(I){return I.x=Math.floor(this.x),I.y=Math.floor(this.y),I}fract(){return new Z(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(I){return I.x=this.x-Math.floor(this.x),I.y=this.y-Math.floor(this.y),I}rotate(I){return this.rotateToRef(I,new Z)}rotateToRef(I,g){const b=Math.cos(I),e=Math.sin(I);return g.x=b*this.x-e*this.y,g.y=e*this.x+b*this.y,g}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){const I=new Z;return this.normalizeToRef(I),I}normalizeToRef(I){const g=this.length();return 0===g&&(I.x=this.x,I.y=this.y),this.scaleToRef(1/g,I)}clone(){return new Z(this.x,this.y)}dot(I){return this.x*I.x+this.y*I.y}static Zero(){return new Z(0,0)}static One(){return new Z(1,1)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Z((0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Db((0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g))}static get ZeroReadOnly(){return Z._ZeroReadOnly}static mb(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Z(I[g],I[g+1])}static FromArrayToRef(I,g,b){return b.x=I[g],b.y=I[g+1],b}static FromFloatsToRef(I,g,b){return b.Db(I,g),b}static CatmullRom(I,g,b,e,c){const z=c*c,M=c*z,J=.5*(2*g.x+(-I.x+b.x)*c+(2*I.x-5*g.x+4*b.x-e.x)*z+(-I.x+3*g.x-3*b.x+e.x)*M),o=.5*(2*g.y+(-I.y+b.y)*c+(2*I.y-5*g.y+4*b.y-e.y)*z+(-I.y+3*g.y-3*b.y+e.y)*M);return new Z(J,o)}static ClampToRef(I,g,b,e){return e.x=(0,o.Clamp)(I.x,g.x,b.x),e.y=(0,o.Clamp)(I.y,g.y,b.y),e}static Clamp(I,g,b){const e=(0,o.Clamp)(I.x,g.x,b.x),c=(0,o.Clamp)(I.y,g.y,b.y);return new Z(e,c)}static Hermite(I,g,b,e,c){const z=c*c,M=c*z,J=2*M-3*z+1,o=-2*M+3*z,n=M-2*z+c,G=M-z,D=I.x*J+b.x*o+g.x*n+e.x*G,p=I.y*J+b.y*o+g.y*n+e.y*G;return new Z(D,p)}static Hermite1stDerivative(I,g,b,e,c){return this.Hermite1stDerivativeToRef(I,g,b,e,c,new Z)}static Hermite1stDerivativeToRef(I,g,b,e,c,z){const M=c*c;return z.x=6*(M-c)*I.x+(3*M-4*c+1)*g.x+6*(-M+c)*b.x+(3*M-2*c)*e.x,z.y=6*(M-c)*I.y+(3*M-4*c+1)*g.y+6*(-M+c)*b.y+(3*M-2*c)*e.y,z}static Lerp(I,g,b){return Z.LerpToRef(I,g,b,new Z)}static LerpToRef(I,g,b,e){return e.x=I.x+(g.x-I.x)*b,e.y=I.y+(g.y-I.y)*b,e}static Dot(I,g){return I.x*g.x+I.y*g.y}static Normalize(I){return Z.NormalizeToRef(I,new Z)}static NormalizeToRef(I,g){return I.normalizeToRef(g),g}static Minimize(I,g){const b=I.x<g.x?I.x:g.x,e=I.y<g.y?I.y:g.y;return new Z(b,e)}static Maximize(I,g){const b=I.x>g.x?I.x:g.x,e=I.y>g.y?I.y:g.y;return new Z(b,e)}static Transform(I,g){return Z.TransformToRef(I,g,new Z)}static TransformToRef(I,g,b){const e=g.m,c=I.x*e[0]+I.y*e[4]+e[12],z=I.x*e[1]+I.y*e[5]+e[13];return b.x=c,b.y=z,b}static PointInTriangle(I,g,b,e){const c=.5*(-b.y*e.x+g.y*(-b.x+e.x)+g.x*(b.y-e.y)+b.x*e.y),z=c<0?-1:1,M=(g.y*e.x-g.x*e.y+(e.y-g.y)*I.x+(g.x-e.x)*I.y)*z,J=(g.x*b.y-g.y*b.x+(g.y-b.y)*I.x+(b.x-g.x)*I.y)*z;return M>0&&J>0&&M+J<2*c*z}static Distance(I,g){return Math.sqrt(Z.DistanceSquared(I,g))}static DistanceSquared(I,g){const b=I.x-g.x,e=I.y-g.y;return b*b+e*e}static Center(I,g){return Z.CenterToRef(I,g,new Z)}static CenterToRef(I,g,b){return b.Db((I.x+g.x)/2,(I.y+g.y)/2)}static DistanceOfPointFromSegment(I,g,b){const e=Z.DistanceSquared(g,b);if(0===e)return Z.Distance(I,g);const c=b.ag(g),z=Math.max(0,Math.min(1,Z.Dot(I.ag(g),c)/e)),M=g.add(c.multiplyByFloats(z,z));return Z.Distance(I,M)}}Z._V8PerformanceHack=new Z(.5,.5),Z._ZeroReadOnly=Z.Zero(),Object.defineProperties(Z.prototype,{dimension:{value:[2]},rank:{value:1}});class k{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._isDirty=!0,this._x=I,this._y=g,this._z=b}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Vg"}getHashCode(){let I=x(this._x);return I=397*I^x(this._y),I=397*I^x(this._z),I}bb(){return[this._x,this._y,this._z]}toArray(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[g]=this._x,I[g+1]=this._y,I[g+2]=this._z,this}Le(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k.FromArrayToRef(I,g,this),this}toQuaternion(){return f.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(I){return this._x+=I._x,this._y+=I._y,this._z+=I._z,this._isDirty=!0,this}addInPlaceFromFloats(I,g,b){return this._x+=I,this._y+=g,this._z+=b,this._isDirty=!0,this}add(I){return new k(this._x+I._x,this._y+I._y,this._z+I._z)}addToRef(I,g){return g._x=this._x+I._x,g._y=this._y+I._y,g._z=this._z+I._z,g._isDirty=!0,g}Op(I){return this._x-=I._x,this._y-=I._y,this._z-=I._z,this._isDirty=!0,this}ag(I){return new k(this._x-I._x,this._y-I._y,this._z-I._z)}subtractToRef(I,g){return this.subtractFromFloatsToRef(I._x,I._y,I._z,g)}subtractFromFloats(I,g,b){return new k(this._x-I,this._y-g,this._z-b)}subtractFromFloatsToRef(I,g,b,e){return e._x=this._x-I,e._y=this._y-g,e._z=this._z-b,e._isDirty=!0,e}negate(){return new k(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(I){return I._x=-1*this._x,I._y=-1*this._y,I._z=-1*this._z,I._isDirty=!0,I}scaleInPlace(I){return this._x*=I,this._y*=I,this._z*=I,this._isDirty=!0,this}scale(I){return new k(this._x*I,this._y*I,this._z*I)}scaleToRef(I,g){return g._x=this._x*I,g._y=this._y*I,g._z=this._z*I,g._isDirty=!0,g}getNormalToRef(I){const g=this.length();let b=Math.acos(this._y/g);const e=Math.atan2(this._z,this._x);b>Math.PI/2?b-=Math.PI/2:b+=Math.PI/2;const c=g*Math.sin(b)*Math.cos(e),z=g*Math.cos(b),M=g*Math.sin(b)*Math.sin(e);return I.set(c,z,M),I}applyRotationQuaternionToRef(I,g){const b=this._x,e=this._y,c=this._z,z=I._x,M=I._y,J=I._z,o=I._w,n=2*(M*c-J*e),G=2*(J*b-z*c),D=2*(z*e-M*b);return g._x=b+o*n+M*D-J*G,g._y=e+o*G+J*n-z*D,g._z=c+o*D+z*G-M*n,g._isDirty=!0,g}applyRotationQuaternionInPlace(I){return this.applyRotationQuaternionToRef(I,this)}applyRotationQuaternion(I){return this.applyRotationQuaternionToRef(I,new k)}scaleAndAddToRef(I,g){return g._x+=this._x*I,g._y+=this._y*I,g._z+=this._z*I,g._isDirty=!0,g}projectOnPlane(I,g){return this.projectOnPlaneToRef(I,g,new k)}projectOnPlaneToRef(I,g,b){const e=I.normal,c=I.d,z=a.Vg[0];this.subtractToRef(g,z),z.normalize();const M=k.Dot(z,e);if(Math.abs(M)<1e-10)b.kb(1/0);else{const I=-(k.Dot(g,e)+c)/M,J=z.scaleInPlace(I);g.addToRef(J,b)}return b}equals(I){return I&&this._x===I._x&&this._y===I._y&&this._z===I._z}equalsWithEpsilon(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.b;return I&&(0,o.WithinEpsilon)(this._x,I._x,g)&&(0,o.WithinEpsilon)(this._y,I._y,g)&&(0,o.WithinEpsilon)(this._z,I._z,g)}equalsToFloats(I,g,b){return this._x===I&&this._y===g&&this._z===b}multiplyInPlace(I){return this._x*=I._x,this._y*=I._y,this._z*=I._z,this._isDirty=!0,this}multiply(I){return this.multiplyByFloats(I._x,I._y,I._z)}multiplyToRef(I,g){return g._x=this._x*I._x,g._y=this._y*I._y,g._z=this._z*I._z,g._isDirty=!0,g}multiplyByFloats(I,g,b){return new k(this._x*I,this._y*g,this._z*b)}divide(I){return new k(this._x/I._x,this._y/I._y,this._z/I._z)}divideToRef(I,g){return g._x=this._x/I._x,g._y=this._y/I._y,g._z=this._z/I._z,g._isDirty=!0,g}divideInPlace(I){return this._x=this._x/I._x,this._y=this._y/I._y,this._z=this._z/I._z,this._isDirty=!0,this}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I._x,I._y,I._z)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I._x,I._y,I._z)}minimizeInPlaceFromFloats(I,g,b){return I<this._x&&(this.x=I),g<this._y&&(this.y=g),b<this._z&&(this.z=b),this}maximizeInPlaceFromFloats(I,g,b){return I>this._x&&(this.x=I),g>this._y&&(this.y=g),b>this._z&&(this.z=b),this}isNonUniformWithinEpsilon(I){const g=Math.abs(this._x),b=Math.abs(this._y);if(!(0,o.WithinEpsilon)(g,b,I))return!0;const e=Math.abs(this._z);return!(0,o.WithinEpsilon)(g,e,I)||!(0,o.WithinEpsilon)(b,e,I)}get isNonUniform(){const I=Math.abs(this._x);if(I!==Math.abs(this._y))return!0;return I!==Math.abs(this._z)}floorToRef(I){return I._x=Math.floor(this._x),I._y=Math.floor(this._y),I._z=Math.floor(this._z),I._isDirty=!0,I}floor(){return new k(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fractToRef(I){return I._x=this._x-Math.floor(this._x),I._y=this._y-Math.floor(this._y),I._z=this._z-Math.floor(this._z),I._isDirty=!0,I}fract(){return new k(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(I){if("xyz"===(I=I.toLowerCase()))return this;const g=a.Vg[0].G(this);return this.x=g[I[0]],this.y=g[I[1]],this.z=g[I[2]],this}rotateByQuaternionToRef(I,g){return I.toRotationMatrix(a.Matrix[0]),k.TransformCoordinatesToRef(this,a.Matrix[0],g),g}rotateByQuaternionAroundPointToRef(I,g,b){return this.subtractToRef(g,a.Vg[0]),a.Vg[0].rotateByQuaternionToRef(I,a.Vg[0]),g.addToRef(a.Vg[0],b),b}cross(I){return k.CrossToRef(this,I,new k)}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){return this.normalizeToRef(new k)}normalizeToRef(I){const g=this.length();return 0===g||1===g?(I._x=this._x,I._y=this._y,I._z=this._z,I._isDirty=!0,I):this.scaleToRef(1/g,I)}clone(){return new k(this._x,this._y,this._z)}G(I){return this.Db(I._x,I._y,I._z)}Db(I,g,b){return this._x=I,this._y=g,this._z=b,this._isDirty=!0,this}set(I,g,b){return this.Db(I,g,b)}kb(I){return this._x=this._y=this._z=I,this._isDirty=!0,this}static GetClipFactor(I,g,b,e){const c=k.Dot(I,b);return(c-e)/(c-k.Dot(g,b))}static GetAngleBetweenVectors(I,g,b){const e=I.normalizeToRef(a.Vg[1]),c=g.normalizeToRef(a.Vg[2]);let z=k.Dot(e,c);z=(0,o.Clamp)(z,-1,1);const M=Math.acos(z),J=a.Vg[3];return k.CrossToRef(e,c,J),k.Dot(J,b)>0?isNaN(M)?0:M:isNaN(M)?-Math.PI:-Math.acos(z)}static GetAngleBetweenVectorsOnPlane(I,g,b){a.Vg[0].G(I);const e=a.Vg[0];a.Vg[1].G(g);const c=a.Vg[1];a.Vg[2].G(b);const z=a.Vg[2],M=a.Vg[3],J=a.Vg[4];e.normalize(),c.normalize(),z.normalize(),k.CrossToRef(z,e,M),k.CrossToRef(M,z,J);const n=Math.atan2(k.Dot(c,M),k.Dot(c,J));return(0,o.NormalizeRadians)(n)}static PitchYawRollToMoveBetweenPointsToRef(I,g,b){const e=v.Vg[0];return g.subtractToRef(I,e),b._y=Math.atan2(e.x,e.z)||0,b._x=Math.atan2(Math.sqrt(e.x**2+e.z**2),e.y)||0,b._z=0,b._isDirty=!0,b}static PitchYawRollToMoveBetweenPoints(I,g){const b=k.Zero();return k.PitchYawRollToMoveBetweenPointsToRef(I,g,b)}static SlerpToRef(I,g,b,c){b=(0,o.Clamp)(b,0,1);const z=a.Vg[0],M=a.Vg[1];z.G(I);const J=z.length();z.normalizeFromLength(J),M.G(g);const n=M.length();M.normalizeFromLength(n);const G=k.Dot(z,M);let D,p;if(G<1-e.b){const I=Math.acos(G),g=1/Math.sin(I);D=Math.sin((1-b)*I)*g,p=Math.sin(b*I)*g}else D=1-b,p=b;return z.scaleInPlace(D),M.scaleInPlace(p),c.G(z).addInPlace(M),c.scaleInPlace((0,o.Lerp)(J,n,b)),c}static SmoothToRef(I,g,b,e,c){return k.SlerpToRef(I,g,0===e?1:b/e,c),c}static mb(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new k(I[g],I[g+1],I[g+2])}static FromFloatArray(I,g){return k.mb(I,g)}static FromArrayToRef(I,g,b){return b._x=I[g],b._y=I[g+1],b._z=I[g+2],b._isDirty=!0,b}static FromFloatArrayToRef(I,g,b){return k.FromArrayToRef(I,g,b)}static FromFloatsToRef(I,g,b,e){return e.Db(I,g,b),e}static Zero(){return new k(0,0,0)}static One(){return new k(1,1,1)}static Up(){return new k(0,1,0)}static get UpReadOnly(){return k._UpReadOnly}static get DownReadOnly(){return k._DownReadOnly}static get RightReadOnly(){return k._RightReadOnly}static get LeftReadOnly(){return k._LeftReadOnly}static get LeftHandedForwardReadOnly(){return k._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return k._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return k._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return k._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return k._ZeroReadOnly}static get OneReadOnly(){return k._OneReadOnly}static Down(){return new k(0,-1,0)}static Forward(){return new k(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?-1:1)}static Backward(){return new k(0,0,arguments.length>0&&void 0!==arguments[0]&&arguments[0]?1:-1)}static Right(){return new k(1,0,0)}static Left(){return new k(-1,0,0)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new k((0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Db((0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g))}static TransformCoordinates(I,g){const b=k.Zero();return k.TransformCoordinatesToRef(I,g,b),b}static TransformCoordinatesToRef(I,g,b){return k.TransformCoordinatesFromFloatsToRef(I._x,I._y,I._z,g,b),b}static TransformCoordinatesFromFloatsToRef(I,g,b,e,c){const z=e.m,M=I*z[0]+g*z[4]+b*z[8]+z[12],J=I*z[1]+g*z[5]+b*z[9]+z[13],o=I*z[2]+g*z[6]+b*z[10]+z[14],n=1/(I*z[3]+g*z[7]+b*z[11]+z[15]);return c._x=M*n,c._y=J*n,c._z=o*n,c._isDirty=!0,c}static TransformNormal(I,g){const b=k.Zero();return k.TransformNormalToRef(I,g,b),b}static TransformNormalToRef(I,g,b){return this.TransformNormalFromFloatsToRef(I._x,I._y,I._z,g,b),b}static TransformNormalFromFloatsToRef(I,g,b,e,c){const z=e.m;return c._x=I*z[0]+g*z[4]+b*z[8],c._y=I*z[1]+g*z[5]+b*z[9],c._z=I*z[2]+g*z[6]+b*z[10],c._isDirty=!0,c}static CatmullRom(I,g,b,e,c){const z=c*c,M=c*z,J=.5*(2*g._x+(-I._x+b._x)*c+(2*I._x-5*g._x+4*b._x-e._x)*z+(-I._x+3*g._x-3*b._x+e._x)*M),o=.5*(2*g._y+(-I._y+b._y)*c+(2*I._y-5*g._y+4*b._y-e._y)*z+(-I._y+3*g._y-3*b._y+e._y)*M),n=.5*(2*g._z+(-I._z+b._z)*c+(2*I._z-5*g._z+4*b._z-e._z)*z+(-I._z+3*g._z-3*b._z+e._z)*M);return new k(J,o,n)}static Clamp(I,g,b){const e=new k;return k.ClampToRef(I,g,b,e),e}static ClampToRef(I,g,b,e){let c=I._x;c=c>b._x?b._x:c,c=c<g._x?g._x:c;let z=I._y;z=z>b._y?b._y:z,z=z<g._y?g._y:z;let M=I._z;return M=M>b._z?b._z:M,M=M<g._z?g._z:M,e.Db(c,z,M),e}static CheckExtends(I,g,b){g.minimizeInPlace(I),b.maximizeInPlace(I)}static Hermite(I,g,b,e,c){const z=c*c,M=c*z,J=2*M-3*z+1,o=-2*M+3*z,n=M-2*z+c,G=M-z,D=I._x*J+b._x*o+g._x*n+e._x*G,p=I._y*J+b._y*o+g._y*n+e._y*G,x=I._z*J+b._z*o+g._z*n+e._z*G;return new k(D,p,x)}static Hermite1stDerivative(I,g,b,e,c){const z=new k;return this.Hermite1stDerivativeToRef(I,g,b,e,c,z),z}static Hermite1stDerivativeToRef(I,g,b,e,c,z){const M=c*c;return z._x=6*(M-c)*I._x+(3*M-4*c+1)*g._x+6*(-M+c)*b._x+(3*M-2*c)*e._x,z._y=6*(M-c)*I._y+(3*M-4*c+1)*g._y+6*(-M+c)*b._y+(3*M-2*c)*e._y,z._z=6*(M-c)*I._z+(3*M-4*c+1)*g._z+6*(-M+c)*b._z+(3*M-2*c)*e._z,z._isDirty=!0,z}static Lerp(I,g,b){const e=new k(0,0,0);return k.LerpToRef(I,g,b,e),e}static LerpToRef(I,g,b,e){return e._x=I._x+(g._x-I._x)*b,e._y=I._y+(g._y-I._y)*b,e._z=I._z+(g._z-I._z)*b,e._isDirty=!0,e}static Dot(I,g){return I._x*g._x+I._y*g._y+I._z*g._z}dot(I){return this._x*I._x+this._y*I._y+this._z*I._z}static Cross(I,g){const b=new k;return k.CrossToRef(I,g,b),b}static CrossToRef(I,g,b){const e=I._y*g._z-I._z*g._y,c=I._z*g._x-I._x*g._z,z=I._x*g._y-I._y*g._x;return b.Db(e,c,z),b}static Normalize(I){const g=k.Zero();return k.NormalizeToRef(I,g),g}static NormalizeToRef(I,g){return I.normalizeToRef(g),g}static Project(I,g,b,e){const c=new k;return k.ProjectToRef(I,g,b,e,c),c}static ProjectToRef(I,g,b,e,c){var z;const M=e.width,o=e.height,n=e.x,G=e.y,D=a.Matrix[1],p=null===(z=J.b.LastCreatedEngine)||void 0===z?void 0:z.isNDCHalfZRange,x=p?1:.5,Z=p?0:.5;V.FromValuesToRef(M/2,0,0,0,0,-o/2,0,0,0,0,x,0,n+M/2,o/2+G,Z,1,D);const S=a.Matrix[0];return g.multiplyToRef(b,S),S.multiplyToRef(D,S),k.TransformCoordinatesToRef(I,S,c),c}static Reflect(I,g){return this.ReflectToRef(I,g,new k)}static ReflectToRef(I,g,b){const e=v.Vg[0];return e.G(g).scaleInPlace(2*k.Dot(I,g)),b.G(I).Op(e)}static _UnprojectFromInvertedMatrixToRef(I,g,b){k.TransformCoordinatesToRef(I,g,b);const e=g.m,c=I._x*e[3]+I._y*e[7]+I._z*e[11]+e[15];return(0,o.WithinEpsilon)(c,1)&&b.scaleInPlace(1/c),b}static UnprojectFromTransform(I,g,b,e,c){return this.Unproject(I,g,b,e,c,V.IdentityReadOnly)}static Unproject(I,g,b,e,c,z){const M=new k;return k.UnprojectToRef(I,g,b,e,c,z,M),M}static UnprojectToRef(I,g,b,e,c,z,M){return k.UnprojectFloatsToRef(I._x,I._y,I._z,g,b,e,c,z,M),M}static UnprojectFloatsToRef(I,g,b,e,c,z,M,o,n){var G;const D=a.Matrix[0];z.multiplyToRef(M,D),D.multiplyToRef(o,D),D.invert();const p=a.Vg[0];return p.x=I/e*2-1,p.y=-(g/c*2-1),null!==(G=J.b.LastCreatedEngine)&&void 0!==G&&G.isNDCHalfZRange?p.z=b:p.z=2*b-1,k._UnprojectFromInvertedMatrixToRef(p,D,n),n}static Minimize(I,g){const b=new k;return b.G(I),b.minimizeInPlace(g),b}static Maximize(I,g){const b=new k;return b.G(I),b.maximizeInPlace(g),b}static Distance(I,g){return Math.sqrt(k.DistanceSquared(I,g))}static DistanceSquared(I,g){const b=I._x-g._x,e=I._y-g._y,c=I._z-g._z;return b*b+e*e+c*c}static ProjectOnTriangleToRef(I,g,b,c,z){const M=a.Vg[0],J=a.Vg[1],n=a.Vg[2],G=a.Vg[3],D=a.Vg[4];b.subtractToRef(g,M),c.subtractToRef(g,J),c.subtractToRef(b,n);const p=M.length(),x=J.length(),Z=n.length();if(p<e.b||x<e.b||Z<e.b)return z.G(g),k.Distance(I,g);I.subtractToRef(g,D),k.CrossToRef(M,J,G);const S=G.length();if(S<e.b)return z.G(g),k.Distance(I,g);G.normalizeFromLength(S);let f=D.length();if(f<e.b)return z.G(g),0;D.normalizeFromLength(f);const V=k.Dot(G,D),v=a.Vg[5],X=a.Vg[6];v.G(G).scaleInPlace(-f*V),X.G(I).addInPlace(v);const R=a.Vg[4],E=a.Vg[5],mI=a.Vg[7],s=a.Vg[8];R.G(M).scaleInPlace(1/p),s.G(J).scaleInPlace(1/x),R.addInPlace(s).scaleInPlace(-1),E.G(M).scaleInPlace(-1/p),s.G(n).scaleInPlace(1/Z),E.addInPlace(s).scaleInPlace(-1),mI.G(n).scaleInPlace(-1/Z),s.G(J).scaleInPlace(-1/x),mI.addInPlace(s).scaleInPlace(-1);const F=a.Vg[9];let Y;F.G(X).Op(g),k.CrossToRef(R,F,s),Y=k.Dot(s,G);const d=Y;F.G(X).Op(b),k.CrossToRef(E,F,s),Y=k.Dot(s,G);const C=Y;F.G(X).Op(c),k.CrossToRef(mI,F,s),Y=k.Dot(s,G);const r=Y,O=a.Vg[10];let H,i;d>0&&C<0?(O.G(M),H=g,i=b):C>0&&r<0?(O.G(n),H=b,i=c):(O.G(J).scaleInPlace(-1),H=c,i=g);const U=a.Vg[9],h=a.Vg[4];H.subtractToRef(X,s),i.subtractToRef(X,U),k.CrossToRef(s,U,h);if(!(k.Dot(h,G)<0))return z.G(X),Math.abs(f*V);const A=a.Vg[5];k.CrossToRef(O,h,A),A.normalize();const j=a.Vg[9];j.G(H).Op(X);const Q=j.length();if(Q<e.b)return z.G(H),k.Distance(I,H);j.normalizeFromLength(Q);const L=k.Dot(A,j),N=a.Vg[7];N.G(X).addInPlace(A.scaleInPlace(Q*L)),s.G(N).Op(H),f=O.length(),O.normalizeFromLength(f);let K=k.Dot(s,O)/Math.max(f,e.b);return K=(0,o.Clamp)(K,0,1),N.G(H).addInPlace(O.scaleInPlace(K*f)),z.G(N),k.Distance(I,N)}static Center(I,g){return k.CenterToRef(I,g,k.Zero())}static CenterToRef(I,g,b){return b.Db((I._x+g._x)/2,(I._y+g._y)/2,(I._z+g._z)/2)}static RotationFromAxis(I,g,b){const e=new k;return k.RotationFromAxisToRef(I,g,b,e),e}static RotationFromAxisToRef(I,g,b,e){const c=a.Quaternion[0];return f.RotationQuaternionFromAxisToRef(I,g,b,c),c.toEulerAnglesToRef(e),e}}k._V8PerformanceHack=new k(.5,.5,.5),k._UpReadOnly=k.Up(),k._DownReadOnly=k.Down(),k._LeftHandedForwardReadOnly=k.Forward(!1),k._RightHandedForwardReadOnly=k.Forward(!0),k._LeftHandedBackwardReadOnly=k.Backward(!1),k._RightHandedBackwardReadOnly=k.Backward(!0),k._RightReadOnly=k.Right(),k._LeftReadOnly=k.Left(),k._ZeroReadOnly=k.Zero(),k._OneReadOnly=k.One(),Object.defineProperties(k.prototype,{dimension:{value:[3]},rank:{value:1}});class S{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}get w(){return this._w}set w(I){this._w=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this._isDirty=!0,this._x=I,this._y=g,this._z=b,this._w=e}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Vector4"}getHashCode(){let I=x(this._x);return I=397*I^x(this._y),I=397*I^x(this._z),I=397*I^x(this._w),I}bb(){return[this._x,this._y,this._z,this._w]}toArray(I,g){return void 0===g&&(g=0),I[g]=this._x,I[g+1]=this._y,I[g+2]=this._z,I[g+3]=this._w,this}Le(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(I,g,this),this}addInPlace(I){return this.x+=I._x,this.y+=I._y,this.z+=I._z,this.w+=I._w,this}addInPlaceFromFloats(I,g,b,e){return this.x+=I,this.y+=g,this.z+=b,this.w+=e,this}add(I){return new S(this._x+I.x,this._y+I.y,this._z+I.z,this._w+I.w)}addToRef(I,g){return g.x=this._x+I.x,g.y=this._y+I.y,g.z=this._z+I.z,g.w=this._w+I.w,g}Op(I){return this.x-=I.x,this.y-=I.y,this.z-=I.z,this.w-=I.w,this}ag(I){return new S(this._x-I.x,this._y-I.y,this._z-I.z,this._w-I.w)}subtractToRef(I,g){return g.x=this._x-I.x,g.y=this._y-I.y,g.z=this._z-I.z,g.w=this._w-I.w,g}subtractFromFloats(I,g,b,e){return new S(this._x-I,this._y-g,this._z-b,this._w-e)}subtractFromFloatsToRef(I,g,b,e,c){return c.x=this._x-I,c.y=this._y-g,c.z=this._z-b,c.w=this._w-e,c}negate(){return new S(-this._x,-this._y,-this._z,-this._w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(I){return I.x=-this._x,I.y=-this._y,I.z=-this._z,I.w=-this._w,I}scaleInPlace(I){return this.x*=I,this.y*=I,this.z*=I,this.w*=I,this}scale(I){return new S(this._x*I,this._y*I,this._z*I,this._w*I)}scaleToRef(I,g){return g.x=this._x*I,g.y=this._y*I,g.z=this._z*I,g.w=this._w*I,g}scaleAndAddToRef(I,g){return g.x+=this._x*I,g.y+=this._y*I,g.z+=this._z*I,g.w+=this._w*I,g}equals(I){return I&&this._x===I.x&&this._y===I.y&&this._z===I.z&&this._w===I.w}equalsWithEpsilon(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.b;return I&&(0,o.WithinEpsilon)(this._x,I.x,g)&&(0,o.WithinEpsilon)(this._y,I.y,g)&&(0,o.WithinEpsilon)(this._z,I.z,g)&&(0,o.WithinEpsilon)(this._w,I.w,g)}equalsToFloats(I,g,b,e){return this._x===I&&this._y===g&&this._z===b&&this._w===e}multiplyInPlace(I){return this.x*=I.x,this.y*=I.y,this.z*=I.z,this.w*=I.w,this}multiply(I){return new S(this._x*I.x,this._y*I.y,this._z*I.z,this._w*I.w)}multiplyToRef(I,g){return g.x=this._x*I.x,g.y=this._y*I.y,g.z=this._z*I.z,g.w=this._w*I.w,g}multiplyByFloats(I,g,b,e){return new S(this._x*I,this._y*g,this._z*b,this._w*e)}divide(I){return new S(this._x/I.x,this._y/I.y,this._z/I.z,this._w/I.w)}divideToRef(I,g){return g.x=this._x/I.x,g.y=this._y/I.y,g.z=this._z/I.z,g.w=this._w/I.w,g}divideInPlace(I){return this.divideToRef(I,this)}minimizeInPlace(I){return I.x<this._x&&(this.x=I.x),I.y<this._y&&(this.y=I.y),I.z<this._z&&(this.z=I.z),I.w<this._w&&(this.w=I.w),this}maximizeInPlace(I){return I.x>this._x&&(this.x=I.x),I.y>this._y&&(this.y=I.y),I.z>this._z&&(this.z=I.z),I.w>this._w&&(this.w=I.w),this}minimizeInPlaceFromFloats(I,g,b,e){return this.x=Math.min(I,this._x),this.y=Math.min(g,this._y),this.z=Math.min(b,this._z),this.w=Math.min(e,this._w),this}maximizeInPlaceFromFloats(I,g,b,e){return this.x=Math.max(I,this._x),this.y=Math.max(g,this._y),this.z=Math.max(b,this._z),this.w=Math.max(e,this._w),this}floorToRef(I){return I.x=Math.floor(this._x),I.y=Math.floor(this._y),I.z=Math.floor(this._z),I.w=Math.floor(this._w),I}floor(){return new S(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z),Math.floor(this._w))}fractToRef(I){return I.x=this._x-Math.floor(this._x),I.y=this._y-Math.floor(this._y),I.z=this._z-Math.floor(this._z),I.w=this._w-Math.floor(this._w),I}fract(){return new S(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z),this._w-Math.floor(this._w))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){return this.normalizeToRef(new S)}normalizeToRef(I){const g=this.length();return 0===g||1===g?(I.x=this._x,I.y=this._y,I.z=this._z,I.w=this._w,I):this.scaleToRef(1/g,I)}toVector3(){return new k(this._x,this._y,this._z)}clone(){return new S(this._x,this._y,this._z,this._w)}G(I){return this.x=I.x,this.y=I.y,this.z=I.z,this.w=I.w,this}Db(I,g,b,e){return this.x=I,this.y=g,this.z=b,this.w=e,this}set(I,g,b,e){return this.Db(I,g,b,e)}kb(I){return this.x=this.y=this.z=this.w=I,this}dot(I){return this._x*I.x+this._y*I.y+this._z*I.z+this._w*I.w}static mb(I,g){return g||(g=0),new S(I[g],I[g+1],I[g+2],I[g+3])}static FromArrayToRef(I,g,b){return b.x=I[g],b.y=I[g+1],b.z=I[g+2],b.w=I[g+3],b}static FromFloatArrayToRef(I,g,b){return S.FromArrayToRef(I,g,b),b}static FromFloatsToRef(I,g,b,e,c){return c.x=I,c.y=g,c.z=b,c.w=e,c}static Zero(){return new S(0,0,0,0)}static One(){return new S(1,1,1,1)}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new S((0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.x=(0,o.RandomRange)(I,g),b.y=(0,o.RandomRange)(I,g),b.z=(0,o.RandomRange)(I,g),b.w=(0,o.RandomRange)(I,g),b}static Clamp(I,g,b){return S.ClampToRef(I,g,b,new S)}static ClampToRef(I,g,b,e){return e.x=(0,o.Clamp)(I.x,g.x,b.x),e.y=(0,o.Clamp)(I.y,g.y,b.y),e.z=(0,o.Clamp)(I.z,g.z,b.z),e.w=(0,o.Clamp)(I.w,g.w,b.w),e}static CheckExtends(I,g,b){g.minimizeInPlace(I),b.maximizeInPlace(I)}static get ZeroReadOnly(){return S._ZeroReadOnly}static Normalize(I){return S.NormalizeToRef(I,new S)}static NormalizeToRef(I,g){return I.normalizeToRef(g),g}static Minimize(I,g){const b=new S;return b.G(I),b.minimizeInPlace(g),b}static Maximize(I,g){const b=new S;return b.G(I),b.maximizeInPlace(g),b}static Distance(I,g){return Math.sqrt(S.DistanceSquared(I,g))}static DistanceSquared(I,g){const b=I.x-g.x,e=I.y-g.y,c=I.z-g.z,z=I.w-g.w;return b*b+e*e+c*c+z*z}static Center(I,g){return S.CenterToRef(I,g,new S)}static CenterToRef(I,g,b){return b.x=(I.x+g.x)/2,b.y=(I.y+g.y)/2,b.z=(I.z+g.z)/2,b.w=(I.w+g.w)/2,b}static TransformCoordinates(I,g){return S.TransformCoordinatesToRef(I,g,new S)}static TransformCoordinatesToRef(I,g,b){return S.TransformCoordinatesFromFloatsToRef(I._x,I._y,I._z,g,b),b}static TransformCoordinatesFromFloatsToRef(I,g,b,e,c){const z=e.m,M=I*z[0]+g*z[4]+b*z[8]+z[12],J=I*z[1]+g*z[5]+b*z[9]+z[13],o=I*z[2]+g*z[6]+b*z[10]+z[14],n=I*z[3]+g*z[7]+b*z[11]+z[15];return c.x=M,c.y=J,c.z=o,c.w=n,c}static TransformNormal(I,g){return S.TransformNormalToRef(I,g,new S)}static TransformNormalToRef(I,g,b){const e=g.m,c=I.x*e[0]+I.y*e[4]+I.z*e[8],z=I.x*e[1]+I.y*e[5]+I.z*e[9],M=I.x*e[2]+I.y*e[6]+I.z*e[10];return b.x=c,b.y=z,b.z=M,b.w=I.w,b}static TransformNormalFromFloatsToRef(I,g,b,e,c,z){const M=c.m;return z.x=I*M[0]+g*M[4]+b*M[8],z.y=I*M[1]+g*M[5]+b*M[9],z.z=I*M[2]+g*M[6]+b*M[10],z.w=e,z}static FromVector3(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new S(I._x,I._y,I._z,g)}static Dot(I,g){return I.x*g.x+I.y*g.y+I.z*g.z+I.w*g.w}}S._V8PerformanceHack=new S(.5,.5,.5,.5),S._ZeroReadOnly=S.Zero(),Object.defineProperties(S.prototype,{dimension:{value:[4]},rank:{value:1}});class f{get x(){return this._x}set x(I){this._x=I,this._isDirty=!0}get y(){return this._y}set y(I){this._y=I,this._isDirty=!0}get z(){return this._z}set z(I){this._z=I,this._isDirty=!0}get w(){return this._w}set w(I){this._w=I,this._isDirty=!0}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this._isDirty=!0,this._x=I,this._y=g,this._z=b,this._w=e}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){let I=x(this._x);return I=397*I^x(this._y),I=397*I^x(this._z),I=397*I^x(this._w),I}bb(){return[this._x,this._y,this._z,this._w]}toArray(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[g]=this._x,I[g+1]=this._y,I[g+2]=this._z,I[g+3]=this._w,this}Le(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f.FromArrayToRef(I,g,this)}equals(I){return I&&this._x===I._x&&this._y===I._y&&this._z===I._z&&this._w===I._w}equalsWithEpsilon(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.b;return I&&(0,o.WithinEpsilon)(this._x,I._x,g)&&(0,o.WithinEpsilon)(this._y,I._y,g)&&(0,o.WithinEpsilon)(this._z,I._z,g)&&(0,o.WithinEpsilon)(this._w,I._w,g)}isApprox(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.b;return I&&((0,o.WithinEpsilon)(this._x,I._x,g)&&(0,o.WithinEpsilon)(this._y,I._y,g)&&(0,o.WithinEpsilon)(this._z,I._z,g)&&(0,o.WithinEpsilon)(this._w,I._w,g)||(0,o.WithinEpsilon)(this._x,-I._x,g)&&(0,o.WithinEpsilon)(this._y,-I._y,g)&&(0,o.WithinEpsilon)(this._z,-I._z,g)&&(0,o.WithinEpsilon)(this._w,-I._w,g))}clone(){return new f(this._x,this._y,this._z,this._w)}G(I){return this._x=I._x,this._y=I._y,this._z=I._z,this._w=I._w,this._isDirty=!0,this}Db(I,g,b,e){return this._x=I,this._y=g,this._z=b,this._w=e,this._isDirty=!0,this}set(I,g,b,e){return this.Db(I,g,b,e)}kb(I){return this.Db(I,I,I,I)}add(I){return new f(this._x+I._x,this._y+I._y,this._z+I._z,this._w+I._w)}addInPlace(I){return this._x+=I._x,this._y+=I._y,this._z+=I._z,this._w+=I._w,this._isDirty=!0,this}addToRef(I,g){return g._x=this._x+I._x,g._y=this._y+I._y,g._z=this._z+I._z,g._w=this._w+I._w,g._isDirty=!0,g}addInPlaceFromFloats(I,g,b,e){return this._x+=I,this._y+=g,this._z+=b,this._w+=e,this._isDirty=!0,this}subtractToRef(I,g){return g._x=this._x-I._x,g._y=this._y-I._y,g._z=this._z-I._z,g._w=this._w-I._w,g._isDirty=!0,g}subtractFromFloats(I,g,b,e){return this.subtractFromFloatsToRef(I,g,b,e,new f)}subtractFromFloatsToRef(I,g,b,e,c){return c._x=this._x-I,c._y=this._y-g,c._z=this._z-b,c._w=this._w-e,c._isDirty=!0,c}ag(I){return new f(this._x-I._x,this._y-I._y,this._z-I._z,this._w-I._w)}Op(I){return this._x-=I._x,this._y-=I._y,this._z-=I._z,this._w-=I._w,this._isDirty=!0,this}scale(I){return new f(this._x*I,this._y*I,this._z*I,this._w*I)}scaleToRef(I,g){return g._x=this._x*I,g._y=this._y*I,g._z=this._z*I,g._w=this._w*I,g._isDirty=!0,g}scaleInPlace(I){return this._x*=I,this._y*=I,this._z*=I,this._w*=I,this._isDirty=!0,this}scaleAndAddToRef(I,g){return g._x+=this._x*I,g._y+=this._y*I,g._z+=this._z*I,g._w+=this._w*I,g._isDirty=!0,g}multiply(I){const g=new f(0,0,0,1);return this.multiplyToRef(I,g),g}multiplyToRef(I,g){const b=this._x*I._w+this._y*I._z-this._z*I._y+this._w*I._x,e=-this._x*I._z+this._y*I._w+this._z*I._x+this._w*I._y,c=this._x*I._y-this._y*I._x+this._z*I._w+this._w*I._z,z=-this._x*I._x-this._y*I._y-this._z*I._z+this._w*I._w;return g.Db(b,e,c,z),g}multiplyInPlace(I){return this.multiplyToRef(I,this)}multiplyByFloats(I,g,b,e){return this._x*=I,this._y*=g,this._z*=b,this._w*=e,this._isDirty=!0,this}divide(I){throw new ReferenceError("Can not divide a quaternion")}divideToRef(I,g){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(I){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new f)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(I){return I._x=-this._x,I._y=-this._y,I._z=-this._z,I._w=-this._w,I._isDirty=!0,I}equalsToFloats(I,g,b,e){return this._x===I&&this._y===g&&this._z===b&&this._w===e}floorToRef(I){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(I){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(I){return I.Db(-this._x,-this._y,-this._z,this._w),I}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new f(-this._x,-this._y,-this._z,this._w)}invert(){const I=this.conjugate(),g=this.lengthSquared();return 0==g||1==g||I.scaleInPlace(1/g),I}invertInPlace(){this.conjugateInPlace();const I=this.lengthSquared();return 0==I||1==I||this.scaleInPlace(1/I),this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(I){return 0===I||1===I?this:this.scaleInPlace(1/I)}normalizeToNew(){const I=new f(0,0,0,1);return this.normalizeToRef(I),I}normalizeToRef(I){const g=this.length();return 0===g||1===g?I.Db(this._x,this._y,this._z,this._w):this.scaleToRef(1/g,I)}toEulerAngles(){const I=k.Zero();return this.toEulerAnglesToRef(I),I}toEulerAnglesToRef(I){const g=this._z,b=this._x,e=this._y,c=this._w,z=e*g-b*c,M=.4999999;if(z<-M)I._y=2*Math.atan2(e,c),I._x=Math.PI/2,I._z=0,I._isDirty=!0;else if(z>M)I._y=2*Math.atan2(e,c),I._x=-Math.PI/2,I._z=0,I._isDirty=!0;else{const M=c*c,J=g*g,o=b*b,n=e*e;I._z=Math.atan2(2*(b*e+g*c),-J-o+n+M),I._x=Math.asin(-2*z),I._y=Math.atan2(2*(g*b+e*c),J-o-n+M),I._isDirty=!0}return I}toAlphaBetaGammaToRef(I){const g=this._z,b=this._x,e=this._y,c=this._w,z=Math.sqrt(b*b+e*e),M=Math.sqrt(g*g+c*c),J=2*Math.atan2(z,M),o=2*Math.atan2(g,c),n=2*Math.atan2(e,b),G=(o+n)/2,D=(o-n)/2;return I.set(D,J,G),I}toRotationMatrix(I){return V.FromQuaternionToRef(this,I),I}fromRotationMatrix(I){return f.FromRotationMatrixToRef(I,this),this}dot(I){return this._x*I._x+this._y*I._y+this._z*I._z+this._w*I._w}toAxisAngle(){const I=k.Zero();return{axis:I,angle:this.toAxisAngleToRef(I)}}toAxisAngleToRef(I){let g=0;const b=Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z),e=this._w;return b>0?(g=2*Math.atan2(b,e),I.set(this._x/b,this._y/b,this._z/b)):(g=0,I.set(1,0,0)),g}static FromRotationMatrix(I){const g=new f;return f.FromRotationMatrixToRef(I,g),g}static FromRotationMatrixToRef(I,g){const b=I.m,e=b[0],c=b[4],z=b[8],M=b[1],J=b[5],o=b[9],n=b[2],G=b[6],D=b[10],p=e+J+D;let x;return p>0?(x=.5/Math.sqrt(p+1),g._w=.25/x,g._x=(G-o)*x,g._y=(z-n)*x,g._z=(M-c)*x,g._isDirty=!0):e>J&&e>D?(x=2*Math.sqrt(1+e-J-D),g._w=(G-o)/x,g._x=.25*x,g._y=(c+M)/x,g._z=(z+n)/x,g._isDirty=!0):J>D?(x=2*Math.sqrt(1+J-e-D),g._w=(z-n)/x,g._x=(c+M)/x,g._y=.25*x,g._z=(o+G)/x,g._isDirty=!0):(x=2*Math.sqrt(1+D-e-J),g._w=(M-c)/x,g._x=(z+n)/x,g._y=(o+G)/x,g._z=.25*x,g._isDirty=!0),g}static Dot(I,g){return I._x*g._x+I._y*g._y+I._z*g._z+I._w*g._w}static AreClose(I,g){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1;const e=f.Dot(I,g);return 1-e*e<=b}static SmoothToRef(I,g,b,e,c){let z=0===e?1:b/e;return z=(0,o.Clamp)(z,0,1),f.SlerpToRef(I,g,z,c),c}static Zero(){return new f(0,0,0,0)}static Inverse(I){return new f(-I._x,-I._y,-I._z,I._w)}static InverseToRef(I,g){return g.set(-I._x,-I._y,-I._z,I._w),g}static Identity(){return new f(0,0,0,1)}static IsIdentity(I){return I&&0===I._x&&0===I._y&&0===I._z&&1===I._w}static RotationAxis(I,g){return f.RotationAxisToRef(I,g,new f)}static RotationAxisToRef(I,g,b){b._w=Math.cos(g/2);const e=Math.sin(g/2)/I.length();return b._x=I._x*e,b._y=I._y*e,b._z=I._z*e,b._isDirty=!0,b}static mb(I,g){return g||(g=0),new f(I[g],I[g+1],I[g+2],I[g+3])}static FromArrayToRef(I,g,b){return b._x=I[g],b._y=I[g+1],b._z=I[g+2],b._w=I[g+3],b._isDirty=!0,b}static FromFloatsToRef(I,g,b,e,c){return c.Db(I,g,b,e),c}static FromEulerAngles(I,g,b){const e=new f;return f.RotationYawPitchRollToRef(g,I,b,e),e}static FromEulerAnglesToRef(I,g,b,e){return f.RotationYawPitchRollToRef(g,I,b,e),e}static FromEulerVector(I){const g=new f;return f.RotationYawPitchRollToRef(I._y,I._x,I._z,g),g}static FromEulerVectorToRef(I,g){return f.RotationYawPitchRollToRef(I._y,I._x,I._z,g),g}static FromUnitVectorsToRef(I,g,b){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.b;const z=k.Dot(I,g)+1;return z<c?Math.abs(I.x)>Math.abs(I.z)?b.set(-I.y,I.x,0,0):b.set(0,-I.z,I.y,0):(k.CrossToRef(I,g,v.Vg[0]),b.set(v.Vg[0].x,v.Vg[0].y,v.Vg[0].z,z)),b.normalize()}static RotationYawPitchRoll(I,g,b){const e=new f;return f.RotationYawPitchRollToRef(I,g,b,e),e}static RotationYawPitchRollToRef(I,g,b,e){const c=.5*b,z=.5*g,M=.5*I,J=Math.sin(c),o=Math.cos(c),n=Math.sin(z),G=Math.cos(z),D=Math.sin(M),p=Math.cos(M);return e._x=p*n*o+D*G*J,e._y=D*G*o-p*n*J,e._z=p*G*J-D*n*o,e._w=p*G*o+D*n*J,e._isDirty=!0,e}static RotationAlphaBetaGamma(I,g,b){const e=new f;return f.RotationAlphaBetaGammaToRef(I,g,b,e),e}static RotationAlphaBetaGammaToRef(I,g,b,e){const c=.5*(b+I),z=.5*(b-I),M=.5*g;return e._x=Math.cos(z)*Math.sin(M),e._y=Math.sin(z)*Math.sin(M),e._z=Math.sin(c)*Math.cos(M),e._w=Math.cos(c)*Math.cos(M),e._isDirty=!0,e}static RotationQuaternionFromAxis(I,g,b){const e=new f(0,0,0,0);return f.RotationQuaternionFromAxisToRef(I,g,b,e),e}static RotationQuaternionFromAxisToRef(I,g,b,e){const c=a.Matrix[0];return I=I.normalizeToRef(a.Vg[0]),g=g.normalizeToRef(a.Vg[1]),b=b.normalizeToRef(a.Vg[2]),V.FromXYZAxesToRef(I,g,b,c),f.FromRotationMatrixToRef(c,e),e}static FromLookDirectionLH(I,g){const b=new f;return f.FromLookDirectionLHToRef(I,g,b),b}static FromLookDirectionLHToRef(I,g,b){const e=a.Matrix[0];return V.LookDirectionLHToRef(I,g,e),f.FromRotationMatrixToRef(e,b),b}static FromLookDirectionRH(I,g){const b=new f;return f.FromLookDirectionRHToRef(I,g,b),b}static FromLookDirectionRHToRef(I,g,b){const e=a.Matrix[0];return V.LookDirectionRHToRef(I,g,e),f.FromRotationMatrixToRef(e,b)}static Slerp(I,g,b){const e=f.Identity();return f.SlerpToRef(I,g,b,e),e}static SlerpToRef(I,g,b,e){let c,z,M=I._x*g._x+I._y*g._y+I._z*g._z+I._w*g._w,J=!1;if(M<0&&(J=!0,M=-M),M>.999999)z=1-b,c=J?-b:b;else{const I=Math.acos(M),g=1/Math.sin(I);z=Math.sin((1-b)*I)*g,c=J?-Math.sin(b*I)*g:Math.sin(b*I)*g}return e._x=z*I._x+c*g._x,e._y=z*I._y+c*g._y,e._z=z*I._z+c*g._z,e._w=z*I._w+c*g._w,e._isDirty=!0,e}static Hermite(I,g,b,e,c){const z=c*c,M=c*z,J=2*M-3*z+1,o=-2*M+3*z,n=M-2*z+c,G=M-z,D=I._x*J+b._x*o+g._x*n+e._x*G,p=I._y*J+b._y*o+g._y*n+e._y*G,x=I._z*J+b._z*o+g._z*n+e._z*G,Z=I._w*J+b._w*o+g._w*n+e._w*G;return new f(D,p,x,Z)}static Hermite1stDerivative(I,g,b,e,c){const z=new f;return this.Hermite1stDerivativeToRef(I,g,b,e,c,z),z}static Hermite1stDerivativeToRef(I,g,b,e,c,z){const M=c*c;return z._x=6*(M-c)*I._x+(3*M-4*c+1)*g._x+6*(-M+c)*b._x+(3*M-2*c)*e._x,z._y=6*(M-c)*I._y+(3*M-4*c+1)*g._y+6*(-M+c)*b._y+(3*M-2*c)*e._y,z._z=6*(M-c)*I._z+(3*M-4*c+1)*g._z+6*(-M+c)*b._z+(3*M-2*c)*e._z,z._w=6*(M-c)*I._w+(3*M-4*c+1)*g._w+6*(-M+c)*b._w+(3*M-2*c)*e._w,z._isDirty=!0,z}static Normalize(I){const g=f.Zero();return f.NormalizeToRef(I,g),g}static NormalizeToRef(I,g){return I.normalizeToRef(g),g}static Clamp(I,g,b){const e=new f;return f.ClampToRef(I,g,b,e),e}static ClampToRef(I,g,b,e){return e.Db((0,o.Clamp)(I.x,g.x,b.x),(0,o.Clamp)(I.y,g.y,b.y),(0,o.Clamp)(I.z,g.z,b.z),(0,o.Clamp)(I.w,g.w,b.w))}static Random(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new f((0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g))}static RandomToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(arguments.length>2?arguments[2]:void 0).Db((0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g),(0,o.RandomRange)(I,g))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(I,g){return Math.sqrt(f.DistanceSquared(I,g))}static DistanceSquared(I,g){const b=I.x-g.x,e=I.y-g.y,c=I.z-g.z,z=I.w-g.w;return b*b+e*e+c*c+z*z}static Center(I,g){return f.CenterToRef(I,g,f.Zero())}static CenterToRef(I,g,b){return b.Db((I.x+g.x)/2,(I.y+g.y)/2,(I.z+g.z)/2,(I.w+g.w)/2)}}f._V8PerformanceHack=new f(.5,.5,.5,.5),Object.defineProperties(f.prototype,{dimension:{value:[4]},rank:{value:1}});class V{static get Use64Bits(){return M.b.MatrixUse64Bits}get m(){return this.Ug}markAsUpdated(){this.updateFlag=n._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(I){let g=arguments.length>1&&void 0!==arguments[1]&&arguments[1],b=arguments.length>2&&void 0!==arguments[2]&&arguments[2],e=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._isIdentity=I,this._isIdentity3x2=I||b,this._isIdentityDirty=!this._isIdentity&&g,this._isIdentity3x2Dirty=!this._isIdentity3x2&&e}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,M.b.MatrixTrackPrecisionChange&&M.b.MatrixTrackedMatrices.push(this),this.Ug=new M.b.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const I=this.Ug;this._isIdentity=1===I[0]&&0===I[1]&&0===I[2]&&0===I[3]&&0===I[4]&&1===I[5]&&0===I[6]&&0===I[7]&&0===I[8]&&0===I[9]&&1===I[10]&&0===I[11]&&0===I[12]&&0===I[13]&&0===I[14]&&1===I[15]}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,1!==this.Ug[0]||1!==this.Ug[5]||1!==this.Ug[15]||0!==this.Ug[1]||0!==this.Ug[2]||0!==this.Ug[3]||0!==this.Ug[4]||0!==this.Ug[6]||0!==this.Ug[7]||0!==this.Ug[8]||0!==this.Ug[9]||0!==this.Ug[10]||0!==this.Ug[11]||0!==this.Ug[12]||0!==this.Ug[13]||0!==this.Ug[14]?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;const I=this.Ug,g=I[0],b=I[1],e=I[2],c=I[3],z=I[4],M=I[5],J=I[6],o=I[7],n=I[8],G=I[9],D=I[10],p=I[11],x=I[12],Z=I[13],k=I[14],S=I[15],f=D*S-k*p,V=G*S-Z*p,a=G*k-Z*D,v=n*S-x*p,X=n*k-D*x,R=n*Z-x*G;return g*+(M*f-J*V+o*a)+b*-(z*f-J*v+o*X)+e*+(z*V-M*v+o*R)+c*-(z*a-M*X+J*R)}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!I)return this.Ug;const b=this.Ug;for(let e=0;e<16;e++)I[g+e]=b[e];return this}bb(){return this.Ug}Le(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V.FromArrayToRef(I,g,this)}Db(){for(var I=arguments.length,g=new Array(I),b=0;b<I;b++)g[b]=arguments[b];return V.FromArrayToRef(g,0,this)}set(){const I=this.Ug;for(let g=0;g<16;g++)I[g]=g<0||arguments.length<=g?void 0:arguments[g];return this.markAsUpdated(),this}kb(I){const g=this.Ug;for(let b=0;b<16;b++)g[b]=I;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return V.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(I){const g=new V;return this.addToRef(I,g),g}addToRef(I,g){const b=this.Ug,e=g.Ug,c=I.m;for(let z=0;z<16;z++)e[z]=b[z]+c[z];return g.markAsUpdated(),g}addToSelf(I){const g=this.Ug,b=I.m;return g[0]+=b[0],g[1]+=b[1],g[2]+=b[2],g[3]+=b[3],g[4]+=b[4],g[5]+=b[5],g[6]+=b[6],g[7]+=b[7],g[8]+=b[8],g[9]+=b[9],g[10]+=b[10],g[11]+=b[11],g[12]+=b[12],g[13]+=b[13],g[14]+=b[14],g[15]+=b[15],this.markAsUpdated(),this}addInPlace(I){const g=this.Ug,b=I.m;for(let e=0;e<16;e++)g[e]+=b[e];return this.markAsUpdated(),this}addInPlaceFromFloats(){const I=this.Ug;for(let g=0;g<16;g++)I[g]+=g<0||arguments.length<=g?void 0:arguments[g];return this.markAsUpdated(),this}ag(I){const g=this.Ug,b=I.m;for(let e=0;e<16;e++)g[e]-=b[e];return this.markAsUpdated(),this}subtractToRef(I,g){const b=this.Ug,e=I.m,c=g.Ug;for(let z=0;z<16;z++)c[z]=b[z]-e[z];return g.markAsUpdated(),g}Op(I){const g=this.Ug,b=I.m;for(let e=0;e<16;e++)g[e]-=b[e];return this.markAsUpdated(),this}subtractFromFloats(){for(var I=arguments.length,g=new Array(I),b=0;b<I;b++)g[b]=arguments[b];return this.subtractFromFloatsToRef(...g,new V)}subtractFromFloatsToRef(){for(var I=arguments.length,g=new Array(I),b=0;b<I;b++)g[b]=arguments[b];const e=g.pop(),c=this.Ug,z=e.Ug,M=g;for(let J=0;J<16;J++)z[J]=c[J]-M[J];return e.markAsUpdated(),e}invertToRef(I){return!0===this._isIdentity?(V.IdentityToRef(I),I):(p(this,I.bb())?I.markAsUpdated():I.G(this),I)}addAtIndex(I,g){return this.Ug[I]+=g,this.markAsUpdated(),this}multiplyAtIndex(I,g){return this.Ug[I]*=g,this.markAsUpdated(),this}setTranslationFromFloats(I,g,b){return this.Ug[12]=I,this.Ug[13]=g,this.Ug[14]=b,this.markAsUpdated(),this}addTranslationFromFloats(I,g,b){return this.Ug[12]+=I,this.Ug[13]+=g,this.Ug[14]+=b,this.markAsUpdated(),this}setTranslation(I){return this.setTranslationFromFloats(I._x,I._y,I._z)}getTranslation(){return new k(this.Ug[12],this.Ug[13],this.Ug[14])}getTranslationToRef(I){return I.x=this.Ug[12],I.y=this.Ug[13],I.z=this.Ug[14],I}removeRotationAndScaling(){const I=this.m;return V.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,I[12],I[13],I[14],I[15],this),this._updateIdentityStatus(0===I[12]&&0===I[13]&&0===I[14]&&1===I[15]),this}G(I){I.copyToArray(this.Ug);const g=I;return this.updateFlag=g.updateFlag,this._updateIdentityStatus(g._isIdentity,g._isIdentityDirty,g._isIdentity3x2,g._isIdentity3x2Dirty),this}copyToArray(I){return D(this,I,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),this}multiply(I){const g=new V;return this.multiplyToRef(I,g),g}multiplyInPlace(I){const g=this.Ug,b=I.m;for(let e=0;e<16;e++)g[e]*=b[e];return this.markAsUpdated(),this}multiplyByFloats(){const I=this.Ug;for(let g=0;g<16;g++)I[g]*=g<0||arguments.length<=g?void 0:arguments[g];return this.markAsUpdated(),this}multiplyByFloatsToRef(){for(var I=arguments.length,g=new Array(I),b=0;b<I;b++)g[b]=arguments[b];const e=g.pop(),c=this.Ug,z=e.Ug,M=g;for(let J=0;J<16;J++)z[J]=c[J]*M[J];return e.markAsUpdated(),e}multiplyToRef(I,g){return this._isIdentity?(g.G(I),g):I._isIdentity?(g.G(this),g):(this.multiplyToArray(I,g.Ug,0),g.markAsUpdated(),g)}multiplyToArray(I,g,b){return G(this,I,g,b),this}divide(I){return this.divideToRef(I,new V)}divideToRef(I,g){const b=this.Ug,e=I.m,c=g.Ug;for(let z=0;z<16;z++)c[z]=b[z]/e[z];return g.markAsUpdated(),g}divideInPlace(I){const g=this.Ug,b=I.m;for(let e=0;e<16;e++)g[e]/=b[e];return this.markAsUpdated(),this}minimizeInPlace(I){const g=this.Ug,b=I.m;for(let e=0;e<16;e++)g[e]=Math.min(g[e],b[e]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(){const I=this.Ug;for(let g=0;g<16;g++)I[g]=Math.min(I[g],g<0||arguments.length<=g?void 0:arguments[g]);return this.markAsUpdated(),this}maximizeInPlace(I){const g=this.Ug,b=I.m;for(let e=0;e<16;e++)g[e]=Math.min(g[e],b[e]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(){const I=this.Ug;for(let g=0;g<16;g++)I[g]=Math.min(I[g],g<0||arguments.length<=g?void 0:arguments[g]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new V)}negateInPlace(){const I=this.Ug;for(let g=0;g<16;g++)I[g]=-I[g];return this.markAsUpdated(),this}negateToRef(I){const g=this.Ug,b=I.Ug;for(let e=0;e<16;e++)b[e]=-g[e];return I.markAsUpdated(),I}equals(I){const g=I;if(!g)return!1;if((this._isIdentity||g._isIdentity)&&!this._isIdentityDirty&&!g._isIdentityDirty)return this._isIdentity&&g._isIdentity;const b=this.m,e=g.m;return b[0]===e[0]&&b[1]===e[1]&&b[2]===e[2]&&b[3]===e[3]&&b[4]===e[4]&&b[5]===e[5]&&b[6]===e[6]&&b[7]===e[7]&&b[8]===e[8]&&b[9]===e[9]&&b[10]===e[10]&&b[11]===e[11]&&b[12]===e[12]&&b[13]===e[13]&&b[14]===e[14]&&b[15]===e[15]}equalsWithEpsilon(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=this.Ug,e=I.m;for(let c=0;c<16;c++)if(!(0,o.WithinEpsilon)(b[c],e[c],g))return!1;return!0}equalsToFloats(){const I=this.Ug;for(let g=0;g<16;g++)if(I[g]!=(g<0||arguments.length<=g?void 0:arguments[g]))return!1;return!0}floor(){return this.floorToRef(new V)}floorToRef(I){const g=this.Ug,b=I.Ug;for(let e=0;e<16;e++)b[e]=Math.floor(g[e]);return I.markAsUpdated(),I}fract(){return this.fractToRef(new V)}fractToRef(I){const g=this.Ug,b=I.Ug;for(let e=0;e<16;e++)b[e]=g[e]-Math.floor(g[e]);return I.markAsUpdated(),I}clone(){const I=new V;return I.G(this),I}getClassName(){return"Matrix"}getHashCode(){let I=x(this.Ug[0]);for(let g=1;g<16;g++)I=397*I^x(this.Ug[g]);return I}decomposeToTransformNode(I){return I.rotationQuaternion=I.rotationQuaternion||new f,this.decompose(I.pb,I.rotationQuaternion,I.position)}decompose(I,g,b,e){let c=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(this._isIdentity)return b&&b.kb(0),I&&I.kb(1),g&&g.Db(0,0,0,1),!0;const z=this.Ug;if(b&&b.Db(z[12],z[13],z[14]),(I=I||a.Vg[0]).x=Math.sqrt(z[0]*z[0]+z[1]*z[1]+z[2]*z[2]),I.y=Math.sqrt(z[4]*z[4]+z[5]*z[5]+z[6]*z[6]),I.z=Math.sqrt(z[8]*z[8]+z[9]*z[9]+z[10]*z[10]),e){const g=(c?e.absoluteScaling.x:e.pb.x)<0?-1:1,b=(c?e.absoluteScaling.y:e.pb.y)<0?-1:1,z=(c?e.absoluteScaling.z:e.pb.z)<0?-1:1;I.x*=g,I.y*=b,I.z*=z}else this.determinant()<=0&&(I.y*=-1);if(0===I._x||0===I._y||0===I._z)return g&&g.Db(0,0,0,1),!1;if(g){const b=1/I._x,e=1/I._y,c=1/I._z;V.FromValuesToRef(z[0]*b,z[1]*b,z[2]*b,0,z[4]*e,z[5]*e,z[6]*e,0,z[8]*c,z[9]*c,z[10]*c,0,0,0,0,1,a.Matrix[0]),f.FromRotationMatrixToRef(a.Matrix[0],g)}return!0}getRow(I){if(I<0||I>3)return null;const g=4*I;return new S(this.Ug[g+0],this.Ug[g+1],this.Ug[g+2],this.Ug[g+3])}getRowToRef(I,g){if(I>=0&&I<=3){const b=4*I;g.x=this.Ug[b+0],g.y=this.Ug[b+1],g.z=this.Ug[b+2],g.w=this.Ug[b+3]}return g}setRow(I,g){return this.setRowFromFloats(I,g.x,g.y,g.z,g.w)}transpose(){const I=new V;return V.TransposeToRef(this,I),I}transposeToRef(I){return V.TransposeToRef(this,I),I}setRowFromFloats(I,g,b,e,c){if(I<0||I>3)return this;const z=4*I;return this.Ug[z+0]=g,this.Ug[z+1]=b,this.Ug[z+2]=e,this.Ug[z+3]=c,this.markAsUpdated(),this}scale(I){const g=new V;return this.scaleToRef(I,g),g}scaleToRef(I,g){for(let b=0;b<16;b++)g.Ug[b]=this.Ug[b]*I;return g.markAsUpdated(),g}scaleAndAddToRef(I,g){for(let b=0;b<16;b++)g.Ug[b]+=this.Ug[b]*I;return g.markAsUpdated(),g}scaleInPlace(I){const g=this.Ug;for(let b=0;b<16;b++)g[b]*=I;return this.markAsUpdated(),this}toNormalMatrix(I){const g=a.Matrix[0];this.invertToRef(g),g.transposeToRef(I);const b=I.Ug;return V.FromValuesToRef(b[0],b[1],b[2],0,b[4],b[5],b[6],0,b[8],b[9],b[10],0,0,0,0,1,I),I}getRotationMatrix(){const I=new V;return this.getRotationMatrixToRef(I),I}getRotationMatrixToRef(I){const g=a.Vg[0];if(!this.decompose(g))return V.IdentityToRef(I),I;const b=this.Ug,e=1/g._x,c=1/g._y,z=1/g._z;return V.FromValuesToRef(b[0]*e,b[1]*e,b[2]*e,0,b[4]*c,b[5]*c,b[6]*c,0,b[8]*z,b[9]*z,b[10]*z,0,0,0,0,1,I),I}toggleModelMatrixHandInPlace(){const I=this.Ug;return I[2]*=-1,I[6]*=-1,I[8]*=-1,I[9]*=-1,I[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const I=this.Ug;return I[8]*=-1,I[9]*=-1,I[10]*=-1,I[11]*=-1,this.markAsUpdated(),this}static mb(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const b=new V;return V.FromArrayToRef(I,g,b),b}static FromArrayToRef(I,g,b){for(let e=0;e<16;e++)b.Ug[e]=I[e+g];return b.markAsUpdated(),b}static FromFloat32ArrayToRefScaled(I,g,b,e){return e.Ug[0]=I[0+g]*b,e.Ug[1]=I[1+g]*b,e.Ug[2]=I[2+g]*b,e.Ug[3]=I[3+g]*b,e.Ug[4]=I[4+g]*b,e.Ug[5]=I[5+g]*b,e.Ug[6]=I[6+g]*b,e.Ug[7]=I[7+g]*b,e.Ug[8]=I[8+g]*b,e.Ug[9]=I[9+g]*b,e.Ug[10]=I[10+g]*b,e.Ug[11]=I[11+g]*b,e.Ug[12]=I[12+g]*b,e.Ug[13]=I[13+g]*b,e.Ug[14]=I[14+g]*b,e.Ug[15]=I[15+g]*b,e.markAsUpdated(),e}static get IdentityReadOnly(){return V._IdentityReadOnly}static FromValuesToRef(I,g,b,e,c,z,M,J,o,n,G,D,p,x,Z,k,S){const f=S.Ug;f[0]=I,f[1]=g,f[2]=b,f[3]=e,f[4]=c,f[5]=z,f[6]=M,f[7]=J,f[8]=o,f[9]=n,f[10]=G,f[11]=D,f[12]=p,f[13]=x,f[14]=Z,f[15]=k,S.markAsUpdated()}static FromValues(I,g,b,e,c,z,M,J,o,n,G,D,p,x,Z,k){const S=new V,f=S.Ug;return f[0]=I,f[1]=g,f[2]=b,f[3]=e,f[4]=c,f[5]=z,f[6]=M,f[7]=J,f[8]=o,f[9]=n,f[10]=G,f[11]=D,f[12]=p,f[13]=x,f[14]=Z,f[15]=k,S.markAsUpdated(),S}static Compose(I,g,b){const e=new V;return V.ComposeToRef(I,g,b,e),e}static ComposeToRef(I,g,b,e){const c=e.Ug,z=g._x,M=g._y,J=g._z,o=g._w,n=z+z,G=M+M,D=J+J,p=z*n,x=z*G,Z=z*D,k=M*G,S=M*D,f=J*D,V=o*n,a=o*G,v=o*D,X=I._x,R=I._y,E=I._z;return c[0]=(1-(k+f))*X,c[1]=(x+v)*X,c[2]=(Z-a)*X,c[3]=0,c[4]=(x-v)*R,c[5]=(1-(p+f))*R,c[6]=(S+V)*R,c[7]=0,c[8]=(Z+a)*E,c[9]=(S-V)*E,c[10]=(1-(p+k))*E,c[11]=0,c[12]=b._x,c[13]=b._y,c[14]=b._z,c[15]=1,e.markAsUpdated(),e}static Identity(){const I=V.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return I._updateIdentityStatus(!0),I}static IdentityToRef(I){return V.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,I),I._updateIdentityStatus(!0),I}static Zero(){const I=V.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return I._updateIdentityStatus(!1),I}static RotationX(I){const g=new V;return V.RotationXToRef(I,g),g}static Invert(I){const g=new V;return I.invertToRef(g),g}static RotationXToRef(I,g){const b=Math.sin(I),e=Math.cos(I);return V.FromValuesToRef(1,0,0,0,0,e,b,0,0,-b,e,0,0,0,0,1,g),g._updateIdentityStatus(1===e&&0===b),g}static RotationY(I){const g=new V;return V.RotationYToRef(I,g),g}static RotationYToRef(I,g){const b=Math.sin(I),e=Math.cos(I);return V.FromValuesToRef(e,0,-b,0,0,1,0,0,b,0,e,0,0,0,0,1,g),g._updateIdentityStatus(1===e&&0===b),g}static RotationZ(I){const g=new V;return V.RotationZToRef(I,g),g}static RotationZToRef(I,g){const b=Math.sin(I),e=Math.cos(I);return V.FromValuesToRef(e,b,0,0,-b,e,0,0,0,0,1,0,0,0,0,1,g),g._updateIdentityStatus(1===e&&0===b),g}static RotationAxis(I,g){const b=new V;return V.RotationAxisToRef(I,g,b),b}static RotationAxisToRef(I,g,b){const e=Math.sin(-g),c=Math.cos(-g),z=1-c;I=I.normalizeToRef(a.Vg[0]);const M=b.Ug;return M[0]=I._x*I._x*z+c,M[1]=I._x*I._y*z-I._z*e,M[2]=I._x*I._z*z+I._y*e,M[3]=0,M[4]=I._y*I._x*z+I._z*e,M[5]=I._y*I._y*z+c,M[6]=I._y*I._z*z-I._x*e,M[7]=0,M[8]=I._z*I._x*z-I._y*e,M[9]=I._z*I._y*z+I._x*e,M[10]=I._z*I._z*z+c,M[11]=0,M[12]=0,M[13]=0,M[14]=0,M[15]=1,b.markAsUpdated(),b}static RotationAlignToRef(I,g,b){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const z=k.Dot(g,I),M=b.Ug;if(z<-1+e.b)M[0]=-1,M[1]=0,M[2]=0,M[3]=0,M[4]=0,M[5]=c?1:-1,M[6]=0,M[7]=0,M[8]=0,M[9]=0,M[10]=c?-1:1,M[11]=0;else{const b=k.Cross(g,I),e=1/(1+z);M[0]=b._x*b._x*e+z,M[1]=b._y*b._x*e-b._z,M[2]=b._z*b._x*e+b._y,M[3]=0,M[4]=b._x*b._y*e+b._z,M[5]=b._y*b._y*e+z,M[6]=b._z*b._y*e-b._x,M[7]=0,M[8]=b._x*b._z*e-b._y,M[9]=b._y*b._z*e+b._x,M[10]=b._z*b._z*e+z,M[11]=0}return M[12]=0,M[13]=0,M[14]=0,M[15]=1,b.markAsUpdated(),b}static RotationYawPitchRoll(I,g,b){const e=new V;return V.RotationYawPitchRollToRef(I,g,b,e),e}static RotationYawPitchRollToRef(I,g,b,e){return f.RotationYawPitchRollToRef(I,g,b,a.Quaternion[0]),a.Quaternion[0].toRotationMatrix(e),e}static Scaling(I,g,b){const e=new V;return V.ScalingToRef(I,g,b,e),e}static ScalingToRef(I,g,b,e){return V.FromValuesToRef(I,0,0,0,0,g,0,0,0,0,b,0,0,0,0,1,e),e._updateIdentityStatus(1===I&&1===g&&1===b),e}static Translation(I,g,b){const e=new V;return V.TranslationToRef(I,g,b,e),e}static TranslationToRef(I,g,b,e){return V.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,I,g,b,1,e),e._updateIdentityStatus(0===I&&0===g&&0===b),e}static Lerp(I,g,b){const e=new V;return V.LerpToRef(I,g,b,e),e}static LerpToRef(I,g,b,e){const c=e.Ug,z=I.m,M=g.m;for(let J=0;J<16;J++)c[J]=z[J]*(1-b)+M[J]*b;return e.markAsUpdated(),e}static DecomposeLerp(I,g,b){const e=new V;return V.DecomposeLerpToRef(I,g,b,e),e}static DecomposeLerpToRef(I,g,b,e){const c=a.Vg[0],z=a.Quaternion[0],M=a.Vg[1];I.decompose(c,z,M);const J=a.Vg[2],o=a.Quaternion[1],n=a.Vg[3];g.decompose(J,o,n);const G=a.Vg[4];k.LerpToRef(c,J,b,G);const D=a.Quaternion[2];f.SlerpToRef(z,o,b,D);const p=a.Vg[5];return k.LerpToRef(M,n,b,p),V.ComposeToRef(G,D,p,e),e}static LookAtLH(I,g,b){const e=new V;return V.LookAtLHToRef(I,g,b,e),e}static LookAtLHToRef(I,g,b,e){const c=a.Vg[0],z=a.Vg[1],M=a.Vg[2];g.subtractToRef(I,M),M.normalize(),k.CrossToRef(b,M,c);const J=c.lengthSquared();0===J?c.x=1:c.normalizeFromLength(Math.sqrt(J)),k.CrossToRef(M,c,z),z.normalize();const o=-k.Dot(c,I),n=-k.Dot(z,I),G=-k.Dot(M,I);return V.FromValuesToRef(c._x,z._x,M._x,0,c._y,z._y,M._y,0,c._z,z._z,M._z,0,o,n,G,1,e),e}static LookAtRH(I,g,b){const e=new V;return V.LookAtRHToRef(I,g,b,e),e}static LookAtRHToRef(I,g,b,e){const c=a.Vg[0],z=a.Vg[1],M=a.Vg[2];I.subtractToRef(g,M),M.normalize(),k.CrossToRef(b,M,c);const J=c.lengthSquared();0===J?c.x=1:c.normalizeFromLength(Math.sqrt(J)),k.CrossToRef(M,c,z),z.normalize();const o=-k.Dot(c,I),n=-k.Dot(z,I),G=-k.Dot(M,I);return V.FromValuesToRef(c._x,z._x,M._x,0,c._y,z._y,M._y,0,c._z,z._z,M._z,0,o,n,G,1,e),e}static LookDirectionLH(I,g){const b=new V;return V.LookDirectionLHToRef(I,g,b),b}static LookDirectionLHToRef(I,g,b){const e=a.Vg[0];e.G(I),e.scaleInPlace(-1);const c=a.Vg[1];return k.CrossToRef(g,e,c),V.FromValuesToRef(c._x,c._y,c._z,0,g._x,g._y,g._z,0,e._x,e._y,e._z,0,0,0,0,1,b),b}static LookDirectionRH(I,g){const b=new V;return V.LookDirectionRHToRef(I,g,b),b}static LookDirectionRHToRef(I,g,b){const e=a.Vg[2];return k.CrossToRef(g,I,e),V.FromValuesToRef(e._x,e._y,e._z,0,g._x,g._y,g._z,0,I._x,I._y,I._z,0,0,0,0,1,b),b}static OrthoLH(I,g,b,e,c){const z=new V;return V.OrthoLHToRef(I,g,b,e,z,c),z}static OrthoLHToRef(I,g,b,e,c,z){const M=2/I,J=2/g,o=2/(e-b),n=-(e+b)/(e-b);return V.FromValuesToRef(M,0,0,0,0,J,0,0,0,0,o,0,0,0,n,1,c),z&&c.multiplyToRef(X,c),c._updateIdentityStatus(1===M&&1===J&&1===o&&0===n),c}static OrthoOffCenterLH(I,g,b,e,c,z,M){const J=new V;return V.OrthoOffCenterLHToRef(I,g,b,e,c,z,J,M),J}static OrthoOffCenterLHToRef(I,g,b,e,c,z,M,J){const o=2/(g-I),n=2/(e-b),G=2/(z-c),D=-(z+c)/(z-c),p=(I+g)/(I-g),x=(e+b)/(b-e);return V.FromValuesToRef(o,0,0,0,0,n,0,0,0,0,G,0,p,x,D,1,M),J&&M.multiplyToRef(X,M),M.markAsUpdated(),M}static ObliqueOffCenterLHToRef(I,g,b,e,c,z,M,J,o,n,G){const D=-M*Math.cos(J),p=-M*Math.sin(J);return V.TranslationToRef(0,0,-o,a.Matrix[1]),V.FromValuesToRef(1,0,0,0,0,1,0,0,D,p,1,0,0,0,0,1,a.Matrix[0]),a.Matrix[1].multiplyToRef(a.Matrix[0],a.Matrix[0]),V.TranslationToRef(0,0,o,a.Matrix[1]),a.Matrix[0].multiplyToRef(a.Matrix[1],a.Matrix[0]),V.OrthoOffCenterLHToRef(I,g,b,e,c,z,n,G),a.Matrix[0].multiplyToRef(n,n),n}static OrthoOffCenterRH(I,g,b,e,c,z,M){const J=new V;return V.OrthoOffCenterRHToRef(I,g,b,e,c,z,J,M),J}static OrthoOffCenterRHToRef(I,g,b,e,c,z,M,J){return V.OrthoOffCenterLHToRef(I,g,b,e,c,z,M,J),M.Ug[10]*=-1,M}static ObliqueOffCenterRHToRef(I,g,b,e,c,z,M,J,o,n,G){const D=M*Math.cos(J),p=M*Math.sin(J);return V.TranslationToRef(0,0,o,a.Matrix[1]),V.FromValuesToRef(1,0,0,0,0,1,0,0,D,p,1,0,0,0,0,1,a.Matrix[0]),a.Matrix[1].multiplyToRef(a.Matrix[0],a.Matrix[0]),V.TranslationToRef(0,0,-o,a.Matrix[1]),a.Matrix[0].multiplyToRef(a.Matrix[1],a.Matrix[0]),V.OrthoOffCenterRHToRef(I,g,b,e,c,z,n,G),a.Matrix[0].multiplyToRef(n,n),n}static PerspectiveLH(I,g,b,e,c){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const M=new V,J=2*b/I,o=2*b/g,n=(e+b)/(e-b),G=-2*e*b/(e-b),D=Math.tan(z);return V.FromValuesToRef(J,0,0,0,0,o,0,D,0,0,n,1,0,0,G,0,M),c&&M.multiplyToRef(X,M),M._updateIdentityStatus(!1),M}static PerspectiveFovLH(I,g,b,e,c){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,M=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const J=new V;return V.PerspectiveFovLHToRef(I,g,b,e,J,!0,c,z,M),J}static PerspectiveFovLHToRef(I,g,b,e,c){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],M=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,o=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const n=b,G=e,D=1/Math.tan(.5*I),p=z?D/g:D,x=z?D:D*g,Z=o&&0===n?-1:0!==G?(G+n)/(G-n):1,k=o&&0===n?2*G:0!==G?-2*G*n/(G-n):-2*n,S=Math.tan(J);return V.FromValuesToRef(p,0,0,0,0,x,0,S,0,0,Z,1,0,0,k,0,c),M&&c.multiplyToRef(X,c),c._updateIdentityStatus(!1),c}static PerspectiveFovReverseLHToRef(I,g,b,e,c){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],M=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const o=1/Math.tan(.5*I),n=z?o/g:o,G=z?o:o*g,D=Math.tan(J);return V.FromValuesToRef(n,0,0,0,0,G,0,D,0,0,-b,1,0,0,1,0,c),M&&c.multiplyToRef(X,c),c._updateIdentityStatus(!1),c}static PerspectiveFovRH(I,g,b,e,c){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,M=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const J=new V;return V.PerspectiveFovRHToRef(I,g,b,e,J,!0,c,z,M),J}static PerspectiveFovRHToRef(I,g,b,e,c){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],M=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,o=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const n=b,G=e,D=1/Math.tan(.5*I),p=z?D/g:D,x=z?D:D*g,Z=o&&0===n?1:0!==G?-(G+n)/(G-n):-1,k=o&&0===n?2*G:0!==G?-2*G*n/(G-n):-2*n,S=Math.tan(J);return V.FromValuesToRef(p,0,0,0,0,x,0,S,0,0,Z,-1,0,0,k,0,c),M&&c.multiplyToRef(X,c),c._updateIdentityStatus(!1),c}static PerspectiveFovReverseRHToRef(I,g,b,e,c){let z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],M=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;const o=1/Math.tan(.5*I),n=z?o/g:o,G=z?o:o*g,D=Math.tan(J);return V.FromValuesToRef(n,0,0,0,0,G,0,D,0,0,-b,-1,0,0,-1,0,c),M&&c.multiplyToRef(X,c),c._updateIdentityStatus(!1),c}static GetFinalMatrix(I,g,b,e,c,z){const M=I.width,J=I.height,o=I.x,n=I.y,G=V.FromValues(M/2,0,0,0,0,-J/2,0,0,0,0,z-c,0,o+M/2,J/2+n,c,1),D=new V;return g.multiplyToRef(b,D),D.multiplyToRef(e,D),D.multiplyToRef(G,D)}static GetAsMatrix2x2(I){const g=I.m,b=[g[0],g[1],g[4],g[5]];return M.b.MatrixUse64Bits?b:new Float32Array(b)}static GetAsMatrix3x3(I){const g=I.m,b=[g[0],g[1],g[2],g[4],g[5],g[6],g[8],g[9],g[10]];return M.b.MatrixUse64Bits?b:new Float32Array(b)}static Transpose(I){const g=new V;return V.TransposeToRef(I,g),g}static TransposeToRef(I,g){const b=I.m,e=b[0],c=b[4],z=b[8],M=b[12],J=b[1],o=b[5],n=b[9],G=b[13],D=b[2],p=b[6],x=b[10],Z=b[14],k=b[3],S=b[7],f=b[11],V=b[15],a=g.Ug;return a[0]=e,a[1]=c,a[2]=z,a[3]=M,a[4]=J,a[5]=o,a[6]=n,a[7]=G,a[8]=D,a[9]=p,a[10]=x,a[11]=Z,a[12]=k,a[13]=S,a[14]=f,a[15]=V,g.markAsUpdated(),g._updateIdentityStatus(I._isIdentity,I._isIdentityDirty),g}static Reflection(I){const g=new V;return V.ReflectionToRef(I,g),g}static ReflectionToRef(I,g){I.normalize();const b=I.normal.x,e=I.normal.y,c=I.normal.z,z=-2*b,M=-2*e,J=-2*c;return V.FromValuesToRef(z*b+1,M*b,J*b,0,z*e,M*e+1,J*e,0,z*c,M*c,J*c+1,0,z*I.d,M*I.d,J*I.d,1,g),g}static FromXYZAxesToRef(I,g,b,e){return V.FromValuesToRef(I._x,I._y,I._z,0,g._x,g._y,g._z,0,b._x,b._y,b._z,0,0,0,0,1,e),e}static FromQuaternionToRef(I,g){const b=I._x*I._x,e=I._y*I._y,c=I._z*I._z,z=I._x*I._y,M=I._z*I._w,J=I._z*I._x,o=I._y*I._w,n=I._y*I._z,G=I._x*I._w;return g.Ug[0]=1-2*(e+c),g.Ug[1]=2*(z+M),g.Ug[2]=2*(J-o),g.Ug[3]=0,g.Ug[4]=2*(z-M),g.Ug[5]=1-2*(c+b),g.Ug[6]=2*(n+G),g.Ug[7]=0,g.Ug[8]=2*(J+o),g.Ug[9]=2*(n-G),g.Ug[10]=1-2*(e+b),g.Ug[11]=0,g.Ug[12]=0,g.Ug[13]=0,g.Ug[14]=0,g.Ug[15]=1,g.markAsUpdated(),g}}V._IdentityReadOnly=V.Identity(),Object.defineProperties(V.prototype,{dimension:{value:[4,4]},rank:{value:2}});class a{}a.Vg=(0,c.f)(11,k.Zero),a.Matrix=(0,c.f)(2,V.Identity),a.Quaternion=(0,c.f)(3,f.Zero);class v{}v.Vector2=(0,c.f)(3,Z.Zero),v.Vg=(0,c.f)(13,k.Zero),v.Vector4=(0,c.f)(3,S.Zero),v.Quaternion=(0,c.f)(3,f.Zero),v.Matrix=(0,c.f)(8,V.Identity),(0,z.g)("BABYLON.Vector2",Z),(0,z.g)("BABYLON.Vector3",k),(0,z.g)("BABYLON.Vector4",S),(0,z.g)("BABYLON.Matrix",V);const X=V.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)},12604:(I,g,b)=>{function e(I,g){const b=[];for(let e=0;e<I;++e)b.push(g());return b}function c(I,g){return e(I,g)}b.d(g,{e:()=>e,f:()=>c,h:()=>M});const z=["push","splice","pop","shift","unshift"];function M(I,g){const b=z.map((b=>function(I,g,b){const e=I[g];if("function"!==typeof e)return null;const c=function(){const e=I.length,z=c.previous.apply(I,arguments);return b(g,e),z};return e.next=c,c.previous=e,I[g]=c,()=>{const b=c.previous;if(!b)return;const e=c.next;e?(b.next=e,e.previous=b):(b.next=void 0,I[g]=b),c.next=void 0,c.previous=void 0}}(I,b,g)));return()=>{for(const I of b)null===I||void 0===I||I()}}}}]);